<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemoryObjectStoreCursor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteIDBBackingStore.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;SQLiteIDBBackingStore.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
  31 #include &quot;IDBBindingUtilities.h&quot;

  32 #include &quot;IDBGetAllRecordsData.h&quot;
  33 #include &quot;IDBGetAllResult.h&quot;
  34 #include &quot;IDBGetRecordData.h&quot;
  35 #include &quot;IDBGetResult.h&quot;
  36 #include &quot;IDBIterateCursorData.h&quot;
  37 #include &quot;IDBKeyData.h&quot;
  38 #include &quot;IDBObjectStoreInfo.h&quot;
  39 #include &quot;IDBSerialization.h&quot;

  40 #include &quot;IDBTransactionInfo.h&quot;
  41 #include &quot;IDBValue.h&quot;
  42 #include &quot;IndexKey.h&quot;
  43 #include &quot;Logging.h&quot;
  44 #include &quot;SQLiteDatabase.h&quot;
  45 #include &quot;SQLiteFileSystem.h&quot;
  46 #include &quot;SQLiteIDBCursor.h&quot;
  47 #include &quot;SQLiteStatement.h&quot;
  48 #include &quot;SQLiteTransaction.h&quot;
  49 #include &quot;ThreadSafeDataBuffer.h&quot;
  50 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
<span class="line-modified">  51 #include &lt;JavaScriptCore/HeapInlines.h&gt;</span>
<span class="line-removed">  52 #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;</span>
<span class="line-removed">  53 #include &lt;JavaScriptCore/JSGlobalObject.h&gt;</span>
  54 #include &lt;JavaScriptCore/StrongInlines.h&gt;
<span class="line-removed">  55 #include &lt;JavaScriptCore/StructureInlines.h&gt;</span>
  56 #include &lt;wtf/FileSystem.h&gt;
  57 #include &lt;wtf/NeverDestroyed.h&gt;
  58 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  59 
  60 namespace WebCore {
  61 using namespace JSC;
  62 namespace IDBServer {
  63 
  64 // Current version of the metadata schema being used in the metadata database.
  65 static const int currentMetadataVersion = 1;
  66 
  67 // The IndexedDatabase spec defines the max key generator value as 2^53.
  68 static const uint64_t maxGeneratorValue = 0x20000000000000;
  69 
  70 static int idbKeyCollate(int aLength, const void* aBuffer, int bLength, const void* bBuffer)
  71 {
  72     IDBKeyData a, b;
  73     if (!deserializeIDBKeyData(static_cast&lt;const uint8_t*&gt;(aBuffer), aLength, a)) {
  74         LOG_ERROR(&quot;Unable to deserialize key A in collation function.&quot;);
  75 
</pre>
<hr />
<pre>
 213     return blobRecordsTableSchemaString;
 214 }
 215 
 216 static const String blobFilesTableSchema(const String&amp; tableName)
 217 {
 218     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (blobURL TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, fileName TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL)&quot;);
 219 }
 220 
 221 static const String&amp; blobFilesTableSchema()
 222 {
 223     static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;BlobFiles&quot;));
 224     return blobFilesTableSchemaString;
 225 }
 226 
 227 static const String&amp; blobFilesTableSchemaAlternate()
 228 {
 229     static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;\&quot;BlobFiles\&quot;&quot;));
 230     return blobFilesTableSchemaString;
 231 }
 232 
<span class="line-modified"> 233 SQLiteIDBBackingStore::SQLiteIDBBackingStore(const IDBDatabaseIdentifier&amp; identifier, const String&amp; databaseRootDirectory, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, uint64_t quota)</span>
<span class="line-modified"> 234     : m_identifier(identifier)</span>


 235     , m_temporaryFileHandler(fileHandler)
<span class="line-modified"> 236     , m_quota(quota)</span>
 237 {
<span class="line-modified"> 238     m_absoluteDatabaseDirectory = identifier.databaseDirectoryRelativeToRoot(databaseRootDirectory);</span>
 239 }
 240 
 241 SQLiteIDBBackingStore::~SQLiteIDBBackingStore()
 242 {
 243     if (m_sqliteDB)
 244         closeSQLiteDB();
<span class="line-removed"> 245 </span>
<span class="line-removed"> 246     if (m_vm) {</span>
<span class="line-removed"> 247         JSLockHolder locker(m_vm.get());</span>
<span class="line-removed"> 248         m_globalObject.clear();</span>
<span class="line-removed"> 249         m_vm = nullptr;</span>
<span class="line-removed"> 250     }</span>
<span class="line-removed"> 251 }</span>
<span class="line-removed"> 252 </span>
<span class="line-removed"> 253 </span>
<span class="line-removed"> 254 void SQLiteIDBBackingStore::initializeVM()</span>
<span class="line-removed"> 255 {</span>
<span class="line-removed"> 256     if (!m_vm) {</span>
<span class="line-removed"> 257         ASSERT(!m_globalObject);</span>
<span class="line-removed"> 258         m_vm = VM::create();</span>
<span class="line-removed"> 259 </span>
<span class="line-removed"> 260         JSLockHolder locker(m_vm.get());</span>
<span class="line-removed"> 261         m_globalObject.set(*m_vm, JSGlobalObject::create(*m_vm, JSGlobalObject::createStructure(*m_vm, jsNull())));</span>
<span class="line-removed"> 262     }</span>
<span class="line-removed"> 263 }</span>
<span class="line-removed"> 264 </span>
<span class="line-removed"> 265 VM&amp; SQLiteIDBBackingStore::vm()</span>
<span class="line-removed"> 266 {</span>
<span class="line-removed"> 267     initializeVM();</span>
<span class="line-removed"> 268     return *m_vm;</span>
<span class="line-removed"> 269 }</span>
<span class="line-removed"> 270 </span>
<span class="line-removed"> 271 JSGlobalObject&amp; SQLiteIDBBackingStore::globalObject()</span>
<span class="line-removed"> 272 {</span>
<span class="line-removed"> 273     initializeVM();</span>
<span class="line-removed"> 274     return **m_globalObject;</span>
 275 }
 276 
 277 static bool createOrMigrateRecordsTableIfNecessary(SQLiteDatabase&amp; database)
 278 {
 279     String currentSchema;
 280     {
 281         // Fetch the schema for an existing records table.
 282         SQLiteStatement statement(database, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;Records&#39;&quot;);
 283         if (statement.prepare() != SQLITE_OK) {
 284             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the Records table.&quot;);
 285             return false;
 286         }
 287 
 288         int sqliteResult = statement.step();
 289 
 290         // If there is no Records table at all, create it and then bail.
 291         if (sqliteResult == SQLITE_DONE) {
 292             if (!database.executeCommand(v3RecordsTableSchema())) {
 293                 LOG_ERROR(&quot;Could not create Records table in database (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 294                 return false;
</pre>
<hr />
<pre>
 607     {
 608         // Database versions are defined to be a uin64_t in the spec but sqlite3 doesn&#39;t support native binding of unsigned integers.
 609         // Therefore we&#39;ll store the version as a String.
 610         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;DatabaseVersion&#39;, ?);&quot;_s);
 611         if (sql.prepare() != SQLITE_OK
 612             || sql.bindText(1, String::number(0)) != SQLITE_OK
 613             || sql.step() != SQLITE_DONE) {
 614             LOG_ERROR(&quot;Could not insert default version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 615             closeSQLiteDB();
 616             return nullptr;
 617         }
 618     }
 619 
 620     if (!m_sqliteDB-&gt;executeCommand(&quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;MaxObjectStoreID&#39;, 1);&quot;_s)) {
 621         LOG_ERROR(&quot;Could not insert default version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 622         closeSQLiteDB();
 623         return nullptr;
 624     }
 625 
 626     // This initial database info matches the default values we just put into the metadata database.
<span class="line-modified"> 627     return std::make_unique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), 0);</span>
 628 }
 629 
 630 std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::extractExistingDatabaseInfo()
 631 {
 632     ASSERT(m_sqliteDB);
 633 
 634     if (!m_sqliteDB-&gt;tableExists(&quot;IDBDatabaseInfo&quot;_s))
 635         return nullptr;
 636 
 637     String databaseName;
 638     {
 639         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseName&#39;;&quot;);
 640         if (sql.isColumnNull(0))
 641             return nullptr;
 642         databaseName = sql.getColumnText(0);
 643         if (databaseName != m_identifier.databaseName()) {
 644             LOG_ERROR(&quot;Database name in the info database (&#39;%s&#39;) does not match the expected name (&#39;%s&#39;)&quot;, databaseName.utf8().data(), m_identifier.databaseName().utf8().data());
 645             return nullptr;
 646         }
 647     }
 648     uint64_t databaseVersion;
 649     {
 650         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseVersion&#39;;&quot;_s);
 651         if (sql.isColumnNull(0))
 652             return nullptr;
 653         String stringVersion = sql.getColumnText(0);
 654         bool ok;
 655         databaseVersion = stringVersion.toUInt64Strict(&amp;ok);
 656         if (!ok) {
 657             LOG_ERROR(&quot;Database version on disk (&#39;%s&#39;) does not cleanly convert to an unsigned 64-bit integer version&quot;, stringVersion.utf8().data());
 658             return nullptr;
 659         }
 660     }
 661 
<span class="line-modified"> 662     auto databaseInfo = std::make_unique&lt;IDBDatabaseInfo&gt;(databaseName, databaseVersion);</span>
 663 
 664     {
 665         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, keyPath, autoInc, maxIndexID FROM ObjectStoreInfo;&quot;_s);
 666         if (sql.prepare() != SQLITE_OK)
 667             return nullptr;
 668 
 669         int result = sql.step();
 670         while (result == SQLITE_ROW) {
 671             uint64_t objectStoreID = sql.getColumnInt64(0);
 672             String objectStoreName = sql.getColumnText(1);
 673 
 674             Vector&lt;char&gt; keyPathBuffer;
 675             sql.getColumnBlobAsVector(2, keyPathBuffer);
 676 
 677             Optional&lt;IDBKeyPath&gt; objectStoreKeyPath;
 678             if (!deserializeIDBKeyPath(reinterpret_cast&lt;const uint8_t*&gt;(keyPathBuffer.data()), keyPathBuffer.size(), objectStoreKeyPath)) {
 679                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 680                 return nullptr;
 681             }
 682 
</pre>
<hr />
<pre>
 747 
 748     String partiallyDecoded = encodedName;
 749     partiallyDecoded.replace(&quot;%2E&quot;_s, &quot;.&quot;_s);
 750 
 751     return FileSystem::decodeFromFilename(partiallyDecoded);
 752 }
 753 
 754 String SQLiteIDBBackingStore::filenameForDatabaseName() const
 755 {
 756     ASSERT(!m_identifier.databaseName().isNull());
 757 
 758     if (m_identifier.databaseName().isEmpty())
 759         return &quot;%00&quot;;
 760 
 761     String filename = FileSystem::encodeForFileName(m_identifier.databaseName());
 762     filename.replace(&#39;.&#39;, &quot;%2E&quot;);
 763 
 764     return filename;
 765 }
 766 
<span class="line-modified"> 767 String SQLiteIDBBackingStore::fullDatabaseDirectory() const</span>
 768 {
<span class="line-modified"> 769     ASSERT(!m_identifier.databaseName().isNull());</span>
<span class="line-removed"> 770 </span>
<span class="line-removed"> 771     return FileSystem::pathByAppendingComponent(m_absoluteDatabaseDirectory, filenameForDatabaseName());</span>
 772 }
 773 
 774 String SQLiteIDBBackingStore::fullDatabasePath() const
 775 {
<span class="line-modified"> 776     ASSERT(!m_identifier.databaseName().isNull());</span>

 777 
<span class="line-modified"> 778     return FileSystem::pathByAppendingComponent(fullDatabaseDirectory(), &quot;IndexedDB.sqlite3&quot;);</span>


































 779 }
 780 
 781 IDBError SQLiteIDBBackingStore::getOrEstablishDatabaseInfo(IDBDatabaseInfo&amp; info)
 782 {
 783     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getOrEstablishDatabaseInfo - database %s&quot;, m_identifier.databaseName().utf8().data());
 784 
 785     if (m_databaseInfo) {
 786         info = *m_databaseInfo;
 787         return IDBError { };
 788     }
 789 
<span class="line-removed"> 790     FileSystem::makeAllDirectories(fullDatabaseDirectory());</span>
 791     String dbFilename = fullDatabasePath();
 792 
<span class="line-modified"> 793     m_sqliteDB = std::make_unique&lt;SQLiteDatabase&gt;();</span>
 794     if (!m_sqliteDB-&gt;open(dbFilename)) {
 795         LOG_ERROR(&quot;Failed to open SQLite database at path &#39;%s&#39;&quot;, dbFilename.utf8().data());
 796         closeSQLiteDB();
 797     }
 798 
 799     if (!m_sqliteDB)
 800         return IDBError { UnknownError, &quot;Unable to open database file on disk&quot;_s };
 801 
 802     m_sqliteDB-&gt;setCollationFunction(&quot;IDBKEY&quot;, [](int aLength, const void* a, int bLength, const void* b) {
 803         return idbKeyCollate(aLength, a, bLength, b);
 804     });
 805 
 806     if (!ensureValidRecordsTable()) {
 807         LOG_ERROR(&quot;Error creating or migrating Records table in database&quot;);
 808         closeSQLiteDB();
 809         return IDBError { UnknownError, &quot;Error creating or migrating Records table in database&quot;_s };
 810     }
 811 
 812     if (!ensureValidIndexRecordsTable()) {
 813         LOG_ERROR(&quot;Error creating or migrating Index Records table in database&quot;);
</pre>
<hr />
<pre>
 825         LOG_ERROR(&quot;Error creating or confirming Blob Records tables in database&quot;);
 826         closeSQLiteDB();
 827         return IDBError { UnknownError, &quot;Error creating or confirming Blob Records tables in database&quot;_s };
 828     }
 829 
 830     auto databaseInfo = extractExistingDatabaseInfo();
 831     if (!databaseInfo)
 832         databaseInfo = createAndPopulateInitialDatabaseInfo();
 833 
 834     if (!databaseInfo) {
 835         LOG_ERROR(&quot;Unable to establish IDB database at path &#39;%s&#39;&quot;, dbFilename.utf8().data());
 836         closeSQLiteDB();
 837         return IDBError { UnknownError, &quot;Unable to establish IDB database file&quot;_s };
 838     }
 839 
 840     m_databaseInfo = WTFMove(databaseInfo);
 841     info = *m_databaseInfo;
 842     return IDBError { };
 843 }
 844 
<span class="line-modified"> 845 uint64_t SQLiteIDBBackingStore::quotaForOrigin() const</span>
<span class="line-removed"> 846 {</span>
<span class="line-removed"> 847     ASSERT(!isMainThread());</span>
<span class="line-removed"> 848     uint64_t diskFreeSpaceSize = 0;</span>
<span class="line-removed"> 849     FileSystem::getVolumeFreeSpace(m_absoluteDatabaseDirectory, diskFreeSpaceSize);</span>
<span class="line-removed"> 850     return std::min(diskFreeSpaceSize / 2, m_quota);</span>
<span class="line-removed"> 851 }</span>
<span class="line-removed"> 852 </span>
<span class="line-removed"> 853 uint64_t SQLiteIDBBackingStore::maximumSize() const</span>
 854 {
<span class="line-removed"> 855     ASSERT(!isMainThread());</span>
<span class="line-removed"> 856 </span>
<span class="line-removed"> 857     // The maximum size for one database file is the quota for its origin, minus size of all databases within that origin,</span>
<span class="line-removed"> 858     // and plus current size of the database file.</span>
<span class="line-removed"> 859     uint64_t databaseFileSize = SQLiteFileSystem::getDatabaseFileSize(fullDatabasePath());</span>
<span class="line-removed"> 860     uint64_t quota = quotaForOrigin();</span>
<span class="line-removed"> 861 </span>
 862     uint64_t diskUsage = 0;
<span class="line-modified"> 863     for (auto&amp; directory : FileSystem::listDirectory(m_absoluteDatabaseDirectory, &quot;*&quot;)) {</span>
<span class="line-modified"> 864         for (auto&amp; file : FileSystem::listDirectory(directory, &quot;*.sqlite3&quot;_s))</span>
 865             diskUsage += SQLiteFileSystem::getDatabaseFileSize(file);
 866     }
<span class="line-modified"> 867     ASSERT(diskUsage &gt;= databaseFileSize);</span>
<span class="line-modified"> 868 </span>
<span class="line-removed"> 869     if (quota &lt; diskUsage)</span>
<span class="line-removed"> 870         return databaseFileSize;</span>
 871 
<span class="line-modified"> 872     return quota - diskUsage + databaseFileSize;</span>



 873 }
 874 
 875 IDBError SQLiteIDBBackingStore::beginTransaction(const IDBTransactionInfo&amp; info)
 876 {
 877     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::beginTransaction - %s&quot;, info.identifier().loggingString().utf8().data());
 878 
 879     ASSERT(m_sqliteDB);
 880     ASSERT(m_sqliteDB-&gt;isOpen());
 881     ASSERT(m_databaseInfo);
 882 
<span class="line-removed"> 883     m_sqliteDB-&gt;setMaximumSize(maximumSize());</span>
 884     auto addResult = m_transactions.add(info.identifier(), nullptr);
 885     if (!addResult.isNewEntry) {
 886         LOG_ERROR(&quot;Attempt to establish transaction identifier that already exists&quot;);
 887         return IDBError { UnknownError, &quot;Attempt to establish transaction identifier that already exists&quot;_s };
 888     }
 889 
<span class="line-modified"> 890     addResult.iterator-&gt;value = std::make_unique&lt;SQLiteIDBTransaction&gt;(*this, info);</span>
 891 
 892     auto error = addResult.iterator-&gt;value-&gt;begin(*m_sqliteDB);
 893     if (error.isNull() &amp;&amp; info.mode() == IDBTransactionMode::Versionchange) {
<span class="line-modified"> 894         m_originalDatabaseInfoBeforeVersionChange = std::make_unique&lt;IDBDatabaseInfo&gt;(*m_databaseInfo);</span>
 895 
 896         SQLiteStatement sql(*m_sqliteDB, &quot;UPDATE IDBDatabaseInfo SET value = ? where key = &#39;DatabaseVersion&#39;;&quot;_s);
 897         if (sql.prepare() != SQLITE_OK
 898             || sql.bindText(1, String::number(info.newVersion())) != SQLITE_OK
 899             || sql.step() != SQLITE_DONE) {
<span class="line-modified"> 900             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed"> 901                 error = IDBError { QuotaExceededError, &quot;Failed to store new database version in database because no enough space for domain&quot;_s };</span>
<span class="line-removed"> 902             else</span>
<span class="line-removed"> 903                 error = IDBError { UnknownError, &quot;Failed to store new database version in database&quot;_s };</span>
 904         }
 905     }
 906 
 907     return error;
 908 }
 909 
 910 IDBError SQLiteIDBBackingStore::abortTransaction(const IDBResourceIdentifier&amp; identifier)
 911 {
 912     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::abortTransaction - %s&quot;, identifier.loggingString().utf8().data());
 913 
 914     ASSERT(m_sqliteDB);
 915     ASSERT(m_sqliteDB-&gt;isOpen());
 916 
 917     auto transaction = m_transactions.take(identifier);
 918     if (!transaction) {
 919         LOG_ERROR(&quot;Attempt to commit a transaction that hasn&#39;t been established&quot;);
 920         return IDBError { UnknownError, &quot;Attempt to abort a transaction that hasn&#39;t been established&quot;_s };
 921     }
 922 
 923     if (transaction-&gt;mode() == IDBTransactionMode::Versionchange &amp;&amp; m_originalDatabaseInfoBeforeVersionChange)
</pre>
<hr />
<pre>
 942     auto error = transaction-&gt;commit();
 943     if (!error.isNull()) {
 944         if (transaction-&gt;mode() == IDBTransactionMode::Versionchange) {
 945             ASSERT(m_originalDatabaseInfoBeforeVersionChange);
 946             m_databaseInfo = WTFMove(m_originalDatabaseInfoBeforeVersionChange);
 947         }
 948     } else
 949         m_originalDatabaseInfoBeforeVersionChange = nullptr;
 950 
 951     return error;
 952 }
 953 
 954 IDBError SQLiteIDBBackingStore::createObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; info)
 955 {
 956     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::createObjectStore - adding OS %s with ID %&quot; PRIu64, info.name().utf8().data(), info.identifier());
 957 
 958     ASSERT(m_sqliteDB);
 959     ASSERT(m_sqliteDB-&gt;isOpen());
 960 
 961     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified"> 962     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed"> 963         LOG_ERROR(&quot;Attempt to create an object store without an in-progress transaction&quot;);</span>
 964         return IDBError { UnknownError, &quot;Attempt to create an object store without an in-progress transaction&quot;_s };
<span class="line-modified"> 965     }</span>
 966     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
 967         LOG_ERROR(&quot;Attempt to create an object store in a non-version-change transaction&quot;);
 968         return IDBError { UnknownError, &quot;Attempt to create an object store in a non-version-change transaction&quot;_s };
 969     }
 970 
 971     RefPtr&lt;SharedBuffer&gt; keyPathBlob = serializeIDBKeyPath(info.keyPath());
 972     if (!keyPathBlob) {
 973         LOG_ERROR(&quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;);
 974         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;_s };
 975     }
 976 
 977     {
 978         auto* sql = cachedStatement(SQL::CreateObjectStoreInfo, &quot;INSERT INTO ObjectStoreInfo VALUES (?, ?, ?, ?, ?);&quot;_s);
 979         if (!sql
 980             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
 981             || sql-&gt;bindText(2, info.name()) != SQLITE_OK
 982             || sql-&gt;bindBlob(3, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
 983             || sql-&gt;bindInt(4, info.autoIncrement()) != SQLITE_OK
 984             || sql-&gt;bindInt64(5, info.maxIndexID()) != SQLITE_OK
 985             || sql-&gt;step() != SQLITE_DONE) {
 986             LOG_ERROR(&quot;Could not add object store &#39;%s&#39; to ObjectStoreInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed"> 987             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed"> 988                 return IDBError { QuotaExceededError, &quot;Could not create object store because no enough space for domain&quot;_s };</span>
 989             return IDBError { UnknownError, &quot;Could not create object store&quot;_s };
 990         }
 991     }
 992 
 993     {
 994         auto* sql = cachedStatement(SQL::CreateObjectStoreKeyGenerator, &quot;INSERT INTO KeyGenerators VALUES (?, 0);&quot;_s);
 995         if (!sql
 996             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
 997             || sql-&gt;step() != SQLITE_DONE) {
 998             LOG_ERROR(&quot;Could not seed initial key generator value for ObjectStoreInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed"> 999             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1000                 return IDBError { QuotaExceededError, &quot;Could not seed initial key generator value for object store because no enough space for domain&quot;_s };</span>
1001             return IDBError { UnknownError, &quot;Could not seed initial key generator value for object store&quot;_s };
1002         }
1003     }
1004 
1005     m_databaseInfo-&gt;addExistingObjectStore(info);
1006 
1007     return IDBError { };
1008 }
1009 
1010 IDBError SQLiteIDBBackingStore::deleteObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
1011 {
1012     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteObjectStore - object store %&quot; PRIu64, objectStoreIdentifier);
1013 
1014     ASSERT(m_sqliteDB);
1015     ASSERT(m_sqliteDB-&gt;isOpen());
1016 
1017     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1018     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1019         LOG_ERROR(&quot;Attempt to delete an object store without an in-progress transaction&quot;);</span>
1020         return IDBError { UnknownError, &quot;Attempt to delete an object store without an in-progress transaction&quot;_s };
<span class="line-modified">1021     }</span>
1022     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1023         LOG_ERROR(&quot;Attempt to delete an object store in a non-version-change transaction&quot;);
1024         return IDBError { UnknownError, &quot;Attempt to delete an object store in a non-version-change transaction&quot;_s };
1025     }
1026 
1027     // Delete the ObjectStore record
1028     {
1029         auto* sql = cachedStatement(SQL::DeleteObjectStoreInfo, &quot;DELETE FROM ObjectStoreInfo WHERE id = ?;&quot;_s);
1030         if (!sql
1031             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1032             || sql-&gt;step() != SQLITE_DONE) {
1033             LOG_ERROR(&quot;Could not delete object store id %&quot; PRIi64 &quot; from ObjectStoreInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1034             return IDBError { UnknownError, &quot;Could not delete object store&quot;_s };
1035         }
1036     }
1037 
1038     // Delete the ObjectStore&#39;s key generator record if there is one.
1039     {
1040         auto* sql = cachedStatement(SQL::DeleteObjectStoreKeyGenerator, &quot;DELETE FROM KeyGenerators WHERE objectStoreID = ?;&quot;_s);
1041         if (!sql
</pre>
<hr />
<pre>
1090     }
1091 
1092     // Delete all unused Blob File records.
1093     auto error = deleteUnusedBlobFileRecords(*transaction);
1094     if (!error.isNull())
1095         return error;
1096 
1097     m_databaseInfo-&gt;deleteObjectStore(objectStoreIdentifier);
1098 
1099     return IDBError { };
1100 }
1101 
1102 IDBError SQLiteIDBBackingStore::renameObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const String&amp; newName)
1103 {
1104     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::renameObjectStore - object store %&quot; PRIu64, objectStoreIdentifier);
1105 
1106     ASSERT(m_sqliteDB);
1107     ASSERT(m_sqliteDB-&gt;isOpen());
1108 
1109     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1110     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1111         LOG_ERROR(&quot;Attempt to rename an object store without an in-progress transaction&quot;);</span>
1112         return IDBError { UnknownError, &quot;Attempt to rename an object store without an in-progress transaction&quot;_s };
<span class="line-modified">1113     }</span>
1114     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1115         LOG_ERROR(&quot;Attempt to rename an object store in a non-version-change transaction&quot;);
1116         return IDBError { UnknownError, &quot;Attempt to rename an object store in a non-version-change transaction&quot;_s };
1117     }
1118 
1119     {
1120         auto* sql = cachedStatement(SQL::RenameObjectStore, &quot;UPDATE ObjectStoreInfo SET name = ? WHERE id = ?;&quot;_s);
1121         if (!sql
1122             || sql-&gt;bindText(1, newName) != SQLITE_OK
1123             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1124             || sql-&gt;step() != SQLITE_DONE) {
1125             LOG_ERROR(&quot;Could not update name for object store id %&quot; PRIi64 &quot; in ObjectStoreInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed">1126             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1127                 return IDBError { QuotaExceededError, &quot;Could not rename object store because no enough space for domain&quot;_s };</span>
1128             return IDBError { UnknownError, &quot;Could not rename object store&quot;_s };
1129         }
1130     }
1131 
1132     m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
1133 
1134     return IDBError { };
1135 }
1136 
1137 IDBError SQLiteIDBBackingStore::clearObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID)
1138 {
1139     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::clearObjectStore - object store %&quot; PRIu64, objectStoreID);
1140 
1141     ASSERT(m_sqliteDB);
1142     ASSERT(m_sqliteDB-&gt;isOpen());
1143 
1144     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1145     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1146         LOG_ERROR(&quot;Attempt to clear an object store without an in-progress transaction&quot;);</span>
1147         return IDBError { UnknownError, &quot;Attempt to clear an object store without an in-progress transaction&quot;_s };
<span class="line-modified">1148     }</span>
1149     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1150         LOG_ERROR(&quot;Attempt to clear an object store in a read-only transaction&quot;);
1151         return IDBError { UnknownError, &quot;Attempt to clear an object store in a read-only transaction&quot;_s };
1152     }
1153 
1154     {
1155         auto* sql = cachedStatement(SQL::ClearObjectStoreRecords, &quot;DELETE FROM Records WHERE objectStoreID = ?;&quot;_s);
1156         if (!sql
1157             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1158             || sql-&gt;step() != SQLITE_DONE) {
1159             LOG_ERROR(&quot;Could not clear records from object store id %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1160             return IDBError { UnknownError, &quot;Unable to clear object store&quot;_s };
1161         }
1162     }
1163 
1164     {
1165         auto* sql = cachedStatement(SQL::ClearObjectStoreIndexRecords, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ?;&quot;_s);
1166         if (!sql
1167             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1168             || sql-&gt;step() != SQLITE_DONE) {
1169             LOG_ERROR(&quot;Could not delete records from index record store id %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1170             return IDBError { UnknownError, &quot;Unable to delete index records while clearing object store&quot;_s };
1171         }
1172     }
1173 
1174     transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1175 
1176     return IDBError { };
1177 }
1178 
1179 IDBError SQLiteIDBBackingStore::createIndex(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)
1180 {
1181     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::createIndex - ObjectStore %&quot; PRIu64 &quot;, Index %&quot; PRIu64, info.objectStoreIdentifier(), info.identifier());
1182     ASSERT(m_sqliteDB);
1183     ASSERT(m_sqliteDB-&gt;isOpen());
1184 
1185     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1186     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1187         LOG_ERROR(&quot;Attempt to create an index without an in-progress transaction&quot;);</span>
1188         return IDBError { UnknownError, &quot;Attempt to create an index without an in-progress transaction&quot;_s };
<span class="line-modified">1189     }</span>
1190     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1191         LOG_ERROR(&quot;Attempt to create an index in a non-version-change transaction&quot;);
1192         return IDBError { UnknownError, &quot;Attempt to create an index in a non-version-change transaction&quot;_s };
1193     }
1194 
1195     RefPtr&lt;SharedBuffer&gt; keyPathBlob = serializeIDBKeyPath(info.keyPath());
1196     if (!keyPathBlob) {
1197         LOG_ERROR(&quot;Unable to serialize IDBKeyPath to save in database&quot;);
1198         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyPath to create index in database&quot;_s };
1199     }
1200 
1201     auto* sql = cachedStatement(SQL::CreateIndexInfo, &quot;INSERT INTO IndexInfo VALUES (?, ?, ?, ?, ?, ?);&quot;_s);
1202     if (!sql
1203         || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1204         || sql-&gt;bindText(2, info.name()) != SQLITE_OK
1205         || sql-&gt;bindInt64(3, info.objectStoreIdentifier()) != SQLITE_OK
1206         || sql-&gt;bindBlob(4, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
1207         || sql-&gt;bindInt(5, info.unique()) != SQLITE_OK
1208         || sql-&gt;bindInt(6, info.multiEntry()) != SQLITE_OK
1209         || sql-&gt;step() != SQLITE_DONE) {
1210         LOG_ERROR(&quot;Could not add index &#39;%s&#39; to IndexInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed">1211         if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1212             return IDBError { QuotaExceededError, &quot;Unable to create index in database because no enough space for domain&quot;_s };</span>
1213         return IDBError { UnknownError, &quot;Unable to create index in database&quot;_s };
1214     }
1215 
1216     // Write index records for any records that already exist in this object store.
1217 
1218     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(info.objectStoreIdentifier(), 0, IDBKeyRangeData::allKeys());
1219 
1220     if (!cursor) {
1221         LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);
1222         return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
1223     }
1224 
1225     while (!cursor-&gt;currentKey().isNull()) {
1226         auto&amp; key = cursor-&gt;currentKey();
1227         auto* value = cursor-&gt;currentValue();
1228         ThreadSafeDataBuffer valueBuffer = value ? value-&gt;data() : ThreadSafeDataBuffer();
1229 
1230         ASSERT(cursor-&gt;currentRecordRowID());
1231 
1232         IDBError error = updateOneIndexForAddRecord(info, key, valueBuffer, cursor-&gt;currentRecordRowID());
1233         if (!error.isNull()) {
1234             auto* sql = cachedStatement(SQL::DeleteIndexInfo, &quot;DELETE FROM IndexInfo WHERE id = ? AND objectStoreID = ?;&quot;_s);
1235             if (!sql
1236                 || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1237                 || sql-&gt;bindInt64(2, info.objectStoreIdentifier()) != SQLITE_OK
1238                 || sql-&gt;step() != SQLITE_DONE) {
1239                 LOG_ERROR(&quot;Index creation failed due to uniqueness constraint failure, but there was an error deleting the Index record from the database&quot;);
1240                 return IDBError { UnknownError, &quot;Index creation failed due to uniqueness constraint failure, but there was an error deleting the Index record from the database&quot;_s };
1241             }
1242 
1243             return error;
1244         }
1245 
1246         if (!cursor-&gt;advance(1)) {
1247             LOG_ERROR(&quot;Error advancing cursor while indexing existing records for new index.&quot;);
1248             return IDBError { UnknownError, &quot;Error advancing cursor while indexing existing records for new index&quot;_s };
1249         }
1250     }
1251 






1252     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
1253     ASSERT(objectStore);
1254     objectStore-&gt;addExistingIndex(info);
1255 
1256     return IDBError { };
1257 }
1258 
1259 IDBError SQLiteIDBBackingStore::uncheckedHasIndexRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; indexKey, bool&amp; hasRecord)
1260 {
1261     hasRecord = false;
1262 
1263     RefPtr&lt;SharedBuffer&gt; indexKeyBuffer = serializeIDBKeyData(indexKey);
1264     if (!indexKeyBuffer) {
1265         LOG_ERROR(&quot;Unable to serialize index key to be stored in the database&quot;);
1266         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for index record in database&quot;_s };
1267     }
1268 
1269     auto* sql = cachedStatement(SQL::HasIndexRecord, &quot;SELECT rowid FROM IndexRecords WHERE indexID = ? AND objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1270     if (!sql
1271         || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
</pre>
<hr />
<pre>
1335         LOG_ERROR(&quot;Unable to serialize index key to be stored in the database&quot;);
1336         return IDBError { UnknownError, &quot;Unable to serialize index key to be stored in the database&quot;_s };
1337     }
1338 
1339     RefPtr&lt;SharedBuffer&gt; valueBuffer = serializeIDBKeyData(keyValue);
1340     if (!valueBuffer) {
1341         LOG_ERROR(&quot;Unable to serialize the value to be stored in the database&quot;);
1342         return IDBError { UnknownError, &quot;Unable to serialize value to be stored in the database&quot;_s };
1343     }
1344 
1345     {
1346         auto* sql = cachedStatement(SQL::PutIndexRecord, &quot;INSERT INTO IndexRecords VALUES (?, ?, CAST(? AS TEXT), CAST(? AS TEXT), ?);&quot;_s);
1347         if (!sql
1348             || sql-&gt;bindInt64(1, indexID) != SQLITE_OK
1349             || sql-&gt;bindInt64(2, objectStoreID) != SQLITE_OK
1350             || sql-&gt;bindBlob(3, indexKeyBuffer-&gt;data(), indexKeyBuffer-&gt;size()) != SQLITE_OK
1351             || sql-&gt;bindBlob(4, valueBuffer-&gt;data(), valueBuffer-&gt;size()) != SQLITE_OK
1352             || sql-&gt;bindInt64(5, recordID) != SQLITE_OK
1353             || sql-&gt;step() != SQLITE_DONE) {
1354             LOG_ERROR(&quot;Could not put index record for index %&quot; PRIi64 &quot; in object store %&quot; PRIi64 &quot; in Records table (%i) - %s&quot;, indexID, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed">1355             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1356                 return IDBError { QuotaExceededError, &quot;Error putting index record into database because no enough space for domain&quot;_s };</span>
1357             return IDBError { UnknownError, &quot;Error putting index record into database&quot;_s };
1358         }
1359     }
1360 
1361     return IDBError { };
1362 }
1363 
1364 
1365 IDBError SQLiteIDBBackingStore::deleteIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)
1366 {
1367     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteIndex - object store %&quot; PRIu64, objectStoreIdentifier);
1368 
1369     ASSERT(m_sqliteDB);
1370     ASSERT(m_sqliteDB-&gt;isOpen());
1371 
1372     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1373     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1374         LOG_ERROR(&quot;Attempt to delete index without an in-progress transaction&quot;);</span>
1375         return IDBError { UnknownError, &quot;Attempt to delete index without an in-progress transaction&quot;_s };
<span class="line-removed">1376     }</span>
1377 
1378     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1379         LOG_ERROR(&quot;Attempt to delete index during a non-version-change transaction&quot;);
1380         return IDBError { UnknownError, &quot;Attempt to delete index during a non-version-change transaction&quot;_s };
1381     }
1382 
1383     {
1384         auto* sql = cachedStatement(SQL::DeleteIndexInfo, &quot;DELETE FROM IndexInfo WHERE id = ? AND objectStoreID = ?;&quot;_s);
1385         if (!sql
1386             || sql-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK
1387             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1388             || sql-&gt;step() != SQLITE_DONE) {
1389             LOG_ERROR(&quot;Could not delete index id %&quot; PRIi64 &quot; from IndexInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1390             return IDBError { UnknownError, &quot;Error deleting index from database&quot;_s };
1391         }
1392     }
1393 
1394     {
1395         auto* sql = cachedStatement(SQL::DeleteIndexRecords, &quot;DELETE FROM IndexRecords WHERE indexID = ? AND objectStoreID = ?;&quot;_s);
1396         if (!sql
</pre>
<hr />
<pre>
1408 
1409     return IDBError { };
1410 }
1411 
1412 IDBError SQLiteIDBBackingStore::renameIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
1413 {
1414     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::renameIndex - object store %&quot; PRIu64 &quot;, index %&quot; PRIu64, objectStoreIdentifier, indexIdentifier);
1415 
1416     ASSERT(m_sqliteDB);
1417     ASSERT(m_sqliteDB-&gt;isOpen());
1418 
1419     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1420     if (!objectStoreInfo)
1421         return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1422 
1423     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
1424     if (!indexInfo)
1425         return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1426 
1427     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1428     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1429         LOG_ERROR(&quot;Attempt to rename an index without an in-progress transaction&quot;);</span>
1430         return IDBError { UnknownError, &quot;Attempt to rename an index without an in-progress transaction&quot;_s };
<span class="line-removed">1431     }</span>
1432 
1433     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1434         LOG_ERROR(&quot;Attempt to rename an index in a non-version-change transaction&quot;);
1435         return IDBError { UnknownError, &quot;Attempt to rename an index in a non-version-change transaction&quot;_s };
1436     }
1437 
1438     {
1439         auto* sql = cachedStatement(SQL::RenameIndex, &quot;UPDATE IndexInfo SET name = ? WHERE objectStoreID = ? AND id = ?;&quot;_s);
1440         if (!sql
1441             || sql-&gt;bindText(1, newName) != SQLITE_OK
1442             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1443             || sql-&gt;bindInt64(3, indexIdentifier) != SQLITE_OK
1444             || sql-&gt;step() != SQLITE_DONE) {
1445             LOG_ERROR(&quot;Could not update name for index id (%&quot; PRIi64 &quot;, %&quot; PRIi64 &quot;) in IndexInfo table (%i) - %s&quot;, objectStoreIdentifier, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed">1446             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1447                 return IDBError { QuotaExceededError, &quot;Could not rename index because no enough space for domain&quot;_s };</span>
1448             return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1449         }
1450     }
1451 
1452     indexInfo-&gt;rename(newName);
1453 
1454     return IDBError { };
1455 }
1456 
1457 IDBError SQLiteIDBBackingStore::keyExistsInObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyData&amp; keyData, bool&amp; keyExists)
1458 {
1459     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::keyExistsInObjectStore - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreID);
1460 
1461     ASSERT(m_sqliteDB);
1462     ASSERT(m_sqliteDB-&gt;isOpen());
1463 
1464     keyExists = false;
1465 
1466     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1467     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1468         LOG_ERROR(&quot;Attempt to see if key exists in objectstore without an in-progress transaction&quot;);</span>
1469         return IDBError { UnknownError, &quot;Attempt to see if key exists in objectstore without an in-progress transaction&quot;_s };
<span class="line-removed">1470     }</span>
1471 
1472     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1473     if (!keyBuffer) {
1474         LOG_ERROR(&quot;Unable to serialize IDBKey to check for existence in object store&quot;);
1475         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for existence in object store&quot;_s };
1476     }
1477     auto* sql = cachedStatement(SQL::KeyExistsInObjectStore, &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT) LIMIT 1;&quot;_s);
1478     if (!sql
1479         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1480         || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK) {
1481         LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1482         return IDBError { UnknownError, &quot;Unable to check for existence of IDBKey in object store&quot;_s };
1483     }
1484 
1485     int sqlResult = sql-&gt;step();
1486     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE)
1487         return IDBError { };
1488 
1489     if (sqlResult != SQLITE_ROW) {
1490         // There was an error fetching the record from the database.
</pre>
<hr />
<pre>
1622         if (!sql
1623             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1624             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1625             || sql-&gt;step() != SQLITE_DONE) {
1626             LOG_ERROR(&quot;Could not delete record from indexes for object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1627             return IDBError { UnknownError, &quot;Failed to delete index entries for object store record&quot;_s };
1628         }
1629     }
1630 
1631     return IDBError { };
1632 }
1633 
1634 IDBError SQLiteIDBBackingStore::deleteRange(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData&amp; keyRange)
1635 {
1636     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteRange - range %s, object store %&quot; PRIu64, keyRange.loggingString().utf8().data(), objectStoreID);
1637 
1638     ASSERT(m_sqliteDB);
1639     ASSERT(m_sqliteDB-&gt;isOpen());
1640 
1641     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1642     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1643         LOG_ERROR(&quot;Attempt to delete range from database without an in-progress transaction&quot;);</span>
1644         return IDBError { UnknownError, &quot;Attempt to delete range from database without an in-progress transaction&quot;_s };
<span class="line-modified">1645     }</span>
1646     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1647         LOG_ERROR(&quot;Attempt to delete records from an object store in a read-only transaction&quot;);
1648         return IDBError { UnknownError, &quot;Attempt to delete records from an object store in a read-only transaction&quot;_s };
1649     }
1650 
1651     // If the range to delete is exactly one key we can delete it right now.
1652     if (keyRange.isExactlyOneKey()) {
1653         auto error = deleteRecord(*transaction, objectStoreID, keyRange.lowerKey);
1654         if (!error.isNull()) {
1655             LOG_ERROR(&quot;Failed to delete record for key &#39;%s&#39;&quot;, keyRange.lowerKey.loggingString().utf8().data());
1656             return error;
1657         }
1658 
1659         transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1660 
1661         return IDBError { };
1662     }
1663 
1664     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreID, 0, keyRange);
1665     if (!cursor) {
</pre>
<hr />
<pre>
1677         LOG_ERROR(&quot;Cursor failed while accumulating range of records from the database&quot;);
1678         return IDBError { UnknownError, &quot;Cursor failed while accumulating range of records from the database&quot;_s };
1679     }
1680 
1681     IDBError error;
1682     for (auto&amp; key : keys) {
1683         error = deleteRecord(*transaction, objectStoreID, key);
1684         if (!error.isNull()) {
1685             LOG_ERROR(&quot;deleteRange: Error deleting keys in range&quot;);
1686             break;
1687         }
1688     }
1689 
1690     transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1691 
1692     return error;
1693 }
1694 
1695 IDBError SQLiteIDBBackingStore::updateOneIndexForAddRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; key, const ThreadSafeDataBuffer&amp; value, int64_t recordID)
1696 {
<span class="line-modified">1697     JSLockHolder locker(vm());</span>
1698 
<span class="line-modified">1699     auto jsValue = deserializeIDBValueToJSValue(*globalObject().globalExec(), value);</span>
1700     if (jsValue.isUndefinedOrNull())
1701         return IDBError { };
1702 
1703     IndexKey indexKey;
<span class="line-modified">1704     generateIndexKeyForValue(*m_globalObject-&gt;globalExec(), info, jsValue, indexKey);</span>


1705 
1706     if (indexKey.isNull())
1707         return IDBError { };
1708 
1709     return uncheckedPutIndexKey(info, key, indexKey, recordID);
1710 }
1711 
1712 IDBError SQLiteIDBBackingStore::updateAllIndexesForAddRecord(const IDBObjectStoreInfo&amp; info, const IDBKeyData&amp; key, const ThreadSafeDataBuffer&amp; value, int64_t recordID)
1713 {
<span class="line-modified">1714     JSLockHolder locker(vm());</span>
1715 
<span class="line-modified">1716     auto jsValue = deserializeIDBValueToJSValue(*globalObject().globalExec(), value);</span>
1717     if (jsValue.isUndefinedOrNull())
1718         return IDBError { };
1719 
1720     IDBError error;
1721     bool anyRecordsSucceeded = false;
1722     for (auto&amp; index : info.indexMap().values()) {
1723         IndexKey indexKey;
<span class="line-modified">1724         generateIndexKeyForValue(*m_globalObject-&gt;globalExec(), index, jsValue, indexKey);</span>
1725 
1726         if (indexKey.isNull())
1727             continue;
1728 
1729         error = uncheckedPutIndexKey(index, key, indexKey, recordID);
1730         if (!error.isNull())
1731             break;
1732 
1733         anyRecordsSucceeded = true;
1734     }
1735 
1736     if (!error.isNull() &amp;&amp; anyRecordsSucceeded) {
1737         RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(key);
1738 
1739         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND value = CAST(? AS TEXT);&quot;_s);
1740 
1741         if (!sql
1742             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1743             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1744             || sql-&gt;step() != SQLITE_DONE) {
1745             LOG_ERROR(&quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;);
1746             return IDBError { UnknownError, &quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;_s };
1747         }
1748     }
1749 
1750     return error;
1751 }
1752 
1753 IDBError SQLiteIDBBackingStore::addRecord(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; objectStoreInfo, const IDBKeyData&amp; keyData, const IDBValue&amp; value)
1754 {
1755     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::addRecord - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreInfo.identifier());
1756 
1757     ASSERT(m_sqliteDB);
1758     ASSERT(m_sqliteDB-&gt;isOpen());
1759     ASSERT(value.data().data());
1760     ASSERT(value.blobURLs().size() == value.blobFilePaths().size());
1761 
1762     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1763     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1764         LOG_ERROR(&quot;Attempt to store a record in an object store without an in-progress transaction&quot;);</span>
1765         return IDBError { UnknownError, &quot;Attempt to store a record in an object store without an in-progress transaction&quot;_s };
<span class="line-modified">1766     }</span>
1767     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1768         LOG_ERROR(&quot;Attempt to store a record in an object store in a read-only transaction&quot;);
1769         return IDBError { UnknownError, &quot;Attempt to store a record in an object store in a read-only transaction&quot;_s };
1770     }
1771 
1772     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1773     if (!keyBuffer) {
1774         LOG_ERROR(&quot;Unable to serialize IDBKey to be stored in an object store&quot;);
1775         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to be stored in an object store&quot;_s };
1776     }
1777 
1778     int64_t recordID = 0;
1779     {
1780         auto* sql = cachedStatement(SQL::AddObjectStoreRecord, &quot;INSERT INTO Records VALUES (?, CAST(? AS TEXT), ?, NULL);&quot;_s);
1781         if (!sql
1782             || sql-&gt;bindInt64(1, objectStoreInfo.identifier()) != SQLITE_OK
1783             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1784             || sql-&gt;bindBlob(3, value.data().data()-&gt;data(), value.data().data()-&gt;size()) != SQLITE_OK
1785             || sql-&gt;step() != SQLITE_DONE) {
1786             LOG_ERROR(&quot;Could not put record for object store %&quot; PRIi64 &quot; in Records table (%i) - %s&quot;, objectStoreInfo.identifier(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed">1787             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1788                 return IDBError { QuotaExceededError, &quot;Unable to store record in object store because no enough space for domain&quot;_s };</span>
1789             return IDBError { UnknownError, &quot;Unable to store record in object store&quot;_s };
1790         }
1791 
1792         recordID = m_sqliteDB-&gt;lastInsertRowID();
1793     }
1794 
1795     auto error = updateAllIndexesForAddRecord(objectStoreInfo, keyData, value.data(), recordID);
1796 
1797     if (!error.isNull()) {
1798         auto* sql = cachedStatement(SQL::DeleteObjectStoreRecord, &quot;DELETE FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1799         if (!sql
1800             || sql-&gt;bindInt64(1, objectStoreInfo.identifier()) != SQLITE_OK
1801             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1802             || sql-&gt;step() != SQLITE_DONE) {
1803             LOG_ERROR(&quot;Indexing new object store record failed, but unable to remove the object store record itself&quot;);
1804             return IDBError { UnknownError, &quot;Indexing new object store record failed, but unable to remove the object store record itself&quot;_s };
1805         }
1806 
1807         return error;
1808     }
1809 
1810     const Vector&lt;String&gt;&amp; blobURLs = value.blobURLs();
1811     const Vector&lt;String&gt;&amp; blobFiles = value.blobFilePaths();
1812     for (size_t i = 0; i &lt; blobURLs.size(); ++i) {
1813         auto&amp; url = blobURLs[i];
1814         {
1815             auto* sql = cachedStatement(SQL::AddBlobRecord, &quot;INSERT INTO BlobRecords VALUES (?, ?);&quot;_s);
1816             if (!sql
1817                 || sql-&gt;bindInt64(1, recordID) != SQLITE_OK
1818                 || sql-&gt;bindText(2, url) != SQLITE_OK
1819                 || sql-&gt;step() != SQLITE_DONE) {
1820                 LOG_ERROR(&quot;Unable to record Blob record in database&quot;);
<span class="line-removed">1821                 if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1822                     return IDBError { QuotaExceededError, &quot;Unable to record Blob record in database because no enough space for domain&quot;_s };</span>
1823                 return IDBError { UnknownError, &quot;Unable to record Blob record in database&quot;_s };
1824             }
1825         }
1826         int64_t potentialFileNameInteger = m_sqliteDB-&gt;lastInsertRowID();
1827 
1828         // If we already have a file for this blobURL, nothing left to do.
1829         {
1830             auto* sql = cachedStatement(SQL::BlobFilenameForBlobURL, &quot;SELECT fileName FROM BlobFiles WHERE blobURL = ?;&quot;_s);
1831             if (!sql
1832                 || sql-&gt;bindText(1, url) != SQLITE_OK) {
1833                 LOG_ERROR(&quot;Unable to examine Blob filenames in database&quot;);
1834                 return IDBError { UnknownError, &quot;Unable to examine Blob filenames in database&quot;_s };
1835             }
1836 
1837             int result = sql-&gt;step();
1838             if (result != SQLITE_ROW &amp;&amp; result != SQLITE_DONE) {
1839                 LOG_ERROR(&quot;Unable to examine Blob filenames in database&quot;);
1840                 return IDBError { UnknownError, &quot;Unable to examine Blob filenames in database&quot;_s };
1841             }
1842 
1843             if (result == SQLITE_ROW)
1844                 continue;
1845         }
1846 
1847         // We don&#39;t already have a file for this blobURL, so commit our file as a unique filename
1848         String storedFilename = makeString(potentialFileNameInteger, &quot;.blob&quot;);
1849         {
1850             auto* sql = cachedStatement(SQL::AddBlobFilename, &quot;INSERT INTO BlobFiles VALUES (?, ?);&quot;_s);
1851             if (!sql
1852                 || sql-&gt;bindText(1, url) != SQLITE_OK
1853                 || sql-&gt;bindText(2, storedFilename) != SQLITE_OK
1854                 || sql-&gt;step() != SQLITE_DONE) {
1855                 LOG_ERROR(&quot;Unable to record Blob file record in database&quot;);
<span class="line-removed">1856                 if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1857                     return IDBError { QuotaExceededError, &quot;Unable to record Blob file in database because no enough space for domain&quot;_s };</span>
1858                 return IDBError { UnknownError, &quot;Unable to record Blob file record in database&quot;_s };
1859             }
1860         }
1861 
1862         transaction-&gt;addBlobFile(blobFiles[i], storedFilename);
1863     }
1864 
1865     transaction-&gt;notifyCursorsOfChanges(objectStoreInfo.identifier());
1866 
1867     return error;
1868 }
1869 
<span class="line-modified">1870 IDBError SQLiteIDBBackingStore::getBlobRecordsForObjectStoreRecord(int64_t objectStoreRecord, Vector&lt;String&gt;&amp; blobURLs, PAL::SessionID&amp; sessionID, Vector&lt;String&gt;&amp; blobFilePaths)</span>
1871 {
1872     ASSERT(objectStoreRecord);
1873 
1874     HashSet&lt;String&gt; blobURLSet;
1875     {
1876         auto* sql = cachedStatement(SQL::GetBlobURL, &quot;SELECT blobURL FROM BlobRecords WHERE objectStoreRow = ?&quot;_s);
1877         if (!sql
1878             || sql-&gt;bindInt64(1, objectStoreRecord) != SQLITE_OK) {
1879             LOG_ERROR(&quot;Could not prepare statement to fetch blob URLs for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1880             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1881         }
1882 
1883         int sqlResult = sql-&gt;step();
1884         if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE) {
1885             // There are no blobURLs in the database for this object store record.
1886             return IDBError { };
1887         }
1888 
1889         while (sqlResult == SQLITE_ROW) {
1890             blobURLSet.add(sql-&gt;getColumnText(0));
1891             sqlResult = sql-&gt;step();
1892         }
1893 
1894         if (sqlResult != SQLITE_DONE) {
1895             LOG_ERROR(&quot;Could not fetch blob URLs for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1896             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1897         }
1898     }
1899 
1900     ASSERT(!blobURLSet.isEmpty());
<span class="line-removed">1901     String databaseDirectory = fullDatabaseDirectory();</span>
1902     for (auto&amp; blobURL : blobURLSet) {
1903         auto* sql = cachedStatement(SQL::BlobFilenameForBlobURL, &quot;SELECT fileName FROM BlobFiles WHERE blobURL = ?;&quot;_s);
1904         if (!sql
1905             || sql-&gt;bindText(1, blobURL) != SQLITE_OK) {
1906             LOG_ERROR(&quot;Could not prepare statement to fetch blob filename for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1907             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1908         }
1909 
1910         if (sql-&gt;step() != SQLITE_ROW) {
1911             LOG_ERROR(&quot;Entry for blob filename for blob url %s does not exist (%i) - %s&quot;, blobURL.utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1912             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1913         }
1914 
1915         blobURLs.append(blobURL);
1916 
1917         String fileName = sql-&gt;getColumnText(0);
<span class="line-modified">1918         blobFilePaths.append(FileSystem::pathByAppendingComponent(databaseDirectory, fileName));</span>
1919     }
<span class="line-removed">1920     sessionID = m_identifier.sessionID();</span>
<span class="line-removed">1921 </span>
1922     return IDBError { };
1923 }
1924 
1925 IDBError SQLiteIDBBackingStore::getRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData&amp; keyRange, IDBGetRecordDataType type, IDBGetResult&amp; resultValue)
1926 {
1927     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getRecord - key range %s, object store %&quot; PRIu64, keyRange.loggingString().utf8().data(), objectStoreID);
1928 
1929     ASSERT(m_sqliteDB);
1930     ASSERT(m_sqliteDB-&gt;isOpen());
1931 
1932     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1933     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1934         LOG_ERROR(&quot;Attempt to get a record from database without an in-progress transaction&quot;);</span>
1935         return IDBError { UnknownError, &quot;Attempt to get a record from database without an in-progress transaction&quot;_s };
<span class="line-removed">1936     }</span>
1937 
1938     auto key = keyRange.lowerKey;
1939     if (key.isNull())
1940         key = IDBKeyData::minimum();
1941     RefPtr&lt;SharedBuffer&gt; lowerBuffer = serializeIDBKeyData(key);
1942     if (!lowerBuffer) {
1943         LOG_ERROR(&quot;Unable to serialize lower IDBKey in lookup range&quot;);
1944         return IDBError { UnknownError, &quot;Unable to serialize lower IDBKey in lookup range&quot;_s };
1945     }
1946 
1947     key = keyRange.upperKey;
1948     if (key.isNull())
1949         key = IDBKeyData::maximum();
1950     RefPtr&lt;SharedBuffer&gt; upperBuffer = serializeIDBKeyData(key);
1951     if (!upperBuffer) {
1952         LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);
1953         return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range&quot;_s };
1954     }
1955 
1956     int64_t recordID = 0;
<span class="line-modified">1957     ThreadSafeDataBuffer resultBuffer;</span>
1958     {
<span class="line-modified">1959         static const char* const lowerOpenUpperOpen = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">1960         static const char* const lowerOpenUpperClosed = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">1961         static const char* const lowerClosedUpperOpen = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">1962         static const char* const lowerClosedUpperClosed = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
1963 
1964         static const char* const lowerOpenUpperOpenKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
1965         static const char* const lowerOpenUpperClosedKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
1966         static const char* const lowerClosedUpperOpenKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
1967         static const char* const lowerClosedUpperClosedKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
1968 
1969         SQLiteStatement* sql = nullptr;
1970 
1971         switch (type) {
1972         case IDBGetRecordDataType::KeyAndValue:
1973             if (keyRange.lowerOpen) {
1974                 if (keyRange.upperOpen)
1975                     sql = cachedStatement(SQL::GetValueRecordsLowerOpenUpperOpen, lowerOpenUpperOpen);
1976                 else
1977                     sql = cachedStatement(SQL::GetValueRecordsLowerOpenUpperClosed, lowerOpenUpperClosed);
1978             } else {
1979                 if (keyRange.upperOpen)
1980                     sql = cachedStatement(SQL::GetValueRecordsLowerClosedUpperOpen, lowerClosedUpperOpen);
1981                 else
1982                     sql = cachedStatement(SQL::GetValueRecordsLowerClosedUpperClosed, lowerClosedUpperClosed);
</pre>
<hr />
<pre>
1999         if (!sql
2000             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
2001             || sql-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK
2002             || sql-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {
2003             LOG_ERROR(&quot;Could not get key range record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2004             return IDBError { UnknownError, &quot;Failed to look up record in object store by key range&quot;_s };
2005         }
2006 
2007         int sqlResult = sql-&gt;step();
2008 
2009         if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE) {
2010             // There was no record for the key in the database.
2011             return IDBError { };
2012         }
2013         if (sqlResult != SQLITE_ROW) {
2014             // There was an error fetching the record from the database.
2015             LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2016             return IDBError { UnknownError, &quot;Error looking up record in object store by key range&quot;_s };
2017         }
2018 
<span class="line-modified">2019         Vector&lt;uint8_t&gt; buffer;</span>
<span class="line-modified">2020         sql-&gt;getColumnBlobAsVector(0, buffer);</span>
<span class="line-modified">2021         resultBuffer = ThreadSafeDataBuffer::create(WTFMove(buffer));</span>
2022 
<span class="line-modified">2023         if (type == IDBGetRecordDataType::KeyAndValue)</span>
<span class="line-modified">2024             recordID = sql-&gt;getColumnInt64(1);</span>




2025     }
2026 
<span class="line-modified">2027     if (type == IDBGetRecordDataType::KeyOnly) {</span>
<span class="line-modified">2028         auto* vector = resultBuffer.data();</span>
<span class="line-modified">2029         if (!vector) {</span>
<span class="line-modified">2030             LOG_ERROR(&quot;Unable to deserialize key data from database for IDBObjectStore.getKey()&quot;);</span>
<span class="line-modified">2031             return IDBError { UnknownError, &quot;Error extracting key data from database executing IDBObjectStore.getKey()&quot;_s };</span>
<span class="line-removed">2032         }</span>
2033 
<span class="line-modified">2034         IDBKeyData keyData;</span>
<span class="line-modified">2035         if (!deserializeIDBKeyData(vector-&gt;data(), vector-&gt;size(), keyData)) {</span>
<span class="line-modified">2036             LOG_ERROR(&quot;Unable to deserialize key data from database for IDBObjectStore.getKey()&quot;);</span>
<span class="line-modified">2037             return IDBError { UnknownError, &quot;Error extracting key data from database executing IDBObjectStore.getKey()&quot;_s };</span>
<span class="line-modified">2038         }</span>
2039 

2040         resultValue = { keyData };
2041         return IDBError { };
2042     }
2043 
2044     ASSERT(recordID);
2045     Vector&lt;String&gt; blobURLs, blobFilePaths;
<span class="line-modified">2046     PAL::SessionID sessionID;</span>
<span class="line-removed">2047     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, sessionID, blobFilePaths);</span>
2048     ASSERT(blobURLs.size() == blobFilePaths.size());
2049 
2050     if (!error.isNull())
2051         return error;
2052 
<span class="line-modified">2053     resultValue = { { resultBuffer, WTFMove(blobURLs), sessionID, WTFMove(blobFilePaths) } };</span>


2054     return IDBError { };
2055 }
2056 
2057 IDBError SQLiteIDBBackingStore::getAllRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2058 {
2059     return getAllRecordsData.indexIdentifier ? getAllIndexRecords(transactionIdentifier, getAllRecordsData, result) : getAllObjectStoreRecords(transactionIdentifier, getAllRecordsData, result);
2060 }
2061 
2062 SQLiteStatement* SQLiteIDBBackingStore::cachedStatementForGetAllObjectStoreRecords(const IDBGetAllRecordsData&amp; getAllRecordsData)
2063 {
2064     static const char* const lowerOpenUpperOpenKey =&quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2065     static const char* const lowerOpenUpperClosedKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2066     static const char* const lowerClosedUpperOpenKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2067     static const char* const lowerClosedUpperClosedKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
<span class="line-modified">2068     static const char* const lowerOpenUpperOpenValue = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">2069     static const char* const lowerOpenUpperClosedValue = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">2070     static const char* const lowerClosedUpperOpenValue = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">2071     static const char* const lowerClosedUpperClosedValue = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
2072 
2073     if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Keys) {
2074         if (getAllRecordsData.keyRangeData.lowerOpen) {
2075             if (getAllRecordsData.keyRangeData.upperOpen)
2076                 return cachedStatement(SQL::GetAllKeyRecordsLowerOpenUpperOpen, lowerOpenUpperOpenKey);
2077             return cachedStatement(SQL::GetAllKeyRecordsLowerOpenUpperClosed, lowerOpenUpperClosedKey);
2078         }
2079 
2080         if (getAllRecordsData.keyRangeData.upperOpen)
2081             return cachedStatement(SQL::GetAllKeyRecordsLowerClosedUpperOpen, lowerClosedUpperOpenKey);
2082         return cachedStatement(SQL::GetAllKeyRecordsLowerClosedUpperClosed, lowerClosedUpperClosedKey);
2083     }
2084 
2085     if (getAllRecordsData.keyRangeData.lowerOpen) {
2086         if (getAllRecordsData.keyRangeData.upperOpen)
2087             return cachedStatement(SQL::GetValueRecordsLowerOpenUpperOpen, lowerOpenUpperOpenValue);
2088         return cachedStatement(SQL::GetValueRecordsLowerOpenUpperClosed, lowerOpenUpperClosedValue);
2089     }
2090 
2091     if (getAllRecordsData.keyRangeData.upperOpen)
2092         return cachedStatement(SQL::GetValueRecordsLowerClosedUpperOpen, lowerClosedUpperOpenValue);
2093     return cachedStatement(SQL::GetValueRecordsLowerClosedUpperClosed, lowerClosedUpperClosedValue);
2094 }
2095 
2096 IDBError SQLiteIDBBackingStore::getAllObjectStoreRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2097 {
2098     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getAllObjectStoreRecords&quot;);
2099 
2100     ASSERT(m_sqliteDB);
2101     ASSERT(m_sqliteDB-&gt;isOpen());
2102 
2103     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2104     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2105         LOG_ERROR(&quot;Attempt to get records from database without an in-progress transaction&quot;);</span>
2106         return IDBError { UnknownError, &quot;Attempt to get records from database without an in-progress transaction&quot;_s };
<span class="line-removed">2107     }</span>
2108 
2109     auto key = getAllRecordsData.keyRangeData.lowerKey;
2110     if (key.isNull())
2111         key = IDBKeyData::minimum();
2112     auto lowerBuffer = serializeIDBKeyData(key);
2113     if (!lowerBuffer) {
2114         LOG_ERROR(&quot;Unable to serialize lower IDBKey in lookup range&quot;);
2115         return IDBError { UnknownError, &quot;Unable to serialize lower IDBKey in lookup range&quot;_s };
2116     }
2117 
2118     key = getAllRecordsData.keyRangeData.upperKey;
2119     if (key.isNull())
2120         key = IDBKeyData::maximum();
2121     auto upperBuffer = serializeIDBKeyData(key);
2122     if (!upperBuffer) {
2123         LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);
2124         return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range&quot;_s };
2125     }
2126 
2127     auto* sql = cachedStatementForGetAllObjectStoreRecords(getAllRecordsData);
2128     if (!sql
2129         || sql-&gt;bindInt64(1, getAllRecordsData.objectStoreIdentifier) != SQLITE_OK
2130         || sql-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK
2131         || sql-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {
2132         LOG_ERROR(&quot;Could not get key range record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, getAllRecordsData.objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2133         return IDBError { UnknownError, &quot;Failed to look up record in object store by key range&quot;_s };
2134     }
2135 
<span class="line-modified">2136     result = { getAllRecordsData.getAllType };</span>


2137 
2138     uint32_t targetResults;
2139     if (getAllRecordsData.count &amp;&amp; getAllRecordsData.count.value())
2140         targetResults = getAllRecordsData.count.value();
2141     else
2142         targetResults = std::numeric_limits&lt;uint32_t&gt;::max();
2143 
2144     int sqlResult = sql-&gt;step();
2145     uint32_t returnedResults = 0;
2146 
2147     while (sqlResult == SQLITE_ROW &amp;&amp; returnedResults &lt; targetResults) {









2148         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values) {
<span class="line-modified">2149             Vector&lt;uint8_t&gt; buffer;</span>
<span class="line-modified">2150             sql-&gt;getColumnBlobAsVector(0, buffer);</span>
<span class="line-modified">2151             ThreadSafeDataBuffer resultBuffer = ThreadSafeDataBuffer::create(WTFMove(buffer));</span>
2152 
<span class="line-modified">2153             auto recordID = sql-&gt;getColumnInt64(1);</span>
2154 
2155             ASSERT(recordID);
2156             Vector&lt;String&gt; blobURLs, blobFilePaths;
<span class="line-modified">2157             PAL::SessionID sessionID;</span>
<span class="line-removed">2158             auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, sessionID, blobFilePaths);</span>
2159             ASSERT(blobURLs.size() == blobFilePaths.size());
2160 
2161             if (!error.isNull())
2162                 return error;
2163 
<span class="line-modified">2164             result.addValue({ resultBuffer, WTFMove(blobURLs), sessionID, WTFMove(blobFilePaths) });</span>
<span class="line-removed">2165         } else {</span>
<span class="line-removed">2166             Vector&lt;uint8_t&gt; keyData;</span>
<span class="line-removed">2167             IDBKeyData key;</span>
<span class="line-removed">2168             sql-&gt;getColumnBlobAsVector(0, keyData);</span>
<span class="line-removed">2169 </span>
<span class="line-removed">2170             if (!deserializeIDBKeyData(keyData.data(), keyData.size(), key)) {</span>
<span class="line-removed">2171                 LOG_ERROR(&quot;Unable to deserialize key data from database while getting all key records&quot;);</span>
<span class="line-removed">2172                 return IDBError { UnknownError, &quot;Unable to deserialize key data while getting all key records&quot;_s };</span>
<span class="line-removed">2173             }</span>
<span class="line-removed">2174 </span>
<span class="line-removed">2175             result.addKey(WTFMove(key));</span>
2176         }
2177 
2178         ++returnedResults;
2179         sqlResult = sql-&gt;step();
2180     }
2181 
2182     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE || sqlResult == SQLITE_ROW) {
2183         // Finished getting results
2184         return IDBError { };
2185     }
2186 
2187     // There was an error fetching records from the database.
2188     LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, getAllRecordsData.objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2189     return IDBError { UnknownError, &quot;Error looking up record in object store by key range&quot;_s };
2190 }
2191 
2192 IDBError SQLiteIDBBackingStore::getAllIndexRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2193 {
2194     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getAllIndexRecords - %s&quot;, getAllRecordsData.keyRangeData.loggingString().utf8().data());
2195 
2196     ASSERT(m_sqliteDB);
2197     ASSERT(m_sqliteDB-&gt;isOpen());
2198 
2199     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2200     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2201         LOG_ERROR(&quot;Attempt to get all index records from database without an in-progress transaction&quot;);</span>
2202         return IDBError { UnknownError, &quot;Attempt to get all index records from database without an in-progress transaction&quot;_s };
<span class="line-removed">2203     }</span>
2204 
2205     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(getAllRecordsData.objectStoreIdentifier, getAllRecordsData.indexIdentifier, getAllRecordsData.keyRangeData);
2206     if (!cursor) {
2207         LOG_ERROR(&quot;Cannot open cursor to perform index gets in database&quot;);
2208         return IDBError { UnknownError, &quot;Cannot open cursor to perform index gets in database&quot;_s };
2209     }
2210 
2211     if (cursor-&gt;didError()) {
2212         LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
2213         return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
2214     }
2215 
<span class="line-modified">2216     result = { getAllRecordsData.getAllType };</span>



2217     uint32_t currentCount = 0;
2218     uint32_t targetCount = getAllRecordsData.count ? getAllRecordsData.count.value() : 0;
2219     if (!targetCount)
2220         targetCount = std::numeric_limits&lt;uint32_t&gt;::max();
2221     while (!cursor-&gt;didComplete() &amp;&amp; !cursor-&gt;didError() &amp;&amp; currentCount &lt; targetCount) {
<span class="line-modified">2222         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Keys) {</span>
<span class="line-modified">2223             IDBKeyData keyCopy = cursor-&gt;currentPrimaryKey();</span>
<span class="line-modified">2224             result.addKey(WTFMove(keyCopy));</span>
<span class="line-removed">2225         } else</span>
2226             result.addValue(cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue());
2227 
2228         ++currentCount;
2229         cursor-&gt;advance(1);
2230     }
2231 
2232     if (cursor-&gt;didError()) {
2233         LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
2234         return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
2235     }
2236 
2237     return IDBError { };
2238 }
2239 
2240 IDBError SQLiteIDBBackingStore::getIndexRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t indexID, IndexedDB::IndexRecordType type, const IDBKeyRangeData&amp; range, IDBGetResult&amp; getResult)
2241 {
2242     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getIndexRecord - %s&quot;, range.loggingString().utf8().data());
2243 
2244     ASSERT(m_sqliteDB);
2245     ASSERT(m_sqliteDB-&gt;isOpen());
2246 
2247     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2248     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2249         LOG_ERROR(&quot;Attempt to get an index record from database without an in-progress transaction&quot;);</span>
2250         return IDBError { UnknownError, &quot;Attempt to get an index record from database without an in-progress transaction&quot;_s };
<span class="line-removed">2251     }</span>
2252 
2253     if (range.isExactlyOneKey())
2254         return uncheckedGetIndexRecordForOneKey(indexID, objectStoreID, type, range.lowerKey, getResult);
2255 
2256     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreID, indexID, range);
2257     if (!cursor) {
2258         LOG_ERROR(&quot;Cannot open cursor to perform index get in database&quot;);
2259         return IDBError { UnknownError, &quot;Cannot open cursor to perform index get in database&quot;_s };
2260     }
2261 
2262     if (cursor-&gt;didError()) {
2263         LOG_ERROR(&quot;Cursor failed while looking up index record in database&quot;);
2264         return IDBError { UnknownError, &quot;Cursor failed while looking up index record in database&quot;_s };
2265     }
2266 
2267     if (cursor-&gt;didComplete())
2268         getResult = { };
2269     else {
2270         if (type == IndexedDB::IndexRecordType::Key)
2271             getResult = { cursor-&gt;currentPrimaryKey() };
<span class="line-modified">2272         else</span>
<span class="line-modified">2273             getResult = { cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue(), cursor-&gt;currentPrimaryKey() };</span>



2274     }
2275 
2276     return IDBError { };
2277 }
2278 
2279 IDBError SQLiteIDBBackingStore::uncheckedGetIndexRecordForOneKey(int64_t indexID, int64_t objectStoreID, IndexedDB::IndexRecordType type, const IDBKeyData&amp; key, IDBGetResult&amp; getResult)
2280 {
2281     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::uncheckedGetIndexRecordForOneKey&quot;);
2282 
2283     ASSERT(key.isValid() &amp;&amp; key.type() != IndexedDB::KeyType::Max &amp;&amp; key.type() != IndexedDB::KeyType::Min);
2284 
2285     RefPtr&lt;SharedBuffer&gt; buffer = serializeIDBKeyData(key);
2286     if (!buffer) {
2287         LOG_ERROR(&quot;Unable to serialize IDBKey to look up one index record&quot;);
2288         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to look up one index record&quot;_s };
2289     }
2290 
2291     auto* sql = cachedStatement(SQL::GetIndexRecordForOneKey, &quot;SELECT IndexRecords.value, Records.value, Records.recordID FROM Records INNER JOIN IndexRecords ON Records.recordID = IndexRecords.objectStoreRecordID WHERE IndexRecords.indexID = ? AND IndexRecords.objectStoreID = ? AND IndexRecords.key = CAST(? AS TEXT) ORDER BY IndexRecords.key, IndexRecords.value&quot;_s);
2292 
2293     if (!sql
</pre>
<hr />
<pre>
2304         return IDBError { UnknownError, &quot;Unable to lookup index record in database&quot;_s };
2305     }
2306 
2307     if (result == SQLITE_DONE)
2308         return IDBError { };
2309 
2310     IDBKeyData objectStoreKey;
2311     Vector&lt;uint8_t&gt; keyVector;
2312     sql-&gt;getColumnBlobAsVector(0, keyVector);
2313 
2314     if (!deserializeIDBKeyData(keyVector.data(), keyVector.size(), objectStoreKey)) {
2315         LOG_ERROR(&quot;Unable to deserialize key looking up index record in database&quot;);
2316         return IDBError { UnknownError, &quot;Unable to deserialize key looking up index record in database&quot;_s };
2317     }
2318 
2319     if (type == IndexedDB::IndexRecordType::Key) {
2320         getResult = { objectStoreKey };
2321         return IDBError { };
2322     }
2323 
<span class="line-modified">2324     sql-&gt;getColumnBlobAsVector(1, keyVector);</span>

2325 
2326     int64_t recordID = sql-&gt;getColumnInt64(2);
2327     Vector&lt;String&gt; blobURLs, blobFilePaths;
<span class="line-modified">2328     PAL::SessionID sessionID;</span>
<span class="line-removed">2329     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, sessionID, blobFilePaths);</span>
2330     ASSERT(blobURLs.size() == blobFilePaths.size());
2331 
2332     if (!error.isNull())
2333         return error;
2334 
<span class="line-modified">2335     getResult = { { ThreadSafeDataBuffer::create(WTFMove(keyVector)), WTFMove(blobURLs), sessionID, WTFMove(blobFilePaths) }, objectStoreKey };</span>


2336     return IDBError { };
2337 }
2338 
2339 IDBError SQLiteIDBBackingStore::getCount(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; range, uint64_t&amp; outCount)
2340 {
2341     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getCount - object store %&quot; PRIu64, objectStoreIdentifier);
2342     ASSERT(m_sqliteDB);
2343     ASSERT(m_sqliteDB-&gt;isOpen());
2344 
2345     outCount = 0;
2346 
2347     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2348     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2349         LOG_ERROR(&quot;Attempt to get count from database without an in-progress transaction&quot;);</span>
2350         return IDBError { UnknownError, &quot;Attempt to get count from database without an in-progress transaction&quot;_s };
<span class="line-removed">2351     }</span>
2352 
2353     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreIdentifier, indexIdentifier, range);
2354     if (!cursor) {
2355         LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);
2356         return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
2357     }
2358 
2359     while (cursor-&gt;advance(1))
2360         ++outCount;
2361 
2362     return IDBError { };
2363 }
2364 
2365 IDBError SQLiteIDBBackingStore::uncheckedGetKeyGeneratorValue(int64_t objectStoreID, uint64_t&amp; outValue)
2366 {
2367     auto* sql = cachedStatement(SQL::GetKeyGeneratorValue, &quot;SELECT currentKey FROM KeyGenerators WHERE objectStoreID = ?;&quot;_s);
2368     if (!sql
2369         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK) {
2370         LOG_ERROR(&quot;Could not retrieve currentKey from KeyGenerators table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2371         return IDBError { UnknownError, &quot;Error getting current key generator value from database&quot;_s };
</pre>
<hr />
<pre>
2375         LOG_ERROR(&quot;Could not retreive key generator value for object store, but it should be there.&quot;);
2376         return IDBError { UnknownError, &quot;Error finding current key generator value in database&quot;_s };
2377     }
2378 
2379     int64_t value = sql-&gt;getColumnInt64(0);
2380     if (value &lt; 0)
2381         return IDBError { ConstraintError, &quot;Current key generator value from database is invalid&quot; };
2382 
2383     outValue = value;
2384     return IDBError { };
2385 }
2386 
2387 IDBError SQLiteIDBBackingStore::uncheckedSetKeyGeneratorValue(int64_t objectStoreID, uint64_t value)
2388 {
2389     auto* sql = cachedStatement(SQL::SetKeyGeneratorValue, &quot;INSERT INTO KeyGenerators VALUES (?, ?);&quot;_s);
2390     if (!sql
2391         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
2392         || sql-&gt;bindInt64(2, value) != SQLITE_OK
2393         || sql-&gt;step() != SQLITE_DONE) {
2394         LOG_ERROR(&quot;Could not update key generator value (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed">2395         if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">2396             return IDBError { QuotaExceededError, &quot;Error storing new key generator value in database because no enough space for domain&quot;_s };</span>
2397         return IDBError { ConstraintError, &quot;Error storing new key generator value in database&quot; };
2398     }
2399 
2400     return IDBError { };
2401 }
2402 
2403 IDBError SQLiteIDBBackingStore::generateKeyNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t&amp; generatedKey)
2404 {
2405     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::generateKeyNumber&quot;);
2406 
2407     ASSERT(m_sqliteDB);
2408     ASSERT(m_sqliteDB-&gt;isOpen());
2409 
2410     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2411     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2412         LOG_ERROR(&quot;Attempt to generate key in database without an in-progress transaction&quot;);</span>
2413         return IDBError { UnknownError, &quot;Attempt to generate key in database without an in-progress transaction&quot;_s };
<span class="line-modified">2414     }</span>
2415     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2416         LOG_ERROR(&quot;Attempt to generate key in a read-only transaction&quot;);
2417         return IDBError { UnknownError, &quot;Attempt to generate key in a read-only transaction&quot;_s };
2418     }
2419 
2420     uint64_t currentValue;
2421     auto error = uncheckedGetKeyGeneratorValue(objectStoreID, currentValue);
2422     if (!error.isNull())
2423         return error;
2424 
2425     if (currentValue + 1 &gt; maxGeneratorValue)
2426         return IDBError { ConstraintError, &quot;Cannot generate new key value over 2^53 for object store operation&quot; };
2427 
2428     generatedKey = currentValue + 1;
2429     return uncheckedSetKeyGeneratorValue(objectStoreID, generatedKey);
2430 }
2431 
2432 IDBError SQLiteIDBBackingStore::revertGeneratedKeyNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t newKeyNumber)
2433 {
2434     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::revertGeneratedKeyNumber - object store %&quot; PRIu64 &quot;, reverted number %&quot; PRIu64, objectStoreID, newKeyNumber);
2435 
2436     ASSERT(m_sqliteDB);
2437     ASSERT(m_sqliteDB-&gt;isOpen());
2438 
2439     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2440     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2441         LOG_ERROR(&quot;Attempt to revert key generator value in database without an in-progress transaction&quot;);</span>
2442         return IDBError { UnknownError, &quot;Attempt to revert key generator value in database without an in-progress transaction&quot;_s };
<span class="line-modified">2443     }</span>
2444     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2445         LOG_ERROR(&quot;Attempt to revert key generator value in a read-only transaction&quot;);
2446         return IDBError { UnknownError, &quot;Attempt to revert key generator value in a read-only transaction&quot;_s };
2447     }
2448 
2449     ASSERT(newKeyNumber);
2450     return uncheckedSetKeyGeneratorValue(objectStoreID, newKeyNumber - 1);
2451 }
2452 
2453 IDBError SQLiteIDBBackingStore::maybeUpdateKeyGeneratorNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, double newKeyNumber)
2454 {
2455     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::maybeUpdateKeyGeneratorNumber&quot;);
2456 
2457     ASSERT(m_sqliteDB);
2458     ASSERT(m_sqliteDB-&gt;isOpen());
2459 
2460     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2461     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2462         LOG_ERROR(&quot;Attempt to update key generator value in database without an in-progress transaction&quot;);</span>
2463         return IDBError { UnknownError, &quot;Attempt to update key generator value in database without an in-progress transaction&quot;_s };
<span class="line-modified">2464     }</span>
2465     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2466         LOG_ERROR(&quot;Attempt to update key generator value in a read-only transaction&quot;);
2467         return IDBError { UnknownError, &quot;Attempt to update key generator value in a read-only transaction&quot;_s };
2468     }
2469 
2470     uint64_t currentValue;
2471     auto error = uncheckedGetKeyGeneratorValue(objectStoreID, currentValue);
2472     if (!error.isNull())
2473         return error;
2474 
2475     if (newKeyNumber &lt;= currentValue)
2476         return IDBError { };
2477 
2478     return uncheckedSetKeyGeneratorValue(objectStoreID, std::min(newKeyNumber, (double)maxGeneratorValue));
2479 }
2480 
2481 IDBError SQLiteIDBBackingStore::openCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info, IDBGetResult&amp; result)
2482 {
2483     ASSERT(m_sqliteDB);
2484     ASSERT(m_sqliteDB-&gt;isOpen());
2485 
2486     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2487     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2488         LOG_ERROR(&quot;Attempt to open a cursor in database without an in-progress transaction&quot;);</span>
2489         return IDBError { UnknownError, &quot;Attempt to open a cursor in database without an in-progress transaction&quot;_s };
<span class="line-removed">2490     }</span>
2491 
2492     auto* cursor = transaction-&gt;maybeOpenCursor(info);
2493     if (!cursor) {
2494         LOG_ERROR(&quot;Unable to open cursor&quot;);
2495         return IDBError { UnknownError, &quot;Unable to open cursor&quot;_s };
2496     }
2497 
2498     m_cursors.set(cursor-&gt;identifier(), cursor);
2499 
<span class="line-modified">2500     cursor-&gt;currentData(result);</span>


2501     return IDBError { };
2502 }
2503 
2504 IDBError SQLiteIDBBackingStore::iterateCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data, IDBGetResult&amp; result)
2505 {
2506     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::iterateCursor&quot;);
2507 
2508     ASSERT(m_sqliteDB);
2509     ASSERT(m_sqliteDB-&gt;isOpen());
2510 
2511     auto* cursor = m_cursors.get(cursorIdentifier);
2512     if (!cursor) {
2513         LOG_ERROR(&quot;Attempt to iterate a cursor that doesn&#39;t exist&quot;);
2514         return IDBError { UnknownError, &quot;Attempt to iterate a cursor that doesn&#39;t exist&quot;_s };
2515     }
2516 
2517     ASSERT_UNUSED(transactionIdentifier, cursor-&gt;transaction()-&gt;transactionIdentifier() == transactionIdentifier);
2518 
<span class="line-modified">2519     if (!cursor-&gt;transaction() || !cursor-&gt;transaction()-&gt;inProgress()) {</span>
<span class="line-removed">2520         LOG_ERROR(&quot;Attempt to iterate a cursor without an in-progress transaction&quot;);</span>
2521         return IDBError { UnknownError, &quot;Attempt to iterate a cursor without an in-progress transaction&quot;_s };
<span class="line-removed">2522     }</span>
2523 
2524     auto key = data.keyData;
2525     auto primaryKey = data.primaryKeyData;
2526     auto count = data.count;
2527 
2528     if (key.isValid()) {
2529         if (!cursor-&gt;iterate(key, primaryKey)) {
2530             LOG_ERROR(&quot;Attempt to iterate cursor failed&quot;);
2531             return IDBError { UnknownError, &quot;Attempt to iterate cursor failed&quot;_s };
2532         }
2533     } else {
2534         ASSERT(!primaryKey.isValid());
2535         if (!count)
2536             count = 1;
2537         if (!cursor-&gt;advance(count)) {
2538             LOG_ERROR(&quot;Attempt to advance cursor failed&quot;);
2539             return IDBError { UnknownError, &quot;Attempt to advance cursor failed&quot;_s };
2540         }
2541     }
2542 
<span class="line-modified">2543     cursor-&gt;currentData(result);</span>


2544     return IDBError { };
2545 }
2546 
2547 bool SQLiteIDBBackingStore::prefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)
2548 {
2549     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::prefetchCursor&quot;);
2550 
2551     ASSERT(m_sqliteDB);
2552     ASSERT(m_sqliteDB-&gt;isOpen());
2553 
2554     auto* cursor = m_cursors.get(cursorIdentifier);
2555     if (!cursor || !cursor-&gt;transaction() || !cursor-&gt;transaction()-&gt;inProgress())
2556         return false;
2557 
2558     ASSERT_UNUSED(transactionIdentifier, cursor-&gt;transaction()-&gt;transactionIdentifier() == transactionIdentifier);
2559 
2560     return cursor-&gt;prefetch();
2561 }
2562 
2563 IDBObjectStoreInfo* SQLiteIDBBackingStore::infoForObjectStore(uint64_t objectStoreIdentifier)
</pre>
<hr />
<pre>
2577         bool errored = true;
2578 
2579         if (m_sqliteDB) {
2580             SQLiteStatement sql(*m_sqliteDB, &quot;SELECT fileName FROM BlobFiles;&quot;_s);
2581             if (sql.prepare() == SQLITE_OK) {
2582                 int result = sql.step();
2583                 while (result == SQLITE_ROW) {
2584                     blobFiles.append(sql.getColumnText(0));
2585                     result = sql.step();
2586                 }
2587 
2588                 if (result == SQLITE_DONE)
2589                     errored = false;
2590             }
2591         }
2592 
2593         if (errored)
2594             LOG_ERROR(&quot;Error getting all blob filenames to be deleted&quot;);
2595     }
2596 
<span class="line-removed">2597     String databaseDirectory = fullDatabaseDirectory();</span>
2598     for (auto&amp; file : blobFiles) {
<span class="line-modified">2599         String fullPath = FileSystem::pathByAppendingComponent(databaseDirectory, file);</span>
2600         if (!FileSystem::deleteFile(fullPath))
2601             LOG_ERROR(&quot;Error deleting blob file %s&quot;, fullPath.utf8().data());
2602     }
2603 
2604     if (m_sqliteDB)
2605         closeSQLiteDB();
2606 
2607     SQLiteFileSystem::deleteDatabaseFile(dbFilename);
<span class="line-modified">2608     SQLiteFileSystem::deleteEmptyDatabaseDirectory(fullDatabaseDirectory());</span>
<span class="line-modified">2609     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_absoluteDatabaseDirectory);</span>
2610 }
2611 
2612 void SQLiteIDBBackingStore::unregisterCursor(SQLiteIDBCursor&amp; cursor)
2613 {
2614     ASSERT(m_cursors.contains(cursor.identifier()));
2615     m_cursors.remove(cursor.identifier());
2616 }
2617 
2618 SQLiteStatement* SQLiteIDBBackingStore::cachedStatement(SQLiteIDBBackingStore::SQL sql, const char* statement)
2619 {
2620     if (sql &gt;= SQL::Count) {
2621         LOG_ERROR(&quot;Invalid SQL statement ID passed to cachedStatement()&quot;);
2622         return nullptr;
2623     }
2624 
2625     if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]) {
2626         if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;reset() == SQLITE_OK)
2627             return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
2628         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
2629     }
2630 
2631     if (m_sqliteDB) {
<span class="line-modified">2632         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = std::make_unique&lt;SQLiteStatement&gt;(*m_sqliteDB, statement);</span>
2633         if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;prepare() != SQLITE_OK)
2634             m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
2635     }
2636 
2637     return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
2638 }
2639 





2640 void SQLiteIDBBackingStore::closeSQLiteDB()
2641 {
2642     for (size_t i = 0; i &lt; static_cast&lt;int&gt;(SQL::Count); ++i)
2643         m_cachedStatements[i] = nullptr;
2644 
2645     if (m_sqliteDB)
2646         m_sqliteDB-&gt;close();
2647 
2648     m_sqliteDB = nullptr;
2649 }
2650 






2651 } // namespace IDBServer
2652 } // namespace WebCore
2653 
2654 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
<td>
<hr />
<pre>
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;SQLiteIDBBackingStore.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
  31 #include &quot;IDBBindingUtilities.h&quot;
<span class="line-added">  32 #include &quot;IDBCursorInfo.h&quot;</span>
  33 #include &quot;IDBGetAllRecordsData.h&quot;
  34 #include &quot;IDBGetAllResult.h&quot;
  35 #include &quot;IDBGetRecordData.h&quot;
  36 #include &quot;IDBGetResult.h&quot;
  37 #include &quot;IDBIterateCursorData.h&quot;
  38 #include &quot;IDBKeyData.h&quot;
  39 #include &quot;IDBObjectStoreInfo.h&quot;
  40 #include &quot;IDBSerialization.h&quot;
<span class="line-added">  41 #include &quot;IDBSerializationContext.h&quot;</span>
  42 #include &quot;IDBTransactionInfo.h&quot;
  43 #include &quot;IDBValue.h&quot;
  44 #include &quot;IndexKey.h&quot;
  45 #include &quot;Logging.h&quot;
  46 #include &quot;SQLiteDatabase.h&quot;
  47 #include &quot;SQLiteFileSystem.h&quot;
  48 #include &quot;SQLiteIDBCursor.h&quot;
  49 #include &quot;SQLiteStatement.h&quot;
  50 #include &quot;SQLiteTransaction.h&quot;
  51 #include &quot;ThreadSafeDataBuffer.h&quot;
  52 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
<span class="line-modified">  53 #include &lt;JavaScriptCore/JSCInlines.h&gt;</span>


  54 #include &lt;JavaScriptCore/StrongInlines.h&gt;

  55 #include &lt;wtf/FileSystem.h&gt;
  56 #include &lt;wtf/NeverDestroyed.h&gt;
  57 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  58 
  59 namespace WebCore {
  60 using namespace JSC;
  61 namespace IDBServer {
  62 
  63 // Current version of the metadata schema being used in the metadata database.
  64 static const int currentMetadataVersion = 1;
  65 
  66 // The IndexedDatabase spec defines the max key generator value as 2^53.
  67 static const uint64_t maxGeneratorValue = 0x20000000000000;
  68 
  69 static int idbKeyCollate(int aLength, const void* aBuffer, int bLength, const void* bBuffer)
  70 {
  71     IDBKeyData a, b;
  72     if (!deserializeIDBKeyData(static_cast&lt;const uint8_t*&gt;(aBuffer), aLength, a)) {
  73         LOG_ERROR(&quot;Unable to deserialize key A in collation function.&quot;);
  74 
</pre>
<hr />
<pre>
 212     return blobRecordsTableSchemaString;
 213 }
 214 
 215 static const String blobFilesTableSchema(const String&amp; tableName)
 216 {
 217     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (blobURL TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, fileName TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL)&quot;);
 218 }
 219 
 220 static const String&amp; blobFilesTableSchema()
 221 {
 222     static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;BlobFiles&quot;));
 223     return blobFilesTableSchemaString;
 224 }
 225 
 226 static const String&amp; blobFilesTableSchemaAlternate()
 227 {
 228     static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;\&quot;BlobFiles\&quot;&quot;));
 229     return blobFilesTableSchemaString;
 230 }
 231 
<span class="line-modified"> 232 SQLiteIDBBackingStore::SQLiteIDBBackingStore(PAL::SessionID sessionID, const IDBDatabaseIdentifier&amp; identifier, const String&amp; databaseRootDirectory, IDBBackingStoreTemporaryFileHandler&amp; fileHandler)</span>
<span class="line-modified"> 233     : m_sessionID(sessionID)</span>
<span class="line-added"> 234     , m_identifier(identifier)</span>
<span class="line-added"> 235     , m_databaseRootDirectory(databaseRootDirectory)</span>
 236     , m_temporaryFileHandler(fileHandler)
<span class="line-modified"> 237     , m_serializationContext(IDBSerializationContext::getOrCreateIDBSerializationContext(sessionID))</span>
 238 {
<span class="line-modified"> 239     m_databaseDirectory = fullDatabaseDirectoryWithUpgrade();</span>
 240 }
 241 
 242 SQLiteIDBBackingStore::~SQLiteIDBBackingStore()
 243 {
 244     if (m_sqliteDB)
 245         closeSQLiteDB();






























 246 }
 247 
 248 static bool createOrMigrateRecordsTableIfNecessary(SQLiteDatabase&amp; database)
 249 {
 250     String currentSchema;
 251     {
 252         // Fetch the schema for an existing records table.
 253         SQLiteStatement statement(database, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;Records&#39;&quot;);
 254         if (statement.prepare() != SQLITE_OK) {
 255             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the Records table.&quot;);
 256             return false;
 257         }
 258 
 259         int sqliteResult = statement.step();
 260 
 261         // If there is no Records table at all, create it and then bail.
 262         if (sqliteResult == SQLITE_DONE) {
 263             if (!database.executeCommand(v3RecordsTableSchema())) {
 264                 LOG_ERROR(&quot;Could not create Records table in database (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 265                 return false;
</pre>
<hr />
<pre>
 578     {
 579         // Database versions are defined to be a uin64_t in the spec but sqlite3 doesn&#39;t support native binding of unsigned integers.
 580         // Therefore we&#39;ll store the version as a String.
 581         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;DatabaseVersion&#39;, ?);&quot;_s);
 582         if (sql.prepare() != SQLITE_OK
 583             || sql.bindText(1, String::number(0)) != SQLITE_OK
 584             || sql.step() != SQLITE_DONE) {
 585             LOG_ERROR(&quot;Could not insert default version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 586             closeSQLiteDB();
 587             return nullptr;
 588         }
 589     }
 590 
 591     if (!m_sqliteDB-&gt;executeCommand(&quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;MaxObjectStoreID&#39;, 1);&quot;_s)) {
 592         LOG_ERROR(&quot;Could not insert default version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 593         closeSQLiteDB();
 594         return nullptr;
 595     }
 596 
 597     // This initial database info matches the default values we just put into the metadata database.
<span class="line-modified"> 598     return makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), 0);</span>
 599 }
 600 
 601 std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::extractExistingDatabaseInfo()
 602 {
 603     ASSERT(m_sqliteDB);
 604 
 605     if (!m_sqliteDB-&gt;tableExists(&quot;IDBDatabaseInfo&quot;_s))
 606         return nullptr;
 607 
 608     String databaseName;
 609     {
 610         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseName&#39;;&quot;);
 611         if (sql.isColumnNull(0))
 612             return nullptr;
 613         databaseName = sql.getColumnText(0);
 614         if (databaseName != m_identifier.databaseName()) {
 615             LOG_ERROR(&quot;Database name in the info database (&#39;%s&#39;) does not match the expected name (&#39;%s&#39;)&quot;, databaseName.utf8().data(), m_identifier.databaseName().utf8().data());
 616             return nullptr;
 617         }
 618     }
 619     uint64_t databaseVersion;
 620     {
 621         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseVersion&#39;;&quot;_s);
 622         if (sql.isColumnNull(0))
 623             return nullptr;
 624         String stringVersion = sql.getColumnText(0);
 625         bool ok;
 626         databaseVersion = stringVersion.toUInt64Strict(&amp;ok);
 627         if (!ok) {
 628             LOG_ERROR(&quot;Database version on disk (&#39;%s&#39;) does not cleanly convert to an unsigned 64-bit integer version&quot;, stringVersion.utf8().data());
 629             return nullptr;
 630         }
 631     }
 632 
<span class="line-modified"> 633     auto databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(databaseName, databaseVersion);</span>
 634 
 635     {
 636         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, keyPath, autoInc, maxIndexID FROM ObjectStoreInfo;&quot;_s);
 637         if (sql.prepare() != SQLITE_OK)
 638             return nullptr;
 639 
 640         int result = sql.step();
 641         while (result == SQLITE_ROW) {
 642             uint64_t objectStoreID = sql.getColumnInt64(0);
 643             String objectStoreName = sql.getColumnText(1);
 644 
 645             Vector&lt;char&gt; keyPathBuffer;
 646             sql.getColumnBlobAsVector(2, keyPathBuffer);
 647 
 648             Optional&lt;IDBKeyPath&gt; objectStoreKeyPath;
 649             if (!deserializeIDBKeyPath(reinterpret_cast&lt;const uint8_t*&gt;(keyPathBuffer.data()), keyPathBuffer.size(), objectStoreKeyPath)) {
 650                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 651                 return nullptr;
 652             }
 653 
</pre>
<hr />
<pre>
 718 
 719     String partiallyDecoded = encodedName;
 720     partiallyDecoded.replace(&quot;%2E&quot;_s, &quot;.&quot;_s);
 721 
 722     return FileSystem::decodeFromFilename(partiallyDecoded);
 723 }
 724 
 725 String SQLiteIDBBackingStore::filenameForDatabaseName() const
 726 {
 727     ASSERT(!m_identifier.databaseName().isNull());
 728 
 729     if (m_identifier.databaseName().isEmpty())
 730         return &quot;%00&quot;;
 731 
 732     String filename = FileSystem::encodeForFileName(m_identifier.databaseName());
 733     filename.replace(&#39;.&#39;, &quot;%2E&quot;);
 734 
 735     return filename;
 736 }
 737 
<span class="line-modified"> 738 String SQLiteIDBBackingStore::fullDatabasePathForDirectory(const String&amp; fullDatabaseDirectory)</span>
 739 {
<span class="line-modified"> 740     return FileSystem::pathByAppendingComponent(fullDatabaseDirectory, &quot;IndexedDB.sqlite3&quot;);</span>


 741 }
 742 
 743 String SQLiteIDBBackingStore::fullDatabasePath() const
 744 {
<span class="line-modified"> 745     return fullDatabasePathForDirectory(m_databaseDirectory);</span>
<span class="line-added"> 746 }</span>
 747 
<span class="line-modified"> 748 String SQLiteIDBBackingStore::databaseNameFromFile(const String&amp; databasePath)</span>
<span class="line-added"> 749 {</span>
<span class="line-added"> 750     SQLiteDatabase database;</span>
<span class="line-added"> 751     if (!database.open(databasePath)) {</span>
<span class="line-added"> 752         LOG_ERROR(&quot;Failed to open SQLite database at path &#39;%s&#39; when getting database name&quot;, databasePath.utf8().data());</span>
<span class="line-added"> 753         return { };</span>
<span class="line-added"> 754     }</span>
<span class="line-added"> 755     if (!database.tableExists(&quot;IDBDatabaseInfo&quot;_s)) {</span>
<span class="line-added"> 756         LOG_ERROR(&quot;Could not find IDBDatabaseInfo table and get database name(%i) - %s&quot;, database.lastError(), database.lastErrorMsg());</span>
<span class="line-added"> 757         database.close();</span>
<span class="line-added"> 758         return { };</span>
<span class="line-added"> 759     }</span>
<span class="line-added"> 760     SQLiteStatement sql(database, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseName&#39;;&quot;);</span>
<span class="line-added"> 761     auto databaseName = sql.getColumnText(0);</span>
<span class="line-added"> 762     database.close();</span>
<span class="line-added"> 763     return databaseName;</span>
<span class="line-added"> 764 }</span>
<span class="line-added"> 765 </span>
<span class="line-added"> 766 String SQLiteIDBBackingStore::fullDatabaseDirectoryWithUpgrade()</span>
<span class="line-added"> 767 {</span>
<span class="line-added"> 768     auto databaseRootDirectory = this-&gt;databaseRootDirectoryIsolatedCopy();</span>
<span class="line-added"> 769     String oldOriginDirectory = m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectory, &quot;v0&quot;);</span>
<span class="line-added"> 770     String oldDatabaseDirectory = FileSystem::pathByAppendingComponent(oldOriginDirectory, filenameForDatabaseName());</span>
<span class="line-added"> 771     String newOriginDirectory = m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectory, &quot;v1&quot;);</span>
<span class="line-added"> 772     String fileNameHash = SQLiteFileSystem::computeHashForFileName(m_identifier.databaseName());</span>
<span class="line-added"> 773     Vector&lt;String&gt; directoriesWithSameHash = FileSystem::listDirectory(newOriginDirectory, fileNameHash + &quot;*&quot;);</span>
<span class="line-added"> 774     String newDatabaseDirectory = FileSystem::pathByAppendingComponent(newOriginDirectory, fileNameHash);</span>
<span class="line-added"> 775     FileSystem::makeAllDirectories(newDatabaseDirectory);</span>
<span class="line-added"> 776 </span>
<span class="line-added"> 777     if (FileSystem::fileExists(oldDatabaseDirectory)) {</span>
<span class="line-added"> 778         FileSystem::moveFile(oldDatabaseDirectory, newDatabaseDirectory);</span>
<span class="line-added"> 779         FileSystem::deleteEmptyDirectory(oldOriginDirectory);</span>
<span class="line-added"> 780     }</span>
<span class="line-added"> 781 </span>
<span class="line-added"> 782     return newDatabaseDirectory;</span>
 783 }
 784 
 785 IDBError SQLiteIDBBackingStore::getOrEstablishDatabaseInfo(IDBDatabaseInfo&amp; info)
 786 {
 787     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getOrEstablishDatabaseInfo - database %s&quot;, m_identifier.databaseName().utf8().data());
 788 
 789     if (m_databaseInfo) {
 790         info = *m_databaseInfo;
 791         return IDBError { };
 792     }
 793 

 794     String dbFilename = fullDatabasePath();
 795 
<span class="line-modified"> 796     m_sqliteDB = makeUnique&lt;SQLiteDatabase&gt;();</span>
 797     if (!m_sqliteDB-&gt;open(dbFilename)) {
 798         LOG_ERROR(&quot;Failed to open SQLite database at path &#39;%s&#39;&quot;, dbFilename.utf8().data());
 799         closeSQLiteDB();
 800     }
 801 
 802     if (!m_sqliteDB)
 803         return IDBError { UnknownError, &quot;Unable to open database file on disk&quot;_s };
 804 
 805     m_sqliteDB-&gt;setCollationFunction(&quot;IDBKEY&quot;, [](int aLength, const void* a, int bLength, const void* b) {
 806         return idbKeyCollate(aLength, a, bLength, b);
 807     });
 808 
 809     if (!ensureValidRecordsTable()) {
 810         LOG_ERROR(&quot;Error creating or migrating Records table in database&quot;);
 811         closeSQLiteDB();
 812         return IDBError { UnknownError, &quot;Error creating or migrating Records table in database&quot;_s };
 813     }
 814 
 815     if (!ensureValidIndexRecordsTable()) {
 816         LOG_ERROR(&quot;Error creating or migrating Index Records table in database&quot;);
</pre>
<hr />
<pre>
 828         LOG_ERROR(&quot;Error creating or confirming Blob Records tables in database&quot;);
 829         closeSQLiteDB();
 830         return IDBError { UnknownError, &quot;Error creating or confirming Blob Records tables in database&quot;_s };
 831     }
 832 
 833     auto databaseInfo = extractExistingDatabaseInfo();
 834     if (!databaseInfo)
 835         databaseInfo = createAndPopulateInitialDatabaseInfo();
 836 
 837     if (!databaseInfo) {
 838         LOG_ERROR(&quot;Unable to establish IDB database at path &#39;%s&#39;&quot;, dbFilename.utf8().data());
 839         closeSQLiteDB();
 840         return IDBError { UnknownError, &quot;Unable to establish IDB database file&quot;_s };
 841     }
 842 
 843     m_databaseInfo = WTFMove(databaseInfo);
 844     info = *m_databaseInfo;
 845     return IDBError { };
 846 }
 847 
<span class="line-modified"> 848 uint64_t SQLiteIDBBackingStore::databasesSizeForDirectory(const String&amp; directory)</span>








 849 {







 850     uint64_t diskUsage = 0;
<span class="line-modified"> 851     for (auto&amp; dbDirectory : FileSystem::listDirectory(directory, &quot;*&quot;)) {</span>
<span class="line-modified"> 852         for (auto&amp; file : FileSystem::listDirectory(dbDirectory, &quot;*.sqlite3&quot;_s))</span>
 853             diskUsage += SQLiteFileSystem::getDatabaseFileSize(file);
 854     }
<span class="line-modified"> 855     return diskUsage;</span>
<span class="line-modified"> 856 }</span>


 857 
<span class="line-modified"> 858 uint64_t SQLiteIDBBackingStore::databaseSize() const</span>
<span class="line-added"> 859 {</span>
<span class="line-added"> 860     ASSERT(!isMainThread());</span>
<span class="line-added"> 861     return SQLiteFileSystem::getDatabaseFileSize(fullDatabasePath());</span>
 862 }
 863 
 864 IDBError SQLiteIDBBackingStore::beginTransaction(const IDBTransactionInfo&amp; info)
 865 {
 866     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::beginTransaction - %s&quot;, info.identifier().loggingString().utf8().data());
 867 
 868     ASSERT(m_sqliteDB);
 869     ASSERT(m_sqliteDB-&gt;isOpen());
 870     ASSERT(m_databaseInfo);
 871 

 872     auto addResult = m_transactions.add(info.identifier(), nullptr);
 873     if (!addResult.isNewEntry) {
 874         LOG_ERROR(&quot;Attempt to establish transaction identifier that already exists&quot;);
 875         return IDBError { UnknownError, &quot;Attempt to establish transaction identifier that already exists&quot;_s };
 876     }
 877 
<span class="line-modified"> 878     addResult.iterator-&gt;value = makeUnique&lt;SQLiteIDBTransaction&gt;(*this, info);</span>
 879 
 880     auto error = addResult.iterator-&gt;value-&gt;begin(*m_sqliteDB);
 881     if (error.isNull() &amp;&amp; info.mode() == IDBTransactionMode::Versionchange) {
<span class="line-modified"> 882         m_originalDatabaseInfoBeforeVersionChange = makeUnique&lt;IDBDatabaseInfo&gt;(*m_databaseInfo);</span>
 883 
 884         SQLiteStatement sql(*m_sqliteDB, &quot;UPDATE IDBDatabaseInfo SET value = ? where key = &#39;DatabaseVersion&#39;;&quot;_s);
 885         if (sql.prepare() != SQLITE_OK
 886             || sql.bindText(1, String::number(info.newVersion())) != SQLITE_OK
 887             || sql.step() != SQLITE_DONE) {
<span class="line-modified"> 888             error = IDBError { UnknownError, &quot;Failed to store new database version in database&quot;_s };</span>



 889         }
 890     }
 891 
 892     return error;
 893 }
 894 
 895 IDBError SQLiteIDBBackingStore::abortTransaction(const IDBResourceIdentifier&amp; identifier)
 896 {
 897     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::abortTransaction - %s&quot;, identifier.loggingString().utf8().data());
 898 
 899     ASSERT(m_sqliteDB);
 900     ASSERT(m_sqliteDB-&gt;isOpen());
 901 
 902     auto transaction = m_transactions.take(identifier);
 903     if (!transaction) {
 904         LOG_ERROR(&quot;Attempt to commit a transaction that hasn&#39;t been established&quot;);
 905         return IDBError { UnknownError, &quot;Attempt to abort a transaction that hasn&#39;t been established&quot;_s };
 906     }
 907 
 908     if (transaction-&gt;mode() == IDBTransactionMode::Versionchange &amp;&amp; m_originalDatabaseInfoBeforeVersionChange)
</pre>
<hr />
<pre>
 927     auto error = transaction-&gt;commit();
 928     if (!error.isNull()) {
 929         if (transaction-&gt;mode() == IDBTransactionMode::Versionchange) {
 930             ASSERT(m_originalDatabaseInfoBeforeVersionChange);
 931             m_databaseInfo = WTFMove(m_originalDatabaseInfoBeforeVersionChange);
 932         }
 933     } else
 934         m_originalDatabaseInfoBeforeVersionChange = nullptr;
 935 
 936     return error;
 937 }
 938 
 939 IDBError SQLiteIDBBackingStore::createObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; info)
 940 {
 941     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::createObjectStore - adding OS %s with ID %&quot; PRIu64, info.name().utf8().data(), info.identifier());
 942 
 943     ASSERT(m_sqliteDB);
 944     ASSERT(m_sqliteDB-&gt;isOpen());
 945 
 946     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified"> 947     if (!transaction || !transaction-&gt;inProgress())</span>

 948         return IDBError { UnknownError, &quot;Attempt to create an object store without an in-progress transaction&quot;_s };
<span class="line-modified"> 949 </span>
 950     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
 951         LOG_ERROR(&quot;Attempt to create an object store in a non-version-change transaction&quot;);
 952         return IDBError { UnknownError, &quot;Attempt to create an object store in a non-version-change transaction&quot;_s };
 953     }
 954 
 955     RefPtr&lt;SharedBuffer&gt; keyPathBlob = serializeIDBKeyPath(info.keyPath());
 956     if (!keyPathBlob) {
 957         LOG_ERROR(&quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;);
 958         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;_s };
 959     }
 960 
 961     {
 962         auto* sql = cachedStatement(SQL::CreateObjectStoreInfo, &quot;INSERT INTO ObjectStoreInfo VALUES (?, ?, ?, ?, ?);&quot;_s);
 963         if (!sql
 964             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
 965             || sql-&gt;bindText(2, info.name()) != SQLITE_OK
 966             || sql-&gt;bindBlob(3, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
 967             || sql-&gt;bindInt(4, info.autoIncrement()) != SQLITE_OK
 968             || sql-&gt;bindInt64(5, info.maxIndexID()) != SQLITE_OK
 969             || sql-&gt;step() != SQLITE_DONE) {
 970             LOG_ERROR(&quot;Could not add object store &#39;%s&#39; to ObjectStoreInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());


 971             return IDBError { UnknownError, &quot;Could not create object store&quot;_s };
 972         }
 973     }
 974 
 975     {
 976         auto* sql = cachedStatement(SQL::CreateObjectStoreKeyGenerator, &quot;INSERT INTO KeyGenerators VALUES (?, 0);&quot;_s);
 977         if (!sql
 978             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
 979             || sql-&gt;step() != SQLITE_DONE) {
 980             LOG_ERROR(&quot;Could not seed initial key generator value for ObjectStoreInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());


 981             return IDBError { UnknownError, &quot;Could not seed initial key generator value for object store&quot;_s };
 982         }
 983     }
 984 
 985     m_databaseInfo-&gt;addExistingObjectStore(info);
 986 
 987     return IDBError { };
 988 }
 989 
 990 IDBError SQLiteIDBBackingStore::deleteObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
 991 {
 992     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteObjectStore - object store %&quot; PRIu64, objectStoreIdentifier);
 993 
 994     ASSERT(m_sqliteDB);
 995     ASSERT(m_sqliteDB-&gt;isOpen());
 996 
 997     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified"> 998     if (!transaction || !transaction-&gt;inProgress())</span>

 999         return IDBError { UnknownError, &quot;Attempt to delete an object store without an in-progress transaction&quot;_s };
<span class="line-modified">1000 </span>
1001     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1002         LOG_ERROR(&quot;Attempt to delete an object store in a non-version-change transaction&quot;);
1003         return IDBError { UnknownError, &quot;Attempt to delete an object store in a non-version-change transaction&quot;_s };
1004     }
1005 
1006     // Delete the ObjectStore record
1007     {
1008         auto* sql = cachedStatement(SQL::DeleteObjectStoreInfo, &quot;DELETE FROM ObjectStoreInfo WHERE id = ?;&quot;_s);
1009         if (!sql
1010             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1011             || sql-&gt;step() != SQLITE_DONE) {
1012             LOG_ERROR(&quot;Could not delete object store id %&quot; PRIi64 &quot; from ObjectStoreInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1013             return IDBError { UnknownError, &quot;Could not delete object store&quot;_s };
1014         }
1015     }
1016 
1017     // Delete the ObjectStore&#39;s key generator record if there is one.
1018     {
1019         auto* sql = cachedStatement(SQL::DeleteObjectStoreKeyGenerator, &quot;DELETE FROM KeyGenerators WHERE objectStoreID = ?;&quot;_s);
1020         if (!sql
</pre>
<hr />
<pre>
1069     }
1070 
1071     // Delete all unused Blob File records.
1072     auto error = deleteUnusedBlobFileRecords(*transaction);
1073     if (!error.isNull())
1074         return error;
1075 
1076     m_databaseInfo-&gt;deleteObjectStore(objectStoreIdentifier);
1077 
1078     return IDBError { };
1079 }
1080 
1081 IDBError SQLiteIDBBackingStore::renameObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const String&amp; newName)
1082 {
1083     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::renameObjectStore - object store %&quot; PRIu64, objectStoreIdentifier);
1084 
1085     ASSERT(m_sqliteDB);
1086     ASSERT(m_sqliteDB-&gt;isOpen());
1087 
1088     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1089     if (!transaction || !transaction-&gt;inProgress())</span>

1090         return IDBError { UnknownError, &quot;Attempt to rename an object store without an in-progress transaction&quot;_s };
<span class="line-modified">1091 </span>
1092     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1093         LOG_ERROR(&quot;Attempt to rename an object store in a non-version-change transaction&quot;);
1094         return IDBError { UnknownError, &quot;Attempt to rename an object store in a non-version-change transaction&quot;_s };
1095     }
1096 
1097     {
1098         auto* sql = cachedStatement(SQL::RenameObjectStore, &quot;UPDATE ObjectStoreInfo SET name = ? WHERE id = ?;&quot;_s);
1099         if (!sql
1100             || sql-&gt;bindText(1, newName) != SQLITE_OK
1101             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1102             || sql-&gt;step() != SQLITE_DONE) {
1103             LOG_ERROR(&quot;Could not update name for object store id %&quot; PRIi64 &quot; in ObjectStoreInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());


1104             return IDBError { UnknownError, &quot;Could not rename object store&quot;_s };
1105         }
1106     }
1107 
1108     m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
1109 
1110     return IDBError { };
1111 }
1112 
1113 IDBError SQLiteIDBBackingStore::clearObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID)
1114 {
1115     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::clearObjectStore - object store %&quot; PRIu64, objectStoreID);
1116 
1117     ASSERT(m_sqliteDB);
1118     ASSERT(m_sqliteDB-&gt;isOpen());
1119 
1120     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1121     if (!transaction || !transaction-&gt;inProgress())</span>

1122         return IDBError { UnknownError, &quot;Attempt to clear an object store without an in-progress transaction&quot;_s };
<span class="line-modified">1123 </span>
1124     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1125         LOG_ERROR(&quot;Attempt to clear an object store in a read-only transaction&quot;);
1126         return IDBError { UnknownError, &quot;Attempt to clear an object store in a read-only transaction&quot;_s };
1127     }
1128 
1129     {
1130         auto* sql = cachedStatement(SQL::ClearObjectStoreRecords, &quot;DELETE FROM Records WHERE objectStoreID = ?;&quot;_s);
1131         if (!sql
1132             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1133             || sql-&gt;step() != SQLITE_DONE) {
1134             LOG_ERROR(&quot;Could not clear records from object store id %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1135             return IDBError { UnknownError, &quot;Unable to clear object store&quot;_s };
1136         }
1137     }
1138 
1139     {
1140         auto* sql = cachedStatement(SQL::ClearObjectStoreIndexRecords, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ?;&quot;_s);
1141         if (!sql
1142             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1143             || sql-&gt;step() != SQLITE_DONE) {
1144             LOG_ERROR(&quot;Could not delete records from index record store id %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1145             return IDBError { UnknownError, &quot;Unable to delete index records while clearing object store&quot;_s };
1146         }
1147     }
1148 
1149     transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1150 
1151     return IDBError { };
1152 }
1153 
1154 IDBError SQLiteIDBBackingStore::createIndex(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)
1155 {
1156     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::createIndex - ObjectStore %&quot; PRIu64 &quot;, Index %&quot; PRIu64, info.objectStoreIdentifier(), info.identifier());
1157     ASSERT(m_sqliteDB);
1158     ASSERT(m_sqliteDB-&gt;isOpen());
1159 
1160     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1161     if (!transaction || !transaction-&gt;inProgress())</span>

1162         return IDBError { UnknownError, &quot;Attempt to create an index without an in-progress transaction&quot;_s };
<span class="line-modified">1163 </span>
1164     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1165         LOG_ERROR(&quot;Attempt to create an index in a non-version-change transaction&quot;);
1166         return IDBError { UnknownError, &quot;Attempt to create an index in a non-version-change transaction&quot;_s };
1167     }
1168 
1169     RefPtr&lt;SharedBuffer&gt; keyPathBlob = serializeIDBKeyPath(info.keyPath());
1170     if (!keyPathBlob) {
1171         LOG_ERROR(&quot;Unable to serialize IDBKeyPath to save in database&quot;);
1172         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyPath to create index in database&quot;_s };
1173     }
1174 
1175     auto* sql = cachedStatement(SQL::CreateIndexInfo, &quot;INSERT INTO IndexInfo VALUES (?, ?, ?, ?, ?, ?);&quot;_s);
1176     if (!sql
1177         || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1178         || sql-&gt;bindText(2, info.name()) != SQLITE_OK
1179         || sql-&gt;bindInt64(3, info.objectStoreIdentifier()) != SQLITE_OK
1180         || sql-&gt;bindBlob(4, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
1181         || sql-&gt;bindInt(5, info.unique()) != SQLITE_OK
1182         || sql-&gt;bindInt(6, info.multiEntry()) != SQLITE_OK
1183         || sql-&gt;step() != SQLITE_DONE) {
1184         LOG_ERROR(&quot;Could not add index &#39;%s&#39; to IndexInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());


1185         return IDBError { UnknownError, &quot;Unable to create index in database&quot;_s };
1186     }
1187 
1188     // Write index records for any records that already exist in this object store.
1189 
1190     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(info.objectStoreIdentifier(), 0, IDBKeyRangeData::allKeys());
1191 
1192     if (!cursor) {
1193         LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);
1194         return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
1195     }
1196 
1197     while (!cursor-&gt;currentKey().isNull()) {
1198         auto&amp; key = cursor-&gt;currentKey();
1199         auto* value = cursor-&gt;currentValue();
1200         ThreadSafeDataBuffer valueBuffer = value ? value-&gt;data() : ThreadSafeDataBuffer();
1201 
1202         ASSERT(cursor-&gt;currentRecordRowID());
1203 
1204         IDBError error = updateOneIndexForAddRecord(info, key, valueBuffer, cursor-&gt;currentRecordRowID());
1205         if (!error.isNull()) {
1206             auto* sql = cachedStatement(SQL::DeleteIndexInfo, &quot;DELETE FROM IndexInfo WHERE id = ? AND objectStoreID = ?;&quot;_s);
1207             if (!sql
1208                 || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1209                 || sql-&gt;bindInt64(2, info.objectStoreIdentifier()) != SQLITE_OK
1210                 || sql-&gt;step() != SQLITE_DONE) {
1211                 LOG_ERROR(&quot;Index creation failed due to uniqueness constraint failure, but there was an error deleting the Index record from the database&quot;);
1212                 return IDBError { UnknownError, &quot;Index creation failed due to uniqueness constraint failure, but there was an error deleting the Index record from the database&quot;_s };
1213             }
1214 
1215             return error;
1216         }
1217 
1218         if (!cursor-&gt;advance(1)) {
1219             LOG_ERROR(&quot;Error advancing cursor while indexing existing records for new index.&quot;);
1220             return IDBError { UnknownError, &quot;Error advancing cursor while indexing existing records for new index&quot;_s };
1221         }
1222     }
1223 
<span class="line-added">1224     ASSERT(m_databaseInfo);</span>
<span class="line-added">1225     if (!m_databaseInfo) {</span>
<span class="line-added">1226         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - SQLiteIDBBackingStore::clearObjectStore: m_databaseInfo is null&quot;, this);</span>
<span class="line-added">1227         return IDBError { UnknownError, &quot;Database info is invalid&quot;_s };</span>
<span class="line-added">1228     }</span>
<span class="line-added">1229 </span>
1230     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
1231     ASSERT(objectStore);
1232     objectStore-&gt;addExistingIndex(info);
1233 
1234     return IDBError { };
1235 }
1236 
1237 IDBError SQLiteIDBBackingStore::uncheckedHasIndexRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; indexKey, bool&amp; hasRecord)
1238 {
1239     hasRecord = false;
1240 
1241     RefPtr&lt;SharedBuffer&gt; indexKeyBuffer = serializeIDBKeyData(indexKey);
1242     if (!indexKeyBuffer) {
1243         LOG_ERROR(&quot;Unable to serialize index key to be stored in the database&quot;);
1244         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for index record in database&quot;_s };
1245     }
1246 
1247     auto* sql = cachedStatement(SQL::HasIndexRecord, &quot;SELECT rowid FROM IndexRecords WHERE indexID = ? AND objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1248     if (!sql
1249         || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
</pre>
<hr />
<pre>
1313         LOG_ERROR(&quot;Unable to serialize index key to be stored in the database&quot;);
1314         return IDBError { UnknownError, &quot;Unable to serialize index key to be stored in the database&quot;_s };
1315     }
1316 
1317     RefPtr&lt;SharedBuffer&gt; valueBuffer = serializeIDBKeyData(keyValue);
1318     if (!valueBuffer) {
1319         LOG_ERROR(&quot;Unable to serialize the value to be stored in the database&quot;);
1320         return IDBError { UnknownError, &quot;Unable to serialize value to be stored in the database&quot;_s };
1321     }
1322 
1323     {
1324         auto* sql = cachedStatement(SQL::PutIndexRecord, &quot;INSERT INTO IndexRecords VALUES (?, ?, CAST(? AS TEXT), CAST(? AS TEXT), ?);&quot;_s);
1325         if (!sql
1326             || sql-&gt;bindInt64(1, indexID) != SQLITE_OK
1327             || sql-&gt;bindInt64(2, objectStoreID) != SQLITE_OK
1328             || sql-&gt;bindBlob(3, indexKeyBuffer-&gt;data(), indexKeyBuffer-&gt;size()) != SQLITE_OK
1329             || sql-&gt;bindBlob(4, valueBuffer-&gt;data(), valueBuffer-&gt;size()) != SQLITE_OK
1330             || sql-&gt;bindInt64(5, recordID) != SQLITE_OK
1331             || sql-&gt;step() != SQLITE_DONE) {
1332             LOG_ERROR(&quot;Could not put index record for index %&quot; PRIi64 &quot; in object store %&quot; PRIi64 &quot; in Records table (%i) - %s&quot;, indexID, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());


1333             return IDBError { UnknownError, &quot;Error putting index record into database&quot;_s };
1334         }
1335     }
1336 
1337     return IDBError { };
1338 }
1339 
1340 
1341 IDBError SQLiteIDBBackingStore::deleteIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)
1342 {
1343     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteIndex - object store %&quot; PRIu64, objectStoreIdentifier);
1344 
1345     ASSERT(m_sqliteDB);
1346     ASSERT(m_sqliteDB-&gt;isOpen());
1347 
1348     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1349     if (!transaction || !transaction-&gt;inProgress())</span>

1350         return IDBError { UnknownError, &quot;Attempt to delete index without an in-progress transaction&quot;_s };

1351 
1352     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1353         LOG_ERROR(&quot;Attempt to delete index during a non-version-change transaction&quot;);
1354         return IDBError { UnknownError, &quot;Attempt to delete index during a non-version-change transaction&quot;_s };
1355     }
1356 
1357     {
1358         auto* sql = cachedStatement(SQL::DeleteIndexInfo, &quot;DELETE FROM IndexInfo WHERE id = ? AND objectStoreID = ?;&quot;_s);
1359         if (!sql
1360             || sql-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK
1361             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1362             || sql-&gt;step() != SQLITE_DONE) {
1363             LOG_ERROR(&quot;Could not delete index id %&quot; PRIi64 &quot; from IndexInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1364             return IDBError { UnknownError, &quot;Error deleting index from database&quot;_s };
1365         }
1366     }
1367 
1368     {
1369         auto* sql = cachedStatement(SQL::DeleteIndexRecords, &quot;DELETE FROM IndexRecords WHERE indexID = ? AND objectStoreID = ?;&quot;_s);
1370         if (!sql
</pre>
<hr />
<pre>
1382 
1383     return IDBError { };
1384 }
1385 
1386 IDBError SQLiteIDBBackingStore::renameIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
1387 {
1388     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::renameIndex - object store %&quot; PRIu64 &quot;, index %&quot; PRIu64, objectStoreIdentifier, indexIdentifier);
1389 
1390     ASSERT(m_sqliteDB);
1391     ASSERT(m_sqliteDB-&gt;isOpen());
1392 
1393     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1394     if (!objectStoreInfo)
1395         return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1396 
1397     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
1398     if (!indexInfo)
1399         return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1400 
1401     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1402     if (!transaction || !transaction-&gt;inProgress())</span>

1403         return IDBError { UnknownError, &quot;Attempt to rename an index without an in-progress transaction&quot;_s };

1404 
1405     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1406         LOG_ERROR(&quot;Attempt to rename an index in a non-version-change transaction&quot;);
1407         return IDBError { UnknownError, &quot;Attempt to rename an index in a non-version-change transaction&quot;_s };
1408     }
1409 
1410     {
1411         auto* sql = cachedStatement(SQL::RenameIndex, &quot;UPDATE IndexInfo SET name = ? WHERE objectStoreID = ? AND id = ?;&quot;_s);
1412         if (!sql
1413             || sql-&gt;bindText(1, newName) != SQLITE_OK
1414             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1415             || sql-&gt;bindInt64(3, indexIdentifier) != SQLITE_OK
1416             || sql-&gt;step() != SQLITE_DONE) {
1417             LOG_ERROR(&quot;Could not update name for index id (%&quot; PRIi64 &quot;, %&quot; PRIi64 &quot;) in IndexInfo table (%i) - %s&quot;, objectStoreIdentifier, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());


1418             return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1419         }
1420     }
1421 
1422     indexInfo-&gt;rename(newName);
1423 
1424     return IDBError { };
1425 }
1426 
1427 IDBError SQLiteIDBBackingStore::keyExistsInObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyData&amp; keyData, bool&amp; keyExists)
1428 {
1429     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::keyExistsInObjectStore - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreID);
1430 
1431     ASSERT(m_sqliteDB);
1432     ASSERT(m_sqliteDB-&gt;isOpen());
1433 
1434     keyExists = false;
1435 
1436     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1437     if (!transaction || !transaction-&gt;inProgress())</span>

1438         return IDBError { UnknownError, &quot;Attempt to see if key exists in objectstore without an in-progress transaction&quot;_s };

1439 
1440     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1441     if (!keyBuffer) {
1442         LOG_ERROR(&quot;Unable to serialize IDBKey to check for existence in object store&quot;);
1443         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for existence in object store&quot;_s };
1444     }
1445     auto* sql = cachedStatement(SQL::KeyExistsInObjectStore, &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT) LIMIT 1;&quot;_s);
1446     if (!sql
1447         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1448         || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK) {
1449         LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1450         return IDBError { UnknownError, &quot;Unable to check for existence of IDBKey in object store&quot;_s };
1451     }
1452 
1453     int sqlResult = sql-&gt;step();
1454     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE)
1455         return IDBError { };
1456 
1457     if (sqlResult != SQLITE_ROW) {
1458         // There was an error fetching the record from the database.
</pre>
<hr />
<pre>
1590         if (!sql
1591             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1592             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1593             || sql-&gt;step() != SQLITE_DONE) {
1594             LOG_ERROR(&quot;Could not delete record from indexes for object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1595             return IDBError { UnknownError, &quot;Failed to delete index entries for object store record&quot;_s };
1596         }
1597     }
1598 
1599     return IDBError { };
1600 }
1601 
1602 IDBError SQLiteIDBBackingStore::deleteRange(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData&amp; keyRange)
1603 {
1604     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteRange - range %s, object store %&quot; PRIu64, keyRange.loggingString().utf8().data(), objectStoreID);
1605 
1606     ASSERT(m_sqliteDB);
1607     ASSERT(m_sqliteDB-&gt;isOpen());
1608 
1609     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1610     if (!transaction || !transaction-&gt;inProgress())</span>

1611         return IDBError { UnknownError, &quot;Attempt to delete range from database without an in-progress transaction&quot;_s };
<span class="line-modified">1612 </span>
1613     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1614         LOG_ERROR(&quot;Attempt to delete records from an object store in a read-only transaction&quot;);
1615         return IDBError { UnknownError, &quot;Attempt to delete records from an object store in a read-only transaction&quot;_s };
1616     }
1617 
1618     // If the range to delete is exactly one key we can delete it right now.
1619     if (keyRange.isExactlyOneKey()) {
1620         auto error = deleteRecord(*transaction, objectStoreID, keyRange.lowerKey);
1621         if (!error.isNull()) {
1622             LOG_ERROR(&quot;Failed to delete record for key &#39;%s&#39;&quot;, keyRange.lowerKey.loggingString().utf8().data());
1623             return error;
1624         }
1625 
1626         transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1627 
1628         return IDBError { };
1629     }
1630 
1631     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreID, 0, keyRange);
1632     if (!cursor) {
</pre>
<hr />
<pre>
1644         LOG_ERROR(&quot;Cursor failed while accumulating range of records from the database&quot;);
1645         return IDBError { UnknownError, &quot;Cursor failed while accumulating range of records from the database&quot;_s };
1646     }
1647 
1648     IDBError error;
1649     for (auto&amp; key : keys) {
1650         error = deleteRecord(*transaction, objectStoreID, key);
1651         if (!error.isNull()) {
1652             LOG_ERROR(&quot;deleteRange: Error deleting keys in range&quot;);
1653             break;
1654         }
1655     }
1656 
1657     transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1658 
1659     return error;
1660 }
1661 
1662 IDBError SQLiteIDBBackingStore::updateOneIndexForAddRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; key, const ThreadSafeDataBuffer&amp; value, int64_t recordID)
1663 {
<span class="line-modified">1664     JSLockHolder locker(m_serializationContext-&gt;vm());</span>
1665 
<span class="line-modified">1666     auto jsValue = deserializeIDBValueToJSValue(m_serializationContext-&gt;execState(), value);</span>
1667     if (jsValue.isUndefinedOrNull())
1668         return IDBError { };
1669 
1670     IndexKey indexKey;
<span class="line-modified">1671     auto* objectStoreInfo = infoForObjectStore(info.objectStoreIdentifier());</span>
<span class="line-added">1672     ASSERT(objectStoreInfo);</span>
<span class="line-added">1673     generateIndexKeyForValue(m_serializationContext-&gt;execState(), info, jsValue, indexKey, objectStoreInfo-&gt;keyPath(), key);</span>
1674 
1675     if (indexKey.isNull())
1676         return IDBError { };
1677 
1678     return uncheckedPutIndexKey(info, key, indexKey, recordID);
1679 }
1680 
1681 IDBError SQLiteIDBBackingStore::updateAllIndexesForAddRecord(const IDBObjectStoreInfo&amp; info, const IDBKeyData&amp; key, const ThreadSafeDataBuffer&amp; value, int64_t recordID)
1682 {
<span class="line-modified">1683     JSLockHolder locker(m_serializationContext-&gt;vm());</span>
1684 
<span class="line-modified">1685     auto jsValue = deserializeIDBValueToJSValue(m_serializationContext-&gt;execState(), value);</span>
1686     if (jsValue.isUndefinedOrNull())
1687         return IDBError { };
1688 
1689     IDBError error;
1690     bool anyRecordsSucceeded = false;
1691     for (auto&amp; index : info.indexMap().values()) {
1692         IndexKey indexKey;
<span class="line-modified">1693         generateIndexKeyForValue(m_serializationContext-&gt;execState(), index, jsValue, indexKey, info.keyPath(), key);</span>
1694 
1695         if (indexKey.isNull())
1696             continue;
1697 
1698         error = uncheckedPutIndexKey(index, key, indexKey, recordID);
1699         if (!error.isNull())
1700             break;
1701 
1702         anyRecordsSucceeded = true;
1703     }
1704 
1705     if (!error.isNull() &amp;&amp; anyRecordsSucceeded) {
1706         RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(key);
1707 
1708         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND value = CAST(? AS TEXT);&quot;_s);
1709 
1710         if (!sql
1711             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1712             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1713             || sql-&gt;step() != SQLITE_DONE) {
1714             LOG_ERROR(&quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;);
1715             return IDBError { UnknownError, &quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;_s };
1716         }
1717     }
1718 
1719     return error;
1720 }
1721 
1722 IDBError SQLiteIDBBackingStore::addRecord(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; objectStoreInfo, const IDBKeyData&amp; keyData, const IDBValue&amp; value)
1723 {
1724     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::addRecord - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreInfo.identifier());
1725 
1726     ASSERT(m_sqliteDB);
1727     ASSERT(m_sqliteDB-&gt;isOpen());
1728     ASSERT(value.data().data());
1729     ASSERT(value.blobURLs().size() == value.blobFilePaths().size());
1730 
1731     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1732     if (!transaction || !transaction-&gt;inProgress())</span>

1733         return IDBError { UnknownError, &quot;Attempt to store a record in an object store without an in-progress transaction&quot;_s };
<span class="line-modified">1734 </span>
1735     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1736         LOG_ERROR(&quot;Attempt to store a record in an object store in a read-only transaction&quot;);
1737         return IDBError { UnknownError, &quot;Attempt to store a record in an object store in a read-only transaction&quot;_s };
1738     }
1739 
1740     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1741     if (!keyBuffer) {
1742         LOG_ERROR(&quot;Unable to serialize IDBKey to be stored in an object store&quot;);
1743         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to be stored in an object store&quot;_s };
1744     }
1745 
1746     int64_t recordID = 0;
1747     {
1748         auto* sql = cachedStatement(SQL::AddObjectStoreRecord, &quot;INSERT INTO Records VALUES (?, CAST(? AS TEXT), ?, NULL);&quot;_s);
1749         if (!sql
1750             || sql-&gt;bindInt64(1, objectStoreInfo.identifier()) != SQLITE_OK
1751             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1752             || sql-&gt;bindBlob(3, value.data().data()-&gt;data(), value.data().data()-&gt;size()) != SQLITE_OK
1753             || sql-&gt;step() != SQLITE_DONE) {
1754             LOG_ERROR(&quot;Could not put record for object store %&quot; PRIi64 &quot; in Records table (%i) - %s&quot;, objectStoreInfo.identifier(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());


1755             return IDBError { UnknownError, &quot;Unable to store record in object store&quot;_s };
1756         }
1757 
1758         recordID = m_sqliteDB-&gt;lastInsertRowID();
1759     }
1760 
1761     auto error = updateAllIndexesForAddRecord(objectStoreInfo, keyData, value.data(), recordID);
1762 
1763     if (!error.isNull()) {
1764         auto* sql = cachedStatement(SQL::DeleteObjectStoreRecord, &quot;DELETE FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1765         if (!sql
1766             || sql-&gt;bindInt64(1, objectStoreInfo.identifier()) != SQLITE_OK
1767             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1768             || sql-&gt;step() != SQLITE_DONE) {
1769             LOG_ERROR(&quot;Indexing new object store record failed, but unable to remove the object store record itself&quot;);
1770             return IDBError { UnknownError, &quot;Indexing new object store record failed, but unable to remove the object store record itself&quot;_s };
1771         }
1772 
1773         return error;
1774     }
1775 
1776     const Vector&lt;String&gt;&amp; blobURLs = value.blobURLs();
1777     const Vector&lt;String&gt;&amp; blobFiles = value.blobFilePaths();
1778     for (size_t i = 0; i &lt; blobURLs.size(); ++i) {
1779         auto&amp; url = blobURLs[i];
1780         {
1781             auto* sql = cachedStatement(SQL::AddBlobRecord, &quot;INSERT INTO BlobRecords VALUES (?, ?);&quot;_s);
1782             if (!sql
1783                 || sql-&gt;bindInt64(1, recordID) != SQLITE_OK
1784                 || sql-&gt;bindText(2, url) != SQLITE_OK
1785                 || sql-&gt;step() != SQLITE_DONE) {
1786                 LOG_ERROR(&quot;Unable to record Blob record in database&quot;);


1787                 return IDBError { UnknownError, &quot;Unable to record Blob record in database&quot;_s };
1788             }
1789         }
1790         int64_t potentialFileNameInteger = m_sqliteDB-&gt;lastInsertRowID();
1791 
1792         // If we already have a file for this blobURL, nothing left to do.
1793         {
1794             auto* sql = cachedStatement(SQL::BlobFilenameForBlobURL, &quot;SELECT fileName FROM BlobFiles WHERE blobURL = ?;&quot;_s);
1795             if (!sql
1796                 || sql-&gt;bindText(1, url) != SQLITE_OK) {
1797                 LOG_ERROR(&quot;Unable to examine Blob filenames in database&quot;);
1798                 return IDBError { UnknownError, &quot;Unable to examine Blob filenames in database&quot;_s };
1799             }
1800 
1801             int result = sql-&gt;step();
1802             if (result != SQLITE_ROW &amp;&amp; result != SQLITE_DONE) {
1803                 LOG_ERROR(&quot;Unable to examine Blob filenames in database&quot;);
1804                 return IDBError { UnknownError, &quot;Unable to examine Blob filenames in database&quot;_s };
1805             }
1806 
1807             if (result == SQLITE_ROW)
1808                 continue;
1809         }
1810 
1811         // We don&#39;t already have a file for this blobURL, so commit our file as a unique filename
1812         String storedFilename = makeString(potentialFileNameInteger, &quot;.blob&quot;);
1813         {
1814             auto* sql = cachedStatement(SQL::AddBlobFilename, &quot;INSERT INTO BlobFiles VALUES (?, ?);&quot;_s);
1815             if (!sql
1816                 || sql-&gt;bindText(1, url) != SQLITE_OK
1817                 || sql-&gt;bindText(2, storedFilename) != SQLITE_OK
1818                 || sql-&gt;step() != SQLITE_DONE) {
1819                 LOG_ERROR(&quot;Unable to record Blob file record in database&quot;);


1820                 return IDBError { UnknownError, &quot;Unable to record Blob file record in database&quot;_s };
1821             }
1822         }
1823 
1824         transaction-&gt;addBlobFile(blobFiles[i], storedFilename);
1825     }
1826 
1827     transaction-&gt;notifyCursorsOfChanges(objectStoreInfo.identifier());
1828 
1829     return error;
1830 }
1831 
<span class="line-modified">1832 IDBError SQLiteIDBBackingStore::getBlobRecordsForObjectStoreRecord(int64_t objectStoreRecord, Vector&lt;String&gt;&amp; blobURLs, Vector&lt;String&gt;&amp; blobFilePaths)</span>
1833 {
1834     ASSERT(objectStoreRecord);
1835 
1836     HashSet&lt;String&gt; blobURLSet;
1837     {
1838         auto* sql = cachedStatement(SQL::GetBlobURL, &quot;SELECT blobURL FROM BlobRecords WHERE objectStoreRow = ?&quot;_s);
1839         if (!sql
1840             || sql-&gt;bindInt64(1, objectStoreRecord) != SQLITE_OK) {
1841             LOG_ERROR(&quot;Could not prepare statement to fetch blob URLs for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1842             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1843         }
1844 
1845         int sqlResult = sql-&gt;step();
1846         if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE) {
1847             // There are no blobURLs in the database for this object store record.
1848             return IDBError { };
1849         }
1850 
1851         while (sqlResult == SQLITE_ROW) {
1852             blobURLSet.add(sql-&gt;getColumnText(0));
1853             sqlResult = sql-&gt;step();
1854         }
1855 
1856         if (sqlResult != SQLITE_DONE) {
1857             LOG_ERROR(&quot;Could not fetch blob URLs for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1858             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1859         }
1860     }
1861 
1862     ASSERT(!blobURLSet.isEmpty());

1863     for (auto&amp; blobURL : blobURLSet) {
1864         auto* sql = cachedStatement(SQL::BlobFilenameForBlobURL, &quot;SELECT fileName FROM BlobFiles WHERE blobURL = ?;&quot;_s);
1865         if (!sql
1866             || sql-&gt;bindText(1, blobURL) != SQLITE_OK) {
1867             LOG_ERROR(&quot;Could not prepare statement to fetch blob filename for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1868             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1869         }
1870 
1871         if (sql-&gt;step() != SQLITE_ROW) {
1872             LOG_ERROR(&quot;Entry for blob filename for blob url %s does not exist (%i) - %s&quot;, blobURL.utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1873             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1874         }
1875 
1876         blobURLs.append(blobURL);
1877 
1878         String fileName = sql-&gt;getColumnText(0);
<span class="line-modified">1879         blobFilePaths.append(FileSystem::pathByAppendingComponent(m_databaseDirectory, fileName));</span>
1880     }


1881     return IDBError { };
1882 }
1883 
1884 IDBError SQLiteIDBBackingStore::getRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData&amp; keyRange, IDBGetRecordDataType type, IDBGetResult&amp; resultValue)
1885 {
1886     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getRecord - key range %s, object store %&quot; PRIu64, keyRange.loggingString().utf8().data(), objectStoreID);
1887 
1888     ASSERT(m_sqliteDB);
1889     ASSERT(m_sqliteDB-&gt;isOpen());
1890 
1891     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">1892     if (!transaction || !transaction-&gt;inProgress())</span>

1893         return IDBError { UnknownError, &quot;Attempt to get a record from database without an in-progress transaction&quot;_s };

1894 
1895     auto key = keyRange.lowerKey;
1896     if (key.isNull())
1897         key = IDBKeyData::minimum();
1898     RefPtr&lt;SharedBuffer&gt; lowerBuffer = serializeIDBKeyData(key);
1899     if (!lowerBuffer) {
1900         LOG_ERROR(&quot;Unable to serialize lower IDBKey in lookup range&quot;);
1901         return IDBError { UnknownError, &quot;Unable to serialize lower IDBKey in lookup range&quot;_s };
1902     }
1903 
1904     key = keyRange.upperKey;
1905     if (key.isNull())
1906         key = IDBKeyData::maximum();
1907     RefPtr&lt;SharedBuffer&gt; upperBuffer = serializeIDBKeyData(key);
1908     if (!upperBuffer) {
1909         LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);
1910         return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range&quot;_s };
1911     }
1912 
1913     int64_t recordID = 0;
<span class="line-modified">1914     ThreadSafeDataBuffer keyResultBuffer, valueResultBuffer;</span>
1915     {
<span class="line-modified">1916         static const char* const lowerOpenUpperOpen = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">1917         static const char* const lowerOpenUpperClosed = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">1918         static const char* const lowerClosedUpperOpen = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">1919         static const char* const lowerClosedUpperClosed = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
1920 
1921         static const char* const lowerOpenUpperOpenKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
1922         static const char* const lowerOpenUpperClosedKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
1923         static const char* const lowerClosedUpperOpenKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
1924         static const char* const lowerClosedUpperClosedKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
1925 
1926         SQLiteStatement* sql = nullptr;
1927 
1928         switch (type) {
1929         case IDBGetRecordDataType::KeyAndValue:
1930             if (keyRange.lowerOpen) {
1931                 if (keyRange.upperOpen)
1932                     sql = cachedStatement(SQL::GetValueRecordsLowerOpenUpperOpen, lowerOpenUpperOpen);
1933                 else
1934                     sql = cachedStatement(SQL::GetValueRecordsLowerOpenUpperClosed, lowerOpenUpperClosed);
1935             } else {
1936                 if (keyRange.upperOpen)
1937                     sql = cachedStatement(SQL::GetValueRecordsLowerClosedUpperOpen, lowerClosedUpperOpen);
1938                 else
1939                     sql = cachedStatement(SQL::GetValueRecordsLowerClosedUpperClosed, lowerClosedUpperClosed);
</pre>
<hr />
<pre>
1956         if (!sql
1957             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1958             || sql-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK
1959             || sql-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {
1960             LOG_ERROR(&quot;Could not get key range record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1961             return IDBError { UnknownError, &quot;Failed to look up record in object store by key range&quot;_s };
1962         }
1963 
1964         int sqlResult = sql-&gt;step();
1965 
1966         if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE) {
1967             // There was no record for the key in the database.
1968             return IDBError { };
1969         }
1970         if (sqlResult != SQLITE_ROW) {
1971             // There was an error fetching the record from the database.
1972             LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1973             return IDBError { UnknownError, &quot;Error looking up record in object store by key range&quot;_s };
1974         }
1975 
<span class="line-modified">1976         Vector&lt;uint8_t&gt; keyBuffer;</span>
<span class="line-modified">1977         sql-&gt;getColumnBlobAsVector(0, keyBuffer);</span>
<span class="line-modified">1978         keyResultBuffer = ThreadSafeDataBuffer::create(WTFMove(keyBuffer));</span>
1979 
<span class="line-modified">1980         if (type == IDBGetRecordDataType::KeyAndValue) {</span>
<span class="line-modified">1981             Vector&lt;uint8_t&gt; valueBuffer;</span>
<span class="line-added">1982             sql-&gt;getColumnBlobAsVector(1, valueBuffer);</span>
<span class="line-added">1983             valueResultBuffer = ThreadSafeDataBuffer::create(WTFMove(valueBuffer));</span>
<span class="line-added">1984             recordID = sql-&gt;getColumnInt64(2);</span>
<span class="line-added">1985         }</span>
1986     }
1987 
<span class="line-modified">1988     auto* keyVector = keyResultBuffer.data();</span>
<span class="line-modified">1989     if (!keyVector) {</span>
<span class="line-modified">1990         LOG_ERROR(&quot;Unable to deserialize key data from database for IDBObjectStore&quot;);</span>
<span class="line-modified">1991         return IDBError { UnknownError, &quot;Error extracting key data from database executing IDBObjectStore get&quot;_s };</span>
<span class="line-modified">1992     }</span>

1993 
<span class="line-modified">1994     IDBKeyData keyData;</span>
<span class="line-modified">1995     if (!deserializeIDBKeyData(keyVector-&gt;data(), keyVector-&gt;size(), keyData)) {</span>
<span class="line-modified">1996         LOG_ERROR(&quot;Unable to deserialize key data from database for IDBObjectStore&quot;);</span>
<span class="line-modified">1997         return IDBError { UnknownError, &quot;Error extracting key data from database executing IDBObjectStore get&quot;_s };</span>
<span class="line-modified">1998     }</span>
1999 
<span class="line-added">2000     if (type == IDBGetRecordDataType::KeyOnly) {</span>
2001         resultValue = { keyData };
2002         return IDBError { };
2003     }
2004 
2005     ASSERT(recordID);
2006     Vector&lt;String&gt; blobURLs, blobFilePaths;
<span class="line-modified">2007     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);</span>

2008     ASSERT(blobURLs.size() == blobFilePaths.size());
2009 
2010     if (!error.isNull())
2011         return error;
2012 
<span class="line-modified">2013     auto* objectStoreInfo = infoForObjectStore(objectStoreID);</span>
<span class="line-added">2014     ASSERT(objectStoreInfo);</span>
<span class="line-added">2015     resultValue = { keyData, { valueResultBuffer, WTFMove(blobURLs), WTFMove(blobFilePaths) }, objectStoreInfo-&gt;keyPath()};</span>
2016     return IDBError { };
2017 }
2018 
2019 IDBError SQLiteIDBBackingStore::getAllRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2020 {
2021     return getAllRecordsData.indexIdentifier ? getAllIndexRecords(transactionIdentifier, getAllRecordsData, result) : getAllObjectStoreRecords(transactionIdentifier, getAllRecordsData, result);
2022 }
2023 
2024 SQLiteStatement* SQLiteIDBBackingStore::cachedStatementForGetAllObjectStoreRecords(const IDBGetAllRecordsData&amp; getAllRecordsData)
2025 {
2026     static const char* const lowerOpenUpperOpenKey =&quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2027     static const char* const lowerOpenUpperClosedKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2028     static const char* const lowerClosedUpperOpenKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2029     static const char* const lowerClosedUpperClosedKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
<span class="line-modified">2030     static const char* const lowerOpenUpperOpenValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">2031     static const char* const lowerOpenUpperClosedValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">2032     static const char* const lowerClosedUpperOpenValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">2033     static const char* const lowerClosedUpperClosedValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
2034 
2035     if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Keys) {
2036         if (getAllRecordsData.keyRangeData.lowerOpen) {
2037             if (getAllRecordsData.keyRangeData.upperOpen)
2038                 return cachedStatement(SQL::GetAllKeyRecordsLowerOpenUpperOpen, lowerOpenUpperOpenKey);
2039             return cachedStatement(SQL::GetAllKeyRecordsLowerOpenUpperClosed, lowerOpenUpperClosedKey);
2040         }
2041 
2042         if (getAllRecordsData.keyRangeData.upperOpen)
2043             return cachedStatement(SQL::GetAllKeyRecordsLowerClosedUpperOpen, lowerClosedUpperOpenKey);
2044         return cachedStatement(SQL::GetAllKeyRecordsLowerClosedUpperClosed, lowerClosedUpperClosedKey);
2045     }
2046 
2047     if (getAllRecordsData.keyRangeData.lowerOpen) {
2048         if (getAllRecordsData.keyRangeData.upperOpen)
2049             return cachedStatement(SQL::GetValueRecordsLowerOpenUpperOpen, lowerOpenUpperOpenValue);
2050         return cachedStatement(SQL::GetValueRecordsLowerOpenUpperClosed, lowerOpenUpperClosedValue);
2051     }
2052 
2053     if (getAllRecordsData.keyRangeData.upperOpen)
2054         return cachedStatement(SQL::GetValueRecordsLowerClosedUpperOpen, lowerClosedUpperOpenValue);
2055     return cachedStatement(SQL::GetValueRecordsLowerClosedUpperClosed, lowerClosedUpperClosedValue);
2056 }
2057 
2058 IDBError SQLiteIDBBackingStore::getAllObjectStoreRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2059 {
2060     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getAllObjectStoreRecords&quot;);
2061 
2062     ASSERT(m_sqliteDB);
2063     ASSERT(m_sqliteDB-&gt;isOpen());
2064 
2065     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2066     if (!transaction || !transaction-&gt;inProgress())</span>

2067         return IDBError { UnknownError, &quot;Attempt to get records from database without an in-progress transaction&quot;_s };

2068 
2069     auto key = getAllRecordsData.keyRangeData.lowerKey;
2070     if (key.isNull())
2071         key = IDBKeyData::minimum();
2072     auto lowerBuffer = serializeIDBKeyData(key);
2073     if (!lowerBuffer) {
2074         LOG_ERROR(&quot;Unable to serialize lower IDBKey in lookup range&quot;);
2075         return IDBError { UnknownError, &quot;Unable to serialize lower IDBKey in lookup range&quot;_s };
2076     }
2077 
2078     key = getAllRecordsData.keyRangeData.upperKey;
2079     if (key.isNull())
2080         key = IDBKeyData::maximum();
2081     auto upperBuffer = serializeIDBKeyData(key);
2082     if (!upperBuffer) {
2083         LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);
2084         return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range&quot;_s };
2085     }
2086 
2087     auto* sql = cachedStatementForGetAllObjectStoreRecords(getAllRecordsData);
2088     if (!sql
2089         || sql-&gt;bindInt64(1, getAllRecordsData.objectStoreIdentifier) != SQLITE_OK
2090         || sql-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK
2091         || sql-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {
2092         LOG_ERROR(&quot;Could not get key range record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, getAllRecordsData.objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2093         return IDBError { UnknownError, &quot;Failed to look up record in object store by key range&quot;_s };
2094     }
2095 
<span class="line-modified">2096     auto* objectStoreInfo = infoForObjectStore(getAllRecordsData.objectStoreIdentifier);</span>
<span class="line-added">2097     ASSERT(objectStoreInfo);</span>
<span class="line-added">2098     result = { getAllRecordsData.getAllType, objectStoreInfo-&gt;keyPath() };</span>
2099 
2100     uint32_t targetResults;
2101     if (getAllRecordsData.count &amp;&amp; getAllRecordsData.count.value())
2102         targetResults = getAllRecordsData.count.value();
2103     else
2104         targetResults = std::numeric_limits&lt;uint32_t&gt;::max();
2105 
2106     int sqlResult = sql-&gt;step();
2107     uint32_t returnedResults = 0;
2108 
2109     while (sqlResult == SQLITE_ROW &amp;&amp; returnedResults &lt; targetResults) {
<span class="line-added">2110         Vector&lt;uint8_t&gt; keyBuffer;</span>
<span class="line-added">2111         IDBKeyData keyData;</span>
<span class="line-added">2112         sql-&gt;getColumnBlobAsVector(0, keyBuffer);</span>
<span class="line-added">2113         if (!deserializeIDBKeyData(keyBuffer.data(), keyBuffer.size(), keyData)) {</span>
<span class="line-added">2114             LOG_ERROR(&quot;Unable to deserialize key data from database while getting all records&quot;);</span>
<span class="line-added">2115             return IDBError { UnknownError, &quot;Unable to deserialize key data while getting all records&quot;_s };</span>
<span class="line-added">2116         }</span>
<span class="line-added">2117         result.addKey(WTFMove(keyData));</span>
<span class="line-added">2118 </span>
2119         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values) {
<span class="line-modified">2120             Vector&lt;uint8_t&gt; valueBuffer;</span>
<span class="line-modified">2121             sql-&gt;getColumnBlobAsVector(1, valueBuffer);</span>
<span class="line-modified">2122             ThreadSafeDataBuffer valueResultBuffer = ThreadSafeDataBuffer::create(WTFMove(valueBuffer));</span>
2123 
<span class="line-modified">2124             auto recordID = sql-&gt;getColumnInt64(2);</span>
2125 
2126             ASSERT(recordID);
2127             Vector&lt;String&gt; blobURLs, blobFilePaths;
<span class="line-modified">2128             auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);</span>

2129             ASSERT(blobURLs.size() == blobFilePaths.size());
2130 
2131             if (!error.isNull())
2132                 return error;
2133 
<span class="line-modified">2134             result.addValue({ valueResultBuffer, WTFMove(blobURLs), WTFMove(blobFilePaths) });</span>











2135         }
2136 
2137         ++returnedResults;
2138         sqlResult = sql-&gt;step();
2139     }
2140 
2141     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE || sqlResult == SQLITE_ROW) {
2142         // Finished getting results
2143         return IDBError { };
2144     }
2145 
2146     // There was an error fetching records from the database.
2147     LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, getAllRecordsData.objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2148     return IDBError { UnknownError, &quot;Error looking up record in object store by key range&quot;_s };
2149 }
2150 
2151 IDBError SQLiteIDBBackingStore::getAllIndexRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2152 {
2153     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getAllIndexRecords - %s&quot;, getAllRecordsData.keyRangeData.loggingString().utf8().data());
2154 
2155     ASSERT(m_sqliteDB);
2156     ASSERT(m_sqliteDB-&gt;isOpen());
2157 
2158     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2159     if (!transaction || !transaction-&gt;inProgress())</span>

2160         return IDBError { UnknownError, &quot;Attempt to get all index records from database without an in-progress transaction&quot;_s };

2161 
2162     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(getAllRecordsData.objectStoreIdentifier, getAllRecordsData.indexIdentifier, getAllRecordsData.keyRangeData);
2163     if (!cursor) {
2164         LOG_ERROR(&quot;Cannot open cursor to perform index gets in database&quot;);
2165         return IDBError { UnknownError, &quot;Cannot open cursor to perform index gets in database&quot;_s };
2166     }
2167 
2168     if (cursor-&gt;didError()) {
2169         LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
2170         return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
2171     }
2172 
<span class="line-modified">2173     auto* objectStoreInfo = infoForObjectStore(getAllRecordsData.objectStoreIdentifier);</span>
<span class="line-added">2174     ASSERT(objectStoreInfo);</span>
<span class="line-added">2175     result = { getAllRecordsData.getAllType, objectStoreInfo-&gt;keyPath() };</span>
<span class="line-added">2176 </span>
2177     uint32_t currentCount = 0;
2178     uint32_t targetCount = getAllRecordsData.count ? getAllRecordsData.count.value() : 0;
2179     if (!targetCount)
2180         targetCount = std::numeric_limits&lt;uint32_t&gt;::max();
2181     while (!cursor-&gt;didComplete() &amp;&amp; !cursor-&gt;didError() &amp;&amp; currentCount &lt; targetCount) {
<span class="line-modified">2182         IDBKeyData keyCopy = cursor-&gt;currentPrimaryKey();</span>
<span class="line-modified">2183         result.addKey(WTFMove(keyCopy));</span>
<span class="line-modified">2184         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values)</span>

2185             result.addValue(cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue());
2186 
2187         ++currentCount;
2188         cursor-&gt;advance(1);
2189     }
2190 
2191     if (cursor-&gt;didError()) {
2192         LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
2193         return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
2194     }
2195 
2196     return IDBError { };
2197 }
2198 
2199 IDBError SQLiteIDBBackingStore::getIndexRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t indexID, IndexedDB::IndexRecordType type, const IDBKeyRangeData&amp; range, IDBGetResult&amp; getResult)
2200 {
2201     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getIndexRecord - %s&quot;, range.loggingString().utf8().data());
2202 
2203     ASSERT(m_sqliteDB);
2204     ASSERT(m_sqliteDB-&gt;isOpen());
2205 
2206     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2207     if (!transaction || !transaction-&gt;inProgress())</span>

2208         return IDBError { UnknownError, &quot;Attempt to get an index record from database without an in-progress transaction&quot;_s };

2209 
2210     if (range.isExactlyOneKey())
2211         return uncheckedGetIndexRecordForOneKey(indexID, objectStoreID, type, range.lowerKey, getResult);
2212 
2213     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreID, indexID, range);
2214     if (!cursor) {
2215         LOG_ERROR(&quot;Cannot open cursor to perform index get in database&quot;);
2216         return IDBError { UnknownError, &quot;Cannot open cursor to perform index get in database&quot;_s };
2217     }
2218 
2219     if (cursor-&gt;didError()) {
2220         LOG_ERROR(&quot;Cursor failed while looking up index record in database&quot;);
2221         return IDBError { UnknownError, &quot;Cursor failed while looking up index record in database&quot;_s };
2222     }
2223 
2224     if (cursor-&gt;didComplete())
2225         getResult = { };
2226     else {
2227         if (type == IndexedDB::IndexRecordType::Key)
2228             getResult = { cursor-&gt;currentPrimaryKey() };
<span class="line-modified">2229         else {</span>
<span class="line-modified">2230             auto* objectStoreInfo = infoForObjectStore(objectStoreID);</span>
<span class="line-added">2231             ASSERT(objectStoreInfo);</span>
<span class="line-added">2232             getResult = { cursor-&gt;currentPrimaryKey(), cursor-&gt;currentPrimaryKey(), cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue(), objectStoreInfo-&gt;keyPath() };</span>
<span class="line-added">2233         }</span>
2234     }
2235 
2236     return IDBError { };
2237 }
2238 
2239 IDBError SQLiteIDBBackingStore::uncheckedGetIndexRecordForOneKey(int64_t indexID, int64_t objectStoreID, IndexedDB::IndexRecordType type, const IDBKeyData&amp; key, IDBGetResult&amp; getResult)
2240 {
2241     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::uncheckedGetIndexRecordForOneKey&quot;);
2242 
2243     ASSERT(key.isValid() &amp;&amp; key.type() != IndexedDB::KeyType::Max &amp;&amp; key.type() != IndexedDB::KeyType::Min);
2244 
2245     RefPtr&lt;SharedBuffer&gt; buffer = serializeIDBKeyData(key);
2246     if (!buffer) {
2247         LOG_ERROR(&quot;Unable to serialize IDBKey to look up one index record&quot;);
2248         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to look up one index record&quot;_s };
2249     }
2250 
2251     auto* sql = cachedStatement(SQL::GetIndexRecordForOneKey, &quot;SELECT IndexRecords.value, Records.value, Records.recordID FROM Records INNER JOIN IndexRecords ON Records.recordID = IndexRecords.objectStoreRecordID WHERE IndexRecords.indexID = ? AND IndexRecords.objectStoreID = ? AND IndexRecords.key = CAST(? AS TEXT) ORDER BY IndexRecords.key, IndexRecords.value&quot;_s);
2252 
2253     if (!sql
</pre>
<hr />
<pre>
2264         return IDBError { UnknownError, &quot;Unable to lookup index record in database&quot;_s };
2265     }
2266 
2267     if (result == SQLITE_DONE)
2268         return IDBError { };
2269 
2270     IDBKeyData objectStoreKey;
2271     Vector&lt;uint8_t&gt; keyVector;
2272     sql-&gt;getColumnBlobAsVector(0, keyVector);
2273 
2274     if (!deserializeIDBKeyData(keyVector.data(), keyVector.size(), objectStoreKey)) {
2275         LOG_ERROR(&quot;Unable to deserialize key looking up index record in database&quot;);
2276         return IDBError { UnknownError, &quot;Unable to deserialize key looking up index record in database&quot;_s };
2277     }
2278 
2279     if (type == IndexedDB::IndexRecordType::Key) {
2280         getResult = { objectStoreKey };
2281         return IDBError { };
2282     }
2283 
<span class="line-modified">2284     Vector&lt;uint8_t&gt; valueVector;</span>
<span class="line-added">2285     sql-&gt;getColumnBlobAsVector(1, valueVector);</span>
2286 
2287     int64_t recordID = sql-&gt;getColumnInt64(2);
2288     Vector&lt;String&gt; blobURLs, blobFilePaths;
<span class="line-modified">2289     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);</span>

2290     ASSERT(blobURLs.size() == blobFilePaths.size());
2291 
2292     if (!error.isNull())
2293         return error;
2294 
<span class="line-modified">2295     auto* objectStoreInfo = infoForObjectStore(objectStoreID);</span>
<span class="line-added">2296     ASSERT(objectStoreInfo);</span>
<span class="line-added">2297     getResult = { objectStoreKey, objectStoreKey, { ThreadSafeDataBuffer::create(WTFMove(valueVector)), WTFMove(blobURLs), WTFMove(blobFilePaths) }, objectStoreInfo-&gt;keyPath() };</span>
2298     return IDBError { };
2299 }
2300 
2301 IDBError SQLiteIDBBackingStore::getCount(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; range, uint64_t&amp; outCount)
2302 {
2303     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getCount - object store %&quot; PRIu64, objectStoreIdentifier);
2304     ASSERT(m_sqliteDB);
2305     ASSERT(m_sqliteDB-&gt;isOpen());
2306 
2307     outCount = 0;
2308 
2309     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2310     if (!transaction || !transaction-&gt;inProgress())</span>

2311         return IDBError { UnknownError, &quot;Attempt to get count from database without an in-progress transaction&quot;_s };

2312 
2313     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreIdentifier, indexIdentifier, range);
2314     if (!cursor) {
2315         LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);
2316         return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
2317     }
2318 
2319     while (cursor-&gt;advance(1))
2320         ++outCount;
2321 
2322     return IDBError { };
2323 }
2324 
2325 IDBError SQLiteIDBBackingStore::uncheckedGetKeyGeneratorValue(int64_t objectStoreID, uint64_t&amp; outValue)
2326 {
2327     auto* sql = cachedStatement(SQL::GetKeyGeneratorValue, &quot;SELECT currentKey FROM KeyGenerators WHERE objectStoreID = ?;&quot;_s);
2328     if (!sql
2329         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK) {
2330         LOG_ERROR(&quot;Could not retrieve currentKey from KeyGenerators table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2331         return IDBError { UnknownError, &quot;Error getting current key generator value from database&quot;_s };
</pre>
<hr />
<pre>
2335         LOG_ERROR(&quot;Could not retreive key generator value for object store, but it should be there.&quot;);
2336         return IDBError { UnknownError, &quot;Error finding current key generator value in database&quot;_s };
2337     }
2338 
2339     int64_t value = sql-&gt;getColumnInt64(0);
2340     if (value &lt; 0)
2341         return IDBError { ConstraintError, &quot;Current key generator value from database is invalid&quot; };
2342 
2343     outValue = value;
2344     return IDBError { };
2345 }
2346 
2347 IDBError SQLiteIDBBackingStore::uncheckedSetKeyGeneratorValue(int64_t objectStoreID, uint64_t value)
2348 {
2349     auto* sql = cachedStatement(SQL::SetKeyGeneratorValue, &quot;INSERT INTO KeyGenerators VALUES (?, ?);&quot;_s);
2350     if (!sql
2351         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
2352         || sql-&gt;bindInt64(2, value) != SQLITE_OK
2353         || sql-&gt;step() != SQLITE_DONE) {
2354         LOG_ERROR(&quot;Could not update key generator value (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());


2355         return IDBError { ConstraintError, &quot;Error storing new key generator value in database&quot; };
2356     }
2357 
2358     return IDBError { };
2359 }
2360 
2361 IDBError SQLiteIDBBackingStore::generateKeyNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t&amp; generatedKey)
2362 {
2363     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::generateKeyNumber&quot;);
2364 
2365     ASSERT(m_sqliteDB);
2366     ASSERT(m_sqliteDB-&gt;isOpen());
2367 
2368     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2369     if (!transaction || !transaction-&gt;inProgress())</span>

2370         return IDBError { UnknownError, &quot;Attempt to generate key in database without an in-progress transaction&quot;_s };
<span class="line-modified">2371 </span>
2372     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2373         LOG_ERROR(&quot;Attempt to generate key in a read-only transaction&quot;);
2374         return IDBError { UnknownError, &quot;Attempt to generate key in a read-only transaction&quot;_s };
2375     }
2376 
2377     uint64_t currentValue;
2378     auto error = uncheckedGetKeyGeneratorValue(objectStoreID, currentValue);
2379     if (!error.isNull())
2380         return error;
2381 
2382     if (currentValue + 1 &gt; maxGeneratorValue)
2383         return IDBError { ConstraintError, &quot;Cannot generate new key value over 2^53 for object store operation&quot; };
2384 
2385     generatedKey = currentValue + 1;
2386     return uncheckedSetKeyGeneratorValue(objectStoreID, generatedKey);
2387 }
2388 
2389 IDBError SQLiteIDBBackingStore::revertGeneratedKeyNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t newKeyNumber)
2390 {
2391     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::revertGeneratedKeyNumber - object store %&quot; PRIu64 &quot;, reverted number %&quot; PRIu64, objectStoreID, newKeyNumber);
2392 
2393     ASSERT(m_sqliteDB);
2394     ASSERT(m_sqliteDB-&gt;isOpen());
2395 
2396     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2397     if (!transaction || !transaction-&gt;inProgress())</span>

2398         return IDBError { UnknownError, &quot;Attempt to revert key generator value in database without an in-progress transaction&quot;_s };
<span class="line-modified">2399 </span>
2400     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2401         LOG_ERROR(&quot;Attempt to revert key generator value in a read-only transaction&quot;);
2402         return IDBError { UnknownError, &quot;Attempt to revert key generator value in a read-only transaction&quot;_s };
2403     }
2404 
2405     ASSERT(newKeyNumber);
2406     return uncheckedSetKeyGeneratorValue(objectStoreID, newKeyNumber - 1);
2407 }
2408 
2409 IDBError SQLiteIDBBackingStore::maybeUpdateKeyGeneratorNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, double newKeyNumber)
2410 {
2411     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::maybeUpdateKeyGeneratorNumber&quot;);
2412 
2413     ASSERT(m_sqliteDB);
2414     ASSERT(m_sqliteDB-&gt;isOpen());
2415 
2416     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2417     if (!transaction || !transaction-&gt;inProgress())</span>

2418         return IDBError { UnknownError, &quot;Attempt to update key generator value in database without an in-progress transaction&quot;_s };
<span class="line-modified">2419 </span>
2420     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2421         LOG_ERROR(&quot;Attempt to update key generator value in a read-only transaction&quot;);
2422         return IDBError { UnknownError, &quot;Attempt to update key generator value in a read-only transaction&quot;_s };
2423     }
2424 
2425     uint64_t currentValue;
2426     auto error = uncheckedGetKeyGeneratorValue(objectStoreID, currentValue);
2427     if (!error.isNull())
2428         return error;
2429 
2430     if (newKeyNumber &lt;= currentValue)
2431         return IDBError { };
2432 
2433     return uncheckedSetKeyGeneratorValue(objectStoreID, std::min(newKeyNumber, (double)maxGeneratorValue));
2434 }
2435 
2436 IDBError SQLiteIDBBackingStore::openCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info, IDBGetResult&amp; result)
2437 {
2438     ASSERT(m_sqliteDB);
2439     ASSERT(m_sqliteDB-&gt;isOpen());
2440 
2441     auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">2442     if (!transaction || !transaction-&gt;inProgress())</span>

2443         return IDBError { UnknownError, &quot;Attempt to open a cursor in database without an in-progress transaction&quot;_s };

2444 
2445     auto* cursor = transaction-&gt;maybeOpenCursor(info);
2446     if (!cursor) {
2447         LOG_ERROR(&quot;Unable to open cursor&quot;);
2448         return IDBError { UnknownError, &quot;Unable to open cursor&quot;_s };
2449     }
2450 
2451     m_cursors.set(cursor-&gt;identifier(), cursor);
2452 
<span class="line-modified">2453     auto* objectStoreInfo = infoForObjectStore(info.objectStoreIdentifier());</span>
<span class="line-added">2454     ASSERT(objectStoreInfo);</span>
<span class="line-added">2455     cursor-&gt;currentData(result, objectStoreInfo-&gt;keyPath());</span>
2456     return IDBError { };
2457 }
2458 
2459 IDBError SQLiteIDBBackingStore::iterateCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data, IDBGetResult&amp; result)
2460 {
2461     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::iterateCursor&quot;);
2462 
2463     ASSERT(m_sqliteDB);
2464     ASSERT(m_sqliteDB-&gt;isOpen());
2465 
2466     auto* cursor = m_cursors.get(cursorIdentifier);
2467     if (!cursor) {
2468         LOG_ERROR(&quot;Attempt to iterate a cursor that doesn&#39;t exist&quot;);
2469         return IDBError { UnknownError, &quot;Attempt to iterate a cursor that doesn&#39;t exist&quot;_s };
2470     }
2471 
2472     ASSERT_UNUSED(transactionIdentifier, cursor-&gt;transaction()-&gt;transactionIdentifier() == transactionIdentifier);
2473 
<span class="line-modified">2474     if (!cursor-&gt;transaction() || !cursor-&gt;transaction()-&gt;inProgress())</span>

2475         return IDBError { UnknownError, &quot;Attempt to iterate a cursor without an in-progress transaction&quot;_s };

2476 
2477     auto key = data.keyData;
2478     auto primaryKey = data.primaryKeyData;
2479     auto count = data.count;
2480 
2481     if (key.isValid()) {
2482         if (!cursor-&gt;iterate(key, primaryKey)) {
2483             LOG_ERROR(&quot;Attempt to iterate cursor failed&quot;);
2484             return IDBError { UnknownError, &quot;Attempt to iterate cursor failed&quot;_s };
2485         }
2486     } else {
2487         ASSERT(!primaryKey.isValid());
2488         if (!count)
2489             count = 1;
2490         if (!cursor-&gt;advance(count)) {
2491             LOG_ERROR(&quot;Attempt to advance cursor failed&quot;);
2492             return IDBError { UnknownError, &quot;Attempt to advance cursor failed&quot;_s };
2493         }
2494     }
2495 
<span class="line-modified">2496     auto* objectStoreInfo = infoForObjectStore(cursor-&gt;objectStoreID());</span>
<span class="line-added">2497     ASSERT(objectStoreInfo);</span>
<span class="line-added">2498     cursor-&gt;currentData(result, objectStoreInfo-&gt;keyPath());</span>
2499     return IDBError { };
2500 }
2501 
2502 bool SQLiteIDBBackingStore::prefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)
2503 {
2504     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::prefetchCursor&quot;);
2505 
2506     ASSERT(m_sqliteDB);
2507     ASSERT(m_sqliteDB-&gt;isOpen());
2508 
2509     auto* cursor = m_cursors.get(cursorIdentifier);
2510     if (!cursor || !cursor-&gt;transaction() || !cursor-&gt;transaction()-&gt;inProgress())
2511         return false;
2512 
2513     ASSERT_UNUSED(transactionIdentifier, cursor-&gt;transaction()-&gt;transactionIdentifier() == transactionIdentifier);
2514 
2515     return cursor-&gt;prefetch();
2516 }
2517 
2518 IDBObjectStoreInfo* SQLiteIDBBackingStore::infoForObjectStore(uint64_t objectStoreIdentifier)
</pre>
<hr />
<pre>
2532         bool errored = true;
2533 
2534         if (m_sqliteDB) {
2535             SQLiteStatement sql(*m_sqliteDB, &quot;SELECT fileName FROM BlobFiles;&quot;_s);
2536             if (sql.prepare() == SQLITE_OK) {
2537                 int result = sql.step();
2538                 while (result == SQLITE_ROW) {
2539                     blobFiles.append(sql.getColumnText(0));
2540                     result = sql.step();
2541                 }
2542 
2543                 if (result == SQLITE_DONE)
2544                     errored = false;
2545             }
2546         }
2547 
2548         if (errored)
2549             LOG_ERROR(&quot;Error getting all blob filenames to be deleted&quot;);
2550     }
2551 

2552     for (auto&amp; file : blobFiles) {
<span class="line-modified">2553         String fullPath = FileSystem::pathByAppendingComponent(m_databaseDirectory, file);</span>
2554         if (!FileSystem::deleteFile(fullPath))
2555             LOG_ERROR(&quot;Error deleting blob file %s&quot;, fullPath.utf8().data());
2556     }
2557 
2558     if (m_sqliteDB)
2559         closeSQLiteDB();
2560 
2561     SQLiteFileSystem::deleteDatabaseFile(dbFilename);
<span class="line-modified">2562     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_databaseDirectory);</span>
<span class="line-modified">2563     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectoryIsolatedCopy()));</span>
2564 }
2565 
2566 void SQLiteIDBBackingStore::unregisterCursor(SQLiteIDBCursor&amp; cursor)
2567 {
2568     ASSERT(m_cursors.contains(cursor.identifier()));
2569     m_cursors.remove(cursor.identifier());
2570 }
2571 
2572 SQLiteStatement* SQLiteIDBBackingStore::cachedStatement(SQLiteIDBBackingStore::SQL sql, const char* statement)
2573 {
2574     if (sql &gt;= SQL::Count) {
2575         LOG_ERROR(&quot;Invalid SQL statement ID passed to cachedStatement()&quot;);
2576         return nullptr;
2577     }
2578 
2579     if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]) {
2580         if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;reset() == SQLITE_OK)
2581             return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
2582         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
2583     }
2584 
2585     if (m_sqliteDB) {
<span class="line-modified">2586         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = makeUnique&lt;SQLiteStatement&gt;(*m_sqliteDB, statement);</span>
2587         if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;prepare() != SQLITE_OK)
2588             m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
2589     }
2590 
2591     return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
2592 }
2593 
<span class="line-added">2594 void SQLiteIDBBackingStore::close()</span>
<span class="line-added">2595 {</span>
<span class="line-added">2596     closeSQLiteDB();</span>
<span class="line-added">2597 }</span>
<span class="line-added">2598 </span>
2599 void SQLiteIDBBackingStore::closeSQLiteDB()
2600 {
2601     for (size_t i = 0; i &lt; static_cast&lt;int&gt;(SQL::Count); ++i)
2602         m_cachedStatements[i] = nullptr;
2603 
2604     if (m_sqliteDB)
2605         m_sqliteDB-&gt;close();
2606 
2607     m_sqliteDB = nullptr;
2608 }
2609 
<span class="line-added">2610 bool SQLiteIDBBackingStore::hasTransaction(const IDBResourceIdentifier&amp; transactionIdentifier) const</span>
<span class="line-added">2611 {</span>
<span class="line-added">2612     ASSERT(isMainThread());</span>
<span class="line-added">2613     return m_transactions.contains(transactionIdentifier);</span>
<span class="line-added">2614 }</span>
<span class="line-added">2615 </span>
2616 } // namespace IDBServer
2617 } // namespace WebCore
2618 
2619 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
</tr>
</table>
<center><a href="MemoryObjectStoreCursor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteIDBBackingStore.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>