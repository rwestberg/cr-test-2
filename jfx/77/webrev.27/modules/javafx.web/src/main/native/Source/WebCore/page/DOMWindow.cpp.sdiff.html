<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DOMTimer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DOMWindow.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;DOMWindow.h&quot;
  29 
  30 #include &quot;BackForwardController.h&quot;
  31 #include &quot;BarProp.h&quot;
  32 #include &quot;CSSComputedStyleDeclaration.h&quot;
  33 #include &quot;CSSRule.h&quot;
  34 #include &quot;CSSRuleList.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;ChromeClient.h&quot;
  37 #include &quot;ComposedTreeIterator.h&quot;
  38 #include &quot;ContentExtensionActions.h&quot;
  39 #include &quot;ContentExtensionRule.h&quot;

  40 #include &quot;Crypto.h&quot;
  41 #include &quot;CustomElementRegistry.h&quot;
  42 #include &quot;DOMApplicationCache.h&quot;
  43 #include &quot;DOMSelection.h&quot;
  44 #include &quot;DOMStringList.h&quot;
  45 #include &quot;DOMTimer.h&quot;
  46 #include &quot;DOMTokenList.h&quot;
  47 #include &quot;DOMURL.h&quot;
<span class="line-removed">  48 #include &quot;DOMWindowExtension.h&quot;</span>
  49 #include &quot;DeviceMotionController.h&quot;



  50 #include &quot;DeviceOrientationController.h&quot;
  51 #include &quot;Document.h&quot;
  52 #include &quot;DocumentLoader.h&quot;
  53 #include &quot;Editor.h&quot;
  54 #include &quot;Element.h&quot;
  55 #include &quot;EventHandler.h&quot;
  56 #include &quot;EventListener.h&quot;
  57 #include &quot;EventNames.h&quot;
  58 #include &quot;FloatRect.h&quot;
  59 #include &quot;FocusController.h&quot;
  60 #include &quot;Frame.h&quot;
  61 #include &quot;FrameLoadRequest.h&quot;
  62 #include &quot;FrameLoader.h&quot;
  63 #include &quot;FrameLoaderClient.h&quot;
  64 #include &quot;FrameTree.h&quot;
  65 #include &quot;FrameView.h&quot;
  66 #include &quot;HTTPParsers.h&quot;
  67 #include &quot;History.h&quot;
  68 #include &quot;InspectorInstrumentation.h&quot;
  69 #include &quot;JSDOMWindowBase.h&quot;
</pre>
<hr />
<pre>
  95 #include &quot;StaticNodeList.h&quot;
  96 #include &quot;Storage.h&quot;
  97 #include &quot;StorageArea.h&quot;
  98 #include &quot;StorageNamespace.h&quot;
  99 #include &quot;StorageNamespaceProvider.h&quot;
 100 #include &quot;StyleMedia.h&quot;
 101 #include &quot;StyleResolver.h&quot;
 102 #include &quot;StyleScope.h&quot;
 103 #include &quot;SuddenTermination.h&quot;
 104 #include &lt;wtf/URL.h&gt;
 105 #include &quot;UserGestureIndicator.h&quot;
 106 #include &quot;VisualViewport.h&quot;
 107 #include &quot;WebKitPoint.h&quot;
 108 #include &quot;WindowFeatures.h&quot;
 109 #include &quot;WindowFocusAllowedIndicator.h&quot;
 110 #include &quot;WindowProxy.h&quot;
 111 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 112 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
 113 #include &lt;algorithm&gt;
 114 #include &lt;memory&gt;

 115 #include &lt;wtf/Language.h&gt;
 116 #include &lt;wtf/MainThread.h&gt;
 117 #include &lt;wtf/MathExtras.h&gt;
 118 #include &lt;wtf/NeverDestroyed.h&gt;
 119 #include &lt;wtf/Ref.h&gt;

 120 #include &lt;wtf/Variant.h&gt;
 121 #include &lt;wtf/text/WTFString.h&gt;
 122 
 123 #if ENABLE(USER_MESSAGE_HANDLERS)
 124 #include &quot;UserContentController.h&quot;
 125 #include &quot;UserMessageHandlerDescriptor.h&quot;
 126 #include &quot;WebKitNamespace.h&quot;
 127 #endif
 128 
 129 #if ENABLE(GAMEPAD)
 130 #include &quot;GamepadManager.h&quot;
 131 #endif
 132 
 133 #if ENABLE(GEOLOCATION)
 134 #include &quot;NavigatorGeolocation.h&quot;
 135 #endif
 136 
 137 #if ENABLE(POINTER_LOCK)
 138 #include &quot;PointerLockController.h&quot;
 139 #endif
 140 
<span class="line-removed"> 141 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 142 #include &quot;WKContentObservation.h&quot;</span>
<span class="line-removed"> 143 #include &quot;WKContentObservationInternal.h&quot;</span>
<span class="line-removed"> 144 #endif</span>
<span class="line-removed"> 145 </span>
<span class="line-removed"> 146 </span>
 147 namespace WebCore {
 148 using namespace Inspector;
 149 


 150 class PostMessageTimer : public TimerBase {
 151 public:
 152     PostMessageTimer(DOMWindow&amp; window, MessageWithMessagePorts&amp;&amp; message, const String&amp; sourceOrigin, RefPtr&lt;WindowProxy&gt;&amp;&amp; source, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; targetOrigin, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; stackTrace)
 153         : m_window(window)
 154         , m_message(WTFMove(message))
 155         , m_origin(sourceOrigin)
 156         , m_source(source)
 157         , m_targetOrigin(WTFMove(targetOrigin))
 158         , m_stackTrace(stackTrace)
 159         , m_userGestureToForward(UserGestureIndicator::currentUserGesture())
 160     {
 161     }
 162 
 163     Ref&lt;MessageEvent&gt; event(ScriptExecutionContext&amp; context)
 164     {
 165         return MessageEvent::create(MessagePort::entanglePorts(context, WTFMove(m_message.transferredPorts)), m_message.message.releaseNonNull(), m_origin, { }, m_source ? makeOptional(MessageEventSource(WTFMove(m_source))) : WTF::nullopt);
 166     }
 167 
 168     SecurityOrigin* targetOrigin() const { return m_targetOrigin.get(); }
 169     ScriptCallStack* stackTrace() const { return m_stackTrace.get(); }
</pre>
<hr />
<pre>
 397 {
 398     static_cast&lt;DOMWindow*&gt;(context)-&gt;languagesChanged();
 399 }
 400 
 401 void DOMWindow::setCanShowModalDialogOverride(bool allow)
 402 {
 403     m_canShowModalDialogOverride = allow;
 404 }
 405 
 406 DOMWindow::DOMWindow(Document&amp; document)
 407     : AbstractDOMWindow(GlobalWindowIdentifier { Process::identifier(), WindowIdentifier::generate() })
 408     , ContextDestructionObserver(&amp;document)
 409 {
 410     ASSERT(frame());
 411     addLanguageChangeObserver(this, &amp;languagesChangedCallback);
 412 }
 413 
 414 void DOMWindow::didSecureTransitionTo(Document&amp; document)
 415 {
 416     observeContext(&amp;document);




























 417 }
 418 
 419 DOMWindow::~DOMWindow()
 420 {
 421     if (m_suspendedForDocumentSuspension)
 422         willDestroyCachedFrame();
 423     else
 424         willDestroyDocumentInFrame();
 425 
 426     removeAllUnloadEventListeners(this);
 427     removeAllBeforeUnloadEventListeners(this);
 428 
 429 #if ENABLE(GAMEPAD)
 430     if (m_gamepadEventListenerCount)
 431         GamepadManager::singleton().unregisterDOMWindow(this);
 432 #endif
 433 
 434     removeLanguageChangeObserver(this);
 435 }
 436 
 437 RefPtr&lt;MediaQueryList&gt; DOMWindow::matchMedia(const String&amp; media)
 438 {
 439     return document() ? document()-&gt;mediaQueryMatcher().matchMedia(media) : nullptr;
 440 }
 441 
 442 Page* DOMWindow::page()
 443 {
 444     return frame() ? frame()-&gt;page() : nullptr;
 445 }
 446 
 447 void DOMWindow::frameDestroyed()
 448 {
 449     Ref&lt;DOMWindow&gt; protectedThis(*this);
 450 
 451     willDestroyDocumentInFrame();
 452     JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(this);
 453 }
 454 
 455 void DOMWindow::willDestroyCachedFrame()
 456 {
<span class="line-modified"> 457     // It is necessary to copy m_properties to a separate vector because the DOMWindowProperties may</span>
 458     // unregister themselves from the DOMWindow as a result of the call to willDestroyGlobalObjectInCachedFrame.
<span class="line-modified"> 459     for (auto* property : copyToVector(m_properties)) {</span>
<span class="line-modified"> 460         if (m_properties.contains(property))</span>
<span class="line-modified"> 461         property-&gt;willDestroyGlobalObjectInCachedFrame();</span>
 462     }
 463 }
 464 
 465 void DOMWindow::willDestroyDocumentInFrame()
 466 {
<span class="line-modified"> 467     // It is necessary to copy m_properties to a separate vector because the DOMWindowProperties may</span>
 468     // unregister themselves from the DOMWindow as a result of the call to willDestroyGlobalObjectInFrame.
<span class="line-modified"> 469     for (auto* property : copyToVector(m_properties)) {</span>
<span class="line-modified"> 470         if (m_properties.contains(property))</span>
<span class="line-modified"> 471         property-&gt;willDestroyGlobalObjectInFrame();</span>
 472     }
 473 }
 474 
 475 void DOMWindow::willDetachDocumentFromFrame()
 476 {
 477     if (!frame())
 478         return;
 479 
<span class="line-modified"> 480     // It is necessary to copy m_properties to a separate vector because the DOMWindowProperties may</span>


 481     // unregister themselves from the DOMWindow as a result of the call to willDetachGlobalObjectFromFrame.
<span class="line-modified"> 482     for (auto&amp; property : copyToVector(m_properties)) {</span>
<span class="line-modified"> 483         if (m_properties.contains(property))</span>
<span class="line-modified"> 484         property-&gt;willDetachGlobalObjectFromFrame();</span>
 485     }
 486 
 487     if (m_performance)
 488         m_performance-&gt;clearResourceTimings();
 489 
 490     JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(this);
 491     InspectorInstrumentation::frameWindowDiscarded(*frame(), this);
 492 }
 493 
 494 #if ENABLE(GAMEPAD)
 495 
 496 void DOMWindow::incrementGamepadEventListenerCount()
 497 {
 498     if (++m_gamepadEventListenerCount == 1)
 499         GamepadManager::singleton().registerDOMWindow(this);
 500 }
 501 
 502 void DOMWindow::decrementGamepadEventListenerCount()
 503 {
 504     ASSERT(m_gamepadEventListenerCount);
 505 
 506     if (!--m_gamepadEventListenerCount)
 507         GamepadManager::singleton().unregisterDOMWindow(this);
 508 }
 509 
 510 #endif
 511 
<span class="line-modified"> 512 void DOMWindow::registerProperty(DOMWindowProperty&amp; property)</span>
 513 {
<span class="line-modified"> 514     m_properties.add(&amp;property);</span>
 515 }
 516 
<span class="line-modified"> 517 void DOMWindow::unregisterProperty(DOMWindowProperty&amp; property)</span>
 518 {
<span class="line-modified"> 519     m_properties.remove(&amp;property);</span>
 520 }
 521 
 522 void DOMWindow::resetUnlessSuspendedForDocumentSuspension()
 523 {
 524     if (m_suspendedForDocumentSuspension)
 525         return;
 526     willDestroyDocumentInFrame();
<span class="line-removed"> 527     resetDOMWindowProperties();</span>
 528 }
 529 
 530 void DOMWindow::suspendForPageCache()
 531 {
<span class="line-modified"> 532     for (auto* property : copyToVector(m_properties)) {</span>
<span class="line-modified"> 533         if (m_properties.contains(property))</span>
<span class="line-modified"> 534         property-&gt;suspendForPageCache();</span>



 535     }

 536 
 537     m_suspendedForDocumentSuspension = true;
 538 }
 539 
 540 void DOMWindow::resumeFromPageCache()
 541 {
<span class="line-modified"> 542     for (auto* property : copyToVector(m_properties)) {</span>
<span class="line-modified"> 543         if (m_properties.contains(property))</span>
<span class="line-modified"> 544         property-&gt;resumeFromPageCache();</span>
 545     }
 546 
 547     m_suspendedForDocumentSuspension = false;
 548 }
 549 
<span class="line-removed"> 550 void DOMWindow::resetDOMWindowProperties()</span>
<span class="line-removed"> 551 {</span>
<span class="line-removed"> 552     m_properties.clear();</span>
<span class="line-removed"> 553 </span>
<span class="line-removed"> 554     m_applicationCache = nullptr;</span>
<span class="line-removed"> 555     m_crypto = nullptr;</span>
<span class="line-removed"> 556     m_history = nullptr;</span>
<span class="line-removed"> 557     m_localStorage = nullptr;</span>
<span class="line-removed"> 558     m_location = nullptr;</span>
<span class="line-removed"> 559     m_locationbar = nullptr;</span>
<span class="line-removed"> 560     m_media = nullptr;</span>
<span class="line-removed"> 561     m_menubar = nullptr;</span>
<span class="line-removed"> 562     m_navigator = nullptr;</span>
<span class="line-removed"> 563     m_personalbar = nullptr;</span>
<span class="line-removed"> 564     m_screen = nullptr;</span>
<span class="line-removed"> 565     m_scrollbars = nullptr;</span>
<span class="line-removed"> 566     m_selection = nullptr;</span>
<span class="line-removed"> 567     m_sessionStorage = nullptr;</span>
<span class="line-removed"> 568     m_statusbar = nullptr;</span>
<span class="line-removed"> 569     m_toolbar = nullptr;</span>
<span class="line-removed"> 570     m_performance = nullptr;</span>
<span class="line-removed"> 571     m_visualViewport = nullptr;</span>
<span class="line-removed"> 572 }</span>
<span class="line-removed"> 573 </span>
 574 bool DOMWindow::isCurrentlyDisplayedInFrame() const
 575 {
 576     auto* frame = this-&gt;frame();
 577     return frame &amp;&amp; frame-&gt;document()-&gt;domWindow() == this;
 578 }
 579 
 580 CustomElementRegistry&amp; DOMWindow::ensureCustomElementRegistry()
 581 {
 582     if (!m_customElementRegistry)
 583         m_customElementRegistry = CustomElementRegistry::create(*this, scriptExecutionContext());
 584     return *m_customElementRegistry;
 585 }
 586 
 587 static ExceptionOr&lt;SelectorQuery&amp;&gt; selectorQueryInFrame(Frame* frame, const String&amp; selectors)
 588 {
 589     if (!frame)
 590         return Exception { NotSupportedError };
 591 
 592     Document* document = frame-&gt;document();
 593     if (!document)
</pre>
<hr />
<pre>
 649 #endif
 650 
 651 Screen&amp; DOMWindow::screen()
 652 {
 653     if (!m_screen)
 654         m_screen = Screen::create(*this);
 655     return *m_screen;
 656 }
 657 
 658 History&amp; DOMWindow::history()
 659 {
 660     if (!m_history)
 661         m_history = History::create(*this);
 662     return *m_history;
 663 }
 664 
 665 Crypto&amp; DOMWindow::crypto() const
 666 {
 667     if (!m_crypto)
 668         m_crypto = Crypto::create(document());

 669     return *m_crypto;
 670 }
 671 
 672 BarProp&amp; DOMWindow::locationbar()
 673 {
 674     if (!m_locationbar)
 675         m_locationbar = BarProp::create(*this, BarProp::Locationbar);
 676     return *m_locationbar;
 677 }
 678 
 679 BarProp&amp; DOMWindow::menubar()
 680 {
 681     if (!m_menubar)
 682         m_menubar = BarProp::create(*this, BarProp::Menubar);
 683     return *m_menubar;
 684 }
 685 
 686 BarProp&amp; DOMWindow::personalbar()
 687 {
 688     if (!m_personalbar)
</pre>
<hr />
<pre>
 714 PageConsoleClient* DOMWindow::console() const
 715 {
 716     // FIXME: This should not return nullptr when frameless.
 717     if (!isCurrentlyDisplayedInFrame())
 718         return nullptr;
 719     auto* frame = this-&gt;frame();
 720     return frame-&gt;page() ? &amp;frame-&gt;page()-&gt;console() : nullptr;
 721 }
 722 
 723 DOMApplicationCache&amp; DOMWindow::applicationCache()
 724 {
 725     if (!m_applicationCache)
 726         m_applicationCache = DOMApplicationCache::create(*this);
 727     return *m_applicationCache;
 728 }
 729 
 730 Navigator&amp; DOMWindow::navigator()
 731 {
 732     if (!m_navigator)
 733         m_navigator = Navigator::create(scriptExecutionContext(), *this);

 734 
 735     return *m_navigator;
 736 }
 737 
 738 Performance&amp; DOMWindow::performance() const
 739 {
 740     if (!m_performance) {
 741         MonotonicTime timeOrigin = document() &amp;&amp; document()-&gt;loader() ? document()-&gt;loader()-&gt;timing().referenceMonotonicTime() : MonotonicTime::now();
 742         m_performance = Performance::create(document(), timeOrigin);
 743     }

 744     return *m_performance;
 745 }
 746 
 747 double DOMWindow::nowTimestamp() const
 748 {
 749     return performance().now() / 1000.;
 750 }
 751 
 752 Location&amp; DOMWindow::location()
 753 {
 754     if (!m_location)
 755         m_location = Location::create(*this);
 756     return *m_location;
 757 }
 758 
 759 VisualViewport&amp; DOMWindow::visualViewport()
 760 {
 761     if (!m_visualViewport)
 762         m_visualViewport = VisualViewport::create(*this);
 763     return *m_visualViewport;
</pre>
<hr />
<pre>
 944 DOMSelection* DOMWindow::getSelection()
 945 {
 946     if (!isCurrentlyDisplayedInFrame())
 947         return nullptr;
 948     if (!m_selection)
 949         m_selection = DOMSelection::create(*this);
 950     return m_selection.get();
 951 }
 952 
 953 Element* DOMWindow::frameElement() const
 954 {
 955     auto* frame = this-&gt;frame();
 956     if (!frame)
 957         return nullptr;
 958 
 959     return frame-&gt;ownerElement();
 960 }
 961 
 962 void DOMWindow::focus(DOMWindow&amp; incumbentWindow)
 963 {
<span class="line-modified"> 964     auto* opener = this-&gt;opener();</span>
<span class="line-modified"> 965     focus(opener &amp;&amp; opener != self() &amp;&amp; incumbentWindow.self() == opener);</span>

 966 }
 967 
 968 void DOMWindow::focus(bool allowFocus)
 969 {
 970     if (!frame())
 971         return;
 972 
 973     Page* page = frame()-&gt;page();
 974     if (!page)
 975         return;
 976 
 977     allowFocus = allowFocus || WindowFocusAllowedIndicator::windowFocusAllowed() || !frame()-&gt;settings().windowFocusRestricted();
 978 
 979     // If we&#39;re a top level window, bring the window to the front.
 980     if (frame()-&gt;isMainFrame() &amp;&amp; allowFocus)
 981         page-&gt;chrome().focus();
 982 
 983     if (!frame())
 984         return;
 985 



 986     // Clear the current frame&#39;s focused node if a new frame is about to be focused.
 987     Frame* focusedFrame = page-&gt;focusController().focusedFrame();
 988     if (focusedFrame &amp;&amp; focusedFrame != frame())
 989         focusedFrame-&gt;document()-&gt;setFocusedElement(nullptr);
 990 
 991     // setFocusedElement may clear frame(), so recheck before using it.
 992     if (auto* frame = this-&gt;frame())
 993         frame-&gt;eventHandler().focusDocumentView();
 994 }
 995 
 996 void DOMWindow::blur()
 997 {
 998     auto* frame = this-&gt;frame();
 999     if (!frame)
1000         return;
1001 
1002     Page* page = frame-&gt;page();
1003     if (!page)
1004         return;
1005 
</pre>
<hr />
<pre>
1224     return view-&gt;frameRect().width();
1225 #else
1226     auto* frame = this-&gt;frame();
1227     if (!frame)
1228         return 0;
1229 
1230     Page* page = frame-&gt;page();
1231     if (!page)
1232         return 0;
1233 
1234     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().width());
1235 #endif
1236 }
1237 
1238 int DOMWindow::innerHeight() const
1239 {
1240     if (!frame())
1241         return 0;
1242 
1243     // Force enough layout in the parent document to ensure that the FrameView has been resized.
<span class="line-modified">1244     if (auto* frameElement = this-&gt;frameElement())</span>
<span class="line-modified">1245         frameElement-&gt;document().updateLayoutIfDimensionsOutOfDate(*frameElement, HeightDimensionsCheck);</span>
1246 
<span class="line-modified">1247     auto* frame = this-&gt;frame();</span>
1248     if (!frame)
1249         return 0;
1250 
<span class="line-modified">1251     FrameView* view = frame-&gt;view();</span>
1252     if (!view)
1253         return 0;
1254 
1255     return view-&gt;mapFromLayoutToCSSUnits(static_cast&lt;int&gt;(view-&gt;unobscuredContentRectIncludingScrollbars().height()));
1256 }
1257 
1258 int DOMWindow::innerWidth() const
1259 {
1260     if (!frame())
1261         return 0;
1262 
1263     // Force enough layout in the parent document to ensure that the FrameView has been resized.
<span class="line-modified">1264     if (auto* frameElement = this-&gt;frameElement())</span>
<span class="line-modified">1265         frameElement-&gt;document().updateLayoutIfDimensionsOutOfDate(*frameElement, WidthDimensionsCheck);</span>
1266 
<span class="line-modified">1267     auto* frame = this-&gt;frame();</span>
1268     if (!frame)
1269         return 0;
1270 
<span class="line-modified">1271     FrameView* view = frame-&gt;view();</span>
1272     if (!view)
1273         return 0;
1274 
1275     return view-&gt;mapFromLayoutToCSSUnits(static_cast&lt;int&gt;(view-&gt;unobscuredContentRectIncludingScrollbars().width()));
1276 }
1277 
1278 int DOMWindow::screenX() const
1279 {
<span class="line-modified">1280     auto* frame = this-&gt;frame();</span>
1281     if (!frame)
1282         return 0;
1283 
1284     Page* page = frame-&gt;page();
1285     if (!page)
1286         return 0;
1287 
1288     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().x());
1289 }
1290 
1291 int DOMWindow::screenY() const
1292 {
<span class="line-modified">1293     auto* frame = this-&gt;frame();</span>
1294     if (!frame)
1295         return 0;
1296 
1297     Page* page = frame-&gt;page();
1298     if (!page)
1299         return 0;
1300 
1301     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().y());
1302 }
1303 
1304 int DOMWindow::scrollX() const
1305 {
<span class="line-modified">1306     auto* frame = this-&gt;frame();</span>
1307     if (!frame)
1308         return 0;
1309 
<span class="line-modified">1310     FrameView* view = frame-&gt;view();</span>
1311     if (!view)
1312         return 0;
1313 
1314     int scrollX = view-&gt;contentsScrollPosition().x();
1315     if (!scrollX)
1316         return 0;
1317 
1318     frame-&gt;document()-&gt;updateLayoutIgnorePendingStylesheets();
1319 
1320     // Layout may have affected the current frame:
<span class="line-modified">1321     auto* frameAfterLayout = this-&gt;frame();</span>
1322     if (!frameAfterLayout)
1323         return 0;
1324 
<span class="line-modified">1325     FrameView* viewAfterLayout = frameAfterLayout-&gt;view();</span>
1326     if (!viewAfterLayout)
1327         return 0;
1328 
1329     return viewAfterLayout-&gt;mapFromLayoutToCSSUnits(viewAfterLayout-&gt;contentsScrollPosition().x());
1330 }
1331 
1332 int DOMWindow::scrollY() const
1333 {
<span class="line-modified">1334     auto* frame = this-&gt;frame();</span>
1335     if (!frame)
1336         return 0;
1337 
<span class="line-modified">1338     FrameView* view = frame-&gt;view();</span>
1339     if (!view)
1340         return 0;
1341 
1342     int scrollY = view-&gt;contentsScrollPosition().y();
1343     if (!scrollY)
1344         return 0;
1345 
1346     frame-&gt;document()-&gt;updateLayoutIgnorePendingStylesheets();
1347 
1348     // Layout may have affected the current frame:
<span class="line-modified">1349     auto* frameAfterLayout = this-&gt;frame();</span>
1350     if (!frameAfterLayout)
1351         return 0;
1352 
<span class="line-modified">1353     FrameView* viewAfterLayout = frameAfterLayout-&gt;view();</span>
1354     if (!viewAfterLayout)
1355         return 0;
1356 
1357     return viewAfterLayout-&gt;mapFromLayoutToCSSUnits(viewAfterLayout-&gt;contentsScrollPosition().y());
1358 }
1359 
1360 bool DOMWindow::closed() const
1361 {
<span class="line-modified">1362     return !frame();</span>





1363 }
1364 
1365 unsigned DOMWindow::length() const
1366 {
1367     if (!isCurrentlyDisplayedInFrame())
1368         return 0;
1369 
1370     return frame()-&gt;tree().scopedChildCount();
1371 }
1372 
1373 String DOMWindow::name() const
1374 {
1375     auto* frame = this-&gt;frame();
1376     if (!frame)
1377         return String();
1378 
1379     return frame-&gt;tree().name();
1380 }
1381 
1382 void DOMWindow::setName(const String&amp; string)
</pre>
<hr />
<pre>
1403     ASSERT(frame-&gt;document()); // Client calls shouldn&#39;t be made when the frame is in inconsistent state.
1404     page-&gt;chrome().setStatusbarText(*frame, m_status);
1405 }
1406 
1407 void DOMWindow::setDefaultStatus(const String&amp; string)
1408 {
1409     m_defaultStatus = string;
1410 
1411     auto* frame = this-&gt;frame();
1412     if (!frame)
1413         return;
1414 
1415     Page* page = frame-&gt;page();
1416     if (!page)
1417         return;
1418 
1419     ASSERT(frame-&gt;document()); // Client calls shouldn&#39;t be made when the frame is in inconsistent state.
1420     page-&gt;chrome().setStatusbarText(*frame, m_defaultStatus);
1421 }
1422 
<span class="line-removed">1423 WindowProxy* DOMWindow::self() const</span>
<span class="line-removed">1424 {</span>
<span class="line-removed">1425     auto* frame = this-&gt;frame();</span>
<span class="line-removed">1426     if (!frame)</span>
<span class="line-removed">1427         return nullptr;</span>
<span class="line-removed">1428 </span>
<span class="line-removed">1429     return &amp;frame-&gt;windowProxy();</span>
<span class="line-removed">1430 }</span>
<span class="line-removed">1431 </span>
1432 WindowProxy* DOMWindow::opener() const
1433 {
1434     auto* frame = this-&gt;frame();
1435     if (!frame)
1436         return nullptr;
1437 
1438     auto* openerFrame = frame-&gt;loader().opener();
1439     if (!openerFrame)
1440         return nullptr;
1441 
1442     return &amp;openerFrame-&gt;windowProxy();
1443 }
1444 
1445 void DOMWindow::disownOpener()
1446 {
1447     if (auto* frame = this-&gt;frame())
1448         frame-&gt;loader().setOpener(nullptr);
1449 }
1450 
1451 WindowProxy* DOMWindow::parent() const
</pre>
<hr />
<pre>
1485 }
1486 
1487 StyleMedia&amp; DOMWindow::styleMedia()
1488 {
1489     if (!m_media)
1490         m_media = StyleMedia::create(*this);
1491     return *m_media;
1492 }
1493 
1494 Ref&lt;CSSStyleDeclaration&gt; DOMWindow::getComputedStyle(Element&amp; element, const String&amp; pseudoElt) const
1495 {
1496     return CSSComputedStyleDeclaration::create(element, false, pseudoElt);
1497 }
1498 
1499 RefPtr&lt;CSSRuleList&gt; DOMWindow::getMatchedCSSRules(Element* element, const String&amp; pseudoElement, bool authorOnly) const
1500 {
1501     if (!isCurrentlyDisplayedInFrame())
1502         return nullptr;
1503 
1504     unsigned colonStart = pseudoElement[0] == &#39;:&#39; ? (pseudoElement[1] == &#39;:&#39; ? 2 : 1) : 0;
<span class="line-modified">1505     CSSSelector::PseudoElementType pseudoType = CSSSelector::parsePseudoElementType(pseudoElement.substringSharingImpl(colonStart));</span>
1506     if (pseudoType == CSSSelector::PseudoElementUnknown &amp;&amp; !pseudoElement.isEmpty())
1507         return nullptr;
1508 
1509     auto* frame = this-&gt;frame();
1510     frame-&gt;document()-&gt;styleScope().flushPendingUpdate();
1511 
1512     unsigned rulesToInclude = StyleResolver::AuthorCSSRules;
1513     if (!authorOnly)
1514         rulesToInclude |= StyleResolver::UAAndUserCSSRules;
1515 
1516     PseudoId pseudoId = CSSSelector::pseudoId(pseudoType);
1517 
1518     auto matchedRules = frame-&gt;document()-&gt;styleScope().resolver().pseudoStyleRulesForElement(element, pseudoId, rulesToInclude);
1519     if (matchedRules.isEmpty())
1520         return nullptr;
1521 
1522     bool allowCrossOrigin = frame-&gt;settings().crossOriginCheckInGetMatchedCSSRulesDisabled();
1523 
1524     auto ruleList = StaticCSSRuleList::create();
1525     for (auto&amp; rule : matchedRules) {
1526         if (!allowCrossOrigin &amp;&amp; !rule-&gt;hasDocumentSecurityOrigin())
1527             continue;
1528         ruleList-&gt;rules().append(rule-&gt;createCSSOMWrapper());
1529     }
1530 
1531     if (ruleList-&gt;rules().isEmpty())
1532         return nullptr;
1533 
<span class="line-modified">1534     return WTFMove(ruleList);</span>
1535 }
1536 
1537 RefPtr&lt;WebKitPoint&gt; DOMWindow::webkitConvertPointFromNodeToPage(Node* node, const WebKitPoint* p) const
1538 {
1539     if (!node || !p)
1540         return nullptr;
1541 
1542     if (!document())
1543         return nullptr;
1544 
1545     document()-&gt;updateLayoutIgnorePendingStylesheets();
1546 
1547     FloatPoint pagePoint(p-&gt;x(), p-&gt;y());
1548     pagePoint = node-&gt;convertToPage(pagePoint);
1549     return WebKitPoint::create(pagePoint.x(), pagePoint.y());
1550 }
1551 
1552 RefPtr&lt;WebKitPoint&gt; DOMWindow::webkitConvertPointFromPageToNode(Node* node, const WebKitPoint* p) const
1553 {
1554     if (!node || !p)
</pre>
<hr />
<pre>
1693 
1694 ExceptionOr&lt;int&gt; DOMWindow::setTimeout(JSC::ExecState&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
1695 {
1696     auto* context = scriptExecutionContext();
1697     if (!context)
1698         return Exception { InvalidAccessError };
1699 
1700     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
1701     if (action-&gt;type() == ScheduledAction::Type::Code) {
1702         if (!context-&gt;contentSecurityPolicy()-&gt;allowEval(&amp;state))
1703             return 0;
1704     }
1705 
1706     action-&gt;addArguments(WTFMove(arguments));
1707 
1708     return DOMTimer::install(*context, WTFMove(action), Seconds::fromMilliseconds(timeout), true);
1709 }
1710 
1711 void DOMWindow::clearTimeout(int timeoutId)
1712 {
<span class="line-removed">1713 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">1714     if (auto* frame = this-&gt;frame()) {</span>
<span class="line-removed">1715         Document* document = frame-&gt;document();</span>
<span class="line-removed">1716         if (timeoutId &gt; 0 &amp;&amp; document) {</span>
<span class="line-removed">1717             DOMTimer* timer = document-&gt;findTimeout(timeoutId);</span>
<span class="line-removed">1718             if (timer &amp;&amp; WebThreadContainsObservedDOMTimer(timer)) {</span>
<span class="line-removed">1719                 LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;DOMWindow::clearTimeout: remove registered timer (&quot; &lt;&lt; timer &lt;&lt; &quot;)&quot;);</span>
<span class="line-removed">1720                 WebThreadRemoveObservedDOMTimer(timer);</span>
<span class="line-removed">1721 </span>
<span class="line-removed">1722                 if (!WebThreadCountOfObservedDOMTimers()) {</span>
<span class="line-removed">1723                     if (Page* page = frame-&gt;page())</span>
<span class="line-removed">1724                         page-&gt;chrome().client().observedContentChange(*frame);</span>
<span class="line-removed">1725                 }</span>
<span class="line-removed">1726             }</span>
<span class="line-removed">1727         }</span>
<span class="line-removed">1728     }</span>
<span class="line-removed">1729 #endif</span>
1730     ScriptExecutionContext* context = scriptExecutionContext();
1731     if (!context)
1732         return;
1733     DOMTimer::removeById(*context, timeoutId);
1734 }
1735 
1736 ExceptionOr&lt;int&gt; DOMWindow::setInterval(JSC::ExecState&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
1737 {
1738     auto* context = scriptExecutionContext();
1739     if (!context)
1740         return Exception { InvalidAccessError };
1741 
1742     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
1743     if (action-&gt;type() == ScheduledAction::Type::Code) {
1744         if (!context-&gt;contentSecurityPolicy()-&gt;allowEval(&amp;state))
1745             return 0;
1746     }
1747 
1748     action-&gt;addArguments(WTFMove(arguments));
1749 
1750     return DOMTimer::install(*context, WTFMove(action), Seconds::fromMilliseconds(timeout), false);
1751 }
1752 
1753 void DOMWindow::clearInterval(int timeoutId)
1754 {
1755     ScriptExecutionContext* context = scriptExecutionContext();
1756     if (!context)
1757         return;
1758     DOMTimer::removeById(*context, timeoutId);
1759 }
1760 
1761 int DOMWindow::requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
1762 {
<span class="line-removed">1763     callback-&gt;m_useLegacyTimeBase = false;</span>
1764     auto* document = this-&gt;document();
1765     if (!document)
1766         return 0;
1767     return document-&gt;requestAnimationFrame(WTFMove(callback));
1768 }
1769 
1770 int DOMWindow::webkitRequestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
1771 {
<span class="line-modified">1772     callback-&gt;m_useLegacyTimeBase = true;</span>
<span class="line-modified">1773     auto* document = this-&gt;document();</span>
<span class="line-modified">1774     if (!document)</span>
<span class="line-modified">1775         return 0;</span>
<span class="line-modified">1776     return document-&gt;requestAnimationFrame(WTFMove(callback));</span>

1777 }
1778 
1779 void DOMWindow::cancelAnimationFrame(int id)
1780 {
1781     auto* document = this-&gt;document();
1782     if (!document)
1783         return;
1784     document-&gt;cancelAnimationFrame(id);
1785 }
1786 
1787 void DOMWindow::createImageBitmap(ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
1788 {
1789     auto* document = this-&gt;document();
1790     if (!document) {
1791         promise.reject(InvalidStateError);
1792         return;
1793     }
1794     ImageBitmap::createPromise(*document, WTFMove(source), WTFMove(options), WTFMove(promise));
1795 }
1796 
</pre>
<hr />
<pre>
1822     window.sessionStorage();
1823 }
1824 
1825 bool DOMWindow::isSameSecurityOriginAsMainFrame() const
1826 {
1827     auto* frame = this-&gt;frame();
1828     if (!frame || !frame-&gt;page() || !document())
1829         return false;
1830 
1831     if (frame-&gt;isMainFrame())
1832         return true;
1833 
1834     Document* mainFrameDocument = frame-&gt;mainFrame().document();
1835 
1836     if (mainFrameDocument &amp;&amp; document()-&gt;securityOrigin().canAccess(mainFrameDocument-&gt;securityOrigin()))
1837         return true;
1838 
1839     return false;
1840 }
1841 
<span class="line-modified">1842 bool DOMWindow::addEventListener(const AtomicString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
1843 {
1844     if (!EventTarget::addEventListener(eventType, WTFMove(listener), options))
1845         return false;
1846 
<span class="line-modified">1847     if (Document* document = this-&gt;document()) {</span>

1848         document-&gt;addListenerTypeIfNeeded(eventType);
1849         if (eventNames().isWheelEventType(eventType))
1850             document-&gt;didAddWheelEventHandler(*document);
<span class="line-modified">1851         else if (eventNames().isTouchEventType(eventType))</span>
1852             document-&gt;didAddTouchEventHandler(*document);
1853         else if (eventType == eventNames().storageEvent)
1854             didAddStorageEventListener(*this);
1855     }
1856 
1857     if (eventType == eventNames().unloadEvent)
1858         addUnloadEventListener(this);
1859     else if (eventType == eventNames().beforeunloadEvent &amp;&amp; allowsBeforeUnloadListeners(this))
1860         addBeforeUnloadEventListener(this);
1861 #if PLATFORM(IOS_FAMILY)
1862     else if (eventType == eventNames().scrollEvent)
1863         incrementScrollEventListenersCount();
1864 #endif
1865 #if ENABLE(IOS_TOUCH_EVENTS)
<span class="line-modified">1866     else if (eventNames().isTouchEventType(eventType))</span>
1867         ++m_touchAndGestureEventListenerCount;
1868 #endif
1869 #if ENABLE(IOS_GESTURE_EVENTS)
1870     else if (eventNames().isGestureEventType(eventType))
1871         ++m_touchAndGestureEventListenerCount;
1872 #endif
1873 #if ENABLE(GAMEPAD)
1874     else if (eventNames().isGamepadEventType(eventType))
1875         incrementGamepadEventListenerCount();
1876 #endif









1877 
1878 #if ENABLE(DEVICE_ORIENTATION)
<span class="line-modified">1879     if (frame() &amp;&amp; frame()-&gt;settings().deviceOrientationEventEnabled() &amp;&amp; document() &amp;&amp; document()-&gt;loader() &amp;&amp; document()-&gt;loader()-&gt;deviceOrientationEventEnabled()) {</span>


1880 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">1881         if ((eventType == eventNames().devicemotionEvent || eventType == eventNames().deviceorientationEvent)) {</span>
<span class="line-removed">1882             if (isSameSecurityOriginAsMainFrame() &amp;&amp; isSecureContext()) {</span>
<span class="line-removed">1883                 if (eventType == eventNames().deviceorientationEvent)</span>
<span class="line-removed">1884                     document()-&gt;deviceOrientationController().addDeviceEventListener(*this);</span>
<span class="line-removed">1885                 else</span>
<span class="line-removed">1886                     document()-&gt;deviceMotionController().addDeviceEventListener(*this);</span>
<span class="line-removed">1887             } else if (document()) {</span>
<span class="line-removed">1888                 if (isSecureContext())</span>
<span class="line-removed">1889                     document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;Blocked attempt to add a device motion or orientation listener from child frame that wasn&#39;t the same security origin as the main page.&quot;_s);</span>
<span class="line-removed">1890                 else</span>
<span class="line-removed">1891                     document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;Blocked attempt to add a device motion or orientation listener because the browsing context is not secure.&quot;_s);</span>
<span class="line-removed">1892             }</span>
<span class="line-removed">1893         }</span>
1894 #else
<span class="line-modified">1895         if (eventType == eventNames().devicemotionEvent) {</span>
<span class="line-modified">1896             if (isSameSecurityOriginAsMainFrame() &amp;&amp; isSecureContext()) {</span>
<span class="line-modified">1897                 if (DeviceMotionController* controller = DeviceMotionController::from(page()))</span>
<span class="line-modified">1898                     controller-&gt;addDeviceEventListener(*this);</span>
<span class="line-modified">1899             } else</span>
<span class="line-modified">1900                 document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;Blocked attempt to add a device motion listener from child frame that wasn&#39;t the same security origin as the main page.&quot;_s);</span>
<span class="line-modified">1901         } else if (eventType == eventNames().deviceorientationEvent) {</span>
<span class="line-modified">1902             if (isSameSecurityOriginAsMainFrame() &amp;&amp; isSecureContext()) {</span>
<span class="line-modified">1903                 if (DeviceOrientationController* controller = DeviceOrientationController::from(page()))</span>
<span class="line-modified">1904                     controller-&gt;addDeviceEventListener(*this);</span>
<span class="line-modified">1905             } else {</span>
<span class="line-modified">1906                 if (isSecureContext())</span>
<span class="line-modified">1907                     document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;Blocked attempt to add a device orientation listener from child frame that wasn&#39;t the same security origin as the main page.&quot;_s);</span>
<span class="line-modified">1908                 else</span>
<span class="line-modified">1909                     document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;Blocked attempt to add a device motion or orientation listener because the browsing context is not secure.&quot;_s);</span>
<span class="line-modified">1910             }</span>



































1911         }
<span class="line-removed">1912 #endif // PLATFORM(IOS_FAMILY)</span>
1913     }
<span class="line-removed">1914 #endif // ENABLE(DEVICE_ORIENTATION)</span>
1915 
1916     return true;
1917 }
1918 














































































1919 #if PLATFORM(IOS_FAMILY)
1920 
1921 void DOMWindow::incrementScrollEventListenersCount()
1922 {
1923     Document* document = this-&gt;document();
1924     if (++m_scrollEventListenerCount == 1 &amp;&amp; document == &amp;document-&gt;topDocument()) {
1925         Frame* frame = this-&gt;frame();
1926         if (frame &amp;&amp; frame-&gt;page())
1927             frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, true);
1928     }
1929 }
1930 
1931 void DOMWindow::decrementScrollEventListenersCount()
1932 {
1933     Document* document = this-&gt;document();
1934     if (!--m_scrollEventListenerCount &amp;&amp; document == &amp;document-&gt;topDocument()) {
1935         Frame* frame = this-&gt;frame();
1936         if (frame &amp;&amp; frame-&gt;page() &amp;&amp; document-&gt;pageCacheState() == Document::NotInPageCache)
1937             frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, false);
1938     }
1939 }
1940 
1941 #endif
1942 
1943 void DOMWindow::resetAllGeolocationPermission()
1944 {
1945     // FIXME: Can we remove the PLATFORM(IOS_FAMILY)-guard?
1946 #if ENABLE(GEOLOCATION) &amp;&amp; PLATFORM(IOS_FAMILY)
1947     if (m_navigator)
<span class="line-modified">1948         NavigatorGeolocation::from(m_navigator.get())-&gt;resetAllGeolocationPermission();</span>
1949 #endif
1950 }
1951 
<span class="line-modified">1952 bool DOMWindow::removeEventListener(const AtomicString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
1953 {
1954     if (!EventTarget::removeEventListener(eventType, listener, options.capture))
1955         return false;
1956 
<span class="line-modified">1957     if (Document* document = this-&gt;document()) {</span>

1958         if (eventNames().isWheelEventType(eventType))
1959             document-&gt;didRemoveWheelEventHandler(*document);
<span class="line-modified">1960         else if (eventNames().isTouchEventType(eventType))</span>
1961             document-&gt;didRemoveTouchEventHandler(*document);
1962     }
1963 
1964     if (eventType == eventNames().unloadEvent)
1965         removeUnloadEventListener(this);
1966     else if (eventType == eventNames().beforeunloadEvent &amp;&amp; allowsBeforeUnloadListeners(this))
1967         removeBeforeUnloadEventListener(this);
<span class="line-removed">1968 #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-removed">1969 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">1970     else if (eventType == eventNames().devicemotionEvent &amp;&amp; document())</span>
<span class="line-removed">1971         document()-&gt;deviceMotionController().removeDeviceEventListener(*this);</span>
<span class="line-removed">1972     else if (eventType == eventNames().deviceorientationEvent &amp;&amp; document())</span>
<span class="line-removed">1973         document()-&gt;deviceOrientationController().removeDeviceEventListener(*this);</span>
<span class="line-removed">1974 #else</span>
<span class="line-removed">1975     else if (eventType == eventNames().devicemotionEvent) {</span>
<span class="line-removed">1976         if (DeviceMotionController* controller = DeviceMotionController::from(page()))</span>
<span class="line-removed">1977             controller-&gt;removeDeviceEventListener(*this);</span>
<span class="line-removed">1978     } else if (eventType == eventNames().deviceorientationEvent) {</span>
<span class="line-removed">1979         if (DeviceOrientationController* controller = DeviceOrientationController::from(page()))</span>
<span class="line-removed">1980             controller-&gt;removeDeviceEventListener(*this);</span>
<span class="line-removed">1981     }</span>
<span class="line-removed">1982 #endif // PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">1983 #endif // ENABLE(DEVICE_ORIENTATION)</span>
1984 #if PLATFORM(IOS_FAMILY)
1985     else if (eventType == eventNames().scrollEvent)
1986         decrementScrollEventListenersCount();
1987 #endif
1988 #if ENABLE(IOS_TOUCH_EVENTS)
<span class="line-modified">1989     else if (eventNames().isTouchEventType(eventType)) {</span>
1990         ASSERT(m_touchAndGestureEventListenerCount &gt; 0);
1991         --m_touchAndGestureEventListenerCount;
1992     }
1993 #endif
1994 #if ENABLE(IOS_GESTURE_EVENTS)
1995     else if (eventNames().isGestureEventType(eventType)) {
1996         ASSERT(m_touchAndGestureEventListenerCount &gt; 0);
1997         --m_touchAndGestureEventListenerCount;
1998     }
1999 #endif
2000 #if ENABLE(GAMEPAD)
2001     else if (eventNames().isGamepadEventType(eventType))
2002         decrementGamepadEventListenerCount();
2003 #endif






2004 
2005     return true;
2006 }
2007 
2008 void DOMWindow::languagesChanged()
2009 {
2010     if (auto* document = this-&gt;document())
2011         document-&gt;enqueueWindowEvent(Event::create(eventNames().languagechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
2012 }
2013 
2014 void DOMWindow::dispatchLoadEvent()
2015 {
2016     // If we did not protect it, the document loader and its timing subobject might get destroyed
2017     // as a side effect of what event handling code does.
2018     auto protectedThis = makeRef(*this);
2019     auto protectedLoader = makeRefPtr(frame() ? frame()-&gt;loader().documentLoader() : nullptr);
2020     bool shouldMarkLoadEventTimes = protectedLoader &amp;&amp; !protectedLoader-&gt;timing().loadEventStart();
2021 
2022     if (shouldMarkLoadEventTimes)
2023         protectedLoader-&gt;timing().markLoadEventStart();
</pre>
<hr />
<pre>
2057                 return; // Event was previously dispatched; do not fire a duplicate event.
2058             m_lastPageStatus = PageStatus::Shown;
2059         } else if (event.type() == eventNames().pagehideEvent) {
2060             if (m_lastPageStatus == PageStatus::Hidden)
2061                 return; // Event was previously dispatched; do not fire a duplicate event.
2062             m_lastPageStatus = PageStatus::Hidden;
2063         }
2064     }
2065 
2066     // FIXME: It doesn&#39;t seem right to have the inspector instrumentation here since not all
2067     // events dispatched to the window object are guaranteed to flow through this function.
2068     // But the instrumentation prevents us from calling EventDispatcher::dispatchEvent here.
2069     event.setTarget(target ? target : this);
2070     event.setCurrentTarget(this);
2071     event.setEventPhase(Event::AT_TARGET);
2072     event.resetBeforeDispatch();
2073     auto cookie = InspectorInstrumentation::willDispatchEventOnWindow(frame(), event, *this);
2074     // FIXME: We should use EventDispatcher everywhere.
2075     fireEventListeners(event, EventInvokePhase::Capturing);
2076     fireEventListeners(event, EventInvokePhase::Bubbling);
<span class="line-modified">2077     InspectorInstrumentation::didDispatchEventOnWindow(cookie);</span>
2078     event.resetAfterDispatch();
2079 }
2080 
2081 void DOMWindow::removeAllEventListeners()
2082 {
2083     EventTarget::removeAllEventListeners();
2084 
2085 #if ENABLE(DEVICE_ORIENTATION)
<span class="line-modified">2086 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">2087     if (Document* document = this-&gt;document()) {</span>
<span class="line-modified">2088         document-&gt;deviceMotionController().removeAllDeviceEventListeners(*this);</span>
<span class="line-removed">2089         document-&gt;deviceOrientationController().removeAllDeviceEventListeners(*this);</span>
<span class="line-removed">2090     }</span>
<span class="line-removed">2091 #else</span>
<span class="line-removed">2092     if (DeviceMotionController* controller = DeviceMotionController::from(page()))</span>
<span class="line-removed">2093         controller-&gt;removeAllDeviceEventListeners(*this);</span>
<span class="line-removed">2094     if (DeviceOrientationController* controller = DeviceOrientationController::from(page()))</span>
<span class="line-removed">2095         controller-&gt;removeAllDeviceEventListeners(*this);</span>
<span class="line-removed">2096 #endif // PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">2097 #endif // ENABLE(DEVICE_ORIENTATION)</span>
2098 
2099 #if PLATFORM(IOS_FAMILY)
2100     if (m_scrollEventListenerCount) {
2101         m_scrollEventListenerCount = 1;
2102         decrementScrollEventListenersCount();
2103     }
2104 #endif
2105 
2106 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS)
2107     m_touchAndGestureEventListenerCount = 0;
2108 #endif
2109 
2110 #if ENABLE(TOUCH_EVENTS)
2111     if (Document* document = this-&gt;document())
2112         document-&gt;didRemoveEventTargetNode(*document);
2113 #endif
2114 
2115     if (m_performance) {
2116         m_performance-&gt;removeAllEventListeners();
2117         m_performance-&gt;removeAllObservers();
</pre>
<hr />
<pre>
2232 
2233     // If this DOMWindow isn&#39;t currently active in the Frame, then there&#39;s no
2234     // way we should allow the access.
2235     // FIXME: Remove this check if we&#39;re able to disconnect DOMWindow from
2236     // Frame on navigation: https://bugs.webkit.org/show_bug.cgi?id=62054
2237     if (isCurrentlyDisplayedInFrame()) {
2238         // FIXME: Is there some way to eliminate the need for a separate &quot;activeWindow == this&quot; check?
2239         if (&amp;activeWindow == this)
2240             return false;
2241 
2242         // FIXME: The name canAccess seems to be a roundabout way to ask &quot;can execute script&quot;.
2243         // Can we name the SecurityOrigin function better to make this more clear?
2244         if (activeWindow.document()-&gt;securityOrigin().canAccess(document()-&gt;securityOrigin()))
2245             return false;
2246     }
2247 
2248     printErrorMessage(crossDomainAccessErrorMessage(activeWindow, IncludeTargetOrigin::Yes));
2249     return true;
2250 }
2251 
<span class="line-modified">2252 ExceptionOr&lt;RefPtr&lt;Frame&gt;&gt; DOMWindow::createWindow(const String&amp; urlString, const AtomicString&amp; frameName, const WindowFeatures&amp; windowFeatures, DOMWindow&amp; activeWindow, Frame&amp; firstFrame, Frame&amp; openerFrame, const WTF::Function&lt;void(DOMWindow&amp;)&gt;&amp; prepareDialogFunction)</span>
2253 {
2254     Frame* activeFrame = activeWindow.frame();
2255     if (!activeFrame)
2256         return RefPtr&lt;Frame&gt; { nullptr };
2257 
2258     Document* activeDocument = activeWindow.document();
2259     if (!activeDocument)
2260         return RefPtr&lt;Frame&gt; { nullptr };
2261 
2262     URL completedURL = urlString.isEmpty() ? URL({ }, emptyString()) : firstFrame.document()-&gt;completeURL(urlString);
2263     if (!completedURL.isEmpty() &amp;&amp; !completedURL.isValid())
2264         return Exception { SyntaxError };
2265 
2266     // For whatever reason, Firefox uses the first frame to determine the outgoingReferrer. We replicate that behavior here.
<span class="line-modified">2267     String referrer = SecurityPolicy::generateReferrerHeader(firstFrame.document()-&gt;referrerPolicy(), completedURL, firstFrame.loader().outgoingReferrer());</span>
2268     auto initiatedByMainFrame = activeFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
2269 
2270     ResourceRequest resourceRequest { completedURL, referrer };
2271     FrameLoader::addHTTPOriginIfNeeded(resourceRequest, firstFrame.loader().outgoingOrigin());
2272     FrameLoadRequest frameLoadRequest { *activeDocument, activeDocument-&gt;securityOrigin(), resourceRequest, frameName, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, activeDocument-&gt;shouldOpenExternalURLsPolicyToPropagate(), initiatedByMainFrame };
2273 
2274     // We pass the opener frame for the lookupFrame in case the active frame is different from
2275     // the opener frame, and the name references a frame relative to the opener frame.
2276     bool created;
2277     auto newFrame = WebCore::createWindow(*activeFrame, openerFrame, WTFMove(frameLoadRequest), windowFeatures, created);
2278     if (!newFrame)
2279         return RefPtr&lt;Frame&gt; { nullptr };
2280 
<span class="line-modified">2281     if (!windowFeatures.noopener)</span>

2282         newFrame-&gt;loader().setOpener(&amp;openerFrame);
2283 
2284     if (created)
2285         newFrame-&gt;page()-&gt;setOpenedByDOM();
2286 
2287     if (newFrame-&gt;document()-&gt;domWindow()-&gt;isInsecureScriptAccess(activeWindow, completedURL))
<span class="line-modified">2288         return windowFeatures.noopener ? RefPtr&lt;Frame&gt; { nullptr } : newFrame;</span>
2289 
2290     if (prepareDialogFunction)
2291         prepareDialogFunction(*newFrame-&gt;document()-&gt;domWindow());
2292 
2293     if (created) {
2294         ResourceRequest resourceRequest { completedURL, referrer, ResourceRequestCachePolicy::UseProtocolCachePolicy };
2295         FrameLoader::addSameSiteInfoToRequestIfNeeded(resourceRequest, openerFrame.document());
2296         FrameLoadRequest frameLoadRequest { *activeWindow.document(), activeWindow.document()-&gt;securityOrigin(), resourceRequest, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, activeDocument-&gt;shouldOpenExternalURLsPolicyToPropagate(), initiatedByMainFrame };
2297         newFrame-&gt;loader().changeLocation(WTFMove(frameLoadRequest));
2298     } else if (!urlString.isEmpty()) {
2299         LockHistory lockHistory = UserGestureIndicator::processingUserGesture() ? LockHistory::No : LockHistory::Yes;
2300         newFrame-&gt;navigationScheduler().scheduleLocationChange(*activeDocument, activeDocument-&gt;securityOrigin(), completedURL, referrer, lockHistory, LockBackForwardList::No);
2301     }
2302 
2303     // Navigating the new frame could result in it being detached from its page by a navigation policy delegate.
2304     if (!newFrame-&gt;page())
2305         return RefPtr&lt;Frame&gt; { nullptr };
2306 
<span class="line-modified">2307     return windowFeatures.noopener ? RefPtr&lt;Frame&gt; { nullptr } : newFrame;</span>
2308 }
2309 
<span class="line-modified">2310 ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; DOMWindow::open(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; urlString, const AtomicString&amp; frameName, const String&amp; windowFeaturesString)</span>
2311 {
2312     if (!isCurrentlyDisplayedInFrame())
2313         return RefPtr&lt;WindowProxy&gt; { nullptr };
2314 
2315     auto* activeDocument = activeWindow.document();
2316     if (!activeDocument)
2317         return RefPtr&lt;WindowProxy&gt; { nullptr };
2318 
2319     auto* firstFrame = firstWindow.frame();
2320     if (!firstFrame)
2321         return RefPtr&lt;WindowProxy&gt; { nullptr };
2322 




2323 #if ENABLE(CONTENT_EXTENSIONS)
2324     if (firstFrame-&gt;document()
2325         &amp;&amp; firstFrame-&gt;page()
2326         &amp;&amp; firstFrame-&gt;mainFrame().document()
2327         &amp;&amp; firstFrame-&gt;mainFrame().document()-&gt;loader()) {
<span class="line-modified">2328         ResourceLoadInfo resourceLoadInfo { firstFrame-&gt;document()-&gt;completeURL(urlString), firstFrame-&gt;mainFrame().document()-&gt;url(), ResourceType::Popup };</span>
<span class="line-modified">2329         for (auto&amp; action : firstFrame-&gt;page()-&gt;userContentProvider().actionsForResourceLoad(resourceLoadInfo, *firstFrame-&gt;mainFrame().document()-&gt;loader()).first) {</span>
<span class="line-modified">2330             if (action.type() == ContentExtensions::ActionType::BlockLoad)</span>
<span class="line-removed">2331                 return RefPtr&lt;WindowProxy&gt; { nullptr };</span>
<span class="line-removed">2332         }</span>
2333     }
2334 #endif
2335 
2336     auto* frame = this-&gt;frame();
2337     if (!firstWindow.allowPopUp()) {
2338         // Because FrameTree::findFrameForNavigation() returns true for empty strings, we must check for empty frame names.
2339         // Otherwise, illegitimate window.open() calls with no name will pass right through the popup blocker.
2340         if (frameName.isEmpty() || !frame-&gt;loader().findFrameForNavigation(frameName, activeDocument))
2341             return RefPtr&lt;WindowProxy&gt; { nullptr };
2342     }
2343 
2344     // Get the target frame for the special cases of _top and _parent.
2345     // In those cases, we schedule a location change right now and return early.
2346     Frame* targetFrame = nullptr;
2347     if (equalIgnoringASCIICase(frameName, &quot;_top&quot;))
2348         targetFrame = &amp;frame-&gt;tree().top();
2349     else if (equalIgnoringASCIICase(frameName, &quot;_parent&quot;)) {
2350         if (Frame* parent = frame-&gt;tree().parent())
2351             targetFrame = parent;
2352         else
</pre>
</td>
<td>
<hr />
<pre>
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;DOMWindow.h&quot;
  29 
  30 #include &quot;BackForwardController.h&quot;
  31 #include &quot;BarProp.h&quot;
  32 #include &quot;CSSComputedStyleDeclaration.h&quot;
  33 #include &quot;CSSRule.h&quot;
  34 #include &quot;CSSRuleList.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;ChromeClient.h&quot;
  37 #include &quot;ComposedTreeIterator.h&quot;
  38 #include &quot;ContentExtensionActions.h&quot;
  39 #include &quot;ContentExtensionRule.h&quot;
<span class="line-added">  40 #include &quot;ContentRuleListResults.h&quot;</span>
  41 #include &quot;Crypto.h&quot;
  42 #include &quot;CustomElementRegistry.h&quot;
  43 #include &quot;DOMApplicationCache.h&quot;
  44 #include &quot;DOMSelection.h&quot;
  45 #include &quot;DOMStringList.h&quot;
  46 #include &quot;DOMTimer.h&quot;
  47 #include &quot;DOMTokenList.h&quot;
  48 #include &quot;DOMURL.h&quot;

  49 #include &quot;DeviceMotionController.h&quot;
<span class="line-added">  50 #include &quot;DeviceMotionData.h&quot;</span>
<span class="line-added">  51 #include &quot;DeviceMotionEvent.h&quot;</span>
<span class="line-added">  52 #include &quot;DeviceOrientationAndMotionAccessController.h&quot;</span>
  53 #include &quot;DeviceOrientationController.h&quot;
  54 #include &quot;Document.h&quot;
  55 #include &quot;DocumentLoader.h&quot;
  56 #include &quot;Editor.h&quot;
  57 #include &quot;Element.h&quot;
  58 #include &quot;EventHandler.h&quot;
  59 #include &quot;EventListener.h&quot;
  60 #include &quot;EventNames.h&quot;
  61 #include &quot;FloatRect.h&quot;
  62 #include &quot;FocusController.h&quot;
  63 #include &quot;Frame.h&quot;
  64 #include &quot;FrameLoadRequest.h&quot;
  65 #include &quot;FrameLoader.h&quot;
  66 #include &quot;FrameLoaderClient.h&quot;
  67 #include &quot;FrameTree.h&quot;
  68 #include &quot;FrameView.h&quot;
  69 #include &quot;HTTPParsers.h&quot;
  70 #include &quot;History.h&quot;
  71 #include &quot;InspectorInstrumentation.h&quot;
  72 #include &quot;JSDOMWindowBase.h&quot;
</pre>
<hr />
<pre>
  98 #include &quot;StaticNodeList.h&quot;
  99 #include &quot;Storage.h&quot;
 100 #include &quot;StorageArea.h&quot;
 101 #include &quot;StorageNamespace.h&quot;
 102 #include &quot;StorageNamespaceProvider.h&quot;
 103 #include &quot;StyleMedia.h&quot;
 104 #include &quot;StyleResolver.h&quot;
 105 #include &quot;StyleScope.h&quot;
 106 #include &quot;SuddenTermination.h&quot;
 107 #include &lt;wtf/URL.h&gt;
 108 #include &quot;UserGestureIndicator.h&quot;
 109 #include &quot;VisualViewport.h&quot;
 110 #include &quot;WebKitPoint.h&quot;
 111 #include &quot;WindowFeatures.h&quot;
 112 #include &quot;WindowFocusAllowedIndicator.h&quot;
 113 #include &quot;WindowProxy.h&quot;
 114 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 115 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
 116 #include &lt;algorithm&gt;
 117 #include &lt;memory&gt;
<span class="line-added"> 118 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
 119 #include &lt;wtf/Language.h&gt;
 120 #include &lt;wtf/MainThread.h&gt;
 121 #include &lt;wtf/MathExtras.h&gt;
 122 #include &lt;wtf/NeverDestroyed.h&gt;
 123 #include &lt;wtf/Ref.h&gt;
<span class="line-added"> 124 #include &lt;wtf/SetForScope.h&gt;</span>
 125 #include &lt;wtf/Variant.h&gt;
 126 #include &lt;wtf/text/WTFString.h&gt;
 127 
 128 #if ENABLE(USER_MESSAGE_HANDLERS)
 129 #include &quot;UserContentController.h&quot;
 130 #include &quot;UserMessageHandlerDescriptor.h&quot;
 131 #include &quot;WebKitNamespace.h&quot;
 132 #endif
 133 
 134 #if ENABLE(GAMEPAD)
 135 #include &quot;GamepadManager.h&quot;
 136 #endif
 137 
 138 #if ENABLE(GEOLOCATION)
 139 #include &quot;NavigatorGeolocation.h&quot;
 140 #endif
 141 
 142 #if ENABLE(POINTER_LOCK)
 143 #include &quot;PointerLockController.h&quot;
 144 #endif
 145 






 146 namespace WebCore {
 147 using namespace Inspector;
 148 
<span class="line-added"> 149 WTF_MAKE_ISO_ALLOCATED_IMPL(DOMWindow);</span>
<span class="line-added"> 150 </span>
 151 class PostMessageTimer : public TimerBase {
 152 public:
 153     PostMessageTimer(DOMWindow&amp; window, MessageWithMessagePorts&amp;&amp; message, const String&amp; sourceOrigin, RefPtr&lt;WindowProxy&gt;&amp;&amp; source, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; targetOrigin, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; stackTrace)
 154         : m_window(window)
 155         , m_message(WTFMove(message))
 156         , m_origin(sourceOrigin)
 157         , m_source(source)
 158         , m_targetOrigin(WTFMove(targetOrigin))
 159         , m_stackTrace(stackTrace)
 160         , m_userGestureToForward(UserGestureIndicator::currentUserGesture())
 161     {
 162     }
 163 
 164     Ref&lt;MessageEvent&gt; event(ScriptExecutionContext&amp; context)
 165     {
 166         return MessageEvent::create(MessagePort::entanglePorts(context, WTFMove(m_message.transferredPorts)), m_message.message.releaseNonNull(), m_origin, { }, m_source ? makeOptional(MessageEventSource(WTFMove(m_source))) : WTF::nullopt);
 167     }
 168 
 169     SecurityOrigin* targetOrigin() const { return m_targetOrigin.get(); }
 170     ScriptCallStack* stackTrace() const { return m_stackTrace.get(); }
</pre>
<hr />
<pre>
 398 {
 399     static_cast&lt;DOMWindow*&gt;(context)-&gt;languagesChanged();
 400 }
 401 
 402 void DOMWindow::setCanShowModalDialogOverride(bool allow)
 403 {
 404     m_canShowModalDialogOverride = allow;
 405 }
 406 
 407 DOMWindow::DOMWindow(Document&amp; document)
 408     : AbstractDOMWindow(GlobalWindowIdentifier { Process::identifier(), WindowIdentifier::generate() })
 409     , ContextDestructionObserver(&amp;document)
 410 {
 411     ASSERT(frame());
 412     addLanguageChangeObserver(this, &amp;languagesChangedCallback);
 413 }
 414 
 415 void DOMWindow::didSecureTransitionTo(Document&amp; document)
 416 {
 417     observeContext(&amp;document);
<span class="line-added"> 418 </span>
<span class="line-added"> 419     // The Window is being transferred from one document to another so we need to reset data</span>
<span class="line-added"> 420     // members that store the window&#39;s document (rather than the window itself).</span>
<span class="line-added"> 421     m_crypto = nullptr;</span>
<span class="line-added"> 422     m_navigator = nullptr;</span>
<span class="line-added"> 423     m_performance = nullptr;</span>
<span class="line-added"> 424 }</span>
<span class="line-added"> 425 </span>
<span class="line-added"> 426 void DOMWindow::prewarmLocalStorageIfNecessary()</span>
<span class="line-added"> 427 {</span>
<span class="line-added"> 428     auto* page = this-&gt;page();</span>
<span class="line-added"> 429 </span>
<span class="line-added"> 430     // No need to prewarm for ephemeral sessions since the data is in memory only.</span>
<span class="line-added"> 431     if (!page || page-&gt;usesEphemeralSession())</span>
<span class="line-added"> 432         return;</span>
<span class="line-added"> 433 </span>
<span class="line-added"> 434     if (!page-&gt;mainFrame().mayPrewarmLocalStorage())</span>
<span class="line-added"> 435         return;</span>
<span class="line-added"> 436 </span>
<span class="line-added"> 437     auto localStorageResult = this-&gt;localStorage();</span>
<span class="line-added"> 438     if (localStorageResult.hasException())</span>
<span class="line-added"> 439         return;</span>
<span class="line-added"> 440 </span>
<span class="line-added"> 441     auto* localStorage = localStorageResult.returnValue();</span>
<span class="line-added"> 442     if (!localStorage)</span>
<span class="line-added"> 443         return;</span>
<span class="line-added"> 444 </span>
<span class="line-added"> 445     page-&gt;mainFrame().didPrewarmLocalStorage();</span>
 446 }
 447 
 448 DOMWindow::~DOMWindow()
 449 {
 450     if (m_suspendedForDocumentSuspension)
 451         willDestroyCachedFrame();
 452     else
 453         willDestroyDocumentInFrame();
 454 
 455     removeAllUnloadEventListeners(this);
 456     removeAllBeforeUnloadEventListeners(this);
 457 
 458 #if ENABLE(GAMEPAD)
 459     if (m_gamepadEventListenerCount)
 460         GamepadManager::singleton().unregisterDOMWindow(this);
 461 #endif
 462 
 463     removeLanguageChangeObserver(this);
 464 }
 465 
 466 RefPtr&lt;MediaQueryList&gt; DOMWindow::matchMedia(const String&amp; media)
 467 {
 468     return document() ? document()-&gt;mediaQueryMatcher().matchMedia(media) : nullptr;
 469 }
 470 
 471 Page* DOMWindow::page()
 472 {
 473     return frame() ? frame()-&gt;page() : nullptr;
 474 }
 475 
 476 void DOMWindow::frameDestroyed()
 477 {
 478     Ref&lt;DOMWindow&gt; protectedThis(*this);
 479 
 480     willDestroyDocumentInFrame();
 481     JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(this);
 482 }
 483 
 484 void DOMWindow::willDestroyCachedFrame()
 485 {
<span class="line-modified"> 486     // It is necessary to copy m_observers to a separate vector because the Observer may</span>
 487     // unregister themselves from the DOMWindow as a result of the call to willDestroyGlobalObjectInCachedFrame.
<span class="line-modified"> 488     for (auto* observer : copyToVector(m_observers)) {</span>
<span class="line-modified"> 489         if (m_observers.contains(observer))</span>
<span class="line-modified"> 490             observer-&gt;willDestroyGlobalObjectInCachedFrame();</span>
 491     }
 492 }
 493 
 494 void DOMWindow::willDestroyDocumentInFrame()
 495 {
<span class="line-modified"> 496     // It is necessary to copy m_observers to a separate vector because the Observer may</span>
 497     // unregister themselves from the DOMWindow as a result of the call to willDestroyGlobalObjectInFrame.
<span class="line-modified"> 498     for (auto* observer : copyToVector(m_observers)) {</span>
<span class="line-modified"> 499         if (m_observers.contains(observer))</span>
<span class="line-modified"> 500             observer-&gt;willDestroyGlobalObjectInFrame();</span>
 501     }
 502 }
 503 
 504 void DOMWindow::willDetachDocumentFromFrame()
 505 {
 506     if (!frame())
 507         return;
 508 
<span class="line-modified"> 509     RELEASE_ASSERT(!m_isSuspendingObservers);</span>
<span class="line-added"> 510 </span>
<span class="line-added"> 511     // It is necessary to copy m_observers to a separate vector because the Observer may</span>
 512     // unregister themselves from the DOMWindow as a result of the call to willDetachGlobalObjectFromFrame.
<span class="line-modified"> 513     for (auto&amp; observer : copyToVector(m_observers)) {</span>
<span class="line-modified"> 514         if (m_observers.contains(observer))</span>
<span class="line-modified"> 515             observer-&gt;willDetachGlobalObjectFromFrame();</span>
 516     }
 517 
 518     if (m_performance)
 519         m_performance-&gt;clearResourceTimings();
 520 
 521     JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(this);
 522     InspectorInstrumentation::frameWindowDiscarded(*frame(), this);
 523 }
 524 
 525 #if ENABLE(GAMEPAD)
 526 
 527 void DOMWindow::incrementGamepadEventListenerCount()
 528 {
 529     if (++m_gamepadEventListenerCount == 1)
 530         GamepadManager::singleton().registerDOMWindow(this);
 531 }
 532 
 533 void DOMWindow::decrementGamepadEventListenerCount()
 534 {
 535     ASSERT(m_gamepadEventListenerCount);
 536 
 537     if (!--m_gamepadEventListenerCount)
 538         GamepadManager::singleton().unregisterDOMWindow(this);
 539 }
 540 
 541 #endif
 542 
<span class="line-modified"> 543 void DOMWindow::registerObserver(Observer&amp; observer)</span>
 544 {
<span class="line-modified"> 545     m_observers.add(&amp;observer);</span>
 546 }
 547 
<span class="line-modified"> 548 void DOMWindow::unregisterObserver(Observer&amp; observer)</span>
 549 {
<span class="line-modified"> 550     m_observers.remove(&amp;observer);</span>
 551 }
 552 
 553 void DOMWindow::resetUnlessSuspendedForDocumentSuspension()
 554 {
 555     if (m_suspendedForDocumentSuspension)
 556         return;
 557     willDestroyDocumentInFrame();

 558 }
 559 
 560 void DOMWindow::suspendForPageCache()
 561 {
<span class="line-modified"> 562     SetForScope&lt;bool&gt; isSuspendingObservers(m_isSuspendingObservers, true);</span>
<span class="line-modified"> 563     RELEASE_ASSERT(frame());</span>
<span class="line-modified"> 564 </span>
<span class="line-added"> 565     for (auto* observer : copyToVector(m_observers)) {</span>
<span class="line-added"> 566         if (m_observers.contains(observer))</span>
<span class="line-added"> 567             observer-&gt;suspendForPageCache();</span>
 568     }
<span class="line-added"> 569     RELEASE_ASSERT(frame());</span>
 570 
 571     m_suspendedForDocumentSuspension = true;
 572 }
 573 
 574 void DOMWindow::resumeFromPageCache()
 575 {
<span class="line-modified"> 576     for (auto* observer : copyToVector(m_observers)) {</span>
<span class="line-modified"> 577         if (m_observers.contains(observer))</span>
<span class="line-modified"> 578             observer-&gt;resumeFromPageCache();</span>
 579     }
 580 
 581     m_suspendedForDocumentSuspension = false;
 582 }
 583 
























 584 bool DOMWindow::isCurrentlyDisplayedInFrame() const
 585 {
 586     auto* frame = this-&gt;frame();
 587     return frame &amp;&amp; frame-&gt;document()-&gt;domWindow() == this;
 588 }
 589 
 590 CustomElementRegistry&amp; DOMWindow::ensureCustomElementRegistry()
 591 {
 592     if (!m_customElementRegistry)
 593         m_customElementRegistry = CustomElementRegistry::create(*this, scriptExecutionContext());
 594     return *m_customElementRegistry;
 595 }
 596 
 597 static ExceptionOr&lt;SelectorQuery&amp;&gt; selectorQueryInFrame(Frame* frame, const String&amp; selectors)
 598 {
 599     if (!frame)
 600         return Exception { NotSupportedError };
 601 
 602     Document* document = frame-&gt;document();
 603     if (!document)
</pre>
<hr />
<pre>
 659 #endif
 660 
 661 Screen&amp; DOMWindow::screen()
 662 {
 663     if (!m_screen)
 664         m_screen = Screen::create(*this);
 665     return *m_screen;
 666 }
 667 
 668 History&amp; DOMWindow::history()
 669 {
 670     if (!m_history)
 671         m_history = History::create(*this);
 672     return *m_history;
 673 }
 674 
 675 Crypto&amp; DOMWindow::crypto() const
 676 {
 677     if (!m_crypto)
 678         m_crypto = Crypto::create(document());
<span class="line-added"> 679     ASSERT(m_crypto-&gt;scriptExecutionContext() == document());</span>
 680     return *m_crypto;
 681 }
 682 
 683 BarProp&amp; DOMWindow::locationbar()
 684 {
 685     if (!m_locationbar)
 686         m_locationbar = BarProp::create(*this, BarProp::Locationbar);
 687     return *m_locationbar;
 688 }
 689 
 690 BarProp&amp; DOMWindow::menubar()
 691 {
 692     if (!m_menubar)
 693         m_menubar = BarProp::create(*this, BarProp::Menubar);
 694     return *m_menubar;
 695 }
 696 
 697 BarProp&amp; DOMWindow::personalbar()
 698 {
 699     if (!m_personalbar)
</pre>
<hr />
<pre>
 725 PageConsoleClient* DOMWindow::console() const
 726 {
 727     // FIXME: This should not return nullptr when frameless.
 728     if (!isCurrentlyDisplayedInFrame())
 729         return nullptr;
 730     auto* frame = this-&gt;frame();
 731     return frame-&gt;page() ? &amp;frame-&gt;page()-&gt;console() : nullptr;
 732 }
 733 
 734 DOMApplicationCache&amp; DOMWindow::applicationCache()
 735 {
 736     if (!m_applicationCache)
 737         m_applicationCache = DOMApplicationCache::create(*this);
 738     return *m_applicationCache;
 739 }
 740 
 741 Navigator&amp; DOMWindow::navigator()
 742 {
 743     if (!m_navigator)
 744         m_navigator = Navigator::create(scriptExecutionContext(), *this);
<span class="line-added"> 745     ASSERT(m_navigator-&gt;scriptExecutionContext() == document());</span>
 746 
 747     return *m_navigator;
 748 }
 749 
 750 Performance&amp; DOMWindow::performance() const
 751 {
 752     if (!m_performance) {
 753         MonotonicTime timeOrigin = document() &amp;&amp; document()-&gt;loader() ? document()-&gt;loader()-&gt;timing().referenceMonotonicTime() : MonotonicTime::now();
 754         m_performance = Performance::create(document(), timeOrigin);
 755     }
<span class="line-added"> 756     ASSERT(m_performance-&gt;scriptExecutionContext() == document());</span>
 757     return *m_performance;
 758 }
 759 
 760 double DOMWindow::nowTimestamp() const
 761 {
 762     return performance().now() / 1000.;
 763 }
 764 
 765 Location&amp; DOMWindow::location()
 766 {
 767     if (!m_location)
 768         m_location = Location::create(*this);
 769     return *m_location;
 770 }
 771 
 772 VisualViewport&amp; DOMWindow::visualViewport()
 773 {
 774     if (!m_visualViewport)
 775         m_visualViewport = VisualViewport::create(*this);
 776     return *m_visualViewport;
</pre>
<hr />
<pre>
 957 DOMSelection* DOMWindow::getSelection()
 958 {
 959     if (!isCurrentlyDisplayedInFrame())
 960         return nullptr;
 961     if (!m_selection)
 962         m_selection = DOMSelection::create(*this);
 963     return m_selection.get();
 964 }
 965 
 966 Element* DOMWindow::frameElement() const
 967 {
 968     auto* frame = this-&gt;frame();
 969     if (!frame)
 970         return nullptr;
 971 
 972     return frame-&gt;ownerElement();
 973 }
 974 
 975 void DOMWindow::focus(DOMWindow&amp; incumbentWindow)
 976 {
<span class="line-modified"> 977     auto* frame = this-&gt;frame();</span>
<span class="line-modified"> 978     auto* openerFrame = frame ? frame-&gt;loader().opener() : nullptr;</span>
<span class="line-added"> 979     focus(openerFrame &amp;&amp; openerFrame != frame &amp;&amp; incumbentWindow.frame() == openerFrame);</span>
 980 }
 981 
 982 void DOMWindow::focus(bool allowFocus)
 983 {
 984     if (!frame())
 985         return;
 986 
 987     Page* page = frame()-&gt;page();
 988     if (!page)
 989         return;
 990 
 991     allowFocus = allowFocus || WindowFocusAllowedIndicator::windowFocusAllowed() || !frame()-&gt;settings().windowFocusRestricted();
 992 
 993     // If we&#39;re a top level window, bring the window to the front.
 994     if (frame()-&gt;isMainFrame() &amp;&amp; allowFocus)
 995         page-&gt;chrome().focus();
 996 
 997     if (!frame())
 998         return;
 999 
<span class="line-added">1000     if (!frame()-&gt;hasHadUserInteraction() &amp;&amp; !isSameSecurityOriginAsMainFrame())</span>
<span class="line-added">1001         return;</span>
<span class="line-added">1002 </span>
1003     // Clear the current frame&#39;s focused node if a new frame is about to be focused.
1004     Frame* focusedFrame = page-&gt;focusController().focusedFrame();
1005     if (focusedFrame &amp;&amp; focusedFrame != frame())
1006         focusedFrame-&gt;document()-&gt;setFocusedElement(nullptr);
1007 
1008     // setFocusedElement may clear frame(), so recheck before using it.
1009     if (auto* frame = this-&gt;frame())
1010         frame-&gt;eventHandler().focusDocumentView();
1011 }
1012 
1013 void DOMWindow::blur()
1014 {
1015     auto* frame = this-&gt;frame();
1016     if (!frame)
1017         return;
1018 
1019     Page* page = frame-&gt;page();
1020     if (!page)
1021         return;
1022 
</pre>
<hr />
<pre>
1241     return view-&gt;frameRect().width();
1242 #else
1243     auto* frame = this-&gt;frame();
1244     if (!frame)
1245         return 0;
1246 
1247     Page* page = frame-&gt;page();
1248     if (!page)
1249         return 0;
1250 
1251     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().width());
1252 #endif
1253 }
1254 
1255 int DOMWindow::innerHeight() const
1256 {
1257     if (!frame())
1258         return 0;
1259 
1260     // Force enough layout in the parent document to ensure that the FrameView has been resized.
<span class="line-modified">1261     if (auto ownerElement = makeRefPtr(frameElement()))</span>
<span class="line-modified">1262         ownerElement-&gt;document().updateLayoutIfDimensionsOutOfDate(*ownerElement, HeightDimensionsCheck);</span>
1263 
<span class="line-modified">1264     auto frame = makeRefPtr(this-&gt;frame());</span>
1265     if (!frame)
1266         return 0;
1267 
<span class="line-modified">1268     auto view = makeRefPtr(frame-&gt;view());</span>
1269     if (!view)
1270         return 0;
1271 
1272     return view-&gt;mapFromLayoutToCSSUnits(static_cast&lt;int&gt;(view-&gt;unobscuredContentRectIncludingScrollbars().height()));
1273 }
1274 
1275 int DOMWindow::innerWidth() const
1276 {
1277     if (!frame())
1278         return 0;
1279 
1280     // Force enough layout in the parent document to ensure that the FrameView has been resized.
<span class="line-modified">1281     if (auto ownerElement = makeRefPtr(frameElement()))</span>
<span class="line-modified">1282         ownerElement-&gt;document().updateLayoutIfDimensionsOutOfDate(*ownerElement, WidthDimensionsCheck);</span>
1283 
<span class="line-modified">1284     auto frame = makeRefPtr(this-&gt;frame());</span>
1285     if (!frame)
1286         return 0;
1287 
<span class="line-modified">1288     auto view = makeRefPtr(frame-&gt;view());</span>
1289     if (!view)
1290         return 0;
1291 
1292     return view-&gt;mapFromLayoutToCSSUnits(static_cast&lt;int&gt;(view-&gt;unobscuredContentRectIncludingScrollbars().width()));
1293 }
1294 
1295 int DOMWindow::screenX() const
1296 {
<span class="line-modified">1297     auto frame = makeRefPtr(this-&gt;frame());</span>
1298     if (!frame)
1299         return 0;
1300 
1301     Page* page = frame-&gt;page();
1302     if (!page)
1303         return 0;
1304 
1305     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().x());
1306 }
1307 
1308 int DOMWindow::screenY() const
1309 {
<span class="line-modified">1310     auto frame = makeRefPtr(this-&gt;frame());</span>
1311     if (!frame)
1312         return 0;
1313 
1314     Page* page = frame-&gt;page();
1315     if (!page)
1316         return 0;
1317 
1318     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().y());
1319 }
1320 
1321 int DOMWindow::scrollX() const
1322 {
<span class="line-modified">1323     auto frame = makeRefPtr(this-&gt;frame());</span>
1324     if (!frame)
1325         return 0;
1326 
<span class="line-modified">1327     auto view = makeRefPtr(frame-&gt;view());</span>
1328     if (!view)
1329         return 0;
1330 
1331     int scrollX = view-&gt;contentsScrollPosition().x();
1332     if (!scrollX)
1333         return 0;
1334 
1335     frame-&gt;document()-&gt;updateLayoutIgnorePendingStylesheets();
1336 
1337     // Layout may have affected the current frame:
<span class="line-modified">1338     auto frameAfterLayout = makeRefPtr(this-&gt;frame());</span>
1339     if (!frameAfterLayout)
1340         return 0;
1341 
<span class="line-modified">1342     auto viewAfterLayout = makeRefPtr(frameAfterLayout-&gt;view());</span>
1343     if (!viewAfterLayout)
1344         return 0;
1345 
1346     return viewAfterLayout-&gt;mapFromLayoutToCSSUnits(viewAfterLayout-&gt;contentsScrollPosition().x());
1347 }
1348 
1349 int DOMWindow::scrollY() const
1350 {
<span class="line-modified">1351     auto frame = makeRefPtr(this-&gt;frame());</span>
1352     if (!frame)
1353         return 0;
1354 
<span class="line-modified">1355     auto view = makeRefPtr(frame-&gt;view());</span>
1356     if (!view)
1357         return 0;
1358 
1359     int scrollY = view-&gt;contentsScrollPosition().y();
1360     if (!scrollY)
1361         return 0;
1362 
1363     frame-&gt;document()-&gt;updateLayoutIgnorePendingStylesheets();
1364 
1365     // Layout may have affected the current frame:
<span class="line-modified">1366     auto frameAfterLayout = makeRefPtr(this-&gt;frame());</span>
1367     if (!frameAfterLayout)
1368         return 0;
1369 
<span class="line-modified">1370     auto viewAfterLayout = makeRefPtr(frameAfterLayout-&gt;view());</span>
1371     if (!viewAfterLayout)
1372         return 0;
1373 
1374     return viewAfterLayout-&gt;mapFromLayoutToCSSUnits(viewAfterLayout-&gt;contentsScrollPosition().y());
1375 }
1376 
1377 bool DOMWindow::closed() const
1378 {
<span class="line-modified">1379     auto* frame = this-&gt;frame();</span>
<span class="line-added">1380     if (!frame)</span>
<span class="line-added">1381         return true;</span>
<span class="line-added">1382 </span>
<span class="line-added">1383     auto* page = frame-&gt;page();</span>
<span class="line-added">1384     return !page || page-&gt;isClosing();</span>
1385 }
1386 
1387 unsigned DOMWindow::length() const
1388 {
1389     if (!isCurrentlyDisplayedInFrame())
1390         return 0;
1391 
1392     return frame()-&gt;tree().scopedChildCount();
1393 }
1394 
1395 String DOMWindow::name() const
1396 {
1397     auto* frame = this-&gt;frame();
1398     if (!frame)
1399         return String();
1400 
1401     return frame-&gt;tree().name();
1402 }
1403 
1404 void DOMWindow::setName(const String&amp; string)
</pre>
<hr />
<pre>
1425     ASSERT(frame-&gt;document()); // Client calls shouldn&#39;t be made when the frame is in inconsistent state.
1426     page-&gt;chrome().setStatusbarText(*frame, m_status);
1427 }
1428 
1429 void DOMWindow::setDefaultStatus(const String&amp; string)
1430 {
1431     m_defaultStatus = string;
1432 
1433     auto* frame = this-&gt;frame();
1434     if (!frame)
1435         return;
1436 
1437     Page* page = frame-&gt;page();
1438     if (!page)
1439         return;
1440 
1441     ASSERT(frame-&gt;document()); // Client calls shouldn&#39;t be made when the frame is in inconsistent state.
1442     page-&gt;chrome().setStatusbarText(*frame, m_defaultStatus);
1443 }
1444 









1445 WindowProxy* DOMWindow::opener() const
1446 {
1447     auto* frame = this-&gt;frame();
1448     if (!frame)
1449         return nullptr;
1450 
1451     auto* openerFrame = frame-&gt;loader().opener();
1452     if (!openerFrame)
1453         return nullptr;
1454 
1455     return &amp;openerFrame-&gt;windowProxy();
1456 }
1457 
1458 void DOMWindow::disownOpener()
1459 {
1460     if (auto* frame = this-&gt;frame())
1461         frame-&gt;loader().setOpener(nullptr);
1462 }
1463 
1464 WindowProxy* DOMWindow::parent() const
</pre>
<hr />
<pre>
1498 }
1499 
1500 StyleMedia&amp; DOMWindow::styleMedia()
1501 {
1502     if (!m_media)
1503         m_media = StyleMedia::create(*this);
1504     return *m_media;
1505 }
1506 
1507 Ref&lt;CSSStyleDeclaration&gt; DOMWindow::getComputedStyle(Element&amp; element, const String&amp; pseudoElt) const
1508 {
1509     return CSSComputedStyleDeclaration::create(element, false, pseudoElt);
1510 }
1511 
1512 RefPtr&lt;CSSRuleList&gt; DOMWindow::getMatchedCSSRules(Element* element, const String&amp; pseudoElement, bool authorOnly) const
1513 {
1514     if (!isCurrentlyDisplayedInFrame())
1515         return nullptr;
1516 
1517     unsigned colonStart = pseudoElement[0] == &#39;:&#39; ? (pseudoElement[1] == &#39;:&#39; ? 2 : 1) : 0;
<span class="line-modified">1518     auto pseudoType = CSSSelector::parsePseudoElementType(StringView { pseudoElement }.substring(colonStart));</span>
1519     if (pseudoType == CSSSelector::PseudoElementUnknown &amp;&amp; !pseudoElement.isEmpty())
1520         return nullptr;
1521 
1522     auto* frame = this-&gt;frame();
1523     frame-&gt;document()-&gt;styleScope().flushPendingUpdate();
1524 
1525     unsigned rulesToInclude = StyleResolver::AuthorCSSRules;
1526     if (!authorOnly)
1527         rulesToInclude |= StyleResolver::UAAndUserCSSRules;
1528 
1529     PseudoId pseudoId = CSSSelector::pseudoId(pseudoType);
1530 
1531     auto matchedRules = frame-&gt;document()-&gt;styleScope().resolver().pseudoStyleRulesForElement(element, pseudoId, rulesToInclude);
1532     if (matchedRules.isEmpty())
1533         return nullptr;
1534 
1535     bool allowCrossOrigin = frame-&gt;settings().crossOriginCheckInGetMatchedCSSRulesDisabled();
1536 
1537     auto ruleList = StaticCSSRuleList::create();
1538     for (auto&amp; rule : matchedRules) {
1539         if (!allowCrossOrigin &amp;&amp; !rule-&gt;hasDocumentSecurityOrigin())
1540             continue;
1541         ruleList-&gt;rules().append(rule-&gt;createCSSOMWrapper());
1542     }
1543 
1544     if (ruleList-&gt;rules().isEmpty())
1545         return nullptr;
1546 
<span class="line-modified">1547     return ruleList;</span>
1548 }
1549 
1550 RefPtr&lt;WebKitPoint&gt; DOMWindow::webkitConvertPointFromNodeToPage(Node* node, const WebKitPoint* p) const
1551 {
1552     if (!node || !p)
1553         return nullptr;
1554 
1555     if (!document())
1556         return nullptr;
1557 
1558     document()-&gt;updateLayoutIgnorePendingStylesheets();
1559 
1560     FloatPoint pagePoint(p-&gt;x(), p-&gt;y());
1561     pagePoint = node-&gt;convertToPage(pagePoint);
1562     return WebKitPoint::create(pagePoint.x(), pagePoint.y());
1563 }
1564 
1565 RefPtr&lt;WebKitPoint&gt; DOMWindow::webkitConvertPointFromPageToNode(Node* node, const WebKitPoint* p) const
1566 {
1567     if (!node || !p)
</pre>
<hr />
<pre>
1706 
1707 ExceptionOr&lt;int&gt; DOMWindow::setTimeout(JSC::ExecState&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
1708 {
1709     auto* context = scriptExecutionContext();
1710     if (!context)
1711         return Exception { InvalidAccessError };
1712 
1713     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
1714     if (action-&gt;type() == ScheduledAction::Type::Code) {
1715         if (!context-&gt;contentSecurityPolicy()-&gt;allowEval(&amp;state))
1716             return 0;
1717     }
1718 
1719     action-&gt;addArguments(WTFMove(arguments));
1720 
1721     return DOMTimer::install(*context, WTFMove(action), Seconds::fromMilliseconds(timeout), true);
1722 }
1723 
1724 void DOMWindow::clearTimeout(int timeoutId)
1725 {

















1726     ScriptExecutionContext* context = scriptExecutionContext();
1727     if (!context)
1728         return;
1729     DOMTimer::removeById(*context, timeoutId);
1730 }
1731 
1732 ExceptionOr&lt;int&gt; DOMWindow::setInterval(JSC::ExecState&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
1733 {
1734     auto* context = scriptExecutionContext();
1735     if (!context)
1736         return Exception { InvalidAccessError };
1737 
1738     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
1739     if (action-&gt;type() == ScheduledAction::Type::Code) {
1740         if (!context-&gt;contentSecurityPolicy()-&gt;allowEval(&amp;state))
1741             return 0;
1742     }
1743 
1744     action-&gt;addArguments(WTFMove(arguments));
1745 
1746     return DOMTimer::install(*context, WTFMove(action), Seconds::fromMilliseconds(timeout), false);
1747 }
1748 
1749 void DOMWindow::clearInterval(int timeoutId)
1750 {
1751     ScriptExecutionContext* context = scriptExecutionContext();
1752     if (!context)
1753         return;
1754     DOMTimer::removeById(*context, timeoutId);
1755 }
1756 
1757 int DOMWindow::requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
1758 {

1759     auto* document = this-&gt;document();
1760     if (!document)
1761         return 0;
1762     return document-&gt;requestAnimationFrame(WTFMove(callback));
1763 }
1764 
1765 int DOMWindow::webkitRequestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
1766 {
<span class="line-modified">1767     static bool firstTime = true;</span>
<span class="line-modified">1768     if (firstTime &amp;&amp; document()) {</span>
<span class="line-modified">1769         document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;webkitRequestAnimationFrame() is deprecated and will be removed. Please use requestAnimationFrame() instead.&quot;_s);</span>
<span class="line-modified">1770         firstTime = false;</span>
<span class="line-modified">1771     }</span>
<span class="line-added">1772     return requestAnimationFrame(WTFMove(callback));</span>
1773 }
1774 
1775 void DOMWindow::cancelAnimationFrame(int id)
1776 {
1777     auto* document = this-&gt;document();
1778     if (!document)
1779         return;
1780     document-&gt;cancelAnimationFrame(id);
1781 }
1782 
1783 void DOMWindow::createImageBitmap(ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
1784 {
1785     auto* document = this-&gt;document();
1786     if (!document) {
1787         promise.reject(InvalidStateError);
1788         return;
1789     }
1790     ImageBitmap::createPromise(*document, WTFMove(source), WTFMove(options), WTFMove(promise));
1791 }
1792 
</pre>
<hr />
<pre>
1818     window.sessionStorage();
1819 }
1820 
1821 bool DOMWindow::isSameSecurityOriginAsMainFrame() const
1822 {
1823     auto* frame = this-&gt;frame();
1824     if (!frame || !frame-&gt;page() || !document())
1825         return false;
1826 
1827     if (frame-&gt;isMainFrame())
1828         return true;
1829 
1830     Document* mainFrameDocument = frame-&gt;mainFrame().document();
1831 
1832     if (mainFrameDocument &amp;&amp; document()-&gt;securityOrigin().canAccess(mainFrameDocument-&gt;securityOrigin()))
1833         return true;
1834 
1835     return false;
1836 }
1837 
<span class="line-modified">1838 bool DOMWindow::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
1839 {
1840     if (!EventTarget::addEventListener(eventType, WTFMove(listener), options))
1841         return false;
1842 
<span class="line-modified">1843     auto* document = this-&gt;document();</span>
<span class="line-added">1844     if (document) {</span>
1845         document-&gt;addListenerTypeIfNeeded(eventType);
1846         if (eventNames().isWheelEventType(eventType))
1847             document-&gt;didAddWheelEventHandler(*document);
<span class="line-modified">1848         else if (eventNames().isTouchRelatedEventType(*document, eventType))</span>
1849             document-&gt;didAddTouchEventHandler(*document);
1850         else if (eventType == eventNames().storageEvent)
1851             didAddStorageEventListener(*this);
1852     }
1853 
1854     if (eventType == eventNames().unloadEvent)
1855         addUnloadEventListener(this);
1856     else if (eventType == eventNames().beforeunloadEvent &amp;&amp; allowsBeforeUnloadListeners(this))
1857         addBeforeUnloadEventListener(this);
1858 #if PLATFORM(IOS_FAMILY)
1859     else if (eventType == eventNames().scrollEvent)
1860         incrementScrollEventListenersCount();
1861 #endif
1862 #if ENABLE(IOS_TOUCH_EVENTS)
<span class="line-modified">1863     else if (document &amp;&amp; eventNames().isTouchRelatedEventType(*document, eventType))</span>
1864         ++m_touchAndGestureEventListenerCount;
1865 #endif
1866 #if ENABLE(IOS_GESTURE_EVENTS)
1867     else if (eventNames().isGestureEventType(eventType))
1868         ++m_touchAndGestureEventListenerCount;
1869 #endif
1870 #if ENABLE(GAMEPAD)
1871     else if (eventNames().isGamepadEventType(eventType))
1872         incrementGamepadEventListenerCount();
1873 #endif
<span class="line-added">1874 #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-added">1875     else if (eventType == eventNames().deviceorientationEvent)</span>
<span class="line-added">1876         startListeningForDeviceOrientationIfNecessary();</span>
<span class="line-added">1877     else if (eventType == eventNames().devicemotionEvent)</span>
<span class="line-added">1878         startListeningForDeviceMotionIfNecessary();</span>
<span class="line-added">1879 #endif</span>
<span class="line-added">1880 </span>
<span class="line-added">1881     return true;</span>
<span class="line-added">1882 }</span>
1883 
1884 #if ENABLE(DEVICE_ORIENTATION)
<span class="line-modified">1885 </span>
<span class="line-added">1886 DeviceOrientationController* DOMWindow::deviceOrientationController() const</span>
<span class="line-added">1887 {</span>
1888 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">1889     return document() ? &amp;document()-&gt;deviceOrientationController() : nullptr;</span>












1890 #else
<span class="line-modified">1891     return DeviceOrientationController::from(page());</span>
<span class="line-modified">1892 #endif</span>
<span class="line-modified">1893 }</span>
<span class="line-modified">1894 </span>
<span class="line-modified">1895 DeviceMotionController* DOMWindow::deviceMotionController() const</span>
<span class="line-modified">1896 {</span>
<span class="line-modified">1897 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">1898     return document() ? &amp;document()-&gt;deviceMotionController() : nullptr;</span>
<span class="line-modified">1899 #else</span>
<span class="line-modified">1900     return DeviceMotionController::from(page());</span>
<span class="line-modified">1901 #endif</span>
<span class="line-modified">1902 }</span>
<span class="line-modified">1903 </span>
<span class="line-modified">1904 bool DOMWindow::isAllowedToUseDeviceMotionOrientation(String&amp; message) const</span>
<span class="line-modified">1905 {</span>
<span class="line-modified">1906     if (!frame() || !frame()-&gt;settings().deviceOrientationEventEnabled()) {</span>
<span class="line-added">1907         message = &quot;API is disabled&quot;_s;</span>
<span class="line-added">1908         return false;</span>
<span class="line-added">1909     }</span>
<span class="line-added">1910 </span>
<span class="line-added">1911     if (!isSecureContext()) {</span>
<span class="line-added">1912         message = &quot;Browsing context is not secure&quot;_s;</span>
<span class="line-added">1913         return false;</span>
<span class="line-added">1914     }</span>
<span class="line-added">1915 </span>
<span class="line-added">1916     if (!isSameSecurityOriginAsMainFrame()) {</span>
<span class="line-added">1917         message = &quot;Source frame did not have the same security origin as the main page&quot;_s;</span>
<span class="line-added">1918         return false;</span>
<span class="line-added">1919     }</span>
<span class="line-added">1920     return true;</span>
<span class="line-added">1921 }</span>
<span class="line-added">1922 </span>
<span class="line-added">1923 bool DOMWindow::isAllowedToAddDeviceMotionOrientationListener(String&amp; message) const</span>
<span class="line-added">1924 {</span>
<span class="line-added">1925     String innerMessage;</span>
<span class="line-added">1926     if (!isAllowedToUseDeviceMotionOrientation(innerMessage)) {</span>
<span class="line-added">1927         message = makeString(&quot;Blocked attempt to add a device motion or orientation event listener, reason: &quot;, innerMessage, &quot;.&quot;);</span>
<span class="line-added">1928         return false;</span>
<span class="line-added">1929     }</span>
<span class="line-added">1930 </span>
<span class="line-added">1931     if (frame()-&gt;settings().deviceOrientationPermissionAPIEnabled()) {</span>
<span class="line-added">1932         auto accessState = document()-&gt;deviceOrientationAndMotionAccessController().accessState();</span>
<span class="line-added">1933         switch (accessState) {</span>
<span class="line-added">1934         case DeviceOrientationOrMotionPermissionState::Denied:</span>
<span class="line-added">1935             message = &quot;No device motion or orientation events will be fired because permission to use the API was denied.&quot;_s;</span>
<span class="line-added">1936             return false;</span>
<span class="line-added">1937         case DeviceOrientationOrMotionPermissionState::Prompt:</span>
<span class="line-added">1938             message = &quot;No device motion or orientation events will be fired until permission has been requested and granted.&quot;_s;</span>
<span class="line-added">1939             return false;</span>
<span class="line-added">1940         case DeviceOrientationOrMotionPermissionState::Granted:</span>
<span class="line-added">1941             break;</span>
1942         }

1943     }

1944 
1945     return true;
1946 }
1947 
<span class="line-added">1948 void DOMWindow::startListeningForDeviceOrientationIfNecessary()</span>
<span class="line-added">1949 {</span>
<span class="line-added">1950     if (!hasEventListeners(eventNames().deviceorientationEvent))</span>
<span class="line-added">1951         return;</span>
<span class="line-added">1952 </span>
<span class="line-added">1953     auto* deviceController = deviceOrientationController();</span>
<span class="line-added">1954     if (!deviceController || deviceController-&gt;hasDeviceEventListener(*this))</span>
<span class="line-added">1955         return;</span>
<span class="line-added">1956 </span>
<span class="line-added">1957     String errorMessage;</span>
<span class="line-added">1958     if (!isAllowedToAddDeviceMotionOrientationListener(errorMessage)) {</span>
<span class="line-added">1959         if (auto* document = this-&gt;document())</span>
<span class="line-added">1960             document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, errorMessage);</span>
<span class="line-added">1961         return;</span>
<span class="line-added">1962     }</span>
<span class="line-added">1963 </span>
<span class="line-added">1964     deviceController-&gt;addDeviceEventListener(*this);</span>
<span class="line-added">1965 }</span>
<span class="line-added">1966 </span>
<span class="line-added">1967 void DOMWindow::stopListeningForDeviceOrientationIfNecessary()</span>
<span class="line-added">1968 {</span>
<span class="line-added">1969     if (hasEventListeners(eventNames().deviceorientationEvent))</span>
<span class="line-added">1970         return;</span>
<span class="line-added">1971 </span>
<span class="line-added">1972     if (auto* deviceController = deviceOrientationController())</span>
<span class="line-added">1973         deviceController-&gt;removeDeviceEventListener(*this);</span>
<span class="line-added">1974 }</span>
<span class="line-added">1975 </span>
<span class="line-added">1976 void DOMWindow::startListeningForDeviceMotionIfNecessary()</span>
<span class="line-added">1977 {</span>
<span class="line-added">1978     if (!hasEventListeners(eventNames().devicemotionEvent))</span>
<span class="line-added">1979         return;</span>
<span class="line-added">1980 </span>
<span class="line-added">1981     auto* deviceController = deviceMotionController();</span>
<span class="line-added">1982     if (!deviceController || deviceController-&gt;hasDeviceEventListener(*this))</span>
<span class="line-added">1983         return;</span>
<span class="line-added">1984 </span>
<span class="line-added">1985     String errorMessage;</span>
<span class="line-added">1986     if (!isAllowedToAddDeviceMotionOrientationListener(errorMessage)) {</span>
<span class="line-added">1987         failedToRegisterDeviceMotionEventListener();</span>
<span class="line-added">1988         if (auto* document = this-&gt;document())</span>
<span class="line-added">1989             document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, errorMessage);</span>
<span class="line-added">1990         return;</span>
<span class="line-added">1991     }</span>
<span class="line-added">1992 </span>
<span class="line-added">1993     deviceController-&gt;addDeviceEventListener(*this);</span>
<span class="line-added">1994 }</span>
<span class="line-added">1995 </span>
<span class="line-added">1996 void DOMWindow::stopListeningForDeviceMotionIfNecessary()</span>
<span class="line-added">1997 {</span>
<span class="line-added">1998     if (hasEventListeners(eventNames().devicemotionEvent))</span>
<span class="line-added">1999         return;</span>
<span class="line-added">2000 </span>
<span class="line-added">2001     if (auto* deviceController = deviceMotionController())</span>
<span class="line-added">2002         deviceController-&gt;removeDeviceEventListener(*this);</span>
<span class="line-added">2003 }</span>
<span class="line-added">2004 </span>
<span class="line-added">2005 void DOMWindow::failedToRegisterDeviceMotionEventListener()</span>
<span class="line-added">2006 {</span>
<span class="line-added">2007 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">2008     if (!isSameSecurityOriginAsMainFrame() || !isSecureContext())</span>
<span class="line-added">2009         return;</span>
<span class="line-added">2010 </span>
<span class="line-added">2011     // FIXME: This is a quirk for chase.com on iPad (&lt;rdar://problem/48423023&gt;).</span>
<span class="line-added">2012     if (RegistrableDomain::uncheckedCreateFromRegistrableDomainString(&quot;chase.com&quot;_s).matches(document()-&gt;url())) {</span>
<span class="line-added">2013         // Fire a fake DeviceMotionEvent with acceleration data to unblock the site&#39;s login flow.</span>
<span class="line-added">2014         document()-&gt;postTask([](auto&amp; context) {</span>
<span class="line-added">2015             if (auto* window = downcast&lt;Document&gt;(context).domWindow()) {</span>
<span class="line-added">2016                 auto acceleration = DeviceMotionData::Acceleration::create();</span>
<span class="line-added">2017                 window-&gt;dispatchEvent(DeviceMotionEvent::create(eventNames().devicemotionEvent, DeviceMotionData::create(acceleration.copyRef(), acceleration.copyRef(), DeviceMotionData::RotationRate::create(), WTF::nullopt).ptr()));</span>
<span class="line-added">2018             }</span>
<span class="line-added">2019         });</span>
<span class="line-added">2020     }</span>
<span class="line-added">2021 #endif // PLATFORM(IOS_FAMILY)</span>
<span class="line-added">2022 }</span>
<span class="line-added">2023 </span>
<span class="line-added">2024 #endif // ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-added">2025 </span>
2026 #if PLATFORM(IOS_FAMILY)
2027 
2028 void DOMWindow::incrementScrollEventListenersCount()
2029 {
2030     Document* document = this-&gt;document();
2031     if (++m_scrollEventListenerCount == 1 &amp;&amp; document == &amp;document-&gt;topDocument()) {
2032         Frame* frame = this-&gt;frame();
2033         if (frame &amp;&amp; frame-&gt;page())
2034             frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, true);
2035     }
2036 }
2037 
2038 void DOMWindow::decrementScrollEventListenersCount()
2039 {
2040     Document* document = this-&gt;document();
2041     if (!--m_scrollEventListenerCount &amp;&amp; document == &amp;document-&gt;topDocument()) {
2042         Frame* frame = this-&gt;frame();
2043         if (frame &amp;&amp; frame-&gt;page() &amp;&amp; document-&gt;pageCacheState() == Document::NotInPageCache)
2044             frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, false);
2045     }
2046 }
2047 
2048 #endif
2049 
2050 void DOMWindow::resetAllGeolocationPermission()
2051 {
2052     // FIXME: Can we remove the PLATFORM(IOS_FAMILY)-guard?
2053 #if ENABLE(GEOLOCATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2054     if (m_navigator)
<span class="line-modified">2055         NavigatorGeolocation::from(*m_navigator)-&gt;resetAllGeolocationPermission();</span>
2056 #endif
2057 }
2058 
<span class="line-modified">2059 bool DOMWindow::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
2060 {
2061     if (!EventTarget::removeEventListener(eventType, listener, options.capture))
2062         return false;
2063 
<span class="line-modified">2064     auto* document = this-&gt;document();</span>
<span class="line-added">2065     if (document) {</span>
2066         if (eventNames().isWheelEventType(eventType))
2067             document-&gt;didRemoveWheelEventHandler(*document);
<span class="line-modified">2068         else if (eventNames().isTouchRelatedEventType(*document, eventType))</span>
2069             document-&gt;didRemoveTouchEventHandler(*document);
2070     }
2071 
2072     if (eventType == eventNames().unloadEvent)
2073         removeUnloadEventListener(this);
2074     else if (eventType == eventNames().beforeunloadEvent &amp;&amp; allowsBeforeUnloadListeners(this))
2075         removeBeforeUnloadEventListener(this);
















2076 #if PLATFORM(IOS_FAMILY)
2077     else if (eventType == eventNames().scrollEvent)
2078         decrementScrollEventListenersCount();
2079 #endif
2080 #if ENABLE(IOS_TOUCH_EVENTS)
<span class="line-modified">2081     else if (document &amp;&amp; eventNames().isTouchRelatedEventType(*document, eventType)) {</span>
2082         ASSERT(m_touchAndGestureEventListenerCount &gt; 0);
2083         --m_touchAndGestureEventListenerCount;
2084     }
2085 #endif
2086 #if ENABLE(IOS_GESTURE_EVENTS)
2087     else if (eventNames().isGestureEventType(eventType)) {
2088         ASSERT(m_touchAndGestureEventListenerCount &gt; 0);
2089         --m_touchAndGestureEventListenerCount;
2090     }
2091 #endif
2092 #if ENABLE(GAMEPAD)
2093     else if (eventNames().isGamepadEventType(eventType))
2094         decrementGamepadEventListenerCount();
2095 #endif
<span class="line-added">2096 #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-added">2097     else if (eventType == eventNames().deviceorientationEvent)</span>
<span class="line-added">2098         stopListeningForDeviceOrientationIfNecessary();</span>
<span class="line-added">2099     else if (eventType == eventNames().devicemotionEvent)</span>
<span class="line-added">2100         stopListeningForDeviceMotionIfNecessary();</span>
<span class="line-added">2101 #endif</span>
2102 
2103     return true;
2104 }
2105 
2106 void DOMWindow::languagesChanged()
2107 {
2108     if (auto* document = this-&gt;document())
2109         document-&gt;enqueueWindowEvent(Event::create(eventNames().languagechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
2110 }
2111 
2112 void DOMWindow::dispatchLoadEvent()
2113 {
2114     // If we did not protect it, the document loader and its timing subobject might get destroyed
2115     // as a side effect of what event handling code does.
2116     auto protectedThis = makeRef(*this);
2117     auto protectedLoader = makeRefPtr(frame() ? frame()-&gt;loader().documentLoader() : nullptr);
2118     bool shouldMarkLoadEventTimes = protectedLoader &amp;&amp; !protectedLoader-&gt;timing().loadEventStart();
2119 
2120     if (shouldMarkLoadEventTimes)
2121         protectedLoader-&gt;timing().markLoadEventStart();
</pre>
<hr />
<pre>
2155                 return; // Event was previously dispatched; do not fire a duplicate event.
2156             m_lastPageStatus = PageStatus::Shown;
2157         } else if (event.type() == eventNames().pagehideEvent) {
2158             if (m_lastPageStatus == PageStatus::Hidden)
2159                 return; // Event was previously dispatched; do not fire a duplicate event.
2160             m_lastPageStatus = PageStatus::Hidden;
2161         }
2162     }
2163 
2164     // FIXME: It doesn&#39;t seem right to have the inspector instrumentation here since not all
2165     // events dispatched to the window object are guaranteed to flow through this function.
2166     // But the instrumentation prevents us from calling EventDispatcher::dispatchEvent here.
2167     event.setTarget(target ? target : this);
2168     event.setCurrentTarget(this);
2169     event.setEventPhase(Event::AT_TARGET);
2170     event.resetBeforeDispatch();
2171     auto cookie = InspectorInstrumentation::willDispatchEventOnWindow(frame(), event, *this);
2172     // FIXME: We should use EventDispatcher everywhere.
2173     fireEventListeners(event, EventInvokePhase::Capturing);
2174     fireEventListeners(event, EventInvokePhase::Bubbling);
<span class="line-modified">2175     InspectorInstrumentation::didDispatchEventOnWindow(cookie, event.defaultPrevented());</span>
2176     event.resetAfterDispatch();
2177 }
2178 
2179 void DOMWindow::removeAllEventListeners()
2180 {
2181     EventTarget::removeAllEventListeners();
2182 
2183 #if ENABLE(DEVICE_ORIENTATION)
<span class="line-modified">2184         stopListeningForDeviceOrientationIfNecessary();</span>
<span class="line-modified">2185         stopListeningForDeviceMotionIfNecessary();</span>
<span class="line-modified">2186 #endif</span>









2187 
2188 #if PLATFORM(IOS_FAMILY)
2189     if (m_scrollEventListenerCount) {
2190         m_scrollEventListenerCount = 1;
2191         decrementScrollEventListenersCount();
2192     }
2193 #endif
2194 
2195 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS)
2196     m_touchAndGestureEventListenerCount = 0;
2197 #endif
2198 
2199 #if ENABLE(TOUCH_EVENTS)
2200     if (Document* document = this-&gt;document())
2201         document-&gt;didRemoveEventTargetNode(*document);
2202 #endif
2203 
2204     if (m_performance) {
2205         m_performance-&gt;removeAllEventListeners();
2206         m_performance-&gt;removeAllObservers();
</pre>
<hr />
<pre>
2321 
2322     // If this DOMWindow isn&#39;t currently active in the Frame, then there&#39;s no
2323     // way we should allow the access.
2324     // FIXME: Remove this check if we&#39;re able to disconnect DOMWindow from
2325     // Frame on navigation: https://bugs.webkit.org/show_bug.cgi?id=62054
2326     if (isCurrentlyDisplayedInFrame()) {
2327         // FIXME: Is there some way to eliminate the need for a separate &quot;activeWindow == this&quot; check?
2328         if (&amp;activeWindow == this)
2329             return false;
2330 
2331         // FIXME: The name canAccess seems to be a roundabout way to ask &quot;can execute script&quot;.
2332         // Can we name the SecurityOrigin function better to make this more clear?
2333         if (activeWindow.document()-&gt;securityOrigin().canAccess(document()-&gt;securityOrigin()))
2334             return false;
2335     }
2336 
2337     printErrorMessage(crossDomainAccessErrorMessage(activeWindow, IncludeTargetOrigin::Yes));
2338     return true;
2339 }
2340 
<span class="line-modified">2341 ExceptionOr&lt;RefPtr&lt;Frame&gt;&gt; DOMWindow::createWindow(const String&amp; urlString, const AtomString&amp; frameName, const WindowFeatures&amp; windowFeatures, DOMWindow&amp; activeWindow, Frame&amp; firstFrame, Frame&amp; openerFrame, const WTF::Function&lt;void(DOMWindow&amp;)&gt;&amp; prepareDialogFunction)</span>
2342 {
2343     Frame* activeFrame = activeWindow.frame();
2344     if (!activeFrame)
2345         return RefPtr&lt;Frame&gt; { nullptr };
2346 
2347     Document* activeDocument = activeWindow.document();
2348     if (!activeDocument)
2349         return RefPtr&lt;Frame&gt; { nullptr };
2350 
2351     URL completedURL = urlString.isEmpty() ? URL({ }, emptyString()) : firstFrame.document()-&gt;completeURL(urlString);
2352     if (!completedURL.isEmpty() &amp;&amp; !completedURL.isValid())
2353         return Exception { SyntaxError };
2354 
2355     // For whatever reason, Firefox uses the first frame to determine the outgoingReferrer. We replicate that behavior here.
<span class="line-modified">2356     String referrer = windowFeatures.noreferrer ? String() : SecurityPolicy::generateReferrerHeader(firstFrame.document()-&gt;referrerPolicy(), completedURL, firstFrame.loader().outgoingReferrer());</span>
2357     auto initiatedByMainFrame = activeFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
2358 
2359     ResourceRequest resourceRequest { completedURL, referrer };
2360     FrameLoader::addHTTPOriginIfNeeded(resourceRequest, firstFrame.loader().outgoingOrigin());
2361     FrameLoadRequest frameLoadRequest { *activeDocument, activeDocument-&gt;securityOrigin(), resourceRequest, frameName, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, activeDocument-&gt;shouldOpenExternalURLsPolicyToPropagate(), initiatedByMainFrame };
2362 
2363     // We pass the opener frame for the lookupFrame in case the active frame is different from
2364     // the opener frame, and the name references a frame relative to the opener frame.
2365     bool created;
2366     auto newFrame = WebCore::createWindow(*activeFrame, openerFrame, WTFMove(frameLoadRequest), windowFeatures, created);
2367     if (!newFrame)
2368         return RefPtr&lt;Frame&gt; { nullptr };
2369 
<span class="line-modified">2370     bool noopener = windowFeatures.noopener || windowFeatures.noreferrer;</span>
<span class="line-added">2371     if (!noopener)</span>
2372         newFrame-&gt;loader().setOpener(&amp;openerFrame);
2373 
2374     if (created)
2375         newFrame-&gt;page()-&gt;setOpenedByDOM();
2376 
2377     if (newFrame-&gt;document()-&gt;domWindow()-&gt;isInsecureScriptAccess(activeWindow, completedURL))
<span class="line-modified">2378         return noopener ? RefPtr&lt;Frame&gt; { nullptr } : newFrame;</span>
2379 
2380     if (prepareDialogFunction)
2381         prepareDialogFunction(*newFrame-&gt;document()-&gt;domWindow());
2382 
2383     if (created) {
2384         ResourceRequest resourceRequest { completedURL, referrer, ResourceRequestCachePolicy::UseProtocolCachePolicy };
2385         FrameLoader::addSameSiteInfoToRequestIfNeeded(resourceRequest, openerFrame.document());
2386         FrameLoadRequest frameLoadRequest { *activeWindow.document(), activeWindow.document()-&gt;securityOrigin(), resourceRequest, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, activeDocument-&gt;shouldOpenExternalURLsPolicyToPropagate(), initiatedByMainFrame };
2387         newFrame-&gt;loader().changeLocation(WTFMove(frameLoadRequest));
2388     } else if (!urlString.isEmpty()) {
2389         LockHistory lockHistory = UserGestureIndicator::processingUserGesture() ? LockHistory::No : LockHistory::Yes;
2390         newFrame-&gt;navigationScheduler().scheduleLocationChange(*activeDocument, activeDocument-&gt;securityOrigin(), completedURL, referrer, lockHistory, LockBackForwardList::No);
2391     }
2392 
2393     // Navigating the new frame could result in it being detached from its page by a navigation policy delegate.
2394     if (!newFrame-&gt;page())
2395         return RefPtr&lt;Frame&gt; { nullptr };
2396 
<span class="line-modified">2397     return noopener ? RefPtr&lt;Frame&gt; { nullptr } : newFrame;</span>
2398 }
2399 
<span class="line-modified">2400 ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; DOMWindow::open(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; urlStringToOpen, const AtomString&amp; frameName, const String&amp; windowFeaturesString)</span>
2401 {
2402     if (!isCurrentlyDisplayedInFrame())
2403         return RefPtr&lt;WindowProxy&gt; { nullptr };
2404 
2405     auto* activeDocument = activeWindow.document();
2406     if (!activeDocument)
2407         return RefPtr&lt;WindowProxy&gt; { nullptr };
2408 
2409     auto* firstFrame = firstWindow.frame();
2410     if (!firstFrame)
2411         return RefPtr&lt;WindowProxy&gt; { nullptr };
2412 
<span class="line-added">2413     auto urlString = urlStringToOpen;</span>
<span class="line-added">2414     if (activeDocument-&gt;quirks().shouldOpenAsAboutBlank(urlStringToOpen))</span>
<span class="line-added">2415         urlString = &quot;about:blank&quot;_s;</span>
<span class="line-added">2416 </span>
2417 #if ENABLE(CONTENT_EXTENSIONS)
2418     if (firstFrame-&gt;document()
2419         &amp;&amp; firstFrame-&gt;page()
2420         &amp;&amp; firstFrame-&gt;mainFrame().document()
2421         &amp;&amp; firstFrame-&gt;mainFrame().document()-&gt;loader()) {
<span class="line-modified">2422         auto results = firstFrame-&gt;page()-&gt;userContentProvider().processContentRuleListsForLoad(firstFrame-&gt;document()-&gt;completeURL(urlString), ContentExtensions::ResourceType::Popup, *firstFrame-&gt;mainFrame().document()-&gt;loader());</span>
<span class="line-modified">2423         if (results.summary.blockedLoad)</span>
<span class="line-modified">2424             return RefPtr&lt;WindowProxy&gt; { nullptr };</span>


2425     }
2426 #endif
2427 
2428     auto* frame = this-&gt;frame();
2429     if (!firstWindow.allowPopUp()) {
2430         // Because FrameTree::findFrameForNavigation() returns true for empty strings, we must check for empty frame names.
2431         // Otherwise, illegitimate window.open() calls with no name will pass right through the popup blocker.
2432         if (frameName.isEmpty() || !frame-&gt;loader().findFrameForNavigation(frameName, activeDocument))
2433             return RefPtr&lt;WindowProxy&gt; { nullptr };
2434     }
2435 
2436     // Get the target frame for the special cases of _top and _parent.
2437     // In those cases, we schedule a location change right now and return early.
2438     Frame* targetFrame = nullptr;
2439     if (equalIgnoringASCIICase(frameName, &quot;_top&quot;))
2440         targetFrame = &amp;frame-&gt;tree().top();
2441     else if (equalIgnoringASCIICase(frameName, &quot;_parent&quot;)) {
2442         if (Frame* parent = frame-&gt;tree().parent())
2443             targetFrame = parent;
2444         else
</pre>
</td>
</tr>
</table>
<center><a href="DOMTimer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DOMWindow.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>