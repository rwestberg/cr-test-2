<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/Modules/encryptedmedia/MediaKeySession.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Metrological Group B.V.
  3  * Copyright (C) 2016 Igalia S.L.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above
 12  *    copyright notice, this list of conditions and the following
 13  *    disclaimer in the documentation and/or other materials provided
 14  *    with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 17  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;MediaKeySession.h&quot;
 31 
 32 #if ENABLE(ENCRYPTED_MEDIA)
 33 
 34 #include &quot;CDM.h&quot;
 35 #include &quot;CDMInstance.h&quot;
 36 #include &quot;Document.h&quot;
 37 #include &quot;EventNames.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &quot;MediaKeyMessageEvent.h&quot;
 40 #include &quot;MediaKeyMessageType.h&quot;
 41 #include &quot;MediaKeyStatusMap.h&quot;
 42 #include &quot;MediaKeys.h&quot;
 43 #include &quot;NotImplemented.h&quot;
 44 #include &quot;Page.h&quot;
 45 #include &quot;SecurityOrigin.h&quot;
 46 #include &quot;SecurityOriginData.h&quot;
 47 #include &quot;Settings.h&quot;
 48 #include &quot;SharedBuffer.h&quot;
 49 
 50 namespace WebCore {
 51 
 52 Ref&lt;MediaKeySession&gt; MediaKeySession::create(ScriptExecutionContext&amp; context, WeakPtr&lt;MediaKeys&gt;&amp;&amp; keys, MediaKeySessionType sessionType, bool useDistinctiveIdentifier, Ref&lt;CDM&gt;&amp;&amp; implementation, Ref&lt;CDMInstanceSession&gt;&amp;&amp; instanceSession)
 53 {
 54     auto session = adoptRef(*new MediaKeySession(context, WTFMove(keys), sessionType, useDistinctiveIdentifier, WTFMove(implementation), WTFMove(instanceSession)));
 55     session-&gt;suspendIfNeeded();
 56     return session;
 57 }
 58 
 59 MediaKeySession::MediaKeySession(ScriptExecutionContext&amp; context, WeakPtr&lt;MediaKeys&gt;&amp;&amp; keys, MediaKeySessionType sessionType, bool useDistinctiveIdentifier, Ref&lt;CDM&gt;&amp;&amp; implementation, Ref&lt;CDMInstanceSession&gt;&amp;&amp; instanceSession)
 60     : ActiveDOMObject(&amp;context)
 61     , m_keys(WTFMove(keys))
 62     , m_expiration(std::numeric_limits&lt;double&gt;::quiet_NaN())
 63     , m_keyStatuses(MediaKeyStatusMap::create(*this))
 64     , m_useDistinctiveIdentifier(useDistinctiveIdentifier)
 65     , m_sessionType(sessionType)
 66     , m_implementation(WTFMove(implementation))
 67     , m_instanceSession(WTFMove(instanceSession))
 68     , m_eventQueue(*this)
 69 {
 70     // https://w3c.github.io/encrypted-media/#dom-mediakeys-createsession
 71     // W3C Editor&#39;s Draft 09 November 2016
 72     // createSession(), ctd.
 73 
 74     LOG(EME, &quot;EME - new session created&quot;);
 75 
 76     // 3.1. Let the sessionId attribute be the empty string.
 77     // 3.2. Let the expiration attribute be NaN.
 78     // 3.3. Let the closed attribute be a new promise.
 79     // 3.4. Let key status be a new empty MediaKeyStatusMap object, and initialize it as follows:
 80     // 3.4.1. Let the size attribute be 0.
 81     // 3.5. Let the session type value be sessionType.
 82     // 3.6. Let the uninitialized value be true.
 83     // 3.7. Let the callable value be false.
 84     // 3.8. Let the use distinctive identifier value be this object&#39;s use distinctive identifier value.
 85     // 3.9. Let the cdm implementation value be this object&#39;s cdm implementation.
 86     // 3.10. Let the cdm instance value be this object&#39;s cdm instance.
 87 
 88     UNUSED_PARAM(m_callable);
 89     UNUSED_PARAM(m_sessionType);
 90     UNUSED_PARAM(m_useDistinctiveIdentifier);
 91     UNUSED_PARAM(m_closed);
 92     UNUSED_PARAM(m_uninitialized);
 93 
 94     m_instanceSession-&gt;setClient(m_cdmInstanceSessionClientWeakPtrFactory.createWeakPtr(*this));
 95 }
 96 
 97 MediaKeySession::~MediaKeySession()
 98 {
 99     m_keyStatuses-&gt;detachSession();
100     m_instanceSession-&gt;clearClient();
101 }
102 
103 const String&amp; MediaKeySession::sessionId() const
104 {
105     return m_sessionId;
106 }
107 
108 double MediaKeySession::expiration() const
109 {
110     return m_expiration;
111 }
112 
113 Ref&lt;MediaKeyStatusMap&gt; MediaKeySession::keyStatuses() const
114 {
115     return m_keyStatuses.copyRef();
116 }
117 
118 void MediaKeySession::generateRequest(const AtomicString&amp; initDataType, const BufferSource&amp; initData, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
119 {
120     // https://w3c.github.io/encrypted-media/#dom-mediakeysession-generaterequest
121     // W3C Editor&#39;s Draft 09 November 2016
122 
123     // When this method is invoked, the user agent must run the following steps:
124     // 1. If this object is closed, return a promise rejected with an InvalidStateError.
125     // 2. If this object&#39;s uninitialized value is false, return a promise rejected with an InvalidStateError.
126     LOG(EME, &quot;EME - generate request&quot;);
127 
128     if (m_closed || !m_uninitialized) {
129         promise-&gt;reject(InvalidStateError);
130         return;
131     }
132 
133     // 3. Let this object&#39;s uninitialized value be false.
134     m_uninitialized = false;
135 
136     // 4. If initDataType is the empty string, return a promise rejected with a newly created TypeError.
137     // 5. If initData is an empty array, return a promise rejected with a newly created TypeError.
138     if (initDataType.isEmpty() || !initData.length()) {
139         promise-&gt;reject(TypeError);
140         return;
141     }
142 
143     // 6. If the Key System implementation represented by this object&#39;s cdm implementation value does not support
144     //    initDataType as an Initialization Data Type, return a promise rejected with a NotSupportedError. String
145     //    comparison is case-sensitive.
146     if (!m_implementation-&gt;supportsInitDataType(initDataType)) {
147         promise-&gt;reject(NotSupportedError);
148         return;
149     }
150 
151     // 7. Let init data be a copy of the contents of the initData parameter.
152     // 8. Let session type be this object&#39;s session type.
153     // 9. Let promise be a new promise.
154     // 10. Run the following steps in parallel:
155     m_taskQueue.enqueueTask([this, initData = SharedBuffer::create(initData.data(), initData.length()), initDataType, promise = WTFMove(promise)] () mutable {
156         // 10.1. If the init data is not valid for initDataType, reject promise with a newly created TypeError.
157         // 10.2. Let sanitized init data be a validated and sanitized version of init data.
158         RefPtr&lt;SharedBuffer&gt; sanitizedInitData = m_implementation-&gt;sanitizeInitData(initDataType, initData);
159 
160         // 10.3. If the preceding step failed, reject promise with a newly created TypeError.
161         if (!sanitizedInitData) {
162             promise-&gt;reject(TypeError);
163             return;
164         }
165 
166         // 10.4. If sanitized init data is empty, reject promise with a NotSupportedError.
167         if (sanitizedInitData-&gt;isEmpty()) {
168             promise-&gt;reject(NotSupportedError);
169             return;
170         }
171 
172         // 10.5. Let session id be the empty string.
173         // 10.6. Let message be null.
174         // 10.7. Let message type be null.
175         // 10.8. Let cdm be the CDM instance represented by this object&#39;s cdm instance value.
176         // 10.9. Use the cdm to execute the following steps:
177         // 10.9.1. If the sanitized init data is not supported by the cdm, reject promise with a NotSupportedError.
178         if (!m_implementation-&gt;supportsInitData(initDataType, *sanitizedInitData)) {
179             promise-&gt;reject(NotSupportedError);
180             return;
181         }
182 
183         // 10.9.2 Follow the steps for the value of session type from the following list:
184         //   ↳ &quot;temporary&quot;
185         //     Let requested license type be a temporary non-persistable license.
186         //   ↳ &quot;persistent-license&quot;
187         //     Let requested license type be a persistable license.
188         //   ↳ &quot;persistent-usage-record&quot;
189         //     1. Initialize this object&#39;s record of key usage as follows.
190         //        Set the list of key IDs known to the session to an empty list.
191         //        Set the first decrypt time to null.
192         //        Set the latest decrypt time to null.
193         //     2. Let requested license type be a non-persistable license that will
194         //        persist a record of key usage.
195 
196         if (m_sessionType == MediaKeySessionType::PersistentUsageRecord) {
197             m_recordOfKeyUsage.clear();
198             m_firstDecryptTime = 0;
199             m_latestDecryptTime = 0;
200         }
201 
202         LOG(EME, &quot;EME - request license from CDM implementation&quot;);
203         m_instanceSession-&gt;requestLicense(m_sessionType, initDataType, WTFMove(initData), [this, weakThis = makeWeakPtr(*this), promise = WTFMove(promise)] (Ref&lt;SharedBuffer&gt;&amp;&amp; message, const String&amp; sessionId, bool needsIndividualization, CDMInstanceSession::SuccessValue succeeded) mutable {
204             if (!weakThis)
205                 return;
206 
207             // 10.9.3. Let session id be a unique Session ID string.
208 
209             MediaKeyMessageType messageType;
210             if (!needsIndividualization) {
211                 // 10.9.4. If a license request for the requested license type can be generated based on the sanitized init data:
212                 // 10.9.4.1. Let message be a license request for the requested license type generated based on the sanitized init data interpreted per initDataType.
213                 // 10.9.4.2. Let message type be &quot;license-request&quot;.
214                 messageType = MediaKeyMessageType::LicenseRequest;
215             } else {
216                 // 10.9.5. Otherwise:
217                 // 10.9.5.1. Let message be the request that needs to be processed before a license request request for the requested license
218                 //           type can be generated based on the sanitized init data.
219                 // 10.9.5.2. Let message type reflect the type of message, either &quot;license-request&quot; or &quot;individualization-request&quot;.
220                 messageType = MediaKeyMessageType::IndividualizationRequest;
221             }
222 
223             // 10.10. Queue a task to run the following steps:
224             m_taskQueue.enqueueTask([this, promise = WTFMove(promise), message = WTFMove(message), messageType, sessionId, succeeded] () mutable {
225                 // 10.10.1. If any of the preceding steps failed, reject promise with a new DOMException whose name is the appropriate error name.
226                 if (succeeded == CDMInstanceSession::SuccessValue::Failed) {
227                     promise-&gt;reject(NotSupportedError);
228                     return;
229                 }
230                 // 10.10.2. Set the sessionId attribute to session id.
231                 m_sessionId = sessionId;
232 
233                 // 10.9.3. Let this object&#39;s callable value be true.
234                 m_callable = true;
235 
236                 // 10.9.3. Run the Queue a &quot;message&quot; Event algorithm on the session, providing message type and message.
237                 enqueueMessage(messageType, message);
238 
239                 // 10.9.3. Resolve promise.
240                 promise-&gt;resolve();
241             });
242         });
243     });
244 
245     // 11. Return promise.
246 }
247 
248 void MediaKeySession::load(const String&amp; sessionId, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
249 {
250     // https://w3c.github.io/encrypted-media/#dom-mediakeysession-load
251     // W3C Editor&#39;s Draft 09 November 2016
252 
253     // 1. If this object is closed, return a promise rejected with an InvalidStateError.
254     // 2. If this object&#39;s uninitialized value is false, return a promise rejected with an InvalidStateError.
255     if (m_closed || !m_uninitialized) {
256         promise-&gt;reject(InvalidStateError);
257         return;
258     }
259 
260     // 3. Let this object&#39;s uninitialized value be false.
261     m_uninitialized = false;
262 
263     // 4. If sessionId is the empty string, return a promise rejected with a newly created TypeError.
264     // 5. If the result of running the Is persistent session type? algorithm on this object&#39;s session type is false, return a promise rejected with a newly created TypeError.
265     if (sessionId.isEmpty() || m_sessionType == MediaKeySessionType::Temporary) {
266         promise-&gt;reject(TypeError);
267         return;
268     }
269 
270     // 6. Let origin be the origin of this object&#39;s Document.
271     // This is retrieved in the following task.
272 
273     // 7. Let promise be a new promise.
274     // 8. Run the following steps in parallel:
275     m_taskQueue.enqueueTask([this, sessionId, promise = WTFMove(promise)] () mutable {
276         // 8.1. Let sanitized session ID be a validated and/or sanitized version of sessionId.
277         // 8.2. If the preceding step failed, or if sanitized session ID is empty, reject promise with a newly created TypeError.
278         Optional&lt;String&gt; sanitizedSessionId = m_implementation-&gt;sanitizeSessionId(sessionId);
279         if (!sanitizedSessionId || sanitizedSessionId-&gt;isEmpty()) {
280             promise-&gt;reject(TypeError);
281             return;
282         }
283 
284         // 8.3. If there is a MediaKeySession object that is not closed in this object&#39;s Document whose sessionId attribute is sanitized session ID, reject promise with a QuotaExceededError.
285         // FIXME: This needs a global MediaKeySession tracker.
286 
287         String origin;
288         if (auto* document = downcast&lt;Document&gt;(scriptExecutionContext()))
289             origin = document-&gt;securityOrigin().toString();
290 
291         // 8.4. Let expiration time be NaN.
292         // 8.5. Let message be null.
293         // 8.6. Let message type be null.
294         // 8.7. Let cdm be the CDM instance represented by this object&#39;s cdm instance value.
295         // 8.8. Use the cdm to execute the following steps:
296         m_instanceSession-&gt;loadSession(m_sessionType, *sanitizedSessionId, origin, [this, weakThis = makeWeakPtr(*this), promise = WTFMove(promise), sanitizedSessionId = *sanitizedSessionId] (Optional&lt;CDMInstanceSession::KeyStatusVector&gt;&amp;&amp; knownKeys, Optional&lt;double&gt;&amp;&amp; expiration, Optional&lt;CDMInstanceSession::Message&gt;&amp;&amp; message, CDMInstanceSession::SuccessValue succeeded, CDMInstanceSession::SessionLoadFailure failure) mutable {
297             // 8.8.1. If there is no data stored for the sanitized session ID in the origin, resolve promise with false and abort these steps.
298             // 8.8.2. If the stored session&#39;s session type is not the same as the current MediaKeySession session type, reject promise with a newly created TypeError.
299             // 8.8.3. Let session data be the data stored for the sanitized session ID in the origin. This must not include data from other origin(s) or that is not associated with an origin.
300             // 8.8.4. If there is a MediaKeySession object that is not closed in any Document and that represents the session data, reject promise with a QuotaExceededError.
301             // 8.8.5. Load the session data.
302             // 8.8.6. If the session data indicates an expiration time for the session, let expiration time be the expiration time in milliseconds since 01 January 1970 UTC.
303             // 8.8.7. If the CDM needs to send a message:
304             //   8.8.7.1. Let message be a message generated by the CDM based on the session data.
305             //   8.8.7.2. Let message type be the appropriate MediaKeyMessageType for the message.
306             // NOTE: Steps 8.8.1. through 8.8.7. should be implemented in CDMInstance.
307 
308             if (succeeded == CDMInstanceSession::SuccessValue::Failed) {
309                 switch (failure) {
310                 case CDMInstanceSession::SessionLoadFailure::NoSessionData:
311                     promise-&gt;resolve&lt;IDLBoolean&gt;(false);
312                     return;
313                 case CDMInstanceSession::SessionLoadFailure::MismatchedSessionType:
314                     promise-&gt;reject(TypeError);
315                     return;
316                 case CDMInstanceSession::SessionLoadFailure::QuotaExceeded:
317                     promise-&gt;reject(QuotaExceededError);
318                     return;
319                 case CDMInstanceSession::SessionLoadFailure::None:
320                 case CDMInstanceSession::SessionLoadFailure::Other:
321                     // In any other case, the session load failure will cause a rejection in the following task.
322                     break;
323                 }
324             }
325 
326             // 8.9. Queue a task to run the following steps:
327             m_taskQueue.enqueueTask([this, knownKeys = WTFMove(knownKeys), expiration = WTFMove(expiration), message = WTFMove(message), sanitizedSessionId, succeeded, promise = WTFMove(promise)] () mutable {
328                 // 8.9.1. If any of the preceding steps failed, reject promise with a the appropriate error name.
329                 if (succeeded == CDMInstanceSession::SuccessValue::Failed) {
330                     promise-&gt;reject(NotSupportedError);
331                     return;
332                 }
333 
334                 // 8.9.2. Set the sessionId attribute to sanitized session ID.
335                 // 8.9.3. Let this object&#39;s callable value be true.
336                 m_sessionId = sanitizedSessionId;
337                 m_callable = true;
338 
339                 // 8.9.4. If the loaded session contains information about any keys (there are known keys), run the Update Key Statuses algorithm on the session, providing each key&#39;s key ID along with the appropriate MediaKeyStatus.
340                 if (knownKeys)
341                     updateKeyStatuses(WTFMove(*knownKeys));
342 
343                 // 8.9.5. Run the Update Expiration algorithm on the session, providing expiration time.
344                 // This must be run, and NaN is the default value if the CDM instance doesn&#39;t provide one.
345                 updateExpiration(expiration.valueOr(std::numeric_limits&lt;double&gt;::quiet_NaN()));
346 
347                 // 8.9.6. If message is not null, run the Queue a &quot;message&quot; Event algorithm on the session, providing message type and message.
348                 if (message)
349                     enqueueMessage(message-&gt;first, WTFMove(message-&gt;second));
350 
351                 // 8.9.7. Resolve promise with true.
352                 promise-&gt;resolve&lt;IDLBoolean&gt;(true);
353             });
354         });
355     });
356 
357     // 9. Return promise.
358 }
359 
360 void MediaKeySession::update(const BufferSource&amp; response, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
361 {
362     // https://w3c.github.io/encrypted-media/#dom-mediakeysession-update
363     // W3C Editor&#39;s Draft 09 November 2016
364 
365     // When this method is invoked, the user agent must run the following steps:
366     // 1. If this object is closed, return a promise rejected with an InvalidStateError.
367     // 2. If this object&#39;s callable value is false, return a promise rejected with an InvalidStateError.
368     LOG(EME, &quot;EME - update session for %s&quot;, m_sessionId.utf8().data());
369 
370     if (m_closed || !m_callable) {
371         promise-&gt;reject(InvalidStateError);
372         return;
373     }
374 
375     // 3. If response is an empty array, return a promise rejected with a newly created TypeError.
376     if (!response.length()) {
377         promise-&gt;reject(TypeError);
378         return;
379     }
380 
381     // 4. Let response copy be a copy of the contents of the response parameter.
382     // 5. Let promise be a new promise.
383     // 6. Run the following steps in parallel:
384     m_taskQueue.enqueueTask([this, response = SharedBuffer::create(response.data(), response.length()), promise = WTFMove(promise)] () mutable {
385         // 6.1. Let sanitized response be a validated and/or sanitized version of response copy.
386         RefPtr&lt;SharedBuffer&gt; sanitizedResponse = m_implementation-&gt;sanitizeResponse(response);
387 
388         // 6.2. If the preceding step failed, or if sanitized response is empty, reject promise with a newly created TypeError.
389         if (!sanitizedResponse || sanitizedResponse-&gt;isEmpty()) {
390             promise-&gt;reject(TypeError);
391             return;
392         }
393 
394         // 6.3. Let message be null.
395         // 6.4. Let message type be null.
396         // 6.5. Let session closed be false.
397         // 6.6. Let cdm be the CDM instance represented by this object&#39;s cdm instance value.
398         // 6.7. Use the cdm to execute the following steps:
399         m_instanceSession-&gt;updateLicense(m_sessionId, m_sessionType, *sanitizedResponse, [this, weakThis = makeWeakPtr(*this), promise = WTFMove(promise)] (bool sessionWasClosed, Optional&lt;CDMInstanceSession::KeyStatusVector&gt;&amp;&amp; changedKeys, Optional&lt;double&gt;&amp;&amp; changedExpiration, Optional&lt;CDMInstanceSession::Message&gt;&amp;&amp; message, CDMInstanceSession::SuccessValue succeeded) mutable {
400             if (!weakThis)
401                 return;
402 
403             // 6.7.1. If the format of sanitized response is invalid in any way, reject promise with a newly created TypeError.
404             // 6.7.2. Process sanitized response, following the stipulation for the first matching condition from the following list:
405             //   ↳ If sanitized response contains a license or key(s)
406             //     Process sanitized response, following the stipulation for the first matching condition from the following list:
407             //     ↳ If sessionType is &quot;temporary&quot; and sanitized response does not specify that session data, including any license, key(s), or similar session data it contains, should be stored
408             //       Process sanitized response, not storing any session data.
409             //     ↳ If sessionType is &quot;persistent-license&quot; and sanitized response contains a persistable license
410             //       Process sanitized response, storing the license/key(s) and related session data contained in sanitized response. Such data must be stored such that only the origin of this object&#39;s Document can access it.
411             //     ↳ If sessionType is &quot;persistent-usage-record&quot; and sanitized response contains a non-persistable license
412             //       Run the following steps:
413             //         6.7.2.3.1. Process sanitized response, not storing any session data.
414             //         6.7.2.3.2. If processing sanitized response results in the addition of keys to the set of known keys, add the key IDs of these keys to this object&#39;s record of key usage.
415             //     ↳ Otherwise
416             //       Reject promise with a newly created TypeError.
417             //   ↳ If sanitized response contains a record of license destruction acknowledgement and sessionType is &quot;persistent-license&quot;
418             //     Run the following steps:
419             //       6.7.2.1. Close the key session and clear all stored session data associated with this object, including the sessionId and record of license destruction.
420             //       6.7.2.2. Set session closed to true.
421             //   ↳ Otherwise
422             //     Process sanitized response, not storing any session data.
423             // NOTE: Steps 6.7.1. and 6.7.2. should be implemented in CDMInstance.
424 
425             if (succeeded == CDMInstanceSession::SuccessValue::Failed) {
426                 LOG(EME, &quot;EME - failed to update CDM license for %s&quot;, m_sessionId.utf8().data());
427                 promise-&gt;reject(TypeError);
428                 return;
429             }
430 
431             // 6.7.3. If a message needs to be sent to the server, execute the following steps:
432             //   6.7.3.1. Let message be that message.
433             //   6.7.3.2. Let message type be the appropriate MediaKeyMessageType for the message.
434             // 6.8. Queue a task to run the following steps:
435             m_taskQueue.enqueueTask([this, sessionWasClosed, changedKeys = WTFMove(changedKeys), changedExpiration = WTFMove(changedExpiration), message = WTFMove(message), promise = WTFMove(promise)] () mutable {
436                 LOG(EME, &quot;EME - updating CDM license succeeded for session %s, sending a message to the license server&quot;, m_sessionId.utf8().data());
437                 // 6.8.1.
438                 if (sessionWasClosed) {
439                     // ↳ If session closed is true:
440                     //   Run the Session Closed algorithm on this object.
441                     sessionClosed();
442                 } else {
443                     // ↳ Otherwise:
444                     //   Run the following steps:
445                     //     6.8.1.1. If the set of keys known to the CDM for this object changed or the status of any key(s) changed, run the Update Key Statuses
446                     //              algorithm on the session, providing each known key&#39;s key ID along with the appropriate MediaKeyStatus. Should additional
447                     //              processing be necessary to determine with certainty the status of a key, use &quot;status-pending&quot;. Once the additional processing
448                     //              for one or more keys has completed, run the Update Key Statuses algorithm again with the actual status(es).
449                     if (changedKeys)
450                         updateKeyStatuses(WTFMove(*changedKeys));
451 
452                     //     6.8.1.2. If the expiration time for the session changed, run the Update Expiration algorithm on the session, providing the new expiration time.
453                     if (changedExpiration)
454                         updateExpiration(*changedExpiration);
455 
456                     //     6.8.1.3. If any of the preceding steps failed, reject promise with a new DOMException whose name is the appropriate error name.
457                     // FIXME: At this point the implementations of preceding steps can&#39;t fail.
458 
459                     //     6.8.1.4. If message is not null, run the Queue a &quot;message&quot; Event algorithm on the session, providing message type and message.
460                     if (message) {
461                         MediaKeyMessageType messageType;
462                         switch (message-&gt;first) {
463                         case CDMInstanceSession::MessageType::LicenseRequest:
464                             messageType = MediaKeyMessageType::LicenseRequest;
465                             break;
466                         case CDMInstanceSession::MessageType::LicenseRenewal:
467                             messageType = MediaKeyMessageType::LicenseRenewal;
468                             break;
469                         case CDMInstanceSession::MessageType::LicenseRelease:
470                             messageType = MediaKeyMessageType::LicenseRelease;
471                             break;
472                         case CDMInstanceSession::MessageType::IndividualizationRequest:
473                             messageType = MediaKeyMessageType::IndividualizationRequest;
474                             break;
475                         }
476 
477                         enqueueMessage(messageType, WTFMove(message-&gt;second));
478                     }
479                 }
480 
481                 // 6.8.2. Resolve promise.
482                 promise-&gt;resolve();
483             });
484         });
485     });
486 
487     // 7. Return promise.
488 }
489 
490 void MediaKeySession::close(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
491 {
492     // https://w3c.github.io/encrypted-media/#dom-mediakeysession-close
493     // W3C Editor&#39;s Draft 09 November 2016
494 
495     // 1. Let session be the associated MediaKeySession object.
496     // 2. If session is closed, return a resolved promise.
497     LOG(EME, &quot;EME - closing session %s&quot;, m_sessionId.utf8().data());
498 
499     if (m_closed) {
500         promise-&gt;resolve();
501         return;
502     }
503 
504     // 3. If session&#39;s callable value is false, return a promise rejected with an InvalidStateError.
505     if (!m_callable) {
506         promise-&gt;reject(InvalidStateError);
507         return;
508     }
509 
510     // 4. Let promise be a new promise.
511     // 5. Run the following steps in parallel:
512     m_taskQueue.enqueueTask([this, promise = WTFMove(promise)] () mutable {
513         // 5.1. Let cdm be the CDM instance represented by session&#39;s cdm instance value.
514         // 5.2. Use cdm to close the key session associated with session.
515         LOG(EME, &quot;EME - closing CDM session %s&quot;, m_sessionId.utf8().data());
516         m_instanceSession-&gt;closeSession(m_sessionId, [this, weakThis = makeWeakPtr(*this), promise = WTFMove(promise)] () mutable {
517             if (!weakThis)
518                 return;
519 
520             // 5.3. Queue a task to run the following steps:
521             m_taskQueue.enqueueTask([this, promise = WTFMove(promise)] () mutable {
522                 // 5.3.1. Run the Session Closed algorithm on the session.
523                 sessionClosed();
524 
525                 // 5.3.2. Resolve promise.
526                 promise-&gt;resolve();
527             });
528         });
529     });
530 
531     // 6. Return promise.
532 }
533 
534 void MediaKeySession::remove(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
535 {
536     // https://w3c.github.io/encrypted-media/#dom-mediakeysession-remove
537     // W3C Editor&#39;s Draft 09 November 2016
538 
539     // 1. If this object is closed, return a promise rejected with an InvalidStateError.
540     // 2. If this object&#39;s callable value is false, return a promise rejected with an InvalidStateError.
541     LOG(EME, &quot;EME - removing session %s&quot;, m_sessionId.utf8().data());
542 
543     if (m_closed || !m_callable) {
544         promise-&gt;reject(InvalidStateError);
545         return;
546     }
547 
548     // 3. Let promise be a new promise.
549     // 4. Run the following steps in parallel:
550     m_taskQueue.enqueueTask([this, promise = WTFMove(promise)] () mutable {
551         // 4.1. Let cdm be the CDM instance represented by this object&#39;s cdm instance value.
552         // 4.2. Let message be null.
553         // 4.3. Let message type be null.
554 
555         // 4.4. Use the cdm to execute the following steps:
556         m_instanceSession-&gt;removeSessionData(m_sessionId, m_sessionType, [this, weakThis = makeWeakPtr(*this), promise = WTFMove(promise)] (CDMInstanceSession::KeyStatusVector&amp;&amp; keys, Optional&lt;Ref&lt;SharedBuffer&gt;&gt;&amp;&amp; message, CDMInstanceSession::SuccessValue succeeded) mutable {
557             if (!weakThis)
558                 return;
559 
560             // 4.4.1. If any license(s) and/or key(s) are associated with the session:
561             //   4.4.1.1. Destroy the license(s) and/or key(s) associated with the session.
562             //   4.4.1.2. Follow the steps for the value of this object&#39;s session type from the following list:
563             //     ↳ &quot;temporary&quot;
564             //       4.4.1.2.1.1 Continue with the following steps.
565             //     ↳ &quot;persistent-license&quot;
566             //       4.4.1.2.2.1. Let record of license destruction be a record of license destruction for the license represented by this object.
567             //       4.4.1.2.2.2. Store the record of license destruction.
568             //       4.4.1.2.2.3. Let message be a message containing or reflecting the record of license destruction.
569             //     ↳ &quot;persistent-usage-record&quot;
570             //       4.4.1.2.3.1. Store this object&#39;s record of key usage.
571             //       4.4.1.2.3.2. Let message be a message containing or reflecting this object&#39;s record of key usage.
572             // NOTE: Step 4.4.1. should be implemented in CDMInstance.
573 
574             // 4.5. Queue a task to run the following steps:
575             m_taskQueue.enqueueTask([this, keys = WTFMove(keys), message = WTFMove(message), succeeded, promise = WTFMove(promise)] () mutable {
576                 // 4.5.1. Run the Update Key Statuses algorithm on the session, providing all key ID(s) in the session along with the &quot;released&quot; MediaKeyStatus value for each.
577                 updateKeyStatuses(WTFMove(keys));
578 
579                 // 4.5.2. Run the Update Expiration algorithm on the session, providing NaN.
580                 updateExpiration(std::numeric_limits&lt;double&gt;::quiet_NaN());
581 
582                 // 4.5.3. If any of the preceding steps failed, reject promise with a new DOMException whose name is the appropriate error name.
583                 if (succeeded == CDMInstanceSession::SuccessValue::Failed) {
584                     promise-&gt;reject(NotSupportedError);
585                     return;
586                 }
587 
588                 // 4.5.4. Let message type be &quot;license-release&quot;.
589                 // 4.5.5. If message is not null, run the Queue a &quot;message&quot; Event algorithm on the session, providing message type and message.
590                 if (message)
591                     enqueueMessage(MediaKeyMessageType::LicenseRelease, *message);
592 
593                 // 4.5.6. Resolve promise.
594                 promise-&gt;resolve();
595             });
596         });
597     });
598 
599     // 5. Return promise.
600 }
601 
602 void MediaKeySession::enqueueMessage(MediaKeyMessageType messageType, const SharedBuffer&amp; message)
603 {
604     // 6.4.1 Queue a &quot;message&quot; Event
605     // https://w3c.github.io/encrypted-media/#queue-message
606     // W3C Editor&#39;s Draft 09 November 2016
607 
608     // The following steps are run:
609     // 1. Let the session be the specified MediaKeySession object.
610     // 2. Queue a task to create an event named message that does not bubble and is not cancellable using the MediaKeyMessageEvent
611     //    interface with its type attribute set to message and its isTrusted attribute initialized to true, and dispatch it at the
612     //    session.
613     auto messageEvent = MediaKeyMessageEvent::create(eventNames().messageEvent, {messageType, message.tryCreateArrayBuffer()}, Event::IsTrusted::Yes);
614     m_eventQueue.enqueueEvent(WTFMove(messageEvent));
615 }
616 
617 void MediaKeySession::updateKeyStatuses(CDMInstanceSession::KeyStatusVector&amp;&amp; inputStatuses)
618 {
619     // https://w3c.github.io/encrypted-media/#update-key-statuses
620     // W3C Editor&#39;s Draft 09 November 2016
621 
622     // 1. Let the session be the associated MediaKeySession object.
623     // 2. Let the input statuses be the sequence of pairs key ID and associated MediaKeyStatus pairs.
624     // 3. Let the statuses be session&#39;s keyStatuses attribute.
625     // 4. Run the following steps to replace the contents of statuses:
626     //   4.1. Empty statuses.
627     //   4.2. For each pair in input statuses.
628     //     4.2.1. Let pair be the pair.
629     //     4.2.2. Insert an entry for pair&#39;s key ID into statuses with the value of pair&#39;s MediaKeyStatus value.
630 
631     static auto toMediaKeyStatus = [] (CDMInstanceSession::KeyStatus status) -&gt; MediaKeyStatus {
632         switch (status) {
633         case CDMInstanceSession::KeyStatus::Usable:
634             return MediaKeyStatus::Usable;
635         case CDMInstanceSession::KeyStatus::Expired:
636             return MediaKeyStatus::Expired;
637         case CDMInstanceSession::KeyStatus::Released:
638             return MediaKeyStatus::Released;
639         case CDMInstanceSession::KeyStatus::OutputRestricted:
640             return MediaKeyStatus::OutputRestricted;
641         case CDMInstanceSession::KeyStatus::OutputDownscaled:
642             return MediaKeyStatus::OutputDownscaled;
643         case CDMInstanceSession::KeyStatus::StatusPending:
644             return MediaKeyStatus::StatusPending;
645         case CDMInstanceSession::KeyStatus::InternalError:
646             return MediaKeyStatus::InternalError;
647         };
648 
649         ASSERT_NOT_REACHED();
650         return MediaKeyStatus::InternalError;
651     };
652 
653     m_statuses.clear();
654     m_statuses.reserveCapacity(inputStatuses.size());
655     for (auto&amp; status : inputStatuses)
656         m_statuses.uncheckedAppend({ WTFMove(status.first), toMediaKeyStatus(status.second) });
657 
658     // 5. Queue a task to fire a simple event named keystatuseschange at the session.
659     m_eventQueue.enqueueEvent(Event::create(eventNames().keystatuseschangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
660 
661     // 6. Queue a task to run the Attempt to Resume Playback If Necessary algorithm on each of the media element(s) whose mediaKeys attribute is the MediaKeys object that created the session.
662     m_taskQueue.enqueueTask(
663         [this] () mutable {
664             if (m_keys)
665                 m_keys-&gt;attemptToResumePlaybackOnClients();
666         });
667 }
668 
669 void MediaKeySession::sendMessage(CDMMessageType messageType, Ref&lt;SharedBuffer&gt;&amp;&amp; message)
670 {
671     enqueueMessage(messageType, message);
672 }
673 
674 void MediaKeySession::sessionIdChanged(const String&amp; sessionId)
675 {
676     m_sessionId = sessionId;
677 }
678 
679 void MediaKeySession::updateExpiration(double)
680 {
681     notImplemented();
682 }
683 
684 void MediaKeySession::sessionClosed()
685 {
686     // https://w3c.github.io/encrypted-media/#session-closed
687     // W3C Editor&#39;s Draft 09 November 2016
688     LOG(EME, &quot;EME - session %s was closed&quot;, m_sessionId.utf8().data());
689 
690     // 1. Let session be the associated MediaKeySession object.
691     // 2. If session&#39;s session type is &quot;persistent-usage-record&quot;, execute the following steps in parallel:
692     if (m_sessionType == MediaKeySessionType::PersistentUsageRecord) {
693         // 2.1. Let cdm be the CDM instance represented by session&#39;s cdm instance value.
694         // 2.2. Use cdm to store session&#39;s record of key usage, if it exists.
695         m_instanceSession-&gt;storeRecordOfKeyUsage(m_sessionId);
696     }
697 
698     // 3. Run the Update Key Statuses algorithm on the session, providing an empty sequence.
699     updateKeyStatuses({ });
700 
701     // 4. Run the Update Expiration algorithm on the session, providing NaN.
702     updateExpiration(std::numeric_limits&lt;double&gt;::quiet_NaN());
703 
704     // Let&#39;s consider the session closed before any promise on the &#39;closed&#39; attribute is resolved.
705     m_closed = true;
706 
707     // 5. Let promise be the closed attribute of the session.
708     // 6. Resolve promise.
709     m_closedPromise.resolve();
710 }
711 
712 String MediaKeySession::mediaKeysStorageDirectory() const
713 {
714     auto* document = downcast&lt;Document&gt;(scriptExecutionContext());
715     if (!document)
716         return emptyString();
717 
718     auto* page = document-&gt;page();
719     if (!page || page-&gt;usesEphemeralSession())
720         return emptyString();
721 
722     auto storageDirectory = document-&gt;settings().mediaKeysStorageDirectory();
723     if (storageDirectory.isEmpty())
724         return emptyString();
725 
726     return FileSystem::pathByAppendingComponent(storageDirectory, document-&gt;securityOrigin().data().databaseIdentifier());
727 }
728 
729 bool MediaKeySession::hasPendingActivity() const
730 {
731     notImplemented();
732     return false;
733 }
734 
735 const char* MediaKeySession::activeDOMObjectName() const
736 {
737     notImplemented();
738     return &quot;MediaKeySession&quot;;
739 }
740 
741 bool MediaKeySession::canSuspendForDocumentSuspension() const
742 {
743     notImplemented();
744     return false;
745 }
746 
747 void MediaKeySession::stop()
748 {
749     notImplemented();
750 }
751 
752 } // namespace WebCore
753 
754 #endif
    </pre>
  </body>
</html>