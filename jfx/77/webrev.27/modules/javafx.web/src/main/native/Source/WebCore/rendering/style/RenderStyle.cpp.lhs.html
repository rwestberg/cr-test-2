<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/style/RenderStyle.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Antti Koivisto (koivisto@kde.org)
   3  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   4  * Copyright (C) 2011 Adobe Systems Incorporated. All rights reserved.
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public License
  17  * along with this library; see the file COPYING.LIB.  If not, write to
  18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;RenderStyle.h&quot;
  25 
  26 #include &quot;CSSComputedStyleDeclaration.h&quot;
  27 #include &quot;CSSCustomPropertyValue.h&quot;
  28 #include &quot;CSSParser.h&quot;
  29 #include &quot;CSSPropertyNames.h&quot;
  30 #include &quot;CSSPropertyParser.h&quot;
  31 #include &quot;ContentData.h&quot;
  32 #include &quot;CursorList.h&quot;
  33 #include &quot;FloatRoundedRect.h&quot;
  34 #include &quot;FontCascade.h&quot;
  35 #include &quot;FontSelector.h&quot;
  36 #include &quot;InlineTextBoxStyle.h&quot;
  37 #include &quot;Pagination.h&quot;
  38 #include &quot;QuotesData.h&quot;
  39 #include &quot;RenderObject.h&quot;
  40 #include &quot;RenderTheme.h&quot;
  41 #include &quot;RuntimeEnabledFeatures.h&quot;
  42 #include &quot;ScaleTransformOperation.h&quot;
  43 #include &quot;ShadowData.h&quot;
  44 #include &quot;StyleBuilderConverter.h&quot;
  45 #include &quot;StyleImage.h&quot;
  46 #include &quot;StyleInheritedData.h&quot;
  47 #include &quot;StyleResolver.h&quot;
  48 #include &quot;StyleScrollSnapPoints.h&quot;
  49 #include &quot;StyleSelfAlignmentData.h&quot;
  50 #include &quot;StyleTreeResolver.h&quot;
  51 #include &quot;WillChangeData.h&quot;
  52 #include &lt;wtf/MathExtras.h&gt;
  53 #include &lt;wtf/PointerComparison.h&gt;
  54 #include &lt;wtf/StdLibExtras.h&gt;
  55 #include &lt;algorithm&gt;
  56 
  57 #if ENABLE(TEXT_AUTOSIZING)
  58 #include &lt;wtf/text/StringHash.h&gt;
  59 #endif
  60 
  61 namespace WebCore {
  62 
  63 struct SameSizeAsBorderValue {
  64     Color m_color;
  65     float m_width;
  66     int m_restBits;
  67 };
  68 
  69 COMPILE_ASSERT(sizeof(BorderValue) == sizeof(SameSizeAsBorderValue), BorderValue_should_not_grow);
  70 
  71 struct SameSizeAsRenderStyle {
  72     void* dataRefs[7];
  73     void* ownPtrs[1];
  74     void* dataRefSvgStyle;
  75     struct InheritedFlags {
  76         unsigned m_bitfields[2];
  77     } m_inheritedFlags;
  78 
  79     struct NonInheritedFlags {
  80         unsigned m_bitfields[2];
  81     } m_nonInheritedFlags;
  82 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)
  83     bool deletionCheck;
  84 #endif
  85 };
  86 
  87 static_assert(sizeof(RenderStyle) == sizeof(SameSizeAsRenderStyle), &quot;RenderStyle should stay small&quot;);
  88 
  89 RenderStyle&amp; RenderStyle::defaultStyle()
  90 {
  91     static NeverDestroyed&lt;RenderStyle&gt; style { CreateDefaultStyle };
  92     return style;
  93 }
  94 
  95 RenderStyle RenderStyle::create()
  96 {
  97     return clone(defaultStyle());
  98 }
  99 
 100 std::unique_ptr&lt;RenderStyle&gt; RenderStyle::createPtr()
 101 {
 102     return clonePtr(defaultStyle());
 103 }
 104 
 105 RenderStyle RenderStyle::clone(const RenderStyle&amp; style)
 106 {
 107     return RenderStyle(style, Clone);
 108 }
 109 
 110 std::unique_ptr&lt;RenderStyle&gt; RenderStyle::clonePtr(const RenderStyle&amp; style)
 111 {
<a name="1" id="anc1"></a><span class="line-modified"> 112     return std::make_unique&lt;RenderStyle&gt;(style, Clone);</span>
 113 }
 114 
 115 RenderStyle RenderStyle::createAnonymousStyleWithDisplay(const RenderStyle&amp; parentStyle, DisplayType display)
 116 {
 117     auto newStyle = create();
 118     newStyle.inheritFrom(parentStyle);
 119     newStyle.inheritUnicodeBidiFrom(&amp;parentStyle);
 120     newStyle.setDisplay(display);
 121     return newStyle;
 122 }
 123 
 124 RenderStyle RenderStyle::createStyleInheritingFromPseudoStyle(const RenderStyle&amp; pseudoStyle)
 125 {
 126     ASSERT(pseudoStyle.styleType() == PseudoId::Before || pseudoStyle.styleType() == PseudoId::After);
 127 
 128     auto style = create();
 129     style.inheritFrom(pseudoStyle);
 130     return style;
 131 }
 132 
 133 RenderStyle::RenderStyle(RenderStyle&amp;&amp;) = default;
 134 RenderStyle&amp; RenderStyle::operator=(RenderStyle&amp;&amp;) = default;
 135 
 136 RenderStyle::RenderStyle(CreateDefaultStyleTag)
 137     : m_boxData(StyleBoxData::create())
 138     , m_visualData(StyleVisualData::create())
 139     , m_backgroundData(StyleBackgroundData::create())
 140     , m_surroundData(StyleSurroundData::create())
 141     , m_rareNonInheritedData(StyleRareNonInheritedData::create())
 142     , m_rareInheritedData(StyleRareInheritedData::create())
 143     , m_inheritedData(StyleInheritedData::create())
 144     , m_svgStyle(SVGRenderStyle::create())
 145 {
 146     m_inheritedFlags.emptyCells = static_cast&lt;unsigned&gt;(initialEmptyCells());
 147     m_inheritedFlags.captionSide = static_cast&lt;unsigned&gt;(initialCaptionSide());
 148     m_inheritedFlags.listStyleType = static_cast&lt;unsigned&gt;(initialListStyleType());
 149     m_inheritedFlags.listStylePosition = static_cast&lt;unsigned&gt;(initialListStylePosition());
 150     m_inheritedFlags.visibility = static_cast&lt;unsigned&gt;(initialVisibility());
 151     m_inheritedFlags.textAlign = static_cast&lt;unsigned&gt;(initialTextAlign());
 152     m_inheritedFlags.textTransform = static_cast&lt;unsigned&gt;(initialTextTransform());
 153     m_inheritedFlags.textDecorations = initialTextDecoration().toRaw();
 154     m_inheritedFlags.cursor = static_cast&lt;unsigned&gt;(initialCursor());
 155 #if ENABLE(CURSOR_VISIBILITY)
 156     m_inheritedFlags.cursorVisibility = static_cast&lt;unsigned&gt;(initialCursorVisibility());
 157 #endif
 158     m_inheritedFlags.direction = static_cast&lt;unsigned&gt;(initialDirection());
 159     m_inheritedFlags.whiteSpace = static_cast&lt;unsigned&gt;(initialWhiteSpace());
 160     m_inheritedFlags.borderCollapse = static_cast&lt;unsigned&gt;(initialBorderCollapse());
 161     m_inheritedFlags.rtlOrdering = static_cast&lt;unsigned&gt;(initialRTLOrdering());
 162     m_inheritedFlags.boxDirection = static_cast&lt;unsigned&gt;(initialBoxDirection());
 163     m_inheritedFlags.printColorAdjust = static_cast&lt;unsigned&gt;(initialPrintColorAdjust());
 164     m_inheritedFlags.pointerEvents = static_cast&lt;unsigned&gt;(initialPointerEvents());
 165     m_inheritedFlags.insideLink = static_cast&lt;unsigned&gt;(InsideLink::NotInside);
 166     m_inheritedFlags.insideDefaultButton = false;
 167     m_inheritedFlags.writingMode = initialWritingMode();
<a name="2" id="anc2"></a>


 168 
 169     m_nonInheritedFlags.effectiveDisplay = static_cast&lt;unsigned&gt;(initialDisplay());
 170     m_nonInheritedFlags.originalDisplay = static_cast&lt;unsigned&gt;(initialDisplay());
 171     m_nonInheritedFlags.overflowX = static_cast&lt;unsigned&gt;(initialOverflowX());
 172     m_nonInheritedFlags.overflowY = static_cast&lt;unsigned&gt;(initialOverflowY());
 173     m_nonInheritedFlags.verticalAlign = static_cast&lt;unsigned&gt;(initialVerticalAlign());
 174     m_nonInheritedFlags.clear = static_cast&lt;unsigned&gt;(initialClear());
 175     m_nonInheritedFlags.position = static_cast&lt;unsigned&gt;(initialPosition());
 176     m_nonInheritedFlags.unicodeBidi = initialUnicodeBidi();
 177     m_nonInheritedFlags.floating = static_cast&lt;unsigned&gt;(initialFloating());
 178     m_nonInheritedFlags.tableLayout = static_cast&lt;unsigned&gt;(initialTableLayout());
 179     m_nonInheritedFlags.hasExplicitlySetDirection = false;
 180     m_nonInheritedFlags.hasExplicitlySetWritingMode = false;
 181     m_nonInheritedFlags.hasExplicitlySetTextAlign = false;
 182     m_nonInheritedFlags.hasViewportUnits = false;
 183     m_nonInheritedFlags.hasExplicitlyInheritedProperties = false;
 184     m_nonInheritedFlags.isUnique = false;
 185     m_nonInheritedFlags.emptyState = false;
 186     m_nonInheritedFlags.firstChildState = false;
 187     m_nonInheritedFlags.lastChildState = false;
 188     m_nonInheritedFlags.affectedByHover = false;
 189     m_nonInheritedFlags.affectedByActive = false;
 190     m_nonInheritedFlags.affectedByDrag = false;
 191     m_nonInheritedFlags.isLink = false;
 192     m_nonInheritedFlags.styleType = static_cast&lt;unsigned&gt;(PseudoId::None);
 193     m_nonInheritedFlags.pseudoBits = static_cast&lt;unsigned&gt;(PseudoId::None);
 194 
 195     static_assert((sizeof(InheritedFlags) &lt;= 8), &quot;InheritedFlags does not grow&quot;);
 196     static_assert((sizeof(NonInheritedFlags) &lt;= 8), &quot;NonInheritedFlags does not grow&quot;);
 197 }
 198 
 199 inline RenderStyle::RenderStyle(const RenderStyle&amp; other, CloneTag)
 200     : m_boxData(other.m_boxData)
 201     , m_visualData(other.m_visualData)
 202     , m_backgroundData(other.m_backgroundData)
 203     , m_surroundData(other.m_surroundData)
 204     , m_rareNonInheritedData(other.m_rareNonInheritedData)
 205     , m_nonInheritedFlags(other.m_nonInheritedFlags)
 206     , m_rareInheritedData(other.m_rareInheritedData)
 207     , m_inheritedData(other.m_inheritedData)
 208     , m_inheritedFlags(other.m_inheritedFlags)
 209     , m_svgStyle(other.m_svgStyle)
 210 {
 211 }
 212 
 213 inline RenderStyle::RenderStyle(RenderStyle&amp; a, RenderStyle&amp;&amp; b)
 214     : m_boxData(a.m_boxData.replace(WTFMove(b.m_boxData)))
 215     , m_visualData(a.m_visualData.replace(WTFMove(b.m_visualData)))
 216     , m_backgroundData(a.m_backgroundData.replace(WTFMove(b.m_backgroundData)))
 217     , m_surroundData(a.m_surroundData.replace(WTFMove(b.m_surroundData)))
 218     , m_rareNonInheritedData(a.m_rareNonInheritedData.replace(WTFMove(b.m_rareNonInheritedData)))
 219     , m_nonInheritedFlags(std::exchange(a.m_nonInheritedFlags, b.m_nonInheritedFlags))
 220     , m_rareInheritedData(a.m_rareInheritedData.replace(WTFMove(b.m_rareInheritedData)))
 221     , m_inheritedData(a.m_inheritedData.replace(WTFMove(b.m_inheritedData)))
 222     , m_inheritedFlags(std::exchange(a.m_inheritedFlags, b.m_inheritedFlags))
 223     , m_cachedPseudoStyles(std::exchange(a.m_cachedPseudoStyles, WTFMove(b.m_cachedPseudoStyles)))
 224     , m_svgStyle(a.m_svgStyle.replace(WTFMove(b.m_svgStyle)))
 225 {
 226 }
 227 
 228 RenderStyle::~RenderStyle()
 229 {
 230 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)
 231     ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
 232     m_deletionHasBegun = true;
 233 #endif
 234 }
 235 
 236 RenderStyle RenderStyle::replace(RenderStyle&amp;&amp; newStyle)
 237 {
 238     return RenderStyle { *this, WTFMove(newStyle) };
 239 }
 240 
 241 static StyleSelfAlignmentData resolvedSelfAlignment(const StyleSelfAlignmentData&amp; value, ItemPosition normalValueBehavior)
 242 {
 243     if (value.position() == ItemPosition::Legacy || value.position() == ItemPosition::Normal || value.position() == ItemPosition::Auto)
 244         return { normalValueBehavior, OverflowAlignment::Default };
 245     return value;
 246 }
 247 
 248 StyleSelfAlignmentData RenderStyle::resolvedAlignItems(ItemPosition normalValueBehaviour) const
 249 {
 250     return resolvedSelfAlignment(alignItems(), normalValueBehaviour);
 251 }
 252 
 253 StyleSelfAlignmentData RenderStyle::resolvedAlignSelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const
 254 {
 255     // The auto keyword computes to the parent&#39;s align-items computed value.
 256     // We will return the behaviour of &#39;normal&#39; value if needed, which is specific of each layout model.
 257     if (!parentStyle || alignSelf().position() != ItemPosition::Auto)
 258         return resolvedSelfAlignment(alignSelf(), normalValueBehaviour);
 259     return parentStyle-&gt;resolvedAlignItems(normalValueBehaviour);
 260 }
 261 
 262 StyleSelfAlignmentData RenderStyle::resolvedJustifyItems(ItemPosition normalValueBehaviour) const
 263 {
 264     return resolvedSelfAlignment(justifyItems(), normalValueBehaviour);
 265 }
 266 
 267 StyleSelfAlignmentData RenderStyle::resolvedJustifySelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const
 268 {
 269     // The auto keyword computes to the parent&#39;s justify-items computed value.
 270     // We will return the behaviour of &#39;normal&#39; value if needed, which is specific of each layout model.
 271     if (!parentStyle || justifySelf().position() != ItemPosition::Auto)
 272         return resolvedSelfAlignment(justifySelf(), normalValueBehaviour);
 273     return parentStyle-&gt;resolvedJustifyItems(normalValueBehaviour);
 274 }
 275 
 276 static inline StyleContentAlignmentData resolvedContentAlignment(const StyleContentAlignmentData&amp; value, const StyleContentAlignmentData&amp; normalValueBehavior)
 277 {
 278     return (value.position() == ContentPosition::Normal &amp;&amp; value.distribution() == ContentDistribution::Default) ? normalValueBehavior : value;
 279 }
 280 
 281 StyleContentAlignmentData RenderStyle::resolvedAlignContent(const StyleContentAlignmentData&amp; normalValueBehavior) const
 282 {
 283     // We will return the behaviour of &#39;normal&#39; value if needed, which is specific of each layout model.
 284     return resolvedContentAlignment(alignContent(), normalValueBehavior);
 285 }
 286 
 287 StyleContentAlignmentData RenderStyle::resolvedJustifyContent(const StyleContentAlignmentData&amp; normalValueBehavior) const
 288 {
 289     // We will return the behaviour of &#39;normal&#39; value if needed, which is specific of each layout model.
 290     return resolvedContentAlignment(justifyContent(), normalValueBehavior);
 291 }
 292 
 293 static inline ContentPosition resolvedContentAlignmentPosition(const StyleContentAlignmentData&amp; value, const StyleContentAlignmentData&amp; normalValueBehavior)
 294 {
 295     return (value.position() == ContentPosition::Normal &amp;&amp; value.distribution() == ContentDistribution::Default) ? normalValueBehavior.position() : value.position();
 296 }
 297 
 298 static inline ContentDistribution resolvedContentAlignmentDistribution(const StyleContentAlignmentData&amp; value, const StyleContentAlignmentData&amp; normalValueBehavior)
 299 {
 300     return (value.position() == ContentPosition::Normal &amp;&amp; value.distribution() == ContentDistribution::Default) ? normalValueBehavior.distribution() : value.distribution();
 301 }
 302 
 303 ContentPosition RenderStyle::resolvedJustifyContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const
 304 {
 305     return resolvedContentAlignmentPosition(justifyContent(), normalValueBehavior);
 306 }
 307 
 308 ContentDistribution RenderStyle::resolvedJustifyContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const
 309 {
 310     return resolvedContentAlignmentDistribution(justifyContent(), normalValueBehavior);
 311 }
 312 
 313 ContentPosition RenderStyle::resolvedAlignContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const
 314 {
 315     return resolvedContentAlignmentPosition(alignContent(), normalValueBehavior);
 316 }
 317 
 318 ContentDistribution RenderStyle::resolvedAlignContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const
 319 {
 320     return resolvedContentAlignmentDistribution(alignContent(), normalValueBehavior);
 321 }
 322 
 323 void RenderStyle::inheritFrom(const RenderStyle&amp; inheritParent)
 324 {
 325     m_rareInheritedData = inheritParent.m_rareInheritedData;
 326     m_inheritedData = inheritParent.m_inheritedData;
 327     m_inheritedFlags = inheritParent.m_inheritedFlags;
 328 
 329     if (m_svgStyle != inheritParent.m_svgStyle)
 330         m_svgStyle.access().inheritFrom(inheritParent.m_svgStyle.get());
 331 }
 332 
 333 void RenderStyle::copyNonInheritedFrom(const RenderStyle&amp; other)
 334 {
 335     m_boxData = other.m_boxData;
 336     m_visualData = other.m_visualData;
 337     m_backgroundData = other.m_backgroundData;
 338     m_surroundData = other.m_surroundData;
 339     m_rareNonInheritedData = other.m_rareNonInheritedData;
 340     m_nonInheritedFlags.copyNonInheritedFrom(other.m_nonInheritedFlags);
 341 
 342     if (m_svgStyle != other.m_svgStyle)
 343         m_svgStyle.access().copyNonInheritedFrom(other.m_svgStyle.get());
 344 
 345     ASSERT(zoom() == initialZoom());
 346 }
 347 
 348 void RenderStyle::copyContentFrom(const RenderStyle&amp; other)
 349 {
 350     if (!other.m_rareNonInheritedData-&gt;content)
 351         return;
 352     m_rareNonInheritedData.access().content = other.m_rareNonInheritedData-&gt;content-&gt;clone();
 353 }
 354 
 355 bool RenderStyle::operator==(const RenderStyle&amp; other) const
 356 {
 357     // compare everything except the pseudoStyle pointer
 358     return m_inheritedFlags == other.m_inheritedFlags
 359         &amp;&amp; m_nonInheritedFlags == other.m_nonInheritedFlags
 360         &amp;&amp; m_boxData == other.m_boxData
 361         &amp;&amp; m_visualData == other.m_visualData
 362         &amp;&amp; m_backgroundData == other.m_backgroundData
 363         &amp;&amp; m_surroundData == other.m_surroundData
 364         &amp;&amp; m_rareNonInheritedData == other.m_rareNonInheritedData
 365         &amp;&amp; m_rareInheritedData == other.m_rareInheritedData
 366         &amp;&amp; m_inheritedData == other.m_inheritedData
 367         &amp;&amp; m_svgStyle == other.m_svgStyle;
 368 }
 369 
 370 bool RenderStyle::hasUniquePseudoStyle() const
 371 {
 372     if (!m_cachedPseudoStyles || styleType() != PseudoId::None)
 373         return false;
 374 
 375     for (auto&amp; pseudoStyle : *m_cachedPseudoStyles) {
 376         if (pseudoStyle-&gt;unique())
 377             return true;
 378     }
 379 
 380     return false;
 381 }
 382 
 383 RenderStyle* RenderStyle::getCachedPseudoStyle(PseudoId pid) const
 384 {
 385     if (!m_cachedPseudoStyles || !m_cachedPseudoStyles-&gt;size())
 386         return nullptr;
 387 
 388     if (styleType() != PseudoId::None)
 389         return nullptr;
 390 
 391     for (auto&amp; pseudoStyle : *m_cachedPseudoStyles) {
 392         if (pseudoStyle-&gt;styleType() == pid)
 393             return pseudoStyle.get();
 394     }
 395 
 396     return nullptr;
 397 }
 398 
 399 RenderStyle* RenderStyle::addCachedPseudoStyle(std::unique_ptr&lt;RenderStyle&gt; pseudo)
 400 {
 401     if (!pseudo)
 402         return nullptr;
 403 
 404     ASSERT(pseudo-&gt;styleType() &gt; PseudoId::None);
 405 
 406     RenderStyle* result = pseudo.get();
 407 
 408     if (!m_cachedPseudoStyles)
<a name="3" id="anc3"></a><span class="line-modified"> 409         m_cachedPseudoStyles = std::make_unique&lt;PseudoStyleCache&gt;();</span>
 410 
 411     m_cachedPseudoStyles-&gt;append(WTFMove(pseudo));
 412 
 413     return result;
 414 }
 415 
 416 void RenderStyle::removeCachedPseudoStyle(PseudoId pid)
 417 {
 418     if (!m_cachedPseudoStyles)
 419         return;
 420     for (size_t i = 0; i &lt; m_cachedPseudoStyles-&gt;size(); ++i) {
 421         RenderStyle* pseudoStyle = m_cachedPseudoStyles-&gt;at(i).get();
 422         if (pseudoStyle-&gt;styleType() == pid) {
 423             m_cachedPseudoStyles-&gt;remove(i);
 424             return;
 425         }
 426     }
 427 }
 428 
 429 bool RenderStyle::inheritedNotEqual(const RenderStyle* other) const
 430 {
 431     return m_inheritedFlags != other-&gt;m_inheritedFlags
 432         || m_inheritedData != other-&gt;m_inheritedData
 433         || m_svgStyle-&gt;inheritedNotEqual(other-&gt;m_svgStyle)
 434         || m_rareInheritedData != other-&gt;m_rareInheritedData;
 435 }
 436 
 437 #if ENABLE(TEXT_AUTOSIZING)
 438 
 439 static inline unsigned computeFontHash(const FontCascade&amp; font)
 440 {
 441     IntegerHasher hasher;
 442     hasher.add(ASCIICaseInsensitiveHash::hash(font.fontDescription().firstFamily()));
 443     hasher.add(font.fontDescription().specifiedSize());
 444     return hasher.hash();
 445 }
 446 
 447 unsigned RenderStyle::hashForTextAutosizing() const
 448 {
 449     // FIXME: Not a very smart hash. Could be improved upon. See &lt;https://bugs.webkit.org/show_bug.cgi?id=121131&gt;.
 450     unsigned hash = m_rareNonInheritedData-&gt;appearance;
 451     hash ^= m_rareNonInheritedData-&gt;marginBeforeCollapse;
 452     hash ^= m_rareNonInheritedData-&gt;marginAfterCollapse;
 453     hash ^= m_rareNonInheritedData-&gt;lineClamp.value();
 454     hash ^= m_rareInheritedData-&gt;overflowWrap;
 455     hash ^= m_rareInheritedData-&gt;nbspMode;
 456     hash ^= m_rareInheritedData-&gt;lineBreak;
 457     hash ^= WTF::FloatHash&lt;float&gt;::hash(m_inheritedData-&gt;specifiedLineHeight.value());
 458     hash ^= computeFontHash(m_inheritedData-&gt;fontCascade);
 459     hash ^= WTF::FloatHash&lt;float&gt;::hash(m_inheritedData-&gt;horizontalBorderSpacing);
 460     hash ^= WTF::FloatHash&lt;float&gt;::hash(m_inheritedData-&gt;verticalBorderSpacing);
 461     hash ^= m_inheritedFlags.boxDirection;
 462     hash ^= m_inheritedFlags.rtlOrdering;
 463     hash ^= m_nonInheritedFlags.position;
 464     hash ^= m_nonInheritedFlags.floating;
 465     hash ^= m_rareNonInheritedData-&gt;textOverflow;
 466     hash ^= m_rareInheritedData-&gt;textSecurity;
 467     return hash;
 468 }
 469 
 470 bool RenderStyle::equalForTextAutosizing(const RenderStyle&amp; other) const
 471 {
 472     return m_rareNonInheritedData-&gt;appearance == other.m_rareNonInheritedData-&gt;appearance
 473         &amp;&amp; m_rareNonInheritedData-&gt;marginBeforeCollapse == other.m_rareNonInheritedData-&gt;marginBeforeCollapse
 474         &amp;&amp; m_rareNonInheritedData-&gt;marginAfterCollapse == other.m_rareNonInheritedData-&gt;marginAfterCollapse
 475         &amp;&amp; m_rareNonInheritedData-&gt;lineClamp == other.m_rareNonInheritedData-&gt;lineClamp
 476         &amp;&amp; m_rareInheritedData-&gt;textSizeAdjust == other.m_rareInheritedData-&gt;textSizeAdjust
 477         &amp;&amp; m_rareInheritedData-&gt;overflowWrap == other.m_rareInheritedData-&gt;overflowWrap
 478         &amp;&amp; m_rareInheritedData-&gt;nbspMode == other.m_rareInheritedData-&gt;nbspMode
 479         &amp;&amp; m_rareInheritedData-&gt;lineBreak == other.m_rareInheritedData-&gt;lineBreak
 480         &amp;&amp; m_rareInheritedData-&gt;textSecurity == other.m_rareInheritedData-&gt;textSecurity
 481         &amp;&amp; m_inheritedData-&gt;specifiedLineHeight == other.m_inheritedData-&gt;specifiedLineHeight
 482         &amp;&amp; m_inheritedData-&gt;fontCascade.equalForTextAutoSizing(other.m_inheritedData-&gt;fontCascade)
 483         &amp;&amp; m_inheritedData-&gt;horizontalBorderSpacing == other.m_inheritedData-&gt;horizontalBorderSpacing
 484         &amp;&amp; m_inheritedData-&gt;verticalBorderSpacing == other.m_inheritedData-&gt;verticalBorderSpacing
 485         &amp;&amp; m_inheritedFlags.boxDirection == other.m_inheritedFlags.boxDirection
 486         &amp;&amp; m_inheritedFlags.rtlOrdering == other.m_inheritedFlags.rtlOrdering
 487         &amp;&amp; m_nonInheritedFlags.position == other.m_nonInheritedFlags.position
 488         &amp;&amp; m_nonInheritedFlags.floating == other.m_nonInheritedFlags.floating
 489         &amp;&amp; m_rareNonInheritedData-&gt;textOverflow == other.m_rareNonInheritedData-&gt;textOverflow;
 490 }
 491 
<a name="4" id="anc4"></a>























































































 492 #endif // ENABLE(TEXT_AUTOSIZING)
 493 
 494 bool RenderStyle::inheritedDataShared(const RenderStyle* other) const
 495 {
 496     // This is a fast check that only looks if the data structures are shared.
 497     return m_inheritedFlags == other-&gt;m_inheritedFlags
 498         &amp;&amp; m_inheritedData.ptr() == other-&gt;m_inheritedData.ptr()
 499         &amp;&amp; m_svgStyle.ptr() == other-&gt;m_svgStyle.ptr()
 500         &amp;&amp; m_rareInheritedData.ptr() == other-&gt;m_rareInheritedData.ptr();
 501 }
 502 
 503 static bool positionChangeIsMovementOnly(const LengthBox&amp; a, const LengthBox&amp; b, const Length&amp; width)
 504 {
 505     // If any unit types are different, then we can&#39;t guarantee
 506     // that this was just a movement.
 507     if (a.left().type() != b.left().type()
 508         || a.right().type() != b.right().type()
 509         || a.top().type() != b.top().type()
 510         || a.bottom().type() != b.bottom().type())
 511         return false;
 512 
 513     // Only one unit can be non-auto in the horizontal direction and
 514     // in the vertical direction.  Otherwise the adjustment of values
 515     // is changing the size of the box.
 516     if (!a.left().isIntrinsicOrAuto() &amp;&amp; !a.right().isIntrinsicOrAuto())
 517         return false;
 518     if (!a.top().isIntrinsicOrAuto() &amp;&amp; !a.bottom().isIntrinsicOrAuto())
 519         return false;
 520     // If our width is auto and left or right is specified then this
 521     // is not just a movement - we need to resize to our container.
 522     if ((!a.left().isIntrinsicOrAuto() || !a.right().isIntrinsicOrAuto()) &amp;&amp; width.isIntrinsicOrAuto())
 523         return false;
 524 
 525     // One of the units is fixed or percent in both directions and stayed
 526     // that way in the new style.  Therefore all we are doing is moving.
 527     return true;
 528 }
 529 
 530 inline bool RenderStyle::changeAffectsVisualOverflow(const RenderStyle&amp; other) const
 531 {
 532     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
 533         &amp;&amp; !arePointingToEqualData(m_rareNonInheritedData-&gt;boxShadow, other.m_rareNonInheritedData-&gt;boxShadow))
 534         return true;
 535 
 536     if (m_rareInheritedData.ptr() != other.m_rareInheritedData.ptr()
 537         &amp;&amp; !arePointingToEqualData(m_rareInheritedData-&gt;textShadow, other.m_rareInheritedData-&gt;textShadow))
 538         return true;
 539 
 540     if (m_inheritedFlags.textDecorations != other.m_inheritedFlags.textDecorations
 541         || m_rareNonInheritedData-&gt;textDecorationStyle != other.m_rareNonInheritedData-&gt;textDecorationStyle
 542         || m_rareInheritedData-&gt;textDecorationThickness != other.m_rareInheritedData-&gt;textDecorationThickness
 543         || m_rareInheritedData-&gt;textUnderlineOffset != other.m_rareInheritedData-&gt;textUnderlineOffset
 544         || m_rareInheritedData-&gt;textUnderlinePosition != other.m_rareInheritedData-&gt;textUnderlinePosition) {
<a name="5" id="anc5"></a><span class="line-modified"> 545         return true;</span>




 546     }
 547 
 548     if (hasOutlineInVisualOverflow() != other.hasOutlineInVisualOverflow())
 549         return true;
 550     return false;
 551 }
 552 
 553 static bool rareNonInheritedDataChangeRequiresLayout(const StyleRareNonInheritedData&amp; first, const StyleRareNonInheritedData&amp; second, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties)
 554 {
 555     ASSERT(&amp;first != &amp;second);
 556 
 557     if (first.appearance != second.appearance
 558         || first.marginBeforeCollapse != second.marginBeforeCollapse
 559         || first.marginAfterCollapse != second.marginAfterCollapse
 560         || first.lineClamp != second.lineClamp
 561         || first.initialLetter != second.initialLetter
 562         || first.textOverflow != second.textOverflow)
 563         return true;
 564 
 565     if (first.shapeMargin != second.shapeMargin)
 566         return true;
 567 
 568     if (first.deprecatedFlexibleBox != second.deprecatedFlexibleBox)
 569         return true;
 570 
 571     if (first.flexibleBox != second.flexibleBox)
 572         return true;
 573 
 574     if (first.order != second.order
 575         || first.alignContent != second.alignContent
 576         || first.alignItems != second.alignItems
 577         || first.alignSelf != second.alignSelf
 578         || first.justifyContent != second.justifyContent
 579         || first.justifyItems != second.justifyItems
 580         || first.justifySelf != second.justifySelf)
 581         return true;
 582 
 583     if (!arePointingToEqualData(first.boxReflect, second.boxReflect))
 584         return true;
 585 
 586     if (first.multiCol != second.multiCol)
 587         return true;
 588 
 589     if (first.transform.ptr() != second.transform.ptr()) {
 590         if (first.transform-&gt;hasTransform() != second.transform-&gt;hasTransform())
 591             return true;
 592         if (*first.transform != *second.transform) {
 593             changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Transform);
 594             // Don&#39;t return; keep looking for another change
 595         }
 596     }
 597 
 598     if (first.grid != second.grid
 599         || first.gridItem != second.gridItem)
 600         return true;
 601 
<a name="6" id="anc6"></a><span class="line-removed"> 602 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 603     // If regions change, trigger a relayout to re-calc regions.</span>
<span class="line-removed"> 604     if (first.dashboardRegions != second.dashboardRegions)</span>
<span class="line-removed"> 605         return true;</span>
<span class="line-removed"> 606 #endif</span>
<span class="line-removed"> 607 </span>
 608     if (!arePointingToEqualData(first.willChange, second.willChange)) {
 609         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::WillChange);
 610         // Don&#39;t return; keep looking for another change
 611     }
 612 
 613     if (first.textCombine != second.textCombine)
 614         return true;
 615 
 616     if (first.breakBefore != second.breakBefore
 617         || first.breakAfter != second.breakAfter
 618         || first.breakInside != second.breakInside)
 619         return true;
 620 
 621     if (first.hasOpacity() != second.hasOpacity()) {
 622         // FIXME: We would like to use SimplifiedLayout here, but we can&#39;t quite do that yet.
 623         // We need to make sure SimplifiedLayout can operate correctly on RenderInlines (we will need
 624         // to add a selfNeedsSimplifiedLayout bit in order to not get confused and taint every line).
 625         // In addition we need to solve the floating object issue when layers come and go. Right now
 626         // a full layout is necessary to keep floating object lists sane.
 627         return true;
 628     }
 629 
 630 #if ENABLE(CSS_COMPOSITING)
 631     if (first.isolation != second.isolation) {
 632         // Ideally this would trigger a cheaper layout that just updates layer z-order trees (webit.org/b/190088).
 633         return true;
 634     }
 635 #endif
 636 
 637     if (first.hasFilters() != second.hasFilters())
 638         return true;
 639 
 640 #if ENABLE(FILTERS_LEVEL_2)
 641     if (first.hasBackdropFilters() != second.hasBackdropFilters())
 642         return true;
 643 #endif
 644 
 645     return false;
 646 }
 647 
 648 static bool rareInheritedDataChangeRequiresLayout(const StyleRareInheritedData&amp; first, const StyleRareInheritedData&amp; second)
 649 {
 650     ASSERT(&amp;first != &amp;second);
 651 
 652     if (first.indent != second.indent
 653 #if ENABLE(CSS3_TEXT)
 654         || first.textAlignLast != second.textAlignLast
 655         || first.textJustify != second.textJustify
 656         || first.textIndentLine != second.textIndentLine
 657 #endif
 658         || first.effectiveZoom != second.effectiveZoom
 659         || first.textZoom != second.textZoom
 660 #if ENABLE(TEXT_AUTOSIZING)
 661         || first.textSizeAdjust != second.textSizeAdjust
 662 #endif
 663         || first.wordBreak != second.wordBreak
 664         || first.overflowWrap != second.overflowWrap
 665         || first.nbspMode != second.nbspMode
 666         || first.lineBreak != second.lineBreak
 667         || first.textSecurity != second.textSecurity
 668         || first.hyphens != second.hyphens
 669         || first.hyphenationLimitBefore != second.hyphenationLimitBefore
 670         || first.hyphenationLimitAfter != second.hyphenationLimitAfter
 671         || first.hyphenationString != second.hyphenationString
 672         || first.rubyPosition != second.rubyPosition
 673         || first.textEmphasisMark != second.textEmphasisMark
 674         || first.textEmphasisPosition != second.textEmphasisPosition
 675         || first.textEmphasisCustomMark != second.textEmphasisCustomMark
 676         || first.textOrientation != second.textOrientation
 677         || first.tabSize != second.tabSize
 678         || first.lineBoxContain != second.lineBoxContain
 679         || first.lineGrid != second.lineGrid
 680 #if ENABLE(CSS_IMAGE_ORIENTATION)
 681         || first.imageOrientation != second.imageOrientation
 682 #endif
 683 #if ENABLE(CSS_IMAGE_RESOLUTION)
 684         || first.imageResolutionSource != second.imageResolutionSource
 685         || first.imageResolutionSnap != second.imageResolutionSnap
 686         || first.imageResolution != second.imageResolution
 687 #endif
 688         || first.lineSnap != second.lineSnap
 689         || first.lineAlign != second.lineAlign
 690         || first.hangingPunctuation != second.hangingPunctuation
<a name="7" id="anc7"></a><span class="line-modified"> 691 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
 692         || first.useTouchOverflowScrolling != second.useTouchOverflowScrolling
 693 #endif
 694         || first.listStyleImage != second.listStyleImage) // FIXME: needs arePointingToEqualData()?
 695         return true;
 696 
 697     if (first.textStrokeWidth != second.textStrokeWidth)
 698         return true;
 699 
 700     // These properties affect the cached stroke bounding box rects.
 701     if (first.capStyle != second.capStyle
 702         || first.joinStyle != second.joinStyle
 703         || first.strokeWidth != second.strokeWidth
 704         || first.miterLimit != second.miterLimit)
 705         return true;
 706 
 707     if (!arePointingToEqualData(first.quotes, second.quotes))
 708         return true;
 709 
 710     return false;
 711 }
 712 
 713 bool RenderStyle::changeRequiresLayout(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
 714 {
 715     if (m_boxData.ptr() != other.m_boxData.ptr()) {
 716         if (m_boxData-&gt;width() != other.m_boxData-&gt;width()
 717             || m_boxData-&gt;minWidth() != other.m_boxData-&gt;minWidth()
 718             || m_boxData-&gt;maxWidth() != other.m_boxData-&gt;maxWidth()
 719             || m_boxData-&gt;height() != other.m_boxData-&gt;height()
 720             || m_boxData-&gt;minHeight() != other.m_boxData-&gt;minHeight()
 721             || m_boxData-&gt;maxHeight() != other.m_boxData-&gt;maxHeight())
 722             return true;
 723 
 724         if (m_boxData-&gt;verticalAlign() != other.m_boxData-&gt;verticalAlign())
 725             return true;
 726 
 727         if (m_boxData-&gt;boxSizing() != other.m_boxData-&gt;boxSizing())
 728             return true;
 729     }
 730 
 731     if (m_surroundData-&gt;margin != other.m_surroundData-&gt;margin)
 732         return true;
 733 
 734     if (m_surroundData-&gt;padding != other.m_surroundData-&gt;padding)
 735         return true;
 736 
 737     // FIXME: We should add an optimized form of layout that just recomputes visual overflow.
 738     if (changeAffectsVisualOverflow(other))
 739         return true;
 740 
 741     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
 742         &amp;&amp; rareNonInheritedDataChangeRequiresLayout(*m_rareNonInheritedData, *other.m_rareNonInheritedData, changedContextSensitiveProperties))
 743         return true;
 744 
 745     if (m_rareInheritedData.ptr() != other.m_rareInheritedData.ptr()
 746         &amp;&amp; rareInheritedDataChangeRequiresLayout(*m_rareInheritedData, *other.m_rareInheritedData))
 747         return true;
 748 
 749     if (m_inheritedData.ptr() != other.m_inheritedData.ptr()) {
 750         if (m_inheritedData-&gt;lineHeight != other.m_inheritedData-&gt;lineHeight
 751 #if ENABLE(TEXT_AUTOSIZING)
 752             || m_inheritedData-&gt;specifiedLineHeight != other.m_inheritedData-&gt;specifiedLineHeight
 753 #endif
 754             || m_inheritedData-&gt;fontCascade != other.m_inheritedData-&gt;fontCascade
 755             || m_inheritedData-&gt;horizontalBorderSpacing != other.m_inheritedData-&gt;horizontalBorderSpacing
 756             || m_inheritedData-&gt;verticalBorderSpacing != other.m_inheritedData-&gt;verticalBorderSpacing)
 757             return true;
 758     }
 759 
 760     if (m_inheritedFlags.boxDirection != other.m_inheritedFlags.boxDirection
 761         || m_inheritedFlags.rtlOrdering != other.m_inheritedFlags.rtlOrdering
 762         || m_nonInheritedFlags.position != other.m_nonInheritedFlags.position
 763         || m_nonInheritedFlags.floating != other.m_nonInheritedFlags.floating
 764         || m_nonInheritedFlags.originalDisplay != other.m_nonInheritedFlags.originalDisplay
 765         || m_nonInheritedFlags.verticalAlign != other.m_nonInheritedFlags.verticalAlign)
 766         return true;
 767 
 768     if (static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.effectiveDisplay) &gt;= DisplayType::Table) {
 769         if (m_inheritedFlags.borderCollapse != other.m_inheritedFlags.borderCollapse
 770             || m_inheritedFlags.emptyCells != other.m_inheritedFlags.emptyCells
 771             || m_inheritedFlags.captionSide != other.m_inheritedFlags.captionSide
 772             || m_nonInheritedFlags.tableLayout != other.m_nonInheritedFlags.tableLayout)
 773             return true;
 774 
 775         // In the collapsing border model, &#39;hidden&#39; suppresses other borders, while &#39;none&#39;
 776         // does not, so these style differences can be width differences.
 777         if (m_inheritedFlags.borderCollapse
 778             &amp;&amp; ((borderTopStyle() == BorderStyle::Hidden &amp;&amp; other.borderTopStyle() == BorderStyle::None)
 779                 || (borderTopStyle() == BorderStyle::None &amp;&amp; other.borderTopStyle() == BorderStyle::Hidden)
 780                 || (borderBottomStyle() == BorderStyle::Hidden &amp;&amp; other.borderBottomStyle() == BorderStyle::None)
 781                 || (borderBottomStyle() == BorderStyle::None &amp;&amp; other.borderBottomStyle() == BorderStyle::Hidden)
 782                 || (borderLeftStyle() == BorderStyle::Hidden &amp;&amp; other.borderLeftStyle() == BorderStyle::None)
 783                 || (borderLeftStyle() == BorderStyle::None &amp;&amp; other.borderLeftStyle() == BorderStyle::Hidden)
 784                 || (borderRightStyle() == BorderStyle::Hidden &amp;&amp; other.borderRightStyle() == BorderStyle::None)
 785                 || (borderRightStyle() == BorderStyle::None &amp;&amp; other.borderRightStyle() == BorderStyle::Hidden)))
 786             return true;
 787     }
 788 
 789     if (static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.effectiveDisplay) == DisplayType::ListItem) {
 790         if (m_inheritedFlags.listStyleType != other.m_inheritedFlags.listStyleType
 791             || m_inheritedFlags.listStylePosition != other.m_inheritedFlags.listStylePosition)
 792             return true;
 793     }
 794 
 795     if (m_inheritedFlags.textAlign != other.m_inheritedFlags.textAlign
 796         || m_inheritedFlags.textTransform != other.m_inheritedFlags.textTransform
 797         || m_inheritedFlags.direction != other.m_inheritedFlags.direction
 798         || m_inheritedFlags.whiteSpace != other.m_inheritedFlags.whiteSpace
 799         || m_nonInheritedFlags.clear != other.m_nonInheritedFlags.clear
 800         || m_nonInheritedFlags.unicodeBidi != other.m_nonInheritedFlags.unicodeBidi)
 801         return true;
 802 
 803     // Check block flow direction.
 804     if (m_inheritedFlags.writingMode != other.m_inheritedFlags.writingMode)
 805         return true;
 806 
 807     // Overflow returns a layout hint.
 808     if (m_nonInheritedFlags.overflowX != other.m_nonInheritedFlags.overflowX
 809         || m_nonInheritedFlags.overflowY != other.m_nonInheritedFlags.overflowY)
 810         return true;
 811 
 812     // If our border widths change, then we need to layout.  Other changes to borders
 813     // only necessitate a repaint.
 814     if (borderLeftWidth() != other.borderLeftWidth()
 815         || borderTopWidth() != other.borderTopWidth()
 816         || borderBottomWidth() != other.borderBottomWidth()
 817         || borderRightWidth() != other.borderRightWidth())
 818         return true;
 819 
 820     // If the counter directives change, trigger a relayout to re-calculate counter values and rebuild the counter node tree.
 821     if (!arePointingToEqualData(m_rareNonInheritedData-&gt;counterDirectives, other.m_rareNonInheritedData-&gt;counterDirectives))
 822         return true;
 823 
 824     if ((visibility() == Visibility::Collapse) != (other.visibility() == Visibility::Collapse))
 825         return true;
 826 
 827     if (position() != PositionType::Static) {
 828         if (m_surroundData-&gt;offset != other.m_surroundData-&gt;offset) {
 829             // FIXME: We would like to use SimplifiedLayout for relative positioning, but we can&#39;t quite do that yet.
 830             // We need to make sure SimplifiedLayout can operate correctly on RenderInlines (we will need
 831             // to add a selfNeedsSimplifiedLayout bit in order to not get confused and taint every line).
 832             if (position() != PositionType::Absolute)
 833                 return true;
 834 
 835             // Optimize for the case where a positioned layer is moving but not changing size.
 836             if (!positionChangeIsMovementOnly(m_surroundData-&gt;offset, other.m_surroundData-&gt;offset, m_boxData-&gt;width()))
 837                 return true;
 838         }
 839     }
 840 
 841     bool hasFirstLineStyle = hasPseudoStyle(PseudoId::FirstLine);
 842     if (hasFirstLineStyle != other.hasPseudoStyle(PseudoId::FirstLine))
 843         return true;
 844     if (hasFirstLineStyle) {
 845         auto* firstLineStyle = getCachedPseudoStyle(PseudoId::FirstLine);
 846         if (!firstLineStyle)
 847             return true;
 848         auto* otherFirstLineStyle = other.getCachedPseudoStyle(PseudoId::FirstLine);
 849         if (!otherFirstLineStyle)
 850             return true;
 851         // FIXME: Not all first line style changes actually need layout.
 852         if (*firstLineStyle != *otherFirstLineStyle)
 853             return true;
 854     }
 855 
 856     return false;
 857 }
 858 
 859 bool RenderStyle::changeRequiresPositionedLayoutOnly(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp;) const
 860 {
 861     if (position() == PositionType::Static)
 862         return false;
 863 
 864     if (m_surroundData-&gt;offset != other.m_surroundData-&gt;offset) {
 865         // Optimize for the case where a positioned layer is moving but not changing size.
 866         if (position() == PositionType::Absolute &amp;&amp; positionChangeIsMovementOnly(m_surroundData-&gt;offset, other.m_surroundData-&gt;offset, m_boxData-&gt;width()))
 867             return true;
 868     }
 869 
 870     return false;
 871 }
 872 
 873 static bool rareNonInheritedDataChangeRequiresLayerRepaint(const StyleRareNonInheritedData&amp; first, const StyleRareNonInheritedData&amp; second, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties)
 874 {
 875 #if ENABLE(CSS_COMPOSITING)
 876     if (first.effectiveBlendMode != second.effectiveBlendMode)
 877         return true;
 878 #endif
 879 
 880     if (first.opacity != second.opacity) {
 881         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Opacity);
 882         // Don&#39;t return true; keep looking for another change.
 883     }
 884 
 885     if (first.filter != second.filter) {
 886         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Filter);
 887         // Don&#39;t return true; keep looking for another change.
 888     }
 889 
 890 #if ENABLE(FILTERS_LEVEL_2)
 891     if (first.backdropFilter != second.backdropFilter) {
 892         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Filter);
 893         // Don&#39;t return true; keep looking for another change.
 894     }
 895 #endif
 896 
 897     if (first.mask != second.mask || first.maskBoxImage != second.maskBoxImage)
 898         return true;
 899 
 900     return false;
 901 }
 902 
 903 bool RenderStyle::changeRequiresLayerRepaint(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
 904 {
 905     // StyleResolver has ensured that zIndex is non-auto only if it&#39;s applicable.
 906     if (m_boxData-&gt;zIndex() != other.m_boxData-&gt;zIndex() || m_boxData-&gt;hasAutoZIndex() != other.m_boxData-&gt;hasAutoZIndex())
 907         return true;
 908 
 909     if (position() != PositionType::Static) {
 910         if (m_visualData-&gt;clip != other.m_visualData-&gt;clip || m_visualData-&gt;hasClip != other.m_visualData-&gt;hasClip) {
 911             changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::ClipRect);
 912             return true;
 913         }
 914     }
 915 
 916     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
 917         &amp;&amp; rareNonInheritedDataChangeRequiresLayerRepaint(*m_rareNonInheritedData, *other.m_rareNonInheritedData, changedContextSensitiveProperties))
 918         return true;
 919 
 920     return false;
 921 }
 922 
 923 static bool requiresPainting(const RenderStyle&amp; style)
 924 {
 925     if (style.visibility() == Visibility::Hidden)
 926         return false;
 927     if (!style.opacity())
 928         return false;
 929     return true;
 930 }
 931 
 932 static bool rareNonInheritedDataChangeRequiresRepaint(const StyleRareNonInheritedData&amp; first, const StyleRareNonInheritedData&amp; second, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties)
 933 {
 934     if (first.userDrag != second.userDrag
 935         || first.borderFit != second.borderFit
 936         || first.objectFit != second.objectFit
 937         || first.objectPosition != second.objectPosition)
 938         return true;
 939 
 940     if (first.isNotFinal != second.isNotFinal)
 941         return true;
 942 
 943     if (first.shapeOutside != second.shapeOutside)
 944         return true;
 945 
 946     // FIXME: this should probably be moved to changeRequiresLayerRepaint().
 947     if (first.clipPath != second.clipPath) {
 948         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::ClipPath);
 949         // Don&#39;t return true; keep looking for another change.
 950     }
 951 
 952     return false;
 953 }
 954 
 955 static bool rareInheritedDataChangeRequiresRepaint(const StyleRareInheritedData&amp; first, const StyleRareInheritedData&amp; second)
 956 {
 957     return first.userModify != second.userModify
 958         || first.userSelect != second.userSelect
 959         || first.appleColorFilter != second.appleColorFilter
 960         || first.imageRendering != second.imageRendering
 961 #if ENABLE(DARK_MODE_CSS)
<a name="8" id="anc8"></a><span class="line-modified"> 962         || first.supportedColorSchemes != second.supportedColorSchemes</span>
 963 #endif
 964     ;
 965 }
 966 
 967 #if ENABLE(CSS_PAINTING_API)
 968 void RenderStyle::addCustomPaintWatchProperty(const String&amp; name)
 969 {
 970     auto&amp; data = m_rareNonInheritedData.access();
 971     if (!data.customPaintWatchedProperties)
<a name="9" id="anc9"></a><span class="line-modified"> 972         data.customPaintWatchedProperties = std::make_unique&lt;HashSet&lt;String&gt;&gt;();</span>
 973     data.customPaintWatchedProperties-&gt;add(name);
 974 }
 975 
 976 inline static bool changedCustomPaintWatchedProperty(const RenderStyle&amp; a, const StyleRareNonInheritedData&amp; aData, const RenderStyle&amp; b, const StyleRareNonInheritedData&amp; bData)
 977 {
 978     auto* propertiesA = aData.customPaintWatchedProperties.get();
 979     auto* propertiesB = bData.customPaintWatchedProperties.get();
 980 
 981     if (UNLIKELY(propertiesA || propertiesB)) {
 982         // FIXME: We should not need to use ComputedStyleExtractor here.
 983         ComputedStyleExtractor extractor((Element*) nullptr);
 984 
 985         for (auto* watchPropertiesMap : { propertiesA, propertiesB }) {
 986             if (!watchPropertiesMap)
 987                 continue;
 988 
 989             for (auto&amp; name : *watchPropertiesMap) {
 990                 RefPtr&lt;CSSValue&gt; valueA;
 991                 RefPtr&lt;CSSValue&gt; valueB;
 992                 if (isCustomPropertyName(name)) {
 993                     if (a.getCustomProperty(name))
 994                         valueA = CSSCustomPropertyValue::create(*a.getCustomProperty(name));
 995                     if (b.getCustomProperty(name))
 996                         valueB = CSSCustomPropertyValue::create(*b.getCustomProperty(name));
 997                 } else {
 998                     CSSPropertyID propertyID = cssPropertyID(name);
 999                     if (!propertyID)
1000                         continue;
<a name="10" id="anc10"></a><span class="line-modified">1001                     valueA = extractor.valueForPropertyinStyle(a, propertyID);</span>
<span class="line-modified">1002                     valueB = extractor.valueForPropertyinStyle(b, propertyID);</span>
1003                 }
1004 
1005                 if ((valueA &amp;&amp; !valueB) || (!valueA &amp;&amp; valueB))
1006                     return true;
1007 
1008                 if (!valueA)
1009                     continue;
1010 
1011                 if (!(*valueA == *valueB))
1012                     return true;
1013             }
1014         }
1015     }
1016 
1017     return false;
1018 }
1019 #endif
1020 
1021 bool RenderStyle::changeRequiresRepaint(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
1022 {
1023     if (!requiresPainting(*this) &amp;&amp; !requiresPainting(other))
1024         return false;
1025 
1026     if (m_inheritedFlags.visibility != other.m_inheritedFlags.visibility
1027         || m_inheritedFlags.printColorAdjust != other.m_inheritedFlags.printColorAdjust
1028         || m_inheritedFlags.insideLink != other.m_inheritedFlags.insideLink
1029         || m_inheritedFlags.insideDefaultButton != other.m_inheritedFlags.insideDefaultButton
1030         || m_surroundData-&gt;border != other.m_surroundData-&gt;border
1031         || !m_backgroundData-&gt;isEquivalentForPainting(*other.m_backgroundData))
1032         return true;
1033 
1034     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
1035         &amp;&amp; rareNonInheritedDataChangeRequiresRepaint(*m_rareNonInheritedData, *other.m_rareNonInheritedData, changedContextSensitiveProperties))
1036         return true;
1037 
1038     if (m_rareInheritedData.ptr() != other.m_rareInheritedData.ptr()
1039         &amp;&amp; rareInheritedDataChangeRequiresRepaint(*m_rareInheritedData, *other.m_rareInheritedData))
1040         return true;
1041 
1042 #if ENABLE(CSS_PAINTING_API)
1043     if (changedCustomPaintWatchedProperty(*this, *m_rareNonInheritedData, other, *other.m_rareNonInheritedData))
1044         return true;
1045 #endif
1046 
1047     return false;
1048 }
1049 
1050 bool RenderStyle::changeRequiresRepaintIfTextOrBorderOrOutline(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp;) const
1051 {
1052     if (m_inheritedData-&gt;color != other.m_inheritedData-&gt;color
1053         || m_inheritedFlags.textDecorations != other.m_inheritedFlags.textDecorations
1054         || m_visualData-&gt;textDecoration != other.m_visualData-&gt;textDecoration
1055         || m_rareNonInheritedData-&gt;textDecorationStyle != other.m_rareNonInheritedData-&gt;textDecorationStyle
1056         || m_rareNonInheritedData-&gt;textDecorationColor != other.m_rareNonInheritedData-&gt;textDecorationColor
1057         || m_rareInheritedData-&gt;textDecorationSkip != other.m_rareInheritedData-&gt;textDecorationSkip
1058         || m_rareInheritedData-&gt;textFillColor != other.m_rareInheritedData-&gt;textFillColor
1059         || m_rareInheritedData-&gt;textStrokeColor != other.m_rareInheritedData-&gt;textStrokeColor
1060         || m_rareInheritedData-&gt;textEmphasisColor != other.m_rareInheritedData-&gt;textEmphasisColor
1061         || m_rareInheritedData-&gt;textEmphasisFill != other.m_rareInheritedData-&gt;textEmphasisFill
1062         || m_rareInheritedData-&gt;strokeColor != other.m_rareInheritedData-&gt;strokeColor
1063         || m_rareInheritedData-&gt;caretColor != other.m_rareInheritedData-&gt;caretColor)
1064         return true;
1065 
1066     return false;
1067 }
1068 
1069 bool RenderStyle::changeRequiresRecompositeLayer(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp;) const
1070 {
1071     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()) {
1072         if (m_rareNonInheritedData-&gt;transformStyle3D != other.m_rareNonInheritedData-&gt;transformStyle3D
1073             || m_rareNonInheritedData-&gt;backfaceVisibility != other.m_rareNonInheritedData-&gt;backfaceVisibility
1074             || m_rareNonInheritedData-&gt;perspective != other.m_rareNonInheritedData-&gt;perspective
1075             || m_rareNonInheritedData-&gt;perspectiveOriginX != other.m_rareNonInheritedData-&gt;perspectiveOriginX
1076             || m_rareNonInheritedData-&gt;perspectiveOriginY != other.m_rareNonInheritedData-&gt;perspectiveOriginY)
1077             return true;
1078     }
1079 
1080     return false;
1081 }
1082 
1083 StyleDifference RenderStyle::diff(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
1084 {
1085     changedContextSensitiveProperties = OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;();
1086 
1087     StyleDifference svgChange = StyleDifference::Equal;
1088     if (m_svgStyle != other.m_svgStyle) {
1089         svgChange = m_svgStyle-&gt;diff(other.m_svgStyle.get());
1090         if (svgChange == StyleDifference::Layout)
1091             return svgChange;
1092     }
1093 
1094     if (changeRequiresLayout(other, changedContextSensitiveProperties))
1095         return StyleDifference::Layout;
1096 
1097     // SVGRenderStyle::diff() might have returned StyleDifference::Repaint, eg. if fill changes.
1098     // If eg. the font-size changed at the same time, we&#39;re not allowed to return StyleDifference::Repaint,
1099     // but have to return StyleDifference::Layout, that&#39;s why  this if branch comes after all branches
1100     // that are relevant for SVG and might return StyleDifference::Layout.
1101     if (svgChange != StyleDifference::Equal)
1102         return svgChange;
1103 
1104     if (changeRequiresPositionedLayoutOnly(other, changedContextSensitiveProperties))
1105         return StyleDifference::LayoutPositionedMovementOnly;
1106 
1107     if (changeRequiresLayerRepaint(other, changedContextSensitiveProperties))
1108         return StyleDifference::RepaintLayer;
1109 
1110     if (changeRequiresRepaint(other, changedContextSensitiveProperties))
1111         return StyleDifference::Repaint;
1112 
1113     if (changeRequiresRecompositeLayer(other, changedContextSensitiveProperties))
1114         return StyleDifference::RecompositeLayer;
1115 
1116     if (changeRequiresRepaintIfTextOrBorderOrOutline(other, changedContextSensitiveProperties))
1117         return StyleDifference::RepaintIfTextOrBorderOrOutline;
1118 
1119     // Cursors are not checked, since they will be set appropriately in response to mouse events,
1120     // so they don&#39;t need to cause any repaint or layout.
1121 
1122     // Animations don&#39;t need to be checked either.  We always set the new style on the RenderObject, so we will get a chance to fire off
1123     // the resulting transition properly.
1124     return StyleDifference::Equal;
1125 }
1126 
1127 bool RenderStyle::diffRequiresLayerRepaint(const RenderStyle&amp; style, bool isComposited) const
1128 {
1129     OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt; changedContextSensitiveProperties;
1130 
1131     if (changeRequiresRepaint(style, changedContextSensitiveProperties))
1132         return true;
1133 
1134     if (isComposited &amp;&amp; changeRequiresLayerRepaint(style, changedContextSensitiveProperties))
1135         return changedContextSensitiveProperties.contains(StyleDifferenceContextSensitiveProperty::ClipRect);
1136 
1137     return false;
1138 }
1139 
1140 void RenderStyle::setClip(Length&amp;&amp; top, Length&amp;&amp; right, Length&amp;&amp; bottom, Length&amp;&amp; left)
1141 {
1142     auto&amp; data = m_visualData.access();
1143     data.clip.top() = WTFMove(top);
1144     data.clip.right() = WTFMove(right);
1145     data.clip.bottom() = WTFMove(bottom);
1146     data.clip.left() = WTFMove(left);
1147 }
1148 
1149 void RenderStyle::addCursor(RefPtr&lt;StyleImage&gt;&amp;&amp; image, const IntPoint&amp; hotSpot)
1150 {
1151     auto&amp; cursorData = m_rareInheritedData.access().cursorData;
1152     if (!cursorData)
1153         cursorData = CursorList::create();
1154     cursorData-&gt;append(CursorData(WTFMove(image), hotSpot));
1155 }
1156 
1157 void RenderStyle::setCursorList(RefPtr&lt;CursorList&gt;&amp;&amp; list)
1158 {
1159     m_rareInheritedData.access().cursorData = WTFMove(list);
1160 }
1161 
1162 void RenderStyle::setQuotes(RefPtr&lt;QuotesData&gt;&amp;&amp; q)
1163 {
1164     if (m_rareInheritedData-&gt;quotes == q || (m_rareInheritedData-&gt;quotes &amp;&amp; q &amp;&amp; *m_rareInheritedData-&gt;quotes == *q))
1165         return;
1166 
1167     m_rareInheritedData.access().quotes = WTFMove(q);
1168 }
1169 
1170 void RenderStyle::setWillChange(RefPtr&lt;WillChangeData&gt;&amp;&amp; willChangeData)
1171 {
1172     if (arePointingToEqualData(m_rareNonInheritedData-&gt;willChange.get(), willChangeData.get()))
1173         return;
1174 
1175     m_rareNonInheritedData.access().willChange = WTFMove(willChangeData);
1176 }
1177 
1178 void RenderStyle::clearCursorList()
1179 {
1180     if (m_rareInheritedData-&gt;cursorData)
1181         m_rareInheritedData.access().cursorData = nullptr;
1182 }
1183 
1184 void RenderStyle::clearContent()
1185 {
1186     if (m_rareNonInheritedData-&gt;content)
1187         m_rareNonInheritedData.access().content = nullptr;
1188 }
1189 
1190 static inline ContentData&amp; lastContent(ContentData&amp; firstContent)
1191 {
1192     auto* lastContent = &amp;firstContent;
1193     for (auto* content = &amp;firstContent; content; content = content-&gt;next())
1194         lastContent = content;
1195     return *lastContent;
1196 }
1197 
1198 void RenderStyle::setContent(std::unique_ptr&lt;ContentData&gt; contentData, bool add)
1199 {
1200     auto&amp; data = m_rareNonInheritedData.access();
1201     if (add &amp;&amp; data.content)
1202         lastContent(*data.content).setNext(WTFMove(contentData));
1203     else {
1204         data.content = WTFMove(contentData);
1205         auto&amp; altText = data.altText;
1206         if (!altText.isNull())
1207             data.content-&gt;setAltText(altText);
1208     }
1209 }
1210 
1211 void RenderStyle::setContent(RefPtr&lt;StyleImage&gt;&amp;&amp; image, bool add)
1212 {
1213     if (!image)
1214         return;
<a name="11" id="anc11"></a><span class="line-modified">1215     setContent(std::make_unique&lt;ImageContentData&gt;(image.releaseNonNull()), add);</span>
1216 }
1217 
1218 void RenderStyle::setContent(const String&amp; string, bool add)
1219 {
1220     auto&amp; data = m_rareNonInheritedData.access();
1221     if (add &amp;&amp; data.content) {
1222         auto&amp; last = lastContent(*data.content);
1223         if (!is&lt;TextContentData&gt;(last))
<a name="12" id="anc12"></a><span class="line-modified">1224             last.setNext(std::make_unique&lt;TextContentData&gt;(string));</span>
1225         else {
1226             auto&amp; textContent = downcast&lt;TextContentData&gt;(last);
1227             textContent.setText(textContent.text() + string);
1228         }
1229     } else {
<a name="13" id="anc13"></a><span class="line-modified">1230         data.content = std::make_unique&lt;TextContentData&gt;(string);</span>
1231         auto&amp; altText = data.altText;
1232         if (!altText.isNull())
1233             data.content-&gt;setAltText(altText);
1234     }
1235 }
1236 
1237 void RenderStyle::setContent(std::unique_ptr&lt;CounterContent&gt; counter, bool add)
1238 {
1239     if (!counter)
1240         return;
<a name="14" id="anc14"></a><span class="line-modified">1241     setContent(std::make_unique&lt;CounterContentData&gt;(WTFMove(counter)), add);</span>
1242 }
1243 
1244 void RenderStyle::setContent(QuoteType quote, bool add)
1245 {
<a name="15" id="anc15"></a><span class="line-modified">1246     setContent(std::make_unique&lt;QuoteContentData&gt;(quote), add);</span>
1247 }
1248 
1249 void RenderStyle::setContentAltText(const String&amp; string)
1250 {
1251     auto&amp; data = m_rareNonInheritedData.access();
1252     data.altText = string;
1253     if (data.content)
1254         data.content-&gt;setAltText(string);
1255 }
1256 
1257 const String&amp; RenderStyle::contentAltText() const
1258 {
1259     return m_rareNonInheritedData-&gt;altText;
1260 }
1261 
1262 void RenderStyle::setHasAttrContent()
1263 {
1264     setUnique();
1265     SET_VAR(m_rareNonInheritedData, hasAttrContent, true);
1266 }
1267 
1268 static inline bool requireTransformOrigin(const Vector&lt;RefPtr&lt;TransformOperation&gt;&gt;&amp; transformOperations, RenderStyle::ApplyTransformOrigin applyOrigin)
1269 {
1270     // The transform-origin property brackets the transform with translate operations.
1271     // When the only transform is a translation, the transform-origin is irrelevant.
1272 
1273     if (applyOrigin != RenderStyle::IncludeTransformOrigin)
1274         return false;
1275 
1276     for (auto&amp; operation : transformOperations) {
1277         // FIXME: Use affectedByTransformOrigin().
1278         auto type = operation-&gt;type();
1279         if (type != TransformOperation::TRANSLATE
1280             &amp;&amp; type != TransformOperation::TRANSLATE_3D
1281             &amp;&amp; type != TransformOperation::TRANSLATE_X
1282             &amp;&amp; type != TransformOperation::TRANSLATE_Y
1283             &amp;&amp; type != TransformOperation::TRANSLATE_Z)
1284             return true;
1285     }
1286 
1287     return false;
1288 }
1289 
1290 void RenderStyle::applyTransform(TransformationMatrix&amp; transform, const FloatRect&amp; boundingBox, ApplyTransformOrigin applyOrigin) const
1291 {
1292     auto&amp; operations = m_rareNonInheritedData-&gt;transform-&gt;operations.operations();
1293     bool applyTransformOrigin = requireTransformOrigin(operations, applyOrigin);
1294 
1295     FloatPoint3D originTranslate;
1296     if (applyTransformOrigin) {
1297         originTranslate.setX(boundingBox.x() + floatValueForLength(transformOriginX(), boundingBox.width()));
1298         originTranslate.setY(boundingBox.y() + floatValueForLength(transformOriginY(), boundingBox.height()));
1299         originTranslate.setZ(transformOriginZ());
1300         transform.translate3d(originTranslate.x(), originTranslate.y(), originTranslate.z());
1301     }
1302 
1303     for (auto&amp; operation : operations)
1304         operation-&gt;apply(transform, boundingBox.size());
1305 
1306     if (applyTransformOrigin)
1307         transform.translate3d(-originTranslate.x(), -originTranslate.y(), -originTranslate.z());
1308 }
1309 
1310 void RenderStyle::setPageScaleTransform(float scale)
1311 {
1312     if (scale == 1)
1313         return;
1314     TransformOperations transform;
1315     transform.operations().append(ScaleTransformOperation::create(scale, scale, ScaleTransformOperation::SCALE));
1316     setTransform(transform);
1317     setTransformOriginX(Length(0, Fixed));
1318     setTransformOriginY(Length(0, Fixed));
1319 }
1320 
1321 void RenderStyle::setTextShadow(std::unique_ptr&lt;ShadowData&gt; shadowData, bool add)
1322 {
1323     ASSERT(!shadowData || (!shadowData-&gt;spread() &amp;&amp; shadowData-&gt;style() == Normal));
1324 
1325     auto&amp; rareData = m_rareInheritedData.access();
1326     if (!add) {
1327         rareData.textShadow = WTFMove(shadowData);
1328         return;
1329     }
1330 
1331     shadowData-&gt;setNext(WTFMove(rareData.textShadow));
1332     rareData.textShadow = WTFMove(shadowData);
1333 }
1334 
1335 void RenderStyle::setBoxShadow(std::unique_ptr&lt;ShadowData&gt; shadowData, bool add)
1336 {
1337     auto&amp; rareData = m_rareNonInheritedData.access();
1338     if (!add) {
1339         rareData.boxShadow = WTFMove(shadowData);
1340         return;
1341     }
1342 
1343     shadowData-&gt;setNext(WTFMove(rareData.boxShadow));
1344     rareData.boxShadow = WTFMove(shadowData);
1345 }
1346 
1347 static RoundedRect::Radii calcRadiiFor(const BorderData&amp; border, const LayoutSize&amp; size)
1348 {
1349     return {
1350         sizeForLengthSize(border.topLeft(), size),
1351         sizeForLengthSize(border.topRight(), size),
1352         sizeForLengthSize(border.bottomLeft(), size),
1353         sizeForLengthSize(border.bottomRight(), size)
1354     };
1355 }
1356 
1357 StyleImage* RenderStyle::listStyleImage() const
1358 {
1359     return m_rareInheritedData-&gt;listStyleImage.get();
1360 }
1361 
1362 void RenderStyle::setListStyleImage(RefPtr&lt;StyleImage&gt;&amp;&amp; v)
1363 {
1364     if (m_rareInheritedData-&gt;listStyleImage != v)
1365         m_rareInheritedData.access().listStyleImage = WTFMove(v);
1366 }
1367 
1368 const Color&amp; RenderStyle::color() const
1369 {
1370     return m_inheritedData-&gt;color;
1371 }
1372 
1373 const Color&amp; RenderStyle::visitedLinkColor() const
1374 {
1375     return m_inheritedData-&gt;visitedLinkColor;
1376 }
1377 
1378 void RenderStyle::setColor(const Color&amp; v)
1379 {
1380     SET_VAR(m_inheritedData, color, v);
1381 }
1382 
1383 void RenderStyle::setVisitedLinkColor(const Color&amp; v)
1384 {
1385     SET_VAR(m_inheritedData, visitedLinkColor, v);
1386 }
1387 
1388 float RenderStyle::horizontalBorderSpacing() const
1389 {
1390     return m_inheritedData-&gt;horizontalBorderSpacing;
1391 }
1392 
1393 float RenderStyle::verticalBorderSpacing() const
1394 {
1395     return m_inheritedData-&gt;verticalBorderSpacing;
1396 }
1397 
1398 void RenderStyle::setHorizontalBorderSpacing(float v)
1399 {
1400     SET_VAR(m_inheritedData, horizontalBorderSpacing, v);
1401 }
1402 
1403 void RenderStyle::setVerticalBorderSpacing(float v)
1404 {
1405     SET_VAR(m_inheritedData, verticalBorderSpacing, v);
1406 }
1407 
1408 RoundedRect RenderStyle::getRoundedBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1409 {
1410     RoundedRect roundedRect(borderRect);
1411     if (hasBorderRadius()) {
1412         RoundedRect::Radii radii = calcRadiiFor(m_surroundData-&gt;border, borderRect.size());
1413         radii.scale(calcBorderRadiiConstraintScaleFor(borderRect, radii));
1414         roundedRect.includeLogicalEdges(radii, isHorizontalWritingMode(), includeLogicalLeftEdge, includeLogicalRightEdge);
1415     }
1416     return roundedRect;
1417 }
1418 
1419 RoundedRect RenderStyle::getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1420 {
1421     bool horizontal = isHorizontalWritingMode();
<a name="16" id="anc16"></a><span class="line-modified">1422     auto leftWidth = (!horizontal || includeLogicalLeftEdge) ? borderLeftWidth() : 0;</span>
<span class="line-modified">1423     auto rightWidth = (!horizontal || includeLogicalRightEdge) ? borderRightWidth() : 0;</span>
<span class="line-modified">1424     auto topWidth = (horizontal || includeLogicalLeftEdge) ? borderTopWidth() : 0;</span>
<span class="line-modified">1425     auto bottomWidth = (horizontal || includeLogicalRightEdge) ? borderBottomWidth() : 0;</span>
1426     return getRoundedInnerBorderFor(borderRect, topWidth, bottomWidth, leftWidth, rightWidth, includeLogicalLeftEdge, includeLogicalRightEdge);
1427 }
1428 
1429 RoundedRect RenderStyle::getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, LayoutUnit topWidth, LayoutUnit bottomWidth,
1430     LayoutUnit leftWidth, LayoutUnit rightWidth, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1431 {
1432     RoundedRect roundedRect { { borderRect.x() + leftWidth, borderRect.y() + topWidth,
1433         borderRect.width() - leftWidth - rightWidth, borderRect.height() - topWidth - bottomWidth } };
1434     if (hasBorderRadius()) {
1435         auto radii = getRoundedBorderFor(borderRect).radii();
1436         radii.shrink(topWidth, bottomWidth, leftWidth, rightWidth);
1437         roundedRect.includeLogicalEdges(radii, isHorizontalWritingMode(), includeLogicalLeftEdge, includeLogicalRightEdge);
1438     }
1439     return roundedRect;
1440 }
1441 
1442 static bool allLayersAreFixed(const FillLayer&amp; layers)
1443 {
1444     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1445         if (!(layer-&gt;image() &amp;&amp; layer-&gt;attachment() == FillAttachment::FixedBackground))
1446             return false;
1447     }
1448     return true;
1449 }
1450 
1451 bool RenderStyle::hasEntirelyFixedBackground() const
1452 {
1453     return allLayersAreFixed(backgroundLayers());
1454 }
1455 
1456 const CounterDirectiveMap* RenderStyle::counterDirectives() const
1457 {
1458     return m_rareNonInheritedData-&gt;counterDirectives.get();
1459 }
1460 
1461 CounterDirectiveMap&amp; RenderStyle::accessCounterDirectives()
1462 {
1463     auto&amp; map = m_rareNonInheritedData.access().counterDirectives;
1464     if (!map)
<a name="17" id="anc17"></a><span class="line-modified">1465         map = std::make_unique&lt;CounterDirectiveMap&gt;();</span>
1466     return *map;
1467 }
1468 
<a name="18" id="anc18"></a><span class="line-modified">1469 const AtomicString&amp; RenderStyle::hyphenString() const</span>
1470 {
1471     ASSERT(hyphens() != Hyphens::None);
1472 
1473     auto&amp; hyphenationString = m_rareInheritedData-&gt;hyphenationString;
1474     if (!hyphenationString.isNull())
1475         return hyphenationString;
1476 
1477     // FIXME: This should depend on locale.
<a name="19" id="anc19"></a><span class="line-modified">1478     static NeverDestroyed&lt;AtomicString&gt; hyphenMinusString(&amp;hyphenMinus, 1);</span>
<span class="line-modified">1479     static NeverDestroyed&lt;AtomicString&gt; hyphenString(&amp;hyphen, 1);</span>
1480     return fontCascade().primaryFont().glyphForCharacter(hyphen) ? hyphenString : hyphenMinusString;
1481 }
1482 
<a name="20" id="anc20"></a><span class="line-modified">1483 const AtomicString&amp; RenderStyle::textEmphasisMarkString() const</span>
1484 {
1485     switch (textEmphasisMark()) {
1486     case TextEmphasisMark::None:
1487         return nullAtom();
1488     case TextEmphasisMark::Custom:
1489         return textEmphasisCustomMark();
1490     case TextEmphasisMark::Dot: {
<a name="21" id="anc21"></a><span class="line-modified">1491         static NeverDestroyed&lt;AtomicString&gt; filledDotString(&amp;bullet, 1);</span>
<span class="line-modified">1492         static NeverDestroyed&lt;AtomicString&gt; openDotString(&amp;whiteBullet, 1);</span>
1493         return textEmphasisFill() == TextEmphasisFill::Filled ? filledDotString : openDotString;
1494     }
1495     case TextEmphasisMark::Circle: {
<a name="22" id="anc22"></a><span class="line-modified">1496         static NeverDestroyed&lt;AtomicString&gt; filledCircleString(&amp;blackCircle, 1);</span>
<span class="line-modified">1497         static NeverDestroyed&lt;AtomicString&gt; openCircleString(&amp;whiteCircle, 1);</span>
1498         return textEmphasisFill() == TextEmphasisFill::Filled ? filledCircleString : openCircleString;
1499     }
1500     case TextEmphasisMark::DoubleCircle: {
<a name="23" id="anc23"></a><span class="line-modified">1501         static NeverDestroyed&lt;AtomicString&gt; filledDoubleCircleString(&amp;fisheye, 1);</span>
<span class="line-modified">1502         static NeverDestroyed&lt;AtomicString&gt; openDoubleCircleString(&amp;bullseye, 1);</span>
1503         return textEmphasisFill() == TextEmphasisFill::Filled ? filledDoubleCircleString : openDoubleCircleString;
1504     }
1505     case TextEmphasisMark::Triangle: {
<a name="24" id="anc24"></a><span class="line-modified">1506         static NeverDestroyed&lt;AtomicString&gt; filledTriangleString(&amp;blackUpPointingTriangle, 1);</span>
<span class="line-modified">1507         static NeverDestroyed&lt;AtomicString&gt; openTriangleString(&amp;whiteUpPointingTriangle, 1);</span>
1508         return textEmphasisFill() == TextEmphasisFill::Filled ? filledTriangleString : openTriangleString;
1509     }
1510     case TextEmphasisMark::Sesame: {
<a name="25" id="anc25"></a><span class="line-modified">1511         static NeverDestroyed&lt;AtomicString&gt; filledSesameString(&amp;sesameDot, 1);</span>
<span class="line-modified">1512         static NeverDestroyed&lt;AtomicString&gt; openSesameString(&amp;whiteSesameDot, 1);</span>
1513         return textEmphasisFill() == TextEmphasisFill::Filled ? filledSesameString : openSesameString;
1514     }
1515     case TextEmphasisMark::Auto:
1516         ASSERT_NOT_REACHED();
1517         return nullAtom();
1518     }
1519 
1520     ASSERT_NOT_REACHED();
1521     return nullAtom();
1522 }
1523 
<a name="26" id="anc26"></a><span class="line-removed">1524 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">1525 </span>
<span class="line-removed">1526 const Vector&lt;StyleDashboardRegion&gt;&amp; RenderStyle::initialDashboardRegions()</span>
<span class="line-removed">1527 {</span>
<span class="line-removed">1528     static NeverDestroyed&lt;Vector&lt;StyleDashboardRegion&gt;&gt; emptyList;</span>
<span class="line-removed">1529     return emptyList;</span>
<span class="line-removed">1530 }</span>
<span class="line-removed">1531 </span>
<span class="line-removed">1532 const Vector&lt;StyleDashboardRegion&gt;&amp; RenderStyle::noneDashboardRegions()</span>
<span class="line-removed">1533 {</span>
<span class="line-removed">1534     static NeverDestroyed&lt;Vector&lt;StyleDashboardRegion&gt;&gt; noneList;</span>
<span class="line-removed">1535     static bool noneListInitialized = false;</span>
<span class="line-removed">1536     if (!noneListInitialized) {</span>
<span class="line-removed">1537         noneList.get().append(StyleDashboardRegion { emptyString(), { }, StyleDashboardRegion::None });</span>
<span class="line-removed">1538         noneListInitialized = true;</span>
<span class="line-removed">1539     }</span>
<span class="line-removed">1540     return noneList;</span>
<span class="line-removed">1541 }</span>
<span class="line-removed">1542 </span>
<span class="line-removed">1543 #endif</span>
<span class="line-removed">1544 </span>
1545 void RenderStyle::adjustAnimations()
1546 {
1547     auto* animationList = m_rareNonInheritedData-&gt;animations.get();
1548     if (!animationList)
1549         return;
1550 
1551     // Get rid of empty animations and anything beyond them
1552     for (size_t i = 0, size = animationList-&gt;size(); i &lt; size; ++i) {
1553         if (animationList-&gt;animation(i).isEmpty()) {
1554             animationList-&gt;resize(i);
1555             break;
1556         }
1557     }
1558 
1559     if (animationList-&gt;isEmpty()) {
1560         clearAnimations();
1561         return;
1562     }
1563 
1564     // Repeat patterns into layers that don&#39;t have some properties set.
1565     animationList-&gt;fillUnsetProperties();
1566 }
1567 
1568 void RenderStyle::adjustTransitions()
1569 {
1570     auto* transitionList = m_rareNonInheritedData-&gt;transitions.get();
1571     if (!transitionList)
1572         return;
1573 
1574     // Get rid of empty transitions and anything beyond them
1575     for (size_t i = 0, size = transitionList-&gt;size(); i &lt; size; ++i) {
1576         if (transitionList-&gt;animation(i).isEmpty()) {
1577             transitionList-&gt;resize(i);
1578             break;
1579         }
1580     }
1581 
1582     if (transitionList-&gt;isEmpty()) {
1583         clearTransitions();
1584         return;
1585     }
1586 
1587     // Repeat patterns into layers that don&#39;t have some properties set.
1588     transitionList-&gt;fillUnsetProperties();
1589 
1590     // Make sure there are no duplicate properties.
1591     // This is an O(n^2) algorithm but the lists tend to be short, so it is probably OK.
1592     for (size_t i = 0; i &lt; transitionList-&gt;size(); ++i) {
1593         for (size_t j = i + 1; j &lt; transitionList-&gt;size(); ++j) {
1594             if (transitionList-&gt;animation(i).property() == transitionList-&gt;animation(j).property()) {
1595                 // toss i
1596                 transitionList-&gt;remove(i);
1597                 j = i;
1598             }
1599         }
1600     }
1601 }
1602 
1603 AnimationList&amp; RenderStyle::ensureAnimations()
1604 {
1605     if (!m_rareNonInheritedData.access().animations)
<a name="27" id="anc27"></a><span class="line-modified">1606         m_rareNonInheritedData.access().animations = std::make_unique&lt;AnimationList&gt;();</span>
1607     return *m_rareNonInheritedData-&gt;animations;
1608 }
1609 
1610 AnimationList&amp; RenderStyle::ensureTransitions()
1611 {
1612     if (!m_rareNonInheritedData.access().transitions)
<a name="28" id="anc28"></a><span class="line-modified">1613         m_rareNonInheritedData.access().transitions = std::make_unique&lt;AnimationList&gt;();</span>
1614     return *m_rareNonInheritedData-&gt;transitions;
1615 }
1616 
1617 const Animation* RenderStyle::transitionForProperty(CSSPropertyID property) const
1618 {
1619     auto* transitions = this-&gt;transitions();
1620     if (!transitions)
1621         return nullptr;
1622     for (size_t i = 0, size = transitions-&gt;size(); i &lt; size; ++i) {
1623         auto&amp; animation = transitions-&gt;animation(i);
1624         if (animation.animationMode() == Animation::AnimateAll || animation.property() == property)
1625             return &amp;animation;
1626     }
1627     return nullptr;
1628 }
1629 
1630 const FontCascade&amp; RenderStyle::fontCascade() const
1631 {
1632     return m_inheritedData-&gt;fontCascade;
1633 }
1634 
1635 const FontMetrics&amp; RenderStyle::fontMetrics() const
1636 {
1637     return m_inheritedData-&gt;fontCascade.fontMetrics();
1638 }
1639 
1640 const FontCascadeDescription&amp; RenderStyle::fontDescription() const
1641 {
1642     return m_inheritedData-&gt;fontCascade.fontDescription();
1643 }
1644 
1645 float RenderStyle::specifiedFontSize() const
1646 {
1647     return fontDescription().specifiedSize();
1648 }
1649 
1650 float RenderStyle::computedFontSize() const
1651 {
1652     return fontDescription().computedSize();
1653 }
1654 
1655 unsigned RenderStyle::computedFontPixelSize() const
1656 {
1657     return fontDescription().computedPixelSize();
1658 }
1659 
1660 const Length&amp; RenderStyle::wordSpacing() const
1661 {
1662     return m_rareInheritedData-&gt;wordSpacing;
1663 }
1664 
1665 float RenderStyle::letterSpacing() const
1666 {
1667     return m_inheritedData-&gt;fontCascade.letterSpacing();
1668 }
1669 
1670 bool RenderStyle::setFontDescription(FontCascadeDescription&amp;&amp; description)
1671 {
1672     if (m_inheritedData-&gt;fontCascade.fontDescription() == description)
1673         return false;
1674     auto&amp; cascade = m_inheritedData.access().fontCascade;
1675     cascade = { WTFMove(description), cascade.letterSpacing(), cascade.wordSpacing() };
1676     return true;
1677 }
1678 
1679 const Length&amp; RenderStyle::specifiedLineHeight() const
1680 {
1681 #if ENABLE(TEXT_AUTOSIZING)
1682     return m_inheritedData-&gt;specifiedLineHeight;
1683 #else
1684     return m_inheritedData-&gt;lineHeight;
1685 #endif
1686 }
1687 
1688 #if ENABLE(TEXT_AUTOSIZING)
1689 
1690 void RenderStyle::setSpecifiedLineHeight(Length&amp;&amp; height)
1691 {
1692     SET_VAR(m_inheritedData, specifiedLineHeight, WTFMove(height));
1693 }
1694 
1695 #endif
1696 
1697 const Length&amp; RenderStyle::lineHeight() const
1698 {
1699     return m_inheritedData-&gt;lineHeight;
1700 }
1701 
1702 void RenderStyle::setLineHeight(Length&amp;&amp; height)
1703 {
1704     SET_VAR(m_inheritedData, lineHeight, WTFMove(height));
1705 }
1706 
1707 int RenderStyle::computedLineHeight() const
1708 {
1709     const Length&amp; lh = lineHeight();
1710 
1711     // Negative value means the line height is not set. Use the font&#39;s built-in spacing.
1712     if (lh.isNegative())
1713         return fontMetrics().lineSpacing();
1714 
1715     if (lh.isPercentOrCalculated())
1716         return minimumValueForLength(lh, computedFontPixelSize());
1717 
1718     return clampTo&lt;int&gt;(lh.value());
1719 }
1720 
1721 void RenderStyle::setWordSpacing(Length&amp;&amp; value)
1722 {
1723     float fontWordSpacing;
1724     switch (value.type()) {
1725     case Auto:
1726         fontWordSpacing = 0;
1727         break;
1728     case Percent:
1729         fontWordSpacing = value.percent() * fontCascade().spaceWidth() / 100;
1730         break;
1731     case Fixed:
1732         fontWordSpacing = value.value();
1733         break;
1734     case Calculated:
1735         fontWordSpacing = value.nonNanCalculatedValue(maxValueForCssLength);
1736         break;
1737     default:
1738         ASSERT_NOT_REACHED();
1739         fontWordSpacing = 0;
1740         break;
1741     }
1742     m_inheritedData.access().fontCascade.setWordSpacing(fontWordSpacing);
1743     m_rareInheritedData.access().wordSpacing = WTFMove(value);
1744 }
1745 
1746 void RenderStyle::setLetterSpacing(float v) { m_inheritedData.access().fontCascade.setLetterSpacing(v); }
1747 
1748 void RenderStyle::setFontSize(float size)
1749 {
1750     // size must be specifiedSize if Text Autosizing is enabled, but computedSize if text
1751     // zoom is enabled (if neither is enabled it&#39;s irrelevant as they&#39;re probably the same).
1752 
1753     ASSERT(std::isfinite(size));
1754     if (!std::isfinite(size) || size &lt; 0)
1755         size = 0;
1756     else
1757         size = std::min(maximumAllowedFontSize, size);
1758 
1759     FontSelector* currentFontSelector = fontCascade().fontSelector();
1760     auto description = fontDescription();
1761     description.setSpecifiedSize(size);
1762     description.setComputedSize(size);
1763 
1764     setFontDescription(WTFMove(description));
1765     fontCascade().update(currentFontSelector);
1766 }
1767 
1768 #if ENABLE(VARIATION_FONTS)
1769 void RenderStyle::setFontVariationSettings(FontVariationSettings settings)
1770 {
1771     FontSelector* currentFontSelector = fontCascade().fontSelector();
1772     auto description = fontDescription();
1773     description.setVariationSettings(WTFMove(settings));
1774 
1775     setFontDescription(WTFMove(description));
1776     fontCascade().update(currentFontSelector);
1777 }
1778 #endif
1779 
1780 void RenderStyle::setFontWeight(FontSelectionValue value)
1781 {
1782     FontSelector* currentFontSelector = fontCascade().fontSelector();
1783     auto description = fontDescription();
1784     description.setWeight(value);
1785 
1786     setFontDescription(WTFMove(description));
1787     fontCascade().update(currentFontSelector);
1788 }
1789 
1790 void RenderStyle::setFontStretch(FontSelectionValue value)
1791 {
1792     FontSelector* currentFontSelector = fontCascade().fontSelector();
1793     auto description = fontDescription();
1794     description.setStretch(value);
1795 
1796     setFontDescription(WTFMove(description));
1797     fontCascade().update(currentFontSelector);
1798 }
1799 
1800 void RenderStyle::setFontItalic(Optional&lt;FontSelectionValue&gt; value)
1801 {
1802     FontSelector* currentFontSelector = fontCascade().fontSelector();
1803     auto description = fontDescription();
1804     description.setItalic(value);
1805 
1806     setFontDescription(WTFMove(description));
1807     fontCascade().update(currentFontSelector);
1808 }
1809 
1810 void RenderStyle::getShadowExtent(const ShadowData* shadow, LayoutUnit&amp; top, LayoutUnit&amp; right, LayoutUnit&amp; bottom, LayoutUnit&amp; left) const
1811 {
1812     top = 0;
1813     right = 0;
1814     bottom = 0;
1815     left = 0;
1816 
1817     for ( ; shadow; shadow = shadow-&gt;next()) {
1818         if (shadow-&gt;style() == Inset)
1819             continue;
1820 
1821         int extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();
1822         top = std::min&lt;LayoutUnit&gt;(top, shadow-&gt;y() - extentAndSpread);
1823         right = std::max&lt;LayoutUnit&gt;(right, shadow-&gt;x() + extentAndSpread);
1824         bottom = std::max&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() + extentAndSpread);
1825         left = std::min&lt;LayoutUnit&gt;(left, shadow-&gt;x() - extentAndSpread);
1826     }
1827 }
1828 
1829 LayoutBoxExtent RenderStyle::getShadowInsetExtent(const ShadowData* shadow) const
1830 {
1831     LayoutUnit top;
1832     LayoutUnit right;
1833     LayoutUnit bottom;
1834     LayoutUnit left;
1835 
1836     for ( ; shadow; shadow = shadow-&gt;next()) {
1837         if (shadow-&gt;style() == Normal)
1838             continue;
1839 
1840         int extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();
1841         top = std::max&lt;LayoutUnit&gt;(top, shadow-&gt;y() + extentAndSpread);
1842         right = std::min&lt;LayoutUnit&gt;(right, shadow-&gt;x() - extentAndSpread);
1843         bottom = std::min&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() - extentAndSpread);
1844         left = std::max&lt;LayoutUnit&gt;(left, shadow-&gt;x() + extentAndSpread);
1845     }
1846 
1847     return LayoutBoxExtent(WTFMove(top), WTFMove(right), WTFMove(bottom), WTFMove(left));
1848 }
1849 
1850 void RenderStyle::getShadowHorizontalExtent(const ShadowData* shadow, LayoutUnit &amp;left, LayoutUnit &amp;right) const
1851 {
1852     left = 0;
1853     right = 0;
1854 
1855     for ( ; shadow; shadow = shadow-&gt;next()) {
1856         if (shadow-&gt;style() == Inset)
1857             continue;
1858 
1859         int extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();
1860         left = std::min&lt;LayoutUnit&gt;(left, shadow-&gt;x() - extentAndSpread);
1861         right = std::max&lt;LayoutUnit&gt;(right, shadow-&gt;x() + extentAndSpread);
1862     }
1863 }
1864 
1865 void RenderStyle::getShadowVerticalExtent(const ShadowData* shadow, LayoutUnit &amp;top, LayoutUnit &amp;bottom) const
1866 {
1867     top = 0;
1868     bottom = 0;
1869 
1870     for ( ; shadow; shadow = shadow-&gt;next()) {
1871         if (shadow-&gt;style() == Inset)
1872             continue;
1873 
1874         int extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();
1875         top = std::min&lt;LayoutUnit&gt;(top, shadow-&gt;y() - extentAndSpread);
1876         bottom = std::max&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() + extentAndSpread);
1877     }
1878 }
1879 
1880 Color RenderStyle::colorIncludingFallback(CSSPropertyID colorProperty, bool visitedLink) const
1881 {
1882     Color result;
1883     BorderStyle borderStyle = BorderStyle::None;
1884     switch (colorProperty) {
1885     case CSSPropertyBackgroundColor:
1886         return visitedLink ? visitedLinkBackgroundColor() : backgroundColor(); // Background color doesn&#39;t fall back.
1887     case CSSPropertyBorderLeftColor:
1888         result = visitedLink ? visitedLinkBorderLeftColor() : borderLeftColor();
1889         borderStyle = borderLeftStyle();
1890         break;
1891     case CSSPropertyBorderRightColor:
1892         result = visitedLink ? visitedLinkBorderRightColor() : borderRightColor();
1893         borderStyle = borderRightStyle();
1894         break;
1895     case CSSPropertyBorderTopColor:
1896         result = visitedLink ? visitedLinkBorderTopColor() : borderTopColor();
1897         borderStyle = borderTopStyle();
1898         break;
1899     case CSSPropertyBorderBottomColor:
1900         result = visitedLink ? visitedLinkBorderBottomColor() : borderBottomColor();
1901         borderStyle = borderBottomStyle();
1902         break;
1903     case CSSPropertyCaretColor:
1904         result = visitedLink ? visitedLinkCaretColor() : caretColor();
1905         break;
1906     case CSSPropertyColor:
1907         result = visitedLink ? visitedLinkColor() : color();
1908         break;
1909     case CSSPropertyOutlineColor:
1910         result = visitedLink ? visitedLinkOutlineColor() : outlineColor();
1911         break;
1912     case CSSPropertyColumnRuleColor:
1913         result = visitedLink ? visitedLinkColumnRuleColor() : columnRuleColor();
1914         break;
1915     case CSSPropertyTextDecorationColor:
1916         // Text decoration color fallback is handled in RenderObject::decorationColor.
1917         return visitedLink ? visitedLinkTextDecorationColor() : textDecorationColor();
1918     case CSSPropertyWebkitTextEmphasisColor:
1919         result = visitedLink ? visitedLinkTextEmphasisColor() : textEmphasisColor();
1920         break;
1921     case CSSPropertyWebkitTextFillColor:
1922         result = visitedLink ? visitedLinkTextFillColor() : textFillColor();
1923         break;
1924     case CSSPropertyWebkitTextStrokeColor:
1925         result = visitedLink ? visitedLinkTextStrokeColor() : textStrokeColor();
1926         break;
1927     case CSSPropertyStrokeColor:
1928         result = visitedLink ? visitedLinkStrokeColor() : strokeColor();
1929         break;
1930     default:
1931         ASSERT_NOT_REACHED();
1932         break;
1933     }
1934 
1935     if (!result.isValid()) {
1936         if (!visitedLink &amp;&amp; (borderStyle == BorderStyle::Inset || borderStyle == BorderStyle::Outset || borderStyle == BorderStyle::Ridge || borderStyle == BorderStyle::Groove))
1937             result = Color(238, 238, 238);
1938         else
1939             result = visitedLink ? visitedLinkColor() : color();
1940     }
1941     return result;
1942 }
1943 
1944 Color RenderStyle::visitedDependentColor(CSSPropertyID colorProperty) const
1945 {
1946     Color unvisitedColor = colorIncludingFallback(colorProperty, false);
1947     if (insideLink() != InsideLink::InsideVisited)
1948         return unvisitedColor;
1949 
1950     Color visitedColor = colorIncludingFallback(colorProperty, true);
1951 
1952     // Text decoration color validity is preserved (checked in RenderObject::decorationColor).
1953     if (colorProperty == CSSPropertyTextDecorationColor)
1954         return visitedColor;
1955 
1956     // FIXME: Technically someone could explicitly specify the color transparent, but for now we&#39;ll just
1957     // assume that if the background color is transparent that it wasn&#39;t set. Note that it&#39;s weird that
1958     // we&#39;re returning unvisited info for a visited link, but given our restriction that the alpha values
1959     // have to match, it makes more sense to return the unvisited background color if specified than it
1960     // does to return black. This behavior matches what Firefox 4 does as well.
1961     if (colorProperty == CSSPropertyBackgroundColor &amp;&amp; visitedColor == Color::transparent)
1962         return unvisitedColor;
1963 
1964     // Take the alpha from the unvisited color, but get the RGB values from the visited color.
1965     return visitedColor.colorWithAlpha(unvisitedColor.alphaAsFloat());
1966 }
1967 
1968 Color RenderStyle::visitedDependentColorWithColorFilter(CSSPropertyID colorProperty) const
1969 {
1970     if (!hasAppleColorFilter())
1971         return visitedDependentColor(colorProperty);
1972 
1973     return colorByApplyingColorFilter(visitedDependentColor(colorProperty));
1974 }
1975 
1976 Color RenderStyle::colorByApplyingColorFilter(const Color&amp; color) const
1977 {
1978     Color transformedColor = color;
1979     appleColorFilter().transformColor(transformedColor);
1980     return transformedColor;
1981 }
1982 
1983 const BorderValue&amp; RenderStyle::borderBefore() const
1984 {
1985     switch (writingMode()) {
1986     case TopToBottomWritingMode:
1987         return borderTop();
1988     case BottomToTopWritingMode:
1989         return borderBottom();
1990     case LeftToRightWritingMode:
1991         return borderLeft();
1992     case RightToLeftWritingMode:
1993         return borderRight();
1994     }
1995     ASSERT_NOT_REACHED();
1996     return borderTop();
1997 }
1998 
1999 const BorderValue&amp; RenderStyle::borderAfter() const
2000 {
2001     switch (writingMode()) {
2002     case TopToBottomWritingMode:
2003         return borderBottom();
2004     case BottomToTopWritingMode:
2005         return borderTop();
2006     case LeftToRightWritingMode:
2007         return borderRight();
2008     case RightToLeftWritingMode:
2009         return borderLeft();
2010     }
2011     ASSERT_NOT_REACHED();
2012     return borderBottom();
2013 }
2014 
2015 const BorderValue&amp; RenderStyle::borderStart() const
2016 {
2017     if (isHorizontalWritingMode())
2018         return isLeftToRightDirection() ? borderLeft() : borderRight();
2019     return isLeftToRightDirection() ? borderTop() : borderBottom();
2020 }
2021 
2022 const BorderValue&amp; RenderStyle::borderEnd() const
2023 {
2024     if (isHorizontalWritingMode())
2025         return isLeftToRightDirection() ? borderRight() : borderLeft();
2026     return isLeftToRightDirection() ? borderBottom() : borderTop();
2027 }
2028 
2029 float RenderStyle::borderBeforeWidth() const
2030 {
2031     switch (writingMode()) {
2032     case TopToBottomWritingMode:
2033         return borderTopWidth();
2034     case BottomToTopWritingMode:
2035         return borderBottomWidth();
2036     case LeftToRightWritingMode:
2037         return borderLeftWidth();
2038     case RightToLeftWritingMode:
2039         return borderRightWidth();
2040     }
2041     ASSERT_NOT_REACHED();
2042     return borderTopWidth();
2043 }
2044 
2045 float RenderStyle::borderAfterWidth() const
2046 {
2047     switch (writingMode()) {
2048     case TopToBottomWritingMode:
2049         return borderBottomWidth();
2050     case BottomToTopWritingMode:
2051         return borderTopWidth();
2052     case LeftToRightWritingMode:
2053         return borderRightWidth();
2054     case RightToLeftWritingMode:
2055         return borderLeftWidth();
2056     }
2057     ASSERT_NOT_REACHED();
2058     return borderBottomWidth();
2059 }
2060 
2061 float RenderStyle::borderStartWidth() const
2062 {
2063     if (isHorizontalWritingMode())
2064         return isLeftToRightDirection() ? borderLeftWidth() : borderRightWidth();
2065     return isLeftToRightDirection() ? borderTopWidth() : borderBottomWidth();
2066 }
2067 
2068 float RenderStyle::borderEndWidth() const
2069 {
2070     if (isHorizontalWritingMode())
2071         return isLeftToRightDirection() ? borderRightWidth() : borderLeftWidth();
2072     return isLeftToRightDirection() ? borderBottomWidth() : borderTopWidth();
2073 }
2074 
2075 void RenderStyle::setMarginStart(Length&amp;&amp; margin)
2076 {
2077     if (isHorizontalWritingMode()) {
2078         if (isLeftToRightDirection())
2079             setMarginLeft(WTFMove(margin));
2080         else
2081             setMarginRight(WTFMove(margin));
2082     } else {
2083         if (isLeftToRightDirection())
2084             setMarginTop(WTFMove(margin));
2085         else
2086             setMarginBottom(WTFMove(margin));
2087     }
2088 }
2089 
2090 void RenderStyle::setMarginEnd(Length&amp;&amp; margin)
2091 {
2092     if (isHorizontalWritingMode()) {
2093         if (isLeftToRightDirection())
2094             setMarginRight(WTFMove(margin));
2095         else
2096             setMarginLeft(WTFMove(margin));
2097     } else {
2098         if (isLeftToRightDirection())
2099             setMarginBottom(WTFMove(margin));
2100         else
2101             setMarginTop(WTFMove(margin));
2102     }
2103 }
2104 
2105 TextEmphasisMark RenderStyle::textEmphasisMark() const
2106 {
2107     auto mark = static_cast&lt;TextEmphasisMark&gt;(m_rareInheritedData-&gt;textEmphasisMark);
2108     if (mark != TextEmphasisMark::Auto)
2109         return mark;
2110     if (isHorizontalWritingMode())
2111         return TextEmphasisMark::Dot;
2112     return TextEmphasisMark::Sesame;
2113 }
2114 
2115 #if ENABLE(TOUCH_EVENTS)
2116 
2117 Color RenderStyle::initialTapHighlightColor()
2118 {
2119     return RenderTheme::tapHighlightColor();
2120 }
2121 
2122 #endif
2123 
2124 LayoutBoxExtent RenderStyle::imageOutsets(const NinePieceImage&amp; image) const
2125 {
<a name="29" id="anc29"></a><span class="line-modified">2126     return LayoutBoxExtent(NinePieceImage::computeOutset(image.outset().top(), borderTopWidth()),</span>
<span class="line-modified">2127                            NinePieceImage::computeOutset(image.outset().right(), borderRightWidth()),</span>
<span class="line-modified">2128                            NinePieceImage::computeOutset(image.outset().bottom(), borderBottomWidth()),</span>
<span class="line-modified">2129                            NinePieceImage::computeOutset(image.outset().left(), borderLeftWidth()));</span>


2130 }
2131 
2132 std::pair&lt;FontOrientation, NonCJKGlyphOrientation&gt; RenderStyle::fontAndGlyphOrientation()
2133 {
2134     // FIXME: TextOrientationSideways should map to sideways-left in vertical-lr, which is not supported yet.
2135 
2136     if (isHorizontalWritingMode())
2137         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2138 
2139     switch (textOrientation()) {
2140     case TextOrientation::Mixed:
2141         return { FontOrientation::Vertical, NonCJKGlyphOrientation::Mixed };
2142     case TextOrientation::Upright:
2143         return { FontOrientation::Vertical, NonCJKGlyphOrientation::Upright };
2144     case TextOrientation::Sideways:
2145         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2146     default:
2147         ASSERT_NOT_REACHED();
2148         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2149     }
2150 }
2151 
2152 void RenderStyle::setBorderImageSource(RefPtr&lt;StyleImage&gt;&amp;&amp; image)
2153 {
2154     if (m_surroundData-&gt;border.m_image.image() == image.get())
2155         return;
2156     m_surroundData.access().border.m_image.setImage(WTFMove(image));
2157 }
2158 
2159 void RenderStyle::setBorderImageSlices(LengthBox&amp;&amp; slices)
2160 {
2161     if (m_surroundData-&gt;border.m_image.imageSlices() == slices)
2162         return;
2163     m_surroundData.access().border.m_image.setImageSlices(WTFMove(slices));
2164 }
2165 
2166 void RenderStyle::setBorderImageWidth(LengthBox&amp;&amp; slices)
2167 {
2168     if (m_surroundData-&gt;border.m_image.borderSlices() == slices)
2169         return;
2170     m_surroundData.access().border.m_image.setBorderSlices(WTFMove(slices));
2171 }
2172 
2173 void RenderStyle::setBorderImageOutset(LengthBox&amp;&amp; outset)
2174 {
2175     if (m_surroundData-&gt;border.m_image.outset() == outset)
2176         return;
2177     m_surroundData.access().border.m_image.setOutset(WTFMove(outset));
2178 }
2179 
2180 void RenderStyle::setColumnStylesFromPaginationMode(const Pagination::Mode&amp; paginationMode)
2181 {
2182     if (paginationMode == Pagination::Unpaginated)
2183         return;
2184 
2185     setColumnFill(ColumnFill::Auto);
2186 
2187     switch (paginationMode) {
2188     case Pagination::LeftToRightPaginated:
2189         setColumnAxis(ColumnAxis::Horizontal);
2190         if (isHorizontalWritingMode())
2191             setColumnProgression(isLeftToRightDirection() ? ColumnProgression::Normal : ColumnProgression::Reverse);
2192         else
2193             setColumnProgression(isFlippedBlocksWritingMode() ? ColumnProgression::Reverse : ColumnProgression::Normal);
2194         break;
2195     case Pagination::RightToLeftPaginated:
2196         setColumnAxis(ColumnAxis::Horizontal);
2197         if (isHorizontalWritingMode())
2198             setColumnProgression(isLeftToRightDirection() ? ColumnProgression::Reverse : ColumnProgression::Normal);
2199         else
2200             setColumnProgression(isFlippedBlocksWritingMode() ? ColumnProgression::Normal : ColumnProgression::Reverse);
2201         break;
2202     case Pagination::TopToBottomPaginated:
2203         setColumnAxis(ColumnAxis::Vertical);
2204         if (isHorizontalWritingMode())
2205             setColumnProgression(isFlippedBlocksWritingMode() ? ColumnProgression::Reverse : ColumnProgression::Normal);
2206         else
2207             setColumnProgression(isLeftToRightDirection() ? ColumnProgression::Normal : ColumnProgression::Reverse);
2208         break;
2209     case Pagination::BottomToTopPaginated:
2210         setColumnAxis(ColumnAxis::Vertical);
2211         if (isHorizontalWritingMode())
2212             setColumnProgression(isFlippedBlocksWritingMode() ? ColumnProgression::Normal : ColumnProgression::Reverse);
2213         else
2214             setColumnProgression(isLeftToRightDirection() ? ColumnProgression::Reverse : ColumnProgression::Normal);
2215         break;
2216     case Pagination::Unpaginated:
2217         ASSERT_NOT_REACHED();
2218         break;
2219     }
2220 }
2221 
2222 #if ENABLE(CSS_SCROLL_SNAP)
2223 
2224 ScrollSnapType RenderStyle::initialScrollSnapType()
2225 {
2226     return { };
2227 }
2228 
2229 ScrollSnapAlign RenderStyle::initialScrollSnapAlign()
2230 {
2231     return { };
2232 }
2233 
2234 const StyleScrollSnapArea&amp; RenderStyle::scrollSnapArea() const
2235 {
2236     return *m_rareNonInheritedData-&gt;scrollSnapArea;
2237 }
2238 
2239 const StyleScrollSnapPort&amp; RenderStyle::scrollSnapPort() const
2240 {
2241     return *m_rareNonInheritedData-&gt;scrollSnapPort;
2242 }
2243 
2244 const ScrollSnapType&amp; RenderStyle::scrollSnapType() const
2245 {
2246     return m_rareNonInheritedData-&gt;scrollSnapPort-&gt;type;
2247 }
2248 
2249 const LengthBox&amp; RenderStyle::scrollPadding() const
2250 {
2251     return m_rareNonInheritedData-&gt;scrollSnapPort-&gt;scrollPadding;
2252 }
2253 
2254 const Length&amp; RenderStyle::scrollPaddingTop() const
2255 {
2256     return scrollPadding().top();
2257 }
2258 
2259 const Length&amp; RenderStyle::scrollPaddingBottom() const
2260 {
2261     return scrollPadding().bottom();
2262 }
2263 
2264 const Length&amp; RenderStyle::scrollPaddingLeft() const
2265 {
2266     return scrollPadding().left();
2267 }
2268 
2269 const Length&amp; RenderStyle::scrollPaddingRight() const
2270 {
2271     return scrollPadding().right();
2272 }
2273 
2274 const ScrollSnapAlign&amp; RenderStyle::scrollSnapAlign() const
2275 {
2276     return m_rareNonInheritedData-&gt;scrollSnapArea-&gt;alignment;
2277 }
2278 
2279 const LengthBox&amp; RenderStyle::scrollSnapMargin() const
2280 {
2281     return m_rareNonInheritedData-&gt;scrollSnapArea-&gt;scrollSnapMargin;
2282 }
2283 
2284 const Length&amp; RenderStyle::scrollSnapMarginTop() const
2285 {
2286     return scrollSnapMargin().top();
2287 }
2288 
2289 const Length&amp; RenderStyle::scrollSnapMarginBottom() const
2290 {
2291     return scrollSnapMargin().bottom();
2292 }
2293 
2294 const Length&amp; RenderStyle::scrollSnapMarginLeft() const
2295 {
2296     return scrollSnapMargin().left();
2297 }
2298 
2299 const Length&amp; RenderStyle::scrollSnapMarginRight() const
2300 {
2301     return scrollSnapMargin().right();
2302 }
2303 
2304 void RenderStyle::setScrollSnapType(const ScrollSnapType&amp; type)
2305 {
2306     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, type, type);
2307 }
2308 
2309 void RenderStyle::setScrollPaddingTop(Length&amp;&amp; length)
2310 {
2311     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, scrollPadding.top(), WTFMove(length));
2312 }
2313 
2314 void RenderStyle::setScrollPaddingBottom(Length&amp;&amp; length)
2315 {
2316     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, scrollPadding.bottom(), WTFMove(length));
2317 }
2318 
2319 void RenderStyle::setScrollPaddingLeft(Length&amp;&amp; length)
2320 {
2321     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, scrollPadding.left(), WTFMove(length));
2322 }
2323 
2324 void RenderStyle::setScrollPaddingRight(Length&amp;&amp; length)
2325 {
2326     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, scrollPadding.right(), WTFMove(length));
2327 }
2328 
2329 void RenderStyle::setScrollSnapAlign(const ScrollSnapAlign&amp; alignment)
2330 {
2331     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, alignment, alignment);
2332 }
2333 
2334 void RenderStyle::setScrollSnapMarginTop(Length&amp;&amp; length)
2335 {
2336     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, scrollSnapMargin.top(), WTFMove(length));
2337 }
2338 
2339 void RenderStyle::setScrollSnapMarginBottom(Length&amp;&amp; length)
2340 {
2341     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, scrollSnapMargin.bottom(), WTFMove(length));
2342 }
2343 
2344 void RenderStyle::setScrollSnapMarginLeft(Length&amp;&amp; length)
2345 {
2346     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, scrollSnapMargin.left(), WTFMove(length));
2347 }
2348 
2349 void RenderStyle::setScrollSnapMarginRight(Length&amp;&amp; length)
2350 {
2351     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, scrollSnapMargin.right(), WTFMove(length));
2352 }
2353 
2354 #endif
2355 
2356 bool RenderStyle::hasReferenceFilterOnly() const
2357 {
2358     if (!hasFilter())
2359         return false;
2360     auto&amp; filterOperations = m_rareNonInheritedData-&gt;filter-&gt;operations;
2361     return filterOperations.size() == 1 &amp;&amp; filterOperations.at(0)-&gt;type() == FilterOperation::REFERENCE;
2362 }
2363 
2364 float RenderStyle::outlineWidth() const
2365 {
2366     if (m_backgroundData-&gt;outline.style() == BorderStyle::None)
2367         return 0;
2368     if (outlineStyleIsAuto() == OutlineIsAuto::On)
2369         return std::max(m_backgroundData-&gt;outline.width(), RenderTheme::platformFocusRingWidth());
2370     return m_backgroundData-&gt;outline.width();
2371 }
2372 
2373 float RenderStyle::outlineOffset() const
2374 {
2375     if (m_backgroundData-&gt;outline.style() == BorderStyle::None)
2376         return 0;
2377     if (outlineStyleIsAuto() == OutlineIsAuto::On)
2378         return (m_backgroundData-&gt;outline.offset() + RenderTheme::platformFocusRingOffset(outlineWidth()));
2379     return m_backgroundData-&gt;outline.offset();
2380 }
2381 
2382 bool RenderStyle::shouldPlaceBlockDirectionScrollbarOnLeft() const
2383 {
2384     return !isLeftToRightDirection() &amp;&amp; isHorizontalWritingMode();
2385 }
2386 
<a name="30" id="anc30"></a><span class="line-removed">2387 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">2388 </span>
<span class="line-removed">2389 void RenderStyle::setDashboardRegion(int type, const String&amp; label, Length&amp;&amp; top, Length&amp;&amp; right, Length&amp;&amp; bottom, Length&amp;&amp; left, bool append)</span>
<span class="line-removed">2390 {</span>
<span class="line-removed">2391     if (!append)</span>
<span class="line-removed">2392         m_rareNonInheritedData.access().dashboardRegions.clear();</span>
<span class="line-removed">2393     m_rareNonInheritedData.access().dashboardRegions.append({ label, { WTFMove(top), WTFMove(right), WTFMove(bottom), WTFMove(left) }, type });</span>
<span class="line-removed">2394 }</span>
<span class="line-removed">2395 </span>
<span class="line-removed">2396 #endif</span>
<span class="line-removed">2397 </span>
2398 Vector&lt;PaintType, 3&gt; RenderStyle::paintTypesForPaintOrder(PaintOrder order)
2399 {
2400     Vector&lt;PaintType, 3&gt; paintOrder;
2401     switch (order) {
2402     case PaintOrder::Normal:
2403         FALLTHROUGH;
2404     case PaintOrder::Fill:
2405         paintOrder.append(PaintType::Fill);
2406         paintOrder.append(PaintType::Stroke);
2407         paintOrder.append(PaintType::Markers);
2408         break;
2409     case PaintOrder::FillMarkers:
2410         paintOrder.append(PaintType::Fill);
2411         paintOrder.append(PaintType::Markers);
2412         paintOrder.append(PaintType::Stroke);
2413         break;
2414     case PaintOrder::Stroke:
2415         paintOrder.append(PaintType::Stroke);
2416         paintOrder.append(PaintType::Fill);
2417         paintOrder.append(PaintType::Markers);
2418         break;
2419     case PaintOrder::StrokeMarkers:
2420         paintOrder.append(PaintType::Stroke);
2421         paintOrder.append(PaintType::Markers);
2422         paintOrder.append(PaintType::Fill);
2423         break;
2424     case PaintOrder::Markers:
2425         paintOrder.append(PaintType::Markers);
2426         paintOrder.append(PaintType::Fill);
2427         paintOrder.append(PaintType::Stroke);
2428         break;
2429     case PaintOrder::MarkersStroke:
2430         paintOrder.append(PaintType::Markers);
2431         paintOrder.append(PaintType::Stroke);
2432         paintOrder.append(PaintType::Fill);
2433         break;
2434     };
2435     return paintOrder;
2436 }
2437 
2438 float RenderStyle::computedStrokeWidth(const IntSize&amp; viewportSize) const
2439 {
2440     // Use the stroke-width and stroke-color value combination only if stroke-color has been explicitly specified.
2441     // Since there will be no visible stroke when stroke-color is not specified (transparent by default), we fall
2442     // back to the legacy Webkit text stroke combination in that case.
2443     if (!hasExplicitlySetStrokeColor())
2444         return textStrokeWidth();
2445 
2446     const Length&amp; length = strokeWidth();
2447 
2448     if (length.isPercent()) {
2449         // According to the spec, https://drafts.fxtf.org/paint/#stroke-width, the percentage is relative to the scaled viewport size.
2450         // The scaled viewport size is the geometric mean of the viewport width and height.
2451         ExceptionOr&lt;float&gt; result = length.value() * (viewportSize.width() + viewportSize.height()) / 200.0f;
2452         if (result.hasException())
2453             return 0;
2454         return result.releaseReturnValue();
2455     }
2456 
2457     if (length.isAuto() || !length.isSpecified())
2458         return 0;
2459 
2460     return floatValueForLength(length, viewportSize.width());
2461 }
2462 
2463 bool RenderStyle::hasPositiveStrokeWidth() const
2464 {
2465     if (!hasExplicitlySetStrokeWidth())
2466         return textStrokeWidth() &gt; 0;
2467 
2468     return strokeWidth().isPositive();
2469 }
2470 
2471 Color RenderStyle::computedStrokeColor() const
2472 {
2473     CSSPropertyID propertyID = CSSPropertyStrokeColor;
2474     if (!hasExplicitlySetStrokeColor())
2475         propertyID = CSSPropertyWebkitTextStrokeColor;
2476     return visitedDependentColor(propertyID);
2477 }
2478 
2479 } // namespace WebCore
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>