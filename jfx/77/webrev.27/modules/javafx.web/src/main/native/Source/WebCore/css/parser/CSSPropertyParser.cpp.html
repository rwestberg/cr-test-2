<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Copyright 2015 The Chromium Authors. All rights reserved.
   2 // Copyright (C) 2016 Apple Inc. All rights reserved.
   3 //
   4 // Redistribution and use in source and binary forms, with or without
   5 // modification, are permitted provided that the following conditions are
   6 // met:
   7 //
   8 //    * Redistributions of source code must retain the above copyright
   9 // notice, this list of conditions and the following disclaimer.
  10 //    * Redistributions in binary form must reproduce the above
  11 // copyright notice, this list of conditions and the following disclaimer
  12 // in the documentation and/or other materials provided with the
  13 // distribution.
  14 //    * Neither the name of Google Inc. nor the names of its
  15 // contributors may be used to endorse or promote products derived from
  16 // this software without specific prior written permission.
  17 //
  18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;CSSPropertyParser.h&quot;
  32 
  33 #include &quot;CSSAspectRatioValue.h&quot;
  34 #include &quot;CSSBasicShapes.h&quot;
  35 #include &quot;CSSBorderImage.h&quot;
  36 #include &quot;CSSBorderImageSliceValue.h&quot;
  37 #include &quot;CSSContentDistributionValue.h&quot;
  38 #include &quot;CSSCursorImageValue.h&quot;
  39 #include &quot;CSSCustomIdentValue.h&quot;
  40 #include &quot;CSSCustomPropertyValue.h&quot;
  41 #include &quot;CSSFontFaceSrcValue.h&quot;
  42 #include &quot;CSSFontFeatureValue.h&quot;
  43 #if ENABLE(VARIATION_FONTS)
  44 #include &quot;CSSFontVariationValue.h&quot;
  45 #endif
  46 #include &quot;CSSFontStyleRangeValue.h&quot;
  47 #include &quot;CSSFontStyleValue.h&quot;
  48 #include &quot;CSSFunctionValue.h&quot;
  49 #include &quot;CSSGridAutoRepeatValue.h&quot;
  50 #include &quot;CSSGridIntegerRepeatValue.h&quot;
  51 #include &quot;CSSGridLineNamesValue.h&quot;
  52 #include &quot;CSSGridTemplateAreasValue.h&quot;
  53 #include &quot;CSSLineBoxContainValue.h&quot;
  54 #include &quot;CSSParserFastPaths.h&quot;
  55 #include &quot;CSSParserIdioms.h&quot;
  56 #include &quot;CSSPendingSubstitutionValue.h&quot;
  57 #include &quot;CSSPrimitiveValueMappings.h&quot;
  58 #include &quot;CSSPropertyParserHelpers.h&quot;
  59 #include &quot;CSSReflectValue.h&quot;
  60 #include &quot;CSSShadowValue.h&quot;
  61 #include &quot;CSSTimingFunctionValue.h&quot;
  62 #include &quot;CSSUnicodeRangeValue.h&quot;
  63 #include &quot;CSSVariableParser.h&quot;
  64 #include &quot;CSSVariableReferenceValue.h&quot;
  65 #include &quot;Counter.h&quot;
  66 #include &quot;FontFace.h&quot;
  67 #include &quot;HashTools.h&quot;
  68 // FIXME-NEWPARSER: Replace Pair and Rect with actual CSSValue subclasses (CSSValuePair and CSSQuadValue).
  69 #include &quot;Pair.h&quot;
  70 #include &quot;Rect.h&quot;
  71 #include &quot;RenderTheme.h&quot;
  72 #include &quot;RuntimeEnabledFeatures.h&quot;
  73 #include &quot;SVGPathByteStream.h&quot;
  74 #include &quot;SVGPathUtilities.h&quot;
  75 #include &quot;StyleBuilderConverter.h&quot;
  76 #include &quot;StylePropertyShorthand.h&quot;
  77 #include &quot;StylePropertyShorthandFunctions.h&quot;
  78 #include &quot;StyleResolver.h&quot;
  79 #include &lt;bitset&gt;
  80 #include &lt;memory&gt;
  81 #include &lt;wtf/text/StringBuilder.h&gt;
  82 
  83 namespace WebCore {
  84 
  85 bool isCustomPropertyName(const String&amp; propertyName)
  86 {
  87     return propertyName.length() &gt; 2 &amp;&amp; propertyName.characterAt(0) == &#39;-&#39; &amp;&amp; propertyName.characterAt(1) == &#39;-&#39;;
  88 }
  89 
  90 static bool hasPrefix(const char* string, unsigned length, const char* prefix)
  91 {
  92     for (unsigned i = 0; i &lt; length; ++i) {
  93         if (!prefix[i])
  94             return true;
  95         if (string[i] != prefix[i])
  96             return false;
  97     }
  98     return false;
  99 }
 100 
 101 #if PLATFORM(IOS_FAMILY)
 102 void cssPropertyNameIOSAliasing(const char* propertyName, const char*&amp; propertyNameAlias, unsigned&amp; newLength)
 103 {
 104     if (!strcmp(propertyName, &quot;-webkit-hyphenate-locale&quot;)) {
 105         // Worked in iOS 4.2.
 106         static const char webkitLocale[] = &quot;-webkit-locale&quot;;
 107         propertyNameAlias = webkitLocale;
 108         newLength = strlen(webkitLocale);
 109     }
 110 }
 111 #endif
 112 
 113 template &lt;typename CharacterType&gt;
 114 static CSSPropertyID cssPropertyID(const CharacterType* propertyName, unsigned length)
 115 {
 116     char buffer[maxCSSPropertyNameLength + 1 + 1]; // 1 to turn &quot;apple&quot;/&quot;khtml&quot; into &quot;webkit&quot;, 1 for null character
 117 
 118     for (unsigned i = 0; i != length; ++i) {
 119         CharacterType c = propertyName[i];
 120         if (!c || c &gt;= 0x7F)
 121             return CSSPropertyInvalid; // illegal character
 122         buffer[i] = toASCIILower(c);
 123     }
 124     buffer[length] = &#39;\0&#39;;
 125 
 126     const char* name = buffer;
 127     if (buffer[0] == &#39;-&#39;) {
 128 #if ENABLE(LEGACY_CSS_VENDOR_PREFIXES)
 129         // If the prefix is -apple- or -khtml-, change it to -webkit-.
 130         // This makes the string one character longer.
 131         if (RuntimeEnabledFeatures::sharedFeatures().legacyCSSVendorPrefixesEnabled()
 132             &amp;&amp; (hasPrefix(buffer, length, &quot;-apple-&quot;) || hasPrefix(buffer, length, &quot;-khtml-&quot;))) {
 133             memmove(buffer + 7, buffer + 6, length + 1 - 6);
 134             memcpy(buffer, &quot;-webkit&quot;, 7);
 135             ++length;
 136         }
 137 #endif
 138 #if PLATFORM(IOS_FAMILY)
 139         cssPropertyNameIOSAliasing(buffer, name, length);
 140 #endif
 141     }
 142 
 143     const Property* hashTableEntry = findProperty(name, length);
 144     if (hashTableEntry) {
 145         auto propertyID = static_cast&lt;CSSPropertyID&gt;(hashTableEntry-&gt;id);
 146         if (isEnabledCSSProperty(propertyID))
 147             return propertyID;
 148     }
 149     return CSSPropertyInvalid;
 150 }
 151 
 152 static bool isAppleLegacyCssValueKeyword(const char* valueKeyword, unsigned length)
 153 {
 154     static const char applePrefix[] = &quot;-apple-&quot;;
 155     static const char appleSystemPrefix[] = &quot;-apple-system&quot;;
 156     static const char applePayPrefix[] = &quot;-apple-pay&quot;;
 157 
 158 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
 159     static const char* appleWirelessPlaybackTargetActive = getValueName(CSSValueAppleWirelessPlaybackTargetActive);
 160 #endif
 161 
 162     return hasPrefix(valueKeyword, length, applePrefix)
 163     &amp;&amp; !hasPrefix(valueKeyword, length, appleSystemPrefix)
 164     &amp;&amp; !hasPrefix(valueKeyword, length, applePayPrefix)
 165 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
 166     &amp;&amp; !WTF::equal(reinterpret_cast&lt;const LChar*&gt;(valueKeyword), reinterpret_cast&lt;const LChar*&gt;(appleWirelessPlaybackTargetActive), length)
 167 #endif
 168     ;
 169 }
 170 
 171 template &lt;typename CharacterType&gt;
 172 static CSSValueID cssValueKeywordID(const CharacterType* valueKeyword, unsigned length)
 173 {
 174     char buffer[maxCSSValueKeywordLength + 1 + 1]; // 1 to turn &quot;apple&quot;/&quot;khtml&quot; into &quot;webkit&quot;, 1 for null character
 175 
 176     for (unsigned i = 0; i != length; ++i) {
 177         CharacterType c = valueKeyword[i];
 178         if (!c || c &gt;= 0x7F)
 179             return CSSValueInvalid; // illegal keyword.
 180         buffer[i] = WTF::toASCIILower(c);
 181     }
 182     buffer[length] = &#39;\0&#39;;
 183 
 184     if (buffer[0] == &#39;-&#39;) {
 185         // If the prefix is -apple- or -khtml-, change it to -webkit-.
 186         // This makes the string one character longer.
 187         // On iOS we don&#39;t want to change values starting with -apple-system to -webkit-system.
 188         // FIXME: Remove this mangling without breaking the web.
 189         if (isAppleLegacyCssValueKeyword(buffer, length) || hasPrefix(buffer, length, &quot;-khtml-&quot;)) {
 190             memmove(buffer + 7, buffer + 6, length + 1 - 6);
 191             memcpy(buffer, &quot;-webkit&quot;, 7);
 192             ++length;
 193         }
 194     }
 195 
 196     const Value* hashTableEntry = findValue(buffer, length);
 197     return hashTableEntry ? static_cast&lt;CSSValueID&gt;(hashTableEntry-&gt;id) : CSSValueInvalid;
 198 }
 199 
 200 CSSValueID cssValueKeywordID(StringView string)
 201 {
 202     unsigned length = string.length();
 203     if (!length)
 204         return CSSValueInvalid;
 205     if (length &gt; maxCSSValueKeywordLength)
 206         return CSSValueInvalid;
 207 
 208     return string.is8Bit() ? cssValueKeywordID(string.characters8(), length) : cssValueKeywordID(string.characters16(), length);
 209 }
 210 
 211 CSSPropertyID cssPropertyID(StringView string)
 212 {
 213     unsigned length = string.length();
 214 
 215     if (!length)
 216         return CSSPropertyInvalid;
 217     if (length &gt; maxCSSPropertyNameLength)
 218         return CSSPropertyInvalid;
 219 
 220     return string.is8Bit() ? cssPropertyID(string.characters8(), length) : cssPropertyID(string.characters16(), length);
 221 }
 222 
 223 using namespace CSSPropertyParserHelpers;
 224 
 225 CSSPropertyParser::CSSPropertyParser(const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, Vector&lt;CSSProperty, 256&gt;* parsedProperties, bool consumeWhitespace)
 226     : m_range(range)
 227     , m_context(context)
 228     , m_parsedProperties(parsedProperties)
 229 {
 230     if (consumeWhitespace)
 231         m_range.consumeWhitespace();
 232 }
 233 
 234 void CSSPropertyParser::addProperty(CSSPropertyID property, CSSPropertyID currentShorthand, Ref&lt;CSSValue&gt;&amp;&amp; value, bool important, bool implicit)
 235 {
 236     if (!isEnabledCSSProperty(property))
 237         return;
 238 
 239     int shorthandIndex = 0;
 240     bool setFromShorthand = false;
 241 
 242     if (currentShorthand) {
 243         auto shorthands = matchingShorthandsForLonghand(property);
 244         setFromShorthand = true;
 245         if (shorthands.size() &gt; 1)
 246             shorthandIndex = indexOfShorthandForLonghand(currentShorthand, shorthands);
 247     }
 248 
 249     m_parsedProperties-&gt;append(CSSProperty(property, WTFMove(value), important, setFromShorthand, shorthandIndex, implicit));
 250 }
 251 
 252 void CSSPropertyParser::addExpandedPropertyForValue(CSSPropertyID property, Ref&lt;CSSValue&gt;&amp;&amp; value, bool important)
 253 {
 254     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(property);
 255     unsigned shorthandLength = shorthand.length();
 256     ASSERT(shorthandLength);
 257     const CSSPropertyID* longhands = shorthand.properties();
 258     for (unsigned i = 0; i &lt; shorthandLength; ++i)
 259         addProperty(longhands[i], property, value.copyRef(), important);
 260 }
 261 
 262 bool CSSPropertyParser::parseValue(CSSPropertyID propertyID, bool important, const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, ParsedPropertyVector&amp; parsedProperties, StyleRule::Type ruleType)
 263 {
 264     int parsedPropertiesSize = parsedProperties.size();
 265 
 266     CSSPropertyParser parser(range, context, &amp;parsedProperties);
 267     bool parseSuccess;
 268 
 269 #if ENABLE(CSS_DEVICE_ADAPTATION)
 270     if (ruleType == StyleRule::Viewport)
 271         parseSuccess = parser.parseViewportDescriptor(propertyID, important);
 272     else
 273 #endif
 274     if (ruleType == StyleRule::FontFace)
 275         parseSuccess = parser.parseFontFaceDescriptor(propertyID);
 276     else
 277         parseSuccess = parser.parseValueStart(propertyID, important);
 278 
 279     if (!parseSuccess)
 280         parsedProperties.shrink(parsedPropertiesSize);
 281 
 282     return parseSuccess;
 283 }
 284 
 285 RefPtr&lt;CSSValue&gt; CSSPropertyParser::parseSingleValue(CSSPropertyID property, const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
 286 {
 287     CSSPropertyParser parser(range, context, nullptr);
 288     RefPtr&lt;CSSValue&gt; value = parser.parseSingleValue(property);
 289     if (!value || !parser.m_range.atEnd())
 290         return nullptr;
 291     return value;
 292 }
 293 
 294 bool CSSPropertyParser::canParseTypedCustomPropertyValue(const String&amp; syntax, const CSSParserTokenRange&amp; tokens, const CSSParserContext&amp; context)
 295 {
 296     CSSPropertyParser parser(tokens, context, nullptr);
 297     return parser.canParseTypedCustomPropertyValue(syntax);
 298 }
 299 
 300 RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const CSSParserTokenRange&amp; tokens, const StyleResolver&amp; styleResolver, const CSSParserContext&amp; context)
 301 {
 302     CSSPropertyParser parser(tokens, context, nullptr, false);
 303     RefPtr&lt;CSSCustomPropertyValue&gt; value = parser.parseTypedCustomPropertyValue(name, syntax, styleResolver);
 304     if (!value || !parser.m_range.atEnd())
 305         return nullptr;
 306     return value;
 307 }
 308 
 309 void CSSPropertyParser::collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies, const CSSParserTokenRange&amp; tokens, const CSSParserContext&amp; context)
 310 {
 311     CSSPropertyParser parser(tokens, context, nullptr);
 312     parser.collectParsedCustomPropertyValueDependencies(syntax, isRoot, dependencies);
 313 }
 314 
 315 bool CSSPropertyParser::parseValueStart(CSSPropertyID propertyID, bool important)
 316 {
 317     if (consumeCSSWideKeyword(propertyID, important))
 318         return true;
 319 
 320     CSSParserTokenRange originalRange = m_range;
 321     bool isShorthand = isShorthandCSSProperty(propertyID);
 322 
 323     if (isShorthand) {
 324         // Variable references will fail to parse here and will fall out to the variable ref parser below.
 325         if (parseShorthand(propertyID, important))
 326             return true;
 327     } else {
 328         RefPtr&lt;CSSValue&gt; parsedValue = parseSingleValue(propertyID);
 329         if (parsedValue &amp;&amp; m_range.atEnd()) {
 330             addProperty(propertyID, CSSPropertyInvalid, *parsedValue, important);
 331             return true;
 332         }
 333     }
 334 
 335     if (CSSVariableParser::containsValidVariableReferences(originalRange, m_context)) {
 336         RefPtr&lt;CSSVariableReferenceValue&gt; variable = CSSVariableReferenceValue::create(originalRange);
 337 
 338         if (isShorthand) {
 339             RefPtr&lt;CSSPendingSubstitutionValue&gt; pendingValue = CSSPendingSubstitutionValue::create(propertyID, variable.releaseNonNull());
 340             addExpandedPropertyForValue(propertyID, pendingValue.releaseNonNull(), important);
 341         } else
 342             addProperty(propertyID, CSSPropertyInvalid, variable.releaseNonNull(), important);
 343         return true;
 344     }
 345 
 346     return false;
 347 }
 348 
 349 bool CSSPropertyParser::consumeCSSWideKeyword(CSSPropertyID propertyID, bool important)
 350 {
 351     CSSParserTokenRange rangeCopy = m_range;
 352     CSSValueID valueID = rangeCopy.consumeIncludingWhitespace().id();
 353     if (!rangeCopy.atEnd())
 354         return false;
 355 
 356     RefPtr&lt;CSSValue&gt; value;
 357     if (valueID == CSSValueInherit)
 358         value = CSSValuePool::singleton().createInheritedValue();
 359     else if (valueID == CSSValueInitial)
 360         value = CSSValuePool::singleton().createExplicitInitialValue();
 361     else if (valueID == CSSValueUnset)
 362         value = CSSValuePool::singleton().createUnsetValue();
 363     else if (valueID == CSSValueRevert)
 364         value = CSSValuePool::singleton().createRevertValue();
 365     else
 366         return false;
 367 
 368     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(propertyID);
 369     if (!shorthand.length()) {
 370         if (CSSProperty::isDescriptorOnly(propertyID))
 371             return false;
 372         addProperty(propertyID, CSSPropertyInvalid, value.releaseNonNull(), important);
 373     } else
 374         addExpandedPropertyForValue(propertyID, value.releaseNonNull(), important);
 375     m_range = rangeCopy;
 376     return true;
 377 }
 378 
 379 bool CSSPropertyParser::consumeTransformOrigin(bool important)
 380 {
 381     RefPtr&lt;CSSPrimitiveValue&gt; resultX;
 382     RefPtr&lt;CSSPrimitiveValue&gt; resultY;
 383     if (consumeOneOrTwoValuedPosition(m_range, m_context.mode, UnitlessQuirk::Forbid, resultX, resultY)) {
 384         m_range.consumeWhitespace();
 385         bool atEnd = m_range.atEnd();
 386         RefPtr&lt;CSSPrimitiveValue&gt; resultZ = consumeLength(m_range, m_context.mode, ValueRangeAll);
 387         bool hasZ = resultZ;
 388         if (!hasZ &amp;&amp; !atEnd)
 389             return false;
 390         addProperty(CSSPropertyTransformOriginX, CSSPropertyTransformOrigin, resultX.releaseNonNull(), important);
 391         addProperty(CSSPropertyTransformOriginY, CSSPropertyTransformOrigin, resultY.releaseNonNull(), important);
 392         addProperty(CSSPropertyTransformOriginZ, CSSPropertyTransformOrigin, resultZ ? resultZ.releaseNonNull() : CSSValuePool::singleton().createValue(0, CSSPrimitiveValue::UnitType::CSS_PX), important, !hasZ);
 393 
 394         return true;
 395     }
 396     return false;
 397 }
 398 
 399 bool CSSPropertyParser::consumePerspectiveOrigin(bool important)
 400 {
 401     RefPtr&lt;CSSPrimitiveValue&gt; resultX;
 402     RefPtr&lt;CSSPrimitiveValue&gt; resultY;
 403     if (consumePosition(m_range, m_context.mode, UnitlessQuirk::Forbid, resultX, resultY)) {
 404         addProperty(CSSPropertyPerspectiveOriginX, CSSPropertyPerspectiveOrigin, resultX.releaseNonNull(), important);
 405         addProperty(CSSPropertyPerspectiveOriginY, CSSPropertyPerspectiveOrigin, resultY.releaseNonNull(), important);
 406         return true;
 407     }
 408     return false;
 409 }
 410 
 411 // Methods for consuming non-shorthand properties starts here.
 412 static RefPtr&lt;CSSValue&gt; consumeWillChange(CSSParserTokenRange&amp; range)
 413 {
 414     if (range.peek().id() == CSSValueAuto)
 415         return consumeIdent(range);
 416 
 417     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createCommaSeparated();
 418     // Every comma-separated list of identifiers is a valid will-change value,
 419     // unless the list includes an explicitly disallowed identifier.
 420     while (true) {
 421         if (range.peek().type() != IdentToken)
 422             return nullptr;
 423         CSSPropertyID propertyID = cssPropertyID(range.peek().value());
 424         if (propertyID != CSSPropertyInvalid) {
 425             // Now &quot;all&quot; is used by both CSSValue and CSSPropertyValue.
 426             // Need to return nullptr when currentValue is CSSPropertyAll.
 427             if (propertyID == CSSPropertyWillChange || propertyID == CSSPropertyAll)
 428                 return nullptr;
 429             // FIXME-NEWPARSER: Use CSSCustomIdentValue someday.
 430             values-&gt;append(CSSValuePool::singleton().createIdentifierValue(propertyID));
 431             range.consumeIncludingWhitespace();
 432         } else {
 433             switch (range.peek().id()) {
 434             case CSSValueNone:
 435             case CSSValueAll:
 436             case CSSValueAuto:
 437             case CSSValueDefault:
 438             case CSSValueInitial:
 439             case CSSValueInherit:
 440                 return nullptr;
 441             case CSSValueContents:
 442             case CSSValueScrollPosition:
 443                 values-&gt;append(consumeIdent(range).releaseNonNull());
 444                 break;
 445             default:
 446                 // Append properties we don&#39;t recognize, but that are legal, as strings.
 447                 values-&gt;append(consumeCustomIdent(range).releaseNonNull());
 448                 break;
 449             }
 450         }
 451 
 452         if (range.atEnd())
 453             break;
 454         if (!consumeCommaIncludingWhitespace(range))
 455             return nullptr;
 456     }
 457 
 458     return values;
 459 }
 460 
 461 static RefPtr&lt;CSSFontFeatureValue&gt; consumeFontFeatureTag(CSSParserTokenRange&amp; range)
 462 {
 463     // Feature tag name consists of 4-letter characters.
 464     static const unsigned tagNameLength = 4;
 465 
 466     const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
 467     // Feature tag name comes first
 468     if (token.type() != StringToken)
 469         return nullptr;
 470     if (token.value().length() != tagNameLength)
 471         return nullptr;
 472 
 473     FontTag tag;
 474     for (unsigned i = 0; i &lt; tag.size(); ++i) {
 475         // Limits the range of characters to 0x20-0x7E, following the tag name rules defiend in the OpenType specification.
 476         UChar character = token.value()[i];
 477         if (character &lt; 0x20 || character &gt; 0x7E)
 478             return nullptr;
 479         tag[i] = toASCIILower(character);
 480     }
 481 
 482     int tagValue = 1;
 483     if (!range.atEnd() &amp;&amp; range.peek().type() != CommaToken) {
 484         // Feature tag values could follow: &lt;integer&gt; | on | off
 485         if (auto primitiveValue = consumeInteger(range, 0))
 486             tagValue = primitiveValue-&gt;intValue();
 487         else if (range.peek().id() == CSSValueOn || range.peek().id() == CSSValueOff)
 488             tagValue = range.consumeIncludingWhitespace().id() == CSSValueOn;
 489         else
 490             return nullptr;
 491     }
 492     return CSSFontFeatureValue::create(WTFMove(tag), tagValue);
 493 }
 494 
 495 static RefPtr&lt;CSSValue&gt; consumeFontFeatureSettings(CSSParserTokenRange&amp; range)
 496 {
 497     if (range.peek().id() == CSSValueNormal)
 498         return consumeIdent(range);
 499     RefPtr&lt;CSSValueList&gt; settings = CSSValueList::createCommaSeparated();
 500     do {
 501         RefPtr&lt;CSSFontFeatureValue&gt; fontFeatureValue = consumeFontFeatureTag(range);
 502         if (!fontFeatureValue)
 503             return nullptr;
 504         settings-&gt;append(fontFeatureValue.releaseNonNull());
 505     } while (consumeCommaIncludingWhitespace(range));
 506     return settings;
 507 }
 508 
 509 #if ENABLE(VARIATION_FONTS)
 510 static RefPtr&lt;CSSValue&gt; consumeFontVariationTag(CSSParserTokenRange&amp; range)
 511 {
 512     if (range.peek().type() != StringToken)
 513         return nullptr;
 514 
 515     auto string = range.consumeIncludingWhitespace().value().toString();
 516 
 517     FontTag tag;
 518     if (string.length() != tag.size())
 519         return nullptr;
 520     for (unsigned i = 0; i &lt; tag.size(); ++i) {
 521         // Limits the range of characters to 0x20-0x7E, following the tag name rules defiend in the OpenType specification.
 522         UChar character = string[i];
 523         if (character &lt; 0x20 || character &gt; 0x7E)
 524             return nullptr;
 525         tag[i] = character;
 526     }
 527 
 528     if (range.atEnd())
 529         return nullptr;
 530 
 531     double tagValue = 0;
 532     auto success = consumeNumberRaw(range, tagValue);
 533     if (!success)
 534         return nullptr;
 535 
 536     return CSSFontVariationValue::create(tag, tagValue);
 537 }
 538 
 539 static RefPtr&lt;CSSValue&gt; consumeFontVariationSettings(CSSParserTokenRange&amp; range)
 540 {
 541     if (range.peek().id() == CSSValueNormal)
 542         return consumeIdent(range);
 543 
 544     auto settings = CSSValueList::createCommaSeparated();
 545     do {
 546         RefPtr&lt;CSSValue&gt; variationValue = consumeFontVariationTag(range);
 547         if (!variationValue)
 548             return nullptr;
 549         settings-&gt;append(variationValue.releaseNonNull());
 550     } while (consumeCommaIncludingWhitespace(range));
 551 
 552     if (!settings-&gt;length())
 553         return nullptr;
 554 
 555     return settings;
 556 }
 557 #endif // ENABLE(VARIATION_FONTS)
 558 
 559 static RefPtr&lt;CSSValue&gt; consumePage(CSSParserTokenRange&amp; range)
 560 {
 561     if (range.peek().id() == CSSValueAuto)
 562         return consumeIdent(range);
 563     return consumeCustomIdent(range);
 564 }
 565 
 566 static RefPtr&lt;CSSValue&gt; consumeQuotes(CSSParserTokenRange&amp; range)
 567 {
 568     if (range.peek().id() == CSSValueNone)
 569         return consumeIdent(range);
 570     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
 571     while (!range.atEnd()) {
 572         RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeString(range);
 573         if (!parsedValue)
 574             return nullptr;
 575         values-&gt;append(parsedValue.releaseNonNull());
 576     }
 577     if (values-&gt;length() &amp;&amp; values-&gt;length() % 2 == 0)
 578         return values;
 579     return nullptr;
 580 }
 581 
 582 class FontVariantLigaturesParser {
 583 public:
 584     FontVariantLigaturesParser()
 585         : m_sawCommonLigaturesValue(false)
 586         , m_sawDiscretionaryLigaturesValue(false)
 587         , m_sawHistoricalLigaturesValue(false)
 588         , m_sawContextualLigaturesValue(false)
 589         , m_result(CSSValueList::createSpaceSeparated())
 590     {
 591     }
 592 
 593     enum class ParseResult {
 594         ConsumedValue,
 595         DisallowedValue,
 596         UnknownValue
 597     };
 598 
 599     ParseResult consumeLigature(CSSParserTokenRange&amp; range)
 600     {
 601         CSSValueID valueID = range.peek().id();
 602         switch (valueID) {
 603         case CSSValueNoCommonLigatures:
 604         case CSSValueCommonLigatures:
 605             if (m_sawCommonLigaturesValue)
 606                 return ParseResult::DisallowedValue;
 607             m_sawCommonLigaturesValue = true;
 608             break;
 609         case CSSValueNoDiscretionaryLigatures:
 610         case CSSValueDiscretionaryLigatures:
 611             if (m_sawDiscretionaryLigaturesValue)
 612                 return ParseResult::DisallowedValue;
 613             m_sawDiscretionaryLigaturesValue = true;
 614             break;
 615         case CSSValueNoHistoricalLigatures:
 616         case CSSValueHistoricalLigatures:
 617             if (m_sawHistoricalLigaturesValue)
 618                 return ParseResult::DisallowedValue;
 619             m_sawHistoricalLigaturesValue = true;
 620             break;
 621         case CSSValueNoContextual:
 622         case CSSValueContextual:
 623             if (m_sawContextualLigaturesValue)
 624                 return ParseResult::DisallowedValue;
 625             m_sawContextualLigaturesValue = true;
 626             break;
 627         default:
 628             return ParseResult::UnknownValue;
 629         }
 630         m_result-&gt;append(consumeIdent(range).releaseNonNull());
 631         return ParseResult::ConsumedValue;
 632     }
 633 
 634     RefPtr&lt;CSSValue&gt; finalizeValue()
 635     {
 636         if (!m_result-&gt;length())
 637             return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
 638         return WTFMove(m_result);
 639     }
 640 
 641 private:
 642     bool m_sawCommonLigaturesValue;
 643     bool m_sawDiscretionaryLigaturesValue;
 644     bool m_sawHistoricalLigaturesValue;
 645     bool m_sawContextualLigaturesValue;
 646     RefPtr&lt;CSSValueList&gt; m_result;
 647 };
 648 
 649 static RefPtr&lt;CSSValue&gt; consumeFontVariantLigatures(CSSParserTokenRange&amp; range)
 650 {
 651     if (range.peek().id() == CSSValueNormal || range.peek().id() == CSSValueNone)
 652         return consumeIdent(range);
 653 
 654     FontVariantLigaturesParser ligaturesParser;
 655     do {
 656         if (ligaturesParser.consumeLigature(range) !=
 657             FontVariantLigaturesParser::ParseResult::ConsumedValue)
 658             return nullptr;
 659     } while (!range.atEnd());
 660 
 661     return ligaturesParser.finalizeValue();
 662 }
 663 
 664 static RefPtr&lt;CSSValue&gt; consumeFontVariantEastAsian(CSSParserTokenRange&amp; range)
 665 {
 666     if (range.peek().id() == CSSValueNormal)
 667         return consumeIdent(range);
 668 
 669     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
 670     FontVariantEastAsianVariant variant = FontVariantEastAsianVariant::Normal;
 671     FontVariantEastAsianWidth width = FontVariantEastAsianWidth::Normal;
 672     FontVariantEastAsianRuby ruby = FontVariantEastAsianRuby::Normal;
 673 
 674     while (!range.atEnd()) {
 675         if (range.peek().type() != IdentToken)
 676             return nullptr;
 677 
 678         auto id = range.peek().id();
 679 
 680         switch (id) {
 681         case CSSValueJis78:
 682             variant = FontVariantEastAsianVariant::Jis78;
 683             break;
 684         case CSSValueJis83:
 685             variant = FontVariantEastAsianVariant::Jis83;
 686             break;
 687         case CSSValueJis90:
 688             variant = FontVariantEastAsianVariant::Jis90;
 689             break;
 690         case CSSValueJis04:
 691             variant = FontVariantEastAsianVariant::Jis04;
 692             break;
 693         case CSSValueSimplified:
 694             variant = FontVariantEastAsianVariant::Simplified;
 695             break;
 696         case CSSValueTraditional:
 697             variant = FontVariantEastAsianVariant::Traditional;
 698             break;
 699         case CSSValueFullWidth:
 700             width = FontVariantEastAsianWidth::Full;
 701             break;
 702         case CSSValueProportionalWidth:
 703             width = FontVariantEastAsianWidth::Proportional;
 704             break;
 705         case CSSValueRuby:
 706             ruby = FontVariantEastAsianRuby::Yes;
 707             break;
 708         default:
 709             return nullptr;
 710         }
 711 
 712         range.consumeIncludingWhitespace();
 713     }
 714 
 715     switch (variant) {
 716     case FontVariantEastAsianVariant::Normal:
 717         break;
 718     case FontVariantEastAsianVariant::Jis78:
 719         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis78));
 720         break;
 721     case FontVariantEastAsianVariant::Jis83:
 722         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis83));
 723         break;
 724     case FontVariantEastAsianVariant::Jis90:
 725         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis90));
 726         break;
 727     case FontVariantEastAsianVariant::Jis04:
 728         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis04));
 729         break;
 730     case FontVariantEastAsianVariant::Simplified:
 731         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSimplified));
 732         break;
 733     case FontVariantEastAsianVariant::Traditional:
 734         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueTraditional));
 735         break;
 736     }
 737 
 738     switch (width) {
 739     case FontVariantEastAsianWidth::Normal:
 740         break;
 741     case FontVariantEastAsianWidth::Full:
 742         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueFullWidth));
 743         break;
 744     case FontVariantEastAsianWidth::Proportional:
 745         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueProportionalWidth));
 746         break;
 747     }
 748 
 749     switch (ruby) {
 750     case FontVariantEastAsianRuby::Normal:
 751         break;
 752     case FontVariantEastAsianRuby::Yes:
 753         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueRuby));
 754     }
 755 
 756     if (!values-&gt;length())
 757         return nullptr;
 758 
 759     return values;
 760 }
 761 
 762 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontVariantCaps(CSSParserTokenRange&amp; range)
 763 {
 764     return consumeIdent&lt;CSSValueNormal, CSSValueSmallCaps, CSSValueAllSmallCaps,
 765         CSSValuePetiteCaps, CSSValueAllPetiteCaps,
 766         CSSValueUnicase, CSSValueTitlingCaps&gt;(range);
 767 }
 768 
 769 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontVariantAlternates(CSSParserTokenRange&amp; range)
 770 {
 771     return consumeIdent&lt;CSSValueNormal, CSSValueHistoricalForms&gt;(range);
 772 }
 773 
 774 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontVariantPosition(CSSParserTokenRange&amp; range)
 775 {
 776     return consumeIdent&lt;CSSValueNormal, CSSValueSub, CSSValueSuper&gt;(range);
 777 }
 778 
 779 class FontVariantNumericParser {
 780 public:
 781     FontVariantNumericParser()
 782         : m_sawNumericFigureValue(false)
 783         , m_sawNumericSpacingValue(false)
 784         , m_sawNumericFractionValue(false)
 785         , m_sawOrdinalValue(false)
 786         , m_sawSlashedZeroValue(false)
 787         , m_result(CSSValueList::createSpaceSeparated())
 788     {
 789     }
 790 
 791     enum class ParseResult {
 792         ConsumedValue,
 793         DisallowedValue,
 794         UnknownValue
 795     };
 796 
 797     ParseResult consumeNumeric(CSSParserTokenRange&amp; range)
 798     {
 799         CSSValueID valueID = range.peek().id();
 800         switch (valueID) {
 801         case CSSValueLiningNums:
 802         case CSSValueOldstyleNums:
 803             if (m_sawNumericFigureValue)
 804                 return ParseResult::DisallowedValue;
 805             m_sawNumericFigureValue = true;
 806             break;
 807         case CSSValueProportionalNums:
 808         case CSSValueTabularNums:
 809             if (m_sawNumericSpacingValue)
 810                 return ParseResult::DisallowedValue;
 811             m_sawNumericSpacingValue = true;
 812             break;
 813         case CSSValueDiagonalFractions:
 814         case CSSValueStackedFractions:
 815             if (m_sawNumericFractionValue)
 816                 return ParseResult::DisallowedValue;
 817             m_sawNumericFractionValue = true;
 818             break;
 819         case CSSValueOrdinal:
 820             if (m_sawOrdinalValue)
 821                 return ParseResult::DisallowedValue;
 822             m_sawOrdinalValue = true;
 823             break;
 824         case CSSValueSlashedZero:
 825             if (m_sawSlashedZeroValue)
 826                 return ParseResult::DisallowedValue;
 827             m_sawSlashedZeroValue = true;
 828             break;
 829         default:
 830             return ParseResult::UnknownValue;
 831         }
 832         m_result-&gt;append(consumeIdent(range).releaseNonNull());
 833         return ParseResult::ConsumedValue;
 834     }
 835 
 836     RefPtr&lt;CSSValue&gt; finalizeValue()
 837     {
 838         if (!m_result-&gt;length())
 839             return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
 840         return WTFMove(m_result);
 841     }
 842 
 843 
 844 private:
 845     bool m_sawNumericFigureValue;
 846     bool m_sawNumericSpacingValue;
 847     bool m_sawNumericFractionValue;
 848     bool m_sawOrdinalValue;
 849     bool m_sawSlashedZeroValue;
 850     RefPtr&lt;CSSValueList&gt; m_result;
 851 };
 852 
 853 static RefPtr&lt;CSSValue&gt; consumeFontVariantNumeric(CSSParserTokenRange&amp; range)
 854 {
 855     if (range.peek().id() == CSSValueNormal)
 856         return consumeIdent(range);
 857 
 858     FontVariantNumericParser numericParser;
 859     do {
 860         if (numericParser.consumeNumeric(range) !=
 861             FontVariantNumericParser::ParseResult::ConsumedValue)
 862             return nullptr;
 863     } while (!range.atEnd());
 864 
 865     return numericParser.finalizeValue();
 866 }
 867 
 868 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontVariantCSS21(CSSParserTokenRange&amp; range)
 869 {
 870     return consumeIdent&lt;CSSValueNormal, CSSValueSmallCaps&gt;(range);
 871 }
 872 
 873 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontWeightKeywordValue(CSSParserTokenRange&amp; range)
 874 {
 875     return consumeIdent&lt;CSSValueNormal, CSSValueBold, CSSValueBolder, CSSValueLighter&gt;(range);
 876 }
 877 
 878 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontWeight(CSSParserTokenRange&amp; range)
 879 {
 880     if (auto result = consumeFontWeightKeywordValue(range))
 881         return result;
 882     return consumeFontWeightNumber(range);
 883 }
 884 
 885 #if ENABLE(VARIATION_FONTS)
 886 static RefPtr&lt;CSSValue&gt; consumeFontWeightRange(CSSParserTokenRange&amp; range)
 887 {
 888     if (auto result = consumeFontWeightKeywordValue(range))
 889         return result;
 890     auto firstNumber = consumeFontWeightNumber(range);
 891     if (!firstNumber)
 892         return nullptr;
 893     if (range.atEnd())
 894         return firstNumber;
 895     auto secondNumber = consumeFontWeightNumber(range);
 896     if (!secondNumber || firstNumber-&gt;floatValue() &gt; secondNumber-&gt;floatValue())
 897         return nullptr;
 898     auto result = CSSValueList::createSpaceSeparated();
 899     result-&gt;append(firstNumber.releaseNonNull());
 900     result-&gt;append(secondNumber.releaseNonNull());
 901     return RefPtr&lt;CSSValue&gt;(WTFMove(result));
 902 }
 903 #endif
 904 
 905 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontStretchKeywordValue(CSSParserTokenRange&amp; range)
 906 {
 907     return consumeIdent&lt;CSSValueUltraCondensed, CSSValueExtraCondensed, CSSValueCondensed, CSSValueSemiCondensed, CSSValueNormal, CSSValueSemiExpanded, CSSValueExpanded, CSSValueExtraExpanded, CSSValueUltraExpanded&gt;(range);
 908 }
 909 
 910 #if ENABLE(VARIATION_FONTS)
 911 static bool fontStretchIsWithinRange(float stretch)
 912 {
 913     return stretch &gt; 0;
 914 }
 915 #endif
 916 
 917 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontStretch(CSSParserTokenRange&amp; range)
 918 {
 919     if (auto result = consumeFontStretchKeywordValue(range))
 920         return result;
 921 #if ENABLE(VARIATION_FONTS)
 922     if (auto percent = consumePercent(range, ValueRangeNonNegative))
 923         return fontStretchIsWithinRange(percent-&gt;value&lt;float&gt;()) ? percent : nullptr;
 924 #endif
 925     return nullptr;
 926 }
 927 
 928 #if ENABLE(VARIATION_FONTS)
 929 static RefPtr&lt;CSSValue&gt; consumeFontStretchRange(CSSParserTokenRange&amp; range)
 930 {
 931     if (auto result = consumeFontStretchKeywordValue(range))
 932         return result;
 933     auto firstPercent = consumePercent(range, ValueRangeNonNegative);
 934     if (!firstPercent || !fontStretchIsWithinRange(firstPercent-&gt;value&lt;float&gt;()))
 935         return nullptr;
 936     if (range.atEnd())
 937         return firstPercent;
 938     auto secondPercent = consumePercent(range, ValueRangeNonNegative);
 939     if (!secondPercent || !fontStretchIsWithinRange(secondPercent-&gt;value&lt;float&gt;()) || firstPercent-&gt;floatValue() &gt; secondPercent-&gt;floatValue())
 940         return nullptr;
 941     auto result = CSSValueList::createSpaceSeparated();
 942     result-&gt;append(firstPercent.releaseNonNull());
 943     result-&gt;append(secondPercent.releaseNonNull());
 944     return RefPtr&lt;CSSValue&gt;(WTFMove(result));
 945 }
 946 #endif
 947 
 948 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontStyleKeywordValue(CSSParserTokenRange&amp; range)
 949 {
 950     return consumeIdent&lt;CSSValueNormal, CSSValueItalic, CSSValueOblique&gt;(range);
 951 }
 952 
 953 #if ENABLE(VARIATION_FONTS)
 954 static bool fontStyleIsWithinRange(float oblique)
 955 {
 956     return oblique &gt; -90 &amp;&amp; oblique &lt; 90;
 957 }
 958 #endif
 959 
 960 static RefPtr&lt;CSSFontStyleValue&gt; consumeFontStyle(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
 961 {
 962     auto result = consumeFontStyleKeywordValue(range);
 963     if (!result)
 964         return nullptr;
 965 
 966     auto valueID = result-&gt;valueID();
 967     if (valueID == CSSValueNormal || valueID == CSSValueItalic)
 968         return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(valueID));
 969     ASSERT(result-&gt;valueID() == CSSValueOblique);
 970 #if ENABLE(VARIATION_FONTS)
 971     if (!range.atEnd()) {
 972         if (auto angle = consumeAngle(range, cssParserMode)) {
 973             if (fontStyleIsWithinRange(angle-&gt;value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG)))
 974                 return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), WTFMove(angle));
 975             return nullptr;
 976         }
 977     }
 978 #else
 979     UNUSED_PARAM(cssParserMode);
 980 #endif
 981     return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique));
 982 }
 983 
 984 #if ENABLE(VARIATION_FONTS)
 985 static RefPtr&lt;CSSFontStyleRangeValue&gt; consumeFontStyleRange(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
 986 {
 987     auto keyword = consumeFontStyleKeywordValue(range);
 988     if (!keyword)
 989         return nullptr;
 990 
 991     if (keyword-&gt;valueID() != CSSValueOblique || range.atEnd())
 992         return CSSFontStyleRangeValue::create(keyword.releaseNonNull());
 993 
 994     if (auto firstAngle = consumeAngle(range, cssParserMode)) {
 995         if (!fontStyleIsWithinRange(firstAngle-&gt;value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG)))
 996             return nullptr;
 997         if (range.atEnd()) {
 998             auto result = CSSValueList::createSpaceSeparated();
 999             result-&gt;append(firstAngle.releaseNonNull());
1000             return CSSFontStyleRangeValue::create(keyword.releaseNonNull(), WTFMove(result));
1001         }
1002         auto secondAngle = consumeAngle(range, cssParserMode);
1003         if (!secondAngle || !fontStyleIsWithinRange(secondAngle-&gt;value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG)) || firstAngle-&gt;floatValue(CSSPrimitiveValue::CSS_DEG) &gt; secondAngle-&gt;floatValue(CSSPrimitiveValue::CSS_DEG))
1004             return nullptr;
1005         auto result = CSSValueList::createSpaceSeparated();
1006         result-&gt;append(firstAngle.releaseNonNull());
1007         result-&gt;append(secondAngle.releaseNonNull());
1008         return CSSFontStyleRangeValue::create(keyword.releaseNonNull(), WTFMove(result));
1009     }
1010 
1011     return nullptr;
1012 }
1013 #endif
1014 
1015 static String concatenateFamilyName(CSSParserTokenRange&amp; range)
1016 {
1017     StringBuilder builder;
1018     bool addedSpace = false;
1019     const CSSParserToken&amp; firstToken = range.peek();
1020     while (range.peek().type() == IdentToken) {
1021         if (!builder.isEmpty()) {
1022             builder.append(&#39; &#39;);
1023             addedSpace = true;
1024         }
1025         builder.append(range.consumeIncludingWhitespace().value());
1026     }
1027     if (!addedSpace &amp;&amp; isCSSWideKeyword(firstToken.id()))
1028         return String();
1029     return builder.toString();
1030 }
1031 
1032 static RefPtr&lt;CSSValue&gt; consumeFamilyName(CSSParserTokenRange&amp; range)
1033 {
1034     if (range.peek().type() == StringToken)
1035         return CSSValuePool::singleton().createFontFamilyValue(range.consumeIncludingWhitespace().value().toString());
1036     if (range.peek().type() != IdentToken)
1037         return nullptr;
1038     String familyName = concatenateFamilyName(range);
1039     if (familyName.isNull())
1040         return nullptr;
1041     return CSSValuePool::singleton().createFontFamilyValue(familyName);
1042 }
1043 
1044 static RefPtr&lt;CSSValue&gt; consumeGenericFamily(CSSParserTokenRange&amp; range)
1045 {
1046     return consumeIdentRange(range, CSSValueSerif, CSSValueWebkitBody);
1047 }
1048 
1049 static RefPtr&lt;CSSValueList&gt; consumeFontFamily(CSSParserTokenRange&amp; range)
1050 {
1051     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createCommaSeparated();
1052     do {
1053         if (auto parsedValue = consumeGenericFamily(range))
1054             list-&gt;append(parsedValue.releaseNonNull());
1055         else {
1056             if (auto parsedValue = consumeFamilyName(range))
1057                 list-&gt;append(parsedValue.releaseNonNull());
1058             else
1059                 return nullptr;
1060         }
1061     } while (consumeCommaIncludingWhitespace(range));
1062     return list;
1063 }
1064 
1065 static RefPtr&lt;CSSValueList&gt; consumeFontFamilyDescriptor(CSSParserTokenRange&amp; range)
1066 {
1067     // FIXME-NEWPARSER: https://bugs.webkit.org/show_bug.cgi?id=196381 For compatibility with the old parser, we have to make
1068     // a list here, even though the list always contains only a single family name.
1069     // Once the old parser is gone, we can delete this function, make the caller
1070     // use consumeFamilyName instead, and then patch the @font-face code to
1071     // not expect a list with a single name in it.
1072     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createCommaSeparated();
1073     RefPtr&lt;CSSValue&gt; parsedValue = consumeFamilyName(range);
1074     if (parsedValue)
1075         list-&gt;append(parsedValue.releaseNonNull());
1076 
1077     if (!range.atEnd() || !list-&gt;length())
1078         return nullptr;
1079 
1080     return list;
1081 }
1082 
1083 static RefPtr&lt;CSSValue&gt; consumeFontSynthesis(CSSParserTokenRange&amp; range)
1084 {
1085     // none | [ weight || style || small-caps ]
1086     CSSValueID id = range.peek().id();
1087     if (id == CSSValueNone)
1088         return consumeIdent(range);
1089 
1090     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1091     while (true) {
1092         auto ident = consumeIdent&lt;CSSValueWeight, CSSValueStyle, CSSValueSmallCaps&gt;(range);
1093         if (!ident)
1094             break;
1095         if (list-&gt;hasValue(ident.get()))
1096             return nullptr;
1097         list-&gt;append(ident.releaseNonNull());
1098     }
1099 
1100     if (!list-&gt;length())
1101         return nullptr;
1102     return list;
1103 }
1104 
1105 static RefPtr&lt;CSSValue&gt; consumeLetterSpacing(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1106 {
1107     if (range.peek().id() == CSSValueNormal)
1108         return consumeIdent(range);
1109 
1110     return consumeLength(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
1111 }
1112 
1113 static RefPtr&lt;CSSValue&gt; consumeWordSpacing(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1114 {
1115     if (range.peek().id() == CSSValueNormal)
1116         return consumeIdent(range);
1117 
1118     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
1119 }
1120 
1121 static RefPtr&lt;CSSValue&gt; consumeTabSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1122 {
1123     auto tabSize = consumeNumber(range, ValueRangeNonNegative);
1124     if (tabSize)
1125         return tabSize;
1126     return consumeLength(range, cssParserMode, ValueRangeNonNegative);
1127 }
1128 
1129 #if ENABLE(TEXT_AUTOSIZING)
1130 static RefPtr&lt;CSSValue&gt; consumeTextSizeAdjust(CSSParserTokenRange&amp; range, CSSParserMode /* cssParserMode */)
1131 {
1132     if (range.peek().id() == CSSValueAuto)
1133         return consumeIdent(range);
1134     if (range.peek().id() == CSSValueNone)
1135         return consumeIdent(range);
1136     return consumePercent(range, ValueRangeNonNegative);
1137 }
1138 #endif
1139 
1140 static RefPtr&lt;CSSValue&gt; consumeFontSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless = UnitlessQuirk::Forbid)
1141 {
1142     if (range.peek().id() &gt;= CSSValueXxSmall &amp;&amp; range.peek().id() &lt;= CSSValueLarger)
1143         return consumeIdent(range);
1144     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, unitless);
1145 }
1146 
1147 static RefPtr&lt;CSSPrimitiveValue&gt; consumeLineHeight(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1148 {
1149     if (range.peek().id() == CSSValueNormal)
1150         return consumeIdent(range);
1151 
1152     RefPtr&lt;CSSPrimitiveValue&gt; lineHeight = consumeNumber(range, ValueRangeNonNegative);
1153     if (lineHeight)
1154         return lineHeight;
1155     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
1156 }
1157 
1158 template&lt;typename... Args&gt;
1159 static Ref&lt;CSSPrimitiveValue&gt; createPrimitiveValuePair(Args&amp;&amp;... args)
1160 {
1161     return CSSValuePool::singleton().createValue(Pair::create(std::forward&lt;Args&gt;(args)...));
1162 }
1163 
1164 
1165 static RefPtr&lt;CSSValue&gt; consumeCounter(CSSParserTokenRange&amp; range, int defaultValue)
1166 {
1167     if (range.peek().id() == CSSValueNone)
1168         return consumeIdent(range);
1169 
1170     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1171     do {
1172         RefPtr&lt;CSSPrimitiveValue&gt; counterName = consumeCustomIdent(range);
1173         if (!counterName)
1174             return nullptr;
1175         int i = defaultValue;
1176         if (RefPtr&lt;CSSPrimitiveValue&gt; counterValue = consumeInteger(range))
1177             i = counterValue-&gt;intValue();
1178         list-&gt;append(createPrimitiveValuePair(counterName.releaseNonNull(), CSSPrimitiveValue::create(i, CSSPrimitiveValue::UnitType::CSS_NUMBER), Pair::IdenticalValueEncoding::Coalesce));
1179     } while (!range.atEnd());
1180     return list;
1181 }
1182 
1183 static RefPtr&lt;CSSValue&gt; consumePageSize(CSSParserTokenRange&amp; range)
1184 {
1185     return consumeIdent&lt;CSSValueA3, CSSValueA4, CSSValueA5, CSSValueB4, CSSValueB5, CSSValueLedger, CSSValueLegal, CSSValueLetter&gt;(range);
1186 }
1187 
1188 static RefPtr&lt;CSSValueList&gt; consumeSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1189 {
1190     RefPtr&lt;CSSValueList&gt; result = CSSValueList::createSpaceSeparated();
1191 
1192     if (range.peek().id() == CSSValueAuto) {
1193         result-&gt;append(consumeIdent(range).releaseNonNull());
1194         return result;
1195     }
1196 
1197     if (RefPtr&lt;CSSValue&gt; width = consumeLength(range, cssParserMode, ValueRangeNonNegative)) {
1198         RefPtr&lt;CSSValue&gt; height = consumeLength(range, cssParserMode, ValueRangeNonNegative);
1199         result-&gt;append(width.releaseNonNull());
1200         if (height)
1201             result-&gt;append(height.releaseNonNull());
1202         return result;
1203     }
1204 
1205     RefPtr&lt;CSSValue&gt; pageSize = consumePageSize(range);
1206     RefPtr&lt;CSSValue&gt; orientation = consumeIdent&lt;CSSValuePortrait, CSSValueLandscape&gt;(range);
1207     if (!pageSize)
1208         pageSize = consumePageSize(range);
1209 
1210     if (!orientation &amp;&amp; !pageSize)
1211         return nullptr;
1212     if (pageSize)
1213         result-&gt;append(pageSize.releaseNonNull());
1214     if (orientation)
1215         result-&gt;append(orientation.releaseNonNull());
1216     return result;
1217 }
1218 
1219 static RefPtr&lt;CSSValue&gt; consumeTextIndent(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1220 {
1221     // [ &lt;length&gt; | &lt;percentage&gt; ] &amp;&amp; hanging? &amp;&amp; each-line?
1222     // Keywords only allowed when css3Text is enabled.
1223     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1224 
1225     bool hasLengthOrPercentage = false;
1226 //    bool hasEachLine = false;
1227     bool hasHanging = false;
1228 
1229     do {
1230         if (!hasLengthOrPercentage) {
1231             if (RefPtr&lt;CSSValue&gt; textIndent = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow)) {
1232                 list-&gt;append(*textIndent);
1233                 hasLengthOrPercentage = true;
1234                 continue;
1235             }
1236         }
1237 
1238         CSSValueID id = range.peek().id();
1239  /* FIXME-NEWPARSER: We don&#39;t support this yet.
1240         if (!hasEachLine &amp;&amp; id == CSSValueEachLine) {
1241             list-&gt;append(*consumeIdent(range));
1242             hasEachLine = true;
1243             continue;
1244         }
1245 */
1246 
1247         if (!hasHanging &amp;&amp; id == CSSValueHanging) {
1248             list-&gt;append(consumeIdent(range).releaseNonNull());
1249             hasHanging = true;
1250             continue;
1251         }
1252 
1253         return nullptr;
1254     } while (!range.atEnd());
1255 
1256     if (!hasLengthOrPercentage)
1257         return nullptr;
1258 
1259     return list;
1260 }
1261 
1262 static bool validWidthOrHeightKeyword(CSSValueID id, const CSSParserContext&amp; /*context*/)
1263 {
1264     if (id == CSSValueIntrinsic || id == CSSValueMinIntrinsic || id == CSSValueMinContent || id == CSSValueWebkitMinContent || id == CSSValueMaxContent || id == CSSValueWebkitMaxContent || id == CSSValueWebkitFillAvailable || id == CSSValueFitContent || id == CSSValueWebkitFitContent) {
1265         return true;
1266     }
1267     return false;
1268 }
1269 
1270 static RefPtr&lt;CSSValue&gt; consumeMaxWidthOrHeight(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, UnitlessQuirk unitless = UnitlessQuirk::Forbid)
1271 {
1272     if (range.peek().id() == CSSValueNone || validWidthOrHeightKeyword(range.peek().id(), context))
1273         return consumeIdent(range);
1274     return consumeLengthOrPercent(range, context.mode, ValueRangeNonNegative, unitless);
1275 }
1276 
1277 static RefPtr&lt;CSSValue&gt; consumeWidthOrHeight(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, UnitlessQuirk unitless = UnitlessQuirk::Forbid)
1278 {
1279     if (range.peek().id() == CSSValueAuto || validWidthOrHeightKeyword(range.peek().id(), context))
1280         return consumeIdent(range);
1281     return consumeLengthOrPercent(range, context.mode, ValueRangeNonNegative, unitless);
1282 }
1283 
1284 static RefPtr&lt;CSSValue&gt; consumeMarginOrOffset(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless)
1285 {
1286     if (range.peek().id() == CSSValueAuto)
1287         return consumeIdent(range);
1288     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, unitless);
1289 }
1290 
1291 static RefPtr&lt;CSSPrimitiveValue&gt; consumeClipComponent(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1292 {
1293     if (range.peek().id() == CSSValueAuto)
1294         return consumeIdent(range);
1295     return consumeLength(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
1296 }
1297 
1298 static RefPtr&lt;CSSValue&gt; consumeClip(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1299 {
1300     if (range.peek().id() == CSSValueAuto)
1301         return consumeIdent(range);
1302 
1303     if (range.peek().functionId() != CSSValueRect)
1304         return nullptr;
1305 
1306     CSSParserTokenRange args = consumeFunction(range);
1307     // rect(t, r, b, l) || rect(t r b l)
1308     RefPtr&lt;CSSPrimitiveValue&gt; top = consumeClipComponent(args, cssParserMode);
1309     if (!top)
1310         return nullptr;
1311     bool needsComma = consumeCommaIncludingWhitespace(args);
1312     RefPtr&lt;CSSPrimitiveValue&gt; right = consumeClipComponent(args, cssParserMode);
1313     if (!right || (needsComma &amp;&amp; !consumeCommaIncludingWhitespace(args)))
1314         return nullptr;
1315     RefPtr&lt;CSSPrimitiveValue&gt; bottom = consumeClipComponent(args, cssParserMode);
1316     if (!bottom || (needsComma &amp;&amp; !consumeCommaIncludingWhitespace(args)))
1317         return nullptr;
1318     RefPtr&lt;CSSPrimitiveValue&gt; left = consumeClipComponent(args, cssParserMode);
1319     if (!left || !args.atEnd())
1320         return nullptr;
1321 
1322     auto rect = Rect::create();
1323     rect-&gt;setLeft(left.releaseNonNull());
1324     rect-&gt;setTop(top.releaseNonNull());
1325     rect-&gt;setRight(right.releaseNonNull());
1326     rect-&gt;setBottom(bottom.releaseNonNull());
1327     return CSSValuePool::singleton().createValue(WTFMove(rect));
1328 }
1329 
1330 #if ENABLE(POINTER_EVENTS)
1331 static RefPtr&lt;CSSValue&gt; consumeTouchAction(CSSParserTokenRange&amp; range)
1332 {
1333     CSSValueID id = range.peek().id();
1334     if (id == CSSValueNone || id == CSSValueAuto || id == CSSValueManipulation)
1335         return consumeIdent(range);
1336 
1337     auto list = CSSValueList::createSpaceSeparated();
1338     while (true) {
1339         auto ident = consumeIdent&lt;CSSValuePanX, CSSValuePanY, CSSValuePinchZoom&gt;(range);
1340         if (!ident)
1341             break;
1342         if (list-&gt;hasValue(ident.get()))
1343             return nullptr;
1344         list-&gt;append(ident.releaseNonNull());
1345     }
1346 
1347     if (!list-&gt;length())
1348         return nullptr;
1349     return list;
1350 }
1351 #endif
1352 
1353 static RefPtr&lt;CSSPrimitiveValue&gt; consumeLineClamp(CSSParserTokenRange&amp; range)
1354 {
1355     RefPtr&lt;CSSPrimitiveValue&gt; clampValue = consumePercent(range, ValueRangeNonNegative);
1356     if (clampValue)
1357         return clampValue;
1358     // When specifying number of lines, don&#39;t allow 0 as a valid value.
1359     return consumePositiveInteger(range);
1360 }
1361 
1362 static RefPtr&lt;CSSValue&gt; consumeAutoOrString(CSSParserTokenRange&amp; range)
1363 {
1364     if (range.peek().id() == CSSValueAuto)
1365         return consumeIdent(range);
1366     return consumeString(range);
1367 }
1368 
1369 static RefPtr&lt;CSSValue&gt; consumeHyphenateLimit(CSSParserTokenRange&amp; range, CSSValueID valueID)
1370 {
1371     if (range.peek().id() == valueID)
1372         return consumeIdent(range);
1373     return consumeNumber(range, ValueRangeNonNegative);
1374 }
1375 
1376 static RefPtr&lt;CSSValue&gt; consumeColumnWidth(CSSParserTokenRange&amp; range)
1377 {
1378     if (range.peek().id() == CSSValueAuto)
1379         return consumeIdent(range);
1380     // Always parse lengths in strict mode here, since it would be ambiguous otherwise when used in
1381     // the &#39;columns&#39; shorthand property.
1382     RefPtr&lt;CSSPrimitiveValue&gt; columnWidth = consumeLength(range, HTMLStandardMode, ValueRangeNonNegative);
1383     if (!columnWidth || (!columnWidth-&gt;isCalculated() &amp;&amp; !columnWidth-&gt;doubleValue()) || (columnWidth-&gt;cssCalcValue() &amp;&amp; !columnWidth-&gt;cssCalcValue()-&gt;doubleValue()))
1384         return nullptr;
1385     return columnWidth;
1386 }
1387 
1388 static RefPtr&lt;CSSValue&gt; consumeColumnCount(CSSParserTokenRange&amp; range)
1389 {
1390     if (range.peek().id() == CSSValueAuto)
1391         return consumeIdent(range);
1392     return consumePositiveInteger(range);
1393 }
1394 
1395 static RefPtr&lt;CSSValue&gt; consumeGapLength(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1396 {
1397     if (range.peek().id() == CSSValueNormal)
1398         return consumeIdent(range);
1399     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
1400 }
1401 
1402 static RefPtr&lt;CSSValue&gt; consumeColumnSpan(CSSParserTokenRange&amp; range)
1403 {
1404     return consumeIdent&lt;CSSValueAll, CSSValueNone&gt;(range);
1405 }
1406 
1407 static RefPtr&lt;CSSValue&gt; consumeZoom(CSSParserTokenRange&amp; range, const CSSParserContext&amp; /*context*/)
1408 {
1409     const CSSParserToken&amp; token = range.peek();
1410     RefPtr&lt;CSSPrimitiveValue&gt; zoom;
1411     if (token.type() == IdentToken)
1412         zoom = consumeIdent&lt;CSSValueNormal, CSSValueReset, CSSValueDocument&gt;(range);
1413     else {
1414         zoom = consumePercent(range, ValueRangeNonNegative);
1415         if (!zoom)
1416             zoom = consumeNumber(range, ValueRangeNonNegative);
1417     }
1418     return zoom;
1419 }
1420 
1421 static RefPtr&lt;CSSValue&gt; consumeAnimationIterationCount(CSSParserTokenRange&amp; range)
1422 {
1423     if (range.peek().id() == CSSValueInfinite)
1424         return consumeIdent(range);
1425     return consumeNumber(range, ValueRangeNonNegative);
1426 }
1427 
1428 static RefPtr&lt;CSSValue&gt; consumeAnimationName(CSSParserTokenRange&amp; range)
1429 {
1430     if (range.peek().id() == CSSValueNone)
1431         return consumeIdent(range);
1432 
1433     if (range.peek().type() == StringToken) {
1434         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
1435         if (equalIgnoringASCIICase(token.value(), &quot;none&quot;))
1436             return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1437         // FIXME-NEWPARSER: Want to use a CSSCustomIdentValue here eventually.
1438         return CSSValuePool::singleton().createValue(token.value().toString(), CSSPrimitiveValue::UnitType::CSS_STRING);
1439     }
1440 
1441     return consumeCustomIdent(range);
1442 }
1443 
1444 static RefPtr&lt;CSSValue&gt; consumeTransitionProperty(CSSParserTokenRange&amp; range)
1445 {
1446     const CSSParserToken&amp; token = range.peek();
1447     if (token.type() != IdentToken)
1448         return nullptr;
1449     if (token.id() == CSSValueNone)
1450         return consumeIdent(range);
1451 
1452     if (CSSPropertyID property = token.parseAsCSSPropertyID()) {
1453         range.consumeIncludingWhitespace();
1454 
1455         // FIXME-NEWPARSER: No reason why we can&#39;t use the &quot;all&quot; property now that it exists.
1456         // The old parser used a value keyword for &quot;all&quot;, though, since it predated support for
1457         // the property.
1458         if (property == CSSPropertyAll)
1459             return CSSValuePool::singleton().createIdentifierValue(CSSValueAll);
1460 
1461         // FIXME-NEWPARSER: Want to use a CSSCustomIdentValue here eventually.
1462         return CSSValuePool::singleton().createIdentifierValue(property);
1463     }
1464     return consumeCustomIdent(range);
1465 }
1466 
1467 
1468 static RefPtr&lt;CSSValue&gt; consumeSteps(CSSParserTokenRange&amp; range)
1469 {
1470     ASSERT(range.peek().functionId() == CSSValueSteps);
1471     CSSParserTokenRange rangeCopy = range;
1472     CSSParserTokenRange args = consumeFunction(rangeCopy);
1473 
1474     RefPtr&lt;CSSPrimitiveValue&gt; steps = consumePositiveInteger(args);
1475     if (!steps)
1476         return nullptr;
1477 
1478     // FIXME-NEWPARSER: Support the middle value and change from a boolean to an enum.
1479     bool stepAtStart = false;
1480     if (consumeCommaIncludingWhitespace(args)) {
1481         switch (args.consumeIncludingWhitespace().id()) {
1482             case CSSValueStart:
1483                 stepAtStart = true;
1484             break;
1485             case CSSValueEnd:
1486                 stepAtStart = false;
1487                 break;
1488             default:
1489                 return nullptr;
1490         }
1491     }
1492 
1493     if (!args.atEnd())
1494         return nullptr;
1495 
1496     range = rangeCopy;
1497     return CSSStepsTimingFunctionValue::create(steps-&gt;intValue(), stepAtStart);
1498 }
1499 
1500 static RefPtr&lt;CSSValue&gt; consumeCubicBezier(CSSParserTokenRange&amp; range)
1501 {
1502     ASSERT(range.peek().functionId() == CSSValueCubicBezier);
1503     CSSParserTokenRange rangeCopy = range;
1504     CSSParserTokenRange args = consumeFunction(rangeCopy);
1505 
1506     double x1, y1, x2, y2;
1507     if (consumeNumberRaw(args, x1)
1508         &amp;&amp; x1 &gt;= 0 &amp;&amp; x1 &lt;= 1
1509         &amp;&amp; consumeCommaIncludingWhitespace(args)
1510         &amp;&amp; consumeNumberRaw(args, y1)
1511         &amp;&amp; consumeCommaIncludingWhitespace(args)
1512         &amp;&amp; consumeNumberRaw(args, x2)
1513         &amp;&amp; x2 &gt;= 0 &amp;&amp; x2 &lt;= 1
1514         &amp;&amp; consumeCommaIncludingWhitespace(args)
1515         &amp;&amp; consumeNumberRaw(args, y2)
1516         &amp;&amp; args.atEnd()) {
1517         range = rangeCopy;
1518         return CSSCubicBezierTimingFunctionValue::create(x1, y1, x2, y2);
1519     }
1520 
1521     return nullptr;
1522 }
1523 
1524 static RefPtr&lt;CSSValue&gt; consumeSpringFunction(CSSParserTokenRange&amp; range)
1525 {
1526     ASSERT(range.peek().functionId() == CSSValueSpring);
1527     CSSParserTokenRange rangeCopy = range;
1528     CSSParserTokenRange args = consumeFunction(rangeCopy);
1529 
1530     // Mass must be greater than 0.
1531     double mass;
1532     if (!consumeNumberRaw(args, mass) || mass &lt;= 0)
1533         return nullptr;
1534 
1535     // Stiffness must be greater than 0.
1536     double stiffness;
1537     if (!consumeNumberRaw(args, stiffness) || stiffness &lt;= 0)
1538         return nullptr;
1539 
1540     // Damping coefficient must be greater than or equal to 0.
1541     double damping;
1542     if (!consumeNumberRaw(args, damping) || damping &lt; 0)
1543         return nullptr;
1544 
1545     // Initial velocity may have any value.
1546     double initialVelocity;
1547     if (!consumeNumberRaw(args, initialVelocity))
1548         return nullptr;
1549 
1550     if (!args.atEnd())
1551         return nullptr;
1552 
1553     range = rangeCopy;
1554 
1555     return CSSSpringTimingFunctionValue::create(mass, stiffness, damping, initialVelocity);
1556 }
1557 
1558 static RefPtr&lt;CSSValue&gt; consumeAnimationTimingFunction(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
1559 {
1560     CSSValueID id = range.peek().id();
1561     if (id == CSSValueEase || id == CSSValueLinear || id == CSSValueEaseIn
1562         || id == CSSValueEaseOut || id == CSSValueEaseInOut || id == CSSValueStepStart || id == CSSValueStepEnd)
1563         return consumeIdent(range);
1564 
1565     CSSValueID function = range.peek().functionId();
1566     if (function == CSSValueCubicBezier)
1567         return consumeCubicBezier(range);
1568     if (function == CSSValueSteps)
1569         return consumeSteps(range);
1570     if (context.springTimingFunctionEnabled &amp;&amp; function == CSSValueSpring)
1571         return consumeSpringFunction(range);
1572     return nullptr;
1573 }
1574 
1575 static RefPtr&lt;CSSValue&gt; consumeAnimationValue(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
1576 {
1577     switch (property) {
1578     case CSSPropertyAnimationDelay:
1579     case CSSPropertyTransitionDelay:
1580         return consumeTime(range, context.mode, ValueRangeAll, UnitlessQuirk::Forbid);
1581     case CSSPropertyAnimationDirection:
1582         return consumeIdent&lt;CSSValueNormal, CSSValueAlternate, CSSValueReverse, CSSValueAlternateReverse&gt;(range);
1583     case CSSPropertyAnimationDuration:
1584     case CSSPropertyTransitionDuration:
1585         return consumeTime(range, context.mode, ValueRangeNonNegative, UnitlessQuirk::Forbid);
1586     case CSSPropertyAnimationFillMode:
1587         return consumeIdent&lt;CSSValueNone, CSSValueForwards, CSSValueBackwards, CSSValueBoth&gt;(range);
1588     case CSSPropertyAnimationIterationCount:
1589         return consumeAnimationIterationCount(range);
1590     case CSSPropertyAnimationName:
1591         return consumeAnimationName(range);
1592     case CSSPropertyAnimationPlayState:
1593         return consumeIdent&lt;CSSValueRunning, CSSValuePaused&gt;(range);
1594     case CSSPropertyTransitionProperty:
1595         return consumeTransitionProperty(range);
1596     case CSSPropertyAnimationTimingFunction:
1597     case CSSPropertyTransitionTimingFunction:
1598         return consumeAnimationTimingFunction(range, context);
1599     default:
1600         ASSERT_NOT_REACHED();
1601         return nullptr;
1602     }
1603 }
1604 
1605 static bool isValidAnimationPropertyList(CSSPropertyID property, const CSSValueList&amp; valueList)
1606 {
1607     if (property != CSSPropertyTransitionProperty || valueList.length() &lt; 2)
1608         return true;
1609     for (auto&amp; value : valueList) {
1610         if (value-&gt;isPrimitiveValue() &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value.get()).isValueID()
1611             &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value.get()).valueID() == CSSValueNone)
1612             return false;
1613     }
1614     return true;
1615 }
1616 
1617 static RefPtr&lt;CSSValue&gt; consumeAnimationPropertyList(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
1618 {
1619     RefPtr&lt;CSSValueList&gt; list;
1620     RefPtr&lt;CSSValue&gt; singleton;
1621     do {
1622         RefPtr&lt;CSSValue&gt; currentValue = consumeAnimationValue(property, range, context);
1623         if (!currentValue)
1624             return nullptr;
1625 
1626         if (singleton &amp;&amp; !list) {
1627             list = CSSValueList::createCommaSeparated();
1628             list-&gt;append(singleton.releaseNonNull());
1629         }
1630 
1631         if (list)
1632             list-&gt;append(currentValue.releaseNonNull());
1633         else
1634             singleton = WTFMove(currentValue);
1635 
1636     } while (consumeCommaIncludingWhitespace(range));
1637 
1638     if (list) {
1639         if (!isValidAnimationPropertyList(property, *list))
1640             return nullptr;
1641 
1642         ASSERT(list-&gt;length());
1643         return list;
1644     }
1645 
1646     return singleton;
1647 }
1648 
1649 bool CSSPropertyParser::consumeAnimationShorthand(const StylePropertyShorthand&amp; shorthand, bool important)
1650 {
1651     const unsigned longhandCount = shorthand.length();
1652     RefPtr&lt;CSSValueList&gt; longhands[8];
1653     ASSERT(longhandCount &lt;= 8);
1654     for (size_t i = 0; i &lt; longhandCount; ++i)
1655         longhands[i] = CSSValueList::createCommaSeparated();
1656 
1657     do {
1658         bool parsedLonghand[8] = { false };
1659         do {
1660             bool foundProperty = false;
1661             for (size_t i = 0; i &lt; longhandCount; ++i) {
1662                 if (parsedLonghand[i])
1663                     continue;
1664 
1665                 if (RefPtr&lt;CSSValue&gt; value = consumeAnimationValue(shorthand.properties()[i], m_range, m_context)) {
1666                     parsedLonghand[i] = true;
1667                     foundProperty = true;
1668                     longhands[i]-&gt;append(*value);
1669                     break;
1670                 }
1671             }
1672             if (!foundProperty)
1673                 return false;
1674         } while (!m_range.atEnd() &amp;&amp; m_range.peek().type() != CommaToken);
1675 
1676         // FIXME: This will make invalid longhands, see crbug.com/386459
1677         for (size_t i = 0; i &lt; longhandCount; ++i) {
1678             if (!parsedLonghand[i])
1679                 longhands[i]-&gt;append(CSSValuePool::singleton().createImplicitInitialValue());
1680             parsedLonghand[i] = false;
1681         }
1682     } while (consumeCommaIncludingWhitespace(m_range));
1683 
1684     for (size_t i = 0; i &lt; longhandCount; ++i) {
1685         if (!isValidAnimationPropertyList(shorthand.properties()[i], *longhands[i]))
1686             return false;
1687     }
1688 
1689     for (size_t i = 0; i &lt; longhandCount; ++i)
1690         addProperty(shorthand.properties()[i], shorthand.id(), *longhands[i], important);
1691 
1692     return m_range.atEnd();
1693 }
1694 
1695 static RefPtr&lt;CSSValue&gt; consumeZIndex(CSSParserTokenRange&amp; range)
1696 {
1697     if (range.peek().id() == CSSValueAuto)
1698         return consumeIdent(range);
1699     return consumeInteger(range);
1700 }
1701 
1702 static RefPtr&lt;CSSValue&gt; consumeShadow(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, bool isBoxShadowProperty)
1703 {
1704     if (range.peek().id() == CSSValueNone)
1705         return consumeIdent(range);
1706 
1707     RefPtr&lt;CSSValueList&gt; shadowValueList = CSSValueList::createCommaSeparated();
1708     do {
1709         if (RefPtr&lt;CSSShadowValue&gt; shadowValue = consumeSingleShadow(range, cssParserMode, isBoxShadowProperty, isBoxShadowProperty))
1710             shadowValueList-&gt;append(*shadowValue);
1711         else
1712             return nullptr;
1713     } while (consumeCommaIncludingWhitespace(range));
1714     return shadowValueList;
1715 }
1716 
1717 static RefPtr&lt;CSSValue&gt; consumeTextDecorationLine(CSSParserTokenRange&amp; range)
1718 {
1719     CSSValueID id = range.peek().id();
1720     if (id == CSSValueNone)
1721         return consumeIdent(range);
1722 
1723     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1724     while (true) {
1725 #if ENABLE(LETTERPRESS)
1726         RefPtr&lt;CSSPrimitiveValue&gt; ident = consumeIdent&lt;CSSValueBlink, CSSValueUnderline, CSSValueOverline, CSSValueLineThrough, CSSValueWebkitLetterpress&gt;(range);
1727 #else
1728         RefPtr&lt;CSSPrimitiveValue&gt; ident = consumeIdent&lt;CSSValueBlink, CSSValueUnderline, CSSValueOverline, CSSValueLineThrough&gt;(range);
1729 #endif
1730         if (!ident)
1731             break;
1732         if (list-&gt;hasValue(ident.get()))
1733             return nullptr;
1734         list-&gt;append(ident.releaseNonNull());
1735     }
1736 
1737     if (!list-&gt;length())
1738         return nullptr;
1739     return list;
1740 }
1741 
1742 static RefPtr&lt;CSSValue&gt; consumeTextDecorationSkip(CSSParserTokenRange&amp; range)
1743 {
1744     CSSValueID id = range.peek().id();
1745     if (id == CSSValueNone)
1746         return consumeIdent(range);
1747 
1748     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1749     while (true) {
1750         auto ident = consumeIdent&lt;CSSValueAuto, CSSValueInk, CSSValueObjects&gt;(range);
1751         if (!ident)
1752             break;
1753         if (list-&gt;hasValue(ident.get()))
1754             return nullptr;
1755         list-&gt;append(ident.releaseNonNull());
1756     }
1757 
1758     if (!list-&gt;length())
1759         return nullptr;
1760     return list;
1761 }
1762 
1763 static RefPtr&lt;CSSValue&gt; consumeTextEmphasisStyle(CSSParserTokenRange&amp; range)
1764 {
1765     CSSValueID id = range.peek().id();
1766     if (id == CSSValueNone)
1767         return consumeIdent(range);
1768 
1769     if (RefPtr&lt;CSSValue&gt; textEmphasisStyle = consumeString(range))
1770         return textEmphasisStyle;
1771 
1772     RefPtr&lt;CSSPrimitiveValue&gt; fill = consumeIdent&lt;CSSValueFilled, CSSValueOpen&gt;(range);
1773     RefPtr&lt;CSSPrimitiveValue&gt; shape = consumeIdent&lt;CSSValueDot, CSSValueCircle, CSSValueDoubleCircle, CSSValueTriangle, CSSValueSesame&gt;(range);
1774     if (!fill)
1775         fill = consumeIdent&lt;CSSValueFilled, CSSValueOpen&gt;(range);
1776     if (fill &amp;&amp; shape) {
1777         RefPtr&lt;CSSValueList&gt; parsedValues = CSSValueList::createSpaceSeparated();
1778         parsedValues-&gt;append(fill.releaseNonNull());
1779         parsedValues-&gt;append(shape.releaseNonNull());
1780         return parsedValues;
1781     }
1782     if (fill)
1783         return fill;
1784     if (shape)
1785         return shape;
1786     return nullptr;
1787 }
1788 
1789 static RefPtr&lt;CSSPrimitiveValue&gt; consumeCaretColor(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1790 {
1791     if (range.peek().id() == CSSValueAuto)
1792         return consumeIdent(range);
1793     return consumeColor(range, cssParserMode);
1794 }
1795 
1796 static RefPtr&lt;CSSValue&gt; consumeOutlineColor(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1797 {
1798     // Allow the special focus color even in HTML Standard parsing mode.
1799     if (range.peek().id() == CSSValueWebkitFocusRingColor)
1800         return consumeIdent(range);
1801     return consumeColor(range, cssParserMode);
1802 }
1803 
1804 static RefPtr&lt;CSSPrimitiveValue&gt; consumeLineWidth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless)
1805 {
1806     CSSValueID id = range.peek().id();
1807     if (id == CSSValueThin || id == CSSValueMedium || id == CSSValueThick)
1808         return consumeIdent(range);
1809     return consumeLength(range, cssParserMode, ValueRangeNonNegative, unitless);
1810 }
1811 
1812 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBorderWidth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless)
1813 {
1814     return consumeLineWidth(range, cssParserMode, unitless);
1815 }
1816 
1817 static RefPtr&lt;CSSPrimitiveValue&gt; consumeTextStrokeWidth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1818 {
1819     return consumeLineWidth(range, cssParserMode, UnitlessQuirk::Forbid);
1820 }
1821 
1822 static RefPtr&lt;CSSPrimitiveValue&gt; consumeColumnRuleWidth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1823 {
1824     return consumeLineWidth(range, cssParserMode, UnitlessQuirk::Forbid);
1825 }
1826 
1827 static bool consumeTranslate3d(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, RefPtr&lt;CSSFunctionValue&gt;&amp; transformValue)
1828 {
1829     unsigned numberOfArguments = 2;
1830     RefPtr&lt;CSSValue&gt; parsedValue;
1831     do {
1832         parsedValue = consumeLengthOrPercent(args, cssParserMode, ValueRangeAll);
1833         if (!parsedValue)
1834             return false;
1835         transformValue-&gt;append(*parsedValue);
1836         if (!consumeCommaIncludingWhitespace(args))
1837             return false;
1838     } while (--numberOfArguments);
1839     parsedValue = consumeLength(args, cssParserMode, ValueRangeAll);
1840     if (!parsedValue)
1841         return false;
1842     transformValue-&gt;append(*parsedValue);
1843     return true;
1844 }
1845 
1846 static bool consumeNumbers(CSSParserTokenRange&amp; args, RefPtr&lt;CSSFunctionValue&gt;&amp; transformValue, unsigned numberOfArguments)
1847 {
1848     do {
1849         RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeNumber(args, ValueRangeAll);
1850         if (!parsedValue)
1851             return false;
1852         transformValue-&gt;append(parsedValue.releaseNonNull());
1853         if (--numberOfArguments &amp;&amp; !consumeCommaIncludingWhitespace(args))
1854             return false;
1855     } while (numberOfArguments);
1856     return true;
1857 }
1858 
1859 static bool consumePerspective(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, RefPtr&lt;CSSFunctionValue&gt;&amp; transformValue)
1860 {
1861     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeLength(args, cssParserMode, ValueRangeNonNegative);
1862     if (!parsedValue) {
1863         double perspective;
1864         if (!consumeNumberRaw(args, perspective) || perspective &lt; 0)
1865             return false;
1866         parsedValue = CSSPrimitiveValue::create(perspective, CSSPrimitiveValue::UnitType::CSS_PX);
1867     }
1868     if (!parsedValue)
1869         return false;
1870     transformValue-&gt;append(parsedValue.releaseNonNull());
1871     return true;
1872 }
1873 
1874 static RefPtr&lt;CSSValue&gt; consumeTransformValue(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1875 {
1876     CSSValueID functionId = range.peek().functionId();
1877     if (functionId == CSSValueInvalid)
1878         return nullptr;
1879     CSSParserTokenRange args = consumeFunction(range);
1880     if (args.atEnd())
1881         return nullptr;
1882 
1883     RefPtr&lt;CSSFunctionValue&gt; transformValue = CSSFunctionValue::create(functionId);
1884     RefPtr&lt;CSSValue&gt; parsedValue;
1885     switch (functionId) {
1886     case CSSValueRotate:
1887     case CSSValueRotateX:
1888     case CSSValueRotateY:
1889     case CSSValueRotateZ:
1890     case CSSValueSkewX:
1891     case CSSValueSkewY:
1892     case CSSValueSkew:
1893         parsedValue = consumeAngle(args, cssParserMode, UnitlessQuirk::Forbid);
1894         if (!parsedValue)
1895             return nullptr;
1896         if (functionId == CSSValueSkew &amp;&amp; consumeCommaIncludingWhitespace(args)) {
1897             transformValue-&gt;append(*parsedValue);
1898             parsedValue = consumeAngle(args, cssParserMode, UnitlessQuirk::Forbid);
1899             if (!parsedValue)
1900                 return nullptr;
1901         }
1902         break;
1903     case CSSValueScaleX:
1904     case CSSValueScaleY:
1905     case CSSValueScaleZ:
1906     case CSSValueScale:
1907         parsedValue = consumeNumber(args, ValueRangeAll);
1908         if (!parsedValue)
1909             return nullptr;
1910         if (functionId == CSSValueScale &amp;&amp; consumeCommaIncludingWhitespace(args)) {
1911             transformValue-&gt;append(*parsedValue);
1912             parsedValue = consumeNumber(args, ValueRangeAll);
1913             if (!parsedValue)
1914                 return nullptr;
1915         }
1916         break;
1917     case CSSValuePerspective:
1918         if (!consumePerspective(args, cssParserMode, transformValue))
1919             return nullptr;
1920         break;
1921     case CSSValueTranslateX:
1922     case CSSValueTranslateY:
1923     case CSSValueTranslate:
1924         parsedValue = consumeLengthOrPercent(args, cssParserMode, ValueRangeAll);
1925         if (!parsedValue)
1926             return nullptr;
1927         if (functionId == CSSValueTranslate &amp;&amp; consumeCommaIncludingWhitespace(args)) {
1928             transformValue-&gt;append(*parsedValue);
1929             parsedValue = consumeLengthOrPercent(args, cssParserMode, ValueRangeAll);
1930             if (!parsedValue)
1931                 return nullptr;
1932         }
1933         break;
1934     case CSSValueTranslateZ:
1935         parsedValue = consumeLength(args, cssParserMode, ValueRangeAll);
1936         break;
1937     case CSSValueMatrix:
1938     case CSSValueMatrix3d:
1939         if (!consumeNumbers(args, transformValue, (functionId == CSSValueMatrix3d) ? 16 : 6))
1940             return nullptr;
1941         break;
1942     case CSSValueScale3d:
1943         if (!consumeNumbers(args, transformValue, 3))
1944             return nullptr;
1945         break;
1946     case CSSValueRotate3d:
1947         if (!consumeNumbers(args, transformValue, 3) || !consumeCommaIncludingWhitespace(args))
1948             return nullptr;
1949         parsedValue = consumeAngle(args, cssParserMode, UnitlessQuirk::Forbid);
1950         if (!parsedValue)
1951             return nullptr;
1952         break;
1953     case CSSValueTranslate3d:
1954         if (!consumeTranslate3d(args, cssParserMode, transformValue))
1955             return nullptr;
1956         break;
1957     default:
1958         return nullptr;
1959     }
1960     if (parsedValue)
1961         transformValue-&gt;append(*parsedValue);
1962     if (!args.atEnd())
1963         return nullptr;
1964     return transformValue;
1965 }
1966 
1967 static RefPtr&lt;CSSValue&gt; consumeTransform(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1968 {
1969     if (range.peek().id() == CSSValueNone)
1970         return consumeIdent(range);
1971 
1972     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1973     do {
1974         RefPtr&lt;CSSValue&gt; parsedTransformValue = consumeTransformValue(range, cssParserMode);
1975         if (!parsedTransformValue)
1976             return nullptr;
1977         list-&gt;append(parsedTransformValue.releaseNonNull());
1978     } while (!range.atEnd());
1979 
1980     return list;
1981 }
1982 
1983 template &lt;CSSValueID start, CSSValueID end&gt;
1984 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionLonghand(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1985 {
1986     if (range.peek().type() == IdentToken) {
1987         CSSValueID id = range.peek().id();
1988         int percent;
1989         if (id == start)
1990             percent = 0;
1991         else if (id == CSSValueCenter)
1992             percent = 50;
1993         else if (id == end)
1994             percent = 100;
1995         else
1996             return nullptr;
1997         range.consumeIncludingWhitespace();
1998         return CSSPrimitiveValue::create(percent, CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);
1999     }
2000     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll);
2001 }
2002 
2003 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionX(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2004 {
2005     return consumePositionLonghand&lt;CSSValueLeft, CSSValueRight&gt;(range, cssParserMode);
2006 }
2007 
2008 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionY(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2009 {
2010     return consumePositionLonghand&lt;CSSValueTop, CSSValueBottom&gt;(range, cssParserMode);
2011 }
2012 
2013 static RefPtr&lt;CSSValue&gt; consumePaintStroke(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2014 {
2015     if (range.peek().id() == CSSValueNone)
2016         return consumeIdent(range);
2017     RefPtr&lt;CSSPrimitiveValue&gt; url = consumeUrl(range);
2018     if (url) {
2019         RefPtr&lt;CSSValue&gt; parsedValue;
2020         if (range.peek().id() == CSSValueNone)
2021             parsedValue = consumeIdent(range);
2022         else
2023             parsedValue = consumeColor(range, cssParserMode);
2024         if (parsedValue) {
2025             RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
2026             values-&gt;append(url.releaseNonNull());
2027             values-&gt;append(parsedValue.releaseNonNull());
2028             return values;
2029         }
2030         return url;
2031     }
2032     return consumeColor(range, cssParserMode);
2033 }
2034 
2035 static RefPtr&lt;CSSValue&gt; consumeGlyphOrientation(CSSParserTokenRange&amp; range, CSSParserMode mode, CSSPropertyID property)
2036 {
2037     if (range.peek().id() == CSSValueAuto) {
2038         if (property == CSSPropertyGlyphOrientationVertical)
2039             return consumeIdent(range);
2040         return nullptr;
2041     }
2042 
2043     return consumeAngle(range, mode, UnitlessQuirk::Allow);
2044 }
2045 
2046 static RefPtr&lt;CSSValue&gt; consumePaintOrder(CSSParserTokenRange&amp; range)
2047 {
2048     if (range.peek().id() == CSSValueNormal)
2049         return consumeIdent(range);
2050 
2051     Vector&lt;CSSValueID, 3&gt; paintTypeList;
2052     RefPtr&lt;CSSPrimitiveValue&gt; fill;
2053     RefPtr&lt;CSSPrimitiveValue&gt; stroke;
2054     RefPtr&lt;CSSPrimitiveValue&gt; markers;
2055     do {
2056         CSSValueID id = range.peek().id();
2057         if (id == CSSValueFill &amp;&amp; !fill)
2058             fill = consumeIdent(range);
2059         else if (id == CSSValueStroke &amp;&amp; !stroke)
2060             stroke = consumeIdent(range);
2061         else if (id == CSSValueMarkers &amp;&amp; !markers)
2062             markers = consumeIdent(range);
2063         else
2064             return nullptr;
2065         paintTypeList.append(id);
2066     } while (!range.atEnd());
2067 
2068     // After parsing we serialize the paint-order list. Since it is not possible to
2069     // pop a last list items from CSSValueList without bigger cost, we create the
2070     // list after parsing.
2071     CSSValueID firstPaintOrderType = paintTypeList.at(0);
2072     RefPtr&lt;CSSValueList&gt; paintOrderList = CSSValueList::createSpaceSeparated();
2073     switch (firstPaintOrderType) {
2074     case CSSValueFill:
2075     case CSSValueStroke:
2076         paintOrderList-&gt;append(firstPaintOrderType == CSSValueFill ? fill.releaseNonNull() : stroke.releaseNonNull());
2077         if (paintTypeList.size() &gt; 1) {
2078             if (paintTypeList.at(1) == CSSValueMarkers)
2079                 paintOrderList-&gt;append(markers.releaseNonNull());
2080         }
2081         break;
2082     case CSSValueMarkers:
2083         paintOrderList-&gt;append(markers.releaseNonNull());
2084         if (paintTypeList.size() &gt; 1) {
2085             if (paintTypeList.at(1) == CSSValueStroke)
2086                 paintOrderList-&gt;append(stroke.releaseNonNull());
2087         }
2088         break;
2089     default:
2090         ASSERT_NOT_REACHED();
2091     }
2092 
2093     return paintOrderList;
2094 }
2095 
2096 static RefPtr&lt;CSSValue&gt; consumeNoneOrURI(CSSParserTokenRange&amp; range)
2097 {
2098     if (range.peek().id() == CSSValueNone)
2099         return consumeIdent(range);
2100     return consumeUrl(range);
2101 }
2102 
2103 static RefPtr&lt;CSSValue&gt; consumeFlexBasis(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2104 {
2105     // FIXME: Support intrinsic dimensions too.
2106     if (range.peek().id() == CSSValueAuto)
2107         return consumeIdent(range);
2108     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2109 }
2110 
2111 static RefPtr&lt;CSSValue&gt; consumeKerning(CSSParserTokenRange&amp; range, CSSParserMode mode)
2112 {
2113     RefPtr&lt;CSSValue&gt; result = consumeIdent&lt;CSSValueAuto, CSSValueNormal&gt;(range);
2114     if (result)
2115         return result;
2116     return consumeLength(range, mode, ValueRangeAll, UnitlessQuirk::Allow);
2117 }
2118 
2119 static RefPtr&lt;CSSValue&gt; consumeStrokeDasharray(CSSParserTokenRange&amp; range)
2120 {
2121     CSSValueID id = range.peek().id();
2122     if (id == CSSValueNone)
2123         return consumeIdent(range);
2124 
2125     RefPtr&lt;CSSValueList&gt; dashes = CSSValueList::createCommaSeparated();
2126     do {
2127         RefPtr&lt;CSSPrimitiveValue&gt; dash = consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeNonNegative);
2128         if (!dash || (consumeCommaIncludingWhitespace(range) &amp;&amp; range.atEnd()))
2129             return nullptr;
2130         dashes-&gt;append(dash.releaseNonNull());
2131     } while (!range.atEnd());
2132     return dashes;
2133 }
2134 
2135 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBaselineShift(CSSParserTokenRange&amp; range)
2136 {
2137     CSSValueID id = range.peek().id();
2138     if (id == CSSValueBaseline || id == CSSValueSub || id == CSSValueSuper)
2139         return consumeIdent(range);
2140     return consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeAll);
2141 }
2142 
2143 static RefPtr&lt;CSSPrimitiveValue&gt; consumeRxOrRy(CSSParserTokenRange&amp; range)
2144 {
2145     // FIXME-NEWPARSER: We don&#39;t support auto values when mapping, so for now turn this
2146     // off until we can figure out if we&#39;re even supposed to support it.
2147     // if (range.peek().id() == CSSValueAuto)
2148     //     return consumeIdent(range);
2149     return consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeAll, UnitlessQuirk::Forbid);
2150 }
2151 
2152 static RefPtr&lt;CSSValue&gt; consumeCursor(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, bool inQuirksMode)
2153 {
2154     RefPtr&lt;CSSValueList&gt; list;
2155     while (RefPtr&lt;CSSValue&gt; image = consumeImage(range, context, ConsumeGeneratedImage::Forbid)) {
2156         double num;
2157         IntPoint hotSpot(-1, -1);
2158         bool hotSpotSpecified = false;
2159         if (consumeNumberRaw(range, num)) {
2160             hotSpot.setX(int(num));
2161             if (!consumeNumberRaw(range, num))
2162                 return nullptr;
2163             hotSpot.setY(int(num));
2164             hotSpotSpecified = true;
2165         }
2166 
2167         if (!list)
2168             list = CSSValueList::createCommaSeparated();
2169 
2170         list-&gt;append(CSSCursorImageValue::create(image.releaseNonNull(), hotSpotSpecified, hotSpot, context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No));
2171         if (!consumeCommaIncludingWhitespace(range))
2172             return nullptr;
2173     }
2174 
2175     CSSValueID id = range.peek().id();
2176     RefPtr&lt;CSSValue&gt; cursorType;
2177     if (id == CSSValueHand) {
2178         if (!inQuirksMode) // Non-standard behavior
2179             return nullptr;
2180         cursorType = CSSValuePool::singleton().createIdentifierValue(CSSValuePointer);
2181         range.consumeIncludingWhitespace();
2182     } else if ((id &gt;= CSSValueAuto &amp;&amp; id &lt;= CSSValueWebkitZoomOut) || id == CSSValueCopy || id == CSSValueNone) {
2183         cursorType = consumeIdent(range);
2184     } else {
2185         return nullptr;
2186     }
2187 
2188     if (!list)
2189         return cursorType;
2190     list-&gt;append(cursorType.releaseNonNull());
2191     return list;
2192 }
2193 
2194 static RefPtr&lt;CSSValue&gt; consumeAttr(CSSParserTokenRange args, CSSParserContext context)
2195 {
2196     if (args.peek().type() != IdentToken)
2197         return nullptr;
2198 
2199     CSSParserToken token = args.consumeIncludingWhitespace();
2200     auto attrName = token.value().toAtomString();
2201     if (context.isHTMLDocument)
2202         attrName = attrName.convertToASCIILowercase();
2203 
2204     if (!args.atEnd())
2205         return nullptr;
2206 
2207     // FIXME-NEWPARSER: We want to use a CSSCustomIdentValue here eventually for the attrName.
2208     // FIXME-NEWPARSER: We want to use a CSSFunctionValue rather than relying on a custom
2209     // attr() primitive value.
2210     return CSSValuePool::singleton().createValue(attrName, CSSPrimitiveValue::CSS_ATTR);
2211 }
2212 
2213 static RefPtr&lt;CSSValue&gt; consumeCounterContent(CSSParserTokenRange args, bool counters)
2214 {
2215     RefPtr&lt;CSSPrimitiveValue&gt; identifier = consumeCustomIdent(args);
2216     if (!identifier)
2217         return nullptr;
2218 
2219     RefPtr&lt;CSSPrimitiveValue&gt; separator;
2220     if (!counters)
2221         separator = CSSPrimitiveValue::create(String(), CSSPrimitiveValue::UnitType::CSS_STRING);
2222     else {
2223         if (!consumeCommaIncludingWhitespace(args) || args.peek().type() != StringToken)
2224             return nullptr;
2225         separator = CSSPrimitiveValue::create(args.consumeIncludingWhitespace().value().toString(), CSSPrimitiveValue::UnitType::CSS_STRING);
2226     }
2227 
2228     RefPtr&lt;CSSPrimitiveValue&gt; listStyle;
2229     if (consumeCommaIncludingWhitespace(args)) {
2230         CSSValueID id = args.peek().id();
2231         if ((id != CSSValueNone &amp;&amp; (id &lt; CSSValueDisc || id &gt; CSSValueKatakanaIroha)))
2232             return nullptr;
2233         listStyle = consumeIdent(args);
2234     } else
2235         listStyle = CSSValuePool::singleton().createIdentifierValue(CSSValueDecimal);
2236 
2237     if (!args.atEnd())
2238         return nullptr;
2239 
2240     // FIXME-NEWPARSER: Should just have a CSSCounterValue.
2241     return CSSValuePool::singleton().createValue(Counter::create(identifier.releaseNonNull(), listStyle.releaseNonNull(), separator.releaseNonNull()));
2242 }
2243 
2244 static RefPtr&lt;CSSValue&gt; consumeContent(CSSParserTokenRange&amp; range, CSSParserContext context)
2245 {
2246     if (identMatches&lt;CSSValueNone, CSSValueNormal&gt;(range.peek().id()))
2247         return consumeIdent(range);
2248 
2249     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
2250 
2251     do {
2252         RefPtr&lt;CSSValue&gt; parsedValue = consumeImage(range, context);
2253         if (!parsedValue)
2254             parsedValue = consumeIdent&lt;CSSValueOpenQuote, CSSValueCloseQuote, CSSValueNoOpenQuote, CSSValueNoCloseQuote&gt;(range);
2255         if (!parsedValue)
2256             parsedValue = consumeString(range);
2257         if (!parsedValue) {
2258             if (range.peek().functionId() == CSSValueAttr)
2259                 parsedValue = consumeAttr(consumeFunction(range), context);
2260             else if (range.peek().functionId() == CSSValueCounter)
2261                 parsedValue = consumeCounterContent(consumeFunction(range), false);
2262             else if (range.peek().functionId() == CSSValueCounters)
2263                 parsedValue = consumeCounterContent(consumeFunction(range), true);
2264             if (!parsedValue)
2265                 return nullptr;
2266         }
2267         values-&gt;append(parsedValue.releaseNonNull());
2268     } while (!range.atEnd());
2269 
2270     return values;
2271 }
2272 
2273 static RefPtr&lt;CSSPrimitiveValue&gt; consumePerspective(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2274 {
2275     if (range.peek().id() == CSSValueNone)
2276         return consumeIdent(range);
2277     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeLength(range, cssParserMode, ValueRangeAll);
2278     if (!parsedValue) {
2279         // FIXME: Make this quirk only apply to the webkit prefixed version of the property.
2280         double perspective;
2281         if (!consumeNumberRaw(range, perspective))
2282             return nullptr;
2283         parsedValue = CSSPrimitiveValue::create(perspective, CSSPrimitiveValue::UnitType::CSS_PX);
2284     }
2285     if (parsedValue &amp;&amp; (parsedValue-&gt;isCalculated() || parsedValue-&gt;doubleValue() &gt; 0))
2286         return parsedValue;
2287     return nullptr;
2288 }
2289 
2290 #if ENABLE(CSS_SCROLL_SNAP)
2291 
2292 static RefPtr&lt;CSSValueList&gt; consumeScrollSnapAlign(CSSParserTokenRange&amp; range)
2293 {
2294     RefPtr&lt;CSSValueList&gt; alignmentValue = CSSValueList::createSpaceSeparated();
2295     if (RefPtr&lt;CSSPrimitiveValue&gt; firstValue = consumeIdent&lt;CSSValueNone, CSSValueStart, CSSValueCenter, CSSValueEnd&gt;(range)) {
2296         alignmentValue-&gt;append(firstValue.releaseNonNull());
2297         if (auto secondValue = consumeIdent&lt;CSSValueNone, CSSValueStart, CSSValueCenter, CSSValueEnd&gt;(range))
2298             alignmentValue-&gt;append(secondValue.releaseNonNull());
2299     }
2300     return alignmentValue-&gt;length() ? alignmentValue : nullptr;
2301 }
2302 
2303 static RefPtr&lt;CSSValueList&gt; consumeScrollSnapType(CSSParserTokenRange&amp; range)
2304 {
2305     RefPtr&lt;CSSValueList&gt; typeValue = CSSValueList::createSpaceSeparated();
2306     RefPtr&lt;CSSPrimitiveValue&gt; secondValue;
2307 
2308     auto firstValue = consumeIdent&lt;CSSValueX, CSSValueY, CSSValueBlock, CSSValueInline, CSSValueBoth&gt;(range);
2309     if (firstValue)
2310         secondValue = consumeIdent&lt;CSSValueProximity, CSSValueMandatory&gt;(range);
2311     else
2312         firstValue = consumeIdent&lt;CSSValueNone, CSSValueProximity, CSSValueMandatory&gt;(range);
2313 
2314     if (!firstValue)
2315         return nullptr;
2316 
2317     typeValue-&gt;append(firstValue.releaseNonNull());
2318     if (secondValue)
2319         typeValue-&gt;append(secondValue.releaseNonNull());
2320 
2321     return typeValue;
2322 }
2323 
2324 #endif
2325 
2326 static RefPtr&lt;CSSValue&gt; consumeBorderRadiusCorner(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2327 {
2328     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue1 = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2329     if (!parsedValue1)
2330         return nullptr;
2331     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue2 = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2332     if (!parsedValue2)
2333         parsedValue2 = parsedValue1;
2334     return createPrimitiveValuePair(parsedValue1.releaseNonNull(), parsedValue2.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
2335 }
2336 
2337 static RefPtr&lt;CSSValue&gt; consumeTextUnderlineOffset(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2338 {
2339     if (auto value = consumeIdent&lt;CSSValueAuto&gt;(range))
2340         return value;
2341     return consumeLength(range, cssParserMode, ValueRangeAll);
2342 }
2343 
2344 static RefPtr&lt;CSSValue&gt; consumeTextDecorationThickness(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2345 {
2346     if (auto value = consumeIdent&lt;CSSValueAuto, CSSValueFromFont&gt;(range))
2347         return value;
2348     return consumeLength(range, cssParserMode, ValueRangeAll);
2349 }
2350 
2351 static RefPtr&lt;CSSPrimitiveValue&gt; consumeVerticalAlign(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2352 {
2353     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeIdentRange(range, CSSValueBaseline, CSSValueWebkitBaselineMiddle);
2354     if (!parsedValue)
2355         parsedValue = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
2356     return parsedValue;
2357 }
2358 
2359 static RefPtr&lt;CSSPrimitiveValue&gt; consumeShapeRadius(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode)
2360 {
2361     if (identMatches&lt;CSSValueClosestSide, CSSValueFarthestSide&gt;(args.peek().id()))
2362         return consumeIdent(args);
2363     return consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative);
2364 }
2365 
2366 static RefPtr&lt;CSSBasicShapeCircle&gt; consumeBasicShapeCircle(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2367 {
2368     // spec: https://drafts.csswg.org/css-shapes/#supported-basic-shapes
2369     // circle( [&lt;shape-radius&gt;]? [at &lt;position&gt;]? )
2370     RefPtr&lt;CSSBasicShapeCircle&gt; shape = CSSBasicShapeCircle::create();
2371     if (RefPtr&lt;CSSPrimitiveValue&gt; radius = consumeShapeRadius(args, context.mode))
2372         shape-&gt;setRadius(radius.releaseNonNull());
2373     if (consumeIdent&lt;CSSValueAt&gt;(args)) {
2374         RefPtr&lt;CSSPrimitiveValue&gt; centerX;
2375         RefPtr&lt;CSSPrimitiveValue&gt; centerY;
2376         if (!consumePosition(args, context.mode, UnitlessQuirk::Forbid, centerX, centerY))
2377             return nullptr;
2378         shape-&gt;setCenterX(centerX.releaseNonNull());
2379         shape-&gt;setCenterY(centerY.releaseNonNull());
2380     }
2381     return shape;
2382 }
2383 
2384 static RefPtr&lt;CSSBasicShapeEllipse&gt; consumeBasicShapeEllipse(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2385 {
2386     // spec: https://drafts.csswg.org/css-shapes/#supported-basic-shapes
2387     // ellipse( [&lt;shape-radius&gt;{2}]? [at &lt;position&gt;]? )
2388     RefPtr&lt;CSSBasicShapeEllipse&gt; shape = CSSBasicShapeEllipse::create();
2389     if (RefPtr&lt;CSSPrimitiveValue&gt; radiusX = consumeShapeRadius(args, context.mode)) {
2390         shape-&gt;setRadiusX(radiusX.releaseNonNull());
2391         if (RefPtr&lt;CSSPrimitiveValue&gt; radiusY = consumeShapeRadius(args, context.mode))
2392             shape-&gt;setRadiusY(radiusY.releaseNonNull());
2393     }
2394     if (consumeIdent&lt;CSSValueAt&gt;(args)) {
2395         RefPtr&lt;CSSPrimitiveValue&gt; centerX;
2396         RefPtr&lt;CSSPrimitiveValue&gt; centerY;
2397         if (!consumePosition(args, context.mode, UnitlessQuirk::Forbid, centerX, centerY))
2398             return nullptr;
2399         shape-&gt;setCenterX(centerX.releaseNonNull());
2400         shape-&gt;setCenterY(centerY.releaseNonNull());
2401     }
2402     return shape;
2403 }
2404 
2405 static RefPtr&lt;CSSBasicShapePolygon&gt; consumeBasicShapePolygon(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2406 {
2407     RefPtr&lt;CSSBasicShapePolygon&gt; shape = CSSBasicShapePolygon::create();
2408     if (identMatches&lt;CSSValueEvenodd, CSSValueNonzero&gt;(args.peek().id())) {
2409         shape-&gt;setWindRule(args.consumeIncludingWhitespace().id() == CSSValueEvenodd ? WindRule::EvenOdd : WindRule::NonZero);
2410         if (!consumeCommaIncludingWhitespace(args))
2411             return nullptr;
2412     }
2413 
2414     do {
2415         RefPtr&lt;CSSPrimitiveValue&gt; xLength = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2416         if (!xLength)
2417             return nullptr;
2418         RefPtr&lt;CSSPrimitiveValue&gt; yLength = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2419         if (!yLength)
2420             return nullptr;
2421         shape-&gt;appendPoint(xLength.releaseNonNull(), yLength.releaseNonNull());
2422     } while (consumeCommaIncludingWhitespace(args));
2423     return shape;
2424 }
2425 
2426 static RefPtr&lt;CSSBasicShapePath&gt; consumeBasicShapePath(CSSParserTokenRange&amp; args)
2427 {
2428     WindRule windRule = WindRule::NonZero;
2429     if (identMatches&lt;CSSValueEvenodd, CSSValueNonzero&gt;(args.peek().id())) {
2430         windRule = args.consumeIncludingWhitespace().id() == CSSValueEvenodd ? WindRule::EvenOdd : WindRule::NonZero;
2431         if (!consumeCommaIncludingWhitespace(args))
2432             return nullptr;
2433     }
2434 
2435     if (args.peek().type() != StringToken)
2436         return nullptr;
2437 
2438     auto byteStream = makeUnique&lt;SVGPathByteStream&gt;();
2439     if (!buildSVGPathByteStreamFromString(args.consumeIncludingWhitespace().value().toString(), *byteStream, UnalteredParsing))
2440         return nullptr;
2441 
2442     auto shape = CSSBasicShapePath::create(WTFMove(byteStream));
2443     shape-&gt;setWindRule(windRule);
2444 
2445     return shape;
2446 }
2447 
2448 static void complete4Sides(RefPtr&lt;CSSPrimitiveValue&gt; side[4])
2449 {
2450     if (side[3])
2451         return;
2452     if (!side[2]) {
2453         if (!side[1])
2454             side[1] = side[0];
2455         side[2] = side[0];
2456     }
2457     side[3] = side[1];
2458 }
2459 
2460 static bool consumeRadii(RefPtr&lt;CSSPrimitiveValue&gt; horizontalRadii[4], RefPtr&lt;CSSPrimitiveValue&gt; verticalRadii[4], CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, bool useLegacyParsing)
2461 {
2462     unsigned i = 0;
2463     for (; i &lt; 4 &amp;&amp; !range.atEnd() &amp;&amp; range.peek().type() != DelimiterToken; ++i) {
2464         horizontalRadii[i] = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2465         if (!horizontalRadii[i])
2466             return false;
2467     }
2468     if (!horizontalRadii[0])
2469         return false;
2470     if (range.atEnd()) {
2471         // Legacy syntax: -webkit-border-radius: l1 l2; is equivalent to border-radius: l1 / l2;
2472         if (useLegacyParsing &amp;&amp; i == 2) {
2473             verticalRadii[0] = horizontalRadii[1];
2474             horizontalRadii[1] = nullptr;
2475         } else {
2476             complete4Sides(horizontalRadii);
2477             for (unsigned i = 0; i &lt; 4; ++i)
2478                 verticalRadii[i] = horizontalRadii[i];
2479             return true;
2480         }
2481     } else {
2482         if (!consumeSlashIncludingWhitespace(range))
2483             return false;
2484         for (i = 0; i &lt; 4 &amp;&amp; !range.atEnd(); ++i) {
2485             verticalRadii[i] = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2486             if (!verticalRadii[i])
2487                 return false;
2488         }
2489         if (!verticalRadii[0] || !range.atEnd())
2490             return false;
2491     }
2492     complete4Sides(horizontalRadii);
2493     complete4Sides(verticalRadii);
2494     return true;
2495 }
2496 
2497 static RefPtr&lt;CSSBasicShapeInset&gt; consumeBasicShapeInset(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2498 {
2499     RefPtr&lt;CSSBasicShapeInset&gt; shape = CSSBasicShapeInset::create();
2500     RefPtr&lt;CSSPrimitiveValue&gt; top = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2501     if (!top)
2502         return nullptr;
2503     RefPtr&lt;CSSPrimitiveValue&gt; right = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2504     RefPtr&lt;CSSPrimitiveValue&gt; bottom;
2505     RefPtr&lt;CSSPrimitiveValue&gt; left;
2506     if (right) {
2507         bottom = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2508         if (bottom)
2509             left = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2510     }
2511     if (left)
2512         shape-&gt;updateShapeSize4Values(top.releaseNonNull(), right.releaseNonNull(), bottom.releaseNonNull(), left.releaseNonNull());
2513     else if (bottom)
2514         shape-&gt;updateShapeSize3Values(top.releaseNonNull(), right.releaseNonNull(), bottom.releaseNonNull());
2515     else if (right)
2516         shape-&gt;updateShapeSize2Values(top.releaseNonNull(), right.releaseNonNull());
2517     else
2518         shape-&gt;updateShapeSize1Value(top.releaseNonNull());
2519 
2520     if (consumeIdent&lt;CSSValueRound&gt;(args)) {
2521         RefPtr&lt;CSSPrimitiveValue&gt; horizontalRadii[4] = { 0 };
2522         RefPtr&lt;CSSPrimitiveValue&gt; verticalRadii[4] = { 0 };
2523         if (!consumeRadii(horizontalRadii, verticalRadii, args, context.mode, false))
2524             return nullptr;
2525         shape-&gt;setTopLeftRadius(createPrimitiveValuePair(horizontalRadii[0].releaseNonNull(), verticalRadii[0].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2526         shape-&gt;setTopRightRadius(createPrimitiveValuePair(horizontalRadii[1].releaseNonNull(), verticalRadii[1].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2527         shape-&gt;setBottomRightRadius(createPrimitiveValuePair(horizontalRadii[2].releaseNonNull(), verticalRadii[2].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2528         shape-&gt;setBottomLeftRadius(createPrimitiveValuePair(horizontalRadii[3].releaseNonNull(), verticalRadii[3].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2529     }
2530     return shape;
2531 }
2532 
2533 static RefPtr&lt;CSSValue&gt; consumeBasicShape(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2534 {
2535     RefPtr&lt;CSSValue&gt; result;
2536     if (range.peek().type() != FunctionToken)
2537         return nullptr;
2538     CSSValueID id = range.peek().functionId();
2539     CSSParserTokenRange rangeCopy = range;
2540     CSSParserTokenRange args = consumeFunction(rangeCopy);
2541 
2542     // FIXME-NEWPARSER: CSSBasicShape should be a CSSValue, and shapes should not be primitive values.
2543     RefPtr&lt;CSSBasicShape&gt; shape;
2544     if (id == CSSValueCircle)
2545         shape = consumeBasicShapeCircle(args, context);
2546     else if (id == CSSValueEllipse)
2547         shape = consumeBasicShapeEllipse(args, context);
2548     else if (id == CSSValuePolygon)
2549         shape = consumeBasicShapePolygon(args, context);
2550     else if (id == CSSValueInset)
2551         shape = consumeBasicShapeInset(args, context);
2552     else if (id == CSSValuePath)
2553         shape = consumeBasicShapePath(args);
2554     if (!shape)
2555         return nullptr;
2556     range = rangeCopy;
2557 
2558     if (!args.atEnd())
2559         return nullptr;
2560 
2561     return CSSValuePool::singleton().createValue(shape.releaseNonNull());
2562 }
2563 
2564 static RefPtr&lt;CSSValue&gt; consumeBasicShapeOrBox(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2565 {
2566     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
2567     bool shapeFound = false;
2568     bool boxFound = false;
2569     while (!range.atEnd() &amp;&amp; !(shapeFound &amp;&amp; boxFound)) {
2570         RefPtr&lt;CSSValue&gt; componentValue;
2571         if (range.peek().type() == FunctionToken &amp;&amp; !shapeFound) {
2572             componentValue = consumeBasicShape(range, context);
2573             shapeFound = true;
2574         } else if (range.peek().type() == IdentToken &amp;&amp; !boxFound) {
2575             componentValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox, CSSValueFillBox, CSSValueStrokeBox, CSSValueViewBox&gt;(range);
2576             boxFound = true;
2577         }
2578         if (!componentValue)
2579             return nullptr;
2580         list-&gt;append(componentValue.releaseNonNull());
2581     }
2582 
2583     if (!range.atEnd() || !list-&gt;length())
2584         return nullptr;
2585 
2586     return list;
2587 }
2588 
2589 static RefPtr&lt;CSSValue&gt; consumeWebkitClipPath(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2590 {
2591     if (range.peek().id() == CSSValueNone)
2592         return consumeIdent(range);
2593     if (RefPtr&lt;CSSPrimitiveValue&gt; url = consumeUrl(range))
2594         return url;
2595     return consumeBasicShapeOrBox(range, context);
2596 }
2597 
2598 static RefPtr&lt;CSSValue&gt; consumeShapeOutside(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2599 {
2600     if (RefPtr&lt;CSSValue&gt; imageValue = consumeImageOrNone(range, context))
2601         return imageValue;
2602     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
2603     if (RefPtr&lt;CSSValue&gt; boxValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox&gt;(range))
2604         list-&gt;append(boxValue.releaseNonNull());
2605     if (RefPtr&lt;CSSValue&gt; shapeValue = consumeBasicShape(range, context)) {
2606         list-&gt;append(shapeValue.releaseNonNull());
2607         if (list-&gt;length() &lt; 2) {
2608             if (RefPtr&lt;CSSValue&gt; boxValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox&gt;(range))
2609                 list-&gt;append(boxValue.releaseNonNull());
2610         }
2611     }
2612     if (!list-&gt;length())
2613         return nullptr;
2614     return list;
2615 }
2616 
2617 static bool isAuto(CSSValueID id)
2618 {
2619     return identMatches&lt;CSSValueAuto&gt;(id);
2620 }
2621 
2622 static bool isNormalOrStretch(CSSValueID id)
2623 {
2624     return identMatches&lt;CSSValueNormal, CSSValueStretch&gt;(id);
2625 }
2626 
2627 static bool isLeftOrRightKeyword(CSSValueID id)
2628 {
2629     return identMatches&lt;CSSValueLeft, CSSValueRight&gt;(id);
2630 }
2631 
2632 static bool isContentDistributionKeyword(CSSValueID id)
2633 {
2634     return identMatches&lt;CSSValueSpaceBetween, CSSValueSpaceAround, CSSValueSpaceEvenly, CSSValueStretch&gt;(id);
2635 }
2636 
2637 static bool isContentPositionKeyword(CSSValueID id)
2638 {
2639     return identMatches&lt;CSSValueStart, CSSValueEnd, CSSValueCenter, CSSValueFlexStart, CSSValueFlexEnd&gt;(id);
2640 }
2641 
2642 static bool isContentPositionOrLeftOrRightKeyword(CSSValueID id)
2643 {
2644     return isContentPositionKeyword(id) || isLeftOrRightKeyword(id);
2645 }
2646 
2647 static bool isOverflowKeyword(CSSValueID id)
2648 {
2649     return CSSPropertyParserHelpers::identMatches&lt;CSSValueUnsafe, CSSValueSafe&gt;(id);
2650 }
2651 
2652 static bool isBaselineKeyword(CSSValueID id)
2653 {
2654     return identMatches&lt;CSSValueFirst, CSSValueLast, CSSValueBaseline&gt;(id);
2655 }
2656 
2657 static RefPtr&lt;CSSPrimitiveValue&gt; consumeOverflowPositionKeyword(CSSParserTokenRange&amp; range)
2658 {
2659     return isOverflowKeyword(range.peek().id()) ? consumeIdent(range) : nullptr;
2660 }
2661 
2662 static CSSValueID getBaselineKeyword(RefPtr&lt;CSSValue&gt; value)
2663 {
2664     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
2665     if (primitiveValue.pairValue()) {
2666         ASSERT(primitiveValue.pairValue()-&gt;first()-&gt;valueID() == CSSValueLast);
2667         ASSERT(primitiveValue.pairValue()-&gt;second()-&gt;valueID() == CSSValueBaseline);
2668         return CSSValueLastBaseline;
2669     }
2670     ASSERT(primitiveValue.valueID() == CSSValueBaseline);
2671     return CSSValueBaseline;
2672 }
2673 
2674 static RefPtr&lt;CSSValue&gt; consumeBaselineKeyword(CSSParserTokenRange&amp; range)
2675 {
2676     RefPtr&lt;CSSPrimitiveValue&gt; preference = consumeIdent&lt;CSSValueFirst, CSSValueLast&gt;(range);
2677     RefPtr&lt;CSSPrimitiveValue&gt; baseline = consumeIdent&lt;CSSValueBaseline&gt;(range);
2678     if (!baseline)
2679         return nullptr;
2680     if (preference &amp;&amp; preference-&gt;valueID() == CSSValueLast)
2681         return createPrimitiveValuePair(preference.releaseNonNull(), baseline.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
2682     return baseline;
2683 }
2684 
2685 using IsPositionKeyword = bool (*)(CSSValueID);
2686 
2687 static RefPtr&lt;CSSValue&gt; consumeContentDistributionOverflowPosition(CSSParserTokenRange&amp; range, IsPositionKeyword isPositionKeyword)
2688 {
2689     ASSERT(isPositionKeyword);
2690     CSSValueID id = range.peek().id();
2691     if (identMatches&lt;CSSValueNormal&gt;(id))
2692         return CSSContentDistributionValue::create(CSSValueInvalid, range.consumeIncludingWhitespace().id(), CSSValueInvalid);
2693 
2694     if (isBaselineKeyword(id)) {
2695         RefPtr&lt;CSSValue&gt; baseline = consumeBaselineKeyword(range);
2696         if (!baseline)
2697             return nullptr;
2698         return CSSContentDistributionValue::create(CSSValueInvalid, getBaselineKeyword(baseline), CSSValueInvalid);
2699     }
2700 
2701     if (isContentDistributionKeyword(id))
2702         return CSSContentDistributionValue::create(range.consumeIncludingWhitespace().id(), CSSValueInvalid, CSSValueInvalid);
2703 
2704     CSSValueID overflow = isOverflowKeyword(id) ? range.consumeIncludingWhitespace().id() : CSSValueInvalid;
2705     if (isPositionKeyword(range.peek().id()))
2706         return CSSContentDistributionValue::create(CSSValueInvalid, range.consumeIncludingWhitespace().id(), overflow);
2707 
2708     return nullptr;
2709 }
2710 
2711 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBorderImageRepeatKeyword(CSSParserTokenRange&amp; range)
2712 {
2713     return consumeIdent&lt;CSSValueStretch, CSSValueRepeat, CSSValueSpace, CSSValueRound&gt;(range);
2714 }
2715 
2716 static RefPtr&lt;CSSValue&gt; consumeBorderImageRepeat(CSSParserTokenRange&amp; range)
2717 {
2718     RefPtr&lt;CSSPrimitiveValue&gt; horizontal = consumeBorderImageRepeatKeyword(range);
2719     if (!horizontal)
2720         return nullptr;
2721     RefPtr&lt;CSSPrimitiveValue&gt; vertical = consumeBorderImageRepeatKeyword(range);
2722     if (!vertical)
2723         vertical = horizontal;
2724     return createPrimitiveValuePair(horizontal.releaseNonNull(), vertical.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
2725 }
2726 
2727 static RefPtr&lt;CSSValue&gt; consumeBorderImageSlice(CSSPropertyID property, CSSParserTokenRange&amp; range)
2728 {
2729     bool fill = consumeIdent&lt;CSSValueFill&gt;(range);
2730     RefPtr&lt;CSSPrimitiveValue&gt; slices[4] = { 0 };
2731 
2732     for (size_t index = 0; index &lt; 4; ++index) {
2733         RefPtr&lt;CSSPrimitiveValue&gt; value = consumePercent(range, ValueRangeNonNegative);
2734         if (!value)
2735             value = consumeNumber(range, ValueRangeNonNegative);
2736         if (!value)
2737             break;
2738         slices[index] = value;
2739     }
2740     if (!slices[0])
2741         return nullptr;
2742     if (consumeIdent&lt;CSSValueFill&gt;(range)) {
2743         if (fill)
2744             return nullptr;
2745         fill = true;
2746     }
2747     complete4Sides(slices);
2748     // FIXME: For backwards compatibility, -webkit-border-image, -webkit-mask-box-image and -webkit-box-reflect have to do a fill by default.
2749     // FIXME: What do we do with -webkit-box-reflect and -webkit-mask-box-image? Probably just have to leave them filling...
2750     if (property == CSSPropertyWebkitBorderImage || property == CSSPropertyWebkitMaskBoxImage || property == CSSPropertyWebkitBoxReflect)
2751         fill = true;
2752 
2753     // Now build a rect value to hold all four of our primitive values.
2754     // FIXME-NEWPARSER: Should just have a CSSQuadValue.
2755     auto quad = Quad::create();
2756     quad-&gt;setTop(slices[0].releaseNonNull());
2757     quad-&gt;setRight(slices[1].releaseNonNull());
2758     quad-&gt;setBottom(slices[2].releaseNonNull());
2759     quad-&gt;setLeft(slices[3].releaseNonNull());
2760 
2761     // Make our new border image value now.
2762     return CSSBorderImageSliceValue::create(CSSValuePool::singleton().createValue(WTFMove(quad)), fill);
2763 }
2764 
2765 static RefPtr&lt;CSSValue&gt; consumeBorderImageOutset(CSSParserTokenRange&amp; range)
2766 {
2767     RefPtr&lt;CSSPrimitiveValue&gt; outsets[4] = { 0 };
2768 
2769     RefPtr&lt;CSSPrimitiveValue&gt; value;
2770     for (size_t index = 0; index &lt; 4; ++index) {
2771         value = consumeNumber(range, ValueRangeNonNegative);
2772         if (!value)
2773             value = consumeLength(range, HTMLStandardMode, ValueRangeNonNegative);
2774         if (!value)
2775             break;
2776         outsets[index] = value;
2777     }
2778     if (!outsets[0])
2779         return nullptr;
2780     complete4Sides(outsets);
2781 
2782     // FIXME-NEWPARSER: Should just have a CSSQuadValue.
2783     auto quad = Quad::create();
2784     quad-&gt;setTop(outsets[0].releaseNonNull());
2785     quad-&gt;setRight(outsets[1].releaseNonNull());
2786     quad-&gt;setBottom(outsets[2].releaseNonNull());
2787     quad-&gt;setLeft(outsets[3].releaseNonNull());
2788 
2789     return CSSValuePool::singleton().createValue(WTFMove(quad));
2790 }
2791 
2792 static RefPtr&lt;CSSValue&gt; consumeBorderImageWidth(CSSParserTokenRange&amp; range)
2793 {
2794     RefPtr&lt;CSSPrimitiveValue&gt; widths[4];
2795 
2796     RefPtr&lt;CSSPrimitiveValue&gt; value;
2797     for (size_t index = 0; index &lt; 4; ++index) {
2798         value = consumeNumber(range, ValueRangeNonNegative);
2799         if (!value)
2800             value = consumeLengthOrPercent(range, HTMLStandardMode, ValueRangeNonNegative, UnitlessQuirk::Forbid);
2801         if (!value)
2802             value = consumeIdent&lt;CSSValueAuto&gt;(range);
2803         if (!value)
2804             break;
2805         widths[index] = value;
2806     }
2807     if (!widths[0])
2808         return nullptr;
2809     complete4Sides(widths);
2810 
2811     // FIXME-NEWPARSER: Should just have a CSSQuadValue.
2812     auto quad = Quad::create();
2813     quad-&gt;setTop(widths[0].releaseNonNull());
2814     quad-&gt;setRight(widths[1].releaseNonNull());
2815     quad-&gt;setBottom(widths[2].releaseNonNull());
2816     quad-&gt;setLeft(widths[3].releaseNonNull());
2817 
2818     return CSSValuePool::singleton().createValue(WTFMove(quad));
2819 }
2820 
2821 static bool consumeBorderImageComponents(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, RefPtr&lt;CSSValue&gt;&amp; source,
2822     RefPtr&lt;CSSValue&gt;&amp; slice, RefPtr&lt;CSSValue&gt;&amp; width, RefPtr&lt;CSSValue&gt;&amp; outset, RefPtr&lt;CSSValue&gt;&amp; repeat)
2823 {
2824     do {
2825         if (!source) {
2826             source = consumeImageOrNone(range, context);
2827             if (source)
2828                 continue;
2829         }
2830         if (!repeat) {
2831             repeat = consumeBorderImageRepeat(range);
2832             if (repeat)
2833                 continue;
2834         }
2835         if (!slice) {
2836             slice = consumeBorderImageSlice(property, range);
2837             if (slice) {
2838                 ASSERT(!width &amp;&amp; !outset);
2839                 if (consumeSlashIncludingWhitespace(range)) {
2840                     width = consumeBorderImageWidth(range);
2841                     if (consumeSlashIncludingWhitespace(range)) {
2842                         outset = consumeBorderImageOutset(range);
2843                         if (!outset)
2844                             return false;
2845                     } else if (!width) {
2846                         return false;
2847                     }
2848                 }
2849             } else {
2850                 return false;
2851             }
2852         } else {
2853             return false;
2854         }
2855     } while (!range.atEnd());
2856     return true;
2857 }
2858 
2859 static RefPtr&lt;CSSValue&gt; consumeWebkitBorderImage(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2860 {
2861     RefPtr&lt;CSSValue&gt; source;
2862     RefPtr&lt;CSSValue&gt; slice;
2863     RefPtr&lt;CSSValue&gt; width;
2864     RefPtr&lt;CSSValue&gt; outset;
2865     RefPtr&lt;CSSValue&gt; repeat;
2866     if (consumeBorderImageComponents(property, range, context, source, slice, width, outset, repeat))
2867         return createBorderImageValue(WTFMove(source), WTFMove(slice), WTFMove(width), WTFMove(outset), WTFMove(repeat));
2868     return nullptr;
2869 }
2870 
2871 static RefPtr&lt;CSSValue&gt; consumeReflect(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2872 {
2873     if (range.peek().id() == CSSValueNone)
2874         return consumeIdent(range);
2875 
2876     RefPtr&lt;CSSPrimitiveValue&gt; direction = consumeIdent&lt;CSSValueAbove, CSSValueBelow, CSSValueLeft, CSSValueRight&gt;(range);
2877     if (!direction)
2878         return nullptr;
2879 
2880     RefPtr&lt;CSSPrimitiveValue&gt; offset;
2881     if (range.atEnd())
2882         offset = CSSValuePool::singleton().createValue(0, CSSPrimitiveValue::UnitType::CSS_PX);
2883     else {
2884         offset = consumeLengthOrPercent(range, context.mode, ValueRangeAll, UnitlessQuirk::Forbid);
2885         if (!offset)
2886             return nullptr;
2887     }
2888 
2889     RefPtr&lt;CSSValue&gt; mask;
2890     if (!range.atEnd()) {
2891         mask = consumeWebkitBorderImage(CSSPropertyWebkitBoxReflect, range, context);
2892         if (!mask)
2893             return nullptr;
2894     }
2895     return CSSReflectValue::create(direction.releaseNonNull(), offset.releaseNonNull(), WTFMove(mask));
2896 }
2897 
2898 #if ENABLE(CSS_IMAGE_ORIENTATION)
2899 static RefPtr&lt;CSSValue&gt; consumeImageOrientation(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless = UnitlessQuirk::Forbid)
2900 {
2901     if (range.peek().type() != NumberToken) {
2902         RefPtr&lt;CSSPrimitiveValue&gt; angle = consumeAngle(range, cssParserMode, unitless);
2903         if (angle &amp;&amp; angle-&gt;doubleValue() == 0)
2904             return angle;
2905     }
2906     return nullptr;
2907 }
2908 #endif
2909 
2910 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundBlendMode(CSSParserTokenRange&amp; range)
2911 {
2912     CSSValueID id = range.peek().id();
2913     if (id == CSSValueNormal || id == CSSValueOverlay || (id &gt;= CSSValueMultiply &amp;&amp; id &lt;= CSSValueLuminosity))
2914         return consumeIdent(range);
2915     return nullptr;
2916 }
2917 
2918 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundAttachment(CSSParserTokenRange&amp; range)
2919 {
2920     return consumeIdent&lt;CSSValueScroll, CSSValueFixed, CSSValueLocal&gt;(range);
2921 }
2922 
2923 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundBox(CSSParserTokenRange&amp; range)
2924 {
2925     return consumeIdent&lt;CSSValueBorderBox, CSSValuePaddingBox, CSSValueContentBox, CSSValueWebkitText&gt;(range);
2926 }
2927 
2928 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundComposite(CSSParserTokenRange&amp; range)
2929 {
2930     return consumeIdentRange(range, CSSValueClear, CSSValuePlusLighter);
2931 }
2932 
2933 static RefPtr&lt;CSSPrimitiveValue&gt; consumeWebkitMaskSourceType(CSSParserTokenRange&amp; range)
2934 {
2935     return consumeIdent&lt;CSSValueAuto, CSSValueAlpha, CSSValueLuminance&gt;(range);
2936 }
2937 
2938 static RefPtr&lt;CSSPrimitiveValue&gt; consumePrefixedBackgroundBox(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; /*context*/)
2939 {
2940     // The values &#39;border&#39;, &#39;padding&#39; and &#39;content&#39; are deprecated and do not apply to the version of the property that has the -webkit- prefix removed.
2941     if (RefPtr&lt;CSSPrimitiveValue&gt; value = consumeIdentRange(range, CSSValueBorder, CSSValuePaddingBox))
2942         return value;
2943     if (range.peek().id() == CSSValueWebkitText || ((property == CSSPropertyWebkitBackgroundClip || property == CSSPropertyWebkitMaskClip) &amp;&amp; range.peek().id() == CSSValueText))
2944         return consumeIdent(range);
2945     return nullptr;
2946 }
2947 
2948 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundSize(CSSPropertyID property, CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2949 {
2950     if (identMatches&lt;CSSValueContain, CSSValueCover&gt;(range.peek().id()))
2951         return consumeIdent(range);
2952 
2953     // FIXME: We&#39;re allowing the unitless quirk on this property because our
2954     // tests assume that. Other browser engines don&#39;t allow it though.
2955     RefPtr&lt;CSSPrimitiveValue&gt; horizontal = consumeIdent&lt;CSSValueAuto&gt;(range);
2956     if (!horizontal)
2957         horizontal = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
2958 
2959     RefPtr&lt;CSSPrimitiveValue&gt; vertical;
2960     if (!range.atEnd()) {
2961         if (range.peek().id() == CSSValueAuto) // `auto&#39; is the default
2962             range.consumeIncludingWhitespace();
2963         else
2964             vertical = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
2965     } else if (!vertical &amp;&amp; property == CSSPropertyWebkitBackgroundSize) {
2966         // Legacy syntax: &quot;-webkit-background-size: 10px&quot; is equivalent to &quot;background-size: 10px 10px&quot;.
2967         vertical = horizontal;
2968     }
2969     if (!vertical)
2970         return horizontal;
2971     return createPrimitiveValuePair(horizontal.releaseNonNull(), vertical.releaseNonNull(), property == CSSPropertyWebkitBackgroundSize ? Pair::IdenticalValueEncoding::Coalesce : Pair::IdenticalValueEncoding::DoNotCoalesce);
2972 }
2973 
2974 static RefPtr&lt;CSSValueList&gt; consumeGridAutoFlow(CSSParserTokenRange&amp; range)
2975 {
2976     RefPtr&lt;CSSPrimitiveValue&gt; rowOrColumnValue = consumeIdent&lt;CSSValueRow, CSSValueColumn&gt;(range);
2977     RefPtr&lt;CSSPrimitiveValue&gt; denseAlgorithm = consumeIdent&lt;CSSValueDense&gt;(range);
2978     if (!rowOrColumnValue) {
2979         rowOrColumnValue = consumeIdent&lt;CSSValueRow, CSSValueColumn&gt;(range);
2980         if (!rowOrColumnValue &amp;&amp; !denseAlgorithm)
2981             return nullptr;
2982     }
2983     RefPtr&lt;CSSValueList&gt; parsedValues = CSSValueList::createSpaceSeparated();
2984     if (rowOrColumnValue)
2985         parsedValues-&gt;append(rowOrColumnValue.releaseNonNull());
2986     if (denseAlgorithm)
2987         parsedValues-&gt;append(denseAlgorithm.releaseNonNull());
2988     return parsedValues;
2989 }
2990 
2991 static RefPtr&lt;CSSValue&gt; consumeBackgroundComponent(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2992 {
2993     switch (property) {
2994     case CSSPropertyBackgroundClip:
2995         return consumeBackgroundBox(range);
2996     case CSSPropertyBackgroundBlendMode:
2997         return consumeBackgroundBlendMode(range);
2998     case CSSPropertyBackgroundAttachment:
2999         return consumeBackgroundAttachment(range);
3000     case CSSPropertyBackgroundOrigin:
3001         return consumeBackgroundBox(range);
3002     case CSSPropertyWebkitMaskComposite:
3003     case CSSPropertyWebkitBackgroundComposite:
3004         return consumeBackgroundComposite(range);
3005     case CSSPropertyWebkitBackgroundClip:
3006     case CSSPropertyWebkitBackgroundOrigin:
3007     case CSSPropertyWebkitMaskClip:
3008     case CSSPropertyWebkitMaskOrigin:
3009         return consumePrefixedBackgroundBox(property, range, context);
3010     case CSSPropertyBackgroundImage:
3011     case CSSPropertyWebkitMaskImage:
3012         return consumeImageOrNone(range, context);
3013     case CSSPropertyWebkitMaskSourceType:
3014         return consumeWebkitMaskSourceType(range);
3015     case CSSPropertyBackgroundPositionX:
3016     case CSSPropertyWebkitMaskPositionX:
3017         return consumePositionX(range, context.mode);
3018     case CSSPropertyBackgroundPositionY:
3019     case CSSPropertyWebkitMaskPositionY:
3020         return consumePositionY(range, context.mode);
3021     case CSSPropertyBackgroundSize:
3022     case CSSPropertyWebkitBackgroundSize:
3023     case CSSPropertyWebkitMaskSize:
3024         return consumeBackgroundSize(property, range, context.mode);
3025     case CSSPropertyBackgroundColor:
3026         return consumeColor(range, context.mode);
3027     default:
3028         break;
3029     };
3030     return nullptr;
3031 }
3032 
3033 static void addBackgroundValue(RefPtr&lt;CSSValue&gt;&amp; list, Ref&lt;CSSValue&gt;&amp;&amp; value)
3034 {
3035     if (list) {
3036         if (!list-&gt;isBaseValueList()) {
3037             RefPtr&lt;CSSValue&gt; firstValue = list;
3038             list = CSSValueList::createCommaSeparated();
3039             downcast&lt;CSSValueList&gt;(*list).append(firstValue.releaseNonNull());
3040         }
3041         downcast&lt;CSSValueList&gt;(*list).append(WTFMove(value));
3042     } else {
3043         // To conserve memory we don&#39;t actually wrap a single value in a list.
3044         list = WTFMove(value);
3045     }
3046 }
3047 
3048 static RefPtr&lt;CSSValue&gt; consumeCommaSeparatedBackgroundComponent(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
3049 {
3050     RefPtr&lt;CSSValue&gt; result;
3051     do {
3052         RefPtr&lt;CSSValue&gt; value = consumeBackgroundComponent(property, range, context);
3053         if (!value)
3054             return nullptr;
3055         addBackgroundValue(result, value.releaseNonNull());
3056     } while (consumeCommaIncludingWhitespace(range));
3057     return result;
3058 }
3059 
3060 static bool isSelfPositionKeyword(CSSValueID id)
3061 {
3062     return identMatches&lt;CSSValueStart, CSSValueEnd, CSSValueCenter, CSSValueSelfStart, CSSValueSelfEnd, CSSValueFlexStart, CSSValueFlexEnd&gt;(id);
3063 }
3064 
3065 static bool isSelfPositionOrLeftOrRightKeyword(CSSValueID id)
3066 {
3067     return isSelfPositionKeyword(id) || isLeftOrRightKeyword(id);
3068 }
3069 
3070 static RefPtr&lt;CSSValue&gt; consumeSelfPositionOverflowPosition(CSSParserTokenRange&amp; range, IsPositionKeyword isPositionKeyword)
3071 {
3072     ASSERT(isPositionKeyword);
3073     CSSValueID id = range.peek().id();
3074     if (isAuto(id) || isNormalOrStretch(id))
3075         return consumeIdent(range);
3076 
3077     if (isBaselineKeyword(id))
3078         return consumeBaselineKeyword(range);
3079 
3080     RefPtr&lt;CSSPrimitiveValue&gt; overflowPosition = consumeOverflowPositionKeyword(range);
3081     if (!isPositionKeyword(range.peek().id()))
3082         return nullptr;
3083     RefPtr&lt;CSSPrimitiveValue&gt; selfPosition = consumeIdent(range);
3084     if (overflowPosition)
3085         return createPrimitiveValuePair(overflowPosition.releaseNonNull(), selfPosition.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
3086     return selfPosition;
3087 }
3088 
3089 static RefPtr&lt;CSSValue&gt; consumeAlignItems(CSSParserTokenRange&amp; range)
3090 {
3091     // align-items property does not allow the &#39;auto&#39; value.
3092     if (identMatches&lt;CSSValueAuto&gt;(range.peek().id()))
3093         return nullptr;
3094     return consumeSelfPositionOverflowPosition(range, isSelfPositionKeyword);
3095 }
3096 
3097 static RefPtr&lt;CSSValue&gt; consumeJustifyItems(CSSParserTokenRange&amp; range)
3098 {
3099     // justify-items property does not allow the &#39;auto&#39; value.
3100     if (identMatches&lt;CSSValueAuto&gt;(range.peek().id()))
3101         return nullptr;
3102     CSSParserTokenRange rangeCopy = range;
3103     RefPtr&lt;CSSPrimitiveValue&gt; legacy = consumeIdent&lt;CSSValueLegacy&gt;(rangeCopy);
3104     RefPtr&lt;CSSPrimitiveValue&gt; positionKeyword = consumeIdent&lt;CSSValueCenter, CSSValueLeft, CSSValueRight&gt;(rangeCopy);
3105     if (!legacy)
3106         legacy = consumeIdent&lt;CSSValueLegacy&gt;(rangeCopy);
3107     if (legacy) {
3108         range = rangeCopy;
3109         if (positionKeyword)
3110             return createPrimitiveValuePair(legacy.releaseNonNull(), positionKeyword.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
3111         return legacy;
3112     }
3113     return consumeSelfPositionOverflowPosition(range, isSelfPositionOrLeftOrRightKeyword);
3114 }
3115 
3116 static RefPtr&lt;CSSValue&gt; consumeFitContent(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3117 {
3118     CSSParserTokenRange rangeCopy = range;
3119     CSSParserTokenRange args = consumeFunction(rangeCopy);
3120     RefPtr&lt;CSSPrimitiveValue&gt; length = consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3121     if (!length || !args.atEnd())
3122         return nullptr;
3123     range = rangeCopy;
3124     RefPtr&lt;CSSFunctionValue&gt; result = CSSFunctionValue::create(CSSValueFitContent);
3125     result-&gt;append(length.releaseNonNull());
3126     return result;
3127 }
3128 
3129 static RefPtr&lt;CSSPrimitiveValue&gt; consumeCustomIdentForGridLine(CSSParserTokenRange&amp; range)
3130 {
3131     if (range.peek().id() == CSSValueAuto || range.peek().id() == CSSValueSpan)
3132         return nullptr;
3133     return consumeCustomIdent(range);
3134 }
3135 
3136 static RefPtr&lt;CSSValue&gt; consumeGridLine(CSSParserTokenRange&amp; range)
3137 {
3138     if (range.peek().id() == CSSValueAuto)
3139         return consumeIdent(range);
3140 
3141     RefPtr&lt;CSSPrimitiveValue&gt; spanValue;
3142     RefPtr&lt;CSSPrimitiveValue&gt; gridLineName;
3143     RefPtr&lt;CSSPrimitiveValue&gt; numericValue = consumeInteger(range);
3144     if (numericValue) {
3145         gridLineName = consumeCustomIdentForGridLine(range);
3146         spanValue = consumeIdent&lt;CSSValueSpan&gt;(range);
3147     } else {
3148         spanValue = consumeIdent&lt;CSSValueSpan&gt;(range);
3149         if (spanValue) {
3150             numericValue = consumeInteger(range);
3151             gridLineName = consumeCustomIdentForGridLine(range);
3152             if (!numericValue)
3153                 numericValue = consumeInteger(range);
3154         } else {
3155             gridLineName = consumeCustomIdentForGridLine(range);
3156             if (gridLineName) {
3157                 numericValue = consumeInteger(range);
3158                 spanValue = consumeIdent&lt;CSSValueSpan&gt;(range);
3159                 if (!spanValue &amp;&amp; !numericValue)
3160                     return gridLineName;
3161             } else {
3162                 return nullptr;
3163             }
3164         }
3165     }
3166 
3167     if (spanValue &amp;&amp; !numericValue &amp;&amp; !gridLineName)
3168         return nullptr; // &quot;span&quot; keyword alone is invalid.
3169     if (spanValue &amp;&amp; numericValue &amp;&amp; numericValue-&gt;intValue() &lt; 0)
3170         return nullptr; // Negative numbers are not allowed for span.
3171     if (numericValue &amp;&amp; numericValue-&gt;intValue() == 0)
3172         return nullptr; // An &lt;integer&gt; value of zero makes the declaration invalid.
3173 
3174     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
3175     if (spanValue)
3176         values-&gt;append(spanValue.releaseNonNull());
3177     if (numericValue)
3178         values-&gt;append(numericValue.releaseNonNull());
3179     if (gridLineName)
3180         values-&gt;append(gridLineName.releaseNonNull());
3181     ASSERT(values-&gt;length());
3182     return values;
3183 }
3184 
3185 static bool isGridTrackFixedSized(const CSSPrimitiveValue&amp; primitiveValue)
3186 {
3187     CSSValueID valueID = primitiveValue.valueID();
3188     if (valueID == CSSValueMinContent || valueID == CSSValueWebkitMinContent || valueID == CSSValueMaxContent || valueID == CSSValueWebkitMaxContent || valueID == CSSValueAuto || primitiveValue.isFlex())
3189         return false;
3190 
3191     return true;
3192 }
3193 
3194 static bool isGridTrackFixedSized(const CSSValue&amp; value)
3195 {
3196     if (value.isPrimitiveValue())
3197         return isGridTrackFixedSized(downcast&lt;CSSPrimitiveValue&gt;(value));
3198 
3199     ASSERT(value.isFunctionValue());
3200     auto&amp; function = downcast&lt;CSSFunctionValue&gt;(value);
3201     if (function.name() == CSSValueFitContent || function.length() &lt; 2)
3202         return false;
3203 
3204     const CSSValue* minPrimitiveValue = downcast&lt;CSSPrimitiveValue&gt;(function.item(0));
3205     const CSSValue* maxPrimitiveValue = downcast&lt;CSSPrimitiveValue&gt;(function.item(1));
3206     return isGridTrackFixedSized(*minPrimitiveValue) || isGridTrackFixedSized(*maxPrimitiveValue);
3207 }
3208 
3209 static Vector&lt;String&gt; parseGridTemplateAreasColumnNames(const String&amp; gridRowNames)
3210 {
3211     ASSERT(!gridRowNames.isEmpty());
3212     Vector&lt;String&gt; columnNames;
3213     // Using StringImpl to avoid checks and indirection in every call to String::operator[].
3214     StringImpl&amp; text = *gridRowNames.impl();
3215 
3216     StringBuilder areaName;
3217     for (unsigned i = 0; i &lt; text.length(); ++i) {
3218         if (isCSSSpace(text[i])) {
3219             if (!areaName.isEmpty()) {
3220                 columnNames.append(areaName.toString());
3221                 areaName.clear();
3222             }
3223             continue;
3224         }
3225         if (text[i] == &#39;.&#39;) {
3226             if (areaName == &quot;.&quot;)
3227                 continue;
3228             if (!areaName.isEmpty()) {
3229                 columnNames.append(areaName.toString());
3230                 areaName.clear();
3231             }
3232         } else {
3233             if (!isNameCodePoint(text[i]))
3234                 return Vector&lt;String&gt;();
3235             if (areaName == &quot;.&quot;) {
3236                 columnNames.append(areaName.toString());
3237                 areaName.clear();
3238             }
3239         }
3240 
3241         areaName.append(text[i]);
3242     }
3243 
3244     if (!areaName.isEmpty())
3245         columnNames.append(areaName.toString());
3246 
3247     return columnNames;
3248 }
3249 
3250 static bool parseGridTemplateAreasRow(const String&amp; gridRowNames, NamedGridAreaMap&amp; gridAreaMap, const size_t rowCount, size_t&amp; columnCount)
3251 {
3252     if (gridRowNames.isAllSpecialCharacters&lt;isCSSSpace&gt;())
3253         return false;
3254 
3255     Vector&lt;String&gt; columnNames = parseGridTemplateAreasColumnNames(gridRowNames);
3256     if (rowCount == 0) {
3257         columnCount = columnNames.size();
3258         if (columnCount == 0)
3259             return false;
3260     } else if (columnCount != columnNames.size()) {
3261         // The declaration is invalid if all the rows don&#39;t have the number of columns.
3262         return false;
3263     }
3264 
3265     for (size_t currentColumn = 0; currentColumn &lt; columnCount; ++currentColumn) {
3266         const String&amp; gridAreaName = columnNames[currentColumn];
3267 
3268         // Unamed areas are always valid (we consider them to be 1x1).
3269         if (gridAreaName == &quot;.&quot;)
3270             continue;
3271 
3272         size_t lookAheadColumn = currentColumn + 1;
3273         while (lookAheadColumn &lt; columnCount &amp;&amp; columnNames[lookAheadColumn] == gridAreaName)
3274             lookAheadColumn++;
3275 
3276         NamedGridAreaMap::iterator gridAreaIt = gridAreaMap.find(gridAreaName);
3277         if (gridAreaIt == gridAreaMap.end()) {
3278             gridAreaMap.add(gridAreaName, GridArea(GridSpan::translatedDefiniteGridSpan(rowCount, rowCount + 1), GridSpan::translatedDefiniteGridSpan(currentColumn, lookAheadColumn)));
3279         } else {
3280             GridArea&amp; gridArea = gridAreaIt-&gt;value;
3281 
3282             // The following checks test that the grid area is a single filled-in rectangle.
3283             // 1. The new row is adjacent to the previously parsed row.
3284             if (rowCount != gridArea.rows.endLine())
3285                 return false;
3286 
3287             // 2. The new area starts at the same position as the previously parsed area.
3288             if (currentColumn != gridArea.columns.startLine())
3289                 return false;
3290 
3291             // 3. The new area ends at the same position as the previously parsed area.
3292             if (lookAheadColumn != gridArea.columns.endLine())
3293                 return false;
3294 
3295             gridArea.rows = GridSpan::translatedDefiniteGridSpan(gridArea.rows.startLine(), gridArea.rows.endLine() + 1);
3296         }
3297         currentColumn = lookAheadColumn - 1;
3298     }
3299 
3300     return true;
3301 }
3302 
3303 static RefPtr&lt;CSSPrimitiveValue&gt; consumeGridBreadth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3304 {
3305     const CSSParserToken&amp; token = range.peek();
3306     if (identMatches&lt;CSSValueMinContent, CSSValueWebkitMinContent, CSSValueMaxContent, CSSValueWebkitMaxContent, CSSValueAuto&gt;(token.id()))
3307         return consumeIdent(range);
3308     if (token.type() == DimensionToken &amp;&amp; token.unitType() == CSSPrimitiveValue::UnitType::CSS_FR) {
3309         if (range.peek().numericValue() &lt; 0)
3310             return nullptr;
3311         return CSSPrimitiveValue::create(range.consumeIncludingWhitespace().numericValue(), CSSPrimitiveValue::UnitType::CSS_FR);
3312     }
3313     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3314 }
3315 
3316 static RefPtr&lt;CSSValue&gt; consumeGridTrackSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3317 {
3318     const CSSParserToken&amp; token = range.peek();
3319     if (identMatches&lt;CSSValueAuto&gt;(token.id()))
3320         return consumeIdent(range);
3321 
3322     if (token.functionId() == CSSValueMinmax) {
3323         CSSParserTokenRange rangeCopy = range;
3324         CSSParserTokenRange args = consumeFunction(rangeCopy);
3325         RefPtr&lt;CSSPrimitiveValue&gt; minTrackBreadth = consumeGridBreadth(args, cssParserMode);
3326         if (!minTrackBreadth || minTrackBreadth-&gt;isFlex() || !consumeCommaIncludingWhitespace(args))
3327             return nullptr;
3328         RefPtr&lt;CSSPrimitiveValue&gt; maxTrackBreadth = consumeGridBreadth(args, cssParserMode);
3329         if (!maxTrackBreadth || !args.atEnd())
3330             return nullptr;
3331         range = rangeCopy;
3332         RefPtr&lt;CSSFunctionValue&gt; result = CSSFunctionValue::create(CSSValueMinmax);
3333         result-&gt;append(minTrackBreadth.releaseNonNull());
3334         result-&gt;append(maxTrackBreadth.releaseNonNull());
3335         return result;
3336     }
3337 
3338     if (token.functionId() == CSSValueFitContent)
3339         return consumeFitContent(range, cssParserMode);
3340 
3341     return consumeGridBreadth(range, cssParserMode);
3342 }
3343 
3344 // Appends to the passed in CSSGridLineNamesValue if any, otherwise creates a new one.
3345 static RefPtr&lt;CSSGridLineNamesValue&gt; consumeGridLineNames(CSSParserTokenRange&amp; range, CSSGridLineNamesValue* lineNames = nullptr)
3346 {
3347     CSSParserTokenRange rangeCopy = range;
3348     if (rangeCopy.consumeIncludingWhitespace().type() != LeftBracketToken)
3349         return nullptr;
3350 
3351     RefPtr&lt;CSSGridLineNamesValue&gt; result = lineNames;
3352     if (!result)
3353         result = CSSGridLineNamesValue::create();
3354     while (RefPtr&lt;CSSPrimitiveValue&gt; lineName = consumeCustomIdentForGridLine(rangeCopy))
3355         result-&gt;append(lineName.releaseNonNull());
3356     if (rangeCopy.consumeIncludingWhitespace().type() != RightBracketToken)
3357         return nullptr;
3358     range = rangeCopy;
3359     return result;
3360 }
3361 
3362 static bool consumeGridTrackRepeatFunction(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, CSSValueList&amp; list, bool&amp; isAutoRepeat, bool&amp; allTracksAreFixedSized)
3363 {
3364     CSSParserTokenRange args = consumeFunction(range);
3365     // The number of repetitions for &lt;auto-repeat&gt; is not important at parsing level
3366     // because it will be computed later, let&#39;s set it to 1.
3367     size_t repetitions = 1;
3368     isAutoRepeat = identMatches&lt;CSSValueAutoFill, CSSValueAutoFit&gt;(args.peek().id());
3369     RefPtr&lt;CSSValueList&gt; repeatedValues;
3370     if (isAutoRepeat)
3371         repeatedValues = CSSGridAutoRepeatValue::create(args.consumeIncludingWhitespace().id());
3372     else {
3373         // FIXME: a consumeIntegerRaw would be more efficient here.
3374         RefPtr&lt;CSSPrimitiveValue&gt; repetition = consumePositiveInteger(args);
3375         if (!repetition)
3376             return false;
3377         repetitions = clampTo&lt;size_t&gt;(repetition-&gt;doubleValue(), 0, GridPosition::max());
3378         repeatedValues = CSSValueList::createSpaceSeparated();
3379     }
3380     if (!consumeCommaIncludingWhitespace(args))
3381         return false;
3382     RefPtr&lt;CSSGridLineNamesValue&gt; lineNames = consumeGridLineNames(args);
3383     if (lineNames)
3384         repeatedValues-&gt;append(lineNames.releaseNonNull());
3385 
3386     size_t numberOfTracks = 0;
3387     while (!args.atEnd()) {
3388         RefPtr&lt;CSSValue&gt; trackSize = consumeGridTrackSize(args, cssParserMode);
3389         if (!trackSize)
3390             return false;
3391         if (allTracksAreFixedSized)
3392             allTracksAreFixedSized = isGridTrackFixedSized(*trackSize);
3393         repeatedValues-&gt;append(trackSize.releaseNonNull());
3394         ++numberOfTracks;
3395         lineNames = consumeGridLineNames(args);
3396         if (lineNames)
3397             repeatedValues-&gt;append(lineNames.releaseNonNull());
3398     }
3399     // We should have found at least one &lt;track-size&gt; or else it is not a valid &lt;track-list&gt;.
3400     if (!numberOfTracks)
3401         return false;
3402 
3403     if (isAutoRepeat)
3404         list.append(repeatedValues.releaseNonNull());
3405     else {
3406         // We clamp the repetitions to a multiple of the repeat() track list&#39;s size, while staying below the max grid size.
3407         repetitions = std::min(repetitions, GridPosition::max() / numberOfTracks);
3408         RefPtr&lt;CSSValueList&gt; integerRepeatedValues = CSSGridIntegerRepeatValue::create(repetitions);
3409         for (size_t i = 0; i &lt; repeatedValues-&gt;length(); ++i)
3410             integerRepeatedValues-&gt;append(*repeatedValues-&gt;itemWithoutBoundsCheck(i));
3411         list.append(integerRepeatedValues.releaseNonNull());
3412     }
3413     return true;
3414 }
3415 
3416 enum TrackListType { GridTemplate, GridTemplateNoRepeat, GridAuto };
3417 
3418 static RefPtr&lt;CSSValue&gt; consumeGridTrackList(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, TrackListType trackListType)
3419 {
3420     bool allowGridLineNames = trackListType != GridAuto;
3421     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
3422     RefPtr&lt;CSSGridLineNamesValue&gt; lineNames = consumeGridLineNames(range);
3423     if (lineNames) {
3424         if (!allowGridLineNames)
3425             return nullptr;
3426         values-&gt;append(lineNames.releaseNonNull());
3427     }
3428 
3429     bool allowRepeat = trackListType == GridTemplate;
3430     bool seenAutoRepeat = false;
3431     bool allTracksAreFixedSized = true;
3432     do {
3433         bool isAutoRepeat;
3434         if (range.peek().functionId() == CSSValueRepeat) {
3435             if (!allowRepeat)
3436                 return nullptr;
3437             if (!consumeGridTrackRepeatFunction(range, cssParserMode, *values, isAutoRepeat, allTracksAreFixedSized))
3438                 return nullptr;
3439             if (isAutoRepeat &amp;&amp; seenAutoRepeat)
3440                 return nullptr;
3441             seenAutoRepeat = seenAutoRepeat || isAutoRepeat;
3442         } else if (RefPtr&lt;CSSValue&gt; value = consumeGridTrackSize(range, cssParserMode)) {
3443             if (allTracksAreFixedSized)
3444                 allTracksAreFixedSized = isGridTrackFixedSized(*value);
3445             values-&gt;append(value.releaseNonNull());
3446         } else {
3447             return nullptr;
3448         }
3449         if (seenAutoRepeat &amp;&amp; !allTracksAreFixedSized)
3450             return nullptr;
3451         lineNames = consumeGridLineNames(range);
3452         if (lineNames) {
3453             if (!allowGridLineNames)
3454                 return nullptr;
3455             values-&gt;append(lineNames.releaseNonNull());
3456         }
3457     } while (!range.atEnd() &amp;&amp; range.peek().type() != DelimiterToken);
3458     return values;
3459 }
3460 
3461 static RefPtr&lt;CSSValue&gt; consumeGridTemplatesRowsOrColumns(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3462 {
3463     if (range.peek().id() == CSSValueNone)
3464         return consumeIdent(range);
3465     return consumeGridTrackList(range, cssParserMode, GridTemplate);
3466 }
3467 
3468 static RefPtr&lt;CSSValue&gt; consumeGridTemplateAreas(CSSParserTokenRange&amp; range)
3469 {
3470     if (range.peek().id() == CSSValueNone)
3471         return consumeIdent(range);
3472 
3473     NamedGridAreaMap gridAreaMap;
3474     size_t rowCount = 0;
3475     size_t columnCount = 0;
3476 
3477     while (range.peek().type() == StringToken) {
3478         if (!parseGridTemplateAreasRow(range.consumeIncludingWhitespace().value().toString(), gridAreaMap, rowCount, columnCount))
3479             return nullptr;
3480         ++rowCount;
3481     }
3482 
3483     if (rowCount == 0)
3484         return nullptr;
3485     ASSERT(columnCount);
3486     return CSSGridTemplateAreasValue::create(gridAreaMap, rowCount, columnCount);
3487 }
3488 
3489 static RefPtr&lt;CSSValue&gt; consumeLineBoxContain(CSSParserTokenRange&amp; range)
3490 {
3491     if (range.peek().id() == CSSValueNone)
3492         return consumeIdent(range);
3493 
3494     LineBoxContain lineBoxContain = LineBoxContainNone;
3495 
3496     while (range.peek().type() == IdentToken) {
3497         auto id = range.peek().id();
3498         if (id == CSSValueBlock) {
3499             if (lineBoxContain &amp; LineBoxContainBlock)
3500                 return nullptr;
3501             lineBoxContain |= LineBoxContainBlock;
3502         } else if (id == CSSValueInline) {
3503             if (lineBoxContain &amp; LineBoxContainInline)
3504                 return nullptr;
3505             lineBoxContain |= LineBoxContainInline;
3506         } else if (id == CSSValueFont) {
3507             if (lineBoxContain &amp; LineBoxContainFont)
3508                 return nullptr;
3509             lineBoxContain |= LineBoxContainFont;
3510         } else if (id == CSSValueGlyphs) {
3511             if (lineBoxContain &amp; LineBoxContainGlyphs)
3512                 return nullptr;
3513             lineBoxContain |= LineBoxContainGlyphs;
3514         } else if (id == CSSValueReplaced) {
3515             if (lineBoxContain &amp; LineBoxContainReplaced)
3516                 return nullptr;
3517             lineBoxContain |= LineBoxContainReplaced;
3518         } else if (id == CSSValueInlineBox) {
3519             if (lineBoxContain &amp; LineBoxContainInlineBox)
3520                 return nullptr;
3521             lineBoxContain |= LineBoxContainInlineBox;
3522         } else if (id == CSSValueInitialLetter) {
3523             if (lineBoxContain &amp; LineBoxContainInitialLetter)
3524                 return nullptr;
3525             lineBoxContain |= LineBoxContainInitialLetter;
3526         } else
3527             return nullptr;
3528         range.consumeIncludingWhitespace();
3529     }
3530 
3531     if (!lineBoxContain)
3532         return nullptr;
3533 
3534     return CSSLineBoxContainValue::create(lineBoxContain);
3535 }
3536 
3537 static RefPtr&lt;CSSValue&gt; consumeLineGrid(CSSParserTokenRange&amp; range)
3538 {
3539     if (range.peek().id() == CSSValueNone)
3540         return consumeIdent(range);
3541     return consumeCustomIdent(range);
3542 }
3543 
3544 static RefPtr&lt;CSSValue&gt; consumeInitialLetter(CSSParserTokenRange&amp; range)
3545 {
3546     RefPtr&lt;CSSValue&gt; ident = consumeIdent&lt;CSSValueNormal&gt;(range);
3547     if (ident)
3548         return ident;
3549 
3550     RefPtr&lt;CSSPrimitiveValue&gt; height = consumeNumber(range, ValueRangeNonNegative);
3551     if (!height)
3552         return nullptr;
3553 
3554     RefPtr&lt;CSSPrimitiveValue&gt; position;
3555     if (!range.atEnd()) {
3556         position = consumeNumber(range, ValueRangeNonNegative);
3557         if (!position || !range.atEnd())
3558             return nullptr;
3559     } else
3560         position = height.copyRef();
3561 
3562     return createPrimitiveValuePair(position.releaseNonNull(), WTFMove(height));
3563 }
3564 
3565 static RefPtr&lt;CSSValue&gt; consumeSpeakAs(CSSParserTokenRange&amp; range)
3566 {
3567     if (range.peek().id() == CSSValueNone)
3568         return consumeIdent(range);
3569 
3570     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3571 
3572     bool seenNormal = false;
3573     bool seenSpellOut = false;
3574     bool seenLiteralPunctuation = false;
3575     bool seenNoPunctuation = false;
3576 
3577     // normal | spell-out || digits || [ literal-punctuation | no-punctuation ]
3578     while (!range.atEnd()) {
3579         CSSValueID valueID = range.peek().id();
3580         if ((valueID == CSSValueNormal &amp;&amp; seenSpellOut)
3581             || (valueID == CSSValueSpellOut &amp;&amp; seenNormal)
3582             || (valueID == CSSValueLiteralPunctuation &amp;&amp; seenNoPunctuation)
3583             || (valueID == CSSValueNoPunctuation &amp;&amp; seenLiteralPunctuation))
3584             return nullptr;
3585         RefPtr&lt;CSSValue&gt; ident = consumeIdent&lt;CSSValueNormal, CSSValueSpellOut, CSSValueDigits, CSSValueLiteralPunctuation, CSSValueNoPunctuation&gt;(range);
3586         if (!ident)
3587             return nullptr;
3588         switch (valueID) {
3589         case CSSValueNormal:
3590             seenNormal = true;
3591             break;
3592         case CSSValueSpellOut:
3593             seenSpellOut = true;
3594             break;
3595         case CSSValueLiteralPunctuation:
3596             seenLiteralPunctuation = true;
3597             break;
3598         case CSSValueNoPunctuation:
3599             seenNoPunctuation = true;
3600             break;
3601         default:
3602             break;
3603         }
3604         list-&gt;append(ident.releaseNonNull());
3605     }
3606 
3607     return list-&gt;length() ? list : nullptr;
3608 }
3609 
3610 static RefPtr&lt;CSSValue&gt; consumeHangingPunctuation(CSSParserTokenRange&amp; range)
3611 {
3612     if (range.peek().id() == CSSValueNone)
3613         return consumeIdent(range);
3614 
3615     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3616 
3617     bool seenForceEnd = false;
3618     bool seenAllowEnd = false;
3619     bool seenFirst = false;
3620     bool seenLast = false;
3621 
3622     while (!range.atEnd()) {
3623         CSSValueID valueID = range.peek().id();
3624         if ((valueID == CSSValueFirst &amp;&amp; seenFirst)
3625             || (valueID == CSSValueLast &amp;&amp; seenLast)
3626             || (valueID == CSSValueAllowEnd &amp;&amp; (seenAllowEnd || seenForceEnd))
3627             || (valueID == CSSValueForceEnd &amp;&amp; (seenAllowEnd || seenForceEnd)))
3628             return nullptr;
3629         RefPtr&lt;CSSValue&gt; ident = consumeIdent&lt;CSSValueAllowEnd, CSSValueForceEnd, CSSValueFirst, CSSValueLast&gt;(range);
3630         if (!ident)
3631             return nullptr;
3632         switch (valueID) {
3633         case CSSValueAllowEnd:
3634             seenAllowEnd = true;
3635             break;
3636         case CSSValueForceEnd:
3637             seenForceEnd = true;
3638             break;
3639         case CSSValueFirst:
3640             seenFirst = true;
3641             break;
3642         case CSSValueLast:
3643             seenLast = true;
3644             break;
3645         default:
3646             break;
3647         }
3648         list-&gt;append(ident.releaseNonNull());
3649     }
3650 
3651     return list-&gt;length() ? list : nullptr;
3652 }
3653 
3654 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeIncrement(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3655 {
3656     if (range.peek().type() == IdentToken)
3657         return consumeIdent&lt;CSSValueSmall, CSSValueMedium, CSSValueLarge&gt;(range);
3658     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
3659 }
3660 
3661 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeRepetition(CSSParserTokenRange&amp; range)
3662 {
3663     if (range.peek().type() == IdentToken)
3664         return consumeIdent&lt;CSSValueInfinite&gt;(range);
3665     return consumeNumber(range, ValueRangeNonNegative);
3666 }
3667 
3668 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeSpeed(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3669 {
3670     if (range.peek().type() == IdentToken)
3671         return consumeIdent&lt;CSSValueSlow, CSSValueNormal, CSSValueFast&gt;(range);
3672     return consumeTime(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3673 }
3674 
3675 static RefPtr&lt;CSSValue&gt; consumeAlt(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
3676 {
3677     if (range.peek().type() == StringToken)
3678         return consumeString(range);
3679 
3680     if (range.peek().functionId() != CSSValueAttr)
3681         return nullptr;
3682 
3683     return consumeAttr(consumeFunction(range), context);
3684 }
3685 
3686 static RefPtr&lt;CSSValue&gt; consumeWebkitAspectRatio(CSSParserTokenRange&amp; range)
3687 {
3688     if (range.peek().type() == IdentToken)
3689         return consumeIdent&lt;CSSValueAuto, CSSValueFromDimensions, CSSValueFromIntrinsic&gt;(range);
3690 
3691     RefPtr&lt;CSSPrimitiveValue&gt; leftValue = consumeNumber(range, ValueRangeNonNegative);
3692     if (!leftValue || !leftValue-&gt;floatValue() || range.atEnd() || !consumeSlashIncludingWhitespace(range))
3693         return nullptr;
3694     RefPtr&lt;CSSPrimitiveValue&gt; rightValue = consumeNumber(range, ValueRangeNonNegative);
3695     if (!rightValue || !rightValue-&gt;floatValue())
3696         return nullptr;
3697 
3698     return CSSAspectRatioValue::create(leftValue-&gt;floatValue(), rightValue-&gt;floatValue());
3699 }
3700 
3701 static RefPtr&lt;CSSValue&gt; consumeTextEmphasisPosition(CSSParserTokenRange&amp; range)
3702 {
3703     bool foundOverOrUnder = false;
3704     CSSValueID overUnderValueID = CSSValueOver;
3705     bool foundLeftOrRight = false;
3706     CSSValueID leftRightValueID = CSSValueRight;
3707     while (!range.atEnd()) {
3708         switch (range.peek().id()) {
3709         case CSSValueOver:
3710             if (foundOverOrUnder)
3711                 return nullptr;
3712             foundOverOrUnder = true;
3713             overUnderValueID = CSSValueOver;
3714             break;
3715         case CSSValueUnder:
3716             if (foundOverOrUnder)
3717                 return nullptr;
3718             foundOverOrUnder = true;
3719             overUnderValueID = CSSValueUnder;
3720             break;
3721         case CSSValueLeft:
3722             if (foundLeftOrRight)
3723                 return nullptr;
3724             foundLeftOrRight = true;
3725             leftRightValueID = CSSValueLeft;
3726             break;
3727         case CSSValueRight:
3728             if (foundLeftOrRight)
3729                 return nullptr;
3730             foundLeftOrRight = true;
3731             leftRightValueID = CSSValueRight;
3732             break;
3733         default:
3734             return nullptr;
3735         }
3736 
3737         range.consumeIncludingWhitespace();
3738     }
3739     if (!foundOverOrUnder)
3740         return nullptr;
3741     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3742     list-&gt;append(CSSValuePool::singleton().createIdentifierValue(overUnderValueID));
3743     if (foundLeftOrRight)
3744         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(leftRightValueID));
3745     return list;
3746 }
3747 
3748 #if ENABLE(DARK_MODE_CSS)
3749 
3750 static RefPtr&lt;CSSValue&gt; consumeColorScheme(CSSParserTokenRange&amp; range)
3751 {
3752     if (isAuto(range.peek().id()))
3753         return consumeIdent(range);
3754 
3755     Vector&lt;CSSValueID, 3&gt; identifiers;
3756 
3757     while (!range.atEnd()) {
3758         if (range.peek().type() != IdentToken)
3759             return nullptr;
3760 
3761         CSSValueID id = range.peek().id();
3762 
3763         switch (id) {
3764         case CSSValueAuto:
3765             // Auto is only allowed as a single value, and was handled earlier.
3766             // Don&#39;t allow it in the list.
3767             return nullptr;
3768 
3769         case CSSValueOnly:
3770         case CSSValueLight:
3771         case CSSValueDark:
3772             if (!identifiers.appendIfNotContains(id))
3773                 return nullptr;
3774             break;
3775 
3776         default:
3777             // Unknown identifiers are allowed and ignored.
3778             break;
3779         }
3780 
3781         range.consumeIncludingWhitespace();
3782     }
3783 
3784     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3785     for (auto id : identifiers)
3786         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(id));
3787     return list;
3788 }
3789 
3790 #endif
3791 
3792 RefPtr&lt;CSSValue&gt; CSSPropertyParser::parseSingleValue(CSSPropertyID property, CSSPropertyID currentShorthand)
3793 {
3794     if (CSSParserFastPaths::isKeywordPropertyID(property)) {
3795         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(property, m_range.peek().id(), m_context))
3796             return nullptr;
3797 
3798         return consumeIdent(m_range);
3799     }
3800     switch (property) {
3801     case CSSPropertyWillChange:
3802         return consumeWillChange(m_range);
3803     case CSSPropertyPage:
3804         return consumePage(m_range);
3805     case CSSPropertyQuotes:
3806         return consumeQuotes(m_range);
3807     case CSSPropertyFontVariantCaps:
3808         return consumeFontVariantCaps(m_range);
3809     case CSSPropertyFontVariantLigatures:
3810         return consumeFontVariantLigatures(m_range);
3811     case CSSPropertyFontVariantNumeric:
3812         return consumeFontVariantNumeric(m_range);
3813     case CSSPropertyFontVariantEastAsian:
3814         return consumeFontVariantEastAsian(m_range);
3815     case CSSPropertyFontFeatureSettings:
3816         return consumeFontFeatureSettings(m_range);
3817     case CSSPropertyFontFamily:
3818         return consumeFontFamily(m_range);
3819     case CSSPropertyFontWeight:
3820         return consumeFontWeight(m_range);
3821     case CSSPropertyFontStretch:
3822         return consumeFontStretch(m_range);
3823     case CSSPropertyFontStyle:
3824         return consumeFontStyle(m_range, m_context.mode);
3825     case CSSPropertyFontSynthesis:
3826         return consumeFontSynthesis(m_range);
3827 #if ENABLE(VARIATION_FONTS)
3828     case CSSPropertyFontVariationSettings:
3829         return consumeFontVariationSettings(m_range);
3830 #endif
3831     case CSSPropertyLetterSpacing:
3832         return consumeLetterSpacing(m_range, m_context.mode);
3833     case CSSPropertyWordSpacing:
3834         return consumeWordSpacing(m_range, m_context.mode);
3835     case CSSPropertyTabSize:
3836         return consumeTabSize(m_range, m_context.mode);
3837 #if ENABLE(TEXT_AUTOSIZING)
3838     case CSSPropertyWebkitTextSizeAdjust:
3839         // FIXME: Support toggling the validation of this property via a runtime setting that is independent of
3840         // whether isTextAutosizingEnabled() is true. We want to enable this property on iOS, when simulating
3841         // a iOS device in Safari&#39;s responsive design mode and when optionally enabled in DRT/WTR. Otherwise,
3842         // this property should be disabled by default.
3843 #if !PLATFORM(IOS_FAMILY)
3844         if (!m_context.textAutosizingEnabled)
3845             return nullptr;
3846 #endif
3847         return consumeTextSizeAdjust(m_range, m_context.mode);
3848 #endif
3849     case CSSPropertyFontSize:
3850         return consumeFontSize(m_range, m_context.mode, UnitlessQuirk::Allow);
3851     case CSSPropertyLineHeight:
3852         return consumeLineHeight(m_range, m_context.mode);
3853     case CSSPropertyWebkitBorderHorizontalSpacing:
3854     case CSSPropertyWebkitBorderVerticalSpacing:
3855         return consumeLength(m_range, m_context.mode, ValueRangeNonNegative);
3856     case CSSPropertyCounterIncrement:
3857     case CSSPropertyCounterReset:
3858         return consumeCounter(m_range, property == CSSPropertyCounterIncrement ? 1 : 0);
3859     case CSSPropertySize:
3860         return consumeSize(m_range, m_context.mode);
3861     case CSSPropertyTextIndent:
3862         return consumeTextIndent(m_range, m_context.mode);
3863     case CSSPropertyMaxWidth:
3864     case CSSPropertyMaxHeight:
3865         return consumeMaxWidthOrHeight(m_range, m_context, UnitlessQuirk::Allow);
3866     case CSSPropertyMaxInlineSize:
3867     case CSSPropertyMaxBlockSize:
3868         return consumeMaxWidthOrHeight(m_range, m_context);
3869     case CSSPropertyMinWidth:
3870     case CSSPropertyMinHeight:
3871     case CSSPropertyWidth:
3872     case CSSPropertyHeight:
3873         return consumeWidthOrHeight(m_range, m_context, UnitlessQuirk::Allow);
3874     case CSSPropertyMinInlineSize:
3875     case CSSPropertyMinBlockSize:
3876     case CSSPropertyInlineSize:
3877     case CSSPropertyBlockSize:
3878         return consumeWidthOrHeight(m_range, m_context);
3879     case CSSPropertyMarginTop:
3880     case CSSPropertyMarginRight:
3881     case CSSPropertyMarginBottom:
3882     case CSSPropertyMarginLeft:
3883     case CSSPropertyBottom:
3884     case CSSPropertyLeft:
3885     case CSSPropertyRight:
3886     case CSSPropertyTop: {
3887         UnitlessQuirk unitless = currentShorthand != CSSPropertyInset ? UnitlessQuirk::Allow : UnitlessQuirk::Forbid;
3888         return consumeMarginOrOffset(m_range, m_context.mode, unitless);
3889     }
3890     case CSSPropertyInsetInlineStart:
3891     case CSSPropertyInsetInlineEnd:
3892     case CSSPropertyInsetBlockStart:
3893     case CSSPropertyInsetBlockEnd:
3894     case CSSPropertyMarginInlineStart:
3895     case CSSPropertyMarginInlineEnd:
3896     case CSSPropertyMarginBlockStart:
3897     case CSSPropertyMarginBlockEnd:
3898         return consumeMarginOrOffset(m_range, m_context.mode, UnitlessQuirk::Forbid);
3899     case CSSPropertyPaddingTop:
3900     case CSSPropertyPaddingRight:
3901     case CSSPropertyPaddingBottom:
3902     case CSSPropertyPaddingLeft:
3903         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3904     case CSSPropertyPaddingInlineStart:
3905     case CSSPropertyPaddingInlineEnd:
3906     case CSSPropertyPaddingBlockStart:
3907     case CSSPropertyPaddingBlockEnd:
3908         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Forbid);
3909 #if ENABLE(CSS_SCROLL_SNAP)
3910     case CSSPropertyScrollSnapMarginBottom:
3911     case CSSPropertyScrollSnapMarginLeft:
3912     case CSSPropertyScrollSnapMarginRight:
3913     case CSSPropertyScrollSnapMarginTop:
3914         return consumeLength(m_range, m_context.mode, ValueRangeAll);
3915     case CSSPropertyScrollPaddingBottom:
3916     case CSSPropertyScrollPaddingLeft:
3917     case CSSPropertyScrollPaddingRight:
3918     case CSSPropertyScrollPaddingTop:
3919         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeAll);
3920     case CSSPropertyScrollSnapAlign:
3921         return consumeScrollSnapAlign(m_range);
3922     case CSSPropertyScrollSnapType:
3923         return consumeScrollSnapType(m_range);
3924 #endif
3925     case CSSPropertyClip:
3926         return consumeClip(m_range, m_context.mode);
3927 #if ENABLE(POINTER_EVENTS)
3928     case CSSPropertyTouchAction:
3929         return consumeTouchAction(m_range);
3930 #endif
3931     case CSSPropertyObjectPosition:
3932         return consumePosition(m_range, m_context.mode, UnitlessQuirk::Forbid);
3933     case CSSPropertyWebkitLineClamp:
3934         return consumeLineClamp(m_range);
3935     case CSSPropertyWebkitFontSizeDelta:
3936         return consumeLength(m_range, m_context.mode, ValueRangeAll, UnitlessQuirk::Allow);
3937     case CSSPropertyWebkitHyphenateCharacter:
3938     case CSSPropertyWebkitLocale:
3939         return consumeAutoOrString(m_range);
3940     case CSSPropertyWebkitHyphenateLimitBefore:
3941     case CSSPropertyWebkitHyphenateLimitAfter:
3942         return consumeHyphenateLimit(m_range, CSSValueAuto);
3943     case CSSPropertyWebkitHyphenateLimitLines:
3944         return consumeHyphenateLimit(m_range, CSSValueNoLimit);
3945     case CSSPropertyColumnWidth:
3946         return consumeColumnWidth(m_range);
3947     case CSSPropertyColumnCount:
3948         return consumeColumnCount(m_range);
3949     case CSSPropertyColumnGap:
3950         return consumeGapLength(m_range, m_context.mode);
3951     case CSSPropertyRowGap:
3952         return consumeGapLength(m_range, m_context.mode);
3953     case CSSPropertyColumnSpan:
3954         return consumeColumnSpan(m_range);
3955     case CSSPropertyZoom:
3956         return consumeZoom(m_range, m_context);
3957     case CSSPropertyAnimationDelay:
3958     case CSSPropertyTransitionDelay:
3959     case CSSPropertyAnimationDirection:
3960     case CSSPropertyAnimationDuration:
3961     case CSSPropertyTransitionDuration:
3962     case CSSPropertyAnimationFillMode:
3963     case CSSPropertyAnimationIterationCount:
3964     case CSSPropertyAnimationName:
3965     case CSSPropertyAnimationPlayState:
3966     case CSSPropertyTransitionProperty:
3967     case CSSPropertyAnimationTimingFunction:
3968     case CSSPropertyTransitionTimingFunction:
3969         return consumeAnimationPropertyList(property, m_range, m_context);
3970     case CSSPropertyShapeMargin:
3971         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative);
3972     case CSSPropertyShapeImageThreshold:
3973         return consumeNumber(m_range, ValueRangeAll);
3974     case CSSPropertyWebkitBoxOrdinalGroup:
3975     case CSSPropertyOrphans:
3976     case CSSPropertyWidows:
3977         return consumePositiveInteger(m_range);
3978     case CSSPropertyTextDecorationColor:
3979         return consumeColor(m_range, m_context.mode);
3980     case CSSPropertyTextDecorationSkip:
3981         return consumeTextDecorationSkip(m_range);
3982     case CSSPropertyWebkitTextStrokeWidth:
3983         return consumeTextStrokeWidth(m_range, m_context.mode);
3984     case CSSPropertyWebkitTextFillColor:
3985 #if ENABLE(TOUCH_EVENTS)
3986     case CSSPropertyWebkitTapHighlightColor:
3987 #endif
3988     case CSSPropertyWebkitTextEmphasisColor:
3989     case CSSPropertyBorderInlineStartColor:
3990     case CSSPropertyBorderInlineEndColor:
3991     case CSSPropertyBorderBlockStartColor:
3992     case CSSPropertyBorderBlockEndColor:
3993     case CSSPropertyWebkitTextStrokeColor:
3994     case CSSPropertyStrokeColor:
3995     case CSSPropertyStopColor:
3996     case CSSPropertyFloodColor:
3997     case CSSPropertyLightingColor:
3998     case CSSPropertyColumnRuleColor:
3999         return consumeColor(m_range, m_context.mode);
4000     case CSSPropertyCaretColor:
4001         return consumeCaretColor(m_range, m_context.mode);
4002     case CSSPropertyColor:
4003     case CSSPropertyBackgroundColor:
4004         return consumeColor(m_range, m_context.mode, inQuirksMode());
4005     case CSSPropertyBorderInlineStartWidth:
4006     case CSSPropertyBorderInlineEndWidth:
4007     case CSSPropertyBorderBlockStartWidth:
4008     case CSSPropertyBorderBlockEndWidth:
4009         return consumeBorderWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
4010     case CSSPropertyBorderBottomColor:
4011     case CSSPropertyBorderLeftColor:
4012     case CSSPropertyBorderRightColor:
4013     case CSSPropertyBorderTopColor: {
4014         bool allowQuirkyColors = inQuirksMode()
4015             &amp;&amp; (currentShorthand == CSSPropertyInvalid || currentShorthand == CSSPropertyBorderColor);
4016         return consumeColor(m_range, m_context.mode, allowQuirkyColors);
4017     }
4018     case CSSPropertyBorderBottomWidth:
4019     case CSSPropertyBorderLeftWidth:
4020     case CSSPropertyBorderRightWidth:
4021     case CSSPropertyBorderTopWidth: {
4022         bool allowQuirkyLengths = inQuirksMode()
4023             &amp;&amp; (currentShorthand == CSSPropertyInvalid || currentShorthand == CSSPropertyBorderWidth);
4024         UnitlessQuirk unitless = allowQuirkyLengths ? UnitlessQuirk::Allow : UnitlessQuirk::Forbid;
4025         return consumeBorderWidth(m_range, m_context.mode, unitless);
4026     }
4027     case CSSPropertyZIndex:
4028         return consumeZIndex(m_range);
4029     case CSSPropertyTextShadow: // CSS2 property, dropped in CSS2.1, back in CSS3, so treat as CSS3
4030     case CSSPropertyBoxShadow:
4031     case CSSPropertyWebkitBoxShadow:
4032         return consumeShadow(m_range, m_context.mode, property == CSSPropertyBoxShadow || property == CSSPropertyWebkitBoxShadow);
4033     case CSSPropertyFilter:
4034 #if ENABLE(FILTERS_LEVEL_2)
4035     case CSSPropertyWebkitBackdropFilter:
4036 #endif
4037         return consumeFilter(m_range, m_context, AllowedFilterFunctions::PixelFilters);
4038     case CSSPropertyAppleColorFilter:
4039         if (!m_context.colorFilterEnabled)
4040             return nullptr;
4041         return consumeFilter(m_range, m_context, AllowedFilterFunctions::ColorFilters);
4042     case CSSPropertyTextDecoration:
4043     case CSSPropertyWebkitTextDecorationsInEffect:
4044     case CSSPropertyTextDecorationLine:
4045         return consumeTextDecorationLine(m_range);
4046     case CSSPropertyWebkitTextEmphasisStyle:
4047         return consumeTextEmphasisStyle(m_range);
4048     case CSSPropertyOutlineColor:
4049         return consumeOutlineColor(m_range, m_context.mode);
4050     case CSSPropertyOutlineOffset:
4051         return consumeLength(m_range, m_context.mode, ValueRangeAll);
4052     case CSSPropertyOutlineWidth:
4053         return consumeLineWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
4054     case CSSPropertyTransform:
4055         return consumeTransform(m_range, m_context.mode);
4056     case CSSPropertyTransformBox:
4057         return consumeIdent&lt;CSSValueBorderBox, CSSValueViewBox, CSSValueFillBox&gt;(m_range);
4058     case CSSPropertyTransformOriginX:
4059     case CSSPropertyPerspectiveOriginX:
4060         return consumePositionX(m_range, m_context.mode);
4061     case CSSPropertyTransformOriginY:
4062     case CSSPropertyPerspectiveOriginY:
4063         return consumePositionY(m_range, m_context.mode);
4064     case CSSPropertyTransformOriginZ:
4065         return consumeLength(m_range, m_context.mode, ValueRangeAll);
4066     case CSSPropertyFill:
4067     case CSSPropertyStroke:
4068         return consumePaintStroke(m_range, m_context.mode);
4069     case CSSPropertyGlyphOrientationVertical:
4070     case CSSPropertyGlyphOrientationHorizontal:
4071         return consumeGlyphOrientation(m_range, m_context.mode, property);
4072     case CSSPropertyPaintOrder:
4073         return consumePaintOrder(m_range);
4074     case CSSPropertyMarkerStart:
4075     case CSSPropertyMarkerMid:
4076     case CSSPropertyMarkerEnd:
4077     case CSSPropertyClipPath:
4078     case CSSPropertyMask:
4079         return consumeNoneOrURI(m_range);
4080     case CSSPropertyFlexBasis:
4081         return consumeFlexBasis(m_range, m_context.mode);
4082     case CSSPropertyFlexGrow:
4083     case CSSPropertyFlexShrink:
4084         return consumeNumber(m_range, ValueRangeNonNegative);
4085     case CSSPropertyStrokeDasharray:
4086         return consumeStrokeDasharray(m_range);
4087     case CSSPropertyColumnRuleWidth:
4088         return consumeColumnRuleWidth(m_range, m_context.mode);
4089     case CSSPropertyStrokeOpacity:
4090     case CSSPropertyFillOpacity:
4091     case CSSPropertyStopOpacity:
4092     case CSSPropertyFloodOpacity:
4093     case CSSPropertyOpacity:
4094     case CSSPropertyWebkitBoxFlex:
4095         return consumeNumber(m_range, ValueRangeAll);
4096     case CSSPropertyBaselineShift:
4097         return consumeBaselineShift(m_range);
4098     case CSSPropertyKerning:
4099         return consumeKerning(m_range, m_context.mode);
4100     case CSSPropertyStrokeMiterlimit:
4101         return consumeNumber(m_range, ValueRangeNonNegative);
4102     case CSSPropertyStrokeWidth:
4103     case CSSPropertyStrokeDashoffset:
4104     case CSSPropertyCx:
4105     case CSSPropertyCy:
4106     case CSSPropertyX:
4107     case CSSPropertyY:
4108     case CSSPropertyR:
4109         return consumeLengthOrPercent(m_range, SVGAttributeMode, ValueRangeAll, UnitlessQuirk::Forbid);
4110     case CSSPropertyRx:
4111     case CSSPropertyRy:
4112         return consumeRxOrRy(m_range);
4113     case CSSPropertyCursor:
4114         return consumeCursor(m_range, m_context, inQuirksMode());
4115     case CSSPropertyContent:
4116         return consumeContent(m_range, m_context);
4117     case CSSPropertyListStyleImage:
4118     case CSSPropertyBorderImageSource:
4119     case CSSPropertyWebkitMaskBoxImageSource:
4120         return consumeImageOrNone(m_range, m_context);
4121     case CSSPropertyPerspective:
4122         return consumePerspective(m_range, m_context.mode);
4123     case CSSPropertyBorderTopRightRadius:
4124     case CSSPropertyBorderTopLeftRadius:
4125     case CSSPropertyBorderBottomLeftRadius:
4126     case CSSPropertyBorderBottomRightRadius:
4127         return consumeBorderRadiusCorner(m_range, m_context.mode);
4128     case CSSPropertyWebkitBoxFlexGroup:
4129         return consumeInteger(m_range, 0);
4130     case CSSPropertyOrder:
4131         return consumeInteger(m_range);
4132     case CSSPropertyTextUnderlinePosition:
4133         // auto | [ [ under | from-font ] || [ left | right ] ], but we only support auto | under | from-font for now
4134         return consumeIdent&lt;CSSValueAuto, CSSValueUnder, CSSValueFromFont&gt;(m_range);
4135     case CSSPropertyTextUnderlineOffset:
4136         return consumeTextUnderlineOffset(m_range, m_context.mode);
4137     case CSSPropertyTextDecorationThickness:
4138         return consumeTextDecorationThickness(m_range, m_context.mode);
4139     case CSSPropertyVerticalAlign:
4140         return consumeVerticalAlign(m_range, m_context.mode);
4141     case CSSPropertyShapeOutside:
4142         return consumeShapeOutside(m_range, m_context);
4143     case CSSPropertyWebkitClipPath:
4144         return consumeWebkitClipPath(m_range, m_context);
4145     case CSSPropertyJustifyContent:
4146         // justify-content property does not allow the &lt;baseline-position&gt; values.
4147         if (isBaselineKeyword(m_range.peek().id()))
4148             return nullptr;
4149         return consumeContentDistributionOverflowPosition(m_range, isContentPositionOrLeftOrRightKeyword);
4150     case CSSPropertyAlignContent:
4151         return consumeContentDistributionOverflowPosition(m_range, isContentPositionKeyword);
4152     case CSSPropertyBorderImageRepeat:
4153     case CSSPropertyWebkitMaskBoxImageRepeat:
4154         return consumeBorderImageRepeat(m_range);
4155     case CSSPropertyBorderImageSlice:
4156     case CSSPropertyWebkitMaskBoxImageSlice:
4157         return consumeBorderImageSlice(property, m_range);
4158     case CSSPropertyBorderImageOutset:
4159     case CSSPropertyWebkitMaskBoxImageOutset:
4160         return consumeBorderImageOutset(m_range);
4161     case CSSPropertyBorderImageWidth:
4162     case CSSPropertyWebkitMaskBoxImageWidth:
4163         return consumeBorderImageWidth(m_range);
4164     case CSSPropertyWebkitBorderImage:
4165     case CSSPropertyWebkitMaskBoxImage:
4166         return consumeWebkitBorderImage(property, m_range, m_context);
4167     case CSSPropertyWebkitBoxReflect:
4168         return consumeReflect(m_range, m_context);
4169     case CSSPropertyWebkitLineBoxContain:
4170         return consumeLineBoxContain(m_range);
4171 #if ENABLE(CSS_IMAGE_ORIENTATION)
4172     case CSSPropertyImageOrientation:
4173         return consumeImageOrientation(m_range, m_context.mode);
4174 #endif
4175     case CSSPropertyBackgroundAttachment:
4176     case CSSPropertyBackgroundBlendMode:
4177     case CSSPropertyBackgroundClip:
4178     case CSSPropertyBackgroundImage:
4179     case CSSPropertyBackgroundOrigin:
4180     case CSSPropertyBackgroundPositionX:
4181     case CSSPropertyBackgroundPositionY:
4182     case CSSPropertyBackgroundSize:
4183     case CSSPropertyWebkitBackgroundClip:
4184     case CSSPropertyWebkitBackgroundOrigin:
4185     case CSSPropertyWebkitBackgroundComposite:
4186     case CSSPropertyWebkitBackgroundSize:
4187     case CSSPropertyWebkitMaskClip:
4188     case CSSPropertyWebkitMaskComposite:
4189     case CSSPropertyWebkitMaskImage:
4190     case CSSPropertyWebkitMaskOrigin:
4191     case CSSPropertyWebkitMaskPositionX:
4192     case CSSPropertyWebkitMaskPositionY:
4193     case CSSPropertyWebkitMaskSize:
4194     case CSSPropertyWebkitMaskSourceType:
4195         return consumeCommaSeparatedBackgroundComponent(property, m_range, m_context);
4196     case CSSPropertyWebkitMaskRepeatX:
4197     case CSSPropertyWebkitMaskRepeatY:
4198         return nullptr;
4199     case CSSPropertyAlignItems:
4200         return consumeAlignItems(m_range);
4201     case CSSPropertyJustifySelf:
4202         return consumeSelfPositionOverflowPosition(m_range, isSelfPositionOrLeftOrRightKeyword);
4203     case CSSPropertyAlignSelf:
4204         return consumeSelfPositionOverflowPosition(m_range, isSelfPositionKeyword);
4205     case CSSPropertyJustifyItems:
4206         return consumeJustifyItems(m_range);
4207     case CSSPropertyGridColumnEnd:
4208     case CSSPropertyGridColumnStart:
4209     case CSSPropertyGridRowEnd:
4210     case CSSPropertyGridRowStart:
4211         return consumeGridLine(m_range);
4212     case CSSPropertyGridAutoColumns:
4213     case CSSPropertyGridAutoRows:
4214         return consumeGridTrackList(m_range, m_context.mode, GridAuto);
4215     case CSSPropertyGridTemplateColumns:
4216     case CSSPropertyGridTemplateRows:
4217         return consumeGridTemplatesRowsOrColumns(m_range, m_context.mode);
4218     case CSSPropertyGridTemplateAreas:
4219         return consumeGridTemplateAreas(m_range);
4220     case CSSPropertyGridAutoFlow:
4221         return consumeGridAutoFlow(m_range);
4222     case CSSPropertyWebkitLineGrid:
4223         return consumeLineGrid(m_range);
4224     case CSSPropertyWebkitInitialLetter:
4225         return consumeInitialLetter(m_range);
4226     case CSSPropertySpeakAs:
4227         return consumeSpeakAs(m_range);
4228     case CSSPropertyHangingPunctuation:
4229         return consumeHangingPunctuation(m_range);
4230     case CSSPropertyWebkitMarqueeIncrement:
4231         return consumeWebkitMarqueeIncrement(m_range, m_context.mode);
4232     case CSSPropertyWebkitMarqueeRepetition:
4233         return consumeWebkitMarqueeRepetition(m_range);
4234     case CSSPropertyWebkitMarqueeSpeed:
4235         return consumeWebkitMarqueeSpeed(m_range, m_context.mode);
4236     case CSSPropertyAlt:
4237         return consumeAlt(m_range, m_context);
4238     case CSSPropertyWebkitAspectRatio:
4239         return consumeWebkitAspectRatio(m_range);
4240     case CSSPropertyWebkitTextEmphasisPosition:
4241         return consumeTextEmphasisPosition(m_range);
4242 #if ENABLE(DARK_MODE_CSS)
4243     case CSSPropertyColorScheme:
4244         return consumeColorScheme(m_range);
4245 #endif
4246     default:
4247         return nullptr;
4248     }
4249 }
4250 
4251 bool CSSPropertyParser::canParseTypedCustomPropertyValue(const String&amp; syntax)
4252 {
4253     if (syntax != &quot;*&quot;) {
4254         m_range.consumeWhitespace();
4255 
4256         // First check for keywords
4257         CSSValueID id = m_range.peek().id();
4258         if (id == CSSValueInherit || id == CSSValueInitial || id == CSSValueRevert)
4259             return true;
4260 
4261         auto localRange = m_range;
4262         while (!localRange.atEnd()) {
4263             auto id = localRange.consume().functionId();
4264             if (id == CSSValueVar || id == CSSValueEnv)
4265                 return true; // For variables, we just permit everything
4266         }
4267 
4268         auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
4269         if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue() &amp;&amp; m_range.atEnd())
4270             return true;
4271         return false;
4272     }
4273 
4274     return true;
4275 }
4276 
4277 void CSSPropertyParser::collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies)
4278 {
4279     if (syntax != &quot;*&quot;) {
4280         m_range.consumeWhitespace();
4281         auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
4282         if (!m_range.atEnd())
4283             return;
4284         if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue()) {
4285             primitiveVal-&gt;collectDirectComputationalDependencies(dependencies);
4286             if (isRoot)
4287                 primitiveVal-&gt;collectDirectRootComputationalDependencies(dependencies);
4288         }
4289     }
4290 }
4291 
4292 RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const StyleResolver&amp; styleResolver)
4293 {
4294     if (syntax != &quot;*&quot;) {
4295         m_range.consumeWhitespace();
4296         auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
4297         if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue() &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(*primitiveVal).isLength()) {
4298             auto length = StyleBuilderConverter::convertLength(styleResolver, *primitiveVal);
4299             if (!length.isCalculated() &amp;&amp; !length.isUndefined())
4300                 return CSSCustomPropertyValue::createSyntaxLength(name, WTFMove(length));
4301         }
4302     } else {
4303         auto propertyValue = CSSCustomPropertyValue::createSyntaxAll(name, CSSVariableData::create(m_range));
4304         while (!m_range.atEnd())
4305             m_range.consume();
4306         return { WTFMove(propertyValue) };
4307     }
4308 
4309     return nullptr;
4310 }
4311 
4312 static RefPtr&lt;CSSValueList&gt; consumeFontFaceUnicodeRange(CSSParserTokenRange&amp; range)
4313 {
4314     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createCommaSeparated();
4315 
4316     do {
4317         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
4318         if (token.type() != UnicodeRangeToken)
4319             return nullptr;
4320 
4321         UChar32 start = token.unicodeRangeStart();
4322         UChar32 end = token.unicodeRangeEnd();
4323         if (start &gt; end)
4324             return nullptr;
4325         values-&gt;append(CSSUnicodeRangeValue::create(start, end));
4326     } while (consumeCommaIncludingWhitespace(range));
4327 
4328     return values;
4329 }
4330 
4331 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontFaceFontDisplay(CSSParserTokenRange&amp; range)
4332 {
4333     return consumeIdent&lt;CSSValueAuto, CSSValueBlock, CSSValueSwap, CSSValueFallback, CSSValueOptional&gt;(range);
4334 }
4335 
4336 static RefPtr&lt;CSSValue&gt; consumeFontFaceSrcURI(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
4337 {
4338     String url = consumeUrlAsStringView(range).toString();
4339     if (url.isNull())
4340         return nullptr;
4341 
4342     RefPtr&lt;CSSFontFaceSrcValue&gt; uriValue = CSSFontFaceSrcValue::create(context.completeURL(url), context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No);
4343 
4344     if (range.peek().functionId() != CSSValueFormat)
4345         return uriValue;
4346 
4347     // FIXME: https://drafts.csswg.org/css-fonts says that format() contains a comma-separated list of strings,
4348     // but CSSFontFaceSrcValue stores only one format. Allowing one format for now.
4349     // FIXME: We&#39;re allowing the format to be an identifier as well as a string, because the old
4350     // parser did. It&#39;s not clear if we need to continue to support this behavior, but we have lots of
4351     // layout tests that rely on it.
4352     CSSParserTokenRange args = consumeFunction(range);
4353     const CSSParserToken&amp; arg = args.consumeIncludingWhitespace();
4354     if ((arg.type() != StringToken &amp;&amp; arg.type() != IdentToken) || !args.atEnd())
4355         return nullptr;
4356     uriValue-&gt;setFormat(arg.value().toString());
4357     return uriValue;
4358 }
4359 
4360 static RefPtr&lt;CSSValue&gt; consumeFontFaceSrcLocal(CSSParserTokenRange&amp; range)
4361 {
4362     CSSParserTokenRange args = consumeFunction(range);
4363     if (args.peek().type() == StringToken) {
4364         const CSSParserToken&amp; arg = args.consumeIncludingWhitespace();
4365         if (!args.atEnd())
4366             return nullptr;
4367         return CSSFontFaceSrcValue::createLocal(arg.value().toString());
4368     }
4369     if (args.peek().type() == IdentToken) {
4370         String familyName = concatenateFamilyName(args);
4371         if (!args.atEnd())
4372             return nullptr;
4373         return CSSFontFaceSrcValue::createLocal(familyName);
4374     }
4375     return nullptr;
4376 }
4377 
4378 static RefPtr&lt;CSSValueList&gt; consumeFontFaceSrc(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
4379 {
4380     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createCommaSeparated();
4381 
4382     do {
4383         const CSSParserToken&amp; token = range.peek();
4384         RefPtr&lt;CSSValue&gt; parsedValue;
4385         if (token.functionId() == CSSValueLocal)
4386             parsedValue = consumeFontFaceSrcLocal(range);
4387         else
4388             parsedValue = consumeFontFaceSrcURI(range, context);
4389         if (!parsedValue)
4390             return nullptr;
4391         values-&gt;append(parsedValue.releaseNonNull());
4392     } while (consumeCommaIncludingWhitespace(range));
4393     return values;
4394 }
4395 
4396 bool CSSPropertyParser::parseFontFaceDescriptor(CSSPropertyID propId)
4397 {
4398     RefPtr&lt;CSSValue&gt; parsedValue;
4399     switch (propId) {
4400     case CSSPropertyFontFamily:
4401         parsedValue = consumeFontFamilyDescriptor(m_range);
4402         break;
4403     case CSSPropertySrc: // This is a list of urls or local references.
4404         parsedValue = consumeFontFaceSrc(m_range, m_context);
4405         break;
4406     case CSSPropertyUnicodeRange:
4407         parsedValue = consumeFontFaceUnicodeRange(m_range);
4408         break;
4409     case CSSPropertyFontDisplay:
4410         parsedValue = consumeFontFaceFontDisplay(m_range);
4411         break;
4412     case CSSPropertyFontWeight:
4413 #if ENABLE(VARIATION_FONTS)
4414         parsedValue = consumeFontWeightRange(m_range);
4415 #else
4416         parsedValue = consumeFontWeight(m_range);
4417 #endif
4418         break;
4419     case CSSPropertyFontStretch:
4420 #if ENABLE(VARIATION_FONTS)
4421         parsedValue = consumeFontStretchRange(m_range);
4422 #else
4423         parsedValue = consumeFontStretch(m_range);
4424 #endif
4425         break;
4426     case CSSPropertyFontStyle:
4427 #if ENABLE(VARIATION_FONTS)
4428         parsedValue = consumeFontStyleRange(m_range, m_context.mode);
4429 #else
4430         parsedValue = consumeFontStyle(m_range, m_context.mode);
4431 #endif
4432         break;
4433     case CSSPropertyFontVariantCaps:
4434         parsedValue = consumeFontVariantCaps(m_range);
4435         break;
4436     case CSSPropertyFontVariantLigatures:
4437         parsedValue = consumeFontVariantLigatures(m_range);
4438         break;
4439     case CSSPropertyFontVariantNumeric:
4440         parsedValue = consumeFontVariantNumeric(m_range);
4441         break;
4442     case CSSPropertyFontVariantEastAsian:
4443         parsedValue = consumeFontVariantEastAsian(m_range);
4444         break;
4445     case CSSPropertyFontVariantAlternates:
4446         parsedValue = consumeFontVariantAlternates(m_range);
4447         break;
4448     case CSSPropertyFontVariantPosition:
4449         parsedValue = consumeFontVariantPosition(m_range);
4450         break;
4451     case CSSPropertyFontVariant:
4452         return consumeFontVariantShorthand(false);
4453     case CSSPropertyFontFeatureSettings:
4454         parsedValue = consumeFontFeatureSettings(m_range);
4455         break;
4456     default:
4457         break;
4458     }
4459 
4460     if (!parsedValue || !m_range.atEnd())
4461         return false;
4462 
4463     addProperty(propId, CSSPropertyInvalid, *parsedValue, false);
4464     return true;
4465 }
4466 
4467 bool CSSPropertyParser::consumeSystemFont(bool important)
4468 {
4469     CSSValueID systemFontID = m_range.consumeIncludingWhitespace().id();
4470     ASSERT(systemFontID &gt;= CSSValueCaption &amp;&amp; systemFontID &lt;= CSSValueStatusBar);
4471     if (!m_range.atEnd())
4472         return false;
4473 
4474     FontCascadeDescription fontDescription;
4475     RenderTheme::singleton().systemFont(systemFontID, fontDescription);
4476     if (!fontDescription.isAbsoluteSize())
4477         return false;
4478 
4479     addProperty(CSSPropertyFontStyle, CSSPropertyFont, CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(isItalic(fontDescription.italic()) ? CSSValueItalic : CSSValueNormal)), important);
4480     addProperty(CSSPropertyFontWeight, CSSPropertyFont, CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(fontDescription.weight())), important);
4481     addProperty(CSSPropertyFontSize, CSSPropertyFont, CSSValuePool::singleton().createValue(fontDescription.specifiedSize(), CSSPrimitiveValue::CSS_PX), important);
4482     Ref&lt;CSSValueList&gt; fontFamilyList = CSSValueList::createCommaSeparated();
4483     fontFamilyList-&gt;append(CSSValuePool::singleton().createFontFamilyValue(fontDescription.familyAt(0), FromSystemFontID::Yes));
4484     addProperty(CSSPropertyFontFamily, CSSPropertyFont, WTFMove(fontFamilyList), important);
4485     addProperty(CSSPropertyFontVariantCaps, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4486     addProperty(CSSPropertyLineHeight, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4487 
4488     // FIXME_NEWPARSER: What about FontVariantNumeric and FontVariantLigatures?
4489 
4490     return true;
4491 }
4492 
4493 bool CSSPropertyParser::consumeFont(bool important)
4494 {
4495     // Let&#39;s check if there is an inherit or initial somewhere in the shorthand.
4496     CSSParserTokenRange range = m_range;
4497     while (!range.atEnd()) {
4498         CSSValueID id = range.consumeIncludingWhitespace().id();
4499         if (id == CSSValueInherit || id == CSSValueInitial)
4500             return false;
4501     }
4502     // Optional font-style, font-variant, font-stretch and font-weight.
4503     RefPtr&lt;CSSFontStyleValue&gt; fontStyle;
4504     RefPtr&lt;CSSPrimitiveValue&gt; fontVariantCaps;
4505     RefPtr&lt;CSSPrimitiveValue&gt; fontWeight;
4506     RefPtr&lt;CSSPrimitiveValue&gt; fontStretch;
4507 
4508     while (!m_range.atEnd()) {
4509         CSSValueID id = m_range.peek().id();
4510         if (!fontStyle) {
4511             fontStyle = consumeFontStyle(m_range, m_context.mode);
4512             if (fontStyle)
4513                 continue;
4514         }
4515         if (!fontVariantCaps &amp;&amp; (id == CSSValueNormal || id == CSSValueSmallCaps)) {
4516             // Font variant in the shorthand is particular, it only accepts normal or small-caps.
4517             // See https://drafts.csswg.org/css-fonts/#propdef-font
4518             fontVariantCaps = consumeFontVariantCSS21(m_range);
4519             if (fontVariantCaps)
4520                 continue;
4521         }
4522         if (!fontWeight) {
4523             fontWeight = consumeFontWeight(m_range);
4524             if (fontWeight)
4525                 continue;
4526         }
4527         if (!fontStretch) {
4528             fontStretch = consumeFontStretchKeywordValue(m_range);
4529             if (fontStretch)
4530                 continue;
4531         }
4532         break;
4533     }
4534 
4535     if (m_range.atEnd())
4536         return false;
4537 
4538     bool hasStyle = fontStyle;
4539     bool hasVariant = fontVariantCaps;
4540     bool hasWeight = fontWeight;
4541     bool hasStretch = fontStretch;
4542 
4543     if (!fontStyle)
4544         fontStyle = CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueNormal));
4545 
4546     addProperty(CSSPropertyFontStyle, CSSPropertyFont, fontStyle.releaseNonNull(), important, !hasStyle);
4547     addProperty(CSSPropertyFontVariantCaps, CSSPropertyFont, fontVariantCaps ? fontVariantCaps.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, !hasVariant);
4548 /*
4549     // FIXME-NEWPARSER: What do we do with these? They aren&#39;t part of our fontShorthand().
4550     addProperty(CSSPropertyFontVariantLigatures, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, true);
4551     addProperty(CSSPropertyFontVariantNumeric, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, true);
4552 */
4553 
4554     addProperty(CSSPropertyFontWeight, CSSPropertyFont, fontWeight ? fontWeight.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, !hasWeight);
4555     addProperty(CSSPropertyFontStretch, CSSPropertyFont, fontStretch ? fontStretch.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, !hasStretch);
4556 
4557     // Now a font size _must_ come.
4558     RefPtr&lt;CSSValue&gt; fontSize = consumeFontSize(m_range, m_context.mode);
4559     if (!fontSize || m_range.atEnd())
4560         return false;
4561 
4562     addProperty(CSSPropertyFontSize, CSSPropertyFont, *fontSize, important);
4563 
4564     if (consumeSlashIncludingWhitespace(m_range)) {
4565         RefPtr&lt;CSSPrimitiveValue&gt; lineHeight = consumeLineHeight(m_range, m_context.mode);
4566         if (!lineHeight)
4567             return false;
4568         addProperty(CSSPropertyLineHeight, CSSPropertyFont, lineHeight.releaseNonNull(), important);
4569     } else
4570         addProperty(CSSPropertyLineHeight, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, true);
4571 
4572     // Font family must come now.
4573     RefPtr&lt;CSSValue&gt; parsedFamilyValue = consumeFontFamily(m_range);
4574     if (!parsedFamilyValue)
4575         return false;
4576 
4577     addProperty(CSSPropertyFontFamily, CSSPropertyFont, parsedFamilyValue.releaseNonNull(), important);
4578 
4579     return m_range.atEnd();
4580 }
4581 
4582 bool CSSPropertyParser::consumeFontVariantShorthand(bool important)
4583 {
4584     if (identMatches&lt;CSSValueNormal, CSSValueNone&gt;(m_range.peek().id())) {
4585         addProperty(CSSPropertyFontVariantLigatures, CSSPropertyFontVariant, consumeIdent(m_range).releaseNonNull(), important);
4586         addProperty(CSSPropertyFontVariantCaps, CSSPropertyFontVariant, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4587         addProperty(CSSPropertyFontVariantEastAsian, CSSPropertyFontVariant, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4588         addProperty(CSSPropertyFontVariantPosition, CSSPropertyFontVariant, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4589         return m_range.atEnd();
4590     }
4591 
4592     RefPtr&lt;CSSPrimitiveValue&gt; capsValue;
4593     RefPtr&lt;CSSPrimitiveValue&gt; alternatesValue;
4594     RefPtr&lt;CSSPrimitiveValue&gt; positionValue;
4595 
4596     RefPtr&lt;CSSValue&gt; eastAsianValue;
4597     FontVariantLigaturesParser ligaturesParser;
4598     FontVariantNumericParser numericParser;
4599     do {
4600         if (!capsValue) {
4601             capsValue = consumeFontVariantCaps(m_range);
4602             if (capsValue)
4603                 continue;
4604         }
4605 
4606         if (!positionValue) {
4607             positionValue = consumeFontVariantPosition(m_range);
4608             if (positionValue)
4609                 continue;
4610         }
4611 
4612         if (!alternatesValue) {
4613             alternatesValue = consumeFontVariantAlternates(m_range);
4614             if (alternatesValue)
4615                 continue;
4616         }
4617 
4618         FontVariantLigaturesParser::ParseResult ligaturesParseResult = ligaturesParser.consumeLigature(m_range);
4619         FontVariantNumericParser::ParseResult numericParseResult = numericParser.consumeNumeric(m_range);
4620         if (ligaturesParseResult == FontVariantLigaturesParser::ParseResult::ConsumedValue
4621             || numericParseResult == FontVariantNumericParser::ParseResult::ConsumedValue)
4622             continue;
4623 
4624         if (ligaturesParseResult == FontVariantLigaturesParser::ParseResult::DisallowedValue
4625             || numericParseResult == FontVariantNumericParser::ParseResult::DisallowedValue)
4626             return false;
4627 
4628         if (!eastAsianValue) {
4629             eastAsianValue = consumeFontVariantEastAsian(m_range);
4630             if (eastAsianValue)
4631             continue;
4632         }
4633 
4634         // Saw some value that didn&#39;t match anything else.
4635         return false;
4636 
4637     } while (!m_range.atEnd());
4638 
4639     addProperty(CSSPropertyFontVariantLigatures, CSSPropertyFontVariant, ligaturesParser.finalizeValue().releaseNonNull(), important);
4640     addProperty(CSSPropertyFontVariantNumeric, CSSPropertyFontVariant, numericParser.finalizeValue().releaseNonNull(), important);
4641     addProperty(CSSPropertyFontVariantCaps, CSSPropertyFontVariant, capsValue ? capsValue.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4642     addProperty(CSSPropertyFontVariantAlternates, CSSPropertyFontVariant, alternatesValue ? alternatesValue.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4643     addProperty(CSSPropertyFontVariantPosition, CSSPropertyFontVariant, positionValue ? positionValue.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4644 
4645     if (!eastAsianValue)
4646         eastAsianValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
4647     addProperty(CSSPropertyFontVariantEastAsian, CSSPropertyFontVariant, eastAsianValue.releaseNonNull(), important);
4648 
4649     return true;
4650 }
4651 
4652 bool CSSPropertyParser::consumeBorderSpacing(bool important)
4653 {
4654     RefPtr&lt;CSSValue&gt; horizontalSpacing = consumeLength(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Allow);
4655     if (!horizontalSpacing)
4656         return false;
4657     RefPtr&lt;CSSValue&gt; verticalSpacing = horizontalSpacing;
4658     if (!m_range.atEnd())
4659         verticalSpacing = consumeLength(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Allow);
4660     if (!verticalSpacing || !m_range.atEnd())
4661         return false;
4662     addProperty(CSSPropertyWebkitBorderHorizontalSpacing, CSSPropertyBorderSpacing, horizontalSpacing.releaseNonNull(), important);
4663     addProperty(CSSPropertyWebkitBorderVerticalSpacing, CSSPropertyBorderSpacing, verticalSpacing.releaseNonNull(), important);
4664     return true;
4665 }
4666 
4667 #if ENABLE(CSS_DEVICE_ADAPTATION)
4668 
4669 static RefPtr&lt;CSSValue&gt; consumeSingleViewportDescriptor(CSSParserTokenRange&amp; range, CSSPropertyID propId, CSSParserMode cssParserMode)
4670 {
4671     CSSValueID id = range.peek().id();
4672     switch (propId) {
4673     case CSSPropertyMinWidth:
4674     case CSSPropertyMaxWidth:
4675     case CSSPropertyMinHeight:
4676     case CSSPropertyMaxHeight:
4677         if (id == CSSValueAuto)
4678             return consumeIdent(range);
4679         return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
4680     case CSSPropertyMinZoom:
4681     case CSSPropertyMaxZoom:
4682     case CSSPropertyZoom: {
4683         if (id == CSSValueAuto)
4684             return consumeIdent(range);
4685         RefPtr&lt;CSSValue&gt; parsedValue = consumeNumber(range, ValueRangeNonNegative);
4686         if (parsedValue)
4687             return parsedValue;
4688         return consumePercent(range, ValueRangeNonNegative);
4689     }
4690     case CSSPropertyUserZoom:
4691         return consumeIdent&lt;CSSValueZoom, CSSValueFixed&gt;(range);
4692     case CSSPropertyOrientation:
4693         return consumeIdent&lt;CSSValueAuto, CSSValuePortrait, CSSValueLandscape&gt;(range);
4694     default:
4695         ASSERT_NOT_REACHED();
4696         break;
4697     }
4698 
4699     ASSERT_NOT_REACHED();
4700     return nullptr;
4701 }
4702 
4703 bool CSSPropertyParser::parseViewportDescriptor(CSSPropertyID propId, bool important)
4704 {
4705     switch (propId) {
4706     case CSSPropertyWidth: {
4707         RefPtr&lt;CSSValue&gt; minWidth = consumeSingleViewportDescriptor(m_range, CSSPropertyMinWidth, m_context.mode);
4708         if (!minWidth)
4709             return false;
4710         RefPtr&lt;CSSValue&gt; maxWidth = minWidth;
4711         if (!m_range.atEnd())
4712             maxWidth = consumeSingleViewportDescriptor(m_range, CSSPropertyMaxWidth, m_context.mode);
4713         if (!maxWidth || !m_range.atEnd())
4714             return false;
4715         addProperty(CSSPropertyMinWidth, CSSPropertyInvalid, *minWidth, important);
4716         addProperty(CSSPropertyMaxWidth, CSSPropertyInvalid, *maxWidth, important);
4717         return true;
4718     }
4719     case CSSPropertyHeight: {
4720         RefPtr&lt;CSSValue&gt; minHeight = consumeSingleViewportDescriptor(m_range, CSSPropertyMinHeight, m_context.mode);
4721         if (!minHeight)
4722             return false;
4723         RefPtr&lt;CSSValue&gt; maxHeight = minHeight;
4724         if (!m_range.atEnd())
4725             maxHeight = consumeSingleViewportDescriptor(m_range, CSSPropertyMaxHeight, m_context.mode);
4726         if (!maxHeight || !m_range.atEnd())
4727             return false;
4728         addProperty(CSSPropertyMinHeight, CSSPropertyInvalid, *minHeight, important);
4729         addProperty(CSSPropertyMaxHeight, CSSPropertyInvalid, *maxHeight, important);
4730         return true;
4731     }
4732     case CSSPropertyMinWidth:
4733     case CSSPropertyMaxWidth:
4734     case CSSPropertyMinHeight:
4735     case CSSPropertyMaxHeight:
4736     case CSSPropertyMinZoom:
4737     case CSSPropertyMaxZoom:
4738     case CSSPropertyZoom:
4739     case CSSPropertyUserZoom:
4740     case CSSPropertyOrientation: {
4741         RefPtr&lt;CSSValue&gt; parsedValue = consumeSingleViewportDescriptor(m_range, propId, m_context.mode);
4742         if (!parsedValue || !m_range.atEnd())
4743             return false;
4744         addProperty(propId, CSSPropertyInvalid, parsedValue.releaseNonNull(), important);
4745         return true;
4746     }
4747     default:
4748         return false;
4749     }
4750 }
4751 
4752 #endif
4753 
4754 bool CSSPropertyParser::consumeColumns(bool important)
4755 {
4756     RefPtr&lt;CSSValue&gt; columnWidth;
4757     RefPtr&lt;CSSValue&gt; columnCount;
4758     bool hasPendingExplicitAuto = false;
4759 
4760     for (unsigned propertiesParsed = 0; propertiesParsed &lt; 2 &amp;&amp; !m_range.atEnd(); ++propertiesParsed) {
4761         if (!propertiesParsed &amp;&amp; m_range.peek().id() == CSSValueAuto) {
4762             // &#39;auto&#39; is a valid value for any of the two longhands, and at this point
4763             // we don&#39;t know which one(s) it is meant for. We need to see if there are other values first.
4764             consumeIdent(m_range);
4765             hasPendingExplicitAuto = true;
4766         } else {
4767             if (!columnWidth) {
4768                 if ((columnWidth = consumeColumnWidth(m_range)))
4769                     continue;
4770             }
4771             if (!columnCount) {
4772                 if ((columnCount = consumeColumnCount(m_range)))
4773                     continue;
4774             }
4775             // If we didn&#39;t find at least one match, this is an invalid shorthand and we have to ignore it.
4776             return false;
4777         }
4778     }
4779 
4780     if (!m_range.atEnd())
4781         return false;
4782 
4783     // Any unassigned property at this point will become implicit &#39;auto&#39;.
4784     if (columnWidth)
4785         addProperty(CSSPropertyColumnWidth, CSSPropertyInvalid, columnWidth.releaseNonNull(), important);
4786     else {
4787         addProperty(CSSPropertyColumnWidth, CSSPropertyInvalid, CSSValuePool::singleton().createIdentifierValue(CSSValueAuto), important, !hasPendingExplicitAuto /* implicit */);
4788         hasPendingExplicitAuto = false;
4789     }
4790 
4791     if (columnCount)
4792         addProperty(CSSPropertyColumnCount, CSSPropertyInvalid, columnCount.releaseNonNull(), important);
4793     else
4794         addProperty(CSSPropertyColumnCount, CSSPropertyInvalid, CSSValuePool::singleton().createIdentifierValue(CSSValueAuto), important, !hasPendingExplicitAuto /* implicit */);
4795 
4796     return true;
4797 }
4798 
4799 bool CSSPropertyParser::consumeShorthandGreedily(const StylePropertyShorthand&amp; shorthand, bool important)
4800 {
4801     ASSERT(shorthand.length() &lt;= 6); // Existing shorthands have at most 6 longhands.
4802     RefPtr&lt;CSSValue&gt; longhands[6];
4803     const CSSPropertyID* shorthandProperties = shorthand.properties();
4804     do {
4805         bool foundLonghand = false;
4806         for (size_t i = 0; !foundLonghand &amp;&amp; i &lt; shorthand.length(); ++i) {
4807             if (longhands[i])
4808                 continue;
4809             longhands[i] = parseSingleValue(shorthandProperties[i], shorthand.id());
4810             if (longhands[i])
4811                 foundLonghand = true;
4812         }
4813         if (!foundLonghand)
4814             return false;
4815     } while (!m_range.atEnd());
4816 
4817     for (size_t i = 0; i &lt; shorthand.length(); ++i) {
4818         if (longhands[i])
4819             addProperty(shorthandProperties[i], shorthand.id(), longhands[i].releaseNonNull(), important);
4820         else
4821             addProperty(shorthandProperties[i], shorthand.id(), CSSValuePool::singleton().createImplicitInitialValue(), important);
4822     }
4823     return true;
4824 }
4825 
4826 bool CSSPropertyParser::consumeFlex(bool important)
4827 {
4828     static const double unsetValue = -1;
4829     double flexGrow = unsetValue;
4830     double flexShrink = unsetValue;
4831     RefPtr&lt;CSSPrimitiveValue&gt; flexBasis;
4832 
4833     if (m_range.peek().id() == CSSValueNone) {
4834         flexGrow = 0;
4835         flexShrink = 0;
4836         flexBasis = CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
4837         m_range.consumeIncludingWhitespace();
4838     } else {
4839         unsigned index = 0;
4840         while (!m_range.atEnd() &amp;&amp; index++ &lt; 3) {
4841             double num;
4842             if (consumeNumberRaw(m_range, num)) {
4843                 if (num &lt; 0)
4844                     return false;
4845                 if (flexGrow == unsetValue)
4846                     flexGrow = num;
4847                 else if (flexShrink == unsetValue)
4848                     flexShrink = num;
4849                 else if (!num) // flex only allows a basis of 0 (sans units) if flex-grow and flex-shrink values have already been set.
4850                     flexBasis = CSSPrimitiveValue::create(0, CSSPrimitiveValue::UnitType::CSS_PX);
4851                 else
4852                     return false;
4853             } else if (!flexBasis) {
4854                 if (m_range.peek().id() == CSSValueAuto)
4855                     flexBasis = consumeIdent(m_range);
4856                 if (!flexBasis)
4857                     flexBasis = consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative);
4858                 if (index == 2 &amp;&amp; !m_range.atEnd())
4859                     return false;
4860             }
4861         }
4862         if (index == 0)
4863             return false;
4864         if (flexGrow == unsetValue)
4865             flexGrow = 1;
4866         if (flexShrink == unsetValue)
4867             flexShrink = 1;
4868 
4869         // FIXME: Using % here is a hack to work around intrinsic sizing implementation being
4870         // a mess (e.g., turned off for nested column flexboxes, failing to relayout properly even
4871         // if turned back on for nested columns, etc.). We have layout test coverage of both
4872         // scenarios.
4873         if (!flexBasis)
4874             flexBasis = CSSPrimitiveValue::create(0, CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);
4875     }
4876 
4877     if (!m_range.atEnd())
4878         return false;
4879     addProperty(CSSPropertyFlexGrow, CSSPropertyFlex, CSSPrimitiveValue::create(clampTo&lt;float&gt;(flexGrow), CSSPrimitiveValue::UnitType::CSS_NUMBER), important);
4880     addProperty(CSSPropertyFlexShrink, CSSPropertyFlex, CSSPrimitiveValue::create(clampTo&lt;float&gt;(flexShrink), CSSPrimitiveValue::UnitType::CSS_NUMBER), important);
4881     addProperty(CSSPropertyFlexBasis, CSSPropertyFlex, flexBasis.releaseNonNull(), important);
4882     return true;
4883 }
4884 
4885 bool CSSPropertyParser::consumeBorder(RefPtr&lt;CSSValue&gt;&amp; width, RefPtr&lt;CSSValue&gt;&amp; style, RefPtr&lt;CSSValue&gt;&amp; color)
4886 {
4887     while (!width || !style || !color) {
4888         if (!width) {
4889             width = consumeLineWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
4890             if (width)
4891                 continue;
4892         }
4893         if (!style) {
4894             style = parseSingleValue(CSSPropertyBorderLeftStyle, CSSPropertyBorder);
4895             if (style)
4896                 continue;
4897         }
4898         if (!color) {
4899             color = consumeColor(m_range, m_context.mode);
4900             if (color)
4901                 continue;
4902         }
4903         break;
4904     }
4905 
4906     if (!width &amp;&amp; !style &amp;&amp; !color)
4907         return false;
4908 
4909     if (!width)
4910         width = CSSValuePool::singleton().createImplicitInitialValue();
4911     if (!style)
4912         style = CSSValuePool::singleton().createImplicitInitialValue();
4913     if (!color)
4914         color = CSSValuePool::singleton().createImplicitInitialValue();
4915 
4916     return m_range.atEnd();
4917 }
4918 
4919 bool CSSPropertyParser::consume2ValueShorthand(const StylePropertyShorthand&amp; shorthand, bool important)
4920 {
4921     ASSERT(shorthand.length() == 2);
4922     const CSSPropertyID* longhands = shorthand.properties();
4923     RefPtr&lt;CSSValue&gt; start = parseSingleValue(longhands[0], shorthand.id());
4924     if (!start)
4925         return false;
4926 
4927     RefPtr&lt;CSSValue&gt; end = parseSingleValue(longhands[1], shorthand.id());
4928     bool endImplicit = !end;
4929     if (endImplicit)
4930         end = start;
4931     addProperty(longhands[0], shorthand.id(), start.releaseNonNull(), important);
4932     addProperty(longhands[1], shorthand.id(), end.releaseNonNull(), important, endImplicit);
4933 
4934     return m_range.atEnd();
4935 }
4936 
4937 bool CSSPropertyParser::consume4ValueShorthand(const StylePropertyShorthand&amp; shorthand, bool important)
4938 {
4939     ASSERT(shorthand.length() == 4);
4940     const CSSPropertyID* longhands = shorthand.properties();
4941     RefPtr&lt;CSSValue&gt; top = parseSingleValue(longhands[0], shorthand.id());
4942     if (!top)
4943         return false;
4944 
4945     RefPtr&lt;CSSValue&gt; right = parseSingleValue(longhands[1], shorthand.id());
4946     RefPtr&lt;CSSValue&gt; bottom;
4947     RefPtr&lt;CSSValue&gt; left;
4948     if (right) {
4949         bottom = parseSingleValue(longhands[2], shorthand.id());
4950         if (bottom)
4951             left = parseSingleValue(longhands[3], shorthand.id());
4952     }
4953 
4954     bool rightImplicit = !right;
4955     bool bottomImplicit = !bottom;
4956     bool leftImplicit = !left;
4957 
4958     if (!right)
4959         right = top;
4960     if (!bottom)
4961         bottom = top;
4962     if (!left)
4963         left = right;
4964 
4965     addProperty(longhands[0], shorthand.id(), top.releaseNonNull(), important);
4966     addProperty(longhands[1], shorthand.id(), right.releaseNonNull(), important, rightImplicit);
4967     addProperty(longhands[2], shorthand.id(), bottom.releaseNonNull(), important, bottomImplicit);
4968     addProperty(longhands[3], shorthand.id(), left.releaseNonNull(), important, leftImplicit);
4969 
4970     return m_range.atEnd();
4971 }
4972 
4973 bool CSSPropertyParser::consumeBorderImage(CSSPropertyID property, bool important)
4974 {
4975     RefPtr&lt;CSSValue&gt; source;
4976     RefPtr&lt;CSSValue&gt; slice;
4977     RefPtr&lt;CSSValue&gt; width;
4978     RefPtr&lt;CSSValue&gt; outset;
4979     RefPtr&lt;CSSValue&gt; repeat;
4980 
4981     if (consumeBorderImageComponents(property, m_range, m_context, source, slice, width, outset, repeat)) {
4982         if (!source)
4983             source = CSSValuePool::singleton().createImplicitInitialValue();
4984         if (!slice)
4985             slice = CSSValuePool::singleton().createImplicitInitialValue();
4986         if (!width)
4987             width = CSSValuePool::singleton().createImplicitInitialValue();
4988         if (!outset)
4989             outset = CSSValuePool::singleton().createImplicitInitialValue();
4990         if (!repeat)
4991             repeat = CSSValuePool::singleton().createImplicitInitialValue();
4992         switch (property) {
4993         case CSSPropertyWebkitMaskBoxImage:
4994             addProperty(CSSPropertyWebkitMaskBoxImageSource, CSSPropertyWebkitMaskBoxImage, source.releaseNonNull(), important);
4995             addProperty(CSSPropertyWebkitMaskBoxImageSlice, CSSPropertyWebkitMaskBoxImage, slice.releaseNonNull(), important);
4996             addProperty(CSSPropertyWebkitMaskBoxImageWidth, CSSPropertyWebkitMaskBoxImage, width.releaseNonNull(), important);
4997             addProperty(CSSPropertyWebkitMaskBoxImageOutset, CSSPropertyWebkitMaskBoxImage, outset.releaseNonNull(), important);
4998             addProperty(CSSPropertyWebkitMaskBoxImageRepeat, CSSPropertyWebkitMaskBoxImage, repeat.releaseNonNull(), important);
4999             return true;
5000         case CSSPropertyBorderImage:
5001             addProperty(CSSPropertyBorderImageSource, CSSPropertyBorderImage, source.releaseNonNull(), important);
5002             addProperty(CSSPropertyBorderImageSlice, CSSPropertyBorderImage, slice.releaseNonNull(), important);
5003             addProperty(CSSPropertyBorderImageWidth, CSSPropertyBorderImage, width.releaseNonNull() , important);
5004             addProperty(CSSPropertyBorderImageOutset, CSSPropertyBorderImage, outset.releaseNonNull(), important);
5005             addProperty(CSSPropertyBorderImageRepeat, CSSPropertyBorderImage, repeat.releaseNonNull(), important);
5006             return true;
5007         default:
5008             ASSERT_NOT_REACHED();
5009             return false;
5010         }
5011     }
5012     return false;
5013 }
5014 
5015 static inline CSSValueID mapFromPageBreakBetween(CSSValueID value)
5016 {
5017     if (value == CSSValueAlways)
5018         return CSSValuePage;
5019     if (value == CSSValueAuto || value == CSSValueAvoid || value == CSSValueLeft || value == CSSValueRight)
5020         return value;
5021     return CSSValueInvalid;
5022 }
5023 
5024 static inline CSSValueID mapFromColumnBreakBetween(CSSValueID value)
5025 {
5026     if (value == CSSValueAlways)
5027         return CSSValueColumn;
5028     if (value == CSSValueAuto)
5029         return value;
5030     if (value == CSSValueAvoid)
5031         return CSSValueAvoidColumn;
5032     return CSSValueInvalid;
5033 }
5034 
5035 static inline CSSValueID mapFromColumnRegionOrPageBreakInside(CSSValueID value)
5036 {
5037     if (value == CSSValueAuto || value == CSSValueAvoid)
5038         return value;
5039     return CSSValueInvalid;
5040 }
5041 
5042 static inline CSSPropertyID mapFromLegacyBreakProperty(CSSPropertyID property)
5043 {
5044     if (property == CSSPropertyPageBreakAfter || property == CSSPropertyWebkitColumnBreakAfter)
5045         return CSSPropertyBreakAfter;
5046     if (property == CSSPropertyPageBreakBefore || property == CSSPropertyWebkitColumnBreakBefore)
5047         return CSSPropertyBreakBefore;
5048     ASSERT(property == CSSPropertyPageBreakInside || property == CSSPropertyWebkitColumnBreakInside);
5049     return CSSPropertyBreakInside;
5050 }
5051 
5052 bool CSSPropertyParser::consumeLegacyBreakProperty(CSSPropertyID property, bool important)
5053 {
5054     // The fragmentation spec says that page-break-(after|before|inside) are to be treated as
5055     // shorthands for their break-(after|before|inside) counterparts. We&#39;ll do the same for the
5056     // non-standard properties -webkit-column-break-(after|before|inside).
5057     RefPtr&lt;CSSPrimitiveValue&gt; keyword = consumeIdent(m_range);
5058     if (!keyword)
5059         return false;
5060     if (!m_range.atEnd())
5061         return false;
5062     CSSValueID value = keyword-&gt;valueID();
5063     switch (property) {
5064     case CSSPropertyPageBreakAfter:
5065     case CSSPropertyPageBreakBefore:
5066         value = mapFromPageBreakBetween(value);
5067         break;
5068     case CSSPropertyWebkitColumnBreakAfter:
5069     case CSSPropertyWebkitColumnBreakBefore:
5070         value = mapFromColumnBreakBetween(value);
5071         break;
5072     case CSSPropertyPageBreakInside:
5073     case CSSPropertyWebkitColumnBreakInside:
5074         value = mapFromColumnRegionOrPageBreakInside(value);
5075         break;
5076     default:
5077         ASSERT_NOT_REACHED();
5078     }
5079     if (value == CSSValueInvalid)
5080         return false;
5081 
5082     CSSPropertyID genericBreakProperty = mapFromLegacyBreakProperty(property);
5083     addProperty(genericBreakProperty, property, CSSValuePool::singleton().createIdentifierValue(value), important);
5084     return true;
5085 }
5086 
5087 static bool consumeBackgroundPosition(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, UnitlessQuirk unitless, RefPtr&lt;CSSValue&gt;&amp; resultX, RefPtr&lt;CSSValue&gt;&amp; resultY)
5088 {
5089     do {
5090         RefPtr&lt;CSSPrimitiveValue&gt; positionX;
5091         RefPtr&lt;CSSPrimitiveValue&gt; positionY;
5092         if (!consumePosition(range, context.mode, unitless, positionX, positionY))
5093             return false;
5094         addBackgroundValue(resultX, positionX.releaseNonNull());
5095         addBackgroundValue(resultY, positionY.releaseNonNull());
5096     } while (consumeCommaIncludingWhitespace(range));
5097     return true;
5098 }
5099 
5100 static bool consumeRepeatStyleComponent(CSSParserTokenRange&amp; range, RefPtr&lt;CSSPrimitiveValue&gt;&amp; value1, RefPtr&lt;CSSPrimitiveValue&gt;&amp; value2, bool&amp; implicit)
5101 {
5102     if (consumeIdent&lt;CSSValueRepeatX&gt;(range)) {
5103         value1 = CSSValuePool::singleton().createIdentifierValue(CSSValueRepeat);
5104         value2 = CSSValuePool::singleton().createIdentifierValue(CSSValueNoRepeat);
5105         implicit = true;
5106         return true;
5107     }
5108     if (consumeIdent&lt;CSSValueRepeatY&gt;(range)) {
5109         value1 = CSSValuePool::singleton().createIdentifierValue(CSSValueNoRepeat);
5110         value2 = CSSValuePool::singleton().createIdentifierValue(CSSValueRepeat);
5111         implicit = true;
5112         return true;
5113     }
5114     value1 = consumeIdent&lt;CSSValueRepeat, CSSValueNoRepeat, CSSValueRound, CSSValueSpace&gt;(range);
5115     if (!value1)
5116         return false;
5117 
5118     value2 = consumeIdent&lt;CSSValueRepeat, CSSValueNoRepeat, CSSValueRound, CSSValueSpace&gt;(range);
5119     if (!value2) {
5120         value2 = value1;
5121         implicit = true;
5122     }
5123     return true;
5124 }
5125 
5126 static bool consumeRepeatStyle(CSSParserTokenRange&amp; range, RefPtr&lt;CSSValue&gt;&amp; resultX, RefPtr&lt;CSSValue&gt;&amp; resultY, bool&amp; implicit)
5127 {
5128     do {
5129         RefPtr&lt;CSSPrimitiveValue&gt; repeatX;
5130         RefPtr&lt;CSSPrimitiveValue&gt; repeatY;
5131         if (!consumeRepeatStyleComponent(range, repeatX, repeatY, implicit))
5132             return false;
5133         addBackgroundValue(resultX, repeatX.releaseNonNull());
5134         addBackgroundValue(resultY, repeatY.releaseNonNull());
5135     } while (consumeCommaIncludingWhitespace(range));
5136     return true;
5137 }
5138 
5139 // Note: consumeBackgroundShorthand assumes y properties (for example background-position-y) follow
5140 // the x properties in the shorthand array.
5141 bool CSSPropertyParser::consumeBackgroundShorthand(const StylePropertyShorthand&amp; shorthand, bool important)
5142 {
5143     const unsigned longhandCount = shorthand.length();
5144     RefPtr&lt;CSSValue&gt; longhands[10];
5145     ASSERT(longhandCount &lt;= 10);
5146 
5147     bool implicit = false;
5148     do {
5149         bool parsedLonghand[10] = { false };
5150         RefPtr&lt;CSSValue&gt; originValue;
5151         do {
5152             bool foundProperty = false;
5153             for (size_t i = 0; i &lt; longhandCount; ++i) {
5154                 if (parsedLonghand[i])
5155                     continue;
5156 
5157                 RefPtr&lt;CSSValue&gt; value;
5158                 RefPtr&lt;CSSValue&gt; valueY;
5159                 CSSPropertyID property = shorthand.properties()[i];
5160                 if (property == CSSPropertyBackgroundRepeatX || property == CSSPropertyWebkitMaskRepeatX) {
5161                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValue;
5162                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValueY;
5163                     consumeRepeatStyleComponent(m_range, primitiveValue, primitiveValueY, implicit);
5164                     value = primitiveValue;
5165                     valueY = primitiveValueY;
5166                 } else if (property == CSSPropertyBackgroundPositionX || property == CSSPropertyWebkitMaskPositionX) {
5167                     CSSParserTokenRange rangeCopy = m_range;
5168                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValue;
5169                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValueY;
5170                     if (!consumePosition(rangeCopy, m_context.mode, UnitlessQuirk::Forbid, primitiveValue, primitiveValueY))
5171                         continue;
5172                     value = primitiveValue;
5173                     valueY = primitiveValueY;
5174                     m_range = rangeCopy;
5175                 } else if (property == CSSPropertyBackgroundSize || property == CSSPropertyWebkitMaskSize) {
5176                     if (!consumeSlashIncludingWhitespace(m_range))
5177                         continue;
5178                     value = consumeBackgroundSize(property, m_range, m_context.mode);
5179                     if (!value || !parsedLonghand[i - 1]) // Position must have been parsed in the current layer.
5180                         return false;
5181                 } else if (property == CSSPropertyBackgroundPositionY || property == CSSPropertyBackgroundRepeatY
5182                     || property == CSSPropertyWebkitMaskPositionY || property == CSSPropertyWebkitMaskRepeatY) {
5183                     continue;
5184                 } else {
5185                     value = consumeBackgroundComponent(property, m_range, m_context);
5186                 }
5187                 if (value) {
5188                     if (property == CSSPropertyBackgroundOrigin || property == CSSPropertyWebkitMaskOrigin)
5189                         originValue = value;
5190                     parsedLonghand[i] = true;
5191                     foundProperty = true;
5192                     addBackgroundValue(longhands[i], value.releaseNonNull());
5193                     if (valueY) {
5194                         parsedLonghand[i + 1] = true;
5195                         addBackgroundValue(longhands[i + 1], valueY.releaseNonNull());
5196                     }
5197                 }
5198             }
5199             if (!foundProperty)
5200                 return false;
5201         } while (!m_range.atEnd() &amp;&amp; m_range.peek().type() != CommaToken);
5202 
5203         // FIXME: This will make invalid longhands, see crbug.com/386459
5204         for (size_t i = 0; i &lt; longhandCount; ++i) {
5205             CSSPropertyID property = shorthand.properties()[i];
5206             if (property == CSSPropertyBackgroundColor &amp;&amp; !m_range.atEnd()) {
5207                 if (parsedLonghand[i])
5208                     return false; // Colors are only allowed in the last layer.
5209                 continue;
5210             }
5211             if ((property == CSSPropertyBackgroundClip || property == CSSPropertyWebkitMaskClip) &amp;&amp; !parsedLonghand[i] &amp;&amp; originValue) {
5212                 addBackgroundValue(longhands[i], originValue.releaseNonNull());
5213                 continue;
5214             }
5215             if (!parsedLonghand[i])
5216                 addBackgroundValue(longhands[i], CSSValuePool::singleton().createImplicitInitialValue());
5217         }
5218     } while (consumeCommaIncludingWhitespace(m_range));
5219     if (!m_range.atEnd())
5220         return false;
5221 
5222     for (size_t i = 0; i &lt; longhandCount; ++i) {
5223         CSSPropertyID property = shorthand.properties()[i];
5224         if (property == CSSPropertyBackgroundSize &amp;&amp; longhands[i] &amp;&amp; m_context.useLegacyBackgroundSizeShorthandBehavior)
5225             continue;
5226         addProperty(property, shorthand.id(), *longhands[i], important, implicit);
5227     }
5228     return true;
5229 }
5230 
5231 // FIXME-NEWPARSER: Hack to work around the fact that we aren&#39;t using CSSCustomIdentValue
5232 // for stuff yet. This can be replaced by CSSValue::isCustomIdentValue() once we switch
5233 // to using CSSCustomIdentValue everywhere.
5234 static bool isCustomIdentValue(const CSSValue&amp; value)
5235 {
5236     return is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value).isString();
5237 }
5238 
5239 bool CSSPropertyParser::consumeGridItemPositionShorthand(CSSPropertyID shorthandId, bool important)
5240 {
5241     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(shorthandId);
5242     ASSERT(shorthand.length() == 2);
5243     RefPtr&lt;CSSValue&gt; startValue = consumeGridLine(m_range);
5244     if (!startValue)
5245         return false;
5246 
5247     RefPtr&lt;CSSValue&gt; endValue;
5248     if (consumeSlashIncludingWhitespace(m_range)) {
5249         endValue = consumeGridLine(m_range);
5250         if (!endValue)
5251             return false;
5252     } else {
5253         endValue = isCustomIdentValue(*startValue) ? startValue : CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5254     }
5255     if (!m_range.atEnd())
5256         return false;
5257     addProperty(shorthand.properties()[0], shorthandId, startValue.releaseNonNull(), important);
5258     addProperty(shorthand.properties()[1], shorthandId, endValue.releaseNonNull(), important);
5259     return true;
5260 }
5261 
5262 bool CSSPropertyParser::consumeGridAreaShorthand(bool important)
5263 {
5264     RefPtr&lt;CSSValue&gt; rowStartValue = consumeGridLine(m_range);
5265     if (!rowStartValue)
5266         return false;
5267     RefPtr&lt;CSSValue&gt; columnStartValue;
5268     RefPtr&lt;CSSValue&gt; rowEndValue;
5269     RefPtr&lt;CSSValue&gt; columnEndValue;
5270     if (consumeSlashIncludingWhitespace(m_range)) {
5271         columnStartValue = consumeGridLine(m_range);
5272         if (!columnStartValue)
5273             return false;
5274         if (consumeSlashIncludingWhitespace(m_range)) {
5275             rowEndValue = consumeGridLine(m_range);
5276             if (!rowEndValue)
5277                 return false;
5278             if (consumeSlashIncludingWhitespace(m_range)) {
5279                 columnEndValue = consumeGridLine(m_range);
5280                 if (!columnEndValue)
5281                     return false;
5282             }
5283         }
5284     }
5285     if (!m_range.atEnd())
5286         return false;
5287     if (!columnStartValue)
5288         columnStartValue = isCustomIdentValue(*rowStartValue) ? rowStartValue : CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5289     if (!rowEndValue)
5290         rowEndValue = isCustomIdentValue(*rowStartValue) ? rowStartValue : CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5291     if (!columnEndValue)
5292         columnEndValue = isCustomIdentValue(*columnStartValue) ? columnStartValue : CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5293 
5294     addProperty(CSSPropertyGridRowStart, CSSPropertyGridArea, rowStartValue.releaseNonNull(), important);
5295     addProperty(CSSPropertyGridColumnStart, CSSPropertyGridArea, columnStartValue.releaseNonNull(), important);
5296     addProperty(CSSPropertyGridRowEnd, CSSPropertyGridArea, rowEndValue.releaseNonNull(), important);
5297     addProperty(CSSPropertyGridColumnEnd, CSSPropertyGridArea, columnEndValue.releaseNonNull(), important);
5298     return true;
5299 }
5300 
5301 bool CSSPropertyParser::consumeGridTemplateRowsAndAreasAndColumns(CSSPropertyID shorthandId, bool important)
5302 {
5303     NamedGridAreaMap gridAreaMap;
5304     size_t rowCount = 0;
5305     size_t columnCount = 0;
5306     RefPtr&lt;CSSValueList&gt; templateRows = CSSValueList::createSpaceSeparated();
5307 
5308     // Persists between loop iterations so we can use the same value for
5309     // consecutive &lt;line-names&gt; values
5310     RefPtr&lt;CSSGridLineNamesValue&gt; lineNames;
5311 
5312     do {
5313         // Handle leading &lt;custom-ident&gt;*.
5314         bool hasPreviousLineNames = lineNames;
5315         lineNames = consumeGridLineNames(m_range, lineNames.get());
5316         if (lineNames &amp;&amp; !hasPreviousLineNames)
5317             templateRows-&gt;append(*lineNames);
5318 
5319         // Handle a template-area&#39;s row.
5320         if (m_range.peek().type() != StringToken || !parseGridTemplateAreasRow(m_range.consumeIncludingWhitespace().value().toString(), gridAreaMap, rowCount, columnCount))
5321             return false;
5322         ++rowCount;
5323 
5324         // Handle template-rows&#39;s track-size.
5325         RefPtr&lt;CSSValue&gt; value = consumeGridTrackSize(m_range, m_context.mode);
5326         if (!value)
5327             value = CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5328         templateRows-&gt;append(*value);
5329 
5330         // This will handle the trailing/leading &lt;custom-ident&gt;* in the grammar.
5331         lineNames = consumeGridLineNames(m_range);
5332         if (lineNames)
5333             templateRows-&gt;append(lineNames.releaseNonNull());
5334     } while (!m_range.atEnd() &amp;&amp; !(m_range.peek().type() == DelimiterToken &amp;&amp; m_range.peek().delimiter() == &#39;/&#39;));
5335 
5336     RefPtr&lt;CSSValue&gt; columnsValue;
5337     if (!m_range.atEnd()) {
5338         if (!consumeSlashIncludingWhitespace(m_range))
5339             return false;
5340         columnsValue = consumeGridTrackList(m_range, m_context.mode, GridTemplateNoRepeat);
5341         if (!columnsValue || !m_range.atEnd())
5342             return false;
5343     } else {
5344         columnsValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
5345     }
5346     addProperty(CSSPropertyGridTemplateRows, shorthandId, templateRows.releaseNonNull(), important);
5347     addProperty(CSSPropertyGridTemplateColumns, shorthandId, columnsValue.releaseNonNull(), important);
5348     addProperty(CSSPropertyGridTemplateAreas, shorthandId, CSSGridTemplateAreasValue::create(gridAreaMap, rowCount, columnCount), important);
5349     return true;
5350 }
5351 
5352 bool CSSPropertyParser::consumeGridTemplateShorthand(CSSPropertyID shorthandId, bool important)
5353 {
5354     CSSParserTokenRange rangeCopy = m_range;
5355     RefPtr&lt;CSSValue&gt; rowsValue = consumeIdent&lt;CSSValueNone&gt;(m_range);
5356 
5357     // 1- &#39;none&#39; case.
5358     if (rowsValue &amp;&amp; m_range.atEnd()) {
5359         addProperty(CSSPropertyGridTemplateRows, shorthandId, CSSValuePool::singleton().createIdentifierValue(CSSValueNone), important);
5360         addProperty(CSSPropertyGridTemplateColumns, shorthandId, CSSValuePool::singleton().createIdentifierValue(CSSValueNone), important);
5361         addProperty(CSSPropertyGridTemplateAreas, shorthandId, CSSValuePool::singleton().createIdentifierValue(CSSValueNone), important);
5362         return true;
5363     }
5364 
5365     // 2- &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;
5366     if (!rowsValue)
5367         rowsValue = consumeGridTrackList(m_range, m_context.mode, GridTemplate);
5368 
5369     if (rowsValue) {
5370         if (!consumeSlashIncludingWhitespace(m_range))
5371             return false;
5372         RefPtr&lt;CSSValue&gt; columnsValue = consumeGridTemplatesRowsOrColumns(m_range, m_context.mode);
5373         if (!columnsValue || !m_range.atEnd())
5374             return false;
5375 
5376         addProperty(CSSPropertyGridTemplateRows, shorthandId, rowsValue.releaseNonNull(), important);
5377         addProperty(CSSPropertyGridTemplateColumns, shorthandId, columnsValue.releaseNonNull(), important);
5378         addProperty(CSSPropertyGridTemplateAreas, shorthandId, CSSValuePool::singleton().createIdentifierValue(CSSValueNone), important);
5379         return true;
5380     }
5381 
5382     // 3- [ &lt;line-names&gt;? &lt;string&gt; &lt;track-size&gt;? &lt;line-names&gt;? ]+ [ / &lt;track-list&gt; ]?
5383     m_range = rangeCopy;
5384     return consumeGridTemplateRowsAndAreasAndColumns(shorthandId, important);
5385 }
5386 
5387 static RefPtr&lt;CSSValue&gt; consumeImplicitGridAutoFlow(CSSParserTokenRange&amp; range, Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; flowDirection)
5388 {
5389     // [ auto-flow &amp;&amp; dense? ]
5390     if (range.atEnd())
5391         return nullptr;
5392     auto list = CSSValueList::createSpaceSeparated();
5393     list-&gt;append(WTFMove(flowDirection));
5394     if (range.peek().id() == CSSValueAutoFlow) {
5395         range.consumeIncludingWhitespace();
5396         RefPtr&lt;CSSValue&gt; denseIdent = consumeIdent&lt;CSSValueDense&gt;(range);
5397         if (denseIdent)
5398             list-&gt;append(denseIdent.releaseNonNull());
5399     } else {
5400         // Dense case
5401         if (range.peek().id() != CSSValueDense)
5402             return nullptr;
5403         range.consumeIncludingWhitespace();
5404         if (range.atEnd() || range.peek().id() != CSSValueAutoFlow)
5405             return nullptr;
5406         range.consumeIncludingWhitespace();
5407         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueDense));
5408     }
5409 
5410     return list;
5411 }
5412 
5413 bool CSSPropertyParser::consumeGridShorthand(bool important)
5414 {
5415     ASSERT(shorthandForProperty(CSSPropertyGrid).length() == 6);
5416 
5417     CSSParserTokenRange rangeCopy = m_range;
5418 
5419     // 1- &lt;grid-template&gt;
5420     if (consumeGridTemplateShorthand(CSSPropertyGrid, important)) {
5421         // It can only be specified the explicit or the implicit grid properties in a single grid declaration.
5422         // The sub-properties not specified are set to their initial value, as normal for shorthands.
5423         addProperty(CSSPropertyGridAutoFlow, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5424         addProperty(CSSPropertyGridAutoColumns, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5425         addProperty(CSSPropertyGridAutoRows, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5426         return true;
5427     }
5428 
5429     m_range = rangeCopy;
5430 
5431     RefPtr&lt;CSSValue&gt; autoColumnsValue;
5432     RefPtr&lt;CSSValue&gt; autoRowsValue;
5433     RefPtr&lt;CSSValue&gt; templateRows;
5434     RefPtr&lt;CSSValue&gt; templateColumns;
5435     RefPtr&lt;CSSValue&gt; gridAutoFlow;
5436 
5437     if (m_range.peek().id() == CSSValueAutoFlow || m_range.peek().id() == CSSValueDense) {
5438         // 2- [ auto-flow &amp;&amp; dense? ] &lt;grid-auto-rows&gt;? / &lt;grid-template-columns&gt;
5439         gridAutoFlow = consumeImplicitGridAutoFlow(m_range, CSSValuePool::singleton().createIdentifierValue(CSSValueRow));
5440         if (!gridAutoFlow || m_range.atEnd())
5441             return false;
5442         if (consumeSlashIncludingWhitespace(m_range))
5443             autoRowsValue = CSSValuePool::singleton().createImplicitInitialValue();
5444         else {
5445             autoRowsValue = consumeGridTrackList(m_range, m_context.mode, GridAuto);
5446             if (!autoRowsValue)
5447                 return false;
5448             if (!consumeSlashIncludingWhitespace(m_range))
5449                 return false;
5450         }
5451         if (m_range.atEnd())
5452             return false;
5453         templateColumns = consumeGridTemplatesRowsOrColumns(m_range, m_context.mode);
5454         if (!templateColumns)
5455             return false;
5456         templateRows = CSSValuePool::singleton().createImplicitInitialValue();
5457         autoColumnsValue = CSSValuePool::singleton().createImplicitInitialValue();
5458     } else {
5459         // 3- &lt;grid-template-rows&gt; / [ auto-flow &amp;&amp; dense? ] &lt;grid-auto-columns&gt;?
5460         templateRows = consumeGridTemplatesRowsOrColumns(m_range, m_context.mode);
5461         if (!templateRows)
5462             return false;
5463         if (!consumeSlashIncludingWhitespace(m_range) || m_range.atEnd())
5464             return false;
5465         gridAutoFlow = consumeImplicitGridAutoFlow(m_range, CSSValuePool::singleton().createIdentifierValue(CSSValueColumn));
5466         if (!gridAutoFlow)
5467             return false;
5468         if (m_range.atEnd())
5469             autoColumnsValue = CSSValuePool::singleton().createImplicitInitialValue();
5470         else {
5471             autoColumnsValue = consumeGridTrackList(m_range, m_context.mode, GridAuto);
5472             if (!autoColumnsValue)
5473                 return false;
5474         }
5475         templateColumns = CSSValuePool::singleton().createImplicitInitialValue();
5476         autoRowsValue = CSSValuePool::singleton().createImplicitInitialValue();
5477     }
5478 
5479     if (!m_range.atEnd())
5480         return false;
5481 
5482     // It can only be specified the explicit or the implicit grid properties in a single grid declaration.
5483     // The sub-properties not specified are set to their initial value, as normal for shorthands.
5484     addProperty(CSSPropertyGridTemplateColumns, CSSPropertyGrid, templateColumns.releaseNonNull(), important);
5485     addProperty(CSSPropertyGridTemplateRows, CSSPropertyGrid, templateRows.releaseNonNull(), important);
5486     addProperty(CSSPropertyGridTemplateAreas, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5487     addProperty(CSSPropertyGridAutoFlow, CSSPropertyGrid, gridAutoFlow.releaseNonNull(), important);
5488     addProperty(CSSPropertyGridAutoColumns, CSSPropertyGrid, autoColumnsValue.releaseNonNull(), important);
5489     addProperty(CSSPropertyGridAutoRows, CSSPropertyGrid, autoRowsValue.releaseNonNull(), important);
5490 
5491     return true;
5492 }
5493 
5494 bool CSSPropertyParser::consumePlaceContentShorthand(bool important)
5495 {
5496     ASSERT(shorthandForProperty(CSSPropertyPlaceContent).length() == 2);
5497 
5498     if (m_range.atEnd())
5499         return false;
5500 
5501     CSSParserTokenRange rangeCopy = m_range;
5502     bool isBaseline = isBaselineKeyword(m_range.peek().id());
5503     RefPtr&lt;CSSValue&gt; alignContentValue = consumeContentDistributionOverflowPosition(m_range, isContentPositionKeyword);
5504     if (!alignContentValue)
5505         return false;
5506 
5507     // justify-content property does not allow the &lt;baseline-position&gt; values.
5508     if (m_range.atEnd() &amp;&amp; isBaseline)
5509         return false;
5510     if (isBaselineKeyword(m_range.peek().id()))
5511         return false;
5512 
5513     if (m_range.atEnd())
5514         m_range = rangeCopy;
5515     RefPtr&lt;CSSValue&gt; justifyContentValue = consumeContentDistributionOverflowPosition(m_range, isContentPositionOrLeftOrRightKeyword);
5516     if (!justifyContentValue)
5517         return false;
5518     if (!m_range.atEnd())
5519         return false;
5520 
5521     addProperty(CSSPropertyAlignContent, CSSPropertyPlaceContent, alignContentValue.releaseNonNull(), important);
5522     addProperty(CSSPropertyJustifyContent, CSSPropertyPlaceContent, justifyContentValue.releaseNonNull(), important);
5523     return true;
5524 }
5525 
5526 bool CSSPropertyParser::consumePlaceItemsShorthand(bool important)
5527 {
5528     ASSERT(shorthandForProperty(CSSPropertyPlaceItems).length() == 2);
5529 
5530     CSSParserTokenRange rangeCopy = m_range;
5531     RefPtr&lt;CSSValue&gt; alignItemsValue = consumeAlignItems(m_range);
5532     if (!alignItemsValue)
5533         return false;
5534 
5535     if (m_range.atEnd())
5536         m_range = rangeCopy;
5537     RefPtr&lt;CSSValue&gt; justifyItemsValue = consumeJustifyItems(m_range);
5538     if (!justifyItemsValue)
5539         return false;
5540 
5541     if (!m_range.atEnd())
5542         return false;
5543 
5544     addProperty(CSSPropertyAlignItems, CSSPropertyPlaceItems, alignItemsValue.releaseNonNull(), important);
5545     addProperty(CSSPropertyJustifyItems, CSSPropertyPlaceItems, justifyItemsValue.releaseNonNull(), important);
5546     return true;
5547 }
5548 
5549 bool CSSPropertyParser::consumePlaceSelfShorthand(bool important)
5550 {
5551     ASSERT(shorthandForProperty(CSSPropertyPlaceSelf).length() == 2);
5552 
5553     CSSParserTokenRange rangeCopy = m_range;
5554     RefPtr&lt;CSSValue&gt; alignSelfValue = consumeSelfPositionOverflowPosition(m_range, isSelfPositionKeyword);
5555     if (!alignSelfValue)
5556         return false;
5557 
5558     if (m_range.atEnd())
5559         m_range = rangeCopy;
5560     RefPtr&lt;CSSValue&gt; justifySelfValue = consumeSelfPositionOverflowPosition(m_range, isSelfPositionOrLeftOrRightKeyword);
5561     if (!justifySelfValue)
5562         return false;
5563 
5564     if (!m_range.atEnd())
5565         return false;
5566 
5567     addProperty(CSSPropertyAlignSelf, CSSPropertyPlaceSelf, alignSelfValue.releaseNonNull(), important);
5568     addProperty(CSSPropertyJustifySelf, CSSPropertyPlaceSelf, justifySelfValue.releaseNonNull(), important);
5569     return true;
5570 }
5571 
5572 bool CSSPropertyParser::parseShorthand(CSSPropertyID property, bool important)
5573 {
5574     switch (property) {
5575     case CSSPropertyWebkitMarginCollapse: {
5576         CSSValueID id = m_range.consumeIncludingWhitespace().id();
5577         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginBeforeCollapse, id, m_context))
5578             return false;
5579         addProperty(CSSPropertyWebkitMarginBeforeCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5580         if (m_range.atEnd()) {
5581             addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5582             return true;
5583         }
5584         id = m_range.consumeIncludingWhitespace().id();
5585         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginAfterCollapse, id, m_context))
5586             return false;
5587         addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5588         return true;
5589     }
5590     case CSSPropertyOverflow: {
5591         CSSValueID id = m_range.consumeIncludingWhitespace().id();
5592         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyOverflowY, id, m_context))
5593             return false;
5594         if (!m_range.atEnd())
5595             return false;
5596         RefPtr&lt;CSSValue&gt; overflowYValue = CSSValuePool::singleton().createIdentifierValue(id);
5597         RefPtr&lt;CSSValue&gt; overflowXValue;
5598 
5599         // FIXME: -webkit-paged-x or -webkit-paged-y only apply to overflow-y. If this value has been
5600         // set using the shorthand, then for now overflow-x will default to auto, but once we implement
5601         // pagination controls, it should default to hidden. If the overflow-y value is anything but
5602         // paged-x or paged-y, then overflow-x and overflow-y should have the same value.
5603         if (id == CSSValueWebkitPagedX || id == CSSValueWebkitPagedY)
5604             overflowXValue = CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5605         else
5606             overflowXValue = overflowYValue;
5607         addProperty(CSSPropertyOverflowX, CSSPropertyOverflow, *overflowXValue, important);
5608         addProperty(CSSPropertyOverflowY, CSSPropertyOverflow, *overflowYValue, important);
5609         return true;
5610     }
5611     case CSSPropertyFont: {
5612         const CSSParserToken&amp; token = m_range.peek();
5613         if (token.id() &gt;= CSSValueCaption &amp;&amp; token.id() &lt;= CSSValueStatusBar)
5614             return consumeSystemFont(important);
5615         return consumeFont(important);
5616     }
5617     case CSSPropertyFontVariant:
5618         return consumeFontVariantShorthand(important);
5619     case CSSPropertyBorderSpacing:
5620         return consumeBorderSpacing(important);
5621     case CSSPropertyColumns:
5622         return consumeColumns(important);
5623     case CSSPropertyAnimation:
5624         return consumeAnimationShorthand(animationShorthandForParsing(), important);
5625     case CSSPropertyTransition:
5626         return consumeAnimationShorthand(transitionShorthandForParsing(), important);
5627     case CSSPropertyTextDecoration:
5628     case CSSPropertyWebkitTextDecoration:
5629         // FIXME-NEWPARSER: We need to unprefix -line/-style/-color ASAP and get rid
5630         // of -webkit-text-decoration completely.
5631         return consumeShorthandGreedily(webkitTextDecorationShorthand(), important);
5632     case CSSPropertyInset:
5633         return consume4ValueShorthand(insetShorthand(), important);
5634     case CSSPropertyInsetBlock:
5635         return consume2ValueShorthand(insetBlockShorthand(), important);
5636     case CSSPropertyInsetInline:
5637         return consume2ValueShorthand(insetInlineShorthand(), important);
5638     case CSSPropertyMargin:
5639         return consume4ValueShorthand(marginShorthand(), important);
5640     case CSSPropertyMarginBlock:
5641         return consume2ValueShorthand(marginBlockShorthand(), important);
5642     case CSSPropertyMarginInline:
5643         return consume2ValueShorthand(marginInlineShorthand(), important);
5644     case CSSPropertyPadding:
5645         return consume4ValueShorthand(paddingShorthand(), important);
5646     case CSSPropertyPaddingBlock:
5647         return consume2ValueShorthand(paddingBlockShorthand(), important);
5648     case CSSPropertyPaddingInline:
5649         return consume2ValueShorthand(paddingInlineShorthand(), important);
5650 #if ENABLE(CSS_SCROLL_SNAP)
5651     case CSSPropertyScrollSnapMargin:
5652         return consume4ValueShorthand(scrollSnapMarginShorthand(), important);
5653     case CSSPropertyScrollPadding:
5654         return consume4ValueShorthand(scrollPaddingShorthand(), important);
5655 #endif
5656     case CSSPropertyWebkitTextEmphasis:
5657         return consumeShorthandGreedily(webkitTextEmphasisShorthand(), important);
5658     case CSSPropertyOutline:
5659         return consumeShorthandGreedily(outlineShorthand(), important);
5660     case CSSPropertyBorderInline: {
5661         RefPtr&lt;CSSValue&gt; width;
5662         RefPtr&lt;CSSValue&gt; style;
5663         RefPtr&lt;CSSValue&gt; color;
5664         if (!consumeBorder(width, style, color))
5665             return false;
5666 
5667         addExpandedPropertyForValue(CSSPropertyBorderInlineWidth, width.releaseNonNull(), important);
5668         addExpandedPropertyForValue(CSSPropertyBorderInlineStyle, style.releaseNonNull(), important);
5669         addExpandedPropertyForValue(CSSPropertyBorderInlineColor, color.releaseNonNull(), important);
5670         return true;
5671     }
5672     case CSSPropertyBorderInlineColor:
5673         return consume2ValueShorthand(borderInlineColorShorthand(), important);
5674     case CSSPropertyBorderInlineStyle:
5675         return consume2ValueShorthand(borderInlineStyleShorthand(), important);
5676     case CSSPropertyBorderInlineWidth:
5677         return consume2ValueShorthand(borderInlineWidthShorthand(), important);
5678     case CSSPropertyBorderInlineStart:
5679         return consumeShorthandGreedily(borderInlineStartShorthand(), important);
5680     case CSSPropertyBorderInlineEnd:
5681         return consumeShorthandGreedily(borderInlineEndShorthand(), important);
5682     case CSSPropertyBorderBlock: {
5683         RefPtr&lt;CSSValue&gt; width;
5684         RefPtr&lt;CSSValue&gt; style;
5685         RefPtr&lt;CSSValue&gt; color;
5686         if (!consumeBorder(width, style, color))
5687             return false;
5688 
5689         addExpandedPropertyForValue(CSSPropertyBorderBlockWidth, width.releaseNonNull(), important);
5690         addExpandedPropertyForValue(CSSPropertyBorderBlockStyle, style.releaseNonNull(), important);
5691         addExpandedPropertyForValue(CSSPropertyBorderBlockColor, color.releaseNonNull(), important);
5692         return true;
5693     }
5694     case CSSPropertyBorderBlockColor:
5695         return consume2ValueShorthand(borderBlockColorShorthand(), important);
5696     case CSSPropertyBorderBlockStyle:
5697         return consume2ValueShorthand(borderBlockStyleShorthand(), important);
5698     case CSSPropertyBorderBlockWidth:
5699         return consume2ValueShorthand(borderBlockWidthShorthand(), important);
5700     case CSSPropertyBorderBlockStart:
5701         return consumeShorthandGreedily(borderBlockStartShorthand(), important);
5702     case CSSPropertyBorderBlockEnd:
5703         return consumeShorthandGreedily(borderBlockEndShorthand(), important);
5704     case CSSPropertyWebkitTextStroke:
5705         return consumeShorthandGreedily(webkitTextStrokeShorthand(), important);
5706     case CSSPropertyMarker: {
5707         RefPtr&lt;CSSValue&gt; marker = parseSingleValue(CSSPropertyMarkerStart);
5708         if (!marker || !m_range.atEnd())
5709             return false;
5710         auto markerRef = marker.releaseNonNull();
5711         addProperty(CSSPropertyMarkerStart, CSSPropertyMarker, markerRef.copyRef(), important);
5712         addProperty(CSSPropertyMarkerMid, CSSPropertyMarker, markerRef.copyRef(), important);
5713         addProperty(CSSPropertyMarkerEnd, CSSPropertyMarker, markerRef.copyRef(), important);
5714         return true;
5715     }
5716     case CSSPropertyFlex:
5717         return consumeFlex(important);
5718     case CSSPropertyFlexFlow:
5719         return consumeShorthandGreedily(flexFlowShorthand(), important);
5720     case CSSPropertyColumnRule:
5721         return consumeShorthandGreedily(columnRuleShorthand(), important);
5722     case CSSPropertyListStyle:
5723         return consumeShorthandGreedily(listStyleShorthand(), important);
5724     case CSSPropertyBorderRadius:
5725     case CSSPropertyWebkitBorderRadius: {
5726         RefPtr&lt;CSSPrimitiveValue&gt; horizontalRadii[4];
5727         RefPtr&lt;CSSPrimitiveValue&gt; verticalRadii[4];
5728         if (!consumeRadii(horizontalRadii, verticalRadii, m_range, m_context.mode, property == CSSPropertyWebkitBorderRadius))
5729             return false;
5730         addProperty(CSSPropertyBorderTopLeftRadius, CSSPropertyBorderRadius, createPrimitiveValuePair(horizontalRadii[0].releaseNonNull(), verticalRadii[0].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce), important);
5731         addProperty(CSSPropertyBorderTopRightRadius, CSSPropertyBorderRadius, createPrimitiveValuePair(horizontalRadii[1].releaseNonNull(), verticalRadii[1].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce), important);
5732         addProperty(CSSPropertyBorderBottomRightRadius, CSSPropertyBorderRadius, createPrimitiveValuePair(horizontalRadii[2].releaseNonNull(), verticalRadii[2].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce), important);
5733         addProperty(CSSPropertyBorderBottomLeftRadius, CSSPropertyBorderRadius, createPrimitiveValuePair(horizontalRadii[3].releaseNonNull(), verticalRadii[3].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce), important);
5734         return true;
5735     }
5736     case CSSPropertyBorderColor:
5737         return consume4ValueShorthand(borderColorShorthand(), important);
5738     case CSSPropertyBorderStyle:
5739         return consume4ValueShorthand(borderStyleShorthand(), important);
5740     case CSSPropertyBorderWidth:
5741         return consume4ValueShorthand(borderWidthShorthand(), important);
5742     case CSSPropertyBorderTop:
5743         return consumeShorthandGreedily(borderTopShorthand(), important);
5744     case CSSPropertyBorderRight:
5745         return consumeShorthandGreedily(borderRightShorthand(), important);
5746     case CSSPropertyBorderBottom:
5747         return consumeShorthandGreedily(borderBottomShorthand(), important);
5748     case CSSPropertyBorderLeft:
5749         return consumeShorthandGreedily(borderLeftShorthand(), important);
5750     case CSSPropertyBorder: {
5751         RefPtr&lt;CSSValue&gt; width;
5752         RefPtr&lt;CSSValue&gt; style;
5753         RefPtr&lt;CSSValue&gt; color;
5754         if (!consumeBorder(width, style, color))
5755             return false;
5756 
5757         addExpandedPropertyForValue(CSSPropertyBorderWidth, width.releaseNonNull(), important);
5758         addExpandedPropertyForValue(CSSPropertyBorderStyle, style.releaseNonNull(), important);
5759         addExpandedPropertyForValue(CSSPropertyBorderColor, color.releaseNonNull(), important);
5760         addExpandedPropertyForValue(CSSPropertyBorderImage, CSSValuePool::singleton().createImplicitInitialValue(), important);
5761         return true;
5762     }
5763     case CSSPropertyBorderImage:
5764         return consumeBorderImage(property, important);
5765     case CSSPropertyPageBreakAfter:
5766     case CSSPropertyPageBreakBefore:
5767     case CSSPropertyPageBreakInside:
5768     case CSSPropertyWebkitColumnBreakAfter:
5769     case CSSPropertyWebkitColumnBreakBefore:
5770     case CSSPropertyWebkitColumnBreakInside:
5771         return consumeLegacyBreakProperty(property, important);
5772     case CSSPropertyWebkitMaskPosition:
5773     case CSSPropertyBackgroundPosition: {
5774         RefPtr&lt;CSSValue&gt; resultX;
5775         RefPtr&lt;CSSValue&gt; resultY;
5776         if (!consumeBackgroundPosition(m_range, m_context, UnitlessQuirk::Allow, resultX, resultY) || !m_range.atEnd())
5777             return false;
5778         addProperty(property == CSSPropertyBackgroundPosition ? CSSPropertyBackgroundPositionX : CSSPropertyWebkitMaskPositionX, property, resultX.releaseNonNull(), important);
5779         addProperty(property == CSSPropertyBackgroundPosition ? CSSPropertyBackgroundPositionY : CSSPropertyWebkitMaskPositionY, property, resultY.releaseNonNull(), important);
5780         return true;
5781     }
5782     case CSSPropertyBackgroundRepeat:
5783     case CSSPropertyWebkitMaskRepeat: {
5784         RefPtr&lt;CSSValue&gt; resultX;
5785         RefPtr&lt;CSSValue&gt; resultY;
5786         bool implicit = false;
5787         if (!consumeRepeatStyle(m_range, resultX, resultY, implicit) || !m_range.atEnd())
5788             return false;
5789         addProperty(property == CSSPropertyBackgroundRepeat ? CSSPropertyBackgroundRepeatX : CSSPropertyWebkitMaskRepeatX, property, resultX.releaseNonNull(), important, implicit);
5790         addProperty(property == CSSPropertyBackgroundRepeat ? CSSPropertyBackgroundRepeatY : CSSPropertyWebkitMaskRepeatY, property, resultY.releaseNonNull(), important, implicit);
5791         return true;
5792     }
5793     case CSSPropertyBackground:
5794         return consumeBackgroundShorthand(backgroundShorthand(), important);
5795     case CSSPropertyWebkitMask:
5796         return consumeBackgroundShorthand(webkitMaskShorthand(), important);
5797     case CSSPropertyTransformOrigin:
5798         return consumeTransformOrigin(important);
5799     case CSSPropertyPerspectiveOrigin:
5800         return consumePerspectiveOrigin(important);
5801     case CSSPropertyGap: {
5802         RefPtr&lt;CSSValue&gt; rowGap = consumeGapLength(m_range, m_context.mode);
5803         RefPtr&lt;CSSValue&gt; columnGap = consumeGapLength(m_range, m_context.mode);
5804         if (!rowGap || !m_range.atEnd())
5805             return false;
5806         if (!columnGap)
5807             columnGap = rowGap;
5808         addProperty(CSSPropertyRowGap, CSSPropertyGap, rowGap.releaseNonNull(), important);
5809         addProperty(CSSPropertyColumnGap, CSSPropertyGap, columnGap.releaseNonNull(), important);
5810         return true;
5811     }
5812     case CSSPropertyGridColumn:
5813     case CSSPropertyGridRow:
5814         return consumeGridItemPositionShorthand(property, important);
5815     case CSSPropertyGridArea:
5816         return consumeGridAreaShorthand(important);
5817     case CSSPropertyGridTemplate:
5818         return consumeGridTemplateShorthand(CSSPropertyGridTemplate, important);
5819     case CSSPropertyGrid:
5820         return consumeGridShorthand(important);
5821     case CSSPropertyPlaceContent:
5822         return consumePlaceContentShorthand(important);
5823     case CSSPropertyPlaceItems:
5824         return consumePlaceItemsShorthand(important);
5825     case CSSPropertyPlaceSelf:
5826         return consumePlaceSelfShorthand(important);
5827     case CSSPropertyWebkitMarquee:
5828         return consumeShorthandGreedily(webkitMarqueeShorthand(), important);
5829     default:
5830         return false;
5831     }
5832 }
5833 
5834 } // namespace WebCore
    </pre>
  </body>
</html>