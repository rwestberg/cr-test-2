<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorPageAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;InspectorPageAgent.h&quot;
 34 
 35 #include &quot;CachedResource.h&quot;
 36 #include &quot;CachedResourceLoader.h&quot;
 37 #include &quot;Cookie.h&quot;
 38 #include &quot;CookieJar.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 39 #include &quot;CustomHeaderFields.h&quot;</span>
 40 #include &quot;Document.h&quot;
 41 #include &quot;DocumentLoader.h&quot;
 42 #include &quot;Frame.h&quot;
 43 #include &quot;FrameLoadRequest.h&quot;
 44 #include &quot;FrameLoader.h&quot;
 45 #include &quot;FrameSnapshotting.h&quot;
 46 #include &quot;FrameView.h&quot;
 47 #include &quot;HTMLFrameOwnerElement.h&quot;
 48 #include &quot;HTMLNames.h&quot;
 49 #include &quot;ImageBuffer.h&quot;
 50 #include &quot;InspectorClient.h&quot;
 51 #include &quot;InspectorDOMAgent.h&quot;
 52 #include &quot;InspectorNetworkAgent.h&quot;
 53 #include &quot;InspectorOverlay.h&quot;
 54 #include &quot;InstrumentingAgents.h&quot;
 55 #include &quot;MIMETypeRegistry.h&quot;
 56 #include &quot;MemoryCache.h&quot;
 57 #include &quot;Page.h&quot;
 58 #include &quot;RenderObject.h&quot;
 59 #include &quot;RenderTheme.h&quot;
 60 #include &quot;ScriptController.h&quot;
 61 #include &quot;SecurityOrigin.h&quot;
 62 #include &quot;Settings.h&quot;
 63 #include &quot;StyleScope.h&quot;
 64 #include &quot;TextEncoding.h&quot;
 65 #include &quot;UserGestureIndicator.h&quot;
 66 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
 67 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 68 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 69 #include &lt;wtf/ListHashSet.h&gt;
 70 #include &lt;wtf/Stopwatch.h&gt;
 71 #include &lt;wtf/text/Base64.h&gt;
 72 #include &lt;wtf/text/StringBuilder.h&gt;
 73 
 74 #if ENABLE(APPLICATION_MANIFEST)
 75 #include &quot;CachedApplicationManifest.h&quot;
 76 #endif
 77 
 78 #if ENABLE(WEB_ARCHIVE) &amp;&amp; USE(CF)
 79 #include &quot;LegacyWebArchive.h&quot;
 80 #endif
 81 
 82 
 83 namespace WebCore {
 84 
 85 using namespace Inspector;
 86 
 87 // Keep this in sync with Page.Setting
 88 #define FOR_EACH_INSPECTOR_OVERRIDE_SETTING(macro) \
 89     macro(AuthorAndUserStylesEnabled) \
 90     macro(ICECandidateFilteringEnabled) \
 91     macro(ImagesEnabled) \
 92     macro(MediaCaptureRequiresSecureConnection) \
 93     macro(MockCaptureDevicesEnabled) \
 94     macro(NeedsSiteSpecificQuirks) \
 95     macro(ScriptEnabled) \
<a name="2" id="anc2"></a><span class="line-added"> 96     macro(WebRTCEncryptionEnabled) \</span>
 97     macro(WebSecurityEnabled)
 98 
 99 static bool decodeBuffer(const char* buffer, unsigned size, const String&amp; textEncodingName, String* result)
100 {
101     if (buffer) {
102         TextEncoding encoding(textEncodingName);
103         if (!encoding.isValid())
104             encoding = WindowsLatin1Encoding();
105         *result = encoding.decode(buffer, size);
106         return true;
107     }
108     return false;
109 }
110 
111 bool InspectorPageAgent::mainResourceContent(Frame* frame, bool withBase64Encode, String* result)
112 {
113     RefPtr&lt;SharedBuffer&gt; buffer = frame-&gt;loader().documentLoader()-&gt;mainResourceData();
114     if (!buffer)
115         return false;
116     return InspectorPageAgent::dataContent(buffer-&gt;data(), buffer-&gt;size(), frame-&gt;document()-&gt;encoding(), withBase64Encode, result);
117 }
118 
119 bool InspectorPageAgent::sharedBufferContent(RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, const String&amp; textEncodingName, bool withBase64Encode, String* result)
120 {
121     return dataContent(buffer ? buffer-&gt;data() : nullptr, buffer ? buffer-&gt;size() : 0, textEncodingName, withBase64Encode, result);
122 }
123 
124 bool InspectorPageAgent::dataContent(const char* data, unsigned size, const String&amp; textEncodingName, bool withBase64Encode, String* result)
125 {
126     if (withBase64Encode) {
127         *result = base64Encode(data, size);
128         return true;
129     }
130 
131     return decodeBuffer(data, size, textEncodingName, result);
132 }
133 
<a name="3" id="anc3"></a><span class="line-added">134 Vector&lt;CachedResource*&gt; InspectorPageAgent::cachedResourcesForFrame(Frame* frame)</span>
<span class="line-added">135 {</span>
<span class="line-added">136     Vector&lt;CachedResource*&gt; result;</span>
<span class="line-added">137 </span>
<span class="line-added">138     for (auto&amp; cachedResourceHandle : frame-&gt;document()-&gt;cachedResourceLoader().allCachedResources().values()) {</span>
<span class="line-added">139         auto* cachedResource = cachedResourceHandle.get();</span>
<span class="line-added">140         if (cachedResource-&gt;resourceRequest().hiddenFromInspector())</span>
<span class="line-added">141             continue;</span>
<span class="line-added">142 </span>
<span class="line-added">143         switch (cachedResource-&gt;type()) {</span>
<span class="line-added">144         case CachedResource::Type::ImageResource:</span>
<span class="line-added">145             // Skip images that were not auto loaded (images disabled in the user agent).</span>
<span class="line-added">146 #if ENABLE(SVG_FONTS)</span>
<span class="line-added">147         case CachedResource::Type::SVGFontResource:</span>
<span class="line-added">148 #endif</span>
<span class="line-added">149         case CachedResource::Type::FontResource:</span>
<span class="line-added">150             // Skip fonts that were referenced in CSS but never used/downloaded.</span>
<span class="line-added">151             if (cachedResource-&gt;stillNeedsLoad())</span>
<span class="line-added">152                 continue;</span>
<span class="line-added">153             break;</span>
<span class="line-added">154         default:</span>
<span class="line-added">155             // All other CachedResource types download immediately.</span>
<span class="line-added">156             break;</span>
<span class="line-added">157         }</span>
<span class="line-added">158 </span>
<span class="line-added">159         result.append(cachedResource);</span>
<span class="line-added">160     }</span>
<span class="line-added">161 </span>
<span class="line-added">162     return result;</span>
<span class="line-added">163 }</span>
<span class="line-added">164 </span>
165 void InspectorPageAgent::resourceContent(ErrorString&amp; errorString, Frame* frame, const URL&amp; url, String* result, bool* base64Encoded)
166 {
167     DocumentLoader* loader = assertDocumentLoader(errorString, frame);
168     if (!loader)
169         return;
170 
171     RefPtr&lt;SharedBuffer&gt; buffer;
172     bool success = false;
173     if (equalIgnoringFragmentIdentifier(url, loader-&gt;url())) {
174         *base64Encoded = false;
175         success = mainResourceContent(frame, *base64Encoded, result);
176     }
177 
178     if (!success) {
179         if (auto* resource = cachedResource(frame, url))
180             success = InspectorNetworkAgent::cachedResourceContent(*resource, result, base64Encoded);
181     }
182 
183     if (!success)
<a name="4" id="anc4"></a><span class="line-modified">184         errorString = &quot;Missing resource for given url&quot;_s;</span>
185 }
186 
187 String InspectorPageAgent::sourceMapURLForResource(CachedResource* cachedResource)
188 {
189     if (!cachedResource)
190         return String();
191 
192     // Scripts are handled in a separate path.
193     if (cachedResource-&gt;type() != CachedResource::Type::CSSStyleSheet)
194         return String();
195 
196     String sourceMapHeader = cachedResource-&gt;response().httpHeaderField(HTTPHeaderName::SourceMap);
197     if (!sourceMapHeader.isEmpty())
198         return sourceMapHeader;
199 
200     sourceMapHeader = cachedResource-&gt;response().httpHeaderField(HTTPHeaderName::XSourceMap);
201     if (!sourceMapHeader.isEmpty())
202         return sourceMapHeader;
203 
204     String content;
205     bool base64Encoded;
206     if (InspectorNetworkAgent::cachedResourceContent(*cachedResource, &amp;content, &amp;base64Encoded) &amp;&amp; !base64Encoded)
207         return ContentSearchUtilities::findStylesheetSourceMapURL(content);
208 
209     return String();
210 }
211 
212 CachedResource* InspectorPageAgent::cachedResource(Frame* frame, const URL&amp; url)
213 {
214     if (url.isNull())
215         return nullptr;
216 
217     CachedResource* cachedResource = frame-&gt;document()-&gt;cachedResourceLoader().cachedResource(MemoryCache::removeFragmentIdentifierIfNeeded(url));
218     if (!cachedResource) {
219         ResourceRequest request(url);
220         request.setDomainForCachePartition(frame-&gt;document()-&gt;domainForCachePartition());
221         cachedResource = MemoryCache::singleton().resourceForRequest(request, frame-&gt;page()-&gt;sessionID());
222     }
223 
224     return cachedResource;
225 }
226 
227 Inspector::Protocol::Page::ResourceType InspectorPageAgent::resourceTypeJSON(InspectorPageAgent::ResourceType resourceType)
228 {
229     switch (resourceType) {
230     case DocumentResource:
231         return Inspector::Protocol::Page::ResourceType::Document;
232     case ImageResource:
233         return Inspector::Protocol::Page::ResourceType::Image;
234     case FontResource:
235         return Inspector::Protocol::Page::ResourceType::Font;
<a name="5" id="anc5"></a><span class="line-modified">236     case StyleSheetResource:</span>
<span class="line-modified">237         return Inspector::Protocol::Page::ResourceType::StyleSheet;</span>
238     case ScriptResource:
239         return Inspector::Protocol::Page::ResourceType::Script;
240     case XHRResource:
241         return Inspector::Protocol::Page::ResourceType::XHR;
242     case FetchResource:
243         return Inspector::Protocol::Page::ResourceType::Fetch;
244     case PingResource:
245         return Inspector::Protocol::Page::ResourceType::Ping;
246     case BeaconResource:
247         return Inspector::Protocol::Page::ResourceType::Beacon;
248     case WebSocketResource:
249         return Inspector::Protocol::Page::ResourceType::WebSocket;
250     case OtherResource:
251         return Inspector::Protocol::Page::ResourceType::Other;
252 #if ENABLE(APPLICATION_MANIFEST)
253     case ApplicationManifestResource:
254         break;
255 #endif
256     }
257     return Inspector::Protocol::Page::ResourceType::Other;
258 }
259 
260 InspectorPageAgent::ResourceType InspectorPageAgent::inspectorResourceType(CachedResource::Type type)
261 {
262     switch (type) {
263     case CachedResource::Type::ImageResource:
264         return InspectorPageAgent::ImageResource;
265 #if ENABLE(SVG_FONTS)
266     case CachedResource::Type::SVGFontResource:
267 #endif
268     case CachedResource::Type::FontResource:
269         return InspectorPageAgent::FontResource;
270 #if ENABLE(XSLT)
271     case CachedResource::Type::XSLStyleSheet:
272 #endif
273     case CachedResource::Type::CSSStyleSheet:
<a name="6" id="anc6"></a><span class="line-modified">274         return InspectorPageAgent::StyleSheetResource;</span>
275     case CachedResource::Type::Script:
276         return InspectorPageAgent::ScriptResource;
277     case CachedResource::Type::MainResource:
278         return InspectorPageAgent::DocumentResource;
279     case CachedResource::Type::Beacon:
280         return InspectorPageAgent::BeaconResource;
281 #if ENABLE(APPLICATION_MANIFEST)
282     case CachedResource::Type::ApplicationManifest:
283         return InspectorPageAgent::ApplicationManifestResource;
284 #endif
<a name="7" id="anc7"></a><span class="line-added">285     case CachedResource::Type::Ping:</span>
<span class="line-added">286         return InspectorPageAgent::PingResource;</span>
287     case CachedResource::Type::MediaResource:
288     case CachedResource::Type::Icon:
289     case CachedResource::Type::RawResource:
290     default:
291         return InspectorPageAgent::OtherResource;
292     }
293 }
294 
295 InspectorPageAgent::ResourceType InspectorPageAgent::inspectorResourceType(const CachedResource&amp; cachedResource)
296 {
297     if (cachedResource.type() == CachedResource::Type::RawResource) {
298         switch (cachedResource.resourceRequest().requester()) {
299         case ResourceRequest::Requester::Fetch:
300             return InspectorPageAgent::FetchResource;
301         case ResourceRequest::Requester::Main:
302             return InspectorPageAgent::DocumentResource;
303         default:
304             return InspectorPageAgent::XHRResource;
305         }
306     }
307 
308     return inspectorResourceType(cachedResource.type());
309 }
310 
311 Inspector::Protocol::Page::ResourceType InspectorPageAgent::cachedResourceTypeJSON(const CachedResource&amp; cachedResource)
312 {
313     return resourceTypeJSON(inspectorResourceType(cachedResource));
314 }
315 
<a name="8" id="anc8"></a><span class="line-added">316 Frame* InspectorPageAgent::findFrameWithSecurityOrigin(Page&amp; page, const String&amp; originRawString)</span>
<span class="line-added">317 {</span>
<span class="line-added">318     for (Frame* frame = &amp;page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-added">319         if (frame-&gt;document()-&gt;securityOrigin().toRawString() == originRawString)</span>
<span class="line-added">320             return frame;</span>
<span class="line-added">321     }</span>
<span class="line-added">322     return nullptr;</span>
<span class="line-added">323 }</span>
<span class="line-added">324 </span>
<span class="line-added">325 DocumentLoader* InspectorPageAgent::assertDocumentLoader(ErrorString&amp; errorString, Frame* frame)</span>
<span class="line-added">326 {</span>
<span class="line-added">327     FrameLoader&amp; frameLoader = frame-&gt;loader();</span>
<span class="line-added">328     DocumentLoader* documentLoader = frameLoader.documentLoader();</span>
<span class="line-added">329     if (!documentLoader)</span>
<span class="line-added">330         errorString = &quot;Missing document loader for given frame&quot;_s;</span>
<span class="line-added">331     return documentLoader;</span>
<span class="line-added">332 }</span>
<span class="line-added">333 </span>
334 InspectorPageAgent::InspectorPageAgent(PageAgentContext&amp; context, InspectorClient* client, InspectorOverlay* overlay)
335     : InspectorAgentBase(&quot;Page&quot;_s, context)
<a name="9" id="anc9"></a><span class="line-modified">336     , m_frontendDispatcher(makeUnique&lt;Inspector::PageFrontendDispatcher&gt;(context.frontendRouter))</span>
337     , m_backendDispatcher(Inspector::PageBackendDispatcher::create(context.backendDispatcher, this))
<a name="10" id="anc10"></a><span class="line-modified">338     , m_inspectedPage(context.inspectedPage)</span>
339     , m_client(client)
340     , m_overlay(overlay)
341 {
342 }
343 
<a name="11" id="anc11"></a><span class="line-added">344 InspectorPageAgent::~InspectorPageAgent() = default;</span>
<span class="line-added">345 </span>
346 void InspectorPageAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
347 {
348 }
349 
350 void InspectorPageAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
351 {
352     ErrorString unused;
353     disable(unused);
354 }
355 
<a name="12" id="anc12"></a><span class="line-modified">356 void InspectorPageAgent::enable(ErrorString&amp; errorString)</span>
357 {
<a name="13" id="anc13"></a><span class="line-modified">358     if (m_instrumentingAgents.inspectorPageAgent() == this) {</span>
<span class="line-modified">359         errorString = &quot;Page domain already enabled&quot;_s;</span>
<span class="line-added">360         return;</span>
<span class="line-added">361     }</span>
362 
<a name="14" id="anc14"></a>


363     m_instrumentingAgents.setInspectorPageAgent(this);
364 
365     auto stopwatch = m_environment.executionStopwatch();
366     stopwatch-&gt;reset();
367     stopwatch-&gt;start();
368 
369 #if HAVE(OS_DARK_MODE_SUPPORT)
<a name="15" id="anc15"></a><span class="line-modified">370     defaultAppearanceDidChange(m_inspectedPage.defaultUseDarkAppearance());</span>
371 #endif
372 }
373 
374 void InspectorPageAgent::disable(ErrorString&amp;)
375 {
<a name="16" id="anc16"></a>
376     m_instrumentingAgents.setInspectorPageAgent(nullptr);
377 
378     ErrorString unused;
379     setShowPaintRects(unused, false);
<a name="17" id="anc17"></a><span class="line-added">380     setShowRulers(unused, false);</span>
381     overrideUserAgent(unused, nullptr);
382     setEmulatedMedia(unused, emptyString());
383     setForcedAppearance(unused, emptyString());
384 
385 #define DISABLE_INSPECTOR_OVERRIDE_SETTING(name) \
<a name="18" id="anc18"></a><span class="line-modified">386     m_inspectedPage.settings().set##name##InspectorOverride(WTF::nullopt);</span>
387 
388     FOR_EACH_INSPECTOR_OVERRIDE_SETTING(DISABLE_INSPECTOR_OVERRIDE_SETTING)
389 
390 #undef DISABLE_INSPECTOR_OVERRIDE_SETTING
<a name="19" id="anc19"></a><span class="line-added">391 </span>
<span class="line-added">392     m_client-&gt;setMockCaptureDevicesEnabledOverride(WTF::nullopt);</span>
<span class="line-added">393 }</span>
<span class="line-added">394 </span>
<span class="line-added">395 double InspectorPageAgent::timestamp()</span>
<span class="line-added">396 {</span>
<span class="line-added">397     return m_environment.executionStopwatch()-&gt;elapsedTime().seconds();</span>
398 }
399 
400 void InspectorPageAgent::reload(ErrorString&amp;, const bool* optionalReloadFromOrigin, const bool* optionalRevalidateAllResources)
401 {
402     bool reloadFromOrigin = optionalReloadFromOrigin &amp;&amp; *optionalReloadFromOrigin;
403     bool revalidateAllResources = optionalRevalidateAllResources &amp;&amp; *optionalRevalidateAllResources;
404 
405     OptionSet&lt;ReloadOption&gt; reloadOptions;
406     if (reloadFromOrigin)
407         reloadOptions.add(ReloadOption::FromOrigin);
408     if (!revalidateAllResources)
409         reloadOptions.add(ReloadOption::ExpiredOnly);
410 
<a name="20" id="anc20"></a><span class="line-modified">411     m_inspectedPage.mainFrame().loader().reload(reloadOptions);</span>
412 }
413 
414 void InspectorPageAgent::navigate(ErrorString&amp;, const String&amp; url)
415 {
416     UserGestureIndicator indicator { ProcessingUserGesture };
<a name="21" id="anc21"></a><span class="line-modified">417     Frame&amp; frame = m_inspectedPage.mainFrame();</span>
418 
419     ResourceRequest resourceRequest { frame.document()-&gt;completeURL(url) };
420     FrameLoadRequest frameLoadRequest { *frame.document(), frame.document()-&gt;securityOrigin(), resourceRequest, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::No, NewFrameOpenerPolicy::Allow, ShouldOpenExternalURLsPolicy::ShouldNotAllow, InitiatedByMainFrame::Unknown };
421     frame.loader().changeLocation(WTFMove(frameLoadRequest));
422 }
423 
424 void InspectorPageAgent::overrideUserAgent(ErrorString&amp;, const String* value)
425 {
426     m_userAgentOverride = value ? *value : String();
427 }
428 
<a name="22" id="anc22"></a><span class="line-added">429 static inline Optional&lt;bool&gt; asOptionalBool(const bool* value)</span>
<span class="line-added">430 {</span>
<span class="line-added">431     if (!value)</span>
<span class="line-added">432         return WTF::nullopt;</span>
<span class="line-added">433     return *value;</span>
<span class="line-added">434 }</span>
<span class="line-added">435 </span>
436 void InspectorPageAgent::overrideSetting(ErrorString&amp; errorString, const String&amp; settingString, const bool* value)
437 {
438     if (settingString.isEmpty()) {
<a name="23" id="anc23"></a><span class="line-modified">439         errorString = &quot;settingString is empty&quot;_s;</span>
440         return;
441     }
442 
443     auto setting = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Page::Setting&gt;(settingString);
444     if (!setting) {
<a name="24" id="anc24"></a><span class="line-modified">445         errorString = makeString(&quot;Unknown settingString: &quot;_s, settingString);</span>
446         return;
447     }
448 
<a name="25" id="anc25"></a><span class="line-added">449     auto overrideValue = asOptionalBool(value);</span>
450     switch (setting.value()) {
451 #define CASE_INSPECTOR_OVERRIDE_SETTING(name) \
<a name="26" id="anc26"></a><span class="line-modified">452     case Inspector::Protocol::Page::Setting::name:                              \</span>
<span class="line-modified">453         m_inspectedPage.settings().set##name##InspectorOverride(overrideValue); \</span>
<span class="line-modified">454         break;                                                                  \</span>




455 
456     FOR_EACH_INSPECTOR_OVERRIDE_SETTING(CASE_INSPECTOR_OVERRIDE_SETTING)
457 
458 #undef CASE_INSPECTOR_OVERRIDE_SETTING
459     }
460 
<a name="27" id="anc27"></a><span class="line-modified">461     // Update the UIProcess / client for particular overrides.</span>
<span class="line-added">462     if (setting.value() == Inspector::Protocol::Page::Setting::MockCaptureDevicesEnabled)</span>
<span class="line-added">463         m_client-&gt;setMockCaptureDevicesEnabledOverride(overrideValue);</span>
464 }
465 
466 static Inspector::Protocol::Page::CookieSameSitePolicy cookieSameSitePolicyJSON(Cookie::SameSitePolicy policy)
467 {
468     switch (policy) {
469     case Cookie::SameSitePolicy::None:
470         return Inspector::Protocol::Page::CookieSameSitePolicy::None;
471     case Cookie::SameSitePolicy::Lax:
472         return Inspector::Protocol::Page::CookieSameSitePolicy::Lax;
473     case Cookie::SameSitePolicy::Strict:
474         return Inspector::Protocol::Page::CookieSameSitePolicy::Strict;
475     }
476     ASSERT_NOT_REACHED();
477     return Inspector::Protocol::Page::CookieSameSitePolicy::None;
478 }
479 
480 static Ref&lt;Inspector::Protocol::Page::Cookie&gt; buildObjectForCookie(const Cookie&amp; cookie)
481 {
482     return Inspector::Protocol::Page::Cookie::create()
483         .setName(cookie.name)
484         .setValue(cookie.value)
485         .setDomain(cookie.domain)
486         .setPath(cookie.path)
487         .setExpires(cookie.expires)
488         .setSize((cookie.name.length() + cookie.value.length()))
489         .setHttpOnly(cookie.httpOnly)
490         .setSecure(cookie.secure)
491         .setSession(cookie.session)
492         .setSameSite(cookieSameSitePolicyJSON(cookie.sameSite))
493         .release();
494 }
495 
496 static Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;&gt; buildArrayForCookies(ListHashSet&lt;Cookie&gt;&amp; cookiesList)
497 {
498     auto cookies = JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;::create();
499 
500     for (const auto&amp; cookie : cookiesList)
501         cookies-&gt;addItem(buildObjectForCookie(cookie));
502 
503     return cookies;
504 }
505 
<a name="28" id="anc28"></a>






























506 static Vector&lt;URL&gt; allResourcesURLsForFrame(Frame* frame)
507 {
508     Vector&lt;URL&gt; result;
509 
510     result.append(frame-&gt;loader().documentLoader()-&gt;url());
511 
<a name="29" id="anc29"></a><span class="line-modified">512     for (auto* cachedResource : InspectorPageAgent::cachedResourcesForFrame(frame))</span>
513         result.append(cachedResource-&gt;url());
514 
515     return result;
516 }
517 
518 void InspectorPageAgent::getCookies(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;&gt;&amp; cookies)
519 {
520     // If we can get raw cookies.
521     ListHashSet&lt;Cookie&gt; rawCookiesList;
522 
523     // If we can&#39;t get raw cookies - fall back to String representation
524     StringBuilder stringCookiesList;
525 
526     // Return value to getRawCookies should be the same for every call because
527     // the return value is platform/network backend specific, and the call will
528     // always return the same true/false value.
529     bool rawCookiesImplemented = false;
530 
<a name="30" id="anc30"></a><span class="line-modified">531     for (Frame* frame = &amp;m_inspectedPage.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
532         Document* document = frame-&gt;document();
533         if (!document || !document-&gt;page())
534             continue;
535 
536         for (auto&amp; url : allResourcesURLsForFrame(frame)) {
537             Vector&lt;Cookie&gt; docCookiesList;
538             rawCookiesImplemented = document-&gt;page()-&gt;cookieJar().getRawCookies(*document, URL({ }, url), docCookiesList);
539 
540             if (!rawCookiesImplemented) {
541                 // FIXME: We need duplication checking for the String representation of cookies.
542                 // Exceptions are thrown by cookie() in sandboxed frames. That won&#39;t happen here
543                 // because &quot;document&quot; is the document of the main frame of the page.
544                 stringCookiesList.append(document-&gt;cookie().releaseReturnValue());
545             } else {
546                 for (auto&amp; cookie : docCookiesList)
547                     rawCookiesList.add(cookie);
548             }
549         }
550     }
551 
552     // FIXME: Do not return empty string/empty array. Make returns optional instead. https://bugs.webkit.org/show_bug.cgi?id=80855
553     if (rawCookiesImplemented)
554         cookies = buildArrayForCookies(rawCookiesList);
555     else
556         cookies = JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;::create();
557 }
558 
559 void InspectorPageAgent::deleteCookie(ErrorString&amp;, const String&amp; cookieName, const String&amp; url)
560 {
561     URL parsedURL({ }, url);
<a name="31" id="anc31"></a><span class="line-modified">562     for (Frame* frame = &amp;m_inspectedPage.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
563         if (auto* document = frame-&gt;document()) {
564             if (auto* page = document-&gt;page())
565                 page-&gt;cookieJar().deleteCookie(*document, parsedURL, cookieName);
566         }
567     }
568 }
569 
570 void InspectorPageAgent::getResourceTree(ErrorString&amp;, RefPtr&lt;Inspector::Protocol::Page::FrameResourceTree&gt;&amp; object)
571 {
<a name="32" id="anc32"></a><span class="line-modified">572     object = buildObjectForFrameTree(&amp;m_inspectedPage.mainFrame());</span>
573 }
574 
575 void InspectorPageAgent::getResourceContent(ErrorString&amp; errorString, const String&amp; frameId, const String&amp; url, String* content, bool* base64Encoded)
576 {
577     Frame* frame = assertFrame(errorString, frameId);
578     if (!frame)
579         return;
580 
581     resourceContent(errorString, frame, URL({ }, url), content, base64Encoded);
582 }
583 
584 void InspectorPageAgent::searchInResource(ErrorString&amp; errorString, const String&amp; frameId, const String&amp; url, const String&amp; query, const bool* optionalCaseSensitive, const bool* optionalIsRegex, const String* optionalRequestId, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;&gt;&amp; results)
585 {
586     results = JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;::create();
587 
588     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
589     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
590 
591     if (optionalRequestId) {
592         if (InspectorNetworkAgent* networkAgent = m_instrumentingAgents.inspectorNetworkAgent()) {
593             networkAgent-&gt;searchInRequest(errorString, *optionalRequestId, query, caseSensitive, isRegex, results);
594             return;
595         }
596     }
597 
598     Frame* frame = assertFrame(errorString, frameId);
599     if (!frame)
600         return;
601 
602     DocumentLoader* loader = assertDocumentLoader(errorString, frame);
603     if (!loader)
604         return;
605 
606     URL kurl({ }, url);
607 
608     String content;
609     bool success = false;
610     if (equalIgnoringFragmentIdentifier(kurl, loader-&gt;url()))
611         success = mainResourceContent(frame, false, &amp;content);
612 
613     if (!success) {
614         if (auto* resource = cachedResource(frame, kurl)) {
615             if (auto textContent = InspectorNetworkAgent::textContentForCachedResource(*resource)) {
616                 content = *textContent;
617                 success = true;
618             }
619         }
620     }
621 
622     if (!success)
623         return;
624 
625     results = ContentSearchUtilities::searchInTextByLines(content, query, caseSensitive, isRegex);
626 }
627 
628 static Ref&lt;Inspector::Protocol::Page::SearchResult&gt; buildObjectForSearchResult(const String&amp; frameId, const String&amp; url, int matchesCount)
629 {
630     return Inspector::Protocol::Page::SearchResult::create()
631         .setUrl(url)
632         .setFrameId(frameId)
633         .setMatchesCount(matchesCount)
634         .release();
635 }
636 
637 void InspectorPageAgent::searchInResources(ErrorString&amp;, const String&amp; text, const bool* optionalCaseSensitive, const bool* optionalIsRegex, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;&gt;&amp; result)
638 {
639     result = JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;::create();
640 
641     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
642     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
643     JSC::Yarr::RegularExpression regex = ContentSearchUtilities::createSearchRegex(text, caseSensitive, isRegex);
644 
<a name="33" id="anc33"></a><span class="line-modified">645     for (Frame* frame = &amp;m_inspectedPage.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
646         for (auto* cachedResource : cachedResourcesForFrame(frame)) {
647             if (auto textContent = InspectorNetworkAgent::textContentForCachedResource(*cachedResource)) {
648                 int matchesCount = ContentSearchUtilities::countRegularExpressionMatches(regex, *textContent);
649                 if (matchesCount)
650                     result-&gt;addItem(buildObjectForSearchResult(frameId(frame), cachedResource-&gt;url(), matchesCount));
651             }
652         }
653     }
654 
655     if (InspectorNetworkAgent* networkAgent = m_instrumentingAgents.inspectorNetworkAgent())
656         networkAgent-&gt;searchOtherRequests(regex, result);
657 }
658 
659 void InspectorPageAgent::setShowRulers(ErrorString&amp;, bool showRulers)
660 {
661     m_overlay-&gt;setShowRulers(showRulers);
662 }
663 
664 void InspectorPageAgent::setShowPaintRects(ErrorString&amp;, bool show)
665 {
666     m_showPaintRects = show;
667     m_client-&gt;setShowPaintRects(show);
668 
669     if (m_client-&gt;overridesShowPaintRects())
670         return;
671 
<a name="34" id="anc34"></a><span class="line-modified">672     m_overlay-&gt;setShowPaintRects(show);</span>
673 }
674 
675 void InspectorPageAgent::domContentEventFired()
676 {
677     m_isFirstLayoutAfterOnLoad = true;
678     m_frontendDispatcher-&gt;domContentEventFired(timestamp());
679 }
680 
681 void InspectorPageAgent::loadEventFired()
682 {
683     m_frontendDispatcher-&gt;loadEventFired(timestamp());
684 }
685 
686 void InspectorPageAgent::frameNavigated(Frame&amp; frame)
687 {
688     m_frontendDispatcher-&gt;frameNavigated(buildObjectForFrame(&amp;frame));
689 }
690 
691 void InspectorPageAgent::frameDetached(Frame&amp; frame)
692 {
693     auto identifier = m_frameToIdentifier.take(&amp;frame);
694     if (identifier.isNull())
695         return;
696     m_frontendDispatcher-&gt;frameDetached(identifier);
697     m_identifierToFrame.remove(identifier);
698 }
699 
<a name="35" id="anc35"></a>




700 Frame* InspectorPageAgent::frameForId(const String&amp; frameId)
701 {
702     return frameId.isEmpty() ? nullptr : m_identifierToFrame.get(frameId);
703 }
704 
705 String InspectorPageAgent::frameId(Frame* frame)
706 {
707     if (!frame)
708         return emptyString();
709     return m_frameToIdentifier.ensure(frame, [this, frame] {
710         auto identifier = IdentifiersFactory::createIdentifier();
711         m_identifierToFrame.set(identifier, frame);
712         return identifier;
713     }).iterator-&gt;value;
714 }
715 
<a name="36" id="anc36"></a>




716 String InspectorPageAgent::loaderId(DocumentLoader* loader)
717 {
718     if (!loader)
719         return emptyString();
720     return m_loaderToIdentifier.ensure(loader, [] {
721         return IdentifiersFactory::createIdentifier();
722     }).iterator-&gt;value;
723 }
724 
<a name="37" id="anc37"></a>








725 Frame* InspectorPageAgent::assertFrame(ErrorString&amp; errorString, const String&amp; frameId)
726 {
727     Frame* frame = frameForId(frameId);
728     if (!frame)
<a name="38" id="anc38"></a><span class="line-modified">729         errorString = &quot;Missing frame for given frameId&quot;_s;</span>
730     return frame;
731 }
732 
<a name="39" id="anc39"></a>








733 void InspectorPageAgent::loaderDetachedFromFrame(DocumentLoader&amp; loader)
734 {
735     m_loaderToIdentifier.remove(&amp;loader);
736 }
737 
738 void InspectorPageAgent::frameStartedLoading(Frame&amp; frame)
739 {
740     m_frontendDispatcher-&gt;frameStartedLoading(frameId(&amp;frame));
741 }
742 
743 void InspectorPageAgent::frameStoppedLoading(Frame&amp; frame)
744 {
745     m_frontendDispatcher-&gt;frameStoppedLoading(frameId(&amp;frame));
746 }
747 
748 void InspectorPageAgent::frameScheduledNavigation(Frame&amp; frame, Seconds delay)
749 {
750     m_frontendDispatcher-&gt;frameScheduledNavigation(frameId(&amp;frame), delay.value());
751 }
752 
753 void InspectorPageAgent::frameClearedScheduledNavigation(Frame&amp; frame)
754 {
755     m_frontendDispatcher-&gt;frameClearedScheduledNavigation(frameId(&amp;frame));
756 }
757 
758 void InspectorPageAgent::defaultAppearanceDidChange(bool useDarkAppearance)
759 {
760     m_frontendDispatcher-&gt;defaultAppearanceDidChange(useDarkAppearance ? Inspector::Protocol::Page::Appearance::Dark : Inspector::Protocol::Page::Appearance::Light);
761 }
762 
763 void InspectorPageAgent::didPaint(RenderObject&amp; renderer, const LayoutRect&amp; rect)
764 {
<a name="40" id="anc40"></a><span class="line-modified">765     if (!m_showPaintRects)</span>
766         return;
767 
768     LayoutRect absoluteRect = LayoutRect(renderer.localToAbsoluteQuad(FloatRect(rect)).boundingBox());
769     FrameView* view = renderer.document().view();
770 
771     LayoutRect rootRect = absoluteRect;
772     if (!view-&gt;frame().isMainFrame()) {
773         IntRect rootViewRect = view-&gt;contentsToRootView(snappedIntRect(absoluteRect));
774         rootRect = view-&gt;frame().mainFrame().view()-&gt;rootViewToContents(rootViewRect);
775     }
776 
777     if (m_client-&gt;overridesShowPaintRects()) {
778         m_client-&gt;showPaintRect(rootRect);
779         return;
780     }
781 
782     m_overlay-&gt;showPaintRect(rootRect);
783 }
784 
785 void InspectorPageAgent::didLayout()
786 {
787     bool isFirstLayout = m_isFirstLayoutAfterOnLoad;
788     if (isFirstLayout)
789         m_isFirstLayoutAfterOnLoad = false;
790 
<a name="41" id="anc41"></a>


791     m_overlay-&gt;update();
792 }
793 
794 void InspectorPageAgent::didScroll()
795 {
<a name="42" id="anc42"></a><span class="line-modified">796     m_overlay-&gt;update();</span>

797 }
798 
799 void InspectorPageAgent::didRecalculateStyle()
800 {
<a name="43" id="anc43"></a><span class="line-modified">801     m_overlay-&gt;update();</span>

802 }
803 
804 Ref&lt;Inspector::Protocol::Page::Frame&gt; InspectorPageAgent::buildObjectForFrame(Frame* frame)
805 {
806     ASSERT_ARG(frame, frame);
807 
808     auto frameObject = Inspector::Protocol::Page::Frame::create()
809         .setId(frameId(frame))
810         .setLoaderId(loaderId(frame-&gt;loader().documentLoader()))
811         .setUrl(frame-&gt;document()-&gt;url().string())
812         .setMimeType(frame-&gt;loader().documentLoader()-&gt;responseMIMEType())
813         .setSecurityOrigin(frame-&gt;document()-&gt;securityOrigin().toRawString())
814         .release();
815     if (frame-&gt;tree().parent())
816         frameObject-&gt;setParentId(frameId(frame-&gt;tree().parent()));
817     if (frame-&gt;ownerElement()) {
818         String name = frame-&gt;ownerElement()-&gt;getNameAttribute();
819         if (name.isEmpty())
820             name = frame-&gt;ownerElement()-&gt;attributeWithoutSynchronization(HTMLNames::idAttr);
821         frameObject-&gt;setName(name);
822     }
823 
824     return frameObject;
825 }
826 
827 Ref&lt;Inspector::Protocol::Page::FrameResourceTree&gt; InspectorPageAgent::buildObjectForFrameTree(Frame* frame)
828 {
829     ASSERT_ARG(frame, frame);
830 
831     Ref&lt;Inspector::Protocol::Page::Frame&gt; frameObject = buildObjectForFrame(frame);
832     auto subresources = JSON::ArrayOf&lt;Inspector::Protocol::Page::FrameResource&gt;::create();
833     auto result = Inspector::Protocol::Page::FrameResourceTree::create()
834         .setFrame(WTFMove(frameObject))
835         .setResources(subresources.copyRef())
836         .release();
837 
838     for (auto* cachedResource : cachedResourcesForFrame(frame)) {
839         auto resourceObject = Inspector::Protocol::Page::FrameResource::create()
840             .setUrl(cachedResource-&gt;url())
841             .setType(cachedResourceTypeJSON(*cachedResource))
842             .setMimeType(cachedResource-&gt;response().mimeType())
843             .release();
844         if (cachedResource-&gt;wasCanceled())
845             resourceObject-&gt;setCanceled(true);
846         else if (cachedResource-&gt;status() == CachedResource::LoadError || cachedResource-&gt;status() == CachedResource::DecodeError)
847             resourceObject-&gt;setFailed(true);
848         String sourceMappingURL = InspectorPageAgent::sourceMapURLForResource(cachedResource);
849         if (!sourceMappingURL.isEmpty())
850             resourceObject-&gt;setSourceMapURL(sourceMappingURL);
851         String targetId = cachedResource-&gt;resourceRequest().initiatorIdentifier();
852         if (!targetId.isEmpty())
853             resourceObject-&gt;setTargetId(targetId);
854         subresources-&gt;addItem(WTFMove(resourceObject));
855     }
856 
857     RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::FrameResourceTree&gt;&gt; childrenArray;
858     for (Frame* child = frame-&gt;tree().firstChild(); child; child = child-&gt;tree().nextSibling()) {
859         if (!childrenArray) {
860             childrenArray = JSON::ArrayOf&lt;Inspector::Protocol::Page::FrameResourceTree&gt;::create();
861             result-&gt;setChildFrames(childrenArray);
862         }
863         childrenArray-&gt;addItem(buildObjectForFrameTree(child));
864     }
865     return result;
866 }
867 
868 void InspectorPageAgent::setEmulatedMedia(ErrorString&amp;, const String&amp; media)
869 {
870     if (media == m_emulatedMedia)
871         return;
872 
873     m_emulatedMedia = media;
874 
<a name="44" id="anc44"></a><span class="line-modified">875     m_inspectedPage.updateStyleAfterChangeInEnvironment();</span>
876 
<a name="45" id="anc45"></a><span class="line-modified">877     if (auto* document = m_inspectedPage.mainFrame().document())</span>
878         document-&gt;updateLayout();
879 }
880 
881 void InspectorPageAgent::setForcedAppearance(ErrorString&amp;, const String&amp; appearance)
882 {
883     if (appearance == m_forcedAppearance)
884         return;
885 
886     m_forcedAppearance = appearance;
887 
888     if (appearance == &quot;Light&quot;_s)
<a name="46" id="anc46"></a><span class="line-modified">889         m_inspectedPage.setUseDarkAppearanceOverride(false);</span>
890     else if (appearance == &quot;Dark&quot;_s)
<a name="47" id="anc47"></a><span class="line-modified">891         m_inspectedPage.setUseDarkAppearanceOverride(true);</span>
892     else
<a name="48" id="anc48"></a><span class="line-modified">893         m_inspectedPage.setUseDarkAppearanceOverride(WTF::nullopt);</span>
894 }
895 
896 void InspectorPageAgent::applyUserAgentOverride(String&amp; userAgent)
897 {
898     if (!m_userAgentOverride.isEmpty())
899         userAgent = m_userAgentOverride;
900 }
901 
902 void InspectorPageAgent::applyEmulatedMedia(String&amp; media)
903 {
904     if (!m_emulatedMedia.isEmpty())
905         media = m_emulatedMedia;
906 }
907 
908 void InspectorPageAgent::getCompositingBordersVisible(ErrorString&amp;, bool* outParam)
909 {
<a name="49" id="anc49"></a><span class="line-modified">910     *outParam = m_inspectedPage.settings().showDebugBorders() || m_inspectedPage.settings().showRepaintCounter();</span>
911 }
912 
913 void InspectorPageAgent::setCompositingBordersVisible(ErrorString&amp;, bool visible)
914 {
<a name="50" id="anc50"></a><span class="line-modified">915     m_inspectedPage.settings().setShowDebugBorders(visible);</span>
<span class="line-modified">916     m_inspectedPage.settings().setShowRepaintCounter(visible);</span>
917 }
918 
919 void InspectorPageAgent::snapshotNode(ErrorString&amp; errorString, int nodeId, String* outDataURL)
920 {
<a name="51" id="anc51"></a>

921     InspectorDOMAgent* domAgent = m_instrumentingAgents.inspectorDOMAgent();
922     ASSERT(domAgent);
923     Node* node = domAgent-&gt;assertNode(errorString, nodeId);
924     if (!node)
925         return;
926 
<a name="52" id="anc52"></a><span class="line-modified">927     std::unique_ptr&lt;ImageBuffer&gt; snapshot = WebCore::snapshotNode(m_inspectedPage.mainFrame(), *node);</span>
928     if (!snapshot) {
929         errorString = &quot;Could not capture snapshot&quot;_s;
930         return;
931     }
932 
933     *outDataURL = snapshot-&gt;toDataURL(&quot;image/png&quot;_s, WTF::nullopt, PreserveResolution::Yes);
934 }
935 
936 void InspectorPageAgent::snapshotRect(ErrorString&amp; errorString, int x, int y, int width, int height, const String&amp; coordinateSystem, String* outDataURL)
937 {
<a name="53" id="anc53"></a>

938     SnapshotOptions options = SnapshotOptionsNone;
939     if (coordinateSystem == &quot;Viewport&quot;)
940         options |= SnapshotOptionsInViewCoordinates;
941 
942     IntRect rectangle(x, y, width, height);
<a name="54" id="anc54"></a><span class="line-modified">943     std::unique_ptr&lt;ImageBuffer&gt; snapshot = snapshotFrameRect(m_inspectedPage.mainFrame(), rectangle, options);</span>
944 
945     if (!snapshot) {
946         errorString = &quot;Could not capture snapshot&quot;_s;
947         return;
948     }
949 
950     *outDataURL = snapshot-&gt;toDataURL(&quot;image/png&quot;_s, WTF::nullopt, PreserveResolution::Yes);
951 }
952 
953 void InspectorPageAgent::archive(ErrorString&amp; errorString, String* data)
954 {
955 #if ENABLE(WEB_ARCHIVE) &amp;&amp; USE(CF)
<a name="55" id="anc55"></a><span class="line-modified">956     auto archive = LegacyWebArchive::create(m_inspectedPage.mainFrame());</span>

957     if (!archive) {
958         errorString = &quot;Could not create web archive for main frame&quot;_s;
959         return;
960     }
961 
962     RetainPtr&lt;CFDataRef&gt; buffer = archive-&gt;rawDataRepresentation();
963     *data = base64Encode(CFDataGetBytePtr(buffer.get()), CFDataGetLength(buffer.get()));
964 #else
965     UNUSED_PARAM(data);
<a name="56" id="anc56"></a><span class="line-modified">966     errorString = &quot;Not supported&quot;_s;</span>
967 #endif
968 }
969 
970 } // namespace WebCore
<a name="57" id="anc57"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="57" type="hidden" />
</body>
</html>