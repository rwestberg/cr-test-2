<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/xml/XMLHttpRequest.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 2004-2016 Apple Inc. All rights reserved.
   3  *  Copyright (C) 2005-2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
   4  *  Copyright (C) 2007, 2008 Julien Chaffraix &lt;jchaffraix@webkit.org&gt;
   5  *  Copyright (C) 2008, 2011 Google Inc. All rights reserved.
   6  *  Copyright (C) 2012 Intel Corporation
   7  *
   8  *  This library is free software; you can redistribute it and/or
   9  *  modify it under the terms of the GNU Lesser General Public
  10  *  License as published by the Free Software Foundation; either
  11  *  version 2 of the License, or (at your option) any later version.
  12  *
  13  *  This library is distributed in the hope that it will be useful,
  14  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  *  Lesser General Public License for more details.
  17  *
  18  *  You should have received a copy of the GNU Lesser General Public
  19  *  License along with this library; if not, write to the Free Software
  20  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;XMLHttpRequest.h&quot;
  25 
  26 #include &quot;Blob.h&quot;
  27 #include &quot;CachedResourceRequestInitiators.h&quot;
  28 #include &quot;ContentSecurityPolicy.h&quot;
  29 #include &quot;CrossOriginAccessControl.h&quot;
  30 #include &quot;DOMFormData.h&quot;
  31 #include &quot;DOMWindow.h&quot;
  32 #include &quot;Event.h&quot;
  33 #include &quot;EventNames.h&quot;
  34 #include &quot;File.h&quot;
  35 #include &quot;HTMLDocument.h&quot;
  36 #include &quot;HTTPHeaderNames.h&quot;
  37 #include &quot;HTTPHeaderValues.h&quot;
  38 #include &quot;HTTPParsers.h&quot;
  39 #include &quot;InspectorInstrumentation.h&quot;
  40 #include &quot;JSDOMBinding.h&quot;
  41 #include &quot;JSDOMWindow.h&quot;
  42 #include &quot;MIMETypeRegistry.h&quot;
  43 #include &quot;MemoryCache.h&quot;
  44 #include &quot;ParsedContentType.h&quot;
  45 #include &quot;ResourceError.h&quot;
  46 #include &quot;ResourceRequest.h&quot;
  47 #include &quot;RuntimeApplicationChecks.h&quot;
  48 #include &quot;SecurityOriginPolicy.h&quot;
  49 #include &quot;Settings.h&quot;
  50 #include &quot;SharedBuffer.h&quot;
  51 #include &quot;StringAdaptors.h&quot;
  52 #include &quot;TextResourceDecoder.h&quot;
  53 #include &quot;ThreadableLoader.h&quot;
  54 #include &quot;XMLDocument.h&quot;
  55 #include &quot;XMLHttpRequestProgressEvent.h&quot;
  56 #include &quot;XMLHttpRequestUpload.h&quot;
  57 #include &quot;markup.h&quot;
  58 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
  59 #include &lt;JavaScriptCore/ArrayBufferView.h&gt;
  60 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  61 #include &lt;JavaScriptCore/JSLock.h&gt;
<a name="1" id="anc1"></a><span class="line-added">  62 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
  63 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  64 #include &lt;wtf/StdLibExtras.h&gt;
  65 #include &lt;wtf/text/CString.h&gt;
  66 
  67 namespace WebCore {
  68 
<a name="2" id="anc2"></a><span class="line-added">  69 static const Seconds maximumIntervalForUserGestureForwarding { 10_s };</span>
<span class="line-added">  70 </span>
<span class="line-added">  71 WTF_MAKE_ISO_ALLOCATED_IMPL(XMLHttpRequest);</span>
<span class="line-added">  72 </span>
  73 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, xmlHttpRequestCounter, (&quot;XMLHttpRequest&quot;));
  74 
  75 // Histogram enum to see when we can deprecate xhr.send(ArrayBuffer).
  76 enum XMLHttpRequestSendArrayBufferOrView {
  77     XMLHttpRequestSendArrayBuffer,
  78     XMLHttpRequestSendArrayBufferView,
  79     XMLHttpRequestSendArrayBufferOrViewMax,
  80 };
  81 
<a name="3" id="anc3"></a><span class="line-modified">  82 static void replaceCharsetInMediaTypeIfNeeded(String&amp; mediaType)</span>
  83 {
<a name="4" id="anc4"></a><span class="line-modified">  84     auto parsedContentType = ParsedContentType::create(mediaType);</span>
<span class="line-modified">  85     if (!parsedContentType || parsedContentType-&gt;charset().isEmpty() || equalIgnoringASCIICase(parsedContentType-&gt;charset(), &quot;UTF-8&quot;))</span>




  86         return;
<a name="5" id="anc5"></a>
  87 
<a name="6" id="anc6"></a><span class="line-modified">  88     parsedContentType-&gt;setCharset(&quot;UTF-8&quot;);</span>
<span class="line-modified">  89     mediaType = parsedContentType-&gt;serialize();</span>




  90 }
  91 
  92 static void logConsoleError(ScriptExecutionContext* context, const String&amp; message)
  93 {
  94     if (!context)
  95         return;
  96     // FIXME: It&#39;s not good to report the bad usage without indicating what source line it came from.
  97     // We should pass additional parameters so we can tell the console where the mistake occurred.
  98     context-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, message);
  99 }
 100 
 101 Ref&lt;XMLHttpRequest&gt; XMLHttpRequest::create(ScriptExecutionContext&amp; context)
 102 {
 103     auto xmlHttpRequest = adoptRef(*new XMLHttpRequest(context));
 104     xmlHttpRequest-&gt;suspendIfNeeded();
 105     return xmlHttpRequest;
 106 }
 107 
 108 XMLHttpRequest::XMLHttpRequest(ScriptExecutionContext&amp; context)
 109     : ActiveDOMObject(&amp;context)
 110     , m_async(true)
 111     , m_includeCredentials(false)
 112     , m_sendFlag(false)
 113     , m_createdDocument(false)
 114     , m_error(false)
 115     , m_uploadListenerFlag(false)
 116     , m_uploadComplete(false)
 117     , m_wasAbortedByClient(false)
 118     , m_responseCacheIsValid(false)
 119     , m_dispatchErrorOnResuming(false)
 120     , m_readyState(static_cast&lt;unsigned&gt;(UNSENT))
 121     , m_responseType(static_cast&lt;unsigned&gt;(ResponseType::EmptyString))
 122     , m_progressEventThrottle(this)
 123     , m_resumeTimer(*this, &amp;XMLHttpRequest::resumeTimerFired)
 124     , m_networkErrorTimer(*this, &amp;XMLHttpRequest::networkErrorTimerFired)
 125     , m_timeoutTimer(*this, &amp;XMLHttpRequest::didReachTimeout)
<a name="7" id="anc7"></a><span class="line-added"> 126     , m_maximumIntervalForUserGestureForwarding(maximumIntervalForUserGestureForwarding)</span>
 127 {
 128 #ifndef NDEBUG
 129     xmlHttpRequestCounter.increment();
 130 #endif
 131 }
 132 
 133 XMLHttpRequest::~XMLHttpRequest()
 134 {
 135 #ifndef NDEBUG
 136     xmlHttpRequestCounter.decrement();
 137 #endif
 138 }
 139 
 140 Document* XMLHttpRequest::document() const
 141 {
 142     ASSERT(scriptExecutionContext());
 143     return downcast&lt;Document&gt;(scriptExecutionContext());
 144 }
 145 
 146 SecurityOrigin* XMLHttpRequest::securityOrigin() const
 147 {
 148     return scriptExecutionContext()-&gt;securityOrigin();
 149 }
 150 
<a name="8" id="anc8"></a>










 151 ExceptionOr&lt;OwnedString&gt; XMLHttpRequest::responseText()
 152 {
 153     if (responseType() != ResponseType::EmptyString &amp;&amp; responseType() != ResponseType::Text)
 154         return Exception { InvalidStateError };
 155     return OwnedString { responseTextIgnoringResponseType() };
 156 }
 157 
 158 void XMLHttpRequest::didCacheResponse()
 159 {
 160     ASSERT(doneWithoutErrors());
 161     m_responseCacheIsValid = true;
 162     m_responseBuilder.clear();
 163 }
 164 
 165 ExceptionOr&lt;Document*&gt; XMLHttpRequest::responseXML()
 166 {
 167     ASSERT(scriptExecutionContext()-&gt;isDocument());
 168 
 169     if (responseType() != ResponseType::EmptyString &amp;&amp; responseType() != ResponseType::Document)
 170         return Exception { InvalidStateError };
 171 
 172     if (!doneWithoutErrors())
 173         return nullptr;
 174 
 175     if (!m_createdDocument) {
<a name="9" id="anc9"></a><span class="line-added"> 176         auto&amp; context = *scriptExecutionContext();</span>
<span class="line-added"> 177 </span>
 178         String mimeType = responseMIMEType();
 179         bool isHTML = equalLettersIgnoringASCIICase(mimeType, &quot;text/html&quot;);
 180 
 181         // The W3C spec requires the final MIME type to be some valid XML type, or text/html.
 182         // If it is text/html, then the responseType of &quot;document&quot; must have been supplied explicitly.
 183         if ((m_response.isHTTP() &amp;&amp; !responseIsXML() &amp;&amp; !isHTML)
 184             || (isHTML &amp;&amp; responseType() == ResponseType::EmptyString)) {
 185             m_responseDocument = nullptr;
 186         } else {
 187             if (isHTML)
<a name="10" id="anc10"></a><span class="line-modified"> 188                 m_responseDocument = HTMLDocument::create(context.sessionID(), nullptr, m_url);</span>
 189             else
<a name="11" id="anc11"></a><span class="line-modified"> 190                 m_responseDocument = XMLDocument::create(context.sessionID(), nullptr, m_url);</span>
 191             m_responseDocument-&gt;overrideLastModified(m_response.lastModified());
 192             m_responseDocument-&gt;setContent(m_responseBuilder.toStringPreserveCapacity());
<a name="12" id="anc12"></a><span class="line-modified"> 193             m_responseDocument-&gt;setContextDocument(downcast&lt;Document&gt;(context));</span>
<span class="line-modified"> 194             m_responseDocument-&gt;setSecurityOriginPolicy(context.securityOriginPolicy());</span>
 195             m_responseDocument-&gt;overrideMIMEType(mimeType);
 196 
 197             if (!m_responseDocument-&gt;wellFormed())
 198                 m_responseDocument = nullptr;
 199         }
 200         m_createdDocument = true;
 201     }
 202 
 203     return m_responseDocument.get();
 204 }
 205 
 206 Ref&lt;Blob&gt; XMLHttpRequest::createResponseBlob()
 207 {
 208     ASSERT(responseType() == ResponseType::Blob);
 209     ASSERT(doneWithoutErrors());
 210 
 211     // FIXME: We just received the data from NetworkProcess, and are sending it back. This is inefficient.
 212     Vector&lt;uint8_t&gt; data;
 213     if (m_binaryResponseBuilder)
 214         data.append(m_binaryResponseBuilder-&gt;data(), m_binaryResponseBuilder-&gt;size());
 215     m_binaryResponseBuilder = nullptr;
 216     String normalizedContentType = Blob::normalizedContentType(responseMIMEType()); // responseMIMEType defaults to text/xml which may be incorrect.
<a name="13" id="anc13"></a><span class="line-modified"> 217     return Blob::create(scriptExecutionContext()-&gt;sessionID(), WTFMove(data), normalizedContentType);</span>
 218 }
 219 
 220 RefPtr&lt;ArrayBuffer&gt; XMLHttpRequest::createResponseArrayBuffer()
 221 {
 222     ASSERT(responseType() == ResponseType::Arraybuffer);
 223     ASSERT(doneWithoutErrors());
 224 
 225     auto result = m_binaryResponseBuilder ? m_binaryResponseBuilder-&gt;tryCreateArrayBuffer() : ArrayBuffer::create(nullptr, 0);
 226     m_binaryResponseBuilder = nullptr;
 227     return result;
 228 }
 229 
 230 ExceptionOr&lt;void&gt; XMLHttpRequest::setTimeout(unsigned timeout)
 231 {
 232     if (scriptExecutionContext()-&gt;isDocument() &amp;&amp; !m_async) {
 233         logConsoleError(scriptExecutionContext(), &quot;XMLHttpRequest.timeout cannot be set for synchronous HTTP(S) requests made from the window context.&quot;);
 234         return Exception { InvalidAccessError };
 235     }
 236     m_timeoutMilliseconds = timeout;
 237     if (!m_timeoutTimer.isActive())
 238         return { };
 239 
 240     // If timeout is zero, we should use the default network timeout. But we disabled it so let&#39;s mimic it with a 60 seconds timeout value.
 241     Seconds interval = Seconds { m_timeoutMilliseconds ? m_timeoutMilliseconds / 1000. : 60. } - (MonotonicTime::now() - m_sendingTime);
 242     m_timeoutTimer.startOneShot(std::max(interval, 0_s));
 243     return { };
 244 }
 245 
 246 ExceptionOr&lt;void&gt; XMLHttpRequest::setResponseType(ResponseType type)
 247 {
 248     if (!scriptExecutionContext()-&gt;isDocument() &amp;&amp; type == ResponseType::Document)
 249         return { };
 250 
 251     if (readyState() &gt;= LOADING)
 252         return Exception { InvalidStateError };
 253 
 254     // Newer functionality is not available to synchronous requests in window contexts, as a spec-mandated
 255     // attempt to discourage synchronous XHR use. responseType is one such piece of functionality.
 256     // We&#39;ll only disable this functionality for HTTP(S) requests since sync requests for local protocols
 257     // such as file: and data: still make sense to allow.
 258     if (!m_async &amp;&amp; scriptExecutionContext()-&gt;isDocument() &amp;&amp; m_url.protocolIsInHTTPFamily()) {
 259         logConsoleError(scriptExecutionContext(), &quot;XMLHttpRequest.responseType cannot be changed for synchronous HTTP(S) requests made from the window context.&quot;);
 260         return Exception { InvalidAccessError };
 261     }
 262 
 263     m_responseType = static_cast&lt;unsigned&gt;(type);
 264     return { };
 265 }
 266 
 267 String XMLHttpRequest::responseURL() const
 268 {
 269     URL responseURL(m_response.url());
 270     responseURL.removeFragmentIdentifier();
 271 
 272     return responseURL.string();
 273 }
 274 
 275 XMLHttpRequestUpload&amp; XMLHttpRequest::upload()
 276 {
 277     if (!m_upload)
<a name="14" id="anc14"></a><span class="line-modified"> 278         m_upload = makeUnique&lt;XMLHttpRequestUpload&gt;(*this);</span>
 279     return *m_upload;
 280 }
 281 
 282 void XMLHttpRequest::changeState(State newState)
 283 {
 284     if (readyState() != newState) {
 285         m_readyState = static_cast&lt;State&gt;(newState);
 286         if (readyState() == DONE) {
 287             // The XHR object itself holds on to the responseText, and
 288             // thus has extra cost even independent of any
 289             // responseText or responseXML objects it has handed
 290             // out. But it is protected from GC while loading, so this
 291             // can&#39;t be recouped until the load is done, so only
 292             // report the extra cost at that point.
 293             if (auto* context = scriptExecutionContext()) {
 294                 JSC::VM&amp; vm = context-&gt;vm();
 295                 JSC::JSLockHolder lock(vm);
 296                 vm.heap.reportExtraMemoryAllocated(memoryCost());
 297             }
 298         }
 299         callReadyStateChangeListener();
 300     }
 301 }
 302 
 303 void XMLHttpRequest::callReadyStateChangeListener()
 304 {
 305     if (!scriptExecutionContext())
 306         return;
 307 
 308     // Check whether sending load and loadend events before sending readystatechange event, as it may change m_error/m_readyState values.
 309     bool shouldSendLoadEvent = (readyState() == DONE &amp;&amp; !m_error);
 310 
 311     if (m_async || (readyState() &lt;= OPENED || readyState() == DONE)) {
 312         m_progressEventThrottle.dispatchReadyStateChangeEvent(Event::create(eventNames().readystatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No),
 313             readyState() == DONE ? FlushProgressEvent : DoNotFlushProgressEvent);
 314     }
 315 
 316     if (shouldSendLoadEvent) {
 317         m_progressEventThrottle.dispatchProgressEvent(eventNames().loadEvent);
 318         m_progressEventThrottle.dispatchProgressEvent(eventNames().loadendEvent);
 319     }
 320 }
 321 
 322 ExceptionOr&lt;void&gt; XMLHttpRequest::setWithCredentials(bool value)
 323 {
 324     if (readyState() &gt; OPENED || m_sendFlag)
 325         return Exception { InvalidStateError };
 326 
 327     m_includeCredentials = value;
 328     return { };
 329 }
 330 
 331 ExceptionOr&lt;void&gt; XMLHttpRequest::open(const String&amp; method, const String&amp; url)
 332 {
 333     // If the async argument is omitted, set async to true.
 334     return open(method, scriptExecutionContext()-&gt;completeURL(url), true);
 335 }
 336 
 337 ExceptionOr&lt;void&gt; XMLHttpRequest::open(const String&amp; method, const URL&amp; url, bool async)
 338 {
 339     if (!isValidHTTPToken(method))
 340         return Exception { SyntaxError };
 341 
 342     if (isForbiddenMethod(method))
 343         return Exception { SecurityError };
 344 
 345     if (!url.isValid())
 346         return Exception { SyntaxError };
 347 
 348     if (!async &amp;&amp; scriptExecutionContext()-&gt;isDocument()) {
 349         // Newer functionality is not available to synchronous requests in window contexts, as a spec-mandated
 350         // attempt to discourage synchronous XHR use. responseType is one such piece of functionality.
 351         // We&#39;ll only disable this functionality for HTTP(S) requests since sync requests for local protocols
 352         // such as file: and data: still make sense to allow.
 353         if (url.protocolIsInHTTPFamily() &amp;&amp; responseType() != ResponseType::EmptyString) {
 354             logConsoleError(scriptExecutionContext(), &quot;Synchronous HTTP(S) requests made from the window context cannot have XMLHttpRequest.responseType set.&quot;);
 355             return Exception { InvalidAccessError };
 356         }
 357 
 358         // Similarly, timeouts are disabled for synchronous requests as well.
 359         if (m_timeoutMilliseconds &gt; 0) {
 360             logConsoleError(scriptExecutionContext(), &quot;Synchronous XMLHttpRequests must not have a timeout value set.&quot;);
 361             return Exception { InvalidAccessError };
 362         }
 363     }
 364 
 365     if (!internalAbort())
 366         return { };
 367 
 368     m_sendFlag = false;
 369     m_uploadListenerFlag = false;
 370     m_method = normalizeHTTPMethod(method);
 371     m_error = false;
 372     m_uploadComplete = false;
 373     m_wasAbortedByClient = false;
 374 
 375     // clear stuff from possible previous load
 376     clearResponse();
 377     clearRequest();
 378 
 379     m_url = url;
 380     scriptExecutionContext()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(m_url, ContentSecurityPolicy::InsecureRequestType::Load);
 381 
 382     m_async = async;
 383 
 384     ASSERT(!m_loader);
 385 
 386     changeState(OPENED);
 387 
 388     return { };
 389 }
 390 
 391 ExceptionOr&lt;void&gt; XMLHttpRequest::open(const String&amp; method, const String&amp; url, bool async, const String&amp; user, const String&amp; password)
 392 {
 393     URL urlWithCredentials = scriptExecutionContext()-&gt;completeURL(url);
 394     if (!user.isNull())
 395         urlWithCredentials.setUser(user);
 396     if (!password.isNull())
 397         urlWithCredentials.setPass(password);
 398 
 399     return open(method, urlWithCredentials, async);
 400 }
 401 
 402 Optional&lt;ExceptionOr&lt;void&gt;&gt; XMLHttpRequest::prepareToSend()
 403 {
 404     // A return value other than WTF::nullopt means we should not try to send, and we should return that value to the caller.
 405     // WTF::nullopt means we are ready to send and should continue with the send algorithm.
 406 
 407     if (!scriptExecutionContext())
 408         return ExceptionOr&lt;void&gt; { };
 409 
 410     auto&amp; context = *scriptExecutionContext();
 411 
 412     if (readyState() != OPENED || m_sendFlag)
 413         return ExceptionOr&lt;void&gt; { Exception { InvalidStateError } };
 414     ASSERT(!m_loader);
 415 
 416     // FIXME: Convert this to check the isolated world&#39;s Content Security Policy once webkit.org/b/104520 is solved.
 417     if (!context.shouldBypassMainWorldContentSecurityPolicy() &amp;&amp; !context.contentSecurityPolicy()-&gt;allowConnectToSource(m_url)) {
 418         if (!m_async)
 419             return ExceptionOr&lt;void&gt; { Exception { NetworkError } };
 420         setPendingActivity(*this);
 421         m_timeoutTimer.stop();
 422         m_networkErrorTimer.startOneShot(0_s);
 423         return ExceptionOr&lt;void&gt; { };
 424     }
 425 
 426     m_error = false;
 427     return WTF::nullopt;
 428 }
 429 
 430 ExceptionOr&lt;void&gt; XMLHttpRequest::send(Optional&lt;SendTypes&gt;&amp;&amp; sendType)
 431 {
 432     InspectorInstrumentation::willSendXMLHttpRequest(scriptExecutionContext(), url());
<a name="15" id="anc15"></a><span class="line-added"> 433     m_userGestureToken = UserGestureIndicator::currentUserGesture();</span>
 434 
 435     ExceptionOr&lt;void&gt; result;
 436     if (!sendType)
 437         result = send();
 438     else {
 439         result = WTF::switchOn(sendType.value(),
 440             [this] (const RefPtr&lt;Document&gt;&amp; document) -&gt; ExceptionOr&lt;void&gt; { return send(*document); },
 441             [this] (const RefPtr&lt;Blob&gt;&amp; blob) -&gt; ExceptionOr&lt;void&gt; { return send(*blob); },
 442             [this] (const RefPtr&lt;JSC::ArrayBufferView&gt;&amp; arrayBufferView) -&gt; ExceptionOr&lt;void&gt; { return send(*arrayBufferView); },
 443             [this] (const RefPtr&lt;JSC::ArrayBuffer&gt;&amp; arrayBuffer) -&gt; ExceptionOr&lt;void&gt; { return send(*arrayBuffer); },
 444             [this] (const RefPtr&lt;DOMFormData&gt;&amp; formData) -&gt; ExceptionOr&lt;void&gt; { return send(*formData); },
 445             [this] (const String&amp; string) -&gt; ExceptionOr&lt;void&gt; { return send(string); }
 446         );
 447     }
 448 
 449     return result;
 450 }
 451 
 452 ExceptionOr&lt;void&gt; XMLHttpRequest::send(Document&amp; document)
 453 {
 454     if (auto result = prepareToSend())
 455         return WTFMove(result.value());
 456 
<a name="16" id="anc16"></a><span class="line-modified"> 457     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {</span>
 458         if (!m_requestHeaders.contains(HTTPHeaderName::ContentType)) {
<a name="17" id="anc17"></a><span class="line-modified"> 459             // FIXME: this should include the charset used for encoding.</span>
<span class="line-modified"> 460             m_requestHeaders.set(HTTPHeaderName::ContentType, document.isHTMLDocument() ? &quot;text/html;charset=UTF-8&quot;_s : &quot;application/xml;charset=UTF-8&quot;_s);</span>





 461         } else {
 462             String contentType = m_requestHeaders.get(HTTPHeaderName::ContentType);
<a name="18" id="anc18"></a><span class="line-modified"> 463             replaceCharsetInMediaTypeIfNeeded(contentType);</span>
 464             m_requestHeaders.set(HTTPHeaderName::ContentType, contentType);
 465         }
 466 
 467         // FIXME: According to XMLHttpRequest Level 2, this should use the Document.innerHTML algorithm
 468         // from the HTML5 specification to serialize the document.
 469         m_requestEntityBody = FormData::create(UTF8Encoding().encode(serializeFragment(document, SerializedNodes::SubtreeIncludingNode), UnencodableHandling::Entities));
 470         if (m_upload)
 471             m_requestEntityBody-&gt;setAlwaysStream(true);
 472     }
 473 
 474     return createRequest();
 475 }
 476 
 477 ExceptionOr&lt;void&gt; XMLHttpRequest::send(const String&amp; body)
 478 {
 479     if (auto result = prepareToSend())
 480         return WTFMove(result.value());
 481 
<a name="19" id="anc19"></a><span class="line-modified"> 482     if (!body.isNull() &amp;&amp; m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {</span>
 483         String contentType = m_requestHeaders.get(HTTPHeaderName::ContentType);
 484         if (contentType.isNull()) {
<a name="20" id="anc20"></a><span class="line-modified"> 485             m_requestHeaders.set(HTTPHeaderName::ContentType, HTTPHeaderValues::textPlainContentType());</span>





 486         } else {
<a name="21" id="anc21"></a><span class="line-modified"> 487             replaceCharsetInMediaTypeIfNeeded(contentType);</span>
 488             m_requestHeaders.set(HTTPHeaderName::ContentType, contentType);
 489         }
 490 
 491         m_requestEntityBody = FormData::create(UTF8Encoding().encode(body, UnencodableHandling::Entities));
 492         if (m_upload)
 493             m_requestEntityBody-&gt;setAlwaysStream(true);
 494     }
 495 
 496     return createRequest();
 497 }
 498 
 499 ExceptionOr&lt;void&gt; XMLHttpRequest::send(Blob&amp; body)
 500 {
 501     if (auto result = prepareToSend())
 502         return WTFMove(result.value());
 503 
<a name="22" id="anc22"></a><span class="line-modified"> 504     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {</span>
<span class="line-added"> 505         if (!m_url.protocolIsInHTTPFamily()) {</span>
<span class="line-added"> 506             // FIXME: We would like to support posting Blobs to non-http URLs (e.g. custom URL schemes)</span>
<span class="line-added"> 507             // but because of the architecture of blob-handling that will require a fair amount of work.</span>
<span class="line-added"> 508 </span>
<span class="line-added"> 509             ASCIILiteral consoleMessage { &quot;POST of a Blob to non-HTTP protocols in XMLHttpRequest.send() is currently unsupported.&quot;_s };</span>
<span class="line-added"> 510             scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, consoleMessage);</span>
<span class="line-added"> 511 </span>
<span class="line-added"> 512             return createRequest();</span>
<span class="line-added"> 513         }</span>
<span class="line-added"> 514 </span>
 515         if (!m_requestHeaders.contains(HTTPHeaderName::ContentType)) {
 516             const String&amp; blobType = body.type();
 517             if (!blobType.isEmpty() &amp;&amp; isValidContentType(blobType))
 518                 m_requestHeaders.set(HTTPHeaderName::ContentType, blobType);
 519             else {
 520                 // From FileAPI spec, whenever media type cannot be determined, empty string must be returned.
 521                 m_requestHeaders.set(HTTPHeaderName::ContentType, emptyString());
 522             }
 523         }
 524 
 525         m_requestEntityBody = FormData::create();
 526         m_requestEntityBody-&gt;appendBlob(body.url());
 527     }
 528 
 529     return createRequest();
 530 }
 531 
 532 ExceptionOr&lt;void&gt; XMLHttpRequest::send(DOMFormData&amp; body)
 533 {
 534     if (auto result = prepareToSend())
 535         return WTFMove(result.value());
 536 
<a name="23" id="anc23"></a><span class="line-modified"> 537     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {</span>
<span class="line-modified"> 538         m_requestEntityBody = FormData::createMultiPart(body);</span>

 539         if (!m_requestHeaders.contains(HTTPHeaderName::ContentType))
 540             m_requestHeaders.set(HTTPHeaderName::ContentType, makeString(&quot;multipart/form-data; boundary=&quot;, m_requestEntityBody-&gt;boundary().data()));
 541     }
 542 
 543     return createRequest();
 544 }
 545 
 546 ExceptionOr&lt;void&gt; XMLHttpRequest::send(ArrayBuffer&amp; body)
 547 {
 548     ASCIILiteral consoleMessage { &quot;ArrayBuffer is deprecated in XMLHttpRequest.send(). Use ArrayBufferView instead.&quot;_s };
 549     scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, consoleMessage);
 550     return sendBytesData(body.data(), body.byteLength());
 551 }
 552 
 553 ExceptionOr&lt;void&gt; XMLHttpRequest::send(ArrayBufferView&amp; body)
 554 {
 555     return sendBytesData(body.baseAddress(), body.byteLength());
 556 }
 557 
 558 ExceptionOr&lt;void&gt; XMLHttpRequest::sendBytesData(const void* data, size_t length)
 559 {
 560     if (auto result = prepareToSend())
 561         return WTFMove(result.value());
 562 
<a name="24" id="anc24"></a><span class="line-modified"> 563     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {</span>
 564         m_requestEntityBody = FormData::create(data, length);
 565         if (m_upload)
 566             m_requestEntityBody-&gt;setAlwaysStream(true);
 567     }
 568 
 569     return createRequest();
 570 }
 571 
 572 ExceptionOr&lt;void&gt; XMLHttpRequest::createRequest()
 573 {
 574     // Only GET request is supported for blob URL.
 575     if (!m_async &amp;&amp; m_url.protocolIsBlob() &amp;&amp; m_method != &quot;GET&quot;)
 576         return Exception { NetworkError };
 577 
 578     if (m_async &amp;&amp; m_upload &amp;&amp; m_upload-&gt;hasEventListeners())
 579         m_uploadListenerFlag = true;
 580 
 581     ResourceRequest request(m_url);
 582     request.setRequester(ResourceRequest::Requester::XHR);
 583     request.setInitiatorIdentifier(scriptExecutionContext()-&gt;resourceRequestIdentifier());
 584     request.setHTTPMethod(m_method);
 585 
 586     if (m_requestEntityBody) {
 587         ASSERT(m_method != &quot;GET&quot;);
 588         ASSERT(m_method != &quot;HEAD&quot;);
 589         request.setHTTPBody(WTFMove(m_requestEntityBody));
 590     }
 591 
 592     if (!m_requestHeaders.isEmpty())
 593         request.setHTTPHeaderFields(m_requestHeaders);
 594 
 595     ThreadableLoaderOptions options;
 596     options.sendLoadCallbacks = SendCallbackPolicy::SendCallbacks;
 597     // The presence of upload event listeners forces us to use preflighting because POSTing to an URL that does not
 598     // permit cross origin requests should look exactly like POSTing to an URL that does not respond at all.
 599     options.preflightPolicy = m_uploadListenerFlag ? PreflightPolicy::Force : PreflightPolicy::Consider;
 600     options.credentials = m_includeCredentials ? FetchOptions::Credentials::Include : FetchOptions::Credentials::SameOrigin;
 601     options.mode = FetchOptions::Mode::Cors;
 602     options.contentSecurityPolicyEnforcement = scriptExecutionContext()-&gt;shouldBypassMainWorldContentSecurityPolicy() ? ContentSecurityPolicyEnforcement::DoNotEnforce : ContentSecurityPolicyEnforcement::EnforceConnectSrcDirective;
 603     options.initiator = cachedResourceRequestInitiators().xmlhttprequest;
 604     options.sameOriginDataURLFlag = SameOriginDataURLFlag::Set;
 605     options.filteringPolicy = ResponseFilteringPolicy::Enable;
 606     options.sniffContentEncoding = ContentEncodingSniffingPolicy::DoNotSniff;
 607 
 608     if (m_timeoutMilliseconds) {
 609         if (!m_async)
 610             request.setTimeoutInterval(m_timeoutMilliseconds / 1000.0);
 611         else {
 612             request.setTimeoutInterval(std::numeric_limits&lt;double&gt;::infinity());
 613             m_sendingTime = MonotonicTime::now();
 614             m_timeoutTimer.startOneShot(1_ms * m_timeoutMilliseconds);
 615         }
 616     }
 617 
 618     m_exceptionCode = WTF::nullopt;
 619     m_error = false;
 620     m_uploadComplete = !request.httpBody();
 621     m_sendFlag = true;
 622 
 623     if (m_async) {
 624         m_progressEventThrottle.dispatchProgressEvent(eventNames().loadstartEvent);
 625         if (!m_uploadComplete &amp;&amp; m_uploadListenerFlag)
<a name="25" id="anc25"></a><span class="line-modified"> 626             m_upload-&gt;dispatchProgressEvent(eventNames().loadstartEvent, 0, request.httpBody()-&gt;lengthInBytes(scriptExecutionContext()-&gt;sessionID()));</span>
 627 
 628         if (readyState() != OPENED || !m_sendFlag || m_loader)
 629             return { };
 630 
 631         // ThreadableLoader::create can return null here, for example if we&#39;re no longer attached to a page or if a content blocker blocks the load.
 632         // This is true while running onunload handlers.
 633         // FIXME: Maybe we need to be able to send XMLHttpRequests from onunload, &lt;http://bugs.webkit.org/show_bug.cgi?id=10904&gt;.
 634         m_loader = ThreadableLoader::create(*scriptExecutionContext(), *this, WTFMove(request), options);
 635 
 636         // Either loader is null or some error was synchronously sent to us.
 637         ASSERT(m_loader || !m_sendFlag);
 638 
 639         // Neither this object nor the JavaScript wrapper should be deleted while
 640         // a request is in progress because we need to keep the listeners alive,
 641         // and they are referenced by the JavaScript wrapper.
 642         if (m_loader)
 643             setPendingActivity(*this);
 644     } else {
 645         request.setDomainForCachePartition(scriptExecutionContext()-&gt;domainForCachePartition());
 646         InspectorInstrumentation::willLoadXHRSynchronously(scriptExecutionContext());
 647         ThreadableLoader::loadResourceSynchronously(*scriptExecutionContext(), WTFMove(request), *this, options);
 648         InspectorInstrumentation::didLoadXHRSynchronously(scriptExecutionContext());
 649     }
 650 
 651     if (m_exceptionCode)
 652         return Exception { m_exceptionCode.value() };
 653     if (m_error)
 654         return Exception { NetworkError };
 655     return { };
 656 }
 657 
 658 void XMLHttpRequest::abort()
 659 {
 660     // internalAbort() calls unsetPendingActivity(this), which may release the last reference.
 661     Ref&lt;XMLHttpRequest&gt; protectedThis(*this);
 662 
 663     m_wasAbortedByClient = true;
 664     if (!internalAbort())
 665         return;
 666 
 667     clearResponseBuffers();
 668 
 669     m_requestHeaders.clear();
 670     if ((readyState() == OPENED &amp;&amp; m_sendFlag) || readyState() == HEADERS_RECEIVED || readyState() == LOADING) {
 671         ASSERT(!m_loader);
 672         m_sendFlag = false;
 673         changeState(DONE);
 674         dispatchErrorEvents(eventNames().abortEvent);
 675     }
 676     if (readyState() == DONE)
 677         m_readyState = static_cast&lt;State&gt;(UNSENT);
 678 }
 679 
 680 bool XMLHttpRequest::internalAbort()
 681 {
 682     m_error = true;
 683 
 684     // FIXME: when we add the support for multi-part XHR, we will have to think be careful with this initialization.
 685     m_receivedLength = 0;
 686 
 687     m_decoder = nullptr;
 688 
 689     m_timeoutTimer.stop();
 690 
 691     if (!m_loader)
 692         return true;
 693 
 694     // Cancelling m_loader may trigger a window.onload callback which can call open() on the same xhr.
 695     // This would create internalAbort reentrant call.
 696     // m_loader is set to null before being cancelled to exit early in any reentrant internalAbort() call.
 697     auto loader = WTFMove(m_loader);
 698     loader-&gt;cancel();
 699 
 700     // If window.onload callback calls open() and send() on the same xhr, m_loader is now set to a new value.
 701     // The function calling internalAbort() should abort to let the open() and send() calls continue properly.
 702     // We ask the function calling internalAbort() to exit by returning false.
 703     // Save this information to a local variable since we are going to drop protection.
 704     bool newLoadStarted = m_loader;
 705 
 706     unsetPendingActivity(*this);
 707 
 708     return !newLoadStarted;
 709 }
 710 
 711 void XMLHttpRequest::clearResponse()
 712 {
 713     m_response = ResourceResponse();
 714     clearResponseBuffers();
 715 }
 716 
 717 void XMLHttpRequest::clearResponseBuffers()
 718 {
 719     m_responseBuilder.clear();
 720     m_responseEncoding = String();
 721     m_createdDocument = false;
 722     m_responseDocument = nullptr;
 723     m_binaryResponseBuilder = nullptr;
 724     m_responseCacheIsValid = false;
 725 }
 726 
 727 void XMLHttpRequest::clearRequest()
 728 {
 729     m_requestHeaders.clear();
 730     m_requestEntityBody = nullptr;
 731 }
 732 
 733 void XMLHttpRequest::genericError()
 734 {
 735     clearResponse();
 736     clearRequest();
 737     m_sendFlag = false;
 738     m_error = true;
 739 
 740     changeState(DONE);
 741 }
 742 
 743 void XMLHttpRequest::networkError()
 744 {
 745     genericError();
 746     dispatchErrorEvents(eventNames().errorEvent);
 747     internalAbort();
 748 }
 749 
 750 void XMLHttpRequest::networkErrorTimerFired()
 751 {
 752     networkError();
 753     unsetPendingActivity(*this);
 754 }
 755 
 756 void XMLHttpRequest::abortError()
 757 {
 758     ASSERT(m_wasAbortedByClient);
 759     genericError();
 760     dispatchErrorEvents(eventNames().abortEvent);
 761 }
 762 
 763 size_t XMLHttpRequest::memoryCost() const
 764 {
 765     if (readyState() == DONE)
 766         return m_responseBuilder.length() * 2;
 767     return 0;
 768 }
 769 
 770 ExceptionOr&lt;void&gt; XMLHttpRequest::overrideMimeType(const String&amp; mimeType)
 771 {
 772     if (readyState() == LOADING || readyState() == DONE)
 773         return Exception { InvalidStateError };
 774 
 775     m_mimeTypeOverride = &quot;application/octet-stream&quot;_s;
 776     if (isValidContentType(mimeType))
 777         m_mimeTypeOverride = mimeType;
 778 
 779     return { };
 780 }
 781 
 782 ExceptionOr&lt;void&gt; XMLHttpRequest::setRequestHeader(const String&amp; name, const String&amp; value)
 783 {
<a name="26" id="anc26"></a><span class="line-modified"> 784     if (readyState() != OPENED || m_sendFlag)</span>




 785         return Exception { InvalidStateError };
<a name="27" id="anc27"></a>
 786 
 787     String normalizedValue = stripLeadingAndTrailingHTTPSpaces(value);
 788     if (!isValidHTTPToken(name) || !isValidHTTPHeaderValue(normalizedValue))
 789         return Exception { SyntaxError };
 790 
 791     bool allowUnsafeHeaderField = false;
<a name="28" id="anc28"></a><span class="line-modified"> 792     // FIXME: The allowSettingAnyXHRHeaderFromFileURLs setting currently only applies to Documents, not workers.</span>
<span class="line-modified"> 793     if (securityOrigin()-&gt;canLoadLocalResources() &amp;&amp; scriptExecutionContext()-&gt;isDocument() &amp;&amp; document()-&gt;settings().allowSettingAnyXHRHeaderFromFileURLs())</span>


 794         allowUnsafeHeaderField = true;
 795     if (!allowUnsafeHeaderField &amp;&amp; isForbiddenHeaderName(name)) {
 796         logConsoleError(scriptExecutionContext(), &quot;Refused to set unsafe header \&quot;&quot; + name + &quot;\&quot;&quot;);
 797         return { };
 798     }
 799 
 800     m_requestHeaders.add(name, normalizedValue);
 801     return { };
 802 }
 803 
 804 String XMLHttpRequest::getAllResponseHeaders() const
 805 {
 806     if (readyState() &lt; HEADERS_RECEIVED || m_error)
 807         return emptyString();
 808 
 809     if (!m_allResponseHeaders) {
 810         Vector&lt;String&gt; headers;
 811         headers.reserveInitialCapacity(m_response.httpHeaderFields().size());
 812 
 813         for (auto&amp; header : m_response.httpHeaderFields()) {
 814             StringBuilder stringBuilder;
 815             stringBuilder.append(header.key.convertToASCIILowercase());
 816             stringBuilder.appendLiteral(&quot;: &quot;);
 817             stringBuilder.append(header.value);
 818             stringBuilder.appendLiteral(&quot;\r\n&quot;);
 819             headers.uncheckedAppend(stringBuilder.toString());
 820         }
 821         std::sort(headers.begin(), headers.end(), WTF::codePointCompareLessThan);
 822 
 823         StringBuilder stringBuilder;
 824         for (auto&amp; header : headers)
 825             stringBuilder.append(header);
 826         m_allResponseHeaders = stringBuilder.toString();
 827     }
 828 
 829     return m_allResponseHeaders;
 830 }
 831 
 832 String XMLHttpRequest::getResponseHeader(const String&amp; name) const
 833 {
 834     if (readyState() &lt; HEADERS_RECEIVED || m_error)
 835         return String();
 836 
 837     return m_response.httpHeaderField(name);
 838 }
 839 
 840 String XMLHttpRequest::responseMIMEType() const
 841 {
 842     String mimeType = extractMIMETypeFromMediaType(m_mimeTypeOverride);
 843     if (mimeType.isEmpty()) {
<a name="29" id="anc29"></a><span class="line-added"> 844         String contentType;</span>
 845         if (m_response.isHTTP())
<a name="30" id="anc30"></a><span class="line-modified"> 846             contentType = m_response.httpHeaderField(HTTPHeaderName::ContentType);</span>
 847         else
<a name="31" id="anc31"></a><span class="line-modified"> 848             contentType = m_response.mimeType();</span>
<span class="line-modified"> 849         if (auto parsedContentType = ParsedContentType::create(contentType))</span>
<span class="line-modified"> 850             return parsedContentType-&gt;mimeType();</span>
<span class="line-added"> 851         return &quot;text/xml&quot;_s;</span>
 852     }
 853     return mimeType;
 854 }
 855 
 856 bool XMLHttpRequest::responseIsXML() const
 857 {
 858     return MIMETypeRegistry::isXMLMIMEType(responseMIMEType());
 859 }
 860 
 861 int XMLHttpRequest::status() const
 862 {
 863     if (readyState() == UNSENT || readyState() == OPENED || m_error)
 864         return 0;
 865 
 866     return m_response.httpStatusCode();
 867 }
 868 
 869 String XMLHttpRequest::statusText() const
 870 {
 871     if (readyState() == UNSENT || readyState() == OPENED || m_error)
 872         return String();
 873 
 874     return m_response.httpStatusText();
 875 }
 876 
 877 void XMLHttpRequest::didFail(const ResourceError&amp; error)
 878 {
 879     // If we are already in an error state, for instance we called abort(), bail out early.
 880     if (m_error)
 881         return;
 882 
 883     // The XHR specification says we should only fire an abort event if the cancelation was requested by the client.
 884     if (m_wasAbortedByClient &amp;&amp; error.isCancellation()) {
 885         m_exceptionCode = AbortError;
 886         abortError();
 887         return;
 888     }
 889 
 890     // In case of worker sync timeouts.
 891     if (error.isTimeout()) {
 892         didReachTimeout();
 893         return;
 894     }
 895 
 896     // In case didFail is called synchronously on an asynchronous XHR call, let&#39;s dispatch network error asynchronously
 897     if (m_async &amp;&amp; m_sendFlag &amp;&amp; !m_loader) {
 898         m_sendFlag = false;
 899         setPendingActivity(*this);
 900         m_timeoutTimer.stop();
 901         m_networkErrorTimer.startOneShot(0_s);
 902         return;
 903     }
 904     m_exceptionCode = NetworkError;
 905     networkError();
 906 }
 907 
 908 void XMLHttpRequest::didFinishLoading(unsigned long)
 909 {
 910     if (m_error)
 911         return;
 912 
 913     if (readyState() &lt; HEADERS_RECEIVED)
 914         changeState(HEADERS_RECEIVED);
 915 
 916     if (m_decoder)
 917         m_responseBuilder.append(m_decoder-&gt;flush());
 918 
 919     m_responseBuilder.shrinkToFit();
 920 
 921     bool hadLoader = m_loader;
 922     m_loader = nullptr;
 923 
 924     m_sendFlag = false;
 925     changeState(DONE);
 926     m_responseEncoding = String();
 927     m_decoder = nullptr;
 928 
 929     m_timeoutTimer.stop();
 930 
 931     if (hadLoader)
 932         unsetPendingActivity(*this);
 933 }
 934 
 935 void XMLHttpRequest::didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent)
 936 {
 937     if (!m_upload)
 938         return;
 939 
 940     if (m_uploadListenerFlag)
<a name="32" id="anc32"></a><span class="line-modified"> 941         m_upload-&gt;dispatchProgressEvent(eventNames().progressEvent, bytesSent, totalBytesToBeSent);</span>
 942 
 943     if (bytesSent == totalBytesToBeSent &amp;&amp; !m_uploadComplete) {
 944         m_uploadComplete = true;
 945         if (m_uploadListenerFlag) {
<a name="33" id="anc33"></a><span class="line-modified"> 946             m_upload-&gt;dispatchProgressEvent(eventNames().loadEvent, bytesSent, totalBytesToBeSent);</span>
<span class="line-modified"> 947             m_upload-&gt;dispatchProgressEvent(eventNames().loadendEvent, bytesSent, totalBytesToBeSent);</span>
 948         }
 949     }
 950 }
 951 
 952 void XMLHttpRequest::didReceiveResponse(unsigned long, const ResourceResponse&amp; response)
 953 {
 954     m_response = response;
 955 }
 956 
 957 static inline bool shouldDecodeResponse(XMLHttpRequest::ResponseType type)
 958 {
 959     switch (type) {
 960     case XMLHttpRequest::ResponseType::EmptyString:
 961     case XMLHttpRequest::ResponseType::Document:
 962     case XMLHttpRequest::ResponseType::Json:
 963     case XMLHttpRequest::ResponseType::Text:
 964         return true;
 965     case XMLHttpRequest::ResponseType::Arraybuffer:
 966     case XMLHttpRequest::ResponseType::Blob:
 967         return false;
 968     }
 969     ASSERT_NOT_REACHED();
 970     return true;
 971 }
 972 
<a name="34" id="anc34"></a><span class="line-added"> 973 // https://xhr.spec.whatwg.org/#final-charset</span>
<span class="line-added"> 974 TextEncoding XMLHttpRequest::finalResponseCharset() const</span>
<span class="line-added"> 975 {</span>
<span class="line-added"> 976     String label = m_responseEncoding;</span>
<span class="line-added"> 977 </span>
<span class="line-added"> 978     String overrideResponseCharset = extractCharsetFromMediaType(m_mimeTypeOverride);</span>
<span class="line-added"> 979     if (!overrideResponseCharset.isEmpty())</span>
<span class="line-added"> 980         label = overrideResponseCharset;</span>
<span class="line-added"> 981 </span>
<span class="line-added"> 982     return TextEncoding(label);</span>
<span class="line-added"> 983 }</span>
<span class="line-added"> 984 </span>
 985 Ref&lt;TextResourceDecoder&gt; XMLHttpRequest::createDecoder() const
 986 {
<a name="35" id="anc35"></a><span class="line-modified"> 987     TextEncoding finalResponseCharset = this-&gt;finalResponseCharset();</span>
<span class="line-modified"> 988     if (finalResponseCharset.isValid())</span>
<span class="line-added"> 989         return TextResourceDecoder::create(&quot;text/plain&quot;, finalResponseCharset);</span>
 990 
 991     switch (responseType()) {
 992     case ResponseType::EmptyString:
 993         if (responseIsXML()) {
 994             auto decoder = TextResourceDecoder::create(&quot;application/xml&quot;);
 995             // Don&#39;t stop on encoding errors, unlike it is done for other kinds of XML resources. This matches the behavior of previous WebKit versions, Firefox and Opera.
 996             decoder-&gt;useLenientXMLDecoding();
 997             return decoder;
 998         }
 999         FALLTHROUGH;
1000     case ResponseType::Text:
1001     case ResponseType::Json:
1002         return TextResourceDecoder::create(&quot;text/plain&quot;, &quot;UTF-8&quot;);
1003     case ResponseType::Document: {
1004         if (equalLettersIgnoringASCIICase(responseMIMEType(), &quot;text/html&quot;))
1005             return TextResourceDecoder::create(&quot;text/html&quot;, &quot;UTF-8&quot;);
1006         auto decoder = TextResourceDecoder::create(&quot;application/xml&quot;);
1007         // Don&#39;t stop on encoding errors, unlike it is done for other kinds of XML resources. This matches the behavior of previous WebKit versions, Firefox and Opera.
1008         decoder-&gt;useLenientXMLDecoding();
1009         return decoder;
1010     }
1011     case ResponseType::Arraybuffer:
1012     case ResponseType::Blob:
1013         ASSERT_NOT_REACHED();
1014         break;
1015     }
1016     return TextResourceDecoder::create(&quot;text/plain&quot;, &quot;UTF-8&quot;);
1017 }
1018 
1019 void XMLHttpRequest::didReceiveData(const char* data, int len)
1020 {
1021     if (m_error)
1022         return;
1023 
1024     if (readyState() &lt; HEADERS_RECEIVED)
1025         changeState(HEADERS_RECEIVED);
1026 
1027     if (!m_mimeTypeOverride.isEmpty())
1028         m_responseEncoding = extractCharsetFromMediaType(m_mimeTypeOverride);
1029     if (m_responseEncoding.isEmpty())
1030         m_responseEncoding = m_response.textEncodingName();
1031 
1032     bool useDecoder = shouldDecodeResponse(responseType());
1033 
1034     if (useDecoder &amp;&amp; !m_decoder)
1035         m_decoder = createDecoder();
1036 
1037     if (!len)
1038         return;
1039 
1040     if (len == -1)
1041         len = strlen(data);
1042 
1043     if (useDecoder)
1044         m_responseBuilder.append(m_decoder-&gt;decode(data, len));
1045     else {
1046         // Buffer binary data.
1047         if (!m_binaryResponseBuilder)
1048             m_binaryResponseBuilder = SharedBuffer::create();
1049         m_binaryResponseBuilder-&gt;append(data, len);
1050     }
1051 
1052     if (!m_error) {
1053         m_receivedLength += len;
1054 
<a name="36" id="anc36"></a><span class="line-added">1055         if (readyState() != LOADING)</span>
<span class="line-added">1056             changeState(LOADING);</span>
<span class="line-added">1057         else {</span>
<span class="line-added">1058             // Firefox calls readyStateChanged every time it receives data, 4449442</span>
<span class="line-added">1059             callReadyStateChangeListener();</span>
<span class="line-added">1060         }</span>
<span class="line-added">1061 </span>
1062         if (m_async) {
1063             long long expectedLength = m_response.expectedContentLength();
1064             bool lengthComputable = expectedLength &gt; 0 &amp;&amp; m_receivedLength &lt;= expectedLength;
1065             unsigned long long total = lengthComputable ? expectedLength : 0;
1066             m_progressEventThrottle.dispatchThrottledProgressEvent(lengthComputable, m_receivedLength, total);
1067         }
<a name="37" id="anc37"></a><span class="line-added">1068     }</span>
<span class="line-added">1069 }</span>
1070 
<a name="38" id="anc38"></a><span class="line-modified">1071 void XMLHttpRequest::dispatchEvent(Event&amp; event)</span>
<span class="line-modified">1072 {</span>
<span class="line-modified">1073     if (m_userGestureToken &amp;&amp; m_userGestureToken-&gt;hasExpired(m_maximumIntervalForUserGestureForwarding))</span>
<span class="line-modified">1074         m_userGestureToken = nullptr;</span>
<span class="line-modified">1075 </span>
<span class="line-added">1076     if (readyState() != DONE || !m_userGestureToken || !m_userGestureToken-&gt;processingUserGesture()) {</span>
<span class="line-added">1077         EventTarget::dispatchEvent(event);</span>
<span class="line-added">1078         return;</span>
1079     }
<a name="39" id="anc39"></a><span class="line-added">1080 </span>
<span class="line-added">1081     UserGestureIndicator gestureIndicator(m_userGestureToken, UserGestureToken::GestureScope::MediaOnly);</span>
<span class="line-added">1082     EventTarget::dispatchEvent(event);</span>
1083 }
1084 
<a name="40" id="anc40"></a><span class="line-modified">1085 void XMLHttpRequest::dispatchErrorEvents(const AtomString&amp; type)</span>
1086 {
1087     if (!m_uploadComplete) {
1088         m_uploadComplete = true;
1089         if (m_upload &amp;&amp; m_uploadListenerFlag) {
<a name="41" id="anc41"></a><span class="line-modified">1090             m_upload-&gt;dispatchProgressEvent(type, 0, 0);</span>
<span class="line-modified">1091             m_upload-&gt;dispatchProgressEvent(eventNames().loadendEvent, 0, 0);</span>
1092         }
1093     }
1094     m_progressEventThrottle.dispatchProgressEvent(type);
1095     m_progressEventThrottle.dispatchProgressEvent(eventNames().loadendEvent);
1096 }
1097 
1098 void XMLHttpRequest::didReachTimeout()
1099 {
1100     // internalAbort() calls unsetPendingActivity(this), which may release the last reference.
1101     Ref&lt;XMLHttpRequest&gt; protectedThis(*this);
1102     if (!internalAbort())
1103         return;
1104 
1105     clearResponse();
1106     clearRequest();
1107 
1108     m_sendFlag = false;
1109     m_error = true;
1110     m_exceptionCode = TimeoutError;
1111 
1112     if (!m_async) {
1113         m_readyState = static_cast&lt;State&gt;(DONE);
1114         m_exceptionCode = TimeoutError;
1115         return;
1116     }
1117 
1118     changeState(DONE);
1119 
1120     dispatchErrorEvents(eventNames().timeoutEvent);
1121 }
1122 
1123 bool XMLHttpRequest::canSuspendForDocumentSuspension() const
1124 {
1125     // If the load event has not fired yet, cancelling the load in suspend() may cause
1126     // the load event to be fired and arbitrary JS execution, which would be unsafe.
1127     // Therefore, we prevent suspending in this case.
1128     return document()-&gt;loadEventFinished();
1129 }
1130 
1131 const char* XMLHttpRequest::activeDOMObjectName() const
1132 {
1133     return &quot;XMLHttpRequest&quot;;
1134 }
1135 
1136 void XMLHttpRequest::suspend(ReasonForSuspension reason)
1137 {
1138     m_progressEventThrottle.suspend();
1139 
1140     if (m_resumeTimer.isActive()) {
1141         m_resumeTimer.stop();
1142         m_dispatchErrorOnResuming = true;
1143     }
1144 
1145     if (reason == ReasonForSuspension::PageCache &amp;&amp; m_loader) {
1146         // Going into PageCache, abort the request and dispatch a network error on resuming.
1147         genericError();
1148         m_dispatchErrorOnResuming = true;
1149         bool aborted = internalAbort();
1150         // It should not be possible to restart the load when aborting in suspend() because
1151         // we are not allowed to execute in JS in suspend().
1152         ASSERT_UNUSED(aborted, aborted);
1153     }
1154 }
1155 
1156 void XMLHttpRequest::resume()
1157 {
1158     m_progressEventThrottle.resume();
1159 
1160     // We are not allowed to execute arbitrary JS in resume() so dispatch
1161     // the error event in a timer.
1162     if (m_dispatchErrorOnResuming &amp;&amp; !m_resumeTimer.isActive())
1163         m_resumeTimer.startOneShot(0_s);
1164 }
1165 
1166 void XMLHttpRequest::resumeTimerFired()
1167 {
1168     ASSERT(m_dispatchErrorOnResuming);
1169     m_dispatchErrorOnResuming = false;
1170     dispatchErrorEvents(eventNames().errorEvent);
1171 }
1172 
1173 void XMLHttpRequest::stop()
1174 {
1175     internalAbort();
1176 }
1177 
1178 void XMLHttpRequest::contextDestroyed()
1179 {
1180     ASSERT(!m_loader);
1181     ActiveDOMObject::contextDestroyed();
1182 }
1183 
<a name="42" id="anc42"></a><span class="line-added">1184 void XMLHttpRequest::setMaximumIntervalForUserGestureForwarding(double interval)</span>
<span class="line-added">1185 {</span>
<span class="line-added">1186     m_maximumIntervalForUserGestureForwarding = Seconds(interval);</span>
<span class="line-added">1187 }</span>
<span class="line-added">1188 </span>
1189 } // namespace WebCore
<a name="43" id="anc43"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="43" type="hidden" />
</body>
</html>