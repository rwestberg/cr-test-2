<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/DeleteSelectionCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2005 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DeleteSelectionCommand.h&quot;
 28 
 29 #include &quot;Document.h&quot;
 30 #include &quot;DocumentMarkerController.h&quot;
 31 #include &quot;Editing.h&quot;
 32 #include &quot;Editor.h&quot;
 33 #include &quot;EditorClient.h&quot;
 34 #include &quot;ElementIterator.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;HTMLBRElement.h&quot;
 37 #include &quot;HTMLLinkElement.h&quot;
 38 #include &quot;HTMLNames.h&quot;
 39 #include &quot;HTMLStyleElement.h&quot;
 40 #include &quot;HTMLTableElement.h&quot;
 41 #include &quot;NodeTraversal.h&quot;
 42 #include &quot;RenderTableCell.h&quot;
 43 #include &quot;RenderText.h&quot;
 44 #include &quot;RenderedDocumentMarker.h&quot;
 45 #include &quot;Text.h&quot;
 46 #include &quot;VisibleUnits.h&quot;
 47 
 48 namespace WebCore {
 49 
 50 using namespace HTMLNames;
 51 
 52 static bool isTableRow(const Node* node)
 53 {
 54     return node &amp;&amp; node-&gt;hasTagName(trTag);
 55 }
 56 
 57 static bool isTableCellEmpty(Node* cell)
 58 {
 59     ASSERT(isTableCell(cell));
 60     return VisiblePosition(firstPositionInNode(cell)) == VisiblePosition(lastPositionInNode(cell));
 61 }
 62 
 63 static bool isTableRowEmpty(Node* row)
 64 {
 65     if (!isTableRow(row))
 66         return false;
 67 
 68     for (Node* child = row-&gt;firstChild(); child; child = child-&gt;nextSibling())
 69         if (isTableCell(child) &amp;&amp; !isTableCellEmpty(child))
 70             return false;
 71 
 72     return true;
 73 }
 74 
 75 DeleteSelectionCommand::DeleteSelectionCommand(Document&amp; document, bool smartDelete, bool mergeBlocksAfterDelete, bool replace, bool expandForSpecialElements, bool sanitizeMarkup, EditAction editingAction)
 76     : CompositeEditCommand(document, editingAction)
 77     , m_hasSelectionToDelete(false)
 78     , m_smartDelete(smartDelete)
 79     , m_mergeBlocksAfterDelete(mergeBlocksAfterDelete)
 80     , m_needPlaceholder(false)
 81     , m_replace(replace)
 82     , m_expandForSpecialElements(expandForSpecialElements)
 83     , m_pruneStartBlockIfNecessary(false)
 84     , m_startsAtEmptyLine(false)
 85     , m_sanitizeMarkup(sanitizeMarkup)
 86 {
 87 }
 88 
 89 DeleteSelectionCommand::DeleteSelectionCommand(const VisibleSelection&amp; selection, bool smartDelete, bool mergeBlocksAfterDelete, bool replace, bool expandForSpecialElements, bool sanitizeMarkup, EditAction editingAction)
 90     : CompositeEditCommand(selection.start().anchorNode()-&gt;document(), editingAction)
 91     , m_hasSelectionToDelete(true)
 92     , m_smartDelete(smartDelete)
 93     , m_mergeBlocksAfterDelete(mergeBlocksAfterDelete)
 94     , m_needPlaceholder(false)
 95     , m_replace(replace)
 96     , m_expandForSpecialElements(expandForSpecialElements)
 97     , m_pruneStartBlockIfNecessary(false)
 98     , m_startsAtEmptyLine(false)
 99     , m_sanitizeMarkup(sanitizeMarkup)
100     , m_selectionToDelete(selection)
101 {
102 }
103 
104 void DeleteSelectionCommand::initializeStartEnd(Position&amp; start, Position&amp; end)
105 {
106     HTMLElement* startSpecialContainer = nullptr;
107     HTMLElement* endSpecialContainer = nullptr;
108 
109     start = m_selectionToDelete.start();
110     end = m_selectionToDelete.end();
111 
112     // For HRs, we&#39;ll get a position at (HR,1) when hitting delete from the beginning of the previous line, or (HR,0) when forward deleting,
113     // but in these cases, we want to delete it, so manually expand the selection
114     if (start.deprecatedNode()-&gt;hasTagName(hrTag))
115         start = positionBeforeNode(start.deprecatedNode());
116     else if (end.deprecatedNode()-&gt;hasTagName(hrTag))
117         end = positionAfterNode(end.deprecatedNode());
118 
119     // FIXME: This is only used so that moveParagraphs can avoid the bugs in special element expansion.
120     if (!m_expandForSpecialElements)
121         return;
122 
123     while (1) {
124         startSpecialContainer = nullptr;
125         endSpecialContainer = nullptr;
126 
127         Position s = positionBeforeContainingSpecialElement(start, &amp;startSpecialContainer);
128         Position e = positionAfterContainingSpecialElement(end, &amp;endSpecialContainer);
129 
130         if (!startSpecialContainer &amp;&amp; !endSpecialContainer)
131             break;
132 
133         m_mergeBlocksAfterDelete = false;
134 
135         if (VisiblePosition(start) != m_selectionToDelete.visibleStart() || VisiblePosition(end) != m_selectionToDelete.visibleEnd())
136             break;
137 
138         // If we&#39;re going to expand to include the startSpecialContainer, it must be fully selected.
139         if (startSpecialContainer &amp;&amp; !endSpecialContainer &amp;&amp; comparePositions(positionInParentAfterNode(startSpecialContainer), end) &gt; -1)
140             break;
141 
142         // If we&#39;re going to expand to include the endSpecialContainer, it must be fully selected.
143         if (endSpecialContainer &amp;&amp; !startSpecialContainer &amp;&amp; comparePositions(start, positionInParentBeforeNode(endSpecialContainer)) &gt; -1)
144             break;
145 
146         if (startSpecialContainer &amp;&amp; startSpecialContainer-&gt;isDescendantOf(endSpecialContainer))
147             // Don&#39;t adjust the end yet, it is the end of a special element that contains the start
148             // special element (which may or may not be fully selected).
149             start = s;
150         else if (endSpecialContainer &amp;&amp; endSpecialContainer-&gt;isDescendantOf(startSpecialContainer))
151             // Don&#39;t adjust the start yet, it is the start of a special element that contains the end
152             // special element (which may or may not be fully selected).
153             end = e;
154         else {
155             start = s;
156             end = e;
157         }
158     }
159 }
160 
161 void DeleteSelectionCommand::setStartingSelectionOnSmartDelete(const Position&amp; start, const Position&amp; end)
162 {
163     VisiblePosition newBase;
164     VisiblePosition newExtent;
165     if (startingSelection().isBaseFirst()) {
166         newBase = start;
167         newExtent = end;
168     } else {
169         newBase = end;
170         newExtent = start;
171     }
172     setStartingSelection(VisibleSelection(newBase, newExtent, startingSelection().isDirectional()));
173 }
174 
<a name="1" id="anc1"></a>







































175 bool DeleteSelectionCommand::initializePositionData()
176 {
177     Position start, end;
178     initializeStartEnd(start, end);
179 
180     if (!isEditablePosition(start, ContentIsEditable))
181         start = firstEditablePositionAfterPositionInRoot(start, highestEditableRoot(start));
182     if (!isEditablePosition(end, ContentIsEditable))
183         end = lastEditablePositionBeforePositionInRoot(end, highestEditableRoot(start));
184 
185     if (start.isNull() || end.isNull())
186         return false;
187 
188     m_upstreamStart = start.upstream();
189     m_downstreamStart = start.downstream();
190     m_upstreamEnd = end.upstream();
191     m_downstreamEnd = end.downstream();
192 
193     m_startRoot = editableRootForPosition(start);
194     m_endRoot = editableRootForPosition(end);
195 
196     m_startTableRow = enclosingNodeOfType(start, &amp;isTableRow);
197     m_endTableRow = enclosingNodeOfType(end, &amp;isTableRow);
198 
199     // Don&#39;t move content out of a table cell.
200     // If the cell is non-editable, enclosingNodeOfType won&#39;t return it by default, so
201     // tell that function that we don&#39;t care if it returns non-editable nodes.
202     Node* startCell = enclosingNodeOfType(m_upstreamStart, &amp;isTableCell, CanCrossEditingBoundary);
203     Node* endCell = enclosingNodeOfType(m_downstreamEnd, &amp;isTableCell, CanCrossEditingBoundary);
204     // FIXME: This isn&#39;t right.  A borderless table with two rows and a single column would appear as two paragraphs.
205     if (endCell &amp;&amp; endCell != startCell)
206         m_mergeBlocksAfterDelete = false;
207 
208     // Usually the start and the end of the selection to delete are pulled together as a result of the deletion.
209     // Sometimes they aren&#39;t (like when no merge is requested), so we must choose one position to hold the caret
210     // and receive the placeholder after deletion.
211     VisiblePosition visibleEnd(m_downstreamEnd);
212     if (m_mergeBlocksAfterDelete &amp;&amp; !isEndOfParagraph(visibleEnd))
213         m_endingPosition = m_downstreamEnd;
214     else
215         m_endingPosition = m_downstreamStart;
216 
217     // We don&#39;t want to merge into a block if it will mean changing the quote level of content after deleting
218     // selections that contain a whole number paragraphs plus a line break, since it is unclear to most users
219     // that such a selection actually ends at the start of the next paragraph. This matches TextEdit behavior
220     // for indented paragraphs.
221     // Only apply this rule if the endingSelection is a range selection.  If it is a caret, then other operations have created
222     // the selection we&#39;re deleting (like the process of creating a selection to delete during a backspace), and the user isn&#39;t in the situation described above.
223     if (numEnclosingMailBlockquotes(start) != numEnclosingMailBlockquotes(end)
224             &amp;&amp; isStartOfParagraph(visibleEnd) &amp;&amp; isStartOfParagraph(VisiblePosition(start))
225             &amp;&amp; endingSelection().isRange()) {
226         m_mergeBlocksAfterDelete = false;
227         m_pruneStartBlockIfNecessary = true;
228     }
229 
230     // Handle leading and trailing whitespace, as well as smart delete adjustments to the selection
231     m_leadingWhitespace = m_upstreamStart.leadingWhitespacePosition(m_selectionToDelete.affinity());
232     m_trailingWhitespace = m_downstreamEnd.trailingWhitespacePosition(VP_DEFAULT_AFFINITY);
233 
234     if (m_smartDelete) {
235 
236         // skip smart delete if the selection to delete already starts or ends with whitespace
237         Position pos = VisiblePosition(m_upstreamStart, m_selectionToDelete.affinity()).deepEquivalent();
238         bool skipSmartDelete = pos.trailingWhitespacePosition(VP_DEFAULT_AFFINITY, true).isNotNull();
239         if (!skipSmartDelete)
240             skipSmartDelete = m_downstreamEnd.leadingWhitespacePosition(VP_DEFAULT_AFFINITY, true).isNotNull();
241 
242         // extend selection upstream if there is whitespace there
243         bool hasLeadingWhitespaceBeforeAdjustment = m_upstreamStart.leadingWhitespacePosition(m_selectionToDelete.affinity(), true).isNotNull();
244         if (!skipSmartDelete &amp;&amp; hasLeadingWhitespaceBeforeAdjustment) {
245             VisiblePosition visiblePos = VisiblePosition(m_upstreamStart, VP_DEFAULT_AFFINITY).previous();
246             pos = visiblePos.deepEquivalent();
247             // Expand out one character upstream for smart delete and recalculate
248             // positions based on this change.
249             m_upstreamStart = pos.upstream();
250             m_downstreamStart = pos.downstream();
251             m_leadingWhitespace = m_upstreamStart.leadingWhitespacePosition(visiblePos.affinity());
252 
253             setStartingSelectionOnSmartDelete(m_upstreamStart, m_upstreamEnd);
254         }
255 
256         // trailing whitespace is only considered for smart delete if there is no leading
257         // whitespace, as in the case where you double-click the first word of a paragraph.
258         if (!skipSmartDelete &amp;&amp; !hasLeadingWhitespaceBeforeAdjustment &amp;&amp; m_downstreamEnd.trailingWhitespacePosition(VP_DEFAULT_AFFINITY, true).isNotNull()) {
259             // Expand out one character downstream for smart delete and recalculate
260             // positions based on this change.
261             pos = VisiblePosition(m_downstreamEnd, VP_DEFAULT_AFFINITY).next().deepEquivalent();
262             m_upstreamEnd = pos.upstream();
263             m_downstreamEnd = pos.downstream();
264             m_trailingWhitespace = m_downstreamEnd.trailingWhitespacePosition(VP_DEFAULT_AFFINITY);
265 
266             setStartingSelectionOnSmartDelete(m_downstreamStart, m_downstreamEnd);
267         }
<a name="2" id="anc2"></a>


268     }
269 
270     // We must pass call parentAnchoredEquivalent on the positions since some editing positions
271     // that appear inside their nodes aren&#39;t really inside them.  [hr, 0] is one example.
272     // FIXME: parentAnchoredEquivalent should eventually be moved into enclosing element getters
273     // like the one below, since editing functions should obviously accept editing positions.
274     // FIXME: Passing false to enclosingNodeOfType tells it that it&#39;s OK to return a non-editable
275     // node.  This was done to match existing behavior, but it seems wrong.
276     m_startBlock = enclosingNodeOfType(m_downstreamStart.parentAnchoredEquivalent(), &amp;isBlock, CanCrossEditingBoundary);
277     m_endBlock = enclosingNodeOfType(m_upstreamEnd.parentAnchoredEquivalent(), &amp;isBlock, CanCrossEditingBoundary);
278 
279     return true;
280 }
281 
282 void DeleteSelectionCommand::saveTypingStyleState()
283 {
284     // A common case is deleting characters that are all from the same text node. In
285     // that case, the style at the start of the selection before deletion will be the
286     // same as the style at the start of the selection after deletion (since those
287     // two positions will be identical). Therefore there is no need to save the
288     // typing style at the start of the selection, nor is there a reason to
289     // compute the style at the start of the selection after deletion (see the
290     // early return in calculateTypingStyleAfterDelete).
291     // However, if typing style was previously set from another text node at the previous
292     // position (now deleted), we need to clear that style as well.
293     if (m_upstreamStart.deprecatedNode() == m_downstreamEnd.deprecatedNode() &amp;&amp; m_upstreamStart.deprecatedNode()-&gt;isTextNode()) {
294         frame().selection().clearTypingStyle();
295         return;
296     }
297 
298     // Figure out the typing style in effect before the delete is done.
299     m_typingStyle = EditingStyle::create(m_selectionToDelete.start(), EditingStyle::EditingPropertiesInEffect);
300     m_typingStyle-&gt;removeStyleAddedByNode(enclosingAnchorElement(m_selectionToDelete.start()));
301 
302     // If we&#39;re deleting into a Mail blockquote, save the style at end() instead of start()
303     // We&#39;ll use this later in computeTypingStyleAfterDelete if we end up outside of a Mail blockquote
304     if (enclosingNodeOfType(m_selectionToDelete.start(), isMailBlockquote))
305         m_deleteIntoBlockquoteStyle = EditingStyle::create(m_selectionToDelete.end());
306     else
307         m_deleteIntoBlockquoteStyle = nullptr;
308 }
309 
310 bool DeleteSelectionCommand::handleSpecialCaseBRDelete()
311 {
312     Node* nodeAfterUpstreamStart = m_upstreamStart.computeNodeAfterPosition();
313     Node* nodeAfterDownstreamStart = m_downstreamStart.computeNodeAfterPosition();
314     // Upstream end will appear before BR due to canonicalization
315     Node* nodeAfterUpstreamEnd = m_upstreamEnd.computeNodeAfterPosition();
316 
317     if (!nodeAfterUpstreamStart || !nodeAfterDownstreamStart)
318         return false;
319 
320     // Check for special-case where the selection contains only a BR on a line by itself after another BR.
321     bool upstreamStartIsBR = nodeAfterUpstreamStart-&gt;hasTagName(brTag);
322     bool downstreamStartIsBR = nodeAfterDownstreamStart-&gt;hasTagName(brTag);
323     // We should consider that the BR is on a line by itself also when we have &lt;br&gt;&lt;br&gt;. This test should be true only
324     // when the two elements are siblings and should be false in a case like &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;.
325     bool isBROnLineByItself = upstreamStartIsBR &amp;&amp; downstreamStartIsBR &amp;&amp; ((nodeAfterDownstreamStart == nodeAfterUpstreamEnd) || (nodeAfterUpstreamEnd &amp;&amp; nodeAfterUpstreamEnd-&gt;hasTagName(brTag) &amp;&amp; nodeAfterUpstreamStart-&gt;nextSibling() == nodeAfterUpstreamEnd));
326 
327     if (isBROnLineByItself) {
328         removeNode(*nodeAfterDownstreamStart);
329         return true;
330     }
331 
332     // FIXME: This code doesn&#39;t belong in here.
333     // We detect the case where the start is an empty line consisting of BR not wrapped in a block element.
334     if (upstreamStartIsBR &amp;&amp; downstreamStartIsBR
335         &amp;&amp; !(isStartOfBlock(positionBeforeNode(nodeAfterUpstreamStart)) &amp;&amp; isEndOfBlock(positionAfterNode(nodeAfterDownstreamStart)))
336         &amp;&amp; (!nodeAfterUpstreamEnd || nodeAfterUpstreamEnd-&gt;hasTagName(brTag) || nodeAfterUpstreamEnd-&gt;previousSibling() != nodeAfterUpstreamStart)) {
337         m_startsAtEmptyLine = true;
338         m_endingPosition = m_downstreamEnd;
339     }
340 
341     return false;
342 }
343 
344 static Position firstEditablePositionInNode(Node* node)
345 {
346     ASSERT(node);
347     Node* next = node;
348     while (next &amp;&amp; !next-&gt;hasEditableStyle())
349         next = NodeTraversal::next(*next, node);
350     return next ? firstPositionInOrBeforeNode(next) : Position();
351 }
352 
353 void DeleteSelectionCommand::insertBlockPlaceholderForTableCellIfNeeded(Element&amp; element)
354 {
355     // Make sure empty cell has some height.
356     auto* renderer = element.renderer();
357     if (!is&lt;RenderTableCell&gt;(renderer))
358         return;
359     if (downcast&lt;RenderTableCell&gt;(*renderer).contentHeight() &gt; 0)
360         return;
361     insertBlockPlaceholder(firstEditablePositionInNode(&amp;element));
362 }
363 
364 void DeleteSelectionCommand::removeNodeUpdatingStates(Node&amp; node, ShouldAssumeContentIsAlwaysEditable shouldAssumeContentIsAlwaysEditable)
365 {
366     if (&amp;node == m_startBlock &amp;&amp; !isEndOfBlock(VisiblePosition(firstPositionInNode(m_startBlock.get())).previous()))
367         m_needPlaceholder = true;
368     else if (&amp;node == m_endBlock &amp;&amp; !isStartOfBlock(VisiblePosition(lastPositionInNode(m_startBlock.get())).next()))
369         m_needPlaceholder = true;
370 
371     // FIXME: Update the endpoints of the range being deleted.
372     updatePositionForNodeRemoval(m_endingPosition, node);
373     updatePositionForNodeRemoval(m_leadingWhitespace, node);
374     updatePositionForNodeRemoval(m_trailingWhitespace, node);
375 
376     CompositeEditCommand::removeNode(node, shouldAssumeContentIsAlwaysEditable);
377 }
378 
379 static inline bool shouldRemoveContentOnly(const Node&amp; node)
380 {
381     return isTableStructureNode(&amp;node) || node.isRootEditableElement();
382 }
383 
384 void DeleteSelectionCommand::removeNode(Node&amp; node, ShouldAssumeContentIsAlwaysEditable shouldAssumeContentIsAlwaysEditable)
385 {
386     Ref&lt;Node&gt; protectedNode = node;
387     if (m_startRoot != m_endRoot &amp;&amp; !(node.isDescendantOf(m_startRoot.get()) &amp;&amp; node.isDescendantOf(m_endRoot.get()))) {
388         // If a node is not in both the start and end editable roots, remove it only if its inside an editable region.
389         if (!node.parentNode()-&gt;hasEditableStyle()) {
390             // Don&#39;t remove non-editable atomic nodes.
391             if (!node.firstChild())
392                 return;
393             // Search this non-editable region for editable regions to empty.
394             RefPtr&lt;Node&gt; child = node.firstChild();
395             while (child) {
396                 RefPtr&lt;Node&gt; nextChild = child-&gt;nextSibling();
397                 removeNode(*child, shouldAssumeContentIsAlwaysEditable);
398                 // Bail if nextChild is no longer node&#39;s child.
399                 if (nextChild &amp;&amp; nextChild-&gt;parentNode() != &amp;node)
400                     return;
401                 child = nextChild;
402             }
403 
404             // Don&#39;t remove editable regions that are inside non-editable ones, just clear them.
405             return;
406         }
407     }
408 
409     if (shouldRemoveContentOnly(node)) {
410         // Do not remove an element of table structure; remove its contents.
411         // Likewise for the root editable element.
412         auto* child = NodeTraversal::next(node, &amp;node);
413         while (child) {
414             if (shouldRemoveContentOnly(*child)) {
415                 child = NodeTraversal::next(*child, &amp;node);
416                 continue;
417             }
418             auto* remove = child;
419             child = NodeTraversal::nextSkippingChildren(*child, &amp;node);
420             removeNodeUpdatingStates(*remove, shouldAssumeContentIsAlwaysEditable);
421         }
422 
423         ASSERT(is&lt;Element&gt;(node));
424         auto&amp; element = downcast&lt;Element&gt;(node);
425         document().updateLayoutIgnorePendingStylesheets();
426         // Check if we need to insert a placeholder for descendant table cells.
427         auto* descendant = ElementTraversal::next(element, &amp;element);
428         while (descendant) {
429             auto* placeholderCandidate = descendant;
430             descendant = ElementTraversal::next(*descendant, &amp;element);
431             insertBlockPlaceholderForTableCellIfNeeded(*placeholderCandidate);
432         }
433         insertBlockPlaceholderForTableCellIfNeeded(element);
434         return;
435     }
436     removeNodeUpdatingStates(node, shouldAssumeContentIsAlwaysEditable);
437 }
438 
439 static void updatePositionForTextRemoval(Node* node, int offset, int count, Position&amp; position)
440 {
441     if (position.anchorType() != Position::PositionIsOffsetInAnchor || position.containerNode() != node)
442         return;
443 
444     if (position.offsetInContainerNode() &gt; offset + count)
445         position.moveToOffset(position.offsetInContainerNode() - count);
446     else if (position.offsetInContainerNode() &gt; offset)
447         position.moveToOffset(offset);
448 }
449 
450 void DeleteSelectionCommand::deleteTextFromNode(Text&amp; node, unsigned offset, unsigned count)
451 {
452     // FIXME: Update the endpoints of the range being deleted.
453     updatePositionForTextRemoval(&amp;node, offset, count, m_endingPosition);
454     updatePositionForTextRemoval(&amp;node, offset, count, m_leadingWhitespace);
455     updatePositionForTextRemoval(&amp;node, offset, count, m_trailingWhitespace);
456     updatePositionForTextRemoval(&amp;node, offset, count, m_downstreamEnd);
457 
458     CompositeEditCommand::deleteTextFromNode(node, offset, count);
459 }
460 
461 void DeleteSelectionCommand::makeStylingElementsDirectChildrenOfEditableRootToPreventStyleLoss()
462 {
463     RefPtr&lt;Range&gt; range = m_selectionToDelete.toNormalizedRange();
464     RefPtr&lt;Node&gt; node = range ? range-&gt;firstNode() : nullptr;
465     while (node &amp;&amp; node != range-&gt;pastLastNode()) {
466         RefPtr&lt;Node&gt; nextNode = NodeTraversal::next(*node);
467         if ((is&lt;HTMLStyleElement&gt;(*node) &amp;&amp; !downcast&lt;HTMLStyleElement&gt;(*node).hasAttributeWithoutSynchronization(scopedAttr)) || is&lt;HTMLLinkElement&gt;(*node)) {
468             nextNode = NodeTraversal::nextSkippingChildren(*node);
469             RefPtr&lt;ContainerNode&gt; rootEditableElement = node-&gt;rootEditableElement();
470             if (rootEditableElement) {
471                 removeNode(*node);
472                 appendNode(*node, *rootEditableElement);
473             }
474         }
475         node = nextNode;
476     }
477 }
478 
479 void DeleteSelectionCommand::handleGeneralDelete()
480 {
481     if (m_upstreamStart.isNull())
482         return;
483 
484     int startOffset = m_upstreamStart.deprecatedEditingOffset();
485     Node* startNode = m_upstreamStart.deprecatedNode();
486 
487     makeStylingElementsDirectChildrenOfEditableRootToPreventStyleLoss();
488 
489     // Never remove the start block unless it&#39;s a table, in which case we won&#39;t merge content in.
490     if (startNode == m_startBlock &amp;&amp; !startOffset &amp;&amp; canHaveChildrenForEditing(*startNode) &amp;&amp; !is&lt;HTMLTableElement&gt;(*startNode)) {
491         startOffset = 0;
492         startNode = NodeTraversal::next(*startNode);
493         if (!startNode)
494             return;
495     }
496 
497     int startNodeCaretMaxOffset = caretMaxOffset(*startNode);
498     if (startOffset &gt;= startNodeCaretMaxOffset &amp;&amp; is&lt;Text&gt;(*startNode)) {
499         Text&amp; text = downcast&lt;Text&gt;(*startNode);
500         if (text.length() &gt; static_cast&lt;unsigned&gt;(startNodeCaretMaxOffset))
501             deleteTextFromNode(text, startNodeCaretMaxOffset, text.length() - startNodeCaretMaxOffset);
502     }
503 
504     if (startOffset &gt;= lastOffsetForEditing(*startNode)) {
505         startNode = NodeTraversal::nextSkippingChildren(*startNode);
506         startOffset = 0;
507     }
508 
509     // Done adjusting the start.  See if we&#39;re all done.
510     if (!startNode)
511         return;
512 
513     if (startNode == m_downstreamEnd.deprecatedNode()) {
514         if (m_downstreamEnd.deprecatedEditingOffset() - startOffset &gt; 0) {
515             if (is&lt;Text&gt;(*startNode)) {
516                 // in a text node that needs to be trimmed
517                 Text&amp; text = downcast&lt;Text&gt;(*startNode);
518                 deleteTextFromNode(text, startOffset, m_downstreamEnd.deprecatedEditingOffset() - startOffset);
519             } else {
520                 removeChildrenInRange(*startNode, startOffset, m_downstreamEnd.deprecatedEditingOffset());
521                 m_endingPosition = m_upstreamStart;
522             }
523         }
524 
525         // The selection to delete is all in one node.
526         if (!startNode-&gt;renderer() || (!startOffset &amp;&amp; m_downstreamEnd.atLastEditingPositionForNode()))
527             removeNode(*startNode);
528     }
529     else {
530         bool startNodeWasDescendantOfEndNode = m_upstreamStart.deprecatedNode()-&gt;isDescendantOf(m_downstreamEnd.deprecatedNode());
531         // The selection to delete spans more than one node.
532         RefPtr&lt;Node&gt; node(startNode);
533 
534         if (startOffset &gt; 0) {
535             if (is&lt;Text&gt;(*startNode)) {
536                 // in a text node that needs to be trimmed
537                 Text&amp; text = downcast&lt;Text&gt;(*node);
538                 deleteTextFromNode(text, startOffset, text.length() - startOffset);
539                 node = NodeTraversal::next(*node);
540             } else {
541                 node = startNode-&gt;traverseToChildAt(startOffset);
542             }
543         } else if (startNode == m_upstreamEnd.deprecatedNode() &amp;&amp; is&lt;Text&gt;(*startNode)) {
544             Text&amp; text = downcast&lt;Text&gt;(*m_upstreamEnd.deprecatedNode());
545             deleteTextFromNode(text, 0, m_upstreamEnd.deprecatedEditingOffset());
546         }
547 
548         // handle deleting all nodes that are completely selected
549         while (node &amp;&amp; node != m_downstreamEnd.deprecatedNode()) {
550             if (comparePositions(firstPositionInOrBeforeNode(node.get()), m_downstreamEnd) &gt;= 0) {
551                 // NodeTraversal::nextSkippingChildren just blew past the end position, so stop deleting
552                 node = nullptr;
553             } else if (!m_downstreamEnd.deprecatedNode()-&gt;isDescendantOf(*node)) {
554                 RefPtr&lt;Node&gt; nextNode = NodeTraversal::nextSkippingChildren(*node);
555                 // if we just removed a node from the end container, update end position so the
556                 // check above will work
557                 updatePositionForNodeRemoval(m_downstreamEnd, *node);
558                 removeNode(*node);
559                 node = nextNode.get();
560             } else {
561                 Node* n = node-&gt;lastDescendant();
562                 if (m_downstreamEnd.deprecatedNode() == n &amp;&amp; m_downstreamEnd.deprecatedEditingOffset() &gt;= caretMaxOffset(*n)) {
563                     removeNode(*node);
564                     node = nullptr;
565                 } else
566                     node = NodeTraversal::next(*node);
567             }
568         }
569 
<a name="3" id="anc3"></a><span class="line-modified">570         if (m_downstreamEnd.deprecatedNode() != startNode &amp;&amp; !m_upstreamStart.deprecatedNode()-&gt;isDescendantOf(m_downstreamEnd.deprecatedNode()) &amp;&amp; m_downstreamEnd.anchorNode()-&gt;isConnected() &amp;&amp; m_downstreamEnd.deprecatedEditingOffset() &gt;= caretMinOffset(*m_downstreamEnd.deprecatedNode())) {</span>


571             if (m_downstreamEnd.atLastEditingPositionForNode() &amp;&amp; !canHaveChildrenForEditing(*m_downstreamEnd.deprecatedNode())) {
572                 // The node itself is fully selected, not just its contents.  Delete it.
573                 removeNode(*m_downstreamEnd.deprecatedNode());
574             } else {
575                 if (is&lt;Text&gt;(*m_downstreamEnd.deprecatedNode())) {
576                     // in a text node that needs to be trimmed
577                     Text&amp; text = downcast&lt;Text&gt;(*m_downstreamEnd.deprecatedNode());
578                     if (m_downstreamEnd.deprecatedEditingOffset() &gt; 0) {
579                         deleteTextFromNode(text, 0, m_downstreamEnd.deprecatedEditingOffset());
580                     }
581                 // Remove children of m_downstreamEnd.deprecatedNode() that come after m_upstreamStart.
582                 // Don&#39;t try to remove children if m_upstreamStart was inside m_downstreamEnd.deprecatedNode()
583                 // and m_upstreamStart has been removed from the document, because then we don&#39;t
584                 // know how many children to remove.
585                 // FIXME: Make m_upstreamStart a position we update as we remove content, then we can
586                 // always know which children to remove.
587                 } else if (!(startNodeWasDescendantOfEndNode &amp;&amp; !m_upstreamStart.anchorNode()-&gt;isConnected())) {
588                     unsigned offset = 0;
589                     if (m_upstreamStart.deprecatedNode()-&gt;isDescendantOf(m_downstreamEnd.deprecatedNode())) {
590                         Node* n = m_upstreamStart.deprecatedNode();
591                         while (n &amp;&amp; n-&gt;parentNode() != m_downstreamEnd.deprecatedNode())
592                             n = n-&gt;parentNode();
593                         if (n)
594                             offset = n-&gt;computeNodeIndex() + 1;
595                     }
596                     removeChildrenInRange(*m_downstreamEnd.deprecatedNode(), offset, m_downstreamEnd.deprecatedEditingOffset());
597                     m_downstreamEnd = createLegacyEditingPosition(m_downstreamEnd.deprecatedNode(), offset);
598                 }
599             }
600         }
601     }
602 }
603 
604 void DeleteSelectionCommand::fixupWhitespace()
605 {
606     document().updateLayoutIgnorePendingStylesheets();
607     // FIXME: isRenderedCharacter should be removed, and we should use VisiblePosition::characterAfter and VisiblePosition::characterBefore
608     if (m_leadingWhitespace.isNotNull() &amp;&amp; !m_leadingWhitespace.isRenderedCharacter() &amp;&amp; is&lt;Text&gt;(*m_leadingWhitespace.deprecatedNode())) {
609         Text&amp; textNode = downcast&lt;Text&gt;(*m_leadingWhitespace.deprecatedNode());
610         ASSERT(!textNode.renderer() || textNode.renderer()-&gt;style().collapseWhiteSpace());
611         replaceTextInNodePreservingMarkers(textNode, m_leadingWhitespace.deprecatedEditingOffset(), 1, nonBreakingSpaceString());
612     }
613     if (m_trailingWhitespace.isNotNull() &amp;&amp; !m_trailingWhitespace.isRenderedCharacter() &amp;&amp; is&lt;Text&gt;(*m_trailingWhitespace.deprecatedNode())) {
614         Text&amp; textNode = downcast&lt;Text&gt;(*m_trailingWhitespace.deprecatedNode());
615         ASSERT(!textNode.renderer() || textNode.renderer()-&gt;style().collapseWhiteSpace());
616         replaceTextInNodePreservingMarkers(textNode, m_trailingWhitespace.deprecatedEditingOffset(), 1, nonBreakingSpaceString());
617     }
618 }
619 
620 // If a selection starts in one block and ends in another, we have to merge to bring content before the
621 // start together with content after the end.
622 void DeleteSelectionCommand::mergeParagraphs()
623 {
624     if (!m_mergeBlocksAfterDelete) {
625         if (m_pruneStartBlockIfNecessary) {
626             // We aren&#39;t going to merge into the start block, so remove it if it&#39;s empty.
627             prune(m_startBlock.get());
628             // Removing the start block during a deletion is usually an indication that we need
629             // a placeholder, but not in this case.
630             m_needPlaceholder = false;
631         }
632         return;
633     }
634 
635     // It shouldn&#39;t have been asked to both try and merge content into the start block and prune it.
636     ASSERT(!m_pruneStartBlockIfNecessary);
637 
638     // FIXME: Deletion should adjust selection endpoints as it removes nodes so that we never get into this state (4099839).
<a name="4" id="anc4"></a><span class="line-modified">639     if (!m_downstreamEnd.anchorNode()-&gt;isConnected() || !m_upstreamStart.anchorNode()-&gt;isConnected())</span>
640          return;
641 
642     // FIXME: The deletion algorithm shouldn&#39;t let this happen.
643     if (comparePositions(m_upstreamStart, m_downstreamEnd) &gt; 0)
644         return;
645 
646     // There&#39;s nothing to merge.
647     if (m_upstreamStart == m_downstreamEnd)
648         return;
649 
650     VisiblePosition startOfParagraphToMove(m_downstreamEnd);
651     VisiblePosition mergeDestination(m_upstreamStart);
652 
653     // m_downstreamEnd&#39;s block has been emptied out by deletion.  There is no content inside of it to
654     // move, so just remove it.
655     Element* endBlock = enclosingBlock(m_downstreamEnd.deprecatedNode());
656     if (!endBlock)
657         return;
658 
659     if (!endBlock-&gt;contains(startOfParagraphToMove.deepEquivalent().deprecatedNode()) || !startOfParagraphToMove.deepEquivalent().deprecatedNode()) {
660         removeNode(*endBlock);
661         return;
662     }
663 
664     // We need to merge into m_upstreamStart&#39;s block, but it&#39;s been emptied out and collapsed by deletion.
665     if (!mergeDestination.deepEquivalent().deprecatedNode() || !mergeDestination.deepEquivalent().deprecatedNode()-&gt;isDescendantOf(enclosingBlock(m_upstreamStart.containerNode())) || m_startsAtEmptyLine) {
666         insertNodeAt(HTMLBRElement::create(document()), m_upstreamStart);
667         mergeDestination = VisiblePosition(m_upstreamStart);
668     }
669 
670     if (mergeDestination == startOfParagraphToMove)
671         return;
672 
673     VisiblePosition endOfParagraphToMove = endOfParagraph(startOfParagraphToMove, CanSkipOverEditingBoundary);
674 
675     if (mergeDestination == endOfParagraphToMove)
676         return;
677 
678     // The rule for merging into an empty block is: only do so if its farther to the right.
679     // FIXME: Consider RTL.
680     if (!m_startsAtEmptyLine &amp;&amp; isStartOfParagraph(mergeDestination) &amp;&amp; startOfParagraphToMove.absoluteCaretBounds().x() &gt; mergeDestination.absoluteCaretBounds().x()) {
681         if (mergeDestination.deepEquivalent().downstream().deprecatedNode()-&gt;hasTagName(brTag)) {
682             removeNodeAndPruneAncestors(*mergeDestination.deepEquivalent().downstream().deprecatedNode());
683             m_endingPosition = startOfParagraphToMove.deepEquivalent();
684             return;
685         }
686     }
687 
688     // Block images, tables and horizontal rules cannot be made inline with content at mergeDestination.  If there is
689     // any (!isStartOfParagraph(mergeDestination)), don&#39;t merge, just move the caret to just before the selection we deleted.
690     // See https://bugs.webkit.org/show_bug.cgi?id=25439
691     if (isRenderedAsNonInlineTableImageOrHR(startOfParagraphToMove.deepEquivalent().deprecatedNode()) &amp;&amp; !isStartOfParagraph(mergeDestination)) {
692         m_endingPosition = m_upstreamStart;
693         return;
694     }
695 
696     auto range = Range::create(document(), startOfParagraphToMove.deepEquivalent().parentAnchoredEquivalent(), endOfParagraphToMove.deepEquivalent().parentAnchoredEquivalent());
697     auto rangeToBeReplaced = Range::create(document(), mergeDestination.deepEquivalent().parentAnchoredEquivalent(), mergeDestination.deepEquivalent().parentAnchoredEquivalent());
698     if (!frame().editor().client()-&gt;shouldMoveRangeAfterDelete(range.ptr(), rangeToBeReplaced.ptr()))
699         return;
700 
701     // moveParagraphs will insert placeholders if it removes blocks that would require their use, don&#39;t let block
702     // removals that it does cause the insertion of *another* placeholder.
703     bool needPlaceholder = m_needPlaceholder;
704     bool paragraphToMergeIsEmpty = (startOfParagraphToMove == endOfParagraphToMove);
705     moveParagraph(startOfParagraphToMove, endOfParagraphToMove, mergeDestination, false, !paragraphToMergeIsEmpty);
706     m_needPlaceholder = needPlaceholder;
707     // The endingPosition was likely clobbered by the move, so recompute it (moveParagraph selects the moved paragraph).
708     m_endingPosition = endingSelection().start();
709 }
710 
711 void DeleteSelectionCommand::removePreviouslySelectedEmptyTableRows()
712 {
713     if (m_endTableRow &amp;&amp; m_endTableRow-&gt;isConnected() &amp;&amp; m_endTableRow != m_startTableRow) {
714         Node* row = m_endTableRow-&gt;previousSibling();
715         while (row &amp;&amp; row != m_startTableRow) {
716             RefPtr&lt;Node&gt; previousRow = row-&gt;previousSibling();
717             if (isTableRowEmpty(row))
718                 // Use a raw removeNode, instead of DeleteSelectionCommand&#39;s, because
719                 // that won&#39;t remove rows, it only empties them in preparation for this function.
720                 CompositeEditCommand::removeNode(*row);
721             row = previousRow.get();
722         }
723     }
724 
725     // Remove empty rows after the start row.
726     if (m_startTableRow &amp;&amp; m_startTableRow-&gt;isConnected() &amp;&amp; m_startTableRow != m_endTableRow) {
727         Node* row = m_startTableRow-&gt;nextSibling();
728         while (row &amp;&amp; row != m_endTableRow) {
729             RefPtr&lt;Node&gt; nextRow = row-&gt;nextSibling();
730             if (isTableRowEmpty(row))
731                 CompositeEditCommand::removeNode(*row);
732             row = nextRow.get();
733         }
734     }
735 
736     if (m_endTableRow &amp;&amp; m_endTableRow-&gt;isConnected() &amp;&amp; m_endTableRow != m_startTableRow) {
737         if (isTableRowEmpty(m_endTableRow.get())) {
738             // Don&#39;t remove m_endTableRow if it&#39;s where we&#39;re putting the ending selection.
739             if (!m_endingPosition.deprecatedNode()-&gt;isDescendantOf(*m_endTableRow)) {
740                 // FIXME: We probably shouldn&#39;t remove m_endTableRow unless it&#39;s fully selected, even if it is empty.
741                 // We&#39;ll need to start adjusting the selection endpoints during deletion to know whether or not m_endTableRow
742                 // was fully selected here.
743                 CompositeEditCommand::removeNode(*m_endTableRow);
744             }
745         }
746     }
747 }
748 
749 void DeleteSelectionCommand::calculateTypingStyleAfterDelete()
750 {
751     if (!m_typingStyle)
752         return;
753 
754     // Compute the difference between the style before the delete and the style now
755     // after the delete has been done. Set this style on the frame, so other editing
756     // commands being composed with this one will work, and also cache it on the command,
757     // so the Frame::appliedEditing can set it after the whole composite command
758     // has completed.
759 
760     // If we deleted into a blockquote, but are now no longer in a blockquote, use the alternate typing style
761     if (m_deleteIntoBlockquoteStyle &amp;&amp; !enclosingNodeOfType(m_endingPosition, isMailBlockquote, CanCrossEditingBoundary))
762         m_typingStyle = m_deleteIntoBlockquoteStyle;
763     m_deleteIntoBlockquoteStyle = nullptr;
764 
765     m_typingStyle-&gt;prepareToApplyAt(m_endingPosition);
766     if (m_typingStyle-&gt;isEmpty())
767         m_typingStyle = nullptr;
768     // This is where we&#39;ve deleted all traces of a style but not a whole paragraph (that&#39;s handled above).
769     // In this case if we start typing, the new characters should have the same style as the just deleted ones,
770     // but, if we change the selection, come back and start typing that style should be lost.  Also see
771     // preserveTypingStyle() below.
772     frame().selection().setTypingStyle(m_typingStyle.copyRef());
773 }
774 
775 void DeleteSelectionCommand::clearTransientState()
776 {
777     m_selectionToDelete = VisibleSelection();
778     m_upstreamStart.clear();
779     m_downstreamStart.clear();
780     m_upstreamEnd.clear();
781     m_downstreamEnd.clear();
782     m_endingPosition.clear();
783     m_leadingWhitespace.clear();
784     m_trailingWhitespace.clear();
785 }
786 
787 String DeleteSelectionCommand::originalStringForAutocorrectionAtBeginningOfSelection()
788 {
789     if (!m_selectionToDelete.isRange())
790         return String();
791 
792     VisiblePosition startOfSelection = m_selectionToDelete.start();
793     if (!isStartOfWord(startOfSelection))
794         return String();
795 
796     VisiblePosition nextPosition = startOfSelection.next();
797     if (nextPosition.isNull())
798         return String();
799 
800     auto rangeOfFirstCharacter = Range::create(document(), startOfSelection.deepEquivalent(), nextPosition.deepEquivalent());
801     for (auto* marker : document().markers().markersInRange(rangeOfFirstCharacter, DocumentMarker::Autocorrected)) {
802         int startOffset = marker-&gt;startOffset();
803         if (startOffset == startOfSelection.deepEquivalent().offsetInContainerNode())
804             return marker-&gt;description();
805     }
806     return String();
807 }
808 
809 // This method removes div elements with no attributes that have only one child or no children at all.
810 void DeleteSelectionCommand::removeRedundantBlocks()
811 {
812     Node* node = m_endingPosition.containerNode();
813     Node* rootNode = node-&gt;rootEditableElement();
814 
815     while (node != rootNode) {
816         if (isRemovableBlock(node)) {
817             if (node == m_endingPosition.anchorNode())
818                 updatePositionForNodeRemovalPreservingChildren(m_endingPosition, *node);
819 
820             CompositeEditCommand::removeNodePreservingChildren(*node);
821             node = m_endingPosition.anchorNode();
822         } else
823             node = node-&gt;parentNode();
824     }
825 }
826 
827 void DeleteSelectionCommand::doApply()
828 {
829     // If selection has not been set to a custom selection when the command was created,
830     // use the current ending selection.
831     if (!m_hasSelectionToDelete)
832         m_selectionToDelete = endingSelection();
833 
834     if (!m_selectionToDelete.isNonOrphanedRange())
835         return;
836 
837     String originalString = originalStringForAutocorrectionAtBeginningOfSelection();
838 
839     // If the deletion is occurring in a text field, and we&#39;re not deleting to replace the selection, then let the frame call across the bridge to notify the form delegate.
840     if (!m_replace) {
841         Element* textControl = enclosingTextFormControl(m_selectionToDelete.start());
842         if (textControl &amp;&amp; textControl-&gt;focused())
843             frame().editor().textWillBeDeletedInTextField(textControl);
844     }
845 
846     // save this to later make the selection with
847     EAffinity affinity = m_selectionToDelete.affinity();
848 
849     Position downstreamEnd = m_selectionToDelete.end().downstream();
850     m_needPlaceholder = isStartOfParagraph(m_selectionToDelete.visibleStart(), CanCrossEditingBoundary)
851             &amp;&amp; isEndOfParagraph(m_selectionToDelete.visibleEnd(), CanCrossEditingBoundary)
852             &amp;&amp; !lineBreakExistsAtVisiblePosition(m_selectionToDelete.visibleEnd());
853     if (m_needPlaceholder) {
854         // Don&#39;t need a placeholder when deleting a selection that starts just before a table
855         // and ends inside it (we do need placeholders to hold open empty cells, but that&#39;s
856         // handled elsewhere).
857         if (auto* table = isLastPositionBeforeTable(m_selectionToDelete.visibleStart())) {
858             if (m_selectionToDelete.end().deprecatedNode()-&gt;isDescendantOf(*table))
859                 m_needPlaceholder = false;
860         }
861     }
862 
863 
864     // set up our state
865     if (!initializePositionData())
866         return;
867 
868     // Delete any text that may hinder our ability to fixup whitespace after the delete
869     deleteInsignificantTextDownstream(m_trailingWhitespace);
870 
871     saveTypingStyleState();
872 
873     // deleting just a BR is handled specially, at least because we do not
874     // want to replace it with a placeholder BR!
875     if (handleSpecialCaseBRDelete()) {
876         calculateTypingStyleAfterDelete();
877         setEndingSelection(VisibleSelection(m_endingPosition, affinity, endingSelection().isDirectional()));
878         clearTransientState();
879         rebalanceWhitespace();
880         return;
881     }
882 
883     handleGeneralDelete();
884 
885     fixupWhitespace();
886 
887     mergeParagraphs();
888 
889     removePreviouslySelectedEmptyTableRows();
890 
891     if (m_needPlaceholder) {
892         if (m_sanitizeMarkup)
893             removeRedundantBlocks();
894         insertNodeAt(HTMLBRElement::create(document()), m_endingPosition);
895     }
896 
897     bool shouldRebalaceWhiteSpace = true;
898     if (!frame().editor().behavior().shouldRebalanceWhiteSpacesInSecureField()) {
899         Node* node = m_endingPosition.deprecatedNode();
900         if (is&lt;Text&gt;(node)) {
901             Text&amp; textNode = downcast&lt;Text&gt;(*node);
902             if (textNode.length() &amp;&amp; textNode.renderer())
903                 shouldRebalaceWhiteSpace = textNode.renderer()-&gt;style().textSecurity() == TextSecurity::None;
904         }
905     }
906     if (shouldRebalaceWhiteSpace)
907         rebalanceWhitespaceAt(m_endingPosition);
908 
909     calculateTypingStyleAfterDelete();
910 
911     if (!originalString.isEmpty())
912         frame().editor().deletedAutocorrectionAtPosition(m_endingPosition, originalString);
913 
914     setEndingSelection(VisibleSelection(m_endingPosition, affinity, endingSelection().isDirectional()));
915     clearTransientState();
916 }
917 
918 // Normally deletion doesn&#39;t preserve the typing style that was present before it.  For example,
919 // type a character, Bold, then delete the character and start typing.  The Bold typing style shouldn&#39;t
920 // stick around.  Deletion should preserve a typing style that *it* sets, however.
921 bool DeleteSelectionCommand::preservesTypingStyle() const
922 {
923     return m_typingStyle;
924 }
925 
926 } // namespace WebCore
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>