<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrInterpreter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2009, 2013-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2010 Peter Varga (pvarga@inf.u-szeged.hu), University of Szeged
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;YarrInterpreter.h&quot;
  29 
  30 #include &quot;Options.h&quot;
  31 #include &quot;SuperSampler.h&quot;
  32 #include &quot;Yarr.h&quot;
  33 #include &quot;YarrCanonicalize.h&quot;
  34 #include &lt;wtf/BumpPointerAllocator.h&gt;
  35 #include &lt;wtf/CheckedArithmetic.h&gt;
  36 #include &lt;wtf/DataLog.h&gt;
  37 #include &lt;wtf/text/CString.h&gt;
  38 #include &lt;wtf/text/WTFString.h&gt;
  39 
  40 namespace JSC { namespace Yarr {
  41 
  42 template&lt;typename CharType&gt;
  43 class Interpreter {
  44 public:
  45     struct ParenthesesDisjunctionContext;
  46 
  47     struct BackTrackInfoParentheses {
  48         uintptr_t matchAmount;
  49         ParenthesesDisjunctionContext* lastContext;
  50     };
  51 
  52     static inline void appendParenthesesDisjunctionContext(BackTrackInfoParentheses* backTrack, ParenthesesDisjunctionContext* context)
  53     {
  54         context-&gt;next = backTrack-&gt;lastContext;
  55         backTrack-&gt;lastContext = context;
  56         ++backTrack-&gt;matchAmount;
  57     }
  58 
  59     static inline void popParenthesesDisjunctionContext(BackTrackInfoParentheses* backTrack)
  60     {
  61         RELEASE_ASSERT(backTrack-&gt;matchAmount);
  62         RELEASE_ASSERT(backTrack-&gt;lastContext);
  63         backTrack-&gt;lastContext = backTrack-&gt;lastContext-&gt;next;
  64         --backTrack-&gt;matchAmount;
  65     }
  66 
  67     struct DisjunctionContext
  68     {
  69         DisjunctionContext() = default;
  70 
  71         void* operator new(size_t, void* where)
  72         {
  73             return where;
  74         }
  75 
  76         static size_t allocationSize(unsigned numberOfFrames)
  77         {
  78             static_assert(alignof(DisjunctionContext) &lt;= sizeof(void*), &quot;&quot;);
  79             size_t rawSize = (sizeof(DisjunctionContext) - sizeof(uintptr_t) + Checked&lt;size_t&gt;(numberOfFrames) * sizeof(uintptr_t)).unsafeGet();
  80             size_t roundedSize = roundUpToMultipleOf&lt;sizeof(void*)&gt;(rawSize);
  81             RELEASE_ASSERT(roundedSize &gt;= rawSize);
  82             return roundedSize;
  83         }
  84 
  85         int term { 0 };
  86         unsigned matchBegin;
  87         unsigned matchEnd;
  88         uintptr_t frame[1];
  89     };
  90 
  91     DisjunctionContext* allocDisjunctionContext(ByteDisjunction* disjunction)
  92     {
  93         size_t size = DisjunctionContext::allocationSize(disjunction-&gt;m_frameSize);
  94         allocatorPool = allocatorPool-&gt;ensureCapacity(size);
  95         RELEASE_ASSERT(allocatorPool);
  96         return new (allocatorPool-&gt;alloc(size)) DisjunctionContext();
  97     }
  98 
  99     void freeDisjunctionContext(DisjunctionContext* context)
 100     {
 101         allocatorPool = allocatorPool-&gt;dealloc(context);
 102     }
 103 
 104     struct ParenthesesDisjunctionContext
 105     {
 106         ParenthesesDisjunctionContext(unsigned* output, ByteTerm&amp; term)
 107         {
 108             unsigned firstSubpatternId = term.atom.subpatternId;
 109             unsigned numNestedSubpatterns = term.atom.parenthesesDisjunction-&gt;m_numSubpatterns;
 110 
 111             for (unsigned i = 0; i &lt; (numNestedSubpatterns &lt;&lt; 1); ++i) {
 112                 subpatternBackup[i] = output[(firstSubpatternId &lt;&lt; 1) + i];
 113                 output[(firstSubpatternId &lt;&lt; 1) + i] = offsetNoMatch;
 114             }
 115 
 116             new (getDisjunctionContext(term)) DisjunctionContext();
 117         }
 118 
 119         void* operator new(size_t, void* where)
 120         {
 121             return where;
 122         }
 123 
 124         void restoreOutput(unsigned* output, unsigned firstSubpatternId, unsigned numNestedSubpatterns)
 125         {
 126             for (unsigned i = 0; i &lt; (numNestedSubpatterns &lt;&lt; 1); ++i)
 127                 output[(firstSubpatternId &lt;&lt; 1) + i] = subpatternBackup[i];
 128         }
 129 
 130         DisjunctionContext* getDisjunctionContext(ByteTerm&amp; term)
 131         {
 132             return bitwise_cast&lt;DisjunctionContext*&gt;(bitwise_cast&lt;uintptr_t&gt;(this) + allocationSize(term.atom.parenthesesDisjunction-&gt;m_numSubpatterns));
 133         }
 134 
 135         static size_t allocationSize(unsigned numberOfSubpatterns)
 136         {
 137             static_assert(alignof(ParenthesesDisjunctionContext) &lt;= sizeof(void*), &quot;&quot;);
 138             size_t rawSize = (sizeof(ParenthesesDisjunctionContext) - sizeof(unsigned) + (Checked&lt;size_t&gt;(numberOfSubpatterns) * 2U) * sizeof(unsigned)).unsafeGet();
 139             size_t roundedSize = roundUpToMultipleOf&lt;sizeof(void*)&gt;(rawSize);
 140             RELEASE_ASSERT(roundedSize &gt;= rawSize);
 141             return roundedSize;
 142         }
 143 
 144         ParenthesesDisjunctionContext* next { nullptr };
 145         unsigned subpatternBackup[1];
 146     };
 147 
 148     ParenthesesDisjunctionContext* allocParenthesesDisjunctionContext(ByteDisjunction* disjunction, unsigned* output, ByteTerm&amp; term)
 149     {
 150         size_t size = (Checked&lt;size_t&gt;(ParenthesesDisjunctionContext::allocationSize(term.atom.parenthesesDisjunction-&gt;m_numSubpatterns)) + DisjunctionContext::allocationSize(disjunction-&gt;m_frameSize)).unsafeGet();
 151         allocatorPool = allocatorPool-&gt;ensureCapacity(size);
 152         RELEASE_ASSERT(allocatorPool);
 153         return new (allocatorPool-&gt;alloc(size)) ParenthesesDisjunctionContext(output, term);
 154     }
 155 
 156     void freeParenthesesDisjunctionContext(ParenthesesDisjunctionContext* context)
 157     {
 158         allocatorPool = allocatorPool-&gt;dealloc(context);
 159     }
 160 
 161     class InputStream {
 162     public:
 163         InputStream(const CharType* input, unsigned start, unsigned length, bool decodeSurrogatePairs)
 164             : input(input)
 165             , pos(start)
 166             , length(length)
 167             , decodeSurrogatePairs(decodeSurrogatePairs)
 168         {
 169         }
 170 
 171         void next()
 172         {
 173             ++pos;
 174         }
 175 
 176         void rewind(unsigned amount)
 177         {
 178             ASSERT(pos &gt;= amount);
 179             pos -= amount;
 180         }
 181 
 182         int read()
 183         {
 184             ASSERT(pos &lt; length);
 185             if (pos &lt; length)
 186                 return input[pos];
 187             return -1;
 188         }
 189 
 190         int readPair()
 191         {
 192             ASSERT(pos + 1 &lt; length);
 193             return input[pos] | input[pos + 1] &lt;&lt; 16;
 194         }
 195 
 196         int readChecked(unsigned negativePositionOffest)
 197         {
 198             RELEASE_ASSERT(pos &gt;= negativePositionOffest);
 199             unsigned p = pos - negativePositionOffest;
 200             ASSERT(p &lt; length);
 201             int result = input[p];
 202             if (U16_IS_LEAD(result) &amp;&amp; decodeSurrogatePairs &amp;&amp; p + 1 &lt; length &amp;&amp; U16_IS_TRAIL(input[p + 1])) {
 203                 if (atEnd())
 204                     return -1;
 205 
 206                 result = U16_GET_SUPPLEMENTARY(result, input[p + 1]);
 207                 next();
 208             }
 209             return result;
 210         }
 211 
 212         int readSurrogatePairChecked(unsigned negativePositionOffset)
 213         {
 214             RELEASE_ASSERT(pos &gt;= negativePositionOffset);
 215             unsigned p = pos - negativePositionOffset;
 216             ASSERT(p &lt; length);
 217             if (p + 1 &gt;= length)
 218                 return -1;
 219 
 220             int first = input[p];
 221             int second = input[p + 1];
 222             if (U16_IS_LEAD(first) &amp;&amp; U16_IS_TRAIL(second))
 223                 return U16_GET_SUPPLEMENTARY(first, second);
 224 
 225             return -1;
 226         }
 227 
 228         int reread(unsigned from)
 229         {
 230             ASSERT(from &lt; length);
 231             int result = input[from];
 232             if (U16_IS_LEAD(result) &amp;&amp; decodeSurrogatePairs &amp;&amp; from + 1 &lt; length &amp;&amp; U16_IS_TRAIL(input[from + 1]))
 233                 result = U16_GET_SUPPLEMENTARY(result, input[from + 1]);
 234             return result;
 235         }
 236 
 237         int prev()
 238         {
 239             ASSERT(!(pos &gt; length));
 240             if (pos &amp;&amp; length)
 241                 return input[pos - 1];
 242             return -1;
 243         }
 244 
 245         unsigned getPos()
 246         {
 247             return pos;
 248         }
 249 
 250         void setPos(unsigned p)
 251         {
 252             pos = p;
 253         }
 254 
 255         bool atStart()
 256         {
 257             return pos == 0;
 258         }
 259 
 260         bool atEnd()
 261         {
 262             return pos == length;
 263         }
 264 
 265         unsigned end()
 266         {
 267             return length;
 268         }
 269 
 270         bool checkInput(unsigned count)
 271         {
 272             if (((pos + count) &lt;= length) &amp;&amp; ((pos + count) &gt;= pos)) {
 273                 pos += count;
 274                 return true;
 275             }
 276             return false;
 277         }
 278 
 279         void uncheckInput(unsigned count)
 280         {
 281             RELEASE_ASSERT(pos &gt;= count);
 282             pos -= count;
 283         }
 284 
 285         bool atStart(unsigned negativePositionOffset)
 286         {
 287             return pos == negativePositionOffset;
 288         }
 289 
 290         bool atEnd(unsigned negativePositionOffest)
 291         {
 292             RELEASE_ASSERT(pos &gt;= negativePositionOffest);
 293             return (pos - negativePositionOffest) == length;
 294         }
 295 
 296         bool isAvailableInput(unsigned offset)
 297         {
 298             return (((pos + offset) &lt;= length) &amp;&amp; ((pos + offset) &gt;= pos));
 299         }
 300 
 301     private:
 302         const CharType* input;
 303         unsigned pos;
 304         unsigned length;
 305         bool decodeSurrogatePairs;
 306     };
 307 
 308     bool testCharacterClass(CharacterClass* characterClass, int ch)
 309     {
 310         auto linearSearchMatches = [&amp;ch](const Vector&lt;UChar32&gt;&amp; matches) {
 311             for (unsigned i = 0; i &lt; matches.size(); ++i) {
 312                 if (ch == matches[i])
 313                     return true;
 314             }
 315 
 316             return false;
 317         };
 318 
 319         auto binarySearchMatches = [&amp;ch](const Vector&lt;UChar32&gt;&amp; matches) {
 320             size_t low = 0;
 321             size_t high = matches.size() - 1;
 322 
 323             while (low &lt;= high) {
 324                 size_t mid = low + (high - low) / 2;
 325                 int diff = ch - matches[mid];
 326                 if (!diff)
 327                     return true;
 328 
 329                 if (diff &lt; 0) {
 330                     if (mid == low)
 331                         return false;
 332                     high = mid - 1;
 333                 } else
 334                     low = mid + 1;
 335             }
 336             return false;
 337         };
 338 
 339         auto linearSearchRanges = [&amp;ch](const Vector&lt;CharacterRange&gt;&amp; ranges) {
 340             for (unsigned i = 0; i &lt; ranges.size(); ++i) {
 341                 if ((ch &gt;= ranges[i].begin) &amp;&amp; (ch &lt;= ranges[i].end))
 342                     return true;
 343             }
 344 
 345             return false;
 346         };
 347 
 348         auto binarySearchRanges = [&amp;ch](const Vector&lt;CharacterRange&gt;&amp; ranges) {
 349             size_t low = 0;
 350             size_t high = ranges.size() - 1;
 351 
 352             while (low &lt;= high) {
 353                 size_t mid = low + (high - low) / 2;
 354                 int rangeBeginDiff = ch - ranges[mid].begin;
 355                 if (rangeBeginDiff &gt;= 0 &amp;&amp; ch &lt;= ranges[mid].end)
 356                     return true;
 357 
 358                 if (rangeBeginDiff &lt; 0) {
 359                     if (mid == low)
 360                         return false;
 361                     high = mid - 1;
 362                 } else
 363                     low = mid + 1;
 364             }
 365             return false;
 366         };
 367 
 368         if (characterClass-&gt;m_anyCharacter)
 369             return true;
 370 
 371         const size_t thresholdForBinarySearch = 6;
 372 
 373         if (!isASCII(ch)) {
 374             if (characterClass-&gt;m_matchesUnicode.size()) {
 375                 if (characterClass-&gt;m_matchesUnicode.size() &gt; thresholdForBinarySearch) {
 376                     if (binarySearchMatches(characterClass-&gt;m_matchesUnicode))
 377                         return true;
 378                 } else if (linearSearchMatches(characterClass-&gt;m_matchesUnicode))
 379                     return true;
 380             }
 381 
 382             if (characterClass-&gt;m_rangesUnicode.size()) {
 383                 if (characterClass-&gt;m_rangesUnicode.size() &gt; thresholdForBinarySearch) {
 384                     if (binarySearchRanges(characterClass-&gt;m_rangesUnicode))
 385                         return true;
 386                 } else if (linearSearchRanges(characterClass-&gt;m_rangesUnicode))
 387                     return true;
 388             }
 389         } else {
 390             if (characterClass-&gt;m_matches.size()) {
 391                 if (characterClass-&gt;m_matches.size() &gt; thresholdForBinarySearch) {
 392                     if (binarySearchMatches(characterClass-&gt;m_matches))
 393                         return true;
 394                 } else if (linearSearchMatches(characterClass-&gt;m_matches))
 395                     return true;
 396             }
 397 
 398             if (characterClass-&gt;m_ranges.size()) {
 399                 if (characterClass-&gt;m_ranges.size() &gt; thresholdForBinarySearch) {
 400                     if (binarySearchRanges(characterClass-&gt;m_ranges))
 401                         return true;
 402                 } else if (linearSearchRanges(characterClass-&gt;m_ranges))
 403                     return true;
 404             }
 405         }
 406 
 407         return false;
 408     }
 409 
 410     bool checkCharacter(int testChar, unsigned negativeInputOffset)
 411     {
 412         return testChar == input.readChecked(negativeInputOffset);
 413     }
 414 
 415     bool checkSurrogatePair(int testUnicodeChar, unsigned negativeInputOffset)
 416     {
 417         return testUnicodeChar == input.readSurrogatePairChecked(negativeInputOffset);
 418     }
 419 
 420     bool checkCasedCharacter(int loChar, int hiChar, unsigned negativeInputOffset)
 421     {
 422         int ch = input.readChecked(negativeInputOffset);
 423         return (loChar == ch) || (hiChar == ch);
 424     }
 425 
 426     bool checkCharacterClass(CharacterClass* characterClass, bool invert, unsigned negativeInputOffset)
 427     {
 428         bool match = testCharacterClass(characterClass, input.readChecked(negativeInputOffset));
 429         return invert ? !match : match;
 430     }
 431 
<a name="1" id="anc1"></a>





 432     bool tryConsumeBackReference(int matchBegin, int matchEnd, unsigned negativeInputOffset)
 433     {
 434         unsigned matchSize = (unsigned)(matchEnd - matchBegin);
 435 
 436         if (!input.checkInput(matchSize))
 437             return false;
 438 
 439         for (unsigned i = 0; i &lt; matchSize; ++i) {
 440             int oldCh = input.reread(matchBegin + i);
 441             int ch;
 442             if (!U_IS_BMP(oldCh)) {
 443                 ch = input.readSurrogatePairChecked(negativeInputOffset + matchSize - i);
 444                 ++i;
 445             } else
 446                 ch = input.readChecked(negativeInputOffset + matchSize - i);
 447 
 448             if (oldCh == ch)
 449                 continue;
 450 
 451             if (pattern-&gt;ignoreCase()) {
 452                 // See ES 6.0, 21.2.2.8.2 for the definition of Canonicalize(). For non-Unicode
 453                 // patterns, Unicode values are never allowed to match against ASCII ones.
 454                 // For Unicode, we need to check all canonical equivalents of a character.
 455                 if (!unicode &amp;&amp; (isASCII(oldCh) || isASCII(ch))) {
 456                     if (toASCIIUpper(oldCh) == toASCIIUpper(ch))
 457                         continue;
 458                 } else if (areCanonicallyEquivalent(oldCh, ch, unicode ? CanonicalMode::Unicode : CanonicalMode::UCS2))
 459                     continue;
 460             }
 461 
 462             input.uncheckInput(matchSize);
 463             return false;
 464         }
 465 
 466         return true;
 467     }
 468 
 469     bool matchAssertionBOL(ByteTerm&amp; term)
 470     {
 471         return (input.atStart(term.inputPosition)) || (pattern-&gt;multiline() &amp;&amp; testCharacterClass(pattern-&gt;newlineCharacterClass, input.readChecked(term.inputPosition + 1)));
 472     }
 473 
 474     bool matchAssertionEOL(ByteTerm&amp; term)
 475     {
 476         if (term.inputPosition)
 477             return (input.atEnd(term.inputPosition)) || (pattern-&gt;multiline() &amp;&amp; testCharacterClass(pattern-&gt;newlineCharacterClass, input.readChecked(term.inputPosition)));
 478 
 479         return (input.atEnd()) || (pattern-&gt;multiline() &amp;&amp; testCharacterClass(pattern-&gt;newlineCharacterClass, input.read()));
 480     }
 481 
 482     bool matchAssertionWordBoundary(ByteTerm&amp; term)
 483     {
 484         bool prevIsWordchar = !input.atStart(term.inputPosition) &amp;&amp; testCharacterClass(pattern-&gt;wordcharCharacterClass, input.readChecked(term.inputPosition + 1));
 485         bool readIsWordchar;
 486         if (term.inputPosition)
 487             readIsWordchar = !input.atEnd(term.inputPosition) &amp;&amp; testCharacterClass(pattern-&gt;wordcharCharacterClass, input.readChecked(term.inputPosition));
 488         else
 489             readIsWordchar = !input.atEnd() &amp;&amp; testCharacterClass(pattern-&gt;wordcharCharacterClass, input.read());
 490 
 491         bool wordBoundary = prevIsWordchar != readIsWordchar;
 492         return term.invert() ? !wordBoundary : wordBoundary;
 493     }
 494 
 495     bool backtrackPatternCharacter(ByteTerm&amp; term, DisjunctionContext* context)
 496     {
 497         BackTrackInfoPatternCharacter* backTrack = reinterpret_cast&lt;BackTrackInfoPatternCharacter*&gt;(context-&gt;frame + term.frameLocation);
 498 
 499         switch (term.atom.quantityType) {
 500         case QuantifierFixedCount:
 501             break;
 502 
 503         case QuantifierGreedy:
 504             if (backTrack-&gt;matchAmount) {
 505                 --backTrack-&gt;matchAmount;
 506                 input.uncheckInput(U16_LENGTH(term.atom.patternCharacter));
 507                 return true;
 508             }
 509             break;
 510 
 511         case QuantifierNonGreedy:
 512             if ((backTrack-&gt;matchAmount &lt; term.atom.quantityMaxCount) &amp;&amp; input.checkInput(1)) {
 513                 ++backTrack-&gt;matchAmount;
 514                 if (checkCharacter(term.atom.patternCharacter, term.inputPosition + 1))
 515                     return true;
 516             }
 517             input.setPos(backTrack-&gt;begin);
 518             break;
 519         }
 520 
 521         return false;
 522     }
 523 
 524     bool backtrackPatternCasedCharacter(ByteTerm&amp; term, DisjunctionContext* context)
 525     {
 526         BackTrackInfoPatternCharacter* backTrack = reinterpret_cast&lt;BackTrackInfoPatternCharacter*&gt;(context-&gt;frame + term.frameLocation);
 527 
 528         switch (term.atom.quantityType) {
 529         case QuantifierFixedCount:
 530             break;
 531 
 532         case QuantifierGreedy:
 533             if (backTrack-&gt;matchAmount) {
 534                 --backTrack-&gt;matchAmount;
 535                 input.uncheckInput(1);
 536                 return true;
 537             }
 538             break;
 539 
 540         case QuantifierNonGreedy:
 541             if ((backTrack-&gt;matchAmount &lt; term.atom.quantityMaxCount) &amp;&amp; input.checkInput(1)) {
 542                 ++backTrack-&gt;matchAmount;
 543                 if (checkCasedCharacter(term.atom.casedCharacter.lo, term.atom.casedCharacter.hi, term.inputPosition + 1))
 544                     return true;
 545             }
 546             input.uncheckInput(backTrack-&gt;matchAmount);
 547             break;
 548         }
 549 
 550         return false;
 551     }
 552 
 553     bool matchCharacterClass(ByteTerm&amp; term, DisjunctionContext* context)
 554     {
 555         ASSERT(term.type == ByteTerm::TypeCharacterClass);
 556         BackTrackInfoCharacterClass* backTrack = reinterpret_cast&lt;BackTrackInfoCharacterClass*&gt;(context-&gt;frame + term.frameLocation);
 557 
 558         switch (term.atom.quantityType) {
 559         case QuantifierFixedCount: {
 560             if (unicode) {
<a name="2" id="anc2"></a>
 561                 backTrack-&gt;begin = input.getPos();
 562                 unsigned matchAmount = 0;
 563                 for (matchAmount = 0; matchAmount &lt; term.atom.quantityMaxCount; ++matchAmount) {
<a name="3" id="anc3"></a><span class="line-modified"> 564                     if (!checkCharacterClass(term.atom.characterClass, term.invert(), term.inputPosition - matchAmount)) {</span>
<span class="line-modified"> 565                         input.setPos(backTrack-&gt;begin);</span>
<span class="line-modified"> 566                         return false;</span>








 567                     }
 568                 }
 569 
 570                 return true;
 571             }
 572 
 573             for (unsigned matchAmount = 0; matchAmount &lt; term.atom.quantityMaxCount; ++matchAmount) {
 574                 if (!checkCharacterClass(term.atom.characterClass, term.invert(), term.inputPosition - matchAmount))
 575                     return false;
 576             }
 577             return true;
 578         }
 579 
 580         case QuantifierGreedy: {
 581             unsigned position = input.getPos();
 582             backTrack-&gt;begin = position;
 583             unsigned matchAmount = 0;
 584             while ((matchAmount &lt; term.atom.quantityMaxCount) &amp;&amp; input.checkInput(1)) {
 585                 if (!checkCharacterClass(term.atom.characterClass, term.invert(), term.inputPosition + 1)) {
 586                     input.setPos(position);
 587                     break;
 588                 }
 589                 ++matchAmount;
 590                 position = input.getPos();
 591             }
 592             backTrack-&gt;matchAmount = matchAmount;
 593 
 594             return true;
 595         }
 596 
 597         case QuantifierNonGreedy:
 598             backTrack-&gt;begin = input.getPos();
 599             backTrack-&gt;matchAmount = 0;
 600             return true;
 601         }
 602 
 603         RELEASE_ASSERT_NOT_REACHED();
 604         return false;
 605     }
 606 
 607     bool backtrackCharacterClass(ByteTerm&amp; term, DisjunctionContext* context)
 608     {
 609         ASSERT(term.type == ByteTerm::TypeCharacterClass);
 610         BackTrackInfoCharacterClass* backTrack = reinterpret_cast&lt;BackTrackInfoCharacterClass*&gt;(context-&gt;frame + term.frameLocation);
 611 
 612         switch (term.atom.quantityType) {
 613         case QuantifierFixedCount:
 614             if (unicode)
 615                 input.setPos(backTrack-&gt;begin);
 616             break;
 617 
 618         case QuantifierGreedy:
 619             if (backTrack-&gt;matchAmount) {
 620                 if (unicode) {
 621                     // Rematch one less match
 622                     input.setPos(backTrack-&gt;begin);
 623                     --backTrack-&gt;matchAmount;
 624                     for (unsigned matchAmount = 0; (matchAmount &lt; backTrack-&gt;matchAmount) &amp;&amp; input.checkInput(1); ++matchAmount) {
 625                         if (!checkCharacterClass(term.atom.characterClass, term.invert(), term.inputPosition + 1)) {
 626                             input.uncheckInput(1);
 627                             break;
 628                         }
 629                     }
 630                     return true;
 631                 }
 632                 --backTrack-&gt;matchAmount;
 633                 input.uncheckInput(1);
 634                 return true;
 635             }
 636             break;
 637 
 638         case QuantifierNonGreedy:
 639             if ((backTrack-&gt;matchAmount &lt; term.atom.quantityMaxCount) &amp;&amp; input.checkInput(1)) {
 640                 ++backTrack-&gt;matchAmount;
 641                 if (checkCharacterClass(term.atom.characterClass, term.invert(), term.inputPosition + 1))
 642                     return true;
 643             }
 644             input.setPos(backTrack-&gt;begin);
 645             break;
 646         }
 647 
 648         return false;
 649     }
 650 
 651     bool matchBackReference(ByteTerm&amp; term, DisjunctionContext* context)
 652     {
 653         ASSERT(term.type == ByteTerm::TypeBackReference);
 654         BackTrackInfoBackReference* backTrack = reinterpret_cast&lt;BackTrackInfoBackReference*&gt;(context-&gt;frame + term.frameLocation);
 655 
 656         unsigned matchBegin = output[(term.atom.subpatternId &lt;&lt; 1)];
 657         unsigned matchEnd = output[(term.atom.subpatternId &lt;&lt; 1) + 1];
 658 
 659         // If the end position of the referenced match hasn&#39;t set yet then the backreference in the same parentheses where it references to that.
 660         // In this case the result of match is empty string like when it references to a parentheses with zero-width match.
 661         // Eg.: /(a\1)/
 662         if (matchEnd == offsetNoMatch)
 663             return true;
 664 
 665         if (matchBegin == offsetNoMatch)
 666             return true;
 667 
 668         ASSERT(matchBegin &lt;= matchEnd);
 669 
 670         if (matchBegin == matchEnd)
 671             return true;
 672 
 673         switch (term.atom.quantityType) {
 674         case QuantifierFixedCount: {
 675             backTrack-&gt;begin = input.getPos();
 676             for (unsigned matchAmount = 0; matchAmount &lt; term.atom.quantityMaxCount; ++matchAmount) {
 677                 if (!tryConsumeBackReference(matchBegin, matchEnd, term.inputPosition)) {
 678                     input.setPos(backTrack-&gt;begin);
 679                     return false;
 680                 }
 681             }
 682             return true;
 683         }
 684 
 685         case QuantifierGreedy: {
 686             unsigned matchAmount = 0;
 687             while ((matchAmount &lt; term.atom.quantityMaxCount) &amp;&amp; tryConsumeBackReference(matchBegin, matchEnd, term.inputPosition))
 688                 ++matchAmount;
 689             backTrack-&gt;matchAmount = matchAmount;
 690             return true;
 691         }
 692 
 693         case QuantifierNonGreedy:
 694             backTrack-&gt;begin = input.getPos();
 695             backTrack-&gt;matchAmount = 0;
 696             return true;
 697         }
 698 
 699         RELEASE_ASSERT_NOT_REACHED();
 700         return false;
 701     }
 702 
 703     bool backtrackBackReference(ByteTerm&amp; term, DisjunctionContext* context)
 704     {
 705         ASSERT(term.type == ByteTerm::TypeBackReference);
 706         BackTrackInfoBackReference* backTrack = reinterpret_cast&lt;BackTrackInfoBackReference*&gt;(context-&gt;frame + term.frameLocation);
 707 
 708         unsigned matchBegin = output[(term.atom.subpatternId &lt;&lt; 1)];
 709         unsigned matchEnd = output[(term.atom.subpatternId &lt;&lt; 1) + 1];
 710 
 711         if (matchBegin == offsetNoMatch)
 712             return false;
 713 
 714         ASSERT(matchBegin &lt;= matchEnd);
 715 
 716         if (matchBegin == matchEnd)
 717             return false;
 718 
 719         switch (term.atom.quantityType) {
 720         case QuantifierFixedCount:
 721             // for quantityMaxCount == 1, could rewind.
 722             input.setPos(backTrack-&gt;begin);
 723             break;
 724 
 725         case QuantifierGreedy:
 726             if (backTrack-&gt;matchAmount) {
 727                 --backTrack-&gt;matchAmount;
 728                 input.rewind(matchEnd - matchBegin);
 729                 return true;
 730             }
 731             break;
 732 
 733         case QuantifierNonGreedy:
 734             if ((backTrack-&gt;matchAmount &lt; term.atom.quantityMaxCount) &amp;&amp; tryConsumeBackReference(matchBegin, matchEnd, term.inputPosition)) {
 735                 ++backTrack-&gt;matchAmount;
 736                 return true;
 737             }
 738             input.setPos(backTrack-&gt;begin);
 739             break;
 740         }
 741 
 742         return false;
 743     }
 744 
 745     void recordParenthesesMatch(ByteTerm&amp; term, ParenthesesDisjunctionContext* context)
 746     {
 747         if (term.capture()) {
 748             unsigned subpatternId = term.atom.subpatternId;
 749             output[(subpatternId &lt;&lt; 1)] = context-&gt;getDisjunctionContext(term)-&gt;matchBegin - term.inputPosition;
 750             output[(subpatternId &lt;&lt; 1) + 1] = context-&gt;getDisjunctionContext(term)-&gt;matchEnd - term.inputPosition;
 751         }
 752     }
 753     void resetMatches(ByteTerm&amp; term, ParenthesesDisjunctionContext* context)
 754     {
 755         unsigned firstSubpatternId = term.atom.subpatternId;
 756         unsigned count = term.atom.parenthesesDisjunction-&gt;m_numSubpatterns;
 757         context-&gt;restoreOutput(output, firstSubpatternId, count);
 758     }
 759     JSRegExpResult parenthesesDoBacktrack(ByteTerm&amp; term, BackTrackInfoParentheses* backTrack)
 760     {
 761         while (backTrack-&gt;matchAmount) {
 762             ParenthesesDisjunctionContext* context = backTrack-&gt;lastContext;
 763 
 764             JSRegExpResult result = matchDisjunction(term.atom.parenthesesDisjunction, context-&gt;getDisjunctionContext(term), true);
 765             if (result == JSRegExpMatch)
 766                 return JSRegExpMatch;
 767 
 768             resetMatches(term, context);
 769             popParenthesesDisjunctionContext(backTrack);
 770             freeParenthesesDisjunctionContext(context);
 771 
 772             if (result != JSRegExpNoMatch)
 773                 return result;
 774         }
 775 
 776         return JSRegExpNoMatch;
 777     }
 778 
 779     bool matchParenthesesOnceBegin(ByteTerm&amp; term, DisjunctionContext* context)
 780     {
 781         ASSERT(term.type == ByteTerm::TypeParenthesesSubpatternOnceBegin);
 782         ASSERT(term.atom.quantityMaxCount == 1);
 783 
 784         BackTrackInfoParenthesesOnce* backTrack = reinterpret_cast&lt;BackTrackInfoParenthesesOnce*&gt;(context-&gt;frame + term.frameLocation);
 785 
 786         switch (term.atom.quantityType) {
 787         case QuantifierGreedy: {
 788             // set this speculatively; if we get to the parens end this will be true.
 789             backTrack-&gt;begin = input.getPos();
 790             break;
 791         }
 792         case QuantifierNonGreedy: {
 793             backTrack-&gt;begin = notFound;
 794             context-&gt;term += term.atom.parenthesesWidth;
 795             return true;
 796         }
 797         case QuantifierFixedCount:
 798             break;
 799         }
 800 
 801         if (term.capture()) {
 802             unsigned subpatternId = term.atom.subpatternId;
 803             output[(subpatternId &lt;&lt; 1)] = input.getPos() - term.inputPosition;
 804         }
 805 
 806         return true;
 807     }
 808 
 809     bool matchParenthesesOnceEnd(ByteTerm&amp; term, DisjunctionContext* context)
 810     {
 811         ASSERT(term.type == ByteTerm::TypeParenthesesSubpatternOnceEnd);
 812         ASSERT(term.atom.quantityMaxCount == 1);
 813 
 814         if (term.capture()) {
 815             unsigned subpatternId = term.atom.subpatternId;
 816             output[(subpatternId &lt;&lt; 1) + 1] = input.getPos() - term.inputPosition;
 817         }
 818 
 819         if (term.atom.quantityType == QuantifierFixedCount)
 820             return true;
 821 
 822         BackTrackInfoParenthesesOnce* backTrack = reinterpret_cast&lt;BackTrackInfoParenthesesOnce*&gt;(context-&gt;frame + term.frameLocation);
 823         return backTrack-&gt;begin != input.getPos();
 824     }
 825 
 826     bool backtrackParenthesesOnceBegin(ByteTerm&amp; term, DisjunctionContext* context)
 827     {
 828         ASSERT(term.type == ByteTerm::TypeParenthesesSubpatternOnceBegin);
 829         ASSERT(term.atom.quantityMaxCount == 1);
 830 
 831         BackTrackInfoParenthesesOnce* backTrack = reinterpret_cast&lt;BackTrackInfoParenthesesOnce*&gt;(context-&gt;frame + term.frameLocation);
 832 
 833         if (term.capture()) {
 834             unsigned subpatternId = term.atom.subpatternId;
 835             output[(subpatternId &lt;&lt; 1)] = offsetNoMatch;
 836             output[(subpatternId &lt;&lt; 1) + 1] = offsetNoMatch;
 837         }
 838 
 839         switch (term.atom.quantityType) {
 840         case QuantifierGreedy:
 841             // if we backtrack to this point, there is another chance - try matching nothing.
 842             ASSERT(backTrack-&gt;begin != notFound);
 843             backTrack-&gt;begin = notFound;
 844             context-&gt;term += term.atom.parenthesesWidth;
 845             return true;
 846         case QuantifierNonGreedy:
 847             ASSERT(backTrack-&gt;begin != notFound);
 848             FALLTHROUGH;
 849         case QuantifierFixedCount:
 850             break;
 851         }
 852 
 853         return false;
 854     }
 855 
 856     bool backtrackParenthesesOnceEnd(ByteTerm&amp; term, DisjunctionContext* context)
 857     {
 858         ASSERT(term.type == ByteTerm::TypeParenthesesSubpatternOnceEnd);
 859         ASSERT(term.atom.quantityMaxCount == 1);
 860 
 861         BackTrackInfoParenthesesOnce* backTrack = reinterpret_cast&lt;BackTrackInfoParenthesesOnce*&gt;(context-&gt;frame + term.frameLocation);
 862 
 863         switch (term.atom.quantityType) {
 864         case QuantifierGreedy:
 865             if (backTrack-&gt;begin == notFound) {
 866                 context-&gt;term -= term.atom.parenthesesWidth;
 867                 return false;
 868             }
 869             FALLTHROUGH;
 870         case QuantifierNonGreedy:
 871             if (backTrack-&gt;begin == notFound) {
 872                 backTrack-&gt;begin = input.getPos();
 873                 if (term.capture()) {
 874                     // Technically this access to inputPosition should be accessing the begin term&#39;s
 875                     // inputPosition, but for repeats other than fixed these values should be
 876                     // the same anyway! (We don&#39;t pre-check for greedy or non-greedy matches.)
 877                     ASSERT((&amp;term - term.atom.parenthesesWidth)-&gt;type == ByteTerm::TypeParenthesesSubpatternOnceBegin);
 878                     ASSERT((&amp;term - term.atom.parenthesesWidth)-&gt;inputPosition == term.inputPosition);
 879                     unsigned subpatternId = term.atom.subpatternId;
 880                     output[subpatternId &lt;&lt; 1] = input.getPos() - term.inputPosition;
 881                 }
 882                 context-&gt;term -= term.atom.parenthesesWidth;
 883                 return true;
 884             }
 885             FALLTHROUGH;
 886         case QuantifierFixedCount:
 887             break;
 888         }
 889 
 890         return false;
 891     }
 892 
 893     bool matchParenthesesTerminalBegin(ByteTerm&amp; term, DisjunctionContext* context)
 894     {
 895         ASSERT(term.type == ByteTerm::TypeParenthesesSubpatternTerminalBegin);
 896         ASSERT(term.atom.quantityType == QuantifierGreedy);
 897         ASSERT(term.atom.quantityMaxCount == quantifyInfinite);
 898         ASSERT(!term.capture());
 899 
 900         BackTrackInfoParenthesesTerminal* backTrack = reinterpret_cast&lt;BackTrackInfoParenthesesTerminal*&gt;(context-&gt;frame + term.frameLocation);
 901         backTrack-&gt;begin = input.getPos();
 902         return true;
 903     }
 904 
 905     bool matchParenthesesTerminalEnd(ByteTerm&amp; term, DisjunctionContext* context)
 906     {
 907         ASSERT(term.type == ByteTerm::TypeParenthesesSubpatternTerminalEnd);
 908 
 909         BackTrackInfoParenthesesTerminal* backTrack = reinterpret_cast&lt;BackTrackInfoParenthesesTerminal*&gt;(context-&gt;frame + term.frameLocation);
 910         // Empty match is a failed match.
 911         if (backTrack-&gt;begin == input.getPos())
 912             return false;
 913 
 914         // Successful match! Okay, what&#39;s next? - loop around and try to match more!
 915         context-&gt;term -= (term.atom.parenthesesWidth + 1);
 916         return true;
 917     }
 918 
 919     bool backtrackParenthesesTerminalBegin(ByteTerm&amp; term, DisjunctionContext* context)
 920     {
 921         ASSERT(term.type == ByteTerm::TypeParenthesesSubpatternTerminalBegin);
 922         ASSERT(term.atom.quantityType == QuantifierGreedy);
 923         ASSERT(term.atom.quantityMaxCount == quantifyInfinite);
 924         ASSERT(!term.capture());
 925 
 926         // If we backtrack to this point, we have failed to match this iteration of the parens.
 927         // Since this is greedy / zero minimum a failed is also accepted as a match!
 928         context-&gt;term += term.atom.parenthesesWidth;
 929         return true;
 930     }
 931 
 932     bool backtrackParenthesesTerminalEnd(ByteTerm&amp;, DisjunctionContext*)
 933     {
 934         // &#39;Terminal&#39; parentheses are at the end of the regex, and as such a match past end
 935         // should always be returned as a successful match - we should never backtrack to here.
 936         RELEASE_ASSERT_NOT_REACHED();
 937         return false;
 938     }
 939 
 940     bool matchParentheticalAssertionBegin(ByteTerm&amp; term, DisjunctionContext* context)
 941     {
 942         ASSERT(term.type == ByteTerm::TypeParentheticalAssertionBegin);
 943         ASSERT(term.atom.quantityMaxCount == 1);
 944 
 945         BackTrackInfoParentheticalAssertion* backTrack = reinterpret_cast&lt;BackTrackInfoParentheticalAssertion*&gt;(context-&gt;frame + term.frameLocation);
 946 
 947         backTrack-&gt;begin = input.getPos();
 948         return true;
 949     }
 950 
 951     bool matchParentheticalAssertionEnd(ByteTerm&amp; term, DisjunctionContext* context)
 952     {
 953         ASSERT(term.type == ByteTerm::TypeParentheticalAssertionEnd);
 954         ASSERT(term.atom.quantityMaxCount == 1);
 955 
 956         BackTrackInfoParentheticalAssertion* backTrack = reinterpret_cast&lt;BackTrackInfoParentheticalAssertion*&gt;(context-&gt;frame + term.frameLocation);
 957 
 958         input.setPos(backTrack-&gt;begin);
 959 
 960         // We&#39;ve reached the end of the parens; if they are inverted, this is failure.
 961         if (term.invert()) {
 962             context-&gt;term -= term.atom.parenthesesWidth;
 963             return false;
 964         }
 965 
 966         return true;
 967     }
 968 
 969     bool backtrackParentheticalAssertionBegin(ByteTerm&amp; term, DisjunctionContext* context)
 970     {
 971         ASSERT(term.type == ByteTerm::TypeParentheticalAssertionBegin);
 972         ASSERT(term.atom.quantityMaxCount == 1);
 973 
 974         // We&#39;ve failed to match parens; if they are inverted, this is win!
 975         if (term.invert()) {
 976             context-&gt;term += term.atom.parenthesesWidth;
 977             return true;
 978         }
 979 
 980         return false;
 981     }
 982 
 983     bool backtrackParentheticalAssertionEnd(ByteTerm&amp; term, DisjunctionContext* context)
 984     {
 985         ASSERT(term.type == ByteTerm::TypeParentheticalAssertionEnd);
 986         ASSERT(term.atom.quantityMaxCount == 1);
 987 
 988         BackTrackInfoParentheticalAssertion* backTrack = reinterpret_cast&lt;BackTrackInfoParentheticalAssertion*&gt;(context-&gt;frame + term.frameLocation);
 989 
 990         input.setPos(backTrack-&gt;begin);
 991 
 992         context-&gt;term -= term.atom.parenthesesWidth;
 993         return false;
 994     }
 995 
 996     JSRegExpResult matchParentheses(ByteTerm&amp; term, DisjunctionContext* context)
 997     {
 998         ASSERT(term.type == ByteTerm::TypeParenthesesSubpattern);
 999 
1000         BackTrackInfoParentheses* backTrack = reinterpret_cast&lt;BackTrackInfoParentheses*&gt;(context-&gt;frame + term.frameLocation);
1001         ByteDisjunction* disjunctionBody = term.atom.parenthesesDisjunction;
1002 
1003         backTrack-&gt;matchAmount = 0;
1004         backTrack-&gt;lastContext = 0;
1005 
1006         ASSERT(term.atom.quantityType != QuantifierFixedCount || term.atom.quantityMinCount == term.atom.quantityMaxCount);
1007 
1008         unsigned minimumMatchCount = term.atom.quantityMinCount;
1009         JSRegExpResult fixedMatchResult;
1010 
1011         // Handle fixed matches and the minimum part of a variable length match.
1012         if (minimumMatchCount) {
1013             // While we haven&#39;t yet reached our fixed limit,
1014             while (backTrack-&gt;matchAmount &lt; minimumMatchCount) {
1015                 // Try to do a match, and it it succeeds, add it to the list.
1016                 ParenthesesDisjunctionContext* context = allocParenthesesDisjunctionContext(disjunctionBody, output, term);
1017                 fixedMatchResult = matchDisjunction(disjunctionBody, context-&gt;getDisjunctionContext(term));
1018                 if (fixedMatchResult == JSRegExpMatch)
1019                     appendParenthesesDisjunctionContext(backTrack, context);
1020                 else {
1021                     // The match failed; try to find an alternate point to carry on from.
1022                     resetMatches(term, context);
1023                     freeParenthesesDisjunctionContext(context);
1024 
1025                     if (fixedMatchResult != JSRegExpNoMatch)
1026                         return fixedMatchResult;
1027                     JSRegExpResult backtrackResult = parenthesesDoBacktrack(term, backTrack);
1028                     if (backtrackResult != JSRegExpMatch)
1029                         return backtrackResult;
1030                 }
1031             }
1032 
1033             ParenthesesDisjunctionContext* context = backTrack-&gt;lastContext;
1034             recordParenthesesMatch(term, context);
1035         }
1036 
1037         switch (term.atom.quantityType) {
1038         case QuantifierFixedCount: {
1039             ASSERT(backTrack-&gt;matchAmount == term.atom.quantityMaxCount);
1040             return JSRegExpMatch;
1041         }
1042 
1043         case QuantifierGreedy: {
1044             while (backTrack-&gt;matchAmount &lt; term.atom.quantityMaxCount) {
1045                 ParenthesesDisjunctionContext* context = allocParenthesesDisjunctionContext(disjunctionBody, output, term);
1046                 JSRegExpResult result = matchNonZeroDisjunction(disjunctionBody, context-&gt;getDisjunctionContext(term));
1047                 if (result == JSRegExpMatch)
1048                     appendParenthesesDisjunctionContext(backTrack, context);
1049                 else {
1050                     resetMatches(term, context);
1051                     freeParenthesesDisjunctionContext(context);
1052 
1053                     if (result != JSRegExpNoMatch)
1054                         return result;
1055 
1056                     break;
1057                 }
1058             }
1059 
1060             if (backTrack-&gt;matchAmount) {
1061                 ParenthesesDisjunctionContext* context = backTrack-&gt;lastContext;
1062                 recordParenthesesMatch(term, context);
1063             }
1064             return JSRegExpMatch;
1065         }
1066 
1067         case QuantifierNonGreedy:
1068             return JSRegExpMatch;
1069         }
1070 
1071         RELEASE_ASSERT_NOT_REACHED();
1072         return JSRegExpErrorNoMatch;
1073     }
1074 
1075     // Rules for backtracking differ depending on whether this is greedy or non-greedy.
1076     //
1077     // Greedy matches never should try just adding more - you should already have done
1078     // the &#39;more&#39; cases.  Always backtrack, at least a leetle bit.  However cases where
1079     // you backtrack an item off the list needs checking, since we&#39;ll never have matched
1080     // the one less case.  Tracking forwards, still add as much as possible.
1081     //
1082     // Non-greedy, we&#39;ve already done the one less case, so don&#39;t match on popping.
1083     // We haven&#39;t done the one more case, so always try to add that.
1084     //
1085     JSRegExpResult backtrackParentheses(ByteTerm&amp; term, DisjunctionContext* context)
1086     {
1087         ASSERT(term.type == ByteTerm::TypeParenthesesSubpattern);
1088 
1089         BackTrackInfoParentheses* backTrack = reinterpret_cast&lt;BackTrackInfoParentheses*&gt;(context-&gt;frame + term.frameLocation);
1090         ByteDisjunction* disjunctionBody = term.atom.parenthesesDisjunction;
1091 
1092         switch (term.atom.quantityType) {
1093         case QuantifierFixedCount: {
1094             ASSERT(backTrack-&gt;matchAmount == term.atom.quantityMaxCount);
1095 
1096             ParenthesesDisjunctionContext* context = 0;
1097             JSRegExpResult result = parenthesesDoBacktrack(term, backTrack);
1098 
1099             if (result != JSRegExpMatch)
1100                 return result;
1101 
1102             // While we haven&#39;t yet reached our fixed limit,
1103             while (backTrack-&gt;matchAmount &lt; term.atom.quantityMaxCount) {
1104                 // Try to do a match, and it it succeeds, add it to the list.
1105                 context = allocParenthesesDisjunctionContext(disjunctionBody, output, term);
1106                 result = matchDisjunction(disjunctionBody, context-&gt;getDisjunctionContext(term));
1107 
1108                 if (result == JSRegExpMatch)
1109                     appendParenthesesDisjunctionContext(backTrack, context);
1110                 else {
1111                     // The match failed; try to find an alternate point to carry on from.
1112                     resetMatches(term, context);
1113                     freeParenthesesDisjunctionContext(context);
1114 
1115                     if (result != JSRegExpNoMatch)
1116                         return result;
1117                     JSRegExpResult backtrackResult = parenthesesDoBacktrack(term, backTrack);
1118                     if (backtrackResult != JSRegExpMatch)
1119                         return backtrackResult;
1120                 }
1121             }
1122 
1123             ASSERT(backTrack-&gt;matchAmount == term.atom.quantityMaxCount);
1124             context = backTrack-&gt;lastContext;
1125             recordParenthesesMatch(term, context);
1126             return JSRegExpMatch;
1127         }
1128 
1129         case QuantifierGreedy: {
1130             if (!backTrack-&gt;matchAmount)
1131                 return JSRegExpNoMatch;
1132 
1133             ParenthesesDisjunctionContext* context = backTrack-&gt;lastContext;
1134             JSRegExpResult result = matchNonZeroDisjunction(disjunctionBody, context-&gt;getDisjunctionContext(term), true);
1135             if (result == JSRegExpMatch) {
1136                 while (backTrack-&gt;matchAmount &lt; term.atom.quantityMaxCount) {
1137                     ParenthesesDisjunctionContext* context = allocParenthesesDisjunctionContext(disjunctionBody, output, term);
1138                     JSRegExpResult parenthesesResult = matchNonZeroDisjunction(disjunctionBody, context-&gt;getDisjunctionContext(term));
1139                     if (parenthesesResult == JSRegExpMatch)
1140                         appendParenthesesDisjunctionContext(backTrack, context);
1141                     else {
1142                         resetMatches(term, context);
1143                         freeParenthesesDisjunctionContext(context);
1144 
1145                         if (parenthesesResult != JSRegExpNoMatch)
1146                             return parenthesesResult;
1147 
1148                         break;
1149                     }
1150                 }
1151             } else {
1152                 resetMatches(term, context);
1153                 popParenthesesDisjunctionContext(backTrack);
1154                 freeParenthesesDisjunctionContext(context);
1155 
1156                 if (result != JSRegExpNoMatch || backTrack-&gt;matchAmount &lt; term.atom.quantityMinCount)
1157                     return result;
1158             }
1159 
1160             if (backTrack-&gt;matchAmount) {
1161                 ParenthesesDisjunctionContext* context = backTrack-&gt;lastContext;
1162                 recordParenthesesMatch(term, context);
1163             }
1164             return JSRegExpMatch;
1165         }
1166 
1167         case QuantifierNonGreedy: {
1168             // If we&#39;ve not reached the limit, try to add one more match.
1169             if (backTrack-&gt;matchAmount &lt; term.atom.quantityMaxCount) {
1170                 ParenthesesDisjunctionContext* context = allocParenthesesDisjunctionContext(disjunctionBody, output, term);
1171                 JSRegExpResult result = matchNonZeroDisjunction(disjunctionBody, context-&gt;getDisjunctionContext(term));
1172                 if (result == JSRegExpMatch) {
1173                     appendParenthesesDisjunctionContext(backTrack, context);
1174                     recordParenthesesMatch(term, context);
1175                     return JSRegExpMatch;
1176                 }
1177 
1178                 resetMatches(term, context);
1179                 freeParenthesesDisjunctionContext(context);
1180 
1181                 if (result != JSRegExpNoMatch)
1182                     return result;
1183             }
1184 
1185             // Nope - okay backtrack looking for an alternative.
1186             while (backTrack-&gt;matchAmount) {
1187                 ParenthesesDisjunctionContext* context = backTrack-&gt;lastContext;
1188                 JSRegExpResult result = matchNonZeroDisjunction(disjunctionBody, context-&gt;getDisjunctionContext(term), true);
1189                 if (result == JSRegExpMatch) {
1190                     // successful backtrack! we&#39;re back in the game!
1191                     if (backTrack-&gt;matchAmount) {
1192                         context = backTrack-&gt;lastContext;
1193                         recordParenthesesMatch(term, context);
1194                     }
1195                     return JSRegExpMatch;
1196                 }
1197 
1198                 // pop a match off the stack
1199                 resetMatches(term, context);
1200                 popParenthesesDisjunctionContext(backTrack);
1201                 freeParenthesesDisjunctionContext(context);
1202 
1203                 if (result != JSRegExpNoMatch)
1204                     return result;
1205             }
1206 
1207             return JSRegExpNoMatch;
1208         }
1209         }
1210 
1211         RELEASE_ASSERT_NOT_REACHED();
1212         return JSRegExpErrorNoMatch;
1213     }
1214 
1215     bool matchDotStarEnclosure(ByteTerm&amp; term, DisjunctionContext* context)
1216     {
1217         UNUSED_PARAM(term);
1218 
1219         if (pattern-&gt;dotAll()) {
1220             context-&gt;matchBegin = startOffset;
1221             context-&gt;matchEnd = input.end();
1222             return true;
1223         }
1224 
1225         unsigned matchBegin = context-&gt;matchBegin;
1226 
1227         if (matchBegin &gt; startOffset) {
1228             for (matchBegin--; true; matchBegin--) {
1229                 if (testCharacterClass(pattern-&gt;newlineCharacterClass, input.reread(matchBegin))) {
1230                     ++matchBegin;
1231                     break;
1232                 }
1233 
1234                 if (matchBegin == startOffset)
1235                     break;
1236             }
1237         }
1238 
1239         unsigned matchEnd = input.getPos();
1240 
1241         for (; (matchEnd != input.end())
1242              &amp;&amp; (!testCharacterClass(pattern-&gt;newlineCharacterClass, input.reread(matchEnd))); matchEnd++) { }
1243 
1244         if (((matchBegin &amp;&amp; term.anchors.m_bol)
1245              || ((matchEnd != input.end()) &amp;&amp; term.anchors.m_eol))
1246             &amp;&amp; !pattern-&gt;multiline())
1247             return false;
1248 
1249         context-&gt;matchBegin = matchBegin;
1250         context-&gt;matchEnd = matchEnd;
1251         return true;
1252     }
1253 
1254 #define MATCH_NEXT() { ++context-&gt;term; goto matchAgain; }
1255 #define BACKTRACK() { --context-&gt;term; goto backtrack; }
1256 #define currentTerm() (disjunction-&gt;terms[context-&gt;term])
1257     JSRegExpResult matchDisjunction(ByteDisjunction* disjunction, DisjunctionContext* context, bool btrack = false)
1258     {
1259         if (!--remainingMatchCount)
1260             return JSRegExpErrorHitLimit;
1261 
1262         if (btrack)
1263             BACKTRACK();
1264 
1265         context-&gt;matchBegin = input.getPos();
1266         context-&gt;term = 0;
1267 
1268     matchAgain:
1269         ASSERT(context-&gt;term &lt; static_cast&lt;int&gt;(disjunction-&gt;terms.size()));
1270 
1271         switch (currentTerm().type) {
1272         case ByteTerm::TypeSubpatternBegin:
1273             MATCH_NEXT();
1274         case ByteTerm::TypeSubpatternEnd:
1275             context-&gt;matchEnd = input.getPos();
1276             return JSRegExpMatch;
1277 
1278         case ByteTerm::TypeBodyAlternativeBegin:
1279             MATCH_NEXT();
1280         case ByteTerm::TypeBodyAlternativeDisjunction:
1281         case ByteTerm::TypeBodyAlternativeEnd:
1282             context-&gt;matchEnd = input.getPos();
1283             return JSRegExpMatch;
1284 
1285         case ByteTerm::TypeAlternativeBegin:
1286             MATCH_NEXT();
1287         case ByteTerm::TypeAlternativeDisjunction:
1288         case ByteTerm::TypeAlternativeEnd: {
1289             int offset = currentTerm().alternative.end;
1290             BackTrackInfoAlternative* backTrack = reinterpret_cast&lt;BackTrackInfoAlternative*&gt;(context-&gt;frame + currentTerm().frameLocation);
1291             backTrack-&gt;offset = offset;
1292             context-&gt;term += offset;
1293             MATCH_NEXT();
1294         }
1295 
1296         case ByteTerm::TypeAssertionBOL:
1297             if (matchAssertionBOL(currentTerm()))
1298                 MATCH_NEXT();
1299             BACKTRACK();
1300         case ByteTerm::TypeAssertionEOL:
1301             if (matchAssertionEOL(currentTerm()))
1302                 MATCH_NEXT();
1303             BACKTRACK();
1304         case ByteTerm::TypeAssertionWordBoundary:
1305             if (matchAssertionWordBoundary(currentTerm()))
1306                 MATCH_NEXT();
1307             BACKTRACK();
1308 
1309         case ByteTerm::TypePatternCharacterOnce:
1310         case ByteTerm::TypePatternCharacterFixed: {
1311             if (unicode) {
1312                 if (!U_IS_BMP(currentTerm().atom.patternCharacter)) {
1313                     for (unsigned matchAmount = 0; matchAmount &lt; currentTerm().atom.quantityMaxCount; ++matchAmount) {
1314                         if (!checkSurrogatePair(currentTerm().atom.patternCharacter, currentTerm().inputPosition - 2 * matchAmount)) {
1315                             BACKTRACK();
1316                         }
1317                     }
1318                     MATCH_NEXT();
1319                 }
1320             }
1321             unsigned position = input.getPos(); // May need to back out reading a surrogate pair.
1322 
1323             for (unsigned matchAmount = 0; matchAmount &lt; currentTerm().atom.quantityMaxCount; ++matchAmount) {
1324                 if (!checkCharacter(currentTerm().atom.patternCharacter, currentTerm().inputPosition - matchAmount)) {
1325                     input.setPos(position);
1326                     BACKTRACK();
1327                 }
1328             }
1329             MATCH_NEXT();
1330         }
1331         case ByteTerm::TypePatternCharacterGreedy: {
1332             BackTrackInfoPatternCharacter* backTrack = reinterpret_cast&lt;BackTrackInfoPatternCharacter*&gt;(context-&gt;frame + currentTerm().frameLocation);
1333             unsigned matchAmount = 0;
1334             unsigned position = input.getPos(); // May need to back out reading a surrogate pair.
1335             while ((matchAmount &lt; currentTerm().atom.quantityMaxCount) &amp;&amp; input.checkInput(1)) {
1336                 if (!checkCharacter(currentTerm().atom.patternCharacter, currentTerm().inputPosition + 1)) {
1337                     input.setPos(position);
1338                     break;
1339                 }
1340                 ++matchAmount;
1341                 position = input.getPos();
1342             }
1343             backTrack-&gt;matchAmount = matchAmount;
1344 
1345             MATCH_NEXT();
1346         }
1347         case ByteTerm::TypePatternCharacterNonGreedy: {
1348             BackTrackInfoPatternCharacter* backTrack = reinterpret_cast&lt;BackTrackInfoPatternCharacter*&gt;(context-&gt;frame + currentTerm().frameLocation);
1349             backTrack-&gt;begin = input.getPos();
1350             backTrack-&gt;matchAmount = 0;
1351             MATCH_NEXT();
1352         }
1353 
1354         case ByteTerm::TypePatternCasedCharacterOnce:
1355         case ByteTerm::TypePatternCasedCharacterFixed: {
1356             if (unicode) {
1357                 // Case insensitive matching of unicode characters is handled as TypeCharacterClass.
1358                 ASSERT(U_IS_BMP(currentTerm().atom.patternCharacter));
1359 
1360                 unsigned position = input.getPos(); // May need to back out reading a surrogate pair.
1361 
1362                 for (unsigned matchAmount = 0; matchAmount &lt; currentTerm().atom.quantityMaxCount; ++matchAmount) {
1363                     if (!checkCasedCharacter(currentTerm().atom.casedCharacter.lo, currentTerm().atom.casedCharacter.hi, currentTerm().inputPosition - matchAmount)) {
1364                         input.setPos(position);
1365                         BACKTRACK();
1366                     }
1367                 }
1368                 MATCH_NEXT();
1369             }
1370 
1371             for (unsigned matchAmount = 0; matchAmount &lt; currentTerm().atom.quantityMaxCount; ++matchAmount) {
1372                 if (!checkCasedCharacter(currentTerm().atom.casedCharacter.lo, currentTerm().atom.casedCharacter.hi, currentTerm().inputPosition - matchAmount))
1373                     BACKTRACK();
1374             }
1375             MATCH_NEXT();
1376         }
1377         case ByteTerm::TypePatternCasedCharacterGreedy: {
1378             BackTrackInfoPatternCharacter* backTrack = reinterpret_cast&lt;BackTrackInfoPatternCharacter*&gt;(context-&gt;frame + currentTerm().frameLocation);
1379 
1380             // Case insensitive matching of unicode characters is handled as TypeCharacterClass.
1381             ASSERT(!unicode || U_IS_BMP(currentTerm().atom.patternCharacter));
1382 
1383             unsigned matchAmount = 0;
1384             while ((matchAmount &lt; currentTerm().atom.quantityMaxCount) &amp;&amp; input.checkInput(1)) {
1385                 if (!checkCasedCharacter(currentTerm().atom.casedCharacter.lo, currentTerm().atom.casedCharacter.hi, currentTerm().inputPosition + 1)) {
1386                     input.uncheckInput(1);
1387                     break;
1388                 }
1389                 ++matchAmount;
1390             }
1391             backTrack-&gt;matchAmount = matchAmount;
1392 
1393             MATCH_NEXT();
1394         }
1395         case ByteTerm::TypePatternCasedCharacterNonGreedy: {
1396             BackTrackInfoPatternCharacter* backTrack = reinterpret_cast&lt;BackTrackInfoPatternCharacter*&gt;(context-&gt;frame + currentTerm().frameLocation);
1397 
1398             // Case insensitive matching of unicode characters is handled as TypeCharacterClass.
1399             ASSERT(!unicode || U_IS_BMP(currentTerm().atom.patternCharacter));
1400 
1401             backTrack-&gt;matchAmount = 0;
1402             MATCH_NEXT();
1403         }
1404 
1405         case ByteTerm::TypeCharacterClass:
1406             if (matchCharacterClass(currentTerm(), context))
1407                 MATCH_NEXT();
1408             BACKTRACK();
1409         case ByteTerm::TypeBackReference:
1410             if (matchBackReference(currentTerm(), context))
1411                 MATCH_NEXT();
1412             BACKTRACK();
1413         case ByteTerm::TypeParenthesesSubpattern: {
1414             JSRegExpResult result = matchParentheses(currentTerm(), context);
1415 
1416             if (result == JSRegExpMatch) {
1417                 MATCH_NEXT();
1418             }  else if (result != JSRegExpNoMatch)
1419                 return result;
1420 
1421             BACKTRACK();
1422         }
1423         case ByteTerm::TypeParenthesesSubpatternOnceBegin:
1424             if (matchParenthesesOnceBegin(currentTerm(), context))
1425                 MATCH_NEXT();
1426             BACKTRACK();
1427         case ByteTerm::TypeParenthesesSubpatternOnceEnd:
1428             if (matchParenthesesOnceEnd(currentTerm(), context))
1429                 MATCH_NEXT();
1430             BACKTRACK();
1431         case ByteTerm::TypeParenthesesSubpatternTerminalBegin:
1432             if (matchParenthesesTerminalBegin(currentTerm(), context))
1433                 MATCH_NEXT();
1434             BACKTRACK();
1435         case ByteTerm::TypeParenthesesSubpatternTerminalEnd:
1436             if (matchParenthesesTerminalEnd(currentTerm(), context))
1437                 MATCH_NEXT();
1438             BACKTRACK();
1439         case ByteTerm::TypeParentheticalAssertionBegin:
1440             if (matchParentheticalAssertionBegin(currentTerm(), context))
1441                 MATCH_NEXT();
1442             BACKTRACK();
1443         case ByteTerm::TypeParentheticalAssertionEnd:
1444             if (matchParentheticalAssertionEnd(currentTerm(), context))
1445                 MATCH_NEXT();
1446             BACKTRACK();
1447 
1448         case ByteTerm::TypeCheckInput:
1449             if (input.checkInput(currentTerm().checkInputCount))
1450                 MATCH_NEXT();
1451             BACKTRACK();
1452 
1453         case ByteTerm::TypeUncheckInput:
1454             input.uncheckInput(currentTerm().checkInputCount);
1455             MATCH_NEXT();
1456 
1457         case ByteTerm::TypeDotStarEnclosure:
1458             if (matchDotStarEnclosure(currentTerm(), context))
1459                 return JSRegExpMatch;
1460             BACKTRACK();
1461         }
1462 
1463         // We should never fall-through to here.
1464         RELEASE_ASSERT_NOT_REACHED();
1465 
1466     backtrack:
1467         ASSERT(context-&gt;term &lt; static_cast&lt;int&gt;(disjunction-&gt;terms.size()));
1468 
1469         switch (currentTerm().type) {
1470         case ByteTerm::TypeSubpatternBegin:
1471             return JSRegExpNoMatch;
1472         case ByteTerm::TypeSubpatternEnd:
1473             RELEASE_ASSERT_NOT_REACHED();
1474 
1475         case ByteTerm::TypeBodyAlternativeBegin:
1476         case ByteTerm::TypeBodyAlternativeDisjunction: {
1477             int offset = currentTerm().alternative.next;
1478             context-&gt;term += offset;
1479             if (offset &gt; 0)
1480                 MATCH_NEXT();
1481 
1482             if (input.atEnd() || pattern-&gt;sticky())
1483                 return JSRegExpNoMatch;
1484 
1485             input.next();
1486 
1487             context-&gt;matchBegin = input.getPos();
1488 
1489             if (currentTerm().alternative.onceThrough)
1490                 context-&gt;term += currentTerm().alternative.next;
1491 
1492             MATCH_NEXT();
1493         }
1494         case ByteTerm::TypeBodyAlternativeEnd:
1495             RELEASE_ASSERT_NOT_REACHED();
1496 
1497         case ByteTerm::TypeAlternativeBegin:
1498         case ByteTerm::TypeAlternativeDisjunction: {
1499             int offset = currentTerm().alternative.next;
1500             context-&gt;term += offset;
1501             if (offset &gt; 0)
1502                 MATCH_NEXT();
1503             BACKTRACK();
1504         }
1505         case ByteTerm::TypeAlternativeEnd: {
1506             // We should never backtrack back into an alternative of the main body of the regex.
1507             BackTrackInfoAlternative* backTrack = reinterpret_cast&lt;BackTrackInfoAlternative*&gt;(context-&gt;frame + currentTerm().frameLocation);
1508             unsigned offset = backTrack-&gt;offset;
1509             context-&gt;term -= offset;
1510             BACKTRACK();
1511         }
1512 
1513         case ByteTerm::TypeAssertionBOL:
1514         case ByteTerm::TypeAssertionEOL:
1515         case ByteTerm::TypeAssertionWordBoundary:
1516             BACKTRACK();
1517 
1518         case ByteTerm::TypePatternCharacterOnce:
1519         case ByteTerm::TypePatternCharacterFixed:
1520         case ByteTerm::TypePatternCharacterGreedy:
1521         case ByteTerm::TypePatternCharacterNonGreedy:
1522             if (backtrackPatternCharacter(currentTerm(), context))
1523                 MATCH_NEXT();
1524             BACKTRACK();
1525         case ByteTerm::TypePatternCasedCharacterOnce:
1526         case ByteTerm::TypePatternCasedCharacterFixed:
1527         case ByteTerm::TypePatternCasedCharacterGreedy:
1528         case ByteTerm::TypePatternCasedCharacterNonGreedy:
1529             if (backtrackPatternCasedCharacter(currentTerm(), context))
1530                 MATCH_NEXT();
1531             BACKTRACK();
1532         case ByteTerm::TypeCharacterClass:
1533             if (backtrackCharacterClass(currentTerm(), context))
1534                 MATCH_NEXT();
1535             BACKTRACK();
1536         case ByteTerm::TypeBackReference:
1537             if (backtrackBackReference(currentTerm(), context))
1538                 MATCH_NEXT();
1539             BACKTRACK();
1540         case ByteTerm::TypeParenthesesSubpattern: {
1541             JSRegExpResult result = backtrackParentheses(currentTerm(), context);
1542 
1543             if (result == JSRegExpMatch) {
1544                 MATCH_NEXT();
1545             } else if (result != JSRegExpNoMatch)
1546                 return result;
1547 
1548             BACKTRACK();
1549         }
1550         case ByteTerm::TypeParenthesesSubpatternOnceBegin:
1551             if (backtrackParenthesesOnceBegin(currentTerm(), context))
1552                 MATCH_NEXT();
1553             BACKTRACK();
1554         case ByteTerm::TypeParenthesesSubpatternOnceEnd:
1555             if (backtrackParenthesesOnceEnd(currentTerm(), context))
1556                 MATCH_NEXT();
1557             BACKTRACK();
1558         case ByteTerm::TypeParenthesesSubpatternTerminalBegin:
1559             if (backtrackParenthesesTerminalBegin(currentTerm(), context))
1560                 MATCH_NEXT();
1561             BACKTRACK();
1562         case ByteTerm::TypeParenthesesSubpatternTerminalEnd:
1563             if (backtrackParenthesesTerminalEnd(currentTerm(), context))
1564                 MATCH_NEXT();
1565             BACKTRACK();
1566         case ByteTerm::TypeParentheticalAssertionBegin:
1567             if (backtrackParentheticalAssertionBegin(currentTerm(), context))
1568                 MATCH_NEXT();
1569             BACKTRACK();
1570         case ByteTerm::TypeParentheticalAssertionEnd:
1571             if (backtrackParentheticalAssertionEnd(currentTerm(), context))
1572                 MATCH_NEXT();
1573             BACKTRACK();
1574 
1575         case ByteTerm::TypeCheckInput:
1576             input.uncheckInput(currentTerm().checkInputCount);
1577             BACKTRACK();
1578 
1579         case ByteTerm::TypeUncheckInput:
1580             input.checkInput(currentTerm().checkInputCount);
1581             BACKTRACK();
1582 
1583         case ByteTerm::TypeDotStarEnclosure:
1584             RELEASE_ASSERT_NOT_REACHED();
1585         }
1586 
1587         RELEASE_ASSERT_NOT_REACHED();
1588         return JSRegExpErrorNoMatch;
1589     }
1590 
1591     JSRegExpResult matchNonZeroDisjunction(ByteDisjunction* disjunction, DisjunctionContext* context, bool btrack = false)
1592     {
1593         JSRegExpResult result = matchDisjunction(disjunction, context, btrack);
1594 
1595         if (result == JSRegExpMatch) {
1596             while (context-&gt;matchBegin == context-&gt;matchEnd) {
1597                 result = matchDisjunction(disjunction, context, true);
1598                 if (result != JSRegExpMatch)
1599                     return result;
1600             }
1601             return JSRegExpMatch;
1602         }
1603 
1604         return result;
1605     }
1606 
1607     unsigned interpret()
1608     {
<a name="4" id="anc4"></a>

1609         if (!input.isAvailableInput(0))
1610             return offsetNoMatch;
1611 
1612         if (pattern-&gt;m_lock)
1613             pattern-&gt;m_lock-&gt;lock();
1614 
1615         for (unsigned i = 0; i &lt; pattern-&gt;m_body-&gt;m_numSubpatterns + 1; ++i)
1616             output[i &lt;&lt; 1] = offsetNoMatch;
1617 
1618         allocatorPool = pattern-&gt;m_allocator-&gt;startAllocator();
1619         RELEASE_ASSERT(allocatorPool);
1620 
1621         DisjunctionContext* context = allocDisjunctionContext(pattern-&gt;m_body.get());
1622 
1623         JSRegExpResult result = matchDisjunction(pattern-&gt;m_body.get(), context, false);
1624         if (result == JSRegExpMatch) {
1625             output[0] = context-&gt;matchBegin;
1626             output[1] = context-&gt;matchEnd;
1627         }
1628 
1629         freeDisjunctionContext(context);
1630 
1631         pattern-&gt;m_allocator-&gt;stopAllocator();
1632 
1633         ASSERT((result == JSRegExpMatch) == (output[0] != offsetNoMatch));
1634 
1635         if (pattern-&gt;m_lock)
1636             pattern-&gt;m_lock-&gt;unlock();
1637 
1638         return output[0];
1639     }
1640 
1641     Interpreter(BytecodePattern* pattern, unsigned* output, const CharType* input, unsigned length, unsigned start)
1642         : pattern(pattern)
1643         , unicode(pattern-&gt;unicode())
1644         , output(output)
1645         , input(input, start, length, pattern-&gt;unicode())
1646         , startOffset(start)
1647         , remainingMatchCount(matchLimit)
1648     {
1649     }
1650 
1651 private:
1652     BytecodePattern* pattern;
1653     bool unicode;
1654     unsigned* output;
1655     InputStream input;
1656     WTF::BumpPointerPool* allocatorPool { nullptr };
1657     unsigned startOffset;
1658     unsigned remainingMatchCount;
1659 };
1660 
1661 class ByteCompiler {
1662     struct ParenthesesStackEntry {
1663         unsigned beginTerm;
1664         unsigned savedAlternativeIndex;
1665         ParenthesesStackEntry(unsigned beginTerm, unsigned savedAlternativeIndex/*, unsigned subpatternId, bool capture = false*/)
1666             : beginTerm(beginTerm)
1667             , savedAlternativeIndex(savedAlternativeIndex)
1668         {
1669         }
1670     };
1671 
1672 public:
1673     ByteCompiler(YarrPattern&amp; pattern)
1674         : m_pattern(pattern)
1675     {
1676     }
1677 
1678     std::unique_ptr&lt;BytecodePattern&gt; compile(BumpPointerAllocator* allocator, ConcurrentJSLock* lock, ErrorCode&amp; errorCode)
1679     {
1680         regexBegin(m_pattern.m_numSubpatterns, m_pattern.m_body-&gt;m_callFrameSize, m_pattern.m_body-&gt;m_alternatives[0]-&gt;onceThrough());
1681         if (auto error = emitDisjunction(m_pattern.m_body, 0, 0)) {
1682             errorCode = error.value();
1683             return nullptr;
1684         }
1685         regexEnd();
1686 
1687 #ifndef NDEBUG
1688         if (Options::dumpCompiledRegExpPatterns())
1689             dumpDisjunction(m_bodyDisjunction.get());
1690 #endif
1691 
<a name="5" id="anc5"></a><span class="line-modified">1692         return std::make_unique&lt;BytecodePattern&gt;(WTFMove(m_bodyDisjunction), m_allParenthesesInfo, m_pattern, allocator, lock);</span>
1693     }
1694 
1695     void checkInput(unsigned count)
1696     {
1697         m_bodyDisjunction-&gt;terms.append(ByteTerm::CheckInput(count));
1698     }
1699 
1700     void uncheckInput(unsigned count)
1701     {
1702         m_bodyDisjunction-&gt;terms.append(ByteTerm::UncheckInput(count));
1703     }
1704 
1705     void assertionBOL(unsigned inputPosition)
1706     {
1707         m_bodyDisjunction-&gt;terms.append(ByteTerm::BOL(inputPosition));
1708     }
1709 
1710     void assertionEOL(unsigned inputPosition)
1711     {
1712         m_bodyDisjunction-&gt;terms.append(ByteTerm::EOL(inputPosition));
1713     }
1714 
1715     void assertionWordBoundary(bool invert, unsigned inputPosition)
1716     {
1717         m_bodyDisjunction-&gt;terms.append(ByteTerm::WordBoundary(invert, inputPosition));
1718     }
1719 
1720     void atomPatternCharacter(UChar32 ch, unsigned inputPosition, unsigned frameLocation, Checked&lt;unsigned&gt; quantityMaxCount, QuantifierType quantityType)
1721     {
1722         if (m_pattern.ignoreCase()) {
1723             UChar32 lo = u_tolower(ch);
1724             UChar32 hi = u_toupper(ch);
1725 
1726             if (lo != hi) {
1727                 m_bodyDisjunction-&gt;terms.append(ByteTerm(lo, hi, inputPosition, frameLocation, quantityMaxCount, quantityType));
1728                 return;
1729             }
1730         }
1731 
1732         m_bodyDisjunction-&gt;terms.append(ByteTerm(ch, inputPosition, frameLocation, quantityMaxCount, quantityType));
1733     }
1734 
1735     void atomCharacterClass(CharacterClass* characterClass, bool invert, unsigned inputPosition, unsigned frameLocation, Checked&lt;unsigned&gt; quantityMaxCount, QuantifierType quantityType)
1736     {
1737         m_bodyDisjunction-&gt;terms.append(ByteTerm(characterClass, invert, inputPosition));
1738 
1739         m_bodyDisjunction-&gt;terms.last().atom.quantityMaxCount = quantityMaxCount.unsafeGet();
1740         m_bodyDisjunction-&gt;terms.last().atom.quantityType = quantityType;
1741         m_bodyDisjunction-&gt;terms.last().frameLocation = frameLocation;
1742     }
1743 
1744     void atomBackReference(unsigned subpatternId, unsigned inputPosition, unsigned frameLocation, Checked&lt;unsigned&gt; quantityMaxCount, QuantifierType quantityType)
1745     {
1746         ASSERT(subpatternId);
1747 
1748         m_bodyDisjunction-&gt;terms.append(ByteTerm::BackReference(subpatternId, inputPosition));
1749 
1750         m_bodyDisjunction-&gt;terms.last().atom.quantityMaxCount = quantityMaxCount.unsafeGet();
1751         m_bodyDisjunction-&gt;terms.last().atom.quantityType = quantityType;
1752         m_bodyDisjunction-&gt;terms.last().frameLocation = frameLocation;
1753     }
1754 
1755     void atomParenthesesOnceBegin(unsigned subpatternId, bool capture, unsigned inputPosition, unsigned frameLocation, unsigned alternativeFrameLocation)
1756     {
1757         unsigned beginTerm = m_bodyDisjunction-&gt;terms.size();
1758 
1759         m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParenthesesSubpatternOnceBegin, subpatternId, capture, false, inputPosition));
1760         m_bodyDisjunction-&gt;terms.last().frameLocation = frameLocation;
1761         m_bodyDisjunction-&gt;terms.append(ByteTerm::AlternativeBegin());
1762         m_bodyDisjunction-&gt;terms.last().frameLocation = alternativeFrameLocation;
1763 
1764         m_parenthesesStack.append(ParenthesesStackEntry(beginTerm, m_currentAlternativeIndex));
1765         m_currentAlternativeIndex = beginTerm + 1;
1766     }
1767 
1768     void atomParenthesesTerminalBegin(unsigned subpatternId, bool capture, unsigned inputPosition, unsigned frameLocation, unsigned alternativeFrameLocation)
1769     {
1770         unsigned beginTerm = m_bodyDisjunction-&gt;terms.size();
1771 
1772         m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParenthesesSubpatternTerminalBegin, subpatternId, capture, false, inputPosition));
1773         m_bodyDisjunction-&gt;terms.last().frameLocation = frameLocation;
1774         m_bodyDisjunction-&gt;terms.append(ByteTerm::AlternativeBegin());
1775         m_bodyDisjunction-&gt;terms.last().frameLocation = alternativeFrameLocation;
1776 
1777         m_parenthesesStack.append(ParenthesesStackEntry(beginTerm, m_currentAlternativeIndex));
1778         m_currentAlternativeIndex = beginTerm + 1;
1779     }
1780 
1781     void atomParenthesesSubpatternBegin(unsigned subpatternId, bool capture, unsigned inputPosition, unsigned frameLocation, unsigned alternativeFrameLocation)
1782     {
1783         // Errrk! - this is a little crazy, we initially generate as a TypeParenthesesSubpatternOnceBegin,
1784         // then fix this up at the end! - simplifying this should make it much clearer.
1785         // https://bugs.webkit.org/show_bug.cgi?id=50136
1786 
1787         unsigned beginTerm = m_bodyDisjunction-&gt;terms.size();
1788 
1789         m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParenthesesSubpatternOnceBegin, subpatternId, capture, false, inputPosition));
1790         m_bodyDisjunction-&gt;terms.last().frameLocation = frameLocation;
1791         m_bodyDisjunction-&gt;terms.append(ByteTerm::AlternativeBegin());
1792         m_bodyDisjunction-&gt;terms.last().frameLocation = alternativeFrameLocation;
1793 
1794         m_parenthesesStack.append(ParenthesesStackEntry(beginTerm, m_currentAlternativeIndex));
1795         m_currentAlternativeIndex = beginTerm + 1;
1796     }
1797 
1798     void atomParentheticalAssertionBegin(unsigned subpatternId, bool invert, unsigned frameLocation, unsigned alternativeFrameLocation)
1799     {
1800         unsigned beginTerm = m_bodyDisjunction-&gt;terms.size();
1801 
1802         m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParentheticalAssertionBegin, subpatternId, false, invert, 0));
1803         m_bodyDisjunction-&gt;terms.last().frameLocation = frameLocation;
1804         m_bodyDisjunction-&gt;terms.append(ByteTerm::AlternativeBegin());
1805         m_bodyDisjunction-&gt;terms.last().frameLocation = alternativeFrameLocation;
1806 
1807         m_parenthesesStack.append(ParenthesesStackEntry(beginTerm, m_currentAlternativeIndex));
1808         m_currentAlternativeIndex = beginTerm + 1;
1809     }
1810 
1811     void atomParentheticalAssertionEnd(unsigned inputPosition, unsigned frameLocation, Checked&lt;unsigned&gt; quantityMaxCount, QuantifierType quantityType)
1812     {
1813         unsigned beginTerm = popParenthesesStack();
1814         closeAlternative(beginTerm + 1);
1815         unsigned endTerm = m_bodyDisjunction-&gt;terms.size();
1816 
1817         ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeParentheticalAssertionBegin);
1818 
1819         bool invert = m_bodyDisjunction-&gt;terms[beginTerm].invert();
1820         unsigned subpatternId = m_bodyDisjunction-&gt;terms[beginTerm].atom.subpatternId;
1821 
1822         m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParentheticalAssertionEnd, subpatternId, false, invert, inputPosition));
1823         m_bodyDisjunction-&gt;terms[beginTerm].atom.parenthesesWidth = endTerm - beginTerm;
1824         m_bodyDisjunction-&gt;terms[endTerm].atom.parenthesesWidth = endTerm - beginTerm;
1825         m_bodyDisjunction-&gt;terms[endTerm].frameLocation = frameLocation;
1826 
1827         m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityMaxCount = quantityMaxCount.unsafeGet();
1828         m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityType = quantityType;
1829         m_bodyDisjunction-&gt;terms[endTerm].atom.quantityMaxCount = quantityMaxCount.unsafeGet();
1830         m_bodyDisjunction-&gt;terms[endTerm].atom.quantityType = quantityType;
1831     }
1832 
1833     void assertionDotStarEnclosure(bool bolAnchored, bool eolAnchored)
1834     {
1835         m_bodyDisjunction-&gt;terms.append(ByteTerm::DotStarEnclosure(bolAnchored, eolAnchored));
1836     }
1837 
1838     unsigned popParenthesesStack()
1839     {
1840         ASSERT(m_parenthesesStack.size());
1841         unsigned beginTerm = m_parenthesesStack.last().beginTerm;
1842         m_currentAlternativeIndex = m_parenthesesStack.last().savedAlternativeIndex;
1843         m_parenthesesStack.removeLast();
1844 
1845         ASSERT(beginTerm &lt; m_bodyDisjunction-&gt;terms.size());
1846         ASSERT(m_currentAlternativeIndex &lt; m_bodyDisjunction-&gt;terms.size());
1847 
1848         return beginTerm;
1849     }
1850 
1851     void closeAlternative(unsigned beginTerm)
1852     {
1853         unsigned origBeginTerm = beginTerm;
1854         ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeAlternativeBegin);
1855         unsigned endIndex = m_bodyDisjunction-&gt;terms.size();
1856 
1857         unsigned frameLocation = m_bodyDisjunction-&gt;terms[beginTerm].frameLocation;
1858 
1859         if (!m_bodyDisjunction-&gt;terms[beginTerm].alternative.next)
1860             m_bodyDisjunction-&gt;terms.remove(beginTerm);
1861         else {
1862             while (m_bodyDisjunction-&gt;terms[beginTerm].alternative.next) {
1863                 beginTerm += m_bodyDisjunction-&gt;terms[beginTerm].alternative.next;
1864                 ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeAlternativeDisjunction);
1865                 m_bodyDisjunction-&gt;terms[beginTerm].alternative.end = endIndex - beginTerm;
1866                 m_bodyDisjunction-&gt;terms[beginTerm].frameLocation = frameLocation;
1867             }
1868 
1869             m_bodyDisjunction-&gt;terms[beginTerm].alternative.next = origBeginTerm - beginTerm;
1870 
1871             m_bodyDisjunction-&gt;terms.append(ByteTerm::AlternativeEnd());
1872             m_bodyDisjunction-&gt;terms[endIndex].frameLocation = frameLocation;
1873         }
1874     }
1875 
1876     void closeBodyAlternative()
1877     {
1878         unsigned beginTerm = 0;
1879         unsigned origBeginTerm = 0;
1880         ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeBodyAlternativeBegin);
1881         unsigned endIndex = m_bodyDisjunction-&gt;terms.size();
1882 
1883         unsigned frameLocation = m_bodyDisjunction-&gt;terms[beginTerm].frameLocation;
1884 
1885         while (m_bodyDisjunction-&gt;terms[beginTerm].alternative.next) {
1886             beginTerm += m_bodyDisjunction-&gt;terms[beginTerm].alternative.next;
1887             ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeBodyAlternativeDisjunction);
1888             m_bodyDisjunction-&gt;terms[beginTerm].alternative.end = endIndex - beginTerm;
1889             m_bodyDisjunction-&gt;terms[beginTerm].frameLocation = frameLocation;
1890         }
1891 
1892         m_bodyDisjunction-&gt;terms[beginTerm].alternative.next = origBeginTerm - beginTerm;
1893 
1894         m_bodyDisjunction-&gt;terms.append(ByteTerm::BodyAlternativeEnd());
1895         m_bodyDisjunction-&gt;terms[endIndex].frameLocation = frameLocation;
1896     }
1897 
1898     void atomParenthesesSubpatternEnd(unsigned lastSubpatternId, unsigned inputPosition, unsigned frameLocation, Checked&lt;unsigned&gt; quantityMinCount, Checked&lt;unsigned&gt; quantityMaxCount, QuantifierType quantityType, unsigned callFrameSize = 0)
1899     {
1900         unsigned beginTerm = popParenthesesStack();
1901         closeAlternative(beginTerm + 1);
1902         unsigned endTerm = m_bodyDisjunction-&gt;terms.size();
1903 
1904         ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeParenthesesSubpatternOnceBegin);
1905 
1906         ByteTerm&amp; parenthesesBegin = m_bodyDisjunction-&gt;terms[beginTerm];
1907 
1908         bool capture = parenthesesBegin.capture();
1909         unsigned subpatternId = parenthesesBegin.atom.subpatternId;
1910 
1911         unsigned numSubpatterns = lastSubpatternId - subpatternId + 1;
<a name="6" id="anc6"></a><span class="line-modified">1912         auto parenthesesDisjunction = std::make_unique&lt;ByteDisjunction&gt;(numSubpatterns, callFrameSize);</span>
1913 
1914         unsigned firstTermInParentheses = beginTerm + 1;
1915         parenthesesDisjunction-&gt;terms.reserveInitialCapacity(endTerm - firstTermInParentheses + 2);
1916 
1917         parenthesesDisjunction-&gt;terms.append(ByteTerm::SubpatternBegin());
1918         for (unsigned termInParentheses = firstTermInParentheses; termInParentheses &lt; endTerm; ++termInParentheses)
1919             parenthesesDisjunction-&gt;terms.append(m_bodyDisjunction-&gt;terms[termInParentheses]);
1920         parenthesesDisjunction-&gt;terms.append(ByteTerm::SubpatternEnd());
1921 
1922         m_bodyDisjunction-&gt;terms.shrink(beginTerm);
1923 
1924         m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParenthesesSubpattern, subpatternId, parenthesesDisjunction.get(), capture, inputPosition));
1925         m_allParenthesesInfo.append(WTFMove(parenthesesDisjunction));
1926 
1927         m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityMinCount = quantityMinCount.unsafeGet();
1928         m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityMaxCount = quantityMaxCount.unsafeGet();
1929         m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityType = quantityType;
1930         m_bodyDisjunction-&gt;terms[beginTerm].frameLocation = frameLocation;
1931     }
1932 
1933     void atomParenthesesOnceEnd(unsigned inputPosition, unsigned frameLocation, Checked&lt;unsigned&gt; quantityMinCount, Checked&lt;unsigned&gt; quantityMaxCount, QuantifierType quantityType)
1934     {
1935         unsigned beginTerm = popParenthesesStack();
1936         closeAlternative(beginTerm + 1);
1937         unsigned endTerm = m_bodyDisjunction-&gt;terms.size();
1938 
1939         ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeParenthesesSubpatternOnceBegin);
1940 
1941         bool capture = m_bodyDisjunction-&gt;terms[beginTerm].capture();
1942         unsigned subpatternId = m_bodyDisjunction-&gt;terms[beginTerm].atom.subpatternId;
1943 
1944         m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParenthesesSubpatternOnceEnd, subpatternId, capture, false, inputPosition));
1945         m_bodyDisjunction-&gt;terms[beginTerm].atom.parenthesesWidth = endTerm - beginTerm;
1946         m_bodyDisjunction-&gt;terms[endTerm].atom.parenthesesWidth = endTerm - beginTerm;
1947         m_bodyDisjunction-&gt;terms[endTerm].frameLocation = frameLocation;
1948 
1949         m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityMinCount = quantityMinCount.unsafeGet();
1950         m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityMaxCount = quantityMaxCount.unsafeGet();
1951         m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityType = quantityType;
1952         m_bodyDisjunction-&gt;terms[endTerm].atom.quantityMinCount = quantityMinCount.unsafeGet();
1953         m_bodyDisjunction-&gt;terms[endTerm].atom.quantityMaxCount = quantityMaxCount.unsafeGet();
1954         m_bodyDisjunction-&gt;terms[endTerm].atom.quantityType = quantityType;
1955     }
1956 
1957     void atomParenthesesTerminalEnd(unsigned inputPosition, unsigned frameLocation, Checked&lt;unsigned&gt; quantityMinCount, Checked&lt;unsigned&gt; quantityMaxCount, QuantifierType quantityType)
1958     {
1959         unsigned beginTerm = popParenthesesStack();
1960         closeAlternative(beginTerm + 1);
1961         unsigned endTerm = m_bodyDisjunction-&gt;terms.size();
1962 
1963         ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeParenthesesSubpatternTerminalBegin);
1964 
1965         bool capture = m_bodyDisjunction-&gt;terms[beginTerm].capture();
1966         unsigned subpatternId = m_bodyDisjunction-&gt;terms[beginTerm].atom.subpatternId;
1967 
1968         m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParenthesesSubpatternTerminalEnd, subpatternId, capture, false, inputPosition));
1969         m_bodyDisjunction-&gt;terms[beginTerm].atom.parenthesesWidth = endTerm - beginTerm;
1970         m_bodyDisjunction-&gt;terms[endTerm].atom.parenthesesWidth = endTerm - beginTerm;
1971         m_bodyDisjunction-&gt;terms[endTerm].frameLocation = frameLocation;
1972 
1973         m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityMinCount = quantityMinCount.unsafeGet();
1974         m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityMaxCount = quantityMaxCount.unsafeGet();
1975         m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityType = quantityType;
1976         m_bodyDisjunction-&gt;terms[endTerm].atom.quantityMinCount = quantityMinCount.unsafeGet();
1977         m_bodyDisjunction-&gt;terms[endTerm].atom.quantityMaxCount = quantityMaxCount.unsafeGet();
1978         m_bodyDisjunction-&gt;terms[endTerm].atom.quantityType = quantityType;
1979     }
1980 
1981     void regexBegin(unsigned numSubpatterns, unsigned callFrameSize, bool onceThrough)
1982     {
<a name="7" id="anc7"></a><span class="line-modified">1983         m_bodyDisjunction = std::make_unique&lt;ByteDisjunction&gt;(numSubpatterns, callFrameSize);</span>
1984         m_bodyDisjunction-&gt;terms.append(ByteTerm::BodyAlternativeBegin(onceThrough));
1985         m_bodyDisjunction-&gt;terms[0].frameLocation = 0;
1986         m_currentAlternativeIndex = 0;
1987     }
1988 
1989     void regexEnd()
1990     {
1991         closeBodyAlternative();
1992     }
1993 
1994     void alternativeBodyDisjunction(bool onceThrough)
1995     {
1996         unsigned newAlternativeIndex = m_bodyDisjunction-&gt;terms.size();
1997         m_bodyDisjunction-&gt;terms[m_currentAlternativeIndex].alternative.next = newAlternativeIndex - m_currentAlternativeIndex;
1998         m_bodyDisjunction-&gt;terms.append(ByteTerm::BodyAlternativeDisjunction(onceThrough));
1999 
2000         m_currentAlternativeIndex = newAlternativeIndex;
2001     }
2002 
2003     void alternativeDisjunction()
2004     {
2005         unsigned newAlternativeIndex = m_bodyDisjunction-&gt;terms.size();
2006         m_bodyDisjunction-&gt;terms[m_currentAlternativeIndex].alternative.next = newAlternativeIndex - m_currentAlternativeIndex;
2007         m_bodyDisjunction-&gt;terms.append(ByteTerm::AlternativeDisjunction());
2008 
2009         m_currentAlternativeIndex = newAlternativeIndex;
2010     }
2011 
2012     Optional&lt;ErrorCode&gt; WARN_UNUSED_RETURN emitDisjunction(PatternDisjunction* disjunction, Checked&lt;unsigned, RecordOverflow&gt; inputCountAlreadyChecked, unsigned parenthesesInputCountAlreadyChecked)
2013     {
2014         for (unsigned alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt) {
2015             auto currentCountAlreadyChecked = inputCountAlreadyChecked;
2016 
2017             PatternAlternative* alternative = disjunction-&gt;m_alternatives[alt].get();
2018 
2019             if (alt) {
2020                 if (disjunction == m_pattern.m_body)
2021                     alternativeBodyDisjunction(alternative-&gt;onceThrough());
2022                 else
2023                     alternativeDisjunction();
2024             }
2025 
2026             unsigned minimumSize = alternative-&gt;m_minimumSize;
2027             ASSERT(minimumSize &gt;= parenthesesInputCountAlreadyChecked);
2028             unsigned countToCheck = minimumSize - parenthesesInputCountAlreadyChecked;
2029 
2030             if (countToCheck) {
2031                 checkInput(countToCheck);
2032                 currentCountAlreadyChecked += countToCheck;
2033                 if (currentCountAlreadyChecked.hasOverflowed())
2034                     return ErrorCode::OffsetTooLarge;
2035             }
2036 
2037             for (auto&amp; term : alternative-&gt;m_terms) {
2038                 switch (term.type) {
2039                 case PatternTerm::TypeAssertionBOL:
2040                     assertionBOL((currentCountAlreadyChecked - term.inputPosition).unsafeGet());
2041                     break;
2042 
2043                 case PatternTerm::TypeAssertionEOL:
2044                     assertionEOL((currentCountAlreadyChecked - term.inputPosition).unsafeGet());
2045                     break;
2046 
2047                 case PatternTerm::TypeAssertionWordBoundary:
2048                     assertionWordBoundary(term.invert(), (currentCountAlreadyChecked - term.inputPosition).unsafeGet());
2049                     break;
2050 
2051                 case PatternTerm::TypePatternCharacter:
2052                     atomPatternCharacter(term.patternCharacter, (currentCountAlreadyChecked - term.inputPosition).unsafeGet(), term.frameLocation, term.quantityMaxCount, term.quantityType);
2053                     break;
2054 
2055                 case PatternTerm::TypeCharacterClass:
2056                     atomCharacterClass(term.characterClass, term.invert(), (currentCountAlreadyChecked - term.inputPosition).unsafeGet(), term.frameLocation, term.quantityMaxCount, term.quantityType);
2057                     break;
2058 
2059                 case PatternTerm::TypeBackReference:
2060                     atomBackReference(term.backReferenceSubpatternId, (currentCountAlreadyChecked - term.inputPosition).unsafeGet(), term.frameLocation, term.quantityMaxCount, term.quantityType);
<a name="8" id="anc8"></a><span class="line-modified">2061                         break;</span>
2062 
2063                 case PatternTerm::TypeForwardReference:
2064                     break;
2065 
2066                 case PatternTerm::TypeParenthesesSubpattern: {
2067                     unsigned disjunctionAlreadyCheckedCount = 0;
2068                     if (term.quantityMaxCount == 1 &amp;&amp; !term.parentheses.isCopy) {
2069                         unsigned alternativeFrameLocation = term.frameLocation;
2070                         // For QuantifierFixedCount we pre-check the minimum size; for greedy/non-greedy we reserve a slot in the frame.
2071                         if (term.quantityType == QuantifierFixedCount)
2072                             disjunctionAlreadyCheckedCount = term.parentheses.disjunction-&gt;m_minimumSize;
2073                         else
2074                             alternativeFrameLocation += YarrStackSpaceForBackTrackInfoParenthesesOnce;
2075                         unsigned delegateEndInputOffset = (currentCountAlreadyChecked - term.inputPosition).unsafeGet();
2076                         atomParenthesesOnceBegin(term.parentheses.subpatternId, term.capture(), disjunctionAlreadyCheckedCount + delegateEndInputOffset, term.frameLocation, alternativeFrameLocation);
2077                         if (auto error = emitDisjunction(term.parentheses.disjunction, currentCountAlreadyChecked, disjunctionAlreadyCheckedCount))
2078                             return error;
2079                         atomParenthesesOnceEnd(delegateEndInputOffset, term.frameLocation, term.quantityMinCount, term.quantityMaxCount, term.quantityType);
2080                     } else if (term.parentheses.isTerminal) {
2081                         unsigned delegateEndInputOffset = (currentCountAlreadyChecked - term.inputPosition).unsafeGet();
2082                         atomParenthesesTerminalBegin(term.parentheses.subpatternId, term.capture(), disjunctionAlreadyCheckedCount + delegateEndInputOffset, term.frameLocation, term.frameLocation + YarrStackSpaceForBackTrackInfoParenthesesTerminal);
2083                         if (auto error = emitDisjunction(term.parentheses.disjunction, currentCountAlreadyChecked, disjunctionAlreadyCheckedCount))
2084                             return error;
2085                         atomParenthesesTerminalEnd(delegateEndInputOffset, term.frameLocation, term.quantityMinCount, term.quantityMaxCount, term.quantityType);
2086                     } else {
2087                         unsigned delegateEndInputOffset = (currentCountAlreadyChecked - term.inputPosition).unsafeGet();
2088                         atomParenthesesSubpatternBegin(term.parentheses.subpatternId, term.capture(), disjunctionAlreadyCheckedCount + delegateEndInputOffset, term.frameLocation, 0);
2089                         if (auto error = emitDisjunction(term.parentheses.disjunction, currentCountAlreadyChecked, 0))
2090                             return error;
2091                         atomParenthesesSubpatternEnd(term.parentheses.lastSubpatternId, delegateEndInputOffset, term.frameLocation, term.quantityMinCount, term.quantityMaxCount, term.quantityType, term.parentheses.disjunction-&gt;m_callFrameSize);
2092                     }
2093                     break;
2094                 }
2095 
2096                 case PatternTerm::TypeParentheticalAssertion: {
2097                     unsigned alternativeFrameLocation = term.frameLocation + YarrStackSpaceForBackTrackInfoParentheticalAssertion;
2098                     unsigned positiveInputOffset = (currentCountAlreadyChecked - term.inputPosition).unsafeGet();
2099                     unsigned uncheckAmount = 0;
2100                     if (positiveInputOffset &gt; term.parentheses.disjunction-&gt;m_minimumSize) {
2101                         uncheckAmount = positiveInputOffset - term.parentheses.disjunction-&gt;m_minimumSize;
2102                         uncheckInput(uncheckAmount);
2103                         currentCountAlreadyChecked -= uncheckAmount;
2104                         if (currentCountAlreadyChecked.hasOverflowed())
2105                             return ErrorCode::OffsetTooLarge;
2106                     }
2107 
2108                     atomParentheticalAssertionBegin(term.parentheses.subpatternId, term.invert(), term.frameLocation, alternativeFrameLocation);
2109                     if (auto error = emitDisjunction(term.parentheses.disjunction, currentCountAlreadyChecked, positiveInputOffset - uncheckAmount))
2110                         return error;
2111                     atomParentheticalAssertionEnd(0, term.frameLocation, term.quantityMaxCount, term.quantityType);
2112                     if (uncheckAmount) {
2113                         checkInput(uncheckAmount);
2114                         currentCountAlreadyChecked += uncheckAmount;
2115                         if (currentCountAlreadyChecked.hasOverflowed())
2116                             return ErrorCode::OffsetTooLarge;
2117                     }
2118                     break;
2119                 }
2120 
2121                 case PatternTerm::TypeDotStarEnclosure:
2122                     assertionDotStarEnclosure(term.anchors.bolAnchor, term.anchors.eolAnchor);
2123                     break;
2124                 }
2125             }
2126         }
2127         return WTF::nullopt;
2128     }
2129 #ifndef NDEBUG
2130     void dumpDisjunction(ByteDisjunction* disjunction, unsigned nesting = 0)
2131     {
2132         PrintStream&amp; out = WTF::dataFile();
2133 
2134         unsigned termIndexNest = 0;
2135 
2136         if (!nesting) {
2137             out.printf(&quot;ByteDisjunction(%p):\n&quot;, disjunction);
2138             nesting = 1;
2139         } else {
2140             termIndexNest = nesting - 1;
2141             nesting = 2;
2142         }
2143 
2144         auto outputTermIndexAndNest = [&amp;](size_t index, unsigned termNesting) {
2145             for (unsigned nestingDepth = 0; nestingDepth &lt; termIndexNest; nestingDepth++)
2146                 out.print(&quot;  &quot;);
2147             out.printf(&quot;%4zu&quot;, index);
2148             for (unsigned nestingDepth = 0; nestingDepth &lt; termNesting; nestingDepth++)
2149                 out.print(&quot;  &quot;);
2150         };
2151 
2152         auto dumpQuantity = [&amp;](ByteTerm&amp; term) {
2153             if (term.atom.quantityType == QuantifierFixedCount &amp;&amp; term.atom.quantityMinCount == 1 &amp;&amp; term.atom.quantityMaxCount == 1)
2154                 return;
2155 
2156             out.print(&quot; {&quot;, term.atom.quantityMinCount);
2157             if (term.atom.quantityMinCount != term.atom.quantityMaxCount) {
2158                 if (term.atom.quantityMaxCount == UINT_MAX)
2159                     out.print(&quot;,inf&quot;);
2160                 else
2161                     out.print(&quot;,&quot;, term.atom.quantityMaxCount);
2162             }
2163             out.print(&quot;}&quot;);
2164             if (term.atom.quantityType == QuantifierGreedy)
2165                 out.print(&quot; greedy&quot;);
2166             else if (term.atom.quantityType == QuantifierNonGreedy)
2167                 out.print(&quot; non-greedy&quot;);
2168         };
2169 
2170         auto dumpCaptured = [&amp;](ByteTerm&amp; term) {
2171             if (term.capture())
2172                 out.print(&quot; captured (#&quot;, term.atom.subpatternId, &quot;)&quot;);
2173         };
2174 
2175         auto dumpInverted = [&amp;](ByteTerm&amp; term) {
2176             if (term.invert())
2177                 out.print(&quot; inverted&quot;);
2178         };
2179 
2180         auto dumpInputPosition = [&amp;](ByteTerm&amp; term) {
2181             out.printf(&quot; inputPosition %u&quot;, term.inputPosition);
2182         };
2183 
2184         auto dumpFrameLocation = [&amp;](ByteTerm&amp; term) {
2185             out.printf(&quot; frameLocation %u&quot;, term.frameLocation);
2186         };
2187 
2188         auto dumpCharacter = [&amp;](ByteTerm&amp; term) {
2189             out.print(&quot; &quot;);
2190             dumpUChar32(out, term.atom.patternCharacter);
2191         };
2192 
2193         auto dumpCharClass = [&amp;](ByteTerm&amp; term) {
2194             out.print(&quot; &quot;);
2195             dumpCharacterClass(out, &amp;m_pattern, term.atom.characterClass);
2196         };
2197 
2198         for (size_t idx = 0; idx &lt; disjunction-&gt;terms.size(); ++idx) {
2199             ByteTerm term = disjunction-&gt;terms[idx];
2200 
2201             bool outputNewline = true;
2202 
2203             switch (term.type) {
2204             case ByteTerm::TypeBodyAlternativeBegin:
2205                 outputTermIndexAndNest(idx, nesting++);
2206                 out.print(&quot;BodyAlternativeBegin&quot;);
2207                 if (term.alternative.onceThrough)
2208                     out.print(&quot; onceThrough&quot;);
2209                 dumpFrameLocation(term);
2210                 break;
2211             case ByteTerm::TypeBodyAlternativeDisjunction:
2212                 outputTermIndexAndNest(idx, nesting - 1);
2213                 out.print(&quot;BodyAlternativeDisjunction&quot;);
2214                 dumpFrameLocation(term);
2215                 break;
2216             case ByteTerm::TypeBodyAlternativeEnd:
2217                 outputTermIndexAndNest(idx, --nesting);
2218                 out.print(&quot;BodyAlternativeEnd&quot;);
2219                 dumpFrameLocation(term);
2220                 break;
2221             case ByteTerm::TypeAlternativeBegin:
2222                 outputTermIndexAndNest(idx, nesting++);
2223                 out.print(&quot;AlternativeBegin&quot;);
2224                 dumpFrameLocation(term);
2225                 break;
2226             case ByteTerm::TypeAlternativeDisjunction:
2227                 outputTermIndexAndNest(idx, nesting - 1);
2228                 out.print(&quot;AlternativeDisjunction&quot;);
2229                 dumpFrameLocation(term);
2230                 break;
2231             case ByteTerm::TypeAlternativeEnd:
2232                 outputTermIndexAndNest(idx, --nesting);
2233                 out.print(&quot;AlternativeEnd&quot;);
2234                 dumpFrameLocation(term);
2235                 break;
2236             case ByteTerm::TypeSubpatternBegin:
2237                 outputTermIndexAndNest(idx, nesting++);
2238                 out.print(&quot;SubpatternBegin&quot;);
2239                 break;
2240             case ByteTerm::TypeSubpatternEnd:
2241                 outputTermIndexAndNest(idx, --nesting);
2242                 out.print(&quot;SubpatternEnd&quot;);
2243                 break;
2244             case ByteTerm::TypeAssertionBOL:
2245                 outputTermIndexAndNest(idx, nesting);
2246                 out.print(&quot;AssertionBOL&quot;);
2247                 break;
2248             case ByteTerm::TypeAssertionEOL:
2249                 outputTermIndexAndNest(idx, nesting);
2250                 out.print(&quot;AssertionEOL&quot;);
2251                 break;
2252             case ByteTerm::TypeAssertionWordBoundary:
2253                 outputTermIndexAndNest(idx, nesting);
2254                 out.print(&quot;AssertionWordBoundary&quot;);
2255                 break;
2256             case ByteTerm::TypePatternCharacterOnce:
2257                 outputTermIndexAndNest(idx, nesting);
2258                 out.print(&quot;PatternCharacterOnce&quot;);
2259                 dumpInverted(term);
2260                 dumpInputPosition(term);
2261                 dumpFrameLocation(term);
2262                 dumpCharacter(term);
2263                 dumpQuantity(term);
2264                 break;
2265             case ByteTerm::TypePatternCharacterFixed:
2266                 outputTermIndexAndNest(idx, nesting);
2267                 out.print(&quot;PatternCharacterFixed&quot;);
2268                 dumpInverted(term);
2269                 dumpInputPosition(term);
2270                 dumpFrameLocation(term);
2271                 dumpCharacter(term);
2272                 out.print(&quot; {&quot;, term.atom.quantityMinCount, &quot;}&quot;);
2273                 break;
2274             case ByteTerm::TypePatternCharacterGreedy:
2275                 outputTermIndexAndNest(idx, nesting);
2276                 out.print(&quot;PatternCharacterGreedy&quot;);
2277                 dumpInverted(term);
2278                 dumpInputPosition(term);
2279                 dumpFrameLocation(term);
2280                 dumpCharacter(term);
2281                 dumpQuantity(term);
2282                 break;
2283             case ByteTerm::TypePatternCharacterNonGreedy:
2284                 outputTermIndexAndNest(idx, nesting);
2285                 out.print(&quot;PatternCharacterNonGreedy&quot;);
2286                 dumpInverted(term);
2287                 dumpInputPosition(term);
2288                 dumpFrameLocation(term);
2289                 dumpCharacter(term);
2290                 dumpQuantity(term);
2291                 break;
2292             case ByteTerm::TypePatternCasedCharacterOnce:
2293                 outputTermIndexAndNest(idx, nesting);
2294                 out.print(&quot;PatternCasedCharacterOnce&quot;);
2295                 break;
2296             case ByteTerm::TypePatternCasedCharacterFixed:
2297                 outputTermIndexAndNest(idx, nesting);
2298                 out.print(&quot;PatternCasedCharacterFixed&quot;);
2299                 break;
2300             case ByteTerm::TypePatternCasedCharacterGreedy:
2301                 outputTermIndexAndNest(idx, nesting);
2302                 out.print(&quot;PatternCasedCharacterGreedy&quot;);
2303                 break;
2304             case ByteTerm::TypePatternCasedCharacterNonGreedy:
2305                 outputTermIndexAndNest(idx, nesting);
2306                 out.print(&quot;PatternCasedCharacterNonGreedy&quot;);
2307                 break;
2308             case ByteTerm::TypeCharacterClass:
2309                 outputTermIndexAndNest(idx, nesting);
2310                 out.print(&quot;CharacterClass&quot;);
2311                 dumpInverted(term);
2312                 dumpInputPosition(term);
2313                 dumpFrameLocation(term);
2314                 dumpCharClass(term);
2315                 dumpQuantity(term);
2316                 break;
2317             case ByteTerm::TypeBackReference:
2318                 outputTermIndexAndNest(idx, nesting);
2319                 out.print(&quot;BackReference #&quot;, term.atom.subpatternId);
2320                 dumpQuantity(term);
2321                 break;
2322             case ByteTerm::TypeParenthesesSubpattern:
2323                 outputTermIndexAndNest(idx, nesting);
2324                 out.print(&quot;ParenthesesSubpattern&quot;);
2325                 dumpCaptured(term);
2326                 dumpInverted(term);
2327                 dumpInputPosition(term);
2328                 dumpFrameLocation(term);
2329                 dumpQuantity(term);
2330                 out.print(&quot;\n&quot;);
2331                 outputNewline = false;
2332                 dumpDisjunction(term.atom.parenthesesDisjunction, nesting);
2333                 break;
2334             case ByteTerm::TypeParenthesesSubpatternOnceBegin:
2335                 outputTermIndexAndNest(idx, nesting++);
2336                 out.print(&quot;ParenthesesSubpatternOnceBegin&quot;);
2337                 dumpCaptured(term);
2338                 dumpInverted(term);
2339                 dumpInputPosition(term);
2340                 dumpFrameLocation(term);
2341                 break;
2342             case ByteTerm::TypeParenthesesSubpatternOnceEnd:
2343                 outputTermIndexAndNest(idx, --nesting);
2344                 out.print(&quot;ParenthesesSubpatternOnceEnd&quot;);
2345                 dumpFrameLocation(term);
2346                 break;
2347             case ByteTerm::TypeParenthesesSubpatternTerminalBegin:
2348                 outputTermIndexAndNest(idx, nesting++);
2349                 out.print(&quot;ParenthesesSubpatternTerminalBegin&quot;);
2350                 dumpInverted(term);
2351                 dumpInputPosition(term);
2352                 dumpFrameLocation(term);
2353                 break;
2354             case ByteTerm::TypeParenthesesSubpatternTerminalEnd:
2355                 outputTermIndexAndNest(idx, --nesting);
2356                 out.print(&quot;ParenthesesSubpatternTerminalEnd&quot;);
2357                 dumpFrameLocation(term);
2358                 break;
2359             case ByteTerm::TypeParentheticalAssertionBegin:
2360                 outputTermIndexAndNest(idx, nesting++);
2361                 out.print(&quot;ParentheticalAssertionBegin&quot;);
2362                 dumpInverted(term);
2363                 dumpInputPosition(term);
2364                 dumpFrameLocation(term);
2365                 break;
2366             case ByteTerm::TypeParentheticalAssertionEnd:
2367                 outputTermIndexAndNest(idx, --nesting);
2368                 out.print(&quot;ParentheticalAssertionEnd&quot;);
2369                 dumpFrameLocation(term);
2370                 break;
2371             case ByteTerm::TypeCheckInput:
2372                 outputTermIndexAndNest(idx, nesting);
2373                 out.print(&quot;CheckInput &quot;, term.checkInputCount);
2374                 break;
2375             case ByteTerm::TypeUncheckInput:
2376                 outputTermIndexAndNest(idx, nesting);
2377                 out.print(&quot;UncheckInput &quot;, term.checkInputCount);
2378                 break;
2379             case ByteTerm::TypeDotStarEnclosure:
2380                 outputTermIndexAndNest(idx, nesting);
2381                 out.print(&quot;DotStarEnclosure&quot;);
2382                 break;
2383             }
2384             if (outputNewline)
2385                 out.print(&quot;\n&quot;);
2386         }
2387     }
2388 #endif
2389 
2390 private:
2391     YarrPattern&amp; m_pattern;
2392     std::unique_ptr&lt;ByteDisjunction&gt; m_bodyDisjunction;
2393     unsigned m_currentAlternativeIndex { 0 };
2394     Vector&lt;ParenthesesStackEntry&gt; m_parenthesesStack;
2395     Vector&lt;std::unique_ptr&lt;ByteDisjunction&gt;&gt; m_allParenthesesInfo;
2396 };
2397 
2398 std::unique_ptr&lt;BytecodePattern&gt; byteCompile(YarrPattern&amp; pattern, BumpPointerAllocator* allocator, ErrorCode&amp; errorCode, ConcurrentJSLock* lock)
2399 {
2400     return ByteCompiler(pattern).compile(allocator, lock, errorCode);
2401 }
2402 
2403 unsigned interpret(BytecodePattern* bytecode, const String&amp; input, unsigned start, unsigned* output)
2404 {
2405     SuperSamplerScope superSamplerScope(false);
2406     if (input.is8Bit())
2407         return Interpreter&lt;LChar&gt;(bytecode, output, input.characters8(), input.length(), start).interpret();
2408     return Interpreter&lt;UChar&gt;(bytecode, output, input.characters16(), input.length(), start).interpret();
2409 }
2410 
2411 unsigned interpret(BytecodePattern* bytecode, const LChar* input, unsigned length, unsigned start, unsigned* output)
2412 {
2413     SuperSamplerScope superSamplerScope(false);
2414     return Interpreter&lt;LChar&gt;(bytecode, output, input, length, start).interpret();
2415 }
2416 
2417 unsigned interpret(BytecodePattern* bytecode, const UChar* input, unsigned length, unsigned start, unsigned* output)
2418 {
2419     SuperSamplerScope superSamplerScope(false);
2420     return Interpreter&lt;UChar&gt;(bytecode, output, input, length, start).interpret();
2421 }
2422 
2423 // These should be the same for both UChar &amp; LChar.
2424 COMPILE_ASSERT(sizeof(BackTrackInfoPatternCharacter) == (YarrStackSpaceForBackTrackInfoPatternCharacter * sizeof(uintptr_t)), CheckYarrStackSpaceForBackTrackInfoPatternCharacter);
2425 COMPILE_ASSERT(sizeof(BackTrackInfoCharacterClass) == (YarrStackSpaceForBackTrackInfoCharacterClass * sizeof(uintptr_t)), CheckYarrStackSpaceForBackTrackInfoCharacterClass);
2426 COMPILE_ASSERT(sizeof(BackTrackInfoBackReference) == (YarrStackSpaceForBackTrackInfoBackReference * sizeof(uintptr_t)), CheckYarrStackSpaceForBackTrackInfoBackReference);
2427 COMPILE_ASSERT(sizeof(BackTrackInfoAlternative) == (YarrStackSpaceForBackTrackInfoAlternative * sizeof(uintptr_t)), CheckYarrStackSpaceForBackTrackInfoAlternative);
2428 COMPILE_ASSERT(sizeof(BackTrackInfoParentheticalAssertion) == (YarrStackSpaceForBackTrackInfoParentheticalAssertion * sizeof(uintptr_t)), CheckYarrStackSpaceForBackTrackInfoParentheticalAssertion);
2429 COMPILE_ASSERT(sizeof(BackTrackInfoParenthesesOnce) == (YarrStackSpaceForBackTrackInfoParenthesesOnce * sizeof(uintptr_t)), CheckYarrStackSpaceForBackTrackInfoParenthesesOnce);
2430 COMPILE_ASSERT(sizeof(Interpreter&lt;UChar&gt;::BackTrackInfoParentheses) &lt;= (YarrStackSpaceForBackTrackInfoParentheses * sizeof(uintptr_t)), CheckYarrStackSpaceForBackTrackInfoParentheses);
2431 
2432 
2433 } }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>