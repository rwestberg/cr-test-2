<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  * Copyright (C) 2003, 2006, 2007, 2015 Apple Inc. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;FrameView.h&quot;
 26 #include &quot;RenderBoxModelObject.h&quot;
 27 #include &quot;RenderOverflow.h&quot;
 28 #include &quot;ScrollTypes.h&quot;
 29 #include &quot;ShapeOutsideInfo.h&quot;
 30 
 31 namespace WebCore {
 32 
 33 class InlineElementBox;
 34 class RenderBlockFlow;
 35 class RenderBoxFragmentInfo;
 36 class RenderFragmentContainer;
 37 struct PaintInfo;
 38 
 39 enum SizeType { MainOrPreferredSize, MinSize, MaxSize };
 40 enum AvailableLogicalHeightType { ExcludeMarginBorderPadding, IncludeMarginBorderPadding };
 41 enum OverlayScrollbarSizeRelevancy { IgnoreOverlayScrollbarSize, IncludeOverlayScrollbarSize };
 42 
 43 enum ShouldComputePreferred { ComputeActual, ComputePreferred };
 44 
 45 class RenderBox : public RenderBoxModelObject {
 46     WTF_MAKE_ISO_ALLOCATED(RenderBox);
 47 public:
 48     virtual ~RenderBox();
 49 
 50     // hasAutoZIndex only returns true if the element is positioned or a flex-item since
 51     // position:static elements that are not flex-items get their z-index coerced to auto.
 52     bool requiresLayer() const override
 53     {
 54         return isDocumentElementRenderer() || isPositioned() || createsGroup() || hasClipPath() || hasOverflowClip()
 55             || hasTransformRelatedProperty() || hasHiddenBackface() || hasReflection() || style().specifiesColumns()
 56             || !style().hasAutoZIndex() || hasRunningAcceleratedAnimations();
 57     }
 58 
 59     bool backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect) const final;
 60 
 61     // Returns false for the body renderer if its background is propagated to the root.
 62     bool paintsOwnBackground() const;
 63 
 64     LayoutUnit x() const { return m_frameRect.x(); }
 65     LayoutUnit y() const { return m_frameRect.y(); }
 66     LayoutUnit width() const { return m_frameRect.width(); }
 67     LayoutUnit height() const { return m_frameRect.height(); }
 68 
 69     // These represent your location relative to your container as a physical offset.
 70     // In layout related methods you almost always want the logical location (e.g. x() and y()).
 71     LayoutUnit top() const { return topLeftLocation().y(); }
 72     LayoutUnit left() const { return topLeftLocation().x(); }
 73 
 74     void setX(LayoutUnit x) { m_frameRect.setX(x); }
 75     void setY(LayoutUnit y) { m_frameRect.setY(y); }
 76     void setWidth(LayoutUnit width) { m_frameRect.setWidth(width); }
 77     void setHeight(LayoutUnit height) { m_frameRect.setHeight(height); }
 78 
 79     LayoutUnit logicalLeft() const { return style().isHorizontalWritingMode() ? x() : y(); }
 80     LayoutUnit logicalRight() const { return logicalLeft() + logicalWidth(); }
 81     LayoutUnit logicalTop() const { return style().isHorizontalWritingMode() ? y() : x(); }
 82     LayoutUnit logicalBottom() const { return logicalTop() + logicalHeight(); }
 83     LayoutUnit logicalWidth() const { return style().isHorizontalWritingMode() ? width() : height(); }
 84     LayoutUnit logicalHeight() const { return style().isHorizontalWritingMode() ? height() : width(); }
 85 
 86     LayoutUnit constrainLogicalWidthInFragmentByMinMax(LayoutUnit, LayoutUnit, RenderBlock&amp;, RenderFragmentContainer* = nullptr) const;
 87     LayoutUnit constrainLogicalHeightByMinMax(LayoutUnit logicalHeight, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const;
 88     LayoutUnit constrainContentBoxLogicalHeightByMinMax(LayoutUnit logicalHeight, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const;
 89 
 90     void setLogicalLeft(LayoutUnit left)
 91     {
 92         if (style().isHorizontalWritingMode())
 93             setX(left);
 94         else
 95             setY(left);
 96     }
 97     void setLogicalTop(LayoutUnit top)
 98     {
 99         if (style().isHorizontalWritingMode())
100             setY(top);
101         else
102             setX(top);
103     }
104     void setLogicalLocation(const LayoutPoint&amp; location)
105     {
106         if (style().isHorizontalWritingMode())
107             setLocation(location);
108         else
109             setLocation(location.transposedPoint());
110     }
111     void setLogicalWidth(LayoutUnit size)
112     {
113         if (style().isHorizontalWritingMode())
114             setWidth(size);
115         else
116             setHeight(size);
117     }
118     void setLogicalHeight(LayoutUnit size)
119     {
120         if (style().isHorizontalWritingMode())
121             setHeight(size);
122         else
123             setWidth(size);
124     }
125     void setLogicalSize(const LayoutSize&amp; size)
126     {
127         if (style().isHorizontalWritingMode())
128             setSize(size);
129         else
130             setSize(size.transposedSize());
131     }
132 
133     LayoutPoint location() const { return m_frameRect.location(); }
134     LayoutSize locationOffset() const { return LayoutSize(x(), y()); }
135     LayoutSize size() const { return m_frameRect.size(); }
136 
137     void setLocation(const LayoutPoint&amp; location) { m_frameRect.setLocation(location); }
138 
139     void setSize(const LayoutSize&amp; size) { m_frameRect.setSize(size); }
140     void move(LayoutUnit dx, LayoutUnit dy) { m_frameRect.move(dx, dy); }
141 
142     LayoutRect frameRect() const { return m_frameRect; }
143     void setFrameRect(const LayoutRect&amp; rect) { m_frameRect = rect; }
144 
145     LayoutRect marginBoxRect() const
146     {
147         auto marginLeft = computedCSSPadding(style().marginLeft());
148         auto marginRight = computedCSSPadding(style().marginRight());
149         auto marginTop = computedCSSPadding(style().marginTop());
150         auto marginBottom = computedCSSPadding(style().marginBottom());
151         return LayoutRect(-marginLeft, -marginTop, size().width() + marginLeft + marginRight, size().height() + marginTop + marginBottom);
152     }
153     LayoutRect borderBoxRect() const { return LayoutRect(LayoutPoint(), size()); }
154     LayoutRect borderBoundingBox() const final { return borderBoxRect(); }
155 
156     WEBCORE_EXPORT RoundedRect::Radii borderRadii() const;
157 
158     // The content area of the box (excludes padding - and intrinsic padding for table cells, etc... - and border).
159     LayoutRect contentBoxRect() const;
160     LayoutPoint contentBoxLocation() const;
161 
162     // The content box in absolute coords. Ignores transforms.
163     IntRect absoluteContentBox() const;
164     // The content box converted to absolute coords (taking transforms into account).
165     WEBCORE_EXPORT FloatQuad absoluteContentQuad() const;
166 
167     // This returns the content area of the box (excluding padding and border). The only difference with contentBoxRect is that computedCSSContentBoxRect
168     // does include the intrinsic padding in the content box as this is what some callers expect (like getComputedStyle).
169     LayoutRect computedCSSContentBoxRect() const { return LayoutRect(borderLeft() + computedCSSPaddingLeft(), borderTop() + computedCSSPaddingTop(), paddingBoxWidth() - computedCSSPaddingLeft() - computedCSSPaddingRight(), paddingBoxHeight() - computedCSSPaddingTop() - computedCSSPaddingBottom()); }
170 
171     // Bounds of the outline box in absolute coords. Respects transforms
172     LayoutRect outlineBoundsForRepaint(const RenderLayerModelObject* /*repaintContainer*/, const RenderGeometryMap*) const final;
173     void addFocusRingRects(Vector&lt;LayoutRect&gt;&amp;, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject* paintContainer = nullptr) override;
174 
175     FloatRect repaintRectInLocalCoordinates() const override { return borderBoxRect(); }
176     FloatRect objectBoundingBox() const override { return borderBoxRect(); }
177 
178     // Note these functions are not equivalent of childrenOfType&lt;RenderBox&gt;
179     RenderBox* parentBox() const;
180     RenderBox* firstChildBox() const;
181     RenderBox* lastChildBox() const;
182     RenderBox* previousSiblingBox() const;
183     RenderBox* nextSiblingBox() const;
184 
185     // Visual and layout overflow are in the coordinate space of the box.  This means that they aren&#39;t purely physical directions.
186     // For horizontal-tb and vertical-lr they will match physical directions, but for horizontal-bt and vertical-rl, the top/bottom and left/right
187     // respectively are flipped when compared to their physical counterparts.  For example minX is on the left in vertical-lr,
188     // but it is on the right in vertical-rl.
189     WEBCORE_EXPORT LayoutRect flippedClientBoxRect() const;
190     LayoutRect layoutOverflowRect() const { return m_overflow ? m_overflow-&gt;layoutOverflowRect() : flippedClientBoxRect(); }
191     LayoutUnit logicalLeftLayoutOverflow() const { return style().isHorizontalWritingMode() ? layoutOverflowRect().x() : layoutOverflowRect().y(); }
192     LayoutUnit logicalRightLayoutOverflow() const { return style().isHorizontalWritingMode() ? layoutOverflowRect().maxX() : layoutOverflowRect().maxY(); }
193 
194     virtual LayoutRect visualOverflowRect() const { return m_overflow ? m_overflow-&gt;visualOverflowRect() : borderBoxRect(); }
195     LayoutUnit logicalLeftVisualOverflow() const { return style().isHorizontalWritingMode() ? visualOverflowRect().x() : visualOverflowRect().y(); }
196     LayoutUnit logicalRightVisualOverflow() const { return style().isHorizontalWritingMode() ? visualOverflowRect().maxX() : visualOverflowRect().maxY(); }
197 
198     LayoutRect overflowRectForPaintRejection() const;
199 
200     void addLayoutOverflow(const LayoutRect&amp;);
201     void addVisualOverflow(const LayoutRect&amp;);
202     void clearOverflow();
203 
204     virtual bool isTopLayoutOverflowAllowed() const { return !style().isLeftToRightDirection() &amp;&amp; !isHorizontalWritingMode(); }
205     virtual bool isLeftLayoutOverflowAllowed() const { return !style().isLeftToRightDirection() &amp;&amp; isHorizontalWritingMode(); }
206 
207     void addVisualEffectOverflow();
208     LayoutRect applyVisualEffectOverflow(const LayoutRect&amp;) const;
209     void addOverflowFromChild(const RenderBox* child) { addOverflowFromChild(child, child-&gt;locationOffset()); }
210     void addOverflowFromChild(const RenderBox* child, const LayoutSize&amp; delta);
211 
212     void updateLayerTransform();
213 
214     LayoutSize contentSize() const { return { contentWidth(), contentHeight() }; }
215     LayoutUnit contentWidth() const { return paddingBoxWidth() - paddingLeft() - paddingRight(); }
216     LayoutUnit contentHeight() const { return paddingBoxHeight() - paddingTop() - paddingBottom(); }
217     LayoutUnit contentLogicalWidth() const { return style().isHorizontalWritingMode() ? contentWidth() : contentHeight(); }
218     LayoutUnit contentLogicalHeight() const { return style().isHorizontalWritingMode() ? contentHeight() : contentWidth(); }
219 
220     LayoutUnit paddingBoxWidth() const { return width() - borderLeft() - borderRight() - verticalScrollbarWidth(); }
221     LayoutUnit paddingBoxHeight() const { return height() - borderTop() - borderBottom() - horizontalScrollbarHeight(); }
222     LayoutRect paddingBoxRect() const { return LayoutRect(borderLeft(), borderTop(), paddingBoxWidth(), paddingBoxHeight()); }
223     LayoutRect paddingBoxRectIncludingScrollbar() const { return LayoutRect(borderLeft(), borderTop(), width() - borderLeft() - borderRight(), height() - borderTop() - borderBottom()); }
224 
225     // IE extensions. Used to calculate offsetWidth/Height.  Overridden by inlines (RenderFlow)
226     // to return the remaining width on a given line (and the height of a single line).
227     LayoutUnit offsetWidth() const override { return width(); }
228     LayoutUnit offsetHeight() const override { return height(); }
229 
230     // More IE extensions.  clientWidth and clientHeight represent the interior of an object
231     // excluding border and scrollbar.  clientLeft/Top are just the borderLeftWidth and borderTopWidth.
232     LayoutUnit clientLeft() const { return borderLeft(); }
233     LayoutUnit clientTop() const { return borderTop(); }
234     WEBCORE_EXPORT LayoutUnit clientWidth() const;
235     WEBCORE_EXPORT LayoutUnit clientHeight() const;
236     LayoutUnit clientLogicalWidth() const { return style().isHorizontalWritingMode() ? clientWidth() : clientHeight(); }
237     LayoutUnit clientLogicalHeight() const { return style().isHorizontalWritingMode() ? clientHeight() : clientWidth(); }
238     LayoutUnit clientLogicalBottom() const { return borderBefore() + clientLogicalHeight(); }
239     LayoutRect clientBoxRect() const { return LayoutRect(clientLeft(), clientTop(), clientWidth(), clientHeight()); }
240 
241     // scrollWidth/scrollHeight will be the same as clientWidth/clientHeight unless the
242     // object has overflow:hidden/scroll/auto specified and also has overflow.
243     // scrollLeft/Top return the current scroll position.  These methods are virtual so that objects like
244     // textareas can scroll shadow content (but pretend that they are the objects that are
245     // scrolling).
246     virtual int scrollLeft() const;
247     virtual int scrollTop() const;
248     virtual int scrollWidth() const;
249     virtual int scrollHeight() const;
250     virtual void setScrollLeft(int, ScrollClamping = ScrollClamping::Clamped);
251     virtual void setScrollTop(int, ScrollClamping = ScrollClamping::Clamped);
252 
253     LayoutUnit marginTop() const override { return m_marginBox.top(); }
254     LayoutUnit marginBottom() const override { return m_marginBox.bottom(); }
255     LayoutUnit marginLeft() const override { return m_marginBox.left(); }
256     LayoutUnit marginRight() const override { return m_marginBox.right(); }
257     void setMarginTop(LayoutUnit margin) { m_marginBox.setTop(margin); }
258     void setMarginBottom(LayoutUnit margin) { m_marginBox.setBottom(margin); }
259     void setMarginLeft(LayoutUnit margin) { m_marginBox.setLeft(margin); }
260     void setMarginRight(LayoutUnit margin) { m_marginBox.setRight(margin); }
261 
262     LayoutUnit marginLogicalLeft() const { return m_marginBox.start(style().writingMode()); }
263     LayoutUnit marginLogicalRight() const { return m_marginBox.end(style().writingMode()); }
264 
265     LayoutUnit marginBefore(const RenderStyle* overrideStyle = nullptr) const final { return m_marginBox.before((overrideStyle ? overrideStyle : &amp;style())-&gt;writingMode()); }
266     LayoutUnit marginAfter(const RenderStyle* overrideStyle = nullptr) const final { return m_marginBox.after((overrideStyle ? overrideStyle : &amp;style())-&gt;writingMode()); }
267     LayoutUnit marginStart(const RenderStyle* overrideStyle = nullptr) const final
268     {
269         const RenderStyle* styleToUse = overrideStyle ? overrideStyle : &amp;style();
270         return m_marginBox.start(styleToUse-&gt;writingMode(), styleToUse-&gt;direction());
271     }
272     LayoutUnit marginEnd(const RenderStyle* overrideStyle = nullptr) const final
273     {
274         const RenderStyle* styleToUse = overrideStyle ? overrideStyle : &amp;style();
275         return m_marginBox.end(styleToUse-&gt;writingMode(), styleToUse-&gt;direction());
276     }
277     void setMarginBefore(LayoutUnit value, const RenderStyle* overrideStyle = nullptr) { m_marginBox.setBefore(value, (overrideStyle ? overrideStyle : &amp;style())-&gt;writingMode()); }
278     void setMarginAfter(LayoutUnit value, const RenderStyle* overrideStyle = nullptr) { m_marginBox.setAfter(value, (overrideStyle ? overrideStyle : &amp;style())-&gt;writingMode()); }
279     void setMarginStart(LayoutUnit value, const RenderStyle* overrideStyle = nullptr)
280     {
281         const RenderStyle* styleToUse = overrideStyle ? overrideStyle : &amp;style();
282         m_marginBox.setStart(value, styleToUse-&gt;writingMode(), styleToUse-&gt;direction());
283     }
284     void setMarginEnd(LayoutUnit value, const RenderStyle* overrideStyle = nullptr)
285     {
286         const RenderStyle* styleToUse = overrideStyle ? overrideStyle : &amp;style();
287         m_marginBox.setEnd(value, styleToUse-&gt;writingMode(), styleToUse-&gt;direction());
288     }
289 
290     virtual bool isSelfCollapsingBlock() const { return false; }
291     virtual LayoutUnit collapsedMarginBefore() const { return marginBefore(); }
292     virtual LayoutUnit collapsedMarginAfter() const { return marginAfter(); }
293 
294     void absoluteRects(Vector&lt;IntRect&gt;&amp;, const LayoutPoint&amp; accumulatedOffset) const override;
295     void absoluteQuads(Vector&lt;FloatQuad&gt;&amp;, bool* wasFixed) const override;
296 
297     int reflectionOffset() const;
298     // Given a rect in the object&#39;s coordinate space, returns the corresponding rect in the reflection.
299     LayoutRect reflectedRect(const LayoutRect&amp;) const;
300 
301     void layout() override;
302     bool nodeAtPoint(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction) override;
303 
304     LayoutUnit minPreferredLogicalWidth() const override;
305     LayoutUnit maxPreferredLogicalWidth() const override;
306 
307     // FIXME: We should rename these back to overrideLogicalHeight/Width and have them store
308     // the border-box height/width like the regular height/width accessors on RenderBox.
309     // Right now, these are different than contentHeight/contentWidth because they still
310     // include the scrollbar height/width.
311     LayoutUnit overrideContentLogicalWidth() const;
312     LayoutUnit overrideContentLogicalHeight() const;
313     bool hasOverrideContentLogicalHeight() const;
314     bool hasOverrideContentLogicalWidth() const;
315     void setOverrideContentLogicalHeight(LayoutUnit);
316     void setOverrideContentLogicalWidth(LayoutUnit);
317     void clearOverrideContentSize();
318     void clearOverrideContentLogicalHeight();
319     void clearOverrideContentLogicalWidth();
320 
321     Optional&lt;LayoutUnit&gt; overrideContainingBlockContentWidth() const override;
322     Optional&lt;LayoutUnit&gt; overrideContainingBlockContentHeight() const override;
323     bool hasOverrideContainingBlockContentWidth() const override;
324     bool hasOverrideContainingBlockContentHeight() const override;
325     Optional&lt;LayoutUnit&gt; overrideContainingBlockContentLogicalWidth() const;
326     Optional&lt;LayoutUnit&gt; overrideContainingBlockContentLogicalHeight() const;
327     bool hasOverrideContainingBlockContentLogicalWidth() const;
328     bool hasOverrideContainingBlockContentLogicalHeight() const;
329     void setOverrideContainingBlockContentLogicalWidth(Optional&lt;LayoutUnit&gt;);
330     void setOverrideContainingBlockContentLogicalHeight(Optional&lt;LayoutUnit&gt;);
331     void clearOverrideContainingBlockContentSize();
332     void clearOverrideContainingBlockContentLogicalHeight();
333 
334     LayoutSize offsetFromContainer(RenderElement&amp;, const LayoutPoint&amp;, bool* offsetDependsOnPoint = nullptr) const override;
335 
336     LayoutUnit adjustBorderBoxLogicalWidthForBoxSizing(LayoutUnit width) const;
337     LayoutUnit adjustContentBoxLogicalWidthForBoxSizing(LayoutUnit width) const;
338 
339     // Overridden by fieldsets to subtract out the intrinsic border.
340     virtual LayoutUnit adjustBorderBoxLogicalHeightForBoxSizing(LayoutUnit height) const;
341     virtual LayoutUnit adjustContentBoxLogicalHeightForBoxSizing(Optional&lt;LayoutUnit&gt; height) const;
342 
343     struct ComputedMarginValues {
344         LayoutUnit m_before;
345         LayoutUnit m_after;
346         LayoutUnit m_start;
347         LayoutUnit m_end;
348     };
349     struct LogicalExtentComputedValues {
350         LayoutUnit m_extent;
351         LayoutUnit m_position;
352         ComputedMarginValues m_margins;
353     };
354     // Resolve auto margins in the inline direction of the containing block so that objects can be pushed to the start, middle or end
355     // of the containing block.
356     void computeInlineDirectionMargins(const RenderBlock&amp; containingBlock, LayoutUnit containerWidth, LayoutUnit childWidth, LayoutUnit&amp; marginStart, LayoutUnit&amp; marginEnd) const;
357 
358     // Used to resolve margins in the containing block&#39;s block-flow direction.
359     void computeBlockDirectionMargins(const RenderBlock&amp; containingBlock, LayoutUnit&amp; marginBefore, LayoutUnit&amp; marginAfter) const;
360     void computeAndSetBlockDirectionMargins(const RenderBlock&amp; containingBlock);
361 
362     enum RenderBoxFragmentInfoFlags { CacheRenderBoxFragmentInfo, DoNotCacheRenderBoxFragmentInfo };
363     LayoutRect borderBoxRectInFragment(RenderFragmentContainer*, RenderBoxFragmentInfoFlags = CacheRenderBoxFragmentInfo) const;
364     LayoutRect clientBoxRectInFragment(RenderFragmentContainer*) const;
365     RenderFragmentContainer* clampToStartAndEndFragments(RenderFragmentContainer*) const;
366     bool hasFragmentRangeInFragmentedFlow() const;
367     virtual LayoutUnit offsetFromLogicalTopOfFirstPage() const;
368 
369     void positionLineBox(InlineElementBox&amp;);
370 
371     virtual std::unique_ptr&lt;InlineElementBox&gt; createInlineBox();
372     void dirtyLineBoxes(bool fullLayout);
373 
374     // For inline replaced elements, this function returns the inline box that owns us.  Enables
375     // the replaced RenderObject to quickly determine what line it is contained on and to easily
376     // iterate over structures on the line.
377     InlineElementBox* inlineBoxWrapper() const { return m_inlineBoxWrapper; }
378     void setInlineBoxWrapper(InlineElementBox*);
379     void deleteLineBoxWrapper();
380 
381     LayoutRect clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const override;
382     Optional&lt;LayoutRect&gt; computeVisibleRectInContainer(const LayoutRect&amp;, const RenderLayerModelObject* container, VisibleRectContext) const
383 override;
384     void repaintDuringLayoutIfMoved(const LayoutRect&amp;);
385     virtual void repaintOverhangingFloats(bool paintAllDescendants);
386 
387     LayoutUnit containingBlockLogicalWidthForContent() const override;
388     LayoutUnit containingBlockLogicalHeightForContent(AvailableLogicalHeightType) const;
389     LayoutUnit containingBlockLogicalWidthForPositioned(const RenderBoxModelObject&amp; containingBlock, RenderFragmentContainer* = nullptr, bool checkForPerpendicularWritingMode = true) const;
390     LayoutUnit containingBlockLogicalHeightForPositioned(const RenderBoxModelObject&amp; containingBlock, bool checkForPerpendicularWritingMode = true) const;
391     LayoutUnit containingBlockLogicalWidthForContentInFragment(RenderFragmentContainer*) const;
392     LayoutUnit containingBlockAvailableLineWidthInFragment(RenderFragmentContainer*) const;
393     LayoutUnit perpendicularContainingBlockLogicalHeight() const;
394 
395     virtual void updateLogicalWidth();
396     virtual void updateLogicalHeight();
397     virtual LogicalExtentComputedValues computeLogicalHeight(LayoutUnit logicalHeight, LayoutUnit logicalTop) const;
398 
399     void cacheIntrinsicContentLogicalHeightForFlexItem(LayoutUnit) const;
400 
401     // This function will compute the logical border-box height, without laying
402     // out the box. This means that the result is only &quot;correct&quot; when the height
403     // is explicitly specified. This function exists so that intrinsic width
404     // calculations have a way to deal with children that have orthogonal writing modes.
405     // When there is no explicit height, this function assumes a content height of
406     // zero (and returns just border + padding).
407     LayoutUnit computeLogicalHeightWithoutLayout() const;
408 
409     RenderBoxFragmentInfo* renderBoxFragmentInfo(RenderFragmentContainer*, RenderBoxFragmentInfoFlags = CacheRenderBoxFragmentInfo) const;
410     void computeLogicalWidthInFragment(LogicalExtentComputedValues&amp;, RenderFragmentContainer* = nullptr) const;
411 
412     bool stretchesToViewport() const
413     {
414         return document().inQuirksMode() &amp;&amp; style().logicalHeight().isAuto() &amp;&amp; !isFloatingOrOutOfFlowPositioned() &amp;&amp; (isDocumentElementRenderer() || isBody()) &amp;&amp; !isInline();
415     }
416 
417     virtual LayoutSize intrinsicSize() const { return LayoutSize(); }
418     LayoutUnit intrinsicLogicalWidth() const { return style().isHorizontalWritingMode() ? intrinsicSize().width() : intrinsicSize().height(); }
419     LayoutUnit intrinsicLogicalHeight() const { return style().isHorizontalWritingMode() ? intrinsicSize().height() : intrinsicSize().width(); }
420 
421     // Whether or not the element shrinks to its intrinsic width (rather than filling the width
422     // of a containing block).  HTML4 buttons, &lt;select&gt;s, &lt;input&gt;s, legends, and floating/compact elements do this.
423     bool sizesLogicalWidthToFitContent(SizeType) const;
424 
425     bool hasStretchedLogicalWidth() const;
426     bool isStretchingColumnFlexItem() const;
427     bool columnFlexItemHasStretchAlignment() const;
428 
429     LayoutUnit shrinkLogicalWidthToAvoidFloats(LayoutUnit childMarginStart, LayoutUnit childMarginEnd, const RenderBlock&amp; cb, RenderFragmentContainer*) const;
430 
431     LayoutUnit computeLogicalWidthInFragmentUsing(SizeType, Length logicalWidth, LayoutUnit availableLogicalWidth, const RenderBlock&amp; containingBlock, RenderFragmentContainer*) const;
432     Optional&lt;LayoutUnit&gt; computeLogicalHeightUsing(SizeType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const;
433     Optional&lt;LayoutUnit&gt; computeContentLogicalHeight(SizeType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const;
434     Optional&lt;LayoutUnit&gt; computeContentAndScrollbarLogicalHeightUsing(SizeType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const;
435     LayoutUnit computeReplacedLogicalWidthUsing(SizeType, Length width) const;
436     LayoutUnit computeReplacedLogicalWidthRespectingMinMaxWidth(LayoutUnit logicalWidth, ShouldComputePreferred  = ComputeActual) const;
437     LayoutUnit computeReplacedLogicalHeightUsing(SizeType, Length height) const;
438     LayoutUnit computeReplacedLogicalHeightRespectingMinMaxHeight(LayoutUnit logicalHeight) const;
439 
440     virtual LayoutUnit computeReplacedLogicalWidth(ShouldComputePreferred  = ComputeActual) const;
441     virtual LayoutUnit computeReplacedLogicalHeight(Optional&lt;LayoutUnit&gt; estimatedUsedWidth = WTF::nullopt) const;
442 
443     Optional&lt;LayoutUnit&gt; computePercentageLogicalHeight(const Length&amp; height) const;
444 
445     virtual LayoutUnit availableLogicalWidth() const { return contentLogicalWidth(); }
446     virtual LayoutUnit availableLogicalHeight(AvailableLogicalHeightType) const;
447     LayoutUnit availableLogicalHeightUsing(const Length&amp;, AvailableLogicalHeightType) const;
448 
449     // There are a few cases where we need to refer specifically to the available physical width and available physical height.
450     // Relative positioning is one of those cases, since left/top offsets are physical.
451     LayoutUnit availableWidth() const { return style().isHorizontalWritingMode() ? availableLogicalWidth() : availableLogicalHeight(IncludeMarginBorderPadding); }
452     LayoutUnit availableHeight() const { return style().isHorizontalWritingMode() ? availableLogicalHeight(IncludeMarginBorderPadding) : availableLogicalWidth(); }
453 
454     WEBCORE_EXPORT virtual int verticalScrollbarWidth() const;
455     WEBCORE_EXPORT int horizontalScrollbarHeight() const;
456     int intrinsicScrollbarLogicalWidth() const;
457     int scrollbarLogicalWidth() const { return style().isHorizontalWritingMode() ? verticalScrollbarWidth() : horizontalScrollbarHeight(); }
458     int scrollbarLogicalHeight() const { return style().isHorizontalWritingMode() ? horizontalScrollbarHeight() : verticalScrollbarWidth(); }
459     virtual bool scroll(ScrollDirection, ScrollGranularity, float multiplier = 1, Element** stopElement = nullptr, RenderBox* startBox = nullptr, const IntPoint&amp; wheelEventAbsolutePoint = IntPoint());
460     virtual bool logicalScroll(ScrollLogicalDirection, ScrollGranularity, float multiplier = 1, Element** stopElement = nullptr);
461     WEBCORE_EXPORT bool canBeScrolledAndHasScrollableArea() const;
462     virtual bool canBeProgramaticallyScrolled() const;
463     virtual void autoscroll(const IntPoint&amp;);
464     bool canAutoscroll() const;
465     IntSize calculateAutoscrollDirection(const IntPoint&amp; windowPoint) const;
466     static RenderBox* findAutoscrollable(RenderObject*);
467     virtual void stopAutoscroll() { }
468     virtual void panScroll(const IntPoint&amp;);
469 
470     bool hasVerticalScrollbarWithAutoBehavior() const;
471     bool hasHorizontalScrollbarWithAutoBehavior() const;
472 
473     bool canUseOverlayScrollbars() const;
474 
475     bool scrollsOverflow() const { return scrollsOverflowX() || scrollsOverflowY(); }
476     bool scrollsOverflowX() const { return hasOverflowClip() &amp;&amp; (style().overflowX() == Overflow::Scroll || style().overflowX() == Overflow::Auto); }
477     bool scrollsOverflowY() const { return hasOverflowClip() &amp;&amp; (style().overflowY() == Overflow::Scroll || style().overflowY() == Overflow::Auto); }
478 
479     bool hasHorizontalOverflow() const { return scrollWidth() != roundToInt(paddingBoxWidth()); }
480     bool hasVerticalOverflow() const { return scrollHeight() != roundToInt(paddingBoxHeight()); }
481 
482     bool hasScrollableOverflowX() const { return scrollsOverflowX() &amp;&amp; hasHorizontalOverflow(); }
483     bool hasScrollableOverflowY() const { return scrollsOverflowY() &amp;&amp; hasVerticalOverflow(); }
484 
485     bool usesCompositedScrolling() const;
486 
487     bool percentageLogicalHeightIsResolvable() const;
488     bool hasUnsplittableScrollingOverflow() const;
489     bool isUnsplittableForPagination() const;
490 
491     bool shouldTreatChildAsReplacedInTableCells() const;
492 
493     LayoutRect localCaretRect(InlineBox*, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine = nullptr) override;
494 
495     virtual LayoutRect overflowClipRect(const LayoutPoint&amp; location, RenderFragmentContainer* = nullptr, OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize, PaintPhase = PaintPhase::BlockBackground);
496     virtual LayoutRect overflowClipRectForChildLayers(const LayoutPoint&amp; location, RenderFragmentContainer* fragment, OverlayScrollbarSizeRelevancy relevancy) { return overflowClipRect(location, fragment, relevancy); }
497     LayoutRect clipRect(const LayoutPoint&amp; location, RenderFragmentContainer*);
498     virtual bool hasControlClip() const { return false; }
499     virtual LayoutRect controlClipRect(const LayoutPoint&amp;) const { return LayoutRect(); }
500     bool pushContentsClip(PaintInfo&amp;, const LayoutPoint&amp; accumulatedOffset);
501     void popContentsClip(PaintInfo&amp;, PaintPhase originalPhase, const LayoutPoint&amp; accumulatedOffset);
502 
503     virtual void paintObject(PaintInfo&amp;, const LayoutPoint&amp;) { ASSERT_NOT_REACHED(); }
504     virtual void paintBoxDecorations(PaintInfo&amp;, const LayoutPoint&amp;);
505     virtual void paintMask(PaintInfo&amp;, const LayoutPoint&amp;);
506     virtual void paintClippingMask(PaintInfo&amp;, const LayoutPoint&amp;);
507     void imageChanged(WrappedImagePtr, const IntRect* = nullptr) override;
508 
509     // Called when a positioned object moves but doesn&#39;t necessarily change size.  A simplified layout is attempted
510     // that just updates the object&#39;s position. If the size does change, the object remains dirty.
511     bool tryLayoutDoingPositionedMovementOnly()
512     {
513         LayoutUnit oldWidth = width();
514         updateLogicalWidth();
515         // If we shrink to fit our width may have changed, so we still need full layout.
516         if (oldWidth != width())
517             return false;
518         updateLogicalHeight();
519         return true;
520     }
521 
522     LayoutRect maskClipRect(const LayoutPoint&amp; paintOffset);
523 
524     VisiblePosition positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*) override;
525 
526     void removeFloatingOrPositionedChildFromBlockLists();
527 
528     RenderLayer* enclosingFloatPaintingLayer() const;
529 
530     virtual Optional&lt;int&gt; firstLineBaseline() const { return Optional&lt;int&gt;(); }
531     virtual Optional&lt;int&gt; inlineBlockBaseline(LineDirectionMode) const { return Optional&lt;int&gt;(); } // Returns empty if we should skip this box when computing the baseline of an inline-block.
532 
533     bool shrinkToAvoidFloats() const;
534     virtual bool avoidsFloats() const;
535 
536     virtual void markForPaginationRelayoutIfNeeded() { }
537 
538     bool isWritingModeRoot() const { return !parent() || parent()-&gt;style().writingMode() != style().writingMode(); }
539 
540     bool isDeprecatedFlexItem() const { return !isInline() &amp;&amp; !isFloatingOrOutOfFlowPositioned() &amp;&amp; parent() &amp;&amp; parent()-&gt;isDeprecatedFlexibleBox(); }
541     bool isFlexItemIncludingDeprecated() const { return !isInline() &amp;&amp; !isFloatingOrOutOfFlowPositioned() &amp;&amp; parent() &amp;&amp; parent()-&gt;isFlexibleBoxIncludingDeprecated(); }
542 
543     LayoutUnit lineHeight(bool firstLine, LineDirectionMode, LinePositionMode = PositionOnContainingLine) const override;
544     int baselinePosition(FontBaseline, bool firstLine, LineDirectionMode, LinePositionMode = PositionOnContainingLine) const override;
545 
546     LayoutUnit offsetLeft() const override;
547     LayoutUnit offsetTop() const override;
548 
549     LayoutPoint flipForWritingModeForChild(const RenderBox* child, const LayoutPoint&amp;) const;
550     LayoutUnit flipForWritingMode(LayoutUnit position) const; // The offset is in the block direction (y for horizontal writing modes, x for vertical writing modes).
551     LayoutPoint flipForWritingMode(const LayoutPoint&amp;) const;
552     LayoutSize flipForWritingMode(const LayoutSize&amp;) const;
553     void flipForWritingMode(LayoutRect&amp;) const;
554     FloatPoint flipForWritingMode(const FloatPoint&amp;) const;
555     void flipForWritingMode(FloatRect&amp;) const;
556     // These represent your location relative to your container as a physical offset.
557     // In layout related methods you almost always want the logical location (e.g. x() and y()).
558     LayoutPoint topLeftLocation() const;
559     LayoutSize topLeftLocationOffset() const;
560     void applyTopLeftLocationOffset(LayoutPoint&amp; point) const
561     {
562         // This is inlined for speed, since it is used by updateLayerPosition() during scrolling.
563         if (!document().view()-&gt;hasFlippedBlockRenderers())
564             point.move(m_frameRect.x(), m_frameRect.y());
565         else
566             applyTopLeftLocationOffsetWithFlipping(point);
567     }
568 
569     LayoutRect logicalVisualOverflowRectForPropagation(const RenderStyle*) const;
570     LayoutRect visualOverflowRectForPropagation(const RenderStyle*) const;
571     LayoutRect logicalLayoutOverflowRectForPropagation(const RenderStyle*) const;
572     LayoutRect layoutOverflowRectForPropagation(const RenderStyle*) const;
573 
574     bool hasRenderOverflow() const { return m_overflow; }
575     bool hasVisualOverflow() const { return m_overflow &amp;&amp; !borderBoxRect().contains(m_overflow-&gt;visualOverflowRect()); }
576 
577     virtual bool needsPreferredWidthsRecalculation() const;
578     virtual void computeIntrinsicRatioInformation(FloatSize&amp; /* intrinsicSize */, double&amp; /* intrinsicRatio */) const { }
579 
580     ScrollPosition scrollPosition() const;
581     LayoutSize cachedSizeForOverflowClip() const;
582 
583     // Returns false if the rect has no intersection with the applied clip rect. When the context specifies edge-inclusive
584     // intersection, this return value allows distinguishing between no intersection and zero-area intersection.
585     bool applyCachedClipAndScrollPosition(LayoutRect&amp;, const RenderLayerModelObject* container, VisibleRectContext) const;
586 
587     virtual bool hasRelativeDimensions() const;
588     virtual bool hasRelativeLogicalHeight() const;
589     virtual bool hasRelativeLogicalWidth() const;
590 
591     bool hasHorizontalLayoutOverflow() const
592     {
593         if (!m_overflow)
594             return false;
595 
596         LayoutRect layoutOverflowRect = m_overflow-&gt;layoutOverflowRect();
597         flipForWritingMode(layoutOverflowRect);
598         return layoutOverflowRect.x() &lt; x() || layoutOverflowRect.maxX() &gt; x() + logicalWidth();
599     }
600 
601     bool hasVerticalLayoutOverflow() const
602     {
603         if (!m_overflow)
604             return false;
605 
606         LayoutRect layoutOverflowRect = m_overflow-&gt;layoutOverflowRect();
607         flipForWritingMode(layoutOverflowRect);
608         return layoutOverflowRect.y() &lt; y() || layoutOverflowRect.maxY() &gt; y() + logicalHeight();
609     }
610 
611     virtual RenderPtr&lt;RenderBox&gt; createAnonymousBoxWithSameTypeAs(const RenderBox&amp;) const
612     {
613         ASSERT_NOT_REACHED();
614         return nullptr;
615     }
616 
617     ShapeOutsideInfo* shapeOutsideInfo() const
618     {
619         return ShapeOutsideInfo::isEnabledFor(*this) ? ShapeOutsideInfo::info(*this) : nullptr;
620     }
621 
622     void markShapeOutsideDependentsForLayout()
623     {
624         if (isFloating())
625             removeFloatingOrPositionedChildFromBlockLists();
626     }
627 
628     // True if this box can have a range in an outside fragmentation context.
629     bool canHaveOutsideFragmentRange() const { return !isInFlowRenderFragmentedFlow(); }
630     virtual bool needsLayoutAfterFragmentRangeChange() const { return false; }
631 
632     const RenderBox* findEnclosingScrollableContainer() const;
633 
634     bool isGridItem() const { return parent() &amp;&amp; parent()-&gt;isRenderGrid() &amp;&amp; !isExcludedFromNormalLayout(); }
635     bool isFlexItem() const { return parent() &amp;&amp; parent()-&gt;isFlexibleBox() &amp;&amp; !isExcludedFromNormalLayout(); }
636 
637     virtual void adjustBorderBoxRectForPainting(LayoutRect&amp;) { };
638 
639 protected:
640     RenderBox(Element&amp;, RenderStyle&amp;&amp;, BaseTypeFlags);
641     RenderBox(Document&amp;, RenderStyle&amp;&amp;, BaseTypeFlags);
642 
643     void styleWillChange(StyleDifference, const RenderStyle&amp; newStyle) override;
644     void styleDidChange(StyleDifference, const RenderStyle* oldStyle) override;
645     void updateFromStyle() override;
646 
647     void willBeDestroyed() override;
648 
649     bool createsNewFormattingContext() const;
650 
651     virtual ItemPosition selfAlignmentNormalBehavior(const RenderBox* = nullptr) const { return ItemPosition::Stretch; }
652 
653     // Returns false if it could not cheaply compute the extent (e.g. fixed background), in which case the returned rect may be incorrect.
654     bool getBackgroundPaintedExtent(const LayoutPoint&amp; paintOffset, LayoutRect&amp;) const;
655     virtual bool foregroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect, unsigned maxDepthToTest) const;
656     bool computeBackgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset) override;
657 
658     void paintBackground(const PaintInfo&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance = BackgroundBleedNone);
659 
660     void paintFillLayer(const PaintInfo&amp;, const Color&amp;, const FillLayer&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance, CompositeOperator, RenderElement* backgroundObject, BaseBackgroundColorUsage = BaseBackgroundColorUse);
661     void paintFillLayers(const PaintInfo&amp;, const Color&amp;, const FillLayer&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance = BackgroundBleedNone, CompositeOperator = CompositeSourceOver, RenderElement* backgroundObject = nullptr);
662 
663     void paintMaskImages(const PaintInfo&amp;, const LayoutRect&amp;);
664 
665     BackgroundBleedAvoidance determineBackgroundBleedAvoidance(GraphicsContext&amp;) const;
666     bool backgroundHasOpaqueTopLayer() const;
667 
668     void computePositionedLogicalWidth(LogicalExtentComputedValues&amp;, RenderFragmentContainer* = nullptr) const;
669 
670     LayoutUnit computeIntrinsicLogicalWidthUsing(Length logicalWidthLength, LayoutUnit availableLogicalWidth, LayoutUnit borderAndPadding) const;
671     virtual Optional&lt;LayoutUnit&gt; computeIntrinsicLogicalContentHeightUsing(Length logicalHeightLength, Optional&lt;LayoutUnit&gt; intrinsicContentHeight, LayoutUnit borderAndPadding) const;
672 
673     virtual bool shouldComputeSizeAsReplaced() const { return isReplaced() &amp;&amp; !isInlineBlockOrInlineTable(); }
674 
675     void mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp;, MapCoordinatesFlags, bool* wasFixed) const override;
676     const RenderObject* pushMappingToContainer(const RenderLayerModelObject*, RenderGeometryMap&amp;) const override;
677     void mapAbsoluteToLocalPoint(MapCoordinatesFlags, TransformState&amp;) const override;
678 
679     void paintRootBoxFillLayers(const PaintInfo&amp;);
680 
681     bool skipContainingBlockForPercentHeightCalculation(const RenderBox&amp; containingBlock, bool isPerpendicularWritingMode) const;
682 
683 private:
684     bool replacedMinMaxLogicalHeightComputesAsNone(SizeType) const;
685 
686     void updateShapeOutsideInfoAfterStyleChange(const RenderStyle&amp;, const RenderStyle* oldStyle);
687 
688     void updateGridPositionAfterStyleChange(const RenderStyle&amp;, const RenderStyle* oldStyle);
689 
690     bool scrollLayer(ScrollDirection, ScrollGranularity, float multiplier, Element** stopElement);
691 
692     bool fixedElementLaysOutRelativeToFrame(const FrameView&amp;) const;
693 
694     bool includeVerticalScrollbarSize() const;
695     bool includeHorizontalScrollbarSize() const;
696 
697     bool isScrollableOrRubberbandableBox() const override;
698 
699     // Returns true if we did a full repaint.
700     bool repaintLayerRectsForImage(WrappedImagePtr, const FillLayer&amp; layers, bool drawingBackground);
701 
702     void computePositionedLogicalHeight(LogicalExtentComputedValues&amp;) const;
703     void computePositionedLogicalWidthUsing(SizeType, Length logicalWidth, const RenderBoxModelObject&amp; containerBlock, TextDirection containerDirection,
704                                             LayoutUnit containerLogicalWidth, LayoutUnit bordersPlusPadding,
705                                             Length logicalLeft, Length logicalRight, Length marginLogicalLeft, Length marginLogicalRight,
706                                             LogicalExtentComputedValues&amp;) const;
707     void computePositionedLogicalHeightUsing(SizeType, Length logicalHeightLength, const RenderBoxModelObject&amp; containerBlock,
708                                              LayoutUnit containerLogicalHeight, LayoutUnit bordersPlusPadding, LayoutUnit logicalHeight,
709                                              Length logicalTop, Length logicalBottom, Length marginLogicalTop, Length marginLogicalBottom,
710                                              LogicalExtentComputedValues&amp;) const;
711 
712     void computePositionedLogicalHeightReplaced(LogicalExtentComputedValues&amp;) const;
713     void computePositionedLogicalWidthReplaced(LogicalExtentComputedValues&amp;) const;
714 
715     LayoutUnit fillAvailableMeasure(LayoutUnit availableLogicalWidth) const;
716     LayoutUnit fillAvailableMeasure(LayoutUnit availableLogicalWidth, LayoutUnit&amp; marginStart, LayoutUnit&amp; marginEnd) const;
717 
718     virtual void computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;
719 
720     // This function calculates the minimum and maximum preferred widths for an object.
721     // These values are used in shrink-to-fit layout systems.
722     // These include tables, positioned objects, floats and flexible boxes.
723     virtual void computePreferredLogicalWidths() { setPreferredLogicalWidthsDirty(false); }
724 
725     LayoutRect frameRectForStickyPositioning() const final { return frameRect(); }
726 
727     LayoutRect computeVisibleRectUsingPaintOffset(const LayoutRect&amp;) const;
728 
729     void applyTopLeftLocationOffsetWithFlipping(LayoutPoint&amp;) const;
730 
731 private:
732     // The width/height of the contents + borders + padding.  The x/y location is relative to our container (which is not always our parent).
733     LayoutRect m_frameRect;
734 
735 protected:
736     LayoutBoxExtent m_marginBox;
737 
738     // The preferred logical width of the element if it were to break its lines at every possible opportunity.
739     LayoutUnit m_minPreferredLogicalWidth;
740 
741     // The preferred logical width of the element if it never breaks any lines at all.
742     LayoutUnit m_maxPreferredLogicalWidth;
743 
744     // For inline replaced elements, the inline box that owns us.
745     InlineElementBox* m_inlineBoxWrapper { nullptr };
746 
747     // Our overflow information.
748     RefPtr&lt;RenderOverflow&gt; m_overflow;
749 
750 private:
751     // Used to store state between styleWillChange and styleDidChange
752     static bool s_hadOverflowClip;
753 };
754 
755 inline RenderBox* RenderBox::parentBox() const
756 {
757     if (is&lt;RenderBox&gt;(parent()))
758         return downcast&lt;RenderBox&gt;(parent());
759 
760     ASSERT(!parent());
761     return nullptr;
762 }
763 
764 inline RenderBox* RenderBox::firstChildBox() const
765 {
766     if (is&lt;RenderBox&gt;(firstChild()))
767         return downcast&lt;RenderBox&gt;(firstChild());
768 
769     ASSERT(!firstChild());
770     return nullptr;
771 }
772 
773 inline RenderBox* RenderBox::lastChildBox() const
774 {
775     if (is&lt;RenderBox&gt;(lastChild()))
776         return downcast&lt;RenderBox&gt;(lastChild());
777 
778     ASSERT(!lastChild());
779     return nullptr;
780 }
781 
782 inline RenderBox* RenderBox::previousSiblingBox() const
783 {
784     if (is&lt;RenderBox&gt;(previousSibling()))
785         return downcast&lt;RenderBox&gt;(previousSibling());
786 
787     ASSERT(!previousSibling());
788     return nullptr;
789 }
790 
791 inline RenderBox* RenderBox::nextSiblingBox() const
792 {
793     if (is&lt;RenderBox&gt;(nextSibling()))
794         return downcast&lt;RenderBox&gt;(nextSibling());
795 
796     ASSERT(!nextSibling());
797     return nullptr;
798 }
799 
800 inline void RenderBox::setInlineBoxWrapper(InlineElementBox* boxWrapper)
801 {
802     if (boxWrapper) {
803         ASSERT(!m_inlineBoxWrapper);
804         // m_inlineBoxWrapper should already be 0. Deleting it is a safeguard against security issues.
805         // Otherwise, there will two line box wrappers keeping the reference to this renderer, and
806         // only one will be notified when the renderer is getting destroyed. The second line box wrapper
807         // will keep a stale reference.
808         if (UNLIKELY(m_inlineBoxWrapper != nullptr))
809             deleteLineBoxWrapper();
810     }
811 
812     m_inlineBoxWrapper = boxWrapper;
813 }
814 
815 } // namespace WebCore
816 
817 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderBox, isBox())
    </pre>
  </body>
</html>