<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008, 2009, 2011 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Nuanti Ltd.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #pragma once
  31 
  32 #include &quot;AccessibilityObjectInterface.h&quot;
  33 #include &quot;FloatQuad.h&quot;
  34 #include &quot;HTMLTextFormControlElement.h&quot;
  35 #include &quot;LayoutRect.h&quot;
  36 #include &quot;Path.h&quot;
  37 #include &quot;Range.h&quot;
  38 #include &quot;TextIteratorBehavior.h&quot;
  39 #include &quot;VisiblePosition.h&quot;
  40 #include &quot;VisibleSelection.h&quot;
  41 #include &lt;wtf/Forward.h&gt;
  42 #include &lt;wtf/Function.h&gt;
  43 #include &lt;wtf/RefPtr.h&gt;
  44 #include &lt;wtf/Vector.h&gt;
  45 
  46 #if PLATFORM(COCOA)
  47 #include &lt;wtf/RetainPtr.h&gt;
  48 #endif
  49 
  50 #if USE(ATK)
  51 #include &lt;wtf/glib/GRefPtr.h&gt;
  52 #endif
  53 
  54 #if PLATFORM(COCOA)
  55 
  56 typedef struct _NSRange NSRange;
  57 
  58 OBJC_CLASS NSArray;
  59 OBJC_CLASS NSAttributedString;
  60 OBJC_CLASS NSData;
  61 OBJC_CLASS NSMutableAttributedString;
  62 OBJC_CLASS NSString;
  63 OBJC_CLASS NSValue;
  64 OBJC_CLASS NSView;
  65 
  66 #endif
  67 
  68 namespace WebCore {
  69 
  70 class AccessibilityObject;
  71 class AccessibilityScrollView;
  72 class AXObjectCache;
  73 class Element;
  74 class Frame;
  75 class FrameView;
  76 class IntPoint;
  77 class IntSize;
  78 class Node;
  79 class Page;
  80 class RenderObject;
  81 class ScrollableArea;
  82 class ScrollView;
  83 class Widget;
  84 struct ScrollRectToVisibleOptions;
  85 
  86 enum class AccessibilityTextSource {
  87     Alternative,
  88     Children,
  89     Summary,
  90     Help,
  91     Visible,
  92     TitleTag,
  93     Placeholder,
  94     LabelByElement,
  95     Title,
  96     Subtitle,
  97     Action,
  98 };
  99 
 100 struct AccessibilityText {
 101     String text;
 102     AccessibilityTextSource textSource;
 103     Vector&lt;RefPtr&lt;AccessibilityObject&gt;&gt; textElements;
 104 
 105     AccessibilityText(const String&amp; t, const AccessibilityTextSource&amp; s)
 106         : text(t)
 107         , textSource(s)
 108     { }
 109 
 110     AccessibilityText(const String&amp; t, const AccessibilityTextSource&amp; s, Vector&lt;RefPtr&lt;AccessibilityObject&gt;&gt; elements)
 111         : text(t)
 112         , textSource(s)
 113         , textElements(WTFMove(elements))
 114     { }
 115 
 116     AccessibilityText(const String&amp; t, const AccessibilityTextSource&amp; s, RefPtr&lt;AccessibilityObject&gt;&amp;&amp; element)
 117         : text(t)
 118         , textSource(s)
 119     {
 120         textElements.append(WTFMove(element));
 121     }
 122 };
 123 
 124 struct AccessibilityTextUnderElementMode {
 125     enum ChildrenInclusion {
 126         TextUnderElementModeSkipIgnoredChildren,
 127         TextUnderElementModeIncludeAllChildren,
 128         TextUnderElementModeIncludeNameFromContentsChildren, // This corresponds to ARIA concept: nameFrom
 129     };
 130 
 131     ChildrenInclusion childrenInclusion;
 132     bool includeFocusableContent;
 133     Node* ignoredChildNode;
 134 
 135     AccessibilityTextUnderElementMode(ChildrenInclusion c = TextUnderElementModeSkipIgnoredChildren, bool i = false, Node* ignored = nullptr)
 136         : childrenInclusion(c)
 137         , includeFocusableContent(i)
 138         , ignoredChildNode(ignored)
 139     { }
 140 };
 141 
 142 // Use this struct to store the isIgnored data that depends on the parents, so that in addChildren()
 143 // we avoid going up the parent chain for each element while traversing the tree with useful information already.
 144 struct AccessibilityIsIgnoredFromParentData {
 145     AccessibilityObject* parent { nullptr };
 146     bool isAXHidden { false };
 147     bool isPresentationalChildOfAriaRole { false };
 148     bool isDescendantOfBarrenParent { false };
 149 
 150     AccessibilityIsIgnoredFromParentData(AccessibilityObject* parent = nullptr)
 151         : parent(parent)
 152     { }
 153 
 154     bool isNull() const { return !parent; }
 155 };
 156 
 157 enum class AccessibilityOrientation {
 158     Vertical,
 159     Horizontal,
 160     Undefined,
 161 };
 162 
 163 enum class AccessibilityObjectInclusion {
 164     IncludeObject,
 165     IgnoreObject,
 166     DefaultBehavior,
 167 };
 168 
 169 enum class AccessibilityButtonState {
 170     Off = 0,
 171     On,
 172     Mixed,
 173 };
 174 
 175 enum class AccessibilitySortDirection {
 176     None,
 177     Ascending,
 178     Descending,
 179     Other,
 180     Invalid,
 181 };
 182 
 183 enum class AccessibilitySearchDirection {
 184     Next = 1,
 185     Previous,
 186 };
 187 
 188 enum class AccessibilitySearchKey {
 189     AnyType = 1,
 190     Article,
 191     BlockquoteSameLevel,
 192     Blockquote,
 193     BoldFont,
 194     Button,
 195     CheckBox,
 196     Control,
 197     DifferentType,
 198     FontChange,
 199     FontColorChange,
 200     Frame,
 201     Graphic,
 202     HeadingLevel1,
 203     HeadingLevel2,
 204     HeadingLevel3,
 205     HeadingLevel4,
 206     HeadingLevel5,
 207     HeadingLevel6,
 208     HeadingSameLevel,
 209     Heading,
 210     Highlighted,
 211     ItalicFont,
 212     KeyboardFocusable,
 213     Landmark,
 214     Link,
 215     List,
 216     LiveRegion,
 217     MisspelledWord,
 218     Outline,
 219     PlainText,
 220     RadioGroup,
 221     SameType,
 222     StaticText,
 223     StyleChange,
 224     TableSameLevel,
 225     Table,
 226     TextField,
 227     Underline,
 228     UnvisitedLink,
 229     VisitedLink,
 230 };
 231 
 232 enum class AccessibilityVisiblePositionForBounds {
 233     First,
 234     Last,
 235 };
 236 
 237 struct AccessibilitySearchCriteria {
 238     AccessibilityObject* startObject;
 239     AccessibilitySearchDirection searchDirection;
 240     Vector&lt;AccessibilitySearchKey&gt; searchKeys;
 241     String searchText;
 242     unsigned resultsLimit;
 243     bool visibleOnly;
 244     bool immediateDescendantsOnly;
 245 
 246     AccessibilitySearchCriteria(AccessibilityObject* startObject, AccessibilitySearchDirection searchDirection, String searchText, unsigned resultsLimit, bool visibleOnly, bool immediateDescendantsOnly)
 247         : startObject(startObject)
 248         , searchDirection(searchDirection)
 249         , searchText(searchText)
 250         , resultsLimit(resultsLimit)
 251         , visibleOnly(visibleOnly)
 252         , immediateDescendantsOnly(immediateDescendantsOnly)
 253     { }
 254 };
 255 
 256 enum class AccessibilityDetachmentType { CacheDestroyed, ElementDestroyed };
 257 
 258 struct VisiblePositionRange {
 259 
 260     VisiblePosition start;
 261     VisiblePosition end;
 262 
 263     VisiblePositionRange() {}
 264 
 265     VisiblePositionRange(const VisiblePosition&amp; s, const VisiblePosition&amp; e)
 266         : start(s)
 267         , end(e)
 268     { }
 269 
 270     VisiblePositionRange(const VisibleSelection&amp; selection)
 271         : start(selection.start())
 272         , end(selection.end())
 273     { }
 274 
 275     bool isNull() const { return start.isNull() || end.isNull(); }
 276 };
 277 
 278 struct PlainTextRange {
 279 
 280     unsigned start { 0 };
 281     unsigned length { 0 };
 282 
 283     PlainTextRange() = default;
 284 
 285     PlainTextRange(unsigned s, unsigned l)
 286         : start(s)
 287         , length(l)
 288     { }
 289 
 290 #if PLATFORM(COCOA)
 291     PlainTextRange(NSRange);
 292 #endif
 293 
 294     bool isNull() const { return !start &amp;&amp; !length; }
 295 };
 296 
 297 enum class AccessibilitySearchTextStartFrom {
 298     Begin, // Search from the beginning of the element.
 299     Selection, // Search from the position of the current selection.
 300     End // Search from the end of the element.
 301 };
 302 
 303 enum class AccessibilitySearchTextDirection {
 304     Forward, // Occurrence after the starting range.
 305     Backward, // Occurrence before the starting range.
 306     Closest, // Closest occurrence to the starting range, whether after or before.
 307     All // All occurrences
 308 };
 309 
 310 struct AccessibilitySearchTextCriteria {
 311     Vector&lt;String&gt; searchStrings; // Text strings to search for.
 312     AccessibilitySearchTextStartFrom start;
 313     AccessibilitySearchTextDirection direction;
 314 
 315     AccessibilitySearchTextCriteria()
 316         : start(AccessibilitySearchTextStartFrom::Selection)
 317         , direction(AccessibilitySearchTextDirection::Forward)
 318     { }
 319 };
 320 
 321 enum class AccessibilityTextOperationType {
 322     Select,
 323     Replace,
 324     Capitalize,
 325     Lowercase,
 326     Uppercase
 327 };
 328 
 329 struct AccessibilityTextOperation {
 330     Vector&lt;RefPtr&lt;Range&gt;&gt; textRanges; // text on which perform the operation.
 331     AccessibilityTextOperationType type;
 332     String replacementText; // For type = replace.
 333 
 334     AccessibilityTextOperation()
 335         : type(AccessibilityTextOperationType::Select)
 336     { }
 337 };
 338 
 339 enum class AccessibilityMathScriptObjectType { Subscript, Superscript };
 340 enum class AccessibilityMathMultiscriptObjectType { PreSubscript, PreSuperscript, PostSubscript, PostSuperscript };
 341 
 342 enum class AccessibilityCurrentState { False, True, Page, Step, Location, Date, Time };
 343 enum class AccessibilityConversionSpace { Screen, Page };
 344 
 345 bool nodeHasPresentationRole(Node*);
 346 
 347 class AccessibilityObject : public RefCounted&lt;AccessibilityObject&gt;, public AccessibilityObjectInterface {
 348 protected:
 349     AccessibilityObject() = default;
 350 
 351 public:
 352     virtual ~AccessibilityObject();
 353 
 354     // After constructing an AccessibilityObject, it must be given a
 355     // unique ID, then added to AXObjectCache, and finally init() must
 356     // be called last.
 357     void setAXObjectID(AXID axObjectID) { m_id = axObjectID; }
 358     virtual void init() { }
 359 
 360     // When the corresponding WebCore object that this AccessibilityObject
 361     // wraps is deleted, it must be detached.
 362     virtual void detach(AccessibilityDetachmentType, AXObjectCache* cache = nullptr);
 363     virtual bool isDetached() const;
 364 
 365     typedef Vector&lt;RefPtr&lt;AccessibilityObject&gt;&gt; AccessibilityChildrenVector;
 366 
 367     virtual bool isAccessibilityNodeObject() const { return false; }
 368     virtual bool isAccessibilityRenderObject() const { return false; }
 369     virtual bool isAccessibilityScrollbar() const { return false; }
 370     virtual bool isAccessibilityScrollView() const { return false; }
 371     virtual bool isAccessibilitySVGRoot() const { return false; }
 372     virtual bool isAccessibilitySVGElement() const { return false; }
 373 
 374     bool accessibilityObjectContainsText(String *) const;
 375 
 376     virtual bool isAttachmentElement() const { return false; }
 377     virtual bool isHeading() const { return false; }
 378     bool isLink() const override { return false; }
 379     bool isImage() const override { return false; }
 380     virtual bool isImageMap() const { return roleValue() == AccessibilityRole::ImageMap; }
 381     virtual bool isNativeImage() const { return false; }
 382     virtual bool isImageButton() const { return false; }
 383     virtual bool isPasswordField() const { return false; }
 384     bool isContainedByPasswordField() const;
 385     virtual AccessibilityObject* passwordFieldOrContainingPasswordField() { return nullptr; }
 386     virtual bool isNativeTextControl() const { return false; }
 387     virtual bool isSearchField() const { return false; }
 388     bool isWebArea() const { return roleValue() == AccessibilityRole::WebArea; }
 389     virtual bool isCheckbox() const { return roleValue() == AccessibilityRole::CheckBox; }
 390     virtual bool isRadioButton() const { return roleValue() == AccessibilityRole::RadioButton; }
 391     virtual bool isNativeListBox() const { return false; }
 392     bool isListBox() const { return roleValue() == AccessibilityRole::ListBox; }
 393     virtual bool isListBoxOption() const { return false; }
 394     bool isAttachment() const override { return false; }
 395     virtual bool isMediaTimeline() const { return false; }
 396     virtual bool isMenuRelated() const { return false; }
 397     virtual bool isMenu() const { return false; }
 398     virtual bool isMenuBar() const { return false; }
 399     virtual bool isMenuButton() const { return false; }
 400     virtual bool isMenuItem() const { return false; }
 401     bool isFileUploadButton() const override { return false; }
 402     virtual bool isInputImage() const { return false; }
 403     virtual bool isProgressIndicator() const { return false; }
 404     virtual bool isSlider() const { return false; }
 405     virtual bool isSliderThumb() const { return false; }
 406     virtual bool isInputSlider() const { return false; }
 407     virtual bool isControl() const { return false; }
 408     virtual bool isLabel() const { return false; }
 409     virtual bool isList() const { return false; }
 410     virtual bool isTable() const { return false; }
 411     virtual bool isDataTable() const { return false; }
 412     virtual bool isTableRow() const { return false; }
 413     virtual bool isTableColumn() const { return false; }
 414     virtual bool isTableCell() const { return false; }
 415     virtual bool isFieldset() const { return false; }
 416     virtual bool isGroup() const { return false; }
 417     virtual bool isARIATreeGridRow() const { return false; }
 418     bool isImageMapLink() const override { return false; }
 419     virtual bool isMenuList() const { return false; }
 420     virtual bool isMenuListPopup() const { return false; }
 421     virtual bool isMenuListOption() const { return false; }
 422     virtual bool isSpinButton() const { return roleValue() == AccessibilityRole::SpinButton; }
 423     virtual bool isNativeSpinButton() const { return false; }
 424     virtual bool isSpinButtonPart() const { return false; }
 425     virtual bool isMockObject() const { return false; }
 426     bool isMediaControlLabel() const override { return false; }
 427     virtual bool isMediaObject() const { return false; }
 428     bool isSwitch() const { return roleValue() == AccessibilityRole::Switch; }
 429     bool isToggleButton() const { return roleValue() == AccessibilityRole::ToggleButton; }
 430     bool isTextControl() const;
 431     bool isARIATextControl() const;
 432     bool isNonNativeTextControl() const;
 433     bool isTabList() const { return roleValue() == AccessibilityRole::TabList; }
 434     bool isTabItem() const { return roleValue() == AccessibilityRole::Tab; }
 435     bool isRadioGroup() const { return roleValue() == AccessibilityRole::RadioGroup; }
 436     bool isComboBox() const { return roleValue() == AccessibilityRole::ComboBox; }
 437     bool isTree() const override { return roleValue() == AccessibilityRole::Tree; }
 438     bool isTreeGrid() const { return roleValue() == AccessibilityRole::TreeGrid; }
 439     bool isTreeItem() const override { return roleValue() == AccessibilityRole::TreeItem; }
 440     bool isScrollbar() const override { return roleValue() == AccessibilityRole::ScrollBar; }
 441     bool isButton() const;
 442     bool isListItem() const { return roleValue() == AccessibilityRole::ListItem; }
 443     bool isCheckboxOrRadio() const { return isCheckbox() || isRadioButton(); }
 444     bool isScrollView() const { return roleValue() == AccessibilityRole::ScrollArea; }
 445     bool isCanvas() const { return roleValue() == AccessibilityRole::Canvas; }
 446     bool isPopUpButton() const { return roleValue() == AccessibilityRole::PopUpButton; }
 447     bool isBlockquote() const;
 448     bool isLandmark() const;
 449     bool isColorWell() const { return roleValue() == AccessibilityRole::ColorWell; }
 450     bool isRangeControl() const;
 451     bool isMeter() const;
 452     bool isSplitter() const { return roleValue() == AccessibilityRole::Splitter; }
 453     bool isToolbar() const { return roleValue() == AccessibilityRole::Toolbar; }
 454     bool isStyleFormatGroup() const;
 455     bool isFigureElement() const;
 456     bool isKeyboardFocusable() const;
 457     bool isSummary() const { return roleValue() == AccessibilityRole::Summary; }
 458     bool isOutput() const;
 459 
 460     virtual bool isChecked() const { return false; }
 461     virtual bool isEnabled() const { return false; }
 462     virtual bool isSelected() const { return false; }
 463     virtual bool isFocused() const { return false; }
 464     virtual bool isHovered() const { return false; }
 465     virtual bool isIndeterminate() const { return false; }
 466     virtual bool isLoaded() const { return false; }
 467     virtual bool isMultiSelectable() const { return false; }
 468     virtual bool isOffScreen() const { return false; }
 469     virtual bool isPressed() const { return false; }
 470     virtual bool isUnvisited() const { return false; }
 471     virtual bool isVisited() const { return false; }
 472     virtual bool isRequired() const { return false; }
 473     virtual bool supportsRequiredAttribute() const { return false; }
 474     virtual bool isLinked() const { return false; }
 475     virtual bool isExpanded() const;
 476     virtual bool isVisible() const { return true; }
 477     virtual bool isCollapsed() const { return false; }
 478     virtual void setIsExpanded(bool) { }
 479     FloatRect relativeFrame() const override;
 480     FloatRect convertFrameToSpace(const FloatRect&amp;, AccessibilityConversionSpace) const;
 481 
 482     // In a multi-select list, many items can be selected but only one is active at a time.
 483     virtual bool isSelectedOptionActive() const { return false; }
 484 
 485     virtual bool hasBoldFont() const { return false; }
 486     virtual bool hasItalicFont() const { return false; }
 487     bool hasMisspelling() const;
 488     virtual bool hasPlainText() const { return false; }
 489     virtual bool hasSameFont(RenderObject*) const { return false; }
 490     virtual bool hasSameFontColor(RenderObject*) const { return false; }
 491     virtual bool hasSameStyle(RenderObject*) const { return false; }
 492     bool isStaticText() const { return roleValue() == AccessibilityRole::StaticText; }
 493     virtual bool hasUnderline() const { return false; }
 494     bool hasHighlighting() const;
 495 
 496     bool supportsDatetimeAttribute() const;
 497     const AtomString&amp; datetimeAttributeValue() const;
 498 
 499     virtual bool canSetFocusAttribute() const { return false; }
 500     virtual bool canSetTextRangeAttributes() const { return false; }
 501     virtual bool canSetValueAttribute() const { return false; }
 502     virtual bool canSetNumericValue() const { return false; }
 503     virtual bool canSetSelectedAttribute() const { return false; }
 504     virtual bool canSetSelectedChildrenAttribute() const { return false; }
 505     virtual bool canSetExpandedAttribute() const { return false; }
 506 
 507     virtual Element* element() const;
 508     virtual Node* node() const { return nullptr; }
 509     virtual RenderObject* renderer() const { return nullptr; }
 510     bool accessibilityIsIgnored() const override;
 511     virtual AccessibilityObjectInclusion defaultObjectInclusion() const;
 512     bool accessibilityIsIgnoredByDefault() const;
 513 
 514     bool isShowingValidationMessage() const;
 515     String validationMessage() const;
 516 
 517     unsigned blockquoteLevel() const;
 518     virtual int headingLevel() const { return 0; }
 519     virtual int tableLevel() const { return 0; }
 520     virtual AccessibilityButtonState checkboxOrRadioValue() const;
 521     virtual String valueDescription() const { return String(); }
 522     virtual float valueForRange() const { return 0.0f; }
 523     virtual float maxValueForRange() const { return 0.0f; }
 524     virtual float minValueForRange() const { return 0.0f; }
 525     virtual float stepValueForRange() const { return 0.0f; }
 526     virtual AccessibilityObject* selectedRadioButton() { return nullptr; }
 527     virtual AccessibilityObject* selectedTabItem() { return nullptr; }
 528     AccessibilityObject* selectedListItem();
 529     virtual int layoutCount() const { return 0; }
 530     virtual double estimatedLoadingProgress() const { return 0; }
 531     WEBCORE_EXPORT static bool isARIAControl(AccessibilityRole);
 532     WEBCORE_EXPORT static bool isARIAInput(AccessibilityRole);
 533 
 534     virtual bool supportsARIAOwns() const { return false; }
 535     bool isActiveDescendantOfFocusedContainer() const;
 536     void ariaActiveDescendantReferencingElements(AccessibilityChildrenVector&amp;) const;
 537     void ariaControlsElements(AccessibilityChildrenVector&amp;) const;
 538     void ariaControlsReferencingElements(AccessibilityChildrenVector&amp;) const;
 539     void ariaDescribedByElements(AccessibilityChildrenVector&amp;) const;
 540     void ariaDescribedByReferencingElements(AccessibilityChildrenVector&amp;) const;
 541     void ariaDetailsElements(AccessibilityChildrenVector&amp;) const;
 542     void ariaDetailsReferencingElements(AccessibilityChildrenVector&amp;) const;
 543     void ariaErrorMessageElements(AccessibilityChildrenVector&amp;) const;
 544     void ariaErrorMessageReferencingElements(AccessibilityChildrenVector&amp;) const;
 545     void ariaFlowToElements(AccessibilityChildrenVector&amp;) const;
 546     void ariaFlowToReferencingElements(AccessibilityChildrenVector&amp;) const;
 547     void ariaLabelledByElements(AccessibilityChildrenVector&amp;) const;
 548     void ariaLabelledByReferencingElements(AccessibilityChildrenVector&amp;) const;
 549     void ariaOwnsElements(AccessibilityChildrenVector&amp;) const;
 550     void ariaOwnsReferencingElements(AccessibilityChildrenVector&amp;) const;
 551 
 552     virtual bool hasPopup() const { return false; }
 553     String popupValue() const;
 554     bool hasDatalist() const;
 555     bool supportsHasPopup() const;
 556     bool pressedIsPresent() const;
 557     bool ariaIsMultiline() const;
 558     String invalidStatus() const;
 559     bool supportsPressed() const;
 560     bool supportsExpanded() const;
 561     bool supportsChecked() const;
 562     AccessibilitySortDirection sortDirection() const;
 563     virtual bool canvasHasFallbackContent() const { return false; }
 564     bool supportsRangeValue() const;
 565     const AtomString&amp; identifierAttribute() const;
 566     const AtomString&amp; linkRelValue() const;
 567     void classList(Vector&lt;String&gt;&amp;) const;
 568     virtual String roleDescription() const;
 569     AccessibilityCurrentState currentState() const;
 570     String currentValue() const;
 571     bool supportsCurrent() const;
 572     const String keyShortcutsValue() const;
 573 
 574     // This function checks if the object should be ignored when there&#39;s a modal dialog displayed.
 575     bool ignoredFromModalPresence() const;
 576     bool isModalDescendant(Node*) const;
 577     bool isModalNode() const;
 578 
 579     bool supportsSetSize() const;
 580     bool supportsPosInSet() const;
 581     int setSize() const;
 582     int posInSet() const;
 583 
 584     // ARIA drag and drop
 585     virtual bool supportsARIADropping() const { return false; }
 586     virtual bool supportsARIADragging() const { return false; }
 587     virtual bool isARIAGrabbed() { return false; }
 588     virtual void setARIAGrabbed(bool) { }
 589     virtual Vector&lt;String&gt; determineARIADropEffects() { return { }; }
 590 
 591     // Called on the root AX object to return the deepest available element.
 592     AccessibilityObjectInterface* accessibilityHitTest(const IntPoint&amp;) const override { return nullptr; }
 593     // Called on the AX object after the render tree determines which is the right AccessibilityRenderObject.
 594     virtual AccessibilityObjectInterface* elementAccessibilityHitTest(const IntPoint&amp;) const;
 595 
 596     AccessibilityObjectInterface* focusedUIElement() const override;
 597 
 598     virtual AccessibilityObject* firstChild() const { return nullptr; }
 599     virtual AccessibilityObject* lastChild() const { return nullptr; }
 600     virtual AccessibilityObject* previousSibling() const { return nullptr; }
 601     virtual AccessibilityObject* nextSibling() const { return nullptr; }
 602     virtual AccessibilityObject* nextSiblingUnignored(int limit) const;
 603     virtual AccessibilityObject* previousSiblingUnignored(int limit) const;
 604     virtual AccessibilityObject* parentObject() const { return nullptr; }
 605     virtual AccessibilityObject* parentObjectUnignored() const;
 606     AccessibilityObjectInterface* parentObjectInterfaceUnignored() const override { return parentObjectUnignored(); }
 607     virtual AccessibilityObject* parentObjectIfExists() const { return nullptr; }
 608     static AccessibilityObject* firstAccessibleObjectFromNode(const Node*);
 609     void findMatchingObjects(AccessibilitySearchCriteria*, AccessibilityChildrenVector&amp;);
 610     virtual bool isDescendantOfBarrenParent() const { return false; }
 611 
 612     bool isDescendantOfRole(AccessibilityRole) const;
 613 
 614     // Text selection
 615 private:
 616     RefPtr&lt;Range&gt; rangeOfStringClosestToRangeInDirection(Range*, AccessibilitySearchDirection, Vector&lt;String&gt; const&amp;) const;
 617     RefPtr&lt;Range&gt; selectionRange() const;
 618     RefPtr&lt;Range&gt; findTextRange(Vector&lt;String&gt; const&amp; searchStrings, RefPtr&lt;Range&gt; const&amp; start, AccessibilitySearchTextDirection) const;
 619 public:
 620     Vector&lt;RefPtr&lt;Range&gt;&gt; findTextRanges(AccessibilitySearchTextCriteria const&amp;) const;
 621     Vector&lt;String&gt; performTextOperation(AccessibilityTextOperation const&amp;);
 622 
 623     virtual AccessibilityObject* observableObject() const { return nullptr; }
 624     virtual void linkedUIElements(AccessibilityChildrenVector&amp;) const { }
 625     virtual AccessibilityObject* titleUIElement() const { return nullptr; }
 626     virtual bool exposesTitleUIElement() const { return true; }
 627     virtual AccessibilityObject* correspondingLabelForControlElement() const { return nullptr; }
 628     virtual AccessibilityObject* correspondingControlForLabelElement() const { return nullptr; }
 629     virtual AccessibilityObject* scrollBar(AccessibilityOrientation) { return nullptr; }
 630 
 631     virtual AccessibilityRole ariaRoleAttribute() const { return AccessibilityRole::Unknown; }
 632     virtual bool isPresentationalChildOfAriaRole() const { return false; }
 633     virtual bool ariaRoleHasPresentationalChildren() const { return false; }
 634     virtual bool inheritsPresentationalRole() const { return false; }
 635 
 636     // Accessibility Text
 637     virtual void accessibilityText(Vector&lt;AccessibilityText&gt;&amp;) const { };
 638     // A single method for getting a computed label for an AXObject. It condenses the nuances of accessibilityText. Used by Inspector.
 639     String computedLabel();
 640 
 641     // A programmatic way to set a name on an AccessibleObject.
 642     virtual void setAccessibleName(const AtomString&amp;) { }
 643     virtual bool hasAttributesRequiredForInclusion() const;
 644 
 645     // Accessibility Text - (To be deprecated).
 646     virtual String accessibilityDescription() const { return String(); }
 647     virtual String title() const { return String(); }
 648     virtual String helpText() const { return String(); }
 649 
 650     // Methods for determining accessibility text.
 651     bool isARIAStaticText() const { return ariaRoleAttribute() == AccessibilityRole::StaticText; }
 652     virtual String stringValue() const { return String(); }
 653     virtual String textUnderElement(AccessibilityTextUnderElementMode = AccessibilityTextUnderElementMode()) const { return String(); }
 654     virtual String text() const { return String(); }
 655     virtual int textLength() const { return 0; }
 656     virtual String ariaLabeledByAttribute() const { return String(); }
 657     virtual String ariaDescribedByAttribute() const { return String(); }
 658     const String placeholderValue() const;
 659     bool accessibleNameDerivesFromContent() const;
 660 
 661     // Abbreviations
 662     virtual String expandedTextValue() const { return String(); }
 663     virtual bool supportsExpandedTextValue() const { return false; }
 664 
 665     void elementsFromAttribute(Vector&lt;Element*&gt;&amp;, const QualifiedName&amp;) const;
 666 
 667     // Only if isColorWell()
 668     virtual void colorValue(int&amp; r, int&amp; g, int&amp; b) const { r = 0; g = 0; b = 0; }
 669 
 670     AccessibilityRole roleValue() const override { return m_role; }
 671 
 672     virtual AXObjectCache* axObjectCache() const;
 673     AXID axObjectID() const { return m_id; }
 674 
 675     static AccessibilityObject* anchorElementForNode(Node*);
 676     static AccessibilityObject* headingElementForNode(Node*);
 677     virtual Element* anchorElement() const { return nullptr; }
 678     bool supportsPressAction() const;
 679     virtual Element* actionElement() const { return nullptr; }
 680     virtual LayoutRect boundingBoxRect() const { return LayoutRect(); }
 681     IntRect pixelSnappedBoundingBoxRect() const { return snappedIntRect(boundingBoxRect()); }
 682     virtual LayoutRect elementRect() const = 0;
 683     LayoutSize size() const { return elementRect().size(); }
 684     virtual IntPoint clickPoint();
 685     static IntRect boundingBoxForQuads(RenderObject*, const Vector&lt;FloatQuad&gt;&amp;);
 686     virtual Path elementPath() const { return Path(); }
 687     virtual bool supportsPath() const { return false; }
 688 
 689     TextIteratorBehavior textIteratorBehaviorForTextRange() const;
 690     virtual PlainTextRange selectedTextRange() const { return PlainTextRange(); }
 691     unsigned selectionStart() const { return selectedTextRange().start; }
 692     unsigned selectionEnd() const { return selectedTextRange().length; }
 693 
 694     virtual URL url() const { return URL(); }
 695     virtual VisibleSelection selection() const { return VisibleSelection(); }
 696     virtual String selectedText() const { return String(); }
 697     virtual const AtomString&amp; accessKey() const { return nullAtom(); }
 698     const String&amp; actionVerb() const;
 699     virtual Widget* widget() const { return nullptr; }
 700     virtual Widget* widgetForAttachmentView() const { return nullptr; }
 701     Page* page() const;
 702     virtual Document* document() const;
 703     virtual FrameView* documentFrameView() const;
 704     Frame* frame() const;
 705     Frame* mainFrame() const;
 706     Document* topDocument() const;
 707     ScrollView* scrollViewAncestor() const;
 708     String language() const;
 709     // 1-based, to match the aria-level spec.
 710     virtual unsigned hierarchicalLevel() const { return 0; }
 711 
 712     virtual void setFocused(bool) { }
 713     virtual void setSelectedText(const String&amp;) { }
 714     virtual void setSelectedTextRange(const PlainTextRange&amp;) { }
 715     virtual void setValue(const String&amp;) { }
 716     bool replaceTextInRange(const String&amp;, const PlainTextRange&amp;);
 717     bool insertText(const String&amp;);
 718 
 719     virtual void setValue(float) { }
 720     virtual void setSelected(bool) { }
 721     virtual void setSelectedRows(AccessibilityChildrenVector&amp;) { }
 722 
 723     virtual void makeRangeVisible(const PlainTextRange&amp;) { }
 724     virtual bool press();
 725     bool performDefaultAction() { return press(); }
 726 
 727     virtual AccessibilityOrientation orientation() const;
 728     virtual void increment() { }
 729     virtual void decrement() { }
 730 
 731     virtual void childrenChanged() { }
 732     virtual void textChanged() { }
 733     virtual void updateAccessibilityRole() { }
 734     const AccessibilityChildrenVector&amp; children(bool updateChildrenIfNeeded = true);
 735     virtual void addChildren() { }
 736     virtual void addChild(AccessibilityObject*);
 737     virtual void insertChild(AccessibilityObject*, unsigned);
 738 
 739     virtual bool shouldIgnoreAttributeRole() const { return false; }
 740 
 741     virtual bool canHaveChildren() const { return true; }
 742     virtual bool hasChildren() const { return m_haveChildren; }
 743     void updateChildrenIfNecessary() override;
 744     virtual void setNeedsToUpdateChildren() { }
 745     virtual void setNeedsToUpdateSubtree() { }
 746     virtual void clearChildren();
 747     virtual bool needsToUpdateChildren() const { return false; }
 748 #if PLATFORM(COCOA)
 749     virtual void detachFromParent();
 750 #else
 751     virtual void detachFromParent() { }
 752 #endif
 753     virtual bool isDetachedFromParent() { return false; }
 754 
 755     virtual bool canHaveSelectedChildren() const { return false; }
 756     virtual void selectedChildren(AccessibilityChildrenVector&amp;) { }
 757     virtual void visibleChildren(AccessibilityChildrenVector&amp;) { }
 758     virtual void tabChildren(AccessibilityChildrenVector&amp;) { }
 759     virtual bool shouldFocusActiveDescendant() const { return false; }
 760     virtual AccessibilityObject* activeDescendant() const { return nullptr; }
 761     virtual void handleActiveDescendantChanged() { }
 762     virtual void handleAriaExpandedChanged() { }
 763     bool isDescendantOfObject(const AccessibilityObject*) const;
 764     bool isAncestorOfObject(const AccessibilityObject*) const;
 765     AccessibilityObject* firstAnonymousBlockChild() const;
 766 
 767     WEBCORE_EXPORT static AccessibilityRole ariaRoleToWebCoreRole(const String&amp;);
 768     bool hasAttribute(const QualifiedName&amp;) const;
 769     const AtomString&amp; getAttribute(const QualifiedName&amp;) const;
 770     bool hasTagName(const QualifiedName&amp;) const;
 771 
 772     virtual VisiblePositionRange visiblePositionRange() const { return VisiblePositionRange(); }
 773     virtual VisiblePositionRange visiblePositionRangeForLine(unsigned) const { return VisiblePositionRange(); }
 774 
 775     RefPtr&lt;Range&gt; elementRange() const;
 776     static bool replacedNodeNeedsCharacter(Node* replacedNode);
 777 
 778     VisiblePositionRange visiblePositionRangeForUnorderedPositions(const VisiblePosition&amp;, const VisiblePosition&amp;) const;
 779     VisiblePositionRange positionOfLeftWord(const VisiblePosition&amp;) const;
 780     VisiblePositionRange positionOfRightWord(const VisiblePosition&amp;) const;
 781     VisiblePositionRange leftLineVisiblePositionRange(const VisiblePosition&amp;) const;
 782     VisiblePositionRange rightLineVisiblePositionRange(const VisiblePosition&amp;) const;
 783     VisiblePositionRange sentenceForPosition(const VisiblePosition&amp;) const;
 784     VisiblePositionRange paragraphForPosition(const VisiblePosition&amp;) const;
 785     VisiblePositionRange styleRangeForPosition(const VisiblePosition&amp;) const;
 786     VisiblePositionRange visiblePositionRangeForRange(const PlainTextRange&amp;) const;
 787     VisiblePositionRange lineRangeForPosition(const VisiblePosition&amp;) const;
 788 
 789     RefPtr&lt;Range&gt; rangeForPlainTextRange(const PlainTextRange&amp;) const;
 790 
 791     static String stringForVisiblePositionRange(const VisiblePositionRange&amp;);
 792     String stringForRange(RefPtr&lt;Range&gt;) const;
 793     virtual IntRect boundsForVisiblePositionRange(const VisiblePositionRange&amp;) const { return IntRect(); }
 794     virtual IntRect boundsForRange(const RefPtr&lt;Range&gt;) const { return IntRect(); }
 795     int lengthForVisiblePositionRange(const VisiblePositionRange&amp;) const;
 796     virtual void setSelectedVisiblePositionRange(const VisiblePositionRange&amp;) const { }
 797 
 798     VisiblePosition visiblePositionForBounds(const IntRect&amp;, AccessibilityVisiblePositionForBounds) const;
 799     virtual VisiblePosition visiblePositionForPoint(const IntPoint&amp;) const { return VisiblePosition(); }
 800     VisiblePosition nextVisiblePosition(const VisiblePosition&amp; visiblePos) const { return visiblePos.next(); }
 801     VisiblePosition previousVisiblePosition(const VisiblePosition&amp; visiblePos) const { return visiblePos.previous(); }
 802     VisiblePosition nextWordEnd(const VisiblePosition&amp;) const;
 803     VisiblePosition previousWordStart(const VisiblePosition&amp;) const;
 804     VisiblePosition nextLineEndPosition(const VisiblePosition&amp;) const;
 805     VisiblePosition previousLineStartPosition(const VisiblePosition&amp;) const;
 806     VisiblePosition nextSentenceEndPosition(const VisiblePosition&amp;) const;
 807     VisiblePosition previousSentenceStartPosition(const VisiblePosition&amp;) const;
 808     VisiblePosition nextParagraphEndPosition(const VisiblePosition&amp;) const;
 809     VisiblePosition previousParagraphStartPosition(const VisiblePosition&amp;) const;
 810     virtual VisiblePosition visiblePositionForIndex(unsigned, bool /*lastIndexOK */) const { return VisiblePosition(); }
 811 
 812     virtual VisiblePosition visiblePositionForIndex(int) const { return VisiblePosition(); }
 813     virtual int indexForVisiblePosition(const VisiblePosition&amp;) const { return 0; }
 814 
 815     AccessibilityObject* accessibilityObjectForPosition(const VisiblePosition&amp;) const;
 816     int lineForPosition(const VisiblePosition&amp;) const;
 817     PlainTextRange plainTextRangeForVisiblePositionRange(const VisiblePositionRange&amp;) const;
 818     virtual int index(const VisiblePosition&amp;) const { return -1; }
 819 
 820     virtual void lineBreaks(Vector&lt;int&gt;&amp;) const { }
 821     virtual PlainTextRange doAXRangeForLine(unsigned) const { return PlainTextRange(); }
 822     PlainTextRange doAXRangeForPosition(const IntPoint&amp;) const;
 823     virtual PlainTextRange doAXRangeForIndex(unsigned) const { return PlainTextRange(); }
 824     PlainTextRange doAXStyleRangeForIndex(unsigned) const;
 825 
 826     virtual String doAXStringForRange(const PlainTextRange&amp;) const { return String(); }
 827     virtual IntRect doAXBoundsForRange(const PlainTextRange&amp;) const { return IntRect(); }
 828     virtual IntRect doAXBoundsForRangeUsingCharacterOffset(const PlainTextRange&amp;) const { return IntRect(); }
 829     static String listMarkerTextForNodeAndPosition(Node*, const VisiblePosition&amp;);
 830 
 831     unsigned doAXLineForIndex(unsigned);
 832 
 833     String computedRoleString() const;
 834 
 835     virtual String stringValueForMSAA() const { return String(); }
 836     virtual String stringRoleForMSAA() const { return String(); }
 837     virtual String nameForMSAA() const { return String(); }
 838     virtual String descriptionForMSAA() const { return String(); }
 839     virtual AccessibilityRole roleValueForMSAA() const { return roleValue(); }
 840 
 841     virtual String passwordFieldValue() const { return String(); }
 842     bool isValueAutofilled() const;
 843     bool isValueAutofillAvailable() const;
 844     AutoFillButtonType valueAutofillButtonType() const;
 845 
 846     // Used by an ARIA tree to get all its rows.
 847     void ariaTreeRows(AccessibilityChildrenVector&amp;);
 848     // Used by an ARIA tree item to get all of its direct rows that it can disclose.
 849     void ariaTreeItemDisclosedRows(AccessibilityChildrenVector&amp;);
 850     // Used by an ARIA tree item to get only its content, and not its child tree items and groups.
 851     void ariaTreeItemContent(AccessibilityChildrenVector&amp;);
 852 
 853     // ARIA live-region features.
 854     bool supportsLiveRegion(bool excludeIfOff = true) const;
 855     bool isInsideLiveRegion(bool excludeIfOff = true) const;
 856     AccessibilityObject* liveRegionAncestor(bool excludeIfOff = true) const;
 857     virtual const String liveRegionStatus() const { return String(); }
 858     virtual const String liveRegionRelevant() const { return nullAtom(); }
 859     virtual bool liveRegionAtomic() const { return false; }
 860     virtual bool isBusy() const { return false; }
 861     static const String defaultLiveRegionStatusForRole(AccessibilityRole);
 862     static bool liveRegionStatusIsEnabled(const AtomString&amp;);
 863     static bool contentEditableAttributeIsEnabled(Element*);
 864     bool hasContentEditableAttributeSet() const;
 865 
 866     bool supportsReadOnly() const;
 867     virtual String readOnlyValue() const;
 868 
 869     bool supportsAutoComplete() const;
 870     String autoCompleteValue() const;
 871 
 872     bool supportsARIAAttributes() const;
 873 
 874     // CSS3 Speech properties.
 875     virtual OptionSet&lt;SpeakAs&gt; speakAsProperty() const { return OptionSet&lt;SpeakAs&gt; { }; }
 876 
 877     // Make this object visible by scrolling as many nested scrollable views as needed.
 878     virtual void scrollToMakeVisible() const;
 879     // Same, but if the whole object can&#39;t be made visible, try for this subrect, in local coordinates.
 880     virtual void scrollToMakeVisibleWithSubFocus(const IntRect&amp;) const;
 881     // Scroll this object to a given point in global coordinates of the top-level window.
 882     virtual void scrollToGlobalPoint(const IntPoint&amp;) const;
 883 
 884     enum class ScrollByPageDirection { Up, Down, Left, Right };
 885     bool scrollByPage(ScrollByPageDirection) const;
 886     IntPoint scrollPosition() const;
 887     IntSize scrollContentsSize() const;
 888     IntRect scrollVisibleContentRect() const;
 889     void scrollToMakeVisible(const ScrollRectToVisibleOptions&amp;) const;
 890 
 891     bool lastKnownIsIgnoredValue();
 892     void setLastKnownIsIgnoredValue(bool);
 893 
 894     // Fires a children changed notification on the parent if the isIgnored value changed.
 895     void notifyIfIgnoredValueChanged();
 896 
 897     // All math elements return true for isMathElement().
 898     virtual bool isMathElement() const { return false; }
 899     virtual bool isMathFraction() const { return false; }
 900     virtual bool isMathFenced() const { return false; }
 901     virtual bool isMathSubscriptSuperscript() const { return false; }
 902     virtual bool isMathRow() const { return false; }
 903     virtual bool isMathUnderOver() const { return false; }
 904     virtual bool isMathRoot() const { return false; }
 905     virtual bool isMathSquareRoot() const { return false; }
 906     virtual bool isMathText() const { return false; }
 907     virtual bool isMathNumber() const { return false; }
 908     virtual bool isMathOperator() const { return false; }
 909     virtual bool isMathFenceOperator() const { return false; }
 910     virtual bool isMathSeparatorOperator() const { return false; }
 911     virtual bool isMathIdentifier() const { return false; }
 912     virtual bool isMathTable() const { return false; }
 913     virtual bool isMathTableRow() const { return false; }
 914     virtual bool isMathTableCell() const { return false; }
 915     virtual bool isMathMultiscript() const { return false; }
 916     virtual bool isMathToken() const { return false; }
 917     virtual bool isMathScriptObject(AccessibilityMathScriptObjectType) const { return false; }
 918     virtual bool isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType) const { return false; }
 919 
 920     // Root components.
 921     virtual AccessibilityObject* mathRadicandObject() { return nullptr; }
 922     virtual AccessibilityObject* mathRootIndexObject() { return nullptr; }
 923 
 924     // Under over components.
 925     virtual AccessibilityObject* mathUnderObject() { return nullptr; }
 926     virtual AccessibilityObject* mathOverObject() { return nullptr; }
 927 
 928     // Fraction components.
 929     virtual AccessibilityObject* mathNumeratorObject() { return nullptr; }
 930     virtual AccessibilityObject* mathDenominatorObject() { return nullptr; }
 931 
 932     // Subscript/superscript components.
 933     virtual AccessibilityObject* mathBaseObject() { return nullptr; }
 934     virtual AccessibilityObject* mathSubscriptObject() { return nullptr; }
 935     virtual AccessibilityObject* mathSuperscriptObject() { return nullptr; }
 936 
 937     // Fenced components.
 938     virtual String mathFencedOpenString() const { return String(); }
 939     virtual String mathFencedCloseString() const { return String(); }
 940     virtual int mathLineThickness() const { return 0; }
 941     virtual bool isAnonymousMathOperator() const { return false; }
 942 
 943     // Multiscripts components.
 944     typedef Vector&lt;std::pair&lt;AccessibilityObject*, AccessibilityObject*&gt;&gt; AccessibilityMathMultiscriptPairs;
 945     virtual void mathPrescripts(AccessibilityMathMultiscriptPairs&amp;) { }
 946     virtual void mathPostscripts(AccessibilityMathMultiscriptPairs&amp;) { }
 947 
 948     // Visibility.
 949     bool isAXHidden() const;
 950     bool isDOMHidden() const;
 951     bool isHidden() const { return isAXHidden() || isDOMHidden(); }
 952 
 953 #if ENABLE(ACCESSIBILITY)
 954     AccessibilityObjectWrapper* wrapper() const override { return m_wrapper.get(); }
 955     void setWrapper(AccessibilityObjectWrapper* wrapper) { m_wrapper = wrapper; }
 956 #else
 957     AccessibilityObjectWrapper* wrapper() const override { return nullptr; }
 958 #endif
 959 
 960 #if PLATFORM(COCOA)
 961     void overrideAttachmentParent(AccessibilityObject* parent);
 962 #else
 963     void overrideAttachmentParent(AccessibilityObject*) { }
 964 #endif
 965 
 966 #if ENABLE(ACCESSIBILITY)
 967     // a platform-specific method for determining if an attachment is ignored
 968     bool accessibilityIgnoreAttachment() const;
 969     // gives platforms the opportunity to indicate if and how an object should be included
 970     AccessibilityObjectInclusion accessibilityPlatformIncludesObject() const;
 971 #else
 972     bool accessibilityIgnoreAttachment() const { return true; }
 973     AccessibilityObjectInclusion accessibilityPlatformIncludesObject() const { return AccessibilityObjectInclusion::DefaultBehavior; }
 974 #endif
 975 
 976 #if PLATFORM(IOS_FAMILY)
 977     int accessibilityPasswordFieldLength();
 978     bool hasTouchEventListener() const;
 979     bool isInputTypePopupButton() const;
 980 #endif
 981 
 982     // allows for an AccessibilityObject to update its render tree or perform
 983     // other operations update type operations
 984     void updateBackingStore();
 985 
 986 #if PLATFORM(COCOA)
 987     bool preventKeyboardDOMEventDispatch() const;
 988     void setPreventKeyboardDOMEventDispatch(bool);
 989     bool fileUploadButtonReturnsValueInTitle() const;
 990     String speechHintAttributeValue() const override;
 991     String descriptionAttributeValue() const override;
 992     String helpTextAttributeValue() const override;
 993     String titleAttributeValue() const override;
 994 #endif
 995 
 996 #if PLATFORM(COCOA) &amp;&amp; !PLATFORM(IOS_FAMILY)
 997     bool caretBrowsingEnabled() const;
 998     void setCaretBrowsingEnabled(bool);
 999 #endif
1000 
1001     AccessibilityObject* focusableAncestor();
1002     AccessibilityObject* editableAncestor();
1003     AccessibilityObject* highestEditableAncestor();
1004 
1005     const AccessibilityScrollView* ancestorAccessibilityScrollView(bool includeSelf) const;
1006     static const AccessibilityObject* matchedParent(const AccessibilityObject&amp;, bool includeSelf, const WTF::Function&lt;bool(const AccessibilityObject&amp;)&gt;&amp;);
1007 
1008     void clearIsIgnoredFromParentData() { m_isIgnoredFromParentData = AccessibilityIsIgnoredFromParentData(); }
1009     void setIsIgnoredFromParentDataForChild(AccessibilityObject*);
1010 
1011 protected:
1012     AXID m_id { 0 };
1013     AccessibilityChildrenVector m_children;
1014     mutable bool m_haveChildren { false };
1015     AccessibilityRole m_role { AccessibilityRole::Unknown };
1016     AccessibilityObjectInclusion m_lastKnownIsIgnoredValue { AccessibilityObjectInclusion::DefaultBehavior };
1017     AccessibilityIsIgnoredFromParentData m_isIgnoredFromParentData { };
1018     bool m_childrenDirty { false };
1019     bool m_subtreeDirty { false };
1020 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
1021     bool m_isolatedTreeNodeInitialized { false };
1022 #endif
1023 
1024     void setIsIgnoredFromParentData(AccessibilityIsIgnoredFromParentData&amp; data) { m_isIgnoredFromParentData = data; }
1025 
1026     virtual bool computeAccessibilityIsIgnored() const { return true; }
1027     bool isAccessibilityObject() const override { return true; }
1028 
1029     // If this object itself scrolls, return its ScrollableArea.
1030     virtual ScrollableArea* getScrollableAreaIfScrollable() const { return nullptr; }
1031     virtual void scrollTo(const IntPoint&amp;) const { }
1032     ScrollableArea* scrollableAreaAncestor() const;
1033     void scrollAreaAndAncestor(std::pair&lt;ScrollableArea*, AccessibilityObject*&gt;&amp;) const;
1034 
1035     static bool isAccessibilityObjectSearchMatchAtIndex(AccessibilityObject*, AccessibilitySearchCriteria*, size_t);
1036     static bool isAccessibilityObjectSearchMatch(AccessibilityObject*, AccessibilitySearchCriteria*);
1037     static bool isAccessibilityTextSearchMatch(AccessibilityObject*, AccessibilitySearchCriteria*);
1038     static bool objectMatchesSearchCriteriaWithResultLimit(AccessibilityObject*, AccessibilitySearchCriteria*, AccessibilityChildrenVector&amp;);
1039     virtual AccessibilityRole buttonRoleType() const;
1040     bool isOnscreen() const;
1041     bool dispatchTouchEvent();
1042 
1043     void ariaElementsFromAttribute(AccessibilityChildrenVector&amp;, const QualifiedName&amp;) const;
1044     void ariaElementsReferencedByAttribute(AccessibilityChildrenVector&amp;, const QualifiedName&amp;) const;
1045 
1046     AccessibilityObject* radioGroupAncestor() const;
1047 
1048 #if ENABLE(ACCESSIBILITY) &amp;&amp; USE(ATK)
1049     bool allowsTextRanges() const;
1050     unsigned getLengthForTextRange() const;
1051 #else
1052     bool allowsTextRanges() const { return isTextControl(); }
1053     unsigned getLengthForTextRange() const { return text().length(); }
1054 #endif
1055 
1056 #if PLATFORM(COCOA)
1057     RetainPtr&lt;WebAccessibilityObjectWrapper&gt; m_wrapper;
1058 #elif PLATFORM(WIN)
1059     COMPtr&lt;AccessibilityObjectWrapper&gt; m_wrapper;
1060 #elif USE(ATK)
1061     GRefPtr&lt;WebKitAccessible&gt; m_wrapper;
1062 #endif
1063 };
1064 
1065 #if !ENABLE(ACCESSIBILITY)
1066 inline const AccessibilityObject::AccessibilityChildrenVector&amp; AccessibilityObject::children(bool) { return m_children; }
1067 inline const String&amp; AccessibilityObject::actionVerb() const { return emptyString(); }
1068 inline int AccessibilityObject::lineForPosition(const VisiblePosition&amp;) const { return -1; }
1069 inline void AccessibilityObject::updateBackingStore() { }
1070 #endif
1071 
1072 AccessibilityObject* firstAccessibleObjectFromNode(const Node*, const WTF::Function&lt;bool(const AccessibilityObject&amp;)&gt;&amp; isAccessible);
1073 
1074 } // namespace WebCore
1075 
1076 #define SPECIALIZE_TYPE_TRAITS_ACCESSIBILITY(ToValueTypeName, predicate) \
1077 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToValueTypeName) \
1078     static bool isType(const WebCore::AccessibilityObject&amp; object) { return object.predicate; } \
1079 SPECIALIZE_TYPE_TRAITS_END()
1080 
1081 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::AccessibilityObject)
1082 static bool isType(const WebCore::AccessibilityObjectInterface&amp; context) { return context.isAccessibilityObject(); }
1083 SPECIALIZE_TYPE_TRAITS_END()
    </pre>
  </body>
</html>