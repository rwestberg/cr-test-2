<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   5  *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
   6  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   7  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   8  * Copyright (C) 2008, 2009, 2011, 2012 Google Inc. All rights reserved.
   9  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  10  * Copyright (C) Research In Motion Limited 2010-2011. All rights reserved.
  11  *
  12  * This library is free software; you can redistribute it and/or
  13  * modify it under the terms of the GNU Library General Public
  14  * License as published by the Free Software Foundation; either
  15  * version 2 of the License, or (at your option) any later version.
  16  *
  17  * This library is distributed in the hope that it will be useful,
  18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  20  * Library General Public License for more details.
  21  *
  22  * You should have received a copy of the GNU Library General Public License
  23  * along with this library; see the file COPYING.LIB.  If not, write to
  24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  25  * Boston, MA 02110-1301, USA.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;Document.h&quot;
  30 
  31 #include &quot;AXObjectCache.h&quot;
  32 #include &quot;ApplicationStateChangeListener.h&quot;
  33 #include &quot;Attr.h&quot;
  34 #include &quot;BeforeUnloadEvent.h&quot;
  35 #include &quot;CDATASection.h&quot;
  36 #include &quot;CSSAnimationController.h&quot;
  37 #include &quot;CSSFontSelector.h&quot;
  38 #include &quot;CSSStyleDeclaration.h&quot;
  39 #include &quot;CSSStyleSheet.h&quot;
  40 #include &quot;CachedCSSStyleSheet.h&quot;
  41 #include &quot;CachedFrame.h&quot;
  42 #include &quot;CachedResourceLoader.h&quot;
  43 #include &quot;CanvasRenderingContext2D.h&quot;
  44 #include &quot;Chrome.h&quot;
  45 #include &quot;ChromeClient.h&quot;
  46 #include &quot;Comment.h&quot;
  47 #include &quot;CommonVM.h&quot;
  48 #include &quot;ComposedTreeIterator.h&quot;
  49 #include &quot;CompositionEvent.h&quot;
  50 #include &quot;ConstantPropertyMap.h&quot;
  51 #include &quot;ContentSecurityPolicy.h&quot;
  52 #include &quot;CookieJar.h&quot;
  53 #include &quot;CustomElementReactionQueue.h&quot;
  54 #include &quot;CustomElementRegistry.h&quot;
  55 #include &quot;CustomEvent.h&quot;
  56 #include &quot;CustomHeaderFields.h&quot;
  57 #include &quot;DOMImplementation.h&quot;
  58 #include &quot;DOMWindow.h&quot;
  59 #include &quot;DateComponents.h&quot;
  60 #include &quot;DebugPageOverlays.h&quot;
  61 #include &quot;DocumentLoader.h&quot;
  62 #include &quot;DocumentMarkerController.h&quot;
  63 #include &quot;DocumentSharedObjectPool.h&quot;
  64 #include &quot;DocumentTimeline.h&quot;
  65 #include &quot;DocumentType.h&quot;
  66 #include &quot;Editing.h&quot;
  67 #include &quot;Editor.h&quot;
  68 #include &quot;ElementIterator.h&quot;
  69 #include &quot;EventHandler.h&quot;
  70 #include &quot;ExtensionStyleSheets.h&quot;
  71 #include &quot;FocusController.h&quot;
  72 #include &quot;FocusEvent.h&quot;
  73 #include &quot;FontFaceSet.h&quot;
  74 #include &quot;FormController.h&quot;
  75 #include &quot;Frame.h&quot;
  76 #include &quot;FrameLoader.h&quot;
  77 #include &quot;FrameLoaderClient.h&quot;
  78 #include &quot;FrameView.h&quot;
  79 #include &quot;FullscreenManager.h&quot;
  80 #include &quot;GenericCachedHTMLCollection.h&quot;
  81 #include &quot;HTMLAllCollection.h&quot;
  82 #include &quot;HTMLAnchorElement.h&quot;
  83 #include &quot;HTMLAttachmentElement.h&quot;
  84 #include &quot;HTMLBaseElement.h&quot;
  85 #include &quot;HTMLBodyElement.h&quot;
  86 #include &quot;HTMLCanvasElement.h&quot;
  87 #include &quot;HTMLDocument.h&quot;
  88 #include &quot;HTMLElementFactory.h&quot;
  89 #include &quot;HTMLFormControlElement.h&quot;
  90 #include &quot;HTMLFrameOwnerElement.h&quot;
  91 #include &quot;HTMLFrameSetElement.h&quot;
  92 #include &quot;HTMLHeadElement.h&quot;
  93 #include &quot;HTMLHtmlElement.h&quot;
  94 #include &quot;HTMLImageElement.h&quot;
  95 #include &quot;HTMLInputElement.h&quot;
  96 #include &quot;HTMLLinkElement.h&quot;
  97 #include &quot;HTMLMediaElement.h&quot;
  98 #include &quot;HTMLNameCollection.h&quot;
  99 #include &quot;HTMLParserIdioms.h&quot;
 100 #include &quot;HTMLPictureElement.h&quot;
 101 #include &quot;HTMLPlugInElement.h&quot;
 102 #include &quot;HTMLScriptElement.h&quot;
 103 #include &quot;HTMLStyleElement.h&quot;
 104 #include &quot;HTMLTitleElement.h&quot;
 105 #include &quot;HTMLUnknownElement.h&quot;
 106 #include &quot;HTTPHeaderNames.h&quot;
 107 #include &quot;HTTPParsers.h&quot;
 108 #include &quot;HashChangeEvent.h&quot;
 109 #include &quot;History.h&quot;
 110 #include &quot;HitTestResult.h&quot;
 111 #include &quot;ImageBitmapRenderingContext.h&quot;
 112 #include &quot;ImageLoader.h&quot;
 113 #include &quot;InspectorInstrumentation.h&quot;
 114 #include &quot;IntersectionObserver.h&quot;
 115 #include &quot;JSCustomElementInterface.h&quot;
 116 #include &quot;JSLazyEventListener.h&quot;
 117 #include &quot;KeyboardEvent.h&quot;
 118 #include &quot;KeyframeEffect.h&quot;
 119 #include &quot;LayoutDisallowedScope.h&quot;
 120 #include &quot;LibWebRTCProvider.h&quot;
 121 #include &quot;LoaderStrategy.h&quot;
 122 #include &quot;Logging.h&quot;
 123 #include &quot;MediaCanStartListener.h&quot;
 124 #include &quot;MediaProducer.h&quot;
 125 #include &quot;MediaQueryList.h&quot;
 126 #include &quot;MediaQueryMatcher.h&quot;
 127 #include &quot;MediaStream.h&quot;
 128 #include &quot;MessageEvent.h&quot;
 129 #include &quot;Microtasks.h&quot;
 130 #include &quot;MouseEventWithHitTestResults.h&quot;
 131 #include &quot;MutationEvent.h&quot;
 132 #include &quot;NameNodeList.h&quot;
 133 #include &quot;NavigationDisabler.h&quot;
 134 #include &quot;NavigationScheduler.h&quot;
 135 #include &quot;NestingLevelIncrementer.h&quot;
 136 #include &quot;NodeIterator.h&quot;
 137 #include &quot;NodeRareData.h&quot;
 138 #include &quot;NodeWithIndex.h&quot;
 139 #include &quot;OverflowEvent.h&quot;
 140 #include &quot;PageConsoleClient.h&quot;
 141 #include &quot;PageGroup.h&quot;
 142 #include &quot;PageTransitionEvent.h&quot;
 143 #include &quot;PaintWorkletGlobalScope.h&quot;
 144 #include &quot;PlatformLocale.h&quot;
 145 #include &quot;PlatformMediaSessionManager.h&quot;
 146 #include &quot;PlatformScreen.h&quot;
 147 #include &quot;PlatformStrategies.h&quot;
 148 #include &quot;PlugInsResources.h&quot;
 149 #include &quot;PluginDocument.h&quot;
 150 #include &quot;PointerLockController.h&quot;
 151 #include &quot;PolicyChecker.h&quot;
 152 #include &quot;PopStateEvent.h&quot;
 153 #include &quot;ProcessingInstruction.h&quot;
 154 #include &quot;PublicSuffix.h&quot;
 155 #include &quot;Quirks.h&quot;
 156 #include &quot;RealtimeMediaSourceCenter.h&quot;
 157 #include &quot;RenderChildIterator.h&quot;
 158 #include &quot;RenderInline.h&quot;
 159 #include &quot;RenderLayerCompositor.h&quot;
 160 #include &quot;RenderLineBreak.h&quot;
 161 #include &quot;RenderTreeUpdater.h&quot;
 162 #include &quot;RenderView.h&quot;
 163 #include &quot;RenderWidget.h&quot;
 164 #include &quot;RequestAnimationFrameCallback.h&quot;
 165 #include &quot;ResizeObserver.h&quot;
 166 #include &quot;ResourceLoadObserver.h&quot;
 167 #include &quot;RuntimeApplicationChecks.h&quot;
 168 #include &quot;RuntimeEnabledFeatures.h&quot;
 169 #include &quot;SVGDocumentExtensions.h&quot;
 170 #include &quot;SVGElement.h&quot;
 171 #include &quot;SVGElementFactory.h&quot;
 172 #include &quot;SVGNames.h&quot;
 173 #include &quot;SVGSVGElement.h&quot;
 174 #include &quot;SVGTitleElement.h&quot;
 175 #include &quot;SVGUseElement.h&quot;
 176 #include &quot;SVGZoomEvent.h&quot;
 177 #include &quot;SWClientConnection.h&quot;
 178 #include &quot;SchemeRegistry.h&quot;
 179 #include &quot;ScopedEventQueue.h&quot;
 180 #include &quot;ScriptController.h&quot;
 181 #include &quot;ScriptDisallowedScope.h&quot;
 182 #include &quot;ScriptModuleLoader.h&quot;
 183 #include &quot;ScriptRunner.h&quot;
 184 #include &quot;ScriptSourceCode.h&quot;
 185 #include &quot;ScriptState.h&quot;
 186 #include &quot;ScriptedAnimationController.h&quot;
 187 #include &quot;ScrollbarTheme.h&quot;
 188 #include &quot;ScrollingCoordinator.h&quot;
 189 #include &quot;SecurityOrigin.h&quot;
 190 #include &quot;SecurityOriginData.h&quot;
 191 #include &quot;SecurityOriginPolicy.h&quot;
 192 #include &quot;SecurityPolicy.h&quot;
 193 #include &quot;SegmentedString.h&quot;
 194 #include &quot;SelectorQuery.h&quot;
 195 #include &quot;ServiceWorkerClientData.h&quot;
 196 #include &quot;ServiceWorkerProvider.h&quot;
 197 #include &quot;Settings.h&quot;
 198 #include &quot;ShadowRoot.h&quot;
 199 #include &quot;SocketProvider.h&quot;
 200 #include &quot;StorageEvent.h&quot;
 201 #include &quot;StringCallback.h&quot;
 202 #include &quot;StyleColor.h&quot;
 203 #include &quot;StyleProperties.h&quot;
 204 #include &quot;StyleResolveForDocument.h&quot;
 205 #include &quot;StyleResolver.h&quot;
 206 #include &quot;StyleScope.h&quot;
 207 #include &quot;StyleSheetContents.h&quot;
 208 #include &quot;StyleSheetList.h&quot;
 209 #include &quot;StyleTreeResolver.h&quot;
 210 #include &quot;SubresourceLoader.h&quot;
 211 #include &quot;TextAutoSizing.h&quot;
 212 #include &quot;TextEvent.h&quot;
 213 #include &quot;TextNodeTraversal.h&quot;
 214 #include &quot;TouchAction.h&quot;
 215 #include &quot;TransformSource.h&quot;
 216 #include &quot;TreeWalker.h&quot;
 217 #include &quot;UndoManager.h&quot;
 218 #include &quot;UserGestureIndicator.h&quot;
 219 #include &quot;ValidationMessageClient.h&quot;
 220 #include &quot;VisibilityChangeClient.h&quot;
 221 #include &quot;VisitedLinkState.h&quot;
 222 #include &quot;WebAnimation.h&quot;
 223 #include &quot;WheelEvent.h&quot;
 224 #include &quot;WindowFeatures.h&quot;
 225 #include &quot;Worklet.h&quot;
 226 #include &quot;XMLDocument.h&quot;
 227 #include &quot;XMLDocumentParser.h&quot;
 228 #include &quot;XMLNSNames.h&quot;
 229 #include &quot;XMLNames.h&quot;
 230 #include &quot;XPathEvaluator.h&quot;
 231 #include &quot;XPathExpression.h&quot;
 232 #include &quot;XPathNSResolver.h&quot;
 233 #include &quot;XPathResult.h&quot;
 234 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 235 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 236 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 237 #include &lt;JavaScriptCore/VM.h&gt;
 238 #include &lt;ctime&gt;
 239 #include &lt;wtf/IsoMallocInlines.h&gt;
 240 #include &lt;wtf/Language.h&gt;
 241 #include &lt;wtf/NeverDestroyed.h&gt;
 242 #include &lt;wtf/SetForScope.h&gt;
 243 #include &lt;wtf/SystemTracing.h&gt;
 244 #include &lt;wtf/UUID.h&gt;
 245 #include &lt;wtf/text/StringBuffer.h&gt;
 246 #include &lt;wtf/text/TextStream.h&gt;
 247 
 248 #if PLATFORM(JAVA)
 249 #include &lt;wtf/unicode/java/UnicodeJava.h&gt;
 250 #endif
 251 
 252 #if ENABLE(DEVICE_ORIENTATION)
 253 #include &quot;DeviceMotionEvent.h&quot;
 254 #include &quot;DeviceOrientationAndMotionAccessController.h&quot;
 255 #include &quot;DeviceOrientationEvent.h&quot;
 256 #endif
 257 
 258 #if ENABLE(FULLSCREEN_API)
 259 #include &quot;RenderFullScreen.h&quot;
 260 #endif
 261 
 262 #if ENABLE(INDEXED_DATABASE)
 263 #include &quot;IDBConnectionProxy.h&quot;
 264 #include &quot;IDBOpenDBRequest.h&quot;
 265 #endif
 266 
 267 #if PLATFORM(IOS_FAMILY)
 268 #include &quot;ContentChangeObserver.h&quot;
 269 #include &quot;CSSFontSelector.h&quot;
 270 #include &quot;DOMTimerHoldingTank.h&quot;
 271 #include &quot;DeviceMotionClientIOS.h&quot;
 272 #include &quot;DeviceMotionController.h&quot;
 273 #include &quot;DeviceOrientationClientIOS.h&quot;
 274 #include &quot;DeviceOrientationController.h&quot;
 275 #include &quot;Geolocation.h&quot;
 276 #include &quot;Navigator.h&quot;
 277 #include &quot;NavigatorGeolocation.h&quot;
 278 #endif
 279 
 280 #if ENABLE(IOS_GESTURE_EVENTS)
 281 #include &quot;GestureEvent.h&quot;
 282 #endif
 283 
 284 #if ENABLE(MATHML)
 285 #include &quot;MathMLElement.h&quot;
 286 #include &quot;MathMLElementFactory.h&quot;
 287 #include &quot;MathMLNames.h&quot;
 288 #endif
 289 
 290 #if ENABLE(MEDIA_SESSION)
 291 #include &quot;MediaSession.h&quot;
 292 #endif
 293 
 294 #if USE(QUICK_LOOK)
 295 #include &quot;QuickLook.h&quot;
 296 #endif
 297 
 298 #if ENABLE(TOUCH_EVENTS)
 299 #include &quot;TouchEvent.h&quot;
 300 #endif
 301 
 302 #if ENABLE(VIDEO_TRACK)
 303 #include &quot;CaptionUserPreferences.h&quot;
 304 #endif
 305 
 306 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 307 #include &quot;MediaPlaybackTargetClient.h&quot;
 308 #endif
 309 
 310 #if ENABLE(XSLT)
 311 #include &quot;XSLTProcessor.h&quot;
 312 #endif
 313 
 314 #if ENABLE(WEBGL)
 315 #include &quot;WebGLRenderingContext.h&quot;
 316 #endif
 317 #if ENABLE(WEBGL2)
 318 #include &quot;WebGL2RenderingContext.h&quot;
 319 #endif
 320 #if ENABLE(WEBGPU)
 321 #include &quot;GPUCanvasContext.h&quot;
 322 #endif
 323 
 324 #if ENABLE(POINTER_EVENTS)
 325 #include &quot;PointerCaptureController.h&quot;
 326 #endif
 327 
 328 namespace WebCore {
 329 
 330 WTF_MAKE_ISO_ALLOCATED_IMPL(Document);
 331 
 332 using namespace HTMLNames;
 333 using namespace PAL;
 334 using namespace WTF::Unicode;
 335 
 336 static const unsigned cMaxWriteRecursionDepth = 21;
 337 bool Document::hasEverCreatedAnAXObjectCache = false;
 338 static const Seconds maxIntervalForUserGestureForwardingAfterMediaFinishesPlaying { 1_s };
 339 
 340 struct FrameFlatteningLayoutDisallower {
 341     FrameFlatteningLayoutDisallower(FrameView&amp; frameView)
 342         : m_frameView(frameView)
 343         , m_disallowLayout(frameView.effectiveFrameFlattening() != FrameFlattening::Disabled)
 344     {
 345         if (m_disallowLayout)
 346             m_frameView.startDisallowingLayout();
 347     }
 348 
 349     ~FrameFlatteningLayoutDisallower()
 350     {
 351         if (m_disallowLayout)
 352             m_frameView.endDisallowingLayout();
 353     }
 354 
 355 private:
 356     FrameView&amp; m_frameView;
 357     bool m_disallowLayout { false };
 358 };
 359 
 360 #if ENABLE(INTERSECTION_OBSERVER)
 361 static const Seconds intersectionObserversInitialUpdateDelay { 2000_ms };
 362 #endif
 363 
 364 // DOM Level 2 says (letters added):
 365 //
 366 // a) Name start characters must have one of the categories Ll, Lu, Lo, Lt, Nl.
 367 // b) Name characters other than Name-start characters must have one of the categories Mc, Me, Mn, Lm, or Nd.
 368 // c) Characters in the compatibility area (i.e. with character code greater than #xF900 and less than #xFFFE) are not allowed in XML names.
 369 // d) Characters which have a font or compatibility decomposition (i.e. those with a &quot;compatibility formatting tag&quot; in field 5 of the database -- marked by field 5 beginning with a &quot;&lt;&quot;) are not allowed.
 370 // e) The following characters are treated as name-start characters rather than name characters, because the property file classifies them as Alphabetic: [#x02BB-#x02C1], #x0559, #x06E5, #x06E6.
 371 // f) Characters #x20DD-#x20E0 are excluded (in accordance with Unicode, section 5.14).
 372 // g) Character #x00B7 is classified as an extender, because the property list so identifies it.
 373 // h) Character #x0387 is added as a name character, because #x00B7 is its canonical equivalent.
 374 // i) Characters &#39;:&#39; and &#39;_&#39; are allowed as name-start characters.
 375 // j) Characters &#39;-&#39; and &#39;.&#39; are allowed as name characters.
 376 //
 377 // It also contains complete tables. If we decide it&#39;s better, we could include those instead of the following code.
 378 
 379 static inline bool isValidNameStart(UChar32 c)
 380 {
 381     // rule (e) above
 382     if ((c &gt;= 0x02BB &amp;&amp; c &lt;= 0x02C1) || c == 0x559 || c == 0x6E5 || c == 0x6E6)
 383         return true;
 384 
 385     // rule (i) above
 386     if (c == &#39;:&#39; || c == &#39;_&#39;)
 387         return true;
 388 
 389     // rules (a) and (f) above
 390     if (!(U_GET_GC_MASK(c) &amp; (U_GC_LL_MASK | U_GC_LU_MASK | U_GC_LO_MASK | U_GC_LT_MASK | U_GC_NL_MASK)))
 391         return false;
 392 
 393     // rule (c) above
 394     if (c &gt;= 0xF900 &amp;&amp; c &lt; 0xFFFE)
 395         return false;
 396 
 397     // rule (d) above
 398 #if PLATFORM(JAVA) // todo tav old code not using icu
 399     DecompositionType decompType = decompositionType(c);
 400     if (decompType == DecompositionFont || decompType == DecompositionCompat)
 401         return false;
 402 #else
 403     int type = u_getIntPropertyValue(c, UCHAR_DECOMPOSITION_TYPE);
 404     if (type == U_DT_FONT || type == U_DT_COMPAT)
 405         return false;
 406 #endif
 407 
 408     return true;
 409 }
 410 
 411 static inline bool isValidNamePart(UChar32 c)
 412 {
 413     // rules (a), (e), and (i) above
 414     if (isValidNameStart(c))
 415         return true;
 416 
 417     // rules (g) and (h) above
 418     if (c == 0x00B7 || c == 0x0387)
 419         return true;
 420 
 421     // rule (j) above
 422     if (c == &#39;-&#39; || c == &#39;.&#39;)
 423         return true;
 424 
 425     // rules (b) and (f) above
 426     if (!(U_GET_GC_MASK(c) &amp; (U_GC_M_MASK | U_GC_LM_MASK | U_GC_ND_MASK)))
 427         return false;
 428 
 429     // rule (c) above
 430     if (c &gt;= 0xF900 &amp;&amp; c &lt; 0xFFFE)
 431         return false;
 432 
 433     // rule (d) above
 434 #if PLATFORM(JAVA) // todo tav old code not using icu
 435     DecompositionType decompType = decompositionType(c);
 436     if (decompType == DecompositionFont || decompType == DecompositionCompat)
 437         return false;
 438 #else
 439     int type = u_getIntPropertyValue(c, UCHAR_DECOMPOSITION_TYPE);
 440     if (type == U_DT_FONT || type == U_DT_COMPAT)
 441         return false;
 442 #endif
 443 
 444     return true;
 445 }
 446 
 447 static Widget* widgetForElement(Element* focusedElement)
 448 {
 449     if (!focusedElement)
 450         return nullptr;
 451     auto* renderer = focusedElement-&gt;renderer();
 452     if (!is&lt;RenderWidget&gt;(renderer))
 453         return nullptr;
 454     return downcast&lt;RenderWidget&gt;(*renderer).widget();
 455 }
 456 
 457 static bool acceptsEditingFocus(const Element&amp; element)
 458 {
 459     ASSERT(element.hasEditableStyle());
 460 
 461     auto* root = element.rootEditableElement();
 462     Frame* frame = element.document().frame();
 463     if (!frame || !root)
 464         return false;
 465 
 466     return frame-&gt;editor().shouldBeginEditing(rangeOfContents(*root).ptr());
 467 }
 468 
 469 static bool canAccessAncestor(const SecurityOrigin&amp; activeSecurityOrigin, Frame* targetFrame)
 470 {
 471     // targetFrame can be 0 when we&#39;re trying to navigate a top-level frame
 472     // that has a 0 opener.
 473     if (!targetFrame)
 474         return false;
 475 
 476     const bool isLocalActiveOrigin = activeSecurityOrigin.isLocal();
 477     for (Frame* ancestorFrame = targetFrame; ancestorFrame; ancestorFrame = ancestorFrame-&gt;tree().parent()) {
 478         Document* ancestorDocument = ancestorFrame-&gt;document();
 479         // FIXME: Should be an ASSERT? Frames should alway have documents.
 480         if (!ancestorDocument)
 481             return true;
 482 
 483         const SecurityOrigin&amp; ancestorSecurityOrigin = ancestorDocument-&gt;securityOrigin();
 484         if (activeSecurityOrigin.canAccess(ancestorSecurityOrigin))
 485             return true;
 486 
 487         // Allow file URL descendant navigation even when allowFileAccessFromFileURLs is false.
 488         // FIXME: It&#39;s a bit strange to special-case local origins here. Should we be doing
 489         // something more general instead?
 490         if (isLocalActiveOrigin &amp;&amp; ancestorSecurityOrigin.isLocal())
 491             return true;
 492     }
 493 
 494     return false;
 495 }
 496 
 497 static void printNavigationErrorMessage(Frame&amp; frame, const URL&amp; activeURL, const char* reason)
 498 {
 499     String message = &quot;Unsafe JavaScript attempt to initiate navigation for frame with URL &#39;&quot; + frame.document()-&gt;url().string() + &quot;&#39; from frame with URL &#39;&quot; + activeURL.string() + &quot;&#39;. &quot; + reason + &quot;\n&quot;;
 500 
 501     // FIXME: should we print to the console of the document performing the navigation instead?
 502     frame.document()-&gt;domWindow()-&gt;printErrorMessage(message);
 503 }
 504 
 505 uint64_t Document::s_globalTreeVersion = 0;
 506 
 507 auto Document::allDocumentsMap() -&gt; DocumentsMap&amp;
 508 {
 509     static NeverDestroyed&lt;DocumentsMap&gt; documents;
 510     return documents;
 511 }
 512 
 513 auto Document::allDocuments() -&gt; DocumentsMap::ValuesIteratorRange
 514 {
 515     return allDocumentsMap().values();
 516 }
 517 
 518 static inline int currentOrientation(Frame* frame)
 519 {
 520 #if ENABLE(ORIENTATION_EVENTS)
 521     if (frame)
 522         return frame-&gt;orientation();
 523 #else
 524     UNUSED_PARAM(frame);
 525 #endif
 526     return 0;
 527 }
 528 
 529 Document::Document(PAL::SessionID sessionID, Frame* frame, const URL&amp; url, unsigned documentClasses, unsigned constructionFlags)
 530     : ContainerNode(*this, CreateDocument)
 531     , TreeScope(*this)
 532     , FrameDestructionObserver(frame)
 533 #if ENABLE(IOS_TOUCH_EVENTS)
 534     , m_touchEventsChangedTimer(*this, &amp;Document::touchEventsChangedTimerFired)
 535 #endif
 536     , m_settings(frame ? Ref&lt;Settings&gt;(frame-&gt;settings()) : Settings::create(nullptr))
 537     , m_quirks(makeUniqueRef&lt;Quirks&gt;(*this))
 538     , m_cachedResourceLoader(m_frame ? Ref&lt;CachedResourceLoader&gt;(m_frame-&gt;loader().activeDocumentLoader()-&gt;cachedResourceLoader()) : CachedResourceLoader::create(nullptr))
 539     , m_domTreeVersion(++s_globalTreeVersion)
 540     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))
 541     , m_extensionStyleSheets(makeUnique&lt;ExtensionStyleSheets&gt;(*this))
 542     , m_visitedLinkState(makeUnique&lt;VisitedLinkState&gt;(*this))
 543     , m_markers(makeUnique&lt;DocumentMarkerController&gt;(*this))
 544     , m_styleRecalcTimer([this] { updateStyleIfNeeded(); })
 545     , m_documentCreationTime(MonotonicTime::now())
 546     , m_scriptRunner(makeUnique&lt;ScriptRunner&gt;(*this))
 547     , m_moduleLoader(makeUnique&lt;ScriptModuleLoader&gt;(*this))
 548 #if ENABLE(XSLT)
 549     , m_applyPendingXSLTransformsTimer(*this, &amp;Document::applyPendingXSLTransformsTimerFired)
 550 #endif
 551     , m_xmlVersion(&quot;1.0&quot;_s)
 552     , m_constantPropertyMap(makeUnique&lt;ConstantPropertyMap&gt;(*this))
 553     , m_documentClasses(documentClasses)
 554     , m_eventQueue(*this)
 555 #if ENABLE(FULLSCREEN_API)
 556     , m_fullscreenManager { makeUniqueRef&lt;FullscreenManager&gt;(*this) }
 557 #endif
 558 #if ENABLE(INTERSECTION_OBSERVER)
 559     , m_intersectionObserversNotifyTimer(*this, &amp;Document::notifyIntersectionObserversTimerFired)
 560     , m_intersectionObserversInitialUpdateTimer(*this, &amp;Document::scheduleTimedRenderingUpdate)
 561 #endif
 562     , m_loadEventDelayTimer(*this, &amp;Document::loadEventDelayTimerFired)
 563 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DEVICE_ORIENTATION)
 564     , m_deviceMotionClient(makeUnique&lt;DeviceMotionClientIOS&gt;())
 565     , m_deviceMotionController(makeUnique&lt;DeviceMotionController&gt;(*m_deviceMotionClient))
 566     , m_deviceOrientationClient(makeUnique&lt;DeviceOrientationClientIOS&gt;())
 567     , m_deviceOrientationController(makeUnique&lt;DeviceOrientationController&gt;(*m_deviceOrientationClient))
 568 #endif
 569     , m_pendingTasksTimer(*this, &amp;Document::pendingTasksTimerFired)
 570     , m_visualUpdatesSuppressionTimer(*this, &amp;Document::visualUpdatesSuppressionTimerFired)
 571     , m_sharedObjectPoolClearTimer(*this, &amp;Document::clearSharedObjectPool)
 572     , m_fontSelector(CSSFontSelector::create(*this))
 573     , m_didAssociateFormControlsTimer(*this, &amp;Document::didAssociateFormControlsTimerFired)
 574     , m_cookieCacheExpiryTimer(*this, &amp;Document::invalidateDOMCookieCache)
 575     , m_socketProvider(page() ? &amp;page()-&gt;socketProvider() : nullptr)
 576     , m_isSynthesized(constructionFlags &amp; Synthesized)
 577     , m_isNonRenderedPlaceholder(constructionFlags &amp; NonRenderedPlaceholder)
 578     , m_orientationNotifier(currentOrientation(frame))
 579     , m_sessionID(sessionID)
 580     , m_identifier(DocumentIdentifier::generate())
 581     , m_undoManager(UndoManager::create(*this))
 582 {
 583     ASSERT(!frame || frame-&gt;sessionID() == m_sessionID);
 584 
 585     auto addResult = allDocumentsMap().add(m_identifier, this);
 586     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 587 
 588     // We depend on the url getting immediately set in subframes, but we
 589     // also depend on the url NOT getting immediately set in opened windows.
 590     // See fast/dom/early-frame-url.html
 591     // and fast/dom/location-new-window-no-crash.html, respectively.
 592     // FIXME: Can/should we unify this behavior?
 593     if ((frame &amp;&amp; frame-&gt;ownerElement()) || !url.isEmpty())
 594         setURL(url);
 595 
 596     m_cachedResourceLoader-&gt;setDocument(this);
 597 
 598     resetLinkColor();
 599     resetVisitedLinkColor();
 600     resetActiveLinkColor();
 601 
 602     initSecurityContext();
 603     initDNSPrefetch();
 604 
 605     m_fontSelector-&gt;registerForInvalidationCallbacks(*this);
 606 
 607     for (auto&amp; nodeListAndCollectionCount : m_nodeListAndCollectionCounts)
 608         nodeListAndCollectionCount = 0;
 609 
 610     InspectorInstrumentation::addEventListenersToNode(*this);
 611 }
 612 
 613 Ref&lt;Document&gt; Document::create(Document&amp; contextDocument)
 614 {
 615     auto document = adoptRef(*new Document(contextDocument.sessionID(), nullptr, URL()));
 616     document-&gt;setContextDocument(contextDocument);
 617     document-&gt;setSecurityOriginPolicy(contextDocument.securityOriginPolicy());
 618     return document;
 619 }
 620 
 621 Ref&lt;Document&gt; Document::createNonRenderedPlaceholder(Frame&amp; frame, const URL&amp; url)
 622 {
 623     return adoptRef(*new Document(frame.sessionID(), &amp;frame, url, DefaultDocumentClass, NonRenderedPlaceholder));
 624 }
 625 
 626 Document::~Document()
 627 {
 628     if (m_logger)
 629         m_logger-&gt;removeObserver(*this);
 630 
 631     ASSERT(allDocumentsMap().contains(m_identifier));
 632     allDocumentsMap().remove(m_identifier);
 633     // We need to remove from the contexts map very early in the destructor so that calling postTask() on this Document from another thread is safe.
 634     removeFromContextsMap();
 635 
 636     ASSERT(!renderView());
 637     ASSERT(m_pageCacheState != InPageCache);
 638     ASSERT(m_ranges.isEmpty());
 639     ASSERT(!m_parentTreeScope);
 640     ASSERT(!m_disabledFieldsetElementsCount);
 641     ASSERT(m_inDocumentShadowRoots.isEmpty());
 642 
 643 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
 644     m_deviceMotionClient-&gt;deviceMotionControllerDestroyed();
 645     m_deviceOrientationClient-&gt;deviceOrientationControllerDestroyed();
 646 #endif
 647 
 648     if (m_templateDocument)
 649         m_templateDocument-&gt;setTemplateDocumentHost(nullptr); // balanced in templateDocument().
 650 
 651     // FIXME: Should we reset m_domWindow when we detach from the Frame?
 652     if (m_domWindow)
 653         m_domWindow-&gt;resetUnlessSuspendedForDocumentSuspension();
 654 
 655     m_scriptRunner = nullptr;
 656     m_moduleLoader = nullptr;
 657 
 658     removeAllEventListeners();
 659 
 660     // Currently we believe that Document can never outlive the parser.
 661     // Although the Document may be replaced synchronously, DocumentParsers
 662     // generally keep at least one reference to an Element which would in turn
 663     // has a reference to the Document.  If you hit this ASSERT, then that
 664     // assumption is wrong.  DocumentParser::detach() should ensure that even
 665     // if the DocumentParser outlives the Document it won&#39;t cause badness.
 666     ASSERT(!m_parser || m_parser-&gt;refCount() == 1);
 667     detachParser();
 668 
 669     if (this == &amp;topDocument())
 670         clearAXObjectCache();
 671 
 672     m_decoder = nullptr;
 673 
 674     if (m_styleSheetList)
 675         m_styleSheetList-&gt;detach();
 676 
 677     extensionStyleSheets().detachFromDocument();
 678 
 679     styleScope().clearResolver(); // We need to destroy CSSFontSelector before destroying m_cachedResourceLoader.
 680     m_fontSelector-&gt;clearDocument();
 681     m_fontSelector-&gt;unregisterForInvalidationCallbacks(*this);
 682 
 683     // It&#39;s possible for multiple Documents to end up referencing the same CachedResourceLoader (e.g., SVGImages
 684     // load the initial empty document and the SVGDocument with the same DocumentLoader).
 685     if (m_cachedResourceLoader-&gt;document() == this)
 686         m_cachedResourceLoader-&gt;setDocument(nullptr);
 687 
 688 #if ENABLE(VIDEO)
 689     stopAllMediaPlayback();
 690 #endif
 691 
 692     // We must call clearRareData() here since a Document class inherits TreeScope
 693     // as well as Node. See a comment on TreeScope.h for the reason.
 694     if (hasRareData())
 695         clearRareData();
 696 
 697     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_listsInvalidatedAtDocument.isEmpty());
 698     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_collectionsInvalidatedAtDocument.isEmpty());
 699     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_svgUseElements.isEmpty());
 700 
 701     for (unsigned count : m_nodeListAndCollectionCounts)
 702         ASSERT_UNUSED(count, !count);
 703 }
 704 
 705 void Document::removedLastRef()
 706 {
 707     ASSERT(!m_deletionHasBegun);
 708     if (m_referencingNodeCount) {
 709         // Node::removedLastRef doesn&#39;t set refCount() to zero because it&#39;s not observable.
 710         // But we need to remember that our refCount reached zero in subsequent calls to decrementReferencingNodeCount().
 711         m_refCountAndParentBit = 0;
 712 
 713         // If removing a child removes the last node reference, we don&#39;t want the scope to be destroyed
 714         // until after removeDetachedChildren returns, so we protect ourselves.
 715         incrementReferencingNodeCount();
 716 
 717         RELEASE_ASSERT(!hasLivingRenderTree());
 718         // We must make sure not to be retaining any of our children through
 719         // these extra pointers or we will create a reference cycle.
 720         m_focusedElement = nullptr;
 721         m_hoveredElement = nullptr;
 722         m_activeElement = nullptr;
 723         m_titleElement = nullptr;
 724         m_documentElement = nullptr;
 725         m_focusNavigationStartingNode = nullptr;
 726         m_userActionElements.clear();
 727 #if ENABLE(FULLSCREEN_API)
 728         m_fullscreenManager-&gt;clear();
 729 #endif
 730         m_associatedFormControls.clear();
 731 
 732         m_fontSelector-&gt;clearDocument();
 733         m_fontSelector-&gt;unregisterForInvalidationCallbacks(*this);
 734 
 735         detachParser();
 736 
 737         // removeDetachedChildren() doesn&#39;t always unregister IDs,
 738         // so tear down scope information up front to avoid having
 739         // stale references in the map.
 740 
 741         destroyTreeScopeData();
 742         removeDetachedChildren();
 743         m_formController = nullptr;
 744 
 745         m_markers-&gt;detach();
 746 
 747         m_cssCanvasElements.clear();
 748 
 749         commonTeardown();
 750 
 751 #ifndef NDEBUG
 752         // We need to do this right now since selfOnlyDeref() can delete this.
 753         m_inRemovedLastRefFunction = false;
 754 #endif
 755         decrementReferencingNodeCount();
 756     } else {
 757 #ifndef NDEBUG
 758         m_inRemovedLastRefFunction = false;
 759         m_deletionHasBegun = true;
 760 #endif
 761         delete this;
 762     }
 763 }
 764 
 765 void Document::commonTeardown()
 766 {
 767     if (svgExtensions())
 768         accessSVGExtensions().pauseAnimations();
 769 
 770     clearScriptedAnimationController();
 771 }
 772 
 773 Element* Document::elementForAccessKey(const String&amp; key)
 774 {
 775     if (key.isEmpty())
 776         return nullptr;
 777     if (!m_accessKeyCache)
 778         buildAccessKeyCache();
 779     return m_accessKeyCache-&gt;get(key);
 780 }
 781 
 782 void Document::buildAccessKeyCache()
 783 {
 784     m_accessKeyCache = makeUnique&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt;([this] {
 785         HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt; map;
 786         for (auto&amp; node : composedTreeDescendants(*this)) {
 787             if (!is&lt;Element&gt;(node))
 788                 continue;
 789             auto&amp; element = downcast&lt;Element&gt;(node);
 790             auto&amp; key = element.attributeWithoutSynchronization(accesskeyAttr);
 791             if (key.isEmpty())
 792                 continue;
 793             map.add(key, &amp;element);
 794         }
 795         return map;
 796     }());
 797 }
 798 
 799 void Document::invalidateAccessKeyCacheSlowCase()
 800 {
 801     m_accessKeyCache = nullptr;
 802 }
 803 
 804 ExceptionOr&lt;SelectorQuery&amp;&gt; Document::selectorQueryForString(const String&amp; selectorString)
 805 {
 806     if (selectorString.isEmpty())
 807         return Exception { SyntaxError };
 808     if (!m_selectorQueryCache)
 809         m_selectorQueryCache = makeUnique&lt;SelectorQueryCache&gt;();
 810     return m_selectorQueryCache-&gt;add(selectorString, *this);
 811 }
 812 
 813 void Document::clearSelectorQueryCache()
 814 {
 815     m_selectorQueryCache = nullptr;
 816 }
 817 
 818 void Document::setReferrerPolicy(ReferrerPolicy referrerPolicy)
 819 {
 820     // Do not override existing referrer policy with the &quot;empty string&quot; one as the &quot;empty string&quot; means we should use
 821     // the policy defined elsewhere.
 822     if (m_referrerPolicy &amp;&amp; referrerPolicy == ReferrerPolicy::EmptyString)
 823         return;
 824 
 825     m_referrerPolicy = referrerPolicy;
 826 }
 827 
 828 MediaQueryMatcher&amp; Document::mediaQueryMatcher()
 829 {
 830     if (!m_mediaQueryMatcher)
 831         m_mediaQueryMatcher = MediaQueryMatcher::create(*this);
 832     return *m_mediaQueryMatcher;
 833 }
 834 
 835 void Document::setCompatibilityMode(DocumentCompatibilityMode mode)
 836 {
 837     if (m_compatibilityModeLocked || mode == m_compatibilityMode)
 838         return;
 839     bool wasInQuirksMode = inQuirksMode();
 840     m_compatibilityMode = mode;
 841 
 842     clearSelectorQueryCache();
 843 
 844     if (inQuirksMode() != wasInQuirksMode) {
 845         // All user stylesheets have to reparse using the different mode.
 846         extensionStyleSheets().clearPageUserSheet();
 847         extensionStyleSheets().invalidateInjectedStyleSheetCache();
 848     }
 849 }
 850 
 851 String Document::compatMode() const
 852 {
 853     return inQuirksMode() ? &quot;BackCompat&quot; : &quot;CSS1Compat&quot;;
 854 }
 855 
 856 void Document::resetLinkColor()
 857 {
 858     m_linkColor = StyleColor::colorFromKeyword(CSSValueWebkitLink, styleColorOptions(nullptr));
 859 }
 860 
 861 void Document::resetVisitedLinkColor()
 862 {
 863     m_visitedLinkColor = StyleColor::colorFromKeyword(CSSValueWebkitLink, styleColorOptions(nullptr) | StyleColor::Options::ForVisitedLink);
 864 }
 865 
 866 void Document::resetActiveLinkColor()
 867 {
 868     m_activeLinkColor = StyleColor::colorFromKeyword(CSSValueWebkitActivelink, styleColorOptions(nullptr));
 869 }
 870 
 871 DOMImplementation&amp; Document::implementation()
 872 {
 873     if (!m_implementation)
 874         m_implementation = makeUnique&lt;DOMImplementation&gt;(*this);
 875     return *m_implementation;
 876 }
 877 
 878 bool Document::hasManifest() const
 879 {
 880     return documentElement() &amp;&amp; documentElement()-&gt;hasTagName(htmlTag) &amp;&amp; documentElement()-&gt;hasAttributeWithoutSynchronization(manifestAttr);
 881 }
 882 
 883 DocumentType* Document::doctype() const
 884 {
 885     for (Node* node = firstChild(); node; node = node-&gt;nextSibling()) {
 886         if (is&lt;DocumentType&gt;(node))
 887             return downcast&lt;DocumentType&gt;(node);
 888     }
 889     return nullptr;
 890 }
 891 
 892 void Document::childrenChanged(const ChildChange&amp; change)
 893 {
 894     ContainerNode::childrenChanged(change);
 895 
 896     // FIXME: Chrome::didReceiveDocType() used to be called only when the doctype changed. We need to check the
 897     // impact of calling this systematically. If the overhead is negligible, we need to rename didReceiveDocType,
 898     // otherwise, we need to detect the doc type changes before updating the viewport.
 899     if (Page* page = this-&gt;page())
 900         page-&gt;chrome().didReceiveDocType(*frame());
 901 
 902     Element* newDocumentElement = childrenOfType&lt;Element&gt;(*this).first();
 903     if (newDocumentElement == m_documentElement)
 904         return;
 905     m_documentElement = newDocumentElement;
 906     // The root style used for media query matching depends on the document element.
 907     styleScope().clearResolver();
 908 }
 909 
 910 static ALWAYS_INLINE Ref&lt;HTMLElement&gt; createUpgradeCandidateElement(Document&amp; document, const QualifiedName&amp; name)
 911 {
 912     if (!RuntimeEnabledFeatures::sharedFeatures().customElementsEnabled()
 913         || Document::validateCustomElementName(name.localName()) != CustomElementNameValidationStatus::Valid)
 914         return HTMLUnknownElement::create(name, document);
 915 
 916     auto element = HTMLElement::create(name, document);
 917     element-&gt;setIsCustomElementUpgradeCandidate();
 918     return element;
 919 }
 920 
 921 static ALWAYS_INLINE Ref&lt;HTMLElement&gt; createUpgradeCandidateElement(Document&amp; document, const AtomString&amp; localName)
 922 {
 923     return createUpgradeCandidateElement(document, QualifiedName { nullAtom(), localName, xhtmlNamespaceURI });
 924 }
 925 
 926 static inline bool isValidHTMLElementName(const AtomString&amp; localName)
 927 {
 928     return Document::isValidName(localName);
 929 }
 930 
 931 static inline bool isValidHTMLElementName(const QualifiedName&amp; name)
 932 {
 933     return Document::isValidName(name.localName());
 934 }
 935 
 936 template&lt;typename NameType&gt;
 937 static ExceptionOr&lt;Ref&lt;Element&gt;&gt; createHTMLElementWithNameValidation(Document&amp; document, const NameType&amp; name)
 938 {
 939     auto element = HTMLElementFactory::createKnownElement(name, document);
 940     if (LIKELY(element))
 941         return Ref&lt;Element&gt; { element.releaseNonNull() };
 942 
 943     if (auto* window = document.domWindow()) {
 944         auto* registry = window-&gt;customElementRegistry();
 945         if (UNLIKELY(registry)) {
 946             if (auto* elementInterface = registry-&gt;findInterface(name))
 947                 return elementInterface-&gt;constructElementWithFallback(document, name);
 948         }
 949     }
 950 
 951     if (UNLIKELY(!isValidHTMLElementName(name)))
 952         return Exception { InvalidCharacterError };
 953 
 954     return Ref&lt;Element&gt; { createUpgradeCandidateElement(document, name) };
 955 }
 956 
 957 ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementForBindings(const AtomString&amp; name)
 958 {
 959     if (isHTMLDocument())
 960         return createHTMLElementWithNameValidation(*this, name.convertToASCIILowercase());
 961 
 962     if (isXHTMLDocument())
 963         return createHTMLElementWithNameValidation(*this, name);
 964 
 965     if (!isValidName(name))
 966         return Exception { InvalidCharacterError };
 967 
 968     return createElement(QualifiedName(nullAtom(), name, nullAtom()), false);
 969 }
 970 
 971 Ref&lt;DocumentFragment&gt; Document::createDocumentFragment()
 972 {
 973     return DocumentFragment::create(document());
 974 }
 975 
 976 Ref&lt;Text&gt; Document::createTextNode(const String&amp; data)
 977 {
 978     return Text::create(*this, data);
 979 }
 980 
 981 Ref&lt;Comment&gt; Document::createComment(const String&amp; data)
 982 {
 983     return Comment::create(*this, data);
 984 }
 985 
 986 ExceptionOr&lt;Ref&lt;CDATASection&gt;&gt; Document::createCDATASection(const String&amp; data)
 987 {
 988     if (isHTMLDocument())
 989         return Exception { NotSupportedError };
 990     return CDATASection::create(*this, data);
 991 }
 992 
 993 ExceptionOr&lt;Ref&lt;ProcessingInstruction&gt;&gt; Document::createProcessingInstruction(const String&amp; target, const String&amp; data)
 994 {
 995     if (!isValidName(target))
 996         return Exception { InvalidCharacterError };
 997 
 998     if (data.contains(&quot;?&gt;&quot;))
 999         return Exception { InvalidCharacterError };
1000 
1001     return ProcessingInstruction::create(*this, target, data);
1002 }
1003 
1004 Ref&lt;Text&gt; Document::createEditingTextNode(const String&amp; text)
1005 {
1006     return Text::createEditingText(*this, text);
1007 }
1008 
1009 Ref&lt;CSSStyleDeclaration&gt; Document::createCSSStyleDeclaration()
1010 {
1011     Ref&lt;MutableStyleProperties&gt; propertySet(MutableStyleProperties::create());
1012     return propertySet-&gt;ensureCSSStyleDeclaration();
1013 }
1014 
1015 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Document::importNode(Node&amp; nodeToImport, bool deep)
1016 {
1017     switch (nodeToImport.nodeType()) {
1018     case DOCUMENT_FRAGMENT_NODE:
1019         if (nodeToImport.isShadowRoot())
1020             break;
1021         FALLTHROUGH;
1022     case ELEMENT_NODE:
1023     case TEXT_NODE:
1024     case CDATA_SECTION_NODE:
1025     case PROCESSING_INSTRUCTION_NODE:
1026     case COMMENT_NODE:
1027         return nodeToImport.cloneNodeInternal(document(), deep ? CloningOperation::Everything : CloningOperation::OnlySelf);
1028 
1029     case ATTRIBUTE_NODE: {
1030         auto&amp; attribute = downcast&lt;Attr&gt;(nodeToImport);
1031         return Ref&lt;Node&gt; { Attr::create(*this, attribute.qualifiedName(), attribute.value()) };
1032     }
1033     case DOCUMENT_NODE: // Can&#39;t import a document into another document.
1034     case DOCUMENT_TYPE_NODE: // FIXME: Support cloning a DocumentType node per DOM4.
1035         break;
1036     }
1037 
1038     return Exception { NotSupportedError };
1039 }
1040 
1041 
1042 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Document::adoptNode(Node&amp; source)
1043 {
1044     EventQueueScope scope;
1045 
1046     switch (source.nodeType()) {
1047     case DOCUMENT_NODE:
1048         return Exception { NotSupportedError };
1049     case ATTRIBUTE_NODE: {
1050         auto&amp; attr = downcast&lt;Attr&gt;(source);
1051         if (auto* element = attr.ownerElement()) {
1052             auto result = element-&gt;removeAttributeNode(attr);
1053             if (result.hasException())
1054                 return result.releaseException();
1055         }
1056         break;
1057     }
1058     default:
1059         if (source.isShadowRoot()) {
1060             // ShadowRoot cannot disconnect itself from the host node.
1061             return Exception { HierarchyRequestError };
1062         }
1063         if (is&lt;HTMLFrameOwnerElement&gt;(source)) {
1064             auto&amp; frameOwnerElement = downcast&lt;HTMLFrameOwnerElement&gt;(source);
1065             if (frame() &amp;&amp; frame()-&gt;tree().isDescendantOf(frameOwnerElement.contentFrame()))
1066                 return Exception { HierarchyRequestError };
1067         }
1068         auto result = source.remove();
1069         if (result.hasException())
1070             return result.releaseException();
1071         RELEASE_ASSERT(!source.isConnected());
1072         RELEASE_ASSERT(!source.parentNode());
1073     }
1074 
1075     source.setTreeScopeRecursively(*this);
1076 
1077     return Ref&lt;Node&gt; { source };
1078 }
1079 
1080 bool Document::hasValidNamespaceForElements(const QualifiedName&amp; qName)
1081 {
1082     // These checks are from DOM Core Level 2, createElementNS
1083     // http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-DocCrElNS
1084     if (!qName.prefix().isEmpty() &amp;&amp; qName.namespaceURI().isNull()) // createElementNS(null, &quot;html:div&quot;)
1085         return false;
1086     if (qName.prefix() == xmlAtom() &amp;&amp; qName.namespaceURI() != XMLNames::xmlNamespaceURI) // createElementNS(&quot;http://www.example.com&quot;, &quot;xml:lang&quot;)
1087         return false;
1088 
1089     // Required by DOM Level 3 Core and unspecified by DOM Level 2 Core:
1090     // http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-DocCrElNS
1091     // createElementNS(&quot;http://www.w3.org/2000/xmlns/&quot;, &quot;foo:bar&quot;), createElementNS(null, &quot;xmlns:bar&quot;), createElementNS(null, &quot;xmlns&quot;)
1092     if (qName.prefix() == xmlnsAtom() || (qName.prefix().isEmpty() &amp;&amp; qName.localName() == xmlnsAtom()))
1093         return qName.namespaceURI() == XMLNSNames::xmlnsNamespaceURI;
1094     return qName.namespaceURI() != XMLNSNames::xmlnsNamespaceURI;
1095 }
1096 
1097 bool Document::hasValidNamespaceForAttributes(const QualifiedName&amp; qName)
1098 {
1099     return hasValidNamespaceForElements(qName);
1100 }
1101 
1102 static Ref&lt;HTMLElement&gt; createFallbackHTMLElement(Document&amp; document, const QualifiedName&amp; name)
1103 {
1104     if (auto* window = document.domWindow()) {
1105         auto* registry = window-&gt;customElementRegistry();
1106         if (UNLIKELY(registry)) {
1107             if (auto* elementInterface = registry-&gt;findInterface(name)) {
1108                 auto element = HTMLElement::create(name, document);
1109                 element-&gt;enqueueToUpgrade(*elementInterface);
1110                 return element;
1111             }
1112         }
1113     }
1114     // FIXME: Should we also check the equality of prefix between the custom element and name?
1115     return createUpgradeCandidateElement(document, name);
1116 }
1117 
1118 // FIXME: This should really be in a possible ElementFactory class.
1119 Ref&lt;Element&gt; Document::createElement(const QualifiedName&amp; name, bool createdByParser)
1120 {
1121     RefPtr&lt;Element&gt; element;
1122 
1123     // FIXME: Use registered namespaces and look up in a hash to find the right factory.
1124     if (name.namespaceURI() == xhtmlNamespaceURI) {
1125         element = HTMLElementFactory::createKnownElement(name, *this, nullptr, createdByParser);
1126         if (UNLIKELY(!element))
1127             element = createFallbackHTMLElement(*this, name);
1128     } else if (name.namespaceURI() == SVGNames::svgNamespaceURI)
1129         element = SVGElementFactory::createElement(name, *this, createdByParser);
1130 #if ENABLE(MATHML)
1131     else if (name.namespaceURI() == MathMLNames::mathmlNamespaceURI)
1132         element = MathMLElementFactory::createElement(name, *this, createdByParser);
1133 #endif
1134 
1135     if (element)
1136         m_sawElementsInKnownNamespaces = true;
1137     else
1138         element = Element::create(name, document());
1139 
1140     // &lt;image&gt; uses imgTag so we need a special rule.
1141     ASSERT((name.matches(imageTag) &amp;&amp; element-&gt;tagQName().matches(imgTag) &amp;&amp; element-&gt;tagQName().prefix() == name.prefix()) || name == element-&gt;tagQName());
1142 
1143     return element.releaseNonNull();
1144 }
1145 
1146 // https://html.spec.whatwg.org/#valid-custom-element-name
1147 
1148 struct UnicodeCodePointRange {
1149     UChar32 minimum;
1150     UChar32 maximum;
1151 };
1152 
1153 #if !ASSERT_DISABLED
1154 
1155 static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, const UnicodeCodePointRange&amp; b)
1156 {
1157     ASSERT(a.minimum &lt;= a.maximum);
1158     ASSERT(b.minimum &lt;= b.maximum);
1159     return a.maximum &lt; b.minimum;
1160 }
1161 
1162 #endif
1163 
1164 static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, UChar32 b)
1165 {
1166     ASSERT(a.minimum &lt;= a.maximum);
1167     return a.maximum &lt; b;
1168 }
1169 
1170 static inline bool operator&lt;(UChar32 a, const UnicodeCodePointRange&amp; b)
1171 {
1172     ASSERT(b.minimum &lt;= b.maximum);
1173     return a &lt; b.minimum;
1174 }
1175 
1176 static inline bool isPotentialCustomElementNameCharacter(UChar32 character)
1177 {
1178     static const UnicodeCodePointRange ranges[] = {
1179         { &#39;-&#39;, &#39;.&#39; },
1180         { &#39;0&#39;, &#39;9&#39; },
1181         { &#39;_&#39;, &#39;_&#39; },
1182         { &#39;a&#39;, &#39;z&#39; },
1183         { 0xB7, 0xB7 },
1184         { 0xC0, 0xD6 },
1185         { 0xD8, 0xF6 },
1186         { 0xF8, 0x37D },
1187         { 0x37F, 0x1FFF },
1188         { 0x200C, 0x200D },
1189         { 0x203F, 0x2040 },
1190         { 0x2070, 0x218F },
1191         { 0x2C00, 0x2FEF },
1192         { 0x3001, 0xD7FF },
1193         { 0xF900, 0xFDCF },
1194         { 0xFDF0, 0xFFFD },
1195         { 0x10000, 0xEFFFF },
1196     };
1197 
1198     ASSERT(std::is_sorted(std::begin(ranges), std::end(ranges)));
1199     return std::binary_search(std::begin(ranges), std::end(ranges), character);
1200 }
1201 
1202 CustomElementNameValidationStatus Document::validateCustomElementName(const AtomString&amp; localName)
1203 {
1204     if (!isASCIILower(localName[0]))
1205         return CustomElementNameValidationStatus::FirstCharacterIsNotLowercaseASCIILetter;
1206 
1207     bool containsHyphen = false;
1208     for (auto character : StringView(localName).codePoints()) {
1209         if (isASCIIUpper(character))
1210             return CustomElementNameValidationStatus::ContainsUppercaseASCIILetter;
1211         if (!isPotentialCustomElementNameCharacter(character))
1212             return CustomElementNameValidationStatus::ContainsDisallowedCharacter;
1213         if (character == &#39;-&#39;)
1214             containsHyphen = true;
1215     }
1216 
1217     if (!containsHyphen)
1218         return CustomElementNameValidationStatus::ContainsNoHyphen;
1219 
1220 #if ENABLE(MATHML)
1221     const auto&amp; annotationXmlLocalName = MathMLNames::annotation_xmlTag-&gt;localName();
1222 #else
1223     static NeverDestroyed&lt;const AtomString&gt; annotationXmlLocalName(&quot;annotation-xml&quot;, AtomString::ConstructFromLiteral);
1224 #endif
1225 
1226     if (localName == SVGNames::color_profileTag-&gt;localName()
1227         || localName == SVGNames::font_faceTag-&gt;localName()
1228         || localName == SVGNames::font_face_formatTag-&gt;localName()
1229         || localName == SVGNames::font_face_nameTag-&gt;localName()
1230         || localName == SVGNames::font_face_srcTag-&gt;localName()
1231         || localName == SVGNames::font_face_uriTag-&gt;localName()
1232         || localName == SVGNames::missing_glyphTag-&gt;localName()
1233         || localName == annotationXmlLocalName)
1234         return CustomElementNameValidationStatus::ConflictsWithStandardElementName;
1235 
1236     return CustomElementNameValidationStatus::Valid;
1237 }
1238 
1239 ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName)
1240 {
1241     auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
1242     if (parseResult.hasException())
1243         return parseResult.releaseException();
1244     QualifiedName parsedName { parseResult.releaseReturnValue() };
1245     if (!hasValidNamespaceForElements(parsedName))
1246         return Exception { NamespaceError };
1247 
1248     if (parsedName.namespaceURI() == xhtmlNamespaceURI)
1249         return createHTMLElementWithNameValidation(*this, parsedName);
1250 
1251     return createElement(parsedName, false);
1252 }
1253 
1254 void Document::setReadyState(ReadyState readyState)
1255 {
1256     if (readyState == m_readyState)
1257         return;
1258 
1259     switch (readyState) {
1260     case Loading:
1261         if (!m_documentTiming.domLoading)
1262             m_documentTiming.domLoading = MonotonicTime::now();
1263         break;
1264     case Interactive:
1265         if (!m_documentTiming.domInteractive)
1266             m_documentTiming.domInteractive = MonotonicTime::now();
1267         break;
1268     case Complete:
1269         if (!m_documentTiming.domComplete)
1270             m_documentTiming.domComplete = MonotonicTime::now();
1271         break;
1272     }
1273 
1274     m_readyState = readyState;
1275     dispatchEvent(Event::create(eventNames().readystatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
1276 
1277     if (settings().suppressesIncrementalRendering())
1278         setVisualUpdatesAllowed(readyState);
1279 }
1280 
1281 void Document::setVisualUpdatesAllowed(ReadyState readyState)
1282 {
1283     ASSERT(settings().suppressesIncrementalRendering());
1284     switch (readyState) {
1285     case Loading:
1286         ASSERT(!m_visualUpdatesSuppressionTimer.isActive());
1287         ASSERT(m_visualUpdatesAllowed);
1288         setVisualUpdatesAllowed(false);
1289         break;
1290     case Interactive:
1291         ASSERT(m_visualUpdatesSuppressionTimer.isActive() || m_visualUpdatesAllowed);
1292         break;
1293     case Complete:
1294         if (m_visualUpdatesSuppressionTimer.isActive()) {
1295             ASSERT(!m_visualUpdatesAllowed);
1296 
1297             if (view() &amp;&amp; !view()-&gt;visualUpdatesAllowedByClient())
1298                 return;
1299 
1300             setVisualUpdatesAllowed(true);
1301         } else
1302             ASSERT(m_visualUpdatesAllowed);
1303         break;
1304     }
1305 }
1306 
1307 void Document::setVisualUpdatesAllowed(bool visualUpdatesAllowed)
1308 {
1309     if (m_visualUpdatesAllowed == visualUpdatesAllowed)
1310         return;
1311 
1312     m_visualUpdatesAllowed = visualUpdatesAllowed;
1313 
1314     if (visualUpdatesAllowed)
1315         m_visualUpdatesSuppressionTimer.stop();
1316     else
1317         m_visualUpdatesSuppressionTimer.startOneShot(1_s * settings().incrementalRenderingSuppressionTimeoutInSeconds());
1318 
1319     if (!visualUpdatesAllowed)
1320         return;
1321 
1322     RefPtr&lt;FrameView&gt; frameView = view();
1323     bool needsLayout = frameView &amp;&amp; renderView() &amp;&amp; (frameView-&gt;layoutContext().isLayoutPending() || renderView()-&gt;needsLayout());
1324     if (needsLayout)
1325         updateLayout();
1326 
1327     if (Page* page = this-&gt;page()) {
1328         if (frame()-&gt;isMainFrame()) {
1329             frameView-&gt;addPaintPendingMilestones(DidFirstPaintAfterSuppressedIncrementalRendering);
1330             if (page-&gt;requestedLayoutMilestones() &amp; DidFirstLayoutAfterSuppressedIncrementalRendering)
1331                 frame()-&gt;loader().didReachLayoutMilestone(DidFirstLayoutAfterSuppressedIncrementalRendering);
1332         }
1333     }
1334 
1335     if (frameView)
1336         frameView-&gt;updateCompositingLayersAfterLayout();
1337 
1338     if (RenderView* renderView = this-&gt;renderView())
1339         renderView-&gt;repaintViewAndCompositedLayers();
1340 
1341     if (Frame* frame = this-&gt;frame())
1342         frame-&gt;loader().forcePageTransitionIfNeeded();
1343 }
1344 
1345 void Document::visualUpdatesSuppressionTimerFired()
1346 {
1347     ASSERT(!m_visualUpdatesAllowed);
1348 
1349     // If the client is extending the visual update suppression period explicitly, the
1350     // watchdog should not re-enable visual updates itself, but should wait for the client.
1351     if (view() &amp;&amp; !view()-&gt;visualUpdatesAllowedByClient())
1352         return;
1353 
1354     setVisualUpdatesAllowed(true);
1355 }
1356 
1357 void Document::setVisualUpdatesAllowedByClient(bool visualUpdatesAllowedByClient)
1358 {
1359     // We should only re-enable visual updates if ReadyState is Completed or the watchdog timer has fired,
1360     // both of which we can determine by looking at the timer.
1361 
1362     if (visualUpdatesAllowedByClient &amp;&amp; !m_visualUpdatesSuppressionTimer.isActive() &amp;&amp; !visualUpdatesAllowed())
1363         setVisualUpdatesAllowed(true);
1364 }
1365 
1366 String Document::characterSetWithUTF8Fallback() const
1367 {
1368     AtomString name = encoding();
1369     if (!name.isNull())
1370         return name;
1371     return UTF8Encoding().domName();
1372 }
1373 
1374 String Document::defaultCharsetForLegacyBindings() const
1375 {
1376     if (!frame())
1377         UTF8Encoding().domName();
1378     return settings().defaultTextEncodingName();
1379 }
1380 
1381 void Document::setCharset(const String&amp; charset)
1382 {
1383     if (!decoder())
1384         return;
1385     decoder()-&gt;setEncoding(charset, TextResourceDecoder::UserChosenEncoding);
1386 }
1387 
1388 void Document::setContentLanguage(const String&amp; language)
1389 {
1390     if (m_contentLanguage == language)
1391         return;
1392     m_contentLanguage = language;
1393 
1394     // Recalculate style so language is used when selecting the initial font.
1395     m_styleScope-&gt;didChangeStyleSheetEnvironment();
1396 }
1397 
1398 ExceptionOr&lt;void&gt; Document::setXMLVersion(const String&amp; version)
1399 {
1400     if (!XMLDocumentParser::supportsXMLVersion(version))
1401         return Exception { NotSupportedError };
1402 
1403     m_xmlVersion = version;
1404     return { };
1405 }
1406 
1407 void Document::setXMLStandalone(bool standalone)
1408 {
1409     m_xmlStandalone = standalone ? StandaloneStatus::Standalone : StandaloneStatus::NotStandalone;
1410 }
1411 
1412 void Document::setDocumentURI(const String&amp; uri)
1413 {
1414     // This property is read-only from JavaScript, but writable from Objective-C.
1415     m_documentURI = uri;
1416     updateBaseURL();
1417 }
1418 
1419 void Document::setContent(const String&amp; content)
1420 {
1421     open();
1422     // FIXME: This should probably use insert(), but that&#39;s (intentionally)
1423     // not implemented for the XML parser as it&#39;s normally synonymous with
1424     // document.write(). append() will end up yielding, but close() will
1425     // pump the tokenizer syncrhonously and finish the parse.
1426     m_parser-&gt;append(content.impl());
1427     close();
1428 }
1429 
1430 String Document::suggestedMIMEType() const
1431 {
1432     if (isXHTMLDocument())
1433         return &quot;application/xhtml+xml&quot;_s;
1434     if (isSVGDocument())
1435         return &quot;image/svg+xml&quot;_s;
1436     if (xmlStandalone())
1437         return &quot;text/xml&quot;_s;
1438     if (isHTMLDocument())
1439         return &quot;text/html&quot;_s;
1440     if (DocumentLoader* loader = this-&gt;loader())
1441         return loader-&gt;responseMIMEType();
1442     return String();
1443 }
1444 
1445 void Document::overrideMIMEType(const String&amp; mimeType)
1446 {
1447     m_overriddenMIMEType = mimeType;
1448 }
1449 
1450 String Document::contentType() const
1451 {
1452     if (!m_overriddenMIMEType.isNull())
1453         return m_overriddenMIMEType;
1454 
1455     if (DocumentLoader* documentLoader = loader())
1456         return documentLoader-&gt;currentContentType();
1457 
1458     String mimeType = suggestedMIMEType();
1459     if (!mimeType.isNull())
1460         return mimeType;
1461 
1462     return &quot;application/xml&quot;_s;
1463 }
1464 
1465 RefPtr&lt;Range&gt; Document::caretRangeFromPoint(int x, int y)
1466 {
1467     return caretRangeFromPoint(LayoutPoint(x, y));
1468 }
1469 
1470 RefPtr&lt;Range&gt; Document::caretRangeFromPoint(const LayoutPoint&amp; clientPoint)
1471 {
1472     if (!hasLivingRenderTree())
1473         return nullptr;
1474 
1475     LayoutPoint localPoint;
1476     Node* node = nodeFromPoint(clientPoint, &amp;localPoint);
1477     if (!node)
1478         return nullptr;
1479 
1480     RenderObject* renderer = node-&gt;renderer();
1481     if (!renderer)
1482         return nullptr;
1483     Position rangeCompliantPosition = renderer-&gt;positionForPoint(localPoint).parentAnchoredEquivalent();
1484     if (rangeCompliantPosition.isNull())
1485         return nullptr;
1486 
1487     unsigned offset = rangeCompliantPosition.offsetInContainerNode();
1488     node = &amp;retargetToScope(*rangeCompliantPosition.containerNode());
1489     if (node != rangeCompliantPosition.containerNode())
1490         offset = 0;
1491 
1492     return Range::create(*this, node, offset, node, offset);
1493 }
1494 
1495 bool Document::isBodyPotentiallyScrollable(HTMLBodyElement&amp; body)
1496 {
1497     // See https://www.w3.org/TR/cssom-view-1/#potentially-scrollable.
1498     // An element is potentially scrollable if all of the following conditions are true:
1499     // - The element has an associated CSS layout box.
1500     // - The element is not the HTML body element, or it is and the root element&#39;s used value of the
1501     //   overflow-x or overflow-y properties is not visible.
1502     // - The element&#39;s used value of the overflow-x or overflow-y properties is not visible.
1503     //
1504     // FIXME: We should use RenderObject::hasOverflowClip() instead of Element::computedStyle() but
1505     // the used values are currently not correctly updated. See https://webkit.org/b/182292.
1506     return body.renderer()
1507         &amp;&amp; documentElement()-&gt;computedStyle()
1508         &amp;&amp; !documentElement()-&gt;computedStyle()-&gt;isOverflowVisible()
1509         &amp;&amp; body.computedStyle()
1510         &amp;&amp; !body.computedStyle()-&gt;isOverflowVisible();
1511 }
1512 
1513 Element* Document::scrollingElementForAPI()
1514 {
1515     if (inQuirksMode() &amp;&amp; settings().CSSOMViewScrollingAPIEnabled())
1516         updateLayoutIgnorePendingStylesheets();
1517     return scrollingElement();
1518 }
1519 
1520 Element* Document::scrollingElement()
1521 {
1522     if (settings().CSSOMViewScrollingAPIEnabled()) {
1523         // See https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement.
1524         // The scrollingElement attribute, on getting, must run these steps:
1525         // 1. If the Document is in quirks mode, follow these substeps:
1526         if (inQuirksMode()) {
1527             auto* firstBody = body();
1528             // 1. If the HTML body element exists, and it is not potentially scrollable, return the
1529             // HTML body element and abort these steps.
1530             if (firstBody &amp;&amp; !isBodyPotentiallyScrollable(*firstBody))
1531                 return firstBody;
1532 
1533             // 2. Return null and abort these steps.
1534             return nullptr;
1535         }
1536 
1537         // 2. If there is a root element, return the root element and abort these steps.
1538         // 3. Return null.
1539         return documentElement();
1540     }
1541 
1542     return body();
1543 }
1544 
1545 static String canonicalizedTitle(Document&amp; document, const String&amp; title)
1546 {
1547     // Collapse runs of HTML spaces into single space characters.
1548     // Strip leading and trailing spaces.
1549     // Replace backslashes with currency symbols.
1550 
1551     StringBuilder builder;
1552 
1553     auto* decoder = document.decoder();
1554     auto backslashAsCurrencySymbol = decoder ? decoder-&gt;encoding().backslashAsCurrencySymbol() : &#39;\\&#39;;
1555 
1556     bool previousCharacterWasHTMLSpace = false;
1557     for (auto character : StringView { title }.codeUnits()) {
1558         if (isHTMLSpace(character))
1559             previousCharacterWasHTMLSpace = true;
1560         else {
1561             if (character == &#39;\\&#39;)
1562                 character = backslashAsCurrencySymbol;
1563             if (previousCharacterWasHTMLSpace &amp;&amp; !builder.isEmpty())
1564                 builder.append(&#39; &#39;);
1565             builder.append(character);
1566             previousCharacterWasHTMLSpace = false;
1567         }
1568     }
1569 
1570     return builder == title ? title : builder.toString();
1571 }
1572 
1573 void Document::updateTitle(const StringWithDirection&amp; title)
1574 {
1575     if (m_rawTitle == title)
1576         return;
1577 
1578     m_rawTitle = title;
1579 
1580     m_title.string = canonicalizedTitle(*this, title.string);
1581     m_title.direction = title.direction;
1582 
1583     if (auto* loader = this-&gt;loader())
1584         loader-&gt;setTitle(m_title);
1585 }
1586 
1587 void Document::updateTitleFromTitleElement()
1588 {
1589     if (!m_titleElement) {
1590         updateTitle({ });
1591         return;
1592     }
1593 
1594     if (is&lt;HTMLTitleElement&gt;(*m_titleElement))
1595         updateTitle(downcast&lt;HTMLTitleElement&gt;(*m_titleElement).textWithDirection());
1596     else if (is&lt;SVGTitleElement&gt;(*m_titleElement)) {
1597         // FIXME: Does the SVG title element have a text direction?
1598         updateTitle({ downcast&lt;SVGTitleElement&gt;(*m_titleElement).textContent(), TextDirection::LTR });
1599     }
1600 }
1601 
1602 void Document::setTitle(const String&amp; title)
1603 {
1604     auto* element = documentElement();
1605     if (is&lt;SVGSVGElement&gt;(element)) {
1606         if (!m_titleElement) {
1607             m_titleElement = SVGTitleElement::create(SVGNames::titleTag, *this);
1608             element-&gt;insertBefore(*m_titleElement, element-&gt;firstChild());
1609         }
1610         m_titleElement-&gt;setTextContent(title);
1611     } else if (is&lt;HTMLElement&gt;(element)) {
1612         if (!m_titleElement) {
1613             auto* headElement = head();
1614             if (!headElement)
1615                 return;
1616             m_titleElement = HTMLTitleElement::create(HTMLNames::titleTag, *this);
1617             headElement-&gt;appendChild(*m_titleElement);
1618         }
1619         m_titleElement-&gt;setTextContent(title);
1620     }
1621 }
1622 
1623 template&lt;typename&gt; struct TitleTraits;
1624 
1625 template&lt;&gt; struct TitleTraits&lt;HTMLTitleElement&gt; {
1626     static bool isInEligibleLocation(HTMLTitleElement&amp; element) { return element.isConnected() &amp;&amp; !element.isInShadowTree(); }
1627     static HTMLTitleElement* findTitleElement(Document&amp; document) { return descendantsOfType&lt;HTMLTitleElement&gt;(document).first(); }
1628 };
1629 
1630 template&lt;&gt; struct TitleTraits&lt;SVGTitleElement&gt; {
1631     static bool isInEligibleLocation(SVGTitleElement&amp; element) { return element.parentNode() == element.document().documentElement(); }
1632     static SVGTitleElement* findTitleElement(Document&amp; document) { return childrenOfType&lt;SVGTitleElement&gt;(*document.documentElement()).first(); }
1633 };
1634 
1635 template&lt;typename TitleElement&gt; Element* selectNewTitleElement(Document&amp; document, Element* oldTitleElement, Element&amp; changingTitleElement)
1636 {
1637     using Traits = TitleTraits&lt;TitleElement&gt;;
1638 
1639     if (!is&lt;TitleElement&gt;(changingTitleElement)) {
1640         ASSERT(oldTitleElement == Traits::findTitleElement(document));
1641         return oldTitleElement;
1642     }
1643 
1644     if (oldTitleElement)
1645         return Traits::findTitleElement(document);
1646 
1647     // Optimized common case: We have no title element yet.
1648     // We can figure out which title element should be used without searching.
1649     bool isEligible = Traits::isInEligibleLocation(downcast&lt;TitleElement&gt;(changingTitleElement));
1650     auto* newTitleElement = isEligible ? &amp;changingTitleElement : nullptr;
1651     ASSERT(newTitleElement == Traits::findTitleElement(document));
1652     return newTitleElement;
1653 }
1654 
1655 void Document::updateTitleElement(Element&amp; changingTitleElement)
1656 {
1657     // Most documents use HTML title rules.
1658     // Documents with SVG document elements use SVG title rules.
1659     auto selectTitleElement = is&lt;SVGSVGElement&gt;(documentElement())
1660         ? selectNewTitleElement&lt;SVGTitleElement&gt; : selectNewTitleElement&lt;HTMLTitleElement&gt;;
1661     auto newTitleElement = selectTitleElement(*this, m_titleElement.get(), changingTitleElement);
1662     if (m_titleElement == newTitleElement)
1663         return;
1664     m_titleElement = newTitleElement;
1665     updateTitleFromTitleElement();
1666 }
1667 
1668 void Document::titleElementAdded(Element&amp; titleElement)
1669 {
1670     if (m_titleElement == &amp;titleElement)
1671         return;
1672 
1673     updateTitleElement(titleElement);
1674 }
1675 
1676 void Document::titleElementRemoved(Element&amp; titleElement)
1677 {
1678     if (m_titleElement != &amp;titleElement)
1679         return;
1680 
1681     updateTitleElement(titleElement);
1682 }
1683 
1684 void Document::titleElementTextChanged(Element&amp; titleElement)
1685 {
1686     if (m_titleElement != &amp;titleElement)
1687         return;
1688 
1689     updateTitleFromTitleElement();
1690 }
1691 
1692 void Document::registerForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp; client)
1693 {
1694     m_visibilityStateCallbackClients.add(&amp;client);
1695 }
1696 
1697 void Document::unregisterForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp; client)
1698 {
1699     m_visibilityStateCallbackClients.remove(&amp;client);
1700 }
1701 
1702 void Document::visibilityStateChanged()
1703 {
1704     enqueueDocumentEvent(Event::create(eventNames().visibilitychangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
1705     for (auto* client : m_visibilityStateCallbackClients)
1706         client-&gt;visibilityStateChanged();
1707 
1708     notifyMediaCaptureOfVisibilityChanged();
1709 }
1710 
1711 VisibilityState Document::visibilityState() const
1712 {
1713     // The visibility of the document is inherited from the visibility of the
1714     // page. If there is no page associated with the document, we will assume
1715     // that the page is hidden, as specified by the spec:
1716     // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/PageVisibility/Overview.html#dom-document-hidden
1717     if (!m_frame || !m_frame-&gt;page())
1718         return VisibilityState::Hidden;
1719     return m_frame-&gt;page()-&gt;visibilityState();
1720 }
1721 
1722 bool Document::hidden() const
1723 {
1724     return visibilityState() != VisibilityState::Visible;
1725 }
1726 
1727 #if ENABLE(VIDEO)
1728 
1729 void Document::registerForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp; element)
1730 {
1731     m_allowsMediaDocumentInlinePlaybackElements.add(&amp;element);
1732 }
1733 
1734 void Document::unregisterForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp; element)
1735 {
1736     m_allowsMediaDocumentInlinePlaybackElements.remove(&amp;element);
1737 }
1738 
1739 void Document::allowsMediaDocumentInlinePlaybackChanged()
1740 {
1741     for (auto* element : m_allowsMediaDocumentInlinePlaybackElements)
1742         element-&gt;allowsMediaDocumentInlinePlaybackChanged();
1743 }
1744 
1745 void Document::stopAllMediaPlayback()
1746 {
1747     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1748         platformMediaSessionManager-&gt;stopAllMediaPlaybackForDocument(*this);
1749 }
1750 
1751 void Document::suspendAllMediaPlayback()
1752 {
1753     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1754         platformMediaSessionManager-&gt;suspendAllMediaPlaybackForDocument(*this);
1755 }
1756 
1757 void Document::resumeAllMediaPlayback()
1758 {
1759     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1760         platformMediaSessionManager-&gt;resumeAllMediaPlaybackForDocument(*this);
1761 }
1762 
1763 void Document::suspendAllMediaBuffering()
1764 {
1765     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1766         platformMediaSessionManager-&gt;suspendAllMediaBufferingForDocument(*this);
1767 }
1768 
1769 void Document::resumeAllMediaBuffering()
1770 {
1771     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1772         platformMediaSessionManager-&gt;resumeAllMediaBufferingForDocument(*this);
1773 }
1774 #endif
1775 
1776 String Document::nodeName() const
1777 {
1778     return &quot;#document&quot;_s;
1779 }
1780 
1781 Node::NodeType Document::nodeType() const
1782 {
1783     return DOCUMENT_NODE;
1784 }
1785 
1786 FormController&amp; Document::formController()
1787 {
1788     if (!m_formController)
1789         m_formController = makeUnique&lt;FormController&gt;();
1790     return *m_formController;
1791 }
1792 
1793 Vector&lt;String&gt; Document::formElementsState() const
1794 {
1795     if (!m_formController)
1796         return Vector&lt;String&gt;();
1797     return m_formController-&gt;formElementsState();
1798 }
1799 
1800 void Document::setStateForNewFormElements(const Vector&lt;String&gt;&amp; stateVector)
1801 {
1802     if (!stateVector.size() &amp;&amp; !m_formController)
1803         return;
1804     formController().setStateForNewFormElements(stateVector);
1805 }
1806 
1807 FrameView* Document::view() const
1808 {
1809     return m_frame ? m_frame-&gt;view() : nullptr;
1810 }
1811 
1812 Page* Document::page() const
1813 {
1814     return m_frame ? m_frame-&gt;page() : nullptr;
1815 }
1816 
1817 Ref&lt;Range&gt; Document::createRange()
1818 {
1819     return Range::create(*this);
1820 }
1821 
1822 Ref&lt;NodeIterator&gt; Document::createNodeIterator(Node&amp; root, unsigned long whatToShow, RefPtr&lt;NodeFilter&gt;&amp;&amp; filter, bool)
1823 {
1824     return NodeIterator::create(root, whatToShow, WTFMove(filter));
1825 }
1826 
1827 Ref&lt;TreeWalker&gt; Document::createTreeWalker(Node&amp; root, unsigned long whatToShow, RefPtr&lt;NodeFilter&gt;&amp;&amp; filter, bool)
1828 {
1829     return TreeWalker::create(root, whatToShow, WTFMove(filter));
1830 }
1831 
1832 void Document::scheduleFullStyleRebuild()
1833 {
1834     m_needsFullStyleRebuild = true;
1835     scheduleStyleRecalc();
1836 }
1837 
1838 void Document::scheduleStyleRecalc()
1839 {
1840     ASSERT(!m_renderView || !inHitTesting());
1841 
1842     if (m_styleRecalcTimer.isActive() || pageCacheState() != NotInPageCache)
1843         return;
1844 
1845     ASSERT(childNeedsStyleRecalc() || m_needsFullStyleRebuild);
1846     auto shouldThrottleStyleRecalc = [&amp;] {
1847         if (!view() || !view()-&gt;isVisuallyNonEmpty())
1848             return false;
1849         if (!page() || !page()-&gt;chrome().client().layerFlushThrottlingIsActive())
1850             return false;
1851         return true;
1852     };
1853 
1854     if (shouldThrottleStyleRecalc())
1855         return;
1856 
1857     m_styleRecalcTimer.startOneShot(0_s);
1858 
1859     InspectorInstrumentation::didScheduleStyleRecalculation(*this);
1860 }
1861 
1862 void Document::unscheduleStyleRecalc()
1863 {
1864     ASSERT(!childNeedsStyleRecalc());
1865 
1866     m_styleRecalcTimer.stop();
1867     m_needsFullStyleRebuild = false;
1868 }
1869 
1870 bool Document::hasPendingStyleRecalc() const
1871 {
1872     return needsStyleRecalc() &amp;&amp; !m_inStyleRecalc;
1873 }
1874 
1875 bool Document::hasPendingFullStyleRebuild() const
1876 {
1877     return hasPendingStyleRecalc() &amp;&amp; m_needsFullStyleRebuild;
1878 }
1879 
1880 void Document::resolveStyle(ResolveStyleType type)
1881 {
1882     ASSERT(!view() || !view()-&gt;isPainting());
1883 
1884     // NOTE: XSL code seems to be the only client stumbling in here without a RenderView.
1885     if (!m_renderView)
1886         return;
1887 
1888     FrameView&amp; frameView = m_renderView-&gt;frameView();
1889     Ref&lt;FrameView&gt; protect(frameView);
1890     if (frameView.isPainting())
1891         return;
1892 
1893     if (m_inStyleRecalc)
1894         return; // Guard against re-entrancy. -dwh
1895 
1896     TraceScope tracingScope(StyleRecalcStart, StyleRecalcEnd);
1897 
1898     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
1899     AnimationUpdateBlock animationUpdateBlock(&amp;m_frame-&gt;animation());
1900 
1901     // FIXME: Do this update per tree scope.
1902     {
1903         auto elements = copyToVectorOf&lt;RefPtr&lt;SVGUseElement&gt;&gt;(m_svgUseElements);
1904         // We can&#39;t clear m_svgUseElements here because updateShadowTree may end up executing arbitrary scripts
1905         // which may insert new SVG use elements or remove existing ones inside sync IPC via ImageLoader::updateFromElement.
1906         for (auto&amp; element : elements)
1907             element-&gt;updateShadowTree();
1908     }
1909 
1910     // FIXME: We should update style on our ancestor chain before proceeding, however doing so at
1911     // the time this comment was originally written caused several tests to crash.
1912 
1913     {
1914         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1915         styleScope().flushPendingUpdate();
1916         frameView.willRecalcStyle();
1917     }
1918 
1919     InspectorInstrumentationCookie cookie = InspectorInstrumentation::willRecalculateStyle(*this);
1920 
1921     bool updatedCompositingLayers = false;
1922     {
1923         Style::PostResolutionCallbackDisabler disabler(*this);
1924         WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
1925         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1926 
1927         m_inStyleRecalc = true;
1928 
1929         if (m_needsFullStyleRebuild)
1930             type = ResolveStyleType::Rebuild;
1931 
1932         if (type == ResolveStyleType::Rebuild) {
1933             // This may get set again during style resolve.
1934             m_hasNodesWithNonFinalStyle = false;
1935             m_hasNodesWithMissingStyle = false;
1936 
1937             auto documentStyle = Style::resolveForDocument(*this);
1938 
1939             // Inserting the pictograph font at the end of the font fallback list is done by the
1940             // font selector, so set a font selector if needed.
1941             if (settings().fontFallbackPrefersPictographs())
1942                 documentStyle.fontCascade().update(&amp;fontSelector());
1943 
1944             auto documentChange = Style::determineChange(documentStyle, m_renderView-&gt;style());
1945             if (documentChange != Style::NoChange)
1946                 renderView()-&gt;setStyle(WTFMove(documentStyle));
1947 
1948             if (auto* documentElement = this-&gt;documentElement())
1949                 documentElement-&gt;invalidateStyleForSubtree();
1950         }
1951 
1952         Style::TreeResolver resolver(*this);
1953         auto styleUpdate = resolver.resolve();
1954 
1955         m_lastStyleUpdateSizeForTesting = styleUpdate ? styleUpdate-&gt;size() : 0;
1956 
1957         setHasValidStyle();
1958         clearChildNeedsStyleRecalc();
1959         unscheduleStyleRecalc();
1960 
1961         m_inStyleRecalc = false;
1962 
1963         if (styleUpdate) {
1964             SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
1965 
1966             RenderTreeUpdater updater(*this);
1967             updater.commit(WTFMove(styleUpdate));
1968 
1969             frameView.styleDidChange();
1970         }
1971 
1972         updatedCompositingLayers = frameView.updateCompositingLayersAfterStyleChange();
1973 
1974         if (m_renderView-&gt;needsLayout())
1975             frameView.layoutContext().scheduleLayout();
1976 
1977         // Usually this is handled by post-layout.
1978         if (!frameView.needsLayout())
1979             frameView.frame().selection().scheduleAppearanceUpdateAfterStyleChange();
1980 
1981         // As a result of the style recalculation, the currently hovered element might have been
1982         // detached (for example, by setting display:none in the :hover style), schedule another mouseMove event
1983         // to check if any other elements ended up under the mouse pointer due to re-layout.
1984         if (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
1985             frameView.frame().mainFrame().eventHandler().dispatchFakeMouseMoveEventSoon();
1986 
1987         ++m_styleRecalcCount;
1988         // FIXME: Assert ASSERT(!needsStyleRecalc()) here. Do we still have some cases where it&#39;s not true?
1989     }
1990 
1991     // If we wanted to call implicitClose() during recalcStyle, do so now that we&#39;re finished.
1992     if (m_closeAfterStyleRecalc) {
1993         m_closeAfterStyleRecalc = false;
1994         implicitClose();
1995     }
1996 
1997     InspectorInstrumentation::didRecalculateStyle(cookie);
1998 
1999     // Some animated images may now be inside the viewport due to style recalc,
2000     // resume them if necessary if there is no layout pending. Otherwise, we&#39;ll
2001     // check if they need to be resumed after layout.
2002     if (updatedCompositingLayers &amp;&amp; !frameView.needsLayout())
2003         frameView.viewportContentsChanged();
2004 
2005     if (m_gotoAnchorNeededAfterStylesheetsLoad &amp;&amp; !styleScope().hasPendingSheets())
2006         frameView.scrollToFragment(m_url);
2007 }
2008 
2009 void Document::updateTextRenderer(Text&amp; text, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText)
2010 {
2011     ASSERT(!m_inRenderTreeUpdate);
2012     SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
2013 
2014     auto textUpdate = makeUnique&lt;Style::Update&gt;(*this);
2015     textUpdate-&gt;addText(text, { offsetOfReplacedText, lengthOfReplacedText, WTF::nullopt });
2016 
2017     RenderTreeUpdater renderTreeUpdater(*this);
2018     renderTreeUpdater.commit(WTFMove(textUpdate));
2019 }
2020 
2021 bool Document::needsStyleRecalc() const
2022 {
2023     if (pageCacheState() != NotInPageCache)
2024         return false;
2025 
2026     if (m_needsFullStyleRebuild)
2027         return true;
2028 
2029     if (childNeedsStyleRecalc())
2030         return true;
2031 
2032     if (styleScope().hasPendingUpdate())
2033         return true;
2034 
2035     // Ensure this happens eventually as it is currently in resolveStyle. This can be removed if the code moves.
2036     if (m_gotoAnchorNeededAfterStylesheetsLoad &amp;&amp; !styleScope().hasPendingSheets())
2037         return true;
2038 
2039     return false;
2040 }
2041 
2042 static bool isSafeToUpdateStyleOrLayout(const Document&amp; document)
2043 {
2044     bool isSafeToExecuteScript = ScriptDisallowedScope::InMainThread::isScriptAllowed();
2045     auto* frameView = document.view();
2046     bool isInFrameFlattening = frameView &amp;&amp; frameView-&gt;isInChildFrameWithFrameFlattening();
2047     return isSafeToExecuteScript || isInFrameFlattening || !isInWebProcess();
2048 }
2049 
2050 bool Document::updateStyleIfNeeded()
2051 {
2052     RefPtr&lt;FrameView&gt; frameView = view();
2053     {
2054         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2055         ASSERT(isMainThread());
2056         ASSERT(!frameView || !frameView-&gt;isPainting());
2057 
2058         if (!frameView || frameView-&gt;layoutContext().isInRenderTreeLayout())
2059             return false;
2060 
2061         styleScope().flushPendingUpdate();
2062 
2063         if (!needsStyleRecalc())
2064             return false;
2065     }
2066 
2067 #if PLATFORM(IOS_FAMILY)
2068     ContentChangeObserver::StyleRecalcScope observingScope(*this);
2069 #endif
2070     // The early exit above for !needsStyleRecalc() is needed when updateWidgetPositions() is called in runOrScheduleAsynchronousTasks().
2071     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(isSafeToUpdateStyleOrLayout(*this));
2072     resolveStyle();
2073     return true;
2074 }
2075 
2076 void Document::updateLayout()
2077 {
2078     ASSERT(isMainThread());
2079 
2080     RefPtr&lt;FrameView&gt; frameView = view();
2081     if (frameView &amp;&amp; frameView-&gt;layoutContext().isInRenderTreeLayout()) {
2082         // View layout should not be re-entrant.
2083         ASSERT_NOT_REACHED();
2084         return;
2085     }
2086     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(isSafeToUpdateStyleOrLayout(*this));
2087 
2088     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
2089 
2090     if (HTMLFrameOwnerElement* owner = ownerElement())
2091         owner-&gt;document().updateLayout();
2092 
2093     updateStyleIfNeeded();
2094 
2095     StackStats::LayoutCheckPoint layoutCheckPoint;
2096 
2097     // Only do a layout if changes have occurred that make it necessary.
2098     if (frameView &amp;&amp; renderView() &amp;&amp; (frameView-&gt;layoutContext().isLayoutPending() || renderView()-&gt;needsLayout()))
2099         frameView-&gt;layoutContext().layout();
2100 }
2101 
2102 void Document::updateLayoutIgnorePendingStylesheets(Document::RunPostLayoutTasks runPostLayoutTasks)
2103 {
2104     bool oldIgnore = m_ignorePendingStylesheets;
2105 
2106     if (!haveStylesheetsLoaded()) {
2107         m_ignorePendingStylesheets = true;
2108         // FIXME: This should just invalidate elements with missing styles.
2109         if (m_hasNodesWithMissingStyle)
2110             scheduleFullStyleRebuild();
2111     }
2112 
2113     updateLayout();
2114 
2115     if (runPostLayoutTasks == RunPostLayoutTasks::Synchronously &amp;&amp; view())
2116         view()-&gt;flushAnyPendingPostLayoutTasks();
2117 
2118     m_ignorePendingStylesheets = oldIgnore;
2119 }
2120 
2121 std::unique_ptr&lt;RenderStyle&gt; Document::styleForElementIgnoringPendingStylesheets(Element&amp; element, const RenderStyle* parentStyle, PseudoId pseudoElementSpecifier)
2122 {
2123     ASSERT(&amp;element.document() == this);
2124     ASSERT(!element.isPseudoElement() || pseudoElementSpecifier == PseudoId::None);
2125     ASSERT(pseudoElementSpecifier == PseudoId::None || parentStyle);
2126 
2127     // On iOS request delegates called during styleForElement may result in re-entering WebKit and killing the style resolver.
2128     Style::PostResolutionCallbackDisabler disabler(*this, Style::PostResolutionCallbackDisabler::DrainCallbacks::No);
2129 
2130     SetForScope&lt;bool&gt; change(m_ignorePendingStylesheets, true);
2131     auto&amp; resolver = element.styleResolver();
2132 
2133     if (pseudoElementSpecifier != PseudoId::None)
2134         return resolver.pseudoStyleForElement(element, PseudoStyleRequest(pseudoElementSpecifier), *parentStyle);
2135 
2136     auto elementStyle = resolver.styleForElement(element, parentStyle);
2137     if (elementStyle.relations) {
2138         Style::Update emptyUpdate(*this);
2139         Style::commitRelations(WTFMove(elementStyle.relations), emptyUpdate);
2140     }
2141 
2142     return WTFMove(elementStyle.renderStyle);
2143 }
2144 
2145 bool Document::updateLayoutIfDimensionsOutOfDate(Element&amp; element, DimensionsCheck dimensionsCheck)
2146 {
2147     ASSERT(isMainThread());
2148 
2149     // If the stylesheets haven&#39;t loaded, just give up and do a full layout ignoring pending stylesheets.
2150     if (!haveStylesheetsLoaded()) {
2151         updateLayoutIgnorePendingStylesheets();
2152         return true;
2153     }
2154 
2155     // Check for re-entrancy and assert (same code that is in updateLayout()).
2156     RefPtr&lt;FrameView&gt; frameView = view();
2157     if (frameView &amp;&amp; frameView-&gt;layoutContext().isInRenderTreeLayout()) {
2158         // View layout should not be re-entrant.
2159         ASSERT_NOT_REACHED();
2160         return true;
2161     }
2162 
2163     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
2164 
2165     // Mimic the structure of updateLayout(), but at each step, see if we have been forced into doing a full
2166     // layout.
2167     bool requireFullLayout = false;
2168     if (HTMLFrameOwnerElement* owner = ownerElement()) {
2169         if (owner-&gt;document().updateLayoutIfDimensionsOutOfDate(*owner))
2170             requireFullLayout = true;
2171     }
2172 
2173     updateStyleIfNeeded();
2174 
2175     RenderObject* renderer = element.renderer();
2176     if (!renderer || renderer-&gt;needsLayout()) {
2177         // If we don&#39;t have a renderer or if the renderer needs layout for any reason, give up.
2178         requireFullLayout = true;
2179     }
2180 
2181     // Turn off this optimization for input elements with shadow content.
2182     if (is&lt;HTMLInputElement&gt;(element))
2183         requireFullLayout = true;
2184 
2185     bool isVertical = renderer &amp;&amp; !renderer-&gt;isHorizontalWritingMode();
2186     bool checkingLogicalWidth = ((dimensionsCheck &amp; WidthDimensionsCheck) &amp;&amp; !isVertical) || ((dimensionsCheck &amp; HeightDimensionsCheck) &amp;&amp; isVertical);
2187     bool checkingLogicalHeight = ((dimensionsCheck &amp; HeightDimensionsCheck) &amp;&amp; !isVertical) || ((dimensionsCheck &amp; WidthDimensionsCheck) &amp;&amp; isVertical);
2188     bool hasSpecifiedLogicalHeight = renderer &amp;&amp; renderer-&gt;style().logicalMinHeight() == Length(0, Fixed) &amp;&amp; renderer-&gt;style().logicalHeight().isFixed() &amp;&amp; renderer-&gt;style().logicalMaxHeight().isAuto();
2189 
2190     if (!requireFullLayout) {
2191         RenderBox* previousBox = nullptr;
2192         RenderBox* currentBox = nullptr;
2193 
2194         // Check our containing block chain. If anything in the chain needs a layout, then require a full layout.
2195         for (RenderObject* currRenderer = element.renderer(); currRenderer &amp;&amp; !currRenderer-&gt;isRenderView(); currRenderer = currRenderer-&gt;container()) {
2196 
2197             // Require the entire container chain to be boxes.
2198             if (!is&lt;RenderBox&gt;(currRenderer)) {
2199                 requireFullLayout = true;
2200                 break;
2201             }
2202 
2203             previousBox = currentBox;
2204             currentBox = downcast&lt;RenderBox&gt;(currRenderer);
2205 
2206             // If a box needs layout for itself or if a box has changed children and sizes its width to
2207             // its content, then require a full layout.
2208             if (currentBox-&gt;selfNeedsLayout() ||
2209                 (checkingLogicalWidth &amp;&amp; currRenderer-&gt;needsLayout() &amp;&amp; currentBox-&gt;sizesLogicalWidthToFitContent(MainOrPreferredSize))) {
2210                 requireFullLayout = true;
2211                 break;
2212             }
2213 
2214             // If a block contains floats and the child&#39;s height isn&#39;t specified, then
2215             // give up also, since our height could end up being influenced by the floats.
2216             if (checkingLogicalHeight &amp;&amp; !hasSpecifiedLogicalHeight &amp;&amp; currentBox-&gt;isRenderBlockFlow()) {
2217                 RenderBlockFlow* currentBlockFlow = downcast&lt;RenderBlockFlow&gt;(currentBox);
2218                 if (currentBlockFlow-&gt;containsFloats() &amp;&amp; previousBox &amp;&amp; !previousBox-&gt;isFloatingOrOutOfFlowPositioned()) {
2219                     requireFullLayout = true;
2220                     break;
2221                 }
2222             }
2223 
2224             if (!currentBox-&gt;isRenderBlockFlow() || currentBox-&gt;enclosingFragmentedFlow() || currentBox-&gt;isWritingModeRoot()) {
2225                 // FIXME: For now require only block flows all the way back to the root. This limits the optimization
2226                 // for now, and we&#39;ll expand it in future patches to apply to more and more scenarios.
2227                 // Disallow columns from having the optimization.
2228                 // Give up if the writing mode changes at all in the containing block chain.
2229                 requireFullLayout = true;
2230                 break;
2231             }
2232 
2233             if (currRenderer == frameView-&gt;layoutContext().subtreeLayoutRoot())
2234                 break;
2235         }
2236     }
2237 
2238     StackStats::LayoutCheckPoint layoutCheckPoint;
2239 
2240     // Only do a layout if changes have occurred that make it necessary.
2241     if (requireFullLayout &amp;&amp; frameView &amp;&amp; renderView() &amp;&amp; (frameView-&gt;layoutContext().isLayoutPending() || renderView()-&gt;needsLayout()))
2242         frameView-&gt;layoutContext().layout();
2243 
2244     return requireFullLayout;
2245 }
2246 
2247 bool Document::isPageBoxVisible(int pageIndex)
2248 {
2249     updateStyleIfNeeded();
2250     std::unique_ptr&lt;RenderStyle&gt; pageStyle(styleScope().resolver().styleForPage(pageIndex));
2251     return pageStyle-&gt;visibility() != Visibility::Hidden; // display property doesn&#39;t apply to @page.
2252 }
2253 
2254 void Document::pageSizeAndMarginsInPixels(int pageIndex, IntSize&amp; pageSize, int&amp; marginTop, int&amp; marginRight, int&amp; marginBottom, int&amp; marginLeft)
2255 {
2256     updateStyleIfNeeded();
2257     auto style = styleScope().resolver().styleForPage(pageIndex);
2258 
2259     int width = pageSize.width();
2260     int height = pageSize.height();
2261     switch (style-&gt;pageSizeType()) {
2262     case PAGE_SIZE_AUTO:
2263         break;
2264     case PAGE_SIZE_AUTO_LANDSCAPE:
2265         if (width &lt; height)
2266             std::swap(width, height);
2267         break;
2268     case PAGE_SIZE_AUTO_PORTRAIT:
2269         if (width &gt; height)
2270             std::swap(width, height);
2271         break;
2272     case PAGE_SIZE_RESOLVED: {
2273         auto&amp; size = style-&gt;pageSize();
2274         ASSERT(size.width.isFixed());
2275         ASSERT(size.height.isFixed());
2276         width = valueForLength(size.width, 0);
2277         height = valueForLength(size.height, 0);
2278         break;
2279     }
2280     default:
2281         ASSERT_NOT_REACHED();
2282     }
2283     pageSize = IntSize(width, height);
2284 
2285     // The percentage is calculated with respect to the width even for margin top and bottom.
2286     // http://www.w3.org/TR/CSS2/box.html#margin-properties
2287     marginTop = style-&gt;marginTop().isAuto() ? marginTop : intValueForLength(style-&gt;marginTop(), width);
2288     marginRight = style-&gt;marginRight().isAuto() ? marginRight : intValueForLength(style-&gt;marginRight(), width);
2289     marginBottom = style-&gt;marginBottom().isAuto() ? marginBottom : intValueForLength(style-&gt;marginBottom(), width);
2290     marginLeft = style-&gt;marginLeft().isAuto() ? marginLeft : intValueForLength(style-&gt;marginLeft(), width);
2291 }
2292 
2293 StyleResolver&amp; Document::userAgentShadowTreeStyleResolver()
2294 {
2295     if (!m_userAgentShadowTreeStyleResolver)
2296         m_userAgentShadowTreeStyleResolver = makeUnique&lt;StyleResolver&gt;(*this);
2297     return *m_userAgentShadowTreeStyleResolver;
2298 }
2299 
2300 void Document::fontsNeedUpdate(FontSelector&amp;)
2301 {
2302     invalidateMatchedPropertiesCacheAndForceStyleRecalc();
2303 }
2304 
2305 void Document::invalidateMatchedPropertiesCacheAndForceStyleRecalc()
2306 {
2307     if (auto* resolver = styleScope().resolverIfExists())
2308         resolver-&gt;invalidateMatchedPropertiesCache();
2309     if (pageCacheState() != NotInPageCache || !renderView())
2310         return;
2311     scheduleFullStyleRebuild();
2312 }
2313 
2314 void Document::didClearStyleResolver()
2315 {
2316     m_userAgentShadowTreeStyleResolver = nullptr;
2317 }
2318 
2319 void Document::setIsResolvingTreeStyle(bool value)
2320 {
2321     RELEASE_ASSERT(value != m_isResolvingTreeStyle);
2322     m_isResolvingTreeStyle = value;
2323 }
2324 
2325 void Document::createRenderTree()
2326 {
2327     ASSERT(!renderView());
2328     ASSERT(m_pageCacheState != InPageCache);
2329     ASSERT(!m_axObjectCache || this != &amp;topDocument());
2330 
2331     if (m_isNonRenderedPlaceholder)
2332         return;
2333 
2334     // FIXME: It would be better if we could pass the resolved document style directly here.
2335     m_renderView = createRenderer&lt;RenderView&gt;(*this, RenderStyle::create());
2336     Node::setRenderer(m_renderView.get());
2337 
2338     renderView()-&gt;setIsInWindow(true);
2339 
2340     resolveStyle(ResolveStyleType::Rebuild);
2341 }
2342 
2343 void Document::didBecomeCurrentDocumentInFrame()
2344 {
2345     // FIXME: Are there cases where the document can be dislodged from the frame during the event handling below?
2346     // If so, then m_frame could become 0, and we need to do something about that.
2347 
2348     m_frame-&gt;script().updateDocument();
2349 
2350     if (!hasLivingRenderTree())
2351         createRenderTree();
2352 
2353     dispatchDisabledAdaptationsDidChangeForMainFrame();
2354     updateViewportArguments();
2355 
2356     // FIXME: Doing this only for the main frame is insufficient.
2357     // Changing a subframe can also change the wheel event handler count.
2358     // FIXME: Doing this only when a document goes into the frame is insufficient.
2359     // Removing a document can also change the wheel event handler count.
2360     // FIXME: Doing this every time is a waste. If the current document and its
2361     // subframes&#39; documents have no wheel event handlers, then the count did not change,
2362     // unless the documents they are replacing had wheel event handlers.
2363     if (page() &amp;&amp; m_frame-&gt;isMainFrame())
2364         wheelEventHandlersChanged();
2365 
2366     // Ensure that the scheduled task state of the document matches the DOM suspension state of the frame. It can
2367     // be out of sync if the DOM suspension state changed while the document was not in the frame (possibly in the
2368     // page cache, or simply newly created).
2369     if (m_frame-&gt;activeDOMObjectsAndAnimationsSuspended()) {
2370         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2371             if (auto* timeline = existingTimeline())
2372                 timeline-&gt;suspendAnimations();
2373         } else
2374             m_frame-&gt;animation().suspendAnimationsForDocument(this);
2375         suspendScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
2376     } else {
2377         resumeScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
2378         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2379             if (auto* timeline = existingTimeline())
2380                 timeline-&gt;resumeAnimations();
2381         } else
2382             m_frame-&gt;animation().resumeAnimationsForDocument(this);
2383     }
2384 }
2385 
2386 void Document::frameDestroyed()
2387 {
2388     // detachFromFrame() must be called before destroying the Frame.
2389     RELEASE_ASSERT(!m_frame);
2390 
2391     if (auto* window = domWindow())
2392         window-&gt;frameDestroyed();
2393 
2394     FrameDestructionObserver::frameDestroyed();
2395 }
2396 
2397 void Document::willDetachPage()
2398 {
2399     FrameDestructionObserver::willDetachPage();
2400 #if PLATFORM(IOS_FAMILY)
2401     contentChangeObserver().willDetachPage();
2402 #endif
2403     if (domWindow() &amp;&amp; frame())
2404         InspectorInstrumentation::frameWindowDiscarded(*frame(), domWindow());
2405 }
2406 
2407 void Document::attachToCachedFrame(CachedFrameBase&amp; cachedFrame)
2408 {
2409     RELEASE_ASSERT(cachedFrame.document() == this);
2410     ASSERT(cachedFrame.view());
2411     ASSERT(m_pageCacheState == Document::InPageCache);
2412     observeFrame(&amp;cachedFrame.view()-&gt;frame());
2413 }
2414 
2415 void Document::detachFromCachedFrame(CachedFrameBase&amp; cachedFrame)
2416 {
2417     ASSERT_UNUSED(cachedFrame, cachedFrame.view());
2418     RELEASE_ASSERT(cachedFrame.document() == this);
2419     ASSERT(m_frame == &amp;cachedFrame.view()-&gt;frame());
2420     ASSERT(m_pageCacheState == Document::InPageCache);
2421     detachFromFrame();
2422 }
2423 
2424 void Document::destroyRenderTree()
2425 {
2426     ASSERT(hasLivingRenderTree());
2427     ASSERT(frame());
2428     ASSERT(frame()-&gt;document() == this);
2429     ASSERT(page());
2430 
2431     // Prevent Widget tree changes from committing until the RenderView is dead and gone.
2432     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
2433 
2434     SetForScope&lt;bool&gt; change(m_renderTreeBeingDestroyed, true);
2435 
2436     if (this == &amp;topDocument())
2437         clearAXObjectCache();
2438 
2439     documentWillBecomeInactive();
2440 
2441     if (view())
2442         view()-&gt;willDestroyRenderTree();
2443 
2444     if (m_documentElement)
2445         RenderTreeUpdater::tearDownRenderers(*m_documentElement);
2446 
2447     clearChildNeedsStyleRecalc();
2448 
2449     unscheduleStyleRecalc();
2450 
2451     // FIXME: RenderObject::view() uses m_renderView and we can&#39;t null it before destruction is completed
2452     {
2453         RenderTreeBuilder builder(*m_renderView);
2454         // FIXME: This is a workaround for leftover content (see webkit.org/b/182547).
2455         while (m_renderView-&gt;firstChild())
2456             builder.destroy(*m_renderView-&gt;firstChild());
2457         m_renderView-&gt;destroy();
2458     }
2459     m_renderView.release();
2460 
2461     Node::setRenderer(nullptr);
2462 
2463 #if ENABLE(TEXT_AUTOSIZING)
2464     m_textAutoSizing = nullptr;
2465 #endif
2466 
2467     if (view())
2468         view()-&gt;didDestroyRenderTree();
2469 }
2470 
2471 void Document::prepareForDestruction()
2472 {
2473     if (m_hasPreparedForDestruction)
2474         return;
2475 
2476     if (m_frame)
2477         m_frame-&gt;animation().detachFromDocument(this);
2478 
2479 #if USE(LIBWEBRTC)
2480     // FIXME: This should be moved to Modules/mediastream.
2481     if (LibWebRTCProvider::webRTCAvailable()) {
2482         if (auto* page = this-&gt;page())
2483             page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
2484     }
2485 #endif
2486 
2487 #if ENABLE(SERVICE_WORKER)
2488     setActiveServiceWorker(nullptr);
2489     setServiceWorkerConnection(nullptr);
2490 #endif
2491 
2492 #if ENABLE(IOS_TOUCH_EVENTS)
2493     clearTouchEventHandlersAndListeners();
2494 #endif
2495 
2496     m_undoManager-&gt;removeAllItems();
2497 
2498 #if ENABLE(ACCESSIBILITY)
2499     if (this != &amp;topDocument()) {
2500         // Let the ax cache know that this subframe goes out of scope.
2501         if (auto* cache = existingAXObjectCache())
2502             cache-&gt;prepareForDocumentDestruction(*this);
2503     }
2504 #endif
2505 
2506     {
2507         NavigationDisabler navigationDisabler(m_frame);
2508         disconnectDescendantFrames();
2509     }
2510     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!m_frame || !m_frame-&gt;tree().childCount());
2511 
2512     if (m_domWindow &amp;&amp; m_frame)
2513         m_domWindow-&gt;willDetachDocumentFromFrame();
2514 
2515     styleScope().clearResolver();
2516 
2517     if (hasLivingRenderTree())
2518         destroyRenderTree();
2519 
2520     if (is&lt;PluginDocument&gt;(*this))
2521         downcast&lt;PluginDocument&gt;(*this).detachFromPluginElement();
2522 
2523 #if ENABLE(POINTER_LOCK)
2524     if (page())
2525         page()-&gt;pointerLockController().documentDetached(*this);
2526 #endif
2527 
2528     if (auto* page = this-&gt;page()) {
2529         if (auto* validationMessageClient = page-&gt;validationMessageClient())
2530             validationMessageClient-&gt;documentDetached(*this);
2531     }
2532 
2533     InspectorInstrumentation::documentDetached(*this);
2534 
2535     stopActiveDOMObjects();
2536     m_eventQueue.close();
2537 #if ENABLE(FULLSCREEN_API)
2538     m_fullscreenManager-&gt;emptyEventQueue();
2539 #endif
2540 
2541     commonTeardown();
2542 
2543 #if ENABLE(TOUCH_EVENTS)
2544     if (m_touchEventTargets &amp;&amp; m_touchEventTargets-&gt;size() &amp;&amp; parentDocument())
2545         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2546 #endif
2547 
2548     if (m_wheelEventTargets &amp;&amp; m_wheelEventTargets-&gt;size() &amp;&amp; parentDocument())
2549         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2550 
2551     if (m_mediaQueryMatcher)
2552         m_mediaQueryMatcher-&gt;documentDestroyed();
2553 
2554 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2555     if (!m_clientToIDMap.isEmpty() &amp;&amp; page()) {
2556         for (auto* client : copyToVector(m_clientToIDMap.keys()))
2557             removePlaybackTargetPickerClient(*client);
2558     }
2559 #endif
2560 
2561     m_cachedResourceLoader-&gt;stopUnusedPreloadsTimer();
2562 
2563     if (page() &amp;&amp; m_mediaState != MediaProducer::IsNotPlaying) {
2564         m_mediaState = MediaProducer::IsNotPlaying;
2565         page()-&gt;updateIsPlayingMedia(HTMLMediaElementInvalidID);
2566     }
2567 
2568     detachFromFrame();
2569 
2570     if (m_timeline) {
2571         m_timeline-&gt;detachFromDocument();
2572         m_timeline = nullptr;
2573     }
2574 
2575 #if ENABLE(CSS_PAINTING_API)
2576     for (auto&amp; scope : m_paintWorkletGlobalScopes.values())
2577         scope-&gt;prepareForDestruction();
2578     m_paintWorkletGlobalScopes.clear();
2579 #endif
2580 
2581     m_hasPreparedForDestruction = true;
2582 
2583     // Note that m_pageCacheState can be Document::AboutToEnterPageCache if our frame
2584     // was removed in an onpagehide event handler fired when the top-level frame is
2585     // about to enter the page cache.
2586     RELEASE_ASSERT(m_pageCacheState != Document::InPageCache);
2587 }
2588 
2589 void Document::removeAllEventListeners()
2590 {
2591     EventTarget::removeAllEventListeners();
2592 
2593     if (m_domWindow)
2594         m_domWindow-&gt;removeAllEventListeners();
2595 
2596 #if ENABLE(IOS_TOUCH_EVENTS)
2597     clearTouchEventHandlersAndListeners();
2598 #endif
2599     for (Node* node = firstChild(); node; node = NodeTraversal::next(*node))
2600         node-&gt;removeAllEventListeners();
2601 
2602 #if ENABLE(TOUCH_EVENTS)
2603     m_touchEventTargets = nullptr;
2604 #endif
2605     m_wheelEventTargets = nullptr;
2606 }
2607 
2608 void Document::suspendDeviceMotionAndOrientationUpdates()
2609 {
2610     if (m_areDeviceMotionAndOrientationUpdatesSuspended)
2611         return;
2612     m_areDeviceMotionAndOrientationUpdatesSuspended = true;
2613 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2614     if (m_deviceMotionController)
2615         m_deviceMotionController-&gt;suspendUpdates();
2616     if (m_deviceOrientationController)
2617         m_deviceOrientationController-&gt;suspendUpdates();
2618 #endif
2619 }
2620 
2621 void Document::resumeDeviceMotionAndOrientationUpdates()
2622 {
2623     if (!m_areDeviceMotionAndOrientationUpdatesSuspended)
2624         return;
2625     m_areDeviceMotionAndOrientationUpdatesSuspended = false;
2626 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2627     if (m_deviceMotionController)
2628         m_deviceMotionController-&gt;resumeUpdates();
2629     if (m_deviceOrientationController)
2630         m_deviceOrientationController-&gt;resumeUpdates();
2631 #endif
2632 }
2633 
2634 bool Document::shouldBypassMainWorldContentSecurityPolicy() const
2635 {
2636     // Bypass this policy when the world is known, and it not the normal world.
2637     auto&amp; callFrame = *commonVM().topCallFrame;
2638     return &amp;callFrame != JSC::CallFrame::noCaller() &amp;&amp; !currentWorld(callFrame).isNormal();
2639 }
2640 
2641 void Document::platformSuspendOrStopActiveDOMObjects()
2642 {
2643 #if PLATFORM(IOS_FAMILY)
2644     contentChangeObserver().didSuspendActiveDOMObjects();
2645 #endif
2646 }
2647 
2648 void Document::suspendActiveDOMObjects(ReasonForSuspension why)
2649 {
2650     ScriptExecutionContext::suspendActiveDOMObjects(why);
2651     suspendDeviceMotionAndOrientationUpdates();
2652     platformSuspendOrStopActiveDOMObjects();
2653 }
2654 
2655 void Document::resumeActiveDOMObjects(ReasonForSuspension why)
2656 {
2657     ScriptExecutionContext::resumeActiveDOMObjects(why);
2658     resumeDeviceMotionAndOrientationUpdates();
2659     // FIXME: For iOS, do we need to add content change observers that were removed in Document::suspendActiveDOMObjects()?
2660 }
2661 
2662 void Document::stopActiveDOMObjects()
2663 {
2664     ScriptExecutionContext::stopActiveDOMObjects();
2665     platformSuspendOrStopActiveDOMObjects();
2666 }
2667 
2668 void Document::clearAXObjectCache()
2669 {
2670     ASSERT(&amp;topDocument() == this);
2671     // Clear the cache member variable before calling delete because attempts
2672     // are made to access it during destruction.
2673     m_axObjectCache = nullptr;
2674 }
2675 
2676 AXObjectCache* Document::existingAXObjectCacheSlow() const
2677 {
2678     ASSERT(hasEverCreatedAnAXObjectCache);
2679     return topDocument().m_axObjectCache.get();
2680 }
2681 
2682 AXObjectCache* Document::axObjectCache() const
2683 {
2684     if (!AXObjectCache::accessibilityEnabled())
2685         return nullptr;
2686 
2687     // The only document that actually has a AXObjectCache is the top-level
2688     // document.  This is because we need to be able to get from any WebCoreAXObject
2689     // to any other WebCoreAXObject on the same page.  Using a single cache allows
2690     // lookups across nested webareas (i.e. multiple documents).
2691     Document&amp; topDocument = this-&gt;topDocument();
2692 
2693     // If the document has already been detached, do not make a new axObjectCache.
2694     if (!topDocument.hasLivingRenderTree())
2695         return nullptr;
2696 
2697     ASSERT(&amp;topDocument == this || !m_axObjectCache);
2698     if (!topDocument.m_axObjectCache) {
2699         topDocument.m_axObjectCache = makeUnique&lt;AXObjectCache&gt;(topDocument);
2700         hasEverCreatedAnAXObjectCache = true;
2701     }
2702     return topDocument.m_axObjectCache.get();
2703 }
2704 
2705 void Document::setVisuallyOrdered()
2706 {
2707     m_visuallyOrdered = true;
2708     if (renderView())
2709         renderView()-&gt;mutableStyle().setRTLOrdering(Order::Visual);
2710 }
2711 
2712 Ref&lt;DocumentParser&gt; Document::createParser()
2713 {
2714     // FIXME: this should probably pass the frame instead
2715     return XMLDocumentParser::create(*this, view());
2716 }
2717 
2718 ScriptableDocumentParser* Document::scriptableDocumentParser() const
2719 {
2720     return parser() ? parser()-&gt;asScriptableDocumentParser() : nullptr;
2721 }
2722 
2723 ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; Document::openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; url, const AtomString&amp; name, const String&amp; features)
2724 {
2725     if (!m_domWindow)
2726         return Exception { InvalidAccessError };
2727 
2728     return m_domWindow-&gt;open(activeWindow, firstWindow, url, name, features);
2729 }
2730 
2731 ExceptionOr&lt;Document&amp;&gt; Document::openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;)
2732 {
2733     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
2734         return Exception { InvalidStateError };
2735 
2736     auto result = open(responsibleDocument);
2737     if (UNLIKELY(result.hasException()))
2738         return result.releaseException();
2739 
2740     return *this;
2741 }
2742 
2743 ExceptionOr&lt;void&gt; Document::open(Document* responsibleDocument)
2744 {
2745     if (responsibleDocument &amp;&amp; !responsibleDocument-&gt;securityOrigin().isSameOriginAs(securityOrigin()))
2746         return Exception { SecurityError };
2747 
2748     if (m_ignoreOpensDuringUnloadCount)
2749         return { };
2750 
2751     if (m_frame) {
2752         if (ScriptableDocumentParser* parser = scriptableDocumentParser()) {
2753             if (parser-&gt;isParsing()) {
2754                 // FIXME: HTML5 doesn&#39;t tell us to check this, it might not be correct.
2755                 if (parser-&gt;isExecutingScript())
2756                     return { };
2757 
2758                 if (!parser-&gt;wasCreatedByScript() &amp;&amp; parser-&gt;hasInsertionPoint())
2759                     return { };
2760             }
2761         }
2762 
2763         if (m_frame-&gt;loader().policyChecker().delegateIsDecidingNavigationPolicy())
2764             m_frame-&gt;loader().policyChecker().stopCheck();
2765         if (m_frame &amp;&amp; m_frame-&gt;loader().state() == FrameStateProvisional)
2766             m_frame-&gt;loader().stopAllLoaders();
2767     }
2768 
2769     removeAllEventListeners();
2770 
2771     if (responsibleDocument &amp;&amp; isFullyActive()) {
2772         auto newURL = responsibleDocument-&gt;url();
2773         if (responsibleDocument != this)
2774             newURL.removeFragmentIdentifier();
2775         setURL(newURL);
2776         auto newCookieURL = responsibleDocument-&gt;cookieURL();
2777         if (responsibleDocument != this)
2778             newCookieURL.removeFragmentIdentifier();
2779         setCookieURL(newCookieURL);
2780         setSecurityOriginPolicy(responsibleDocument-&gt;securityOriginPolicy());
2781     }
2782 
2783     implicitOpen();
2784     if (ScriptableDocumentParser* parser = scriptableDocumentParser())
2785         parser-&gt;setWasCreatedByScript(true);
2786 
2787     if (m_frame)
2788         m_frame-&gt;loader().didExplicitOpen();
2789 
2790     return { };
2791 }
2792 
2793 // https://html.spec.whatwg.org/#fully-active
2794 bool Document::isFullyActive() const
2795 {
2796     auto* frame = this-&gt;frame();
2797     if (!frame || frame-&gt;document() != this)
2798         return false;
2799 
2800     if (frame-&gt;isMainFrame())
2801         return true;
2802 
2803     auto* parentFrame = frame-&gt;tree().parent();
2804     return parentFrame &amp;&amp; parentFrame-&gt;document() &amp;&amp; parentFrame-&gt;document()-&gt;isFullyActive();
2805 }
2806 
2807 void Document::detachParser()
2808 {
2809     if (!m_parser)
2810         return;
2811     m_parser-&gt;detach();
2812     m_parser = nullptr;
2813 }
2814 
2815 void Document::cancelParsing()
2816 {
2817     if (!m_parser)
2818         return;
2819 
2820     // We have to clear the parser to avoid possibly triggering
2821     // the onload handler when closing as a side effect of a cancel-style
2822     // change, such as opening a new document or closing the window while
2823     // still parsing
2824     detachParser();
2825     explicitClose();
2826 }
2827 
2828 void Document::implicitOpen()
2829 {
2830     removeChildren();
2831 
2832     setCompatibilityMode(DocumentCompatibilityMode::NoQuirksMode);
2833 
2834     cancelParsing();
2835     m_parser = createParser();
2836 
2837     if (hasActiveParserYieldToken())
2838         m_parser-&gt;didBeginYieldingParser();
2839 
2840     setParsing(true);
2841     setReadyState(Loading);
2842 }
2843 
2844 HTMLBodyElement* Document::body() const
2845 {
2846     auto* element = documentElement();
2847     if (!is&lt;HTMLHtmlElement&gt;(element))
2848         return nullptr;
2849     return childrenOfType&lt;HTMLBodyElement&gt;(*element).first();
2850 }
2851 
2852 HTMLElement* Document::bodyOrFrameset() const
2853 {
2854     // Return the first body or frameset child of the html element.
2855     auto* element = documentElement();
2856     if (!is&lt;HTMLHtmlElement&gt;(element))
2857         return nullptr;
2858     for (auto&amp; child : childrenOfType&lt;HTMLElement&gt;(*element)) {
2859         if (is&lt;HTMLBodyElement&gt;(child) || is&lt;HTMLFrameSetElement&gt;(child))
2860             return &amp;child;
2861     }
2862     return nullptr;
2863 }
2864 
2865 ExceptionOr&lt;void&gt; Document::setBodyOrFrameset(RefPtr&lt;HTMLElement&gt;&amp;&amp; newBody)
2866 {
2867     if (!is&lt;HTMLBodyElement&gt;(newBody) &amp;&amp; !is&lt;HTMLFrameSetElement&gt;(newBody))
2868         return Exception { HierarchyRequestError };
2869 
2870     auto* currentBody = bodyOrFrameset();
2871     if (newBody == currentBody)
2872         return { };
2873 
2874     if (!m_documentElement)
2875         return Exception { HierarchyRequestError };
2876 
2877     if (currentBody)
2878         return m_documentElement-&gt;replaceChild(*newBody, *currentBody);
2879     return m_documentElement-&gt;appendChild(*newBody);
2880 }
2881 
2882 Location* Document::location() const
2883 {
2884     auto* window = domWindow();
2885     return window ? &amp;window-&gt;location() : nullptr;
2886 }
2887 
2888 HTMLHeadElement* Document::head()
2889 {
2890     if (auto element = documentElement())
2891         return childrenOfType&lt;HTMLHeadElement&gt;(*element).first();
2892     return nullptr;
2893 }
2894 
2895 ExceptionOr&lt;void&gt; Document::closeForBindings()
2896 {
2897     // FIXME: We should follow the specification more closely:
2898     //        http://www.whatwg.org/specs/web-apps/current-work/#dom-document-close
2899 
2900     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
2901         return Exception { InvalidStateError };
2902 
2903     close();
2904     return { };
2905 }
2906 
2907 void Document::close()
2908 {
2909     if (!scriptableDocumentParser() || !scriptableDocumentParser()-&gt;wasCreatedByScript() || !scriptableDocumentParser()-&gt;isParsing())
2910         return;
2911 
2912     explicitClose();
2913 }
2914 
2915 void Document::explicitClose()
2916 {
2917     if (RefPtr&lt;DocumentParser&gt; parser = m_parser)
2918         parser-&gt;finish();
2919 
2920     if (!m_frame) {
2921         // Because we have no frame, we don&#39;t know if all loading has completed,
2922         // so we just call implicitClose() immediately. FIXME: This might fire
2923         // the load event prematurely &lt;http://bugs.webkit.org/show_bug.cgi?id=14568&gt;.
2924         implicitClose();
2925         return;
2926     }
2927 
2928     checkCompleted();
2929 }
2930 
2931 void Document::implicitClose()
2932 {
2933     // If we&#39;re in the middle of recalcStyle, we need to defer the close until the style information is accurate and all elements are re-attached.
2934     if (m_inStyleRecalc) {
2935         m_closeAfterStyleRecalc = true;
2936         return;
2937     }
2938 
2939     bool wasLocationChangePending = frame() &amp;&amp; frame()-&gt;navigationScheduler().locationChangePending();
2940     bool doload = !parsing() &amp;&amp; m_parser &amp;&amp; !m_processingLoadEvent &amp;&amp; !wasLocationChangePending;
2941 
2942     if (!doload)
2943         return;
2944 
2945     // Call to dispatchWindowLoadEvent can blow us from underneath.
2946     Ref&lt;Document&gt; protectedThis(*this);
2947 
2948     m_processingLoadEvent = true;
2949 
2950     ScriptableDocumentParser* parser = scriptableDocumentParser();
2951     m_wellFormed = parser &amp;&amp; parser-&gt;wellFormed();
2952 
2953     // We have to clear the parser, in case someone document.write()s from the
2954     // onLoad event handler, as in Radar 3206524.
2955     detachParser();
2956 
2957     // FIXME: We kick off the icon loader when the Document is done parsing.
2958     // There are earlier opportunities we could start it:
2959     //  -When the &lt;head&gt; finishes parsing
2960     //  -When any new HTMLLinkElement is inserted into the document
2961     // But those add a dynamic component to the favicon that has UI
2962     // ramifications, and we need to decide what is the Right Thing To Do(tm)
2963     RefPtr&lt;Frame&gt; f = frame();
2964     if (f) {
2965 #if ENABLE(XSLT)
2966         // Apply XSL transforms before load events so that event handlers can access the transformed DOM tree.
2967         applyPendingXSLTransformsNowIfScheduled();
2968 #endif
2969 
2970         if (auto* documentLoader = loader())
2971             documentLoader-&gt;startIconLoading();
2972 
2973         f-&gt;animation().startAnimationsIfNotSuspended(this);
2974 
2975         // FIXME: We shouldn&#39;t be dispatching pending events globally on all Documents here.
2976         // For now, only do this when there is a Frame, otherwise this could cause JS reentrancy
2977         // below SVG font parsing, for example. &lt;https://webkit.org/b/136269&gt;
2978         ImageLoader::dispatchPendingBeforeLoadEvents();
2979         ImageLoader::dispatchPendingLoadEvents();
2980         ImageLoader::dispatchPendingErrorEvents();
2981         HTMLLinkElement::dispatchPendingLoadEvents();
2982         HTMLStyleElement::dispatchPendingLoadEvents();
2983 
2984         // To align the HTML load event and the SVGLoad event for the outermost &lt;svg&gt; element, fire it from
2985         // here, instead of doing it from SVGElement::finishedParsingChildren (if externalResourcesRequired=&quot;false&quot;,
2986         // which is the default, for =&#39;true&#39; its fired at a later time, once all external resources finished loading).
2987         if (svgExtensions())
2988             accessSVGExtensions().dispatchSVGLoadEventToOutermostSVGElements();
2989     }
2990 
2991     dispatchWindowLoadEvent();
2992     dispatchPageshowEvent(PageshowEventNotPersisted);
2993     if (m_pendingStateObject)
2994         dispatchPopstateEvent(WTFMove(m_pendingStateObject));
2995 
2996     if (f)
2997         f-&gt;loader().dispatchOnloadEvents();
2998 
2999     // An event handler may have removed the frame
3000     if (!frame()) {
3001         m_processingLoadEvent = false;
3002         return;
3003     }
3004 
3005     // Make sure both the initial layout and reflow happen after the onload
3006     // fires. This will improve onload scores, and other browsers do it.
3007     // If they wanna cheat, we can too. -dwh
3008 
3009     if (frame()-&gt;navigationScheduler().locationChangePending() &amp;&amp; timeSinceDocumentCreation() &lt; settings().layoutInterval()) {
3010         // Just bail out. Before or during the onload we were shifted to another page.
3011         // The old i-Bench suite does this. When this happens don&#39;t bother painting or laying out.
3012         m_processingLoadEvent = false;
3013         view()-&gt;layoutContext().unscheduleLayout();
3014         return;
3015     }
3016 
3017     frame()-&gt;loader().checkCallImplicitClose();
3018 
3019     // We used to force a synchronous display and flush here.  This really isn&#39;t
3020     // necessary and can in fact be actively harmful if pages are loading at a rate of &gt; 60fps
3021     // (if your platform is syncing flushes and limiting them to 60fps).
3022     m_overMinimumLayoutThreshold = true;
3023     if (!ownerElement() || (ownerElement()-&gt;renderer() &amp;&amp; !ownerElement()-&gt;renderer()-&gt;needsLayout())) {
3024         updateStyleIfNeeded();
3025 
3026         // Always do a layout after loading if needed.
3027         if (view() &amp;&amp; renderView() &amp;&amp; (!renderView()-&gt;firstChild() || renderView()-&gt;needsLayout()))
3028             view()-&gt;layoutContext().layout();
3029     }
3030 
3031     m_processingLoadEvent = false;
3032 
3033     if (auto* fontFaceSet = fontSelector().optionalFontFaceSet())
3034         fontFaceSet-&gt;didFirstLayout();
3035 
3036 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
3037     if (f &amp;&amp; hasLivingRenderTree() &amp;&amp; AXObjectCache::accessibilityEnabled()) {
3038         // The AX cache may have been cleared at this point, but we need to make sure it contains an
3039         // AX object to send the notification to. getOrCreate will make sure that an valid AX object
3040         // exists in the cache (we ignore the return value because we don&#39;t need it here). This is
3041         // only safe to call when a layout is not in progress, so it can not be used in postNotification.
3042         //
3043         // This notification is now called AXNewDocumentLoadComplete because there are other handlers that will
3044         // catch new AND page history loads, and that uses AXLoadComplete
3045 
3046         axObjectCache()-&gt;getOrCreate(renderView());
3047         if (this == &amp;topDocument())
3048             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXNewDocumentLoadComplete);
3049         else {
3050             // AXLoadComplete can only be posted on the top document, so if it&#39;s a document
3051             // in an iframe that just finished loading, post AXLayoutComplete instead.
3052             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXLayoutComplete);
3053         }
3054     }
3055 #endif
3056 
3057     if (svgExtensions())
3058         accessSVGExtensions().startAnimations();
3059 }
3060 
3061 void Document::setParsing(bool b)
3062 {
3063     m_bParsing = b;
3064 
3065     if (m_bParsing &amp;&amp; !m_sharedObjectPool)
3066         m_sharedObjectPool = makeUnique&lt;DocumentSharedObjectPool&gt;();
3067 
3068     if (!m_bParsing &amp;&amp; view() &amp;&amp; !view()-&gt;needsLayout())
3069         view()-&gt;fireLayoutRelatedMilestonesIfNeeded();
3070 }
3071 
3072 bool Document::shouldScheduleLayout()
3073 {
3074     if (!documentElement())
3075         return false;
3076     if (!is&lt;HTMLHtmlElement&gt;(*documentElement()))
3077         return true;
3078     if (!bodyOrFrameset())
3079         return false;
3080     if (styleScope().hasPendingSheetsBeforeBody())
3081         return false;
3082     if (page() &amp;&amp; page()-&gt;chrome().client().layerFlushThrottlingIsActive() &amp;&amp; view() &amp;&amp; view()-&gt;isVisuallyNonEmpty())
3083         return false;
3084 
3085     return true;
3086 }
3087 
3088 bool Document::isLayoutTimerActive()
3089 {
3090     return view() &amp;&amp; view()-&gt;layoutContext().isLayoutPending() &amp;&amp; !minimumLayoutDelay();
3091 }
3092 
3093 Seconds Document::minimumLayoutDelay()
3094 {
3095     if (m_overMinimumLayoutThreshold)
3096         return 0_s;
3097 
3098     auto elapsed = timeSinceDocumentCreation();
3099     m_overMinimumLayoutThreshold = elapsed &gt; settings().layoutInterval();
3100 
3101     // We&#39;ll want to schedule the timer to fire at the minimum layout threshold.
3102     return std::max(0_s, settings().layoutInterval() - elapsed);
3103 }
3104 
3105 Seconds Document::timeSinceDocumentCreation() const
3106 {
3107     return MonotonicTime::now() - m_documentCreationTime;
3108 }
3109 
3110 ExceptionOr&lt;void&gt; Document::write(Document* responsibleDocument, SegmentedString&amp;&amp; text)
3111 {
3112     NestingLevelIncrementer nestingLevelIncrementer(m_writeRecursionDepth);
3113 
3114     m_writeRecursionIsTooDeep = (m_writeRecursionDepth &gt; 1) &amp;&amp; m_writeRecursionIsTooDeep;
3115     m_writeRecursionIsTooDeep = (m_writeRecursionDepth &gt; cMaxWriteRecursionDepth) || m_writeRecursionIsTooDeep;
3116 
3117     if (m_writeRecursionIsTooDeep)
3118         return { };
3119 
3120     bool hasInsertionPoint = m_parser &amp;&amp; m_parser-&gt;hasInsertionPoint();
3121     if (!hasInsertionPoint &amp;&amp; (m_ignoreOpensDuringUnloadCount || m_ignoreDestructiveWriteCount))
3122         return { };
3123 
3124     if (!hasInsertionPoint) {
3125         auto result = open(responsibleDocument);
3126         if (UNLIKELY(result.hasException()))
3127             return result.releaseException();
3128     }
3129 
3130     ASSERT(m_parser);
3131     m_parser-&gt;insert(WTFMove(text));
3132     return { };
3133 }
3134 
3135 ExceptionOr&lt;void&gt; Document::write(Document* responsibleDocument, Vector&lt;String&gt;&amp;&amp; strings)
3136 {
3137     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
3138         return Exception { InvalidStateError };
3139 
3140     SegmentedString text;
3141     for (auto&amp; string : strings)
3142         text.append(WTFMove(string));
3143 
3144     return write(responsibleDocument, WTFMove(text));
3145 }
3146 
3147 ExceptionOr&lt;void&gt; Document::writeln(Document* responsibleDocument, Vector&lt;String&gt;&amp;&amp; strings)
3148 {
3149     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
3150         return Exception { InvalidStateError };
3151 
3152     SegmentedString text;
3153     for (auto&amp; string : strings)
3154         text.append(WTFMove(string));
3155 
3156     text.append(&quot;\n&quot;_s);
3157     return write(responsibleDocument, WTFMove(text));
3158 }
3159 
3160 Seconds Document::minimumDOMTimerInterval() const
3161 {
3162     auto* page = this-&gt;page();
3163     if (!page)
3164         return ScriptExecutionContext::minimumDOMTimerInterval();
3165     return page-&gt;settings().minimumDOMTimerInterval();
3166 }
3167 
3168 void Document::setTimerThrottlingEnabled(bool shouldThrottle)
3169 {
3170     if (m_isTimerThrottlingEnabled == shouldThrottle)
3171         return;
3172 
3173     m_isTimerThrottlingEnabled = shouldThrottle;
3174     didChangeTimerAlignmentInterval();
3175 }
3176 
3177 Seconds Document::domTimerAlignmentInterval(bool hasReachedMaxNestingLevel) const
3178 {
3179     auto alignmentInterval = ScriptExecutionContext::domTimerAlignmentInterval(hasReachedMaxNestingLevel);
3180     if (!hasReachedMaxNestingLevel)
3181         return alignmentInterval;
3182 
3183     // Apply Document-level DOMTimer throttling only if timers have reached their maximum nesting level as the Page may still be visible.
3184     if (m_isTimerThrottlingEnabled)
3185         alignmentInterval = std::max(alignmentInterval, DOMTimer::hiddenPageAlignmentInterval());
3186 
3187     if (Page* page = this-&gt;page())
3188         alignmentInterval = std::max(alignmentInterval, page-&gt;domTimerAlignmentInterval());
3189 
3190     if (!topOrigin().canAccess(securityOrigin()) &amp;&amp; !hasHadUserInteraction())
3191         alignmentInterval = std::max(alignmentInterval, DOMTimer::nonInteractedCrossOriginFrameAlignmentInterval());
3192 
3193     return alignmentInterval;
3194 }
3195 
3196 EventTarget* Document::errorEventTarget()
3197 {
3198     return m_domWindow.get();
3199 }
3200 
3201 void Document::logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack)
3202 {
3203     addMessage(MessageSource::JS, MessageLevel::Error, errorMessage, sourceURL, lineNumber, columnNumber, WTFMove(callStack));
3204 }
3205 
3206 void Document::setURL(const URL&amp; url)
3207 {
3208     const URL&amp; newURL = url.isEmpty() ? WTF::blankURL() : url;
3209     if (newURL == m_url)
3210         return;
3211 
3212     m_url = newURL;
3213     m_documentURI = m_url.string();
3214     updateBaseURL();
3215 }
3216 
3217 void Document::updateBaseURL()
3218 {
3219     URL oldBaseURL = m_baseURL;
3220     // DOM 3 Core: When the Document supports the feature &quot;HTML&quot; [DOM Level 2 HTML], the base URI is computed using
3221     // first the value of the href attribute of the HTML BASE element if any, and the value of the documentURI attribute
3222     // from the Document interface otherwise.
3223     if (!m_baseElementURL.isEmpty())
3224         m_baseURL = m_baseElementURL;
3225     else if (!m_baseURLOverride.isEmpty())
3226         m_baseURL = m_baseURLOverride;
3227     else {
3228         // The documentURI attribute is read-only from JavaScript, but writable from Objective C, so we need to retain
3229         // this fallback behavior. We use a null base URL, since the documentURI attribute is an arbitrary string
3230         // and DOM 3 Core does not specify how it should be resolved.
3231         m_baseURL = URL({ }, documentURI());
3232     }
3233 
3234     clearSelectorQueryCache();
3235 
3236     if (!m_baseURL.isValid())
3237         m_baseURL = URL();
3238 }
3239 
3240 void Document::setBaseURLOverride(const URL&amp; url)
3241 {
3242     m_baseURLOverride = url;
3243     updateBaseURL();
3244 }
3245 
3246 void Document::processBaseElement()
3247 {
3248     // Find the first href attribute in a base element and the first target attribute in a base element.
3249     const AtomString* href = nullptr;
3250     const AtomString* target = nullptr;
3251     auto baseDescendants = descendantsOfType&lt;HTMLBaseElement&gt;(*this);
3252     for (auto&amp; base : baseDescendants) {
3253         if (!href) {
3254             const AtomString&amp; value = base.attributeWithoutSynchronization(hrefAttr);
3255             if (!value.isNull()) {
3256                 href = &amp;value;
3257                 if (target)
3258                     break;
3259             }
3260         }
3261         if (!target) {
3262             const AtomString&amp; value = base.attributeWithoutSynchronization(targetAttr);
3263             if (!value.isNull()) {
3264                 target = &amp;value;
3265                 if (href)
3266                     break;
3267             }
3268         }
3269     }
3270 
3271     // FIXME: Since this doesn&#39;t share code with completeURL it may not handle encodings correctly.
3272     URL baseElementURL;
3273     if (href) {
3274         String strippedHref = stripLeadingAndTrailingHTMLSpaces(*href);
3275         if (!strippedHref.isEmpty())
3276             baseElementURL = URL(url(), strippedHref);
3277     }
3278     if (m_baseElementURL != baseElementURL &amp;&amp; contentSecurityPolicy()-&gt;allowBaseURI(baseElementURL)) {
3279         m_baseElementURL = baseElementURL;
3280         updateBaseURL();
3281     }
3282 
3283     m_baseTarget = target ? *target : nullAtom();
3284 }
3285 
3286 String Document::userAgent(const URL&amp; url) const
3287 {
3288     return frame() ? frame()-&gt;loader().userAgent(url) : String();
3289 }
3290 
3291 void Document::disableEval(const String&amp; errorMessage)
3292 {
3293     if (!frame())
3294         return;
3295 
3296     frame()-&gt;script().disableEval(errorMessage);
3297 }
3298 
3299 void Document::disableWebAssembly(const String&amp; errorMessage)
3300 {
3301     if (!frame())
3302         return;
3303 
3304     frame()-&gt;script().disableWebAssembly(errorMessage);
3305 }
3306 
3307 #if ENABLE(INDEXED_DATABASE)
3308 IDBClient::IDBConnectionProxy* Document::idbConnectionProxy()
3309 {
3310     if (!m_idbConnectionProxy) {
3311         Page* currentPage = page();
3312         if (!currentPage)
3313             return nullptr;
3314         m_idbConnectionProxy = &amp;currentPage-&gt;idbConnection().proxy();
3315     }
3316     return m_idbConnectionProxy.get();
3317 }
3318 #endif
3319 
3320 SocketProvider* Document::socketProvider()
3321 {
3322     return m_socketProvider.get();
3323 }
3324 
3325 bool Document::canNavigate(Frame* targetFrame, const URL&amp; destinationURL)
3326 {
3327     if (!m_frame)
3328         return false;
3329 
3330     // FIXME: We shouldn&#39;t call this function without a target frame, but
3331     // fast/forms/submit-to-blank-multiple-times.html depends on this function
3332     // returning true when supplied with a 0 targetFrame.
3333     if (!targetFrame)
3334         return true;
3335 
3336     if (!canNavigateInternal(*targetFrame))
3337         return false;
3338 
3339     if (isNavigationBlockedByThirdPartyIFrameRedirectBlocking(*targetFrame, destinationURL)) {
3340         printNavigationErrorMessage(*targetFrame, url(), &quot;The frame attempting navigation of the top-level window is cross-origin and the user has never interacted with the frame.&quot;_s);
3341         return false;
3342     }
3343 
3344     return true;
3345 }
3346 
3347 bool Document::canNavigateInternal(Frame&amp; targetFrame)
3348 {
3349     ASSERT(m_frame);
3350 
3351     // Cases (i), (ii) and (iii) pass the tests from the specifications but might not pass the &quot;security origin&quot; tests.
3352 
3353     // i. A frame can navigate its top ancestor when its &#39;allow-top-navigation&#39; flag is set (sometimes known as &#39;frame-busting&#39;).
3354     if (!isSandboxed(SandboxTopNavigation) &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top())
3355         return true;
3356 
3357     // ii. A frame can navigate its top ancestor when its &#39;allow-top-navigation-by-user-activation&#39; flag is set and navigation is triggered by user activation.
3358     if (!isSandboxed(SandboxTopNavigationByUserActivation) &amp;&amp; UserGestureIndicator::processingUserGesture() &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top())
3359         return true;
3360 
3361     // iii. A sandboxed frame can always navigate its descendants.
3362     if (isSandboxed(SandboxNavigation) &amp;&amp; targetFrame.tree().isDescendantOf(m_frame))
3363         return true;
3364 
3365     // From https://html.spec.whatwg.org/multipage/browsers.html#allowed-to-navigate.
3366     // 1. If A is not the same browsing context as B, and A is not one of the ancestor browsing contexts of B, and B is not a top-level browsing context, and A&#39;s active document&#39;s active sandboxing
3367     // flag set has its sandboxed navigation browsing context flag set, then abort these steps negatively.
3368     if (m_frame != &amp;targetFrame &amp;&amp; isSandboxed(SandboxNavigation) &amp;&amp; targetFrame.tree().parent() &amp;&amp; !targetFrame.tree().isDescendantOf(m_frame)) {
3369         printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is sandboxed, and is therefore disallowed from navigating its ancestors.&quot;_s);
3370         return false;
3371     }
3372 
3373     // 2. Otherwise, if B is a top-level browsing context, and is one of the ancestor browsing contexts of A, then:
3374     if (m_frame != &amp;targetFrame &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top()) {
3375         bool triggeredByUserActivation = UserGestureIndicator::processingUserGesture();
3376         // 1. If this algorithm is triggered by user activation and A&#39;s active document&#39;s active sandboxing flag set has its sandboxed top-level navigation with user activation browsing context flag set, then abort these steps negatively.
3377         if (triggeredByUserActivation &amp;&amp; isSandboxed(SandboxTopNavigationByUserActivation)) {
3378             printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation of the top-level window is sandboxed, but the &#39;allow-top-navigation-by-user-activation&#39; flag is not set and navigation is not triggered by user activation.&quot;_s);
3379             return false;
3380         }
3381         // 2. Otherwise, If this algorithm is not triggered by user activation and A&#39;s active document&#39;s active sandboxing flag set has its sandboxed top-level navigation without user activation browsing context flag set, then abort these steps negatively.
3382         if (!triggeredByUserActivation &amp;&amp; isSandboxed(SandboxTopNavigation)) {
3383             printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation of the top-level window is sandboxed, but the &#39;allow-top-navigation&#39; flag is not set.&quot;_s);
3384             return false;
3385         }
3386     }
3387 
3388     // 3. Otherwise, if B is a top-level browsing context, and is neither A nor one of the ancestor browsing contexts of A, and A&#39;s Document&#39;s active sandboxing flag set has its
3389     // sandboxed navigation browsing context flag set, and A is not the one permitted sandboxed navigator of B, then abort these steps negatively.
3390     if (!targetFrame.tree().parent() &amp;&amp; m_frame != &amp;targetFrame &amp;&amp; &amp;targetFrame != &amp;m_frame-&gt;tree().top() &amp;&amp; isSandboxed(SandboxNavigation) &amp;&amp; targetFrame.loader().opener() != m_frame) {
3391         printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is sandboxed, and is not allowed to navigate this popup.&quot;_s);
3392         return false;
3393     }
3394 
3395     // 4. Otherwise, terminate positively!
3396 
3397     // This is the normal case. A document can navigate its descendant frames,
3398     // or, more generally, a document can navigate a frame if the document is
3399     // in the same origin as any of that frame&#39;s ancestors (in the frame
3400     // hierarchy).
3401     //
3402     // See http://www.adambarth.com/papers/2008/barth-jackson-mitchell.pdf for
3403     // historical information about this security check.
3404     if (canAccessAncestor(securityOrigin(), &amp;targetFrame))
3405         return true;
3406 
3407     // Top-level frames are easier to navigate than other frames because they
3408     // display their URLs in the address bar (in most browsers). However, there
3409     // are still some restrictions on navigation to avoid nuisance attacks.
3410     // Specifically, a document can navigate a top-level frame if that frame
3411     // opened the document or if the document is the same-origin with any of
3412     // the top-level frame&#39;s opener&#39;s ancestors (in the frame hierarchy).
3413     //
3414     // In both of these cases, the document performing the navigation is in
3415     // some way related to the frame being navigate (e.g., by the &quot;opener&quot;
3416     // and/or &quot;parent&quot; relation). Requiring some sort of relation prevents a
3417     // document from navigating arbitrary, unrelated top-level frames.
3418     if (!targetFrame.tree().parent()) {
3419         if (&amp;targetFrame == m_frame-&gt;loader().opener())
3420             return true;
3421 
3422         if (canAccessAncestor(securityOrigin(), targetFrame.loader().opener()))
3423             return true;
3424     }
3425 
3426     printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is neither same-origin with the target, nor is it the target&#39;s parent or opener.&quot;);
3427     return false;
3428 }
3429 
3430 // Prevent cross-site top-level redirects from third-party iframes unless the user has ever interacted with the frame.
3431 bool Document::isNavigationBlockedByThirdPartyIFrameRedirectBlocking(Frame&amp; targetFrame, const URL&amp; destinationURL)
3432 {
3433     if (!settings().thirdPartyIframeRedirectBlockingEnabled())
3434         return false;
3435 
3436     // Only prevent top frame navigations by subframes.
3437     if (m_frame == &amp;targetFrame || &amp;targetFrame != &amp;m_frame-&gt;tree().top())
3438         return false;
3439 
3440     // Only prevent navigations by subframes that the user has not interacted with.
3441     if (m_frame-&gt;hasHadUserInteraction())
3442         return false;
3443 
3444     // Only prevent navigations by unsandboxed iframes. Such navigations by unsandboxed iframes would have already been blocked unless
3445     // &quot;allow-top-navigation&quot; / &quot;allow-top-navigation-by-user-activation&quot; was explicitly specified.
3446     if (sandboxFlags() != SandboxNone)
3447         return false;
3448 
3449     // Only prevent navigations by third-party iframes.
3450     if (canAccessAncestor(securityOrigin(), &amp;targetFrame))
3451         return false;
3452 
3453     // Only prevent cross-site navigations.
3454     auto* targetDocument = targetFrame.document();
3455     if (targetDocument &amp;&amp; (targetDocument-&gt;securityOrigin().canAccess(SecurityOrigin::create(destinationURL)) || areRegistrableDomainsEqual(targetDocument-&gt;url(), destinationURL)))
3456         return false;
3457 
3458     return true;
3459 }
3460 
3461 void Document::didRemoveAllPendingStylesheet()
3462 {
3463     if (auto* parser = scriptableDocumentParser())
3464         parser-&gt;executeScriptsWaitingForStylesheetsSoon();
3465 }
3466 
3467 bool Document::usesStyleBasedEditability() const
3468 {
3469     if (m_hasElementUsingStyleBasedEditability)
3470         return true;
3471 
3472     ASSERT(!m_renderView || !m_renderView-&gt;frameView().isPainting());
3473     ASSERT(!m_inStyleRecalc);
3474 
3475     auto&amp; styleScope = const_cast&lt;Style::Scope&amp;&gt;(this-&gt;styleScope());
3476     styleScope.flushPendingUpdate();
3477     return styleScope.usesStyleBasedEditability();
3478 }
3479 
3480 void Document::setHasElementUsingStyleBasedEditability()
3481 {
3482     m_hasElementUsingStyleBasedEditability = true;
3483 }
3484 
3485 void Document::processHttpEquiv(const String&amp; equiv, const String&amp; content, bool isInDocumentHead)
3486 {
3487     ASSERT(!equiv.isNull());
3488     ASSERT(!content.isNull());
3489 
3490     HttpEquivPolicy policy = httpEquivPolicy();
3491     if (policy != HttpEquivPolicy::Enabled) {
3492         String reason;
3493         switch (policy) {
3494         case HttpEquivPolicy::Enabled:
3495             ASSERT_NOT_REACHED();
3496             break;
3497         case HttpEquivPolicy::DisabledBySettings:
3498             reason = &quot;by the embedder.&quot;;
3499             break;
3500         case HttpEquivPolicy::DisabledByContentDispositionAttachmentSandbox:
3501             reason = &quot;for documents with Content-Disposition: attachment.&quot;;
3502             break;
3503         }
3504         String message = &quot;http-equiv &#39;&quot; + equiv + &quot;&#39; is disabled &quot; + reason;
3505         addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
3506         return;
3507     }
3508 
3509     Frame* frame = this-&gt;frame();
3510     auto* documentLoader = frame ? frame-&gt;loader().documentLoader() : nullptr;
3511     auto httpStatusCode = documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0;
3512 
3513     HTTPHeaderName headerName;
3514     if (!findHTTPHeaderName(equiv, headerName))
3515         return;
3516 
3517     switch (headerName) {
3518     case HTTPHeaderName::DefaultStyle:
3519         // The preferred style set has been overridden as per section
3520         // 14.3.2 of the HTML4.0 specification.  We need to update the
3521         // sheet used variable and then update our style selector.
3522         // For more info, see the test at:
3523         // http://www.hixie.ch/tests/evil/css/import/main/preferred.html
3524         // -dwh
3525         styleScope().setPreferredStylesheetSetName(content);
3526         break;
3527 
3528     case HTTPHeaderName::Refresh: {
3529         double delay;
3530         String urlString;
3531         if (frame &amp;&amp; parseMetaHTTPEquivRefresh(content, delay, urlString)) {
3532             URL completedURL;
3533             if (urlString.isEmpty())
3534                 completedURL = m_url;
3535             else
3536                 completedURL = completeURL(urlString);
3537             if (!WTF::protocolIsJavaScript(completedURL))
3538                 frame-&gt;navigationScheduler().scheduleRedirect(*this, delay, completedURL);
3539             else {
3540                 String message = &quot;Refused to refresh &quot; + m_url.stringCenterEllipsizedToLength() + &quot; to a javascript: URL&quot;;
3541                 addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
3542             }
3543         }
3544 
3545         break;
3546     }
3547 
3548     case HTTPHeaderName::SetCookie:
3549         if (isHTMLDocument())
3550             addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;The Set-Cookie meta tag is obsolete and was ignored. Use the HTTP header Set-Cookie or document.cookie instead.&quot;_s);
3551         break;
3552 
3553     case HTTPHeaderName::ContentLanguage:
3554         setContentLanguage(content);
3555         break;
3556 
3557     case HTTPHeaderName::XDNSPrefetchControl:
3558         parseDNSPrefetchControlHeader(content);
3559         break;
3560 
3561     case HTTPHeaderName::XFrameOptions:
3562         if (frame) {
3563             FrameLoader&amp; frameLoader = frame-&gt;loader();
3564             unsigned long requestIdentifier = 0;
3565             if (frameLoader.activeDocumentLoader() &amp;&amp; frameLoader.activeDocumentLoader()-&gt;mainResourceLoader())
3566                 requestIdentifier = frameLoader.activeDocumentLoader()-&gt;mainResourceLoader()-&gt;identifier();
3567 
3568             String message = &quot;The X-Frame-Option &#39;&quot; + content + &quot;&#39; supplied in a &lt;meta&gt; element was ignored. X-Frame-Options may only be provided by an HTTP header sent with the document.&quot;;
3569             addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, requestIdentifier);
3570         }
3571         break;
3572 
3573     case HTTPHeaderName::ContentSecurityPolicy:
3574         if (isInDocumentHead)
3575             contentSecurityPolicy()-&gt;didReceiveHeader(content, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::HTTPEquivMeta, referrer(), httpStatusCode);
3576         break;
3577 
3578     case HTTPHeaderName::XWebKitCSP:
3579         if (isInDocumentHead)
3580             contentSecurityPolicy()-&gt;didReceiveHeader(content, ContentSecurityPolicyHeaderType::PrefixedEnforce, ContentSecurityPolicy::PolicyFrom::HTTPEquivMeta, referrer(), httpStatusCode);
3581         break;
3582 
3583     default:
3584         break;
3585     }
3586 }
3587 
3588 void Document::processDisabledAdaptations(const String&amp; disabledAdaptationsString)
3589 {
3590     auto disabledAdaptations = parseDisabledAdaptations(disabledAdaptationsString);
3591     if (m_disabledAdaptations == disabledAdaptations)
3592         return;
3593 
3594     m_disabledAdaptations = disabledAdaptations;
3595     dispatchDisabledAdaptationsDidChangeForMainFrame();
3596 }
3597 
3598 void Document::dispatchDisabledAdaptationsDidChangeForMainFrame()
3599 {
3600     if (!frame()-&gt;isMainFrame())
3601         return;
3602 
3603     if (!page())
3604         return;
3605 
3606     page()-&gt;chrome().dispatchDisabledAdaptationsDidChange(m_disabledAdaptations);
3607 }
3608 
3609 void Document::processViewport(const String&amp; features, ViewportArguments::Type origin)
3610 {
3611     ASSERT(!features.isNull());
3612 
3613     LOG_WITH_STREAM(Viewports, stream &lt;&lt; &quot;Document::processViewport &quot; &lt;&lt; features);
3614 
3615     if (origin &lt; m_viewportArguments.type)
3616         return;
3617 
3618     m_viewportArguments = ViewportArguments(origin);
3619 
3620     LOG_WITH_STREAM(Viewports, stream  &lt;&lt; &quot; resolved to &quot; &lt;&lt; m_viewportArguments);
3621 
3622     processFeaturesString(features, FeatureMode::Viewport, [this](StringView key, StringView value) {
3623         setViewportFeature(m_viewportArguments, *this, key, value);
3624     });
3625 
3626     updateViewportArguments();
3627 }
3628 
3629 ViewportArguments Document::viewportArguments() const
3630 {
3631     auto* page = this-&gt;page();
3632     if (!page)
3633         return m_viewportArguments;
3634     return page-&gt;overrideViewportArguments().valueOr(m_viewportArguments);
3635 }
3636 
3637 void Document::updateViewportArguments()
3638 {
3639     if (page() &amp;&amp; frame()-&gt;isMainFrame()) {
3640 #ifndef NDEBUG
3641         m_didDispatchViewportPropertiesChanged = true;
3642 #endif
3643         page()-&gt;chrome().dispatchViewportPropertiesDidChange(viewportArguments());
3644         page()-&gt;chrome().didReceiveDocType(*frame());
3645     }
3646 }
3647 
3648 #if ENABLE(DARK_MODE_CSS)
3649 static void processColorSchemeString(StringView colorScheme, const WTF::Function&lt;void(StringView key)&gt;&amp; callback)
3650 {
3651     unsigned length = colorScheme.length();
3652     for (unsigned i = 0; i &lt; length; ) {
3653         // Skip to first non-separator.
3654         while (i &lt; length &amp;&amp; isHTMLSpace(colorScheme[i]))
3655             ++i;
3656         unsigned keyBegin = i;
3657 
3658         // Skip to first separator.
3659         while (i &lt; length &amp;&amp; !isHTMLSpace(colorScheme[i]))
3660             ++i;
3661         unsigned keyEnd = i;
3662 
3663         if (keyBegin == keyEnd)
3664             continue;
3665 
3666         callback(colorScheme.substring(keyBegin, keyEnd - keyBegin));
3667     }
3668 }
3669 
3670 void Document::processColorScheme(const String&amp; colorSchemeString)
3671 {
3672     OptionSet&lt;ColorScheme&gt; colorScheme;
3673     bool allowsTransformations = true;
3674     bool autoEncountered = false;
3675 
3676     processColorSchemeString(colorSchemeString, [&amp;](StringView key) {
3677         if (equalLettersIgnoringASCIICase(key, &quot;auto&quot;)) {
3678             colorScheme = { };
3679             allowsTransformations = true;
3680             autoEncountered = true;
3681             return;
3682         }
3683 
3684         if (autoEncountered)
3685             return;
3686 
3687         if (equalLettersIgnoringASCIICase(key, &quot;light&quot;))
3688             colorScheme.add(ColorScheme::Light);
3689         else if (equalLettersIgnoringASCIICase(key, &quot;dark&quot;))
3690             colorScheme.add(ColorScheme::Dark);
3691         else if (equalLettersIgnoringASCIICase(key, &quot;only&quot;))
3692             allowsTransformations = false;
3693     });
3694 
3695     // If the value was just &quot;only&quot;, that is synonymous for &quot;only light&quot;.
3696     if (colorScheme.isEmpty() &amp;&amp; !allowsTransformations)
3697         colorScheme.add(ColorScheme::Light);
3698 
3699     m_colorScheme = colorScheme;
3700     m_allowsColorSchemeTransformations = allowsTransformations;
3701 
3702     if (auto* frameView = view())
3703         frameView-&gt;recalculateBaseBackgroundColor();
3704 
3705     if (auto* page = this-&gt;page())
3706         page-&gt;updateStyleAfterChangeInEnvironment();
3707 }
3708 #endif
3709 
3710 #if PLATFORM(IOS_FAMILY)
3711 
3712 void Document::processFormatDetection(const String&amp; features)
3713 {
3714     // FIXME: Find a better place for this function.
3715     processFeaturesString(features, FeatureMode::Viewport, [this](StringView key, StringView value) {
3716         if (equalLettersIgnoringASCIICase(key, &quot;telephone&quot;) &amp;&amp; equalLettersIgnoringASCIICase(value, &quot;no&quot;))
3717             m_isTelephoneNumberParsingAllowed = false;
3718     });
3719 }
3720 
3721 void Document::processWebAppOrientations()
3722 {
3723     if (Page* page = this-&gt;page())
3724         page-&gt;chrome().client().webAppOrientationsUpdated();
3725 }
3726 
3727 #endif
3728 
3729 void Document::processReferrerPolicy(const String&amp; policy, ReferrerPolicySource source)
3730 {
3731     ASSERT(!policy.isNull());
3732 
3733     // Documents in a Content-Disposition: attachment sandbox should never send a Referer header,
3734     // even if the document has a meta tag saying otherwise.
3735     if (shouldEnforceContentDispositionAttachmentSandbox())
3736         return;
3737 
3738 #if USE(QUICK_LOOK)
3739     if (shouldEnforceQuickLookSandbox())
3740         return;
3741 #endif
3742 
3743     auto referrerPolicy = parseReferrerPolicy(policy, source);
3744     if (!referrerPolicy) {
3745         // Unknown policy values are ignored (https://w3c.github.io/webappsec-referrer-policy/#unknown-policy-values).
3746         addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, &quot;Failed to set referrer policy: The value &#39;&quot; + policy + &quot;&#39; is not one of &#39;no-referrer&#39;, &#39;no-referrer-when-downgrade&#39;, &#39;same-origin&#39;, &#39;origin&#39;, &#39;strict-origin&#39;, &#39;origin-when-cross-origin&#39;, &#39;strict-origin-when-cross-origin&#39; or &#39;unsafe-url&#39;.&quot;);
3747         return;
3748     }
3749     setReferrerPolicy(referrerPolicy.value());
3750 }
3751 
3752 MouseEventWithHitTestResults Document::prepareMouseEvent(const HitTestRequest&amp; request, const LayoutPoint&amp; documentPoint, const PlatformMouseEvent&amp; event)
3753 {
3754     if (!hasLivingRenderTree())
3755         return MouseEventWithHitTestResults(event, HitTestResult(LayoutPoint()));
3756 
3757     HitTestResult result(documentPoint);
3758     hitTest(request, result);
3759 
3760     auto captureElementChanged = CaptureChange::No;
3761     if (!request.readOnly()) {
3762         auto targetElement = makeRefPtr(result.targetElement());
3763 #if ENABLE(POINTER_EVENTS)
3764         if (auto* page = this-&gt;page()) {
3765             // Before we dispatch a new mouse event, we must run the Process Pending Capture Element steps as defined
3766             // in https://w3c.github.io/pointerevents/#process-pending-pointer-capture.
3767             auto&amp; pointerCaptureController = page-&gt;pointerCaptureController();
3768             auto* previousCaptureElement = pointerCaptureController.pointerCaptureElement(this, event.pointerId());
3769             pointerCaptureController.processPendingPointerCapture(event.pointerId());
3770             auto* captureElement = pointerCaptureController.pointerCaptureElement(this, event.pointerId());
3771             // If the capture element has changed while running the Process Pending Capture Element steps then
3772             // we need to indicate that when calling updateHoverActiveState to be sure that the :active and :hover
3773             // element chains are updated.
3774             if (previousCaptureElement != captureElement)
3775                 captureElementChanged = CaptureChange::Yes;
3776             // If we have a capture element, we must target it instead of what would normally hit-test for this event.
3777             if (captureElement)
3778                 targetElement = captureElement;
3779         }
3780 #endif
3781         updateHoverActiveState(request, targetElement.get(), captureElementChanged);
3782     }
3783 
3784     return MouseEventWithHitTestResults(event, result);
3785 }
3786 
3787 // DOM Section 1.1.1
3788 bool Document::childTypeAllowed(NodeType type) const
3789 {
3790     switch (type) {
3791     case ATTRIBUTE_NODE:
3792     case CDATA_SECTION_NODE:
3793     case DOCUMENT_FRAGMENT_NODE:
3794     case DOCUMENT_NODE:
3795     case TEXT_NODE:
3796         return false;
3797     case COMMENT_NODE:
3798     case PROCESSING_INSTRUCTION_NODE:
3799         return true;
3800     case DOCUMENT_TYPE_NODE:
3801     case ELEMENT_NODE:
3802         // Documents may contain no more than one of each of these.
3803         // (One Element and one DocumentType.)
3804         for (Node* c = firstChild(); c; c = c-&gt;nextSibling())
3805             if (c-&gt;nodeType() == type)
3806                 return false;
3807         return true;
3808     }
3809     return false;
3810 }
3811 
3812 bool Document::canAcceptChild(const Node&amp; newChild, const Node* refChild, AcceptChildOperation operation) const
3813 {
3814     if (operation == AcceptChildOperation::Replace &amp;&amp; refChild-&gt;nodeType() == newChild.nodeType())
3815         return true;
3816 
3817     switch (newChild.nodeType()) {
3818     case ATTRIBUTE_NODE:
3819     case CDATA_SECTION_NODE:
3820     case DOCUMENT_NODE:
3821     case TEXT_NODE:
3822         return false;
3823     case COMMENT_NODE:
3824     case PROCESSING_INSTRUCTION_NODE:
3825         return true;
3826     case DOCUMENT_FRAGMENT_NODE: {
3827         bool hasSeenElementChild = false;
3828         for (auto* node = downcast&lt;DocumentFragment&gt;(newChild).firstChild(); node; node = node-&gt;nextSibling()) {
3829             if (is&lt;Element&gt;(*node)) {
3830                 if (hasSeenElementChild)
3831                     return false;
3832                 hasSeenElementChild = true;
3833             }
3834             if (!canAcceptChild(*node, refChild, operation))
3835                 return false;
3836         }
3837         break;
3838     }
3839     case DOCUMENT_TYPE_NODE: {
3840         auto* existingDocType = childrenOfType&lt;DocumentType&gt;(*this).first();
3841         if (operation == AcceptChildOperation::Replace) {
3842             //  parent has a doctype child that is not child, or an element is preceding child.
3843             if (existingDocType &amp;&amp; existingDocType != refChild)
3844                 return false;
3845             if (refChild-&gt;previousElementSibling())
3846                 return false;
3847         } else {
3848             ASSERT(operation == AcceptChildOperation::InsertOrAdd);
3849             if (existingDocType)
3850                 return false;
3851             if ((refChild &amp;&amp; refChild-&gt;previousElementSibling()) || (!refChild &amp;&amp; firstElementChild()))
3852                 return false;
3853         }
3854         break;
3855     }
3856     case ELEMENT_NODE: {
3857         auto* existingElementChild = firstElementChild();
3858         if (operation == AcceptChildOperation::Replace) {
3859             if (existingElementChild &amp;&amp; existingElementChild != refChild)
3860                 return false;
3861             for (auto* child = refChild-&gt;nextSibling(); child; child = child-&gt;nextSibling()) {
3862                 if (is&lt;DocumentType&gt;(*child))
3863                     return false;
3864             }
3865         } else {
3866             ASSERT(operation == AcceptChildOperation::InsertOrAdd);
3867             if (existingElementChild)
3868                 return false;
3869             for (auto* child = refChild; child; child = child-&gt;nextSibling()) {
3870                 if (is&lt;DocumentType&gt;(*child))
3871                     return false;
3872             }
3873         }
3874         break;
3875     }
3876     }
3877     return true;
3878 }
3879 
3880 Ref&lt;Node&gt; Document::cloneNodeInternal(Document&amp;, CloningOperation type)
3881 {
3882     Ref&lt;Document&gt; clone = cloneDocumentWithoutChildren();
3883     clone-&gt;cloneDataFromDocument(*this);
3884     switch (type) {
3885     case CloningOperation::OnlySelf:
3886     case CloningOperation::SelfWithTemplateContent:
3887         break;
3888     case CloningOperation::Everything:
3889         cloneChildNodes(clone);
3890         break;
3891     }
3892     return clone;
3893 }
3894 
3895 Ref&lt;Document&gt; Document::cloneDocumentWithoutChildren() const
3896 {
3897     if (isXMLDocument()) {
3898         if (isXHTMLDocument())
3899             return XMLDocument::createXHTML(sessionID(), nullptr, url());
3900         return XMLDocument::create(sessionID(), nullptr, url());
3901     }
3902     return create(sessionID(), url());
3903 }
3904 
3905 void Document::cloneDataFromDocument(const Document&amp; other)
3906 {
3907     ASSERT(m_url == other.url());
3908     m_baseURL = other.baseURL();
3909     m_baseURLOverride = other.baseURLOverride();
3910     m_documentURI = other.documentURI();
3911 
3912     setCompatibilityMode(other.m_compatibilityMode);
3913     setContextDocument(other.contextDocument());
3914     setSecurityOriginPolicy(other.securityOriginPolicy());
3915     overrideMIMEType(other.contentType());
3916     setDecoder(other.decoder());
3917 }
3918 
3919 StyleSheetList&amp; Document::styleSheets()
3920 {
3921     if (!m_styleSheetList)
3922         m_styleSheetList = StyleSheetList::create(*this);
3923     return *m_styleSheetList;
3924 }
3925 
3926 void Document::evaluateMediaQueryList()
3927 {
3928     if (m_mediaQueryMatcher)
3929         m_mediaQueryMatcher-&gt;styleResolverChanged();
3930 
3931     checkViewportDependentPictures();
3932     checkAppearanceDependentPictures();
3933 }
3934 
3935 void Document::checkViewportDependentPictures()
3936 {
3937     Vector&lt;HTMLPictureElement*, 16&gt; changedPictures;
3938     HashSet&lt;HTMLPictureElement*&gt;::iterator end = m_viewportDependentPictures.end();
3939     for (HashSet&lt;HTMLPictureElement*&gt;::iterator it = m_viewportDependentPictures.begin(); it != end; ++it) {
3940         if ((*it)-&gt;viewportChangeAffectedPicture())
3941             changedPictures.append(*it);
3942     }
3943     for (auto* picture : changedPictures)
3944         picture-&gt;sourcesChanged();
3945 }
3946 
3947 void Document::checkAppearanceDependentPictures()
3948 {
3949     Vector&lt;HTMLPictureElement*, 16&gt; changedPictures;
3950     for (auto* picture : m_appearanceDependentPictures) {
3951         if (picture-&gt;appearanceChangeAffectedPicture())
3952             changedPictures.append(picture);
3953     }
3954 
3955     for (auto* picture : changedPictures)
3956         picture-&gt;sourcesChanged();
3957 }
3958 
3959 void Document::updateViewportUnitsOnResize()
3960 {
3961     if (!hasStyleWithViewportUnits())
3962         return;
3963 
3964     styleScope().resolver().clearCachedPropertiesAffectedByViewportUnits();
3965 
3966     // FIXME: Ideally, we should save the list of elements that have viewport units and only iterate over those.
3967     for (Element* element = ElementTraversal::firstWithin(rootNode()); element; element = ElementTraversal::nextIncludingPseudo(*element)) {
3968         auto* renderer = element-&gt;renderer();
3969         if (renderer &amp;&amp; renderer-&gt;style().hasViewportUnits())
3970             element-&gt;invalidateStyle();
3971     }
3972 }
3973 
3974 void Document::addAudioProducer(MediaProducer&amp; audioProducer)
3975 {
3976     m_audioProducers.add(audioProducer);
3977     updateIsPlayingMedia();
3978 }
3979 
3980 void Document::removeAudioProducer(MediaProducer&amp; audioProducer)
3981 {
3982     RELEASE_ASSERT(isMainThread());
3983     m_audioProducers.remove(audioProducer);
3984     updateIsPlayingMedia();
3985 }
3986 
3987 void Document::noteUserInteractionWithMediaElement()
3988 {
3989     if (m_userHasInteractedWithMediaElement)
3990         return;
3991 
3992     if (!topDocument().userDidInteractWithPage())
3993         return;
3994 
3995     m_userHasInteractedWithMediaElement = true;
3996     updateIsPlayingMedia();
3997 }
3998 
3999 void Document::updateIsPlayingMedia(uint64_t sourceElementID)
4000 {
4001     ASSERT(!m_audioProducers.hasNullReferences());
4002     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
4003     for (auto&amp; audioProducer : m_audioProducers)
4004         state |= audioProducer.mediaState();
4005 
4006 #if ENABLE(MEDIA_STREAM) &amp;&amp; PLATFORM(IOS_FAMILY)
4007     state |= MediaStreamTrack::captureState();
4008 #endif
4009 
4010 #if ENABLE(MEDIA_SESSION)
4011     if (HTMLMediaElement* sourceElement = HTMLMediaElement::elementWithID(sourceElementID)) {
4012         if (sourceElement-&gt;isPlaying())
4013             state |= MediaProducer::IsSourceElementPlaying;
4014 
4015         if (auto* session = sourceElement-&gt;session()) {
4016             if (auto* controls = session-&gt;controls()) {
4017                 if (controls-&gt;previousTrackEnabled())
4018                     state |= MediaProducer::IsPreviousTrackControlEnabled;
4019                 if (controls-&gt;nextTrackEnabled())
4020                     state |= MediaProducer::IsNextTrackControlEnabled;
4021             }
4022         }
4023     }
4024 #endif
4025 
4026     if (m_userHasInteractedWithMediaElement)
4027         state |= MediaProducer::HasUserInteractedWithMediaElement;
4028 
4029     if (state == m_mediaState)
4030         return;
4031 
4032 #if ENABLE(MEDIA_STREAM)
4033     bool captureStateChanged = MediaProducer::isCapturing(m_mediaState) != MediaProducer::isCapturing(state);
4034 #endif
4035 
4036     m_mediaState = state;
4037 
4038     if (page())
4039         page()-&gt;updateIsPlayingMedia(sourceElementID);
4040 
4041 #if ENABLE(MEDIA_STREAM)
4042     if (captureStateChanged)
4043         mediaStreamCaptureStateChanged();
4044 #endif
4045 }
4046 
4047 void Document::pageMutedStateDidChange()
4048 {
4049     for (auto&amp; audioProducer : m_audioProducers)
4050         audioProducer.pageMutedStateDidChange();
4051 
4052 #if ENABLE(MEDIA_STREAM) &amp;&amp; PLATFORM(IOS_FAMILY)
4053     MediaStreamTrack::muteCapture();
4054 #endif
4055 }
4056 
4057 static bool isNodeInSubtree(Node&amp; node, Node&amp; container, Document::NodeRemoval nodeRemoval)
4058 {
4059     if (nodeRemoval == Document::NodeRemoval::ChildrenOfNode)
4060         return node.isDescendantOf(container);
4061 
4062     return &amp;node == &amp;container || node.isDescendantOf(container);
4063 }
4064 
4065 void Document::adjustFocusedNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
4066 {
4067     if (!m_focusedElement || pageCacheState() != NotInPageCache) // If the document is in the page cache, then we don&#39;t need to clear out the focused node.
4068         return;
4069 
4070     Element* focusedElement = node.treeScope().focusedElementInScope();
4071     if (!focusedElement)
4072         return;
4073 
4074     if (isNodeInSubtree(*focusedElement, node, nodeRemoval)) {
4075         // FIXME: We should avoid synchronously updating the style inside setFocusedElement.
4076         // FIXME: Object elements should avoid loading a frame synchronously in a post style recalc callback.
4077         SubframeLoadingDisabler disabler(is&lt;ContainerNode&gt;(node) ? &amp;downcast&lt;ContainerNode&gt;(node) : nullptr);
4078         setFocusedElement(nullptr, FocusDirectionNone, FocusRemovalEventsMode::DoNotDispatch);
4079         // Set the focus navigation starting node to the previous focused element so that
4080         // we can fallback to the siblings or parent node for the next search.
4081         // Also we need to call removeFocusNavigationNodeOfSubtree after this function because
4082         // setFocusedElement(nullptr) will reset m_focusNavigationStartingNode.
4083         setFocusNavigationStartingNode(focusedElement);
4084     }
4085 }
4086 
4087 void Document::hoveredElementDidDetach(Element&amp; element)
4088 {
4089     if (!m_hoveredElement || &amp;element != m_hoveredElement)
4090         return;
4091 
4092     m_hoveredElement = element.parentElement();
4093     while (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
4094         m_hoveredElement = m_hoveredElement-&gt;parentElement();
4095     if (frame())
4096         frame()-&gt;eventHandler().scheduleHoverStateUpdate();
4097 }
4098 
4099 void Document::elementInActiveChainDidDetach(Element&amp; element)
4100 {
4101     if (!m_activeElement || &amp;element != m_activeElement)
4102         return;
4103 
4104     m_activeElement = element.parentElement();
4105     while (m_activeElement &amp;&amp; !m_activeElement-&gt;renderer())
4106         m_activeElement = m_activeElement-&gt;parentElement();
4107 }
4108 
4109 void Document::invalidateRenderingDependentRegions()
4110 {
4111 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(TOUCH_EVENTS)
4112     setTouchEventRegionsNeedUpdate();
4113 #endif
4114 
4115 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)
4116     if (auto* page = this-&gt;page()) {
4117         if (auto* frameView = view()) {
4118             if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
4119                 scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
4120         }
4121     }
4122 #endif
4123 }
4124 
4125 bool Document::setFocusedElement(Element* element, FocusDirection direction, FocusRemovalEventsMode eventsMode)
4126 {
4127     RefPtr&lt;Element&gt; newFocusedElement = element;
4128     // Make sure newFocusedElement is actually in this document
4129     if (newFocusedElement &amp;&amp; (&amp;newFocusedElement-&gt;document() != this))
4130         return true;
4131 
4132     if (m_focusedElement == newFocusedElement)
4133         return true;
4134 
4135     if (pageCacheState() != NotInPageCache)
4136         return false;
4137 
4138     bool focusChangeBlocked = false;
4139     RefPtr&lt;Element&gt; oldFocusedElement = WTFMove(m_focusedElement);
4140 
4141     // Remove focus from the existing focus node (if any)
4142     if (oldFocusedElement) {
4143         oldFocusedElement-&gt;setFocus(false);
4144         setFocusNavigationStartingNode(nullptr);
4145 
4146         if (eventsMode == FocusRemovalEventsMode::Dispatch) {
4147             // Dispatch a change event for form control elements that have been edited.
4148             if (is&lt;HTMLFormControlElement&gt;(*oldFocusedElement)) {
4149                 HTMLFormControlElement&amp; formControlElement = downcast&lt;HTMLFormControlElement&gt;(*oldFocusedElement);
4150                 if (formControlElement.wasChangedSinceLastFormControlChangeEvent())
4151                     formControlElement.dispatchFormControlChangeEvent();
4152             }
4153 
4154             // Dispatch the blur event and let the node do any other blur related activities (important for text fields)
4155             oldFocusedElement-&gt;dispatchBlurEvent(newFocusedElement.copyRef());
4156 
4157             if (m_focusedElement) {
4158                 // handler shifted focus
4159                 focusChangeBlocked = true;
4160                 newFocusedElement = nullptr;
4161             }
4162 
4163             oldFocusedElement-&gt;dispatchFocusOutEvent(eventNames().focusoutEvent, newFocusedElement.copyRef()); // DOM level 3 name for the bubbling blur event.
4164             // FIXME: We should remove firing DOMFocusOutEvent event when we are sure no content depends
4165             // on it, probably when &lt;rdar://problem/8503958&gt; is resolved.
4166             oldFocusedElement-&gt;dispatchFocusOutEvent(eventNames().DOMFocusOutEvent, newFocusedElement.copyRef()); // DOM level 2 name for compatibility.
4167 
4168             if (m_focusedElement) {
4169                 // handler shifted focus
4170                 focusChangeBlocked = true;
4171                 newFocusedElement = nullptr;
4172             }
4173         } else {
4174             // Match the order in HTMLTextFormControlElement::dispatchBlurEvent.
4175             if (is&lt;HTMLInputElement&gt;(*oldFocusedElement))
4176                 downcast&lt;HTMLInputElement&gt;(*oldFocusedElement).endEditing();
4177             if (page())
4178                 page()-&gt;chrome().client().elementDidBlur(*oldFocusedElement);
4179             ASSERT(!m_focusedElement);
4180         }
4181 
4182         if (oldFocusedElement-&gt;isRootEditableElement())
4183             frame()-&gt;editor().didEndEditing();
4184 
4185         if (view()) {
4186             if (Widget* oldWidget = widgetForElement(oldFocusedElement.get()))
4187                 oldWidget-&gt;setFocus(false);
4188             else
4189                 view()-&gt;setFocus(false);
4190         }
4191 
4192         if (is&lt;HTMLInputElement&gt;(oldFocusedElement)) {
4193             // HTMLInputElement::didBlur just scrolls text fields back to the beginning.
4194             // FIXME: This could be done asynchronusly.
4195             // Updating style may dispatch events due to PostResolutionCallback
4196             if (eventsMode == FocusRemovalEventsMode::Dispatch)
4197                 updateStyleIfNeeded();
4198             downcast&lt;HTMLInputElement&gt;(*oldFocusedElement).didBlur();
4199         }
4200     }
4201 
4202     if (newFocusedElement &amp;&amp; newFocusedElement-&gt;isFocusable()) {
4203         if (newFocusedElement-&gt;isRootEditableElement() &amp;&amp; !acceptsEditingFocus(*newFocusedElement)) {
4204             // delegate blocks focus change
4205             focusChangeBlocked = true;
4206             goto SetFocusedNodeDone;
4207         }
4208         // Set focus on the new node
4209         m_focusedElement = newFocusedElement;
4210         setFocusNavigationStartingNode(m_focusedElement.get());
4211 
4212         // Dispatch the focus event and let the node do any other focus related activities (important for text fields)
4213         m_focusedElement-&gt;dispatchFocusEvent(oldFocusedElement.copyRef(), direction);
4214 
4215         if (m_focusedElement != newFocusedElement) {
4216             // handler shifted focus
4217             focusChangeBlocked = true;
4218             goto SetFocusedNodeDone;
4219         }
4220 
4221         m_focusedElement-&gt;dispatchFocusInEvent(eventNames().focusinEvent, oldFocusedElement.copyRef()); // DOM level 3 bubbling focus event.
4222 
4223         if (m_focusedElement != newFocusedElement) {
4224             // handler shifted focus
4225             focusChangeBlocked = true;
4226             goto SetFocusedNodeDone;
4227         }
4228 
4229         // FIXME: We should remove firing DOMFocusInEvent event when we are sure no content depends
4230         // on it, probably when &lt;rdar://problem/8503958&gt; is m.
4231         m_focusedElement-&gt;dispatchFocusInEvent(eventNames().DOMFocusInEvent, oldFocusedElement.copyRef()); // DOM level 2 for compatibility.
4232 
4233         if (m_focusedElement != newFocusedElement) {
4234             // handler shifted focus
4235             focusChangeBlocked = true;
4236             goto SetFocusedNodeDone;
4237         }
4238 
4239         m_focusedElement-&gt;setFocus(true);
4240 
4241         // The setFocus call triggers a blur and a focus event. Event handlers could cause the focused element to be cleared.
4242         if (m_focusedElement != newFocusedElement) {
4243             // handler shifted focus
4244             focusChangeBlocked = true;
4245             goto SetFocusedNodeDone;
4246         }
4247 
4248         if (m_focusedElement-&gt;isRootEditableElement())
4249             frame()-&gt;editor().didBeginEditing();
4250 
4251         // eww, I suck. set the qt focus correctly
4252         // ### find a better place in the code for this
4253         if (view()) {
4254             Widget* focusWidget = widgetForElement(m_focusedElement.get());
4255             if (focusWidget) {
4256                 // Make sure a widget has the right size before giving it focus.
4257                 // Otherwise, we are testing edge cases of the Widget code.
4258                 // Specifically, in WebCore this does not work well for text fields.
4259                 updateLayout();
4260                 // Re-get the widget in case updating the layout changed things.
4261                 focusWidget = widgetForElement(m_focusedElement.get());
4262             }
4263             if (focusWidget)
4264                 focusWidget-&gt;setFocus(true);
4265             else if (auto* frameView = view())
4266                 frameView-&gt;setFocus(true);
4267         }
4268     }
4269 
4270     if (!focusChangeBlocked &amp;&amp; m_focusedElement) {
4271         // Create the AXObject cache in a focus change because GTK relies on it.
4272         if (AXObjectCache* cache = axObjectCache())
4273             cache-&gt;deferFocusedUIElementChangeIfNeeded(oldFocusedElement.get(), newFocusedElement.get());
4274     }
4275 
4276     if (!focusChangeBlocked &amp;&amp; page())
4277         page()-&gt;chrome().focusedElementChanged(m_focusedElement.get());
4278 
4279 SetFocusedNodeDone:
4280     // Updating style may dispatch events due to PostResolutionCallback
4281     // FIXME: Why is synchronous style update needed here at all?
4282     if (eventsMode == FocusRemovalEventsMode::Dispatch)
4283         updateStyleIfNeeded();
4284     return !focusChangeBlocked;
4285 }
4286 
4287 static bool shouldResetFocusNavigationStartingNode(Node&amp; node)
4288 {
4289     // Setting focus navigation starting node to the following nodes means that we should start
4290     // the search from the beginning of the document.
4291     return is&lt;HTMLHtmlElement&gt;(node) || is&lt;HTMLDocument&gt;(node);
4292 }
4293 
4294 void Document::setFocusNavigationStartingNode(Node* node)
4295 {
4296     if (!m_frame)
4297         return;
4298 
4299     m_focusNavigationStartingNodeIsRemoved = false;
4300     if (!node || shouldResetFocusNavigationStartingNode(*node)) {
4301         m_focusNavigationStartingNode = nullptr;
4302         return;
4303     }
4304 
4305     ASSERT(!node || node != this);
4306     m_focusNavigationStartingNode = node;
4307 }
4308 
4309 Element* Document::focusNavigationStartingNode(FocusDirection direction) const
4310 {
4311     if (m_focusedElement) {
4312         if (!m_focusNavigationStartingNode || !m_focusNavigationStartingNode-&gt;isDescendantOf(m_focusedElement.get()))
4313             return m_focusedElement.get();
4314     }
4315 
4316     if (!m_focusNavigationStartingNode)
4317         return nullptr;
4318 
4319     Node* node = m_focusNavigationStartingNode.get();
4320 
4321     // When the node was removed from the document tree. This case is not specified in the spec:
4322     // https://html.spec.whatwg.org/multipage/interaction.html#sequential-focus-navigation-starting-point
4323     // Current behaivor is to move the sequential navigation node to / after (based on the focus direction)
4324     // the previous sibling of the removed node.
4325     if (m_focusNavigationStartingNodeIsRemoved) {
4326         Node* nextNode = NodeTraversal::next(*node);
4327         if (!nextNode)
4328             nextNode = node;
4329         if (direction == FocusDirectionForward)
4330             return ElementTraversal::previous(*nextNode);
4331         if (is&lt;Element&gt;(*nextNode))
4332             return downcast&lt;Element&gt;(nextNode);
4333         return ElementTraversal::next(*nextNode);
4334     }
4335 
4336     if (is&lt;Element&gt;(*node))
4337         return downcast&lt;Element&gt;(node);
4338     if (Element* elementBeforeNextFocusableElement = direction == FocusDirectionForward ? ElementTraversal::previous(*node) : ElementTraversal::next(*node))
4339         return elementBeforeNextFocusableElement;
4340     return node-&gt;parentOrShadowHostElement();
4341 }
4342 
4343 void Document::setCSSTarget(Element* targetNode)
4344 {
4345     if (m_cssTarget)
4346         m_cssTarget-&gt;invalidateStyleForSubtree();
4347     m_cssTarget = targetNode;
4348     if (targetNode)
4349         targetNode-&gt;invalidateStyleForSubtree();
4350 }
4351 
4352 void Document::registerNodeListForInvalidation(LiveNodeList&amp; list)
4353 {
4354     m_nodeListAndCollectionCounts[list.invalidationType()]++;
4355     if (!list.isRootedAtDocument())
4356         return;
4357     ASSERT(!list.isRegisteredForInvalidationAtDocument());
4358     list.setRegisteredForInvalidationAtDocument(true);
4359     m_listsInvalidatedAtDocument.add(&amp;list);
4360 }
4361 
4362 void Document::unregisterNodeListForInvalidation(LiveNodeList&amp; list)
4363 {
4364     m_nodeListAndCollectionCounts[list.invalidationType()]--;
4365     if (!list.isRegisteredForInvalidationAtDocument())
4366         return;
4367 
4368     list.setRegisteredForInvalidationAtDocument(false);
4369     ASSERT(m_listsInvalidatedAtDocument.contains(&amp;list));
4370     m_listsInvalidatedAtDocument.remove(&amp;list);
4371 }
4372 
4373 void Document::registerCollection(HTMLCollection&amp; collection)
4374 {
4375     m_nodeListAndCollectionCounts[collection.invalidationType()]++;
4376     if (collection.isRootedAtDocument())
4377         m_collectionsInvalidatedAtDocument.add(&amp;collection);
4378 }
4379 
4380 void Document::unregisterCollection(HTMLCollection&amp; collection)
4381 {
4382     ASSERT(m_nodeListAndCollectionCounts[collection.invalidationType()]);
4383     m_nodeListAndCollectionCounts[collection.invalidationType()]--;
4384     if (!collection.isRootedAtDocument())
4385         return;
4386 
4387     m_collectionsInvalidatedAtDocument.remove(&amp;collection);
4388 }
4389 
4390 void Document::collectionCachedIdNameMap(const HTMLCollection&amp; collection)
4391 {
4392     ASSERT_UNUSED(collection, collection.hasNamedElementCache());
4393     m_nodeListAndCollectionCounts[InvalidateOnIdNameAttrChange]++;
4394 }
4395 
4396 void Document::collectionWillClearIdNameMap(const HTMLCollection&amp; collection)
4397 {
4398     ASSERT_UNUSED(collection, collection.hasNamedElementCache());
4399     ASSERT(m_nodeListAndCollectionCounts[InvalidateOnIdNameAttrChange]);
4400     m_nodeListAndCollectionCounts[InvalidateOnIdNameAttrChange]--;
4401 }
4402 
4403 void Document::attachNodeIterator(NodeIterator&amp; iterator)
4404 {
4405     m_nodeIterators.add(&amp;iterator);
4406 }
4407 
4408 void Document::detachNodeIterator(NodeIterator&amp; iterator)
4409 {
4410     // The node iterator can be detached without having been attached if its root node didn&#39;t have a document
4411     // when the iterator was created, but has it now.
4412     m_nodeIterators.remove(&amp;iterator);
4413 }
4414 
4415 void Document::moveNodeIteratorsToNewDocumentSlowCase(Node&amp; node, Document&amp; newDocument)
4416 {
4417     ASSERT(!m_nodeIterators.isEmpty());
4418     for (auto* iterator : copyToVector(m_nodeIterators)) {
4419         if (&amp;iterator-&gt;root() == &amp;node) {
4420             detachNodeIterator(*iterator);
4421             newDocument.attachNodeIterator(*iterator);
4422         }
4423     }
4424 }
4425 
4426 void Document::updateRangesAfterChildrenChanged(ContainerNode&amp; container)
4427 {
4428     for (auto* range : m_ranges)
4429         range-&gt;nodeChildrenChanged(container);
4430 }
4431 
4432 void Document::nodeChildrenWillBeRemoved(ContainerNode&amp; container)
4433 {
4434     ASSERT(ScriptDisallowedScope::InMainThread::hasDisallowedScope());
4435 
4436     adjustFocusedNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4437     adjustFocusNavigationNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4438 
4439 #if ENABLE(FULLSCREEN_API)
4440     m_fullscreenManager-&gt;adjustFullscreenElementOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4441 #endif
4442 
4443     for (auto* range : m_ranges)
4444         range-&gt;nodeChildrenWillBeRemoved(container);
4445 
4446     for (auto* it : m_nodeIterators) {
4447         for (Node* n = container.firstChild(); n; n = n-&gt;nextSibling())
4448             it-&gt;nodeWillBeRemoved(*n);
4449     }
4450 
4451     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
4452         for (Node* n = container.firstChild(); n; n = n-&gt;nextSibling()) {
4453             frame-&gt;eventHandler().nodeWillBeRemoved(*n);
4454             frame-&gt;selection().nodeWillBeRemoved(*n);
4455             frame-&gt;page()-&gt;dragCaretController().nodeWillBeRemoved(*n);
4456         }
4457     }
4458 
4459     if (m_markers-&gt;hasMarkers()) {
4460         for (Text* textNode = TextNodeTraversal::firstChild(container); textNode; textNode = TextNodeTraversal::nextSibling(*textNode))
4461             m_markers-&gt;removeMarkers(*textNode);
4462     }
4463 }
4464 
4465 void Document::nodeWillBeRemoved(Node&amp; node)
4466 {
4467     ASSERT(ScriptDisallowedScope::InMainThread::hasDisallowedScope());
4468 
4469     adjustFocusedNodeOnNodeRemoval(node);
4470     adjustFocusNavigationNodeOnNodeRemoval(node);
4471 
4472 #if ENABLE(FULLSCREEN_API)
4473     m_fullscreenManager-&gt;adjustFullscreenElementOnNodeRemoval(node, NodeRemoval::Node);
4474 #endif
4475 
4476     for (auto* it : m_nodeIterators)
4477         it-&gt;nodeWillBeRemoved(node);
4478 
4479     for (auto* range : m_ranges)
4480         range-&gt;nodeWillBeRemoved(node);
4481 
4482     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
4483         frame-&gt;eventHandler().nodeWillBeRemoved(node);
4484         frame-&gt;selection().nodeWillBeRemoved(node);
4485         frame-&gt;page()-&gt;dragCaretController().nodeWillBeRemoved(node);
4486     }
4487 
4488     if (is&lt;Text&gt;(node))
4489         m_markers-&gt;removeMarkers(node);
4490 }
4491 
4492 static Node* fallbackFocusNavigationStartingNodeAfterRemoval(Node&amp; node)
4493 {
4494     return node.previousSibling() ? node.previousSibling() : node.parentNode();
4495 }
4496 
4497 void Document::adjustFocusNavigationNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
4498 {
4499     if (!m_focusNavigationStartingNode)
4500         return;
4501 
4502     if (isNodeInSubtree(*m_focusNavigationStartingNode, node, nodeRemoval)) {
4503         auto* newNode = (nodeRemoval == NodeRemoval::ChildrenOfNode) ? &amp;node : fallbackFocusNavigationStartingNodeAfterRemoval(node);
4504         m_focusNavigationStartingNode = (newNode != this) ? newNode : nullptr;
4505         m_focusNavigationStartingNodeIsRemoved = true;
4506     }
4507 }
4508 
4509 void Document::textInserted(Node&amp; text, unsigned offset, unsigned length)
4510 {
4511     if (!m_ranges.isEmpty()) {
4512         for (auto* range : m_ranges)
4513             range-&gt;textInserted(text, offset, length);
4514     }
4515 
4516     // Update the markers for spelling and grammar checking.
4517     m_markers-&gt;shiftMarkers(text, offset, length);
4518 
4519 #if ENABLE(PLATFORM_DRIVEN_TEXT_CHECKING)
4520     // Freshly inserted text is expected to not inherit PlatformTextChecking markers.
4521     m_markers-&gt;removeMarkers(text, offset, length, DocumentMarker::PlatformTextChecking);
4522 #endif
4523 }
4524 
4525 void Document::textRemoved(Node&amp; text, unsigned offset, unsigned length)
4526 {
4527     if (!m_ranges.isEmpty()) {
4528         for (auto* range : m_ranges)
4529             range-&gt;textRemoved(text, offset, length);
4530     }
4531 
4532     // Update the markers for spelling and grammar checking.
4533     m_markers-&gt;removeMarkers(text, offset, length);
4534     m_markers-&gt;shiftMarkers(text, offset + length, 0 - length);
4535 }
4536 
4537 void Document::textNodesMerged(Text&amp; oldNode, unsigned offset)
4538 {
4539     if (!m_ranges.isEmpty()) {
4540         NodeWithIndex oldNodeWithIndex(&amp;oldNode);
4541         for (auto* range : m_ranges)
4542             range-&gt;textNodesMerged(oldNodeWithIndex, offset);
4543     }
4544 
4545     // FIXME: This should update markers for spelling and grammar checking.
4546 }
4547 
4548 void Document::textNodeSplit(Text&amp; oldNode)
4549 {
4550     for (auto* range : m_ranges)
4551         range-&gt;textNodeSplit(oldNode);
4552 
4553     // FIXME: This should update markers for spelling and grammar checking.
4554 }
4555 
4556 void Document::createDOMWindow()
4557 {
4558     ASSERT(m_frame);
4559     ASSERT(!m_domWindow);
4560 
4561     m_domWindow = DOMWindow::create(*this);
4562 
4563     ASSERT(m_domWindow-&gt;document() == this);
4564     ASSERT(m_domWindow-&gt;frame() == m_frame);
4565 
4566     m_frame-&gt;loader().client().didCreateWindow(*m_domWindow);
4567 }
4568 
4569 void Document::takeDOMWindowFrom(Document&amp; document)
4570 {
4571     ASSERT(m_frame);
4572     ASSERT(!m_domWindow);
4573     ASSERT(document.m_domWindow);
4574     // A valid DOMWindow is needed by CachedFrame for its documents.
4575     ASSERT(pageCacheState() == NotInPageCache);
4576 
4577     m_domWindow = WTFMove(document.m_domWindow);
4578     m_domWindow-&gt;didSecureTransitionTo(*this);
4579 
4580     ASSERT(m_domWindow-&gt;document() == this);
4581     ASSERT(m_domWindow-&gt;frame() == m_frame);
4582 }
4583 
4584 WindowProxy* Document::windowProxy() const
4585 {
4586     if (!m_frame)
4587         return nullptr;
4588     return &amp;m_frame-&gt;windowProxy();
4589 }
4590 
4591 Document&amp; Document::contextDocument() const
4592 {
4593     if (m_contextDocument)
4594         return *m_contextDocument.get();
4595     return const_cast&lt;Document&amp;&gt;(*this);
4596 }
4597 
4598 void Document::setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)
4599 {
4600     setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), isolatedWorld);
4601 }
4602 
4603 void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp; listener, DOMWrapperWorld&amp; isolatedWorld)
4604 {
4605     if (!m_domWindow)
4606         return;
4607     m_domWindow-&gt;setAttributeEventListener(eventType, WTFMove(listener), isolatedWorld);
4608 }
4609 
4610 void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)
4611 {
4612     if (!m_domWindow)
4613         return;
4614     setWindowAttributeEventListener(eventType, JSLazyEventListener::create(*m_domWindow, attributeName, attributeValue), isolatedWorld);
4615 }
4616 
4617 EventListener* Document::getWindowAttributeEventListener(const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
4618 {
4619     if (!m_domWindow)
4620         return nullptr;
4621     return m_domWindow-&gt;attributeEventListener(eventType, isolatedWorld);
4622 }
4623 
4624 void Document::dispatchWindowEvent(Event&amp; event, EventTarget* target)
4625 {
4626     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4627     if (!m_domWindow)
4628         return;
4629     m_domWindow-&gt;dispatchEvent(event, target);
4630 }
4631 
4632 void Document::dispatchWindowLoadEvent()
4633 {
4634     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4635     if (!m_domWindow)
4636         return;
4637     m_domWindow-&gt;dispatchLoadEvent();
4638     m_loadEventFinished = true;
4639     m_cachedResourceLoader-&gt;documentDidFinishLoadEvent();
4640 }
4641 
4642 void Document::enqueueWindowEvent(Ref&lt;Event&gt;&amp;&amp; event)
4643 {
4644     event-&gt;setTarget(m_domWindow.get());
4645     m_eventQueue.enqueueEvent(WTFMove(event));
4646 }
4647 
4648 void Document::enqueueDocumentEvent(Ref&lt;Event&gt;&amp;&amp; event)
4649 {
4650     event-&gt;setTarget(this);
4651     m_eventQueue.enqueueEvent(WTFMove(event));
4652 }
4653 
4654 void Document::enqueueOverflowEvent(Ref&lt;Event&gt;&amp;&amp; event)
4655 {
4656     m_eventQueue.enqueueEvent(WTFMove(event));
4657 }
4658 
4659 ExceptionOr&lt;Ref&lt;Event&gt;&gt; Document::createEvent(const String&amp; type)
4660 {
4661     // Please do *not* add new event classes to this function unless they are required
4662     // for compatibility with the DOM specification or some actual legacy web content.
4663 
4664     // This mechanism is superceded by use of event constructors.
4665     // That is what we should use for any new event classes.
4666 
4667     // The following strings are the ones from the DOM specification
4668     // &lt;https://dom.spec.whatwg.org/#dom-document-createevent&gt;.
4669 
4670     if (equalLettersIgnoringASCIICase(type, &quot;beforeunloadevent&quot;))
4671         return Ref&lt;Event&gt; { BeforeUnloadEvent::createForBindings() };
4672     if (equalLettersIgnoringASCIICase(type, &quot;compositionevent&quot;))
4673         return Ref&lt;Event&gt; { CompositionEvent::createForBindings() };
4674     if (equalLettersIgnoringASCIICase(type, &quot;customevent&quot;))
4675         return Ref&lt;Event&gt; { CustomEvent::create() };
4676     if (equalLettersIgnoringASCIICase(type, &quot;event&quot;) || equalLettersIgnoringASCIICase(type, &quot;events&quot;) || equalLettersIgnoringASCIICase(type, &quot;htmlevents&quot;) || equalLettersIgnoringASCIICase(type, &quot;svgevents&quot;))
4677         return Event::createForBindings();
4678     if (equalLettersIgnoringASCIICase(type, &quot;focusevent&quot;))
4679         return Ref&lt;Event&gt; { FocusEvent::createForBindings() };
4680     if (equalLettersIgnoringASCIICase(type, &quot;hashchangeevent&quot;))
4681         return Ref&lt;Event&gt; { HashChangeEvent::createForBindings() };
4682     if (equalLettersIgnoringASCIICase(type, &quot;keyboardevent&quot;))
4683         return Ref&lt;Event&gt; { KeyboardEvent::createForBindings() };
4684     if (equalLettersIgnoringASCIICase(type, &quot;messageevent&quot;))
4685         return Ref&lt;Event&gt; { MessageEvent::createForBindings() };
4686     if (equalLettersIgnoringASCIICase(type, &quot;storageevent&quot;))
4687         return Ref&lt;Event&gt; { StorageEvent::createForBindings() };
4688     if (equalLettersIgnoringASCIICase(type, &quot;mouseevent&quot;) || equalLettersIgnoringASCIICase(type, &quot;mouseevents&quot;))
4689         return Ref&lt;Event&gt; { MouseEvent::createForBindings() };
4690     if (equalLettersIgnoringASCIICase(type, &quot;textevent&quot;))
4691         return Ref&lt;Event&gt; { TextEvent::createForBindings() }; // FIXME: HTML specification says this should create a CompositionEvent, not a TextEvent.
4692     if (equalLettersIgnoringASCIICase(type, &quot;uievent&quot;) || equalLettersIgnoringASCIICase(type, &quot;uievents&quot;))
4693         return Ref&lt;Event&gt; { UIEvent::createForBindings() };
4694 
4695     // FIXME: Consider including support for these event classes even when device orientation
4696     // support is not enabled.
4697 #if ENABLE(DEVICE_ORIENTATION)
4698     if (equalLettersIgnoringASCIICase(type, &quot;devicemotionevent&quot;))
4699         return Ref&lt;Event&gt; { DeviceMotionEvent::createForBindings() };
4700     if (equalLettersIgnoringASCIICase(type, &quot;deviceorientationevent&quot;))
4701         return Ref&lt;Event&gt; { DeviceOrientationEvent::createForBindings() };
4702 #endif
4703 
4704 #if ENABLE(TOUCH_EVENTS)
4705     if (equalLettersIgnoringASCIICase(type, &quot;touchevent&quot;))
4706         return Ref&lt;Event&gt; { TouchEvent::createForBindings() };
4707 #endif
4708 
4709     // FIXME: Add support for &quot;dragevent&quot;, which the DOM specification calls for.
4710 
4711     // The following string comes from the SVG specification
4712     // &lt;http://www.w3.org/TR/SVG/script.html#InterfaceSVGZoomEvent&gt;
4713     // However, since there is no provision for initializing the event once it is created,
4714     // there is no practical value in this feature.
4715     // FIXME: Confirm there is no content depending on this and remove it.
4716 
4717     if (equalLettersIgnoringASCIICase(type, &quot;svgzoomevents&quot;))
4718         return Ref&lt;Event&gt; { SVGZoomEvent::createForBindings() };
4719 
4720     // The following strings are not part of the DOM specification and we would like to eliminate them.
4721     // However, we currently include them until we resolve any issues with backward compatibility.
4722     // FIXME: For each of the strings below, confirm that there is no content depending on it and remove
4723     // the string, remove the createForBindings function, and also consider removing the corresponding
4724     // init function for that class.
4725 
4726     if (equalLettersIgnoringASCIICase(type, &quot;keyboardevents&quot;))
4727         return Ref&lt;Event&gt; { KeyboardEvent::createForBindings() };
4728     if (equalLettersIgnoringASCIICase(type, &quot;mutationevent&quot;) || equalLettersIgnoringASCIICase(type, &quot;mutationevents&quot;))
4729         return Ref&lt;Event&gt; { MutationEvent::createForBindings() };
4730     if (equalLettersIgnoringASCIICase(type, &quot;overflowevent&quot;))
4731         return Ref&lt;Event&gt; { OverflowEvent::createForBindings() };
4732     if (equalLettersIgnoringASCIICase(type, &quot;popstateevent&quot;))
4733         return Ref&lt;Event&gt; { PopStateEvent::createForBindings() };
4734     if (equalLettersIgnoringASCIICase(type, &quot;wheelevent&quot;))
4735         return Ref&lt;Event&gt; { WheelEvent::createForBindings() };
4736 
4737     return Exception { NotSupportedError };
4738 }
4739 
4740 bool Document::hasListenerTypeForEventType(PlatformEvent::Type eventType) const
4741 {
4742     switch (eventType) {
4743     case PlatformEvent::MouseForceChanged:
4744         return m_listenerTypes &amp; Document::FORCECHANGED_LISTENER;
4745     case PlatformEvent::MouseForceDown:
4746         return m_listenerTypes &amp; Document::FORCEDOWN_LISTENER;
4747     case PlatformEvent::MouseForceUp:
4748         return m_listenerTypes &amp; Document::FORCEUP_LISTENER;
4749     case PlatformEvent::MouseScroll:
4750         return m_listenerTypes &amp; Document::SCROLL_LISTENER;
4751     default:
4752         return false;
4753     }
4754 }
4755 
4756 void Document::addListenerTypeIfNeeded(const AtomString&amp; eventType)
4757 {
4758     if (eventType == eventNames().DOMSubtreeModifiedEvent)
4759         addListenerType(DOMSUBTREEMODIFIED_LISTENER);
4760     else if (eventType == eventNames().DOMNodeInsertedEvent)
4761         addListenerType(DOMNODEINSERTED_LISTENER);
4762     else if (eventType == eventNames().DOMNodeRemovedEvent)
4763         addListenerType(DOMNODEREMOVED_LISTENER);
4764     else if (eventType == eventNames().DOMNodeRemovedFromDocumentEvent)
4765         addListenerType(DOMNODEREMOVEDFROMDOCUMENT_LISTENER);
4766     else if (eventType == eventNames().DOMNodeInsertedIntoDocumentEvent)
4767         addListenerType(DOMNODEINSERTEDINTODOCUMENT_LISTENER);
4768     else if (eventType == eventNames().DOMCharacterDataModifiedEvent)
4769         addListenerType(DOMCHARACTERDATAMODIFIED_LISTENER);
4770     else if (eventType == eventNames().overflowchangedEvent)
4771         addListenerType(OVERFLOWCHANGED_LISTENER);
4772     else if (eventType == eventNames().webkitAnimationStartEvent || eventType == eventNames().animationstartEvent)
4773         addListenerType(ANIMATIONSTART_LISTENER);
4774     else if (eventType == eventNames().webkitAnimationEndEvent || eventType == eventNames().animationendEvent)
4775         addListenerType(ANIMATIONEND_LISTENER);
4776     else if (eventType == eventNames().webkitAnimationIterationEvent || eventType == eventNames().animationiterationEvent)
4777         addListenerType(ANIMATIONITERATION_LISTENER);
4778     else if (eventType == eventNames().webkitTransitionEndEvent || eventType == eventNames().transitionendEvent)
4779         addListenerType(TRANSITIONEND_LISTENER);
4780     else if (eventType == eventNames().beforeloadEvent)
4781         addListenerType(BEFORELOAD_LISTENER);
4782     else if (eventType == eventNames().scrollEvent)
4783         addListenerType(SCROLL_LISTENER);
4784     else if (eventType == eventNames().webkitmouseforcewillbeginEvent)
4785         addListenerType(FORCEWILLBEGIN_LISTENER);
4786     else if (eventType == eventNames().webkitmouseforcechangedEvent)
4787         addListenerType(FORCECHANGED_LISTENER);
4788     else if (eventType == eventNames().webkitmouseforcedownEvent)
4789         addListenerType(FORCEDOWN_LISTENER);
4790     else if (eventType == eventNames().webkitmouseforceupEvent)
4791         addListenerType(FORCEUP_LISTENER);
4792     else if (eventType == eventNames().resizeEvent)
4793         addListenerType(RESIZE_LISTENER);
4794 }
4795 
4796 HTMLFrameOwnerElement* Document::ownerElement() const
4797 {
4798     if (!frame())
4799         return nullptr;
4800     return frame()-&gt;ownerElement();
4801 }
4802 
4803 // https://html.spec.whatwg.org/#cookie-averse-document-object
4804 bool Document::isCookieAverse() const
4805 {
4806     // A Document that has no browsing context is cookie-averse.
4807     if (!frame())
4808         return true;
4809 
4810     URL cookieURL = this-&gt;cookieURL();
4811 
4812     // This is not part of the specification but we have historically allowed cookies over file protocol
4813     // and some developers rely on this for testing.
4814     if (cookieURL.isLocalFile())
4815         return false;
4816 
4817     // A Document whose URL&#39;s scheme is not a network scheme is cookie-averse (https://fetch.spec.whatwg.org/#network-scheme).
4818     return !cookieURL.protocolIsInHTTPFamily() &amp;&amp; !cookieURL.protocolIs(&quot;ftp&quot;);
4819 }
4820 
4821 ExceptionOr&lt;String&gt; Document::cookie()
4822 {
4823     if (page() &amp;&amp; !page()-&gt;settings().cookieEnabled())
4824         return String();
4825 
4826     if (isCookieAverse())
4827         return String();
4828 
4829     if (!securityOrigin().canAccessCookies())
4830         return Exception { SecurityError };
4831 
4832     URL cookieURL = this-&gt;cookieURL();
4833     if (cookieURL.isEmpty())
4834         return String();
4835 
4836     if (!isDOMCookieCacheValid() &amp;&amp; page())
4837         setCachedDOMCookies(page()-&gt;cookieJar().cookies(*this, cookieURL));
4838 
4839     return String { cachedDOMCookies() };
4840 }
4841 
4842 ExceptionOr&lt;void&gt; Document::setCookie(const String&amp; value)
4843 {
4844     if (page() &amp;&amp; !page()-&gt;settings().cookieEnabled())
4845         return { };
4846 
4847     if (isCookieAverse())
4848         return { };
4849 
4850     if (!securityOrigin().canAccessCookies())
4851         return Exception { SecurityError };
4852 
4853     URL cookieURL = this-&gt;cookieURL();
4854     if (cookieURL.isEmpty())
4855         return { };
4856 
4857     invalidateDOMCookieCache();
4858     if (page())
4859         page()-&gt;cookieJar().setCookies(*this, cookieURL, value);
4860     return { };
4861 }
4862 
4863 String Document::referrer() const
4864 {
4865 #if ENABLE(RESOURCE_LOAD_STATISTICS)
4866     if (!m_referrerOverride.isEmpty())
4867         return m_referrerOverride;
4868 #endif
4869     if (frame())
4870         return frame()-&gt;loader().referrer();
4871     return String();
4872 }
4873 
4874 String Document::origin() const
4875 {
4876     return securityOrigin().toString();
4877 }
4878 
4879 String Document::domain() const
4880 {
4881     return securityOrigin().domain();
4882 }
4883 
4884 ExceptionOr&lt;void&gt; Document::setDomain(const String&amp; newDomain)
4885 {
4886     if (!frame())
4887         return Exception { SecurityError, &quot;A browsing context is required to set a domain.&quot; };
4888 
4889     if (isSandboxed(SandboxDocumentDomain))
4890         return Exception { SecurityError, &quot;Assignment is forbidden for sandboxed iframes.&quot; };
4891 
4892     if (SchemeRegistry::isDomainRelaxationForbiddenForURLScheme(securityOrigin().protocol()))
4893         return Exception { SecurityError };
4894 
4895     // FIXME: We should add logging indicating why a domain was not allowed.
4896 
4897     const String&amp; effectiveDomain = domain();
4898     if (effectiveDomain.isEmpty())
4899         return Exception { SecurityError, &quot;The document has a null effectiveDomain.&quot; };
4900 
4901     if (!securityOrigin().isMatchingRegistrableDomainSuffix(newDomain, settings().treatIPAddressAsDomain()))
4902         return Exception { SecurityError, &quot;Attempted to use a non-registrable domain.&quot; };
4903 
4904     securityOrigin().setDomainFromDOM(newDomain);
4905     return { };
4906 }
4907 
4908 void Document::overrideLastModified(const Optional&lt;WallTime&gt;&amp; lastModified)
4909 {
4910     m_overrideLastModified = lastModified;
4911 }
4912 
4913 // http://www.whatwg.org/specs/web-apps/current-work/#dom-document-lastmodified
4914 String Document::lastModified() const
4915 {
4916     Optional&lt;WallTime&gt; dateTime;
4917     if (m_overrideLastModified)
4918         dateTime = m_overrideLastModified;
4919     else if (loader())
4920         dateTime = loader()-&gt;response().lastModified();
4921 
4922     // FIXME: If this document came from the file system, the HTML specification tells
4923     // us to read the last modification date from the file system.
4924     if (!dateTime)
4925         dateTime = WallTime::now();
4926 
4927     auto ctime = dateTime.value().secondsSinceEpoch().secondsAs&lt;time_t&gt;();
4928     auto localDateTime = std::localtime(&amp;ctime);
4929     return makeString(pad(&#39;0&#39;, 2, localDateTime-&gt;tm_mon + 1), &#39;/&#39;,
4930         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_mday), &#39;/&#39;,
4931         pad(&#39;0&#39;, 4, 1900 + localDateTime-&gt;tm_year), &#39; &#39;,
4932         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_hour), &#39;:&#39;,
4933         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_min), &#39;:&#39;,
4934         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_sec));
4935 }
4936 
4937 void Document::setCookieURL(const URL&amp; url)
4938 {
4939     if (m_cookieURL == url)
4940         return;
4941     m_cookieURL = url;
4942     invalidateDOMCookieCache();
4943 }
4944 
4945 static bool isValidNameNonASCII(const LChar* characters, unsigned length)
4946 {
4947     if (!isValidNameStart(characters[0]))
4948         return false;
4949 
4950     for (unsigned i = 1; i &lt; length; ++i) {
4951         if (!isValidNamePart(characters[i]))
4952             return false;
4953     }
4954 
4955     return true;
4956 }
4957 
4958 static bool isValidNameNonASCII(const UChar* characters, unsigned length)
4959 {
4960     unsigned i = 0;
4961 
4962     UChar32 c;
4963     U16_NEXT(characters, i, length, c);
4964     if (!isValidNameStart(c))
4965         return false;
4966 
4967     while (i &lt; length) {
4968         U16_NEXT(characters, i, length, c);
4969         if (!isValidNamePart(c))
4970             return false;
4971     }
4972 
4973     return true;
4974 }
4975 
4976 template&lt;typename CharType&gt;
4977 static inline bool isValidNameASCII(const CharType* characters, unsigned length)
4978 {
4979     CharType c = characters[0];
4980     if (!(isASCIIAlpha(c) || c == &#39;:&#39; || c == &#39;_&#39;))
4981         return false;
4982 
4983     for (unsigned i = 1; i &lt; length; ++i) {
4984         c = characters[i];
4985         if (!(isASCIIAlphanumeric(c) || c == &#39;:&#39; || c == &#39;_&#39; || c == &#39;-&#39; || c == &#39;.&#39;))
4986             return false;
4987     }
4988 
4989     return true;
4990 }
4991 
4992 bool Document::isValidName(const String&amp; name)
4993 {
4994     unsigned length = name.length();
4995     if (!length)
4996         return false;
4997 
4998     if (name.is8Bit()) {
4999         const LChar* characters = name.characters8();
5000 
5001         if (isValidNameASCII(characters, length))
5002             return true;
5003 
5004         return isValidNameNonASCII(characters, length);
5005     }
5006 
5007     const UChar* characters = name.characters16();
5008 
5009     if (isValidNameASCII(characters, length))
5010         return true;
5011 
5012     return isValidNameNonASCII(characters, length);
5013 }
5014 
5015 ExceptionOr&lt;std::pair&lt;AtomString, AtomString&gt;&gt; Document::parseQualifiedName(const String&amp; qualifiedName)
5016 {
5017     unsigned length = qualifiedName.length();
5018 
5019     if (!length)
5020         return Exception { InvalidCharacterError };
5021 
5022     bool nameStart = true;
5023     bool sawColon = false;
5024     unsigned colonPosition = 0;
5025 
5026     for (unsigned i = 0; i &lt; length; ) {
5027         UChar32 c;
5028         U16_NEXT(qualifiedName, i, length, c);
5029         if (c == &#39;:&#39;) {
5030             if (sawColon)
5031                 return Exception { InvalidCharacterError };
5032             nameStart = true;
5033             sawColon = true;
5034             colonPosition = i - 1;
5035         } else if (nameStart) {
5036             if (!isValidNameStart(c))
5037                 return Exception { InvalidCharacterError };
5038             nameStart = false;
5039         } else {
5040             if (!isValidNamePart(c))
5041                 return Exception { InvalidCharacterError };
5042         }
5043     }
5044 
5045     if (!sawColon)
5046         return std::pair&lt;AtomString, AtomString&gt; { { }, { qualifiedName } };
5047 
5048     if (!colonPosition || length - colonPosition &lt;= 1)
5049         return Exception { InvalidCharacterError };
5050 
5051     return std::pair&lt;AtomString, AtomString&gt; { StringView { qualifiedName }.substring(0, colonPosition).toAtomString(), StringView { qualifiedName }.substring(colonPosition + 1).toAtomString() };
5052 }
5053 
5054 ExceptionOr&lt;QualifiedName&gt; Document::parseQualifiedName(const AtomString&amp; namespaceURI, const String&amp; qualifiedName)
5055 {
5056     auto parseResult = parseQualifiedName(qualifiedName);
5057     if (parseResult.hasException())
5058         return parseResult.releaseException();
5059     auto parsedPieces = parseResult.releaseReturnValue();
5060     return QualifiedName { parsedPieces.first, parsedPieces.second, namespaceURI };
5061 }
5062 
5063 void Document::setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp; decoder)
5064 {
5065     m_decoder = WTFMove(decoder);
5066 }
5067 
5068 URL Document::completeURL(const String&amp; url, const URL&amp; baseURLOverride) const
5069 {
5070     // Always return a null URL when passed a null string.
5071     // FIXME: Should we change the URL constructor to have this behavior?
5072     // See also [CSS]StyleSheet::completeURL(const String&amp;)
5073     if (url.isNull())
5074         return URL();
5075     const URL&amp; baseURL = ((baseURLOverride.isEmpty() || baseURLOverride == WTF::blankURL()) &amp;&amp; parentDocument()) ? parentDocument()-&gt;baseURL() : baseURLOverride;
5076     if (!m_decoder)
5077         return URL(baseURL, url);
5078     return URL(baseURL, url, m_decoder-&gt;encodingForURLParsing());
5079 }
5080 
5081 URL Document::completeURL(const String&amp; url) const
5082 {
5083     return completeURL(url, m_baseURL);
5084 }
5085 
5086 PAL::SessionID Document::sessionID() const
5087 {
5088     return m_sessionID;
5089 }
5090 
5091 void Document::setPageCacheState(PageCacheState state)
5092 {
5093     if (m_pageCacheState == state)
5094         return;
5095 
5096     m_pageCacheState = state;
5097 
5098     FrameView* v = view();
5099     Page* page = this-&gt;page();
5100 
5101     switch (state) {
5102     case InPageCache:
5103         if (v) {
5104             // FIXME: There is some scrolling related work that needs to happen whenever a page goes into the
5105             // page cache and similar work that needs to occur when it comes out. This is where we do the work
5106             // that needs to happen when we enter, and the work that needs to happen when we exit is in
5107             // HistoryController::restoreScrollPositionAndViewState(). It can&#39;t be here because this function is
5108             // called too early on in the process of a page exiting the cache for that work to be possible in this
5109             // function. It would be nice if there was more symmetry here.
5110             // https://bugs.webkit.org/show_bug.cgi?id=98698
5111             v-&gt;cacheCurrentScrollPosition();
5112             if (page &amp;&amp; m_frame-&gt;isMainFrame()) {
5113                 v-&gt;resetScrollbarsAndClearContentsSize();
5114                 if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
5115                     scrollingCoordinator-&gt;clearAllNodes();
5116             }
5117         }
5118 
5119 #if ENABLE(POINTER_LOCK)
5120         exitPointerLock();
5121 #endif
5122 
5123         styleScope().clearResolver();
5124         clearSelectorQueryCache();
5125         m_styleRecalcTimer.stop();
5126 
5127         clearSharedObjectPool();
5128         break;
5129     case NotInPageCache:
5130         if (childNeedsStyleRecalc())
5131             scheduleStyleRecalc();
5132         break;
5133     case AboutToEnterPageCache:
5134         break;
5135     }
5136 }
5137 
5138 void Document::documentWillBecomeInactive()
5139 {
5140     if (renderView())
5141         renderView()-&gt;setIsInWindow(false);
5142 }
5143 
5144 void Document::suspend(ReasonForSuspension reason)
5145 {
5146     if (m_isSuspended)
5147         return;
5148 
5149     documentWillBecomeInactive();
5150 
5151     for (auto* element : m_documentSuspensionCallbackElements)
5152         element-&gt;prepareForDocumentSuspension();
5153 
5154 #ifndef NDEBUG
5155     // Clear the update flag to be able to check if the viewport arguments update
5156     // is dispatched, after the document is restored from the page cache.
5157     m_didDispatchViewportPropertiesChanged = false;
5158 #endif
5159 
5160     ASSERT(page());
5161     page()-&gt;lockAllOverlayScrollbarsToHidden(true);
5162 
5163     if (RenderView* view = renderView()) {
5164         if (view-&gt;usesCompositing())
5165             view-&gt;compositor().cancelCompositingLayerUpdate();
5166     }
5167 
5168 #if USE(LIBWEBRTC)
5169     // FIXME: This should be moved to Modules/mediastream.
5170     if (LibWebRTCProvider::webRTCAvailable()) {
5171         if (auto* page = this-&gt;page())
5172             page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
5173     }
5174 #endif
5175 
5176 #if ENABLE(SERVICE_WORKER)
5177     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::PageCache) {
5178         ASSERT_WITH_MESSAGE(!activeServiceWorker(), &quot;Documents with an active service worker should not go into PageCache in the first place&quot;);
5179         setServiceWorkerConnection(nullptr);
5180     }
5181 #endif
5182 
5183     suspendScheduledTasks(reason);
5184 
5185     ASSERT(m_frame);
5186     m_frame-&gt;clearTimers();
5187 
5188     m_visualUpdatesAllowed = false;
5189     m_visualUpdatesSuppressionTimer.stop();
5190 
5191     m_isSuspended = true;
5192 }
5193 
5194 void Document::resume(ReasonForSuspension reason)
5195 {
5196     if (!m_isSuspended)
5197         return;
5198 
5199     for (auto* element : copyToVector(m_documentSuspensionCallbackElements))
5200         element-&gt;resumeFromDocumentSuspension();
5201 
5202     if (renderView())
5203         renderView()-&gt;setIsInWindow(true);
5204 
5205     ASSERT(page());
5206     page()-&gt;lockAllOverlayScrollbarsToHidden(false);
5207 
5208     ASSERT(m_frame);
5209     m_frame-&gt;loader().client().dispatchDidBecomeFrameset(isFrameSet());
5210 
5211     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
5212         if (auto* timeline = existingTimeline())
5213             timeline-&gt;resumeAnimations();
5214     } else
5215         m_frame-&gt;animation().resumeAnimationsForDocument(this);
5216 
5217     resumeScheduledTasks(reason);
5218 
5219     m_visualUpdatesAllowed = true;
5220 
5221     m_isSuspended = false;
5222 
5223 #if ENABLE(SERVICE_WORKER)
5224     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::PageCache) {
5225         ASSERT_WITH_MESSAGE(!activeServiceWorker(), &quot;Documents with an active service worker should not go into PageCache in the first place&quot;);
5226         setServiceWorkerConnection(ServiceWorkerProvider::singleton().existingServiceWorkerConnectionForSession(sessionID()));
5227     }
5228 #endif
5229 }
5230 
5231 void Document::registerForDocumentSuspensionCallbacks(Element&amp; element)
5232 {
5233     m_documentSuspensionCallbackElements.add(&amp;element);
5234 }
5235 
5236 void Document::unregisterForDocumentSuspensionCallbacks(Element&amp; element)
5237 {
5238     m_documentSuspensionCallbackElements.remove(&amp;element);
5239 }
5240 
5241 void Document::mediaVolumeDidChange()
5242 {
5243     for (auto* element : m_mediaVolumeCallbackElements)
5244         element-&gt;mediaVolumeDidChange();
5245 }
5246 
5247 void Document::registerForMediaVolumeCallbacks(Element&amp; element)
5248 {
5249     m_mediaVolumeCallbackElements.add(&amp;element);
5250 }
5251 
5252 void Document::unregisterForMediaVolumeCallbacks(Element&amp; element)
5253 {
5254     m_mediaVolumeCallbackElements.remove(&amp;element);
5255 }
5256 
5257 bool Document::audioPlaybackRequiresUserGesture() const
5258 {
5259     if (DocumentLoader* loader = this-&gt;loader()) {
5260         // If an audio playback policy was set during navigation, use it. If not, use the global settings.
5261         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5262         if (policy != AutoplayPolicy::Default)
5263             return policy == AutoplayPolicy::AllowWithoutSound || policy == AutoplayPolicy::Deny;
5264     }
5265 
5266     return settings().audioPlaybackRequiresUserGesture();
5267 }
5268 
5269 bool Document::videoPlaybackRequiresUserGesture() const
5270 {
5271     if (DocumentLoader* loader = this-&gt;loader()) {
5272         // If a video playback policy was set during navigation, use it. If not, use the global settings.
5273         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5274         if (policy != AutoplayPolicy::Default)
5275             return policy == AutoplayPolicy::Deny;
5276     }
5277 
5278     return settings().videoPlaybackRequiresUserGesture();
5279 }
5280 
5281 void Document::storageBlockingStateDidChange()
5282 {
5283     securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
5284 }
5285 
5286 void Document::privateBrowsingStateDidChange(PAL::SessionID sessionID)
5287 {
5288     m_sessionID = sessionID;
5289     if (m_logger)
5290         m_logger-&gt;setEnabled(this, sessionID.isAlwaysOnLoggingAllowed());
5291 
5292     for (auto* element : m_privateBrowsingStateChangedElements)
5293         element-&gt;privateBrowsingStateDidChange(sessionID);
5294 
5295 #if ENABLE(SERVICE_WORKER)
5296     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; m_serviceWorkerConnection)
5297         setServiceWorkerConnection(&amp;ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID));
5298 #endif
5299 }
5300 
5301 void Document::registerForPrivateBrowsingStateChangedCallbacks(Element&amp; element)
5302 {
5303     m_privateBrowsingStateChangedElements.add(&amp;element);
5304 }
5305 
5306 void Document::unregisterForPrivateBrowsingStateChangedCallbacks(Element&amp; element)
5307 {
5308     m_privateBrowsingStateChangedElements.remove(&amp;element);
5309 }
5310 
5311 #if ENABLE(VIDEO_TRACK)
5312 
5313 void Document::registerForCaptionPreferencesChangedCallbacks(Element&amp; element)
5314 {
5315     if (page())
5316         page()-&gt;group().captionPreferences().setInterestedInCaptionPreferenceChanges();
5317 
5318     m_captionPreferencesChangedElements.add(&amp;element);
5319 }
5320 
5321 void Document::unregisterForCaptionPreferencesChangedCallbacks(Element&amp; element)
5322 {
5323     m_captionPreferencesChangedElements.remove(&amp;element);
5324 }
5325 
5326 void Document::captionPreferencesChanged()
5327 {
5328     for (auto* element : m_captionPreferencesChangedElements)
5329         element-&gt;captionPreferencesChanged();
5330 }
5331 
5332 #endif
5333 
5334 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
5335 
5336 void Document::registerForPageScaleFactorChangedCallbacks(HTMLMediaElement&amp; element)
5337 {
5338     m_pageScaleFactorChangedElements.add(&amp;element);
5339 }
5340 
5341 void Document::unregisterForPageScaleFactorChangedCallbacks(HTMLMediaElement&amp; element)
5342 {
5343     m_pageScaleFactorChangedElements.remove(&amp;element);
5344 }
5345 
5346 void Document::pageScaleFactorChangedAndStable()
5347 {
5348     for (HTMLMediaElement* mediaElement : m_pageScaleFactorChangedElements)
5349         mediaElement-&gt;pageScaleFactorChanged();
5350 }
5351 
5352 void Document::registerForUserInterfaceLayoutDirectionChangedCallbacks(HTMLMediaElement&amp; element)
5353 {
5354     m_userInterfaceLayoutDirectionChangedElements.add(&amp;element);
5355 }
5356 
5357 void Document::unregisterForUserInterfaceLayoutDirectionChangedCallbacks(HTMLMediaElement&amp; element)
5358 {
5359     m_userInterfaceLayoutDirectionChangedElements.remove(&amp;element);
5360 }
5361 
5362 void Document::userInterfaceLayoutDirectionChanged()
5363 {
5364     for (auto* mediaElement : m_userInterfaceLayoutDirectionChangedElements)
5365         mediaElement-&gt;userInterfaceLayoutDirectionChanged();
5366 }
5367 
5368 #endif
5369 
5370 void Document::setShouldCreateRenderers(bool f)
5371 {
5372     m_createRenderers = f;
5373 }
5374 
5375 bool Document::shouldCreateRenderers()
5376 {
5377     return m_createRenderers;
5378 }
5379 
5380 // Support for Javascript execCommand, and related methods
5381 
5382 static Editor::Command command(Document* document, const String&amp; commandName, bool userInterface = false)
5383 {
5384     auto protectedDocument = makeRef(*document);
5385 
5386     document-&gt;updateStyleIfNeeded();
5387 
5388     auto frame = makeRefPtr(document-&gt;frame());
5389 
5390     if (!frame || frame-&gt;document() != document)
5391         return Editor::Command();
5392 
5393     return frame-&gt;editor().command(commandName,
5394         userInterface ? CommandFromDOMWithUserInterface : CommandFromDOM);
5395 }
5396 
5397 bool Document::execCommand(const String&amp; commandName, bool userInterface, const String&amp; value)
5398 {
5399     EventQueueScope eventQueueScope;
5400     return command(this, commandName, userInterface).execute(value);
5401 }
5402 
5403 bool Document::queryCommandEnabled(const String&amp; commandName)
5404 {
5405     return command(this, commandName).isEnabled();
5406 }
5407 
5408 bool Document::queryCommandIndeterm(const String&amp; commandName)
5409 {
5410     return command(this, commandName).state() == MixedTriState;
5411 }
5412 
5413 bool Document::queryCommandState(const String&amp; commandName)
5414 {
5415     return command(this, commandName).state() == TrueTriState;
5416 }
5417 
5418 bool Document::queryCommandSupported(const String&amp; commandName)
5419 {
5420     return command(this, commandName).isSupported();
5421 }
5422 
5423 String Document::queryCommandValue(const String&amp; commandName)
5424 {
5425     return command(this, commandName).value();
5426 }
5427 
5428 void Document::pushCurrentScript(HTMLScriptElement* newCurrentScript)
5429 {
5430     m_currentScriptStack.append(newCurrentScript);
5431 }
5432 
5433 void Document::popCurrentScript()
5434 {
5435     ASSERT(!m_currentScriptStack.isEmpty());
5436     m_currentScriptStack.removeLast();
5437 }
5438 
5439 bool Document::shouldDeferAsynchronousScriptsUntilParsingFinishes() const
5440 {
5441     return parsing() &amp;&amp; settings().shouldDeferAsynchronousScriptsUntilAfterDocumentLoad();
5442 }
5443 
5444 #if ENABLE(XSLT)
5445 
5446 void Document::scheduleToApplyXSLTransforms()
5447 {
5448     m_hasPendingXSLTransforms = true;
5449     if (!m_applyPendingXSLTransformsTimer.isActive())
5450         m_applyPendingXSLTransformsTimer.startOneShot(0_s);
5451 }
5452 
5453 void Document::applyPendingXSLTransformsNowIfScheduled()
5454 {
5455     if (!m_hasPendingXSLTransforms)
5456         return;
5457     m_applyPendingXSLTransformsTimer.stop();
5458     applyPendingXSLTransformsTimerFired();
5459 }
5460 
5461 void Document::applyPendingXSLTransformsTimerFired()
5462 {
5463     if (parsing())
5464         return;
5465 
5466     m_hasPendingXSLTransforms = false;
5467     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
5468     for (auto&amp; processingInstruction : styleScope().collectXSLTransforms()) {
5469         ASSERT(processingInstruction-&gt;isXSL());
5470 
5471         // Don&#39;t apply XSL transforms to already transformed documents -- &lt;rdar://problem/4132806&gt;
5472         if (transformSourceDocument() || !processingInstruction-&gt;sheet())
5473             return;
5474 
5475         // If the Document has already been detached from the frame, or the frame is currently in the process of
5476         // changing to a new document, don&#39;t attempt to create a new Document from the XSLT.
5477         if (!frame() || frame()-&gt;documentIsBeingReplaced())
5478             return;
5479 
5480         auto processor = XSLTProcessor::create();
5481         processor-&gt;setXSLStyleSheet(downcast&lt;XSLStyleSheet&gt;(processingInstruction-&gt;sheet()));
5482         String resultMIMEType;
5483         String newSource;
5484         String resultEncoding;
5485         if (!processor-&gt;transformToString(*this, resultMIMEType, newSource, resultEncoding))
5486             continue;
5487         // FIXME: If the transform failed we should probably report an error (like Mozilla does).
5488         processor-&gt;createDocumentFromSource(newSource, resultEncoding, resultMIMEType, this, frame());
5489     }
5490 }
5491 
5492 void Document::setTransformSource(std::unique_ptr&lt;TransformSource&gt; source)
5493 {
5494     m_transformSource = WTFMove(source);
5495 }
5496 
5497 #endif
5498 
5499 void Document::setDesignMode(InheritedBool value)
5500 {
5501     m_designMode = value;
5502     for (Frame* frame = m_frame; frame &amp;&amp; frame-&gt;document(); frame = frame-&gt;tree().traverseNext(m_frame))
5503         frame-&gt;document()-&gt;scheduleFullStyleRebuild();
5504 }
5505 
5506 String Document::designMode() const
5507 {
5508     return inDesignMode() ? &quot;on&quot;_s : &quot;off&quot;_s;
5509 }
5510 
5511 void Document::setDesignMode(const String&amp; value)
5512 {
5513     InheritedBool mode;
5514     if (equalLettersIgnoringASCIICase(value, &quot;on&quot;))
5515         mode = on;
5516     else if (equalLettersIgnoringASCIICase(value, &quot;off&quot;))
5517         mode = off;
5518     else
5519         mode = inherit;
5520     setDesignMode(mode);
5521 }
5522 
5523 auto Document::getDesignMode() const -&gt; InheritedBool
5524 {
5525     return m_designMode;
5526 }
5527 
5528 bool Document::inDesignMode() const
5529 {
5530     for (const Document* d = this; d; d = d-&gt;parentDocument()) {
5531         if (d-&gt;m_designMode != inherit)
5532             return d-&gt;m_designMode;
5533     }
5534     return false;
5535 }
5536 
5537 Document* Document::parentDocument() const
5538 {
5539     if (!m_frame)
5540         return nullptr;
5541     Frame* parent = m_frame-&gt;tree().parent();
5542     if (!parent)
5543         return nullptr;
5544     return parent-&gt;document();
5545 }
5546 
5547 Document&amp; Document::topDocument() const
5548 {
5549     // FIXME: This special-casing avoids incorrectly determined top documents during the process
5550     // of AXObjectCache teardown or notification posting for cached or being-destroyed documents.
5551     if (pageCacheState() == NotInPageCache &amp;&amp; !m_renderTreeBeingDestroyed) {
5552         if (!m_frame)
5553             return const_cast&lt;Document&amp;&gt;(*this);
5554         // This should always be non-null.
5555         Document* mainFrameDocument = m_frame-&gt;mainFrame().document();
5556         return mainFrameDocument ? *mainFrameDocument : const_cast&lt;Document&amp;&gt;(*this);
5557     }
5558 
5559     Document* document = const_cast&lt;Document*&gt;(this);
5560     while (HTMLFrameOwnerElement* element = document-&gt;ownerElement())
5561         document = &amp;element-&gt;document();
5562     return *document;
5563 }
5564 
5565 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttribute(const String&amp; name)
5566 {
5567     return createAttributeNS({ }, isHTMLDocument() ? name.convertToASCIILowercase() : name, true);
5568 }
5569 
5570 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttributeNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks)
5571 {
5572     auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
5573     if (parseResult.hasException())
5574         return parseResult.releaseException();
5575     QualifiedName parsedName { parseResult.releaseReturnValue() };
5576     if (!shouldIgnoreNamespaceChecks &amp;&amp; !hasValidNamespaceForAttributes(parsedName))
5577         return Exception { NamespaceError };
5578     return Attr::create(*this, parsedName, emptyString());
5579 }
5580 
5581 const SVGDocumentExtensions* Document::svgExtensions()
5582 {
5583     return m_svgExtensions.get();
5584 }
5585 
5586 SVGDocumentExtensions&amp; Document::accessSVGExtensions()
5587 {
5588     if (!m_svgExtensions)
5589         m_svgExtensions = makeUnique&lt;SVGDocumentExtensions&gt;(*this);
5590     return *m_svgExtensions;
5591 }
5592 
5593 void Document::addSVGUseElement(SVGUseElement&amp; element)
5594 {
5595     auto result = m_svgUseElements.add(&amp;element);
5596     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(result.isNewEntry);
5597 }
5598 
5599 void Document::removeSVGUseElement(SVGUseElement&amp; element)
5600 {
5601     m_svgUseElements.remove(&amp;element);
5602     // FIXME: Assert that element was in m_svgUseElements once re-entrancy to update style and layout have been removed.
5603 }
5604 
5605 bool Document::hasSVGRootNode() const
5606 {
5607     return documentElement() &amp;&amp; documentElement()-&gt;hasTagName(SVGNames::svgTag);
5608 }
5609 
5610 template &lt;CollectionType collectionType&gt;
5611 Ref&lt;HTMLCollection&gt; Document::ensureCachedCollection()
5612 {
5613     return ensureRareData().ensureNodeLists().addCachedCollection&lt;GenericCachedHTMLCollection&lt;CollectionTypeTraits&lt;collectionType&gt;::traversalType&gt;&gt;(*this, collectionType);
5614 }
5615 
5616 Ref&lt;HTMLCollection&gt; Document::images()
5617 {
5618     return ensureCachedCollection&lt;DocImages&gt;();
5619 }
5620 
5621 Ref&lt;HTMLCollection&gt; Document::applets()
5622 {
5623     return ensureCachedCollection&lt;DocApplets&gt;();
5624 }
5625 
5626 Ref&lt;HTMLCollection&gt; Document::embeds()
5627 {
5628     return ensureCachedCollection&lt;DocEmbeds&gt;();
5629 }
5630 
5631 Ref&lt;HTMLCollection&gt; Document::plugins()
5632 {
5633     // This is an alias for embeds() required for the JS DOM bindings.
5634     return ensureCachedCollection&lt;DocEmbeds&gt;();
5635 }
5636 
5637 Ref&lt;HTMLCollection&gt; Document::scripts()
5638 {
5639     return ensureCachedCollection&lt;DocScripts&gt;();
5640 }
5641 
5642 Ref&lt;HTMLCollection&gt; Document::links()
5643 {
5644     return ensureCachedCollection&lt;DocLinks&gt;();
5645 }
5646 
5647 Ref&lt;HTMLCollection&gt; Document::forms()
5648 {
5649     return ensureCachedCollection&lt;DocForms&gt;();
5650 }
5651 
5652 Ref&lt;HTMLCollection&gt; Document::anchors()
5653 {
5654     return ensureCachedCollection&lt;DocAnchors&gt;();
5655 }
5656 
5657 Ref&lt;HTMLCollection&gt; Document::all()
5658 {
5659     return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllCollection&gt;(*this, DocAll);
5660 }
5661 
5662 Ref&lt;HTMLCollection&gt; Document::allFilteredByName(const AtomString&amp; name)
5663 {
5664     return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllNamedSubCollection&gt;(*this, DocumentAllNamedItems, name);
5665 }
5666 
5667 Ref&lt;HTMLCollection&gt; Document::windowNamedItems(const AtomString&amp; name)
5668 {
5669     return ensureRareData().ensureNodeLists().addCachedCollection&lt;WindowNameCollection&gt;(*this, WindowNamedItems, name);
5670 }
5671 
5672 Ref&lt;HTMLCollection&gt; Document::documentNamedItems(const AtomString&amp; name)
5673 {
5674     return ensureRareData().ensureNodeLists().addCachedCollection&lt;DocumentNameCollection&gt;(*this, DocumentNamedItems, name);
5675 }
5676 
5677 void Document::finishedParsing()
5678 {
5679     ASSERT(!scriptableDocumentParser() || !m_parser-&gt;isParsing());
5680     ASSERT(!scriptableDocumentParser() || m_readyState != Loading);
5681     setParsing(false);
5682 
5683     Ref&lt;Document&gt; protectedThis(*this);
5684 
5685     scriptRunner().documentFinishedParsing();
5686 
5687     if (!m_documentTiming.domContentLoadedEventStart)
5688         m_documentTiming.domContentLoadedEventStart = MonotonicTime::now();
5689 
5690     if (!page() || !page()-&gt;isForSanitizingWebContent()) {
5691         // FIXME: Schedule a task to fire DOMContentLoaded event instead. See webkit.org/b/82931
5692         MicrotaskQueue::mainThreadQueue().performMicrotaskCheckpoint();
5693     }
5694 
5695     dispatchEvent(Event::create(eventNames().DOMContentLoadedEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
5696 
5697     if (!m_documentTiming.domContentLoadedEventEnd)
5698         m_documentTiming.domContentLoadedEventEnd = MonotonicTime::now();
5699 
5700     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
5701 #if ENABLE(XSLT)
5702         applyPendingXSLTransformsNowIfScheduled();
5703 #endif
5704 
5705         // FrameLoader::finishedParsing() might end up calling Document::implicitClose() if all
5706         // resource loads are complete. HTMLObjectElements can start loading their resources from
5707         // post attach callbacks triggered by resolveStyle(). This means if we parse out an &lt;object&gt;
5708         // tag and then reach the end of the document without updating styles, we might not have yet
5709         // started the resource load and might fire the window load event too early. To avoid this
5710         // we force the styles to be up to date before calling FrameLoader::finishedParsing().
5711         // See https://bugs.webkit.org/show_bug.cgi?id=36864 starting around comment 35.
5712         updateStyleIfNeeded();
5713 
5714         frame-&gt;loader().finishedParsing();
5715         InspectorInstrumentation::domContentLoadedEventFired(*frame);
5716     }
5717 
5718     // Schedule dropping of the DocumentSharedObjectPool. We keep it alive for a while after parsing finishes
5719     // so that dynamically inserted content can also benefit from sharing optimizations.
5720     // Note that we don&#39;t refresh the timer on pool access since that could lead to huge caches being kept
5721     // alive indefinitely by something innocuous like JS setting .innerHTML repeatedly on a timer.
5722     static const Seconds timeToKeepSharedObjectPoolAliveAfterParsingFinished { 10_s };
5723     m_sharedObjectPoolClearTimer.startOneShot(timeToKeepSharedObjectPoolAliveAfterParsingFinished);
5724 
5725     // Parser should have picked up all speculative preloads by now
5726     m_cachedResourceLoader-&gt;clearPreloads(CachedResourceLoader::ClearPreloadsMode::ClearSpeculativePreloads);
5727 }
5728 
5729 void Document::clearSharedObjectPool()
5730 {
5731     m_sharedObjectPool = nullptr;
5732     m_sharedObjectPoolClearTimer.stop();
5733 }
5734 
5735 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
5736 
5737 // FIXME: Find a better place for this code.
5738 
5739 bool Document::isTelephoneNumberParsingEnabled() const
5740 {
5741     return settings().telephoneNumberParsingEnabled() &amp;&amp; m_isTelephoneNumberParsingAllowed;
5742 }
5743 
5744 bool Document::isTelephoneNumberParsingAllowed() const
5745 {
5746     return m_isTelephoneNumberParsingAllowed;
5747 }
5748 
5749 #endif
5750 
5751 String Document::originIdentifierForPasteboard() const
5752 {
5753     auto origin = securityOrigin().toString();
5754     if (origin != &quot;null&quot;)
5755         return origin;
5756     if (!m_uniqueIdentifier)
5757         m_uniqueIdentifier = &quot;null:&quot; + createCanonicalUUIDString();
5758     return m_uniqueIdentifier;
5759 }
5760 
5761 ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; Document::createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver)
5762 {
5763     if (!m_xpathEvaluator)
5764         m_xpathEvaluator = XPathEvaluator::create();
5765     return m_xpathEvaluator-&gt;createExpression(expression, WTFMove(resolver));
5766 }
5767 
5768 Ref&lt;XPathNSResolver&gt; Document::createNSResolver(Node* nodeResolver)
5769 {
5770     if (!m_xpathEvaluator)
5771         m_xpathEvaluator = XPathEvaluator::create();
5772     return m_xpathEvaluator-&gt;createNSResolver(nodeResolver);
5773 }
5774 
5775 ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; Document::evaluate(const String&amp; expression, Node* contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver, unsigned short type, XPathResult* result)
5776 {
5777     if (!m_xpathEvaluator)
5778         m_xpathEvaluator = XPathEvaluator::create();
5779     return m_xpathEvaluator-&gt;evaluate(expression, contextNode, WTFMove(resolver), type, result);
5780 }
5781 
5782 void Document::initSecurityContext()
5783 {
5784     if (haveInitializedSecurityOrigin()) {
5785         ASSERT(SecurityContext::securityOrigin());
5786         return;
5787     }
5788 
5789     if (!m_frame) {
5790         // No source for a security context.
5791         // This can occur via document.implementation.createDocument().
5792         setCookieURL(URL({ }, emptyString()));
5793         setSecurityOriginPolicy(SecurityOriginPolicy::create(SecurityOrigin::createUnique()));
5794         setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { { }, emptyString() }, *this));
5795         return;
5796     }
5797 
5798     // In the common case, create the security context from the currently
5799     // loading URL with a fresh content security policy.
5800     setCookieURL(m_url);
5801     enforceSandboxFlags(m_frame-&gt;loader().effectiveSandboxFlags());
5802     setReferrerPolicy(m_frame-&gt;loader().effectiveReferrerPolicy());
5803 
5804     if (shouldEnforceContentDispositionAttachmentSandbox())
5805         applyContentDispositionAttachmentSandbox();
5806 
5807     auto* documentLoader = m_frame-&gt;loader().documentLoader();
5808     bool isSecurityOriginUnique = isSandboxed(SandboxOrigin);
5809     if (!isSecurityOriginUnique)
5810         isSecurityOriginUnique = documentLoader &amp;&amp; documentLoader-&gt;response().tainting() == ResourceResponse::Tainting::Opaque;
5811 
5812     setSecurityOriginPolicy(SecurityOriginPolicy::create(isSecurityOriginUnique ? SecurityOrigin::createUnique() : SecurityOrigin::create(m_url)));
5813     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));
5814 
5815     String overrideContentSecurityPolicy = m_frame-&gt;loader().client().overrideContentSecurityPolicy();
5816     if (!overrideContentSecurityPolicy.isNull())
5817         contentSecurityPolicy()-&gt;didReceiveHeader(overrideContentSecurityPolicy, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::API, referrer(), documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0);
5818 
5819 #if USE(QUICK_LOOK)
5820     if (shouldEnforceQuickLookSandbox())
5821         applyQuickLookSandbox();
5822 #endif
5823 
5824     if (shouldEnforceHTTP09Sandbox()) {
5825         String message = makeString(&quot;Sandboxing &#39;&quot;, m_url.stringCenterEllipsizedToLength(), &quot;&#39; because it is using HTTP/0.9.&quot;);
5826         addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
5827         enforceSandboxFlags(SandboxScripts | SandboxPlugins);
5828     }
5829 
5830     if (settings().needsStorageAccessFromFileURLsQuirk())
5831         securityOrigin().grantStorageAccessFromFileURLsQuirk();
5832     if (!settings().webSecurityEnabled()) {
5833         // Web security is turned off. We should let this document access every other document. This is used primary by testing
5834         // harnesses for web sites.
5835         securityOrigin().grantUniversalAccess();
5836     } else if (securityOrigin().isLocal()) {
5837         if (settings().allowUniversalAccessFromFileURLs() || m_frame-&gt;loader().client().shouldForceUniversalAccessFromLocalURL(m_url)) {
5838             // Some clients want local URLs to have universal access, but that setting is dangerous for other clients.
5839             securityOrigin().grantUniversalAccess();
5840         } else if (!settings().allowFileAccessFromFileURLs()) {
5841             // Some clients want local URLs to have even tighter restrictions by default, and not be able to access other local files.
5842             // FIXME 81578: The naming of this is confusing. Files with restricted access to other local files
5843             // still can have other privileges that can be remembered, thereby not making them unique origins.
5844             securityOrigin().setEnforcesFilePathSeparation();
5845         }
5846     }
5847     securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
5848 
5849     Document* parentDocument = ownerElement() ? &amp;ownerElement()-&gt;document() : nullptr;
5850     if (parentDocument &amp;&amp; m_frame-&gt;loader().shouldTreatURLAsSrcdocDocument(url())) {
5851         m_isSrcdocDocument = true;
5852         setBaseURLOverride(parentDocument-&gt;baseURL());
5853     }
5854     if (parentDocument)
5855         setStrictMixedContentMode(parentDocument-&gt;isStrictMixedContentMode());
5856 
5857     if (!SecurityPolicy::shouldInheritSecurityOriginFromOwner(m_url))
5858         return;
5859 
5860     // If we do not obtain a meaningful origin from the URL, then we try to
5861     // find one via the frame hierarchy.
5862     Frame* parentFrame = m_frame-&gt;tree().parent();
5863     Frame* openerFrame = m_frame-&gt;loader().opener();
5864 
5865     Frame* ownerFrame = parentFrame;
5866     if (!ownerFrame)
5867         ownerFrame = openerFrame;
5868 
5869     if (!ownerFrame) {
5870         didFailToInitializeSecurityOrigin();
5871         return;
5872     }
5873 
5874     Document* openerDocument = openerFrame ? openerFrame-&gt;document() : nullptr;
5875 
5876     // Per &lt;http://www.w3.org/TR/upgrade-insecure-requests/&gt;, new browsing contexts must inherit from an
5877     // ongoing set of upgraded requests. When opening a new browsing context, we need to capture its
5878     // existing upgrade request. Nested browsing contexts are handled during DocumentWriter::begin.
5879     if (openerDocument)
5880         contentSecurityPolicy()-&gt;inheritInsecureNavigationRequestsToUpgradeFromOpener(*openerDocument-&gt;contentSecurityPolicy());
5881 
5882     if (isSandboxed(SandboxOrigin)) {
5883         // If we&#39;re supposed to inherit our security origin from our owner,
5884         // but we&#39;re also sandboxed, the only thing we inherit is the ability
5885         // to load local resources. This lets about:blank iframes in file://
5886         // URL documents load images and other resources from the file system.
5887         if (ownerFrame-&gt;document()-&gt;securityOrigin().canLoadLocalResources())
5888             securityOrigin().grantLoadLocalResources();
5889         return;
5890     }
5891 
5892     setCookieURL(ownerFrame-&gt;document()-&gt;cookieURL());
5893     // We alias the SecurityOrigins to match Firefox, see Bug 15313
5894     // https://bugs.webkit.org/show_bug.cgi?id=15313
5895     setSecurityOriginPolicy(ownerFrame-&gt;document()-&gt;securityOriginPolicy());
5896 }
5897 
5898 // FIXME: The current criterion is stricter than &lt;https://www.w3.org/TR/CSP3/#security-inherit-csp&gt; (Editor&#39;s Draft, 28 February 2019).
5899 bool Document::shouldInheritContentSecurityPolicy() const
5900 {
5901     ASSERT(m_frame);
5902     if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(m_url))
5903         return true;
5904     if (m_url.protocolIsData() || m_url.protocolIsBlob())
5905         return true;
5906     if (!isPluginDocument())
5907         return false;
5908     if (m_frame-&gt;tree().parent())
5909         return true;
5910     Frame* openerFrame = m_frame-&gt;loader().opener();
5911     if (!openerFrame)
5912         return false;
5913     return openerFrame-&gt;document()-&gt;securityOrigin().canAccess(securityOrigin());
5914 }
5915 
5916 void Document::initContentSecurityPolicy(ContentSecurityPolicy* previousPolicy)
5917 {
5918     // 1. Inherit Upgrade Insecure Requests
5919     Frame* parentFrame = m_frame-&gt;tree().parent();
5920     if (parentFrame)
5921         contentSecurityPolicy()-&gt;copyUpgradeInsecureRequestStateFrom(*parentFrame-&gt;document()-&gt;contentSecurityPolicy());
5922 
5923     // 2. Inherit Content Security Policy (without copying Upgrade Insecure Requests state).
5924     if (!shouldInheritContentSecurityPolicy())
5925         return;
5926     ContentSecurityPolicy* ownerPolicy = nullptr;
5927     if (previousPolicy &amp;&amp; (m_url.protocolIsData() || m_url.protocolIsBlob()))
5928         ownerPolicy = previousPolicy;
5929     if (!ownerPolicy) {
5930         Frame* ownerFrame = parentFrame;
5931         if (!ownerFrame)
5932             ownerFrame = m_frame-&gt;loader().opener();
5933         if (ownerFrame)
5934             ownerPolicy = ownerFrame-&gt;document()-&gt;contentSecurityPolicy();
5935     }
5936     if (!ownerPolicy)
5937         return;
5938     // FIXME: We are stricter than the CSP 3 spec. with regards to plugins: we prefer to inherit the full policy unless the plugin
5939     // document is opened in a new window. The CSP 3 spec. implies that only plugin documents delivered with a local scheme (e.g. blob,
5940     // file, data) should inherit a policy.
5941     if (isPluginDocument() &amp;&amp; m_frame-&gt;loader().opener())
5942         contentSecurityPolicy()-&gt;createPolicyForPluginDocumentFrom(*ownerPolicy);
5943     else
5944         contentSecurityPolicy()-&gt;copyStateFrom(ownerPolicy);
5945 }
5946 
5947 bool Document::isContextThread() const
5948 {
5949     return isMainThread();
5950 }
5951 
5952 bool Document::isSecureContext() const
5953 {
5954     if (!m_frame)
5955         return true;
5956     if (!RuntimeEnabledFeatures::sharedFeatures().secureContextChecksEnabled())
5957         return true;
5958     if (!securityOrigin().isPotentiallyTrustworthy())
5959         return false;
5960     for (Frame* frame = m_frame-&gt;tree().parent(); frame; frame = frame-&gt;tree().parent()) {
5961         if (!frame-&gt;document()-&gt;securityOrigin().isPotentiallyTrustworthy())
5962             return false;
5963     }
5964     return true;
5965 }
5966 
5967 void Document::updateURLForPushOrReplaceState(const URL&amp; url)
5968 {
5969     Frame* f = frame();
5970     if (!f)
5971         return;
5972 
5973     setURL(url);
5974     f-&gt;loader().setOutgoingReferrer(url);
5975 
5976     if (DocumentLoader* documentLoader = loader())
5977         documentLoader-&gt;replaceRequestURLForSameDocumentNavigation(url);
5978 }
5979 
5980 void Document::statePopped(Ref&lt;SerializedScriptValue&gt;&amp;&amp; stateObject)
5981 {
5982     if (!frame())
5983         return;
5984 
5985     // Per step 11 of section 6.5.9 (history traversal) of the HTML5 spec, we
5986     // defer firing of popstate until we&#39;re in the complete state.
5987     if (m_readyState == Complete)
5988         dispatchPopstateEvent(WTFMove(stateObject));
5989     else
5990         m_pendingStateObject = WTFMove(stateObject);
5991 }
5992 
5993 void Document::attachRange(Range&amp; range)
5994 {
5995     ASSERT(!m_ranges.contains(&amp;range));
5996     m_ranges.add(&amp;range);
5997 }
5998 
5999 void Document::detachRange(Range&amp; range)
6000 {
6001     // We don&#39;t ASSERT m_ranges.contains(&amp;range) to allow us to call this
6002     // unconditionally to fix: https://bugs.webkit.org/show_bug.cgi?id=26044
6003     m_ranges.remove(&amp;range);
6004 }
6005 
6006 Optional&lt;RenderingContext&gt; Document::getCSSCanvasContext(const String&amp; type, const String&amp; name, int width, int height)
6007 {
6008     HTMLCanvasElement* element = getCSSCanvasElement(name);
6009     if (!element)
6010         return WTF::nullopt;
6011     element-&gt;setSize({ width, height });
6012     auto context = element-&gt;getContext(type);
6013     if (!context)
6014         return WTF::nullopt;
6015 
6016 #if ENABLE(WEBGL)
6017     if (is&lt;WebGLRenderingContext&gt;(*context))
6018         return RenderingContext { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*context) } };
6019 #endif
6020 #if ENABLE(WEBGL2)
6021     if (is&lt;WebGL2RenderingContext&gt;(*context))
6022         return RenderingContext { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*context) } };
6023 #endif
6024 #if ENABLE(WEBGPU)
6025     if (is&lt;GPUCanvasContext&gt;(*context))
6026         return RenderingContext { RefPtr&lt;GPUCanvasContext&gt; { &amp;downcast&lt;GPUCanvasContext&gt;(*context) } };
6027 #endif
6028 
6029     return RenderingContext { RefPtr&lt;CanvasRenderingContext2D&gt; { &amp;downcast&lt;CanvasRenderingContext2D&gt;(*context) } };
6030 }
6031 
6032 HTMLCanvasElement* Document::getCSSCanvasElement(const String&amp; name)
6033 {
6034     RefPtr&lt;HTMLCanvasElement&gt;&amp; element = m_cssCanvasElements.add(name, nullptr).iterator-&gt;value;
6035     if (!element)
6036         element = HTMLCanvasElement::create(*this);
6037     return element.get();
6038 }
6039 
6040 String Document::nameForCSSCanvasElement(const HTMLCanvasElement&amp; canvasElement) const
6041 {
6042     for (const auto&amp; entry : m_cssCanvasElements) {
6043         if (entry.value.get() == &amp;canvasElement)
6044             return entry.key;
6045     }
6046     return String();
6047 }
6048 
6049 #if ENABLE(TEXT_AUTOSIZING)
6050 TextAutoSizing&amp; Document::textAutoSizing()
6051 {
6052     if (!m_textAutoSizing)
6053         m_textAutoSizing = makeUnique&lt;TextAutoSizing&gt;();
6054     return *m_textAutoSizing;
6055 }
6056 #endif // ENABLE(TEXT_AUTOSIZING)
6057 
6058 void Document::initDNSPrefetch()
6059 {
6060     m_haveExplicitlyDisabledDNSPrefetch = false;
6061     m_isDNSPrefetchEnabled = settings().dnsPrefetchingEnabled() &amp;&amp; securityOrigin().protocol() == &quot;http&quot;;
6062 
6063     // Inherit DNS prefetch opt-out from parent frame
6064     if (Document* parent = parentDocument()) {
6065         if (!parent-&gt;isDNSPrefetchEnabled())
6066             m_isDNSPrefetchEnabled = false;
6067     }
6068 }
6069 
6070 void Document::parseDNSPrefetchControlHeader(const String&amp; dnsPrefetchControl)
6071 {
6072     if (!settings().dnsPrefetchingEnabled())
6073         return;
6074 
6075     if (equalLettersIgnoringASCIICase(dnsPrefetchControl, &quot;on&quot;) &amp;&amp; !m_haveExplicitlyDisabledDNSPrefetch) {
6076         m_isDNSPrefetchEnabled = true;
6077         return;
6078     }
6079 
6080     m_isDNSPrefetchEnabled = false;
6081     m_haveExplicitlyDisabledDNSPrefetch = true;
6082 }
6083 
6084 void Document::getParserLocation(String&amp; completedURL, unsigned&amp; line, unsigned&amp; column) const
6085 {
6086     // We definitely cannot associate the message with a location being parsed if we are not even parsing.
6087     if (!parsing())
6088         return;
6089 
6090     ScriptableDocumentParser* parser = scriptableDocumentParser();
6091     if (!parser)
6092         return;
6093 
6094     // When the parser waits for scripts, any messages must be coming from some other source, and are not related to the location of the script element that made the parser wait.
6095     if (!parser-&gt;shouldAssociateConsoleMessagesWithTextPosition())
6096         return;
6097 
6098     completedURL = url().string();
6099     TextPosition position = parser-&gt;textPosition();
6100     line = position.m_line.oneBasedInt();
6101     column = position.m_column.oneBasedInt();
6102 }
6103 
6104 void Document::addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; consoleMessage)
6105 {
6106     if (!isContextThread()) {
6107         postTask(AddConsoleMessageTask(WTFMove(consoleMessage)));
6108         return;
6109     }
6110 
6111     if (Page* page = this-&gt;page())
6112         page-&gt;console().addMessage(WTFMove(consoleMessage));
6113 }
6114 
6115 void Document::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, unsigned long requestIdentifier)
6116 {
6117     if (!isContextThread()) {
6118         postTask(AddConsoleMessageTask(source, level, message));
6119         return;
6120     }
6121 
6122     if (Page* page = this-&gt;page())
6123         page-&gt;console().addMessage(source, level, message, requestIdentifier, this);
6124 
6125     if (m_consoleMessageListener)
6126         m_consoleMessageListener-&gt;scheduleCallback(*this, message);
6127 }
6128 
6129 void Document::addMessage(MessageSource source, MessageLevel level, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack, JSC::ExecState* state, unsigned long requestIdentifier)
6130 {
6131     if (!isContextThread()) {
6132         postTask(AddConsoleMessageTask(source, level, message));
6133         return;
6134     }
6135 
6136     if (Page* page = this-&gt;page())
6137         page-&gt;console().addMessage(source, level, message, sourceURL, lineNumber, columnNumber, WTFMove(callStack), state, requestIdentifier);
6138 }
6139 
6140 void Document::postTask(Task&amp;&amp; task)
6141 {
6142     callOnMainThread([documentID = identifier(), task = WTFMove(task)]() mutable {
6143         ASSERT(isMainThread());
6144 
6145         auto* document = allDocumentsMap().get(documentID);
6146         if (!document)
6147             return;
6148 
6149         Page* page = document-&gt;page();
6150         if ((page &amp;&amp; page-&gt;defersLoading() &amp;&amp; document-&gt;activeDOMObjectsAreSuspended()) || !document-&gt;m_pendingTasks.isEmpty())
6151             document-&gt;m_pendingTasks.append(WTFMove(task));
6152         else
6153             task.performTask(*document);
6154     });
6155 }
6156 
6157 void Document::pendingTasksTimerFired()
6158 {
6159     Vector&lt;Task&gt; pendingTasks = WTFMove(m_pendingTasks);
6160     for (auto&amp; task : pendingTasks)
6161         task.performTask(*this);
6162 }
6163 
6164 void Document::suspendScheduledTasks(ReasonForSuspension reason)
6165 {
6166     if (m_scheduledTasksAreSuspended) {
6167         // A page may subsequently suspend DOM objects, say as part of handling a scroll or zoom gesture, after the
6168         // embedding client requested the page be suspended. We ignore such requests so long as the embedding client
6169         // requested the suspension first. See &lt;rdar://problem/13754896&gt; for more details.
6170         ASSERT(reasonForSuspendingActiveDOMObjects() == ReasonForSuspension::PageWillBeSuspended);
6171         return;
6172     }
6173 
6174     suspendScriptedAnimationControllerCallbacks();
6175     suspendActiveDOMObjects(reason);
6176     scriptRunner().suspend();
6177     m_pendingTasksTimer.stop();
6178 
6179 #if ENABLE(XSLT)
6180     m_applyPendingXSLTransformsTimer.stop();
6181 #endif
6182 
6183     // Deferring loading and suspending parser is necessary when we need to prevent re-entrant JavaScript execution
6184     // (e.g. while displaying an alert).
6185     // It is not currently possible to suspend parser unless loading is deferred, because new data arriving from network
6186     // will trigger parsing, and leave the scheduler in an inconsistent state where it doesn&#39;t know whether it&#39;s suspended or not.
6187     if (reason == ReasonForSuspension::WillDeferLoading &amp;&amp; m_parser)
6188         m_parser-&gt;suspendScheduledTasks();
6189 
6190     m_scheduledTasksAreSuspended = true;
6191 }
6192 
6193 void Document::resumeScheduledTasks(ReasonForSuspension reason)
6194 {
6195     if (reasonForSuspendingActiveDOMObjects() != reason)
6196         return;
6197 
6198     ASSERT(m_scheduledTasksAreSuspended);
6199 
6200     if (reason == ReasonForSuspension::WillDeferLoading &amp;&amp; m_parser)
6201         m_parser-&gt;resumeScheduledTasks();
6202 
6203 #if ENABLE(XSLT)
6204     if (m_hasPendingXSLTransforms)
6205         m_applyPendingXSLTransformsTimer.startOneShot(0_s);
6206 #endif
6207 
6208     if (!m_pendingTasks.isEmpty())
6209         m_pendingTasksTimer.startOneShot(0_s);
6210     scriptRunner().resume();
6211     resumeActiveDOMObjects(reason);
6212     resumeScriptedAnimationControllerCallbacks();
6213 
6214     m_scheduledTasksAreSuspended = false;
6215 }
6216 
6217 void Document::suspendScriptedAnimationControllerCallbacks()
6218 {
6219     if (m_scriptedAnimationController)
6220         m_scriptedAnimationController-&gt;suspend();
6221 }
6222 
6223 void Document::resumeScriptedAnimationControllerCallbacks()
6224 {
6225     if (m_scriptedAnimationController)
6226         m_scriptedAnimationController-&gt;resume();
6227 }
6228 
6229 void Document::updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp)
6230 {
6231     if (m_timeline)
6232         m_timeline-&gt;updateAnimationsAndSendEvents(timestamp);
6233 }
6234 
6235 void Document::serviceRequestAnimationFrameCallbacks(DOMHighResTimeStamp timestamp)
6236 {
6237     if (m_scriptedAnimationController)
6238         m_scriptedAnimationController-&gt;serviceRequestAnimationFrameCallbacks(timestamp);
6239 }
6240 
6241 void Document::windowScreenDidChange(PlatformDisplayID displayID)
6242 {
6243     if (RenderView* view = renderView()) {
6244         if (view-&gt;usesCompositing())
6245             view-&gt;compositor().windowScreenDidChange(displayID);
6246     }
6247 }
6248 
6249 String Document::displayStringModifiedByEncoding(const String&amp; string) const
6250 {
6251     if (!m_decoder)
6252         return string;
6253     return String { string }.replace(&#39;\\&#39;, m_decoder-&gt;encoding().backslashAsCurrencySymbol());
6254 }
6255 
6256 void Document::dispatchPageshowEvent(PageshowEventPersistence persisted)
6257 {
6258     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=36334 Pageshow event needs to fire asynchronously.
6259     dispatchWindowEvent(PageTransitionEvent::create(eventNames().pageshowEvent, persisted), this);
6260 }
6261 
6262 void Document::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
6263 {
6264     enqueueDocumentEvent(SecurityPolicyViolationEvent::create(eventNames().securitypolicyviolationEvent, WTFMove(eventInit), Event::IsTrusted::Yes));
6265 }
6266 
6267 void Document::enqueueHashchangeEvent(const String&amp; oldURL, const String&amp; newURL)
6268 {
6269     enqueueWindowEvent(HashChangeEvent::create(oldURL, newURL));
6270 }
6271 
6272 void Document::dispatchPopstateEvent(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject)
6273 {
6274     dispatchWindowEvent(PopStateEvent::create(WTFMove(stateObject), m_domWindow ? &amp;m_domWindow-&gt;history() : nullptr));
6275 }
6276 
6277 void Document::addMediaCanStartListener(MediaCanStartListener&amp; listener)
6278 {
6279     ASSERT(!m_mediaCanStartListeners.contains(&amp;listener));
6280     m_mediaCanStartListeners.add(&amp;listener);
6281 }
6282 
6283 void Document::removeMediaCanStartListener(MediaCanStartListener&amp; listener)
6284 {
6285     ASSERT(m_mediaCanStartListeners.contains(&amp;listener));
6286     m_mediaCanStartListeners.remove(&amp;listener);
6287 }
6288 
6289 MediaCanStartListener* Document::takeAnyMediaCanStartListener()
6290 {
6291     return m_mediaCanStartListeners.takeAny();
6292 }
6293 
6294 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
6295 
6296 DeviceMotionController&amp; Document::deviceMotionController() const
6297 {
6298     return *m_deviceMotionController;
6299 }
6300 
6301 DeviceOrientationController&amp; Document::deviceOrientationController() const
6302 {
6303     return *m_deviceOrientationController;
6304 }
6305 
6306 void Document::simulateDeviceOrientationChange(double alpha, double beta, double gamma)
6307 {
6308     auto orientation = DeviceOrientationData::create(alpha, beta, gamma, WTF::nullopt, WTF::nullopt);
6309     deviceOrientationController().didChangeDeviceOrientation(orientation.ptr());
6310 }
6311 
6312 #endif
6313 
6314 #if ENABLE(POINTER_LOCK)
6315 
6316 void Document::exitPointerLock()
6317 {
6318     Page* page = this-&gt;page();
6319     if (!page)
6320         return;
6321     if (auto* target = page-&gt;pointerLockController().element()) {
6322         if (&amp;target-&gt;document() != this)
6323             return;
6324     }
6325     page-&gt;pointerLockController().requestPointerUnlock();
6326 }
6327 
6328 #endif
6329 
6330 void Document::decrementLoadEventDelayCount()
6331 {
6332     ASSERT(m_loadEventDelayCount);
6333     --m_loadEventDelayCount;
6334 
6335     if (frame() &amp;&amp; !m_loadEventDelayCount &amp;&amp; !m_loadEventDelayTimer.isActive())
6336         m_loadEventDelayTimer.startOneShot(0_s);
6337 }
6338 
6339 void Document::loadEventDelayTimerFired()
6340 {
6341     // FIXME: Should the call to FrameLoader::checkLoadComplete be moved inside Document::checkCompleted?
6342     // FIXME: Should this also call DocumentLoader::checkLoadComplete?
6343     // FIXME: Not obvious why checkCompleted needs to go first. The order these are called is
6344     // visible to WebKit clients, but it&#39;s more like a race than a well-defined relationship.
6345     Ref&lt;Document&gt; protectedThis(*this);
6346     checkCompleted();
6347     if (auto* frame = this-&gt;frame())
6348         frame-&gt;loader().checkLoadComplete();
6349 }
6350 
6351 void Document::checkCompleted()
6352 {
6353     if (auto* frame = this-&gt;frame())
6354         frame-&gt;loader().checkCompleted();
6355 }
6356 
6357 double Document::monotonicTimestamp() const
6358 {
6359     auto* loader = this-&gt;loader();
6360     if (!loader)
6361         return 0;
6362 
6363     return loader-&gt;timing().secondsSinceStartTime(MonotonicTime::now()).seconds();
6364 }
6365 
6366 int Document::requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
6367 {
6368     if (!m_scriptedAnimationController) {
6369         m_scriptedAnimationController = ScriptedAnimationController::create(*this);
6370 
6371         // It&#39;s possible that the Page may have suspended scripted animations before
6372         // we were created. We need to make sure that we don&#39;t start up the animation
6373         // controller on a background tab, for example.
6374         if (!page() || page()-&gt;scriptedAnimationsSuspended())
6375             m_scriptedAnimationController-&gt;suspend();
6376 
6377         if (page() &amp;&amp; page()-&gt;isLowPowerModeEnabled())
6378             m_scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::LowPowerMode);
6379 
6380         if (!topOrigin().canAccess(securityOrigin()) &amp;&amp; !hasHadUserInteraction())
6381             m_scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::NonInteractedCrossOriginFrame);
6382     }
6383 
6384     return m_scriptedAnimationController-&gt;registerCallback(WTFMove(callback));
6385 }
6386 
6387 void Document::cancelAnimationFrame(int id)
6388 {
6389     if (!m_scriptedAnimationController)
6390         return;
6391     m_scriptedAnimationController-&gt;cancelCallback(id);
6392 }
6393 
6394 void Document::clearScriptedAnimationController()
6395 {
6396     // FIXME: consider using ActiveDOMObject.
6397     if (m_scriptedAnimationController)
6398         m_scriptedAnimationController-&gt;clearDocumentPointer();
6399     m_scriptedAnimationController = nullptr;
6400 }
6401 
6402 void Document::wheelEventHandlersChanged()
6403 {
6404     Page* page = this-&gt;page();
6405     if (!page)
6406         return;
6407 
6408     if (FrameView* frameView = view()) {
6409         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
6410             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
6411     }
6412 
6413     bool haveHandlers = m_wheelEventTargets &amp;&amp; !m_wheelEventTargets-&gt;isEmpty();
6414     page-&gt;chrome().client().wheelEventHandlersChanged(haveHandlers);
6415 }
6416 
6417 void Document::didAddWheelEventHandler(Node&amp; node)
6418 {
6419     if (!m_wheelEventTargets)
6420         m_wheelEventTargets = makeUnique&lt;EventTargetSet&gt;();
6421 
6422     m_wheelEventTargets-&gt;add(&amp;node);
6423 
6424     wheelEventHandlersChanged();
6425 
6426     if (Frame* frame = this-&gt;frame())
6427         DebugPageOverlays::didChangeEventHandlers(*frame);
6428 }
6429 
6430 HttpEquivPolicy Document::httpEquivPolicy() const
6431 {
6432     if (shouldEnforceContentDispositionAttachmentSandbox())
6433         return HttpEquivPolicy::DisabledByContentDispositionAttachmentSandbox;
6434     if (page() &amp;&amp; !page()-&gt;settings().httpEquivEnabled())
6435         return HttpEquivPolicy::DisabledBySettings;
6436     return HttpEquivPolicy::Enabled;
6437 }
6438 
6439 static bool removeHandlerFromSet(EventTargetSet&amp; handlerSet, Node&amp; node, EventHandlerRemoval removal)
6440 {
6441     switch (removal) {
6442     case EventHandlerRemoval::One:
6443         return handlerSet.remove(&amp;node);
6444     case EventHandlerRemoval::All:
6445         return handlerSet.removeAll(&amp;node);
6446     }
6447     return false;
6448 }
6449 
6450 void Document::didRemoveWheelEventHandler(Node&amp; node, EventHandlerRemoval removal)
6451 {
6452     if (!m_wheelEventTargets)
6453         return;
6454 
6455     if (!removeHandlerFromSet(*m_wheelEventTargets, node, removal))
6456         return;
6457 
6458     wheelEventHandlersChanged();
6459 
6460     if (Frame* frame = this-&gt;frame())
6461         DebugPageOverlays::didChangeEventHandlers(*frame);
6462 }
6463 
6464 unsigned Document::wheelEventHandlerCount() const
6465 {
6466     if (!m_wheelEventTargets)
6467         return 0;
6468 
6469     unsigned count = 0;
6470     for (auto&amp; handler : *m_wheelEventTargets)
6471         count += handler.value;
6472 
6473     return count;
6474 }
6475 
6476 void Document::didAddTouchEventHandler(Node&amp; handler)
6477 {
6478 #if ENABLE(TOUCH_EVENTS)
6479     if (!m_touchEventTargets)
6480         m_touchEventTargets = makeUnique&lt;EventTargetSet&gt;();
6481 
6482     m_touchEventTargets-&gt;add(&amp;handler);
6483 
6484     if (Document* parent = parentDocument()) {
6485         parent-&gt;didAddTouchEventHandler(*this);
6486         return;
6487     }
6488 #else
6489     UNUSED_PARAM(handler);
6490 #endif
6491 }
6492 
6493 void Document::didRemoveTouchEventHandler(Node&amp; handler, EventHandlerRemoval removal)
6494 {
6495 #if ENABLE(TOUCH_EVENTS)
6496     if (!m_touchEventTargets)
6497         return;
6498 
6499     removeHandlerFromSet(*m_touchEventTargets, handler, removal);
6500 
6501     if (Document* parent = parentDocument())
6502         parent-&gt;didRemoveTouchEventHandler(*this);
6503 #else
6504     UNUSED_PARAM(handler);
6505     UNUSED_PARAM(removal);
6506 #endif
6507 }
6508 
6509 void Document::didRemoveEventTargetNode(Node&amp; handler)
6510 {
6511 #if ENABLE(TOUCH_EVENTS)
6512     if (m_touchEventTargets) {
6513         m_touchEventTargets-&gt;removeAll(&amp;handler);
6514         if ((&amp;handler == this || m_touchEventTargets-&gt;isEmpty()) &amp;&amp; parentDocument())
6515             parentDocument()-&gt;didRemoveEventTargetNode(*this);
6516     }
6517 #endif
6518 
6519     if (m_wheelEventTargets) {
6520         m_wheelEventTargets-&gt;removeAll(&amp;handler);
6521         if ((&amp;handler == this || m_wheelEventTargets-&gt;isEmpty()) &amp;&amp; parentDocument())
6522             parentDocument()-&gt;didRemoveEventTargetNode(*this);
6523     }
6524 }
6525 
6526 unsigned Document::touchEventHandlerCount() const
6527 {
6528 #if ENABLE(TOUCH_EVENTS)
6529     if (!m_touchEventTargets)
6530         return 0;
6531 
6532     unsigned count = 0;
6533     for (auto&amp; handler : *m_touchEventTargets)
6534         count += handler.value;
6535 
6536     return count;
6537 #else
6538     return 0;
6539 #endif
6540 }
6541 
6542 LayoutRect Document::absoluteEventHandlerBounds(bool&amp; includesFixedPositionElements)
6543 {
6544     includesFixedPositionElements = false;
6545     if (RenderView* renderView = this-&gt;renderView())
6546         return renderView-&gt;documentRect();
6547 
6548     return LayoutRect();
6549 }
6550 
6551 Document::RegionFixedPair Document::absoluteEventRegionForNode(Node&amp; node)
6552 {
6553     Region region;
6554     LayoutRect rootRelativeBounds;
6555     bool insideFixedPosition = false;
6556 
6557     if (is&lt;Document&gt;(node)) {
6558         auto&amp; document = downcast&lt;Document&gt;(node);
6559         if (&amp;document == this)
6560             rootRelativeBounds = absoluteEventHandlerBounds(insideFixedPosition);
6561         else if (Element* element = document.ownerElement())
6562             rootRelativeBounds = element-&gt;absoluteEventHandlerBounds(insideFixedPosition);
6563     } else if (is&lt;Element&gt;(node)) {
6564         auto&amp; element = downcast&lt;Element&gt;(node);
6565         if (is&lt;HTMLBodyElement&gt;(element)) {
6566             // For the body, just use the document bounds.
6567             // The body may not cover this whole area, but it&#39;s OK for this region to be an overestimate.
6568             rootRelativeBounds = absoluteEventHandlerBounds(insideFixedPosition);
6569         } else
6570             rootRelativeBounds = element.absoluteEventHandlerBounds(insideFixedPosition);
6571     }
6572 
6573     if (!rootRelativeBounds.isEmpty())
6574         region.unite(Region(enclosingIntRect(rootRelativeBounds)));
6575 
6576     return RegionFixedPair(region, insideFixedPosition);
6577 }
6578 
6579 Document::RegionFixedPair Document::absoluteRegionForEventTargets(const EventTargetSet* targets)
6580 {
6581     LayoutDisallowedScope layoutDisallowedScope(LayoutDisallowedScope::Reason::ReentrancyAvoidance);
6582 
6583     if (!targets)
6584         return RegionFixedPair(Region(), false);
6585 
6586     Region targetRegion;
6587     bool insideFixedPosition = false;
6588 
6589     for (auto&amp; keyValuePair : *targets) {
6590         if (auto* node = keyValuePair.key) {
6591             auto targetRegionFixedPair = absoluteEventRegionForNode(*node);
6592             targetRegion.unite(targetRegionFixedPair.first);
6593             insideFixedPosition |= targetRegionFixedPair.second;
6594         }
6595     }
6596 
6597     return RegionFixedPair(targetRegion, insideFixedPosition);
6598 }
6599 
6600 void Document::updateLastHandledUserGestureTimestamp(MonotonicTime time)
6601 {
6602     m_lastHandledUserGestureTimestamp = time;
6603 
6604     if (static_cast&lt;bool&gt;(time) &amp;&amp; m_scriptedAnimationController) {
6605         // It&#39;s OK to always remove NonInteractedCrossOriginFrame even if this frame isn&#39;t cross-origin.
6606         m_scriptedAnimationController-&gt;removeThrottlingReason(ScriptedAnimationController::ThrottlingReason::NonInteractedCrossOriginFrame);
6607     }
6608 
6609     // DOM Timer alignment may depend on the user having interacted with the document.
6610     didChangeTimerAlignmentInterval();
6611 
6612     if (HTMLFrameOwnerElement* element = ownerElement())
6613         element-&gt;document().updateLastHandledUserGestureTimestamp(time);
6614 }
6615 
6616 bool Document::processingUserGestureForMedia() const
6617 {
6618     if (UserGestureIndicator::processingUserGestureForMedia())
6619         return true;
6620 
6621     if (m_userActivatedMediaFinishedPlayingTimestamp + maxIntervalForUserGestureForwardingAfterMediaFinishesPlaying &gt;= MonotonicTime::now())
6622         return true;
6623 
6624     if (settings().mediaUserGestureInheritsFromDocument())
6625         return topDocument().hasHadUserInteraction();
6626 
6627     auto* loader = this-&gt;loader();
6628     if (loader &amp;&amp; loader-&gt;allowedAutoplayQuirks().contains(AutoplayQuirk::InheritedUserGestures))
6629         return topDocument().hasHadUserInteraction();
6630 
6631     return false;
6632 }
6633 
6634 void Document::startTrackingStyleRecalcs()
6635 {
6636     m_styleRecalcCount = 0;
6637 }
6638 
6639 unsigned Document::styleRecalcCount() const
6640 {
6641     return m_styleRecalcCount;
6642 }
6643 
6644 DocumentLoader* Document::loader() const
6645 {
6646     if (!m_frame)
6647         return nullptr;
6648 
6649     DocumentLoader* loader = m_frame-&gt;loader().documentLoader();
6650     if (!loader)
6651         return nullptr;
6652 
6653     if (m_frame-&gt;document() != this)
6654         return nullptr;
6655 
6656     return loader;
6657 }
6658 
6659 #if ENABLE(CSS_DEVICE_ADAPTATION)
6660 
6661 IntSize Document::initialViewportSize() const
6662 {
6663     if (!view())
6664         return IntSize();
6665     return view()-&gt;initialViewportSize();
6666 }
6667 
6668 #endif
6669 
6670 Element* eventTargetElementForDocument(Document* document)
6671 {
6672     if (!document)
6673         return nullptr;
6674     Element* element = document-&gt;focusedElement();
6675     if (!element &amp;&amp; is&lt;PluginDocument&gt;(*document))
6676         element = downcast&lt;PluginDocument&gt;(*document).pluginElement();
6677     if (!element &amp;&amp; document-&gt;isHTMLDocument())
6678         element = document-&gt;bodyOrFrameset();
6679     if (!element)
6680         element = document-&gt;documentElement();
6681     return element;
6682 }
6683 
6684 void Document::convertAbsoluteToClientQuads(Vector&lt;FloatQuad&gt;&amp; quads, const RenderStyle&amp; style)
6685 {
6686     if (!view())
6687         return;
6688 
6689     const auto&amp; frameView = *view();
6690     float inverseFrameScale = frameView.absoluteToDocumentScaleFactor(style.effectiveZoom());
6691     auto documentToClientOffset = frameView.documentToClientOffset();
6692 
6693     for (auto&amp; quad : quads) {
6694         if (inverseFrameScale != 1)
6695             quad.scale(inverseFrameScale);
6696 
6697         quad.move(documentToClientOffset);
6698     }
6699 }
6700 
6701 void Document::convertAbsoluteToClientRects(Vector&lt;FloatRect&gt;&amp; rects, const RenderStyle&amp; style)
6702 {
6703     if (!view())
6704         return;
6705 
6706     auto&amp; frameView = *view();
6707     float inverseFrameScale = frameView.absoluteToDocumentScaleFactor(style.effectiveZoom());
6708     auto documentToClientOffset = frameView.documentToClientOffset();
6709 
6710     for (auto&amp; rect : rects) {
6711         if (inverseFrameScale != 1)
6712             rect.scale(inverseFrameScale);
6713 
6714         rect.move(documentToClientOffset);
6715     }
6716 }
6717 
6718 void Document::convertAbsoluteToClientRect(FloatRect&amp; rect, const RenderStyle&amp; style)
6719 {
6720     if (!view())
6721         return;
6722 
6723     const auto&amp; frameView = *view();
6724     rect = frameView.absoluteToDocumentRect(rect, style.effectiveZoom());
6725     rect = frameView.documentToClientRect(rect);
6726 }
6727 
6728 bool Document::hasActiveParser()
6729 {
6730     return m_activeParserCount || (m_parser &amp;&amp; m_parser-&gt;processingData());
6731 }
6732 
6733 void Document::decrementActiveParserCount()
6734 {
6735     --m_activeParserCount;
6736     if (!frame())
6737         return;
6738 
6739     // FIXME: We should call DocumentLoader::checkLoadComplete as well here,
6740     // but it seems to cause http/tests/security/feed-urls-from-remote.html
6741     // to timeout on Mac WK1; see http://webkit.org/b/110554 and http://webkit.org/b/110401.
6742     frame()-&gt;loader().checkLoadComplete();
6743 }
6744 
6745 DocumentParserYieldToken::DocumentParserYieldToken(Document&amp; document)
6746     : m_document(makeWeakPtr(document))
6747 {
6748     if (++document.m_parserYieldTokenCount != 1)
6749         return;
6750 
6751     document.scriptRunner().didBeginYieldingParser();
6752     if (auto* parser = document.parser())
6753         parser-&gt;didBeginYieldingParser();
6754 }
6755 
6756 DocumentParserYieldToken::~DocumentParserYieldToken()
6757 {
6758     if (!m_document)
6759         return;
6760 
6761     ASSERT(m_document-&gt;m_parserYieldTokenCount);
6762     if (--m_document-&gt;m_parserYieldTokenCount)
6763         return;
6764 
6765     m_document-&gt;scriptRunner().didEndYieldingParser();
6766     if (auto* parser = m_document-&gt;parser())
6767         parser-&gt;didEndYieldingParser();
6768 }
6769 
6770 static Element* findNearestCommonComposedAncestor(Element* elementA, Element* elementB)
6771 {
6772     if (!elementA || !elementB)
6773         return nullptr;
6774 
6775     if (elementA == elementB)
6776         return elementA;
6777 
6778     HashSet&lt;Element*&gt; ancestorChain;
6779     for (auto* element = elementA; element; element = element-&gt;parentElementInComposedTree())
6780         ancestorChain.add(element);
6781 
6782     for (auto* element = elementB; element; element = element-&gt;parentElementInComposedTree()) {
6783         if (ancestorChain.contains(element))
6784             return element;
6785     }
6786     return nullptr;
6787 }
6788 
6789 void Document::updateHoverActiveState(const HitTestRequest&amp; request, Element* innerElement, CaptureChange captureElementChanged)
6790 {
6791     ASSERT(!request.readOnly());
6792 
6793     Element* innerElementInDocument = innerElement;
6794     while (innerElementInDocument &amp;&amp; &amp;innerElementInDocument-&gt;document() != this) {
6795         innerElementInDocument-&gt;document().updateHoverActiveState(request, innerElementInDocument);
6796         innerElementInDocument = innerElementInDocument-&gt;document().ownerElement();
6797     }
6798 
6799     Element* oldActiveElement = m_activeElement.get();
6800     if (oldActiveElement &amp;&amp; !request.active()) {
6801         // We are clearing the :active chain because the mouse has been released.
6802         for (Element* currentElement = oldActiveElement; currentElement; currentElement = currentElement-&gt;parentElementInComposedTree()) {
6803             currentElement-&gt;setActive(false);
6804             m_userActionElements.setInActiveChain(*currentElement, false);
6805         }
6806         m_activeElement = nullptr;
6807     } else {
6808         Element* newActiveElement = innerElementInDocument;
6809         if (!oldActiveElement &amp;&amp; newActiveElement &amp;&amp; request.active() &amp;&amp; !request.touchMove()) {
6810             // We are setting the :active chain and freezing it. If future moves happen, they
6811             // will need to reference this chain.
6812             for (RenderElement* curr = newActiveElement-&gt;renderer(); curr; curr = curr-&gt;parent()) {
6813                 Element* element = curr-&gt;element();
6814                 if (!element || curr-&gt;isTextOrLineBreak())
6815                     continue;
6816                 m_userActionElements.setInActiveChain(*element, true);
6817             }
6818 
6819             m_activeElement = newActiveElement;
6820         }
6821     }
6822     // If the mouse has just been pressed, set :active on the chain. Those (and only those)
6823     // nodes should remain :active until the mouse is released.
6824     bool allowActiveChanges = !oldActiveElement &amp;&amp; m_activeElement;
6825 
6826     // If the mouse is down and if this is a mouse move event, we want to restrict changes in
6827     // :hover/:active to only apply to elements that are in the :active chain that we froze
6828     // at the time the mouse went down, unless the capture element changed.
6829     bool mustBeInActiveChain = request.active() &amp;&amp; request.move() &amp;&amp; captureElementChanged == CaptureChange::No;
6830 
6831     RefPtr&lt;Element&gt; oldHoveredElement = WTFMove(m_hoveredElement);
6832 
6833     // A touch release does not set a new hover target; clearing the element we&#39;re working with
6834     // will clear the chain of hovered elements all the way to the top of the tree.
6835     if (request.touchRelease())
6836         innerElementInDocument = nullptr;
6837 
6838     // Check to see if the hovered Element has changed.
6839     // If it hasn&#39;t, we do not need to do anything.
6840     Element* newHoveredElement = innerElementInDocument;
6841     while (newHoveredElement &amp;&amp; !newHoveredElement-&gt;renderer())
6842         newHoveredElement = newHoveredElement-&gt;parentElementInComposedTree();
6843 
6844     m_hoveredElement = newHoveredElement;
6845 
6846     auto* commonAncestor = findNearestCommonComposedAncestor(oldHoveredElement.get(), newHoveredElement);
6847 
6848     Vector&lt;RefPtr&lt;Element&gt;, 32&gt; elementsToRemoveFromChain;
6849     Vector&lt;RefPtr&lt;Element&gt;, 32&gt; elementsToAddToChain;
6850 
6851     if (oldHoveredElement != newHoveredElement) {
6852         for (auto* element = oldHoveredElement.get(); element; element = element-&gt;parentElementInComposedTree()) {
6853             if (element == commonAncestor)
6854                 break;
6855             if (!mustBeInActiveChain || element-&gt;isInActiveChain())
6856                 elementsToRemoveFromChain.append(element);
6857         }
6858         // Unset hovered nodes in sub frame documents if the old hovered node was a frame owner.
6859         if (is&lt;HTMLFrameOwnerElement&gt;(oldHoveredElement)) {
6860             if (auto* contentDocument = downcast&lt;HTMLFrameOwnerElement&gt;(*oldHoveredElement).contentDocument())
6861                 contentDocument-&gt;updateHoverActiveState(request, nullptr);
6862         }
6863     }
6864 
6865     for (auto* element = newHoveredElement; element; element = element-&gt;parentElementInComposedTree()) {
6866         if (!mustBeInActiveChain || element-&gt;isInActiveChain())
6867             elementsToAddToChain.append(element);
6868     }
6869 
6870     for (auto&amp; element : elementsToRemoveFromChain)
6871         element-&gt;setHovered(false);
6872 
6873     bool sawCommonAncestor = false;
6874     for (auto&amp; element : elementsToAddToChain) {
6875         if (allowActiveChanges)
6876             element-&gt;setActive(true);
6877         if (element == commonAncestor)
6878             sawCommonAncestor = true;
6879         if (!sawCommonAncestor) {
6880             // Elements after the common hover ancestor does not change hover state, but are iterated over because they may change active state.
6881             element-&gt;setHovered(true);
6882         }
6883     }
6884 }
6885 
6886 bool Document::haveStylesheetsLoaded() const
6887 {
6888     return !styleScope().hasPendingSheets() || m_ignorePendingStylesheets;
6889 }
6890 
6891 Locale&amp; Document::getCachedLocale(const AtomString&amp; locale)
6892 {
6893     AtomString localeKey = locale;
6894     if (locale.isEmpty() || !settings().langAttributeAwareFormControlUIEnabled())
6895         localeKey = defaultLanguage();
6896     LocaleIdentifierToLocaleMap::AddResult result = m_localeCache.add(localeKey, nullptr);
6897     if (result.isNewEntry)
6898         result.iterator-&gt;value = Locale::create(localeKey);
6899     return *(result.iterator-&gt;value);
6900 }
6901 
6902 Document&amp; Document::ensureTemplateDocument()
6903 {
6904     if (const Document* document = templateDocument())
6905         return const_cast&lt;Document&amp;&gt;(*document);
6906 
6907     if (isHTMLDocument())
6908         m_templateDocument = HTMLDocument::create(sessionID(), nullptr, WTF::blankURL());
6909     else
6910         m_templateDocument = create(sessionID(), WTF::blankURL());
6911 
6912     m_templateDocument-&gt;setContextDocument(contextDocument());
6913     m_templateDocument-&gt;setTemplateDocumentHost(this); // balanced in dtor.
6914 
6915     return *m_templateDocument;
6916 }
6917 
6918 Ref&lt;FontFaceSet&gt; Document::fonts()
6919 {
6920     updateStyleIfNeeded();
6921     return fontSelector().fontFaceSet();
6922 }
6923 
6924 EditingBehavior Document::editingBehavior() const
6925 {
6926     return EditingBehavior { settings().editingBehaviorType() };
6927 }
6928 
6929 float Document::deviceScaleFactor() const
6930 {
6931     float deviceScaleFactor = 1.0;
6932     if (Page* documentPage = page())
6933         deviceScaleFactor = documentPage-&gt;deviceScaleFactor();
6934     return deviceScaleFactor;
6935 }
6936 
6937 bool Document::useSystemAppearance() const
6938 {
6939     if (auto* documentPage = page())
6940         return documentPage-&gt;useSystemAppearance();
6941     return false;
6942 }
6943 
6944 bool Document::useDarkAppearance(const RenderStyle* style) const
6945 {
6946 #if ENABLE(DARK_MODE_CSS)
6947     OptionSet&lt;ColorScheme&gt; colorScheme;
6948 
6949     // Use the style&#39;s supported color schemes, if supplied.
6950     if (style)
6951         colorScheme = style-&gt;colorScheme().colorScheme();
6952 
6953     // Fallback to the document&#39;s supported color schemes if style was empty (auto).
6954     if (colorScheme.isEmpty())
6955         colorScheme = m_colorScheme;
6956 
6957     if (colorScheme.contains(ColorScheme::Dark) &amp;&amp; !colorScheme.contains(ColorScheme::Light))
6958         return true;
6959 #else
6960     UNUSED_PARAM(style);
6961 #endif
6962 
6963     bool pageUsesDarkAppearance = false;
6964     if (Page* documentPage = page())
6965         pageUsesDarkAppearance = documentPage-&gt;useDarkAppearance();
6966 
6967     if (useSystemAppearance())
6968         return pageUsesDarkAppearance;
6969 
6970 #if ENABLE(DARK_MODE_CSS)
6971     if (colorScheme.contains(ColorScheme::Dark))
6972         return pageUsesDarkAppearance;
6973 #endif
6974 
6975     return false;
6976 }
6977 
6978 bool Document::useElevatedUserInterfaceLevel() const
6979 {
6980     if (auto* documentPage = page())
6981         return documentPage-&gt;useElevatedUserInterfaceLevel();
6982     return false;
6983 }
6984 
6985 OptionSet&lt;StyleColor::Options&gt; Document::styleColorOptions(const RenderStyle* style) const
6986 {
6987     OptionSet&lt;StyleColor::Options&gt; options;
6988     if (useSystemAppearance())
6989         options.add(StyleColor::Options::UseSystemAppearance);
6990     if (useDarkAppearance(style))
6991         options.add(StyleColor::Options::UseDarkAppearance);
6992     if (useElevatedUserInterfaceLevel())
6993         options.add(StyleColor::Options::UseElevatedUserInterfaceLevel);
6994     return options;
6995 }
6996 
6997 CompositeOperator Document::compositeOperatorForBackgroundColor(const Color&amp; color, const RenderObject&amp; renderer) const
6998 {
6999     if (LIKELY(!settings().punchOutWhiteBackgroundsInDarkMode() || !Color::isWhiteColor(color) || !renderer.useDarkAppearance()))
7000         return CompositeSourceOver;
7001 
7002     auto* frameView = view();
7003     if (!frameView)
7004         return CompositeSourceOver;
7005 
7006     // Mail on macOS uses a transparent view, and on iOS it is an opaque view. We need to
7007     // use different composite modes to get the right results in this case.
7008     return frameView-&gt;isTransparent() ? CompositeDestinationOut : CompositeDestinationIn;
7009 }
7010 
7011 void Document::didAssociateFormControl(Element&amp; element)
7012 {
7013     auto* page = this-&gt;page();
7014     if (!page || !page-&gt;chrome().client().shouldNotifyOnFormChanges())
7015         return;
7016     m_associatedFormControls.add(&amp;element);
7017     if (!m_didAssociateFormControlsTimer.isActive())
7018         m_didAssociateFormControlsTimer.startOneShot(0_s);
7019 }
7020 
7021 void Document::didAssociateFormControlsTimerFired()
7022 {
7023     auto vector = copyToVector(m_associatedFormControls);
7024     m_associatedFormControls.clear();
7025     if (auto* page = this-&gt;page()) {
7026         ASSERT(m_frame);
7027         page-&gt;chrome().client().didAssociateFormControls(vector, *m_frame);
7028     }
7029 }
7030 
7031 void Document::setCachedDOMCookies(const String&amp; cookies)
7032 {
7033     ASSERT(!isDOMCookieCacheValid());
7034     m_cachedDOMCookies = cookies;
7035     // The cookie cache is valid at most until we go back to the event loop.
7036     m_cookieCacheExpiryTimer.startOneShot(0_s);
7037 }
7038 
7039 void Document::invalidateDOMCookieCache()
7040 {
7041     m_cookieCacheExpiryTimer.stop();
7042     m_cachedDOMCookies = String();
7043 }
7044 
7045 void Document::didLoadResourceSynchronously()
7046 {
7047     // Synchronous resources loading can set cookies so we invalidate the cookies cache
7048     // in this case, to be safe.
7049     invalidateDOMCookieCache();
7050 }
7051 
7052 void Document::ensurePlugInsInjectedScript(DOMWrapperWorld&amp; world)
7053 {
7054     if (m_hasInjectedPlugInsScript)
7055         return;
7056 
7057     auto&amp; scriptController = frame()-&gt;script();
7058 
7059     // Use the JS file provided by the Chrome client, or fallback to the default one.
7060     String jsString = page()-&gt;chrome().client().plugInExtraScript();
7061     if (!jsString || !scriptController.shouldAllowUserAgentScripts(*this))
7062         jsString = String(plugInsJavaScript, sizeof(plugInsJavaScript));
7063 
7064     setHasEvaluatedUserAgentScripts();
7065     scriptController.evaluateInWorld(ScriptSourceCode(jsString), world);
7066 
7067     m_hasInjectedPlugInsScript = true;
7068 }
7069 
7070 #if ENABLE(WEB_CRYPTO)
7071 
7072 bool Document::wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
7073 {
7074     Page* page = this-&gt;page();
7075     if (!page)
7076         return false;
7077     return page-&gt;chrome().client().wrapCryptoKey(key, wrappedKey);
7078 }
7079 
7080 bool Document::unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
7081 {
7082     Page* page = this-&gt;page();
7083     if (!page)
7084         return false;
7085     return page-&gt;chrome().client().unwrapCryptoKey(wrappedKey, key);
7086 }
7087 
7088 #endif // ENABLE(WEB_CRYPTO)
7089 
7090 Element* Document::activeElement()
7091 {
7092     if (Element* element = treeScope().focusedElementInScope())
7093         return element;
7094     return bodyOrFrameset();
7095 }
7096 
7097 bool Document::hasFocus() const
7098 {
7099     Page* page = this-&gt;page();
7100     if (!page || !page-&gt;focusController().isActive())
7101         return false;
7102     if (Frame* focusedFrame = page-&gt;focusController().focusedFrame()) {
7103         if (focusedFrame-&gt;tree().isDescendantOf(frame()))
7104             return true;
7105     }
7106     return false;
7107 }
7108 
7109 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7110 
7111 static uint64_t nextPlaybackTargetClientContextId()
7112 {
7113     static uint64_t contextId = 0;
7114     return ++contextId;
7115 }
7116 
7117 void Document::addPlaybackTargetPickerClient(MediaPlaybackTargetClient&amp; client)
7118 {
7119     Page* page = this-&gt;page();
7120     if (!page)
7121         return;
7122 
7123     // FIXME: change this back to an ASSERT once https://webkit.org/b/144970 is fixed.
7124     if (m_clientToIDMap.contains(&amp;client))
7125         return;
7126 
7127     uint64_t contextId = nextPlaybackTargetClientContextId();
7128     m_clientToIDMap.add(&amp;client, contextId);
7129     m_idToClientMap.add(contextId, &amp;client);
7130     page-&gt;addPlaybackTargetPickerClient(contextId);
7131 }
7132 
7133 void Document::removePlaybackTargetPickerClient(MediaPlaybackTargetClient&amp; client)
7134 {
7135     auto it = m_clientToIDMap.find(&amp;client);
7136     if (it == m_clientToIDMap.end())
7137         return;
7138 
7139     uint64_t clientId = it-&gt;value;
7140     m_idToClientMap.remove(clientId);
7141     m_clientToIDMap.remove(it);
7142 
7143     Page* page = this-&gt;page();
7144     if (!page)
7145         return;
7146     page-&gt;removePlaybackTargetPickerClient(clientId);
7147 }
7148 
7149 void Document::showPlaybackTargetPicker(MediaPlaybackTargetClient&amp; client, bool isVideo, RouteSharingPolicy routeSharingPolicy, const String&amp; routingContextUID)
7150 {
7151     Page* page = this-&gt;page();
7152     if (!page)
7153         return;
7154 
7155     auto it = m_clientToIDMap.find(&amp;client);
7156     if (it == m_clientToIDMap.end())
7157         return;
7158 
7159     page-&gt;showPlaybackTargetPicker(it-&gt;value, view()-&gt;lastKnownMousePosition(), isVideo, routeSharingPolicy, routingContextUID);
7160 }
7161 
7162 void Document::playbackTargetPickerClientStateDidChange(MediaPlaybackTargetClient&amp; client, MediaProducer::MediaStateFlags state)
7163 {
7164     Page* page = this-&gt;page();
7165     if (!page)
7166         return;
7167 
7168     auto it = m_clientToIDMap.find(&amp;client);
7169     if (it == m_clientToIDMap.end())
7170         return;
7171 
7172     page-&gt;playbackTargetPickerClientStateDidChange(it-&gt;value, state);
7173 }
7174 
7175 void Document::playbackTargetAvailabilityDidChange(uint64_t clientId, bool available)
7176 {
7177     auto it = m_idToClientMap.find(clientId);
7178     if (it == m_idToClientMap.end())
7179         return;
7180 
7181     it-&gt;value-&gt;externalOutputDeviceAvailableDidChange(available);
7182 }
7183 
7184 void Document::setPlaybackTarget(uint64_t clientId, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
7185 {
7186     auto it = m_idToClientMap.find(clientId);
7187     if (it == m_idToClientMap.end())
7188         return;
7189 
7190     it-&gt;value-&gt;setPlaybackTarget(target.copyRef());
7191 }
7192 
7193 void Document::setShouldPlayToPlaybackTarget(uint64_t clientId, bool shouldPlay)
7194 {
7195     auto it = m_idToClientMap.find(clientId);
7196     if (it == m_idToClientMap.end())
7197         return;
7198 
7199     it-&gt;value-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
7200 }
7201 
7202 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET)
7203 
7204 #if ENABLE(MEDIA_SESSION)
7205 
7206 MediaSession&amp; Document::defaultMediaSession()
7207 {
7208     if (!m_defaultMediaSession)
7209         m_defaultMediaSession = MediaSession::create(*scriptExecutionContext());
7210     return *m_defaultMediaSession;
7211 }
7212 
7213 #endif
7214 
7215 ShouldOpenExternalURLsPolicy Document::shouldOpenExternalURLsPolicyToPropagate() const
7216 {
7217     if (DocumentLoader* documentLoader = loader())
7218         return documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate();
7219 
7220     return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
7221 }
7222 
7223 bool Document::shouldEnforceHTTP09Sandbox() const
7224 {
7225     if (m_isSynthesized || !m_frame)
7226         return false;
7227     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7228     return documentLoader &amp;&amp; documentLoader-&gt;response().isHTTP09();
7229 }
7230 
7231 #if USE(QUICK_LOOK)
7232 bool Document::shouldEnforceQuickLookSandbox() const
7233 {
7234     if (m_isSynthesized || !m_frame)
7235         return false;
7236     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7237     return documentLoader &amp;&amp; documentLoader-&gt;response().isQuickLook();
7238 }
7239 
7240 void Document::applyQuickLookSandbox()
7241 {
7242     auto&amp; documentLoader = *m_frame-&gt;loader().activeDocumentLoader();
7243     auto documentURL = documentLoader.documentURL();
7244     auto&amp; responseURL = documentLoader.responseURL();
7245     ASSERT(!documentURL.protocolIs(QLPreviewProtocol));
7246     ASSERT(responseURL.protocolIs(QLPreviewProtocol));
7247 
7248     auto securityOrigin = SecurityOrigin::createNonLocalWithAllowedFilePath(responseURL, documentURL.fileSystemPath());
7249     securityOrigin-&gt;setStorageBlockingPolicy(SecurityOrigin::BlockAllStorage);
7250     setSecurityOriginPolicy(SecurityOriginPolicy::create(WTFMove(securityOrigin)));
7251 
7252     static NeverDestroyed&lt;String&gt; quickLookCSP = makeString(&quot;default-src &quot;, QLPreviewProtocol, &quot;: &#39;unsafe-inline&#39;; base-uri &#39;none&#39;; sandbox allow-same-origin allow-scripts&quot;);
7253     RELEASE_ASSERT(contentSecurityPolicy());
7254     // The sandbox directive is only allowed if the policy is from an HTTP header.
7255     contentSecurityPolicy()-&gt;didReceiveHeader(quickLookCSP, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::HTTPHeader, referrer());
7256 
7257     disableSandboxFlags(SandboxNavigation);
7258 
7259     setReferrerPolicy(ReferrerPolicy::NoReferrer);
7260 }
7261 #endif
7262 
7263 bool Document::shouldEnforceContentDispositionAttachmentSandbox() const
7264 {
7265     if (!settings().contentDispositionAttachmentSandboxEnabled())
7266         return false;
7267 
7268     if (m_isSynthesized)
7269         return false;
7270 
7271     if (auto* documentLoader = m_frame ? m_frame-&gt;loader().activeDocumentLoader() : nullptr)
7272         return documentLoader-&gt;response().isAttachment();
7273     return false;
7274 }
7275 
7276 void Document::applyContentDispositionAttachmentSandbox()
7277 {
7278     ASSERT(shouldEnforceContentDispositionAttachmentSandbox());
7279 
7280     setReferrerPolicy(ReferrerPolicy::NoReferrer);
7281     if (!isMediaDocument())
7282         enforceSandboxFlags(SandboxAll);
7283     else
7284         enforceSandboxFlags(SandboxOrigin);
7285 }
7286 
7287 void Document::addViewportDependentPicture(HTMLPictureElement&amp; picture)
7288 {
7289     m_viewportDependentPictures.add(&amp;picture);
7290 }
7291 
7292 void Document::removeViewportDependentPicture(HTMLPictureElement&amp; picture)
7293 {
7294     m_viewportDependentPictures.remove(&amp;picture);
7295 }
7296 
7297 void Document::addAppearanceDependentPicture(HTMLPictureElement&amp; picture)
7298 {
7299     m_appearanceDependentPictures.add(&amp;picture);
7300 }
7301 
7302 void Document::removeAppearanceDependentPicture(HTMLPictureElement&amp; picture)
7303 {
7304     m_appearanceDependentPictures.remove(&amp;picture);
7305 }
7306 
7307 void Document::scheduleTimedRenderingUpdate()
7308 {
7309 #if ENABLE(INTERSECTION_OBSERVER)
7310     m_intersectionObserversInitialUpdateTimer.stop();
7311 #endif
7312     if (auto page = this-&gt;page())
7313         page-&gt;renderingUpdateScheduler().scheduleTimedRenderingUpdate();
7314 }
7315 
7316 #if ENABLE(INTERSECTION_OBSERVER)
7317 void Document::addIntersectionObserver(IntersectionObserver&amp; observer)
7318 {
7319     ASSERT(m_intersectionObservers.find(&amp;observer) == notFound);
7320     m_intersectionObservers.append(makeWeakPtr(&amp;observer));
7321 }
7322 
7323 void Document::removeIntersectionObserver(IntersectionObserver&amp; observer)
7324 {
7325     m_intersectionObservers.removeFirst(&amp;observer);
7326 }
7327 
7328 static void expandRootBoundsWithRootMargin(FloatRect&amp; localRootBounds, const LengthBox&amp; rootMargin)
7329 {
7330     FloatBoxExtent rootMarginFloatBox(
7331         floatValueForLength(rootMargin.top(), localRootBounds.height()),
7332         floatValueForLength(rootMargin.right(), localRootBounds.width()),
7333         floatValueForLength(rootMargin.bottom(), localRootBounds.height()),
7334         floatValueForLength(rootMargin.left(), localRootBounds.width())
7335     );
7336 
7337     localRootBounds.expand(rootMarginFloatBox);
7338 }
7339 
7340 static Optional&lt;LayoutRect&gt; computeClippedRectInRootContentsSpace(const LayoutRect&amp; rect, const RenderElement* renderer)
7341 {
7342     OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
7343     Optional&lt;LayoutRect&gt; rectInFrameAbsoluteSpace = renderer-&gt;computeVisibleRectInContainer(rect, &amp;renderer-&gt;view(),  {false /* hasPositionFixedDescendant */, false /* dirtyRectIsFlipped */, visibleRectOptions });
7344     if (!rectInFrameAbsoluteSpace || renderer-&gt;frame().isMainFrame())
7345         return rectInFrameAbsoluteSpace;
7346 
7347     bool intersects = rectInFrameAbsoluteSpace-&gt;edgeInclusiveIntersect(renderer-&gt;view().frameView().layoutViewportRect());
7348     if (!intersects)
7349         return WTF::nullopt;
7350 
7351     LayoutRect rectInFrameViewSpace(renderer-&gt;view().frameView().contentsToView(snappedIntRect(*rectInFrameAbsoluteSpace)));
7352     auto* ownerRenderer = renderer-&gt;frame().ownerRenderer();
7353     if (!ownerRenderer)
7354         return WTF::nullopt;
7355 
7356     rectInFrameViewSpace.moveBy(ownerRenderer-&gt;contentBoxLocation());
7357     return computeClippedRectInRootContentsSpace(rectInFrameViewSpace, ownerRenderer);
7358 }
7359 
7360 struct IntersectionObservationState {
7361     FloatRect absoluteTargetRect;
7362     FloatRect absoluteRootBounds;
7363     FloatRect absoluteIntersectionRect;
7364     bool isIntersecting { false };
7365 };
7366 
7367 static Optional&lt;IntersectionObservationState&gt; computeIntersectionState(FrameView&amp; frameView, const IntersectionObserver&amp; observer, Element&amp; target, bool applyRootMargin)
7368 {
7369     auto* targetRenderer = target.renderer();
7370     if (!targetRenderer)
7371         return WTF::nullopt;
7372 
7373     FloatRect localRootBounds;
7374     RenderBlock* rootRenderer;
7375     if (observer.root()) {
7376         if (observer.trackingDocument() != &amp;target.document())
7377             return WTF::nullopt;
7378 
7379         if (!observer.root()-&gt;renderer() || !is&lt;RenderBlock&gt;(observer.root()-&gt;renderer()))
7380             return WTF::nullopt;
7381 
7382         rootRenderer = downcast&lt;RenderBlock&gt;(observer.root()-&gt;renderer());
7383         if (!rootRenderer-&gt;isContainingBlockAncestorFor(*targetRenderer))
7384             return WTF::nullopt;
7385 
7386         if (rootRenderer-&gt;hasOverflowClip())
7387             localRootBounds = rootRenderer-&gt;contentBoxRect();
7388         else
7389             localRootBounds = { FloatPoint(), rootRenderer-&gt;size() };
7390     } else {
7391         ASSERT(frameView.frame().isMainFrame());
7392         // FIXME: Handle the case of an implicit-root observer that has a target in a different frame tree.
7393         if (&amp;targetRenderer-&gt;frame().mainFrame() != &amp;frameView.frame())
7394             return WTF::nullopt;
7395         rootRenderer = frameView.renderView();
7396         localRootBounds = frameView.layoutViewportRect();
7397     }
7398 
7399     if (applyRootMargin)
7400         expandRootBoundsWithRootMargin(localRootBounds, observer.rootMarginBox());
7401 
7402     LayoutRect localTargetBounds;
7403     if (is&lt;RenderBox&gt;(*targetRenderer))
7404         localTargetBounds = downcast&lt;RenderBox&gt;(targetRenderer)-&gt;borderBoundingBox();
7405     else if (is&lt;RenderInline&gt;(targetRenderer)) {
7406         auto pair = target.boundingAbsoluteRectWithoutLayout();
7407         if (pair) {
7408             FloatRect absoluteTargetBounds = pair-&gt;second;
7409             localTargetBounds = enclosingLayoutRect(targetRenderer-&gt;absoluteToLocalQuad(absoluteTargetBounds).boundingBox());
7410         }
7411     } else if (is&lt;RenderLineBreak&gt;(targetRenderer))
7412         localTargetBounds = downcast&lt;RenderLineBreak&gt;(targetRenderer)-&gt;linesBoundingBox();
7413 
7414     Optional&lt;LayoutRect&gt; rootLocalTargetRect;
7415     if (observer.root()) {
7416         OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
7417         rootLocalTargetRect = targetRenderer-&gt;computeVisibleRectInContainer(localTargetBounds, rootRenderer, { false /* hasPositionFixedDescendant */, false /* dirtyRectIsFlipped */, visibleRectOptions });
7418     } else
7419         rootLocalTargetRect = computeClippedRectInRootContentsSpace(localTargetBounds, targetRenderer);
7420 
7421     FloatRect rootLocalIntersectionRect = localRootBounds;
7422 
7423     IntersectionObservationState intersectionState;
7424     intersectionState.isIntersecting = rootLocalTargetRect &amp;&amp; rootLocalIntersectionRect.edgeInclusiveIntersect(*rootLocalTargetRect);
7425 
7426     if (intersectionState.isIntersecting) {
7427         FloatRect rootAbsoluteIntersectionRect = rootRenderer-&gt;localToAbsoluteQuad(rootLocalIntersectionRect).boundingBox();
7428         if (&amp;targetRenderer-&gt;frame() == &amp;rootRenderer-&gt;frame())
7429             intersectionState.absoluteIntersectionRect = rootAbsoluteIntersectionRect;
7430         else {
7431             FloatRect rootViewIntersectionRect = frameView.contentsToView(rootAbsoluteIntersectionRect);
7432             intersectionState.absoluteIntersectionRect = targetRenderer-&gt;view().frameView().rootViewToContents(rootViewIntersectionRect);
7433         }
7434     }
7435 
7436     intersectionState.absoluteTargetRect = targetRenderer-&gt;localToAbsoluteQuad(FloatRect(localTargetBounds)).boundingBox();
7437     intersectionState.absoluteRootBounds = rootRenderer-&gt;localToAbsoluteQuad(localRootBounds).boundingBox();
7438     return intersectionState;
7439 }
7440 
7441 void Document::updateIntersectionObservations()
7442 {
7443     auto* frameView = view();
7444     if (!frameView)
7445         return;
7446 
7447     m_intersectionObserversInitialUpdateTimer.stop();
7448 
7449     bool needsLayout = frameView-&gt;layoutContext().isLayoutPending() || (renderView() &amp;&amp; renderView()-&gt;needsLayout());
7450     if (needsLayout || hasPendingStyleRecalc())
7451         return;
7452 
7453     for (const auto&amp; observer : m_intersectionObservers) {
7454         bool needNotify = false;
7455         DOMHighResTimeStamp timestamp;
7456         if (!observer-&gt;createTimestamp(timestamp))
7457             continue;
7458         for (Element* target : observer-&gt;observationTargets()) {
7459             auto&amp; targetRegistrations = target-&gt;intersectionObserverData()-&gt;registrations;
7460             auto index = targetRegistrations.findMatching([observer](auto&amp; registration) {
7461                 return registration.observer.get() == observer;
7462             });
7463             ASSERT(index != notFound);
7464             auto&amp; registration = targetRegistrations[index];
7465 
7466             bool isSameOriginObservation = &amp;target-&gt;document() == this || target-&gt;document().securityOrigin().canAccess(securityOrigin());
7467             auto intersectionState = computeIntersectionState(*frameView, *observer, *target, isSameOriginObservation);
7468 
7469             float intersectionRatio = 0;
7470             size_t thresholdIndex = 0;
7471             if (intersectionState) {
7472                 if (intersectionState-&gt;isIntersecting) {
7473                     float absTargetArea = intersectionState-&gt;absoluteTargetRect.area();
7474                     if (absTargetArea)
7475                         intersectionRatio = intersectionState-&gt;absoluteIntersectionRect.area() / absTargetArea;
7476                     else
7477                         intersectionRatio = 1;
7478 
7479                     auto&amp; thresholds = observer-&gt;thresholds();
7480                     while (thresholdIndex &lt; thresholds.size() &amp;&amp; thresholds[thresholdIndex] &lt;= intersectionRatio)
7481                         ++thresholdIndex;
7482                 }
7483             }
7484 
7485             if (!registration.previousThresholdIndex || thresholdIndex != registration.previousThresholdIndex) {
7486                 FloatRect targetBoundingClientRect;
7487                 FloatRect clientIntersectionRect;
7488                 FloatRect clientRootBounds;
7489                 if (intersectionState) {
7490                     auto* targetFrameView = target-&gt;document().view();
7491                     targetBoundingClientRect = targetFrameView-&gt;absoluteToClientRect(intersectionState-&gt;absoluteTargetRect, target-&gt;renderer()-&gt;style().effectiveZoom());
7492                     auto* rootRenderer = observer-&gt;root() ? observer-&gt;root()-&gt;renderer() : frameView-&gt;renderView();
7493                     clientRootBounds = frameView-&gt;absoluteToClientRect(intersectionState-&gt;absoluteRootBounds, rootRenderer-&gt;style().effectiveZoom());
7494                     if (intersectionState-&gt;isIntersecting)
7495                         clientIntersectionRect = targetFrameView-&gt;absoluteToClientRect(intersectionState-&gt;absoluteIntersectionRect, target-&gt;renderer()-&gt;style().effectiveZoom());
7496                 }
7497 
7498                 Optional&lt;DOMRectInit&gt; reportedRootBounds;
7499                 if (isSameOriginObservation) {
7500                     reportedRootBounds = DOMRectInit({
7501                         clientRootBounds.x(),
7502                         clientRootBounds.y(),
7503                         clientRootBounds.width(),
7504                         clientRootBounds.height()
7505                     });
7506                 }
7507 
7508                 observer-&gt;appendQueuedEntry(IntersectionObserverEntry::create({
7509                     timestamp,
7510                     reportedRootBounds,
7511                     { targetBoundingClientRect.x(), targetBoundingClientRect.y(), targetBoundingClientRect.width(), targetBoundingClientRect.height() },
7512                     { clientIntersectionRect.x(), clientIntersectionRect.y(), clientIntersectionRect.width(), clientIntersectionRect.height() },
7513                     intersectionRatio,
7514                     target,
7515                     thresholdIndex &gt; 0,
7516                 }));
7517                 needNotify = true;
7518                 registration.previousThresholdIndex = thresholdIndex;
7519             }
7520         }
7521         if (needNotify)
7522             m_intersectionObserversWithPendingNotifications.append(makeWeakPtr(observer.get()));
7523     }
7524 
7525     if (m_intersectionObserversWithPendingNotifications.size())
7526         m_intersectionObserversNotifyTimer.startOneShot(0_s);
7527 }
7528 
7529 void Document::notifyIntersectionObserversTimerFired()
7530 {
7531     for (const auto&amp; observer : m_intersectionObserversWithPendingNotifications) {
7532         if (observer)
7533             observer-&gt;notify();
7534     }
7535     m_intersectionObserversWithPendingNotifications.clear();
7536 }
7537 
7538 void Document::scheduleInitialIntersectionObservationUpdate()
7539 {
7540     if (m_readyState == Complete)
7541         scheduleTimedRenderingUpdate();
7542     else if (!m_intersectionObserversInitialUpdateTimer.isActive())
7543         m_intersectionObserversInitialUpdateTimer.startOneShot(intersectionObserversInitialUpdateDelay);
7544 }
7545 #endif
7546 
7547 #if ENABLE(RESIZE_OBSERVER)
7548 void Document::addResizeObserver(ResizeObserver&amp; observer)
7549 {
7550     if (!m_resizeObservers.contains(&amp;observer))
7551         m_resizeObservers.append(makeWeakPtr(&amp;observer));
7552 }
7553 
7554 void Document::removeResizeObserver(ResizeObserver&amp; observer)
7555 {
7556     m_resizeObservers.removeFirst(&amp;observer);
7557 }
7558 
7559 bool Document::hasResizeObservers()
7560 {
7561     return !m_resizeObservers.isEmpty();
7562 }
7563 
7564 size_t Document::gatherResizeObservations(size_t deeperThan)
7565 {
7566     size_t minDepth = ResizeObserver::maxElementDepth();
7567     for (const auto&amp; observer : m_resizeObservers) {
7568         if (!observer-&gt;hasObservations())
7569             continue;
7570         auto depth = observer-&gt;gatherObservations(deeperThan);
7571         minDepth = std::min(minDepth, depth);
7572     }
7573     return minDepth;
7574 }
7575 
7576 void Document::deliverResizeObservations()
7577 {
7578     auto observersToNotify = m_resizeObservers;
7579     for (const auto&amp; observer : observersToNotify) {
7580         if (!observer || !observer-&gt;hasActiveObservations())
7581             continue;
7582         observer-&gt;deliverObservations();
7583     }
7584 }
7585 
7586 bool Document::hasSkippedResizeObservations() const
7587 {
7588     for (const auto&amp; observer : m_resizeObservers) {
7589         if (observer-&gt;hasSkippedObservations())
7590             return true;
7591     }
7592     return false;
7593 }
7594 
7595 void Document::setHasSkippedResizeObservations(bool skipped)
7596 {
7597     for (const auto&amp; observer : m_resizeObservers)
7598         observer-&gt;setHasSkippedObservations(skipped);
7599 }
7600 
7601 void Document::updateResizeObservations(Page&amp; page)
7602 {
7603     if (!hasResizeObservers())
7604         return;
7605 
7606     // We need layout the whole frame tree here. Because ResizeObserver could observe element in other frame,
7607     // and it could change other frame in deliverResizeObservations().
7608     page.layoutIfNeeded();
7609 
7610     // Start check resize obervers;
7611     for (size_t depth = gatherResizeObservations(0); depth != ResizeObserver::maxElementDepth(); depth = gatherResizeObservations(depth)) {
7612         deliverResizeObservations();
7613         page.layoutIfNeeded();
7614     }
7615 
7616     if (hasSkippedResizeObservations()) {
7617         setHasSkippedResizeObservations(false);
7618         String url;
7619         unsigned line = 0;
7620         unsigned column = 0;
7621         getParserLocation(url, line, column);
7622         reportException(&quot;ResizeObserver loop completed with undelivered notifications.&quot;, line, column, url, nullptr, nullptr);
7623         // Starting a new schedule the next round of notify.
7624         scheduleTimedRenderingUpdate();
7625     }
7626 }
7627 #endif
7628 
7629 const AtomString&amp; Document::dir() const
7630 {
7631     auto* documentElement = this-&gt;documentElement();
7632     if (!is&lt;HTMLHtmlElement&gt;(documentElement))
7633         return nullAtom();
7634     return downcast&lt;HTMLHtmlElement&gt;(*documentElement).dir();
7635 }
7636 
7637 void Document::setDir(const AtomString&amp; value)
7638 {
7639     auto* documentElement = this-&gt;documentElement();
7640     if (is&lt;HTMLHtmlElement&gt;(documentElement))
7641         downcast&lt;HTMLHtmlElement&gt;(*documentElement).setDir(value);
7642 }
7643 
7644 DOMSelection* Document::getSelection()
7645 {
7646     return m_domWindow ? m_domWindow-&gt;getSelection() : nullptr;
7647 }
7648 
7649 void Document::didInsertInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
7650 {
7651     ASSERT(shadowRoot.isConnected());
7652     ASSERT(!m_inDocumentShadowRoots.contains(&amp;shadowRoot));
7653     m_inDocumentShadowRoots.add(&amp;shadowRoot);
7654 }
7655 
7656 void Document::didRemoveInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
7657 {
7658     ASSERT(m_inDocumentShadowRoots.contains(&amp;shadowRoot));
7659     m_inDocumentShadowRoots.remove(&amp;shadowRoot);
7660 }
7661 
7662 void Document::orientationChanged(int orientation)
7663 {
7664     LOG(Events, &quot;Document %p orientationChanged - orientation %d&quot;, this, orientation);
7665     dispatchWindowEvent(Event::create(eventNames().orientationchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
7666     m_orientationNotifier.orientationChanged(orientation);
7667 }
7668 
7669 void Document::notifyMediaCaptureOfVisibilityChanged()
7670 {
7671 #if ENABLE(MEDIA_STREAM)
7672     if (!page())
7673         return;
7674 
7675     RealtimeMediaSourceCenter::singleton().setCapturePageState(hidden(), page()-&gt;isMediaCaptureMuted());
7676 #endif
7677 }
7678 
7679 #if ENABLE(MEDIA_STREAM)
7680 void Document::stopMediaCapture()
7681 {
7682     MediaStreamTrack::endCapture(*this);
7683 }
7684 
7685 void Document::registerForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp; element)
7686 {
7687     m_mediaStreamStateChangeElements.add(&amp;element);
7688 }
7689 
7690 void Document::unregisterForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp; element)
7691 {
7692     m_mediaStreamStateChangeElements.remove(&amp;element);
7693 }
7694 
7695 void Document::mediaStreamCaptureStateChanged()
7696 {
7697     if (!MediaProducer::isCapturing(m_mediaState))
7698         return;
7699 
7700     for (auto* mediaElement : m_mediaStreamStateChangeElements)
7701         mediaElement-&gt;mediaStreamCaptureStarted();
7702 }
7703 
7704 void Document::setDeviceIDHashSalt(const String&amp; salt)
7705 {
7706     ASSERT(m_idHashSalt.isEmpty() || m_idHashSalt == salt);
7707     m_idHashSalt = salt;
7708 }
7709 
7710 #endif
7711 
7712 void Document::addApplicationStateChangeListener(ApplicationStateChangeListener&amp; listener)
7713 {
7714     m_applicationStateChangeListeners.add(&amp;listener);
7715 }
7716 
7717 void Document::removeApplicationStateChangeListener(ApplicationStateChangeListener&amp; listener)
7718 {
7719     m_applicationStateChangeListeners.remove(&amp;listener);
7720 }
7721 
7722 void Document::forEachApplicationStateChangeListener(const Function&lt;void(ApplicationStateChangeListener&amp;)&gt;&amp; functor)
7723 {
7724     for (auto* listener : m_applicationStateChangeListeners)
7725         functor(*listener);
7726 }
7727 
7728 const AtomString&amp; Document::bgColor() const
7729 {
7730     auto* bodyElement = body();
7731     if (!bodyElement)
7732         return emptyAtom();
7733     return bodyElement-&gt;attributeWithoutSynchronization(bgcolorAttr);
7734 }
7735 
7736 void Document::setBgColor(const String&amp; value)
7737 {
7738     if (auto* bodyElement = body())
7739         bodyElement-&gt;setAttributeWithoutSynchronization(bgcolorAttr, value);
7740 }
7741 
7742 const AtomString&amp; Document::fgColor() const
7743 {
7744     auto* bodyElement = body();
7745     if (!bodyElement)
7746         return emptyAtom();
7747     return bodyElement-&gt;attributeWithoutSynchronization(textAttr);
7748 }
7749 
7750 void Document::setFgColor(const String&amp; value)
7751 {
7752     if (auto* bodyElement = body())
7753         bodyElement-&gt;setAttributeWithoutSynchronization(textAttr, value);
7754 }
7755 
7756 const AtomString&amp; Document::alinkColor() const
7757 {
7758     auto* bodyElement = body();
7759     if (!bodyElement)
7760         return emptyAtom();
7761     return bodyElement-&gt;attributeWithoutSynchronization(alinkAttr);
7762 }
7763 
7764 void Document::setAlinkColor(const String&amp; value)
7765 {
7766     if (auto* bodyElement = body())
7767         bodyElement-&gt;setAttributeWithoutSynchronization(alinkAttr, value);
7768 }
7769 
7770 const AtomString&amp; Document::linkColorForBindings() const
7771 {
7772     auto* bodyElement = body();
7773     if (!bodyElement)
7774         return emptyAtom();
7775     return bodyElement-&gt;attributeWithoutSynchronization(linkAttr);
7776 }
7777 
7778 void Document::setLinkColorForBindings(const String&amp; value)
7779 {
7780     if (auto* bodyElement = body())
7781         bodyElement-&gt;setAttributeWithoutSynchronization(linkAttr, value);
7782 }
7783 
7784 const AtomString&amp; Document::vlinkColor() const
7785 {
7786     auto* bodyElement = body();
7787     if (!bodyElement)
7788         return emptyAtom();
7789     return bodyElement-&gt;attributeWithoutSynchronization(vlinkAttr);
7790 }
7791 
7792 void Document::setVlinkColor(const String&amp; value)
7793 {
7794     if (auto* bodyElement = body())
7795         bodyElement-&gt;setAttributeWithoutSynchronization(vlinkAttr, value);
7796 }
7797 
7798 Logger&amp; Document::logger()
7799 {
7800     if (!m_logger) {
7801         m_logger = Logger::create(this);
7802         m_logger-&gt;setEnabled(this, sessionID().isAlwaysOnLoggingAllowed());
7803         m_logger-&gt;addObserver(*this);
7804     }
7805 
7806     return *m_logger;
7807 }
7808 
7809 Optional&lt;PageIdentifier&gt; Document::pageID() const
7810 {
7811     return m_frame-&gt;loader().client().pageID();
7812 }
7813 
7814 void Document::registerArticleElement(Element&amp; article)
7815 {
7816     m_articleElements.add(&amp;article);
7817 }
7818 
7819 void Document::unregisterArticleElement(Element&amp; article)
7820 {
7821     m_articleElements.remove(&amp;article);
7822     if (m_mainArticleElement == &amp;article)
7823         m_mainArticleElement = nullptr;
7824 }
7825 
7826 void Document::updateMainArticleElementAfterLayout()
7827 {
7828     ASSERT(page() &amp;&amp; page()-&gt;requestedLayoutMilestones().contains(DidRenderSignificantAmountOfText));
7829 
7830     // If there are too many article elements on the page, don&#39;t consider any one of them to be &quot;main content&quot;.
7831     const unsigned maxNumberOfArticlesBeforeIgnoringMainContentArticle = 10;
7832 
7833     // We consider an article to be main content if it is either:
7834     // 1. The only article element in the document.
7835     // 2. Much taller than the next tallest article, and also much larger than the viewport.
7836     const float minimumSecondTallestArticleHeightFactor = 4;
7837     const float minimumViewportAreaFactor = 5;
7838 
7839     m_mainArticleElement = nullptr;
7840 
7841     auto numberOfArticles = m_articleElements.size();
7842     if (!numberOfArticles || numberOfArticles &gt; maxNumberOfArticlesBeforeIgnoringMainContentArticle)
7843         return;
7844 
7845     Element* tallestArticle = nullptr;
7846     float tallestArticleHeight = 0;
7847     float tallestArticleWidth = 0;
7848     float secondTallestArticleHeight = 0;
7849 
7850     for (auto* article : m_articleElements) {
7851         auto* box = article-&gt;renderBox();
7852         float height = box ? box-&gt;height().toFloat() : 0;
7853         if (height &gt;= tallestArticleHeight) {
7854             secondTallestArticleHeight = tallestArticleHeight;
7855             tallestArticleHeight = height;
7856             tallestArticleWidth = box ? box-&gt;width().toFloat() : 0;
7857             tallestArticle = article;
7858         } else if (height &gt;= secondTallestArticleHeight)
7859             secondTallestArticleHeight = height;
7860     }
7861 
7862     if (numberOfArticles == 1) {
7863         m_mainArticleElement = tallestArticle;
7864         return;
7865     }
7866 
7867     if (tallestArticleHeight &lt; minimumSecondTallestArticleHeightFactor * secondTallestArticleHeight)
7868         return;
7869 
7870     if (!view())
7871         return;
7872 
7873     auto viewportSize = view()-&gt;layoutViewportRect().size();
7874     if (tallestArticleWidth * tallestArticleHeight &lt; minimumViewportAreaFactor * (viewportSize.width() * viewportSize.height()).toFloat())
7875         return;
7876 
7877     m_mainArticleElement = tallestArticle;
7878 }
7879 
7880 #if ENABLE(RESOURCE_LOAD_STATISTICS)
7881 bool Document::hasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp; domain)
7882 {
7883     return m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction == domain;
7884 }
7885 
7886 void Document::setHasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp; domain)
7887 {
7888     m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction = domain;
7889 }
7890 
7891 void Document::wasLoadedWithDataTransferFromPrevalentResource()
7892 {
7893     downgradeReferrerToRegistrableDomain();
7894 }
7895 
7896 void Document::downgradeReferrerToRegistrableDomain()
7897 {
7898     auto referrerStr = referrer();
7899     if (referrerStr.isEmpty())
7900         return;
7901 
7902     URL referrerURL { URL(), referrerStr };
7903     auto referrerPort = referrerURL.port();
7904     RegistrableDomain referrerRegistrableDomain { referrerURL };
7905     auto referrerRegistrableDomainStr = referrerRegistrableDomain.string();
7906     if (referrerRegistrableDomainStr.isEmpty())
7907         return;
7908 
7909     StringBuilder builder;
7910     builder.append(referrerURL.protocol());
7911     builder.appendLiteral(&quot;://&quot;);
7912     builder.append(referrerRegistrableDomainStr);
7913     if (referrerPort) {
7914         builder.append(&#39;:&#39;);
7915         builder.appendNumber(*referrerPort);
7916     }
7917     builder.append(&#39;/&#39;);
7918 
7919     m_referrerOverride = builder.toString();
7920 }
7921 #endif
7922 
7923 void Document::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
7924 {
7925     m_consoleMessageListener = listener;
7926 }
7927 
7928 DocumentTimeline&amp; Document::timeline()
7929 {
7930     if (!m_timeline)
7931         m_timeline = DocumentTimeline::create(*this);
7932 
7933     return *m_timeline;
7934 }
7935 
7936 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Document::getAnimations()
7937 {
7938     // For the list of animations to be current, we need to account for any pending CSS changes,
7939     // such as updates to CSS Animations and CSS Transitions.
7940     updateStyleIfNeeded();
7941 
7942     if (m_timeline)
7943         return m_timeline-&gt;getAnimations();
7944     return { };
7945 }
7946 
7947 #if ENABLE(ATTACHMENT_ELEMENT)
7948 
7949 void Document::registerAttachmentIdentifier(const String&amp; identifier)
7950 {
7951     if (auto* frame = this-&gt;frame())
7952         frame-&gt;editor().registerAttachmentIdentifier(identifier);
7953 }
7954 
7955 void Document::didInsertAttachmentElement(HTMLAttachmentElement&amp; attachment)
7956 {
7957     auto identifier = attachment.uniqueIdentifier();
7958     auto previousIdentifier = identifier;
7959     bool previousIdentifierIsNotUnique = !previousIdentifier.isEmpty() &amp;&amp; m_attachmentIdentifierToElementMap.contains(previousIdentifier);
7960     if (identifier.isEmpty() || previousIdentifierIsNotUnique) {
7961         previousIdentifier = identifier;
7962         identifier = createCanonicalUUIDString();
7963         attachment.setUniqueIdentifier(identifier);
7964     }
7965 
7966     m_attachmentIdentifierToElementMap.set(identifier, attachment);
7967 
7968     if (auto* frame = this-&gt;frame()) {
7969         if (previousIdentifierIsNotUnique)
7970             frame-&gt;editor().cloneAttachmentData(previousIdentifier, identifier);
7971         frame-&gt;editor().didInsertAttachmentElement(attachment);
7972     }
7973 }
7974 
7975 void Document::didRemoveAttachmentElement(HTMLAttachmentElement&amp; attachment)
7976 {
7977     auto identifier = attachment.uniqueIdentifier();
7978     if (!identifier)
7979         return;
7980 
7981     m_attachmentIdentifierToElementMap.remove(identifier);
7982 
7983     if (frame())
7984         frame()-&gt;editor().didRemoveAttachmentElement(attachment);
7985 }
7986 
7987 RefPtr&lt;HTMLAttachmentElement&gt; Document::attachmentForIdentifier(const String&amp; identifier) const
7988 {
7989     return m_attachmentIdentifierToElementMap.get(identifier);
7990 }
7991 
7992 #endif // ENABLE(ATTACHMENT_ELEMENT)
7993 
7994 static MessageSource messageSourceForWTFLogChannel(const WTFLogChannel&amp; channel)
7995 {
7996     static const NeverDestroyed&lt;String&gt; mediaChannel = MAKE_STATIC_STRING_IMPL(&quot;media&quot;);
7997     static const NeverDestroyed&lt;String&gt; webrtcChannel = MAKE_STATIC_STRING_IMPL(&quot;webrtc&quot;);
7998     static const NeverDestroyed&lt;String&gt; mediaSourceChannel = MAKE_STATIC_STRING_IMPL(&quot;mediasource&quot;);
7999 
8000     if (equalIgnoringASCIICase(mediaChannel, channel.name))
8001         return MessageSource::Media;
8002 
8003     if (equalIgnoringASCIICase(webrtcChannel, channel.name))
8004         return MessageSource::WebRTC;
8005 
8006     if (equalIgnoringASCIICase(mediaSourceChannel, channel.name))
8007         return MessageSource::MediaSource;
8008 
8009     return MessageSource::Other;
8010 }
8011 
8012 static MessageLevel messageLevelFromWTFLogLevel(WTFLogLevel level)
8013 {
8014     switch (level) {
8015     case WTFLogLevel::Always:
8016         return MessageLevel::Log;
8017     case WTFLogLevel::Error:
8018         return MessageLevel::Error;
8019         break;
8020     case WTFLogLevel::Warning:
8021         return MessageLevel::Warning;
8022         break;
8023     case WTFLogLevel::Info:
8024         return MessageLevel::Info;
8025         break;
8026     case WTFLogLevel::Debug:
8027         return MessageLevel::Debug;
8028         break;
8029     }
8030 
8031     ASSERT_NOT_REACHED();
8032     return MessageLevel::Log;
8033 }
8034 
8035 static inline Vector&lt;JSONLogValue&gt; crossThreadCopy(Vector&lt;JSONLogValue&gt;&amp;&amp; source)
8036 {
8037     auto values = WTFMove(source);
8038     for (auto&amp; value : values)
8039         value.value = crossThreadCopy(WTFMove(value.value));
8040     return values;
8041 }
8042 
8043 void Document::didLogMessage(const WTFLogChannel&amp; channel, WTFLogLevel level, Vector&lt;JSONLogValue&gt;&amp;&amp; logMessages)
8044 {
8045     if (!isMainThread()) {
8046         postTask([this, channel, level, logMessages = crossThreadCopy(WTFMove(logMessages))](auto&amp;) mutable {
8047             didLogMessage(channel, level, WTFMove(logMessages));
8048         });
8049         return;
8050     }
8051     if (!page())
8052         return;
8053 
8054     ASSERT(sessionID().isAlwaysOnLoggingAllowed());
8055 
8056     auto messageSource = messageSourceForWTFLogChannel(channel);
8057     if (messageSource == MessageSource::Other)
8058         return;
8059 
8060     m_logMessageTaskQueue.enqueueTask([this, level, messageSource, logMessages = WTFMove(logMessages)]() mutable {
8061         if (!page())
8062             return;
8063 
8064         auto messageLevel = messageLevelFromWTFLogLevel(level);
8065         auto message = makeUnique&lt;Inspector::ConsoleMessage&gt;(messageSource, MessageType::Log, messageLevel, WTFMove(logMessages), mainWorldExecState(frame()));
8066 
8067         addConsoleMessage(WTFMove(message));
8068     });
8069 }
8070 
8071 #if ENABLE(SERVICE_WORKER)
8072 void Document::setServiceWorkerConnection(SWClientConnection* serviceWorkerConnection)
8073 {
8074     if (m_serviceWorkerConnection == serviceWorkerConnection || m_hasPreparedForDestruction || m_isSuspended)
8075         return;
8076 
8077     if (m_serviceWorkerConnection)
8078         m_serviceWorkerConnection-&gt;unregisterServiceWorkerClient(identifier());
8079 
8080     m_serviceWorkerConnection = serviceWorkerConnection;
8081 
8082     if (!m_serviceWorkerConnection)
8083         return;
8084 
8085     auto controllingServiceWorkerRegistrationIdentifier = activeServiceWorker() ? makeOptional&lt;ServiceWorkerRegistrationIdentifier&gt;(activeServiceWorker()-&gt;registrationIdentifier()) : WTF::nullopt;
8086     m_serviceWorkerConnection-&gt;registerServiceWorkerClient(topOrigin(), ServiceWorkerClientData::from(*this, *serviceWorkerConnection), controllingServiceWorkerRegistrationIdentifier, userAgent(url()));
8087 }
8088 #endif
8089 
8090 String Document::signedPublicKeyAndChallengeString(unsigned keySizeIndex, const String&amp; challengeString, const URL&amp; url)
8091 {
8092     Page* page = this-&gt;page();
8093     if (!page)
8094         return emptyString();
8095     return page-&gt;chrome().client().signedPublicKeyAndChallengeString(keySizeIndex, challengeString, url);
8096 }
8097 
8098 bool Document::registerCSSProperty(CSSRegisteredCustomProperty&amp;&amp; prop)
8099 {
8100     return m_CSSRegisteredPropertySet.add(prop.name, makeUnique&lt;CSSRegisteredCustomProperty&gt;(WTFMove(prop))).isNewEntry;
8101 }
8102 
8103 void Document::detachFromFrame()
8104 {
8105     // Assertion to help pinpint rdar://problem/49877867. If this hits, the crash trace should tell us
8106     // which piece of code is detaching the document from its frame while constructing the CachedFrames.
8107     RELEASE_ASSERT(m_mayBeDetachedFromFrame);
8108 
8109     observeFrame(nullptr);
8110 }
8111 
8112 void Document::frameWasDisconnectedFromOwner()
8113 {
8114     if (!frame())
8115         return;
8116 
8117     if (auto* window = domWindow())
8118         window-&gt;willDetachDocumentFromFrame();
8119 
8120     detachFromFrame();
8121 }
8122 
8123 bool Document::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
8124 {
8125     return hitTest(request, result.hitTestLocation(), result);
8126 }
8127 
8128 bool Document::hitTest(const HitTestRequest&amp; request, const HitTestLocation&amp; location, HitTestResult&amp; result)
8129 {
8130     Ref&lt;Document&gt; protectedThis(*this);
8131     updateLayout();
8132     if (!renderView())
8133         return false;
8134 
8135 #if !ASSERT_DISABLED
8136     SetForScope&lt;bool&gt; hitTestRestorer { m_inHitTesting, true };
8137 #endif
8138 
8139     auto&amp; frameView = renderView()-&gt;frameView();
8140     Ref&lt;FrameView&gt; protector(frameView);
8141 
8142     FrameFlatteningLayoutDisallower disallower(frameView);
8143 
8144     bool resultLayer = renderView()-&gt;layer()-&gt;hitTest(request, location, result);
8145 
8146     // ScrollView scrollbars are not the same as RenderLayer scrollbars tested by RenderLayer::hitTestOverflowControls,
8147     // so we need to test ScrollView scrollbars separately here. In case of using overlay scrollbars, the layer hit test
8148     // will always work so we need to check the ScrollView scrollbars in that case too.
8149     if (!resultLayer || ScrollbarTheme::theme().usesOverlayScrollbars()) {
8150         // FIXME: Consider if this test should be done unconditionally.
8151         if (request.allowsFrameScrollbars()) {
8152             IntPoint windowPoint = frameView.contentsToWindow(location.roundedPoint());
8153             if (auto* frameScrollbar = frameView.scrollbarAtPoint(windowPoint)) {
8154                 result.setScrollbar(frameScrollbar);
8155                 return true;
8156             }
8157         }
8158     }
8159     return resultLayer;
8160 }
8161 
8162 ElementIdentifier Document::identifierForElement(Element&amp; element)
8163 {
8164     ASSERT(&amp;element.document() == this);
8165     auto result = m_identifiedElementsMap.ensure(&amp;element, [&amp;] {
8166         return element.createElementIdentifier();
8167     });
8168     return result.iterator-&gt;value;
8169 }
8170 
8171 Element* Document::searchForElementByIdentifier(const ElementIdentifier&amp; identifier)
8172 {
8173     for (auto it = m_identifiedElementsMap.begin(); it != m_identifiedElementsMap.end(); ++it) {
8174         if (it-&gt;value == identifier)
8175             return it-&gt;key;
8176     }
8177 
8178     return nullptr;
8179 }
8180 
8181 void Document::identifiedElementWasRemovedFromDocument(Element&amp; element)
8182 {
8183     m_identifiedElementsMap.remove(&amp;element);
8184 }
8185 
8186 #if ENABLE(DEVICE_ORIENTATION)
8187 
8188 DeviceOrientationAndMotionAccessController&amp; Document::deviceOrientationAndMotionAccessController()
8189 {
8190     if (&amp;topDocument() != this)
8191         return topDocument().deviceOrientationAndMotionAccessController();
8192 
8193     if (!m_deviceOrientationAndMotionAccessController)
8194         m_deviceOrientationAndMotionAccessController = makeUnique&lt;DeviceOrientationAndMotionAccessController&gt;(*this);
8195     return *m_deviceOrientationAndMotionAccessController;
8196 }
8197 
8198 #endif
8199 
8200 #if ENABLE(CSS_PAINTING_API)
8201 Worklet&amp; Document::ensurePaintWorklet()
8202 {
8203     if (!m_paintWorklet)
8204         m_paintWorklet = Worklet::create();
8205     return *m_paintWorklet;
8206 }
8207 
8208 PaintWorkletGlobalScope* Document::paintWorkletGlobalScopeForName(const String&amp; name)
8209 {
8210     return m_paintWorkletGlobalScopes.get(name);
8211 }
8212 
8213 void Document::setPaintWorkletGlobalScopeForName(const String&amp; name, Ref&lt;PaintWorkletGlobalScope&gt;&amp;&amp; scope)
8214 {
8215     auto addResult = m_paintWorkletGlobalScopes.add(name, WTFMove(scope));
8216     ASSERT_UNUSED(addResult, addResult);
8217 }
8218 #endif
8219 
8220 #if PLATFORM(IOS_FAMILY)
8221 
8222 ContentChangeObserver&amp; Document::contentChangeObserver()
8223 {
8224     if (!m_contentChangeObserver)
8225         m_contentChangeObserver = makeUnique&lt;ContentChangeObserver&gt;(*this);
8226     return *m_contentChangeObserver;
8227 }
8228 
8229 DOMTimerHoldingTank&amp; Document::domTimerHoldingTank()
8230 {
8231     if (m_domTimerHoldingTank)
8232         return *m_domTimerHoldingTank;
8233     m_domTimerHoldingTank = makeUnique&lt;DOMTimerHoldingTank&gt;();
8234     return *m_domTimerHoldingTank;
8235 }
8236 
8237 #endif
8238 
8239 bool Document::hasEvaluatedUserAgentScripts() const
8240 {
8241     auto&amp; top = topDocument();
8242     return this == &amp;top ? m_hasEvaluatedUserAgentScripts : top.hasEvaluatedUserAgentScripts();
8243 }
8244 
8245 bool Document::isRunningUserScripts() const
8246 {
8247     auto&amp; top = topDocument();
8248     return this == &amp;top ? m_isRunningUserScripts : top.isRunningUserScripts();
8249 }
8250 
8251 void Document::setAsRunningUserScripts()
8252 {
8253     auto&amp; top = topDocument();
8254     if (this == &amp;top)
8255         m_isRunningUserScripts = true;
8256     else
8257         top.setAsRunningUserScripts();
8258 }
8259 
8260 void Document::setHasEvaluatedUserAgentScripts()
8261 {
8262     auto&amp; top = topDocument();
8263     if (this == &amp;top)
8264         m_hasEvaluatedUserAgentScripts = true;
8265     else
8266         top.setHasEvaluatedUserAgentScripts();
8267 }
8268 
8269 #if ENABLE(APPLE_PAY)
8270 
8271 bool Document::isApplePayActive() const
8272 {
8273     auto&amp; top = topDocument();
8274     return this == &amp;top ? m_hasStartedApplePaySession : top.isApplePayActive();
8275 }
8276 
8277 void Document::setApplePayIsActive()
8278 {
8279     auto&amp; top = topDocument();
8280     if (this == &amp;top)
8281         m_hasStartedApplePaySession = true;
8282     else
8283         top.setApplePayIsActive();
8284 }
8285 
8286 #endif
8287 
8288 } // namespace WebCore
    </pre>
  </body>
</html>