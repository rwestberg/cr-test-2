<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/NodesCodegen.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2 *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
   3 *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<a name="1" id="anc1"></a><span class="line-modified">   4 *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.</span>
   5 *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   6 *  Copyright (C) 2007 Maks Orlovich
   7 *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   8  * Copyright (C) 2012 Igalia, S.L.
   9 *
  10 *  This library is free software; you can redistribute it and/or
  11 *  modify it under the terms of the GNU Library General Public
  12 *  License as published by the Free Software Foundation; either
  13 *  version 2 of the License, or (at your option) any later version.
  14 *
  15 *  This library is distributed in the hope that it will be useful,
  16 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  17 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18 *  Library General Public License for more details.
  19 *
  20 *  You should have received a copy of the GNU Library General Public License
  21 *  along with this library; see the file COPYING.LIB.  If not, write to
  22 *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23 *  Boston, MA 02110-1301, USA.
  24 *
  25 */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Nodes.h&quot;
  29 #include &quot;NodeConstructors.h&quot;
  30 
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;BytecodeGenerator.h&quot;
  33 #include &quot;CallFrame.h&quot;
  34 #include &quot;JIT.h&quot;
  35 #include &quot;JSCInlines.h&quot;
  36 #include &quot;JSFunction.h&quot;
  37 #include &quot;JSGeneratorFunction.h&quot;
  38 #include &quot;JSGlobalObject.h&quot;
  39 #include &quot;JSImmutableButterfly.h&quot;
  40 #include &quot;LabelScope.h&quot;
  41 #include &quot;Lexer.h&quot;
  42 #include &quot;Parser.h&quot;
  43 #include &quot;StackAlignment.h&quot;
<a name="2" id="anc2"></a>

  44 #include &lt;wtf/Assertions.h&gt;
  45 #include &lt;wtf/Threading.h&gt;
  46 #include &lt;wtf/text/StringBuilder.h&gt;
  47 
  48 namespace JSC {
  49 
  50 /*
  51     Details of the emitBytecode function.
  52 
  53     Return value: The register holding the production&#39;s value.
  54              dst: An optional parameter specifying the most efficient destination at
  55                   which to store the production&#39;s value. The callee must honor dst.
  56 
  57     The dst argument provides for a crude form of copy propagation. For example,
  58 
  59         x = 1
  60 
  61     becomes
  62 
  63         load r[x], 1
  64 
  65     instead of
  66 
  67         load r0, 1
  68         mov r[x], r0
  69 
  70     because the assignment node, &quot;x =&quot;, passes r[x] as dst to the number node, &quot;1&quot;.
  71 */
  72 
  73 void ExpressionNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
  74 {
  75     RegisterID* result = generator.emitNode(this);
  76     if (fallThroughMode == FallThroughMeansTrue)
  77         generator.emitJumpIfFalse(result, falseTarget);
  78     else
  79         generator.emitJumpIfTrue(result, trueTarget);
  80 }
  81 
  82 // ------------------------------ ThrowableExpressionData --------------------------------
  83 
  84 RegisterID* ThrowableExpressionData::emitThrowReferenceError(BytecodeGenerator&amp; generator, const String&amp; message)
  85 {
  86     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
  87     generator.emitThrowReferenceError(message);
  88     return generator.newTemporary();
  89 }
  90 
  91 // ------------------------------ ConstantNode ----------------------------------
  92 
  93 void ConstantNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
  94 {
  95     TriState value = jsValue(generator).pureToBoolean();
  96 
  97     if (UNLIKELY(needsDebugHook())) {
  98         if (value != MixedTriState)
  99             generator.emitDebugHook(this);
 100     }
 101 
 102     if (value == MixedTriState)
 103         ExpressionNode::emitBytecodeInConditionContext(generator, trueTarget, falseTarget, fallThroughMode);
 104     else if (value == TrueTriState &amp;&amp; fallThroughMode == FallThroughMeansFalse)
 105         generator.emitJump(trueTarget);
 106     else if (value == FalseTriState &amp;&amp; fallThroughMode == FallThroughMeansTrue)
 107         generator.emitJump(falseTarget);
 108 
 109     // All other cases are unconditional fall-throughs, like &quot;if (true)&quot;.
 110 }
 111 
 112 RegisterID* ConstantNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 113 {
 114     if (dst == generator.ignoredResult())
 115         return 0;
 116     return generator.emitLoad(dst, jsValue(generator));
 117 }
 118 
 119 JSValue StringNode::jsValue(BytecodeGenerator&amp; generator) const
 120 {
 121     return generator.addStringConstant(m_value);
 122 }
 123 
 124 JSValue BigIntNode::jsValue(BytecodeGenerator&amp; generator) const
 125 {
 126     return generator.addBigIntConstant(m_value, m_radix, m_sign);
 127 }
 128 
 129 // ------------------------------ NumberNode ----------------------------------
 130 
 131 RegisterID* NumberNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 132 {
 133     if (dst == generator.ignoredResult())
 134         return nullptr;
 135     return generator.emitLoad(dst, jsValue(generator), isIntegerNode() ? SourceCodeRepresentation::Integer : SourceCodeRepresentation::Double);
 136 }
 137 
 138 // ------------------------------ RegExpNode -----------------------------------
 139 
 140 RegisterID* RegExpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 141 {
 142     if (dst == generator.ignoredResult())
 143         return nullptr;
<a name="3" id="anc3"></a><span class="line-modified"> 144     RegExp* regExp = RegExp::create(*generator.vm(), m_pattern.string(), regExpFlags(m_flags.string()));</span>



 145     if (regExp-&gt;isValid())
 146         return generator.emitNewRegExp(generator.finalDestination(dst), regExp);
<a name="4" id="anc4"></a>
 147     const char* messageCharacters = regExp-&gt;errorMessage();
 148     const Identifier&amp; message = generator.parserArena().identifierArena().makeIdentifier(generator.vm(), bitwise_cast&lt;const LChar*&gt;(messageCharacters), strlen(messageCharacters));
 149     generator.emitThrowStaticError(ErrorType::SyntaxError, message);
 150     return generator.emitLoad(generator.finalDestination(dst), jsUndefined());
 151 }
 152 
 153 // ------------------------------ ThisNode -------------------------------------
 154 
 155 RegisterID* ThisNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 156 {
 157     generator.ensureThis();
 158     if (dst == generator.ignoredResult())
 159         return 0;
 160 
 161     RegisterID* result = generator.move(dst, generator.thisRegister());
 162     static const unsigned thisLength = 4;
 163     generator.emitProfileType(generator.thisRegister(), position(), JSTextPosition(-1, position().offset + thisLength, -1));
 164     return result;
 165 }
 166 
 167 // ------------------------------ SuperNode -------------------------------------
 168 
 169 static RegisterID* emitHomeObjectForCallee(BytecodeGenerator&amp; generator)
 170 {
 171     if (generator.isDerivedClassContext() || generator.isDerivedConstructorContext()) {
 172         RegisterID* derivedConstructor = generator.emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();
 173         return generator.emitGetById(generator.newTemporary(), derivedConstructor, generator.propertyNames().builtinNames().homeObjectPrivateName());
 174     }
 175 
 176     RegisterID callee;
 177     callee.setIndex(CallFrameSlot::callee);
 178     return generator.emitGetById(generator.newTemporary(), &amp;callee, generator.propertyNames().builtinNames().homeObjectPrivateName());
 179 }
 180 
 181 static RegisterID* emitSuperBaseForCallee(BytecodeGenerator&amp; generator)
 182 {
 183     RefPtr&lt;RegisterID&gt; homeObject = emitHomeObjectForCallee(generator);
 184     return generator.emitGetById(generator.newTemporary(), homeObject.get(), generator.propertyNames().underscoreProto);
 185 }
 186 
 187 static RegisterID* emitGetSuperFunctionForConstruct(BytecodeGenerator&amp; generator)
 188 {
 189     if (generator.isDerivedConstructorContext())
 190         return generator.emitGetById(generator.newTemporary(), generator.emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment(), generator.propertyNames().underscoreProto);
 191 
 192     RegisterID callee;
 193     callee.setIndex(CallFrameSlot::callee);
 194     return generator.emitGetById(generator.newTemporary(), &amp;callee, generator.propertyNames().underscoreProto);
 195 }
 196 
 197 RegisterID* SuperNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 198 {
 199     RegisterID* result = emitSuperBaseForCallee(generator);
 200     return generator.move(generator.finalDestination(dst), result);
 201 }
 202 
 203 // ------------------------------ ImportNode -------------------------------------
 204 
 205 RegisterID* ImportNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 206 {
 207     RefPtr&lt;RegisterID&gt; importModule = generator.emitGetGlobalPrivate(generator.newTemporary(), generator.propertyNames().builtinNames().importModulePrivateName());
 208     CallArguments arguments(generator, nullptr, 1);
 209     generator.emitLoad(arguments.thisRegister(), jsUndefined());
 210     generator.emitNode(arguments.argumentRegister(0), m_expr);
 211     return generator.emitCall(generator.finalDestination(dst, importModule.get()), importModule.get(), NoExpectedFunction, arguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);
 212 }
 213 
 214 // ------------------------------ NewTargetNode ----------------------------------
 215 
 216 RegisterID* NewTargetNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 217 {
 218     if (dst == generator.ignoredResult())
 219         return nullptr;
 220 
 221     return generator.move(dst, generator.newTarget());
 222 }
 223 
 224 // ------------------------------ ImportMetaNode ---------------------------------
 225 
 226 RegisterID* ImportMetaNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 227 {
 228     return generator.emitNode(dst, m_expr);
 229 }
 230 
 231 // ------------------------------ ResolveNode ----------------------------------
 232 
 233 bool ResolveNode::isPure(BytecodeGenerator&amp; generator) const
 234 {
 235     return generator.variable(m_ident).offset().isStack();
 236 }
 237 
 238 RegisterID* ResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 239 {
 240     Variable var = generator.variable(m_ident);
 241     if (RegisterID* local = var.local()) {
 242         generator.emitTDZCheckIfNecessary(var, local, nullptr);
 243         if (dst == generator.ignoredResult())
 244             return nullptr;
 245 
 246         generator.emitProfileType(local, var, m_position, JSTextPosition(-1, m_position.offset + m_ident.length(), -1));
 247         return generator.move(dst, local);
 248     }
 249 
 250     JSTextPosition divot = m_start + m_ident.length();
 251     generator.emitExpressionInfo(divot, m_start, divot);
 252     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(dst, var);
 253     RegisterID* finalDest = generator.finalDestination(dst);
 254     RefPtr&lt;RegisterID&gt; uncheckedResult = generator.newTemporary();
 255     generator.emitGetFromScope(uncheckedResult.get(), scope.get(), var, ThrowIfNotFound);
 256     generator.emitTDZCheckIfNecessary(var, uncheckedResult.get(), nullptr);
 257     generator.move(finalDest, uncheckedResult.get());
 258     generator.emitProfileType(finalDest, var, m_position, JSTextPosition(-1, m_position.offset + m_ident.length(), -1));
 259     return finalDest;
 260 }
 261 
 262 // ------------------------------ TemplateStringNode -----------------------------------
 263 
 264 RegisterID* TemplateStringNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 265 {
 266     if (dst == generator.ignoredResult())
 267         return nullptr;
 268     ASSERT(cooked());
 269     return generator.emitLoad(dst, JSValue(generator.addStringConstant(*cooked())));
 270 }
 271 
 272 // ------------------------------ TemplateLiteralNode -----------------------------------
 273 
 274 RegisterID* TemplateLiteralNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 275 {
 276     if (!m_templateExpressions) {
 277         TemplateStringNode* templateString = m_templateStrings-&gt;value();
 278         ASSERT_WITH_MESSAGE(!m_templateStrings-&gt;next(), &quot;Only one template element exists because there&#39;s no expression in a given template literal.&quot;);
 279         return generator.emitNode(dst, templateString);
 280     }
 281 
 282     Vector&lt;RefPtr&lt;RegisterID&gt;, 16&gt; temporaryRegisters;
 283 
 284     TemplateStringListNode* templateString = m_templateStrings;
 285     TemplateExpressionListNode* templateExpression = m_templateExpressions;
 286     for (; templateExpression; templateExpression = templateExpression-&gt;next(), templateString = templateString-&gt;next()) {
 287         // Evaluate TemplateString.
 288         ASSERT(templateString-&gt;value()-&gt;cooked());
 289         if (!templateString-&gt;value()-&gt;cooked()-&gt;isEmpty()) {
 290             temporaryRegisters.append(generator.newTemporary());
 291             generator.emitNode(temporaryRegisters.last().get(), templateString-&gt;value());
 292         }
 293 
 294         // Evaluate Expression.
 295         temporaryRegisters.append(generator.newTemporary());
 296         generator.emitNode(temporaryRegisters.last().get(), templateExpression-&gt;value());
 297         generator.emitToString(temporaryRegisters.last().get(), temporaryRegisters.last().get());
 298     }
 299 
 300     // Evaluate tail TemplateString.
 301     ASSERT(templateString-&gt;value()-&gt;cooked());
 302     if (!templateString-&gt;value()-&gt;cooked()-&gt;isEmpty()) {
 303         temporaryRegisters.append(generator.newTemporary());
 304         generator.emitNode(temporaryRegisters.last().get(), templateString-&gt;value());
 305     }
 306 
 307     if (temporaryRegisters.size() == 1)
 308         return generator.emitToString(generator.finalDestination(dst, temporaryRegisters[0].get()), temporaryRegisters[0].get());
 309 
 310     return generator.emitStrcat(generator.finalDestination(dst, temporaryRegisters[0].get()), temporaryRegisters[0].get(), temporaryRegisters.size());
 311 }
 312 
 313 // ------------------------------ TaggedTemplateNode -----------------------------------
 314 
 315 RegisterID* TaggedTemplateNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 316 {
 317     ExpectedFunction expectedFunction = NoExpectedFunction;
 318     RefPtr&lt;RegisterID&gt; tag = nullptr;
 319     RefPtr&lt;RegisterID&gt; base = nullptr;
 320     if (!m_tag-&gt;isLocation()) {
 321         tag = generator.newTemporary();
 322         tag = generator.emitNode(tag.get(), m_tag);
 323     } else if (m_tag-&gt;isResolveNode()) {
 324         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(m_tag);
 325         const Identifier&amp; identifier = resolve-&gt;identifier();
 326         expectedFunction = generator.expectedFunctionForIdentifier(identifier);
 327 
 328         Variable var = generator.variable(identifier);
 329         if (RegisterID* local = var.local()) {
 330             generator.emitTDZCheckIfNecessary(var, local, nullptr);
 331             tag = generator.move(generator.newTemporary(), local);
 332         } else {
 333             tag = generator.newTemporary();
 334             base = generator.newTemporary();
 335 
 336             JSTextPosition newDivot = divotStart() + identifier.length();
 337             generator.emitExpressionInfo(newDivot, divotStart(), newDivot);
 338             generator.move(base.get(), generator.emitResolveScope(base.get(), var));
 339             generator.emitGetFromScope(tag.get(), base.get(), var, ThrowIfNotFound);
 340             generator.emitTDZCheckIfNecessary(var, tag.get(), nullptr);
 341         }
 342     } else if (m_tag-&gt;isBracketAccessorNode()) {
 343         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(m_tag);
 344         base = generator.newTemporary();
 345         base = generator.emitNode(base.get(), bracket-&gt;base());
 346         RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(bracket-&gt;subscript());
 347         if (bracket-&gt;base()-&gt;isSuperNode()) {
 348             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 349             tag = generator.emitGetByVal(generator.newTemporary(), base.get(), thisValue.get(), property.get());
 350         } else
 351             tag = generator.emitGetByVal(generator.newTemporary(), base.get(), property.get());
 352     } else {
 353         ASSERT(m_tag-&gt;isDotAccessorNode());
 354         DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(m_tag);
 355         base = generator.newTemporary();
 356         base = generator.emitNode(base.get(), dot-&gt;base());
 357         if (dot-&gt;base()-&gt;isSuperNode()) {
 358             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 359             tag = generator.emitGetById(generator.newTemporary(), base.get(), thisValue.get(), dot-&gt;identifier());
 360         } else
 361             tag = generator.emitGetById(generator.newTemporary(), base.get(), dot-&gt;identifier());
 362     }
 363 
 364     RefPtr&lt;RegisterID&gt; templateObject = generator.emitGetTemplateObject(nullptr, this);
 365 
 366     unsigned expressionsCount = 0;
 367     for (TemplateExpressionListNode* templateExpression = m_templateLiteral-&gt;templateExpressions(); templateExpression; templateExpression = templateExpression-&gt;next())
 368         ++expressionsCount;
 369 
 370     CallArguments callArguments(generator, nullptr, 1 + expressionsCount);
 371     if (base)
 372         generator.move(callArguments.thisRegister(), base.get());
 373     else
 374         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 375 
 376     unsigned argumentIndex = 0;
 377     generator.move(callArguments.argumentRegister(argumentIndex++), templateObject.get());
 378     for (TemplateExpressionListNode* templateExpression = m_templateLiteral-&gt;templateExpressions(); templateExpression; templateExpression = templateExpression-&gt;next())
 379         generator.emitNode(callArguments.argumentRegister(argumentIndex++), templateExpression-&gt;value());
 380 
 381     return generator.emitCallInTailPosition(generator.finalDestination(dst, tag.get()), tag.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 382 }
 383 
 384 // ------------------------------ ArrayNode ------------------------------------
 385 
 386 RegisterID* ArrayNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 387 {
 388     bool hadVariableExpression = false;
 389     unsigned length = 0;
 390 
 391     IndexingType recommendedIndexingType = ArrayWithUndecided;
 392     ElementNode* firstPutElement;
 393     for (firstPutElement = m_element; firstPutElement; firstPutElement = firstPutElement-&gt;next()) {
 394         if (firstPutElement-&gt;elision() || firstPutElement-&gt;value()-&gt;isSpreadExpression())
 395             break;
 396         if (!firstPutElement-&gt;value()-&gt;isConstant())
 397             hadVariableExpression = true;
 398         else
 399             recommendedIndexingType = leastUpperBoundOfIndexingTypeAndValue(recommendedIndexingType, static_cast&lt;ConstantNode*&gt;(firstPutElement-&gt;value())-&gt;jsValue(generator));
 400 
 401         ++length;
 402     }
 403 
 404     auto newArray = [&amp;] (RegisterID* dst, ElementNode* elements, unsigned length, bool hadVariableExpression) {
 405         if (length &amp;&amp; !hadVariableExpression) {
 406             recommendedIndexingType |= CopyOnWrite;
<a name="5" id="anc5"></a><span class="line-modified"> 407             ASSERT(generator.vm()-&gt;heap.isDeferred()); // We run bytecode generator under a DeferGC. If we stopped doing that, we&#39;d need to put a DeferGC here as we filled in these slots.</span>
<span class="line-modified"> 408             auto* array = JSImmutableButterfly::create(*generator.vm(), recommendedIndexingType, length);</span>
 409             unsigned index = 0;
 410             for (ElementNode* element = elements; index &lt; length; element = element-&gt;next()) {
 411                 ASSERT(element-&gt;value()-&gt;isConstant());
<a name="6" id="anc6"></a><span class="line-modified"> 412                 array-&gt;setIndex(*generator.vm(), index++, static_cast&lt;ConstantNode*&gt;(element-&gt;value())-&gt;jsValue(generator));</span>
 413             }
 414             return generator.emitNewArrayBuffer(dst, array, recommendedIndexingType);
 415         }
 416         return generator.emitNewArray(dst, elements, length, recommendedIndexingType);
 417     };
 418 
 419     if (!firstPutElement &amp;&amp; !m_elision)
 420         return newArray(generator.finalDestination(dst), m_element, length, hadVariableExpression);
 421 
 422     if (firstPutElement &amp;&amp; firstPutElement-&gt;value()-&gt;isSpreadExpression()) {
 423         bool hasElision = m_elision;
 424         if (!hasElision) {
 425             for (ElementNode* node = firstPutElement; node; node = node-&gt;next()) {
 426                 if (node-&gt;elision()) {
 427                     hasElision = true;
 428                     break;
 429                 }
 430             }
 431         }
 432 
 433         if (!hasElision)
 434             return generator.emitNewArrayWithSpread(generator.finalDestination(dst), m_element);
 435     }
 436 
 437     RefPtr&lt;RegisterID&gt; array = newArray(generator.tempDestination(dst), m_element, length, hadVariableExpression);
 438     ElementNode* n = firstPutElement;
 439     for (; n; n = n-&gt;next()) {
 440         if (n-&gt;value()-&gt;isSpreadExpression())
 441             goto handleSpread;
 442         RefPtr&lt;RegisterID&gt; value = generator.emitNode(n-&gt;value());
 443         length += n-&gt;elision();
 444 
 445         RefPtr&lt;RegisterID&gt; index = generator.emitLoad(nullptr, jsNumber(length++));
 446         generator.emitDirectPutByVal(array.get(), index.get(), value.get());
 447     }
 448 
 449     if (m_elision) {
 450         RegisterID* value = generator.emitLoad(0, jsNumber(m_elision + length));
 451         generator.emitPutById(array.get(), generator.propertyNames().length, value);
 452     }
 453 
 454     return generator.move(dst, array.get());
 455 
 456 handleSpread:
 457     RefPtr&lt;RegisterID&gt; index = generator.emitLoad(generator.newTemporary(), jsNumber(length));
 458     auto spreader = scopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;([array, index](BytecodeGenerator&amp; generator, RegisterID* value)
 459     {
 460         generator.emitDirectPutByVal(array.get(), index.get(), value);
 461         generator.emitInc(index.get());
 462     });
 463     for (; n; n = n-&gt;next()) {
 464         if (n-&gt;elision())
 465             generator.emitBinaryOp&lt;OpAdd&gt;(index.get(), index.get(), generator.emitLoad(0, jsNumber(n-&gt;elision())), OperandTypes(ResultType::numberTypeIsInt32(), ResultType::numberTypeIsInt32()));
 466         if (n-&gt;value()-&gt;isSpreadExpression()) {
 467             SpreadExpressionNode* spread = static_cast&lt;SpreadExpressionNode*&gt;(n-&gt;value());
 468             generator.emitEnumeration(spread, spread-&gt;expression(), spreader);
 469         } else {
 470             generator.emitDirectPutByVal(array.get(), index.get(), generator.emitNode(n-&gt;value()));
 471             generator.emitInc(index.get());
 472         }
 473     }
 474 
 475     if (m_elision) {
 476         generator.emitBinaryOp&lt;OpAdd&gt;(index.get(), index.get(), generator.emitLoad(0, jsNumber(m_elision)), OperandTypes(ResultType::numberTypeIsInt32(), ResultType::numberTypeIsInt32()));
 477         generator.emitPutById(array.get(), generator.propertyNames().length, index.get());
 478     }
 479     return generator.move(dst, array.get());
 480 }
 481 
 482 bool ArrayNode::isSimpleArray() const
 483 {
 484     if (m_elision || m_optional)
 485         return false;
 486     for (ElementNode* ptr = m_element; ptr; ptr = ptr-&gt;next()) {
 487         if (ptr-&gt;elision())
 488             return false;
 489         if (ptr-&gt;value()-&gt;isSpreadExpression())
 490             return false;
 491     }
 492     return true;
 493 }
 494 
 495 ArgumentListNode* ArrayNode::toArgumentList(ParserArena&amp; parserArena, int lineNumber, int startPosition) const
 496 {
 497     ASSERT(!m_elision &amp;&amp; !m_optional);
 498     ElementNode* ptr = m_element;
 499     if (!ptr)
 500         return 0;
 501     JSTokenLocation location;
 502     location.line = lineNumber;
 503     location.startOffset = startPosition;
 504     ArgumentListNode* head = new (parserArena) ArgumentListNode(location, ptr-&gt;value());
 505     ArgumentListNode* tail = head;
 506     ptr = ptr-&gt;next();
 507     for (; ptr; ptr = ptr-&gt;next()) {
 508         ASSERT(!ptr-&gt;elision());
 509         tail = new (parserArena) ArgumentListNode(location, tail, ptr-&gt;value());
 510     }
 511     return head;
 512 }
 513 
 514 // ------------------------------ ObjectLiteralNode ----------------------------
 515 
 516 RegisterID* ObjectLiteralNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 517 {
 518     if (!m_list) {
 519         if (dst == generator.ignoredResult())
 520             return 0;
 521         return generator.emitNewObject(generator.finalDestination(dst));
 522     }
 523     RefPtr&lt;RegisterID&gt; newObj = generator.emitNewObject(generator.tempDestination(dst));
 524     generator.emitNode(newObj.get(), m_list);
 525     return generator.move(dst, newObj.get());
 526 }
 527 
 528 // ------------------------------ PropertyListNode -----------------------------
 529 
 530 static inline void emitPutHomeObject(BytecodeGenerator&amp; generator, RegisterID* function, RegisterID* homeObject)
 531 {
 532     generator.emitPutById(function, generator.propertyNames().builtinNames().homeObjectPrivateName(), homeObject);
 533 }
 534 
 535 RegisterID* PropertyListNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dstOrConstructor, RegisterID* prototype)
 536 {
 537     // Fast case: this loop just handles regular value properties.
 538     PropertyListNode* p = this;
 539     RegisterID* dst = nullptr;
 540     for (; p &amp;&amp; (p-&gt;m_node-&gt;m_type &amp; PropertyNode::Constant); p = p-&gt;m_next) {
 541         dst = p-&gt;m_node-&gt;isInstanceClassProperty() ? prototype : dstOrConstructor;
 542         emitPutConstantProperty(generator, dst, *p-&gt;m_node);
 543     }
 544 
 545     // Were there any get/set properties?
 546     if (p) {
 547         // Build a list of getter/setter pairs to try to put them at the same time. If we encounter
 548         // a computed property or a spread, just emit everything as that may override previous values.
 549         bool canOverrideProperties = false;
 550 
 551         typedef std::pair&lt;PropertyNode*, PropertyNode*&gt; GetterSetterPair;
 552         typedef HashMap&lt;UniquedStringImpl*, GetterSetterPair, IdentifierRepHash&gt; GetterSetterMap;
 553         GetterSetterMap instanceMap;
 554         GetterSetterMap staticMap;
 555 
 556         // Build a map, pairing get/set values together.
 557         for (PropertyListNode* q = p; q; q = q-&gt;m_next) {
 558             PropertyNode* node = q-&gt;m_node;
 559             if (node-&gt;m_type &amp; PropertyNode::Computed || node-&gt;m_type &amp; PropertyNode::Spread) {
 560                 canOverrideProperties = true;
 561                 break;
 562             }
 563 
 564             if (node-&gt;m_type &amp; PropertyNode::Constant)
 565                 continue;
 566 
 567             // Duplicates are possible.
 568             GetterSetterPair pair(node, static_cast&lt;PropertyNode*&gt;(nullptr));
 569             GetterSetterMap&amp; map = node-&gt;isStaticClassProperty() ? staticMap : instanceMap;
 570             GetterSetterMap::AddResult result = map.add(node-&gt;name()-&gt;impl(), pair);
 571             auto&amp; resultPair = result.iterator-&gt;value;
 572             if (!result.isNewEntry) {
 573                 if (resultPair.first-&gt;m_type == node-&gt;m_type) {
 574                     resultPair.first-&gt;setIsOverriddenByDuplicate();
 575                     resultPair.first = node;
 576                 } else {
 577                     if (resultPair.second)
 578                         resultPair.second-&gt;setIsOverriddenByDuplicate();
 579                     resultPair.second = node;
 580                 }
 581             }
 582         }
 583 
 584         // Iterate over the remaining properties in the list.
 585         for (; p; p = p-&gt;m_next) {
 586             PropertyNode* node = p-&gt;m_node;
 587             dst = node-&gt;isInstanceClassProperty() ? prototype : dstOrConstructor;
 588 
 589             // Handle regular values.
 590             if (node-&gt;m_type &amp; PropertyNode::Constant) {
 591                 emitPutConstantProperty(generator, dst, *node);
 592                 continue;
 593             } else if (node-&gt;m_type &amp; PropertyNode::Spread) {
 594                 generator.emitNode(dst, node-&gt;m_assign);
 595                 continue;
 596             }
 597 
 598             RefPtr&lt;RegisterID&gt; value = generator.emitNode(node-&gt;m_assign);
 599             bool needsSuperBinding = node-&gt;needsSuperBinding();
 600             if (needsSuperBinding)
 601                 emitPutHomeObject(generator, value.get(), dst);
 602 
 603             unsigned attributes = node-&gt;isClassProperty() ? (PropertyAttribute::Accessor | PropertyAttribute::DontEnum) : static_cast&lt;unsigned&gt;(PropertyAttribute::Accessor);
 604 
 605             ASSERT(node-&gt;m_type &amp; (PropertyNode::Getter | PropertyNode::Setter));
 606 
 607             // This is a get/set property which may be overridden by a computed property or spread later.
 608             if (canOverrideProperties) {
 609                 // Computed accessors.
 610                 if (node-&gt;m_type &amp; PropertyNode::Computed) {
 611                     RefPtr&lt;RegisterID&gt; propertyName = generator.emitNode(node-&gt;m_expression);
 612                     generator.emitSetFunctionNameIfNeeded(node-&gt;m_assign, value.get(), propertyName.get());
 613                     if (node-&gt;m_type &amp; PropertyNode::Getter)
 614                         generator.emitPutGetterByVal(dst, propertyName.get(), attributes, value.get());
 615                     else
 616                         generator.emitPutSetterByVal(dst, propertyName.get(), attributes, value.get());
 617                     continue;
 618                 }
 619 
 620                 if (node-&gt;m_type &amp; PropertyNode::Getter)
 621                     generator.emitPutGetterById(dst, *node-&gt;name(), attributes, value.get());
 622                 else
 623                     generator.emitPutSetterById(dst, *node-&gt;name(), attributes, value.get());
 624                 continue;
 625             }
 626 
 627             // This is a get/set property pair.
 628             GetterSetterMap&amp; map = node-&gt;isStaticClassProperty() ? staticMap : instanceMap;
 629             GetterSetterMap::iterator it = map.find(node-&gt;name()-&gt;impl());
 630             ASSERT(it != map.end());
 631             GetterSetterPair&amp; pair = it-&gt;value;
 632 
 633             // Was this already generated as a part of its partner?
 634             if (pair.second == node || node-&gt;isOverriddenByDuplicate())
 635                 continue;
 636 
 637             // Generate the paired node now.
 638             RefPtr&lt;RegisterID&gt; getterReg;
 639             RefPtr&lt;RegisterID&gt; setterReg;
 640             RegisterID* secondReg = nullptr;
 641 
 642             if (node-&gt;m_type &amp; PropertyNode::Getter) {
 643                 getterReg = value;
 644                 if (pair.second) {
 645                     ASSERT(pair.second-&gt;m_type &amp; PropertyNode::Setter);
 646                     setterReg = generator.emitNode(pair.second-&gt;m_assign);
 647                     secondReg = setterReg.get();
 648                 } else {
 649                     setterReg = generator.newTemporary();
 650                     generator.emitLoad(setterReg.get(), jsUndefined());
 651                 }
 652             } else {
 653                 ASSERT(node-&gt;m_type &amp; PropertyNode::Setter);
 654                 setterReg = value;
 655                 if (pair.second) {
 656                     ASSERT(pair.second-&gt;m_type &amp; PropertyNode::Getter);
 657                     getterReg = generator.emitNode(pair.second-&gt;m_assign);
 658                     secondReg = getterReg.get();
 659                 } else {
 660                     getterReg = generator.newTemporary();
 661                     generator.emitLoad(getterReg.get(), jsUndefined());
 662                 }
 663             }
 664 
 665             ASSERT(!pair.second || needsSuperBinding == pair.second-&gt;needsSuperBinding());
 666             if (needsSuperBinding &amp;&amp; pair.second)
 667                 emitPutHomeObject(generator, secondReg, dst);
 668 
 669             generator.emitPutGetterSetter(dst, *node-&gt;name(), attributes, getterReg.get(), setterReg.get());
 670         }
 671     }
 672 
 673     return dstOrConstructor;
 674 }
 675 
 676 void PropertyListNode::emitPutConstantProperty(BytecodeGenerator&amp; generator, RegisterID* newObj, PropertyNode&amp; node)
 677 {
 678     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node.m_assign);
 679     if (node.needsSuperBinding())
 680         emitPutHomeObject(generator, value.get(), newObj);
 681 
 682     if (node.isClassProperty()) {
 683         ASSERT(node.needsSuperBinding());
 684         RefPtr&lt;RegisterID&gt; propertyNameRegister;
 685         if (node.name())
 686             propertyNameRegister = generator.emitLoad(nullptr, *node.name());
 687         else
 688             propertyNameRegister = generator.emitNode(node.m_expression);
 689 
 690         generator.emitSetFunctionNameIfNeeded(node.m_assign, value.get(), propertyNameRegister.get());
 691         generator.emitCallDefineProperty(newObj, propertyNameRegister.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable, m_position);
 692         return;
 693     }
 694     if (const auto* identifier = node.name()) {
 695         Optional&lt;uint32_t&gt; optionalIndex = parseIndex(*identifier);
 696         if (!optionalIndex) {
 697             generator.emitDirectPutById(newObj, *identifier, value.get(), node.putType());
 698             return;
 699         }
 700 
 701         RefPtr&lt;RegisterID&gt; index = generator.emitLoad(nullptr, jsNumber(optionalIndex.value()));
 702         generator.emitDirectPutByVal(newObj, index.get(), value.get());
 703         return;
 704     }
 705     RefPtr&lt;RegisterID&gt; propertyName = generator.emitNode(node.m_expression);
 706     generator.emitSetFunctionNameIfNeeded(node.m_assign, value.get(), propertyName.get());
 707     generator.emitDirectPutByVal(newObj, propertyName.get(), value.get());
 708 }
 709 
 710 // ------------------------------ BracketAccessorNode --------------------------------
 711 
 712 static bool isNonIndexStringElement(ExpressionNode&amp; element)
 713 {
 714     return element.isString() &amp;&amp; !parseIndex(static_cast&lt;StringNode&amp;&gt;(element).value());
 715 }
 716 
 717 RegisterID* BracketAccessorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 718 {
 719     if (m_base-&gt;isSuperNode()) {
 720         RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
 721         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 722         RefPtr&lt;RegisterID&gt; superBase = emitSuperBaseForCallee(generator);
 723 
 724         if (isNonIndexStringElement(*m_subscript)) {
 725             const Identifier&amp; id = static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value();
 726             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 727             generator.emitGetById(finalDest.get(), superBase.get(), thisValue.get(), id);
 728         } else  {
 729             RefPtr&lt;RegisterID&gt; subscript = generator.emitNodeForProperty(m_subscript);
 730             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 731             generator.emitGetByVal(finalDest.get(), superBase.get(), thisValue.get(), subscript.get());
 732         }
 733 
 734         generator.emitProfileType(finalDest.get(), divotStart(), divotEnd());
 735         return finalDest.get();
 736     }
 737 
 738     RegisterID* ret;
 739     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
 740 
<a name="7" id="anc7"></a><span class="line-modified"> 741     if (isNonIndexStringElement(*m_subscript)) {</span>
<span class="line-modified"> 742         RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);</span>







 743         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 744         ret = generator.emitGetById(finalDest.get(), base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());
 745     } else {
<a name="8" id="anc8"></a><span class="line-removed"> 746         RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments, m_subscript-&gt;isPure(generator));</span>
 747         RegisterID* property = generator.emitNodeForProperty(m_subscript);
 748         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 749         ret = generator.emitGetByVal(finalDest.get(), base.get(), property);
 750     }
 751 
 752     generator.emitProfileType(finalDest.get(), divotStart(), divotEnd());
 753     return ret;
 754 }
 755 
 756 // ------------------------------ DotAccessorNode --------------------------------
 757 
 758 RegisterID* DotAccessorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 759 {
<a name="9" id="anc9"></a>
 760     bool baseIsSuper = m_base-&gt;isSuperNode();
<a name="10" id="anc10"></a><span class="line-modified"> 761     RefPtr&lt;RegisterID&gt; base = baseIsSuper ? emitSuperBaseForCallee(generator) : generator.emitNode(m_base);</span>









 762     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
<a name="11" id="anc11"></a><span class="line-removed"> 763     RegisterID* finalDest = generator.finalDestination(dst);</span>
 764     RegisterID* ret;
 765     if (baseIsSuper) {
 766         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
<a name="12" id="anc12"></a><span class="line-modified"> 767         ret = generator.emitGetById(finalDest, base.get(), thisValue.get(), m_ident);</span>
 768     } else
<a name="13" id="anc13"></a><span class="line-modified"> 769         ret = generator.emitGetById(finalDest, base.get(), m_ident);</span>
<span class="line-modified"> 770     generator.emitProfileType(finalDest, divotStart(), divotEnd());</span>
 771     return ret;
 772 }
 773 
 774 // ------------------------------ ArgumentListNode -----------------------------
 775 
 776 RegisterID* ArgumentListNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 777 {
 778     ASSERT(m_expr);
 779     return generator.emitNode(dst, m_expr);
 780 }
 781 
 782 // ------------------------------ NewExprNode ----------------------------------
 783 
 784 RegisterID* NewExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 785 {
 786     ExpectedFunction expectedFunction;
 787     if (m_expr-&gt;isResolveNode())
 788         expectedFunction = generator.expectedFunctionForIdentifier(static_cast&lt;ResolveNode*&gt;(m_expr)-&gt;identifier());
 789     else
 790         expectedFunction = NoExpectedFunction;
 791     RefPtr&lt;RegisterID&gt; func = generator.emitNode(m_expr);
 792     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 793     CallArguments callArguments(generator, m_args);
 794     return generator.emitConstruct(returnValue.get(), func.get(), func.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd());
 795 }
 796 
 797 CallArguments::CallArguments(BytecodeGenerator&amp; generator, ArgumentsNode* argumentsNode, unsigned additionalArguments)
 798     : m_argumentsNode(argumentsNode)
 799     , m_padding(0)
 800 {
 801     size_t argumentCountIncludingThis = 1 + additionalArguments; // &#39;this&#39; register.
 802     if (argumentsNode) {
 803         for (ArgumentListNode* node = argumentsNode-&gt;m_listNode; node; node = node-&gt;m_next)
 804             ++argumentCountIncludingThis;
 805     }
 806 
 807     m_argv.grow(argumentCountIncludingThis);
 808     for (int i = argumentCountIncludingThis - 1; i &gt;= 0; --i) {
 809         m_argv[i] = generator.newTemporary();
 810         ASSERT(static_cast&lt;size_t&gt;(i) == m_argv.size() - 1 || m_argv[i]-&gt;index() == m_argv[i + 1]-&gt;index() - 1);
 811     }
 812 
 813     // We need to ensure that the frame size is stack-aligned
 814     while ((CallFrame::headerSizeInRegisters + m_argv.size()) % stackAlignmentRegisters()) {
 815         m_argv.insert(0, generator.newTemporary());
 816         m_padding++;
 817     }
 818 
 819     while (stackOffset() % stackAlignmentRegisters()) {
 820         m_argv.insert(0, generator.newTemporary());
 821         m_padding++;
 822     }
 823 }
 824 
 825 // ------------------------------ EvalFunctionCallNode ----------------------------------
 826 
 827 RegisterID* EvalFunctionCallNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 828 {
 829     // We need try to load &#39;this&#39; before call eval in constructor, because &#39;this&#39; can created by &#39;super&#39; in some of the arrow function
 830     // var A = class A {
 831     //   constructor () { this.id = &#39;A&#39;; }
 832     // }
 833     //
 834     // var B = class B extend A {
 835     //    constructor () {
 836     //       var arrow = () =&gt; super();
 837     //       arrow();
 838     //       eval(&quot;this.id = &#39;B&#39;&quot;);
 839     //    }
 840     // }
 841     if (generator.constructorKind() == ConstructorKind::Extends &amp;&amp; generator.needsToUpdateArrowFunctionContext() &amp;&amp; generator.isThisUsedInInnerArrowFunction())
 842         generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
 843 
 844     Variable var = generator.variable(generator.propertyNames().eval);
<a name="14" id="anc14"></a><span class="line-modified"> 845     if (RegisterID* local = var.local()) {</span>
<span class="line-modified"> 846         generator.emitTDZCheckIfNecessary(var, local, nullptr);</span>
<span class="line-modified"> 847         RefPtr&lt;RegisterID&gt; func = generator.move(generator.tempDestination(dst), local);</span>
<span class="line-modified"> 848         CallArguments callArguments(generator, m_args);</span>






 849         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
<a name="15" id="anc15"></a><span class="line-modified"> 850         return generator.emitCallEval(generator.finalDestination(dst, func.get()), func.get(), callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);</span>







 851     }
 852 
<a name="16" id="anc16"></a><span class="line-modified"> 853     RefPtr&lt;RegisterID&gt; func = generator.newTemporary();</span>
<span class="line-modified"> 854     CallArguments callArguments(generator, m_args);</span>
<span class="line-modified"> 855     JSTextPosition newDivot = divotStart() + 4;</span>
<span class="line-modified"> 856     generator.emitExpressionInfo(newDivot, divotStart(), newDivot);</span>
<span class="line-modified"> 857     generator.move(</span>
<span class="line-removed"> 858         callArguments.thisRegister(),</span>
<span class="line-removed"> 859         generator.emitResolveScope(callArguments.thisRegister(), var));</span>
<span class="line-removed"> 860     generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);</span>
<span class="line-removed"> 861     generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);</span>
<span class="line-removed"> 862     return generator.emitCallEval(generator.finalDestination(dst, func.get()), func.get(), callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);</span>
 863 }
 864 
 865 // ------------------------------ FunctionCallValueNode ----------------------------------
 866 
 867 RegisterID* FunctionCallValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 868 {
 869     if (m_expr-&gt;isSuperNode()) {
 870         RefPtr&lt;RegisterID&gt; func = emitGetSuperFunctionForConstruct(generator);
 871         RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 872         CallArguments callArguments(generator, m_args);
 873 
 874         ASSERT(generator.isConstructor() || generator.derivedContextType() == DerivedContextType::DerivedConstructorContext);
 875         ASSERT(generator.constructorKind() == ConstructorKind::Extends || generator.derivedContextType() == DerivedContextType::DerivedConstructorContext);
 876         RegisterID* ret = generator.emitConstruct(returnValue.get(), func.get(), generator.newTarget(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd());
 877 
 878         bool isConstructorKindDerived = generator.constructorKind() == ConstructorKind::Extends;
 879         bool doWeUseArrowFunctionInConstructor = isConstructorKindDerived &amp;&amp; generator.needsToUpdateArrowFunctionContext();
 880 
 881         if (generator.isDerivedConstructorContext() || (doWeUseArrowFunctionInConstructor &amp;&amp; generator.isSuperCallUsedInInnerArrowFunction()))
 882             generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
 883 
 884         Ref&lt;Label&gt; thisIsEmptyLabel = generator.newLabel();
 885         generator.emitJumpIfTrue(generator.emitIsEmpty(generator.newTemporary(), generator.thisRegister()), thisIsEmptyLabel.get());
 886         generator.emitThrowReferenceError(&quot;&#39;super()&#39; can&#39;t be called more than once in a constructor.&quot;_s);
 887         generator.emitLabel(thisIsEmptyLabel.get());
 888 
 889         generator.move(generator.thisRegister(), ret);
 890 
 891         if (generator.isDerivedConstructorContext() || doWeUseArrowFunctionInConstructor)
 892             generator.emitPutThisToArrowFunctionContextScope();
 893 
 894         return ret;
 895     }
<a name="17" id="anc17"></a>
 896     RefPtr&lt;RegisterID&gt; func = generator.emitNode(m_expr);
 897     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
<a name="18" id="anc18"></a>


 898     CallArguments callArguments(generator, m_args);
 899     generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 900     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 901     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
 902     return ret;
 903 }
 904 
 905 // ------------------------------ FunctionCallResolveNode ----------------------------------
 906 
 907 RegisterID* FunctionCallResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 908 {
<a name="19" id="anc19"></a><span class="line-modified"> 909     if (UNLIKELY(m_ident == generator.vm()-&gt;propertyNames-&gt;builtinNames().assertPrivateName())) {</span>
 910         if (ASSERT_DISABLED)
 911             return generator.move(dst, generator.emitLoad(nullptr, jsUndefined()));
 912     }
 913 
 914     ExpectedFunction expectedFunction = generator.expectedFunctionForIdentifier(m_ident);
 915 
 916     Variable var = generator.variable(m_ident);
<a name="20" id="anc20"></a><span class="line-modified"> 917     if (RegisterID* local = var.local()) {</span>
<span class="line-modified"> 918         generator.emitTDZCheckIfNecessary(var, local, nullptr);</span>
<span class="line-modified"> 919         RefPtr&lt;RegisterID&gt; func = generator.move(generator.tempDestination(dst), local);</span>
<span class="line-modified"> 920         RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());</span>
<span class="line-modified"> 921         CallArguments callArguments(generator, m_args);</span>





 922         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 923         // This passes NoExpectedFunction because we expect that if the function is in a
 924         // local variable, then it&#39;s not one of our built-in constructors.
<a name="21" id="anc21"></a><span class="line-modified"> 925         RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);</span>
<span class="line-modified"> 926         generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());</span>
<span class="line-modified"> 927         return ret;</span>






 928     }
 929 
<a name="22" id="anc22"></a><span class="line-removed"> 930     RefPtr&lt;RegisterID&gt; func = generator.newTemporary();</span>
 931     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
<a name="23" id="anc23"></a><span class="line-modified"> 932     CallArguments callArguments(generator, m_args);</span>

 933 
<a name="24" id="anc24"></a><span class="line-removed"> 934     JSTextPosition newDivot = divotStart() + m_ident.length();</span>
<span class="line-removed"> 935     generator.emitExpressionInfo(newDivot, divotStart(), newDivot);</span>
<span class="line-removed"> 936     generator.move(</span>
<span class="line-removed"> 937         callArguments.thisRegister(),</span>
<span class="line-removed"> 938         generator.emitResolveScope(callArguments.thisRegister(), var));</span>
<span class="line-removed"> 939     generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);</span>
<span class="line-removed"> 940     generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);</span>
 941     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 942     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
 943     return ret;
 944 }
 945 
 946 // ------------------------------ BytecodeIntrinsicNode ----------------------------------
 947 
 948 RegisterID* BytecodeIntrinsicNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 949 {
 950     return (this-&gt;*m_emitter)(generator, dst);
 951 }
 952 
 953 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
 954 {
 955     ArgumentListNode* node = m_args-&gt;m_listNode;
 956     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
 957     node = node-&gt;m_next;
 958     ASSERT(node-&gt;m_expr-&gt;isString());
 959     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
 960     ASSERT(!node-&gt;m_next);
 961     return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), ident);
 962 }
 963 
 964 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirectPrivate(BytecodeGenerator&amp; generator, RegisterID* dst)
 965 {
 966     ArgumentListNode* node = m_args-&gt;m_listNode;
 967     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
 968     node = node-&gt;m_next;
 969     ASSERT(node-&gt;m_expr-&gt;isString());
<a name="25" id="anc25"></a><span class="line-modified"> 970     SymbolImpl* symbol = generator.vm()-&gt;propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());</span>
 971     ASSERT(symbol);
 972     ASSERT(!node-&gt;m_next);
 973     return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol));
 974 }
 975 
 976 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_argument(BytecodeGenerator&amp; generator, RegisterID* dst)
 977 {
 978     ArgumentListNode* node = m_args-&gt;m_listNode;
 979     ASSERT(node-&gt;m_expr-&gt;isNumber());
 980     double value = static_cast&lt;NumberNode*&gt;(node-&gt;m_expr)-&gt;value();
 981     int32_t index = static_cast&lt;int32_t&gt;(value);
 982     ASSERT(value == index);
 983     ASSERT(index &gt;= 0);
 984     ASSERT(!node-&gt;m_next);
 985 
 986     // The body functions of generator and async have different mechanism for arguments.
 987     ASSERT(generator.parseMode() != SourceParseMode::GeneratorBodyMode);
 988     ASSERT(!isAsyncFunctionBodyParseMode(generator.parseMode()));
 989 
 990     return generator.emitGetArgument(generator.finalDestination(dst), index);
 991 }
 992 
 993 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_argumentCount(BytecodeGenerator&amp; generator, RegisterID* dst)
 994 {
 995     ASSERT(!m_args-&gt;m_listNode);
 996 
 997     return generator.emitArgumentCount(generator.finalDestination(dst));
 998 }
 999 
1000 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByIdDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
1001 {
1002     ArgumentListNode* node = m_args-&gt;m_listNode;
1003     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1004     node = node-&gt;m_next;
1005     ASSERT(node-&gt;m_expr-&gt;isString());
1006     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1007     node = node-&gt;m_next;
1008     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1009 
1010     ASSERT(!node-&gt;m_next);
1011 
1012     return generator.move(dst, generator.emitDirectPutById(base.get(), ident, value.get(), PropertyNode::KnownDirect));
1013 }
1014 
1015 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByIdDirectPrivate(BytecodeGenerator&amp; generator, RegisterID* dst)
1016 {
1017     ArgumentListNode* node = m_args-&gt;m_listNode;
1018     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1019     node = node-&gt;m_next;
1020     ASSERT(node-&gt;m_expr-&gt;isString());
<a name="26" id="anc26"></a><span class="line-modified">1021     SymbolImpl* symbol = generator.vm()-&gt;propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());</span>
1022     ASSERT(symbol);
1023     node = node-&gt;m_next;
1024     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1025 
1026     ASSERT(!node-&gt;m_next);
1027 
1028     return generator.move(dst, generator.emitDirectPutById(base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol), value.get(), PropertyNode::KnownDirect));
1029 }
1030 
1031 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByValDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
1032 {
1033     ArgumentListNode* node = m_args-&gt;m_listNode;
1034     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1035     node = node-&gt;m_next;
1036     RefPtr&lt;RegisterID&gt; index = generator.emitNodeForProperty(node);
1037     node = node-&gt;m_next;
1038     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1039 
1040     ASSERT(!node-&gt;m_next);
1041 
1042     return generator.move(dst, generator.emitDirectPutByVal(base.get(), index.get(), value.get()));
1043 }
1044 
1045 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_tailCallForwardArguments(BytecodeGenerator&amp; generator, RegisterID* dst)
1046 {
1047     ArgumentListNode* node = m_args-&gt;m_listNode;
1048     RefPtr&lt;RegisterID&gt; function = generator.emitNode(node);
1049     node = node-&gt;m_next;
1050     RefPtr&lt;RegisterID&gt; thisRegister = generator.emitNode(node);
1051     ASSERT(!node-&gt;m_next);
1052 
1053     RefPtr&lt;RegisterID&gt; finalDst = generator.finalDestination(dst);
1054     return generator.emitCallForwardArgumentsInTailPosition(finalDst.get(), function.get(), thisRegister.get(), generator.newTemporary(), 0, divot(), divotStart(), divotEnd(), DebuggableCall::No);
1055 }
1056 
1057 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_throwTypeError(BytecodeGenerator&amp; generator, RegisterID* dst)
1058 {
1059     ArgumentListNode* node = m_args-&gt;m_listNode;
1060     ASSERT(!node-&gt;m_next);
1061     if (node-&gt;m_expr-&gt;isString()) {
1062         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1063         generator.emitThrowTypeError(ident);
1064     } else {
1065         RefPtr&lt;RegisterID&gt; message = generator.emitNode(node);
1066         generator.emitThrowStaticError(ErrorType::TypeError, message.get());
1067     }
1068     return dst;
1069 }
1070 
1071 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_throwRangeError(BytecodeGenerator&amp; generator, RegisterID* dst)
1072 {
1073     ArgumentListNode* node = m_args-&gt;m_listNode;
1074     ASSERT(!node-&gt;m_next);
1075     if (node-&gt;m_expr-&gt;isString()) {
1076         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1077         generator.emitThrowRangeError(ident);
1078     } else {
1079         RefPtr&lt;RegisterID&gt; message = generator.emitNode(node);
1080         generator.emitThrowStaticError(ErrorType::RangeError, message.get());
1081     }
1082 
1083     return dst;
1084 }
1085 
1086 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_throwOutOfMemoryError(BytecodeGenerator&amp; generator, RegisterID* dst)
1087 {
1088     ASSERT(!m_args-&gt;m_listNode);
1089 
1090     generator.emitThrowOutOfMemoryError();
1091     return dst;
1092 }
1093 
1094 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_tryGetById(BytecodeGenerator&amp; generator, RegisterID* dst)
1095 {
1096     ArgumentListNode* node = m_args-&gt;m_listNode;
1097     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1098     node = node-&gt;m_next;
1099 
1100     // Since this is a builtin we expect the creator to use a string literal as the second argument.
1101     ASSERT(node-&gt;m_expr-&gt;isString());
1102     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1103     ASSERT(!node-&gt;m_next);
1104 
1105     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
1106     return generator.emitTryGetById(finalDest.get(), base.get(), ident);
1107 }
1108 
1109 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_toNumber(BytecodeGenerator&amp; generator, RegisterID* dst)
1110 {
1111     ArgumentListNode* node = m_args-&gt;m_listNode;
1112     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1113     ASSERT(!node-&gt;m_next);
1114 
1115     return generator.move(dst, generator.emitToNumber(generator.tempDestination(dst), src.get()));
1116 }
1117 
1118 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_toString(BytecodeGenerator&amp; generator, RegisterID* dst)
1119 {
1120     ArgumentListNode* node = m_args-&gt;m_listNode;
1121     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1122     ASSERT(!node-&gt;m_next);
1123 
1124     return generator.move(dst, generator.emitToString(generator.tempDestination(dst), src.get()));
1125 }
1126 
1127 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_toObject(BytecodeGenerator&amp; generator, RegisterID* dst)
1128 {
1129     ArgumentListNode* node = m_args-&gt;m_listNode;
1130     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1131     node = node-&gt;m_next;
1132 
1133     RefPtr&lt;RegisterID&gt; temp = generator.tempDestination(dst);
1134     if (node) {
1135         ASSERT(node-&gt;m_expr-&gt;isString());
1136         const Identifier&amp; message = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1137         ASSERT(!node-&gt;m_next);
1138         return generator.move(dst, generator.emitToObject(temp.get(), src.get(), message));
1139     }
<a name="27" id="anc27"></a><span class="line-modified">1140     return generator.move(dst, generator.emitToObject(temp.get(), src.get(), generator.vm()-&gt;propertyNames-&gt;emptyIdentifier));</span>
1141 }
1142 
1143 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_idWithProfile(BytecodeGenerator&amp; generator, RegisterID* dst)
1144 {
1145     ArgumentListNode* node = m_args-&gt;m_listNode;
1146     RefPtr&lt;RegisterID&gt; idValue = generator.newTemporary();
1147     generator.emitNode(idValue.get(), node);
1148     SpeculatedType speculation = SpecNone;
1149     while (node-&gt;m_next) {
1150         node = node-&gt;m_next;
1151         ASSERT(node-&gt;m_expr-&gt;isString());
1152         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1153         speculation |= speculationFromString(ident.utf8().data());
1154     }
1155 
1156     return generator.move(dst, generator.emitIdWithProfile(idValue.get(), speculation));
1157 }
1158 
1159 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isJSArray(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1160 {
1161     ArgumentListNode* node = m_args-&gt;m_listNode;
1162     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1163     ASSERT(!node-&gt;m_next);
1164 
1165     return generator.move(dst, generator.emitIsJSArray(generator.tempDestination(dst), src.get()));
1166 }
1167 
1168 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isProxyObject(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1169 {
1170     ArgumentListNode* node = m_args-&gt;m_listNode;
1171     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1172     ASSERT(!node-&gt;m_next);
1173 
1174     return generator.move(dst, generator.emitIsProxyObject(generator.tempDestination(dst), src.get()));
1175 }
1176 
1177 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isRegExpObject(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1178 {
1179     ArgumentListNode* node = m_args-&gt;m_listNode;
1180     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1181     ASSERT(!node-&gt;m_next);
1182 
1183     return generator.move(dst, generator.emitIsRegExpObject(generator.tempDestination(dst), src.get()));
1184 }
1185 
1186 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isObject(BytecodeGenerator&amp; generator, RegisterID* dst)
1187 {
1188     ArgumentListNode* node = m_args-&gt;m_listNode;
1189     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1190     ASSERT(!node-&gt;m_next);
1191 
1192     return generator.move(dst, generator.emitIsObject(generator.tempDestination(dst), src.get()));
1193 }
1194 
1195 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isDerivedArray(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1196 {
1197     ArgumentListNode* node = m_args-&gt;m_listNode;
1198     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1199     ASSERT(!node-&gt;m_next);
1200 
1201     return generator.move(dst, generator.emitIsDerivedArray(generator.tempDestination(dst), src.get()));
1202 }
1203 
1204 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isMap(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1205 {
1206     ArgumentListNode* node = m_args-&gt;m_listNode;
1207     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1208     ASSERT(!node-&gt;m_next);
1209 
1210     return generator.move(dst, generator.emitIsMap(generator.tempDestination(dst), src.get()));
1211 }
1212 
1213 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isSet(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1214 {
1215     ArgumentListNode* node = m_args-&gt;m_listNode;
1216     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1217     ASSERT(!node-&gt;m_next);
1218 
1219     return generator.move(dst, generator.emitIsSet(generator.tempDestination(dst), src.get()));
1220 }
1221 
1222 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isUndefinedOrNull(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1223 {
1224     ArgumentListNode* node = m_args-&gt;m_listNode;
1225     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1226     ASSERT(!node-&gt;m_next);
1227 
1228     return generator.move(dst, generator.emitIsUndefinedOrNull(generator.tempDestination(dst), src.get()));
1229 }
1230 
1231 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_newArrayWithSize(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1232 {
1233     ArgumentListNode* node = m_args-&gt;m_listNode;
1234     RefPtr&lt;RegisterID&gt; size = generator.emitNode(node);
1235     ASSERT(!node-&gt;m_next);
1236 
1237     RefPtr&lt;RegisterID&gt; finalDestination = generator.finalDestination(dst);
1238     generator.emitNewArrayWithSize(finalDestination.get(), size.get());
1239     return finalDestination.get();
1240 }
1241 
1242 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_defineEnumerableWritableConfigurableDataProperty(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1243 {
1244     ArgumentListNode* node = m_args-&gt;m_listNode;
1245     RefPtr&lt;RegisterID&gt; newObj = generator.emitNode(node);
1246     node = node-&gt;m_next;
1247     RefPtr&lt;RegisterID&gt; propertyNameRegister = generator.emitNode(node);
1248     node = node-&gt;m_next;
1249     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1250     ASSERT(!node-&gt;m_next);
1251 
1252     generator.emitCallDefineProperty(newObj.get(), propertyNameRegister.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable | BytecodeGenerator::PropertyEnumerable, m_position);
1253     return dst;
1254 }
1255 
1256 #define JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS(name) \
1257     RegisterID* BytecodeIntrinsicNode::emit_intrinsic_##name(BytecodeGenerator&amp; generator, RegisterID* dst) \
1258     { \
1259         ASSERT(!m_args); \
1260         ASSERT(type() == Type::Constant); \
1261         if (dst == generator.ignoredResult()) \
1262             return nullptr; \
<a name="28" id="anc28"></a><span class="line-modified">1263         return generator.emitLoad(dst, generator.vm()-&gt;bytecodeIntrinsicRegistry().name##Value(generator)); \</span>
1264     }
1265     JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS)
1266 #undef JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS
1267 
1268 // ------------------------------ FunctionCallBracketNode ----------------------------------
1269 
1270 RegisterID* FunctionCallBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1271 {
<a name="29" id="anc29"></a>

1272     bool baseIsSuper = m_base-&gt;isSuperNode();
1273     bool subscriptIsNonIndexString = isNonIndexStringElement(*m_subscript);
1274 
1275     RefPtr&lt;RegisterID&gt; base;
1276     if (baseIsSuper)
1277         base = emitSuperBaseForCallee(generator);
1278     else {
1279         if (subscriptIsNonIndexString)
1280             base = generator.emitNode(m_base);
1281         else
1282             base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments, m_subscript-&gt;isPure(generator));
<a name="30" id="anc30"></a>


1283     }
1284 
<a name="31" id="anc31"></a><span class="line-removed">1285     RefPtr&lt;RegisterID&gt; function;</span>
1286     RefPtr&lt;RegisterID&gt; thisRegister;
1287     if (baseIsSuper) {
1288         // Note that we only need to do this once because we either have a non-TDZ this or we throw. Once we have a non-TDZ this, we can&#39;t change its value back to TDZ.
1289         thisRegister = generator.ensureThis();
1290     }
1291     if (subscriptIsNonIndexString) {
1292         generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1293         if (baseIsSuper)
<a name="32" id="anc32"></a><span class="line-modified">1294             function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisRegister.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());</span>
1295         else
<a name="33" id="anc33"></a><span class="line-modified">1296             function = generator.emitGetById(generator.tempDestination(dst), base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());</span>
1297     } else {
1298         RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(m_subscript);
1299         generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1300         if (baseIsSuper)
<a name="34" id="anc34"></a><span class="line-modified">1301             function = generator.emitGetByVal(generator.tempDestination(dst), base.get(), thisRegister.get(), property.get());</span>
1302         else
<a name="35" id="anc35"></a><span class="line-modified">1303             function = generator.emitGetByVal(generator.tempDestination(dst), base.get(), property.get());</span>
1304     }
<a name="36" id="anc36"></a>

1305 
<a name="37" id="anc37"></a><span class="line-removed">1306     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, function.get());</span>
1307     CallArguments callArguments(generator, m_args);
1308     if (baseIsSuper) {
1309         generator.emitTDZCheck(generator.thisRegister());
1310         generator.move(callArguments.thisRegister(), thisRegister.get());
1311     } else
1312         generator.move(callArguments.thisRegister(), base.get());
1313     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1314     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1315     return ret;
1316 }
1317 
1318 // ------------------------------ FunctionCallDotNode ----------------------------------
1319 
1320 RegisterID* FunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1321 {
1322     RefPtr&lt;RegisterID&gt; function = generator.tempDestination(dst);
1323     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, function.get());
1324     CallArguments callArguments(generator, m_args);
1325     bool baseIsSuper = m_base-&gt;isSuperNode();
1326     if (baseIsSuper)
1327         generator.move(callArguments.thisRegister(), generator.ensureThis());
<a name="38" id="anc38"></a><span class="line-modified">1328     else</span>
1329         generator.emitNode(callArguments.thisRegister(), m_base);
<a name="39" id="anc39"></a>


1330     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1331     if (baseIsSuper) {
1332         RefPtr&lt;RegisterID&gt; superBase = emitSuperBaseForCallee(generator);
1333         generator.emitGetById(function.get(), superBase.get(), callArguments.thisRegister(), m_ident);
1334     } else
1335         generator.emitGetById(function.get(), callArguments.thisRegister(), m_ident);
<a name="40" id="anc40"></a>



1336     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1337     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1338     return ret;
1339 }
1340 
1341 static constexpr size_t maxDistanceToInnermostCallOrApply = 2;
1342 
1343 RegisterID* CallFunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1344 {
<a name="41" id="anc41"></a>
1345     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);
<a name="42" id="anc42"></a>



1346     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
<a name="43" id="anc43"></a><span class="line-removed">1347     RefPtr&lt;RegisterID&gt; function;</span>
<span class="line-removed">1348     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst);</span>
1349 
<a name="44" id="anc44"></a>
1350     auto makeFunction = [&amp;] {
1351         if (m_base-&gt;isSuperNode()) {
1352             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
1353             function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), generator.propertyNames().builtinNames().callPublicName());
1354         } else
1355             function = generator.emitGetById(generator.tempDestination(dst), base.get(), generator.propertyNames().builtinNames().callPublicName());
<a name="45" id="anc45"></a>


1356     };
1357 
1358     bool emitCallCheck = !generator.isBuiltinFunction();
1359     if (m_distanceToInnermostCallOrApply &gt; maxDistanceToInnermostCallOrApply &amp;&amp; emitCallCheck) {
1360         makeFunction();
1361         CallArguments callArguments(generator, m_args);
1362         generator.move(callArguments.thisRegister(), base.get());
1363         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1364         generator.move(dst, returnValue.get());
1365         return returnValue.get();
1366     }
1367 
1368     Ref&lt;Label&gt; realCall = generator.newLabel();
1369     Ref&lt;Label&gt; end = generator.newLabel();
1370 
1371     if (emitCallCheck) {
1372         makeFunction();
1373         generator.emitJumpIfNotFunctionCall(function.get(), realCall.get());
1374     }
1375     {
1376         if (m_args-&gt;m_listNode &amp;&amp; m_args-&gt;m_listNode-&gt;m_expr &amp;&amp; m_args-&gt;m_listNode-&gt;m_expr-&gt;isSpreadExpression()) {
1377             SpreadExpressionNode* spread = static_cast&lt;SpreadExpressionNode*&gt;(m_args-&gt;m_listNode-&gt;m_expr);
1378             ExpressionNode* subject = spread-&gt;expression();
1379             RefPtr&lt;RegisterID&gt; argumentsRegister;
1380             argumentsRegister = generator.emitNode(subject);
1381             generator.emitExpressionInfo(spread-&gt;divot(), spread-&gt;divotStart(), spread-&gt;divotEnd());
1382             RefPtr&lt;RegisterID&gt; thisRegister = generator.emitGetByVal(generator.newTemporary(), argumentsRegister.get(), generator.emitLoad(0, jsNumber(0)));
1383             generator.emitCallVarargsInTailPosition(returnValue.get(), base.get(), thisRegister.get(), argumentsRegister.get(), generator.newTemporary(), 1, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1384         } else if (m_args-&gt;m_listNode &amp;&amp; m_args-&gt;m_listNode-&gt;m_expr) {
1385             ArgumentListNode* oldList = m_args-&gt;m_listNode;
1386             m_args-&gt;m_listNode = m_args-&gt;m_listNode-&gt;m_next;
1387 
1388             RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1389             CallArguments callArguments(generator, m_args);
1390             generator.emitNode(callArguments.thisRegister(), oldList-&gt;m_expr);
1391             generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1392             m_args-&gt;m_listNode = oldList;
1393         } else {
1394             RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1395             CallArguments callArguments(generator, m_args);
1396             generator.emitLoad(callArguments.thisRegister(), jsUndefined());
1397             generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1398         }
1399     }
1400     if (emitCallCheck) {
1401         generator.emitJump(end.get());
1402         generator.emitLabel(realCall.get());
1403         {
1404             CallArguments callArguments(generator, m_args);
1405             generator.move(callArguments.thisRegister(), base.get());
1406             generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1407         }
1408         generator.emitLabel(end.get());
1409     }
1410     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1411     return returnValue.get();
1412 }
1413 
1414 static bool areTrivialApplyArguments(ArgumentsNode* args)
1415 {
1416     return !args-&gt;m_listNode || !args-&gt;m_listNode-&gt;m_expr || !args-&gt;m_listNode-&gt;m_next
1417         || (!args-&gt;m_listNode-&gt;m_next-&gt;m_next &amp;&amp; args-&gt;m_listNode-&gt;m_next-&gt;m_expr-&gt;isSimpleArray());
1418 }
1419 
1420 RegisterID* ApplyFunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1421 {
1422     // A few simple cases can be trivially handled as ordinary function calls.
1423     // function.apply(), function.apply(arg) -&gt; identical to function.call
1424     // function.apply(thisArg, [arg0, arg1, ...]) -&gt; can be trivially coerced into function.call(thisArg, arg0, arg1, ...) and saves object allocation
1425     bool mayBeCall = areTrivialApplyArguments(m_args);
1426 
<a name="46" id="anc46"></a><span class="line-removed">1427     RefPtr&lt;RegisterID&gt; function;</span>
<span class="line-removed">1428     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);</span>
1429     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst);
<a name="47" id="anc47"></a>





1430     auto makeFunction = [&amp;] {
1431         if (m_base-&gt;isSuperNode()) {
1432             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
1433             function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), generator.propertyNames().builtinNames().applyPublicName());
1434         } else
1435             function = generator.emitGetById(generator.tempDestination(dst), base.get(), generator.propertyNames().builtinNames().applyPublicName());
<a name="48" id="anc48"></a>


1436     };
1437 
1438     bool emitCallCheck = !generator.isBuiltinFunction();
1439     if (m_distanceToInnermostCallOrApply &gt; maxDistanceToInnermostCallOrApply &amp;&amp; emitCallCheck) {
1440         makeFunction();
1441         CallArguments callArguments(generator, m_args);
1442         generator.move(callArguments.thisRegister(), base.get());
1443         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1444         generator.move(dst, returnValue.get());
1445         return returnValue.get();
1446     }
1447 
1448     Ref&lt;Label&gt; realCall = generator.newLabel();
1449     Ref&lt;Label&gt; end = generator.newLabel();
1450     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1451     if (emitCallCheck) {
1452         makeFunction();
1453         ASSERT(!m_base-&gt;isResolveNode() || static_cast&lt;ResolveNode*&gt;(m_base)-&gt;identifier() != &quot;Reflect&quot;);
1454         generator.emitJumpIfNotFunctionApply(function.get(), realCall.get());
1455     }
1456     if (mayBeCall) {
1457         if (m_args-&gt;m_listNode &amp;&amp; m_args-&gt;m_listNode-&gt;m_expr) {
1458             ArgumentListNode* oldList = m_args-&gt;m_listNode;
1459             if (m_args-&gt;m_listNode-&gt;m_expr-&gt;isSpreadExpression()) {
1460                 SpreadExpressionNode* spread = static_cast&lt;SpreadExpressionNode*&gt;(m_args-&gt;m_listNode-&gt;m_expr);
1461                 RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.newTemporary(), base.get());
1462                 RefPtr&lt;RegisterID&gt; index = generator.emitLoad(generator.newTemporary(), jsNumber(0));
1463                 RefPtr&lt;RegisterID&gt; thisRegister = generator.emitLoad(generator.newTemporary(), jsUndefined());
1464                 RefPtr&lt;RegisterID&gt; argumentsRegister = generator.emitLoad(generator.newTemporary(), jsUndefined());
1465 
1466                 auto extractor = scopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;([&amp;thisRegister, &amp;argumentsRegister, &amp;index](BytecodeGenerator&amp; generator, RegisterID* value)
1467                 {
1468                     Ref&lt;Label&gt; haveThis = generator.newLabel();
1469                     Ref&lt;Label&gt; end = generator.newLabel();
1470                     RefPtr&lt;RegisterID&gt; compareResult = generator.newTemporary();
1471                     RefPtr&lt;RegisterID&gt; indexZeroCompareResult = generator.emitBinaryOp&lt;OpEq&gt;(compareResult.get(), index.get(), generator.emitLoad(0, jsNumber(0)), OperandTypes(ResultType::numberTypeIsInt32(), ResultType::numberTypeIsInt32()));
1472                     generator.emitJumpIfFalse(indexZeroCompareResult.get(), haveThis.get());
1473                     generator.move(thisRegister.get(), value);
1474                     generator.emitLoad(index.get(), jsNumber(1));
1475                     generator.emitJump(end.get());
1476                     generator.emitLabel(haveThis.get());
1477                     RefPtr&lt;RegisterID&gt; indexOneCompareResult = generator.emitBinaryOp&lt;OpEq&gt;(compareResult.get(), index.get(), generator.emitLoad(0, jsNumber(1)), OperandTypes(ResultType::numberTypeIsInt32(), ResultType::numberTypeIsInt32()));
1478                     generator.emitJumpIfFalse(indexOneCompareResult.get(), end.get());
1479                     generator.move(argumentsRegister.get(), value);
1480                     generator.emitLoad(index.get(), jsNumber(2));
1481                     generator.emitLabel(end.get());
1482                 });
1483                 generator.emitEnumeration(this, spread-&gt;expression(), extractor);
1484                 generator.emitCallVarargsInTailPosition(returnValue.get(), realFunction.get(), thisRegister.get(), argumentsRegister.get(), generator.newTemporary(), 0, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1485             } else if (m_args-&gt;m_listNode-&gt;m_next) {
1486                 ASSERT(m_args-&gt;m_listNode-&gt;m_next-&gt;m_expr-&gt;isSimpleArray());
1487                 ASSERT(!m_args-&gt;m_listNode-&gt;m_next-&gt;m_next);
1488                 m_args-&gt;m_listNode = static_cast&lt;ArrayNode*&gt;(m_args-&gt;m_listNode-&gt;m_next-&gt;m_expr)-&gt;toArgumentList(generator.parserArena(), 0, 0);
1489                 RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1490                 CallArguments callArguments(generator, m_args);
1491                 generator.emitNode(callArguments.thisRegister(), oldList-&gt;m_expr);
1492                 generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1493             } else {
1494                 m_args-&gt;m_listNode = m_args-&gt;m_listNode-&gt;m_next;
1495                 RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1496                 CallArguments callArguments(generator, m_args);
1497                 generator.emitNode(callArguments.thisRegister(), oldList-&gt;m_expr);
1498                 generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1499             }
1500             m_args-&gt;m_listNode = oldList;
1501         } else {
1502             RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1503             CallArguments callArguments(generator, m_args);
1504             generator.emitLoad(callArguments.thisRegister(), jsUndefined());
1505             generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1506         }
1507     } else {
1508         ASSERT(m_args-&gt;m_listNode &amp;&amp; m_args-&gt;m_listNode-&gt;m_next);
1509         RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1510         RefPtr&lt;RegisterID&gt; thisRegister = generator.emitNode(m_args-&gt;m_listNode-&gt;m_expr);
1511         RefPtr&lt;RegisterID&gt; argsRegister;
1512         ArgumentListNode* args = m_args-&gt;m_listNode-&gt;m_next;
1513         argsRegister = generator.emitNode(args-&gt;m_expr);
1514 
1515         // Function.prototype.apply ignores extra arguments, but we still
1516         // need to evaluate them for side effects.
1517         while ((args = args-&gt;m_next))
1518             generator.emitNode(args-&gt;m_expr);
1519 
1520         generator.emitCallVarargsInTailPosition(returnValue.get(), realFunction.get(), thisRegister.get(), argsRegister.get(), generator.newTemporary(), 0, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1521     }
1522     if (emitCallCheck) {
1523         generator.emitJump(end.get());
1524         generator.emitLabel(realCall.get());
1525         CallArguments callArguments(generator, m_args);
1526         generator.move(callArguments.thisRegister(), base.get());
1527         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1528         generator.emitLabel(end.get());
1529     }
1530     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1531     return returnValue.get();
1532 }
1533 
1534 // ------------------------------ PostfixNode ----------------------------------
1535 
1536 static RegisterID* emitIncOrDec(BytecodeGenerator&amp; generator, RegisterID* srcDst, Operator oper)
1537 {
1538     return (oper == OpPlusPlus) ? generator.emitInc(srcDst) : generator.emitDec(srcDst);
1539 }
1540 
1541 static RegisterID* emitPostIncOrDec(BytecodeGenerator&amp; generator, RegisterID* dst, RegisterID* srcDst, Operator oper)
1542 {
1543     if (dst == srcDst)
1544         return generator.emitToNumber(generator.finalDestination(dst), srcDst);
1545     RefPtr&lt;RegisterID&gt; tmp = generator.emitToNumber(generator.tempDestination(dst), srcDst);
1546     emitIncOrDec(generator, srcDst, oper);
1547     return generator.move(dst, tmp.get());
1548 }
1549 
1550 RegisterID* PostfixNode::emitResolve(BytecodeGenerator&amp; generator, RegisterID* dst)
1551 {
1552     if (dst == generator.ignoredResult())
1553         return PrefixNode::emitResolve(generator, dst);
1554 
1555     ASSERT(m_expr-&gt;isResolveNode());
1556     ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(m_expr);
1557     const Identifier&amp; ident = resolve-&gt;identifier();
1558 
1559     Variable var = generator.variable(ident);
1560     if (RegisterID* local = var.local()) {
1561         generator.emitTDZCheckIfNecessary(var, local, nullptr);
1562         RefPtr&lt;RegisterID&gt; localReg = local;
1563         if (var.isReadOnly()) {
1564             generator.emitReadOnlyExceptionIfNeeded(var);
1565             localReg = generator.move(generator.tempDestination(dst), local);
1566         }
1567         RefPtr&lt;RegisterID&gt; oldValue = emitPostIncOrDec(generator, generator.finalDestination(dst), localReg.get(), m_operator);
1568         generator.emitProfileType(localReg.get(), var, divotStart(), divotEnd());
1569         return oldValue.get();
1570     }
1571 
1572     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1573     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
1574     RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
1575     generator.emitTDZCheckIfNecessary(var, value.get(), nullptr);
1576     if (var.isReadOnly()) {
1577         bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
1578         if (threwException)
1579             return value.get();
1580     }
1581     RefPtr&lt;RegisterID&gt; oldValue = emitPostIncOrDec(generator, generator.finalDestination(dst), value.get(), m_operator);
1582     if (!var.isReadOnly()) {
1583         generator.emitPutToScope(scope.get(), var, value.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
1584         generator.emitProfileType(value.get(), var, divotStart(), divotEnd());
1585     }
1586 
1587     return oldValue.get();
1588 }
1589 
1590 RegisterID* PostfixNode::emitBracket(BytecodeGenerator&amp; generator, RegisterID* dst)
1591 {
1592     if (dst == generator.ignoredResult())
1593         return PrefixNode::emitBracket(generator, dst);
1594 
1595     ASSERT(m_expr-&gt;isBracketAccessorNode());
1596     BracketAccessorNode* bracketAccessor = static_cast&lt;BracketAccessorNode*&gt;(m_expr);
1597     ExpressionNode* baseNode = bracketAccessor-&gt;base();
1598     ExpressionNode* subscript = bracketAccessor-&gt;subscript();
1599 
1600     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(baseNode, bracketAccessor-&gt;subscriptHasAssignments(), subscript-&gt;isPure(generator));
1601     RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(subscript);
1602 
1603     generator.emitExpressionInfo(bracketAccessor-&gt;divot(), bracketAccessor-&gt;divotStart(), bracketAccessor-&gt;divotEnd());
1604     RefPtr&lt;RegisterID&gt; value;
1605     RefPtr&lt;RegisterID&gt; thisValue;
1606     if (baseNode-&gt;isSuperNode()) {
1607         thisValue = generator.ensureThis();
1608         value = generator.emitGetByVal(generator.newTemporary(), base.get(), thisValue.get(), property.get());
1609     } else
1610         value = generator.emitGetByVal(generator.newTemporary(), base.get(), property.get());
1611     RegisterID* oldValue = emitPostIncOrDec(generator, generator.tempDestination(dst), value.get(), m_operator);
1612     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1613     if (baseNode-&gt;isSuperNode())
1614         generator.emitPutByVal(base.get(), thisValue.get(), property.get(), value.get());
1615     else
1616         generator.emitPutByVal(base.get(), property.get(), value.get());
1617     generator.emitProfileType(value.get(), divotStart(), divotEnd());
1618     return generator.move(dst, oldValue);
1619 }
1620 
1621 RegisterID* PostfixNode::emitDot(BytecodeGenerator&amp; generator, RegisterID* dst)
1622 {
1623     if (dst == generator.ignoredResult())
1624         return PrefixNode::emitDot(generator, dst);
1625 
1626     ASSERT(m_expr-&gt;isDotAccessorNode());
1627     DotAccessorNode* dotAccessor = static_cast&lt;DotAccessorNode*&gt;(m_expr);
1628     ExpressionNode* baseNode = dotAccessor-&gt;base();
1629     bool baseIsSuper = baseNode-&gt;isSuperNode();
1630     const Identifier&amp; ident = dotAccessor-&gt;identifier();
1631 
1632     RefPtr&lt;RegisterID&gt; base = generator.emitNode(baseNode);
1633 
1634     generator.emitExpressionInfo(dotAccessor-&gt;divot(), dotAccessor-&gt;divotStart(), dotAccessor-&gt;divotEnd());
1635     RefPtr&lt;RegisterID&gt; value;
1636     RefPtr&lt;RegisterID&gt; thisValue;
1637     if (baseIsSuper) {
1638         thisValue = generator.ensureThis();
1639         value = generator.emitGetById(generator.newTemporary(), base.get(), thisValue.get(), ident);
1640     } else
1641         value = generator.emitGetById(generator.newTemporary(), base.get(), ident);
1642     RegisterID* oldValue = emitPostIncOrDec(generator, generator.tempDestination(dst), value.get(), m_operator);
1643     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1644     if (baseIsSuper)
1645         generator.emitPutById(base.get(), thisValue.get(), ident, value.get());
1646     else
1647         generator.emitPutById(base.get(), ident, value.get());
1648     generator.emitProfileType(value.get(), divotStart(), divotEnd());
1649     return generator.move(dst, oldValue);
1650 }
1651 
1652 RegisterID* PostfixNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1653 {
1654     if (m_expr-&gt;isResolveNode())
1655         return emitResolve(generator, dst);
1656 
1657     if (m_expr-&gt;isBracketAccessorNode())
1658         return emitBracket(generator, dst);
1659 
1660     if (m_expr-&gt;isDotAccessorNode())
1661         return emitDot(generator, dst);
1662 
<a name="49" id="anc49"></a>
1663     return emitThrowReferenceError(generator, m_operator == OpPlusPlus
1664         ? &quot;Postfix ++ operator applied to value that is not a reference.&quot;_s
1665         : &quot;Postfix -- operator applied to value that is not a reference.&quot;_s);
1666 }
1667 
1668 // ------------------------------ DeleteResolveNode -----------------------------------
1669 
1670 RegisterID* DeleteResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1671 {
1672     Variable var = generator.variable(m_ident);
1673     if (var.local()) {
1674         generator.emitTDZCheckIfNecessary(var, var.local(), nullptr);
1675         return generator.emitLoad(generator.finalDestination(dst), false);
1676     }
1677 
1678     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1679     RefPtr&lt;RegisterID&gt; base = generator.emitResolveScope(dst, var);
1680     generator.emitTDZCheckIfNecessary(var, nullptr, base.get());
1681     return generator.emitDeleteById(generator.finalDestination(dst, base.get()), base.get(), m_ident);
1682 }
1683 
1684 // ------------------------------ DeleteBracketNode -----------------------------------
1685 
1686 RegisterID* DeleteBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1687 {
<a name="50" id="anc50"></a>
1688     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_base);
<a name="51" id="anc51"></a><span class="line-removed">1689     RefPtr&lt;RegisterID&gt; r1 = generator.emitNode(m_subscript);</span>
1690 
<a name="52" id="anc52"></a>



1691     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1692     if (m_base-&gt;isSuperNode())
1693         return emitThrowReferenceError(generator, &quot;Cannot delete a super property&quot;);
<a name="53" id="anc53"></a><span class="line-modified">1694     return generator.emitDeleteByVal(generator.finalDestination(dst), r0.get(), r1.get());</span>
1695 }
1696 
1697 // ------------------------------ DeleteDotNode -----------------------------------
1698 
1699 RegisterID* DeleteDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1700 {
<a name="54" id="anc54"></a>
1701     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_base);
1702 
<a name="55" id="anc55"></a>


1703     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1704     if (m_base-&gt;isSuperNode())
1705         return emitThrowReferenceError(generator, &quot;Cannot delete a super property&quot;);
<a name="56" id="anc56"></a><span class="line-modified">1706     return generator.emitDeleteById(generator.finalDestination(dst), r0.get(), m_ident);</span>
1707 }
1708 
1709 // ------------------------------ DeleteValueNode -----------------------------------
1710 
1711 RegisterID* DeleteValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1712 {
1713     generator.emitNode(generator.ignoredResult(), m_expr);
1714 
1715     // delete on a non-location expression ignores the value and returns true
1716     return generator.emitLoad(generator.finalDestination(dst), true);
1717 }
1718 
1719 // ------------------------------ VoidNode -------------------------------------
1720 
1721 RegisterID* VoidNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1722 {
1723     if (dst == generator.ignoredResult()) {
1724         generator.emitNode(generator.ignoredResult(), m_expr);
1725         return 0;
1726     }
1727     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_expr);
1728     return generator.emitLoad(dst, jsUndefined());
1729 }
1730 
1731 // ------------------------------ TypeOfResolveNode -----------------------------------
1732 
1733 RegisterID* TypeOfResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1734 {
1735     Variable var = generator.variable(m_ident);
1736     if (RegisterID* local = var.local()) {
1737         generator.emitTDZCheckIfNecessary(var, local, nullptr);
1738         if (dst == generator.ignoredResult())
1739             return 0;
1740         return generator.emitTypeOf(generator.finalDestination(dst), local);
1741     }
1742 
1743     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(dst, var);
1744     RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, DoNotThrowIfNotFound);
1745     generator.emitTDZCheckIfNecessary(var, value.get(), nullptr);
1746     if (dst == generator.ignoredResult())
1747         return 0;
1748     return generator.emitTypeOf(generator.finalDestination(dst, scope.get()), value.get());
1749 }
1750 
1751 // ------------------------------ TypeOfValueNode -----------------------------------
1752 
1753 RegisterID* TypeOfValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1754 {
1755     if (dst == generator.ignoredResult()) {
1756         generator.emitNode(generator.ignoredResult(), m_expr);
1757         return 0;
1758     }
1759     RefPtr&lt;RegisterID&gt; src = generator.emitNode(m_expr);
1760     return generator.emitTypeOf(generator.finalDestination(dst), src.get());
1761 }
1762 
1763 // ------------------------------ PrefixNode ----------------------------------
1764 
1765 RegisterID* PrefixNode::emitResolve(BytecodeGenerator&amp; generator, RegisterID* dst)
1766 {
1767     ASSERT(m_expr-&gt;isResolveNode());
1768     ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(m_expr);
1769     const Identifier&amp; ident = resolve-&gt;identifier();
1770 
1771     Variable var = generator.variable(ident);
1772     if (RegisterID* local = var.local()) {
1773         generator.emitTDZCheckIfNecessary(var, local, nullptr);
1774         RefPtr&lt;RegisterID&gt; localReg = local;
1775         if (var.isReadOnly()) {
1776             generator.emitReadOnlyExceptionIfNeeded(var);
1777             localReg = generator.move(generator.tempDestination(dst), localReg.get());
<a name="57" id="anc57"></a><span class="line-modified">1778         } else if (generator.vm()-&gt;typeProfiler()) {</span>
1779             RefPtr&lt;RegisterID&gt; tempDst = generator.tempDestination(dst);
1780             generator.move(tempDst.get(), localReg.get());
1781             emitIncOrDec(generator, tempDst.get(), m_operator);
1782             generator.move(localReg.get(), tempDst.get());
1783             generator.emitProfileType(localReg.get(), var, divotStart(), divotEnd());
1784             return generator.move(dst, tempDst.get());
1785         }
1786         emitIncOrDec(generator, localReg.get(), m_operator);
1787         return generator.move(dst, localReg.get());
1788     }
1789 
1790     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1791     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(dst, var);
1792     RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
1793     generator.emitTDZCheckIfNecessary(var, value.get(), nullptr);
1794     if (var.isReadOnly()) {
1795         bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
1796         if (threwException)
1797             return value.get();
1798     }
1799 
1800     emitIncOrDec(generator, value.get(), m_operator);
1801     if (!var.isReadOnly()) {
1802         generator.emitPutToScope(scope.get(), var, value.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
1803         generator.emitProfileType(value.get(), var, divotStart(), divotEnd());
1804     }
1805     return generator.move(dst, value.get());
1806 }
1807 
1808 RegisterID* PrefixNode::emitBracket(BytecodeGenerator&amp; generator, RegisterID* dst)
1809 {
1810     ASSERT(m_expr-&gt;isBracketAccessorNode());
1811     BracketAccessorNode* bracketAccessor = static_cast&lt;BracketAccessorNode*&gt;(m_expr);
1812     ExpressionNode* baseNode = bracketAccessor-&gt;base();
1813     ExpressionNode* subscript = bracketAccessor-&gt;subscript();
1814 
1815     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(baseNode, bracketAccessor-&gt;subscriptHasAssignments(), subscript-&gt;isPure(generator));
1816     RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(subscript);
1817     RefPtr&lt;RegisterID&gt; propDst = generator.tempDestination(dst);
1818 
1819     generator.emitExpressionInfo(bracketAccessor-&gt;divot(), bracketAccessor-&gt;divotStart(), bracketAccessor-&gt;divotEnd());
1820     RegisterID* value;
1821     RefPtr&lt;RegisterID&gt; thisValue;
1822     if (baseNode-&gt;isSuperNode()) {
1823         thisValue = generator.ensureThis();
1824         value = generator.emitGetByVal(propDst.get(), base.get(), thisValue.get(), property.get());
1825     } else
1826         value = generator.emitGetByVal(propDst.get(), base.get(), property.get());
1827     emitIncOrDec(generator, value, m_operator);
1828     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1829     if (baseNode-&gt;isSuperNode())
1830         generator.emitPutByVal(base.get(), thisValue.get(), property.get(), value);
1831     else
1832         generator.emitPutByVal(base.get(), property.get(), value);
1833     generator.emitProfileType(value, divotStart(), divotEnd());
1834     return generator.move(dst, propDst.get());
1835 }
1836 
1837 RegisterID* PrefixNode::emitDot(BytecodeGenerator&amp; generator, RegisterID* dst)
1838 {
1839     ASSERT(m_expr-&gt;isDotAccessorNode());
1840     DotAccessorNode* dotAccessor = static_cast&lt;DotAccessorNode*&gt;(m_expr);
1841     ExpressionNode* baseNode = dotAccessor-&gt;base();
1842     const Identifier&amp; ident = dotAccessor-&gt;identifier();
1843 
1844     RefPtr&lt;RegisterID&gt; base = generator.emitNode(baseNode);
1845     RefPtr&lt;RegisterID&gt; propDst = generator.tempDestination(dst);
1846 
1847     generator.emitExpressionInfo(dotAccessor-&gt;divot(), dotAccessor-&gt;divotStart(), dotAccessor-&gt;divotEnd());
1848     RegisterID* value;
1849     RefPtr&lt;RegisterID&gt; thisValue;
1850     if (baseNode-&gt;isSuperNode()) {
1851         thisValue = generator.ensureThis();
1852         value = generator.emitGetById(propDst.get(), base.get(), thisValue.get(), ident);
1853     } else
1854         value = generator.emitGetById(propDst.get(), base.get(), ident);
1855     emitIncOrDec(generator, value, m_operator);
1856     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1857     if (baseNode-&gt;isSuperNode())
1858         generator.emitPutById(base.get(), thisValue.get(), ident, value);
1859     else
1860         generator.emitPutById(base.get(), ident, value);
1861     generator.emitProfileType(value, divotStart(), divotEnd());
1862     return generator.move(dst, propDst.get());
1863 }
1864 
1865 RegisterID* PrefixNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1866 {
1867     if (m_expr-&gt;isResolveNode())
1868         return emitResolve(generator, dst);
1869 
1870     if (m_expr-&gt;isBracketAccessorNode())
1871         return emitBracket(generator, dst);
1872 
1873     if (m_expr-&gt;isDotAccessorNode())
1874         return emitDot(generator, dst);
1875 
<a name="58" id="anc58"></a>
1876     return emitThrowReferenceError(generator, m_operator == OpPlusPlus
1877         ? &quot;Prefix ++ operator applied to value that is not a reference.&quot;_s
1878         : &quot;Prefix -- operator applied to value that is not a reference.&quot;_s);
1879 }
1880 
1881 // ------------------------------ Unary Operation Nodes -----------------------------------
1882 
1883 RegisterID* UnaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1884 {
1885     RefPtr&lt;RegisterID&gt; src = generator.emitNode(m_expr);
1886     generator.emitExpressionInfo(position(), position(), position());
1887     return generator.emitUnaryOp(opcodeID(), generator.finalDestination(dst), src.get(), OperandTypes(m_expr-&gt;resultDescriptor()));
1888 }
1889 
1890 // ------------------------------ UnaryPlusNode -----------------------------------
1891 
1892 RegisterID* UnaryPlusNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1893 {
1894     ASSERT(opcodeID() == op_to_number);
1895     RefPtr&lt;RegisterID&gt; src = generator.emitNode(expr());
1896     generator.emitExpressionInfo(position(), position(), position());
1897     return generator.emitToNumber(generator.finalDestination(dst), src.get());
1898 }
1899 
1900 // ------------------------------ LogicalNotNode -----------------------------------
1901 
1902 void LogicalNotNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
1903 {
1904     if (UNLIKELY(needsDebugHook()))
1905         generator.emitDebugHook(this);
1906 
1907     // Reverse the true and false targets.
1908     generator.emitNodeInConditionContext(expr(), falseTarget, trueTarget, invert(fallThroughMode));
1909 }
1910 
1911 
1912 // ------------------------------ Binary Operation Nodes -----------------------------------
1913 
1914 // BinaryOpNode::emitStrcat:
1915 //
1916 // This node generates an op_strcat operation.  This opcode can handle concatenation of three or
1917 // more values, where we can determine a set of separate op_add operations would be operating on
1918 // string values.
1919 //
1920 // This function expects to be operating on a graph of AST nodes looking something like this:
1921 //
1922 //     (a)...     (b)
1923 //          \   /
1924 //           (+)     (c)
1925 //              \   /
1926 //      [d]     ((+))
1927 //         \    /
1928 //          [+=]
1929 //
1930 // The assignment operation is optional, if it exists the register holding the value on the
1931 // lefthand side of the assignment should be passing as the optional &#39;lhs&#39; argument.
1932 //
1933 // The method should be called on the node at the root of the tree of regular binary add
1934 // operations (marked in the diagram with a double set of parentheses).  This node must
1935 // be performing a string concatenation (determined by statically detecting that at least
1936 // one child must be a string).
1937 //
1938 // Since the minimum number of values being concatenated together is expected to be 3, if
1939 // a lhs to a concatenating assignment is not provided then the  root add should have at
1940 // least one left child that is also an add that can be determined to be operating on strings.
1941 //
1942 RegisterID* BinaryOpNode::emitStrcat(BytecodeGenerator&amp; generator, RegisterID* dst, RegisterID* lhs, ReadModifyResolveNode* emitExpressionInfoForMe)
1943 {
1944     ASSERT(isAdd());
1945     ASSERT(resultDescriptor().definitelyIsString());
1946 
1947     // Create a list of expressions for all the adds in the tree of nodes we can convert into
1948     // a string concatenation.  The rightmost node (c) is added first.  The rightmost node is
1949     // added first, and the leftmost child is never added, so the vector produced for the
1950     // example above will be [ c, b ].
1951     Vector&lt;ExpressionNode*, 16&gt; reverseExpressionList;
1952     reverseExpressionList.append(m_expr2);
1953 
1954     // Examine the left child of the add.  So long as this is a string add, add its right-child
1955     // to the list, and keep processing along the left fork.
1956     ExpressionNode* leftMostAddChild = m_expr1;
1957     while (leftMostAddChild-&gt;isAdd() &amp;&amp; leftMostAddChild-&gt;resultDescriptor().definitelyIsString()) {
1958         reverseExpressionList.append(static_cast&lt;AddNode*&gt;(leftMostAddChild)-&gt;m_expr2);
1959         leftMostAddChild = static_cast&lt;AddNode*&gt;(leftMostAddChild)-&gt;m_expr1;
1960     }
1961 
1962     Vector&lt;RefPtr&lt;RegisterID&gt;, 16&gt; temporaryRegisters;
1963 
1964     // If there is an assignment, allocate a temporary to hold the lhs after conversion.
1965     // We could possibly avoid this (the lhs is converted last anyway, we could let the
1966     // op_strcat node handle its conversion if required).
1967     if (lhs)
1968         temporaryRegisters.append(generator.newTemporary());
1969 
1970     // Emit code for the leftmost node ((a) in the example).
1971     temporaryRegisters.append(generator.newTemporary());
1972     RegisterID* leftMostAddChildTempRegister = temporaryRegisters.last().get();
1973     generator.emitNode(leftMostAddChildTempRegister, leftMostAddChild);
1974 
1975     // Note on ordering of conversions:
1976     //
1977     // We maintain the same ordering of conversions as we would see if the concatenations
1978     // was performed as a sequence of adds (otherwise this optimization could change
1979     // behaviour should an object have been provided a valueOf or toString method).
1980     //
1981     // Considering the above example, the sequnce of execution is:
1982     //     * evaluate operand (a)
1983     //     * evaluate operand (b)
1984     //     * convert (a) to primitive   &lt;-  (this would be triggered by the first add)
1985     //     * convert (b) to primitive   &lt;-  (ditto)
1986     //     * evaluate operand (c)
1987     //     * convert (c) to primitive   &lt;-  (this would be triggered by the second add)
1988     // And optionally, if there is an assignment:
1989     //     * convert (d) to primitive   &lt;-  (this would be triggered by the assigning addition)
1990     //
1991     // As such we do not plant an op to convert the leftmost child now.  Instead, use
1992     // &#39;leftMostAddChildTempRegister&#39; as a flag to trigger generation of the conversion
1993     // once the second node has been generated.  However, if the leftmost child is an
1994     // immediate we can trivially determine that no conversion will be required.
1995     // If this is the case
1996     if (leftMostAddChild-&gt;isString())
1997         leftMostAddChildTempRegister = 0;
1998 
1999     while (reverseExpressionList.size()) {
2000         ExpressionNode* node = reverseExpressionList.last();
2001         reverseExpressionList.removeLast();
2002 
2003         // Emit the code for the current node.
2004         temporaryRegisters.append(generator.newTemporary());
2005         generator.emitNode(temporaryRegisters.last().get(), node);
2006 
2007         // On the first iteration of this loop, when we first reach this point we have just
2008         // generated the second node, which means it is time to convert the leftmost operand.
2009         if (leftMostAddChildTempRegister) {
2010             generator.emitToPrimitive(leftMostAddChildTempRegister, leftMostAddChildTempRegister);
2011             leftMostAddChildTempRegister = 0; // Only do this once.
2012         }
2013         // Plant a conversion for this node, if necessary.
2014         if (!node-&gt;isString())
2015             generator.emitToPrimitive(temporaryRegisters.last().get(), temporaryRegisters.last().get());
2016     }
2017     ASSERT(temporaryRegisters.size() &gt;= 3);
2018 
2019     // Certain read-modify nodes require expression info to be emitted *after* m_right has been generated.
2020     // If this is required the node is passed as &#39;emitExpressionInfoForMe&#39;; do so now.
2021     if (emitExpressionInfoForMe)
2022         generator.emitExpressionInfo(emitExpressionInfoForMe-&gt;divot(), emitExpressionInfoForMe-&gt;divotStart(), emitExpressionInfoForMe-&gt;divotEnd());
2023     // If there is an assignment convert the lhs now.  This will also copy lhs to
2024     // the temporary register we allocated for it.
2025     if (lhs)
2026         generator.emitToPrimitive(temporaryRegisters[0].get(), lhs);
2027 
2028     return generator.emitStrcat(generator.finalDestination(dst, temporaryRegisters[0].get()), temporaryRegisters[0].get(), temporaryRegisters.size());
2029 }
2030 
2031 void BinaryOpNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
2032 {
2033     TriState branchCondition;
2034     ExpressionNode* branchExpression;
2035     tryFoldToBranch(generator, branchCondition, branchExpression);
2036 
2037     if (UNLIKELY(needsDebugHook())) {
2038         if (branchCondition != MixedTriState)
2039             generator.emitDebugHook(this);
2040     }
2041 
2042     if (branchCondition == MixedTriState)
2043         ExpressionNode::emitBytecodeInConditionContext(generator, trueTarget, falseTarget, fallThroughMode);
2044     else if (branchCondition == TrueTriState)
2045         generator.emitNodeInConditionContext(branchExpression, trueTarget, falseTarget, fallThroughMode);
2046     else
2047         generator.emitNodeInConditionContext(branchExpression, falseTarget, trueTarget, invert(fallThroughMode));
2048 }
2049 
2050 static inline bool canFoldToBranch(OpcodeID opcodeID, ExpressionNode* branchExpression, JSValue constant)
2051 {
2052     ResultType expressionType = branchExpression-&gt;resultDescriptor();
2053 
2054     if (expressionType.definitelyIsBoolean() &amp;&amp; constant.isBoolean())
2055         return true;
2056     else if (expressionType.definitelyIsBoolean() &amp;&amp; constant.isInt32() &amp;&amp; (constant.asInt32() == 0 || constant.asInt32() == 1))
2057         return opcodeID == op_eq || opcodeID == op_neq; // Strict equality is false in the case of type mismatch.
2058     else if (expressionType.isInt32() &amp;&amp; constant.isInt32() &amp;&amp; constant.asInt32() == 0)
2059         return true;
2060 
2061     return false;
2062 }
2063 
2064 void BinaryOpNode::tryFoldToBranch(BytecodeGenerator&amp; generator, TriState&amp; branchCondition, ExpressionNode*&amp; branchExpression)
2065 {
2066     branchCondition = MixedTriState;
2067     branchExpression = 0;
2068 
2069     ConstantNode* constant = 0;
2070     if (m_expr1-&gt;isConstant()) {
2071         constant = static_cast&lt;ConstantNode*&gt;(m_expr1);
2072         branchExpression = m_expr2;
2073     } else if (m_expr2-&gt;isConstant()) {
2074         constant = static_cast&lt;ConstantNode*&gt;(m_expr2);
2075         branchExpression = m_expr1;
2076     }
2077 
2078     if (!constant)
2079         return;
2080     ASSERT(branchExpression);
2081 
2082     OpcodeID opcodeID = this-&gt;opcodeID();
2083     JSValue value = constant-&gt;jsValue(generator);
2084     bool canFoldToBranch = JSC::canFoldToBranch(opcodeID, branchExpression, value);
2085     if (!canFoldToBranch)
2086         return;
2087 
2088     if (opcodeID == op_eq || opcodeID == op_stricteq)
2089         branchCondition = triState(value.pureToBoolean());
2090     else if (opcodeID == op_neq || opcodeID == op_nstricteq)
2091         branchCondition = triState(!value.pureToBoolean());
2092 }
2093 
2094 RegisterID* BinaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2095 {
2096     OpcodeID opcodeID = this-&gt;opcodeID();
2097 
2098     if (opcodeID == op_less || opcodeID == op_lesseq || opcodeID == op_greater || opcodeID == op_greatereq) {
2099         auto isUInt32 = [&amp;] (ExpressionNode* node) -&gt; Optional&lt;UInt32Result&gt; {
2100             if (node-&gt;isBinaryOpNode() &amp;&amp; static_cast&lt;BinaryOpNode*&gt;(node)-&gt;opcodeID() == op_urshift)
2101                 return UInt32Result::UInt32;
2102             if (node-&gt;isNumber() &amp;&amp; static_cast&lt;NumberNode*&gt;(node)-&gt;isIntegerNode()) {
2103                 auto value = jsNumber(static_cast&lt;NumberNode*&gt;(node)-&gt;value());
2104                 if (value.isInt32() &amp;&amp; value.asInt32() &gt;= 0)
2105                     return UInt32Result::Constant;
2106             }
2107             return WTF::nullopt;
2108         };
2109         auto leftResult = isUInt32(m_expr1);
2110         auto rightResult = isUInt32(m_expr2);
2111         if ((leftResult &amp;&amp; rightResult) &amp;&amp; (leftResult.value() == UInt32Result::UInt32 || rightResult.value() == UInt32Result::UInt32)) {
2112             auto* left = m_expr1;
2113             auto* right = m_expr2;
2114             if (left-&gt;isBinaryOpNode()) {
2115                 ASSERT(static_cast&lt;BinaryOpNode*&gt;(left)-&gt;opcodeID() == op_urshift);
2116                 static_cast&lt;BinaryOpNode*&gt;(left)-&gt;m_shouldToUnsignedResult = false;
2117             }
2118             if (right-&gt;isBinaryOpNode()) {
2119                 ASSERT(static_cast&lt;BinaryOpNode*&gt;(right)-&gt;opcodeID() == op_urshift);
2120                 static_cast&lt;BinaryOpNode*&gt;(right)-&gt;m_shouldToUnsignedResult = false;
2121             }
2122             RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(left, m_rightHasAssignments, right-&gt;isPure(generator));
2123             RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(right);
2124             generator.emitExpressionInfo(position(), position(), position());
2125 
2126             // Since the both sides only accept Int32, replacing operands is not observable to users.
2127             bool replaceOperands = false;
2128             OpcodeID resultOp = opcodeID;
2129             switch (opcodeID) {
2130             case op_less:
2131                 resultOp = op_below;
2132                 break;
2133             case op_lesseq:
2134                 resultOp = op_beloweq;
2135                 break;
2136             case op_greater:
2137                 resultOp = op_below;
2138                 replaceOperands = true;
2139                 break;
2140             case op_greatereq:
2141                 resultOp = op_beloweq;
2142                 replaceOperands = true;
2143                 break;
2144             default:
2145                 RELEASE_ASSERT_NOT_REACHED();
2146             }
2147             OperandTypes operandTypes(left-&gt;resultDescriptor(), right-&gt;resultDescriptor());
2148             if (replaceOperands) {
2149                 std::swap(src1, src2);
2150                 operandTypes = OperandTypes(right-&gt;resultDescriptor(), left-&gt;resultDescriptor());
2151             }
2152             return generator.emitBinaryOp(resultOp, generator.finalDestination(dst, src1.get()), src1.get(), src2.get(), operandTypes);
2153         }
2154     }
2155 
2156     if (opcodeID == op_add &amp;&amp; m_expr1-&gt;isAdd() &amp;&amp; m_expr1-&gt;resultDescriptor().definitelyIsString()) {
2157         generator.emitExpressionInfo(position(), position(), position());
2158         return emitStrcat(generator, dst);
2159     }
2160 
2161     if (opcodeID == op_neq) {
2162         if (m_expr1-&gt;isNull() || m_expr2-&gt;isNull()) {
2163             RefPtr&lt;RegisterID&gt; src = generator.tempDestination(dst);
2164             generator.emitNode(src.get(), m_expr1-&gt;isNull() ? m_expr2 : m_expr1);
2165             return generator.emitUnaryOp&lt;OpNeqNull&gt;(generator.finalDestination(dst, src.get()), src.get());
2166         }
2167     }
2168 
2169     ExpressionNode* left = m_expr1;
2170     ExpressionNode* right = m_expr2;
2171     if (opcodeID == op_neq || opcodeID == op_nstricteq) {
2172         if (left-&gt;isString())
2173             std::swap(left, right);
2174     }
2175 
2176     RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(left, m_rightHasAssignments, right-&gt;isPure(generator));
2177     bool wasTypeof = generator.lastOpcodeID() == op_typeof;
2178     RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(right);
2179     generator.emitExpressionInfo(position(), position(), position());
2180     if (wasTypeof &amp;&amp; (opcodeID == op_neq || opcodeID == op_nstricteq)) {
2181         RefPtr&lt;RegisterID&gt; tmp = generator.tempDestination(dst);
2182         if (opcodeID == op_neq)
2183             generator.emitEqualityOp&lt;OpEq&gt;(generator.finalDestination(tmp.get(), src1.get()), src1.get(), src2.get());
2184         else if (opcodeID == op_nstricteq)
2185             generator.emitEqualityOp&lt;OpStricteq&gt;(generator.finalDestination(tmp.get(), src1.get()), src1.get(), src2.get());
2186         else
2187             RELEASE_ASSERT_NOT_REACHED();
2188         return generator.emitUnaryOp&lt;OpNot&gt;(generator.finalDestination(dst, tmp.get()), tmp.get());
2189     }
2190     RegisterID* result = generator.emitBinaryOp(opcodeID, generator.finalDestination(dst, src1.get()), src1.get(), src2.get(), OperandTypes(left-&gt;resultDescriptor(), right-&gt;resultDescriptor()));
2191     if (m_shouldToUnsignedResult) {
2192         if (opcodeID == op_urshift &amp;&amp; dst != generator.ignoredResult())
2193             return generator.emitUnaryOp&lt;OpUnsigned&gt;(result, result);
2194     }
2195     return result;
2196 }
2197 
2198 RegisterID* EqualNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2199 {
2200     if (m_expr1-&gt;isNull() || m_expr2-&gt;isNull()) {
2201         RefPtr&lt;RegisterID&gt; src = generator.tempDestination(dst);
2202         generator.emitNode(src.get(), m_expr1-&gt;isNull() ? m_expr2 : m_expr1);
2203         return generator.emitUnaryOp&lt;OpEqNull&gt;(generator.finalDestination(dst, src.get()), src.get());
2204     }
2205 
2206     ExpressionNode* left = m_expr1;
2207     ExpressionNode* right = m_expr2;
2208     if (left-&gt;isString())
2209         std::swap(left, right);
2210 
2211     RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(left, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2212     RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(right);
2213     return generator.emitEqualityOp&lt;OpEq&gt;(generator.finalDestination(dst, src1.get()), src1.get(), src2.get());
2214 }
2215 
2216 RegisterID* StrictEqualNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2217 {
2218     ExpressionNode* left = m_expr1;
2219     ExpressionNode* right = m_expr2;
2220     if (left-&gt;isString())
2221         std::swap(left, right);
2222 
2223     RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(left, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2224     RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(right);
2225     return generator.emitEqualityOp&lt;OpStricteq&gt;(generator.finalDestination(dst, src1.get()), src1.get(), src2.get());
2226 }
2227 
2228 RegisterID* ThrowableBinaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2229 {
2230     RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(m_expr1, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2231     RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(m_expr2);
2232     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2233     return generator.emitBinaryOp(opcodeID(), generator.finalDestination(dst, src1.get()), src1.get(), src2.get(), OperandTypes(m_expr1-&gt;resultDescriptor(), m_expr2-&gt;resultDescriptor()));
2234 }
2235 
2236 RegisterID* InstanceOfNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2237 {
2238     RefPtr&lt;RegisterID&gt; hasInstanceValue = generator.newTemporary();
2239     RefPtr&lt;RegisterID&gt; isObject = generator.newTemporary();
2240     RefPtr&lt;RegisterID&gt; isCustom = generator.newTemporary();
2241     RefPtr&lt;RegisterID&gt; prototype = generator.newTemporary();
2242     RefPtr&lt;RegisterID&gt; value = generator.emitNodeForLeftHandSide(m_expr1, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2243     RefPtr&lt;RegisterID&gt; constructor = generator.emitNode(m_expr2);
2244     RefPtr&lt;RegisterID&gt; dstReg = generator.finalDestination(dst, value.get());
2245     Ref&lt;Label&gt; custom = generator.newLabel();
2246     Ref&lt;Label&gt; done = generator.newLabel();
2247     Ref&lt;Label&gt; typeError = generator.newLabel();
2248 
2249     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2250     generator.emitIsObject(isObject.get(), constructor.get());
2251     generator.emitJumpIfFalse(isObject.get(), typeError.get());
2252 
2253     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
<a name="59" id="anc59"></a><span class="line-modified">2254     generator.emitGetById(hasInstanceValue.get(), constructor.get(), generator.vm()-&gt;propertyNames-&gt;hasInstanceSymbol);</span>
2255 
2256     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2257     generator.emitOverridesHasInstance(isCustom.get(), constructor.get(), hasInstanceValue.get());
2258 
2259     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2260     generator.emitJumpIfTrue(isCustom.get(), custom.get());
2261 
2262     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
<a name="60" id="anc60"></a><span class="line-modified">2263     generator.emitGetById(prototype.get(), constructor.get(), generator.vm()-&gt;propertyNames-&gt;prototype);</span>
2264 
2265     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2266     generator.emitInstanceOf(dstReg.get(), value.get(), prototype.get());
2267 
2268     generator.emitJump(done.get());
2269 
2270     generator.emitLabel(typeError.get());
2271     generator.emitThrowTypeError(&quot;Right hand side of instanceof is not an object&quot;);
2272 
2273     generator.emitLabel(custom.get());
2274 
2275     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2276     generator.emitInstanceOfCustom(dstReg.get(), value.get(), constructor.get(), hasInstanceValue.get());
2277 
2278     generator.emitLabel(done.get());
2279 
2280     return dstReg.get();
2281 }
2282 
2283 // ------------------------------ InNode ----------------------------
2284 
2285 RegisterID* InNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2286 {
2287     if (isNonIndexStringElement(*m_expr1)) {
2288         RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_expr2);
2289         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2290         return generator.emitInById(generator.finalDestination(dst, base.get()), base.get(), static_cast&lt;StringNode*&gt;(m_expr1)-&gt;value());
2291     }
2292 
2293     RefPtr&lt;RegisterID&gt; key = generator.emitNodeForLeftHandSide(m_expr1, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2294     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_expr2);
2295     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2296     return generator.emitInByVal(generator.finalDestination(dst, key.get()), key.get(), base.get());
2297 }
2298 
2299 
2300 // ------------------------------ LogicalOpNode ----------------------------
2301 
2302 RegisterID* LogicalOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2303 {
2304     RefPtr&lt;RegisterID&gt; temp = generator.tempDestination(dst);
2305     Ref&lt;Label&gt; target = generator.newLabel();
2306 
2307     generator.emitNode(temp.get(), m_expr1);
2308     if (m_operator == OpLogicalAnd)
2309         generator.emitJumpIfFalse(temp.get(), target.get());
2310     else
2311         generator.emitJumpIfTrue(temp.get(), target.get());
2312     generator.emitNodeInTailPosition(temp.get(), m_expr2);
2313     generator.emitLabel(target.get());
2314 
2315     return generator.move(dst, temp.get());
2316 }
2317 
2318 void LogicalOpNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
2319 {
2320     if (UNLIKELY(needsDebugHook()))
2321         generator.emitDebugHook(this);
2322 
2323     Ref&lt;Label&gt; afterExpr1 = generator.newLabel();
2324     if (m_operator == OpLogicalAnd)
2325         generator.emitNodeInConditionContext(m_expr1, afterExpr1.get(), falseTarget, FallThroughMeansTrue);
2326     else
2327         generator.emitNodeInConditionContext(m_expr1, trueTarget, afterExpr1.get(), FallThroughMeansFalse);
2328     generator.emitLabel(afterExpr1.get());
2329 
2330     generator.emitNodeInConditionContext(m_expr2, trueTarget, falseTarget, fallThroughMode);
2331 }
2332 
<a name="61" id="anc61"></a>


































2333 // ------------------------------ ConditionalNode ------------------------------
2334 
2335 RegisterID* ConditionalNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2336 {
2337     RefPtr&lt;RegisterID&gt; newDst = generator.finalDestination(dst);
2338     Ref&lt;Label&gt; beforeElse = generator.newLabel();
2339     Ref&lt;Label&gt; afterElse = generator.newLabel();
2340 
2341     Ref&lt;Label&gt; beforeThen = generator.newLabel();
2342     generator.emitNodeInConditionContext(m_logical, beforeThen.get(), beforeElse.get(), FallThroughMeansTrue);
2343     generator.emitLabel(beforeThen.get());
2344 
2345     generator.emitProfileControlFlow(m_expr1-&gt;startOffset());
2346     generator.emitNodeInTailPosition(newDst.get(), m_expr1);
2347     generator.emitJump(afterElse.get());
2348 
2349     generator.emitLabel(beforeElse.get());
2350     generator.emitProfileControlFlow(m_expr1-&gt;endOffset() + 1);
2351     generator.emitNodeInTailPosition(newDst.get(), m_expr2);
2352 
2353     generator.emitLabel(afterElse.get());
2354 
2355     generator.emitProfileControlFlow(m_expr2-&gt;endOffset() + 1);
2356 
2357     return newDst.get();
2358 }
2359 
2360 // ------------------------------ ReadModifyResolveNode -----------------------------------
2361 
2362 // FIXME: should this be moved to be a method on BytecodeGenerator?
2363 static ALWAYS_INLINE RegisterID* emitReadModifyAssignment(BytecodeGenerator&amp; generator, RegisterID* dst, RegisterID* src1, ExpressionNode* m_right, Operator oper, OperandTypes types, ReadModifyResolveNode* emitExpressionInfoForMe = 0)
2364 {
2365     OpcodeID opcodeID;
2366     switch (oper) {
2367         case OpMultEq:
2368             opcodeID = op_mul;
2369             break;
2370         case OpDivEq:
2371             opcodeID = op_div;
2372             break;
2373         case OpPlusEq:
2374             if (m_right-&gt;isAdd() &amp;&amp; m_right-&gt;resultDescriptor().definitelyIsString())
2375                 return static_cast&lt;AddNode*&gt;(m_right)-&gt;emitStrcat(generator, dst, src1, emitExpressionInfoForMe);
2376             opcodeID = op_add;
2377             break;
2378         case OpMinusEq:
2379             opcodeID = op_sub;
2380             break;
2381         case OpLShift:
2382             opcodeID = op_lshift;
2383             break;
2384         case OpRShift:
2385             opcodeID = op_rshift;
2386             break;
2387         case OpURShift:
2388             opcodeID = op_urshift;
2389             break;
2390         case OpAndEq:
2391             opcodeID = op_bitand;
2392             break;
2393         case OpXOrEq:
2394             opcodeID = op_bitxor;
2395             break;
2396         case OpOrEq:
2397             opcodeID = op_bitor;
2398             break;
2399         case OpModEq:
2400             opcodeID = op_mod;
2401             break;
2402         case OpPowEq:
2403             opcodeID = op_pow;
2404             break;
2405         default:
2406             RELEASE_ASSERT_NOT_REACHED();
2407             return dst;
2408     }
2409 
2410     RegisterID* src2 = generator.emitNode(m_right);
2411 
2412     // Certain read-modify nodes require expression info to be emitted *after* m_right has been generated.
2413     // If this is required the node is passed as &#39;emitExpressionInfoForMe&#39;; do so now.
2414     if (emitExpressionInfoForMe)
2415         generator.emitExpressionInfo(emitExpressionInfoForMe-&gt;divot(), emitExpressionInfoForMe-&gt;divotStart(), emitExpressionInfoForMe-&gt;divotEnd());
2416     RegisterID* result = generator.emitBinaryOp(opcodeID, dst, src1, src2, types);
2417     if (oper == OpURShift)
2418         return generator.emitUnaryOp&lt;OpUnsigned&gt;(result, result);
2419     return result;
2420 }
2421 
2422 RegisterID* ReadModifyResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2423 {
2424     JSTextPosition newDivot = divotStart() + m_ident.length();
2425     Variable var = generator.variable(m_ident);
2426     if (RegisterID* local = var.local()) {
2427         generator.emitTDZCheckIfNecessary(var, local, nullptr);
2428         if (var.isReadOnly()) {
2429             generator.emitReadOnlyExceptionIfNeeded(var);
2430             RegisterID* result = emitReadModifyAssignment(generator, generator.finalDestination(dst), local, m_right, m_operator, OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
2431             generator.emitProfileType(result, divotStart(), divotEnd());
2432             return result;
2433         }
2434 
2435         if (generator.leftHandSideNeedsCopy(m_rightHasAssignments, m_right-&gt;isPure(generator))) {
2436             RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
2437             generator.move(result.get(), local);
2438             emitReadModifyAssignment(generator, result.get(), result.get(), m_right, m_operator, OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
2439             generator.move(local, result.get());
2440             generator.emitProfileType(local, divotStart(), divotEnd());
2441             return generator.move(dst, result.get());
2442         }
2443 
2444         RegisterID* result = emitReadModifyAssignment(generator, local, local, m_right, m_operator, OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
2445         generator.emitProfileType(result, divotStart(), divotEnd());
2446         return generator.move(dst, result);
2447     }
2448 
2449     generator.emitExpressionInfo(newDivot, divotStart(), newDivot);
2450     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2451     RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
2452     generator.emitTDZCheckIfNecessary(var, value.get(), nullptr);
2453     if (var.isReadOnly()) {
2454         bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
2455         if (threwException)
2456             return value.get();
2457     }
2458     RefPtr&lt;RegisterID&gt; result = emitReadModifyAssignment(generator, generator.finalDestination(dst, value.get()), value.get(), m_right, m_operator, OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()), this);
2459     RegisterID* returnResult = result.get();
2460     if (!var.isReadOnly()) {
2461         returnResult = generator.emitPutToScope(scope.get(), var, result.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
2462         generator.emitProfileType(result.get(), var, divotStart(), divotEnd());
2463     }
2464     return returnResult;
2465 }
2466 
2467 static InitializationMode initializationModeForAssignmentContext(AssignmentContext assignmentContext)
2468 {
2469     switch (assignmentContext) {
2470     case AssignmentContext::DeclarationStatement:
2471         return InitializationMode::Initialization;
2472     case AssignmentContext::ConstDeclarationStatement:
2473         return InitializationMode::ConstInitialization;
2474     case AssignmentContext::AssignmentExpression:
2475         return InitializationMode::NotInitialization;
2476     }
2477 
2478     ASSERT_NOT_REACHED();
2479     return InitializationMode::NotInitialization;
2480 }
2481 
2482 // ------------------------------ AssignResolveNode -----------------------------------
2483 
2484 RegisterID* AssignResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2485 {
2486     Variable var = generator.variable(m_ident);
2487     bool isReadOnly = var.isReadOnly() &amp;&amp; m_assignmentContext != AssignmentContext::ConstDeclarationStatement;
2488     if (RegisterID* local = var.local()) {
2489         RegisterID* result = nullptr;
2490         if (m_assignmentContext == AssignmentContext::AssignmentExpression)
2491             generator.emitTDZCheckIfNecessary(var, local, nullptr);
2492 
2493         if (isReadOnly) {
2494             result = generator.emitNode(dst, m_right); // Execute side effects first.
2495             generator.emitReadOnlyExceptionIfNeeded(var);
2496             generator.emitProfileType(result, var, divotStart(), divotEnd());
2497         } else if (var.isSpecial()) {
2498             RefPtr&lt;RegisterID&gt; tempDst = generator.tempDestination(dst);
2499             generator.emitNode(tempDst.get(), m_right);
2500             generator.move(local, tempDst.get());
2501             generator.emitProfileType(local, var, divotStart(), divotEnd());
2502             result = generator.move(dst, tempDst.get());
2503         } else {
2504             RegisterID* right = generator.emitNode(local, m_right);
2505             generator.emitProfileType(right, var, divotStart(), divotEnd());
2506             result = generator.move(dst, right);
2507         }
2508 
2509         if (m_assignmentContext == AssignmentContext::DeclarationStatement || m_assignmentContext == AssignmentContext::ConstDeclarationStatement)
2510             generator.liftTDZCheckIfPossible(var);
2511         return result;
2512     }
2513 
2514     if (generator.isStrictMode())
2515         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2516     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2517     if (m_assignmentContext == AssignmentContext::AssignmentExpression)
2518         generator.emitTDZCheckIfNecessary(var, nullptr, scope.get());
2519     if (dst == generator.ignoredResult())
2520         dst = 0;
2521     RefPtr&lt;RegisterID&gt; result = generator.emitNode(dst, m_right);
2522     if (isReadOnly) {
2523         RegisterID* result = generator.emitNode(dst, m_right); // Execute side effects first.
2524         bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
2525         if (threwException)
2526             return result;
2527     }
2528     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2529     RegisterID* returnResult = result.get();
2530     if (!isReadOnly) {
2531         returnResult = generator.emitPutToScope(scope.get(), var, result.get(), generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, initializationModeForAssignmentContext(m_assignmentContext));
2532         generator.emitProfileType(result.get(), var, divotStart(), divotEnd());
2533     }
2534 
2535     if (m_assignmentContext == AssignmentContext::DeclarationStatement || m_assignmentContext == AssignmentContext::ConstDeclarationStatement)
2536         generator.liftTDZCheckIfPossible(var);
2537     return returnResult;
2538 }
2539 
2540 // ------------------------------ AssignDotNode -----------------------------------
2541 
2542 RegisterID* AssignDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2543 {
2544     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_rightHasAssignments, m_right-&gt;isPure(generator));
2545     RefPtr&lt;RegisterID&gt; value = generator.destinationForAssignResult(dst);
2546     RefPtr&lt;RegisterID&gt; result = generator.emitNode(value.get(), m_right);
2547     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2548     RefPtr&lt;RegisterID&gt; forwardResult = (dst == generator.ignoredResult()) ? result.get() : generator.move(generator.tempDestination(result.get()), result.get());
2549     if (m_base-&gt;isSuperNode()) {
2550         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
2551         generator.emitPutById(base.get(), thisValue.get(), m_ident, forwardResult.get());
2552     } else
2553         generator.emitPutById(base.get(), m_ident, forwardResult.get());
2554     generator.emitProfileType(forwardResult.get(), divotStart(), divotEnd());
2555     return generator.move(dst, forwardResult.get());
2556 }
2557 
2558 // ------------------------------ ReadModifyDotNode -----------------------------------
2559 
2560 RegisterID* ReadModifyDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2561 {
2562     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_rightHasAssignments, m_right-&gt;isPure(generator));
2563 
2564     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
2565     RefPtr&lt;RegisterID&gt; value;
2566     RefPtr&lt;RegisterID&gt; thisValue;
2567     if (m_base-&gt;isSuperNode()) {
2568         thisValue = generator.ensureThis();
2569         value = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), m_ident);
2570     } else
2571         value = generator.emitGetById(generator.tempDestination(dst), base.get(), m_ident);
2572     RegisterID* updatedValue = emitReadModifyAssignment(generator, generator.finalDestination(dst, value.get()), value.get(), m_right, static_cast&lt;JSC::Operator&gt;(m_operator), OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
2573 
2574     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2575     RegisterID* ret;
2576     if (m_base-&gt;isSuperNode())
2577         ret = generator.emitPutById(base.get(), thisValue.get(), m_ident, updatedValue);
2578     else
2579         ret = generator.emitPutById(base.get(), m_ident, updatedValue);
2580     generator.emitProfileType(updatedValue, divotStart(), divotEnd());
2581     return ret;
2582 }
2583 
2584 // ------------------------------ AssignErrorNode -----------------------------------
2585 
2586 RegisterID* AssignErrorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2587 {
2588     return emitThrowReferenceError(generator, &quot;Left side of assignment is not a reference.&quot;_s);
2589 }
2590 
2591 // ------------------------------ AssignBracketNode -----------------------------------
2592 
2593 RegisterID* AssignBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2594 {
2595     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments || m_rightHasAssignments, m_subscript-&gt;isPure(generator) &amp;&amp; m_right-&gt;isPure(generator));
2596     RefPtr&lt;RegisterID&gt; property = generator.emitNodeForLeftHandSideForProperty(m_subscript, m_rightHasAssignments, m_right-&gt;isPure(generator));
2597     RefPtr&lt;RegisterID&gt; value = generator.destinationForAssignResult(dst);
2598     RefPtr&lt;RegisterID&gt; result = generator.emitNode(value.get(), m_right);
2599 
2600     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2601     RegisterID* forwardResult = (dst == generator.ignoredResult()) ? result.get() : generator.move(generator.tempDestination(result.get()), result.get());
2602 
2603     if (isNonIndexStringElement(*m_subscript)) {
2604         if (m_base-&gt;isSuperNode()) {
2605             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
2606             generator.emitPutById(base.get(), thisValue.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value(), forwardResult);
2607         } else
2608             generator.emitPutById(base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value(), forwardResult);
2609     } else {
2610         if (m_base-&gt;isSuperNode()) {
2611             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
2612             generator.emitPutByVal(base.get(), thisValue.get(), property.get(), forwardResult);
2613         } else
2614             generator.emitPutByVal(base.get(), property.get(), forwardResult);
2615     }
2616 
2617     generator.emitProfileType(forwardResult, divotStart(), divotEnd());
2618     return generator.move(dst, forwardResult);
2619 }
2620 
2621 // ------------------------------ ReadModifyBracketNode -----------------------------------
2622 
2623 RegisterID* ReadModifyBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2624 {
2625     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments || m_rightHasAssignments, m_subscript-&gt;isPure(generator) &amp;&amp; m_right-&gt;isPure(generator));
2626     RefPtr&lt;RegisterID&gt; property = generator.emitNodeForLeftHandSideForProperty(m_subscript, m_rightHasAssignments, m_right-&gt;isPure(generator));
2627 
2628     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
2629     RefPtr&lt;RegisterID&gt; value;
2630     RefPtr&lt;RegisterID&gt; thisValue;
2631     if (m_base-&gt;isSuperNode()) {
2632         thisValue = generator.ensureThis();
2633         value = generator.emitGetByVal(generator.tempDestination(dst), base.get(), thisValue.get(), property.get());
2634     } else
2635         value = generator.emitGetByVal(generator.tempDestination(dst), base.get(), property.get());
2636     RegisterID* updatedValue = emitReadModifyAssignment(generator, generator.finalDestination(dst, value.get()), value.get(), m_right, static_cast&lt;JSC::Operator&gt;(m_operator), OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
2637 
2638     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2639     if (m_base-&gt;isSuperNode())
2640         generator.emitPutByVal(base.get(), thisValue.get(), property.get(), updatedValue);
2641     else
2642         generator.emitPutByVal(base.get(), property.get(), updatedValue);
2643     generator.emitProfileType(updatedValue, divotStart(), divotEnd());
2644 
2645     return updatedValue;
2646 }
2647 
2648 // ------------------------------ CommaNode ------------------------------------
2649 
2650 RegisterID* CommaNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2651 {
2652     CommaNode* node = this;
2653     for (; node &amp;&amp; node-&gt;next(); node = node-&gt;next())
2654         generator.emitNode(generator.ignoredResult(), node-&gt;m_expr);
2655     return generator.emitNodeInTailPosition(dst, node-&gt;m_expr);
2656 }
2657 
2658 // ------------------------------ SourceElements -------------------------------
2659 
2660 inline void SourceElements::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2661 {
2662     StatementNode* lastStatementWithCompletionValue = nullptr;
2663     if (generator.shouldBeConcernedWithCompletionValue()) {
2664         for (StatementNode* statement = m_head; statement; statement = statement-&gt;next()) {
2665             if (statement-&gt;hasCompletionValue())
2666                 lastStatementWithCompletionValue = statement;
2667         }
2668     }
2669 
2670     for (StatementNode* statement = m_head; statement; statement = statement-&gt;next()) {
2671         if (statement == lastStatementWithCompletionValue)
2672             generator.emitLoad(dst, jsUndefined());
2673         generator.emitNodeInTailPosition(dst, statement);
2674     }
2675 }
2676 
2677 // ------------------------------ BlockNode ------------------------------------
2678 
2679 void BlockNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2680 {
2681     if (!m_statements)
2682         return;
2683     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested);
2684     m_statements-&gt;emitBytecode(generator, dst);
2685     generator.popLexicalScope(this);
2686 }
2687 
2688 // ------------------------------ EmptyStatementNode ---------------------------
2689 
2690 void EmptyStatementNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
2691 {
2692     RELEASE_ASSERT(needsDebugHook());
2693 }
2694 
2695 // ------------------------------ DebuggerStatementNode ---------------------------
2696 
2697 void DebuggerStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2698 {
2699     generator.emitDebugHook(DidReachBreakpoint, position());
2700 }
2701 
2702 // ------------------------------ ExprStatementNode ----------------------------
2703 
2704 void ExprStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2705 {
2706     ASSERT(m_expr);
2707     generator.emitNode(dst, m_expr);
2708 }
2709 
2710 // ------------------------------ DeclarationStatement ----------------------------
2711 
2712 void DeclarationStatement::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2713 {
2714     ASSERT(m_expr);
2715     generator.emitNode(m_expr);
2716 }
2717 
2718 // ------------------------------ EmptyVarExpression ----------------------------
2719 
2720 RegisterID* EmptyVarExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2721 {
2722     // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
<a name="62" id="anc62"></a><span class="line-modified">2723     if (!generator.vm()-&gt;typeProfiler())</span>
2724         return nullptr;
2725 
2726     Variable var = generator.variable(m_ident);
2727     if (RegisterID* local = var.local())
2728         generator.emitProfileType(local, var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));
2729     else {
2730         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2731         RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, DoNotThrowIfNotFound);
2732         generator.emitProfileType(value.get(), var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));
2733     }
2734 
2735     return nullptr;
2736 }
2737 
2738 // ------------------------------ EmptyLetExpression ----------------------------
2739 
2740 RegisterID* EmptyLetExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2741 {
2742     // Lexical declarations like &#39;let&#39; must move undefined into their variables so we don&#39;t
2743     // get TDZ errors for situations like this: `let x; x;`
2744     Variable var = generator.variable(m_ident);
2745     if (RegisterID* local = var.local()) {
2746         generator.emitLoad(local, jsUndefined());
2747         generator.emitProfileType(local, var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));
2748     } else {
2749         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2750         RefPtr&lt;RegisterID&gt; value = generator.emitLoad(nullptr, jsUndefined());
2751         generator.emitPutToScope(scope.get(), var, value.get(), generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::Initialization);
2752         generator.emitProfileType(value.get(), var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));
2753     }
2754 
2755     generator.liftTDZCheckIfPossible(var);
2756 
2757     // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
2758     return nullptr;
2759 }
2760 
2761 // ------------------------------ IfElseNode ---------------------------------------
2762 
2763 static inline StatementNode* singleStatement(StatementNode* statementNode)
2764 {
2765     if (statementNode-&gt;isBlock())
2766         return static_cast&lt;BlockNode*&gt;(statementNode)-&gt;singleStatement();
2767     return statementNode;
2768 }
2769 
2770 bool IfElseNode::tryFoldBreakAndContinue(BytecodeGenerator&amp; generator, StatementNode* ifBlock,
2771     Label*&amp; trueTarget, FallThroughMode&amp; fallThroughMode)
2772 {
2773     StatementNode* singleStatement = JSC::singleStatement(ifBlock);
2774     if (!singleStatement)
2775         return false;
2776 
2777     if (singleStatement-&gt;isBreak()) {
2778         BreakNode* breakNode = static_cast&lt;BreakNode*&gt;(singleStatement);
2779         Label* target = breakNode-&gt;trivialTarget(generator);
2780         if (!target)
2781             return false;
2782         trueTarget = target;
2783         fallThroughMode = FallThroughMeansFalse;
2784         return true;
2785     }
2786 
2787     if (singleStatement-&gt;isContinue()) {
2788         ContinueNode* continueNode = static_cast&lt;ContinueNode*&gt;(singleStatement);
2789         Label* target = continueNode-&gt;trivialTarget(generator);
2790         if (!target)
2791             return false;
2792         trueTarget = target;
2793         fallThroughMode = FallThroughMeansFalse;
2794         return true;
2795     }
2796 
2797     return false;
2798 }
2799 
2800 void IfElseNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2801 {
2802     if (generator.shouldBeConcernedWithCompletionValue()) {
2803         if (m_ifBlock-&gt;hasEarlyBreakOrContinue() || (m_elseBlock &amp;&amp; m_elseBlock-&gt;hasEarlyBreakOrContinue()))
2804             generator.emitLoad(dst, jsUndefined());
2805     }
2806 
2807     Ref&lt;Label&gt; beforeThen = generator.newLabel();
2808     Ref&lt;Label&gt; beforeElse = generator.newLabel();
2809     Ref&lt;Label&gt; afterElse = generator.newLabel();
2810 
2811     Label* trueTarget = beforeThen.ptr();
2812     Label&amp; falseTarget = beforeElse.get();
2813     FallThroughMode fallThroughMode = FallThroughMeansTrue;
2814     bool didFoldIfBlock = tryFoldBreakAndContinue(generator, m_ifBlock, trueTarget, fallThroughMode);
2815 
2816     generator.emitNodeInConditionContext(m_condition, *trueTarget, falseTarget, fallThroughMode);
2817     generator.emitLabel(beforeThen.get());
2818     generator.emitProfileControlFlow(m_ifBlock-&gt;startOffset());
2819 
2820     if (!didFoldIfBlock) {
2821         generator.emitNodeInTailPosition(dst, m_ifBlock);
2822         if (m_elseBlock)
2823             generator.emitJump(afterElse.get());
2824     }
2825 
2826     generator.emitLabel(beforeElse.get());
2827 
2828     if (m_elseBlock) {
2829         generator.emitProfileControlFlow(m_ifBlock-&gt;endOffset() + (m_ifBlock-&gt;isBlock() ? 1 : 0));
2830         generator.emitNodeInTailPosition(dst, m_elseBlock);
2831     }
2832 
2833     generator.emitLabel(afterElse.get());
2834     StatementNode* endingBlock = m_elseBlock ? m_elseBlock : m_ifBlock;
2835     generator.emitProfileControlFlow(endingBlock-&gt;endOffset() + (endingBlock-&gt;isBlock() ? 1 : 0));
2836 }
2837 
2838 // ------------------------------ DoWhileNode ----------------------------------
2839 
2840 void DoWhileNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2841 {
2842     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
2843         generator.emitLoad(dst, jsUndefined());
2844 
2845     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
2846 
2847     Ref&lt;Label&gt; topOfLoop = generator.newLabel();
2848     generator.emitLabel(topOfLoop.get());
2849     generator.emitLoopHint();
2850 
2851     generator.emitNodeInTailPosition(dst, m_statement);
2852 
2853     generator.emitLabel(*scope-&gt;continueTarget());
2854     generator.emitNodeInConditionContext(m_expr, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansFalse);
2855 
2856     generator.emitLabel(scope-&gt;breakTarget());
2857 }
2858 
2859 // ------------------------------ WhileNode ------------------------------------
2860 
2861 void WhileNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2862 {
2863     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
2864         generator.emitLoad(dst, jsUndefined());
2865 
2866     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
2867     Ref&lt;Label&gt; topOfLoop = generator.newLabel();
2868 
2869     generator.emitNodeInConditionContext(m_expr, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansTrue);
2870 
2871     generator.emitLabel(topOfLoop.get());
2872     generator.emitLoopHint();
2873 
2874     generator.emitProfileControlFlow(m_statement-&gt;startOffset());
2875     generator.emitNodeInTailPosition(dst, m_statement);
2876 
2877     generator.emitLabel(*scope-&gt;continueTarget());
2878 
2879     generator.emitNodeInConditionContext(m_expr, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansFalse);
2880 
2881     generator.emitLabel(scope-&gt;breakTarget());
2882 
2883     generator.emitProfileControlFlow(m_statement-&gt;endOffset() + (m_statement-&gt;isBlock() ? 1 : 0));
2884 }
2885 
2886 // ------------------------------ ForNode --------------------------------------
2887 
2888 void ForNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2889 {
2890     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
2891         generator.emitLoad(dst, jsUndefined());
2892 
2893     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
2894 
2895     RegisterID* forLoopSymbolTable = nullptr;
2896     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested, &amp;forLoopSymbolTable);
2897 
2898     if (m_expr1)
2899         generator.emitNode(generator.ignoredResult(), m_expr1);
2900 
2901     Ref&lt;Label&gt; topOfLoop = generator.newLabel();
2902     if (m_expr2)
2903         generator.emitNodeInConditionContext(m_expr2, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansTrue);
2904 
2905     generator.emitLabel(topOfLoop.get());
2906     generator.emitLoopHint();
2907     generator.emitProfileControlFlow(m_statement-&gt;startOffset());
2908 
2909     generator.emitNodeInTailPosition(dst, m_statement);
2910 
2911     generator.emitLabel(*scope-&gt;continueTarget());
2912     generator.prepareLexicalScopeForNextForLoopIteration(this, forLoopSymbolTable);
2913     if (m_expr3)
2914         generator.emitNode(generator.ignoredResult(), m_expr3);
2915 
2916     if (m_expr2)
2917         generator.emitNodeInConditionContext(m_expr2, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansFalse);
2918     else
2919         generator.emitJump(topOfLoop.get());
2920 
2921     generator.emitLabel(scope-&gt;breakTarget());
2922     generator.popLexicalScope(this);
2923     generator.emitProfileControlFlow(m_statement-&gt;endOffset() + (m_statement-&gt;isBlock() ? 1 : 0));
2924 }
2925 
2926 // ------------------------------ ForInNode ------------------------------------
2927 
2928 RegisterID* ForInNode::tryGetBoundLocal(BytecodeGenerator&amp; generator)
2929 {
2930     if (m_lexpr-&gt;isResolveNode()) {
2931         const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
2932         return generator.variable(ident).local();
2933     }
2934 
2935     if (m_lexpr-&gt;isDestructuringNode()) {
2936         DestructuringAssignmentNode* assignNode = static_cast&lt;DestructuringAssignmentNode*&gt;(m_lexpr);
2937         auto binding = assignNode-&gt;bindings();
2938         if (!binding-&gt;isBindingNode())
2939             return nullptr;
2940 
2941         auto simpleBinding = static_cast&lt;BindingNode*&gt;(binding);
2942         const Identifier&amp; ident = simpleBinding-&gt;boundProperty();
2943         Variable var = generator.variable(ident);
2944         if (var.isSpecial())
2945             return nullptr;
2946         return var.local();
2947     }
2948 
2949     return nullptr;
2950 }
2951 
2952 void ForInNode::emitLoopHeader(BytecodeGenerator&amp; generator, RegisterID* propertyName)
2953 {
2954     auto lambdaEmitResolveVariable = [&amp;] (const Identifier&amp; ident) {
2955         Variable var = generator.variable(ident);
2956         if (RegisterID* local = var.local()) {
2957             if (var.isReadOnly())
2958                 generator.emitReadOnlyExceptionIfNeeded(var);
2959             generator.move(local, propertyName);
2960         } else {
2961             if (generator.isStrictMode())
2962                 generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2963             if (var.isReadOnly())
2964                 generator.emitReadOnlyExceptionIfNeeded(var);
2965             RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2966             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2967             generator.emitPutToScope(scope.get(), var, propertyName, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
2968         }
2969         generator.emitProfileType(propertyName, var, m_lexpr-&gt;position(), JSTextPosition(-1, m_lexpr-&gt;position().offset + ident.length(), -1));
2970     };
2971 
2972     if (m_lexpr-&gt;isResolveNode()) {
2973         const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
2974         lambdaEmitResolveVariable(ident);
2975         return;
2976     }
2977 
2978     if (m_lexpr-&gt;isAssignResolveNode()) {
2979         const Identifier&amp; ident = static_cast&lt;AssignResolveNode*&gt;(m_lexpr)-&gt;identifier();
2980         lambdaEmitResolveVariable(ident);
2981         return;
2982     }
2983 
2984     if (m_lexpr-&gt;isDotAccessorNode()) {
2985         DotAccessorNode* assignNode = static_cast&lt;DotAccessorNode*&gt;(m_lexpr);
2986         const Identifier&amp; ident = assignNode-&gt;identifier();
2987         RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
2988         generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
2989         if (assignNode-&gt;base()-&gt;isSuperNode()) {
2990             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
2991             generator.emitPutById(base.get(), thisValue.get(), ident, propertyName);
2992         } else
2993             generator.emitPutById(base.get(), ident, propertyName);
2994         generator.emitProfileType(propertyName, assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
2995         return;
2996     }
2997     if (m_lexpr-&gt;isBracketAccessorNode()) {
2998         BracketAccessorNode* assignNode = static_cast&lt;BracketAccessorNode*&gt;(m_lexpr);
2999         RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3000         RefPtr&lt;RegisterID&gt; subscript = generator.emitNodeForProperty(assignNode-&gt;subscript());
3001         generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3002         if (assignNode-&gt;base()-&gt;isSuperNode()) {
3003             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
3004             generator.emitPutByVal(base.get(), thisValue.get(), subscript.get(), propertyName);
3005         } else
3006             generator.emitPutByVal(base.get(), subscript.get(), propertyName);
3007         generator.emitProfileType(propertyName, assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3008         return;
3009     }
3010 
3011     if (m_lexpr-&gt;isDestructuringNode()) {
3012         DestructuringAssignmentNode* assignNode = static_cast&lt;DestructuringAssignmentNode*&gt;(m_lexpr);
3013         auto binding = assignNode-&gt;bindings();
3014         if (!binding-&gt;isBindingNode()) {
3015             assignNode-&gt;bindings()-&gt;bindValue(generator, propertyName);
3016             return;
3017         }
3018 
3019         auto simpleBinding = static_cast&lt;BindingNode*&gt;(binding);
3020         const Identifier&amp; ident = simpleBinding-&gt;boundProperty();
3021         Variable var = generator.variable(ident);
3022         if (!var.local() || var.isSpecial()) {
3023             assignNode-&gt;bindings()-&gt;bindValue(generator, propertyName);
3024             return;
3025         }
3026         generator.move(var.local(), propertyName);
3027         generator.emitProfileType(propertyName, var, simpleBinding-&gt;divotStart(), simpleBinding-&gt;divotEnd());
3028         return;
3029     }
3030 
3031     RELEASE_ASSERT_NOT_REACHED();
3032 }
3033 
3034 void ForInNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3035 {
3036     if (!m_lexpr-&gt;isAssignResolveNode() &amp;&amp; !m_lexpr-&gt;isAssignmentLocation()) {
3037         emitThrowReferenceError(generator, &quot;Left side of for-in statement is not a reference.&quot;_s);
3038         return;
3039     }
3040 
3041     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
3042         generator.emitLoad(dst, jsUndefined());
3043 
3044     Ref&lt;Label&gt; end = generator.newLabel();
3045 
3046     RegisterID* forLoopSymbolTable = nullptr;
3047     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested, &amp;forLoopSymbolTable);
3048 
3049     if (m_lexpr-&gt;isAssignResolveNode())
3050         generator.emitNode(generator.ignoredResult(), m_lexpr);
3051 
3052     RefPtr&lt;RegisterID&gt; base = generator.newTemporary();
3053     RefPtr&lt;RegisterID&gt; length;
3054     RefPtr&lt;RegisterID&gt; enumerator;
3055 
3056     generator.emitNode(base.get(), m_expr);
3057     RefPtr&lt;RegisterID&gt; local = this-&gt;tryGetBoundLocal(generator);
3058     RefPtr&lt;RegisterID&gt; enumeratorIndex;
3059 
3060     // Pause at the assignment expression for each for..in iteration.
3061     generator.emitDebugHook(m_lexpr);
3062 
3063     int profilerStartOffset = m_statement-&gt;startOffset();
3064     int profilerEndOffset = m_statement-&gt;endOffset() + (m_statement-&gt;isBlock() ? 1 : 0);
3065 
3066     enumerator = generator.emitGetPropertyEnumerator(generator.newTemporary(), base.get());
3067 
3068     BytecodeGenerator::PreservedTDZStack preservedTDZStack;
3069     generator.preserveTDZStack(preservedTDZStack);
3070 
3071     // Indexed property loop.
3072     {
3073         Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
3074         Ref&lt;Label&gt; loopStart = generator.newLabel();
3075         Ref&lt;Label&gt; loopEnd = generator.newLabel();
3076 
3077         length = generator.emitGetEnumerableLength(generator.newTemporary(), enumerator.get());
3078         RefPtr&lt;RegisterID&gt; i = generator.emitLoad(generator.newTemporary(), jsNumber(0));
3079         RefPtr&lt;RegisterID&gt; propertyName = generator.newTemporary();
3080 
3081         generator.emitLabel(loopStart.get());
3082         generator.emitLoopHint();
3083 
3084         RefPtr&lt;RegisterID&gt; result = generator.emitEqualityOp&lt;OpLess&gt;(generator.newTemporary(), i.get(), length.get());
3085         generator.emitJumpIfFalse(result.get(), loopEnd.get());
3086         generator.emitHasIndexedProperty(result.get(), base.get(), i.get());
3087         generator.emitJumpIfFalse(result.get(), *scope-&gt;continueTarget());
3088 
3089         generator.emitToIndexString(propertyName.get(), i.get());
3090         this-&gt;emitLoopHeader(generator, propertyName.get());
3091 
3092         generator.emitProfileControlFlow(profilerStartOffset);
3093 
3094         generator.pushIndexedForInScope(local.get(), i.get());
3095         generator.emitNode(dst, m_statement);
3096         generator.popIndexedForInScope(local.get());
3097 
3098         generator.emitProfileControlFlow(profilerEndOffset);
3099 
3100         generator.emitLabel(*scope-&gt;continueTarget());
3101         generator.prepareLexicalScopeForNextForLoopIteration(this, forLoopSymbolTable);
3102         generator.emitInc(i.get());
3103         generator.emitDebugHook(m_lexpr); // Pause at the assignment expression for each for..in iteration.
3104         generator.emitJump(loopStart.get());
3105 
3106         generator.emitLabel(scope-&gt;breakTarget());
3107         generator.emitJump(end.get());
3108         generator.emitLabel(loopEnd.get());
3109     }
3110     generator.restoreTDZStack(preservedTDZStack);
3111 
3112     // Structure property loop.
3113     {
3114         Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
3115         Ref&lt;Label&gt; loopStart = generator.newLabel();
3116         Ref&lt;Label&gt; loopEnd = generator.newLabel();
3117 
3118         enumeratorIndex = generator.emitLoad(generator.newTemporary(), jsNumber(0));
3119         RefPtr&lt;RegisterID&gt; propertyName = generator.newTemporary();
3120         generator.emitEnumeratorStructurePropertyName(propertyName.get(), enumerator.get(), enumeratorIndex.get());
3121 
3122         generator.emitLabel(loopStart.get());
3123         generator.emitLoopHint();
3124 
3125         RefPtr&lt;RegisterID&gt; result = generator.emitUnaryOp&lt;OpEqNull&gt;(generator.newTemporary(), propertyName.get());
3126         generator.emitJumpIfTrue(result.get(), loopEnd.get());
3127         generator.emitHasStructureProperty(result.get(), base.get(), propertyName.get(), enumerator.get());
3128         generator.emitJumpIfFalse(result.get(), *scope-&gt;continueTarget());
3129 
3130         this-&gt;emitLoopHeader(generator, propertyName.get());
3131 
3132         generator.emitProfileControlFlow(profilerStartOffset);
3133 
3134         generator.pushStructureForInScope(local.get(), enumeratorIndex.get(), propertyName.get(), enumerator.get());
3135         generator.emitNode(dst, m_statement);
3136         generator.popStructureForInScope(local.get());
3137 
3138         generator.emitProfileControlFlow(profilerEndOffset);
3139 
3140         generator.emitLabel(*scope-&gt;continueTarget());
3141         generator.prepareLexicalScopeForNextForLoopIteration(this, forLoopSymbolTable);
3142         generator.emitInc(enumeratorIndex.get());
3143         generator.emitEnumeratorStructurePropertyName(propertyName.get(), enumerator.get(), enumeratorIndex.get());
3144         generator.emitDebugHook(m_lexpr); // Pause at the assignment expression for each for..in iteration.
3145         generator.emitJump(loopStart.get());
3146 
3147         generator.emitLabel(scope-&gt;breakTarget());
3148         generator.emitJump(end.get());
3149         generator.emitLabel(loopEnd.get());
3150     }
3151     generator.restoreTDZStack(preservedTDZStack);
3152 
3153     // Generic property loop.
3154     {
3155         Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
3156         Ref&lt;Label&gt; loopStart = generator.newLabel();
3157         Ref&lt;Label&gt; loopEnd = generator.newLabel();
3158 
3159         RefPtr&lt;RegisterID&gt; propertyName = generator.newTemporary();
3160 
3161         generator.emitEnumeratorGenericPropertyName(propertyName.get(), enumerator.get(), enumeratorIndex.get());
3162 
3163         generator.emitLabel(loopStart.get());
3164         generator.emitLoopHint();
3165 
3166         RefPtr&lt;RegisterID&gt; result = generator.emitUnaryOp&lt;OpEqNull&gt;(generator.newTemporary(), propertyName.get());
3167         generator.emitJumpIfTrue(result.get(), loopEnd.get());
3168 
3169         generator.emitHasGenericProperty(result.get(), base.get(), propertyName.get());
3170         generator.emitJumpIfFalse(result.get(), *scope-&gt;continueTarget());
3171 
3172         this-&gt;emitLoopHeader(generator, propertyName.get());
3173 
3174         generator.emitProfileControlFlow(profilerStartOffset);
3175 
3176         generator.emitNode(dst, m_statement);
3177 
3178         generator.emitLabel(*scope-&gt;continueTarget());
3179         generator.prepareLexicalScopeForNextForLoopIteration(this, forLoopSymbolTable);
3180         generator.emitInc(enumeratorIndex.get());
3181         generator.emitEnumeratorGenericPropertyName(propertyName.get(), enumerator.get(), enumeratorIndex.get());
3182         generator.emitDebugHook(m_lexpr); // Pause at the assignment expression for each for..in iteration.
3183         generator.emitJump(loopStart.get());
3184 
3185         generator.emitLabel(scope-&gt;breakTarget());
3186         generator.emitJump(end.get());
3187         generator.emitLabel(loopEnd.get());
3188     }
3189 
3190     generator.emitLabel(end.get());
3191     generator.popLexicalScope(this);
3192     generator.emitProfileControlFlow(profilerEndOffset);
3193 }
3194 
3195 // ------------------------------ ForOfNode ------------------------------------
3196 void ForOfNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3197 {
3198     if (!m_lexpr-&gt;isAssignmentLocation()) {
3199         emitThrowReferenceError(generator, &quot;Left side of for-of statement is not a reference.&quot;_s);
3200         return;
3201     }
3202 
3203     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
3204         generator.emitLoad(dst, jsUndefined());
3205 
3206     RegisterID* forLoopSymbolTable = nullptr;
3207     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested, &amp;forLoopSymbolTable);
3208     auto extractor = scopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;([this, dst](BytecodeGenerator&amp; generator, RegisterID* value)
3209     {
3210         if (m_lexpr-&gt;isResolveNode()) {
3211             const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
3212             Variable var = generator.variable(ident);
3213             if (RegisterID* local = var.local()) {
3214                 if (var.isReadOnly())
3215                     generator.emitReadOnlyExceptionIfNeeded(var);
3216                 generator.move(local, value);
3217             } else {
3218                 if (generator.isStrictMode())
3219                     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3220                 if (var.isReadOnly())
3221                     generator.emitReadOnlyExceptionIfNeeded(var);
3222                 RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
3223                 generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3224                 generator.emitPutToScope(scope.get(), var, value, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
3225             }
3226             generator.emitProfileType(value, var, m_lexpr-&gt;position(), JSTextPosition(-1, m_lexpr-&gt;position().offset + ident.length(), -1));
3227         } else if (m_lexpr-&gt;isDotAccessorNode()) {
3228             DotAccessorNode* assignNode = static_cast&lt;DotAccessorNode*&gt;(m_lexpr);
3229             const Identifier&amp; ident = assignNode-&gt;identifier();
3230             RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3231 
3232             generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3233             if (assignNode-&gt;base()-&gt;isSuperNode()) {
3234                 RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
3235                 generator.emitPutById(base.get(), thisValue.get(), ident, value);
3236             } else
3237                 generator.emitPutById(base.get(), ident, value);
3238             generator.emitProfileType(value, assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3239         } else if (m_lexpr-&gt;isBracketAccessorNode()) {
3240             BracketAccessorNode* assignNode = static_cast&lt;BracketAccessorNode*&gt;(m_lexpr);
3241             RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3242             RegisterID* subscript = generator.emitNodeForProperty(assignNode-&gt;subscript());
3243 
3244             generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3245             if (assignNode-&gt;base()-&gt;isSuperNode()) {
3246                 RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
3247                 generator.emitPutByVal(base.get(), thisValue.get(), subscript, value);
3248             } else
3249                 generator.emitPutByVal(base.get(), subscript, value);
3250             generator.emitProfileType(value, assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3251         } else {
3252             ASSERT(m_lexpr-&gt;isDestructuringNode());
3253             DestructuringAssignmentNode* assignNode = static_cast&lt;DestructuringAssignmentNode*&gt;(m_lexpr);
3254             assignNode-&gt;bindings()-&gt;bindValue(generator, value);
3255         }
3256         generator.emitProfileControlFlow(m_statement-&gt;startOffset());
3257         generator.emitNode(dst, m_statement);
3258     });
3259     generator.emitEnumeration(this, m_expr, extractor, this, forLoopSymbolTable);
3260     generator.popLexicalScope(this);
3261     generator.emitProfileControlFlow(m_statement-&gt;endOffset() + (m_statement-&gt;isBlock() ? 1 : 0));
3262 }
3263 
3264 // ------------------------------ ContinueNode ---------------------------------
3265 
3266 Label* ContinueNode::trivialTarget(BytecodeGenerator&amp; generator)
3267 {
3268     if (generator.shouldEmitDebugHooks())
3269         return nullptr;
3270 
3271     LabelScope* scope = generator.continueTarget(m_ident);
3272     ASSERT(scope);
3273 
3274     if (generator.labelScopeDepth() != scope-&gt;scopeDepth())
3275         return nullptr;
3276 
3277     return scope-&gt;continueTarget();
3278 }
3279 
3280 void ContinueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3281 {
3282     LabelScope* scope = generator.continueTarget(m_ident);
3283     ASSERT(scope);
3284 
3285     bool hasFinally = generator.emitJumpViaFinallyIfNeeded(scope-&gt;scopeDepth(), *scope-&gt;continueTarget());
3286     if (!hasFinally) {
3287         int lexicalScopeIndex = generator.labelScopeDepthToLexicalScopeIndex(scope-&gt;scopeDepth());
3288         generator.restoreScopeRegister(lexicalScopeIndex);
3289         generator.emitJump(*scope-&gt;continueTarget());
3290     }
3291 
3292     generator.emitProfileControlFlow(endOffset());
3293 }
3294 
3295 // ------------------------------ BreakNode ------------------------------------
3296 
3297 Label* BreakNode::trivialTarget(BytecodeGenerator&amp; generator)
3298 {
3299     if (generator.shouldEmitDebugHooks())
3300         return nullptr;
3301 
3302     LabelScope* scope = generator.breakTarget(m_ident);
3303     ASSERT(scope);
3304 
3305     if (generator.labelScopeDepth() != scope-&gt;scopeDepth())
3306         return nullptr;
3307 
3308     return &amp;scope-&gt;breakTarget();
3309 }
3310 
3311 void BreakNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3312 {
3313     LabelScope* scope = generator.breakTarget(m_ident);
3314     ASSERT(scope);
3315 
3316     bool hasFinally = generator.emitJumpViaFinallyIfNeeded(scope-&gt;scopeDepth(), scope-&gt;breakTarget());
3317     if (!hasFinally) {
3318         int lexicalScopeIndex = generator.labelScopeDepthToLexicalScopeIndex(scope-&gt;scopeDepth());
3319         generator.restoreScopeRegister(lexicalScopeIndex);
3320         generator.emitJump(scope-&gt;breakTarget());
3321     }
3322 
3323     generator.emitProfileControlFlow(endOffset());
3324 }
3325 
3326 // ------------------------------ ReturnNode -----------------------------------
3327 
3328 void ReturnNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3329 {
3330     ASSERT(generator.codeType() == FunctionCode);
3331 
3332     if (dst == generator.ignoredResult())
3333         dst = 0;
3334 
3335     RefPtr&lt;RegisterID&gt; returnRegister = m_value ? generator.emitNodeInTailPosition(dst, m_value) : generator.emitLoad(dst, jsUndefined());
3336 
3337     generator.emitProfileType(returnRegister.get(), ProfileTypeBytecodeFunctionReturnStatement, divotStart(), divotEnd());
3338 
3339     bool hasFinally = generator.emitReturnViaFinallyIfNeeded(returnRegister.get());
3340     if (!hasFinally) {
3341         if (generator.parseMode() == SourceParseMode::AsyncGeneratorBodyMode) {
3342             returnRegister = generator.move(generator.newTemporary(), returnRegister.get());
3343             generator.emitAwait(returnRegister.get());
3344         }
3345 
3346         generator.emitWillLeaveCallFrameDebugHook();
3347         generator.emitReturn(returnRegister.get());
3348     }
3349 
3350     generator.emitProfileControlFlow(endOffset());
3351     // Emitting an unreachable return here is needed in case this op_profile_control_flow is the
3352     // last opcode in a CodeBlock because a CodeBlock&#39;s instructions must end with a terminal opcode.
<a name="63" id="anc63"></a><span class="line-modified">3353     if (generator.vm()-&gt;controlFlowProfiler())</span>
3354         generator.emitReturn(generator.emitLoad(nullptr, jsUndefined()));
3355 }
3356 
3357 // ------------------------------ WithNode -------------------------------------
3358 
3359 void WithNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3360 {
3361     RefPtr&lt;RegisterID&gt; scope = generator.emitNode(m_expr);
3362     generator.emitExpressionInfo(m_divot, m_divot - m_expressionLength, m_divot);
3363     generator.emitPushWithScope(scope.get());
3364     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
3365         generator.emitLoad(dst, jsUndefined());
3366     generator.emitNodeInTailPosition(dst, m_statement);
3367     generator.emitPopWithScope();
3368 }
3369 
3370 // ------------------------------ CaseClauseNode --------------------------------
3371 
3372 inline void CaseClauseNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3373 {
3374     generator.emitProfileControlFlow(m_startOffset);
3375     if (!m_statements)
3376         return;
3377     m_statements-&gt;emitBytecode(generator, dst);
3378 }
3379 
3380 // ------------------------------ CaseBlockNode --------------------------------
3381 
3382 enum SwitchKind {
3383     SwitchUnset = 0,
3384     SwitchNumber = 1,
3385     SwitchString = 2,
3386     SwitchNeither = 3
3387 };
3388 
3389 static void processClauseList(ClauseListNode* list, Vector&lt;ExpressionNode*, 8&gt;&amp; literalVector, SwitchKind&amp; typeForTable, bool&amp; singleCharacterSwitch, int32_t&amp; min_num, int32_t&amp; max_num)
3390 {
3391     for (; list; list = list-&gt;getNext()) {
3392         ExpressionNode* clauseExpression = list-&gt;getClause()-&gt;expr();
3393         literalVector.append(clauseExpression);
3394         if (clauseExpression-&gt;isNumber()) {
3395             double value = static_cast&lt;NumberNode*&gt;(clauseExpression)-&gt;value();
3396             int32_t intVal = static_cast&lt;int32_t&gt;(value);
3397             if ((typeForTable &amp; ~SwitchNumber) || (intVal != value)) {
3398                 typeForTable = SwitchNeither;
3399                 break;
3400             }
3401             if (intVal &lt; min_num)
3402                 min_num = intVal;
3403             if (intVal &gt; max_num)
3404                 max_num = intVal;
3405             typeForTable = SwitchNumber;
3406             continue;
3407         }
3408         if (clauseExpression-&gt;isString()) {
3409             if (typeForTable &amp; ~SwitchString) {
3410                 typeForTable = SwitchNeither;
3411                 break;
3412             }
3413             const String&amp; value = static_cast&lt;StringNode*&gt;(clauseExpression)-&gt;value().string();
3414             if (singleCharacterSwitch &amp;= value.length() == 1) {
3415                 int32_t intVal = value[0];
3416                 if (intVal &lt; min_num)
3417                     min_num = intVal;
3418                 if (intVal &gt; max_num)
3419                     max_num = intVal;
3420             }
3421             typeForTable = SwitchString;
3422             continue;
3423         }
3424         typeForTable = SwitchNeither;
3425         break;
3426     }
3427 }
3428 
3429 static inline size_t length(ClauseListNode* list1, ClauseListNode* list2)
3430 {
3431     size_t length = 0;
3432     for (ClauseListNode* node = list1; node; node = node-&gt;getNext())
3433         ++length;
3434     for (ClauseListNode* node = list2; node; node = node-&gt;getNext())
3435         ++length;
3436     return length;
3437 }
3438 
3439 SwitchInfo::SwitchType CaseBlockNode::tryTableSwitch(Vector&lt;ExpressionNode*, 8&gt;&amp; literalVector, int32_t&amp; min_num, int32_t&amp; max_num)
3440 {
3441     if (length(m_list1, m_list2) &lt; s_tableSwitchMinimum)
3442         return SwitchInfo::SwitchNone;
3443 
3444     SwitchKind typeForTable = SwitchUnset;
3445     bool singleCharacterSwitch = true;
3446 
3447     processClauseList(m_list1, literalVector, typeForTable, singleCharacterSwitch, min_num, max_num);
3448     processClauseList(m_list2, literalVector, typeForTable, singleCharacterSwitch, min_num, max_num);
3449 
3450     if (typeForTable == SwitchUnset || typeForTable == SwitchNeither)
3451         return SwitchInfo::SwitchNone;
3452 
3453     if (typeForTable == SwitchNumber) {
3454         int32_t range = max_num - min_num;
3455         if (min_num &lt;= max_num &amp;&amp; range &lt;= 1000 &amp;&amp; (range / literalVector.size()) &lt; 10)
3456             return SwitchInfo::SwitchImmediate;
3457         return SwitchInfo::SwitchNone;
3458     }
3459 
3460     ASSERT(typeForTable == SwitchString);
3461 
3462     if (singleCharacterSwitch) {
3463         int32_t range = max_num - min_num;
3464         if (min_num &lt;= max_num &amp;&amp; range &lt;= 1000 &amp;&amp; (range / literalVector.size()) &lt; 10)
3465             return SwitchInfo::SwitchCharacter;
3466     }
3467 
3468     return SwitchInfo::SwitchString;
3469 }
3470 
3471 void CaseBlockNode::emitBytecodeForBlock(BytecodeGenerator&amp; generator, RegisterID* switchExpression, RegisterID* dst)
3472 {
3473     Vector&lt;Ref&lt;Label&gt;, 8&gt; labelVector;
3474     Vector&lt;ExpressionNode*, 8&gt; literalVector;
3475     int32_t min_num = std::numeric_limits&lt;int32_t&gt;::max();
3476     int32_t max_num = std::numeric_limits&lt;int32_t&gt;::min();
3477     SwitchInfo::SwitchType switchType = tryTableSwitch(literalVector, min_num, max_num);
3478 
3479     Ref&lt;Label&gt; defaultLabel = generator.newLabel();
3480     if (switchType != SwitchInfo::SwitchNone) {
3481         // Prepare the various labels
3482         for (uint32_t i = 0; i &lt; literalVector.size(); i++)
3483             labelVector.append(generator.newLabel());
3484         generator.beginSwitch(switchExpression, switchType);
3485     } else {
3486         // Setup jumps
3487         for (ClauseListNode* list = m_list1; list; list = list-&gt;getNext()) {
3488             RefPtr&lt;RegisterID&gt; clauseVal = generator.newTemporary();
3489             generator.emitNode(clauseVal.get(), list-&gt;getClause()-&gt;expr());
3490             generator.emitBinaryOp&lt;OpStricteq&gt;(clauseVal.get(), clauseVal.get(), switchExpression, OperandTypes());
3491             labelVector.append(generator.newLabel());
3492             generator.emitJumpIfTrue(clauseVal.get(), labelVector[labelVector.size() - 1].get());
3493         }
3494 
3495         for (ClauseListNode* list = m_list2; list; list = list-&gt;getNext()) {
3496             RefPtr&lt;RegisterID&gt; clauseVal = generator.newTemporary();
3497             generator.emitNode(clauseVal.get(), list-&gt;getClause()-&gt;expr());
3498             generator.emitBinaryOp&lt;OpStricteq&gt;(clauseVal.get(), clauseVal.get(), switchExpression, OperandTypes());
3499             labelVector.append(generator.newLabel());
3500             generator.emitJumpIfTrue(clauseVal.get(), labelVector[labelVector.size() - 1].get());
3501         }
3502         generator.emitJump(defaultLabel.get());
3503     }
3504 
3505     size_t i = 0;
3506     for (ClauseListNode* list = m_list1; list; list = list-&gt;getNext()) {
3507         generator.emitLabel(labelVector[i++].get());
3508         list-&gt;getClause()-&gt;emitBytecode(generator, dst);
3509     }
3510 
3511     if (m_defaultClause) {
3512         generator.emitLabel(defaultLabel.get());
3513         m_defaultClause-&gt;emitBytecode(generator, dst);
3514     }
3515 
3516     for (ClauseListNode* list = m_list2; list; list = list-&gt;getNext()) {
3517         generator.emitLabel(labelVector[i++].get());
3518         list-&gt;getClause()-&gt;emitBytecode(generator, dst);
3519     }
3520     if (!m_defaultClause)
3521         generator.emitLabel(defaultLabel.get());
3522 
3523     ASSERT(i == labelVector.size());
3524     if (switchType != SwitchInfo::SwitchNone) {
3525         ASSERT(labelVector.size() == literalVector.size());
3526         generator.endSwitch(labelVector.size(), labelVector, literalVector.data(), defaultLabel.get(), min_num, max_num);
3527     }
3528 }
3529 
3530 // ------------------------------ SwitchNode -----------------------------------
3531 
3532 void SwitchNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3533 {
3534     if (generator.shouldBeConcernedWithCompletionValue())
3535         generator.emitLoad(dst, jsUndefined());
3536 
3537     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Switch);
3538 
3539     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_expr);
3540 
3541     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::DoNotOptimize, BytecodeGenerator::NestedScopeType::IsNested);
3542     m_block-&gt;emitBytecodeForBlock(generator, r0.get(), dst);
3543     generator.popLexicalScope(this);
3544 
3545     generator.emitLabel(scope-&gt;breakTarget());
3546     generator.emitProfileControlFlow(endOffset());
3547 }
3548 
3549 // ------------------------------ LabelNode ------------------------------------
3550 
3551 void LabelNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3552 {
3553     ASSERT(!generator.breakTarget(m_name));
3554 
3555     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::NamedLabel, &amp;m_name);
3556     generator.emitNodeInTailPosition(dst, m_statement);
3557 
3558     generator.emitLabel(scope-&gt;breakTarget());
3559 }
3560 
3561 // ------------------------------ ThrowNode ------------------------------------
3562 
3563 void ThrowNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3564 {
3565     if (dst == generator.ignoredResult())
3566         dst = 0;
3567     RefPtr&lt;RegisterID&gt; expr = generator.emitNode(m_expr);
3568     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3569     generator.emitThrow(expr.get());
3570 
3571     generator.emitProfileControlFlow(endOffset());
3572 }
3573 
3574 // ------------------------------ TryNode --------------------------------------
3575 
3576 void TryNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3577 {
3578     // NOTE: The catch and finally blocks must be labeled explicitly, so the
3579     // optimizer knows they may be jumped to from anywhere.
3580 
3581     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_tryBlock-&gt;hasEarlyBreakOrContinue())
3582         generator.emitLoad(dst, jsUndefined());
3583 
3584     ASSERT(m_catchBlock || m_finallyBlock);
<a name="64" id="anc64"></a><span class="line-removed">3585     BytecodeGenerator::CompletionRecordScope completionRecordScope(generator, m_finallyBlock);</span>
3586 
3587     RefPtr&lt;Label&gt; catchLabel;
3588     RefPtr&lt;Label&gt; catchEndLabel;
<a name="65" id="anc65"></a><span class="line-removed">3589     RefPtr&lt;Label&gt; finallyViaThrowLabel;</span>
3590     RefPtr&lt;Label&gt; finallyLabel;
3591     RefPtr&lt;Label&gt; finallyEndLabel;
<a name="66" id="anc66"></a><span class="line-modified">3592 </span>
<span class="line-removed">3593     Ref&lt;Label&gt; tryStartLabel = generator.newLabel();</span>
<span class="line-removed">3594     generator.emitLabel(tryStartLabel.get());</span>
3595 
3596     if (m_finallyBlock) {
<a name="67" id="anc67"></a><span class="line-removed">3597         finallyViaThrowLabel = generator.newLabel();</span>
3598         finallyLabel = generator.newLabel();
3599         finallyEndLabel = generator.newLabel();
3600 
<a name="68" id="anc68"></a><span class="line-modified">3601         generator.pushFinallyControlFlowScope(*finallyLabel);</span>

3602     }
3603     if (m_catchBlock) {
3604         catchLabel = generator.newLabel();
3605         catchEndLabel = generator.newLabel();
3606     }
3607 
<a name="69" id="anc69"></a><span class="line-modified">3608     Label&amp; tryHandlerLabel = m_catchBlock ? *catchLabel : *finallyViaThrowLabel;</span>

3609     HandlerType tryHandlerType = m_catchBlock ? HandlerType::Catch : HandlerType::Finally;
<a name="70" id="anc70"></a><span class="line-modified">3610     TryData* tryData = generator.pushTry(tryStartLabel.get(), tryHandlerLabel, tryHandlerType);</span>
3611     TryData* finallyTryData = nullptr;
3612     if (!m_catchBlock &amp;&amp; m_finallyBlock)
3613         finallyTryData = tryData;
3614 
3615     generator.emitNode(dst, m_tryBlock);
3616 
3617     if (m_finallyBlock)
3618         generator.emitJump(*finallyLabel);
3619     else
3620         generator.emitJump(*catchEndLabel);
3621 
<a name="71" id="anc71"></a><span class="line-modified">3622     Ref&lt;Label&gt; endTryLabel = generator.newEmittedLabel();</span>
<span class="line-modified">3623     generator.popTry(tryData, endTryLabel.get());</span>
3624 
3625     if (m_catchBlock) {
3626         // Uncaught exception path: the catch block.
3627         generator.emitLabel(*catchLabel);
3628         RefPtr&lt;RegisterID&gt; thrownValueRegister = generator.newTemporary();
<a name="72" id="anc72"></a><span class="line-modified">3629         RegisterID* unused = generator.newTemporary();</span>
<span class="line-modified">3630         generator.emitCatch(unused, thrownValueRegister.get(), tryData);</span>
3631         generator.restoreScopeRegister();
3632 
3633         if (m_finallyBlock) {
3634             // If the catch block throws an exception and we have a finally block, then the finally
3635             // block should &quot;catch&quot; that exception.
<a name="73" id="anc73"></a><span class="line-modified">3636             finallyTryData = generator.pushTry(*catchLabel, *finallyViaThrowLabel, HandlerType::Finally);</span>
3637         }
3638 
3639         if (m_catchPattern) {
3640             generator.emitPushCatchScope(m_lexicalVariables);
3641             m_catchPattern-&gt;bindValue(generator, thrownValueRegister.get());
3642         }
3643 
3644         generator.emitProfileControlFlow(m_tryBlock-&gt;endOffset() + 1);
3645         if (m_finallyBlock)
3646             generator.emitNode(dst, m_catchBlock);
3647         else
3648             generator.emitNodeInTailPosition(dst, m_catchBlock);
3649         generator.emitLoad(thrownValueRegister.get(), jsUndefined());
3650 
3651         if (m_catchPattern)
3652             generator.emitPopCatchScope(m_lexicalVariables);
3653 
3654         if (m_finallyBlock) {
<a name="74" id="anc74"></a><span class="line-modified">3655             generator.emitSetCompletionType(CompletionType::Normal);</span>
3656             generator.emitJump(*finallyLabel);
<a name="75" id="anc75"></a><span class="line-modified">3657             generator.popTry(finallyTryData, *finallyViaThrowLabel);</span>
3658         }
3659 
3660         generator.emitLabel(*catchEndLabel);
3661         generator.emitProfileControlFlow(m_catchBlock-&gt;endOffset() + 1);
3662     }
3663 
3664     if (m_finallyBlock) {
<a name="76" id="anc76"></a><span class="line-modified">3665         FinallyContext finallyContext = generator.popFinallyControlFlowScope();</span>
3666 
<a name="77" id="anc77"></a><span class="line-modified">3667         // Entry to the finally block for CompletionType::Throw.</span>
<span class="line-modified">3668         generator.emitLabel(*finallyViaThrowLabel);</span>
<span class="line-removed">3669         RegisterID* unused = generator.newTemporary();</span>
<span class="line-removed">3670         generator.emitCatch(generator.completionValueRegister(), unused, finallyTryData);</span>
<span class="line-removed">3671         generator.emitSetCompletionType(CompletionType::Throw);</span>
3672 
3673         // Entry to the finally block for CompletionTypes other than Throw.
3674         generator.emitLabel(*finallyLabel);
3675         generator.restoreScopeRegister();
3676 
<a name="78" id="anc78"></a><span class="line-removed">3677         RefPtr&lt;RegisterID&gt; savedCompletionTypeRegister = generator.newTemporary();</span>
<span class="line-removed">3678         generator.move(savedCompletionTypeRegister.get(), generator.completionTypeRegister());</span>
<span class="line-removed">3679 </span>
3680         int finallyStartOffset = m_catchBlock ? m_catchBlock-&gt;endOffset() + 1 : m_tryBlock-&gt;endOffset() + 1;
3681         generator.emitProfileControlFlow(finallyStartOffset);
3682         generator.emitNodeInTailPosition(m_finallyBlock);
3683 
<a name="79" id="anc79"></a><span class="line-modified">3684         generator.emitFinallyCompletion(finallyContext, savedCompletionTypeRegister.get(), *finallyEndLabel);</span>
3685         generator.emitLabel(*finallyEndLabel);
3686         generator.emitProfileControlFlow(m_finallyBlock-&gt;endOffset() + 1);
3687     }
3688 }
3689 
3690 // ------------------------------ ScopeNode -----------------------------
3691 
3692 inline void ScopeNode::emitStatementsBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3693 {
3694     if (!m_statements)
3695         return;
3696     m_statements-&gt;emitBytecode(generator, dst);
3697 }
3698 
3699 static void emitProgramNodeBytecode(BytecodeGenerator&amp; generator, ScopeNode&amp; scopeNode)
3700 {
3701     generator.emitDebugHook(WillExecuteProgram, scopeNode.startLine(), scopeNode.startStartOffset(), scopeNode.startLineStartOffset());
3702 
3703     RefPtr&lt;RegisterID&gt; dstRegister = generator.newTemporary();
3704     generator.emitLoad(dstRegister.get(), jsUndefined());
3705     generator.emitProfileControlFlow(scopeNode.startStartOffset());
3706     scopeNode.emitStatementsBytecode(generator, dstRegister.get());
3707 
3708     generator.emitDebugHook(DidExecuteProgram, scopeNode.lastLine(), scopeNode.startOffset(), scopeNode.lineStartOffset());
3709     generator.emitEnd(dstRegister.get());
3710 }
3711 
3712 // ------------------------------ ProgramNode -----------------------------
3713 
3714 void ProgramNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3715 {
3716     emitProgramNodeBytecode(generator, *this);
3717 }
3718 
3719 // ------------------------------ ModuleProgramNode --------------------
3720 
3721 void ModuleProgramNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3722 {
3723     emitProgramNodeBytecode(generator, *this);
3724 }
3725 
3726 // ------------------------------ EvalNode -----------------------------
3727 
3728 void EvalNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3729 {
3730     generator.emitDebugHook(WillExecuteProgram, startLine(), startStartOffset(), startLineStartOffset());
3731 
3732     RefPtr&lt;RegisterID&gt; dstRegister = generator.newTemporary();
3733     generator.emitLoad(dstRegister.get(), jsUndefined());
3734     emitStatementsBytecode(generator, dstRegister.get());
3735 
3736     generator.emitDebugHook(DidExecuteProgram, lastLine(), startOffset(), lineStartOffset());
3737     generator.emitEnd(dstRegister.get());
3738 }
3739 
3740 // ------------------------------ FunctionNode -----------------------------
3741 
3742 void FunctionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3743 {
<a name="80" id="anc80"></a><span class="line-modified">3744     if (generator.vm()-&gt;typeProfiler()) {</span>
3745         // If the parameter list is non simple one, it is handled in bindValue&#39;s code.
3746         if (m_parameters-&gt;isSimpleParameterList()) {
3747             for (size_t i = 0; i &lt; m_parameters-&gt;size(); i++) {
3748                 BindingNode* bindingNode = static_cast&lt;BindingNode*&gt;(m_parameters-&gt;at(i).first);
3749                 RegisterID reg(CallFrame::argumentOffset(i));
3750                 generator.emitProfileType(&amp;reg, ProfileTypeBytecodeFunctionArgument, bindingNode-&gt;divotStart(), bindingNode-&gt;divotEnd());
3751             }
3752         }
3753     }
3754 
3755     generator.emitProfileControlFlow(startStartOffset());
3756     generator.emitDebugHook(DidEnterCallFrame, startLine(), startStartOffset(), startLineStartOffset());
3757 
3758     switch (generator.parseMode()) {
3759     case SourceParseMode::GeneratorWrapperFunctionMode:
3760     case SourceParseMode::GeneratorWrapperMethodMode:
3761     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
3762     case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
3763         StatementNode* singleStatement = this-&gt;singleStatement();
3764         ASSERT(singleStatement-&gt;isExprStatement());
3765         ExprStatementNode* exprStatement = static_cast&lt;ExprStatementNode*&gt;(singleStatement);
3766         ExpressionNode* expr = exprStatement-&gt;expr();
3767         ASSERT(expr-&gt;isFuncExprNode());
3768         FuncExprNode* funcExpr = static_cast&lt;FuncExprNode*&gt;(expr);
3769 
3770         RefPtr&lt;RegisterID&gt; next = generator.newTemporary();
3771         generator.emitNode(next.get(), funcExpr);
3772 
3773         if (generator.superBinding() == SuperBinding::Needed) {
3774             RefPtr&lt;RegisterID&gt; homeObject = emitHomeObjectForCallee(generator);
3775             emitPutHomeObject(generator, next.get(), homeObject.get());
3776         }
3777 
3778         if (isGeneratorWrapperParseMode(generator.parseMode()))
3779             generator.emitPutGeneratorFields(next.get());
3780         else {
3781             ASSERT(isAsyncGeneratorWrapperParseMode(generator.parseMode()));
3782             generator.emitPutAsyncGeneratorFields(next.get());
3783         }
3784 
3785         ASSERT(startOffset() &gt;= lineStartOffset());
3786         generator.emitDebugHook(WillLeaveCallFrame, lastLine(), startOffset(), lineStartOffset());
3787         generator.emitReturn(generator.generatorRegister());
3788         break;
3789     }
3790 
3791     case SourceParseMode::AsyncFunctionMode:
3792     case SourceParseMode::AsyncMethodMode:
3793     case SourceParseMode::AsyncArrowFunctionMode: {
3794         StatementNode* singleStatement = this-&gt;singleStatement();
3795         ASSERT(singleStatement-&gt;isExprStatement());
3796         ExprStatementNode* exprStatement = static_cast&lt;ExprStatementNode*&gt;(singleStatement);
3797         ExpressionNode* expr = exprStatement-&gt;expr();
3798         ASSERT(expr-&gt;isFuncExprNode());
3799         FuncExprNode* funcExpr = static_cast&lt;FuncExprNode*&gt;(expr);
3800 
3801         RefPtr&lt;RegisterID&gt; next = generator.newTemporary();
3802         generator.emitNode(next.get(), funcExpr);
3803 
3804         if (generator.superBinding() == SuperBinding::Needed || (generator.parseMode() == SourceParseMode::AsyncArrowFunctionMode &amp;&amp; generator.isSuperUsedInInnerArrowFunction())) {
3805             RefPtr&lt;RegisterID&gt; homeObject = emitHomeObjectForCallee(generator);
3806             emitPutHomeObject(generator, next.get(), homeObject.get());
3807         }
3808 
3809         if (generator.parseMode() == SourceParseMode::AsyncArrowFunctionMode &amp;&amp; generator.isThisUsedInInnerArrowFunction())
3810             generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
3811 
3812         generator.emitPutGeneratorFields(next.get());
3813 
3814         ASSERT(startOffset() &gt;= lineStartOffset());
3815         generator.emitDebugHook(WillLeaveCallFrame, lastLine(), startOffset(), lineStartOffset());
3816 
3817         // load and call @asyncFunctionResume
3818         auto var = generator.variable(generator.propertyNames().builtinNames().asyncFunctionResumePrivateName());
3819         RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();
3820         generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));
3821         RefPtr&lt;RegisterID&gt; asyncFunctionResume = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
3822 
3823         CallArguments args(generator, nullptr, 4);
3824         unsigned argumentCount = 0;
3825         generator.emitLoad(args.thisRegister(), jsUndefined());
3826         generator.move(args.argumentRegister(argumentCount++), generator.generatorRegister());
3827         generator.move(args.argumentRegister(argumentCount++), generator.promiseCapabilityRegister());
3828         generator.emitLoad(args.argumentRegister(argumentCount++), jsUndefined());
3829         generator.emitLoad(args.argumentRegister(argumentCount++), jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode)));
3830         // JSTextPosition(int _line, int _offset, int _lineStartOffset)
3831         JSTextPosition divot(firstLine(), startOffset(), lineStartOffset());
3832 
3833         RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
3834         generator.emitCallInTailPosition(result.get(), asyncFunctionResume.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
3835         generator.emitReturn(result.get());
3836         break;
3837     }
3838 
3839     case SourceParseMode::AsyncGeneratorBodyMode:
3840     case SourceParseMode::AsyncArrowFunctionBodyMode:
3841     case SourceParseMode::AsyncFunctionBodyMode:
3842     case SourceParseMode::GeneratorBodyMode: {
3843         Ref&lt;Label&gt; generatorBodyLabel = generator.newLabel();
3844         {
3845             RefPtr&lt;RegisterID&gt; condition = generator.newTemporary();
3846             generator.emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generator.generatorResumeModeRegister(), generator.emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode))));
3847             generator.emitJumpIfTrue(condition.get(), generatorBodyLabel.get());
3848 
3849             Ref&lt;Label&gt; throwLabel = generator.newLabel();
3850             generator.emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generator.generatorResumeModeRegister(), generator.emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::ThrowMode))));
3851             generator.emitJumpIfTrue(condition.get(), throwLabel.get());
3852 
3853             generator.emitReturn(generator.generatorValueRegister());
3854 
3855             generator.emitLabel(throwLabel.get());
3856             generator.emitThrow(generator.generatorValueRegister());
3857         }
3858 
3859         generator.emitLabel(generatorBodyLabel.get());
3860 
3861         emitStatementsBytecode(generator, generator.ignoredResult());
3862 
3863         Ref&lt;Label&gt; done = generator.newLabel();
3864         generator.emitLabel(done.get());
3865         generator.emitReturn(generator.emitLoad(nullptr, jsUndefined()));
3866         break;
3867     }
3868 
3869     default: {
3870         emitStatementsBytecode(generator, generator.ignoredResult());
3871 
3872         StatementNode* singleStatement = this-&gt;singleStatement();
3873         ReturnNode* returnNode = 0;
3874 
3875         // Check for a return statement at the end of a function composed of a single block.
3876         if (singleStatement &amp;&amp; singleStatement-&gt;isBlock()) {
3877             StatementNode* lastStatementInBlock = static_cast&lt;BlockNode*&gt;(singleStatement)-&gt;lastStatement();
3878             if (lastStatementInBlock &amp;&amp; lastStatementInBlock-&gt;isReturnNode())
3879                 returnNode = static_cast&lt;ReturnNode*&gt;(lastStatementInBlock);
3880         }
3881 
3882         // If there is no return we must automatically insert one.
3883         if (!returnNode) {
3884             if (generator.constructorKind() == ConstructorKind::Extends &amp;&amp; generator.needsToUpdateArrowFunctionContext() &amp;&amp; generator.isSuperCallUsedInInnerArrowFunction())
3885                 generator.emitLoadThisFromArrowFunctionLexicalEnvironment(); // Arrow function can invoke &#39;super&#39; in constructor and before leave constructor we need load &#39;this&#39; from lexical arrow function environment
3886 
3887             RegisterID* r0 = generator.isConstructor() ? generator.thisRegister() : generator.emitLoad(0, jsUndefined());
3888             generator.emitProfileType(r0, ProfileTypeBytecodeFunctionReturnStatement); // Do not emit expression info for this profile because it&#39;s not in the user&#39;s source code.
3889             ASSERT(startOffset() &gt;= lineStartOffset());
3890             generator.emitWillLeaveCallFrameDebugHook();
3891             generator.emitReturn(r0);
3892             return;
3893         }
3894         break;
3895     }
3896     }
3897 }
3898 
3899 // ------------------------------ FuncDeclNode ---------------------------------
3900 
3901 void FuncDeclNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3902 {
3903     generator.hoistSloppyModeFunctionIfNecessary(metadata()-&gt;ident());
3904 }
3905 
3906 // ------------------------------ FuncExprNode ---------------------------------
3907 
3908 RegisterID* FuncExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3909 {
3910     return generator.emitNewFunctionExpression(generator.finalDestination(dst), this);
3911 }
3912 
3913 // ------------------------------ ArrowFuncExprNode ---------------------------------
3914 
3915 RegisterID* ArrowFuncExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3916 {
3917     return generator.emitNewArrowFunctionExpression(generator.finalDestination(dst), this);
3918 }
3919 
3920 // ------------------------------ MethodDefinitionNode ---------------------------------
3921 
3922 RegisterID* MethodDefinitionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3923 {
3924     return generator.emitNewMethodDefinition(generator.finalDestination(dst), this);
3925 }
3926 
3927 // ------------------------------ YieldExprNode --------------------------------
3928 
3929 RegisterID* YieldExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3930 {
3931     if (!delegate()) {
3932         RefPtr&lt;RegisterID&gt; arg = nullptr;
3933         if (argument()) {
3934             arg = generator.newTemporary();
3935             generator.emitNode(arg.get(), argument());
3936         } else
3937             arg = generator.emitLoad(nullptr, jsUndefined());
3938         RefPtr&lt;RegisterID&gt; value = generator.emitYield(arg.get(), JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Yield);
3939         if (dst == generator.ignoredResult())
3940             return nullptr;
3941         return generator.move(generator.finalDestination(dst), value.get());
3942     }
3943     RefPtr&lt;RegisterID&gt; arg = generator.newTemporary();
3944     generator.emitNode(arg.get(), argument());
3945     RefPtr&lt;RegisterID&gt; value = generator.emitDelegateYield(arg.get(), this);
3946     if (dst == generator.ignoredResult())
3947         return nullptr;
3948     return generator.move(generator.finalDestination(dst), value.get());
3949 }
3950 
3951 // ------------------------------ AwaitExprNode --------------------------------
3952 
3953 RegisterID* AwaitExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3954 {
3955     RefPtr&lt;RegisterID&gt; arg = generator.newTemporary();
3956     generator.emitNode(arg.get(), argument());
3957     RefPtr&lt;RegisterID&gt; value = generator.emitYield(arg.get(), JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Await);
3958     if (dst == generator.ignoredResult())
3959         return nullptr;
3960     return generator.move(generator.finalDestination(dst), value.get());
3961 }
3962 
3963 // ------------------------------ ClassDeclNode ---------------------------------
3964 
3965 void ClassDeclNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3966 {
3967     generator.emitNode(m_classDeclaration);
3968 }
3969 
3970 // ------------------------------ ClassExprNode ---------------------------------
3971 
3972 RegisterID* ClassExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3973 {
3974     if (!m_name.isNull())
3975         generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested);
3976 
3977     RefPtr&lt;RegisterID&gt; superclass;
3978     if (m_classHeritage) {
3979         superclass = generator.newTemporary();
3980         generator.emitNode(superclass.get(), m_classHeritage);
3981     }
3982 
3983     RefPtr&lt;RegisterID&gt; constructor = generator.tempDestination(dst);
3984     bool needsHomeObject = false;
3985 
3986     if (m_constructorExpression) {
3987         ASSERT(m_constructorExpression-&gt;isFuncExprNode());
3988         FunctionMetadataNode* metadata = static_cast&lt;FuncExprNode*&gt;(m_constructorExpression)-&gt;metadata();
3989         metadata-&gt;setEcmaName(ecmaName());
3990         metadata-&gt;setClassSource(m_classSource);
3991         constructor = generator.emitNode(constructor.get(), m_constructorExpression);
3992         needsHomeObject = m_classHeritage || metadata-&gt;superBinding() == SuperBinding::Needed;
3993     } else
3994         constructor = generator.emitNewDefaultConstructor(constructor.get(), m_classHeritage ? ConstructorKind::Extends : ConstructorKind::Base, m_name, ecmaName(), m_classSource);
3995 
3996     const auto&amp; propertyNames = generator.propertyNames();
3997     RefPtr&lt;RegisterID&gt; prototype = generator.emitNewObject(generator.newTemporary());
3998 
3999     if (superclass) {
4000         RefPtr&lt;RegisterID&gt; protoParent = generator.newTemporary();
4001         generator.emitLoad(protoParent.get(), jsNull());
4002 
4003         RefPtr&lt;RegisterID&gt; tempRegister = generator.newTemporary();
4004 
4005         // FIXME: Throw TypeError if it&#39;s a generator function.
4006         Ref&lt;Label&gt; superclassIsUndefinedLabel = generator.newLabel();
4007         generator.emitJumpIfTrue(generator.emitIsUndefined(tempRegister.get(), superclass.get()), superclassIsUndefinedLabel.get());
4008 
4009         Ref&lt;Label&gt; superclassIsNullLabel = generator.newLabel();
4010         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpEqNull&gt;(tempRegister.get(), superclass.get()), superclassIsNullLabel.get());
4011 
4012         Ref&lt;Label&gt; superclassIsObjectLabel = generator.newLabel();
4013         generator.emitJumpIfTrue(generator.emitIsObject(tempRegister.get(), superclass.get()), superclassIsObjectLabel.get());
4014         generator.emitLabel(superclassIsUndefinedLabel.get());
4015         generator.emitThrowTypeError(&quot;The superclass is not an object.&quot;_s);
4016         generator.emitLabel(superclassIsObjectLabel.get());
4017         generator.emitGetById(protoParent.get(), superclass.get(), generator.propertyNames().prototype);
4018 
4019         Ref&lt;Label&gt; protoParentIsObjectOrNullLabel = generator.newLabel();
4020         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpIsObjectOrNull&gt;(tempRegister.get(), protoParent.get()), protoParentIsObjectOrNullLabel.get());
4021         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpIsFunction&gt;(tempRegister.get(), protoParent.get()), protoParentIsObjectOrNullLabel.get());
4022         generator.emitThrowTypeError(&quot;The value of the superclass&#39;s prototype property is not an object.&quot;_s);
4023         generator.emitLabel(protoParentIsObjectOrNullLabel.get());
4024 
4025         generator.emitDirectPutById(constructor.get(), generator.propertyNames().underscoreProto, superclass.get(), PropertyNode::Unknown);
4026         generator.emitLabel(superclassIsNullLabel.get());
4027         generator.emitDirectPutById(prototype.get(), generator.propertyNames().underscoreProto, protoParent.get(), PropertyNode::Unknown);
4028     }
4029 
4030     if (needsHomeObject)
4031         emitPutHomeObject(generator, constructor.get(), prototype.get());
4032 
4033     RefPtr&lt;RegisterID&gt; constructorNameRegister = generator.emitLoad(nullptr, propertyNames.constructor);
4034     generator.emitCallDefineProperty(prototype.get(), constructorNameRegister.get(), constructor.get(), nullptr, nullptr,
4035         BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable, m_position);
4036 
4037     RefPtr&lt;RegisterID&gt; prototypeNameRegister = generator.emitLoad(nullptr, propertyNames.prototype);
4038     generator.emitCallDefineProperty(constructor.get(), prototypeNameRegister.get(), prototype.get(), nullptr, nullptr, 0, m_position);
4039 
4040     if (m_classElements)
4041         generator.emitDefineClassElements(m_classElements, constructor.get(), prototype.get());
4042 
4043     if (!m_name.isNull()) {
4044         Variable classNameVar = generator.variable(m_name);
4045         RELEASE_ASSERT(classNameVar.isResolved());
4046         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, classNameVar);
4047         generator.emitPutToScope(scope.get(), classNameVar, constructor.get(), ThrowIfNotFound, InitializationMode::Initialization);
4048         generator.popLexicalScope(this);
4049     }
4050 
4051     return generator.move(generator.finalDestination(dst, constructor.get()), constructor.get());
4052 }
4053 
4054 // ------------------------------ ImportDeclarationNode -----------------------
4055 
4056 void ImportDeclarationNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4057 {
4058     // Do nothing at runtime.
4059 }
4060 
4061 // ------------------------------ ExportAllDeclarationNode --------------------
4062 
4063 void ExportAllDeclarationNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4064 {
4065     // Do nothing at runtime.
4066 }
4067 
4068 // ------------------------------ ExportDefaultDeclarationNode ----------------
4069 
4070 void ExportDefaultDeclarationNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4071 {
4072     ASSERT(m_declaration);
4073     generator.emitNode(dst, m_declaration);
4074 }
4075 
4076 // ------------------------------ ExportLocalDeclarationNode ------------------
4077 
4078 void ExportLocalDeclarationNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4079 {
4080     ASSERT(m_declaration);
4081     generator.emitNode(dst, m_declaration);
4082 }
4083 
4084 // ------------------------------ ExportNamedDeclarationNode ------------------
4085 
4086 void ExportNamedDeclarationNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4087 {
4088     // Do nothing at runtime.
4089 }
4090 
4091 // ------------------------------ DestructuringAssignmentNode -----------------
4092 RegisterID* DestructuringAssignmentNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4093 {
4094     if (RegisterID* result = m_bindings-&gt;emitDirectBinding(generator, dst, m_initializer))
4095         return result;
4096     RefPtr&lt;RegisterID&gt; initializer = generator.tempDestination(dst);
4097     generator.emitNode(initializer.get(), m_initializer);
4098     m_bindings-&gt;bindValue(generator, initializer.get());
4099     return generator.move(dst, initializer.get());
4100 }
4101 
4102 static void assignDefaultValueIfUndefined(BytecodeGenerator&amp; generator, RegisterID* maybeUndefined, ExpressionNode* defaultValue)
4103 {
4104     ASSERT(defaultValue);
4105     Ref&lt;Label&gt; isNotUndefined = generator.newLabel();
4106     generator.emitJumpIfFalse(generator.emitIsUndefined(generator.newTemporary(), maybeUndefined), isNotUndefined.get());
4107     generator.emitNode(maybeUndefined, defaultValue);
4108     generator.emitLabel(isNotUndefined.get());
4109 }
4110 
4111 void ArrayPatternNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* rhs) const
4112 {
4113     RefPtr&lt;RegisterID&gt; iterator = generator.newTemporary();
4114     {
4115         generator.emitGetById(iterator.get(), rhs, generator.propertyNames().iteratorSymbol);
4116         CallArguments args(generator, nullptr);
4117         generator.move(args.thisRegister(), rhs);
4118         generator.emitCall(iterator.get(), iterator.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4119     }
4120     RefPtr&lt;RegisterID&gt; nextMethod = generator.emitGetById(generator.newTemporary(), iterator.get(), generator.propertyNames().next);
4121 
4122     if (m_targetPatterns.isEmpty()) {
4123         generator.emitIteratorClose(iterator.get(), this);
4124         return;
4125     }
4126 
4127     RefPtr&lt;RegisterID&gt; done;
4128     for (auto&amp; target : m_targetPatterns) {
4129         switch (target.bindingType) {
4130         case BindingType::Elision:
4131         case BindingType::Element: {
4132             Ref&lt;Label&gt; iterationSkipped = generator.newLabel();
4133             if (!done)
4134                 done = generator.newTemporary();
4135             else
4136                 generator.emitJumpIfTrue(done.get(), iterationSkipped.get());
4137 
4138             RefPtr&lt;RegisterID&gt; value = generator.newTemporary();
4139             generator.emitIteratorNext(value.get(), nextMethod.get(), iterator.get(), this);
4140             generator.emitGetById(done.get(), value.get(), generator.propertyNames().done);
4141             generator.emitJumpIfTrue(done.get(), iterationSkipped.get());
4142             generator.emitGetById(value.get(), value.get(), generator.propertyNames().value);
4143 
4144             {
4145                 Ref&lt;Label&gt; valueIsSet = generator.newLabel();
4146                 generator.emitJump(valueIsSet.get());
4147                 generator.emitLabel(iterationSkipped.get());
4148                 generator.emitLoad(value.get(), jsUndefined());
4149                 generator.emitLabel(valueIsSet.get());
4150             }
4151 
4152             if (target.bindingType == BindingType::Element) {
4153                 if (target.defaultValue)
4154                     assignDefaultValueIfUndefined(generator, value.get(), target.defaultValue);
4155                 target.pattern-&gt;bindValue(generator, value.get());
4156             }
4157             break;
4158         }
4159 
4160         case BindingType::RestElement: {
4161             RefPtr&lt;RegisterID&gt; array = generator.emitNewArray(generator.newTemporary(), nullptr, 0, ArrayWithUndecided);
4162 
4163             Ref&lt;Label&gt; iterationDone = generator.newLabel();
4164             if (!done)
4165                 done = generator.newTemporary();
4166             else
4167                 generator.emitJumpIfTrue(done.get(), iterationDone.get());
4168 
4169             RefPtr&lt;RegisterID&gt; index = generator.newTemporary();
4170             generator.emitLoad(index.get(), jsNumber(0));
4171             Ref&lt;Label&gt; loopStart = generator.newLabel();
4172             generator.emitLabel(loopStart.get());
4173 
4174             RefPtr&lt;RegisterID&gt; value = generator.newTemporary();
4175             generator.emitIteratorNext(value.get(), nextMethod.get(), iterator.get(), this);
4176             generator.emitGetById(done.get(), value.get(), generator.propertyNames().done);
4177             generator.emitJumpIfTrue(done.get(), iterationDone.get());
4178             generator.emitGetById(value.get(), value.get(), generator.propertyNames().value);
4179 
4180             generator.emitDirectPutByVal(array.get(), index.get(), value.get());
4181             generator.emitInc(index.get());
4182             generator.emitJump(loopStart.get());
4183 
4184             generator.emitLabel(iterationDone.get());
4185             target.pattern-&gt;bindValue(generator, array.get());
4186             break;
4187         }
4188         }
4189     }
4190 
4191     Ref&lt;Label&gt; iteratorClosed = generator.newLabel();
4192     generator.emitJumpIfTrue(done.get(), iteratorClosed.get());
4193     generator.emitIteratorClose(iterator.get(), this);
4194     generator.emitLabel(iteratorClosed.get());
4195 }
4196 
4197 RegisterID* ArrayPatternNode::emitDirectBinding(BytecodeGenerator&amp; generator, RegisterID* dst, ExpressionNode* rhs)
4198 {
4199     if (!rhs-&gt;isSimpleArray())
4200         return nullptr;
4201 
4202     ElementNode* elementNodes = static_cast&lt;ArrayNode*&gt;(rhs)-&gt;elements();
4203     Vector&lt;ExpressionNode*&gt; elements;
4204     for (; elementNodes; elementNodes = elementNodes-&gt;next()) {
4205         ExpressionNode* value = elementNodes-&gt;value();
4206         if (value-&gt;isSpreadExpression())
4207             return nullptr;
4208         elements.append(value);
4209     }
4210 
4211     RefPtr&lt;RegisterID&gt; resultRegister;
4212     if (dst != generator.ignoredResult())
4213         resultRegister = generator.emitNewArray(generator.newTemporary(), nullptr, 0, ArrayWithUndecided);
4214     if (m_targetPatterns.size() != elements.size())
4215         return nullptr;
4216     Vector&lt;RefPtr&lt;RegisterID&gt;&gt; registers;
4217     registers.reserveCapacity(m_targetPatterns.size());
4218     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4219         registers.uncheckedAppend(generator.newTemporary());
4220         generator.emitNode(registers.last().get(), elements[i]);
4221         if (m_targetPatterns[i].defaultValue)
4222             assignDefaultValueIfUndefined(generator, registers.last().get(), m_targetPatterns[i].defaultValue);
4223         if (resultRegister) {
4224             RefPtr&lt;RegisterID&gt; index = generator.emitLoad(nullptr, jsNumber(i));
4225             generator.emitDirectPutByVal(resultRegister.get(), index.get(), registers.last().get());
4226         }
4227     }
4228 
4229     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4230         if (m_targetPatterns[i].pattern)
4231             m_targetPatterns[i].pattern-&gt;bindValue(generator, registers[i].get());
4232     }
4233     if (resultRegister)
4234         return generator.move(generator.finalDestination(dst, resultRegister.get()), resultRegister.get());
4235     return generator.emitLoad(generator.finalDestination(dst), jsUndefined());
4236 }
4237 
4238 void ArrayPatternNode::toString(StringBuilder&amp; builder) const
4239 {
4240     builder.append(&#39;[&#39;);
4241     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4242         const auto&amp; target = m_targetPatterns[i];
4243 
4244         switch (target.bindingType) {
4245         case BindingType::Elision:
4246             builder.append(&#39;,&#39;);
4247             break;
4248 
4249         case BindingType::Element:
4250             target.pattern-&gt;toString(builder);
4251             if (i &lt; m_targetPatterns.size() - 1)
4252                 builder.append(&#39;,&#39;);
4253             break;
4254 
4255         case BindingType::RestElement:
4256             builder.appendLiteral(&quot;...&quot;);
4257             target.pattern-&gt;toString(builder);
4258             break;
4259         }
4260     }
4261     builder.append(&#39;]&#39;);
4262 }
4263 
4264 void ArrayPatternNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
4265 {
4266     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4267         if (DestructuringPatternNode* node = m_targetPatterns[i].pattern)
4268             node-&gt;collectBoundIdentifiers(identifiers);
4269     }
4270 }
4271 
4272 void ObjectPatternNode::toString(StringBuilder&amp; builder) const
4273 {
4274     builder.append(&#39;{&#39;);
4275     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4276         if (m_targetPatterns[i].wasString)
4277             builder.appendQuotedJSONString(m_targetPatterns[i].propertyName.string());
4278         else
4279             builder.append(m_targetPatterns[i].propertyName.string());
4280         builder.append(&#39;:&#39;);
4281         m_targetPatterns[i].pattern-&gt;toString(builder);
4282         if (i &lt; m_targetPatterns.size() - 1)
4283             builder.append(&#39;,&#39;);
4284     }
4285     builder.append(&#39;}&#39;);
4286 }
4287 
4288 void ObjectPatternNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* rhs) const
4289 {
4290     generator.emitRequireObjectCoercible(rhs, &quot;Right side of assignment cannot be destructured&quot;_s);
4291 
4292     RefPtr&lt;RegisterID&gt; excludedList;
4293     IdentifierSet excludedSet;
4294     RefPtr&lt;RegisterID&gt; addMethod;
4295     if (m_containsRestElement &amp;&amp; m_containsComputedProperty) {
4296         auto var = generator.variable(generator.propertyNames().builtinNames().SetPrivateName());
4297 
4298         RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();
4299         generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));
4300         RefPtr&lt;RegisterID&gt; setConstructor = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
4301 
4302         CallArguments args(generator, nullptr, 0);
4303         excludedList = generator.emitConstruct(generator.newTemporary(), setConstructor.get(), setConstructor.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd());
4304 
4305         addMethod = generator.emitGetById(generator.newTemporary(), excludedList.get(), generator.propertyNames().builtinNames().addPrivateName());
4306     }
4307 
<a name="81" id="anc81"></a>


4308     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4309         const auto&amp; target = m_targetPatterns[i];
4310         if (target.bindingType == BindingType::Element) {
4311             RefPtr&lt;RegisterID&gt; temp = generator.newTemporary();
4312             RefPtr&lt;RegisterID&gt; propertyName;
4313             if (!target.propertyExpression) {
4314                 Optional&lt;uint32_t&gt; optionalIndex = parseIndex(target.propertyName);
4315                 if (!optionalIndex)
4316                     generator.emitGetById(temp.get(), rhs, target.propertyName);
4317                 else {
4318                     RefPtr&lt;RegisterID&gt; propertyIndex = generator.emitLoad(nullptr, jsNumber(optionalIndex.value()));
4319                     generator.emitGetByVal(temp.get(), rhs, propertyIndex.get());
4320                 }
4321             } else {
4322                 propertyName = generator.emitNodeForProperty(target.propertyExpression);
4323                 generator.emitGetByVal(temp.get(), rhs, propertyName.get());
4324             }
4325 
4326             if (m_containsRestElement) {
4327                 if (m_containsComputedProperty) {
4328                     if (!target.propertyExpression)
4329                         propertyName = generator.emitLoad(nullptr, target.propertyName);
4330 
4331                     CallArguments args(generator, nullptr, 1);
4332                     generator.move(args.thisRegister(), excludedList.get());
4333                     generator.move(args.argumentRegister(0), propertyName.get());
4334                     generator.emitCall(generator.newTemporary(), addMethod.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4335                 } else
4336                     excludedSet.add(target.propertyName.impl());
4337             }
4338 
4339             if (target.defaultValue)
4340                 assignDefaultValueIfUndefined(generator, temp.get(), target.defaultValue);
4341             target.pattern-&gt;bindValue(generator, temp.get());
4342         } else {
4343             ASSERT(target.bindingType == BindingType::RestElement);
4344             ASSERT(i == m_targetPatterns.size() - 1);
4345             RefPtr&lt;RegisterID&gt; newObject = generator.emitNewObject(generator.newTemporary());
4346 
4347             // load and call @copyDataProperties
4348             auto var = generator.variable(generator.propertyNames().builtinNames().copyDataPropertiesPrivateName());
4349 
4350             RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();
4351             generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));
4352             RefPtr&lt;RegisterID&gt; copyDataProperties = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
4353 
4354             CallArguments args(generator, nullptr, 3);
4355             generator.emitLoad(args.thisRegister(), jsUndefined());
4356             generator.move(args.argumentRegister(0), newObject.get());
4357             generator.move(args.argumentRegister(1), rhs);
4358             if (m_containsComputedProperty)
4359                 generator.move(args.argumentRegister(2), excludedList.get());
4360             else {
4361                 RefPtr&lt;RegisterID&gt; excludedSetReg = generator.emitLoad(generator.newTemporary(), excludedSet);
4362                 generator.move(args.argumentRegister(2), excludedSetReg.get());
4363             }
4364 
4365             RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
4366             generator.emitCall(result.get(), copyDataProperties.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4367             target.pattern-&gt;bindValue(generator, result.get());
4368         }
4369     }
<a name="82" id="anc82"></a>

4370 }
4371 
4372 void ObjectPatternNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
4373 {
4374     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++)
4375         m_targetPatterns[i].pattern-&gt;collectBoundIdentifiers(identifiers);
4376 }
4377 
4378 void BindingNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* value) const
4379 {
4380     Variable var = generator.variable(m_boundProperty);
4381     bool isReadOnly = var.isReadOnly() &amp;&amp; m_bindingContext != AssignmentContext::ConstDeclarationStatement;
4382     if (RegisterID* local = var.local()) {
4383         if (m_bindingContext == AssignmentContext::AssignmentExpression)
4384             generator.emitTDZCheckIfNecessary(var, local, nullptr);
4385         if (isReadOnly) {
4386             generator.emitReadOnlyExceptionIfNeeded(var);
4387             return;
4388         }
4389         generator.move(local, value);
4390         generator.emitProfileType(local, var, divotStart(), divotEnd());
4391         if (m_bindingContext == AssignmentContext::DeclarationStatement || m_bindingContext == AssignmentContext::ConstDeclarationStatement)
4392             generator.liftTDZCheckIfPossible(var);
4393         return;
4394     }
4395     if (generator.isStrictMode())
4396         generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4397     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
4398     generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4399     if (m_bindingContext == AssignmentContext::AssignmentExpression)
4400         generator.emitTDZCheckIfNecessary(var, nullptr, scope.get());
4401     if (isReadOnly) {
4402         generator.emitReadOnlyExceptionIfNeeded(var);
4403         return;
4404     }
4405     generator.emitPutToScope(scope.get(), var, value, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, initializationModeForAssignmentContext(m_bindingContext));
4406     generator.emitProfileType(value, var, divotStart(), divotEnd());
4407     if (m_bindingContext == AssignmentContext::DeclarationStatement || m_bindingContext == AssignmentContext::ConstDeclarationStatement)
4408         generator.liftTDZCheckIfPossible(var);
4409     return;
4410 }
4411 
4412 void BindingNode::toString(StringBuilder&amp; builder) const
4413 {
4414     builder.append(m_boundProperty.string());
4415 }
4416 
4417 void BindingNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
4418 {
4419     identifiers.append(m_boundProperty);
4420 }
4421 
4422 void AssignmentElementNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const
4423 {
4424 }
4425 
4426 void AssignmentElementNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* value) const
4427 {
4428     if (m_assignmentTarget-&gt;isResolveNode()) {
4429         ResolveNode* lhs = static_cast&lt;ResolveNode*&gt;(m_assignmentTarget);
4430         Variable var = generator.variable(lhs-&gt;identifier());
4431         bool isReadOnly = var.isReadOnly();
4432         if (RegisterID* local = var.local()) {
4433             generator.emitTDZCheckIfNecessary(var, local, nullptr);
4434 
4435             if (isReadOnly)
4436                 generator.emitReadOnlyExceptionIfNeeded(var);
4437             else {
4438                 generator.move(local, value);
4439                 generator.emitProfileType(local, divotStart(), divotEnd());
4440             }
4441             return;
4442         }
4443         if (generator.isStrictMode())
4444             generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4445         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
4446         generator.emitTDZCheckIfNecessary(var, nullptr, scope.get());
4447         if (isReadOnly) {
4448             bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
4449             if (threwException)
4450                 return;
4451         }
4452         generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4453         if (!isReadOnly) {
4454             generator.emitPutToScope(scope.get(), var, value, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
4455             generator.emitProfileType(value, var, divotStart(), divotEnd());
4456         }
4457     } else if (m_assignmentTarget-&gt;isDotAccessorNode()) {
4458         DotAccessorNode* lhs = static_cast&lt;DotAccessorNode*&gt;(m_assignmentTarget);
4459         RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(lhs-&gt;base(), true, false);
4460         generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4461         if (lhs-&gt;base()-&gt;isSuperNode()) {
4462             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
4463             generator.emitPutById(base.get(), thisValue.get(), lhs-&gt;identifier(), value);
4464         } else
4465             generator.emitPutById(base.get(), lhs-&gt;identifier(), value);
4466         generator.emitProfileType(value, divotStart(), divotEnd());
4467     } else if (m_assignmentTarget-&gt;isBracketAccessorNode()) {
4468         BracketAccessorNode* lhs = static_cast&lt;BracketAccessorNode*&gt;(m_assignmentTarget);
4469         RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(lhs-&gt;base(), true, false);
4470         RefPtr&lt;RegisterID&gt; property = generator.emitNodeForLeftHandSideForProperty(lhs-&gt;subscript(), true, false);
4471         generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4472         if (lhs-&gt;base()-&gt;isSuperNode()) {
4473             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
4474             generator.emitPutByVal(base.get(), thisValue.get(), property.get(), value);
4475         } else
4476             generator.emitPutByVal(base.get(), property.get(), value);
4477         generator.emitProfileType(value, divotStart(), divotEnd());
4478     }
4479 }
4480 
4481 void AssignmentElementNode::toString(StringBuilder&amp; builder) const
4482 {
4483     if (m_assignmentTarget-&gt;isResolveNode())
4484         builder.append(static_cast&lt;ResolveNode*&gt;(m_assignmentTarget)-&gt;identifier().string());
4485 }
4486 
4487 void RestParameterNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
4488 {
4489     m_pattern-&gt;collectBoundIdentifiers(identifiers);
4490 }
4491 
4492 void RestParameterNode::toString(StringBuilder&amp; builder) const
4493 {
4494     builder.appendLiteral(&quot;...&quot;);
4495     m_pattern-&gt;toString(builder);
4496 }
4497 
4498 void RestParameterNode::bindValue(BytecodeGenerator&amp;, RegisterID*) const
4499 {
4500     RELEASE_ASSERT_NOT_REACHED();
4501 }
4502 
4503 void RestParameterNode::emit(BytecodeGenerator&amp; generator)
4504 {
4505     RefPtr&lt;RegisterID&gt; temp = generator.newTemporary();
4506     generator.emitRestParameter(temp.get(), m_numParametersToSkip);
4507     m_pattern-&gt;bindValue(generator, temp.get());
4508 }
4509 
4510 
4511 RegisterID* SpreadExpressionNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4512 {
4513     RELEASE_ASSERT_NOT_REACHED();
4514     return 0;
4515 }
4516 
4517 RegisterID* ObjectSpreadExpressionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4518 {
4519     RefPtr&lt;RegisterID&gt; src = generator.newTemporary();
4520     generator.emitNode(src.get(), m_expression);
4521 
4522     // load and call @copyDataPropertiesNoExclusions
4523     auto var = generator.variable(generator.propertyNames().builtinNames().copyDataPropertiesNoExclusionsPrivateName());
4524 
4525     RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();
4526     generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));
4527     RefPtr&lt;RegisterID&gt; copyDataProperties = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
4528 
4529     CallArguments args(generator, nullptr, 2);
4530     generator.emitLoad(args.thisRegister(), jsUndefined());
4531     generator.move(args.argumentRegister(0), dst);
4532     generator.move(args.argumentRegister(1), src.get());
4533 
4534     generator.emitCall(generator.newTemporary(), copyDataProperties.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4535 
4536     return dst;
4537 }
4538 
4539 } // namespace JSC
<a name="83" id="anc83"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="83" type="hidden" />
</body>
</html>