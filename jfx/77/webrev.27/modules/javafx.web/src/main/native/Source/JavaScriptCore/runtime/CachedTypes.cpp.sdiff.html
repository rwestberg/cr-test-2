<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CachedTypes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ButterflyInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CachedTypes.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CachedTypes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CachedTypes.h&quot;
  28 

  29 #include &quot;BytecodeCacheVersion.h&quot;
  30 #include &quot;BytecodeLivenessAnalysis.h&quot;
<span class="line-modified">  31 #include &quot;JSCast.h&quot;</span>
  32 #include &quot;JSImmutableButterfly.h&quot;
  33 #include &quot;JSTemplateObjectDescriptor.h&quot;
  34 #include &quot;ScopedArgumentsTable.h&quot;
  35 #include &quot;SourceCodeKey.h&quot;

  36 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  37 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  38 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  39 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  40 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  41 #include &lt;wtf/FastMalloc.h&gt;
<span class="line-removed">  42 #include &lt;wtf/Forward.h&gt;</span>
  43 #include &lt;wtf/Optional.h&gt;
  44 #include &lt;wtf/UUID.h&gt;
<span class="line-modified">  45 #include &lt;wtf/text/AtomicStringImpl.h&gt;</span>
  46 
  47 namespace JSC {
  48 




  49 template &lt;typename T, typename = void&gt;
  50 struct SourceTypeImpl {
  51     using type = T;
  52 };
  53 
  54 template&lt;typename T&gt;
  55 struct SourceTypeImpl&lt;T, std::enable_if_t&lt;!std::is_fundamental&lt;T&gt;::value &amp;&amp; !std::is_same&lt;typename T::SourceType_, void&gt;::value&gt;&gt; {
  56     using type = typename T::SourceType_;
  57 
  58 };
  59 
  60 template&lt;typename T&gt;
  61 using SourceType = typename SourceTypeImpl&lt;T&gt;::type;
  62 
  63 class Encoder {
  64     WTF_MAKE_NONCOPYABLE(Encoder);
  65     WTF_FORBID_HEAP_ALLOCATION;
  66 
  67 public:
  68     class Allocation {
  69         friend class Encoder;
  70 
  71     public:
  72         uint8_t* buffer() const { return m_buffer; }
  73         ptrdiff_t offset() const { return m_offset; }
  74 
  75     private:
  76         Allocation(uint8_t* buffer, ptrdiff_t offset)
  77             : m_buffer(buffer)
  78             , m_offset(offset)
  79         {
  80         }
  81 
  82         uint8_t* m_buffer;
  83         ptrdiff_t m_offset;
  84     };
  85 
<span class="line-modified">  86     Encoder(VM&amp; vm)</span>
  87         : m_vm(vm)

  88         , m_baseOffset(0)
  89         , m_currentPage(nullptr)
  90     {
  91         allocateNewPage();
  92     }
  93 
  94     VM&amp; vm() { return m_vm; }
  95 
  96     Allocation malloc(unsigned size)
  97     {
<span class="line-modified">  98         ASSERT(size);</span>
  99         ptrdiff_t offset;
 100         if (m_currentPage-&gt;malloc(size, offset))
 101             return Allocation { m_currentPage-&gt;buffer() + offset, m_baseOffset + offset };
 102         allocateNewPage(size);
 103         return malloc(size);
 104     }
 105 
 106     template&lt;typename T, typename... Args&gt;
 107     T* malloc(Args&amp;&amp;... args)
 108     {
 109         return new (malloc(sizeof(T)).buffer()) T(std::forward&lt;Args&gt;(args)...);
 110     }
 111 
 112     ptrdiff_t offsetOf(const void* address)
 113     {
 114         ptrdiff_t offset;
 115         ptrdiff_t baseOffset = 0;
 116         for (const auto&amp; page : m_pages) {
 117             if (page.getOffset(address, offset))
 118                 return baseOffset + offset;
 119             baseOffset += page.size();
 120         }
 121         RELEASE_ASSERT_NOT_REACHED();
 122         return 0;
 123     }
 124 
 125     void cachePtr(const void* ptr, ptrdiff_t offset)
 126     {
 127         m_ptrToOffsetMap.add(ptr, offset);
 128     }
 129 
<span class="line-modified"> 130     WTF::Optional&lt;ptrdiff_t&gt; offsetForPtr(const void* ptr)</span>
 131     {
 132         auto it = m_ptrToOffsetMap.find(ptr);
 133         if (it == m_ptrToOffsetMap.end())
 134             return WTF::nullopt;
 135         return { it-&gt;value };
 136     }
 137 
<span class="line-modified"> 138     std::pair&lt;MallocPtr&lt;uint8_t&gt;, size_t&gt; release()</span>





 139     {








 140         size_t size = m_baseOffset + m_currentPage-&gt;size();
 141         MallocPtr&lt;uint8_t&gt; buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);
 142         unsigned offset = 0;
 143         for (const auto&amp; page : m_pages) {
 144             memcpy(buffer.get() + offset, page.buffer(), page.size());
 145             offset += page.size();
 146         }
 147         RELEASE_ASSERT(offset == size);
<span class="line-modified"> 148         return { WTFMove(buffer), size };</span>
 149     }
 150 
 151 private:































 152     class Page {
 153     public:
 154         Page(size_t size)
 155             : m_offset(0)
 156             , m_capacity(size)
 157         {
 158             m_buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);
 159         }
 160 
 161         bool malloc(size_t size, ptrdiff_t&amp; result)
 162         {
 163             size_t alignment = std::min(alignof(std::max_align_t), static_cast&lt;size_t&gt;(WTF::roundUpToPowerOfTwo(size)));
<span class="line-modified"> 164             ptrdiff_t offset = WTF::roundUpToMultipleOf(alignment, m_offset);</span>
<span class="line-modified"> 165             size = WTF::roundUpToMultipleOf(alignment, size);</span>
 166             if (static_cast&lt;size_t&gt;(offset + size) &gt; m_capacity)
 167                 return false;
 168 
 169             result = offset;
 170             m_offset = offset + size;
 171             return true;
 172         }
 173 
 174         uint8_t* buffer() const { return m_buffer.get(); }
 175         size_t size() const { return static_cast&lt;size_t&gt;(m_offset); }
 176 
 177         bool getOffset(const void* address, ptrdiff_t&amp; result) const
 178         {
 179             const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(address);
 180             if (addr &gt;= m_buffer.get() &amp;&amp; addr &lt; m_buffer.get() + m_offset) {
 181                 result = addr - m_buffer.get();
 182                 return true;
 183             }
 184             return false;
 185         }
 186 









 187     private:
 188         MallocPtr&lt;uint8_t&gt; m_buffer;
 189         ptrdiff_t m_offset;
 190         size_t m_capacity;
 191     };
 192 
 193     void allocateNewPage(size_t size = 0)
 194     {
<span class="line-modified"> 195         static size_t minPageSize = WTF::pageSize();</span>
<span class="line-modified"> 196         if (m_currentPage)</span>

 197             m_baseOffset += m_currentPage-&gt;size();

 198         if (size &lt; minPageSize)
 199             size = minPageSize;
 200         else
<span class="line-modified"> 201             size = WTF::roundUpToMultipleOf(minPageSize, size);</span>
 202         m_pages.append(Page { size });
 203         m_currentPage = &amp;m_pages.last();
 204     }
 205 
 206     VM&amp; m_vm;

 207     ptrdiff_t m_baseOffset;
 208     Page* m_currentPage;
 209     Vector&lt;Page&gt; m_pages;
 210     HashMap&lt;const void*, ptrdiff_t&gt; m_ptrToOffsetMap;

 211 };
 212 
<span class="line-modified"> 213 class Decoder {</span>
<span class="line-modified"> 214     WTF_MAKE_NONCOPYABLE(Decoder);</span>
<span class="line-modified"> 215     WTF_FORBID_HEAP_ALLOCATION;</span>



 216 
<span class="line-modified"> 217 public:</span>
<span class="line-modified"> 218     Decoder(VM&amp; vm, const void* baseAddress, size_t size)</span>
<span class="line-modified"> 219         : m_vm(vm)</span>
<span class="line-modified"> 220         , m_baseAddress(reinterpret_cast&lt;const uint8_t*&gt;(baseAddress))</span>
<span class="line-modified"> 221 #ifndef NDEBUG</span>
<span class="line-removed"> 222         , m_size(size)</span>
<span class="line-removed"> 223 #endif</span>
<span class="line-removed"> 224     {</span>
<span class="line-removed"> 225         UNUSED_PARAM(size);</span>
<span class="line-removed"> 226     }</span>
 227 
<span class="line-modified"> 228     ~Decoder()</span>
<span class="line-modified"> 229     {</span>
<span class="line-modified"> 230         for (auto&amp; pair : m_finalizers)</span>
<span class="line-modified"> 231             pair.value();</span>
<span class="line-removed"> 232     }</span>
 233 
<span class="line-modified"> 234     VM&amp; vm() { return m_vm; }</span>



 235 
<span class="line-modified"> 236     ptrdiff_t offsetOf(const void* ptr)</span>
<span class="line-modified"> 237     {</span>
<span class="line-modified"> 238         const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(ptr);</span>
<span class="line-modified"> 239         ASSERT(addr &gt;= m_baseAddress &amp;&amp; addr &lt; m_baseAddress + m_size);</span>
<span class="line-modified"> 240         return addr - m_baseAddress;</span>
<span class="line-modified"> 241     }</span>
 242 
<span class="line-modified"> 243     void cacheOffset(ptrdiff_t offset, void* ptr)</span>
<span class="line-modified"> 244     {</span>
<span class="line-modified"> 245         m_offsetToPtrMap.add(offset, ptr);</span>
<span class="line-modified"> 246     }</span>
 247 
<span class="line-modified"> 248     WTF::Optional&lt;void*&gt; ptrForOffset(ptrdiff_t offset)</span>
<span class="line-modified"> 249     {</span>
<span class="line-modified"> 250         auto it = m_offsetToPtrMap.find(offset);</span>
<span class="line-modified"> 251         if (it == m_offsetToPtrMap.end())</span>
<span class="line-modified"> 252             return WTF::nullopt;</span>
<span class="line-modified"> 253         return { it-&gt;value };</span>
<span class="line-modified"> 254     }</span>
 255 
<span class="line-modified"> 256     template&lt;typename Functor&gt;</span>
<span class="line-modified"> 257     void addFinalizer(ptrdiff_t offset, const Functor&amp; fn)</span>
<span class="line-modified"> 258     {</span>
<span class="line-modified"> 259         m_finalizers.add(offset, fn);</span>
<span class="line-modified"> 260     }</span>
 261 
<span class="line-modified"> 262 private:</span>
<span class="line-modified"> 263     VM&amp; m_vm;</span>
<span class="line-modified"> 264     const uint8_t* m_baseAddress;</span>
<span class="line-modified"> 265 #ifndef NDEBUG</span>
<span class="line-modified"> 266     size_t m_size;</span>
<span class="line-modified"> 267 #endif</span>
<span class="line-modified"> 268     HashMap&lt;ptrdiff_t, void*&gt; m_offsetToPtrMap;</span>
<span class="line-modified"> 269     HashMap&lt;ptrdiff_t, std::function&lt;void()&gt;&gt; m_finalizers;</span>
<span class="line-modified"> 270 };</span>



















 271 
 272 template&lt;typename T&gt;
 273 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; encode(Encoder&amp;, T&amp; dst, const SourceType&lt;T&gt;&amp; src)
 274 {
 275     dst = src;
 276 }
 277 
 278 template&lt;typename T&gt;
 279 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; encode(Encoder&amp; encoder, T&amp; dst, const SourceType&lt;T&gt;&amp; src)
 280 {
 281     dst.encode(encoder, src);
 282 }
 283 
 284 template&lt;typename T, typename... Args&gt;
 285 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; decode(Decoder&amp;, const T&amp; src, SourceType&lt;T&gt;&amp; dst, Args...)
 286 {
 287     dst = src;
 288 }
 289 
 290 template&lt;typename T, typename... Args&gt;
</pre>
<hr />
<pre>
 298 {
 299     return src;
 300 }
 301 
 302 template&lt;typename T&gt;
 303 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value, SourceType&lt;T&gt;&gt;&amp;&amp; decode(Decoder&amp; decoder, const T&amp; src)
 304 {
 305     return src.decode(decoder);
 306 }
 307 
 308 template&lt;typename Source&gt;
 309 class CachedObject {
 310     WTF_MAKE_NONCOPYABLE(CachedObject&lt;Source&gt;);
 311 
 312 public:
 313     using SourceType_ = Source;
 314 
 315     CachedObject() = default;
 316 
 317     inline void* operator new(size_t, void* where) { return where; }

 318 
 319     // Copied from WTF_FORBID_HEAP_ALLOCATION, since we only want to allow placement new
<span class="line-removed"> 320     void* operator new[](size_t, void*) = delete;</span>
 321     void* operator new(size_t) = delete;
 322     void operator delete(void*) = delete;
 323     void* operator new[](size_t size) = delete;
 324     void operator delete[](void*) = delete;
 325     void* operator new(size_t, NotNullTag, void* location) = delete;
 326 };
 327 
 328 template&lt;typename Source&gt;
<span class="line-modified"> 329 class VariableLengthObject : public CachedObject&lt;Source&gt; {</span>
 330     template&lt;typename, typename&gt;
<span class="line-modified"> 331     friend struct CachedPtr;</span>












 332 
 333 protected:
 334     const uint8_t* buffer() const
 335     {
<span class="line-modified"> 336         ASSERT(m_offset != s_invalidOffset);</span>
<span class="line-modified"> 337         return reinterpret_cast&lt;const uint8_t*&gt;(this) + m_offset;</span>
 338     }
 339 
 340     template&lt;typename T&gt;
 341     const T* buffer() const
 342     {

 343         return bitwise_cast&lt;const T*&gt;(buffer());
 344     }
 345 
 346     uint8_t* allocate(Encoder&amp; encoder, size_t size)
 347     {
 348         ptrdiff_t offsetOffset = encoder.offsetOf(&amp;m_offset);
 349         auto result = encoder.malloc(size);
 350         m_offset = result.offset() - offsetOffset;
 351         return result.buffer();
 352     }
 353 
 354     template&lt;typename T&gt;





 355     T* allocate(Encoder&amp; encoder, unsigned size = 1)
 356     {
 357         uint8_t* result = allocate(encoder, sizeof(T) * size);
<span class="line-modified"> 358         return new (result) T();</span>

 359     }
 360 
 361 private:
 362     constexpr static ptrdiff_t s_invalidOffset = std::numeric_limits&lt;ptrdiff_t&gt;::max();
<span class="line-removed"> 363 </span>
<span class="line-removed"> 364     ptrdiff_t m_offset { s_invalidOffset };</span>
<span class="line-removed"> 365 </span>
 366 };
 367 
 368 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 369 class CachedPtr : public VariableLengthObject&lt;Source*&gt; {
 370     template&lt;typename, typename&gt;
<span class="line-modified"> 371     friend struct CachedRefPtr;</span>


 372 
 373 public:
 374     void encode(Encoder&amp; encoder, const Source* src)
 375     {
<span class="line-modified"> 376         m_isEmpty = !src;</span>
<span class="line-removed"> 377         if (m_isEmpty)</span>
 378             return;
 379 
<span class="line-modified"> 380         if (WTF::Optional&lt;ptrdiff_t&gt; offset = encoder.offsetForPtr(src)) {</span>
 381             this-&gt;m_offset = *offset - encoder.offsetOf(&amp;this-&gt;m_offset);
 382             return;
 383         }
 384 
 385         T* cachedObject = this-&gt;template allocate&lt;T&gt;(encoder);
 386         cachedObject-&gt;encode(encoder, *src);
 387         encoder.cachePtr(src, encoder.offsetOf(cachedObject));
 388     }
 389 
 390     template&lt;typename... Args&gt;
<span class="line-modified"> 391     Source* decode(Decoder&amp; decoder, Args... args) const</span>
 392     {
<span class="line-modified"> 393         if (m_isEmpty)</span>

 394             return nullptr;

 395 
 396         ptrdiff_t bufferOffset = decoder.offsetOf(this-&gt;buffer());
<span class="line-modified"> 397         if (WTF::Optional&lt;void*&gt; ptr = decoder.ptrForOffset(bufferOffset))</span>
<span class="line-modified"> 398             return reinterpret_cast&lt;Source*&gt;(*ptr);</span>


 399 
<span class="line-modified"> 400         Source* ptr = get()-&gt;decode(decoder, args...);</span>

 401         decoder.cacheOffset(bufferOffset, ptr);
 402         return ptr;
 403     }
 404 







 405     const T* operator-&gt;() const { return get(); }
 406 
 407 private:
 408     const T* get() const
 409     {
<span class="line-modified"> 410         if (m_isEmpty)</span>
<span class="line-removed"> 411             return nullptr;</span>
 412         return this-&gt;template buffer&lt;T&gt;();
 413     }
<span class="line-removed"> 414 </span>
<span class="line-removed"> 415     bool m_isEmpty;</span>
<span class="line-removed"> 416 </span>
 417 };
 418 





 419 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 420 class CachedRefPtr : public CachedObject&lt;RefPtr&lt;Source&gt;&gt; {
 421 public:
 422     void encode(Encoder&amp; encoder, const Source* src)
 423     {
 424         m_ptr.encode(encoder, src);
 425     }
 426 
 427     void encode(Encoder&amp; encoder, const RefPtr&lt;Source&gt; src)
 428     {
 429         encode(encoder, src.get());
 430     }
 431 
 432     RefPtr&lt;Source&gt; decode(Decoder&amp; decoder) const
 433     {
<span class="line-modified"> 434         Source* decodedPtr = m_ptr.decode(decoder);</span>

 435         if (!decodedPtr)
 436             return nullptr;
<span class="line-modified"> 437         decoder.addFinalizer(decoder.offsetOf(m_ptr.buffer()), [=] { derefIfNotNull(decodedPtr); });</span>




 438         refIfNotNull(decodedPtr);
 439         return adoptRef(decodedPtr);
 440     }
 441 
 442     void decode(Decoder&amp; decoder, RefPtr&lt;Source&gt;&amp; src) const
 443     {
 444         src = decode(decoder);
 445     }
 446 
 447 private:
 448     CachedPtr&lt;T, Source&gt; m_ptr;
 449 };
 450 
 451 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 452 class CachedWriteBarrier : public CachedObject&lt;WriteBarrier&lt;Source&gt;&gt; {


 453 public:


 454     void encode(Encoder&amp; encoder, const WriteBarrier&lt;Source&gt; src)
 455     {
 456         m_ptr.encode(encoder, src.get());
 457     }
 458 
 459     void decode(Decoder&amp; decoder, WriteBarrier&lt;Source&gt;&amp; src, const JSCell* owner) const
 460     {
 461         Source* decodedPtr = m_ptr.decode(decoder);
 462         if (decodedPtr)
 463             src.set(decoder.vm(), owner, decodedPtr);
 464     }
 465 
 466 private:
 467     CachedPtr&lt;T, Source&gt; m_ptr;
 468 };
 469 





 470 template&lt;typename T, size_t InlineCapacity = 0, typename OverflowHandler = CrashOnOverflow&gt;
 471 class CachedVector : public VariableLengthObject&lt;Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&gt; {
 472 public:
 473     void encode(Encoder&amp; encoder, const Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector)
 474     {
 475         m_size = vector.size();
 476         if (!m_size)
 477             return;
 478         T* buffer = this-&gt;template allocate&lt;T&gt;(encoder, m_size);
 479         for (unsigned i = 0; i &lt; m_size; ++i)
 480             ::JSC::encode(encoder, buffer[i], vector[i]);
 481     }
 482 
 483     template&lt;typename... Args&gt;
 484     void decode(Decoder&amp; decoder, Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector, Args... args) const
 485     {
 486         if (!m_size)
 487             return;
 488         vector.resizeToFit(m_size);
 489         const T* buffer = this-&gt;template buffer&lt;T&gt;();
</pre>
<hr />
<pre>
 525     {
 526         SourceType&lt;decltype(m_entries)&gt; entriesVector(map.size());
 527         unsigned i = 0;
 528         for (const auto&amp; it : map)
 529             entriesVector[i++] = { it.key, it.value };
 530         m_entries.encode(encoder, entriesVector);
 531     }
 532 
 533     void decode(Decoder&amp; decoder, Map&lt;SourceType&lt;Key&gt;, SourceType&lt;Value&gt;&gt;&amp; map) const
 534     {
 535         SourceType&lt;decltype(m_entries)&gt; decodedEntries;
 536         m_entries.decode(decoder, decodedEntries);
 537         for (const auto&amp; pair : decodedEntries)
 538             map.set(pair.first, pair.second);
 539     }
 540 
 541 private:
 542     CachedVector&lt;CachedPair&lt;Key, Value&gt;&gt; m_entries;
 543 };
 544 
<span class="line-modified"> 545 class CachedUniquedStringImpl : public VariableLengthObject&lt;UniquedStringImpl&gt; {</span>

 546 public:
 547     void encode(Encoder&amp; encoder, const StringImpl&amp; string)
 548     {
<span class="line-modified"> 549         m_isAtomic = string.isAtomic();</span>
 550         m_isSymbol = string.isSymbol();
 551         RefPtr&lt;StringImpl&gt; impl = const_cast&lt;StringImpl*&gt;(&amp;string);
 552 
 553         if (m_isSymbol) {
 554             SymbolImpl* symbol = static_cast&lt;SymbolImpl*&gt;(impl.get());
 555             if (!symbol-&gt;isNullSymbol()) {
 556                 // We have special handling for well-known symbols.
 557                 if (!symbol-&gt;isPrivate())
 558                     impl = encoder.vm().propertyNames-&gt;getPublicName(encoder.vm(), symbol).impl();
 559             }
 560         }
 561 
 562         m_is8Bit = impl-&gt;is8Bit();
 563         m_length = impl-&gt;length();
 564 
 565         if (!m_length)
 566             return;
 567 
 568         unsigned size = m_length;
 569         const void* payload;
 570         if (m_is8Bit)
 571             payload = impl-&gt;characters8();
 572         else {
 573             payload = impl-&gt;characters16();
 574             size *= 2;
 575         }
 576 
 577         uint8_t* buffer = this-&gt;allocate(encoder, size);
 578         memcpy(buffer, payload, size);
 579     }
 580 
 581     UniquedStringImpl* decode(Decoder&amp; decoder) const
 582     {
 583         auto create = [&amp;](const auto* buffer) -&gt; UniquedStringImpl* {
 584             if (!m_isSymbol)
<span class="line-modified"> 585                 return AtomicStringImpl::add(buffer, m_length).leakRef();</span>
 586 
<span class="line-modified"> 587             Identifier ident = Identifier::fromString(&amp;decoder.vm(), buffer, m_length);</span>
 588             String str = decoder.vm().propertyNames-&gt;lookUpPrivateName(ident);
 589             StringImpl* impl = str.releaseImpl().get();
 590             ASSERT(impl-&gt;isSymbol());
 591             return static_cast&lt;UniquedStringImpl*&gt;(impl);
 592         };
 593 
 594         if (!m_length) {
 595             if (m_isSymbol)
 596                 return &amp;SymbolImpl::createNullSymbol().leakRef();
<span class="line-modified"> 597             return AtomicStringImpl::add(&quot;&quot;).leakRef();</span>
 598         }
 599 
 600         if (m_is8Bit)
<span class="line-modified"> 601             return create(this-&gt;buffer&lt;LChar&gt;());</span>
<span class="line-modified"> 602         return create(this-&gt;buffer&lt;UChar&gt;());</span>
 603     }
 604 
 605 private:
 606     bool m_is8Bit : 1;
 607     bool m_isSymbol : 1;
 608     bool m_isAtomic : 1;
 609     unsigned m_length;
 610 };
 611 
<span class="line-modified"> 612 class CachedStringImpl : public VariableLengthObject&lt;StringImpl&gt; {</span>
<span class="line-modified"> 613 public:</span>
<span class="line-removed"> 614     void encode(Encoder&amp; encoder, const StringImpl&amp; impl)</span>
<span class="line-removed"> 615     {</span>
<span class="line-removed"> 616         m_uniquedStringImpl.encode(encoder, impl);</span>
<span class="line-removed"> 617     }</span>
<span class="line-removed"> 618 </span>
<span class="line-removed"> 619     StringImpl* decode(Decoder&amp; decoder) const</span>
<span class="line-removed"> 620     {</span>
<span class="line-removed"> 621         return m_uniquedStringImpl.decode(decoder);</span>
<span class="line-removed"> 622     }</span>
<span class="line-removed"> 623 </span>
<span class="line-removed"> 624 private:</span>
<span class="line-removed"> 625     CachedUniquedStringImpl m_uniquedStringImpl;</span>
<span class="line-removed"> 626 };</span>
 627 
 628 class CachedString : public VariableLengthObject&lt;String&gt; {
 629 public:
 630     void encode(Encoder&amp; encoder, const String&amp; string)
 631     {
 632         m_impl.encode(encoder, static_cast&lt;UniquedStringImpl*&gt;(string.impl()));
 633     }
 634 
 635     String decode(Decoder&amp; decoder) const
 636     {
 637         return String(static_cast&lt;RefPtr&lt;StringImpl&gt;&gt;(m_impl.decode(decoder)));
 638     }
 639 
 640     void decode(Decoder&amp; decoder, String&amp; dst) const
 641     {
 642         dst = decode(decoder);
 643     }
 644 
 645 private:
 646     CachedRefPtr&lt;CachedUniquedStringImpl&gt; m_impl;
 647 };
 648 
 649 class CachedIdentifier : public VariableLengthObject&lt;Identifier&gt; {
 650 public:
 651     void encode(Encoder&amp; encoder, const Identifier&amp; identifier)
 652     {
 653         m_string.encode(encoder, identifier.string());
 654     }
 655 
 656     Identifier decode(Decoder&amp; decoder) const
 657     {
 658         String str = m_string.decode(decoder);
 659         if (str.isNull())
 660             return Identifier();
 661 
<span class="line-modified"> 662         return Identifier::fromUid(&amp;decoder.vm(), (UniquedStringImpl*)str.impl());</span>
 663     }
 664 
 665     void decode(Decoder&amp; decoder, Identifier&amp; ident) const
 666     {
 667         ident = decode(decoder);
 668     }
 669 
 670 private:
 671     CachedString m_string;
 672 };
 673 
 674 template&lt;typename T&gt;
<span class="line-modified"> 675 class CachedOptional : public VariableLengthObject&lt;WTF::Optional&lt;SourceType&lt;T&gt;&gt;&gt; {</span>
 676 public:
<span class="line-modified"> 677     void encode(Encoder&amp; encoder, const WTF::Optional&lt;SourceType&lt;T&gt;&gt;&amp; source)</span>
 678     {
<span class="line-modified"> 679         m_isEmpty = !source;</span>
<span class="line-removed"> 680 </span>
<span class="line-removed"> 681         if (m_isEmpty)</span>
 682             return;
 683 
 684         this-&gt;template allocate&lt;T&gt;(encoder)-&gt;encode(encoder, *source);
 685     }
 686 
<span class="line-modified"> 687     WTF::Optional&lt;SourceType&lt;T&gt;&gt; decode(Decoder&amp; decoder) const</span>
 688     {
<span class="line-modified"> 689         if (m_isEmpty)</span>
 690             return WTF::nullopt;
 691 
 692         return { this-&gt;template buffer&lt;T&gt;()-&gt;decode(decoder) };
 693     }
 694 
<span class="line-modified"> 695     void decode(Decoder&amp; decoder, WTF::Optional&lt;SourceType&lt;T&gt;&gt;&amp; dst) const</span>
 696     {
 697         dst = decode(decoder);
 698     }
 699 
 700     void encode(Encoder&amp; encoder, const std::unique_ptr&lt;SourceType&lt;T&gt;&gt;&amp; source)
 701     {
 702         if (!source)
 703             encode(encoder, WTF::nullopt);
 704         else
 705             encode(encoder, { *source });
 706     }
<span class="line-removed"> 707 </span>
<span class="line-removed"> 708     SourceType&lt;T&gt;* decodeAsPtr(Decoder&amp; decoder) const</span>
<span class="line-removed"> 709     {</span>
<span class="line-removed"> 710         if (m_isEmpty)</span>
<span class="line-removed"> 711             return nullptr;</span>
<span class="line-removed"> 712 </span>
<span class="line-removed"> 713         return this-&gt;template buffer&lt;T&gt;()-&gt;decode(decoder);</span>
<span class="line-removed"> 714     }</span>
<span class="line-removed"> 715 </span>
<span class="line-removed"> 716 private:</span>
<span class="line-removed"> 717     bool m_isEmpty;</span>
 718 };
 719 
 720 class CachedSimpleJumpTable : public CachedObject&lt;UnlinkedSimpleJumpTable&gt; {
 721 public:
 722     void encode(Encoder&amp; encoder, const UnlinkedSimpleJumpTable&amp; jumpTable)
 723     {
 724         m_min = jumpTable.min;
 725         m_branchOffsets.encode(encoder, jumpTable.branchOffsets);
 726     }
 727 
 728     void decode(Decoder&amp; decoder, UnlinkedSimpleJumpTable&amp; jumpTable) const
 729     {
 730         jumpTable.min = m_min;
 731         m_branchOffsets.decode(decoder, jumpTable.branchOffsets);
 732     }
 733 
 734 private:
 735     int32_t m_min;
 736     CachedVector&lt;int32_t&gt; m_branchOffsets;
 737 };
</pre>
<hr />
<pre>
 861 
 862 class CachedVariableEnvironment : public CachedObject&lt;VariableEnvironment&gt; {
 863 public:
 864     void encode(Encoder&amp; encoder, const VariableEnvironment&amp; env)
 865     {
 866         m_isEverythingCaptured = env.m_isEverythingCaptured;
 867         m_map.encode(encoder, env.m_map);
 868     }
 869 
 870     void decode(Decoder&amp; decoder, VariableEnvironment&amp; env) const
 871     {
 872         env.m_isEverythingCaptured = m_isEverythingCaptured;
 873         m_map.decode(decoder, env.m_map);
 874     }
 875 
 876 private:
 877     bool m_isEverythingCaptured;
 878     CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, VariableEnvironmentEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntryHashTraits&gt; m_map;
 879 };
 880 

































































 881 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 882 class CachedArray : public VariableLengthObject&lt;Source*&gt; {
 883 public:
 884     void encode(Encoder&amp; encoder, const Source* array, unsigned size)
 885     {
 886         if (!size)
 887             return;
 888         T* dst = this-&gt;template allocate&lt;T&gt;(encoder, size);
 889         for (unsigned i = 0; i &lt; size; ++i)
 890             ::JSC::encode(encoder, dst[i], array[i]);
 891     }
 892 
 893     template&lt;typename... Args&gt;
 894     void decode(Decoder&amp; decoder, Source* array, unsigned size, Args... args) const
 895     {
 896         if (!size)
 897             return;
 898         const T* buffer = this-&gt;template buffer&lt;T&gt;();
 899         for (unsigned i = 0; i &lt; size; ++i)
 900             ::JSC::decode(decoder, buffer[i], array[i], args...);
 901     }
 902 };
 903 
 904 class CachedScopedArgumentsTable : public CachedObject&lt;ScopedArgumentsTable&gt; {
 905 public:
 906     void encode(Encoder&amp; encoder, const ScopedArgumentsTable&amp; scopedArgumentsTable)
 907     {
 908         m_length = scopedArgumentsTable.m_length;
<span class="line-modified"> 909         m_arguments.encode(encoder, scopedArgumentsTable.m_arguments.get(), m_length);</span>
 910     }
 911 
 912     ScopedArgumentsTable* decode(Decoder&amp; decoder) const
 913     {
 914         ScopedArgumentsTable* scopedArgumentsTable = ScopedArgumentsTable::create(decoder.vm(), m_length);
<span class="line-modified"> 915         m_arguments.decode(decoder, scopedArgumentsTable-&gt;m_arguments.get(), m_length);</span>
 916         return scopedArgumentsTable;
 917     }
 918 
 919 private:
 920     uint32_t m_length;
 921     CachedArray&lt;ScopeOffset&gt; m_arguments;
 922 };
 923 
 924 class CachedSymbolTableEntry : public CachedObject&lt;SymbolTableEntry&gt; {
 925 public:
 926     void encode(Encoder&amp;, const SymbolTableEntry&amp; symbolTableEntry)
 927     {
 928         m_bits = symbolTableEntry.m_bits | SymbolTableEntry::SlimFlag;
 929     }
 930 
 931     void decode(Decoder&amp;, SymbolTableEntry&amp; symbolTableEntry) const
 932     {
 933         symbolTableEntry.m_bits = m_bits;
 934     }
 935 
</pre>
<hr />
<pre>
1008         CachedArray&lt;CachedJSValue, WriteBarrier&lt;Unknown&gt;&gt; m_cachedValues;
1009     };
1010 };
1011 
1012 class CachedRegExp : public CachedObject&lt;RegExp&gt; {
1013 public:
1014     void encode(Encoder&amp; encoder, const RegExp&amp; regExp)
1015     {
1016         m_patternString.encode(encoder, regExp.m_patternString);
1017         m_flags = regExp.m_flags;
1018     }
1019 
1020     RegExp* decode(Decoder&amp; decoder) const
1021     {
1022         String pattern { m_patternString.decode(decoder) };
1023         return RegExp::create(decoder.vm(), pattern, m_flags);
1024     }
1025 
1026 private:
1027     CachedString m_patternString;
<span class="line-modified">1028     RegExpFlags m_flags;</span>
1029 };
1030 
1031 class CachedTemplateObjectDescriptor : public CachedObject&lt;TemplateObjectDescriptor&gt; {
1032 public:
<span class="line-modified">1033     void encode(Encoder&amp; encoder, const TemplateObjectDescriptor&amp; templateObjectDescriptor)</span>
1034     {
<span class="line-modified">1035         m_rawStrings.encode(encoder, templateObjectDescriptor.rawStrings());</span>
<span class="line-modified">1036         m_cookedStrings.encode(encoder, templateObjectDescriptor.cookedStrings());</span>

1037     }
1038 
<span class="line-modified">1039     Ref&lt;TemplateObjectDescriptor&gt; decode(Decoder&amp; decoder) const</span>
1040     {
1041         TemplateObjectDescriptor::StringVector decodedRawStrings;
1042         TemplateObjectDescriptor::OptionalStringVector decodedCookedStrings;
1043         m_rawStrings.decode(decoder, decodedRawStrings);
1044         m_cookedStrings.decode(decoder, decodedCookedStrings);
<span class="line-modified">1045         return TemplateObjectDescriptor::create(WTFMove(decodedRawStrings), WTFMove(decodedCookedStrings));</span>
1046     }
1047 
1048 private:
1049     CachedVector&lt;CachedString, 4&gt; m_rawStrings;
1050     CachedVector&lt;CachedOptional&lt;CachedString&gt;, 4&gt; m_cookedStrings;

1051 };
1052 
1053 class CachedBigInt : public VariableLengthObject&lt;JSBigInt&gt; {
1054 public:
1055     void encode(Encoder&amp; encoder, JSBigInt&amp; bigInt)
1056     {
1057         m_length = bigInt.length();
1058         m_sign = bigInt.sign();
1059 
1060         if (!m_length)
1061             return;
1062 
1063         unsigned size = sizeof(JSBigInt::Digit) * m_length;
1064         uint8_t* buffer = this-&gt;allocate(encoder, size);
1065         memcpy(buffer, bigInt.dataStorage(), size);
1066     }
1067 
1068     JSBigInt* decode(Decoder&amp; decoder) const
1069     {
1070         JSBigInt* bigInt = JSBigInt::createWithLengthUnchecked(decoder.vm(), m_length);
</pre>
<hr />
<pre>
1104             m_type = EncodedType::String;
1105             StringImpl* impl = string-&gt;tryGetValue().impl();
1106             this-&gt;allocate&lt;CachedUniquedStringImpl&gt;(encoder)-&gt;encode(encoder, *impl);
1107             return;
1108         }
1109 
1110         if (auto* immutableButterfly = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, cell)) {
1111             m_type = EncodedType::ImmutableButterfly;
1112             this-&gt;allocate&lt;CachedImmutableButterfly&gt;(encoder)-&gt;encode(encoder, *immutableButterfly);
1113             return;
1114         }
1115 
1116         if (auto* regexp = jsDynamicCast&lt;RegExp*&gt;(vm, cell)) {
1117             m_type = EncodedType::RegExp;
1118             this-&gt;allocate&lt;CachedRegExp&gt;(encoder)-&gt;encode(encoder, *regexp);
1119             return;
1120         }
1121 
1122         if (auto* templateObjectDescriptor = jsDynamicCast&lt;JSTemplateObjectDescriptor*&gt;(vm, cell)) {
1123             m_type = EncodedType::TemplateObjectDescriptor;
<span class="line-modified">1124             this-&gt;allocate&lt;CachedTemplateObjectDescriptor&gt;(encoder)-&gt;encode(encoder, templateObjectDescriptor-&gt;descriptor());</span>
1125             return;
1126         }
1127 
1128         if (auto* bigInt = jsDynamicCast&lt;JSBigInt*&gt;(vm, cell)) {
1129             m_type = EncodedType::BigInt;
1130             this-&gt;allocate&lt;CachedBigInt&gt;(encoder)-&gt;encode(encoder, *bigInt);
1131             return;
1132         }
1133 
1134         RELEASE_ASSERT_NOT_REACHED();
1135     }
1136 
1137     void decode(Decoder&amp; decoder, WriteBarrier&lt;Unknown&gt;&amp; value, const JSCell* owner) const
1138     {
1139         JSValue v;
1140         switch (m_type) {
1141         case EncodedType::JSValue:
1142             v = JSValue::decode(*this-&gt;buffer&lt;EncodedJSValue&gt;());
1143             break;
1144         case EncodedType::SymbolTable:
1145             v = this-&gt;buffer&lt;CachedSymbolTable&gt;()-&gt;decode(decoder);
1146             break;
1147         case EncodedType::String: {
1148             StringImpl* impl = this-&gt;buffer&lt;CachedUniquedStringImpl&gt;()-&gt;decode(decoder);
<span class="line-modified">1149             v = jsString(&amp;decoder.vm(), adoptRef(*impl));</span>
1150             break;
1151         }
1152         case EncodedType::ImmutableButterfly:
1153             v = this-&gt;buffer&lt;CachedImmutableButterfly&gt;()-&gt;decode(decoder);
1154             break;
1155         case EncodedType::RegExp:
1156             v = this-&gt;buffer&lt;CachedRegExp&gt;()-&gt;decode(decoder);
1157             break;
1158         case EncodedType::TemplateObjectDescriptor:
<span class="line-modified">1159             v = JSTemplateObjectDescriptor::create(decoder.vm(), this-&gt;buffer&lt;CachedTemplateObjectDescriptor&gt;()-&gt;decode(decoder));</span>
1160             break;
1161         case EncodedType::BigInt:
1162             v = this-&gt;buffer&lt;CachedBigInt&gt;()-&gt;decode(decoder);
1163             break;
1164         default:
1165             RELEASE_ASSERT_NOT_REACHED();
1166         }
1167         value.set(decoder.vm(), owner, v);
1168     }
1169 
1170 private:
1171     enum class EncodedType : uint8_t {
1172         JSValue,
1173         SymbolTable,
1174         String,
1175         ImmutableButterfly,
1176         RegExp,
1177         TemplateObjectDescriptor,
1178         BigInt,
1179     };
</pre>
<hr />
<pre>
1190 
1191     InstructionStream* decode(Decoder&amp; decoder) const
1192     {
1193         Vector&lt;uint8_t, 0, UnsafeVectorOverflow&gt; instructionsVector;
1194         m_instructions.decode(decoder, instructionsVector);
1195         return new InstructionStream(WTFMove(instructionsVector));
1196     }
1197 
1198 private:
1199     CachedVector&lt;uint8_t, 0, UnsafeVectorOverflow&gt; m_instructions;
1200 };
1201 
1202 class CachedMetadataTable : public CachedObject&lt;UnlinkedMetadataTable&gt; {
1203 public:
1204     void encode(Encoder&amp;, const UnlinkedMetadataTable&amp; metadataTable)
1205     {
1206         ASSERT(metadataTable.m_isFinalized);
1207         m_hasMetadata = metadataTable.m_hasMetadata;
1208         if (!m_hasMetadata)
1209             return;
<span class="line-modified">1210         for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="line-modified">1211             m_metadata[i] = metadataTable.buffer()[i];</span>






1212     }
1213 
1214     Ref&lt;UnlinkedMetadataTable&gt; decode(Decoder&amp;) const
1215     {
<span class="line-modified">1216         Ref&lt;UnlinkedMetadataTable&gt; metadataTable = UnlinkedMetadataTable::create();</span>



1217         metadataTable-&gt;m_isFinalized = true;
1218         metadataTable-&gt;m_isLinked = false;
1219         metadataTable-&gt;m_hasMetadata = m_hasMetadata;
<span class="line-modified">1220         for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="line-modified">1221             metadataTable-&gt;buffer()[i] = m_metadata[i];</span>





1222         return metadataTable;
1223     }
1224 
1225 private:
1226     bool m_hasMetadata;

1227     std::array&lt;unsigned, UnlinkedMetadataTable::s_offsetTableEntries&gt; m_metadata;
1228 };
1229 
1230 class CachedSourceOrigin : public CachedObject&lt;SourceOrigin&gt; {
1231 public:
1232     void encode(Encoder&amp; encoder, const SourceOrigin&amp; sourceOrigin)
1233     {
1234         m_string.encode(encoder, sourceOrigin.string());
1235     }
1236 
1237     SourceOrigin decode(Decoder&amp; decoder) const
1238     {
1239         return SourceOrigin { m_string.decode(decoder) };
1240     }
1241 
1242 private:
1243     CachedString m_string;
1244 };
1245 
1246 class CachedTextPosition : public CachedObject&lt;TextPosition&gt; {
</pre>
<hr />
<pre>
1370         case SourceProviderSourceType::Module:
1371             return this-&gt;buffer&lt;CachedStringSourceProvider&gt;()-&gt;decode(decoder, m_sourceType);
1372 #if ENABLE(WEBASSEMBLY)
1373         case SourceProviderSourceType::WebAssembly:
1374             return this-&gt;buffer&lt;CachedWebAssemblySourceProvider&gt;()-&gt;decode(decoder);
1375 #endif
1376         default:
1377             RELEASE_ASSERT_NOT_REACHED();
1378         }
1379     }
1380 
1381 private:
1382     SourceProviderSourceType m_sourceType;
1383 };
1384 
1385 template&lt;typename Source&gt;
1386 class CachedUnlinkedSourceCodeShape : public CachedObject&lt;Source&gt; {
1387 public:
1388     void encode(Encoder&amp; encoder, const UnlinkedSourceCode&amp; sourceCode)
1389     {
<span class="line-modified">1390         m_provider.encode(encoder, sourceCode.m_provider.get());</span>
1391         m_startOffset = sourceCode.startOffset();
1392         m_endOffset = sourceCode.endOffset();
1393     }
1394 
1395     void decode(Decoder&amp; decoder, UnlinkedSourceCode&amp; sourceCode) const
1396     {
1397         sourceCode.m_provider = m_provider.decode(decoder);
1398         sourceCode.m_startOffset = m_startOffset;
1399         sourceCode.m_endOffset = m_endOffset;
1400     }
1401 
1402 private:
<span class="line-modified">1403     CachedPtr&lt;CachedSourceProvider&gt; m_provider;</span>
1404     int m_startOffset;
1405     int m_endOffset;
1406 };
1407 
1408 
1409 class CachedUnlinkedSourceCode : public CachedUnlinkedSourceCodeShape&lt;UnlinkedSourceCode&gt; { };
1410 
1411 class CachedSourceCode : public CachedUnlinkedSourceCodeShape&lt;SourceCode&gt; {
1412     using Base = CachedUnlinkedSourceCodeShape&lt;SourceCode&gt;;
1413 
1414 public:
1415     void encode(Encoder&amp; encoder, const SourceCode&amp; sourceCode)
1416     {
1417         Base::encode(encoder, sourceCode);
1418         m_firstLine = sourceCode.firstLine().zeroBasedInt();
1419         m_startColumn = sourceCode.startColumn().zeroBasedInt();
1420     }
1421 
1422     void decode(Decoder&amp; decoder, SourceCode&amp; sourceCode) const
1423     {
1424         Base::decode(decoder, sourceCode);
1425         sourceCode.m_firstLine = OrdinalNumber::fromZeroBasedInt(m_firstLine);
1426         sourceCode.m_startColumn = OrdinalNumber::fromZeroBasedInt(m_startColumn);
1427     }
1428 
1429 private:
1430     int m_firstLine;
1431     int m_startColumn;
1432 };
1433 





























1434 class CachedFunctionExecutableRareData : public CachedObject&lt;UnlinkedFunctionExecutable::RareData&gt; {
1435 public:
1436     void encode(Encoder&amp; encoder, const UnlinkedFunctionExecutable::RareData&amp; rareData)
1437     {
1438         m_classSource.encode(encoder, rareData.m_classSource);

1439     }
1440 
1441     UnlinkedFunctionExecutable::RareData* decode(Decoder&amp; decoder) const
1442     {
1443         UnlinkedFunctionExecutable::RareData* rareData = new UnlinkedFunctionExecutable::RareData { };
1444         m_classSource.decode(decoder, rareData-&gt;m_classSource);


1445         return rareData;
1446     }
1447 
1448 private:
<span class="line-modified">1449     CachedSourceCode m_classSource;</span>

1450 };
1451 
1452 class CachedFunctionExecutable : public CachedObject&lt;UnlinkedFunctionExecutable&gt; {


1453 public:
1454     void encode(Encoder&amp;, const UnlinkedFunctionExecutable&amp;);
1455     UnlinkedFunctionExecutable* decode(Decoder&amp;) const;
1456 
1457     unsigned firstLineOffset() const { return m_firstLineOffset; }
1458     unsigned lineCount() const { return m_lineCount; }
1459     unsigned unlinkedFunctionNameStart() const { return m_unlinkedFunctionNameStart; }
1460     unsigned unlinkedBodyStartColumn() const { return m_unlinkedBodyStartColumn; }
1461     unsigned unlinkedBodyEndColumn() const { return m_unlinkedBodyEndColumn; }
1462     unsigned startOffset() const { return m_startOffset; }
1463     unsigned sourceLength() const { return m_sourceLength; }
1464     unsigned parametersStartOffset() const { return m_parametersStartOffset; }
1465     unsigned typeProfilingStartOffset() const { return m_typeProfilingStartOffset; }
1466     unsigned typeProfilingEndOffset() const { return m_typeProfilingEndOffset; }
1467     unsigned parameterCount() const { return m_parameterCount; }
1468 
<span class="line-modified">1469     CodeFeatures features() const { return m_features; }</span>
1470     SourceParseMode sourceParseMode() const { return m_sourceParseMode; }
1471 
1472     unsigned isInStrictContext() const { return m_isInStrictContext; }
<span class="line-modified">1473     unsigned hasCapturedVariables() const { return m_hasCapturedVariables; }</span>
1474     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1475     unsigned isBuiltinDefaultClassConstructor() const { return m_isBuiltinDefaultClassConstructor; }
1476     unsigned constructAbility() const { return m_constructAbility; }
1477     unsigned constructorKind() const { return m_constructorKind; }
1478     unsigned functionMode() const { return m_functionMode; }
1479     unsigned scriptMode() const { return m_scriptMode; }
1480     unsigned superBinding() const { return m_superBinding; }
1481     unsigned derivedContextType() const { return m_derivedContextType; }
1482 
1483     Identifier name(Decoder&amp; decoder) const { return m_name.decode(decoder); }
1484     Identifier ecmaName(Decoder&amp; decoder) const { return m_ecmaName.decode(decoder); }
<span class="line-removed">1485     Identifier inferredName(Decoder&amp; decoder) const { return m_inferredName.decode(decoder); }</span>
1486 
<span class="line-modified">1487     UnlinkedFunctionExecutable::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decodeAsPtr(decoder); }</span>



1488 
1489 private:
<span class="line-modified">1490     unsigned m_firstLineOffset;</span>
<span class="line-modified">1491     unsigned m_lineCount;</span>
<span class="line-modified">1492     unsigned m_unlinkedFunctionNameStart;</span>
<span class="line-removed">1493     unsigned m_unlinkedBodyStartColumn;</span>
<span class="line-removed">1494     unsigned m_unlinkedBodyEndColumn;</span>
<span class="line-removed">1495     unsigned m_startOffset;</span>
<span class="line-removed">1496     unsigned m_sourceLength;</span>
<span class="line-removed">1497     unsigned m_parametersStartOffset;</span>
<span class="line-removed">1498     unsigned m_typeProfilingStartOffset;</span>
<span class="line-removed">1499     unsigned m_typeProfilingEndOffset;</span>
<span class="line-removed">1500     unsigned m_parameterCount;</span>
<span class="line-removed">1501     CodeFeatures m_features;</span>
<span class="line-removed">1502     SourceParseMode m_sourceParseMode;</span>
1503     unsigned m_isInStrictContext : 1;
<span class="line-modified">1504     unsigned m_hasCapturedVariables : 1;</span>
1505     unsigned m_isBuiltinFunction : 1;

1506     unsigned m_isBuiltinDefaultClassConstructor : 1;

1507     unsigned m_constructAbility: 1;
<span class="line-modified">1508     unsigned m_constructorKind : 2;</span>
<span class="line-modified">1509     unsigned m_functionMode : 2; // FunctionMode</span>
1510     unsigned m_scriptMode: 1; // JSParserScriptMode

1511     unsigned m_superBinding : 1;







1512     unsigned m_derivedContextType: 2;
1513 
<span class="line-modified">1514     CachedOptional&lt;CachedFunctionExecutableRareData&gt; m_rareData;</span>
1515 
1516     CachedIdentifier m_name;
1517     CachedIdentifier m_ecmaName;
<span class="line-removed">1518     CachedIdentifier m_inferredName;</span>
<span class="line-removed">1519 </span>
<span class="line-removed">1520     CachedVariableEnvironment m_parentScopeTDZVariables;</span>
1521 
1522     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForCall;
1523     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForConstruct;
1524 };
1525 















1526 template&lt;typename CodeBlockType&gt;
1527 class CachedCodeBlock : public CachedObject&lt;CodeBlockType&gt; {
1528 public:
1529     void encode(Encoder&amp;, const UnlinkedCodeBlock&amp;);
1530     void decode(Decoder&amp;, UnlinkedCodeBlock&amp;) const;
1531 
1532     InstructionStream* instructions(Decoder&amp; decoder) const { return m_instructions.decode(decoder); }
1533 
1534     VirtualRegister thisRegister() const { return m_thisRegister; }
1535     VirtualRegister scopeRegister() const { return m_scopeRegister; }
1536 
1537     String sourceURLDirective(Decoder&amp; decoder) const { return m_sourceURLDirective.decode(decoder); }
1538     String sourceMappingURLDirective(Decoder&amp; decoder) const { return m_sourceMappingURLDirective.decode(decoder); }
1539 
1540     Ref&lt;UnlinkedMetadataTable&gt; metadata(Decoder&amp; decoder) const { return m_metadata.decode(decoder); }
1541 
1542     unsigned usesEval() const { return m_usesEval; }
1543     unsigned isStrictMode() const { return m_isStrictMode; }
1544     unsigned isConstructor() const { return m_isConstructor; }
1545     unsigned hasCapturedVariables() const { return m_hasCapturedVariables; }
1546     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1547     unsigned superBinding() const { return m_superBinding; }
1548     unsigned scriptMode() const { return m_scriptMode; }
1549     unsigned isArrowFunctionContext() const { return m_isArrowFunctionContext; }
1550     unsigned isClassContext() const { return m_isClassContext; }
<span class="line-removed">1551     unsigned wasCompiledWithDebuggingOpcodes() const { return m_wasCompiledWithDebuggingOpcodes; }</span>
1552     unsigned constructorKind() const { return m_constructorKind; }
1553     unsigned derivedContextType() const { return m_derivedContextType; }
1554     unsigned evalContextType() const { return m_evalContextType; }
1555     unsigned hasTailCalls() const { return m_hasTailCalls; }
1556     unsigned lineCount() const { return m_lineCount; }
1557     unsigned endColumn() const { return m_endColumn; }
1558 
1559     int numVars() const { return m_numVars; }
1560     int numCalleeLocals() const { return m_numCalleeLocals; }
1561     int numParameters() const { return m_numParameters; }
1562 
1563     CodeFeatures features() const { return m_features; }
1564     SourceParseMode parseMode() const { return m_parseMode; }

1565     unsigned codeType() const { return m_codeType; }
1566 
<span class="line-modified">1567     UnlinkedCodeBlock::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decodeAsPtr(decoder); }</span>
1568 
1569 private:
1570     VirtualRegister m_thisRegister;
1571     VirtualRegister m_scopeRegister;
1572     std::array&lt;unsigned, LinkTimeConstantCount&gt; m_linkTimeConstants;
1573 
1574     unsigned m_usesEval : 1;
1575     unsigned m_isStrictMode : 1;
1576     unsigned m_isConstructor : 1;
1577     unsigned m_hasCapturedVariables : 1;
1578     unsigned m_isBuiltinFunction : 1;
1579     unsigned m_superBinding : 1;
1580     unsigned m_scriptMode: 1;
1581     unsigned m_isArrowFunctionContext : 1;
1582     unsigned m_isClassContext : 1;
<span class="line-removed">1583     unsigned m_wasCompiledWithDebuggingOpcodes : 1;</span>
1584     unsigned m_constructorKind : 2;
1585     unsigned m_derivedContextType : 2;
1586     unsigned m_evalContextType : 2;
1587     unsigned m_hasTailCalls : 1;
1588     unsigned m_codeType : 2;
1589 
1590     CodeFeatures m_features;
1591     SourceParseMode m_parseMode;

1592 
1593     unsigned m_lineCount;
1594     unsigned m_endColumn;
1595 
1596     int m_numVars;
1597     int m_numCalleeLocals;
1598     int m_numParameters;
1599 
1600     CachedMetadataTable m_metadata;
1601 
<span class="line-modified">1602     CachedOptional&lt;CachedCodeBlockRareData&gt; m_rareData;</span>
1603 
1604     CachedString m_sourceURLDirective;
1605     CachedString m_sourceMappingURLDirective;
1606 
1607     CachedPtr&lt;CachedInstructionStream&gt; m_instructions;
1608     CachedVector&lt;InstructionStream::Offset&gt; m_jumpTargets;
1609     CachedVector&lt;InstructionStream::Offset&gt; m_propertyAccessInstructions;
1610     CachedVector&lt;CachedJSValue&gt; m_constantRegisters;
1611     CachedVector&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;
1612     CachedVector&lt;ExpressionRangeInfo&gt; m_expressionInfo;
1613     CachedHashMap&lt;InstructionStream::Offset, int&gt; m_outOfLineJumpTargets;
1614 
1615     CachedVector&lt;CachedIdentifier&gt; m_identifiers;
1616     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionDecls;
1617     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionExprs;
1618 };
1619 
1620 class CachedProgramCodeBlock : public CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt; {
1621     using Base = CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt;;
1622 
</pre>
<hr />
<pre>
1707         codeBlock-&gt;finishCreation(decoder.vm());
1708         Base::decode(decoder, *codeBlock);
1709         return codeBlock;
1710     }
1711 };
1712 
1713 ALWAYS_INLINE UnlinkedFunctionCodeBlock::UnlinkedFunctionCodeBlock(Decoder&amp; decoder, const CachedFunctionCodeBlock&amp; cachedCodeBlock)
1714     : Base(decoder, decoder.vm().unlinkedFunctionCodeBlockStructure.get(), cachedCodeBlock)
1715 {
1716 }
1717 
1718 template&lt;typename T&gt;
1719 struct CachedCodeBlockTypeImpl;
1720 
1721 enum CachedCodeBlockTag {
1722     CachedProgramCodeBlockTag,
1723     CachedModuleCodeBlockTag,
1724     CachedEvalCodeBlockTag,
1725 };
1726 
















1727 template&lt;&gt;
1728 struct CachedCodeBlockTypeImpl&lt;UnlinkedProgramCodeBlock&gt; {
1729     using type = CachedProgramCodeBlock;
1730     static constexpr CachedCodeBlockTag tag = CachedProgramCodeBlockTag;
1731 };
1732 
1733 template&lt;&gt;
1734 struct CachedCodeBlockTypeImpl&lt;UnlinkedModuleProgramCodeBlock&gt; {
1735     using type = CachedModuleCodeBlock;
1736     static constexpr CachedCodeBlockTag tag = CachedModuleCodeBlockTag;
1737 };
1738 
1739 template&lt;&gt;
1740 struct CachedCodeBlockTypeImpl&lt;UnlinkedEvalCodeBlock&gt; {
1741     using type = CachedEvalCodeBlock;
1742     static constexpr CachedCodeBlockTag tag = CachedEvalCodeBlockTag;
1743 };
1744 
1745 template&lt;typename T&gt;
1746 using CachedCodeBlockType = typename CachedCodeBlockTypeImpl&lt;T&gt;::type;
1747 
1748 template&lt;typename CodeBlockType&gt;
1749 ALWAYS_INLINE UnlinkedCodeBlock::UnlinkedCodeBlock(Decoder&amp; decoder, Structure* structure, const CachedCodeBlock&lt;CodeBlockType&gt;&amp; cachedCodeBlock)
1750     : Base(decoder.vm(), structure)
1751     , m_thisRegister(cachedCodeBlock.thisRegister())
1752     , m_scopeRegister(cachedCodeBlock.scopeRegister())
1753 
1754     , m_usesEval(cachedCodeBlock.usesEval())
1755     , m_isStrictMode(cachedCodeBlock.isStrictMode())
1756     , m_isConstructor(cachedCodeBlock.isConstructor())
1757     , m_hasCapturedVariables(cachedCodeBlock.hasCapturedVariables())
1758     , m_isBuiltinFunction(cachedCodeBlock.isBuiltinFunction())
1759     , m_superBinding(cachedCodeBlock.superBinding())
1760     , m_scriptMode(cachedCodeBlock.scriptMode())
1761     , m_isArrowFunctionContext(cachedCodeBlock.isArrowFunctionContext())
1762     , m_isClassContext(cachedCodeBlock.isClassContext())
<span class="line-modified">1763     , m_wasCompiledWithDebuggingOpcodes(cachedCodeBlock.wasCompiledWithDebuggingOpcodes())</span>
1764     , m_constructorKind(cachedCodeBlock.constructorKind())
1765     , m_derivedContextType(cachedCodeBlock.derivedContextType())
1766     , m_evalContextType(cachedCodeBlock.evalContextType())
<span class="line-removed">1767     , m_hasTailCalls(cachedCodeBlock.hasTailCalls())</span>
1768     , m_codeType(cachedCodeBlock.codeType())
1769 



1770     , m_features(cachedCodeBlock.features())
1771     , m_parseMode(cachedCodeBlock.parseMode())

1772 
1773     , m_lineCount(cachedCodeBlock.lineCount())
1774     , m_endColumn(cachedCodeBlock.endColumn())
1775     , m_numVars(cachedCodeBlock.numVars())
1776     , m_numCalleeLocals(cachedCodeBlock.numCalleeLocals())
1777     , m_numParameters(cachedCodeBlock.numParameters())
1778 
1779     , m_sourceURLDirective(cachedCodeBlock.sourceURLDirective(decoder))
1780     , m_sourceMappingURLDirective(cachedCodeBlock.sourceMappingURLDirective(decoder))
1781 
1782     , m_metadata(cachedCodeBlock.metadata(decoder))
1783     , m_instructions(cachedCodeBlock.instructions(decoder))
1784 
1785     , m_rareData(cachedCodeBlock.rareData(decoder))
1786 {
1787 }
1788 
1789 template&lt;typename CodeBlockType&gt;
1790 ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::decode(Decoder&amp; decoder, UnlinkedCodeBlock&amp; codeBlock) const
1791 {
</pre>
<hr />
<pre>
1803     m_functionExprs.decode(decoder, codeBlock.m_functionExprs, &amp;codeBlock);
1804 }
1805 
1806 ALWAYS_INLINE UnlinkedProgramCodeBlock::UnlinkedProgramCodeBlock(Decoder&amp; decoder, const CachedProgramCodeBlock&amp; cachedCodeBlock)
1807     : Base(decoder, decoder.vm().unlinkedProgramCodeBlockStructure.get(), cachedCodeBlock)
1808 {
1809 }
1810 
1811 ALWAYS_INLINE UnlinkedModuleProgramCodeBlock::UnlinkedModuleProgramCodeBlock(Decoder&amp; decoder, const CachedModuleCodeBlock&amp; cachedCodeBlock)
1812     : Base(decoder, decoder.vm().unlinkedModuleProgramCodeBlockStructure.get(), cachedCodeBlock)
1813 {
1814 }
1815 
1816 ALWAYS_INLINE UnlinkedEvalCodeBlock::UnlinkedEvalCodeBlock(Decoder&amp; decoder, const CachedEvalCodeBlock&amp; cachedCodeBlock)
1817     : Base(decoder, decoder.vm().unlinkedEvalCodeBlockStructure.get(), cachedCodeBlock)
1818 {
1819 }
1820 
1821 ALWAYS_INLINE void CachedFunctionExecutable::encode(Encoder&amp; encoder, const UnlinkedFunctionExecutable&amp; executable)
1822 {



1823     m_firstLineOffset = executable.m_firstLineOffset;
1824     m_lineCount = executable.m_lineCount;
1825     m_unlinkedFunctionNameStart = executable.m_unlinkedFunctionNameStart;
1826     m_unlinkedBodyStartColumn = executable.m_unlinkedBodyStartColumn;
1827     m_unlinkedBodyEndColumn = executable.m_unlinkedBodyEndColumn;
1828     m_startOffset = executable.m_startOffset;
1829     m_sourceLength = executable.m_sourceLength;
1830     m_parametersStartOffset = executable.m_parametersStartOffset;
1831     m_typeProfilingStartOffset = executable.m_typeProfilingStartOffset;
1832     m_typeProfilingEndOffset = executable.m_typeProfilingEndOffset;
1833     m_parameterCount = executable.m_parameterCount;
1834 
<span class="line-removed">1835     m_features = executable.m_features;</span>
1836     m_sourceParseMode = executable.m_sourceParseMode;
1837 
1838     m_isInStrictContext = executable.m_isInStrictContext;
<span class="line-removed">1839     m_hasCapturedVariables = executable.m_hasCapturedVariables;</span>
1840     m_isBuiltinFunction = executable.m_isBuiltinFunction;
1841     m_isBuiltinDefaultClassConstructor = executable.m_isBuiltinDefaultClassConstructor;
1842     m_constructAbility = executable.m_constructAbility;
1843     m_constructorKind = executable.m_constructorKind;
1844     m_functionMode = executable.m_functionMode;
1845     m_scriptMode = executable.m_scriptMode;
1846     m_superBinding = executable.m_superBinding;
1847     m_derivedContextType = executable.m_derivedContextType;
1848 
<span class="line-modified">1849     m_rareData.encode(encoder, executable.m_rareData);</span>
1850 
1851     m_name.encode(encoder, executable.name());
1852     m_ecmaName.encode(encoder, executable.ecmaName());
<span class="line-removed">1853     m_inferredName.encode(encoder, executable.inferredName());</span>
<span class="line-removed">1854 </span>
<span class="line-removed">1855     m_parentScopeTDZVariables.encode(encoder, executable.parentScopeTDZVariables());</span>
1856 
1857     m_unlinkedCodeBlockForCall.encode(encoder, executable.m_unlinkedCodeBlockForCall);
1858     m_unlinkedCodeBlockForConstruct.encode(encoder, executable.m_unlinkedCodeBlockForConstruct);



1859 }
1860 
1861 ALWAYS_INLINE UnlinkedFunctionExecutable* CachedFunctionExecutable::decode(Decoder&amp; decoder) const
1862 {
<span class="line-modified">1863     VariableEnvironment env;</span>
<span class="line-removed">1864     m_parentScopeTDZVariables.decode(decoder, env);</span>
<span class="line-removed">1865 </span>
<span class="line-removed">1866     UnlinkedFunctionExecutable* executable = new (NotNull, allocateCell&lt;UnlinkedFunctionExecutable&gt;(decoder.vm().heap)) UnlinkedFunctionExecutable(decoder, env, *this);</span>
1867     executable-&gt;finishCreation(decoder.vm());
<span class="line-removed">1868 </span>
<span class="line-removed">1869     m_unlinkedCodeBlockForCall.decode(decoder, executable-&gt;m_unlinkedCodeBlockForCall, executable);</span>
<span class="line-removed">1870     m_unlinkedCodeBlockForConstruct.decode(decoder, executable-&gt;m_unlinkedCodeBlockForConstruct, executable);</span>
<span class="line-removed">1871 </span>
1872     return executable;
1873 }
1874 
<span class="line-modified">1875 ALWAYS_INLINE UnlinkedFunctionExecutable::UnlinkedFunctionExecutable(Decoder&amp; decoder, VariableEnvironment&amp; parentScopeTDZVariables, const CachedFunctionExecutable&amp; cachedExecutable)</span>
1876     : Base(decoder.vm(), decoder.vm().unlinkedFunctionExecutableStructure.get())
1877     , m_firstLineOffset(cachedExecutable.firstLineOffset())

1878     , m_lineCount(cachedExecutable.lineCount())

1879     , m_unlinkedFunctionNameStart(cachedExecutable.unlinkedFunctionNameStart())

1880     , m_unlinkedBodyStartColumn(cachedExecutable.unlinkedBodyStartColumn())

1881     , m_unlinkedBodyEndColumn(cachedExecutable.unlinkedBodyEndColumn())

1882     , m_startOffset(cachedExecutable.startOffset())

1883     , m_sourceLength(cachedExecutable.sourceLength())

1884     , m_parametersStartOffset(cachedExecutable.parametersStartOffset())

1885     , m_typeProfilingStartOffset(cachedExecutable.typeProfilingStartOffset())
1886     , m_typeProfilingEndOffset(cachedExecutable.typeProfilingEndOffset())
1887     , m_parameterCount(cachedExecutable.parameterCount())
1888     , m_features(cachedExecutable.features())
1889     , m_sourceParseMode(cachedExecutable.sourceParseMode())
<span class="line-removed">1890     , m_isInStrictContext(cachedExecutable.isInStrictContext())</span>
<span class="line-removed">1891     , m_hasCapturedVariables(cachedExecutable.hasCapturedVariables())</span>
<span class="line-removed">1892     , m_isBuiltinFunction(cachedExecutable.isBuiltinFunction())</span>
<span class="line-removed">1893     , m_isBuiltinDefaultClassConstructor(cachedExecutable.isBuiltinDefaultClassConstructor())</span>
<span class="line-removed">1894     , m_constructAbility(cachedExecutable.constructAbility())</span>
1895     , m_constructorKind(cachedExecutable.constructorKind())
1896     , m_functionMode(cachedExecutable.functionMode())
<span class="line-removed">1897     , m_scriptMode(cachedExecutable.scriptMode())</span>
<span class="line-removed">1898     , m_superBinding(cachedExecutable.superBinding())</span>
1899     , m_derivedContextType(cachedExecutable.derivedContextType())



1900 
1901     , m_name(cachedExecutable.name(decoder))
1902     , m_ecmaName(cachedExecutable.ecmaName(decoder))
<span class="line-removed">1903     , m_inferredName(cachedExecutable.inferredName(decoder))</span>
<span class="line-removed">1904 </span>
<span class="line-removed">1905     , m_parentScopeTDZVariables(decoder.vm().m_compactVariableMap-&gt;get(parentScopeTDZVariables))</span>
1906 
1907     , m_rareData(cachedExecutable.rareData(decoder))
1908 {



























1909 }
1910 
1911 template&lt;typename CodeBlockType&gt;
1912 ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::encode(Encoder&amp; encoder, const UnlinkedCodeBlock&amp; codeBlock)
1913 {
1914     m_thisRegister = codeBlock.m_thisRegister;
1915     m_scopeRegister = codeBlock.m_scopeRegister;
1916     m_usesEval = codeBlock.m_usesEval;
1917     m_isStrictMode = codeBlock.m_isStrictMode;
1918     m_isConstructor = codeBlock.m_isConstructor;
1919     m_hasCapturedVariables = codeBlock.m_hasCapturedVariables;
1920     m_isBuiltinFunction = codeBlock.m_isBuiltinFunction;
1921     m_superBinding = codeBlock.m_superBinding;
1922     m_scriptMode = codeBlock.m_scriptMode;
1923     m_isArrowFunctionContext = codeBlock.m_isArrowFunctionContext;
1924     m_isClassContext = codeBlock.m_isClassContext;
<span class="line-modified">1925     m_wasCompiledWithDebuggingOpcodes = codeBlock.m_wasCompiledWithDebuggingOpcodes;</span>
1926     m_constructorKind = codeBlock.m_constructorKind;
1927     m_derivedContextType = codeBlock.m_derivedContextType;
1928     m_evalContextType = codeBlock.m_evalContextType;
<span class="line-removed">1929     m_hasTailCalls = codeBlock.m_hasTailCalls;</span>
1930     m_lineCount = codeBlock.m_lineCount;
1931     m_endColumn = codeBlock.m_endColumn;
1932     m_numVars = codeBlock.m_numVars;
1933     m_numCalleeLocals = codeBlock.m_numCalleeLocals;
1934     m_numParameters = codeBlock.m_numParameters;
1935     m_features = codeBlock.m_features;
1936     m_parseMode = codeBlock.m_parseMode;

1937     m_codeType = codeBlock.m_codeType;
1938 
1939     for (unsigned i = LinkTimeConstantCount; i--;)
1940         m_linkTimeConstants[i] = codeBlock.m_linkTimeConstants[i];
1941 
1942     m_metadata.encode(encoder, codeBlock.m_metadata.get());
<span class="line-modified">1943     m_rareData.encode(encoder, codeBlock.m_rareData);</span>
1944 
1945     m_sourceURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());
1946     m_sourceMappingURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());
1947 
1948     m_instructions.encode(encoder, codeBlock.m_instructions.get());
1949     m_propertyAccessInstructions.encode(encoder, codeBlock.m_propertyAccessInstructions);
1950     m_constantRegisters.encode(encoder, codeBlock.m_constantRegisters);
1951     m_constantsSourceCodeRepresentation.encode(encoder, codeBlock.m_constantsSourceCodeRepresentation);
1952     m_expressionInfo.encode(encoder, codeBlock.m_expressionInfo);
1953     m_jumpTargets.encode(encoder, codeBlock.m_jumpTargets);
1954     m_outOfLineJumpTargets.encode(encoder, codeBlock.m_outOfLineJumpTargets);
1955 
1956     m_identifiers.encode(encoder, codeBlock.m_identifiers);
1957     m_functionDecls.encode(encoder, codeBlock.m_functionDecls);
1958     m_functionExprs.encode(encoder, codeBlock.m_functionExprs);
1959 }
1960 
1961 class CachedSourceCodeKey : public CachedObject&lt;SourceCodeKey&gt; {
1962 public:
1963     void encode(Encoder&amp; encoder, const SourceCodeKey&amp; key)
</pre>
<hr />
<pre>
1972     void decode(Decoder&amp; decoder, SourceCodeKey&amp; key) const
1973     {
1974         m_sourceCode.decode(decoder, key.m_sourceCode);
1975         m_name.decode(decoder, key.m_name);
1976         key.m_flags.m_flags = m_flags;
1977         key.m_hash = m_hash;
1978         key.m_functionConstructorParametersEndPosition = m_functionConstructorParametersEndPosition;
1979     }
1980 
1981 private:
1982     CachedUnlinkedSourceCode m_sourceCode;
1983     CachedString m_name;
1984     unsigned m_flags;
1985     unsigned m_hash;
1986     int m_functionConstructorParametersEndPosition;
1987 };
1988 
1989 class GenericCacheEntry {
1990 public:
1991     bool decode(Decoder&amp;, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp;) const;

1992 
1993 protected:
1994     GenericCacheEntry(Encoder&amp; encoder, CachedCodeBlockTag tag)
1995         : m_tag(tag)
1996     {
1997         m_bootSessionUUID.encode(encoder, bootSessionUUIDString());
1998     }
1999 
2000     CachedCodeBlockTag tag() const { return m_tag; }
2001 









2002 private:
2003     uint32_t m_cacheVersion { JSC_BYTECODE_CACHE_VERSION };
2004     CachedString m_bootSessionUUID;
2005     CachedCodeBlockTag m_tag;
2006 };
2007 
2008 template&lt;typename UnlinkedCodeBlockType&gt;
2009 class CacheEntry : public GenericCacheEntry {
2010 public:
2011     CacheEntry(Encoder&amp; encoder)
2012         : GenericCacheEntry(encoder, CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag)
2013     {
2014     }
2015 
2016     void encode(Encoder&amp; encoder, std::pair&lt;SourceCodeKey, const UnlinkedCodeBlockType*&gt; pair)
2017     {
2018         m_key.encode(encoder, pair.first);
2019         m_codeBlock.encode(encoder, pair.second);
2020     }
2021 
2022 private:
2023     friend GenericCacheEntry;
2024 







2025     bool decode(Decoder&amp; decoder, std::pair&lt;SourceCodeKey, UnlinkedCodeBlockType*&gt;&amp; result) const
2026     {
2027         ASSERT(tag() == CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag);
2028         SourceCodeKey decodedKey;
2029         m_key.decode(decoder, decodedKey);
2030         result = { WTFMove(decodedKey), m_codeBlock.decode(decoder) };
2031         return true;
2032     }
2033 
2034     CachedSourceCodeKey m_key;
2035     CachedPtr&lt;CachedCodeBlockType&lt;UnlinkedCodeBlockType&gt;&gt; m_codeBlock;
2036 };
2037 
2038 bool GenericCacheEntry::decode(Decoder&amp; decoder, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp; result) const
2039 {
<span class="line-modified">2040     if (m_cacheVersion != JSC_BYTECODE_CACHE_VERSION)</span>
<span class="line-removed">2041         return false;</span>
<span class="line-removed">2042     if (m_bootSessionUUID.decode(decoder) != bootSessionUUIDString())</span>
2043         return false;
2044 
2045     switch (m_tag) {
2046     case CachedProgramCodeBlockTag:
<span class="line-modified">2047         return reinterpret_cast&lt;const CacheEntry&lt;UnlinkedProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedProgramCodeBlock*&gt;&amp;&gt;(result));</span>
2048     case CachedModuleCodeBlockTag:
<span class="line-modified">2049         return reinterpret_cast&lt;const CacheEntry&lt;UnlinkedModuleProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedModuleProgramCodeBlock*&gt;&amp;&gt;(result));</span>
2050     case CachedEvalCodeBlockTag:
2051         // We do not cache eval code blocks
2052         RELEASE_ASSERT_NOT_REACHED();
2053     }
2054     RELEASE_ASSERT_NOT_REACHED();
2055 #if COMPILER(MSVC)
2056     // Without this, MSVC will complain that this path does not return a value.
2057     return false;
2058 #endif
2059 }
2060 


















2061 template&lt;typename UnlinkedCodeBlockType&gt;
2062 void encodeCodeBlock(Encoder&amp; encoder, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)
2063 {
2064     auto* entry = encoder.template malloc&lt;CacheEntry&lt;UnlinkedCodeBlockType&gt;&gt;(encoder);
<span class="line-modified">2065     entry-&gt;encode(encoder,  { key, jsCast&lt;const UnlinkedCodeBlockType*&gt;(codeBlock) });</span>
2066 }
2067 
<span class="line-modified">2068 std::pair&lt;MallocPtr&lt;uint8_t&gt;, size_t&gt; encodeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)</span>
2069 {
2070     const ClassInfo* classInfo = codeBlock-&gt;classInfo(vm);
2071 
<span class="line-modified">2072     Encoder encoder(vm);</span>
2073     if (classInfo == UnlinkedProgramCodeBlock::info())
2074         encodeCodeBlock&lt;UnlinkedProgramCodeBlock&gt;(encoder, key, codeBlock);
2075     else if (classInfo == UnlinkedModuleProgramCodeBlock::info())
2076         encodeCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;(encoder, key, codeBlock);
2077     else
2078         ASSERT(classInfo == UnlinkedEvalCodeBlock::info());
2079 
<span class="line-modified">2080     return encoder.release();</span>













2081 }
2082 
<span class="line-modified">2083 UnlinkedCodeBlock* decodeCodeBlockImpl(VM&amp; vm, const SourceCodeKey&amp; key, const void* buffer, size_t size)</span>
2084 {
<span class="line-modified">2085     const auto* cachedEntry = reinterpret_cast&lt;const GenericCacheEntry*&gt;(buffer);</span>
<span class="line-modified">2086     Decoder decoder(vm, buffer, size);</span>
2087     std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt; entry;
2088     {
2089         DeferGC deferGC(vm.heap);
<span class="line-modified">2090         if (!cachedEntry-&gt;decode(decoder, entry))</span>
2091             return nullptr;
2092     }
2093 
2094     if (entry.first != key)
2095         return nullptr;
2096     return entry.second;
2097 }
2098 


















2099 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CachedTypes.h&quot;
  28 
<span class="line-added">  29 #include &quot;BytecodeCacheError.h&quot;</span>
  30 #include &quot;BytecodeCacheVersion.h&quot;
  31 #include &quot;BytecodeLivenessAnalysis.h&quot;
<span class="line-modified">  32 #include &quot;JSCInlines.h&quot;</span>
  33 #include &quot;JSImmutableButterfly.h&quot;
  34 #include &quot;JSTemplateObjectDescriptor.h&quot;
  35 #include &quot;ScopedArgumentsTable.h&quot;
  36 #include &quot;SourceCodeKey.h&quot;
<span class="line-added">  37 #include &quot;SourceProvider.h&quot;</span>
  38 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  39 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  40 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  41 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  42 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  43 #include &lt;wtf/FastMalloc.h&gt;

  44 #include &lt;wtf/Optional.h&gt;
  45 #include &lt;wtf/UUID.h&gt;
<span class="line-modified">  46 #include &lt;wtf/text/AtomStringImpl.h&gt;</span>
  47 
  48 namespace JSC {
  49 
<span class="line-added">  50 namespace Yarr {</span>
<span class="line-added">  51 enum class Flags : uint8_t;</span>
<span class="line-added">  52 }</span>
<span class="line-added">  53 </span>
  54 template &lt;typename T, typename = void&gt;
  55 struct SourceTypeImpl {
  56     using type = T;
  57 };
  58 
  59 template&lt;typename T&gt;
  60 struct SourceTypeImpl&lt;T, std::enable_if_t&lt;!std::is_fundamental&lt;T&gt;::value &amp;&amp; !std::is_same&lt;typename T::SourceType_, void&gt;::value&gt;&gt; {
  61     using type = typename T::SourceType_;
  62 
  63 };
  64 
  65 template&lt;typename T&gt;
  66 using SourceType = typename SourceTypeImpl&lt;T&gt;::type;
  67 
  68 class Encoder {
  69     WTF_MAKE_NONCOPYABLE(Encoder);
  70     WTF_FORBID_HEAP_ALLOCATION;
  71 
  72 public:
  73     class Allocation {
  74         friend class Encoder;
  75 
  76     public:
  77         uint8_t* buffer() const { return m_buffer; }
  78         ptrdiff_t offset() const { return m_offset; }
  79 
  80     private:
  81         Allocation(uint8_t* buffer, ptrdiff_t offset)
  82             : m_buffer(buffer)
  83             , m_offset(offset)
  84         {
  85         }
  86 
  87         uint8_t* m_buffer;
  88         ptrdiff_t m_offset;
  89     };
  90 
<span class="line-modified">  91     Encoder(VM&amp; vm, FileSystem::PlatformFileHandle fd = FileSystem::invalidPlatformFileHandle)</span>
  92         : m_vm(vm)
<span class="line-added">  93         , m_fd(fd)</span>
  94         , m_baseOffset(0)
  95         , m_currentPage(nullptr)
  96     {
  97         allocateNewPage();
  98     }
  99 
 100     VM&amp; vm() { return m_vm; }
 101 
 102     Allocation malloc(unsigned size)
 103     {
<span class="line-modified"> 104         RELEASE_ASSERT(size);</span>
 105         ptrdiff_t offset;
 106         if (m_currentPage-&gt;malloc(size, offset))
 107             return Allocation { m_currentPage-&gt;buffer() + offset, m_baseOffset + offset };
 108         allocateNewPage(size);
 109         return malloc(size);
 110     }
 111 
 112     template&lt;typename T, typename... Args&gt;
 113     T* malloc(Args&amp;&amp;... args)
 114     {
 115         return new (malloc(sizeof(T)).buffer()) T(std::forward&lt;Args&gt;(args)...);
 116     }
 117 
 118     ptrdiff_t offsetOf(const void* address)
 119     {
 120         ptrdiff_t offset;
 121         ptrdiff_t baseOffset = 0;
 122         for (const auto&amp; page : m_pages) {
 123             if (page.getOffset(address, offset))
 124                 return baseOffset + offset;
 125             baseOffset += page.size();
 126         }
 127         RELEASE_ASSERT_NOT_REACHED();
 128         return 0;
 129     }
 130 
 131     void cachePtr(const void* ptr, ptrdiff_t offset)
 132     {
 133         m_ptrToOffsetMap.add(ptr, offset);
 134     }
 135 
<span class="line-modified"> 136     Optional&lt;ptrdiff_t&gt; cachedOffsetForPtr(const void* ptr)</span>
 137     {
 138         auto it = m_ptrToOffsetMap.find(ptr);
 139         if (it == m_ptrToOffsetMap.end())
 140             return WTF::nullopt;
 141         return { it-&gt;value };
 142     }
 143 
<span class="line-modified"> 144     void addLeafExecutable(const UnlinkedFunctionExecutable* executable, ptrdiff_t offset)</span>
<span class="line-added"> 145     {</span>
<span class="line-added"> 146         m_leafExecutables.add(executable, offset);</span>
<span class="line-added"> 147     }</span>
<span class="line-added"> 148 </span>
<span class="line-added"> 149     RefPtr&lt;CachedBytecode&gt; release(BytecodeCacheError&amp; error)</span>
 150     {
<span class="line-added"> 151         if (!m_currentPage)</span>
<span class="line-added"> 152             return nullptr;</span>
<span class="line-added"> 153         m_currentPage-&gt;alignEnd();</span>
<span class="line-added"> 154 </span>
<span class="line-added"> 155         if (FileSystem::isHandleValid(m_fd)) {</span>
<span class="line-added"> 156             return releaseMapped(error);</span>
<span class="line-added"> 157         }</span>
<span class="line-added"> 158 </span>
 159         size_t size = m_baseOffset + m_currentPage-&gt;size();
 160         MallocPtr&lt;uint8_t&gt; buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);
 161         unsigned offset = 0;
 162         for (const auto&amp; page : m_pages) {
 163             memcpy(buffer.get() + offset, page.buffer(), page.size());
 164             offset += page.size();
 165         }
 166         RELEASE_ASSERT(offset == size);
<span class="line-modified"> 167         return CachedBytecode::create(WTFMove(buffer), size, WTFMove(m_leafExecutables));</span>
 168     }
 169 
 170 private:
<span class="line-added"> 171     RefPtr&lt;CachedBytecode&gt; releaseMapped(BytecodeCacheError&amp; error)</span>
<span class="line-added"> 172     {</span>
<span class="line-added"> 173         size_t size = m_baseOffset + m_currentPage-&gt;size();</span>
<span class="line-added"> 174         if (!FileSystem::truncateFile(m_fd, size)) {</span>
<span class="line-added"> 175             error = BytecodeCacheError::StandardError(errno);</span>
<span class="line-added"> 176             return nullptr;</span>
<span class="line-added"> 177         }</span>
<span class="line-added"> 178 </span>
<span class="line-added"> 179         for (const auto&amp; page : m_pages) {</span>
<span class="line-added"> 180             int bytesWritten = FileSystem::writeToFile(m_fd, reinterpret_cast&lt;char*&gt;(page.buffer()), page.size());</span>
<span class="line-added"> 181             if (bytesWritten == -1) {</span>
<span class="line-added"> 182                 error = BytecodeCacheError::StandardError(errno);</span>
<span class="line-added"> 183                 return nullptr;</span>
<span class="line-added"> 184             }</span>
<span class="line-added"> 185 </span>
<span class="line-added"> 186             if (static_cast&lt;size_t&gt;(bytesWritten) != page.size()) {</span>
<span class="line-added"> 187                 error = BytecodeCacheError::WriteError(bytesWritten, page.size());</span>
<span class="line-added"> 188                 return nullptr;</span>
<span class="line-added"> 189             }</span>
<span class="line-added"> 190         }</span>
<span class="line-added"> 191 </span>
<span class="line-added"> 192         bool success;</span>
<span class="line-added"> 193         FileSystem::MappedFileData mappedFileData(m_fd, FileSystem::MappedFileMode::Private, success);</span>
<span class="line-added"> 194         if (!success) {</span>
<span class="line-added"> 195             error = BytecodeCacheError::StandardError(errno);</span>
<span class="line-added"> 196             return nullptr;</span>
<span class="line-added"> 197         }</span>
<span class="line-added"> 198 </span>
<span class="line-added"> 199         return CachedBytecode::create(WTFMove(mappedFileData), WTFMove(m_leafExecutables));</span>
<span class="line-added"> 200     }</span>
<span class="line-added"> 201 </span>
 202     class Page {
 203     public:
 204         Page(size_t size)
 205             : m_offset(0)
 206             , m_capacity(size)
 207         {
 208             m_buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);
 209         }
 210 
 211         bool malloc(size_t size, ptrdiff_t&amp; result)
 212         {
 213             size_t alignment = std::min(alignof(std::max_align_t), static_cast&lt;size_t&gt;(WTF::roundUpToPowerOfTwo(size)));
<span class="line-modified"> 214             ptrdiff_t offset = roundUpToMultipleOf(alignment, m_offset);</span>
<span class="line-modified"> 215             size = roundUpToMultipleOf(alignment, size);</span>
 216             if (static_cast&lt;size_t&gt;(offset + size) &gt; m_capacity)
 217                 return false;
 218 
 219             result = offset;
 220             m_offset = offset + size;
 221             return true;
 222         }
 223 
 224         uint8_t* buffer() const { return m_buffer.get(); }
 225         size_t size() const { return static_cast&lt;size_t&gt;(m_offset); }
 226 
 227         bool getOffset(const void* address, ptrdiff_t&amp; result) const
 228         {
 229             const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(address);
 230             if (addr &gt;= m_buffer.get() &amp;&amp; addr &lt; m_buffer.get() + m_offset) {
 231                 result = addr - m_buffer.get();
 232                 return true;
 233             }
 234             return false;
 235         }
 236 
<span class="line-added"> 237         void alignEnd()</span>
<span class="line-added"> 238         {</span>
<span class="line-added"> 239             ptrdiff_t size = roundUpToMultipleOf(alignof(std::max_align_t), m_offset);</span>
<span class="line-added"> 240             if (size == m_offset)</span>
<span class="line-added"> 241                 return;</span>
<span class="line-added"> 242             RELEASE_ASSERT(static_cast&lt;size_t&gt;(size) &lt;= m_capacity);</span>
<span class="line-added"> 243             m_offset = size;</span>
<span class="line-added"> 244         }</span>
<span class="line-added"> 245 </span>
 246     private:
 247         MallocPtr&lt;uint8_t&gt; m_buffer;
 248         ptrdiff_t m_offset;
 249         size_t m_capacity;
 250     };
 251 
 252     void allocateNewPage(size_t size = 0)
 253     {
<span class="line-modified"> 254         static size_t minPageSize = pageSize();</span>
<span class="line-modified"> 255         if (m_currentPage) {</span>
<span class="line-added"> 256             m_currentPage-&gt;alignEnd();</span>
 257             m_baseOffset += m_currentPage-&gt;size();
<span class="line-added"> 258         }</span>
 259         if (size &lt; minPageSize)
 260             size = minPageSize;
 261         else
<span class="line-modified"> 262             size = roundUpToMultipleOf(minPageSize, size);</span>
 263         m_pages.append(Page { size });
 264         m_currentPage = &amp;m_pages.last();
 265     }
 266 
 267     VM&amp; m_vm;
<span class="line-added"> 268     FileSystem::PlatformFileHandle m_fd;</span>
 269     ptrdiff_t m_baseOffset;
 270     Page* m_currentPage;
 271     Vector&lt;Page&gt; m_pages;
 272     HashMap&lt;const void*, ptrdiff_t&gt; m_ptrToOffsetMap;
<span class="line-added"> 273     LeafExecutableMap m_leafExecutables;</span>
 274 };
 275 
<span class="line-modified"> 276 Decoder::Decoder(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, RefPtr&lt;SourceProvider&gt; provider)</span>
<span class="line-modified"> 277     : m_vm(vm)</span>
<span class="line-modified"> 278     , m_cachedBytecode(WTFMove(cachedBytecode))</span>
<span class="line-added"> 279     , m_provider(provider)</span>
<span class="line-added"> 280 {</span>
<span class="line-added"> 281 }</span>
 282 
<span class="line-modified"> 283 Decoder::~Decoder()</span>
<span class="line-modified"> 284 {</span>
<span class="line-modified"> 285     for (auto&amp; finalizer : m_finalizers)</span>
<span class="line-modified"> 286         finalizer();</span>
<span class="line-modified"> 287 }</span>





 288 
<span class="line-modified"> 289 Ref&lt;Decoder&gt; Decoder::create(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, RefPtr&lt;SourceProvider&gt; provider)</span>
<span class="line-modified"> 290 {</span>
<span class="line-modified"> 291     return adoptRef(*new Decoder(vm, WTFMove(cachedBytecode), WTFMove(provider)));</span>
<span class="line-modified"> 292 }</span>

 293 
<span class="line-modified"> 294 size_t Decoder::size() const</span>
<span class="line-added"> 295 {</span>
<span class="line-added"> 296     return m_cachedBytecode-&gt;size();</span>
<span class="line-added"> 297 }</span>
 298 
<span class="line-modified"> 299 ptrdiff_t Decoder::offsetOf(const void* ptr)</span>
<span class="line-modified"> 300 {</span>
<span class="line-modified"> 301     const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(ptr);</span>
<span class="line-modified"> 302     ASSERT(addr &gt;= m_cachedBytecode-&gt;data() &amp;&amp; addr &lt; m_cachedBytecode-&gt;data() + m_cachedBytecode-&gt;size());</span>
<span class="line-modified"> 303     return addr - m_cachedBytecode-&gt;data();</span>
<span class="line-modified"> 304 }</span>
 305 
<span class="line-modified"> 306 void Decoder::cacheOffset(ptrdiff_t offset, void* ptr)</span>
<span class="line-modified"> 307 {</span>
<span class="line-modified"> 308     m_offsetToPtrMap.add(offset, ptr);</span>
<span class="line-modified"> 309 }</span>
 310 
<span class="line-modified"> 311 WTF::Optional&lt;void*&gt; Decoder::cachedPtrForOffset(ptrdiff_t offset)</span>
<span class="line-modified"> 312 {</span>
<span class="line-modified"> 313     auto it = m_offsetToPtrMap.find(offset);</span>
<span class="line-modified"> 314     if (it == m_offsetToPtrMap.end())</span>
<span class="line-modified"> 315         return WTF::nullopt;</span>
<span class="line-modified"> 316     return { it-&gt;value };</span>
<span class="line-modified"> 317 }</span>
 318 
<span class="line-modified"> 319 const void* Decoder::ptrForOffsetFromBase(ptrdiff_t offset)</span>
<span class="line-modified"> 320 {</span>
<span class="line-modified"> 321     ASSERT(offset &gt; 0 &amp;&amp; static_cast&lt;size_t&gt;(offset) &lt; m_cachedBytecode-&gt;size());</span>
<span class="line-modified"> 322     return m_cachedBytecode-&gt;data() + offset;</span>
<span class="line-modified"> 323 }</span>
 324 
<span class="line-modified"> 325 CompactVariableMap::Handle Decoder::handleForEnvironment(CompactVariableEnvironment* environment) const</span>
<span class="line-modified"> 326 {</span>
<span class="line-modified"> 327     auto it = m_environmentToHandleMap.find(environment);</span>
<span class="line-modified"> 328     RELEASE_ASSERT(it != m_environmentToHandleMap.end());</span>
<span class="line-modified"> 329     return it-&gt;value;</span>
<span class="line-modified"> 330 }</span>
<span class="line-modified"> 331 </span>
<span class="line-modified"> 332 void Decoder::setHandleForEnvironment(CompactVariableEnvironment* environment, const CompactVariableMap::Handle&amp; handle)</span>
<span class="line-modified"> 333 {</span>
<span class="line-added"> 334     auto addResult = m_environmentToHandleMap.add(environment, handle);</span>
<span class="line-added"> 335     RELEASE_ASSERT(addResult.isNewEntry);</span>
<span class="line-added"> 336 }</span>
<span class="line-added"> 337 </span>
<span class="line-added"> 338 void Decoder::addLeafExecutable(const UnlinkedFunctionExecutable* executable, ptrdiff_t offset)</span>
<span class="line-added"> 339 {</span>
<span class="line-added"> 340     m_cachedBytecode-&gt;leafExecutables().add(executable, offset);</span>
<span class="line-added"> 341 }</span>
<span class="line-added"> 342 </span>
<span class="line-added"> 343 template&lt;typename Functor&gt;</span>
<span class="line-added"> 344 void Decoder::addFinalizer(const Functor&amp; fn)</span>
<span class="line-added"> 345 {</span>
<span class="line-added"> 346     m_finalizers.append(fn);</span>
<span class="line-added"> 347 }</span>
<span class="line-added"> 348 </span>
<span class="line-added"> 349 RefPtr&lt;SourceProvider&gt; Decoder::provider() const</span>
<span class="line-added"> 350 {</span>
<span class="line-added"> 351     return m_provider;</span>
<span class="line-added"> 352 }</span>
 353 
 354 template&lt;typename T&gt;
 355 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; encode(Encoder&amp;, T&amp; dst, const SourceType&lt;T&gt;&amp; src)
 356 {
 357     dst = src;
 358 }
 359 
 360 template&lt;typename T&gt;
 361 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; encode(Encoder&amp; encoder, T&amp; dst, const SourceType&lt;T&gt;&amp; src)
 362 {
 363     dst.encode(encoder, src);
 364 }
 365 
 366 template&lt;typename T, typename... Args&gt;
 367 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; decode(Decoder&amp;, const T&amp; src, SourceType&lt;T&gt;&amp; dst, Args...)
 368 {
 369     dst = src;
 370 }
 371 
 372 template&lt;typename T, typename... Args&gt;
</pre>
<hr />
<pre>
 380 {
 381     return src;
 382 }
 383 
 384 template&lt;typename T&gt;
 385 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value, SourceType&lt;T&gt;&gt;&amp;&amp; decode(Decoder&amp; decoder, const T&amp; src)
 386 {
 387     return src.decode(decoder);
 388 }
 389 
 390 template&lt;typename Source&gt;
 391 class CachedObject {
 392     WTF_MAKE_NONCOPYABLE(CachedObject&lt;Source&gt;);
 393 
 394 public:
 395     using SourceType_ = Source;
 396 
 397     CachedObject() = default;
 398 
 399     inline void* operator new(size_t, void* where) { return where; }
<span class="line-added"> 400     void* operator new[](size_t, void* where) { return where; }</span>
 401 
 402     // Copied from WTF_FORBID_HEAP_ALLOCATION, since we only want to allow placement new

 403     void* operator new(size_t) = delete;
 404     void operator delete(void*) = delete;
 405     void* operator new[](size_t size) = delete;
 406     void operator delete[](void*) = delete;
 407     void* operator new(size_t, NotNullTag, void* location) = delete;
 408 };
 409 
 410 template&lt;typename Source&gt;
<span class="line-modified"> 411 class VariableLengthObject : public CachedObject&lt;Source&gt;, VariableLengthObjectBase {</span>
 412     template&lt;typename, typename&gt;
<span class="line-modified"> 413     friend class CachedPtr;</span>
<span class="line-added"> 414     friend struct CachedPtrOffsets;</span>
<span class="line-added"> 415 </span>
<span class="line-added"> 416 public:</span>
<span class="line-added"> 417     VariableLengthObject()</span>
<span class="line-added"> 418         : VariableLengthObjectBase(s_invalidOffset)</span>
<span class="line-added"> 419     {</span>
<span class="line-added"> 420     }</span>
<span class="line-added"> 421 </span>
<span class="line-added"> 422     bool isEmpty() const</span>
<span class="line-added"> 423     {</span>
<span class="line-added"> 424         return m_offset == s_invalidOffset;</span>
<span class="line-added"> 425     }</span>
 426 
 427 protected:
 428     const uint8_t* buffer() const
 429     {
<span class="line-modified"> 430         ASSERT(!isEmpty());</span>
<span class="line-modified"> 431         return bitwise_cast&lt;const uint8_t*&gt;(this) + m_offset;</span>
 432     }
 433 
 434     template&lt;typename T&gt;
 435     const T* buffer() const
 436     {
<span class="line-added"> 437         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(buffer()) % alignof(T)));</span>
 438         return bitwise_cast&lt;const T*&gt;(buffer());
 439     }
 440 
 441     uint8_t* allocate(Encoder&amp; encoder, size_t size)
 442     {
 443         ptrdiff_t offsetOffset = encoder.offsetOf(&amp;m_offset);
 444         auto result = encoder.malloc(size);
 445         m_offset = result.offset() - offsetOffset;
 446         return result.buffer();
 447     }
 448 
 449     template&lt;typename T&gt;
<span class="line-added"> 450 #if CPU(ARM64) &amp;&amp; CPU(ADDRESS32)</span>
<span class="line-added"> 451     // FIXME: Remove this once it&#39;s no longer needed and LLVM doesn&#39;t miscompile us:</span>
<span class="line-added"> 452     // &lt;rdar://problem/49792205&gt;</span>
<span class="line-added"> 453     __attribute__((optnone))</span>
<span class="line-added"> 454 #endif</span>
 455     T* allocate(Encoder&amp; encoder, unsigned size = 1)
 456     {
 457         uint8_t* result = allocate(encoder, sizeof(T) * size);
<span class="line-modified"> 458         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(result) % alignof(T)));</span>
<span class="line-added"> 459         return new (result) T[size];</span>
 460     }
 461 
 462 private:
 463     constexpr static ptrdiff_t s_invalidOffset = std::numeric_limits&lt;ptrdiff_t&gt;::max();



 464 };
 465 
 466 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 467 class CachedPtr : public VariableLengthObject&lt;Source*&gt; {
 468     template&lt;typename, typename&gt;
<span class="line-modified"> 469     friend class CachedRefPtr;</span>
<span class="line-added"> 470 </span>
<span class="line-added"> 471     friend struct CachedPtrOffsets;</span>
 472 
 473 public:
 474     void encode(Encoder&amp; encoder, const Source* src)
 475     {
<span class="line-modified"> 476         if (!src)</span>

 477             return;
 478 
<span class="line-modified"> 479         if (Optional&lt;ptrdiff_t&gt; offset = encoder.cachedOffsetForPtr(src)) {</span>
 480             this-&gt;m_offset = *offset - encoder.offsetOf(&amp;this-&gt;m_offset);
 481             return;
 482         }
 483 
 484         T* cachedObject = this-&gt;template allocate&lt;T&gt;(encoder);
 485         cachedObject-&gt;encode(encoder, *src);
 486         encoder.cachePtr(src, encoder.offsetOf(cachedObject));
 487     }
 488 
 489     template&lt;typename... Args&gt;
<span class="line-modified"> 490     Source* decode(Decoder&amp; decoder, bool&amp; isNewAllocation, Args&amp;&amp;... args) const</span>
 491     {
<span class="line-modified"> 492         if (this-&gt;isEmpty()) {</span>
<span class="line-added"> 493             isNewAllocation = false;</span>
 494             return nullptr;
<span class="line-added"> 495         }</span>
 496 
 497         ptrdiff_t bufferOffset = decoder.offsetOf(this-&gt;buffer());
<span class="line-modified"> 498         if (Optional&lt;void*&gt; ptr = decoder.cachedPtrForOffset(bufferOffset)) {</span>
<span class="line-modified"> 499             isNewAllocation = false;</span>
<span class="line-added"> 500             return static_cast&lt;Source*&gt;(*ptr);</span>
<span class="line-added"> 501         }</span>
 502 
<span class="line-modified"> 503         isNewAllocation = true;</span>
<span class="line-added"> 504         Source* ptr = get()-&gt;decode(decoder, std::forward&lt;Args&gt;(args)...);</span>
 505         decoder.cacheOffset(bufferOffset, ptr);
 506         return ptr;
 507     }
 508 
<span class="line-added"> 509     template&lt;typename... Args&gt;</span>
<span class="line-added"> 510     Source* decode(Decoder&amp; decoder, Args&amp;&amp;... args) const</span>
<span class="line-added"> 511     {</span>
<span class="line-added"> 512         bool unusedIsNewAllocation;</span>
<span class="line-added"> 513         return decode(decoder, unusedIsNewAllocation, std::forward&lt;Args&gt;(args)...);</span>
<span class="line-added"> 514     }</span>
<span class="line-added"> 515 </span>
 516     const T* operator-&gt;() const { return get(); }
 517 
 518 private:
 519     const T* get() const
 520     {
<span class="line-modified"> 521         RELEASE_ASSERT(!this-&gt;isEmpty());</span>

 522         return this-&gt;template buffer&lt;T&gt;();
 523     }



 524 };
 525 
<span class="line-added"> 526 ptrdiff_t CachedPtrOffsets::offsetOffset()</span>
<span class="line-added"> 527 {</span>
<span class="line-added"> 528     return OBJECT_OFFSETOF(CachedPtr&lt;void&gt;, m_offset);</span>
<span class="line-added"> 529 }</span>
<span class="line-added"> 530 </span>
 531 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 532 class CachedRefPtr : public CachedObject&lt;RefPtr&lt;Source&gt;&gt; {
 533 public:
 534     void encode(Encoder&amp; encoder, const Source* src)
 535     {
 536         m_ptr.encode(encoder, src);
 537     }
 538 
 539     void encode(Encoder&amp; encoder, const RefPtr&lt;Source&gt; src)
 540     {
 541         encode(encoder, src.get());
 542     }
 543 
 544     RefPtr&lt;Source&gt; decode(Decoder&amp; decoder) const
 545     {
<span class="line-modified"> 546         bool isNewAllocation;</span>
<span class="line-added"> 547         Source* decodedPtr = m_ptr.decode(decoder, isNewAllocation);</span>
 548         if (!decodedPtr)
 549             return nullptr;
<span class="line-modified"> 550         if (isNewAllocation) {</span>
<span class="line-added"> 551             decoder.addFinalizer([=] {</span>
<span class="line-added"> 552                 derefIfNotNull(decodedPtr);</span>
<span class="line-added"> 553             });</span>
<span class="line-added"> 554         }</span>
 555         refIfNotNull(decodedPtr);
 556         return adoptRef(decodedPtr);
 557     }
 558 
 559     void decode(Decoder&amp; decoder, RefPtr&lt;Source&gt;&amp; src) const
 560     {
 561         src = decode(decoder);
 562     }
 563 
 564 private:
 565     CachedPtr&lt;T, Source&gt; m_ptr;
 566 };
 567 
 568 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 569 class CachedWriteBarrier : public CachedObject&lt;WriteBarrier&lt;Source&gt;&gt; {
<span class="line-added"> 570     friend struct CachedWriteBarrierOffsets;</span>
<span class="line-added"> 571 </span>
 572 public:
<span class="line-added"> 573     bool isEmpty() const { return m_ptr.isEmpty(); }</span>
<span class="line-added"> 574 </span>
 575     void encode(Encoder&amp; encoder, const WriteBarrier&lt;Source&gt; src)
 576     {
 577         m_ptr.encode(encoder, src.get());
 578     }
 579 
 580     void decode(Decoder&amp; decoder, WriteBarrier&lt;Source&gt;&amp; src, const JSCell* owner) const
 581     {
 582         Source* decodedPtr = m_ptr.decode(decoder);
 583         if (decodedPtr)
 584             src.set(decoder.vm(), owner, decodedPtr);
 585     }
 586 
 587 private:
 588     CachedPtr&lt;T, Source&gt; m_ptr;
 589 };
 590 
<span class="line-added"> 591 ptrdiff_t CachedWriteBarrierOffsets::ptrOffset()</span>
<span class="line-added"> 592 {</span>
<span class="line-added"> 593     return OBJECT_OFFSETOF(CachedWriteBarrier&lt;void&gt;, m_ptr);</span>
<span class="line-added"> 594 }</span>
<span class="line-added"> 595 </span>
 596 template&lt;typename T, size_t InlineCapacity = 0, typename OverflowHandler = CrashOnOverflow&gt;
 597 class CachedVector : public VariableLengthObject&lt;Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&gt; {
 598 public:
 599     void encode(Encoder&amp; encoder, const Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector)
 600     {
 601         m_size = vector.size();
 602         if (!m_size)
 603             return;
 604         T* buffer = this-&gt;template allocate&lt;T&gt;(encoder, m_size);
 605         for (unsigned i = 0; i &lt; m_size; ++i)
 606             ::JSC::encode(encoder, buffer[i], vector[i]);
 607     }
 608 
 609     template&lt;typename... Args&gt;
 610     void decode(Decoder&amp; decoder, Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector, Args... args) const
 611     {
 612         if (!m_size)
 613             return;
 614         vector.resizeToFit(m_size);
 615         const T* buffer = this-&gt;template buffer&lt;T&gt;();
</pre>
<hr />
<pre>
 651     {
 652         SourceType&lt;decltype(m_entries)&gt; entriesVector(map.size());
 653         unsigned i = 0;
 654         for (const auto&amp; it : map)
 655             entriesVector[i++] = { it.key, it.value };
 656         m_entries.encode(encoder, entriesVector);
 657     }
 658 
 659     void decode(Decoder&amp; decoder, Map&lt;SourceType&lt;Key&gt;, SourceType&lt;Value&gt;&gt;&amp; map) const
 660     {
 661         SourceType&lt;decltype(m_entries)&gt; decodedEntries;
 662         m_entries.decode(decoder, decodedEntries);
 663         for (const auto&amp; pair : decodedEntries)
 664             map.set(pair.first, pair.second);
 665     }
 666 
 667 private:
 668     CachedVector&lt;CachedPair&lt;Key, Value&gt;&gt; m_entries;
 669 };
 670 
<span class="line-modified"> 671 template&lt;typename T&gt;</span>
<span class="line-added"> 672 class CachedUniquedStringImplBase : public VariableLengthObject&lt;T&gt; {</span>
 673 public:
 674     void encode(Encoder&amp; encoder, const StringImpl&amp; string)
 675     {
<span class="line-modified"> 676         m_isAtomic = string.isAtom();</span>
 677         m_isSymbol = string.isSymbol();
 678         RefPtr&lt;StringImpl&gt; impl = const_cast&lt;StringImpl*&gt;(&amp;string);
 679 
 680         if (m_isSymbol) {
 681             SymbolImpl* symbol = static_cast&lt;SymbolImpl*&gt;(impl.get());
 682             if (!symbol-&gt;isNullSymbol()) {
 683                 // We have special handling for well-known symbols.
 684                 if (!symbol-&gt;isPrivate())
 685                     impl = encoder.vm().propertyNames-&gt;getPublicName(encoder.vm(), symbol).impl();
 686             }
 687         }
 688 
 689         m_is8Bit = impl-&gt;is8Bit();
 690         m_length = impl-&gt;length();
 691 
 692         if (!m_length)
 693             return;
 694 
 695         unsigned size = m_length;
 696         const void* payload;
 697         if (m_is8Bit)
 698             payload = impl-&gt;characters8();
 699         else {
 700             payload = impl-&gt;characters16();
 701             size *= 2;
 702         }
 703 
 704         uint8_t* buffer = this-&gt;allocate(encoder, size);
 705         memcpy(buffer, payload, size);
 706     }
 707 
 708     UniquedStringImpl* decode(Decoder&amp; decoder) const
 709     {
 710         auto create = [&amp;](const auto* buffer) -&gt; UniquedStringImpl* {
 711             if (!m_isSymbol)
<span class="line-modified"> 712                 return AtomStringImpl::add(buffer, m_length).leakRef();</span>
 713 
<span class="line-modified"> 714             Identifier ident = Identifier::fromString(decoder.vm(), buffer, m_length);</span>
 715             String str = decoder.vm().propertyNames-&gt;lookUpPrivateName(ident);
 716             StringImpl* impl = str.releaseImpl().get();
 717             ASSERT(impl-&gt;isSymbol());
 718             return static_cast&lt;UniquedStringImpl*&gt;(impl);
 719         };
 720 
 721         if (!m_length) {
 722             if (m_isSymbol)
 723                 return &amp;SymbolImpl::createNullSymbol().leakRef();
<span class="line-modified"> 724             return AtomStringImpl::add(&quot;&quot;).leakRef();</span>
 725         }
 726 
 727         if (m_is8Bit)
<span class="line-modified"> 728             return create(this-&gt;template buffer&lt;LChar&gt;());</span>
<span class="line-modified"> 729         return create(this-&gt;template buffer&lt;UChar&gt;());</span>
 730     }
 731 
 732 private:
 733     bool m_is8Bit : 1;
 734     bool m_isSymbol : 1;
 735     bool m_isAtomic : 1;
 736     unsigned m_length;
 737 };
 738 
<span class="line-modified"> 739 class CachedUniquedStringImpl : public CachedUniquedStringImplBase&lt;UniquedStringImpl&gt; { };</span>
<span class="line-modified"> 740 class CachedStringImpl : public CachedUniquedStringImplBase&lt;StringImpl&gt; { };</span>













 741 
 742 class CachedString : public VariableLengthObject&lt;String&gt; {
 743 public:
 744     void encode(Encoder&amp; encoder, const String&amp; string)
 745     {
 746         m_impl.encode(encoder, static_cast&lt;UniquedStringImpl*&gt;(string.impl()));
 747     }
 748 
 749     String decode(Decoder&amp; decoder) const
 750     {
 751         return String(static_cast&lt;RefPtr&lt;StringImpl&gt;&gt;(m_impl.decode(decoder)));
 752     }
 753 
 754     void decode(Decoder&amp; decoder, String&amp; dst) const
 755     {
 756         dst = decode(decoder);
 757     }
 758 
 759 private:
 760     CachedRefPtr&lt;CachedUniquedStringImpl&gt; m_impl;
 761 };
 762 
 763 class CachedIdentifier : public VariableLengthObject&lt;Identifier&gt; {
 764 public:
 765     void encode(Encoder&amp; encoder, const Identifier&amp; identifier)
 766     {
 767         m_string.encode(encoder, identifier.string());
 768     }
 769 
 770     Identifier decode(Decoder&amp; decoder) const
 771     {
 772         String str = m_string.decode(decoder);
 773         if (str.isNull())
 774             return Identifier();
 775 
<span class="line-modified"> 776         return Identifier::fromUid(decoder.vm(), (UniquedStringImpl*)str.impl());</span>
 777     }
 778 
 779     void decode(Decoder&amp; decoder, Identifier&amp; ident) const
 780     {
 781         ident = decode(decoder);
 782     }
 783 
 784 private:
 785     CachedString m_string;
 786 };
 787 
 788 template&lt;typename T&gt;
<span class="line-modified"> 789 class CachedOptional : public VariableLengthObject&lt;Optional&lt;SourceType&lt;T&gt;&gt;&gt; {</span>
 790 public:
<span class="line-modified"> 791     void encode(Encoder&amp; encoder, const Optional&lt;SourceType&lt;T&gt;&gt;&amp; source)</span>
 792     {
<span class="line-modified"> 793         if (!source)</span>


 794             return;
 795 
 796         this-&gt;template allocate&lt;T&gt;(encoder)-&gt;encode(encoder, *source);
 797     }
 798 
<span class="line-modified"> 799     Optional&lt;SourceType&lt;T&gt;&gt; decode(Decoder&amp; decoder) const</span>
 800     {
<span class="line-modified"> 801         if (this-&gt;isEmpty())</span>
 802             return WTF::nullopt;
 803 
 804         return { this-&gt;template buffer&lt;T&gt;()-&gt;decode(decoder) };
 805     }
 806 
<span class="line-modified"> 807     void decode(Decoder&amp; decoder, Optional&lt;SourceType&lt;T&gt;&gt;&amp; dst) const</span>
 808     {
 809         dst = decode(decoder);
 810     }
 811 
 812     void encode(Encoder&amp; encoder, const std::unique_ptr&lt;SourceType&lt;T&gt;&gt;&amp; source)
 813     {
 814         if (!source)
 815             encode(encoder, WTF::nullopt);
 816         else
 817             encode(encoder, { *source });
 818     }











 819 };
 820 
 821 class CachedSimpleJumpTable : public CachedObject&lt;UnlinkedSimpleJumpTable&gt; {
 822 public:
 823     void encode(Encoder&amp; encoder, const UnlinkedSimpleJumpTable&amp; jumpTable)
 824     {
 825         m_min = jumpTable.min;
 826         m_branchOffsets.encode(encoder, jumpTable.branchOffsets);
 827     }
 828 
 829     void decode(Decoder&amp; decoder, UnlinkedSimpleJumpTable&amp; jumpTable) const
 830     {
 831         jumpTable.min = m_min;
 832         m_branchOffsets.decode(decoder, jumpTable.branchOffsets);
 833     }
 834 
 835 private:
 836     int32_t m_min;
 837     CachedVector&lt;int32_t&gt; m_branchOffsets;
 838 };
</pre>
<hr />
<pre>
 962 
 963 class CachedVariableEnvironment : public CachedObject&lt;VariableEnvironment&gt; {
 964 public:
 965     void encode(Encoder&amp; encoder, const VariableEnvironment&amp; env)
 966     {
 967         m_isEverythingCaptured = env.m_isEverythingCaptured;
 968         m_map.encode(encoder, env.m_map);
 969     }
 970 
 971     void decode(Decoder&amp; decoder, VariableEnvironment&amp; env) const
 972     {
 973         env.m_isEverythingCaptured = m_isEverythingCaptured;
 974         m_map.decode(decoder, env.m_map);
 975     }
 976 
 977 private:
 978     bool m_isEverythingCaptured;
 979     CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, VariableEnvironmentEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntryHashTraits&gt; m_map;
 980 };
 981 
<span class="line-added"> 982 class CachedCompactVariableEnvironment : public CachedObject&lt;CompactVariableEnvironment&gt; {</span>
<span class="line-added"> 983 public:</span>
<span class="line-added"> 984     void encode(Encoder&amp; encoder, const CompactVariableEnvironment&amp; env)</span>
<span class="line-added"> 985     {</span>
<span class="line-added"> 986         m_variables.encode(encoder, env.m_variables);</span>
<span class="line-added"> 987         m_variableMetadata.encode(encoder, env.m_variableMetadata);</span>
<span class="line-added"> 988         m_hash = env.m_hash;</span>
<span class="line-added"> 989         m_isEverythingCaptured = env.m_isEverythingCaptured;</span>
<span class="line-added"> 990     }</span>
<span class="line-added"> 991 </span>
<span class="line-added"> 992     void decode(Decoder&amp; decoder, CompactVariableEnvironment&amp; env) const</span>
<span class="line-added"> 993     {</span>
<span class="line-added"> 994         m_variables.decode(decoder, env.m_variables);</span>
<span class="line-added"> 995         m_variableMetadata.decode(decoder, env.m_variableMetadata);</span>
<span class="line-added"> 996         env.m_hash = m_hash;</span>
<span class="line-added"> 997         env.m_isEverythingCaptured = m_isEverythingCaptured;</span>
<span class="line-added"> 998     }</span>
<span class="line-added"> 999 </span>
<span class="line-added">1000     CompactVariableEnvironment* decode(Decoder&amp; decoder) const</span>
<span class="line-added">1001     {</span>
<span class="line-added">1002         CompactVariableEnvironment* env = new CompactVariableEnvironment;</span>
<span class="line-added">1003         decode(decoder, *env);</span>
<span class="line-added">1004         return env;</span>
<span class="line-added">1005     }</span>
<span class="line-added">1006 </span>
<span class="line-added">1007 private:</span>
<span class="line-added">1008     CachedVector&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;&gt; m_variables;</span>
<span class="line-added">1009     CachedVector&lt;VariableEnvironmentEntry&gt; m_variableMetadata;</span>
<span class="line-added">1010     unsigned m_hash;</span>
<span class="line-added">1011     bool m_isEverythingCaptured;</span>
<span class="line-added">1012 };</span>
<span class="line-added">1013 </span>
<span class="line-added">1014 class CachedCompactVariableMapHandle : public CachedObject&lt;CompactVariableMap::Handle&gt; {</span>
<span class="line-added">1015 public:</span>
<span class="line-added">1016     void encode(Encoder&amp; encoder, const CompactVariableMap::Handle&amp; handle)</span>
<span class="line-added">1017     {</span>
<span class="line-added">1018         m_environment.encode(encoder, handle.m_environment);</span>
<span class="line-added">1019     }</span>
<span class="line-added">1020 </span>
<span class="line-added">1021     CompactVariableMap::Handle decode(Decoder&amp; decoder) const</span>
<span class="line-added">1022     {</span>
<span class="line-added">1023         bool isNewAllocation;</span>
<span class="line-added">1024         CompactVariableEnvironment* environment = m_environment.decode(decoder, isNewAllocation);</span>
<span class="line-added">1025         if (!environment) {</span>
<span class="line-added">1026             ASSERT(!isNewAllocation);</span>
<span class="line-added">1027             return CompactVariableMap::Handle();</span>
<span class="line-added">1028         }</span>
<span class="line-added">1029 </span>
<span class="line-added">1030         if (!isNewAllocation)</span>
<span class="line-added">1031             return decoder.handleForEnvironment(environment);</span>
<span class="line-added">1032         bool isNewEntry;</span>
<span class="line-added">1033         CompactVariableMap::Handle handle = decoder.vm().m_compactVariableMap-&gt;get(environment, isNewEntry);</span>
<span class="line-added">1034         if (!isNewEntry) {</span>
<span class="line-added">1035             decoder.addFinalizer([=] {</span>
<span class="line-added">1036                 delete environment;</span>
<span class="line-added">1037             });</span>
<span class="line-added">1038         }</span>
<span class="line-added">1039         decoder.setHandleForEnvironment(environment, handle);</span>
<span class="line-added">1040         return handle;</span>
<span class="line-added">1041     }</span>
<span class="line-added">1042 </span>
<span class="line-added">1043 private:</span>
<span class="line-added">1044     CachedPtr&lt;CachedCompactVariableEnvironment&gt; m_environment;</span>
<span class="line-added">1045 };</span>
<span class="line-added">1046 </span>
1047 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
1048 class CachedArray : public VariableLengthObject&lt;Source*&gt; {
1049 public:
1050     void encode(Encoder&amp; encoder, const Source* array, unsigned size)
1051     {
1052         if (!size)
1053             return;
1054         T* dst = this-&gt;template allocate&lt;T&gt;(encoder, size);
1055         for (unsigned i = 0; i &lt; size; ++i)
1056             ::JSC::encode(encoder, dst[i], array[i]);
1057     }
1058 
1059     template&lt;typename... Args&gt;
1060     void decode(Decoder&amp; decoder, Source* array, unsigned size, Args... args) const
1061     {
1062         if (!size)
1063             return;
1064         const T* buffer = this-&gt;template buffer&lt;T&gt;();
1065         for (unsigned i = 0; i &lt; size; ++i)
1066             ::JSC::decode(decoder, buffer[i], array[i], args...);
1067     }
1068 };
1069 
1070 class CachedScopedArgumentsTable : public CachedObject&lt;ScopedArgumentsTable&gt; {
1071 public:
1072     void encode(Encoder&amp; encoder, const ScopedArgumentsTable&amp; scopedArgumentsTable)
1073     {
1074         m_length = scopedArgumentsTable.m_length;
<span class="line-modified">1075         m_arguments.encode(encoder, scopedArgumentsTable.m_arguments.get(m_length), m_length);</span>
1076     }
1077 
1078     ScopedArgumentsTable* decode(Decoder&amp; decoder) const
1079     {
1080         ScopedArgumentsTable* scopedArgumentsTable = ScopedArgumentsTable::create(decoder.vm(), m_length);
<span class="line-modified">1081         m_arguments.decode(decoder, scopedArgumentsTable-&gt;m_arguments.get(m_length), m_length);</span>
1082         return scopedArgumentsTable;
1083     }
1084 
1085 private:
1086     uint32_t m_length;
1087     CachedArray&lt;ScopeOffset&gt; m_arguments;
1088 };
1089 
1090 class CachedSymbolTableEntry : public CachedObject&lt;SymbolTableEntry&gt; {
1091 public:
1092     void encode(Encoder&amp;, const SymbolTableEntry&amp; symbolTableEntry)
1093     {
1094         m_bits = symbolTableEntry.m_bits | SymbolTableEntry::SlimFlag;
1095     }
1096 
1097     void decode(Decoder&amp;, SymbolTableEntry&amp; symbolTableEntry) const
1098     {
1099         symbolTableEntry.m_bits = m_bits;
1100     }
1101 
</pre>
<hr />
<pre>
1174         CachedArray&lt;CachedJSValue, WriteBarrier&lt;Unknown&gt;&gt; m_cachedValues;
1175     };
1176 };
1177 
1178 class CachedRegExp : public CachedObject&lt;RegExp&gt; {
1179 public:
1180     void encode(Encoder&amp; encoder, const RegExp&amp; regExp)
1181     {
1182         m_patternString.encode(encoder, regExp.m_patternString);
1183         m_flags = regExp.m_flags;
1184     }
1185 
1186     RegExp* decode(Decoder&amp; decoder) const
1187     {
1188         String pattern { m_patternString.decode(decoder) };
1189         return RegExp::create(decoder.vm(), pattern, m_flags);
1190     }
1191 
1192 private:
1193     CachedString m_patternString;
<span class="line-modified">1194     OptionSet&lt;Yarr::Flags&gt; m_flags;</span>
1195 };
1196 
1197 class CachedTemplateObjectDescriptor : public CachedObject&lt;TemplateObjectDescriptor&gt; {
1198 public:
<span class="line-modified">1199     void encode(Encoder&amp; encoder, const JSTemplateObjectDescriptor&amp; descriptor)</span>
1200     {
<span class="line-modified">1201         m_rawStrings.encode(encoder, descriptor.descriptor().rawStrings());</span>
<span class="line-modified">1202         m_cookedStrings.encode(encoder, descriptor.descriptor().cookedStrings());</span>
<span class="line-added">1203         m_endOffset = descriptor.endOffset();</span>
1204     }
1205 
<span class="line-modified">1206     JSTemplateObjectDescriptor* decode(Decoder&amp; decoder) const</span>
1207     {
1208         TemplateObjectDescriptor::StringVector decodedRawStrings;
1209         TemplateObjectDescriptor::OptionalStringVector decodedCookedStrings;
1210         m_rawStrings.decode(decoder, decodedRawStrings);
1211         m_cookedStrings.decode(decoder, decodedCookedStrings);
<span class="line-modified">1212         return JSTemplateObjectDescriptor::create(decoder.vm(), TemplateObjectDescriptor::create(WTFMove(decodedRawStrings), WTFMove(decodedCookedStrings)), m_endOffset);</span>
1213     }
1214 
1215 private:
1216     CachedVector&lt;CachedString, 4&gt; m_rawStrings;
1217     CachedVector&lt;CachedOptional&lt;CachedString&gt;, 4&gt; m_cookedStrings;
<span class="line-added">1218     int m_endOffset;</span>
1219 };
1220 
1221 class CachedBigInt : public VariableLengthObject&lt;JSBigInt&gt; {
1222 public:
1223     void encode(Encoder&amp; encoder, JSBigInt&amp; bigInt)
1224     {
1225         m_length = bigInt.length();
1226         m_sign = bigInt.sign();
1227 
1228         if (!m_length)
1229             return;
1230 
1231         unsigned size = sizeof(JSBigInt::Digit) * m_length;
1232         uint8_t* buffer = this-&gt;allocate(encoder, size);
1233         memcpy(buffer, bigInt.dataStorage(), size);
1234     }
1235 
1236     JSBigInt* decode(Decoder&amp; decoder) const
1237     {
1238         JSBigInt* bigInt = JSBigInt::createWithLengthUnchecked(decoder.vm(), m_length);
</pre>
<hr />
<pre>
1272             m_type = EncodedType::String;
1273             StringImpl* impl = string-&gt;tryGetValue().impl();
1274             this-&gt;allocate&lt;CachedUniquedStringImpl&gt;(encoder)-&gt;encode(encoder, *impl);
1275             return;
1276         }
1277 
1278         if (auto* immutableButterfly = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, cell)) {
1279             m_type = EncodedType::ImmutableButterfly;
1280             this-&gt;allocate&lt;CachedImmutableButterfly&gt;(encoder)-&gt;encode(encoder, *immutableButterfly);
1281             return;
1282         }
1283 
1284         if (auto* regexp = jsDynamicCast&lt;RegExp*&gt;(vm, cell)) {
1285             m_type = EncodedType::RegExp;
1286             this-&gt;allocate&lt;CachedRegExp&gt;(encoder)-&gt;encode(encoder, *regexp);
1287             return;
1288         }
1289 
1290         if (auto* templateObjectDescriptor = jsDynamicCast&lt;JSTemplateObjectDescriptor*&gt;(vm, cell)) {
1291             m_type = EncodedType::TemplateObjectDescriptor;
<span class="line-modified">1292             this-&gt;allocate&lt;CachedTemplateObjectDescriptor&gt;(encoder)-&gt;encode(encoder, *templateObjectDescriptor);</span>
1293             return;
1294         }
1295 
1296         if (auto* bigInt = jsDynamicCast&lt;JSBigInt*&gt;(vm, cell)) {
1297             m_type = EncodedType::BigInt;
1298             this-&gt;allocate&lt;CachedBigInt&gt;(encoder)-&gt;encode(encoder, *bigInt);
1299             return;
1300         }
1301 
1302         RELEASE_ASSERT_NOT_REACHED();
1303     }
1304 
1305     void decode(Decoder&amp; decoder, WriteBarrier&lt;Unknown&gt;&amp; value, const JSCell* owner) const
1306     {
1307         JSValue v;
1308         switch (m_type) {
1309         case EncodedType::JSValue:
1310             v = JSValue::decode(*this-&gt;buffer&lt;EncodedJSValue&gt;());
1311             break;
1312         case EncodedType::SymbolTable:
1313             v = this-&gt;buffer&lt;CachedSymbolTable&gt;()-&gt;decode(decoder);
1314             break;
1315         case EncodedType::String: {
1316             StringImpl* impl = this-&gt;buffer&lt;CachedUniquedStringImpl&gt;()-&gt;decode(decoder);
<span class="line-modified">1317             v = jsString(decoder.vm(), adoptRef(*impl));</span>
1318             break;
1319         }
1320         case EncodedType::ImmutableButterfly:
1321             v = this-&gt;buffer&lt;CachedImmutableButterfly&gt;()-&gt;decode(decoder);
1322             break;
1323         case EncodedType::RegExp:
1324             v = this-&gt;buffer&lt;CachedRegExp&gt;()-&gt;decode(decoder);
1325             break;
1326         case EncodedType::TemplateObjectDescriptor:
<span class="line-modified">1327             v = this-&gt;buffer&lt;CachedTemplateObjectDescriptor&gt;()-&gt;decode(decoder);</span>
1328             break;
1329         case EncodedType::BigInt:
1330             v = this-&gt;buffer&lt;CachedBigInt&gt;()-&gt;decode(decoder);
1331             break;
1332         default:
1333             RELEASE_ASSERT_NOT_REACHED();
1334         }
1335         value.set(decoder.vm(), owner, v);
1336     }
1337 
1338 private:
1339     enum class EncodedType : uint8_t {
1340         JSValue,
1341         SymbolTable,
1342         String,
1343         ImmutableButterfly,
1344         RegExp,
1345         TemplateObjectDescriptor,
1346         BigInt,
1347     };
</pre>
<hr />
<pre>
1358 
1359     InstructionStream* decode(Decoder&amp; decoder) const
1360     {
1361         Vector&lt;uint8_t, 0, UnsafeVectorOverflow&gt; instructionsVector;
1362         m_instructions.decode(decoder, instructionsVector);
1363         return new InstructionStream(WTFMove(instructionsVector));
1364     }
1365 
1366 private:
1367     CachedVector&lt;uint8_t, 0, UnsafeVectorOverflow&gt; m_instructions;
1368 };
1369 
1370 class CachedMetadataTable : public CachedObject&lt;UnlinkedMetadataTable&gt; {
1371 public:
1372     void encode(Encoder&amp;, const UnlinkedMetadataTable&amp; metadataTable)
1373     {
1374         ASSERT(metadataTable.m_isFinalized);
1375         m_hasMetadata = metadataTable.m_hasMetadata;
1376         if (!m_hasMetadata)
1377             return;
<span class="line-modified">1378         m_is32Bit = metadataTable.m_is32Bit;</span>
<span class="line-modified">1379         if (m_is32Bit) {</span>
<span class="line-added">1380             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="line-added">1381                 m_metadata[i] = metadataTable.offsetTable32()[i];</span>
<span class="line-added">1382         } else {</span>
<span class="line-added">1383             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="line-added">1384                 m_metadata[i] = metadataTable.offsetTable16()[i];</span>
<span class="line-added">1385         }</span>
1386     }
1387 
1388     Ref&lt;UnlinkedMetadataTable&gt; decode(Decoder&amp;) const
1389     {
<span class="line-modified">1390         if (!m_hasMetadata)</span>
<span class="line-added">1391             return UnlinkedMetadataTable::empty();</span>
<span class="line-added">1392 </span>
<span class="line-added">1393         Ref&lt;UnlinkedMetadataTable&gt; metadataTable = UnlinkedMetadataTable::create(m_is32Bit);</span>
1394         metadataTable-&gt;m_isFinalized = true;
1395         metadataTable-&gt;m_isLinked = false;
1396         metadataTable-&gt;m_hasMetadata = m_hasMetadata;
<span class="line-modified">1397         if (m_is32Bit) {</span>
<span class="line-modified">1398             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="line-added">1399                 metadataTable-&gt;offsetTable32()[i] = m_metadata[i];</span>
<span class="line-added">1400         } else {</span>
<span class="line-added">1401             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="line-added">1402                 metadataTable-&gt;offsetTable16()[i] = m_metadata[i];</span>
<span class="line-added">1403         }</span>
1404         return metadataTable;
1405     }
1406 
1407 private:
1408     bool m_hasMetadata;
<span class="line-added">1409     bool m_is32Bit;</span>
1410     std::array&lt;unsigned, UnlinkedMetadataTable::s_offsetTableEntries&gt; m_metadata;
1411 };
1412 
1413 class CachedSourceOrigin : public CachedObject&lt;SourceOrigin&gt; {
1414 public:
1415     void encode(Encoder&amp; encoder, const SourceOrigin&amp; sourceOrigin)
1416     {
1417         m_string.encode(encoder, sourceOrigin.string());
1418     }
1419 
1420     SourceOrigin decode(Decoder&amp; decoder) const
1421     {
1422         return SourceOrigin { m_string.decode(decoder) };
1423     }
1424 
1425 private:
1426     CachedString m_string;
1427 };
1428 
1429 class CachedTextPosition : public CachedObject&lt;TextPosition&gt; {
</pre>
<hr />
<pre>
1553         case SourceProviderSourceType::Module:
1554             return this-&gt;buffer&lt;CachedStringSourceProvider&gt;()-&gt;decode(decoder, m_sourceType);
1555 #if ENABLE(WEBASSEMBLY)
1556         case SourceProviderSourceType::WebAssembly:
1557             return this-&gt;buffer&lt;CachedWebAssemblySourceProvider&gt;()-&gt;decode(decoder);
1558 #endif
1559         default:
1560             RELEASE_ASSERT_NOT_REACHED();
1561         }
1562     }
1563 
1564 private:
1565     SourceProviderSourceType m_sourceType;
1566 };
1567 
1568 template&lt;typename Source&gt;
1569 class CachedUnlinkedSourceCodeShape : public CachedObject&lt;Source&gt; {
1570 public:
1571     void encode(Encoder&amp; encoder, const UnlinkedSourceCode&amp; sourceCode)
1572     {
<span class="line-modified">1573         m_provider.encode(encoder, sourceCode.m_provider);</span>
1574         m_startOffset = sourceCode.startOffset();
1575         m_endOffset = sourceCode.endOffset();
1576     }
1577 
1578     void decode(Decoder&amp; decoder, UnlinkedSourceCode&amp; sourceCode) const
1579     {
1580         sourceCode.m_provider = m_provider.decode(decoder);
1581         sourceCode.m_startOffset = m_startOffset;
1582         sourceCode.m_endOffset = m_endOffset;
1583     }
1584 
1585 private:
<span class="line-modified">1586     CachedRefPtr&lt;CachedSourceProvider&gt; m_provider;</span>
1587     int m_startOffset;
1588     int m_endOffset;
1589 };
1590 
1591 
1592 class CachedUnlinkedSourceCode : public CachedUnlinkedSourceCodeShape&lt;UnlinkedSourceCode&gt; { };
1593 
1594 class CachedSourceCode : public CachedUnlinkedSourceCodeShape&lt;SourceCode&gt; {
1595     using Base = CachedUnlinkedSourceCodeShape&lt;SourceCode&gt;;
1596 
1597 public:
1598     void encode(Encoder&amp; encoder, const SourceCode&amp; sourceCode)
1599     {
1600         Base::encode(encoder, sourceCode);
1601         m_firstLine = sourceCode.firstLine().zeroBasedInt();
1602         m_startColumn = sourceCode.startColumn().zeroBasedInt();
1603     }
1604 
1605     void decode(Decoder&amp; decoder, SourceCode&amp; sourceCode) const
1606     {
1607         Base::decode(decoder, sourceCode);
1608         sourceCode.m_firstLine = OrdinalNumber::fromZeroBasedInt(m_firstLine);
1609         sourceCode.m_startColumn = OrdinalNumber::fromZeroBasedInt(m_startColumn);
1610     }
1611 
1612 private:
1613     int m_firstLine;
1614     int m_startColumn;
1615 };
1616 
<span class="line-added">1617 class CachedSourceCodeWithoutProvider : public CachedObject&lt;SourceCode&gt; {</span>
<span class="line-added">1618 public:</span>
<span class="line-added">1619     void encode(Encoder&amp;, const SourceCode&amp; sourceCode)</span>
<span class="line-added">1620     {</span>
<span class="line-added">1621         m_hasProvider = !!sourceCode.provider();</span>
<span class="line-added">1622         m_startOffset = sourceCode.startOffset();</span>
<span class="line-added">1623         m_endOffset = sourceCode.endOffset();</span>
<span class="line-added">1624         m_firstLine = sourceCode.firstLine().zeroBasedInt();</span>
<span class="line-added">1625         m_startColumn = sourceCode.startColumn().zeroBasedInt();</span>
<span class="line-added">1626     }</span>
<span class="line-added">1627 </span>
<span class="line-added">1628     void decode(Decoder&amp; decoder, SourceCode&amp; sourceCode) const</span>
<span class="line-added">1629     {</span>
<span class="line-added">1630         if (m_hasProvider)</span>
<span class="line-added">1631             sourceCode.m_provider = decoder.provider();</span>
<span class="line-added">1632         sourceCode.m_startOffset = m_startOffset;</span>
<span class="line-added">1633         sourceCode.m_endOffset = m_endOffset;</span>
<span class="line-added">1634         sourceCode.m_firstLine = OrdinalNumber::fromZeroBasedInt(m_firstLine);</span>
<span class="line-added">1635         sourceCode.m_startColumn = OrdinalNumber::fromZeroBasedInt(m_startColumn);</span>
<span class="line-added">1636     }</span>
<span class="line-added">1637 </span>
<span class="line-added">1638 private:</span>
<span class="line-added">1639     bool m_hasProvider;</span>
<span class="line-added">1640     int m_startOffset;</span>
<span class="line-added">1641     int m_endOffset;</span>
<span class="line-added">1642     int m_firstLine;</span>
<span class="line-added">1643     int m_startColumn;</span>
<span class="line-added">1644 };</span>
<span class="line-added">1645 </span>
1646 class CachedFunctionExecutableRareData : public CachedObject&lt;UnlinkedFunctionExecutable::RareData&gt; {
1647 public:
1648     void encode(Encoder&amp; encoder, const UnlinkedFunctionExecutable::RareData&amp; rareData)
1649     {
1650         m_classSource.encode(encoder, rareData.m_classSource);
<span class="line-added">1651         m_parentScopeTDZVariables.encode(encoder, rareData.m_parentScopeTDZVariables);</span>
1652     }
1653 
1654     UnlinkedFunctionExecutable::RareData* decode(Decoder&amp; decoder) const
1655     {
1656         UnlinkedFunctionExecutable::RareData* rareData = new UnlinkedFunctionExecutable::RareData { };
1657         m_classSource.decode(decoder, rareData-&gt;m_classSource);
<span class="line-added">1658         auto parentScopeTDZVariables = m_parentScopeTDZVariables.decode(decoder);</span>
<span class="line-added">1659         rareData-&gt;m_parentScopeTDZVariables = WTFMove(parentScopeTDZVariables);</span>
1660         return rareData;
1661     }
1662 
1663 private:
<span class="line-modified">1664     CachedSourceCodeWithoutProvider m_classSource;</span>
<span class="line-added">1665     CachedCompactVariableMapHandle m_parentScopeTDZVariables;</span>
1666 };
1667 
1668 class CachedFunctionExecutable : public CachedObject&lt;UnlinkedFunctionExecutable&gt; {
<span class="line-added">1669     friend struct CachedFunctionExecutableOffsets;</span>
<span class="line-added">1670 </span>
1671 public:
1672     void encode(Encoder&amp;, const UnlinkedFunctionExecutable&amp;);
1673     UnlinkedFunctionExecutable* decode(Decoder&amp;) const;
1674 
1675     unsigned firstLineOffset() const { return m_firstLineOffset; }
1676     unsigned lineCount() const { return m_lineCount; }
1677     unsigned unlinkedFunctionNameStart() const { return m_unlinkedFunctionNameStart; }
1678     unsigned unlinkedBodyStartColumn() const { return m_unlinkedBodyStartColumn; }
1679     unsigned unlinkedBodyEndColumn() const { return m_unlinkedBodyEndColumn; }
1680     unsigned startOffset() const { return m_startOffset; }
1681     unsigned sourceLength() const { return m_sourceLength; }
1682     unsigned parametersStartOffset() const { return m_parametersStartOffset; }
1683     unsigned typeProfilingStartOffset() const { return m_typeProfilingStartOffset; }
1684     unsigned typeProfilingEndOffset() const { return m_typeProfilingEndOffset; }
1685     unsigned parameterCount() const { return m_parameterCount; }
1686 
<span class="line-modified">1687     CodeFeatures features() const { return m_mutableMetadata.m_features; }</span>
1688     SourceParseMode sourceParseMode() const { return m_sourceParseMode; }
1689 
1690     unsigned isInStrictContext() const { return m_isInStrictContext; }
<span class="line-modified">1691     unsigned hasCapturedVariables() const { return m_mutableMetadata.m_hasCapturedVariables; }</span>
1692     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1693     unsigned isBuiltinDefaultClassConstructor() const { return m_isBuiltinDefaultClassConstructor; }
1694     unsigned constructAbility() const { return m_constructAbility; }
1695     unsigned constructorKind() const { return m_constructorKind; }
1696     unsigned functionMode() const { return m_functionMode; }
1697     unsigned scriptMode() const { return m_scriptMode; }
1698     unsigned superBinding() const { return m_superBinding; }
1699     unsigned derivedContextType() const { return m_derivedContextType; }
1700 
1701     Identifier name(Decoder&amp; decoder) const { return m_name.decode(decoder); }
1702     Identifier ecmaName(Decoder&amp; decoder) const { return m_ecmaName.decode(decoder); }

1703 
<span class="line-modified">1704     UnlinkedFunctionExecutable::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }</span>
<span class="line-added">1705 </span>
<span class="line-added">1706     const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;&amp; unlinkedCodeBlockForCall() const { return m_unlinkedCodeBlockForCall; }</span>
<span class="line-added">1707     const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;&amp; unlinkedCodeBlockForConstruct() const { return m_unlinkedCodeBlockForConstruct; }</span>
1708 
1709 private:
<span class="line-modified">1710     CachedFunctionExecutableMetadata m_mutableMetadata;</span>
<span class="line-modified">1711 </span>
<span class="line-modified">1712     unsigned m_firstLineOffset : 31;</span>










1713     unsigned m_isInStrictContext : 1;
<span class="line-modified">1714     unsigned m_lineCount : 31;</span>
1715     unsigned m_isBuiltinFunction : 1;
<span class="line-added">1716     unsigned m_unlinkedFunctionNameStart : 31;</span>
1717     unsigned m_isBuiltinDefaultClassConstructor : 1;
<span class="line-added">1718     unsigned m_unlinkedBodyStartColumn : 31;</span>
1719     unsigned m_constructAbility: 1;
<span class="line-modified">1720     unsigned m_unlinkedBodyEndColumn : 31;</span>
<span class="line-modified">1721     unsigned m_startOffset : 31;</span>
1722     unsigned m_scriptMode: 1; // JSParserScriptMode
<span class="line-added">1723     unsigned m_sourceLength : 31;</span>
1724     unsigned m_superBinding : 1;
<span class="line-added">1725     unsigned m_parametersStartOffset : 31;</span>
<span class="line-added">1726     unsigned m_typeProfilingStartOffset;</span>
<span class="line-added">1727     unsigned m_typeProfilingEndOffset;</span>
<span class="line-added">1728     unsigned m_parameterCount;</span>
<span class="line-added">1729     SourceParseMode m_sourceParseMode;</span>
<span class="line-added">1730     unsigned m_constructorKind : 2;</span>
<span class="line-added">1731     unsigned m_functionMode : 2; // FunctionMode</span>
1732     unsigned m_derivedContextType: 2;
1733 
<span class="line-modified">1734     CachedPtr&lt;CachedFunctionExecutableRareData&gt; m_rareData;</span>
1735 
1736     CachedIdentifier m_name;
1737     CachedIdentifier m_ecmaName;



1738 
1739     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForCall;
1740     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForConstruct;
1741 };
1742 
<span class="line-added">1743 ptrdiff_t CachedFunctionExecutableOffsets::codeBlockForCallOffset()</span>
<span class="line-added">1744 {</span>
<span class="line-added">1745     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_unlinkedCodeBlockForCall);</span>
<span class="line-added">1746 }</span>
<span class="line-added">1747 </span>
<span class="line-added">1748 ptrdiff_t CachedFunctionExecutableOffsets::codeBlockForConstructOffset()</span>
<span class="line-added">1749 {</span>
<span class="line-added">1750     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_unlinkedCodeBlockForConstruct);</span>
<span class="line-added">1751 }</span>
<span class="line-added">1752 </span>
<span class="line-added">1753 ptrdiff_t CachedFunctionExecutableOffsets::metadataOffset()</span>
<span class="line-added">1754 {</span>
<span class="line-added">1755     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_mutableMetadata);</span>
<span class="line-added">1756 }</span>
<span class="line-added">1757 </span>
1758 template&lt;typename CodeBlockType&gt;
1759 class CachedCodeBlock : public CachedObject&lt;CodeBlockType&gt; {
1760 public:
1761     void encode(Encoder&amp;, const UnlinkedCodeBlock&amp;);
1762     void decode(Decoder&amp;, UnlinkedCodeBlock&amp;) const;
1763 
1764     InstructionStream* instructions(Decoder&amp; decoder) const { return m_instructions.decode(decoder); }
1765 
1766     VirtualRegister thisRegister() const { return m_thisRegister; }
1767     VirtualRegister scopeRegister() const { return m_scopeRegister; }
1768 
1769     String sourceURLDirective(Decoder&amp; decoder) const { return m_sourceURLDirective.decode(decoder); }
1770     String sourceMappingURLDirective(Decoder&amp; decoder) const { return m_sourceMappingURLDirective.decode(decoder); }
1771 
1772     Ref&lt;UnlinkedMetadataTable&gt; metadata(Decoder&amp; decoder) const { return m_metadata.decode(decoder); }
1773 
1774     unsigned usesEval() const { return m_usesEval; }
1775     unsigned isStrictMode() const { return m_isStrictMode; }
1776     unsigned isConstructor() const { return m_isConstructor; }
1777     unsigned hasCapturedVariables() const { return m_hasCapturedVariables; }
1778     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1779     unsigned superBinding() const { return m_superBinding; }
1780     unsigned scriptMode() const { return m_scriptMode; }
1781     unsigned isArrowFunctionContext() const { return m_isArrowFunctionContext; }
1782     unsigned isClassContext() const { return m_isClassContext; }

1783     unsigned constructorKind() const { return m_constructorKind; }
1784     unsigned derivedContextType() const { return m_derivedContextType; }
1785     unsigned evalContextType() const { return m_evalContextType; }
1786     unsigned hasTailCalls() const { return m_hasTailCalls; }
1787     unsigned lineCount() const { return m_lineCount; }
1788     unsigned endColumn() const { return m_endColumn; }
1789 
1790     int numVars() const { return m_numVars; }
1791     int numCalleeLocals() const { return m_numCalleeLocals; }
1792     int numParameters() const { return m_numParameters; }
1793 
1794     CodeFeatures features() const { return m_features; }
1795     SourceParseMode parseMode() const { return m_parseMode; }
<span class="line-added">1796     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode() const { return m_codeGenerationMode; }</span>
1797     unsigned codeType() const { return m_codeType; }
1798 
<span class="line-modified">1799     UnlinkedCodeBlock::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }</span>
1800 
1801 private:
1802     VirtualRegister m_thisRegister;
1803     VirtualRegister m_scopeRegister;
1804     std::array&lt;unsigned, LinkTimeConstantCount&gt; m_linkTimeConstants;
1805 
1806     unsigned m_usesEval : 1;
1807     unsigned m_isStrictMode : 1;
1808     unsigned m_isConstructor : 1;
1809     unsigned m_hasCapturedVariables : 1;
1810     unsigned m_isBuiltinFunction : 1;
1811     unsigned m_superBinding : 1;
1812     unsigned m_scriptMode: 1;
1813     unsigned m_isArrowFunctionContext : 1;
1814     unsigned m_isClassContext : 1;

1815     unsigned m_constructorKind : 2;
1816     unsigned m_derivedContextType : 2;
1817     unsigned m_evalContextType : 2;
1818     unsigned m_hasTailCalls : 1;
1819     unsigned m_codeType : 2;
1820 
1821     CodeFeatures m_features;
1822     SourceParseMode m_parseMode;
<span class="line-added">1823     OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;</span>
1824 
1825     unsigned m_lineCount;
1826     unsigned m_endColumn;
1827 
1828     int m_numVars;
1829     int m_numCalleeLocals;
1830     int m_numParameters;
1831 
1832     CachedMetadataTable m_metadata;
1833 
<span class="line-modified">1834     CachedPtr&lt;CachedCodeBlockRareData&gt; m_rareData;</span>
1835 
1836     CachedString m_sourceURLDirective;
1837     CachedString m_sourceMappingURLDirective;
1838 
1839     CachedPtr&lt;CachedInstructionStream&gt; m_instructions;
1840     CachedVector&lt;InstructionStream::Offset&gt; m_jumpTargets;
1841     CachedVector&lt;InstructionStream::Offset&gt; m_propertyAccessInstructions;
1842     CachedVector&lt;CachedJSValue&gt; m_constantRegisters;
1843     CachedVector&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;
1844     CachedVector&lt;ExpressionRangeInfo&gt; m_expressionInfo;
1845     CachedHashMap&lt;InstructionStream::Offset, int&gt; m_outOfLineJumpTargets;
1846 
1847     CachedVector&lt;CachedIdentifier&gt; m_identifiers;
1848     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionDecls;
1849     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionExprs;
1850 };
1851 
1852 class CachedProgramCodeBlock : public CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt; {
1853     using Base = CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt;;
1854 
</pre>
<hr />
<pre>
1939         codeBlock-&gt;finishCreation(decoder.vm());
1940         Base::decode(decoder, *codeBlock);
1941         return codeBlock;
1942     }
1943 };
1944 
1945 ALWAYS_INLINE UnlinkedFunctionCodeBlock::UnlinkedFunctionCodeBlock(Decoder&amp; decoder, const CachedFunctionCodeBlock&amp; cachedCodeBlock)
1946     : Base(decoder, decoder.vm().unlinkedFunctionCodeBlockStructure.get(), cachedCodeBlock)
1947 {
1948 }
1949 
1950 template&lt;typename T&gt;
1951 struct CachedCodeBlockTypeImpl;
1952 
1953 enum CachedCodeBlockTag {
1954     CachedProgramCodeBlockTag,
1955     CachedModuleCodeBlockTag,
1956     CachedEvalCodeBlockTag,
1957 };
1958 
<span class="line-added">1959 static CachedCodeBlockTag tagFromSourceCodeType(SourceCodeType type)</span>
<span class="line-added">1960 {</span>
<span class="line-added">1961     switch (type) {</span>
<span class="line-added">1962     case SourceCodeType::ProgramType:</span>
<span class="line-added">1963         return CachedProgramCodeBlockTag;</span>
<span class="line-added">1964     case SourceCodeType::EvalType:</span>
<span class="line-added">1965         return CachedEvalCodeBlockTag;</span>
<span class="line-added">1966     case SourceCodeType::ModuleType:</span>
<span class="line-added">1967         return CachedModuleCodeBlockTag;</span>
<span class="line-added">1968     case SourceCodeType::FunctionType:</span>
<span class="line-added">1969         break;</span>
<span class="line-added">1970     }</span>
<span class="line-added">1971     ASSERT_NOT_REACHED();</span>
<span class="line-added">1972     return static_cast&lt;CachedCodeBlockTag&gt;(-1);</span>
<span class="line-added">1973 }</span>
<span class="line-added">1974 </span>
1975 template&lt;&gt;
1976 struct CachedCodeBlockTypeImpl&lt;UnlinkedProgramCodeBlock&gt; {
1977     using type = CachedProgramCodeBlock;
1978     static constexpr CachedCodeBlockTag tag = CachedProgramCodeBlockTag;
1979 };
1980 
1981 template&lt;&gt;
1982 struct CachedCodeBlockTypeImpl&lt;UnlinkedModuleProgramCodeBlock&gt; {
1983     using type = CachedModuleCodeBlock;
1984     static constexpr CachedCodeBlockTag tag = CachedModuleCodeBlockTag;
1985 };
1986 
1987 template&lt;&gt;
1988 struct CachedCodeBlockTypeImpl&lt;UnlinkedEvalCodeBlock&gt; {
1989     using type = CachedEvalCodeBlock;
1990     static constexpr CachedCodeBlockTag tag = CachedEvalCodeBlockTag;
1991 };
1992 
1993 template&lt;typename T&gt;
1994 using CachedCodeBlockType = typename CachedCodeBlockTypeImpl&lt;T&gt;::type;
1995 
1996 template&lt;typename CodeBlockType&gt;
1997 ALWAYS_INLINE UnlinkedCodeBlock::UnlinkedCodeBlock(Decoder&amp; decoder, Structure* structure, const CachedCodeBlock&lt;CodeBlockType&gt;&amp; cachedCodeBlock)
1998     : Base(decoder.vm(), structure)
1999     , m_thisRegister(cachedCodeBlock.thisRegister())
2000     , m_scopeRegister(cachedCodeBlock.scopeRegister())
2001 
2002     , m_usesEval(cachedCodeBlock.usesEval())
2003     , m_isStrictMode(cachedCodeBlock.isStrictMode())
2004     , m_isConstructor(cachedCodeBlock.isConstructor())
2005     , m_hasCapturedVariables(cachedCodeBlock.hasCapturedVariables())
2006     , m_isBuiltinFunction(cachedCodeBlock.isBuiltinFunction())
2007     , m_superBinding(cachedCodeBlock.superBinding())
2008     , m_scriptMode(cachedCodeBlock.scriptMode())
2009     , m_isArrowFunctionContext(cachedCodeBlock.isArrowFunctionContext())
2010     , m_isClassContext(cachedCodeBlock.isClassContext())
<span class="line-modified">2011     , m_hasTailCalls(cachedCodeBlock.hasTailCalls())</span>
2012     , m_constructorKind(cachedCodeBlock.constructorKind())
2013     , m_derivedContextType(cachedCodeBlock.derivedContextType())
2014     , m_evalContextType(cachedCodeBlock.evalContextType())

2015     , m_codeType(cachedCodeBlock.codeType())
2016 
<span class="line-added">2017     , m_didOptimize(static_cast&lt;unsigned&gt;(MixedTriState))</span>
<span class="line-added">2018     , m_age(0)</span>
<span class="line-added">2019 </span>
2020     , m_features(cachedCodeBlock.features())
2021     , m_parseMode(cachedCodeBlock.parseMode())
<span class="line-added">2022     , m_codeGenerationMode(cachedCodeBlock.codeGenerationMode())</span>
2023 
2024     , m_lineCount(cachedCodeBlock.lineCount())
2025     , m_endColumn(cachedCodeBlock.endColumn())
2026     , m_numVars(cachedCodeBlock.numVars())
2027     , m_numCalleeLocals(cachedCodeBlock.numCalleeLocals())
2028     , m_numParameters(cachedCodeBlock.numParameters())
2029 
2030     , m_sourceURLDirective(cachedCodeBlock.sourceURLDirective(decoder))
2031     , m_sourceMappingURLDirective(cachedCodeBlock.sourceMappingURLDirective(decoder))
2032 
2033     , m_metadata(cachedCodeBlock.metadata(decoder))
2034     , m_instructions(cachedCodeBlock.instructions(decoder))
2035 
2036     , m_rareData(cachedCodeBlock.rareData(decoder))
2037 {
2038 }
2039 
2040 template&lt;typename CodeBlockType&gt;
2041 ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::decode(Decoder&amp; decoder, UnlinkedCodeBlock&amp; codeBlock) const
2042 {
</pre>
<hr />
<pre>
2054     m_functionExprs.decode(decoder, codeBlock.m_functionExprs, &amp;codeBlock);
2055 }
2056 
2057 ALWAYS_INLINE UnlinkedProgramCodeBlock::UnlinkedProgramCodeBlock(Decoder&amp; decoder, const CachedProgramCodeBlock&amp; cachedCodeBlock)
2058     : Base(decoder, decoder.vm().unlinkedProgramCodeBlockStructure.get(), cachedCodeBlock)
2059 {
2060 }
2061 
2062 ALWAYS_INLINE UnlinkedModuleProgramCodeBlock::UnlinkedModuleProgramCodeBlock(Decoder&amp; decoder, const CachedModuleCodeBlock&amp; cachedCodeBlock)
2063     : Base(decoder, decoder.vm().unlinkedModuleProgramCodeBlockStructure.get(), cachedCodeBlock)
2064 {
2065 }
2066 
2067 ALWAYS_INLINE UnlinkedEvalCodeBlock::UnlinkedEvalCodeBlock(Decoder&amp; decoder, const CachedEvalCodeBlock&amp; cachedCodeBlock)
2068     : Base(decoder, decoder.vm().unlinkedEvalCodeBlockStructure.get(), cachedCodeBlock)
2069 {
2070 }
2071 
2072 ALWAYS_INLINE void CachedFunctionExecutable::encode(Encoder&amp; encoder, const UnlinkedFunctionExecutable&amp; executable)
2073 {
<span class="line-added">2074     m_mutableMetadata.m_features = executable.m_features;</span>
<span class="line-added">2075     m_mutableMetadata.m_hasCapturedVariables = executable.m_hasCapturedVariables;</span>
<span class="line-added">2076 </span>
2077     m_firstLineOffset = executable.m_firstLineOffset;
2078     m_lineCount = executable.m_lineCount;
2079     m_unlinkedFunctionNameStart = executable.m_unlinkedFunctionNameStart;
2080     m_unlinkedBodyStartColumn = executable.m_unlinkedBodyStartColumn;
2081     m_unlinkedBodyEndColumn = executable.m_unlinkedBodyEndColumn;
2082     m_startOffset = executable.m_startOffset;
2083     m_sourceLength = executable.m_sourceLength;
2084     m_parametersStartOffset = executable.m_parametersStartOffset;
2085     m_typeProfilingStartOffset = executable.m_typeProfilingStartOffset;
2086     m_typeProfilingEndOffset = executable.m_typeProfilingEndOffset;
2087     m_parameterCount = executable.m_parameterCount;
2088 

2089     m_sourceParseMode = executable.m_sourceParseMode;
2090 
2091     m_isInStrictContext = executable.m_isInStrictContext;

2092     m_isBuiltinFunction = executable.m_isBuiltinFunction;
2093     m_isBuiltinDefaultClassConstructor = executable.m_isBuiltinDefaultClassConstructor;
2094     m_constructAbility = executable.m_constructAbility;
2095     m_constructorKind = executable.m_constructorKind;
2096     m_functionMode = executable.m_functionMode;
2097     m_scriptMode = executable.m_scriptMode;
2098     m_superBinding = executable.m_superBinding;
2099     m_derivedContextType = executable.m_derivedContextType;
2100 
<span class="line-modified">2101     m_rareData.encode(encoder, executable.m_rareData.get());</span>
2102 
2103     m_name.encode(encoder, executable.name());
2104     m_ecmaName.encode(encoder, executable.ecmaName());



2105 
2106     m_unlinkedCodeBlockForCall.encode(encoder, executable.m_unlinkedCodeBlockForCall);
2107     m_unlinkedCodeBlockForConstruct.encode(encoder, executable.m_unlinkedCodeBlockForConstruct);
<span class="line-added">2108 </span>
<span class="line-added">2109     if (!executable.m_unlinkedCodeBlockForCall || !executable.m_unlinkedCodeBlockForConstruct)</span>
<span class="line-added">2110         encoder.addLeafExecutable(&amp;executable, encoder.offsetOf(this));</span>
2111 }
2112 
2113 ALWAYS_INLINE UnlinkedFunctionExecutable* CachedFunctionExecutable::decode(Decoder&amp; decoder) const
2114 {
<span class="line-modified">2115     UnlinkedFunctionExecutable* executable = new (NotNull, allocateCell&lt;UnlinkedFunctionExecutable&gt;(decoder.vm().heap)) UnlinkedFunctionExecutable(decoder, *this);</span>



2116     executable-&gt;finishCreation(decoder.vm());




2117     return executable;
2118 }
2119 
<span class="line-modified">2120 ALWAYS_INLINE UnlinkedFunctionExecutable::UnlinkedFunctionExecutable(Decoder&amp; decoder, const CachedFunctionExecutable&amp; cachedExecutable)</span>
2121     : Base(decoder.vm(), decoder.vm().unlinkedFunctionExecutableStructure.get())
2122     , m_firstLineOffset(cachedExecutable.firstLineOffset())
<span class="line-added">2123     , m_isInStrictContext(cachedExecutable.isInStrictContext())</span>
2124     , m_lineCount(cachedExecutable.lineCount())
<span class="line-added">2125     , m_hasCapturedVariables(cachedExecutable.hasCapturedVariables())</span>
2126     , m_unlinkedFunctionNameStart(cachedExecutable.unlinkedFunctionNameStart())
<span class="line-added">2127     , m_isBuiltinFunction(cachedExecutable.isBuiltinFunction())</span>
2128     , m_unlinkedBodyStartColumn(cachedExecutable.unlinkedBodyStartColumn())
<span class="line-added">2129     , m_isBuiltinDefaultClassConstructor(cachedExecutable.isBuiltinDefaultClassConstructor())</span>
2130     , m_unlinkedBodyEndColumn(cachedExecutable.unlinkedBodyEndColumn())
<span class="line-added">2131     , m_constructAbility(cachedExecutable.constructAbility())</span>
2132     , m_startOffset(cachedExecutable.startOffset())
<span class="line-added">2133     , m_scriptMode(cachedExecutable.scriptMode())</span>
2134     , m_sourceLength(cachedExecutable.sourceLength())
<span class="line-added">2135     , m_superBinding(cachedExecutable.superBinding())</span>
2136     , m_parametersStartOffset(cachedExecutable.parametersStartOffset())
<span class="line-added">2137     , m_isCached(false)</span>
2138     , m_typeProfilingStartOffset(cachedExecutable.typeProfilingStartOffset())
2139     , m_typeProfilingEndOffset(cachedExecutable.typeProfilingEndOffset())
2140     , m_parameterCount(cachedExecutable.parameterCount())
2141     , m_features(cachedExecutable.features())
2142     , m_sourceParseMode(cachedExecutable.sourceParseMode())





2143     , m_constructorKind(cachedExecutable.constructorKind())
2144     , m_functionMode(cachedExecutable.functionMode())


2145     , m_derivedContextType(cachedExecutable.derivedContextType())
<span class="line-added">2146     , m_isGeneratedFromCache(true)</span>
<span class="line-added">2147     , m_unlinkedCodeBlockForCall()</span>
<span class="line-added">2148     , m_unlinkedCodeBlockForConstruct()</span>
2149 
2150     , m_name(cachedExecutable.name(decoder))
2151     , m_ecmaName(cachedExecutable.ecmaName(decoder))



2152 
2153     , m_rareData(cachedExecutable.rareData(decoder))
2154 {
<span class="line-added">2155 </span>
<span class="line-added">2156     uint32_t leafExecutables = 2;</span>
<span class="line-added">2157     auto checkBounds = [&amp;](int32_t&amp; codeBlockOffset, auto&amp; cachedPtr) {</span>
<span class="line-added">2158         if (!cachedPtr.isEmpty()) {</span>
<span class="line-added">2159             ptrdiff_t offset = decoder.offsetOf(&amp;cachedPtr);</span>
<span class="line-added">2160             if (static_cast&lt;size_t&gt;(offset) &lt; decoder.size()) {</span>
<span class="line-added">2161                 codeBlockOffset = offset;</span>
<span class="line-added">2162                 m_isCached = true;</span>
<span class="line-added">2163                 leafExecutables--;</span>
<span class="line-added">2164                 return;</span>
<span class="line-added">2165             }</span>
<span class="line-added">2166         }</span>
<span class="line-added">2167 </span>
<span class="line-added">2168         codeBlockOffset = 0;</span>
<span class="line-added">2169     };</span>
<span class="line-added">2170 </span>
<span class="line-added">2171     if (!cachedExecutable.unlinkedCodeBlockForCall().isEmpty() || !cachedExecutable.unlinkedCodeBlockForConstruct().isEmpty()) {</span>
<span class="line-added">2172         checkBounds(m_cachedCodeBlockForCallOffset, cachedExecutable.unlinkedCodeBlockForCall());</span>
<span class="line-added">2173         checkBounds(m_cachedCodeBlockForConstructOffset, cachedExecutable.unlinkedCodeBlockForConstruct());</span>
<span class="line-added">2174         if (m_isCached)</span>
<span class="line-added">2175             m_decoder = &amp;decoder;</span>
<span class="line-added">2176         else</span>
<span class="line-added">2177             m_decoder = nullptr;</span>
<span class="line-added">2178     }</span>
<span class="line-added">2179 </span>
<span class="line-added">2180     if (leafExecutables)</span>
<span class="line-added">2181         decoder.addLeafExecutable(this, decoder.offsetOf(&amp;cachedExecutable));</span>
2182 }
2183 
2184 template&lt;typename CodeBlockType&gt;
2185 ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::encode(Encoder&amp; encoder, const UnlinkedCodeBlock&amp; codeBlock)
2186 {
2187     m_thisRegister = codeBlock.m_thisRegister;
2188     m_scopeRegister = codeBlock.m_scopeRegister;
2189     m_usesEval = codeBlock.m_usesEval;
2190     m_isStrictMode = codeBlock.m_isStrictMode;
2191     m_isConstructor = codeBlock.m_isConstructor;
2192     m_hasCapturedVariables = codeBlock.m_hasCapturedVariables;
2193     m_isBuiltinFunction = codeBlock.m_isBuiltinFunction;
2194     m_superBinding = codeBlock.m_superBinding;
2195     m_scriptMode = codeBlock.m_scriptMode;
2196     m_isArrowFunctionContext = codeBlock.m_isArrowFunctionContext;
2197     m_isClassContext = codeBlock.m_isClassContext;
<span class="line-modified">2198     m_hasTailCalls = codeBlock.m_hasTailCalls;</span>
2199     m_constructorKind = codeBlock.m_constructorKind;
2200     m_derivedContextType = codeBlock.m_derivedContextType;
2201     m_evalContextType = codeBlock.m_evalContextType;

2202     m_lineCount = codeBlock.m_lineCount;
2203     m_endColumn = codeBlock.m_endColumn;
2204     m_numVars = codeBlock.m_numVars;
2205     m_numCalleeLocals = codeBlock.m_numCalleeLocals;
2206     m_numParameters = codeBlock.m_numParameters;
2207     m_features = codeBlock.m_features;
2208     m_parseMode = codeBlock.m_parseMode;
<span class="line-added">2209     m_codeGenerationMode = codeBlock.m_codeGenerationMode;</span>
2210     m_codeType = codeBlock.m_codeType;
2211 
2212     for (unsigned i = LinkTimeConstantCount; i--;)
2213         m_linkTimeConstants[i] = codeBlock.m_linkTimeConstants[i];
2214 
2215     m_metadata.encode(encoder, codeBlock.m_metadata.get());
<span class="line-modified">2216     m_rareData.encode(encoder, codeBlock.m_rareData.get());</span>
2217 
2218     m_sourceURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());
2219     m_sourceMappingURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());
2220 
2221     m_instructions.encode(encoder, codeBlock.m_instructions.get());
2222     m_propertyAccessInstructions.encode(encoder, codeBlock.m_propertyAccessInstructions);
2223     m_constantRegisters.encode(encoder, codeBlock.m_constantRegisters);
2224     m_constantsSourceCodeRepresentation.encode(encoder, codeBlock.m_constantsSourceCodeRepresentation);
2225     m_expressionInfo.encode(encoder, codeBlock.m_expressionInfo);
2226     m_jumpTargets.encode(encoder, codeBlock.m_jumpTargets);
2227     m_outOfLineJumpTargets.encode(encoder, codeBlock.m_outOfLineJumpTargets);
2228 
2229     m_identifiers.encode(encoder, codeBlock.m_identifiers);
2230     m_functionDecls.encode(encoder, codeBlock.m_functionDecls);
2231     m_functionExprs.encode(encoder, codeBlock.m_functionExprs);
2232 }
2233 
2234 class CachedSourceCodeKey : public CachedObject&lt;SourceCodeKey&gt; {
2235 public:
2236     void encode(Encoder&amp; encoder, const SourceCodeKey&amp; key)
</pre>
<hr />
<pre>
2245     void decode(Decoder&amp; decoder, SourceCodeKey&amp; key) const
2246     {
2247         m_sourceCode.decode(decoder, key.m_sourceCode);
2248         m_name.decode(decoder, key.m_name);
2249         key.m_flags.m_flags = m_flags;
2250         key.m_hash = m_hash;
2251         key.m_functionConstructorParametersEndPosition = m_functionConstructorParametersEndPosition;
2252     }
2253 
2254 private:
2255     CachedUnlinkedSourceCode m_sourceCode;
2256     CachedString m_name;
2257     unsigned m_flags;
2258     unsigned m_hash;
2259     int m_functionConstructorParametersEndPosition;
2260 };
2261 
2262 class GenericCacheEntry {
2263 public:
2264     bool decode(Decoder&amp;, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp;) const;
<span class="line-added">2265     bool isStillValid(Decoder&amp;, const SourceCodeKey&amp;, CachedCodeBlockTag) const;</span>
2266 
2267 protected:
2268     GenericCacheEntry(Encoder&amp; encoder, CachedCodeBlockTag tag)
2269         : m_tag(tag)
2270     {
2271         m_bootSessionUUID.encode(encoder, bootSessionUUIDString());
2272     }
2273 
2274     CachedCodeBlockTag tag() const { return m_tag; }
2275 
<span class="line-added">2276     bool isUpToDate(Decoder&amp; decoder) const</span>
<span class="line-added">2277     {</span>
<span class="line-added">2278         if (m_cacheVersion != JSC_BYTECODE_CACHE_VERSION)</span>
<span class="line-added">2279             return false;</span>
<span class="line-added">2280         if (m_bootSessionUUID.decode(decoder) != bootSessionUUIDString())</span>
<span class="line-added">2281             return false;</span>
<span class="line-added">2282         return true;</span>
<span class="line-added">2283     }</span>
<span class="line-added">2284 </span>
2285 private:
2286     uint32_t m_cacheVersion { JSC_BYTECODE_CACHE_VERSION };
2287     CachedString m_bootSessionUUID;
2288     CachedCodeBlockTag m_tag;
2289 };
2290 
2291 template&lt;typename UnlinkedCodeBlockType&gt;
2292 class CacheEntry : public GenericCacheEntry {
2293 public:
2294     CacheEntry(Encoder&amp; encoder)
2295         : GenericCacheEntry(encoder, CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag)
2296     {
2297     }
2298 
2299     void encode(Encoder&amp; encoder, std::pair&lt;SourceCodeKey, const UnlinkedCodeBlockType*&gt; pair)
2300     {
2301         m_key.encode(encoder, pair.first);
2302         m_codeBlock.encode(encoder, pair.second);
2303     }
2304 
2305 private:
2306     friend GenericCacheEntry;
2307 
<span class="line-added">2308     bool isStillValid(Decoder&amp; decoder, const SourceCodeKey&amp; key) const</span>
<span class="line-added">2309     {</span>
<span class="line-added">2310         SourceCodeKey decodedKey;</span>
<span class="line-added">2311         m_key.decode(decoder, decodedKey);</span>
<span class="line-added">2312         return decodedKey == key;</span>
<span class="line-added">2313     }</span>
<span class="line-added">2314 </span>
2315     bool decode(Decoder&amp; decoder, std::pair&lt;SourceCodeKey, UnlinkedCodeBlockType*&gt;&amp; result) const
2316     {
2317         ASSERT(tag() == CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag);
2318         SourceCodeKey decodedKey;
2319         m_key.decode(decoder, decodedKey);
2320         result = { WTFMove(decodedKey), m_codeBlock.decode(decoder) };
2321         return true;
2322     }
2323 
2324     CachedSourceCodeKey m_key;
2325     CachedPtr&lt;CachedCodeBlockType&lt;UnlinkedCodeBlockType&gt;&gt; m_codeBlock;
2326 };
2327 
2328 bool GenericCacheEntry::decode(Decoder&amp; decoder, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp; result) const
2329 {
<span class="line-modified">2330     if (!isUpToDate(decoder))</span>


2331         return false;
2332 
2333     switch (m_tag) {
2334     case CachedProgramCodeBlockTag:
<span class="line-modified">2335         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedProgramCodeBlock*&gt;&amp;&gt;(result));</span>
2336     case CachedModuleCodeBlockTag:
<span class="line-modified">2337         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedModuleProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedModuleProgramCodeBlock*&gt;&amp;&gt;(result));</span>
2338     case CachedEvalCodeBlockTag:
2339         // We do not cache eval code blocks
2340         RELEASE_ASSERT_NOT_REACHED();
2341     }
2342     RELEASE_ASSERT_NOT_REACHED();
2343 #if COMPILER(MSVC)
2344     // Without this, MSVC will complain that this path does not return a value.
2345     return false;
2346 #endif
2347 }
2348 
<span class="line-added">2349 bool GenericCacheEntry::isStillValid(Decoder&amp; decoder, const SourceCodeKey&amp; key, CachedCodeBlockTag tag) const</span>
<span class="line-added">2350 {</span>
<span class="line-added">2351     if (!isUpToDate(decoder))</span>
<span class="line-added">2352         return false;</span>
<span class="line-added">2353 </span>
<span class="line-added">2354     switch (tag) {</span>
<span class="line-added">2355     case CachedProgramCodeBlockTag:</span>
<span class="line-added">2356         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedProgramCodeBlock&gt;*&gt;(this)-&gt;isStillValid(decoder, key);</span>
<span class="line-added">2357     case CachedModuleCodeBlockTag:</span>
<span class="line-added">2358         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedModuleProgramCodeBlock&gt;*&gt;(this)-&gt;isStillValid(decoder, key);</span>
<span class="line-added">2359     case CachedEvalCodeBlockTag:</span>
<span class="line-added">2360         // We do not cache eval code blocks</span>
<span class="line-added">2361         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">2362     }</span>
<span class="line-added">2363     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">2364     return false;</span>
<span class="line-added">2365 }</span>
<span class="line-added">2366 </span>
2367 template&lt;typename UnlinkedCodeBlockType&gt;
2368 void encodeCodeBlock(Encoder&amp; encoder, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)
2369 {
2370     auto* entry = encoder.template malloc&lt;CacheEntry&lt;UnlinkedCodeBlockType&gt;&gt;(encoder);
<span class="line-modified">2371     entry-&gt;encode(encoder, { key, jsCast&lt;const UnlinkedCodeBlockType*&gt;(codeBlock) });</span>
2372 }
2373 
<span class="line-modified">2374 RefPtr&lt;CachedBytecode&gt; encodeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock, FileSystem::PlatformFileHandle fd, BytecodeCacheError&amp; error)</span>
2375 {
2376     const ClassInfo* classInfo = codeBlock-&gt;classInfo(vm);
2377 
<span class="line-modified">2378     Encoder encoder(vm, fd);</span>
2379     if (classInfo == UnlinkedProgramCodeBlock::info())
2380         encodeCodeBlock&lt;UnlinkedProgramCodeBlock&gt;(encoder, key, codeBlock);
2381     else if (classInfo == UnlinkedModuleProgramCodeBlock::info())
2382         encodeCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;(encoder, key, codeBlock);
2383     else
2384         ASSERT(classInfo == UnlinkedEvalCodeBlock::info());
2385 
<span class="line-modified">2386     return encoder.release(error);</span>
<span class="line-added">2387 }</span>
<span class="line-added">2388 </span>
<span class="line-added">2389 RefPtr&lt;CachedBytecode&gt; encodeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)</span>
<span class="line-added">2390 {</span>
<span class="line-added">2391     BytecodeCacheError error;</span>
<span class="line-added">2392     return encodeCodeBlock(vm, key, codeBlock, FileSystem::invalidPlatformFileHandle, error);</span>
<span class="line-added">2393 }</span>
<span class="line-added">2394 </span>
<span class="line-added">2395 RefPtr&lt;CachedBytecode&gt; encodeFunctionCodeBlock(VM&amp; vm, const UnlinkedFunctionCodeBlock* codeBlock, BytecodeCacheError&amp; error)</span>
<span class="line-added">2396 {</span>
<span class="line-added">2397     Encoder encoder(vm);</span>
<span class="line-added">2398     encoder.malloc&lt;CachedFunctionCodeBlock&gt;()-&gt;encode(encoder, *codeBlock);</span>
<span class="line-added">2399     return encoder.release(error);</span>
2400 }
2401 
<span class="line-modified">2402 UnlinkedCodeBlock* decodeCodeBlockImpl(VM&amp; vm, const SourceCodeKey&amp; key, Ref&lt;CachedBytecode&gt; cachedBytecode)</span>
2403 {
<span class="line-modified">2404     const auto* cachedEntry = bitwise_cast&lt;const GenericCacheEntry*&gt;(cachedBytecode-&gt;data());</span>
<span class="line-modified">2405     Ref&lt;Decoder&gt; decoder = Decoder::create(vm, WTFMove(cachedBytecode), &amp;key.source().provider());</span>
2406     std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt; entry;
2407     {
2408         DeferGC deferGC(vm.heap);
<span class="line-modified">2409         if (!cachedEntry-&gt;decode(decoder.get(), entry))</span>
2410             return nullptr;
2411     }
2412 
2413     if (entry.first != key)
2414         return nullptr;
2415     return entry.second;
2416 }
2417 
<span class="line-added">2418 bool isCachedBytecodeStillValid(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, const SourceCodeKey&amp; key, SourceCodeType type)</span>
<span class="line-added">2419 {</span>
<span class="line-added">2420     const void* buffer = cachedBytecode-&gt;data();</span>
<span class="line-added">2421     size_t size = cachedBytecode-&gt;size();</span>
<span class="line-added">2422     if (!size)</span>
<span class="line-added">2423         return false;</span>
<span class="line-added">2424     const auto* cachedEntry = bitwise_cast&lt;const GenericCacheEntry*&gt;(buffer);</span>
<span class="line-added">2425     Ref&lt;Decoder&gt; decoder = Decoder::create(vm, WTFMove(cachedBytecode));</span>
<span class="line-added">2426     return cachedEntry-&gt;isStillValid(decoder.get(), key, tagFromSourceCodeType(type));</span>
<span class="line-added">2427 }</span>
<span class="line-added">2428 </span>
<span class="line-added">2429 void decodeFunctionCodeBlock(Decoder&amp; decoder, int32_t cachedFunctionCodeBlockOffset, WriteBarrier&lt;UnlinkedFunctionCodeBlock&gt;&amp; codeBlock, const JSCell* owner)</span>
<span class="line-added">2430 {</span>
<span class="line-added">2431     ASSERT(decoder.vm().heap.isDeferred());</span>
<span class="line-added">2432     auto* cachedCodeBlock = static_cast&lt;const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;*&gt;(decoder.ptrForOffsetFromBase(cachedFunctionCodeBlockOffset));</span>
<span class="line-added">2433     cachedCodeBlock-&gt;decode(decoder, codeBlock, owner);</span>
<span class="line-added">2434 }</span>
<span class="line-added">2435 </span>
2436 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="ButterflyInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CachedTypes.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>