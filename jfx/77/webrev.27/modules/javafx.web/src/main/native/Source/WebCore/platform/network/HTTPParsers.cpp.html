<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/network/HTTPParsers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006 Alexey Proskuryakov (ap@webkit.org)
   3  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   4  * Copyright (C) 2009 Torch Mobile Inc. http://www.torchmobile.com/
   5  * Copyright (C) 2009 Google Inc. All rights reserved.
   6  * Copyright (C) 2011 Apple Inc. All Rights Reserved.
   7  *
   8  * Redistribution and use in source and binary forms, with or without
   9  * modification, are permitted provided that the following conditions
  10  * are met:
  11  *
  12  * 1.  Redistributions of source code must retain the above copyright
  13  *     notice, this list of conditions and the following disclaimer.
  14  * 2.  Redistributions in binary form must reproduce the above copyright
  15  *     notice, this list of conditions and the following disclaimer in the
  16  *     documentation and/or other materials provided with the distribution.
  17  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  18  *     its contributors may be used to endorse or promote products derived
  19  *     from this software without specific prior written permission.
  20  *
  21  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  22  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  23  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  24  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  25  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  26  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  27  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  28  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  30  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31  */
  32 
  33 #include &quot;config.h&quot;
  34 #include &quot;HTTPParsers.h&quot;
  35 
  36 #include &quot;HTTPHeaderNames.h&quot;
  37 #include &lt;wtf/DateMath.h&gt;
  38 #include &lt;wtf/Language.h&gt;
  39 #include &lt;wtf/NeverDestroyed.h&gt;
  40 #include &lt;wtf/Optional.h&gt;
  41 #include &lt;wtf/text/StringBuilder.h&gt;
  42 #include &lt;wtf/unicode/CharacterNames.h&gt;
  43 
  44 
  45 namespace WebCore {
  46 
  47 // true if there is more to parse, after incrementing pos past whitespace.
  48 // Note: Might return pos == str.length()
  49 static inline bool skipWhiteSpace(const String&amp; str, unsigned&amp; pos)
  50 {
  51     unsigned len = str.length();
  52 
  53     while (pos &lt; len &amp;&amp; (str[pos] == &#39;\t&#39; || str[pos] == &#39; &#39;))
  54         ++pos;
  55 
  56     return pos &lt; len;
  57 }
  58 
  59 // Returns true if the function can match the whole token (case insensitive)
  60 // incrementing pos on match, otherwise leaving pos unchanged.
  61 // Note: Might return pos == str.length()
  62 static inline bool skipToken(const String&amp; str, unsigned&amp; pos, const char* token)
  63 {
  64     unsigned len = str.length();
  65     unsigned current = pos;
  66 
  67     while (current &lt; len &amp;&amp; *token) {
  68         if (toASCIILower(str[current]) != *token++)
  69             return false;
  70         ++current;
  71     }
  72 
  73     if (*token)
  74         return false;
  75 
  76     pos = current;
  77     return true;
  78 }
  79 
  80 // True if the expected equals sign is seen and there is more to follow.
  81 static inline bool skipEquals(const String&amp; str, unsigned &amp;pos)
  82 {
  83     return skipWhiteSpace(str, pos) &amp;&amp; str[pos++] == &#39;=&#39; &amp;&amp; skipWhiteSpace(str, pos);
  84 }
  85 
  86 // True if a value present, incrementing pos to next space or semicolon, if any.
  87 // Note: might return pos == str.length().
  88 static inline bool skipValue(const String&amp; str, unsigned&amp; pos)
  89 {
  90     unsigned start = pos;
  91     unsigned len = str.length();
  92     while (pos &lt; len) {
  93         if (str[pos] == &#39; &#39; || str[pos] == &#39;\t&#39; || str[pos] == &#39;;&#39;)
  94             break;
  95         ++pos;
  96     }
  97     return pos != start;
  98 }
  99 
 100 // True if characters which satisfy the predicate are present, incrementing
 101 // &quot;pos&quot; to the next character which does not satisfy the predicate.
 102 // Note: might return pos == str.length().
 103 static inline bool skipWhile(const String&amp; str, unsigned&amp; pos, const WTF::Function&lt;bool(const UChar)&gt;&amp; predicate)
 104 {
 105     const unsigned start = pos;
 106     const unsigned len = str.length();
 107     while (pos &lt; len &amp;&amp; predicate(str[pos]))
 108         ++pos;
 109     return pos != start;
 110 }
 111 
 112 // See RFC 7230, Section 3.1.2.
 113 bool isValidReasonPhrase(const String&amp; value)
 114 {
 115     for (unsigned i = 0; i &lt; value.length(); ++i) {
 116         UChar c = value[i];
 117         if (c == 0x7F || !isLatin1(c) || (c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;))
 118             return false;
 119     }
 120     return true;
 121 }
 122 
 123 // See https://fetch.spec.whatwg.org/#concept-header
 124 bool isValidHTTPHeaderValue(const String&amp; value)
 125 {
 126     UChar c = value[0];
 127     if (c == &#39; &#39; || c == &#39;\t&#39;)
 128         return false;
 129     c = value[value.length() - 1];
 130     if (c == &#39; &#39; || c == &#39;\t&#39;)
 131         return false;
 132     for (unsigned i = 0; i &lt; value.length(); ++i) {
 133         c = value[i];
 134         ASSERT(isLatin1(c));
 135         if (c == 0x00 || c == 0x0A || c == 0x0D)
 136             return false;
 137     }
 138     return true;
 139 }
 140 
 141 // See RFC 7230, Section 3.2.6.
 142 static bool isDelimiterCharacter(const UChar c)
 143 {
 144     // DQUOTE and &quot;(),/:;&lt;=&gt;?@[\]{}&quot;
 145     return (c == &#39;&quot;&#39; || c == &#39;(&#39; || c == &#39;)&#39; || c == &#39;,&#39; || c == &#39;/&#39; || c == &#39;:&#39; || c == &#39;;&#39;
 146         || c == &#39;&lt;&#39; || c == &#39;=&#39; || c == &#39;&gt;&#39; || c == &#39;?&#39; || c == &#39;@&#39; || c == &#39;[&#39; || c == &#39;\\&#39;
 147         || c == &#39;]&#39; || c == &#39;{&#39; || c == &#39;}&#39;);
 148 }
 149 
 150 // See RFC 7230, Section 3.2.6.
 151 static inline bool isVisibleCharacter(const UChar c)
 152 {
 153     // VCHAR = %x21-7E
 154     return (c &gt;= 0x21 &amp;&amp; c &lt;= 0x7E);
 155 }
 156 
 157 // See RFC 7230, Section 3.2.6.
 158 static inline bool isOctectInFieldContentCharacter(const UChar c)
 159 {
 160     // obs-text = %x80-FF
 161     return (c &gt;= 0x80 &amp;&amp; c &lt;= 0xFF);
 162 }
 163 
 164 // See RFC 7230, Section 3.2.6.
 165 static bool isCommentTextCharacter(const UChar c)
 166 {
 167     // ctext = HTAB / SP
 168     //       / %x21-27 ; &#39;!&#39;-&#39;&#39;&#39;
 169     //       / %x2A-5B ; &#39;*&#39;-&#39;[&#39;
 170     //       / %x5D-7E ; &#39;]&#39;-&#39;~&#39;
 171     //       / obs-text
 172     return (c == &#39;\t&#39; || c == &#39; &#39;
 173         || (c &gt;= 0x21 &amp;&amp; c &lt;= 0x27)
 174         || (c &gt;= 0x2A &amp;&amp; c &lt;= 0x5B)
 175         || (c &gt;= 0x5D &amp;&amp; c &lt;= 0x7E)
 176         || isOctectInFieldContentCharacter(c));
 177 }
 178 
 179 // See RFC 7231, Section 5.3.2.
 180 bool isValidAcceptHeaderValue(const String&amp; value)
 181 {
 182     for (unsigned i = 0; i &lt; value.length(); ++i) {
 183         UChar c = value[i];
 184 
 185         // First check for alphanumeric for performance reasons then whitelist four delimiter characters.
 186         if (isASCIIAlphanumeric(c) || c == &#39;,&#39; || c == &#39;/&#39; || c == &#39;;&#39; || c == &#39;=&#39;)
 187             continue;
 188 
 189         ASSERT(isLatin1(c));
 190         if (c == 0x7F || (c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;))
 191             return false;
 192 
 193         if (isDelimiterCharacter(c))
 194             return false;
 195     }
 196 
 197     return true;
 198 }
 199 
 200 // See RFC 7231, Section 5.3.5 and 3.1.3.2.
 201 bool isValidLanguageHeaderValue(const String&amp; value)
 202 {
 203     for (unsigned i = 0; i &lt; value.length(); ++i) {
 204         UChar c = value[i];
 205         if (isASCIIAlphanumeric(c) || c == &#39; &#39; || c == &#39;*&#39; || c == &#39;,&#39; || c == &#39;-&#39; || c == &#39;.&#39; || c == &#39;;&#39; || c == &#39;=&#39;)
 206             continue;
 207         return false;
 208     }
 209 
 210     // FIXME: Validate further by splitting into language tags and optional quality
 211     // values (q=) and then check each language tag.
 212     // Language tags https://tools.ietf.org/html/rfc7231#section-3.1.3.1
 213     // Language tag syntax https://tools.ietf.org/html/bcp47#section-2.1
 214     return true;
 215 }
 216 
 217 // See RFC 7230, Section 3.2.6.
 218 static inline bool isHTTPTokenCharacter(const UChar c)
 219 {
 220     // Any VCHAR, except delimiters
 221     return c &gt; 0x20 &amp;&amp; c &lt; 0x7F &amp;&amp; !isDelimiterCharacter(c);
 222 }
 223 
 224 // See RFC 7230, Section 3.2.6.
 225 bool isValidHTTPToken(const String&amp; value)
 226 {
 227     if (value.isEmpty())
 228         return false;
 229     auto valueStringView = StringView(value);
 230     for (UChar c : valueStringView.codeUnits()) {
 231         if (!isHTTPTokenCharacter(c))
 232             return false;
 233     }
 234     return true;
 235 }
 236 
 237 // True if the character at the given position satisifies a predicate, incrementing &quot;pos&quot; by one.
 238 // Note: Might return pos == str.length()
 239 static inline bool skipCharacter(const String&amp; value, unsigned&amp; pos, WTF::Function&lt;bool(const UChar)&gt;&amp;&amp; predicate)
 240 {
 241     if (pos &lt; value.length() &amp;&amp; predicate(value[pos])) {
 242         ++pos;
 243         return true;
 244     }
 245     return false;
 246 }
 247 
 248 // True if the &quot;expected&quot; character is at the given position, incrementing &quot;pos&quot; by one.
 249 // Note: Might return pos == str.length()
 250 static inline bool skipCharacter(const String&amp; value, unsigned&amp; pos, const UChar expected)
 251 {
 252     return skipCharacter(value, pos, [expected](const UChar c) {
 253         return c == expected;
 254     });
 255 }
 256 
 257 // True if a quoted pair is present, incrementing &quot;pos&quot; to the position after the quoted pair.
 258 // Note: Might return pos == str.length()
 259 // See RFC 7230, Section 3.2.6.
 260 static constexpr auto QuotedPairStartCharacter = &#39;\\&#39;;
 261 static bool skipQuotedPair(const String&amp; value, unsigned&amp; pos)
 262 {
 263     // quoted-pair = &quot;\&quot; ( HTAB / SP / VCHAR / obs-text )
 264     if (!skipCharacter(value, pos, QuotedPairStartCharacter))
 265         return false;
 266 
 267     return skipCharacter(value, pos, &#39;\t&#39;)
 268         || skipCharacter(value, pos, &#39; &#39;)
 269         || skipCharacter(value, pos, isVisibleCharacter)
 270         || skipCharacter(value, pos, isOctectInFieldContentCharacter);
 271 }
 272 
 273 // True if a comment is present, incrementing &quot;pos&quot; to the position after the comment.
 274 // Note: Might return pos == str.length()
 275 // See RFC 7230, Section 3.2.6.
 276 static constexpr auto CommentStartCharacter = &#39;(&#39;;
 277 static constexpr auto CommentEndCharacter = &#39;)&#39;;
 278 static bool skipComment(const String&amp; value, unsigned&amp; pos)
 279 {
 280     // comment = &quot;(&quot; *( ctext / quoted-pair / comment ) &quot;)&quot;
 281     // ctext   = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
 282     if (!skipCharacter(value, pos, CommentStartCharacter))
 283         return false;
 284 
 285     const unsigned end = value.length();
 286     while (pos &lt; end &amp;&amp; value[pos] != CommentEndCharacter) {
 287         switch (value[pos]) {
 288         case CommentStartCharacter:
 289             if (!skipComment(value, pos))
 290                 return false;
 291             break;
 292         case QuotedPairStartCharacter:
 293             if (!skipQuotedPair(value, pos))
 294                 return false;
 295             break;
 296         default:
 297             if (!skipWhile(value, pos, isCommentTextCharacter))
 298                 return false;
 299         }
 300     }
 301     return skipCharacter(value, pos, CommentEndCharacter);
 302 }
 303 
 304 // True if an HTTP header token is present, incrementing &quot;pos&quot; to the position after it.
 305 // Note: Might return pos == str.length()
 306 // See RFC 7230, Section 3.2.6.
 307 static bool skipHTTPToken(const String&amp; value, unsigned&amp; pos)
 308 {
 309     return skipWhile(value, pos, isHTTPTokenCharacter);
 310 }
 311 
 312 // True if a product specifier (as in an User-Agent header) is present, incrementing &quot;pos&quot; to the position after it.
 313 // Note: Might return pos == str.length()
 314 // See RFC 7231, Section 5.5.3.
 315 static bool skipUserAgentProduct(const String&amp; value, unsigned&amp; pos)
 316 {
 317     // product         = token [&quot;/&quot; product-version]
 318     // product-version = token
 319     if (!skipHTTPToken(value, pos))
 320         return false;
 321     if (skipCharacter(value, pos, &#39;/&#39;))
 322         return skipHTTPToken(value, pos);
 323     return true;
 324 }
 325 
 326 // See RFC 7231, Section 5.5.3
 327 bool isValidUserAgentHeaderValue(const String&amp; value)
 328 {
 329     // User-Agent = product *( RWS ( product / comment ) )
 330     unsigned pos = 0;
 331     if (!skipUserAgentProduct(value, pos))
 332         return false;
 333 
 334     while (pos &lt; value.length()) {
 335         if (!skipWhiteSpace(value, pos))
 336             return false;
 337         if (value[pos] == CommentStartCharacter) {
 338             if (!skipComment(value, pos))
 339                 return false;
 340         } else {
 341             if (!skipUserAgentProduct(value, pos))
 342                 return false;
 343         }
 344     }
 345 
 346     return pos == value.length();
 347 }
 348 
 349 static const size_t maxInputSampleSize = 128;
 350 static String trimInputSample(const char* p, size_t length)
 351 {
 352     String s = String(p, std::min&lt;size_t&gt;(length, maxInputSampleSize));
 353     if (length &gt; maxInputSampleSize)
 354         s.append(horizontalEllipsis);
 355     return s;
 356 }
 357 
 358 bool parseHTTPRefresh(const String&amp; refresh, double&amp; delay, String&amp; url)
 359 {
 360     unsigned len = refresh.length();
 361     unsigned pos = 0;
 362 
 363     if (!skipWhiteSpace(refresh, pos))
 364         return false;
 365 
 366     while (pos != len &amp;&amp; refresh[pos] != &#39;,&#39; &amp;&amp; refresh[pos] != &#39;;&#39;)
 367         ++pos;
 368 
 369     if (pos == len) { // no URL
 370         url = String();
 371         bool ok;
 372         delay = refresh.stripWhiteSpace().toDouble(&amp;ok);
 373         return ok;
 374     } else {
 375         bool ok;
 376         delay = refresh.left(pos).stripWhiteSpace().toDouble(&amp;ok);
 377         if (!ok)
 378             return false;
 379 
 380         ++pos;
 381         skipWhiteSpace(refresh, pos);
 382         unsigned urlStartPos = pos;
 383         if (refresh.findIgnoringASCIICase(&quot;url&quot;, urlStartPos) == urlStartPos) {
 384             urlStartPos += 3;
 385             skipWhiteSpace(refresh, urlStartPos);
 386             if (refresh[urlStartPos] == &#39;=&#39;) {
 387                 ++urlStartPos;
 388                 skipWhiteSpace(refresh, urlStartPos);
 389             } else
 390                 urlStartPos = pos;  // e.g. &quot;Refresh: 0; url.html&quot;
 391         }
 392 
 393         unsigned urlEndPos = len;
 394 
 395         if (refresh[urlStartPos] == &#39;&quot;&#39; || refresh[urlStartPos] == &#39;\&#39;&#39;) {
 396             UChar quotationMark = refresh[urlStartPos];
 397             urlStartPos++;
 398             while (urlEndPos &gt; urlStartPos) {
 399                 urlEndPos--;
 400                 if (refresh[urlEndPos] == quotationMark)
 401                     break;
 402             }
 403 
 404             // https://bugs.webkit.org/show_bug.cgi?id=27868
 405             // Sometimes there is no closing quote for the end of the URL even though there was an opening quote.
 406             // If we looped over the entire alleged URL string back to the opening quote, just use everything
 407             // after the opening quote instead.
 408             if (urlEndPos == urlStartPos)
 409                 urlEndPos = len;
 410         }
 411 
 412         url = refresh.substring(urlStartPos, urlEndPos - urlStartPos).stripWhiteSpace();
 413         return true;
 414     }
 415 }
 416 
 417 Optional&lt;WallTime&gt; parseHTTPDate(const String&amp; value)
 418 {
 419     double dateInMillisecondsSinceEpoch = parseDateFromNullTerminatedCharacters(value.utf8().data());
 420     if (!std::isfinite(dateInMillisecondsSinceEpoch))
 421         return WTF::nullopt;
 422     // This assumes system_clock epoch equals Unix epoch which is true for all implementations but unspecified.
 423     // FIXME: The parsing function should be switched to WallTime too.
 424     return WallTime::fromRawSeconds(dateInMillisecondsSinceEpoch / 1000.0);
 425 }
 426 
 427 // FIXME: This function doesn&#39;t comply with RFC 6266.
 428 // For example, this function doesn&#39;t handle the interaction between &quot; and ;
 429 // that arises from quoted-string, nor does this function properly unquote
 430 // attribute values. Further this function appears to process parameter names
 431 // in a case-sensitive manner. (There are likely other bugs as well.)
 432 String filenameFromHTTPContentDisposition(const String&amp; value)
 433 {
 434     for (auto&amp; keyValuePair : value.split(&#39;;&#39;)) {
 435         size_t valueStartPos = keyValuePair.find(&#39;=&#39;);
 436         if (valueStartPos == notFound)
 437             continue;
 438 
 439         String key = keyValuePair.left(valueStartPos).stripWhiteSpace();
 440 
 441         if (key.isEmpty() || key != &quot;filename&quot;)
 442             continue;
 443 
 444         String value = keyValuePair.substring(valueStartPos + 1).stripWhiteSpace();
 445 
 446         // Remove quotes if there are any
 447         if (value[0] == &#39;\&quot;&#39;)
 448             value = value.substring(1, value.length() - 2);
 449 
 450         return value;
 451     }
 452 
 453     return String();
 454 }
 455 
 456 String extractMIMETypeFromMediaType(const String&amp; mediaType)
 457 {
 458     unsigned position = 0;
 459     unsigned length = mediaType.length();
 460 
 461     for (; position &lt; length; ++position) {
 462         UChar c = mediaType[position];
 463         if (c != &#39;\t&#39; &amp;&amp; c != &#39; &#39;)
 464             break;
 465     }
 466 
 467     if (position == length)
 468         return mediaType;
 469 
 470     unsigned typeStart = position;
 471 
 472     unsigned typeEnd = position;
 473     for (; position &lt; length; ++position) {
 474         UChar c = mediaType[position];
 475 
 476         // While RFC 2616 does not allow it, other browsers allow multiple values in the HTTP media
 477         // type header field, Content-Type. In such cases, the media type string passed here may contain
 478         // the multiple values separated by commas. For now, this code ignores text after the first comma,
 479         // which prevents it from simply failing to parse such types altogether. Later for better
 480         // compatibility we could consider using the first or last valid MIME type instead.
 481         // See https://bugs.webkit.org/show_bug.cgi?id=25352 for more discussion.
 482         if (c == &#39;,&#39;)
 483             break;
 484 
 485         if (c == &#39;\t&#39; || c == &#39; &#39; || c == &#39;;&#39;)
 486             break;
 487 
 488         typeEnd = position + 1;
 489     }
 490 
 491     return mediaType.substring(typeStart, typeEnd - typeStart);
 492 }
 493 
 494 String extractCharsetFromMediaType(const String&amp; mediaType)
 495 {
 496     unsigned int pos, len;
 497     findCharsetInMediaType(mediaType, pos, len);
 498     return mediaType.substring(pos, len);
 499 }
 500 
 501 void findCharsetInMediaType(const String&amp; mediaType, unsigned int&amp; charsetPos, unsigned int&amp; charsetLen, unsigned int start)
 502 {
 503     charsetPos = start;
 504     charsetLen = 0;
 505 
 506     size_t pos = start;
 507     unsigned length = mediaType.length();
 508 
 509     while (pos &lt; length) {
 510         pos = mediaType.findIgnoringASCIICase(&quot;charset&quot;, pos);
 511         if (pos == notFound || pos == 0) {
 512             charsetLen = 0;
 513             return;
 514         }
 515 
 516         // is what we found a beginning of a word?
 517         if (mediaType[pos-1] &gt; &#39; &#39; &amp;&amp; mediaType[pos-1] != &#39;;&#39;) {
 518             pos += 7;
 519             continue;
 520         }
 521 
 522         pos += 7;
 523 
 524         // skip whitespace
 525         while (pos != length &amp;&amp; mediaType[pos] &lt;= &#39; &#39;)
 526             ++pos;
 527 
 528         if (mediaType[pos++] != &#39;=&#39;) // this &quot;charset&quot; substring wasn&#39;t a parameter name, but there may be others
 529             continue;
 530 
 531         while (pos != length &amp;&amp; (mediaType[pos] &lt;= &#39; &#39; || mediaType[pos] == &#39;&quot;&#39; || mediaType[pos] == &#39;\&#39;&#39;))
 532             ++pos;
 533 
 534         // we don&#39;t handle spaces within quoted parameter values, because charset names cannot have any
 535         unsigned endpos = pos;
 536         while (pos != length &amp;&amp; mediaType[endpos] &gt; &#39; &#39; &amp;&amp; mediaType[endpos] != &#39;&quot;&#39; &amp;&amp; mediaType[endpos] != &#39;\&#39;&#39; &amp;&amp; mediaType[endpos] != &#39;;&#39;)
 537             ++endpos;
 538 
 539         charsetPos = pos;
 540         charsetLen = endpos - pos;
 541         return;
 542     }
 543 }
 544 
 545 XSSProtectionDisposition parseXSSProtectionHeader(const String&amp; header, String&amp; failureReason, unsigned&amp; failurePosition, String&amp; reportURL)
 546 {
 547     static NeverDestroyed&lt;String&gt; failureReasonInvalidToggle(MAKE_STATIC_STRING_IMPL(&quot;expected 0 or 1&quot;));
 548     static NeverDestroyed&lt;String&gt; failureReasonInvalidSeparator(MAKE_STATIC_STRING_IMPL(&quot;expected semicolon&quot;));
 549     static NeverDestroyed&lt;String&gt; failureReasonInvalidEquals(MAKE_STATIC_STRING_IMPL(&quot;expected equals sign&quot;));
 550     static NeverDestroyed&lt;String&gt; failureReasonInvalidMode(MAKE_STATIC_STRING_IMPL(&quot;invalid mode directive&quot;));
 551     static NeverDestroyed&lt;String&gt; failureReasonInvalidReport(MAKE_STATIC_STRING_IMPL(&quot;invalid report directive&quot;));
 552     static NeverDestroyed&lt;String&gt; failureReasonDuplicateMode(MAKE_STATIC_STRING_IMPL(&quot;duplicate mode directive&quot;));
 553     static NeverDestroyed&lt;String&gt; failureReasonDuplicateReport(MAKE_STATIC_STRING_IMPL(&quot;duplicate report directive&quot;));
 554     static NeverDestroyed&lt;String&gt; failureReasonInvalidDirective(MAKE_STATIC_STRING_IMPL(&quot;unrecognized directive&quot;));
 555 
 556     unsigned pos = 0;
 557 
 558     if (!skipWhiteSpace(header, pos))
 559         return XSSProtectionDisposition::Enabled;
 560 
 561     if (header[pos] == &#39;0&#39;)
 562         return XSSProtectionDisposition::Disabled;
 563 
 564     if (header[pos++] != &#39;1&#39;) {
 565         failureReason = failureReasonInvalidToggle;
 566         return XSSProtectionDisposition::Invalid;
 567     }
 568 
 569     XSSProtectionDisposition result = XSSProtectionDisposition::Enabled;
 570     bool modeDirectiveSeen = false;
 571     bool reportDirectiveSeen = false;
 572 
 573     while (1) {
 574         // At end of previous directive: consume whitespace, semicolon, and whitespace.
 575         if (!skipWhiteSpace(header, pos))
 576             return result;
 577 
 578         if (header[pos++] != &#39;;&#39;) {
 579             failureReason = failureReasonInvalidSeparator;
 580             failurePosition = pos;
 581             return XSSProtectionDisposition::Invalid;
 582         }
 583 
 584         if (!skipWhiteSpace(header, pos))
 585             return result;
 586 
 587         // At start of next directive.
 588         if (skipToken(header, pos, &quot;mode&quot;)) {
 589             if (modeDirectiveSeen) {
 590                 failureReason = failureReasonDuplicateMode;
 591                 failurePosition = pos;
 592                 return XSSProtectionDisposition::Invalid;
 593             }
 594             modeDirectiveSeen = true;
 595             if (!skipEquals(header, pos)) {
 596                 failureReason = failureReasonInvalidEquals;
 597                 failurePosition = pos;
 598                 return XSSProtectionDisposition::Invalid;
 599             }
 600             if (!skipToken(header, pos, &quot;block&quot;)) {
 601                 failureReason = failureReasonInvalidMode;
 602                 failurePosition = pos;
 603                 return XSSProtectionDisposition::Invalid;
 604             }
 605             result = XSSProtectionDisposition::BlockEnabled;
 606         } else if (skipToken(header, pos, &quot;report&quot;)) {
 607             if (reportDirectiveSeen) {
 608                 failureReason = failureReasonDuplicateReport;
 609                 failurePosition = pos;
 610                 return XSSProtectionDisposition::Invalid;
 611             }
 612             reportDirectiveSeen = true;
 613             if (!skipEquals(header, pos)) {
 614                 failureReason = failureReasonInvalidEquals;
 615                 failurePosition = pos;
 616                 return XSSProtectionDisposition::Invalid;
 617             }
 618             size_t startPos = pos;
 619             if (!skipValue(header, pos)) {
 620                 failureReason = failureReasonInvalidReport;
 621                 failurePosition = pos;
 622                 return XSSProtectionDisposition::Invalid;
 623             }
 624             reportURL = header.substring(startPos, pos - startPos);
 625             failurePosition = startPos; // If later semantic check deems unacceptable.
 626         } else {
 627             failureReason = failureReasonInvalidDirective;
 628             failurePosition = pos;
 629             return XSSProtectionDisposition::Invalid;
 630         }
 631     }
 632 }
 633 
 634 ContentTypeOptionsDisposition parseContentTypeOptionsHeader(StringView header)
 635 {
 636     StringView leftToken = header.left(header.find(&#39;,&#39;));
 637     if (equalLettersIgnoringASCIICase(stripLeadingAndTrailingHTTPSpaces(leftToken), &quot;nosniff&quot;))
 638         return ContentTypeOptionsNosniff;
 639     return ContentTypeOptionsNone;
 640 }
 641 
 642 // For example: &quot;HTTP/1.1 200 OK&quot; =&gt; &quot;OK&quot;.
 643 // Note that HTTP/2 does not include a reason phrase, so we return the empty atom.
 644 AtomString extractReasonPhraseFromHTTPStatusLine(const String&amp; statusLine)
 645 {
 646     StringView view = statusLine;
 647     size_t spacePos = view.find(&#39; &#39;);
 648 
 649     // Remove status code from the status line.
 650     spacePos = view.find(&#39; &#39;, spacePos + 1);
 651     if (spacePos == notFound)
 652         return emptyAtom();
 653 
 654     return view.substring(spacePos + 1).toAtomString();
 655 }
 656 
 657 XFrameOptionsDisposition parseXFrameOptionsHeader(const String&amp; header)
 658 {
 659     XFrameOptionsDisposition result = XFrameOptionsNone;
 660 
 661     if (header.isEmpty())
 662         return result;
 663 
 664     for (auto&amp; currentHeader : header.split(&#39;,&#39;)) {
 665         currentHeader = currentHeader.stripWhiteSpace();
 666         XFrameOptionsDisposition currentValue = XFrameOptionsNone;
 667         if (equalLettersIgnoringASCIICase(currentHeader, &quot;deny&quot;))
 668             currentValue = XFrameOptionsDeny;
 669         else if (equalLettersIgnoringASCIICase(currentHeader, &quot;sameorigin&quot;))
 670             currentValue = XFrameOptionsSameOrigin;
 671         else if (equalLettersIgnoringASCIICase(currentHeader, &quot;allowall&quot;))
 672             currentValue = XFrameOptionsAllowAll;
 673         else
 674             currentValue = XFrameOptionsInvalid;
 675 
 676         if (result == XFrameOptionsNone)
 677             result = currentValue;
 678         else if (result != currentValue)
 679             return XFrameOptionsConflict;
 680     }
 681     return result;
 682 }
 683 
 684 bool parseRange(const String&amp; range, long long&amp; rangeOffset, long long&amp; rangeEnd, long long&amp; rangeSuffixLength)
 685 {
 686     // The format of &quot;Range&quot; header is defined in RFC 2616 Section 14.35.1.
 687     // http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1
 688     // We don&#39;t support multiple range requests.
 689 
 690     rangeOffset = rangeEnd = rangeSuffixLength = -1;
 691 
 692     // The &quot;bytes&quot; unit identifier should be present.
 693     static const unsigned bytesLength = 6;
 694     if (!startsWithLettersIgnoringASCIICase(range, &quot;bytes=&quot;))
 695         return false;
 696     // FIXME: The rest of this should use StringView.
 697     String byteRange = range.substring(bytesLength);
 698 
 699     // The &#39;-&#39; character needs to be present.
 700     int index = byteRange.find(&#39;-&#39;);
 701     if (index == -1)
 702         return false;
 703 
 704     // If the &#39;-&#39; character is at the beginning, the suffix length, which specifies the last N bytes, is provided.
 705     // Example:
 706     //     -500
 707     if (!index) {
 708         String suffixLengthString = byteRange.substring(index + 1).stripWhiteSpace();
 709         bool ok;
 710         long long value = suffixLengthString.toInt64Strict(&amp;ok);
 711         if (ok)
 712             rangeSuffixLength = value;
 713         return true;
 714     }
 715 
 716     // Otherwise, the first-byte-position and the last-byte-position are provied.
 717     // Examples:
 718     //     0-499
 719     //     500-
 720     String firstBytePosStr = byteRange.left(index).stripWhiteSpace();
 721     bool ok;
 722     long long firstBytePos = firstBytePosStr.toInt64Strict(&amp;ok);
 723     if (!ok)
 724         return false;
 725 
 726     String lastBytePosStr = byteRange.substring(index + 1).stripWhiteSpace();
 727     long long lastBytePos = -1;
 728     if (!lastBytePosStr.isEmpty()) {
 729         lastBytePos = lastBytePosStr.toInt64Strict(&amp;ok);
 730         if (!ok)
 731             return false;
 732     }
 733 
 734     if (firstBytePos &lt; 0 || !(lastBytePos == -1 || lastBytePos &gt;= firstBytePos))
 735         return false;
 736 
 737     rangeOffset = firstBytePos;
 738     rangeEnd = lastBytePos;
 739     return true;
 740 }
 741 
 742 // HTTP/1.1 - RFC 2616
 743 // http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1
 744 // Request-Line = Method SP Request-URI SP HTTP-Version CRLF
 745 size_t parseHTTPRequestLine(const char* data, size_t length, String&amp; failureReason, String&amp; method, String&amp; url, HTTPVersion&amp; httpVersion)
 746 {
 747     method = String();
 748     url = String();
 749     httpVersion = Unknown;
 750 
 751     const char* space1 = 0;
 752     const char* space2 = 0;
 753     const char* p;
 754     size_t consumedLength;
 755 
 756     for (p = data, consumedLength = 0; consumedLength &lt; length; p++, consumedLength++) {
 757         if (*p == &#39; &#39;) {
 758             if (!space1)
 759                 space1 = p;
 760             else if (!space2)
 761                 space2 = p;
 762         } else if (*p == &#39;\n&#39;)
 763             break;
 764     }
 765 
 766     // Haven&#39;t finished header line.
 767     if (consumedLength == length) {
 768         failureReason = &quot;Incomplete Request Line&quot;_s;
 769         return 0;
 770     }
 771 
 772     // RequestLine does not contain 3 parts.
 773     if (!space1 || !space2) {
 774         failureReason = &quot;Request Line does not appear to contain: &lt;Method&gt; &lt;Url&gt; &lt;HTTPVersion&gt;.&quot;_s;
 775         return 0;
 776     }
 777 
 778     // The line must end with &quot;\r\n&quot;.
 779     const char* end = p + 1;
 780     if (*(end - 2) != &#39;\r&#39;) {
 781         failureReason = &quot;Request line does not end with CRLF&quot;_s;
 782         return 0;
 783     }
 784 
 785     // Request Method.
 786     method = String(data, space1 - data); // For length subtract 1 for space, but add 1 for data being the first character.
 787 
 788     // Request URI.
 789     url = String(space1 + 1, space2 - space1 - 1); // For length subtract 1 for space.
 790 
 791     // HTTP Version.
 792     String httpVersionString(space2 + 1, end - space2 - 3); // For length subtract 1 for space, and 2 for &quot;\r\n&quot;.
 793     if (httpVersionString.length() != 8 || !httpVersionString.startsWith(&quot;HTTP/1.&quot;))
 794         httpVersion = Unknown;
 795     else if (httpVersionString[7] == &#39;0&#39;)
 796         httpVersion = HTTP_1_0;
 797     else if (httpVersionString[7] == &#39;1&#39;)
 798         httpVersion = HTTP_1_1;
 799     else
 800         httpVersion = Unknown;
 801 
 802     return end - data;
 803 }
 804 
 805 static inline bool isValidHeaderNameCharacter(const char* character)
 806 {
 807     // https://tools.ietf.org/html/rfc7230#section-3.2
 808     // A header name should only contain one or more of
 809     // alphanumeric or ! # $ % &amp; &#39; * + - . ^ _ ` | ~
 810     if (isASCIIAlphanumeric(*character))
 811         return true;
 812     switch (*character) {
 813     case &#39;!&#39;:
 814     case &#39;#&#39;:
 815     case &#39;$&#39;:
 816     case &#39;%&#39;:
 817     case &#39;&amp;&#39;:
 818     case &#39;\&#39;&#39;:
 819     case &#39;*&#39;:
 820     case &#39;+&#39;:
 821     case &#39;-&#39;:
 822     case &#39;.&#39;:
 823     case &#39;^&#39;:
 824     case &#39;_&#39;:
 825     case &#39;`&#39;:
 826     case &#39;|&#39;:
 827     case &#39;~&#39;:
 828         return true;
 829     default:
 830         return false;
 831     }
 832 }
 833 
 834 size_t parseHTTPHeader(const char* start, size_t length, String&amp; failureReason, StringView&amp; nameStr, String&amp; valueStr, bool strict)
 835 {
 836     const char* p = start;
 837     const char* end = start + length;
 838 
 839     Vector&lt;char&gt; name;
 840     Vector&lt;char&gt; value;
 841 
 842     bool foundFirstNameChar = false;
 843     const char* namePtr = nullptr;
 844     size_t nameSize = 0;
 845 
 846     nameStr = StringView();
 847     valueStr = String();
 848 
 849     for (; p &lt; end; p++) {
 850         switch (*p) {
 851         case &#39;\r&#39;:
 852             if (name.isEmpty()) {
 853                 if (p + 1 &lt; end &amp;&amp; *(p + 1) == &#39;\n&#39;)
 854                     return (p + 2) - start;
 855                 failureReason = makeString(&quot;CR doesn&#39;t follow LF in header name at &quot;, trimInputSample(p, end - p));
 856                 return 0;
 857             }
 858             failureReason = makeString(&quot;Unexpected CR in header name at &quot;, trimInputSample(name.data(), name.size()));
 859             return 0;
 860         case &#39;\n&#39;:
 861             failureReason = makeString(&quot;Unexpected LF in header name at &quot;, trimInputSample(name.data(), name.size()));
 862             return 0;
 863         case &#39;:&#39;:
 864             break;
 865         default:
 866             if (!isValidHeaderNameCharacter(p)) {
 867                 if (name.size() &lt; 1)
 868                     failureReason = &quot;Unexpected start character in header name&quot;;
 869                 else
 870                     failureReason = makeString(&quot;Unexpected character in header name at &quot;, trimInputSample(name.data(), name.size()));
 871                 return 0;
 872             }
 873             name.append(*p);
 874             if (!foundFirstNameChar) {
 875                 namePtr = p;
 876                 foundFirstNameChar = true;
 877             }
 878             continue;
 879         }
 880         if (*p == &#39;:&#39;) {
 881             ++p;
 882             break;
 883         }
 884     }
 885 
 886     nameSize = name.size();
 887     nameStr = StringView(namePtr, nameSize);
 888 
 889     for (; p &lt; end &amp;&amp; *p == 0x20; p++) { }
 890 
 891     for (; p &lt; end; p++) {
 892         switch (*p) {
 893         case &#39;\r&#39;:
 894             break;
 895         case &#39;\n&#39;:
 896             if (strict) {
 897                 failureReason = makeString(&quot;Unexpected LF in header value at &quot;, trimInputSample(value.data(), value.size()));
 898                 return 0;
 899             }
 900             break;
 901         default:
 902             value.append(*p);
 903         }
 904         if (*p == &#39;\r&#39; || (!strict &amp;&amp; *p == &#39;\n&#39;)) {
 905             ++p;
 906             break;
 907         }
 908     }
 909     if (p &gt;= end || (strict &amp;&amp; *p != &#39;\n&#39;)) {
 910         failureReason = makeString(&quot;CR doesn&#39;t follow LF after header value at &quot;, trimInputSample(p, end - p));
 911         return 0;
 912     }
 913     valueStr = String::fromUTF8(value.data(), value.size());
 914     if (valueStr.isNull()) {
 915         failureReason = &quot;Invalid UTF-8 sequence in header value&quot;_s;
 916         return 0;
 917     }
 918     return p - start;
 919 }
 920 
 921 size_t parseHTTPRequestBody(const char* data, size_t length, Vector&lt;unsigned char&gt;&amp; body)
 922 {
 923     body.clear();
 924     body.append(data, length);
 925 
 926     return length;
 927 }
 928 
 929 // Implements &lt;https://fetch.spec.whatwg.org/#forbidden-header-name&gt;.
 930 bool isForbiddenHeaderName(const String&amp; name)
 931 {
 932     HTTPHeaderName headerName;
 933     if (findHTTPHeaderName(name, headerName)) {
 934         switch (headerName) {
 935         case HTTPHeaderName::AcceptCharset:
 936         case HTTPHeaderName::AcceptEncoding:
 937         case HTTPHeaderName::AccessControlRequestHeaders:
 938         case HTTPHeaderName::AccessControlRequestMethod:
 939         case HTTPHeaderName::Connection:
 940         case HTTPHeaderName::ContentLength:
 941         case HTTPHeaderName::Cookie:
 942         case HTTPHeaderName::Cookie2:
 943         case HTTPHeaderName::Date:
 944         case HTTPHeaderName::DNT:
 945         case HTTPHeaderName::Expect:
 946         case HTTPHeaderName::Host:
 947         case HTTPHeaderName::KeepAlive:
 948         case HTTPHeaderName::Origin:
 949         case HTTPHeaderName::Referer:
 950         case HTTPHeaderName::TE:
 951         case HTTPHeaderName::Trailer:
 952         case HTTPHeaderName::TransferEncoding:
 953         case HTTPHeaderName::Upgrade:
 954         case HTTPHeaderName::Via:
 955             return true;
 956         default:
 957             break;
 958         }
 959     }
 960     return startsWithLettersIgnoringASCIICase(name, &quot;sec-&quot;) || startsWithLettersIgnoringASCIICase(name, &quot;proxy-&quot;);
 961 }
 962 
 963 // Implements &lt;https://fetch.spec.whatwg.org/#forbidden-response-header-name&gt;.
 964 bool isForbiddenResponseHeaderName(const String&amp; name)
 965 {
 966     return equalLettersIgnoringASCIICase(name, &quot;set-cookie&quot;) || equalLettersIgnoringASCIICase(name, &quot;set-cookie2&quot;);
 967 }
 968 
 969 // Implements &lt;https://fetch.spec.whatwg.org/#forbidden-method&gt;.
 970 bool isForbiddenMethod(const String&amp; name)
 971 {
 972     return equalLettersIgnoringASCIICase(name, &quot;connect&quot;) || equalLettersIgnoringASCIICase(name, &quot;trace&quot;) || equalLettersIgnoringASCIICase(name, &quot;track&quot;);
 973 }
 974 
 975 bool isSimpleHeader(const String&amp; name, const String&amp; value)
 976 {
 977     HTTPHeaderName headerName;
 978     if (!findHTTPHeaderName(name, headerName))
 979         return false;
 980     return isCrossOriginSafeRequestHeader(headerName, value);
 981 }
 982 
 983 bool isCrossOriginSafeHeader(HTTPHeaderName name, const HTTPHeaderSet&amp; accessControlExposeHeaderSet)
 984 {
 985     switch (name) {
 986     case HTTPHeaderName::CacheControl:
 987     case HTTPHeaderName::ContentLanguage:
 988     case HTTPHeaderName::ContentLength:
 989     case HTTPHeaderName::ContentType:
 990     case HTTPHeaderName::Expires:
 991     case HTTPHeaderName::LastModified:
 992     case HTTPHeaderName::Pragma:
 993     case HTTPHeaderName::Accept:
 994         return true;
 995     case HTTPHeaderName::SetCookie:
 996     case HTTPHeaderName::SetCookie2:
 997         return false;
 998     default:
 999         break;
1000     }
1001     return accessControlExposeHeaderSet.contains(httpHeaderNameString(name).toStringWithoutCopying());
1002 }
1003 
1004 bool isCrossOriginSafeHeader(const String&amp; name, const HTTPHeaderSet&amp; accessControlExposeHeaderSet)
1005 {
1006 #ifndef ASSERT_DISABLED
1007     HTTPHeaderName headerName;
1008     ASSERT(!findHTTPHeaderName(name, headerName));
1009 #endif
1010     return accessControlExposeHeaderSet.contains(name);
1011 }
1012 
1013 // Implements https://fetch.spec.whatwg.org/#cors-safelisted-request-header
1014 bool isCrossOriginSafeRequestHeader(HTTPHeaderName name, const String&amp; value)
1015 {
1016     switch (name) {
1017     case HTTPHeaderName::Accept:
1018         if (!isValidAcceptHeaderValue(value))
1019             return false;
1020         break;
1021     case HTTPHeaderName::AcceptLanguage:
1022     case HTTPHeaderName::ContentLanguage:
1023         if (!isValidLanguageHeaderValue(value))
1024             return false;
1025         break;
1026     case HTTPHeaderName::ContentType: {
1027         // Preflight is required for MIME types that can not be sent via form submission.
1028         String mimeType = extractMIMETypeFromMediaType(value);
1029         if (!(equalLettersIgnoringASCIICase(mimeType, &quot;application/x-www-form-urlencoded&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;multipart/form-data&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;text/plain&quot;)))
1030             return false;
1031         break;
1032     }
1033     default:
1034         // FIXME: Should we also make safe other headers (DPR, Downlink, Save-Data...)? That would require validating their values.
1035         return false;
1036     }
1037     return value.length() &lt;= 128;
1038 }
1039 
1040 // Implements &lt;https://fetch.spec.whatwg.org/#concept-method-normalize&gt;.
1041 String normalizeHTTPMethod(const String&amp; method)
1042 {
1043     const ASCIILiteral methods[] = { &quot;DELETE&quot;_s, &quot;GET&quot;_s, &quot;HEAD&quot;_s, &quot;OPTIONS&quot;_s, &quot;POST&quot;_s, &quot;PUT&quot;_s };
1044     for (auto value : methods) {
1045         if (equalIgnoringASCIICase(method, value.characters())) {
1046             // Don&#39;t bother allocating a new string if it&#39;s already all uppercase.
1047             if (method == value)
1048                 break;
1049             return value;
1050         }
1051     }
1052     return method;
1053 }
1054 
1055 CrossOriginResourcePolicy parseCrossOriginResourcePolicyHeader(StringView header)
1056 {
1057     auto strippedHeader = stripLeadingAndTrailingHTTPSpaces(header);
1058 
1059     if (strippedHeader.isEmpty())
1060         return CrossOriginResourcePolicy::None;
1061 
1062     if (strippedHeader == &quot;same-origin&quot;)
1063         return CrossOriginResourcePolicy::SameOrigin;
1064 
1065     if (strippedHeader == &quot;same-site&quot;)
1066         return CrossOriginResourcePolicy::SameSite;
1067 
1068     return CrossOriginResourcePolicy::Invalid;
1069 }
1070 
1071 }
    </pre>
  </body>
</html>