<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/fixed-dtoa.cc</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="fast-dtoa.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="fixed-dtoa.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/fixed-dtoa.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,195 ***</span>
  #include &lt;wtf/dtoa/fixed-dtoa.h&gt;
  #include &lt;wtf/dtoa/ieee.h&gt;
  
  namespace WTF {
  namespace double_conversion {
<span class="line-modified">!     </span>
  // Represents a 128bit type. This class should be replaced by a native type on
  // platforms that support 128bit integers.
  class UInt128 {
<span class="line-modified">!     public:</span>
<span class="line-modified">!         UInt128() : high_bits_(0), low_bits_(0) { }</span>
<span class="line-modified">!         UInt128(uint64_t high, uint64_t low) : high_bits_(high), low_bits_(low) { }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         void Multiply(uint32_t multiplicand) {</span>
<span class="line-modified">!             uint64_t accumulator;</span>
<span class="line-modified">!             </span>
<span class="line-modified">!             accumulator = (low_bits_ &amp; kMask32) * multiplicand;</span>
<span class="line-modified">!             uint32_t part = static_cast&lt;uint32_t&gt;(accumulator &amp; kMask32);</span>
<span class="line-modified">!             accumulator &gt;&gt;= 32;</span>
<span class="line-modified">!             accumulator = accumulator + (low_bits_ &gt;&gt; 32) * multiplicand;</span>
<span class="line-modified">!             low_bits_ = (accumulator &lt;&lt; 32) + part;</span>
<span class="line-modified">!             accumulator &gt;&gt;= 32;</span>
<span class="line-modified">!             accumulator = accumulator + (high_bits_ &amp; kMask32) * multiplicand;</span>
<span class="line-modified">!             part = static_cast&lt;uint32_t&gt;(accumulator &amp; kMask32);</span>
<span class="line-modified">!             accumulator &gt;&gt;= 32;</span>
<span class="line-modified">!             accumulator = accumulator + (high_bits_ &gt;&gt; 32) * multiplicand;</span>
<span class="line-modified">!             high_bits_ = (accumulator &lt;&lt; 32) + part;</span>
<span class="line-modified">!             ASSERT((accumulator &gt;&gt; 32) == 0);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         void Shift(int shift_amount) {</span>
<span class="line-modified">!             ASSERT(-64 &lt;= shift_amount &amp;&amp; shift_amount &lt;= 64);</span>
<span class="line-modified">!             if (shift_amount == 0) {</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!             } else if (shift_amount == -64) {</span>
<span class="line-modified">!                 high_bits_ = low_bits_;</span>
<span class="line-modified">!                 low_bits_ = 0;</span>
<span class="line-modified">!             } else if (shift_amount == 64) {</span>
<span class="line-modified">!                 low_bits_ = high_bits_;</span>
<span class="line-modified">!                 high_bits_ = 0;</span>
<span class="line-modified">!             } else if (shift_amount &lt;= 0) {</span>
<span class="line-modified">!                 high_bits_ &lt;&lt;= -shift_amount;</span>
<span class="line-modified">!                 high_bits_ += low_bits_ &gt;&gt; (64 + shift_amount);</span>
<span class="line-modified">!                 low_bits_ &lt;&lt;= -shift_amount;</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 low_bits_ &gt;&gt;= shift_amount;</span>
<span class="line-modified">!                 low_bits_ += high_bits_ &lt;&lt; (64 - shift_amount);</span>
<span class="line-modified">!                 high_bits_ &gt;&gt;= shift_amount;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // Modifies *this to *this MOD (2^power).</span>
<span class="line-modified">!         // Returns *this DIV (2^power).</span>
<span class="line-modified">!         int DivModPowerOf2(int power) {</span>
<span class="line-modified">!             if (power &gt;= 64) {</span>
<span class="line-modified">!                 int result = static_cast&lt;int&gt;(high_bits_ &gt;&gt; (power - 64));</span>
<span class="line-modified">!                 high_bits_ -= static_cast&lt;uint64_t&gt;(result) &lt;&lt; (power - 64);</span>
<span class="line-modified">!                 return result;</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 uint64_t part_low = low_bits_ &gt;&gt; power;</span>
<span class="line-modified">!                 uint64_t part_high = high_bits_ &lt;&lt; (64 - power);</span>
<span class="line-modified">!                 int result = static_cast&lt;int&gt;(part_low + part_high);</span>
<span class="line-modified">!                 high_bits_ = 0;</span>
<span class="line-modified">!                 low_bits_ -= part_low &lt;&lt; power;</span>
<span class="line-modified">!                 return result;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         bool IsZero() const {</span>
<span class="line-modified">!             return high_bits_ == 0 &amp;&amp; low_bits_ == 0;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
    int BitAt(int position) const {
<span class="line-modified">!             if (position &gt;= 64) {</span>
<span class="line-modified">!                 return static_cast&lt;int&gt;(high_bits_ &gt;&gt; (position - 64)) &amp; 1;</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 return static_cast&lt;int&gt;(low_bits_ &gt;&gt; position) &amp; 1;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!     private:</span>
<span class="line-modified">!         static const uint64_t kMask32 = 0xFFFFFFFF;</span>
<span class="line-modified">!         // Value == (high_bits_ &lt;&lt; 64) + low_bits_</span>
<span class="line-modified">!         uint64_t high_bits_;</span>
<span class="line-modified">!         uint64_t low_bits_;</span>
  };
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  static const int kDoubleSignificandSize = 53;  // Includes the hidden bit.
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  static void FillDigits32FixedLength(uint32_t number, int requested_length,
<span class="line-modified">!                                         BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="line-modified">!         for (int i = requested_length - 1; i &gt;= 0; --i) {</span>
<span class="line-modified">!             buffer[(*length) + i] = &#39;0&#39; + number % 10;</span>
<span class="line-modified">!             number /= 10;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         *length += requested_length;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  static void FillDigits32(uint32_t number, BufferReference&lt;char&gt; buffer, int* length) {
<span class="line-modified">!         int number_length = 0;</span>
<span class="line-modified">!         // We fill the digits in reverse order and exchange them afterwards.</span>
<span class="line-modified">!         while (number != 0) {</span>
<span class="line-modified">!             int digit = number % 10;</span>
<span class="line-modified">!             number /= 10;</span>
      buffer[(*length) + number_length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="line-modified">!             number_length++;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // Exchange the digits.</span>
<span class="line-modified">!         int i = *length;</span>
<span class="line-modified">!         int j = *length + number_length - 1;</span>
<span class="line-modified">!         while (i &lt; j) {</span>
<span class="line-modified">!             char tmp = buffer[i];</span>
<span class="line-modified">!             buffer[i] = buffer[j];</span>
<span class="line-modified">!             buffer[j] = tmp;</span>
<span class="line-modified">!             i++;</span>
<span class="line-modified">!             j--;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         *length += number_length;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  static void FillDigits64FixedLength(uint64_t number,
<span class="line-modified">!                                         BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="line-modified">!         const uint32_t kTen7 = 10000000;</span>
<span class="line-modified">!         // For efficiency cut the number into 3 uint32_t parts, and print those.</span>
<span class="line-modified">!         uint32_t part2 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="line-modified">!         number /= kTen7;</span>
<span class="line-modified">!         uint32_t part1 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="line-modified">!         uint32_t part0 = static_cast&lt;uint32_t&gt;(number / kTen7);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         FillDigits32FixedLength(part0, 3, buffer, length);</span>
<span class="line-modified">!         FillDigits32FixedLength(part1, 7, buffer, length);</span>
<span class="line-modified">!         FillDigits32FixedLength(part2, 7, buffer, length);</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  static void FillDigits64(uint64_t number, BufferReference&lt;char&gt; buffer, int* length) {
<span class="line-modified">!         const uint32_t kTen7 = 10000000;</span>
<span class="line-modified">!         // For efficiency cut the number into 3 uint32_t parts, and print those.</span>
<span class="line-modified">!         uint32_t part2 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="line-modified">!         number /= kTen7;</span>
<span class="line-modified">!         uint32_t part1 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="line-modified">!         uint32_t part0 = static_cast&lt;uint32_t&gt;(number / kTen7);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (part0 != 0) {</span>
<span class="line-modified">!             FillDigits32(part0, buffer, length);</span>
<span class="line-modified">!             FillDigits32FixedLength(part1, 7, buffer, length);</span>
<span class="line-modified">!             FillDigits32FixedLength(part2, 7, buffer, length);</span>
<span class="line-modified">!         } else if (part1 != 0) {</span>
<span class="line-modified">!             FillDigits32(part1, buffer, length);</span>
<span class="line-modified">!             FillDigits32FixedLength(part2, 7, buffer, length);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             FillDigits32(part2, buffer, length);</span>
<span class="line-modified">!         }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  static void RoundUp(BufferReference&lt;char&gt; buffer, int* length, int* decimal_point) {
<span class="line-modified">!         // An empty buffer represents 0.</span>
<span class="line-modified">!         if (*length == 0) {</span>
<span class="line-modified">!             buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">!             *decimal_point = 1;</span>
<span class="line-modified">!             *length = 1;</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // Round the last digit until we either have a digit that was not &#39;9&#39; or until</span>
<span class="line-modified">!         // we reached the first digit.</span>
<span class="line-modified">!         buffer[(*length) - 1]++;</span>
<span class="line-modified">!         for (int i = (*length) - 1; i &gt; 0; --i) {</span>
<span class="line-modified">!             if (buffer[i] != &#39;0&#39; + 10) {</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             buffer[i] = &#39;0&#39;;</span>
<span class="line-modified">!             buffer[i - 1]++;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // If the first digit is now &#39;0&#39; + 10, we would need to set it to &#39;0&#39; and add</span>
<span class="line-modified">!         // a &#39;1&#39; in front. However we reach the first digit only if all following</span>
<span class="line-modified">!         // digits had been &#39;9&#39; before rounding up. Now all trailing digits are &#39;0&#39; and</span>
<span class="line-modified">!         // we simply switch the first digit to &#39;1&#39; and update the decimal-point</span>
<span class="line-modified">!         // (indicating that the point is now one digit to the right).</span>
<span class="line-modified">!         if (buffer[0] == &#39;0&#39; + 10) {</span>
<span class="line-modified">!             buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">!             (*decimal_point)++;</span>
<span class="line-modified">!         }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // The given fractionals number represents a fixed-point number with binary
  // point at bit (-exponent).
  // Preconditions:
  //   -128 &lt;= exponent &lt;= 0.
  //   0 &lt;= fractionals * 2^exponent &lt; 1
<span class="line-new-header">--- 32,195 ---</span>
  #include &lt;wtf/dtoa/fixed-dtoa.h&gt;
  #include &lt;wtf/dtoa/ieee.h&gt;
  
  namespace WTF {
  namespace double_conversion {
<span class="line-modified">! </span>
  // Represents a 128bit type. This class should be replaced by a native type on
  // platforms that support 128bit integers.
  class UInt128 {
<span class="line-modified">!  public:</span>
<span class="line-modified">!   UInt128() : high_bits_(0), low_bits_(0) { }</span>
<span class="line-modified">!   UInt128(uint64_t high, uint64_t low) : high_bits_(high), low_bits_(low) { }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   void Multiply(uint32_t multiplicand) {</span>
<span class="line-modified">!     uint64_t accumulator;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     accumulator = (low_bits_ &amp; kMask32) * multiplicand;</span>
<span class="line-modified">!     uint32_t part = static_cast&lt;uint32_t&gt;(accumulator &amp; kMask32);</span>
<span class="line-modified">!     accumulator &gt;&gt;= 32;</span>
<span class="line-modified">!     accumulator = accumulator + (low_bits_ &gt;&gt; 32) * multiplicand;</span>
<span class="line-modified">!     low_bits_ = (accumulator &lt;&lt; 32) + part;</span>
<span class="line-modified">!     accumulator &gt;&gt;= 32;</span>
<span class="line-modified">!     accumulator = accumulator + (high_bits_ &amp; kMask32) * multiplicand;</span>
<span class="line-modified">!     part = static_cast&lt;uint32_t&gt;(accumulator &amp; kMask32);</span>
<span class="line-modified">!     accumulator &gt;&gt;= 32;</span>
<span class="line-modified">!     accumulator = accumulator + (high_bits_ &gt;&gt; 32) * multiplicand;</span>
<span class="line-modified">!     high_bits_ = (accumulator &lt;&lt; 32) + part;</span>
<span class="line-modified">!     ASSERT((accumulator &gt;&gt; 32) == 0);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   void Shift(int shift_amount) {</span>
<span class="line-modified">!     ASSERT(-64 &lt;= shift_amount &amp;&amp; shift_amount &lt;= 64);</span>
<span class="line-modified">!     if (shift_amount == 0) {</span>
<span class="line-modified">!       return;</span>
<span class="line-modified">!     } else if (shift_amount == -64) {</span>
<span class="line-modified">!       high_bits_ = low_bits_;</span>
<span class="line-modified">!       low_bits_ = 0;</span>
<span class="line-modified">!     } else if (shift_amount == 64) {</span>
<span class="line-modified">!       low_bits_ = high_bits_;</span>
<span class="line-modified">!       high_bits_ = 0;</span>
<span class="line-modified">!     } else if (shift_amount &lt;= 0) {</span>
<span class="line-modified">!       high_bits_ &lt;&lt;= -shift_amount;</span>
<span class="line-modified">!       high_bits_ += low_bits_ &gt;&gt; (64 + shift_amount);</span>
<span class="line-modified">!       low_bits_ &lt;&lt;= -shift_amount;</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       low_bits_ &gt;&gt;= shift_amount;</span>
<span class="line-modified">!       low_bits_ += high_bits_ &lt;&lt; (64 - shift_amount);</span>
<span class="line-modified">!       high_bits_ &gt;&gt;= shift_amount;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Modifies *this to *this MOD (2^power).</span>
<span class="line-modified">!   // Returns *this DIV (2^power).</span>
<span class="line-modified">!   int DivModPowerOf2(int power) {</span>
<span class="line-modified">!     if (power &gt;= 64) {</span>
<span class="line-modified">!       int result = static_cast&lt;int&gt;(high_bits_ &gt;&gt; (power - 64));</span>
<span class="line-modified">!       high_bits_ -= static_cast&lt;uint64_t&gt;(result) &lt;&lt; (power - 64);</span>
<span class="line-modified">!       return result;</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       uint64_t part_low = low_bits_ &gt;&gt; power;</span>
<span class="line-modified">!       uint64_t part_high = high_bits_ &lt;&lt; (64 - power);</span>
<span class="line-modified">!       int result = static_cast&lt;int&gt;(part_low + part_high);</span>
<span class="line-modified">!       high_bits_ = 0;</span>
<span class="line-modified">!       low_bits_ -= part_low &lt;&lt; power;</span>
<span class="line-modified">!       return result;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool IsZero() const {</span>
<span class="line-modified">!     return high_bits_ == 0 &amp;&amp; low_bits_ == 0;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
    int BitAt(int position) const {
<span class="line-modified">!     if (position &gt;= 64) {</span>
<span class="line-modified">!       return static_cast&lt;int&gt;(high_bits_ &gt;&gt; (position - 64)) &amp; 1;</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       return static_cast&lt;int&gt;(low_bits_ &gt;&gt; position) &amp; 1;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!  private:</span>
<span class="line-modified">!   static const uint64_t kMask32 = 0xFFFFFFFF;</span>
<span class="line-modified">!   // Value == (high_bits_ &lt;&lt; 64) + low_bits_</span>
<span class="line-modified">!   uint64_t high_bits_;</span>
<span class="line-modified">!   uint64_t low_bits_;</span>
  };
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  static const int kDoubleSignificandSize = 53;  // Includes the hidden bit.
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  static void FillDigits32FixedLength(uint32_t number, int requested_length,
<span class="line-modified">!                                     BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="line-modified">!   for (int i = requested_length - 1; i &gt;= 0; --i) {</span>
<span class="line-modified">!     buffer[(*length) + i] = &#39;0&#39; + number % 10;</span>
<span class="line-modified">!     number /= 10;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   *length += requested_length;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  static void FillDigits32(uint32_t number, BufferReference&lt;char&gt; buffer, int* length) {
<span class="line-modified">!   int number_length = 0;</span>
<span class="line-modified">!   // We fill the digits in reverse order and exchange them afterwards.</span>
<span class="line-modified">!   while (number != 0) {</span>
<span class="line-modified">!     int digit = number % 10;</span>
<span class="line-modified">!     number /= 10;</span>
      buffer[(*length) + number_length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="line-modified">!     number_length++;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   // Exchange the digits.</span>
<span class="line-modified">!   int i = *length;</span>
<span class="line-modified">!   int j = *length + number_length - 1;</span>
<span class="line-modified">!   while (i &lt; j) {</span>
<span class="line-modified">!     char tmp = buffer[i];</span>
<span class="line-modified">!     buffer[i] = buffer[j];</span>
<span class="line-modified">!     buffer[j] = tmp;</span>
<span class="line-modified">!     i++;</span>
<span class="line-modified">!     j--;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   *length += number_length;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  static void FillDigits64FixedLength(uint64_t number,
<span class="line-modified">!                                     BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="line-modified">!   const uint32_t kTen7 = 10000000;</span>
<span class="line-modified">!   // For efficiency cut the number into 3 uint32_t parts, and print those.</span>
<span class="line-modified">!   uint32_t part2 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="line-modified">!   number /= kTen7;</span>
<span class="line-modified">!   uint32_t part1 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="line-modified">!   uint32_t part0 = static_cast&lt;uint32_t&gt;(number / kTen7);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   FillDigits32FixedLength(part0, 3, buffer, length);</span>
<span class="line-modified">!   FillDigits32FixedLength(part1, 7, buffer, length);</span>
<span class="line-modified">!   FillDigits32FixedLength(part2, 7, buffer, length);</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  static void FillDigits64(uint64_t number, BufferReference&lt;char&gt; buffer, int* length) {
<span class="line-modified">!   const uint32_t kTen7 = 10000000;</span>
<span class="line-modified">!   // For efficiency cut the number into 3 uint32_t parts, and print those.</span>
<span class="line-modified">!   uint32_t part2 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="line-modified">!   number /= kTen7;</span>
<span class="line-modified">!   uint32_t part1 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="line-modified">!   uint32_t part0 = static_cast&lt;uint32_t&gt;(number / kTen7);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (part0 != 0) {</span>
<span class="line-modified">!     FillDigits32(part0, buffer, length);</span>
<span class="line-modified">!     FillDigits32FixedLength(part1, 7, buffer, length);</span>
<span class="line-modified">!     FillDigits32FixedLength(part2, 7, buffer, length);</span>
<span class="line-modified">!   } else if (part1 != 0) {</span>
<span class="line-modified">!     FillDigits32(part1, buffer, length);</span>
<span class="line-modified">!     FillDigits32FixedLength(part2, 7, buffer, length);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     FillDigits32(part2, buffer, length);</span>
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  static void RoundUp(BufferReference&lt;char&gt; buffer, int* length, int* decimal_point) {
<span class="line-modified">!   // An empty buffer represents 0.</span>
<span class="line-modified">!   if (*length == 0) {</span>
<span class="line-modified">!     buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">!     *decimal_point = 1;</span>
<span class="line-modified">!     *length = 1;</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   // Round the last digit until we either have a digit that was not &#39;9&#39; or until</span>
<span class="line-modified">!   // we reached the first digit.</span>
<span class="line-modified">!   buffer[(*length) - 1]++;</span>
<span class="line-modified">!   for (int i = (*length) - 1; i &gt; 0; --i) {</span>
<span class="line-modified">!     if (buffer[i] != &#39;0&#39; + 10) {</span>
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     buffer[i] = &#39;0&#39;;</span>
<span class="line-modified">!     buffer[i - 1]++;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   // If the first digit is now &#39;0&#39; + 10, we would need to set it to &#39;0&#39; and add</span>
<span class="line-modified">!   // a &#39;1&#39; in front. However we reach the first digit only if all following</span>
<span class="line-modified">!   // digits had been &#39;9&#39; before rounding up. Now all trailing digits are &#39;0&#39; and</span>
<span class="line-modified">!   // we simply switch the first digit to &#39;1&#39; and update the decimal-point</span>
<span class="line-modified">!   // (indicating that the point is now one digit to the right).</span>
<span class="line-modified">!   if (buffer[0] == &#39;0&#39; + 10) {</span>
<span class="line-modified">!     buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">!     (*decimal_point)++;</span>
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // The given fractionals number represents a fixed-point number with binary
  // point at bit (-exponent).
  // Preconditions:
  //   -128 &lt;= exponent &lt;= 0.
  //   0 &lt;= fractionals * 2^exponent &lt; 1
</pre>
<hr />
<pre>
<span class="line-old-header">*** 229,181 ***</span>
  // generated by this function might be updated, and the decimal-point variable
  // might be updated. If this function generates the digits 99 and the buffer
  // already contained &quot;199&quot; (thus yielding a buffer of &quot;19999&quot;) then a
  // rounding-up will change the contents of the buffer to &quot;20000&quot;.
  static void FillFractionals(uint64_t fractionals, int exponent,
<span class="line-modified">!                                 int fractional_count, BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">!                                 int* length, int* decimal_point) {</span>
<span class="line-modified">!         ASSERT(-128 &lt;= exponent &amp;&amp; exponent &lt;= 0);</span>
<span class="line-modified">!         // &#39;fractionals&#39; is a fixed-point number, with binary point at bit</span>
<span class="line-modified">!         // (-exponent). Inside the function the non-converted remainder of fractionals</span>
<span class="line-modified">!         // is a fixed-point number, with binary point at bit &#39;point&#39;.</span>
<span class="line-modified">!         if (-exponent &lt;= 64) {</span>
<span class="line-modified">!             // One 64 bit number is sufficient.</span>
<span class="line-modified">!             ASSERT(fractionals &gt;&gt; 56 == 0);</span>
<span class="line-modified">!             int point = -exponent;</span>
<span class="line-modified">!             for (int i = 0; i &lt; fractional_count; ++i) {</span>
<span class="line-modified">!                 if (fractionals == 0) break;</span>
<span class="line-modified">!                 // Instead of multiplying by 10 we multiply by 5 and adjust the point</span>
<span class="line-modified">!                 // location. This way the fractionals variable will not overflow.</span>
<span class="line-modified">!                 // Invariant at the beginning of the loop: fractionals &lt; 2^point.</span>
<span class="line-modified">!                 // Initially we have: point &lt;= 64 and fractionals &lt; 2^56</span>
<span class="line-modified">!                 // After each iteration the point is decremented by one.</span>
<span class="line-modified">!                 // Note that 5^3 = 125 &lt; 128 = 2^7.</span>
<span class="line-modified">!                 // Therefore three iterations of this loop will not overflow fractionals</span>
<span class="line-modified">!                 // (even without the subtraction at the end of the loop body). At this</span>
<span class="line-modified">!                 // time point will satisfy point &lt;= 61 and therefore fractionals &lt; 2^point</span>
<span class="line-modified">!                 // and any further multiplication of fractionals by 5 will not overflow.</span>
<span class="line-modified">!                 fractionals *= 5;</span>
<span class="line-modified">!                 point--;</span>
<span class="line-modified">!                 int digit = static_cast&lt;int&gt;(fractionals &gt;&gt; point);</span>
        ASSERT(digit &lt;= 9);
        buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="line-modified">!                 (*length)++;</span>
<span class="line-modified">!                 fractionals -= static_cast&lt;uint64_t&gt;(digit) &lt;&lt; point;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             // If the first bit after the point is set we have to round up.</span>
      ASSERT(fractionals == 0 || point - 1 &gt;= 0);
      if ((fractionals != 0) &amp;&amp; ((fractionals &gt;&gt; (point - 1)) &amp; 1) == 1) {
<span class="line-modified">!                 RoundUp(buffer, length, decimal_point);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         } else {  // We need 128 bits.</span>
<span class="line-modified">!             ASSERT(64 &lt; -exponent &amp;&amp; -exponent &lt;= 128);</span>
<span class="line-modified">!             UInt128 fractionals128 = UInt128(fractionals, 0);</span>
<span class="line-modified">!             fractionals128.Shift(-exponent - 64);</span>
<span class="line-modified">!             int point = 128;</span>
<span class="line-modified">!             for (int i = 0; i &lt; fractional_count; ++i) {</span>
<span class="line-modified">!                 if (fractionals128.IsZero()) break;</span>
<span class="line-modified">!                 // As before: instead of multiplying by 10 we multiply by 5 and adjust the</span>
<span class="line-modified">!                 // point location.</span>
<span class="line-modified">!                 // This multiplication will not overflow for the same reasons as before.</span>
<span class="line-modified">!                 fractionals128.Multiply(5);</span>
<span class="line-modified">!                 point--;</span>
<span class="line-modified">!                 int digit = fractionals128.DivModPowerOf2(point);</span>
        ASSERT(digit &lt;= 9);
        buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="line-modified">!                 (*length)++;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             if (fractionals128.BitAt(point - 1) == 1) {</span>
<span class="line-modified">!                 RoundUp(buffer, length, decimal_point);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // Removes leading and trailing zeros.
  // If leading zeros are removed then the decimal point position is adjusted.
  static void TrimZeros(BufferReference&lt;char&gt; buffer, int* length, int* decimal_point) {
<span class="line-modified">!         while (*length &gt; 0 &amp;&amp; buffer[(*length) - 1] == &#39;0&#39;) {</span>
<span class="line-modified">!             (*length)--;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         int first_non_zero = 0;</span>
<span class="line-modified">!         while (first_non_zero &lt; *length &amp;&amp; buffer[first_non_zero] == &#39;0&#39;) {</span>
<span class="line-modified">!             first_non_zero++;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (first_non_zero != 0) {</span>
<span class="line-modified">!             for (int i = first_non_zero; i &lt; *length; ++i) {</span>
<span class="line-modified">!                 buffer[i - first_non_zero] = buffer[i];</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             *length -= first_non_zero;</span>
<span class="line-modified">!             *decimal_point -= first_non_zero;</span>
<span class="line-modified">!         }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  bool FastFixedDtoa(double v,
<span class="line-modified">!                        int fractional_count,</span>
<span class="line-modified">!                        BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">!                        int* length,</span>
<span class="line-modified">!                        int* decimal_point) {</span>
<span class="line-modified">!         const uint32_t kMaxUInt32 = 0xFFFFFFFF;</span>
<span class="line-modified">!         uint64_t significand = Double(v).Significand();</span>
<span class="line-modified">!         int exponent = Double(v).Exponent();</span>
<span class="line-modified">!         // v = significand * 2^exponent (with significand a 53bit integer).</span>
<span class="line-modified">!         // If the exponent is larger than 20 (i.e. we may have a 73bit number) then we</span>
<span class="line-modified">!         // don&#39;t know how to compute the representation. 2^73 ~= 9.5*10^21.</span>
<span class="line-modified">!         // If necessary this limit could probably be increased, but we don&#39;t need</span>
<span class="line-modified">!         // more.</span>
<span class="line-modified">!         if (exponent &gt; 20) return false;</span>
<span class="line-modified">!         if (fractional_count &gt; 20) return false;</span>
<span class="line-modified">!         *length = 0;</span>
<span class="line-modified">!         // At most kDoubleSignificandSize bits of the significand are non-zero.</span>
<span class="line-modified">!         // Given a 64 bit integer we have 11 0s followed by 53 potentially non-zero</span>
<span class="line-modified">!         // bits:  0..11*..0xxx..53*..xx</span>
<span class="line-modified">!         if (exponent + kDoubleSignificandSize &gt; 64) {</span>
<span class="line-modified">!             // The exponent must be &gt; 11.</span>
<span class="line-modified">!             //</span>
<span class="line-modified">!             // We know that v = significand * 2^exponent.</span>
<span class="line-modified">!             // And the exponent &gt; 11.</span>
<span class="line-modified">!             // We simplify the task by dividing v by 10^17.</span>
<span class="line-modified">!             // The quotient delivers the first digits, and the remainder fits into a 64</span>
<span class="line-modified">!             // bit number.</span>
<span class="line-modified">!             // Dividing by 10^17 is equivalent to dividing by 5^17*2^17.</span>
<span class="line-modified">!             const uint64_t kFive17 = UINT64_2PART_C(0xB1, A2BC2EC5);  // 5^17</span>
<span class="line-modified">!             uint64_t divisor = kFive17;</span>
<span class="line-modified">!             int divisor_power = 17;</span>
<span class="line-modified">!             uint64_t dividend = significand;</span>
<span class="line-modified">!             uint32_t quotient;</span>
<span class="line-modified">!             uint64_t remainder;</span>
<span class="line-modified">!             // Let v = f * 2^e with f == significand and e == exponent.</span>
<span class="line-modified">!             // Then need q (quotient) and r (remainder) as follows:</span>
<span class="line-modified">!             //   v            = q * 10^17       + r</span>
<span class="line-modified">!             //   f * 2^e      = q * 10^17       + r</span>
<span class="line-modified">!             //   f * 2^e      = q * 5^17 * 2^17 + r</span>
<span class="line-modified">!             // If e &gt; 17 then</span>
<span class="line-modified">!             //   f * 2^(e-17) = q * 5^17        + r/2^17</span>
<span class="line-modified">!             // else</span>
<span class="line-modified">!             //   f  = q * 5^17 * 2^(17-e) + r/2^e</span>
<span class="line-modified">!             if (exponent &gt; divisor_power) {</span>
<span class="line-modified">!                 // We only allow exponents of up to 20 and therefore (17 - e) &lt;= 3</span>
<span class="line-modified">!                 dividend &lt;&lt;= exponent - divisor_power;</span>
<span class="line-modified">!                 quotient = static_cast&lt;uint32_t&gt;(dividend / divisor);</span>
<span class="line-modified">!                 remainder = (dividend % divisor) &lt;&lt; divisor_power;</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 divisor &lt;&lt;= divisor_power - exponent;</span>
<span class="line-modified">!                 quotient = static_cast&lt;uint32_t&gt;(dividend / divisor);</span>
<span class="line-modified">!                 remainder = (dividend % divisor) &lt;&lt; exponent;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             FillDigits32(quotient, buffer, length);</span>
      FillDigits64FixedLength(remainder, buffer, length);
<span class="line-modified">!             *decimal_point = *length;</span>
<span class="line-modified">!         } else if (exponent &gt;= 0) {</span>
<span class="line-modified">!             // 0 &lt;= exponent &lt;= 11</span>
<span class="line-modified">!             significand &lt;&lt;= exponent;</span>
<span class="line-modified">!             FillDigits64(significand, buffer, length);</span>
<span class="line-modified">!             *decimal_point = *length;</span>
<span class="line-modified">!         } else if (exponent &gt; -kDoubleSignificandSize) {</span>
<span class="line-modified">!             // We have to cut the number.</span>
<span class="line-modified">!             uint64_t integrals = significand &gt;&gt; -exponent;</span>
<span class="line-modified">!             uint64_t fractionals = significand - (integrals &lt;&lt; -exponent);</span>
<span class="line-modified">!             if (integrals &gt; kMaxUInt32) {</span>
<span class="line-modified">!                 FillDigits64(integrals, buffer, length);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 FillDigits32(static_cast&lt;uint32_t&gt;(integrals), buffer, length);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             *decimal_point = *length;</span>
<span class="line-modified">!             FillFractionals(fractionals, exponent, fractional_count,</span>
<span class="line-modified">!                             buffer, length, decimal_point);</span>
<span class="line-modified">!         } else if (exponent &lt; -128) {</span>
<span class="line-modified">!             // This configuration (with at most 20 digits) means that all digits must be</span>
<span class="line-modified">!             // 0.</span>
<span class="line-modified">!             ASSERT(fractional_count &lt;= 20);</span>
<span class="line-modified">!             buffer[0] = &#39;\0&#39;;</span>
<span class="line-modified">!             *length = 0;</span>
<span class="line-modified">!             *decimal_point = -fractional_count;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             *decimal_point = 0;</span>
<span class="line-modified">!             FillFractionals(significand, exponent, fractional_count,</span>
<span class="line-modified">!                             buffer, length, decimal_point);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         TrimZeros(buffer, length, decimal_point);</span>
<span class="line-modified">!         buffer[*length] = &#39;\0&#39;;</span>
<span class="line-modified">!         if ((*length) == 0) {</span>
<span class="line-modified">!             // The string is empty and the decimal_point thus has no importance. Mimick</span>
<span class="line-modified">!             // Gay&#39;s dtoa and and set it to -fractional_count.</span>
<span class="line-modified">!             *decimal_point = -fractional_count;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return true;</span>
  }
<span class="line-modified">!     </span>
  }  // namespace double_conversion
<span class="line-modified">! } // namespace WTF</span>
<span class="line-new-header">--- 229,181 ---</span>
  // generated by this function might be updated, and the decimal-point variable
  // might be updated. If this function generates the digits 99 and the buffer
  // already contained &quot;199&quot; (thus yielding a buffer of &quot;19999&quot;) then a
  // rounding-up will change the contents of the buffer to &quot;20000&quot;.
  static void FillFractionals(uint64_t fractionals, int exponent,
<span class="line-modified">!                             int fractional_count, BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">!                             int* length, int* decimal_point) {</span>
<span class="line-modified">!   ASSERT(-128 &lt;= exponent &amp;&amp; exponent &lt;= 0);</span>
<span class="line-modified">!   // &#39;fractionals&#39; is a fixed-point number, with binary point at bit</span>
<span class="line-modified">!   // (-exponent). Inside the function the non-converted remainder of fractionals</span>
<span class="line-modified">!   // is a fixed-point number, with binary point at bit &#39;point&#39;.</span>
<span class="line-modified">!   if (-exponent &lt;= 64) {</span>
<span class="line-modified">!     // One 64 bit number is sufficient.</span>
<span class="line-modified">!     ASSERT(fractionals &gt;&gt; 56 == 0);</span>
<span class="line-modified">!     int point = -exponent;</span>
<span class="line-modified">!     for (int i = 0; i &lt; fractional_count; ++i) {</span>
<span class="line-modified">!       if (fractionals == 0) break;</span>
<span class="line-modified">!       // Instead of multiplying by 10 we multiply by 5 and adjust the point</span>
<span class="line-modified">!       // location. This way the fractionals variable will not overflow.</span>
<span class="line-modified">!       // Invariant at the beginning of the loop: fractionals &lt; 2^point.</span>
<span class="line-modified">!       // Initially we have: point &lt;= 64 and fractionals &lt; 2^56</span>
<span class="line-modified">!       // After each iteration the point is decremented by one.</span>
<span class="line-modified">!       // Note that 5^3 = 125 &lt; 128 = 2^7.</span>
<span class="line-modified">!       // Therefore three iterations of this loop will not overflow fractionals</span>
<span class="line-modified">!       // (even without the subtraction at the end of the loop body). At this</span>
<span class="line-modified">!       // time point will satisfy point &lt;= 61 and therefore fractionals &lt; 2^point</span>
<span class="line-modified">!       // and any further multiplication of fractionals by 5 will not overflow.</span>
<span class="line-modified">!       fractionals *= 5;</span>
<span class="line-modified">!       point--;</span>
<span class="line-modified">!       int digit = static_cast&lt;int&gt;(fractionals &gt;&gt; point);</span>
        ASSERT(digit &lt;= 9);
        buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="line-modified">!       (*length)++;</span>
<span class="line-modified">!       fractionals -= static_cast&lt;uint64_t&gt;(digit) &lt;&lt; point;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     // If the first bit after the point is set we have to round up.</span>
      ASSERT(fractionals == 0 || point - 1 &gt;= 0);
      if ((fractionals != 0) &amp;&amp; ((fractionals &gt;&gt; (point - 1)) &amp; 1) == 1) {
<span class="line-modified">!       RoundUp(buffer, length, decimal_point);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   } else {  // We need 128 bits.</span>
<span class="line-modified">!     ASSERT(64 &lt; -exponent &amp;&amp; -exponent &lt;= 128);</span>
<span class="line-modified">!     UInt128 fractionals128 = UInt128(fractionals, 0);</span>
<span class="line-modified">!     fractionals128.Shift(-exponent - 64);</span>
<span class="line-modified">!     int point = 128;</span>
<span class="line-modified">!     for (int i = 0; i &lt; fractional_count; ++i) {</span>
<span class="line-modified">!       if (fractionals128.IsZero()) break;</span>
<span class="line-modified">!       // As before: instead of multiplying by 10 we multiply by 5 and adjust the</span>
<span class="line-modified">!       // point location.</span>
<span class="line-modified">!       // This multiplication will not overflow for the same reasons as before.</span>
<span class="line-modified">!       fractionals128.Multiply(5);</span>
<span class="line-modified">!       point--;</span>
<span class="line-modified">!       int digit = fractionals128.DivModPowerOf2(point);</span>
        ASSERT(digit &lt;= 9);
        buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="line-modified">!       (*length)++;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (fractionals128.BitAt(point - 1) == 1) {</span>
<span class="line-modified">!       RoundUp(buffer, length, decimal_point);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // Removes leading and trailing zeros.
  // If leading zeros are removed then the decimal point position is adjusted.
  static void TrimZeros(BufferReference&lt;char&gt; buffer, int* length, int* decimal_point) {
<span class="line-modified">!   while (*length &gt; 0 &amp;&amp; buffer[(*length) - 1] == &#39;0&#39;) {</span>
<span class="line-modified">!     (*length)--;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   int first_non_zero = 0;</span>
<span class="line-modified">!   while (first_non_zero &lt; *length &amp;&amp; buffer[first_non_zero] == &#39;0&#39;) {</span>
<span class="line-modified">!     first_non_zero++;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (first_non_zero != 0) {</span>
<span class="line-modified">!     for (int i = first_non_zero; i &lt; *length; ++i) {</span>
<span class="line-modified">!       buffer[i - first_non_zero] = buffer[i];</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     *length -= first_non_zero;</span>
<span class="line-modified">!     *decimal_point -= first_non_zero;</span>
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  bool FastFixedDtoa(double v,
<span class="line-modified">!                    int fractional_count,</span>
<span class="line-modified">!                    BufferReference&lt;char&gt; buffer,</span>
<span class="line-modified">!                    int* length,</span>
<span class="line-modified">!                    int* decimal_point) {</span>
<span class="line-modified">!   const uint32_t kMaxUInt32 = 0xFFFFFFFF;</span>
<span class="line-modified">!   uint64_t significand = Double(v).Significand();</span>
<span class="line-modified">!   int exponent = Double(v).Exponent();</span>
<span class="line-modified">!   // v = significand * 2^exponent (with significand a 53bit integer).</span>
<span class="line-modified">!   // If the exponent is larger than 20 (i.e. we may have a 73bit number) then we</span>
<span class="line-modified">!   // don&#39;t know how to compute the representation. 2^73 ~= 9.5*10^21.</span>
<span class="line-modified">!   // If necessary this limit could probably be increased, but we don&#39;t need</span>
<span class="line-modified">!   // more.</span>
<span class="line-modified">!   if (exponent &gt; 20) return false;</span>
<span class="line-modified">!   if (fractional_count &gt; 20) return false;</span>
<span class="line-modified">!   *length = 0;</span>
<span class="line-modified">!   // At most kDoubleSignificandSize bits of the significand are non-zero.</span>
<span class="line-modified">!   // Given a 64 bit integer we have 11 0s followed by 53 potentially non-zero</span>
<span class="line-modified">!   // bits:  0..11*..0xxx..53*..xx</span>
<span class="line-modified">!   if (exponent + kDoubleSignificandSize &gt; 64) {</span>
<span class="line-modified">!     // The exponent must be &gt; 11.</span>
<span class="line-modified">!     //</span>
<span class="line-modified">!     // We know that v = significand * 2^exponent.</span>
<span class="line-modified">!     // And the exponent &gt; 11.</span>
<span class="line-modified">!     // We simplify the task by dividing v by 10^17.</span>
<span class="line-modified">!     // The quotient delivers the first digits, and the remainder fits into a 64</span>
<span class="line-modified">!     // bit number.</span>
<span class="line-modified">!     // Dividing by 10^17 is equivalent to dividing by 5^17*2^17.</span>
<span class="line-modified">!     const uint64_t kFive17 = UINT64_2PART_C(0xB1, A2BC2EC5);  // 5^17</span>
<span class="line-modified">!     uint64_t divisor = kFive17;</span>
<span class="line-modified">!     int divisor_power = 17;</span>
<span class="line-modified">!     uint64_t dividend = significand;</span>
<span class="line-modified">!     uint32_t quotient;</span>
<span class="line-modified">!     uint64_t remainder;</span>
<span class="line-modified">!     // Let v = f * 2^e with f == significand and e == exponent.</span>
<span class="line-modified">!     // Then need q (quotient) and r (remainder) as follows:</span>
<span class="line-modified">!     //   v            = q * 10^17       + r</span>
<span class="line-modified">!     //   f * 2^e      = q * 10^17       + r</span>
<span class="line-modified">!     //   f * 2^e      = q * 5^17 * 2^17 + r</span>
<span class="line-modified">!     // If e &gt; 17 then</span>
<span class="line-modified">!     //   f * 2^(e-17) = q * 5^17        + r/2^17</span>
<span class="line-modified">!     // else</span>
<span class="line-modified">!     //   f  = q * 5^17 * 2^(17-e) + r/2^e</span>
<span class="line-modified">!     if (exponent &gt; divisor_power) {</span>
<span class="line-modified">!       // We only allow exponents of up to 20 and therefore (17 - e) &lt;= 3</span>
<span class="line-modified">!       dividend &lt;&lt;= exponent - divisor_power;</span>
<span class="line-modified">!       quotient = static_cast&lt;uint32_t&gt;(dividend / divisor);</span>
<span class="line-modified">!       remainder = (dividend % divisor) &lt;&lt; divisor_power;</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       divisor &lt;&lt;= divisor_power - exponent;</span>
<span class="line-modified">!       quotient = static_cast&lt;uint32_t&gt;(dividend / divisor);</span>
<span class="line-modified">!       remainder = (dividend % divisor) &lt;&lt; exponent;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     FillDigits32(quotient, buffer, length);</span>
      FillDigits64FixedLength(remainder, buffer, length);
<span class="line-modified">!     *decimal_point = *length;</span>
<span class="line-modified">!   } else if (exponent &gt;= 0) {</span>
<span class="line-modified">!     // 0 &lt;= exponent &lt;= 11</span>
<span class="line-modified">!     significand &lt;&lt;= exponent;</span>
<span class="line-modified">!     FillDigits64(significand, buffer, length);</span>
<span class="line-modified">!     *decimal_point = *length;</span>
<span class="line-modified">!   } else if (exponent &gt; -kDoubleSignificandSize) {</span>
<span class="line-modified">!     // We have to cut the number.</span>
<span class="line-modified">!     uint64_t integrals = significand &gt;&gt; -exponent;</span>
<span class="line-modified">!     uint64_t fractionals = significand - (integrals &lt;&lt; -exponent);</span>
<span class="line-modified">!     if (integrals &gt; kMaxUInt32) {</span>
<span class="line-modified">!       FillDigits64(integrals, buffer, length);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       FillDigits32(static_cast&lt;uint32_t&gt;(integrals), buffer, length);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     *decimal_point = *length;</span>
<span class="line-modified">!     FillFractionals(fractionals, exponent, fractional_count,</span>
<span class="line-modified">!                     buffer, length, decimal_point);</span>
<span class="line-modified">!   } else if (exponent &lt; -128) {</span>
<span class="line-modified">!     // This configuration (with at most 20 digits) means that all digits must be</span>
<span class="line-modified">!     // 0.</span>
<span class="line-modified">!     ASSERT(fractional_count &lt;= 20);</span>
<span class="line-modified">!     buffer[0] = &#39;\0&#39;;</span>
<span class="line-modified">!     *length = 0;</span>
<span class="line-modified">!     *decimal_point = -fractional_count;</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     *decimal_point = 0;</span>
<span class="line-modified">!     FillFractionals(significand, exponent, fractional_count,</span>
<span class="line-modified">!                     buffer, length, decimal_point);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   TrimZeros(buffer, length, decimal_point);</span>
<span class="line-modified">!   buffer[*length] = &#39;\0&#39;;</span>
<span class="line-modified">!   if ((*length) == 0) {</span>
<span class="line-modified">!     // The string is empty and the decimal_point thus has no importance. Mimick</span>
<span class="line-modified">!     // Gay&#39;s dtoa and and set it to -fractional_count.</span>
<span class="line-modified">!     *decimal_point = -fractional_count;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return true;</span>
  }
<span class="line-modified">! </span>
  }  // namespace double_conversion
<span class="line-modified">! }  // namespace WTF</span>
</pre>
<center><a href="fast-dtoa.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="fixed-dtoa.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>