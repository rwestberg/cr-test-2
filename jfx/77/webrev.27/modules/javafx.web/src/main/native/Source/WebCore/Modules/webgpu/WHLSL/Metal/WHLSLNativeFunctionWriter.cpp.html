<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLNativeFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLNativeFunctionWriter.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;NotImplemented.h&quot;
 32 #include &quot;WHLSLAddressSpace.h&quot;
 33 #include &quot;WHLSLArrayType.h&quot;
 34 #include &quot;WHLSLEnumerationDefinition.h&quot;
 35 #include &quot;WHLSLInferTypes.h&quot;
 36 #include &quot;WHLSLIntrinsics.h&quot;
 37 #include &quot;WHLSLNamedType.h&quot;
 38 #include &quot;WHLSLNativeFunctionDeclaration.h&quot;
 39 #include &quot;WHLSLNativeTypeDeclaration.h&quot;
 40 #include &quot;WHLSLPointerType.h&quot;
 41 #include &quot;WHLSLStructureDefinition.h&quot;
 42 #include &quot;WHLSLTypeDefinition.h&quot;
 43 #include &quot;WHLSLTypeNamer.h&quot;
 44 #include &quot;WHLSLUnnamedType.h&quot;
 45 #include &quot;WHLSLVariableDeclaration.h&quot;
 46 #include &lt;wtf/text/StringBuilder.h&gt;
 47 
 48 namespace WebCore {
 49 
 50 namespace WHLSL {
 51 
 52 namespace Metal {
 53 
 54 static String mapFunctionName(String&amp; functionName)
 55 {
 56     if (functionName == &quot;ddx&quot;)
 57         return &quot;dfdx&quot;_str;
 58     if (functionName == &quot;ddy&quot;)
 59         return &quot;dfdy&quot;_str;
 60     if (functionName == &quot;asint&quot;)
 61         return &quot;as_type&lt;int32_t&gt;&quot;_str;
 62     if (functionName == &quot;asuint&quot;)
 63         return &quot;as_type&lt;uint32_t&gt;&quot;_str;
 64     if (functionName == &quot;asfloat&quot;)
 65         return &quot;as_type&lt;float&gt;&quot;_str;
 66     return functionName;
 67 }
 68 
 69 static String atomicName(String input)
 70 {
 71     if (input == &quot;Add&quot;)
 72         return &quot;fetch_add&quot;_str;
 73     if (input == &quot;And&quot;)
 74         return &quot;fetch_and&quot;_str;
 75     if (input == &quot;Exchange&quot;)
 76         return &quot;exchange&quot;_str;
 77     if (input == &quot;Max&quot;)
 78         return &quot;fetch_max&quot;_str;
 79     if (input == &quot;Min&quot;)
 80         return &quot;fetch_min&quot;_str;
 81     if (input == &quot;Or&quot;)
 82         return &quot;fetch_or&quot;_str;
 83     ASSERT(input == &quot;Xor&quot;);
 84         return &quot;fetch_xor&quot;_str;
 85 }
 86 
 87 static int vectorLength(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
 88 {
 89     int vectorLength = 1;
 90     if (!nativeTypeDeclaration.typeArguments().isEmpty()) {
 91         ASSERT(nativeTypeDeclaration.typeArguments().size() == 2);
 92         ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]));
 93         vectorLength = WTF::get&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]).integerLiteral().value();
 94     }
 95     return vectorLength;
 96 }
 97 
 98 static AST::NamedType&amp; vectorInnerType(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
 99 {
100     if (nativeTypeDeclaration.typeArguments().isEmpty())
101         return nativeTypeDeclaration;
102 
103     ASSERT(nativeTypeDeclaration.typeArguments().size() == 2);
104     ASSERT(WTF::holds_alternative&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));
105     return WTF::get&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0])-&gt;resolvedType();
106 }
107 
108 static const char* vectorSuffix(int vectorLength)
109 {
110     switch (vectorLength) {
111     case 1:
112         return &quot;&quot;;
113     case 2:
114         return &quot;2&quot;;
115     case 3:
116         return &quot;3&quot;;
117     default:
118         ASSERT(vectorLength == 4);
119         return &quot;4&quot;;
120     }
121 }
122 
123 void inlineNativeFunction(StringBuilder&amp; stringBuilder, AST::NativeFunctionDeclaration&amp; nativeFunctionDeclaration, MangledVariableName returnName, const Vector&lt;MangledVariableName&gt;&amp; args, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName, Indentation&lt;4&gt; indent)
124 {
125     auto asMatrixType = [&amp;] (AST::UnnamedType&amp; unnamedType) -&gt; AST::NativeTypeDeclaration* {
126         auto&amp; realType = unnamedType.unifyNode();
127         if (!realType.isNativeTypeDeclaration())
128             return nullptr;
129 
130         auto&amp; maybeMatrixType = downcast&lt;AST::NativeTypeDeclaration&gt;(realType);
131         if (maybeMatrixType.isMatrix())
132             return &amp;maybeMatrixType;
133 
134         return nullptr;
135     };
136 
137     if (nativeFunctionDeclaration.isCast()) {
138         auto&amp; returnType = nativeFunctionDeclaration.type();
139         auto metalReturnTypeName = typeNamer.mangledNameForType(returnType);
140 
141         if (!nativeFunctionDeclaration.parameters().size()) {
142             stringBuilder.append(indent, returnName, &quot; = { };\n&quot;);
143             return;
144         }
145 
146         if (nativeFunctionDeclaration.parameters().size() == 1) {
147             auto&amp; parameterType = *nativeFunctionDeclaration.parameters()[0]-&gt;type();
148             auto metalParameterTypeName = typeNamer.mangledNameForType(parameterType);
149 
150             auto isEnumerationDefinition = [] (auto&amp; type) {
151                 return is&lt;AST::NamedType&gt;(type) &amp;&amp; is&lt;AST::EnumerationDefinition&gt;(downcast&lt;AST::NamedType&gt;(type));
152             };
153             auto&amp; unifiedReturnType = returnType.unifyNode();
154             if (isEnumerationDefinition(unifiedReturnType) &amp;&amp; !isEnumerationDefinition(parameterType.unifyNode())) {
155                 auto variableName = generateNextVariableName();
156                 stringBuilder.append(indent, metalParameterTypeName, &#39; &#39;, variableName, &quot; = &quot;, args[0], &quot;;\n&quot;);
157                 auto&amp; enumerationDefinition = downcast&lt;AST::EnumerationDefinition&gt;(downcast&lt;AST::NamedType&gt;(unifiedReturnType));
158                 stringBuilder.append(indent, &quot;switch (&quot;, variableName, &quot;) {\n&quot;);
159                 {
160                     IndentationScope switchScope(indent);
161                     bool hasZeroCase = false;
162                     for (auto&amp; member : enumerationDefinition.enumerationMembers()) {
163                         hasZeroCase |= !member.get().value();
164                         stringBuilder.append(
165                             indent, &quot;case &quot;, member.get().value(), &quot;:\n&quot;,
166                             indent, &quot;    break;\n&quot;);
167                     }
168                     ASSERT_UNUSED(hasZeroCase, hasZeroCase);
169                     stringBuilder.append(
170                         indent, &quot;default:\n&quot;,
171                         indent, &quot;    &quot;, variableName, &quot; = 0;\n&quot;,
172                         indent, &quot;    break;\n&quot;,
173                         indent, &quot;}\n&quot;);
174                 }
175                 stringBuilder.append(indent, returnName, &quot; = static_cast&lt;&quot;, metalReturnTypeName, &quot;&gt;(&quot;, variableName, &quot;);\n&quot;);
176             } else
177                 stringBuilder.append(indent, returnName, &quot; = static_cast&lt;&quot;, metalReturnTypeName, &quot;&gt;(&quot;, args[0], &quot;);\n&quot;);
178 
179             return;
180         }
181 
182         if (auto* matrixType = asMatrixType(returnType)) {
183             unsigned numRows = matrixType-&gt;numberOfMatrixRows();
184             unsigned numColumns = matrixType-&gt;numberOfMatrixColumns();
185             RELEASE_ASSERT(nativeFunctionDeclaration.parameters().size() == numRows || nativeFunctionDeclaration.parameters().size() == numRows * numColumns);
186 
187             auto variableName = generateNextVariableName();
188 
189             stringBuilder.append(indent, metalReturnTypeName, &#39; &#39;, variableName, &quot;;\n&quot;);
190 
191             // We need to abide by the memory layout we use for matrices here.
192             if (nativeFunctionDeclaration.parameters().size() == numRows) {
193                 // operator matrixMxN (vectorN, ..., vectorN)
194                 for (unsigned i = 0; i &lt; numRows; ++i) {
195                     for (unsigned j = 0; j &lt; numColumns; ++j)
196                         stringBuilder.append(indent, variableName, &quot;[&quot;, j * numRows + i, &quot;] = &quot;, args[i], &quot;[&quot;, j, &quot;];\n&quot;);
197                 }
198             } else {
199                 // operator matrixMxN (scalar, ..., scalar)
200                 unsigned index = 0;
201                 for (unsigned i = 0; i &lt; numRows; ++i) {
202                     for (unsigned j = 0; j &lt; numColumns; ++j) {
203                         stringBuilder.append(indent, variableName, &#39;[&#39;, j * numRows + i, &quot;] = &quot;, args[index], &quot;;\n&quot;);
204                         ++index;
205                     }
206                 }
207             }
208 
209             stringBuilder.append(indent, returnName, &quot; = &quot;, variableName, &quot;;\n&quot;);
210             return;
211         }
212 
213         stringBuilder.append(indent, returnName, &quot; = &quot;, metalReturnTypeName, &quot;(&quot;);
214         for (unsigned i = 0; i &lt; nativeFunctionDeclaration.parameters().size(); ++i) {
215             if (i &gt; 0)
216                 stringBuilder.append(&quot;, &quot;);
217             stringBuilder.append(args[i]);
218         }
219         stringBuilder.append(&quot;);\n&quot;);
220         return;
221     }
222 
223     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198077 Authors can make a struct field named &quot;length&quot; too. Autogenerated getters for those shouldn&#39;t take this codepath.
224     if (nativeFunctionDeclaration.name() == &quot;operator.length&quot;) {
225         ASSERT_UNUSED(intrinsics, matches(nativeFunctionDeclaration.type(), intrinsics.uintType()));
226         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
227         auto&amp; parameterType = nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode();
228         auto&amp; unnamedParameterType = downcast&lt;AST::UnnamedType&gt;(parameterType);
229         if (is&lt;AST::ArrayType&gt;(unnamedParameterType)) {
230             auto&amp; arrayParameterType = downcast&lt;AST::ArrayType&gt;(unnamedParameterType);
231             stringBuilder.append(
232                 indent, returnName, &quot; = &quot;, arrayParameterType.numElements(), &quot;;\n&quot;);
233             return;
234         }
235 
236         ASSERT(is&lt;AST::ArrayReferenceType&gt;(unnamedParameterType));
237         stringBuilder.append(
238             indent, returnName, &quot; = &quot;, args[0], &quot;.length;\n&quot;);
239         return;
240     }
241 
242     if (nativeFunctionDeclaration.name().startsWith(&quot;operator.&quot;_str)) {
243         auto appendMangledFieldName = [&amp;] (const String&amp; fieldName) {
244             auto&amp; unifyNode = nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode();
245             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);
246             if (is&lt;AST::StructureDefinition&gt;(namedType)) {
247                 auto&amp; structureDefinition = downcast&lt;AST::StructureDefinition&gt;(namedType);
248                 auto* structureElement = structureDefinition.find(fieldName);
249                 ASSERT(structureElement);
250                 stringBuilder.append(typeNamer.mangledNameForStructureElement(*structureElement));
251                 return;
252             }
253             ASSERT(is&lt;AST::NativeTypeDeclaration&gt;(namedType));
254             stringBuilder.append(fieldName);
255         };
256 
257         if (nativeFunctionDeclaration.name().endsWith(&quot;=&quot;)) {
258             ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
259             auto fieldName = nativeFunctionDeclaration.name().substring(&quot;operator.&quot;_str.length());
260             fieldName = fieldName.substring(0, fieldName.length() - 1);
261 
262             stringBuilder.append(
263                 indent, returnName, &quot; = &quot;, args[0], &quot;;\n&quot;,
264                 indent, returnName, &#39;.&#39;);
265             appendMangledFieldName(fieldName);
266             stringBuilder.append(&quot; = &quot;, args[1], &quot;;\n&quot;);
267 
268             return;
269         }
270 
271         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
272         auto fieldName = nativeFunctionDeclaration.name().substring(&quot;operator.&quot;_str.length());
273         stringBuilder.append(
274             indent, returnName, &quot; = &quot;, args[0], &#39;.&#39;);
275         appendMangledFieldName(fieldName);
276         stringBuilder.append(&quot;;\n&quot;);
277         return;
278     }
279 
280     if (nativeFunctionDeclaration.name().startsWith(&quot;operator&amp;.&quot;_str)) {
281         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
282         auto fieldName = nativeFunctionDeclaration.name().substring(&quot;operator&amp;.&quot;_str.length());
283 
284         stringBuilder.append(
285             indent, returnName, &quot; = &quot;, args[0], &quot; ? &amp;(&quot;, args[0], &quot;-&gt;&quot;);
286 
287         auto&amp; unnamedType = *nativeFunctionDeclaration.parameters()[0]-&gt;type();
288         auto&amp; unifyNode = downcast&lt;AST::PointerType&gt;(unnamedType).elementType().unifyNode();
289         auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);
290         if (is&lt;AST::StructureDefinition&gt;(namedType)) {
291             auto&amp; structureDefinition = downcast&lt;AST::StructureDefinition&gt;(namedType);
292             auto* structureElement = structureDefinition.find(fieldName);
293             ASSERT(structureElement);
294             stringBuilder.append(typeNamer.mangledNameForStructureElement(*structureElement));
295         } else
296             stringBuilder.append(fieldName);
297 
298         stringBuilder.append(&quot;) : nullptr;\n&quot;);
299 
300         return;
301     }
302 
303     if (nativeFunctionDeclaration.name() == &quot;operator&amp;[]&quot;) {
304         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
305         ASSERT(is&lt;AST::ArrayReferenceType&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type()));
306 
307         stringBuilder.append(
308             indent, returnName, &quot; = (&quot;, args[1], &quot; &lt; &quot;, args[0], &quot;.length) ? &quot;, &quot; &amp;(&quot;, args[0], &quot;.pointer[&quot;, args[1], &quot;]) : nullptr;\n&quot;);
309 
310         return;
311     }
312 
313     auto vectorSize = [&amp;] () -&gt; unsigned {
314         auto&amp; typeReference = downcast&lt;AST::TypeReference&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type());
315         auto&amp; vectorType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::TypeReference&gt;(downcast&lt;AST::TypeDefinition&gt;(typeReference.resolvedType()).type()).resolvedType());
316         ASSERT(vectorType.name() == &quot;vector&quot;);
317         ASSERT(vectorType.typeArguments().size() == 2);
318         return WTF::get&lt;AST::ConstantExpression&gt;(vectorType.typeArguments()[1]).integerLiteral().value();
319     };
320 
321     auto getMatrixType = [&amp;] () -&gt; AST::NativeTypeDeclaration&amp; {
322         auto&amp; typeReference = downcast&lt;AST::TypeReference&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type());
323         auto&amp; result = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::TypeReference&gt;(downcast&lt;AST::TypeDefinition&gt;(typeReference.resolvedType()).type()).resolvedType());
324         ASSERT(result.isMatrix());
325         return result;
326     };
327 
328     if (nativeFunctionDeclaration.name() == &quot;operator[]&quot;) {
329         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
330         auto&amp; typeReference = downcast&lt;AST::TypeReference&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type());
331         size_t numTypeArguments = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::TypeReference&gt;(downcast&lt;AST::TypeDefinition&gt;(typeReference.resolvedType()).type()).resolvedType()).typeArguments().size();
332         if (numTypeArguments == 3) {
333             auto metalReturnName = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());
334 
335             unsigned numberOfRows = getMatrixType().numberOfMatrixRows();
336             unsigned numberOfColumns = getMatrixType().numberOfMatrixColumns();
337 
338             stringBuilder.append(indent, &quot;do {\n&quot;);
339             {
340                 IndentationScope scope(indent);
341 
342                 stringBuilder.append(
343                     indent, metalReturnName, &quot; result;\n&quot;,
344                     indent, &quot;if (&quot;, args[1], &quot; &gt;= &quot;, numberOfRows, &quot;) {\n&quot;,
345                     indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,
346                     indent, &quot;    break;\n&quot;,
347                     indent, &quot;}\n&quot;,
348                     indent, &quot;result[0] = &quot;, args[0], &#39;[&#39;, args[1], &quot;];\n&quot;,
349                     indent, &quot;result[1] = &quot;, args[0], &#39;[&#39;, args[1], &quot; + &quot;, numberOfRows, &quot;];\n&quot;);
350 
351                 if (numberOfColumns &gt;= 3)
352                     stringBuilder.append(indent, &quot;result[2] = &quot;, args[0], &#39;[&#39;, args[1], &quot; + &quot;, numberOfRows * 2, &quot;];\n&quot;);
353                 if (numberOfColumns &gt;= 4)
354                     stringBuilder.append(indent, &quot;result[3] = &quot;, args[0], &#39;[&#39;, args[1], &quot; + &quot;, numberOfRows * 3, &quot;];\n&quot;);
355 
356                 stringBuilder.append(indent, returnName, &quot; = result;\n&quot;);
357             }
358             stringBuilder.append(&quot;} while (0);\n&quot;);
359         } else {
360             RELEASE_ASSERT(numTypeArguments == 2);
361             unsigned numElements = vectorSize();
362 
363             auto metalReturnName = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());
364 
365             stringBuilder.append(indent, &quot;do {\n&quot;);
366             {
367                 IndentationScope scope(indent);
368                 stringBuilder.append(
369                     indent, metalReturnName, &quot; result;\n&quot;,
370                     indent, &quot;if (&quot;, args[1], &quot; &gt;= &quot;, numElements, &quot;) {\n&quot;,
371                     indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,
372                     indent, &quot;    break;\n&quot;,
373                     indent, &quot;}\n&quot;,
374                     indent, &quot;result = &quot;, args[0], &quot;[&quot;, args[1], &quot;];\n&quot;,
375                     indent, returnName, &quot; = result;\n&quot;);
376             }
377             stringBuilder.append(indent, &quot;} while (0);\n&quot;);
378         }
379 
380         return;
381     }
382 
383     if (nativeFunctionDeclaration.name() == &quot;operator[]=&quot;) {
384         auto&amp; typeReference = downcast&lt;AST::TypeReference&gt;(*nativeFunctionDeclaration.parameters()[0]-&gt;type());
385         size_t numTypeArguments = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::TypeReference&gt;(downcast&lt;AST::TypeDefinition&gt;(typeReference.resolvedType()).type()).resolvedType()).typeArguments().size();
386         if (numTypeArguments == 3) {
387             ASSERT(nativeFunctionDeclaration.parameters().size() == 3);
388             auto metalParameter2Name = typeNamer.mangledNameForType(*nativeFunctionDeclaration.parameters()[1]-&gt;type());
389             auto metalReturnName = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());
390 
391             unsigned numberOfRows = getMatrixType().numberOfMatrixRows();
392             unsigned numberOfColumns = getMatrixType().numberOfMatrixColumns();
393 
394             stringBuilder.append(indent, &quot;do {\n&quot;);
395             {
396                 IndentationScope scope(indent);
397 
398                 stringBuilder.append(
399                     indent, metalReturnName, &quot; m = &quot;, args[0], &quot;;\n&quot;,
400                     indent, metalParameter2Name, &quot; i = &quot;, args[1], &quot;;\n&quot;,
401                     indent, &quot;if (i &gt;= &quot;, numberOfRows, &quot;) {\n&quot;,
402                     indent, &quot;    &quot;, returnName, &quot; = m;\n&quot;,
403                     indent, &quot;    break;\n&quot;,
404                     indent, &quot;}\n&quot;,
405                     indent, &quot;m[i] = &quot;, args[2], &quot;[0];\n&quot;,
406                     indent, &quot;m[i + &quot;, numberOfRows, &quot;] = &quot;, args[2], &quot;[1];\n&quot;);
407                 if (numberOfColumns &gt;= 3)
408                     stringBuilder.append(indent, &quot;m[i + &quot;, numberOfRows * 2, &quot;] = &quot;, args[2], &quot;[2];\n&quot;);
409                 if (numberOfColumns &gt;= 4)
410                     stringBuilder.append(indent, &quot;m[i + &quot;, numberOfRows * 3, &quot;] = &quot;, args[2], &quot;[3];\n&quot;);
411                 stringBuilder.append(indent, returnName, &quot; = m;\n&quot;);
412             }
413 
414             stringBuilder.append(indent, &quot;} while(0);\n&quot;);
415         } else {
416             RELEASE_ASSERT(numTypeArguments == 2);
417 
418             ASSERT(nativeFunctionDeclaration.parameters().size() == 3);
419             auto metalParameter2Name = typeNamer.mangledNameForType(*nativeFunctionDeclaration.parameters()[1]-&gt;type());
420             auto metalReturnName = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());
421 
422             unsigned numElements = vectorSize();
423 
424             stringBuilder.append(indent, &quot;do {\n&quot;);
425             {
426                 IndentationScope scope(indent);
427 
428                 stringBuilder.append(
429                     indent, metalReturnName, &quot; v = &quot;, args[0], &quot;;\n&quot;,
430                     indent, metalParameter2Name, &quot; i = &quot;, args[1], &quot;;\n&quot;,
431                     indent, &quot;if (i &gt;= &quot;, numElements, &quot;) {\n&quot;,
432                     indent, &quot;    &quot;, returnName, &quot; = v;\n&quot;,
433                     indent, &quot;    break;\n&quot;,
434                     indent, &quot;}\n&quot;,
435                     indent, &quot;v[i] = &quot;, args[2], &quot;;\n&quot;,
436                     indent, returnName, &quot; = v;\n&quot;);
437             }
438             stringBuilder.append(indent, &quot;} while(0);\n&quot;);
439         }
440 
441         return;
442     }
443 
444     if (nativeFunctionDeclaration.isOperator()) {
445         auto operatorName = nativeFunctionDeclaration.name().substring(&quot;operator&quot;_str.length());
446         auto metalReturnType = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());
447         if (nativeFunctionDeclaration.parameters().size() == 1) {
448             if (auto* matrixType = asMatrixType(nativeFunctionDeclaration.type())) {
449                 stringBuilder.append(indent, &quot;{\n&quot;);
450                 {
451                     IndentationScope scope(indent);
452                     stringBuilder.append(
453                         indent, metalReturnType, &quot; x = &quot;, args[0], &quot;;\n&quot;,
454                         indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i)\n&quot;,
455                         indent, &quot;    x[i] = &quot;, operatorName, &quot;x[i];\n&quot;,
456                         indent, returnName, &quot; = x;\n&quot;);
457                 }
458                 stringBuilder.append(indent, &quot;}\n&quot;);
459             } else {
460                 stringBuilder.append(indent, &quot;{\n&quot;);
461                 {
462                     IndentationScope scope(indent);
463                     stringBuilder.append(
464                         indent, metalReturnType, &quot; x = &quot;, args[0], &quot;;\n&quot;,
465                         indent, returnName, &quot; = &quot;, operatorName, &quot;x;\n&quot;);
466                 }
467                 stringBuilder.append(indent, &quot;}\n&quot;);
468             }
469             return;
470         }
471 
472         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
473         if (auto* leftMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[0]-&gt;type())) {
474             if (auto* rightMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[1]-&gt;type())) {
475                 // matrix &lt;op&gt; matrix
476                 stringBuilder.append(indent, &quot;{\n&quot;);
477                 {
478                     IndentationScope scope(indent);
479                     stringBuilder.append(
480                         indent, metalReturnType, &quot; x;\n&quot;,
481                         indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i)\n&quot;,
482                         indent, &quot;    x[i] = &quot;, args[0], &quot;[i] &quot;, operatorName, &#39; &#39;, args[1], &quot;[i];\n&quot;,
483                         indent, returnName, &quot; = x;\n&quot;);
484                 }
485                 stringBuilder.append(indent, &quot;}\n&quot;);
486             } else {
487                 // matrix &lt;op&gt; scalar
488                 stringBuilder.append(indent, &quot;{\n&quot;);
489                 {
490                     IndentationScope scope(indent);
491                     stringBuilder.append(
492                         indent, metalReturnType, &quot; x;\n&quot;,
493                         indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i)\n&quot;,
494                         indent, &quot;    x[i] = &quot;, args[0], &quot;[i] &quot;, operatorName, &#39; &#39;, args[1], &quot;;\n&quot;,
495                         indent, returnName, &quot; = x;\n&quot;);
496                 }
497                 stringBuilder.append(indent, &quot;}\n&quot;);
498             }
499         } else if (auto* rightMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[1]-&gt;type())) {
500             ASSERT(!asMatrixType(*nativeFunctionDeclaration.parameters()[0]-&gt;type()));
501             // scalar &lt;op&gt; matrix
502             stringBuilder.append(indent, &quot;{\n&quot;);
503             {
504                 IndentationScope scope(indent);
505                 stringBuilder.append(
506                     indent, metalReturnType, &quot; x;\n&quot;,
507                     indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i)\n&quot;,
508                     indent, &quot;    x[i] = &quot;, args[0], &#39; &#39;, operatorName, &#39; &#39;, args[1], &quot;[i];\n&quot;,
509                     indent, returnName, &quot; = x;\n&quot;);
510             }
511             stringBuilder.append(indent, &quot;}\n&quot;);
512         } else {
513             // scalar &lt;op&gt; scalar
514             // vector &lt;op&gt; vector
515             // vector &lt;op&gt; scalar
516             // scalar &lt;op&gt; vector
517             stringBuilder.append(
518                 indent, returnName, &quot; = &quot;, args[0], &#39; &#39;, operatorName, &#39; &#39;, args[1], &quot;;\n&quot;);
519         }
520 
521         return;
522     }
523 
524     if (nativeFunctionDeclaration.name() == &quot;cos&quot;
525         || nativeFunctionDeclaration.name() == &quot;sin&quot;
526         || nativeFunctionDeclaration.name() == &quot;tan&quot;
527         || nativeFunctionDeclaration.name() == &quot;acos&quot;
528         || nativeFunctionDeclaration.name() == &quot;asin&quot;
529         || nativeFunctionDeclaration.name() == &quot;atan&quot;
530         || nativeFunctionDeclaration.name() == &quot;cosh&quot;
531         || nativeFunctionDeclaration.name() == &quot;sinh&quot;
532         || nativeFunctionDeclaration.name() == &quot;tanh&quot;
533         || nativeFunctionDeclaration.name() == &quot;ceil&quot;
534         || nativeFunctionDeclaration.name() == &quot;exp&quot;
535         || nativeFunctionDeclaration.name() == &quot;floor&quot;
536         || nativeFunctionDeclaration.name() == &quot;log&quot;
537         || nativeFunctionDeclaration.name() == &quot;round&quot;
538         || nativeFunctionDeclaration.name() == &quot;trunc&quot;
539         || nativeFunctionDeclaration.name() == &quot;ddx&quot;
540         || nativeFunctionDeclaration.name() == &quot;ddy&quot;
541         || nativeFunctionDeclaration.name() == &quot;isnormal&quot;
542         || nativeFunctionDeclaration.name() == &quot;isfinite&quot;
543         || nativeFunctionDeclaration.name() == &quot;isinf&quot;
544         || nativeFunctionDeclaration.name() == &quot;isnan&quot;
545         || nativeFunctionDeclaration.name() == &quot;asint&quot;
546         || nativeFunctionDeclaration.name() == &quot;asuint&quot;
547         || nativeFunctionDeclaration.name() == &quot;asfloat&quot;
548         || nativeFunctionDeclaration.name() == &quot;length&quot;) {
549         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
550         stringBuilder.append(
551             indent, returnName, &quot; = &quot;, mapFunctionName(nativeFunctionDeclaration.name()), &#39;(&#39;, args[0], &quot;);\n&quot;);
552         return;
553     }
554 
555     if (nativeFunctionDeclaration.name() == &quot;pow&quot; || nativeFunctionDeclaration.name() == &quot;atan2&quot;) {
556         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
557         stringBuilder.append(
558             indent, returnName, &quot; = &quot;, nativeFunctionDeclaration.name(), &quot;(&quot;, args[0], &quot;, &quot;, args[1], &quot;);\n&quot;);
559         return;
560     }
561 
562     if (nativeFunctionDeclaration.name() == &quot;clamp&quot;) {
563         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);
564         if (asMatrixType(nativeFunctionDeclaration.type())) {
565             auto metalReturnType = typeNamer.mangledNameForType(nativeFunctionDeclaration.type());
566 
567             stringBuilder.append(indent, &quot;{\n&quot;);
568             {
569                 IndentationScope scope(indent);
570                 stringBuilder.append(
571                     indent, metalReturnType, &quot; x;\n&quot;,
572                     indent, &quot;for (size_t i = 0; i &lt; x.size(); ++i) \n&quot;,
573                     indent, &quot;    x[i] = clamp(&quot;, args[0], &quot;[i], &quot;, args[1], &quot;[i], &quot;, args[2], &quot;[i]);&quot;,
574                     indent, returnName, &quot; = x;\n&quot;);
575             }
576             stringBuilder.append(indent, &quot;}\n&quot;);
577         } else {
578             stringBuilder.append(
579                 indent, returnName, &quot; = clamp(&quot;, args[0], &quot;, &quot;, args[1], &quot;, &quot;, args[2], &quot;);\n&quot;);
580         }
581         return;
582     }
583 
584     if (nativeFunctionDeclaration.name() == &quot;AllMemoryBarrierWithGroupSync&quot;) {
585         ASSERT(!nativeFunctionDeclaration.parameters().size());
586         stringBuilder.append(
587             indent, &quot;threadgroup_barrier(mem_flags::mem_device);\n&quot;,
588             indent, &quot;threadgroup_barrier(mem_flags::mem_threadgroup);\n&quot;,
589             indent, &quot;threadgroup_barrier(mem_flags::mem_texture);\n&quot;);
590         return;
591     }
592 
593     if (nativeFunctionDeclaration.name() == &quot;DeviceMemoryBarrierWithGroupSync&quot;) {
594         ASSERT(!nativeFunctionDeclaration.parameters().size());
595         stringBuilder.append(
596             indent, &quot;threadgroup_barrier(mem_flags::mem_device);\n&quot;);
597         return;
598     }
599 
600     if (nativeFunctionDeclaration.name() == &quot;GroupMemoryBarrierWithGroupSync&quot;) {
601         ASSERT(!nativeFunctionDeclaration.parameters().size());
602         stringBuilder.append(
603             indent, &quot;threadgroup_barrier(mem_flags::mem_threadgroup);\n&quot;);
604         return;
605     }
606 
607     if (nativeFunctionDeclaration.name().startsWith(&quot;Interlocked&quot;_str)) {
608         if (nativeFunctionDeclaration.name() == &quot;InterlockedCompareExchange&quot;) {
609             ASSERT(nativeFunctionDeclaration.parameters().size() == 4);
610             stringBuilder.append(
611                 indent, &quot;atomic_compare_exchange_weak_explicit(&quot;, args[0], &quot;, &amp;&quot;, args[1], &quot;, &quot;, args[2], &quot;, memory_order_relaxed, memory_order_relaxed);\n&quot;,
612                 indent, &#39;*&#39;, args[3], &quot; = &quot;, args[1], &quot;;\n&quot;);
613             return;
614         }
615 
616         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);
617         auto name = atomicName(nativeFunctionDeclaration.name().substring(&quot;Interlocked&quot;_str.length()));
618         stringBuilder.append(
619             indent, &#39;*&#39;, args[2], &quot; = atomic_&quot;, name, &quot;_explicit(&quot;, args[0], &quot;, &quot;, args[1], &quot;, memory_order_relaxed);\n&quot;);
620         return;
621     }
622 
623     if (nativeFunctionDeclaration.name() == &quot;Sample&quot;) {
624         ASSERT(nativeFunctionDeclaration.parameters().size() == 3 || nativeFunctionDeclaration.parameters().size() == 4);
625 
626         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));
627         auto&amp; locationType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[2]-&gt;type()-&gt;unifyNode()));
628         auto locationVectorLength = vectorLength(locationType);
629         auto&amp; returnType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.type().unifyNode()));
630         auto returnVectorLength = vectorLength(returnType);
631 
632         stringBuilder.append(
633             indent, returnName, &quot; = &quot;, args[0], &quot;.sample(&quot;, args[1], &quot;, &quot;);
634 
635         if (textureType.isTextureArray()) {
636             ASSERT(locationVectorLength &gt; 1);
637             stringBuilder.append(args[2], &#39;.&#39;, &quot;xyzw&quot;_str.substring(0, locationVectorLength - 1), &quot;, &quot;, args[2], &#39;.&#39;, &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1));
638         } else
639             stringBuilder.append(args[2]);
640         if (nativeFunctionDeclaration.parameters().size() == 4)
641             stringBuilder.append(&quot;, &quot;, args[3]);
642         stringBuilder.append(&quot;)&quot;);
643         if (!textureType.isDepthTexture())
644             stringBuilder.append(&quot;.&quot;, &quot;xyzw&quot;_str.substring(0, returnVectorLength));
645         stringBuilder.append(&quot;;\n&quot;);
646 
647         return;
648     }
649 
650     if (nativeFunctionDeclaration.name() == &quot;Load&quot;) {
651         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
652 
653         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));
654         auto&amp; locationType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[1]-&gt;type()-&gt;unifyNode()));
655         auto locationVectorLength = vectorLength(locationType);
656         auto&amp; returnType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.type().unifyNode()));
657         auto returnVectorLength = vectorLength(returnType);
658 
659         auto metalReturnName = typeNamer.mangledNameForType(returnType);
660 
661         stringBuilder.append(indent, &quot;do {\n&quot;);
662         {
663             IndentationScope scope(indent);
664 
665             if (textureType.isTextureArray()) {
666                 ASSERT(locationVectorLength &gt; 1);
667                 String dimensions[] = { &quot;width&quot;_str, &quot;height&quot;_str, &quot;depth&quot;_str };
668                 for (int i = 0; i &lt; locationVectorLength - 1; ++i) {
669                     auto suffix = &quot;xyzw&quot;_str.substring(i, 1);
670                     stringBuilder.append(
671                         indent, &quot;if (&quot;, args[1], &#39;.&#39;, suffix, &quot; &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &#39;.&#39;, suffix, &quot;) &gt;= &quot;, args[0], &quot;.get_&quot;, dimensions[i], &quot;()) {\n&quot;,
672                         indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,
673                         indent, &quot;    break;\n&quot;,
674                         indent, &quot;}\n&quot;);
675                 }
676                 auto suffix = &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1);
677                 stringBuilder.append(
678                     indent, &quot;if (&quot;, args[1], &#39;.&#39;, suffix, &quot; &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &#39;.&#39;, suffix, &quot;) &gt;= &quot;, args[0], &quot;.get_array_size()) {\n&quot;,
679                     indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,
680                     indent, &quot;    break;\n&quot;,
681                     indent, &quot;}\n&quot;);
682             } else {
683                 if (locationVectorLength == 1) {
684                     stringBuilder.append(
685                         indent, &quot;if (&quot;, args[1], &quot; &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &quot;) &gt;= &quot;, args[0], &quot;.get_width()) {\n&quot;,
686                         indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,
687                         indent, &quot;    break;\n&quot;,
688                         indent, &quot;}\n&quot;);
689                 } else {
690                     stringBuilder.append(
691                         indent, &quot;if (&quot;, args[1], &quot;.x &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &quot;.x) &gt;= &quot;, args[0], &quot;.get_width()) {\n&quot;,
692                         indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,
693                         indent, &quot;    break;\n&quot;,
694                         indent, &quot;}\n&quot;,
695                         indent, &quot;if (&quot;, args[1], &quot;.y &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &quot;.y) &gt;= &quot;, args[0], &quot;.get_height()) {\n&quot;,
696                         indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,
697                         indent, &quot;    break;\n&quot;,
698                         indent, &quot;}\n&quot;);
699                     if (locationVectorLength &gt;= 3) {
700                         stringBuilder.append(
701                             indent, &quot;if (&quot;, args[1], &quot;.z &lt; 0 || static_cast&lt;uint32_t&gt;(&quot;, args[1], &quot;.z) &gt;= &quot;, args[0], &quot;.get_depth()) {\n&quot;,
702                             indent, &quot;    &quot;, returnName, &quot; = &quot;, metalReturnName, &quot;(0);\n&quot;,
703                             indent, &quot;    break;\n&quot;,
704                             indent, &quot;}\n&quot;);
705                     }
706                 }
707             }
708             stringBuilder.append(indent, returnName, &quot; = &quot;, args[0], &quot;.read(&quot;);
709             if (textureType.isTextureArray()) {
710                 ASSERT(locationVectorLength &gt; 1);
711                 stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength - 1), &#39;(&#39;, args[1], &#39;.&#39;, &quot;xyzw&quot;_str.substring(0, locationVectorLength - 1), &quot;), uint(&quot;, args[1], &#39;.&#39;, &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1), &#39;)&#39;);
712             } else
713                 stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength), &#39;(&#39;, args[1], &#39;)&#39;);
714             stringBuilder.append(&#39;)&#39;);
715             if (!textureType.isDepthTexture())
716                 stringBuilder.append(&#39;.&#39;, &quot;xyzw&quot;_str.substring(0, returnVectorLength));
717             stringBuilder.append(&quot;;\n&quot;);
718         }
719         stringBuilder.append(indent, &quot;} while(0);\n&quot;);
720 
721         return;
722     }
723 
724     if (nativeFunctionDeclaration.name() == &quot;load&quot;) {
725         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
726         stringBuilder.append(
727             indent, returnName, &quot; = atomic_load_explicit(&quot;, args[0], &quot;, memory_order_relaxed);\n&quot;);
728         return;
729     }
730 
731     if (nativeFunctionDeclaration.name() == &quot;store&quot;) {
732         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
733         stringBuilder.append(
734             indent, &quot;atomic_store_explicit(&quot;, args[0], &quot;, &quot;, args[1], &quot;, memory_order_relaxed);\n&quot;);
735         return;
736     }
737 
738     if (nativeFunctionDeclaration.name() == &quot;GetDimensions&quot;) {
739         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));
740 
741         size_t index = 1;
742         bool hasMipLevel = !textureType.isWritableTexture() &amp;&amp; textureType.textureDimension() != 1;
743         if (hasMipLevel)
744             ++index;
745         const MangledVariableName&amp; widthName = args[index];
746         ++index;
747         Optional&lt;MangledVariableName&gt; heightName;
748         if (textureType.textureDimension() &gt;= 2) {
749             heightName = args[index];
750             ++index;
751         }
752         Optional&lt;MangledVariableName&gt; depthName;
753         if (textureType.textureDimension() &gt;= 3) {
754             depthName = args[index];
755             ++index;
756         }
757         Optional&lt;MangledVariableName&gt; elementsName;
758         if (textureType.isTextureArray()) {
759             elementsName = args[index];
760             ++index;
761         }
762         Optional&lt;MangledVariableName&gt; numberOfLevelsName;
763         if (!textureType.isWritableTexture() &amp;&amp; textureType.textureDimension() != 1) {
764             numberOfLevelsName = args[index];
765             ++index;
766         }
767         ASSERT(index == nativeFunctionDeclaration.parameters().size());
768 
769         stringBuilder.append(
770             indent, &quot;if (&quot;, widthName, &quot;)\n&quot;,
771             indent, &quot;    *&quot;, widthName, &quot; = &quot;, args[0], &quot;.get_width(&quot;);
772         if (hasMipLevel)
773             stringBuilder.append(args[1]);
774         stringBuilder.append(&quot;);\n&quot;);
775 
776         if (heightName) {
777             stringBuilder.append(
778                 indent, &quot;if (&quot;, *heightName, &quot;)\n&quot;,
779                 indent, &quot;    *&quot;, *heightName, &quot; = &quot;, args[0], &quot;.get_height(&quot;);
780             if (hasMipLevel)
781                 stringBuilder.append(args[1]);
782             stringBuilder.append(&quot;);\n&quot;);
783         }
784         if (depthName) {
785             stringBuilder.append(
786                 indent, &quot;if (&quot;, *depthName, &quot;)\n&quot;,
787                 indent, &quot;    *&quot;, *depthName, &quot; = &quot;, args[0], &quot;.get_depth(&quot;);
788             if (hasMipLevel)
789                 stringBuilder.append(args[1]);
790             stringBuilder.append(&quot;);\n&quot;);
791         }
792         if (elementsName) {
793             stringBuilder.append(
794                 indent, &quot;if (&quot;, *elementsName, &quot;)\n&quot;,
795                 indent, &quot;    *&quot;, *elementsName, &quot; = &quot;, args[0], &quot;.get_array_size();\n&quot;);
796         }
797         if (numberOfLevelsName) {
798             stringBuilder.append(
799                 indent, &quot;if (&quot;, *numberOfLevelsName, &quot;)\n&quot;,
800                 indent, &quot;    *&quot;, *numberOfLevelsName, &quot; = &quot;, args[0], &quot;.get_num_mip_levels();\n&quot;);
801         }
802         return;
803     }
804 
805     if (nativeFunctionDeclaration.name() == &quot;SampleBias&quot;) {
806         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
807         notImplemented();
808     }
809 
810     if (nativeFunctionDeclaration.name() == &quot;SampleGrad&quot;) {
811         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
812         notImplemented();
813     }
814 
815     if (nativeFunctionDeclaration.name() == &quot;SampleLevel&quot;) {
816         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
817         notImplemented();
818     }
819 
820     if (nativeFunctionDeclaration.name() == &quot;Gather&quot;) {
821         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
822         notImplemented();
823     }
824 
825     if (nativeFunctionDeclaration.name() == &quot;GatherRed&quot;) {
826         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
827         notImplemented();
828     }
829 
830     if (nativeFunctionDeclaration.name() == &quot;SampleCmp&quot;) {
831         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
832         notImplemented();
833     }
834 
835     if (nativeFunctionDeclaration.name() == &quot;SampleCmpLevelZero&quot;) {
836         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
837         notImplemented();
838     }
839 
840     if (nativeFunctionDeclaration.name() == &quot;Store&quot;) {
841         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);
842 
843         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));
844         auto&amp; itemType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[1]-&gt;type()-&gt;unifyNode()));
845         auto&amp; itemVectorInnerType = vectorInnerType(itemType);
846         auto itemVectorLength = vectorLength(itemType);
847         auto&amp; locationType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[2]-&gt;type()-&gt;unifyNode()));
848         auto locationVectorLength = vectorLength(locationType);
849 
850         auto metalInnerTypeName = typeNamer.mangledNameForType(itemVectorInnerType);
851 
852         stringBuilder.append(&quot;do {\n&quot;);
853         {
854             IndentationScope scope(indent);
855 
856             if (textureType.isTextureArray()) {
857                 ASSERT(locationVectorLength &gt; 1);
858                 String dimensions[] = { &quot;width&quot;_str, &quot;height&quot;_str, &quot;depth&quot;_str };
859                 for (int i = 0; i &lt; locationVectorLength - 1; ++i) {
860                     auto suffix = &quot;xyzw&quot;_str.substring(i, 1);
861                     stringBuilder.append(
862                         indent, &quot;if (&quot;, args[2], &quot;.&quot;, suffix, &quot; &gt;= &quot;, args[0], &quot;.get_&quot;, dimensions[i], &quot;())\n&quot;,
863                         indent, &quot;    break;\n&quot;);
864                 }
865                 auto suffix = &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1);
866                 stringBuilder.append(
867                     indent, &quot;if (&quot;, args[2], &#39;.&#39;, suffix, &quot; &gt;= &quot;, args[0], &quot;.get_array_size())\n&quot;,
868                     indent, &quot;    break;\n&quot;);
869             } else {
870                 if (locationVectorLength == 1) {
871                     stringBuilder.append(
872                         indent, &quot;if (&quot;, args[2], &quot; &gt;= &quot;, args[0], &quot;.get_width()) \n&quot;,
873                         indent, &quot;    break;\n&quot;);
874                 } else {
875                     stringBuilder.append(
876                         indent, &quot;if (&quot;, args[2], &quot;.x &gt;= &quot;, args[0], &quot;.get_width())\n&quot;,
877                         indent, &quot;    break;\n&quot;,
878                         indent, &quot;if (&quot;, args[2], &quot;.y &gt;= &quot;, args[0], &quot;.get_height())\n&quot;,
879                         indent, &quot;    break;\n&quot;);
880                     if (locationVectorLength &gt;= 3) {
881                         stringBuilder.append(
882                             indent, &quot;if (&quot;, args[2], &quot;.z &gt;= &quot;, args[0], &quot;.get_depth())\n&quot;,
883                             indent, &quot;    break;\n&quot;);
884                     }
885                 }
886             }
887             stringBuilder.append(indent, args[0], &quot;.write(vec&lt;&quot;, metalInnerTypeName, &quot;, 4&gt;(&quot;, args[1]);
888             for (int i = 0; i &lt; 4 - itemVectorLength; ++i)
889                 stringBuilder.append(&quot;, 0&quot;);
890             stringBuilder.append(&quot;), &quot;);
891             if (textureType.isTextureArray()) {
892                 ASSERT(locationVectorLength &gt; 1);
893                 stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength - 1), &#39;(&#39;, args[2], &#39;.&#39;, &quot;xyzw&quot;_str.substring(0, locationVectorLength - 1), &quot;), uint(&quot;, args[2], &quot;.&quot;, &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1), &#39;)&#39;);
894             } else
895                 stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength), &#39;(&#39;, args[2], &#39;)&#39;);
896             stringBuilder.append(&quot;);\n&quot;);
897         }
898         stringBuilder.append(indent, &quot;} while(0);\n&quot;);
899 
900         return;
901     }
902 
903     if (nativeFunctionDeclaration.name() == &quot;GatherAlpha&quot;) {
904         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
905         notImplemented();
906     }
907 
908     if (nativeFunctionDeclaration.name() == &quot;GatherBlue&quot;) {
909         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
910         notImplemented();
911     }
912 
913     if (nativeFunctionDeclaration.name() == &quot;GatherCmp&quot;) {
914         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
915         notImplemented();
916     }
917 
918     if (nativeFunctionDeclaration.name() == &quot;GatherCmpRed&quot;) {
919         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
920         notImplemented();
921     }
922 
923     if (nativeFunctionDeclaration.name() == &quot;GatherGreen&quot;) {
924         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
925         notImplemented();
926     }
927 
928     ASSERT_NOT_REACHED();
929 }
930 
931 } // namespace Metal
932 
933 } // namespace WHLSL
934 
935 } // namespace WebCore
936 
937 #endif
    </pre>
  </body>
</html>