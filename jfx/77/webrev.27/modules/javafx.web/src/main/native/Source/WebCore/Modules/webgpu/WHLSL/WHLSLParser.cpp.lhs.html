<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WHLSLParser.h&quot;
  28 
  29 #if ENABLE(WEBGPU)
  30 
  31 #include &quot;WHLSLAddressSpace.h&quot;
  32 #include &quot;WHLSLEntryPointType.h&quot;
<a name="1" id="anc1"></a>
  33 #include &lt;wtf/dtoa.h&gt;
  34 #include &lt;wtf/text/StringBuilder.h&gt;
  35 #include &lt;wtf/text/StringConcatenate.h&gt;
  36 
  37 namespace WebCore {
  38 
  39 namespace WHLSL {
  40 
<a name="2" id="anc2"></a><span class="line-modified">  41 // FIXME: Return a better error code from this, and report it to JavaScript.</span>
<span class="line-modified">  42 auto Parser::parse(Program&amp; program, StringView stringView, Mode mode) -&gt; Optional&lt;Error&gt;</span>



















  43 {
<a name="3" id="anc3"></a><span class="line-modified">  44     m_lexer = Lexer(stringView);</span>
  45     m_mode = mode;
  46 
  47     while (!m_lexer.isFullyConsumed()) {
<a name="4" id="anc4"></a><span class="line-modified">  48         if (tryType(Lexer::Token::Type::Semicolon)) {</span>




  49             m_lexer.consumeToken();
  50             continue;
<a name="5" id="anc5"></a>







  51         }
<a name="6" id="anc6"></a><span class="line-modified">  52 </span>
<span class="line-modified">  53         {</span>
<span class="line-modified">  54             auto typeDefinition = backtrackingScope&lt;Expected&lt;AST::TypeDefinition, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">  55                 return parseTypeDefinition();</span>
<span class="line-modified">  56             });</span>
<span class="line-modified">  57             if (typeDefinition) {</span>
<span class="line-modified">  58                 auto success = program.append(WTFMove(*typeDefinition));</span>
<span class="line-modified">  59                 if (!success)</span>
<span class="line-removed">  60                     return WTF::nullopt;</span>
<span class="line-removed">  61                 continue;</span>
<span class="line-removed">  62             }</span>
  63         }
<a name="7" id="anc7"></a><span class="line-modified">  64 </span>
<span class="line-modified">  65         {</span>
<span class="line-modified">  66             auto structureDefinition = backtrackingScope&lt;Expected&lt;AST::StructureDefinition, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">  67                 return parseStructureDefinition();</span>
<span class="line-modified">  68             });</span>
<span class="line-modified">  69             if (structureDefinition) {</span>
<span class="line-modified">  70                 auto success = program.append(WTFMove(*structureDefinition));</span>
<span class="line-modified">  71                 if (!success)</span>
<span class="line-removed">  72                     return WTF::nullopt;</span>
<span class="line-removed">  73                 continue;</span>
<span class="line-removed">  74             }</span>
  75         }
<a name="8" id="anc8"></a><span class="line-modified">  76 </span>
<span class="line-modified">  77         {</span>
<span class="line-modified">  78             auto enumerationDefinition = backtrackingScope&lt;Expected&lt;AST::EnumerationDefinition, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">  79                 return parseEnumerationDefinition();</span>
<span class="line-modified">  80             });</span>
<span class="line-modified">  81             if (enumerationDefinition) {</span>
<span class="line-modified">  82                 auto success = program.append(WTFMove(*enumerationDefinition));</span>
<span class="line-modified">  83                 if (!success)</span>
<span class="line-modified">  84                     return WTF::nullopt;</span>




  85                 continue;
  86             }
<a name="9" id="anc9"></a>






  87         }
<a name="10" id="anc10"></a><span class="line-modified">  88 </span>
<span class="line-modified">  89         Optional&lt;Error&gt; error;</span>
<span class="line-modified">  90         {</span>
<span class="line-modified">  91             auto functionDefinition = backtrackingScope&lt;Expected&lt;AST::FunctionDefinition, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">  92                 return parseFunctionDefinition();</span>
<span class="line-modified">  93             });</span>
<span class="line-modified">  94             if (functionDefinition) {</span>
<span class="line-modified">  95                 auto success = program.append(WTFMove(*functionDefinition));</span>
<span class="line-removed">  96                 if (!success)</span>
<span class="line-removed">  97                     return WTF::nullopt;</span>
<span class="line-removed">  98                 continue;</span>
<span class="line-removed">  99             }</span>
<span class="line-removed"> 100             error = functionDefinition.error();</span>
 101         }
<a name="11" id="anc11"></a><span class="line-removed"> 102 </span>
<span class="line-removed"> 103         if (m_mode == Mode::StandardLibrary) {</span>
<span class="line-removed"> 104             auto nativeFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::NativeFunctionDeclaration, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 105                 return parseNativeFunctionDeclaration();</span>
<span class="line-removed"> 106             });</span>
<span class="line-removed"> 107             if (nativeFunctionDeclaration) {</span>
<span class="line-removed"> 108                 auto success = program.append(WTFMove(*nativeFunctionDeclaration));</span>
<span class="line-removed"> 109                 if (!success)</span>
<span class="line-removed"> 110                     return WTF::nullopt;</span>
<span class="line-removed"> 111                 continue;</span>
<span class="line-removed"> 112             }</span>
 113         }
<a name="12" id="anc12"></a>
 114 
<a name="13" id="anc13"></a><span class="line-modified"> 115         if (m_mode == Mode::StandardLibrary) {</span>
<span class="line-modified"> 116             auto nativeTypeDeclaration = backtrackingScope&lt;Expected&lt;AST::NativeTypeDeclaration, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 117                 return parseNativeTypeDeclaration();</span>
<span class="line-removed"> 118             });</span>
<span class="line-removed"> 119             if (nativeTypeDeclaration) {</span>
<span class="line-removed"> 120                 auto success = program.append(WTFMove(*nativeTypeDeclaration));</span>
<span class="line-removed"> 121                 if (!success)</span>
<span class="line-removed"> 122                     return WTF::nullopt;</span>
<span class="line-removed"> 123                 continue;</span>
<span class="line-removed"> 124             }</span>
<span class="line-removed"> 125         }</span>
 126 
<a name="14" id="anc14"></a><span class="line-modified"> 127         return WTFMove(*error);</span>




 128     }
<a name="15" id="anc15"></a><span class="line-modified"> 129     return WTF::nullopt;</span>
 130 }
 131 
<a name="16" id="anc16"></a><span class="line-modified"> 132 auto Parser::fail(const String&amp; message) -&gt; Unexpected&lt;Error&gt;</span>
 133 {
<a name="17" id="anc17"></a><span class="line-modified"> 134     if (auto nextToken = peek())</span>
<span class="line-modified"> 135         return Unexpected&lt;Error&gt;(Error(m_lexer.errorString(*nextToken, message)));</span>
<span class="line-modified"> 136     return Unexpected&lt;Error&gt;(Error(makeString(&quot;Cannot lex: &quot;, message)));</span>

 137 }
 138 
<a name="18" id="anc18"></a><span class="line-modified"> 139 auto Parser::peek() -&gt; Expected&lt;Lexer::Token, Error&gt;</span>
 140 {
<a name="19" id="anc19"></a><span class="line-modified"> 141     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified"> 142         m_lexer.unconsumeToken(Lexer::Token(*token));</span>
<span class="line-modified"> 143         return *token;</span>


























 144     }
<a name="20" id="anc20"></a><span class="line-modified"> 145     return fail(&quot;Cannot consume token&quot;_str);</span>






 146 }
 147 
<a name="21" id="anc21"></a><span class="line-modified"> 148 Optional&lt;Lexer::Token&gt; Parser::tryType(Lexer::Token::Type type)</span>

 149 {
<a name="22" id="anc22"></a><span class="line-modified"> 150     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified"> 151         if (token-&gt;type == type)</span>
<span class="line-modified"> 152             return token;</span>
<span class="line-modified"> 153         m_lexer.unconsumeToken(Lexer::Token(*token));</span>
<span class="line-modified"> 154     }</span>




 155     return WTF::nullopt;
 156 }
 157 
<a name="23" id="anc23"></a><span class="line-modified"> 158 Optional&lt;Lexer::Token&gt; Parser::tryTypes(Vector&lt;Lexer::Token::Type&gt; types)</span>

 159 {
<a name="24" id="anc24"></a><span class="line-modified"> 160     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified"> 161         if (std::find(types.begin(), types.end(), token-&gt;type) != types.end())</span>
<span class="line-modified"> 162             return token;</span>
<span class="line-removed"> 163         m_lexer.unconsumeToken(Lexer::Token(*token));</span>
<span class="line-removed"> 164     }</span>
 165     return WTF::nullopt;
 166 }
 167 
<a name="25" id="anc25"></a><span class="line-modified"> 168 auto Parser::consumeType(Lexer::Token::Type type) -&gt; Expected&lt;Lexer::Token, Error&gt;</span>
 169 {
<a name="26" id="anc26"></a><span class="line-modified"> 170     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified"> 171         if (token-&gt;type == type)</span>
<span class="line-modified"> 172             return *token;</span>
<span class="line-modified"> 173         return fail(makeString(&quot;Unexpected token (expected &quot;, Lexer::Token::typeName(type), &quot; got &quot;, Lexer::Token::typeName(token-&gt;type), &quot;)&quot;));</span>
<span class="line-removed"> 174     }</span>
<span class="line-removed"> 175     return fail(makeString(&quot;Cannot consume token (expected &quot;, Lexer::Token::typeName(type), &quot;)&quot;));</span>
 176 }
 177 
<a name="27" id="anc27"></a><span class="line-modified"> 178 auto Parser::consumeTypes(Vector&lt;Lexer::Token::Type&gt; types) -&gt; Expected&lt;Lexer::Token, Error&gt;</span>

 179 {
 180     auto buildExpectedString = [&amp;]() -&gt; String {
 181         StringBuilder builder;
 182         builder.append(&quot;[&quot;);
<a name="28" id="anc28"></a><span class="line-modified"> 183         for (unsigned i = 0; i &lt; types.size(); ++i) {</span>
<span class="line-removed"> 184             if (i &gt; 0)</span>
<span class="line-removed"> 185                 builder.append(&quot;, &quot;);</span>
<span class="line-removed"> 186             builder.append(Lexer::Token::typeName(types[i]));</span>
<span class="line-removed"> 187         }</span>
 188         builder.append(&quot;]&quot;);
 189         return builder.toString();
 190     };
 191 
<a name="29" id="anc29"></a><span class="line-modified"> 192     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified"> 193         if (std::find(types.begin(), types.end(), token-&gt;type) != types.end())</span>
<span class="line-modified"> 194             return *token;</span>
<span class="line-modified"> 195         return fail(makeString(&quot;Unexpected token (expected one of &quot;, buildExpectedString(), &quot; got &quot;, Lexer::Token::typeName(token-&gt;type), &quot;)&quot;));</span>
<span class="line-removed"> 196     }</span>
<span class="line-removed"> 197     return fail(makeString(&quot;Cannot consume token (expected &quot;, buildExpectedString(), &quot;)&quot;));</span>
 198 }
 199 
 200 static int digitValue(UChar character)
 201 {
 202     if (character &gt;= &#39;0&#39; &amp;&amp; character &lt;= &#39;9&#39;)
 203         return character - &#39;0&#39;;
 204     if (character &gt;= &#39;a&#39; &amp;&amp; character &lt;= &#39;f&#39;)
 205         return character - &#39;a&#39; + 10;
 206     return character - &#39;A&#39; + 10;
 207 }
 208 
<a name="30" id="anc30"></a><span class="line-modified"> 209 static Expected&lt;int, Parser::Error&gt; intLiteralToInt(StringView text)</span>
 210 {
 211     bool negate = false;
 212     if (text.startsWith(&quot;-&quot;_str)) {
 213         negate = true;
 214         text = text.substring(1);
 215     }
 216     int base = 10;
 217     if (text.startsWith(&quot;0x&quot;_str)) {
 218         text = text.substring(2);
 219         base = 16;
 220     }
 221 
 222     unsigned result = 0;
 223     for (auto codePoint : text.codePoints()) {
 224         unsigned digit = digitValue(codePoint);
 225         auto previous = result;
 226         result = result * base + digit;
 227         if (result &lt; previous)
<a name="31" id="anc31"></a><span class="line-modified"> 228             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
 229     }
 230     if (negate) {
<a name="32" id="anc32"></a><span class="line-modified"> 231         static_assert(std::numeric_limits&lt;long long int&gt;::min() &lt; std::numeric_limits&lt;int&gt;::min(), &quot;long long needs to be bigger than an int&quot;);</span>
<span class="line-modified"> 232         if (static_cast&lt;long long&gt;(result) &gt; std::abs(static_cast&lt;long long&gt;(std::numeric_limits&lt;int&gt;::min())))</span>
<span class="line-modified"> 233             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
<span class="line-modified"> 234         return { static_cast&lt;int&gt;(static_cast&lt;long long&gt;(result) * 1) };</span>

 235     }
 236     if (result &gt; static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()))
<a name="33" id="anc33"></a><span class="line-modified"> 237         return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
 238     return { static_cast&lt;int&gt;(result) };
 239 }
 240 
<a name="34" id="anc34"></a><span class="line-modified"> 241 static Expected&lt;unsigned, Parser::Error&gt; uintLiteralToUint(StringView text)</span>
 242 {
 243     unsigned base = 10;
 244     if (text.startsWith(&quot;0x&quot;_str)) {
 245         text = text.substring(2);
 246         base = 16;
 247     }
 248     ASSERT(text.endsWith(&quot;u&quot;));
 249     text = text.substring(0, text.length() - 1);
 250     unsigned result = 0;
 251     for (auto codePoint : text.codePoints()) {
 252         unsigned digit = digitValue(codePoint);
 253         auto previous = result;
 254         result = result * base + digit;
 255         if (result &lt; previous)
<a name="35" id="anc35"></a><span class="line-modified"> 256             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;uint literal &quot;, text, &quot; is out of bounds&quot;)));</span>
 257     }
 258     return { result };
 259 }
 260 
<a name="36" id="anc36"></a><span class="line-modified"> 261 static Expected&lt;float, Parser::Error&gt; floatLiteralToFloat(StringView text)</span>
 262 {
 263     size_t parsedLength;
 264     auto result = parseDouble(text, parsedLength);
 265     if (parsedLength != text.length())
<a name="37" id="anc37"></a><span class="line-modified"> 266         return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Cannot parse float &quot;, text)));</span>
 267     return static_cast&lt;float&gt;(result);
 268 }
 269 
 270 auto Parser::consumeIntegralLiteral() -&gt; Expected&lt;Variant&lt;int, unsigned&gt;, Error&gt;
 271 {
<a name="38" id="anc38"></a><span class="line-modified"> 272     auto integralLiteralToken = consumeTypes({ Lexer::Token::Type::IntLiteral, Lexer::Token::Type::UintLiteral });</span>
 273     if (!integralLiteralToken)
<a name="39" id="anc39"></a><span class="line-modified"> 274         return Unexpected&lt;Error&gt;(integralLiteralToken.error());</span>
 275 
 276     switch (integralLiteralToken-&gt;type) {
<a name="40" id="anc40"></a><span class="line-modified"> 277     case Lexer::Token::Type::IntLiteral: {</span>
<span class="line-modified"> 278         auto result = intLiteralToInt(integralLiteralToken-&gt;stringView);</span>
 279         if (result)
 280             return {{ *result }};
<a name="41" id="anc41"></a><span class="line-modified"> 281         return Unexpected&lt;Error&gt;(result.error());</span>
 282     }
 283     default: {
<a name="42" id="anc42"></a><span class="line-modified"> 284         ASSERT(integralLiteralToken-&gt;type == Lexer::Token::Type::UintLiteral);</span>
<span class="line-modified"> 285         auto result = uintLiteralToUint(integralLiteralToken-&gt;stringView);</span>
 286         if (result)
 287             return {{ *result }};
<a name="43" id="anc43"></a><span class="line-modified"> 288         return Unexpected&lt;Error&gt;(result.error());</span>
 289     }
 290     }
 291 }
 292 
 293 auto Parser::consumeNonNegativeIntegralLiteral() -&gt; Expected&lt;unsigned, Error&gt;
 294 {
 295     auto integralLiteral = consumeIntegralLiteral();
 296     if (!integralLiteral)
<a name="44" id="anc44"></a><span class="line-modified"> 297         return Unexpected&lt;Error&gt;(integralLiteral.error());</span>
 298     auto result = WTF::visit(WTF::makeVisitor([](int x) -&gt; Optional&lt;unsigned&gt; {
 299         if (x &lt; 0)
 300             return WTF::nullopt;
 301         return x;
 302     }, [](unsigned x) -&gt; Optional&lt;unsigned&gt; {
 303         return x;
 304     }), *integralLiteral);
 305     if (result)
 306         return *result;
 307     return fail(&quot;int literal is negative&quot;_str);
 308 }
 309 
<a name="45" id="anc45"></a><span class="line-modified"> 310 static Expected&lt;unsigned, Parser::Error&gt; recognizeSimpleUnsignedInteger(StringView stringView)</span>
 311 {
 312     unsigned result = 0;
 313     if (stringView.length() &lt; 1)
<a name="46" id="anc46"></a><span class="line-modified"> 314         return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is too short&quot;)));</span>
 315     for (auto codePoint : stringView.codePoints()) {
 316         if (codePoint &lt; &#39;0&#39; || codePoint &gt; &#39;9&#39;)
<a name="47" id="anc47"></a><span class="line-modified"> 317             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; isn&#39;t of the form [0-9]+&quot;)));</span>
 318         auto previous = result;
 319         result = result * 10 + (codePoint - &#39;0&#39;);
 320         if (result &lt; previous)
<a name="48" id="anc48"></a><span class="line-modified"> 321             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is out of bounds&quot;)));</span>
 322     }
 323     return result;
 324 }
 325 
 326 auto Parser::parseConstantExpression() -&gt; Expected&lt;AST::ConstantExpression, Error&gt;
 327 {
<a name="49" id="anc49"></a><span class="line-modified"> 328     auto type = consumeTypes({</span>
<span class="line-modified"> 329         Lexer::Token::Type::IntLiteral,</span>
<span class="line-modified"> 330         Lexer::Token::Type::UintLiteral,</span>
<span class="line-modified"> 331         Lexer::Token::Type::FloatLiteral,</span>
<span class="line-modified"> 332         Lexer::Token::Type::Null,</span>
<span class="line-modified"> 333         Lexer::Token::Type::True,</span>
<span class="line-modified"> 334         Lexer::Token::Type::False,</span>
<span class="line-modified"> 335         Lexer::Token::Type::Identifier,</span>
<span class="line-removed"> 336     });</span>
 337     if (!type)
<a name="50" id="anc50"></a><span class="line-modified"> 338         return Unexpected&lt;Error&gt;(type.error());</span>
 339 
 340     switch (type-&gt;type) {
<a name="51" id="anc51"></a><span class="line-modified"> 341     case Lexer::Token::Type::IntLiteral: {</span>
<span class="line-modified"> 342         auto value = intLiteralToInt(type-&gt;stringView);</span>
 343         if (!value)
<a name="52" id="anc52"></a><span class="line-modified"> 344             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified"> 345         return {{ AST::IntegerLiteral(WTFMove(*type), *value) }};</span>
 346     }
<a name="53" id="anc53"></a><span class="line-modified"> 347     case Lexer::Token::Type::UintLiteral: {</span>
<span class="line-modified"> 348         auto value = uintLiteralToUint(type-&gt;stringView);</span>
 349         if (!value)
<a name="54" id="anc54"></a><span class="line-modified"> 350             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified"> 351         return {{ AST::UnsignedIntegerLiteral(WTFMove(*type), *value) }};</span>
 352     }
<a name="55" id="anc55"></a><span class="line-modified"> 353     case Lexer::Token::Type::FloatLiteral: {</span>
<span class="line-modified"> 354         auto value = floatLiteralToFloat(type-&gt;stringView);</span>
 355         if (!value)
<a name="56" id="anc56"></a><span class="line-modified"> 356             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified"> 357         return {{ AST::FloatLiteral(WTFMove(*type), *value) }};</span>
 358     }
<a name="57" id="anc57"></a><span class="line-modified"> 359     case Lexer::Token::Type::Null:</span>
 360         return { AST::NullLiteral(WTFMove(*type)) };
<a name="58" id="anc58"></a><span class="line-modified"> 361     case Lexer::Token::Type::True:</span>
 362         return { AST::BooleanLiteral(WTFMove(*type), true) };
<a name="59" id="anc59"></a><span class="line-modified"> 363     case Lexer::Token::Type::False:</span>
 364         return { AST::BooleanLiteral(WTFMove(*type), false) };
 365     default: {
<a name="60" id="anc60"></a><span class="line-modified"> 366         ASSERT(type-&gt;type == Lexer::Token::Type::Identifier);</span>
<span class="line-modified"> 367         auto origin = consumeType(Lexer::Token::Type::FullStop);</span>
<span class="line-modified"> 368         if (!origin)</span>
<span class="line-modified"> 369             return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed"> 370         auto next = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed"> 371         if (!next)</span>
<span class="line-removed"> 372             return Unexpected&lt;Error&gt;(next.error());</span>
<span class="line-removed"> 373         return { AST::EnumerationMemberLiteral(WTFMove(*origin), type-&gt;stringView.toString(), next-&gt;stringView.toString()) };</span>
 374     }
 375     }
 376 }
 377 
 378 auto Parser::parseTypeArgument() -&gt; Expected&lt;AST::TypeArgument, Error&gt;
 379 {
<a name="61" id="anc61"></a><span class="line-modified"> 380     auto constantExpression = backtrackingScope&lt;Expected&lt;AST::ConstantExpression, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified"> 381         return parseConstantExpression();</span>
<span class="line-modified"> 382     });</span>
<span class="line-modified"> 383     if (constantExpression)</span>
 384         return AST::TypeArgument(WTFMove(*constantExpression));
<a name="62" id="anc62"></a><span class="line-modified"> 385     auto result = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified"> 386     if (!result)</span>
<span class="line-modified"> 387         return Unexpected&lt;Error&gt;(result.error());</span>
<span class="line-modified"> 388     return AST::TypeArgument(makeUniqueRef&lt;AST::TypeReference&gt;(Lexer::Token(*result), result-&gt;stringView.toString(), AST::TypeArguments()));</span>
 389 }
 390 
 391 auto Parser::parseTypeArguments() -&gt; Expected&lt;AST::TypeArguments, Error&gt;
 392 {
<a name="63" id="anc63"></a><span class="line-modified"> 393     auto typeArguments = backtrackingScope&lt;Optional&lt;AST::TypeArguments&gt;&gt;([&amp;]() -&gt; Optional&lt;AST::TypeArguments&gt; {</span>
<span class="line-modified"> 394         auto lessThanSign = consumeType(Lexer::Token::Type::LessThanSign);</span>
<span class="line-modified"> 395         if (!lessThanSign)</span>
<span class="line-removed"> 396             return WTF::nullopt;</span>
<span class="line-removed"> 397         AST::TypeArguments typeArguments;</span>
<span class="line-removed"> 398         auto typeArgument = parseTypeArgument();</span>
<span class="line-removed"> 399         if (!typeArgument)</span>
<span class="line-removed"> 400             return WTF::nullopt;</span>
<span class="line-removed"> 401         typeArguments.append(WTFMove(*typeArgument));</span>
<span class="line-removed"> 402         while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-removed"> 403             auto typeArgument = parseTypeArgument();</span>
<span class="line-removed"> 404             if (!typeArgument)</span>
<span class="line-removed"> 405                 return WTF::nullopt;</span>
<span class="line-removed"> 406             typeArguments.append(WTFMove(*typeArgument));</span>
<span class="line-removed"> 407         }</span>
<span class="line-removed"> 408         auto greaterThanSign = consumeType(Lexer::Token::Type::GreaterThanSign);</span>
<span class="line-removed"> 409         if (!greaterThanSign)</span>
<span class="line-removed"> 410             return WTF::nullopt;</span>
 411         return typeArguments;
<a name="64" id="anc64"></a><span class="line-removed"> 412     });</span>
<span class="line-removed"> 413     if (typeArguments)</span>
<span class="line-removed"> 414         return WTFMove(*typeArguments);</span>
 415 
<a name="65" id="anc65"></a><span class="line-modified"> 416     typeArguments = backtrackingScope&lt;Optional&lt;AST::TypeArguments&gt;&gt;([&amp;]() -&gt; Optional&lt;AST::TypeArguments&gt; {</span>
<span class="line-modified"> 417         auto lessThanSign = consumeType(Lexer::Token::Type::LessThanSign);</span>
<span class="line-modified"> 418         if (!lessThanSign)</span>
<span class="line-modified"> 419             return WTF::nullopt;</span>
<span class="line-modified"> 420         auto greaterThanSign = consumeType(Lexer::Token::Type::GreaterThanSign);</span>
<span class="line-modified"> 421         if (!greaterThanSign)</span>
<span class="line-modified"> 422             return WTF::nullopt;</span>
<span class="line-modified"> 423         return {{ }};</span>
<span class="line-modified"> 424     });</span>
<span class="line-modified"> 425     if (typeArguments)</span>
<span class="line-modified"> 426         return WTFMove(*typeArguments);</span>





 427 
<a name="66" id="anc66"></a><span class="line-modified"> 428     return AST::TypeArguments();</span>
 429 }
 430 
 431 auto Parser::parseTypeSuffixAbbreviated() -&gt; Expected&lt;TypeSuffixAbbreviated, Error&gt;
 432 {
<a name="67" id="anc67"></a><span class="line-modified"> 433     auto token = consumeTypes({ Lexer::Token::Type::Star, Lexer::Token::Type::SquareBracketPair, Lexer::Token::Type::LeftSquareBracket });</span>



 434     if (!token)
<a name="68" id="anc68"></a><span class="line-modified"> 435         return Unexpected&lt;Error&gt;(token.error());</span>
<span class="line-modified"> 436     if (token-&gt;type == Lexer::Token::Type::LeftSquareBracket) {</span>
 437         auto numElements = consumeNonNegativeIntegralLiteral();
 438         if (!numElements)
<a name="69" id="anc69"></a><span class="line-modified"> 439             return Unexpected&lt;Error&gt;(numElements.error());</span>
<span class="line-modified"> 440         auto rightSquareBracket = consumeType(Lexer::Token::Type::RightSquareBracket);</span>
<span class="line-modified"> 441         if (!rightSquareBracket)</span>
<span class="line-removed"> 442             return Unexpected&lt;Error&gt;(rightSquareBracket.error());</span>
<span class="line-removed"> 443         return {{ *token, *numElements }};</span>
 444     }
<a name="70" id="anc70"></a><span class="line-modified"> 445     return {{ *token, WTF::nullopt }};</span>
 446 }
 447 
 448 auto Parser::parseTypeSuffixNonAbbreviated() -&gt; Expected&lt;TypeSuffixNonAbbreviated, Error&gt;
 449 {
<a name="71" id="anc71"></a><span class="line-modified"> 450     auto token = consumeTypes({ Lexer::Token::Type::Star, Lexer::Token::Type::SquareBracketPair, Lexer::Token::Type::LeftSquareBracket });</span>



 451     if (!token)
<a name="72" id="anc72"></a><span class="line-modified"> 452         return Unexpected&lt;Error&gt;(token.error());</span>
<span class="line-modified"> 453     if (token-&gt;type == Lexer::Token::Type::LeftSquareBracket) {</span>
 454         auto numElements = consumeNonNegativeIntegralLiteral();
 455         if (!numElements)
<a name="73" id="anc73"></a><span class="line-modified"> 456             return Unexpected&lt;Error&gt;(numElements.error());</span>
<span class="line-modified"> 457         auto rightSquareBracket = consumeType(Lexer::Token::Type::RightSquareBracket);</span>
<span class="line-modified"> 458         if (!rightSquareBracket)</span>
<span class="line-modified"> 459             return Unexpected&lt;Error&gt;(rightSquareBracket.error());</span>
<span class="line-modified"> 460         return {{ *token, WTF::nullopt, *numElements }};</span>
<span class="line-modified"> 461     }</span>
<span class="line-modified"> 462     auto addressSpaceToken = consumeTypes({ Lexer::Token::Type::Constant, Lexer::Token::Type::Device, Lexer::Token::Type::Threadgroup, Lexer::Token::Type::Thread});</span>


 463     if (!addressSpaceToken)
<a name="74" id="anc74"></a><span class="line-modified"> 464         return Unexpected&lt;Error&gt;(addressSpaceToken.error());</span>
 465     AST::AddressSpace addressSpace;
 466     switch (addressSpaceToken-&gt;type) {
<a name="75" id="anc75"></a><span class="line-modified"> 467     case Lexer::Token::Type::Constant:</span>
 468         addressSpace = AST::AddressSpace::Constant;
 469         break;
<a name="76" id="anc76"></a><span class="line-modified"> 470     case Lexer::Token::Type::Device:</span>
 471         addressSpace = AST::AddressSpace::Device;
 472         break;
<a name="77" id="anc77"></a><span class="line-modified"> 473     case Lexer::Token::Type::Threadgroup:</span>
 474         addressSpace = AST::AddressSpace::Threadgroup;
 475         break;
 476     default:
<a name="78" id="anc78"></a><span class="line-modified"> 477         ASSERT(addressSpaceToken-&gt;type == Lexer::Token::Type::Thread);</span>
 478         addressSpace = AST::AddressSpace::Thread;
 479         break;
 480     }
<a name="79" id="anc79"></a><span class="line-modified"> 481     return {{ *token, { addressSpace }, WTF::nullopt }};</span>
 482 }
 483 
<a name="80" id="anc80"></a><span class="line-modified"> 484 auto Parser::parseAddressSpaceType() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;</span>
 485 {
<a name="81" id="anc81"></a><span class="line-modified"> 486     auto addressSpaceToken = consumeTypes({ Lexer::Token::Type::Constant, Lexer::Token::Type::Device, Lexer::Token::Type::Threadgroup, Lexer::Token::Type::Thread});</span>
<span class="line-modified"> 487     if (!addressSpaceToken)</span>
<span class="line-modified"> 488         return Unexpected&lt;Error&gt;(addressSpaceToken.error());</span>
<span class="line-modified"> 489     AST::AddressSpace addressSpace;</span>
<span class="line-modified"> 490     switch (addressSpaceToken-&gt;type) {</span>
<span class="line-removed"> 491     case Lexer::Token::Type::Constant:</span>
<span class="line-removed"> 492         addressSpace = AST::AddressSpace::Constant;</span>
<span class="line-removed"> 493         break;</span>
<span class="line-removed"> 494     case Lexer::Token::Type::Device:</span>
<span class="line-removed"> 495         addressSpace = AST::AddressSpace::Device;</span>
<span class="line-removed"> 496         break;</span>
<span class="line-removed"> 497     case Lexer::Token::Type::Threadgroup:</span>
<span class="line-removed"> 498         addressSpace = AST::AddressSpace::Threadgroup;</span>
<span class="line-removed"> 499         break;</span>
<span class="line-removed"> 500     default:</span>
<span class="line-removed"> 501         ASSERT(addressSpaceToken-&gt;type == Lexer::Token::Type::Thread);</span>
<span class="line-removed"> 502         addressSpace = AST::AddressSpace::Thread;</span>
<span class="line-removed"> 503         break;</span>
<span class="line-removed"> 504     }</span>
<span class="line-removed"> 505     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed"> 506     if (!name)</span>
<span class="line-removed"> 507         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed"> 508     auto typeArguments = parseTypeArguments();</span>
<span class="line-removed"> 509     if (!typeArguments)</span>
<span class="line-removed"> 510         return Unexpected&lt;Error&gt;(typeArguments.error());</span>
<span class="line-removed"> 511 </span>
<span class="line-removed"> 512     auto constructTypeFromSuffixAbbreviated = [&amp;](const TypeSuffixAbbreviated&amp; typeSuffixAbbreviated, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
<span class="line-removed"> 513         switch (typeSuffixAbbreviated.token.type) {</span>
<span class="line-removed"> 514         case Lexer::Token::Type::Star:</span>
<span class="line-removed"> 515             return { makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(typeSuffixAbbreviated.token), addressSpace, WTFMove(previous)) };</span>
<span class="line-removed"> 516         case Lexer::Token::Type::SquareBracketPair:</span>
<span class="line-removed"> 517             return { makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(typeSuffixAbbreviated.token), addressSpace, WTFMove(previous)) };</span>
<span class="line-removed"> 518         default:</span>
<span class="line-removed"> 519             ASSERT(typeSuffixAbbreviated.token.type == Lexer::Token::Type::LeftSquareBracket);</span>
<span class="line-removed"> 520             return { makeUniqueRef&lt;AST::ArrayType&gt;(Lexer::Token(typeSuffixAbbreviated.token), WTFMove(previous), *typeSuffixAbbreviated.numElements) };</span>
<span class="line-removed"> 521         }</span>
<span class="line-removed"> 522     };</span>
 523 
<a name="82" id="anc82"></a><span class="line-modified"> 524     auto firstTypeSuffixAbbreviated = parseTypeSuffixAbbreviated();</span>
<span class="line-modified"> 525     if (!firstTypeSuffixAbbreviated)</span>
<span class="line-modified"> 526         return Unexpected&lt;Error&gt;(firstTypeSuffixAbbreviated.error());</span>
<span class="line-modified"> 527     UniqueRef&lt;AST::UnnamedType&gt; result = makeUniqueRef&lt;AST::TypeReference&gt;(WTFMove(*addressSpaceToken), name-&gt;stringView.toString(), WTFMove(*typeArguments));</span>
<span class="line-modified"> 528     auto next = constructTypeFromSuffixAbbreviated(*firstTypeSuffixAbbreviated, WTFMove(result));</span>
<span class="line-modified"> 529     result = WTFMove(next);</span>
<span class="line-modified"> 530     while (true) {</span>
<span class="line-modified"> 531         auto typeSuffixAbbreviated = backtrackingScope&lt;Expected&lt;TypeSuffixAbbreviated, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 532             return parseTypeSuffixAbbreviated();</span>
<span class="line-removed"> 533         });</span>
<span class="line-removed"> 534         if (!typeSuffixAbbreviated)</span>
 535             break;
<a name="83" id="anc83"></a><span class="line-modified"> 536         // FIXME: The nesting here might be in the wrong order.</span>
<span class="line-modified"> 537         next = constructTypeFromSuffixAbbreviated(*typeSuffixAbbreviated, WTFMove(result));</span>
























 538         result = WTFMove(next);
<a name="84" id="anc84"></a>












 539     }
 540 
<a name="85" id="anc85"></a><span class="line-modified"> 541     return WTFMove(result);</span>
<span class="line-modified"> 542 }</span>
<span class="line-removed"> 543 </span>
<span class="line-removed"> 544 auto Parser::parseNonAddressSpaceType() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;</span>
<span class="line-removed"> 545 {</span>
<span class="line-removed"> 546     auto origin = peek();</span>
<span class="line-removed"> 547     if (!origin)</span>
<span class="line-removed"> 548         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed"> 549     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed"> 550     if (!name)</span>
<span class="line-removed"> 551         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed"> 552     auto typeArguments = parseTypeArguments();</span>
<span class="line-removed"> 553     if (!typeArguments)</span>
<span class="line-removed"> 554         return Unexpected&lt;Error&gt;(typeArguments.error());</span>
<span class="line-removed"> 555 </span>
<span class="line-removed"> 556     auto constructTypeFromSuffixNonAbbreviated = [&amp;](const TypeSuffixNonAbbreviated&amp; typeSuffixNonAbbreviated, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
 557         switch (typeSuffixNonAbbreviated.token.type) {
<a name="86" id="anc86"></a><span class="line-modified"> 558         case Lexer::Token::Type::Star:</span>
<span class="line-modified"> 559             return { makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(typeSuffixNonAbbreviated.token), *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };</span>
<span class="line-modified"> 560         case Lexer::Token::Type::SquareBracketPair:</span>
<span class="line-modified"> 561             return { makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(typeSuffixNonAbbreviated.token), *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };</span>
 562         default:
<a name="87" id="anc87"></a><span class="line-modified"> 563             ASSERT(typeSuffixNonAbbreviated.token.type == Lexer::Token::Type::LeftSquareBracket);</span>
<span class="line-modified"> 564             return { makeUniqueRef&lt;AST::ArrayType&gt;(Lexer::Token(typeSuffixNonAbbreviated.token), WTFMove(previous), *typeSuffixNonAbbreviated.numElements) };</span>
 565         }
 566     };
<a name="88" id="anc88"></a><span class="line-modified"> 567 </span>
<span class="line-removed"> 568     UniqueRef&lt;AST::UnnamedType&gt; result = makeUniqueRef&lt;AST::TypeReference&gt;(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*typeArguments));</span>
 569     while (true) {
<a name="89" id="anc89"></a><span class="line-modified"> 570         auto typeSuffixNonAbbreviated = backtrackingScope&lt;Expected&lt;TypeSuffixNonAbbreviated, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified"> 571             return parseTypeSuffixNonAbbreviated();</span>
<span class="line-modified"> 572         });</span>
<span class="line-modified"> 573         if (!typeSuffixNonAbbreviated)</span>
 574             break;
<a name="90" id="anc90"></a>

 575         // FIXME: The nesting here might be in the wrong order.
 576         auto next = constructTypeFromSuffixNonAbbreviated(*typeSuffixNonAbbreviated, WTFMove(result));
 577         result = WTFMove(next);
 578     }
<a name="91" id="anc91"></a><span class="line-removed"> 579 </span>
 580     return WTFMove(result);
 581 }
 582 
<a name="92" id="anc92"></a><span class="line-removed"> 583 auto Parser::parseType() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;</span>
<span class="line-removed"> 584 {</span>
<span class="line-removed"> 585     auto type = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 586         return parseAddressSpaceType();</span>
<span class="line-removed"> 587     });</span>
<span class="line-removed"> 588     if (type)</span>
<span class="line-removed"> 589         return type;</span>
<span class="line-removed"> 590 </span>
<span class="line-removed"> 591     type = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 592         return parseNonAddressSpaceType();</span>
<span class="line-removed"> 593     });</span>
<span class="line-removed"> 594     if (type)</span>
<span class="line-removed"> 595         return type;</span>
<span class="line-removed"> 596 </span>
<span class="line-removed"> 597     return Unexpected&lt;Error&gt;(type.error());</span>
<span class="line-removed"> 598 }</span>
<span class="line-removed"> 599 </span>
 600 auto Parser::parseTypeDefinition() -&gt; Expected&lt;AST::TypeDefinition, Error&gt;
 601 {
<a name="93" id="anc93"></a><span class="line-modified"> 602     auto origin = consumeType(Lexer::Token::Type::Typedef);</span>
<span class="line-modified"> 603     if (!origin)</span>
<span class="line-modified"> 604         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified"> 605     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified"> 606     if (!name)</span>
<span class="line-modified"> 607         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed"> 608     auto equals = consumeType(Lexer::Token::Type::EqualsSign);</span>
<span class="line-removed"> 609     if (!equals)</span>
<span class="line-removed"> 610         return Unexpected&lt;Error&gt;(equals.error());</span>
<span class="line-removed"> 611     auto type = parseType();</span>
<span class="line-removed"> 612     if (!type)</span>
<span class="line-removed"> 613         return Unexpected&lt;Error&gt;(type.error());</span>
<span class="line-removed"> 614     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed"> 615     if (!semicolon)</span>
<span class="line-removed"> 616         return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed"> 617     return AST::TypeDefinition(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*type));</span>
 618 }
 619 
 620 auto Parser::parseBuiltInSemantic() -&gt; Expected&lt;AST::BuiltInSemantic, Error&gt;
 621 {
<a name="94" id="anc94"></a><span class="line-modified"> 622     auto origin = consumeTypes({</span>
<span class="line-modified"> 623         Lexer::Token::Type::SVInstanceID,</span>
<span class="line-modified"> 624         Lexer::Token::Type::SVVertexID,</span>
<span class="line-modified"> 625         Lexer::Token::Type::PSize,</span>
<span class="line-modified"> 626         Lexer::Token::Type::SVPosition,</span>
<span class="line-modified"> 627         Lexer::Token::Type::SVIsFrontFace,</span>
<span class="line-modified"> 628         Lexer::Token::Type::SVSampleIndex,</span>
<span class="line-modified"> 629         Lexer::Token::Type::SVInnerCoverage,</span>
<span class="line-modified"> 630         Lexer::Token::Type::SVTarget,</span>
<span class="line-modified"> 631         Lexer::Token::Type::SVDepth,</span>
<span class="line-modified"> 632         Lexer::Token::Type::SVCoverage,</span>
<span class="line-modified"> 633         Lexer::Token::Type::SVDispatchThreadID,</span>
<span class="line-modified"> 634         Lexer::Token::Type::SVGroupID,</span>
<span class="line-modified"> 635         Lexer::Token::Type::SVGroupIndex,</span>
<span class="line-modified"> 636         Lexer::Token::Type::SVGroupThreadID});</span>
 637     if (!origin)
<a name="95" id="anc95"></a><span class="line-modified"> 638         return Unexpected&lt;Error&gt;(origin.error());</span>
 639 
 640     switch (origin-&gt;type) {
<a name="96" id="anc96"></a><span class="line-modified"> 641     case Lexer::Token::Type::SVInstanceID:</span>
<span class="line-modified"> 642         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVInstanceID);</span>
<span class="line-modified"> 643     case Lexer::Token::Type::SVVertexID:</span>
<span class="line-modified"> 644         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVVertexID);</span>
<span class="line-modified"> 645     case Lexer::Token::Type::PSize:</span>
<span class="line-modified"> 646         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::PSize);</span>
<span class="line-modified"> 647     case Lexer::Token::Type::SVPosition:</span>
<span class="line-modified"> 648         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVPosition);</span>
<span class="line-modified"> 649     case Lexer::Token::Type::SVIsFrontFace:</span>
<span class="line-modified"> 650         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVIsFrontFace);</span>
<span class="line-modified"> 651     case Lexer::Token::Type::SVSampleIndex:</span>
<span class="line-modified"> 652         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVSampleIndex);</span>
<span class="line-modified"> 653     case Lexer::Token::Type::SVInnerCoverage:</span>
<span class="line-modified"> 654         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVInnerCoverage);</span>
<span class="line-modified"> 655     case Lexer::Token::Type::SVTarget: {</span>
<span class="line-modified"> 656         auto target = consumeNonNegativeIntegralLiteral();</span>
 657         if (!target)
<a name="97" id="anc97"></a><span class="line-modified"> 658             return Unexpected&lt;Error&gt;(target.error());</span>
<span class="line-modified"> 659         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVTarget, *target);</span>
<span class="line-modified"> 660     }</span>
<span class="line-modified"> 661     case Lexer::Token::Type::SVDepth:</span>
<span class="line-modified"> 662         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVDepth);</span>
<span class="line-modified"> 663     case Lexer::Token::Type::SVCoverage:</span>
<span class="line-modified"> 664         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVCoverage);</span>
<span class="line-modified"> 665     case Lexer::Token::Type::SVDispatchThreadID:</span>
<span class="line-modified"> 666         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVDispatchThreadID);</span>
<span class="line-modified"> 667     case Lexer::Token::Type::SVGroupID:</span>
<span class="line-modified"> 668         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVGroupID);</span>
<span class="line-modified"> 669     case Lexer::Token::Type::SVGroupIndex:</span>
<span class="line-modified"> 670         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVGroupIndex);</span>
 671     default:
<a name="98" id="anc98"></a><span class="line-modified"> 672         ASSERT(origin-&gt;type == Lexer::Token::Type::SVGroupThreadID);</span>
<span class="line-modified"> 673         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVGroupThreadID);</span>
 674     }
 675 }
 676 
 677 auto Parser::parseResourceSemantic() -&gt; Expected&lt;AST::ResourceSemantic, Error&gt;
 678 {
<a name="99" id="anc99"></a><span class="line-modified"> 679     auto origin = consumeType(Lexer::Token::Type::Register);</span>
<span class="line-modified"> 680     if (!origin)</span>
<span class="line-removed"> 681         return Unexpected&lt;Error&gt;(origin.error());</span>
 682 
<a name="100" id="anc100"></a><span class="line-modified"> 683     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-modified"> 684     if (!leftParenthesis)</span>
<span class="line-modified"> 685         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-modified"> 686 </span>
<span class="line-modified"> 687     auto info = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified"> 688     if (!info)</span>
<span class="line-modified"> 689         return Unexpected&lt;Error&gt;(info.error());</span>
<span class="line-removed"> 690     if (info-&gt;stringView.length() &lt; 2 || (info-&gt;stringView[0] != &#39;u&#39;</span>
<span class="line-removed"> 691         &amp;&amp; info-&gt;stringView[0] != &#39;t&#39;</span>
<span class="line-removed"> 692         &amp;&amp; info-&gt;stringView[0] != &#39;b&#39;</span>
<span class="line-removed"> 693         &amp;&amp; info-&gt;stringView[0] != &#39;s&#39;))</span>
<span class="line-removed"> 694         return Unexpected&lt;Error&gt;(Error(makeString(info-&gt;stringView.substring(0, 1), &quot; is not a known resource type (&#39;u&#39;, &#39;t&#39;, &#39;b&#39;, or &#39;s&#39;)&quot;)));</span>
 695 
 696     AST::ResourceSemantic::Mode mode;
<a name="101" id="anc101"></a><span class="line-modified"> 697     switch (info-&gt;stringView[0]) {</span>
 698     case &#39;u&#39;:
 699         mode = AST::ResourceSemantic::Mode::UnorderedAccessView;
 700         break;
 701     case &#39;t&#39;:
 702         mode = AST::ResourceSemantic::Mode::Texture;
 703         break;
 704     case &#39;b&#39;:
 705         mode = AST::ResourceSemantic::Mode::Buffer;
 706         break;
 707     case &#39;s&#39;:
 708         mode = AST::ResourceSemantic::Mode::Sampler;
 709         break;
 710     }
 711 
<a name="102" id="anc102"></a><span class="line-modified"> 712     auto index = recognizeSimpleUnsignedInteger(info-&gt;stringView.substring(1));</span>
 713     if (!index)
<a name="103" id="anc103"></a><span class="line-modified"> 714         return Unexpected&lt;Error&gt;(index.error());</span>
 715 
 716     unsigned space = 0;
<a name="104" id="anc104"></a><span class="line-modified"> 717     if (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified"> 718         auto spaceToken = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified"> 719         if (!spaceToken)</span>
<span class="line-modified"> 720             return Unexpected&lt;Error&gt;(spaceToken.error());</span>
<span class="line-modified"> 721         auto prefix = &quot;space&quot;_str;</span>
<span class="line-modified"> 722         if (!spaceToken-&gt;stringView.startsWith(StringView(prefix)))</span>
<span class="line-modified"> 723             return Unexpected&lt;Error&gt;(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceToken-&gt;stringView, &quot; needs be of the form &#39;space0&#39;&quot;)));</span>
<span class="line-modified"> 724         if (spaceToken-&gt;stringView.length() &lt;= prefix.length())</span>
<span class="line-modified"> 725             return Unexpected&lt;Error&gt;(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceToken-&gt;stringView, &quot; needs be of the form &#39;space0&#39;&quot;)));</span>
<span class="line-removed"> 726         auto spaceValue = recognizeSimpleUnsignedInteger(spaceToken-&gt;stringView.substring(prefix.length()));</span>
 727         if (!spaceValue)
<a name="105" id="anc105"></a><span class="line-modified"> 728             return Unexpected&lt;Error&gt;(spaceValue.error());</span>
 729         space = *spaceValue;
 730     }
 731 
<a name="106" id="anc106"></a><span class="line-modified"> 732     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed"> 733     if (!rightParenthesis)</span>
<span class="line-removed"> 734         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
 735 
<a name="107" id="anc107"></a><span class="line-modified"> 736     return AST::ResourceSemantic(WTFMove(*origin), mode, *index, space);</span>
 737 }
 738 
 739 auto Parser::parseSpecializationConstantSemantic() -&gt; Expected&lt;AST::SpecializationConstantSemantic, Error&gt;
 740 {
<a name="108" id="anc108"></a><span class="line-modified"> 741     auto origin = consumeType(Lexer::Token::Type::Specialized);</span>
<span class="line-modified"> 742     if (!origin)</span>
<span class="line-removed"> 743         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed"> 744     return AST::SpecializationConstantSemantic(WTFMove(*origin));</span>
 745 }
 746 
 747 auto Parser::parseStageInOutSemantic() -&gt; Expected&lt;AST::StageInOutSemantic, Error&gt;
 748 {
<a name="109" id="anc109"></a><span class="line-modified"> 749     auto origin = consumeType(Lexer::Token::Type::Attribute);</span>
<span class="line-modified"> 750     if (!origin)</span>
<span class="line-removed"> 751         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed"> 752 </span>
<span class="line-removed"> 753     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed"> 754     if (!leftParenthesis)</span>
<span class="line-removed"> 755         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
 756 
 757     auto index = consumeNonNegativeIntegralLiteral();
 758     if (!index)
<a name="110" id="anc110"></a><span class="line-modified"> 759         return Unexpected&lt;Error&gt;(index.error());</span>
 760 
<a name="111" id="anc111"></a><span class="line-modified"> 761     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed"> 762     if (!rightParenthesis)</span>
<span class="line-removed"> 763         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
 764 
<a name="112" id="anc112"></a><span class="line-modified"> 765     return AST::StageInOutSemantic(WTFMove(*origin), *index);</span>
 766 }
 767 
<a name="113" id="anc113"></a><span class="line-modified"> 768 auto Parser::parseSemantic() -&gt; Expected&lt;AST::Semantic, Error&gt;</span>
 769 {
<a name="114" id="anc114"></a><span class="line-modified"> 770     auto builtInSemantic = backtrackingScope&lt;Expected&lt;AST::BuiltInSemantic, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified"> 771         return parseBuiltInSemantic();</span>
<span class="line-removed"> 772     });</span>
<span class="line-removed"> 773     if (builtInSemantic)</span>
<span class="line-removed"> 774         return AST::Semantic(WTFMove(*builtInSemantic));</span>
<span class="line-removed"> 775 </span>
<span class="line-removed"> 776     auto resourceSemantic = backtrackingScope&lt;Expected&lt;AST::ResourceSemantic, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 777         return parseResourceSemantic();</span>
<span class="line-removed"> 778     });</span>
<span class="line-removed"> 779     if (resourceSemantic)</span>
<span class="line-removed"> 780         return AST::Semantic(WTFMove(*resourceSemantic));</span>
<span class="line-removed"> 781 </span>
<span class="line-removed"> 782     auto specializationConstantSemantic = backtrackingScope&lt;Expected&lt;AST::SpecializationConstantSemantic, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 783         return parseSpecializationConstantSemantic();</span>
<span class="line-removed"> 784     });</span>
<span class="line-removed"> 785     if (specializationConstantSemantic)</span>
<span class="line-removed"> 786         return AST::Semantic(WTFMove(*specializationConstantSemantic));</span>
<span class="line-removed"> 787 </span>
<span class="line-removed"> 788     auto stageInOutSemantic = backtrackingScope&lt;Expected&lt;AST::StageInOutSemantic, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed"> 789         return parseStageInOutSemantic();</span>
<span class="line-removed"> 790     });</span>
<span class="line-removed"> 791     if (stageInOutSemantic)</span>
<span class="line-removed"> 792         return AST::Semantic(WTFMove(*stageInOutSemantic));</span>
 793 
<a name="115" id="anc115"></a><span class="line-modified"> 794     return Unexpected&lt;Error&gt;(stageInOutSemantic.error());</span>


















 795 }
 796 AST::Qualifiers Parser::parseQualifiers()
 797 {
 798     AST::Qualifiers qualifiers;
<a name="116" id="anc116"></a><span class="line-modified"> 799     while (true) {</span>
<span class="line-modified"> 800         if (auto next = tryType(Lexer::Token::Type::Qualifier)) {</span>
<span class="line-modified"> 801             if (&quot;nointerpolation&quot; == next-&gt;stringView)</span>
<span class="line-modified"> 802                 qualifiers.append(AST::Qualifier::Nointerpolation);</span>
<span class="line-modified"> 803             else if (&quot;noperspective&quot; == next-&gt;stringView)</span>
<span class="line-modified"> 804                 qualifiers.append(AST::Qualifier::Noperspective);</span>
<span class="line-modified"> 805             else if (&quot;uniform&quot; == next-&gt;stringView)</span>
<span class="line-modified"> 806                 qualifiers.append(AST::Qualifier::Uniform);</span>
<span class="line-modified"> 807             else if (&quot;centroid&quot; == next-&gt;stringView)</span>
<span class="line-modified"> 808                 qualifiers.append(AST::Qualifier::Centroid);</span>
<span class="line-modified"> 809             else {</span>
<span class="line-modified"> 810                 ASSERT(&quot;sample&quot; == next-&gt;stringView);</span>
<span class="line-modified"> 811                 qualifiers.append(AST::Qualifier::Sample);</span>
<span class="line-modified"> 812             }</span>
<span class="line-removed"> 813         } else</span>
<span class="line-removed"> 814             break;</span>
 815     }
 816     return qualifiers;
 817 }
 818 
 819 auto Parser::parseStructureElement() -&gt; Expected&lt;AST::StructureElement, Error&gt;
 820 {
<a name="117" id="anc117"></a><span class="line-modified"> 821     auto origin = peek();</span>
<span class="line-removed"> 822     if (!origin)</span>
<span class="line-removed"> 823         return Unexpected&lt;Error&gt;(origin.error());</span>
 824 
 825     AST::Qualifiers qualifiers = parseQualifiers();
 826 
<a name="118" id="anc118"></a><span class="line-modified"> 827     auto type = parseType();</span>
<span class="line-modified"> 828     if (!type)</span>
<span class="line-modified"> 829         return Unexpected&lt;Error&gt;(type.error());</span>
<span class="line-modified"> 830 </span>
<span class="line-removed"> 831     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed"> 832     if (!name)</span>
<span class="line-removed"> 833         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed"> 834 </span>
<span class="line-removed"> 835     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed"> 836         auto semantic = parseSemantic();</span>
<span class="line-removed"> 837         if (!semantic)</span>
<span class="line-removed"> 838             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed"> 839 </span>
<span class="line-removed"> 840         auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed"> 841         if (!semicolon)</span>
<span class="line-removed"> 842             return Unexpected&lt;Error&gt;(semicolon.error());</span>
 843 
<a name="119" id="anc119"></a><span class="line-modified"> 844         return AST::StructureElement(WTFMove(*origin), WTFMove(qualifiers), WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*semantic));</span>
<span class="line-removed"> 845     }</span>
<span class="line-removed"> 846 </span>
<span class="line-removed"> 847     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed"> 848     if (!semicolon)</span>
<span class="line-removed"> 849         return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed"> 850 </span>
<span class="line-removed"> 851     return AST::StructureElement(WTFMove(*origin), WTFMove(qualifiers), WTFMove(*type), name-&gt;stringView.toString(), WTF::nullopt);</span>
 852 }
 853 
 854 auto Parser::parseStructureDefinition() -&gt; Expected&lt;AST::StructureDefinition, Error&gt;
 855 {
<a name="120" id="anc120"></a><span class="line-modified"> 856     auto origin = consumeType(Lexer::Token::Type::Struct);</span>
<span class="line-modified"> 857     if (!origin)</span>
<span class="line-modified"> 858         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed"> 859 </span>
<span class="line-removed"> 860     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed"> 861     if (!name)</span>
<span class="line-removed"> 862         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed"> 863 </span>
<span class="line-removed"> 864     auto leftCurlyBracket = consumeType(Lexer::Token::Type::LeftCurlyBracket);</span>
<span class="line-removed"> 865     if (!leftCurlyBracket)</span>
<span class="line-removed"> 866         return Unexpected&lt;Error&gt;(leftCurlyBracket.error());</span>
 867 
 868     AST::StructureElements structureElements;
<a name="121" id="anc121"></a><span class="line-modified"> 869     while (true) {</span>
<span class="line-modified"> 870         auto structureElement = backtrackingScope&lt;Expected&lt;AST::StructureElement, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified"> 871             return parseStructureElement();</span>
<span class="line-removed"> 872         });</span>
<span class="line-removed"> 873         if (structureElement)</span>
<span class="line-removed"> 874             structureElements.append(WTFMove(*structureElement));</span>
<span class="line-removed"> 875         else</span>
<span class="line-removed"> 876             break;</span>
 877     }
 878 
<a name="122" id="anc122"></a><span class="line-modified"> 879     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);</span>
<span class="line-removed"> 880     if (!rightCurlyBracket)</span>
<span class="line-removed"> 881         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());</span>
 882 
<a name="123" id="anc123"></a><span class="line-modified"> 883     return AST::StructureDefinition(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(structureElements));</span>
 884 }
 885 
 886 auto Parser::parseEnumerationDefinition() -&gt; Expected&lt;AST::EnumerationDefinition, Error&gt;
 887 {
<a name="124" id="anc124"></a><span class="line-modified"> 888     auto origin = consumeType(Lexer::Token::Type::Enum);</span>
<span class="line-modified"> 889     if (!origin)</span>
<span class="line-removed"> 890         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed"> 891 </span>
<span class="line-removed"> 892     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed"> 893     if (!name)</span>
<span class="line-removed"> 894         return Unexpected&lt;Error&gt;(name.error());</span>
 895 
<a name="125" id="anc125"></a><span class="line-modified"> 896     auto type = ([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt; {</span>
<span class="line-modified"> 897         if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-modified"> 898             auto parsedType = parseType();</span>
<span class="line-removed"> 899             if (!parsedType)</span>
<span class="line-removed"> 900                 return Unexpected&lt;Error&gt;(parsedType.error());</span>
 901             return WTFMove(*parsedType);
 902         }
<a name="126" id="anc126"></a><span class="line-modified"> 903         return { makeUniqueRef&lt;AST::TypeReference&gt;(Lexer::Token(*origin), &quot;int&quot;_str, AST::TypeArguments()) };</span>
 904     })();
 905     if (!type)
<a name="127" id="anc127"></a><span class="line-modified"> 906         return Unexpected&lt;Error&gt;(type.error());</span>
 907 
<a name="128" id="anc128"></a><span class="line-modified"> 908     auto leftCurlyBracket = consumeType(Lexer::Token::Type::LeftCurlyBracket);</span>
<span class="line-removed"> 909     if (!leftCurlyBracket)</span>
<span class="line-removed"> 910         return Unexpected&lt;Error&gt;(leftCurlyBracket.error());</span>
 911 
<a name="129" id="anc129"></a><span class="line-modified"> 912     auto firstEnumerationMember = parseEnumerationMember();</span>
<span class="line-modified"> 913     if (!firstEnumerationMember)</span>
<span class="line-modified"> 914         return Unexpected&lt;Error&gt;(firstEnumerationMember.error());</span>
 915 
<a name="130" id="anc130"></a><span class="line-modified"> 916     AST::EnumerationDefinition result(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*type));</span>
 917     auto success = result.add(WTFMove(*firstEnumerationMember));
 918     if (!success)
 919         return fail(&quot;Cannot add enumeration member&quot;_str);
 920 
<a name="131" id="anc131"></a><span class="line-modified"> 921     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified"> 922         auto member = parseEnumerationMember();</span>
<span class="line-modified"> 923         if (!member)</span>
<span class="line-removed"> 924             return Unexpected&lt;Error&gt;(member.error());</span>
 925         success = result.add(WTFMove(*member));
 926         if (!success)
 927             return fail(&quot;Cannot add enumeration member&quot;_str);
 928     }
 929 
<a name="132" id="anc132"></a><span class="line-modified"> 930     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);</span>
<span class="line-modified"> 931     if (!rightCurlyBracket)</span>
<span class="line-removed"> 932         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());</span>
 933 
 934     return WTFMove(result);
 935 }
 936 
<a name="133" id="anc133"></a><span class="line-modified"> 937 auto Parser::parseEnumerationMember() -&gt; Expected&lt;AST::EnumerationMember, Error&gt;</span>
 938 {
<a name="134" id="anc134"></a><span class="line-modified"> 939     auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified"> 940     if (!identifier)</span>
<span class="line-modified"> 941         return Unexpected&lt;Error&gt;(identifier.error());</span>
<span class="line-modified"> 942     auto name = identifier-&gt;stringView.toString();</span>

 943 
<a name="135" id="anc135"></a><span class="line-modified"> 944     if (tryType(Lexer::Token::Type::EqualsSign)) {</span>
<span class="line-modified"> 945         auto constantExpression = parseConstantExpression();</span>
<span class="line-modified"> 946         if (!constantExpression)</span>
<span class="line-modified"> 947             return Unexpected&lt;Error&gt;(constantExpression.error());</span>
<span class="line-modified"> 948         return AST::EnumerationMember(Lexer::Token(*identifier), WTFMove(name), WTFMove(*constantExpression));</span>









 949     }
<a name="136" id="anc136"></a><span class="line-modified"> 950     return AST::EnumerationMember(Lexer::Token(*identifier), WTFMove(name));</span>
 951 }
 952 
 953 auto Parser::parseNativeTypeDeclaration() -&gt; Expected&lt;AST::NativeTypeDeclaration, Error&gt;
 954 {
<a name="137" id="anc137"></a><span class="line-modified"> 955     auto origin = consumeType(Lexer::Token::Type::Native);</span>
<span class="line-modified"> 956     if (!origin)</span>
<span class="line-modified"> 957         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified"> 958 </span>
<span class="line-modified"> 959     auto parsedTypedef = consumeType(Lexer::Token::Type::Typedef);</span>
<span class="line-removed"> 960     if (!parsedTypedef)</span>
<span class="line-removed"> 961         return Unexpected&lt;Error&gt;(parsedTypedef.error());</span>
<span class="line-removed"> 962 </span>
<span class="line-removed"> 963     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed"> 964     if (!name)</span>
<span class="line-removed"> 965         return Unexpected&lt;Error&gt;(name.error());</span>
 966 
<a name="138" id="anc138"></a><span class="line-modified"> 967     auto typeArguments = parseTypeArguments();</span>
<span class="line-removed"> 968     if (!typeArguments)</span>
<span class="line-removed"> 969         return Unexpected&lt;Error&gt;(typeArguments.error());</span>
<span class="line-removed"> 970 </span>
<span class="line-removed"> 971     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed"> 972     if (!semicolon)</span>
<span class="line-removed"> 973         return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed"> 974 </span>
<span class="line-removed"> 975     return AST::NativeTypeDeclaration(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*typeArguments));</span>
 976 }
 977 
 978 auto Parser::parseNumThreadsFunctionAttribute() -&gt; Expected&lt;AST::NumThreadsFunctionAttribute, Error&gt;
 979 {
<a name="139" id="anc139"></a><span class="line-modified"> 980     auto origin = consumeType(Lexer::Token::Type::NumThreads);</span>
<span class="line-modified"> 981     if (!origin)</span>
<span class="line-removed"> 982         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed"> 983 </span>
<span class="line-removed"> 984     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed"> 985     if (!leftParenthesis)</span>
<span class="line-removed"> 986         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
 987 
 988     auto width = consumeNonNegativeIntegralLiteral();
 989     if (!width)
<a name="140" id="anc140"></a><span class="line-modified"> 990         return Unexpected&lt;Error&gt;(width.error());</span>
 991 
<a name="141" id="anc141"></a><span class="line-modified"> 992     auto comma = consumeType(Lexer::Token::Type::Comma);</span>
<span class="line-removed"> 993     if (!comma)</span>
<span class="line-removed"> 994         return Unexpected&lt;Error&gt;(comma.error());</span>
 995 
 996     auto height = consumeNonNegativeIntegralLiteral();
 997     if (!height)
<a name="142" id="anc142"></a><span class="line-modified"> 998         return Unexpected&lt;Error&gt;(height.error());</span>
 999 
<a name="143" id="anc143"></a><span class="line-modified">1000     comma = consumeType(Lexer::Token::Type::Comma);</span>
<span class="line-removed">1001     if (!comma)</span>
<span class="line-removed">1002         return Unexpected&lt;Error&gt;(comma.error());</span>
1003 
1004     auto depth = consumeNonNegativeIntegralLiteral();
1005     if (!depth)
<a name="144" id="anc144"></a><span class="line-modified">1006         return Unexpected&lt;Error&gt;(depth.error());</span>
1007 
<a name="145" id="anc145"></a><span class="line-modified">1008     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">1009     if (!rightParenthesis)</span>
<span class="line-removed">1010         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
1011 
<a name="146" id="anc146"></a><span class="line-modified">1012     return AST::NumThreadsFunctionAttribute(WTFMove(*origin), *width, *height, *depth);</span>
1013 }
1014 
1015 auto Parser::parseAttributeBlock() -&gt; Expected&lt;AST::AttributeBlock, Error&gt;
1016 {
<a name="147" id="anc147"></a><span class="line-modified">1017     auto leftSquareBracket = consumeType(Lexer::Token::Type::LeftSquareBracket);</span>
<span class="line-removed">1018     if (!leftSquareBracket)</span>
<span class="line-removed">1019         return Unexpected&lt;Error&gt;(leftSquareBracket.error());</span>
1020 
1021     AST::AttributeBlock result;
1022 
<a name="148" id="anc148"></a><span class="line-modified">1023     while (true) {</span>
<span class="line-modified">1024         auto numThreadsFunctionAttribute = backtrackingScope&lt;Expected&lt;AST::NumThreadsFunctionAttribute, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1025             return parseNumThreadsFunctionAttribute();</span>
<span class="line-removed">1026         });</span>
<span class="line-removed">1027         if (numThreadsFunctionAttribute) {</span>
<span class="line-removed">1028             result.append(WTFMove(*numThreadsFunctionAttribute));</span>
<span class="line-removed">1029             continue;</span>
<span class="line-removed">1030         }</span>
<span class="line-removed">1031 </span>
<span class="line-removed">1032         break;</span>
1033     }
1034 
<a name="149" id="anc149"></a><span class="line-removed">1035     auto rightSquareBracket = consumeType(Lexer::Token::Type::RightSquareBracket);</span>
<span class="line-removed">1036     if (!rightSquareBracket)</span>
<span class="line-removed">1037         return Unexpected&lt;Error&gt;(rightSquareBracket.error());</span>
<span class="line-removed">1038 </span>
1039     return WTFMove(result);
1040 }
1041 
1042 auto Parser::parseParameter() -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;
1043 {
<a name="150" id="anc150"></a><span class="line-modified">1044     auto origin = peek();</span>
<span class="line-removed">1045     if (!origin)</span>
<span class="line-removed">1046         return Unexpected&lt;Error&gt;(origin.error());</span>
1047 
1048     AST::Qualifiers qualifiers = parseQualifiers();
<a name="151" id="anc151"></a><span class="line-modified">1049 </span>
<span class="line-removed">1050     auto type = parseType();</span>
<span class="line-removed">1051     if (!type)</span>
<span class="line-removed">1052         return Unexpected&lt;Error&gt;(type.error());</span>
1053 
1054     String name;
<a name="152" id="anc152"></a><span class="line-modified">1055     if (auto token = tryType(Lexer::Token::Type::Identifier))</span>
<span class="line-modified">1056         name = token-&gt;stringView.toString();</span>
1057 
<a name="153" id="anc153"></a><span class="line-modified">1058     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-modified">1059         auto semantic = parseSemantic();</span>
<span class="line-modified">1060         if (!semantic)</span>
<span class="line-removed">1061             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">1062         return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt;(WTFMove(*type)), WTFMove(name), WTFMove(*semantic), WTF::nullopt);</span>
<span class="line-removed">1063     }</span>
1064 
<a name="154" id="anc154"></a><span class="line-modified">1065     return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(*type) }, WTFMove(name), WTF::nullopt, WTF::nullopt);</span>
1066 }
1067 
1068 auto Parser::parseParameters() -&gt; Expected&lt;AST::VariableDeclarations, Error&gt;
1069 {
<a name="155" id="anc155"></a><span class="line-removed">1070     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">1071     if (!leftParenthesis)</span>
<span class="line-removed">1072         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">1073 </span>
1074     AST::VariableDeclarations parameters;
<a name="156" id="anc156"></a><span class="line-modified">1075     if (tryType(Lexer::Token::Type::RightParenthesis))</span>



1076         return WTFMove(parameters);
1077 
<a name="157" id="anc157"></a><span class="line-modified">1078     auto firstParameter = parseParameter();</span>
<span class="line-modified">1079     if (!firstParameter)</span>
<span class="line-removed">1080         return Unexpected&lt;Error&gt;(firstParameter.error());</span>
<span class="line-removed">1081     parameters.append(WTFMove(*firstParameter));</span>
1082 
<a name="158" id="anc158"></a><span class="line-modified">1083     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified">1084         auto parameter = parseParameter();</span>
<span class="line-modified">1085         if (!parameter)</span>
<span class="line-removed">1086             return Unexpected&lt;Error&gt;(parameter.error());</span>
<span class="line-removed">1087         parameters.append(WTFMove(*parameter));</span>
1088     }
1089 
<a name="159" id="anc159"></a><span class="line-modified">1090     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">1091     if (!rightParenthesis)</span>
<span class="line-removed">1092         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
1093 
1094     return WTFMove(parameters);
1095 }
1096 
1097 auto Parser::parseFunctionDefinition() -&gt; Expected&lt;AST::FunctionDefinition, Error&gt;
1098 {
<a name="160" id="anc160"></a><span class="line-modified">1099     auto functionDeclaration = parseFunctionDeclaration();</span>
<span class="line-modified">1100     if (!functionDeclaration)</span>
<span class="line-removed">1101         return Unexpected&lt;Error&gt;(functionDeclaration.error());</span>
<span class="line-removed">1102 </span>
<span class="line-removed">1103     auto block = parseBlock();</span>
<span class="line-removed">1104     if (!block)</span>
<span class="line-removed">1105         return Unexpected&lt;Error&gt;(block.error());</span>
<span class="line-removed">1106 </span>
1107     return AST::FunctionDefinition(WTFMove(*functionDeclaration), WTFMove(*block));
1108 }
1109 
<a name="161" id="anc161"></a><span class="line-modified">1110 auto Parser::parseEntryPointFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;</span>
1111 {
<a name="162" id="anc162"></a><span class="line-modified">1112     auto origin = peek();</span>
<span class="line-removed">1113     if (!origin)</span>
<span class="line-removed">1114         return Unexpected&lt;Error&gt;(origin.error());</span>
1115 
<a name="163" id="anc163"></a><span class="line-modified">1116     AST::AttributeBlock attributeBlock;</span>
<span class="line-modified">1117     AST::EntryPointType entryPointType;</span>
<span class="line-modified">1118 </span>
<span class="line-modified">1119     auto parsedAttributeBlock = backtrackingScope&lt;Expected&lt;AST::AttributeBlock, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1120         return parseAttributeBlock();</span>
<span class="line-modified">1121     });</span>
<span class="line-removed">1122     if (parsedAttributeBlock) {</span>
<span class="line-removed">1123         auto compute = consumeType(Lexer::Token::Type::Compute);</span>
<span class="line-removed">1124         if (!compute)</span>
<span class="line-removed">1125             return Unexpected&lt;Error&gt;(compute.error());</span>
<span class="line-removed">1126         attributeBlock = WTFMove(*parsedAttributeBlock);</span>
<span class="line-removed">1127         entryPointType = AST::EntryPointType::Compute;</span>
<span class="line-removed">1128     } else {</span>
<span class="line-removed">1129         auto type = consumeTypes({ Lexer::Token::Type::Vertex, Lexer::Token::Type::Fragment });</span>
<span class="line-removed">1130         if (!type)</span>
<span class="line-removed">1131             return Unexpected&lt;Error&gt;(type.error());</span>
<span class="line-removed">1132 </span>
<span class="line-removed">1133         switch (origin-&gt;type) {</span>
<span class="line-removed">1134         case Lexer::Token::Type::Vertex:</span>
<span class="line-removed">1135             entryPointType = AST::EntryPointType::Vertex;</span>
<span class="line-removed">1136             break;</span>
<span class="line-removed">1137         default:</span>
<span class="line-removed">1138             ASSERT(origin-&gt;type == Lexer::Token::Type::Fragment);</span>
<span class="line-removed">1139             entryPointType = AST::EntryPointType::Fragment;</span>
<span class="line-removed">1140             break;</span>
<span class="line-removed">1141         }</span>
<span class="line-removed">1142     }</span>
1143 
<a name="164" id="anc164"></a><span class="line-modified">1144     auto type = parseType();</span>
<span class="line-removed">1145     if (!type)</span>
<span class="line-removed">1146         return Unexpected&lt;Error&gt;(type.error());</span>
1147 
<a name="165" id="anc165"></a><span class="line-modified">1148     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified">1149     if (!name)</span>
<span class="line-modified">1150         return Unexpected&lt;Error&gt;(name.error());</span>
1151 
<a name="166" id="anc166"></a><span class="line-modified">1152     auto parameters = parseParameters();</span>
<span class="line-modified">1153     if (!parameters)</span>
<span class="line-modified">1154         return Unexpected&lt;Error&gt;(parameters.error());</span>



1155 
<a name="167" id="anc167"></a><span class="line-modified">1156     bool isOperator = false;</span>



1157 
<a name="168" id="anc168"></a><span class="line-modified">1158     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed">1159         auto semantic = parseSemantic();</span>
<span class="line-removed">1160         if (!semantic)</span>
<span class="line-removed">1161             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">1162         return AST::FunctionDeclaration(WTFMove(*origin), WTFMove(attributeBlock), entryPointType, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator);</span>
<span class="line-removed">1163     }</span>
1164 
<a name="169" id="anc169"></a><span class="line-modified">1165     return AST::FunctionDeclaration(WTFMove(*origin), WTFMove(attributeBlock), entryPointType, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTF::nullopt, isOperator);</span>

1166 }
1167 
1168 auto Parser::parseRegularFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1169 {
<a name="170" id="anc170"></a><span class="line-modified">1170     auto origin = peek();</span>
<span class="line-removed">1171     if (!origin)</span>
<span class="line-removed">1172         return Unexpected&lt;Error&gt;(origin.error());</span>
1173 
<a name="171" id="anc171"></a><span class="line-modified">1174     auto type = parseType();</span>
<span class="line-removed">1175     if (!type)</span>
<span class="line-removed">1176         return Unexpected&lt;Error&gt;(type.error());</span>
1177 
<a name="172" id="anc172"></a><span class="line-modified">1178     auto name = consumeTypes({ Lexer::Token::Type::Identifier, Lexer::Token::Type::OperatorName });</span>
1179     if (!name)
<a name="173" id="anc173"></a><span class="line-modified">1180         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-modified">1181     auto isOperator = name-&gt;type == Lexer::Token::Type::OperatorName;</span>
1182 
<a name="174" id="anc174"></a><span class="line-modified">1183     auto parameters = parseParameters();</span>
<span class="line-modified">1184     if (!parameters)</span>
<span class="line-removed">1185         return Unexpected&lt;Error&gt;(parameters.error());</span>
1186 
<a name="175" id="anc175"></a><span class="line-modified">1187     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed">1188         auto semantic = parseSemantic();</span>
<span class="line-removed">1189         if (!semantic)</span>
<span class="line-removed">1190             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">1191         return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator);</span>
<span class="line-removed">1192     }</span>
1193 
<a name="176" id="anc176"></a><span class="line-modified">1194     return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTF::nullopt, isOperator);</span>
1195 }
1196 
1197 auto Parser::parseOperatorFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1198 {
<a name="177" id="anc177"></a><span class="line-modified">1199     auto origin = consumeType(Lexer::Token::Type::Operator);</span>
<span class="line-modified">1200     if (!origin)</span>
<span class="line-modified">1201         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">1202 </span>
<span class="line-removed">1203     auto type = parseType();</span>
<span class="line-removed">1204     if (!type)</span>
<span class="line-removed">1205         return Unexpected&lt;Error&gt;(type.error());</span>
1206 
<a name="178" id="anc178"></a><span class="line-modified">1207     auto parameters = parseParameters();</span>
<span class="line-removed">1208     if (!parameters)</span>
<span class="line-removed">1209         return Unexpected&lt;Error&gt;(parameters.error());</span>
1210 
1211     bool isOperator = true;
<a name="179" id="anc179"></a><span class="line-modified">1212 </span>
<span class="line-removed">1213     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed">1214         auto semantic = parseSemantic();</span>
<span class="line-removed">1215         if (!semantic)</span>
<span class="line-removed">1216             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">1217         return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), &quot;operator cast&quot;_str, WTFMove(*parameters), WTFMove(*semantic), isOperator);</span>
<span class="line-removed">1218     }</span>
<span class="line-removed">1219 </span>
<span class="line-removed">1220     return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), &quot;operator cast&quot;_str, WTFMove(*parameters), WTF::nullopt, isOperator);</span>
1221 }
1222 
1223 auto Parser::parseFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1224 {
<a name="180" id="anc180"></a><span class="line-modified">1225     auto entryPointFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::FunctionDeclaration, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1226         return parseEntryPointFunctionDeclaration();</span>
<span class="line-modified">1227     });</span>
<span class="line-removed">1228     if (entryPointFunctionDeclaration)</span>
<span class="line-removed">1229         return WTFMove(*entryPointFunctionDeclaration);</span>
<span class="line-removed">1230 </span>
<span class="line-removed">1231     auto regularFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::FunctionDeclaration, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">1232         return parseRegularFunctionDeclaration();</span>
<span class="line-removed">1233     });</span>
<span class="line-removed">1234     if (regularFunctionDeclaration)</span>
<span class="line-removed">1235         return WTFMove(*regularFunctionDeclaration);</span>
<span class="line-removed">1236 </span>
<span class="line-removed">1237     auto operatorFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::FunctionDeclaration, Error&gt;&gt;([&amp;]() {</span>
1238         return parseOperatorFunctionDeclaration();
<a name="181" id="anc181"></a><span class="line-modified">1239     });</span>
<span class="line-modified">1240     if (operatorFunctionDeclaration)</span>
<span class="line-modified">1241         return WTFMove(*operatorFunctionDeclaration);</span>
<span class="line-modified">1242 </span>
<span class="line-modified">1243     return Unexpected&lt;Error&gt;(operatorFunctionDeclaration.error());</span>



1244 }
1245 
1246 auto Parser::parseNativeFunctionDeclaration() -&gt; Expected&lt;AST::NativeFunctionDeclaration, Error&gt;
1247 {
<a name="182" id="anc182"></a><span class="line-modified">1248     Optional&lt;Lexer::Token&gt; origin;</span>
<span class="line-modified">1249 </span>
<span class="line-modified">1250     auto native = consumeType(Lexer::Token::Type::Native);</span>
<span class="line-removed">1251     if (!native)</span>
<span class="line-removed">1252         return Unexpected&lt;Error&gt;(native.error());</span>
<span class="line-removed">1253     if (!origin)</span>
<span class="line-removed">1254         origin = *native;</span>
<span class="line-removed">1255 </span>
<span class="line-removed">1256     auto functionDeclaration = parseFunctionDeclaration();</span>
<span class="line-removed">1257     if (!functionDeclaration)</span>
<span class="line-removed">1258         return Unexpected&lt;Error&gt;(functionDeclaration.error());</span>
<span class="line-removed">1259 </span>
<span class="line-removed">1260     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1261     if (!semicolon)</span>
<span class="line-removed">1262         return Unexpected&lt;Error&gt;(semicolon.error());</span>
1263 
1264     return AST::NativeFunctionDeclaration(WTFMove(*functionDeclaration));
1265 }
1266 
1267 auto Parser::parseBlock() -&gt; Expected&lt;AST::Block, Error&gt;
1268 {
<a name="183" id="anc183"></a><span class="line-modified">1269     auto origin = consumeType(Lexer::Token::Type::LeftCurlyBracket);</span>
<span class="line-modified">1270     if (!origin)</span>
<span class="line-modified">1271         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">1272 </span>
<span class="line-modified">1273     auto result = parseBlockBody(WTFMove(*origin));</span>
<span class="line-removed">1274 </span>
<span class="line-removed">1275     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);</span>
<span class="line-removed">1276     if (!rightCurlyBracket)</span>
<span class="line-removed">1277         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());</span>
<span class="line-removed">1278 </span>
<span class="line-removed">1279     return WTFMove(result);</span>
1280 }
1281 
<a name="184" id="anc184"></a><span class="line-modified">1282 AST::Block Parser::parseBlockBody(Lexer::Token&amp;&amp; origin)</span>
1283 {
<a name="185" id="anc185"></a>

1284     AST::Statements statements;
<a name="186" id="anc186"></a><span class="line-modified">1285     while (true) {</span>
<span class="line-modified">1286         auto statement = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1287             return parseStatement();</span>
<span class="line-removed">1288         });</span>
<span class="line-removed">1289         if (statement)</span>
<span class="line-removed">1290             statements.append(WTFMove(*statement));</span>
<span class="line-removed">1291         else</span>
<span class="line-removed">1292             break;</span>
1293     }
<a name="187" id="anc187"></a><span class="line-modified">1294     return AST::Block(WTFMove(origin), WTFMove(statements));</span>



1295 }
1296 
1297 auto Parser::parseIfStatement() -&gt; Expected&lt;AST::IfStatement, Error&gt;
1298 {
<a name="188" id="anc188"></a><span class="line-modified">1299     auto origin = consumeType(Lexer::Token::Type::If);</span>
<span class="line-modified">1300     if (!origin)</span>
<span class="line-modified">1301         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">1302 </span>
<span class="line-modified">1303     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">1304     if (!leftParenthesis)</span>
<span class="line-removed">1305         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">1306 </span>
<span class="line-removed">1307     auto conditional = parseExpression();</span>
<span class="line-removed">1308     if (!conditional)</span>
<span class="line-removed">1309         return Unexpected&lt;Error&gt;(conditional.error());</span>
<span class="line-removed">1310 </span>
<span class="line-removed">1311     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">1312     if (!rightParenthesis)</span>
<span class="line-removed">1313         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
<span class="line-removed">1314 </span>
<span class="line-removed">1315     auto body = parseStatement();</span>
<span class="line-removed">1316     if (!body)</span>
<span class="line-removed">1317         return Unexpected&lt;Error&gt;(body.error());</span>
1318 
<a name="189" id="anc189"></a><span class="line-modified">1319     Optional&lt;UniqueRef&lt;AST::Statement&gt;&gt; elseBody;</span>
<span class="line-modified">1320     if (tryType(Lexer::Token::Type::Else)) {</span>
<span class="line-modified">1321         auto parsedElseBody = parseStatement();</span>
<span class="line-modified">1322         if (!parsedElseBody)</span>
<span class="line-removed">1323             return Unexpected&lt;Error&gt;(parsedElseBody.error());</span>
<span class="line-removed">1324         elseBody = WTFMove(*parsedElseBody);</span>
1325     }
1326 
<a name="190" id="anc190"></a>

1327     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
1328     castArguments.append(WTFMove(*conditional));
<a name="191" id="anc191"></a><span class="line-modified">1329     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*origin), &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">1330     return AST::IfStatement(WTFMove(*origin), WTFMove(boolCast), WTFMove(*body), WTFMove(elseBody));</span>
1331 }
1332 
1333 auto Parser::parseSwitchStatement() -&gt; Expected&lt;AST::SwitchStatement, Error&gt;
1334 {
<a name="192" id="anc192"></a><span class="line-modified">1335     auto origin = consumeType(Lexer::Token::Type::Switch);</span>
<span class="line-modified">1336     if (!origin)</span>
<span class="line-modified">1337         return Unexpected&lt;Error&gt;(origin.error());</span>


1338 
<a name="193" id="anc193"></a><span class="line-modified">1339     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-modified">1340     if (!leftParenthesis)</span>
<span class="line-modified">1341         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>





1342 
<a name="194" id="anc194"></a><span class="line-modified">1343     auto value = parseExpression();</span>
<span class="line-removed">1344     if (!value)</span>
<span class="line-removed">1345         return Unexpected&lt;Error&gt;(value.error());</span>
1346 
<a name="195" id="anc195"></a><span class="line-modified">1347     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-modified">1348     if (!rightParenthesis)</span>
<span class="line-removed">1349         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
1350 
<a name="196" id="anc196"></a><span class="line-modified">1351     auto leftCurlyBracket = consumeType(Lexer::Token::Type::LeftCurlyBracket);</span>
<span class="line-modified">1352     if (!leftCurlyBracket)</span>
<span class="line-modified">1353         return Unexpected&lt;Error&gt;(leftCurlyBracket.error());</span>
<span class="line-modified">1354 </span>
<span class="line-modified">1355     Vector&lt;AST::SwitchCase&gt; switchCases;</span>
<span class="line-removed">1356     while (true) {</span>
<span class="line-removed">1357         auto switchCase = backtrackingScope&lt;Expected&lt;AST::SwitchCase, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">1358             return parseSwitchCase();</span>
<span class="line-removed">1359         });</span>
<span class="line-removed">1360         if (switchCase)</span>
<span class="line-removed">1361             switchCases.append(WTFMove(*switchCase));</span>
<span class="line-removed">1362         else</span>
<span class="line-removed">1363             break;</span>
<span class="line-removed">1364     }</span>
<span class="line-removed">1365 </span>
<span class="line-removed">1366     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);</span>
<span class="line-removed">1367     if (!rightCurlyBracket)</span>
<span class="line-removed">1368         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());</span>
<span class="line-removed">1369 </span>
<span class="line-removed">1370     return AST::SwitchStatement(WTFMove(*origin), WTFMove(*value), WTFMove(switchCases));</span>
<span class="line-removed">1371 }</span>
<span class="line-removed">1372 </span>
<span class="line-removed">1373 auto Parser::parseSwitchCase() -&gt; Expected&lt;AST::SwitchCase, Error&gt;</span>
<span class="line-removed">1374 {</span>
<span class="line-removed">1375     auto origin = consumeTypes({ Lexer::Token::Type::Case, Lexer::Token::Type::Default });</span>
<span class="line-removed">1376     if (!origin)</span>
<span class="line-removed">1377         return Unexpected&lt;Error&gt;(origin.error());</span>
1378 
1379     switch (origin-&gt;type) {
<a name="197" id="anc197"></a><span class="line-modified">1380     case Lexer::Token::Type::Case: {</span>
<span class="line-modified">1381         auto value = parseConstantExpression();</span>
<span class="line-modified">1382         if (!value)</span>
<span class="line-removed">1383             return Unexpected&lt;Error&gt;(value.error());</span>
1384 
<a name="198" id="anc198"></a><span class="line-modified">1385         auto origin = consumeType(Lexer::Token::Type::Colon);</span>
<span class="line-removed">1386         if (!origin)</span>
<span class="line-removed">1387             return Unexpected&lt;Error&gt;(origin.error());</span>
1388 
<a name="199" id="anc199"></a><span class="line-modified">1389         auto block = parseBlockBody(Lexer::Token(*origin));</span>
<span class="line-removed">1390 </span>
<span class="line-removed">1391         return AST::SwitchCase(WTFMove(*origin), WTFMove(*value), WTFMove(block));</span>
1392     }
1393     default: {
<a name="200" id="anc200"></a><span class="line-modified">1394         ASSERT(origin-&gt;type == Lexer::Token::Type::Default);</span>
<span class="line-modified">1395         auto origin = consumeType(Lexer::Token::Type::Colon);</span>
<span class="line-removed">1396         if (!origin)</span>
<span class="line-removed">1397             return Unexpected&lt;Error&gt;(origin.error());</span>
1398 
<a name="201" id="anc201"></a><span class="line-modified">1399         auto block = parseBlockBody(Lexer::Token(*origin));</span>
1400 
<a name="202" id="anc202"></a><span class="line-modified">1401         return AST::SwitchCase(WTFMove(*origin), WTF::nullopt, WTFMove(block));</span>
1402     }
1403     }
1404 }
1405 
1406 auto Parser::parseForLoop() -&gt; Expected&lt;AST::ForLoop, Error&gt;
1407 {
<a name="203" id="anc203"></a><span class="line-modified">1408     auto origin = consumeType(Lexer::Token::Type::For);</span>
<span class="line-modified">1409     if (!origin)</span>
<span class="line-removed">1410         return Unexpected&lt;Error&gt;(origin.error());</span>
1411 
<a name="204" id="anc204"></a><span class="line-modified">1412     auto parseRemainder = [&amp;](Variant&lt;AST::VariableDeclarationsStatement, UniqueRef&lt;AST::Expression&gt;&gt;&amp;&amp; initialization) -&gt; Expected&lt;AST::ForLoop, Error&gt; {</span>
<span class="line-modified">1413         auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1414         if (!semicolon)</span>
<span class="line-removed">1415             return Unexpected&lt;Error&gt;(semicolon.error());</span>
1416 
<a name="205" id="anc205"></a><span class="line-modified">1417         auto condition = backtrackingScope&lt;Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt;&gt;([&amp;]() -&gt; Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt; {</span>

1418             if (auto expression = parseExpression())
<a name="206" id="anc206"></a><span class="line-modified">1419                 return { WTFMove(*expression) };</span>
<span class="line-modified">1420             return WTF::nullopt;</span>
<span class="line-modified">1421         });</span>
<span class="line-modified">1422 </span>
<span class="line-modified">1423         semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1424         if (!semicolon)</span>
<span class="line-removed">1425             return Unexpected&lt;Error&gt;(semicolon.error());</span>
1426 
<a name="207" id="anc207"></a><span class="line-modified">1427         auto increment = backtrackingScope&lt;Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt;&gt;([&amp;]() -&gt; Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt; {</span>

1428             if (auto expression = parseExpression())
<a name="208" id="anc208"></a><span class="line-modified">1429                 return { WTFMove(*expression) };</span>
<span class="line-modified">1430             return WTF::nullopt;</span>
<span class="line-modified">1431         });</span>
<span class="line-modified">1432 </span>
<span class="line-modified">1433         auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">1434         if (!rightParenthesis)</span>
<span class="line-removed">1435             return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
<span class="line-removed">1436 </span>
<span class="line-removed">1437         auto body = parseStatement();</span>
<span class="line-removed">1438         if (!body)</span>
<span class="line-removed">1439             return Unexpected&lt;Error&gt;(body.error());</span>
1440 
<a name="209" id="anc209"></a><span class="line-modified">1441         return AST::ForLoop(WTFMove(*origin), WTFMove(initialization), WTFMove(condition), WTFMove(increment), WTFMove(*body));</span>


1442     };
1443 
<a name="210" id="anc210"></a><span class="line-removed">1444     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">1445     if (!leftParenthesis)</span>
<span class="line-removed">1446         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">1447 </span>
1448     auto variableDeclarations = backtrackingScope&lt;Expected&lt;AST::VariableDeclarationsStatement, Error&gt;&gt;([&amp;]() {
1449         return parseVariableDeclarations();
1450     });
<a name="211" id="anc211"></a><span class="line-modified">1451     if (variableDeclarations)</span>
<span class="line-modified">1452         return parseRemainder(WTFMove(*variableDeclarations));</span>


1453 
<a name="212" id="anc212"></a><span class="line-modified">1454     auto effectfulExpression = parseEffectfulExpression();</span>
<span class="line-removed">1455     if (!effectfulExpression)</span>
<span class="line-removed">1456         return Unexpected&lt;Error&gt;(effectfulExpression.error());</span>
1457 
1458     return parseRemainder(WTFMove(*effectfulExpression));
1459 }
1460 
1461 auto Parser::parseWhileLoop() -&gt; Expected&lt;AST::WhileLoop, Error&gt;
1462 {
<a name="213" id="anc213"></a><span class="line-modified">1463     auto origin = consumeType(Lexer::Token::Type::While);</span>
<span class="line-modified">1464     if (!origin)</span>
<span class="line-modified">1465         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">1466 </span>
<span class="line-modified">1467     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">1468     if (!leftParenthesis)</span>
<span class="line-removed">1469         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">1470 </span>
<span class="line-removed">1471     auto conditional = parseExpression();</span>
<span class="line-removed">1472     if (!conditional)</span>
<span class="line-removed">1473         return Unexpected&lt;Error&gt;(conditional.error());</span>
<span class="line-removed">1474 </span>
<span class="line-removed">1475     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">1476     if (!rightParenthesis)</span>
<span class="line-removed">1477         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
1478 
<a name="214" id="anc214"></a><span class="line-modified">1479     auto body = parseStatement();</span>
<span class="line-modified">1480     if (!body)</span>
<span class="line-removed">1481         return Unexpected&lt;Error&gt;(body.error());</span>
<span class="line-removed">1482 </span>
<span class="line-removed">1483     return AST::WhileLoop(WTFMove(*origin), WTFMove(*conditional), WTFMove(*body));</span>
1484 }
1485 
1486 auto Parser::parseDoWhileLoop() -&gt; Expected&lt;AST::DoWhileLoop, Error&gt;
1487 {
<a name="215" id="anc215"></a><span class="line-modified">1488     auto origin = consumeType(Lexer::Token::Type::Do);</span>
<span class="line-modified">1489     if (!origin)</span>
<span class="line-modified">1490         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">1491 </span>
<span class="line-modified">1492     auto body = parseStatement();</span>
<span class="line-modified">1493     if (!body)</span>
<span class="line-modified">1494         return Unexpected&lt;Error&gt;(body.error());</span>
<span class="line-removed">1495 </span>
<span class="line-removed">1496     auto whileKeyword = consumeType(Lexer::Token::Type::While);</span>
<span class="line-removed">1497     if (!whileKeyword)</span>
<span class="line-removed">1498         return Unexpected&lt;Error&gt;(whileKeyword.error());</span>
1499 
<a name="216" id="anc216"></a><span class="line-modified">1500     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">1501     if (!leftParenthesis)</span>
<span class="line-removed">1502         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">1503 </span>
<span class="line-removed">1504     auto conditional = parseExpression();</span>
<span class="line-removed">1505     if (!conditional)</span>
<span class="line-removed">1506         return Unexpected&lt;Error&gt;(conditional.error());</span>
<span class="line-removed">1507 </span>
<span class="line-removed">1508     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">1509     if (!rightParenthesis)</span>
<span class="line-removed">1510         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
<span class="line-removed">1511 </span>
<span class="line-removed">1512     return AST::DoWhileLoop(WTFMove(*origin), WTFMove(*body), WTFMove(*conditional));</span>
1513 }
1514 
<a name="217" id="anc217"></a><span class="line-modified">1515 auto Parser::parseVariableDeclaration(UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; type) -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;</span>
1516 {
<a name="218" id="anc218"></a><span class="line-modified">1517     auto origin = peek();</span>
<span class="line-removed">1518     if (!origin)</span>
<span class="line-removed">1519         return Unexpected&lt;Error&gt;(origin.error());</span>
1520 
1521     auto qualifiers = parseQualifiers();
1522 
<a name="219" id="anc219"></a><span class="line-modified">1523     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified">1524     if (!name)</span>
<span class="line-removed">1525         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed">1526 </span>
<span class="line-removed">1527     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed">1528         auto semantic = parseSemantic();</span>
<span class="line-removed">1529         if (!semantic)</span>
<span class="line-removed">1530             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">1531 </span>
<span class="line-removed">1532         if (tryType(Lexer::Token::Type::EqualsSign)) {</span>
<span class="line-removed">1533             auto initializer = parseExpression();</span>
<span class="line-removed">1534             if (!initializer)</span>
<span class="line-removed">1535                 return Unexpected&lt;Error&gt;(initializer.error());</span>
<span class="line-removed">1536             return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTFMove(*semantic), WTFMove(*initializer));</span>
<span class="line-removed">1537         }</span>
<span class="line-removed">1538 </span>
<span class="line-removed">1539         return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTFMove(*semantic), WTF::nullopt);</span>
<span class="line-removed">1540     }</span>
1541 
<a name="220" id="anc220"></a><span class="line-modified">1542     if (tryType(Lexer::Token::Type::EqualsSign)) {</span>
<span class="line-modified">1543         auto initializer = parseExpression();</span>
<span class="line-modified">1544         if (!initializer)</span>
<span class="line-modified">1545             return Unexpected&lt;Error&gt;(initializer.error());</span>
<span class="line-removed">1546         return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTF::nullopt, WTFMove(*initializer));</span>
1547     }
1548 
<a name="221" id="anc221"></a><span class="line-modified">1549     return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTF::nullopt, WTF::nullopt);</span>

1550 }
1551 
1552 auto Parser::parseVariableDeclarations() -&gt; Expected&lt;AST::VariableDeclarationsStatement, Error&gt;
1553 {
<a name="222" id="anc222"></a><span class="line-modified">1554     auto origin = peek();</span>
<span class="line-removed">1555     if (!origin)</span>
<span class="line-removed">1556         return Unexpected&lt;Error&gt;(origin.error());</span>
1557 
<a name="223" id="anc223"></a><span class="line-modified">1558     auto type = parseType();</span>
<span class="line-removed">1559     if (!type)</span>
<span class="line-removed">1560         return Unexpected&lt;Error&gt;(type.error());</span>
1561 
<a name="224" id="anc224"></a><span class="line-modified">1562     auto firstVariableDeclaration = parseVariableDeclaration((*type)-&gt;clone());</span>
1563     if (!firstVariableDeclaration)
<a name="225" id="anc225"></a><span class="line-modified">1564         return Unexpected&lt;Error&gt;(firstVariableDeclaration.error());</span>
1565 
<a name="226" id="anc226"></a><span class="line-modified">1566     Vector&lt;AST::VariableDeclaration&gt; result;</span>
<span class="line-modified">1567     result.append(WTFMove(*firstVariableDeclaration));</span>
1568 
<a name="227" id="anc227"></a><span class="line-modified">1569     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified">1570         auto variableDeclaration = parseVariableDeclaration((*type)-&gt;clone());</span>
1571         if (!variableDeclaration)
<a name="228" id="anc228"></a><span class="line-modified">1572             return Unexpected&lt;Error&gt;(variableDeclaration.error());</span>
<span class="line-modified">1573         result.append(WTFMove(*variableDeclaration));</span>
1574     }
1575 
<a name="229" id="anc229"></a><span class="line-modified">1576     return AST::VariableDeclarationsStatement(WTFMove(*origin), WTFMove(result));</span>

1577 }
1578 
1579 auto Parser::parseStatement() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;
1580 {
<a name="230" id="anc230"></a><span class="line-modified">1581     {</span>
<span class="line-modified">1582         auto block = backtrackingScope&lt;Expected&lt;AST::Block, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1583             return parseBlock();</span>
<span class="line-modified">1584         });</span>
<span class="line-modified">1585         if (block)</span>
<span class="line-modified">1586             return { makeUniqueRef&lt;AST::Block&gt;(WTFMove(*block)) };</span>
<span class="line-modified">1587     }</span>
<span class="line-modified">1588 </span>
<span class="line-modified">1589     {</span>
<span class="line-modified">1590         auto ifStatement = backtrackingScope&lt;Expected&lt;AST::IfStatement, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1591             return parseIfStatement();</span>
<span class="line-modified">1592         });</span>
<span class="line-modified">1593         if (ifStatement)</span>
<span class="line-modified">1594             return { makeUniqueRef&lt;AST::IfStatement&gt;(WTFMove(*ifStatement)) };</span>
<span class="line-modified">1595     }</span>
<span class="line-modified">1596 </span>
<span class="line-modified">1597     {</span>
<span class="line-modified">1598         auto switchStatement = backtrackingScope&lt;Expected&lt;AST::SwitchStatement, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1599             return parseSwitchStatement();</span>
<span class="line-modified">1600         });</span>
<span class="line-modified">1601         if (switchStatement)</span>
<span class="line-modified">1602             return { makeUniqueRef&lt;AST::SwitchStatement&gt;(WTFMove(*switchStatement)) };</span>
<span class="line-modified">1603     }</span>
<span class="line-modified">1604 </span>
<span class="line-modified">1605     {</span>
<span class="line-modified">1606         auto forLoop = backtrackingScope&lt;Expected&lt;AST::ForLoop, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1607             return parseForLoop();</span>
<span class="line-modified">1608         });</span>
<span class="line-modified">1609         if (forLoop)</span>
<span class="line-modified">1610             return { makeUniqueRef&lt;AST::ForLoop&gt;(WTFMove(*forLoop)) };</span>
<span class="line-modified">1611     }</span>
<span class="line-modified">1612 </span>
<span class="line-modified">1613     {</span>
<span class="line-modified">1614         auto whileLoop = backtrackingScope&lt;Expected&lt;AST::WhileLoop, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1615             return parseWhileLoop();</span>
<span class="line-modified">1616         });</span>
<span class="line-modified">1617         if (whileLoop)</span>
<span class="line-modified">1618             return { makeUniqueRef&lt;AST::WhileLoop&gt;(WTFMove(*whileLoop)) };</span>
<span class="line-modified">1619     }</span>
<span class="line-modified">1620 </span>
<span class="line-modified">1621     {</span>
<span class="line-modified">1622         auto doWhileLoop = backtrackingScope&lt;Expected&lt;AST::DoWhileLoop, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::DoWhileLoop, Error&gt; {</span>
<span class="line-modified">1623             auto result = parseDoWhileLoop();</span>
<span class="line-modified">1624             if (!result)</span>
<span class="line-modified">1625                 return Unexpected&lt;Error&gt;(result.error());</span>
<span class="line-modified">1626 </span>
<span class="line-modified">1627             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-modified">1628             if (!semicolon)</span>
<span class="line-modified">1629                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-modified">1630 </span>
<span class="line-modified">1631             return result;</span>
<span class="line-modified">1632         });</span>
<span class="line-modified">1633         if (doWhileLoop)</span>
<span class="line-modified">1634             return { makeUniqueRef&lt;AST::DoWhileLoop&gt;(WTFMove(*doWhileLoop)) };</span>
<span class="line-modified">1635     }</span>
<span class="line-modified">1636 </span>
<span class="line-modified">1637     {</span>
<span class="line-modified">1638         auto breakObject = backtrackingScope&lt;Expected&lt;AST::Break, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Break, Error&gt; {</span>
<span class="line-modified">1639             auto origin = consumeType(Lexer::Token::Type::Break);</span>
<span class="line-modified">1640             if (!origin)</span>
<span class="line-modified">1641                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">1642 </span>
<span class="line-modified">1643             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-modified">1644             if (!semicolon)</span>
<span class="line-modified">1645                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-modified">1646 </span>
<span class="line-modified">1647             return AST::Break(WTFMove(*origin));</span>
<span class="line-modified">1648         });</span>
<span class="line-modified">1649         if (breakObject)</span>
<span class="line-modified">1650             return { makeUniqueRef&lt;AST::Break&gt;(WTFMove(*breakObject)) };</span>
<span class="line-modified">1651     }</span>
<span class="line-modified">1652 </span>
<span class="line-modified">1653     {</span>
<span class="line-modified">1654         auto continueObject = backtrackingScope&lt;Expected&lt;AST::Continue, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Continue, Error&gt; {</span>
<span class="line-modified">1655             auto origin = consumeType(Lexer::Token::Type::Continue);</span>
<span class="line-modified">1656             if (!origin)</span>
<span class="line-modified">1657                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">1658 </span>
<span class="line-removed">1659             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1660             if (!semicolon)</span>
<span class="line-removed">1661                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">1662 </span>
<span class="line-removed">1663             return AST::Continue(WTFMove(*origin));</span>
<span class="line-removed">1664         });</span>
<span class="line-removed">1665         if (continueObject)</span>
<span class="line-removed">1666             return { makeUniqueRef&lt;AST::Continue&gt;(WTFMove(*continueObject)) };</span>
<span class="line-removed">1667     }</span>
<span class="line-removed">1668 </span>
<span class="line-removed">1669     {</span>
<span class="line-removed">1670         auto fallthroughObject = backtrackingScope&lt;Expected&lt;AST::Fallthrough, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Fallthrough, Error&gt; {</span>
<span class="line-removed">1671             auto origin = consumeType(Lexer::Token::Type::Fallthrough);</span>
<span class="line-removed">1672             if (!origin)</span>
<span class="line-removed">1673                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">1674 </span>
<span class="line-removed">1675             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1676             if (!semicolon)</span>
<span class="line-removed">1677                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">1678 </span>
<span class="line-removed">1679             return AST::Fallthrough(WTFMove(*origin));</span>
<span class="line-removed">1680         });</span>
<span class="line-removed">1681         if (fallthroughObject)</span>
<span class="line-removed">1682             return { makeUniqueRef&lt;AST::Fallthrough&gt;(WTFMove(*fallthroughObject)) };</span>
<span class="line-removed">1683     }</span>
<span class="line-removed">1684 </span>
<span class="line-removed">1685     {</span>
<span class="line-removed">1686         auto trapObject = backtrackingScope&lt;Expected&lt;AST::Trap, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Trap, Error&gt; {</span>
<span class="line-removed">1687             auto origin = consumeType(Lexer::Token::Type::Trap);</span>
<span class="line-removed">1688             if (!origin)</span>
<span class="line-removed">1689                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">1690 </span>
<span class="line-removed">1691             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1692             if (!semicolon)</span>
<span class="line-removed">1693                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">1694 </span>
<span class="line-removed">1695             return AST::Trap(WTFMove(*origin));</span>
<span class="line-removed">1696         });</span>
<span class="line-removed">1697         if (trapObject)</span>
<span class="line-removed">1698             return { makeUniqueRef&lt;AST::Trap&gt;(WTFMove(*trapObject)) };</span>
1699     }
<a name="231" id="anc231"></a><span class="line-modified">1700 </span>
<span class="line-modified">1701     {</span>
<span class="line-removed">1702         auto returnObject = backtrackingScope&lt;Expected&lt;AST::Return, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Return, Error&gt; {</span>
<span class="line-removed">1703             auto origin = consumeType(Lexer::Token::Type::Return);</span>
<span class="line-removed">1704             if (!origin)</span>
<span class="line-removed">1705                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">1706 </span>
<span class="line-removed">1707             if (auto semicolon = tryType(Lexer::Token::Type::Semicolon))</span>
<span class="line-removed">1708                 return AST::Return(WTFMove(*origin), WTF::nullopt);</span>
<span class="line-removed">1709 </span>
<span class="line-removed">1710             auto expression = parseExpression();</span>
<span class="line-removed">1711             if (!expression)</span>
<span class="line-removed">1712                 return Unexpected&lt;Error&gt;(expression.error());</span>
<span class="line-removed">1713 </span>
<span class="line-removed">1714             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1715             if (!semicolon)</span>
<span class="line-removed">1716                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">1717 </span>
<span class="line-removed">1718             return AST::Return(WTFMove(*origin), { WTFMove(*expression) });</span>
<span class="line-removed">1719         });</span>
<span class="line-removed">1720         if (returnObject)</span>
<span class="line-removed">1721             return { makeUniqueRef&lt;AST::Return&gt;(WTFMove(*returnObject)) };</span>
1722     }
1723 
1724     {
<a name="232" id="anc232"></a><span class="line-modified">1725         auto variableDeclarations = backtrackingScope&lt;Expected&lt;AST::VariableDeclarationsStatement, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::VariableDeclarationsStatement, Error&gt; {</span>
<span class="line-modified">1726             auto result = parseVariableDeclarations();</span>
<span class="line-modified">1727             if (!result)</span>
<span class="line-removed">1728                 return Unexpected&lt;Error&gt;(result.error());</span>
<span class="line-removed">1729 </span>
<span class="line-removed">1730             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1731             if (!semicolon)</span>
<span class="line-removed">1732                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">1733 </span>
1734             return result;
1735         });
<a name="233" id="anc233"></a><span class="line-modified">1736         if (variableDeclarations)</span>
<span class="line-modified">1737             return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };</span>
1738     }
1739 
<a name="234" id="anc234"></a><span class="line-modified">1740     auto effectfulExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-modified">1741         auto result = parseEffectfulExpression();</span>
<span class="line-modified">1742         if (!result)</span>
<span class="line-removed">1743             return Unexpected&lt;Error&gt;(result.error());</span>
<span class="line-removed">1744 </span>
<span class="line-removed">1745         auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">1746         if (!semicolon)</span>
<span class="line-removed">1747             return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">1748 </span>
<span class="line-removed">1749         return result;</span>
<span class="line-removed">1750     });</span>
<span class="line-removed">1751     if (effectfulExpression)</span>
<span class="line-removed">1752         return { makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(WTFMove(*effectfulExpression)) };</span>
<span class="line-removed">1753 </span>
<span class="line-removed">1754     return Unexpected&lt;Error&gt;(effectfulExpression.error());</span>
1755 }
1756 
<a name="235" id="anc235"></a><span class="line-modified">1757 auto Parser::parseEffectfulExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
1758 {
<a name="236" id="anc236"></a><span class="line-modified">1759     auto origin = peek();</span>
<span class="line-modified">1760     if (!origin)</span>
<span class="line-modified">1761         return Unexpected&lt;Error&gt;(origin.error());</span>
1762 
1763     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
<a name="237" id="anc237"></a>

1764 
<a name="238" id="anc238"></a><span class="line-modified">1765     auto first = backtrackingScope&lt;Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt;&gt;([&amp;]() -&gt; Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt; {</span>
<span class="line-modified">1766         auto effectfulExpression = parseEffectfulAssignment();</span>
<span class="line-removed">1767         if (!effectfulExpression)</span>
<span class="line-removed">1768             return WTF::nullopt;</span>
<span class="line-removed">1769         return { WTFMove(*effectfulExpression) };</span>
<span class="line-removed">1770     });</span>
<span class="line-removed">1771     if (!first)</span>
<span class="line-removed">1772         return { makeUniqueRef&lt;AST::CommaExpression&gt;(WTFMove(*origin), WTFMove(expressions)) };</span>
<span class="line-removed">1773 </span>
<span class="line-removed">1774     expressions.append(WTFMove(*first));</span>
<span class="line-removed">1775 </span>
<span class="line-removed">1776     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-removed">1777         auto expression = parseEffectfulAssignment();</span>
<span class="line-removed">1778         if (!expression)</span>
<span class="line-removed">1779             return Unexpected&lt;Error&gt;(expression.error());</span>
1780         expressions.append(WTFMove(*expression));
1781     }
1782 
1783     if (expressions.size() == 1)
<a name="239" id="anc239"></a><span class="line-modified">1784         return WTFMove(expressions[0]);</span>
<span class="line-modified">1785     return { makeUniqueRef&lt;AST::CommaExpression&gt;(WTFMove(*origin), WTFMove(expressions)) };</span>



1786 }
1787 
1788 auto Parser::parseEffectfulAssignment() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1789 {
<a name="240" id="anc240"></a><span class="line-modified">1790     auto assignment = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">1791         return parseAssignment();</span>
<span class="line-removed">1792     });</span>
<span class="line-removed">1793     if (assignment)</span>
<span class="line-removed">1794         return assignment;</span>
1795 
<a name="241" id="anc241"></a><span class="line-modified">1796     assignment = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">1797         return parseEffectfulPrefix();</span>
<span class="line-removed">1798     });</span>
<span class="line-removed">1799     if (assignment)</span>
<span class="line-removed">1800         return assignment;</span>
<span class="line-removed">1801 </span>
<span class="line-removed">1802     assignment = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">1803         return parseCallExpression();</span>
<span class="line-removed">1804     });</span>
<span class="line-removed">1805     if (assignment)</span>
<span class="line-removed">1806         return assignment;</span>
1807 
<a name="242" id="anc242"></a><span class="line-modified">1808     return Unexpected&lt;Error&gt;(assignment.error());</span>
<span class="line-modified">1809 }</span>
<span class="line-modified">1810 </span>
<span class="line-modified">1811 auto Parser::parseEffectfulPrefix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">1812 {</span>
<span class="line-modified">1813     auto prefix = consumeTypes({ Lexer::Token::Type::PlusPlus, Lexer::Token::Type::MinusMinus });</span>
<span class="line-modified">1814     if (!prefix)</span>
<span class="line-modified">1815         return Unexpected&lt;Error&gt;(prefix.error());</span>
<span class="line-modified">1816 </span>
<span class="line-modified">1817     auto previous = parsePossiblePrefix();</span>
<span class="line-modified">1818     if (!previous)</span>
<span class="line-modified">1819         return Unexpected&lt;Error&gt;(previous.error());</span>
<span class="line-modified">1820 </span>
<span class="line-modified">1821     switch (prefix-&gt;type) {</span>
<span class="line-removed">1822     case Lexer::Token::Type::PlusPlus: {</span>
<span class="line-removed">1823         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*previous));</span>
<span class="line-removed">1824         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">1825         callArguments.append(result-&gt;oldVariableReference());</span>
<span class="line-removed">1826         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*prefix), &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
<span class="line-removed">1827         result-&gt;setResultExpression(result-&gt;newVariableReference());</span>
<span class="line-removed">1828         return { WTFMove(result) };</span>
1829     }
<a name="243" id="anc243"></a><span class="line-removed">1830     default: {</span>
<span class="line-removed">1831         ASSERT(prefix-&gt;type == Lexer::Token::Type::MinusMinus);</span>
<span class="line-removed">1832         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*previous));</span>
<span class="line-removed">1833         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">1834         callArguments.append(result-&gt;oldVariableReference());</span>
<span class="line-removed">1835         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*prefix), &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
<span class="line-removed">1836         result-&gt;setResultExpression(result-&gt;newVariableReference());</span>
<span class="line-removed">1837         return { WTFMove(result) };</span>
<span class="line-removed">1838     }</span>
<span class="line-removed">1839     }</span>
<span class="line-removed">1840 }</span>
1841 
<a name="244" id="anc244"></a><span class="line-modified">1842 auto Parser::parseEffectfulSuffix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-removed">1843 {</span>
<span class="line-removed">1844     auto effectfulSuffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-removed">1845         auto previous = parsePossibleSuffix();</span>
<span class="line-removed">1846         if (!previous)</span>
<span class="line-removed">1847             return Unexpected&lt;Error&gt;(previous.error());</span>
<span class="line-removed">1848 </span>
<span class="line-removed">1849         auto suffix = consumeTypes({ Lexer::Token::Type::PlusPlus, Lexer::Token::Type::MinusMinus });</span>
<span class="line-removed">1850         if (!suffix)</span>
<span class="line-removed">1851             return Unexpected&lt;Error&gt;(suffix.error());</span>
<span class="line-removed">1852 </span>
<span class="line-removed">1853         switch (suffix-&gt;type) {</span>
<span class="line-removed">1854         case Lexer::Token::Type::PlusPlus: {</span>
<span class="line-removed">1855             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(*previous));</span>
<span class="line-removed">1856             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">1857             callArguments.append(result-&gt;oldVariableReference());</span>
<span class="line-removed">1858             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
<span class="line-removed">1859             result-&gt;setResultExpression(result-&gt;oldVariableReference());</span>
<span class="line-removed">1860             return { WTFMove(result) };</span>
<span class="line-removed">1861         }</span>
<span class="line-removed">1862         default: {</span>
<span class="line-removed">1863             ASSERT(suffix-&gt;type == Lexer::Token::Type::MinusMinus);</span>
<span class="line-removed">1864             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(*previous));</span>
<span class="line-removed">1865             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">1866             callArguments.append(result-&gt;oldVariableReference());</span>
<span class="line-removed">1867             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
<span class="line-removed">1868             result-&gt;setResultExpression(result-&gt;oldVariableReference());</span>
<span class="line-removed">1869             return { WTFMove(result) };</span>
<span class="line-removed">1870         }</span>
<span class="line-removed">1871         }</span>
<span class="line-removed">1872     });</span>
<span class="line-removed">1873     if (effectfulSuffix)</span>
<span class="line-removed">1874         return effectfulSuffix;</span>
<span class="line-removed">1875 </span>
<span class="line-removed">1876     effectfulSuffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">1877         return parseCallExpression();</span>
<span class="line-removed">1878     });</span>
<span class="line-removed">1879     if (effectfulSuffix)</span>
<span class="line-removed">1880         return effectfulSuffix;</span>
<span class="line-removed">1881 </span>
<span class="line-removed">1882     effectfulSuffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-removed">1883         auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">1884         if (!leftParenthesis)</span>
<span class="line-removed">1885             return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">1886 </span>
<span class="line-removed">1887         auto expression = parseExpression();</span>
<span class="line-removed">1888         if (!expression)</span>
<span class="line-removed">1889             return Unexpected&lt;Error&gt;(expression.error());</span>
<span class="line-removed">1890 </span>
<span class="line-removed">1891         auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">1892         if (!rightParenthesis)</span>
<span class="line-removed">1893             return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
<span class="line-removed">1894 </span>
<span class="line-removed">1895         return { WTFMove(*expression) };</span>
<span class="line-removed">1896     });</span>
<span class="line-removed">1897     if (effectfulSuffix)</span>
<span class="line-removed">1898         return effectfulSuffix;</span>
<span class="line-removed">1899 </span>
<span class="line-removed">1900     return Unexpected&lt;Error&gt;(effectfulSuffix.error());</span>
1901 }
1902 
1903 auto Parser::parseLimitedSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
1904 {
<a name="245" id="anc245"></a><span class="line-modified">1905     auto type = consumeTypes({ Lexer::Token::Type::FullStop, Lexer::Token::Type::Arrow, Lexer::Token::Type::LeftSquareBracket });</span>



1906     if (!type)
1907         return SuffixExpression(WTFMove(previous), false);
1908 
1909     switch (type-&gt;type) {
<a name="246" id="anc246"></a><span class="line-modified">1910     case Lexer::Token::Type::FullStop: {</span>
<span class="line-modified">1911         auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
1912         if (!identifier)
1913             return SuffixExpression(WTFMove(previous), false);
<a name="247" id="anc247"></a><span class="line-modified">1914         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(WTFMove(*type), WTFMove(previous), identifier-&gt;stringView.toString()), true);</span>

1915     }
<a name="248" id="anc248"></a><span class="line-modified">1916     case Lexer::Token::Type::Arrow: {</span>
<span class="line-modified">1917         auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
1918         if (!identifier)
1919             return SuffixExpression(WTFMove(previous), false);
<a name="249" id="anc249"></a><span class="line-modified">1920         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(Lexer::Token(*type), makeUniqueRef&lt;AST::DereferenceExpression&gt;(WTFMove(*type), WTFMove(previous)), identifier-&gt;stringView.toString()), true);</span>

1921     }
1922     default: {
<a name="250" id="anc250"></a><span class="line-modified">1923         ASSERT(type-&gt;type == Lexer::Token::Type::LeftSquareBracket);</span>
1924         auto expression = parseExpression();
1925         if (!expression)
1926             return SuffixExpression(WTFMove(previous), false);
<a name="251" id="anc251"></a><span class="line-modified">1927         if (!consumeType(Lexer::Token::Type::RightSquareBracket))</span>
<span class="line-modified">1928             return SuffixExpression(WTFMove(previous), false);</span>
<span class="line-modified">1929         return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(WTFMove(*type), WTFMove(previous), WTFMove(*expression)), true);</span>


1930     }
1931     }
1932 }
1933 
1934 auto Parser::parseSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
1935 {
<a name="252" id="anc252"></a><span class="line-modified">1936     auto suffix = consumeTypes({ Lexer::Token::Type::FullStop, Lexer::Token::Type::Arrow, Lexer::Token::Type::LeftSquareBracket, Lexer::Token::Type::PlusPlus, Lexer::Token::Type::MinusMinus });</span>





1937     if (!suffix)
1938         return SuffixExpression(WTFMove(previous), false);
1939 
1940     switch (suffix-&gt;type) {
<a name="253" id="anc253"></a><span class="line-modified">1941     case Lexer::Token::Type::FullStop: {</span>
<span class="line-modified">1942         auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
1943         if (!identifier)
1944             return SuffixExpression(WTFMove(previous), false);
<a name="254" id="anc254"></a><span class="line-modified">1945         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(WTFMove(*suffix), WTFMove(previous), identifier-&gt;stringView.toString()), true);</span>

1946     }
<a name="255" id="anc255"></a><span class="line-modified">1947     case Lexer::Token::Type::Arrow: {</span>
<span class="line-modified">1948         auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
1949         if (!identifier)
1950             return SuffixExpression(WTFMove(previous), false);
<a name="256" id="anc256"></a><span class="line-modified">1951         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(Lexer::Token(*suffix), makeUniqueRef&lt;AST::DereferenceExpression&gt;(WTFMove(*suffix), WTFMove(previous)), identifier-&gt;stringView.toString()), true);</span>

1952     }
<a name="257" id="anc257"></a><span class="line-modified">1953     case Lexer::Token::Type::LeftSquareBracket: {</span>
1954         auto expression = parseExpression();
1955         if (!expression)
1956             return SuffixExpression(WTFMove(previous), false);
<a name="258" id="anc258"></a><span class="line-modified">1957         if (!consumeType(Lexer::Token::Type::RightSquareBracket))</span>
<span class="line-modified">1958             return SuffixExpression(WTFMove(previous), false);</span>
<span class="line-modified">1959         return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(WTFMove(*suffix), WTFMove(previous), WTFMove(*expression)), true);</span>


1960     }
<a name="259" id="anc259"></a><span class="line-modified">1961     case Lexer::Token::Type::PlusPlus: {</span>
<span class="line-modified">1962         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(previous));</span>

1963         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1964         callArguments.append(result-&gt;oldVariableReference());
<a name="260" id="anc260"></a><span class="line-modified">1965         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
1966         result-&gt;setResultExpression(result-&gt;oldVariableReference());
1967         return SuffixExpression(WTFMove(result), true);
1968     }
1969     default: {
<a name="261" id="anc261"></a><span class="line-modified">1970         ASSERT(suffix-&gt;type == Lexer::Token::Type::MinusMinus);</span>
<span class="line-modified">1971         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(previous));</span>

1972         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1973         callArguments.append(result-&gt;oldVariableReference());
<a name="262" id="anc262"></a><span class="line-modified">1974         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
1975         result-&gt;setResultExpression(result-&gt;oldVariableReference());
1976         return SuffixExpression(WTFMove(result), true);
1977     }
1978     }
1979 }
1980 
1981 auto Parser::parseExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1982 {
<a name="263" id="anc263"></a><span class="line-modified">1983     auto origin = peek();</span>
<span class="line-removed">1984     if (!origin)</span>
<span class="line-removed">1985         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">1986 </span>
<span class="line-removed">1987     auto first = parsePossibleTernaryConditional();</span>
<span class="line-removed">1988     if (!first)</span>
<span class="line-removed">1989         return Unexpected&lt;Error&gt;(first.error());</span>
<span class="line-removed">1990 </span>
1991     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
<a name="264" id="anc264"></a>
1992     expressions.append(WTFMove(*first));
1993 
<a name="265" id="anc265"></a><span class="line-modified">1994     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified">1995         auto expression = parsePossibleTernaryConditional();</span>
<span class="line-removed">1996         if (!expression)</span>
<span class="line-removed">1997             return Unexpected&lt;Error&gt;(expression.error());</span>
1998         expressions.append(WTFMove(*expression));
1999     }
2000 
2001     if (expressions.size() == 1)
2002         return WTFMove(expressions[0]);
<a name="266" id="anc266"></a><span class="line-modified">2003     return { makeUniqueRef&lt;AST::CommaExpression&gt;(WTFMove(*origin), WTFMove(expressions)) };</span>


2004 }
2005 
<a name="267" id="anc267"></a><span class="line-modified">2006 auto Parser::parseTernaryConditional() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
2007 {
<a name="268" id="anc268"></a><span class="line-modified">2008     auto origin = peek();</span>
<span class="line-modified">2009     if (!origin)</span>
<span class="line-modified">2010         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">2011 </span>
<span class="line-removed">2012     auto predicate = parsePossibleLogicalBinaryOperation();</span>
<span class="line-removed">2013     if (!predicate)</span>
<span class="line-removed">2014         return Unexpected&lt;Error&gt;(predicate.error());</span>
<span class="line-removed">2015 </span>
<span class="line-removed">2016     auto questionMark = consumeType(Lexer::Token::Type::QuestionMark);</span>
<span class="line-removed">2017     if (!questionMark)</span>
<span class="line-removed">2018         return Unexpected&lt;Error&gt;(questionMark.error());</span>
<span class="line-removed">2019 </span>
<span class="line-removed">2020     auto bodyExpression = parseExpression();</span>
<span class="line-removed">2021     if (!bodyExpression)</span>
<span class="line-removed">2022         return Unexpected&lt;Error&gt;(bodyExpression.error());</span>
<span class="line-removed">2023 </span>
<span class="line-removed">2024     auto colon = consumeType(Lexer::Token::Type::Colon);</span>
<span class="line-removed">2025     if (!colon)</span>
<span class="line-removed">2026         return Unexpected&lt;Error&gt;(colon.error());</span>
<span class="line-removed">2027 </span>
<span class="line-removed">2028     auto elseExpression = parsePossibleTernaryConditional();</span>
<span class="line-removed">2029     if (!elseExpression)</span>
<span class="line-removed">2030         return Unexpected&lt;Error&gt;(elseExpression.error());</span>
2031 
<a name="269" id="anc269"></a>
2032     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
<a name="270" id="anc270"></a><span class="line-modified">2033     castArguments.append(WTFMove(*predicate));</span>
<span class="line-modified">2034     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*origin), &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">2035     return { makeUniqueRef&lt;AST::TernaryExpression&gt;(WTFMove(*origin), WTFMove(boolCast), WTFMove(*bodyExpression), WTFMove(*elseExpression)) };</span>
<span class="line-modified">2036 }</span>
<span class="line-modified">2037 </span>
<span class="line-modified">2038 auto Parser::parseAssignment() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">2039 {</span>
<span class="line-modified">2040     auto origin = peek();</span>
<span class="line-modified">2041     if (!origin)</span>
<span class="line-modified">2042         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">2043 </span>
<span class="line-modified">2044     auto left = parsePossiblePrefix();</span>
<span class="line-modified">2045     if (!left)</span>
<span class="line-modified">2046         return Unexpected&lt;Error&gt;(left.error());</span>
<span class="line-modified">2047 </span>
<span class="line-modified">2048     auto assignmentOperator = consumeTypes({</span>
<span class="line-modified">2049         Lexer::Token::Type::EqualsSign,</span>
<span class="line-modified">2050         Lexer::Token::Type::PlusEquals,</span>
<span class="line-modified">2051         Lexer::Token::Type::MinusEquals,</span>
<span class="line-modified">2052         Lexer::Token::Type::TimesEquals,</span>
<span class="line-removed">2053         Lexer::Token::Type::DivideEquals,</span>
<span class="line-removed">2054         Lexer::Token::Type::ModEquals,</span>
<span class="line-removed">2055         Lexer::Token::Type::XorEquals,</span>
<span class="line-removed">2056         Lexer::Token::Type::AndEquals,</span>
<span class="line-removed">2057         Lexer::Token::Type::OrEquals,</span>
<span class="line-removed">2058         Lexer::Token::Type::RightShiftEquals,</span>
<span class="line-removed">2059         Lexer::Token::Type::LeftShiftEquals</span>
<span class="line-removed">2060     });</span>
2061     if (!assignmentOperator)
<a name="271" id="anc271"></a><span class="line-modified">2062         return Unexpected&lt;Error&gt;(assignmentOperator.error());</span>
2063 
<a name="272" id="anc272"></a><span class="line-modified">2064     auto right = parsePossibleTernaryConditional();</span>
<span class="line-modified">2065     if (!right)</span>
<span class="line-removed">2066         return Unexpected&lt;Error&gt;(right.error());</span>
2067 
<a name="273" id="anc273"></a><span class="line-modified">2068     if (assignmentOperator-&gt;type == Lexer::Token::Type::EqualsSign)</span>
<span class="line-modified">2069         return { makeUniqueRef&lt;AST::AssignmentExpression&gt;(WTFMove(*origin), WTFMove(*left), WTFMove(*right))};</span>
2070 
2071     String name;
2072     switch (assignmentOperator-&gt;type) {
<a name="274" id="anc274"></a><span class="line-modified">2073     case Lexer::Token::Type::PlusEquals:</span>
2074         name = &quot;operator+&quot;_str;
2075         break;
<a name="275" id="anc275"></a><span class="line-modified">2076     case Lexer::Token::Type::MinusEquals:</span>
2077         name = &quot;operator-&quot;_str;
2078         break;
<a name="276" id="anc276"></a><span class="line-modified">2079     case Lexer::Token::Type::TimesEquals:</span>
2080         name = &quot;operator*&quot;_str;
2081         break;
<a name="277" id="anc277"></a><span class="line-modified">2082     case Lexer::Token::Type::DivideEquals:</span>
2083         name = &quot;operator/&quot;_str;
2084         break;
<a name="278" id="anc278"></a><span class="line-modified">2085     case Lexer::Token::Type::ModEquals:</span>
2086         name = &quot;operator%&quot;_str;
2087         break;
<a name="279" id="anc279"></a><span class="line-modified">2088     case Lexer::Token::Type::XorEquals:</span>
2089         name = &quot;operator^&quot;_str;
2090         break;
<a name="280" id="anc280"></a><span class="line-modified">2091     case Lexer::Token::Type::AndEquals:</span>
2092         name = &quot;operator&amp;&quot;_str;
2093         break;
<a name="281" id="anc281"></a><span class="line-modified">2094     case Lexer::Token::Type::OrEquals:</span>
2095         name = &quot;operator|&quot;_str;
2096         break;
<a name="282" id="anc282"></a><span class="line-modified">2097     case Lexer::Token::Type::RightShiftEquals:</span>
2098         name = &quot;operator&gt;&gt;&quot;_str;
2099         break;
2100     default:
<a name="283" id="anc283"></a><span class="line-modified">2101         ASSERT(assignmentOperator-&gt;type == Lexer::Token::Type::LeftShiftEquals);</span>
2102         name = &quot;operator&lt;&lt;&quot;_str;
2103         break;
2104     }
2105 
<a name="284" id="anc284"></a><span class="line-modified">2106     auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*origin), WTFMove(*left));</span>
2107     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2108     callArguments.append(result-&gt;oldVariableReference());
2109     callArguments.append(WTFMove(*right));
<a name="285" id="anc285"></a><span class="line-modified">2110     result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*origin), WTFMove(name), WTFMove(callArguments)));</span>
2111     result-&gt;setResultExpression(result-&gt;newVariableReference());
2112     return { WTFMove(result) };
2113 }
2114 
2115 auto Parser::parsePossibleTernaryConditional() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2116 {
<a name="286" id="anc286"></a><span class="line-modified">2117     auto ternaryExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">2118         return parseTernaryConditional();</span>
<span class="line-removed">2119     });</span>
<span class="line-removed">2120     if (ternaryExpression)</span>
<span class="line-removed">2121         return ternaryExpression;</span>
2122 
<a name="287" id="anc287"></a><span class="line-modified">2123     auto assignmentExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">2124         return parseAssignment();</span>
<span class="line-modified">2125     });</span>
<span class="line-modified">2126     if (assignmentExpression)</span>
<span class="line-modified">2127         return assignmentExpression;</span>








2128 
<a name="288" id="anc288"></a><span class="line-modified">2129     auto binaryOperation = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">2130         return parsePossibleLogicalBinaryOperation();</span>
<span class="line-modified">2131     });</span>
<span class="line-modified">2132     if (binaryOperation)</span>
<span class="line-modified">2133         return binaryOperation;</span>










2134 
<a name="289" id="anc289"></a><span class="line-modified">2135     return Unexpected&lt;Error&gt;(binaryOperation.error());</span>







2136 }
2137 
2138 auto Parser::parsePossibleLogicalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2139 {
<a name="290" id="anc290"></a><span class="line-modified">2140     auto parsedPrevious = parsePossibleRelationalBinaryOperation();</span>
<span class="line-modified">2141     if (!parsedPrevious)</span>
<span class="line-modified">2142         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-modified">2143     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>
<span class="line-modified">2144 </span>
<span class="line-modified">2145     while (auto logicalBinaryOperation = tryTypes({</span>
<span class="line-modified">2146         Lexer::Token::Type::OrOr,</span>
<span class="line-modified">2147         Lexer::Token::Type::AndAnd,</span>
<span class="line-modified">2148         Lexer::Token::Type::Or,</span>
<span class="line-modified">2149         Lexer::Token::Type::Xor,</span>
<span class="line-modified">2150         Lexer::Token::Type::And</span>
<span class="line-modified">2151         })) {</span>
<span class="line-modified">2152         auto next = parsePossibleRelationalBinaryOperation();</span>
<span class="line-modified">2153         if (!next)</span>
<span class="line-modified">2154             return Unexpected&lt;Error&gt;(next.error());</span>
2155 
2156         switch (logicalBinaryOperation-&gt;type) {
<a name="291" id="anc291"></a><span class="line-modified">2157         case Lexer::Token::Type::OrOr:</span>
<span class="line-modified">2158             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(WTFMove(*logicalBinaryOperation), AST::LogicalExpression::Type::Or, WTFMove(previous), WTFMove(*next));</span>
2159             break;
<a name="292" id="anc292"></a><span class="line-modified">2160         case Lexer::Token::Type::AndAnd:</span>
<span class="line-modified">2161             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(WTFMove(*logicalBinaryOperation), AST::LogicalExpression::Type::And, WTFMove(previous), WTFMove(*next));</span>
2162             break;
<a name="293" id="anc293"></a><span class="line-modified">2163         case Lexer::Token::Type::Or: {</span>
2164             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2165             callArguments.append(WTFMove(previous));
2166             callArguments.append(WTFMove(*next));
<a name="294" id="anc294"></a><span class="line-modified">2167             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*logicalBinaryOperation), &quot;operator|&quot;_str, WTFMove(callArguments));</span>
2168             break;
2169         }
<a name="295" id="anc295"></a><span class="line-modified">2170         case Lexer::Token::Type::Xor: {</span>
2171             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2172             callArguments.append(WTFMove(previous));
2173             callArguments.append(WTFMove(*next));
<a name="296" id="anc296"></a><span class="line-modified">2174             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*logicalBinaryOperation), &quot;operator^&quot;_str, WTFMove(callArguments));</span>
2175             break;
2176         }
2177         default: {
<a name="297" id="anc297"></a><span class="line-modified">2178             ASSERT(logicalBinaryOperation-&gt;type == Lexer::Token::Type::And);</span>
2179             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2180             callArguments.append(WTFMove(previous));
2181             callArguments.append(WTFMove(*next));
<a name="298" id="anc298"></a><span class="line-modified">2182             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*logicalBinaryOperation), &quot;operator&amp;&quot;_str, WTFMove(callArguments));</span>
2183             break;
2184         }
2185         }
2186     }
2187 
2188     return { WTFMove(previous) };
2189 }
2190 
2191 auto Parser::parsePossibleRelationalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2192 {
<a name="299" id="anc299"></a><span class="line-modified">2193     auto parsedPrevious = parsePossibleShift();</span>
<span class="line-modified">2194     if (!parsedPrevious)</span>
<span class="line-modified">2195         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-modified">2196     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>
<span class="line-modified">2197 </span>
<span class="line-modified">2198     while (auto relationalBinaryOperation = tryTypes({</span>
<span class="line-modified">2199         Lexer::Token::Type::LessThanSign,</span>
<span class="line-modified">2200         Lexer::Token::Type::GreaterThanSign,</span>
<span class="line-modified">2201         Lexer::Token::Type::LessThanOrEqualTo,</span>
<span class="line-modified">2202         Lexer::Token::Type::GreaterThanOrEqualTo,</span>
<span class="line-modified">2203         Lexer::Token::Type::EqualComparison,</span>
<span class="line-modified">2204         Lexer::Token::Type::NotEqual</span>
<span class="line-modified">2205         })) {</span>
<span class="line-modified">2206         auto next = parsePossibleShift();</span>
<span class="line-modified">2207         if (!next)</span>
<span class="line-modified">2208             return Unexpected&lt;Error&gt;(next.error());</span>




2209 
2210         switch (relationalBinaryOperation-&gt;type) {
<a name="300" id="anc300"></a><span class="line-modified">2211         case Lexer::Token::Type::LessThanSign: {</span>
<span class="line-modified">2212             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2213             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2214             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2215             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&lt;&quot;_str, WTFMove(callArguments));</span>
2216             break;
2217         }
<a name="301" id="anc301"></a><span class="line-modified">2218         case Lexer::Token::Type::GreaterThanSign: {</span>
<span class="line-modified">2219             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2220             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2221             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2222             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&gt;&quot;_str, WTFMove(callArguments));</span>
2223             break;
2224         }
<a name="302" id="anc302"></a><span class="line-modified">2225         case Lexer::Token::Type::LessThanOrEqualTo: {</span>
<span class="line-modified">2226             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2227             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2228             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2229             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&lt;=&quot;_str, WTFMove(callArguments));</span>
2230             break;
2231         }
<a name="303" id="anc303"></a><span class="line-modified">2232         case Lexer::Token::Type::GreaterThanOrEqualTo: {</span>
<span class="line-modified">2233             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2234             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2235             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2236             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&gt;=&quot;_str, WTFMove(callArguments));</span>
2237             break;
2238         }
<a name="304" id="anc304"></a><span class="line-modified">2239         case Lexer::Token::Type::EqualComparison: {</span>
<span class="line-modified">2240             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2241             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2242             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2243             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator==&quot;_str, WTFMove(callArguments));</span>
2244             break;
2245         }
2246         default: {
<a name="305" id="anc305"></a><span class="line-modified">2247             ASSERT(relationalBinaryOperation-&gt;type == Lexer::Token::Type::NotEqual);</span>
<span class="line-modified">2248             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-modified">2249             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2250             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2251             previous = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*relationalBinaryOperation), &quot;operator==&quot;_str, WTFMove(callArguments));</span>
<span class="line-removed">2252             previous = makeUniqueRef&lt;AST::LogicalNotExpression&gt;(WTFMove(*relationalBinaryOperation), WTFMove(previous));</span>
2253             break;
2254         }
2255         }
2256     }
2257 
2258     return WTFMove(previous);
2259 }
2260 
2261 auto Parser::parsePossibleShift() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2262 {
<a name="306" id="anc306"></a><span class="line-modified">2263     auto parsedPrevious = parsePossibleAdd();</span>
<span class="line-modified">2264     if (!parsedPrevious)</span>
<span class="line-modified">2265         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-modified">2266     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>








2267 
<a name="307" id="anc307"></a><span class="line-modified">2268     while (auto shift = tryTypes({</span>
<span class="line-modified">2269         Lexer::Token::Type::LeftShift,</span>
<span class="line-modified">2270         Lexer::Token::Type::RightShift</span>
<span class="line-removed">2271         })) {</span>
<span class="line-removed">2272         auto next = parsePossibleAdd();</span>
<span class="line-removed">2273         if (!next)</span>
<span class="line-removed">2274             return Unexpected&lt;Error&gt;(next.error());</span>
2275 
2276         switch (shift-&gt;type) {
<a name="308" id="anc308"></a><span class="line-modified">2277         case Lexer::Token::Type::LeftShift: {</span>
<span class="line-modified">2278             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2279             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2280             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2281             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*shift), &quot;operator&lt;&lt;&quot;_str, WTFMove(callArguments));</span>
2282             break;
2283         }
2284         default: {
<a name="309" id="anc309"></a><span class="line-modified">2285             ASSERT(shift-&gt;type == Lexer::Token::Type::RightShift);</span>
<span class="line-modified">2286             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2287             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2288             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2289             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*shift), &quot;operator&gt;&gt;&quot;_str, WTFMove(callArguments));</span>
2290             break;
2291         }
2292         }
2293     }
2294 
2295     return WTFMove(previous);
2296 }
2297 
2298 auto Parser::parsePossibleAdd() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2299 {
<a name="310" id="anc310"></a><span class="line-modified">2300     auto parsedPrevious = parsePossibleMultiply();</span>
<span class="line-modified">2301     if (!parsedPrevious)</span>
<span class="line-modified">2302         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-removed">2303     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>
2304 
<a name="311" id="anc311"></a><span class="line-modified">2305     while (auto add = tryTypes({</span>
<span class="line-modified">2306         Lexer::Token::Type::Plus,</span>
<span class="line-modified">2307         Lexer::Token::Type::Minus</span>
<span class="line-modified">2308         })) {</span>
<span class="line-modified">2309         auto next = parsePossibleMultiply();</span>
<span class="line-modified">2310         if (!next)</span>
<span class="line-modified">2311             return Unexpected&lt;Error&gt;(next.error());</span>





2312 
2313         switch (add-&gt;type) {
<a name="312" id="anc312"></a><span class="line-modified">2314         case Lexer::Token::Type::Plus: {</span>
<span class="line-modified">2315             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2316             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2317             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2318             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*add), &quot;operator+&quot;_str, WTFMove(callArguments));</span>
2319             break;
2320         }
2321         default: {
<a name="313" id="anc313"></a><span class="line-modified">2322             ASSERT(add-&gt;type == Lexer::Token::Type::Minus);</span>
<span class="line-modified">2323             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2324             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2325             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2326             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*add), &quot;operator-&quot;_str, WTFMove(callArguments));</span>
2327             break;
2328         }
2329         }
2330     }
2331 
2332     return WTFMove(previous);
2333 }
2334 
2335 auto Parser::parsePossibleMultiply() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2336 {
<a name="314" id="anc314"></a><span class="line-modified">2337     auto parsedPrevious = parsePossiblePrefix();</span>
<span class="line-modified">2338     if (!parsedPrevious)</span>
<span class="line-modified">2339         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-removed">2340     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>
2341 
<a name="315" id="anc315"></a><span class="line-modified">2342     while (auto multiply = tryTypes({</span>
<span class="line-modified">2343         Lexer::Token::Type::Star,</span>
<span class="line-modified">2344         Lexer::Token::Type::Divide,</span>
<span class="line-modified">2345         Lexer::Token::Type::Mod</span>
<span class="line-modified">2346         })) {</span>
<span class="line-modified">2347         auto next = parsePossiblePrefix();</span>
<span class="line-modified">2348         if (!next)</span>
<span class="line-modified">2349             return Unexpected&lt;Error&gt;(next.error());</span>





2350 
2351         switch (multiply-&gt;type) {
<a name="316" id="anc316"></a><span class="line-modified">2352         case Lexer::Token::Type::Star: {</span>
<span class="line-modified">2353             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2354             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2355             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2356             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*multiply), &quot;operator*&quot;_str, WTFMove(callArguments));</span>
2357             break;
2358         }
<a name="317" id="anc317"></a><span class="line-modified">2359         case Lexer::Token::Type::Divide: {</span>
<span class="line-modified">2360             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2361             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2362             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2363             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*multiply), &quot;operator/&quot;_str, WTFMove(callArguments));</span>
2364             break;
2365         }
2366         default: {
<a name="318" id="anc318"></a><span class="line-modified">2367             ASSERT(multiply-&gt;type == Lexer::Token::Type::Mod);</span>
<span class="line-modified">2368             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">2369             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">2370             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">2371             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*multiply), &quot;operator%&quot;_str, WTFMove(callArguments));</span>
2372             break;
2373         }
2374         }
2375     }
2376 
2377     return WTFMove(previous);
2378 }
2379 
<a name="319" id="anc319"></a><span class="line-modified">2380 auto Parser::parsePossiblePrefix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
2381 {
<a name="320" id="anc320"></a><span class="line-modified">2382     if (auto prefix = tryTypes({</span>
<span class="line-modified">2383         Lexer::Token::Type::PlusPlus,</span>
<span class="line-modified">2384         Lexer::Token::Type::MinusMinus,</span>
<span class="line-modified">2385         Lexer::Token::Type::Plus,</span>
<span class="line-modified">2386         Lexer::Token::Type::Minus,</span>
<span class="line-modified">2387         Lexer::Token::Type::Tilde,</span>
<span class="line-modified">2388         Lexer::Token::Type::ExclamationPoint,</span>
<span class="line-modified">2389         Lexer::Token::Type::And,</span>
<span class="line-modified">2390         Lexer::Token::Type::At,</span>
<span class="line-modified">2391         Lexer::Token::Type::Star</span>
<span class="line-modified">2392     })) {</span>
<span class="line-modified">2393         auto next = parsePossiblePrefix();</span>
<span class="line-modified">2394         if (!next)</span>
<span class="line-removed">2395             return Unexpected&lt;Error&gt;(next.error());</span>
2396 
2397         switch (prefix-&gt;type) {
<a name="321" id="anc321"></a><span class="line-modified">2398         case Lexer::Token::Type::PlusPlus: {</span>
<span class="line-modified">2399             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*next));</span>


2400             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2401             callArguments.append(result-&gt;oldVariableReference());
<a name="322" id="anc322"></a><span class="line-modified">2402             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
2403             result-&gt;setResultExpression(result-&gt;newVariableReference());
2404             return { WTFMove(result) };
2405         }
<a name="323" id="anc323"></a><span class="line-modified">2406         case Lexer::Token::Type::MinusMinus: {</span>
<span class="line-modified">2407             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*next));</span>


2408             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2409             callArguments.append(result-&gt;oldVariableReference());
<a name="324" id="anc324"></a><span class="line-modified">2410             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
2411             result-&gt;setResultExpression(result-&gt;newVariableReference());
2412             return { WTFMove(result) };
2413         }
<a name="325" id="anc325"></a><span class="line-modified">2414         case Lexer::Token::Type::Plus: {</span>
2415             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2416             callArguments.append(WTFMove(*next));
<a name="326" id="anc326"></a><span class="line-modified">2417             return { makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator+&quot;_str, WTFMove(callArguments)) };</span>
2418         }
<a name="327" id="anc327"></a><span class="line-modified">2419         case Lexer::Token::Type::Minus: {</span>
2420             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2421             callArguments.append(WTFMove(*next));
<a name="328" id="anc328"></a><span class="line-modified">2422             return { makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator-&quot;_str, WTFMove(callArguments)) };</span>
2423         }
<a name="329" id="anc329"></a><span class="line-modified">2424         case Lexer::Token::Type::Tilde: {</span>
2425             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
2426             callArguments.append(WTFMove(*next));
<a name="330" id="anc330"></a><span class="line-modified">2427             return { makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator~&quot;_str, WTFMove(callArguments)) };</span>
2428         }
<a name="331" id="anc331"></a><span class="line-modified">2429         case Lexer::Token::Type::ExclamationPoint: {</span>
2430             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
2431             castArguments.append(WTFMove(*next));
<a name="332" id="anc332"></a><span class="line-modified">2432             auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">2433             return { makeUniqueRef&lt;AST::LogicalNotExpression&gt;(Lexer::Token(*prefix), WTFMove(boolCast)) };</span>
2434         }
<a name="333" id="anc333"></a><span class="line-modified">2435         case Lexer::Token::Type::And:</span>
<span class="line-modified">2436             return { makeUniqueRef&lt;AST::MakePointerExpression&gt;(Lexer::Token(*prefix), WTFMove(*next)) };</span>
<span class="line-modified">2437         case Lexer::Token::Type::At:</span>
<span class="line-modified">2438             return { makeUniqueRef&lt;AST::MakeArrayReferenceExpression&gt;(Lexer::Token(*prefix), WTFMove(*next)) };</span>
2439         default:
<a name="334" id="anc334"></a><span class="line-modified">2440             ASSERT(prefix-&gt;type == Lexer::Token::Type::Star);</span>
<span class="line-modified">2441             return { makeUniqueRef&lt;AST::DereferenceExpression&gt;(Lexer::Token(*prefix), WTFMove(*next)) };</span>
2442         }
2443     }
2444 
<a name="335" id="anc335"></a><span class="line-modified">2445     return parsePossibleSuffix();</span>
2446 }
2447 
<a name="336" id="anc336"></a><span class="line-modified">2448 auto Parser::parsePossibleSuffix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
2449 {
<a name="337" id="anc337"></a><span class="line-modified">2450     auto suffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-modified">2451         auto expression = parseCallExpression();</span>
<span class="line-removed">2452         if (!expression)</span>
<span class="line-removed">2453             return Unexpected&lt;Error&gt;(expression.error());</span>
2454 
<a name="338" id="anc338"></a>



2455         while (true) {
<a name="339" id="anc339"></a><span class="line-modified">2456             auto result = backtrackingScope&lt;SuffixExpression&gt;([&amp;]() -&gt; SuffixExpression {</span>
<span class="line-modified">2457                 return parseLimitedSuffixOperator(WTFMove(*expression));</span>
<span class="line-removed">2458             });</span>
<span class="line-removed">2459             expression = WTFMove(result.result);</span>
<span class="line-removed">2460             if (!result)</span>
2461                 break;
<a name="340" id="anc340"></a>

2462         }
2463         return expression;
<a name="341" id="anc341"></a><span class="line-modified">2464     });</span>
<span class="line-removed">2465     if (suffix)</span>
<span class="line-removed">2466         return suffix;</span>
2467 
<a name="342" id="anc342"></a><span class="line-modified">2468     suffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-modified">2469         auto expression = parseTerm();</span>
<span class="line-removed">2470         if (!expression)</span>
<span class="line-removed">2471             return Unexpected&lt;Error&gt;(expression.error());</span>
2472 
<a name="343" id="anc343"></a><span class="line-modified">2473         while (true) {</span>
<span class="line-modified">2474             auto result = backtrackingScope&lt;SuffixExpression&gt;([&amp;]() -&gt; SuffixExpression {</span>
<span class="line-modified">2475                 return parseSuffixOperator(WTFMove(*expression));</span>
<span class="line-modified">2476             });</span>
<span class="line-modified">2477             expression = WTFMove(result.result);</span>
<span class="line-modified">2478             if (!result)</span>
<span class="line-modified">2479                 break;</span>



2480         }
<a name="344" id="anc344"></a><span class="line-modified">2481         return expression;</span>
<span class="line-modified">2482     });</span>
<span class="line-modified">2483     if (suffix)</span>
<span class="line-modified">2484         return suffix;</span>
<span class="line-modified">2485 </span>
<span class="line-modified">2486     return Unexpected&lt;Error&gt;(suffix.error());</span>

2487 }
2488 
2489 auto Parser::parseCallExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2490 {
<a name="345" id="anc345"></a><span class="line-modified">2491     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified">2492     if (!name)</span>
<span class="line-removed">2493         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed">2494     auto callName = name-&gt;stringView.toString();</span>
2495 
<a name="346" id="anc346"></a><span class="line-modified">2496     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">2497     if (!leftParenthesis)</span>
<span class="line-removed">2498         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
2499 
2500     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
<a name="347" id="anc347"></a><span class="line-modified">2501     if (tryType(Lexer::Token::Type::RightParenthesis))</span>
2502         return { makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*name), WTFMove(callName), WTFMove(arguments)) };
2503 
<a name="348" id="anc348"></a><span class="line-modified">2504     auto firstArgument = parsePossibleTernaryConditional();</span>
<span class="line-removed">2505     if (!firstArgument)</span>
<span class="line-removed">2506         return Unexpected&lt;Error&gt;(firstArgument.error());</span>
2507     arguments.append(WTFMove(*firstArgument));
<a name="349" id="anc349"></a><span class="line-modified">2508     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified">2509         auto argument = parsePossibleTernaryConditional();</span>
<span class="line-removed">2510         if (!argument)</span>
<span class="line-removed">2511             return Unexpected&lt;Error&gt;(argument.error());</span>
2512         arguments.append(WTFMove(*argument));
2513     }
2514 
<a name="350" id="anc350"></a><span class="line-modified">2515     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-modified">2516     if (!rightParenthesis)</span>
<span class="line-removed">2517         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
2518 
<a name="351" id="anc351"></a><span class="line-modified">2519     return { makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*name), WTFMove(callName), WTFMove(arguments)) };</span>
2520 }
2521 
2522 auto Parser::parseTerm() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2523 {
<a name="352" id="anc352"></a><span class="line-modified">2524     auto type = consumeTypes({</span>
<span class="line-modified">2525         Lexer::Token::Type::IntLiteral,</span>
<span class="line-modified">2526         Lexer::Token::Type::UintLiteral,</span>
<span class="line-modified">2527         Lexer::Token::Type::FloatLiteral,</span>
<span class="line-modified">2528         Lexer::Token::Type::Null,</span>
<span class="line-modified">2529         Lexer::Token::Type::True,</span>
<span class="line-modified">2530         Lexer::Token::Type::False,</span>
<span class="line-modified">2531         Lexer::Token::Type::Identifier,</span>
<span class="line-modified">2532         Lexer::Token::Type::LeftParenthesis</span>
<span class="line-removed">2533     });</span>
2534     if (!type)
<a name="353" id="anc353"></a><span class="line-modified">2535         return Unexpected&lt;Error&gt;(type.error());</span>
2536 
2537     switch (type-&gt;type) {
<a name="354" id="anc354"></a><span class="line-modified">2538     case Lexer::Token::Type::IntLiteral: {</span>
<span class="line-modified">2539         auto value = intLiteralToInt(type-&gt;stringView);</span>
2540         if (!value)
<a name="355" id="anc355"></a><span class="line-modified">2541             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified">2542         return { makeUniqueRef&lt;AST::IntegerLiteral&gt;(WTFMove(*type), *value) };</span>
2543     }
<a name="356" id="anc356"></a><span class="line-modified">2544     case Lexer::Token::Type::UintLiteral: {</span>
<span class="line-modified">2545         auto value = uintLiteralToUint(type-&gt;stringView);</span>
2546         if (!value)
<a name="357" id="anc357"></a><span class="line-modified">2547             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified">2548         return { makeUniqueRef&lt;AST::UnsignedIntegerLiteral&gt;(WTFMove(*type), *value) };</span>
2549     }
<a name="358" id="anc358"></a><span class="line-modified">2550     case Lexer::Token::Type::FloatLiteral: {</span>
<span class="line-modified">2551         auto value = floatLiteralToFloat(type-&gt;stringView);</span>
2552         if (!value)
<a name="359" id="anc359"></a><span class="line-modified">2553             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified">2554         return { makeUniqueRef&lt;AST::FloatLiteral&gt;(WTFMove(*type), *value) };</span>
<span class="line-modified">2555     }</span>
<span class="line-modified">2556     case Lexer::Token::Type::Null:</span>
<span class="line-modified">2557         return { makeUniqueRef&lt;AST::NullLiteral&gt;(WTFMove(*type)) };</span>
<span class="line-modified">2558     case Lexer::Token::Type::True:</span>
<span class="line-modified">2559         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(WTFMove(*type), true) };</span>
<span class="line-modified">2560     case Lexer::Token::Type::False:</span>
<span class="line-modified">2561         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(WTFMove(*type), false) };</span>
<span class="line-modified">2562     case Lexer::Token::Type::Identifier: {</span>
<span class="line-modified">2563         auto name = type-&gt;stringView.toString();</span>
<span class="line-modified">2564         return { makeUniqueRef&lt;AST::VariableReference&gt;(WTFMove(*type), WTFMove(name)) };</span>
2565     }
2566     default: {
<a name="360" id="anc360"></a><span class="line-modified">2567         ASSERT(type-&gt;type == Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-modified">2568         auto expression = parseExpression();</span>
<span class="line-modified">2569         if (!expression)</span>
<span class="line-removed">2570             return Unexpected&lt;Error&gt;(expression.error());</span>
<span class="line-removed">2571 </span>
<span class="line-removed">2572         auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">2573         if (!rightParenthesis)</span>
<span class="line-removed">2574             return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
2575 
2576         return { WTFMove(*expression) };
2577     }
2578     }
2579 }
2580 
2581 } // namespace WHLSL
2582 
2583 } // namespace WebCore
2584 
2585 #endif // ENABLE(WEBGPU)
<a name="361" id="anc361"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="361" type="hidden" />
</body>
</html>