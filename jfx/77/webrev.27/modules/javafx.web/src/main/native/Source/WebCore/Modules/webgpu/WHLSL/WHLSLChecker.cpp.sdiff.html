<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLCheckDuplicateFunctions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLChecker.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WHLSLChecker.h&quot;
  28 
  29 #if ENABLE(WEBGPU)
  30 
  31 #include &quot;WHLSLArrayReferenceType.h&quot;
  32 #include &quot;WHLSLArrayType.h&quot;
  33 #include &quot;WHLSLAssignmentExpression.h&quot;
  34 #include &quot;WHLSLCallExpression.h&quot;
  35 #include &quot;WHLSLCommaExpression.h&quot;
  36 #include &quot;WHLSLDereferenceExpression.h&quot;
  37 #include &quot;WHLSLDoWhileLoop.h&quot;
  38 #include &quot;WHLSLDotExpression.h&quot;

  39 #include &quot;WHLSLForLoop.h&quot;
  40 #include &quot;WHLSLGatherEntryPointItems.h&quot;
  41 #include &quot;WHLSLIfStatement.h&quot;
  42 #include &quot;WHLSLIndexExpression.h&quot;
  43 #include &quot;WHLSLInferTypes.h&quot;
  44 #include &quot;WHLSLLogicalExpression.h&quot;
  45 #include &quot;WHLSLLogicalNotExpression.h&quot;
  46 #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;
  47 #include &quot;WHLSLMakePointerExpression.h&quot;

  48 #include &quot;WHLSLPointerType.h&quot;
  49 #include &quot;WHLSLProgram.h&quot;
  50 #include &quot;WHLSLReadModifyWriteExpression.h&quot;
  51 #include &quot;WHLSLResolvableType.h&quot;
  52 #include &quot;WHLSLResolveOverloadImpl.h&quot;
  53 #include &quot;WHLSLResolvingType.h&quot;
  54 #include &quot;WHLSLReturn.h&quot;
  55 #include &quot;WHLSLSwitchStatement.h&quot;
  56 #include &quot;WHLSLTernaryExpression.h&quot;
  57 #include &quot;WHLSLVisitor.h&quot;
  58 #include &quot;WHLSLWhileLoop.h&quot;
  59 #include &lt;wtf/HashMap.h&gt;
  60 #include &lt;wtf/HashSet.h&gt;
  61 #include &lt;wtf/Ref.h&gt;
  62 #include &lt;wtf/Vector.h&gt;
  63 #include &lt;wtf/text/WTFString.h&gt;
  64 
  65 namespace WebCore {
  66 
  67 namespace WHLSL {
  68 
  69 class PODChecker : public Visitor {
  70 public:
  71     PODChecker() = default;
  72 
  73     virtual ~PODChecker() = default;
  74 
  75     void visit(AST::EnumerationDefinition&amp; enumerationDefinition) override
  76     {
  77         Visitor::visit(enumerationDefinition);
  78     }
  79 
  80     void visit(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration) override
  81     {
  82         if (!nativeTypeDeclaration.isNumber()
  83             &amp;&amp; !nativeTypeDeclaration.isVector()
  84             &amp;&amp; !nativeTypeDeclaration.isMatrix())
<span class="line-modified">  85             setError();</span>
  86     }
  87 
  88     void visit(AST::StructureDefinition&amp; structureDefinition) override
  89     {
  90         Visitor::visit(structureDefinition);
  91     }
  92 
  93     void visit(AST::TypeDefinition&amp; typeDefinition) override
  94     {
  95         Visitor::visit(typeDefinition);
  96     }
  97 
  98     void visit(AST::ArrayType&amp; arrayType) override
  99     {
 100         Visitor::visit(arrayType);
 101     }
 102 
<span class="line-modified"> 103     void visit(AST::PointerType&amp;) override</span>
 104     {
<span class="line-modified"> 105         setError();</span>
 106     }
 107 
<span class="line-modified"> 108     void visit(AST::ArrayReferenceType&amp;) override</span>
 109     {
<span class="line-modified"> 110         setError();</span>
 111     }
 112 
 113     void visit(AST::TypeReference&amp; typeReference) override
 114     {
<span class="line-modified"> 115         ASSERT(typeReference.resolvedType());</span>
<span class="line-removed"> 116         checkErrorAndVisit(*typeReference.resolvedType());</span>
 117     }
 118 };
 119 
<span class="line-modified"> 120 static AST::NativeFunctionDeclaration resolveWithOperatorAnderIndexer(AST::CallExpression&amp; callExpression, AST::ArrayReferenceType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>




































































































































 121 {
 122     const bool isOperator = true;
<span class="line-modified"> 123     auto returnType = makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(callExpression.origin()), firstArgument.addressSpace(), firstArgument.elementType().clone());</span>
 124     AST::VariableDeclarations parameters;
<span class="line-modified"> 125     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { firstArgument.clone() }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified"> 126     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.uintType()) }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified"> 127     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator&amp;[]&quot;, String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));</span>
 128 }
 129 
<span class="line-modified"> 130 static AST::NativeFunctionDeclaration resolveWithOperatorLength(AST::CallExpression&amp; callExpression, AST::UnnamedType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
 131 {
 132     const bool isOperator = true;
<span class="line-modified"> 133     auto returnType = AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.uintType());</span>
 134     AST::VariableDeclarations parameters;
<span class="line-modified"> 135     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { firstArgument.clone() }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified"> 136     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator.length&quot;, String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));</span>
 137 }
 138 
<span class="line-modified"> 139 static AST::NativeFunctionDeclaration resolveWithReferenceComparator(AST::CallExpression&amp; callExpression, ResolvingType&amp; firstArgument, ResolvingType&amp; secondArgument, const Intrinsics&amp; intrinsics)</span>
 140 {
 141     const bool isOperator = true;
<span class="line-modified"> 142     auto returnType = AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.boolType());</span>
<span class="line-modified"> 143     auto argumentType = WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 144         return unnamedType-&gt;clone();</span>
<span class="line-modified"> 145     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 146         return WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 147             return unnamedType-&gt;clone();</span>
<span class="line-modified"> 148         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
 149             // We encountered &quot;null == null&quot;.
<span class="line-modified"> 150             // The type isn&#39;t observable, so we can pick whatever we want.</span>
<span class="line-modified"> 151             // FIXME: This can probably be generalized, using the &quot;preferred type&quot; infrastructure used by generic literals</span>
<span class="line-modified"> 152             return AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.intType());</span>
<span class="line-modified"> 153         }), secondArgument);</span>
<span class="line-modified"> 154     }), firstArgument);</span>
 155     AST::VariableDeclarations parameters;
<span class="line-modified"> 156     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { argumentType-&gt;clone() }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified"> 157     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { WTFMove(argumentType) }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified"> 158     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator==&quot;, String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));</span>
 159 }
 160 
<span class="line-modified"> 161 static Optional&lt;AST::NativeFunctionDeclaration&gt; resolveByInstantiation(AST::CallExpression&amp; callExpression, const Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const Intrinsics&amp; intrinsics)</span>






 162 {
<span class="line-modified"> 163     if (callExpression.name() == &quot;operator&amp;[]&quot; &amp;&amp; types.size() == 2) {</span>
<span class="line-modified"> 164         auto* firstArgumentArrayRef = WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::ArrayReferenceType* {</span>
 165             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))
 166                 return &amp;downcast&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType));
 167             return nullptr;
<span class="line-modified"> 168         }, [](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::ArrayReferenceType* {</span>
 169             return nullptr;
<span class="line-modified"> 170         }), types[0].get());</span>
<span class="line-modified"> 171         bool secondArgumentIsUint = WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
 172             return matches(unnamedType, intrinsics.uintType());
<span class="line-modified"> 173         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
 174             return resolvableTypeReference-&gt;resolvableType().canResolve(intrinsics.uintType());
<span class="line-modified"> 175         }), types[1].get());</span>
 176         if (firstArgumentArrayRef &amp;&amp; secondArgumentIsUint)
<span class="line-modified"> 177             return resolveWithOperatorAnderIndexer(callExpression, *firstArgumentArrayRef, intrinsics);</span>
<span class="line-modified"> 178     } else if (callExpression.name() == &quot;operator.length&quot; &amp;&amp; types.size() == 1) {</span>
<span class="line-modified"> 179         auto* firstArgumentReference = WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
 180             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)) || is&lt;AST::ArrayType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))
<span class="line-modified"> 181                 return &amp;unnamedType;</span>
 182             return nullptr;
<span class="line-modified"> 183         }, [](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::UnnamedType* {</span>
 184             return nullptr;
<span class="line-modified"> 185         }), types[0].get());</span>
 186         if (firstArgumentReference)
<span class="line-modified"> 187             return resolveWithOperatorLength(callExpression, *firstArgumentReference, intrinsics);</span>
<span class="line-modified"> 188     } else if (callExpression.name() == &quot;operator==&quot; &amp;&amp; types.size() == 2) {</span>
<span class="line-modified"> 189         auto isAcceptable = [](ResolvingType&amp; resolvingType) -&gt; bool {</span>
<span class="line-modified"> 190             return WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
<span class="line-modified"> 191                 return is&lt;AST::ReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType));</span>
<span class="line-modified"> 192             }, [](Ref&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
<span class="line-modified"> 193                 return is&lt;AST::NullLiteralType&gt;(resolvableTypeReference-&gt;resolvableType());</span>
<span class="line-modified"> 194             }), resolvingType);</span>

 195         };
<span class="line-modified"> 196         if (isAcceptable(types[0].get()) &amp;&amp; isAcceptable(types[1].get()))</span>
<span class="line-modified"> 197             return resolveWithReferenceComparator(callExpression, types[0].get(), types[1].get(), intrinsics);</span>










 198     }
 199     return WTF::nullopt;
 200 }
 201 
 202 static bool checkSemantics(Vector&lt;EntryPointItem&gt;&amp; inputItems, Vector&lt;EntryPointItem&gt;&amp; outputItems, const Optional&lt;AST::EntryPointType&gt;&amp; entryPointType, const Intrinsics&amp; intrinsics)
 203 {
 204     {
 205         auto checkDuplicateSemantics = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 206             for (size_t i = 0; i &lt; items.size(); ++i) {
 207                 for (size_t j = i + 1; j &lt; items.size(); ++j) {
 208                     if (items[i].semantic == items[j].semantic)
 209                         return false;
 210                 }
 211             }
 212             return true;
 213         };
 214         if (!checkDuplicateSemantics(inputItems))
 215             return false;
 216         if (!checkDuplicateSemantics(outputItems))
 217             return false;
</pre>
<hr />
<pre>
 246             return true;
 247         };
 248         if (!checkSemanticForShaderType(inputItems, AST::BaseSemantic::ShaderItemDirection::Input))
 249             return false;
 250         if (!checkSemanticForShaderType(outputItems, AST::BaseSemantic::ShaderItemDirection::Output))
 251             return false;
 252     }
 253 
 254     {
 255         auto checkPODData = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 256             for (auto&amp; item : items) {
 257                 PODChecker podChecker;
 258                 if (is&lt;AST::PointerType&gt;(item.unnamedType))
 259                     podChecker.checkErrorAndVisit(downcast&lt;AST::PointerType&gt;(*item.unnamedType).elementType());
 260                 else if (is&lt;AST::ArrayReferenceType&gt;(item.unnamedType))
 261                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayReferenceType&gt;(*item.unnamedType).elementType());
 262                 else if (is&lt;AST::ArrayType&gt;(item.unnamedType))
 263                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayType&gt;(*item.unnamedType).type());
 264                 else
 265                     continue;
<span class="line-modified"> 266                 if (podChecker.error())</span>
 267                     return false;
 268             }
 269             return true;
 270         };
 271         if (!checkPODData(inputItems))
 272             return false;
 273         if (!checkPODData(outputItems))
 274             return false;
 275     }
 276 
 277     return true;
 278 }
 279 
<span class="line-modified"> 280 static bool checkOperatorOverload(const AST::FunctionDefinition&amp; functionDefinition, const Intrinsics&amp; intrinsics, NameContext&amp; nameContext)</span>
 281 {
 282     enum class CheckKind {
 283         Index,
 284         Dot
 285     };
 286 
 287     auto checkGetter = [&amp;](CheckKind kind) -&gt; bool {
 288         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;
 289         if (functionDefinition.parameters().size() != numExpectedParameters)
 290             return false;
<span class="line-modified"> 291         auto&amp; firstParameterUnifyNode = (*functionDefinition.parameters()[0].type())-&gt;unifyNode();</span>
 292         if (is&lt;AST::UnnamedType&gt;(firstParameterUnifyNode)) {
 293             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstParameterUnifyNode);
 294             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))
 295                 return false;
 296         }
 297         if (kind == CheckKind::Index) {
<span class="line-modified"> 298             auto&amp; secondParameterUnifyNode = (*functionDefinition.parameters()[1].type())-&gt;unifyNode();</span>
 299             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))
 300                 return false;
 301             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);
 302             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 303                 return false;
 304             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 305             if (!nativeTypeDeclaration.isInt())
 306                 return false;
 307         }
 308         return true;
 309     };
 310 
 311     auto checkSetter = [&amp;](CheckKind kind) -&gt; bool {
 312         size_t numExpectedParameters = kind == CheckKind::Index ? 3 : 2;
 313         if (functionDefinition.parameters().size() != numExpectedParameters)
 314             return false;
<span class="line-modified"> 315         auto&amp; firstArgumentUnifyNode = (*functionDefinition.parameters()[0].type())-&gt;unifyNode();</span>
 316         if (is&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode)) {
 317             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode);
 318             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))
 319                 return false;
 320         }
 321         if (kind == CheckKind::Index) {
<span class="line-modified"> 322             auto&amp; secondParameterUnifyNode = (*functionDefinition.parameters()[1].type())-&gt;unifyNode();</span>
 323             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))
 324                 return false;
 325             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);
 326             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 327                 return false;
 328             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 329             if (!nativeTypeDeclaration.isInt())
 330                 return false;
 331         }
<span class="line-modified"> 332         if (!matches(functionDefinition.type(), *functionDefinition.parameters()[0].type()))</span>
 333             return false;
<span class="line-modified"> 334         auto&amp; valueType = *functionDefinition.parameters()[numExpectedParameters - 1].type();</span>
 335         auto getterName = functionDefinition.name().substring(0, functionDefinition.name().length() - 1);
<span class="line-modified"> 336         auto* getterFuncs = nameContext.getFunctions(getterName);</span>
<span class="line-removed"> 337         if (!getterFuncs)</span>
<span class="line-removed"> 338             return false;</span>
 339         Vector&lt;ResolvingType&gt; argumentTypes;
 340         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; argumentTypeReferences;
 341         for (size_t i = 0; i &lt; numExpectedParameters - 1; ++i)
<span class="line-modified"> 342             argumentTypes.append((*functionDefinition.parameters()[0].type())-&gt;clone());</span>
 343         for (auto&amp; argumentType : argumentTypes)
 344             argumentTypeReferences.append(argumentType);
<span class="line-modified"> 345         Optional&lt;std::reference_wrapper&lt;AST::NamedType&gt;&gt; castReturnType;</span>
<span class="line-removed"> 346         auto* overload = resolveFunctionOverloadImpl(*getterFuncs, argumentTypeReferences, castReturnType);</span>
 347         if (!overload)
 348             return false;
 349         auto&amp; resultType = overload-&gt;type();
 350         return matches(resultType, valueType);
 351     };
 352 
 353     auto checkAnder = [&amp;](CheckKind kind) -&gt; bool {
 354         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;
 355         if (functionDefinition.parameters().size() != numExpectedParameters)
 356             return false;
 357         {
 358             auto&amp; unifyNode = functionDefinition.type().unifyNode();
 359             if (!is&lt;AST::UnnamedType&gt;(unifyNode))
 360                 return false;
 361             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 362             if (!is&lt;AST::PointerType&gt;(unnamedType))
 363                 return false;
 364         }
 365         {
<span class="line-modified"> 366             auto&amp; unifyNode = (*functionDefinition.parameters()[0].type())-&gt;unifyNode();</span>
 367             if (!is&lt;AST::UnnamedType&gt;(unifyNode))
 368                 return false;
 369             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 370             return is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType);
 371         }
 372     };
 373 
 374     if (!functionDefinition.isOperator())
 375         return true;
 376     if (functionDefinition.isCast())
 377         return true;
 378     if (functionDefinition.name() == &quot;operator++&quot; || functionDefinition.name() == &quot;operator--&quot;) {
 379         return functionDefinition.parameters().size() == 1
<span class="line-modified"> 380             &amp;&amp; matches(*functionDefinition.parameters()[0].type(), functionDefinition.type());</span>
 381     }
 382     if (functionDefinition.name() == &quot;operator+&quot; || functionDefinition.name() == &quot;operator-&quot;)
 383         return functionDefinition.parameters().size() == 1 || functionDefinition.parameters().size() == 2;
 384     if (functionDefinition.name() == &quot;operator*&quot;
 385         || functionDefinition.name() == &quot;operator/&quot;
 386         || functionDefinition.name() == &quot;operator%&quot;
 387         || functionDefinition.name() == &quot;operator&amp;&quot;
 388         || functionDefinition.name() == &quot;operator|&quot;
 389         || functionDefinition.name() == &quot;operator^&quot;
 390         || functionDefinition.name() == &quot;operator&lt;&lt;&quot;
<span class="line-modified"> 391         || functionDefinition.name() == &quot;opreator&gt;&gt;&quot;)</span>
 392         return functionDefinition.parameters().size() == 2;
 393     if (functionDefinition.name() == &quot;operator~&quot;)
 394         return functionDefinition.parameters().size() == 1;
<span class="line-removed"> 395     if (functionDefinition.name() == &quot;operator==&quot;</span>
<span class="line-removed"> 396         || functionDefinition.name() == &quot;operator&lt;&quot;</span>
<span class="line-removed"> 397         || functionDefinition.name() == &quot;operator&lt;=&quot;</span>
<span class="line-removed"> 398         || functionDefinition.name() == &quot;operator&gt;&quot;</span>
<span class="line-removed"> 399         || functionDefinition.name() == &quot;operator&gt;=&quot;) {</span>
<span class="line-removed"> 400         return functionDefinition.parameters().size() == 2</span>
<span class="line-removed"> 401             &amp;&amp; matches(functionDefinition.type(), intrinsics.boolType());</span>
<span class="line-removed"> 402     }</span>
 403     if (functionDefinition.name() == &quot;operator[]&quot;)
 404         return checkGetter(CheckKind::Index);
 405     if (functionDefinition.name() == &quot;operator[]=&quot;)
 406         return checkSetter(CheckKind::Index);
 407     if (functionDefinition.name() == &quot;operator&amp;[]&quot;)
 408         return checkAnder(CheckKind::Index);
 409     if (functionDefinition.name().startsWith(&quot;operator.&quot;)) {
 410         if (functionDefinition.name().endsWith(&quot;=&quot;))
 411             return checkSetter(CheckKind::Dot);
 412         return checkGetter(CheckKind::Dot);
 413     }
 414     if (functionDefinition.name().startsWith(&quot;operator&amp;.&quot;))
 415         return checkAnder(CheckKind::Dot);
 416     return false;
 417 }
 418 
 419 class Checker : public Visitor {
 420 public:
 421     Checker(const Intrinsics&amp; intrinsics, Program&amp; program)
 422         : m_intrinsics(intrinsics)
 423         , m_program(program)
 424     {



















 425     }
 426 
<span class="line-modified"> 427     ~Checker() = default;</span>
 428 
 429     void visit(Program&amp;) override;
 430 
<span class="line-modified"> 431     bool assignTypes();</span>
 432 
 433 private:
 434     bool checkShaderType(const AST::FunctionDefinition&amp;);
<span class="line-removed"> 435     void finishVisitingPropertyAccess(AST::PropertyAccessExpression&amp;, AST::UnnamedType&amp; wrappedBaseType, AST::UnnamedType* extraArgumentType = nullptr);</span>
 436     bool isBoolType(ResolvingType&amp;);
 437     struct RecurseInfo {
 438         ResolvingType&amp; resolvingType;
<span class="line-modified"> 439         Optional&lt;AST::AddressSpace&gt;&amp; addressSpace;</span>
 440     };
<span class="line-modified"> 441     Optional&lt;RecurseInfo&gt; recurseAndGetInfo(AST::Expression&amp;, bool requiresLValue = false);</span>
<span class="line-modified"> 442     Optional&lt;RecurseInfo&gt; getInfo(AST::Expression&amp;, bool requiresLValue = false);</span>
<span class="line-modified"> 443     Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; recurseAndWrapBaseType(AST::PropertyAccessExpression&amp;);</span>
 444     bool recurseAndRequireBoolType(AST::Expression&amp;);
<span class="line-modified"> 445     void assignType(AST::Expression&amp;, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp;, Optional&lt;AST::AddressSpace&gt; = WTF::nullopt);</span>
<span class="line-modified"> 446     void assignType(AST::Expression&amp;, Ref&lt;ResolvableTypeReference&gt;&amp;&amp;, Optional&lt;AST::AddressSpace&gt; = WTF::nullopt);</span>
<span class="line-modified"> 447     void forwardType(AST::Expression&amp;, ResolvingType&amp;, Optional&lt;AST::AddressSpace&gt; = WTF::nullopt);</span>
 448 
 449     void visit(AST::FunctionDefinition&amp;) override;
 450     void visit(AST::EnumerationDefinition&amp;) override;
 451     void visit(AST::TypeReference&amp;) override;
 452     void visit(AST::VariableDeclaration&amp;) override;
 453     void visit(AST::AssignmentExpression&amp;) override;
 454     void visit(AST::ReadModifyWriteExpression&amp;) override;
 455     void visit(AST::DereferenceExpression&amp;) override;
 456     void visit(AST::MakePointerExpression&amp;) override;
 457     void visit(AST::MakeArrayReferenceExpression&amp;) override;
 458     void visit(AST::DotExpression&amp;) override;
 459     void visit(AST::IndexExpression&amp;) override;
 460     void visit(AST::VariableReference&amp;) override;
 461     void visit(AST::Return&amp;) override;
 462     void visit(AST::PointerType&amp;) override;
 463     void visit(AST::ArrayReferenceType&amp;) override;
 464     void visit(AST::IntegerLiteral&amp;) override;
 465     void visit(AST::UnsignedIntegerLiteral&amp;) override;
 466     void visit(AST::FloatLiteral&amp;) override;
 467     void visit(AST::NullLiteral&amp;) override;
 468     void visit(AST::BooleanLiteral&amp;) override;
 469     void visit(AST::EnumerationMemberLiteral&amp;) override;
 470     void visit(AST::LogicalNotExpression&amp;) override;
 471     void visit(AST::LogicalExpression&amp;) override;
 472     void visit(AST::IfStatement&amp;) override;
 473     void visit(AST::WhileLoop&amp;) override;
 474     void visit(AST::DoWhileLoop&amp;) override;
 475     void visit(AST::ForLoop&amp;) override;
 476     void visit(AST::SwitchStatement&amp;) override;
 477     void visit(AST::CommaExpression&amp;) override;
 478     void visit(AST::TernaryExpression&amp;) override;
 479     void visit(AST::CallExpression&amp;) override;
 480 
<span class="line-modified"> 481     HashMap&lt;AST::Expression*, ResolvingType&gt; m_typeMap;</span>
<span class="line-modified"> 482     HashMap&lt;AST::Expression*, Optional&lt;AST::AddressSpace&gt;&gt; m_addressSpaceMap;</span>
<span class="line-modified"> 483     HashSet&lt;String&gt; m_vertexEntryPoints;</span>
<span class="line-modified"> 484     HashSet&lt;String&gt; m_fragmentEntryPoints;</span>
<span class="line-modified"> 485     HashSet&lt;String&gt; m_computeEntryPoints;</span>

































 486     const Intrinsics&amp; m_intrinsics;
 487     Program&amp; m_program;




 488 };
 489 
 490 void Checker::visit(Program&amp; program)
 491 {
 492     // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
 493     for (size_t i = 0; i &lt; program.typeDefinitions().size(); ++i)
 494         checkErrorAndVisit(program.typeDefinitions()[i]);
 495     for (size_t i = 0; i &lt; program.structureDefinitions().size(); ++i)
 496         checkErrorAndVisit(program.structureDefinitions()[i]);
 497     for (size_t i = 0; i &lt; program.enumerationDefinitions().size(); ++i)
 498         checkErrorAndVisit(program.enumerationDefinitions()[i]);
 499     for (size_t i = 0; i &lt; program.nativeTypeDeclarations().size(); ++i)
 500         checkErrorAndVisit(program.nativeTypeDeclarations()[i]);
 501 
 502     for (size_t i = 0; i &lt; program.functionDefinitions().size(); ++i)
 503         checkErrorAndVisit(program.functionDefinitions()[i]);
 504     for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
 505         checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
 506 }
 507 
<span class="line-modified"> 508 bool Checker::assignTypes()</span>
 509 {
 510     for (auto&amp; keyValuePair : m_typeMap) {
<span class="line-modified"> 511         auto success = WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
<span class="line-modified"> 512             keyValuePair.key-&gt;setType(unnamedType-&gt;clone());</span>
 513             return true;
<span class="line-modified"> 514         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
<span class="line-modified"> 515             if (!resolvableTypeReference-&gt;resolvableType().resolvedType()) {</span>
<span class="line-removed"> 516                 // FIXME: Instead of trying to commit, it might be better to just return an error instead.</span>
 517                 if (!static_cast&lt;bool&gt;(commit(resolvableTypeReference-&gt;resolvableType())))
 518                     return false;
 519             }
<span class="line-modified"> 520             keyValuePair.key-&gt;setType(resolvableTypeReference-&gt;resolvableType().resolvedType()-&gt;clone());</span>
 521             return true;
<span class="line-modified"> 522         }), keyValuePair.value);</span>
 523         if (!success)
<span class="line-modified"> 524             return false;</span>
 525     }
 526 
<span class="line-modified"> 527     for (auto&amp; keyValuePair : m_addressSpaceMap)</span>
<span class="line-removed"> 528         keyValuePair.key-&gt;setAddressSpace(keyValuePair.value);</span>
<span class="line-removed"> 529     return true;</span>
 530 }
 531 
 532 bool Checker::checkShaderType(const AST::FunctionDefinition&amp; functionDefinition)
 533 {

 534     switch (*functionDefinition.entryPointType()) {
 535     case AST::EntryPointType::Vertex:
<span class="line-modified"> 536         return !m_vertexEntryPoints.add(functionDefinition.name()).isNewEntry;</span>
 537     case AST::EntryPointType::Fragment:
<span class="line-modified"> 538         return !m_fragmentEntryPoints.add(functionDefinition.name()).isNewEntry;</span>
 539     case AST::EntryPointType::Compute:
<span class="line-modified"> 540         return !m_computeEntryPoints.add(functionDefinition.name()).isNewEntry;</span>
 541     }
 542 }
 543 
 544 void Checker::visit(AST::FunctionDefinition&amp; functionDefinition)
 545 {


 546     if (functionDefinition.entryPointType()) {
 547         if (!checkShaderType(functionDefinition)) {
<span class="line-modified"> 548             setError();</span>
 549             return;
 550         }
 551         auto entryPointItems = gatherEntryPointItems(m_intrinsics, functionDefinition);
 552         if (!entryPointItems) {
<span class="line-modified"> 553             setError();</span>
 554             return;
 555         }
 556         if (!checkSemantics(entryPointItems-&gt;inputs, entryPointItems-&gt;outputs, functionDefinition.entryPointType(), m_intrinsics)) {
<span class="line-modified"> 557             setError();</span>
 558             return;
 559         }
 560     }
<span class="line-modified"> 561     if (!checkOperatorOverload(functionDefinition, m_intrinsics, m_program.nameContext())) {</span>
<span class="line-modified"> 562         setError();</span>
 563         return;
 564     }
 565 
<span class="line-modified"> 566     checkErrorAndVisit(functionDefinition);</span>
 567 }
 568 
<span class="line-modified"> 569 static Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; matchAndCommit(ResolvingType&amp; left, ResolvingType&amp; right)</span>
 570 {
<span class="line-modified"> 571     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; left) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
<span class="line-modified"> 572         return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
 573             if (matches(left, right))
<span class="line-modified"> 574                 return left-&gt;clone();</span>
<span class="line-modified"> 575             return WTF::nullopt;</span>
<span class="line-modified"> 576         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
 577             return matchAndCommit(left, right-&gt;resolvableType());
<span class="line-modified"> 578         }), right);</span>
<span class="line-modified"> 579     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; left) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
<span class="line-modified"> 580         return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
 581             return matchAndCommit(right, left-&gt;resolvableType());
<span class="line-modified"> 582         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
 583             return matchAndCommit(left-&gt;resolvableType(), right-&gt;resolvableType());
<span class="line-modified"> 584         }), right);</span>
<span class="line-modified"> 585     }), left);</span>
 586 }
 587 
<span class="line-modified"> 588 static Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::UnnamedType&amp; unnamedType)</span>
 589 {
<span class="line-modified"> 590     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
 591         if (matches(unnamedType, resolvingType))
<span class="line-modified"> 592             return unnamedType.clone();</span>
<span class="line-modified"> 593         return WTF::nullopt;</span>
<span class="line-modified"> 594     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
 595         return matchAndCommit(unnamedType, resolvingType-&gt;resolvableType());
<span class="line-modified"> 596     }), resolvingType);</span>
 597 }
 598 
<span class="line-modified"> 599 static Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::NamedType&amp; namedType)</span>
 600 {
<span class="line-modified"> 601     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
<span class="line-modified"> 602         if (matches(resolvingType, namedType))</span>
<span class="line-modified"> 603             return resolvingType-&gt;clone();</span>
<span class="line-modified"> 604         return WTF::nullopt;</span>
<span class="line-modified"> 605     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
<span class="line-modified"> 606         return matchAndCommit(namedType, resolvingType-&gt;resolvableType());</span>
<span class="line-modified"> 607     }), resolvingType);</span>















































 608 }
 609 
 610 void Checker::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
 611 {

 612     auto* baseType = ([&amp;]() -&gt; AST::NativeTypeDeclaration* {
 613         checkErrorAndVisit(enumerationDefinition.type());
 614         auto&amp; baseType = enumerationDefinition.type().unifyNode();
 615         if (!is&lt;AST::NamedType&gt;(baseType))
 616             return nullptr;
 617         auto&amp; namedType = downcast&lt;AST::NamedType&gt;(baseType);
 618         if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 619             return nullptr;
 620         auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 621         if (!nativeTypeDeclaration.isInt())
 622             return nullptr;

 623         return &amp;nativeTypeDeclaration;
 624     })();
 625     if (!baseType) {
<span class="line-modified"> 626         setError();</span>
 627         return;
 628     }
 629 
 630     auto enumerationMembers = enumerationDefinition.enumerationMembers();
 631 
 632     for (auto&amp; member : enumerationMembers) {
<span class="line-modified"> 633         if (!member.get().value())</span>
<span class="line-modified"> 634             continue;</span>
<span class="line-modified"> 635 </span>
<span class="line-modified"> 636         bool success = false;</span>
<span class="line-removed"> 637         member.get().value()-&gt;visit(WTF::makeVisitor([&amp;](AST::Expression&amp; value) {</span>
<span class="line-removed"> 638             auto valueInfo = recurseAndGetInfo(value);</span>
<span class="line-removed"> 639             if (!valueInfo)</span>
 640                 return;
<span class="line-modified"> 641             success = static_cast&lt;bool&gt;(matchAndCommit(valueInfo-&gt;resolvingType, *baseType));</span>
<span class="line-removed"> 642         }));</span>
<span class="line-removed"> 643         if (!success) {</span>
<span class="line-removed"> 644             setError();</span>
<span class="line-removed"> 645             return;</span>
<span class="line-removed"> 646         }</span>
<span class="line-removed"> 647     }</span>
<span class="line-removed"> 648 </span>
<span class="line-removed"> 649     int64_t nextValue = 0;</span>
<span class="line-removed"> 650     for (auto&amp; member : enumerationMembers) {</span>
<span class="line-removed"> 651         if (member.get().value()) {</span>
<span class="line-removed"> 652             int64_t value;</span>
<span class="line-removed"> 653             member.get().value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-removed"> 654                 value = integerLiteral.valueForSelectedType();</span>
<span class="line-removed"> 655             }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-removed"> 656                 value = unsignedIntegerLiteral.valueForSelectedType();</span>
<span class="line-removed"> 657             }, [&amp;](auto&amp;) {</span>
<span class="line-removed"> 658                 ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 659             }));</span>
<span class="line-removed"> 660             nextValue = baseType-&gt;successor()(value);</span>
 661         } else {
<span class="line-modified"> 662             if (nextValue &gt; std::numeric_limits&lt;int&gt;::max()) {</span>
<span class="line-modified"> 663                 ASSERT(nextValue &lt;= std::numeric_limits&lt;unsigned&gt;::max());</span>
<span class="line-modified"> 664                 member.get().setValue(AST::ConstantExpression(AST::UnsignedIntegerLiteral(Lexer::Token(member.get().origin()), static_cast&lt;unsigned&gt;(nextValue))));</span>
 665             }
<span class="line-removed"> 666             ASSERT(nextValue &gt;= std::numeric_limits&lt;int&gt;::min());</span>
<span class="line-removed"> 667             member.get().setValue(AST::ConstantExpression(AST::IntegerLiteral(Lexer::Token(member.get().origin()), static_cast&lt;int&gt;(nextValue))));</span>
<span class="line-removed"> 668             nextValue = baseType-&gt;successor()(nextValue);</span>
 669         }
 670     }
 671 
<span class="line-removed"> 672     auto getValue = [&amp;](AST::EnumerationMember&amp; member) -&gt; int64_t {</span>
<span class="line-removed"> 673         int64_t value;</span>
<span class="line-removed"> 674         ASSERT(member.value());</span>
<span class="line-removed"> 675         member.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-removed"> 676             value = integerLiteral.value();</span>
<span class="line-removed"> 677         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-removed"> 678             value = unsignedIntegerLiteral.value();</span>
<span class="line-removed"> 679         }, [&amp;](auto&amp;) {</span>
<span class="line-removed"> 680             ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 681         }));</span>
<span class="line-removed"> 682         return value;</span>
<span class="line-removed"> 683     };</span>
<span class="line-removed"> 684 </span>
 685     for (size_t i = 0; i &lt; enumerationMembers.size(); ++i) {
<span class="line-modified"> 686         auto value = getValue(enumerationMembers[i].get());</span>
 687         for (size_t j = i + 1; j &lt; enumerationMembers.size(); ++j) {
<span class="line-modified"> 688             auto otherValue = getValue(enumerationMembers[j].get());</span>
 689             if (value == otherValue) {
<span class="line-modified"> 690                 setError();</span>
 691                 return;
 692             }
 693         }
 694     }
 695 
 696     bool foundZero = false;
 697     for (auto&amp; member : enumerationMembers) {
<span class="line-modified"> 698         if (!getValue(member.get())) {</span>
 699             foundZero = true;
 700             break;
 701         }
 702     }
 703     if (!foundZero) {
<span class="line-modified"> 704         setError();</span>
 705         return;
 706     }
 707 }
 708 
 709 void Checker::visit(AST::TypeReference&amp; typeReference)
 710 {
<span class="line-modified"> 711     ASSERT(typeReference.resolvedType());</span>
 712 
<span class="line-modified"> 713     checkErrorAndVisit(typeReference);</span>

 714 }
 715 
<span class="line-modified"> 716 auto Checker::recurseAndGetInfo(AST::Expression&amp; expression, bool requiresLValue) -&gt; Optional&lt;RecurseInfo&gt;</span>
 717 {
<span class="line-modified"> 718     checkErrorAndVisit(expression);</span>
<span class="line-modified"> 719     if (!error())</span>
 720         return WTF::nullopt;
<span class="line-modified"> 721     return getInfo(expression, requiresLValue);</span>
 722 }
 723 
<span class="line-modified"> 724 auto Checker::getInfo(AST::Expression&amp; expression, bool requiresLValue) -&gt; Optional&lt;RecurseInfo&gt;</span>
 725 {
 726     auto typeIterator = m_typeMap.find(&amp;expression);
 727     ASSERT(typeIterator != m_typeMap.end());
 728 
<span class="line-modified"> 729     auto addressSpaceIterator = m_addressSpaceMap.find(&amp;expression);</span>
<span class="line-modified"> 730     ASSERT(addressSpaceIterator != m_addressSpaceMap.end());</span>
<span class="line-modified"> 731     if (requiresLValue &amp;&amp; !addressSpaceIterator-&gt;value) {</span>
<span class="line-removed"> 732         setError();</span>
 733         return WTF::nullopt;
 734     }
<span class="line-modified"> 735     return {{ typeIterator-&gt;value, addressSpaceIterator-&gt;value }};</span>
 736 }
 737 
 738 void Checker::visit(AST::VariableDeclaration&amp; variableDeclaration)
 739 {
 740     // ReadModifyWriteExpressions are the only place where anonymous variables exist,
 741     // and that doesn&#39;t recurse on the anonymous variables, so we can assume the variable has a type.
 742     checkErrorAndVisit(*variableDeclaration.type());




 743     if (variableDeclaration.initializer()) {
 744         auto&amp; lhsType = *variableDeclaration.type();
 745         auto initializerInfo = recurseAndGetInfo(*variableDeclaration.initializer());
 746         if (!initializerInfo)
 747             return;
 748         if (!matchAndCommit(initializerInfo-&gt;resolvingType, lhsType)) {
<span class="line-modified"> 749             setError();</span>
 750             return;
 751         }
 752     }
 753 }
 754 
<span class="line-modified"> 755 void Checker::assignType(AST::Expression&amp; expression, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; unnamedType, Optional&lt;AST::AddressSpace&gt; addressSpace)</span>
 756 {
<span class="line-modified"> 757     auto addResult = m_typeMap.add(&amp;expression, WTFMove(unnamedType));</span>
 758     ASSERT_UNUSED(addResult, addResult.isNewEntry);
<span class="line-modified"> 759     auto addressSpaceAddResult = m_addressSpaceMap.add(&amp;expression, addressSpace);</span>
<span class="line-removed"> 760     ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);</span>
 761 }
 762 
<span class="line-modified"> 763 void Checker::assignType(AST::Expression&amp; expression, Ref&lt;ResolvableTypeReference&gt;&amp;&amp; resolvableTypeReference, Optional&lt;AST::AddressSpace&gt; addressSpace)</span>
 764 {
<span class="line-modified"> 765     auto addResult = m_typeMap.add(&amp;expression, WTFMove(resolvableTypeReference));</span>
 766     ASSERT_UNUSED(addResult, addResult.isNewEntry);
<span class="line-modified"> 767     auto addressSpaceAddResult = m_addressSpaceMap.add(&amp;expression, addressSpace);</span>
<span class="line-modified"> 768     ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);</span>











 769 }
 770 
 771 void Checker::visit(AST::AssignmentExpression&amp; assignmentExpression)
 772 {
 773     auto leftInfo = recurseAndGetInfo(assignmentExpression.left(), true);
 774     if (!leftInfo)
 775         return;
 776 
 777     auto rightInfo = recurseAndGetInfo(assignmentExpression.right());
 778     if (!rightInfo)
 779         return;
 780 
 781     auto resultType = matchAndCommit(leftInfo-&gt;resolvingType, rightInfo-&gt;resolvingType);
 782     if (!resultType) {
<span class="line-modified"> 783         setError();</span>
 784         return;
 785     }
 786 
<span class="line-modified"> 787     assignType(assignmentExpression, WTFMove(*resultType));</span>
<span class="line-removed"> 788 }</span>
<span class="line-removed"> 789 </span>
<span class="line-removed"> 790 void Checker::forwardType(AST::Expression&amp; expression, ResolvingType&amp; resolvingType, Optional&lt;AST::AddressSpace&gt; addressSpace)</span>
<span class="line-removed"> 791 {</span>
<span class="line-removed"> 792     WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; result) {</span>
<span class="line-removed"> 793         auto addResult = m_typeMap.add(&amp;expression, result-&gt;clone());</span>
<span class="line-removed"> 794         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-removed"> 795     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; result) {</span>
<span class="line-removed"> 796         auto addResult = m_typeMap.add(&amp;expression, result.copyRef());</span>
<span class="line-removed"> 797         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-removed"> 798     }), resolvingType);</span>
<span class="line-removed"> 799     auto addressSpaceAddResult = m_addressSpaceMap.add(&amp;expression, addressSpace);</span>
<span class="line-removed"> 800     ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);</span>
 801 }
 802 
 803 void Checker::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)
 804 {
<span class="line-modified"> 805     auto lValueInfo = recurseAndGetInfo(readModifyWriteExpression.lValue(), true);</span>
<span class="line-modified"> 806     if (!lValueInfo)</span>
 807         return;
 808 
<span class="line-modified"> 809     // FIXME: Figure out what to do with the ReadModifyWriteExpression&#39;s AnonymousVariables.</span>
 810 
<span class="line-modified"> 811     auto newValueInfo = recurseAndGetInfo(*readModifyWriteExpression.newValueExpression());</span>
 812     if (!newValueInfo)
 813         return;
 814 
<span class="line-modified"> 815     if (!matchAndCommit(lValueInfo-&gt;resolvingType, newValueInfo-&gt;resolvingType)) {</span>
<span class="line-modified"> 816         setError();</span>


 817         return;
 818     }
 819 
<span class="line-modified"> 820     auto resultInfo = recurseAndGetInfo(*readModifyWriteExpression.resultExpression());</span>
 821     if (!resultInfo)
 822         return;
 823 
 824     forwardType(readModifyWriteExpression, resultInfo-&gt;resolvingType);
 825 }
 826 
 827 static AST::UnnamedType* getUnnamedType(ResolvingType&amp; resolvingType)
 828 {
<span class="line-modified"> 829     return WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; type) -&gt; AST::UnnamedType* {</span>
<span class="line-modified"> 830         return &amp;type;</span>
<span class="line-modified"> 831     }, [](Ref&lt;ResolvableTypeReference&gt;&amp; type) -&gt; AST::UnnamedType* {</span>
 832         // FIXME: If the type isn&#39;t committed, should we just commit() it now?
<span class="line-modified"> 833         return type-&gt;resolvableType().resolvedType();</span>
<span class="line-modified"> 834     }), resolvingType);</span>
 835 }
 836 
 837 void Checker::visit(AST::DereferenceExpression&amp; dereferenceExpression)
 838 {
 839     auto pointerInfo = recurseAndGetInfo(dereferenceExpression.pointer());
 840     if (!pointerInfo)
 841         return;
 842 
 843     auto* unnamedType = getUnnamedType(pointerInfo-&gt;resolvingType);
 844 
 845     auto* pointerType = ([&amp;](AST::UnnamedType* unnamedType) -&gt; AST::PointerType* {
 846         if (!unnamedType)
 847             return nullptr;
 848         auto&amp; unifyNode = unnamedType-&gt;unifyNode();
 849         if (!is&lt;AST::UnnamedType&gt;(unifyNode))
 850             return nullptr;
 851         auto&amp; unnamedUnifyType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 852         if (!is&lt;AST::PointerType&gt;(unnamedUnifyType))
 853             return nullptr;
 854         return &amp;downcast&lt;AST::PointerType&gt;(unnamedUnifyType);
 855     })(unnamedType);
 856     if (!pointerType) {
<span class="line-modified"> 857         setError();</span>
 858         return;
 859     }
 860 
<span class="line-modified"> 861     assignType(dereferenceExpression, pointerType-&gt;clone(), pointerType-&gt;addressSpace());</span>
 862 }
 863 
 864 void Checker::visit(AST::MakePointerExpression&amp; makePointerExpression)
 865 {
<span class="line-modified"> 866     auto lValueInfo = recurseAndGetInfo(makePointerExpression.lValue(), true);</span>
<span class="line-modified"> 867     if (!lValueInfo)</span>
 868         return;
 869 
<span class="line-modified"> 870     auto* lValueType = getUnnamedType(lValueInfo-&gt;resolvingType);</span>
<span class="line-modified"> 871     if (!lValueType) {</span>
<span class="line-modified"> 872         setError();</span>
 873         return;
 874     }
 875 
<span class="line-modified"> 876     assignType(makePointerExpression, makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(makePointerExpression.origin()), *lValueInfo-&gt;addressSpace, lValueType-&gt;clone()));</span>






 877 }
 878 
 879 void Checker::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
 880 {
<span class="line-modified"> 881     auto lValueInfo = recurseAndGetInfo(makeArrayReferenceExpression.lValue());</span>
<span class="line-modified"> 882     if (!lValueInfo)</span>
 883         return;
 884 
<span class="line-modified"> 885     auto* lValueType = getUnnamedType(lValueInfo-&gt;resolvingType);</span>
<span class="line-modified"> 886     if (!lValueType) {</span>
<span class="line-modified"> 887         setError();</span>
 888         return;
 889     }
 890 
<span class="line-modified"> 891     auto&amp; unifyNode = lValueType-&gt;unifyNode();</span>
 892     if (is&lt;AST::UnnamedType&gt;(unifyNode)) {
 893         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 894         if (is&lt;AST::PointerType&gt;(unnamedType)) {
 895             auto&amp; pointerType = downcast&lt;AST::PointerType&gt;(unnamedType);
<span class="line-modified"> 896             // FIXME: Save the fact that we&#39;re not targetting the item; we&#39;re targetting the item&#39;s inner element.</span>
<span class="line-modified"> 897             assignType(makeArrayReferenceExpression, makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(makeArrayReferenceExpression.origin()), pointerType.addressSpace(), pointerType.elementType().clone()));</span>
 898             return;
 899         }
 900 
<span class="line-modified"> 901         if (!lValueInfo-&gt;addressSpace) {</span>
<span class="line-modified"> 902             setError();</span>

 903             return;
 904         }
 905 
 906         if (is&lt;AST::ArrayType&gt;(unnamedType)) {
 907             auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(unnamedType);
<span class="line-modified"> 908             // FIXME: Save the number of elements.</span>
<span class="line-modified"> 909             assignType(makeArrayReferenceExpression, makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(makeArrayReferenceExpression.origin()), *lValueInfo-&gt;addressSpace, arrayType.type().clone()));</span>
 910             return;
 911         }
 912     }
 913 
<span class="line-modified"> 914     if (!lValueInfo-&gt;addressSpace) {</span>
<span class="line-modified"> 915         setError();</span>

 916         return;
 917     }
 918 
<span class="line-modified"> 919     assignType(makeArrayReferenceExpression, makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(makeArrayReferenceExpression.origin()), *lValueInfo-&gt;addressSpace, lValueType-&gt;clone()));</span>
 920 }
 921 
<span class="line-modified"> 922 void Checker::finishVisitingPropertyAccess(AST::PropertyAccessExpression&amp; propertyAccessExpression, AST::UnnamedType&amp; wrappedBaseType, AST::UnnamedType* extraArgumentType)</span>
 923 {
<span class="line-modified"> 924     Optional&lt;std::reference_wrapper&lt;AST::NamedType&gt;&gt; castReturnType;</span>
<span class="line-modified"> 925     using OverloadResolution = std::tuple&lt;AST::FunctionDeclaration*, AST::UnnamedType*&gt;;</span>
<span class="line-modified"> 926 </span>
<span class="line-modified"> 927     AST::FunctionDeclaration* getFunction;</span>
<span class="line-modified"> 928     AST::UnnamedType* getReturnType;</span>
<span class="line-modified"> 929     std::tie(getFunction, getReturnType) = ([&amp;]() -&gt; OverloadResolution {</span>
<span class="line-removed"> 930         ResolvingType getArgumentType1(wrappedBaseType.clone());</span>
<span class="line-removed"> 931         Optional&lt;ResolvingType&gt; getArgumentType2;</span>
<span class="line-removed"> 932         if (extraArgumentType)</span>
<span class="line-removed"> 933             getArgumentType2 = ResolvingType(extraArgumentType-&gt;clone());</span>
<span class="line-removed"> 934 </span>
<span class="line-removed"> 935         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; getArgumentTypes;</span>
<span class="line-removed"> 936         getArgumentTypes.append(getArgumentType1);</span>
<span class="line-removed"> 937         if (getArgumentType2)</span>
<span class="line-removed"> 938             getArgumentTypes.append(*getArgumentType2);</span>
<span class="line-removed"> 939 </span>
<span class="line-removed"> 940         auto* getFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleGetOverloads(), getArgumentTypes, castReturnType);</span>
<span class="line-removed"> 941         if (!getFunction)</span>
<span class="line-removed"> 942             return std::make_pair(nullptr, nullptr);</span>
<span class="line-removed"> 943         return std::make_pair(getFunction, &amp;getFunction-&gt;type());</span>
<span class="line-removed"> 944     })();</span>
 945 
<span class="line-modified"> 946     AST::FunctionDeclaration* andFunction;</span>
<span class="line-modified"> 947     AST::UnnamedType* andReturnType;</span>
<span class="line-modified"> 948     std::tie(andFunction, andReturnType) = ([&amp;]() -&gt; OverloadResolution {</span>
<span class="line-modified"> 949         auto computeAndArgumentType = [&amp;](AST::UnnamedType&amp; unnamedType) -&gt; Optional&lt;ResolvingType&gt; {</span>
<span class="line-modified"> 950             if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))</span>
<span class="line-modified"> 951                 return { unnamedType.clone() };</span>
<span class="line-modified"> 952             if (is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="line-modified"> 953                 return { makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(propertyAccessExpression.origin()), AST::AddressSpace::Thread, downcast&lt;AST::ArrayType&gt;(unnamedType).type().clone()) };</span>
<span class="line-modified"> 954             if (is&lt;AST::PointerType&gt;(unnamedType))</span>
<span class="line-modified"> 955                 return WTF::nullopt;</span>
<span class="line-modified"> 956             return { makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(propertyAccessExpression.origin()), AST::AddressSpace::Thread, downcast&lt;AST::ArrayType&gt;(unnamedType).type().clone()) };</span>
<span class="line-modified"> 957         };</span>
<span class="line-modified"> 958         auto computeAndReturnType = [&amp;](AST::UnnamedType&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
<span class="line-modified"> 959             if (is&lt;AST::PointerType&gt;(unnamedType))</span>
<span class="line-modified"> 960                 return &amp;downcast&lt;AST::PointerType&gt;(unnamedType).elementType();</span>

 961             return nullptr;
<span class="line-removed"> 962         };</span>
 963 
<span class="line-modified"> 964         auto andArgumentType1 = computeAndArgumentType(wrappedBaseType);</span>
<span class="line-modified"> 965         if (!andArgumentType1)</span>
<span class="line-removed"> 966             return std::make_pair(nullptr, nullptr);</span>
<span class="line-removed"> 967         Optional&lt;ResolvingType&gt; andArgumentType2;</span>
<span class="line-removed"> 968         if (extraArgumentType)</span>
<span class="line-removed"> 969             andArgumentType2 = ResolvingType(extraArgumentType-&gt;clone());</span>
<span class="line-removed"> 970 </span>
<span class="line-removed"> 971         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; andArgumentTypes;</span>
<span class="line-removed"> 972         andArgumentTypes.append(*andArgumentType1);</span>
<span class="line-removed"> 973         if (andArgumentType2)</span>
<span class="line-removed"> 974             andArgumentTypes.append(*andArgumentType2);</span>
<span class="line-removed"> 975 </span>
<span class="line-removed"> 976         auto* andFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleAndOverloads(), andArgumentTypes, castReturnType);</span>
<span class="line-removed"> 977         if (!andFunction)</span>
<span class="line-removed"> 978             return std::make_pair(nullptr, nullptr);</span>
<span class="line-removed"> 979         return std::make_pair(andFunction, computeAndReturnType(andFunction-&gt;type()));</span>
<span class="line-removed"> 980     })();</span>
 981 
<span class="line-modified"> 982     if (!getReturnType &amp;&amp; !andReturnType) {</span>
<span class="line-modified"> 983         setError();</span>
<span class="line-modified"> 984         return;</span>
<span class="line-modified"> 985     }</span>
 986 
<span class="line-modified"> 987     if (getReturnType &amp;&amp; andReturnType &amp;&amp; !matches(*getReturnType, *andReturnType)) {</span>
<span class="line-modified"> 988         setError();</span>






 989         return;
 990     }
 991 
<span class="line-modified"> 992     AST::FunctionDeclaration* setFunction;</span>
<span class="line-modified"> 993     AST::UnnamedType* setReturnType;</span>
<span class="line-modified"> 994     std::tie(setFunction, setReturnType) = ([&amp;]() -&gt; OverloadResolution {</span>
<span class="line-modified"> 995         ResolvingType setArgument1Type(wrappedBaseType.clone());</span>
<span class="line-modified"> 996         Optional&lt;ResolvingType&gt; setArgumentType2;</span>
<span class="line-modified"> 997         if (extraArgumentType)</span>
<span class="line-modified"> 998             setArgumentType2 = ResolvingType(extraArgumentType-&gt;clone());</span>
<span class="line-modified"> 999         ResolvingType setArgument3Type(getReturnType ? getReturnType-&gt;clone() : andReturnType-&gt;clone());</span>
<span class="line-modified">1000 </span>
<span class="line-removed">1001         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; setArgumentTypes;</span>
<span class="line-removed">1002         setArgumentTypes.append(setArgument1Type);</span>
<span class="line-removed">1003         if (setArgumentType2)</span>
<span class="line-removed">1004             setArgumentTypes.append(*setArgumentType2);</span>
<span class="line-removed">1005         setArgumentTypes.append(setArgument3Type);</span>
<span class="line-removed">1006 </span>
<span class="line-removed">1007         auto* setFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleSetOverloads(), setArgumentTypes, castReturnType);</span>
<span class="line-removed">1008         if (!setFunction)</span>
<span class="line-removed">1009             return std::make_pair(nullptr, nullptr);</span>
<span class="line-removed">1010         return std::make_pair(setFunction, &amp;setFunction-&gt;type());</span>
<span class="line-removed">1011     })();</span>
<span class="line-removed">1012 </span>
<span class="line-removed">1013     if (setFunction) {</span>
<span class="line-removed">1014         if (!matches(setFunction-&gt;type(), wrappedBaseType)) {</span>
<span class="line-removed">1015             setError();</span>
1016             return;
<span class="line-modified">1017         }</span>

1018     }
1019 
<span class="line-modified">1020     Optional&lt;AST::AddressSpace&gt; addressSpace;</span>
<span class="line-modified">1021     if (getReturnType || andReturnType) {</span>
<span class="line-modified">1022         // FIXME: The reference compiler has &quot;else if (!node.base.isLValue &amp;&amp; !baseType.isArrayRef)&quot;,</span>
<span class="line-modified">1023         // but I don&#39;t understand why it exists. I haven&#39;t written it here, and I&#39;ll investigate</span>
<span class="line-modified">1024         // if we can remove it from the reference compiler.</span>
<span class="line-modified">1025         if (is&lt;AST::ReferenceType&gt;(wrappedBaseType))</span>
<span class="line-modified">1026             addressSpace = downcast&lt;AST::ReferenceType&gt;(wrappedBaseType).addressSpace();</span>
<span class="line-modified">1027         else {</span>
<span class="line-modified">1028             auto addressSpaceIterator = m_addressSpaceMap.find(&amp;propertyAccessExpression.base());</span>
<span class="line-modified">1029             ASSERT(addressSpaceIterator != m_addressSpaceMap.end());</span>
<span class="line-modified">1030             if (addressSpaceIterator-&gt;value)</span>
<span class="line-modified">1031                 addressSpace = *addressSpaceIterator-&gt;value;</span>
<span class="line-removed">1032             else {</span>
<span class="line-removed">1033                 setError();</span>
1034                 return;
<span class="line-modified">1035             }</span>

1036         }
1037     }
1038 
<span class="line-modified">1039     // FIXME: Generate the call expressions</span>
<span class="line-modified">1040 </span>
<span class="line-modified">1041     assignType(propertyAccessExpression, getReturnType ? getReturnType-&gt;clone() : andReturnType-&gt;clone(), addressSpace);</span>
<span class="line-modified">1042 }</span>










1043 
<span class="line-modified">1044 Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; Checker::recurseAndWrapBaseType(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="line-modified">1045 {</span>
<span class="line-modified">1046     auto baseInfo = recurseAndGetInfo(propertyAccessExpression.base());</span>
<span class="line-modified">1047     if (!baseInfo)</span>
<span class="line-removed">1048         return WTF::nullopt;</span>
1049 
<span class="line-modified">1050     auto* baseType = getUnnamedType(baseInfo-&gt;resolvingType);</span>
<span class="line-modified">1051     if (!baseType) {</span>
<span class="line-modified">1052         setError();</span>
<span class="line-removed">1053         return WTF::nullopt;</span>
1054     }
<span class="line-removed">1055     auto&amp; baseUnifyNode = baseType-&gt;unifyNode();</span>
<span class="line-removed">1056     if (is&lt;AST::UnnamedType&gt;(baseUnifyNode))</span>
<span class="line-removed">1057         return downcast&lt;AST::UnnamedType&gt;(baseUnifyNode).clone();</span>
<span class="line-removed">1058     ASSERT(is&lt;AST::NamedType&gt;(baseUnifyNode));</span>
<span class="line-removed">1059     return { AST::TypeReference::wrap(Lexer::Token(propertyAccessExpression.origin()), downcast&lt;AST::NamedType&gt;(baseUnifyNode)) };</span>
<span class="line-removed">1060 }</span>
1061 
<span class="line-modified">1062 void Checker::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-modified">1063 {</span>
<span class="line-removed">1064     auto baseType = recurseAndWrapBaseType(dotExpression);</span>
<span class="line-removed">1065     if (!baseType)</span>
1066         return;

1067 
<span class="line-modified">1068     finishVisitingPropertyAccess(dotExpression, *baseType);</span>
<span class="line-modified">1069 }</span>


1070 
<span class="line-modified">1071 void Checker::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-modified">1072 {</span>
<span class="line-removed">1073     auto baseType = recurseAndWrapBaseType(indexExpression);</span>
<span class="line-removed">1074     if (!baseType)</span>
1075         return;

1076 
<span class="line-modified">1077     auto indexInfo = recurseAndGetInfo(indexExpression.indexExpression());</span>
<span class="line-modified">1078     if (!indexInfo)</span>
1079         return;
<span class="line-modified">1080     auto indexExpressionType = getUnnamedType(indexInfo-&gt;resolvingType);</span>
<span class="line-modified">1081     if (!indexExpressionType) {</span>
<span class="line-modified">1082         setError();</span>



















1083         return;
1084     }
1085 
<span class="line-modified">1086     finishVisitingPropertyAccess(indexExpression, WTFMove(*baseType), indexExpressionType);</span>


























1087 }
1088 
1089 void Checker::visit(AST::VariableReference&amp; variableReference)
1090 {
1091     ASSERT(variableReference.variable());
1092     ASSERT(variableReference.variable()-&gt;type());
1093 
<span class="line-modified">1094     Optional&lt;AST::AddressSpace&gt; addressSpace;</span>
<span class="line-removed">1095     if (!variableReference.variable()-&gt;isAnonymous())</span>
<span class="line-removed">1096         addressSpace = AST::AddressSpace::Thread;</span>
<span class="line-removed">1097     assignType(variableReference, variableReference.variable()-&gt;type()-&gt;clone(), addressSpace);</span>
1098 }
1099 
1100 void Checker::visit(AST::Return&amp; returnStatement)
1101 {
<span class="line-removed">1102     ASSERT(returnStatement.function());</span>
1103     if (returnStatement.value()) {
1104         auto valueInfo = recurseAndGetInfo(*returnStatement.value());
1105         if (!valueInfo)
1106             return;
<span class="line-modified">1107         if (!matchAndCommit(valueInfo-&gt;resolvingType, returnStatement.function()-&gt;type()))</span>
<span class="line-modified">1108             setError();</span>
1109         return;
1110     }
1111 
<span class="line-modified">1112     if (!matches(returnStatement.function()-&gt;type(), m_intrinsics.voidType()))</span>
<span class="line-modified">1113         setError();</span>
1114 }
1115 
1116 void Checker::visit(AST::PointerType&amp;)
1117 {
1118     // Following pointer types can cause infinite loops because of data structures
1119     // like linked lists.
1120     // FIXME: Make sure this function should be empty
1121 }
1122 
1123 void Checker::visit(AST::ArrayReferenceType&amp;)
1124 {
1125     // Following array reference types can cause infinite loops because of data
1126     // structures like linked lists.
1127     // FIXME: Make sure this function should be empty
1128 }
1129 
1130 void Checker::visit(AST::IntegerLiteral&amp; integerLiteral)
1131 {
1132     assignType(integerLiteral, adoptRef(*new ResolvableTypeReference(integerLiteral.type())));
1133 }
1134 
1135 void Checker::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
1136 {
1137     assignType(unsignedIntegerLiteral, adoptRef(*new ResolvableTypeReference(unsignedIntegerLiteral.type())));
1138 }
1139 
1140 void Checker::visit(AST::FloatLiteral&amp; floatLiteral)
1141 {
1142     assignType(floatLiteral, adoptRef(*new ResolvableTypeReference(floatLiteral.type())));
1143 }
1144 
1145 void Checker::visit(AST::NullLiteral&amp; nullLiteral)
1146 {
1147     assignType(nullLiteral, adoptRef(*new ResolvableTypeReference(nullLiteral.type())));
1148 }
1149 
1150 void Checker::visit(AST::BooleanLiteral&amp; booleanLiteral)
1151 {
<span class="line-modified">1152     assignType(booleanLiteral, AST::TypeReference::wrap(Lexer::Token(booleanLiteral.origin()), m_intrinsics.boolType()));</span>
1153 }
1154 
1155 void Checker::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
1156 {
1157     ASSERT(enumerationMemberLiteral.enumerationDefinition());
1158     auto&amp; enumerationDefinition = *enumerationMemberLiteral.enumerationDefinition();
<span class="line-modified">1159     assignType(enumerationMemberLiteral, AST::TypeReference::wrap(Lexer::Token(enumerationMemberLiteral.origin()), enumerationDefinition));</span>
1160 }
1161 
1162 bool Checker::isBoolType(ResolvingType&amp; resolvingType)
1163 {
<span class="line-modified">1164     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; left) -&gt; bool {</span>
1165         return matches(left, m_intrinsics.boolType());
<span class="line-modified">1166     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; left) -&gt; bool {</span>
1167         return static_cast&lt;bool&gt;(matchAndCommit(m_intrinsics.boolType(), left-&gt;resolvableType()));
<span class="line-modified">1168     }), resolvingType);</span>
1169 }
1170 
1171 bool Checker::recurseAndRequireBoolType(AST::Expression&amp; expression)
1172 {
1173     auto expressionInfo = recurseAndGetInfo(expression);
1174     if (!expressionInfo)
1175         return false;
1176     if (!isBoolType(expressionInfo-&gt;resolvingType)) {
<span class="line-modified">1177         setError();</span>
1178         return false;
1179     }
1180     return true;
1181 }
1182 
1183 void Checker::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
1184 {
1185     if (!recurseAndRequireBoolType(logicalNotExpression.operand()))
1186         return;
<span class="line-modified">1187     assignType(logicalNotExpression, AST::TypeReference::wrap(Lexer::Token(logicalNotExpression.origin()), m_intrinsics.boolType()));</span>
1188 }
1189 
1190 void Checker::visit(AST::LogicalExpression&amp; logicalExpression)
1191 {
1192     if (!recurseAndRequireBoolType(logicalExpression.left()))
1193         return;
1194     if (!recurseAndRequireBoolType(logicalExpression.right()))
1195         return;
<span class="line-modified">1196     assignType(logicalExpression, AST::TypeReference::wrap(Lexer::Token(logicalExpression.origin()), m_intrinsics.boolType()));</span>
1197 }
1198 
1199 void Checker::visit(AST::IfStatement&amp; ifStatement)
1200 {
1201     if (!recurseAndRequireBoolType(ifStatement.conditional()))
1202         return;
1203     checkErrorAndVisit(ifStatement.body());
1204     if (ifStatement.elseBody())
1205         checkErrorAndVisit(*ifStatement.elseBody());
1206 }
1207 
1208 void Checker::visit(AST::WhileLoop&amp; whileLoop)
1209 {
1210     if (!recurseAndRequireBoolType(whileLoop.conditional()))
1211         return;
1212     checkErrorAndVisit(whileLoop.body());
1213 }
1214 
1215 void Checker::visit(AST::DoWhileLoop&amp; doWhileLoop)
1216 {
1217     checkErrorAndVisit(doWhileLoop.body());
1218     recurseAndRequireBoolType(doWhileLoop.conditional());
1219 }
1220 
1221 void Checker::visit(AST::ForLoop&amp; forLoop)
1222 {
<span class="line-modified">1223     WTF::visit(WTF::makeVisitor([&amp;](AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement) {</span>
<span class="line-modified">1224         checkErrorAndVisit(variableDeclarationsStatement);</span>
<span class="line-removed">1225     }, [&amp;](UniqueRef&lt;AST::Expression&gt;&amp; expression) {</span>
<span class="line-removed">1226         checkErrorAndVisit(expression);</span>
<span class="line-removed">1227     }), forLoop.initialization());</span>
<span class="line-removed">1228     if (error())</span>
1229         return;
1230     if (forLoop.condition()) {
1231         if (!recurseAndRequireBoolType(*forLoop.condition()))
1232             return;
1233     }
1234     if (forLoop.increment())
1235         checkErrorAndVisit(*forLoop.increment());
1236     checkErrorAndVisit(forLoop.body());
1237 }
1238 
1239 void Checker::visit(AST::SwitchStatement&amp; switchStatement)
1240 {
1241     auto* valueType = ([&amp;]() -&gt; AST::NamedType* {
1242         auto valueInfo = recurseAndGetInfo(switchStatement.value());
1243         if (!valueInfo)
1244             return nullptr;
1245         auto* valueType = getUnnamedType(valueInfo-&gt;resolvingType);
1246         if (!valueType)
1247             return nullptr;
1248         auto&amp; valueUnifyNode = valueType-&gt;unifyNode();
1249         if (!is&lt;AST::NamedType&gt;(valueUnifyNode))
1250             return nullptr;
1251         auto&amp; valueNamedUnifyNode = downcast&lt;AST::NamedType&gt;(valueUnifyNode);
1252         if (!(is&lt;AST::NativeTypeDeclaration&gt;(valueNamedUnifyNode) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(valueNamedUnifyNode).isInt())
1253             &amp;&amp; !is&lt;AST::EnumerationDefinition&gt;(valueNamedUnifyNode))
1254             return nullptr;
1255         return &amp;valueNamedUnifyNode;
1256     })();
1257     if (!valueType) {
<span class="line-modified">1258         setError();</span>
1259         return;
1260     }
1261 
1262     bool hasDefault = false;
1263     for (auto&amp; switchCase : switchStatement.switchCases()) {
1264         checkErrorAndVisit(switchCase.block());
1265         if (!switchCase.value()) {
1266             hasDefault = true;
1267             continue;
1268         }
<span class="line-modified">1269         bool success;</span>
<span class="line-modified">1270         switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-modified">1271             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, integerLiteral.type()));</span>
<span class="line-modified">1272         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-modified">1273             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, unsignedIntegerLiteral.type()));</span>
<span class="line-modified">1274         }, [&amp;](AST::FloatLiteral&amp; floatLiteral) {</span>
<span class="line-modified">1275             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, floatLiteral.type()));</span>
<span class="line-modified">1276         }, [&amp;](AST::NullLiteral&amp; nullLiteral) {</span>
<span class="line-modified">1277             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, nullLiteral.type()));</span>
<span class="line-modified">1278         }, [&amp;](AST::BooleanLiteral&amp;) {</span>
<span class="line-modified">1279             success = matches(*valueType, m_intrinsics.boolType());</span>
<span class="line-removed">1280         }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {</span>
1281             ASSERT(enumerationMemberLiteral.enumerationDefinition());
<span class="line-modified">1282             success = matches(*valueType, *enumerationMemberLiteral.enumerationDefinition());</span>
1283         }));
1284         if (!success) {
<span class="line-modified">1285             setError();</span>
1286             return;
1287         }
1288     }
1289 
1290     for (size_t i = 0; i &lt; switchStatement.switchCases().size(); ++i) {
1291         auto&amp; firstCase = switchStatement.switchCases()[i];
1292         for (size_t j = i + 1; j &lt; switchStatement.switchCases().size(); ++j) {
1293             auto&amp; secondCase = switchStatement.switchCases()[j];
1294 
1295             if (static_cast&lt;bool&gt;(firstCase.value()) != static_cast&lt;bool&gt;(secondCase.value()))
1296                 continue;
1297 
1298             if (!static_cast&lt;bool&gt;(firstCase.value())) {
<span class="line-modified">1299                 setError();</span>
1300                 return;
1301             }
1302 
<span class="line-modified">1303             bool success = true;</span>
<span class="line-modified">1304             firstCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; firstIntegerLiteral) {</span>
<span class="line-modified">1305                 secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) {</span>
<span class="line-modified">1306                     success = firstIntegerLiteral.value() != secondIntegerLiteral.value();</span>
<span class="line-modified">1307                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) {</span>
<span class="line-modified">1308                     success = static_cast&lt;int64_t&gt;(firstIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondUnsignedIntegerLiteral.value());</span>
<span class="line-modified">1309                 }, [](auto&amp;) {</span>
1310                 }));
<span class="line-modified">1311             }, [&amp;](AST::UnsignedIntegerLiteral&amp; firstUnsignedIntegerLiteral) {</span>
<span class="line-modified">1312                 secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) {</span>
<span class="line-modified">1313                     success = static_cast&lt;int64_t&gt;(firstUnsignedIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondIntegerLiteral.value());</span>
<span class="line-modified">1314                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) {</span>
<span class="line-modified">1315                     success = firstUnsignedIntegerLiteral.value() != secondUnsignedIntegerLiteral.value();</span>
<span class="line-modified">1316                 }, [](auto&amp;) {</span>

1317                 }));
<span class="line-modified">1318             }, [&amp;](AST::EnumerationMemberLiteral&amp; firstEnumerationMemberLiteral) {</span>
<span class="line-modified">1319                 secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp;) {</span>
<span class="line-removed">1320                 }, [&amp;](AST::EnumerationMemberLiteral&amp; secondEnumerationMemberLiteral) {</span>
1321                     ASSERT(firstEnumerationMemberLiteral.enumerationMember());
1322                     ASSERT(secondEnumerationMemberLiteral.enumerationMember());
<span class="line-modified">1323                     success = firstEnumerationMemberLiteral.enumerationMember() != secondEnumerationMemberLiteral.enumerationMember();</span>
<span class="line-modified">1324                 }, [](auto&amp;) {</span>

1325                 }));
<span class="line-modified">1326             }, [](auto&amp;) {</span>

1327             }));




1328         }
1329     }
1330 
1331     if (!hasDefault) {
1332         if (is&lt;AST::NativeTypeDeclaration&gt;(*valueType)) {
1333             HashSet&lt;int64_t&gt; values;
1334             bool zeroValueExists;
1335             for (auto&amp; switchCase : switchStatement.switchCases()) {
<span class="line-modified">1336                 int64_t value;</span>
<span class="line-modified">1337                 switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-modified">1338                     value = integerLiteral.valueForSelectedType();</span>
<span class="line-modified">1339                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-modified">1340                     value = unsignedIntegerLiteral.valueForSelectedType();</span>
<span class="line-removed">1341                 }, [](auto&amp;) {</span>
1342                     ASSERT_NOT_REACHED();

1343                 }));
1344                 if (!value)
1345                     zeroValueExists = true;
1346                 else
1347                     values.add(value);
1348             }
1349             bool success = true;
1350             downcast&lt;AST::NativeTypeDeclaration&gt;(*valueType).iterateAllValues([&amp;](int64_t value) -&gt; bool {
1351                 if (!value) {
1352                     if (!zeroValueExists) {
1353                         success = false;
1354                         return true;
1355                     }
1356                     return false;
1357                 }
1358                 if (!values.contains(value)) {
1359                     success = false;
1360                     return true;
1361                 }
1362                 return false;
1363             });
1364             if (!success) {
<span class="line-modified">1365                 setError();</span>
1366                 return;
1367             }
1368         } else {
<span class="line-removed">1369             ASSERT(is&lt;AST::EnumerationDefinition&gt;(*valueType));</span>
1370             HashSet&lt;AST::EnumerationMember*&gt; values;
1371             for (auto&amp; switchCase : switchStatement.switchCases()) {
1372                 switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
1373                     ASSERT(enumerationMemberLiteral.enumerationMember());
1374                     values.add(enumerationMemberLiteral.enumerationMember());
1375                 }, [](auto&amp;) {
1376                     ASSERT_NOT_REACHED();
1377                 }));
1378             }
1379             for (auto&amp; enumerationMember : downcast&lt;AST::EnumerationDefinition&gt;(*valueType).enumerationMembers()) {
1380                 if (!values.contains(&amp;enumerationMember.get())) {
<span class="line-modified">1381                     setError();</span>
1382                     return;
1383                 }
1384             }
1385         }
1386     }
1387 }
1388 
1389 void Checker::visit(AST::CommaExpression&amp; commaExpression)
1390 {
1391     ASSERT(commaExpression.list().size() &gt; 0);
1392     Visitor::visit(commaExpression);
<span class="line-modified">1393     if (error())</span>
1394         return;
1395     auto lastInfo = getInfo(commaExpression.list().last());
1396     forwardType(commaExpression, lastInfo-&gt;resolvingType);
1397 }
1398 
1399 void Checker::visit(AST::TernaryExpression&amp; ternaryExpression)
1400 {
1401     auto predicateInfo = recurseAndRequireBoolType(ternaryExpression.predicate());
1402     if (!predicateInfo)
1403         return;
1404 
1405     auto bodyInfo = recurseAndGetInfo(ternaryExpression.bodyExpression());
1406     auto elseInfo = recurseAndGetInfo(ternaryExpression.elseExpression());
1407 
1408     auto resultType = matchAndCommit(bodyInfo-&gt;resolvingType, elseInfo-&gt;resolvingType);
1409     if (!resultType) {
<span class="line-modified">1410         setError();</span>
1411         return;
1412     }
1413 
<span class="line-modified">1414     assignType(ternaryExpression, WTFMove(*resultType));</span>
1415 }
1416 
1417 void Checker::visit(AST::CallExpression&amp; callExpression)
1418 {
1419     Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; types;
1420     types.reserveInitialCapacity(callExpression.arguments().size());
1421     for (auto&amp; argument : callExpression.arguments()) {
1422         auto argumentInfo = recurseAndGetInfo(argument);
1423         if (!argumentInfo)
1424             return;
1425         types.uncheckedAppend(argumentInfo-&gt;resolvingType);
1426     }
<span class="line-modified">1427     if (callExpression.castReturnType()) {</span>
<span class="line-modified">1428         checkErrorAndVisit(callExpression.castReturnType()-&gt;get());</span>
<span class="line-modified">1429         if (error())</span>
<span class="line-modified">1430             return;</span>
<span class="line-modified">1431     }</span>

1432 
<span class="line-removed">1433     ASSERT(callExpression.hasOverloads());</span>
<span class="line-removed">1434     auto* function = resolveFunctionOverloadImpl(*callExpression.overloads(), types, callExpression.castReturnType());</span>
1435     if (!function) {
<span class="line-modified">1436         if (auto newFunction = resolveByInstantiation(callExpression, types, m_intrinsics)) {</span>
<span class="line-modified">1437             m_program.append(WTFMove(*newFunction));</span>
<span class="line-modified">1438             function = &amp;m_program.nativeFunctionDeclarations().last();</span>






1439         }
1440     }
1441 
1442     if (!function) {
<span class="line-modified">1443         setError();</span>


1444         return;
1445     }
1446 
1447     for (size_t i = 0; i &lt; function-&gt;parameters().size(); ++i) {
<span class="line-modified">1448         if (!matchAndCommit(types[i].get(), *function-&gt;parameters()[i].type())) {</span>
<span class="line-modified">1449             setError();</span>
1450             return;
1451         }
1452     }
1453 
1454     callExpression.setFunction(*function);
1455 
<span class="line-modified">1456     assignType(callExpression, function-&gt;type().clone());</span>
1457 }
1458 
<span class="line-modified">1459 bool check(Program&amp; program)</span>
1460 {
1461     Checker checker(program.intrinsics(), program);
1462     checker.checkErrorAndVisit(program);
<span class="line-modified">1463     if (checker.error())</span>
<span class="line-modified">1464         return false;</span>
1465     return checker.assignTypes();
1466 }
1467 
1468 } // namespace WHLSL
1469 
1470 } // namespace WebCore
1471 
1472 #endif // ENABLE(WEBGPU)
</pre>
</td>
<td>
<hr />
<pre>
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WHLSLChecker.h&quot;
  28 
  29 #if ENABLE(WEBGPU)
  30 
  31 #include &quot;WHLSLArrayReferenceType.h&quot;
  32 #include &quot;WHLSLArrayType.h&quot;
  33 #include &quot;WHLSLAssignmentExpression.h&quot;
  34 #include &quot;WHLSLCallExpression.h&quot;
  35 #include &quot;WHLSLCommaExpression.h&quot;
  36 #include &quot;WHLSLDereferenceExpression.h&quot;
  37 #include &quot;WHLSLDoWhileLoop.h&quot;
  38 #include &quot;WHLSLDotExpression.h&quot;
<span class="line-added">  39 #include &quot;WHLSLEntryPointType.h&quot;</span>
  40 #include &quot;WHLSLForLoop.h&quot;
  41 #include &quot;WHLSLGatherEntryPointItems.h&quot;
  42 #include &quot;WHLSLIfStatement.h&quot;
  43 #include &quot;WHLSLIndexExpression.h&quot;
  44 #include &quot;WHLSLInferTypes.h&quot;
  45 #include &quot;WHLSLLogicalExpression.h&quot;
  46 #include &quot;WHLSLLogicalNotExpression.h&quot;
  47 #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;
  48 #include &quot;WHLSLMakePointerExpression.h&quot;
<span class="line-added">  49 #include &quot;WHLSLNameContext.h&quot;</span>
  50 #include &quot;WHLSLPointerType.h&quot;
  51 #include &quot;WHLSLProgram.h&quot;
  52 #include &quot;WHLSLReadModifyWriteExpression.h&quot;
  53 #include &quot;WHLSLResolvableType.h&quot;
  54 #include &quot;WHLSLResolveOverloadImpl.h&quot;
  55 #include &quot;WHLSLResolvingType.h&quot;
  56 #include &quot;WHLSLReturn.h&quot;
  57 #include &quot;WHLSLSwitchStatement.h&quot;
  58 #include &quot;WHLSLTernaryExpression.h&quot;
  59 #include &quot;WHLSLVisitor.h&quot;
  60 #include &quot;WHLSLWhileLoop.h&quot;
  61 #include &lt;wtf/HashMap.h&gt;
  62 #include &lt;wtf/HashSet.h&gt;
  63 #include &lt;wtf/Ref.h&gt;
  64 #include &lt;wtf/Vector.h&gt;
  65 #include &lt;wtf/text/WTFString.h&gt;
  66 
  67 namespace WebCore {
  68 
  69 namespace WHLSL {
  70 
  71 class PODChecker : public Visitor {
  72 public:
  73     PODChecker() = default;
  74 
  75     virtual ~PODChecker() = default;
  76 
  77     void visit(AST::EnumerationDefinition&amp; enumerationDefinition) override
  78     {
  79         Visitor::visit(enumerationDefinition);
  80     }
  81 
  82     void visit(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration) override
  83     {
  84         if (!nativeTypeDeclaration.isNumber()
  85             &amp;&amp; !nativeTypeDeclaration.isVector()
  86             &amp;&amp; !nativeTypeDeclaration.isMatrix())
<span class="line-modified">  87             setError(Error(&quot;Use of native type is not a POD in entrypoint semantic.&quot;, nativeTypeDeclaration.codeLocation()));</span>
  88     }
  89 
  90     void visit(AST::StructureDefinition&amp; structureDefinition) override
  91     {
  92         Visitor::visit(structureDefinition);
  93     }
  94 
  95     void visit(AST::TypeDefinition&amp; typeDefinition) override
  96     {
  97         Visitor::visit(typeDefinition);
  98     }
  99 
 100     void visit(AST::ArrayType&amp; arrayType) override
 101     {
 102         Visitor::visit(arrayType);
 103     }
 104 
<span class="line-modified"> 105     void visit(AST::PointerType&amp; pointerType) override</span>
 106     {
<span class="line-modified"> 107         setError(Error(&quot;Illegal use of pointer in entrypoint semantic.&quot;, pointerType.codeLocation()));</span>
 108     }
 109 
<span class="line-modified"> 110     void visit(AST::ArrayReferenceType&amp; arrayReferenceType) override</span>
 111     {
<span class="line-modified"> 112         setError(Error(&quot;Illegal use of array reference in entrypoint semantic.&quot;, arrayReferenceType.codeLocation()));</span>
 113     }
 114 
 115     void visit(AST::TypeReference&amp; typeReference) override
 116     {
<span class="line-modified"> 117         checkErrorAndVisit(typeReference.resolvedType());</span>

 118     }
 119 };
 120 
<span class="line-modified"> 121 class FunctionKey {</span>
<span class="line-added"> 122 public:</span>
<span class="line-added"> 123     FunctionKey() = default;</span>
<span class="line-added"> 124     FunctionKey(WTF::HashTableDeletedValueType)</span>
<span class="line-added"> 125     {</span>
<span class="line-added"> 126         m_castReturnType = bitwise_cast&lt;AST::NamedType*&gt;(static_cast&lt;uintptr_t&gt;(1));</span>
<span class="line-added"> 127     }</span>
<span class="line-added"> 128 </span>
<span class="line-added"> 129     FunctionKey(String name, Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; types, AST::NamedType* castReturnType = nullptr)</span>
<span class="line-added"> 130         : m_name(WTFMove(name))</span>
<span class="line-added"> 131         , m_types(WTFMove(types))</span>
<span class="line-added"> 132         , m_castReturnType(castReturnType)</span>
<span class="line-added"> 133     { }</span>
<span class="line-added"> 134 </span>
<span class="line-added"> 135     bool isEmptyValue() const { return m_name.isNull(); }</span>
<span class="line-added"> 136     bool isHashTableDeletedValue() const { return m_castReturnType == bitwise_cast&lt;AST::NamedType*&gt;(static_cast&lt;uintptr_t&gt;(1)); }</span>
<span class="line-added"> 137 </span>
<span class="line-added"> 138     unsigned hash() const</span>
<span class="line-added"> 139     {</span>
<span class="line-added"> 140         unsigned hash = IntHash&lt;size_t&gt;::hash(m_types.size());</span>
<span class="line-added"> 141         hash ^= m_name.hash();</span>
<span class="line-added"> 142         for (size_t i = 0; i &lt; m_types.size(); ++i)</span>
<span class="line-added"> 143             hash ^= m_types[i].get().hash() + i;</span>
<span class="line-added"> 144 </span>
<span class="line-added"> 145         if (m_castReturnType)</span>
<span class="line-added"> 146             hash ^= WTF::PtrHash&lt;AST::Type*&gt;::hash(&amp;m_castReturnType-&gt;unifyNode());</span>
<span class="line-added"> 147 </span>
<span class="line-added"> 148         return hash;</span>
<span class="line-added"> 149     }</span>
<span class="line-added"> 150 </span>
<span class="line-added"> 151     bool operator==(const FunctionKey&amp; other) const</span>
<span class="line-added"> 152     {</span>
<span class="line-added"> 153         if (m_types.size() != other.m_types.size())</span>
<span class="line-added"> 154             return false;</span>
<span class="line-added"> 155 </span>
<span class="line-added"> 156         if (m_name != other.m_name)</span>
<span class="line-added"> 157             return false;</span>
<span class="line-added"> 158 </span>
<span class="line-added"> 159         for (size_t i = 0; i &lt; m_types.size(); ++i) {</span>
<span class="line-added"> 160             if (!matches(m_types[i].get(), other.m_types[i].get()))</span>
<span class="line-added"> 161                 return false;</span>
<span class="line-added"> 162         }</span>
<span class="line-added"> 163 </span>
<span class="line-added"> 164         if (static_cast&lt;bool&gt;(m_castReturnType) != static_cast&lt;bool&gt;(other.m_castReturnType))</span>
<span class="line-added"> 165             return false;</span>
<span class="line-added"> 166 </span>
<span class="line-added"> 167         if (!m_castReturnType)</span>
<span class="line-added"> 168             return true;</span>
<span class="line-added"> 169 </span>
<span class="line-added"> 170         if (&amp;m_castReturnType-&gt;unifyNode() == &amp;other.m_castReturnType-&gt;unifyNode())</span>
<span class="line-added"> 171             return true;</span>
<span class="line-added"> 172 </span>
<span class="line-added"> 173         return false;</span>
<span class="line-added"> 174     }</span>
<span class="line-added"> 175 </span>
<span class="line-added"> 176     struct Hash {</span>
<span class="line-added"> 177         static unsigned hash(const FunctionKey&amp; key)</span>
<span class="line-added"> 178         {</span>
<span class="line-added"> 179             return key.hash();</span>
<span class="line-added"> 180         }</span>
<span class="line-added"> 181 </span>
<span class="line-added"> 182         static bool equal(const FunctionKey&amp; a, const FunctionKey&amp; b)</span>
<span class="line-added"> 183         {</span>
<span class="line-added"> 184             return a == b;</span>
<span class="line-added"> 185         }</span>
<span class="line-added"> 186 </span>
<span class="line-added"> 187         static const bool safeToCompareToEmptyOrDeleted = false;</span>
<span class="line-added"> 188         static const bool emptyValueIsZero = false;</span>
<span class="line-added"> 189     };</span>
<span class="line-added"> 190 </span>
<span class="line-added"> 191     struct Traits : public WTF::SimpleClassHashTraits&lt;FunctionKey&gt; {</span>
<span class="line-added"> 192         static const bool hasIsEmptyValueFunction = true;</span>
<span class="line-added"> 193         static bool isEmptyValue(const FunctionKey&amp; key) { return key.isEmptyValue(); }</span>
<span class="line-added"> 194     };</span>
<span class="line-added"> 195 </span>
<span class="line-added"> 196 private:</span>
<span class="line-added"> 197     String m_name;</span>
<span class="line-added"> 198     Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; m_types;</span>
<span class="line-added"> 199     AST::NamedType* m_castReturnType;</span>
<span class="line-added"> 200 };</span>
<span class="line-added"> 201 </span>
<span class="line-added"> 202 class AndOverloadTypeKey {</span>
<span class="line-added"> 203 public:</span>
<span class="line-added"> 204     AndOverloadTypeKey() = default;</span>
<span class="line-added"> 205     AndOverloadTypeKey(WTF::HashTableDeletedValueType)</span>
<span class="line-added"> 206     {</span>
<span class="line-added"> 207         m_type = bitwise_cast&lt;AST::UnnamedType*&gt;(static_cast&lt;uintptr_t&gt;(1));</span>
<span class="line-added"> 208     }</span>
<span class="line-added"> 209 </span>
<span class="line-added"> 210     AndOverloadTypeKey(AST::UnnamedType&amp; type, AST::AddressSpace addressSpace)</span>
<span class="line-added"> 211         : m_type(&amp;type)</span>
<span class="line-added"> 212         , m_addressSpace(addressSpace)</span>
<span class="line-added"> 213     { }</span>
<span class="line-added"> 214 </span>
<span class="line-added"> 215     bool isEmptyValue() const { return !m_type; }</span>
<span class="line-added"> 216     bool isHashTableDeletedValue() const { return m_type == bitwise_cast&lt;AST::UnnamedType*&gt;(static_cast&lt;uintptr_t&gt;(1)); }</span>
<span class="line-added"> 217 </span>
<span class="line-added"> 218     unsigned hash() const</span>
<span class="line-added"> 219     {</span>
<span class="line-added"> 220         return IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(m_addressSpace)) ^ m_type-&gt;hash();</span>
<span class="line-added"> 221     }</span>
<span class="line-added"> 222 </span>
<span class="line-added"> 223     bool operator==(const AndOverloadTypeKey&amp; other) const</span>
<span class="line-added"> 224     {</span>
<span class="line-added"> 225         return m_addressSpace == other.m_addressSpace</span>
<span class="line-added"> 226             &amp;&amp; *m_type == *other.m_type;</span>
<span class="line-added"> 227     }</span>
<span class="line-added"> 228 </span>
<span class="line-added"> 229     struct Hash {</span>
<span class="line-added"> 230         static unsigned hash(const AndOverloadTypeKey&amp; key)</span>
<span class="line-added"> 231         {</span>
<span class="line-added"> 232             return key.hash();</span>
<span class="line-added"> 233         }</span>
<span class="line-added"> 234 </span>
<span class="line-added"> 235         static bool equal(const AndOverloadTypeKey&amp; a, const AndOverloadTypeKey&amp; b)</span>
<span class="line-added"> 236         {</span>
<span class="line-added"> 237             return a == b;</span>
<span class="line-added"> 238         }</span>
<span class="line-added"> 239 </span>
<span class="line-added"> 240         static const bool safeToCompareToEmptyOrDeleted = false;</span>
<span class="line-added"> 241     };</span>
<span class="line-added"> 242 </span>
<span class="line-added"> 243     struct Traits : public WTF::SimpleClassHashTraits&lt;AndOverloadTypeKey&gt; {</span>
<span class="line-added"> 244         static const bool hasIsEmptyValueFunction = true;</span>
<span class="line-added"> 245         static bool isEmptyValue(const AndOverloadTypeKey&amp; key) { return key.isEmptyValue(); }</span>
<span class="line-added"> 246     };</span>
<span class="line-added"> 247 </span>
<span class="line-added"> 248 private:</span>
<span class="line-added"> 249     AST::UnnamedType* m_type { nullptr };</span>
<span class="line-added"> 250     AST::AddressSpace m_addressSpace;</span>
<span class="line-added"> 251 };</span>
<span class="line-added"> 252 </span>
<span class="line-added"> 253 static AST::NativeFunctionDeclaration resolveWithOperatorAnderIndexer(CodeLocation location, AST::ArrayReferenceType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
 254 {
 255     const bool isOperator = true;
<span class="line-modified"> 256     auto returnType = AST::PointerType::create(location, firstArgument.addressSpace(), firstArgument.elementType());</span>
 257     AST::VariableDeclarations parameters;
<span class="line-modified"> 258     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), &amp;firstArgument, String(), nullptr, nullptr));</span>
<span class="line-modified"> 259     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), AST::TypeReference::wrap(location, intrinsics.uintType()), String(), nullptr, nullptr));</span>
<span class="line-modified"> 260     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator&amp;[]&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
 261 }
 262 
<span class="line-modified"> 263 static AST::NativeFunctionDeclaration resolveWithOperatorLength(CodeLocation location, AST::UnnamedType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
 264 {
 265     const bool isOperator = true;
<span class="line-modified"> 266     auto returnType = AST::TypeReference::wrap(location, intrinsics.uintType());</span>
 267     AST::VariableDeclarations parameters;
<span class="line-modified"> 268     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), &amp;firstArgument, String(), nullptr, nullptr));</span>
<span class="line-modified"> 269     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator.length&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
 270 }
 271 
<span class="line-modified"> 272 static AST::NativeFunctionDeclaration resolveWithReferenceComparator(CodeLocation location, ResolvingType&amp; firstArgument, ResolvingType&amp; secondArgument, const Intrinsics&amp; intrinsics)</span>
 273 {
 274     const bool isOperator = true;
<span class="line-modified"> 275     auto returnType = AST::TypeReference::wrap(location, intrinsics.boolType());</span>
<span class="line-modified"> 276     auto argumentType = firstArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 277         return unnamedType.copyRef();</span>
<span class="line-modified"> 278     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 279         return secondArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 280             return unnamedType.copyRef();</span>
<span class="line-modified"> 281         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
 282             // We encountered &quot;null == null&quot;.
<span class="line-modified"> 283             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198162 This can probably be generalized, using the &quot;preferred type&quot; infrastructure used by generic literals</span>
<span class="line-modified"> 284             ASSERT_NOT_REACHED();</span>
<span class="line-modified"> 285             return AST::TypeReference::wrap(location, intrinsics.intType());</span>
<span class="line-modified"> 286         }));</span>
<span class="line-modified"> 287     }));</span>
 288     AST::VariableDeclarations parameters;
<span class="line-modified"> 289     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), argumentType.copyRef(), String(), nullptr, nullptr));</span>
<span class="line-modified"> 290     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), WTFMove(argumentType), String(), nullptr, nullptr));</span>
<span class="line-modified"> 291     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator==&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
 292 }
 293 
<span class="line-modified"> 294 enum class Acceptability {</span>
<span class="line-added"> 295     Yes,</span>
<span class="line-added"> 296     Maybe,</span>
<span class="line-added"> 297     No</span>
<span class="line-added"> 298 };</span>
<span class="line-added"> 299 </span>
<span class="line-added"> 300 static Optional&lt;AST::NativeFunctionDeclaration&gt; resolveByInstantiation(const String&amp; name, CodeLocation location, const Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const Intrinsics&amp; intrinsics)</span>
 301 {
<span class="line-modified"> 302     if (name == &quot;operator&amp;[]&quot; &amp;&amp; types.size() == 2) {</span>
<span class="line-modified"> 303         auto* firstArgumentArrayRef = types[0].get().visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::ArrayReferenceType* {</span>
 304             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))
 305                 return &amp;downcast&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType));
 306             return nullptr;
<span class="line-modified"> 307         }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::ArrayReferenceType* {</span>
 308             return nullptr;
<span class="line-modified"> 309         }));</span>
<span class="line-modified"> 310         bool secondArgumentIsUint = types[1].get().visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
 311             return matches(unnamedType, intrinsics.uintType());
<span class="line-modified"> 312         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
 313             return resolvableTypeReference-&gt;resolvableType().canResolve(intrinsics.uintType());
<span class="line-modified"> 314         }));</span>
 315         if (firstArgumentArrayRef &amp;&amp; secondArgumentIsUint)
<span class="line-modified"> 316             return resolveWithOperatorAnderIndexer(location, *firstArgumentArrayRef, intrinsics);</span>
<span class="line-modified"> 317     } else if (name == &quot;operator.length&quot; &amp;&amp; types.size() == 1) {</span>
<span class="line-modified"> 318         auto* firstArgumentReference = types[0].get().visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
 319             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)) || is&lt;AST::ArrayType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))
<span class="line-modified"> 320                 return unnamedType.ptr();</span>
 321             return nullptr;
<span class="line-modified"> 322         }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::UnnamedType* {</span>
 323             return nullptr;
<span class="line-modified"> 324         }));</span>
 325         if (firstArgumentReference)
<span class="line-modified"> 326             return resolveWithOperatorLength(location, *firstArgumentReference, intrinsics);</span>
<span class="line-modified"> 327     } else if (name == &quot;operator==&quot; &amp;&amp; types.size() == 2) {</span>
<span class="line-modified"> 328         auto acceptability = [](ResolvingType&amp; resolvingType) -&gt; Acceptability {</span>
<span class="line-modified"> 329             return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Acceptability {</span>
<span class="line-modified"> 330                 auto&amp; unifyNode = unnamedType-&gt;unifyNode();</span>
<span class="line-modified"> 331                 return is&lt;AST::UnnamedType&gt;(unifyNode) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(unifyNode)) ? Acceptability::Yes : Acceptability::No;</span>
<span class="line-modified"> 332             }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; Acceptability {</span>
<span class="line-modified"> 333                 return is&lt;AST::NullLiteralType&gt;(resolvableTypeReference-&gt;resolvableType()) ? Acceptability::Maybe : Acceptability::No;</span>
<span class="line-added"> 334             }));</span>
 335         };
<span class="line-modified"> 336         auto leftAcceptability = acceptability(types[0].get());</span>
<span class="line-modified"> 337         auto rightAcceptability = acceptability(types[1].get());</span>
<span class="line-added"> 338         bool success = false;</span>
<span class="line-added"> 339         if (leftAcceptability == Acceptability::Yes &amp;&amp; rightAcceptability == Acceptability::Yes) {</span>
<span class="line-added"> 340             auto&amp; unnamedType1 = *types[0].get().getUnnamedType();</span>
<span class="line-added"> 341             auto&amp; unnamedType2 = *types[1].get().getUnnamedType();</span>
<span class="line-added"> 342             success = matches(unnamedType1, unnamedType2);</span>
<span class="line-added"> 343         } else if ((leftAcceptability == Acceptability::Maybe &amp;&amp; rightAcceptability == Acceptability::Yes)</span>
<span class="line-added"> 344             || (leftAcceptability == Acceptability::Yes &amp;&amp; rightAcceptability == Acceptability::Maybe))</span>
<span class="line-added"> 345             success = true;</span>
<span class="line-added"> 346         if (success)</span>
<span class="line-added"> 347             return resolveWithReferenceComparator(location, types[0].get(), types[1].get(), intrinsics);</span>
 348     }
 349     return WTF::nullopt;
 350 }
 351 
 352 static bool checkSemantics(Vector&lt;EntryPointItem&gt;&amp; inputItems, Vector&lt;EntryPointItem&gt;&amp; outputItems, const Optional&lt;AST::EntryPointType&gt;&amp; entryPointType, const Intrinsics&amp; intrinsics)
 353 {
 354     {
 355         auto checkDuplicateSemantics = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 356             for (size_t i = 0; i &lt; items.size(); ++i) {
 357                 for (size_t j = i + 1; j &lt; items.size(); ++j) {
 358                     if (items[i].semantic == items[j].semantic)
 359                         return false;
 360                 }
 361             }
 362             return true;
 363         };
 364         if (!checkDuplicateSemantics(inputItems))
 365             return false;
 366         if (!checkDuplicateSemantics(outputItems))
 367             return false;
</pre>
<hr />
<pre>
 396             return true;
 397         };
 398         if (!checkSemanticForShaderType(inputItems, AST::BaseSemantic::ShaderItemDirection::Input))
 399             return false;
 400         if (!checkSemanticForShaderType(outputItems, AST::BaseSemantic::ShaderItemDirection::Output))
 401             return false;
 402     }
 403 
 404     {
 405         auto checkPODData = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 406             for (auto&amp; item : items) {
 407                 PODChecker podChecker;
 408                 if (is&lt;AST::PointerType&gt;(item.unnamedType))
 409                     podChecker.checkErrorAndVisit(downcast&lt;AST::PointerType&gt;(*item.unnamedType).elementType());
 410                 else if (is&lt;AST::ArrayReferenceType&gt;(item.unnamedType))
 411                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayReferenceType&gt;(*item.unnamedType).elementType());
 412                 else if (is&lt;AST::ArrayType&gt;(item.unnamedType))
 413                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayType&gt;(*item.unnamedType).type());
 414                 else
 415                     continue;
<span class="line-modified"> 416                 if (podChecker.hasError())</span>
 417                     return false;
 418             }
 419             return true;
 420         };
 421         if (!checkPODData(inputItems))
 422             return false;
 423         if (!checkPODData(outputItems))
 424             return false;
 425     }
 426 
 427     return true;
 428 }
 429 
<span class="line-modified"> 430 static bool checkOperatorOverload(const AST::FunctionDefinition&amp; functionDefinition, NameContext&amp; nameContext, AST::NameSpace currentNameSpace)</span>
 431 {
 432     enum class CheckKind {
 433         Index,
 434         Dot
 435     };
 436 
 437     auto checkGetter = [&amp;](CheckKind kind) -&gt; bool {
 438         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;
 439         if (functionDefinition.parameters().size() != numExpectedParameters)
 440             return false;
<span class="line-modified"> 441         auto&amp; firstParameterUnifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
 442         if (is&lt;AST::UnnamedType&gt;(firstParameterUnifyNode)) {
 443             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstParameterUnifyNode);
 444             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))
 445                 return false;
 446         }
 447         if (kind == CheckKind::Index) {
<span class="line-modified"> 448             auto&amp; secondParameterUnifyNode = functionDefinition.parameters()[1]-&gt;type()-&gt;unifyNode();</span>
 449             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))
 450                 return false;
 451             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);
 452             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 453                 return false;
 454             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 455             if (!nativeTypeDeclaration.isInt())
 456                 return false;
 457         }
 458         return true;
 459     };
 460 
 461     auto checkSetter = [&amp;](CheckKind kind) -&gt; bool {
 462         size_t numExpectedParameters = kind == CheckKind::Index ? 3 : 2;
 463         if (functionDefinition.parameters().size() != numExpectedParameters)
 464             return false;
<span class="line-modified"> 465         auto&amp; firstArgumentUnifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
 466         if (is&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode)) {
 467             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode);
 468             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))
 469                 return false;
 470         }
 471         if (kind == CheckKind::Index) {
<span class="line-modified"> 472             auto&amp; secondParameterUnifyNode = functionDefinition.parameters()[1]-&gt;type()-&gt;unifyNode();</span>
 473             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))
 474                 return false;
 475             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);
 476             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 477                 return false;
 478             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 479             if (!nativeTypeDeclaration.isInt())
 480                 return false;
 481         }
<span class="line-modified"> 482         if (!matches(functionDefinition.type(), *functionDefinition.parameters()[0]-&gt;type()))</span>
 483             return false;
<span class="line-modified"> 484         auto&amp; valueType = *functionDefinition.parameters()[numExpectedParameters - 1]-&gt;type();</span>
 485         auto getterName = functionDefinition.name().substring(0, functionDefinition.name().length() - 1);
<span class="line-modified"> 486         auto getterFuncs = nameContext.getFunctions(getterName, currentNameSpace);</span>


 487         Vector&lt;ResolvingType&gt; argumentTypes;
 488         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; argumentTypeReferences;
 489         for (size_t i = 0; i &lt; numExpectedParameters - 1; ++i)
<span class="line-modified"> 490             argumentTypes.append(*functionDefinition.parameters()[i]-&gt;type());</span>
 491         for (auto&amp; argumentType : argumentTypes)
 492             argumentTypeReferences.append(argumentType);
<span class="line-modified"> 493         auto* overload = resolveFunctionOverload(getterFuncs, argumentTypeReferences, currentNameSpace);</span>

 494         if (!overload)
 495             return false;
 496         auto&amp; resultType = overload-&gt;type();
 497         return matches(resultType, valueType);
 498     };
 499 
 500     auto checkAnder = [&amp;](CheckKind kind) -&gt; bool {
 501         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;
 502         if (functionDefinition.parameters().size() != numExpectedParameters)
 503             return false;
 504         {
 505             auto&amp; unifyNode = functionDefinition.type().unifyNode();
 506             if (!is&lt;AST::UnnamedType&gt;(unifyNode))
 507                 return false;
 508             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 509             if (!is&lt;AST::PointerType&gt;(unnamedType))
 510                 return false;
 511         }
 512         {
<span class="line-modified"> 513             auto&amp; unifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
 514             if (!is&lt;AST::UnnamedType&gt;(unifyNode))
 515                 return false;
 516             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 517             return is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType);
 518         }
 519     };
 520 
 521     if (!functionDefinition.isOperator())
 522         return true;
 523     if (functionDefinition.isCast())
 524         return true;
 525     if (functionDefinition.name() == &quot;operator++&quot; || functionDefinition.name() == &quot;operator--&quot;) {
 526         return functionDefinition.parameters().size() == 1
<span class="line-modified"> 527             &amp;&amp; matches(*functionDefinition.parameters()[0]-&gt;type(), functionDefinition.type());</span>
 528     }
 529     if (functionDefinition.name() == &quot;operator+&quot; || functionDefinition.name() == &quot;operator-&quot;)
 530         return functionDefinition.parameters().size() == 1 || functionDefinition.parameters().size() == 2;
 531     if (functionDefinition.name() == &quot;operator*&quot;
 532         || functionDefinition.name() == &quot;operator/&quot;
 533         || functionDefinition.name() == &quot;operator%&quot;
 534         || functionDefinition.name() == &quot;operator&amp;&quot;
 535         || functionDefinition.name() == &quot;operator|&quot;
 536         || functionDefinition.name() == &quot;operator^&quot;
 537         || functionDefinition.name() == &quot;operator&lt;&lt;&quot;
<span class="line-modified"> 538         || functionDefinition.name() == &quot;operator&gt;&gt;&quot;)</span>
 539         return functionDefinition.parameters().size() == 2;
 540     if (functionDefinition.name() == &quot;operator~&quot;)
 541         return functionDefinition.parameters().size() == 1;








 542     if (functionDefinition.name() == &quot;operator[]&quot;)
 543         return checkGetter(CheckKind::Index);
 544     if (functionDefinition.name() == &quot;operator[]=&quot;)
 545         return checkSetter(CheckKind::Index);
 546     if (functionDefinition.name() == &quot;operator&amp;[]&quot;)
 547         return checkAnder(CheckKind::Index);
 548     if (functionDefinition.name().startsWith(&quot;operator.&quot;)) {
 549         if (functionDefinition.name().endsWith(&quot;=&quot;))
 550             return checkSetter(CheckKind::Dot);
 551         return checkGetter(CheckKind::Dot);
 552     }
 553     if (functionDefinition.name().startsWith(&quot;operator&amp;.&quot;))
 554         return checkAnder(CheckKind::Dot);
 555     return false;
 556 }
 557 
 558 class Checker : public Visitor {
 559 public:
 560     Checker(const Intrinsics&amp; intrinsics, Program&amp; program)
 561         : m_intrinsics(intrinsics)
 562         , m_program(program)
 563     {
<span class="line-added"> 564         auto addFunction = [&amp;] (AST::FunctionDeclaration&amp; function) {</span>
<span class="line-added"> 565             AST::NamedType* castReturnType = nullptr;</span>
<span class="line-added"> 566             if (function.isCast() &amp;&amp; is&lt;AST::NamedType&gt;(function.type().unifyNode()))</span>
<span class="line-added"> 567                 castReturnType = &amp;downcast&lt;AST::NamedType&gt;(function.type().unifyNode());</span>
<span class="line-added"> 568 </span>
<span class="line-added"> 569             Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; types;</span>
<span class="line-added"> 570             types.reserveInitialCapacity(function.parameters().size());</span>
<span class="line-added"> 571 </span>
<span class="line-added"> 572             for (auto&amp; param : function.parameters())</span>
<span class="line-added"> 573                 types.uncheckedAppend(normalizedTypeForFunctionKey(*param-&gt;type()));</span>
<span class="line-added"> 574 </span>
<span class="line-added"> 575             auto addResult = m_functions.add(FunctionKey { function.name(), WTFMove(types), castReturnType }, Vector&lt;std::reference_wrapper&lt;AST::FunctionDeclaration&gt;, 1&gt;());</span>
<span class="line-added"> 576             addResult.iterator-&gt;value.append(function);</span>
<span class="line-added"> 577         };</span>
<span class="line-added"> 578 </span>
<span class="line-added"> 579         for (auto&amp; function : m_program.functionDefinitions())</span>
<span class="line-added"> 580             addFunction(function.get());</span>
<span class="line-added"> 581         for (auto&amp; function : m_program.nativeFunctionDeclarations())</span>
<span class="line-added"> 582             addFunction(function.get());</span>
 583     }
 584 
<span class="line-modified"> 585     virtual ~Checker() = default;</span>
 586 
 587     void visit(Program&amp;) override;
 588 
<span class="line-modified"> 589     Expected&lt;void, Error&gt; assignTypes();</span>
 590 
 591 private:
 592     bool checkShaderType(const AST::FunctionDefinition&amp;);

 593     bool isBoolType(ResolvingType&amp;);
 594     struct RecurseInfo {
 595         ResolvingType&amp; resolvingType;
<span class="line-modified"> 596         const AST::TypeAnnotation typeAnnotation;</span>
 597     };
<span class="line-modified"> 598     Optional&lt;RecurseInfo&gt; recurseAndGetInfo(AST::Expression&amp;, bool requiresLeftValue = false);</span>
<span class="line-modified"> 599     Optional&lt;RecurseInfo&gt; getInfo(AST::Expression&amp;, bool requiresLeftValue = false);</span>
<span class="line-modified"> 600     RefPtr&lt;AST::UnnamedType&gt; recurseAndWrapBaseType(AST::PropertyAccessExpression&amp;);</span>
 601     bool recurseAndRequireBoolType(AST::Expression&amp;);
<span class="line-modified"> 602     void assignConcreteType(AST::Expression&amp;, Ref&lt;AST::UnnamedType&gt;, AST::TypeAnnotation);</span>
<span class="line-modified"> 603     void assignType(AST::Expression&amp;, RefPtr&lt;ResolvableTypeReference&gt;, AST::TypeAnnotation);</span>
<span class="line-modified"> 604     void forwardType(AST::Expression&amp;, ResolvingType&amp;, AST::TypeAnnotation);</span>
 605 
 606     void visit(AST::FunctionDefinition&amp;) override;
 607     void visit(AST::EnumerationDefinition&amp;) override;
 608     void visit(AST::TypeReference&amp;) override;
 609     void visit(AST::VariableDeclaration&amp;) override;
 610     void visit(AST::AssignmentExpression&amp;) override;
 611     void visit(AST::ReadModifyWriteExpression&amp;) override;
 612     void visit(AST::DereferenceExpression&amp;) override;
 613     void visit(AST::MakePointerExpression&amp;) override;
 614     void visit(AST::MakeArrayReferenceExpression&amp;) override;
 615     void visit(AST::DotExpression&amp;) override;
 616     void visit(AST::IndexExpression&amp;) override;
 617     void visit(AST::VariableReference&amp;) override;
 618     void visit(AST::Return&amp;) override;
 619     void visit(AST::PointerType&amp;) override;
 620     void visit(AST::ArrayReferenceType&amp;) override;
 621     void visit(AST::IntegerLiteral&amp;) override;
 622     void visit(AST::UnsignedIntegerLiteral&amp;) override;
 623     void visit(AST::FloatLiteral&amp;) override;
 624     void visit(AST::NullLiteral&amp;) override;
 625     void visit(AST::BooleanLiteral&amp;) override;
 626     void visit(AST::EnumerationMemberLiteral&amp;) override;
 627     void visit(AST::LogicalNotExpression&amp;) override;
 628     void visit(AST::LogicalExpression&amp;) override;
 629     void visit(AST::IfStatement&amp;) override;
 630     void visit(AST::WhileLoop&amp;) override;
 631     void visit(AST::DoWhileLoop&amp;) override;
 632     void visit(AST::ForLoop&amp;) override;
 633     void visit(AST::SwitchStatement&amp;) override;
 634     void visit(AST::CommaExpression&amp;) override;
 635     void visit(AST::TernaryExpression&amp;) override;
 636     void visit(AST::CallExpression&amp;) override;
 637 
<span class="line-modified"> 638     void finishVisiting(AST::PropertyAccessExpression&amp;, ResolvingType* additionalArgumentType = nullptr);</span>
<span class="line-modified"> 639 </span>
<span class="line-modified"> 640     AST::FunctionDeclaration* resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation, AST::NamedType* castReturnType = nullptr);</span>
<span class="line-modified"> 641 </span>
<span class="line-modified"> 642     RefPtr&lt;AST::UnnamedType&gt; argumentTypeForAndOverload(AST::UnnamedType&amp; baseType, AST::AddressSpace);</span>
<span class="line-added"> 643 </span>
<span class="line-added"> 644     AST::UnnamedType&amp; wrappedFloatType()</span>
<span class="line-added"> 645     {</span>
<span class="line-added"> 646         if (!m_wrappedFloatType)</span>
<span class="line-added"> 647             m_wrappedFloatType = AST::TypeReference::wrap({ }, m_intrinsics.floatType());</span>
<span class="line-added"> 648         return *m_wrappedFloatType;</span>
<span class="line-added"> 649     }</span>
<span class="line-added"> 650 </span>
<span class="line-added"> 651     AST::UnnamedType&amp; genericPointerType()</span>
<span class="line-added"> 652     {</span>
<span class="line-added"> 653         if (!m_genericPointerType)</span>
<span class="line-added"> 654             m_genericPointerType = AST::PointerType::create({ }, AST::AddressSpace::Thread, AST::TypeReference::wrap({ }, m_intrinsics.floatType()));</span>
<span class="line-added"> 655         return *m_genericPointerType;</span>
<span class="line-added"> 656     }</span>
<span class="line-added"> 657 </span>
<span class="line-added"> 658     AST::UnnamedType&amp; normalizedTypeForFunctionKey(AST::UnnamedType&amp; type)</span>
<span class="line-added"> 659     {</span>
<span class="line-added"> 660         auto* unifyNode = &amp;type.unifyNode();</span>
<span class="line-added"> 661         if (unifyNode == &amp;m_intrinsics.uintType() || unifyNode == &amp;m_intrinsics.intType())</span>
<span class="line-added"> 662             return wrappedFloatType();</span>
<span class="line-added"> 663 </span>
<span class="line-added"> 664         if (is&lt;AST::ReferenceType&gt;(type))</span>
<span class="line-added"> 665             return genericPointerType();</span>
<span class="line-added"> 666 </span>
<span class="line-added"> 667         return type;</span>
<span class="line-added"> 668     }</span>
<span class="line-added"> 669 </span>
<span class="line-added"> 670     RefPtr&lt;AST::TypeReference&gt; m_wrappedFloatType;</span>
<span class="line-added"> 671     RefPtr&lt;AST::UnnamedType&gt; m_genericPointerType;</span>
<span class="line-added"> 672     HashMap&lt;AST::Expression*, std::unique_ptr&lt;ResolvingType&gt;&gt; m_typeMap;</span>
<span class="line-added"> 673     HashSet&lt;String&gt; m_vertexEntryPoints[AST::nameSpaceCount];</span>
<span class="line-added"> 674     HashSet&lt;String&gt; m_fragmentEntryPoints[AST::nameSpaceCount];</span>
<span class="line-added"> 675     HashSet&lt;String&gt; m_computeEntryPoints[AST::nameSpaceCount];</span>
 676     const Intrinsics&amp; m_intrinsics;
 677     Program&amp; m_program;
<span class="line-added"> 678     AST::FunctionDefinition* m_currentFunction { nullptr };</span>
<span class="line-added"> 679     HashMap&lt;FunctionKey, Vector&lt;std::reference_wrapper&lt;AST::FunctionDeclaration&gt;, 1&gt;, FunctionKey::Hash, FunctionKey::Traits&gt; m_functions;</span>
<span class="line-added"> 680     HashMap&lt;AndOverloadTypeKey, RefPtr&lt;AST::UnnamedType&gt;, AndOverloadTypeKey::Hash, AndOverloadTypeKey::Traits&gt; m_andOverloadTypeMap;</span>
<span class="line-added"> 681     AST::NameSpace m_currentNameSpace { AST::NameSpace::StandardLibrary };</span>
 682 };
 683 
 684 void Checker::visit(Program&amp; program)
 685 {
 686     // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
 687     for (size_t i = 0; i &lt; program.typeDefinitions().size(); ++i)
 688         checkErrorAndVisit(program.typeDefinitions()[i]);
 689     for (size_t i = 0; i &lt; program.structureDefinitions().size(); ++i)
 690         checkErrorAndVisit(program.structureDefinitions()[i]);
 691     for (size_t i = 0; i &lt; program.enumerationDefinitions().size(); ++i)
 692         checkErrorAndVisit(program.enumerationDefinitions()[i]);
 693     for (size_t i = 0; i &lt; program.nativeTypeDeclarations().size(); ++i)
 694         checkErrorAndVisit(program.nativeTypeDeclarations()[i]);
 695 
 696     for (size_t i = 0; i &lt; program.functionDefinitions().size(); ++i)
 697         checkErrorAndVisit(program.functionDefinitions()[i]);
 698     for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
 699         checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
 700 }
 701 
<span class="line-modified"> 702 Expected&lt;void, Error&gt; Checker::assignTypes()</span>
 703 {
 704     for (auto&amp; keyValuePair : m_typeMap) {
<span class="line-modified"> 705         auto success = keyValuePair.value-&gt;visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
<span class="line-modified"> 706             keyValuePair.key-&gt;setType(unnamedType.copyRef());</span>
 707             return true;
<span class="line-modified"> 708         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
<span class="line-modified"> 709             if (!resolvableTypeReference-&gt;resolvableType().maybeResolvedType()) {</span>

 710                 if (!static_cast&lt;bool&gt;(commit(resolvableTypeReference-&gt;resolvableType())))
 711                     return false;
 712             }
<span class="line-modified"> 713             keyValuePair.key-&gt;setType(resolvableTypeReference-&gt;resolvableType().resolvedType());</span>
 714             return true;
<span class="line-modified"> 715         }));</span>
 716         if (!success)
<span class="line-modified"> 717             return makeUnexpected(Error(&quot;Could not resolve the type of a constant.&quot;));</span>
 718     }
 719 
<span class="line-modified"> 720     return { };</span>


 721 }
 722 
 723 bool Checker::checkShaderType(const AST::FunctionDefinition&amp; functionDefinition)
 724 {
<span class="line-added"> 725     auto index = static_cast&lt;unsigned&gt;(m_currentNameSpace);</span>
 726     switch (*functionDefinition.entryPointType()) {
 727     case AST::EntryPointType::Vertex:
<span class="line-modified"> 728         return static_cast&lt;bool&gt;(m_vertexEntryPoints[index].add(functionDefinition.name()));</span>
 729     case AST::EntryPointType::Fragment:
<span class="line-modified"> 730         return static_cast&lt;bool&gt;(m_fragmentEntryPoints[index].add(functionDefinition.name()));</span>
 731     case AST::EntryPointType::Compute:
<span class="line-modified"> 732         return static_cast&lt;bool&gt;(m_computeEntryPoints[index].add(functionDefinition.name()));</span>
 733     }
 734 }
 735 
 736 void Checker::visit(AST::FunctionDefinition&amp; functionDefinition)
 737 {
<span class="line-added"> 738     m_currentNameSpace = functionDefinition.nameSpace();</span>
<span class="line-added"> 739     m_currentFunction = &amp;functionDefinition;</span>
 740     if (functionDefinition.entryPointType()) {
 741         if (!checkShaderType(functionDefinition)) {
<span class="line-modified"> 742             setError(Error(&quot;Duplicate entrypoint function.&quot;, functionDefinition.codeLocation()));</span>
 743             return;
 744         }
 745         auto entryPointItems = gatherEntryPointItems(m_intrinsics, functionDefinition);
 746         if (!entryPointItems) {
<span class="line-modified"> 747             setError(entryPointItems.error());</span>
 748             return;
 749         }
 750         if (!checkSemantics(entryPointItems-&gt;inputs, entryPointItems-&gt;outputs, functionDefinition.entryPointType(), m_intrinsics)) {
<span class="line-modified"> 751             setError(Error(&quot;Bad semantics for entrypoint.&quot;, functionDefinition.codeLocation()));</span>
 752             return;
 753         }
 754     }
<span class="line-modified"> 755     if (!checkOperatorOverload(functionDefinition, m_program.nameContext(), m_currentNameSpace)) {</span>
<span class="line-modified"> 756         setError(Error(&quot;Operator does not match expected signature.&quot;, functionDefinition.codeLocation()));</span>
 757         return;
 758     }
 759 
<span class="line-modified"> 760     Visitor::visit(functionDefinition);</span>
 761 }
 762 
<span class="line-modified"> 763 static RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(ResolvingType&amp; left, ResolvingType&amp; right)</span>
 764 {
<span class="line-modified"> 765     return left.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; left) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 766         return right.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
 767             if (matches(left, right))
<span class="line-modified"> 768                 return left.copyRef();</span>
<span class="line-modified"> 769             return nullptr;</span>
<span class="line-modified"> 770         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
 771             return matchAndCommit(left, right-&gt;resolvableType());
<span class="line-modified"> 772         }));</span>
<span class="line-modified"> 773     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; left) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 774         return right.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
 775             return matchAndCommit(right, left-&gt;resolvableType());
<span class="line-modified"> 776         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
 777             return matchAndCommit(left-&gt;resolvableType(), right-&gt;resolvableType());
<span class="line-modified"> 778         }));</span>
<span class="line-modified"> 779     }));</span>
 780 }
 781 
<span class="line-modified"> 782 static RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::UnnamedType&amp; unnamedType)</span>
 783 {
<span class="line-modified"> 784     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
 785         if (matches(unnamedType, resolvingType))
<span class="line-modified"> 786             return &amp;unnamedType;</span>
<span class="line-modified"> 787         return nullptr;</span>
<span class="line-modified"> 788     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
 789         return matchAndCommit(unnamedType, resolvingType-&gt;resolvableType());
<span class="line-modified"> 790     }));</span>
 791 }
 792 
<span class="line-modified"> 793 static RefPtr&lt;AST::UnnamedType&gt; commit(ResolvingType&amp; resolvingType)</span>
 794 {
<span class="line-modified"> 795     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 796         return unnamedType.copyRef();</span>
<span class="line-modified"> 797     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 798         if (!resolvableTypeReference-&gt;resolvableType().maybeResolvedType())</span>
<span class="line-modified"> 799             return commit(resolvableTypeReference-&gt;resolvableType());</span>
<span class="line-modified"> 800         return &amp;resolvableTypeReference-&gt;resolvableType().resolvedType();</span>
<span class="line-modified"> 801     }));</span>
<span class="line-added"> 802 }</span>
<span class="line-added"> 803 </span>
<span class="line-added"> 804 AST::FunctionDeclaration* Checker::resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation location, AST::NamedType* castReturnType)</span>
<span class="line-added"> 805 {</span>
<span class="line-added"> 806     Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; unnamedTypes;</span>
<span class="line-added"> 807     unnamedTypes.reserveInitialCapacity(types.size());</span>
<span class="line-added"> 808 </span>
<span class="line-added"> 809     for (auto resolvingType : types) {</span>
<span class="line-added"> 810         AST::UnnamedType* type = resolvingType.get().visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
<span class="line-added"> 811             return unnamedType.ptr();</span>
<span class="line-added"> 812         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; AST::UnnamedType* {</span>
<span class="line-added"> 813             if (resolvableTypeReference-&gt;resolvableType().maybeResolvedType())</span>
<span class="line-added"> 814                 return &amp;resolvableTypeReference-&gt;resolvableType().resolvedType();</span>
<span class="line-added"> 815 </span>
<span class="line-added"> 816             if (resolvableTypeReference-&gt;resolvableType().isFloatLiteralType()</span>
<span class="line-added"> 817                 || resolvableTypeReference-&gt;resolvableType().isIntegerLiteralType()</span>
<span class="line-added"> 818                 || resolvableTypeReference-&gt;resolvableType().isUnsignedIntegerLiteralType())</span>
<span class="line-added"> 819                 return &amp;wrappedFloatType();</span>
<span class="line-added"> 820 </span>
<span class="line-added"> 821             if (resolvableTypeReference-&gt;resolvableType().isNullLiteralType())</span>
<span class="line-added"> 822                 return &amp;genericPointerType();</span>
<span class="line-added"> 823 </span>
<span class="line-added"> 824             return commit(resolvableTypeReference-&gt;resolvableType()).get();</span>
<span class="line-added"> 825         }));</span>
<span class="line-added"> 826 </span>
<span class="line-added"> 827         if (!type) {</span>
<span class="line-added"> 828             setError(Error(&quot;Could not resolve the type of a constant.&quot;));</span>
<span class="line-added"> 829             return nullptr;</span>
<span class="line-added"> 830         }</span>
<span class="line-added"> 831 </span>
<span class="line-added"> 832         unnamedTypes.uncheckedAppend(normalizedTypeForFunctionKey(*type));</span>
<span class="line-added"> 833     }</span>
<span class="line-added"> 834 </span>
<span class="line-added"> 835     {</span>
<span class="line-added"> 836         auto iter = m_functions.find(FunctionKey { name, WTFMove(unnamedTypes), castReturnType });</span>
<span class="line-added"> 837         if (iter != m_functions.end()) {</span>
<span class="line-added"> 838             if (AST::FunctionDeclaration* function = resolveFunctionOverload(iter-&gt;value, types, castReturnType, m_currentNameSpace))</span>
<span class="line-added"> 839                 return function;</span>
<span class="line-added"> 840         }</span>
<span class="line-added"> 841     }</span>
<span class="line-added"> 842 </span>
<span class="line-added"> 843     if (auto newFunction = resolveByInstantiation(name, location, types, m_intrinsics)) {</span>
<span class="line-added"> 844         m_program.append(WTFMove(*newFunction));</span>
<span class="line-added"> 845         return &amp;m_program.nativeFunctionDeclarations().last();</span>
<span class="line-added"> 846     }</span>
<span class="line-added"> 847 </span>
<span class="line-added"> 848     return nullptr;</span>
 849 }
 850 
 851 void Checker::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
 852 {
<span class="line-added"> 853     bool isSigned;</span>
 854     auto* baseType = ([&amp;]() -&gt; AST::NativeTypeDeclaration* {
 855         checkErrorAndVisit(enumerationDefinition.type());
 856         auto&amp; baseType = enumerationDefinition.type().unifyNode();
 857         if (!is&lt;AST::NamedType&gt;(baseType))
 858             return nullptr;
 859         auto&amp; namedType = downcast&lt;AST::NamedType&gt;(baseType);
 860         if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 861             return nullptr;
 862         auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 863         if (!nativeTypeDeclaration.isInt())
 864             return nullptr;
<span class="line-added"> 865         isSigned = nativeTypeDeclaration.isSigned();</span>
 866         return &amp;nativeTypeDeclaration;
 867     })();
 868     if (!baseType) {
<span class="line-modified"> 869         setError(Error(&quot;Invalid base type for enum.&quot;, enumerationDefinition.codeLocation()));</span>
 870         return;
 871     }
 872 
 873     auto enumerationMembers = enumerationDefinition.enumerationMembers();
 874 
 875     for (auto&amp; member : enumerationMembers) {
<span class="line-modified"> 876         int64_t value = member.get().value();</span>
<span class="line-modified"> 877         if (isSigned) {</span>
<span class="line-modified"> 878             if (static_cast&lt;int64_t&gt;(static_cast&lt;int32_t&gt;(value)) != value) {</span>
<span class="line-modified"> 879                 setError(Error(&quot;Invalid enumeration value.&quot;, member.get().codeLocation()));</span>



 880                 return;
<span class="line-modified"> 881             }</span>



















 882         } else {
<span class="line-modified"> 883             if (static_cast&lt;int64_t&gt;(static_cast&lt;uint32_t&gt;(value)) != value) {</span>
<span class="line-modified"> 884                 setError(Error(&quot;Invalid enumeration value.&quot;, member.get().codeLocation()));</span>
<span class="line-modified"> 885                 return;</span>
 886             }



 887         }
 888     }
 889 













 890     for (size_t i = 0; i &lt; enumerationMembers.size(); ++i) {
<span class="line-modified"> 891         auto value = enumerationMembers[i].get().value();</span>
 892         for (size_t j = i + 1; j &lt; enumerationMembers.size(); ++j) {
<span class="line-modified"> 893             auto otherValue = enumerationMembers[j].get().value();</span>
 894             if (value == otherValue) {
<span class="line-modified"> 895                 setError(Error(&quot;Cannot declare duplicate enumeration values.&quot;, enumerationMembers[j].get().codeLocation()));</span>
 896                 return;
 897             }
 898         }
 899     }
 900 
 901     bool foundZero = false;
 902     for (auto&amp; member : enumerationMembers) {
<span class="line-modified"> 903         if (!member.get().value()) {</span>
 904             foundZero = true;
 905             break;
 906         }
 907     }
 908     if (!foundZero) {
<span class="line-modified"> 909         setError(Error(&quot;enum definition must contain a zero value.&quot;, enumerationDefinition.codeLocation()));</span>
 910         return;
 911     }
 912 }
 913 
 914 void Checker::visit(AST::TypeReference&amp; typeReference)
 915 {
<span class="line-modified"> 916     ASSERT(typeReference.maybeResolvedType());</span>
 917 
<span class="line-modified"> 918     for (auto&amp; typeArgument : typeReference.typeArguments())</span>
<span class="line-added"> 919         checkErrorAndVisit(typeArgument);</span>
 920 }
 921 
<span class="line-modified"> 922 auto Checker::recurseAndGetInfo(AST::Expression&amp; expression, bool requiresLeftValue) -&gt; Optional&lt;RecurseInfo&gt;</span>
 923 {
<span class="line-modified"> 924     Visitor::visit(expression);</span>
<span class="line-modified"> 925     if (hasError())</span>
 926         return WTF::nullopt;
<span class="line-modified"> 927     return getInfo(expression, requiresLeftValue);</span>
 928 }
 929 
<span class="line-modified"> 930 auto Checker::getInfo(AST::Expression&amp; expression, bool requiresLeftValue) -&gt; Optional&lt;RecurseInfo&gt;</span>
 931 {
 932     auto typeIterator = m_typeMap.find(&amp;expression);
 933     ASSERT(typeIterator != m_typeMap.end());
 934 
<span class="line-modified"> 935     const auto&amp; typeAnnotation = expression.typeAnnotation();</span>
<span class="line-modified"> 936     if (requiresLeftValue &amp;&amp; typeAnnotation.isRightValue()) {</span>
<span class="line-modified"> 937         setError(Error(&quot;Unexpected rvalue.&quot;, expression.codeLocation()));</span>

 938         return WTF::nullopt;
 939     }
<span class="line-modified"> 940     return {{ *typeIterator-&gt;value, typeAnnotation }};</span>
 941 }
 942 
 943 void Checker::visit(AST::VariableDeclaration&amp; variableDeclaration)
 944 {
 945     // ReadModifyWriteExpressions are the only place where anonymous variables exist,
 946     // and that doesn&#39;t recurse on the anonymous variables, so we can assume the variable has a type.
 947     checkErrorAndVisit(*variableDeclaration.type());
<span class="line-added"> 948     if (matches(*variableDeclaration.type(), m_intrinsics.voidType())) {</span>
<span class="line-added"> 949         setError(Error(&quot;Variables can&#39;t have void type.&quot;, variableDeclaration.codeLocation()));</span>
<span class="line-added"> 950         return;</span>
<span class="line-added"> 951     }</span>
 952     if (variableDeclaration.initializer()) {
 953         auto&amp; lhsType = *variableDeclaration.type();
 954         auto initializerInfo = recurseAndGetInfo(*variableDeclaration.initializer());
 955         if (!initializerInfo)
 956             return;
 957         if (!matchAndCommit(initializerInfo-&gt;resolvingType, lhsType)) {
<span class="line-modified"> 958             setError(Error(&quot;Declared variable type does not match its initializer&#39;s type.&quot;, variableDeclaration.codeLocation()));</span>
 959             return;
 960         }
 961     }
 962 }
 963 
<span class="line-modified"> 964 void Checker::assignConcreteType(AST::Expression&amp; expression, Ref&lt;AST::UnnamedType&gt; unnamedType, AST::TypeAnnotation typeAnnotation = AST::RightValue())</span>
 965 {
<span class="line-modified"> 966     auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(unnamedType)));</span>
 967     ASSERT_UNUSED(addResult, addResult.isNewEntry);
<span class="line-modified"> 968     expression.setTypeAnnotation(WTFMove(typeAnnotation));</span>

 969 }
 970 
<span class="line-modified"> 971 void Checker::assignType(AST::Expression&amp; expression, RefPtr&lt;ResolvableTypeReference&gt; resolvableTypeReference, AST::TypeAnnotation typeAnnotation = AST::RightValue())</span>
 972 {
<span class="line-modified"> 973     auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(resolvableTypeReference)));</span>
 974     ASSERT_UNUSED(addResult, addResult.isNewEntry);
<span class="line-modified"> 975     expression.setTypeAnnotation(WTFMove(typeAnnotation));</span>
<span class="line-modified"> 976 }</span>
<span class="line-added"> 977 </span>
<span class="line-added"> 978 void Checker::forwardType(AST::Expression&amp; expression, ResolvingType&amp; resolvingType, AST::TypeAnnotation typeAnnotation = AST::RightValue())</span>
<span class="line-added"> 979 {</span>
<span class="line-added"> 980     resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; result) {</span>
<span class="line-added"> 981         auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(result.copyRef()));</span>
<span class="line-added"> 982         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added"> 983     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; result) {</span>
<span class="line-added"> 984         auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(result.copyRef()));</span>
<span class="line-added"> 985         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added"> 986     }));</span>
<span class="line-added"> 987     expression.setTypeAnnotation(WTFMove(typeAnnotation));</span>
 988 }
 989 
 990 void Checker::visit(AST::AssignmentExpression&amp; assignmentExpression)
 991 {
 992     auto leftInfo = recurseAndGetInfo(assignmentExpression.left(), true);
 993     if (!leftInfo)
 994         return;
 995 
 996     auto rightInfo = recurseAndGetInfo(assignmentExpression.right());
 997     if (!rightInfo)
 998         return;
 999 
1000     auto resultType = matchAndCommit(leftInfo-&gt;resolvingType, rightInfo-&gt;resolvingType);
1001     if (!resultType) {
<span class="line-modified">1002         setError(Error(&quot;Left hand side of assignment does not match the type of the right hand side.&quot;, assignmentExpression.codeLocation()));</span>
1003         return;
1004     }
1005 
<span class="line-modified">1006     assignConcreteType(assignmentExpression, *resultType);</span>













1007 }
1008 
1009 void Checker::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)
1010 {
<span class="line-modified">1011     auto leftValueInfo = recurseAndGetInfo(readModifyWriteExpression.leftValue(), true);</span>
<span class="line-modified">1012     if (!leftValueInfo)</span>
1013         return;
1014 
<span class="line-modified">1015     readModifyWriteExpression.oldValue().setType(*leftValueInfo-&gt;resolvingType.getUnnamedType());</span>
1016 
<span class="line-modified">1017     auto newValueInfo = recurseAndGetInfo(readModifyWriteExpression.newValueExpression());</span>
1018     if (!newValueInfo)
1019         return;
1020 
<span class="line-modified">1021     if (RefPtr&lt;AST::UnnamedType&gt; matchedType = matchAndCommit(leftValueInfo-&gt;resolvingType, newValueInfo-&gt;resolvingType))</span>
<span class="line-modified">1022         readModifyWriteExpression.newValue().setType(*matchedType);</span>
<span class="line-added">1023     else {</span>
<span class="line-added">1024         setError(Error(&quot;Base of the read-modify-write expression does not match the type of the new value.&quot;, readModifyWriteExpression.codeLocation()));</span>
1025         return;
1026     }
1027 
<span class="line-modified">1028     auto resultInfo = recurseAndGetInfo(readModifyWriteExpression.resultExpression());</span>
1029     if (!resultInfo)
1030         return;
1031 
1032     forwardType(readModifyWriteExpression, resultInfo-&gt;resolvingType);
1033 }
1034 
1035 static AST::UnnamedType* getUnnamedType(ResolvingType&amp; resolvingType)
1036 {
<span class="line-modified">1037     return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; type) -&gt; AST::UnnamedType* {</span>
<span class="line-modified">1038         return type.ptr();</span>
<span class="line-modified">1039     }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp; type) -&gt; AST::UnnamedType* {</span>
1040         // FIXME: If the type isn&#39;t committed, should we just commit() it now?
<span class="line-modified">1041         return type-&gt;resolvableType().maybeResolvedType();</span>
<span class="line-modified">1042     }));</span>
1043 }
1044 
1045 void Checker::visit(AST::DereferenceExpression&amp; dereferenceExpression)
1046 {
1047     auto pointerInfo = recurseAndGetInfo(dereferenceExpression.pointer());
1048     if (!pointerInfo)
1049         return;
1050 
1051     auto* unnamedType = getUnnamedType(pointerInfo-&gt;resolvingType);
1052 
1053     auto* pointerType = ([&amp;](AST::UnnamedType* unnamedType) -&gt; AST::PointerType* {
1054         if (!unnamedType)
1055             return nullptr;
1056         auto&amp; unifyNode = unnamedType-&gt;unifyNode();
1057         if (!is&lt;AST::UnnamedType&gt;(unifyNode))
1058             return nullptr;
1059         auto&amp; unnamedUnifyType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
1060         if (!is&lt;AST::PointerType&gt;(unnamedUnifyType))
1061             return nullptr;
1062         return &amp;downcast&lt;AST::PointerType&gt;(unnamedUnifyType);
1063     })(unnamedType);
1064     if (!pointerType) {
<span class="line-modified">1065         setError(Error(&quot;Cannot dereference a non-pointer type.&quot;, dereferenceExpression.codeLocation()));</span>
1066         return;
1067     }
1068 
<span class="line-modified">1069     assignConcreteType(dereferenceExpression, pointerType-&gt;elementType(), AST::LeftValue { pointerType-&gt;addressSpace() });</span>
1070 }
1071 
1072 void Checker::visit(AST::MakePointerExpression&amp; makePointerExpression)
1073 {
<span class="line-modified">1074     auto leftValueInfo = recurseAndGetInfo(makePointerExpression.leftValue(), true);</span>
<span class="line-modified">1075     if (!leftValueInfo)</span>
1076         return;
1077 
<span class="line-modified">1078     auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="line-modified">1079     if (!leftAddressSpace) {</span>
<span class="line-modified">1080         setError(Error(&quot;Cannot take the address of a non lvalue.&quot;, makePointerExpression.codeLocation()));</span>
1081         return;
1082     }
1083 
<span class="line-modified">1084     auto* leftValueType = getUnnamedType(leftValueInfo-&gt;resolvingType);</span>
<span class="line-added">1085     if (!leftValueType) {</span>
<span class="line-added">1086         setError(Error(&quot;Cannot take the address of a value without a type.&quot;, makePointerExpression.codeLocation()));</span>
<span class="line-added">1087         return;</span>
<span class="line-added">1088     }</span>
<span class="line-added">1089 </span>
<span class="line-added">1090     assignConcreteType(makePointerExpression, AST::PointerType::create(makePointerExpression.codeLocation(), *leftAddressSpace, *leftValueType));</span>
1091 }
1092 
1093 void Checker::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
1094 {
<span class="line-modified">1095     auto leftValueInfo = recurseAndGetInfo(makeArrayReferenceExpression.leftValue());</span>
<span class="line-modified">1096     if (!leftValueInfo)</span>
1097         return;
1098 
<span class="line-modified">1099     auto* leftValueType = getUnnamedType(leftValueInfo-&gt;resolvingType);</span>
<span class="line-modified">1100     if (!leftValueType) {</span>
<span class="line-modified">1101         setError(Error(&quot;Cannot make an array reference of a value without a type.&quot;, makeArrayReferenceExpression.codeLocation()));</span>
1102         return;
1103     }
1104 
<span class="line-modified">1105     auto&amp; unifyNode = leftValueType-&gt;unifyNode();</span>
1106     if (is&lt;AST::UnnamedType&gt;(unifyNode)) {
1107         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
1108         if (is&lt;AST::PointerType&gt;(unnamedType)) {
1109             auto&amp; pointerType = downcast&lt;AST::PointerType&gt;(unnamedType);
<span class="line-modified">1110             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the fact that we&#39;re not targetting the item; we&#39;re targetting the item&#39;s inner element.</span>
<span class="line-modified">1111             assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), pointerType.addressSpace(), pointerType.elementType()));</span>
1112             return;
1113         }
1114 
<span class="line-modified">1115         auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="line-modified">1116         if (!leftAddressSpace) {</span>
<span class="line-added">1117             setError(Error(&quot;Cannot make an array reference from a non-left-value.&quot;, makeArrayReferenceExpression.codeLocation()));</span>
1118             return;
1119         }
1120 
1121         if (is&lt;AST::ArrayType&gt;(unnamedType)) {
1122             auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(unnamedType);
<span class="line-modified">1123             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the number of elements.</span>
<span class="line-modified">1124             assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, arrayType.type()));</span>
1125             return;
1126         }
1127     }
1128 
<span class="line-modified">1129     auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="line-modified">1130     if (!leftAddressSpace) {</span>
<span class="line-added">1131         setError(Error(&quot;Cannot make an array reference from a non-left-value.&quot;, makeArrayReferenceExpression.codeLocation()));</span>
1132         return;
1133     }
1134 
<span class="line-modified">1135     assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, *leftValueType));</span>
1136 }
1137 
<span class="line-modified">1138 RefPtr&lt;AST::UnnamedType&gt; Checker::argumentTypeForAndOverload(AST::UnnamedType&amp; baseType, AST::AddressSpace addressSpace)</span>
1139 {
<span class="line-modified">1140     AndOverloadTypeKey key { baseType, addressSpace };</span>
<span class="line-modified">1141     {</span>
<span class="line-modified">1142         auto iter = m_andOverloadTypeMap.find(key);</span>
<span class="line-modified">1143         if (iter != m_andOverloadTypeMap.end())</span>
<span class="line-modified">1144             return iter-&gt;value;</span>
<span class="line-modified">1145     }</span>















1146 
<span class="line-modified">1147     auto createArgumentType = [&amp;] () -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified">1148         auto&amp; unifyNode = baseType.unifyNode();</span>
<span class="line-modified">1149         if (is&lt;AST::NamedType&gt;(unifyNode)) {</span>
<span class="line-modified">1150             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-modified">1151             return { AST::PointerType::create(namedType.codeLocation(), addressSpace, AST::TypeReference::wrap(namedType.codeLocation(), namedType)) };</span>
<span class="line-modified">1152         }</span>
<span class="line-modified">1153 </span>
<span class="line-modified">1154         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-modified">1155 </span>
<span class="line-modified">1156         if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))</span>
<span class="line-modified">1157             return &amp;unnamedType;</span>
<span class="line-modified">1158 </span>
<span class="line-modified">1159         if (is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="line-modified">1160             return { AST::ArrayReferenceType::create(unnamedType.codeLocation(), addressSpace, downcast&lt;AST::ArrayType&gt;(unnamedType).type()) };</span>
<span class="line-modified">1161 </span>
<span class="line-added">1162         if (is&lt;AST::PointerType&gt;(unnamedType))</span>
1163             return nullptr;

1164 
<span class="line-modified">1165         return { AST::PointerType::create(unnamedType.codeLocation(), addressSpace, unnamedType) };</span>
<span class="line-modified">1166     };</span>















1167 
<span class="line-modified">1168     auto result = createArgumentType();</span>
<span class="line-modified">1169     m_andOverloadTypeMap.add(key, result);</span>
<span class="line-modified">1170     return result;</span>
<span class="line-modified">1171 }</span>
1172 
<span class="line-modified">1173 void Checker::finishVisiting(AST::PropertyAccessExpression&amp; propertyAccessExpression, ResolvingType* additionalArgumentType)</span>
<span class="line-modified">1174 {</span>
<span class="line-added">1175     auto baseInfo = recurseAndGetInfo(propertyAccessExpression.base());</span>
<span class="line-added">1176     if (!baseInfo)</span>
<span class="line-added">1177         return;</span>
<span class="line-added">1178     auto baseUnnamedType = commit(baseInfo-&gt;resolvingType);</span>
<span class="line-added">1179     if (!baseUnnamedType) {</span>
<span class="line-added">1180         setError(Error(&quot;Cannot resolve the type of the base of a property access expression.&quot;, propertyAccessExpression.codeLocation()));</span>
1181         return;
1182     }
1183 
<span class="line-modified">1184     AST::FunctionDeclaration* getterFunction = nullptr;</span>
<span class="line-modified">1185     RefPtr&lt;AST::UnnamedType&gt; getterReturnType = nullptr;</span>
<span class="line-modified">1186     {</span>
<span class="line-modified">1187         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; getterArgumentTypes { baseInfo-&gt;resolvingType };</span>
<span class="line-modified">1188         if (additionalArgumentType)</span>
<span class="line-modified">1189             getterArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-modified">1190         auto getterName = propertyAccessExpression.getterFunctionName();</span>
<span class="line-modified">1191         getterFunction = resolveFunction(getterArgumentTypes, getterName, propertyAccessExpression.codeLocation());</span>
<span class="line-modified">1192         if (hasError())</span>















1193             return;
<span class="line-modified">1194         if (getterFunction)</span>
<span class="line-added">1195             getterReturnType = &amp;getterFunction-&gt;type();</span>
1196     }
1197 
<span class="line-modified">1198     AST::FunctionDeclaration* anderFunction = nullptr;</span>
<span class="line-modified">1199     RefPtr&lt;AST::UnnamedType&gt; anderReturnType = nullptr;</span>
<span class="line-modified">1200     auto leftAddressSpace = baseInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="line-modified">1201     if (leftAddressSpace) {</span>
<span class="line-modified">1202         if (auto argumentTypeForAndOverload = this-&gt;argumentTypeForAndOverload(*baseUnnamedType, *leftAddressSpace)) {</span>
<span class="line-modified">1203             ResolvingType argumentType = { Ref&lt;AST::UnnamedType&gt;(*argumentTypeForAndOverload) };</span>
<span class="line-modified">1204             Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; anderArgumentTypes { argumentType };</span>
<span class="line-modified">1205             if (additionalArgumentType)</span>
<span class="line-modified">1206                 anderArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-modified">1207             auto anderName = propertyAccessExpression.anderFunctionName();</span>
<span class="line-modified">1208             anderFunction = resolveFunction(anderArgumentTypes, anderName, propertyAccessExpression.codeLocation());</span>
<span class="line-modified">1209             if (hasError())</span>


1210                 return;
<span class="line-modified">1211             if (anderFunction)</span>
<span class="line-added">1212                 anderReturnType = &amp;downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).elementType(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198164 Enforce the return of anders will always be a pointer</span>
1213         }
1214     }
1215 
<span class="line-modified">1216     AST::FunctionDeclaration* threadAnderFunction = nullptr;</span>
<span class="line-modified">1217     RefPtr&lt;AST::UnnamedType&gt; threadAnderReturnType = nullptr;</span>
<span class="line-modified">1218     if (auto argumentTypeForAndOverload = this-&gt;argumentTypeForAndOverload(*baseUnnamedType, AST::AddressSpace::Thread)) {</span>
<span class="line-modified">1219         ResolvingType argumentType = { Ref&lt;AST::UnnamedType&gt;(AST::PointerType::create(propertyAccessExpression.codeLocation(), AST::AddressSpace::Thread, *baseUnnamedType)) };</span>
<span class="line-added">1220         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; threadAnderArgumentTypes { argumentType };</span>
<span class="line-added">1221         if (additionalArgumentType)</span>
<span class="line-added">1222             threadAnderArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-added">1223         auto anderName = propertyAccessExpression.anderFunctionName();</span>
<span class="line-added">1224         threadAnderFunction = resolveFunction(threadAnderArgumentTypes, anderName, propertyAccessExpression.codeLocation());</span>
<span class="line-added">1225         if (hasError())</span>
<span class="line-added">1226             return;</span>
<span class="line-added">1227         if (threadAnderFunction)</span>
<span class="line-added">1228             threadAnderReturnType = &amp;downcast&lt;AST::PointerType&gt;(threadAnderFunction-&gt;type()).elementType(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198164 Enforce the return of anders will always be a pointer</span>
<span class="line-added">1229     }</span>
1230 
<span class="line-modified">1231     if (leftAddressSpace &amp;&amp; !anderFunction &amp;&amp; !getterFunction) {</span>
<span class="line-modified">1232         setError(Error(&quot;Property access instruction must either have an ander or a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-modified">1233         return;</span>
<span class="line-modified">1234     }</span>

1235 
<span class="line-modified">1236     if (!leftAddressSpace &amp;&amp; !threadAnderFunction &amp;&amp; !getterFunction) {</span>
<span class="line-modified">1237         setError(Error(&quot;Property access instruction must either have a thread ander or a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-modified">1238         return;</span>

1239     }






1240 
<span class="line-modified">1241     if (threadAnderFunction &amp;&amp; getterFunction) {</span>
<span class="line-modified">1242         setError(Error(&quot;Cannot have both a thread ander and a getter.&quot;, propertyAccessExpression.codeLocation()));</span>


1243         return;
<span class="line-added">1244     }</span>
1245 
<span class="line-modified">1246     if (anderFunction &amp;&amp; threadAnderFunction &amp;&amp; !matches(*anderReturnType, *threadAnderReturnType)) {</span>
<span class="line-modified">1247         setError(Error(&quot;Return type of ander must match the return type of the thread ander.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-added">1248         return;</span>
<span class="line-added">1249     }</span>
1250 
<span class="line-modified">1251     if (getterFunction &amp;&amp; anderFunction &amp;&amp; !matches(*getterReturnType, *anderReturnType)) {</span>
<span class="line-modified">1252         setError(Error(&quot;Return type of ander must match the return type of the getter.&quot;, propertyAccessExpression.codeLocation()));</span>


1253         return;
<span class="line-added">1254     }</span>
1255 
<span class="line-modified">1256     if (getterFunction &amp;&amp; threadAnderFunction &amp;&amp; !matches(*getterReturnType, *threadAnderReturnType)) {</span>
<span class="line-modified">1257         setError(Error(&quot;Return type of the thread ander must match the return type of the getter.&quot;, propertyAccessExpression.codeLocation()));</span>
1258         return;
<span class="line-modified">1259     }</span>
<span class="line-modified">1260 </span>
<span class="line-modified">1261     Ref&lt;AST::UnnamedType&gt; fieldType = getterReturnType ? *getterReturnType : anderReturnType ? *anderReturnType : *threadAnderReturnType;</span>
<span class="line-added">1262 </span>
<span class="line-added">1263     AST::FunctionDeclaration* setterFunction = nullptr;</span>
<span class="line-added">1264     AST::UnnamedType* setterReturnType = nullptr;</span>
<span class="line-added">1265     {</span>
<span class="line-added">1266         ResolvingType fieldResolvingType(fieldType.copyRef());</span>
<span class="line-added">1267         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; setterArgumentTypes { baseInfo-&gt;resolvingType };</span>
<span class="line-added">1268         if (additionalArgumentType)</span>
<span class="line-added">1269             setterArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-added">1270         setterArgumentTypes.append(fieldResolvingType);</span>
<span class="line-added">1271         auto setterName = propertyAccessExpression.setterFunctionName();</span>
<span class="line-added">1272         setterFunction = resolveFunction(setterArgumentTypes, setterName, propertyAccessExpression.codeLocation());</span>
<span class="line-added">1273         if (hasError())</span>
<span class="line-added">1274             return;</span>
<span class="line-added">1275         if (setterFunction)</span>
<span class="line-added">1276             setterReturnType = &amp;setterFunction-&gt;type();</span>
<span class="line-added">1277     }</span>
<span class="line-added">1278 </span>
<span class="line-added">1279     if (setterFunction &amp;&amp; !getterFunction) {</span>
<span class="line-added">1280         setError(Error(&quot;Cannot define a setter function without a corresponding getter.&quot;, propertyAccessExpression.codeLocation()));</span>
1281         return;
1282     }
1283 
<span class="line-modified">1284     propertyAccessExpression.setGetterFunction(getterFunction);</span>
<span class="line-added">1285     propertyAccessExpression.setAnderFunction(anderFunction);</span>
<span class="line-added">1286     propertyAccessExpression.setThreadAnderFunction(threadAnderFunction);</span>
<span class="line-added">1287     propertyAccessExpression.setSetterFunction(setterFunction);</span>
<span class="line-added">1288 </span>
<span class="line-added">1289     AST::TypeAnnotation typeAnnotation = AST::RightValue();</span>
<span class="line-added">1290     if (auto leftAddressSpace = baseInfo-&gt;typeAnnotation.leftAddressSpace()) {</span>
<span class="line-added">1291         if (anderFunction)</span>
<span class="line-added">1292             typeAnnotation = AST::LeftValue { downcast&lt;AST::ReferenceType&gt;(anderFunction-&gt;type()).addressSpace() };</span>
<span class="line-added">1293         else if (setterFunction)</span>
<span class="line-added">1294             typeAnnotation = AST::AbstractLeftValue();</span>
<span class="line-added">1295     } else if (!baseInfo-&gt;typeAnnotation.isRightValue() &amp;&amp; (setterFunction || threadAnderFunction))</span>
<span class="line-added">1296         typeAnnotation = AST::AbstractLeftValue();</span>
<span class="line-added">1297     assignConcreteType(propertyAccessExpression, WTFMove(fieldType), WTFMove(typeAnnotation));</span>
<span class="line-added">1298 }</span>
<span class="line-added">1299 </span>
<span class="line-added">1300 void Checker::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-added">1301 {</span>
<span class="line-added">1302     finishVisiting(dotExpression);</span>
<span class="line-added">1303 }</span>
<span class="line-added">1304 </span>
<span class="line-added">1305 void Checker::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-added">1306 {</span>
<span class="line-added">1307     auto baseInfo = recurseAndGetInfo(indexExpression.indexExpression());</span>
<span class="line-added">1308     if (!baseInfo)</span>
<span class="line-added">1309         return;</span>
<span class="line-added">1310     finishVisiting(indexExpression, &amp;baseInfo-&gt;resolvingType);</span>
1311 }
1312 
1313 void Checker::visit(AST::VariableReference&amp; variableReference)
1314 {
1315     ASSERT(variableReference.variable());
1316     ASSERT(variableReference.variable()-&gt;type());
1317 
<span class="line-modified">1318     assignConcreteType(variableReference, *variableReference.variable()-&gt;type(), AST::LeftValue { AST::AddressSpace::Thread });</span>



1319 }
1320 
1321 void Checker::visit(AST::Return&amp; returnStatement)
1322 {

1323     if (returnStatement.value()) {
1324         auto valueInfo = recurseAndGetInfo(*returnStatement.value());
1325         if (!valueInfo)
1326             return;
<span class="line-modified">1327         if (!matchAndCommit(valueInfo-&gt;resolvingType, m_currentFunction-&gt;type()))</span>
<span class="line-modified">1328             setError(Error(&quot;Type of the return value must match the return type of the function.&quot;, returnStatement.codeLocation()));</span>
1329         return;
1330     }
1331 
<span class="line-modified">1332     if (!matches(m_currentFunction-&gt;type(), m_intrinsics.voidType()))</span>
<span class="line-modified">1333         setError(Error(&quot;Cannot return a value from a void function.&quot;, returnStatement.codeLocation()));</span>
1334 }
1335 
1336 void Checker::visit(AST::PointerType&amp;)
1337 {
1338     // Following pointer types can cause infinite loops because of data structures
1339     // like linked lists.
1340     // FIXME: Make sure this function should be empty
1341 }
1342 
1343 void Checker::visit(AST::ArrayReferenceType&amp;)
1344 {
1345     // Following array reference types can cause infinite loops because of data
1346     // structures like linked lists.
1347     // FIXME: Make sure this function should be empty
1348 }
1349 
1350 void Checker::visit(AST::IntegerLiteral&amp; integerLiteral)
1351 {
1352     assignType(integerLiteral, adoptRef(*new ResolvableTypeReference(integerLiteral.type())));
1353 }
1354 
1355 void Checker::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
1356 {
1357     assignType(unsignedIntegerLiteral, adoptRef(*new ResolvableTypeReference(unsignedIntegerLiteral.type())));
1358 }
1359 
1360 void Checker::visit(AST::FloatLiteral&amp; floatLiteral)
1361 {
1362     assignType(floatLiteral, adoptRef(*new ResolvableTypeReference(floatLiteral.type())));
1363 }
1364 
1365 void Checker::visit(AST::NullLiteral&amp; nullLiteral)
1366 {
1367     assignType(nullLiteral, adoptRef(*new ResolvableTypeReference(nullLiteral.type())));
1368 }
1369 
1370 void Checker::visit(AST::BooleanLiteral&amp; booleanLiteral)
1371 {
<span class="line-modified">1372     assignConcreteType(booleanLiteral, AST::TypeReference::wrap(booleanLiteral.codeLocation(), m_intrinsics.boolType()));</span>
1373 }
1374 
1375 void Checker::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
1376 {
1377     ASSERT(enumerationMemberLiteral.enumerationDefinition());
1378     auto&amp; enumerationDefinition = *enumerationMemberLiteral.enumerationDefinition();
<span class="line-modified">1379     assignConcreteType(enumerationMemberLiteral, AST::TypeReference::wrap(enumerationMemberLiteral.codeLocation(), enumerationDefinition));</span>
1380 }
1381 
1382 bool Checker::isBoolType(ResolvingType&amp; resolvingType)
1383 {
<span class="line-modified">1384     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; left) -&gt; bool {</span>
1385         return matches(left, m_intrinsics.boolType());
<span class="line-modified">1386     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; left) -&gt; bool {</span>
1387         return static_cast&lt;bool&gt;(matchAndCommit(m_intrinsics.boolType(), left-&gt;resolvableType()));
<span class="line-modified">1388     }));</span>
1389 }
1390 
1391 bool Checker::recurseAndRequireBoolType(AST::Expression&amp; expression)
1392 {
1393     auto expressionInfo = recurseAndGetInfo(expression);
1394     if (!expressionInfo)
1395         return false;
1396     if (!isBoolType(expressionInfo-&gt;resolvingType)) {
<span class="line-modified">1397         setError(Error(&quot;Expected bool type from expression.&quot;, expression.codeLocation()));</span>
1398         return false;
1399     }
1400     return true;
1401 }
1402 
1403 void Checker::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
1404 {
1405     if (!recurseAndRequireBoolType(logicalNotExpression.operand()))
1406         return;
<span class="line-modified">1407     assignConcreteType(logicalNotExpression, AST::TypeReference::wrap(logicalNotExpression.codeLocation(), m_intrinsics.boolType()));</span>
1408 }
1409 
1410 void Checker::visit(AST::LogicalExpression&amp; logicalExpression)
1411 {
1412     if (!recurseAndRequireBoolType(logicalExpression.left()))
1413         return;
1414     if (!recurseAndRequireBoolType(logicalExpression.right()))
1415         return;
<span class="line-modified">1416     assignConcreteType(logicalExpression, AST::TypeReference::wrap(logicalExpression.codeLocation(), m_intrinsics.boolType()));</span>
1417 }
1418 
1419 void Checker::visit(AST::IfStatement&amp; ifStatement)
1420 {
1421     if (!recurseAndRequireBoolType(ifStatement.conditional()))
1422         return;
1423     checkErrorAndVisit(ifStatement.body());
1424     if (ifStatement.elseBody())
1425         checkErrorAndVisit(*ifStatement.elseBody());
1426 }
1427 
1428 void Checker::visit(AST::WhileLoop&amp; whileLoop)
1429 {
1430     if (!recurseAndRequireBoolType(whileLoop.conditional()))
1431         return;
1432     checkErrorAndVisit(whileLoop.body());
1433 }
1434 
1435 void Checker::visit(AST::DoWhileLoop&amp; doWhileLoop)
1436 {
1437     checkErrorAndVisit(doWhileLoop.body());
1438     recurseAndRequireBoolType(doWhileLoop.conditional());
1439 }
1440 
1441 void Checker::visit(AST::ForLoop&amp; forLoop)
1442 {
<span class="line-modified">1443     checkErrorAndVisit(forLoop.initialization());</span>
<span class="line-modified">1444     if (hasError())</span>




1445         return;
1446     if (forLoop.condition()) {
1447         if (!recurseAndRequireBoolType(*forLoop.condition()))
1448             return;
1449     }
1450     if (forLoop.increment())
1451         checkErrorAndVisit(*forLoop.increment());
1452     checkErrorAndVisit(forLoop.body());
1453 }
1454 
1455 void Checker::visit(AST::SwitchStatement&amp; switchStatement)
1456 {
1457     auto* valueType = ([&amp;]() -&gt; AST::NamedType* {
1458         auto valueInfo = recurseAndGetInfo(switchStatement.value());
1459         if (!valueInfo)
1460             return nullptr;
1461         auto* valueType = getUnnamedType(valueInfo-&gt;resolvingType);
1462         if (!valueType)
1463             return nullptr;
1464         auto&amp; valueUnifyNode = valueType-&gt;unifyNode();
1465         if (!is&lt;AST::NamedType&gt;(valueUnifyNode))
1466             return nullptr;
1467         auto&amp; valueNamedUnifyNode = downcast&lt;AST::NamedType&gt;(valueUnifyNode);
1468         if (!(is&lt;AST::NativeTypeDeclaration&gt;(valueNamedUnifyNode) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(valueNamedUnifyNode).isInt())
1469             &amp;&amp; !is&lt;AST::EnumerationDefinition&gt;(valueNamedUnifyNode))
1470             return nullptr;
1471         return &amp;valueNamedUnifyNode;
1472     })();
1473     if (!valueType) {
<span class="line-modified">1474         setError(Error(&quot;Invalid type for the expression condition of the switch statement.&quot;, switchStatement.codeLocation()));</span>
1475         return;
1476     }
1477 
1478     bool hasDefault = false;
1479     for (auto&amp; switchCase : switchStatement.switchCases()) {
1480         checkErrorAndVisit(switchCase.block());
1481         if (!switchCase.value()) {
1482             hasDefault = true;
1483             continue;
1484         }
<span class="line-modified">1485         auto success = switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) -&gt; bool {</span>
<span class="line-modified">1486             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, integerLiteral.type()));</span>
<span class="line-modified">1487         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">1488             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, unsignedIntegerLiteral.type()));</span>
<span class="line-modified">1489         }, [&amp;](AST::FloatLiteral&amp; floatLiteral) -&gt; bool {</span>
<span class="line-modified">1490             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, floatLiteral.type()));</span>
<span class="line-modified">1491         }, [&amp;](AST::NullLiteral&amp; nullLiteral) -&gt; bool {</span>
<span class="line-modified">1492             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, nullLiteral.type()));</span>
<span class="line-modified">1493         }, [&amp;](AST::BooleanLiteral&amp;) -&gt; bool {</span>
<span class="line-modified">1494             return matches(*valueType, m_intrinsics.boolType());</span>
<span class="line-modified">1495         }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) -&gt; bool {</span>

1496             ASSERT(enumerationMemberLiteral.enumerationDefinition());
<span class="line-modified">1497             return matches(*valueType, *enumerationMemberLiteral.enumerationDefinition());</span>
1498         }));
1499         if (!success) {
<span class="line-modified">1500             setError(Error(&quot;Invalid type for switch case.&quot;, switchCase.codeLocation()));</span>
1501             return;
1502         }
1503     }
1504 
1505     for (size_t i = 0; i &lt; switchStatement.switchCases().size(); ++i) {
1506         auto&amp; firstCase = switchStatement.switchCases()[i];
1507         for (size_t j = i + 1; j &lt; switchStatement.switchCases().size(); ++j) {
1508             auto&amp; secondCase = switchStatement.switchCases()[j];
1509 
1510             if (static_cast&lt;bool&gt;(firstCase.value()) != static_cast&lt;bool&gt;(secondCase.value()))
1511                 continue;
1512 
1513             if (!static_cast&lt;bool&gt;(firstCase.value())) {
<span class="line-modified">1514                 setError(Error(&quot;Cannot define multiple default cases in switch statement.&quot;, secondCase.codeLocation()));</span>
1515                 return;
1516             }
1517 
<span class="line-modified">1518             auto success = firstCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; firstIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">1519                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">1520                     return firstIntegerLiteral.value() != secondIntegerLiteral.value();</span>
<span class="line-modified">1521                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">1522                     return static_cast&lt;int64_t&gt;(firstIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondUnsignedIntegerLiteral.value());</span>
<span class="line-modified">1523                 }, [](auto&amp;) -&gt; bool {</span>
<span class="line-modified">1524                     return true;</span>
1525                 }));
<span class="line-modified">1526             }, [&amp;](AST::UnsignedIntegerLiteral&amp; firstUnsignedIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">1527                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">1528                     return static_cast&lt;int64_t&gt;(firstUnsignedIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondIntegerLiteral.value());</span>
<span class="line-modified">1529                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">1530                     return firstUnsignedIntegerLiteral.value() != secondUnsignedIntegerLiteral.value();</span>
<span class="line-modified">1531                 }, [](auto&amp;) -&gt; bool {</span>
<span class="line-added">1532                     return true;</span>
1533                 }));
<span class="line-modified">1534             }, [&amp;](AST::EnumerationMemberLiteral&amp; firstEnumerationMemberLiteral) -&gt; bool {</span>
<span class="line-modified">1535                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::EnumerationMemberLiteral&amp; secondEnumerationMemberLiteral) -&gt; bool {</span>

1536                     ASSERT(firstEnumerationMemberLiteral.enumerationMember());
1537                     ASSERT(secondEnumerationMemberLiteral.enumerationMember());
<span class="line-modified">1538                     return firstEnumerationMemberLiteral.enumerationMember() != secondEnumerationMemberLiteral.enumerationMember();</span>
<span class="line-modified">1539                 }, [](auto&amp;) -&gt; bool {</span>
<span class="line-added">1540                     return true;</span>
1541                 }));
<span class="line-modified">1542             }, [](auto&amp;) -&gt; bool {</span>
<span class="line-added">1543                 return true;</span>
1544             }));
<span class="line-added">1545             if (!success) {</span>
<span class="line-added">1546                 setError(Error(&quot;Cannot define duplicate case statements in a switch.&quot;, secondCase.codeLocation()));</span>
<span class="line-added">1547                 return;</span>
<span class="line-added">1548             }</span>
1549         }
1550     }
1551 
1552     if (!hasDefault) {
1553         if (is&lt;AST::NativeTypeDeclaration&gt;(*valueType)) {
1554             HashSet&lt;int64_t&gt; values;
1555             bool zeroValueExists;
1556             for (auto&amp; switchCase : switchStatement.switchCases()) {
<span class="line-modified">1557                 auto value = switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) -&gt; int64_t {</span>
<span class="line-modified">1558                     return integerLiteral.valueForSelectedType();</span>
<span class="line-modified">1559                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) -&gt; int64_t {</span>
<span class="line-modified">1560                     return unsignedIntegerLiteral.valueForSelectedType();</span>
<span class="line-modified">1561                 }, [](auto&amp;) -&gt; int64_t {</span>

1562                     ASSERT_NOT_REACHED();
<span class="line-added">1563                     return 0;</span>
1564                 }));
1565                 if (!value)
1566                     zeroValueExists = true;
1567                 else
1568                     values.add(value);
1569             }
1570             bool success = true;
1571             downcast&lt;AST::NativeTypeDeclaration&gt;(*valueType).iterateAllValues([&amp;](int64_t value) -&gt; bool {
1572                 if (!value) {
1573                     if (!zeroValueExists) {
1574                         success = false;
1575                         return true;
1576                     }
1577                     return false;
1578                 }
1579                 if (!values.contains(value)) {
1580                     success = false;
1581                     return true;
1582                 }
1583                 return false;
1584             });
1585             if (!success) {
<span class="line-modified">1586                 setError(Error(&quot;Switch cases must be exhaustive or you must define a default case.&quot;, switchStatement.codeLocation()));</span>
1587                 return;
1588             }
1589         } else {

1590             HashSet&lt;AST::EnumerationMember*&gt; values;
1591             for (auto&amp; switchCase : switchStatement.switchCases()) {
1592                 switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
1593                     ASSERT(enumerationMemberLiteral.enumerationMember());
1594                     values.add(enumerationMemberLiteral.enumerationMember());
1595                 }, [](auto&amp;) {
1596                     ASSERT_NOT_REACHED();
1597                 }));
1598             }
1599             for (auto&amp; enumerationMember : downcast&lt;AST::EnumerationDefinition&gt;(*valueType).enumerationMembers()) {
1600                 if (!values.contains(&amp;enumerationMember.get())) {
<span class="line-modified">1601                     setError(Error(&quot;Switch cases over an enum must be exhaustive or you must define a default case.&quot;, switchStatement.codeLocation()));</span>
1602                     return;
1603                 }
1604             }
1605         }
1606     }
1607 }
1608 
1609 void Checker::visit(AST::CommaExpression&amp; commaExpression)
1610 {
1611     ASSERT(commaExpression.list().size() &gt; 0);
1612     Visitor::visit(commaExpression);
<span class="line-modified">1613     if (hasError())</span>
1614         return;
1615     auto lastInfo = getInfo(commaExpression.list().last());
1616     forwardType(commaExpression, lastInfo-&gt;resolvingType);
1617 }
1618 
1619 void Checker::visit(AST::TernaryExpression&amp; ternaryExpression)
1620 {
1621     auto predicateInfo = recurseAndRequireBoolType(ternaryExpression.predicate());
1622     if (!predicateInfo)
1623         return;
1624 
1625     auto bodyInfo = recurseAndGetInfo(ternaryExpression.bodyExpression());
1626     auto elseInfo = recurseAndGetInfo(ternaryExpression.elseExpression());
1627 
1628     auto resultType = matchAndCommit(bodyInfo-&gt;resolvingType, elseInfo-&gt;resolvingType);
1629     if (!resultType) {
<span class="line-modified">1630         setError(Error(&quot;lhs and rhs of a ternary expression must match.&quot;, ternaryExpression.codeLocation()));</span>
1631         return;
1632     }
1633 
<span class="line-modified">1634     assignConcreteType(ternaryExpression, *resultType);</span>
1635 }
1636 
1637 void Checker::visit(AST::CallExpression&amp; callExpression)
1638 {
1639     Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; types;
1640     types.reserveInitialCapacity(callExpression.arguments().size());
1641     for (auto&amp; argument : callExpression.arguments()) {
1642         auto argumentInfo = recurseAndGetInfo(argument);
1643         if (!argumentInfo)
1644             return;
1645         types.uncheckedAppend(argumentInfo-&gt;resolvingType);
1646     }
<span class="line-modified">1647     // Don&#39;t recurse on the castReturnType, because it&#39;s guaranteed to be a NamedType, which will get visited later.</span>
<span class="line-modified">1648     // We don&#39;t want to recurse to the same node twice.</span>
<span class="line-modified">1649 </span>
<span class="line-modified">1650     auto* function = resolveFunction(types, callExpression.name(), callExpression.codeLocation());</span>
<span class="line-modified">1651     if (hasError())</span>
<span class="line-added">1652         return;</span>
1653 


1654     if (!function) {
<span class="line-modified">1655         NameContext&amp; nameContext = m_program.nameContext();</span>
<span class="line-modified">1656         auto castTypes = nameContext.getTypes(callExpression.name(), m_currentNameSpace);</span>
<span class="line-modified">1657         if (castTypes.size() == 1) {</span>
<span class="line-added">1658             AST::NamedType&amp; castType = castTypes[0].get();</span>
<span class="line-added">1659             function = resolveFunction(types, &quot;operator cast&quot;_str, callExpression.codeLocation(), &amp;castType);</span>
<span class="line-added">1660             if (hasError())</span>
<span class="line-added">1661                 return;</span>
<span class="line-added">1662             if (function)</span>
<span class="line-added">1663                 callExpression.setCastData(castType);</span>
1664         }
1665     }
1666 
1667     if (!function) {
<span class="line-modified">1668         // FIXME: Add better error messages for why we can&#39;t resolve to one of the overrides.</span>
<span class="line-added">1669         // https://bugs.webkit.org/show_bug.cgi?id=200133</span>
<span class="line-added">1670         setError(Error(&quot;Cannot resolve function call to a concrete callee. Make sure you are using compatible types.&quot;, callExpression.codeLocation()));</span>
1671         return;
1672     }
1673 
1674     for (size_t i = 0; i &lt; function-&gt;parameters().size(); ++i) {
<span class="line-modified">1675         if (!matchAndCommit(types[i].get(), *function-&gt;parameters()[i]-&gt;type())) {</span>
<span class="line-modified">1676             setError(Error(makeString(&quot;Invalid type for parameter number &quot;, i + 1, &quot; in function call.&quot;), callExpression.codeLocation()));</span>
1677             return;
1678         }
1679     }
1680 
1681     callExpression.setFunction(*function);
1682 
<span class="line-modified">1683     assignConcreteType(callExpression, function-&gt;type());</span>
1684 }
1685 
<span class="line-modified">1686 Expected&lt;void, Error&gt; check(Program&amp; program)</span>
1687 {
1688     Checker checker(program.intrinsics(), program);
1689     checker.checkErrorAndVisit(program);
<span class="line-modified">1690     if (checker.hasError())</span>
<span class="line-modified">1691         return checker.result();</span>
1692     return checker.assignTypes();
1693 }
1694 
1695 } // namespace WHLSL
1696 
1697 } // namespace WebCore
1698 
1699 #endif // ENABLE(WEBGPU)
</pre>
</td>
</tr>
</table>
<center><a href="WHLSLCheckDuplicateFunctions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLChecker.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>