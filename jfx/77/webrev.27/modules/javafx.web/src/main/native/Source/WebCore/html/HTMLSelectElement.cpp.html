<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/HTMLSelectElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
   3  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   4  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   5  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   6  * Copyright (C) 2004, 2005, 2006, 2007, 2009, 2010, 2011 Apple Inc. All rights reserved.
   7  *           (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   8  * Copyright (C) 2010 Google Inc. All rights reserved.
   9  * Copyright (C) 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  10  *
  11  * This library is free software; you can redistribute it and/or
  12  * modify it under the terms of the GNU Library General Public
  13  * License as published by the Free Software Foundation; either
  14  * version 2 of the License, or (at your option) any later version.
  15  *
  16  * This library is distributed in the hope that it will be useful,
  17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19  * Library General Public License for more details.
  20  *
  21  * You should have received a copy of the GNU Library General Public License
  22  * along with this library; see the file COPYING.LIB.  If not, write to
  23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24  * Boston, MA 02110-1301, USA.
  25  *
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;HTMLSelectElement.h&quot;
  30 
  31 #include &quot;AXObjectCache.h&quot;
  32 #include &quot;DOMFormData.h&quot;
  33 #include &quot;ElementTraversal.h&quot;
  34 #include &quot;EventHandler.h&quot;
  35 #include &quot;EventNames.h&quot;
  36 #include &quot;FormController.h&quot;
  37 #include &quot;Frame.h&quot;
  38 #include &quot;GenericCachedHTMLCollection.h&quot;
  39 #include &quot;HTMLFormElement.h&quot;
  40 #include &quot;HTMLHRElement.h&quot;
  41 #include &quot;HTMLNames.h&quot;
  42 #include &quot;HTMLOptGroupElement.h&quot;
  43 #include &quot;HTMLOptionElement.h&quot;
  44 #include &quot;HTMLOptionsCollection.h&quot;
  45 #include &quot;HTMLParserIdioms.h&quot;
  46 #include &quot;KeyboardEvent.h&quot;
  47 #include &quot;LocalizedStrings.h&quot;
  48 #include &quot;MouseEvent.h&quot;
  49 #include &quot;NodeRareData.h&quot;
  50 #include &quot;Page.h&quot;
  51 #include &quot;PlatformMouseEvent.h&quot;
  52 #include &quot;RenderListBox.h&quot;
  53 #include &quot;RenderMenuList.h&quot;
  54 #include &quot;RenderTheme.h&quot;
  55 #include &quot;Settings.h&quot;
  56 #include &quot;SpatialNavigation.h&quot;
  57 #include &lt;wtf/IsoMallocInlines.h&gt;
  58 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  59 
  60 namespace WebCore {
  61 
  62 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLSelectElement);
  63 
  64 using namespace WTF::Unicode;
  65 
  66 using namespace HTMLNames;
  67 
  68 // Upper limit agreed upon with representatives of Opera and Mozilla.
  69 static const unsigned maxSelectItems = 10000;
  70 
  71 HTMLSelectElement::HTMLSelectElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)
  72     : HTMLFormControlElementWithState(tagName, document, form)
  73     , m_typeAhead(this)
  74     , m_size(0)
  75     , m_lastOnChangeIndex(-1)
  76     , m_activeSelectionAnchorIndex(-1)
  77     , m_activeSelectionEndIndex(-1)
  78     , m_isProcessingUserDrivenChange(false)
  79     , m_multiple(false)
  80     , m_activeSelectionState(false)
  81     , m_allowsNonContiguousSelection(false)
  82     , m_shouldRecalcListItems(false)
  83 {
  84     ASSERT(hasTagName(selectTag));
  85 }
  86 
  87 Ref&lt;HTMLSelectElement&gt; HTMLSelectElement::create(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)
  88 {
  89     ASSERT(tagName.matches(selectTag));
  90     return adoptRef(*new HTMLSelectElement(tagName, document, form));
  91 }
  92 
  93 void HTMLSelectElement::didRecalcStyle(Style::Change styleChange)
  94 {
  95     // Even though the options didn&#39;t necessarily change, we will call setOptionsChangedOnRenderer for its side effect
  96     // of recomputing the width of the element. We need to do that if the style change included a change in zoom level.
  97     setOptionsChangedOnRenderer();
  98     HTMLFormControlElement::didRecalcStyle(styleChange);
  99 }
 100 
 101 const AtomString&amp; HTMLSelectElement::formControlType() const
 102 {
 103     static NeverDestroyed&lt;const AtomString&gt; selectMultiple(&quot;select-multiple&quot;, AtomString::ConstructFromLiteral);
 104     static NeverDestroyed&lt;const AtomString&gt; selectOne(&quot;select-one&quot;, AtomString::ConstructFromLiteral);
 105     return m_multiple ? selectMultiple : selectOne;
 106 }
 107 
 108 void HTMLSelectElement::deselectItems(HTMLOptionElement* excludeElement)
 109 {
 110     deselectItemsWithoutValidation(excludeElement);
 111     updateValidity();
 112 }
 113 
 114 void HTMLSelectElement::optionSelectedByUser(int optionIndex, bool fireOnChangeNow, bool allowMultipleSelection)
 115 {
 116     // User interaction such as mousedown events can cause list box select elements to send change events.
 117     // This produces that same behavior for changes triggered by other code running on behalf of the user.
 118     if (!usesMenuList()) {
 119         updateSelectedState(optionToListIndex(optionIndex), allowMultipleSelection, false);
 120         updateValidity();
 121         if (auto* renderer = this-&gt;renderer())
 122             renderer-&gt;updateFromElement();
 123         if (fireOnChangeNow)
 124             listBoxOnChange();
 125         return;
 126     }
 127 
 128     // Bail out if this index is already the selected one, to avoid running unnecessary JavaScript that can mess up
 129     // autofill when there is no actual change (see https://bugs.webkit.org/show_bug.cgi?id=35256 and &lt;rdar://7467917&gt;).
 130     // The selectOption function does not behave this way, possibly because other callers need a change event even
 131     // in cases where the selected option is not change.
 132     if (optionIndex == selectedIndex())
 133         return;
 134 
 135     selectOption(optionIndex, DeselectOtherOptions | (fireOnChangeNow ? DispatchChangeEvent : 0) | UserDriven);
 136 }
 137 
 138 bool HTMLSelectElement::hasPlaceholderLabelOption() const
 139 {
 140     // The select element has no placeholder label option if it has an attribute &quot;multiple&quot; specified or a display size of non-1.
 141     //
 142     // The condition &quot;size() &gt; 1&quot; is not compliant with the HTML5 spec as of Dec 3, 2010. &quot;size() != 1&quot; is correct.
 143     // Using &quot;size() &gt; 1&quot; here because size() may be 0 in WebKit.
 144     // See the discussion at https://bugs.webkit.org/show_bug.cgi?id=43887
 145     //
 146     // &quot;0 size()&quot; happens when an attribute &quot;size&quot; is absent or an invalid size attribute is specified.
 147     // In this case, the display size should be assumed as the default.
 148     // The default display size is 1 for non-multiple select elements, and 4 for multiple select elements.
 149     //
 150     // Finally, if size() == 0 and non-multiple, the display size can be assumed as 1.
 151     if (multiple() || size() &gt; 1)
 152         return false;
 153 
 154     int listIndex = optionToListIndex(0);
 155     ASSERT(listIndex &gt;= 0);
 156     if (listIndex &lt; 0)
 157         return false;
 158     HTMLOptionElement&amp; option = downcast&lt;HTMLOptionElement&gt;(*listItems()[listIndex]);
 159     return !listIndex &amp;&amp; option.value().isEmpty();
 160 }
 161 
 162 String HTMLSelectElement::validationMessage() const
 163 {
 164     if (!willValidate())
 165         return String();
 166 
 167     if (customError())
 168         return customValidationMessage();
 169 
 170     return valueMissing() ? validationMessageValueMissingForSelectText() : String();
 171 }
 172 
 173 bool HTMLSelectElement::valueMissing() const
 174 {
 175     if (!willValidate())
 176         return false;
 177 
 178     if (!isRequired())
 179         return false;
 180 
 181     int firstSelectionIndex = selectedIndex();
 182 
 183     // If a non-placeholer label option is selected (firstSelectionIndex &gt; 0), it&#39;s not value-missing.
 184     return firstSelectionIndex &lt; 0 || (!firstSelectionIndex &amp;&amp; hasPlaceholderLabelOption());
 185 }
 186 
 187 void HTMLSelectElement::listBoxSelectItem(int listIndex, bool allowMultiplySelections, bool shift, bool fireOnChangeNow)
 188 {
 189     if (!multiple())
 190         optionSelectedByUser(listToOptionIndex(listIndex), fireOnChangeNow, false);
 191     else {
 192         updateSelectedState(listIndex, allowMultiplySelections, shift);
 193         updateValidity();
 194         if (fireOnChangeNow)
 195             listBoxOnChange();
 196     }
 197 }
 198 
 199 bool HTMLSelectElement::usesMenuList() const
 200 {
 201 #if !PLATFORM(IOS_FAMILY)
 202     if (RenderTheme::singleton().delegatesMenuListRendering())
 203         return true;
 204 
 205     return !m_multiple &amp;&amp; m_size &lt;= 1;
 206 #else
 207     return !m_multiple;
 208 #endif
 209 }
 210 
 211 int HTMLSelectElement::activeSelectionStartListIndex() const
 212 {
 213     if (m_activeSelectionAnchorIndex &gt;= 0)
 214         return m_activeSelectionAnchorIndex;
 215     return optionToListIndex(selectedIndex());
 216 }
 217 
 218 int HTMLSelectElement::activeSelectionEndListIndex() const
 219 {
 220     if (m_activeSelectionEndIndex &gt;= 0)
 221         return m_activeSelectionEndIndex;
 222     return lastSelectedListIndex();
 223 }
 224 
 225 ExceptionOr&lt;void&gt; HTMLSelectElement::add(const OptionOrOptGroupElement&amp; element, const Optional&lt;HTMLElementOrInt&gt;&amp; before)
 226 {
 227     RefPtr&lt;HTMLElement&gt; beforeElement;
 228     if (before) {
 229         beforeElement = WTF::switchOn(before.value(),
 230             [](const RefPtr&lt;HTMLElement&gt;&amp; element) -&gt; HTMLElement* { return element.get(); },
 231             [this](int index) -&gt; HTMLElement* { return item(index); }
 232         );
 233     }
 234     HTMLElement&amp; toInsert = WTF::switchOn(element,
 235         [](const auto&amp; htmlElement) -&gt; HTMLElement&amp; { return *htmlElement; }
 236     );
 237 
 238 
 239     return insertBefore(toInsert, beforeElement.get());
 240 }
 241 
 242 void HTMLSelectElement::remove(int optionIndex)
 243 {
 244     int listIndex = optionToListIndex(optionIndex);
 245     if (listIndex &lt; 0)
 246         return;
 247 
 248     listItems()[listIndex]-&gt;remove();
 249 }
 250 
 251 String HTMLSelectElement::value() const
 252 {
 253     for (auto* item : listItems()) {
 254         if (is&lt;HTMLOptionElement&gt;(*item)) {
 255             HTMLOptionElement&amp; option = downcast&lt;HTMLOptionElement&gt;(*item);
 256             if (option.selected())
 257                 return option.value();
 258         }
 259     }
 260     return emptyString();
 261 }
 262 
 263 void HTMLSelectElement::setValue(const String&amp; value)
 264 {
 265     // Find the option with value() matching the given parameter and make it the current selection.
 266     unsigned optionIndex = 0;
 267     for (auto* item : listItems()) {
 268         if (is&lt;HTMLOptionElement&gt;(*item)) {
 269             if (downcast&lt;HTMLOptionElement&gt;(*item).value() == value) {
 270                 setSelectedIndex(optionIndex);
 271                 return;
 272             }
 273             ++optionIndex;
 274         }
 275     }
 276 
 277     setSelectedIndex(-1);
 278 }
 279 
 280 bool HTMLSelectElement::isPresentationAttribute(const QualifiedName&amp; name) const
 281 {
 282     if (name == alignAttr) {
 283         // Don&#39;t map &#39;align&#39; attribute. This matches what Firefox, Opera and IE do.
 284         // See http://bugs.webkit.org/show_bug.cgi?id=12072
 285         return false;
 286     }
 287 
 288     return HTMLFormControlElementWithState::isPresentationAttribute(name);
 289 }
 290 
 291 void HTMLSelectElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 292 {
 293     if (name == sizeAttr) {
 294         unsigned oldSize = m_size;
 295         unsigned size = limitToOnlyHTMLNonNegative(value);
 296 
 297         // Ensure that we&#39;ve determined selectedness of the items at least once prior to changing the size.
 298         if (oldSize != size)
 299             updateListItemSelectedStates();
 300 
 301         m_size = size;
 302         updateValidity();
 303         if (m_size != oldSize) {
 304             invalidateStyleAndRenderersForSubtree();
 305             setRecalcListItems();
 306             updateValidity();
 307         }
 308     } else if (name == multipleAttr)
 309         parseMultipleAttribute(value);
 310     else
 311         HTMLFormControlElementWithState::parseAttribute(name, value);
 312 }
 313 
 314 int HTMLSelectElement::defaultTabIndex() const
 315 {
 316     return 0;
 317 }
 318 
 319 bool HTMLSelectElement::isKeyboardFocusable(KeyboardEvent* event) const
 320 {
 321     if (renderer())
 322         return isFocusable();
 323     return HTMLFormControlElementWithState::isKeyboardFocusable(event);
 324 }
 325 
 326 bool HTMLSelectElement::isMouseFocusable() const
 327 {
 328     if (renderer())
 329         return isFocusable();
 330     return HTMLFormControlElementWithState::isMouseFocusable();
 331 }
 332 
 333 bool HTMLSelectElement::canSelectAll() const
 334 {
 335     return !usesMenuList();
 336 }
 337 
 338 RenderPtr&lt;RenderElement&gt; HTMLSelectElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 339 {
 340 #if !PLATFORM(IOS_FAMILY)
 341     if (usesMenuList())
 342         return createRenderer&lt;RenderMenuList&gt;(*this, WTFMove(style));
 343     return createRenderer&lt;RenderListBox&gt;(*this, WTFMove(style));
 344 #else
 345     return createRenderer&lt;RenderMenuList&gt;(*this, WTFMove(style));
 346 #endif
 347 }
 348 
 349 bool HTMLSelectElement::childShouldCreateRenderer(const Node&amp; child) const
 350 {
 351     if (!HTMLFormControlElementWithState::childShouldCreateRenderer(child))
 352         return false;
 353 #if !PLATFORM(IOS_FAMILY)
 354     if (!usesMenuList())
 355         return is&lt;HTMLOptionElement&gt;(child) || is&lt;HTMLOptGroupElement&gt;(child) || validationMessageShadowTreeContains(child);
 356 #endif
 357     return validationMessageShadowTreeContains(child);
 358 }
 359 
 360 Ref&lt;HTMLCollection&gt; HTMLSelectElement::selectedOptions()
 361 {
 362     return ensureRareData().ensureNodeLists().addCachedCollection&lt;GenericCachedHTMLCollection&lt;CollectionTypeTraits&lt;SelectedOptions&gt;::traversalType&gt;&gt;(*this, SelectedOptions);
 363 }
 364 
 365 Ref&lt;HTMLOptionsCollection&gt; HTMLSelectElement::options()
 366 {
 367     return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLOptionsCollection&gt;(*this, SelectOptions);
 368 }
 369 
 370 void HTMLSelectElement::updateListItemSelectedStates()
 371 {
 372     if (m_shouldRecalcListItems)
 373         recalcListItems();
 374 }
 375 
 376 void HTMLSelectElement::childrenChanged(const ChildChange&amp; change)
 377 {
 378     setRecalcListItems();
 379     updateValidity();
 380     m_lastOnChangeSelection.clear();
 381 
 382     HTMLFormControlElementWithState::childrenChanged(change);
 383 }
 384 
 385 void HTMLSelectElement::optionElementChildrenChanged()
 386 {
 387     setRecalcListItems();
 388     updateValidity();
 389     if (auto* cache = document().existingAXObjectCache())
 390         cache-&gt;childrenChanged(this);
 391 }
 392 
 393 void HTMLSelectElement::accessKeyAction(bool sendMouseEvents)
 394 {
 395     focus();
 396     dispatchSimulatedClick(0, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
 397 }
 398 
 399 void HTMLSelectElement::setMultiple(bool multiple)
 400 {
 401     bool oldMultiple = this-&gt;multiple();
 402     int oldSelectedIndex = selectedIndex();
 403     setAttributeWithoutSynchronization(multipleAttr, multiple ? emptyAtom() : nullAtom());
 404 
 405     // Restore selectedIndex after changing the multiple flag to preserve
 406     // selection as single-line and multi-line has different defaults.
 407     if (oldMultiple != this-&gt;multiple())
 408         setSelectedIndex(oldSelectedIndex);
 409 }
 410 
 411 void HTMLSelectElement::setSize(unsigned size)
 412 {
 413     setUnsignedIntegralAttribute(sizeAttr, limitToOnlyHTMLNonNegative(size));
 414 }
 415 
 416 HTMLOptionElement* HTMLSelectElement::namedItem(const AtomString&amp; name)
 417 {
 418     return options()-&gt;namedItem(name);
 419 }
 420 
 421 HTMLOptionElement* HTMLSelectElement::item(unsigned index)
 422 {
 423     return options()-&gt;item(index);
 424 }
 425 
 426 ExceptionOr&lt;void&gt; HTMLSelectElement::setItem(unsigned index, HTMLOptionElement* option)
 427 {
 428     if (!option) {
 429         remove(index);
 430         return { };
 431     }
 432 
 433     if (index &gt; maxSelectItems - 1)
 434         index = maxSelectItems - 1;
 435 
 436     int diff = index - length();
 437 
 438     RefPtr&lt;HTMLOptionElement&gt; before;
 439     // Out of array bounds? First insert empty dummies.
 440     if (diff &gt; 0) {
 441         auto result = setLength(index);
 442         if (result.hasException())
 443             return result;
 444         // Replace an existing entry?
 445     } else if (diff &lt; 0) {
 446         before = item(index + 1);
 447         remove(index);
 448     }
 449 
 450     // Finally add the new element.
 451     auto result = add(option, HTMLElementOrInt { before.get() });
 452     if (result.hasException())
 453         return result;
 454 
 455     if (diff &gt;= 0 &amp;&amp; option-&gt;selected())
 456         optionSelectionStateChanged(*option, true);
 457 
 458     return { };
 459 }
 460 
 461 ExceptionOr&lt;void&gt; HTMLSelectElement::setLength(unsigned newLength)
 462 {
 463     if (newLength &gt; length() &amp;&amp; newLength &gt; maxSelectItems) {
 464         document().addConsoleMessage(MessageSource::Other, MessageLevel::Warning, makeString(&quot;Blocked attempt to expand the option list to &quot;, newLength, &quot; items. The maximum number of items allowed is &quot;, maxSelectItems, &#39;.&#39;));
 465         return { };
 466     }
 467 
 468     int diff = length() - newLength;
 469 
 470     if (diff &lt; 0) { // Add dummy elements.
 471         do {
 472             auto result = add(HTMLOptionElement::create(document()).ptr(), WTF::nullopt);
 473             if (result.hasException())
 474                 return result;
 475         } while (++diff);
 476     } else {
 477         auto&amp; items = listItems();
 478 
 479         // Removing children fires mutation events, which might mutate the DOM further, so we first copy out a list
 480         // of elements that we intend to remove then attempt to remove them one at a time.
 481         Vector&lt;Ref&lt;HTMLOptionElement&gt;&gt; itemsToRemove;
 482         size_t optionIndex = 0;
 483         for (auto&amp; item : items) {
 484             if (is&lt;HTMLOptionElement&gt;(*item) &amp;&amp; optionIndex++ &gt;= newLength) {
 485                 ASSERT(item-&gt;parentNode());
 486                 itemsToRemove.append(downcast&lt;HTMLOptionElement&gt;(*item));
 487             }
 488         }
 489 
 490         // FIXME: Clients can detect what order we remove the options in; is it good to remove them in ascending order?
 491         // FIXME: This ignores exceptions. A previous version passed through the exception only for the last item removed.
 492         // What exception behavior do we want?
 493         for (auto&amp; item : itemsToRemove)
 494             item-&gt;remove();
 495     }
 496     return { };
 497 }
 498 
 499 bool HTMLSelectElement::isRequiredFormControl() const
 500 {
 501     return isRequired();
 502 }
 503 
 504 bool HTMLSelectElement::willRespondToMouseClickEvents()
 505 {
 506 #if PLATFORM(IOS_FAMILY)
 507     return !isDisabledFormControl();
 508 #else
 509     return HTMLFormControlElementWithState::willRespondToMouseClickEvents();
 510 #endif
 511 }
 512 
 513 // Returns the 1st valid item |skip| items from |listIndex| in direction |direction| if there is one.
 514 // Otherwise, it returns the valid item closest to that boundary which is past |listIndex| if there is one.
 515 // Otherwise, it returns |listIndex|.
 516 // Valid means that it is enabled and an option element.
 517 int HTMLSelectElement::nextValidIndex(int listIndex, SkipDirection direction, int skip) const
 518 {
 519     ASSERT(direction == -1 || direction == 1);
 520     auto&amp; listItems = this-&gt;listItems();
 521     int lastGoodIndex = listIndex;
 522     int size = listItems.size();
 523     for (listIndex += direction; listIndex &gt;= 0 &amp;&amp; listIndex &lt; size; listIndex += direction) {
 524         --skip;
 525         if (!listItems[listIndex]-&gt;isDisabledFormControl() &amp;&amp; is&lt;HTMLOptionElement&gt;(*listItems[listIndex])) {
 526             lastGoodIndex = listIndex;
 527             if (skip &lt;= 0)
 528                 break;
 529         }
 530     }
 531     return lastGoodIndex;
 532 }
 533 
 534 int HTMLSelectElement::nextSelectableListIndex(int startIndex) const
 535 {
 536     return nextValidIndex(startIndex, SkipForwards, 1);
 537 }
 538 
 539 int HTMLSelectElement::previousSelectableListIndex(int startIndex) const
 540 {
 541     if (startIndex == -1)
 542         startIndex = listItems().size();
 543     return nextValidIndex(startIndex, SkipBackwards, 1);
 544 }
 545 
 546 int HTMLSelectElement::firstSelectableListIndex() const
 547 {
 548     auto&amp; items = listItems();
 549     int index = nextValidIndex(items.size(), SkipBackwards, INT_MAX);
 550     if (static_cast&lt;size_t&gt;(index) == items.size())
 551         return -1;
 552     return index;
 553 }
 554 
 555 int HTMLSelectElement::lastSelectableListIndex() const
 556 {
 557     return nextValidIndex(-1, SkipForwards, INT_MAX);
 558 }
 559 
 560 // Returns the index of the next valid item one page away from |startIndex| in direction |direction|.
 561 int HTMLSelectElement::nextSelectableListIndexPageAway(int startIndex, SkipDirection direction) const
 562 {
 563     auto&amp; items = listItems();
 564 
 565     // Can&#39;t use m_size because renderer forces a minimum size.
 566     int pageSize = 0;
 567     auto* renderer = this-&gt;renderer();
 568     if (is&lt;RenderListBox&gt;(*renderer))
 569         pageSize = downcast&lt;RenderListBox&gt;(*renderer).size() - 1; // -1 so we still show context.
 570 
 571     // One page away, but not outside valid bounds.
 572     // If there is a valid option item one page away, the index is chosen.
 573     // If there is no exact one page away valid option, returns startIndex or the most far index.
 574     int edgeIndex = direction == SkipForwards ? 0 : items.size() - 1;
 575     int skipAmount = pageSize + (direction == SkipForwards ? startIndex : edgeIndex - startIndex);
 576     return nextValidIndex(edgeIndex, direction, skipAmount);
 577 }
 578 
 579 void HTMLSelectElement::selectAll()
 580 {
 581     ASSERT(!usesMenuList());
 582     if (!renderer() || !m_multiple)
 583         return;
 584 
 585     // Save the selection so it can be compared to the new selectAll selection
 586     // when dispatching change events.
 587     saveLastSelection();
 588 
 589     m_activeSelectionState = true;
 590     setActiveSelectionAnchorIndex(nextSelectableListIndex(-1));
 591     setActiveSelectionEndIndex(previousSelectableListIndex(-1));
 592     if (m_activeSelectionAnchorIndex &lt; 0)
 593         return;
 594 
 595     updateListBoxSelection(false);
 596     listBoxOnChange();
 597     updateValidity();
 598 }
 599 
 600 void HTMLSelectElement::saveLastSelection()
 601 {
 602     if (usesMenuList()) {
 603         m_lastOnChangeIndex = selectedIndex();
 604         return;
 605     }
 606 
 607     m_lastOnChangeSelection.clear();
 608     for (auto&amp; element : listItems())
 609         m_lastOnChangeSelection.append(is&lt;HTMLOptionElement&gt;(*element) &amp;&amp; downcast&lt;HTMLOptionElement&gt;(*element).selected());
 610 }
 611 
 612 void HTMLSelectElement::setActiveSelectionAnchorIndex(int index)
 613 {
 614     m_activeSelectionAnchorIndex = index;
 615 
 616     // Cache the selection state so we can restore the old selection as the new
 617     // selection pivots around this anchor index.
 618     m_cachedStateForActiveSelection.clear();
 619 
 620     for (auto&amp; element : listItems())
 621         m_cachedStateForActiveSelection.append(is&lt;HTMLOptionElement&gt;(*element) &amp;&amp; downcast&lt;HTMLOptionElement&gt;(*element).selected());
 622 }
 623 
 624 void HTMLSelectElement::setActiveSelectionEndIndex(int index)
 625 {
 626     m_activeSelectionEndIndex = index;
 627 }
 628 
 629 void HTMLSelectElement::updateListBoxSelection(bool deselectOtherOptions)
 630 {
 631     ASSERT(renderer());
 632 
 633 #if !PLATFORM(IOS_FAMILY)
 634     ASSERT(renderer()-&gt;isListBox() || m_multiple);
 635 #else
 636     ASSERT(renderer()-&gt;isMenuList() || m_multiple);
 637 #endif
 638 
 639     ASSERT(!listItems().size() || m_activeSelectionAnchorIndex &gt;= 0);
 640 
 641     unsigned start = std::min(m_activeSelectionAnchorIndex, m_activeSelectionEndIndex);
 642     unsigned end = std::max(m_activeSelectionAnchorIndex, m_activeSelectionEndIndex);
 643 
 644     auto&amp; items = listItems();
 645     for (unsigned i = 0; i &lt; items.size(); ++i) {
 646         auto&amp; element = *items[i];
 647         if (!is&lt;HTMLOptionElement&gt;(element) || downcast&lt;HTMLOptionElement&gt;(element).isDisabledFormControl())
 648             continue;
 649 
 650         if (i &gt;= start &amp;&amp; i &lt;= end)
 651             downcast&lt;HTMLOptionElement&gt;(element).setSelectedState(m_activeSelectionState);
 652         else if (deselectOtherOptions || i &gt;= m_cachedStateForActiveSelection.size())
 653             downcast&lt;HTMLOptionElement&gt;(element).setSelectedState(false);
 654         else
 655             downcast&lt;HTMLOptionElement&gt;(element).setSelectedState(m_cachedStateForActiveSelection[i]);
 656     }
 657 
 658     scrollToSelection();
 659     updateValidity();
 660 }
 661 
 662 void HTMLSelectElement::listBoxOnChange()
 663 {
 664     ASSERT(!usesMenuList() || m_multiple);
 665 
 666     auto&amp; items = listItems();
 667 
 668     // If the cached selection list is empty, or the size has changed, then fire
 669     // dispatchFormControlChangeEvent, and return early.
 670     if (m_lastOnChangeSelection.isEmpty() || m_lastOnChangeSelection.size() != items.size()) {
 671         dispatchFormControlChangeEvent();
 672         return;
 673     }
 674 
 675     // Update m_lastOnChangeSelection and fire dispatchFormControlChangeEvent.
 676     bool fireOnChange = false;
 677     for (unsigned i = 0; i &lt; items.size(); ++i) {
 678         auto&amp; element = *items[i];
 679         bool selected = is&lt;HTMLOptionElement&gt;(element) &amp;&amp; downcast&lt;HTMLOptionElement&gt;(element).selected();
 680         if (selected != m_lastOnChangeSelection[i])
 681             fireOnChange = true;
 682         m_lastOnChangeSelection[i] = selected;
 683     }
 684 
 685     if (fireOnChange) {
 686         dispatchInputEvent();
 687         dispatchFormControlChangeEvent();
 688     }
 689 }
 690 
 691 void HTMLSelectElement::dispatchChangeEventForMenuList()
 692 {
 693     ASSERT(usesMenuList());
 694 
 695     int selected = selectedIndex();
 696     if (m_lastOnChangeIndex != selected &amp;&amp; m_isProcessingUserDrivenChange) {
 697         m_lastOnChangeIndex = selected;
 698         m_isProcessingUserDrivenChange = false;
 699         dispatchInputEvent();
 700         dispatchFormControlChangeEvent();
 701     }
 702 }
 703 
 704 void HTMLSelectElement::scrollToSelection()
 705 {
 706 #if !PLATFORM(IOS_FAMILY)
 707     if (usesMenuList())
 708         return;
 709 
 710     auto* renderer = this-&gt;renderer();
 711     if (!is&lt;RenderListBox&gt;(renderer))
 712         return;
 713     downcast&lt;RenderListBox&gt;(*renderer).selectionChanged();
 714 #else
 715     if (auto* renderer = this-&gt;renderer())
 716         renderer-&gt;repaint();
 717 #endif
 718 }
 719 
 720 void HTMLSelectElement::setOptionsChangedOnRenderer()
 721 {
 722     if (auto* renderer = this-&gt;renderer()) {
 723 #if !PLATFORM(IOS_FAMILY)
 724         if (is&lt;RenderMenuList&gt;(*renderer))
 725             downcast&lt;RenderMenuList&gt;(*renderer).setOptionsChanged(true);
 726         else
 727             downcast&lt;RenderListBox&gt;(*renderer).setOptionsChanged(true);
 728 #else
 729         downcast&lt;RenderMenuList&gt;(*renderer).setOptionsChanged(true);
 730 #endif
 731     }
 732 }
 733 
 734 const Vector&lt;HTMLElement*&gt;&amp; HTMLSelectElement::listItems() const
 735 {
 736     if (m_shouldRecalcListItems)
 737         recalcListItems();
 738     else {
 739 #if !ASSERT_DISABLED
 740         Vector&lt;HTMLElement*&gt; items = m_listItems;
 741         recalcListItems(false);
 742         ASSERT(items == m_listItems);
 743 #endif
 744     }
 745 
 746     return m_listItems;
 747 }
 748 
 749 void HTMLSelectElement::invalidateSelectedItems()
 750 {
 751     if (HTMLCollection* collection = cachedHTMLCollection(SelectedOptions))
 752         collection-&gt;invalidateCache();
 753 }
 754 
 755 void HTMLSelectElement::setRecalcListItems()
 756 {
 757     m_shouldRecalcListItems = true;
 758     // Manual selection anchor is reset when manipulating the select programmatically.
 759     m_activeSelectionAnchorIndex = -1;
 760     setOptionsChangedOnRenderer();
 761     invalidateStyleForSubtree();
 762     if (!isConnected()) {
 763         if (HTMLCollection* collection = cachedHTMLCollection(SelectOptions))
 764             collection-&gt;invalidateCache();
 765     }
 766     if (!isConnected())
 767         invalidateSelectedItems();
 768     if (auto* cache = document().existingAXObjectCache())
 769         cache-&gt;childrenChanged(this);
 770 }
 771 
 772 void HTMLSelectElement::recalcListItems(bool updateSelectedStates) const
 773 {
 774     m_listItems.clear();
 775 
 776     m_shouldRecalcListItems = false;
 777 
 778     RefPtr&lt;HTMLOptionElement&gt; foundSelected;
 779     RefPtr&lt;HTMLOptionElement&gt; firstOption;
 780     for (RefPtr&lt;Element&gt; currentElement = ElementTraversal::firstWithin(*this); currentElement; ) {
 781         if (!is&lt;HTMLElement&gt;(*currentElement)) {
 782             currentElement = ElementTraversal::nextSkippingChildren(*currentElement, this);
 783             continue;
 784         }
 785         HTMLElement&amp; current = downcast&lt;HTMLElement&gt;(*currentElement);
 786 
 787         // Only consider optgroup elements that are direct children of the select element.
 788         if (is&lt;HTMLOptGroupElement&gt;(current) &amp;&amp; current.parentNode() == this) {
 789             m_listItems.append(&amp;current);
 790             if (RefPtr&lt;Element&gt; nextElement = ElementTraversal::firstWithin(current)) {
 791                 currentElement = nextElement;
 792                 continue;
 793             }
 794         }
 795 
 796         if (is&lt;HTMLOptionElement&gt;(current)) {
 797             m_listItems.append(&amp;current);
 798 
 799             if (updateSelectedStates &amp;&amp; !m_multiple) {
 800                 HTMLOptionElement&amp; option = downcast&lt;HTMLOptionElement&gt;(current);
 801                 if (!firstOption)
 802                     firstOption = &amp;option;
 803                 if (option.selected()) {
 804                     if (foundSelected)
 805                         foundSelected-&gt;setSelectedState(false);
 806                     foundSelected = &amp;option;
 807                 } else if (m_size &lt;= 1 &amp;&amp; !foundSelected &amp;&amp; !option.isDisabledFormControl()) {
 808                     foundSelected = &amp;option;
 809                     foundSelected-&gt;setSelectedState(true);
 810                 }
 811             }
 812         }
 813 
 814         if (current.hasTagName(hrTag))
 815             m_listItems.append(&amp;current);
 816 
 817         // In conforming HTML code, only &lt;optgroup&gt; and &lt;option&gt; will be found
 818         // within a &lt;select&gt;. We call NodeTraversal::nextSkippingChildren so that we only step
 819         // into those tags that we choose to. For web-compat, we should cope
 820         // with the case where odd tags like a &lt;div&gt; have been added but we
 821         // handle this because such tags have already been removed from the
 822         // &lt;select&gt;&#39;s subtree at this point.
 823         currentElement = ElementTraversal::nextSkippingChildren(*currentElement, this);
 824     }
 825 
 826     if (!foundSelected &amp;&amp; m_size &lt;= 1 &amp;&amp; firstOption &amp;&amp; !firstOption-&gt;selected())
 827         firstOption-&gt;setSelectedState(true);
 828 }
 829 
 830 int HTMLSelectElement::selectedIndex() const
 831 {
 832     unsigned index = 0;
 833 
 834     // Return the number of the first option selected.
 835     for (auto&amp; element : listItems()) {
 836         if (is&lt;HTMLOptionElement&gt;(*element)) {
 837             if (downcast&lt;HTMLOptionElement&gt;(*element).selected())
 838                 return index;
 839             ++index;
 840         }
 841     }
 842 
 843     return -1;
 844 }
 845 
 846 void HTMLSelectElement::setSelectedIndex(int index)
 847 {
 848     selectOption(index, DeselectOtherOptions);
 849 }
 850 
 851 void HTMLSelectElement::optionSelectionStateChanged(HTMLOptionElement&amp; option, bool optionIsSelected)
 852 {
 853     ASSERT(option.ownerSelectElement() == this);
 854     if (optionIsSelected)
 855         selectOption(option.index());
 856     else if (!usesMenuList())
 857         selectOption(-1);
 858     else
 859         selectOption(nextSelectableListIndex(-1));
 860 }
 861 
 862 void HTMLSelectElement::selectOption(int optionIndex, SelectOptionFlags flags)
 863 {
 864     bool shouldDeselect = !m_multiple || (flags &amp; DeselectOtherOptions);
 865 
 866     auto&amp; items = listItems();
 867     int listIndex = optionToListIndex(optionIndex);
 868 
 869     RefPtr&lt;HTMLElement&gt; element;
 870     if (listIndex &gt;= 0)
 871         element = items[listIndex];
 872 
 873     if (shouldDeselect)
 874         deselectItemsWithoutValidation(element.get());
 875 
 876     if (is&lt;HTMLOptionElement&gt;(element)) {
 877         if (m_activeSelectionAnchorIndex &lt; 0 || shouldDeselect)
 878             setActiveSelectionAnchorIndex(listIndex);
 879         if (m_activeSelectionEndIndex &lt; 0 || shouldDeselect)
 880             setActiveSelectionEndIndex(listIndex);
 881         downcast&lt;HTMLOptionElement&gt;(*element).setSelectedState(true);
 882     }
 883 
 884     updateValidity();
 885 
 886     // For the menu list case, this is what makes the selected element appear.
 887     if (auto* renderer = this-&gt;renderer())
 888         renderer-&gt;updateFromElement();
 889 
 890     scrollToSelection();
 891 
 892     if (usesMenuList()) {
 893         m_isProcessingUserDrivenChange = flags &amp; UserDriven;
 894         if (flags &amp; DispatchChangeEvent)
 895             dispatchChangeEventForMenuList();
 896         if (auto* renderer = this-&gt;renderer()) {
 897             if (is&lt;RenderMenuList&gt;(*renderer))
 898                 downcast&lt;RenderMenuList&gt;(*renderer).didSetSelectedIndex(listIndex);
 899             else
 900                 downcast&lt;RenderListBox&gt;(*renderer).selectionChanged();
 901         }
 902     }
 903 }
 904 
 905 int HTMLSelectElement::optionToListIndex(int optionIndex) const
 906 {
 907     auto&amp; items = listItems();
 908     int listSize = static_cast&lt;int&gt;(items.size());
 909     if (optionIndex &lt; 0 || optionIndex &gt;= listSize)
 910         return -1;
 911 
 912     int optionIndex2 = -1;
 913     for (int listIndex = 0; listIndex &lt; listSize; ++listIndex) {
 914         if (is&lt;HTMLOptionElement&gt;(*items[listIndex])) {
 915             ++optionIndex2;
 916             if (optionIndex2 == optionIndex)
 917                 return listIndex;
 918         }
 919     }
 920 
 921     return -1;
 922 }
 923 
 924 int HTMLSelectElement::listToOptionIndex(int listIndex) const
 925 {
 926     auto&amp; items = listItems();
 927     if (listIndex &lt; 0 || listIndex &gt;= static_cast&lt;int&gt;(items.size()) || !is&lt;HTMLOptionElement&gt;(*items[listIndex]))
 928         return -1;
 929 
 930     // Actual index of option not counting OPTGROUP entries that may be in list.
 931     int optionIndex = 0;
 932     for (int i = 0; i &lt; listIndex; ++i) {
 933         if (is&lt;HTMLOptionElement&gt;(*items[i]))
 934             ++optionIndex;
 935     }
 936 
 937     return optionIndex;
 938 }
 939 
 940 void HTMLSelectElement::dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection direction)
 941 {
 942     // Save the selection so it can be compared to the new selection when
 943     // dispatching change events during blur event dispatch.
 944     if (usesMenuList())
 945         saveLastSelection();
 946     HTMLFormControlElementWithState::dispatchFocusEvent(WTFMove(oldFocusedElement), direction);
 947 }
 948 
 949 void HTMLSelectElement::dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement)
 950 {
 951     // We only need to fire change events here for menu lists, because we fire
 952     // change events for list boxes whenever the selection change is actually made.
 953     // This matches other browsers&#39; behavior.
 954     if (usesMenuList())
 955         dispatchChangeEventForMenuList();
 956     HTMLFormControlElementWithState::dispatchBlurEvent(WTFMove(newFocusedElement));
 957 }
 958 
 959 void HTMLSelectElement::deselectItemsWithoutValidation(HTMLElement* excludeElement)
 960 {
 961     for (auto&amp; element : listItems()) {
 962         if (element != excludeElement &amp;&amp; is&lt;HTMLOptionElement&gt;(*element))
 963             downcast&lt;HTMLOptionElement&gt;(*element).setSelectedState(false);
 964     }
 965 }
 966 
 967 FormControlState HTMLSelectElement::saveFormControlState() const
 968 {
 969     FormControlState state;
 970     auto&amp; items = listItems();
 971     state.reserveInitialCapacity(items.size());
 972     for (auto&amp; element : items) {
 973         if (!is&lt;HTMLOptionElement&gt;(*element))
 974             continue;
 975         auto&amp; option = downcast&lt;HTMLOptionElement&gt;(*element);
 976         if (!option.selected())
 977             continue;
 978         state.uncheckedAppend(option.value());
 979         if (!multiple())
 980             break;
 981     }
 982     return state;
 983 }
 984 
 985 size_t HTMLSelectElement::searchOptionsForValue(const String&amp; value, size_t listIndexStart, size_t listIndexEnd) const
 986 {
 987     auto&amp; items = listItems();
 988     size_t loopEndIndex = std::min(items.size(), listIndexEnd);
 989     for (size_t i = listIndexStart; i &lt; loopEndIndex; ++i) {
 990         if (!is&lt;HTMLOptionElement&gt;(*items[i]))
 991             continue;
 992         if (downcast&lt;HTMLOptionElement&gt;(*items[i]).value() == value)
 993             return i;
 994     }
 995     return notFound;
 996 }
 997 
 998 void HTMLSelectElement::restoreFormControlState(const FormControlState&amp; state)
 999 {
1000     recalcListItems();
1001 
1002     auto&amp; items = listItems();
1003     size_t itemsSize = items.size();
1004     if (!itemsSize)
1005         return;
1006 
1007     for (auto&amp; element : items) {
1008         if (!is&lt;HTMLOptionElement&gt;(*element))
1009             continue;
1010         downcast&lt;HTMLOptionElement&gt;(*element).setSelectedState(false);
1011     }
1012 
1013     if (!multiple()) {
1014         size_t foundIndex = searchOptionsForValue(state[0], 0, itemsSize);
1015         if (foundIndex != notFound)
1016             downcast&lt;HTMLOptionElement&gt;(*items[foundIndex]).setSelectedState(true);
1017     } else {
1018         size_t startIndex = 0;
1019         for (auto&amp; value : state) {
1020             size_t foundIndex = searchOptionsForValue(value, startIndex, itemsSize);
1021             if (foundIndex == notFound)
1022                 foundIndex = searchOptionsForValue(value, 0, startIndex);
1023             if (foundIndex == notFound)
1024                 continue;
1025             downcast&lt;HTMLOptionElement&gt;(*items[foundIndex]).setSelectedState(true);
1026             startIndex = foundIndex + 1;
1027         }
1028     }
1029 
1030     setOptionsChangedOnRenderer();
1031     updateValidity();
1032 }
1033 
1034 void HTMLSelectElement::parseMultipleAttribute(const AtomString&amp; value)
1035 {
1036     bool oldUsesMenuList = usesMenuList();
1037     m_multiple = !value.isNull();
1038     updateValidity();
1039     if (oldUsesMenuList != usesMenuList())
1040         invalidateStyleAndRenderersForSubtree();
1041 }
1042 
1043 bool HTMLSelectElement::appendFormData(DOMFormData&amp; formData, bool)
1044 {
1045     const AtomString&amp; name = this-&gt;name();
1046     if (name.isEmpty())
1047         return false;
1048 
1049     bool successful = false;
1050     for (auto&amp; element : listItems()) {
1051         if (is&lt;HTMLOptionElement&gt;(*element) &amp;&amp; downcast&lt;HTMLOptionElement&gt;(*element).selected() &amp;&amp; !downcast&lt;HTMLOptionElement&gt;(*element).isDisabledFormControl()) {
1052             formData.append(name, downcast&lt;HTMLOptionElement&gt;(*element).value());
1053             successful = true;
1054         }
1055     }
1056 
1057     // It&#39;s possible that this is a menulist with multiple options and nothing
1058     // will be submitted (!successful). We won&#39;t send a unselected non-disabled
1059     // option as fallback. This behavior matches to other browsers.
1060     return successful;
1061 }
1062 
1063 void HTMLSelectElement::reset()
1064 {
1065     RefPtr&lt;HTMLOptionElement&gt; firstOption;
1066     RefPtr&lt;HTMLOptionElement&gt; selectedOption;
1067 
1068     for (auto&amp; element : listItems()) {
1069         if (!is&lt;HTMLOptionElement&gt;(*element))
1070             continue;
1071 
1072         HTMLOptionElement&amp; option = downcast&lt;HTMLOptionElement&gt;(*element);
1073         if (option.hasAttributeWithoutSynchronization(selectedAttr)) {
1074             if (selectedOption &amp;&amp; !m_multiple)
1075                 selectedOption-&gt;setSelectedState(false);
1076             option.setSelectedState(true);
1077             selectedOption = &amp;option;
1078         } else
1079             option.setSelectedState(false);
1080 
1081         if (!firstOption)
1082             firstOption = &amp;option;
1083     }
1084 
1085     if (!selectedOption &amp;&amp; firstOption &amp;&amp; !m_multiple &amp;&amp; m_size &lt;= 1)
1086         firstOption-&gt;setSelectedState(true);
1087 
1088     setOptionsChangedOnRenderer();
1089     invalidateStyleForSubtree();
1090     updateValidity();
1091 }
1092 
1093 #if !PLATFORM(WIN)
1094 
1095 bool HTMLSelectElement::platformHandleKeydownEvent(KeyboardEvent* event)
1096 {
1097     if (!RenderTheme::singleton().popsMenuByArrowKeys())
1098         return false;
1099 
1100     if (!isSpatialNavigationEnabled(document().frame())) {
1101         if (event-&gt;keyIdentifier() == &quot;Down&quot; || event-&gt;keyIdentifier() == &quot;Up&quot;) {
1102             focus();
1103             // Calling focus() may cause us to lose our renderer. Return true so
1104             // that our caller doesn&#39;t process the event further, but don&#39;t set
1105             // the event as handled.
1106             auto* renderer = this-&gt;renderer();
1107             if (!is&lt;RenderMenuList&gt;(renderer))
1108                 return true;
1109 
1110             // Save the selection so it can be compared to the new selection
1111             // when dispatching change events during selectOption, which
1112             // gets called from RenderMenuList::valueChanged, which gets called
1113             // after the user makes a selection from the menu.
1114             saveLastSelection();
1115             downcast&lt;RenderMenuList&gt;(*renderer).showPopup();
1116             event-&gt;setDefaultHandled();
1117         }
1118         return true;
1119     }
1120 
1121     return false;
1122 }
1123 
1124 #endif
1125 
1126 void HTMLSelectElement::menuListDefaultEventHandler(Event&amp; event)
1127 {
1128     ASSERT(renderer());
1129     ASSERT(renderer()-&gt;isMenuList());
1130 
1131     if (event.type() == eventNames().keydownEvent) {
1132         if (!is&lt;KeyboardEvent&gt;(event))
1133             return;
1134 
1135         KeyboardEvent&amp; keyboardEvent = downcast&lt;KeyboardEvent&gt;(event);
1136         if (platformHandleKeydownEvent(&amp;keyboardEvent))
1137             return;
1138 
1139         // When using spatial navigation, we want to be able to navigate away
1140         // from the select element when the user hits any of the arrow keys,
1141         // instead of changing the selection.
1142         if (isSpatialNavigationEnabled(document().frame())) {
1143             if (!m_activeSelectionState)
1144                 return;
1145         }
1146 
1147         const String&amp; keyIdentifier = keyboardEvent.keyIdentifier();
1148         bool handled = true;
1149         auto&amp; listItems = this-&gt;listItems();
1150         int listIndex = optionToListIndex(selectedIndex());
1151 
1152         // When using caret browsing, we want to be able to move the focus
1153         // out of the select element when user hits a left or right arrow key.
1154         if (document().settings().caretBrowsingEnabled()) {
1155             if (keyIdentifier == &quot;Left&quot; || keyIdentifier == &quot;Right&quot;)
1156                 return;
1157         }
1158 
1159         if (keyIdentifier == &quot;Down&quot; || keyIdentifier == &quot;Right&quot;)
1160             listIndex = nextValidIndex(listIndex, SkipForwards, 1);
1161         else if (keyIdentifier == &quot;Up&quot; || keyIdentifier == &quot;Left&quot;)
1162             listIndex = nextValidIndex(listIndex, SkipBackwards, 1);
1163         else if (keyIdentifier == &quot;PageDown&quot;)
1164             listIndex = nextValidIndex(listIndex, SkipForwards, 3);
1165         else if (keyIdentifier == &quot;PageUp&quot;)
1166             listIndex = nextValidIndex(listIndex, SkipBackwards, 3);
1167         else if (keyIdentifier == &quot;Home&quot;)
1168             listIndex = nextValidIndex(-1, SkipForwards, 1);
1169         else if (keyIdentifier == &quot;End&quot;)
1170             listIndex = nextValidIndex(listItems.size(), SkipBackwards, 1);
1171         else
1172             handled = false;
1173 
1174         if (handled &amp;&amp; static_cast&lt;size_t&gt;(listIndex) &lt; listItems.size())
1175             selectOption(listToOptionIndex(listIndex), DeselectOtherOptions | DispatchChangeEvent | UserDriven);
1176 
1177         if (handled)
1178             keyboardEvent.setDefaultHandled();
1179     }
1180 
1181     // Use key press event here since sending simulated mouse events
1182     // on key down blocks the proper sending of the key press event.
1183     if (event.type() == eventNames().keypressEvent) {
1184         if (!is&lt;KeyboardEvent&gt;(event))
1185             return;
1186 
1187         KeyboardEvent&amp; keyboardEvent = downcast&lt;KeyboardEvent&gt;(event);
1188         int keyCode = keyboardEvent.keyCode();
1189         bool handled = false;
1190 
1191         if (keyCode == &#39; &#39; &amp;&amp; isSpatialNavigationEnabled(document().frame())) {
1192             // Use space to toggle arrow key handling for selection change or spatial navigation.
1193             m_activeSelectionState = !m_activeSelectionState;
1194             keyboardEvent.setDefaultHandled();
1195             return;
1196         }
1197 
1198         if (RenderTheme::singleton().popsMenuBySpaceOrReturn()) {
1199             if (keyCode == &#39; &#39; || keyCode == &#39;\r&#39;) {
1200                 focus();
1201 
1202                 // Calling focus() may remove the renderer or change the renderer type.
1203                 auto* renderer = this-&gt;renderer();
1204                 if (!is&lt;RenderMenuList&gt;(renderer))
1205                     return;
1206 
1207                 // Save the selection so it can be compared to the new selection
1208                 // when dispatching change events during selectOption, which
1209                 // gets called from RenderMenuList::valueChanged, which gets called
1210                 // after the user makes a selection from the menu.
1211                 saveLastSelection();
1212                 downcast&lt;RenderMenuList&gt;(*renderer).showPopup();
1213                 handled = true;
1214             }
1215         } else if (RenderTheme::singleton().popsMenuByArrowKeys()) {
1216             if (keyCode == &#39; &#39;) {
1217                 focus();
1218 
1219                 // Calling focus() may remove the renderer or change the renderer type.
1220                 auto* renderer = this-&gt;renderer();
1221                 if (!is&lt;RenderMenuList&gt;(renderer))
1222                     return;
1223 
1224                 // Save the selection so it can be compared to the new selection
1225                 // when dispatching change events during selectOption, which
1226                 // gets called from RenderMenuList::valueChanged, which gets called
1227                 // after the user makes a selection from the menu.
1228                 saveLastSelection();
1229                 downcast&lt;RenderMenuList&gt;(*renderer).showPopup();
1230                 handled = true;
1231             } else if (keyCode == &#39;\r&#39;) {
1232                 if (form())
1233                     form()-&gt;submitImplicitly(keyboardEvent, false);
1234                 dispatchChangeEventForMenuList();
1235                 handled = true;
1236             }
1237         }
1238 
1239         if (handled)
1240             keyboardEvent.setDefaultHandled();
1241     }
1242 
1243     if (event.type() == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event) &amp;&amp; downcast&lt;MouseEvent&gt;(event).button() == LeftButton) {
1244         focus();
1245 #if !PLATFORM(IOS_FAMILY)
1246         auto* renderer = this-&gt;renderer();
1247         if (is&lt;RenderMenuList&gt;(renderer)) {
1248             auto&amp; menuList = downcast&lt;RenderMenuList&gt;(*renderer);
1249             ASSERT(!menuList.popupIsVisible());
1250             // Save the selection so it can be compared to the new
1251             // selection when we call onChange during selectOption,
1252             // which gets called from RenderMenuList::valueChanged,
1253             // which gets called after the user makes a selection from
1254             // the menu.
1255             saveLastSelection();
1256             menuList.showPopup();
1257         }
1258 #endif
1259         event.setDefaultHandled();
1260     }
1261 
1262 #if !PLATFORM(IOS_FAMILY)
1263     if (event.type() == eventNames().blurEvent &amp;&amp; !focused()) {
1264         auto&amp; menuList = downcast&lt;RenderMenuList&gt;(*renderer());
1265         if (menuList.popupIsVisible())
1266             menuList.hidePopup();
1267     }
1268 #endif
1269 }
1270 
1271 void HTMLSelectElement::updateSelectedState(int listIndex, bool multi, bool shift)
1272 {
1273     auto&amp; items = listItems();
1274     int listSize = static_cast&lt;int&gt;(items.size());
1275     if (listIndex &lt; 0 || listIndex &gt;= listSize)
1276         return;
1277 
1278     // Save the selection so it can be compared to the new selection when
1279     // dispatching change events during mouseup, or after autoscroll finishes.
1280     saveLastSelection();
1281 
1282     m_activeSelectionState = true;
1283 
1284     bool shiftSelect = m_multiple &amp;&amp; shift;
1285     bool multiSelect = m_multiple &amp;&amp; multi &amp;&amp; !shift;
1286 
1287     auto&amp; clickedElement = *items[listIndex];
1288     if (is&lt;HTMLOptionElement&gt;(clickedElement)) {
1289         // Keep track of whether an active selection (like during drag
1290         // selection), should select or deselect.
1291         if (downcast&lt;HTMLOptionElement&gt;(clickedElement).selected() &amp;&amp; multiSelect)
1292             m_activeSelectionState = false;
1293         if (!m_activeSelectionState)
1294             downcast&lt;HTMLOptionElement&gt;(clickedElement).setSelectedState(false);
1295     }
1296 
1297     // If we&#39;re not in any special multiple selection mode, then deselect all
1298     // other items, excluding the clicked option. If no option was clicked, then
1299     // this will deselect all items in the list.
1300     if (!shiftSelect &amp;&amp; !multiSelect)
1301         deselectItemsWithoutValidation(&amp;clickedElement);
1302 
1303     // If the anchor hasn&#39;t been set, and we&#39;re doing a single selection or a
1304     // shift selection, then initialize the anchor to the first selected index.
1305     if (m_activeSelectionAnchorIndex &lt; 0 &amp;&amp; !multiSelect)
1306         setActiveSelectionAnchorIndex(selectedIndex());
1307 
1308     // Set the selection state of the clicked option.
1309     if (is&lt;HTMLOptionElement&gt;(clickedElement) &amp;&amp; !downcast&lt;HTMLOptionElement&gt;(clickedElement).isDisabledFormControl())
1310         downcast&lt;HTMLOptionElement&gt;(clickedElement).setSelectedState(true);
1311 
1312     // If there was no selectedIndex() for the previous initialization, or If
1313     // we&#39;re doing a single selection, or a multiple selection (using cmd or
1314     // ctrl), then initialize the anchor index to the listIndex that just got
1315     // clicked.
1316     if (m_activeSelectionAnchorIndex &lt; 0 || !shiftSelect)
1317         setActiveSelectionAnchorIndex(listIndex);
1318 
1319     setActiveSelectionEndIndex(listIndex);
1320     updateListBoxSelection(!multiSelect);
1321 }
1322 
1323 void HTMLSelectElement::listBoxDefaultEventHandler(Event&amp; event)
1324 {
1325     auto&amp; listItems = this-&gt;listItems();
1326 
1327     if (event.type() == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event) &amp;&amp; downcast&lt;MouseEvent&gt;(event).button() == LeftButton) {
1328         focus();
1329 
1330         // Calling focus() may remove or change our renderer, in which case we don&#39;t want to handle the event further.
1331         auto* renderer = this-&gt;renderer();
1332         if (!is&lt;RenderListBox&gt;(renderer))
1333             return;
1334         auto&amp; renderListBox = downcast&lt;RenderListBox&gt;(*renderer);
1335 
1336         // Convert to coords relative to the list box if needed.
1337         MouseEvent&amp; mouseEvent = downcast&lt;MouseEvent&gt;(event);
1338         IntPoint localOffset = roundedIntPoint(renderListBox.absoluteToLocal(mouseEvent.absoluteLocation(), UseTransforms));
1339         int listIndex = renderListBox.listIndexAtOffset(toIntSize(localOffset));
1340         if (listIndex &gt;= 0) {
1341             if (!isDisabledFormControl()) {
1342 #if PLATFORM(COCOA)
1343                 updateSelectedState(listIndex, mouseEvent.metaKey(), mouseEvent.shiftKey());
1344 #else
1345                 updateSelectedState(listIndex, mouseEvent.ctrlKey(), mouseEvent.shiftKey());
1346 #endif
1347             }
1348             if (RefPtr&lt;Frame&gt; frame = document().frame())
1349                 frame-&gt;eventHandler().setMouseDownMayStartAutoscroll();
1350 
1351             mouseEvent.setDefaultHandled();
1352         }
1353     } else if (event.type() == eventNames().mousemoveEvent &amp;&amp; is&lt;MouseEvent&gt;(event) &amp;&amp; !downcast&lt;RenderListBox&gt;(*renderer()).canBeScrolledAndHasScrollableArea()) {
1354         MouseEvent&amp; mouseEvent = downcast&lt;MouseEvent&gt;(event);
1355         if (mouseEvent.button() != LeftButton || !mouseEvent.buttonDown())
1356             return;
1357 
1358         auto&amp; renderListBox = downcast&lt;RenderListBox&gt;(*renderer());
1359         IntPoint localOffset = roundedIntPoint(renderListBox.absoluteToLocal(mouseEvent.absoluteLocation(), UseTransforms));
1360         int listIndex = renderListBox.listIndexAtOffset(toIntSize(localOffset));
1361         if (listIndex &gt;= 0) {
1362             if (!isDisabledFormControl()) {
1363                 if (m_multiple) {
1364                     // Only extend selection if there is something selected.
1365                     if (m_activeSelectionAnchorIndex &lt; 0)
1366                         return;
1367 
1368                     setActiveSelectionEndIndex(listIndex);
1369                     updateListBoxSelection(false);
1370                 } else {
1371                     setActiveSelectionAnchorIndex(listIndex);
1372                     setActiveSelectionEndIndex(listIndex);
1373                     updateListBoxSelection(true);
1374                 }
1375             }
1376             mouseEvent.setDefaultHandled();
1377         }
1378     } else if (event.type() == eventNames().mouseupEvent &amp;&amp; is&lt;MouseEvent&gt;(event) &amp;&amp; downcast&lt;MouseEvent&gt;(event).button() == LeftButton &amp;&amp; document().frame()-&gt;eventHandler().autoscrollRenderer() != renderer()) {
1379         // This click or drag event was not over any of the options.
1380         if (m_lastOnChangeSelection.isEmpty())
1381             return;
1382         // This makes sure we fire dispatchFormControlChangeEvent for a single
1383         // click. For drag selection, onChange will fire when the autoscroll
1384         // timer stops.
1385         listBoxOnChange();
1386     } else if (event.type() == eventNames().keydownEvent) {
1387         if (!is&lt;KeyboardEvent&gt;(event))
1388             return;
1389 
1390         KeyboardEvent&amp; keyboardEvent = downcast&lt;KeyboardEvent&gt;(event);
1391         const String&amp; keyIdentifier = keyboardEvent.keyIdentifier();
1392 
1393         bool handled = false;
1394         int endIndex = 0;
1395         if (m_activeSelectionEndIndex &lt; 0) {
1396             // Initialize the end index
1397             if (keyIdentifier == &quot;Down&quot; || keyIdentifier == &quot;PageDown&quot;) {
1398                 int startIndex = lastSelectedListIndex();
1399                 handled = true;
1400                 if (keyIdentifier == &quot;Down&quot;)
1401                     endIndex = nextSelectableListIndex(startIndex);
1402                 else
1403                     endIndex = nextSelectableListIndexPageAway(startIndex, SkipForwards);
1404             } else if (keyIdentifier == &quot;Up&quot; || keyIdentifier == &quot;PageUp&quot;) {
1405                 int startIndex = optionToListIndex(selectedIndex());
1406                 handled = true;
1407                 if (keyIdentifier == &quot;Up&quot;)
1408                     endIndex = previousSelectableListIndex(startIndex);
1409                 else
1410                     endIndex = nextSelectableListIndexPageAway(startIndex, SkipBackwards);
1411             }
1412         } else {
1413             // Set the end index based on the current end index.
1414             if (keyIdentifier == &quot;Down&quot;) {
1415                 endIndex = nextSelectableListIndex(m_activeSelectionEndIndex);
1416                 handled = true;
1417             } else if (keyIdentifier == &quot;Up&quot;) {
1418                 endIndex = previousSelectableListIndex(m_activeSelectionEndIndex);
1419                 handled = true;
1420             } else if (keyIdentifier == &quot;PageDown&quot;) {
1421                 endIndex = nextSelectableListIndexPageAway(m_activeSelectionEndIndex, SkipForwards);
1422                 handled = true;
1423             } else if (keyIdentifier == &quot;PageUp&quot;) {
1424                 endIndex = nextSelectableListIndexPageAway(m_activeSelectionEndIndex, SkipBackwards);
1425                 handled = true;
1426             }
1427         }
1428         if (keyIdentifier == &quot;Home&quot;) {
1429             endIndex = firstSelectableListIndex();
1430             handled = true;
1431         } else if (keyIdentifier == &quot;End&quot;) {
1432             endIndex = lastSelectableListIndex();
1433             handled = true;
1434         }
1435 
1436         if (isSpatialNavigationEnabled(document().frame()))
1437             // Check if the selection moves to the boundary.
1438             if (keyIdentifier == &quot;Left&quot; || keyIdentifier == &quot;Right&quot; || ((keyIdentifier == &quot;Down&quot; || keyIdentifier == &quot;Up&quot;) &amp;&amp; endIndex == m_activeSelectionEndIndex))
1439                 return;
1440 
1441         if (endIndex &gt;= 0 &amp;&amp; handled) {
1442             // Save the selection so it can be compared to the new selection
1443             // when dispatching change events immediately after making the new
1444             // selection.
1445             saveLastSelection();
1446 
1447             ASSERT_UNUSED(listItems, !listItems.size() || static_cast&lt;size_t&gt;(endIndex) &lt; listItems.size());
1448             setActiveSelectionEndIndex(endIndex);
1449 
1450 #if PLATFORM(COCOA)
1451             m_allowsNonContiguousSelection = m_multiple &amp;&amp; isSpatialNavigationEnabled(document().frame());
1452 #else
1453             m_allowsNonContiguousSelection = m_multiple &amp;&amp; (isSpatialNavigationEnabled(document().frame()) || keyboardEvent.ctrlKey());
1454 #endif
1455             bool selectNewItem = keyboardEvent.shiftKey() || !m_allowsNonContiguousSelection;
1456 
1457             if (selectNewItem)
1458                 m_activeSelectionState = true;
1459             // If the anchor is unitialized, or if we&#39;re going to deselect all
1460             // other options, then set the anchor index equal to the end index.
1461             bool deselectOthers = !m_multiple || (!keyboardEvent.shiftKey() &amp;&amp; selectNewItem);
1462             if (m_activeSelectionAnchorIndex &lt; 0 || deselectOthers) {
1463                 if (deselectOthers)
1464                     deselectItemsWithoutValidation();
1465                 setActiveSelectionAnchorIndex(m_activeSelectionEndIndex);
1466             }
1467 
1468             downcast&lt;RenderListBox&gt;(*renderer()).scrollToRevealElementAtListIndex(endIndex);
1469             if (selectNewItem) {
1470                 updateListBoxSelection(deselectOthers);
1471                 listBoxOnChange();
1472             } else
1473                 scrollToSelection();
1474 
1475             keyboardEvent.setDefaultHandled();
1476         }
1477     } else if (event.type() == eventNames().keypressEvent) {
1478         if (!is&lt;KeyboardEvent&gt;(event))
1479             return;
1480         KeyboardEvent&amp; keyboardEvent = downcast&lt;KeyboardEvent&gt;(event);
1481         int keyCode = keyboardEvent.keyCode();
1482 
1483         if (keyCode == &#39;\r&#39;) {
1484             if (form())
1485                 form()-&gt;submitImplicitly(keyboardEvent, false);
1486             keyboardEvent.setDefaultHandled();
1487         } else if (m_multiple &amp;&amp; keyCode == &#39; &#39; &amp;&amp; m_allowsNonContiguousSelection) {
1488             // Use space to toggle selection change.
1489             m_activeSelectionState = !m_activeSelectionState;
1490             ASSERT(m_activeSelectionEndIndex &gt;= 0);
1491             ASSERT(m_activeSelectionEndIndex &lt; static_cast&lt;int&gt;(listItems.size()));
1492             ASSERT(is&lt;HTMLOptionElement&gt;(*listItems[m_activeSelectionEndIndex]));
1493             updateSelectedState(m_activeSelectionEndIndex, true /*multi*/, false /*shift*/);
1494             listBoxOnChange();
1495             keyboardEvent.setDefaultHandled();
1496         }
1497     }
1498 }
1499 
1500 void HTMLSelectElement::defaultEventHandler(Event&amp; event)
1501 {
1502     auto* renderer = this-&gt;renderer();
1503     if (!renderer)
1504         return;
1505 
1506 #if !PLATFORM(IOS_FAMILY)
1507     if (isDisabledFormControl()) {
1508         HTMLFormControlElementWithState::defaultEventHandler(event);
1509         return;
1510     }
1511 
1512     if (renderer-&gt;isMenuList())
1513         menuListDefaultEventHandler(event);
1514     else
1515         listBoxDefaultEventHandler(event);
1516 #else
1517     menuListDefaultEventHandler(event);
1518 #endif
1519     if (event.defaultHandled())
1520         return;
1521 
1522     if (event.type() == eventNames().keypressEvent &amp;&amp; is&lt;KeyboardEvent&gt;(event)) {
1523         KeyboardEvent&amp; keyboardEvent = downcast&lt;KeyboardEvent&gt;(event);
1524         if (!keyboardEvent.ctrlKey() &amp;&amp; !keyboardEvent.altKey() &amp;&amp; !keyboardEvent.metaKey() &amp;&amp; u_isprint(keyboardEvent.charCode())) {
1525             typeAheadFind(keyboardEvent);
1526             event.setDefaultHandled();
1527             return;
1528         }
1529     }
1530     HTMLFormControlElementWithState::defaultEventHandler(event);
1531 }
1532 
1533 int HTMLSelectElement::lastSelectedListIndex() const
1534 {
1535     auto&amp; items = listItems();
1536     for (size_t i = items.size(); i;) {
1537         auto&amp; element = *items[--i];
1538         if (is&lt;HTMLOptionElement&gt;(element) &amp;&amp; downcast&lt;HTMLOptionElement&gt;(element).selected())
1539             return i;
1540     }
1541     return -1;
1542 }
1543 
1544 int HTMLSelectElement::indexOfSelectedOption() const
1545 {
1546     return optionToListIndex(selectedIndex());
1547 }
1548 
1549 int HTMLSelectElement::optionCount() const
1550 {
1551     return listItems().size();
1552 }
1553 
1554 String HTMLSelectElement::optionAtIndex(int index) const
1555 {
1556     auto&amp; element = *listItems()[index];
1557     if (!is&lt;HTMLOptionElement&gt;(element) || downcast&lt;HTMLOptionElement&gt;(element).isDisabledFormControl())
1558         return String();
1559     return downcast&lt;HTMLOptionElement&gt;(element).textIndentedToRespectGroupLabel();
1560 }
1561 
1562 void HTMLSelectElement::typeAheadFind(KeyboardEvent&amp; event)
1563 {
1564     int index = m_typeAhead.handleEvent(&amp;event, TypeAhead::MatchPrefix | TypeAhead::CycleFirstChar);
1565     if (index &lt; 0)
1566         return;
1567     selectOption(listToOptionIndex(index), DeselectOtherOptions | DispatchChangeEvent | UserDriven);
1568     if (!usesMenuList())
1569         listBoxOnChange();
1570 }
1571 
1572 Node::InsertedIntoAncestorResult HTMLSelectElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
1573 {
1574     // When the element is created during document parsing, it won&#39;t have any
1575     // items yet - but for innerHTML and related methods, this method is called
1576     // after the whole subtree is constructed.
1577     recalcListItems();
1578     return HTMLFormControlElementWithState::insertedIntoAncestor(insertionType, parentOfInsertedTree);
1579 }
1580 
1581 void HTMLSelectElement::accessKeySetSelectedIndex(int index)
1582 {
1583     // First bring into focus the list box.
1584     if (!focused())
1585         accessKeyAction(false);
1586 
1587     // If this index is already selected, unselect. otherwise update the selected index.
1588     auto&amp; items = listItems();
1589     int listIndex = optionToListIndex(index);
1590     if (listIndex &gt;= 0) {
1591         auto&amp; element = *items[listIndex];
1592         if (is&lt;HTMLOptionElement&gt;(element)) {
1593             if (downcast&lt;HTMLOptionElement&gt;(element).selected())
1594                 downcast&lt;HTMLOptionElement&gt;(element).setSelectedState(false);
1595             else
1596                 selectOption(index, DispatchChangeEvent | UserDriven);
1597         }
1598     }
1599 
1600     if (usesMenuList())
1601         dispatchChangeEventForMenuList();
1602     else
1603         listBoxOnChange();
1604 
1605     scrollToSelection();
1606 }
1607 
1608 unsigned HTMLSelectElement::length() const
1609 {
1610     unsigned options = 0;
1611 
1612     auto&amp; items = listItems();
1613     for (unsigned i = 0; i &lt; items.size(); ++i) {
1614         if (is&lt;HTMLOptionElement&gt;(*items[i]))
1615             ++options;
1616     }
1617 
1618     return options;
1619 }
1620 
1621 } // namespace
    </pre>
  </body>
</html>