<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Node.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Node.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NodeIterator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Node.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  *
 23  */
 24 
 25 #pragma once
 26 
 27 #include &quot;EventTarget.h&quot;
 28 #include &quot;ExceptionOr.h&quot;
 29 #include &quot;LayoutRect.h&quot;
 30 #include &quot;MutationObserver.h&quot;
 31 #include &quot;RenderStyleConstants.h&quot;
 32 #include &quot;StyleValidity.h&quot;
 33 #include &quot;TreeScope.h&quot;

 34 #include &lt;wtf/Forward.h&gt;
 35 #include &lt;wtf/IsoMalloc.h&gt;
 36 #include &lt;wtf/ListHashSet.h&gt;
 37 #include &lt;wtf/MainThread.h&gt;
 38 #include &lt;wtf/URLHash.h&gt;
 39 
 40 // This needs to be here because Document.h also depends on it.
 41 #define DUMP_NODE_STATISTICS 0
 42 
 43 namespace WebCore {
 44 
 45 class ContainerNode;
 46 class Document;
 47 class Element;
 48 class FloatPoint;
 49 class HTMLQualifiedName;
 50 class HTMLSlotElement;
 51 class MathMLQualifiedName;
 52 class NamedNodeMap;
 53 class NodeList;
 54 class NodeListsNodeData;
 55 class NodeRareData;
 56 class QualifiedName;
 57 class RenderBox;
 58 class RenderBoxModelObject;
 59 class RenderObject;
 60 class RenderStyle;
 61 class SVGQualifiedName;
 62 class ShadowRoot;
 63 class TouchEvent;
 64 
 65 using NodeOrString = Variant&lt;RefPtr&lt;Node&gt;, String&gt;;
 66 
<span class="line-removed"> 67 class NodeRareDataBase {</span>
<span class="line-removed"> 68 public:</span>
<span class="line-removed"> 69     RenderObject* renderer() const { return m_renderer; }</span>
<span class="line-removed"> 70     void setRenderer(RenderObject* renderer) { m_renderer = renderer; }</span>
<span class="line-removed"> 71 </span>
<span class="line-removed"> 72 protected:</span>
<span class="line-removed"> 73     NodeRareDataBase(RenderObject* renderer)</span>
<span class="line-removed"> 74         : m_renderer(renderer)</span>
<span class="line-removed"> 75     { }</span>
<span class="line-removed"> 76 </span>
<span class="line-removed"> 77 private:</span>
<span class="line-removed"> 78     RenderObject* m_renderer;</span>
<span class="line-removed"> 79 };</span>
<span class="line-removed"> 80 </span>
 81 class Node : public EventTarget {
 82     WTF_MAKE_ISO_ALLOCATED(Node);
 83 
 84     friend class Document;
 85     friend class TreeScope;
 86 public:
 87     enum NodeType {
 88         ELEMENT_NODE = 1,
 89         ATTRIBUTE_NODE = 2,
 90         TEXT_NODE = 3,
 91         CDATA_SECTION_NODE = 4,
 92         PROCESSING_INSTRUCTION_NODE = 7,
 93         COMMENT_NODE = 8,
 94         DOCUMENT_NODE = 9,
 95         DOCUMENT_TYPE_NODE = 10,
 96         DOCUMENT_FRAGMENT_NODE = 11,
 97     };
 98     enum DeprecatedNodeType {
 99         ENTITY_REFERENCE_NODE = 5,
100         ENTITY_NODE = 6,
</pre>
<hr />
<pre>
148     WEBCORE_EXPORT const URL&amp; baseURI() const;
149 
150     void getSubresourceURLs(ListHashSet&lt;URL&gt;&amp;) const;
151 
152     WEBCORE_EXPORT ExceptionOr&lt;void&gt; insertBefore(Node&amp; newChild, Node* refChild);
153     WEBCORE_EXPORT ExceptionOr&lt;void&gt; replaceChild(Node&amp; newChild, Node&amp; oldChild);
154     WEBCORE_EXPORT ExceptionOr&lt;void&gt; removeChild(Node&amp; child);
155     WEBCORE_EXPORT ExceptionOr&lt;void&gt; appendChild(Node&amp; newChild);
156 
157     bool hasChildNodes() const { return firstChild(); }
158 
159     enum class CloningOperation {
160         OnlySelf,
161         SelfWithTemplateContent,
162         Everything,
163     };
164     virtual Ref&lt;Node&gt; cloneNodeInternal(Document&amp;, CloningOperation) = 0;
165     Ref&lt;Node&gt; cloneNode(bool deep) { return cloneNodeInternal(document(), deep ? CloningOperation::Everything : CloningOperation::OnlySelf); }
166     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Node&gt;&gt; cloneNodeForBindings(bool deep);
167 
<span class="line-modified">168     virtual const AtomicString&amp; localName() const;</span>
<span class="line-modified">169     virtual const AtomicString&amp; namespaceURI() const;</span>
<span class="line-modified">170     virtual const AtomicString&amp; prefix() const;</span>
<span class="line-modified">171     virtual ExceptionOr&lt;void&gt; setPrefix(const AtomicString&amp;);</span>
172     WEBCORE_EXPORT void normalize();
173 
174     bool isSameNode(Node* other) const { return this == other; }
175     WEBCORE_EXPORT bool isEqualNode(Node*) const;
<span class="line-modified">176     WEBCORE_EXPORT bool isDefaultNamespace(const AtomicString&amp; namespaceURI) const;</span>
<span class="line-modified">177     WEBCORE_EXPORT const AtomicString&amp; lookupPrefix(const AtomicString&amp; namespaceURI) const;</span>
<span class="line-modified">178     WEBCORE_EXPORT const AtomicString&amp; lookupNamespaceURI(const AtomicString&amp; prefix) const;</span>
179 
180     WEBCORE_EXPORT String textContent(bool convertBRsToNewlines = false) const;
181     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setTextContent(const String&amp;);
182 
183     Node* lastDescendant() const;
184     Node* firstDescendant() const;
185 
186     // From the NonDocumentTypeChildNode - https://dom.spec.whatwg.org/#nondocumenttypechildnode
187     WEBCORE_EXPORT Element* previousElementSibling() const;
188     WEBCORE_EXPORT Element* nextElementSibling() const;
189 
190     // From the ChildNode - https://dom.spec.whatwg.org/#childnode
191     ExceptionOr&lt;void&gt; before(Vector&lt;NodeOrString&gt;&amp;&amp;);
192     ExceptionOr&lt;void&gt; after(Vector&lt;NodeOrString&gt;&amp;&amp;);
193     ExceptionOr&lt;void&gt; replaceWith(Vector&lt;NodeOrString&gt;&amp;&amp;);
194     WEBCORE_EXPORT ExceptionOr&lt;void&gt; remove();
195 
196     // Other methods (not part of DOM)
197 
198     bool isElementNode() const { return getFlag(IsElementFlag); }
</pre>
<hr />
<pre>
266 
267     void* opaqueRoot() const;
268 
269     // Use when it&#39;s guaranteed to that shadowHost is null.
270     ContainerNode* parentNodeGuaranteedHostFree() const;
271     // Returns the parent node, but null if the parent node is a ShadowRoot.
272     ContainerNode* nonShadowBoundaryParentNode() const;
273 
274     bool selfOrAncestorHasDirAutoAttribute() const { return getFlag(SelfOrAncestorHasDirAutoFlag); }
275     void setSelfOrAncestorHasDirAutoAttribute(bool flag) { setFlag(flag, SelfOrAncestorHasDirAutoFlag); }
276 
277     // Returns the enclosing event parent Element (or self) that, when clicked, would trigger a navigation.
278     Element* enclosingLinkEventParentOrSelf();
279 
280     // These low-level calls give the caller responsibility for maintaining the integrity of the tree.
281     void setPreviousSibling(Node* previous) { m_previous = previous; }
282     void setNextSibling(Node* next) { m_next = next; }
283 
284     virtual bool canContainRangeEndPoint() const { return false; }
285 
<span class="line-modified">286     bool isRootEditableElement() const;</span>
287     WEBCORE_EXPORT Element* rootEditableElement() const;
288 
289     // Called by the parser when this element&#39;s close tag is reached,
290     // signaling that all child tags have been parsed and added.
291     // This is needed for &lt;applet&gt; and &lt;object&gt; elements, which can&#39;t lay themselves out
292     // until they know all of their nested &lt;param&gt;s. [Radar 3603191, 4040848].
293     // Also used for script elements and some SVG elements for similar purposes,
294     // but making parsing a special case in this respect should be avoided if possible.
295     virtual void finishParsingChildren() { }
296     virtual void beginParsingChildren() { }
297 
298     // For &lt;link&gt; and &lt;style&gt; elements.
299     virtual bool sheetLoaded() { return true; }
300     virtual void notifyLoadedSheetAndAllCriticalSubresources(bool /* error loading subresource */) { }
301     virtual void startLoadingDynamicSheet() { ASSERT_NOT_REACHED(); }
302 
303     bool isUserActionElement() const { return getFlag(IsUserActionElement); }
304     void setUserActionElement(bool flag) { setFlag(flag, IsUserActionElement); }
305 
306     bool inRenderedDocument() const;
</pre>
<hr />
<pre>
367         return *m_treeScope;
368     }
369     void setTreeScopeRecursively(TreeScope&amp;);
370     static ptrdiff_t treeScopeMemoryOffset() { return OBJECT_OFFSETOF(Node, m_treeScope); }
371 
372     // Returns true if this node is associated with a document and is in its associated document&#39;s
373     // node tree, false otherwise (https://dom.spec.whatwg.org/#connected).
374     bool isConnected() const
375     {
376         return getFlag(IsConnectedFlag);
377     }
378     bool isInUserAgentShadowTree() const;
379     bool isInShadowTree() const { return getFlag(IsInShadowTreeFlag); }
380     bool isInTreeScope() const { return getFlag(static_cast&lt;NodeFlags&gt;(IsConnectedFlag | IsInShadowTreeFlag)); }
381 
382     bool isDocumentTypeNode() const { return nodeType() == DOCUMENT_TYPE_NODE; }
383     virtual bool childTypeAllowed(NodeType) const { return false; }
384     unsigned countChildNodes() const;
385     Node* traverseToChildAt(unsigned) const;
386 
<span class="line-modified">387     ExceptionOr&lt;void&gt; checkSetPrefix(const AtomicString&amp; prefix);</span>
388 
389     WEBCORE_EXPORT bool isDescendantOf(const Node&amp;) const;
390     bool isDescendantOf(const Node* other) const { return other &amp;&amp; isDescendantOf(*other); }
391 
392     bool isDescendantOrShadowDescendantOf(const Node*) const;
393     WEBCORE_EXPORT bool contains(const Node*) const;
394     bool containsIncludingShadowDOM(const Node*) const;
395 
396     // Number of DOM 16-bit units contained in node. Note that rendered text length can be different - e.g. because of
397     // css-transform:capitalize breaking up precomposed characters and ligatures.
398     virtual int maxCharacterOffset() const;
399 
400     // Whether or not a selection can be started in this object
401     virtual bool canStartSelection() const;
402 
403     virtual bool shouldSelectOnMouseDown() { return false; }
404 
405     // Getting points into and out of screen space
406     FloatPoint convertToPage(const FloatPoint&amp;) const;
407     FloatPoint convertFromPage(const FloatPoint&amp;) const;
408 
409     // -----------------------------------------------------------------------------
410     // Integration with rendering tree
411 
412     // As renderer() includes a branch you should avoid calling it repeatedly in hot code paths.
<span class="line-modified">413     RenderObject* renderer() const { return hasRareData() ? m_data.m_rareData-&gt;renderer() : m_data.m_renderer; };</span>
<span class="line-modified">414     void setRenderer(RenderObject* renderer)</span>
<span class="line-removed">415     {</span>
<span class="line-removed">416         if (hasRareData())</span>
<span class="line-removed">417             m_data.m_rareData-&gt;setRenderer(renderer);</span>
<span class="line-removed">418         else</span>
<span class="line-removed">419             m_data.m_renderer = renderer;</span>
<span class="line-removed">420     }</span>
421 
422     // Use these two methods with caution.
423     WEBCORE_EXPORT RenderBox* renderBox() const;
424     RenderBoxModelObject* renderBoxModelObject() const;
425 
426     // Wrapper for nodes that don&#39;t have a renderer, but still cache the style (like HTMLOptionElement).
427     const RenderStyle* renderStyle() const;
428 
429     virtual const RenderStyle* computedStyle(PseudoId pseudoElementSpecifier = PseudoId::None);
430 
431     enum class InsertedIntoAncestorResult {
432         Done,
433         NeedsPostInsertionCallback,
434     };
435 
436     struct InsertionType {
437         bool connectedToDocument { false };
438         bool treeScopeChanged { false };
439     };
440     // Called *after* this node or its ancestor is inserted into a new parent (may or may not be a part of document) by scripts or parser.
</pre>
<hr />
<pre>
455     void showTreeForThis() const;
456     void showNodePathForThis() const;
457     void showTreeAndMark(const Node* markedNode1, const char* markedLabel1, const Node* markedNode2 = nullptr, const char* markedLabel2 = nullptr) const;
458     void showTreeForThisAcrossFrame() const;
459 #endif // ENABLE(TREE_DEBUGGING)
460 
461     void invalidateNodeListAndCollectionCachesInAncestors();
462     void invalidateNodeListAndCollectionCachesInAncestorsForAttribute(const QualifiedName&amp; attrName);
463     NodeListsNodeData* nodeLists();
464     void clearNodeLists();
465 
466     virtual bool willRespondToMouseMoveEvents();
467     virtual bool willRespondToMouseClickEvents();
468     virtual bool willRespondToMouseWheelEvents();
469 
470     WEBCORE_EXPORT unsigned short compareDocumentPosition(Node&amp;);
471 
472     EventTargetInterface eventTargetInterface() const override;
473     ScriptExecutionContext* scriptExecutionContext() const final; // Implemented in Document.h
474 
<span class="line-modified">475     bool addEventListener(const AtomicString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) override;</span>
<span class="line-modified">476     bool removeEventListener(const AtomicString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) override;</span>
477 
478     using EventTarget::dispatchEvent;
479     void dispatchEvent(Event&amp;) override;
480 
481     void dispatchScopedEvent(Event&amp;);
482 
483     virtual void handleLocalEvents(Event&amp;, EventInvokePhase);
484 
485     void dispatchSubtreeModifiedEvent();
486     void dispatchDOMActivateEvent(Event&amp; underlyingClickEvent);
487 
488 #if ENABLE(TOUCH_EVENTS)
489     virtual bool allowsDoubleTapGesture() const { return true; }
490 #endif
491 
492     bool dispatchBeforeLoadEvent(const String&amp; sourceURL);
493 
494     WEBCORE_EXPORT void dispatchInputEvent();
495 
496     // Perform the default action for an event.
497     virtual void defaultEventHandler(Event&amp;);
498 
499     void ref();
500     void deref();
501     bool hasOneRef() const;
<span class="line-modified">502     int refCount() const;</span>
503 
504 #ifndef NDEBUG
505     bool m_deletionHasBegun { false };
506     bool m_inRemovedLastRefFunction { false };
507     bool m_adoptionIsRequired { true };
508 #endif
509 
510     EventTargetData* eventTargetData() final;
511     EventTargetData* eventTargetDataConcurrently() final;
512     EventTargetData&amp; ensureEventTargetData() final;
513 
514     HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; registeredMutationObservers(MutationObserver::MutationType, const QualifiedName* attributeName);
<span class="line-modified">515     void registerMutationObserver(MutationObserver&amp;, MutationObserverOptions, const HashSet&lt;AtomicString&gt;&amp; attributeFilter);</span>
516     void unregisterMutationObserver(MutationObserverRegistration&amp;);
517     void registerTransientMutationObserver(MutationObserverRegistration&amp;);
518     void unregisterTransientMutationObserver(MutationObserverRegistration&amp;);
519     void notifyMutationObserversNodeWillDetach();
520 
521     WEBCORE_EXPORT void textRects(Vector&lt;IntRect&gt;&amp;) const;
522 
523     unsigned connectedSubframeCount() const;
524     void incrementConnectedSubframeCount(unsigned amount = 1);
525     void decrementConnectedSubframeCount(unsigned amount = 1);
526     void updateAncestorConnectedSubframeCountForRemoval() const;
527     void updateAncestorConnectedSubframeCountForInsertion() const;
528 
529 #if ENABLE(JIT)
530     static ptrdiff_t nodeFlagsMemoryOffset() { return OBJECT_OFFSETOF(Node, m_nodeFlags); }
<span class="line-modified">531     static ptrdiff_t rareDataMemoryOffset() { return OBJECT_OFFSETOF(Node, m_data.m_rareData); }</span>
532     static int32_t flagIsText() { return IsTextFlag; }
533     static int32_t flagIsContainer() { return IsContainerFlag; }
534     static int32_t flagIsElement() { return IsElementFlag; }
535     static int32_t flagIsShadowRoot() { return IsShadowRootFlag; }
536     static int32_t flagIsHTML() { return IsHTMLFlag; }
537     static int32_t flagIsLink() { return IsLinkFlag; }
538     static int32_t flagHasFocusWithin() { return HasFocusWithin; }
<span class="line-removed">539     static int32_t flagHasRareData() { return HasRareDataFlag; }</span>
540     static int32_t flagIsParsingChildrenFinished() { return IsParsingChildrenFinishedFlag; }
541     static int32_t flagChildrenAffectedByFirstChildRulesFlag() { return ChildrenAffectedByFirstChildRulesFlag; }
542     static int32_t flagChildrenAffectedByLastChildRulesFlag() { return ChildrenAffectedByLastChildRulesFlag; }
543 
544     static int32_t flagAffectsNextSiblingElementStyle() { return AffectsNextSiblingElementStyle; }
545     static int32_t flagStyleIsAffectedByPreviousSibling() { return StyleIsAffectedByPreviousSibling; }
546 #endif // ENABLE(JIT)
547 
548 protected:
549     enum NodeFlags {
550         IsTextFlag = 1,
551         IsContainerFlag = 1 &lt;&lt; 1,
552         IsElementFlag = 1 &lt;&lt; 2,
553         IsHTMLFlag = 1 &lt;&lt; 3,
554         IsSVGFlag = 1 &lt;&lt; 4,
555         IsMathMLFlag = 1 &lt;&lt; 5,
556         IsDocumentNodeFlag = 1 &lt;&lt; 6,
557         IsShadowRootFlag = 1 &lt;&lt; 7,
558         IsConnectedFlag = 1 &lt;&lt; 8,
559         IsInShadowTreeFlag = 1 &lt;&lt; 9,
<span class="line-modified">560         HasRareDataFlag = 1 &lt;&lt; 10,</span>
561         HasEventTargetDataFlag = 1 &lt;&lt; 11,
562 
563         // These bits are used by derived classes, pulled up here so they can
564         // be stored in the same memory word as the Node bits above.
565         ChildNeedsStyleRecalcFlag = 1 &lt;&lt; 12, // ContainerNode
566         DirectChildNeedsStyleRecalcFlag = 1 &lt;&lt; 13,
567 
568         IsEditingTextOrUndefinedCustomElementFlag = 1 &lt;&lt; 14, // Text and Element
569         IsCustomElement = 1 &lt;&lt; 15, // Element
570         HasFocusWithin = 1 &lt;&lt; 16,
571         IsLinkFlag = 1 &lt;&lt; 17,
572         IsUserActionElement = 1 &lt;&lt; 18,
573         IsParsingChildrenFinishedFlag = 1 &lt;&lt; 19,
574         HasSyntheticAttrChildNodesFlag = 1 &lt;&lt; 20,
575         SelfOrAncestorHasDirAutoFlag = 1 &lt;&lt; 21,
576 
577         // The following flags are used in style invalidation.
578         StyleValidityShift = 22,
579         StyleValidityMask = 3 &lt;&lt; StyleValidityShift,
580         StyleResolutionShouldRecompositeLayerFlag = 1 &lt;&lt; 24,
</pre>
<hr />
<pre>
600     bool isParsingChildrenFinished() const { return getFlag(IsParsingChildrenFinishedFlag); }
601     void setIsParsingChildrenFinished() { setFlag(IsParsingChildrenFinishedFlag); }
602     void clearIsParsingChildrenFinished() { clearFlag(IsParsingChildrenFinishedFlag); }
603 
604     enum ConstructionType {
605         CreateOther = DefaultNodeFlags,
606         CreateText = DefaultNodeFlags | IsTextFlag,
607         CreateContainer = DefaultNodeFlags | IsContainerFlag,
608         CreateElement = CreateContainer | IsElementFlag,
609         CreatePseudoElement =  CreateElement | IsConnectedFlag,
610         CreateShadowRoot = CreateContainer | IsShadowRootFlag | IsInShadowTreeFlag,
611         CreateDocumentFragment = CreateContainer,
612         CreateHTMLElement = CreateElement | IsHTMLFlag,
613         CreateSVGElement = CreateElement | IsSVGFlag | HasCustomStyleResolveCallbacksFlag,
614         CreateMathMLElement = CreateElement | IsMathMLFlag,
615         CreateDocument = CreateContainer | IsDocumentNodeFlag | IsConnectedFlag,
616         CreateEditingText = CreateText | IsEditingTextOrUndefinedCustomElementFlag,
617     };
618     Node(Document&amp;, ConstructionType);
619 
<span class="line-modified">620     virtual void addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp;) const { }</span>




















621 
<span class="line-modified">622     bool hasRareData() const { return getFlag(HasRareDataFlag); }</span>
623 
<span class="line-modified">624     NodeRareData* rareData() const;</span>

625     NodeRareData&amp; ensureRareData();
626     void clearRareData();
627 
628     void clearEventTargetData();
629 
630     void setHasCustomStyleResolveCallbacks() { setFlag(true, HasCustomStyleResolveCallbacksFlag); }
631 
632     void setTreeScope(TreeScope&amp; scope) { m_treeScope = &amp;scope; }
633 
634     void invalidateStyle(Style::Validity, Style::InvalidationMode = Style::InvalidationMode::Normal);
635     void updateAncestorsForStyleRecalc();
636 
637     ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; convertNodesOrStringsIntoNode(Vector&lt;NodeOrString&gt;&amp;&amp;);
638 
639 private:
640     virtual PseudoId customPseudoId() const
641     {
642         ASSERT(hasCustomStyleResolveCallbacks());
643         return PseudoId::None;
644     }
</pre>
<hr />
<pre>
646     WEBCORE_EXPORT void removedLastRef();
647 
648     void refEventTarget() final;
649     void derefEventTarget() final;
650     bool isNode() const final;
651 
652     void trackForDebugging();
653     void materializeRareData();
654 
655     Vector&lt;std::unique_ptr&lt;MutationObserverRegistration&gt;&gt;* mutationObserverRegistry();
656     HashSet&lt;MutationObserverRegistration*&gt;* transientMutationObserverRegistry();
657 
658     void adjustStyleValidity(Style::Validity, Style::InvalidationMode);
659 
660     void* opaqueRootSlow() const;
661 
662     static void moveShadowTreeToNewDocument(ShadowRoot&amp;, Document&amp; oldDocument, Document&amp; newDocument);
663     static void moveTreeToNewScope(Node&amp;, TreeScope&amp; oldScope, TreeScope&amp; newScope);
664     void moveNodeToNewDocument(Document&amp; oldDocument, Document&amp; newDocument);
665 
<span class="line-modified">666     int m_refCount;</span>




667     mutable uint32_t m_nodeFlags;
668 
669     ContainerNode* m_parentNode { nullptr };
670     TreeScope* m_treeScope { nullptr };
671     Node* m_previous { nullptr };
672     Node* m_next { nullptr };
<span class="line-modified">673     // When a node has rare data we move the renderer into the rare data.</span>
<span class="line-modified">674     union DataUnion {</span>
<span class="line-removed">675         RenderObject* m_renderer;</span>
<span class="line-removed">676         NodeRareDataBase* m_rareData;</span>
<span class="line-removed">677     } m_data { nullptr };</span>
678 };
679 
680 #ifndef NDEBUG
681 inline void adopted(Node* node)
682 {
683     if (!node)
684         return;
685     ASSERT(!node-&gt;m_deletionHasBegun);
686     ASSERT(!node-&gt;m_inRemovedLastRefFunction);
687     node-&gt;m_adoptionIsRequired = false;
688 }
689 #endif
690 
691 ALWAYS_INLINE void Node::ref()
692 {
693     ASSERT(isMainThread());
694     ASSERT(!m_deletionHasBegun);
695     ASSERT(!m_inRemovedLastRefFunction);
696     ASSERT(!m_adoptionIsRequired);
<span class="line-modified">697     ++m_refCount;</span>
698 }
699 
700 ALWAYS_INLINE void Node::deref()
701 {
702     ASSERT(isMainThread());
<span class="line-modified">703     ASSERT(m_refCount &gt;= 0);</span>
704     ASSERT(!m_deletionHasBegun);
705     ASSERT(!m_inRemovedLastRefFunction);
706     ASSERT(!m_adoptionIsRequired);
<span class="line-modified">707     if (--m_refCount &lt;= 0 &amp;&amp; !parentNode()) {</span>



708 #ifndef NDEBUG
709         m_inRemovedLastRefFunction = true;
710 #endif
711         removedLastRef();

712     }

713 }
714 
715 ALWAYS_INLINE bool Node::hasOneRef() const
716 {
717     ASSERT(!m_deletionHasBegun);
718     ASSERT(!m_inRemovedLastRefFunction);
<span class="line-modified">719     return m_refCount == 1;</span>
720 }
721 
<span class="line-modified">722 ALWAYS_INLINE int Node::refCount() const</span>
723 {
<span class="line-modified">724     return m_refCount;</span>
725 }
726 
727 // Used in Node::addSubresourceAttributeURLs() and in addSubresourceStyleURLs()
728 inline void addSubresourceURL(ListHashSet&lt;URL&gt;&amp; urls, const URL&amp; url)
729 {
730     if (!url.isNull())
731         urls.add(url);
732 }
733 
734 inline void Node::setParentNode(ContainerNode* parent)
735 {
736     ASSERT(isMainThread());
737     m_parentNode = parent;

738 }
739 
740 inline ContainerNode* Node::parentNode() const
741 {
742     ASSERT(isMainThreadOrGCThread());
743     return m_parentNode;
744 }
745 
746 inline void* Node::opaqueRoot() const
747 {
748     // FIXME: Possible race?
749     // https://bugs.webkit.org/show_bug.cgi?id=165713
750     if (isConnected())
751         return &amp;document();
752     return opaqueRootSlow();
753 }
754 
755 inline ContainerNode* Node::parentNodeGuaranteedHostFree() const
756 {
757     ASSERT(!isShadowRoot());
</pre>
</td>
<td>
<hr />
<pre>
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  *
 23  */
 24 
 25 #pragma once
 26 
 27 #include &quot;EventTarget.h&quot;
 28 #include &quot;ExceptionOr.h&quot;
 29 #include &quot;LayoutRect.h&quot;
 30 #include &quot;MutationObserver.h&quot;
 31 #include &quot;RenderStyleConstants.h&quot;
 32 #include &quot;StyleValidity.h&quot;
 33 #include &quot;TreeScope.h&quot;
<span class="line-added"> 34 #include &lt;wtf/CompactPointerTuple.h&gt;</span>
 35 #include &lt;wtf/Forward.h&gt;
 36 #include &lt;wtf/IsoMalloc.h&gt;
 37 #include &lt;wtf/ListHashSet.h&gt;
 38 #include &lt;wtf/MainThread.h&gt;
 39 #include &lt;wtf/URLHash.h&gt;
 40 
 41 // This needs to be here because Document.h also depends on it.
 42 #define DUMP_NODE_STATISTICS 0
 43 
 44 namespace WebCore {
 45 
 46 class ContainerNode;
 47 class Document;
 48 class Element;
 49 class FloatPoint;
 50 class HTMLQualifiedName;
 51 class HTMLSlotElement;
 52 class MathMLQualifiedName;
 53 class NamedNodeMap;
 54 class NodeList;
 55 class NodeListsNodeData;
 56 class NodeRareData;
 57 class QualifiedName;
 58 class RenderBox;
 59 class RenderBoxModelObject;
 60 class RenderObject;
 61 class RenderStyle;
 62 class SVGQualifiedName;
 63 class ShadowRoot;
 64 class TouchEvent;
 65 
 66 using NodeOrString = Variant&lt;RefPtr&lt;Node&gt;, String&gt;;
 67 














 68 class Node : public EventTarget {
 69     WTF_MAKE_ISO_ALLOCATED(Node);
 70 
 71     friend class Document;
 72     friend class TreeScope;
 73 public:
 74     enum NodeType {
 75         ELEMENT_NODE = 1,
 76         ATTRIBUTE_NODE = 2,
 77         TEXT_NODE = 3,
 78         CDATA_SECTION_NODE = 4,
 79         PROCESSING_INSTRUCTION_NODE = 7,
 80         COMMENT_NODE = 8,
 81         DOCUMENT_NODE = 9,
 82         DOCUMENT_TYPE_NODE = 10,
 83         DOCUMENT_FRAGMENT_NODE = 11,
 84     };
 85     enum DeprecatedNodeType {
 86         ENTITY_REFERENCE_NODE = 5,
 87         ENTITY_NODE = 6,
</pre>
<hr />
<pre>
135     WEBCORE_EXPORT const URL&amp; baseURI() const;
136 
137     void getSubresourceURLs(ListHashSet&lt;URL&gt;&amp;) const;
138 
139     WEBCORE_EXPORT ExceptionOr&lt;void&gt; insertBefore(Node&amp; newChild, Node* refChild);
140     WEBCORE_EXPORT ExceptionOr&lt;void&gt; replaceChild(Node&amp; newChild, Node&amp; oldChild);
141     WEBCORE_EXPORT ExceptionOr&lt;void&gt; removeChild(Node&amp; child);
142     WEBCORE_EXPORT ExceptionOr&lt;void&gt; appendChild(Node&amp; newChild);
143 
144     bool hasChildNodes() const { return firstChild(); }
145 
146     enum class CloningOperation {
147         OnlySelf,
148         SelfWithTemplateContent,
149         Everything,
150     };
151     virtual Ref&lt;Node&gt; cloneNodeInternal(Document&amp;, CloningOperation) = 0;
152     Ref&lt;Node&gt; cloneNode(bool deep) { return cloneNodeInternal(document(), deep ? CloningOperation::Everything : CloningOperation::OnlySelf); }
153     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Node&gt;&gt; cloneNodeForBindings(bool deep);
154 
<span class="line-modified">155     virtual const AtomString&amp; localName() const;</span>
<span class="line-modified">156     virtual const AtomString&amp; namespaceURI() const;</span>
<span class="line-modified">157     virtual const AtomString&amp; prefix() const;</span>
<span class="line-modified">158     virtual ExceptionOr&lt;void&gt; setPrefix(const AtomString&amp;);</span>
159     WEBCORE_EXPORT void normalize();
160 
161     bool isSameNode(Node* other) const { return this == other; }
162     WEBCORE_EXPORT bool isEqualNode(Node*) const;
<span class="line-modified">163     WEBCORE_EXPORT bool isDefaultNamespace(const AtomString&amp; namespaceURI) const;</span>
<span class="line-modified">164     WEBCORE_EXPORT const AtomString&amp; lookupPrefix(const AtomString&amp; namespaceURI) const;</span>
<span class="line-modified">165     WEBCORE_EXPORT const AtomString&amp; lookupNamespaceURI(const AtomString&amp; prefix) const;</span>
166 
167     WEBCORE_EXPORT String textContent(bool convertBRsToNewlines = false) const;
168     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setTextContent(const String&amp;);
169 
170     Node* lastDescendant() const;
171     Node* firstDescendant() const;
172 
173     // From the NonDocumentTypeChildNode - https://dom.spec.whatwg.org/#nondocumenttypechildnode
174     WEBCORE_EXPORT Element* previousElementSibling() const;
175     WEBCORE_EXPORT Element* nextElementSibling() const;
176 
177     // From the ChildNode - https://dom.spec.whatwg.org/#childnode
178     ExceptionOr&lt;void&gt; before(Vector&lt;NodeOrString&gt;&amp;&amp;);
179     ExceptionOr&lt;void&gt; after(Vector&lt;NodeOrString&gt;&amp;&amp;);
180     ExceptionOr&lt;void&gt; replaceWith(Vector&lt;NodeOrString&gt;&amp;&amp;);
181     WEBCORE_EXPORT ExceptionOr&lt;void&gt; remove();
182 
183     // Other methods (not part of DOM)
184 
185     bool isElementNode() const { return getFlag(IsElementFlag); }
</pre>
<hr />
<pre>
253 
254     void* opaqueRoot() const;
255 
256     // Use when it&#39;s guaranteed to that shadowHost is null.
257     ContainerNode* parentNodeGuaranteedHostFree() const;
258     // Returns the parent node, but null if the parent node is a ShadowRoot.
259     ContainerNode* nonShadowBoundaryParentNode() const;
260 
261     bool selfOrAncestorHasDirAutoAttribute() const { return getFlag(SelfOrAncestorHasDirAutoFlag); }
262     void setSelfOrAncestorHasDirAutoAttribute(bool flag) { setFlag(flag, SelfOrAncestorHasDirAutoFlag); }
263 
264     // Returns the enclosing event parent Element (or self) that, when clicked, would trigger a navigation.
265     Element* enclosingLinkEventParentOrSelf();
266 
267     // These low-level calls give the caller responsibility for maintaining the integrity of the tree.
268     void setPreviousSibling(Node* previous) { m_previous = previous; }
269     void setNextSibling(Node* next) { m_next = next; }
270 
271     virtual bool canContainRangeEndPoint() const { return false; }
272 
<span class="line-modified">273     WEBCORE_EXPORT bool isRootEditableElement() const;</span>
274     WEBCORE_EXPORT Element* rootEditableElement() const;
275 
276     // Called by the parser when this element&#39;s close tag is reached,
277     // signaling that all child tags have been parsed and added.
278     // This is needed for &lt;applet&gt; and &lt;object&gt; elements, which can&#39;t lay themselves out
279     // until they know all of their nested &lt;param&gt;s. [Radar 3603191, 4040848].
280     // Also used for script elements and some SVG elements for similar purposes,
281     // but making parsing a special case in this respect should be avoided if possible.
282     virtual void finishParsingChildren() { }
283     virtual void beginParsingChildren() { }
284 
285     // For &lt;link&gt; and &lt;style&gt; elements.
286     virtual bool sheetLoaded() { return true; }
287     virtual void notifyLoadedSheetAndAllCriticalSubresources(bool /* error loading subresource */) { }
288     virtual void startLoadingDynamicSheet() { ASSERT_NOT_REACHED(); }
289 
290     bool isUserActionElement() const { return getFlag(IsUserActionElement); }
291     void setUserActionElement(bool flag) { setFlag(flag, IsUserActionElement); }
292 
293     bool inRenderedDocument() const;
</pre>
<hr />
<pre>
354         return *m_treeScope;
355     }
356     void setTreeScopeRecursively(TreeScope&amp;);
357     static ptrdiff_t treeScopeMemoryOffset() { return OBJECT_OFFSETOF(Node, m_treeScope); }
358 
359     // Returns true if this node is associated with a document and is in its associated document&#39;s
360     // node tree, false otherwise (https://dom.spec.whatwg.org/#connected).
361     bool isConnected() const
362     {
363         return getFlag(IsConnectedFlag);
364     }
365     bool isInUserAgentShadowTree() const;
366     bool isInShadowTree() const { return getFlag(IsInShadowTreeFlag); }
367     bool isInTreeScope() const { return getFlag(static_cast&lt;NodeFlags&gt;(IsConnectedFlag | IsInShadowTreeFlag)); }
368 
369     bool isDocumentTypeNode() const { return nodeType() == DOCUMENT_TYPE_NODE; }
370     virtual bool childTypeAllowed(NodeType) const { return false; }
371     unsigned countChildNodes() const;
372     Node* traverseToChildAt(unsigned) const;
373 
<span class="line-modified">374     ExceptionOr&lt;void&gt; checkSetPrefix(const AtomString&amp; prefix);</span>
375 
376     WEBCORE_EXPORT bool isDescendantOf(const Node&amp;) const;
377     bool isDescendantOf(const Node* other) const { return other &amp;&amp; isDescendantOf(*other); }
378 
379     bool isDescendantOrShadowDescendantOf(const Node*) const;
380     WEBCORE_EXPORT bool contains(const Node*) const;
381     bool containsIncludingShadowDOM(const Node*) const;
382 
383     // Number of DOM 16-bit units contained in node. Note that rendered text length can be different - e.g. because of
384     // css-transform:capitalize breaking up precomposed characters and ligatures.
385     virtual int maxCharacterOffset() const;
386 
387     // Whether or not a selection can be started in this object
388     virtual bool canStartSelection() const;
389 
390     virtual bool shouldSelectOnMouseDown() { return false; }
391 
392     // Getting points into and out of screen space
393     FloatPoint convertToPage(const FloatPoint&amp;) const;
394     FloatPoint convertFromPage(const FloatPoint&amp;) const;
395 
396     // -----------------------------------------------------------------------------
397     // Integration with rendering tree
398 
399     // As renderer() includes a branch you should avoid calling it repeatedly in hot code paths.
<span class="line-modified">400     RenderObject* renderer() const { return m_rendererWithStyleFlags.pointer(); }</span>
<span class="line-modified">401     void setRenderer(RenderObject*); // Defined in RenderObject.h</span>






402 
403     // Use these two methods with caution.
404     WEBCORE_EXPORT RenderBox* renderBox() const;
405     RenderBoxModelObject* renderBoxModelObject() const;
406 
407     // Wrapper for nodes that don&#39;t have a renderer, but still cache the style (like HTMLOptionElement).
408     const RenderStyle* renderStyle() const;
409 
410     virtual const RenderStyle* computedStyle(PseudoId pseudoElementSpecifier = PseudoId::None);
411 
412     enum class InsertedIntoAncestorResult {
413         Done,
414         NeedsPostInsertionCallback,
415     };
416 
417     struct InsertionType {
418         bool connectedToDocument { false };
419         bool treeScopeChanged { false };
420     };
421     // Called *after* this node or its ancestor is inserted into a new parent (may or may not be a part of document) by scripts or parser.
</pre>
<hr />
<pre>
436     void showTreeForThis() const;
437     void showNodePathForThis() const;
438     void showTreeAndMark(const Node* markedNode1, const char* markedLabel1, const Node* markedNode2 = nullptr, const char* markedLabel2 = nullptr) const;
439     void showTreeForThisAcrossFrame() const;
440 #endif // ENABLE(TREE_DEBUGGING)
441 
442     void invalidateNodeListAndCollectionCachesInAncestors();
443     void invalidateNodeListAndCollectionCachesInAncestorsForAttribute(const QualifiedName&amp; attrName);
444     NodeListsNodeData* nodeLists();
445     void clearNodeLists();
446 
447     virtual bool willRespondToMouseMoveEvents();
448     virtual bool willRespondToMouseClickEvents();
449     virtual bool willRespondToMouseWheelEvents();
450 
451     WEBCORE_EXPORT unsigned short compareDocumentPosition(Node&amp;);
452 
453     EventTargetInterface eventTargetInterface() const override;
454     ScriptExecutionContext* scriptExecutionContext() const final; // Implemented in Document.h
455 
<span class="line-modified">456     WEBCORE_EXPORT bool addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) override;</span>
<span class="line-modified">457     bool removeEventListener(const AtomString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) override;</span>
458 
459     using EventTarget::dispatchEvent;
460     void dispatchEvent(Event&amp;) override;
461 
462     void dispatchScopedEvent(Event&amp;);
463 
464     virtual void handleLocalEvents(Event&amp;, EventInvokePhase);
465 
466     void dispatchSubtreeModifiedEvent();
467     void dispatchDOMActivateEvent(Event&amp; underlyingClickEvent);
468 
469 #if ENABLE(TOUCH_EVENTS)
470     virtual bool allowsDoubleTapGesture() const { return true; }
471 #endif
472 
473     bool dispatchBeforeLoadEvent(const String&amp; sourceURL);
474 
475     WEBCORE_EXPORT void dispatchInputEvent();
476 
477     // Perform the default action for an event.
478     virtual void defaultEventHandler(Event&amp;);
479 
480     void ref();
481     void deref();
482     bool hasOneRef() const;
<span class="line-modified">483     unsigned refCount() const;</span>
484 
485 #ifndef NDEBUG
486     bool m_deletionHasBegun { false };
487     bool m_inRemovedLastRefFunction { false };
488     bool m_adoptionIsRequired { true };
489 #endif
490 
491     EventTargetData* eventTargetData() final;
492     EventTargetData* eventTargetDataConcurrently() final;
493     EventTargetData&amp; ensureEventTargetData() final;
494 
495     HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; registeredMutationObservers(MutationObserver::MutationType, const QualifiedName* attributeName);
<span class="line-modified">496     void registerMutationObserver(MutationObserver&amp;, MutationObserverOptions, const HashSet&lt;AtomString&gt;&amp; attributeFilter);</span>
497     void unregisterMutationObserver(MutationObserverRegistration&amp;);
498     void registerTransientMutationObserver(MutationObserverRegistration&amp;);
499     void unregisterTransientMutationObserver(MutationObserverRegistration&amp;);
500     void notifyMutationObserversNodeWillDetach();
501 
502     WEBCORE_EXPORT void textRects(Vector&lt;IntRect&gt;&amp;) const;
503 
504     unsigned connectedSubframeCount() const;
505     void incrementConnectedSubframeCount(unsigned amount = 1);
506     void decrementConnectedSubframeCount(unsigned amount = 1);
507     void updateAncestorConnectedSubframeCountForRemoval() const;
508     void updateAncestorConnectedSubframeCountForInsertion() const;
509 
510 #if ENABLE(JIT)
511     static ptrdiff_t nodeFlagsMemoryOffset() { return OBJECT_OFFSETOF(Node, m_nodeFlags); }
<span class="line-modified">512     static ptrdiff_t rareDataMemoryOffset() { return OBJECT_OFFSETOF(Node, m_rareData); }</span>
513     static int32_t flagIsText() { return IsTextFlag; }
514     static int32_t flagIsContainer() { return IsContainerFlag; }
515     static int32_t flagIsElement() { return IsElementFlag; }
516     static int32_t flagIsShadowRoot() { return IsShadowRootFlag; }
517     static int32_t flagIsHTML() { return IsHTMLFlag; }
518     static int32_t flagIsLink() { return IsLinkFlag; }
519     static int32_t flagHasFocusWithin() { return HasFocusWithin; }

520     static int32_t flagIsParsingChildrenFinished() { return IsParsingChildrenFinishedFlag; }
521     static int32_t flagChildrenAffectedByFirstChildRulesFlag() { return ChildrenAffectedByFirstChildRulesFlag; }
522     static int32_t flagChildrenAffectedByLastChildRulesFlag() { return ChildrenAffectedByLastChildRulesFlag; }
523 
524     static int32_t flagAffectsNextSiblingElementStyle() { return AffectsNextSiblingElementStyle; }
525     static int32_t flagStyleIsAffectedByPreviousSibling() { return StyleIsAffectedByPreviousSibling; }
526 #endif // ENABLE(JIT)
527 
528 protected:
529     enum NodeFlags {
530         IsTextFlag = 1,
531         IsContainerFlag = 1 &lt;&lt; 1,
532         IsElementFlag = 1 &lt;&lt; 2,
533         IsHTMLFlag = 1 &lt;&lt; 3,
534         IsSVGFlag = 1 &lt;&lt; 4,
535         IsMathMLFlag = 1 &lt;&lt; 5,
536         IsDocumentNodeFlag = 1 &lt;&lt; 6,
537         IsShadowRootFlag = 1 &lt;&lt; 7,
538         IsConnectedFlag = 1 &lt;&lt; 8,
539         IsInShadowTreeFlag = 1 &lt;&lt; 9,
<span class="line-modified">540         StyleAffectedByFocusWithinFlag = 1 &lt;&lt; 10,</span>
541         HasEventTargetDataFlag = 1 &lt;&lt; 11,
542 
543         // These bits are used by derived classes, pulled up here so they can
544         // be stored in the same memory word as the Node bits above.
545         ChildNeedsStyleRecalcFlag = 1 &lt;&lt; 12, // ContainerNode
546         DirectChildNeedsStyleRecalcFlag = 1 &lt;&lt; 13,
547 
548         IsEditingTextOrUndefinedCustomElementFlag = 1 &lt;&lt; 14, // Text and Element
549         IsCustomElement = 1 &lt;&lt; 15, // Element
550         HasFocusWithin = 1 &lt;&lt; 16,
551         IsLinkFlag = 1 &lt;&lt; 17,
552         IsUserActionElement = 1 &lt;&lt; 18,
553         IsParsingChildrenFinishedFlag = 1 &lt;&lt; 19,
554         HasSyntheticAttrChildNodesFlag = 1 &lt;&lt; 20,
555         SelfOrAncestorHasDirAutoFlag = 1 &lt;&lt; 21,
556 
557         // The following flags are used in style invalidation.
558         StyleValidityShift = 22,
559         StyleValidityMask = 3 &lt;&lt; StyleValidityShift,
560         StyleResolutionShouldRecompositeLayerFlag = 1 &lt;&lt; 24,
</pre>
<hr />
<pre>
580     bool isParsingChildrenFinished() const { return getFlag(IsParsingChildrenFinishedFlag); }
581     void setIsParsingChildrenFinished() { setFlag(IsParsingChildrenFinishedFlag); }
582     void clearIsParsingChildrenFinished() { clearFlag(IsParsingChildrenFinishedFlag); }
583 
584     enum ConstructionType {
585         CreateOther = DefaultNodeFlags,
586         CreateText = DefaultNodeFlags | IsTextFlag,
587         CreateContainer = DefaultNodeFlags | IsContainerFlag,
588         CreateElement = CreateContainer | IsElementFlag,
589         CreatePseudoElement =  CreateElement | IsConnectedFlag,
590         CreateShadowRoot = CreateContainer | IsShadowRootFlag | IsInShadowTreeFlag,
591         CreateDocumentFragment = CreateContainer,
592         CreateHTMLElement = CreateElement | IsHTMLFlag,
593         CreateSVGElement = CreateElement | IsSVGFlag | HasCustomStyleResolveCallbacksFlag,
594         CreateMathMLElement = CreateElement | IsMathMLFlag,
595         CreateDocument = CreateContainer | IsDocumentNodeFlag | IsConnectedFlag,
596         CreateEditingText = CreateText | IsEditingTextOrUndefinedCustomElementFlag,
597     };
598     Node(Document&amp;, ConstructionType);
599 
<span class="line-modified">600     static constexpr uint32_t s_refCountIncrement = 2;</span>
<span class="line-added">601     static constexpr uint32_t s_refCountMask = ~static_cast&lt;uint32_t&gt;(1);</span>
<span class="line-added">602 </span>
<span class="line-added">603     enum class ElementStyleFlag : uint8_t {</span>
<span class="line-added">604         StyleAffectedByActive = 1 &lt;&lt; 0,</span>
<span class="line-added">605         StyleAffectedByEmpty = 1 &lt;&lt; 1,</span>
<span class="line-added">606         ChildrenAffectedByDrag = 1 &lt;&lt; 2,</span>
<span class="line-added">607 </span>
<span class="line-added">608         // Bits for dynamic child matching.</span>
<span class="line-added">609         // We optimize for :first-child and :last-child. The other positional child selectors like nth-child or</span>
<span class="line-added">610         // *-child-of-type, we will just give up and re-evaluate whenever children change at all.</span>
<span class="line-added">611         ChildrenAffectedByForwardPositionalRules = 1 &lt;&lt; 3,</span>
<span class="line-added">612         DescendantsAffectedByForwardPositionalRules = 1 &lt;&lt; 4,</span>
<span class="line-added">613         ChildrenAffectedByBackwardPositionalRules = 1 &lt;&lt; 5,</span>
<span class="line-added">614         DescendantsAffectedByBackwardPositionalRules = 1 &lt;&lt; 6,</span>
<span class="line-added">615         ChildrenAffectedByPropertyBasedBackwardPositionalRules = 1 &lt;&lt; 7,</span>
<span class="line-added">616     };</span>
<span class="line-added">617 </span>
<span class="line-added">618     bool hasStyleFlag(ElementStyleFlag state) const { return m_rendererWithStyleFlags.type() &amp; static_cast&lt;uint8_t&gt;(state); }</span>
<span class="line-added">619     void setStyleFlag(ElementStyleFlag state) { m_rendererWithStyleFlags.setType(m_rendererWithStyleFlags.type() | static_cast&lt;uint8_t&gt;(state)); }</span>
<span class="line-added">620     void clearStyleFlags() { m_rendererWithStyleFlags.setType(0); }</span>
621 
<span class="line-modified">622     virtual void addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp;) const { }</span>
623 
<span class="line-modified">624     bool hasRareData() const { return !!m_rareData; }</span>
<span class="line-added">625     NodeRareData* rareData() const { return m_rareData.get(); }</span>
626     NodeRareData&amp; ensureRareData();
627     void clearRareData();
628 
629     void clearEventTargetData();
630 
631     void setHasCustomStyleResolveCallbacks() { setFlag(true, HasCustomStyleResolveCallbacksFlag); }
632 
633     void setTreeScope(TreeScope&amp; scope) { m_treeScope = &amp;scope; }
634 
635     void invalidateStyle(Style::Validity, Style::InvalidationMode = Style::InvalidationMode::Normal);
636     void updateAncestorsForStyleRecalc();
637 
638     ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; convertNodesOrStringsIntoNode(Vector&lt;NodeOrString&gt;&amp;&amp;);
639 
640 private:
641     virtual PseudoId customPseudoId() const
642     {
643         ASSERT(hasCustomStyleResolveCallbacks());
644         return PseudoId::None;
645     }
</pre>
<hr />
<pre>
647     WEBCORE_EXPORT void removedLastRef();
648 
649     void refEventTarget() final;
650     void derefEventTarget() final;
651     bool isNode() const final;
652 
653     void trackForDebugging();
654     void materializeRareData();
655 
656     Vector&lt;std::unique_ptr&lt;MutationObserverRegistration&gt;&gt;* mutationObserverRegistry();
657     HashSet&lt;MutationObserverRegistration*&gt;* transientMutationObserverRegistry();
658 
659     void adjustStyleValidity(Style::Validity, Style::InvalidationMode);
660 
661     void* opaqueRootSlow() const;
662 
663     static void moveShadowTreeToNewDocument(ShadowRoot&amp;, Document&amp; oldDocument, Document&amp; newDocument);
664     static void moveTreeToNewScope(Node&amp;, TreeScope&amp; oldScope, TreeScope&amp; newScope);
665     void moveNodeToNewDocument(Document&amp; oldDocument, Document&amp; newDocument);
666 
<span class="line-modified">667     struct NodeRareDataDeleter {</span>
<span class="line-added">668         void operator()(NodeRareData*) const;</span>
<span class="line-added">669     };</span>
<span class="line-added">670 </span>
<span class="line-added">671     uint32_t m_refCountAndParentBit { s_refCountIncrement };</span>
672     mutable uint32_t m_nodeFlags;
673 
674     ContainerNode* m_parentNode { nullptr };
675     TreeScope* m_treeScope { nullptr };
676     Node* m_previous { nullptr };
677     Node* m_next { nullptr };
<span class="line-modified">678     CompactPointerTuple&lt;RenderObject*, uint8_t&gt; m_rendererWithStyleFlags;</span>
<span class="line-modified">679     std::unique_ptr&lt;NodeRareData, NodeRareDataDeleter&gt; m_rareData;</span>



680 };
681 
682 #ifndef NDEBUG
683 inline void adopted(Node* node)
684 {
685     if (!node)
686         return;
687     ASSERT(!node-&gt;m_deletionHasBegun);
688     ASSERT(!node-&gt;m_inRemovedLastRefFunction);
689     node-&gt;m_adoptionIsRequired = false;
690 }
691 #endif
692 
693 ALWAYS_INLINE void Node::ref()
694 {
695     ASSERT(isMainThread());
696     ASSERT(!m_deletionHasBegun);
697     ASSERT(!m_inRemovedLastRefFunction);
698     ASSERT(!m_adoptionIsRequired);
<span class="line-modified">699     m_refCountAndParentBit += s_refCountIncrement;</span>
700 }
701 
702 ALWAYS_INLINE void Node::deref()
703 {
704     ASSERT(isMainThread());
<span class="line-modified">705     ASSERT(refCount());</span>
706     ASSERT(!m_deletionHasBegun);
707     ASSERT(!m_inRemovedLastRefFunction);
708     ASSERT(!m_adoptionIsRequired);
<span class="line-modified">709     auto updatedRefCount = m_refCountAndParentBit - s_refCountIncrement;</span>
<span class="line-added">710     if (!updatedRefCount) {</span>
<span class="line-added">711         // Don&#39;t update m_refCountAndParentBit to avoid double destruction through use of Ref&lt;T&gt;/RefPtr&lt;T&gt;.</span>
<span class="line-added">712         // (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)</span>
713 #ifndef NDEBUG
714         m_inRemovedLastRefFunction = true;
715 #endif
716         removedLastRef();
<span class="line-added">717         return;</span>
718     }
<span class="line-added">719     m_refCountAndParentBit = updatedRefCount;</span>
720 }
721 
722 ALWAYS_INLINE bool Node::hasOneRef() const
723 {
724     ASSERT(!m_deletionHasBegun);
725     ASSERT(!m_inRemovedLastRefFunction);
<span class="line-modified">726     return refCount() == 1;</span>
727 }
728 
<span class="line-modified">729 ALWAYS_INLINE unsigned Node::refCount() const</span>
730 {
<span class="line-modified">731     return m_refCountAndParentBit / s_refCountIncrement;</span>
732 }
733 
734 // Used in Node::addSubresourceAttributeURLs() and in addSubresourceStyleURLs()
735 inline void addSubresourceURL(ListHashSet&lt;URL&gt;&amp; urls, const URL&amp; url)
736 {
737     if (!url.isNull())
738         urls.add(url);
739 }
740 
741 inline void Node::setParentNode(ContainerNode* parent)
742 {
743     ASSERT(isMainThread());
744     m_parentNode = parent;
<span class="line-added">745     m_refCountAndParentBit = (m_refCountAndParentBit &amp; s_refCountMask) | !!parent;</span>
746 }
747 
748 inline ContainerNode* Node::parentNode() const
749 {
750     ASSERT(isMainThreadOrGCThread());
751     return m_parentNode;
752 }
753 
754 inline void* Node::opaqueRoot() const
755 {
756     // FIXME: Possible race?
757     // https://bugs.webkit.org/show_bug.cgi?id=165713
758     if (isConnected())
759         return &amp;document();
760     return opaqueRootSlow();
761 }
762 
763 inline ContainerNode* Node::parentNodeGuaranteedHostFree() const
764 {
765     ASSERT(!isShadowRoot());
</pre>
</td>
</tr>
</table>
<center><a href="Node.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NodeIterator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>