<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/editing/ReplaceSelectionCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2005-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2009, 2010, 2011 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;ReplaceSelectionCommand.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;ApplyStyleCommand.h&quot;
  32 #include &quot;BeforeTextInsertedEvent.h&quot;
  33 #include &quot;BreakBlockquoteCommand.h&quot;
  34 #include &quot;CSSComputedStyleDeclaration.h&quot;
  35 #include &quot;CSSStyleDeclaration.h&quot;
  36 #include &quot;DOMWrapperWorld.h&quot;
  37 #include &quot;DataTransfer.h&quot;
  38 #include &quot;Document.h&quot;
  39 #include &quot;DocumentFragment.h&quot;
  40 #include &quot;Editing.h&quot;
  41 #include &quot;EditingBehavior.h&quot;
  42 #include &quot;ElementIterator.h&quot;
  43 #include &quot;EventNames.h&quot;
  44 #include &quot;Frame.h&quot;
  45 #include &quot;FrameSelection.h&quot;
  46 #include &quot;HTMLBRElement.h&quot;
  47 #include &quot;HTMLBaseElement.h&quot;
  48 #include &quot;HTMLBodyElement.h&quot;
  49 #include &quot;HTMLInputElement.h&quot;
  50 #include &quot;HTMLLIElement.h&quot;
  51 #include &quot;HTMLLinkElement.h&quot;
  52 #include &quot;HTMLMetaElement.h&quot;
  53 #include &quot;HTMLNames.h&quot;
  54 #include &quot;HTMLStyleElement.h&quot;
  55 #include &quot;HTMLTitleElement.h&quot;
  56 #include &quot;NodeList.h&quot;
  57 #include &quot;NodeRenderStyle.h&quot;
  58 #include &quot;RenderInline.h&quot;
  59 #include &quot;RenderText.h&quot;
  60 #include &quot;ScriptElement.h&quot;
  61 #include &quot;SimplifyMarkupCommand.h&quot;
  62 #include &quot;SmartReplace.h&quot;
  63 #include &quot;StyleProperties.h&quot;
  64 #include &quot;Text.h&quot;
  65 #include &quot;TextIterator.h&quot;
  66 #include &quot;VisibleUnits.h&quot;
  67 #include &quot;markup.h&quot;
  68 #include &lt;wtf/NeverDestroyed.h&gt;
  69 #include &lt;wtf/StdLibExtras.h&gt;
  70 
  71 namespace WebCore {
  72 
  73 using namespace HTMLNames;
  74 
  75 enum EFragmentType { EmptyFragment, SingleTextNodeFragment, TreeFragment };
  76 
  77 // --- ReplacementFragment helper class
  78 
  79 class ReplacementFragment {
  80     WTF_MAKE_FAST_ALLOCATED;
  81     WTF_MAKE_NONCOPYABLE(ReplacementFragment);
  82 public:
  83     ReplacementFragment(DocumentFragment*, const VisibleSelection&amp;);
  84 
  85     DocumentFragment* fragment() { return m_fragment.get(); }
  86 
  87     Node* firstChild() const;
  88     Node* lastChild() const;
  89 
  90     bool isEmpty() const;
  91 
  92     bool hasInterchangeNewlineAtStart() const { return m_hasInterchangeNewlineAtStart; }
  93     bool hasInterchangeNewlineAtEnd() const { return m_hasInterchangeNewlineAtEnd; }
  94 
  95     void removeNode(Node&amp;);
  96     void removeNodePreservingChildren(Node&amp;);
  97 
  98 private:
  99     void removeContentsWithSideEffects();
 100     Ref&lt;HTMLElement&gt; insertFragmentForTestRendering(Node* rootEditableNode);
 101     void removeUnrenderedNodes(Node*);
 102     void restoreAndRemoveTestRenderingNodesToFragment(StyledElement*);
 103     void removeInterchangeNodes(Node*);
 104 
 105     void insertNodeBefore(Node&amp;, Node&amp; refNode);
 106 
 107     RefPtr&lt;DocumentFragment&gt; m_fragment;
 108     bool m_hasInterchangeNewlineAtStart;
 109     bool m_hasInterchangeNewlineAtEnd;
 110 };
 111 
 112 static bool isInterchangeNewlineNode(const Node* node)
 113 {
 114     static NeverDestroyed&lt;String&gt; interchangeNewlineClassString(AppleInterchangeNewline);
 115     return is&lt;HTMLBRElement&gt;(node) &amp;&amp; downcast&lt;HTMLBRElement&gt;(*node).attributeWithoutSynchronization(classAttr) == interchangeNewlineClassString;
 116 }
 117 
 118 static bool isInterchangeConvertedSpaceSpan(const Node* node)
 119 {
 120     static NeverDestroyed&lt;String&gt; convertedSpaceSpanClassString(AppleConvertedSpace);
 121     return is&lt;HTMLElement&gt;(node) &amp;&amp; downcast&lt;HTMLElement&gt;(*node).attributeWithoutSynchronization(classAttr) == convertedSpaceSpanClassString;
 122 }
 123 
 124 static Position positionAvoidingPrecedingNodes(Position position)
 125 {
 126     ASSERT(position.isNotNull());
 127 
 128     // If we&#39;re already on a break, it&#39;s probably a placeholder and we shouldn&#39;t change our position.
 129     if (editingIgnoresContent(*position.deprecatedNode()))
 130         return position;
 131 
 132     // We also stop when changing block flow elements because even though the visual position is the
 133     // same.  E.g.,
 134     //   &lt;div&gt;foo^&lt;/div&gt;^
 135     // The two positions above are the same visual position, but we want to stay in the same block.
 136     auto* enclosingBlockNode = enclosingBlock(position.containerNode());
 137     for (Position nextPosition = position; nextPosition.containerNode() != enclosingBlockNode; position = nextPosition) {
 138         if (lineBreakExistsAtPosition(position))
 139             break;
 140 
 141         if (position.containerNode()-&gt;nonShadowBoundaryParentNode())
 142             nextPosition = positionInParentAfterNode(position.containerNode());
 143 
 144         if (nextPosition == position)
 145             break;
 146         if (enclosingBlock(nextPosition.containerNode()) != enclosingBlockNode)
 147             break;
 148         if (VisiblePosition(position) != VisiblePosition(nextPosition))
 149             break;
 150     }
 151     return position;
 152 }
 153 
 154 ReplacementFragment::ReplacementFragment(DocumentFragment* fragment, const VisibleSelection&amp; selection)
 155     : m_fragment(fragment)
 156     , m_hasInterchangeNewlineAtStart(false)
 157     , m_hasInterchangeNewlineAtEnd(false)
 158 {
 159     if (!m_fragment)
 160         return;
 161     if (!m_fragment-&gt;firstChild())
 162         return;
 163 
 164     removeContentsWithSideEffects();
 165 
 166     RefPtr&lt;Element&gt; editableRoot = selection.rootEditableElement();
 167     ASSERT(editableRoot);
 168     if (!editableRoot)
 169         return;
 170 
 171     auto* shadowHost = editableRoot-&gt;shadowHost();
 172     if (!editableRoot-&gt;attributeEventListener(eventNames().webkitBeforeTextInsertedEvent, mainThreadNormalWorld())
 173         &amp;&amp; !(shadowHost &amp;&amp; shadowHost-&gt;renderer() &amp;&amp; shadowHost-&gt;renderer()-&gt;isTextControl())
 174         &amp;&amp; editableRoot-&gt;hasRichlyEditableStyle()) {
 175         removeInterchangeNodes(m_fragment.get());
 176         return;
 177     }
 178 
 179     auto page = createPageForSanitizingWebContent();
 180     Document* stagingDocument = page-&gt;mainFrame().document();
 181     ASSERT(stagingDocument-&gt;body());
 182 
 183     ComputedStyleExtractor computedStyleOfEditableRoot(editableRoot.get());
 184     stagingDocument-&gt;body()-&gt;setAttributeWithoutSynchronization(styleAttr, computedStyleOfEditableRoot.copyProperties()-&gt;asText());
 185 
 186     RefPtr&lt;StyledElement&gt; holder = insertFragmentForTestRendering(stagingDocument-&gt;body());
 187     if (!holder) {
 188         removeInterchangeNodes(m_fragment.get());
 189         return;
 190     }
 191 
 192     RefPtr&lt;Range&gt; range = VisibleSelection::selectionFromContentsOfNode(holder.get()).toNormalizedRange();
 193     String text = plainText(range.get(), static_cast&lt;TextIteratorBehavior&gt;(TextIteratorEmitsOriginalText | TextIteratorIgnoresStyleVisibility));
 194 
 195     removeInterchangeNodes(holder.get());
 196     removeUnrenderedNodes(holder.get());
 197     restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 198 
 199     // Give the root a chance to change the text.
 200     auto event = BeforeTextInsertedEvent::create(text);
 201     editableRoot-&gt;dispatchEvent(event);
 202     if (text != event-&gt;text() || !editableRoot-&gt;hasRichlyEditableStyle()) {
 203         restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 204 
 205         RefPtr&lt;Range&gt; range = selection.toNormalizedRange();
 206         if (!range)
 207             return;
 208 
 209         m_fragment = createFragmentFromText(*range, event-&gt;text());
 210         if (!m_fragment-&gt;firstChild())
 211             return;
 212 
 213         holder = insertFragmentForTestRendering(stagingDocument-&gt;body());
 214         removeInterchangeNodes(holder.get());
 215         removeUnrenderedNodes(holder.get());
 216         restoreAndRemoveTestRenderingNodesToFragment(holder.get());
 217     }
 218 }
 219 
 220 void ReplacementFragment::removeContentsWithSideEffects()
 221 {
 222     Vector&lt;Ref&lt;Element&gt;&gt; elementsToRemove;
 223     Vector&lt;std::pair&lt;Ref&lt;Element&gt;, QualifiedName&gt;&gt; attributesToRemove;
 224 
 225     auto it = descendantsOfType&lt;Element&gt;(*m_fragment).begin();
 226     auto end = descendantsOfType&lt;Element&gt;(*m_fragment).end();
 227     while (it != end) {
 228         auto element = makeRef(*it);
 229         if (isScriptElement(element) || (is&lt;HTMLStyleElement&gt;(element) &amp;&amp; element-&gt;getAttribute(classAttr) != WebKitMSOListQuirksStyle)
 230             || is&lt;HTMLBaseElement&gt;(element) || is&lt;HTMLLinkElement&gt;(element) || is&lt;HTMLMetaElement&gt;(element) || is&lt;HTMLTitleElement&gt;(element)) {
 231             elementsToRemove.append(WTFMove(element));
 232             it.traverseNextSkippingChildren();
 233             continue;
 234         }
 235         if (element-&gt;hasAttributes()) {
 236             for (auto&amp; attribute : element-&gt;attributesIterator()) {
 237                 if (element-&gt;isEventHandlerAttribute(attribute) || element-&gt;isJavaScriptURLAttribute(attribute))
 238                     attributesToRemove.append({ element.copyRef(), attribute.name() });
 239             }
 240         }
 241         ++it;
 242     }
 243 
 244     for (auto&amp; element : elementsToRemove)
 245         removeNode(WTFMove(element));
 246 
 247     for (auto&amp; item : attributesToRemove)
 248         item.first-&gt;removeAttribute(item.second);
 249 }
 250 
 251 bool ReplacementFragment::isEmpty() const
 252 {
 253     return (!m_fragment || !m_fragment-&gt;firstChild()) &amp;&amp; !m_hasInterchangeNewlineAtStart &amp;&amp; !m_hasInterchangeNewlineAtEnd;
 254 }
 255 
 256 Node *ReplacementFragment::firstChild() const
 257 {
 258     return m_fragment ? m_fragment-&gt;firstChild() : 0;
 259 }
 260 
 261 Node *ReplacementFragment::lastChild() const
 262 {
 263     return m_fragment ? m_fragment-&gt;lastChild() : 0;
 264 }
 265 
 266 void ReplacementFragment::removeNodePreservingChildren(Node&amp; node)
 267 {
 268     Ref&lt;Node&gt; protectedNode = node;
 269     while (RefPtr&lt;Node&gt; n = node.firstChild()) {
 270         removeNode(*n);
 271         insertNodeBefore(*n, node);
 272     }
 273     removeNode(node);
 274 }
 275 
 276 void ReplacementFragment::removeNode(Node&amp; node)
 277 {
 278     ContainerNode* parent = node.nonShadowBoundaryParentNode();
 279     if (!parent)
 280         return;
 281 
 282     parent-&gt;removeChild(node);
 283 }
 284 
 285 void ReplacementFragment::insertNodeBefore(Node&amp; node, Node&amp; refNode)
 286 {
 287     ContainerNode* parent = refNode.nonShadowBoundaryParentNode();
 288     if (!parent)
 289         return;
 290 
 291     parent-&gt;insertBefore(node, &amp;refNode);
 292 }
 293 
 294 Ref&lt;HTMLElement&gt; ReplacementFragment::insertFragmentForTestRendering(Node* rootNode)
 295 {
 296     auto document = makeRef(rootNode-&gt;document());
 297     auto holder = createDefaultParagraphElement(document.get());
 298 
 299     holder-&gt;appendChild(*m_fragment);
 300     rootNode-&gt;appendChild(holder);
 301     document-&gt;updateLayoutIgnorePendingStylesheets();
 302 
 303     return holder;
 304 }
 305 
 306 void ReplacementFragment::restoreAndRemoveTestRenderingNodesToFragment(StyledElement* holder)
 307 {
 308     if (!holder)
 309         return;
 310 
 311     while (RefPtr&lt;Node&gt; node = holder-&gt;firstChild()) {
 312         holder-&gt;removeChild(*node);
 313         m_fragment-&gt;appendChild(*node);
 314     }
 315 
 316     removeNode(*holder);
 317 }
 318 
 319 void ReplacementFragment::removeUnrenderedNodes(Node* holder)
 320 {
 321     Vector&lt;Ref&lt;Node&gt;&gt; unrendered;
 322 
 323     for (Node* node = holder-&gt;firstChild(); node; node = NodeTraversal::next(*node, holder)) {
 324         if (!isNodeRendered(*node) &amp;&amp; !isTableStructureNode(node))
 325             unrendered.append(*node);
 326     }
 327 
 328     for (auto&amp; node : unrendered)
 329         removeNode(node);
 330 }
 331 
 332 void ReplacementFragment::removeInterchangeNodes(Node* container)
 333 {
 334     m_hasInterchangeNewlineAtStart = false;
 335     m_hasInterchangeNewlineAtEnd = false;
 336 
 337     // Interchange newlines at the &quot;start&quot; of the incoming fragment must be
 338     // either the first node in the fragment or the first leaf in the fragment.
 339     Node* node = container-&gt;firstChild();
 340     while (node) {
 341         if (isInterchangeNewlineNode(node)) {
 342             m_hasInterchangeNewlineAtStart = true;
 343             removeNode(*node);
 344             break;
 345         }
 346         node = node-&gt;firstChild();
 347     }
 348     if (!container-&gt;hasChildNodes())
 349         return;
 350     // Interchange newlines at the &quot;end&quot; of the incoming fragment must be
 351     // either the last node in the fragment or the last leaf in the fragment.
 352     node = container-&gt;lastChild();
 353     while (node) {
 354         if (isInterchangeNewlineNode(node)) {
 355             m_hasInterchangeNewlineAtEnd = true;
 356             removeNode(*node);
 357             break;
 358         }
 359         node = node-&gt;lastChild();
 360     }
 361 
 362     node = container-&gt;firstChild();
 363     while (node) {
 364         RefPtr&lt;Node&gt; next = NodeTraversal::next(*node);
 365         if (isInterchangeConvertedSpaceSpan(node)) {
 366             next = NodeTraversal::nextSkippingChildren(*node);
 367             removeNodePreservingChildren(*node);
 368         }
 369         node = next.get();
 370     }
 371 }
 372 
 373 inline void ReplaceSelectionCommand::InsertedNodes::respondToNodeInsertion(Node* node)
 374 {
 375     if (!node)
 376         return;
 377 
 378     if (!m_firstNodeInserted)
 379         m_firstNodeInserted = node;
 380 
 381     m_lastNodeInserted = node;
 382 }
 383 
 384 inline void ReplaceSelectionCommand::InsertedNodes::willRemoveNodePreservingChildren(Node* node)
 385 {
 386     if (m_firstNodeInserted == node)
 387         m_firstNodeInserted = NodeTraversal::next(*node);
 388     if (m_lastNodeInserted == node) {
 389         m_lastNodeInserted = node-&gt;lastChild() ? node-&gt;lastChild() : NodeTraversal::nextSkippingChildren(*node);
 390         if (!m_lastNodeInserted) {
 391             // If the last inserted node is at the end of the document and doesn&#39;t have any children, look backwards for the
 392             // previous node as the last inserted node, clamping to the first inserted node if needed to ensure that the
 393             // document position of the last inserted node is not behind the first inserted node.
 394             auto* previousNode = NodeTraversal::previousSkippingChildren(*node);
 395             ASSERT(previousNode);
 396             m_lastNodeInserted = m_firstNodeInserted-&gt;compareDocumentPosition(*previousNode) &amp; Node::DOCUMENT_POSITION_FOLLOWING ? previousNode : m_firstNodeInserted;
 397         }
 398     }
 399 }
 400 
 401 inline void ReplaceSelectionCommand::InsertedNodes::willRemoveNode(Node* node)
 402 {
 403     if (m_firstNodeInserted == node &amp;&amp; m_lastNodeInserted == node) {
 404         m_firstNodeInserted = nullptr;
 405         m_lastNodeInserted = nullptr;
 406     } else if (m_firstNodeInserted == node)
 407         m_firstNodeInserted = NodeTraversal::nextSkippingChildren(*m_firstNodeInserted);
 408     else if (m_lastNodeInserted == node)
 409         m_lastNodeInserted = NodeTraversal::previousSkippingChildren(*m_lastNodeInserted);
 410 }
 411 
 412 inline void ReplaceSelectionCommand::InsertedNodes::didReplaceNode(Node* node, Node* newNode)
 413 {
 414     if (m_firstNodeInserted == node)
 415         m_firstNodeInserted = newNode;
 416     if (m_lastNodeInserted == node)
 417         m_lastNodeInserted = newNode;
 418 }
 419 
 420 ReplaceSelectionCommand::ReplaceSelectionCommand(Document&amp; document, RefPtr&lt;DocumentFragment&gt;&amp;&amp; fragment, OptionSet&lt;CommandOption&gt; options, EditAction editAction)
 421     : CompositeEditCommand(document, editAction)
 422     , m_selectReplacement(options &amp; SelectReplacement)
 423     , m_smartReplace(options &amp; SmartReplace)
 424     , m_matchStyle(options &amp; MatchStyle)
 425     , m_documentFragment(fragment)
 426     , m_preventNesting(options &amp; PreventNesting)
 427     , m_movingParagraph(options &amp; MovingParagraph)
 428     , m_sanitizeFragment(options &amp; SanitizeFragment)
 429     , m_shouldMergeEnd(false)
 430     , m_ignoreMailBlockquote(options &amp; IgnoreMailBlockquote)
 431 {
 432 }
 433 
 434 static bool hasMatchingQuoteLevel(VisiblePosition endOfExistingContent, VisiblePosition endOfInsertedContent)
 435 {
 436     Position existing = endOfExistingContent.deepEquivalent();
 437     Position inserted = endOfInsertedContent.deepEquivalent();
 438     bool isInsideMailBlockquote = enclosingNodeOfType(inserted, isMailBlockquote, CanCrossEditingBoundary);
 439     return isInsideMailBlockquote &amp;&amp; (numEnclosingMailBlockquotes(existing) == numEnclosingMailBlockquotes(inserted));
 440 }
 441 
 442 bool ReplaceSelectionCommand::shouldMergeStart(bool selectionStartWasStartOfParagraph, bool fragmentHasInterchangeNewlineAtStart, bool selectionStartWasInsideMailBlockquote)
 443 {
 444     if (m_movingParagraph)
 445         return false;
 446 
 447     VisiblePosition startOfInsertedContent(positionAtStartOfInsertedContent());
 448     VisiblePosition prev = startOfInsertedContent.previous(CannotCrossEditingBoundary);
 449     if (prev.isNull())
 450         return false;
 451 
 452     // When we have matching quote levels, its ok to merge more frequently.
 453     // For a successful merge, we still need to make sure that the inserted content starts with the beginning of a paragraph.
 454     // And we should only merge here if the selection start was inside a mail blockquote.  This prevents against removing a
 455     // blockquote from newly pasted quoted content that was pasted into an unquoted position.  If that unquoted position happens
 456     // to be right after another blockquote, we don&#39;t want to merge and risk stripping a valid block (and newline) from the pasted content.
 457     if (isStartOfParagraph(startOfInsertedContent) &amp;&amp; selectionStartWasInsideMailBlockquote &amp;&amp; hasMatchingQuoteLevel(prev, positionAtEndOfInsertedContent()))
 458         return true;
 459 
 460     return !selectionStartWasStartOfParagraph
 461         &amp;&amp; !fragmentHasInterchangeNewlineAtStart
 462         &amp;&amp; isStartOfParagraph(startOfInsertedContent)
 463         &amp;&amp; !startOfInsertedContent.deepEquivalent().deprecatedNode()-&gt;hasTagName(brTag)
 464         &amp;&amp; shouldMerge(startOfInsertedContent, prev);
 465 }
 466 
 467 bool ReplaceSelectionCommand::shouldMergeEnd(bool selectionEndWasEndOfParagraph)
 468 {
 469     VisiblePosition endOfInsertedContent(positionAtEndOfInsertedContent());
 470     VisiblePosition next = endOfInsertedContent.next(CannotCrossEditingBoundary);
 471     if (next.isNull())
 472         return false;
 473 
 474     return !selectionEndWasEndOfParagraph
 475         &amp;&amp; isEndOfParagraph(endOfInsertedContent)
 476         &amp;&amp; !endOfInsertedContent.deepEquivalent().deprecatedNode()-&gt;hasTagName(brTag)
 477         &amp;&amp; shouldMerge(endOfInsertedContent, next);
 478 }
 479 
 480 static bool isMailPasteAsQuotationNode(const Node* node)
 481 {
 482     return node &amp;&amp; node-&gt;hasTagName(blockquoteTag) &amp;&amp; downcast&lt;Element&gt;(node)-&gt;attributeWithoutSynchronization(classAttr) == ApplePasteAsQuotation;
 483 }
 484 
 485 static bool isHeaderElement(const Node* a)
 486 {
 487     if (!a)
 488         return false;
 489 
 490     return a-&gt;hasTagName(h1Tag)
 491         || a-&gt;hasTagName(h2Tag)
 492         || a-&gt;hasTagName(h3Tag)
 493         || a-&gt;hasTagName(h4Tag)
 494         || a-&gt;hasTagName(h5Tag)
 495         || a-&gt;hasTagName(h6Tag);
 496 }
 497 
 498 static bool haveSameTagName(Node* a, Node* b)
 499 {
 500     return is&lt;Element&gt;(a) &amp;&amp; is&lt;Element&gt;(b) &amp;&amp; downcast&lt;Element&gt;(*a).tagName() == downcast&lt;Element&gt;(*b).tagName();
 501 }
 502 
 503 bool ReplaceSelectionCommand::shouldMerge(const VisiblePosition&amp; source, const VisiblePosition&amp; destination)
 504 {
 505     if (source.isNull() || destination.isNull())
 506         return false;
 507 
 508     auto* sourceNode = source.deepEquivalent().deprecatedNode();
 509     auto* destinationNode = destination.deepEquivalent().deprecatedNode();
 510     auto* sourceBlock = enclosingBlock(sourceNode);
 511     auto* destinationBlock = enclosingBlock(destinationNode);
 512     return !enclosingNodeOfType(source.deepEquivalent(), &amp;isMailPasteAsQuotationNode)
 513         &amp;&amp; sourceBlock
 514         &amp;&amp; (!sourceBlock-&gt;hasTagName(blockquoteTag) || isMailBlockquote(sourceBlock))
 515         &amp;&amp; enclosingListChild(sourceBlock) == enclosingListChild(destinationNode)
 516         &amp;&amp; enclosingTableCell(source.deepEquivalent()) == enclosingTableCell(destination.deepEquivalent())
 517         &amp;&amp; (!isHeaderElement(sourceBlock) || haveSameTagName(sourceBlock, destinationBlock))
 518         // Don&#39;t merge to or from a position before or after a block because it would
 519         // be a no-op and cause infinite recursion.
 520         &amp;&amp; !isBlock(sourceNode) &amp;&amp; !isBlock(destinationNode);
 521 }
 522 
 523 // Style rules that match just inserted elements could change their appearance, like
 524 // a div inserted into a document with div { display:inline; }.
 525 void ReplaceSelectionCommand::removeRedundantStylesAndKeepStyleSpanInline(InsertedNodes&amp; insertedNodes)
 526 {
 527     RefPtr&lt;Node&gt; pastEndNode = insertedNodes.pastLastLeaf();
 528     RefPtr&lt;Node&gt; next;
 529     for (RefPtr&lt;Node&gt; node = insertedNodes.firstNodeInserted(); node &amp;&amp; node != pastEndNode; node = next) {
 530         // FIXME: &lt;rdar://problem/5371536&gt; Style rules that match pasted content can change it&#39;s appearance
 531 
 532         next = NodeTraversal::next(*node);
 533         if (!is&lt;StyledElement&gt;(*node))
 534             continue;
 535 
 536         StyledElement* element = downcast&lt;StyledElement&gt;(node.get());
 537 
 538         const StyleProperties* inlineStyle = element-&gt;inlineStyle();
 539         auto newInlineStyle = EditingStyle::create(inlineStyle);
 540         if (inlineStyle) {
 541             if (is&lt;HTMLElement&gt;(*element)) {
 542                 Vector&lt;QualifiedName&gt; attributes;
 543                 HTMLElement&amp; htmlElement = downcast&lt;HTMLElement&gt;(*element);
 544 
 545                 if (newInlineStyle-&gt;conflictsWithImplicitStyleOfElement(htmlElement)) {
 546                     // e.g. &lt;b style=&quot;font-weight: normal;&quot;&gt; is converted to &lt;span style=&quot;font-weight: normal;&quot;&gt;
 547                     node = replaceElementWithSpanPreservingChildrenAndAttributes(htmlElement);
 548                     element = downcast&lt;StyledElement&gt;(node.get());
 549                     insertedNodes.didReplaceNode(&amp;htmlElement, node.get());
 550                 } else if (newInlineStyle-&gt;extractConflictingImplicitStyleOfAttributes(htmlElement, EditingStyle::PreserveWritingDirection, nullptr, attributes, EditingStyle::DoNotExtractMatchingStyle)) {
 551                     // e.g. &lt;font size=&quot;3&quot; style=&quot;font-size: 20px;&quot;&gt; is converted to &lt;font style=&quot;font-size: 20px;&quot;&gt;
 552                     for (auto&amp; attribute : attributes)
 553                         removeNodeAttribute(*element, attribute);
 554                 }
 555             }
 556 
 557             ContainerNode* context = element-&gt;parentNode();
 558 
 559             // If Mail wraps the fragment with a Paste as Quotation blockquote, or if you&#39;re pasting into a quoted region,
 560             // styles from blockquoteNode are allowed to override those from the source document, see &lt;rdar://problem/4930986&gt; and &lt;rdar://problem/5089327&gt;.
 561             Node* blockquoteNode = isMailPasteAsQuotationNode(context) ? context : enclosingNodeOfType(firstPositionInNode(context), isMailBlockquote, CanCrossEditingBoundary);
 562             if (blockquoteNode)
 563                 newInlineStyle-&gt;removeStyleFromRulesAndContext(*element, document().documentElement());
 564 
 565             newInlineStyle-&gt;removeStyleFromRulesAndContext(*element, context);
 566         }
 567 
 568         if (!inlineStyle || newInlineStyle-&gt;isEmpty()) {
 569             if (isStyleSpanOrSpanWithOnlyStyleAttribute(*element) || isEmptyFontTag(element, AllowNonEmptyStyleAttribute)) {
 570                 insertedNodes.willRemoveNodePreservingChildren(element);
 571                 removeNodePreservingChildren(*element);
 572                 continue;
 573             }
 574             removeNodeAttribute(*element, styleAttr);
 575         } else if (newInlineStyle-&gt;style()-&gt;propertyCount() != inlineStyle-&gt;propertyCount())
 576             setNodeAttribute(*element, styleAttr, newInlineStyle-&gt;style()-&gt;asText());
 577 
 578         // FIXME: Tolerate differences in id, class, and style attributes.
 579         if (element-&gt;parentNode() &amp;&amp; isNonTableCellHTMLBlockElement(element) &amp;&amp; areIdenticalElements(*element, *element-&gt;parentNode())
 580             &amp;&amp; VisiblePosition(firstPositionInNode(element-&gt;parentNode())) == VisiblePosition(firstPositionInNode(element))
 581             &amp;&amp; VisiblePosition(lastPositionInNode(element-&gt;parentNode())) == VisiblePosition(lastPositionInNode(element))) {
 582             insertedNodes.willRemoveNodePreservingChildren(element);
 583             removeNodePreservingChildren(*element);
 584             continue;
 585         }
 586 
 587         if (element-&gt;parentNode() &amp;&amp; element-&gt;parentNode()-&gt;hasRichlyEditableStyle())
 588             removeNodeAttribute(*element, contenteditableAttr);
 589 
 590         // WebKit used to not add display: inline and float: none on copy.
 591         // Keep this code around for backward compatibility
 592         if (isLegacyAppleStyleSpan(element)) {
 593             if (!element-&gt;firstChild()) {
 594                 insertedNodes.willRemoveNodePreservingChildren(element);
 595                 removeNodePreservingChildren(*element);
 596                 continue;
 597             }
 598             // There are other styles that style rules can give to style spans,
 599             // but these are the two important ones because they&#39;ll prevent
 600             // inserted content from appearing in the right paragraph.
 601             // FIXME: Hyatt is concerned that selectively using display:inline will give inconsistent
 602             // results. We already know one issue because td elements ignore their display property
 603             // in quirks mode (which Mail.app is always in). We should look for an alternative.
 604 
 605             // Mutate using the CSSOM wrapper so we get the same event behavior as a script.
 606             if (isBlock(element))
 607                 element-&gt;cssomStyle().setPropertyInternal(CSSPropertyDisplay, &quot;inline&quot;, false);
 608             if (element-&gt;renderer() &amp;&amp; element-&gt;renderer()-&gt;style().isFloating())
 609                 element-&gt;cssomStyle().setPropertyInternal(CSSPropertyFloat, &quot;none&quot;, false);
 610         }
 611     }
 612 }
 613 
 614 static bool isProhibitedParagraphChild(const AtomString&amp; name)
 615 {
 616     // https://dvcs.w3.org/hg/editing/raw-file/57abe6d3cb60/editing.html#prohibited-paragraph-child
 617     static const auto localNames = makeNeverDestroyed([] {
 618         static const HTMLQualifiedName* const tags[] = {
 619             &amp;addressTag.get(),
 620             &amp;articleTag.get(),
 621             &amp;asideTag.get(),
 622             &amp;blockquoteTag.get(),
 623             &amp;captionTag.get(),
 624             &amp;centerTag.get(),
 625             &amp;colTag.get(),
 626             &amp;colgroupTag.get(),
 627             &amp;ddTag.get(),
 628             &amp;detailsTag.get(),
 629             &amp;dirTag.get(),
 630             &amp;divTag.get(),
 631             &amp;dlTag.get(),
 632             &amp;dtTag.get(),
 633             &amp;fieldsetTag.get(),
 634             &amp;figcaptionTag.get(),
 635             &amp;figureTag.get(),
 636             &amp;footerTag.get(),
 637             &amp;formTag.get(),
 638             &amp;h1Tag.get(),
 639             &amp;h2Tag.get(),
 640             &amp;h3Tag.get(),
 641             &amp;h4Tag.get(),
 642             &amp;h5Tag.get(),
 643             &amp;h6Tag.get(),
 644             &amp;headerTag.get(),
 645             &amp;hgroupTag.get(),
 646             &amp;hrTag.get(),
 647             &amp;liTag.get(),
 648             &amp;listingTag.get(),
 649             &amp;mainTag.get(), // Missing in the specification.
 650             &amp;menuTag.get(),
 651             &amp;navTag.get(),
 652             &amp;olTag.get(),
 653             &amp;pTag.get(),
 654             &amp;plaintextTag.get(),
 655             &amp;preTag.get(),
 656             &amp;sectionTag.get(),
 657             &amp;summaryTag.get(),
 658             &amp;tableTag.get(),
 659             &amp;tbodyTag.get(),
 660             &amp;tdTag.get(),
 661             &amp;tfootTag.get(),
 662             &amp;thTag.get(),
 663             &amp;theadTag.get(),
 664             &amp;trTag.get(),
 665             &amp;ulTag.get(),
 666             &amp;xmpTag.get(),
 667         };
 668         HashSet&lt;AtomString&gt; set;
 669         for (auto&amp; tag : tags)
 670             set.add(tag-&gt;localName());
 671         return set;
 672     }());
 673     return localNames.get().contains(name);
 674 }
 675 
 676 void ReplaceSelectionCommand::makeInsertedContentRoundTrippableWithHTMLTreeBuilder(InsertedNodes&amp; insertedNodes)
 677 {
 678     RefPtr&lt;Node&gt; pastEndNode = insertedNodes.pastLastLeaf();
 679     RefPtr&lt;Node&gt; next;
 680     for (RefPtr&lt;Node&gt; node = insertedNodes.firstNodeInserted(); node &amp;&amp; node != pastEndNode; node = next) {
 681         next = NodeTraversal::next(*node);
 682 
 683         if (!is&lt;HTMLElement&gt;(*node))
 684             continue;
 685 
 686         if (isProhibitedParagraphChild(downcast&lt;HTMLElement&gt;(*node).localName())) {
 687             if (auto* paragraphElement = enclosingElementWithTag(positionInParentBeforeNode(node.get()), pTag)) {
 688                 auto* parent = paragraphElement-&gt;parentNode();
 689                 if (parent &amp;&amp; parent-&gt;hasEditableStyle())
 690                     moveNodeOutOfAncestor(*node, *paragraphElement, insertedNodes);
 691             }
 692         }
 693 
 694         if (isHeaderElement(node.get())) {
 695             if (auto* headerElement = highestEnclosingNodeOfType(positionInParentBeforeNode(node.get()), isHeaderElement)) {
 696                 if (headerElement-&gt;parentNode() &amp;&amp; headerElement-&gt;parentNode()-&gt;isContentRichlyEditable())
 697                     moveNodeOutOfAncestor(*node, *headerElement, insertedNodes);
 698                 else {
 699                     HTMLElement* newSpanElement = replaceElementWithSpanPreservingChildrenAndAttributes(downcast&lt;HTMLElement&gt;(*node));
 700                     insertedNodes.didReplaceNode(node.get(), newSpanElement);
 701                 }
 702             }
 703         }
 704     }
 705 }
 706 
 707 static inline bool hasRenderedText(const Text&amp; text)
 708 {
 709     return text.renderer() &amp;&amp; text.renderer()-&gt;hasRenderedText();
 710 }
 711 
 712 void ReplaceSelectionCommand::moveNodeOutOfAncestor(Node&amp; node, Node&amp; ancestor, InsertedNodes&amp; insertedNodes)
 713 {
 714     Ref&lt;Node&gt; protectedNode = node;
 715     Ref&lt;Node&gt; protectedAncestor = ancestor;
 716 
 717     VisiblePosition positionAtEndOfNode = lastPositionInOrAfterNode(&amp;node);
 718     VisiblePosition lastPositionInParagraph = lastPositionInNode(&amp;ancestor);
 719     if (positionAtEndOfNode == lastPositionInParagraph) {
 720         removeNode(node);
 721         if (ancestor.nextSibling())
 722             insertNodeBefore(WTFMove(protectedNode), *ancestor.nextSibling());
 723         else
 724             appendNode(WTFMove(protectedNode), *ancestor.parentNode());
 725     } else {
 726         RefPtr&lt;Node&gt; nodeToSplitTo = splitTreeToNode(node, ancestor, true);
 727         removeNode(node);
 728         insertNodeBefore(WTFMove(protectedNode), *nodeToSplitTo);
 729     }
 730 
 731     document().updateLayoutIgnorePendingStylesheets();
 732 
 733     bool safeToRemoveAncestor = true;
 734     for (auto* child = ancestor.firstChild(); child; child = child-&gt;nextSibling()) {
 735         if (is&lt;Text&gt;(child) &amp;&amp; hasRenderedText(downcast&lt;Text&gt;(*child))) {
 736             safeToRemoveAncestor = false;
 737             break;
 738         }
 739 
 740         if (is&lt;Element&gt;(child)) {
 741             safeToRemoveAncestor = false;
 742             break;
 743         }
 744     }
 745 
 746     if (safeToRemoveAncestor) {
 747         insertedNodes.willRemoveNode(&amp;ancestor);
 748         removeNode(ancestor);
 749     }
 750 }
 751 
 752 void ReplaceSelectionCommand::removeUnrenderedTextNodesAtEnds(InsertedNodes&amp; insertedNodes)
 753 {
 754     document().updateLayoutIgnorePendingStylesheets();
 755 
 756     Node* lastLeafInserted = insertedNodes.lastLeafInserted();
 757     if (is&lt;Text&gt;(lastLeafInserted) &amp;&amp; !hasRenderedText(downcast&lt;Text&gt;(*lastLeafInserted))
 758         &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(lastLeafInserted), selectTag)
 759         &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(lastLeafInserted), scriptTag)) {
 760         insertedNodes.willRemoveNode(lastLeafInserted);
 761         removeNode(*lastLeafInserted);
 762     }
 763 
 764     // We don&#39;t have to make sure that firstNodeInserted isn&#39;t inside a select or script element
 765     // because it is a top level node in the fragment and the user can&#39;t insert into those elements.
 766     Node* firstNodeInserted = insertedNodes.firstNodeInserted();
 767     if (is&lt;Text&gt;(firstNodeInserted) &amp;&amp; !hasRenderedText(downcast&lt;Text&gt;(*firstNodeInserted))) {
 768         insertedNodes.willRemoveNode(firstNodeInserted);
 769         removeNode(*firstNodeInserted);
 770     }
 771 }
 772 
 773 VisiblePosition ReplaceSelectionCommand::positionAtEndOfInsertedContent() const
 774 {
 775     // FIXME: Why is this hack here?  What&#39;s special about &lt;select&gt; tags?
 776     auto* enclosingSelect = enclosingElementWithTag(m_endOfInsertedContent, selectTag);
 777     return enclosingSelect ? lastPositionInOrAfterNode(enclosingSelect) : m_endOfInsertedContent;
 778 }
 779 
 780 VisiblePosition ReplaceSelectionCommand::positionAtStartOfInsertedContent() const
 781 {
 782     return m_startOfInsertedContent;
 783 }
 784 
 785 // Remove style spans before insertion if they are unnecessary.  It&#39;s faster because we&#39;ll
 786 // avoid doing a layout.
 787 static bool handleStyleSpansBeforeInsertion(ReplacementFragment&amp; fragment, const Position&amp; insertionPos)
 788 {
 789     Node* topNode = fragment.firstChild();
 790 
 791     // Handling the case where we are doing Paste as Quotation or pasting into quoted content is more complicated (see handleStyleSpans)
 792     // and doesn&#39;t receive the optimization.
 793     if (isMailPasteAsQuotationNode(topNode) || enclosingNodeOfType(firstPositionInOrBeforeNode(topNode), isMailBlockquote, CanCrossEditingBoundary))
 794         return false;
 795 
 796     // Either there are no style spans in the fragment or a WebKit client has added content to the fragment
 797     // before inserting it.  Look for and handle style spans after insertion.
 798     if (!isLegacyAppleStyleSpan(topNode))
 799         return false;
 800 
 801     Node* wrappingStyleSpan = topNode;
 802     auto styleAtInsertionPos = EditingStyle::create(insertionPos.parentAnchoredEquivalent());
 803     String styleText = styleAtInsertionPos-&gt;style()-&gt;asText();
 804 
 805     // FIXME: This string comparison is a naive way of comparing two styles.
 806     // We should be taking the diff and check that the diff is empty.
 807     if (styleText != downcast&lt;Element&gt;(*wrappingStyleSpan).getAttribute(styleAttr))
 808         return false;
 809 
 810     fragment.removeNodePreservingChildren(*wrappingStyleSpan);
 811     return true;
 812 }
 813 
 814 // At copy time, WebKit wraps copied content in a span that contains the source document&#39;s
 815 // default styles.  If the copied Range inherits any other styles from its ancestors, we put
 816 // those styles on a second span.
 817 // This function removes redundant styles from those spans, and removes the spans if all their
 818 // styles are redundant.
 819 // We should remove the Apple-style-span class when we&#39;re done, see &lt;rdar://problem/5685600&gt;.
 820 // We should remove styles from spans that are overridden by all of their children, either here
 821 // or at copy time.
 822 void ReplaceSelectionCommand::handleStyleSpans(InsertedNodes&amp; insertedNodes)
 823 {
 824     HTMLElement* wrappingStyleSpan = nullptr;
 825     // The style span that contains the source document&#39;s default style should be at
 826     // the top of the fragment, but Mail sometimes adds a wrapper (for Paste As Quotation),
 827     // so search for the top level style span instead of assuming it&#39;s at the top.
 828     for (Node* node = insertedNodes.firstNodeInserted(); node; node = NodeTraversal::next(*node)) {
 829         if (isLegacyAppleStyleSpan(node)) {
 830             wrappingStyleSpan = downcast&lt;HTMLElement&gt;(node);
 831             break;
 832         }
 833     }
 834 
 835     // There might not be any style spans if we&#39;re pasting from another application or if
 836     // we are here because of a document.execCommand(&quot;InsertHTML&quot;, ...) call.
 837     if (!wrappingStyleSpan)
 838         return;
 839 
 840     auto style = EditingStyle::create(wrappingStyleSpan-&gt;inlineStyle());
 841     ContainerNode* context = wrappingStyleSpan-&gt;parentNode();
 842 
 843     // If Mail wraps the fragment with a Paste as Quotation blockquote, or if you&#39;re pasting into a quoted region,
 844     // styles from blockquoteNode are allowed to override those from the source document, see &lt;rdar://problem/4930986&gt; and &lt;rdar://problem/5089327&gt;.
 845     Node* blockquoteNode = isMailPasteAsQuotationNode(context) ? context : enclosingNodeOfType(firstPositionInNode(context), isMailBlockquote, CanCrossEditingBoundary);
 846     if (blockquoteNode)
 847         context = document().documentElement();
 848 
 849     // This operation requires that only editing styles to be removed from sourceDocumentStyle.
 850     style-&gt;prepareToApplyAt(firstPositionInNode(context));
 851 
 852     // Remove block properties in the span&#39;s style. This prevents properties that probably have no effect
 853     // currently from affecting blocks later if the style is cloned for a new block element during a future
 854     // editing operation.
 855     // FIXME: They *can* have an effect currently if blocks beneath the style span aren&#39;t individually marked
 856     // with block styles by the editing engine used to style them.  WebKit doesn&#39;t do this, but others might.
 857     style-&gt;removeBlockProperties();
 858 
 859     if (style-&gt;isEmpty() || !wrappingStyleSpan-&gt;firstChild()) {
 860         insertedNodes.willRemoveNodePreservingChildren(wrappingStyleSpan);
 861         removeNodePreservingChildren(*wrappingStyleSpan);
 862     } else
 863         setNodeAttribute(*wrappingStyleSpan, styleAttr, style-&gt;style()-&gt;asText());
 864 }
 865 
 866 void ReplaceSelectionCommand::mergeEndIfNeeded()
 867 {
 868     if (!m_shouldMergeEnd)
 869         return;
 870 
 871     VisiblePosition startOfInsertedContent(positionAtStartOfInsertedContent());
 872     VisiblePosition endOfInsertedContent(positionAtEndOfInsertedContent());
 873 
 874     // Bail to avoid infinite recursion.
 875     if (m_movingParagraph) {
 876         ASSERT_NOT_REACHED();
 877         return;
 878     }
 879 
 880     // Merging two paragraphs will destroy the moved one&#39;s block styles.  Always move the end of inserted forward
 881     // to preserve the block style of the paragraph already in the document, unless the paragraph to move would
 882     // include the what was the start of the selection that was pasted into, so that we preserve that paragraph&#39;s
 883     // block styles.
 884     bool mergeForward = !(inSameParagraph(startOfInsertedContent, endOfInsertedContent) &amp;&amp; !isStartOfParagraph(startOfInsertedContent));
 885 
 886     VisiblePosition destination = mergeForward ? endOfInsertedContent.next() : endOfInsertedContent;
 887     VisiblePosition startOfParagraphToMove = mergeForward ? startOfParagraph(endOfInsertedContent) : endOfInsertedContent.next();
 888 
 889     // Merging forward could result in deleting the destination anchor node.
 890     // To avoid this, we add a placeholder node before the start of the paragraph.
 891     if (endOfParagraph(startOfParagraphToMove) == destination) {
 892         auto placeholder = HTMLBRElement::create(document());
 893         auto* placeholderPtr = placeholder.ptr();
 894         insertNodeBefore(WTFMove(placeholder), *startOfParagraphToMove.deepEquivalent().deprecatedNode());
 895         destination = VisiblePosition(positionBeforeNode(placeholderPtr));
 896     }
 897 
 898     moveParagraph(startOfParagraphToMove, endOfParagraph(startOfParagraphToMove), destination);
 899 
 900     // Merging forward will remove m_endOfInsertedContent from the document.
 901     if (mergeForward) {
 902         if (m_startOfInsertedContent.isOrphan())
 903             m_startOfInsertedContent = endingSelection().visibleStart().deepEquivalent();
 904          m_endOfInsertedContent = endingSelection().visibleEnd().deepEquivalent();
 905         // If we merged text nodes, m_endOfInsertedContent could be null. If this is the case, we use m_startOfInsertedContent.
 906         if (m_endOfInsertedContent.isNull())
 907             m_endOfInsertedContent = m_startOfInsertedContent;
 908     }
 909 }
 910 
 911 static Node* enclosingInline(Node* node)
 912 {
 913     while (ContainerNode* parent = node-&gt;parentNode()) {
 914         if (isBlockFlowElement(*parent) || parent-&gt;hasTagName(bodyTag))
 915             return node;
 916         // Stop if any previous sibling is a block.
 917         for (Node* sibling = node-&gt;previousSibling(); sibling; sibling = sibling-&gt;previousSibling()) {
 918             if (isBlockFlowElement(*sibling))
 919                 return node;
 920         }
 921         node = parent;
 922     }
 923     return node;
 924 }
 925 
 926 static bool isInlineNodeWithStyle(const Node* node)
 927 {
 928     // We don&#39;t want to skip over any block elements.
 929     if (isBlock(node))
 930         return false;
 931 
 932     if (!node-&gt;isHTMLElement())
 933         return false;
 934 
 935     // We can skip over elements whose class attribute is
 936     // one of our internal classes.
 937     const HTMLElement* element = static_cast&lt;const HTMLElement*&gt;(node);
 938     const AtomString&amp; classAttributeValue = element-&gt;attributeWithoutSynchronization(classAttr);
 939     if (classAttributeValue == AppleTabSpanClass
 940         || classAttributeValue == AppleConvertedSpace
 941         || classAttributeValue == ApplePasteAsQuotation)
 942         return true;
 943 
 944     return EditingStyle::elementIsStyledSpanOrHTMLEquivalent(*element);
 945 }
 946 
 947 inline Node* nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(const Position&amp; insertionPos)
 948 {
 949     Node* containgBlock = enclosingBlock(insertionPos.containerNode());
 950     return highestEnclosingNodeOfType(insertionPos, isInlineNodeWithStyle, CannotCrossEditingBoundary, containgBlock);
 951 }
 952 
 953 bool ReplaceSelectionCommand::willApplyCommand()
 954 {
 955     m_documentFragmentPlainText = m_documentFragment-&gt;textContent();
 956     m_documentFragmentHTMLMarkup = serializeFragment(*m_documentFragment, SerializedNodes::SubtreeIncludingNode);
 957     ensureReplacementFragment();
 958     return CompositeEditCommand::willApplyCommand();
 959 }
 960 
 961 static bool hasBlankLineBetweenParagraphs(Position&amp; position)
 962 {
 963     bool reachedBoundaryStart = false;
 964     bool reachedBoundaryEnd = false;
 965     VisiblePosition visiblePosition(position);
 966     VisiblePosition previousPosition = visiblePosition.previous(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);
 967     VisiblePosition nextPosition = visiblePosition.next(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);
 968     bool hasLineBeforePosition = isEndOfLine(previousPosition);
 969 
 970     return !reachedBoundaryStart &amp;&amp; !reachedBoundaryEnd &amp;&amp; isBlankParagraph(visiblePosition) &amp;&amp; hasLineBeforePosition &amp;&amp; isStartOfLine(nextPosition);
 971 }
 972 
 973 void ReplaceSelectionCommand::doApply()
 974 {
 975     VisibleSelection selection = endingSelection();
 976     ASSERT(selection.isCaretOrRange());
 977     ASSERT(selection.start().deprecatedNode());
 978     if (selection.isNoneOrOrphaned() || !selection.start().deprecatedNode() || !selection.isContentEditable())
 979         return;
 980 
 981     // In plain text only regions, we create style-less fragments, so the inserted content will automatically
 982     // match the style of the surrounding area and so we can avoid unnecessary work below for m_matchStyle.
 983     if (!selection.isContentRichlyEditable())
 984         m_matchStyle = false;
 985 
 986     ReplacementFragment&amp; fragment = *ensureReplacementFragment();
 987     if (performTrivialReplace(fragment))
 988         return;
 989 
 990     // We can skip matching the style if the selection is plain text.
 991     if ((selection.start().deprecatedNode()-&gt;renderer() &amp;&amp; selection.start().deprecatedNode()-&gt;renderer()-&gt;style().userModify() == UserModify::ReadWritePlaintextOnly)
 992         &amp;&amp; (selection.end().deprecatedNode()-&gt;renderer() &amp;&amp; selection.end().deprecatedNode()-&gt;renderer()-&gt;style().userModify() == UserModify::ReadWritePlaintextOnly))
 993         m_matchStyle = false;
 994 
 995     if (m_matchStyle) {
 996         m_insertionStyle = EditingStyle::create(selection.start());
 997         m_insertionStyle-&gt;mergeTypingStyle(document());
 998     }
 999 
1000     VisiblePosition visibleStart = selection.visibleStart();
1001     VisiblePosition visibleEnd = selection.visibleEnd();
1002 
1003     bool selectionEndWasEndOfParagraph = isEndOfParagraph(visibleEnd);
1004     bool selectionStartWasStartOfParagraph = isStartOfParagraph(visibleStart);
1005 
1006     Node* startBlock = enclosingBlock(visibleStart.deepEquivalent().deprecatedNode());
1007 
1008     Position insertionPos = selection.start();
1009     bool shouldHandleMailBlockquote = enclosingNodeOfType(insertionPos, isMailBlockquote, CanCrossEditingBoundary) &amp;&amp; !m_ignoreMailBlockquote;
1010     bool selectionIsPlainText = !selection.isContentRichlyEditable();
1011     Element* currentRoot = selection.rootEditableElement();
1012 
1013     if ((selectionStartWasStartOfParagraph &amp;&amp; selectionEndWasEndOfParagraph &amp;&amp; !shouldHandleMailBlockquote)
1014         || startBlock == currentRoot || isListItem(startBlock) || selectionIsPlainText)
1015         m_preventNesting = false;
1016 
1017     if (selection.isRange()) {
1018         // When the end of the selection being pasted into is at the end of a paragraph, and that selection
1019         // spans multiple blocks, not merging may leave an empty line.
1020         // When the start of the selection being pasted into is at the start of a block, not merging
1021         // will leave hanging block(s).
1022         // Merge blocks if the start of the selection was in a Mail blockquote, since we handle
1023         // that case specially to prevent nesting.
1024         bool mergeBlocksAfterDelete = shouldHandleMailBlockquote || isEndOfParagraph(visibleEnd) || isStartOfBlock(visibleStart);
1025         // FIXME: We should only expand to include fully selected special elements if we are copying a
1026         // selection and pasting it on top of itself.
1027         // FIXME: capturing the content of this delete would allow a replace accessibility notification instead of a simple insert
1028         deleteSelection(false, mergeBlocksAfterDelete, true, false, true);
1029         visibleStart = endingSelection().visibleStart();
1030         if (fragment.hasInterchangeNewlineAtStart()) {
1031             if (isEndOfParagraph(visibleStart) &amp;&amp; !isStartOfParagraph(visibleStart)) {
1032                 if (!isEndOfEditableOrNonEditableContent(visibleStart))
1033                     setEndingSelection(visibleStart.next());
1034             } else
1035                 insertParagraphSeparator();
1036         }
1037         insertionPos = endingSelection().start();
1038     } else {
1039         ASSERT(selection.isCaret());
1040         if (fragment.hasInterchangeNewlineAtStart()) {
1041             VisiblePosition next = visibleStart.next(CannotCrossEditingBoundary);
1042             if (isEndOfParagraph(visibleStart) &amp;&amp; !isStartOfParagraph(visibleStart) &amp;&amp; next.isNotNull())
1043                 setEndingSelection(next);
1044             else  {
1045                 insertParagraphSeparator();
1046                 visibleStart = endingSelection().visibleStart();
1047             }
1048         }
1049         // We split the current paragraph in two to avoid nesting the blocks from the fragment inside the current block.
1050         // For example paste &lt;div&gt;foo&lt;/div&gt;&lt;div&gt;bar&lt;/div&gt;&lt;div&gt;baz&lt;/div&gt; into &lt;div&gt;x^x&lt;/div&gt;, where ^ is the caret.
1051         // As long as the  div styles are the same, visually you&#39;d expect: &lt;div&gt;xbar&lt;/div&gt;&lt;div&gt;bar&lt;/div&gt;&lt;div&gt;bazx&lt;/div&gt;,
1052         // not &lt;div&gt;xbar&lt;div&gt;bar&lt;/div&gt;&lt;div&gt;bazx&lt;/div&gt;&lt;/div&gt;.
1053         // Don&#39;t do this if the selection started in a Mail blockquote.
1054         if (m_preventNesting &amp;&amp; !shouldHandleMailBlockquote &amp;&amp; !isEndOfParagraph(visibleStart) &amp;&amp; !isStartOfParagraph(visibleStart)) {
1055             insertParagraphSeparator();
1056             setEndingSelection(endingSelection().visibleStart().previous());
1057         }
1058         insertionPos = endingSelection().start();
1059     }
1060 
1061     // We don&#39;t want any of the pasted content to end up nested in a Mail blockquote, so first break
1062     // out of any surrounding Mail blockquotes. Unless we&#39;re inserting in a table, in which case
1063     // breaking the blockquote will prevent the content from actually being inserted in the table.
1064     if (shouldHandleMailBlockquote &amp;&amp; m_preventNesting &amp;&amp; !(enclosingNodeOfType(insertionPos, &amp;isTableStructureNode))) {
1065         applyCommandToComposite(BreakBlockquoteCommand::create(document()));
1066         // This will leave a br between the split.
1067         Node* br = endingSelection().start().deprecatedNode();
1068         ASSERT(br-&gt;hasTagName(brTag));
1069         // Insert content between the two blockquotes, but remove the br (since it was just a placeholder).
1070         insertionPos = positionInParentBeforeNode(br);
1071         removeNode(*br);
1072     }
1073 
1074     // Inserting content could cause whitespace to collapse, e.g. inserting &lt;div&gt;foo&lt;/div&gt; into hello^ world.
1075     prepareWhitespaceAtPositionForSplit(insertionPos);
1076 
1077     // If the downstream node has been removed there&#39;s no point in continuing.
1078     if (!insertionPos.downstream().deprecatedNode())
1079       return;
1080 
1081     // NOTE: This would be an incorrect usage of downstream() if downstream() were changed to mean the last position after
1082     // p that maps to the same visible position as p (since in the case where a br is at the end of a block and collapsed
1083     // away, there are positions after the br which map to the same visible position as [br, 0]).
1084     RefPtr&lt;Node&gt; endBR = insertionPos.downstream().deprecatedNode()-&gt;hasTagName(brTag) ? insertionPos.downstream().deprecatedNode() : nullptr;
1085     VisiblePosition originalVisPosBeforeEndBR;
1086     if (endBR)
1087         originalVisPosBeforeEndBR = VisiblePosition(positionBeforeNode(endBR.get()), DOWNSTREAM).previous();
1088 
1089     RefPtr&lt;Node&gt; insertionBlock = enclosingBlock(insertionPos.deprecatedNode());
1090 
1091     // Adjust insertionPos to prevent nesting.
1092     // If the start was in a Mail blockquote, we will have already handled adjusting insertionPos above.
1093     if (m_preventNesting &amp;&amp; insertionBlock &amp;&amp; !isTableCell(insertionBlock.get()) &amp;&amp; !shouldHandleMailBlockquote) {
1094         ASSERT(insertionBlock != currentRoot);
1095         VisiblePosition visibleInsertionPos(insertionPos);
1096         if (isEndOfBlock(visibleInsertionPos) &amp;&amp; !(isStartOfBlock(visibleInsertionPos) &amp;&amp; fragment.hasInterchangeNewlineAtEnd()))
1097             insertionPos = positionInParentAfterNode(insertionBlock.get());
1098         else if (isStartOfBlock(visibleInsertionPos))
1099             insertionPos = positionInParentBeforeNode(insertionBlock.get());
1100     }
1101 
1102     // Paste at start or end of link goes outside of link.
1103     insertionPos = positionAvoidingSpecialElementBoundary(insertionPos);
1104 
1105     // FIXME: Can this wait until after the operation has been performed?  There doesn&#39;t seem to be
1106     // any work performed after this that queries or uses the typing style.
1107     frame().selection().clearTypingStyle();
1108 
1109     // We don&#39;t want the destination to end up inside nodes that weren&#39;t selected.  To avoid that, we move the
1110     // position forward without changing the visible position so we&#39;re still at the same visible location, but
1111     // outside of preceding tags.
1112     insertionPos = positionAvoidingPrecedingNodes(insertionPos);
1113 
1114     // Paste into run of tabs splits the tab span.
1115     insertionPos = positionOutsideTabSpan(insertionPos);
1116 
1117     bool hasBlankLinesBetweenParagraphs = hasBlankLineBetweenParagraphs(insertionPos);
1118 
1119     bool handledStyleSpans = handleStyleSpansBeforeInsertion(fragment, insertionPos);
1120 
1121     // We&#39;re finished if there is nothing to add.
1122     if (fragment.isEmpty() || !fragment.firstChild())
1123         return;
1124 
1125     // If we are not trying to match the destination style we prefer a position
1126     // that is outside inline elements that provide style.
1127     // This way we can produce a less verbose markup.
1128     // We can skip this optimization for fragments not wrapped in one of
1129     // our style spans and for positions inside list items
1130     // since insertAsListItems already does the right thing.
1131     if (!m_matchStyle &amp;&amp; !enclosingList(insertionPos.containerNode())) {
1132         if (insertionPos.containerNode()-&gt;isTextNode() &amp;&amp; insertionPos.offsetInContainerNode() &amp;&amp; !insertionPos.atLastEditingPositionForNode()) {
1133             splitTextNode(*insertionPos.containerText(), insertionPos.offsetInContainerNode());
1134             insertionPos = firstPositionInNode(insertionPos.containerNode());
1135         }
1136 
1137         if (RefPtr&lt;Node&gt; nodeToSplitTo = nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(insertionPos)) {
1138             if (insertionPos.containerNode() != nodeToSplitTo-&gt;parentNode()) {
1139                 Node* splitStart = insertionPos.computeNodeAfterPosition();
1140                 if (!splitStart)
1141                     splitStart = insertionPos.containerNode();
1142                 ASSERT(splitStart);
1143                 nodeToSplitTo = splitTreeToNode(*splitStart, *nodeToSplitTo-&gt;parentNode()).get();
1144                 insertionPos = positionInParentBeforeNode(nodeToSplitTo.get());
1145             }
1146         }
1147     }
1148 
1149     // FIXME: When pasting rich content we&#39;re often prevented from heading down the fast path by style spans.  Try
1150     // again here if they&#39;ve been removed.
1151 
1152     // 1) Insert the content.
1153     // 2) Remove redundant styles and style tags, this inner &lt;b&gt; for example: &lt;b&gt;foo &lt;b&gt;bar&lt;/b&gt; baz&lt;/b&gt;.
1154     // 3) Merge the start of the added content with the content before the position being pasted into.
1155     // 4) Do one of the following: a) expand the last br if the fragment ends with one and it collapsed,
1156     // b) merge the last paragraph of the incoming fragment with the paragraph that contained the
1157     // end of the selection that was pasted into, or c) handle an interchange newline at the end of the
1158     // incoming fragment.
1159     // 5) Add spaces for smart replace.
1160     // 6) Select the replacement if requested, and match style if requested.
1161 
1162     InsertedNodes insertedNodes;
1163     RefPtr&lt;Node&gt; refNode = fragment.firstChild();
1164     RefPtr&lt;Node&gt; node = refNode-&gt;nextSibling();
1165 
1166     if (refNode)
1167         fragment.removeNode(*refNode);
1168 
1169     Node* blockStart = enclosingBlock(insertionPos.deprecatedNode());
1170     bool isInsertingIntoList = (isListHTMLElement(refNode.get()) || (isLegacyAppleStyleSpan(refNode.get()) &amp;&amp; isListHTMLElement(refNode-&gt;firstChild())))
1171     &amp;&amp; blockStart &amp;&amp; blockStart-&gt;renderer()-&gt;isListItem();
1172     if (isInsertingIntoList)
1173         refNode = insertAsListItems(downcast&lt;HTMLElement&gt;(*refNode), blockStart, insertionPos, insertedNodes);
1174     else {
1175         insertNodeAt(*refNode, insertionPos);
1176         insertedNodes.respondToNodeInsertion(refNode.get());
1177     }
1178 
1179     // Mutation events (bug 22634) may have already removed the inserted content
1180     if (!refNode-&gt;isConnected())
1181         return;
1182 
1183     bool plainTextFragment = isPlainTextMarkup(refNode.get());
1184 
1185     while (node) {
1186         RefPtr&lt;Node&gt; next = node-&gt;nextSibling();
1187         fragment.removeNode(*node);
1188         insertNodeAfter(*node, *refNode);
1189         insertedNodes.respondToNodeInsertion(node.get());
1190 
1191         // Mutation events (bug 22634) may have already removed the inserted content
1192         if (!node-&gt;isConnected())
1193             return;
1194 
1195         refNode = node;
1196         if (node &amp;&amp; plainTextFragment)
1197             plainTextFragment = isPlainTextMarkup(node.get());
1198         node = next;
1199     }
1200 
1201     if (insertedNodes.isEmpty())
1202         return;
1203     removeUnrenderedTextNodesAtEnds(insertedNodes);
1204 
1205     if (!handledStyleSpans)
1206         handleStyleSpans(insertedNodes);
1207 
1208     // Mutation events (bug 20161) may have already removed the inserted content
1209     if (insertedNodes.isEmpty())
1210         return;
1211     if (!insertedNodes.firstNodeInserted()-&gt;isConnected())
1212         return;
1213 
1214     VisiblePosition startOfInsertedContent = firstPositionInOrBeforeNode(insertedNodes.firstNodeInserted());
1215 
1216     // We inserted before the insertionBlock to prevent nesting, and the content before the insertionBlock wasn&#39;t in its own block and
1217     // didn&#39;t have a br after it, so the inserted content ended up in the same paragraph.
1218     if (!startOfInsertedContent.isNull() &amp;&amp; insertionBlock &amp;&amp; insertionPos.deprecatedNode() == insertionBlock-&gt;parentNode() &amp;&amp; (unsigned)insertionPos.deprecatedEditingOffset() &lt; insertionBlock-&gt;computeNodeIndex() &amp;&amp; !isStartOfParagraph(startOfInsertedContent))
1219         insertNodeAt(HTMLBRElement::create(document()), startOfInsertedContent.deepEquivalent());
1220 
1221     if (endBR &amp;&amp; (plainTextFragment || shouldRemoveEndBR(endBR.get(), originalVisPosBeforeEndBR))) {
1222         RefPtr&lt;Node&gt; parent = endBR-&gt;parentNode();
1223         insertedNodes.willRemoveNode(endBR.get());
1224         removeNode(*endBR);
1225         if (Node* nodeToRemove = highestNodeToRemoveInPruning(parent.get())) {
1226             insertedNodes.willRemoveNode(nodeToRemove);
1227             removeNode(*nodeToRemove);
1228         }
1229     }
1230 
1231     makeInsertedContentRoundTrippableWithHTMLTreeBuilder(insertedNodes);
1232     if (insertedNodes.isEmpty())
1233         return;
1234 
1235     removeRedundantStylesAndKeepStyleSpanInline(insertedNodes);
1236     if (insertedNodes.isEmpty())
1237         return;
1238 
1239     if (m_sanitizeFragment)
1240         applyCommandToComposite(SimplifyMarkupCommand::create(document(), insertedNodes.firstNodeInserted(), insertedNodes.pastLastLeaf()));
1241 
1242     // Setup m_startOfInsertedContent and m_endOfInsertedContent. This should be the last two lines of code that access insertedNodes.
1243     m_startOfInsertedContent = firstPositionInOrBeforeNode(insertedNodes.firstNodeInserted());
1244     m_endOfInsertedContent = lastPositionInOrAfterNode(insertedNodes.lastLeafInserted());
1245 
1246     // Determine whether or not we should merge the end of inserted content with what&#39;s after it before we do
1247     // the start merge so that the start merge doesn&#39;t effect our decision.
1248     m_shouldMergeEnd = shouldMergeEnd(selectionEndWasEndOfParagraph);
1249 
1250     if (shouldMergeStart(selectionStartWasStartOfParagraph, fragment.hasInterchangeNewlineAtStart(), shouldHandleMailBlockquote)) {
1251         VisiblePosition startOfParagraphToMove = positionAtStartOfInsertedContent();
1252         VisiblePosition destination = startOfParagraphToMove.previous();
1253         // We need to handle the case where we need to merge the end
1254         // but our destination node is inside an inline that is the last in the block.
1255         // We insert a placeholder before the newly inserted content to avoid being merged into the inline.
1256         Node* destinationNode = destination.deepEquivalent().deprecatedNode();
1257         if (m_shouldMergeEnd &amp;&amp; destinationNode != enclosingInline(destinationNode) &amp;&amp; enclosingInline(destinationNode)-&gt;nextSibling())
1258             insertNodeBefore(HTMLBRElement::create(document()), *refNode);
1259 
1260         // Merging the first paragraph of inserted content with the content that came
1261         // before the selection that was pasted into would also move content after
1262         // the selection that was pasted into if: only one paragraph was being pasted,
1263         // and it was not wrapped in a block, the selection that was pasted into ended
1264         // at the end of a block and the next paragraph didn&#39;t start at the start of a block.
1265         // Insert a line break just after the inserted content to separate it from what
1266         // comes after and prevent that from happening.
1267         VisiblePosition endOfInsertedContent = positionAtEndOfInsertedContent();
1268         if (startOfParagraph(endOfInsertedContent) == startOfParagraphToMove) {
1269             insertNodeAt(HTMLBRElement::create(document()), endOfInsertedContent.deepEquivalent());
1270             // Mutation events (bug 22634) triggered by inserting the &lt;br&gt; might have removed the content we&#39;re about to move
1271             if (!startOfParagraphToMove.deepEquivalent().anchorNode()-&gt;isConnected())
1272                 return;
1273         }
1274 
1275         // FIXME: Maintain positions for the start and end of inserted content instead of keeping nodes.  The nodes are
1276         // only ever used to create positions where inserted content starts/ends.
1277         moveParagraph(startOfParagraphToMove, endOfParagraph(startOfParagraphToMove), destination);
1278         m_startOfInsertedContent = endingSelection().visibleStart().deepEquivalent().downstream();
1279         if (m_endOfInsertedContent.isOrphan())
1280             m_endOfInsertedContent = endingSelection().visibleEnd().deepEquivalent().upstream();
1281     }
1282 
1283     Position lastPositionToSelect;
1284     if (fragment.hasInterchangeNewlineAtEnd()) {
1285         VisiblePosition endOfInsertedContent = positionAtEndOfInsertedContent();
1286         VisiblePosition next = endOfInsertedContent.next(CannotCrossEditingBoundary);
1287 
1288         if (selectionEndWasEndOfParagraph || !isEndOfParagraph(endOfInsertedContent) || next.isNull()) {
1289             if (!isStartOfParagraph(endOfInsertedContent)) {
1290                 setEndingSelection(endOfInsertedContent);
1291                 Node* enclosingNode = enclosingBlock(endOfInsertedContent.deepEquivalent().deprecatedNode());
1292                 if (isListItem(enclosingNode)) {
1293                     auto newListItem = HTMLLIElement::create(document());
1294                     insertNodeAfter(newListItem.copyRef(), *enclosingNode);
1295                     setEndingSelection(VisiblePosition(firstPositionInNode(newListItem.ptr())));
1296                 } else {
1297                     // Use a default paragraph element (a plain div) for the empty paragraph, using the last paragraph
1298                     // block&#39;s style seems to annoy users.
1299                     insertParagraphSeparator(true, !shouldHandleMailBlockquote &amp;&amp; highestEnclosingNodeOfType(endOfInsertedContent.deepEquivalent(),
1300                         isMailBlockquote, CannotCrossEditingBoundary, insertedNodes.firstNodeInserted()-&gt;parentNode()));
1301                 }
1302 
1303                 // Select up to the paragraph separator that was added.
1304                 lastPositionToSelect = endingSelection().visibleStart().deepEquivalent();
1305                 updateNodesInserted(lastPositionToSelect.deprecatedNode());
1306             }
1307         } else {
1308             // Select up to the beginning of the next paragraph.
1309             lastPositionToSelect = next.deepEquivalent().downstream();
1310         }
1311 
1312     } else
1313         mergeEndIfNeeded();
1314 
1315     if (Node* mailBlockquote = enclosingNodeOfType(positionAtStartOfInsertedContent().deepEquivalent(), isMailPasteAsQuotationNode))
1316         removeNodeAttribute(downcast&lt;Element&gt;(*mailBlockquote), classAttr);
1317 
1318     if (shouldPerformSmartReplace())
1319         addSpacesForSmartReplace();
1320 
1321     if (!isInsertingIntoList &amp;&amp; hasBlankLinesBetweenParagraphs &amp;&amp; shouldPerformSmartParagraphReplace())
1322         addNewLinesForSmartReplace();
1323 
1324     // If we are dealing with a fragment created from plain text
1325     // no style matching is necessary.
1326     if (plainTextFragment)
1327         m_matchStyle = false;
1328 
1329     completeHTMLReplacement(lastPositionToSelect);
1330 }
1331 
1332 String ReplaceSelectionCommand::inputEventData() const
1333 {
1334     if (isEditingTextAreaOrTextInput())
1335         return m_documentFragment-&gt;textContent();
1336 
1337     return CompositeEditCommand::inputEventData();
1338 }
1339 
1340 RefPtr&lt;DataTransfer&gt; ReplaceSelectionCommand::inputEventDataTransfer() const
1341 {
1342     if (isEditingTextAreaOrTextInput())
1343         return CompositeEditCommand::inputEventDataTransfer();
1344 
1345     return DataTransfer::createForInputEvent(document(), m_documentFragmentPlainText, m_documentFragmentHTMLMarkup);
1346 }
1347 
1348 bool ReplaceSelectionCommand::shouldRemoveEndBR(Node* endBR, const VisiblePosition&amp; originalVisPosBeforeEndBR)
1349 {
1350     if (!endBR || !endBR-&gt;isConnected())
1351         return false;
1352 
1353     VisiblePosition visiblePos(positionBeforeNode(endBR));
1354 
1355     // Don&#39;t remove the br if nothing was inserted.
1356     if (visiblePos.previous() == originalVisPosBeforeEndBR)
1357         return false;
1358 
1359     // Remove the br if it is collapsed away and so is unnecessary.
1360     if (!document().inNoQuirksMode() &amp;&amp; isEndOfBlock(visiblePos) &amp;&amp; !isStartOfParagraph(visiblePos))
1361         return true;
1362 
1363     // A br that was originally holding a line open should be displaced by inserted content or turned into a line break.
1364     // A br that was originally acting as a line break should still be acting as a line break, not as a placeholder.
1365     return isStartOfParagraph(visiblePos) &amp;&amp; isEndOfParagraph(visiblePos);
1366 }
1367 
1368 bool ReplaceSelectionCommand::shouldPerformSmartReplace() const
1369 {
1370     if (!m_smartReplace)
1371         return false;
1372 
1373     Element* textControl = enclosingTextFormControl(positionAtStartOfInsertedContent().deepEquivalent());
1374     if (is&lt;HTMLInputElement&gt;(textControl) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*textControl).isPasswordField())
1375         return false; // Disable smart replace for password fields.
1376 
1377     return true;
1378 }
1379 
1380 bool ReplaceSelectionCommand::shouldPerformSmartParagraphReplace() const
1381 {
1382     if (!m_smartReplace)
1383         return false;
1384 
1385     if (!document().editingBehavior().shouldSmartInsertDeleteParagraphs())
1386         return false;
1387 
1388     return true;
1389 }
1390 
1391 static bool isCharacterSmartReplaceExemptConsideringNonBreakingSpace(UChar32 character, bool previousCharacter)
1392 {
1393     return isCharacterSmartReplaceExempt(character == noBreakSpace ? &#39; &#39; : character, previousCharacter);
1394 }
1395 
1396 void ReplaceSelectionCommand::addNewLinesForSmartReplace()
1397 {
1398     VisiblePosition startOfInsertedContent = positionAtStartOfInsertedContent();
1399     VisiblePosition endOfInsertedContent = positionAtEndOfInsertedContent();
1400 
1401     bool isPastedContentEntireParagraphs = isStartOfParagraph(startOfInsertedContent) &amp;&amp; isEndOfParagraph(endOfInsertedContent);
1402 
1403     // If we aren&#39;t pasting a paragraph, no need to attempt to insert newlines.
1404     if (!isPastedContentEntireParagraphs)
1405         return;
1406 
1407     bool reachedBoundaryStart = false;
1408     bool reachedBoundaryEnd = false;
1409     VisiblePosition positionBeforeStart = startOfInsertedContent.previous(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);
1410     VisiblePosition positionAfterEnd = endOfInsertedContent.next(CannotCrossEditingBoundary, &amp;reachedBoundaryEnd);
1411 
1412     if (!reachedBoundaryStart &amp;&amp; !reachedBoundaryEnd) {
1413         if (!isBlankParagraph(positionBeforeStart) &amp;&amp; !isBlankParagraph(startOfInsertedContent) &amp;&amp; isEndOfLine(positionBeforeStart) &amp;&amp; !isEndOfEditableOrNonEditableContent(positionAfterEnd) &amp;&amp; !isEndOfEditableOrNonEditableContent(endOfInsertedContent)) {
1414             setEndingSelection(startOfInsertedContent);
1415             insertParagraphSeparator();
1416             auto newStart = endingSelection().visibleStart().previous(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);
1417             if (!reachedBoundaryStart)
1418                 m_startOfInsertedContent = newStart.deepEquivalent();
1419         }
1420     }
1421 
1422     reachedBoundaryStart = false;
1423     reachedBoundaryEnd = false;
1424     positionAfterEnd = endOfInsertedContent.next(CannotCrossEditingBoundary, &amp;reachedBoundaryEnd);
1425     positionBeforeStart = startOfInsertedContent.previous(CannotCrossEditingBoundary, &amp;reachedBoundaryStart);
1426 
1427     if (!reachedBoundaryEnd &amp;&amp; !reachedBoundaryStart) {
1428         if (!isBlankParagraph(positionAfterEnd) &amp;&amp; !isBlankParagraph(endOfInsertedContent) &amp;&amp; isStartOfLine(positionAfterEnd) &amp;&amp; !isEndOfLine(positionAfterEnd) &amp;&amp; !isEndOfEditableOrNonEditableContent(positionAfterEnd)) {
1429             setEndingSelection(endOfInsertedContent);
1430             insertParagraphSeparator();
1431             m_endOfInsertedContent = endingSelection().start();
1432         }
1433     }
1434 }
1435 
1436 void ReplaceSelectionCommand::addSpacesForSmartReplace()
1437 {
1438     VisiblePosition startOfInsertedContent = positionAtStartOfInsertedContent();
1439     VisiblePosition endOfInsertedContent = positionAtEndOfInsertedContent();
1440 
1441     Position endUpstream = endOfInsertedContent.deepEquivalent().upstream();
1442     Node* endNode = endUpstream.computeNodeBeforePosition();
1443     int endOffset = is&lt;Text&gt;(endNode) ? downcast&lt;Text&gt;(*endNode).length() : 0;
1444     if (endUpstream.anchorType() == Position::PositionIsOffsetInAnchor) {
1445         endNode = endUpstream.containerNode();
1446         endOffset = endUpstream.offsetInContainerNode();
1447     }
1448 
1449     bool needsTrailingSpace = !isEndOfParagraph(endOfInsertedContent) &amp;&amp; !isStartOfParagraph(endOfInsertedContent) &amp;&amp; !isCharacterSmartReplaceExemptConsideringNonBreakingSpace(endOfInsertedContent.characterAfter(), false);
1450     if (needsTrailingSpace &amp;&amp; endNode) {
1451         bool collapseWhiteSpace = !endNode-&gt;renderer() || endNode-&gt;renderer()-&gt;style().collapseWhiteSpace();
1452         if (is&lt;Text&gt;(*endNode)) {
1453             insertTextIntoNode(downcast&lt;Text&gt;(*endNode), endOffset, collapseWhiteSpace ? nonBreakingSpaceString() : &quot; &quot;);
1454             if (m_endOfInsertedContent.containerNode() == endNode)
1455                 m_endOfInsertedContent.moveToOffset(m_endOfInsertedContent.offsetInContainerNode() + 1);
1456         } else {
1457             auto node = document().createEditingTextNode(collapseWhiteSpace ? nonBreakingSpaceString() : &quot; &quot;);
1458             insertNodeAfter(node.copyRef(), *endNode);
1459             updateNodesInserted(node.ptr());
1460         }
1461     }
1462 
1463     document().updateLayout();
1464 
1465     Position startDownstream = startOfInsertedContent.deepEquivalent().downstream();
1466     Node* startNode = startDownstream.computeNodeAfterPosition();
1467     unsigned startOffset = 0;
1468     if (startDownstream.anchorType() == Position::PositionIsOffsetInAnchor) {
1469         startNode = startDownstream.containerNode();
1470         startOffset = startDownstream.offsetInContainerNode();
1471     }
1472 
1473     bool needsLeadingSpace = !isStartOfParagraph(startOfInsertedContent) &amp;&amp; !isEndOfParagraph(startOfInsertedContent) &amp;&amp; !isCharacterSmartReplaceExemptConsideringNonBreakingSpace(startOfInsertedContent.previous().characterAfter(), true);
1474     if (needsLeadingSpace &amp;&amp; startNode) {
1475         bool collapseWhiteSpace = !startNode-&gt;renderer() || startNode-&gt;renderer()-&gt;style().collapseWhiteSpace();
1476         if (is&lt;Text&gt;(*startNode)) {
1477             insertTextIntoNode(downcast&lt;Text&gt;(*startNode), startOffset, collapseWhiteSpace ? nonBreakingSpaceString() : &quot; &quot;);
1478             if (m_endOfInsertedContent.containerNode() == startNode &amp;&amp; m_endOfInsertedContent.offsetInContainerNode())
1479                 m_endOfInsertedContent.moveToOffset(m_endOfInsertedContent.offsetInContainerNode() + 1);
1480         } else {
1481             auto node = document().createEditingTextNode(collapseWhiteSpace ? nonBreakingSpaceString() : &quot; &quot;);
1482             auto* nodePtr = node.ptr();
1483             // Don&#39;t updateNodesInserted. Doing so would set m_endOfInsertedContent to be the node containing the leading space,
1484             // but m_endOfInsertedContent is supposed to mark the end of pasted content.
1485             insertNodeBefore(WTFMove(node), *startNode);
1486             m_startOfInsertedContent = firstPositionInNode(nodePtr);
1487         }
1488     }
1489 }
1490 
1491 void ReplaceSelectionCommand::completeHTMLReplacement(const Position &amp;lastPositionToSelect)
1492 {
1493     Position start = positionAtStartOfInsertedContent().deepEquivalent();
1494     Position end = positionAtEndOfInsertedContent().deepEquivalent();
1495 
1496     // Mutation events may have deleted start or end
1497     if (start.isNotNull() &amp;&amp; !start.isOrphan() &amp;&amp; end.isNotNull() &amp;&amp; !end.isOrphan()) {
1498         // FIXME (11475): Remove this and require that the creator of the fragment to use nbsps.
1499         rebalanceWhitespaceAt(start);
1500         rebalanceWhitespaceAt(end);
1501 
1502         if (m_matchStyle) {
1503             ASSERT(m_insertionStyle);
1504             applyStyle(m_insertionStyle.get(), start, end);
1505         }
1506 
1507         if (lastPositionToSelect.isNotNull())
1508             end = lastPositionToSelect;
1509 
1510         mergeTextNodesAroundPosition(start, end);
1511         mergeTextNodesAroundPosition(end, start);
1512     } else if (lastPositionToSelect.isNotNull())
1513         start = end = lastPositionToSelect;
1514     else
1515         return;
1516 
1517     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction() == EditAction::Paste)
1518         m_visibleSelectionForInsertedText = VisibleSelection(start, end);
1519 
1520     if (m_selectReplacement)
1521         setEndingSelection(VisibleSelection(start, end, SEL_DEFAULT_AFFINITY, endingSelection().isDirectional()));
1522     else
1523         setEndingSelection(VisibleSelection(end, SEL_DEFAULT_AFFINITY, endingSelection().isDirectional()));
1524 }
1525 
1526 void ReplaceSelectionCommand::mergeTextNodesAroundPosition(Position&amp; position, Position&amp; positionOnlyToBeUpdated)
1527 {
1528     bool positionIsOffsetInAnchor = position.anchorType() == Position::PositionIsOffsetInAnchor;
1529     bool positionOnlyToBeUpdatedIsOffsetInAnchor = positionOnlyToBeUpdated.anchorType() == Position::PositionIsOffsetInAnchor;
1530     RefPtr&lt;Text&gt; text;
1531     if (positionIsOffsetInAnchor &amp;&amp; is&lt;Text&gt;(position.containerNode()))
1532         text = downcast&lt;Text&gt;(position.containerNode());
1533     else {
1534         Node* before = position.computeNodeBeforePosition();
1535         if (is&lt;Text&gt;(before))
1536             text = downcast&lt;Text&gt;(before);
1537         else {
1538             Node* after = position.computeNodeAfterPosition();
1539             if (is&lt;Text&gt;(after))
1540                 text = downcast&lt;Text&gt;(after);
1541         }
1542     }
1543     if (!text)
1544         return;
1545 
1546     if (is&lt;Text&gt;(text-&gt;previousSibling())) {
1547         Ref&lt;Text&gt; previous(downcast&lt;Text&gt;(*text-&gt;previousSibling()));
1548         insertTextIntoNode(*text, 0, previous-&gt;data());
1549 
1550         if (positionIsOffsetInAnchor)
1551             position.moveToOffset(previous-&gt;length() + position.offsetInContainerNode());
1552         else
1553             updatePositionForNodeRemoval(position, previous.get());
1554 
1555         if (positionOnlyToBeUpdatedIsOffsetInAnchor) {
1556             if (positionOnlyToBeUpdated.containerNode() == text)
1557                 positionOnlyToBeUpdated.moveToOffset(previous-&gt;length() + positionOnlyToBeUpdated.offsetInContainerNode());
1558             else if (positionOnlyToBeUpdated.containerNode() == previous.ptr())
1559                 positionOnlyToBeUpdated.moveToPosition(text.get(), positionOnlyToBeUpdated.offsetInContainerNode());
1560         } else
1561             updatePositionForNodeRemoval(positionOnlyToBeUpdated, previous.get());
1562 
1563         removeNode(previous);
1564     }
1565     if (is&lt;Text&gt;(text-&gt;nextSibling())) {
1566         Ref&lt;Text&gt; next(downcast&lt;Text&gt;(*text-&gt;nextSibling()));
1567         unsigned originalLength = text-&gt;length();
1568         insertTextIntoNode(*text, originalLength, next-&gt;data());
1569 
1570         if (!positionIsOffsetInAnchor)
1571             updatePositionForNodeRemoval(position, next.get());
1572 
1573         if (positionOnlyToBeUpdatedIsOffsetInAnchor &amp;&amp; positionOnlyToBeUpdated.containerNode() == next.ptr())
1574             positionOnlyToBeUpdated.moveToPosition(text.get(), originalLength + positionOnlyToBeUpdated.offsetInContainerNode());
1575         else
1576             updatePositionForNodeRemoval(positionOnlyToBeUpdated, next.get());
1577 
1578         removeNode(next);
1579     }
1580 }
1581 
1582 static HTMLElement* singleChildList(HTMLElement&amp; element)
1583 {
1584     if (!element.hasOneChild())
1585         return nullptr;
1586 
1587     auto&amp; child = *element.firstChild();
1588     return isListHTMLElement(&amp;child) ? &amp;downcast&lt;HTMLElement&gt;(child) : nullptr;
1589 }
1590 
1591 static HTMLElement&amp; deepestSingleChildList(HTMLElement&amp; topLevelList)
1592 {
1593     auto* list = &amp;topLevelList;
1594     while (auto* childList = singleChildList(*list))
1595         list = childList;
1596     return *list;
1597 }
1598 
1599 // If the user is inserting a list into an existing list, instead of nesting the list,
1600 // we put the list items into the existing list.
1601 Node* ReplaceSelectionCommand::insertAsListItems(HTMLElement&amp; passedListElement, Node* insertionBlock, const Position&amp; insertPos, InsertedNodes&amp; insertedNodes)
1602 {
1603     Ref&lt;HTMLElement&gt; listElement = deepestSingleChildList(passedListElement);
1604 
1605     bool isStart = isStartOfParagraph(insertPos);
1606     bool isEnd = isEndOfParagraph(insertPos);
1607     bool isMiddle = !isStart &amp;&amp; !isEnd;
1608     Node* lastNode = insertionBlock;
1609 
1610     // If we&#39;re in the middle of a list item, we should split it into two separate
1611     // list items and insert these nodes between them.
1612     if (isMiddle) {
1613         int textNodeOffset = insertPos.offsetInContainerNode();
1614         if (is&lt;Text&gt;(*insertPos.deprecatedNode()) &amp;&amp; textNodeOffset &gt; 0)
1615             splitTextNode(downcast&lt;Text&gt;(*insertPos.deprecatedNode()), textNodeOffset);
1616         splitTreeToNode(*insertPos.deprecatedNode(), *lastNode, true);
1617     }
1618 
1619     while (RefPtr&lt;Node&gt; listItem = listElement-&gt;firstChild()) {
1620         listElement-&gt;removeChild(*listItem);
1621         if (isStart || isMiddle) {
1622             insertNodeBefore(*listItem, *lastNode);
1623             insertedNodes.respondToNodeInsertion(listItem.get());
1624         } else if (isEnd) {
1625             insertNodeAfter(*listItem, *lastNode);
1626             insertedNodes.respondToNodeInsertion(listItem.get());
1627             lastNode = listItem.get();
1628         } else
1629             ASSERT_NOT_REACHED();
1630     }
1631     if ((isStart || isMiddle) &amp;&amp; lastNode-&gt;previousSibling())
1632         lastNode = lastNode-&gt;previousSibling();
1633     return lastNode;
1634 }
1635 
1636 void ReplaceSelectionCommand::updateNodesInserted(Node *node)
1637 {
1638     if (!node)
1639         return;
1640 
1641     if (m_startOfInsertedContent.isNull())
1642         m_startOfInsertedContent = firstPositionInOrBeforeNode(node);
1643 
1644     m_endOfInsertedContent = lastPositionInOrAfterNode(node-&gt;lastDescendant());
1645 }
1646 
1647 ReplacementFragment* ReplaceSelectionCommand::ensureReplacementFragment()
1648 {
1649     if (!m_replacementFragment)
1650         m_replacementFragment = makeUnique&lt;ReplacementFragment&gt;(m_documentFragment.get(), endingSelection());
1651     return m_replacementFragment.get();
1652 }
1653 
1654 // During simple pastes, where we&#39;re just pasting a text node into a run of text, we insert the text node
1655 // directly into the text node that holds the selection.  This is much faster than the generalized code in
1656 // ReplaceSelectionCommand, and works around &lt;https://bugs.webkit.org/show_bug.cgi?id=6148&gt; since we don&#39;t
1657 // split text nodes.
1658 bool ReplaceSelectionCommand::performTrivialReplace(const ReplacementFragment&amp; fragment)
1659 {
1660     if (!is&lt;Text&gt;(fragment.firstChild()) || fragment.firstChild() != fragment.lastChild())
1661         return false;
1662 
1663     // FIXME: Would be nice to handle smart replace in the fast path.
1664     if (m_smartReplace || fragment.hasInterchangeNewlineAtStart() || fragment.hasInterchangeNewlineAtEnd())
1665         return false;
1666 
1667     // e.g. when &quot;bar&quot; is inserted after &quot;foo&quot; in &lt;div&gt;&lt;u&gt;foo&lt;/u&gt;&lt;/div&gt;, &quot;bar&quot; should not be underlined.
1668     if (nodeToSplitToAvoidPastingIntoInlineNodesWithStyle(endingSelection().start()))
1669         return false;
1670 
1671     RefPtr&lt;Node&gt; nodeAfterInsertionPos = endingSelection().end().downstream().anchorNode();
1672     Text&amp; textNode = downcast&lt;Text&gt;(*fragment.firstChild());
1673     // Our fragment creation code handles tabs, spaces, and newlines, so we don&#39;t have to worry about those here.
1674 
1675     Position start = endingSelection().start();
1676     Position end = replaceSelectedTextInNode(textNode.data());
1677     if (end.isNull())
1678         return false;
1679 
1680     if (nodeAfterInsertionPos &amp;&amp; nodeAfterInsertionPos-&gt;parentNode() &amp;&amp; nodeAfterInsertionPos-&gt;hasTagName(brTag)
1681         &amp;&amp; shouldRemoveEndBR(nodeAfterInsertionPos.get(), positionBeforeNode(nodeAfterInsertionPos.get())))
1682         removeNodeAndPruneAncestors(*nodeAfterInsertionPos);
1683 
1684     VisibleSelection selectionAfterReplace(m_selectReplacement ? start : end, end);
1685 
1686     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction() == EditAction::Paste)
1687         m_visibleSelectionForInsertedText = VisibleSelection(start, end);
1688 
1689     setEndingSelection(selectionAfterReplace);
1690 
1691     return true;
1692 }
1693 
1694 } // namespace WebCore
    </pre>
  </body>
</html>