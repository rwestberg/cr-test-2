<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1998, 1999 Torben Weis &lt;weis@kde.org&gt;
   3  *                     1999 Lars Knoll &lt;knoll@kde.org&gt;
   4  *                     1999 Antti Koivisto &lt;koivisto@kde.org&gt;
   5  *                     2000 Dirk Mueller &lt;mueller@kde.org&gt;
   6  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   7  *           (C) 2006 Graham Dennis (graham.dennis@gmail.com)
   8  *           (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   9  * Copyright (C) 2009 Google Inc. All rights reserved.
  10  *
  11  * This library is free software; you can redistribute it and/or
  12  * modify it under the terms of the GNU Library General Public
  13  * License as published by the Free Software Foundation; either
  14  * version 2 of the License, or (at your option) any later version.
  15  *
  16  * This library is distributed in the hope that it will be useful,
  17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19  * Library General Public License for more details.
  20  *
  21  * You should have received a copy of the GNU Library General Public License
  22  * along with this library; see the file COPYING.LIB.  If not, write to
  23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24  * Boston, MA 02110-1301, USA.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;FrameView.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;BackForwardController.h&quot;
  32 #include &quot;CSSAnimationController.h&quot;
  33 #include &quot;CachedImage.h&quot;
  34 #include &quot;CachedResourceLoader.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;ChromeClient.h&quot;
<a name="1" id="anc1"></a>
  37 #include &quot;DOMWindow.h&quot;
  38 #include &quot;DebugPageOverlays.h&quot;
  39 #include &quot;DeprecatedGlobalSettings.h&quot;
  40 #include &quot;DocumentLoader.h&quot;
  41 #include &quot;DocumentMarkerController.h&quot;
  42 #include &quot;EventHandler.h&quot;
  43 #include &quot;EventNames.h&quot;
  44 #include &quot;FloatRect.h&quot;
  45 #include &quot;FocusController.h&quot;
  46 #include &quot;Frame.h&quot;
  47 #include &quot;FrameLoader.h&quot;
  48 #include &quot;FrameLoaderClient.h&quot;
  49 #include &quot;FrameSelection.h&quot;
  50 #include &quot;FrameTree.h&quot;
  51 #include &quot;GraphicsContext.h&quot;
  52 #include &quot;HTMLBodyElement.h&quot;
  53 #include &quot;HTMLEmbedElement.h&quot;
  54 #include &quot;HTMLFrameElement.h&quot;
  55 #include &quot;HTMLFrameSetElement.h&quot;
  56 #include &quot;HTMLHtmlElement.h&quot;
  57 #include &quot;HTMLIFrameElement.h&quot;
  58 #include &quot;HTMLNames.h&quot;
  59 #include &quot;HTMLObjectElement.h&quot;
  60 #include &quot;HTMLParserIdioms.h&quot;
  61 #include &quot;HTMLPlugInImageElement.h&quot;
  62 #include &quot;ImageDocument.h&quot;
  63 #include &quot;InspectorClient.h&quot;
  64 #include &quot;InspectorController.h&quot;
  65 #include &quot;InspectorInstrumentation.h&quot;
  66 #include &quot;Logging.h&quot;
  67 #include &quot;MemoryCache.h&quot;
  68 #include &quot;OverflowEvent.h&quot;
  69 #include &quot;Page.h&quot;
  70 #include &quot;PageCache.h&quot;
  71 #include &quot;PageOverlayController.h&quot;
  72 #include &quot;ProgressTracker.h&quot;
  73 #include &quot;RenderEmbeddedObject.h&quot;
  74 #include &quot;RenderFullScreen.h&quot;
  75 #include &quot;RenderIFrame.h&quot;
  76 #include &quot;RenderInline.h&quot;
  77 #include &quot;RenderLayer.h&quot;
  78 #include &quot;RenderLayerBacking.h&quot;
  79 #include &quot;RenderLayerCompositor.h&quot;
  80 #include &quot;RenderSVGRoot.h&quot;
  81 #include &quot;RenderScrollbar.h&quot;
  82 #include &quot;RenderScrollbarPart.h&quot;
  83 #include &quot;RenderStyle.h&quot;
  84 #include &quot;RenderText.h&quot;
  85 #include &quot;RenderTheme.h&quot;
  86 #include &quot;RenderView.h&quot;
  87 #include &quot;RenderWidget.h&quot;
<a name="2" id="anc2"></a>
  88 #include &quot;RuntimeEnabledFeatures.h&quot;
  89 #include &quot;SVGDocument.h&quot;
  90 #include &quot;SVGSVGElement.h&quot;
  91 #include &quot;ScriptRunner.h&quot;
  92 #include &quot;ScriptedAnimationController.h&quot;
  93 #include &quot;ScrollAnimator.h&quot;
  94 #include &quot;ScrollingCoordinator.h&quot;
  95 #include &quot;Settings.h&quot;
  96 #include &quot;StyleResolver.h&quot;
  97 #include &quot;StyleScope.h&quot;
  98 #include &quot;TextResourceDecoder.h&quot;
  99 #include &quot;TiledBacking.h&quot;
<a name="3" id="anc3"></a>
 100 #include &quot;VisualViewport.h&quot;
 101 #include &quot;WheelEventTestTrigger.h&quot;
 102 #include &lt;wtf/text/TextStream.h&gt;
 103 
 104 #include &lt;wtf/IsoMallocInlines.h&gt;
 105 #include &lt;wtf/MemoryPressureHandler.h&gt;
 106 #include &lt;wtf/Ref.h&gt;
 107 #include &lt;wtf/SetForScope.h&gt;
 108 #include &lt;wtf/SystemTracing.h&gt;
 109 
 110 #if USE(COORDINATED_GRAPHICS)
 111 #include &quot;TiledBackingStore.h&quot;
 112 #endif
 113 
 114 #if ENABLE(CSS_SCROLL_SNAP)
 115 #include &quot;AxisScrollSnapOffsets.h&quot;
 116 #endif
 117 
 118 #if PLATFORM(IOS_FAMILY)
 119 #include &quot;DocumentLoader.h&quot;
 120 #include &quot;LegacyTileCache.h&quot;
 121 #endif
 122 
 123 #if PLATFORM(MAC)
 124 #include &quot;LocalDefaultSystemAppearance.h&quot;
 125 #endif
 126 
 127 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(frame().page() &amp;&amp; frame().page()-&gt;isAlwaysOnLoggingAllowed(), Layout, &quot;%p - FrameView::&quot; fmt, this, ##__VA_ARGS__)
 128 
 129 namespace WebCore {
 130 
 131 using namespace HTMLNames;
 132 
 133 WTF_MAKE_ISO_ALLOCATED_IMPL(FrameView);
 134 
 135 MonotonicTime FrameView::sCurrentPaintTimeStamp { };
 136 
 137 // The maximum number of updateEmbeddedObjects iterations that should be done before returning.
 138 static const unsigned maxUpdateEmbeddedObjectsIterations = 2;
 139 
 140 static constexpr unsigned defaultSignificantRenderedTextCharacterThreshold = 3000;
 141 static constexpr float defaultSignificantRenderedTextMeanLength = 50;
 142 static constexpr unsigned mainArticleSignificantRenderedTextCharacterThreshold = 1500;
 143 static constexpr float mainArticleSignificantRenderedTextMeanLength = 25;
 144 
<a name="4" id="anc4"></a><span class="line-removed"> 145 static OptionSet&lt;RenderLayer::UpdateLayerPositionsFlag&gt; updateLayerPositionFlags(RenderLayer* layer, bool isRelayoutingSubtree, bool didFullRepaint)</span>
<span class="line-removed"> 146 {</span>
<span class="line-removed"> 147     auto flags = RenderLayer::updateLayerPositionsDefaultFlags();</span>
<span class="line-removed"> 148     if (didFullRepaint) {</span>
<span class="line-removed"> 149         flags.remove(RenderLayer::CheckForRepaint);</span>
<span class="line-removed"> 150         flags.add(RenderLayer::NeedsFullRepaintInBacking);</span>
<span class="line-removed"> 151     }</span>
<span class="line-removed"> 152     if (isRelayoutingSubtree &amp;&amp; layer-&gt;enclosingPaginationLayer(RenderLayer::IncludeCompositedPaginatedLayers))</span>
<span class="line-removed"> 153         flags.add(RenderLayer::UpdatePagination);</span>
<span class="line-removed"> 154     return flags;</span>
<span class="line-removed"> 155 }</span>
<span class="line-removed"> 156 </span>
 157 Pagination::Mode paginationModeForRenderStyle(const RenderStyle&amp; style)
 158 {
 159     Overflow overflow = style.overflowY();
 160     if (overflow != Overflow::PagedX &amp;&amp; overflow != Overflow::PagedY)
 161         return Pagination::Unpaginated;
 162 
 163     bool isHorizontalWritingMode = style.isHorizontalWritingMode();
 164     TextDirection textDirection = style.direction();
 165     WritingMode writingMode = style.writingMode();
 166 
 167     // paged-x always corresponds to LeftToRightPaginated or RightToLeftPaginated. If the WritingMode
 168     // is horizontal, then we use TextDirection to choose between those options. If the WritingMode
 169     // is vertical, then the direction of the verticality dictates the choice.
 170     if (overflow == Overflow::PagedX) {
 171         if ((isHorizontalWritingMode &amp;&amp; textDirection == TextDirection::LTR) || writingMode == LeftToRightWritingMode)
 172             return Pagination::LeftToRightPaginated;
 173         return Pagination::RightToLeftPaginated;
 174     }
 175 
 176     // paged-y always corresponds to TopToBottomPaginated or BottomToTopPaginated. If the WritingMode
 177     // is horizontal, then the direction of the horizontality dictates the choice. If the WritingMode
 178     // is vertical, then we use TextDirection to choose between those options.
 179     if (writingMode == TopToBottomWritingMode || (!isHorizontalWritingMode &amp;&amp; textDirection == TextDirection::RTL))
 180         return Pagination::TopToBottomPaginated;
 181     return Pagination::BottomToTopPaginated;
 182 }
 183 
 184 FrameView::FrameView(Frame&amp; frame)
 185     : m_frame(frame)
 186     , m_layoutContext(*this)
 187     , m_updateEmbeddedObjectsTimer(*this, &amp;FrameView::updateEmbeddedObjectsTimerFired)
 188     , m_updateWidgetPositionsTimer(*this, &amp;FrameView::updateWidgetPositionsTimerFired)
 189     , m_delayedScrollEventTimer(*this, &amp;FrameView::sendScrollEvent)
 190     , m_delayedScrollToFocusedElementTimer(*this, &amp;FrameView::scrollToFocusedElementTimerFired)
 191     , m_speculativeTilingEnableTimer(*this, &amp;FrameView::speculativeTilingEnableTimerFired)
 192 {
 193     init();
 194 
 195 #if ENABLE(RUBBER_BANDING)
 196     ScrollElasticity verticalElasticity = ScrollElasticityNone;
 197     ScrollElasticity horizontalElasticity = ScrollElasticityNone;
 198     if (m_frame-&gt;isMainFrame()) {
 199         verticalElasticity = m_frame-&gt;page() ? m_frame-&gt;page()-&gt;verticalScrollElasticity() : ScrollElasticityAllowed;
 200         horizontalElasticity = m_frame-&gt;page() ? m_frame-&gt;page()-&gt;horizontalScrollElasticity() : ScrollElasticityAllowed;
 201     } else if (m_frame-&gt;settings().rubberBandingForSubScrollableRegionsEnabled()) {
 202         verticalElasticity = ScrollElasticityAutomatic;
 203         horizontalElasticity = ScrollElasticityAutomatic;
 204     }
 205 
 206     ScrollableArea::setVerticalScrollElasticity(verticalElasticity);
 207     ScrollableArea::setHorizontalScrollElasticity(horizontalElasticity);
 208 #endif
 209 }
 210 
 211 Ref&lt;FrameView&gt; FrameView::create(Frame&amp; frame)
 212 {
 213     Ref&lt;FrameView&gt; view = adoptRef(*new FrameView(frame));
 214     if (frame.page() &amp;&amp; frame.page()-&gt;isVisible())
 215         view-&gt;show();
 216     return view;
 217 }
 218 
 219 Ref&lt;FrameView&gt; FrameView::create(Frame&amp; frame, const IntSize&amp; initialSize)
 220 {
 221     Ref&lt;FrameView&gt; view = adoptRef(*new FrameView(frame));
 222     view-&gt;Widget::setFrameRect(IntRect(view-&gt;location(), initialSize));
 223     if (frame.page() &amp;&amp; frame.page()-&gt;isVisible())
 224         view-&gt;show();
 225     return view;
 226 }
 227 
 228 FrameView::~FrameView()
 229 {
 230     removeFromAXObjectCache();
 231     resetScrollbars();
 232 
 233     // Custom scrollbars should already be destroyed at this point
 234     ASSERT(!horizontalScrollbar() || !horizontalScrollbar()-&gt;isCustomScrollbar());
 235     ASSERT(!verticalScrollbar() || !verticalScrollbar()-&gt;isCustomScrollbar());
 236 
 237     setHasHorizontalScrollbar(false); // Remove native scrollbars now before we lose the connection to the HostWindow.
 238     setHasVerticalScrollbar(false);
 239 
 240     ASSERT(!m_scrollCorner);
 241 
 242     ASSERT(frame().view() != this || !frame().contentRenderer());
 243 }
 244 
 245 void FrameView::reset()
 246 {
 247     m_cannotBlitToWindow = false;
 248     m_isOverlapped = false;
 249     m_contentIsOpaque = false;
 250     m_updateEmbeddedObjectsTimer.stop();
 251     m_wasScrolledByUser = false;
 252     m_delayedScrollEventTimer.stop();
 253     m_shouldScrollToFocusedElement = false;
 254     m_delayedScrollToFocusedElementTimer.stop();
 255     m_lastViewportSize = IntSize();
 256     m_lastZoomFactor = 1.0f;
 257     m_isTrackingRepaints = false;
 258     m_trackedRepaintRects.clear();
 259     m_lastPaintTime = MonotonicTime();
 260     m_paintBehavior = PaintBehavior::Normal;
 261     m_isPainting = false;
 262     m_needsDeferredScrollbarsUpdate = false;
 263     m_maintainScrollPositionAnchor = nullptr;
 264     resetLayoutMilestones();
 265     layoutContext().reset();
 266 }
 267 
 268 void FrameView::resetLayoutMilestones()
 269 {
 270     m_firstLayoutCallbackPending = false;
 271     m_isVisuallyNonEmpty = false;
 272     m_hasReachedSignificantRenderedTextThreshold = false;
 273     m_renderedSignificantAmountOfText = false;
 274     m_visuallyNonEmptyCharacterCount = 0;
 275     m_visuallyNonEmptyPixelCount = 0;
 276     m_textRendererCountForVisuallyNonEmptyCharacters = 0;
 277 }
 278 
 279 void FrameView::removeFromAXObjectCache()
 280 {
 281     if (AXObjectCache* cache = axObjectCache()) {
 282         if (HTMLFrameOwnerElement* owner = frame().ownerElement())
 283             cache-&gt;childrenChanged(owner-&gt;renderer());
 284         cache-&gt;remove(this);
 285     }
 286 }
 287 
 288 void FrameView::resetScrollbars()
 289 {
 290     // FIXME: Do we really need this?
 291     layoutContext().resetFirstLayoutFlag();
 292     // Reset the document&#39;s scrollbars back to our defaults before we yield the floor.
 293     setScrollbarsSuppressed(true);
 294     if (m_canHaveScrollbars)
 295         setScrollbarModes(ScrollbarAuto, ScrollbarAuto);
 296     else
 297         setScrollbarModes(ScrollbarAlwaysOff, ScrollbarAlwaysOff);
 298     setScrollbarsSuppressed(false);
 299 }
 300 
 301 void FrameView::resetScrollbarsAndClearContentsSize()
 302 {
 303     resetScrollbars();
 304 
 305     LOG(Layout, &quot;FrameView %p resetScrollbarsAndClearContentsSize&quot;, this);
 306 
 307     setScrollbarsSuppressed(true);
 308     setContentsSize(IntSize());
 309     setScrollbarsSuppressed(false);
 310 }
 311 
 312 void FrameView::init()
 313 {
 314     reset();
 315 
<a name="5" id="anc5"></a><span class="line-removed"> 316     m_margins = LayoutSize(-1, -1); // undefined</span>
 317     m_size = LayoutSize();
 318 
<a name="6" id="anc6"></a><span class="line-modified"> 319     // Propagate the marginwidth/height and scrolling modes to the view.</span>
<span class="line-modified"> 320     Element* ownerElement = frame().ownerElement();</span>
<span class="line-modified"> 321     if (is&lt;HTMLFrameElementBase&gt;(ownerElement)) {</span>
<span class="line-modified"> 322         HTMLFrameElementBase&amp; frameElement = downcast&lt;HTMLFrameElementBase&gt;(*ownerElement);</span>
<span class="line-removed"> 323         if (frameElement.scrollingMode() == ScrollbarAlwaysOff)</span>
<span class="line-removed"> 324             setCanHaveScrollbars(false);</span>
<span class="line-removed"> 325         LayoutUnit marginWidth = frameElement.marginWidth();</span>
<span class="line-removed"> 326         LayoutUnit marginHeight = frameElement.marginHeight();</span>
<span class="line-removed"> 327         if (marginWidth != -1)</span>
<span class="line-removed"> 328             setMarginWidth(marginWidth);</span>
<span class="line-removed"> 329         if (marginHeight != -1)</span>
<span class="line-removed"> 330             setMarginHeight(marginHeight);</span>
<span class="line-removed"> 331     }</span>
 332 
 333     Page* page = frame().page();
 334     if (page &amp;&amp; page-&gt;chrome().client().shouldPaintEntireContents())
 335         setPaintsEntireContents(true);
 336 }
 337 
 338 void FrameView::prepareForDetach()
 339 {
 340     detachCustomScrollbars();
 341     // When the view is no longer associated with a frame, it needs to be removed from the ax object cache
 342     // right now, otherwise it won&#39;t be able to reach the topDocument()&#39;s axObject cache later.
 343     removeFromAXObjectCache();
 344 
 345     if (frame().page()) {
 346         if (ScrollingCoordinator* scrollingCoordinator = frame().page()-&gt;scrollingCoordinator())
 347             scrollingCoordinator-&gt;willDestroyScrollableArea(*this);
 348     }
 349 }
 350 
 351 void FrameView::detachCustomScrollbars()
 352 {
 353     Scrollbar* horizontalBar = horizontalScrollbar();
 354     if (horizontalBar &amp;&amp; horizontalBar-&gt;isCustomScrollbar())
 355         setHasHorizontalScrollbar(false);
 356 
 357     Scrollbar* verticalBar = verticalScrollbar();
 358     if (verticalBar &amp;&amp; verticalBar-&gt;isCustomScrollbar())
 359         setHasVerticalScrollbar(false);
 360 
 361     m_scrollCorner = nullptr;
 362 }
 363 
 364 void FrameView::recalculateScrollbarOverlayStyle()
 365 {
 366     ScrollbarOverlayStyle oldOverlayStyle = scrollbarOverlayStyle();
 367     Optional&lt;ScrollbarOverlayStyle&gt; clientOverlayStyle = frame().page() ? frame().page()-&gt;chrome().client().preferredScrollbarOverlayStyle() : WTF::nullopt;
 368     if (clientOverlayStyle) {
 369         if (clientOverlayStyle.value() != oldOverlayStyle)
 370             setScrollbarOverlayStyle(clientOverlayStyle.value());
 371         return;
 372     }
 373 
 374     ScrollbarOverlayStyle computedOverlayStyle = ScrollbarOverlayStyleDefault;
 375 
 376     Color backgroundColor = documentBackgroundColor();
 377     if (backgroundColor.isValid()) {
 378         // Reduce the background color from RGB to a lightness value
 379         // and determine which scrollbar style to use based on a lightness
 380         // heuristic.
 381         double hue, saturation, lightness;
 382         backgroundColor.getHSL(hue, saturation, lightness);
 383         if (lightness &lt;= .5 &amp;&amp; backgroundColor.isVisible())
 384             computedOverlayStyle = ScrollbarOverlayStyleLight;
 385         else if (!backgroundColor.isVisible() &amp;&amp; useDarkAppearance())
 386             computedOverlayStyle = ScrollbarOverlayStyleLight;
 387     }
 388 
 389     if (oldOverlayStyle != computedOverlayStyle)
 390         setScrollbarOverlayStyle(computedOverlayStyle);
 391 }
 392 
 393 #if ENABLE(DARK_MODE_CSS)
 394 void FrameView::recalculateBaseBackgroundColor()
 395 {
 396     bool usingDarkAppearance = useDarkAppearance();
 397     if (m_usesDarkAppearance == usingDarkAppearance)
 398         return;
 399 
 400     m_usesDarkAppearance = usingDarkAppearance;
 401     Optional&lt;Color&gt; backgroundColor;
 402     if (m_isTransparent)
 403         backgroundColor = Color(Color::transparent);
 404     updateBackgroundRecursively(backgroundColor);
 405 }
 406 #endif
 407 
 408 void FrameView::clear()
 409 {
 410     setCanBlitOnScroll(true);
 411 
 412     reset();
 413 
 414     setScrollbarsSuppressed(true);
 415 
 416 #if PLATFORM(IOS_FAMILY)
 417     // To avoid flashes of white, disable tile updates immediately when view is cleared at the beginning of a page load.
 418     // Tiling will be re-enabled from UIKit via [WAKWindow setTilingMode:] when we have content to draw.
 419     if (LegacyTileCache* tileCache = legacyTileCache())
 420         tileCache-&gt;setTilingMode(LegacyTileCache::Disabled);
 421 #endif
 422 }
 423 
 424 #if PLATFORM(IOS_FAMILY)
 425 void FrameView::didReplaceMultipartContent()
 426 {
 427     // Re-enable tile updates that were disabled in clear().
 428     if (LegacyTileCache* tileCache = legacyTileCache())
 429         tileCache-&gt;setTilingMode(LegacyTileCache::Normal);
 430 }
 431 #endif
 432 
 433 bool FrameView::didFirstLayout() const
 434 {
 435     return layoutContext().didFirstLayout();
 436 }
 437 
 438 void FrameView::invalidateRect(const IntRect&amp; rect)
 439 {
 440     if (!parent()) {
 441         if (auto* page = frame().page())
 442             page-&gt;chrome().invalidateContentsAndRootView(rect);
 443         return;
 444     }
 445 
 446     auto* renderer = frame().ownerRenderer();
 447     if (!renderer)
 448         return;
 449 
 450     IntRect repaintRect = rect;
 451     repaintRect.moveBy(roundedIntPoint(renderer-&gt;contentBoxLocation()));
 452     renderer-&gt;repaintRectangle(repaintRect);
 453 }
 454 
 455 void FrameView::setFrameRect(const IntRect&amp; newRect)
 456 {
 457     Ref&lt;FrameView&gt; protectedThis(*this);
 458     IntRect oldRect = frameRect();
 459     if (newRect == oldRect)
 460         return;
<a name="7" id="anc7"></a>
 461     // Every scroll that happens as the result of frame size change is programmatic.
<a name="8" id="anc8"></a><span class="line-modified"> 462     SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true);</span>


 463     ScrollView::setFrameRect(newRect);
 464 
 465     updateScrollableAreaSet();
 466 
 467     if (RenderView* renderView = this-&gt;renderView()) {
 468         if (renderView-&gt;usesCompositing())
 469             renderView-&gt;compositor().frameViewDidChangeSize();
 470     }
 471 
 472     if (frame().isMainFrame() &amp;&amp; frame().page())
 473         frame().page()-&gt;pageOverlayController().didChangeViewSize();
 474 
 475     viewportContentsChanged();
<a name="9" id="anc9"></a>
 476 }
 477 
 478 bool FrameView::scheduleAnimation()
 479 {
 480     auto* page = frame().page();
 481     if (!page)
 482         return false;
 483     page-&gt;chrome().scheduleAnimation();
 484     return true;
 485 }
 486 
<a name="10" id="anc10"></a><span class="line-removed"> 487 void FrameView::setMarginWidth(LayoutUnit w)</span>
<span class="line-removed"> 488 {</span>
<span class="line-removed"> 489     // make it update the rendering area when set</span>
<span class="line-removed"> 490     m_margins.setWidth(w);</span>
<span class="line-removed"> 491 }</span>
<span class="line-removed"> 492 </span>
<span class="line-removed"> 493 void FrameView::setMarginHeight(LayoutUnit h)</span>
<span class="line-removed"> 494 {</span>
<span class="line-removed"> 495     // make it update the rendering area when set</span>
<span class="line-removed"> 496     m_margins.setHeight(h);</span>
<span class="line-removed"> 497 }</span>
<span class="line-removed"> 498 </span>
 499 FrameFlattening FrameView::effectiveFrameFlattening() const
 500 {
 501 #if PLATFORM(IOS_FAMILY)
 502     // On iOS when async frame scrolling is enabled, it does not make sense to use full frame flattening.
 503     // In that case, we just consider that frame flattening is disabled. This allows people to test
 504     // frame scrolling on iOS by enabling &quot;Async Frame Scrolling&quot; via the Safari menu.
 505     if (frame().settings().asyncFrameScrollingEnabled() &amp;&amp; frame().settings().frameFlattening() == FrameFlattening::FullyEnabled)
 506         return FrameFlattening::Disabled;
 507 #endif
 508     return frame().settings().frameFlattening();
 509 }
 510 
 511 bool FrameView::frameFlatteningEnabled() const
 512 {
 513     return effectiveFrameFlattening() != FrameFlattening::Disabled;
 514 }
 515 
 516 bool FrameView::isFrameFlatteningValidForThisFrame() const
 517 {
 518     if (!frameFlatteningEnabled())
 519         return false;
 520 
 521     HTMLFrameOwnerElement* owner = frame().ownerElement();
 522     if (!owner)
 523         return false;
 524 
 525     // Frame flattening is valid only for &lt;frame&gt; and &lt;iframe&gt;.
 526     return owner-&gt;hasTagName(frameTag) || owner-&gt;hasTagName(iframeTag);
 527 }
 528 
 529 bool FrameView::avoidScrollbarCreation() const
 530 {
 531     // with frame flattening no subframe can have scrollbars
 532     // but we also cannot turn scrollbars off as we determine
 533     // our flattening policy using that.
 534     return isFrameFlatteningValidForThisFrame();
 535 }
 536 
 537 void FrameView::setCanHaveScrollbars(bool canHaveScrollbars)
 538 {
 539     m_canHaveScrollbars = canHaveScrollbars;
 540     ScrollView::setCanHaveScrollbars(canHaveScrollbars);
 541 }
 542 
 543 void FrameView::updateCanHaveScrollbars()
 544 {
 545     ScrollbarMode hMode;
 546     ScrollbarMode vMode;
 547     scrollbarModes(hMode, vMode);
 548     if (hMode == ScrollbarAlwaysOff &amp;&amp; vMode == ScrollbarAlwaysOff)
 549         setCanHaveScrollbars(false);
 550     else
 551         setCanHaveScrollbars(true);
 552 }
 553 
 554 Ref&lt;Scrollbar&gt; FrameView::createScrollbar(ScrollbarOrientation orientation)
 555 {
 556     // FIXME: We need to update the scrollbar dynamically as documents change (or as doc elements and bodies get discovered that have custom styles).
 557     Document* doc = frame().document();
 558 
 559     // Try the &lt;body&gt; element first as a scrollbar source.
 560     HTMLElement* body = doc ? doc-&gt;bodyOrFrameset() : nullptr;
 561     if (body &amp;&amp; body-&gt;renderer() &amp;&amp; body-&gt;renderer()-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))
 562         return RenderScrollbar::createCustomScrollbar(*this, orientation, body);
 563 
 564     // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
 565     Element* docElement = doc ? doc-&gt;documentElement() : nullptr;
 566     if (docElement &amp;&amp; docElement-&gt;renderer() &amp;&amp; docElement-&gt;renderer()-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))
 567         return RenderScrollbar::createCustomScrollbar(*this, orientation, docElement);
 568 
 569     // If we have an owning iframe/frame element, then it can set the custom scrollbar also.
 570     RenderWidget* frameRenderer = frame().ownerRenderer();
 571     if (frameRenderer &amp;&amp; frameRenderer-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))
 572         return RenderScrollbar::createCustomScrollbar(*this, orientation, nullptr, &amp;frame());
 573 
 574     // Nobody set a custom style, so we just use a native scrollbar.
 575     return ScrollView::createScrollbar(orientation);
 576 }
 577 
 578 void FrameView::didRestoreFromPageCache()
 579 {
 580     // When restoring from page cache, the main frame stays in place while subframes get swapped in.
 581     // We update the scrollable area set to ensure that scrolling data structures get invalidated.
 582     updateScrollableAreaSet();
 583 }
 584 
 585 void FrameView::willDestroyRenderTree()
 586 {
 587     detachCustomScrollbars();
 588     layoutContext().clearSubtreeLayoutRoot();
 589 }
 590 
 591 void FrameView::didDestroyRenderTree()
 592 {
 593     ASSERT(!layoutContext().subtreeLayoutRoot());
 594     ASSERT(m_widgetsInRenderTree.isEmpty());
 595 
 596     // If the render tree is destroyed below FrameView::updateEmbeddedObjects(), there will still be a null sentinel in the set.
 597     // Everything else should have removed itself as the tree was felled.
 598     ASSERT(!m_embeddedObjectsToUpdate || m_embeddedObjectsToUpdate-&gt;isEmpty() || (m_embeddedObjectsToUpdate-&gt;size() == 1 &amp;&amp; m_embeddedObjectsToUpdate-&gt;first() == nullptr));
 599 
 600     ASSERT(!m_viewportConstrainedObjects || m_viewportConstrainedObjects-&gt;isEmpty());
 601     ASSERT(!m_slowRepaintObjects || m_slowRepaintObjects-&gt;isEmpty());
 602 
 603     ASSERT(!frame().animation().hasAnimations());
 604 }
 605 
 606 void FrameView::setContentsSize(const IntSize&amp; size)
 607 {
 608     if (size == contentsSize())
 609         return;
 610 
 611     layoutContext().disableSetNeedsLayout();
 612 
 613     ScrollView::setContentsSize(size);
 614     contentsResized();
 615 
 616     Page* page = frame().page();
 617     if (!page)
 618         return;
 619 
 620     updateScrollableAreaSet();
 621 
 622     page-&gt;chrome().contentsSizeChanged(frame(), size); // Notify only.
 623 
 624     if (frame().isMainFrame()) {
 625         page-&gt;pageOverlayController().didChangeDocumentSize();
 626         PageCache::singleton().markPagesForContentsSizeChanged(*page);
 627     }
 628     layoutContext().enableSetNeedsLayout();
 629 }
 630 
 631 void FrameView::adjustViewSize()
 632 {
 633     RenderView* renderView = this-&gt;renderView();
 634     if (!renderView)
 635         return;
 636 
 637     ASSERT(frame().view() == this);
 638 
 639     const IntRect rect = renderView-&gt;documentRect();
 640     const IntSize&amp; size = rect.size();
 641     ScrollView::setScrollOrigin(IntPoint(-rect.x(), -rect.y()), !frame().document()-&gt;printing(), size == contentsSize());
 642 
 643     LOG_WITH_STREAM(Layout, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; adjustViewSize: unscaled document rect changed to &quot; &lt;&lt; renderView-&gt;unscaledDocumentRect() &lt;&lt; &quot; (scaled to &quot; &lt;&lt; size &lt;&lt; &quot;)&quot;);
 644 
 645     setContentsSize(size);
 646 }
 647 
 648 void FrameView::applyOverflowToViewport(const RenderElement&amp; renderer, ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode)
 649 {
 650     // Handle the overflow:hidden/scroll case for the body/html elements.  WinIE treats
 651     // overflow:hidden and overflow:scroll on &lt;body&gt; as applying to the document&#39;s
 652     // scrollbars.  The CSS2.1 draft states that HTML UAs should use the &lt;html&gt; or &lt;body&gt; element and XML/XHTML UAs should
 653     // use the root element.
 654 
 655     // To combat the inability to scroll on a page with overflow:hidden on the root when scaled, disregard hidden when
 656     // there is a frameScaleFactor that is greater than one on the main frame. Also disregard hidden if there is a
 657     // header or footer.
 658 
 659     bool overrideHidden = frame().isMainFrame() &amp;&amp; ((frame().frameScaleFactor() &gt; 1) || headerHeight() || footerHeight());
 660 
 661     Overflow overflowX = renderer.style().overflowX();
 662     Overflow overflowY = renderer.style().overflowY();
 663 
 664     if (is&lt;RenderSVGRoot&gt;(renderer)) {
 665         // FIXME: evaluate if we can allow overflow for these cases too.
 666         // Overflow is always hidden when stand-alone SVG documents are embedded.
 667         if (downcast&lt;RenderSVGRoot&gt;(renderer).isEmbeddedThroughFrameContainingSVGDocument()) {
 668             overflowX = Overflow::Hidden;
 669             overflowY = Overflow::Hidden;
 670         }
 671     }
 672 
 673     switch (overflowX) {
 674     case Overflow::Hidden:
 675         if (overrideHidden)
 676             hMode = ScrollbarAuto;
 677         else
 678             hMode = ScrollbarAlwaysOff;
 679         break;
 680     case Overflow::Scroll:
 681         hMode = ScrollbarAlwaysOn;
 682         break;
 683     case Overflow::Auto:
 684         hMode = ScrollbarAuto;
 685         break;
 686     default:
 687         // Don&#39;t set it at all.
 688         ;
 689     }
 690 
 691     switch (overflowY) {
 692     case Overflow::Hidden:
 693         if (overrideHidden)
 694             vMode = ScrollbarAuto;
 695         else
 696             vMode = ScrollbarAlwaysOff;
 697         break;
 698     case Overflow::Scroll:
 699         vMode = ScrollbarAlwaysOn;
 700         break;
 701     case Overflow::Auto:
 702         vMode = ScrollbarAuto;
 703         break;
 704     default:
 705         // Don&#39;t set it at all. Values of Overflow::PagedX and Overflow::PagedY are handled by applyPaginationToViewPort().
 706         ;
 707     }
 708 }
 709 
 710 void FrameView::applyPaginationToViewport()
 711 {
 712     auto* document = frame().document();
 713     auto* documentElement = document ? document-&gt;documentElement() : nullptr;
 714     if (!documentElement || !documentElement-&gt;renderer()) {
 715         setPagination(Pagination());
 716         return;
 717     }
 718 
 719     auto&amp; documentRenderer = *documentElement-&gt;renderer();
 720     auto* documentOrBodyRenderer = &amp;documentRenderer;
 721 
 722     auto* body = document-&gt;body();
 723     if (body &amp;&amp; body-&gt;renderer()) {
 724         documentOrBodyRenderer = documentRenderer.style().overflowX() == Overflow::Visible &amp;&amp; is&lt;HTMLHtmlElement&gt;(*documentElement) ?
 725             body-&gt;renderer() : &amp;documentRenderer;
 726     }
 727 
 728     Pagination pagination;
 729     Overflow overflowY = documentOrBodyRenderer-&gt;style().overflowY();
 730     if (overflowY == Overflow::PagedX || overflowY == Overflow::PagedY) {
 731         pagination.mode = WebCore::paginationModeForRenderStyle(documentOrBodyRenderer-&gt;style());
 732         GapLength columnGapLength = documentOrBodyRenderer-&gt;style().columnGap();
 733         pagination.gap = 0;
 734         if (!columnGapLength.isNormal()) {
 735             if (auto* containerForPaginationGap = is&lt;RenderBox&gt;(documentOrBodyRenderer) ? downcast&lt;RenderBox&gt;(documentOrBodyRenderer) : documentOrBodyRenderer-&gt;containingBlock())
 736                 pagination.gap = valueForLength(columnGapLength.length(), containerForPaginationGap-&gt;availableLogicalWidth()).toUnsigned();
 737         }
 738     }
 739     setPagination(pagination);
 740 }
 741 
 742 void FrameView::calculateScrollbarModesForLayout(ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode, ScrollbarModesCalculationStrategy strategy)
 743 {
 744     m_viewportRendererType = ViewportRendererType::None;
 745 
 746     const HTMLFrameOwnerElement* owner = frame().ownerElement();
 747     if (owner &amp;&amp; (owner-&gt;scrollingMode() == ScrollbarAlwaysOff)) {
 748         hMode = ScrollbarAlwaysOff;
 749         vMode = ScrollbarAlwaysOff;
 750         return;
 751     }
 752 
 753     if (m_canHaveScrollbars || strategy == RulesFromWebContentOnly) {
 754         hMode = ScrollbarAuto;
 755         vMode = ScrollbarAuto;
 756     } else {
 757         hMode = ScrollbarAlwaysOff;
 758         vMode = ScrollbarAlwaysOff;
 759     }
 760 
 761     if (layoutContext().subtreeLayoutRoot())
 762         return;
 763 
 764     auto* document = frame().document();
 765     if (!document)
 766         return;
 767 
 768     auto* documentElement = document-&gt;documentElement();
 769     if (!documentElement)
 770         return;
 771 
 772     auto* bodyOrFrameset = document-&gt;bodyOrFrameset();
 773     auto* rootRenderer = documentElement-&gt;renderer();
 774     if (!bodyOrFrameset || !bodyOrFrameset-&gt;renderer()) {
 775         if (rootRenderer) {
 776             applyOverflowToViewport(*rootRenderer, hMode, vMode);
 777             m_viewportRendererType = ViewportRendererType::Document;
 778         }
 779         return;
 780     }
 781 
 782     if (is&lt;HTMLFrameSetElement&gt;(*bodyOrFrameset) &amp;&amp; !frameFlatteningEnabled()) {
 783         vMode = ScrollbarAlwaysOff;
 784         hMode = ScrollbarAlwaysOff;
 785         return;
 786     }
 787 
 788     if (is&lt;HTMLBodyElement&gt;(*bodyOrFrameset) &amp;&amp; rootRenderer) {
 789         // It&#39;s sufficient to just check the X overflow,
 790         // since it&#39;s illegal to have visible in only one direction.
 791         if (rootRenderer-&gt;style().overflowX() == Overflow::Visible &amp;&amp; is&lt;HTMLHtmlElement&gt;(documentElement)) {
 792             auto* bodyRenderer = bodyOrFrameset-&gt;renderer();
 793             if (bodyRenderer) {
 794                 applyOverflowToViewport(*bodyRenderer, hMode, vMode);
 795                 m_viewportRendererType = ViewportRendererType::Body;
 796             }
 797         } else {
 798             applyOverflowToViewport(*rootRenderer, hMode, vMode);
 799             m_viewportRendererType = ViewportRendererType::Document;
 800         }
 801     }
 802 }
 803 
 804 void FrameView::willRecalcStyle()
 805 {
 806     RenderView* renderView = this-&gt;renderView();
 807     if (!renderView)
 808         return;
 809 
 810     renderView-&gt;compositor().willRecalcStyle();
 811 }
 812 
 813 bool FrameView::updateCompositingLayersAfterStyleChange()
 814 {
 815     // If we expect to update compositing after an incipient layout, don&#39;t do so here.
 816     if (!renderView() || needsLayout() || layoutContext().isInLayout())
 817         return false;
 818     return renderView()-&gt;compositor().didRecalcStyleWithNoPendingLayout();
 819 }
 820 
 821 void FrameView::updateCompositingLayersAfterLayout()
 822 {
 823     RenderView* renderView = this-&gt;renderView();
 824     if (!renderView)
 825         return;
 826 
 827     renderView-&gt;compositor().updateCompositingLayers(CompositingUpdateType::AfterLayout);
 828 }
 829 
 830 GraphicsLayer* FrameView::layerForHorizontalScrollbar() const
 831 {
 832     RenderView* renderView = this-&gt;renderView();
 833     if (!renderView)
 834         return nullptr;
 835     return renderView-&gt;compositor().layerForHorizontalScrollbar();
 836 }
 837 
 838 GraphicsLayer* FrameView::layerForVerticalScrollbar() const
 839 {
 840     RenderView* renderView = this-&gt;renderView();
 841     if (!renderView)
 842         return nullptr;
 843     return renderView-&gt;compositor().layerForVerticalScrollbar();
 844 }
 845 
 846 GraphicsLayer* FrameView::layerForScrollCorner() const
 847 {
 848     RenderView* renderView = this-&gt;renderView();
 849     if (!renderView)
 850         return nullptr;
 851     return renderView-&gt;compositor().layerForScrollCorner();
 852 }
 853 
 854 TiledBacking* FrameView::tiledBacking() const
 855 {
 856     RenderView* renderView = this-&gt;renderView();
 857     if (!renderView)
 858         return nullptr;
 859 
 860     RenderLayerBacking* backing = renderView-&gt;layer()-&gt;backing();
 861     if (!backing)
 862         return nullptr;
 863 
 864     return backing-&gt;tiledBacking();
 865 }
 866 
 867 ScrollingNodeID FrameView::scrollingNodeID() const
 868 {
 869     RenderView* renderView = this-&gt;renderView();
 870     if (!renderView)
 871         return 0;
 872 
 873     RenderLayerBacking* backing = renderView-&gt;layer()-&gt;backing();
 874     if (!backing)
 875         return 0;
 876 
 877     return backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);
 878 }
 879 
 880 ScrollableArea* FrameView::scrollableAreaForScrollLayerID(uint64_t nodeID) const
 881 {
 882     RenderView* renderView = this-&gt;renderView();
 883     if (!renderView)
 884         return nullptr;
 885 
 886     return renderView-&gt;compositor().scrollableAreaForScrollLayerID(nodeID);
 887 }
 888 
 889 #if ENABLE(RUBBER_BANDING)
 890 GraphicsLayer* FrameView::layerForOverhangAreas() const
 891 {
 892     RenderView* renderView = this-&gt;renderView();
 893     if (!renderView)
 894         return nullptr;
 895     return renderView-&gt;compositor().layerForOverhangAreas();
 896 }
 897 
 898 GraphicsLayer* FrameView::setWantsLayerForTopOverHangArea(bool wantsLayer) const
 899 {
 900     RenderView* renderView = this-&gt;renderView();
 901     if (!renderView)
 902         return nullptr;
 903 
 904     return renderView-&gt;compositor().updateLayerForTopOverhangArea(wantsLayer);
 905 }
 906 
 907 GraphicsLayer* FrameView::setWantsLayerForBottomOverHangArea(bool wantsLayer) const
 908 {
 909     RenderView* renderView = this-&gt;renderView();
 910     if (!renderView)
 911         return nullptr;
 912 
 913     return renderView-&gt;compositor().updateLayerForBottomOverhangArea(wantsLayer);
 914 }
 915 
 916 #endif // ENABLE(RUBBER_BANDING)
 917 
 918 #if ENABLE(CSS_SCROLL_SNAP)
 919 void FrameView::updateSnapOffsets()
 920 {
 921     if (!frame().document())
 922         return;
 923 
 924     // FIXME: Should we allow specifying snap points through &lt;html&gt; tags too?
 925     HTMLElement* body = frame().document()-&gt;bodyOrFrameset();
 926     if (!renderView() || !body || !body-&gt;renderer())
 927         return;
 928 
 929     updateSnapOffsetsForScrollableArea(*this, *body, *renderView(), body-&gt;renderer()-&gt;style());
 930 }
 931 
 932 bool FrameView::isScrollSnapInProgress() const
 933 {
 934     if (scrollbarsSuppressed())
 935         return false;
 936 
 937     // If the scrolling thread updates the scroll position for this FrameView, then we should return
 938     // ScrollingCoordinator::isScrollSnapInProgress().
 939     if (Page* page = frame().page()) {
 940         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator()) {
 941             if (!scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
 942                 return scrollingCoordinator-&gt;isScrollSnapInProgress();
 943         }
 944     }
 945 
 946     // If the main thread updates the scroll position for this FrameView, we should return
 947     // ScrollAnimator::isScrollSnapInProgress().
 948     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
 949         return scrollAnimator-&gt;isScrollSnapInProgress();
 950 
 951     return false;
 952 }
 953 
 954 void FrameView::updateScrollingCoordinatorScrollSnapProperties() const
 955 {
 956     renderView()-&gt;compositor().updateScrollSnapPropertiesWithFrameView(*this);
 957 }
 958 #endif
 959 
 960 bool FrameView::flushCompositingStateForThisFrame(const Frame&amp; rootFrameForFlush)
 961 {
 962     RenderView* renderView = this-&gt;renderView();
 963     if (!renderView)
 964         return true; // We don&#39;t want to keep trying to update layers if we have no renderer.
 965 
 966     ASSERT(frame().view() == this);
 967 
 968     // If we sync compositing layers when a layout is pending, we may cause painting of compositing
 969     // layer content to occur before layout has happened, which will cause paintContents() to bail.
 970     if (needsLayout())
 971         return false;
 972 
 973 #if PLATFORM(IOS_FAMILY)
 974     if (LegacyTileCache* tileCache = legacyTileCache())
 975         tileCache-&gt;doPendingRepaints();
 976 #endif
 977 
 978     renderView-&gt;compositor().flushPendingLayerChanges(&amp;rootFrameForFlush == m_frame.ptr());
 979 
 980     return true;
 981 }
 982 
 983 void FrameView::setNeedsOneShotDrawingSynchronization()
 984 {
 985     if (Page* page = frame().page())
 986         page-&gt;chrome().client().setNeedsOneShotDrawingSynchronization();
 987 }
 988 
 989 GraphicsLayer* FrameView::graphicsLayerForPlatformWidget(PlatformWidget platformWidget)
 990 {
 991     // To find the Widget that corresponds with platformWidget we have to do a linear
 992     // search of our child widgets.
 993     const Widget* foundWidget = nullptr;
 994     for (auto&amp; widget : children()) {
 995         if (widget-&gt;platformWidget() != platformWidget)
 996             continue;
 997         foundWidget = widget.ptr();
 998         break;
 999     }
1000 
1001     if (!foundWidget)
1002         return nullptr;
1003 
1004     auto* renderWidget = RenderWidget::find(*foundWidget);
1005     if (!renderWidget)
1006         return nullptr;
1007 
1008     auto* widgetLayer = renderWidget-&gt;layer();
1009     if (!widgetLayer || !widgetLayer-&gt;isComposited())
1010         return nullptr;
1011 
1012     return widgetLayer-&gt;backing()-&gt;parentForSublayers();
1013 }
1014 
1015 void FrameView::scheduleLayerFlushAllowingThrottling()
1016 {
1017     RenderView* view = this-&gt;renderView();
1018     if (!view)
1019         return;
1020     view-&gt;compositor().scheduleLayerFlush(true /* canThrottle */);
1021 }
1022 
1023 LayoutRect FrameView::fixedScrollableAreaBoundsInflatedForScrolling(const LayoutRect&amp; uninflatedBounds) const
1024 {
1025     LayoutPoint scrollPosition;
1026     LayoutSize topLeftExpansion;
1027     LayoutSize bottomRightExpansion;
1028 
1029     if (frame().settings().visualViewportEnabled()) {
1030         // FIXME: this is wrong under zooming; uninflatedBounds is scaled but the scroll positions are not.
1031         scrollPosition = layoutViewportRect().location();
1032         topLeftExpansion = scrollPosition - unscaledMinimumScrollPosition();
1033         bottomRightExpansion = unscaledMaximumScrollPosition() - scrollPosition;
1034     } else {
1035         scrollPosition = scrollPositionRespectingCustomFixedPosition();
1036         topLeftExpansion = scrollPosition - minimumScrollPosition();
1037         bottomRightExpansion = maximumScrollPosition() - scrollPosition;
1038     }
1039 
1040     return LayoutRect(uninflatedBounds.location() - topLeftExpansion, uninflatedBounds.size() + topLeftExpansion + bottomRightExpansion);
1041 }
1042 
1043 LayoutPoint FrameView::scrollPositionRespectingCustomFixedPosition() const
1044 {
1045 #if PLATFORM(IOS_FAMILY)
1046     if (!frame().settings().visualViewportEnabled())
1047         return useCustomFixedPositionLayoutRect() ? customFixedPositionLayoutRect().location() : scrollPosition();
1048 #endif
1049 
1050     return scrollPositionForFixedPosition();
1051 }
1052 
1053 int FrameView::headerHeight() const
1054 {
1055     if (!frame().isMainFrame())
1056         return 0;
1057     Page* page = frame().page();
1058     return page ? page-&gt;headerHeight() : 0;
1059 }
1060 
1061 int FrameView::footerHeight() const
1062 {
1063     if (!frame().isMainFrame())
1064         return 0;
1065     Page* page = frame().page();
1066     return page ? page-&gt;footerHeight() : 0;
1067 }
1068 
1069 float FrameView::topContentInset(TopContentInsetType contentInsetTypeToReturn) const
1070 {
1071     if (platformWidget() &amp;&amp; contentInsetTypeToReturn == TopContentInsetType::WebCoreOrPlatformContentInset)
1072         return platformTopContentInset();
1073 
1074     if (!frame().isMainFrame())
1075         return 0;
1076 
1077     Page* page = frame().page();
1078     return page ? page-&gt;topContentInset() : 0;
1079 }
1080 
1081 void FrameView::topContentInsetDidChange(float newTopContentInset)
1082 {
1083     RenderView* renderView = this-&gt;renderView();
1084     if (!renderView)
1085         return;
1086 
1087     if (platformWidget())
1088         platformSetTopContentInset(newTopContentInset);
1089 
1090     layoutContext().layout();
1091     // Every scroll that happens as the result of content inset change is programmatic.
<a name="11" id="anc11"></a><span class="line-modified">1092     SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true);</span>


1093     updateScrollbars(scrollPosition());
1094     if (renderView-&gt;usesCompositing())
1095         renderView-&gt;compositor().frameViewDidChangeSize();
1096 
1097     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
1098         tiledBacking-&gt;setTopContentInset(newTopContentInset);
<a name="12" id="anc12"></a>

1099 }
1100 
1101 void FrameView::topContentDirectionDidChange()
1102 {
1103     m_needsDeferredScrollbarsUpdate = true;
1104 }
1105 
1106 void FrameView::handleDeferredScrollbarsUpdateAfterDirectionChange()
1107 {
1108     if (!m_needsDeferredScrollbarsUpdate)
1109         return;
1110 
1111     m_needsDeferredScrollbarsUpdate = false;
1112 
1113     updateScrollbars(scrollPosition());
1114     positionScrollbarLayers();
1115 }
1116 
1117 // Sometimes (for plug-ins) we need to eagerly go into compositing mode.
1118 void FrameView::enterCompositingMode()
1119 {
1120     if (RenderView* renderView = this-&gt;renderView()) {
1121         renderView-&gt;compositor().enableCompositingMode();
1122         if (!needsLayout())
1123             renderView-&gt;compositor().scheduleCompositingLayerUpdate();
1124     }
1125 }
1126 
1127 bool FrameView::isEnclosedInCompositingLayer() const
1128 {
1129     auto frameOwnerRenderer = frame().ownerRenderer();
1130     if (frameOwnerRenderer &amp;&amp; frameOwnerRenderer-&gt;containerForRepaint())
1131         return true;
1132 
1133     if (FrameView* parentView = parentFrameView())
1134         return parentView-&gt;isEnclosedInCompositingLayer();
1135     return false;
1136 }
1137 
1138 bool FrameView::flushCompositingStateIncludingSubframes()
1139 {
<a name="13" id="anc13"></a><span class="line-removed">1140 #if PLATFORM(COCOA)</span>
<span class="line-removed">1141     InspectorInstrumentation::willComposite(frame());</span>
<span class="line-removed">1142 #endif</span>
<span class="line-removed">1143 </span>
1144     bool allFramesFlushed = flushCompositingStateForThisFrame(frame());
1145 
1146     for (Frame* child = frame().tree().firstRenderedChild(); child; child = child-&gt;tree().traverseNextRendered(m_frame.ptr())) {
1147         if (!child-&gt;view())
1148             continue;
1149         bool flushed = child-&gt;view()-&gt;flushCompositingStateForThisFrame(frame());
1150         allFramesFlushed &amp;= flushed;
1151     }
1152     return allFramesFlushed;
1153 }
1154 
1155 bool FrameView::isSoftwareRenderable() const
1156 {
1157     RenderView* renderView = this-&gt;renderView();
1158     return !renderView || !renderView-&gt;compositor().has3DContent();
1159 }
1160 
1161 void FrameView::setIsInWindow(bool isInWindow)
1162 {
1163     if (RenderView* renderView = this-&gt;renderView())
1164         renderView-&gt;setIsInWindow(isInWindow);
1165 }
1166 
1167 void FrameView::forceLayoutParentViewIfNeeded()
1168 {
1169     RenderWidget* ownerRenderer = frame().ownerRenderer();
1170     if (!ownerRenderer)
1171         return;
1172 
1173     RenderBox* contentBox = embeddedContentBox();
1174     if (!contentBox)
1175         return;
1176 
1177     auto&amp; svgRoot = downcast&lt;RenderSVGRoot&gt;(*contentBox);
1178     if (svgRoot.everHadLayout() &amp;&amp; !svgRoot.needsLayout())
1179         return;
1180 
1181     LOG(Layout, &quot;FrameView %p forceLayoutParentViewIfNeeded scheduling layout on parent FrameView %p&quot;, this, &amp;ownerRenderer-&gt;view().frameView());
1182 
1183     // If the embedded SVG document appears the first time, the ownerRenderer has already finished
1184     // layout without knowing about the existence of the embedded SVG document, because RenderReplaced
1185     // embeddedContentBox() returns nullptr, as long as the embedded document isn&#39;t loaded yet. Before
1186     // bothering to lay out the SVG document, mark the ownerRenderer needing layout and ask its
1187     // FrameView for a layout. After that the RenderEmbeddedObject (ownerRenderer) carries the
1188     // correct size, which RenderSVGRoot::computeReplacedLogicalWidth/Height rely on, when laying
1189     // out for the first time, or when the RenderSVGRoot size has changed dynamically (eg. via &lt;script&gt;).
1190 
1191     ownerRenderer-&gt;setNeedsLayoutAndPrefWidthsRecalc();
1192     ownerRenderer-&gt;view().frameView().layoutContext().scheduleLayout();
1193 }
1194 
1195 void FrameView::markRootOrBodyRendererDirty() const
1196 {
1197     auto&amp; document = *frame().document();
1198     RenderBox* rootRenderer = document.documentElement() ? document.documentElement()-&gt;renderBox() : nullptr;
1199     auto* body = document.bodyOrFrameset();
1200     RenderBox* bodyRenderer = rootRenderer &amp;&amp; body ? body-&gt;renderBox() : nullptr;
1201     if (bodyRenderer &amp;&amp; bodyRenderer-&gt;stretchesToViewport())
1202         bodyRenderer-&gt;setChildNeedsLayout();
1203     else if (rootRenderer &amp;&amp; rootRenderer-&gt;stretchesToViewport())
1204         rootRenderer-&gt;setChildNeedsLayout();
1205 }
1206 
1207 void FrameView::adjustScrollbarsForLayout(bool isFirstLayout)
1208 {
1209     ScrollbarMode hMode;
1210     ScrollbarMode vMode;
1211     calculateScrollbarModesForLayout(hMode, vMode);
1212     if (isFirstLayout &amp;&amp; !layoutContext().isLayoutNested()) {
1213         setScrollbarsSuppressed(true);
1214         // Set the initial vMode to AlwaysOn if we&#39;re auto.
1215         if (vMode == ScrollbarAuto)
1216             setVerticalScrollbarMode(ScrollbarAlwaysOn); // This causes a vertical scrollbar to appear.
1217         // Set the initial hMode to AlwaysOff if we&#39;re auto.
1218         if (hMode == ScrollbarAuto)
1219             setHorizontalScrollbarMode(ScrollbarAlwaysOff); // This causes a horizontal scrollbar to disappear.
1220         ASSERT(frame().page());
1221         if (frame().page()-&gt;expectsWheelEventTriggers())
1222             scrollAnimator().setWheelEventTestTrigger(frame().page()-&gt;testTrigger());
1223         setScrollbarModes(hMode, vMode);
1224         setScrollbarsSuppressed(false, true);
1225     } else if (hMode != horizontalScrollbarMode() || vMode != verticalScrollbarMode())
1226         setScrollbarModes(hMode, vMode);
1227 }
1228 
1229 void FrameView::willDoLayout(WeakPtr&lt;RenderElement&gt; layoutRoot)
1230 {
1231     bool subtreeLayout = !is&lt;RenderView&gt;(*layoutRoot);
1232     if (subtreeLayout)
1233         return;
1234 
1235     if (auto* body = frame().document()-&gt;bodyOrFrameset()) {
1236         if (is&lt;HTMLFrameSetElement&gt;(*body) &amp;&amp; !frameFlatteningEnabled() &amp;&amp; body-&gt;renderer())
1237             body-&gt;renderer()-&gt;setChildNeedsLayout();
1238     }
1239     auto firstLayout = !layoutContext().didFirstLayout();
1240     if (firstLayout) {
1241         m_lastViewportSize = sizeForResizeEvent();
1242         m_lastZoomFactor = layoutRoot-&gt;style().zoom();
1243         m_firstLayoutCallbackPending = true;
1244     }
1245     adjustScrollbarsForLayout(firstLayout);
1246 
1247     auto oldSize = m_size;
1248     LayoutSize newSize = layoutSize();
1249     if (oldSize != newSize) {
1250         m_size = newSize;
1251         LOG(Layout, &quot;  layout size changed from %.3fx%.3f to %.3fx%.3f&quot;, oldSize.width().toFloat(), oldSize.height().toFloat(),     newSize.width().toFloat(), newSize.height().toFloat());
1252         layoutContext().setNeedsFullRepaint();
1253         if (!firstLayout)
1254             markRootOrBodyRendererDirty();
1255     }
1256     forceLayoutParentViewIfNeeded();
1257 }
1258 
1259 void FrameView::didLayout(WeakPtr&lt;RenderElement&gt; layoutRoot)
1260 {
1261     renderView()-&gt;releaseProtectedRenderWidgets();
1262     auto* layoutRootEnclosingLayer = layoutRoot-&gt;enclosingLayer();
<a name="14" id="anc14"></a><span class="line-modified">1263     layoutRootEnclosingLayer-&gt;updateLayerPositionsAfterLayout(renderView()-&gt;layer(), updateLayerPositionFlags(layoutRootEnclosingLayer, !is&lt;RenderView&gt;(*layoutRoot), layoutContext().needsFullRepaint()));</span>
1264 
1265     updateCompositingLayersAfterLayout();
1266 
1267 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
1268     if (auto* cache = frame().document()-&gt;existingAXObjectCache())
1269         cache-&gt;postNotification(layoutRoot.get(), AXObjectCache::AXLayoutComplete);
1270 #endif
1271 
<a name="15" id="anc15"></a><span class="line-modified">1272     frame().document()-&gt;invalidateRenderingDependentRegions(Document::AnnotationsAction::Update);</span>
1273 
1274     updateCanBlitOnScrollRecursively();
1275 
1276     handleDeferredScrollUpdateAfterContentSizeChange();
1277 
1278     handleDeferredScrollbarsUpdateAfterDirectionChange();
1279 
1280     if (frame().document()-&gt;hasListenerType(Document::OVERFLOWCHANGED_LISTENER))
1281         updateOverflowStatus(layoutWidth() &lt; contentsWidth(), layoutHeight() &lt; contentsHeight());
1282 
1283     frame().document()-&gt;markers().invalidateRectsForAllMarkers();
1284 }
1285 
1286 bool FrameView::shouldDeferScrollUpdateAfterContentSizeChange()
1287 {
1288     return (layoutContext().layoutPhase() &lt; FrameViewLayoutContext::LayoutPhase::InPostLayout) &amp;&amp; (layoutContext().layoutPhase() != FrameViewLayoutContext::LayoutPhase::OutsideLayout);
1289 }
1290 
1291 RenderBox* FrameView::embeddedContentBox() const
1292 {
1293     RenderView* renderView = this-&gt;renderView();
1294     if (!renderView)
1295         return nullptr;
1296 
1297     RenderObject* firstChild = renderView-&gt;firstChild();
1298 
1299     // Curently only embedded SVG documents participate in the size-negotiation logic.
1300     if (is&lt;RenderSVGRoot&gt;(firstChild))
1301         return downcast&lt;RenderSVGRoot&gt;(firstChild);
1302 
1303     return nullptr;
1304 }
1305 
1306 void FrameView::addEmbeddedObjectToUpdate(RenderEmbeddedObject&amp; embeddedObject)
1307 {
1308     if (!m_embeddedObjectsToUpdate)
<a name="16" id="anc16"></a><span class="line-modified">1309         m_embeddedObjectsToUpdate = std::make_unique&lt;ListHashSet&lt;RenderEmbeddedObject*&gt;&gt;();</span>
1310 
1311     HTMLFrameOwnerElement&amp; element = embeddedObject.frameOwnerElement();
1312     if (is&lt;HTMLObjectElement&gt;(element) || is&lt;HTMLEmbedElement&gt;(element)) {
1313         // Tell the DOM element that it needs a widget update.
1314         HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
1315         if (!pluginElement.needsCheckForSizeChange())
1316             pluginElement.setNeedsWidgetUpdate(true);
1317     }
1318 
1319     m_embeddedObjectsToUpdate-&gt;add(&amp;embeddedObject);
1320 }
1321 
1322 void FrameView::removeEmbeddedObjectToUpdate(RenderEmbeddedObject&amp; embeddedObject)
1323 {
1324     if (!m_embeddedObjectsToUpdate)
1325         return;
1326 
1327     m_embeddedObjectsToUpdate-&gt;remove(&amp;embeddedObject);
1328 }
1329 
1330 void FrameView::setMediaType(const String&amp; mediaType)
1331 {
1332     m_mediaType = mediaType;
1333 }
1334 
1335 String FrameView::mediaType() const
1336 {
1337     // See if we have an override type.
1338     String overrideType = frame().loader().client().overrideMediaType();
1339     InspectorInstrumentation::applyEmulatedMedia(frame(), overrideType);
1340     if (!overrideType.isNull())
1341         return overrideType;
1342     return m_mediaType;
1343 }
1344 
1345 void FrameView::adjustMediaTypeForPrinting(bool printing)
1346 {
1347     if (printing) {
1348         if (m_mediaTypeWhenNotPrinting.isNull())
1349             m_mediaTypeWhenNotPrinting = mediaType();
1350         setMediaType(&quot;print&quot;);
1351     } else {
1352         if (!m_mediaTypeWhenNotPrinting.isNull())
1353             setMediaType(m_mediaTypeWhenNotPrinting);
1354         m_mediaTypeWhenNotPrinting = String();
1355     }
1356 }
1357 
1358 bool FrameView::useSlowRepaints(bool considerOverlap) const
1359 {
1360     bool mustBeSlow = hasSlowRepaintObjects() || (platformWidget() &amp;&amp; hasViewportConstrainedObjects());
1361 
1362     // FIXME: WidgetMac.mm makes the assumption that useSlowRepaints ==
1363     // m_contentIsOpaque, so don&#39;t take the fast path for composited layers
1364     // if they are a platform widget in order to get painting correctness
1365     // for transparent layers. See the comment in WidgetMac::paint.
1366     if (usesCompositedScrolling() &amp;&amp; !platformWidget())
1367         return mustBeSlow;
1368 
1369     bool isOverlapped = m_isOverlapped &amp;&amp; considerOverlap;
1370 
1371     if (mustBeSlow || m_cannotBlitToWindow || isOverlapped || !m_contentIsOpaque)
1372         return true;
1373 
1374     if (FrameView* parentView = parentFrameView())
1375         return parentView-&gt;useSlowRepaints(considerOverlap);
1376 
1377     return false;
1378 }
1379 
1380 bool FrameView::useSlowRepaintsIfNotOverlapped() const
1381 {
1382     return useSlowRepaints(false);
1383 }
1384 
1385 void FrameView::updateCanBlitOnScrollRecursively()
1386 {
1387     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
1388         if (FrameView* view = frame-&gt;view())
1389             view-&gt;setCanBlitOnScroll(!view-&gt;useSlowRepaints());
1390     }
1391 }
1392 
1393 bool FrameView::usesCompositedScrolling() const
1394 {
1395     RenderView* renderView = this-&gt;renderView();
1396     if (renderView &amp;&amp; renderView-&gt;isComposited()) {
1397         GraphicsLayer* layer = renderView-&gt;layer()-&gt;backing()-&gt;graphicsLayer();
1398         if (layer &amp;&amp; layer-&gt;drawsContent())
1399             return true;
1400     }
1401 
1402     return false;
1403 }
1404 
1405 bool FrameView::usesAsyncScrolling() const
1406 {
1407 #if ENABLE(ASYNC_SCROLLING)
1408     if (Page* page = frame().page()) {
1409         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1410             return scrollingCoordinator-&gt;coordinatesScrollingForFrameView(*this);
1411     }
1412 #endif
1413     return false;
1414 }
1415 
1416 bool FrameView::usesMockScrollAnimator() const
1417 {
1418     return DeprecatedGlobalSettings::usesMockScrollAnimator();
1419 }
1420 
1421 void FrameView::logMockScrollAnimatorMessage(const String&amp; message) const
1422 {
1423     Document* document = frame().document();
1424     if (!document)
1425         return;
1426     StringBuilder builder;
1427     if (frame().isMainFrame())
1428         builder.appendLiteral(&quot;Main&quot;);
1429     builder.appendLiteral(&quot;FrameView: &quot;);
1430     builder.append(message);
1431     document-&gt;addConsoleMessage(MessageSource::Other, MessageLevel::Debug, builder.toString());
1432 }
1433 
1434 void FrameView::setCannotBlitToWindow()
1435 {
1436     m_cannotBlitToWindow = true;
1437     updateCanBlitOnScrollRecursively();
1438 }
1439 
1440 void FrameView::addSlowRepaintObject(RenderElement&amp; renderer)
1441 {
1442     bool hadSlowRepaintObjects = hasSlowRepaintObjects();
1443 
1444     if (!m_slowRepaintObjects)
<a name="17" id="anc17"></a><span class="line-modified">1445         m_slowRepaintObjects = std::make_unique&lt;HashSet&lt;const RenderElement*&gt;&gt;();</span>
1446 
1447     m_slowRepaintObjects-&gt;add(&amp;renderer);
1448     if (hadSlowRepaintObjects)
1449         return;
1450 
1451     updateCanBlitOnScrollRecursively();
1452 
1453     if (auto* page = frame().page()) {
1454         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
1455             scrollingCoordinator-&gt;frameViewHasSlowRepaintObjectsDidChange(*this);
1456     }
1457 }
1458 
1459 void FrameView::removeSlowRepaintObject(RenderElement&amp; renderer)
1460 {
1461     if (!m_slowRepaintObjects)
1462         return;
1463 
1464     m_slowRepaintObjects-&gt;remove(&amp;renderer);
1465     if (!m_slowRepaintObjects-&gt;isEmpty())
1466         return;
1467 
1468     m_slowRepaintObjects = nullptr;
1469     updateCanBlitOnScrollRecursively();
1470 
1471     if (auto* page = frame().page()) {
1472         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
1473             scrollingCoordinator-&gt;frameViewHasSlowRepaintObjectsDidChange(*this);
1474     }
1475 }
1476 
1477 void FrameView::addViewportConstrainedObject(RenderLayerModelObject* object)
1478 {
1479     if (!m_viewportConstrainedObjects)
<a name="18" id="anc18"></a><span class="line-modified">1480         m_viewportConstrainedObjects = std::make_unique&lt;ViewportConstrainedObjectSet&gt;();</span>
1481 
1482     if (!m_viewportConstrainedObjects-&gt;contains(object)) {
1483         m_viewportConstrainedObjects-&gt;add(object);
1484         if (platformWidget())
1485             updateCanBlitOnScrollRecursively();
1486 
1487         if (Page* page = frame().page()) {
1488             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1489                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(*this);
1490         }
1491     }
1492 }
1493 
1494 void FrameView::removeViewportConstrainedObject(RenderLayerModelObject* object)
1495 {
1496     if (m_viewportConstrainedObjects &amp;&amp; m_viewportConstrainedObjects-&gt;remove(object)) {
1497         if (Page* page = frame().page()) {
1498             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1499                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(*this);
1500         }
1501 
1502         // FIXME: In addFixedObject() we only call this if there&#39;s a platform widget,
1503         // why isn&#39;t the same check being made here?
1504         updateCanBlitOnScrollRecursively();
1505     }
1506 }
1507 
1508 LayoutSize FrameView::expandedLayoutViewportSize(const LayoutSize&amp; baseLayoutViewportSize, const LayoutSize&amp; documentSize, double heightExpansionFactor)
1509 {
1510     if (!heightExpansionFactor)
1511         return baseLayoutViewportSize;
1512 
1513     auto documentHeight = documentSize.height();
1514     auto layoutViewportHeight = baseLayoutViewportSize.height();
1515     if (layoutViewportHeight &gt; documentHeight)
1516         return baseLayoutViewportSize;
1517 
<a name="19" id="anc19"></a><span class="line-modified">1518     return { baseLayoutViewportSize.width(), std::min&lt;LayoutUnit&gt;(documentHeight, (1 + heightExpansionFactor) * layoutViewportHeight) };</span>
1519 }
1520 
1521 LayoutRect FrameView::computeUpdatedLayoutViewportRect(const LayoutRect&amp; layoutViewport, const LayoutRect&amp; documentRect, const LayoutSize&amp; unobscuredContentSize, const LayoutRect&amp; unobscuredContentRect, const LayoutSize&amp; baseLayoutViewportSize, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, LayoutViewportConstraint constraint)
1522 {
1523     LayoutRect layoutViewportRect = layoutViewport;
1524 
1525     // The layout viewport is never smaller than baseLayoutViewportSize, and never be smaller than the unobscuredContentRect.
1526     LayoutSize constrainedSize = baseLayoutViewportSize;
1527     layoutViewportRect.setSize(constrainedSize.expandedTo(unobscuredContentSize));
1528 
1529     LayoutPoint layoutViewportOrigin = computeLayoutViewportOrigin(unobscuredContentRect, stableLayoutViewportOriginMin, stableLayoutViewportOriginMax, layoutViewportRect, StickToViewportBounds);
1530 
1531     // FIXME: Is this equivalent to calling computeLayoutViewportOrigin() with StickToDocumentBounds?
1532     if (constraint == LayoutViewportConstraint::ConstrainedToDocumentRect) {
1533         // The max stable layout viewport origin really depends on the size of the layout viewport itself, so we need to adjust the location of the layout viewport one final time to make sure it does not end up out of bounds of the document.
1534         // Without this adjustment (and with using the non-constrained unobscuredContentRect&#39;s size as the size of the layout viewport) the layout viewport can be pushed past the bounds of the document during rubber-banding, and cannot be pushed
1535         // back in until the user scrolls back in the other direction.
1536         layoutViewportOrigin.setX(clampTo&lt;float&gt;(layoutViewportOrigin.x().toFloat(), 0, documentRect.width() - layoutViewportRect.width()));
1537         layoutViewportOrigin.setY(clampTo&lt;float&gt;(layoutViewportOrigin.y().toFloat(), 0, documentRect.height() - layoutViewportRect.height()));
1538     }
1539     layoutViewportRect.setLocation(layoutViewportOrigin);
1540 
1541     return layoutViewportRect;
1542 }
1543 
1544 // visualViewport and layoutViewport are both in content coordinates (unzoomed).
1545 LayoutPoint FrameView::computeLayoutViewportOrigin(const LayoutRect&amp; visualViewport, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, const LayoutRect&amp; layoutViewport, ScrollBehaviorForFixedElements fixedBehavior)
1546 {
1547     LayoutPoint layoutViewportOrigin = layoutViewport.location();
1548     bool allowRubberBanding = fixedBehavior == StickToViewportBounds;
1549 
1550     if (visualViewport.width() &gt; layoutViewport.width()) {
1551         layoutViewportOrigin.setX(visualViewport.x());
1552         if (!allowRubberBanding) {
1553             if (layoutViewportOrigin.x() &lt; stableLayoutViewportOriginMin.x())
1554                 layoutViewportOrigin.setX(stableLayoutViewportOriginMin.x());
1555             else if (layoutViewportOrigin.x() &gt; stableLayoutViewportOriginMax.x())
1556                 layoutViewportOrigin.setX(stableLayoutViewportOriginMax.x());
1557         }
1558     } else {
1559         bool rubberbandingAtLeft = allowRubberBanding &amp;&amp; visualViewport.x() &lt; stableLayoutViewportOriginMin.x();
1560         bool rubberbandingAtRight = allowRubberBanding &amp;&amp; (visualViewport.maxX() - layoutViewport.width()) &gt; stableLayoutViewportOriginMax.x();
1561 
1562         if (visualViewport.x() &lt; layoutViewport.x() || rubberbandingAtLeft)
1563             layoutViewportOrigin.setX(visualViewport.x());
1564 
1565         if (visualViewport.maxX() &gt; layoutViewport.maxX() || rubberbandingAtRight)
1566             layoutViewportOrigin.setX(visualViewport.maxX() - layoutViewport.width());
1567 
1568         if (!rubberbandingAtLeft &amp;&amp; layoutViewportOrigin.x() &lt; stableLayoutViewportOriginMin.x())
1569             layoutViewportOrigin.setX(stableLayoutViewportOriginMin.x());
1570 
1571         if (!rubberbandingAtRight &amp;&amp; layoutViewportOrigin.x() &gt; stableLayoutViewportOriginMax.x())
1572             layoutViewportOrigin.setX(stableLayoutViewportOriginMax.x());
1573     }
1574 
1575     if (visualViewport.height() &gt; layoutViewport.height()) {
1576         layoutViewportOrigin.setY(visualViewport.y());
1577         if (!allowRubberBanding) {
1578             if (layoutViewportOrigin.y() &lt; stableLayoutViewportOriginMin.y())
1579                 layoutViewportOrigin.setY(stableLayoutViewportOriginMin.y());
1580             else if (layoutViewportOrigin.y() &gt; stableLayoutViewportOriginMax.y())
1581                 layoutViewportOrigin.setY(stableLayoutViewportOriginMax.y());
1582         }
1583     } else {
1584         bool rubberbandingAtTop = allowRubberBanding &amp;&amp; visualViewport.y() &lt; stableLayoutViewportOriginMin.y();
1585         bool rubberbandingAtBottom = allowRubberBanding &amp;&amp; (visualViewport.maxY() - layoutViewport.height()) &gt; stableLayoutViewportOriginMax.y();
1586 
1587         if (visualViewport.y() &lt; layoutViewport.y() || rubberbandingAtTop)
1588             layoutViewportOrigin.setY(visualViewport.y());
1589 
1590         if (visualViewport.maxY() &gt; layoutViewport.maxY() || rubberbandingAtBottom)
1591             layoutViewportOrigin.setY(visualViewport.maxY() - layoutViewport.height());
1592 
1593         if (!rubberbandingAtTop &amp;&amp; layoutViewportOrigin.y() &lt; stableLayoutViewportOriginMin.y())
1594             layoutViewportOrigin.setY(stableLayoutViewportOriginMin.y());
1595 
1596         if (!rubberbandingAtBottom &amp;&amp; layoutViewportOrigin.y() &gt; stableLayoutViewportOriginMax.y())
1597             layoutViewportOrigin.setY(stableLayoutViewportOriginMax.y());
1598     }
1599 
1600     return layoutViewportOrigin;
1601 }
1602 
1603 void FrameView::setBaseLayoutViewportOrigin(LayoutPoint origin, TriggerLayoutOrNot layoutTriggering)
1604 {
1605     ASSERT(frame().settings().visualViewportEnabled());
1606 
1607     if (origin == m_layoutViewportOrigin)
1608         return;
1609 
1610     m_layoutViewportOrigin = origin;
1611     if (layoutTriggering == TriggerLayoutOrNot::Yes)
1612         setViewportConstrainedObjectsNeedLayout();
1613 
1614     if (TiledBacking* tiledBacking = this-&gt;tiledBacking()) {
1615         FloatRect layoutViewport = layoutViewportRect();
1616         layoutViewport.moveBy(unscaledScrollOrigin()); // tiledBacking deals in top-left relative coordinates.
1617         tiledBacking-&gt;setLayoutViewportRect(layoutViewport);
1618     }
1619 }
1620 
1621 void FrameView::setLayoutViewportOverrideRect(Optional&lt;LayoutRect&gt; rect, TriggerLayoutOrNot layoutTriggering)
1622 {
1623     if (rect == m_layoutViewportOverrideRect)
1624         return;
1625 
1626     LayoutRect oldRect = layoutViewportRect();
1627     m_layoutViewportOverrideRect = rect;
1628 
1629     // Triggering layout on height changes is necessary to make bottom-fixed elements behave correctly.
1630     if (oldRect.height() != layoutViewportRect().height())
1631         layoutTriggering = TriggerLayoutOrNot::Yes;
1632 
1633     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\nFrameView &quot; &lt;&lt; this &lt;&lt; &quot; setLayoutViewportOverrideRect() - changing override layout viewport from &quot; &lt;&lt; oldRect &lt;&lt; &quot; to &quot; &lt;&lt; m_layoutViewportOverrideRect.valueOr(LayoutRect()) &lt;&lt; &quot; layoutTriggering &quot; &lt;&lt; (layoutTriggering == TriggerLayoutOrNot::Yes ? &quot;yes&quot; : &quot;no&quot;));
1634 
1635     if (oldRect != layoutViewportRect() &amp;&amp; layoutTriggering == TriggerLayoutOrNot::Yes)
1636         setViewportConstrainedObjectsNeedLayout();
1637 }
1638 
1639 void FrameView::setVisualViewportOverrideRect(Optional&lt;LayoutRect&gt; rect)
1640 {
1641     m_visualViewportOverrideRect = rect;
1642 }
1643 
1644 LayoutSize FrameView::baseLayoutViewportSize() const
1645 {
1646     return renderView() ? renderView()-&gt;size() : size();
1647 }
1648 
1649 void FrameView::updateLayoutViewport()
1650 {
1651     if (!frame().settings().visualViewportEnabled())
1652         return;
1653 
1654     // Don&#39;t update the layout viewport if we&#39;re in the middle of adjusting scrollbars. We&#39;ll get another call
1655     // as a post-layout task.
1656     if (layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::InViewSizeAdjust)
1657         return;
1658 
1659     LayoutRect layoutViewport = layoutViewportRect();
1660 
1661     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\nFrameView &quot; &lt;&lt; this &lt;&lt; &quot; updateLayoutViewport() totalContentSize &quot; &lt;&lt; totalContentsSize() &lt;&lt; &quot; unscaledDocumentRect &quot; &lt;&lt; (renderView() ? renderView()-&gt;unscaledDocumentRect() : IntRect()) &lt;&lt; &quot; header height &quot; &lt;&lt; headerHeight() &lt;&lt; &quot; footer height &quot; &lt;&lt; footerHeight() &lt;&lt; &quot; fixed behavior &quot; &lt;&lt; scrollBehaviorForFixedElements());
1662     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport: &quot; &lt;&lt; layoutViewport);
1663     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;visualViewport: &quot; &lt;&lt; visualViewportRect() &lt;&lt; &quot; (is override &quot; &lt;&lt; (bool)m_visualViewportOverrideRect &lt;&lt; &quot;)&quot;);
1664     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;stable origins: min: &quot; &lt;&lt; minStableLayoutViewportOrigin() &lt;&lt; &quot; max: &quot;&lt;&lt; maxStableLayoutViewportOrigin());
1665 
1666     if (m_layoutViewportOverrideRect) {
<a name="20" id="anc20"></a><span class="line-modified">1667         if (m_inProgrammaticScroll) {</span>
1668             LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;computing new override layout viewport because of programmatic scrolling&quot;);
1669             LayoutPoint newOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, StickToDocumentBounds);
1670             setLayoutViewportOverrideRect(LayoutRect(newOrigin, m_layoutViewportOverrideRect.value().size()));
1671         }
<a name="21" id="anc21"></a><span class="line-modified">1672         if (frame().settings().visualViewportAPIEnabled()) {</span>
<span class="line-removed">1673             if (auto* window = frame().window())</span>
<span class="line-removed">1674                 window-&gt;visualViewport().update();</span>
<span class="line-removed">1675         }</span>
1676         return;
1677     }
1678 
1679     LayoutPoint newLayoutViewportOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, scrollBehaviorForFixedElements());
1680     if (newLayoutViewportOrigin != m_layoutViewportOrigin) {
1681         setBaseLayoutViewportOrigin(newLayoutViewportOrigin);
1682         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport changed to &quot; &lt;&lt; layoutViewportRect());
1683     }
<a name="22" id="anc22"></a><span class="line-modified">1684     if (frame().settings().visualViewportAPIEnabled()) {</span>
<span class="line-removed">1685         if (auto* window = frame().window())</span>
<span class="line-removed">1686             window-&gt;visualViewport().update();</span>
<span class="line-removed">1687     }</span>
1688 }
1689 
1690 LayoutPoint FrameView::minStableLayoutViewportOrigin() const
1691 {
1692     return unscaledMinimumScrollPosition();
1693 }
1694 
1695 LayoutPoint FrameView::maxStableLayoutViewportOrigin() const
1696 {
1697     LayoutPoint maxPosition = unscaledMaximumScrollPosition();
1698     maxPosition = (maxPosition - LayoutSize(0, headerHeight() + footerHeight())).expandedTo({ });
1699     return maxPosition;
1700 }
1701 
1702 IntPoint FrameView::unscaledScrollOrigin() const
1703 {
1704     if (RenderView* renderView = this-&gt;renderView())
1705         return -renderView-&gt;unscaledDocumentRect().location(); // Akin to code in adjustViewSize().
1706 
1707     return { };
1708 }
1709 
1710 LayoutRect FrameView::layoutViewportRect() const
1711 {
1712     if (m_layoutViewportOverrideRect)
1713         return m_layoutViewportOverrideRect.value();
1714 
1715     // Size of initial containing block, anchored at scroll position, in document coordinates (unchanged by scale factor).
1716     return LayoutRect(m_layoutViewportOrigin, baseLayoutViewportSize());
1717 }
1718 
1719 // visibleContentRect is in the bounds of the scroll view content. That consists of an
1720 // optional header, the document, and an optional footer. Only the document is scaled,
1721 // so we have to compute the visible part of the document in unscaled document coordinates.
1722 // On iOS, pageScaleFactor is always 1 here, and we never have headers and footers.
1723 LayoutRect FrameView::visibleDocumentRect(const FloatRect&amp; visibleContentRect, float headerHeight, float footerHeight, const FloatSize&amp; totalContentsSize, float pageScaleFactor)
1724 {
1725     float contentsHeight = totalContentsSize.height() - headerHeight - footerHeight;
1726 
1727     float rubberBandTop = std::min&lt;float&gt;(visibleContentRect.y(), 0);
1728     float visibleScaledDocumentTop = std::max&lt;float&gt;(visibleContentRect.y() - headerHeight, 0) + rubberBandTop;
1729 
1730     float rubberBandBottom = std::min&lt;float&gt;((totalContentsSize.height() - visibleContentRect.y()) - visibleContentRect.height(), 0);
1731     float visibleScaledDocumentBottom = std::min&lt;float&gt;(visibleContentRect.maxY() - headerHeight, contentsHeight) - rubberBandBottom;
1732 
1733     FloatRect visibleDocumentRect = visibleContentRect;
1734     visibleDocumentRect.setY(visibleScaledDocumentTop);
1735     visibleDocumentRect.setHeight(std::max&lt;float&gt;(visibleScaledDocumentBottom - visibleScaledDocumentTop, 0));
1736     visibleDocumentRect.scale(1 / pageScaleFactor);
1737 
1738     return LayoutRect(visibleDocumentRect);
1739 }
1740 
1741 LayoutRect FrameView::visualViewportRect() const
1742 {
1743     if (m_visualViewportOverrideRect)
1744         return m_visualViewportOverrideRect.value();
1745 
1746     FloatRect visibleContentRect = this-&gt;visibleContentRect(LegacyIOSDocumentVisibleRect);
1747     return visibleDocumentRect(visibleContentRect, headerHeight(), footerHeight(), totalContentsSize(), frameScaleFactor());
1748 }
1749 
1750 LayoutRect FrameView::viewportConstrainedVisibleContentRect() const
1751 {
1752     ASSERT(!frame().settings().visualViewportEnabled());
1753 
1754 #if PLATFORM(IOS_FAMILY)
1755     if (useCustomFixedPositionLayoutRect())
1756         return customFixedPositionLayoutRect();
1757 #endif
1758     LayoutRect viewportRect = visibleContentRect();
1759 
1760     viewportRect.setLocation(scrollPositionForFixedPosition());
1761     return viewportRect;
1762 }
1763 
1764 LayoutRect FrameView::rectForFixedPositionLayout() const
1765 {
1766     if (frame().settings().visualViewportEnabled())
1767         return layoutViewportRect();
1768 
1769     return viewportConstrainedVisibleContentRect();
1770 }
1771 
1772 float FrameView::frameScaleFactor() const
1773 {
1774     return frame().frameScaleFactor();
1775 }
1776 
1777 LayoutPoint FrameView::scrollPositionForFixedPosition() const
1778 {
1779     if (frame().settings().visualViewportEnabled())
1780         return layoutViewportRect().location();
1781 
1782     return scrollPositionForFixedPosition(visibleContentRect(), totalContentsSize(), scrollPosition(), scrollOrigin(), frameScaleFactor(), fixedElementsLayoutRelativeToFrame(), scrollBehaviorForFixedElements(), headerHeight(), footerHeight());
1783 }
1784 
1785 LayoutPoint FrameView::scrollPositionForFixedPosition(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, const LayoutPoint&amp; scrollPosition, const LayoutPoint&amp; scrollOrigin, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements behaviorForFixed, int headerHeight, int footerHeight)
1786 {
1787     LayoutPoint position;
1788     if (behaviorForFixed == StickToDocumentBounds)
1789         position = ScrollableArea::constrainScrollPositionForOverhang(visibleContentRect, totalContentsSize, scrollPosition, scrollOrigin, headerHeight, footerHeight);
1790     else {
1791         position = scrollPosition;
1792         position.setY(position.y() - headerHeight);
1793     }
1794 
1795     LayoutSize maxSize = totalContentsSize - visibleContentRect.size();
1796 
1797     float dragFactorX = (fixedElementsLayoutRelativeToFrame || !maxSize.width()) ? 1 : (totalContentsSize.width() - visibleContentRect.width() * frameScaleFactor) / maxSize.width();
1798     float dragFactorY = (fixedElementsLayoutRelativeToFrame || !maxSize.height()) ? 1 : (totalContentsSize.height() - visibleContentRect.height() * frameScaleFactor) / maxSize.height();
1799 
1800     return LayoutPoint(position.x() * dragFactorX / frameScaleFactor, position.y() * dragFactorY / frameScaleFactor);
1801 }
1802 
1803 float FrameView::yPositionForInsetClipLayer(const FloatPoint&amp; scrollPosition, float topContentInset)
1804 {
1805     if (!topContentInset)
1806         return 0;
1807 
1808     // The insetClipLayer should not move for negative scroll values.
1809     float scrollY = std::max&lt;float&gt;(0, scrollPosition.y());
1810 
1811     if (scrollY &gt;= topContentInset)
1812         return 0;
1813 
1814     return topContentInset - scrollY;
1815 }
1816 
1817 float FrameView::yPositionForHeaderLayer(const FloatPoint&amp; scrollPosition, float topContentInset)
1818 {
1819     if (!topContentInset)
1820         return 0;
1821 
1822     float scrollY = std::max&lt;float&gt;(0, scrollPosition.y());
1823 
1824     if (scrollY &gt;= topContentInset)
1825         return topContentInset;
1826 
1827     return scrollY;
1828 }
1829 
1830 float FrameView::yPositionForFooterLayer(const FloatPoint&amp; scrollPosition, float topContentInset, float totalContentsHeight, float footerHeight)
1831 {
1832     return yPositionForHeaderLayer(scrollPosition, topContentInset) + totalContentsHeight - footerHeight;
1833 }
1834 
1835 FloatPoint FrameView::positionForRootContentLayer(const FloatPoint&amp; scrollPosition, const FloatPoint&amp; scrollOrigin, float topContentInset, float headerHeight)
1836 {
1837     return FloatPoint(0, yPositionForHeaderLayer(scrollPosition, topContentInset) + headerHeight) - toFloatSize(scrollOrigin);
1838 }
1839 
1840 FloatPoint FrameView::positionForRootContentLayer() const
1841 {
1842     return positionForRootContentLayer(scrollPosition(), scrollOrigin(), topContentInset(), headerHeight());
1843 }
1844 
1845 #if PLATFORM(IOS_FAMILY)
1846 LayoutRect FrameView::rectForViewportConstrainedObjects(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements scrollBehavior)
1847 {
1848     if (fixedElementsLayoutRelativeToFrame)
1849         return visibleContentRect;
1850 
1851     if (totalContentsSize.isEmpty())
1852         return visibleContentRect;
1853 
1854     // We impose an lower limit on the size (so an upper limit on the scale) of
1855     // the rect used to position fixed objects so that they don&#39;t crowd into the
1856     // center of the screen at larger scales.
1857     const LayoutUnit maxContentWidthForZoomThreshold = 1024_lu;
1858     float zoomedOutScale = frameScaleFactor * visibleContentRect.width() / std::min(maxContentWidthForZoomThreshold, totalContentsSize.width());
1859     float constraintThresholdScale = 1.5 * zoomedOutScale;
1860     float maxPostionedObjectsRectScale = std::min(frameScaleFactor, constraintThresholdScale);
1861 
1862     LayoutRect viewportConstrainedObjectsRect = visibleContentRect;
1863 
1864     if (frameScaleFactor &gt; constraintThresholdScale) {
1865         FloatRect contentRect(FloatPoint(), totalContentsSize);
1866         FloatRect viewportRect = visibleContentRect;
1867 
1868         // Scale the rect up from a point that is relative to its position in the viewport.
1869         FloatSize sizeDelta = contentRect.size() - viewportRect.size();
1870 
1871         FloatPoint scaleOrigin;
1872         scaleOrigin.setX(contentRect.x() + sizeDelta.width() &gt; 0 ? contentRect.width() * (viewportRect.x() - contentRect.x()) / sizeDelta.width() : 0);
1873         scaleOrigin.setY(contentRect.y() + sizeDelta.height() &gt; 0 ? contentRect.height() * (viewportRect.y() - contentRect.y()) / sizeDelta.height() : 0);
1874 
1875         AffineTransform rescaleTransform = AffineTransform::translation(scaleOrigin.x(), scaleOrigin.y());
1876         rescaleTransform.scale(frameScaleFactor / maxPostionedObjectsRectScale, frameScaleFactor / maxPostionedObjectsRectScale);
1877         rescaleTransform = CGAffineTransformTranslate(rescaleTransform, -scaleOrigin.x(), -scaleOrigin.y());
1878 
1879         viewportConstrainedObjectsRect = enclosingLayoutRect(rescaleTransform.mapRect(visibleContentRect));
1880     }
1881 
1882     if (scrollBehavior == StickToDocumentBounds) {
1883         LayoutRect documentBounds(LayoutPoint(), totalContentsSize);
1884         viewportConstrainedObjectsRect.intersect(documentBounds);
1885     }
1886 
1887     return viewportConstrainedObjectsRect;
1888 }
1889 
1890 LayoutRect FrameView::viewportConstrainedObjectsRect() const
1891 {
1892     return rectForViewportConstrainedObjects(visibleContentRect(), totalContentsSize(), frame().frameScaleFactor(), fixedElementsLayoutRelativeToFrame(), scrollBehaviorForFixedElements());
1893 }
1894 #endif
1895 
1896 ScrollPosition FrameView::minimumScrollPosition() const
1897 {
1898     ScrollPosition minimumPosition = ScrollView::minimumScrollPosition();
1899 
1900     if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToBottom)
1901         minimumPosition.setY(maximumScrollPosition().y());
1902 
1903     return minimumPosition;
1904 }
1905 
1906 ScrollPosition FrameView::maximumScrollPosition() const
1907 {
1908     ScrollPosition maximumPosition = ScrollView::maximumScrollPosition();
1909 
1910     if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToTop)
1911         maximumPosition.setY(minimumScrollPosition().y());
1912 
1913     return maximumPosition;
1914 }
1915 
1916 ScrollPosition FrameView::unscaledMinimumScrollPosition() const
1917 {
1918     if (RenderView* renderView = this-&gt;renderView()) {
1919         IntRect unscaledDocumentRect = renderView-&gt;unscaledDocumentRect();
1920         ScrollPosition minimumPosition = unscaledDocumentRect.location();
1921 
1922         if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToBottom)
1923             minimumPosition.setY(unscaledMaximumScrollPosition().y());
1924 
1925         return minimumPosition;
1926     }
1927 
1928     return minimumScrollPosition();
1929 }
1930 
1931 ScrollPosition FrameView::unscaledMaximumScrollPosition() const
1932 {
1933     if (RenderView* renderView = this-&gt;renderView()) {
1934         IntRect unscaledDocumentRect = renderView-&gt;unscaledDocumentRect();
1935         unscaledDocumentRect.expand(0, headerHeight() + footerHeight());
1936         ScrollPosition maximumPosition = ScrollPosition(unscaledDocumentRect.maxXMaxYCorner() - visibleSize()).expandedTo({ 0, 0 });
1937         if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToTop)
1938             maximumPosition.setY(unscaledMinimumScrollPosition().y());
1939 
1940         return maximumPosition;
1941     }
1942 
1943     return maximumScrollPosition();
1944 }
1945 
1946 void FrameView::viewportContentsChanged()
1947 {
1948     if (!frame().view()) {
1949         // The frame is being destroyed.
1950         return;
1951     }
1952 
1953     if (auto* page = frame().page())
1954         page-&gt;updateValidationBubbleStateIfNeeded();
1955 
1956     // When the viewport contents changes (scroll, resize, style recalc, layout, ...),
1957     // check if we should resume animated images or unthrottle DOM timers.
1958     applyRecursivelyWithVisibleRect([] (FrameView&amp; frameView, const IntRect&amp; visibleRect) {
1959         frameView.resumeVisibleImageAnimations(visibleRect);
1960         frameView.updateScriptedAnimationsAndTimersThrottlingState(visibleRect);
1961 
1962         if (auto* renderView = frameView.frame().contentRenderer())
1963             renderView-&gt;updateVisibleViewportRect(visibleRect);
1964     });
<a name="23" id="anc23"></a><span class="line-removed">1965 </span>
<span class="line-removed">1966 #if ENABLE(INTERSECTION_OBSERVER)</span>
<span class="line-removed">1967     if (auto* document = frame().document()) {</span>
<span class="line-removed">1968         if (auto* page = frame().page()) {</span>
<span class="line-removed">1969             if (document-&gt;numberOfIntersectionObservers())</span>
<span class="line-removed">1970                 page-&gt;addDocumentNeedingIntersectionObservationUpdate(*document);</span>
<span class="line-removed">1971             if (!frame().isMainFrame()) {</span>
<span class="line-removed">1972                 if (auto* mainDocument = frame().mainFrame().document()) {</span>
<span class="line-removed">1973                     if (mainDocument-&gt;numberOfIntersectionObservers())</span>
<span class="line-removed">1974                         page-&gt;addDocumentNeedingIntersectionObservationUpdate(*mainDocument);</span>
<span class="line-removed">1975                 }</span>
<span class="line-removed">1976             }</span>
<span class="line-removed">1977         }</span>
<span class="line-removed">1978     }</span>
<span class="line-removed">1979 #endif</span>
1980 }
1981 
<a name="24" id="anc24"></a><span class="line-modified">1982 IntRect FrameView::unobscuredContentRectExpandedByContentInsets() const</span>
1983 {
<a name="25" id="anc25"></a><span class="line-modified">1984     FloatRect unobscuredContentRect = this-&gt;unobscuredContentRect();</span>





1985     if (auto* page = frame().page())
<a name="26" id="anc26"></a><span class="line-modified">1986         unobscuredContentRect.expand(page-&gt;contentInsets());</span>
<span class="line-modified">1987     return IntRect(unobscuredContentRect);</span>

1988 }
1989 
1990 bool FrameView::fixedElementsLayoutRelativeToFrame() const
1991 {
1992     return frame().settings().fixedElementsLayoutRelativeToFrame();
1993 }
1994 
1995 IntPoint FrameView::lastKnownMousePosition() const
1996 {
1997     return frame().eventHandler().lastKnownMousePosition();
1998 }
1999 
2000 bool FrameView::isHandlingWheelEvent() const
2001 {
2002     return frame().eventHandler().isHandlingWheelEvent();
2003 }
2004 
2005 bool FrameView::shouldSetCursor() const
2006 {
2007     Page* page = frame().page();
2008     return page &amp;&amp; page-&gt;isVisible() &amp;&amp; page-&gt;focusController().isActive();
2009 }
2010 
2011 #if ENABLE(DARK_MODE_CSS)
<a name="27" id="anc27"></a><span class="line-modified">2012 RenderObject* FrameView::rendererForSupportedColorSchemes() const</span>
2013 {
2014     auto* document = frame().document();
2015     auto* documentElement = document ? document-&gt;documentElement() : nullptr;
2016     auto* documentElementRenderer = documentElement ? documentElement-&gt;renderer() : nullptr;
<a name="28" id="anc28"></a><span class="line-modified">2017     if (documentElementRenderer &amp;&amp; documentElementRenderer-&gt;style().hasExplicitlySetSupportedColorSchemes())</span>
2018         return documentElementRenderer;
2019     auto* bodyElement = document ? document-&gt;bodyOrFrameset() : nullptr;
2020     return bodyElement ? bodyElement-&gt;renderer() : nullptr;
2021 }
2022 #endif
2023 
2024 bool FrameView::useDarkAppearance() const
2025 {
2026 #if ENABLE(DARK_MODE_CSS)
<a name="29" id="anc29"></a><span class="line-modified">2027     if (auto* renderer = rendererForSupportedColorSchemes())</span>
2028         return renderer-&gt;useDarkAppearance();
2029 #endif
2030     if (auto* document = frame().document())
2031         return document-&gt;useDarkAppearance(nullptr);
2032     return false;
2033 }
2034 
2035 OptionSet&lt;StyleColor::Options&gt; FrameView::styleColorOptions() const
2036 {
2037 #if ENABLE(DARK_MODE_CSS)
<a name="30" id="anc30"></a><span class="line-modified">2038     if (auto* renderer = rendererForSupportedColorSchemes())</span>
2039         return renderer-&gt;styleColorOptions();
2040 #endif
2041     if (auto* document = frame().document())
2042         return document-&gt;styleColorOptions(nullptr);
2043     return { };
2044 }
2045 
2046 bool FrameView::scrollContentsFastPath(const IntSize&amp; scrollDelta, const IntRect&amp; rectToScroll, const IntRect&amp; clipRect)
2047 {
2048     if (!m_viewportConstrainedObjects || m_viewportConstrainedObjects-&gt;isEmpty()) {
2049         frame().page()-&gt;chrome().scroll(scrollDelta, rectToScroll, clipRect);
2050         return true;
2051     }
2052 
2053     bool isCompositedContentLayer = usesCompositedScrolling();
2054 
2055     // Get the rects of the fixed objects visible in the rectToScroll
2056     Region regionToUpdate;
2057     for (auto&amp; renderer : *m_viewportConstrainedObjects) {
2058         if (!renderer-&gt;style().hasViewportConstrainedPosition())
2059             continue;
2060         if (renderer-&gt;isComposited())
2061             continue;
2062 
2063         // Fixed items should always have layers.
2064         ASSERT(renderer-&gt;hasLayer());
2065         RenderLayer* layer = downcast&lt;RenderBoxModelObject&gt;(*renderer).layer();
2066 
2067         if (layer-&gt;viewportConstrainedNotCompositedReason() == RenderLayer::NotCompositedForBoundsOutOfView
2068             || layer-&gt;viewportConstrainedNotCompositedReason() == RenderLayer::NotCompositedForNoVisibleContent) {
2069             // Don&#39;t invalidate for invisible fixed layers.
2070             continue;
2071         }
2072 
2073         if (layer-&gt;hasAncestorWithFilterOutsets()) {
2074             // If the fixed layer has a blur/drop-shadow filter applied on at least one of its parents, we cannot
2075             // scroll using the fast path, otherwise the outsets of the filter will be moved around the page.
2076             return false;
2077         }
2078 
2079         // FIXME: use pixel snapping instead of enclosing when ScrollView has finished transitioning from IntRect to Float/LayoutRect.
2080         IntRect updateRect = enclosingIntRect(layer-&gt;repaintRectIncludingNonCompositingDescendants());
2081         updateRect = contentsToRootView(updateRect);
2082         if (!isCompositedContentLayer)
2083             updateRect.intersect(rectToScroll);
2084         if (!updateRect.isEmpty())
2085             regionToUpdate.unite(updateRect);
2086     }
2087 
2088     // 1) scroll
2089     frame().page()-&gt;chrome().scroll(scrollDelta, rectToScroll, clipRect);
2090 
2091     // 2) update the area of fixed objects that has been invalidated
2092     for (auto&amp; updateRect : regionToUpdate.rects()) {
2093         IntRect scrolledRect = updateRect;
2094         scrolledRect.move(scrollDelta);
2095         updateRect.unite(scrolledRect);
2096         if (isCompositedContentLayer) {
2097             updateRect = rootViewToContents(updateRect);
2098             ASSERT(renderView());
2099             renderView()-&gt;layer()-&gt;setBackingNeedsRepaintInRect(updateRect);
2100             continue;
2101         }
2102         updateRect.intersect(rectToScroll);
2103         frame().page()-&gt;chrome().invalidateContentsAndRootView(updateRect);
2104     }
2105 
2106     return true;
2107 }
2108 
2109 void FrameView::scrollContentsSlowPath(const IntRect&amp; updateRect)
2110 {
2111     repaintSlowRepaintObjects();
2112 
2113     if (!usesCompositedScrolling() &amp;&amp; isEnclosedInCompositingLayer()) {
2114         if (RenderWidget* frameRenderer = frame().ownerRenderer()) {
2115             LayoutRect rect(frameRenderer-&gt;borderLeft() + frameRenderer-&gt;paddingLeft(), frameRenderer-&gt;borderTop() + frameRenderer-&gt;paddingTop(),
2116                 visibleWidth(), visibleHeight());
2117             frameRenderer-&gt;repaintRectangle(rect);
2118             return;
2119         }
2120     }
2121 
2122     ScrollView::scrollContentsSlowPath(updateRect);
2123 }
2124 
2125 void FrameView::repaintSlowRepaintObjects()
2126 {
2127     if (!m_slowRepaintObjects)
2128         return;
2129 
2130     // Renderers with fixed backgrounds may be in compositing layers, so we need to explicitly
2131     // repaint them after scrolling.
2132     for (auto&amp; renderer : *m_slowRepaintObjects)
2133         renderer-&gt;repaintSlowRepaintObject();
2134 }
2135 
2136 // Note that this gets called at painting time.
2137 void FrameView::setIsOverlapped(bool isOverlapped)
2138 {
2139     if (isOverlapped == m_isOverlapped)
2140         return;
2141 
2142     m_isOverlapped = isOverlapped;
2143     updateCanBlitOnScrollRecursively();
2144 }
2145 
2146 void FrameView::setContentIsOpaque(bool contentIsOpaque)
2147 {
2148     if (contentIsOpaque == m_contentIsOpaque)
2149         return;
2150 
2151     m_contentIsOpaque = contentIsOpaque;
2152     updateCanBlitOnScrollRecursively();
2153 }
2154 
2155 void FrameView::restoreScrollbar()
2156 {
2157     setScrollbarsSuppressed(false);
2158 }
2159 
2160 bool FrameView::scrollToFragment(const URL&amp; url)
2161 {
2162     String fragmentIdentifier = url.fragmentIdentifier();
2163     if (scrollToAnchor(fragmentIdentifier))
2164         return true;
2165 
2166     // Try again after decoding the ref, based on the document&#39;s encoding.
2167     if (TextResourceDecoder* decoder = frame().document()-&gt;decoder()) {
2168         if (scrollToAnchor(decodeURLEscapeSequences(fragmentIdentifier, decoder-&gt;encoding())))
2169             return true;
2170     }
2171 
2172     resetScrollAnchor();
2173     return false;
2174 }
2175 
2176 bool FrameView::scrollToAnchor(const String&amp; fragmentIdentifier)
2177 {
2178     LOG(Scrolling, &quot;FrameView::scrollToAnchor %s&quot;, fragmentIdentifier.utf8().data());
2179 
2180     // If our URL has no ref, then we have no place we need to jump to.
2181     if (fragmentIdentifier.isNull())
2182         return false;
2183 
2184     ASSERT(frame().document());
2185     auto&amp; document = *frame().document();
2186 
2187     if (!document.haveStylesheetsLoaded()) {
2188         document.setGotoAnchorNeededAfterStylesheetsLoad(true);
2189         return false;
2190     }
2191 
2192     document.setGotoAnchorNeededAfterStylesheetsLoad(false);
2193 
2194     Element* anchorElement = document.findAnchor(fragmentIdentifier);
2195 
2196     LOG(Scrolling, &quot; anchorElement is %p&quot;, anchorElement);
2197 
2198     // Setting to null will clear the current target.
2199     document.setCSSTarget(anchorElement);
2200 
2201     if (is&lt;SVGDocument&gt;(document)) {
2202         if (fragmentIdentifier.isEmpty())
2203             return false;
2204         if (auto rootElement = SVGDocument::rootElement(document)) {
2205             if (rootElement-&gt;scrollToFragment(fragmentIdentifier))
2206                 return true;
2207             // If SVG failed to scrollToAnchor() and anchorElement is null, no other scrolling will be possible.
2208             if (!anchorElement)
2209                 return false;
2210         }
2211     } else if (!anchorElement &amp;&amp; !(fragmentIdentifier.isEmpty() || equalLettersIgnoringASCIICase(fragmentIdentifier, &quot;top&quot;))) {
2212         // Implement the rule that &quot;&quot; and &quot;top&quot; both mean top of page as in other browsers.
2213         return false;
2214     }
2215 
2216     ContainerNode* scrollPositionAnchor = anchorElement;
2217     if (!scrollPositionAnchor)
2218         scrollPositionAnchor = frame().document();
2219     maintainScrollPositionAtAnchor(scrollPositionAnchor);
2220 
2221     // If the anchor accepts keyboard focus, move focus there to aid users relying on keyboard navigation.
2222     if (anchorElement) {
2223         if (anchorElement-&gt;isFocusable())
2224             document.setFocusedElement(anchorElement);
2225         else {
2226             document.setFocusedElement(nullptr);
2227             document.setFocusNavigationStartingNode(anchorElement);
2228         }
2229     }
2230 
2231     return true;
2232 }
2233 
2234 void FrameView::maintainScrollPositionAtAnchor(ContainerNode* anchorNode)
2235 {
2236     LOG(Scrolling, &quot;FrameView::maintainScrollPositionAtAnchor at %p&quot;, anchorNode);
2237 
2238     m_maintainScrollPositionAnchor = anchorNode;
2239     if (!m_maintainScrollPositionAnchor)
2240         return;
2241     m_shouldScrollToFocusedElement = false;
2242     m_delayedScrollToFocusedElementTimer.stop();
2243 
2244     // We need to update the layout before scrolling, otherwise we could
2245     // really mess things up if an anchor scroll comes at a bad moment.
2246     frame().document()-&gt;updateStyleIfNeeded();
2247     // Only do a layout if changes have occurred that make it necessary.
2248     RenderView* renderView = this-&gt;renderView();
2249     if (renderView &amp;&amp; renderView-&gt;needsLayout())
2250         layoutContext().layout();
2251     else
2252         scrollToAnchor();
2253 }
2254 
2255 void FrameView::scrollElementToRect(const Element&amp; element, const IntRect&amp; rect)
2256 {
2257     frame().document()-&gt;updateLayoutIgnorePendingStylesheets();
2258 
2259     LayoutRect bounds;
2260     if (RenderElement* renderer = element.renderer())
2261         bounds = renderer-&gt;absoluteAnchorRect();
2262     int centeringOffsetX = (rect.width() - bounds.width()) / 2;
2263     int centeringOffsetY = (rect.height() - bounds.height()) / 2;
2264     setScrollPosition(IntPoint(bounds.x() - centeringOffsetX - rect.x(), bounds.y() - centeringOffsetY - rect.y()));
2265 }
2266 
2267 void FrameView::setScrollPosition(const ScrollPosition&amp; scrollPosition)
2268 {
2269     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::setScrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; , clearing anchor&quot;);
2270 
<a name="31" id="anc31"></a><span class="line-modified">2271     SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true);</span>


2272     m_maintainScrollPositionAnchor = nullptr;
2273     m_shouldScrollToFocusedElement = false;
2274     m_delayedScrollToFocusedElementTimer.stop();
2275     Page* page = frame().page();
2276     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())
2277         scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());
2278     ScrollView::setScrollPosition(scrollPosition);
<a name="32" id="anc32"></a>

2279 }
2280 
2281 void FrameView::resetScrollAnchor()
2282 {
2283     ASSERT(frame().document());
2284     auto&amp; document = *frame().document();
2285 
2286     // If CSS target was set previously, we want to set it to 0, recalc
2287     // and possibly repaint because :target pseudo class may have been
2288     // set (see bug 11321).
2289     document.setCSSTarget(nullptr);
2290 
2291     if (is&lt;SVGDocument&gt;(document)) {
2292         if (auto rootElement = SVGDocument::rootElement(document)) {
2293             // We need to update the layout before resetScrollAnchor(), otherwise we
2294             // could really mess things up if resetting the anchor comes at a bad moment.
2295             document.updateStyleIfNeeded();
2296             rootElement-&gt;resetScrollAnchor();
2297         }
2298     }
2299 }
2300 
2301 void FrameView::scheduleScrollToFocusedElement(SelectionRevealMode selectionRevealMode)
2302 {
2303     if (selectionRevealMode == SelectionRevealMode::DoNotReveal)
2304         return;
2305 
2306     m_selectionRevealModeForFocusedElement = selectionRevealMode;
2307     if (m_shouldScrollToFocusedElement)
2308         return;
2309     m_shouldScrollToFocusedElement = true;
2310     m_delayedScrollToFocusedElementTimer.startOneShot(0_s);
2311 }
2312 
2313 void FrameView::scrollToFocusedElementImmediatelyIfNeeded()
2314 {
2315     if (!m_shouldScrollToFocusedElement)
2316         return;
2317 
2318     m_delayedScrollToFocusedElementTimer.stop();
2319     scrollToFocusedElementInternal();
2320 }
2321 
2322 void FrameView::scrollToFocusedElementTimerFired()
2323 {
2324     auto protectedThis = makeRef(*this);
2325     scrollToFocusedElementInternal();
2326 }
2327 
2328 void FrameView::scrollToFocusedElementInternal()
2329 {
2330     RELEASE_ASSERT(m_shouldScrollToFocusedElement);
2331     auto document = makeRefPtr(frame().document());
2332     if (!document)
2333         return;
2334 
2335     document-&gt;updateLayoutIgnorePendingStylesheets();
2336     if (!m_shouldScrollToFocusedElement)
2337         return; // Updating the layout may have ran scripts.
2338     m_shouldScrollToFocusedElement = false;
2339 
2340     auto focusedElement = makeRefPtr(document-&gt;focusedElement());
2341     if (!focusedElement)
2342         return;
2343     auto updateTarget = focusedElement-&gt;focusAppearanceUpdateTarget();
2344     if (!updateTarget)
2345         return;
2346 
2347     auto* renderer = updateTarget-&gt;renderer();
2348     if (!renderer || renderer-&gt;isWidget())
2349         return;
2350 
2351     bool insideFixed;
2352     LayoutRect absoluteBounds = renderer-&gt;absoluteAnchorRect(&amp;insideFixed);
2353     renderer-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { m_selectionRevealModeForFocusedElement, ScrollAlignment::alignCenterIfNeeded, ScrollAlignment::alignCenterIfNeeded, ShouldAllowCrossOriginScrolling::No });
2354 }
2355 
2356 void FrameView::contentsResized()
2357 {
2358     // For non-delegated scrolling, updateTiledBackingAdaptiveSizing() is called via addedOrRemovedScrollbar() which occurs less often.
2359     if (delegatesScrolling())
2360         updateTiledBackingAdaptiveSizing();
2361 }
2362 
2363 void FrameView::delegatesScrollingDidChange()
2364 {
2365     RenderView* renderView = this-&gt;renderView();
2366     if (!renderView)
2367         return;
2368 
2369     RenderLayerCompositor&amp; compositor = renderView-&gt;compositor();
2370     // When we switch to delegatesScrolling mode, we should destroy the scrolling/clipping layers in RenderLayerCompositor.
2371     if (compositor.usesCompositing()) {
2372         ASSERT(compositor.usesCompositing());
2373         compositor.enableCompositingMode(false);
2374         compositor.clearBackingForAllLayers();
2375     }
2376 }
2377 
2378 #if USE(COORDINATED_GRAPHICS)
2379 void FrameView::setFixedVisibleContentRect(const IntRect&amp; visibleContentRect)
2380 {
2381     bool visibleContentSizeDidChange = false;
2382     if (visibleContentRect.size() != this-&gt;fixedVisibleContentRect().size()) {
2383         // When the viewport size changes or the content is scaled, we need to
2384         // reposition the fixed and sticky positioned elements.
2385         setViewportConstrainedObjectsNeedLayout();
2386         visibleContentSizeDidChange = true;
2387     }
2388 
2389     IntPoint oldPosition = scrollPosition();
2390     ScrollView::setFixedVisibleContentRect(visibleContentRect);
2391     IntPoint newPosition = scrollPosition();
2392     if (oldPosition != newPosition) {
2393         updateLayerPositionsAfterScrolling();
2394         if (frame().settings().acceleratedCompositingForFixedPositionEnabled())
2395             updateCompositingLayersAfterScrolling();
2396         scrollAnimator().setCurrentPosition(newPosition);
2397         scrollPositionChanged(oldPosition, newPosition);
2398     }
2399     if (visibleContentSizeDidChange) {
2400         // Update the scroll-bars to calculate new page-step size.
2401         updateScrollbars(scrollPosition());
2402     }
2403     didChangeScrollOffset();
2404 }
2405 #endif
2406 
2407 void FrameView::setViewportConstrainedObjectsNeedLayout()
2408 {
2409     if (!hasViewportConstrainedObjects())
2410         return;
2411 
2412     for (auto&amp; renderer : *m_viewportConstrainedObjects) {
2413         renderer-&gt;setNeedsLayout();
2414         if (renderer-&gt;hasLayer()) {
2415             auto* layer = downcast&lt;RenderBoxModelObject&gt;(*renderer).layer();
2416             layer-&gt;setNeedsCompositingGeometryUpdate();
2417         }
2418     }
2419 }
2420 
2421 void FrameView::didChangeScrollOffset()
2422 {
2423     if (auto* page = frame().page())
2424         page-&gt;pageOverlayController().didScrollFrame(frame());
2425     frame().loader().client().didChangeScrollOffset();
2426 }
2427 
2428 void FrameView::scrollOffsetChangedViaPlatformWidgetImpl(const ScrollOffset&amp; oldOffset, const ScrollOffset&amp; newOffset)
2429 {
2430     updateLayerPositionsAfterScrolling();
2431     updateCompositingLayersAfterScrolling();
2432     repaintSlowRepaintObjects();
2433     scrollPositionChanged(scrollPositionFromOffset(oldOffset), scrollPositionFromOffset(newOffset));
2434 
2435     if (auto* renderView = this-&gt;renderView()) {
2436         if (renderView-&gt;usesCompositing())
2437             renderView-&gt;compositor().didChangeVisibleRect();
2438     }
2439 }
2440 
2441 // These scroll positions are affected by zooming.
2442 void FrameView::scrollPositionChanged(const ScrollPosition&amp; oldPosition, const ScrollPosition&amp; newPosition)
2443 {
2444     UNUSED_PARAM(oldPosition);
2445     UNUSED_PARAM(newPosition);
2446 
2447     Page* page = frame().page();
2448     Seconds throttlingDelay = page ? page-&gt;chrome().client().eventThrottlingDelay() : 0_s;
2449 
2450     if (throttlingDelay == 0_s) {
2451         m_delayedScrollEventTimer.stop();
2452         sendScrollEvent();
2453     } else if (!m_delayedScrollEventTimer.isActive())
2454         m_delayedScrollEventTimer.startOneShot(throttlingDelay);
2455 
2456     if (RenderView* renderView = this-&gt;renderView()) {
2457         if (renderView-&gt;usesCompositing())
2458             renderView-&gt;compositor().frameViewDidScroll();
2459     }
2460 
2461     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; scrollPositionChanged from &quot; &lt;&lt; oldPosition &lt;&lt; &quot; to &quot; &lt;&lt; newPosition &lt;&lt; &quot; (scale &quot; &lt;&lt; frameScaleFactor() &lt;&lt; &quot; )&quot;);
2462     updateLayoutViewport();
2463     viewportContentsChanged();
2464 }
2465 
2466 void FrameView::applyRecursivelyWithVisibleRect(const WTF::Function&lt;void (FrameView&amp; frameView, const IntRect&amp; visibleRect)&gt;&amp; apply)
2467 {
2468     IntRect windowClipRect = this-&gt;windowClipRect();
2469     auto visibleRect = windowToContents(windowClipRect);
2470     apply(*this, visibleRect);
2471 
2472     // Recursive call for subframes. We cache the current FrameView&#39;s windowClipRect to avoid recomputing it for every subframe.
2473     SetForScope&lt;IntRect*&gt; windowClipRectCache(m_cachedWindowClipRect, &amp;windowClipRect);
2474     for (Frame* childFrame = frame().tree().firstChild(); childFrame; childFrame = childFrame-&gt;tree().nextSibling()) {
2475         if (auto* childView = childFrame-&gt;view())
2476             childView-&gt;applyRecursivelyWithVisibleRect(apply);
2477     }
2478 }
2479 
2480 void FrameView::resumeVisibleImageAnimations(const IntRect&amp; visibleRect)
2481 {
2482     if (visibleRect.isEmpty())
2483         return;
2484 
2485     if (auto* renderView = frame().contentRenderer())
2486         renderView-&gt;resumePausedImageAnimationsIfNeeded(visibleRect);
2487 }
2488 
2489 void FrameView::updateScriptedAnimationsAndTimersThrottlingState(const IntRect&amp; visibleRect)
2490 {
2491     if (frame().isMainFrame())
2492         return;
2493 
2494     auto* document = frame().document();
2495     if (!document)
2496         return;
2497 
2498     // We don&#39;t throttle zero-size or display:none frames because those are usually utility frames.
2499     bool shouldThrottle = visibleRect.isEmpty() &amp;&amp; !m_size.isEmpty() &amp;&amp; frame().ownerRenderer();
2500 
2501     if (auto* scriptedAnimationController = document-&gt;scriptedAnimationController()) {
2502         if (shouldThrottle)
2503             scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::OutsideViewport);
2504         else
2505             scriptedAnimationController-&gt;removeThrottlingReason(ScriptedAnimationController::ThrottlingReason::OutsideViewport);
2506     }
2507 
2508     document-&gt;setTimerThrottlingEnabled(shouldThrottle);
2509 }
2510 
2511 
2512 void FrameView::resumeVisibleImageAnimationsIncludingSubframes()
2513 {
2514     applyRecursivelyWithVisibleRect([] (FrameView&amp; frameView, const IntRect&amp; visibleRect) {
2515         frameView.resumeVisibleImageAnimations(visibleRect);
2516     });
2517 }
2518 
2519 void FrameView::updateLayerPositionsAfterScrolling()
2520 {
2521     // If we&#39;re scrolling as a result of updating the view size after layout, we&#39;ll update widgets and layer positions soon anyway.
2522     if (layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::InViewSizeAdjust)
2523         return;
2524 
2525     if (!layoutContext().isLayoutNested() &amp;&amp; hasViewportConstrainedObjects()) {
2526         if (RenderView* renderView = this-&gt;renderView()) {
2527             updateWidgetPositions();
2528             renderView-&gt;layer()-&gt;updateLayerPositionsAfterDocumentScroll();
2529         }
2530     }
2531 }
2532 
2533 bool FrameView::shouldUpdateCompositingLayersAfterScrolling() const
2534 {
2535 #if ENABLE(ASYNC_SCROLLING)
2536     // If the scrolling thread is updating the fixed elements, then the FrameView should not update them as well.
2537 
2538     Page* page = frame().page();
2539     if (!page)
2540         return true;
2541 
2542     if (&amp;page-&gt;mainFrame() != m_frame.ptr())
2543         return true;
2544 
2545     ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator();
2546     if (!scrollingCoordinator)
2547         return true;
2548 
2549     if (scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
2550         return true;
2551 
<a name="33" id="anc33"></a><span class="line-modified">2552     if (inProgrammaticScroll())</span>
2553         return true;
2554 
2555     return false;
2556 #endif
2557     return true;
2558 }
2559 
2560 void FrameView::updateCompositingLayersAfterScrolling()
2561 {
2562     ASSERT(layoutContext().layoutPhase() &gt;= FrameViewLayoutContext::LayoutPhase::InPostLayout || layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::OutsideLayout);
2563 
2564     if (!shouldUpdateCompositingLayersAfterScrolling())
2565         return;
2566 
2567     if (!layoutContext().isLayoutNested() &amp;&amp; hasViewportConstrainedObjects()) {
2568         if (RenderView* renderView = this-&gt;renderView())
2569             renderView-&gt;compositor().updateCompositingLayers(CompositingUpdateType::OnScroll);
2570     }
2571 }
2572 
2573 bool FrameView::isRubberBandInProgress() const
2574 {
2575     if (scrollbarsSuppressed())
2576         return false;
2577 
2578     // If the scrolling thread updates the scroll position for this FrameView, then we should return
2579     // ScrollingCoordinator::isRubberBandInProgress().
2580     if (Page* page = frame().page()) {
2581         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator()) {
2582             if (!scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
2583                 return scrollingCoordinator-&gt;isRubberBandInProgress();
2584         }
2585     }
2586 
2587     // If the main thread updates the scroll position for this FrameView, we should return
2588     // ScrollAnimator::isRubberBandInProgress().
2589     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
2590         return scrollAnimator-&gt;isRubberBandInProgress();
2591 
2592     return false;
2593 }
2594 
2595 bool FrameView::requestScrollPositionUpdate(const ScrollPosition&amp; position)
2596 {
2597     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::requestScrollPositionUpdate &quot; &lt;&lt; position);
2598 
2599 #if ENABLE(ASYNC_SCROLLING)
2600     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
2601         tiledBacking-&gt;prepopulateRect(FloatRect(position, visibleContentRect().size()));
2602 #endif
2603 
2604 #if ENABLE(ASYNC_SCROLLING) || USE(COORDINATED_GRAPHICS)
2605     if (Page* page = frame().page()) {
2606         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
2607             return scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, position);
2608     }
2609 #else
2610     UNUSED_PARAM(position);
2611 #endif
2612 
2613     return false;
2614 }
2615 
2616 HostWindow* FrameView::hostWindow() const
2617 {
2618     auto* page = frame().page();
2619     if (!page)
2620         return nullptr;
2621     return &amp;page-&gt;chrome();
2622 }
2623 
2624 void FrameView::addTrackedRepaintRect(const FloatRect&amp; r)
2625 {
2626     if (!m_isTrackingRepaints || r.isEmpty())
2627         return;
2628 
2629     FloatRect repaintRect = r;
2630     repaintRect.moveBy(-scrollPosition());
2631     m_trackedRepaintRects.append(repaintRect);
2632 }
2633 
2634 void FrameView::repaintContentRectangle(const IntRect&amp; r)
2635 {
2636     ASSERT(!frame().ownerElement());
2637 
2638     if (!shouldUpdate())
2639         return;
2640 
2641     ScrollView::repaintContentRectangle(r);
2642 }
2643 
2644 static unsigned countRenderedCharactersInRenderObjectWithThreshold(const RenderElement&amp; renderer, unsigned threshold)
2645 {
2646     unsigned count = 0;
2647     for (const RenderObject* descendant = &amp;renderer; descendant; descendant = descendant-&gt;nextInPreOrder()) {
2648         if (is&lt;RenderText&gt;(*descendant)) {
2649             count += downcast&lt;RenderText&gt;(*descendant).text().length();
2650             if (count &gt;= threshold)
2651                 break;
2652         }
2653     }
2654     return count;
2655 }
2656 
2657 bool FrameView::renderedCharactersExceed(unsigned threshold)
2658 {
2659     if (!frame().contentRenderer())
2660         return false;
2661     return countRenderedCharactersInRenderObjectWithThreshold(*frame().contentRenderer(), threshold) &gt;= threshold;
2662 }
2663 
2664 void FrameView::availableContentSizeChanged(AvailableSizeChangeReason reason)
2665 {
2666     if (Document* document = frame().document()) {
2667         // FIXME: Merge this logic with m_setNeedsLayoutWasDeferred and find a more appropriate
2668         // way of handling potential recursive layouts when the viewport is resized to accomodate
2669         // the content but the content always overflows the viewport. See webkit.org/b/165781.
2670         if (!(layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::InViewSizeAdjust &amp;&amp; useFixedLayout()))
2671             document-&gt;updateViewportUnitsOnResize();
2672     }
2673 
2674     updateLayoutViewport();
2675     setNeedsLayoutAfterViewConfigurationChange();
2676     ScrollView::availableContentSizeChanged(reason);
2677 }
2678 
2679 bool FrameView::shouldLayoutAfterContentsResized() const
2680 {
2681     return !useFixedLayout() || useCustomFixedPositionLayoutRect();
2682 }
2683 
2684 void FrameView::updateContentsSize()
2685 {
2686     // We check to make sure the view is attached to a frame() as this method can
2687     // be triggered before the view is attached by Frame::createView(...) setting
2688     // various values such as setScrollBarModes(...) for example.  An ASSERT is
2689     // triggered when a view is layout before being attached to a frame().
2690     if (!frame().view())
2691         return;
2692 
2693 #if PLATFORM(IOS_FAMILY)
2694     if (RenderView* root = m_frame-&gt;contentRenderer()) {
2695         if (useCustomFixedPositionLayoutRect() &amp;&amp; hasViewportConstrainedObjects()) {
2696             setViewportConstrainedObjectsNeedLayout();
2697             // We must eagerly enter compositing mode because fixed position elements
2698             // will not have been made compositing via a preceding style change before
2699             // m_useCustomFixedPositionLayoutRect was true.
2700             root-&gt;compositor().enableCompositingMode();
2701         }
2702     }
2703 #endif
2704 
2705     if (shouldLayoutAfterContentsResized() &amp;&amp; needsLayout())
2706         layoutContext().layout();
2707 
2708     if (RenderView* renderView = this-&gt;renderView()) {
2709         if (renderView-&gt;usesCompositing())
2710             renderView-&gt;compositor().frameViewDidChangeSize();
2711     }
2712 }
2713 
2714 void FrameView::addedOrRemovedScrollbar()
2715 {
2716     if (RenderView* renderView = this-&gt;renderView()) {
2717         if (renderView-&gt;usesCompositing())
2718             renderView-&gt;compositor().frameViewDidAddOrRemoveScrollbars();
2719     }
2720 
2721     updateTiledBackingAdaptiveSizing();
2722 }
2723 
2724 TiledBacking::Scrollability FrameView::computeScrollability() const
2725 {
2726     auto* page = frame().page();
2727 
2728     // Use smaller square tiles if the Window is not active to facilitate app napping.
2729     if (!page || !page-&gt;isWindowActive())
2730         return TiledBacking::HorizontallyScrollable | TiledBacking::VerticallyScrollable;
2731 
2732     bool horizontallyScrollable;
2733     bool verticallyScrollable;
2734     bool clippedByAncestorView = static_cast&lt;bool&gt;(m_viewExposedRect);
2735 
2736 #if PLATFORM(IOS_FAMILY)
2737     if (page)
2738         clippedByAncestorView |= page-&gt;enclosedInScrollableAncestorView();
2739 #endif
2740 
2741     if (delegatesScrolling()) {
2742         IntSize documentSize = contentsSize();
2743         IntSize visibleSize = this-&gt;visibleSize();
2744 
2745         horizontallyScrollable = clippedByAncestorView || documentSize.width() &gt; visibleSize.width();
2746         verticallyScrollable = clippedByAncestorView || documentSize.height() &gt; visibleSize.height();
2747     } else {
2748         horizontallyScrollable = clippedByAncestorView || horizontalScrollbar();
2749         verticallyScrollable = clippedByAncestorView || verticalScrollbar();
2750     }
2751 
2752     TiledBacking::Scrollability scrollability = TiledBacking::NotScrollable;
2753     if (horizontallyScrollable)
2754         scrollability = TiledBacking::HorizontallyScrollable;
2755 
2756     if (verticallyScrollable)
2757         scrollability |= TiledBacking::VerticallyScrollable;
2758 
2759     return scrollability;
2760 }
2761 
2762 void FrameView::updateTiledBackingAdaptiveSizing()
2763 {
2764     auto* tiledBacking = this-&gt;tiledBacking();
2765     if (!tiledBacking)
2766         return;
2767 
2768     tiledBacking-&gt;setScrollability(computeScrollability());
2769 }
2770 
<a name="34" id="anc34"></a><span class="line-modified">2771 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">2772 </span>
<span class="line-removed">2773 void FrameView::didUpdateViewportOverrideRects()</span>
2774 {
2775     if (!frame().settings().visualViewportAPIEnabled())
2776         return;
2777 
2778     if (auto* window = frame().window())
2779         window-&gt;visualViewport().update();
<a name="35" id="anc35"></a>




2780 }
2781 
<a name="36" id="anc36"></a>

2782 void FrameView::unobscuredContentSizeChanged()
2783 {
2784     updateTiledBackingAdaptiveSizing();
2785 }
2786 
2787 #endif
2788 
2789 static LayerFlushThrottleState::Flags determineLayerFlushThrottleState(Page&amp; page)
2790 {
2791     // We only throttle when constantly receiving new data during the inital page load.
2792     if (!page.progress().isMainLoadProgressing())
2793         return 0;
2794     // Scrolling during page loading disables throttling.
2795     if (page.mainFrame().view()-&gt;wasScrolledByUser())
2796         return 0;
2797     // Disable for image documents so large GIF animations don&#39;t get throttled during loading.
2798     auto* document = page.mainFrame().document();
2799     if (!document || is&lt;ImageDocument&gt;(*document))
2800         return 0;
2801     return LayerFlushThrottleState::Enabled;
2802 }
2803 
2804 void FrameView::disableLayerFlushThrottlingTemporarilyForInteraction()
2805 {
2806     if (!frame().page())
2807         return;
2808     auto&amp; page = *frame().page();
2809 
2810     LayerFlushThrottleState::Flags flags = LayerFlushThrottleState::UserIsInteracting | determineLayerFlushThrottleState(page);
2811     if (page.chrome().client().adjustLayerFlushThrottling(flags))
2812         return;
2813 
2814     if (RenderView* view = renderView())
2815         view-&gt;compositor().disableLayerFlushThrottlingTemporarilyForInteraction();
2816 }
2817 
2818 void FrameView::loadProgressingStatusChanged()
2819 {
2820     if (!m_isVisuallyNonEmpty &amp;&amp; frame().loader().isComplete())
2821         fireLayoutRelatedMilestonesIfNeeded();
2822     updateLayerFlushThrottling();
2823     adjustTiledBackingCoverage();
2824 }
2825 
2826 void FrameView::updateLayerFlushThrottling()
2827 {
2828     Page* page = frame().page();
2829     if (!page)
2830         return;
2831 
2832     ASSERT(frame().isMainFrame());
2833 
2834     LayerFlushThrottleState::Flags flags = determineLayerFlushThrottleState(*page);
2835 
2836     // See if the client is handling throttling.
2837     if (page-&gt;chrome().client().adjustLayerFlushThrottling(flags))
2838         return;
2839 
2840     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
2841         if (RenderView* renderView = frame-&gt;contentRenderer())
2842             renderView-&gt;compositor().setLayerFlushThrottlingEnabled(flags &amp; LayerFlushThrottleState::Enabled);
2843     }
2844 }
2845 
2846 void FrameView::adjustTiledBackingCoverage()
2847 {
2848     if (!m_speculativeTilingEnabled)
2849         enableSpeculativeTilingIfNeeded();
2850 
2851     RenderView* renderView = this-&gt;renderView();
2852     if (renderView &amp;&amp; renderView-&gt;layer() &amp;&amp; renderView-&gt;layer()-&gt;backing())
2853         renderView-&gt;layer()-&gt;backing()-&gt;adjustTiledBackingCoverage();
2854 #if PLATFORM(IOS_FAMILY)
2855     if (LegacyTileCache* tileCache = legacyTileCache())
2856         tileCache-&gt;setSpeculativeTileCreationEnabled(m_speculativeTilingEnabled);
2857 #endif
2858 }
2859 
2860 static bool shouldEnableSpeculativeTilingDuringLoading(const FrameView&amp; view)
2861 {
2862     Page* page = view.frame().page();
2863     return page &amp;&amp; view.isVisuallyNonEmpty() &amp;&amp; !page-&gt;progress().isMainLoadProgressing();
2864 }
2865 
2866 void FrameView::enableSpeculativeTilingIfNeeded()
2867 {
2868     ASSERT(!m_speculativeTilingEnabled);
2869     if (m_wasScrolledByUser) {
2870         m_speculativeTilingEnabled = true;
2871         return;
2872     }
2873     if (!shouldEnableSpeculativeTilingDuringLoading(*this))
2874         return;
2875 
2876     if (m_speculativeTilingDelayDisabledForTesting) {
2877         speculativeTilingEnableTimerFired();
2878         return;
2879     }
2880 
2881     if (m_speculativeTilingEnableTimer.isActive())
2882         return;
2883     // Delay enabling a bit as load completion may trigger further loading from scripts.
2884     static const Seconds speculativeTilingEnableDelay { 500_ms };
2885     m_speculativeTilingEnableTimer.startOneShot(speculativeTilingEnableDelay);
2886 }
2887 
2888 void FrameView::speculativeTilingEnableTimerFired()
2889 {
2890     if (m_speculativeTilingEnabled)
2891         return;
2892     m_speculativeTilingEnabled = shouldEnableSpeculativeTilingDuringLoading(*this);
2893     adjustTiledBackingCoverage();
2894 }
2895 
2896 void FrameView::show()
2897 {
2898     ScrollView::show();
2899 
2900     if (frame().isMainFrame()) {
2901         // Turn off speculative tiling for a brief moment after a FrameView appears on screen.
2902         // Note that adjustTiledBackingCoverage() kicks the (500ms) timer to re-enable it.
2903         m_speculativeTilingEnabled = false;
2904         m_wasScrolledByUser = false;
2905         adjustTiledBackingCoverage();
2906     }
2907 }
2908 
2909 void FrameView::hide()
2910 {
2911     ScrollView::hide();
2912     adjustTiledBackingCoverage();
2913 }
2914 
2915 bool FrameView::needsLayout() const
2916 {
2917     return layoutContext().needsLayout();
2918 }
2919 
2920 void FrameView::setNeedsLayoutAfterViewConfigurationChange()
2921 {
2922     layoutContext().setNeedsLayoutAfterViewConfigurationChange();
2923 }
2924 
2925 void FrameView::setNeedsCompositingConfigurationUpdate()
2926 {
2927     RenderView* renderView = this-&gt;renderView();
<a name="37" id="anc37"></a><span class="line-modified">2928     if (renderView-&gt;usesCompositing()) {</span>
2929         if (auto* rootLayer = renderView-&gt;layer())
2930             rootLayer-&gt;setNeedsCompositingConfigurationUpdate();
2931         renderView-&gt;compositor().scheduleCompositingLayerUpdate();
2932     }
2933 }
2934 
2935 void FrameView::setNeedsCompositingGeometryUpdate()
2936 {
2937     RenderView* renderView = this-&gt;renderView();
2938     if (renderView-&gt;usesCompositing()) {
2939         if (auto* rootLayer = renderView-&gt;layer())
2940             rootLayer-&gt;setNeedsCompositingGeometryUpdate();
2941         renderView-&gt;compositor().scheduleCompositingLayerUpdate();
2942     }
2943 }
2944 
2945 void FrameView::scheduleSelectionUpdate()
2946 {
2947     if (needsLayout())
2948         return;
2949     // FIXME: We should not need to go through the layout process since selection update does not change dimension/geometry.
2950     // However we can&#39;t tell at this point if the tree is stable yet, so let&#39;s just schedule a root only layout for now.
2951     setNeedsLayoutAfterViewConfigurationChange();
2952 }
2953 
2954 bool FrameView::isTransparent() const
2955 {
2956     return m_isTransparent;
2957 }
2958 
2959 void FrameView::setTransparent(bool isTransparent)
2960 {
2961     if (m_isTransparent == isTransparent)
2962         return;
2963 
2964     m_isTransparent = isTransparent;
2965 
2966     // setTransparent can be called in the window between FrameView initialization
2967     // and switching in the new Document; this means that the RenderView that we
2968     // retrieve is actually attached to the previous Document, which is going away,
2969     // and must not update compositing layers.
2970     if (!isViewForDocumentInFrame())
2971         return;
2972 
2973     setNeedsLayoutAfterViewConfigurationChange();
2974     setNeedsCompositingConfigurationUpdate();
2975 }
2976 
2977 bool FrameView::hasOpaqueBackground() const
2978 {
2979     return !m_isTransparent &amp;&amp; m_baseBackgroundColor.isOpaque();
2980 }
2981 
2982 Color FrameView::baseBackgroundColor() const
2983 {
2984     return m_baseBackgroundColor;
2985 }
2986 
2987 void FrameView::setBaseBackgroundColor(const Color&amp; backgroundColor)
2988 {
<a name="38" id="anc38"></a><span class="line-modified">2989     m_baseBackgroundColor = backgroundColor.isValid() ? backgroundColor : Color::white;</span>




2990 
2991     if (!isViewForDocumentInFrame())
2992         return;
2993 
2994     recalculateScrollbarOverlayStyle();
2995     setNeedsLayoutAfterViewConfigurationChange();
2996     setNeedsCompositingConfigurationUpdate();
2997 }
2998 
2999 void FrameView::updateBackgroundRecursively(const Optional&lt;Color&gt;&amp; backgroundColor)
3000 {
<a name="39" id="anc39"></a><span class="line-modified">3001 #if ENABLE(DARK_MODE_CSS) &amp;&amp; PLATFORM(MAC)</span>
3002     Color baseBackgroundColor = backgroundColor.valueOr(RenderTheme::singleton().systemColor(CSSValueAppleSystemControlBackground, styleColorOptions()));
3003 #else
3004     Color baseBackgroundColor = backgroundColor.valueOr(Color::white);
3005 #endif
3006 
3007     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
3008         if (FrameView* view = frame-&gt;view()) {
3009             view-&gt;setTransparent(!baseBackgroundColor.isVisible());
3010             view-&gt;setBaseBackgroundColor(baseBackgroundColor);
3011             if (view-&gt;needsLayout())
3012                 view-&gt;layoutContext().scheduleLayout();
3013         }
3014     }
3015 }
3016 
3017 bool FrameView::hasExtendedBackgroundRectForPainting() const
3018 {
3019     TiledBacking* tiledBacking = this-&gt;tiledBacking();
3020     if (!tiledBacking)
3021         return false;
3022 
3023     return tiledBacking-&gt;hasMargins();
3024 }
3025 
3026 void FrameView::updateExtendBackgroundIfNecessary()
3027 {
3028     ExtendedBackgroundMode mode = calculateExtendedBackgroundMode();
3029     if (mode == ExtendedBackgroundModeNone)
3030         return;
3031 
3032     updateTilesForExtendedBackgroundMode(mode);
3033 }
3034 
3035 FrameView::ExtendedBackgroundMode FrameView::calculateExtendedBackgroundMode() const
3036 {
3037 #if PLATFORM(IOS_FAMILY)
3038     // &lt;rdar://problem/16201373&gt;
3039     return ExtendedBackgroundModeNone;
3040 #else
3041     if (!frame().settings().backgroundShouldExtendBeyondPage())
3042         return ExtendedBackgroundModeNone;
3043 
3044     // Just because Settings::backgroundShouldExtendBeyondPage() is true does not necessarily mean
3045     // that the background rect needs to be extended for painting. Simple backgrounds can be extended
3046     // just with RenderLayerCompositor&#39;s rootExtendedBackgroundColor. More complicated backgrounds,
3047     // such as images, require extending the background rect to continue painting into the extended
3048     // region. This function finds out if it is necessary to extend the background rect for painting.
3049 
3050     if (!frame().isMainFrame())
3051         return ExtendedBackgroundModeNone;
3052 
3053     Document* document = frame().document();
3054     if (!document)
3055         return ExtendedBackgroundModeNone;
3056 
3057     if (!renderView())
3058         return ExtendedBackgroundModeNone;
3059 
3060     auto* rootBackgroundRenderer = renderView()-&gt;rendererForRootBackground();
3061     if (!rootBackgroundRenderer)
3062         return ExtendedBackgroundModeNone;
3063 
3064     if (!rootBackgroundRenderer-&gt;style().hasBackgroundImage())
3065         return ExtendedBackgroundModeNone;
3066 
3067     ExtendedBackgroundMode mode = ExtendedBackgroundModeNone;
3068     if (rootBackgroundRenderer-&gt;style().backgroundRepeatX() == FillRepeat::Repeat)
3069         mode |= ExtendedBackgroundModeHorizontal;
3070     if (rootBackgroundRenderer-&gt;style().backgroundRepeatY() == FillRepeat::Repeat)
3071         mode |= ExtendedBackgroundModeVertical;
3072 
3073     return mode;
3074 #endif
3075 }
3076 
3077 void FrameView::updateTilesForExtendedBackgroundMode(ExtendedBackgroundMode mode)
3078 {
3079     RenderView* renderView = this-&gt;renderView();
3080     if (!renderView)
3081         return;
3082 
3083     RenderLayerBacking* backing = renderView-&gt;layer()-&gt;backing();
3084     if (!backing)
3085         return;
3086 
3087     TiledBacking* tiledBacking = backing-&gt;tiledBacking();
3088     if (!tiledBacking)
3089         return;
3090 
3091     ExtendedBackgroundMode existingMode = ExtendedBackgroundModeNone;
3092     if (tiledBacking-&gt;hasVerticalMargins())
3093         existingMode |= ExtendedBackgroundModeVertical;
3094     if (tiledBacking-&gt;hasHorizontalMargins())
3095         existingMode |= ExtendedBackgroundModeHorizontal;
3096 
3097     if (existingMode == mode)
3098         return;
3099 
3100     backing-&gt;setTiledBackingHasMargins(mode &amp; ExtendedBackgroundModeHorizontal, mode &amp; ExtendedBackgroundModeVertical);
3101 }
3102 
3103 IntRect FrameView::extendedBackgroundRectForPainting() const
3104 {
3105     TiledBacking* tiledBacking = this-&gt;tiledBacking();
3106     if (!tiledBacking)
3107         return IntRect();
3108 
3109     RenderView* renderView = this-&gt;renderView();
3110     if (!renderView)
3111         return IntRect();
3112 
3113     LayoutRect extendedRect = renderView-&gt;unextendedBackgroundRect();
3114     if (!tiledBacking-&gt;hasMargins())
3115         return snappedIntRect(extendedRect);
3116 
3117     extendedRect.moveBy(LayoutPoint(-tiledBacking-&gt;leftMarginWidth(), -tiledBacking-&gt;topMarginHeight()));
3118     extendedRect.expand(LayoutSize(tiledBacking-&gt;leftMarginWidth() + tiledBacking-&gt;rightMarginWidth(), tiledBacking-&gt;topMarginHeight() + tiledBacking-&gt;bottomMarginHeight()));
3119     return snappedIntRect(extendedRect);
3120 }
3121 
3122 bool FrameView::shouldUpdateWhileOffscreen() const
3123 {
3124     return m_shouldUpdateWhileOffscreen;
3125 }
3126 
3127 void FrameView::setShouldUpdateWhileOffscreen(bool shouldUpdateWhileOffscreen)
3128 {
3129     m_shouldUpdateWhileOffscreen = shouldUpdateWhileOffscreen;
3130 }
3131 
3132 bool FrameView::shouldUpdate() const
3133 {
3134     if (isOffscreen() &amp;&amp; !shouldUpdateWhileOffscreen())
3135         return false;
3136     return true;
3137 }
3138 
3139 bool FrameView::safeToPropagateScrollToParent() const
3140 {
3141     auto* document = frame().document();
3142     if (!document)
3143         return false;
3144 
3145     auto* parentFrame = frame().tree().parent();
3146     if (!parentFrame)
3147         return false;
3148 
3149     auto* parentDocument = parentFrame-&gt;document();
3150     if (!parentDocument)
3151         return false;
3152 
3153     return document-&gt;securityOrigin().canAccess(parentDocument-&gt;securityOrigin());
3154 }
3155 
3156 void FrameView::scrollToAnchor()
3157 {
3158     RefPtr&lt;ContainerNode&gt; anchorNode = m_maintainScrollPositionAnchor;
3159 
3160     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::scrollToAnchor() &quot; &lt;&lt; anchorNode.get());
3161 
3162     if (!anchorNode)
3163         return;
3164 
3165     if (!anchorNode-&gt;renderer())
3166         return;
3167     m_shouldScrollToFocusedElement = false;
3168     m_delayedScrollToFocusedElementTimer.stop();
3169 
3170     LayoutRect rect;
3171     bool insideFixed = false;
3172     if (anchorNode != frame().document() &amp;&amp; anchorNode-&gt;renderer())
3173         rect = anchorNode-&gt;renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
3174 
3175     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot; anchor node rect &quot; &lt;&lt; rect);
3176 
3177     // Scroll nested layers and frames to reveal the anchor.
3178     // Align to the top and to the closest side (this matches other browsers).
3179     if (anchorNode-&gt;renderer()-&gt;style().isHorizontalWritingMode())
3180         anchorNode-&gt;renderer()-&gt;scrollRectToVisible(rect, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignTopAlways, ShouldAllowCrossOriginScrolling::No });
3181     else if (anchorNode-&gt;renderer()-&gt;style().isFlippedBlocksWritingMode())
3182         anchorNode-&gt;renderer()-&gt;scrollRectToVisible(rect, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignRightAlways, ScrollAlignment::alignToEdgeIfNeeded, ShouldAllowCrossOriginScrolling::No });
3183     else
3184         anchorNode-&gt;renderer()-&gt;scrollRectToVisible(rect, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignLeftAlways, ScrollAlignment::alignToEdgeIfNeeded, ShouldAllowCrossOriginScrolling::No });
3185 
3186     if (AXObjectCache* cache = frame().document()-&gt;existingAXObjectCache())
3187         cache-&gt;handleScrolledToAnchor(anchorNode.get());
3188 
3189     // scrollRectToVisible can call into setScrollPosition(), which resets m_maintainScrollPositionAnchor.
3190     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot; restoring anchor node to &quot; &lt;&lt; anchorNode.get());
3191     m_maintainScrollPositionAnchor = anchorNode;
3192     m_shouldScrollToFocusedElement = false;
3193     m_delayedScrollToFocusedElementTimer.stop();
3194 }
3195 
3196 void FrameView::updateEmbeddedObject(RenderEmbeddedObject&amp; embeddedObject)
3197 {
3198     // No need to update if it&#39;s already crashed or known to be missing.
3199     if (embeddedObject.isPluginUnavailable())
3200         return;
3201 
3202     HTMLFrameOwnerElement&amp; element = embeddedObject.frameOwnerElement();
3203 
3204     if (embeddedObject.isSnapshottedPlugIn()) {
3205         if (is&lt;HTMLObjectElement&gt;(element) || is&lt;HTMLEmbedElement&gt;(element)) {
3206             HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
3207             pluginElement.checkSnapshotStatus();
3208         }
3209         return;
3210     }
3211 
3212     auto weakRenderer = makeWeakPtr(embeddedObject);
3213 
3214     // FIXME: This could turn into a real virtual dispatch if we defined
3215     // updateWidget(PluginCreationOption) on HTMLElement.
3216     if (is&lt;HTMLPlugInImageElement&gt;(element)) {
3217         HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
3218         if (pluginElement.needsCheckForSizeChange()) {
3219             pluginElement.checkSnapshotStatus();
3220             return;
3221         }
3222         if (pluginElement.needsWidgetUpdate())
3223             pluginElement.updateWidget(CreatePlugins::Yes);
3224     } else
3225         ASSERT_NOT_REACHED();
3226 
3227     // It&#39;s possible the renderer was destroyed below updateWidget() since loading a plugin may execute arbitrary JavaScript.
3228     if (!weakRenderer)
3229         return;
3230 
3231     auto ignoreWidgetState = embeddedObject.updateWidgetPosition();
3232     UNUSED_PARAM(ignoreWidgetState);
3233 }
3234 
3235 bool FrameView::updateEmbeddedObjects()
3236 {
3237     if (layoutContext().isLayoutNested() || !m_embeddedObjectsToUpdate || m_embeddedObjectsToUpdate-&gt;isEmpty())
3238         return true;
3239 
3240     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
3241 
3242     // Insert a marker for where we should stop.
3243     ASSERT(!m_embeddedObjectsToUpdate-&gt;contains(nullptr));
3244     m_embeddedObjectsToUpdate-&gt;add(nullptr);
3245 
3246     while (!m_embeddedObjectsToUpdate-&gt;isEmpty()) {
3247         RenderEmbeddedObject* embeddedObject = m_embeddedObjectsToUpdate-&gt;takeFirst();
3248         if (!embeddedObject)
3249             break;
3250         updateEmbeddedObject(*embeddedObject);
3251     }
3252 
3253     return m_embeddedObjectsToUpdate-&gt;isEmpty();
3254 }
3255 
3256 void FrameView::updateEmbeddedObjectsTimerFired()
3257 {
3258     RefPtr&lt;FrameView&gt; protectedThis(this);
3259     m_updateEmbeddedObjectsTimer.stop();
3260     for (unsigned i = 0; i &lt; maxUpdateEmbeddedObjectsIterations; i++) {
3261         if (updateEmbeddedObjects())
3262             break;
3263     }
3264 }
3265 
3266 void FrameView::flushAnyPendingPostLayoutTasks()
3267 {
3268     layoutContext().flushAsynchronousTasks();
3269     if (m_updateEmbeddedObjectsTimer.isActive())
3270         updateEmbeddedObjectsTimerFired();
3271 }
3272 
3273 void FrameView::queuePostLayoutCallback(Function&lt;void()&gt;&amp;&amp; callback)
3274 {
3275     m_postLayoutCallbackQueue.append(WTFMove(callback));
3276 }
3277 
3278 void FrameView::flushPostLayoutTasksQueue()
3279 {
3280     if (layoutContext().isLayoutNested())
3281         return;
3282 
3283     if (!m_postLayoutCallbackQueue.size())
3284         return;
3285 
3286     Vector&lt;Function&lt;void()&gt;&gt; queue = WTFMove(m_postLayoutCallbackQueue);
3287     for (auto&amp; task : queue)
3288         task();
3289 }
3290 
3291 void FrameView::performPostLayoutTasks()
3292 {
3293     // FIXME: We should not run any JavaScript code in this function.
3294     LOG(Layout, &quot;FrameView %p performPostLayoutTasks&quot;, this);
3295     updateHasReachedSignificantRenderedTextThreshold();
3296     frame().selection().updateAppearanceAfterLayout();
3297 
3298     flushPostLayoutTasksQueue();
3299 
3300     if (!layoutContext().isLayoutNested() &amp;&amp; frame().document()-&gt;documentElement())
3301         fireLayoutRelatedMilestonesIfNeeded();
3302 
3303 #if PLATFORM(IOS_FAMILY)
3304     // Only send layout-related delegate callbacks synchronously for the main frame to
3305     // avoid re-entering layout for the main frame while delivering a layout-related delegate
3306     // callback for a subframe.
3307     if (frame().isMainFrame()) {
3308         if (Page* page = frame().page())
3309             page-&gt;chrome().client().didLayout();
3310     }
3311 #endif
3312 
3313     // FIXME: We should consider adding DidLayout as a LayoutMilestone. That would let us merge this
3314     // with didLayout(LayoutMilestones).
3315     frame().loader().client().dispatchDidLayout();
3316 
3317     updateWidgetPositions();
3318 
3319 #if ENABLE(CSS_SCROLL_SNAP)
3320     updateSnapOffsets();
3321 #endif
3322     m_updateEmbeddedObjectsTimer.startOneShot(0_s);
3323 
3324     if (auto* page = frame().page()) {
3325         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
3326             scrollingCoordinator-&gt;frameViewLayoutUpdated(*this);
3327     }
3328 
3329     if (RenderView* renderView = this-&gt;renderView()) {
3330         if (renderView-&gt;usesCompositing())
3331             renderView-&gt;compositor().frameViewDidLayout();
3332     }
3333 
3334     scrollToAnchor();
3335 
3336     sendResizeEventIfNeeded();
3337 
3338     updateLayoutViewport();
3339     viewportContentsChanged();
3340 
3341     updateScrollSnapState();
3342 
3343     if (AXObjectCache* cache = frame().document()-&gt;existingAXObjectCache())
3344         cache-&gt;performDeferredCacheUpdate();
3345 }
3346 
3347 IntSize FrameView::sizeForResizeEvent() const
3348 {
3349 #if PLATFORM(IOS_FAMILY)
3350     if (m_useCustomSizeForResizeEvent)
3351         return m_customSizeForResizeEvent;
3352 #endif
3353     if (useFixedLayout() &amp;&amp; !fixedLayoutSize().isEmpty() &amp;&amp; delegatesScrolling())
3354         return fixedLayoutSize();
3355     return visibleContentRectIncludingScrollbars().size();
3356 }
3357 
3358 void FrameView::sendResizeEventIfNeeded()
3359 {
3360     if (layoutContext().isInRenderTreeLayout() || needsLayout())
3361         return;
3362 
3363     RenderView* renderView = this-&gt;renderView();
3364     if (!renderView || renderView-&gt;printing())
3365         return;
3366 
3367     if (frame().page() &amp;&amp; frame().page()-&gt;chrome().client().isSVGImageChromeClient())
3368         return;
3369 
3370     IntSize currentSize = sizeForResizeEvent();
3371     float currentZoomFactor = renderView-&gt;style().zoom();
3372 
3373     if (currentSize == m_lastViewportSize &amp;&amp; currentZoomFactor == m_lastZoomFactor)
3374         return;
3375 
3376     m_lastViewportSize = currentSize;
3377     m_lastZoomFactor = currentZoomFactor;
3378 
3379     if (!layoutContext().didFirstLayout())
3380         return;
3381 
3382 #if PLATFORM(IOS_FAMILY)
3383     // Don&#39;t send the resize event if the document is loading. Some pages automatically reload
3384     // when the window is resized; Safari on iOS often resizes the window while setting up its
3385     // viewport. This obviously can cause problems.
3386     if (DocumentLoader* documentLoader = frame().loader().documentLoader()) {
3387         if (documentLoader-&gt;isLoadingInAPISense())
3388             return;
3389     }
3390 #endif
3391 
3392     bool isMainFrame = frame().isMainFrame();
3393     bool canSendResizeEventSynchronously = isMainFrame &amp;&amp; !m_shouldAutoSize;
3394 
3395     LOG(Events, &quot;FrameView %p sendResizeEventIfNeeded sending resize event, size %dx%d (canSendResizeEventSynchronously %d)&quot;, this, currentSize.width(), currentSize.height(), canSendResizeEventSynchronously);
3396 
3397     Ref&lt;Event&gt; resizeEvent = Event::create(eventNames().resizeEvent, Event::CanBubble::No, Event::IsCancelable::No);
3398     if (canSendResizeEventSynchronously)
3399         frame().document()-&gt;dispatchWindowEvent(resizeEvent);
3400     else {
3401         // FIXME: Queueing this event for an unpredictable time in the future seems
3402         // intrinsically racy. By the time this resize event fires, the frame might
3403         // be resized again, so we could end up with two resize events for the same size.
3404         frame().document()-&gt;enqueueWindowEvent(WTFMove(resizeEvent));
3405     }
3406 
3407     if (InspectorInstrumentation::hasFrontends() &amp;&amp; isMainFrame) {
3408         if (Page* page = frame().page()) {
3409             if (InspectorClient* inspectorClient = page-&gt;inspectorController().inspectorClient())
3410                 inspectorClient-&gt;didResizeMainFrame(&amp;frame());
3411         }
3412     }
3413 }
3414 
3415 void FrameView::willStartLiveResize()
3416 {
3417     ScrollView::willStartLiveResize();
3418     adjustTiledBackingCoverage();
3419 }
3420 
3421 void FrameView::willEndLiveResize()
3422 {
3423     ScrollView::willEndLiveResize();
3424     adjustTiledBackingCoverage();
3425 }
3426 
3427 void FrameView::autoSizeIfEnabled()
3428 {
3429     if (!m_shouldAutoSize)
3430         return;
3431 
3432     if (m_inAutoSize)
3433         return;
3434 
3435     auto* document = frame().document();
3436     if (!document)
3437         return;
3438 
3439     auto* renderView = document-&gt;renderView();
3440     if (!renderView)
3441         return;
3442 
<a name="40" id="anc40"></a>



3443     LOG(Layout, &quot;FrameView %p autoSizeIfEnabled&quot;, this);
3444     SetForScope&lt;bool&gt; changeInAutoSize(m_inAutoSize, true);
3445     if (layoutContext().subtreeLayoutRoot())
3446         layoutContext().convertSubtreeLayoutToFullLayout();
<a name="41" id="anc41"></a><span class="line-removed">3447     // Start from the minimum size and allow it to grow.</span>
<span class="line-removed">3448     resize(m_minAutoSize.width(), m_minAutoSize.height());</span>
<span class="line-removed">3449     IntSize size = frameRect().size();</span>
<span class="line-removed">3450     // Do the resizing twice. The first time is basically a rough calculation using the preferred width</span>
<span class="line-removed">3451     // which may result in a height change during the second iteration.</span>
<span class="line-removed">3452     for (int i = 0; i &lt; 2; i++) {</span>
<span class="line-removed">3453         // Update various sizes including contentsSize, scrollHeight, etc.</span>
<span class="line-removed">3454         document-&gt;updateLayoutIgnorePendingStylesheets();</span>
<span class="line-removed">3455         int width = renderView-&gt;minPreferredLogicalWidth();</span>
<span class="line-removed">3456         int height = renderView-&gt;documentRect().height();</span>
<span class="line-removed">3457         IntSize newSize(width, height);</span>
<span class="line-removed">3458 </span>
<span class="line-removed">3459         // Check to see if a scrollbar is needed for a given dimension and</span>
<span class="line-removed">3460         // if so, increase the other dimension to account for the scrollbar.</span>
<span class="line-removed">3461         // Since the dimensions are only for the view rectangle, once a</span>
<span class="line-removed">3462         // dimension exceeds the maximum, there is no need to increase it further.</span>
<span class="line-removed">3463         if (newSize.width() &gt; m_maxAutoSize.width()) {</span>
<span class="line-removed">3464             RefPtr&lt;Scrollbar&gt; localHorizontalScrollbar = horizontalScrollbar();</span>
<span class="line-removed">3465             if (!localHorizontalScrollbar)</span>
<span class="line-removed">3466                 localHorizontalScrollbar = createScrollbar(HorizontalScrollbar);</span>
<span class="line-removed">3467             newSize.expand(0, localHorizontalScrollbar-&gt;occupiedHeight());</span>
<span class="line-removed">3468 </span>
<span class="line-removed">3469             // Don&#39;t bother checking for a vertical scrollbar because the width is at</span>
<span class="line-removed">3470             // already greater the maximum.</span>
<span class="line-removed">3471         } else if (newSize.height() &gt; m_maxAutoSize.height()) {</span>
<span class="line-removed">3472             RefPtr&lt;Scrollbar&gt; localVerticalScrollbar = verticalScrollbar();</span>
<span class="line-removed">3473             if (!localVerticalScrollbar)</span>
<span class="line-removed">3474                 localVerticalScrollbar = createScrollbar(VerticalScrollbar);</span>
<span class="line-removed">3475             newSize.expand(localVerticalScrollbar-&gt;occupiedWidth(), 0);</span>
<span class="line-removed">3476 </span>
<span class="line-removed">3477             // Don&#39;t bother checking for a horizontal scrollbar because the height is</span>
<span class="line-removed">3478             // already greater the maximum.</span>
<span class="line-removed">3479         }</span>
<span class="line-removed">3480 </span>
<span class="line-removed">3481         // Ensure the size is at least the min bounds.</span>
<span class="line-removed">3482         newSize = newSize.expandedTo(m_minAutoSize);</span>
<span class="line-removed">3483 </span>
<span class="line-removed">3484         // Bound the dimensions by the max bounds and determine what scrollbars to show.</span>
<span class="line-removed">3485         ScrollbarMode horizonalScrollbarMode = ScrollbarAlwaysOff;</span>
<span class="line-removed">3486         if (newSize.width() &gt; m_maxAutoSize.width()) {</span>
<span class="line-removed">3487             newSize.setWidth(m_maxAutoSize.width());</span>
<span class="line-removed">3488             horizonalScrollbarMode = ScrollbarAlwaysOn;</span>
<span class="line-removed">3489         }</span>
<span class="line-removed">3490         ScrollbarMode verticalScrollbarMode = ScrollbarAlwaysOff;</span>
<span class="line-removed">3491         if (newSize.height() &gt; m_maxAutoSize.height()) {</span>
<span class="line-removed">3492             newSize.setHeight(m_maxAutoSize.height());</span>
<span class="line-removed">3493             verticalScrollbarMode = ScrollbarAlwaysOn;</span>
<span class="line-removed">3494         }</span>
3495 
<a name="42" id="anc42"></a><span class="line-modified">3496         if (newSize == size)</span>
<span class="line-modified">3497             continue;</span>



3498 
<a name="43" id="anc43"></a><span class="line-modified">3499         // While loading only allow the size to increase (to avoid twitching during intermediate smaller states)</span>
<span class="line-modified">3500         // unless autoresize has just been turned on or the maximum size is smaller than the current size.</span>
<span class="line-modified">3501         if (m_didRunAutosize &amp;&amp; size.height() &lt;= m_maxAutoSize.height() &amp;&amp; size.width() &lt;= m_maxAutoSize.width()</span>
<span class="line-modified">3502             &amp;&amp; !frame().loader().isComplete() &amp;&amp; (newSize.height() &lt; size.height() || newSize.width() &lt; size.width()))</span>
<span class="line-removed">3503             break;</span>
3504 
<a name="44" id="anc44"></a><span class="line-removed">3505         // The first time around, resize to the minimum height again; otherwise,</span>
<span class="line-removed">3506         // on pages (e.g. quirks mode) where the body/document resize to the view size,</span>
<span class="line-removed">3507         // we&#39;ll end up not shrinking back down after resizing to the computed preferred width.</span>
<span class="line-removed">3508         resize(newSize.width(), i ? newSize.height() : m_minAutoSize.height());</span>
<span class="line-removed">3509         // Force the scrollbar state to avoid the scrollbar code adding them and causing them to be needed. For example,</span>
<span class="line-removed">3510         // a vertical scrollbar may cause text to wrap and thus increase the height (which is the only reason the scollbar is needed).</span>
<span class="line-removed">3511         setVerticalScrollbarLock(false);</span>
<span class="line-removed">3512         setHorizontalScrollbarLock(false);</span>
<span class="line-removed">3513         setScrollbarModes(horizonalScrollbarMode, verticalScrollbarMode, true, true);</span>
<span class="line-removed">3514     }</span>
3515     Ref&lt;FrameView&gt; protectedThis(*this);
<a name="45" id="anc45"></a><span class="line-removed">3516     // All the resizing above may have invalidated style (for example if viewport units are being used).</span>
3517     document-&gt;updateStyleIfNeeded();
<a name="46" id="anc46"></a><span class="line-modified">3518     // FIXME: Use the final layout&#39;s result as the content size (webkit.org/b/173561).</span>



3519     m_autoSizeContentSize = contentsSize();
<a name="47" id="anc47"></a><span class="line-removed">3520     if (m_autoSizeFixedMinimumHeight) {</span>
<span class="line-removed">3521         auto contentsSize = this-&gt;contentsSize();</span>
<span class="line-removed">3522         resize(contentsSize.width(), std::max(m_autoSizeFixedMinimumHeight, contentsSize.height()));</span>
<span class="line-removed">3523         document-&gt;updateLayoutIgnorePendingStylesheets();</span>
<span class="line-removed">3524     }</span>
<span class="line-removed">3525     m_didRunAutosize = true;</span>
3526 
<a name="48" id="anc48"></a><span class="line-modified">3527     LOG_WITH_STREAM(Layout, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; autoSizeIfEnabled() changed size from &quot; &lt;&lt; size &lt;&lt; &quot; to &quot; &lt;&lt; frameRect().size());</span>






3528 }
3529 
3530 void FrameView::setAutoSizeFixedMinimumHeight(int fixedMinimumHeight)
3531 {
3532     if (m_autoSizeFixedMinimumHeight == fixedMinimumHeight)
3533         return;
3534 
3535     m_autoSizeFixedMinimumHeight = fixedMinimumHeight;
3536 
3537     setNeedsLayoutAfterViewConfigurationChange();
3538 }
3539 
3540 RenderElement* FrameView::viewportRenderer() const
3541 {
3542     if (m_viewportRendererType == ViewportRendererType::None)
3543         return nullptr;
3544 
3545     auto* document = frame().document();
3546     if (!document)
3547         return nullptr;
3548 
3549     if (m_viewportRendererType == ViewportRendererType::Document) {
3550         auto* documentElement = document-&gt;documentElement();
3551         if (!documentElement)
3552             return nullptr;
3553         return documentElement-&gt;renderer();
3554     }
3555 
3556     if (m_viewportRendererType == ViewportRendererType::Body) {
3557         auto* body = document-&gt;body();
3558         if (!body)
3559             return nullptr;
3560         return body-&gt;renderer();
3561     }
3562 
3563     ASSERT_NOT_REACHED();
3564     return nullptr;
3565 }
3566 
3567 void FrameView::updateOverflowStatus(bool horizontalOverflow, bool verticalOverflow)
3568 {
3569     auto* viewportRenderer = this-&gt;viewportRenderer();
3570     if (!viewportRenderer)
3571         return;
3572 
3573     if (m_overflowStatusDirty) {
3574         m_horizontalOverflow = horizontalOverflow;
3575         m_verticalOverflow = verticalOverflow;
3576         m_overflowStatusDirty = false;
3577         return;
3578     }
3579 
3580     bool horizontalOverflowChanged = (m_horizontalOverflow != horizontalOverflow);
3581     bool verticalOverflowChanged = (m_verticalOverflow != verticalOverflow);
3582 
3583     if (horizontalOverflowChanged || verticalOverflowChanged) {
3584         m_horizontalOverflow = horizontalOverflow;
3585         m_verticalOverflow = verticalOverflow;
3586 
3587         Ref&lt;OverflowEvent&gt; overflowEvent = OverflowEvent::create(horizontalOverflowChanged, horizontalOverflow,
3588             verticalOverflowChanged, verticalOverflow);
3589         overflowEvent-&gt;setTarget(viewportRenderer-&gt;element());
3590 
3591         frame().document()-&gt;enqueueOverflowEvent(WTFMove(overflowEvent));
3592     }
3593 }
3594 
3595 const Pagination&amp; FrameView::pagination() const
3596 {
3597     if (m_pagination != Pagination())
3598         return m_pagination;
3599 
3600     if (frame().isMainFrame()) {
3601         if (Page* page = frame().page())
3602             return page-&gt;pagination();
3603     }
3604 
3605     return m_pagination;
3606 }
3607 
3608 void FrameView::setPagination(const Pagination&amp; pagination)
3609 {
3610     if (m_pagination == pagination)
3611         return;
3612 
3613     m_pagination = pagination;
3614 
3615     frame().document()-&gt;styleScope().didChangeStyleSheetEnvironment();
3616 }
3617 
3618 IntRect FrameView::windowClipRect() const
3619 {
3620     ASSERT(frame().view() == this);
3621 
3622     if (m_cachedWindowClipRect)
3623         return *m_cachedWindowClipRect;
3624 
3625     if (paintsEntireContents())
3626         return contentsToWindow(IntRect(IntPoint(), totalContentsSize()));
3627 
3628     // Set our clip rect to be our contents.
3629     IntRect clipRect = contentsToWindow(visibleContentRect(LegacyIOSDocumentVisibleRect));
3630 
3631     if (!frame().ownerElement())
3632         return clipRect;
3633 
3634     // Take our owner element and get its clip rect.
3635     HTMLFrameOwnerElement* ownerElement = frame().ownerElement();
3636     if (FrameView* parentView = ownerElement-&gt;document().view())
3637         clipRect.intersect(parentView-&gt;windowClipRectForFrameOwner(ownerElement, true));
3638     return clipRect;
3639 }
3640 
3641 IntRect FrameView::windowClipRectForFrameOwner(const HTMLFrameOwnerElement* ownerElement, bool clipToLayerContents) const
3642 {
3643     // The renderer can sometimes be null when style=&quot;display:none&quot; interacts
3644     // with external content and plugins.
3645     if (!ownerElement-&gt;renderer())
3646         return windowClipRect();
3647 
3648     // If we have no layer, just return our window clip rect.
3649     const RenderLayer* enclosingLayer = ownerElement-&gt;renderer()-&gt;enclosingLayer();
3650     if (!enclosingLayer)
3651         return windowClipRect();
3652 
3653     // Apply the clip from the layer.
3654     IntRect clipRect;
3655     if (clipToLayerContents)
3656         clipRect = snappedIntRect(enclosingLayer-&gt;childrenClipRect());
3657     else
3658         clipRect = snappedIntRect(enclosingLayer-&gt;selfClipRect());
3659     clipRect = contentsToWindow(clipRect);
3660     return intersection(clipRect, windowClipRect());
3661 }
3662 
3663 bool FrameView::isActive() const
3664 {
3665     Page* page = frame().page();
3666     return page &amp;&amp; page-&gt;focusController().isActive();
3667 }
3668 
3669 bool FrameView::forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const
3670 {
3671     Page* page = frame().page();
3672     return page &amp;&amp; page-&gt;settings().forceUpdateScrollbarsOnMainThreadForPerformanceTesting();
3673 }
3674 
3675 void FrameView::scrollTo(const ScrollPosition&amp; newPosition)
3676 {
3677     IntPoint oldPosition = scrollPosition();
3678     ScrollView::scrollTo(newPosition);
3679     if (oldPosition != scrollPosition())
3680         scrollPositionChanged(oldPosition, scrollPosition());
3681 
3682     didChangeScrollOffset();
3683 }
3684 
3685 float FrameView::adjustScrollStepForFixedContent(float step, ScrollbarOrientation orientation, ScrollGranularity granularity)
3686 {
3687     if (granularity != ScrollByPage || orientation == HorizontalScrollbar)
3688         return step;
3689 
3690     TrackedRendererListHashSet* positionedObjects = nullptr;
3691     if (RenderView* root = frame().contentRenderer()) {
3692         if (!root-&gt;hasPositionedObjects())
3693             return step;
3694         positionedObjects = root-&gt;positionedObjects();
3695     }
3696 
3697     FloatRect unobscuredContentRect = this-&gt;unobscuredContentRect();
3698     float topObscuredArea = 0;
3699     float bottomObscuredArea = 0;
3700     for (const auto&amp; positionedObject : *positionedObjects) {
3701         const RenderStyle&amp; style = positionedObject-&gt;style();
3702         if (style.position() != PositionType::Fixed || style.visibility() == Visibility::Hidden || !style.opacity())
3703             continue;
3704 
3705         FloatQuad contentQuad = positionedObject-&gt;absoluteContentQuad();
3706         if (!contentQuad.isRectilinear())
3707             continue;
3708 
3709         FloatRect contentBoundingBox = contentQuad.boundingBox();
3710         FloatRect fixedRectInView = intersection(unobscuredContentRect, contentBoundingBox);
3711 
3712         if (fixedRectInView.width() &lt; unobscuredContentRect.width())
3713             continue;
3714 
3715         if (fixedRectInView.y() == unobscuredContentRect.y())
3716             topObscuredArea = std::max(topObscuredArea, fixedRectInView.height());
3717         else if (fixedRectInView.maxY() == unobscuredContentRect.maxY())
3718             bottomObscuredArea = std::max(bottomObscuredArea, fixedRectInView.height());
3719     }
3720 
3721     return Scrollbar::pageStep(unobscuredContentRect.height(), unobscuredContentRect.height() - topObscuredArea - bottomObscuredArea);
3722 }
3723 
3724 void FrameView::invalidateScrollbarRect(Scrollbar&amp; scrollbar, const IntRect&amp; rect)
3725 {
3726     // Add in our offset within the FrameView.
3727     IntRect dirtyRect = rect;
3728     dirtyRect.moveBy(scrollbar.location());
3729     invalidateRect(dirtyRect);
3730 }
3731 
3732 float FrameView::visibleContentScaleFactor() const
3733 {
3734     if (!frame().isMainFrame() || !frame().settings().delegatesPageScaling())
3735         return 1;
3736 
3737     Page* page = frame().page();
3738     if (!page)
3739         return 1;
3740 
3741     return page-&gt;pageScaleFactor();
3742 }
3743 
3744 void FrameView::setVisibleScrollerThumbRect(const IntRect&amp; scrollerThumb)
3745 {
3746     if (!frame().isMainFrame())
3747         return;
3748 
3749     if (Page* page = frame().page())
3750         page-&gt;chrome().client().notifyScrollerThumbIsVisibleInRect(scrollerThumb);
3751 }
3752 
3753 ScrollableArea* FrameView::enclosingScrollableArea() const
3754 {
3755     // FIXME: Walk up the frame tree and look for a scrollable parent frame or RenderLayer.
3756     return nullptr;
3757 }
3758 
3759 IntRect FrameView::scrollableAreaBoundingBox(bool*) const
3760 {
3761     RenderWidget* ownerRenderer = frame().ownerRenderer();
3762     if (!ownerRenderer)
3763         return frameRect();
3764 
3765     return ownerRenderer-&gt;absoluteContentQuad().enclosingBoundingBox();
3766 }
3767 
3768 bool FrameView::isScrollable(Scrollability definitionOfScrollable)
3769 {
3770     // Check for:
3771     // 1) If there an actual overflow.
3772     // 2) display:none or visibility:hidden set to self or inherited.
3773     // 3) overflow{-x,-y}: hidden;
3774     // 4) scrolling: no;
3775     if (!didFirstLayout())
3776         return false;
3777 
3778     bool requiresActualOverflowToBeConsideredScrollable = !frame().isMainFrame() || definitionOfScrollable != Scrollability::ScrollableOrRubberbandable;
3779 #if !ENABLE(RUBBER_BANDING)
3780     requiresActualOverflowToBeConsideredScrollable = true;
3781 #endif
3782 
3783     // Covers #1
3784     if (requiresActualOverflowToBeConsideredScrollable) {
3785         IntSize totalContentsSize = this-&gt;totalContentsSize();
3786         IntSize visibleContentSize = visibleContentRect(LegacyIOSDocumentVisibleRect).size();
3787         if (totalContentsSize.height() &lt;= visibleContentSize.height() &amp;&amp; totalContentsSize.width() &lt;= visibleContentSize.width())
3788             return false;
3789     }
3790 
3791     // Covers #2.
3792     HTMLFrameOwnerElement* owner = frame().ownerElement();
3793     if (owner &amp;&amp; (!owner-&gt;renderer() || !owner-&gt;renderer()-&gt;visibleToHitTesting()))
3794         return false;
3795 
3796     // Cover #3 and #4.
3797     ScrollbarMode horizontalMode;
3798     ScrollbarMode verticalMode;
3799     calculateScrollbarModesForLayout(horizontalMode, verticalMode, RulesFromWebContentOnly);
3800     if (horizontalMode == ScrollbarAlwaysOff &amp;&amp; verticalMode == ScrollbarAlwaysOff)
3801         return false;
3802 
3803     return true;
3804 }
3805 
3806 bool FrameView::isScrollableOrRubberbandable()
3807 {
3808     return isScrollable(Scrollability::ScrollableOrRubberbandable);
3809 }
3810 
3811 bool FrameView::hasScrollableOrRubberbandableAncestor()
3812 {
3813     if (frame().isMainFrame())
3814         return isScrollableOrRubberbandable();
3815 
3816     for (FrameView* parent = this-&gt;parentFrameView(); parent; parent = parent-&gt;parentFrameView()) {
3817         Scrollability frameScrollability = parent-&gt;frame().isMainFrame() ? Scrollability::ScrollableOrRubberbandable : Scrollability::Scrollable;
3818         if (parent-&gt;isScrollable(frameScrollability))
3819             return true;
3820     }
3821 
3822     return false;
3823 }
3824 
3825 void FrameView::updateScrollableAreaSet()
3826 {
3827     // That ensures that only inner frames are cached.
3828     FrameView* parentFrameView = this-&gt;parentFrameView();
3829     if (!parentFrameView)
3830         return;
3831 
3832     if (!isScrollable()) {
3833         parentFrameView-&gt;removeScrollableArea(this);
3834         return;
3835     }
3836 
3837     parentFrameView-&gt;addScrollableArea(this);
3838 }
3839 
3840 bool FrameView::shouldSuspendScrollAnimations() const
3841 {
3842     return frame().loader().state() != FrameStateComplete;
3843 }
3844 
3845 void FrameView::scrollbarStyleChanged(ScrollbarStyle newStyle, bool forceUpdate)
3846 {
3847     if (!frame().isMainFrame())
3848         return;
3849 
3850     if (Page* page = frame().page())
3851         page-&gt;chrome().client().recommendedScrollbarStyleDidChange(newStyle);
3852 
3853     ScrollView::scrollbarStyleChanged(newStyle, forceUpdate);
3854 }
3855 
3856 void FrameView::notifyPageThatContentAreaWillPaint() const
3857 {
3858     Page* page = frame().page();
3859     if (!page)
3860         return;
3861 
3862     contentAreaWillPaint();
3863 
3864     if (!m_scrollableAreas)
3865         return;
3866 
3867     for (auto&amp; scrollableArea : *m_scrollableAreas)
3868         scrollableArea-&gt;contentAreaWillPaint();
3869 }
3870 
3871 bool FrameView::scrollAnimatorEnabled() const
3872 {
3873 #if ENABLE(SMOOTH_SCROLLING)
3874     if (Page* page = frame().page())
3875         return page-&gt;settings().scrollAnimatorEnabled();
3876 #endif
3877 
3878     return false;
3879 }
3880 
3881 void FrameView::updateScrollCorner()
3882 {
3883     RenderElement* renderer = nullptr;
3884     std::unique_ptr&lt;RenderStyle&gt; cornerStyle;
3885     IntRect cornerRect = scrollCornerRect();
3886 
3887     if (!cornerRect.isEmpty()) {
3888         // Try the &lt;body&gt; element first as a scroll corner source.
3889         Document* doc = frame().document();
3890         Element* body = doc ? doc-&gt;bodyOrFrameset() : nullptr;
3891         if (body &amp;&amp; body-&gt;renderer()) {
3892             renderer = body-&gt;renderer();
3893             cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());
3894         }
3895 
3896         if (!cornerStyle) {
3897             // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
3898             Element* docElement = doc ? doc-&gt;documentElement() : nullptr;
3899             if (docElement &amp;&amp; docElement-&gt;renderer()) {
3900                 renderer = docElement-&gt;renderer();
3901                 cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());
3902             }
3903         }
3904 
3905         if (!cornerStyle) {
3906             // If we have an owning iframe/frame element, then it can set the custom scrollbar also.
3907             if (RenderWidget* renderer = frame().ownerRenderer())
3908                 cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());
3909         }
3910     }
3911 
3912     if (!cornerStyle)
3913         m_scrollCorner = nullptr;
3914     else {
3915         if (!m_scrollCorner) {
3916             m_scrollCorner = createRenderer&lt;RenderScrollbarPart&gt;(renderer-&gt;document(), WTFMove(*cornerStyle));
3917             m_scrollCorner-&gt;initializeStyle();
3918         } else
3919             m_scrollCorner-&gt;setStyle(WTFMove(*cornerStyle));
3920         invalidateScrollCorner(cornerRect);
3921     }
3922 }
3923 
3924 void FrameView::paintScrollCorner(GraphicsContext&amp; context, const IntRect&amp; cornerRect)
3925 {
3926     if (context.invalidatingControlTints()) {
3927         updateScrollCorner();
3928         return;
3929     }
3930 
3931     if (m_scrollCorner) {
3932         if (frame().isMainFrame())
3933             context.fillRect(cornerRect, baseBackgroundColor());
3934         m_scrollCorner-&gt;paintIntoRect(context, cornerRect.location(), cornerRect);
3935         return;
3936     }
3937 
3938 #if PLATFORM(MAC)
3939     // Keep this in sync with ScrollAnimatorMac&#39;s effectiveAppearanceForScrollerImp:.
3940     LocalDefaultSystemAppearance localAppearance(useDarkAppearanceForScrollbars());
3941 #endif
3942 
3943     ScrollView::paintScrollCorner(context, cornerRect);
3944 }
3945 
3946 void FrameView::paintScrollbar(GraphicsContext&amp; context, Scrollbar&amp; bar, const IntRect&amp; rect)
3947 {
3948     if (bar.isCustomScrollbar() &amp;&amp; frame().isMainFrame()) {
3949         IntRect toFill = bar.frameRect();
3950         toFill.intersect(rect);
3951         context.fillRect(toFill, baseBackgroundColor());
3952     }
3953 
3954     ScrollView::paintScrollbar(context, bar, rect);
3955 }
3956 
3957 Color FrameView::documentBackgroundColor() const
3958 {
3959     // &lt;https://bugs.webkit.org/show_bug.cgi?id=59540&gt; We blend the background color of
3960     // the document and the body against the base background color of the frame view.
3961     // Background images are unfortunately impractical to include.
3962 
3963     // Return invalid Color objects whenever there is insufficient information.
3964     if (!frame().document())
3965         return Color();
3966 
3967     auto* htmlElement = frame().document()-&gt;documentElement();
3968     auto* bodyElement = frame().document()-&gt;bodyOrFrameset();
3969 
3970     // Start with invalid colors.
3971     Color htmlBackgroundColor;
3972     Color bodyBackgroundColor;
3973     if (htmlElement &amp;&amp; htmlElement-&gt;renderer())
3974         htmlBackgroundColor = htmlElement-&gt;renderer()-&gt;style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
3975     if (bodyElement &amp;&amp; bodyElement-&gt;renderer())
3976         bodyBackgroundColor = bodyElement-&gt;renderer()-&gt;style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
3977 
3978     if (!bodyBackgroundColor.isValid()) {
3979         if (!htmlBackgroundColor.isValid())
3980             return Color();
3981         return baseBackgroundColor().blend(htmlBackgroundColor);
3982     }
3983 
3984     if (!htmlBackgroundColor.isValid())
3985         return baseBackgroundColor().blend(bodyBackgroundColor);
3986 
3987     // We take the aggregate of the base background color
3988     // the &lt;html&gt; background color, and the &lt;body&gt;
3989     // background color to find the document color. The
3990     // addition of the base background color is not
3991     // technically part of the document background, but it
3992     // otherwise poses problems when the aggregate is not
3993     // fully opaque.
3994     return baseBackgroundColor().blend(htmlBackgroundColor).blend(bodyBackgroundColor);
3995 }
3996 
3997 bool FrameView::hasCustomScrollbars() const
3998 {
3999     for (auto&amp; widget : children()) {
4000         if (is&lt;FrameView&gt;(widget)) {
4001             if (downcast&lt;FrameView&gt;(widget.get()).hasCustomScrollbars())
4002                 return true;
4003         } else if (is&lt;Scrollbar&gt;(widget)) {
4004             if (downcast&lt;Scrollbar&gt;(widget.get()).isCustomScrollbar())
4005                 return true;
4006         }
4007     }
4008     return false;
4009 }
4010 
4011 FrameView* FrameView::parentFrameView() const
4012 {
4013     if (!parent())
4014         return nullptr;
4015     auto* parentFrame = frame().tree().parent();
4016     if (!parentFrame)
4017         return nullptr;
4018     return parentFrame-&gt;view();
4019 }
4020 
4021 bool FrameView::isInChildFrameWithFrameFlattening() const
4022 {
4023     if (!frameFlatteningEnabled())
4024         return false;
4025 
4026     if (!parent())
4027         return false;
4028 
4029     HTMLFrameOwnerElement* ownerElement = frame().ownerElement();
4030     if (!ownerElement)
4031         return false;
4032 
4033     if (!ownerElement-&gt;renderWidget())
4034         return false;
4035 
4036     // Frame flattening applies when the owner element is either in a frameset or
4037     // an iframe with flattening parameters.
4038     if (is&lt;HTMLIFrameElement&gt;(*ownerElement))
4039         return downcast&lt;RenderIFrame&gt;(*ownerElement-&gt;renderWidget()).flattenFrame();
4040 
4041     if (is&lt;HTMLFrameElement&gt;(*ownerElement))
4042         return true;
4043 
4044     return false;
4045 }
4046 
4047 void FrameView::updateControlTints()
4048 {
4049     // This is called when control tints are changed from aqua/graphite to clear and vice versa.
4050     // We do a &quot;fake&quot; paint, and when the theme gets a paint call, it can then do an invalidate.
4051     // This is only done if the theme supports control tinting. It&#39;s up to the theme and platform
4052     // to define when controls get the tint and to call this function when that changes.
4053 
4054     // Optimize the common case where we bring a window to the front while it&#39;s still empty.
4055     if (frame().document()-&gt;url().isEmpty())
4056         return;
4057 
4058     // As noted above, this is a &quot;fake&quot; paint, so we should pause counting relevant repainted objects.
4059     Page* page = frame().page();
4060     bool isCurrentlyCountingRelevantRepaintedObject = false;
4061     if (page) {
4062         isCurrentlyCountingRelevantRepaintedObject = page-&gt;isCountingRelevantRepaintedObjects();
4063         page-&gt;setIsCountingRelevantRepaintedObjects(false);
4064     }
4065 
4066     RenderView* renderView = this-&gt;renderView();
4067     if ((renderView &amp;&amp; renderView-&gt;theme().supportsControlTints()) || hasCustomScrollbars())
4068         invalidateControlTints();
4069 
4070     if (page)
4071         page-&gt;setIsCountingRelevantRepaintedObjects(isCurrentlyCountingRelevantRepaintedObject);
4072 }
4073 
4074 void FrameView::traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons paintInvalidationReasons)
4075 {
4076     if (needsLayout())
4077         layoutContext().layout();
4078 
4079     GraphicsContext context(paintInvalidationReasons);
4080     if (platformWidget()) {
4081         // FIXME: consult paintsEntireContents().
4082         paintContents(context, visibleContentRect(LegacyIOSDocumentVisibleRect));
4083     } else
4084         paint(context, frameRect());
4085 }
4086 
4087 bool FrameView::wasScrolledByUser() const
4088 {
4089     return m_wasScrolledByUser;
4090 }
4091 
4092 void FrameView::setWasScrolledByUser(bool wasScrolledByUser)
4093 {
4094     LOG(Scrolling, &quot;FrameView::setWasScrolledByUser at %d&quot;, wasScrolledByUser);
4095 
4096     m_shouldScrollToFocusedElement = false;
4097     m_delayedScrollToFocusedElementTimer.stop();
<a name="49" id="anc49"></a><span class="line-modified">4098     if (m_inProgrammaticScroll)</span>
4099         return;
4100     m_maintainScrollPositionAnchor = nullptr;
4101     if (m_wasScrolledByUser == wasScrolledByUser)
4102         return;
4103     m_wasScrolledByUser = wasScrolledByUser;
4104     if (frame().isMainFrame())
4105         updateLayerFlushThrottling();
4106     adjustTiledBackingCoverage();
4107 }
4108 
4109 void FrameView::willPaintContents(GraphicsContext&amp; context, const IntRect&amp;, PaintingState&amp; paintingState)
4110 {
4111     Document* document = frame().document();
4112 
4113     if (!context.paintingDisabled())
4114         InspectorInstrumentation::willPaint(*renderView());
4115 
4116     paintingState.isTopLevelPainter = !sCurrentPaintTimeStamp;
4117 
4118     if (paintingState.isTopLevelPainter)
4119         sCurrentPaintTimeStamp = MonotonicTime::now();
4120 
4121     paintingState.paintBehavior = m_paintBehavior;
4122 
4123     if (FrameView* parentView = parentFrameView()) {
4124         if (parentView-&gt;paintBehavior() &amp; PaintBehavior::FlattenCompositingLayers)
4125             m_paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4126 
4127         if (parentView-&gt;paintBehavior() &amp; PaintBehavior::Snapshotting)
4128             m_paintBehavior.add(PaintBehavior::Snapshotting);
4129 
4130         if (parentView-&gt;paintBehavior() &amp; PaintBehavior::TileFirstPaint)
4131             m_paintBehavior.add(PaintBehavior::TileFirstPaint);
4132     }
4133 
4134     if (document-&gt;printing()) {
4135         m_paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4136         m_paintBehavior.add(PaintBehavior::Snapshotting);
4137     }
4138 
4139     paintingState.isFlatteningPaintOfRootFrame = (m_paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) &amp;&amp; !frame().ownerElement();
4140     if (paintingState.isFlatteningPaintOfRootFrame)
4141         notifyWidgetsInAllFrames(WillPaintFlattened);
4142 
4143     ASSERT(!m_isPainting);
4144     m_isPainting = true;
4145 }
4146 
4147 void FrameView::didPaintContents(GraphicsContext&amp; context, const IntRect&amp; dirtyRect, PaintingState&amp; paintingState)
4148 {
4149     m_isPainting = false;
4150 
4151     if (paintingState.isFlatteningPaintOfRootFrame)
4152         notifyWidgetsInAllFrames(DidPaintFlattened);
4153 
4154     m_paintBehavior = paintingState.paintBehavior;
4155     m_lastPaintTime = MonotonicTime::now();
4156 
<a name="50" id="anc50"></a><span class="line-removed">4157     // Regions may have changed as a result of the visibility/z-index of element changing.</span>
<span class="line-removed">4158     frame().document()-&gt;updateZOrderDependentRegions();</span>
<span class="line-removed">4159 </span>
4160     if (paintingState.isTopLevelPainter)
4161         sCurrentPaintTimeStamp = MonotonicTime();
4162 
4163     if (!context.paintingDisabled()) {
4164         InspectorInstrumentation::didPaint(*renderView(), dirtyRect);
4165         // FIXME: should probably not fire milestones for snapshot painting. https://bugs.webkit.org/show_bug.cgi?id=117623
4166         firePaintRelatedMilestonesIfNeeded();
4167     }
4168 }
4169 
4170 void FrameView::paintContents(GraphicsContext&amp; context, const IntRect&amp; dirtyRect, SecurityOriginPaintPolicy securityOriginPaintPolicy)
4171 {
4172 #ifndef NDEBUG
4173     bool fillWithWarningColor;
4174     if (frame().document()-&gt;printing())
4175         fillWithWarningColor = false; // Printing, don&#39;t fill with red (can&#39;t remember why).
4176     else if (frame().ownerElement())
4177         fillWithWarningColor = false; // Subframe, don&#39;t fill with red.
4178     else if (isTransparent())
4179         fillWithWarningColor = false; // Transparent, don&#39;t fill with red.
4180     else if (m_paintBehavior &amp; PaintBehavior::SelectionOnly)
4181         fillWithWarningColor = false; // Selections are transparent, don&#39;t fill with red.
4182     else if (m_nodeToDraw)
4183         fillWithWarningColor = false; // Element images are transparent, don&#39;t fill with red.
4184     else
4185         fillWithWarningColor = true;
4186 
4187     if (fillWithWarningColor)
4188         context.fillRect(dirtyRect, Color(255, 64, 255));
4189 #endif
4190 
4191     RenderView* renderView = this-&gt;renderView();
4192     if (!renderView) {
4193         LOG_ERROR(&quot;called FrameView::paint with nil renderer&quot;);
4194         return;
4195     }
4196 
4197     if (!layoutContext().inPaintableState())
4198         return;
4199 
4200     ASSERT(!needsLayout());
4201     if (needsLayout()) {
4202         RELEASE_LOG_IF_ALLOWED(&quot;FrameView::paintContents() - not painting because render tree needs layout (is main frame %d)&quot;, frame().isMainFrame());
4203         return;
4204     }
4205 
4206     PaintingState paintingState;
4207     willPaintContents(context, dirtyRect, paintingState);
4208 
4209     // m_nodeToDraw is used to draw only one element (and its descendants)
4210     RenderObject* renderer = m_nodeToDraw ? m_nodeToDraw-&gt;renderer() : nullptr;
4211     RenderLayer* rootLayer = renderView-&gt;layer();
4212 
4213 #ifndef NDEBUG
4214     RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;rootLayer-&gt;renderer());
4215 #endif
4216 
4217     // To work around http://webkit.org/b/135106, ensure that the paint root isn&#39;t an inline with culled line boxes.
4218     // FIXME: This can cause additional content to be included in the snapshot, so remove this once that bug is fixed.
4219     while (is&lt;RenderInline&gt;(renderer) &amp;&amp; !downcast&lt;RenderInline&gt;(*renderer).firstLineBox())
4220         renderer = renderer-&gt;parent();
4221 
4222     rootLayer-&gt;paint(context, dirtyRect, LayoutSize(), m_paintBehavior, renderer, { }, securityOriginPaintPolicy == SecurityOriginPaintPolicy::AnyOrigin ? RenderLayer::SecurityOriginPaintPolicy::AnyOrigin : RenderLayer::SecurityOriginPaintPolicy::AccessibleOriginOnly);
4223     if (rootLayer-&gt;containsDirtyOverlayScrollbars())
4224         rootLayer-&gt;paintOverlayScrollbars(context, dirtyRect, m_paintBehavior, renderer);
4225 
4226     didPaintContents(context, dirtyRect, paintingState);
4227 }
4228 
4229 void FrameView::setPaintBehavior(OptionSet&lt;PaintBehavior&gt; behavior)
4230 {
4231     m_paintBehavior = behavior;
4232 }
4233 
4234 OptionSet&lt;PaintBehavior&gt; FrameView::paintBehavior() const
4235 {
4236     return m_paintBehavior;
4237 }
4238 
4239 bool FrameView::isPainting() const
4240 {
4241     return m_isPainting;
4242 }
4243 
4244 // FIXME: change this to use the subtreePaint terminology.
4245 void FrameView::setNodeToDraw(Node* node)
4246 {
4247     m_nodeToDraw = node;
4248 }
4249 
4250 void FrameView::paintContentsForSnapshot(GraphicsContext&amp; context, const IntRect&amp; imageRect, SelectionInSnapshot shouldPaintSelection, CoordinateSpaceForSnapshot coordinateSpace)
4251 {
4252     updateLayoutAndStyleIfNeededRecursive();
4253 
4254     // Cache paint behavior and set a new behavior appropriate for snapshots.
4255     auto oldBehavior = paintBehavior();
4256     setPaintBehavior(oldBehavior | PaintBehavior::FlattenCompositingLayers | PaintBehavior::Snapshotting);
4257 
4258     // If the snapshot should exclude selection, then we&#39;ll clear the current selection
4259     // in the render tree only. This will allow us to restore the selection from the DOM
4260     // after we paint the snapshot.
4261     if (shouldPaintSelection == ExcludeSelection) {
4262         for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
4263             if (auto* renderView = frame-&gt;contentRenderer())
4264                 renderView-&gt;selection().clear();
4265         }
4266     }
4267 
4268     if (coordinateSpace == DocumentCoordinates)
4269         paintContents(context, imageRect);
4270     else {
4271         // A snapshot in ViewCoordinates will include a scrollbar, and the snapshot will contain
4272         // whatever content the document is currently scrolled to.
4273         paint(context, imageRect);
4274     }
4275 
4276     // Restore selection.
4277     if (shouldPaintSelection == ExcludeSelection) {
4278         for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr()))
4279             frame-&gt;selection().updateAppearance();
4280     }
4281 
4282     // Restore cached paint behavior.
4283     setPaintBehavior(oldBehavior);
4284 }
4285 
4286 void FrameView::paintOverhangAreas(GraphicsContext&amp; context, const IntRect&amp; horizontalOverhangArea, const IntRect&amp; verticalOverhangArea, const IntRect&amp; dirtyRect)
4287 {
4288     if (context.paintingDisabled())
4289         return;
4290 
4291     if (frame().document()-&gt;printing())
4292         return;
4293 
4294     ScrollView::paintOverhangAreas(context, horizontalOverhangArea, verticalOverhangArea, dirtyRect);
4295 }
4296 
4297 void FrameView::updateLayoutAndStyleIfNeededRecursive()
4298 {
4299     // Style updating, render tree creation, and layout needs to be done multiple times
4300     // for more than one reason. But one reason is that when an &lt;object&gt; element determines
4301     // what it needs to load a subframe, a second pass is needed. That requires update
4302     // passes equal to the number of levels of DOM nesting. That is why this number is large.
4303     // There are test cases where we have roughly 10 levels of DOM nesting, so this needs to
4304     // be greater than that. We have a limit to avoid the possibility of an infinite loop.
4305     // Typical calls will run the loop 2 times (once to do work, once to detect no further work
4306     // is needed).
4307     // FIXME: We should find an approach that does not require a loop at all.
4308     const unsigned maxUpdatePasses = 25;
4309 
4310     // Style updates can trigger script, which can cause this FrameView to be destroyed.
4311     Ref&lt;FrameView&gt; protectedThis(*this);
4312 
4313     AnimationUpdateBlock animationUpdateBlock(&amp;frame().animation());
4314 
4315     using DescendantsDeque = Deque&lt;Ref&lt;FrameView&gt;, 16&gt;;
4316     auto nextRenderedDescendant = [this] (DescendantsDeque&amp; descendantsDeque) -&gt; RefPtr&lt;FrameView&gt; {
4317         if (descendantsDeque.isEmpty())
4318             descendantsDeque.append(*this);
4319         else {
4320             // Append renderered children after processing the parent, in case the processing
4321             // affects the set of rendered children.
4322             auto previousView = descendantsDeque.takeFirst();
4323             for (auto* frame = previousView-&gt;frame().tree().firstRenderedChild(); frame; frame = frame-&gt;tree().nextRenderedSibling()) {
4324                 if (auto* view = frame-&gt;view())
4325                     descendantsDeque.append(*view);
4326             }
4327             if (descendantsDeque.isEmpty())
4328                 return nullptr;
4329         }
4330         return descendantsDeque.first().ptr();
4331     };
4332 
4333     for (unsigned i = 0; i &lt; maxUpdatePasses; ++i) {
4334         bool didWork = false;
4335         DescendantsDeque deque;
4336         while (auto view = nextRenderedDescendant(deque)) {
4337             if (view-&gt;frame().document()-&gt;updateStyleIfNeeded())
4338                 didWork = true;
4339             if (view-&gt;needsLayout()) {
4340                 view-&gt;layoutContext().layout();
4341                 didWork = true;
4342             }
4343         }
4344         if (!didWork)
4345             break;
4346     }
4347 
4348 #if !ASSERT_DISABLED
4349     auto needsStyleRecalc = [&amp;] {
4350         DescendantsDeque deque;
4351         while (auto view = nextRenderedDescendant(deque)) {
4352             auto* document = view-&gt;frame().document();
4353             if (document &amp;&amp; document-&gt;childNeedsStyleRecalc())
4354                 return true;
4355         }
4356         return false;
4357     };
4358 
4359     auto needsLayout = [&amp;] {
4360         DescendantsDeque deque;
4361         while (auto view = nextRenderedDescendant(deque)) {
4362             if (view-&gt;needsLayout())
4363                 return true;
4364         }
4365         return false;
4366     };
4367 #endif
4368 
4369     ASSERT(!needsStyleRecalc());
4370     ASSERT(!needsLayout());
4371 }
4372 
4373 void FrameView::incrementVisuallyNonEmptyCharacterCount(const String&amp; inlineText)
4374 {
4375     if (m_visuallyNonEmptyCharacterCount &gt; visualCharacterThreshold &amp;&amp; m_hasReachedSignificantRenderedTextThreshold)
4376         return;
4377 
4378     auto nonWhitespaceLength = [](auto&amp; inlineText) {
4379         auto length = inlineText.length();
4380         for (unsigned i = 0; i &lt; inlineText.length(); ++i) {
4381             if (isNotHTMLSpace(inlineText[i]))
4382                 continue;
4383             --length;
4384         }
4385         return length;
4386     };
4387     m_visuallyNonEmptyCharacterCount += nonWhitespaceLength(inlineText);
4388     ++m_textRendererCountForVisuallyNonEmptyCharacters;
4389 }
4390 
4391 static bool elementOverflowRectIsLargerThanThreshold(const Element&amp; element)
4392 {
4393     // Require the document to grow a bit.
4394     // Using a value of 48 allows the header on Google&#39;s search page to render immediately before search results populate later.
4395     static const int documentHeightThreshold = 48;
4396     if (auto* elementRenderBox = element.renderBox())
4397         return snappedIntRect(elementRenderBox-&gt;layoutOverflowRect()).height() &gt;= documentHeightThreshold;
4398 
4399     return false;
4400 }
4401 
4402 void FrameView::updateHasReachedSignificantRenderedTextThreshold()
4403 {
4404     if (m_hasReachedSignificantRenderedTextThreshold)
4405         return;
4406 
4407     auto* page = frame().page();
4408     if (!page || !page-&gt;requestedLayoutMilestones().contains(DidRenderSignificantAmountOfText))
4409         return;
4410 
4411     auto* document = frame().document();
4412     if (!document)
4413         return;
4414 
4415     document-&gt;updateMainArticleElementAfterLayout();
4416     auto hasMainArticleElement = document-&gt;hasMainArticleElement();
4417     auto characterThreshold = hasMainArticleElement ? mainArticleSignificantRenderedTextCharacterThreshold : defaultSignificantRenderedTextCharacterThreshold;
4418     if (m_visuallyNonEmptyCharacterCount &lt; characterThreshold)
4419         return;
4420 
4421     auto meanLength = hasMainArticleElement ? mainArticleSignificantRenderedTextMeanLength : defaultSignificantRenderedTextMeanLength;
4422     if (!m_textRendererCountForVisuallyNonEmptyCharacters || m_visuallyNonEmptyCharacterCount / static_cast&lt;float&gt;(m_textRendererCountForVisuallyNonEmptyCharacters) &lt; meanLength)
4423         return;
4424 
4425     m_hasReachedSignificantRenderedTextThreshold = true;
4426 }
4427 
4428 bool FrameView::qualifiesAsSignificantRenderedText() const
4429 {
4430     ASSERT(!m_renderedSignificantAmountOfText);
4431     auto* document = frame().document();
4432     if (!document || document-&gt;styleScope().hasPendingSheetsBeforeBody())
4433         return false;
4434 
4435     auto* documentElement = document-&gt;documentElement();
4436     if (!documentElement || !elementOverflowRectIsLargerThanThreshold(*documentElement))
4437         return false;
4438 
4439     return m_hasReachedSignificantRenderedTextThreshold;
4440 }
4441 
4442 bool FrameView::qualifiesAsVisuallyNonEmpty() const
4443 {
4444     // No content yet.
4445     Element* documentElement = frame().document()-&gt;documentElement();
4446     if (!documentElement || !documentElement-&gt;renderer())
4447         return false;
4448 
4449     // FIXME: We should also ignore renderers with non-final style.
4450     if (frame().document()-&gt;styleScope().hasPendingSheetsBeforeBody())
4451         return false;
4452 
4453     auto finishedParsingMainDocument = frame().loader().stateMachine().committedFirstRealDocumentLoad() &amp;&amp; (frame().document()-&gt;readyState() == Document::Interactive || frame().document()-&gt;readyState() == Document::Complete);
4454     // Ensure that we always fire visually non-empty milestone eventually.
4455     if (finishedParsingMainDocument &amp;&amp; frame().loader().isComplete())
4456         return true;
4457 
4458     auto isVisible = [](const Element* element) {
4459         if (!element || !element-&gt;renderer())
4460             return false;
4461         if (!element-&gt;renderer()-&gt;opacity())
4462             return false;
4463         return element-&gt;renderer()-&gt;style().visibility() == Visibility::Visible;
4464     };
4465 
4466     if (!isVisible(documentElement))
4467         return false;
4468 
4469     if (!isVisible(frame().document()-&gt;body()))
4470         return false;
4471 
4472     if (!elementOverflowRectIsLargerThanThreshold(*documentElement))
4473         return false;
4474 
4475     // The first few hundred characters rarely contain the interesting content of the page.
4476     if (m_visuallyNonEmptyCharacterCount &gt; visualCharacterThreshold)
4477         return true;
4478 
4479     // Use a threshold value to prevent very small amounts of visible content from triggering didFirstVisuallyNonEmptyLayout
4480     if (m_visuallyNonEmptyPixelCount &gt; visualPixelThreshold)
4481         return true;
4482 
4483     auto isMoreContentExpected = [&amp;]() {
4484         ASSERT(finishedParsingMainDocument);
4485         // Pending css/font loading means we should wait a little longer. Classic non-async, non-defer scripts are all processed by now.
4486         auto* documentLoader = frame().loader().documentLoader();
4487         if (!documentLoader)
4488             return false;
4489 
4490         auto&amp; resourceLoader = documentLoader-&gt;cachedResourceLoader();
4491         if (!resourceLoader.requestCount())
4492             return false;
4493 
4494         auto&amp; resources = resourceLoader.allCachedResources();
4495         for (auto&amp; resource : resources) {
4496             if (resource.value-&gt;isLoaded())
4497                 continue;
4498             if (resource.value-&gt;type() == CachedResource::Type::CSSStyleSheet || resource.value-&gt;type() == CachedResource::Type::FontResource)
4499                 return true;
4500         }
4501         return false;
4502     };
4503 
4504     // Finished parsing the main document and we still don&#39;t yet have enough content. Check if we might be getting some more.
4505     if (finishedParsingMainDocument)
4506         return !isMoreContentExpected();
4507 
4508     return false;
4509 }
4510 
4511 bool FrameView::isViewForDocumentInFrame() const
4512 {
4513     RenderView* renderView = this-&gt;renderView();
4514     if (!renderView)
4515         return false;
4516 
4517     return &amp;renderView-&gt;frameView() == this;
4518 }
4519 
<a name="51" id="anc51"></a><span class="line-modified">4520 void FrameView::enableAutoSizeMode(bool enable, const IntSize&amp; minSize, const IntSize&amp; maxSize)</span>
4521 {
<a name="52" id="anc52"></a><span class="line-modified">4522     ASSERT(!enable || !minSize.isEmpty());</span>
<span class="line-modified">4523     ASSERT(minSize.width() &lt;= maxSize.width());</span>
<span class="line-removed">4524     ASSERT(minSize.height() &lt;= maxSize.height());</span>
<span class="line-removed">4525 </span>
<span class="line-removed">4526     if (m_shouldAutoSize == enable &amp;&amp; m_minAutoSize == minSize &amp;&amp; m_maxAutoSize == maxSize)</span>
4527         return;
4528 
4529     m_shouldAutoSize = enable;
<a name="53" id="anc53"></a><span class="line-modified">4530     m_minAutoSize = minSize;</span>
<span class="line-modified">4531     m_maxAutoSize = maxSize;</span>
4532     m_didRunAutosize = false;
4533 
4534     setNeedsLayoutAfterViewConfigurationChange();
4535     layoutContext().scheduleLayout();
4536     if (m_shouldAutoSize) {
<a name="54" id="anc54"></a><span class="line-modified">4537         overrideViewportSizeForCSSViewportUnits({ minSize.width(), m_overrideViewportSize ? m_overrideViewportSize-&gt;height : WTF::nullopt });</span>
4538         return;
4539     }
4540 
4541     clearViewportSizeOverrideForCSSViewportUnits();
4542     // Since autosize mode forces the scrollbar mode, change them to being auto.
4543     setVerticalScrollbarLock(false);
4544     setHorizontalScrollbarLock(false);
4545     setScrollbarModes(ScrollbarAuto, ScrollbarAuto);
4546 }
4547 
4548 void FrameView::forceLayout(bool allowSubtreeLayout)
4549 {
4550     if (!allowSubtreeLayout &amp;&amp; layoutContext().subtreeLayoutRoot())
4551         layoutContext().convertSubtreeLayoutToFullLayout();
4552     layoutContext().layout();
4553 }
4554 
4555 void FrameView::forceLayoutForPagination(const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkFactor, AdjustViewSizeOrNot shouldAdjustViewSize)
4556 {
4557     if (!renderView())
4558         return;
4559 
4560     Ref&lt;FrameView&gt; protectedThis(*this);
4561     auto&amp; renderView = *this-&gt;renderView();
4562 
4563     // Dumping externalRepresentation(frame().renderer()).ascii() is a good trick to see
4564     // the state of things before and after the layout
4565     float pageLogicalWidth = renderView.style().isHorizontalWritingMode() ? pageSize.width() : pageSize.height();
4566     float pageLogicalHeight = renderView.style().isHorizontalWritingMode() ? pageSize.height() : pageSize.width();
4567 
4568     renderView.setPageLogicalSize({ floor(pageLogicalWidth), floor(pageLogicalHeight) });
4569     renderView.setNeedsLayoutAndPrefWidthsRecalc();
4570     forceLayout();
4571     if (hasOneRef())
4572         return;
4573 
4574     // If we don&#39;t fit in the given page width, we&#39;ll lay out again. If we don&#39;t fit in the
4575     // page width when shrunk, we will lay out at maximum shrink and clip extra content.
4576     // FIXME: We are assuming a shrink-to-fit printing implementation. A cropping
4577     // implementation should not do this!
4578     bool horizontalWritingMode = renderView.style().isHorizontalWritingMode();
4579     const LayoutRect&amp; documentRect = renderView.documentRect();
4580     LayoutUnit docLogicalWidth = horizontalWritingMode ? documentRect.width() : documentRect.height();
4581     if (docLogicalWidth &gt; pageLogicalWidth) {
4582         int expectedPageWidth = std::min&lt;float&gt;(documentRect.width(), pageSize.width() * maximumShrinkFactor);
4583         int expectedPageHeight = std::min&lt;float&gt;(documentRect.height(), pageSize.height() * maximumShrinkFactor);
4584         FloatSize maxPageSize = frame().resizePageRectsKeepingRatio(FloatSize(originalPageSize.width(), originalPageSize.height()), FloatSize(expectedPageWidth, expectedPageHeight));
4585         pageLogicalWidth = horizontalWritingMode ? maxPageSize.width() : maxPageSize.height();
4586         pageLogicalHeight = horizontalWritingMode ? maxPageSize.height() : maxPageSize.width();
4587 
4588         renderView.setPageLogicalSize({ floor(pageLogicalWidth), floor(pageLogicalHeight) });
4589         renderView.setNeedsLayoutAndPrefWidthsRecalc();
4590         forceLayout();
4591         if (hasOneRef())
4592             return;
4593 
4594         const LayoutRect&amp; updatedDocumentRect = renderView.documentRect();
4595         LayoutUnit docLogicalHeight = horizontalWritingMode ? updatedDocumentRect.height() : updatedDocumentRect.width();
4596         LayoutUnit docLogicalTop = horizontalWritingMode ? updatedDocumentRect.y() : updatedDocumentRect.x();
4597         LayoutUnit docLogicalRight = horizontalWritingMode ? updatedDocumentRect.maxX() : updatedDocumentRect.maxY();
4598         LayoutUnit clippedLogicalLeft;
4599         if (!renderView.style().isLeftToRightDirection())
4600             clippedLogicalLeft = docLogicalRight - pageLogicalWidth;
<a name="55" id="anc55"></a><span class="line-modified">4601         LayoutRect overflow(clippedLogicalLeft, docLogicalTop, pageLogicalWidth, docLogicalHeight);</span>
4602 
4603         if (!horizontalWritingMode)
4604             overflow = overflow.transposedRect();
4605         renderView.clearLayoutOverflow();
4606         renderView.addLayoutOverflow(overflow); // This is how we clip in case we overflow again.
4607     }
4608 
4609     if (shouldAdjustViewSize)
4610         adjustViewSize();
4611 }
4612 
4613 void FrameView::adjustPageHeightDeprecated(float *newBottom, float oldTop, float oldBottom, float /*bottomLimit*/)
4614 {
4615     RenderView* renderView = this-&gt;renderView();
4616     if (!renderView) {
4617         *newBottom = oldBottom;
4618         return;
4619 
4620     }
4621     // Use a context with painting disabled.
4622     GraphicsContext context(GraphicsContext::PaintInvalidationReasons::None);
4623     renderView-&gt;setTruncatedAt(static_cast&lt;int&gt;(floorf(oldBottom)));
4624     IntRect dirtyRect(0, static_cast&lt;int&gt;(floorf(oldTop)), renderView-&gt;layoutOverflowRect().maxX(), static_cast&lt;int&gt;(ceilf(oldBottom - oldTop)));
4625     renderView-&gt;setPrintRect(dirtyRect);
4626     renderView-&gt;layer()-&gt;paint(context, dirtyRect);
4627     *newBottom = renderView-&gt;bestTruncatedAt();
4628     if (!*newBottom)
4629         *newBottom = oldBottom;
4630     renderView-&gt;setPrintRect(IntRect());
4631 }
4632 
4633 IntRect FrameView::convertFromRendererToContainingView(const RenderElement* renderer, const IntRect&amp; rendererRect) const
4634 {
4635     IntRect rect = snappedIntRect(enclosingLayoutRect(renderer-&gt;localToAbsoluteQuad(FloatRect(rendererRect)).boundingBox()));
4636 
4637     return contentsToView(rect);
4638 }
4639 
4640 IntRect FrameView::convertFromContainingViewToRenderer(const RenderElement* renderer, const IntRect&amp; viewRect) const
4641 {
4642     IntRect rect = viewToContents(viewRect);
4643 
4644     // FIXME: we don&#39;t have a way to map an absolute rect down to a local quad, so just
4645     // move the rect for now.
4646     rect.setLocation(roundedIntPoint(renderer-&gt;absoluteToLocal(rect.location(), UseTransforms)));
4647     return rect;
4648 }
4649 
4650 FloatRect FrameView::convertFromContainingViewToRenderer(const RenderElement* renderer, const FloatRect&amp; viewRect) const
4651 {
4652     FloatRect rect = viewToContents(viewRect);
4653 
4654     return (renderer-&gt;absoluteToLocalQuad(rect)).boundingBox();
4655 }
4656 
4657 IntPoint FrameView::convertFromRendererToContainingView(const RenderElement* renderer, const IntPoint&amp; rendererPoint) const
4658 {
4659     IntPoint point = roundedIntPoint(renderer-&gt;localToAbsolute(rendererPoint, UseTransforms));
4660 
4661     return contentsToView(point);
4662 }
4663 
4664 IntPoint FrameView::convertFromContainingViewToRenderer(const RenderElement* renderer, const IntPoint&amp; viewPoint) const
4665 {
4666     IntPoint point = viewPoint;
4667 
4668     // Convert from FrameView coords into page (&quot;absolute&quot;) coordinates.
4669     if (!delegatesScrolling())
4670         point = viewToContents(point);
4671 
4672     return roundedIntPoint(renderer-&gt;absoluteToLocal(point, UseTransforms));
4673 }
4674 
4675 IntRect FrameView::convertToContainingView(const IntRect&amp; localRect) const
4676 {
4677     if (const ScrollView* parentScrollView = parent()) {
4678         if (is&lt;FrameView&gt;(*parentScrollView)) {
4679             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4680             // Get our renderer in the parent view
4681             RenderWidget* renderer = frame().ownerRenderer();
4682             if (!renderer)
4683                 return localRect;
4684 
4685             auto rect = localRect;
4686             rect.moveBy(roundedIntPoint(renderer-&gt;contentBoxLocation()));
4687             return parentView.convertFromRendererToContainingView(renderer, rect);
4688         }
4689 
4690         return Widget::convertToContainingView(localRect);
4691     }
4692 
4693     return localRect;
4694 }
4695 
4696 IntRect FrameView::convertFromContainingView(const IntRect&amp; parentRect) const
4697 {
4698     if (const ScrollView* parentScrollView = parent()) {
4699         if (is&lt;FrameView&gt;(*parentScrollView)) {
4700             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4701 
4702             // Get our renderer in the parent view
4703             RenderWidget* renderer = frame().ownerRenderer();
4704             if (!renderer)
4705                 return parentRect;
4706 
4707             auto rect = parentView.convertFromContainingViewToRenderer(renderer, parentRect);
4708             rect.moveBy(-roundedIntPoint(renderer-&gt;contentBoxLocation()));
4709             return rect;
4710         }
4711 
4712         return Widget::convertFromContainingView(parentRect);
4713     }
4714 
4715     return parentRect;
4716 }
4717 
4718 FloatRect FrameView::convertFromContainingView(const FloatRect&amp; parentRect) const
4719 {
4720     if (const ScrollView* parentScrollView = parent()) {
4721         if (is&lt;FrameView&gt;(*parentScrollView)) {
4722             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4723 
4724             // Get our renderer in the parent view
4725             RenderWidget* renderer = frame().ownerRenderer();
4726             if (!renderer)
4727                 return parentRect;
4728 
4729             auto rect = parentView.convertFromContainingViewToRenderer(renderer, parentRect);
4730             rect.moveBy(-renderer-&gt;contentBoxLocation());
4731             return rect;
4732         }
4733 
4734         return Widget::convertFromContainingView(parentRect);
4735     }
4736 
4737     return parentRect;
4738 }
4739 
4740 IntPoint FrameView::convertToContainingView(const IntPoint&amp; localPoint) const
4741 {
4742     if (const ScrollView* parentScrollView = parent()) {
4743         if (is&lt;FrameView&gt;(*parentScrollView)) {
4744             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4745 
4746             // Get our renderer in the parent view
4747             RenderWidget* renderer = frame().ownerRenderer();
4748             if (!renderer)
4749                 return localPoint;
4750 
4751             auto point = localPoint;
4752             point.moveBy(roundedIntPoint(renderer-&gt;contentBoxLocation()));
4753             return parentView.convertFromRendererToContainingView(renderer, point);
4754         }
4755 
4756         return Widget::convertToContainingView(localPoint);
4757     }
4758 
4759     return localPoint;
4760 }
4761 
4762 IntPoint FrameView::convertFromContainingView(const IntPoint&amp; parentPoint) const
4763 {
4764     if (const ScrollView* parentScrollView = parent()) {
4765         if (is&lt;FrameView&gt;(*parentScrollView)) {
4766             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4767 
4768             // Get our renderer in the parent view
4769             RenderWidget* renderer = frame().ownerRenderer();
4770             if (!renderer)
4771                 return parentPoint;
4772 
4773             auto point = parentView.convertFromContainingViewToRenderer(renderer, parentPoint);
4774             point.moveBy(-roundedIntPoint(renderer-&gt;contentBoxLocation()));
4775             return point;
4776         }
4777 
4778         return Widget::convertFromContainingView(parentPoint);
4779     }
4780 
4781     return parentPoint;
4782 }
4783 
4784 float FrameView::documentToAbsoluteScaleFactor(Optional&lt;float&gt; effectiveZoom) const
4785 {
4786     // If effectiveZoom is passed, it already factors in pageZoomFactor().
4787     return effectiveZoom.valueOr(frame().pageZoomFactor()) * frame().frameScaleFactor();
4788 }
4789 
4790 float FrameView::absoluteToDocumentScaleFactor(Optional&lt;float&gt; effectiveZoom) const
4791 {
4792     // If effectiveZoom is passed, it already factors in pageZoomFactor().
4793     return 1 / documentToAbsoluteScaleFactor(effectiveZoom);
4794 }
4795 
4796 FloatRect FrameView::absoluteToDocumentRect(FloatRect rect, Optional&lt;float&gt; effectiveZoom) const
4797 {
4798     rect.scale(absoluteToDocumentScaleFactor(effectiveZoom));
4799     return rect;
4800 }
4801 
4802 FloatPoint FrameView::absoluteToDocumentPoint(FloatPoint p, Optional&lt;float&gt; effectiveZoom) const
4803 {
4804     return p.scaled(absoluteToDocumentScaleFactor(effectiveZoom));
4805 }
4806 
4807 FloatRect FrameView::absoluteToClientRect(FloatRect rect, Optional&lt;float&gt; effectiveZoom) const
4808 {
4809     return documentToClientRect(absoluteToDocumentRect(rect, effectiveZoom));
4810 }
4811 
4812 FloatSize FrameView::documentToClientOffset() const
4813 {
4814     FloatSize clientOrigin = -toFloatSize(visibleContentRect().location());
4815 
4816     // Layout and visual viewports are affected by page zoom, so we need to factor that out.
4817     return clientOrigin.scaled(1 / (frame().pageZoomFactor() * frame().frameScaleFactor()));
4818 }
4819 
4820 FloatRect FrameView::documentToClientRect(FloatRect rect) const
4821 {
4822     rect.move(documentToClientOffset());
4823     return rect;
4824 }
4825 
4826 FloatPoint FrameView::documentToClientPoint(FloatPoint p) const
4827 {
4828     p.move(documentToClientOffset());
4829     return p;
4830 }
4831 
4832 FloatRect FrameView::clientToDocumentRect(FloatRect rect) const
4833 {
4834     rect.move(-documentToClientOffset());
4835     return rect;
4836 }
4837 
4838 FloatPoint FrameView::clientToDocumentPoint(FloatPoint point) const
4839 {
4840     point.move(-documentToClientOffset());
4841     return point;
4842 }
4843 
<a name="56" id="anc56"></a>







4844 FloatPoint FrameView::layoutViewportToAbsolutePoint(FloatPoint p) const
4845 {
4846     ASSERT(frame().settings().visualViewportEnabled());
4847     p.moveBy(layoutViewportRect().location());
4848     return p.scaled(frame().frameScaleFactor());
4849 }
4850 
<a name="57" id="anc57"></a>















4851 FloatRect FrameView::clientToLayoutViewportRect(FloatRect rect) const
4852 {
4853     ASSERT(frame().settings().visualViewportEnabled());
4854     rect.scale(frame().pageZoomFactor());
4855     return rect;
4856 }
4857 
4858 FloatPoint FrameView::clientToLayoutViewportPoint(FloatPoint p) const
4859 {
4860     ASSERT(frame().settings().visualViewportEnabled());
4861     return p.scaled(frame().pageZoomFactor());
4862 }
4863 
4864 void FrameView::setTracksRepaints(bool trackRepaints)
4865 {
4866     if (trackRepaints == m_isTrackingRepaints)
4867         return;
4868 
4869     // Force layout to flush out any pending repaints.
4870     if (trackRepaints) {
4871         if (frame().document())
4872             frame().document()-&gt;updateLayout();
4873     }
4874 
4875     for (Frame* frame = &amp;m_frame-&gt;tree().top(); frame; frame = frame-&gt;tree().traverseNext()) {
4876         if (RenderView* renderView = frame-&gt;contentRenderer())
4877             renderView-&gt;compositor().setTracksRepaints(trackRepaints);
4878     }
4879 
4880     resetTrackedRepaints();
4881     m_isTrackingRepaints = trackRepaints;
4882 }
4883 
4884 void FrameView::resetTrackedRepaints()
4885 {
4886     m_trackedRepaintRects.clear();
4887     if (RenderView* renderView = this-&gt;renderView())
4888         renderView-&gt;compositor().resetTrackedRepaintRects();
4889 }
4890 
4891 String FrameView::trackedRepaintRectsAsText() const
4892 {
4893     Frame&amp; frame = this-&gt;frame();
4894     Ref&lt;Frame&gt; protector(frame);
4895 
4896     if (auto* document = frame.document())
4897         document-&gt;updateLayout();
4898 
4899     TextStream ts;
4900     if (!m_trackedRepaintRects.isEmpty()) {
4901         ts &lt;&lt; &quot;(repaint rects\n&quot;;
4902         for (auto&amp; rect : m_trackedRepaintRects)
4903             ts &lt;&lt; &quot;  (rect &quot; &lt;&lt; LayoutUnit(rect.x()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.y()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.width()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.height()) &lt;&lt; &quot;)\n&quot;;
4904         ts &lt;&lt; &quot;)\n&quot;;
4905     }
4906     return ts.release();
4907 }
4908 
4909 bool FrameView::addScrollableArea(ScrollableArea* scrollableArea)
4910 {
4911     if (!m_scrollableAreas)
<a name="58" id="anc58"></a><span class="line-modified">4912         m_scrollableAreas = std::make_unique&lt;ScrollableAreaSet&gt;();</span>
4913 
4914     if (m_scrollableAreas-&gt;add(scrollableArea).isNewEntry) {
4915         scrollableAreaSetChanged();
4916         return true;
4917     }
4918 
4919     return false;
4920 }
4921 
4922 bool FrameView::removeScrollableArea(ScrollableArea* scrollableArea)
4923 {
4924     if (m_scrollableAreas &amp;&amp; m_scrollableAreas-&gt;remove(scrollableArea)) {
4925         scrollableAreaSetChanged();
4926         return true;
4927     }
4928     return false;
4929 }
4930 
4931 bool FrameView::containsScrollableArea(ScrollableArea* scrollableArea) const
4932 {
4933     return m_scrollableAreas &amp;&amp; m_scrollableAreas-&gt;contains(scrollableArea);
4934 }
4935 
4936 void FrameView::scrollableAreaSetChanged()
4937 {
4938     if (auto* page = frame().page()) {
4939         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
4940             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*this);
4941     }
4942 }
4943 
4944 void FrameView::sendScrollEvent()
4945 {
4946     frame().eventHandler().sendScrollEvent();
4947     frame().eventHandler().dispatchFakeMouseMoveEventSoon();
4948 }
4949 
4950 void FrameView::addChild(Widget&amp; widget)
4951 {
4952     if (is&lt;FrameView&gt;(widget)) {
4953         auto&amp; childFrameView = downcast&lt;FrameView&gt;(widget);
4954         if (childFrameView.isScrollable())
4955             addScrollableArea(&amp;childFrameView);
4956     }
4957 
4958     ScrollView::addChild(widget);
4959 }
4960 
4961 void FrameView::removeChild(Widget&amp; widget)
4962 {
4963     if (is&lt;FrameView&gt;(widget))
4964         removeScrollableArea(&amp;downcast&lt;FrameView&gt;(widget));
4965 
4966     ScrollView::removeChild(widget);
4967 }
4968 
4969 bool FrameView::wheelEvent(const PlatformWheelEvent&amp; wheelEvent)
4970 {
4971     // Note that to allow for rubber-band over-scroll behavior, even non-scrollable views
4972     // should handle wheel events.
4973 #if !ENABLE(RUBBER_BANDING)
4974     if (!isScrollable())
4975         return false;
4976 #endif
4977 
4978     if (delegatesScrolling()) {
4979         ScrollPosition oldPosition = scrollPosition();
4980         ScrollPosition newPosition = oldPosition - IntSize(wheelEvent.deltaX(), wheelEvent.deltaY());
4981         if (oldPosition != newPosition) {
4982             ScrollView::scrollTo(newPosition);
4983             scrollPositionChanged(oldPosition, scrollPosition());
4984             didChangeScrollOffset();
4985         }
4986         return true;
4987     }
4988 
4989     // We don&#39;t allow mouse wheeling to happen in a ScrollView that has had its scrollbars explicitly disabled.
4990     if (!canHaveScrollbars())
4991         return false;
4992 
4993     if (platformWidget())
4994         return false;
4995 
4996 #if ENABLE(ASYNC_SCROLLING)
4997     if (Page* page = frame().page()) {
4998         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator()) {
4999             if (scrollingCoordinator-&gt;coordinatesScrollingForFrameView(*this))
5000                 return scrollingCoordinator-&gt;handleWheelEvent(*this, wheelEvent) != ScrollingEventResult::DidNotHandleEvent;
5001         }
5002     }
5003 #endif
5004 
5005     return ScrollableArea::handleWheelEvent(wheelEvent);
5006 }
5007 
5008 
5009 bool FrameView::isVerticalDocument() const
5010 {
5011     RenderView* renderView = this-&gt;renderView();
5012     if (!renderView)
5013         return true;
5014 
5015     return renderView-&gt;style().isHorizontalWritingMode();
5016 }
5017 
5018 bool FrameView::isFlippedDocument() const
5019 {
5020     RenderView* renderView = this-&gt;renderView();
5021     if (!renderView)
5022         return false;
5023 
5024     return renderView-&gt;style().isFlippedBlocksWritingMode();
5025 }
5026 
5027 void FrameView::notifyWidgetsInAllFrames(WidgetNotification notification)
5028 {
5029     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
5030         if (FrameView* view = frame-&gt;view())
5031             view-&gt;notifyWidgets(notification);
5032     }
5033 }
5034 
5035 AXObjectCache* FrameView::axObjectCache() const
5036 {
5037     if (frame().document())
5038         return frame().document()-&gt;existingAXObjectCache();
5039     return nullptr;
5040 }
5041 
5042 #if PLATFORM(IOS_FAMILY)
5043 bool FrameView::useCustomFixedPositionLayoutRect() const
5044 {
5045     return !frame().settings().visualViewportEnabled() &amp;&amp; m_useCustomFixedPositionLayoutRect;
5046 }
5047 
5048 void FrameView::setCustomFixedPositionLayoutRect(const IntRect&amp; rect)
5049 {
5050     if (m_useCustomFixedPositionLayoutRect &amp;&amp; m_customFixedPositionLayoutRect == rect)
5051         return;
5052     m_useCustomFixedPositionLayoutRect = true;
5053     m_customFixedPositionLayoutRect = rect;
5054     updateContentsSize();
5055 }
5056 
5057 bool FrameView::updateFixedPositionLayoutRect()
5058 {
5059     if (!m_useCustomFixedPositionLayoutRect)
5060         return false;
5061 
5062     IntRect newRect;
5063     Page* page = frame().page();
5064     if (!page || !page-&gt;chrome().client().fetchCustomFixedPositionLayoutRect(newRect))
5065         return false;
5066 
5067     if (newRect != m_customFixedPositionLayoutRect) {
5068         m_customFixedPositionLayoutRect = newRect;
5069         setViewportConstrainedObjectsNeedLayout();
5070         return true;
5071     }
5072     return false;
5073 }
5074 
5075 void FrameView::setCustomSizeForResizeEvent(IntSize customSize)
5076 {
5077     m_useCustomSizeForResizeEvent = true;
5078     m_customSizeForResizeEvent = customSize;
5079     sendResizeEventIfNeeded();
5080 }
5081 
<a name="59" id="anc59"></a><span class="line-modified">5082 void FrameView::setScrollVelocity(double horizontalVelocity, double verticalVelocity, double scaleChangeRate, MonotonicTime timestamp)</span>
5083 {
5084     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
<a name="60" id="anc60"></a><span class="line-modified">5085         tiledBacking-&gt;setVelocity(VelocityData(horizontalVelocity, verticalVelocity, scaleChangeRate, timestamp));</span>
5086 }
5087 #endif // PLATFORM(IOS_FAMILY)
5088 
5089 void FrameView::setScrollingPerformanceLoggingEnabled(bool flag)
5090 {
5091     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
5092         tiledBacking-&gt;setScrollingPerformanceLoggingEnabled(flag);
5093 }
5094 
5095 void FrameView::didAddScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
5096 {
5097     ScrollableArea::didAddScrollbar(scrollbar, orientation);
5098     Page* page = frame().page();
5099     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())
5100         scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());
5101     if (AXObjectCache* cache = axObjectCache())
5102         cache-&gt;handleScrollbarUpdate(this);
5103 }
5104 
5105 void FrameView::willRemoveScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
5106 {
5107     ScrollableArea::willRemoveScrollbar(scrollbar, orientation);
5108     if (AXObjectCache* cache = axObjectCache()) {
5109         cache-&gt;remove(scrollbar);
5110         cache-&gt;handleScrollbarUpdate(this);
5111     }
5112 }
5113 
5114 void FrameView::addPaintPendingMilestones(OptionSet&lt;LayoutMilestone&gt; milestones)
5115 {
5116     m_milestonesPendingPaint.add(milestones);
5117 }
5118 
5119 void FrameView::fireLayoutRelatedMilestonesIfNeeded()
5120 {
5121     OptionSet&lt;LayoutMilestone&gt; requestedMilestones;
5122     OptionSet&lt;LayoutMilestone&gt; milestonesAchieved;
5123     Page* page = frame().page();
5124     if (page)
5125         requestedMilestones = page-&gt;requestedLayoutMilestones();
5126 
5127     if (m_firstLayoutCallbackPending) {
5128         m_firstLayoutCallbackPending = false;
5129         frame().loader().didFirstLayout();
5130         if (requestedMilestones &amp; DidFirstLayout)
5131             milestonesAchieved.add(DidFirstLayout);
5132         if (frame().isMainFrame())
5133             page-&gt;startCountingRelevantRepaintedObjects();
5134     }
5135 
5136     if (!m_isVisuallyNonEmpty &amp;&amp; qualifiesAsVisuallyNonEmpty()) {
5137         m_isVisuallyNonEmpty = true;
5138         addPaintPendingMilestones(DidFirstMeaningfulPaint);
5139         if (requestedMilestones &amp; DidFirstVisuallyNonEmptyLayout)
5140             milestonesAchieved.add(DidFirstVisuallyNonEmptyLayout);
5141     }
5142 
5143     if (!m_renderedSignificantAmountOfText &amp;&amp; qualifiesAsSignificantRenderedText()) {
5144         m_renderedSignificantAmountOfText = true;
5145         if (requestedMilestones &amp; DidRenderSignificantAmountOfText)
5146             milestonesAchieved.add(DidRenderSignificantAmountOfText);
5147     }
5148 
5149     if (milestonesAchieved &amp;&amp; frame().isMainFrame()) {
5150         if (milestonesAchieved.contains(DidFirstVisuallyNonEmptyLayout))
5151             RELEASE_LOG_IF_ALLOWED(&quot;fireLayoutRelatedMilestonesIfNeeded() - firing first visually non-empty layout milestone on the main frame&quot;);
5152         frame().loader().didReachLayoutMilestone(milestonesAchieved);
5153     }
5154 }
5155 
5156 void FrameView::firePaintRelatedMilestonesIfNeeded()
5157 {
5158     Page* page = frame().page();
5159     if (!page)
5160         return;
5161 
5162     OptionSet&lt;LayoutMilestone&gt; milestonesAchieved;
5163 
5164     // Make sure the pending paint milestones have actually been requested before we send them.
5165     if (m_milestonesPendingPaint &amp; DidFirstFlushForHeaderLayer) {
5166         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstFlushForHeaderLayer)
5167             milestonesAchieved.add(DidFirstFlushForHeaderLayer);
5168     }
5169 
5170     if (m_milestonesPendingPaint &amp; DidFirstPaintAfterSuppressedIncrementalRendering) {
5171         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstPaintAfterSuppressedIncrementalRendering)
5172             milestonesAchieved.add(DidFirstPaintAfterSuppressedIncrementalRendering);
5173     }
5174 
5175     if (m_milestonesPendingPaint &amp; DidFirstMeaningfulPaint) {
5176         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstMeaningfulPaint)
5177             milestonesAchieved.add(DidFirstMeaningfulPaint);
5178     }
5179 
5180     m_milestonesPendingPaint = { };
5181 
5182     if (milestonesAchieved)
5183         page-&gt;mainFrame().loader().didReachLayoutMilestone(milestonesAchieved);
5184 }
5185 
5186 void FrameView::setVisualUpdatesAllowedByClient(bool visualUpdatesAllowed)
5187 {
5188     if (m_visualUpdatesAllowedByClient == visualUpdatesAllowed)
5189         return;
5190 
5191     m_visualUpdatesAllowedByClient = visualUpdatesAllowed;
5192 
5193     frame().document()-&gt;setVisualUpdatesAllowedByClient(visualUpdatesAllowed);
5194 }
5195 
5196 void FrameView::setScrollPinningBehavior(ScrollPinningBehavior pinning)
5197 {
5198     m_scrollPinningBehavior = pinning;
5199 
5200     if (Page* page = frame().page()) {
5201         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
5202             scrollingCoordinator-&gt;setScrollPinningBehavior(pinning);
5203     }
5204 
5205     updateScrollbars(scrollPosition());
5206 }
5207 
5208 ScrollBehaviorForFixedElements FrameView::scrollBehaviorForFixedElements() const
5209 {
5210     return frame().settings().backgroundShouldExtendBeyondPage() ? StickToViewportBounds : StickToDocumentBounds;
5211 }
5212 
5213 RenderView* FrameView::renderView() const
5214 {
5215     return frame().contentRenderer();
5216 }
5217 
5218 int FrameView::mapFromLayoutToCSSUnits(LayoutUnit value) const
5219 {
5220     return value / (frame().pageZoomFactor() * frame().frameScaleFactor());
5221 }
5222 
5223 LayoutUnit FrameView::mapFromCSSToLayoutUnits(int value) const
5224 {
<a name="61" id="anc61"></a><span class="line-modified">5225     return value * frame().pageZoomFactor() * frame().frameScaleFactor();</span>
5226 }
5227 
5228 void FrameView::didAddWidgetToRenderTree(Widget&amp; widget)
5229 {
5230     ASSERT(!m_widgetsInRenderTree.contains(&amp;widget));
5231     m_widgetsInRenderTree.add(&amp;widget);
5232 }
5233 
5234 void FrameView::willRemoveWidgetFromRenderTree(Widget&amp; widget)
5235 {
5236     ASSERT(m_widgetsInRenderTree.contains(&amp;widget));
5237     m_widgetsInRenderTree.remove(&amp;widget);
5238 }
5239 
5240 static Vector&lt;RefPtr&lt;Widget&gt;&gt; collectAndProtectWidgets(const HashSet&lt;Widget*&gt;&amp; set)
5241 {
5242     return copyToVectorOf&lt;RefPtr&lt;Widget&gt;&gt;(set);
5243 }
5244 
5245 void FrameView::updateWidgetPositions()
5246 {
5247     m_updateWidgetPositionsTimer.stop();
5248     // updateWidgetPosition() can possibly cause layout to be re-entered (via plug-ins running
5249     // scripts in response to NPP_SetWindow, for example), so we need to keep the Widgets
5250     // alive during enumeration.
5251     for (auto&amp; widget : collectAndProtectWidgets(m_widgetsInRenderTree)) {
5252         if (auto* renderer = RenderWidget::find(*widget)) {
5253             auto ignoreWidgetState = renderer-&gt;updateWidgetPosition();
5254             UNUSED_PARAM(ignoreWidgetState);
5255         }
5256     }
5257 }
5258 
5259 void FrameView::scheduleUpdateWidgetPositions()
5260 {
5261     if (!m_updateWidgetPositionsTimer.isActive())
5262         m_updateWidgetPositionsTimer.startOneShot(0_s);
5263 }
5264 
5265 void FrameView::updateWidgetPositionsTimerFired()
5266 {
5267     updateWidgetPositions();
5268 }
5269 
5270 void FrameView::notifyWidgets(WidgetNotification notification)
5271 {
5272     for (auto&amp; widget : collectAndProtectWidgets(m_widgetsInRenderTree))
5273         widget-&gt;notifyWidget(notification);
5274 }
5275 
5276 void FrameView::setViewExposedRect(Optional&lt;FloatRect&gt; viewExposedRect)
5277 {
5278     if (m_viewExposedRect == viewExposedRect)
5279         return;
5280 
5281     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; setViewExposedRect &quot; &lt;&lt; (viewExposedRect ? viewExposedRect.value() : FloatRect()));
5282 
5283     bool hasRectChanged = !m_viewExposedRect == !viewExposedRect;
5284     m_viewExposedRect = viewExposedRect;
5285 
5286     // FIXME: We should support clipping to the exposed rect for subframes as well.
5287     if (!frame().isMainFrame())
5288         return;
5289 
5290     if (TiledBacking* tiledBacking = this-&gt;tiledBacking()) {
5291         if (hasRectChanged)
5292             updateTiledBackingAdaptiveSizing();
5293         adjustTiledBackingCoverage();
5294         tiledBacking-&gt;setTiledScrollingIndicatorPosition(m_viewExposedRect ? m_viewExposedRect.value().location() : FloatPoint());
5295     }
5296 
5297     if (auto* view = renderView())
5298         view-&gt;compositor().scheduleLayerFlush(false /* canThrottle */);
5299 
5300     if (auto* page = frame().page())
5301         page-&gt;pageOverlayController().didChangeViewExposedRect();
5302 }
5303 
5304 void FrameView::clearViewportSizeOverrideForCSSViewportUnits()
5305 {
5306     if (!m_overrideViewportSize)
5307         return;
5308 
5309     m_overrideViewportSize = WTF::nullopt;
5310     if (auto* document = frame().document())
5311         document-&gt;styleScope().didChangeStyleSheetEnvironment();
5312 }
5313 
5314 void FrameView::setViewportSizeForCSSViewportUnits(IntSize size)
5315 {
5316     overrideViewportSizeForCSSViewportUnits({ size.width(), size.height() });
5317 }
5318 
5319 void FrameView::overrideViewportSizeForCSSViewportUnits(OverrideViewportSize size)
5320 {
5321     if (m_overrideViewportSize &amp;&amp; *m_overrideViewportSize == size)
5322         return;
5323 
5324     m_overrideViewportSize = size;
5325 
5326     if (auto* document = frame().document())
5327         document-&gt;styleScope().didChangeStyleSheetEnvironment();
5328 }
5329 
5330 IntSize FrameView::viewportSizeForCSSViewportUnits() const
5331 {
5332     OverrideViewportSize viewportSize;
5333 
5334     if (m_overrideViewportSize) {
5335         viewportSize = *m_overrideViewportSize;
5336         // auto-size overrides the width only, so we can&#39;t always bail out early here.
5337         if (viewportSize.width &amp;&amp; viewportSize.height)
5338             return { *viewportSize.width, *viewportSize.height };
5339     }
5340 
5341     if (useFixedLayout()) {
5342         auto fixedLayoutSize = this-&gt;fixedLayoutSize();
5343         viewportSize.width = viewportSize.width.valueOr(fixedLayoutSize.width());
5344         viewportSize.height = viewportSize.height.valueOr(fixedLayoutSize.height());
5345         return { *viewportSize.width, *viewportSize.height };
5346     }
5347 
5348     // FIXME: the value returned should take into account the value of the overflow
5349     // property on the root element.
5350     auto visibleContentSizeIncludingScrollbars = visibleContentRectIncludingScrollbars().size();
5351     viewportSize.width = viewportSize.width.valueOr(visibleContentSizeIncludingScrollbars.width());
5352     viewportSize.height = viewportSize.height.valueOr(visibleContentSizeIncludingScrollbars.height());
5353     return { *viewportSize.width, *viewportSize.height };
5354 }
5355 
5356 bool FrameView::shouldPlaceBlockDirectionScrollbarOnLeft() const
5357 {
5358     return renderView() &amp;&amp; renderView()-&gt;shouldPlaceBlockDirectionScrollbarOnLeft();
5359 }
5360 
5361 } // namespace WebCore
<a name="62" id="anc62"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="62" type="hidden" />
</body>
</html>