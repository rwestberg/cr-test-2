<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderImage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
  5  *           (C) 2006 Allan Sandfeld Jensen (kde@carewolf.com)
  6  *           (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
  7  * Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.
  8  * Copyright (C) 2010 Google Inc. All rights reserved.
  9  * Copyright (C) Research In Motion Limited 2011-2012. All rights reserved.
 10  *
 11  * This library is free software; you can redistribute it and/or
 12  * modify it under the terms of the GNU Library General Public
 13  * License as published by the Free Software Foundation; either
 14  * version 2 of the License, or (at your option) any later version.
 15  *
 16  * This library is distributed in the hope that it will be useful,
 17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 19  * Library General Public License for more details.
 20  *
 21  * You should have received a copy of the GNU Library General Public License
 22  * along with this library; see the file COPYING.LIB.  If not, write to
 23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 24  * Boston, MA 02110-1301, USA.
 25  *
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;RenderImage.h&quot;
 30 
 31 #include &quot;AXObjectCache.h&quot;
 32 #include &quot;BitmapImage.h&quot;
 33 #include &quot;CachedImage.h&quot;
 34 #include &quot;FocusController.h&quot;
 35 #include &quot;FontCache.h&quot;
 36 #include &quot;FontCascade.h&quot;
 37 #include &quot;Frame.h&quot;
 38 #include &quot;FrameSelection.h&quot;
 39 #include &quot;GeometryUtilities.h&quot;
 40 #include &quot;GraphicsContext.h&quot;
 41 #include &quot;HTMLAreaElement.h&quot;
 42 #include &quot;HTMLImageElement.h&quot;
 43 #include &quot;HTMLInputElement.h&quot;
 44 #include &quot;HTMLMapElement.h&quot;
 45 #include &quot;HTMLNames.h&quot;
 46 #include &quot;HitTestResult.h&quot;
 47 #include &quot;InlineElementBox.h&quot;
 48 #include &quot;Page.h&quot;
 49 #include &quot;PaintInfo.h&quot;
 50 #include &quot;RenderFragmentedFlow.h&quot;
 51 #include &quot;RenderImageResourceStyleImage.h&quot;
 52 #include &quot;RenderLayoutState.h&quot;
 53 #include &quot;RenderTheme.h&quot;
 54 #include &quot;RenderView.h&quot;
 55 #include &quot;RuntimeEnabledFeatures.h&quot;
 56 #include &quot;SVGImage.h&quot;
 57 #include &quot;Settings.h&quot;
 58 #include &lt;wtf/IsoMallocInlines.h&gt;
 59 #include &lt;wtf/StackStats.h&gt;
 60 
 61 #if PLATFORM(IOS_FAMILY)
 62 #include &quot;LogicalSelectionOffsetCaches.h&quot;
 63 #include &quot;SelectionRect.h&quot;
 64 #endif
 65 
 66 #if USE(CG)
 67 #include &quot;PDFDocumentImage.h&quot;
 68 #include &quot;Settings.h&quot;
 69 #endif
 70 
 71 namespace WebCore {
 72 
 73 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderImage);
 74 
 75 #if PLATFORM(IOS_FAMILY)
 76 // FIXME: This doesn&#39;t behave correctly for floating or positioned images, but WebCore doesn&#39;t handle those well
 77 // during selection creation yet anyway.
 78 // FIXME: We can&#39;t tell whether or not we contain the start or end of the selected Range using only the offsets
 79 // of the start and end, we need to know the whole Position.
 80 void RenderImage::collectSelectionRects(Vector&lt;SelectionRect&gt;&amp; rects, unsigned, unsigned)
 81 {
 82     RenderBlock* containingBlock = this-&gt;containingBlock();
 83 
 84     IntRect imageRect;
 85     // FIXME: It doesn&#39;t make sense to package line bounds into SelectionRects. We should find
 86     // the right and left extent of the selection once for the entire selected Range, perhaps
 87     // using the Range&#39;s common ancestor.
 88     IntRect lineExtentRect;
 89     bool isFirstOnLine = false;
 90     bool isLastOnLine = false;
 91 
 92     InlineBox* inlineBox = inlineBoxWrapper();
 93     if (!inlineBox) {
 94         // This is a block image.
 95         imageRect = IntRect(0, 0, width(), height());
 96         isFirstOnLine = true;
 97         isLastOnLine = true;
 98         lineExtentRect = imageRect;
 99         if (containingBlock-&gt;isHorizontalWritingMode()) {
100             lineExtentRect.setX(containingBlock-&gt;x());
101             lineExtentRect.setWidth(containingBlock-&gt;width());
102         } else {
103             lineExtentRect.setY(containingBlock-&gt;y());
104             lineExtentRect.setHeight(containingBlock-&gt;height());
105         }
106     } else {
107         LayoutUnit selectionTop = !containingBlock-&gt;style().isFlippedBlocksWritingMode() ? inlineBox-&gt;root().selectionTop() - logicalTop() : logicalBottom() - inlineBox-&gt;root().selectionBottom();
108         imageRect = IntRect(0,  selectionTop, logicalWidth(), inlineBox-&gt;root().selectionHeight());
109         isFirstOnLine = !inlineBox-&gt;previousOnLineExists();
110         isLastOnLine = !inlineBox-&gt;nextOnLineExists();
111         LogicalSelectionOffsetCaches cache(*containingBlock);
<a name="1" id="anc1"></a><span class="line-modified">112         LayoutUnit leftOffset = containingBlock-&gt;logicalLeftSelectionOffset(*containingBlock, LayoutUnit(inlineBox-&gt;logicalTop()), cache);</span>
<span class="line-modified">113         LayoutUnit rightOffset = containingBlock-&gt;logicalRightSelectionOffset(*containingBlock, LayoutUnit(inlineBox-&gt;logicalTop()), cache);</span>
114         lineExtentRect = IntRect(leftOffset - logicalLeft(), imageRect.y(), rightOffset - leftOffset, imageRect.height());
115         if (!inlineBox-&gt;isHorizontal()) {
116             imageRect = imageRect.transposedRect();
117             lineExtentRect = lineExtentRect.transposedRect();
118         }
119     }
120 
121     bool isFixed = false;
122     IntRect absoluteBounds = localToAbsoluteQuad(FloatRect(imageRect), UseTransforms, &amp;isFixed).enclosingBoundingBox();
123     IntRect lineExtentBounds = localToAbsoluteQuad(FloatRect(lineExtentRect)).enclosingBoundingBox();
124     if (!containingBlock-&gt;isHorizontalWritingMode())
125         lineExtentBounds = lineExtentBounds.transposedRect();
126 
127     // FIXME: We should consider either making SelectionRect a struct or better organize its optional fields into
128     // an auxiliary struct to simplify its initialization.
129     rects.append(SelectionRect(absoluteBounds, containingBlock-&gt;style().direction(), lineExtentBounds.x(), lineExtentBounds.maxX(), lineExtentBounds.maxY(), 0, false /* line break */, isFirstOnLine, isLastOnLine, false /* contains start */, false /* contains end */, containingBlock-&gt;style().isHorizontalWritingMode(), isFixed, false /* ruby text */, view().pageNumberForBlockProgressionOffset(absoluteBounds.x())));
130 }
131 #endif
132 
133 using namespace HTMLNames;
134 
135 RenderImage::RenderImage(Element&amp; element, RenderStyle&amp;&amp; style, StyleImage* styleImage, const float imageDevicePixelRatio)
136     : RenderReplaced(element, WTFMove(style), IntSize())
<a name="2" id="anc2"></a><span class="line-modified">137     , m_imageResource(styleImage ? makeUnique&lt;RenderImageResourceStyleImage&gt;(*styleImage) : makeUnique&lt;RenderImageResource&gt;())</span>
138     , m_imageDevicePixelRatio(imageDevicePixelRatio)
139 {
140     updateAltText();
141     if (is&lt;HTMLImageElement&gt;(element))
142         m_hasShadowControls = downcast&lt;HTMLImageElement&gt;(element).hasShadowControls();
143 }
144 
145 RenderImage::RenderImage(Document&amp; document, RenderStyle&amp;&amp; style, StyleImage* styleImage)
146     : RenderReplaced(document, WTFMove(style), IntSize())
<a name="3" id="anc3"></a><span class="line-modified">147     , m_imageResource(styleImage ? makeUnique&lt;RenderImageResourceStyleImage&gt;(*styleImage) : makeUnique&lt;RenderImageResource&gt;())</span>
148 {
149 }
150 
151 RenderImage::~RenderImage()
152 {
153     // Do not add any code here. Add it to willBeDestroyed() instead.
154 }
155 
156 void RenderImage::willBeDestroyed()
157 {
158     imageResource().shutdown();
159     RenderReplaced::willBeDestroyed();
160 }
161 
162 // If we&#39;ll be displaying either alt text or an image, add some padding.
163 static const unsigned short paddingWidth = 4;
164 static const unsigned short paddingHeight = 4;
165 
166 // Alt text is restricted to this maximum size, in pixels.  These are
167 // signed integers because they are compared with other signed values.
168 static const float maxAltTextWidth = 1024;
169 static const int maxAltTextHeight = 256;
170 
171 IntSize RenderImage::imageSizeForError(CachedImage* newImage) const
172 {
173     ASSERT_ARG(newImage, newImage);
174     ASSERT_ARG(newImage, newImage-&gt;imageForRenderer(this));
175 
176     FloatSize imageSize;
177     if (newImage-&gt;willPaintBrokenImage()) {
178         std::pair&lt;Image*, float&gt; brokenImageAndImageScaleFactor = newImage-&gt;brokenImage(document().deviceScaleFactor());
179         imageSize = brokenImageAndImageScaleFactor.first-&gt;size();
180         imageSize.scale(1 / brokenImageAndImageScaleFactor.second);
181     } else
182         imageSize = newImage-&gt;imageForRenderer(this)-&gt;size();
183 
184     // imageSize() returns 0 for the error image. We need the true size of the
185     // error image, so we have to get it by grabbing image() directly.
186     return IntSize(paddingWidth + imageSize.width() * style().effectiveZoom(), paddingHeight + imageSize.height() * style().effectiveZoom());
187 }
188 
189 // Sets the image height and width to fit the alt text.  Returns true if the
190 // image size changed.
191 ImageSizeChangeType RenderImage::setImageSizeForAltText(CachedImage* newImage /* = 0 */)
192 {
193     IntSize imageSize;
194     if (newImage &amp;&amp; newImage-&gt;imageForRenderer(this))
195         imageSize = imageSizeForError(newImage);
196     else if (!m_altText.isEmpty() || newImage) {
197         // If we&#39;ll be displaying either text or an image, add a little padding.
198         imageSize = IntSize(paddingWidth, paddingHeight);
199     }
200 
201     // we have an alt and the user meant it (its not a text we invented)
202     if (!m_altText.isEmpty()) {
203         const FontCascade&amp; font = style().fontCascade();
204         IntSize paddedTextSize(paddingWidth + std::min(ceilf(font.width(RenderBlock::constructTextRun(m_altText, style()))), maxAltTextWidth), paddingHeight + std::min(font.fontMetrics().height(), maxAltTextHeight));
205         imageSize = imageSize.expandedTo(paddedTextSize);
206     }
207 
208     if (imageSize == intrinsicSize())
209         return ImageSizeChangeNone;
210 
211     setIntrinsicSize(imageSize);
212     return ImageSizeChangeForAltText;
213 }
214 
215 bool RenderImage::isEditableImage() const
216 {
217     if (!element() || !is&lt;HTMLImageElement&gt;(element()))
218         return false;
219     return downcast&lt;HTMLImageElement&gt;(element())-&gt;hasEditableImageAttribute();
220 }
221 
222 bool RenderImage::requiresLayer() const
223 {
224     if (RenderReplaced::requiresLayer())
225         return true;
226 
227     if (isEditableImage())
228         return true;
229 
230     return false;
231 }
232 
233 void RenderImage::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
234 {
235     if (!hasInitializedStyle())
236         imageResource().initialize(*this);
237     RenderReplaced::styleWillChange(diff, newStyle);
238 }
239 
240 void RenderImage::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
241 {
242     RenderReplaced::styleDidChange(diff, oldStyle);
243     if (m_needsToSetSizeForAltText) {
244         if (!m_altText.isEmpty() &amp;&amp; setImageSizeForAltText(cachedImage()))
245             repaintOrMarkForLayout(ImageSizeChangeForAltText);
246         m_needsToSetSizeForAltText = false;
247     }
248 #if ENABLE(CSS_IMAGE_ORIENTATION)
249     if (diff == StyleDifference::Layout &amp;&amp; oldStyle-&gt;imageOrientation() != style().imageOrientation())
250         return repaintOrMarkForLayout(ImageSizeChangeNone);
251 #endif
252 
253 #if ENABLE(CSS_IMAGE_RESOLUTION)
254     if (diff == StyleDifference::Layout
255         &amp;&amp; (oldStyle-&gt;imageResolution() != style().imageResolution()
256             || oldStyle-&gt;imageResolutionSnap() != style().imageResolutionSnap()
257             || oldStyle-&gt;imageResolutionSource() != style().imageResolutionSource()))
258         repaintOrMarkForLayout(ImageSizeChangeNone);
259 #endif
260 }
261 
262 void RenderImage::imageChanged(WrappedImagePtr newImage, const IntRect* rect)
263 {
264     if (renderTreeBeingDestroyed())
265         return;
266 
267     if (hasVisibleBoxDecorations() || hasMask() || hasShapeOutside())
268         RenderReplaced::imageChanged(newImage, rect);
269 
270     if (newImage != imageResource().imagePtr() || !newImage)
271         return;
272 
<a name="4" id="anc4"></a><span class="line-modified">273     // At a zoom level of 1 the image is guaranteed to have an integer size.</span>
<span class="line-modified">274     incrementVisuallyNonEmptyPixelCountIfNeeded(flooredIntSize(imageResource().imageSize(1.0f)));</span>



275 
276     ImageSizeChangeType imageSizeChange = ImageSizeChangeNone;
277 
278     // Set image dimensions, taking into account the size of the alt text.
279     if (imageResource().errorOccurred()) {
280         if (!m_altText.isEmpty() &amp;&amp; document().hasPendingStyleRecalc()) {
281             ASSERT(element());
282             if (element()) {
283                 m_needsToSetSizeForAltText = true;
284                 element()-&gt;invalidateStyle();
285             }
286             return;
287         }
288         imageSizeChange = setImageSizeForAltText(cachedImage());
289     }
290     repaintOrMarkForLayout(imageSizeChange, rect);
291     if (AXObjectCache* cache = document().existingAXObjectCache())
292         cache-&gt;deferRecomputeIsIgnoredIfNeeded(element());
293 }
294 
295 void RenderImage::updateIntrinsicSizeIfNeeded(const LayoutSize&amp; newSize)
296 {
297     if (imageResource().errorOccurred() || !m_imageResource-&gt;cachedImage())
298         return;
299     setIntrinsicSize(newSize);
300 }
301 
302 void RenderImage::updateInnerContentRect()
303 {
304     // Propagate container size to image resource.
305     IntSize containerSize(replacedContentRect().size());
306     if (!containerSize.isEmpty()) {
307         URL imageSourceURL;
308         if (HTMLImageElement* imageElement = is&lt;HTMLImageElement&gt;(element()) ? downcast&lt;HTMLImageElement&gt;(element()) : nullptr)
309             imageSourceURL = document().completeURL(imageElement-&gt;imageSourceURL());
310         imageResource().setContainerContext(containerSize, imageSourceURL);
311     }
312 }
313 
314 void RenderImage::repaintOrMarkForLayout(ImageSizeChangeType imageSizeChange, const IntRect* rect)
315 {
316 #if ENABLE(CSS_IMAGE_RESOLUTION)
317     double scale = style().imageResolution();
318     if (style().imageResolutionSnap() == ImageResolutionSnap::Pixels)
319         scale = roundForImpreciseConversion&lt;int&gt;(scale);
320     if (scale &lt;= 0)
321         scale = 1;
322     LayoutSize newIntrinsicSize = imageResource().intrinsicSize(style().effectiveZoom() / scale);
323 #else
324     LayoutSize newIntrinsicSize = imageResource().intrinsicSize(style().effectiveZoom());
325 #endif
326     LayoutSize oldIntrinsicSize = intrinsicSize();
327 
328     updateIntrinsicSizeIfNeeded(newIntrinsicSize);
329 
330     // In the case of generated image content using :before/:after/content, we might not be
331     // in the render tree yet. In that case, we just need to update our intrinsic size.
332     // layout() will be called after we are inserted in the tree which will take care of
333     // what we are doing here.
334     if (!containingBlock())
335         return;
336 
337     bool imageSourceHasChangedSize = oldIntrinsicSize != newIntrinsicSize || imageSizeChange != ImageSizeChangeNone;
338 
339     if (imageSourceHasChangedSize &amp;&amp; setNeedsLayoutIfNeededAfterIntrinsicSizeChange())
340         return;
341 
342     if (everHadLayout() &amp;&amp; !selfNeedsLayout()) {
343         // The inner content rectangle is calculated during layout, but may need an update now
344         // (unless the box has already been scheduled for layout). In order to calculate it, we
345         // may need values from the containing block, though, so make sure that we&#39;re not too
346         // early. It may be that layout hasn&#39;t even taken place once yet.
347 
348         // FIXME: we should not have to trigger another call to setContainerContextForRenderer()
349         // from here, since it&#39;s already being done during layout.
350         updateInnerContentRect();
351     }
352 
353     LayoutRect repaintRect = contentBoxRect();
354     if (rect) {
355         // The image changed rect is in source image coordinates (pre-zooming),
356         // so map from the bounds of the image to the contentsBox.
357         repaintRect.intersect(enclosingIntRect(mapRect(*rect, FloatRect(FloatPoint(), imageResource().imageSize(1.0f)), repaintRect)));
358     }
359 
360     repaintRectangle(repaintRect);
361 
362     // Tell any potential compositing layers that the image needs updating.
363     contentChanged(ImageChanged);
364 }
365 
366 void RenderImage::notifyFinished(CachedResource&amp; newImage)
367 {
368     if (renderTreeBeingDestroyed())
369         return;
370 
371     invalidateBackgroundObscurationStatus();
372 
373     if (&amp;newImage == cachedImage()) {
374         // tell any potential compositing layers
375         // that the image is done and they can reference it directly.
376         contentChanged(ImageChanged);
377     }
<a name="5" id="anc5"></a><span class="line-added">378 </span>
<span class="line-added">379     if (is&lt;HTMLImageElement&gt;(element()))</span>
<span class="line-added">380         page().didFinishLoadingImageForElement(downcast&lt;HTMLImageElement&gt;(*element()));</span>
381 }
382 
383 bool RenderImage::isShowingMissingOrImageError() const
384 {
385     return !imageResource().cachedImage() || imageResource().errorOccurred();
386 }
387 
388 bool RenderImage::isShowingAltText() const
389 {
390     return isShowingMissingOrImageError() &amp;&amp; !m_altText.isEmpty();
391 }
392 
393 bool RenderImage::hasNonBitmapImage() const
394 {
395     if (!imageResource().cachedImage())
396         return false;
397 
398     Image* image = cachedImage()-&gt;imageForRenderer(this);
399     return image &amp;&amp; !is&lt;BitmapImage&gt;(image);
400 }
401 
402 void RenderImage::paintIncompleteImageOutline(PaintInfo&amp; paintInfo, LayoutPoint paintOffset, LayoutUnit borderWidth) const
403 {
404     auto contentSize = this-&gt;contentSize();
405     if (contentSize.width() &lt;= 2 || contentSize.height() &lt;= 2)
406         return;
407 
408     auto leftBorder = borderLeft();
409     auto topBorder = borderTop();
410     auto leftPadding = paddingLeft();
411     auto topPadding = paddingTop();
412 
413     // Draw an outline rect where the image should be.
414     GraphicsContext&amp; context = paintInfo.context();
415     context.setStrokeStyle(SolidStroke);
416     context.setStrokeColor(Color::lightGray);
417     context.setFillColor(Color::transparent);
418     context.drawRect(snapRectToDevicePixels(LayoutRect({ paintOffset.x() + leftBorder + leftPadding, paintOffset.y() + topBorder + topPadding }, contentSize), document().deviceScaleFactor()), borderWidth);
419 }
420 
421 void RenderImage::paintReplaced(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
422 {
423     GraphicsContext&amp; context = paintInfo.context();
424     if (context.invalidatingImagesWithAsyncDecodes()) {
425         if (cachedImage() &amp;&amp; cachedImage()-&gt;isClientWaitingForAsyncDecoding(*this))
426             cachedImage()-&gt;removeAllClientsWaitingForAsyncDecoding();
427         return;
428     }
429 
430     auto contentSize = this-&gt;contentSize();
431     float deviceScaleFactor = document().deviceScaleFactor();
432     LayoutUnit missingImageBorderWidth(1 / deviceScaleFactor);
433 
434     if (!imageResource().cachedImage() || imageResource().errorOccurred()) {
435         if (paintInfo.phase == PaintPhase::Selection)
436             return;
437 
438         if (paintInfo.phase == PaintPhase::Foreground)
439             page().addRelevantUnpaintedObject(this, visualOverflowRect());
440 
441         paintIncompleteImageOutline(paintInfo, paintOffset, missingImageBorderWidth);
442 
443         if (contentSize.width() &gt; 2 &amp;&amp; contentSize.height() &gt; 2) {
444             LayoutUnit leftBorder = borderLeft();
445             LayoutUnit topBorder = borderTop();
446             LayoutUnit leftPad = paddingLeft();
447             LayoutUnit topPad = paddingTop();
448 
449             bool errorPictureDrawn = false;
450             LayoutSize imageOffset;
451             // When calculating the usable dimensions, exclude the pixels of
452             // the ouline rect so the error image/alt text doesn&#39;t draw on it.
453             LayoutSize usableSize = contentSize - LayoutSize(2 * missingImageBorderWidth, 2 * missingImageBorderWidth);
454 
455             RefPtr&lt;Image&gt; image = imageResource().image();
456 
457             if (imageResource().errorOccurred() &amp;&amp; !image-&gt;isNull() &amp;&amp; usableSize.width() &gt;= image-&gt;width() &amp;&amp; usableSize.height() &gt;= image-&gt;height()) {
458                 // Call brokenImage() explicitly to ensure we get the broken image icon at the appropriate resolution.
459                 std::pair&lt;Image*, float&gt; brokenImageAndImageScaleFactor = cachedImage()-&gt;brokenImage(deviceScaleFactor);
460                 image = brokenImageAndImageScaleFactor.first;
461                 FloatSize imageSize = image-&gt;size();
462                 imageSize.scale(1 / brokenImageAndImageScaleFactor.second);
463                 // Center the error image, accounting for border and padding.
<a name="6" id="anc6"></a><span class="line-modified">464                 LayoutUnit centerX { (usableSize.width() - imageSize.width()) / 2 };</span>
465                 if (centerX &lt; 0)
466                     centerX = 0;
<a name="7" id="anc7"></a><span class="line-modified">467                 LayoutUnit centerY { (usableSize.height() - imageSize.height()) / 2 };</span>
468                 if (centerY &lt; 0)
469                     centerY = 0;
470                 imageOffset = LayoutSize(leftBorder + leftPad + centerX + missingImageBorderWidth, topBorder + topPad + centerY + missingImageBorderWidth);
471 
<a name="8" id="anc8"></a><span class="line-modified">472                 context.drawImage(*image, snapRectToDevicePixels(LayoutRect(paintOffset + imageOffset, imageSize), deviceScaleFactor), { imageOrientation() });</span>




473                 errorPictureDrawn = true;
474             }
475 
476             if (!m_altText.isEmpty()) {
477                 String text = document().displayStringModifiedByEncoding(m_altText);
478                 context.setFillColor(style().visitedDependentColorWithColorFilter(CSSPropertyColor));
479                 const FontCascade&amp; font = style().fontCascade();
480                 const FontMetrics&amp; fontMetrics = font.fontMetrics();
481                 LayoutUnit ascent = fontMetrics.ascent();
482                 LayoutPoint altTextOffset = paintOffset;
483                 altTextOffset.move(leftBorder + leftPad + (paddingWidth / 2) - missingImageBorderWidth, topBorder + topPad + ascent + (paddingHeight / 2) - missingImageBorderWidth);
484 
485                 // Only draw the alt text if it&#39;ll fit within the content box,
486                 // and only if it fits above the error image.
487                 TextRun textRun = RenderBlock::constructTextRun(text, style());
<a name="9" id="anc9"></a><span class="line-modified">488                 LayoutUnit textWidth { font.width(textRun) };</span>
489                 if (errorPictureDrawn) {
490                     if (usableSize.width() &gt;= textWidth &amp;&amp; fontMetrics.height() &lt;= imageOffset.height())
491                         context.drawText(font, textRun, altTextOffset);
492                 } else if (usableSize.width() &gt;= textWidth &amp;&amp; usableSize.height() &gt;= fontMetrics.height())
493                     context.drawText(font, textRun, altTextOffset);
494             }
495         }
496         return;
497     }
498 
499     if (contentSize.isEmpty())
500         return;
501 
502     bool showBorderForIncompleteImage = settings().incompleteImageBorderEnabled();
503 
504     RefPtr&lt;Image&gt; img = imageResource().image(flooredIntSize(contentSize));
505     if (!img || img-&gt;isNull()) {
506         if (showBorderForIncompleteImage)
507             paintIncompleteImageOutline(paintInfo, paintOffset, missingImageBorderWidth);
508 
509         if (paintInfo.phase == PaintPhase::Foreground)
510             page().addRelevantUnpaintedObject(this, visualOverflowRect());
511         return;
512     }
513 
514     LayoutRect contentBoxRect = this-&gt;contentBoxRect();
515     contentBoxRect.moveBy(paintOffset);
516     LayoutRect replacedContentRect = this-&gt;replacedContentRect();
517     replacedContentRect.moveBy(paintOffset);
518     bool clip = !contentBoxRect.contains(replacedContentRect);
519     GraphicsContextStateSaver stateSaver(context, clip);
520     if (clip)
521         context.clip(contentBoxRect);
522 
523     ImageDrawResult result = paintIntoRect(paintInfo, snapRectToDevicePixels(replacedContentRect, deviceScaleFactor));
524 
525     if (showBorderForIncompleteImage &amp;&amp; (result != ImageDrawResult::DidDraw || (cachedImage() &amp;&amp; cachedImage()-&gt;isLoading())))
526         paintIncompleteImageOutline(paintInfo, paintOffset, missingImageBorderWidth);
527 
528     if (cachedImage() &amp;&amp; paintInfo.phase == PaintPhase::Foreground) {
529         // For now, count images as unpainted if they are still progressively loading. We may want
530         // to refine this in the future to account for the portion of the image that has painted.
531         LayoutRect visibleRect = intersection(replacedContentRect, contentBoxRect);
532         if (cachedImage()-&gt;isLoading() || result == ImageDrawResult::DidRequestDecoding)
533             page().addRelevantUnpaintedObject(this, visibleRect);
534         else
535             page().addRelevantRepaintedObject(this, visibleRect);
536     }
537 }
538 
539 void RenderImage::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
540 {
541     RenderReplaced::paint(paintInfo, paintOffset);
542 
543     if (paintInfo.phase == PaintPhase::Outline)
544         paintAreaElementFocusRing(paintInfo, paintOffset);
545 }
546 
547 void RenderImage::paintAreaElementFocusRing(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
548 {
549 #if !PLATFORM(IOS_FAMILY) || ENABLE(FULL_KEYBOARD_ACCESS)
550     if (document().printing() || !frame().selection().isFocusedAndActive())
551         return;
552 
553     if (paintInfo.context().paintingDisabled() &amp;&amp; !paintInfo.context().performingPaintInvalidation())
554         return;
555 
556     Element* focusedElement = document().focusedElement();
557     if (!is&lt;HTMLAreaElement&gt;(focusedElement))
558         return;
559 
560     HTMLAreaElement&amp; areaElement = downcast&lt;HTMLAreaElement&gt;(*focusedElement);
561     if (areaElement.imageElement() != element())
562         return;
563 
564     auto* areaElementStyle = areaElement.computedStyle();
565     if (!areaElementStyle)
566         return;
567 
568     float outlineWidth = areaElementStyle-&gt;outlineWidth();
569     if (!outlineWidth)
570         return;
571 
572     // Even if the theme handles focus ring drawing for entire elements, it won&#39;t do it for
573     // an area within an image, so we don&#39;t call RenderTheme::supportsFocusRing here.
574     auto path = areaElement.computePathForFocusRing(size());
575     if (path.isEmpty())
576         return;
577 
578     AffineTransform zoomTransform;
579     zoomTransform.scale(style().effectiveZoom());
580     path.transform(zoomTransform);
581 
582     auto adjustedOffset = paintOffset;
583     adjustedOffset.moveBy(location());
584     path.translate(toFloatSize(adjustedOffset));
585 
586 #if PLATFORM(MAC)
587     bool needsRepaint;
588     paintInfo.context().drawFocusRing(path, page().focusController().timeSinceFocusWasSet().seconds(), needsRepaint, RenderTheme::singleton().focusRingColor(styleColorOptions()));
589     if (needsRepaint)
590         page().focusController().setFocusedElementNeedsRepaint();
591 #else
592     paintInfo.context().drawFocusRing(path, outlineWidth, areaElementStyle-&gt;outlineOffset(), areaElementStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyOutlineColor));
593 #endif // PLATFORM(MAC)
594 #else
595     UNUSED_PARAM(paintInfo);
596     UNUSED_PARAM(paintOffset);
597 #endif // ENABLE(FULL_KEYBOARD_ACCESS)
598 }
599 
600 void RenderImage::areaElementFocusChanged(HTMLAreaElement* element)
601 {
602     ASSERT_UNUSED(element, element-&gt;imageElement() == this-&gt;element());
603 
604     // It would be more efficient to only repaint the focus ring rectangle
605     // for the passed-in area element. That would require adding functions
606     // to the area element class.
607     repaint();
608 }
609 
610 ImageDrawResult RenderImage::paintIntoRect(PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
611 {
612     if (!imageResource().cachedImage() || imageResource().errorOccurred() || rect.width() &lt;= 0 || rect.height() &lt;= 0)
613         return ImageDrawResult::DidNothing;
614 
615     RefPtr&lt;Image&gt; img = imageResource().image(flooredIntSize(rect.size()));
616     if (!img || img-&gt;isNull())
617         return ImageDrawResult::DidNothing;
618 
619     HTMLImageElement* imageElement = is&lt;HTMLImageElement&gt;(element()) ? downcast&lt;HTMLImageElement&gt;(element()) : nullptr;
620     CompositeOperator compositeOperator = imageElement ? imageElement-&gt;compositeOperator() : CompositeSourceOver;
621 
622     // FIXME: Document when image != img.get().
623     Image* image = imageResource().image().get();
624     InterpolationQuality interpolation = image ? chooseInterpolationQuality(paintInfo.context(), *image, image, LayoutSize(rect.size())) : InterpolationDefault;
625 
626 #if USE(CG)
627     if (is&lt;PDFDocumentImage&gt;(image))
628         downcast&lt;PDFDocumentImage&gt;(*image).setPdfImageCachingPolicy(settings().pdfImageCachingPolicy());
629 #endif
630 
631     if (is&lt;BitmapImage&gt;(image))
632         downcast&lt;BitmapImage&gt;(*image).updateFromSettings(settings());
633 
<a name="10" id="anc10"></a>
634     auto decodingMode = decodingModeForImageDraw(*image, paintInfo);
<a name="11" id="anc11"></a><span class="line-modified">635     auto drawResult = paintInfo.context().drawImage(*img, rect, { compositeOperator, BlendMode::Normal, decodingMode, imageOrientation(), interpolation });</span>
636     if (drawResult == ImageDrawResult::DidRequestDecoding)
637         imageResource().cachedImage()-&gt;addClientWaitingForAsyncDecoding(*this);
638 
639 #if USE(SYSTEM_PREVIEW)
640     if (imageElement &amp;&amp; imageElement-&gt;isSystemPreviewImage() &amp;&amp; drawResult == ImageDrawResult::DidDraw &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().systemPreviewEnabled())
641         theme().paintSystemPreviewBadge(*img, paintInfo, rect);
642 #endif
643 
644     return drawResult;
645 }
646 
647 bool RenderImage::boxShadowShouldBeAppliedToBackground(const LayoutPoint&amp; paintOffset, BackgroundBleedAvoidance bleedAvoidance, InlineFlowBox*) const
648 {
649     if (!RenderBoxModelObject::boxShadowShouldBeAppliedToBackground(paintOffset, bleedAvoidance))
650         return false;
651 
652     return !const_cast&lt;RenderImage*&gt;(this)-&gt;backgroundIsKnownToBeObscured(paintOffset);
653 }
654 
655 bool RenderImage::foregroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect, unsigned maxDepthToTest) const
656 {
657     UNUSED_PARAM(maxDepthToTest);
658     if (!imageResource().cachedImage() || imageResource().errorOccurred())
659         return false;
660     if (cachedImage() &amp;&amp; !cachedImage()-&gt;isLoaded())
661         return false;
662     if (!contentBoxRect().contains(localRect))
663         return false;
664     FillBox backgroundClip = style().backgroundClip();
665     // Background paints under borders.
666     if (backgroundClip == FillBox::Border &amp;&amp; style().hasBorder() &amp;&amp; !borderObscuresBackground())
667         return false;
668     // Background shows in padding area.
669     if ((backgroundClip == FillBox::Border || backgroundClip == FillBox::Padding) &amp;&amp; style().hasPadding())
670         return false;
671     // Object-fit may leave parts of the content box empty.
672     ObjectFit objectFit = style().objectFit();
673     if (objectFit != ObjectFit::Fill &amp;&amp; objectFit != ObjectFit::Cover)
674         return false;
675 
676     LengthPoint objectPosition = style().objectPosition();
677     if (objectPosition != RenderStyle::initialObjectPosition())
678         return false;
679 
680     // Check for image with alpha.
681     return cachedImage() &amp;&amp; cachedImage()-&gt;currentFrameKnownToBeOpaque(this);
682 }
683 
684 bool RenderImage::computeBackgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset)
685 {
686     if (!hasBackground())
687         return false;
688 
689     LayoutRect paintedExtent;
690     if (!getBackgroundPaintedExtent(paintOffset, paintedExtent))
691         return false;
692     return foregroundIsKnownToBeOpaqueInRect(paintedExtent, 0);
693 }
694 
695 LayoutUnit RenderImage::minimumReplacedHeight() const
696 {
697     return imageResource().errorOccurred() ? intrinsicSize().height() : 0_lu;
698 }
699 
700 HTMLMapElement* RenderImage::imageMap() const
701 {
702     auto* imageElement = element();
703     if (!imageElement || !is&lt;HTMLImageElement&gt;(imageElement))
704         return nullptr;
705     return downcast&lt;HTMLImageElement&gt;(imageElement)-&gt;associatedMapElement();
706 }
707 
708 bool RenderImage::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
709 {
710     HitTestResult tempResult(result.hitTestLocation());
711     bool inside = RenderReplaced::nodeAtPoint(request, tempResult, locationInContainer, accumulatedOffset, hitTestAction);
712 
713     if (tempResult.innerNode() &amp;&amp; element()) {
714         if (HTMLMapElement* map = imageMap()) {
715             LayoutRect contentBox = contentBoxRect();
716             float scaleFactor = 1 / style().effectiveZoom();
717             LayoutPoint mapLocation = locationInContainer.point() - toLayoutSize(accumulatedOffset) - locationOffset() - toLayoutSize(contentBox.location());
718             mapLocation.scale(scaleFactor);
719 
720             if (map-&gt;mapMouseEvent(mapLocation, contentBox.size(), tempResult))
721                 tempResult.setInnerNonSharedNode(element());
722         }
723     }
724 
725     if (!inside &amp;&amp; request.resultIsElementList())
726         result.append(tempResult, request);
727     if (inside)
728         result = tempResult;
729     return inside;
730 }
731 
732 void RenderImage::updateAltText()
733 {
734     if (!element())
735         return;
736 
737     if (is&lt;HTMLInputElement&gt;(*element()))
738         m_altText = downcast&lt;HTMLInputElement&gt;(*element()).altText();
739     else if (is&lt;HTMLImageElement&gt;(*element()))
740         m_altText = downcast&lt;HTMLImageElement&gt;(*element()).altText();
741 }
742 
743 bool RenderImage::canHaveChildren() const
744 {
745 #if !ENABLE(SERVICE_CONTROLS)
746     return false;
747 #else
748     return m_hasShadowControls;
749 #endif
750 }
751 
752 void RenderImage::layout()
753 {
754     // Recomputing overflow is required only when child content is present.
755     if (needsSimplifiedNormalFlowLayoutOnly() &amp;&amp; !m_hasShadowControls) {
756         clearNeedsLayout();
757         return;
758     }
759 
760     StackStats::LayoutCheckPoint layoutCheckPoint;
761 
762     LayoutSize oldSize = contentBoxRect().size();
763     RenderReplaced::layout();
764 
765     updateInnerContentRect();
766 
767     if (m_hasShadowControls)
768         layoutShadowControls(oldSize);
769 }
770 
771 void RenderImage::layoutShadowControls(const LayoutSize&amp; oldSize)
772 {
773     // We expect a single containing box under the UA shadow root.
774     ASSERT(firstChild() == lastChild());
775 
776     auto* controlsRenderer = downcast&lt;RenderBox&gt;(firstChild());
777     if (!controlsRenderer)
778         return;
779 
780     bool controlsNeedLayout = controlsRenderer-&gt;needsLayout();
781     // If the region chain has changed we also need to relayout the controls to update the region box info.
782     // FIXME: We can do better once we compute region box info for RenderReplaced, not only for RenderBlock.
783     const RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
784     if (fragmentedFlow &amp;&amp; !controlsNeedLayout) {
785         if (fragmentedFlow-&gt;pageLogicalSizeChanged())
786             controlsNeedLayout = true;
787     }
788 
789     LayoutSize newSize = contentBoxRect().size();
790     if (newSize == oldSize &amp;&amp; !controlsNeedLayout)
791         return;
792 
793     // When calling layout() on a child node, a parent must either push a LayoutStateMaintainter, or
794     // instantiate LayoutStateDisabler. Since using a LayoutStateMaintainer is slightly more efficient,
795     // and this method might be called many times per second during video playback, use a LayoutStateMaintainer:
796     LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
797 
798     if (shadowControlsNeedCustomLayoutMetrics()) {
799         controlsRenderer-&gt;setLocation(LayoutPoint(borderLeft(), borderTop()) + LayoutSize(paddingLeft(), paddingTop()));
800         controlsRenderer-&gt;mutableStyle().setHeight(Length(newSize.height(), Fixed));
801         controlsRenderer-&gt;mutableStyle().setWidth(Length(newSize.width(), Fixed));
802     }
803 
804     controlsRenderer-&gt;setNeedsLayout(MarkOnlyThis);
805     controlsRenderer-&gt;layout();
806     clearChildNeedsLayout();
807 }
808 
809 void RenderImage::computeIntrinsicRatioInformation(FloatSize&amp; intrinsicSize, double&amp; intrinsicRatio) const
810 {
811     RenderReplaced::computeIntrinsicRatioInformation(intrinsicSize, intrinsicRatio);
812 
813     // Our intrinsicSize is empty if we&#39;re rendering generated images with relative width/height. Figure out the right intrinsic size to use.
814     if (intrinsicSize.isEmpty() &amp;&amp; (imageResource().imageHasRelativeWidth() || imageResource().imageHasRelativeHeight())) {
815         RenderObject* containingBlock = isOutOfFlowPositioned() ? container() : this-&gt;containingBlock();
816         if (is&lt;RenderBox&gt;(*containingBlock)) {
817             auto&amp; box = downcast&lt;RenderBox&gt;(*containingBlock);
818             intrinsicSize.setWidth(box.availableLogicalWidth());
819             intrinsicSize.setHeight(box.availableLogicalHeight(IncludeMarginBorderPadding));
820         }
821     }
822     // Don&#39;t compute an intrinsic ratio to preserve historical WebKit behavior if we&#39;re painting alt text and/or a broken image.
823     if (imageResource().errorOccurred()) {
824         intrinsicRatio = 1;
825         return;
826     }
827 }
828 
829 bool RenderImage::needsPreferredWidthsRecalculation() const
830 {
831     if (RenderReplaced::needsPreferredWidthsRecalculation())
832         return true;
833     return embeddedContentBox();
834 }
835 
836 RenderBox* RenderImage::embeddedContentBox() const
837 {
838     CachedImage* cachedImage = this-&gt;cachedImage();
839     if (cachedImage &amp;&amp; is&lt;SVGImage&gt;(cachedImage-&gt;image()))
840         return downcast&lt;SVGImage&gt;(*cachedImage-&gt;image()).embeddedContentBox();
841 
842     return nullptr;
843 }
844 
<a name="12" id="anc12"></a><span class="line-added">845 void RenderImage::incrementVisuallyNonEmptyPixelCountIfNeeded(const IntSize&amp; size)</span>
<span class="line-added">846 {</span>
<span class="line-added">847     if (m_didIncrementVisuallyNonEmptyPixelCount)</span>
<span class="line-added">848         return;</span>
<span class="line-added">849 </span>
<span class="line-added">850     view().frameView().incrementVisuallyNonEmptyPixelCount(size);</span>
<span class="line-added">851     m_didIncrementVisuallyNonEmptyPixelCount = true;</span>
<span class="line-added">852 }</span>
<span class="line-added">853 </span>
854 } // namespace WebCore
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>