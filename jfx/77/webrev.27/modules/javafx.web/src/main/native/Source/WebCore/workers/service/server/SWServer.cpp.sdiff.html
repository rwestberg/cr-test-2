<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RegistrationStore.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWServer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 52 
 53 SWServer::Connection::Connection(SWServer&amp; server)
 54     : m_server(server)
 55     , m_identifier(SWServerConnectionIdentifier::generate())
 56 {
 57 }
 58 
 59 HashSet&lt;SWServer*&gt;&amp; SWServer::allServers()
 60 {
 61     static NeverDestroyed&lt;HashSet&lt;SWServer*&gt;&gt; servers;
 62     return servers;
 63 }
 64 
 65 SWServer::~SWServer()
 66 {
 67     // Destroy the remaining connections before the SWServer gets destroyed since they have a raw pointer
 68     // to the server and since they try to unregister clients from the server in their destructor.
 69     auto connections = WTFMove(m_connections);
 70     connections.clear();
 71 








 72     allServers().remove(this);
 73 }
 74 
 75 SWServerWorker* SWServer::workerByID(ServiceWorkerIdentifier identifier) const
 76 {
 77     auto* worker = SWServerWorker::existingWorkerForIdentifier(identifier);
<span class="line-modified"> 78     ASSERT(!worker || &amp;worker-&gt;server() == this);</span>
 79     return worker;
 80 }
 81 
 82 Optional&lt;ServiceWorkerClientData&gt; SWServer::serviceWorkerClientWithOriginByID(const ClientOrigin&amp; clientOrigin, const ServiceWorkerClientIdentifier&amp; clientIdentifier) const
 83 {
 84     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
 85     if (iterator == m_clientIdentifiersPerOrigin.end())
 86         return WTF::nullopt;
 87 
 88     if (!iterator-&gt;value.identifiers.contains(clientIdentifier))
 89         return WTF::nullopt;
 90 
 91     auto clientIterator = m_clientsById.find(clientIdentifier);
 92     ASSERT(clientIterator != m_clientsById.end());
 93     return clientIterator-&gt;value;
 94 }
 95 
 96 String SWServer::serviceWorkerClientUserAgent(const ClientOrigin&amp; clientOrigin) const
 97 {
 98     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
</pre>
<hr />
<pre>
119     m_originStore-&gt;importComplete();
120 
121     auto clearCallbacks = WTFMove(m_clearCompletionCallbacks);
122     for (auto&amp; callback : clearCallbacks)
123         callback();
124 
125     performGetOriginsWithRegistrationsCallbacks();
126 }
127 
128 void SWServer::registrationStoreDatabaseFailedToOpen()
129 {
130     if (!m_importCompleted)
131         registrationStoreImportComplete();
132 }
133 
134 void SWServer::addRegistrationFromStore(ServiceWorkerContextData&amp;&amp; data)
135 {
136     // Pages should not have been able to make a new registration to this key while the import was still taking place.
137     ASSERT(!m_registrations.contains(data.registration.key));
138 
<span class="line-modified">139     auto registration = std::make_unique&lt;SWServerRegistration&gt;(*this, data.registration.key, data.registration.updateViaCache, data.registration.scopeURL, data.scriptURL);</span>
140     registration-&gt;setLastUpdateTime(data.registration.lastUpdateTime);
141     auto registrationPtr = registration.get();
142     addRegistration(WTFMove(registration));
143 
<span class="line-modified">144     auto worker = SWServerWorker::create(*this, *registrationPtr, data.scriptURL, data.script, data.contentSecurityPolicy, WTFMove(data.referrerPolicy), data.workerType, data.serviceWorkerIdentifier, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt; { data.scriptResourceMap });</span>
145     registrationPtr-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Active, worker.ptr());
146     worker-&gt;setState(ServiceWorkerState::Activated);
147 }
148 
149 void SWServer::addRegistration(std::unique_ptr&lt;SWServerRegistration&gt;&amp;&amp; registration)
150 {
151     auto key = registration-&gt;key();
152     auto* registrationPtr = registration.get();
153     auto addResult1 = m_registrations.add(key, WTFMove(registration));
154     ASSERT_UNUSED(addResult1, addResult1.isNewEntry);
155 
156     auto addResult2 = m_registrationsByID.add(registrationPtr-&gt;identifier(), registrationPtr);
157     ASSERT_UNUSED(addResult2, addResult2.isNewEntry);
158 
159     m_originStore-&gt;add(key.topOrigin());
160 }
161 
162 void SWServer::removeRegistration(const ServiceWorkerRegistrationKey&amp; key)
163 {
164     auto topOrigin = key.topOrigin();
165     auto registration = m_registrations.take(key);
166     ASSERT(registration);
167     bool wasRemoved = m_registrationsByID.remove(registration-&gt;identifier());
168     ASSERT_UNUSED(wasRemoved, wasRemoved);
169 
170     m_originStore-&gt;remove(topOrigin);
171     if (m_registrationStore)
<span class="line-modified">172         m_registrationStore-&gt;removeRegistration(*registration);</span>
173 }
174 
175 Vector&lt;ServiceWorkerRegistrationData&gt; SWServer::getRegistrations(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
176 {
177     Vector&lt;SWServerRegistration*&gt; matchingRegistrations;
178     for (auto&amp; item : m_registrations) {
179         if (!item.value-&gt;isUninstalling() &amp;&amp; item.key.originIsMatching(topOrigin, clientURL))
180             matchingRegistrations.append(item.value.get());
181     }
182     // The specification mandates that registrations are returned in the insertion order.
183     std::sort(matchingRegistrations.begin(), matchingRegistrations.end(), [](auto&amp; a, auto&amp; b) {
184         return a-&gt;creationTime() &lt; b-&gt;creationTime();
185     });
186     Vector&lt;ServiceWorkerRegistrationData&gt; matchingRegistrationDatas;
187     matchingRegistrationDatas.reserveInitialCapacity(matchingRegistrations.size());
188     for (auto* registration : matchingRegistrations)
189         matchingRegistrationDatas.uncheckedAppend(registration-&gt;data());
190     return matchingRegistrationDatas;
191 }
192 
193 void SWServer::clearAll(CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
194 {
195     if (!m_importCompleted) {
196         m_clearCompletionCallbacks.append([this, completionHandler = WTFMove(completionHandler)] () mutable {
197             ASSERT(m_importCompleted);
198             clearAll(WTFMove(completionHandler));
199         });
200         return;
201     }
202 
203     m_jobQueues.clear();
204     while (!m_registrations.isEmpty())
205         m_registrations.begin()-&gt;value-&gt;clear();
206     ASSERT(m_registrationsByID.isEmpty());
207     m_pendingContextDatas.clear();
208     m_originStore-&gt;clearAll();
209     if (m_registrationStore)
210         m_registrationStore-&gt;clearAll(WTFMove(completionHandler));
211 }
212 















213 void SWServer::clear(const SecurityOriginData&amp; securityOrigin, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
214 {
215     if (!m_importCompleted) {
216         m_clearCompletionCallbacks.append([this, securityOrigin, completionHandler = WTFMove(completionHandler)] () mutable {
217             ASSERT(m_importCompleted);
218             clear(securityOrigin, WTFMove(completionHandler));
219         });
220         return;
221     }
222 
223     m_jobQueues.removeIf([&amp;](auto&amp; keyAndValue) {
224         return keyAndValue.key.relatesToOrigin(securityOrigin);
225     });
226 
227     Vector&lt;SWServerRegistration*&gt; registrationsToRemove;
228     for (auto&amp; keyAndValue : m_registrations) {
229         if (keyAndValue.key.relatesToOrigin(securityOrigin))
230             registrationsToRemove.append(keyAndValue.value.get());
231     }
232 
</pre>
<hr />
<pre>
264     m_server.addClientServiceWorkerRegistration(*this, identifier);
265 }
266 
267 void SWServer::Connection::removeServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
268 {
269     m_server.removeClientServiceWorkerRegistration(*this, identifier);
270 }
271 
272 void SWServer::Connection::syncTerminateWorker(ServiceWorkerIdentifier identifier)
273 {
274     if (auto* worker = m_server.workerByID(identifier))
275         m_server.syncTerminateWorker(*worker);
276 }
277 
278 SWServer::SWServer(UniqueRef&lt;SWOriginStore&gt;&amp;&amp; originStore, String&amp;&amp; registrationDatabaseDirectory, PAL::SessionID sessionID)
279     : m_originStore(WTFMove(originStore))
280     , m_sessionID(sessionID)
281 {
282     ASSERT(!registrationDatabaseDirectory.isEmpty() || m_sessionID.isEphemeral());
283     if (!m_sessionID.isEphemeral())
<span class="line-modified">284         m_registrationStore = std::make_unique&lt;RegistrationStore&gt;(*this, WTFMove(registrationDatabaseDirectory));</span>
285     else
286         registrationStoreImportComplete();
287 
288     UNUSED_PARAM(registrationDatabaseDirectory);
289     allServers().add(this);
290 }
291 
292 // https://w3c.github.io/ServiceWorker/#schedule-job-algorithm
293 void SWServer::scheduleJob(ServiceWorkerJobData&amp;&amp; jobData)
294 {
295     ASSERT(m_connections.contains(jobData.connectionIdentifier()));
296 
297     // FIXME: Per the spec, check if this job is equivalent to the last job on the queue.
298     // If it is, stack it along with that job.
299 
300     auto&amp; jobQueue = *m_jobQueues.ensure(jobData.registrationKey(), [this, &amp;jobData] {
<span class="line-modified">301         return std::make_unique&lt;SWServerJobQueue&gt;(*this, jobData.registrationKey());</span>
302     }).iterator-&gt;value;
303 
304     jobQueue.enqueueJob(jobData);
305     if (jobQueue.size() == 1)
306         jobQueue.runNextJob();
307 }
308 
309 void SWServer::rejectJob(const ServiceWorkerJobData&amp; jobData, const ExceptionData&amp; exceptionData)
310 {
311     LOG(ServiceWorker, &quot;Rejected ServiceWorker job %s in server&quot;, jobData.identifier().loggingString().utf8().data());
312     auto* connection = m_connections.get(jobData.connectionIdentifier());
313     if (!connection)
314         return;
315 
316     connection-&gt;rejectJobInClient(jobData.identifier().jobIdentifier, exceptionData);
317 }
318 
319 void SWServer::resolveRegistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationData&amp; registrationData, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
320 {
321     LOG(ServiceWorker, &quot;Resolved ServiceWorker job %s in server with registration %s&quot;, jobData.identifier().loggingString().utf8().data(), registrationData.identifier.loggingString().utf8().data());
</pre>
<hr />
<pre>
493         LOG_ERROR(&quot;Request to add client-side ServiceWorkerRegistration to non-existent server-side registration&quot;);
494         return;
495     }
496 
497     registration-&gt;addClientServiceWorkerRegistration(connection.identifier());
498 }
499 
500 void SWServer::removeClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
501 {
502     if (auto* registration = m_registrationsByID.get(identifier))
503         registration-&gt;removeClientServiceWorkerRegistration(connection.identifier());
504 }
505 
506 void SWServer::updateWorker(Connection&amp;, const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, SWServerRegistration&amp; registration, const URL&amp; url, const String&amp; script, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, const String&amp; referrerPolicy, WorkerType type, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt;&amp;&amp; scriptResourceMap)
507 {
508     tryInstallContextData({ jobDataIdentifier, registration.data(), ServiceWorkerIdentifier::generate(), script, contentSecurityPolicy, referrerPolicy, url, type, sessionID(), false, WTFMove(scriptResourceMap) });
509 }
510 
511 void SWServer::tryInstallContextData(ServiceWorkerContextData&amp;&amp; data)
512 {
<span class="line-modified">513     auto securityOrigin = SecurityOriginData::fromURL(data.scriptURL);</span>
<span class="line-modified">514     auto* connection = SWServerToContextConnection::connectionForOrigin(securityOrigin);</span>
515     if (!connection) {
<span class="line-modified">516         m_pendingContextDatas.ensure(WTFMove(securityOrigin), [] {</span>
517             return Vector&lt;ServiceWorkerContextData&gt; { };
518         }).iterator-&gt;value.append(WTFMove(data));
519         return;
520     }
521 
522     installContextData(data);
523 }
524 
525 void SWServer::serverToContextConnectionCreated(SWServerToContextConnection&amp; contextConnection)
526 {
<span class="line-modified">527     auto pendingContextDatas = m_pendingContextDatas.take(contextConnection.securityOrigin());</span>



528     for (auto&amp; data : pendingContextDatas)
529         installContextData(data);
530 
<span class="line-modified">531     auto serviceWorkerRunRequests = m_serviceWorkerRunRequests.take(contextConnection.securityOrigin());</span>
532     for (auto&amp; item : serviceWorkerRunRequests) {
533         bool success = runServiceWorker(item.key);
534         for (auto&amp; callback : item.value)
535             callback(success ? &amp;contextConnection : nullptr);
536     }
537 }
538 
539 void SWServer::installContextData(const ServiceWorkerContextData&amp; data)
540 {
541     ASSERT_WITH_MESSAGE(!data.loadedFromDisk, &quot;Workers we just read from disk should only be launched as needed&quot;);
542 
543     if (data.jobDataIdentifier) {
544         // Abort if the job that scheduled this has been cancelled.
545         auto* jobQueue = m_jobQueues.get(data.registration.key);
546         if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*data.jobDataIdentifier))
547             return;
548     }
549 
550     auto* registration = m_registrations.get(data.registration.key);
551     RELEASE_ASSERT(registration);
</pre>
<hr />
<pre>
563 
564     connection-&gt;installServiceWorkerContext(data, m_sessionID, userAgent);
565 }
566 
567 void SWServer::runServiceWorkerIfNecessary(ServiceWorkerIdentifier identifier, RunServiceWorkerCallback&amp;&amp; callback)
568 {
569     auto* worker = workerByID(identifier);
570     if (!worker) {
571         callback(nullptr);
572         return;
573     }
574 
575     auto* contextConnection = worker-&gt;contextConnection();
576     if (worker-&gt;isRunning()) {
577         ASSERT(contextConnection);
578         callback(contextConnection);
579         return;
580     }
581 
582     if (!contextConnection) {
<span class="line-modified">583         auto&amp; serviceWorkerRunRequestsForOrigin = m_serviceWorkerRunRequests.ensure(worker-&gt;securityOrigin(), [] {</span>
584             return HashMap&lt;ServiceWorkerIdentifier, Vector&lt;RunServiceWorkerCallback&gt;&gt; { };
585         }).iterator-&gt;value;
586         serviceWorkerRunRequestsForOrigin.ensure(identifier, [&amp;] {
587             return Vector&lt;RunServiceWorkerCallback&gt; { };
588         }).iterator-&gt;value.append(WTFMove(callback));
589         return;
590     }
591 
592     bool success = runServiceWorker(identifier);
593     callback(success ? contextConnection : nullptr);
594 }
595 
596 bool SWServer::runServiceWorker(ServiceWorkerIdentifier identifier)
597 {
598     auto* worker = workerByID(identifier);
599     if (!worker)
600         return false;
601 
602     // If the registration for a working has been removed then the request to run
603     // the worker is moot.
</pre>
<hr />
<pre>
637     worker.setState(SWServerWorker::State::Terminating);
638 
639     auto* contextConnection = worker.contextConnection();
640     ASSERT(contextConnection);
641     if (!contextConnection) {
642         LOG_ERROR(&quot;Request to terminate a worker whose context connection does not exist&quot;);
643         workerContextTerminated(worker);
644         return;
645     }
646 
647     switch (mode) {
648     case Asynchronous:
649         contextConnection-&gt;terminateWorker(worker.identifier());
650         break;
651     case Synchronous:
652         contextConnection-&gt;syncTerminateWorker(worker.identifier());
653         break;
654     };
655 }
656 
<span class="line-modified">657 void SWServer::markAllWorkersForOriginAsTerminated(const SecurityOriginData&amp; securityOrigin)</span>
658 {
659     Vector&lt;SWServerWorker*&gt; terminatedWorkers;
660     for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
<span class="line-modified">661         if (worker-&gt;securityOrigin() == securityOrigin)</span>
662             terminatedWorkers.append(worker.ptr());
663     }
664     for (auto&amp; terminatedWorker : terminatedWorkers)
665         workerContextTerminated(*terminatedWorker);
666 }
667 
668 void SWServer::workerContextTerminated(SWServerWorker&amp; worker)
669 {
670     worker.setState(SWServerWorker::State::NotRunning);
671 
672     if (auto* jobQueue = m_jobQueues.get(worker.registrationKey()))
673         jobQueue-&gt;cancelJobsFromServiceWorker(worker.identifier());
674 
675     // At this point if no registrations are referencing the worker then it will be destroyed,
676     // removing itself from the m_workersByID map.
677     auto result = m_runningOrTerminatingWorkers.take(worker.identifier());
678     ASSERT_UNUSED(result, result &amp;&amp; result-&gt;ptr() == &amp;worker);
679 }
680 
681 void SWServer::fireInstallEvent(SWServerWorker&amp; worker)
</pre>
<hr />
<pre>
744 void SWServer::registerServiceWorkerClient(ClientOrigin&amp;&amp; clientOrigin, ServiceWorkerClientData&amp;&amp; data, const Optional&lt;ServiceWorkerRegistrationIdentifier&gt;&amp; controllingServiceWorkerRegistrationIdentifier, String&amp;&amp; userAgent)
745 {
746     auto clientIdentifier = data.identifier;
747 
748     ASSERT(!m_clientsById.contains(clientIdentifier));
749     m_clientsById.add(clientIdentifier, WTFMove(data));
750 
751     auto&amp; clientIdentifiersForOrigin = m_clientIdentifiersPerOrigin.ensure(clientOrigin, [] {
752         return Clients { };
753     }).iterator-&gt;value;
754 
755     ASSERT(!clientIdentifiersForOrigin.identifiers.contains(clientIdentifier));
756     clientIdentifiersForOrigin.identifiers.append(clientIdentifier);
757 
758     if (!clientIdentifiersForOrigin.userAgent.isNull() &amp;&amp; clientIdentifiersForOrigin.userAgent != userAgent)
759         RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::registerServiceWorkerClient: Service worker has clients using different user agents&quot;, this);
760     clientIdentifiersForOrigin.userAgent = WTFMove(userAgent);
761 
762     clientIdentifiersForOrigin.terminateServiceWorkersTimer = nullptr;
763 
<span class="line-modified">764     m_clientsBySecurityOrigin.ensure(clientOrigin.clientOrigin, [] {</span>
765         return HashSet&lt;ServiceWorkerClientIdentifier&gt; { };
766     }).iterator-&gt;value.add(clientIdentifier);
767 
768     if (!controllingServiceWorkerRegistrationIdentifier)
769         return;
770 
771     auto* controllingRegistration = m_registrationsByID.get(*controllingServiceWorkerRegistrationIdentifier);
772     if (!controllingRegistration || !controllingRegistration-&gt;activeWorker())
773         return;
774 
775     controllingRegistration-&gt;addClientUsingRegistration(clientIdentifier);
776     ASSERT(!m_clientToControllingRegistration.contains(clientIdentifier));
777     m_clientToControllingRegistration.add(clientIdentifier, *controllingServiceWorkerRegistrationIdentifier);
778 }
779 
780 void SWServer::unregisterServiceWorkerClient(const ClientOrigin&amp; clientOrigin, ServiceWorkerClientIdentifier clientIdentifier)
781 {


782     bool wasRemoved = m_clientsById.remove(clientIdentifier);
783     ASSERT_UNUSED(wasRemoved, wasRemoved);
784 
785     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
786     ASSERT(iterator != m_clientIdentifiersPerOrigin.end());
787 
788     auto&amp; clientIdentifiers = iterator-&gt;value.identifiers;
789     clientIdentifiers.removeFirstMatching([&amp;] (const auto&amp; identifier) {
790         return clientIdentifier == identifier;
791     });

792     if (clientIdentifiers.isEmpty()) {
793         ASSERT(!iterator-&gt;value.terminateServiceWorkersTimer);
<span class="line-modified">794         iterator-&gt;value.terminateServiceWorkersTimer = std::make_unique&lt;Timer&gt;([clientOrigin, this] {</span>
795             Vector&lt;SWServerWorker*&gt; workersToTerminate;
796             for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
797                 if (worker-&gt;isRunning() &amp;&amp; worker-&gt;origin() == clientOrigin)
798                     workersToTerminate.append(worker.ptr());
799             }
800             for (auto* worker : workersToTerminate)
801                 terminateWorker(*worker);
802 
<span class="line-modified">803             if (!m_clientsBySecurityOrigin.contains(clientOrigin.clientOrigin)) {</span>
<span class="line-modified">804                 if (auto* connection = SWServerToContextConnection::connectionForOrigin(clientOrigin.clientOrigin))</span>
805                     connection-&gt;connectionMayNoLongerBeNeeded();
806             }
807 
808             m_clientIdentifiersPerOrigin.remove(clientOrigin);
809         });
810         iterator-&gt;value.terminateServiceWorkersTimer-&gt;startOneShot(m_shouldDisableServiceWorkerProcessTerminationDelay ? 0_s : terminationDelay);
811     }
812 
<span class="line-modified">813     auto clientsBySecurityOriginIterator = m_clientsBySecurityOrigin.find(clientOrigin.clientOrigin);</span>
<span class="line-modified">814     ASSERT(clientsBySecurityOriginIterator != m_clientsBySecurityOrigin.end());</span>
<span class="line-modified">815     auto&amp; clientsForSecurityOrigin = clientsBySecurityOriginIterator-&gt;value;</span>
<span class="line-modified">816     clientsForSecurityOrigin.remove(clientIdentifier);</span>
<span class="line-modified">817     if (clientsForSecurityOrigin.isEmpty())</span>
<span class="line-modified">818         m_clientsBySecurityOrigin.remove(clientsBySecurityOriginIterator);</span>
819 
820     auto registrationIterator = m_clientToControllingRegistration.find(clientIdentifier);
821     if (registrationIterator == m_clientToControllingRegistration.end())
822         return;
823 
824     if (auto* registration = m_registrationsByID.get(registrationIterator-&gt;value))
825         registration-&gt;removeClientUsingRegistration(clientIdentifier);
826 
827     m_clientToControllingRegistration.remove(registrationIterator);
828 }
829 
<span class="line-modified">830 bool SWServer::needsServerToContextConnectionForOrigin(const SecurityOriginData&amp; securityOrigin) const</span>
831 {
<span class="line-modified">832     return m_clientsBySecurityOrigin.contains(securityOrigin);</span>
833 }
834 
835 void SWServer::resolveRegistrationReadyRequests(SWServerRegistration&amp; registration)
836 {
837     for (auto&amp; connection : m_connections.values())
838         connection-&gt;resolveRegistrationReadyRequests(registration);
839 }
840 
841 void SWServer::Connection::whenRegistrationReady(uint64_t registrationReadyRequestIdentifier, const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
842 {
843     if (auto* registration = doRegistrationMatching(topOrigin, clientURL)) {
844         if (registration-&gt;activeWorker()) {
845             registrationReady(registrationReadyRequestIdentifier, registration-&gt;data());
846             return;
847         }
848     }
849     m_registrationReadyRequests.append({ topOrigin, clientURL, registrationReadyRequestIdentifier });
850 }
851 









852 void SWServer::Connection::resolveRegistrationReadyRequests(SWServerRegistration&amp; registration)
853 {
854     m_registrationReadyRequests.removeAllMatching([&amp;](auto&amp; request) {
855         if (!registration.key().isMatching(request.topOrigin, request.clientURL))
856             return false;
857 
858         this-&gt;registrationReady(request.identifier, registration.data());
859         return true;
860     });
861 }
862 
863 void SWServer::getOriginsWithRegistrations(Function&lt;void(const HashSet&lt;SecurityOriginData&gt;&amp;)&gt;&amp;&amp; callback)
864 {
865     m_getOriginsWithRegistrationsCallbacks.append(WTFMove(callback));
866 
867     if (m_importCompleted)
868         performGetOriginsWithRegistrationsCallbacks();
869 }
870 
871 void SWServer::performGetOriginsWithRegistrationsCallbacks()
</pre>
</td>
<td>
<hr />
<pre>
 52 
 53 SWServer::Connection::Connection(SWServer&amp; server)
 54     : m_server(server)
 55     , m_identifier(SWServerConnectionIdentifier::generate())
 56 {
 57 }
 58 
 59 HashSet&lt;SWServer*&gt;&amp; SWServer::allServers()
 60 {
 61     static NeverDestroyed&lt;HashSet&lt;SWServer*&gt;&gt; servers;
 62     return servers;
 63 }
 64 
 65 SWServer::~SWServer()
 66 {
 67     // Destroy the remaining connections before the SWServer gets destroyed since they have a raw pointer
 68     // to the server and since they try to unregister clients from the server in their destructor.
 69     auto connections = WTFMove(m_connections);
 70     connections.clear();
 71 
<span class="line-added"> 72     Vector&lt;SWServerWorker*&gt; runningWorkers;</span>
<span class="line-added"> 73     for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {</span>
<span class="line-added"> 74         if (worker-&gt;isRunning())</span>
<span class="line-added"> 75             runningWorkers.append(worker.ptr());</span>
<span class="line-added"> 76     }</span>
<span class="line-added"> 77     for (auto&amp; runningWorker : runningWorkers)</span>
<span class="line-added"> 78         terminateWorker(*runningWorker);</span>
<span class="line-added"> 79 </span>
 80     allServers().remove(this);
 81 }
 82 
 83 SWServerWorker* SWServer::workerByID(ServiceWorkerIdentifier identifier) const
 84 {
 85     auto* worker = SWServerWorker::existingWorkerForIdentifier(identifier);
<span class="line-modified"> 86     ASSERT(!worker || worker-&gt;server() == this);</span>
 87     return worker;
 88 }
 89 
 90 Optional&lt;ServiceWorkerClientData&gt; SWServer::serviceWorkerClientWithOriginByID(const ClientOrigin&amp; clientOrigin, const ServiceWorkerClientIdentifier&amp; clientIdentifier) const
 91 {
 92     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
 93     if (iterator == m_clientIdentifiersPerOrigin.end())
 94         return WTF::nullopt;
 95 
 96     if (!iterator-&gt;value.identifiers.contains(clientIdentifier))
 97         return WTF::nullopt;
 98 
 99     auto clientIterator = m_clientsById.find(clientIdentifier);
100     ASSERT(clientIterator != m_clientsById.end());
101     return clientIterator-&gt;value;
102 }
103 
104 String SWServer::serviceWorkerClientUserAgent(const ClientOrigin&amp; clientOrigin) const
105 {
106     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
</pre>
<hr />
<pre>
127     m_originStore-&gt;importComplete();
128 
129     auto clearCallbacks = WTFMove(m_clearCompletionCallbacks);
130     for (auto&amp; callback : clearCallbacks)
131         callback();
132 
133     performGetOriginsWithRegistrationsCallbacks();
134 }
135 
136 void SWServer::registrationStoreDatabaseFailedToOpen()
137 {
138     if (!m_importCompleted)
139         registrationStoreImportComplete();
140 }
141 
142 void SWServer::addRegistrationFromStore(ServiceWorkerContextData&amp;&amp; data)
143 {
144     // Pages should not have been able to make a new registration to this key while the import was still taking place.
145     ASSERT(!m_registrations.contains(data.registration.key));
146 
<span class="line-modified">147     auto registration = makeUnique&lt;SWServerRegistration&gt;(*this, data.registration.key, data.registration.updateViaCache, data.registration.scopeURL, data.scriptURL);</span>
148     registration-&gt;setLastUpdateTime(data.registration.lastUpdateTime);
149     auto registrationPtr = registration.get();
150     addRegistration(WTFMove(registration));
151 
<span class="line-modified">152     auto worker = SWServerWorker::create(*this, *registrationPtr, data.scriptURL, data.script, data.contentSecurityPolicy, WTFMove(data.referrerPolicy), data.workerType, data.serviceWorkerIdentifier, WTFMove(data.scriptResourceMap));</span>
153     registrationPtr-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Active, worker.ptr());
154     worker-&gt;setState(ServiceWorkerState::Activated);
155 }
156 
157 void SWServer::addRegistration(std::unique_ptr&lt;SWServerRegistration&gt;&amp;&amp; registration)
158 {
159     auto key = registration-&gt;key();
160     auto* registrationPtr = registration.get();
161     auto addResult1 = m_registrations.add(key, WTFMove(registration));
162     ASSERT_UNUSED(addResult1, addResult1.isNewEntry);
163 
164     auto addResult2 = m_registrationsByID.add(registrationPtr-&gt;identifier(), registrationPtr);
165     ASSERT_UNUSED(addResult2, addResult2.isNewEntry);
166 
167     m_originStore-&gt;add(key.topOrigin());
168 }
169 
170 void SWServer::removeRegistration(const ServiceWorkerRegistrationKey&amp; key)
171 {
172     auto topOrigin = key.topOrigin();
173     auto registration = m_registrations.take(key);
174     ASSERT(registration);
175     bool wasRemoved = m_registrationsByID.remove(registration-&gt;identifier());
176     ASSERT_UNUSED(wasRemoved, wasRemoved);
177 
178     m_originStore-&gt;remove(topOrigin);
179     if (m_registrationStore)
<span class="line-modified">180         m_registrationStore-&gt;removeRegistration(key);</span>
181 }
182 
183 Vector&lt;ServiceWorkerRegistrationData&gt; SWServer::getRegistrations(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
184 {
185     Vector&lt;SWServerRegistration*&gt; matchingRegistrations;
186     for (auto&amp; item : m_registrations) {
187         if (!item.value-&gt;isUninstalling() &amp;&amp; item.key.originIsMatching(topOrigin, clientURL))
188             matchingRegistrations.append(item.value.get());
189     }
190     // The specification mandates that registrations are returned in the insertion order.
191     std::sort(matchingRegistrations.begin(), matchingRegistrations.end(), [](auto&amp; a, auto&amp; b) {
192         return a-&gt;creationTime() &lt; b-&gt;creationTime();
193     });
194     Vector&lt;ServiceWorkerRegistrationData&gt; matchingRegistrationDatas;
195     matchingRegistrationDatas.reserveInitialCapacity(matchingRegistrations.size());
196     for (auto* registration : matchingRegistrations)
197         matchingRegistrationDatas.uncheckedAppend(registration-&gt;data());
198     return matchingRegistrationDatas;
199 }
200 
201 void SWServer::clearAll(CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
202 {
203     if (!m_importCompleted) {
204         m_clearCompletionCallbacks.append([this, completionHandler = WTFMove(completionHandler)] () mutable {
205             ASSERT(m_importCompleted);
206             clearAll(WTFMove(completionHandler));
207         });
208         return;
209     }
210 
211     m_jobQueues.clear();
212     while (!m_registrations.isEmpty())
213         m_registrations.begin()-&gt;value-&gt;clear();
214     ASSERT(m_registrationsByID.isEmpty());
215     m_pendingContextDatas.clear();
216     m_originStore-&gt;clearAll();
217     if (m_registrationStore)
218         m_registrationStore-&gt;clearAll(WTFMove(completionHandler));
219 }
220 
<span class="line-added">221 void SWServer::startSuspension(CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)</span>
<span class="line-added">222 {</span>
<span class="line-added">223     if (!m_registrationStore) {</span>
<span class="line-added">224         completionHandler();</span>
<span class="line-added">225         return;</span>
<span class="line-added">226     }</span>
<span class="line-added">227     m_registrationStore-&gt;startSuspension(WTFMove(completionHandler));</span>
<span class="line-added">228 }</span>
<span class="line-added">229 </span>
<span class="line-added">230 void SWServer::endSuspension()</span>
<span class="line-added">231 {</span>
<span class="line-added">232     if (m_registrationStore)</span>
<span class="line-added">233         m_registrationStore-&gt;endSuspension();</span>
<span class="line-added">234 }</span>
<span class="line-added">235 </span>
236 void SWServer::clear(const SecurityOriginData&amp; securityOrigin, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
237 {
238     if (!m_importCompleted) {
239         m_clearCompletionCallbacks.append([this, securityOrigin, completionHandler = WTFMove(completionHandler)] () mutable {
240             ASSERT(m_importCompleted);
241             clear(securityOrigin, WTFMove(completionHandler));
242         });
243         return;
244     }
245 
246     m_jobQueues.removeIf([&amp;](auto&amp; keyAndValue) {
247         return keyAndValue.key.relatesToOrigin(securityOrigin);
248     });
249 
250     Vector&lt;SWServerRegistration*&gt; registrationsToRemove;
251     for (auto&amp; keyAndValue : m_registrations) {
252         if (keyAndValue.key.relatesToOrigin(securityOrigin))
253             registrationsToRemove.append(keyAndValue.value.get());
254     }
255 
</pre>
<hr />
<pre>
287     m_server.addClientServiceWorkerRegistration(*this, identifier);
288 }
289 
290 void SWServer::Connection::removeServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
291 {
292     m_server.removeClientServiceWorkerRegistration(*this, identifier);
293 }
294 
295 void SWServer::Connection::syncTerminateWorker(ServiceWorkerIdentifier identifier)
296 {
297     if (auto* worker = m_server.workerByID(identifier))
298         m_server.syncTerminateWorker(*worker);
299 }
300 
301 SWServer::SWServer(UniqueRef&lt;SWOriginStore&gt;&amp;&amp; originStore, String&amp;&amp; registrationDatabaseDirectory, PAL::SessionID sessionID)
302     : m_originStore(WTFMove(originStore))
303     , m_sessionID(sessionID)
304 {
305     ASSERT(!registrationDatabaseDirectory.isEmpty() || m_sessionID.isEphemeral());
306     if (!m_sessionID.isEphemeral())
<span class="line-modified">307         m_registrationStore = makeUnique&lt;RegistrationStore&gt;(*this, WTFMove(registrationDatabaseDirectory));</span>
308     else
309         registrationStoreImportComplete();
310 
311     UNUSED_PARAM(registrationDatabaseDirectory);
312     allServers().add(this);
313 }
314 
315 // https://w3c.github.io/ServiceWorker/#schedule-job-algorithm
316 void SWServer::scheduleJob(ServiceWorkerJobData&amp;&amp; jobData)
317 {
318     ASSERT(m_connections.contains(jobData.connectionIdentifier()));
319 
320     // FIXME: Per the spec, check if this job is equivalent to the last job on the queue.
321     // If it is, stack it along with that job.
322 
323     auto&amp; jobQueue = *m_jobQueues.ensure(jobData.registrationKey(), [this, &amp;jobData] {
<span class="line-modified">324         return makeUnique&lt;SWServerJobQueue&gt;(*this, jobData.registrationKey());</span>
325     }).iterator-&gt;value;
326 
327     jobQueue.enqueueJob(jobData);
328     if (jobQueue.size() == 1)
329         jobQueue.runNextJob();
330 }
331 
332 void SWServer::rejectJob(const ServiceWorkerJobData&amp; jobData, const ExceptionData&amp; exceptionData)
333 {
334     LOG(ServiceWorker, &quot;Rejected ServiceWorker job %s in server&quot;, jobData.identifier().loggingString().utf8().data());
335     auto* connection = m_connections.get(jobData.connectionIdentifier());
336     if (!connection)
337         return;
338 
339     connection-&gt;rejectJobInClient(jobData.identifier().jobIdentifier, exceptionData);
340 }
341 
342 void SWServer::resolveRegistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationData&amp; registrationData, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
343 {
344     LOG(ServiceWorker, &quot;Resolved ServiceWorker job %s in server with registration %s&quot;, jobData.identifier().loggingString().utf8().data(), registrationData.identifier.loggingString().utf8().data());
</pre>
<hr />
<pre>
516         LOG_ERROR(&quot;Request to add client-side ServiceWorkerRegistration to non-existent server-side registration&quot;);
517         return;
518     }
519 
520     registration-&gt;addClientServiceWorkerRegistration(connection.identifier());
521 }
522 
523 void SWServer::removeClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
524 {
525     if (auto* registration = m_registrationsByID.get(identifier))
526         registration-&gt;removeClientServiceWorkerRegistration(connection.identifier());
527 }
528 
529 void SWServer::updateWorker(Connection&amp;, const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, SWServerRegistration&amp; registration, const URL&amp; url, const String&amp; script, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, const String&amp; referrerPolicy, WorkerType type, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt;&amp;&amp; scriptResourceMap)
530 {
531     tryInstallContextData({ jobDataIdentifier, registration.data(), ServiceWorkerIdentifier::generate(), script, contentSecurityPolicy, referrerPolicy, url, type, sessionID(), false, WTFMove(scriptResourceMap) });
532 }
533 
534 void SWServer::tryInstallContextData(ServiceWorkerContextData&amp;&amp; data)
535 {
<span class="line-modified">536     RegistrableDomain registrableDomain(data.scriptURL);</span>
<span class="line-modified">537     auto* connection = SWServerToContextConnection::connectionForRegistrableDomain(registrableDomain);</span>
538     if (!connection) {
<span class="line-modified">539         m_pendingContextDatas.ensure(WTFMove(registrableDomain), [] {</span>
540             return Vector&lt;ServiceWorkerContextData&gt; { };
541         }).iterator-&gt;value.append(WTFMove(data));
542         return;
543     }
544 
545     installContextData(data);
546 }
547 
548 void SWServer::serverToContextConnectionCreated(SWServerToContextConnection&amp; contextConnection)
549 {
<span class="line-modified">550     for (auto&amp; connection : m_connections.values())</span>
<span class="line-added">551         connection-&gt;serverToContextConnectionCreated(contextConnection);</span>
<span class="line-added">552 </span>
<span class="line-added">553     auto pendingContextDatas = m_pendingContextDatas.take(contextConnection.registrableDomain());</span>
554     for (auto&amp; data : pendingContextDatas)
555         installContextData(data);
556 
<span class="line-modified">557     auto serviceWorkerRunRequests = m_serviceWorkerRunRequests.take(contextConnection.registrableDomain());</span>
558     for (auto&amp; item : serviceWorkerRunRequests) {
559         bool success = runServiceWorker(item.key);
560         for (auto&amp; callback : item.value)
561             callback(success ? &amp;contextConnection : nullptr);
562     }
563 }
564 
565 void SWServer::installContextData(const ServiceWorkerContextData&amp; data)
566 {
567     ASSERT_WITH_MESSAGE(!data.loadedFromDisk, &quot;Workers we just read from disk should only be launched as needed&quot;);
568 
569     if (data.jobDataIdentifier) {
570         // Abort if the job that scheduled this has been cancelled.
571         auto* jobQueue = m_jobQueues.get(data.registration.key);
572         if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*data.jobDataIdentifier))
573             return;
574     }
575 
576     auto* registration = m_registrations.get(data.registration.key);
577     RELEASE_ASSERT(registration);
</pre>
<hr />
<pre>
589 
590     connection-&gt;installServiceWorkerContext(data, m_sessionID, userAgent);
591 }
592 
593 void SWServer::runServiceWorkerIfNecessary(ServiceWorkerIdentifier identifier, RunServiceWorkerCallback&amp;&amp; callback)
594 {
595     auto* worker = workerByID(identifier);
596     if (!worker) {
597         callback(nullptr);
598         return;
599     }
600 
601     auto* contextConnection = worker-&gt;contextConnection();
602     if (worker-&gt;isRunning()) {
603         ASSERT(contextConnection);
604         callback(contextConnection);
605         return;
606     }
607 
608     if (!contextConnection) {
<span class="line-modified">609         auto&amp; serviceWorkerRunRequestsForOrigin = m_serviceWorkerRunRequests.ensure(worker-&gt;registrableDomain(), [] {</span>
610             return HashMap&lt;ServiceWorkerIdentifier, Vector&lt;RunServiceWorkerCallback&gt;&gt; { };
611         }).iterator-&gt;value;
612         serviceWorkerRunRequestsForOrigin.ensure(identifier, [&amp;] {
613             return Vector&lt;RunServiceWorkerCallback&gt; { };
614         }).iterator-&gt;value.append(WTFMove(callback));
615         return;
616     }
617 
618     bool success = runServiceWorker(identifier);
619     callback(success ? contextConnection : nullptr);
620 }
621 
622 bool SWServer::runServiceWorker(ServiceWorkerIdentifier identifier)
623 {
624     auto* worker = workerByID(identifier);
625     if (!worker)
626         return false;
627 
628     // If the registration for a working has been removed then the request to run
629     // the worker is moot.
</pre>
<hr />
<pre>
663     worker.setState(SWServerWorker::State::Terminating);
664 
665     auto* contextConnection = worker.contextConnection();
666     ASSERT(contextConnection);
667     if (!contextConnection) {
668         LOG_ERROR(&quot;Request to terminate a worker whose context connection does not exist&quot;);
669         workerContextTerminated(worker);
670         return;
671     }
672 
673     switch (mode) {
674     case Asynchronous:
675         contextConnection-&gt;terminateWorker(worker.identifier());
676         break;
677     case Synchronous:
678         contextConnection-&gt;syncTerminateWorker(worker.identifier());
679         break;
680     };
681 }
682 
<span class="line-modified">683 void SWServer::markAllWorkersForRegistrableDomainAsTerminated(const RegistrableDomain&amp; registrableDomain)</span>
684 {
685     Vector&lt;SWServerWorker*&gt; terminatedWorkers;
686     for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
<span class="line-modified">687         if (worker-&gt;registrableDomain() == registrableDomain)</span>
688             terminatedWorkers.append(worker.ptr());
689     }
690     for (auto&amp; terminatedWorker : terminatedWorkers)
691         workerContextTerminated(*terminatedWorker);
692 }
693 
694 void SWServer::workerContextTerminated(SWServerWorker&amp; worker)
695 {
696     worker.setState(SWServerWorker::State::NotRunning);
697 
698     if (auto* jobQueue = m_jobQueues.get(worker.registrationKey()))
699         jobQueue-&gt;cancelJobsFromServiceWorker(worker.identifier());
700 
701     // At this point if no registrations are referencing the worker then it will be destroyed,
702     // removing itself from the m_workersByID map.
703     auto result = m_runningOrTerminatingWorkers.take(worker.identifier());
704     ASSERT_UNUSED(result, result &amp;&amp; result-&gt;ptr() == &amp;worker);
705 }
706 
707 void SWServer::fireInstallEvent(SWServerWorker&amp; worker)
</pre>
<hr />
<pre>
770 void SWServer::registerServiceWorkerClient(ClientOrigin&amp;&amp; clientOrigin, ServiceWorkerClientData&amp;&amp; data, const Optional&lt;ServiceWorkerRegistrationIdentifier&gt;&amp; controllingServiceWorkerRegistrationIdentifier, String&amp;&amp; userAgent)
771 {
772     auto clientIdentifier = data.identifier;
773 
774     ASSERT(!m_clientsById.contains(clientIdentifier));
775     m_clientsById.add(clientIdentifier, WTFMove(data));
776 
777     auto&amp; clientIdentifiersForOrigin = m_clientIdentifiersPerOrigin.ensure(clientOrigin, [] {
778         return Clients { };
779     }).iterator-&gt;value;
780 
781     ASSERT(!clientIdentifiersForOrigin.identifiers.contains(clientIdentifier));
782     clientIdentifiersForOrigin.identifiers.append(clientIdentifier);
783 
784     if (!clientIdentifiersForOrigin.userAgent.isNull() &amp;&amp; clientIdentifiersForOrigin.userAgent != userAgent)
785         RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::registerServiceWorkerClient: Service worker has clients using different user agents&quot;, this);
786     clientIdentifiersForOrigin.userAgent = WTFMove(userAgent);
787 
788     clientIdentifiersForOrigin.terminateServiceWorkersTimer = nullptr;
789 
<span class="line-modified">790     m_clientsByRegistrableDomain.ensure(clientOrigin.clientRegistrableDomain(), [] {</span>
791         return HashSet&lt;ServiceWorkerClientIdentifier&gt; { };
792     }).iterator-&gt;value.add(clientIdentifier);
793 
794     if (!controllingServiceWorkerRegistrationIdentifier)
795         return;
796 
797     auto* controllingRegistration = m_registrationsByID.get(*controllingServiceWorkerRegistrationIdentifier);
798     if (!controllingRegistration || !controllingRegistration-&gt;activeWorker())
799         return;
800 
801     controllingRegistration-&gt;addClientUsingRegistration(clientIdentifier);
802     ASSERT(!m_clientToControllingRegistration.contains(clientIdentifier));
803     m_clientToControllingRegistration.add(clientIdentifier, *controllingServiceWorkerRegistrationIdentifier);
804 }
805 
806 void SWServer::unregisterServiceWorkerClient(const ClientOrigin&amp; clientOrigin, ServiceWorkerClientIdentifier clientIdentifier)
807 {
<span class="line-added">808     auto clientRegistrableDomain = clientOrigin.clientRegistrableDomain();</span>
<span class="line-added">809 </span>
810     bool wasRemoved = m_clientsById.remove(clientIdentifier);
811     ASSERT_UNUSED(wasRemoved, wasRemoved);
812 
813     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
814     ASSERT(iterator != m_clientIdentifiersPerOrigin.end());
815 
816     auto&amp; clientIdentifiers = iterator-&gt;value.identifiers;
817     clientIdentifiers.removeFirstMatching([&amp;] (const auto&amp; identifier) {
818         return clientIdentifier == identifier;
819     });
<span class="line-added">820 </span>
821     if (clientIdentifiers.isEmpty()) {
822         ASSERT(!iterator-&gt;value.terminateServiceWorkersTimer);
<span class="line-modified">823         iterator-&gt;value.terminateServiceWorkersTimer = makeUnique&lt;Timer&gt;([clientOrigin, clientRegistrableDomain, this] {</span>
824             Vector&lt;SWServerWorker*&gt; workersToTerminate;
825             for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
826                 if (worker-&gt;isRunning() &amp;&amp; worker-&gt;origin() == clientOrigin)
827                     workersToTerminate.append(worker.ptr());
828             }
829             for (auto* worker : workersToTerminate)
830                 terminateWorker(*worker);
831 
<span class="line-modified">832             if (!m_clientsByRegistrableDomain.contains(clientRegistrableDomain)) {</span>
<span class="line-modified">833                 if (auto* connection = SWServerToContextConnection::connectionForRegistrableDomain(clientRegistrableDomain))</span>
834                     connection-&gt;connectionMayNoLongerBeNeeded();
835             }
836 
837             m_clientIdentifiersPerOrigin.remove(clientOrigin);
838         });
839         iterator-&gt;value.terminateServiceWorkersTimer-&gt;startOneShot(m_shouldDisableServiceWorkerProcessTerminationDelay ? 0_s : terminationDelay);
840     }
841 
<span class="line-modified">842     auto clientsByRegistrableDomainIterator = m_clientsByRegistrableDomain.find(clientRegistrableDomain);</span>
<span class="line-modified">843     ASSERT(clientsByRegistrableDomainIterator != m_clientsByRegistrableDomain.end());</span>
<span class="line-modified">844     auto&amp; clientsForRegistrableDomain = clientsByRegistrableDomainIterator-&gt;value;</span>
<span class="line-modified">845     clientsForRegistrableDomain.remove(clientIdentifier);</span>
<span class="line-modified">846     if (clientsForRegistrableDomain.isEmpty())</span>
<span class="line-modified">847         m_clientsByRegistrableDomain.remove(clientsByRegistrableDomainIterator);</span>
848 
849     auto registrationIterator = m_clientToControllingRegistration.find(clientIdentifier);
850     if (registrationIterator == m_clientToControllingRegistration.end())
851         return;
852 
853     if (auto* registration = m_registrationsByID.get(registrationIterator-&gt;value))
854         registration-&gt;removeClientUsingRegistration(clientIdentifier);
855 
856     m_clientToControllingRegistration.remove(registrationIterator);
857 }
858 
<span class="line-modified">859 bool SWServer::needsServerToContextConnectionForRegistrableDomain(const RegistrableDomain&amp; registrableDomain) const</span>
860 {
<span class="line-modified">861     return m_clientsByRegistrableDomain.contains(registrableDomain);</span>
862 }
863 
864 void SWServer::resolveRegistrationReadyRequests(SWServerRegistration&amp; registration)
865 {
866     for (auto&amp; connection : m_connections.values())
867         connection-&gt;resolveRegistrationReadyRequests(registration);
868 }
869 
870 void SWServer::Connection::whenRegistrationReady(uint64_t registrationReadyRequestIdentifier, const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
871 {
872     if (auto* registration = doRegistrationMatching(topOrigin, clientURL)) {
873         if (registration-&gt;activeWorker()) {
874             registrationReady(registrationReadyRequestIdentifier, registration-&gt;data());
875             return;
876         }
877     }
878     m_registrationReadyRequests.append({ topOrigin, clientURL, registrationReadyRequestIdentifier });
879 }
880 
<span class="line-added">881 void SWServer::Connection::storeRegistrationsOnDisk(CompletionHandler&lt;void()&gt;&amp;&amp; callback)</span>
<span class="line-added">882 {</span>
<span class="line-added">883     if (!m_server.m_registrationStore) {</span>
<span class="line-added">884         callback();</span>
<span class="line-added">885         return;</span>
<span class="line-added">886     }</span>
<span class="line-added">887     m_server.m_registrationStore-&gt;closeDatabase(WTFMove(callback));</span>
<span class="line-added">888 }</span>
<span class="line-added">889 </span>
890 void SWServer::Connection::resolveRegistrationReadyRequests(SWServerRegistration&amp; registration)
891 {
892     m_registrationReadyRequests.removeAllMatching([&amp;](auto&amp; request) {
893         if (!registration.key().isMatching(request.topOrigin, request.clientURL))
894             return false;
895 
896         this-&gt;registrationReady(request.identifier, registration.data());
897         return true;
898     });
899 }
900 
901 void SWServer::getOriginsWithRegistrations(Function&lt;void(const HashSet&lt;SecurityOriginData&gt;&amp;)&gt;&amp;&amp; callback)
902 {
903     m_getOriginsWithRegistrationsCallbacks.append(WTFMove(callback));
904 
905     if (m_importCompleted)
906         performGetOriginsWithRegistrationsCallbacks();
907 }
908 
909 void SWServer::performGetOriginsWithRegistrationsCallbacks()
</pre>
</td>
</tr>
</table>
<center><a href="RegistrationStore.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWServer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>