<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2011 Google Inc. All rights reserved.
   4  * Copyright (C) 2009 Joseph Pecoraro
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  *
  10  * 1.  Redistributions of source code must retain the above copyright
  11  *     notice, this list of conditions and the following disclaimer.
  12  * 2.  Redistributions in binary form must reproduce the above copyright
  13  *     notice, this list of conditions and the following disclaimer in the
  14  *     documentation and/or other materials provided with the distribution.
  15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16  *     its contributors may be used to endorse or promote products derived
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #include &quot;config.h&quot;
  32 #include &quot;InspectorDOMAgent.h&quot;
  33 
  34 #include &quot;AXObjectCache.h&quot;
  35 #include &quot;AccessibilityNodeObject.h&quot;
  36 #include &quot;Attr.h&quot;
  37 #include &quot;CSSComputedStyleDeclaration.h&quot;
  38 #include &quot;CSSPropertyNames.h&quot;
  39 #include &quot;CSSPropertySourceData.h&quot;
  40 #include &quot;CSSRule.h&quot;
  41 #include &quot;CSSRuleList.h&quot;
  42 #include &quot;CSSStyleRule.h&quot;
  43 #include &quot;CSSStyleSheet.h&quot;
  44 #include &quot;CharacterData.h&quot;
  45 #include &quot;CommandLineAPIHost.h&quot;
  46 #include &quot;ContainerNode.h&quot;
  47 #include &quot;Cookie.h&quot;
  48 #include &quot;CookieJar.h&quot;
  49 #include &quot;DOMEditor.h&quot;
  50 #include &quot;DOMException.h&quot;
  51 #include &quot;DOMPatchSupport.h&quot;
  52 #include &quot;DOMWindow.h&quot;
  53 #include &quot;Document.h&quot;
  54 #include &quot;DocumentType.h&quot;
  55 #include &quot;Editing.h&quot;
  56 #include &quot;Element.h&quot;
  57 #include &quot;Event.h&quot;
  58 #include &quot;EventListener.h&quot;
  59 #include &quot;EventNames.h&quot;
  60 #include &quot;Frame.h&quot;
  61 #include &quot;FrameTree.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  62 #include &quot;FrameView.h&quot;</span>
<span class="line-added">  63 #include &quot;FullscreenManager.h&quot;</span>
  64 #include &quot;HTMLElement.h&quot;
  65 #include &quot;HTMLFrameOwnerElement.h&quot;
  66 #include &quot;HTMLMediaElement.h&quot;
  67 #include &quot;HTMLNames.h&quot;
  68 #include &quot;HTMLParserIdioms.h&quot;
  69 #include &quot;HTMLScriptElement.h&quot;
  70 #include &quot;HTMLStyleElement.h&quot;
  71 #include &quot;HTMLTemplateElement.h&quot;
  72 #include &quot;HTMLVideoElement.h&quot;
  73 #include &quot;HitTestResult.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  74 #include &quot;InspectorCSSAgent.h&quot;</span>
  75 #include &quot;InspectorClient.h&quot;
  76 #include &quot;InspectorController.h&quot;
  77 #include &quot;InspectorHistory.h&quot;
  78 #include &quot;InspectorNodeFinder.h&quot;
  79 #include &quot;InspectorOverlay.h&quot;
  80 #include &quot;InspectorPageAgent.h&quot;
  81 #include &quot;InstrumentingAgents.h&quot;
  82 #include &quot;IntRect.h&quot;
  83 #include &quot;JSDOMBindingSecurity.h&quot;
  84 #include &quot;JSEventListener.h&quot;
  85 #include &quot;JSNode.h&quot;
  86 #include &quot;MutationEvent.h&quot;
  87 #include &quot;Node.h&quot;
  88 #include &quot;NodeList.h&quot;
  89 #include &quot;Page.h&quot;
  90 #include &quot;Pasteboard.h&quot;
  91 #include &quot;PseudoElement.h&quot;
  92 #include &quot;RenderStyle.h&quot;
  93 #include &quot;RenderStyleConstants.h&quot;
  94 #include &quot;ScriptState.h&quot;
  95 #include &quot;ShadowRoot.h&quot;
  96 #include &quot;StaticNodeList.h&quot;
  97 #include &quot;StyleProperties.h&quot;
  98 #include &quot;StyleResolver.h&quot;
  99 #include &quot;StyleSheetList.h&quot;
 100 #include &quot;Text.h&quot;
 101 #include &quot;TextNodeTraversal.h&quot;
 102 #include &quot;Timer.h&quot;
 103 #include &quot;VideoPlaybackQuality.h&quot;
 104 #include &quot;WebInjectedScriptManager.h&quot;
 105 #include &quot;XPathResult.h&quot;
 106 #include &quot;markup.h&quot;
 107 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 108 #include &lt;JavaScriptCore/InjectedScript.h&gt;
 109 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
 110 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 111 #include &lt;pal/crypto/CryptoDigest.h&gt;
 112 #include &lt;wtf/text/Base64.h&gt;
 113 #include &lt;wtf/text/CString.h&gt;
 114 #include &lt;wtf/text/WTFString.h&gt;
 115 
 116 namespace WebCore {
 117 
 118 using namespace Inspector;
 119 
 120 using namespace HTMLNames;
 121 
 122 static const size_t maxTextSize = 10000;
 123 static const UChar ellipsisUChar[] = { 0x2026, 0 };
 124 
 125 static Color parseColor(const JSON::Object* colorObject)
 126 {
 127     if (!colorObject)
 128         return Color::transparent;
 129 
 130     int r = 0;
 131     int g = 0;
 132     int b = 0;
 133     if (!colorObject-&gt;getInteger(&quot;r&quot;, r) || !colorObject-&gt;getInteger(&quot;g&quot;, g) || !colorObject-&gt;getInteger(&quot;b&quot;, b))
 134         return Color::transparent;
 135 
 136     double a = 1.0;
 137     if (!colorObject-&gt;getDouble(&quot;a&quot;, a))
 138         return Color(r, g, b);
 139 
 140     // Clamp alpha to the [0..1] range.
 141     if (a &lt; 0)
 142         a = 0;
 143     else if (a &gt; 1)
 144         a = 1;
 145 
 146     return Color(r, g, b, static_cast&lt;int&gt;(a * 255));
 147 }
 148 
 149 static Color parseConfigColor(const String&amp; fieldName, const JSON::Object* configObject)
 150 {
 151     RefPtr&lt;JSON::Object&gt; colorObject;
 152     configObject-&gt;getObject(fieldName, colorObject);
 153 
 154     return parseColor(colorObject.get());
 155 }
 156 
 157 static bool parseQuad(const JSON::Array&amp; quadArray, FloatQuad* quad)
 158 {
 159     const size_t coordinatesInQuad = 8;
 160     double coordinates[coordinatesInQuad];
 161     if (quadArray.length() != coordinatesInQuad)
 162         return false;
 163     for (size_t i = 0; i &lt; coordinatesInQuad; ++i) {
 164         if (!quadArray.get(i)-&gt;asDouble(*(coordinates + i)))
 165             return false;
 166     }
 167     quad-&gt;setP1(FloatPoint(coordinates[0], coordinates[1]));
 168     quad-&gt;setP2(FloatPoint(coordinates[2], coordinates[3]));
 169     quad-&gt;setP3(FloatPoint(coordinates[4], coordinates[5]));
 170     quad-&gt;setP4(FloatPoint(coordinates[6], coordinates[7]));
 171 
 172     return true;
 173 }
 174 
 175 class RevalidateStyleAttributeTask {
 176     WTF_MAKE_FAST_ALLOCATED;
 177 public:
 178     RevalidateStyleAttributeTask(InspectorDOMAgent*);
 179     void scheduleFor(Element*);
 180     void reset() { m_timer.stop(); }
 181     void timerFired();
 182 
 183 private:
 184     InspectorDOMAgent* m_domAgent;
 185     Timer m_timer;
 186     HashSet&lt;RefPtr&lt;Element&gt;&gt; m_elements;
 187 };
 188 
 189 RevalidateStyleAttributeTask::RevalidateStyleAttributeTask(InspectorDOMAgent* domAgent)
 190     : m_domAgent(domAgent)
 191     , m_timer(*this, &amp;RevalidateStyleAttributeTask::timerFired)
 192 {
 193 }
 194 
 195 void RevalidateStyleAttributeTask::scheduleFor(Element* element)
 196 {
 197     m_elements.add(element);
 198     if (!m_timer.isActive())
 199         m_timer.startOneShot(0_s);
 200 }
 201 
 202 void RevalidateStyleAttributeTask::timerFired()
 203 {
 204     // The timer is stopped on m_domAgent destruction, so this method will never be called after m_domAgent has been destroyed.
 205     Vector&lt;Element*&gt; elements;
 206     for (auto&amp; element : m_elements)
 207         elements.append(element.get());
 208     m_domAgent-&gt;styleAttributeInvalidated(elements);
 209 
 210     m_elements.clear();
 211 }
 212 
 213 class InspectableNode final : public CommandLineAPIHost::InspectableObject {
 214 public:
 215     explicit InspectableNode(Node* node)
 216         : m_node(node)
 217     {
 218     }
 219 
 220     JSC::JSValue get(JSC::ExecState&amp; state) final
 221     {
 222         return InspectorDOMAgent::nodeAsScriptValue(state, m_node.get());
 223     }
 224 private:
 225     RefPtr&lt;Node&gt; m_node;
 226 };
 227 
 228 class EventFiredCallback final : public EventListener {
 229 public:
 230     static Ref&lt;EventFiredCallback&gt; create(InspectorDOMAgent&amp; domAgent)
 231     {
 232         return adoptRef(*new EventFiredCallback(domAgent));
 233     }
 234 
 235     bool operator==(const EventListener&amp; other) const final
 236     {
 237         return this == &amp;other;
 238     }
 239 
 240     void handleEvent(ScriptExecutionContext&amp;, Event&amp; event) final
 241     {
 242         if (!is&lt;Node&gt;(event.target()) || m_domAgent.m_dispatchedEvents.contains(&amp;event))
 243             return;
 244 
 245         auto* node = downcast&lt;Node&gt;(event.target());
 246         int nodeId = m_domAgent.pushNodePathToFrontend(node);
 247         if (!nodeId)
 248             return;
 249 
 250         m_domAgent.m_dispatchedEvents.add(&amp;event);
 251 
 252         RefPtr&lt;JSON::Object&gt; data = JSON::Object::create();
 253 
 254 #if ENABLE(FULLSCREEN_API)
 255         if (event.type() == eventNames().webkitfullscreenchangeEvent)
<a name="4" id="anc4"></a><span class="line-modified"> 256             data-&gt;setBoolean(&quot;enabled&quot;_s, !!node-&gt;document().fullscreenManager().fullscreenElement());</span>
 257 #endif // ENABLE(FULLSCREEN_API)
 258 
 259         auto timestamp = m_domAgent.m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
 260         m_domAgent.m_frontendDispatcher-&gt;didFireEvent(nodeId, event.type(), timestamp, data-&gt;size() ? WTFMove(data) : nullptr);
 261     }
 262 
 263 private:
 264     EventFiredCallback(InspectorDOMAgent&amp; domAgent)
 265         : EventListener(EventListener::CPPEventListenerType)
 266         , m_domAgent(domAgent)
 267     {
 268     }
 269 
 270     InspectorDOMAgent&amp; m_domAgent;
 271 };
 272 
 273 String InspectorDOMAgent::toErrorString(ExceptionCode ec)
 274 {
 275     return ec ? String(DOMException::name(ec)) : emptyString();
 276 }
 277 
 278 String InspectorDOMAgent::toErrorString(Exception&amp;&amp; exception)
 279 {
 280     return DOMException::name(exception.code());
 281 }
 282 
<a name="5" id="anc5"></a><span class="line-modified"> 283 InspectorDOMAgent::InspectorDOMAgent(PageAgentContext&amp; context, InspectorOverlay* overlay)</span>
 284     : InspectorAgentBase(&quot;DOM&quot;_s, context)
 285     , m_injectedScriptManager(context.injectedScriptManager)
<a name="6" id="anc6"></a><span class="line-modified"> 286     , m_frontendDispatcher(makeUnique&lt;Inspector::DOMFrontendDispatcher&gt;(context.frontendRouter))</span>
 287     , m_backendDispatcher(Inspector::DOMBackendDispatcher::create(context.backendDispatcher, this))
<a name="7" id="anc7"></a><span class="line-modified"> 288     , m_inspectedPage(context.inspectedPage)</span>
 289     , m_overlay(overlay)
 290 #if ENABLE(VIDEO)
 291     , m_mediaMetricsTimer(*this, &amp;InspectorDOMAgent::mediaMetricsTimerFired)
 292 #endif
 293 {
 294 }
 295 
<a name="8" id="anc8"></a><span class="line-modified"> 296 InspectorDOMAgent::~InspectorDOMAgent() = default;</span>




 297 
 298 void InspectorDOMAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 299 {
<a name="9" id="anc9"></a><span class="line-modified"> 300     m_history = makeUnique&lt;InspectorHistory&gt;();</span>
<span class="line-modified"> 301     m_domEditor = makeUnique&lt;DOMEditor&gt;(*m_history);</span>
 302 
 303     m_instrumentingAgents.setInspectorDOMAgent(this);
<a name="10" id="anc10"></a><span class="line-modified"> 304     m_document = m_inspectedPage.mainFrame().document();</span>
 305 
 306 #if ENABLE(VIDEO)
 307     if (m_document)
 308         addEventListenersToNode(*m_document);
 309 
 310     for (auto* mediaElement : HTMLMediaElement::allMediaElements())
 311         addEventListenersToNode(*mediaElement);
 312 #endif
<a name="11" id="anc11"></a>


 313 }
 314 
 315 void InspectorDOMAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
 316 {
 317     m_history.reset();
 318     m_domEditor.reset();
<a name="12" id="anc12"></a><span class="line-added"> 319     m_nodeToFocus = nullptr;</span>
 320     m_mousedOverNode = nullptr;
<a name="13" id="anc13"></a><span class="line-added"> 321     m_inspectedNode = nullptr;</span>
 322 
<a name="14" id="anc14"></a><span class="line-modified"> 323     ErrorString ignored;</span>
<span class="line-modified"> 324     setSearchingForNode(ignored, false, nullptr, false);</span>
<span class="line-modified"> 325     hideHighlight(ignored);</span>
 326 
 327     m_instrumentingAgents.setInspectorDOMAgent(nullptr);
 328     m_documentRequested = false;
 329     reset();
 330 }
 331 
 332 Vector&lt;Document*&gt; InspectorDOMAgent::documents()
 333 {
 334     Vector&lt;Document*&gt; result;
 335     for (Frame* frame = m_document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
 336         Document* document = frame-&gt;document();
 337         if (!document)
 338             continue;
 339         result.append(document);
 340     }
 341     return result;
 342 }
 343 
 344 void InspectorDOMAgent::reset()
 345 {
 346     if (m_history)
 347         m_history-&gt;reset();
 348     m_searchResults.clear();
 349     discardBindings();
 350     if (m_revalidateStyleAttrTask)
 351         m_revalidateStyleAttrTask-&gt;reset();
 352     m_document = nullptr;
 353 }
 354 
<a name="15" id="anc15"></a>




 355 void InspectorDOMAgent::setDocument(Document* document)
 356 {
 357     if (document == m_document.get())
 358         return;
 359 
 360     reset();
 361 
 362     m_document = document;
 363 
 364     if (!m_documentRequested)
 365         return;
 366 
 367     // Immediately communicate null document or document that has finished loading.
 368     if (!document || !document-&gt;parsing())
 369         m_frontendDispatcher-&gt;documentUpdated();
 370 }
 371 
 372 void InspectorDOMAgent::releaseDanglingNodes()
 373 {
 374     m_danglingNodeToIdMaps.clear();
 375 }
 376 
 377 int InspectorDOMAgent::bind(Node* node, NodeToIdMap* nodesMap)
 378 {
 379     int id = nodesMap-&gt;get(node);
 380     if (id)
 381         return id;
 382     id = m_lastNodeId++;
 383     nodesMap-&gt;set(node, id);
 384     m_idToNode.set(id, node);
 385     m_idToNodesMap.set(id, nodesMap);
 386     return id;
 387 }
 388 
 389 void InspectorDOMAgent::unbind(Node* node, NodeToIdMap* nodesMap)
 390 {
 391     int id = nodesMap-&gt;get(node);
 392     if (!id)
 393         return;
 394 
 395     m_idToNode.remove(id);
 396 
 397     if (node-&gt;isFrameOwnerElement()) {
 398         const HTMLFrameOwnerElement* frameOwner = static_cast&lt;const HTMLFrameOwnerElement*&gt;(node);
 399         if (Document* contentDocument = frameOwner-&gt;contentDocument())
 400             unbind(contentDocument, nodesMap);
 401     }
 402 
 403     if (is&lt;Element&gt;(*node)) {
 404         Element&amp; element = downcast&lt;Element&gt;(*node);
 405         if (ShadowRoot* root = element.shadowRoot())
 406             unbind(root, nodesMap);
 407         if (PseudoElement* beforeElement = element.beforePseudoElement())
 408             unbind(beforeElement, nodesMap);
 409         if (PseudoElement* afterElement = element.afterPseudoElement())
 410             unbind(afterElement, nodesMap);
 411     }
 412 
 413     nodesMap-&gt;remove(node);
<a name="16" id="anc16"></a><span class="line-modified"> 414 </span>
<span class="line-modified"> 415     if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())</span>
<span class="line-added"> 416         cssAgent-&gt;didRemoveDOMNode(*node, id);</span>
 417 
 418     if (m_childrenRequested.remove(id)) {
 419         // FIXME: Would be better to do this iteratively rather than recursively.
 420         for (Node* child = innerFirstChild(node); child; child = innerNextSibling(child))
 421             unbind(child, nodesMap);
 422     }
 423 }
 424 
 425 Node* InspectorDOMAgent::assertNode(ErrorString&amp; errorString, int nodeId)
 426 {
 427     Node* node = nodeForId(nodeId);
 428     if (!node) {
<a name="17" id="anc17"></a><span class="line-modified"> 429         errorString = &quot;Missing node for given nodeId&quot;_s;</span>
 430         return nullptr;
 431     }
 432     return node;
 433 }
 434 
 435 Document* InspectorDOMAgent::assertDocument(ErrorString&amp; errorString, int nodeId)
 436 {
 437     Node* node = assertNode(errorString, nodeId);
 438     if (!node)
 439         return nullptr;
<a name="18" id="anc18"></a><span class="line-modified"> 440     if (!is&lt;Document&gt;(node)) {</span>
<span class="line-modified"> 441         errorString = &quot;Node for given nodeId is not a document&quot;_s;</span>
 442         return nullptr;
 443     }
 444     return downcast&lt;Document&gt;(node);
 445 }
 446 
 447 Element* InspectorDOMAgent::assertElement(ErrorString&amp; errorString, int nodeId)
 448 {
 449     Node* node = assertNode(errorString, nodeId);
 450     if (!node)
 451         return nullptr;
<a name="19" id="anc19"></a><span class="line-modified"> 452     if (!is&lt;Element&gt;(node)) {</span>
<span class="line-modified"> 453         errorString = &quot;Node for given nodeId is not an element&quot;_s;</span>
 454         return nullptr;
 455     }
 456     return downcast&lt;Element&gt;(node);
 457 }
 458 
 459 Node* InspectorDOMAgent::assertEditableNode(ErrorString&amp; errorString, int nodeId)
 460 {
 461     Node* node = assertNode(errorString, nodeId);
 462     if (!node)
 463         return nullptr;
 464     if (node-&gt;isInUserAgentShadowTree()) {
<a name="20" id="anc20"></a><span class="line-modified"> 465         errorString = &quot;Node for given nodeId is in a shadow tree&quot;_s;</span>
 466         return nullptr;
 467     }
 468     if (node-&gt;isPseudoElement()) {
<a name="21" id="anc21"></a><span class="line-modified"> 469         errorString = &quot;Node for given nodeId is a pseudo-element&quot;_s;</span>
 470         return nullptr;
 471     }
 472     return node;
 473 }
 474 
 475 Element* InspectorDOMAgent::assertEditableElement(ErrorString&amp; errorString, int nodeId)
 476 {
<a name="22" id="anc22"></a><span class="line-modified"> 477     Node* node = assertEditableNode(errorString, nodeId);</span>
<span class="line-modified"> 478     if (!node)</span>



 479         return nullptr;
<a name="23" id="anc23"></a><span class="line-modified"> 480     if (!is&lt;Element&gt;(node)) {</span>
<span class="line-modified"> 481         errorString = &quot;Node for given nodeId is not an element&quot;_s;</span>

 482         return nullptr;
 483     }
<a name="24" id="anc24"></a><span class="line-modified"> 484     return downcast&lt;Element&gt;(node);</span>
 485 }
 486 
 487 void InspectorDOMAgent::getDocument(ErrorString&amp; errorString, RefPtr&lt;Inspector::Protocol::DOM::Node&gt;&amp; root)
 488 {
 489     m_documentRequested = true;
 490 
 491     if (!m_document) {
<a name="25" id="anc25"></a><span class="line-modified"> 492         errorString = &quot;Internal error: missing document&quot;_s;</span>
 493         return;
 494     }
 495 
 496     // Reset backend state.
 497     RefPtr&lt;Document&gt; document = m_document;
 498     reset();
 499     m_document = document;
 500 
 501     root = buildObjectForNode(m_document.get(), 2, &amp;m_documentNodeToIdMap);
<a name="26" id="anc26"></a><span class="line-added"> 502 </span>
<span class="line-added"> 503     if (m_nodeToFocus)</span>
<span class="line-added"> 504         focusNode();</span>
 505 }
 506 
 507 void InspectorDOMAgent::pushChildNodesToFrontend(int nodeId, int depth)
 508 {
 509     Node* node = nodeForId(nodeId);
 510     if (!node || (node-&gt;nodeType() != Node::ELEMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_FRAGMENT_NODE))
 511         return;
 512 
 513     NodeToIdMap* nodeMap = m_idToNodesMap.get(nodeId);
 514 
 515     if (m_childrenRequested.contains(nodeId)) {
 516         if (depth &lt;= 1)
 517             return;
 518 
 519         depth--;
 520 
 521         for (node = innerFirstChild(node); node; node = innerNextSibling(node)) {
 522             int childNodeId = nodeMap-&gt;get(node);
 523             ASSERT(childNodeId);
 524             pushChildNodesToFrontend(childNodeId, depth);
 525         }
 526 
 527         return;
 528     }
 529 
 530     auto children = buildArrayForContainerChildren(node, depth, nodeMap);
 531     m_frontendDispatcher-&gt;setChildNodes(nodeId, WTFMove(children));
 532 }
 533 
 534 void InspectorDOMAgent::discardBindings()
 535 {
 536     m_documentNodeToIdMap.clear();
 537     m_idToNode.clear();
 538     m_dispatchedEvents.clear();
 539     m_eventListenerEntries.clear();
 540     releaseDanglingNodes();
 541     m_childrenRequested.clear();
 542 }
 543 
 544 int InspectorDOMAgent::pushNodeToFrontend(ErrorString&amp; errorString, int documentNodeId, Node* nodeToPush)
 545 {
 546     Document* document = assertDocument(errorString, documentNodeId);
 547     if (!document)
 548         return 0;
 549     if (&amp;nodeToPush-&gt;document() != document) {
<a name="27" id="anc27"></a><span class="line-modified"> 550         errorString = &quot;nodeToPush is not part of the document with given documentNodeId&quot;_s;</span>
 551         return 0;
 552     }
 553 
 554     return pushNodePathToFrontend(nodeToPush);
 555 }
 556 
 557 Node* InspectorDOMAgent::nodeForId(int id)
 558 {
 559     if (!m_idToNode.isValidKey(id))
 560         return nullptr;
 561 
 562     return m_idToNode.get(id);
 563 }
 564 
 565 void InspectorDOMAgent::requestChildNodes(ErrorString&amp; errorString, int nodeId, const int* depth)
 566 {
 567     int sanitizedDepth;
 568 
 569     if (!depth)
 570         sanitizedDepth = 1;
 571     else if (*depth == -1)
 572         sanitizedDepth = INT_MAX;
 573     else if (*depth &gt; 0)
 574         sanitizedDepth = *depth;
 575     else {
<a name="28" id="anc28"></a><span class="line-modified"> 576         errorString = &quot;Unexpected value below -1 for given depth&quot;_s;</span>
 577         return;
 578     }
 579 
 580     pushChildNodesToFrontend(nodeId, sanitizedDepth);
 581 }
 582 
 583 void InspectorDOMAgent::querySelector(ErrorString&amp; errorString, int nodeId, const String&amp; selectors, int* elementId)
 584 {
 585     *elementId = 0;
 586     Node* node = assertNode(errorString, nodeId);
 587     if (!node)
 588         return;
 589     if (!is&lt;ContainerNode&gt;(*node)) {
 590         assertElement(errorString, nodeId);
 591         return;
 592     }
 593 
 594     auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelector(selectors);
 595     if (queryResult.hasException()) {
<a name="29" id="anc29"></a><span class="line-modified"> 596         errorString = &quot;DOM Error while querying with given selectors&quot;_s;</span>
 597         return;
 598     }
 599 
 600     if (auto* element = queryResult.releaseReturnValue())
 601         *elementId = pushNodePathToFrontend(element);
 602 }
 603 
 604 void InspectorDOMAgent::querySelectorAll(ErrorString&amp; errorString, int nodeId, const String&amp; selectors, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result)
 605 {
 606     Node* node = assertNode(errorString, nodeId);
 607     if (!node)
 608         return;
 609     if (!is&lt;ContainerNode&gt;(*node)) {
 610         assertElement(errorString, nodeId);
 611         return;
 612     }
 613 
 614     auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelectorAll(selectors);
 615     if (queryResult.hasException()) {
<a name="30" id="anc30"></a><span class="line-modified"> 616         errorString = &quot;DOM Error while querying with given selectors&quot;_s;</span>
 617         return;
 618     }
 619 
 620     auto nodes = queryResult.releaseReturnValue();
 621     result = JSON::ArrayOf&lt;int&gt;::create();
 622     for (unsigned i = 0; i &lt; nodes-&gt;length(); ++i)
 623         result-&gt;addItem(pushNodePathToFrontend(nodes-&gt;item(i)));
 624 }
 625 
 626 int InspectorDOMAgent::pushNodePathToFrontend(Node* nodeToPush)
 627 {
 628     ASSERT(nodeToPush);  // Invalid input
 629 
 630     if (!m_document)
 631         return 0;
 632     if (!m_documentNodeToIdMap.contains(m_document))
 633         return 0;
 634 
 635     // Return id in case the node is known.
 636     int result = m_documentNodeToIdMap.get(nodeToPush);
 637     if (result)
 638         return result;
 639 
 640     Node* node = nodeToPush;
 641     Vector&lt;Node*&gt; path;
 642     NodeToIdMap* danglingMap = 0;
 643 
 644     while (true) {
 645         Node* parent = innerParentNode(node);
 646         if (!parent) {
 647             // Node being pushed is detached -&gt; push subtree root.
<a name="31" id="anc31"></a><span class="line-modified"> 648             auto newMap = makeUnique&lt;NodeToIdMap&gt;();</span>
 649             danglingMap = newMap.get();
 650             m_danglingNodeToIdMaps.append(newMap.release());
 651             auto children = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
 652             children-&gt;addItem(buildObjectForNode(node, 0, danglingMap));
 653             m_frontendDispatcher-&gt;setChildNodes(0, WTFMove(children));
 654             break;
 655         } else {
 656             path.append(parent);
 657             if (m_documentNodeToIdMap.get(parent))
 658                 break;
 659             else
 660                 node = parent;
 661         }
 662     }
 663 
 664     NodeToIdMap* map = danglingMap ? danglingMap : &amp;m_documentNodeToIdMap;
 665     for (int i = path.size() - 1; i &gt;= 0; --i) {
 666         int nodeId = map-&gt;get(path.at(i));
 667         ASSERT(nodeId);
 668         pushChildNodesToFrontend(nodeId);
 669     }
 670     return map-&gt;get(nodeToPush);
 671 }
 672 
 673 int InspectorDOMAgent::boundNodeId(const Node* node)
 674 {
 675     return m_documentNodeToIdMap.get(const_cast&lt;Node*&gt;(node));
 676 }
 677 
 678 void InspectorDOMAgent::setAttributeValue(ErrorString&amp; errorString, int elementId, const String&amp; name, const String&amp; value)
 679 {
 680     Element* element = assertEditableElement(errorString, elementId);
 681     if (!element)
 682         return;
 683 
 684     m_domEditor-&gt;setAttribute(*element, name, value, errorString);
 685 }
 686 
 687 void InspectorDOMAgent::setAttributesAsText(ErrorString&amp; errorString, int elementId, const String&amp; text, const String* name)
 688 {
 689     Element* element = assertEditableElement(errorString, elementId);
 690     if (!element)
 691         return;
 692 
 693     auto parsedElement = createHTMLElement(element-&gt;document(), spanTag);
 694     auto result = parsedElement.get().setInnerHTML(&quot;&lt;span &quot; + text + &quot;&gt;&lt;/span&gt;&quot;);
 695     if (result.hasException()) {
 696         errorString = toErrorString(result.releaseException());
 697         return;
 698     }
 699 
 700     Node* child = parsedElement-&gt;firstChild();
 701     if (!child) {
<a name="32" id="anc32"></a><span class="line-modified"> 702         errorString = &quot;Could not parse given text&quot;_s;</span>
 703         return;
 704     }
 705 
 706     Element* childElement = downcast&lt;Element&gt;(child);
 707     if (!childElement-&gt;hasAttributes() &amp;&amp; name) {
 708         m_domEditor-&gt;removeAttribute(*element, *name, errorString);
 709         return;
 710     }
 711 
 712     bool foundOriginalAttribute = false;
 713     for (const Attribute&amp; attribute : childElement-&gt;attributesIterator()) {
 714         // Add attribute pair
 715         foundOriginalAttribute = foundOriginalAttribute || (name &amp;&amp; attribute.name().toString() == *name);
 716         if (!m_domEditor-&gt;setAttribute(*element, attribute.name().toString(), attribute.value(), errorString))
 717             return;
 718     }
 719 
 720     if (!foundOriginalAttribute &amp;&amp; name &amp;&amp; !name-&gt;stripWhiteSpace().isEmpty())
 721         m_domEditor-&gt;removeAttribute(*element, *name, errorString);
 722 }
 723 
 724 void InspectorDOMAgent::removeAttribute(ErrorString&amp; errorString, int elementId, const String&amp; name)
 725 {
 726     Element* element = assertEditableElement(errorString, elementId);
 727     if (!element)
 728         return;
 729 
 730     m_domEditor-&gt;removeAttribute(*element, name, errorString);
 731 }
 732 
 733 void InspectorDOMAgent::removeNode(ErrorString&amp; errorString, int nodeId)
 734 {
 735     Node* node = assertEditableNode(errorString, nodeId);
 736     if (!node)
 737         return;
 738 
 739     ContainerNode* parentNode = node-&gt;parentNode();
 740     if (!parentNode) {
 741         errorString = &quot;Cannot remove detached node&quot;_s;
 742         return;
 743     }
 744 
 745     m_domEditor-&gt;removeChild(*parentNode, *node, errorString);
 746 }
 747 
 748 void InspectorDOMAgent::setNodeName(ErrorString&amp; errorString, int nodeId, const String&amp; tagName, int* newId)
 749 {
 750     *newId = 0;
 751 
 752     RefPtr&lt;Node&gt; oldNode = nodeForId(nodeId);
 753     if (!is&lt;Element&gt;(oldNode))
 754         return;
 755 
 756     auto createElementResult = oldNode-&gt;document().createElementForBindings(tagName);
 757     if (createElementResult.hasException())
 758         return;
 759     auto newElement = createElementResult.releaseReturnValue();
 760 
 761     // Copy over the original node&#39;s attributes.
 762     newElement-&gt;cloneAttributesFromElement(downcast&lt;Element&gt;(*oldNode));
 763 
 764     // Copy over the original node&#39;s children.
 765     RefPtr&lt;Node&gt; child;
 766     while ((child = oldNode-&gt;firstChild())) {
 767         if (!m_domEditor-&gt;insertBefore(newElement, *child, 0, errorString))
 768             return;
 769     }
 770 
 771     // Replace the old node with the new node
 772     RefPtr&lt;ContainerNode&gt; parent = oldNode-&gt;parentNode();
 773     if (!m_domEditor-&gt;insertBefore(*parent, newElement.copyRef(), oldNode-&gt;nextSibling(), errorString))
 774         return;
 775     if (!m_domEditor-&gt;removeChild(*parent, *oldNode, errorString))
 776         return;
 777 
 778     *newId = pushNodePathToFrontend(newElement.ptr());
 779     if (m_childrenRequested.contains(nodeId))
 780         pushChildNodesToFrontend(*newId);
 781 }
 782 
 783 void InspectorDOMAgent::getOuterHTML(ErrorString&amp; errorString, int nodeId, WTF::String* outerHTML)
 784 {
 785     Node* node = assertNode(errorString, nodeId);
 786     if (!node)
 787         return;
 788 
 789     *outerHTML = serializeFragment(*node, SerializedNodes::SubtreeIncludingNode);
 790 }
 791 
 792 void InspectorDOMAgent::setOuterHTML(ErrorString&amp; errorString, int nodeId, const String&amp; outerHTML)
 793 {
 794     if (!nodeId) {
 795         DOMPatchSupport { *m_domEditor, *m_document }.patchDocument(outerHTML);
 796         return;
 797     }
 798 
 799     Node* node = assertEditableNode(errorString, nodeId);
 800     if (!node)
 801         return;
 802 
 803     Document&amp; document = node-&gt;document();
 804     if (!document.isHTMLDocument() &amp;&amp; !document.isXMLDocument()) {
<a name="33" id="anc33"></a><span class="line-modified"> 805         errorString = &quot;Document of node for given nodeId is not HTML/XML&quot;_s;</span>
 806         return;
 807     }
 808 
 809     Node* newNode = nullptr;
 810     if (!m_domEditor-&gt;setOuterHTML(*node, outerHTML, newNode, errorString))
 811         return;
 812 
 813     if (!newNode) {
 814         // The only child node has been deleted.
 815         return;
 816     }
 817 
 818     int newId = pushNodePathToFrontend(newNode);
 819 
 820     bool childrenRequested = m_childrenRequested.contains(nodeId);
 821     if (childrenRequested)
 822         pushChildNodesToFrontend(newId);
 823 }
 824 
 825 void InspectorDOMAgent::insertAdjacentHTML(ErrorString&amp; errorString, int nodeId, const String&amp; position, const String&amp; html)
 826 {
 827     Node* node = assertEditableNode(errorString, nodeId);
 828     if (!node)
 829         return;
 830 
 831     if (!is&lt;Element&gt;(node)) {
<a name="34" id="anc34"></a><span class="line-modified"> 832         errorString = &quot;Node for given nodeId is not an element&quot;_s;</span>
 833         return;
 834     }
 835 
 836     m_domEditor-&gt;insertAdjacentHTML(downcast&lt;Element&gt;(*node), position, html, errorString);
 837 }
 838 
 839 void InspectorDOMAgent::setNodeValue(ErrorString&amp; errorString, int nodeId, const String&amp; value)
 840 {
 841     Node* node = assertEditableNode(errorString, nodeId);
 842     if (!node)
 843         return;
 844 
 845     if (!is&lt;Text&gt;(*node)) {
<a name="35" id="anc35"></a><span class="line-modified"> 846         errorString = &quot;Node for given nodeId is not text&quot;_s;</span>
 847         return;
 848     }
 849 
 850     m_domEditor-&gt;replaceWholeText(downcast&lt;Text&gt;(*node), value, errorString);
 851 }
 852 
 853 void InspectorDOMAgent::getSupportedEventNames(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; eventNames)
 854 {
 855     eventNames = JSON::ArrayOf&lt;String&gt;::create();
 856 
 857 #define DOM_EVENT_NAMES_ADD(name) eventNames-&gt;addItem(#name);
 858     DOM_EVENT_NAMES_FOR_EACH(DOM_EVENT_NAMES_ADD)
 859 #undef DOM_EVENT_NAMES_ADD
 860 }
 861 
<a name="36" id="anc36"></a><span class="line-modified"> 862 void InspectorDOMAgent::getDataBindingsForNode(ErrorString&amp; errorString, int /* nodeId */, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::DataBinding&gt;&gt;&amp; /* dataBindings */)</span>
<span class="line-added"> 863 {</span>
<span class="line-added"> 864     errorString = &quot;Not supported&quot;_s;</span>
<span class="line-added"> 865 }</span>
<span class="line-added"> 866 </span>
<span class="line-added"> 867 void InspectorDOMAgent::getAssociatedDataForNode(ErrorString&amp; errorString, int /* nodeId */, Optional&lt;String&gt;&amp; /* associatedData */)</span>
<span class="line-added"> 868 {</span>
<span class="line-added"> 869     errorString = &quot;Not supported&quot;_s;</span>
<span class="line-added"> 870 }</span>
<span class="line-added"> 871 </span>
<span class="line-added"> 872 void InspectorDOMAgent::getEventListenersForNode(ErrorString&amp; errorString, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;&gt;&amp; listenersArray)</span>
 873 {
 874     listenersArray = JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;::create();
<a name="37" id="anc37"></a><span class="line-modified"> 875 </span>
<span class="line-added"> 876     auto* node = assertNode(errorString, nodeId);</span>
 877     if (!node)
 878         return;
<a name="38" id="anc38"></a><span class="line-added"> 879 </span>
<span class="line-added"> 880     Vector&lt;RefPtr&lt;EventTarget&gt;&gt; ancestors;</span>
<span class="line-added"> 881     ancestors.append(node);</span>
<span class="line-added"> 882     for (auto* ancestor = node-&gt;parentOrShadowHostNode(); ancestor; ancestor = ancestor-&gt;parentOrShadowHostNode())</span>
<span class="line-added"> 883         ancestors.append(ancestor);</span>
<span class="line-added"> 884     if (auto* window = node-&gt;document().domWindow())</span>
<span class="line-added"> 885         ancestors.append(window);</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887     struct EventListenerInfo {</span>
<span class="line-added"> 888         RefPtr&lt;EventTarget&gt; eventTarget;</span>
<span class="line-added"> 889         const AtomString eventType;</span>
<span class="line-added"> 890         const EventListenerVector eventListeners;</span>
<span class="line-added"> 891     };</span>
<span class="line-added"> 892 </span>
 893     Vector&lt;EventListenerInfo&gt; eventInformation;
<a name="39" id="anc39"></a><span class="line-modified"> 894     for (size_t i = ancestors.size(); i; --i) {</span>
<span class="line-added"> 895         auto&amp; ancestor = ancestors[i - 1];</span>
<span class="line-added"> 896         for (auto&amp; eventType : ancestor-&gt;eventTypes()) {</span>
<span class="line-added"> 897             EventListenerVector filteredListeners;</span>
<span class="line-added"> 898             for (auto&amp; listener : ancestor-&gt;eventListeners(eventType)) {</span>
<span class="line-added"> 899                 if (listener-&gt;callback().type() == EventListener::JSEventListenerType)</span>
<span class="line-added"> 900                     filteredListeners.append(listener);</span>
<span class="line-added"> 901             }</span>
<span class="line-added"> 902             if (!filteredListeners.isEmpty())</span>
<span class="line-added"> 903                 eventInformation.append({ ancestor, eventType, WTFMove(filteredListeners) });</span>
<span class="line-added"> 904         }</span>
<span class="line-added"> 905     }</span>
 906 
 907     auto addListener = [&amp;] (RegisteredEventListener&amp; listener, const EventListenerInfo&amp; info) {
 908         int identifier = 0;
 909         bool disabled = false;
 910         bool hasBreakpoint = false;
 911 
 912         for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
<a name="40" id="anc40"></a><span class="line-modified"> 913             if (inspectorEventListener.matches(*info.eventTarget, info.eventType, listener.callback(), listener.useCapture())) {</span>
 914                 identifier = inspectorEventListener.identifier;
 915                 disabled = inspectorEventListener.disabled;
 916                 hasBreakpoint = inspectorEventListener.hasBreakpoint;
 917                 break;
 918             }
 919         }
 920 
 921         if (!identifier) {
<a name="41" id="anc41"></a><span class="line-modified"> 922             InspectorEventListener inspectorEventListener(m_lastEventListenerId++, *info.eventTarget, info.eventType, listener.callback(), listener.useCapture());</span>
 923 
 924             identifier = inspectorEventListener.identifier;
 925             disabled = inspectorEventListener.disabled;
 926             hasBreakpoint = inspectorEventListener.hasBreakpoint;
 927 
 928             m_eventListenerEntries.add(identifier, inspectorEventListener);
 929         }
 930 
<a name="42" id="anc42"></a><span class="line-modified"> 931         listenersArray-&gt;addItem(buildObjectForEventListener(listener, identifier, *info.eventTarget, info.eventType, disabled, hasBreakpoint));</span>
 932     };
 933 
 934     // Get Capturing Listeners (in this order)
 935     size_t eventInformationLength = eventInformation.size();
 936     for (auto&amp; info : eventInformation) {
<a name="43" id="anc43"></a><span class="line-modified"> 937         for (auto&amp; listener : info.eventListeners) {</span>
 938             if (listener-&gt;useCapture())
 939                 addListener(*listener, info);
 940         }
 941     }
 942 
 943     // Get Bubbling Listeners (reverse order)
 944     for (size_t i = eventInformationLength; i; --i) {
 945         const EventListenerInfo&amp; info = eventInformation[i - 1];
<a name="44" id="anc44"></a><span class="line-modified"> 946         for (auto&amp; listener : info.eventListeners) {</span>
 947             if (!listener-&gt;useCapture())
 948                 addListener(*listener, info);
 949         }
 950     }
<a name="45" id="anc45"></a>











 951 
<a name="46" id="anc46"></a><span class="line-modified"> 952     if (m_inspectedNode == node)</span>
<span class="line-modified"> 953         m_suppressEventListenerChangedEvent = false;</span>

















 954 }
 955 
 956 void InspectorDOMAgent::setEventListenerDisabled(ErrorString&amp; errorString, int eventListenerId, bool disabled)
 957 {
 958     auto it = m_eventListenerEntries.find(eventListenerId);
 959     if (it == m_eventListenerEntries.end()) {
<a name="47" id="anc47"></a><span class="line-modified"> 960         errorString = &quot;Missing event listener for given eventListenerId&quot;_s;</span>
 961         return;
 962     }
 963 
 964     it-&gt;value.disabled = disabled;
 965 }
 966 
 967 void InspectorDOMAgent::setBreakpointForEventListener(ErrorString&amp; errorString, int eventListenerId)
 968 {
 969     auto it = m_eventListenerEntries.find(eventListenerId);
 970     if (it == m_eventListenerEntries.end()) {
<a name="48" id="anc48"></a><span class="line-modified"> 971         errorString = &quot;Missing event listener for given eventListenerId&quot;_s;</span>
 972         return;
 973     }
 974 
 975     it-&gt;value.hasBreakpoint = true;
 976 }
 977 
 978 void InspectorDOMAgent::removeBreakpointForEventListener(ErrorString&amp; errorString, int eventListenerId)
 979 {
 980     auto it = m_eventListenerEntries.find(eventListenerId);
 981     if (it == m_eventListenerEntries.end()) {
<a name="49" id="anc49"></a><span class="line-modified"> 982         errorString = &quot;Missing event listener for given eventListenerId&quot;_s;</span>
 983         return;
 984     }
 985 
 986     it-&gt;value.hasBreakpoint = false;
 987 }
 988 
 989 void InspectorDOMAgent::getAccessibilityPropertiesForNode(ErrorString&amp; errorString, int nodeId, RefPtr&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt;&amp; axProperties)
 990 {
 991     Node* node = assertNode(errorString, nodeId);
 992     if (!node)
 993         return;
 994 
 995     axProperties = buildObjectForAccessibilityProperties(node);
 996 }
 997 
<a name="50" id="anc50"></a><span class="line-modified"> 998 void InspectorDOMAgent::performSearch(ErrorString&amp; errorString, const String&amp; query, const JSON::Array* nodeIds, const bool* caseSensitive, String* searchId, int* resultCount)</span>
 999 {
1000     // FIXME: Search works with node granularity - number of matches within node is not calculated.
<a name="51" id="anc51"></a><span class="line-modified">1001     InspectorNodeFinder finder(query, caseSensitive &amp;&amp; *caseSensitive);</span>
1002 
1003     if (nodeIds) {
1004         for (auto&amp; nodeValue : *nodeIds) {
1005             if (!nodeValue) {
<a name="52" id="anc52"></a><span class="line-modified">1006                 errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;</span>
1007                 return;
1008             }
1009             int nodeId = 0;
1010             if (!nodeValue-&gt;asInteger(nodeId)) {
<a name="53" id="anc53"></a><span class="line-modified">1011                 errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;</span>
1012                 return;
1013             }
1014             Node* node = assertNode(errorString, nodeId);
1015             if (!node) {
1016                 // assertNode should have filled the errorString for us.
1017                 ASSERT(errorString.length());
1018                 return;
1019             }
1020             finder.performSearch(node);
1021         }
1022     } else {
1023         // There&#39;s no need to iterate the frames tree because
1024         // the search helper will go inside the frame owner elements.
1025         finder.performSearch(m_document.get());
1026     }
1027 
1028     *searchId = IdentifiersFactory::createIdentifier();
1029 
1030     auto&amp; resultsVector = m_searchResults.add(*searchId, Vector&lt;RefPtr&lt;Node&gt;&gt;()).iterator-&gt;value;
1031     for (auto&amp; result : finder.results())
1032         resultsVector.append(result);
1033 
1034     *resultCount = resultsVector.size();
1035 }
1036 
1037 void InspectorDOMAgent::getSearchResults(ErrorString&amp; errorString, const String&amp; searchId, int fromIndex, int toIndex, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; nodeIds)
1038 {
1039     SearchResults::iterator it = m_searchResults.find(searchId);
1040     if (it == m_searchResults.end()) {
<a name="54" id="anc54"></a><span class="line-modified">1041         errorString = &quot;Missing search result for given searchId&quot;_s;</span>
1042         return;
1043     }
1044 
1045     int size = it-&gt;value.size();
1046     if (fromIndex &lt; 0 || toIndex &gt; size || fromIndex &gt;= toIndex) {
<a name="55" id="anc55"></a><span class="line-modified">1047         errorString = &quot;Invalid search result range for given fromIndex and toIndex&quot;_s;</span>
1048         return;
1049     }
1050 
1051     nodeIds = JSON::ArrayOf&lt;int&gt;::create();
1052     for (int i = fromIndex; i &lt; toIndex; ++i)
1053         nodeIds-&gt;addItem(pushNodePathToFrontend((it-&gt;value)[i].get()));
1054 }
1055 
1056 void InspectorDOMAgent::discardSearchResults(ErrorString&amp;, const String&amp; searchId)
1057 {
1058     m_searchResults.remove(searchId);
1059 }
1060 
1061 bool InspectorDOMAgent::handleMousePress()
1062 {
1063     if (!m_searchingForNode)
1064         return false;
1065 
1066     if (Node* node = m_overlay-&gt;highlightedNode()) {
1067         inspect(node);
1068         return true;
1069     }
1070     return false;
1071 }
1072 
1073 bool InspectorDOMAgent::handleTouchEvent(Node&amp; node)
1074 {
1075     if (!m_searchingForNode)
1076         return false;
1077     if (m_inspectModeHighlightConfig) {
1078         m_overlay-&gt;highlightNode(&amp;node, *m_inspectModeHighlightConfig);
1079         inspect(&amp;node);
1080         return true;
1081     }
1082     return false;
1083 }
1084 
1085 void InspectorDOMAgent::inspect(Node* inspectedNode)
1086 {
<a name="56" id="anc56"></a><span class="line-modified">1087     ErrorString ignored;</span>
1088     RefPtr&lt;Node&gt; node = inspectedNode;
<a name="57" id="anc57"></a><span class="line-modified">1089     setSearchingForNode(ignored, false, nullptr, false);</span>
1090 
1091     if (node-&gt;nodeType() != Node::ELEMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_NODE)
1092         node = node-&gt;parentNode();
1093     m_nodeToFocus = node;
1094 
1095     if (!m_nodeToFocus)
1096         return;
1097 
1098     focusNode();
1099 }
1100 
1101 void InspectorDOMAgent::focusNode()
1102 {
<a name="58" id="anc58"></a><span class="line-modified">1103     if (!m_documentRequested)</span>
1104         return;
1105 
1106     ASSERT(m_nodeToFocus);
1107 
1108     RefPtr&lt;Node&gt; node = m_nodeToFocus.get();
1109     m_nodeToFocus = nullptr;
1110 
1111     Frame* frame = node-&gt;document().frame();
1112     if (!frame)
1113         return;
1114 
1115     JSC::ExecState* scriptState = mainWorldExecState(frame);
1116     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(scriptState);
1117     if (injectedScript.hasNoValue())
1118         return;
1119 
1120     injectedScript.inspectObject(nodeAsScriptValue(*scriptState, node.get()));
1121 }
1122 
1123 void InspectorDOMAgent::mouseDidMoveOverElement(const HitTestResult&amp; result, unsigned)
1124 {
1125     m_mousedOverNode = result.innerNode();
1126 
1127     if (!m_searchingForNode)
1128         return;
1129 
1130     highlightMousedOverNode();
1131 }
1132 
1133 void InspectorDOMAgent::highlightMousedOverNode()
1134 {
1135     Node* node = m_mousedOverNode.get();
1136     while (node &amp;&amp; node-&gt;nodeType() == Node::TEXT_NODE)
1137         node = node-&gt;parentNode();
1138     if (node &amp;&amp; m_inspectModeHighlightConfig)
1139         m_overlay-&gt;highlightNode(node, *m_inspectModeHighlightConfig);
1140 }
1141 
<a name="59" id="anc59"></a><span class="line-modified">1142 void InspectorDOMAgent::setSearchingForNode(ErrorString&amp; errorString, bool enabled, const JSON::Object* highlightInspectorObject, bool showRulers)</span>
1143 {
1144     if (m_searchingForNode == enabled)
1145         return;
1146 
1147     m_searchingForNode = enabled;
1148 
<a name="60" id="anc60"></a><span class="line-modified">1149     m_overlay-&gt;setShowRulersDuringElementSelection(m_searchingForNode &amp;&amp; showRulers);</span>
<span class="line-added">1150 </span>
<span class="line-added">1151     if (m_searchingForNode) {</span>
1152         m_inspectModeHighlightConfig = highlightConfigFromInspectorObject(errorString, highlightInspectorObject);
1153         if (!m_inspectModeHighlightConfig)
1154             return;
1155         highlightMousedOverNode();
1156     } else
1157         hideHighlight(errorString);
1158 
1159     m_overlay-&gt;didSetSearchingForNode(m_searchingForNode);
1160 
<a name="61" id="anc61"></a><span class="line-modified">1161     if (InspectorClient* client = m_inspectedPage.inspectorController().inspectorClient())</span>
1162         client-&gt;elementSelectionChanged(m_searchingForNode);
1163 }
1164 
1165 std::unique_ptr&lt;HighlightConfig&gt; InspectorDOMAgent::highlightConfigFromInspectorObject(ErrorString&amp; errorString, const JSON::Object* highlightInspectorObject)
1166 {
1167     if (!highlightInspectorObject) {
1168         errorString = &quot;Internal error: highlight configuration parameter is missing&quot;_s;
1169         return nullptr;
1170     }
1171 
<a name="62" id="anc62"></a><span class="line-modified">1172     auto highlightConfig = makeUnique&lt;HighlightConfig&gt;();</span>
1173     bool showInfo = false; // Default: false (do not show a tooltip).
1174     highlightInspectorObject-&gt;getBoolean(&quot;showInfo&quot;, showInfo);
1175     highlightConfig-&gt;showInfo = showInfo;
1176     highlightConfig-&gt;content = parseConfigColor(&quot;contentColor&quot;, highlightInspectorObject);
1177     highlightConfig-&gt;contentOutline = parseConfigColor(&quot;contentOutlineColor&quot;, highlightInspectorObject);
1178     highlightConfig-&gt;padding = parseConfigColor(&quot;paddingColor&quot;, highlightInspectorObject);
1179     highlightConfig-&gt;border = parseConfigColor(&quot;borderColor&quot;, highlightInspectorObject);
1180     highlightConfig-&gt;margin = parseConfigColor(&quot;marginColor&quot;, highlightInspectorObject);
1181     return highlightConfig;
1182 }
1183 
<a name="63" id="anc63"></a><span class="line-modified">1184 void InspectorDOMAgent::setInspectModeEnabled(ErrorString&amp; errorString, bool enabled, const JSON::Object* highlightConfig, const bool* showRulers)</span>
1185 {
<a name="64" id="anc64"></a><span class="line-modified">1186     setSearchingForNode(errorString, enabled, highlightConfig ? highlightConfig : nullptr, showRulers &amp;&amp; *showRulers);</span>
1187 }
1188 
1189 void InspectorDOMAgent::highlightRect(ErrorString&amp;, int x, int y, int width, int height, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1190 {
<a name="65" id="anc65"></a><span class="line-modified">1191     auto quad = makeUnique&lt;FloatQuad&gt;(FloatRect(x, y, width, height));</span>
1192     innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
1193 }
1194 
1195 void InspectorDOMAgent::highlightQuad(ErrorString&amp; errorString, const JSON::Array&amp; quadArray, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1196 {
<a name="66" id="anc66"></a><span class="line-modified">1197     auto quad = makeUnique&lt;FloatQuad&gt;();</span>
1198     if (!parseQuad(quadArray, quad.get())) {
<a name="67" id="anc67"></a><span class="line-modified">1199         errorString = &quot;Unexpected invalid quadArray&quot;_s;</span>
1200         return;
1201     }
1202     innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
1203 }
1204 
1205 void InspectorDOMAgent::innerHighlightQuad(std::unique_ptr&lt;FloatQuad&gt; quad, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1206 {
<a name="68" id="anc68"></a><span class="line-modified">1207     auto highlightConfig = makeUnique&lt;HighlightConfig&gt;();</span>
1208     highlightConfig-&gt;content = parseColor(color);
1209     highlightConfig-&gt;contentOutline = parseColor(outlineColor);
1210     highlightConfig-&gt;usePageCoordinates = usePageCoordinates ? *usePageCoordinates : false;
1211     m_overlay-&gt;highlightQuad(WTFMove(quad), *highlightConfig);
1212 }
1213 
1214 void InspectorDOMAgent::highlightSelector(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const String&amp; selectorString, const String* frameId)
1215 {
1216     RefPtr&lt;Document&gt; document;
1217 
1218     if (frameId) {
<a name="69" id="anc69"></a><span class="line-modified">1219         auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();</span>
<span class="line-modified">1220         if (!pageAgent) {</span>
<span class="line-modified">1221             errorString = &quot;Page domain must be enabled&quot;_s;</span>
1222             return;
1223         }
1224 
<a name="70" id="anc70"></a><span class="line-added">1225         auto* frame = pageAgent-&gt;assertFrame(errorString, *frameId);</span>
<span class="line-added">1226         if (!frame)</span>
<span class="line-added">1227             return;</span>
<span class="line-added">1228 </span>
1229         document = frame-&gt;document();
1230     } else
1231         document = m_document;
1232 
1233     if (!document) {
<a name="71" id="anc71"></a><span class="line-modified">1234         errorString = &quot;Missing document of frame for given frameId&quot;_s;</span>
1235         return;
1236     }
1237 
1238     auto queryResult = document-&gt;querySelectorAll(selectorString);
1239     // FIXME: &lt;https://webkit.org/b/146161&gt; Web Inspector: DOM.highlightSelector should work for &quot;a:visited&quot;
1240     if (queryResult.hasException()) {
<a name="72" id="anc72"></a><span class="line-modified">1241         errorString = &quot;DOM Error while querying with given selectorString&quot;_s;</span>
1242         return;
1243     }
1244 
1245     auto highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1246     if (!highlightConfig)
1247         return;
1248 
1249     m_overlay-&gt;highlightNodeList(queryResult.releaseReturnValue(), *highlightConfig);
1250 }
1251 
1252 void InspectorDOMAgent::highlightNode(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const int* nodeId, const String* objectId)
1253 {
1254     Node* node = nullptr;
1255     if (nodeId)
1256         node = assertNode(errorString, *nodeId);
1257     else if (objectId) {
1258         node = nodeForObjectId(*objectId);
1259         if (!node)
<a name="73" id="anc73"></a><span class="line-modified">1260             errorString = &quot;Missing node for given objectId&quot;_s;</span>
1261     } else
1262         errorString = &quot;Either nodeId or objectId must be specified&quot;_s;
1263 
1264     if (!node)
1265         return;
1266 
1267     std::unique_ptr&lt;HighlightConfig&gt; highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1268     if (!highlightConfig)
1269         return;
1270 
1271     m_overlay-&gt;highlightNode(node, *highlightConfig);
1272 }
1273 
1274 void InspectorDOMAgent::highlightNodeList(ErrorString&amp; errorString, const JSON::Array&amp; nodeIds, const JSON::Object&amp; highlightInspectorObject)
1275 {
1276     Vector&lt;Ref&lt;Node&gt;&gt; nodes;
1277     for (auto&amp; nodeValue : nodeIds) {
1278         if (!nodeValue) {
<a name="74" id="anc74"></a><span class="line-modified">1279             errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;</span>
1280             return;
1281         }
1282 
1283         int nodeId = 0;
1284         if (!nodeValue-&gt;asInteger(nodeId)) {
<a name="75" id="anc75"></a><span class="line-modified">1285             errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;</span>
1286             return;
1287         }
1288 
1289         // In the case that a node is removed in the time between when highlightNodeList is invoked
1290         // by the frontend and it is executed by the backend, we should still attempt to highlight
1291         // as many nodes as possible. As such, we should ignore any errors generated when attempting
1292         // to get a Node from a given nodeId.
1293         ErrorString ignored;
1294         Node* node = assertNode(ignored, nodeId);
1295         if (!node)
1296             continue;
1297 
1298         nodes.append(*node);
1299     }
1300 
1301     std::unique_ptr&lt;HighlightConfig&gt; highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1302     if (!highlightConfig)
1303         return;
1304 
1305     m_overlay-&gt;highlightNodeList(StaticNodeList::create(WTFMove(nodes)), *highlightConfig);
1306 }
1307 
1308 void InspectorDOMAgent::highlightFrame(ErrorString&amp; errorString, const String&amp; frameId, const JSON::Object* color, const JSON::Object* outlineColor)
1309 {
<a name="76" id="anc76"></a><span class="line-modified">1310     auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();</span>
<span class="line-added">1311     if (!pageAgent) {</span>
<span class="line-added">1312         errorString = &quot;Page domain must be enabled&quot;_s;</span>
<span class="line-added">1313         return;</span>
<span class="line-added">1314     }</span>
<span class="line-added">1315 </span>
<span class="line-added">1316     auto* frame = pageAgent-&gt;assertFrame(errorString, frameId);</span>
1317     if (!frame)
1318         return;
1319 
1320     if (frame-&gt;ownerElement()) {
<a name="77" id="anc77"></a><span class="line-modified">1321         auto highlightConfig = makeUnique&lt;HighlightConfig&gt;();</span>
1322         highlightConfig-&gt;showInfo = true; // Always show tooltips for frames.
1323         highlightConfig-&gt;content = parseColor(color);
1324         highlightConfig-&gt;contentOutline = parseColor(outlineColor);
1325         m_overlay-&gt;highlightNode(frame-&gt;ownerElement(), *highlightConfig);
1326     }
1327 }
1328 
1329 void InspectorDOMAgent::hideHighlight(ErrorString&amp;)
1330 {
1331     m_overlay-&gt;hideHighlight();
1332 }
1333 
1334 void InspectorDOMAgent::moveTo(ErrorString&amp; errorString, int nodeId, int targetElementId, const int* anchorNodeId, int* newNodeId)
1335 {
1336     Node* node = assertEditableNode(errorString, nodeId);
1337     if (!node)
1338         return;
1339 
1340     Element* targetElement = assertEditableElement(errorString, targetElementId);
1341     if (!targetElement)
1342         return;
1343 
1344     Node* anchorNode = 0;
1345     if (anchorNodeId &amp;&amp; *anchorNodeId) {
1346         anchorNode = assertEditableNode(errorString, *anchorNodeId);
1347         if (!anchorNode)
1348             return;
1349         if (anchorNode-&gt;parentNode() != targetElement) {
<a name="78" id="anc78"></a><span class="line-modified">1350             errorString = &quot;Given anchorNodeId must be a child of given targetElementId&quot;_s;</span>
1351             return;
1352         }
1353     }
1354 
1355     if (!m_domEditor-&gt;insertBefore(*targetElement, *node, anchorNode, errorString))
1356         return;
1357 
1358     *newNodeId = pushNodePathToFrontend(node);
1359 }
1360 
1361 void InspectorDOMAgent::undo(ErrorString&amp; errorString)
1362 {
1363     auto result = m_history-&gt;undo();
1364     if (result.hasException())
1365         errorString = toErrorString(result.releaseException());
1366 }
1367 
1368 void InspectorDOMAgent::redo(ErrorString&amp; errorString)
1369 {
1370     auto result = m_history-&gt;redo();
1371     if (result.hasException())
1372         errorString = toErrorString(result.releaseException());
1373 }
1374 
1375 void InspectorDOMAgent::markUndoableState(ErrorString&amp;)
1376 {
1377     m_history-&gt;markUndoableState();
1378 }
1379 
1380 void InspectorDOMAgent::focus(ErrorString&amp; errorString, int nodeId)
1381 {
1382     Element* element = assertElement(errorString, nodeId);
1383     if (!element)
1384         return;
1385     if (!element-&gt;isFocusable()) {
<a name="79" id="anc79"></a><span class="line-modified">1386         errorString = &quot;Element for given nodeId is not focusable&quot;_s;</span>
1387         return;
1388     }
1389     element-&gt;focus();
1390 }
1391 
1392 void InspectorDOMAgent::setInspectedNode(ErrorString&amp; errorString, int nodeId)
1393 {
<a name="80" id="anc80"></a><span class="line-modified">1394     Node* node = assertNode(errorString, nodeId);</span>
<span class="line-modified">1395     if (!node)</span>
<span class="line-modified">1396         return;</span>
<span class="line-added">1397 </span>
<span class="line-added">1398     if (node-&gt;isInUserAgentShadowTree()) {</span>
<span class="line-added">1399         errorString = &quot;Node for given nodeId is in a shadow tree&quot;_s;</span>
1400         return;
1401     }
1402 
<a name="81" id="anc81"></a><span class="line-modified">1403     m_inspectedNode = node;</span>
<span class="line-modified">1404 </span>
<span class="line-added">1405     if (auto&amp; commandLineAPIHost = static_cast&lt;WebInjectedScriptManager&amp;&gt;(m_injectedScriptManager).commandLineAPIHost())</span>
<span class="line-added">1406         commandLineAPIHost-&gt;addInspectedObject(makeUnique&lt;InspectableNode&gt;(node));</span>
<span class="line-added">1407 </span>
<span class="line-added">1408     m_suppressEventListenerChangedEvent = false;</span>
1409 }
1410 
1411 void InspectorDOMAgent::resolveNode(ErrorString&amp; errorString, int nodeId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
1412 {
1413     String objectGroupName = objectGroup ? *objectGroup : emptyString();
<a name="82" id="anc82"></a><span class="line-modified">1414     Node* node = assertNode(errorString, nodeId);</span>
<span class="line-modified">1415     if (!node)</span>

1416         return;
<a name="83" id="anc83"></a>
1417     RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; object = resolveNode(node, objectGroupName);
1418     if (!object) {
<a name="84" id="anc84"></a><span class="line-modified">1419         errorString = &quot;Missing injected script for given nodeId&quot;_s;</span>
1420         return;
1421     }
1422     result = object;
1423 }
1424 
1425 void InspectorDOMAgent::getAttributes(ErrorString&amp; errorString, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; result)
1426 {
1427     Element* element = assertElement(errorString, nodeId);
1428     if (!element)
1429         return;
1430 
1431     result = buildArrayForElementAttributes(element);
1432 }
1433 
1434 void InspectorDOMAgent::requestNode(ErrorString&amp;, const String&amp; objectId, int* nodeId)
1435 {
1436     Node* node = nodeForObjectId(objectId);
1437     if (node)
1438         *nodeId = pushNodePathToFrontend(node);
1439     else
1440         *nodeId = 0;
1441 }
1442 
1443 String InspectorDOMAgent::documentURLString(Document* document)
1444 {
1445     if (!document || document-&gt;url().isNull())
1446         return emptyString();
1447     return document-&gt;url().string();
1448 }
1449 
1450 static String documentBaseURLString(Document* document)
1451 {
1452     return document-&gt;completeURL(emptyString()).string();
1453 }
1454 
1455 static bool pseudoElementType(PseudoId pseudoId, Inspector::Protocol::DOM::PseudoType* type)
1456 {
1457     switch (pseudoId) {
1458     case PseudoId::Before:
1459         *type = Inspector::Protocol::DOM::PseudoType::Before;
1460         return true;
1461     case PseudoId::After:
1462         *type = Inspector::Protocol::DOM::PseudoType::After;
1463         return true;
1464     default:
1465         return false;
1466     }
1467 }
1468 
1469 static Inspector::Protocol::DOM::ShadowRootType shadowRootType(ShadowRootMode mode)
1470 {
1471     switch (mode) {
1472     case ShadowRootMode::UserAgent:
1473         return Inspector::Protocol::DOM::ShadowRootType::UserAgent;
1474     case ShadowRootMode::Closed:
1475         return Inspector::Protocol::DOM::ShadowRootType::Closed;
1476     case ShadowRootMode::Open:
1477         return Inspector::Protocol::DOM::ShadowRootType::Open;
1478     }
1479 
1480     ASSERT_NOT_REACHED();
1481     return Inspector::Protocol::DOM::ShadowRootType::UserAgent;
1482 }
1483 
1484 static Inspector::Protocol::DOM::CustomElementState customElementState(const Element&amp; element)
1485 {
1486     if (element.isDefinedCustomElement())
1487         return Inspector::Protocol::DOM::CustomElementState::Custom;
1488     if (element.isFailedCustomElement())
1489         return Inspector::Protocol::DOM::CustomElementState::Failed;
1490     if (element.isUndefinedCustomElement() || element.isCustomElementUpgradeCandidate())
1491         return Inspector::Protocol::DOM::CustomElementState::Waiting;
1492     return Inspector::Protocol::DOM::CustomElementState::Builtin;
1493 }
1494 
1495 static String computeContentSecurityPolicySHA256Hash(const Element&amp; element)
1496 {
1497     // FIXME: Compute the digest with respect to the raw bytes received from the page.
1498     // See &lt;https://bugs.webkit.org/show_bug.cgi?id=155184&gt;.
1499     TextEncoding documentEncoding = element.document().textEncoding();
1500     const TextEncoding&amp; encodingToUse = documentEncoding.isValid() ? documentEncoding : UTF8Encoding();
1501     auto content = encodingToUse.encode(TextNodeTraversal::contentsAsString(element), UnencodableHandling::Entities);
1502     auto cryptoDigest = PAL::CryptoDigest::create(PAL::CryptoDigest::Algorithm::SHA_256);
1503     cryptoDigest-&gt;addBytes(content.data(), content.size());
1504     auto digest = cryptoDigest-&gt;computeHash();
1505     return makeString(&quot;sha256-&quot;, base64Encode(digest.data(), digest.size()));
1506 }
1507 
1508 Ref&lt;Inspector::Protocol::DOM::Node&gt; InspectorDOMAgent::buildObjectForNode(Node* node, int depth, NodeToIdMap* nodesMap)
1509 {
1510     int id = bind(node, nodesMap);
1511     String nodeName;
1512     String localName;
1513     String nodeValue;
1514 
1515     switch (node-&gt;nodeType()) {
1516     case Node::PROCESSING_INSTRUCTION_NODE:
1517         nodeName = node-&gt;nodeName();
1518         localName = node-&gt;localName();
1519         FALLTHROUGH;
1520     case Node::TEXT_NODE:
1521     case Node::COMMENT_NODE:
1522     case Node::CDATA_SECTION_NODE:
1523         nodeValue = node-&gt;nodeValue();
1524         if (nodeValue.length() &gt; maxTextSize) {
1525             nodeValue = nodeValue.left(maxTextSize);
1526             nodeValue.append(ellipsisUChar);
1527         }
1528         break;
1529     case Node::ATTRIBUTE_NODE:
1530         localName = node-&gt;localName();
1531         break;
1532     case Node::DOCUMENT_FRAGMENT_NODE:
1533     case Node::DOCUMENT_NODE:
1534     case Node::ELEMENT_NODE:
1535     default:
1536         nodeName = node-&gt;nodeName();
1537         localName = node-&gt;localName();
1538         break;
1539     }
1540 
1541     auto value = Inspector::Protocol::DOM::Node::create()
1542         .setNodeId(id)
1543         .setNodeType(static_cast&lt;int&gt;(node-&gt;nodeType()))
1544         .setNodeName(nodeName)
1545         .setLocalName(localName)
1546         .setNodeValue(nodeValue)
1547         .release();
1548 
1549     if (node-&gt;isContainerNode()) {
1550         int nodeCount = innerChildNodeCount(node);
1551         value-&gt;setChildNodeCount(nodeCount);
1552         Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; children = buildArrayForContainerChildren(node, depth, nodesMap);
1553         if (children-&gt;length() &gt; 0)
1554             value-&gt;setChildren(WTFMove(children));
1555     }
1556 
<a name="85" id="anc85"></a><span class="line-added">1557     auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();</span>
<span class="line-added">1558     if (pageAgent) {</span>
<span class="line-added">1559         if (auto* frameView = node-&gt;document().view())</span>
<span class="line-added">1560             value-&gt;setFrameId(pageAgent-&gt;frameId(&amp;frameView-&gt;frame()));</span>
<span class="line-added">1561     }</span>
<span class="line-added">1562 </span>
1563     if (is&lt;Element&gt;(*node)) {
1564         Element&amp; element = downcast&lt;Element&gt;(*node);
1565         value-&gt;setAttributes(buildArrayForElementAttributes(&amp;element));
1566         if (is&lt;HTMLFrameOwnerElement&gt;(element)) {
<a name="86" id="anc86"></a><span class="line-modified">1567             if (auto* document = downcast&lt;HTMLFrameOwnerElement&gt;(element).contentDocument())</span>





1568                 value-&gt;setContentDocument(buildObjectForNode(document, 0, nodesMap));
1569         }
1570 
1571         if (ShadowRoot* root = element.shadowRoot()) {
1572             auto shadowRoots = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
1573             shadowRoots-&gt;addItem(buildObjectForNode(root, 0, nodesMap));
1574             value-&gt;setShadowRoots(WTFMove(shadowRoots));
1575         }
1576 
1577         if (is&lt;HTMLTemplateElement&gt;(element))
1578             value-&gt;setTemplateContent(buildObjectForNode(&amp;downcast&lt;HTMLTemplateElement&gt;(element).content(), 0, nodesMap));
1579 
1580         if (is&lt;HTMLStyleElement&gt;(element) || (is&lt;HTMLScriptElement&gt;(element) &amp;&amp; !element.hasAttributeWithoutSynchronization(HTMLNames::srcAttr)))
1581             value-&gt;setContentSecurityPolicyHash(computeContentSecurityPolicySHA256Hash(element));
1582 
1583         auto state = customElementState(element);
1584         if (state != Inspector::Protocol::DOM::CustomElementState::Builtin)
1585             value-&gt;setCustomElementState(state);
1586 
1587         if (element.pseudoId() != PseudoId::None) {
1588             Inspector::Protocol::DOM::PseudoType pseudoType;
1589             if (pseudoElementType(element.pseudoId(), &amp;pseudoType))
1590                 value-&gt;setPseudoType(pseudoType);
1591         } else {
1592             if (auto pseudoElements = buildArrayForPseudoElements(element, nodesMap))
1593                 value-&gt;setPseudoElements(WTFMove(pseudoElements));
1594         }
<a name="87" id="anc87"></a>
1595     } else if (is&lt;Document&gt;(*node)) {
1596         Document&amp; document = downcast&lt;Document&gt;(*node);
<a name="88" id="anc88"></a><span class="line-modified">1597         if (pageAgent)</span>
<span class="line-added">1598             value-&gt;setFrameId(pageAgent-&gt;frameId(document.frame()));</span>
1599         value-&gt;setDocumentURL(documentURLString(&amp;document));
1600         value-&gt;setBaseURL(documentBaseURLString(&amp;document));
1601         value-&gt;setXmlVersion(document.xmlVersion());
1602     } else if (is&lt;DocumentType&gt;(*node)) {
1603         DocumentType&amp; docType = downcast&lt;DocumentType&gt;(*node);
1604         value-&gt;setPublicId(docType.publicId());
1605         value-&gt;setSystemId(docType.systemId());
1606     } else if (is&lt;Attr&gt;(*node)) {
1607         Attr&amp; attribute = downcast&lt;Attr&gt;(*node);
1608         value-&gt;setName(attribute.name());
1609         value-&gt;setValue(attribute.value());
1610     } else if (is&lt;ShadowRoot&gt;(*node)) {
1611         ShadowRoot&amp; shadowRoot = downcast&lt;ShadowRoot&gt;(*node);
1612         value-&gt;setShadowRootType(shadowRootType(shadowRoot.mode()));
1613     }
1614 
1615     return value;
1616 }
1617 
1618 Ref&lt;JSON::ArrayOf&lt;String&gt;&gt; InspectorDOMAgent::buildArrayForElementAttributes(Element* element)
1619 {
1620     auto attributesValue = JSON::ArrayOf&lt;String&gt;::create();
1621     // Go through all attributes and serialize them.
1622     if (!element-&gt;hasAttributes())
1623         return attributesValue;
1624     for (const Attribute&amp; attribute : element-&gt;attributesIterator()) {
1625         // Add attribute pair
1626         attributesValue-&gt;addItem(attribute.name().toString());
1627         attributesValue-&gt;addItem(attribute.value());
1628     }
1629     return attributesValue;
1630 }
1631 
1632 Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; InspectorDOMAgent::buildArrayForContainerChildren(Node* container, int depth, NodeToIdMap* nodesMap)
1633 {
1634     auto children = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
1635     if (depth == 0) {
1636         // Special-case the only text child - pretend that container&#39;s children have been requested.
1637         Node* firstChild = container-&gt;firstChild();
1638         if (firstChild &amp;&amp; firstChild-&gt;nodeType() == Node::TEXT_NODE &amp;&amp; !firstChild-&gt;nextSibling()) {
1639             children-&gt;addItem(buildObjectForNode(firstChild, 0, nodesMap));
1640             m_childrenRequested.add(bind(container, nodesMap));
1641         }
1642         return children;
1643     }
1644 
1645     Node* child = innerFirstChild(container);
1646     depth--;
1647     m_childrenRequested.add(bind(container, nodesMap));
1648 
1649     while (child) {
1650         children-&gt;addItem(buildObjectForNode(child, depth, nodesMap));
1651         child = innerNextSibling(child);
1652     }
1653     return children;
1654 }
1655 
1656 RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; InspectorDOMAgent::buildArrayForPseudoElements(const Element&amp; element, NodeToIdMap* nodesMap)
1657 {
1658     PseudoElement* beforeElement = element.beforePseudoElement();
1659     PseudoElement* afterElement = element.afterPseudoElement();
1660     if (!beforeElement &amp;&amp; !afterElement)
1661         return nullptr;
1662 
1663     auto pseudoElements = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
1664     if (beforeElement)
1665         pseudoElements-&gt;addItem(buildObjectForNode(beforeElement, 0, nodesMap));
1666     if (afterElement)
1667         pseudoElements-&gt;addItem(buildObjectForNode(afterElement, 0, nodesMap));
<a name="89" id="anc89"></a><span class="line-modified">1668     return pseudoElements;</span>
1669 }
1670 
<a name="90" id="anc90"></a><span class="line-modified">1671 Ref&lt;Inspector::Protocol::DOM::EventListener&gt; InspectorDOMAgent::buildObjectForEventListener(const RegisteredEventListener&amp; registeredEventListener, int identifier, EventTarget&amp; eventTarget, const AtomString&amp; eventType, bool disabled, bool hasBreakpoint)</span>
1672 {
1673     Ref&lt;EventListener&gt; eventListener = registeredEventListener.callback();
1674 
<a name="91" id="anc91"></a>


1675     String handlerName;
1676     int lineNumber = 0;
1677     int columnNumber = 0;
1678     String scriptID;
1679     if (is&lt;JSEventListener&gt;(eventListener.get())) {
1680         auto&amp; scriptListener = downcast&lt;JSEventListener&gt;(eventListener.get());
1681 
<a name="92" id="anc92"></a><span class="line-added">1682         Document* document = nullptr;</span>
<span class="line-added">1683         if (auto* scriptExecutionContext = eventTarget.scriptExecutionContext()) {</span>
<span class="line-added">1684             if (is&lt;Document&gt;(scriptExecutionContext))</span>
<span class="line-added">1685                 document = downcast&lt;Document&gt;(scriptExecutionContext);</span>
<span class="line-added">1686         } else if (is&lt;Node&gt;(eventTarget))</span>
<span class="line-added">1687             document = &amp;downcast&lt;Node&gt;(eventTarget).document();</span>
<span class="line-added">1688 </span>
<span class="line-added">1689         JSC::JSObject* handlerObject = nullptr;</span>
<span class="line-added">1690         JSC::ExecState* exec = nullptr;</span>
<span class="line-added">1691 </span>
1692         JSC::JSLockHolder lock(scriptListener.isolatedWorld().vm());
1693 
<a name="93" id="anc93"></a><span class="line-modified">1694         if (document) {</span>
<span class="line-modified">1695             handlerObject = scriptListener.jsFunction(*document);</span>
<span class="line-added">1696             exec = execStateFromNode(scriptListener.isolatedWorld(), document);</span>
<span class="line-added">1697         }</span>
<span class="line-added">1698 </span>
1699         if (handlerObject &amp;&amp; exec) {
<a name="94" id="anc94"></a><span class="line-modified">1700             JSC::VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">1701             JSC::JSFunction* handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(vm, handlerObject);</span>
1702 
1703             if (!handlerFunction) {
<a name="95" id="anc95"></a><span class="line-modified">1704                 auto scope = DECLARE_CATCH_SCOPE(vm);</span>
1705 
1706                 // If the handler is not actually a function, see if it implements the EventListener interface and use that.
<a name="96" id="anc96"></a><span class="line-modified">1707                 auto handleEventValue = handlerObject-&gt;get(exec, JSC::Identifier::fromString(vm, &quot;handleEvent&quot;));</span>
1708 
1709                 if (UNLIKELY(scope.exception()))
1710                     scope.clearException();
1711 
1712                 if (handleEventValue)
<a name="97" id="anc97"></a><span class="line-modified">1713                     handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(vm, handleEventValue);</span>
1714             }
1715 
1716             if (handlerFunction &amp;&amp; !handlerFunction-&gt;isHostOrBuiltinFunction()) {
1717                 // If the listener implements the EventListener interface, use the class name instead of
1718                 // &quot;handleEvent&quot;, unless it is a plain object.
1719                 if (handlerFunction != handlerObject)
1720                     handlerName = JSC::JSObject::calculatedClassName(handlerObject);
1721                 if (handlerName.isEmpty() || handlerName == &quot;Object&quot;_s)
<a name="98" id="anc98"></a><span class="line-modified">1722                     handlerName = handlerFunction-&gt;calculatedDisplayName(vm);</span>
1723 
1724                 if (auto executable = handlerFunction-&gt;jsExecutable()) {
1725                     lineNumber = executable-&gt;firstLine() - 1;
1726                     columnNumber = executable-&gt;startColumn() - 1;
1727                     scriptID = executable-&gt;sourceID() == JSC::SourceProvider::nullID ? emptyString() : String::number(executable-&gt;sourceID());
1728                 }
1729             }
1730         }
1731     }
1732 
1733     auto value = Inspector::Protocol::DOM::EventListener::create()
1734         .setEventListenerId(identifier)
1735         .setType(eventType)
1736         .setUseCapture(registeredEventListener.useCapture())
1737         .setIsAttribute(eventListener-&gt;isAttribute())
<a name="99" id="anc99"></a>
1738         .release();
<a name="100" id="anc100"></a><span class="line-modified">1739     if (is&lt;Node&gt;(eventTarget))</span>
<span class="line-modified">1740         value-&gt;setNodeId(pushNodePathToFrontend(&amp;downcast&lt;Node&gt;(eventTarget)));</span>
<span class="line-modified">1741     else if (is&lt;DOMWindow&gt;(eventTarget))</span>
<span class="line-modified">1742         value-&gt;setOnWindow(true);</span>

1743     if (!scriptID.isNull()) {
1744         auto location = Inspector::Protocol::Debugger::Location::create()
1745             .setScriptId(scriptID)
1746             .setLineNumber(lineNumber)
1747             .release();
1748         location-&gt;setColumnNumber(columnNumber);
1749         value-&gt;setLocation(WTFMove(location));
1750     }
1751     if (!handlerName.isEmpty())
1752         value-&gt;setHandlerName(handlerName);
1753     if (registeredEventListener.isPassive())
1754         value-&gt;setPassive(true);
1755     if (registeredEventListener.isOnce())
1756         value-&gt;setOnce(true);
1757     if (disabled)
1758         value-&gt;setDisabled(disabled);
1759     if (hasBreakpoint)
1760         value-&gt;setHasBreakpoint(hasBreakpoint);
1761     return value;
1762 }
1763 
1764 void InspectorDOMAgent::processAccessibilityChildren(AccessibilityObject&amp; axObject, JSON::ArrayOf&lt;int&gt;&amp; childNodeIds)
1765 {
1766     const auto&amp; children = axObject.children();
1767     if (!children.size())
1768         return;
1769 
1770     for (const auto&amp; childObject : children) {
1771         if (Node* childNode = childObject-&gt;node())
1772             childNodeIds.addItem(pushNodePathToFrontend(childNode));
1773         else
1774             processAccessibilityChildren(*childObject, childNodeIds);
1775     }
1776 }
1777 
1778 RefPtr&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt; InspectorDOMAgent::buildObjectForAccessibilityProperties(Node* node)
1779 {
1780     ASSERT(node);
1781     if (!node)
1782         return nullptr;
1783 
1784     if (!WebCore::AXObjectCache::accessibilityEnabled())
1785         WebCore::AXObjectCache::enableAccessibility();
1786 
1787     Node* activeDescendantNode = nullptr;
1788     bool busy = false;
1789     auto checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::False;
1790     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; childNodeIds;
1791     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; controlledNodeIds;
1792     auto currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::False;
1793     bool exists = false;
1794     bool expanded = false;
1795     bool disabled = false;
1796     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; flowedNodeIds;
1797     bool focused = false;
1798     bool ignored = true;
1799     bool ignoredByDefault = false;
1800     auto invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::False;
1801     bool hidden = false;
1802     String label;
1803     bool liveRegionAtomic = false;
1804     RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt; liveRegionRelevant;
1805     auto liveRegionStatus = Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Off;
1806     Node* mouseEventNode = nullptr;
1807     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; ownedNodeIds;
1808     Node* parentNode = nullptr;
1809     bool pressed = false;
1810     bool readonly = false;
1811     bool required = false;
1812     String role;
1813     bool selected = false;
1814     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; selectedChildNodeIds;
1815     bool supportsChecked = false;
1816     bool supportsExpanded = false;
1817     bool supportsLiveRegion = false;
1818     bool supportsPressed = false;
1819     bool supportsRequired = false;
1820     bool supportsFocused = false;
1821     bool isPopupButton = false;
1822     int headingLevel = 0;
1823     unsigned hierarchicalLevel = 0;
1824     unsigned level = 0;
1825 
1826     if (AXObjectCache* axObjectCache = node-&gt;document().axObjectCache()) {
1827         if (AccessibilityObject* axObject = axObjectCache-&gt;getOrCreate(node)) {
1828 
1829             if (AccessibilityObject* activeDescendant = axObject-&gt;activeDescendant())
1830                 activeDescendantNode = activeDescendant-&gt;node();
1831 
1832             // An AX object is &quot;busy&quot; if it or any ancestor has aria-busy=&quot;true&quot; set.
1833             AccessibilityObject* current = axObject;
1834             while (!busy &amp;&amp; current) {
1835                 busy = current-&gt;isBusy();
1836                 current = current-&gt;parentObject();
1837             }
1838 
1839             supportsChecked = axObject-&gt;supportsChecked();
1840             if (supportsChecked) {
1841                 AccessibilityButtonState checkValue = axObject-&gt;checkboxOrRadioValue(); // Element using aria-checked.
1842                 if (checkValue == AccessibilityButtonState::On)
1843                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::True;
1844                 else if (checkValue == AccessibilityButtonState::Mixed)
1845                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::Mixed;
1846                 else if (axObject-&gt;isChecked()) // Native checkbox.
1847                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::True;
1848             }
1849 
1850             if (!axObject-&gt;children().isEmpty()) {
1851                 childNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1852                 processAccessibilityChildren(*axObject, *childNodeIds);
1853             }
1854 
1855             Vector&lt;Element*&gt; controlledElements;
1856             axObject-&gt;elementsFromAttribute(controlledElements, aria_controlsAttr);
1857             if (controlledElements.size()) {
1858                 controlledNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1859                 for (Element* controlledElement : controlledElements)
1860                     controlledNodeIds-&gt;addItem(pushNodePathToFrontend(controlledElement));
1861             }
1862 
1863             switch (axObject-&gt;currentState()) {
1864             case AccessibilityCurrentState::False:
1865                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::False;
1866                 break;
1867             case AccessibilityCurrentState::Page:
1868                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Page;
1869                 break;
1870             case AccessibilityCurrentState::Step:
1871                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Step;
1872                 break;
1873             case AccessibilityCurrentState::Location:
1874                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Location;
1875                 break;
1876             case AccessibilityCurrentState::Date:
1877                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Date;
1878                 break;
1879             case AccessibilityCurrentState::Time:
1880                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Time;
1881                 break;
1882             case AccessibilityCurrentState::True:
1883                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::True;
1884                 break;
1885             }
1886 
1887             disabled = !axObject-&gt;isEnabled();
1888             exists = true;
1889 
1890             supportsExpanded = axObject-&gt;supportsExpanded();
1891             if (supportsExpanded)
1892                 expanded = axObject-&gt;isExpanded();
1893 
1894             Vector&lt;Element*&gt; flowedElements;
1895             axObject-&gt;elementsFromAttribute(flowedElements, aria_flowtoAttr);
1896             if (flowedElements.size()) {
1897                 flowedNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1898                 for (Element* flowedElement : flowedElements)
1899                     flowedNodeIds-&gt;addItem(pushNodePathToFrontend(flowedElement));
1900             }
1901 
1902             if (is&lt;Element&gt;(*node)) {
1903                 supportsFocused = axObject-&gt;canSetFocusAttribute();
1904                 if (supportsFocused)
1905                     focused = axObject-&gt;isFocused();
1906             }
1907 
1908             ignored = axObject-&gt;accessibilityIsIgnored();
1909             ignoredByDefault = axObject-&gt;accessibilityIsIgnoredByDefault();
1910 
1911             String invalidValue = axObject-&gt;invalidStatus();
1912             if (invalidValue == &quot;false&quot;)
1913                 invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::False;
1914             else if (invalidValue == &quot;grammar&quot;)
1915                 invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::Grammar;
1916             else if (invalidValue == &quot;spelling&quot;)
1917                 invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::Spelling;
1918             else // Future versions of ARIA may allow additional truthy values. Ex. format, order, or size.
1919                 invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::True;
1920 
1921             if (axObject-&gt;isAXHidden() || axObject-&gt;isDOMHidden())
1922                 hidden = true;
1923 
1924             label = axObject-&gt;computedLabel();
1925 
1926             if (axObject-&gt;supportsLiveRegion()) {
1927                 supportsLiveRegion = true;
1928                 liveRegionAtomic = axObject-&gt;liveRegionAtomic();
1929 
1930                 String ariaRelevantAttrValue = axObject-&gt;liveRegionRelevant();
1931                 if (!ariaRelevantAttrValue.isEmpty()) {
1932                     // FIXME: Pass enum values rather than strings once unblocked. http://webkit.org/b/133711
1933                     String ariaRelevantAdditions = Inspector::Protocol::InspectorHelpers::getEnumConstantValue(Inspector::Protocol::DOM::LiveRegionRelevant::Additions);
1934                     String ariaRelevantRemovals = Inspector::Protocol::InspectorHelpers::getEnumConstantValue(Inspector::Protocol::DOM::LiveRegionRelevant::Removals);
1935                     String ariaRelevantText = Inspector::Protocol::InspectorHelpers::getEnumConstantValue(Inspector::Protocol::DOM::LiveRegionRelevant::Text);
1936                     liveRegionRelevant = JSON::ArrayOf&lt;String&gt;::create();
1937                     const SpaceSplitString&amp; values = SpaceSplitString(ariaRelevantAttrValue, true);
1938                     // @aria-relevant=&quot;all&quot; is exposed as [&quot;additions&quot;,&quot;removals&quot;,&quot;text&quot;], in order.
1939                     // This order is controlled in WebCore and expected in WebInspectorUI.
1940                     if (values.contains(&quot;all&quot;)) {
1941                         liveRegionRelevant-&gt;addItem(ariaRelevantAdditions);
1942                         liveRegionRelevant-&gt;addItem(ariaRelevantRemovals);
1943                         liveRegionRelevant-&gt;addItem(ariaRelevantText);
1944                     } else {
1945                         if (values.contains(ariaRelevantAdditions))
1946                             liveRegionRelevant-&gt;addItem(ariaRelevantAdditions);
1947                         if (values.contains(ariaRelevantRemovals))
1948                             liveRegionRelevant-&gt;addItem(ariaRelevantRemovals);
1949                         if (values.contains(ariaRelevantText))
1950                             liveRegionRelevant-&gt;addItem(ariaRelevantText);
1951                     }
1952                 }
1953 
1954                 String ariaLive = axObject-&gt;liveRegionStatus();
1955                 if (ariaLive == &quot;assertive&quot;)
1956                     liveRegionStatus = Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Assertive;
1957                 else if (ariaLive == &quot;polite&quot;)
1958                     liveRegionStatus = Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Polite;
1959             }
1960 
1961             if (is&lt;AccessibilityNodeObject&gt;(*axObject))
1962                 mouseEventNode = downcast&lt;AccessibilityNodeObject&gt;(*axObject).mouseButtonListener(MouseButtonListenerResultFilter::IncludeBodyElement);
1963 
1964             if (axObject-&gt;supportsARIAOwns()) {
1965                 Vector&lt;Element*&gt; ownedElements;
1966                 axObject-&gt;elementsFromAttribute(ownedElements, aria_ownsAttr);
1967                 if (ownedElements.size()) {
1968                     ownedNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1969                     for (Element* ownedElement : ownedElements)
1970                         ownedNodeIds-&gt;addItem(pushNodePathToFrontend(ownedElement));
1971                 }
1972             }
1973 
1974             if (AccessibilityObject* parentObject = axObject-&gt;parentObjectUnignored())
1975                 parentNode = parentObject-&gt;node();
1976 
1977             supportsPressed = axObject-&gt;pressedIsPresent();
1978             if (supportsPressed)
1979                 pressed = axObject-&gt;isPressed();
1980 
1981             if (axObject-&gt;isTextControl())
1982                 readonly = !axObject-&gt;canSetValueAttribute();
1983 
1984             supportsRequired = axObject-&gt;supportsRequiredAttribute();
1985             if (supportsRequired)
1986                 required = axObject-&gt;isRequired();
1987 
1988             role = axObject-&gt;computedRoleString();
1989             selected = axObject-&gt;isSelected();
1990 
1991             AccessibilityObject::AccessibilityChildrenVector selectedChildren;
1992             axObject-&gt;selectedChildren(selectedChildren);
1993             if (selectedChildren.size()) {
1994                 selectedChildNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1995                 for (auto&amp; selectedChildObject : selectedChildren) {
1996                     if (Node* selectedChildNode = selectedChildObject-&gt;node())
1997                         selectedChildNodeIds-&gt;addItem(pushNodePathToFrontend(selectedChildNode));
1998                 }
1999             }
2000 
2001             headingLevel = axObject-&gt;headingLevel();
2002             hierarchicalLevel = axObject-&gt;hierarchicalLevel();
2003 
2004             level = hierarchicalLevel ? hierarchicalLevel : headingLevel;
2005             isPopupButton = axObject-&gt;isPopUpButton() || axObject-&gt;hasPopup();
2006         }
2007     }
2008 
2009     Ref&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt; value = Inspector::Protocol::DOM::AccessibilityProperties::create()
2010         .setExists(exists)
2011         .setLabel(label)
2012         .setRole(role)
2013         .setNodeId(pushNodePathToFrontend(node))
2014         .release();
2015 
2016     if (exists) {
2017         if (activeDescendantNode)
2018             value-&gt;setActiveDescendantNodeId(pushNodePathToFrontend(activeDescendantNode));
2019         if (busy)
2020             value-&gt;setBusy(busy);
2021         if (supportsChecked)
2022             value-&gt;setChecked(checked);
2023         if (childNodeIds)
2024             value-&gt;setChildNodeIds(childNodeIds);
2025         if (controlledNodeIds)
2026             value-&gt;setControlledNodeIds(controlledNodeIds);
2027         if (currentState != Inspector::Protocol::DOM::AccessibilityProperties::Current::False)
2028             value-&gt;setCurrent(currentState);
2029         if (disabled)
2030             value-&gt;setDisabled(disabled);
2031         if (supportsExpanded)
2032             value-&gt;setExpanded(expanded);
2033         if (flowedNodeIds)
2034             value-&gt;setFlowedNodeIds(flowedNodeIds);
2035         if (supportsFocused)
2036             value-&gt;setFocused(focused);
2037         if (ignored)
2038             value-&gt;setIgnored(ignored);
2039         if (ignoredByDefault)
2040             value-&gt;setIgnoredByDefault(ignoredByDefault);
2041         if (invalid != Inspector::Protocol::DOM::AccessibilityProperties::Invalid::False)
2042             value-&gt;setInvalid(invalid);
2043         if (hidden)
2044             value-&gt;setHidden(hidden);
2045         if (supportsLiveRegion) {
2046             value-&gt;setLiveRegionAtomic(liveRegionAtomic);
2047             if (liveRegionRelevant-&gt;length())
2048                 value-&gt;setLiveRegionRelevant(liveRegionRelevant);
2049             value-&gt;setLiveRegionStatus(liveRegionStatus);
2050         }
2051         if (mouseEventNode)
2052             value-&gt;setMouseEventNodeId(pushNodePathToFrontend(mouseEventNode));
2053         if (ownedNodeIds)
2054             value-&gt;setOwnedNodeIds(ownedNodeIds);
2055         if (parentNode)
2056             value-&gt;setParentNodeId(pushNodePathToFrontend(parentNode));
2057         if (supportsPressed)
2058             value-&gt;setPressed(pressed);
2059         if (readonly)
2060             value-&gt;setReadonly(readonly);
2061         if (supportsRequired)
2062             value-&gt;setRequired(required);
2063         if (selected)
2064             value-&gt;setSelected(selected);
2065         if (selectedChildNodeIds)
2066             value-&gt;setSelectedChildNodeIds(selectedChildNodeIds);
2067 
2068         // H1 -- H6 always have a headingLevel property that can be complimented by a hierarchicalLevel
2069         // property when aria-level is set on the element, in which case we want to remain calling
2070         // this value the &quot;Heading Level&quot; in the inspector.
2071         // Also, we do not want it to say Hierarchy Level: 0
2072         if (headingLevel)
2073             value-&gt;setHeadingLevel(level);
2074         else if (level)
2075             value-&gt;setHierarchyLevel(level);
2076         if (isPopupButton)
2077             value-&gt;setIsPopUpButton(isPopupButton);
2078     }
2079 
<a name="101" id="anc101"></a><span class="line-modified">2080     return value;</span>
2081 }
2082 
2083 static bool containsOnlyHTMLWhitespace(Node* node)
2084 {
2085     // FIXME: Respect ignoreWhitespace setting from inspector front end?
2086     return is&lt;Text&gt;(node) &amp;&amp; downcast&lt;Text&gt;(*node).data().isAllSpecialCharacters&lt;isHTMLSpace&gt;();
2087 }
2088 
2089 Node* InspectorDOMAgent::innerFirstChild(Node* node)
2090 {
2091     node = node-&gt;firstChild();
2092     while (containsOnlyHTMLWhitespace(node))
2093         node = node-&gt;nextSibling();
2094     return node;
2095 }
2096 
2097 Node* InspectorDOMAgent::innerNextSibling(Node* node)
2098 {
2099     do {
2100         node = node-&gt;nextSibling();
2101     } while (containsOnlyHTMLWhitespace(node));
2102     return node;
2103 }
2104 
2105 Node* InspectorDOMAgent::innerPreviousSibling(Node* node)
2106 {
2107     do {
2108         node = node-&gt;previousSibling();
2109     } while (containsOnlyHTMLWhitespace(node));
2110     return node;
2111 }
2112 
2113 unsigned InspectorDOMAgent::innerChildNodeCount(Node* node)
2114 {
2115     unsigned count = 0;
2116     for (Node* child = innerFirstChild(node); child; child = innerNextSibling(child))
2117         ++count;
2118     return count;
2119 }
2120 
2121 Node* InspectorDOMAgent::innerParentNode(Node* node)
2122 {
2123     ASSERT(node);
2124     if (is&lt;Document&gt;(*node))
2125         return downcast&lt;Document&gt;(*node).ownerElement();
2126     if (is&lt;ShadowRoot&gt;(*node))
2127         return downcast&lt;ShadowRoot&gt;(*node).host();
2128     return node-&gt;parentNode();
2129 }
2130 
2131 void InspectorDOMAgent::didCommitLoad(Document* document)
2132 {
<a name="102" id="anc102"></a><span class="line-added">2133     if (m_nodeToFocus &amp;&amp; &amp;m_nodeToFocus-&gt;document() == document)</span>
<span class="line-added">2134         m_nodeToFocus = nullptr;</span>
<span class="line-added">2135 </span>
<span class="line-added">2136     if (m_mousedOverNode &amp;&amp; &amp;m_mousedOverNode-&gt;document() == document)</span>
<span class="line-added">2137         m_mousedOverNode = nullptr;</span>
<span class="line-added">2138 </span>
<span class="line-added">2139     if (m_inspectedNode &amp;&amp; &amp;m_inspectedNode-&gt;document() == document)</span>
<span class="line-added">2140         m_inspectedNode = nullptr;</span>
<span class="line-added">2141 </span>
2142     RefPtr&lt;Element&gt; frameOwner = document-&gt;ownerElement();
2143     if (!frameOwner)
2144         return;
2145 
2146     int frameOwnerId = m_documentNodeToIdMap.get(frameOwner);
2147     if (!frameOwnerId)
2148         return;
2149 
2150     // Re-add frame owner element together with its new children.
2151     int parentId = m_documentNodeToIdMap.get(innerParentNode(frameOwner.get()));
2152     m_frontendDispatcher-&gt;childNodeRemoved(parentId, frameOwnerId);
2153     unbind(frameOwner.get(), &amp;m_documentNodeToIdMap);
2154 
2155     Ref&lt;Inspector::Protocol::DOM::Node&gt; value = buildObjectForNode(frameOwner.get(), 0, &amp;m_documentNodeToIdMap);
2156     Node* previousSibling = innerPreviousSibling(frameOwner.get());
2157     int prevId = previousSibling ? m_documentNodeToIdMap.get(previousSibling) : 0;
2158     m_frontendDispatcher-&gt;childNodeInserted(parentId, prevId, WTFMove(value));
2159 }
2160 
2161 int InspectorDOMAgent::identifierForNode(Node&amp; node)
2162 {
2163     return pushNodePathToFrontend(&amp;node);
2164 }
2165 
2166 void InspectorDOMAgent::addEventListenersToNode(Node&amp; node)
2167 {
2168 #if ENABLE(VIDEO)
2169     auto callback = EventFiredCallback::create(*this);
2170 
<a name="103" id="anc103"></a><span class="line-modified">2171     auto createEventListener = [&amp;] (const AtomString&amp; eventName) {</span>
2172         node.addEventListener(eventName, callback.copyRef(), false);
2173     };
2174 
2175 #if ENABLE(FULLSCREEN_API)
2176     if (is&lt;Document&gt;(node) || is&lt;HTMLMediaElement&gt;(node))
2177         createEventListener(eventNames().webkitfullscreenchangeEvent);
2178 #endif // ENABLE(FULLSCREEN_API)
2179 
2180     if (is&lt;HTMLMediaElement&gt;(node)) {
2181         createEventListener(eventNames().abortEvent);
2182         createEventListener(eventNames().canplayEvent);
2183         createEventListener(eventNames().canplaythroughEvent);
2184         createEventListener(eventNames().emptiedEvent);
2185         createEventListener(eventNames().endedEvent);
2186         createEventListener(eventNames().loadeddataEvent);
2187         createEventListener(eventNames().loadedmetadataEvent);
2188         createEventListener(eventNames().loadstartEvent);
2189         createEventListener(eventNames().pauseEvent);
2190         createEventListener(eventNames().playEvent);
2191         createEventListener(eventNames().playingEvent);
2192         createEventListener(eventNames().seekedEvent);
2193         createEventListener(eventNames().seekingEvent);
2194         createEventListener(eventNames().stalledEvent);
2195         createEventListener(eventNames().suspendEvent);
2196         createEventListener(eventNames().waitingEvent);
2197 
2198         if (!m_mediaMetricsTimer.isActive())
2199             m_mediaMetricsTimer.start(0_s, 1_s / 15.);
2200     }
2201 #else
2202     UNUSED_PARAM(node);
2203 #endif // ENABLE(VIDEO)
2204 }
2205 
2206 void InspectorDOMAgent::didInsertDOMNode(Node&amp; node)
2207 {
2208     if (containsOnlyHTMLWhitespace(&amp;node))
2209         return;
2210 
2211     // We could be attaching existing subtree. Forget the bindings.
2212     unbind(&amp;node, &amp;m_documentNodeToIdMap);
2213 
2214     ContainerNode* parent = node.parentNode();
2215     if (!parent)
2216         return;
2217 
2218     int parentId = m_documentNodeToIdMap.get(parent);
2219     // Return if parent is not mapped yet.
2220     if (!parentId)
2221         return;
2222 
2223     if (!m_childrenRequested.contains(parentId)) {
2224         // No children are mapped yet -&gt; only notify on changes of hasChildren.
2225         m_frontendDispatcher-&gt;childNodeCountUpdated(parentId, innerChildNodeCount(parent));
2226     } else {
2227         // Children have been requested -&gt; return value of a new child.
2228         Node* prevSibling = innerPreviousSibling(&amp;node);
2229         int prevId = prevSibling ? m_documentNodeToIdMap.get(prevSibling) : 0;
2230         Ref&lt;Inspector::Protocol::DOM::Node&gt; value = buildObjectForNode(&amp;node, 0, &amp;m_documentNodeToIdMap);
2231         m_frontendDispatcher-&gt;childNodeInserted(parentId, prevId, WTFMove(value));
2232     }
2233 }
2234 
2235 void InspectorDOMAgent::didRemoveDOMNode(Node&amp; node)
2236 {
2237     if (containsOnlyHTMLWhitespace(&amp;node))
2238         return;
2239 
2240     ContainerNode* parent = node.parentNode();
2241 
2242     // If parent is not mapped yet -&gt; ignore the event.
2243     if (!m_documentNodeToIdMap.contains(parent))
2244         return;
2245 
2246     int parentId = m_documentNodeToIdMap.get(parent);
2247 
2248     if (!m_childrenRequested.contains(parentId)) {
2249         // No children are mapped yet -&gt; only notify on changes of hasChildren.
2250         if (innerChildNodeCount(parent) == 1)
2251             m_frontendDispatcher-&gt;childNodeCountUpdated(parentId, 0);
2252     } else
2253         m_frontendDispatcher-&gt;childNodeRemoved(parentId, m_documentNodeToIdMap.get(&amp;node));
2254     unbind(&amp;node, &amp;m_documentNodeToIdMap);
2255 }
2256 
<a name="104" id="anc104"></a><span class="line-modified">2257 void InspectorDOMAgent::willModifyDOMAttr(Element&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue)</span>
2258 {
2259     m_suppressAttributeModifiedEvent = (oldValue == newValue);
2260 }
2261 
<a name="105" id="anc105"></a><span class="line-modified">2262 void InspectorDOMAgent::didModifyDOMAttr(Element&amp; element, const AtomString&amp; name, const AtomString&amp; value)</span>
2263 {
2264     bool shouldSuppressEvent = m_suppressAttributeModifiedEvent;
2265     m_suppressAttributeModifiedEvent = false;
2266     if (shouldSuppressEvent)
2267         return;
2268 
2269     int id = boundNodeId(&amp;element);
<a name="106" id="anc106"></a>
2270     if (!id)
2271         return;
2272 
<a name="107" id="anc107"></a><span class="line-modified">2273     if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())</span>
<span class="line-modified">2274         cssAgent-&gt;didModifyDOMAttr(element);</span>
2275 
2276     m_frontendDispatcher-&gt;attributeModified(id, name, value);
2277 }
2278 
<a name="108" id="anc108"></a><span class="line-modified">2279 void InspectorDOMAgent::didRemoveDOMAttr(Element&amp; element, const AtomString&amp; name)</span>
2280 {
2281     int id = boundNodeId(&amp;element);
<a name="109" id="anc109"></a>
2282     if (!id)
2283         return;
2284 
<a name="110" id="anc110"></a><span class="line-modified">2285     if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())</span>
<span class="line-modified">2286         cssAgent-&gt;didModifyDOMAttr(element);</span>
2287 
2288     m_frontendDispatcher-&gt;attributeRemoved(id, name);
2289 }
2290 
2291 void InspectorDOMAgent::styleAttributeInvalidated(const Vector&lt;Element*&gt;&amp; elements)
2292 {
2293     auto nodeIds = JSON::ArrayOf&lt;int&gt;::create();
2294     for (auto&amp; element : elements) {
2295         int id = boundNodeId(element);
<a name="111" id="anc111"></a>
2296         if (!id)
2297             continue;
2298 
<a name="112" id="anc112"></a><span class="line-modified">2299         if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())</span>
<span class="line-modified">2300             cssAgent-&gt;didModifyDOMAttr(*element);</span>
<span class="line-added">2301 </span>
2302         nodeIds-&gt;addItem(id);
2303     }
2304     m_frontendDispatcher-&gt;inlineStyleInvalidated(WTFMove(nodeIds));
2305 }
2306 
2307 void InspectorDOMAgent::characterDataModified(CharacterData&amp; characterData)
2308 {
2309     int id = m_documentNodeToIdMap.get(&amp;characterData);
2310     if (!id) {
2311         // Push text node if it is being created.
2312         didInsertDOMNode(characterData);
2313         return;
2314     }
2315     m_frontendDispatcher-&gt;characterDataModified(id, characterData.data());
2316 }
2317 
<a name="113" id="anc113"></a><span class="line-modified">2318 void InspectorDOMAgent::didInvalidateStyleAttr(Element&amp; element)</span>
2319 {
<a name="114" id="anc114"></a><span class="line-modified">2320     int id = m_documentNodeToIdMap.get(&amp;element);</span>

2321     if (!id)
2322         return;
2323 
2324     if (!m_revalidateStyleAttrTask)
<a name="115" id="anc115"></a><span class="line-modified">2325         m_revalidateStyleAttrTask = makeUnique&lt;RevalidateStyleAttributeTask&gt;(this);</span>
<span class="line-modified">2326     m_revalidateStyleAttrTask-&gt;scheduleFor(&amp;element);</span>
2327 }
2328 
2329 void InspectorDOMAgent::didPushShadowRoot(Element&amp; host, ShadowRoot&amp; root)
2330 {
2331     int hostId = m_documentNodeToIdMap.get(&amp;host);
2332     if (hostId)
2333         m_frontendDispatcher-&gt;shadowRootPushed(hostId, buildObjectForNode(&amp;root, 0, &amp;m_documentNodeToIdMap));
2334 }
2335 
2336 void InspectorDOMAgent::willPopShadowRoot(Element&amp; host, ShadowRoot&amp; root)
2337 {
2338     int hostId = m_documentNodeToIdMap.get(&amp;host);
2339     int rootId = m_documentNodeToIdMap.get(&amp;root);
2340     if (hostId &amp;&amp; rootId)
2341         m_frontendDispatcher-&gt;shadowRootPopped(hostId, rootId);
2342 }
2343 
2344 void InspectorDOMAgent::didChangeCustomElementState(Element&amp; element)
2345 {
2346     int elementId = m_documentNodeToIdMap.get(&amp;element);
2347     if (!elementId)
2348         return;
2349 
2350     m_frontendDispatcher-&gt;customElementStateChanged(elementId, customElementState(element));
2351 }
2352 
2353 void InspectorDOMAgent::frameDocumentUpdated(Frame&amp; frame)
2354 {
2355     Document* document = frame.document();
2356     if (!document)
2357         return;
2358 
2359     if (!frame.isMainFrame())
2360         return;
2361 
2362     // Only update the main frame document, nested frame document updates are not required
2363     // (will be handled by didCommitLoad()).
2364     setDocument(document);
2365 }
2366 
2367 void InspectorDOMAgent::pseudoElementCreated(PseudoElement&amp; pseudoElement)
2368 {
2369     Element* parent = pseudoElement.hostElement();
2370     if (!parent)
2371         return;
2372 
2373     int parentId = m_documentNodeToIdMap.get(parent);
2374     if (!parentId)
2375         return;
2376 
2377     pushChildNodesToFrontend(parentId, 1);
2378     m_frontendDispatcher-&gt;pseudoElementAdded(parentId, buildObjectForNode(&amp;pseudoElement, 0, &amp;m_documentNodeToIdMap));
2379 }
2380 
2381 void InspectorDOMAgent::pseudoElementDestroyed(PseudoElement&amp; pseudoElement)
2382 {
2383     int pseudoElementId = m_documentNodeToIdMap.get(&amp;pseudoElement);
2384     if (!pseudoElementId)
2385         return;
2386 
2387     // If a PseudoElement is bound, its parent element must have been bound.
2388     Element* parent = pseudoElement.hostElement();
2389     ASSERT(parent);
2390     int parentId = m_documentNodeToIdMap.get(parent);
2391     ASSERT(parentId);
2392 
2393     unbind(&amp;pseudoElement, &amp;m_documentNodeToIdMap);
2394     m_frontendDispatcher-&gt;pseudoElementRemoved(parentId, pseudoElementId);
2395 }
2396 
2397 void InspectorDOMAgent::didAddEventListener(EventTarget&amp; target)
2398 {
2399     if (!is&lt;Node&gt;(target))
2400         return;
2401 
<a name="116" id="anc116"></a><span class="line-modified">2402     auto&amp; node = downcast&lt;Node&gt;(target);</span>
<span class="line-added">2403     if (!node.contains(m_inspectedNode.get()))</span>
<span class="line-added">2404         return;</span>
<span class="line-added">2405 </span>
<span class="line-added">2406     int nodeId = boundNodeId(&amp;node);</span>
2407     if (!nodeId)
2408         return;
2409 
<a name="117" id="anc117"></a><span class="line-added">2410     if (m_suppressEventListenerChangedEvent)</span>
<span class="line-added">2411         return;</span>
<span class="line-added">2412 </span>
<span class="line-added">2413     m_suppressEventListenerChangedEvent = true;</span>
<span class="line-added">2414 </span>
2415     m_frontendDispatcher-&gt;didAddEventListener(nodeId);
2416 }
2417 
<a name="118" id="anc118"></a><span class="line-modified">2418 void InspectorDOMAgent::willRemoveEventListener(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)</span>
2419 {
2420     if (!is&lt;Node&gt;(target))
2421         return;
<a name="119" id="anc119"></a><span class="line-added">2422 </span>
2423     auto&amp; node = downcast&lt;Node&gt;(target);
<a name="120" id="anc120"></a><span class="line-added">2424     if (!node.contains(m_inspectedNode.get()))</span>
<span class="line-added">2425         return;</span>
2426 
2427     int nodeId = boundNodeId(&amp;node);
2428     if (!nodeId)
2429         return;
2430 
2431     bool listenerExists = false;
2432     for (auto&amp; item : node.eventListeners(eventType)) {
2433         if (item-&gt;callback() == listener &amp;&amp; item-&gt;useCapture() == capture) {
2434             listenerExists = true;
2435             break;
2436         }
2437     }
2438 
2439     if (!listenerExists)
2440         return;
2441 
2442     m_eventListenerEntries.removeIf([&amp;] (auto&amp; entry) {
2443         return entry.value.matches(target, eventType, listener, capture);
2444     });
2445 
<a name="121" id="anc121"></a><span class="line-added">2446     if (m_suppressEventListenerChangedEvent)</span>
<span class="line-added">2447         return;</span>
<span class="line-added">2448 </span>
<span class="line-added">2449     m_suppressEventListenerChangedEvent = true;</span>
<span class="line-added">2450 </span>
2451     m_frontendDispatcher-&gt;willRemoveEventListener(nodeId);
2452 }
2453 
<a name="122" id="anc122"></a><span class="line-modified">2454 bool InspectorDOMAgent::isEventListenerDisabled(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)</span>
2455 {
2456     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2457         if (inspectorEventListener.matches(target, eventType, listener, capture))
2458             return inspectorEventListener.disabled;
2459     }
2460     return false;
2461 }
2462 
2463 void InspectorDOMAgent::eventDidResetAfterDispatch(const Event&amp; event)
2464 {
2465     m_dispatchedEvents.remove(&amp;event);
2466 }
2467 
<a name="123" id="anc123"></a><span class="line-modified">2468 bool InspectorDOMAgent::hasBreakpointForEventListener(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)</span>
2469 {
2470     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2471         if (inspectorEventListener.matches(target, eventType, listener, capture))
2472             return inspectorEventListener.hasBreakpoint;
2473     }
2474     return false;
2475 }
2476 
<a name="124" id="anc124"></a><span class="line-modified">2477 int InspectorDOMAgent::idForEventListener(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)</span>
2478 {
2479     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2480         if (inspectorEventListener.matches(target, eventType, listener, capture))
2481             return inspectorEventListener.identifier;
2482     }
2483     return 0;
2484 }
2485 
2486 #if ENABLE(VIDEO)
2487 void InspectorDOMAgent::mediaMetricsTimerFired()
2488 {
2489     // FIXME: remove metrics information for any media element when it&#39;s destroyed
2490 
2491     if (HTMLMediaElement::allMediaElements().isEmpty()) {
2492         if (m_mediaMetricsTimer.isActive())
2493             m_mediaMetricsTimer.stop();
2494         m_mediaMetrics.clear();
2495         return;
2496     }
2497 
2498     for (auto* mediaElement : HTMLMediaElement::allMediaElements()) {
2499         if (!is&lt;HTMLVideoElement&gt;(mediaElement) || !mediaElement-&gt;isPlaying())
2500             continue;
2501 
2502         auto videoPlaybackQuality = mediaElement-&gt;getVideoPlaybackQuality();
2503         unsigned displayCompositedVideoFrames = videoPlaybackQuality-&gt;displayCompositedVideoFrames();
2504 
2505         auto iterator = m_mediaMetrics.find(mediaElement);
2506         if (iterator == m_mediaMetrics.end()) {
2507             m_mediaMetrics.set(mediaElement, MediaMetrics(displayCompositedVideoFrames));
2508             continue;
2509         }
2510 
<a name="125" id="anc125"></a><span class="line-modified">2511         bool isPowerEfficient = (displayCompositedVideoFrames - iterator-&gt;value.displayCompositedFrames) &gt; 0;</span>
<span class="line-modified">2512         if (iterator-&gt;value.isPowerEfficient != isPowerEfficient) {</span>
<span class="line-modified">2513             iterator-&gt;value.isPowerEfficient = isPowerEfficient;</span>
2514 
2515             int nodeId = pushNodePathToFrontend(mediaElement);
2516             if (nodeId) {
2517                 auto timestamp = m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
<a name="126" id="anc126"></a><span class="line-modified">2518                 m_frontendDispatcher-&gt;powerEfficientPlaybackStateChanged(nodeId, timestamp, iterator-&gt;value.isPowerEfficient);</span>
2519             }
2520         }
2521 
2522         iterator-&gt;value.displayCompositedFrames = displayCompositedVideoFrames;
2523     }
2524 
2525     m_mediaMetrics.removeIf([&amp;] (auto&amp; entry) {
2526         return !HTMLMediaElement::allMediaElements().contains(entry.key);
2527     });
2528 }
2529 #endif
2530 
2531 Node* InspectorDOMAgent::nodeForPath(const String&amp; path)
2532 {
2533     // The path is of form &quot;1,HTML,2,BODY,1,DIV&quot;
2534     if (!m_document)
2535         return nullptr;
2536 
2537     Node* node = m_document.get();
2538     Vector&lt;String&gt; pathTokens = path.split(&#39;,&#39;);
2539     if (!pathTokens.size())
2540         return nullptr;
2541 
2542     for (size_t i = 0; i &lt; pathTokens.size() - 1; i += 2) {
2543         bool success = true;
2544         unsigned childNumber = pathTokens[i].toUInt(&amp;success);
2545         if (!success)
2546             return nullptr;
2547 
2548         Node* child;
2549         if (is&lt;HTMLFrameOwnerElement&gt;(*node)) {
2550             ASSERT(!childNumber);
2551             auto&amp; frameOwner = downcast&lt;HTMLFrameOwnerElement&gt;(*node);
2552             child = frameOwner.contentDocument();
2553         } else {
2554             if (childNumber &gt;= innerChildNodeCount(node))
2555                 return nullptr;
2556 
2557             child = innerFirstChild(node);
2558             for (size_t j = 0; child &amp;&amp; j &lt; childNumber; ++j)
2559                 child = innerNextSibling(child);
2560         }
2561 
2562         const auto&amp; childName = pathTokens[i + 1];
2563         if (!child || child-&gt;nodeName() != childName)
2564             return nullptr;
2565         node = child;
2566     }
2567     return node;
2568 }
2569 
2570 Node* InspectorDOMAgent::nodeForObjectId(const String&amp; objectId)
2571 {
2572     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
2573     if (injectedScript.hasNoValue())
2574         return nullptr;
2575 
2576     return scriptValueAsNode(injectedScript.findObjectById(objectId));
2577 }
2578 
2579 void InspectorDOMAgent::pushNodeByPathToFrontend(ErrorString&amp; errorString, const String&amp; path, int* nodeId)
2580 {
2581     if (Node* node = nodeForPath(path))
2582         *nodeId = pushNodePathToFrontend(node);
2583     else
<a name="127" id="anc127"></a><span class="line-modified">2584         errorString = &quot;Missing node for given path&quot;_s;</span>
2585 }
2586 
2587 RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; InspectorDOMAgent::resolveNode(Node* node, const String&amp; objectGroup)
2588 {
<a name="128" id="anc128"></a><span class="line-modified">2589     Document* document = &amp;node-&gt;document();</span>
<span class="line-added">2590     if (auto* templateHost = document-&gt;templateDocumentHost())</span>
<span class="line-added">2591         document = templateHost;</span>
<span class="line-added">2592     auto* frame =  document-&gt;frame();</span>
2593     if (!frame)
2594         return nullptr;
2595 
2596     auto&amp; state = *mainWorldExecState(frame);
2597     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
2598     if (injectedScript.hasNoValue())
2599         return nullptr;
2600 
2601     return injectedScript.wrapObject(nodeAsScriptValue(state, node), objectGroup);
2602 }
2603 
2604 Node* InspectorDOMAgent::scriptValueAsNode(JSC::JSValue value)
2605 {
2606     if (!value || !value.isObject())
2607         return nullptr;
<a name="129" id="anc129"></a><span class="line-modified">2608     return JSNode::toWrapped(value.getObject()-&gt;vm(), value.getObject());</span>
2609 }
2610 
2611 JSC::JSValue InspectorDOMAgent::nodeAsScriptValue(JSC::ExecState&amp; state, Node* node)
2612 {
2613     JSC::JSLockHolder lock(&amp;state);
2614     return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), BindingSecurity::checkSecurityForNode(state, node));
2615 }
2616 
2617 } // namespace WebCore
<a name="130" id="anc130"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="130" type="hidden" />
</body>
</html>