<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/cssjit/SelectorCompiler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../css/typedom/TypedOMCSSUnparsedValue.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackAllocator.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/cssjit/SelectorCompiler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 195,13 ***</span>
      FunctionType appendUnoptimizedPseudoClassWithContext(bool (*matcher)(const SelectorChecker::CheckingContext&amp;));
  
      // FIXME: the large stack allocation caused by the inline capacity causes memory inefficiency. We should dump
      // the min/max/average of the vectors and pick better inline capacity.
      const CSSSelector* tagNameSelector = nullptr;
<span class="line-modified">!     const AtomicString* id = nullptr;</span>
<span class="line-modified">!     Vector&lt;const Vector&lt;AtomicString&gt;*&gt; languageArgumentsList;</span>
<span class="line-modified">!     Vector&lt;const AtomicStringImpl*, 8&gt; classNames;</span>
      HashSet&lt;unsigned&gt; pseudoClasses;
      Vector&lt;JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;, 4&gt; unoptimizedPseudoClasses;
      Vector&lt;JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;, 4&gt; unoptimizedPseudoClassesWithContext;
      Vector&lt;AttributeMatchingInfo, 4&gt; attributes;
      Vector&lt;std::pair&lt;int, int&gt;, 2&gt; nthChildFilters;
<span class="line-new-header">--- 195,13 ---</span>
      FunctionType appendUnoptimizedPseudoClassWithContext(bool (*matcher)(const SelectorChecker::CheckingContext&amp;));
  
      // FIXME: the large stack allocation caused by the inline capacity causes memory inefficiency. We should dump
      // the min/max/average of the vectors and pick better inline capacity.
      const CSSSelector* tagNameSelector = nullptr;
<span class="line-modified">!     const AtomString* id = nullptr;</span>
<span class="line-modified">!     Vector&lt;const Vector&lt;AtomString&gt;*&gt; languageArgumentsList;</span>
<span class="line-modified">!     Vector&lt;const AtomStringImpl*, 8&gt; classNames;</span>
      HashSet&lt;unsigned&gt; pseudoClasses;
      Vector&lt;JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;, 4&gt; unoptimizedPseudoClasses;
      Vector&lt;JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;, 4&gt; unoptimizedPseudoClassesWithContext;
      Vector&lt;AttributeMatchingInfo, 4&gt; attributes;
      Vector&lt;std::pair&lt;int, int&gt;, 2&gt; nthChildFilters;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 298,24 ***</span>
      void generateElementIsActive(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
      void generateElementIsEmpty(Assembler::JumpList&amp; failureCases);
      void generateElementIsFirstChild(Assembler::JumpList&amp; failureCases);
      void generateElementIsHovered(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
      void generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
<span class="line-modified">!     void generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const Vector&lt;AtomicString&gt;*);</span>
      void generateElementIsLastChild(Assembler::JumpList&amp; failureCases);
      void generateElementIsOnlyChild(Assembler::JumpList&amp; failureCases);
      void generateElementHasPlaceholderShown(Assembler::JumpList&amp; failureCases);
      void generateSynchronizeStyleAttribute(Assembler::RegisterID elementDataArraySizeAndFlags);
      void generateSynchronizeAllAnimatedSVGAttribute(Assembler::RegisterID elementDataArraySizeAndFlags);
      void generateElementAttributesMatching(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const SelectorFragment&amp;);
      void generateElementAttributeMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, Assembler::RegisterID decIndexRegister, const AttributeMatchingInfo&amp; attributeInfo);
      void generateElementAttributeValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AttributeMatchingInfo&amp; attributeInfo);
<span class="line-modified">!     void generateElementAttributeValueExactMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomicString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity);</span>
<span class="line-modified">!     void generateElementAttributeFunctionCallValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomicString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseSensitiveTest, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseInsensitiveTest);</span>
      void generateElementHasTagName(Assembler::JumpList&amp; failureCases, const CSSSelector&amp; tagMatchingSelector);
<span class="line-modified">!     void generateElementHasId(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const AtomicString&amp; idToMatch);</span>
<span class="line-modified">!     void generateElementHasClasses(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const Vector&lt;const AtomicStringImpl*, 8&gt;&amp; classNames);</span>
      void generateElementIsLink(Assembler::JumpList&amp; failureCases);
      void generateElementIsNthChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
      void generateElementIsNthChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
      void generateElementIsNthLastChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
      void generateElementIsNthLastChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
<span class="line-new-header">--- 298,24 ---</span>
      void generateElementIsActive(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
      void generateElementIsEmpty(Assembler::JumpList&amp; failureCases);
      void generateElementIsFirstChild(Assembler::JumpList&amp; failureCases);
      void generateElementIsHovered(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
      void generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
<span class="line-modified">!     void generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const Vector&lt;AtomString&gt;*);</span>
      void generateElementIsLastChild(Assembler::JumpList&amp; failureCases);
      void generateElementIsOnlyChild(Assembler::JumpList&amp; failureCases);
      void generateElementHasPlaceholderShown(Assembler::JumpList&amp; failureCases);
      void generateSynchronizeStyleAttribute(Assembler::RegisterID elementDataArraySizeAndFlags);
      void generateSynchronizeAllAnimatedSVGAttribute(Assembler::RegisterID elementDataArraySizeAndFlags);
      void generateElementAttributesMatching(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const SelectorFragment&amp;);
      void generateElementAttributeMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, Assembler::RegisterID decIndexRegister, const AttributeMatchingInfo&amp; attributeInfo);
      void generateElementAttributeValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AttributeMatchingInfo&amp; attributeInfo);
<span class="line-modified">!     void generateElementAttributeValueExactMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity);</span>
<span class="line-modified">!     void generateElementAttributeFunctionCallValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseSensitiveTest, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseInsensitiveTest);</span>
      void generateElementHasTagName(Assembler::JumpList&amp; failureCases, const CSSSelector&amp; tagMatchingSelector);
<span class="line-modified">!     void generateElementHasId(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const AtomString&amp; idToMatch);</span>
<span class="line-modified">!     void generateElementHasClasses(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const Vector&lt;const AtomStringImpl*, 8&gt;&amp; classNames);</span>
      void generateElementIsLink(Assembler::JumpList&amp; failureCases);
      void generateElementIsNthChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
      void generateElementIsNthChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
      void generateElementIsNthLastChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
      void generateElementIsNthLastChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 538,10 ***</span>
<span class="line-new-header">--- 538,13 ---</span>
          fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilled));
          return FunctionType::SimpleSelectorChecker;
      case CSSSelector::PseudoClassAutofillStrongPassword:
          fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilledStrongPassword));
          return FunctionType::SimpleSelectorChecker;
<span class="line-added">+     case CSSSelector::PseudoClassAutofillStrongPasswordViewable:</span>
<span class="line-added">+         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilledStrongPasswordViewable));</span>
<span class="line-added">+         return FunctionType::SimpleSelectorChecker;</span>
      case CSSSelector::PseudoClassChecked:
          fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isChecked));
          return FunctionType::SimpleSelectorChecker;
      case CSSSelector::PseudoClassDefault:
          fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesDefaultPseudoClass));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 779,11 ***</span>
              return functionType;
          }
  
      case CSSSelector::PseudoClassLang:
          {
<span class="line-modified">!             const Vector&lt;AtomicString&gt;* selectorLangArgumentList = selector.langArgumentList();</span>
              ASSERT(selectorLangArgumentList &amp;&amp; !selectorLangArgumentList-&gt;isEmpty());
              fragment.languageArgumentsList.append(selectorLangArgumentList);
              return FunctionType::SimpleSelectorChecker;
          }
  
<span class="line-new-header">--- 782,11 ---</span>
              return functionType;
          }
  
      case CSSSelector::PseudoClassLang:
          {
<span class="line-modified">!             const Vector&lt;AtomString&gt;* selectorLangArgumentList = selector.langArgumentList();</span>
              ASSERT(selectorLangArgumentList &amp;&amp; !selectorLangArgumentList-&gt;isEmpty());
              fragment.languageArgumentsList.append(selectorLangArgumentList);
              return FunctionType::SimpleSelectorChecker;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 915,11 ***</span>
              fragment-&gt;tagNameSelector = selector;
              if (fragment-&gt;tagNameSelector-&gt;tagQName() != anyQName())
                  fragment-&gt;onlyMatchesLinksInQuirksMode = false;
              break;
          case CSSSelector::Id: {
<span class="line-modified">!             const AtomicString&amp; id = selector-&gt;value();</span>
              if (fragment-&gt;id) {
                  if (id != *fragment-&gt;id)
                      return FunctionType::CannotMatchAnything;
              } else
                  fragment-&gt;id = &amp;(selector-&gt;value());
<span class="line-new-header">--- 918,11 ---</span>
              fragment-&gt;tagNameSelector = selector;
              if (fragment-&gt;tagNameSelector-&gt;tagQName() != anyQName())
                  fragment-&gt;onlyMatchesLinksInQuirksMode = false;
              break;
          case CSSSelector::Id: {
<span class="line-modified">!             const AtomString&amp; id = selector-&gt;value();</span>
              if (fragment-&gt;id) {
                  if (id != *fragment-&gt;id)
                      return FunctionType::CannotMatchAnything;
              } else
                  fragment-&gt;id = &amp;(selector-&gt;value());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1402,26 ***</span>
  
      const QualifiedName&amp; rhsQualifiedName = rhs-&gt;tagQName();
      if (rhsQualifiedName == anyQName())
          return TagNameEquality::MaybeEqual;
  
<span class="line-modified">!     const AtomicString&amp; lhsLocalName = lhsQualifiedName.localName();</span>
<span class="line-modified">!     const AtomicString&amp; rhsLocalName = rhsQualifiedName.localName();</span>
      if (lhsLocalName != starAtom() &amp;&amp; rhsLocalName != starAtom()) {
<span class="line-modified">!         const AtomicString&amp; lhsLowercaseLocalName = lhs-&gt;tagLowercaseLocalName();</span>
<span class="line-modified">!         const AtomicString&amp; rhsLowercaseLocalName = rhs-&gt;tagLowercaseLocalName();</span>
  
          if (lhsLowercaseLocalName != rhsLowercaseLocalName)
              return TagNameEquality::StrictlyNotEqual;
  
          if (lhsLocalName == lhsLowercaseLocalName &amp;&amp; rhsLocalName == rhsLowercaseLocalName)
              return TagNameEquality::StrictlyEqual;
          return TagNameEquality::MaybeEqual;
      }
  
<span class="line-modified">!     const AtomicString&amp; lhsNamespaceURI = lhsQualifiedName.namespaceURI();</span>
<span class="line-modified">!     const AtomicString&amp; rhsNamespaceURI = rhsQualifiedName.namespaceURI();</span>
      if (lhsNamespaceURI != starAtom() &amp;&amp; rhsNamespaceURI != starAtom()) {
          if (lhsNamespaceURI != rhsNamespaceURI)
              return TagNameEquality::StrictlyNotEqual;
          return TagNameEquality::StrictlyEqual;
      }
<span class="line-new-header">--- 1405,26 ---</span>
  
      const QualifiedName&amp; rhsQualifiedName = rhs-&gt;tagQName();
      if (rhsQualifiedName == anyQName())
          return TagNameEquality::MaybeEqual;
  
<span class="line-modified">!     const AtomString&amp; lhsLocalName = lhsQualifiedName.localName();</span>
<span class="line-modified">!     const AtomString&amp; rhsLocalName = rhsQualifiedName.localName();</span>
      if (lhsLocalName != starAtom() &amp;&amp; rhsLocalName != starAtom()) {
<span class="line-modified">!         const AtomString&amp; lhsLowercaseLocalName = lhs-&gt;tagLowercaseLocalName();</span>
<span class="line-modified">!         const AtomString&amp; rhsLowercaseLocalName = rhs-&gt;tagLowercaseLocalName();</span>
  
          if (lhsLowercaseLocalName != rhsLowercaseLocalName)
              return TagNameEquality::StrictlyNotEqual;
  
          if (lhsLocalName == lhsLowercaseLocalName &amp;&amp; rhsLocalName == rhsLowercaseLocalName)
              return TagNameEquality::StrictlyEqual;
          return TagNameEquality::MaybeEqual;
      }
  
<span class="line-modified">!     const AtomString&amp; lhsNamespaceURI = lhsQualifiedName.namespaceURI();</span>
<span class="line-modified">!     const AtomString&amp; rhsNamespaceURI = rhsQualifiedName.namespaceURI();</span>
      if (lhsNamespaceURI != starAtom() &amp;&amp; rhsNamespaceURI != starAtom()) {
          if (lhsNamespaceURI != rhsNamespaceURI)
              return TagNameEquality::StrictlyNotEqual;
          return TagNameEquality::StrictlyEqual;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2695,11 ***</span>
          const CSSSelector&amp; attributeSelector = fragment.attributes[i].selector();
          const QualifiedName&amp; attributeName = attributeSelector.attribute();
          if (Attribute::nameMatchesFilter(HTMLNames::styleAttr, attributeName.prefix(), attributeName.localName(), attributeName.namespaceURI()))
              return true;
  
<span class="line-modified">!         const AtomicString&amp; canonicalLocalName = attributeSelector.attributeCanonicalLocalName();</span>
          if (attributeName.localName() != canonicalLocalName
              &amp;&amp; Attribute::nameMatchesFilter(HTMLNames::styleAttr, attributeName.prefix(), attributeSelector.attributeCanonicalLocalName(), attributeName.namespaceURI())) {
              return true;
          }
      }
<span class="line-new-header">--- 2698,11 ---</span>
          const CSSSelector&amp; attributeSelector = fragment.attributes[i].selector();
          const QualifiedName&amp; attributeName = attributeSelector.attribute();
          if (Attribute::nameMatchesFilter(HTMLNames::styleAttr, attributeName.prefix(), attributeName.localName(), attributeName.namespaceURI()))
              return true;
  
<span class="line-modified">!         const AtomString&amp; canonicalLocalName = attributeSelector.attributeCanonicalLocalName();</span>
          if (attributeName.localName() != canonicalLocalName
              &amp;&amp; Attribute::nameMatchesFilter(HTMLNames::styleAttr, attributeName.prefix(), attributeSelector.attributeCanonicalLocalName(), attributeName.namespaceURI())) {
              return true;
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2728,11 ***</span>
  
          const QualifiedName&amp; candidateForLocalName = SVGElement::animatableAttributeForName(selectorAttributeName.localName());
          if (Attribute::nameMatchesFilter(candidateForLocalName, selectorAttributeName.prefix(), selectorAttributeName.localName(), selectorAttributeName.namespaceURI()))
              return true;
  
<span class="line-modified">!         const AtomicString&amp; canonicalLocalName = attributeSelector.attributeCanonicalLocalName();</span>
          if (selectorAttributeName.localName() != canonicalLocalName) {
              const QualifiedName&amp; candidateForCanonicalLocalName = SVGElement::animatableAttributeForName(selectorAttributeName.localName());
              if (Attribute::nameMatchesFilter(candidateForCanonicalLocalName, selectorAttributeName.prefix(), selectorAttributeName.localName(), selectorAttributeName.namespaceURI()))
                  return true;
          }
<span class="line-new-header">--- 2731,11 ---</span>
  
          const QualifiedName&amp; candidateForLocalName = SVGElement::animatableAttributeForName(selectorAttributeName.localName());
          if (Attribute::nameMatchesFilter(candidateForLocalName, selectorAttributeName.prefix(), selectorAttributeName.localName(), selectorAttributeName.namespaceURI()))
              return true;
  
<span class="line-modified">!         const AtomString&amp; canonicalLocalName = attributeSelector.attributeCanonicalLocalName();</span>
          if (selectorAttributeName.localName() != canonicalLocalName) {
              const QualifiedName&amp; candidateForCanonicalLocalName = SVGElement::animatableAttributeForName(selectorAttributeName.localName());
              if (Attribute::nameMatchesFilter(candidateForCanonicalLocalName, selectorAttributeName.prefix(), selectorAttributeName.localName(), selectorAttributeName.namespaceURI()))
                  return true;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2823,12 ***</span>
      LocalRegister localNameToMatch(m_registerAllocator);
  
      // In general, canonicalLocalName and localName are the same. When they differ, we have to check if the node is HTML to know
      // which one to use.
      const CSSSelector&amp; attributeSelector = attributeInfo.selector();
<span class="line-modified">!     const AtomicStringImpl* canonicalLocalName = attributeSelector.attributeCanonicalLocalName().impl();</span>
<span class="line-modified">!     const AtomicStringImpl* localName = attributeSelector.attribute().localName().impl();</span>
      if (canonicalLocalName == localName)
          m_assembler.move(Assembler::TrustedImmPtr(canonicalLocalName), localNameToMatch);
      else {
          m_assembler.move(Assembler::TrustedImmPtr(canonicalLocalName), localNameToMatch);
          Assembler::Jump elementIsHTML = DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::NonZero, elementAddressRegister);
<span class="line-new-header">--- 2826,12 ---</span>
      LocalRegister localNameToMatch(m_registerAllocator);
  
      // In general, canonicalLocalName and localName are the same. When they differ, we have to check if the node is HTML to know
      // which one to use.
      const CSSSelector&amp; attributeSelector = attributeInfo.selector();
<span class="line-modified">!     const AtomStringImpl* canonicalLocalName = attributeSelector.attributeCanonicalLocalName().impl();</span>
<span class="line-modified">!     const AtomStringImpl* localName = attributeSelector.attribute().localName().impl();</span>
      if (canonicalLocalName == localName)
          m_assembler.move(Assembler::TrustedImmPtr(canonicalLocalName), localNameToMatch);
      else {
          m_assembler.move(Assembler::TrustedImmPtr(canonicalLocalName), localNameToMatch);
          Assembler::Jump elementIsHTML = DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::NonZero, elementAddressRegister);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2845,11 ***</span>
  
          bool shouldCheckNamespace = attributeSelector.attribute().prefix() != starAtom();
          if (shouldCheckNamespace) {
              Assembler::Jump nameDoesNotMatch = m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), localNameToMatch);
  
<span class="line-modified">!             const AtomicStringImpl* namespaceURI = attributeSelector.attribute().namespaceURI().impl();</span>
              if (namespaceURI) {
                  LocalRegister namespaceToMatch(m_registerAllocator);
                  m_assembler.move(Assembler::TrustedImmPtr(namespaceURI), namespaceToMatch);
                  successCases.append(m_assembler.branchPtr(Assembler::Equal, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset()), namespaceToMatch));
              } else
<span class="line-new-header">--- 2848,11 ---</span>
  
          bool shouldCheckNamespace = attributeSelector.attribute().prefix() != starAtom();
          if (shouldCheckNamespace) {
              Assembler::Jump nameDoesNotMatch = m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), localNameToMatch);
  
<span class="line-modified">!             const AtomStringImpl* namespaceURI = attributeSelector.attribute().namespaceURI().impl();</span>
              if (namespaceURI) {
                  LocalRegister namespaceToMatch(m_registerAllocator);
                  m_assembler.move(Assembler::TrustedImmPtr(namespaceURI), namespaceToMatch);
                  successCases.append(m_assembler.branchPtr(Assembler::Equal, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset()), namespaceToMatch));
              } else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2884,46 ***</span>
      CaseSensitive,
      CaseInsensitive
  };
  
  template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">! static bool attributeValueBeginsWith(const Attribute* attribute, AtomicStringImpl* expectedString)</span>
  {
      ASSERT(expectedString);
  
<span class="line-modified">!     AtomicStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
      if (caseSensitivity == CaseSensitive)
          return valueImpl.startsWith(*expectedString);
      return valueImpl.startsWithIgnoringASCIICase(*expectedString);
  }
  
  template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">! static bool attributeValueContains(const Attribute* attribute, AtomicStringImpl* expectedString)</span>
  {
<span class="line-modified">!     AtomicStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
      if (caseSensitivity == CaseSensitive)
          return valueImpl.find(expectedString) != notFound;
      return valueImpl.findIgnoringASCIICase(expectedString) != notFound;
  }
  
  template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">! static bool attributeValueEndsWith(const Attribute* attribute, AtomicStringImpl* expectedString)</span>
  {
      ASSERT(expectedString);
  
<span class="line-modified">!     AtomicStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
      if (caseSensitivity == CaseSensitive)
          return valueImpl.endsWith(*expectedString);
      return valueImpl.endsWithIgnoringASCIICase(*expectedString);
  }
  
  template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">! static bool attributeValueMatchHyphenRule(const Attribute* attribute, AtomicStringImpl* expectedString)</span>
  {
      ASSERT(expectedString);
  
<span class="line-modified">!     AtomicStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
      if (valueImpl.length() &lt; expectedString-&gt;length())
          return false;
  
      bool valueStartsWithExpectedString;
      if (caseSensitivity == CaseSensitive)
<span class="line-new-header">--- 2887,46 ---</span>
      CaseSensitive,
      CaseInsensitive
  };
  
  template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">! static bool attributeValueBeginsWith(const Attribute* attribute, AtomStringImpl* expectedString)</span>
  {
      ASSERT(expectedString);
  
<span class="line-modified">!     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
      if (caseSensitivity == CaseSensitive)
          return valueImpl.startsWith(*expectedString);
      return valueImpl.startsWithIgnoringASCIICase(*expectedString);
  }
  
  template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">! static bool attributeValueContains(const Attribute* attribute, AtomStringImpl* expectedString)</span>
  {
<span class="line-modified">!     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
      if (caseSensitivity == CaseSensitive)
          return valueImpl.find(expectedString) != notFound;
      return valueImpl.findIgnoringASCIICase(expectedString) != notFound;
  }
  
  template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">! static bool attributeValueEndsWith(const Attribute* attribute, AtomStringImpl* expectedString)</span>
  {
      ASSERT(expectedString);
  
<span class="line-modified">!     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
      if (caseSensitivity == CaseSensitive)
          return valueImpl.endsWith(*expectedString);
      return valueImpl.endsWithIgnoringASCIICase(*expectedString);
  }
  
  template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">! static bool attributeValueMatchHyphenRule(const Attribute* attribute, AtomStringImpl* expectedString)</span>
  {
      ASSERT(expectedString);
  
<span class="line-modified">!     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
      if (valueImpl.length() &lt; expectedString-&gt;length())
          return false;
  
      bool valueStartsWithExpectedString;
      if (caseSensitivity == CaseSensitive)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2936,13 ***</span>
  
      return valueImpl.length() == expectedString-&gt;length() || valueImpl[expectedString-&gt;length()] == &#39;-&#39;;
  }
  
  template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">! static bool attributeValueSpaceSeparetedListContains(const Attribute* attribute, AtomicStringImpl* expectedString)</span>
  {
<span class="line-modified">!     AtomicStringImpl&amp; value = *attribute-&gt;value().impl();</span>
  
      unsigned startSearchAt = 0;
      while (true) {
          size_t foundPos;
          if (caseSensitivity == CaseSensitive)
<span class="line-new-header">--- 2939,13 ---</span>
  
      return valueImpl.length() == expectedString-&gt;length() || valueImpl[expectedString-&gt;length()] == &#39;-&#39;;
  }
  
  template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">! static bool attributeValueSpaceSeparetedListContains(const Attribute* attribute, AtomStringImpl* expectedString)</span>
  {
<span class="line-modified">!     AtomStringImpl&amp; value = *attribute-&gt;value().impl();</span>
  
      unsigned startSearchAt = 0;
      while (true) {
          size_t foundPos;
          if (caseSensitivity == CaseSensitive)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2962,11 ***</span>
  }
  
  void SelectorCodeGenerator::generateElementAttributeValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AttributeMatchingInfo&amp; attributeInfo)
  {
      const CSSSelector&amp; attributeSelector = attributeInfo.selector();
<span class="line-modified">!     const AtomicString&amp; expectedValue = attributeSelector.value();</span>
      ASSERT(!expectedValue.isNull());
      AttributeCaseSensitivity valueCaseSensitivity = attributeInfo.attributeCaseSensitivity();
  
      switch (attributeSelector.match()) {
      case CSSSelector::Begin:
<span class="line-new-header">--- 2965,11 ---</span>
  }
  
  void SelectorCodeGenerator::generateElementAttributeValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AttributeMatchingInfo&amp; attributeInfo)
  {
      const CSSSelector&amp; attributeSelector = attributeInfo.selector();
<span class="line-modified">!     const AtomString&amp; expectedValue = attributeSelector.value();</span>
      ASSERT(!expectedValue.isNull());
      AttributeCaseSensitivity valueCaseSensitivity = attributeInfo.attributeCaseSensitivity();
  
      switch (attributeSelector.match()) {
      case CSSSelector::Begin:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2995,11 ***</span>
  static inline Assembler::Jump testIsHTMLClassOnDocument(Assembler::ResultCondition condition, Assembler&amp; assembler, Assembler::RegisterID documentAddress)
  {
      return assembler.branchTest32(condition, Assembler::Address(documentAddress, Document::documentClassesMemoryOffset()), Assembler::TrustedImm32(Document::isHTMLDocumentClassFlag()));
  }
  
<span class="line-modified">! void SelectorCodeGenerator::generateElementAttributeValueExactMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomicString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity)</span>
  {
      LocalRegisterWithPreference expectedValueRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
      m_assembler.move(Assembler::TrustedImmPtr(expectedValue.impl()), expectedValueRegister);
  
      switch (valueCaseSensitivity) {
<span class="line-new-header">--- 2998,11 ---</span>
  static inline Assembler::Jump testIsHTMLClassOnDocument(Assembler::ResultCondition condition, Assembler&amp; assembler, Assembler::RegisterID documentAddress)
  {
      return assembler.branchTest32(condition, Assembler::Address(documentAddress, Document::documentClassesMemoryOffset()), Assembler::TrustedImm32(Document::isHTMLDocumentClassFlag()));
  }
  
<span class="line-modified">! void SelectorCodeGenerator::generateElementAttributeValueExactMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity)</span>
  {
      LocalRegisterWithPreference expectedValueRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
      m_assembler.move(Assembler::TrustedImmPtr(expectedValue.impl()), expectedValueRegister);
  
      switch (valueCaseSensitivity) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3045,11 ***</span>
          break;
      }
      }
  }
  
<span class="line-modified">! void SelectorCodeGenerator::generateElementAttributeFunctionCallValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomicString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseSensitiveTest, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseInsensitiveTest)</span>
  {
      LocalRegisterWithPreference expectedValueRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
      m_assembler.move(Assembler::TrustedImmPtr(expectedValue.impl()), expectedValueRegister);
  
  
<span class="line-new-header">--- 3048,11 ---</span>
          break;
      }
      }
  }
  
<span class="line-modified">! void SelectorCodeGenerator::generateElementAttributeFunctionCallValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseSensitiveTest, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseInsensitiveTest)</span>
  {
      LocalRegisterWithPreference expectedValueRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
      m_assembler.move(Assembler::TrustedImmPtr(expectedValue.impl()), expectedValueRegister);
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3266,15 ***</span>
      successCases.link(&amp;m_assembler);
  }
  
  void SelectorCodeGenerator::generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
  {
<span class="line-modified">!     for (const Vector&lt;AtomicString&gt;* languageArguments : fragment.languageArgumentsList)</span>
          generateElementIsInLanguage(failureCases, languageArguments);
  }
  
<span class="line-modified">! void SelectorCodeGenerator::generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const Vector&lt;AtomicString&gt;* languageArguments)</span>
  {
      LocalRegisterWithPreference langRangeRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
      m_assembler.move(Assembler::TrustedImmPtr(languageArguments), langRangeRegister);
  
      Assembler::RegisterID elementAddress = elementAddressRegister;
<span class="line-new-header">--- 3269,15 ---</span>
      successCases.link(&amp;m_assembler);
  }
  
  void SelectorCodeGenerator::generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
  {
<span class="line-modified">!     for (const Vector&lt;AtomString&gt;* languageArguments : fragment.languageArgumentsList)</span>
          generateElementIsInLanguage(failureCases, languageArguments);
  }
  
<span class="line-modified">! void SelectorCodeGenerator::generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const Vector&lt;AtomString&gt;* languageArguments)</span>
  {
      LocalRegisterWithPreference langRangeRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
      m_assembler.move(Assembler::TrustedImmPtr(languageArguments), langRangeRegister);
  
      Assembler::RegisterID elementAddress = elementAddressRegister;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3453,13 ***</span>
  
      // Load the QualifiedNameImpl from the input.
      LocalRegister qualifiedNameImpl(m_registerAllocator);
      m_assembler.loadPtr(Assembler::Address(elementAddressRegister, Element::tagQNameMemoryOffset() + QualifiedName::implMemoryOffset()), qualifiedNameImpl);
  
<span class="line-modified">!     const AtomicString&amp; selectorLocalName = nameToMatch.localName();</span>
      if (selectorLocalName != starAtom()) {
<span class="line-modified">!         const AtomicString&amp; lowercaseLocalName = tagMatchingSelector.tagLowercaseLocalName();</span>
  
          if (selectorLocalName == lowercaseLocalName) {
              // Generate localName == element-&gt;localName().
              LocalRegister constantRegister(m_registerAllocator);
              m_assembler.move(Assembler::TrustedImmPtr(selectorLocalName.impl()), constantRegister);
<span class="line-new-header">--- 3456,13 ---</span>
  
      // Load the QualifiedNameImpl from the input.
      LocalRegister qualifiedNameImpl(m_registerAllocator);
      m_assembler.loadPtr(Assembler::Address(elementAddressRegister, Element::tagQNameMemoryOffset() + QualifiedName::implMemoryOffset()), qualifiedNameImpl);
  
<span class="line-modified">!     const AtomString&amp; selectorLocalName = nameToMatch.localName();</span>
      if (selectorLocalName != starAtom()) {
<span class="line-modified">!         const AtomString&amp; lowercaseLocalName = tagMatchingSelector.tagLowercaseLocalName();</span>
  
          if (selectorLocalName == lowercaseLocalName) {
              // Generate localName == element-&gt;localName().
              LocalRegister constantRegister(m_registerAllocator);
              m_assembler.move(Assembler::TrustedImmPtr(selectorLocalName.impl()), constantRegister);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3483,28 ***</span>
  
              failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), constantRegister));
          }
      }
  
<span class="line-modified">!     const AtomicString&amp; selectorNamespaceURI = nameToMatch.namespaceURI();</span>
      if (selectorNamespaceURI != starAtom()) {
          // Generate namespaceURI == element-&gt;namespaceURI().
          LocalRegister constantRegister(m_registerAllocator);
          m_assembler.move(Assembler::TrustedImmPtr(selectorNamespaceURI.impl()), constantRegister);
          failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset()), constantRegister));
      }
  }
  
<span class="line-modified">! void SelectorCodeGenerator::generateElementHasId(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const AtomicString&amp; idToMatch)</span>
  {
<span class="line-modified">!     // Compare the pointers of the AtomicStringImpl from idForStyleResolution with the reference idToMatch.</span>
      LocalRegister idToMatchRegister(m_registerAllocator);
      m_assembler.move(Assembler::TrustedImmPtr(idToMatch.impl()), idToMatchRegister);
      failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(elementDataAddress, ElementData::idForStyleResolutionMemoryOffset()), idToMatchRegister));
  }
  
<span class="line-modified">! void SelectorCodeGenerator::generateElementHasClasses(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const Vector&lt;const AtomicStringImpl*, 8&gt;&amp; classNames)</span>
  {
      // Load m_classNames.
      LocalRegister spaceSplitStringData(m_registerAllocator);
      m_assembler.loadPtr(Assembler::Address(elementDataAddress, ElementData::classNamesMemoryOffset()), spaceSplitStringData);
  
<span class="line-new-header">--- 3486,28 ---</span>
  
              failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), constantRegister));
          }
      }
  
<span class="line-modified">!     const AtomString&amp; selectorNamespaceURI = nameToMatch.namespaceURI();</span>
      if (selectorNamespaceURI != starAtom()) {
          // Generate namespaceURI == element-&gt;namespaceURI().
          LocalRegister constantRegister(m_registerAllocator);
          m_assembler.move(Assembler::TrustedImmPtr(selectorNamespaceURI.impl()), constantRegister);
          failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset()), constantRegister));
      }
  }
  
<span class="line-modified">! void SelectorCodeGenerator::generateElementHasId(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const AtomString&amp; idToMatch)</span>
  {
<span class="line-modified">!     // Compare the pointers of the AtomStringImpl from idForStyleResolution with the reference idToMatch.</span>
      LocalRegister idToMatchRegister(m_registerAllocator);
      m_assembler.move(Assembler::TrustedImmPtr(idToMatch.impl()), idToMatchRegister);
      failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(elementDataAddress, ElementData::idForStyleResolutionMemoryOffset()), idToMatchRegister));
  }
  
<span class="line-modified">! void SelectorCodeGenerator::generateElementHasClasses(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const Vector&lt;const AtomStringImpl*, 8&gt;&amp; classNames)</span>
  {
      // Load m_classNames.
      LocalRegister spaceSplitStringData(m_registerAllocator);
      m_assembler.loadPtr(Assembler::Address(elementDataAddress, ElementData::classNamesMemoryOffset()), spaceSplitStringData);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3597,14 ***</span>
          // index on the first direct adjacent.
          Assembler::JumpList noMoreSiblingsCases;
  
          Assembler::JumpList noCachedChildIndexCases;
          generateWalkToPreviousAdjacentElement(noMoreSiblingsCases, previousSibling);
<span class="line-modified">!         noCachedChildIndexCases.append(m_assembler.branchTest32(Assembler::Zero, Assembler::Address(previousSibling, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagHasRareData())));</span>
          {
<span class="line-removed">-             LocalRegister elementRareData(m_registerAllocator);</span>
<span class="line-removed">-             m_assembler.loadPtr(Assembler::Address(previousSibling, Node::rareDataMemoryOffset()), elementRareData);</span>
              LocalRegister cachedChildIndex(m_registerAllocator);
              m_assembler.load16(Assembler::Address(elementRareData, ElementRareData::childIndexMemoryOffset()), cachedChildIndex);
              noCachedChildIndexCases.append(m_assembler.branchTest32(Assembler::Zero, cachedChildIndex));
              m_assembler.add32(cachedChildIndex, elementCounter);
              noMoreSiblingsCases.append(m_assembler.jump());
<span class="line-new-header">--- 3600,16 ---</span>
          // index on the first direct adjacent.
          Assembler::JumpList noMoreSiblingsCases;
  
          Assembler::JumpList noCachedChildIndexCases;
          generateWalkToPreviousAdjacentElement(noMoreSiblingsCases, previousSibling);
<span class="line-modified">! </span>
<span class="line-added">+         LocalRegister elementRareData(m_registerAllocator);</span>
<span class="line-added">+         m_assembler.loadPtr(Assembler::Address(previousSibling, Node::rareDataMemoryOffset()), elementRareData);</span>
<span class="line-added">+ </span>
<span class="line-added">+         noCachedChildIndexCases.append(m_assembler.branchTestPtr(Assembler::Zero, elementRareData));</span>
          {
              LocalRegister cachedChildIndex(m_registerAllocator);
              m_assembler.load16(Assembler::Address(elementRareData, ElementRareData::childIndexMemoryOffset()), cachedChildIndex);
              noCachedChildIndexCases.append(m_assembler.branchTest32(Assembler::Zero, cachedChildIndex));
              m_assembler.add32(cachedChildIndex, elementCounter);
              noMoreSiblingsCases.append(m_assembler.jump());
</pre>
<center><a href="../css/typedom/TypedOMCSSUnparsedValue.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackAllocator.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>