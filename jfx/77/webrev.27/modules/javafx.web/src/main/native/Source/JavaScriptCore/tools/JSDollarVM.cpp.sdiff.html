<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/JSDollarVM.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HeapVerifier.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SigillCrashAnalyzer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/JSDollarVM.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;JSDollarVM.h&quot;
  28 
  29 #include &quot;BuiltinExecutableCreator.h&quot;
  30 #include &quot;CodeBlock.h&quot;
  31 #include &quot;DOMAttributeGetterSetter.h&quot;
  32 #include &quot;DOMJITGetterSetter.h&quot;
  33 #include &quot;FrameTracers.h&quot;
  34 #include &quot;FunctionCodeBlock.h&quot;
  35 #include &quot;GetterSetter.h&quot;
  36 #include &quot;JSArray.h&quot;
  37 #include &quot;JSArrayBuffer.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;JSFunction.h&quot;
  40 #include &quot;JSONObject.h&quot;
  41 #include &quot;JSProxy.h&quot;
  42 #include &quot;JSString.h&quot;

  43 #include &quot;ShadowChicken.h&quot;
  44 #include &quot;Snippet.h&quot;
  45 #include &quot;SnippetParams.h&quot;
  46 #include &quot;TypeProfiler.h&quot;
  47 #include &quot;TypeProfilerLog.h&quot;
  48 #include &quot;VMInspector.h&quot;

  49 #include &lt;wtf/Atomics.h&gt;
  50 #include &lt;wtf/DataLog.h&gt;
  51 #include &lt;wtf/ProcessID.h&gt;
  52 #include &lt;wtf/StringPrintStream.h&gt;
  53 
  54 #if ENABLE(WEBASSEMBLY)
  55 #include &quot;JSWebAssemblyHelpers.h&quot;
  56 #include &quot;WasmStreamingParser.h&quot;
  57 #endif
  58 
  59 using namespace JSC;
  60 
  61 namespace {
  62 
  63 class JSDollarVMCallFrame : public JSDestructibleObject {
  64     using Base = JSDestructibleObject;
  65 public:
  66     JSDollarVMCallFrame(VM&amp; vm, Structure* structure)
  67         : Base(vm, structure)
  68     { }
  69 
  70     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  71     {
  72         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  73     }
  74 
  75     static JSDollarVMCallFrame* create(ExecState* exec, unsigned requestedFrameIndex)
  76     {
  77         VM&amp; vm = exec-&gt;vm();
  78         JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
  79         Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified">  80         JSDollarVMCallFrame* frame = new (NotNull, allocateCell&lt;JSDollarVMCallFrame&gt;(vm.heap, sizeof(JSDollarVMCallFrame))) JSDollarVMCallFrame(vm, structure);</span>
  81         frame-&gt;finishCreation(vm, exec, requestedFrameIndex);
  82         return frame;
  83     }
  84 
  85     void finishCreation(VM&amp; vm, CallFrame* frame, unsigned requestedFrameIndex)
  86     {
  87         Base::finishCreation(vm);
  88 
  89         auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
  90             JSDollarVMCallFrame::addProperty(vm, name, value);
  91         };
  92 
  93         unsigned frameIndex = 0;
  94         bool isValid = false;
  95         frame-&gt;iterate([&amp;] (StackVisitor&amp; visitor) {
  96 
  97             if (frameIndex++ != requestedFrameIndex)
  98                 return StackVisitor::Continue;
  99 
<span class="line-modified"> 100             addProperty(vm, &quot;name&quot;, jsString(&amp;vm, visitor-&gt;functionName()));</span>
 101 
 102             if (visitor-&gt;callee().isCell())
 103                 addProperty(vm, &quot;callee&quot;, visitor-&gt;callee().asCell());
 104 
 105             CodeBlock* codeBlock = visitor-&gt;codeBlock();
 106             if (codeBlock) {
 107                 addProperty(vm, &quot;codeBlock&quot;, codeBlock);
 108                 addProperty(vm, &quot;unlinkedCodeBlock&quot;, codeBlock-&gt;unlinkedCodeBlock());
 109                 addProperty(vm, &quot;executable&quot;, codeBlock-&gt;ownerExecutable());
 110             }
 111             isValid = true;
 112 
 113             return StackVisitor::Done;
 114         });
 115 
 116         addProperty(vm, &quot;valid&quot;, jsBoolean(isValid));
 117     }
 118 
 119     DECLARE_INFO;
 120 
 121 private:
 122     void addProperty(VM&amp; vm, const char* name, JSValue value)
 123     {
<span class="line-modified"> 124         Identifier identifier = Identifier::fromString(&amp;vm, name);</span>
 125         putDirect(vm, identifier, value);
 126     }
 127 };
 128 
 129 const ClassInfo JSDollarVMCallFrame::s_info = { &quot;CallFrame&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVMCallFrame) };
 130 
 131 class ElementHandleOwner;
 132 class Root;
 133 
 134 class Element : public JSNonFinalObject {
 135 public:
 136     Element(VM&amp; vm, Structure* structure)
 137         : Base(vm, structure)
 138     {
 139     }
 140 
 141     typedef JSNonFinalObject Base;
 142 
 143     Root* root() const { return m_root.get(); }
 144     void setRoot(VM&amp; vm, Root* root) { m_root.set(vm, this, root); }
 145 
 146     static Element* create(VM&amp; vm, JSGlobalObject* globalObject, Root* root)
 147     {
 148         Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified"> 149         Element* element = new (NotNull, allocateCell&lt;Element&gt;(vm.heap, sizeof(Element))) Element(vm, structure);</span>
 150         element-&gt;finishCreation(vm, root);
 151         return element;
 152     }
 153 
 154     void finishCreation(VM&amp;, Root*);
 155 
 156     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 157     {
 158         Element* thisObject = jsCast&lt;Element*&gt;(cell);
 159         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 160         Base::visitChildren(thisObject, visitor);
 161         visitor.append(thisObject-&gt;m_root);
 162     }
 163 
 164     static ElementHandleOwner* handleOwner();
 165 
 166     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 167     {
 168         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 169     }
 170 
 171     DECLARE_INFO;
 172 
 173 private:
 174     WriteBarrier&lt;Root&gt; m_root;
 175 };
 176 
 177 class ElementHandleOwner : public WeakHandleOwner {

 178 public:
 179     bool isReachableFromOpaqueRoots(Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason) override
 180     {
 181         if (UNLIKELY(reason))
 182             *reason = &quot;JSC::Element is opaque root&quot;;
 183         Element* element = jsCast&lt;Element*&gt;(handle.slot()-&gt;asCell());
 184         return visitor.containsOpaqueRoot(element-&gt;root());
 185     }
 186 };
 187 
 188 class Root : public JSDestructibleObject {
 189 public:
 190     Root(VM&amp; vm, Structure* structure)
 191         : Base(vm, structure)
 192     {
 193     }
 194 
 195     Element* element()
 196     {
 197         return m_element.get();
 198     }
 199 
 200     void setElement(Element* element)
 201     {
 202         Weak&lt;Element&gt; newElement(element, Element::handleOwner());
 203         m_element.swap(newElement);
 204     }
 205 
 206     static Root* create(VM&amp; vm, JSGlobalObject* globalObject)
 207     {
 208         Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified"> 209         Root* root = new (NotNull, allocateCell&lt;Root&gt;(vm.heap, sizeof(Root))) Root(vm, structure);</span>
 210         root-&gt;finishCreation(vm);
 211         return root;
 212     }
 213 
 214     typedef JSDestructibleObject Base;
 215 
 216     DECLARE_INFO;
 217 
 218     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 219     {
 220         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 221     }
 222 
 223     static void visitChildren(JSCell* thisObject, SlotVisitor&amp; visitor)
 224     {

 225         Base::visitChildren(thisObject, visitor);
 226         visitor.addOpaqueRoot(thisObject);
 227     }
 228 
 229 private:
 230     Weak&lt;Element&gt; m_element;
 231 };
 232 
 233 class SimpleObject : public JSNonFinalObject {
 234 public:
 235     SimpleObject(VM&amp; vm, Structure* structure)
 236         : Base(vm, structure)
 237     {
 238     }
 239 
 240     typedef JSNonFinalObject Base;
 241     static const bool needsDestruction = false;
 242 
 243     static SimpleObject* create(VM&amp; vm, JSGlobalObject* globalObject)
 244     {
 245         Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified"> 246         SimpleObject* simpleObject = new (NotNull, allocateCell&lt;SimpleObject&gt;(vm.heap, sizeof(SimpleObject))) SimpleObject(vm, structure);</span>
 247         simpleObject-&gt;finishCreation(vm);
 248         return simpleObject;
 249     }
 250 
 251     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 252     {
 253         SimpleObject* thisObject = jsCast&lt;SimpleObject*&gt;(cell);
 254         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 255         Base::visitChildren(thisObject, visitor);
 256         visitor.append(thisObject-&gt;m_hiddenValue);
 257     }
 258 
 259     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 260     {
 261         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 262     }
 263 
 264     JSValue hiddenValue()
 265     {
 266         return m_hiddenValue.get();
</pre>
<hr />
<pre>
 279 };
 280 
 281 class ImpureGetter : public JSNonFinalObject {
 282 public:
 283     ImpureGetter(VM&amp; vm, Structure* structure)
 284         : Base(vm, structure)
 285     {
 286     }
 287 
 288     DECLARE_INFO;
 289     typedef JSNonFinalObject Base;
 290     static const unsigned StructureFlags = Base::StructureFlags | JSC::GetOwnPropertySlotIsImpure | JSC::OverridesGetOwnPropertySlot;
 291 
 292     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 293     {
 294         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 295     }
 296 
 297     static ImpureGetter* create(VM&amp; vm, Structure* structure, JSObject* delegate)
 298     {
<span class="line-modified"> 299         ImpureGetter* getter = new (NotNull, allocateCell&lt;ImpureGetter&gt;(vm.heap, sizeof(ImpureGetter))) ImpureGetter(vm, structure);</span>
 300         getter-&gt;finishCreation(vm, delegate);
 301         return getter;
 302     }
 303 
 304     void finishCreation(VM&amp; vm, JSObject* delegate)
 305     {
 306         Base::finishCreation(vm);
 307         if (delegate)
 308             m_delegate.set(vm, this, delegate);
 309     }
 310 
 311     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName name, PropertySlot&amp; slot)
 312     {
 313         VM&amp; vm = exec-&gt;vm();
 314         auto scope = DECLARE_THROW_SCOPE(vm);
 315         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(object);
 316 
 317         if (thisObject-&gt;m_delegate) {
 318             if (thisObject-&gt;m_delegate-&gt;getPropertySlot(exec, name, slot))
 319                 return true;
 320             RETURN_IF_EXCEPTION(scope, false);
 321         }
 322 
 323         return Base::getOwnPropertySlot(object, exec, name, slot);
 324     }
 325 
 326     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 327     {

 328         Base::visitChildren(cell, visitor);
 329         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(cell);
 330         visitor.append(thisObject-&gt;m_delegate);
 331     }
 332 
 333     void setDelegate(VM&amp; vm, JSObject* delegate)
 334     {
 335         m_delegate.set(vm, this, delegate);
 336     }
 337 
 338 private:
 339     WriteBarrier&lt;JSObject&gt; m_delegate;
 340 };
 341 
 342 class CustomGetter : public JSNonFinalObject {
 343 public:
 344     CustomGetter(VM&amp; vm, Structure* structure)
 345         : Base(vm, structure)
 346     {
 347     }
 348 
 349     DECLARE_INFO;
 350     typedef JSNonFinalObject Base;
 351     static const unsigned StructureFlags = Base::StructureFlags | JSC::OverridesGetOwnPropertySlot;
 352 
 353     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 354     {
 355         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 356     }
 357 
 358     static CustomGetter* create(VM&amp; vm, Structure* structure)
 359     {
<span class="line-modified"> 360         CustomGetter* getter = new (NotNull, allocateCell&lt;CustomGetter&gt;(vm.heap, sizeof(CustomGetter))) CustomGetter(vm, structure);</span>
 361         getter-&gt;finishCreation(vm);
 362         return getter;
 363     }
 364 
 365     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 366     {

 367         CustomGetter* thisObject = jsCast&lt;CustomGetter*&gt;(object);
<span class="line-modified"> 368         if (propertyName == PropertyName(Identifier::fromString(exec, &quot;customGetter&quot;))) {</span>
 369             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;customGetter);
 370             return true;
 371         }
 372 
<span class="line-modified"> 373         if (propertyName == PropertyName(Identifier::fromString(exec, &quot;customGetterAccessor&quot;))) {</span>
 374             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::CustomAccessor, thisObject-&gt;customGetterAcessor);
 375             return true;
 376         }
 377 
 378         return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);
 379     }
 380 
 381 private:
 382     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 383     {
 384         VM&amp; vm = exec-&gt;vm();
 385         auto scope = DECLARE_THROW_SCOPE(vm);
 386 
 387         CustomGetter* thisObject = jsDynamicCast&lt;CustomGetter*&gt;(vm, JSValue::decode(thisValue));
 388         if (!thisObject)
 389             return throwVMTypeError(exec, scope);
<span class="line-modified"> 390         bool shouldThrow = thisObject-&gt;get(exec, PropertyName(Identifier::fromString(exec, &quot;shouldThrow&quot;))).toBoolean(exec);</span>
 391         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 392         if (shouldThrow)
 393             return throwVMTypeError(exec, scope);
 394         return JSValue::encode(jsNumber(100));
 395     }
 396 
 397     static EncodedJSValue customGetterAcessor(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 398     {
 399         VM&amp; vm = exec-&gt;vm();
 400         auto scope = DECLARE_THROW_SCOPE(vm);
 401 
 402         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 403         if (!thisObject)
 404             return throwVMTypeError(exec, scope);
<span class="line-modified"> 405         bool shouldThrow = thisObject-&gt;get(exec, PropertyName(Identifier::fromString(exec, &quot;shouldThrow&quot;))).toBoolean(exec);</span>
 406         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 407         if (shouldThrow)
 408             return throwVMTypeError(exec, scope);
 409         return JSValue::encode(jsNumber(100));
 410     }
 411 };
 412 
 413 class RuntimeArray : public JSArray {
 414 public:
 415     typedef JSArray Base;
 416     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | OverridesGetPropertyNames;
 417 
 418     static RuntimeArray* create(ExecState* exec)
 419     {
 420         VM&amp; vm = exec-&gt;vm();
 421         JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 422         Structure* structure = createStructure(vm, globalObject, createPrototype(vm, globalObject));
 423         RuntimeArray* runtimeArray = new (NotNull, allocateCell&lt;RuntimeArray&gt;(vm.heap)) RuntimeArray(exec, structure);
 424         runtimeArray-&gt;finishCreation(exec);
 425         vm.heap.addFinalizer(runtimeArray, destroy);
</pre>
<hr />
<pre>
 533     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 534     {
 535         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 536     }
 537 
 538 #if ENABLE(JIT)
 539     static Ref&lt;Snippet&gt; checkSubClassSnippet()
 540     {
 541         Ref&lt;Snippet&gt; snippet = Snippet::create();
 542         snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 543             CCallHelpers::JumpList failureCases;
 544             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
 545             return failureCases;
 546         });
 547         return snippet;
 548     }
 549 #endif
 550 
 551     static DOMJITNode* create(VM&amp; vm, Structure* structure)
 552     {
<span class="line-modified"> 553         DOMJITNode* getter = new (NotNull, allocateCell&lt;DOMJITNode&gt;(vm.heap, sizeof(DOMJITNode))) DOMJITNode(vm, structure);</span>
 554         getter-&gt;finishCreation(vm);
 555         return getter;
 556     }
 557 
 558     int32_t value() const
 559     {
 560         return m_value;
 561     }
 562 
 563     static ptrdiff_t offsetOfValue() { return OBJECT_OFFSETOF(DOMJITNode, m_value); }
 564 
 565 private:
 566     int32_t m_value { 42 };
 567 };
 568 
 569 class DOMJITGetter : public DOMJITNode {
 570 public:
 571     DOMJITGetter(VM&amp; vm, Structure* structure)
 572         : Base(vm, structure)
 573     {
 574     }
 575 
 576     DECLARE_INFO;
 577     typedef DOMJITNode Base;
 578     static const unsigned StructureFlags = Base::StructureFlags;
 579 
 580     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 581     {
 582         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 583     }
 584 
 585     static DOMJITGetter* create(VM&amp; vm, Structure* structure)
 586     {
<span class="line-modified"> 587         DOMJITGetter* getter = new (NotNull, allocateCell&lt;DOMJITGetter&gt;(vm.heap, sizeof(DOMJITGetter))) DOMJITGetter(vm, structure);</span>
 588         getter-&gt;finishCreation(vm);
 589         return getter;
 590     }
 591 
 592     class DOMJITAttribute : public DOMJIT::GetterSetter {
 593     public:
 594         constexpr DOMJITAttribute()
 595             : DOMJIT::GetterSetter(
 596                 DOMJITGetter::customGetter,
 597 #if ENABLE(JIT)
 598                 &amp;callDOMGetter,
 599 #else
 600                 nullptr,
 601 #endif
 602                 SpecInt32Only)
 603         {
 604         }
 605 
 606 #if ENABLE(JIT)
 607         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)
 608         {
 609             VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 610             NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 611             return JSValue::encode(jsNumber(static_cast&lt;DOMJITGetter*&gt;(pointer)-&gt;value()));
 612         }
 613 
 614         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 615         {
 616             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 617             snippet-&gt;requireGlobalObject = false;
 618             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 619                 JSValueRegs results = params[0].jsValueRegs();
 620                 GPRReg dom = params[1].gpr();
 621                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, dom);
 622                 return CCallHelpers::JumpList();
 623 
 624             });
 625             return snippet;
 626         }
 627 #endif
 628     };
 629 
 630 private:
 631     void finishCreation(VM&amp;);
 632 
 633     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 634     {
 635         VM&amp; vm = exec-&gt;vm();
 636         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, JSValue::decode(thisValue));
 637         ASSERT(thisObject);
 638         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 639     }
 640 };
 641 
 642 static const DOMJITGetter::DOMJITAttribute DOMJITGetterDOMJIT;
 643 
 644 void DOMJITGetter::finishCreation(VM&amp; vm)
 645 {
 646     Base::finishCreation(vm);
 647     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterDOMJIT;
 648     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITNode::info(), domJIT });
<span class="line-modified"> 649     putDirectCustomAccessor(vm, Identifier::fromString(&amp;vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);</span>
 650 }
 651 
 652 class DOMJITGetterComplex : public DOMJITNode {
 653 public:
 654     DOMJITGetterComplex(VM&amp; vm, Structure* structure)
 655         : Base(vm, structure)
 656     {
 657     }
 658 
 659     DECLARE_INFO;
 660     typedef DOMJITNode Base;
 661     static const unsigned StructureFlags = Base::StructureFlags;
 662 
 663     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 664     {
 665         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 666     }
 667 
 668     static DOMJITGetterComplex* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 669     {
<span class="line-modified"> 670         DOMJITGetterComplex* getter = new (NotNull, allocateCell&lt;DOMJITGetterComplex&gt;(vm.heap, sizeof(DOMJITGetterComplex))) DOMJITGetterComplex(vm, structure);</span>
 671         getter-&gt;finishCreation(vm, globalObject);
 672         return getter;
 673     }
 674 
 675     class DOMJITAttribute : public DOMJIT::GetterSetter {
 676     public:
 677         constexpr DOMJITAttribute()
 678             : DOMJIT::GetterSetter(
 679                 DOMJITGetterComplex::customGetter,
 680 #if ENABLE(JIT)
 681                 &amp;callDOMGetter,
 682 #else
 683                 nullptr,
 684 #endif
 685                 SpecInt32Only)
 686         {
 687         }
 688 
 689 #if ENABLE(JIT)
 690         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)
 691         {
 692             VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 693             NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 694             auto scope = DECLARE_THROW_SCOPE(vm);
 695             auto* object = static_cast&lt;DOMJITNode*&gt;(pointer);
 696             auto* domjitGetterComplex = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, object);
 697             if (domjitGetterComplex) {
 698                 if (domjitGetterComplex-&gt;m_enableException)
 699                     return JSValue::encode(throwException(exec, scope, createError(exec, &quot;DOMJITGetterComplex slow call exception&quot;_s)));
 700             }
 701             return JSValue::encode(jsNumber(object-&gt;value()));
 702         }
 703 
 704         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 705         {
 706             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 707             static_assert(GPRInfo::numberOfRegisters &gt;= 4, &quot;Number of registers should be larger or equal to 4.&quot;);
 708             unsigned numGPScratchRegisters = GPRInfo::numberOfRegisters - 4;
 709             snippet-&gt;numGPScratchRegisters = numGPScratchRegisters;
 710             snippet-&gt;numFPScratchRegisters = 3;
 711             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 712                 JSValueRegs results = params[0].jsValueRegs();
 713                 GPRReg domGPR = params[1].gpr();
</pre>
<hr />
<pre>
 739         VM&amp; vm = exec-&gt;vm();
 740         auto scope = DECLARE_THROW_SCOPE(vm);
 741 
 742         auto* thisObject = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, JSValue::decode(thisValue));
 743         ASSERT(thisObject);
 744         if (thisObject-&gt;m_enableException)
 745             return JSValue::encode(throwException(exec, scope, createError(exec, &quot;DOMJITGetterComplex slow call exception&quot;_s)));
 746         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 747     }
 748 
 749     bool m_enableException { false };
 750 };
 751 
 752 static const DOMJITGetterComplex::DOMJITAttribute DOMJITGetterComplexDOMJIT;
 753 
 754 void DOMJITGetterComplex::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 755 {
 756     Base::finishCreation(vm);
 757     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterComplexDOMJIT;
 758     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITGetterComplex::info(), domJIT });
<span class="line-modified"> 759     putDirectCustomAccessor(vm, Identifier::fromString(&amp;vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);</span>
<span class="line-modified"> 760     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;enableException&quot;), 0, functionEnableException, NoIntrinsic, 0);</span>
 761 }
 762 
 763 class DOMJITFunctionObject : public DOMJITNode {
 764 public:
 765     DOMJITFunctionObject(VM&amp; vm, Structure* structure)
 766         : Base(vm, structure)
 767     {
 768     }
 769 
 770     DECLARE_INFO;
 771     typedef DOMJITNode Base;
 772     static const unsigned StructureFlags = Base::StructureFlags;
 773 
 774 
 775     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 776     {
 777         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 778     }
 779 
 780     static DOMJITFunctionObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 781     {
<span class="line-modified"> 782         DOMJITFunctionObject* object = new (NotNull, allocateCell&lt;DOMJITFunctionObject&gt;(vm.heap, sizeof(DOMJITFunctionObject))) DOMJITFunctionObject(vm, structure);</span>
 783         object-&gt;finishCreation(vm, globalObject);
 784         return object;
 785     }
 786 
<span class="line-modified"> 787     static EncodedJSValue JSC_HOST_CALL safeFunction(ExecState* exec)</span>
 788     {
 789         VM&amp; vm = exec-&gt;vm();
 790         auto scope = DECLARE_THROW_SCOPE(vm);
 791 
 792         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, exec-&gt;thisValue());
 793         if (!thisObject)
 794             return throwVMTypeError(exec, scope);
 795         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 796     }
 797 
<span class="line-modified"> 798     static EncodedJSValue JIT_OPERATION unsafeFunction(ExecState* exec, DOMJITNode* node)</span>
 799     {
 800         VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 801         NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 802         return JSValue::encode(jsNumber(node-&gt;value()));
 803     }
 804 
 805 #if ENABLE(JIT)
 806     static Ref&lt;Snippet&gt; checkSubClassSnippet()
 807     {
 808         Ref&lt;Snippet&gt; snippet = Snippet::create();
 809         snippet-&gt;numFPScratchRegisters = 1;
 810         snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 811             static const double value = 42.0;
 812             CCallHelpers::JumpList failureCases;
 813             // May use scratch registers.
 814             jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;value), params.fpScratch(0));
 815             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
 816             return failureCases;
 817         });
 818         return snippet;
 819     }
 820 #endif
 821 
 822 private:
 823     void finishCreation(VM&amp;, JSGlobalObject*);
 824 };
 825 
<span class="line-modified"> 826 static const DOMJIT::Signature DOMJITFunctionObjectSignature((uintptr_t)DOMJITFunctionObject::unsafeFunction, DOMJITFunctionObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);</span>
 827 
 828 void DOMJITFunctionObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 829 {
 830     Base::finishCreation(vm);
<span class="line-modified"> 831     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;func&quot;), 0, safeFunction, NoIntrinsic, &amp;DOMJITFunctionObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));</span>
 832 }
 833 
 834 class DOMJITCheckSubClassObject : public DOMJITNode {
 835 public:
 836     DOMJITCheckSubClassObject(VM&amp; vm, Structure* structure)
 837         : Base(vm, structure)
 838     {
 839     }
 840 
 841     DECLARE_INFO;
 842     typedef DOMJITNode Base;
 843     static const unsigned StructureFlags = Base::StructureFlags;
 844 
 845 
 846     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 847     {
 848         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 849     }
 850 
 851     static DOMJITCheckSubClassObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 852     {
<span class="line-modified"> 853         DOMJITCheckSubClassObject* object = new (NotNull, allocateCell&lt;DOMJITCheckSubClassObject&gt;(vm.heap, sizeof(DOMJITCheckSubClassObject))) DOMJITCheckSubClassObject(vm, structure);</span>
 854         object-&gt;finishCreation(vm, globalObject);
 855         return object;
 856     }
 857 
<span class="line-modified"> 858     static EncodedJSValue JSC_HOST_CALL safeFunction(ExecState* exec)</span>
 859     {
 860         VM&amp; vm = exec-&gt;vm();
 861         auto scope = DECLARE_THROW_SCOPE(vm);
 862 
 863         auto* thisObject = jsDynamicCast&lt;DOMJITCheckSubClassObject*&gt;(vm, exec-&gt;thisValue());
 864         if (!thisObject)
 865             return throwVMTypeError(exec, scope);
 866         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 867     }
 868 
<span class="line-modified"> 869     static EncodedJSValue JIT_OPERATION unsafeFunction(ExecState* exec, DOMJITNode* node)</span>
 870     {
 871         VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 872         NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 873         return JSValue::encode(jsNumber(node-&gt;value()));
 874     }
 875 
 876 private:
 877     void finishCreation(VM&amp;, JSGlobalObject*);
 878 };
 879 
<span class="line-modified"> 880 static const DOMJIT::Signature DOMJITCheckSubClassObjectSignature((uintptr_t)DOMJITCheckSubClassObject::unsafeFunction, DOMJITCheckSubClassObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);</span>
 881 
 882 void DOMJITCheckSubClassObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 883 {
 884     Base::finishCreation(vm);
<span class="line-modified"> 885     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;func&quot;), 0, safeFunction, NoIntrinsic, &amp;DOMJITCheckSubClassObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));</span>
 886 }
 887 
 888 class DOMJITGetterBaseJSObject : public DOMJITNode {
 889 public:
 890     DOMJITGetterBaseJSObject(VM&amp; vm, Structure* structure)
 891         : Base(vm, structure)
 892     {
 893     }
 894 
 895     DECLARE_INFO;
 896     using Base = DOMJITNode;
 897     static const unsigned StructureFlags = Base::StructureFlags;
 898 
 899     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 900     {
 901         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 902     }
 903 
 904     static DOMJITGetterBaseJSObject* create(VM&amp; vm, Structure* structure)
 905     {
<span class="line-modified"> 906         DOMJITGetterBaseJSObject* getter = new (NotNull, allocateCell&lt;DOMJITGetterBaseJSObject&gt;(vm.heap, sizeof(DOMJITGetterBaseJSObject))) DOMJITGetterBaseJSObject(vm, structure);</span>
 907         getter-&gt;finishCreation(vm);
 908         return getter;
 909     }
 910 
 911     class DOMJITAttribute : public DOMJIT::GetterSetter {
 912     public:
 913         constexpr DOMJITAttribute()
 914             : DOMJIT::GetterSetter(
 915                 DOMJITGetterBaseJSObject::customGetter,
 916 #if ENABLE(JIT)
 917                 &amp;callDOMGetter,
 918 #else
 919                 nullptr,
 920 #endif
 921                 SpecBytecodeTop)
 922         {
 923         }
 924 
 925 #if ENABLE(JIT)
 926         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)
 927         {
 928             VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 929             NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 930             JSObject* object = static_cast&lt;JSObject*&gt;(pointer);
 931             return JSValue::encode(object-&gt;getPrototypeDirect(vm));
 932         }
 933 
 934         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 935         {
 936             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 937             snippet-&gt;requireGlobalObject = false;
 938             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 939                 JSValueRegs results = params[0].jsValueRegs();
 940                 GPRReg dom = params[1].gpr();
 941                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, dom);
 942                 return CCallHelpers::JumpList();
 943 
 944             });
 945             return snippet;
 946         }
 947 #endif
 948     };
 949 
 950 private:
 951     void finishCreation(VM&amp;);
 952 
 953     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 954     {
 955         VM&amp; vm = exec-&gt;vm();
 956         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 957         RELEASE_ASSERT(thisObject);
 958         return JSValue::encode(thisObject-&gt;getPrototypeDirect(vm));
 959     }
 960 };
 961 
 962 static const DOMJITGetterBaseJSObject::DOMJITAttribute DOMJITGetterBaseJSObjectDOMJIT;
 963 
 964 void DOMJITGetterBaseJSObject::finishCreation(VM&amp; vm)
 965 {
 966     Base::finishCreation(vm);
 967     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterBaseJSObjectDOMJIT;
 968     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { JSObject::info(), domJIT });
<span class="line-modified"> 969     putDirectCustomAccessor(vm, Identifier::fromString(&amp;vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);</span>
 970 }
 971 
 972 class Message : public ThreadSafeRefCounted&lt;Message&gt; {
 973 public:
 974     Message(ArrayBufferContents&amp;&amp;, int32_t);
 975     ~Message();
 976 
 977     ArrayBufferContents&amp;&amp; releaseContents() { return WTFMove(m_contents); }
 978     int32_t index() const { return m_index; }
 979 
 980 private:
 981     ArrayBufferContents m_contents;
 982     int32_t m_index { 0 };
 983 };
 984 
 985 class JSTestCustomGetterSetter : public JSNonFinalObject {
 986 public:
 987     using Base = JSNonFinalObject;
 988     static const unsigned StructureFlags = Base::StructureFlags;
 989 
 990     JSTestCustomGetterSetter(VM&amp; vm, Structure* structure)
 991         : Base(vm, structure)
 992     { }
 993 
 994     static JSTestCustomGetterSetter* create(VM&amp; vm, JSGlobalObject*, Structure* structure)
 995     {
<span class="line-modified"> 996         JSTestCustomGetterSetter* result = new (NotNull, allocateCell&lt;JSTestCustomGetterSetter&gt;(vm.heap, sizeof(JSTestCustomGetterSetter))) JSTestCustomGetterSetter(vm, structure);</span>
 997         result-&gt;finishCreation(vm);
 998         return result;
 999     }
1000 
1001     void finishCreation(VM&amp;);
1002 
1003     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject)
1004     {
1005         return Structure::create(vm, globalObject, globalObject-&gt;objectPrototype(), TypeInfo(ObjectType, StructureFlags), info());
1006     }
1007 
1008     DECLARE_INFO;
1009 };
1010 
1011 
1012 static EncodedJSValue customGetAccessor(ExecState*, EncodedJSValue thisValue, PropertyName)
1013 {
1014     // Passed |this|
1015     return thisValue;
1016 }
1017 
1018 static EncodedJSValue customGetValue(ExecState* exec, EncodedJSValue slotValue, PropertyName)
1019 {
1020     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(exec-&gt;vm()));
1021     // Passed property holder.
1022     return slotValue;
1023 }
1024 
1025 static bool customSetAccessor(ExecState* exec, EncodedJSValue thisObject, EncodedJSValue encodedValue)
1026 {
1027     VM&amp; vm = exec-&gt;vm();
1028 
1029     JSValue value = JSValue::decode(encodedValue);
1030     RELEASE_ASSERT(value.isObject());
1031     JSObject* object = asObject(value);
1032     PutPropertySlot slot(object);
<span class="line-modified">1033     object-&gt;put(object, exec, Identifier::fromString(&amp;vm, &quot;result&quot;), JSValue::decode(thisObject), slot);</span>
1034 
1035     return true;
1036 }
1037 
1038 static bool customSetValue(ExecState* exec, EncodedJSValue slotValue, EncodedJSValue encodedValue)
1039 {
1040     VM&amp; vm = exec-&gt;vm();
1041 
1042     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(exec-&gt;vm()));
1043 
1044     JSValue value = JSValue::decode(encodedValue);
1045     RELEASE_ASSERT(value.isObject());
1046     JSObject* object = asObject(value);
1047     PutPropertySlot slot(object);
<span class="line-modified">1048     object-&gt;put(object, exec, Identifier::fromString(&amp;vm, &quot;result&quot;), JSValue::decode(slotValue), slot);</span>
1049 
1050     return true;
1051 }
1052 
1053 void JSTestCustomGetterSetter::finishCreation(VM&amp; vm)
1054 {
1055     Base::finishCreation(vm);
1056 
<span class="line-modified">1057     putDirectCustomAccessor(vm, Identifier::fromString(&amp;vm, &quot;customValue&quot;),</span>
1058         CustomGetterSetter::create(vm, customGetValue, customSetValue), 0);
<span class="line-modified">1059     putDirectCustomAccessor(vm, Identifier::fromString(&amp;vm, &quot;customAccessor&quot;),</span>
1060         CustomGetterSetter::create(vm, customGetAccessor, customSetAccessor), static_cast&lt;unsigned&gt;(PropertyAttribute::CustomAccessor));
1061 }
1062 
1063 const ClassInfo Element::s_info = { &quot;Element&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Element) };
1064 const ClassInfo Root::s_info = { &quot;Root&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Root) };
1065 const ClassInfo SimpleObject::s_info = { &quot;SimpleObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(SimpleObject) };
1066 const ClassInfo ImpureGetter::s_info = { &quot;ImpureGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ImpureGetter) };
1067 const ClassInfo CustomGetter::s_info = { &quot;CustomGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(CustomGetter) };
1068 const ClassInfo RuntimeArray::s_info = { &quot;RuntimeArray&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RuntimeArray) };
1069 #if ENABLE(JIT)
1070 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITNode::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITNode) };
1071 #else
1072 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITNode) };
1073 #endif
1074 const ClassInfo DOMJITGetter::s_info = { &quot;DOMJITGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetter) };
1075 const ClassInfo DOMJITGetterComplex::s_info = { &quot;DOMJITGetterComplex&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterComplex) };
1076 const ClassInfo DOMJITGetterBaseJSObject::s_info = { &quot;DOMJITGetterBaseJSObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterBaseJSObject) };
1077 #if ENABLE(JIT)
1078 const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITFunctionObject::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
1079 #else
</pre>
<hr />
<pre>
1099 
1100 #if ENABLE(WEBASSEMBLY)
1101 
1102 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(ExecState*);
1103 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(ExecState*);
1104 
1105 class WasmStreamingParser : public JSDestructibleObject {
1106 public:
1107     WasmStreamingParser(VM&amp; vm, Structure* structure)
1108         : Base(vm, structure)
1109         , m_info(Wasm::ModuleInformation::create())
1110         , m_streamingParser(m_info.get())
1111     {
1112     }
1113 
1114     using Base = JSDestructibleObject;
1115 
1116     static WasmStreamingParser* create(VM&amp; vm, JSGlobalObject* globalObject)
1117     {
1118         Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified">1119         WasmStreamingParser* result = new (NotNull, allocateCell&lt;WasmStreamingParser&gt;(vm.heap, sizeof(WasmStreamingParser))) WasmStreamingParser(vm, structure);</span>
1120         result-&gt;finishCreation(vm);
1121         return result;
1122     }
1123 
1124     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1125     {
1126         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1127     }
1128 
1129     Wasm::StreamingParser&amp; streamingParser() { return m_streamingParser; }
1130 
1131     void finishCreation(VM&amp; vm)
1132     {
1133         Base::finishCreation(vm);
1134 
1135         JSGlobalObject* globalObject = this-&gt;globalObject(vm);
<span class="line-modified">1136         putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;addBytes&quot;), 0, functionWasmStreamingParserAddBytes, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">1137         putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;finalize&quot;), 0, functionWasmStreamingParserFinalize, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
1138     }
1139 
1140     DECLARE_INFO;
1141 
1142     Ref&lt;Wasm::ModuleInformation&gt; m_info;
1143     Wasm::StreamingParser m_streamingParser;
1144 };
1145 
1146 const ClassInfo WasmStreamingParser::s_info = { &quot;WasmStreamingParser&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WasmStreamingParser) };
1147 
1148 EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(ExecState* exec)
1149 {
1150     VM&amp; vm = exec-&gt;vm();
1151     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
1152     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, exec-&gt;thisValue());
1153     if (!thisObject)
1154         RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(false)));
1155 
1156     auto data = getWasmBufferFromValue(exec, exec-&gt;argument(0));
1157     RETURN_IF_EXCEPTION(scope, encodedJSValue());
</pre>
<hr />
<pre>
1283             toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfPublicLength());
1284         }
1285     }
1286 
1287     if (!toFlush.size())
1288         return JSValue::encode(jsBoolean(false));
1289 
1290     for (void* ptr : toFlush)
1291         clflush(ptr);
1292     return JSValue::encode(jsBoolean(true));
1293 #else
1294     UNUSED_PARAM(exec);
1295     return JSValue::encode(jsBoolean(false));
1296 #endif
1297 }
1298 
1299 class CallerFrameJITTypeFunctor {
1300 public:
1301     CallerFrameJITTypeFunctor()
1302         : m_currentFrame(0)
<span class="line-modified">1303         , m_jitType(JITCode::None)</span>
1304     {
1305     }
1306 
1307     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
1308     {
1309         if (m_currentFrame++ &gt; 1) {
1310             m_jitType = visitor-&gt;codeBlock()-&gt;jitType();
1311             return StackVisitor::Done;
1312         }
1313         return StackVisitor::Continue;
1314     }
1315 
<span class="line-modified">1316     JITCode::JITType jitType() { return m_jitType; }</span>
1317 
1318 private:
1319     mutable unsigned m_currentFrame;
<span class="line-modified">1320     mutable JITCode::JITType m_jitType;</span>
1321 };
1322 
1323 static FunctionExecutable* getExecutableForFunction(JSValue theFunctionValue)
1324 {
1325     if (!theFunctionValue.isCell())
1326         return nullptr;
1327 
<span class="line-modified">1328     VM&amp; vm = *theFunctionValue.asCell()-&gt;vm();</span>
1329     JSFunction* theFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, theFunctionValue);
1330     if (!theFunction)
1331         return nullptr;
1332 
1333     FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm,
1334         theFunction-&gt;executable());
1335 
1336     return executable;
1337 }
1338 
1339 // Returns true if the current frame is a LLInt frame.
1340 // Usage: isLLInt = $vm.llintTrue()
1341 static EncodedJSValue JSC_HOST_CALL functionLLintTrue(ExecState* exec)
1342 {
1343     if (!exec)
1344         return JSValue::encode(jsUndefined());
1345     CallerFrameJITTypeFunctor functor;
1346     exec-&gt;iterate(functor);
<span class="line-modified">1347     return JSValue::encode(jsBoolean(functor.jitType() == JITCode::InterpreterThunk));</span>
1348 }
1349 
1350 // Returns true if the current frame is a baseline JIT frame.
1351 // Usage: isBaselineJIT = $vm.jitTrue()
1352 static EncodedJSValue JSC_HOST_CALL functionJITTrue(ExecState* exec)
1353 {
1354     if (!exec)
1355         return JSValue::encode(jsUndefined());
1356     CallerFrameJITTypeFunctor functor;
1357     exec-&gt;iterate(functor);
<span class="line-modified">1358     return JSValue::encode(jsBoolean(functor.jitType() == JITCode::BaselineJIT));</span>
1359 }
1360 
1361 // Set that the argument function should not be inlined.
1362 // Usage:
1363 // function f() { };
1364 // $vm.noInline(f);
1365 static EncodedJSValue JSC_HOST_CALL functionNoInline(ExecState* exec)
1366 {
1367     if (exec-&gt;argumentCount() &lt; 1)
1368         return JSValue::encode(jsUndefined());
1369 
1370     JSValue theFunctionValue = exec-&gt;uncheckedArgument(0);
1371 
1372     if (FunctionExecutable* executable = getExecutableForFunction(theFunctionValue))
1373         executable-&gt;setNeverInline(true);
1374 
1375     return JSValue::encode(jsUndefined());
1376 }
1377 
1378 // Runs a full GC synchronously.
1379 // Usage: $vm.gc()
1380 static EncodedJSValue JSC_HOST_CALL functionGC(ExecState* exec)
1381 {
1382     VMInspector::gc(exec);
1383     return JSValue::encode(jsUndefined());
1384 }
1385 
1386 // Runs the edenGC synchronously.
1387 // Usage: $vm.edenGC()
1388 static EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState* exec)
1389 {
1390     VMInspector::edenGC(exec);
1391     return JSValue::encode(jsUndefined());
1392 }
1393 









1394 // Gets a JSDollarVMCallFrame for a specified frame index.
1395 // Usage: var callFrame = $vm.callFrame(0) // frame 0 is the top frame.
1396 // Usage: var callFrame = $vm.callFrame() // implies frame 0 i.e. current frame.
1397 //
1398 // This gives you the ability to query the following:
1399 //    callFrame.valid; // false if we asked for a frame beyond the end of the stack, else true.
1400 //    callFrame.callee;
1401 //    callFrame.codeBlock;
1402 //    callFrame.unlinkedCodeBlock;
1403 //    callFrame.executable;
1404 //
1405 // Note: you cannot toString() a codeBlock, unlinkedCodeBlock, or executable because
1406 // there are internal objects and not a JS object. Hence, you cannot do string
1407 // concatenation with them.
1408 static EncodedJSValue JSC_HOST_CALL functionCallFrame(ExecState* exec)
1409 {
1410     unsigned frameNumber = 1;
1411     if (exec-&gt;argumentCount() &gt;= 1) {
1412         JSValue value = exec-&gt;uncheckedArgument(0);
1413         if (!value.isUInt32())
</pre>
<hr />
<pre>
1467     if (candidateCodeBlock &amp;&amp; VMInspector::isValidCodeBlock(exec, candidateCodeBlock))
1468         return candidateCodeBlock;
1469 
1470     if (candidateCodeBlock)
1471         dataLog(&quot;Invalid codeBlock: &quot;, RawPointer(candidateCodeBlock), &quot; &quot;, value, &quot;\n&quot;);
1472     else
1473         dataLog(&quot;Invalid codeBlock: &quot;, value, &quot;\n&quot;);
1474     return nullptr;
1475 }
1476 
1477 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(functionObj))
1478 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(codeBlockToken))
1479 // Note: you cannot toString() a codeBlock because it&#39;s an internal object and not
1480 // a JS object. Hence, you cannot do string concatenation with it.
1481 static EncodedJSValue JSC_HOST_CALL functionCodeBlockFor(ExecState* exec)
1482 {
1483     CodeBlock* codeBlock = codeBlockFromArg(exec);
1484     WTF::StringPrintStream stream;
1485     if (codeBlock) {
1486         stream.print(*codeBlock);
<span class="line-modified">1487         return JSValue::encode(jsString(exec, stream.toString()));</span>
1488     }
1489     return JSValue::encode(jsUndefined());
1490 }
1491 
1492 // Usage: $vm.dumpSourceFor(functionObj)
1493 // Usage: $vm.dumpSourceFor(codeBlockToken)
1494 static EncodedJSValue JSC_HOST_CALL functionDumpSourceFor(ExecState* exec)
1495 {
1496     CodeBlock* codeBlock = codeBlockFromArg(exec);
1497     if (codeBlock)
1498         codeBlock-&gt;dumpSource();
1499     return JSValue::encode(jsUndefined());
1500 }
1501 
1502 // Usage: $vm.dumpBytecodeFor(functionObj)
1503 // Usage: $vm.dumpBytecodeFor(codeBlock)
1504 static EncodedJSValue JSC_HOST_CALL functionDumpBytecodeFor(ExecState* exec)
1505 {
1506     CodeBlock* codeBlock = codeBlockFromArg(exec);
1507     if (codeBlock)
</pre>
<hr />
<pre>
1600 // Usage: $vm.dumpCell(cell)
1601 static EncodedJSValue JSC_HOST_CALL functionDumpCell(ExecState* exec)
1602 {
1603     JSValue value = exec-&gt;argument(0);
1604     if (!value.isCell())
1605         return encodedJSUndefined();
1606 
1607     VMInspector::dumpCellMemory(value.asCell());
1608     return encodedJSUndefined();
1609 }
1610 
1611 // Gets the dataLog dump of the indexingMode of the passed value.
1612 // Usage: $vm.print(&quot;indexingMode = &quot; + $vm.indexingMode(jsValue))
1613 static EncodedJSValue JSC_HOST_CALL functionIndexingMode(ExecState* exec)
1614 {
1615     if (!exec-&gt;argument(0).isObject())
1616         return encodedJSUndefined();
1617 
1618     WTF::StringPrintStream stream;
1619     stream.print(IndexingTypeDump(exec-&gt;uncheckedArgument(0).getObject()-&gt;indexingMode()));
<span class="line-modified">1620     return JSValue::encode(jsString(exec, stream.toString()));</span>
1621 }
1622 
1623 static EncodedJSValue JSC_HOST_CALL functionInlineCapacity(ExecState* exec)
1624 {
1625     VM&amp; vm = exec-&gt;vm();
1626     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0)))
1627         return JSValue::encode(jsNumber(object-&gt;structure(vm)-&gt;inlineCapacity()));
1628 
1629     return encodedJSUndefined();
1630 }
1631 
1632 // Gets the dataLog dump of a given JS value as a string.
1633 // Usage: $vm.print(&quot;value = &quot; + $vm.value(jsValue))
1634 static EncodedJSValue JSC_HOST_CALL functionValue(ExecState* exec)
1635 {
1636     WTF::StringPrintStream stream;
1637     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
1638         if (i)
1639             stream.print(&quot;, &quot;);
1640         stream.print(exec-&gt;uncheckedArgument(i));
1641     }
1642 
<span class="line-modified">1643     return JSValue::encode(jsString(exec, stream.toString()));</span>
1644 }
1645 
1646 // Gets the pid of the current process.
1647 // Usage: $vm.print(&quot;pid = &quot; + $vm.getpid())
1648 static EncodedJSValue JSC_HOST_CALL functionGetPID(ExecState*)
1649 {
1650     return JSValue::encode(jsNumber(getCurrentProcessID()));
1651 }
1652 
1653 // Make the globalObject have a bad time. Does nothing if the object is not a JSGlobalObject.
1654 // Usage: $vm.haveABadTime(globalObject)
1655 static EncodedJSValue JSC_HOST_CALL functionHaveABadTime(ExecState* exec)
1656 {
1657     VM&amp; vm = exec-&gt;vm();
1658     JSLockHolder lock(vm);
1659     JSValue objValue = exec-&gt;argument(0);
1660     if (!objValue.isObject())
1661         return JSValue::encode(jsBoolean(false));
1662 
1663     JSObject* obj = asObject(objValue.asCell());
</pre>
<hr />
<pre>
1704 static EncodedJSValue JSC_HOST_CALL functionCreateProxy(ExecState* exec)
1705 {
1706     VM&amp; vm = exec-&gt;vm();
1707     JSLockHolder lock(vm);
1708     JSValue target = exec-&gt;argument(0);
1709     if (!target.isObject())
1710         return JSValue::encode(jsUndefined());
1711     JSObject* jsTarget = asObject(target.asCell());
1712     Structure* structure = JSProxy::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsTarget-&gt;getPrototypeDirect(vm), ImpureProxyType);
1713     JSProxy* proxy = JSProxy::create(vm, structure, jsTarget);
1714     return JSValue::encode(proxy);
1715 }
1716 
1717 static EncodedJSValue JSC_HOST_CALL functionCreateRuntimeArray(ExecState* exec)
1718 {
1719     JSLockHolder lock(exec);
1720     RuntimeArray* array = RuntimeArray::create(exec);
1721     return JSValue::encode(array);
1722 }
1723 







1724 static EncodedJSValue JSC_HOST_CALL functionCreateImpureGetter(ExecState* exec)
1725 {
1726     VM&amp; vm = exec-&gt;vm();
1727     JSLockHolder lock(vm);
1728     JSValue target = exec-&gt;argument(0);
1729     JSObject* delegate = nullptr;
1730     if (target.isObject())
1731         delegate = asObject(target.asCell());
1732     Structure* structure = ImpureGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1733     ImpureGetter* result = ImpureGetter::create(vm, structure, delegate);
1734     return JSValue::encode(result);
1735 }
1736 
1737 static EncodedJSValue JSC_HOST_CALL functionCreateCustomGetterObject(ExecState* exec)
1738 {
1739     VM&amp; vm = exec-&gt;vm();
1740     JSLockHolder lock(vm);
1741     Structure* structure = CustomGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1742     CustomGetter* result = CustomGetter::create(vm, structure);
1743     return JSValue::encode(result);
</pre>
<hr />
<pre>
1822     if (UNLIKELY(!impureGetter)) {
1823         throwTypeError(exec, scope, &quot;argument is not an ImpureGetter&quot;_s);
1824         return encodedJSValue();
1825     }
1826     impureGetter-&gt;setDelegate(vm, asObject(delegate.asCell()));
1827     return JSValue::encode(jsUndefined());
1828 }
1829 
1830 static EncodedJSValue JSC_HOST_CALL functionCreateBuiltin(ExecState* exec)
1831 {
1832     VM&amp; vm = exec-&gt;vm();
1833     auto scope = DECLARE_THROW_SCOPE(vm);
1834 
1835     if (exec-&gt;argumentCount() &lt; 1 || !exec-&gt;argument(0).isString())
1836         return JSValue::encode(jsUndefined());
1837 
1838     String functionText = asString(exec-&gt;argument(0))-&gt;value(exec);
1839     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1840 
1841     const SourceCode&amp; source = makeSource(functionText, { });
<span class="line-modified">1842     JSFunction* func = JSFunction::create(vm, createBuiltinExecutable(vm, source, Identifier::fromString(&amp;vm, &quot;foo&quot;), ConstructorKind::None, ConstructAbility::CannotConstruct)-&gt;link(vm, source), exec-&gt;lexicalGlobalObject());</span>
1843 
1844     return JSValue::encode(func);
1845 }
1846 
1847 static EncodedJSValue JSC_HOST_CALL functionGetPrivateProperty(ExecState* exec)
1848 {
1849     VM&amp; vm = exec-&gt;vm();
1850     auto scope = DECLARE_THROW_SCOPE(vm);
1851 
1852     if (exec-&gt;argumentCount() &lt; 2 || !exec-&gt;argument(1).isString())
1853         return encodedJSUndefined();
1854 
1855     String str = asString(exec-&gt;argument(1))-&gt;value(exec);
1856 
<span class="line-modified">1857     SymbolImpl* symbol = vm.propertyNames-&gt;lookUpPrivateName(Identifier::fromString(exec, str));</span>
1858     if (!symbol)
1859         return throwVMError(exec, scope, &quot;Unknown private name.&quot;);
1860 
1861     RELEASE_AND_RETURN(scope, JSValue::encode(exec-&gt;argument(0).get(exec, symbol)));
1862 }
1863 
1864 static EncodedJSValue JSC_HOST_CALL functionCreateRoot(ExecState* exec)
1865 {
1866     VM&amp; vm = exec-&gt;vm();
1867     JSLockHolder lock(vm);
1868     return JSValue::encode(Root::create(vm, exec-&gt;lexicalGlobalObject()));
1869 }
1870 
1871 static EncodedJSValue JSC_HOST_CALL functionCreateElement(ExecState* exec)
1872 {
1873     VM&amp; vm = exec-&gt;vm();
1874     JSLockHolder lock(vm);
1875     auto scope = DECLARE_THROW_SCOPE(vm);
1876 
1877     Root* root = jsDynamicCast&lt;Root*&gt;(vm, exec-&gt;argument(0));
</pre>
<hr />
<pre>
2037     JSValue functionValue = exec-&gt;argument(0);
2038     RELEASE_ASSERT(functionValue.isFunction(vm));
2039     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2040 
2041     RELEASE_ASSERT(exec-&gt;argument(1).isString());
2042     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);
2043     String sourceCodeText = executable-&gt;source().view().toString();
2044     RELEASE_ASSERT(sourceCodeText.contains(substring));
2045     int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
2046 
2047     size_t executionCount = vm.controlFlowProfiler()-&gt;basicBlockExecutionCountAtTextOffset(offset, executable-&gt;sourceID(), vm);
2048     return JSValue::encode(JSValue(executionCount));
2049 }
2050 
2051 static EncodedJSValue JSC_HOST_CALL functionEnableExceptionFuzz(ExecState*)
2052 {
2053     Options::useExceptionFuzz() = true;
2054     return JSValue::encode(jsUndefined());
2055 }
2056 
<span class="line-modified">2057 static EncodedJSValue changeDebuggerModeWhenIdle(ExecState* exec, DebuggerMode mode)</span>
2058 {
<span class="line-modified">2059     bool newDebuggerMode = (mode == DebuggerOn);</span>
2060     if (Options::forceDebuggerBytecodeGeneration() == newDebuggerMode)
2061         return JSValue::encode(jsUndefined());
2062 
2063     VM* vm = &amp;exec-&gt;vm();
2064     vm-&gt;whenIdle([=] () {
2065         Options::forceDebuggerBytecodeGeneration() = newDebuggerMode;
2066         vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);
<span class="line-modified">2067         if (mode == DebuggerMode::DebuggerOn)</span>
2068             vm-&gt;ensureShadowChicken();
2069     });
2070     return JSValue::encode(jsUndefined());
2071 }
2072 
2073 static EncodedJSValue JSC_HOST_CALL functionEnableDebuggerModeWhenIdle(ExecState* exec)
2074 {
<span class="line-modified">2075     return changeDebuggerModeWhenIdle(exec, DebuggerOn);</span>
2076 }
2077 
2078 static EncodedJSValue JSC_HOST_CALL functionDisableDebuggerModeWhenIdle(ExecState* exec)
2079 {
<span class="line-modified">2080     return changeDebuggerModeWhenIdle(exec, DebuggerOff);</span>









2081 }
2082 
2083 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectCount(ExecState* exec)
2084 {
2085     return JSValue::encode(jsNumber(exec-&gt;vm().heap.globalObjectCount()));
2086 }
2087 
2088 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectForObject(ExecState* exec)
2089 {
2090     JSValue value = exec-&gt;argument(0);
2091     RELEASE_ASSERT(value.isObject());
2092     JSGlobalObject* globalObject = jsCast&lt;JSObject*&gt;(value)-&gt;globalObject(exec-&gt;vm());
2093     RELEASE_ASSERT(globalObject);
2094     return JSValue::encode(globalObject);
2095 }
2096 
2097 static EncodedJSValue JSC_HOST_CALL functionGetGetterSetter(ExecState* exec)
2098 {



2099     JSValue value = exec-&gt;argument(0);
2100     if (!value.isObject())
2101         return JSValue::encode(jsUndefined());
2102 
2103     JSValue property = exec-&gt;argument(1);
2104     if (!property.isString())
2105         return JSValue::encode(jsUndefined());
2106 



2107     PropertySlot slot(value, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">2108     value.getPropertySlot(exec, asString(property)-&gt;toIdentifier(exec), slot);</span>

2109 
2110     JSValue result;
2111     if (slot.isCacheableGetter())
2112         result = slot.getterSetter();
2113     else
2114         result = jsNull();
2115 
2116     return JSValue::encode(result);
2117 }
2118 
2119 static EncodedJSValue JSC_HOST_CALL functionLoadGetterFromGetterSetter(ExecState* exec)
2120 {
2121     VM&amp; vm = exec-&gt;vm();
2122     auto scope = DECLARE_THROW_SCOPE(vm);
2123 
2124     GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(vm, exec-&gt;argument(0));
2125     if (UNLIKELY(!getterSetter)) {
2126         throwTypeError(exec, scope, &quot;Invalid use of loadGetterFromGetterSetter test function: argument is not a GetterSetter&quot;_s);
2127         return encodedJSValue();
2128     }
</pre>
<hr />
<pre>
2144     VM&amp; vm = exec-&gt;vm();
2145     JSObject* a = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));
2146     JSObject* b = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(1));
2147     if (!a || !b)
2148         return JSValue::encode(jsNumber(PNaN));
2149 
2150     ptrdiff_t delta = bitwise_cast&lt;char*&gt;(a-&gt;butterfly()) - bitwise_cast&lt;char*&gt;(b-&gt;butterfly());
2151     if (delta &lt; 0)
2152         return JSValue::encode(jsNumber(PNaN));
2153     if (delta &gt; std::numeric_limits&lt;int32_t&gt;::max())
2154         return JSValue::encode(jsNumber(PNaN));
2155     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(delta)));
2156 }
2157 
2158 static EncodedJSValue JSC_HOST_CALL functionTotalGCTime(ExecState* exec)
2159 {
2160     VM&amp; vm = exec-&gt;vm();
2161     return JSValue::encode(jsNumber(vm.heap.totalGCTime().seconds()));
2162 }
2163 














2164 void JSDollarVM::finishCreation(VM&amp; vm)
2165 {
2166     Base::finishCreation(vm);
2167 
2168     JSGlobalObject* globalObject = this-&gt;globalObject(vm);
2169 
2170     auto addFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
2171         JSDollarVM::addFunction(vm, globalObject, name, function, arguments);
2172     };
2173     auto addConstructibleFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
2174         JSDollarVM::addConstructibleFunction(vm, globalObject, name, function, arguments);
2175     };
2176 
2177     addFunction(vm, &quot;abort&quot;, functionCrash, 0);
2178     addFunction(vm, &quot;crash&quot;, functionCrash, 0);
2179     addFunction(vm, &quot;breakpoint&quot;, functionBreakpoint, 0);
2180 
<span class="line-modified">2181     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;dfgTrue&quot;), 0, functionDFGTrue, DFGTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">2182     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;ftlTrue&quot;), 0, functionFTLTrue, FTLTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
2183 
<span class="line-modified">2184     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;cpuMfence&quot;), 0, functionCpuMfence, CPUMfenceIntrinsic, 0);</span>
<span class="line-modified">2185     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;cpuRdtsc&quot;), 0, functionCpuRdtsc, CPURdtscIntrinsic, 0);</span>
<span class="line-modified">2186     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;cpuCpuid&quot;), 0, functionCpuCpuid, CPUCpuidIntrinsic, 0);</span>
<span class="line-modified">2187     putDirectNativeFunction(vm, globalObject, Identifier::fromString(&amp;vm, &quot;cpuPause&quot;), 0, functionCpuPause, CPUPauseIntrinsic, 0);</span>
2188     addFunction(vm, &quot;cpuClflush&quot;, functionCpuClflush, 2);
2189 
2190     addFunction(vm, &quot;llintTrue&quot;, functionLLintTrue, 0);
2191     addFunction(vm, &quot;jitTrue&quot;, functionJITTrue, 0);
2192 
2193     addFunction(vm, &quot;noInline&quot;, functionNoInline, 1);
2194 
2195     addFunction(vm, &quot;gc&quot;, functionGC, 0);
2196     addFunction(vm, &quot;edenGC&quot;, functionEdenGC, 0);

2197 
2198     addFunction(vm, &quot;callFrame&quot;, functionCallFrame, 1);
2199     addFunction(vm, &quot;codeBlockFor&quot;, functionCodeBlockFor, 1);
2200     addFunction(vm, &quot;codeBlockForFrame&quot;, functionCodeBlockForFrame, 1);
2201     addFunction(vm, &quot;dumpSourceFor&quot;, functionDumpSourceFor, 1);
2202     addFunction(vm, &quot;dumpBytecodeFor&quot;, functionDumpBytecodeFor, 1);
2203 
2204     addFunction(vm, &quot;dataLog&quot;, functionDataLog, 1);
2205     addFunction(vm, &quot;print&quot;, functionPrint, 1);
2206     addFunction(vm, &quot;dumpCallFrame&quot;, functionDumpCallFrame, 0);
2207     addFunction(vm, &quot;dumpStack&quot;, functionDumpStack, 0);
2208     addFunction(vm, &quot;dumpRegisters&quot;, functionDumpRegisters, 1);
2209 
2210     addFunction(vm, &quot;dumpCell&quot;, functionDumpCell, 1);
2211 
2212     addFunction(vm, &quot;indexingMode&quot;, functionIndexingMode, 1);
2213     addFunction(vm, &quot;inlineCapacity&quot;, functionInlineCapacity, 1);
2214     addFunction(vm, &quot;value&quot;, functionValue, 1);
2215     addFunction(vm, &quot;getpid&quot;, functionGetPID, 0);
2216 
2217     addFunction(vm, &quot;haveABadTime&quot;, functionHaveABadTime, 1);
2218     addFunction(vm, &quot;isHavingABadTime&quot;, functionIsHavingABadTime, 1);
2219 
2220     addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
2221     addFunction(vm, &quot;createProxy&quot;, functionCreateProxy, 1);
2222     addFunction(vm, &quot;createRuntimeArray&quot;, functionCreateRuntimeArray, 0);

2223 
2224     addFunction(vm, &quot;createImpureGetter&quot;, functionCreateImpureGetter, 1);
2225     addFunction(vm, &quot;createCustomGetterObject&quot;, functionCreateCustomGetterObject, 0);
2226     addFunction(vm, &quot;createDOMJITNodeObject&quot;, functionCreateDOMJITNodeObject, 0);
2227     addFunction(vm, &quot;createDOMJITGetterObject&quot;, functionCreateDOMJITGetterObject, 0);
2228     addFunction(vm, &quot;createDOMJITGetterComplexObject&quot;, functionCreateDOMJITGetterComplexObject, 0);
2229     addFunction(vm, &quot;createDOMJITFunctionObject&quot;, functionCreateDOMJITFunctionObject, 0);
2230     addFunction(vm, &quot;createDOMJITCheckSubClassObject&quot;, functionCreateDOMJITCheckSubClassObject, 0);
2231     addFunction(vm, &quot;createDOMJITGetterBaseJSObject&quot;, functionCreateDOMJITGetterBaseJSObject, 0);
2232     addFunction(vm, &quot;createBuiltin&quot;, functionCreateBuiltin, 2);
2233 #if ENABLE(WEBASSEMBLY)
2234     addFunction(vm, &quot;createWasmStreamingParser&quot;, functionCreateWasmStreamingParser, 0);
2235 #endif
2236     addFunction(vm, &quot;getPrivateProperty&quot;, functionGetPrivateProperty, 2);
2237     addFunction(vm, &quot;setImpureGetterDelegate&quot;, functionSetImpureGetterDelegate, 2);
2238 
2239     addConstructibleFunction(vm, &quot;Root&quot;, functionCreateRoot, 0);
2240     addConstructibleFunction(vm, &quot;Element&quot;, functionCreateElement, 1);
2241     addFunction(vm, &quot;getElement&quot;, functionGetElement, 1);
2242 
</pre>
<hr />
<pre>
2244     addFunction(vm, &quot;getHiddenValue&quot;, functionGetHiddenValue, 1);
2245     addFunction(vm, &quot;setHiddenValue&quot;, functionSetHiddenValue, 2);
2246 
2247     addFunction(vm, &quot;shadowChickenFunctionsOnStack&quot;, functionShadowChickenFunctionsOnStack, 0);
2248     addFunction(vm, &quot;setGlobalConstRedeclarationShouldNotThrow&quot;, functionSetGlobalConstRedeclarationShouldNotThrow, 0);
2249 
2250     addFunction(vm, &quot;findTypeForExpression&quot;, functionFindTypeForExpression, 2);
2251     addFunction(vm, &quot;returnTypeFor&quot;, functionReturnTypeFor, 1);
2252 
2253     addFunction(vm, &quot;flattenDictionaryObject&quot;, functionFlattenDictionaryObject, 1);
2254 
2255     addFunction(vm, &quot;dumpBasicBlockExecutionRanges&quot;, functionDumpBasicBlockExecutionRanges , 0);
2256     addFunction(vm, &quot;hasBasicBlockExecuted&quot;, functionHasBasicBlockExecuted, 2);
2257     addFunction(vm, &quot;basicBlockExecutionCount&quot;, functionBasicBlockExecutionCount, 2);
2258 
2259     addFunction(vm, &quot;enableExceptionFuzz&quot;, functionEnableExceptionFuzz, 0);
2260 
2261     addFunction(vm, &quot;enableDebuggerModeWhenIdle&quot;, functionEnableDebuggerModeWhenIdle, 0);
2262     addFunction(vm, &quot;disableDebuggerModeWhenIdle&quot;, functionDisableDebuggerModeWhenIdle, 0);
2263 


2264     addFunction(vm, &quot;globalObjectCount&quot;, functionGlobalObjectCount, 0);
2265     addFunction(vm, &quot;globalObjectForObject&quot;, functionGlobalObjectForObject, 1);
2266 
2267     addFunction(vm, &quot;getGetterSetter&quot;, functionGetGetterSetter, 2);
2268     addFunction(vm, &quot;loadGetterFromGetterSetter&quot;, functionLoadGetterFromGetterSetter, 1);
2269     addFunction(vm, &quot;createCustomTestGetterSetter&quot;, functionCreateCustomTestGetterSetter, 1);
2270 
2271     addFunction(vm, &quot;deltaBetweenButterflies&quot;, functionDeltaBetweenButterflies, 2);
2272 
2273     addFunction(vm, &quot;totalGCTime&quot;, functionTotalGCTime, 0);




2274 }
2275 
2276 void JSDollarVM::addFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2277 {
<span class="line-modified">2278     Identifier identifier = Identifier::fromString(&amp;vm, name);</span>
2279     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function));
2280 }
2281 
2282 void JSDollarVM::addConstructibleFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2283 {
<span class="line-modified">2284     Identifier identifier = Identifier::fromString(&amp;vm, name);</span>
2285     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function, NoIntrinsic, function));
2286 }
2287 
2288 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;JSDollarVM.h&quot;
  28 
  29 #include &quot;BuiltinExecutableCreator.h&quot;
  30 #include &quot;CodeBlock.h&quot;
  31 #include &quot;DOMAttributeGetterSetter.h&quot;
  32 #include &quot;DOMJITGetterSetter.h&quot;
  33 #include &quot;FrameTracers.h&quot;
  34 #include &quot;FunctionCodeBlock.h&quot;
  35 #include &quot;GetterSetter.h&quot;
  36 #include &quot;JSArray.h&quot;
  37 #include &quot;JSArrayBuffer.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;JSFunction.h&quot;
  40 #include &quot;JSONObject.h&quot;
  41 #include &quot;JSProxy.h&quot;
  42 #include &quot;JSString.h&quot;
<span class="line-added">  43 #include &quot;Parser.h&quot;</span>
  44 #include &quot;ShadowChicken.h&quot;
  45 #include &quot;Snippet.h&quot;
  46 #include &quot;SnippetParams.h&quot;
  47 #include &quot;TypeProfiler.h&quot;
  48 #include &quot;TypeProfilerLog.h&quot;
  49 #include &quot;VMInspector.h&quot;
<span class="line-added">  50 #include &quot;WasmCapabilities.h&quot;</span>
  51 #include &lt;wtf/Atomics.h&gt;
  52 #include &lt;wtf/DataLog.h&gt;
  53 #include &lt;wtf/ProcessID.h&gt;
  54 #include &lt;wtf/StringPrintStream.h&gt;
  55 
  56 #if ENABLE(WEBASSEMBLY)
  57 #include &quot;JSWebAssemblyHelpers.h&quot;
  58 #include &quot;WasmStreamingParser.h&quot;
  59 #endif
  60 
  61 using namespace JSC;
  62 
  63 namespace {
  64 
  65 class JSDollarVMCallFrame : public JSDestructibleObject {
  66     using Base = JSDestructibleObject;
  67 public:
  68     JSDollarVMCallFrame(VM&amp; vm, Structure* structure)
  69         : Base(vm, structure)
  70     { }
  71 
  72     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  73     {
  74         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  75     }
  76 
  77     static JSDollarVMCallFrame* create(ExecState* exec, unsigned requestedFrameIndex)
  78     {
  79         VM&amp; vm = exec-&gt;vm();
  80         JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
  81         Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified">  82         JSDollarVMCallFrame* frame = new (NotNull, allocateCell&lt;JSDollarVMCallFrame&gt;(vm.heap)) JSDollarVMCallFrame(vm, structure);</span>
  83         frame-&gt;finishCreation(vm, exec, requestedFrameIndex);
  84         return frame;
  85     }
  86 
  87     void finishCreation(VM&amp; vm, CallFrame* frame, unsigned requestedFrameIndex)
  88     {
  89         Base::finishCreation(vm);
  90 
  91         auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
  92             JSDollarVMCallFrame::addProperty(vm, name, value);
  93         };
  94 
  95         unsigned frameIndex = 0;
  96         bool isValid = false;
  97         frame-&gt;iterate([&amp;] (StackVisitor&amp; visitor) {
  98 
  99             if (frameIndex++ != requestedFrameIndex)
 100                 return StackVisitor::Continue;
 101 
<span class="line-modified"> 102             addProperty(vm, &quot;name&quot;, jsString(vm, visitor-&gt;functionName()));</span>
 103 
 104             if (visitor-&gt;callee().isCell())
 105                 addProperty(vm, &quot;callee&quot;, visitor-&gt;callee().asCell());
 106 
 107             CodeBlock* codeBlock = visitor-&gt;codeBlock();
 108             if (codeBlock) {
 109                 addProperty(vm, &quot;codeBlock&quot;, codeBlock);
 110                 addProperty(vm, &quot;unlinkedCodeBlock&quot;, codeBlock-&gt;unlinkedCodeBlock());
 111                 addProperty(vm, &quot;executable&quot;, codeBlock-&gt;ownerExecutable());
 112             }
 113             isValid = true;
 114 
 115             return StackVisitor::Done;
 116         });
 117 
 118         addProperty(vm, &quot;valid&quot;, jsBoolean(isValid));
 119     }
 120 
 121     DECLARE_INFO;
 122 
 123 private:
 124     void addProperty(VM&amp; vm, const char* name, JSValue value)
 125     {
<span class="line-modified"> 126         Identifier identifier = Identifier::fromString(vm, name);</span>
 127         putDirect(vm, identifier, value);
 128     }
 129 };
 130 
 131 const ClassInfo JSDollarVMCallFrame::s_info = { &quot;CallFrame&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVMCallFrame) };
 132 
 133 class ElementHandleOwner;
 134 class Root;
 135 
 136 class Element : public JSNonFinalObject {
 137 public:
 138     Element(VM&amp; vm, Structure* structure)
 139         : Base(vm, structure)
 140     {
 141     }
 142 
 143     typedef JSNonFinalObject Base;
 144 
 145     Root* root() const { return m_root.get(); }
 146     void setRoot(VM&amp; vm, Root* root) { m_root.set(vm, this, root); }
 147 
 148     static Element* create(VM&amp; vm, JSGlobalObject* globalObject, Root* root)
 149     {
 150         Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified"> 151         Element* element = new (NotNull, allocateCell&lt;Element&gt;(vm.heap)) Element(vm, structure);</span>
 152         element-&gt;finishCreation(vm, root);
 153         return element;
 154     }
 155 
 156     void finishCreation(VM&amp;, Root*);
 157 
 158     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 159     {
 160         Element* thisObject = jsCast&lt;Element*&gt;(cell);
 161         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 162         Base::visitChildren(thisObject, visitor);
 163         visitor.append(thisObject-&gt;m_root);
 164     }
 165 
 166     static ElementHandleOwner* handleOwner();
 167 
 168     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 169     {
 170         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 171     }
 172 
 173     DECLARE_INFO;
 174 
 175 private:
 176     WriteBarrier&lt;Root&gt; m_root;
 177 };
 178 
 179 class ElementHandleOwner : public WeakHandleOwner {
<span class="line-added"> 180     WTF_MAKE_FAST_ALLOCATED;</span>
 181 public:
 182     bool isReachableFromOpaqueRoots(Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason) override
 183     {
 184         if (UNLIKELY(reason))
 185             *reason = &quot;JSC::Element is opaque root&quot;;
 186         Element* element = jsCast&lt;Element*&gt;(handle.slot()-&gt;asCell());
 187         return visitor.containsOpaqueRoot(element-&gt;root());
 188     }
 189 };
 190 
 191 class Root : public JSDestructibleObject {
 192 public:
 193     Root(VM&amp; vm, Structure* structure)
 194         : Base(vm, structure)
 195     {
 196     }
 197 
 198     Element* element()
 199     {
 200         return m_element.get();
 201     }
 202 
 203     void setElement(Element* element)
 204     {
 205         Weak&lt;Element&gt; newElement(element, Element::handleOwner());
 206         m_element.swap(newElement);
 207     }
 208 
 209     static Root* create(VM&amp; vm, JSGlobalObject* globalObject)
 210     {
 211         Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified"> 212         Root* root = new (NotNull, allocateCell&lt;Root&gt;(vm.heap)) Root(vm, structure);</span>
 213         root-&gt;finishCreation(vm);
 214         return root;
 215     }
 216 
 217     typedef JSDestructibleObject Base;
 218 
 219     DECLARE_INFO;
 220 
 221     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 222     {
 223         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 224     }
 225 
 226     static void visitChildren(JSCell* thisObject, SlotVisitor&amp; visitor)
 227     {
<span class="line-added"> 228         ASSERT_GC_OBJECT_INHERITS(thisObject, info());</span>
 229         Base::visitChildren(thisObject, visitor);
 230         visitor.addOpaqueRoot(thisObject);
 231     }
 232 
 233 private:
 234     Weak&lt;Element&gt; m_element;
 235 };
 236 
 237 class SimpleObject : public JSNonFinalObject {
 238 public:
 239     SimpleObject(VM&amp; vm, Structure* structure)
 240         : Base(vm, structure)
 241     {
 242     }
 243 
 244     typedef JSNonFinalObject Base;
 245     static const bool needsDestruction = false;
 246 
 247     static SimpleObject* create(VM&amp; vm, JSGlobalObject* globalObject)
 248     {
 249         Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified"> 250         SimpleObject* simpleObject = new (NotNull, allocateCell&lt;SimpleObject&gt;(vm.heap)) SimpleObject(vm, structure);</span>
 251         simpleObject-&gt;finishCreation(vm);
 252         return simpleObject;
 253     }
 254 
 255     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 256     {
 257         SimpleObject* thisObject = jsCast&lt;SimpleObject*&gt;(cell);
 258         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 259         Base::visitChildren(thisObject, visitor);
 260         visitor.append(thisObject-&gt;m_hiddenValue);
 261     }
 262 
 263     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 264     {
 265         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 266     }
 267 
 268     JSValue hiddenValue()
 269     {
 270         return m_hiddenValue.get();
</pre>
<hr />
<pre>
 283 };
 284 
 285 class ImpureGetter : public JSNonFinalObject {
 286 public:
 287     ImpureGetter(VM&amp; vm, Structure* structure)
 288         : Base(vm, structure)
 289     {
 290     }
 291 
 292     DECLARE_INFO;
 293     typedef JSNonFinalObject Base;
 294     static const unsigned StructureFlags = Base::StructureFlags | JSC::GetOwnPropertySlotIsImpure | JSC::OverridesGetOwnPropertySlot;
 295 
 296     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 297     {
 298         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 299     }
 300 
 301     static ImpureGetter* create(VM&amp; vm, Structure* structure, JSObject* delegate)
 302     {
<span class="line-modified"> 303         ImpureGetter* getter = new (NotNull, allocateCell&lt;ImpureGetter&gt;(vm.heap)) ImpureGetter(vm, structure);</span>
 304         getter-&gt;finishCreation(vm, delegate);
 305         return getter;
 306     }
 307 
 308     void finishCreation(VM&amp; vm, JSObject* delegate)
 309     {
 310         Base::finishCreation(vm);
 311         if (delegate)
 312             m_delegate.set(vm, this, delegate);
 313     }
 314 
 315     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName name, PropertySlot&amp; slot)
 316     {
 317         VM&amp; vm = exec-&gt;vm();
 318         auto scope = DECLARE_THROW_SCOPE(vm);
 319         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(object);
 320 
 321         if (thisObject-&gt;m_delegate) {
 322             if (thisObject-&gt;m_delegate-&gt;getPropertySlot(exec, name, slot))
 323                 return true;
 324             RETURN_IF_EXCEPTION(scope, false);
 325         }
 326 
 327         return Base::getOwnPropertySlot(object, exec, name, slot);
 328     }
 329 
 330     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 331     {
<span class="line-added"> 332         ASSERT_GC_OBJECT_INHERITS(cell, info());</span>
 333         Base::visitChildren(cell, visitor);
 334         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(cell);
 335         visitor.append(thisObject-&gt;m_delegate);
 336     }
 337 
 338     void setDelegate(VM&amp; vm, JSObject* delegate)
 339     {
 340         m_delegate.set(vm, this, delegate);
 341     }
 342 
 343 private:
 344     WriteBarrier&lt;JSObject&gt; m_delegate;
 345 };
 346 
 347 class CustomGetter : public JSNonFinalObject {
 348 public:
 349     CustomGetter(VM&amp; vm, Structure* structure)
 350         : Base(vm, structure)
 351     {
 352     }
 353 
 354     DECLARE_INFO;
 355     typedef JSNonFinalObject Base;
 356     static const unsigned StructureFlags = Base::StructureFlags | JSC::OverridesGetOwnPropertySlot;
 357 
 358     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 359     {
 360         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 361     }
 362 
 363     static CustomGetter* create(VM&amp; vm, Structure* structure)
 364     {
<span class="line-modified"> 365         CustomGetter* getter = new (NotNull, allocateCell&lt;CustomGetter&gt;(vm.heap)) CustomGetter(vm, structure);</span>
 366         getter-&gt;finishCreation(vm);
 367         return getter;
 368     }
 369 
 370     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 371     {
<span class="line-added"> 372         VM&amp; vm = exec-&gt;vm();</span>
 373         CustomGetter* thisObject = jsCast&lt;CustomGetter*&gt;(object);
<span class="line-modified"> 374         if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetter&quot;))) {</span>
 375             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;customGetter);
 376             return true;
 377         }
 378 
<span class="line-modified"> 379         if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetterAccessor&quot;))) {</span>
 380             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::CustomAccessor, thisObject-&gt;customGetterAcessor);
 381             return true;
 382         }
 383 
 384         return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);
 385     }
 386 
 387 private:
 388     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 389     {
 390         VM&amp; vm = exec-&gt;vm();
 391         auto scope = DECLARE_THROW_SCOPE(vm);
 392 
 393         CustomGetter* thisObject = jsDynamicCast&lt;CustomGetter*&gt;(vm, JSValue::decode(thisValue));
 394         if (!thisObject)
 395             return throwVMTypeError(exec, scope);
<span class="line-modified"> 396         bool shouldThrow = thisObject-&gt;get(exec, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(exec);</span>
 397         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 398         if (shouldThrow)
 399             return throwVMTypeError(exec, scope);
 400         return JSValue::encode(jsNumber(100));
 401     }
 402 
 403     static EncodedJSValue customGetterAcessor(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 404     {
 405         VM&amp; vm = exec-&gt;vm();
 406         auto scope = DECLARE_THROW_SCOPE(vm);
 407 
 408         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 409         if (!thisObject)
 410             return throwVMTypeError(exec, scope);
<span class="line-modified"> 411         bool shouldThrow = thisObject-&gt;get(exec, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(exec);</span>
 412         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 413         if (shouldThrow)
 414             return throwVMTypeError(exec, scope);
 415         return JSValue::encode(jsNumber(100));
 416     }
 417 };
 418 
 419 class RuntimeArray : public JSArray {
 420 public:
 421     typedef JSArray Base;
 422     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | OverridesGetPropertyNames;
 423 
 424     static RuntimeArray* create(ExecState* exec)
 425     {
 426         VM&amp; vm = exec-&gt;vm();
 427         JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 428         Structure* structure = createStructure(vm, globalObject, createPrototype(vm, globalObject));
 429         RuntimeArray* runtimeArray = new (NotNull, allocateCell&lt;RuntimeArray&gt;(vm.heap)) RuntimeArray(exec, structure);
 430         runtimeArray-&gt;finishCreation(exec);
 431         vm.heap.addFinalizer(runtimeArray, destroy);
</pre>
<hr />
<pre>
 539     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 540     {
 541         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 542     }
 543 
 544 #if ENABLE(JIT)
 545     static Ref&lt;Snippet&gt; checkSubClassSnippet()
 546     {
 547         Ref&lt;Snippet&gt; snippet = Snippet::create();
 548         snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 549             CCallHelpers::JumpList failureCases;
 550             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
 551             return failureCases;
 552         });
 553         return snippet;
 554     }
 555 #endif
 556 
 557     static DOMJITNode* create(VM&amp; vm, Structure* structure)
 558     {
<span class="line-modified"> 559         DOMJITNode* getter = new (NotNull, allocateCell&lt;DOMJITNode&gt;(vm.heap)) DOMJITNode(vm, structure);</span>
 560         getter-&gt;finishCreation(vm);
 561         return getter;
 562     }
 563 
 564     int32_t value() const
 565     {
 566         return m_value;
 567     }
 568 
 569     static ptrdiff_t offsetOfValue() { return OBJECT_OFFSETOF(DOMJITNode, m_value); }
 570 
 571 private:
 572     int32_t m_value { 42 };
 573 };
 574 
 575 class DOMJITGetter : public DOMJITNode {
 576 public:
 577     DOMJITGetter(VM&amp; vm, Structure* structure)
 578         : Base(vm, structure)
 579     {
 580     }
 581 
 582     DECLARE_INFO;
 583     typedef DOMJITNode Base;
 584     static const unsigned StructureFlags = Base::StructureFlags;
 585 
 586     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 587     {
 588         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 589     }
 590 
 591     static DOMJITGetter* create(VM&amp; vm, Structure* structure)
 592     {
<span class="line-modified"> 593         DOMJITGetter* getter = new (NotNull, allocateCell&lt;DOMJITGetter&gt;(vm.heap)) DOMJITGetter(vm, structure);</span>
 594         getter-&gt;finishCreation(vm);
 595         return getter;
 596     }
 597 
 598     class DOMJITAttribute : public DOMJIT::GetterSetter {
 599     public:
 600         constexpr DOMJITAttribute()
 601             : DOMJIT::GetterSetter(
 602                 DOMJITGetter::customGetter,
 603 #if ENABLE(JIT)
 604                 &amp;callDOMGetter,
 605 #else
 606                 nullptr,
 607 #endif
 608                 SpecInt32Only)
 609         {
 610         }
 611 
 612 #if ENABLE(JIT)
 613         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)
 614         {
 615             VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 616             NativeCallFrameTracer tracer(vm, exec);</span>
 617             return JSValue::encode(jsNumber(static_cast&lt;DOMJITGetter*&gt;(pointer)-&gt;value()));
 618         }
 619 
 620         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 621         {
 622             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 623             snippet-&gt;requireGlobalObject = false;
 624             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 625                 JSValueRegs results = params[0].jsValueRegs();
 626                 GPRReg dom = params[1].gpr();
 627                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, dom);
 628                 return CCallHelpers::JumpList();
 629 
 630             });
 631             return snippet;
 632         }
 633 #endif
 634     };
 635 
 636 private:
 637     void finishCreation(VM&amp;);
 638 
 639     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 640     {
 641         VM&amp; vm = exec-&gt;vm();
 642         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, JSValue::decode(thisValue));
 643         ASSERT(thisObject);
 644         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 645     }
 646 };
 647 
 648 static const DOMJITGetter::DOMJITAttribute DOMJITGetterDOMJIT;
 649 
 650 void DOMJITGetter::finishCreation(VM&amp; vm)
 651 {
 652     Base::finishCreation(vm);
 653     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterDOMJIT;
 654     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITNode::info(), domJIT });
<span class="line-modified"> 655     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);</span>
 656 }
 657 
 658 class DOMJITGetterComplex : public DOMJITNode {
 659 public:
 660     DOMJITGetterComplex(VM&amp; vm, Structure* structure)
 661         : Base(vm, structure)
 662     {
 663     }
 664 
 665     DECLARE_INFO;
 666     typedef DOMJITNode Base;
 667     static const unsigned StructureFlags = Base::StructureFlags;
 668 
 669     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 670     {
 671         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 672     }
 673 
 674     static DOMJITGetterComplex* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 675     {
<span class="line-modified"> 676         DOMJITGetterComplex* getter = new (NotNull, allocateCell&lt;DOMJITGetterComplex&gt;(vm.heap)) DOMJITGetterComplex(vm, structure);</span>
 677         getter-&gt;finishCreation(vm, globalObject);
 678         return getter;
 679     }
 680 
 681     class DOMJITAttribute : public DOMJIT::GetterSetter {
 682     public:
 683         constexpr DOMJITAttribute()
 684             : DOMJIT::GetterSetter(
 685                 DOMJITGetterComplex::customGetter,
 686 #if ENABLE(JIT)
 687                 &amp;callDOMGetter,
 688 #else
 689                 nullptr,
 690 #endif
 691                 SpecInt32Only)
 692         {
 693         }
 694 
 695 #if ENABLE(JIT)
 696         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)
 697         {
 698             VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 699             NativeCallFrameTracer tracer(vm, exec);</span>
 700             auto scope = DECLARE_THROW_SCOPE(vm);
 701             auto* object = static_cast&lt;DOMJITNode*&gt;(pointer);
 702             auto* domjitGetterComplex = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, object);
 703             if (domjitGetterComplex) {
 704                 if (domjitGetterComplex-&gt;m_enableException)
 705                     return JSValue::encode(throwException(exec, scope, createError(exec, &quot;DOMJITGetterComplex slow call exception&quot;_s)));
 706             }
 707             return JSValue::encode(jsNumber(object-&gt;value()));
 708         }
 709 
 710         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 711         {
 712             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 713             static_assert(GPRInfo::numberOfRegisters &gt;= 4, &quot;Number of registers should be larger or equal to 4.&quot;);
 714             unsigned numGPScratchRegisters = GPRInfo::numberOfRegisters - 4;
 715             snippet-&gt;numGPScratchRegisters = numGPScratchRegisters;
 716             snippet-&gt;numFPScratchRegisters = 3;
 717             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 718                 JSValueRegs results = params[0].jsValueRegs();
 719                 GPRReg domGPR = params[1].gpr();
</pre>
<hr />
<pre>
 745         VM&amp; vm = exec-&gt;vm();
 746         auto scope = DECLARE_THROW_SCOPE(vm);
 747 
 748         auto* thisObject = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, JSValue::decode(thisValue));
 749         ASSERT(thisObject);
 750         if (thisObject-&gt;m_enableException)
 751             return JSValue::encode(throwException(exec, scope, createError(exec, &quot;DOMJITGetterComplex slow call exception&quot;_s)));
 752         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 753     }
 754 
 755     bool m_enableException { false };
 756 };
 757 
 758 static const DOMJITGetterComplex::DOMJITAttribute DOMJITGetterComplexDOMJIT;
 759 
 760 void DOMJITGetterComplex::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 761 {
 762     Base::finishCreation(vm);
 763     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterComplexDOMJIT;
 764     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITGetterComplex::info(), domJIT });
<span class="line-modified"> 765     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);</span>
<span class="line-modified"> 766     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;enableException&quot;), 0, functionEnableException, NoIntrinsic, 0);</span>
 767 }
 768 
 769 class DOMJITFunctionObject : public DOMJITNode {
 770 public:
 771     DOMJITFunctionObject(VM&amp; vm, Structure* structure)
 772         : Base(vm, structure)
 773     {
 774     }
 775 
 776     DECLARE_INFO;
 777     typedef DOMJITNode Base;
 778     static const unsigned StructureFlags = Base::StructureFlags;
 779 
 780 
 781     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 782     {
 783         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 784     }
 785 
 786     static DOMJITFunctionObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 787     {
<span class="line-modified"> 788         DOMJITFunctionObject* object = new (NotNull, allocateCell&lt;DOMJITFunctionObject&gt;(vm.heap)) DOMJITFunctionObject(vm, structure);</span>
 789         object-&gt;finishCreation(vm, globalObject);
 790         return object;
 791     }
 792 
<span class="line-modified"> 793     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(ExecState* exec)</span>
 794     {
 795         VM&amp; vm = exec-&gt;vm();
 796         auto scope = DECLARE_THROW_SCOPE(vm);
 797 
 798         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, exec-&gt;thisValue());
 799         if (!thisObject)
 800             return throwVMTypeError(exec, scope);
 801         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 802     }
 803 
<span class="line-modified"> 804     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(ExecState* exec, DOMJITNode* node)</span>
 805     {
 806         VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 807         NativeCallFrameTracer tracer(vm, exec);</span>
 808         return JSValue::encode(jsNumber(node-&gt;value()));
 809     }
 810 
 811 #if ENABLE(JIT)
 812     static Ref&lt;Snippet&gt; checkSubClassSnippet()
 813     {
 814         Ref&lt;Snippet&gt; snippet = Snippet::create();
 815         snippet-&gt;numFPScratchRegisters = 1;
 816         snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 817             static const double value = 42.0;
 818             CCallHelpers::JumpList failureCases;
 819             // May use scratch registers.
 820             jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;value), params.fpScratch(0));
 821             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
 822             return failureCases;
 823         });
 824         return snippet;
 825     }
 826 #endif
 827 
 828 private:
 829     void finishCreation(VM&amp;, JSGlobalObject*);
 830 };
 831 
<span class="line-modified"> 832 static const DOMJIT::Signature DOMJITFunctionObjectSignature(DOMJITFunctionObject::functionWithoutTypeCheck, DOMJITFunctionObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);</span>
 833 
 834 void DOMJITFunctionObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 835 {
 836     Base::finishCreation(vm);
<span class="line-modified"> 837     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITFunctionObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));</span>
 838 }
 839 
 840 class DOMJITCheckSubClassObject : public DOMJITNode {
 841 public:
 842     DOMJITCheckSubClassObject(VM&amp; vm, Structure* structure)
 843         : Base(vm, structure)
 844     {
 845     }
 846 
 847     DECLARE_INFO;
 848     typedef DOMJITNode Base;
 849     static const unsigned StructureFlags = Base::StructureFlags;
 850 
 851 
 852     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 853     {
 854         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 855     }
 856 
 857     static DOMJITCheckSubClassObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 858     {
<span class="line-modified"> 859         DOMJITCheckSubClassObject* object = new (NotNull, allocateCell&lt;DOMJITCheckSubClassObject&gt;(vm.heap)) DOMJITCheckSubClassObject(vm, structure);</span>
 860         object-&gt;finishCreation(vm, globalObject);
 861         return object;
 862     }
 863 
<span class="line-modified"> 864     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(ExecState* exec)</span>
 865     {
 866         VM&amp; vm = exec-&gt;vm();
 867         auto scope = DECLARE_THROW_SCOPE(vm);
 868 
 869         auto* thisObject = jsDynamicCast&lt;DOMJITCheckSubClassObject*&gt;(vm, exec-&gt;thisValue());
 870         if (!thisObject)
 871             return throwVMTypeError(exec, scope);
 872         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 873     }
 874 
<span class="line-modified"> 875     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(ExecState* exec, DOMJITNode* node)</span>
 876     {
 877         VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 878         NativeCallFrameTracer tracer(vm, exec);</span>
 879         return JSValue::encode(jsNumber(node-&gt;value()));
 880     }
 881 
 882 private:
 883     void finishCreation(VM&amp;, JSGlobalObject*);
 884 };
 885 
<span class="line-modified"> 886 static const DOMJIT::Signature DOMJITCheckSubClassObjectSignature(DOMJITCheckSubClassObject::functionWithoutTypeCheck, DOMJITCheckSubClassObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);</span>
 887 
 888 void DOMJITCheckSubClassObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 889 {
 890     Base::finishCreation(vm);
<span class="line-modified"> 891     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITCheckSubClassObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));</span>
 892 }
 893 
 894 class DOMJITGetterBaseJSObject : public DOMJITNode {
 895 public:
 896     DOMJITGetterBaseJSObject(VM&amp; vm, Structure* structure)
 897         : Base(vm, structure)
 898     {
 899     }
 900 
 901     DECLARE_INFO;
 902     using Base = DOMJITNode;
 903     static const unsigned StructureFlags = Base::StructureFlags;
 904 
 905     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 906     {
 907         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 908     }
 909 
 910     static DOMJITGetterBaseJSObject* create(VM&amp; vm, Structure* structure)
 911     {
<span class="line-modified"> 912         DOMJITGetterBaseJSObject* getter = new (NotNull, allocateCell&lt;DOMJITGetterBaseJSObject&gt;(vm.heap)) DOMJITGetterBaseJSObject(vm, structure);</span>
 913         getter-&gt;finishCreation(vm);
 914         return getter;
 915     }
 916 
 917     class DOMJITAttribute : public DOMJIT::GetterSetter {
 918     public:
 919         constexpr DOMJITAttribute()
 920             : DOMJIT::GetterSetter(
 921                 DOMJITGetterBaseJSObject::customGetter,
 922 #if ENABLE(JIT)
 923                 &amp;callDOMGetter,
 924 #else
 925                 nullptr,
 926 #endif
 927                 SpecBytecodeTop)
 928         {
 929         }
 930 
 931 #if ENABLE(JIT)
 932         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)
 933         {
 934             VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 935             NativeCallFrameTracer tracer(vm, exec);</span>
 936             JSObject* object = static_cast&lt;JSObject*&gt;(pointer);
 937             return JSValue::encode(object-&gt;getPrototypeDirect(vm));
 938         }
 939 
 940         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 941         {
 942             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 943             snippet-&gt;requireGlobalObject = false;
 944             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {
 945                 JSValueRegs results = params[0].jsValueRegs();
 946                 GPRReg dom = params[1].gpr();
 947                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, dom);
 948                 return CCallHelpers::JumpList();
 949 
 950             });
 951             return snippet;
 952         }
 953 #endif
 954     };
 955 
 956 private:
 957     void finishCreation(VM&amp;);
 958 
 959     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 960     {
 961         VM&amp; vm = exec-&gt;vm();
 962         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 963         RELEASE_ASSERT(thisObject);
 964         return JSValue::encode(thisObject-&gt;getPrototypeDirect(vm));
 965     }
 966 };
 967 
 968 static const DOMJITGetterBaseJSObject::DOMJITAttribute DOMJITGetterBaseJSObjectDOMJIT;
 969 
 970 void DOMJITGetterBaseJSObject::finishCreation(VM&amp; vm)
 971 {
 972     Base::finishCreation(vm);
 973     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterBaseJSObjectDOMJIT;
 974     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { JSObject::info(), domJIT });
<span class="line-modified"> 975     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);</span>
 976 }
 977 
 978 class Message : public ThreadSafeRefCounted&lt;Message&gt; {
 979 public:
 980     Message(ArrayBufferContents&amp;&amp;, int32_t);
 981     ~Message();
 982 
 983     ArrayBufferContents&amp;&amp; releaseContents() { return WTFMove(m_contents); }
 984     int32_t index() const { return m_index; }
 985 
 986 private:
 987     ArrayBufferContents m_contents;
 988     int32_t m_index { 0 };
 989 };
 990 
 991 class JSTestCustomGetterSetter : public JSNonFinalObject {
 992 public:
 993     using Base = JSNonFinalObject;
 994     static const unsigned StructureFlags = Base::StructureFlags;
 995 
 996     JSTestCustomGetterSetter(VM&amp; vm, Structure* structure)
 997         : Base(vm, structure)
 998     { }
 999 
1000     static JSTestCustomGetterSetter* create(VM&amp; vm, JSGlobalObject*, Structure* structure)
1001     {
<span class="line-modified">1002         JSTestCustomGetterSetter* result = new (NotNull, allocateCell&lt;JSTestCustomGetterSetter&gt;(vm.heap)) JSTestCustomGetterSetter(vm, structure);</span>
1003         result-&gt;finishCreation(vm);
1004         return result;
1005     }
1006 
1007     void finishCreation(VM&amp;);
1008 
1009     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject)
1010     {
1011         return Structure::create(vm, globalObject, globalObject-&gt;objectPrototype(), TypeInfo(ObjectType, StructureFlags), info());
1012     }
1013 
1014     DECLARE_INFO;
1015 };
1016 
1017 
1018 static EncodedJSValue customGetAccessor(ExecState*, EncodedJSValue thisValue, PropertyName)
1019 {
1020     // Passed |this|
1021     return thisValue;
1022 }
1023 
1024 static EncodedJSValue customGetValue(ExecState* exec, EncodedJSValue slotValue, PropertyName)
1025 {
1026     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(exec-&gt;vm()));
1027     // Passed property holder.
1028     return slotValue;
1029 }
1030 
1031 static bool customSetAccessor(ExecState* exec, EncodedJSValue thisObject, EncodedJSValue encodedValue)
1032 {
1033     VM&amp; vm = exec-&gt;vm();
1034 
1035     JSValue value = JSValue::decode(encodedValue);
1036     RELEASE_ASSERT(value.isObject());
1037     JSObject* object = asObject(value);
1038     PutPropertySlot slot(object);
<span class="line-modified">1039     object-&gt;put(object, exec, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(thisObject), slot);</span>
1040 
1041     return true;
1042 }
1043 
1044 static bool customSetValue(ExecState* exec, EncodedJSValue slotValue, EncodedJSValue encodedValue)
1045 {
1046     VM&amp; vm = exec-&gt;vm();
1047 
1048     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(exec-&gt;vm()));
1049 
1050     JSValue value = JSValue::decode(encodedValue);
1051     RELEASE_ASSERT(value.isObject());
1052     JSObject* object = asObject(value);
1053     PutPropertySlot slot(object);
<span class="line-modified">1054     object-&gt;put(object, exec, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(slotValue), slot);</span>
1055 
1056     return true;
1057 }
1058 
1059 void JSTestCustomGetterSetter::finishCreation(VM&amp; vm)
1060 {
1061     Base::finishCreation(vm);
1062 
<span class="line-modified">1063     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customValue&quot;),</span>
1064         CustomGetterSetter::create(vm, customGetValue, customSetValue), 0);
<span class="line-modified">1065     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customAccessor&quot;),</span>
1066         CustomGetterSetter::create(vm, customGetAccessor, customSetAccessor), static_cast&lt;unsigned&gt;(PropertyAttribute::CustomAccessor));
1067 }
1068 
1069 const ClassInfo Element::s_info = { &quot;Element&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Element) };
1070 const ClassInfo Root::s_info = { &quot;Root&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Root) };
1071 const ClassInfo SimpleObject::s_info = { &quot;SimpleObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(SimpleObject) };
1072 const ClassInfo ImpureGetter::s_info = { &quot;ImpureGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ImpureGetter) };
1073 const ClassInfo CustomGetter::s_info = { &quot;CustomGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(CustomGetter) };
1074 const ClassInfo RuntimeArray::s_info = { &quot;RuntimeArray&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RuntimeArray) };
1075 #if ENABLE(JIT)
1076 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITNode::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITNode) };
1077 #else
1078 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITNode) };
1079 #endif
1080 const ClassInfo DOMJITGetter::s_info = { &quot;DOMJITGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetter) };
1081 const ClassInfo DOMJITGetterComplex::s_info = { &quot;DOMJITGetterComplex&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterComplex) };
1082 const ClassInfo DOMJITGetterBaseJSObject::s_info = { &quot;DOMJITGetterBaseJSObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterBaseJSObject) };
1083 #if ENABLE(JIT)
1084 const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITFunctionObject::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
1085 #else
</pre>
<hr />
<pre>
1105 
1106 #if ENABLE(WEBASSEMBLY)
1107 
1108 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(ExecState*);
1109 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(ExecState*);
1110 
1111 class WasmStreamingParser : public JSDestructibleObject {
1112 public:
1113     WasmStreamingParser(VM&amp; vm, Structure* structure)
1114         : Base(vm, structure)
1115         , m_info(Wasm::ModuleInformation::create())
1116         , m_streamingParser(m_info.get())
1117     {
1118     }
1119 
1120     using Base = JSDestructibleObject;
1121 
1122     static WasmStreamingParser* create(VM&amp; vm, JSGlobalObject* globalObject)
1123     {
1124         Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified">1125         WasmStreamingParser* result = new (NotNull, allocateCell&lt;WasmStreamingParser&gt;(vm.heap)) WasmStreamingParser(vm, structure);</span>
1126         result-&gt;finishCreation(vm);
1127         return result;
1128     }
1129 
1130     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1131     {
1132         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1133     }
1134 
1135     Wasm::StreamingParser&amp; streamingParser() { return m_streamingParser; }
1136 
1137     void finishCreation(VM&amp; vm)
1138     {
1139         Base::finishCreation(vm);
1140 
1141         JSGlobalObject* globalObject = this-&gt;globalObject(vm);
<span class="line-modified">1142         putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;addBytes&quot;), 0, functionWasmStreamingParserAddBytes, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">1143         putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;finalize&quot;), 0, functionWasmStreamingParserFinalize, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
1144     }
1145 
1146     DECLARE_INFO;
1147 
1148     Ref&lt;Wasm::ModuleInformation&gt; m_info;
1149     Wasm::StreamingParser m_streamingParser;
1150 };
1151 
1152 const ClassInfo WasmStreamingParser::s_info = { &quot;WasmStreamingParser&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WasmStreamingParser) };
1153 
1154 EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(ExecState* exec)
1155 {
1156     VM&amp; vm = exec-&gt;vm();
1157     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
1158     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, exec-&gt;thisValue());
1159     if (!thisObject)
1160         RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(false)));
1161 
1162     auto data = getWasmBufferFromValue(exec, exec-&gt;argument(0));
1163     RETURN_IF_EXCEPTION(scope, encodedJSValue());
</pre>
<hr />
<pre>
1289             toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfPublicLength());
1290         }
1291     }
1292 
1293     if (!toFlush.size())
1294         return JSValue::encode(jsBoolean(false));
1295 
1296     for (void* ptr : toFlush)
1297         clflush(ptr);
1298     return JSValue::encode(jsBoolean(true));
1299 #else
1300     UNUSED_PARAM(exec);
1301     return JSValue::encode(jsBoolean(false));
1302 #endif
1303 }
1304 
1305 class CallerFrameJITTypeFunctor {
1306 public:
1307     CallerFrameJITTypeFunctor()
1308         : m_currentFrame(0)
<span class="line-modified">1309         , m_jitType(JITType::None)</span>
1310     {
1311     }
1312 
1313     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
1314     {
1315         if (m_currentFrame++ &gt; 1) {
1316             m_jitType = visitor-&gt;codeBlock()-&gt;jitType();
1317             return StackVisitor::Done;
1318         }
1319         return StackVisitor::Continue;
1320     }
1321 
<span class="line-modified">1322     JITType jitType() { return m_jitType; }</span>
1323 
1324 private:
1325     mutable unsigned m_currentFrame;
<span class="line-modified">1326     mutable JITType m_jitType;</span>
1327 };
1328 
1329 static FunctionExecutable* getExecutableForFunction(JSValue theFunctionValue)
1330 {
1331     if (!theFunctionValue.isCell())
1332         return nullptr;
1333 
<span class="line-modified">1334     VM&amp; vm = theFunctionValue.asCell()-&gt;vm();</span>
1335     JSFunction* theFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, theFunctionValue);
1336     if (!theFunction)
1337         return nullptr;
1338 
1339     FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm,
1340         theFunction-&gt;executable());
1341 
1342     return executable;
1343 }
1344 
1345 // Returns true if the current frame is a LLInt frame.
1346 // Usage: isLLInt = $vm.llintTrue()
1347 static EncodedJSValue JSC_HOST_CALL functionLLintTrue(ExecState* exec)
1348 {
1349     if (!exec)
1350         return JSValue::encode(jsUndefined());
1351     CallerFrameJITTypeFunctor functor;
1352     exec-&gt;iterate(functor);
<span class="line-modified">1353     return JSValue::encode(jsBoolean(functor.jitType() == JITType::InterpreterThunk));</span>
1354 }
1355 
1356 // Returns true if the current frame is a baseline JIT frame.
1357 // Usage: isBaselineJIT = $vm.jitTrue()
1358 static EncodedJSValue JSC_HOST_CALL functionJITTrue(ExecState* exec)
1359 {
1360     if (!exec)
1361         return JSValue::encode(jsUndefined());
1362     CallerFrameJITTypeFunctor functor;
1363     exec-&gt;iterate(functor);
<span class="line-modified">1364     return JSValue::encode(jsBoolean(functor.jitType() == JITType::BaselineJIT));</span>
1365 }
1366 
1367 // Set that the argument function should not be inlined.
1368 // Usage:
1369 // function f() { };
1370 // $vm.noInline(f);
1371 static EncodedJSValue JSC_HOST_CALL functionNoInline(ExecState* exec)
1372 {
1373     if (exec-&gt;argumentCount() &lt; 1)
1374         return JSValue::encode(jsUndefined());
1375 
1376     JSValue theFunctionValue = exec-&gt;uncheckedArgument(0);
1377 
1378     if (FunctionExecutable* executable = getExecutableForFunction(theFunctionValue))
1379         executable-&gt;setNeverInline(true);
1380 
1381     return JSValue::encode(jsUndefined());
1382 }
1383 
1384 // Runs a full GC synchronously.
1385 // Usage: $vm.gc()
1386 static EncodedJSValue JSC_HOST_CALL functionGC(ExecState* exec)
1387 {
1388     VMInspector::gc(exec);
1389     return JSValue::encode(jsUndefined());
1390 }
1391 
1392 // Runs the edenGC synchronously.
1393 // Usage: $vm.edenGC()
1394 static EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState* exec)
1395 {
1396     VMInspector::edenGC(exec);
1397     return JSValue::encode(jsUndefined());
1398 }
1399 
<span class="line-added">1400 // Dumps the hashes of all subspaces currently registered with the VM.</span>
<span class="line-added">1401 // Usage: $vm.dumpSubspaceHashes()</span>
<span class="line-added">1402 static EncodedJSValue JSC_HOST_CALL functionDumpSubspaceHashes(ExecState* exec)</span>
<span class="line-added">1403 {</span>
<span class="line-added">1404     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">1405     VMInspector::dumpSubspaceHashes(&amp;vm);</span>
<span class="line-added">1406     return JSValue::encode(jsUndefined());</span>
<span class="line-added">1407 }</span>
<span class="line-added">1408 </span>
1409 // Gets a JSDollarVMCallFrame for a specified frame index.
1410 // Usage: var callFrame = $vm.callFrame(0) // frame 0 is the top frame.
1411 // Usage: var callFrame = $vm.callFrame() // implies frame 0 i.e. current frame.
1412 //
1413 // This gives you the ability to query the following:
1414 //    callFrame.valid; // false if we asked for a frame beyond the end of the stack, else true.
1415 //    callFrame.callee;
1416 //    callFrame.codeBlock;
1417 //    callFrame.unlinkedCodeBlock;
1418 //    callFrame.executable;
1419 //
1420 // Note: you cannot toString() a codeBlock, unlinkedCodeBlock, or executable because
1421 // there are internal objects and not a JS object. Hence, you cannot do string
1422 // concatenation with them.
1423 static EncodedJSValue JSC_HOST_CALL functionCallFrame(ExecState* exec)
1424 {
1425     unsigned frameNumber = 1;
1426     if (exec-&gt;argumentCount() &gt;= 1) {
1427         JSValue value = exec-&gt;uncheckedArgument(0);
1428         if (!value.isUInt32())
</pre>
<hr />
<pre>
1482     if (candidateCodeBlock &amp;&amp; VMInspector::isValidCodeBlock(exec, candidateCodeBlock))
1483         return candidateCodeBlock;
1484 
1485     if (candidateCodeBlock)
1486         dataLog(&quot;Invalid codeBlock: &quot;, RawPointer(candidateCodeBlock), &quot; &quot;, value, &quot;\n&quot;);
1487     else
1488         dataLog(&quot;Invalid codeBlock: &quot;, value, &quot;\n&quot;);
1489     return nullptr;
1490 }
1491 
1492 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(functionObj))
1493 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(codeBlockToken))
1494 // Note: you cannot toString() a codeBlock because it&#39;s an internal object and not
1495 // a JS object. Hence, you cannot do string concatenation with it.
1496 static EncodedJSValue JSC_HOST_CALL functionCodeBlockFor(ExecState* exec)
1497 {
1498     CodeBlock* codeBlock = codeBlockFromArg(exec);
1499     WTF::StringPrintStream stream;
1500     if (codeBlock) {
1501         stream.print(*codeBlock);
<span class="line-modified">1502         return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));</span>
1503     }
1504     return JSValue::encode(jsUndefined());
1505 }
1506 
1507 // Usage: $vm.dumpSourceFor(functionObj)
1508 // Usage: $vm.dumpSourceFor(codeBlockToken)
1509 static EncodedJSValue JSC_HOST_CALL functionDumpSourceFor(ExecState* exec)
1510 {
1511     CodeBlock* codeBlock = codeBlockFromArg(exec);
1512     if (codeBlock)
1513         codeBlock-&gt;dumpSource();
1514     return JSValue::encode(jsUndefined());
1515 }
1516 
1517 // Usage: $vm.dumpBytecodeFor(functionObj)
1518 // Usage: $vm.dumpBytecodeFor(codeBlock)
1519 static EncodedJSValue JSC_HOST_CALL functionDumpBytecodeFor(ExecState* exec)
1520 {
1521     CodeBlock* codeBlock = codeBlockFromArg(exec);
1522     if (codeBlock)
</pre>
<hr />
<pre>
1615 // Usage: $vm.dumpCell(cell)
1616 static EncodedJSValue JSC_HOST_CALL functionDumpCell(ExecState* exec)
1617 {
1618     JSValue value = exec-&gt;argument(0);
1619     if (!value.isCell())
1620         return encodedJSUndefined();
1621 
1622     VMInspector::dumpCellMemory(value.asCell());
1623     return encodedJSUndefined();
1624 }
1625 
1626 // Gets the dataLog dump of the indexingMode of the passed value.
1627 // Usage: $vm.print(&quot;indexingMode = &quot; + $vm.indexingMode(jsValue))
1628 static EncodedJSValue JSC_HOST_CALL functionIndexingMode(ExecState* exec)
1629 {
1630     if (!exec-&gt;argument(0).isObject())
1631         return encodedJSUndefined();
1632 
1633     WTF::StringPrintStream stream;
1634     stream.print(IndexingTypeDump(exec-&gt;uncheckedArgument(0).getObject()-&gt;indexingMode()));
<span class="line-modified">1635     return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));</span>
1636 }
1637 
1638 static EncodedJSValue JSC_HOST_CALL functionInlineCapacity(ExecState* exec)
1639 {
1640     VM&amp; vm = exec-&gt;vm();
1641     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0)))
1642         return JSValue::encode(jsNumber(object-&gt;structure(vm)-&gt;inlineCapacity()));
1643 
1644     return encodedJSUndefined();
1645 }
1646 
1647 // Gets the dataLog dump of a given JS value as a string.
1648 // Usage: $vm.print(&quot;value = &quot; + $vm.value(jsValue))
1649 static EncodedJSValue JSC_HOST_CALL functionValue(ExecState* exec)
1650 {
1651     WTF::StringPrintStream stream;
1652     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
1653         if (i)
1654             stream.print(&quot;, &quot;);
1655         stream.print(exec-&gt;uncheckedArgument(i));
1656     }
1657 
<span class="line-modified">1658     return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));</span>
1659 }
1660 
1661 // Gets the pid of the current process.
1662 // Usage: $vm.print(&quot;pid = &quot; + $vm.getpid())
1663 static EncodedJSValue JSC_HOST_CALL functionGetPID(ExecState*)
1664 {
1665     return JSValue::encode(jsNumber(getCurrentProcessID()));
1666 }
1667 
1668 // Make the globalObject have a bad time. Does nothing if the object is not a JSGlobalObject.
1669 // Usage: $vm.haveABadTime(globalObject)
1670 static EncodedJSValue JSC_HOST_CALL functionHaveABadTime(ExecState* exec)
1671 {
1672     VM&amp; vm = exec-&gt;vm();
1673     JSLockHolder lock(vm);
1674     JSValue objValue = exec-&gt;argument(0);
1675     if (!objValue.isObject())
1676         return JSValue::encode(jsBoolean(false));
1677 
1678     JSObject* obj = asObject(objValue.asCell());
</pre>
<hr />
<pre>
1719 static EncodedJSValue JSC_HOST_CALL functionCreateProxy(ExecState* exec)
1720 {
1721     VM&amp; vm = exec-&gt;vm();
1722     JSLockHolder lock(vm);
1723     JSValue target = exec-&gt;argument(0);
1724     if (!target.isObject())
1725         return JSValue::encode(jsUndefined());
1726     JSObject* jsTarget = asObject(target.asCell());
1727     Structure* structure = JSProxy::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsTarget-&gt;getPrototypeDirect(vm), ImpureProxyType);
1728     JSProxy* proxy = JSProxy::create(vm, structure, jsTarget);
1729     return JSValue::encode(proxy);
1730 }
1731 
1732 static EncodedJSValue JSC_HOST_CALL functionCreateRuntimeArray(ExecState* exec)
1733 {
1734     JSLockHolder lock(exec);
1735     RuntimeArray* array = RuntimeArray::create(exec);
1736     return JSValue::encode(array);
1737 }
1738 
<span class="line-added">1739 static EncodedJSValue JSC_HOST_CALL functionCreateNullRopeString(ExecState* exec)</span>
<span class="line-added">1740 {</span>
<span class="line-added">1741     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">1742     JSLockHolder lock(vm);</span>
<span class="line-added">1743     return JSValue::encode(JSRopeString::createNullForTesting(vm));</span>
<span class="line-added">1744 }</span>
<span class="line-added">1745 </span>
1746 static EncodedJSValue JSC_HOST_CALL functionCreateImpureGetter(ExecState* exec)
1747 {
1748     VM&amp; vm = exec-&gt;vm();
1749     JSLockHolder lock(vm);
1750     JSValue target = exec-&gt;argument(0);
1751     JSObject* delegate = nullptr;
1752     if (target.isObject())
1753         delegate = asObject(target.asCell());
1754     Structure* structure = ImpureGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1755     ImpureGetter* result = ImpureGetter::create(vm, structure, delegate);
1756     return JSValue::encode(result);
1757 }
1758 
1759 static EncodedJSValue JSC_HOST_CALL functionCreateCustomGetterObject(ExecState* exec)
1760 {
1761     VM&amp; vm = exec-&gt;vm();
1762     JSLockHolder lock(vm);
1763     Structure* structure = CustomGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());
1764     CustomGetter* result = CustomGetter::create(vm, structure);
1765     return JSValue::encode(result);
</pre>
<hr />
<pre>
1844     if (UNLIKELY(!impureGetter)) {
1845         throwTypeError(exec, scope, &quot;argument is not an ImpureGetter&quot;_s);
1846         return encodedJSValue();
1847     }
1848     impureGetter-&gt;setDelegate(vm, asObject(delegate.asCell()));
1849     return JSValue::encode(jsUndefined());
1850 }
1851 
1852 static EncodedJSValue JSC_HOST_CALL functionCreateBuiltin(ExecState* exec)
1853 {
1854     VM&amp; vm = exec-&gt;vm();
1855     auto scope = DECLARE_THROW_SCOPE(vm);
1856 
1857     if (exec-&gt;argumentCount() &lt; 1 || !exec-&gt;argument(0).isString())
1858         return JSValue::encode(jsUndefined());
1859 
1860     String functionText = asString(exec-&gt;argument(0))-&gt;value(exec);
1861     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1862 
1863     const SourceCode&amp; source = makeSource(functionText, { });
<span class="line-modified">1864     JSFunction* func = JSFunction::create(vm, createBuiltinExecutable(vm, source, Identifier::fromString(vm, &quot;foo&quot;), ConstructorKind::None, ConstructAbility::CannotConstruct)-&gt;link(vm, nullptr, source), exec-&gt;lexicalGlobalObject());</span>
1865 
1866     return JSValue::encode(func);
1867 }
1868 
1869 static EncodedJSValue JSC_HOST_CALL functionGetPrivateProperty(ExecState* exec)
1870 {
1871     VM&amp; vm = exec-&gt;vm();
1872     auto scope = DECLARE_THROW_SCOPE(vm);
1873 
1874     if (exec-&gt;argumentCount() &lt; 2 || !exec-&gt;argument(1).isString())
1875         return encodedJSUndefined();
1876 
1877     String str = asString(exec-&gt;argument(1))-&gt;value(exec);
1878 
<span class="line-modified">1879     SymbolImpl* symbol = vm.propertyNames-&gt;lookUpPrivateName(Identifier::fromString(vm, str));</span>
1880     if (!symbol)
1881         return throwVMError(exec, scope, &quot;Unknown private name.&quot;);
1882 
1883     RELEASE_AND_RETURN(scope, JSValue::encode(exec-&gt;argument(0).get(exec, symbol)));
1884 }
1885 
1886 static EncodedJSValue JSC_HOST_CALL functionCreateRoot(ExecState* exec)
1887 {
1888     VM&amp; vm = exec-&gt;vm();
1889     JSLockHolder lock(vm);
1890     return JSValue::encode(Root::create(vm, exec-&gt;lexicalGlobalObject()));
1891 }
1892 
1893 static EncodedJSValue JSC_HOST_CALL functionCreateElement(ExecState* exec)
1894 {
1895     VM&amp; vm = exec-&gt;vm();
1896     JSLockHolder lock(vm);
1897     auto scope = DECLARE_THROW_SCOPE(vm);
1898 
1899     Root* root = jsDynamicCast&lt;Root*&gt;(vm, exec-&gt;argument(0));
</pre>
<hr />
<pre>
2059     JSValue functionValue = exec-&gt;argument(0);
2060     RELEASE_ASSERT(functionValue.isFunction(vm));
2061     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2062 
2063     RELEASE_ASSERT(exec-&gt;argument(1).isString());
2064     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);
2065     String sourceCodeText = executable-&gt;source().view().toString();
2066     RELEASE_ASSERT(sourceCodeText.contains(substring));
2067     int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
2068 
2069     size_t executionCount = vm.controlFlowProfiler()-&gt;basicBlockExecutionCountAtTextOffset(offset, executable-&gt;sourceID(), vm);
2070     return JSValue::encode(JSValue(executionCount));
2071 }
2072 
2073 static EncodedJSValue JSC_HOST_CALL functionEnableExceptionFuzz(ExecState*)
2074 {
2075     Options::useExceptionFuzz() = true;
2076     return JSValue::encode(jsUndefined());
2077 }
2078 
<span class="line-modified">2079 static EncodedJSValue changeDebuggerModeWhenIdle(ExecState* exec, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)</span>
2080 {
<span class="line-modified">2081     bool newDebuggerMode = codeGenerationMode.contains(CodeGenerationMode::Debugger);</span>
2082     if (Options::forceDebuggerBytecodeGeneration() == newDebuggerMode)
2083         return JSValue::encode(jsUndefined());
2084 
2085     VM* vm = &amp;exec-&gt;vm();
2086     vm-&gt;whenIdle([=] () {
2087         Options::forceDebuggerBytecodeGeneration() = newDebuggerMode;
2088         vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);
<span class="line-modified">2089         if (newDebuggerMode)</span>
2090             vm-&gt;ensureShadowChicken();
2091     });
2092     return JSValue::encode(jsUndefined());
2093 }
2094 
2095 static EncodedJSValue JSC_HOST_CALL functionEnableDebuggerModeWhenIdle(ExecState* exec)
2096 {
<span class="line-modified">2097     return changeDebuggerModeWhenIdle(exec, { CodeGenerationMode::Debugger });</span>
2098 }
2099 
2100 static EncodedJSValue JSC_HOST_CALL functionDisableDebuggerModeWhenIdle(ExecState* exec)
2101 {
<span class="line-modified">2102     return changeDebuggerModeWhenIdle(exec, { });</span>
<span class="line-added">2103 }</span>
<span class="line-added">2104 </span>
<span class="line-added">2105 static EncodedJSValue JSC_HOST_CALL functionDeleteAllCodeWhenIdle(ExecState* exec)</span>
<span class="line-added">2106 {</span>
<span class="line-added">2107     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-added">2108     vm-&gt;whenIdle([=] () {</span>
<span class="line-added">2109         vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);</span>
<span class="line-added">2110     });</span>
<span class="line-added">2111     return JSValue::encode(jsUndefined());</span>
2112 }
2113 
2114 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectCount(ExecState* exec)
2115 {
2116     return JSValue::encode(jsNumber(exec-&gt;vm().heap.globalObjectCount()));
2117 }
2118 
2119 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectForObject(ExecState* exec)
2120 {
2121     JSValue value = exec-&gt;argument(0);
2122     RELEASE_ASSERT(value.isObject());
2123     JSGlobalObject* globalObject = jsCast&lt;JSObject*&gt;(value)-&gt;globalObject(exec-&gt;vm());
2124     RELEASE_ASSERT(globalObject);
2125     return JSValue::encode(globalObject);
2126 }
2127 
2128 static EncodedJSValue JSC_HOST_CALL functionGetGetterSetter(ExecState* exec)
2129 {
<span class="line-added">2130     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">2131     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2132 </span>
2133     JSValue value = exec-&gt;argument(0);
2134     if (!value.isObject())
2135         return JSValue::encode(jsUndefined());
2136 
2137     JSValue property = exec-&gt;argument(1);
2138     if (!property.isString())
2139         return JSValue::encode(jsUndefined());
2140 
<span class="line-added">2141     auto propertyName = asString(property)-&gt;toIdentifier(exec);</span>
<span class="line-added">2142     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">2143 </span>
2144     PropertySlot slot(value, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">2145     value.getPropertySlot(exec, propertyName, slot);</span>
<span class="line-added">2146     RETURN_IF_EXCEPTION(scope, { });</span>
2147 
2148     JSValue result;
2149     if (slot.isCacheableGetter())
2150         result = slot.getterSetter();
2151     else
2152         result = jsNull();
2153 
2154     return JSValue::encode(result);
2155 }
2156 
2157 static EncodedJSValue JSC_HOST_CALL functionLoadGetterFromGetterSetter(ExecState* exec)
2158 {
2159     VM&amp; vm = exec-&gt;vm();
2160     auto scope = DECLARE_THROW_SCOPE(vm);
2161 
2162     GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(vm, exec-&gt;argument(0));
2163     if (UNLIKELY(!getterSetter)) {
2164         throwTypeError(exec, scope, &quot;Invalid use of loadGetterFromGetterSetter test function: argument is not a GetterSetter&quot;_s);
2165         return encodedJSValue();
2166     }
</pre>
<hr />
<pre>
2182     VM&amp; vm = exec-&gt;vm();
2183     JSObject* a = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));
2184     JSObject* b = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(1));
2185     if (!a || !b)
2186         return JSValue::encode(jsNumber(PNaN));
2187 
2188     ptrdiff_t delta = bitwise_cast&lt;char*&gt;(a-&gt;butterfly()) - bitwise_cast&lt;char*&gt;(b-&gt;butterfly());
2189     if (delta &lt; 0)
2190         return JSValue::encode(jsNumber(PNaN));
2191     if (delta &gt; std::numeric_limits&lt;int32_t&gt;::max())
2192         return JSValue::encode(jsNumber(PNaN));
2193     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(delta)));
2194 }
2195 
2196 static EncodedJSValue JSC_HOST_CALL functionTotalGCTime(ExecState* exec)
2197 {
2198     VM&amp; vm = exec-&gt;vm();
2199     return JSValue::encode(jsNumber(vm.heap.totalGCTime().seconds()));
2200 }
2201 
<span class="line-added">2202 static EncodedJSValue JSC_HOST_CALL functionParseCount(ExecState*)</span>
<span class="line-added">2203 {</span>
<span class="line-added">2204     return JSValue::encode(jsNumber(globalParseCount.load()));</span>
<span class="line-added">2205 }</span>
<span class="line-added">2206 </span>
<span class="line-added">2207 static EncodedJSValue JSC_HOST_CALL functionIsWasmSupported(ExecState*)</span>
<span class="line-added">2208 {</span>
<span class="line-added">2209 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">2210     return JSValue::encode(jsBoolean(Wasm::isSupported()));</span>
<span class="line-added">2211 #else</span>
<span class="line-added">2212     return JSValue::encode(jsBoolean(false));</span>
<span class="line-added">2213 #endif</span>
<span class="line-added">2214 }</span>
<span class="line-added">2215 </span>
2216 void JSDollarVM::finishCreation(VM&amp; vm)
2217 {
2218     Base::finishCreation(vm);
2219 
2220     JSGlobalObject* globalObject = this-&gt;globalObject(vm);
2221 
2222     auto addFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
2223         JSDollarVM::addFunction(vm, globalObject, name, function, arguments);
2224     };
2225     auto addConstructibleFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
2226         JSDollarVM::addConstructibleFunction(vm, globalObject, name, function, arguments);
2227     };
2228 
2229     addFunction(vm, &quot;abort&quot;, functionCrash, 0);
2230     addFunction(vm, &quot;crash&quot;, functionCrash, 0);
2231     addFunction(vm, &quot;breakpoint&quot;, functionBreakpoint, 0);
2232 
<span class="line-modified">2233     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;dfgTrue&quot;), 0, functionDFGTrue, DFGTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">2234     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;ftlTrue&quot;), 0, functionFTLTrue, FTLTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
2235 
<span class="line-modified">2236     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuMfence&quot;), 0, functionCpuMfence, CPUMfenceIntrinsic, 0);</span>
<span class="line-modified">2237     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuRdtsc&quot;), 0, functionCpuRdtsc, CPURdtscIntrinsic, 0);</span>
<span class="line-modified">2238     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuCpuid&quot;), 0, functionCpuCpuid, CPUCpuidIntrinsic, 0);</span>
<span class="line-modified">2239     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuPause&quot;), 0, functionCpuPause, CPUPauseIntrinsic, 0);</span>
2240     addFunction(vm, &quot;cpuClflush&quot;, functionCpuClflush, 2);
2241 
2242     addFunction(vm, &quot;llintTrue&quot;, functionLLintTrue, 0);
2243     addFunction(vm, &quot;jitTrue&quot;, functionJITTrue, 0);
2244 
2245     addFunction(vm, &quot;noInline&quot;, functionNoInline, 1);
2246 
2247     addFunction(vm, &quot;gc&quot;, functionGC, 0);
2248     addFunction(vm, &quot;edenGC&quot;, functionEdenGC, 0);
<span class="line-added">2249     addFunction(vm, &quot;dumpSubspaceHashes&quot;, functionDumpSubspaceHashes, 0);</span>
2250 
2251     addFunction(vm, &quot;callFrame&quot;, functionCallFrame, 1);
2252     addFunction(vm, &quot;codeBlockFor&quot;, functionCodeBlockFor, 1);
2253     addFunction(vm, &quot;codeBlockForFrame&quot;, functionCodeBlockForFrame, 1);
2254     addFunction(vm, &quot;dumpSourceFor&quot;, functionDumpSourceFor, 1);
2255     addFunction(vm, &quot;dumpBytecodeFor&quot;, functionDumpBytecodeFor, 1);
2256 
2257     addFunction(vm, &quot;dataLog&quot;, functionDataLog, 1);
2258     addFunction(vm, &quot;print&quot;, functionPrint, 1);
2259     addFunction(vm, &quot;dumpCallFrame&quot;, functionDumpCallFrame, 0);
2260     addFunction(vm, &quot;dumpStack&quot;, functionDumpStack, 0);
2261     addFunction(vm, &quot;dumpRegisters&quot;, functionDumpRegisters, 1);
2262 
2263     addFunction(vm, &quot;dumpCell&quot;, functionDumpCell, 1);
2264 
2265     addFunction(vm, &quot;indexingMode&quot;, functionIndexingMode, 1);
2266     addFunction(vm, &quot;inlineCapacity&quot;, functionInlineCapacity, 1);
2267     addFunction(vm, &quot;value&quot;, functionValue, 1);
2268     addFunction(vm, &quot;getpid&quot;, functionGetPID, 0);
2269 
2270     addFunction(vm, &quot;haveABadTime&quot;, functionHaveABadTime, 1);
2271     addFunction(vm, &quot;isHavingABadTime&quot;, functionIsHavingABadTime, 1);
2272 
2273     addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
2274     addFunction(vm, &quot;createProxy&quot;, functionCreateProxy, 1);
2275     addFunction(vm, &quot;createRuntimeArray&quot;, functionCreateRuntimeArray, 0);
<span class="line-added">2276     addFunction(vm, &quot;createNullRopeString&quot;, functionCreateNullRopeString, 0);</span>
2277 
2278     addFunction(vm, &quot;createImpureGetter&quot;, functionCreateImpureGetter, 1);
2279     addFunction(vm, &quot;createCustomGetterObject&quot;, functionCreateCustomGetterObject, 0);
2280     addFunction(vm, &quot;createDOMJITNodeObject&quot;, functionCreateDOMJITNodeObject, 0);
2281     addFunction(vm, &quot;createDOMJITGetterObject&quot;, functionCreateDOMJITGetterObject, 0);
2282     addFunction(vm, &quot;createDOMJITGetterComplexObject&quot;, functionCreateDOMJITGetterComplexObject, 0);
2283     addFunction(vm, &quot;createDOMJITFunctionObject&quot;, functionCreateDOMJITFunctionObject, 0);
2284     addFunction(vm, &quot;createDOMJITCheckSubClassObject&quot;, functionCreateDOMJITCheckSubClassObject, 0);
2285     addFunction(vm, &quot;createDOMJITGetterBaseJSObject&quot;, functionCreateDOMJITGetterBaseJSObject, 0);
2286     addFunction(vm, &quot;createBuiltin&quot;, functionCreateBuiltin, 2);
2287 #if ENABLE(WEBASSEMBLY)
2288     addFunction(vm, &quot;createWasmStreamingParser&quot;, functionCreateWasmStreamingParser, 0);
2289 #endif
2290     addFunction(vm, &quot;getPrivateProperty&quot;, functionGetPrivateProperty, 2);
2291     addFunction(vm, &quot;setImpureGetterDelegate&quot;, functionSetImpureGetterDelegate, 2);
2292 
2293     addConstructibleFunction(vm, &quot;Root&quot;, functionCreateRoot, 0);
2294     addConstructibleFunction(vm, &quot;Element&quot;, functionCreateElement, 1);
2295     addFunction(vm, &quot;getElement&quot;, functionGetElement, 1);
2296 
</pre>
<hr />
<pre>
2298     addFunction(vm, &quot;getHiddenValue&quot;, functionGetHiddenValue, 1);
2299     addFunction(vm, &quot;setHiddenValue&quot;, functionSetHiddenValue, 2);
2300 
2301     addFunction(vm, &quot;shadowChickenFunctionsOnStack&quot;, functionShadowChickenFunctionsOnStack, 0);
2302     addFunction(vm, &quot;setGlobalConstRedeclarationShouldNotThrow&quot;, functionSetGlobalConstRedeclarationShouldNotThrow, 0);
2303 
2304     addFunction(vm, &quot;findTypeForExpression&quot;, functionFindTypeForExpression, 2);
2305     addFunction(vm, &quot;returnTypeFor&quot;, functionReturnTypeFor, 1);
2306 
2307     addFunction(vm, &quot;flattenDictionaryObject&quot;, functionFlattenDictionaryObject, 1);
2308 
2309     addFunction(vm, &quot;dumpBasicBlockExecutionRanges&quot;, functionDumpBasicBlockExecutionRanges , 0);
2310     addFunction(vm, &quot;hasBasicBlockExecuted&quot;, functionHasBasicBlockExecuted, 2);
2311     addFunction(vm, &quot;basicBlockExecutionCount&quot;, functionBasicBlockExecutionCount, 2);
2312 
2313     addFunction(vm, &quot;enableExceptionFuzz&quot;, functionEnableExceptionFuzz, 0);
2314 
2315     addFunction(vm, &quot;enableDebuggerModeWhenIdle&quot;, functionEnableDebuggerModeWhenIdle, 0);
2316     addFunction(vm, &quot;disableDebuggerModeWhenIdle&quot;, functionDisableDebuggerModeWhenIdle, 0);
2317 
<span class="line-added">2318     addFunction(vm, &quot;deleteAllCodeWhenIdle&quot;, functionDeleteAllCodeWhenIdle, 0);</span>
<span class="line-added">2319 </span>
2320     addFunction(vm, &quot;globalObjectCount&quot;, functionGlobalObjectCount, 0);
2321     addFunction(vm, &quot;globalObjectForObject&quot;, functionGlobalObjectForObject, 1);
2322 
2323     addFunction(vm, &quot;getGetterSetter&quot;, functionGetGetterSetter, 2);
2324     addFunction(vm, &quot;loadGetterFromGetterSetter&quot;, functionLoadGetterFromGetterSetter, 1);
2325     addFunction(vm, &quot;createCustomTestGetterSetter&quot;, functionCreateCustomTestGetterSetter, 1);
2326 
2327     addFunction(vm, &quot;deltaBetweenButterflies&quot;, functionDeltaBetweenButterflies, 2);
2328 
2329     addFunction(vm, &quot;totalGCTime&quot;, functionTotalGCTime, 0);
<span class="line-added">2330 </span>
<span class="line-added">2331     addFunction(vm, &quot;parseCount&quot;, functionParseCount, 0);</span>
<span class="line-added">2332 </span>
<span class="line-added">2333     addFunction(vm, &quot;isWasmSupported&quot;, functionIsWasmSupported, 0);</span>
2334 }
2335 
2336 void JSDollarVM::addFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2337 {
<span class="line-modified">2338     Identifier identifier = Identifier::fromString(vm, name);</span>
2339     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function));
2340 }
2341 
2342 void JSDollarVM::addConstructibleFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2343 {
<span class="line-modified">2344     Identifier identifier = Identifier::fromString(vm, name);</span>
2345     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function, NoIntrinsic, function));
2346 }
2347 
2348 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="HeapVerifier.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SigillCrashAnalyzer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>