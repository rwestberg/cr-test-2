<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOpcodes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITMathIC.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOpcodes32_64.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOpcodes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -230,11 +230,11 @@</span>
      Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
      move(TrustedImm32(0), regT0);
      Jump notMasqueradesAsUndefined = jump();
  
      isMasqueradesAsUndefined.link(this);
<span class="udiff-line-modified-removed">-     emitLoadStructure(*vm(), regT0, regT1, regT2);</span>
<span class="udiff-line-modified-added">+     emitLoadStructure(vm(), regT0, regT1, regT2);</span>
      move(TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0);
      loadPtr(Address(regT1, Structure::globalObjectOffset()), regT1);
      comparePtr(Equal, regT0, regT1, regT0);
  
      notMasqueradesAsUndefined.link(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -389,11 +389,11 @@</span>
      GPRReg scratch1 = regT1;
      GPRReg scratch2 = regT2;
      bool shouldCheckMasqueradesAsUndefined = true;
  
      emitGetVirtualRegister(bytecode.m_condition.offset(), value);
<span class="udiff-line-modified-removed">-     addJump(branchIfFalsey(*vm(), JSValueRegs(value), scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);</span>
<span class="udiff-line-modified-added">+     addJump(branchIfFalsey(vm(), JSValueRegs(value), scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);</span>
  }
  
  void JIT::emit_op_jeq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJeqNull&gt;();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -403,11 +403,11 @@</span>
      emitGetVirtualRegister(src, regT0);
      Jump isImmediate = branchIfNotCell(regT0);
  
      // First, handle JSCell cases - check MasqueradesAsUndefined bit on the structure.
      Jump isNotMasqueradesAsUndefined = branchTest8(Zero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
<span class="udiff-line-modified-removed">-     emitLoadStructure(*vm(), regT0, regT2, regT1);</span>
<span class="udiff-line-modified-added">+     emitLoadStructure(vm(), regT0, regT2, regT1);</span>
      move(TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0);
      addJump(branchPtr(Equal, Address(regT2, Structure::globalObjectOffset()), regT0), target);
      Jump masqueradesGlobalObjectIsForeign = jump();
  
      // Now handle the immediate cases - undefined &amp; null
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -427,11 +427,11 @@</span>
      emitGetVirtualRegister(src, regT0);
      Jump isImmediate = branchIfNotCell(regT0);
  
      // First, handle JSCell cases - check MasqueradesAsUndefined bit on the structure.
      addJump(branchTest8(Zero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined)), target);
<span class="udiff-line-modified-removed">-     emitLoadStructure(*vm(), regT0, regT2, regT1);</span>
<span class="udiff-line-modified-added">+     emitLoadStructure(vm(), regT0, regT2, regT1);</span>
      move(TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0);
      addJump(branchPtr(NotEqual, Address(regT2, Structure::globalObjectOffset()), regT0), target);
      Jump wasNotImmediate = jump();
  
      // Now handle the immediate cases - undefined &amp; null
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -440,10 +440,34 @@</span>
      addJump(branch64(NotEqual, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);
  
      wasNotImmediate.link(this);
  }
  
<span class="udiff-line-added">+ void JIT::emit_op_jundefined_or_null(const Instruction* currentInstruction)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto bytecode = currentInstruction-&gt;as&lt;OpJundefinedOrNull&gt;();</span>
<span class="udiff-line-added">+     int value = bytecode.m_value.offset();</span>
<span class="udiff-line-added">+     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     emitGetVirtualRegister(value, regT0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     and64(TrustedImm32(~TagBitUndefined), regT0);</span>
<span class="udiff-line-added">+     addJump(branch64(Equal, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void JIT::emit_op_jnundefined_or_null(const Instruction* currentInstruction)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto bytecode = currentInstruction-&gt;as&lt;OpJnundefinedOrNull&gt;();</span>
<span class="udiff-line-added">+     int value = bytecode.m_value.offset();</span>
<span class="udiff-line-added">+     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     emitGetVirtualRegister(value, regT0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     and64(TrustedImm32(~TagBitUndefined), regT0);</span>
<span class="udiff-line-added">+     addJump(branch64(NotEqual, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void JIT::emit_op_jneq_ptr(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJneqPtr&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      int src = bytecode.m_value.offset();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -484,11 +508,11 @@</span>
      GPRReg value = regT0;
      GPRReg scratch1 = regT1;
      GPRReg scratch2 = regT2;
      bool shouldCheckMasqueradesAsUndefined = true;
      emitGetVirtualRegister(bytecode.m_condition.offset(), value);
<span class="udiff-line-modified-removed">-     addJump(branchIfTruthy(*vm(), JSValueRegs(value), scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);</span>
<span class="udiff-line-modified-added">+     addJump(branchIfTruthy(vm(), JSValueRegs(value), scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);</span>
  }
  
  void JIT::emit_op_neq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNeq&gt;();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -511,14 +535,14 @@</span>
  
  void JIT::emit_op_throw(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpThrow&gt;();
      ASSERT(regT0 == returnValueGPR);
<span class="udiff-line-modified-removed">-     copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm()-&gt;topEntryFrame);</span>
<span class="udiff-line-modified-added">+     copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);</span>
      emitGetVirtualRegister(bytecode.m_value.offset(), regT0);
      callOperationNoExceptionCheck(operationThrow, regT0);
<span class="udiff-line-modified-removed">-     jumpToExceptionHandler(*vm());</span>
<span class="udiff-line-modified-added">+     jumpToExceptionHandler(vm());</span>
  }
  
  template&lt;typename Op&gt;
  void JIT::compileOpStrictEq(const Instruction* currentInstruction, CompileOpStrictEqType type)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -665,21 +689,21 @@</span>
  
  void JIT::emit_op_catch(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpCatch&gt;();
  
<span class="udiff-line-modified-removed">-     restoreCalleeSavesFromEntryFrameCalleeSavesBuffer(vm()-&gt;topEntryFrame);</span>
<span class="udiff-line-modified-added">+     restoreCalleeSavesFromEntryFrameCalleeSavesBuffer(vm().topEntryFrame);</span>
  
      move(TrustedImmPtr(m_vm), regT3);
      load64(Address(regT3, VM::callFrameForCatchOffset()), callFrameRegister);
      storePtr(TrustedImmPtr(nullptr), Address(regT3, VM::callFrameForCatchOffset()));
  
      addPtr(TrustedImm32(stackPointerOffsetFor(codeBlock()) * sizeof(Register)), callFrameRegister, stackPointerRegister);
  
      callOperationNoExceptionCheck(operationCheckIfExceptionIsUncatchableAndNotifyProfiler);
      Jump isCatchableException = branchTest32(Zero, returnValueGPR);
<span class="udiff-line-modified-removed">-     jumpToExceptionHandler(*vm());</span>
<span class="udiff-line-modified-added">+     jumpToExceptionHandler(vm());</span>
      isCatchableException.link(this);
  
      move(TrustedImmPtr(m_vm), regT3);
      load64(Address(regT3, VM::exceptionOffset()), regT0);
      store64(TrustedImm64(JSValue::encode(JSValue())), Address(regT3, VM::exceptionOffset()));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -699,17 +723,17 @@</span>
          callOperation(operationTryOSREnterAtCatch, m_bytecodeOffset);
      else
          callOperation(operationTryOSREnterAtCatchAndValueProfile, m_bytecodeOffset);
      auto skipOSREntry = branchTestPtr(Zero, returnValueGPR);
      emitRestoreCalleeSaves();
<span class="udiff-line-modified-removed">-     jump(returnValueGPR, ExceptionHandlerPtrTag);</span>
<span class="udiff-line-modified-added">+     farJump(returnValueGPR, ExceptionHandlerPtrTag);</span>
      skipOSREntry.link(this);
      if (buffer &amp;&amp; shouldEmitProfiling()) {
          buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {
              JSValueRegs regs(regT0);
              emitGetVirtualRegister(profile.m_operand, regs);
<span class="udiff-line-modified-removed">-             emitValueProfilingSite(profile.m_profile);</span>
<span class="udiff-line-modified-added">+             emitValueProfilingSite(static_cast&lt;ValueProfile&amp;&gt;(profile));</span>
          });
      }
  #endif // ENABLE(DFG_JIT)
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -739,11 +763,11 @@</span>
      m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Immediate));
      jumpTable-&gt;ensureCTITable();
  
      emitGetVirtualRegister(scrutinee, regT0);
      callOperation(operationSwitchImmWithUnknownKeyType, regT0, tableIndex);
<span class="udiff-line-modified-removed">-     jump(returnValueGPR, JSSwitchPtrTag);</span>
<span class="udiff-line-modified-added">+     farJump(returnValueGPR, JSSwitchPtrTag);</span>
  }
  
  void JIT::emit_op_switch_char(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchChar&gt;();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -756,11 +780,11 @@</span>
      m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Character));
      jumpTable-&gt;ensureCTITable();
  
      emitGetVirtualRegister(scrutinee, regT0);
      callOperation(operationSwitchCharWithUnknownKeyType, regT0, tableIndex);
<span class="udiff-line-modified-removed">-     jump(returnValueGPR, JSSwitchPtrTag);</span>
<span class="udiff-line-modified-added">+     farJump(returnValueGPR, JSSwitchPtrTag);</span>
  }
  
  void JIT::emit_op_switch_string(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchString&gt;();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -772,11 +796,11 @@</span>
      StringJumpTable* jumpTable = &amp;m_codeBlock-&gt;stringSwitchJumpTable(tableIndex);
      m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset));
  
      emitGetVirtualRegister(scrutinee, regT0);
      callOperation(operationSwitchStringWithUnknownKeyType, regT0, tableIndex);
<span class="udiff-line-modified-removed">-     jump(returnValueGPR, JSSwitchPtrTag);</span>
<span class="udiff-line-modified-added">+     farJump(returnValueGPR, JSSwitchPtrTag);</span>
  }
  
  void JIT::emit_op_debug(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDebug&gt;();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -798,11 +822,11 @@</span>
      Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
      move(TrustedImm32(0), regT0);
      Jump wasNotMasqueradesAsUndefined = jump();
  
      isMasqueradesAsUndefined.link(this);
<span class="udiff-line-modified-removed">-     emitLoadStructure(*vm(), regT0, regT2, regT1);</span>
<span class="udiff-line-modified-added">+     emitLoadStructure(vm(), regT0, regT2, regT1);</span>
      move(TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0);
      loadPtr(Address(regT2, Structure::globalObjectOffset()), regT2);
      comparePtr(Equal, regT0, regT2, regT0);
      Jump wasNotImmediate = jump();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -831,11 +855,11 @@</span>
      Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
      move(TrustedImm32(1), regT0);
      Jump wasNotMasqueradesAsUndefined = jump();
  
      isMasqueradesAsUndefined.link(this);
<span class="udiff-line-modified-removed">-     emitLoadStructure(*vm(), regT0, regT2, regT1);</span>
<span class="udiff-line-modified-added">+     emitLoadStructure(vm(), regT0, regT2, regT1);</span>
      move(TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0);
      loadPtr(Address(regT2, Structure::globalObjectOffset()), regT2);
      comparePtr(NotEqual, regT0, regT2, regT0);
      Jump wasNotImmediate = jump();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -849,24 +873,10 @@</span>
  
      boxBoolean(regT0, JSValueRegs { regT0 });
      emitPutVirtualRegister(dst);
  }
  
<span class="udiff-line-removed">- void JIT::emit_op_enter(const Instruction*)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     // Even though CTI doesn&#39;t use them, we initialize our constant</span>
<span class="udiff-line-removed">-     // registers to zap stale pointers, to avoid unnecessarily prolonging</span>
<span class="udiff-line-removed">-     // object lifetime and increasing GC pressure.</span>
<span class="udiff-line-removed">-     size_t count = m_codeBlock-&gt;numVars();</span>
<span class="udiff-line-removed">-     for (size_t j = CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters(); j &lt; count; ++j)</span>
<span class="udiff-line-removed">-         emitInitRegister(virtualRegisterForLocal(j).offset());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     emitWriteBarrier(m_codeBlock);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     emitEnterOptimizationCheck();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void JIT::emit_op_get_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetScope&gt;();
      int dst = bytecode.m_dst.offset();
      emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, regT0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -876,19 +886,17 @@</span>
  
  void JIT::emit_op_to_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToThis&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="udiff-line-modified-removed">-     WriteBarrierBase&lt;Structure&gt;* cachedStructure = &amp;metadata.m_cachedStructure;</span>
<span class="udiff-line-modified-added">+     StructureID* cachedStructureID = &amp;metadata.m_cachedStructureID;</span>
      emitGetVirtualRegister(bytecode.m_srcDst.offset(), regT1);
  
      emitJumpSlowCaseIfNotJSCell(regT1);
  
      addSlowCase(branchIfNotType(regT1, FinalObjectType));
<span class="udiff-line-modified-removed">-     loadPtr(cachedStructure, regT2);</span>
<span class="udiff-line-removed">-     addSlowCase(branchTestPtr(Zero, regT2));</span>
<span class="udiff-line-removed">-     load32(Address(regT2, Structure::structureIDOffset()), regT2);</span>
<span class="udiff-line-modified-added">+     load32(cachedStructureID, regT2);</span>
      addSlowCase(branch32(NotEqual, Address(regT1, JSCell::structureIDOffset()), regT2));
  }
  
  void JIT::emit_op_create_this(const Instruction* currentInstruction)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -906,24 +914,22 @@</span>
  
      emitGetVirtualRegister(callee, calleeReg);
      addSlowCase(branchIfNotFunction(calleeReg));
      loadPtr(Address(calleeReg, JSFunction::offsetOfRareData()), rareDataReg);
      addSlowCase(branchTestPtr(Zero, rareDataReg));
<span class="udiff-line-modified-removed">-     loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfAllocator()), allocatorReg);</span>
<span class="udiff-line-modified-removed">-     loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfStructure()), structureReg);</span>
<span class="udiff-line-modified-added">+     loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator()), allocatorReg);</span>
<span class="udiff-line-modified-added">+     loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure()), structureReg);</span>
  
      loadPtr(cachedFunction, cachedFunctionReg);
      Jump hasSeenMultipleCallees = branchPtr(Equal, cachedFunctionReg, TrustedImmPtr(JSCell::seenMultipleCalleeObjects()));
      addSlowCase(branchPtr(NotEqual, calleeReg, cachedFunctionReg));
      hasSeenMultipleCallees.link(this);
  
      JumpList slowCases;
      auto butterfly = TrustedImmPtr(nullptr);
      emitAllocateJSObject(resultReg, JITAllocator::variable(), allocatorReg, structureReg, butterfly, scratchReg, slowCases);
<span class="udiff-line-modified-removed">-     emitGetVirtualRegister(callee, scratchReg);</span>
<span class="udiff-line-removed">-     loadPtr(Address(scratchReg, JSFunction::offsetOfRareData()), scratchReg);</span>
<span class="udiff-line-removed">-     load32(Address(scratchReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfInlineCapacity()), scratchReg);</span>
<span class="udiff-line-modified-added">+     load8(Address(structureReg, Structure::inlineCapacityOffset()), scratchReg);</span>
      emitInitializeInlineStorage(resultReg, scratchReg);
      addSlowCase(slowCases);
      emitPutVirtualRegister(bytecode.m_dst.offset());
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -998,49 +1004,47 @@</span>
  
  #endif // USE(JSVALUE64)
  
  void JIT::emit_op_loop_hint(const Instruction*)
  {
<span class="udiff-line-added">+     // Check traps.</span>
<span class="udiff-line-added">+     addSlowCase(branchTest8(NonZero, AbsoluteAddress(m_vm-&gt;needTrapHandlingAddress())));</span>
<span class="udiff-line-added">+ #if ENABLE(DFG_JIT)</span>
      // Emit the JIT optimization check:
      if (canBeOptimized()) {
          addSlowCase(branchAdd32(PositiveOrZero, TrustedImm32(Options::executionCounterIncrementForLoop()),
              AbsoluteAddress(m_codeBlock-&gt;addressOfJITExecuteCounter())));
      }
<span class="udiff-line-added">+ #endif</span>
  }
  
  void JIT::emitSlow_op_loop_hint(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
<span class="udiff-line-added">+     linkSlowCase(iter);</span>
<span class="udiff-line-added">+     callOperation(operationHandleTraps);</span>
  #if ENABLE(DFG_JIT)
      // Emit the slow path for the JIT optimization check:
      if (canBeOptimized()) {
<span class="udiff-line-modified-removed">-         linkAllSlowCases(iter);</span>
<span class="udiff-line-modified-added">+         emitJumpSlowToHot(branchAdd32(Signed, TrustedImm32(Options::executionCounterIncrementForLoop()), AbsoluteAddress(m_codeBlock-&gt;addressOfJITExecuteCounter())), currentInstruction-&gt;size());</span>
<span class="udiff-line-added">+         linkSlowCase(iter);</span>
  
<span class="udiff-line-modified-removed">-         copyCalleeSavesFromFrameOrRegisterToEntryFrameCalleeSavesBuffer(vm()-&gt;topEntryFrame);</span>
<span class="udiff-line-modified-added">+         copyCalleeSavesFromFrameOrRegisterToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);</span>
  
          callOperation(operationOptimize, m_bytecodeOffset);
<span class="udiff-line-modified-removed">-         Jump noOptimizedEntry = branchTestPtr(Zero, returnValueGPR);</span>
<span class="udiff-line-modified-added">+         emitJumpSlowToHot(branchTestPtr(Zero, returnValueGPR), currentInstruction-&gt;size());</span>
          if (!ASSERT_DISABLED) {
              Jump ok = branchPtr(MacroAssembler::Above, returnValueGPR, TrustedImmPtr(bitwise_cast&lt;void*&gt;(static_cast&lt;intptr_t&gt;(1000))));
              abortWithReason(JITUnreasonableLoopHintJumpTarget);
              ok.link(this);
          }
<span class="udiff-line-modified-removed">-         jump(returnValueGPR, GPRInfo::callFrameRegister);</span>
<span class="udiff-line-removed">-         noOptimizedEntry.link(this);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         emitJumpSlowToHot(jump(), currentInstruction-&gt;size());</span>
<span class="udiff-line-modified-added">+         farJump(returnValueGPR, GPRInfo::callFrameRegister);</span>
      }
  #else
      UNUSED_PARAM(currentInstruction);
<span class="udiff-line-removed">-     UNUSED_PARAM(iter);</span>
  #endif
  }
  
<span class="udiff-line-removed">- void JIT::emit_op_check_traps(const Instruction*)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     addSlowCase(branchTest8(NonZero, AbsoluteAddress(m_vm-&gt;needTrapHandlingAddress())));</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void JIT::emit_op_nop(const Instruction*)
  {
  }
  
  void JIT::emit_op_super_sampler_begin(const Instruction*)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1051,15 +1055,50 @@</span>
  void JIT::emit_op_super_sampler_end(const Instruction*)
  {
      sub32(TrustedImm32(1), AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
  }
  
<span class="udiff-line-modified-removed">- void JIT::emitSlow_op_check_traps(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)</span>
<span class="udiff-line-modified-added">+ void JIT::emit_op_enter(const Instruction*)</span>
  {
<span class="udiff-line-modified-removed">-     linkAllSlowCases(iter);</span>
<span class="udiff-line-modified-added">+     // Even though JIT doesn&#39;t use them, we initialize our constant</span>
<span class="udiff-line-added">+     // registers to zap stale pointers, to avoid unnecessarily prolonging</span>
<span class="udiff-line-added">+     // object lifetime and increasing GC pressure.</span>
<span class="udiff-line-added">+     size_t count = m_codeBlock-&gt;numVars();</span>
<span class="udiff-line-added">+     for (size_t i = CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters(); i &lt; count; ++i)</span>
<span class="udiff-line-added">+         emitInitRegister(virtualRegisterForLocal(i).offset());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     emitWriteBarrier(m_codeBlock);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Check traps.</span>
<span class="udiff-line-added">+     addSlowCase(branchTest8(NonZero, AbsoluteAddress(m_vm-&gt;needTrapHandlingAddress())));</span>
  
<span class="udiff-line-added">+ #if ENABLE(DFG_JIT)</span>
<span class="udiff-line-added">+     if (canBeOptimized())</span>
<span class="udiff-line-added">+         addSlowCase(branchAdd32(PositiveOrZero, TrustedImm32(Options::executionCounterIncrementForEntry()), AbsoluteAddress(m_codeBlock-&gt;addressOfJITExecuteCounter())));</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void JIT::emitSlow_op_enter(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     linkSlowCase(iter);</span>
      callOperation(operationHandleTraps);
<span class="udiff-line-added">+ #if ENABLE(DFG_JIT)</span>
<span class="udiff-line-added">+     if (canBeOptimized()) {</span>
<span class="udiff-line-added">+         emitJumpSlowToHot(branchAdd32(Signed, TrustedImm32(Options::executionCounterIncrementForEntry()), AbsoluteAddress(m_codeBlock-&gt;addressOfJITExecuteCounter())), currentInstruction-&gt;size());</span>
<span class="udiff-line-added">+         linkSlowCase(iter);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ASSERT(!m_bytecodeOffset);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         copyCalleeSavesFromFrameOrRegisterToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         callOperation(operationOptimize, m_bytecodeOffset);</span>
<span class="udiff-line-added">+         emitJumpSlowToHot(branchTestPtr(Zero, returnValueGPR), currentInstruction-&gt;size());</span>
<span class="udiff-line-added">+         farJump(returnValueGPR, GPRInfo::callFrameRegister);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     UNUSED_PARAM(currentInstruction);</span>
<span class="udiff-line-added">+ #endif</span>
  }
  
  void JIT::emit_op_new_regexp(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNewRegexp&gt;();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1247,10 +1286,12 @@</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
      ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
  
      emitGetVirtualRegisters(base, regT0, property, regT1);
  
<span class="udiff-line-added">+     emitJumpSlowCaseIfNotInt(regT1);</span>
<span class="udiff-line-added">+ </span>
      // This is technically incorrect - we&#39;re zero-extending an int32. On the hot path this doesn&#39;t matter.
      // We check the value as if it was a uint32 against the m_vectorLength - which will always fail if
      // number was signed since m_vectorLength is always less than intmax (since the total allocation
      // size is always less than 4Gb). As such zero extending will have been correct (and extending the value
      // to 64-bits is necessary since it&#39;s used in the address calculation. We zero extend rather than sign
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1456,32 +1497,32 @@</span>
      jumpToEnd.link(this);
  }
  
  void JIT::emit_op_log_shadow_chicken_prologue(const Instruction* currentInstruction)
  {
<span class="udiff-line-modified-removed">-     RELEASE_ASSERT(vm()-&gt;shadowChicken());</span>
<span class="udiff-line-modified-added">+     RELEASE_ASSERT(vm().shadowChicken());</span>
      updateTopCallFrame();
      static_assert(nonArgGPR0 != regT0 &amp;&amp; nonArgGPR0 != regT2, &quot;we will have problems if this is true.&quot;);
      auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenPrologue&gt;();
      GPRReg shadowPacketReg = regT0;
      GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
      GPRReg scratch2Reg = regT2;
<span class="udiff-line-modified-removed">-     ensureShadowChickenPacket(*vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
<span class="udiff-line-modified-added">+     ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
      emitGetVirtualRegister(bytecode.m_scope.offset(), regT3);
      logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, regT3);
  }
  
  void JIT::emit_op_log_shadow_chicken_tail(const Instruction* currentInstruction)
  {
<span class="udiff-line-modified-removed">-     RELEASE_ASSERT(vm()-&gt;shadowChicken());</span>
<span class="udiff-line-modified-added">+     RELEASE_ASSERT(vm().shadowChicken());</span>
      updateTopCallFrame();
      static_assert(nonArgGPR0 != regT0 &amp;&amp; nonArgGPR0 != regT2, &quot;we will have problems if this is true.&quot;);
      auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenTail&gt;();
      GPRReg shadowPacketReg = regT0;
      GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
      GPRReg scratch2Reg = regT2;
<span class="udiff-line-modified-removed">-     ensureShadowChickenPacket(*vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
<span class="udiff-line-modified-added">+     ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
      emitGetVirtualRegister(bytecode.m_thisValue.offset(), regT2);
      emitGetVirtualRegister(bytecode.m_scope.offset(), regT3);
      logShadowChickenTailPacket(shadowPacketReg, JSValueRegs(regT2), regT3, m_codeBlock, CallSiteIndex(m_bytecodeOffset));
  }
  
</pre>
<center><a href="JITMathIC.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOpcodes32_64.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>