<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSSelectorParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Copyright 2014 The Chromium Authors. All rights reserved.
  2 // Copyright (C) 2016 Apple Inc. All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //    * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //    * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //    * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;CSSSelectorParser.h&quot;
 32 
 33 #include &quot;CSSParserContext.h&quot;
 34 #include &quot;CSSSelectorList.h&quot;
 35 #include &quot;StyleSheetContents.h&quot;
 36 #include &lt;memory&gt;
 37 
 38 namespace WebCore {
 39 
 40 CSSSelectorList CSSSelectorParser::parseSelector(CSSParserTokenRange range, const CSSParserContext&amp; context, StyleSheetContents* styleSheet)
 41 {
 42     CSSSelectorParser parser(context, styleSheet);
 43     range.consumeWhitespace();
 44     CSSSelectorList result = parser.consumeComplexSelectorList(range);
 45     if (!range.atEnd())
 46         return CSSSelectorList();
 47     return result;
 48 }
 49 
 50 CSSSelectorParser::CSSSelectorParser(const CSSParserContext&amp; context, StyleSheetContents* styleSheet)
 51     : m_context(context)
 52     , m_styleSheet(styleSheet)
 53 {
 54 }
 55 
 56 CSSSelectorList CSSSelectorParser::consumeComplexSelectorList(CSSParserTokenRange&amp; range)
 57 {
 58     Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt; selectorList;
 59     std::unique_ptr&lt;CSSParserSelector&gt; selector = consumeComplexSelector(range);
 60     if (!selector)
 61         return CSSSelectorList();
 62     selectorList.append(WTFMove(selector));
 63     while (!range.atEnd() &amp;&amp; range.peek().type() == CommaToken) {
 64         range.consumeIncludingWhitespace();
 65         selector = consumeComplexSelector(range);
 66         if (!selector)
 67             return CSSSelectorList();
 68         selectorList.append(WTFMove(selector));
 69     }
 70 
 71     if (m_failedParsing)
 72         return { };
 73     return CSSSelectorList { WTFMove(selectorList) };
 74 }
 75 
 76 CSSSelectorList CSSSelectorParser::consumeCompoundSelectorList(CSSParserTokenRange&amp; range)
 77 {
 78     Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt; selectorList;
 79     std::unique_ptr&lt;CSSParserSelector&gt; selector = consumeCompoundSelector(range);
 80     range.consumeWhitespace();
 81     if (!selector)
 82         return CSSSelectorList();
 83     selectorList.append(WTFMove(selector));
 84     while (!range.atEnd() &amp;&amp; range.peek().type() == CommaToken) {
 85         range.consumeIncludingWhitespace();
 86         selector = consumeCompoundSelector(range);
 87         range.consumeWhitespace();
 88         if (!selector)
 89             return CSSSelectorList();
 90         selectorList.append(WTFMove(selector));
 91     }
 92 
 93     if (m_failedParsing)
 94         return { };
 95     return CSSSelectorList { WTFMove(selectorList) };
 96 }
 97 
 98 static bool consumeLangArgumentList(std::unique_ptr&lt;Vector&lt;AtomicString&gt;&gt;&amp; argumentList, CSSParserTokenRange&amp; range)
 99 {
100     const CSSParserToken&amp; ident = range.consumeIncludingWhitespace();
101     if (ident.type() != IdentToken &amp;&amp; ident.type() != StringToken)
102         return false;
103     StringView string = ident.value();
104     if (string.startsWith(&quot;--&quot;))
105         return false;
106     argumentList-&gt;append(string.toAtomicString());
107     while (!range.atEnd() &amp;&amp; range.peek().type() == CommaToken) {
108         range.consumeIncludingWhitespace();
109         const CSSParserToken&amp; ident = range.consumeIncludingWhitespace();
110         if (ident.type() != IdentToken &amp;&amp; ident.type() != StringToken)
111             return false;
112         StringView string = ident.value();
113         if (string.startsWith(&quot;--&quot;))
114             return false;
115         argumentList-&gt;append(string.toAtomicString());
116     }
117     return range.atEnd();
118 }
119 
120 namespace {
121 
122 enum CompoundSelectorFlags {
123     HasPseudoElementForRightmostCompound = 1 &lt;&lt; 0,
124     HasContentPseudoElement = 1 &lt;&lt; 1
125 };
126 
127 unsigned extractCompoundFlags(const CSSParserSelector&amp; simpleSelector, CSSParserMode parserMode)
128 {
129     if (simpleSelector.match() != CSSSelector::PseudoElement)
130         return 0;
131 
132     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=161747
133     // The UASheetMode check is a work-around to allow this selector in mediaControls(New).css:
134     // input[type=&quot;range&quot; i]::-webkit-media-slider-container &gt; div {
135     if (parserMode == UASheetMode &amp;&amp; simpleSelector.pseudoElementType() == CSSSelector::PseudoElementWebKitCustom)
136         return 0;
137     return HasPseudoElementForRightmostCompound;
138 }
139 
140 } // namespace
141 
142 static bool isDescendantCombinator(CSSSelector::RelationType relation)
143 {
144     return relation == CSSSelector::DescendantSpace;
145 }
146 
147 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeComplexSelector(CSSParserTokenRange&amp; range)
148 {
149     std::unique_ptr&lt;CSSParserSelector&gt; selector = consumeCompoundSelector(range);
150     if (!selector)
151         return nullptr;
152 
153     unsigned previousCompoundFlags = 0;
154 
155     for (CSSParserSelector* simple = selector.get(); simple &amp;&amp; !previousCompoundFlags; simple = simple-&gt;tagHistory())
156         previousCompoundFlags |= extractCompoundFlags(*simple, m_context.mode);
157 
158     while (auto combinator = consumeCombinator(range)) {
159         std::unique_ptr&lt;CSSParserSelector&gt; nextSelector = consumeCompoundSelector(range);
160         if (!nextSelector)
161             return isDescendantCombinator(combinator) ? WTFMove(selector) : nullptr;
162         if (previousCompoundFlags &amp; HasPseudoElementForRightmostCompound)
163             return nullptr;
164         CSSParserSelector* end = nextSelector.get();
165         unsigned compoundFlags = extractCompoundFlags(*end, m_context.mode);
166         while (end-&gt;tagHistory()) {
167             end = end-&gt;tagHistory();
168             compoundFlags |= extractCompoundFlags(*end, m_context.mode);
169         }
170         end-&gt;setRelation(combinator);
171         previousCompoundFlags = compoundFlags;
172         end-&gt;setTagHistory(WTFMove(selector));
173 
174         selector = WTFMove(nextSelector);
175     }
176 
177     return selector;
178 }
179 
180 namespace {
181 
182 bool isScrollbarPseudoClass(CSSSelector::PseudoClassType pseudo)
183 {
184     switch (pseudo) {
185     case CSSSelector::PseudoClassEnabled:
186     case CSSSelector::PseudoClassDisabled:
187     case CSSSelector::PseudoClassHover:
188     case CSSSelector::PseudoClassActive:
189     case CSSSelector::PseudoClassHorizontal:
190     case CSSSelector::PseudoClassVertical:
191     case CSSSelector::PseudoClassDecrement:
192     case CSSSelector::PseudoClassIncrement:
193     case CSSSelector::PseudoClassStart:
194     case CSSSelector::PseudoClassEnd:
195     case CSSSelector::PseudoClassDoubleButton:
196     case CSSSelector::PseudoClassSingleButton:
197     case CSSSelector::PseudoClassNoButton:
198     case CSSSelector::PseudoClassCornerPresent:
199     case CSSSelector::PseudoClassWindowInactive:
200         return true;
201     default:
202         return false;
203     }
204 }
205 
206 bool isUserActionPseudoClass(CSSSelector::PseudoClassType pseudo)
207 {
208     switch (pseudo) {
209     case CSSSelector::PseudoClassHover:
210     case CSSSelector::PseudoClassFocus:
211     case CSSSelector::PseudoClassActive:
212         return true;
213     default:
214         return false;
215     }
216 }
217 
218 bool isPseudoClassValidAfterPseudoElement(CSSSelector::PseudoClassType pseudoClass, CSSSelector::PseudoElementType compoundPseudoElement)
219 {
220     switch (compoundPseudoElement) {
221     case CSSSelector::PseudoElementResizer:
222     case CSSSelector::PseudoElementScrollbar:
223     case CSSSelector::PseudoElementScrollbarCorner:
224     case CSSSelector::PseudoElementScrollbarButton:
225     case CSSSelector::PseudoElementScrollbarThumb:
226     case CSSSelector::PseudoElementScrollbarTrack:
227     case CSSSelector::PseudoElementScrollbarTrackPiece:
228         return isScrollbarPseudoClass(pseudoClass);
229     case CSSSelector::PseudoElementSelection:
230         return pseudoClass == CSSSelector::PseudoClassWindowInactive;
231     case CSSSelector::PseudoElementWebKitCustom:
232     case CSSSelector::PseudoElementWebKitCustomLegacyPrefixed:
233         return isUserActionPseudoClass(pseudoClass);
234     default:
235         return false;
236     }
237 }
238 
239 bool isSimpleSelectorValidAfterPseudoElement(const CSSParserSelector&amp; simpleSelector, CSSSelector::PseudoElementType compoundPseudoElement)
240 {
241     if (compoundPseudoElement == CSSSelector::PseudoElementUnknown)
242         return true;
243     // FIXME-NEWPARSER: This doesn&#39;t exist for us.
244     // if (compoundPseudoElement == CSSSelector::PseudoElementContent)
245     //    return simpleSelector.match() != CSSSelector::PseudoElement;
246     if (simpleSelector.match() != CSSSelector::PseudoClass)
247         return false;
248     CSSSelector::PseudoClassType pseudo = simpleSelector.pseudoClassType();
249     if (pseudo == CSSSelector::PseudoClassNot) {
250         ASSERT(simpleSelector.selectorList());
251         ASSERT(simpleSelector.selectorList()-&gt;first());
252         pseudo = simpleSelector.selectorList()-&gt;first()-&gt;pseudoClassType();
253     }
254     return isPseudoClassValidAfterPseudoElement(pseudo, compoundPseudoElement);
255 }
256 
257 } // namespace
258 
259 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeCompoundSelector(CSSParserTokenRange&amp; range)
260 {
261     std::unique_ptr&lt;CSSParserSelector&gt; compoundSelector;
262 
263     AtomicString namespacePrefix;
264     AtomicString elementName;
265     CSSSelector::PseudoElementType compoundPseudoElement = CSSSelector::PseudoElementUnknown;
266     if (!consumeName(range, elementName, namespacePrefix)) {
267         compoundSelector = consumeSimpleSelector(range);
268         if (!compoundSelector)
269             return nullptr;
270         if (compoundSelector-&gt;match() == CSSSelector::PseudoElement)
271             compoundPseudoElement = compoundSelector-&gt;pseudoElementType();
272     }
273 
274     while (std::unique_ptr&lt;CSSParserSelector&gt; simpleSelector = consumeSimpleSelector(range)) {
275         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=161747
276         // The UASheetMode check is a work-around to allow this selector in mediaControls(New).css:
277         // video::-webkit-media-text-track-region-container.scrolling
278         if (m_context.mode != UASheetMode &amp;&amp; !isSimpleSelectorValidAfterPseudoElement(*simpleSelector.get(), compoundPseudoElement)) {
279             m_failedParsing = true;
280             return nullptr;
281         }
282         if (simpleSelector-&gt;match() == CSSSelector::PseudoElement)
283             compoundPseudoElement = simpleSelector-&gt;pseudoElementType();
284 
285         if (compoundSelector)
286             compoundSelector = addSimpleSelectorToCompound(WTFMove(compoundSelector), WTFMove(simpleSelector));
287         else
288             compoundSelector = WTFMove(simpleSelector);
289     }
290 
291     if (!compoundSelector) {
292         AtomicString namespaceURI = determineNamespace(namespacePrefix);
293         if (namespaceURI.isNull()) {
294             m_failedParsing = true;
295             return nullptr;
296         }
297         if (namespaceURI == defaultNamespace())
298             namespacePrefix = nullAtom();
299 
300         CSSParserSelector* rawSelector = new CSSParserSelector(QualifiedName(namespacePrefix, elementName, namespaceURI));
301         std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(rawSelector);
302         return selector;
303     }
304     prependTypeSelectorIfNeeded(namespacePrefix, elementName, compoundSelector.get());
305     return splitCompoundAtImplicitShadowCrossingCombinator(WTFMove(compoundSelector), m_context);
306 }
307 
308 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeSimpleSelector(CSSParserTokenRange&amp; range)
309 {
310     const CSSParserToken&amp; token = range.peek();
311     std::unique_ptr&lt;CSSParserSelector&gt; selector;
312     if (token.type() == HashToken)
313         selector = consumeId(range);
314     else if (token.type() == DelimiterToken &amp;&amp; token.delimiter() == &#39;.&#39;)
315         selector = consumeClass(range);
316     else if (token.type() == LeftBracketToken)
317         selector = consumeAttribute(range);
318     else if (token.type() == ColonToken)
319         selector = consumePseudo(range);
320     else
321         return nullptr;
322     if (!selector)
323         m_failedParsing = true;
324     return selector;
325 }
326 
327 bool CSSSelectorParser::consumeName(CSSParserTokenRange&amp; range, AtomicString&amp; name, AtomicString&amp; namespacePrefix)
328 {
329     name = nullAtom();
330     namespacePrefix = nullAtom();
331 
332     const CSSParserToken&amp; firstToken = range.peek();
333     if (firstToken.type() == IdentToken) {
334         name = firstToken.value().toAtomicString();
335         range.consume();
336     } else if (firstToken.type() == DelimiterToken &amp;&amp; firstToken.delimiter() == &#39;*&#39;) {
337         name = starAtom();
338         range.consume();
339     } else if (firstToken.type() == DelimiterToken &amp;&amp; firstToken.delimiter() == &#39;|&#39;) {
340         // This is an empty namespace, which&#39;ll get assigned this value below
341         name = emptyAtom();
342     } else
343         return false;
344 
345     if (range.peek().type() != DelimiterToken || range.peek().delimiter() != &#39;|&#39;)
346         return true;
347     range.consume();
348 
349     namespacePrefix = name;
350     const CSSParserToken&amp; nameToken = range.consume();
351     if (nameToken.type() == IdentToken) {
352         name = nameToken.value().toAtomicString();
353     } else if (nameToken.type() == DelimiterToken &amp;&amp; nameToken.delimiter() == &#39;*&#39;)
354         name = starAtom();
355     else {
356         name = nullAtom();
357         namespacePrefix = nullAtom();
358         return false;
359     }
360 
361     return true;
362 }
363 
364 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeId(CSSParserTokenRange&amp; range)
365 {
366     ASSERT(range.peek().type() == HashToken);
367     if (range.peek().getHashTokenType() != HashTokenId)
368         return nullptr;
369     std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(new CSSParserSelector());
370     selector-&gt;setMatch(CSSSelector::Id);
371 
372     // FIXME-NEWPARSER: Avoid having to do this, but the old parser does and we need
373     // to be compatible for now.
374     CSSParserToken token = range.consume();
375     selector-&gt;setValue(token.value().toAtomicString(), m_context.mode == HTMLQuirksMode);
376     return selector;
377 }
378 
379 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeClass(CSSParserTokenRange&amp; range)
380 {
381     ASSERT(range.peek().type() == DelimiterToken);
382     ASSERT(range.peek().delimiter() == &#39;.&#39;);
383     range.consume();
384     if (range.peek().type() != IdentToken)
385         return nullptr;
386     std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(new CSSParserSelector());
387     selector-&gt;setMatch(CSSSelector::Class);
388 
389     // FIXME-NEWPARSER: Avoid having to do this, but the old parser does and we need
390     // to be compatible for now.
391     CSSParserToken token = range.consume();
392     selector-&gt;setValue(token.value().toAtomicString(), m_context.mode == HTMLQuirksMode);
393 
394     return selector;
395 }
396 
397 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeAttribute(CSSParserTokenRange&amp; range)
398 {
399     ASSERT(range.peek().type() == LeftBracketToken);
400     CSSParserTokenRange block = range.consumeBlock();
401     if (block.end() == range.end())
402         return nullptr; // No ] was found. Be strict about this.
403 
404     block.consumeWhitespace();
405 
406     AtomicString namespacePrefix;
407     AtomicString attributeName;
408     if (!consumeName(block, attributeName, namespacePrefix))
409         return nullptr;
410     block.consumeWhitespace();
411 
412     AtomicString namespaceURI = determineNamespace(namespacePrefix);
413     if (namespaceURI.isNull())
414         return nullptr;
415 
416     QualifiedName qualifiedName = namespacePrefix.isNull()
417         ? QualifiedName(nullAtom(), attributeName, nullAtom())
418         : QualifiedName(namespacePrefix, attributeName, namespaceURI);
419 
420     std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(new CSSParserSelector());
421 
422     if (block.atEnd()) {
423         selector-&gt;setAttribute(qualifiedName, m_context.isHTMLDocument, CSSSelector::CaseSensitive);
424         selector-&gt;setMatch(CSSSelector::Set);
425         return selector;
426     }
427 
428     selector-&gt;setMatch(consumeAttributeMatch(block));
429 
430     const CSSParserToken&amp; attributeValue = block.consumeIncludingWhitespace();
431     if (attributeValue.type() != IdentToken &amp;&amp; attributeValue.type() != StringToken)
432         return nullptr;
433     selector-&gt;setValue(attributeValue.value().toAtomicString());
434 
435     selector-&gt;setAttribute(qualifiedName, m_context.isHTMLDocument, consumeAttributeFlags(block));
436 
437     if (!block.atEnd())
438         return nullptr;
439     return selector;
440 }
441 
442 static bool isOnlyPseudoClassFunction(CSSSelector::PseudoClassType pseudoClassType)
443 {
444     switch (pseudoClassType) {
445     case CSSSelector::PseudoClassNot:
446     case CSSSelector::PseudoClassMatches:
447     case CSSSelector::PseudoClassNthChild:
448     case CSSSelector::PseudoClassNthLastChild:
449     case CSSSelector::PseudoClassNthOfType:
450     case CSSSelector::PseudoClassNthLastOfType:
451     case CSSSelector::PseudoClassLang:
452     case CSSSelector::PseudoClassAny:
453 #if ENABLE(CSS_SELECTORS_LEVEL4)
454     case CSSSelector::PseudoClassDir:
455     case CSSSelector::PseudoClassRole:
456 #endif
457         return true;
458     default:
459         break;
460     }
461     return false;
462 }
463 
464 static bool isOnlyPseudoElementFunction(CSSSelector::PseudoElementType pseudoElementType)
465 {
466     // Note that we omit cue since it can be both an ident or a function.
467     switch (pseudoElementType) {
468     case CSSSelector::PseudoElementSlotted:
469         return true;
470     default:
471         break;
472     }
473     return false;
474 }
475 
476 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumePseudo(CSSParserTokenRange&amp; range)
477 {
478     ASSERT(range.peek().type() == ColonToken);
479     range.consume();
480 
481     int colons = 1;
482     if (range.peek().type() == ColonToken) {
483         range.consume();
484         colons++;
485     }
486 
487     const CSSParserToken&amp; token = range.peek();
488     if (token.type() != IdentToken &amp;&amp; token.type() != FunctionToken)
489         return nullptr;
490 
491     std::unique_ptr&lt;CSSParserSelector&gt; selector;
492 
493     auto lowercasedValue = token.value().convertToASCIILowercase();
494     auto value = StringView { lowercasedValue };
495 
496     if (colons == 1) {
497         selector = std::unique_ptr&lt;CSSParserSelector&gt;(CSSParserSelector::parsePseudoClassSelectorFromStringView(value));
498 #if ENABLE(ATTACHMENT_ELEMENT)
499         if (!m_context.attachmentEnabled &amp;&amp; selector &amp;&amp; selector-&gt;match() == CSSSelector::PseudoClass &amp;&amp; selector-&gt;pseudoClassType() == CSSSelector::PseudoClassHasAttachment)
500             return nullptr;
501 #endif
502     } else {
503         selector = std::unique_ptr&lt;CSSParserSelector&gt;(CSSParserSelector::parsePseudoElementSelectorFromStringView(value));
504 #if ENABLE(VIDEO_TRACK)
505         // Treat the ident version of cue as PseudoElementWebkitCustom.
506         if (token.type() == IdentToken &amp;&amp; selector &amp;&amp; selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; selector-&gt;pseudoElementType() == CSSSelector::PseudoElementCue)
507             selector-&gt;setPseudoElementType(CSSSelector::PseudoElementWebKitCustom);
508 #endif
509     }
510 
511     if (!selector || (selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; m_disallowPseudoElements))
512         return nullptr;
513 
514     if (token.type() == IdentToken) {
515         range.consume();
516         if ((selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; (selector-&gt;pseudoElementType() == CSSSelector::PseudoElementUnknown || isOnlyPseudoElementFunction(selector-&gt;pseudoElementType())))
517             || (selector-&gt;match() == CSSSelector::PseudoClass &amp;&amp; (selector-&gt;pseudoClassType() == CSSSelector::PseudoClassUnknown || isOnlyPseudoClassFunction(selector-&gt;pseudoClassType()))))
518             return nullptr;
519         return selector;
520     }
521 
522     CSSParserTokenRange block = range.consumeBlock();
523     if (block.end() == range.end())
524         return nullptr; // No ) was found. Be strict about this.
525     block.consumeWhitespace();
526     if (token.type() != FunctionToken)
527         return nullptr;
528 
529     const auto&amp; argumentStart = block.peek();
530 
531     if (selector-&gt;match() == CSSSelector::PseudoClass) {
532         switch (selector-&gt;pseudoClassType()) {
533         case CSSSelector::PseudoClassNot: {
534             DisallowPseudoElementsScope scope(this);
535             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
536             *selectorList = consumeComplexSelectorList(block);
537             if (!selectorList-&gt;first() || !block.atEnd())
538                 return nullptr;
539             selector-&gt;setSelectorList(WTFMove(selectorList));
540             return selector;
541         }
542         case CSSSelector::PseudoClassNthChild:
543         case CSSSelector::PseudoClassNthLastChild:
544         case CSSSelector::PseudoClassNthOfType:
545         case CSSSelector::PseudoClassNthLastOfType: {
546             std::pair&lt;int, int&gt; ab;
547             if (!consumeANPlusB(block, ab))
548                 return nullptr;
549             block.consumeWhitespace();
550             const auto&amp; argumentEnd = block.peek();
551             auto rangeOfANPlusB = block.makeSubRange(&amp;argumentStart, &amp;argumentEnd);
552             auto argument = rangeOfANPlusB.serialize();
553             selector-&gt;setArgument(argument.stripWhiteSpace());
554             if (!block.atEnd()) {
555                 if (block.peek().type() != IdentToken)
556                     return nullptr;
557                 const CSSParserToken&amp; ident = block.consume();
558                 if (!equalIgnoringASCIICase(ident.value(), &quot;of&quot;))
559                     return nullptr;
560                 if (block.peek().type() != WhitespaceToken)
561                     return nullptr;
562                 DisallowPseudoElementsScope scope(this);
563                 block.consumeWhitespace();
564                 std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
565                 *selectorList = consumeComplexSelectorList(block);
566                 if (!selectorList-&gt;first() || !block.atEnd())
567                     return nullptr;
568                 selector-&gt;setSelectorList(WTFMove(selectorList));
569             }
570             selector-&gt;setNth(ab.first, ab.second);
571             return selector;
572         }
573         case CSSSelector::PseudoClassLang: {
574             // FIXME: CSS Selectors Level 4 allows :lang(*-foo)
575             auto argumentList = std::make_unique&lt;Vector&lt;AtomicString&gt;&gt;();
576             if (!consumeLangArgumentList(argumentList, block))
577                 return nullptr;
578             selector-&gt;setLangArgumentList(WTFMove(argumentList));
579             return selector;
580         }
581         case CSSSelector::PseudoClassMatches: {
582             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
583             *selectorList = consumeComplexSelectorList(block);
584             if (!selectorList-&gt;first() || !block.atEnd())
585                 return nullptr;
586             selector-&gt;setSelectorList(WTFMove(selectorList));
587             return selector;
588         }
589         case CSSSelector::PseudoClassAny:
590         case CSSSelector::PseudoClassHost: {
591             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
592             *selectorList = consumeCompoundSelectorList(block);
593             if (!selectorList-&gt;first() || !block.atEnd())
594                 return nullptr;
595             selector-&gt;setSelectorList(WTFMove(selectorList));
596             return selector;
597         }
598 #if ENABLE(CSS_SELECTORS_LEVEL4)
599         case CSSSelector::PseudoClassDir:
600         case CSSSelector::PseudoClassRole: {
601             const CSSParserToken&amp; ident = block.consumeIncludingWhitespace();
602             if (ident.type() != IdentToken || !block.atEnd())
603                 return nullptr;
604             selector-&gt;setArgument(ident.value().toAtomicString());
605             return selector;
606         }
607 #endif
608         default:
609             break;
610         }
611 
612     }
613 
614     if (selector-&gt;match() == CSSSelector::PseudoElement) {
615         switch (selector-&gt;pseudoElementType()) {
616 #if ENABLE(VIDEO_TRACK)
617         case CSSSelector::PseudoElementCue: {
618             DisallowPseudoElementsScope scope(this);
619             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
620             *selectorList = consumeCompoundSelectorList(block);
621             if (!selectorList-&gt;isValid() || !block.atEnd())
622                 return nullptr;
623             selector-&gt;setSelectorList(WTFMove(selectorList));
624             return selector;
625         }
626 #endif
627         case CSSSelector::PseudoElementSlotted: {
628             DisallowPseudoElementsScope scope(this);
629 
630             std::unique_ptr&lt;CSSParserSelector&gt; innerSelector = consumeCompoundSelector(block);
631             block.consumeWhitespace();
632             if (!innerSelector || !block.atEnd())
633                 return nullptr;
634             selector-&gt;adoptSelectorVector(Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt;::from(WTFMove(innerSelector)));
635             return selector;
636         }
637         default:
638             break;
639         }
640     }
641 
642     return nullptr;
643 }
644 
645 CSSSelector::RelationType CSSSelectorParser::consumeCombinator(CSSParserTokenRange&amp; range)
646 {
647     auto fallbackResult = CSSSelector::Subselector;
648     while (range.peek().type() == WhitespaceToken) {
649         range.consume();
650         fallbackResult = CSSSelector::DescendantSpace;
651     }
652 
653     if (range.peek().type() != DelimiterToken)
654         return fallbackResult;
655 
656     UChar delimiter = range.peek().delimiter();
657 
658     if (delimiter == &#39;+&#39; || delimiter == &#39;~&#39; || delimiter == &#39;&gt;&#39;) {
659         range.consumeIncludingWhitespace();
660         if (delimiter == &#39;+&#39;)
661             return CSSSelector::DirectAdjacent;
662         if (delimiter == &#39;~&#39;)
663             return CSSSelector::IndirectAdjacent;
664         return CSSSelector::Child;
665     }
666 
667     return fallbackResult;
668 }
669 
670 CSSSelector::Match CSSSelectorParser::consumeAttributeMatch(CSSParserTokenRange&amp; range)
671 {
672     const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
673     switch (token.type()) {
674     case IncludeMatchToken:
675         return CSSSelector::List;
676     case DashMatchToken:
677         return CSSSelector::Hyphen;
678     case PrefixMatchToken:
679         return CSSSelector::Begin;
680     case SuffixMatchToken:
681         return CSSSelector::End;
682     case SubstringMatchToken:
683         return CSSSelector::Contain;
684     case DelimiterToken:
685         if (token.delimiter() == &#39;=&#39;)
686             return CSSSelector::Exact;
687         FALLTHROUGH;
688     default:
689         m_failedParsing = true;
690         return CSSSelector::Exact;
691     }
692 }
693 
694 CSSSelector::AttributeMatchType CSSSelectorParser::consumeAttributeFlags(CSSParserTokenRange&amp; range)
695 {
696     if (range.peek().type() != IdentToken)
697         return CSSSelector::CaseSensitive;
698     const CSSParserToken&amp; flag = range.consumeIncludingWhitespace();
699     if (equalIgnoringASCIICase(flag.value(), &quot;i&quot;))
700         return CSSSelector::CaseInsensitive;
701     m_failedParsing = true;
702     return CSSSelector::CaseSensitive;
703 }
704 
705 bool CSSSelectorParser::consumeANPlusB(CSSParserTokenRange&amp; range, std::pair&lt;int, int&gt;&amp; result)
706 {
707     const CSSParserToken&amp; token = range.consume();
708     if (token.type() == NumberToken &amp;&amp; token.numericValueType() == IntegerValueType) {
709         result = std::make_pair(0, static_cast&lt;int&gt;(token.numericValue()));
710         return true;
711     }
712     if (token.type() == IdentToken) {
713         if (equalIgnoringASCIICase(token.value(), &quot;odd&quot;)) {
714             result = std::make_pair(2, 1);
715             return true;
716         }
717         if (equalIgnoringASCIICase(token.value(), &quot;even&quot;)) {
718             result = std::make_pair(2, 0);
719             return true;
720         }
721     }
722 
723     // The &#39;n&#39; will end up as part of an ident or dimension. For a valid &lt;an+b&gt;,
724     // this will store a string of the form &#39;n&#39;, &#39;n-&#39;, or &#39;n-123&#39;.
725     String nString;
726 
727     if (token.type() == DelimiterToken &amp;&amp; token.delimiter() == &#39;+&#39; &amp;&amp; range.peek().type() == IdentToken) {
728         result.first = 1;
729         nString = range.consume().value().toString();
730     } else if (token.type() == DimensionToken &amp;&amp; token.numericValueType() == IntegerValueType) {
731         result.first = token.numericValue();
732         nString = token.value().toString();
733     } else if (token.type() == IdentToken) {
734         if (token.value()[0] == &#39;-&#39;) {
735             result.first = -1;
736             nString = token.value().substring(1).toString();
737         } else {
738             result.first = 1;
739             nString = token.value().toString();
740         }
741     }
742 
743     range.consumeWhitespace();
744 
745     if (nString.isEmpty() || !isASCIIAlphaCaselessEqual(nString[0], &#39;n&#39;))
746         return false;
747     if (nString.length() &gt; 1 &amp;&amp; nString[1] != &#39;-&#39;)
748         return false;
749 
750     if (nString.length() &gt; 2) {
751         bool valid;
752         result.second = nString.substring(1).toIntStrict(&amp;valid);
753         return valid;
754     }
755 
756     NumericSign sign = nString.length() == 1 ? NoSign : MinusSign;
757     if (sign == NoSign &amp;&amp; range.peek().type() == DelimiterToken) {
758         char delimiterSign = range.consumeIncludingWhitespace().delimiter();
759         if (delimiterSign == &#39;+&#39;)
760             sign = PlusSign;
761         else if (delimiterSign == &#39;-&#39;)
762             sign = MinusSign;
763         else
764             return false;
765     }
766 
767     if (sign == NoSign &amp;&amp; range.peek().type() != NumberToken) {
768         result.second = 0;
769         return true;
770     }
771 
772     const CSSParserToken&amp; b = range.consume();
773     if (b.type() != NumberToken || b.numericValueType() != IntegerValueType)
774         return false;
775     if ((b.numericSign() == NoSign) == (sign == NoSign))
776         return false;
777     result.second = b.numericValue();
778     if (sign == MinusSign)
779         result.second = -result.second;
780     return true;
781 }
782 
783 const AtomicString&amp; CSSSelectorParser::defaultNamespace() const
784 {
785     if (!m_styleSheet)
786         return starAtom();
787     return m_styleSheet-&gt;defaultNamespace();
788 }
789 
790 const AtomicString&amp; CSSSelectorParser::determineNamespace(const AtomicString&amp; prefix)
791 {
792     if (prefix.isNull())
793         return defaultNamespace();
794     if (prefix.isEmpty())
795         return emptyAtom(); // No namespace. If an element/attribute has a namespace, we won&#39;t match it.
796     if (prefix == starAtom())
797         return starAtom(); // We&#39;ll match any namespace.
798     if (!m_styleSheet)
799         return nullAtom(); // Cannot resolve prefix to namespace without a stylesheet, syntax error.
800     return m_styleSheet-&gt;namespaceURIFromPrefix(prefix);
801 }
802 
803 void CSSSelectorParser::prependTypeSelectorIfNeeded(const AtomicString&amp; namespacePrefix, const AtomicString&amp; elementName, CSSParserSelector* compoundSelector)
804 {
805     bool isShadowDOM = compoundSelector-&gt;needsImplicitShadowCombinatorForMatching();
806 
807     if (elementName.isNull() &amp;&amp; defaultNamespace() == starAtom() &amp;&amp; !isShadowDOM)
808         return;
809 
810     AtomicString determinedElementName = elementName.isNull() ? starAtom() : elementName;
811     AtomicString namespaceURI = determineNamespace(namespacePrefix);
812     if (namespaceURI.isNull()) {
813         m_failedParsing = true;
814         return;
815     }
816     AtomicString determinedPrefix = namespacePrefix;
817     if (namespaceURI == defaultNamespace())
818         determinedPrefix = nullAtom();
819     QualifiedName tag = QualifiedName(determinedPrefix, determinedElementName, namespaceURI);
820 
821     // *:host never matches, so we can&#39;t discard the *,
822     // otherwise we can&#39;t tell the difference between *:host and just :host.
823     //
824     // Also, selectors where we use a ShadowPseudo combinator between the
825     // element and the pseudo element for matching (custom pseudo elements,
826     // ::cue), we need a universal selector to set the combinator
827     // (relation) on in the cases where there are no simple selectors preceding
828     // the pseudo element.
829     bool explicitForHost = compoundSelector-&gt;isHostPseudoSelector() &amp;&amp; !elementName.isNull();
830     if (tag != anyQName() || explicitForHost || isShadowDOM)
831         compoundSelector-&gt;prependTagSelector(tag, determinedPrefix == nullAtom() &amp;&amp; determinedElementName == starAtom() &amp;&amp; !explicitForHost);
832 }
833 
834 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::addSimpleSelectorToCompound(std::unique_ptr&lt;CSSParserSelector&gt; compoundSelector, std::unique_ptr&lt;CSSParserSelector&gt; simpleSelector)
835 {
836     compoundSelector-&gt;appendTagHistory(CSSSelector::Subselector, WTFMove(simpleSelector));
837     return compoundSelector;
838 }
839 
840 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::splitCompoundAtImplicitShadowCrossingCombinator(std::unique_ptr&lt;CSSParserSelector&gt; compoundSelector, const CSSParserContext&amp; context)
841 {
842     // The tagHistory is a linked list that stores combinator separated compound selectors
843     // from right-to-left. Yet, within a single compound selector, stores the simple selectors
844     // from left-to-right.
845     //
846     // &quot;.a.b &gt; div#id&quot; is stored in a tagHistory as [div, #id, .a, .b], each element in the
847     // list stored with an associated relation (combinator or Subselector).
848     //
849     // ::cue, ::shadow, and custom pseudo elements have an implicit ShadowPseudo combinator
850     // to their left, which really makes for a new compound selector, yet it&#39;s consumed by
851     // the selector parser as a single compound selector.
852     //
853     // Example: input#x::-webkit-clear-button -&gt; [ ::-webkit-clear-button, input, #x ]
854     //
855     CSSParserSelector* splitAfter = compoundSelector.get();
856     while (splitAfter-&gt;tagHistory() &amp;&amp; !splitAfter-&gt;tagHistory()-&gt;needsImplicitShadowCombinatorForMatching())
857         splitAfter = splitAfter-&gt;tagHistory();
858 
859     if (!splitAfter || !splitAfter-&gt;tagHistory())
860         return compoundSelector;
861 
862     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=161747
863     // We have to recur, since we have rules in media controls like video::a::b. This should not be allowed, and
864     // we should remove this recursion once those rules are gone.
865     std::unique_ptr&lt;CSSParserSelector&gt; secondCompound = context.mode != UASheetMode ? splitAfter-&gt;releaseTagHistory() : splitCompoundAtImplicitShadowCrossingCombinator(splitAfter-&gt;releaseTagHistory(), context);
866     secondCompound-&gt;appendTagHistory(CSSSelector::ShadowDescendant, WTFMove(compoundSelector));
867     return secondCompound;
868 }
869 
870 } // namespace WebCore
    </pre>
  </body>
</html>