<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContextLineLayout.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineFormattingContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InlineFormattingState.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContextLineLayout.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InlineFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;FloatingContext.h&quot;
 32 #include &quot;FloatingState.h&quot;
 33 #include &quot;InlineFormattingState.h&quot;

 34 #include &quot;InlineLineBreaker.h&quot;
<span class="line-removed"> 35 #include &quot;InlineRunProvider.h&quot;</span>
 36 #include &quot;LayoutBox.h&quot;
 37 #include &quot;LayoutContainer.h&quot;
 38 #include &quot;LayoutState.h&quot;
 39 #include &quot;TextUtil.h&quot;
 40 
 41 namespace WebCore {
 42 namespace Layout {
 43 
<span class="line-modified"> 44 class Line {</span>
<span class="line-modified"> 45 public:</span>
<span class="line-modified"> 46     void init(const LayoutPoint&amp; topLeft, LayoutUnit availableWidth, LayoutUnit minimalHeight);</span>
<span class="line-modified"> 47     void close();</span>
 48 
<span class="line-modified"> 49     void appendContent(const InlineRunProvider::Run&amp;, const LayoutSize&amp;);</span>




 50 
<span class="line-modified"> 51     void adjustLogicalLeft(LayoutUnit delta);</span>
<span class="line-modified"> 52     void adjustLogicalRight(LayoutUnit delta);</span>

 53 
<span class="line-modified"> 54     bool hasContent() const { return !m_inlineRuns.isEmpty(); }</span>
<span class="line-modified"> 55     bool isClosed() const { return m_closed; }</span>
<span class="line-removed"> 56     bool isFirstLine() const { return m_isFirstLine; }</span>
<span class="line-removed"> 57     Vector&lt;InlineRun&gt;&amp; runs() { return m_inlineRuns; }</span>
 58 
<span class="line-modified"> 59     LayoutUnit contentLogicalRight() const;</span>
<span class="line-modified"> 60     LayoutUnit contentLogicalLeft() const { return m_logicalRect.left(); }</span>
<span class="line-removed"> 61     LayoutUnit availableWidth() const { return m_availableWidth; }</span>
<span class="line-removed"> 62     Optional&lt;InlineRunProvider::Run::Type&gt; lastRunType() const { return m_lastRunType; }</span>
 63 
<span class="line-modified"> 64     LayoutUnit logicalTop() const { return m_logicalRect.top(); }</span>
<span class="line-modified"> 65     LayoutUnit logicalBottom() const { return m_logicalRect.bottom(); }</span>
<span class="line-removed"> 66     LayoutUnit logicalHeight() const { return logicalBottom() - logicalTop(); }</span>
 67 
<span class="line-modified"> 68 private:</span>
<span class="line-modified"> 69     struct TrailingTrimmableContent {</span>
<span class="line-removed"> 70         LayoutUnit width;</span>
<span class="line-removed"> 71         unsigned length;</span>
<span class="line-removed"> 72     };</span>
<span class="line-removed"> 73     Optional&lt;TrailingTrimmableContent&gt; m_trailingTrimmableContent;</span>
<span class="line-removed"> 74     Optional&lt;InlineRunProvider::Run::Type&gt; m_lastRunType;</span>
<span class="line-removed"> 75     bool m_lastRunCanExpand { false };</span>
 76 
<span class="line-modified"> 77     Display::Box::Rect m_logicalRect;</span>
<span class="line-modified"> 78     LayoutUnit m_availableWidth;</span>

 79 
<span class="line-modified"> 80     Vector&lt;InlineRun&gt; m_inlineRuns;</span>
<span class="line-modified"> 81     bool m_isFirstLine { true };</span>
<span class="line-modified"> 82     bool m_closed { true };</span>




 83 };
 84 
<span class="line-modified"> 85 void Line::init(const LayoutPoint&amp; topLeft, LayoutUnit availableWidth, LayoutUnit minimalHeight)</span>
<span class="line-modified"> 86 {</span>
<span class="line-removed"> 87     m_logicalRect.setTopLeft(topLeft);</span>
<span class="line-removed"> 88     m_logicalRect.setWidth(availableWidth);</span>
<span class="line-removed"> 89     m_logicalRect.setHeight(minimalHeight);</span>
<span class="line-removed"> 90     m_availableWidth = availableWidth;</span>
<span class="line-removed"> 91 </span>
<span class="line-removed"> 92     m_inlineRuns.clear();</span>
<span class="line-removed"> 93     m_lastRunType = { };</span>
<span class="line-removed"> 94     m_lastRunCanExpand = false;</span>
<span class="line-removed"> 95     m_trailingTrimmableContent = { };</span>
<span class="line-removed"> 96     m_closed = false;</span>
<span class="line-removed"> 97 }</span>
 98 
<span class="line-modified"> 99 void Line::adjustLogicalLeft(LayoutUnit delta)</span>
<span class="line-modified">100 {</span>
<span class="line-modified">101     ASSERT(delta &gt; 0);</span>




102 
<span class="line-modified">103     m_availableWidth -= delta;</span>
<span class="line-modified">104     m_logicalRect.shiftLeftTo(m_logicalRect.left() + delta);</span>



105 
<span class="line-modified">106     for (auto&amp; inlineRun : m_inlineRuns)</span>
<span class="line-modified">107         inlineRun.moveHorizontally(delta);</span>
<span class="line-modified">108 }</span>
109 
<span class="line-modified">110 void Line::adjustLogicalRight(LayoutUnit delta)</span>
<span class="line-removed">111 {</span>
<span class="line-removed">112     ASSERT(delta &gt; 0);</span>
113 
<span class="line-modified">114     m_availableWidth -= delta;</span>
<span class="line-modified">115     m_logicalRect.shiftRightTo(m_logicalRect.right() - delta);</span>
<span class="line-modified">116 }</span>











117 
<span class="line-modified">118 static bool isTrimmableContent(const InlineRunProvider::Run&amp; inlineRun)</span>
<span class="line-modified">119 {</span>
<span class="line-modified">120     return inlineRun.isWhitespace() &amp;&amp; inlineRun.style().collapseWhiteSpace();</span>
<span class="line-modified">121 }</span>
122 
<span class="line-modified">123 LayoutUnit Line::contentLogicalRight() const</span>
<span class="line-modified">124 {</span>
<span class="line-modified">125     if (m_inlineRuns.isEmpty())</span>
<span class="line-modified">126         return m_logicalRect.left();</span>
127 
<span class="line-modified">128     return m_inlineRuns.last().logicalRight();</span>
<span class="line-modified">129 }</span>









130 
<span class="line-modified">131 void Line::appendContent(const InlineRunProvider::Run&amp; run, const LayoutSize&amp; runSize)</span>
132 {
<span class="line-modified">133     ASSERT(!isClosed());</span>
<span class="line-modified">134 </span>
<span class="line-removed">135     // Append this text run to the end of the last text run, if the last run is continuous.</span>
<span class="line-removed">136     Optional&lt;InlineRun::TextContext&gt; textRun;</span>
<span class="line-removed">137     if (run.isText()) {</span>
<span class="line-removed">138         auto textContext = run.textContext();</span>
<span class="line-removed">139         auto runLength = textContext-&gt;isCollapsed() ? 1 : textContext-&gt;length();</span>
<span class="line-removed">140         textRun = InlineRun::TextContext { textContext-&gt;start(), runLength };</span>
<span class="line-removed">141     }</span>
<span class="line-removed">142 </span>
<span class="line-removed">143     auto requiresNewInlineRun = !hasContent() || !run.isText() || !m_lastRunCanExpand;</span>
<span class="line-removed">144     if (requiresNewInlineRun) {</span>
<span class="line-removed">145         // FIXME: This needs proper baseline handling</span>
<span class="line-removed">146         auto inlineRun = InlineRun { { logicalTop(), contentLogicalRight(), runSize.width(), runSize.height() }, run.inlineItem() };</span>
<span class="line-removed">147         if (textRun)</span>
<span class="line-removed">148             inlineRun.setTextContext({ textRun-&gt;start(), textRun-&gt;length() });</span>
<span class="line-removed">149         m_inlineRuns.append(inlineRun);</span>
<span class="line-removed">150         m_logicalRect.setHeight(std::max(runSize.height(), m_logicalRect.height()));</span>
<span class="line-removed">151     } else {</span>
<span class="line-removed">152         // Non-text runs always require new inline run.</span>
<span class="line-removed">153         ASSERT(textRun);</span>
<span class="line-removed">154         auto&amp; inlineRun = m_inlineRuns.last();</span>
<span class="line-removed">155         ASSERT(runSize.height() == inlineRun.logicalHeight());</span>
<span class="line-removed">156         inlineRun.setLogicalWidth(inlineRun.logicalWidth() + runSize.width());</span>
<span class="line-removed">157         inlineRun.textContext()-&gt;setLength(inlineRun.textContext()-&gt;length() + textRun-&gt;length());</span>
<span class="line-removed">158     }</span>
<span class="line-removed">159 </span>
<span class="line-removed">160     m_availableWidth -= runSize.width();</span>
<span class="line-removed">161     m_lastRunType = run.type();</span>
<span class="line-removed">162     m_lastRunCanExpand = run.isText() &amp;&amp; !run.textContext()-&gt;isCollapsed();</span>
<span class="line-removed">163     m_trailingTrimmableContent = { };</span>
<span class="line-removed">164     if (isTrimmableContent(run))</span>
<span class="line-removed">165         m_trailingTrimmableContent = TrailingTrimmableContent { runSize.width(), textRun-&gt;length() };</span>
166 }
167 
<span class="line-modified">168 void Line::close()</span>
169 {
<span class="line-modified">170     auto trimTrailingContent = [&amp;] {</span>
<span class="line-modified">171         if (!m_trailingTrimmableContent)</span>
<span class="line-removed">172             return;</span>
<span class="line-removed">173         auto&amp; lastInlineRun = m_inlineRuns.last();</span>
<span class="line-removed">174         lastInlineRun.setLogicalWidth(lastInlineRun.logicalWidth() - m_trailingTrimmableContent-&gt;width);</span>
<span class="line-removed">175         lastInlineRun.textContext()-&gt;setLength(lastInlineRun.textContext()-&gt;length() - m_trailingTrimmableContent-&gt;length);</span>
<span class="line-removed">176 </span>
<span class="line-removed">177         if (!lastInlineRun.textContext()-&gt;length())</span>
<span class="line-removed">178             m_inlineRuns.removeLast();</span>
<span class="line-removed">179         m_availableWidth += m_trailingTrimmableContent-&gt;width;</span>
<span class="line-removed">180         m_trailingTrimmableContent = { };</span>
<span class="line-removed">181     };</span>
<span class="line-removed">182 </span>
<span class="line-removed">183     if (!hasContent())</span>
<span class="line-removed">184         return;</span>
<span class="line-removed">185 </span>
<span class="line-removed">186     trimTrailingContent();</span>
<span class="line-removed">187     m_isFirstLine = false;</span>
<span class="line-removed">188     m_closed = true;</span>
189 }
190 
<span class="line-modified">191 InlineFormattingContext::LineLayout::LineLayout(const InlineFormattingContext&amp; inlineFormattingContext)</span>
<span class="line-modified">192     : m_formattingContext(inlineFormattingContext)</span>
<span class="line-modified">193     , m_formattingState(m_formattingContext.formattingState())</span>
<span class="line-modified">194     , m_floatingState(m_formattingState.floatingState())</span>
<span class="line-modified">195     , m_formattingRoot(downcast&lt;Container&gt;(m_formattingContext.root()))</span>
196 {
197 }
198 
<span class="line-modified">199 static bool isTrimmableContent(const InlineLineBreaker::Run&amp; run)</span>
200 {
<span class="line-modified">201     return run.content.isWhitespace() &amp;&amp; run.content.style().collapseWhiteSpace();</span>





202 }
203 
<span class="line-modified">204 void InlineFormattingContext::LineLayout::layout(const InlineRunProvider&amp; inlineRunProvider) const</span>
205 {
<span class="line-modified">206     auto&amp; layoutState = m_formattingContext.layoutState();</span>
<span class="line-modified">207     auto floatingContext = FloatingContext { m_floatingState };</span>

208 
<span class="line-modified">209     Line line;</span>
<span class="line-modified">210     initializeNewLine(line);</span>


211 
<span class="line-modified">212     InlineLineBreaker lineBreaker(layoutState, m_formattingState.inlineContent(), inlineRunProvider.runs());</span>
<span class="line-modified">213     while (auto run = lineBreaker.nextRun(line.contentLogicalRight(), line.availableWidth(), !line.hasContent())) {</span>
<span class="line-modified">214         auto isFirstRun = run-&gt;position == InlineLineBreaker::Run::Position::LineBegin;</span>
<span class="line-removed">215         auto isLastRun = run-&gt;position == InlineLineBreaker::Run::Position::LineEnd;</span>
<span class="line-removed">216         auto generatesInlineRun = true;</span>
217 
<span class="line-modified">218         // Position float and adjust the runs on line.</span>
<span class="line-modified">219         if (run-&gt;content.isFloat()) {</span>
<span class="line-modified">220             auto&amp; floatBox = run-&gt;content.inlineItem().layoutBox();</span>
<span class="line-modified">221             computeFloatPosition(floatingContext, line, floatBox);</span>
<span class="line-modified">222             m_floatingState.append(floatBox);</span>























223 
<span class="line-modified">224             auto floatBoxWidth = layoutState.displayBoxForLayoutBox(floatBox).marginBox().width();</span>
<span class="line-modified">225             // Shrink availble space for current line and move existing inline runs.</span>
<span class="line-modified">226             floatBox.isLeftFloatingPositioned() ? line.adjustLogicalLeft(floatBoxWidth) : line.adjustLogicalRight(floatBoxWidth);</span>









227 
<span class="line-modified">228             generatesInlineRun = false;</span>
<span class="line-modified">229         }</span>

230 
<span class="line-modified">231         // 1. Initialize new line if needed.</span>
<span class="line-modified">232         // 2. Append inline run unless it is skipped.</span>
<span class="line-removed">233         // 3. Close current line if needed.</span>
<span class="line-removed">234         if (isFirstRun) {</span>
<span class="line-removed">235             // When the first run does not generate an actual inline run, the next run comes in first-run as well.</span>
<span class="line-removed">236             // No need to spend time on closing/initializing.</span>
<span class="line-removed">237             // Skip leading whitespace.</span>
<span class="line-removed">238             if (!generatesInlineRun || isTrimmableContent(*run))</span>
<span class="line-removed">239                 continue;</span>
<span class="line-removed">240 </span>
<span class="line-removed">241             if (line.hasContent()) {</span>
<span class="line-removed">242                 // Previous run ended up being at the line end. Adjust the line accordingly.</span>
<span class="line-removed">243                 if (!line.isClosed())</span>
<span class="line-removed">244                     closeLine(line, IsLastLine::No);</span>
<span class="line-removed">245                 initializeNewLine(line);</span>
<span class="line-removed">246             }</span>
<span class="line-removed">247         }</span>
248 
<span class="line-modified">249         if (generatesInlineRun) {</span>
<span class="line-modified">250             auto width = run-&gt;width;</span>
<span class="line-modified">251             auto height = run-&gt;content.isText() ? LayoutUnit(m_formattingRoot.style().computedLineHeight()) : layoutState.displayBoxForLayoutBox(run-&gt;content.inlineItem().layoutBox()).height();</span>
<span class="line-modified">252             appendContentToLine(line, run-&gt;content, { width, height });</span>
<span class="line-modified">253         }</span>














254 
<span class="line-modified">255         if (isLastRun)</span>
<span class="line-modified">256             closeLine(line, IsLastLine::No);</span>

257     }











258 
<span class="line-modified">259     closeLine(line, IsLastLine::Yes);</span>



260 }
261 
<span class="line-modified">262 void InlineFormattingContext::LineLayout::initializeNewLine(Line&amp; line) const</span>
263 {
<span class="line-modified">264     auto&amp; formattingRootDisplayBox = m_formattingContext.layoutState().displayBoxForLayoutBox(m_formattingRoot);</span>

265 

266     auto lineLogicalLeft = formattingRootDisplayBox.contentBoxLeft();
<span class="line-removed">267     auto lineLogicalTop = line.isFirstLine() ? formattingRootDisplayBox.contentBoxTop() : line.logicalBottom();</span>
<span class="line-removed">268     auto availableWidth = formattingRootDisplayBox.contentBoxWidth();</span>
269 
<span class="line-modified">270     // Check for intruding floats and adjust logical left/available width for this line accordingly.</span>
<span class="line-modified">271     if (!m_floatingState.isEmpty()) {</span>
<span class="line-modified">272         auto floatConstraints = m_floatingState.constraints({ lineLogicalTop }, m_formattingRoot);</span>




273         // Check if these constraints actually put limitation on the line.
<span class="line-modified">274         if (floatConstraints.left &amp;&amp; *floatConstraints.left &lt;= formattingRootDisplayBox.contentBoxLeft())</span>
275             floatConstraints.left = { };
276 
<span class="line-modified">277         if (floatConstraints.right &amp;&amp; *floatConstraints.right &gt;= formattingRootDisplayBox.contentBoxRight())</span>
278             floatConstraints.right = { };
279 






280         if (floatConstraints.left &amp;&amp; floatConstraints.right) {
<span class="line-modified">281             ASSERT(*floatConstraints.left &lt; *floatConstraints.right);</span>
<span class="line-modified">282             availableWidth = *floatConstraints.right - *floatConstraints.left;</span>
<span class="line-modified">283             lineLogicalLeft = *floatConstraints.left;</span>
284         } else if (floatConstraints.left) {
<span class="line-modified">285             ASSERT(*floatConstraints.left &gt; lineLogicalLeft);</span>
<span class="line-modified">286             availableWidth -= (*floatConstraints.left - lineLogicalLeft);</span>
<span class="line-modified">287             lineLogicalLeft = *floatConstraints.left;</span>
288         } else if (floatConstraints.right) {
<span class="line-modified">289             ASSERT(*floatConstraints.right &gt; lineLogicalLeft);</span>
<span class="line-modified">290             availableWidth = *floatConstraints.right - lineLogicalLeft;</span>
291         }
<span class="line-modified">292     }</span>
<span class="line-modified">293 </span>
<span class="line-removed">294     line.init({ lineLogicalLeft, lineLogicalTop }, availableWidth, m_formattingRoot.style().computedLineHeight());</span>
<span class="line-removed">295 }</span>
<span class="line-removed">296 </span>
<span class="line-removed">297 void InlineFormattingContext::LineLayout::splitInlineRunIfNeeded(const InlineRun&amp; inlineRun, InlineRuns&amp; splitRuns) const</span>
<span class="line-removed">298 {</span>
<span class="line-removed">299     ASSERT(inlineRun.textContext());</span>
<span class="line-removed">300     ASSERT(inlineRun.overlapsMultipleInlineItems());</span>
<span class="line-removed">301     // In certain cases, a run can overlap multiple inline elements like this:</span>
<span class="line-removed">302     // &lt;span&gt;normal text content&lt;/span&gt;&lt;span style=&quot;position: relative; left: 10px;&quot;&gt;but this one needs a dedicated run&lt;/span&gt;&lt;span&gt;end of text&lt;/span&gt;</span>
<span class="line-removed">303     // The content above generates one long run &lt;normal text contentbut this one needs dedicated runend of text&gt;</span>
<span class="line-removed">304     // However, since the middle run is positioned, it needs to be moved independently from the rest of the content, hence it needs a dedicated inline run.</span>
<span class="line-removed">305 </span>
<span class="line-removed">306     // 1. Start with the first inline item (element) and travers the list until</span>
<span class="line-removed">307     // 2. either find an inline item that needs a dedicated run or we reach the end of the run</span>
<span class="line-removed">308     // 3. Create dedicate inline runs.</span>
<span class="line-removed">309     auto&amp; inlineContent = m_formattingState.inlineContent();</span>
<span class="line-removed">310     auto contentStart = inlineRun.logicalLeft();</span>
<span class="line-removed">311     auto startPosition = inlineRun.textContext()-&gt;start();</span>
<span class="line-removed">312     auto remaningLength = inlineRun.textContext()-&gt;length();</span>
<span class="line-removed">313 </span>
<span class="line-removed">314     struct Uncommitted {</span>
<span class="line-removed">315         const InlineItem* firstInlineItem { nullptr };</span>
<span class="line-removed">316         const InlineItem* lastInlineItem { nullptr };</span>
<span class="line-removed">317         unsigned length { 0 };</span>
<span class="line-removed">318     };</span>
<span class="line-removed">319     Optional&lt;Uncommitted&gt; uncommitted;</span>
<span class="line-removed">320 </span>
<span class="line-removed">321     auto commit = [&amp;] {</span>
<span class="line-removed">322         if (!uncommitted)</span>
<span class="line-removed">323             return;</span>
<span class="line-removed">324 </span>
<span class="line-removed">325         contentStart += uncommitted-&gt;firstInlineItem-&gt;nonBreakableStart();</span>
<span class="line-removed">326 </span>
<span class="line-removed">327         auto runWidth = this-&gt;runWidth(inlineContent, *uncommitted-&gt;firstInlineItem, startPosition, uncommitted-&gt;length, contentStart);</span>
<span class="line-removed">328         auto run = InlineRun { { inlineRun.logicalTop(), contentStart, runWidth, inlineRun.logicalHeight() }, *uncommitted-&gt;firstInlineItem };</span>
<span class="line-removed">329         run.setTextContext({ startPosition, uncommitted-&gt;length });</span>
<span class="line-removed">330         splitRuns.append(run);</span>
<span class="line-removed">331 </span>
<span class="line-removed">332         contentStart += runWidth + uncommitted-&gt;lastInlineItem-&gt;nonBreakableEnd();</span>
<span class="line-removed">333 </span>
<span class="line-removed">334         startPosition = 0;</span>
<span class="line-removed">335         uncommitted = { };</span>
336     };
337 
<span class="line-modified">338     for (auto iterator = inlineContent.find(const_cast&lt;InlineItem*&gt;(&amp;inlineRun.inlineItem())); iterator != inlineContent.end() &amp;&amp; remaningLength &gt; 0; ++iterator) {</span>
<span class="line-modified">339         auto&amp; inlineItem = **iterator;</span>
<span class="line-modified">340 </span>
<span class="line-modified">341         // Skip all non-inflow boxes (floats, out-of-flow positioned elements). They don&#39;t participate in the inline run context.</span>
<span class="line-modified">342         if (!inlineItem.layoutBox().isInFlow())</span>
<span class="line-modified">343             continue;</span>
<span class="line-modified">344 </span>
<span class="line-modified">345         auto currentLength = [&amp;] {</span>
<span class="line-modified">346             return std::min(remaningLength, inlineItem.textContent().length() - startPosition);</span>
<span class="line-modified">347         };</span>
<span class="line-modified">348 </span>
<span class="line-modified">349         // 1. Break before/after -&gt; requires dedicated run -&gt; commit what we&#39;ve got so far and also commit the current inline element as a separate inline run.</span>
<span class="line-modified">350         // 2. Break at the beginning of the inline element -&gt; commit what we&#39;ve got so far. Current element becomes the first uncommitted.</span>
<span class="line-modified">351         // 3. Break at the end of the inline element -&gt; commit what we&#39;ve got so far including the current element.</span>
<span class="line-removed">352         // 4. Inline element does not require run breaking -&gt; add current inline element to uncommitted. Jump to the next element.</span>
<span class="line-removed">353         auto detachingRules = inlineItem.detachingRules();</span>
<span class="line-removed">354 </span>
<span class="line-removed">355         // #1</span>
<span class="line-removed">356         if (detachingRules.containsAll({ InlineItem::DetachingRule::BreakAtStart, InlineItem::DetachingRule::BreakAtEnd })) {</span>
<span class="line-removed">357             commit();</span>
<span class="line-removed">358             auto contentLength = currentLength();</span>
<span class="line-removed">359             uncommitted = Uncommitted { &amp;inlineItem, &amp;inlineItem, contentLength };</span>
<span class="line-removed">360             remaningLength -= contentLength;</span>
<span class="line-removed">361             commit();</span>
<span class="line-removed">362             continue;</span>
363         }
<span class="line-removed">364 </span>
<span class="line-removed">365         // #2</span>
<span class="line-removed">366         if (detachingRules.contains(InlineItem::DetachingRule::BreakAtStart))</span>
<span class="line-removed">367             commit();</span>
<span class="line-removed">368 </span>
<span class="line-removed">369         // Add current inline item to uncommitted.</span>
<span class="line-removed">370         // #3 and #4</span>
<span class="line-removed">371         auto contentLength = currentLength();</span>
<span class="line-removed">372         if (!uncommitted)</span>
<span class="line-removed">373             uncommitted = Uncommitted { &amp;inlineItem, &amp;inlineItem, 0 };</span>
<span class="line-removed">374         uncommitted-&gt;length += contentLength;</span>
<span class="line-removed">375         uncommitted-&gt;lastInlineItem = &amp;inlineItem;</span>
<span class="line-removed">376         remaningLength -= contentLength;</span>
<span class="line-removed">377 </span>
<span class="line-removed">378         // #3</span>
<span class="line-removed">379         if (detachingRules.contains(InlineItem::DetachingRule::BreakAtEnd))</span>
<span class="line-removed">380             commit();</span>
381     }
<span class="line-removed">382     // Either all inline elements needed dedicated runs or neither of them.</span>
<span class="line-removed">383     if (!remaningLength || remaningLength == inlineRun.textContext()-&gt;length())</span>
<span class="line-removed">384         return;</span>
<span class="line-removed">385 </span>
<span class="line-removed">386     commit();</span>
387 }
388 
<span class="line-modified">389 void InlineFormattingContext::LineLayout::createFinalRuns(Line&amp; line) const</span>
390 {
<span class="line-modified">391     for (auto&amp; inlineRun : line.runs()) {</span>
<span class="line-modified">392         if (inlineRun.overlapsMultipleInlineItems()) {</span>
<span class="line-modified">393             InlineRuns splitRuns;</span>
<span class="line-modified">394             splitInlineRunIfNeeded(inlineRun, splitRuns);</span>
<span class="line-modified">395             for (auto&amp; splitRun : splitRuns)</span>
<span class="line-modified">396                 m_formattingState.appendInlineRun(splitRun);</span>
<span class="line-modified">397 </span>
<span class="line-modified">398             if (!splitRuns.isEmpty())</span>
<span class="line-modified">399                 continue;</span>
<span class="line-removed">400         }</span>
<span class="line-removed">401 </span>
<span class="line-removed">402         auto finalRun = [&amp;] {</span>
<span class="line-removed">403             auto&amp; inlineItem = inlineRun.inlineItem();</span>
<span class="line-removed">404             if (inlineItem.detachingRules().isEmpty())</span>
<span class="line-removed">405                 return inlineRun;</span>
<span class="line-removed">406 </span>
<span class="line-removed">407             InlineRun adjustedRun = inlineRun;</span>
<span class="line-removed">408             auto width = inlineRun.logicalWidth() - inlineItem.nonBreakableStart() - inlineItem.nonBreakableEnd();</span>
<span class="line-removed">409             adjustedRun.setLogicalLeft(inlineRun.logicalLeft() + inlineItem.nonBreakableStart());</span>
<span class="line-removed">410             adjustedRun.setLogicalWidth(width);</span>
<span class="line-removed">411             return adjustedRun;</span>
<span class="line-removed">412         };</span>
<span class="line-removed">413 </span>
<span class="line-removed">414         m_formattingState.appendInlineRun(finalRun());</span>
415     }

416 }
417 
<span class="line-modified">418 void InlineFormattingContext::LineLayout::postProcessInlineRuns(Line&amp; line, IsLastLine isLastLine) const</span>
419 {
<span class="line-modified">420     alignRuns(m_formattingRoot.style().textAlign(), line, isLastLine);</span>
<span class="line-modified">421     auto firstRunIndex = m_formattingState.inlineRuns().size();</span>
<span class="line-modified">422     createFinalRuns(line);</span>
<span class="line-modified">423 </span>
<span class="line-modified">424     placeInFlowPositionedChildren(firstRunIndex);</span>
<span class="line-modified">425 }</span>









426 
<span class="line-modified">427 void InlineFormattingContext::LineLayout::closeLine(Line&amp; line, IsLastLine isLastLine) const</span>
<span class="line-modified">428 {</span>
<span class="line-modified">429     line.close();</span>
<span class="line-modified">430     if (!line.hasContent())</span>
431         return;

432 
<span class="line-modified">433     postProcessInlineRuns(line, isLastLine);</span>
<span class="line-modified">434 }</span>
<span class="line-modified">435 </span>
<span class="line-modified">436 void InlineFormattingContext::LineLayout::appendContentToLine(Line&amp; line, const InlineRunProvider::Run&amp; run, const LayoutSize&amp; runSize) const</span>
<span class="line-modified">437 {</span>
<span class="line-modified">438     auto lastRunType = line.lastRunType();</span>
<span class="line-modified">439     line.appendContent(run, runSize);</span>













440 
<span class="line-modified">441     if (m_formattingRoot.style().textAlign() == TextAlignMode::Justify)</span>
<span class="line-modified">442         computeExpansionOpportunities(line, run, lastRunType.valueOr(InlineRunProvider::Run::Type::NonWhitespace));</span>
<span class="line-modified">443 }</span>







444 
<span class="line-modified">445 void InlineFormattingContext::LineLayout::computeFloatPosition(const FloatingContext&amp; floatingContext, Line&amp; line, const Box&amp; floatBox) const</span>
<span class="line-modified">446 {</span>
<span class="line-modified">447     auto&amp; layoutState = m_formattingContext.layoutState();</span>
<span class="line-modified">448     ASSERT(layoutState.hasDisplayBox(floatBox));</span>
<span class="line-modified">449     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(floatBox);</span>
<span class="line-modified">450 </span>
<span class="line-removed">451     // Set static position first.</span>
<span class="line-removed">452     displayBox.setTopLeft({ line.contentLogicalRight(), line.logicalTop() });</span>
<span class="line-removed">453     // Float it.</span>
<span class="line-removed">454     displayBox.setTopLeft(floatingContext.positionForFloat(floatBox));</span>
<span class="line-removed">455 }</span>
456 
<span class="line-modified">457 void InlineFormattingContext::LineLayout::placeInFlowPositionedChildren(unsigned fistRunIndex) const</span>
<span class="line-modified">458 {</span>
<span class="line-modified">459     auto&amp; layoutState = m_formattingContext.layoutState();</span>
<span class="line-modified">460     auto&amp; inlineRuns = m_formattingState.inlineRuns();</span>
<span class="line-modified">461     for (auto runIndex = fistRunIndex; runIndex &lt; inlineRuns.size(); ++runIndex) {</span>
<span class="line-modified">462         auto&amp; inlineRun = inlineRuns[runIndex];</span>
<span class="line-removed">463 </span>
<span class="line-removed">464         auto positionOffset = [&amp;](auto&amp; layoutBox) {</span>
<span class="line-removed">465             // FIXME: Need to figure out whether in-flow offset should stick. This might very well be temporary.</span>
<span class="line-removed">466             Optional&lt;LayoutSize&gt; offset;</span>
<span class="line-removed">467             for (auto* box = &amp;layoutBox; box != &amp;m_formattingRoot; box = box-&gt;parent()) {</span>
<span class="line-removed">468                 if (!box-&gt;isInFlowPositioned())</span>
<span class="line-removed">469                     continue;</span>
<span class="line-removed">470                 offset = offset.valueOr(LayoutSize()) + Geometry::inFlowPositionedPositionOffset(layoutState, *box);</span>
471             }
<span class="line-modified">472             return offset;</span>
<span class="line-modified">473         };</span>






474 
<span class="line-modified">475         if (auto offset = positionOffset(inlineRun.inlineItem().layoutBox())) {</span>
<span class="line-modified">476             inlineRun.moveVertically(offset-&gt;height());</span>
<span class="line-modified">477             inlineRun.moveHorizontally(offset-&gt;width());</span>























478         }
479     }



480 }
481 
<span class="line-modified">482 static LayoutUnit adjustedLineLogicalLeft(TextAlignMode align, LayoutUnit lineLogicalLeft, LayoutUnit remainingWidth)</span>
483 {
484     switch (align) {
485     case TextAlignMode::Left:
486     case TextAlignMode::WebKitLeft:
487     case TextAlignMode::Start:
<span class="line-modified">488         return lineLogicalLeft;</span>
489     case TextAlignMode::Right:
490     case TextAlignMode::WebKitRight:
491     case TextAlignMode::End:
<span class="line-modified">492         return lineLogicalLeft + std::max(remainingWidth, 0_lu);</span>
493     case TextAlignMode::Center:
494     case TextAlignMode::WebKitCenter:
<span class="line-modified">495         return lineLogicalLeft + std::max(remainingWidth / 2, 0_lu);</span>
496     case TextAlignMode::Justify:
497         ASSERT_NOT_REACHED();
498         break;
499     }
500     ASSERT_NOT_REACHED();
<span class="line-modified">501     return lineLogicalLeft;</span>
<span class="line-removed">502 }</span>
<span class="line-removed">503 </span>
<span class="line-removed">504 void InlineFormattingContext::LineLayout::justifyRuns(Line&amp; line)</span>
<span class="line-removed">505 {</span>
<span class="line-removed">506     auto&amp; inlineRuns = line.runs();</span>
<span class="line-removed">507     auto&amp; lastInlineRun = inlineRuns.last();</span>
<span class="line-removed">508 </span>
<span class="line-removed">509     // Adjust (forbid) trailing expansion for the last text run on line.</span>
<span class="line-removed">510     auto expansionBehavior = lastInlineRun.expansionOpportunity().behavior;</span>
<span class="line-removed">511     // Remove allow and add forbid.</span>
<span class="line-removed">512     expansionBehavior ^= AllowTrailingExpansion;</span>
<span class="line-removed">513     expansionBehavior |= ForbidTrailingExpansion;</span>
<span class="line-removed">514     lastInlineRun.expansionOpportunity().behavior = expansionBehavior;</span>
<span class="line-removed">515 </span>
<span class="line-removed">516     // Collect expansion opportunities and justify the runs.</span>
<span class="line-removed">517     auto widthToDistribute = line.availableWidth();</span>
<span class="line-removed">518     if (widthToDistribute &lt;= 0)</span>
<span class="line-removed">519         return;</span>
<span class="line-removed">520 </span>
<span class="line-removed">521     auto expansionOpportunities = 0;</span>
<span class="line-removed">522     for (auto&amp; inlineRun : inlineRuns)</span>
<span class="line-removed">523         expansionOpportunities += inlineRun.expansionOpportunity().count;</span>
<span class="line-removed">524 </span>
<span class="line-removed">525     if (!expansionOpportunities)</span>
<span class="line-removed">526         return;</span>
<span class="line-removed">527 </span>
<span class="line-removed">528     float expansion = widthToDistribute.toFloat() / expansionOpportunities;</span>
<span class="line-removed">529     LayoutUnit accumulatedExpansion;</span>
<span class="line-removed">530     for (auto&amp; inlineRun : inlineRuns) {</span>
<span class="line-removed">531         auto expansionForRun = inlineRun.expansionOpportunity().count * expansion;</span>
<span class="line-removed">532 </span>
<span class="line-removed">533         inlineRun.expansionOpportunity().expansion = expansionForRun;</span>
<span class="line-removed">534         inlineRun.setLogicalLeft(inlineRun.logicalLeft() + accumulatedExpansion);</span>
<span class="line-removed">535         inlineRun.setLogicalWidth(inlineRun.logicalWidth() + expansionForRun);</span>
<span class="line-removed">536         accumulatedExpansion += expansionForRun;</span>
<span class="line-removed">537     }</span>
<span class="line-removed">538 }</span>
<span class="line-removed">539 </span>
<span class="line-removed">540 void InlineFormattingContext::LineLayout::computeExpansionOpportunities(Line&amp; line, const InlineRunProvider::Run&amp; run, InlineRunProvider::Run::Type lastRunType) const</span>
<span class="line-removed">541 {</span>
<span class="line-removed">542     auto isExpansionOpportunity = [](auto currentRunIsWhitespace, auto lastRunIsWhitespace) {</span>
<span class="line-removed">543         return currentRunIsWhitespace || (!currentRunIsWhitespace &amp;&amp; !lastRunIsWhitespace);</span>
<span class="line-removed">544     };</span>
<span class="line-removed">545 </span>
<span class="line-removed">546     auto expansionBehavior = [](auto isAtExpansionOpportunity) {</span>
<span class="line-removed">547         ExpansionBehavior expansionBehavior = AllowTrailingExpansion;</span>
<span class="line-removed">548         expansionBehavior |= isAtExpansionOpportunity ? ForbidLeadingExpansion : AllowLeadingExpansion;</span>
<span class="line-removed">549         return expansionBehavior;</span>
<span class="line-removed">550     };</span>
<span class="line-removed">551 </span>
<span class="line-removed">552     auto isAtExpansionOpportunity = isExpansionOpportunity(run.isWhitespace(), lastRunType == InlineRunProvider::Run::Type::Whitespace);</span>
<span class="line-removed">553 </span>
<span class="line-removed">554     auto&amp; currentInlineRun = line.runs().last();</span>
<span class="line-removed">555     auto&amp; expansionOpportunity = currentInlineRun.expansionOpportunity();</span>
<span class="line-removed">556     if (isAtExpansionOpportunity)</span>
<span class="line-removed">557         ++expansionOpportunity.count;</span>
<span class="line-removed">558 </span>
<span class="line-removed">559     expansionOpportunity.behavior = expansionBehavior(isAtExpansionOpportunity);</span>
560 }
561 
<span class="line-modified">562 void InlineFormattingContext::LineLayout::alignRuns(TextAlignMode textAlign, Line&amp; line,  IsLastLine isLastLine) const</span>
563 {
<span class="line-modified">564     auto adjutedTextAlignment = textAlign != TextAlignMode::Justify ? textAlign : isLastLine == IsLastLine::No ? TextAlignMode::Justify : TextAlignMode::Left;</span>
<span class="line-modified">565     if (adjutedTextAlignment == TextAlignMode::Justify) {</span>
<span class="line-removed">566         justifyRuns(line);</span>
567         return;
<span class="line-removed">568     }</span>
<span class="line-removed">569 </span>
<span class="line-removed">570     auto lineLogicalLeft = line.contentLogicalLeft();</span>
<span class="line-removed">571     auto adjustedLogicalLeft = adjustedLineLogicalLeft(adjutedTextAlignment, lineLogicalLeft, line.availableWidth());</span>
<span class="line-removed">572     if (adjustedLogicalLeft == lineLogicalLeft)</span>
<span class="line-removed">573         return;</span>
<span class="line-removed">574 </span>
<span class="line-removed">575     auto delta = adjustedLogicalLeft - lineLogicalLeft;</span>
<span class="line-removed">576     for (auto&amp; inlineRun : line.runs())</span>
<span class="line-removed">577         inlineRun.setLogicalLeft(inlineRun.logicalLeft() + delta);</span>
<span class="line-removed">578 }</span>
579 
<span class="line-modified">580 LayoutUnit InlineFormattingContext::LineLayout::runWidth(const InlineContent&amp; inlineContent, const InlineItem&amp; inlineItem, ItemPosition from, unsigned length, LayoutUnit contentLogicalLeft) const</span>
<span class="line-modified">581 {</span>
<span class="line-removed">582     LayoutUnit width;</span>
<span class="line-removed">583     auto startPosition = from;</span>
<span class="line-removed">584     auto iterator = inlineContent.find(const_cast&lt;InlineItem*&gt;(&amp;inlineItem));</span>
<span class="line-removed">585 #if !ASSERT_DISABLED</span>
<span class="line-removed">586     auto inlineItemEnd = inlineContent.end();</span>
<span class="line-removed">587 #endif</span>
<span class="line-removed">588     while (length) {</span>
<span class="line-removed">589         ASSERT(iterator != inlineItemEnd);</span>
<span class="line-removed">590         auto&amp; currentInlineItem = **iterator;</span>
<span class="line-removed">591         auto endPosition = std::min&lt;ItemPosition&gt;(startPosition + length, currentInlineItem.textContent().length());</span>
<span class="line-removed">592         auto textWidth = TextUtil::width(currentInlineItem, startPosition, endPosition, contentLogicalLeft);</span>
<span class="line-removed">593 </span>
<span class="line-removed">594         contentLogicalLeft += textWidth;</span>
<span class="line-removed">595         width += textWidth;</span>
<span class="line-removed">596         length -= (endPosition - startPosition);</span>
<span class="line-removed">597 </span>
<span class="line-removed">598         startPosition = 0;</span>
<span class="line-removed">599         ++iterator;</span>
<span class="line-removed">600     }</span>
<span class="line-removed">601     return width;</span>
602 }
603 
604 }
605 }
606 
607 #endif
</pre>
</td>
<td>
<hr />
<pre>
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InlineFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;FloatingContext.h&quot;
 32 #include &quot;FloatingState.h&quot;
 33 #include &quot;InlineFormattingState.h&quot;
<span class="line-added"> 34 #include &quot;InlineLine.h&quot;</span>
 35 #include &quot;InlineLineBreaker.h&quot;

 36 #include &quot;LayoutBox.h&quot;
 37 #include &quot;LayoutContainer.h&quot;
 38 #include &quot;LayoutState.h&quot;
 39 #include &quot;TextUtil.h&quot;
 40 
 41 namespace WebCore {
 42 namespace Layout {
 43 
<span class="line-modified"> 44 static LayoutUnit inlineItemWidth(const LayoutState&amp; layoutState, const InlineItem&amp; inlineItem, LayoutUnit contentLogicalLeft)</span>
<span class="line-modified"> 45 {</span>
<span class="line-modified"> 46     if (inlineItem.isLineBreak())</span>
<span class="line-modified"> 47         return 0;</span>
 48 
<span class="line-modified"> 49     if (is&lt;InlineTextItem&gt;(inlineItem)) {</span>
<span class="line-added"> 50         auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(inlineItem);</span>
<span class="line-added"> 51         auto end = inlineTextItem.isCollapsed() ? inlineTextItem.start() + 1 : inlineTextItem.end();</span>
<span class="line-added"> 52         return TextUtil::width(inlineTextItem.layoutBox(), inlineTextItem.start(), end, contentLogicalLeft);</span>
<span class="line-added"> 53     }</span>
 54 
<span class="line-modified"> 55     auto&amp; layoutBox = inlineItem.layoutBox();</span>
<span class="line-modified"> 56     ASSERT(layoutState.hasDisplayBox(layoutBox));</span>
<span class="line-added"> 57     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
 58 
<span class="line-modified"> 59     if (layoutBox.isFloatingPositioned())</span>
<span class="line-modified"> 60         return displayBox.marginBoxWidth();</span>


 61 
<span class="line-modified"> 62     if (layoutBox.replaced())</span>
<span class="line-modified"> 63         return displayBox.width();</span>


 64 
<span class="line-modified"> 65     if (inlineItem.isContainerStart())</span>
<span class="line-modified"> 66         return displayBox.marginStart() + displayBox.borderLeft() + displayBox.paddingLeft().valueOr(0);</span>

 67 
<span class="line-modified"> 68     if (inlineItem.isContainerEnd())</span>
<span class="line-modified"> 69         return displayBox.marginEnd() + displayBox.borderRight() + displayBox.paddingRight().valueOr(0);</span>






 70 
<span class="line-modified"> 71     // Non-replaced inline box (e.g. inline-block)</span>
<span class="line-modified"> 72     return displayBox.width();</span>
<span class="line-added"> 73 }</span>
 74 
<span class="line-modified"> 75 struct IndexAndRange {</span>
<span class="line-modified"> 76     unsigned index { 0 };</span>
<span class="line-modified"> 77     struct Range {</span>
<span class="line-added"> 78         unsigned start { 0 };</span>
<span class="line-added"> 79         unsigned length { 0 };</span>
<span class="line-added"> 80     };</span>
<span class="line-added"> 81     Optional&lt;Range&gt; partialContext;</span>
 82 };
 83 
<span class="line-modified"> 84 struct LineInput {</span>
<span class="line-modified"> 85     LineInput(const Line::InitialConstraints&amp; initialLineConstraints, Line::SkipVerticalAligment, IndexAndRange firstToProcess, const InlineItems&amp;);</span>











 86 
<span class="line-modified"> 87     Line::InitialConstraints initialConstraints;</span>
<span class="line-modified"> 88     // FIXME Alternatively we could just have a second pass with vertical positioning (preferred width computation opts out)</span>
<span class="line-modified"> 89     Line::SkipVerticalAligment skipVerticalAligment;</span>
<span class="line-added"> 90     IndexAndRange firstInlineItem;</span>
<span class="line-added"> 91     const InlineItems&amp; inlineItems;</span>
<span class="line-added"> 92     Optional&lt;LayoutUnit&gt; floatMinimumLogicalBottom;</span>
<span class="line-added"> 93 };</span>
 94 
<span class="line-modified"> 95 struct LineContent {</span>
<span class="line-modified"> 96     Optional&lt;IndexAndRange&gt; lastCommitted;</span>
<span class="line-added"> 97     Vector&lt;WeakPtr&lt;InlineItem&gt;&gt; floats;</span>
<span class="line-added"> 98     std::unique_ptr&lt;Line::Content&gt; runs;</span>
<span class="line-added"> 99 };</span>
100 
<span class="line-modified">101 class LineLayout {</span>
<span class="line-modified">102 public:</span>
<span class="line-modified">103     LineLayout(const LayoutState&amp;, const LineInput&amp;);</span>
104 
<span class="line-modified">105     LineContent layout();</span>


106 
<span class="line-modified">107 private:</span>
<span class="line-modified">108     const LayoutState&amp; layoutState() const { return m_layoutState; }</span>
<span class="line-modified">109     enum class IsEndOfLine { No, Yes };</span>
<span class="line-added">110     IsEndOfLine placeInlineItem(const InlineItem&amp;);</span>
<span class="line-added">111     void commitPendingContent();</span>
<span class="line-added">112     LineContent close();</span>
<span class="line-added">113 </span>
<span class="line-added">114     struct UncommittedContent {</span>
<span class="line-added">115         struct Run {</span>
<span class="line-added">116             const InlineItem&amp; inlineItem;</span>
<span class="line-added">117             LayoutUnit logicalWidth;</span>
<span class="line-added">118         };</span>
<span class="line-added">119         void add(const InlineItem&amp;, LayoutUnit logicalWidth);</span>
<span class="line-added">120         void reset();</span>
121 
<span class="line-modified">122         Vector&lt;Run&gt; runs() { return m_uncommittedRuns; }</span>
<span class="line-modified">123         bool isEmpty() const { return m_uncommittedRuns.isEmpty(); }</span>
<span class="line-modified">124         unsigned size() const { return m_uncommittedRuns.size(); }</span>
<span class="line-modified">125         LayoutUnit width() const { return m_width; }</span>
126 
<span class="line-modified">127     private:</span>
<span class="line-modified">128         Vector&lt;Run&gt; m_uncommittedRuns;</span>
<span class="line-modified">129         LayoutUnit m_width;</span>
<span class="line-modified">130     };</span>
131 
<span class="line-modified">132     const LayoutState&amp; m_layoutState;</span>
<span class="line-modified">133     const LineInput&amp; m_lineInput;</span>
<span class="line-added">134     Line m_line;</span>
<span class="line-added">135     LineBreaker m_lineBreaker;</span>
<span class="line-added">136     bool m_lineHasFloatBox { false };</span>
<span class="line-added">137     UncommittedContent m_uncommittedContent;</span>
<span class="line-added">138     unsigned m_committedInlineItemCount { 0 };</span>
<span class="line-added">139     Vector&lt;WeakPtr&lt;InlineItem&gt;&gt; m_floats;</span>
<span class="line-added">140     std::unique_ptr&lt;InlineTextItem&gt; m_leadingPartialInlineTextItem;</span>
<span class="line-added">141     std::unique_ptr&lt;InlineTextItem&gt; m_trailingPartialInlineTextItem;</span>
<span class="line-added">142 };</span>
143 
<span class="line-modified">144 void LineLayout::UncommittedContent::add(const InlineItem&amp; inlineItem, LayoutUnit logicalWidth)</span>
145 {
<span class="line-modified">146     m_uncommittedRuns.append({ inlineItem, logicalWidth });</span>
<span class="line-modified">147     m_width += logicalWidth;</span>































148 }
149 
<span class="line-modified">150 void LineLayout::UncommittedContent::reset()</span>
151 {
<span class="line-modified">152     m_uncommittedRuns.clear();</span>
<span class="line-modified">153     m_width = 0;</span>

















154 }
155 
<span class="line-modified">156 LineLayout::LineLayout(const LayoutState&amp; layoutState, const LineInput&amp; lineInput)</span>
<span class="line-modified">157     : m_layoutState(layoutState)</span>
<span class="line-modified">158     , m_lineInput(lineInput)</span>
<span class="line-modified">159     , m_line(layoutState, lineInput.initialConstraints, lineInput.skipVerticalAligment)</span>
<span class="line-modified">160     , m_lineHasFloatBox(lineInput.floatMinimumLogicalBottom.hasValue())</span>
161 {
162 }
163 
<span class="line-modified">164 void LineLayout::commitPendingContent()</span>
165 {
<span class="line-modified">166     if (m_uncommittedContent.isEmpty())</span>
<span class="line-added">167         return;</span>
<span class="line-added">168     m_committedInlineItemCount += m_uncommittedContent.size();</span>
<span class="line-added">169     for (auto&amp; uncommittedRun : m_uncommittedContent.runs())</span>
<span class="line-added">170         m_line.append(uncommittedRun.inlineItem, uncommittedRun.logicalWidth);</span>
<span class="line-added">171     m_uncommittedContent.reset();</span>
172 }
173 
<span class="line-modified">174 LineContent LineLayout::close()</span>
175 {
<span class="line-modified">176     ASSERT(m_committedInlineItemCount || m_lineHasFloatBox);</span>
<span class="line-modified">177     if (!m_committedInlineItemCount)</span>
<span class="line-added">178         return LineContent { WTF::nullopt, WTFMove(m_floats), m_line.close() };</span>
179 
<span class="line-modified">180     auto lastInlineItemIndex = m_lineInput.firstInlineItem.index + m_committedInlineItemCount - 1;</span>
<span class="line-modified">181     Optional&lt;IndexAndRange::Range&gt; partialContext;</span>
<span class="line-added">182     if (m_trailingPartialInlineTextItem)</span>
<span class="line-added">183         partialContext = IndexAndRange::Range { m_trailingPartialInlineTextItem-&gt;start(), m_trailingPartialInlineTextItem-&gt;length() };</span>
184 
<span class="line-modified">185     auto lastCommitedItem = IndexAndRange { lastInlineItemIndex, partialContext };</span>
<span class="line-modified">186     return LineContent { lastCommitedItem, WTFMove(m_floats), m_line.close() };</span>
<span class="line-modified">187 }</span>


188 
<span class="line-modified">189 LineLayout::IsEndOfLine LineLayout::placeInlineItem(const InlineItem&amp; inlineItem)</span>
<span class="line-modified">190 {</span>
<span class="line-modified">191     auto availableWidth = m_line.availableWidth() - m_uncommittedContent.width();</span>
<span class="line-modified">192     auto currentLogicalRight = m_line.contentLogicalRight() + m_uncommittedContent.width();</span>
<span class="line-modified">193     auto itemLogicalWidth = inlineItemWidth(layoutState(), inlineItem, currentLogicalRight);</span>
<span class="line-added">194 </span>
<span class="line-added">195     // FIXME: Ensure LineContext::trimmableWidth includes uncommitted content if needed.</span>
<span class="line-added">196     auto lineIsConsideredEmpty = !m_line.hasContent() &amp;&amp; !m_lineHasFloatBox;</span>
<span class="line-added">197     auto breakingContext = m_lineBreaker.breakingContext(inlineItem, itemLogicalWidth, { availableWidth, currentLogicalRight, m_line.trailingTrimmableWidth(), lineIsConsideredEmpty });</span>
<span class="line-added">198     if (breakingContext.isAtBreakingOpportunity)</span>
<span class="line-added">199         commitPendingContent();</span>
<span class="line-added">200 </span>
<span class="line-added">201     // Content does not fit the current line.</span>
<span class="line-added">202     if (breakingContext.breakingBehavior == LineBreaker::BreakingBehavior::Wrap)</span>
<span class="line-added">203         return IsEndOfLine::Yes;</span>
<span class="line-added">204 </span>
<span class="line-added">205     // Partial content stays on the current line.</span>
<span class="line-added">206     if (breakingContext.breakingBehavior == LineBreaker::BreakingBehavior::Split) {</span>
<span class="line-added">207         ASSERT(inlineItem.isText());</span>
<span class="line-added">208         auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(inlineItem);</span>
<span class="line-added">209         auto splitData = TextUtil::split(inlineTextItem.layoutBox(), inlineTextItem.start(), inlineTextItem.length(), itemLogicalWidth, availableWidth, currentLogicalRight);</span>
<span class="line-added">210         // Construct a partial trailing inline item.</span>
<span class="line-added">211         ASSERT(!m_trailingPartialInlineTextItem);</span>
<span class="line-added">212         m_trailingPartialInlineTextItem = inlineTextItem.split(splitData.start, splitData.length);</span>
<span class="line-added">213         m_uncommittedContent.add(*m_trailingPartialInlineTextItem, splitData.logicalWidth);</span>
<span class="line-added">214         commitPendingContent();</span>
<span class="line-added">215         return IsEndOfLine::Yes;</span>
<span class="line-added">216     }</span>
217 
<span class="line-modified">218     ASSERT(breakingContext.breakingBehavior == LineBreaker::BreakingBehavior::Keep);</span>
<span class="line-modified">219     if (inlineItem.isFloat()) {</span>
<span class="line-modified">220         auto&amp; floatBox = inlineItem.layoutBox();</span>
<span class="line-added">221         ASSERT(layoutState().hasDisplayBox(floatBox));</span>
<span class="line-added">222         // Shrink available space for current line and move existing inline runs.</span>
<span class="line-added">223         auto floatBoxWidth = layoutState().displayBoxForLayoutBox(floatBox).marginBoxWidth();</span>
<span class="line-added">224         floatBox.isLeftFloatingPositioned() ? m_line.moveLogicalLeft(floatBoxWidth) : m_line.moveLogicalRight(floatBoxWidth);</span>
<span class="line-added">225         m_floats.append(makeWeakPtr(inlineItem));</span>
<span class="line-added">226         ++m_committedInlineItemCount;</span>
<span class="line-added">227         m_lineHasFloatBox = true;</span>
<span class="line-added">228         return IsEndOfLine::No;</span>
<span class="line-added">229     }</span>
230 
<span class="line-modified">231     m_uncommittedContent.add(inlineItem, itemLogicalWidth);</span>
<span class="line-modified">232     if (breakingContext.isAtBreakingOpportunity)</span>
<span class="line-added">233         commitPendingContent();</span>
234 
<span class="line-modified">235     return inlineItem.isHardLineBreak() ? IsEndOfLine::Yes : IsEndOfLine::No;</span>
<span class="line-modified">236 }</span>















237 
<span class="line-modified">238 LineContent LineLayout::layout()</span>
<span class="line-modified">239 {</span>
<span class="line-modified">240     // Iterate through the inline content and place the inline boxes on the current line.</span>
<span class="line-modified">241     // Start with the partial text from the previous line.</span>
<span class="line-modified">242     auto firstInlineItem = m_lineInput.firstInlineItem;</span>
<span class="line-added">243     unsigned firstNonPartialIndex = firstInlineItem.index;</span>
<span class="line-added">244     if (firstInlineItem.partialContext) {</span>
<span class="line-added">245         // Handle partial inline item (split text from the previous line).</span>
<span class="line-added">246         auto&amp; originalTextItem = m_lineInput.inlineItems[firstInlineItem.index];</span>
<span class="line-added">247         RELEASE_ASSERT(originalTextItem-&gt;isText());</span>
<span class="line-added">248 </span>
<span class="line-added">249         auto textRange = *firstInlineItem.partialContext;</span>
<span class="line-added">250         // Construct a partial leading inline item.</span>
<span class="line-added">251         ASSERT(!m_leadingPartialInlineTextItem);</span>
<span class="line-added">252         m_leadingPartialInlineTextItem = downcast&lt;InlineTextItem&gt;(*originalTextItem).split(textRange.start, textRange.length);</span>
<span class="line-added">253         if (placeInlineItem(*m_leadingPartialInlineTextItem) == IsEndOfLine::Yes)</span>
<span class="line-added">254             return close();</span>
<span class="line-added">255         ++firstNonPartialIndex;</span>
<span class="line-added">256     }</span>
257 
<span class="line-modified">258     for (auto inlineItemIndex = firstNonPartialIndex; inlineItemIndex &lt; m_lineInput.inlineItems.size(); ++inlineItemIndex) {</span>
<span class="line-modified">259         if (placeInlineItem(*m_lineInput.inlineItems[inlineItemIndex]) == IsEndOfLine::Yes)</span>
<span class="line-added">260             return close();</span>
261     }
<span class="line-added">262     commitPendingContent();</span>
<span class="line-added">263     return close();</span>
<span class="line-added">264 }</span>
<span class="line-added">265 </span>
<span class="line-added">266 LineInput::LineInput(const Line::InitialConstraints&amp; initialLineConstraints, Line::SkipVerticalAligment skipVerticalAligment, IndexAndRange firstToProcess, const InlineItems&amp; inlineItems)</span>
<span class="line-added">267     : initialConstraints(initialLineConstraints)</span>
<span class="line-added">268     , skipVerticalAligment(skipVerticalAligment)</span>
<span class="line-added">269     , firstInlineItem(firstToProcess)</span>
<span class="line-added">270     , inlineItems(inlineItems)</span>
<span class="line-added">271 {</span>
<span class="line-added">272 }</span>
273 
<span class="line-modified">274 InlineFormattingContext::InlineLayout::InlineLayout(const InlineFormattingContext&amp; inlineFormattingContext)</span>
<span class="line-added">275     : m_layoutState(inlineFormattingContext.layoutState())</span>
<span class="line-added">276     , m_formattingRoot(downcast&lt;Container&gt;(inlineFormattingContext.root()))</span>
<span class="line-added">277 {</span>
278 }
279 
<span class="line-modified">280 void InlineFormattingContext::InlineLayout::layout(const InlineItems&amp; inlineItems, LayoutUnit widthConstraint) const</span>
281 {
<span class="line-modified">282     auto&amp; formattingRootDisplayBox = layoutState().displayBoxForLayoutBox(m_formattingRoot);</span>
<span class="line-added">283     auto&amp; floatingState = layoutState().establishedFormattingState(m_formattingRoot).floatingState();</span>
284 
<span class="line-added">285     auto lineLogicalTop = formattingRootDisplayBox.contentBoxTop();</span>
286     auto lineLogicalLeft = formattingRootDisplayBox.contentBoxLeft();


287 
<span class="line-modified">288     auto applyFloatConstraint = [&amp;](auto&amp; lineInput) {</span>
<span class="line-modified">289         // Check for intruding floats and adjust logical left/available width for this line accordingly.</span>
<span class="line-modified">290         if (floatingState.isEmpty())</span>
<span class="line-added">291             return;</span>
<span class="line-added">292         auto availableWidth = lineInput.initialConstraints.availableLogicalWidth;</span>
<span class="line-added">293         auto lineLogicalLeft = lineInput.initialConstraints.logicalTopLeft.x();</span>
<span class="line-added">294         auto floatConstraints = floatingState.constraints({ lineLogicalTop }, m_formattingRoot);</span>
295         // Check if these constraints actually put limitation on the line.
<span class="line-modified">296         if (floatConstraints.left &amp;&amp; floatConstraints.left-&gt;x &lt;= formattingRootDisplayBox.contentBoxLeft())</span>
297             floatConstraints.left = { };
298 
<span class="line-modified">299         if (floatConstraints.right &amp;&amp; floatConstraints.right-&gt;x &gt;= formattingRootDisplayBox.contentBoxRight())</span>
300             floatConstraints.right = { };
301 
<span class="line-added">302         // Set the minimum float bottom value as a hint for the next line if needed.</span>
<span class="line-added">303         static auto inifitePoint = PointInContextRoot::max();</span>
<span class="line-added">304         auto floatMinimumLogicalBottom = std::min(floatConstraints.left.valueOr(inifitePoint).y, floatConstraints.right.valueOr(inifitePoint).y);</span>
<span class="line-added">305         if (floatMinimumLogicalBottom != inifitePoint.y)</span>
<span class="line-added">306             lineInput.floatMinimumLogicalBottom = floatMinimumLogicalBottom;</span>
<span class="line-added">307 </span>
308         if (floatConstraints.left &amp;&amp; floatConstraints.right) {
<span class="line-modified">309             ASSERT(floatConstraints.left-&gt;x &lt;= floatConstraints.right-&gt;x);</span>
<span class="line-modified">310             availableWidth = floatConstraints.right-&gt;x - floatConstraints.left-&gt;x;</span>
<span class="line-modified">311             lineLogicalLeft = floatConstraints.left-&gt;x;</span>
312         } else if (floatConstraints.left) {
<span class="line-modified">313             ASSERT(floatConstraints.left-&gt;x &gt;= lineLogicalLeft);</span>
<span class="line-modified">314             availableWidth -= (floatConstraints.left-&gt;x - lineLogicalLeft);</span>
<span class="line-modified">315             lineLogicalLeft = floatConstraints.left-&gt;x;</span>
316         } else if (floatConstraints.right) {
<span class="line-modified">317             ASSERT(floatConstraints.right-&gt;x &gt;= lineLogicalLeft);</span>
<span class="line-modified">318             availableWidth = floatConstraints.right-&gt;x - lineLogicalLeft;</span>
319         }
<span class="line-modified">320         lineInput.initialConstraints.availableLogicalWidth = availableWidth;</span>
<span class="line-modified">321         lineInput.initialConstraints.logicalTopLeft.setX(lineLogicalLeft);</span>










































322     };
323 
<span class="line-modified">324     IndexAndRange currentInlineItem;</span>
<span class="line-modified">325     while (currentInlineItem.index &lt; inlineItems.size()) {</span>
<span class="line-modified">326         auto lineInput = LineInput { { { lineLogicalLeft, lineLogicalTop }, widthConstraint, Quirks::lineHeightConstraints(layoutState(), m_formattingRoot) }, Line::SkipVerticalAligment::No, currentInlineItem, inlineItems };</span>
<span class="line-modified">327         applyFloatConstraint(lineInput);</span>
<span class="line-modified">328         auto lineContent = LineLayout(layoutState(), lineInput).layout();</span>
<span class="line-modified">329         createDisplayRuns(*lineContent.runs, lineContent.floats, widthConstraint);</span>
<span class="line-modified">330         if (!lineContent.lastCommitted) {</span>
<span class="line-modified">331             // Floats prevented us putting any content on the line.</span>
<span class="line-modified">332             ASSERT(lineInput.floatMinimumLogicalBottom);</span>
<span class="line-modified">333             ASSERT(lineContent.runs-&gt;isEmpty());</span>
<span class="line-modified">334             lineLogicalTop = *lineInput.floatMinimumLogicalBottom;</span>
<span class="line-modified">335         } else {</span>
<span class="line-modified">336             currentInlineItem = { lineContent.lastCommitted-&gt;index + 1, WTF::nullopt };</span>
<span class="line-modified">337             lineLogicalTop = lineContent.runs-&gt;logicalBottom();</span>











338         }

















339     }





340 }
341 
<span class="line-modified">342 LayoutUnit InlineFormattingContext::InlineLayout::computedIntrinsicWidth(const InlineItems&amp; inlineItems, LayoutUnit widthConstraint) const</span>
343 {
<span class="line-modified">344     LayoutUnit maximumLineWidth;</span>
<span class="line-modified">345     IndexAndRange currentInlineItem;</span>
<span class="line-modified">346     while (currentInlineItem.index &lt; inlineItems.size()) {</span>
<span class="line-modified">347         auto lineContent = LineLayout(layoutState(), { { { }, widthConstraint, Quirks::lineHeightConstraints(layoutState(), m_formattingRoot) }, Line::SkipVerticalAligment::Yes, currentInlineItem, inlineItems }).layout();</span>
<span class="line-modified">348         currentInlineItem = { lineContent.lastCommitted-&gt;index + 1, WTF::nullopt };</span>
<span class="line-modified">349         LayoutUnit floatsWidth;</span>
<span class="line-modified">350         for (auto&amp; floatItem : lineContent.floats)</span>
<span class="line-modified">351             floatsWidth += layoutState().displayBoxForLayoutBox(floatItem-&gt;layoutBox()).marginBoxWidth();</span>
<span class="line-modified">352         maximumLineWidth = std::max(maximumLineWidth, floatsWidth + lineContent.runs-&gt;logicalWidth());</span>















353     }
<span class="line-added">354     return maximumLineWidth;</span>
355 }
356 
<span class="line-modified">357 void InlineFormattingContext::InlineLayout::createDisplayRuns(const Line::Content&amp; lineContent, const Vector&lt;WeakPtr&lt;InlineItem&gt;&gt;&amp; floats, LayoutUnit widthConstraint) const</span>
358 {
<span class="line-modified">359     auto&amp; formattingState = downcast&lt;InlineFormattingState&gt;(layoutState().establishedFormattingState(m_formattingRoot));</span>
<span class="line-modified">360     auto&amp; floatingState = formattingState.floatingState();</span>
<span class="line-modified">361     auto floatingContext = FloatingContext { floatingState };</span>
<span class="line-modified">362 </span>
<span class="line-modified">363     // Move floats to their final position.</span>
<span class="line-modified">364     for (auto floatItem : floats) {</span>
<span class="line-added">365         auto&amp; floatBox = floatItem-&gt;layoutBox();</span>
<span class="line-added">366         ASSERT(layoutState().hasDisplayBox(floatBox));</span>
<span class="line-added">367         auto&amp; displayBox = layoutState().displayBoxForLayoutBox(floatBox);</span>
<span class="line-added">368         // Set static position first.</span>
<span class="line-added">369         displayBox.setTopLeft({ lineContent.logicalLeft(), lineContent.logicalTop() });</span>
<span class="line-added">370         // Float it.</span>
<span class="line-added">371         displayBox.setTopLeft(floatingContext.positionForFloat(floatBox));</span>
<span class="line-added">372         floatingState.append(floatBox);</span>
<span class="line-added">373     }</span>
374 
<span class="line-modified">375     if (lineContent.isEmpty()) {</span>
<span class="line-modified">376         // Spec tells us to create a zero height, empty line box.</span>
<span class="line-modified">377         auto lineBoxRect = Display::Rect { lineContent.logicalTop(), lineContent.logicalLeft(), 0 , 0 };</span>
<span class="line-modified">378         formattingState.addLineBox({ lineBoxRect, lineContent.baseline(), lineContent.baselineOffset() });</span>
379         return;
<span class="line-added">380     }</span>
381 
<span class="line-modified">382     auto&amp; inlineDisplayRuns = formattingState.inlineRuns();</span>
<span class="line-modified">383     Optional&lt;unsigned&gt; previousLineLastRunIndex = inlineDisplayRuns.isEmpty() ? Optional&lt;unsigned&gt;() : inlineDisplayRuns.size() - 1;</span>
<span class="line-modified">384     // 9.4.2 Inline formatting contexts</span>
<span class="line-modified">385     // A line box is always tall enough for all of the boxes it contains.</span>
<span class="line-modified">386     auto lineBoxRect = Display::Rect { lineContent.logicalTop(), lineContent.logicalLeft(), 0, lineContent.logicalHeight()};</span>
<span class="line-modified">387     // Create final display runs.</span>
<span class="line-modified">388     auto&amp; lineRuns = lineContent.runs();</span>
<span class="line-added">389     for (unsigned index = 0; index &lt; lineRuns.size(); ++index) {</span>
<span class="line-added">390         auto&amp; lineRun = lineRuns.at(index);</span>
<span class="line-added">391         auto&amp; logicalRect = lineRun-&gt;logicalRect();</span>
<span class="line-added">392         auto&amp; layoutBox = lineRun-&gt;layoutBox();</span>
<span class="line-added">393         auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);</span>
<span class="line-added">394 </span>
<span class="line-added">395         if (lineRun-&gt;isLineBreak()) {</span>
<span class="line-added">396             displayBox.setTopLeft(logicalRect.topLeft());</span>
<span class="line-added">397             displayBox.setContentBoxWidth(logicalRect.width());</span>
<span class="line-added">398             displayBox.setContentBoxHeight(logicalRect.height());</span>
<span class="line-added">399             formattingState.addInlineRun(makeUnique&lt;Display::Run&gt;(logicalRect));</span>
<span class="line-added">400             continue;</span>
<span class="line-added">401         }</span>
402 
<span class="line-modified">403         // Inline level box (replaced or inline-block)</span>
<span class="line-modified">404         if (lineRun-&gt;isBox()) {</span>
<span class="line-modified">405             auto topLeft = logicalRect.topLeft();</span>
<span class="line-added">406             if (layoutBox.isInFlowPositioned())</span>
<span class="line-added">407                 topLeft += Geometry::inFlowPositionedPositionOffset(layoutState(), layoutBox);</span>
<span class="line-added">408             displayBox.setTopLeft(topLeft);</span>
<span class="line-added">409             lineBoxRect.expandHorizontally(logicalRect.width());</span>
<span class="line-added">410             formattingState.addInlineRun(makeUnique&lt;Display::Run&gt;(logicalRect));</span>
<span class="line-added">411             continue;</span>
<span class="line-added">412         }</span>
413 
<span class="line-modified">414         // Inline level container start (&lt;span&gt;)</span>
<span class="line-modified">415         if (lineRun-&gt;isContainerStart()) {</span>
<span class="line-modified">416             displayBox.setTopLeft(logicalRect.topLeft());</span>
<span class="line-modified">417             lineBoxRect.expandHorizontally(logicalRect.width());</span>
<span class="line-modified">418             continue;</span>
<span class="line-modified">419         }</span>





420 
<span class="line-modified">421         // Inline level container end (&lt;/span&gt;)</span>
<span class="line-modified">422         if (lineRun-&gt;isContainerEnd()) {</span>
<span class="line-modified">423             if (layoutBox.isInFlowPositioned()) {</span>
<span class="line-modified">424                 auto inflowOffset = Geometry::inFlowPositionedPositionOffset(layoutState(), layoutBox);</span>
<span class="line-modified">425                 displayBox.moveHorizontally(inflowOffset.width());</span>
<span class="line-modified">426                 displayBox.moveVertically(inflowOffset.height());</span>








427             }
<span class="line-modified">428             auto marginBoxWidth = logicalRect.left() - displayBox.left();</span>
<span class="line-modified">429             auto contentBoxWidth = marginBoxWidth - (displayBox.marginStart() + displayBox.borderLeft() + displayBox.paddingLeft().valueOr(0));</span>
<span class="line-added">430             // FIXME fix it for multiline.</span>
<span class="line-added">431             displayBox.setContentBoxWidth(contentBoxWidth);</span>
<span class="line-added">432             displayBox.setContentBoxHeight(logicalRect.height());</span>
<span class="line-added">433             lineBoxRect.expandHorizontally(logicalRect.width());</span>
<span class="line-added">434             continue;</span>
<span class="line-added">435         }</span>
436 
<span class="line-modified">437         // Text content. Try to join multiple text runs when possible.</span>
<span class="line-modified">438         ASSERT(lineRun-&gt;isText());</span>
<span class="line-modified">439         auto textContext = lineRun-&gt;textContext();</span>
<span class="line-added">440         const Line::Content::Run* previousLineRun = !index ? nullptr : lineRuns[index - 1].get();</span>
<span class="line-added">441         if (!textContext-&gt;isCollapsed) {</span>
<span class="line-added">442             auto previousRunCanBeExtended = previousLineRun &amp;&amp; previousLineRun-&gt;textContext() ? previousLineRun-&gt;textContext()-&gt;canBeExtended : false;</span>
<span class="line-added">443             auto requiresNewRun = !index || !previousRunCanBeExtended || &amp;layoutBox != &amp;previousLineRun-&gt;layoutBox();</span>
<span class="line-added">444             if (requiresNewRun)</span>
<span class="line-added">445                 formattingState.addInlineRun(makeUnique&lt;Display::Run&gt;(logicalRect, Display::Run::TextContext { textContext-&gt;start, textContext-&gt;length }));</span>
<span class="line-added">446             else {</span>
<span class="line-added">447                 auto&amp; lastDisplayRun = formattingState.inlineRuns().last();</span>
<span class="line-added">448                 lastDisplayRun-&gt;expandHorizontally(logicalRect.width());</span>
<span class="line-added">449                 lastDisplayRun-&gt;textContext()-&gt;expand(textContext-&gt;length);</span>
<span class="line-added">450             }</span>
<span class="line-added">451             lineBoxRect.expandHorizontally(logicalRect.width());</span>
<span class="line-added">452         }</span>
<span class="line-added">453         // FIXME take content breaking into account when part of the layout box is on the previous line.</span>
<span class="line-added">454         auto firstInlineRunForLayoutBox = !previousLineRun || &amp;previousLineRun-&gt;layoutBox() != &amp;layoutBox;</span>
<span class="line-added">455         if (firstInlineRunForLayoutBox) {</span>
<span class="line-added">456             // Setup display box for the associated layout box.</span>
<span class="line-added">457             displayBox.setTopLeft(logicalRect.topLeft());</span>
<span class="line-added">458             displayBox.setContentBoxWidth(textContext-&gt;isCollapsed ? LayoutUnit() : logicalRect.width());</span>
<span class="line-added">459             displayBox.setContentBoxHeight(logicalRect.height());</span>
<span class="line-added">460         } else if (!textContext-&gt;isCollapsed) {</span>
<span class="line-added">461             // FIXME fix it for multirun/multiline.</span>
<span class="line-added">462             displayBox.setContentBoxWidth(displayBox.contentBoxWidth() + logicalRect.width());</span>
463         }
464     }
<span class="line-added">465     // FIXME linebox needs to be ajusted after content alignment.</span>
<span class="line-added">466     formattingState.addLineBox({ lineBoxRect, lineContent.baseline(), lineContent.baselineOffset() });</span>
<span class="line-added">467     alignRuns(m_formattingRoot.style().textAlign(), inlineDisplayRuns, previousLineLastRunIndex.valueOr(-1) + 1, widthConstraint - lineContent.logicalWidth());</span>
468 }
469 
<span class="line-modified">470 static Optional&lt;LayoutUnit&gt; horizontalAdjustmentForAlignment(TextAlignMode align, LayoutUnit remainingWidth)</span>
471 {
472     switch (align) {
473     case TextAlignMode::Left:
474     case TextAlignMode::WebKitLeft:
475     case TextAlignMode::Start:
<span class="line-modified">476         return { };</span>
477     case TextAlignMode::Right:
478     case TextAlignMode::WebKitRight:
479     case TextAlignMode::End:
<span class="line-modified">480         return std::max(remainingWidth, 0_lu);</span>
481     case TextAlignMode::Center:
482     case TextAlignMode::WebKitCenter:
<span class="line-modified">483         return std::max(remainingWidth / 2, 0_lu);</span>
484     case TextAlignMode::Justify:
485         ASSERT_NOT_REACHED();
486         break;
487     }
488     ASSERT_NOT_REACHED();
<span class="line-modified">489     return { };</span>


























































490 }
491 
<span class="line-modified">492 void InlineFormattingContext::InlineLayout::alignRuns(TextAlignMode textAlign, InlineRuns&amp; inlineDisplayRuns, unsigned firstRunIndex, LayoutUnit availableWidth) const</span>
493 {
<span class="line-modified">494     auto adjustment = horizontalAdjustmentForAlignment(textAlign, availableWidth);</span>
<span class="line-modified">495     if (!adjustment)</span>

496         return;











497 
<span class="line-modified">498     for (unsigned index = firstRunIndex; index &lt; inlineDisplayRuns.size(); ++index)</span>
<span class="line-modified">499         inlineDisplayRuns[index]-&gt;moveHorizontally(*adjustment);</span>




















500 }
501 
502 }
503 }
504 
505 #endif
</pre>
</td>
</tr>
</table>
<center><a href="InlineFormattingContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InlineFormattingState.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>