<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ComplexTextController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2007, 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;ComplexTextController.h&quot;
 27 
 28 #include &quot;CharacterProperties.h&quot;
 29 #include &quot;FloatSize.h&quot;
 30 #include &quot;FontCascade.h&quot;
 31 #include &quot;RenderBlock.h&quot;
 32 #include &quot;RenderText.h&quot;
 33 #include &quot;TextRun.h&quot;
 34 #include &lt;unicode/ubrk.h&gt;
 35 #include &lt;wtf/Optional.h&gt;
 36 #include &lt;wtf/StdLibExtras.h&gt;
 37 #include &lt;wtf/text/TextBreakIterator.h&gt;
 38 #include &lt;wtf/unicode/CharacterNames.h&gt;
 39 
 40 #if PLATFORM(IOS_FAMILY)
 41 #include &lt;CoreText/CoreText.h&gt;
 42 #endif
 43 
 44 namespace WebCore {
 45 
 46 #if PLATFORM(WIN)
 47 
 48 class TextLayout {
 49 };
 50 
 51 void TextLayoutDeleter::operator()(TextLayout*) const
 52 {
 53 }
 54 
 55 std::unique_ptr&lt;TextLayout, TextLayoutDeleter&gt; FontCascade::createLayout(RenderText&amp;, float, bool) const
 56 {
 57     return nullptr;
 58 }
 59 
 60 float FontCascade::width(TextLayout&amp;, unsigned, unsigned, HashSet&lt;const Font*&gt;*)
 61 {
 62     ASSERT_NOT_REACHED();
 63     return 0;
 64 }
 65 
 66 #else
 67 
 68 class TextLayout {
 69     WTF_MAKE_FAST_ALLOCATED;
 70 public:
 71     static bool isNeeded(RenderText&amp; text, const FontCascade&amp; font)
 72     {
 73         TextRun run = RenderBlock::constructTextRun(text, text.style());
 74         return font.codePath(run) == FontCascade::Complex;
 75     }
 76 
 77     TextLayout(RenderText&amp; text, const FontCascade&amp; font, float xPos)
 78         : m_font(font)
 79         , m_run(constructTextRun(text, xPos))
<a name="1" id="anc1"></a><span class="line-modified"> 80         , m_controller(makeUnique&lt;ComplexTextController&gt;(m_font, m_run, true))</span>
 81     {
 82     }
 83 
 84     float width(unsigned from, unsigned len, HashSet&lt;const Font*&gt;* fallbackFonts)
 85     {
 86         m_controller-&gt;advance(from, 0, ByWholeGlyphs, fallbackFonts);
 87         float beforeWidth = m_controller-&gt;runWidthSoFar();
 88         if (m_font.wordSpacing() &amp;&amp; from &amp;&amp; FontCascade::treatAsSpace(m_run[from]))
 89             beforeWidth += m_font.wordSpacing();
 90         m_controller-&gt;advance(from + len, 0, ByWholeGlyphs, fallbackFonts);
 91         float afterWidth = m_controller-&gt;runWidthSoFar();
 92         return afterWidth - beforeWidth;
 93     }
 94 
 95 private:
 96     static TextRun constructTextRun(RenderText&amp; text, float xPos)
 97     {
 98         TextRun run = RenderBlock::constructTextRun(text, text.style());
 99         run.setXPos(xPos);
100         return run;
101     }
102 
103     // ComplexTextController has only references to its FontCascade and TextRun so they must be kept alive here.
104     FontCascade m_font;
105     TextRun m_run;
106     std::unique_ptr&lt;ComplexTextController&gt; m_controller;
107 };
108 
109 void TextLayoutDeleter::operator()(TextLayout* layout) const
110 {
111     delete layout;
112 }
113 
114 std::unique_ptr&lt;TextLayout, TextLayoutDeleter&gt; FontCascade::createLayout(RenderText&amp; text, float xPos, bool collapseWhiteSpace) const
115 {
116     if (!collapseWhiteSpace || !TextLayout::isNeeded(text, *this))
117         return nullptr;
118     return std::unique_ptr&lt;TextLayout, TextLayoutDeleter&gt;(new TextLayout(text, *this, xPos));
119 }
120 
121 float FontCascade::width(TextLayout&amp; layout, unsigned from, unsigned len, HashSet&lt;const Font*&gt;* fallbackFonts)
122 {
123     return layout.width(from, len, fallbackFonts);
124 }
125 
126 void ComplexTextController::computeExpansionOpportunity()
127 {
128     if (!m_expansion)
129         m_expansionPerOpportunity = 0;
130     else {
131         unsigned expansionOpportunityCount = FontCascade::expansionOpportunityCount(m_run.text(), m_run.ltr() ? TextDirection::LTR : TextDirection::RTL, m_run.expansionBehavior()).first;
132 
133         if (!expansionOpportunityCount)
134             m_expansionPerOpportunity = 0;
135         else
136             m_expansionPerOpportunity = m_expansion / expansionOpportunityCount;
137     }
138 }
139 
140 ComplexTextController::ComplexTextController(const FontCascade&amp; font, const TextRun&amp; run, bool mayUseNaturalWritingDirection, HashSet&lt;const Font*&gt;* fallbackFonts, bool forTextEmphasis)
141     : m_fallbackFonts(fallbackFonts)
142     , m_font(font)
143     , m_run(run)
144     , m_end(run.length())
145     , m_expansion(run.expansion())
146     , m_mayUseNaturalWritingDirection(mayUseNaturalWritingDirection)
147     , m_forTextEmphasis(forTextEmphasis)
148 {
149 #if PLATFORM(WIN)
150     ASSERT_NOT_REACHED();
151 #endif
152 
153     computeExpansionOpportunity();
154 
155     collectComplexTextRuns();
156 
157     finishConstruction();
158 }
159 
160 ComplexTextController::ComplexTextController(const FontCascade&amp; font, const TextRun&amp; run, Vector&lt;Ref&lt;ComplexTextRun&gt;&gt;&amp; runs)
161     : m_font(font)
162     , m_run(run)
163     , m_end(run.length())
164     , m_expansion(run.expansion())
165 {
166     computeExpansionOpportunity();
167 
168     for (auto&amp; run : runs)
169         m_complexTextRuns.append(run.ptr());
170 
171     finishConstruction();
172 }
173 
174 void ComplexTextController::finishConstruction()
175 {
176     adjustGlyphsAndAdvances();
177 
178     if (!m_isLTROnly) {
179         m_runIndices.reserveInitialCapacity(m_complexTextRuns.size());
180 
181         m_glyphCountFromStartToIndex.reserveInitialCapacity(m_complexTextRuns.size());
182         unsigned glyphCountSoFar = 0;
183         for (unsigned i = 0; i &lt; m_complexTextRuns.size(); ++i) {
184             m_glyphCountFromStartToIndex.uncheckedAppend(glyphCountSoFar);
185             glyphCountSoFar += m_complexTextRuns[i]-&gt;glyphCount();
186         }
187     }
188 }
189 
190 unsigned ComplexTextController::offsetForPosition(float h, bool includePartialGlyphs)
191 {
192     if (h &gt;= m_totalWidth)
193         return m_run.ltr() ? m_end : 0;
194 
195     if (h &lt; 0)
196         return m_run.ltr() ? 0 : m_end;
197 
198     float x = h;
199 
200     size_t runCount = m_complexTextRuns.size();
201     unsigned offsetIntoAdjustedGlyphs = 0;
202 
203     for (size_t r = 0; r &lt; runCount; ++r) {
204         const ComplexTextRun&amp; complexTextRun = *m_complexTextRuns[r];
205         for (unsigned j = 0; j &lt; complexTextRun.glyphCount(); ++j) {
206             unsigned index = offsetIntoAdjustedGlyphs + j;
207             float adjustedAdvance = m_adjustedBaseAdvances[index].width();
<a name="2" id="anc2"></a><span class="line-modified">208             bool hit = m_run.ltr() ? x &lt; adjustedAdvance : (x &lt;= adjustedAdvance &amp;&amp; adjustedAdvance);</span>
<span class="line-added">209             if (hit) {</span>
210                 unsigned hitGlyphStart = complexTextRun.indexAt(j);
211                 unsigned hitGlyphEnd;
212                 if (m_run.ltr())
213                     hitGlyphEnd = std::max(hitGlyphStart, j + 1 &lt; complexTextRun.glyphCount() ? complexTextRun.indexAt(j + 1) : complexTextRun.indexEnd());
214                 else
215                     hitGlyphEnd = std::max(hitGlyphStart, j &gt; 0 ? complexTextRun.indexAt(j - 1) : complexTextRun.indexEnd());
216 
217                 // FIXME: Instead of dividing the glyph&#39;s advance equally between the characters, this
218                 // could use the glyph&#39;s &quot;ligature carets&quot;. This is available in CoreText via CTFontGetLigatureCaretPositions().
<a name="3" id="anc3"></a><span class="line-modified">219                 unsigned hitIndex;</span>
<span class="line-added">220                 if (m_run.ltr())</span>
<span class="line-added">221                     hitIndex = hitGlyphStart + (hitGlyphEnd - hitGlyphStart) * (x / adjustedAdvance);</span>
<span class="line-added">222                 else {</span>
<span class="line-added">223                     if (hitGlyphStart == hitGlyphEnd)</span>
<span class="line-added">224                         hitIndex = hitGlyphStart;</span>
<span class="line-added">225                     else if (x)</span>
<span class="line-added">226                         hitIndex = hitGlyphEnd - (hitGlyphEnd - hitGlyphStart) * (x / adjustedAdvance);</span>
<span class="line-added">227                     else</span>
<span class="line-added">228                         hitIndex = hitGlyphEnd - 1;</span>
<span class="line-added">229                 }</span>
<span class="line-added">230 </span>
231                 unsigned stringLength = complexTextRun.stringLength();
232                 CachedTextBreakIterator cursorPositionIterator(StringView(complexTextRun.characters(), stringLength), TextBreakIterator::Mode::Caret, nullAtom());
233                 unsigned clusterStart;
234                 if (cursorPositionIterator.isBoundary(hitIndex))
235                     clusterStart = hitIndex;
236                 else
237                     clusterStart = cursorPositionIterator.preceding(hitIndex).valueOr(0);
238 
239                 if (!includePartialGlyphs)
240                     return complexTextRun.stringLocation() + clusterStart;
241 
242                 unsigned clusterEnd = cursorPositionIterator.following(hitIndex).valueOr(stringLength);
243 
244                 float clusterWidth;
245                 // FIXME: The search stops at the boundaries of complexTextRun. In theory, it should go on into neighboring ComplexTextRuns
246                 // derived from the same CTLine. In practice, we do not expect there to be more than one CTRun in a CTLine, as no
247                 // reordering and no font fallback should occur within a CTLine.
248                 if (clusterEnd - clusterStart &gt; 1) {
249                     clusterWidth = adjustedAdvance;
250                     if (j) {
251                         unsigned firstGlyphBeforeCluster = j - 1;
252                         while (complexTextRun.indexAt(firstGlyphBeforeCluster) &gt;= clusterStart &amp;&amp; complexTextRun.indexAt(firstGlyphBeforeCluster) &lt; clusterEnd) {
253                             float width = m_adjustedBaseAdvances[offsetIntoAdjustedGlyphs + firstGlyphBeforeCluster].width();
254                             clusterWidth += width;
255                             x += width;
256                             if (!firstGlyphBeforeCluster)
257                                 break;
258                             firstGlyphBeforeCluster--;
259                         }
260                     }
261                     unsigned firstGlyphAfterCluster = j + 1;
262                     while (firstGlyphAfterCluster &lt; complexTextRun.glyphCount() &amp;&amp; complexTextRun.indexAt(firstGlyphAfterCluster) &gt;= clusterStart &amp;&amp; complexTextRun.indexAt(firstGlyphAfterCluster) &lt; clusterEnd) {
263                         clusterWidth += m_adjustedBaseAdvances[offsetIntoAdjustedGlyphs + firstGlyphAfterCluster].width();
264                         firstGlyphAfterCluster++;
265                     }
266                 } else {
267                     clusterWidth = adjustedAdvance / (hitGlyphEnd - hitGlyphStart);
268                     x -=  clusterWidth * (m_run.ltr() ? hitIndex - hitGlyphStart : hitGlyphEnd - hitIndex - 1);
269                 }
270                 if (x &lt;= clusterWidth / 2)
271                     return complexTextRun.stringLocation() + (m_run.ltr() ? clusterStart : clusterEnd);
272                 return complexTextRun.stringLocation() + (m_run.ltr() ? clusterEnd : clusterStart);
273             }
274             x -= adjustedAdvance;
275         }
276         offsetIntoAdjustedGlyphs += complexTextRun.glyphCount();
277     }
278 
279     ASSERT_NOT_REACHED();
280     return 0;
281 }
282 
283 // FIXME: We should consider reimplementing this function using ICU to advance by grapheme.
284 // The current implementation only considers explicitly emoji sequences and emoji variations.
285 static bool advanceByCombiningCharacterSequence(const UChar*&amp; iterator, const UChar* end, UChar32&amp; baseCharacter, unsigned&amp; markCount)
286 {
287     ASSERT(iterator &lt; end);
288 
289     markCount = 0;
290 
291     unsigned i = 0;
292     unsigned remainingCharacters = end - iterator;
293     U16_NEXT(iterator, i, remainingCharacters, baseCharacter);
294     iterator = iterator + i;
295     if (U_IS_SURROGATE(baseCharacter))
296         return false;
297 
298     // Consume marks.
299     bool sawEmojiGroupCandidate = isEmojiGroupCandidate(baseCharacter);
300     bool sawJoiner = false;
301     bool sawRegionalIndicator = isEmojiRegionalIndicator(baseCharacter);
302     while (iterator &lt; end) {
303         UChar32 nextCharacter;
304         unsigned markLength = 0;
305         bool shouldContinue = false;
306         ASSERT(end &gt;= iterator);
307         U16_NEXT(iterator, markLength, static_cast&lt;unsigned&gt;(end - iterator), nextCharacter);
308 
309         if (isVariationSelector(nextCharacter) || isEmojiFitzpatrickModifier(nextCharacter))
310             shouldContinue = true;
311 
312         if (sawRegionalIndicator &amp;&amp; isEmojiRegionalIndicator(nextCharacter)) {
313             shouldContinue = true;
314             sawRegionalIndicator = false;
315         }
316 
317         if (sawJoiner &amp;&amp; isEmojiGroupCandidate(nextCharacter))
318             shouldContinue = true;
319 
320         sawJoiner = false;
321         if (sawEmojiGroupCandidate &amp;&amp; nextCharacter == zeroWidthJoiner) {
322             sawJoiner = true;
323             shouldContinue = true;
324         }
325 
326         if (!shouldContinue &amp;&amp; !(U_GET_GC_MASK(nextCharacter) &amp; U_GC_M_MASK))
327             break;
328 
329         markCount += markLength;
330         iterator += markLength;
331     }
332 
333     return true;
334 }
335 
336 // FIXME: Capitalization is language-dependent and context-dependent and should operate on grapheme clusters instead of codepoints.
337 static inline Optional&lt;UChar32&gt; capitalized(UChar32 baseCharacter)
338 {
339     if (U_GET_GC_MASK(baseCharacter) &amp; U_GC_M_MASK)
340         return WTF::nullopt;
341 
342     UChar32 uppercaseCharacter = u_toupper(baseCharacter);
343     ASSERT(uppercaseCharacter == baseCharacter || (U_IS_BMP(baseCharacter) == U_IS_BMP(uppercaseCharacter)));
344     if (uppercaseCharacter != baseCharacter)
345         return uppercaseCharacter;
346     return WTF::nullopt;
347 }
348 
349 static bool shouldSynthesize(bool dontSynthesizeSmallCaps, const Font* nextFont, UChar32 baseCharacter, Optional&lt;UChar32&gt; capitalizedBase, FontVariantCaps fontVariantCaps, bool engageAllSmallCapsProcessing)
350 {
351     if (dontSynthesizeSmallCaps)
352         return false;
353     if (!nextFont || nextFont == Font::systemFallback())
354         return false;
355     if (engageAllSmallCapsProcessing &amp;&amp; isASCIISpace(baseCharacter))
356         return false;
357     if (!engageAllSmallCapsProcessing &amp;&amp; !capitalizedBase)
358         return false;
359     return !nextFont-&gt;variantCapsSupportsCharacterForSynthesis(fontVariantCaps, baseCharacter);
360 }
361 
362 void ComplexTextController::collectComplexTextRuns()
363 {
364     if (!m_end)
365         return;
366 
367     // We break up glyph run generation for the string by Font.
368     const UChar* cp;
369 
370     if (m_run.is8Bit()) {
371         String stringFor8BitRun = String::make16BitFrom8BitSource(m_run.characters8(), m_run.length());
372         m_stringsFor8BitRuns.append(WTFMove(stringFor8BitRun));
373         cp = m_stringsFor8BitRuns.last().characters16();
374     } else
375         cp = m_run.characters16();
376 
377     auto fontVariantCaps = m_font.fontDescription().variantCaps();
378     bool dontSynthesizeSmallCaps = !static_cast&lt;bool&gt;(m_font.fontDescription().fontSynthesis() &amp; FontSynthesisSmallCaps);
379     bool engageAllSmallCapsProcessing = fontVariantCaps == FontVariantCaps::AllSmall || fontVariantCaps == FontVariantCaps::AllPetite;
380     bool engageSmallCapsProcessing = engageAllSmallCapsProcessing || fontVariantCaps == FontVariantCaps::Small || fontVariantCaps == FontVariantCaps::Petite;
381 
382     if (engageAllSmallCapsProcessing || engageSmallCapsProcessing)
383         m_smallCapsBuffer.resize(m_end);
384 
385     unsigned indexOfFontTransition = 0;
386     const UChar* curr = cp;
387     const UChar* end = cp + m_end;
388 
389     const Font* font;
390     const Font* nextFont;
391     const Font* synthesizedFont = nullptr;
392     const Font* smallSynthesizedFont = nullptr;
393 
394     unsigned markCount;
395     UChar32 baseCharacter;
396     if (!advanceByCombiningCharacterSequence(curr, end, baseCharacter, markCount))
397         return;
398 
399     nextFont = m_font.fontForCombiningCharacterSequence(cp, curr - cp);
400 
401     bool isSmallCaps = false;
402     bool nextIsSmallCaps = false;
403 
404     auto capitalizedBase = capitalized(baseCharacter);
405     if (shouldSynthesize(dontSynthesizeSmallCaps, nextFont, baseCharacter, capitalizedBase, fontVariantCaps, engageAllSmallCapsProcessing)) {
406         synthesizedFont = &amp;nextFont-&gt;noSynthesizableFeaturesFont();
407         smallSynthesizedFont = synthesizedFont-&gt;smallCapsFont(m_font.fontDescription());
408         UChar32 characterToWrite = capitalizedBase ? capitalizedBase.value() : cp[0];
409         unsigned characterIndex = 0;
410         U16_APPEND_UNSAFE(m_smallCapsBuffer, characterIndex, characterToWrite);
411         for (unsigned i = characterIndex; cp + i &lt; curr; ++i)
412             m_smallCapsBuffer[i] = cp[i];
413         nextIsSmallCaps = true;
414     }
415 
416     while (curr &lt; end) {
417         font = nextFont;
418         isSmallCaps = nextIsSmallCaps;
419         unsigned index = curr - cp;
420 
421         if (!advanceByCombiningCharacterSequence(curr, end, baseCharacter, markCount))
422             return;
423 
424         if (synthesizedFont) {
425             if (auto capitalizedBase = capitalized(baseCharacter)) {
426                 unsigned characterIndex = index;
427                 U16_APPEND_UNSAFE(m_smallCapsBuffer, characterIndex, capitalizedBase.value());
428                 for (unsigned i = 0; i &lt; markCount; ++i)
429                     m_smallCapsBuffer[i + characterIndex] = cp[i + characterIndex];
430                 nextIsSmallCaps = true;
431             } else {
432                 if (engageAllSmallCapsProcessing) {
433                     for (unsigned i = 0; i &lt; curr - cp - index; ++i)
434                         m_smallCapsBuffer[index + i] = cp[index + i];
435                 }
436                 nextIsSmallCaps = engageAllSmallCapsProcessing;
437             }
438         }
439 
440         if (baseCharacter == zeroWidthJoiner)
441             nextFont = font;
442         else
443             nextFont = m_font.fontForCombiningCharacterSequence(cp + index, curr - cp - index);
444 
445         capitalizedBase = capitalized(baseCharacter);
446         if (!synthesizedFont &amp;&amp; shouldSynthesize(dontSynthesizeSmallCaps, nextFont, baseCharacter, capitalizedBase, fontVariantCaps, engageAllSmallCapsProcessing)) {
447             // Rather than synthesize each character individually, we should synthesize the entire &quot;run&quot; if any character requires synthesis.
448             synthesizedFont = &amp;nextFont-&gt;noSynthesizableFeaturesFont();
449             smallSynthesizedFont = synthesizedFont-&gt;smallCapsFont(m_font.fontDescription());
450             nextIsSmallCaps = true;
451             curr = cp + indexOfFontTransition;
452             continue;
453         }
454 
455         if (nextFont != font || nextIsSmallCaps != isSmallCaps) {
456             unsigned itemLength = index - indexOfFontTransition;
457             if (itemLength) {
458                 unsigned itemStart = indexOfFontTransition;
459                 if (synthesizedFont) {
460                     if (isSmallCaps)
461                         collectComplexTextRunsForCharacters(m_smallCapsBuffer.data() + itemStart, itemLength, itemStart, smallSynthesizedFont);
462                     else
463                         collectComplexTextRunsForCharacters(cp + itemStart, itemLength, itemStart, synthesizedFont);
464                 } else
465                     collectComplexTextRunsForCharacters(cp + itemStart, itemLength, itemStart, font);
466                 if (nextFont != font) {
467                     synthesizedFont = nullptr;
468                     smallSynthesizedFont = nullptr;
469                     nextIsSmallCaps = false;
470                 }
471             }
472             indexOfFontTransition = index;
473         }
474     }
475 
476     ASSERT(m_end &gt;= indexOfFontTransition);
477     unsigned itemLength = m_end - indexOfFontTransition;
478     if (itemLength) {
479         unsigned itemStart = indexOfFontTransition;
480         if (synthesizedFont) {
481             if (nextIsSmallCaps)
482                 collectComplexTextRunsForCharacters(m_smallCapsBuffer.data() + itemStart, itemLength, itemStart, smallSynthesizedFont);
483             else
484                 collectComplexTextRunsForCharacters(cp + itemStart, itemLength, itemStart, synthesizedFont);
485         } else
486             collectComplexTextRunsForCharacters(cp + itemStart, itemLength, itemStart, nextFont);
487     }
488 
489     if (!m_run.ltr())
490         m_complexTextRuns.reverse();
491 }
492 
493 unsigned ComplexTextController::ComplexTextRun::indexAt(unsigned i) const
494 {
495     ASSERT(i &lt; m_glyphCount);
496 
497     return m_coreTextIndices[i];
498 }
499 
500 void ComplexTextController::ComplexTextRun::setIsNonMonotonic()
501 {
502     ASSERT(m_isMonotonic);
503     m_isMonotonic = false;
504 
505     Vector&lt;bool, 64&gt; mappedIndices(m_stringLength, false);
506     for (unsigned i = 0; i &lt; m_glyphCount; ++i) {
507         ASSERT(indexAt(i) &lt; m_stringLength);
508         mappedIndices[indexAt(i)] = true;
509     }
510 
511     m_glyphEndOffsets.grow(m_glyphCount);
512     for (unsigned i = 0; i &lt; m_glyphCount; ++i) {
513         unsigned nextMappedIndex = m_indexEnd;
514         for (unsigned j = indexAt(i) + 1; j &lt; m_stringLength; ++j) {
515             if (mappedIndices[j]) {
516                 nextMappedIndex = j;
517                 break;
518             }
519         }
520         m_glyphEndOffsets[i] = nextMappedIndex;
521     }
522 }
523 
524 unsigned ComplexTextController::indexOfCurrentRun(unsigned&amp; leftmostGlyph)
525 {
526     leftmostGlyph = 0;
527 
528     size_t runCount = m_complexTextRuns.size();
529     if (m_currentRun &gt;= runCount)
530         return runCount;
531 
532     if (m_isLTROnly) {
533         for (unsigned i = 0; i &lt; m_currentRun; ++i)
534             leftmostGlyph += m_complexTextRuns[i]-&gt;glyphCount();
535         return m_currentRun;
536     }
537 
538     if (m_runIndices.isEmpty()) {
539         unsigned firstRun = 0;
540         unsigned firstRunOffset = stringBegin(*m_complexTextRuns[0]);
541         for (unsigned i = 1; i &lt; runCount; ++i) {
542             unsigned offset = stringBegin(*m_complexTextRuns[i]);
543             if (offset &lt; firstRunOffset) {
544                 firstRun = i;
545                 firstRunOffset = offset;
546             }
547         }
548         m_runIndices.uncheckedAppend(firstRun);
549     }
550 
551     while (m_runIndices.size() &lt;= m_currentRun) {
552         unsigned offset = stringEnd(*m_complexTextRuns[m_runIndices.last()]);
553 
554         for (unsigned i = 0; i &lt; runCount; ++i) {
555             if (offset == stringBegin(*m_complexTextRuns[i])) {
556                 m_runIndices.uncheckedAppend(i);
557                 break;
558             }
559         }
560     }
561 
562     unsigned currentRunIndex = m_runIndices[m_currentRun];
563     leftmostGlyph = m_glyphCountFromStartToIndex[currentRunIndex];
564     return currentRunIndex;
565 }
566 
567 unsigned ComplexTextController::incrementCurrentRun(unsigned&amp; leftmostGlyph)
568 {
569     if (m_isLTROnly) {
570         leftmostGlyph += m_complexTextRuns[m_currentRun++]-&gt;glyphCount();
571         return m_currentRun;
572     }
573 
574     m_currentRun++;
575     leftmostGlyph = 0;
576     return indexOfCurrentRun(leftmostGlyph);
577 }
578 
579 float ComplexTextController::runWidthSoFarFraction(unsigned glyphStartOffset, unsigned glyphEndOffset, unsigned oldCharacterInCurrentGlyph, GlyphIterationStyle iterationStyle) const
580 {
581     // FIXME: Instead of dividing the glyph&#39;s advance equally between the characters, this
582     // could use the glyph&#39;s &quot;ligature carets&quot;. This is available in CoreText via CTFontGetLigatureCaretPositions().
583     if (glyphStartOffset == glyphEndOffset) {
584         // When there are multiple glyphs per character we need to advance by the full width of the glyph.
585         ASSERT(m_characterInCurrentGlyph == oldCharacterInCurrentGlyph);
586         return 1;
587     }
588 
589     if (iterationStyle == ByWholeGlyphs) {
590         if (!oldCharacterInCurrentGlyph)
591             return 1;
592         return 0;
593     }
594 
595     return static_cast&lt;float&gt;(m_characterInCurrentGlyph - oldCharacterInCurrentGlyph) / (glyphEndOffset - glyphStartOffset);
596 }
597 
598 void ComplexTextController::advance(unsigned offset, GlyphBuffer* glyphBuffer, GlyphIterationStyle iterationStyle, HashSet&lt;const Font*&gt;* fallbackFonts)
599 {
600     if (offset &gt; m_end)
601         offset = m_end;
602 
603     if (offset &lt;= m_currentCharacter) {
604         m_runWidthSoFar = 0;
605         m_numGlyphsSoFar = 0;
606         m_currentRun = 0;
607         m_glyphInCurrentRun = 0;
608         m_characterInCurrentGlyph = 0;
609     }
610 
611     m_currentCharacter = offset;
612 
613     size_t runCount = m_complexTextRuns.size();
614 
615     unsigned indexOfLeftmostGlyphInCurrentRun = 0; // Relative to the beginning of ComplexTextController.
616     unsigned currentRunIndex = indexOfCurrentRun(indexOfLeftmostGlyphInCurrentRun);
617     while (m_currentRun &lt; runCount) {
618         const ComplexTextRun&amp; complexTextRun = *m_complexTextRuns[currentRunIndex];
619         bool ltr = complexTextRun.isLTR();
620         unsigned glyphCount = complexTextRun.glyphCount();
621         unsigned glyphIndexIntoCurrentRun = ltr ? m_glyphInCurrentRun : glyphCount - 1 - m_glyphInCurrentRun;
622         unsigned glyphIndexIntoComplexTextController = indexOfLeftmostGlyphInCurrentRun + glyphIndexIntoCurrentRun;
623         if (fallbackFonts &amp;&amp; &amp;complexTextRun.font() != &amp;m_font.primaryFont())
624             fallbackFonts-&gt;add(&amp;complexTextRun.font());
625 
626         // We must store the initial advance for the first glyph we are going to draw.
627         // When leftmostGlyph is 0, it represents the first glyph to draw, taking into
628         // account the text direction.
629         if (!indexOfLeftmostGlyphInCurrentRun &amp;&amp; glyphBuffer)
630             glyphBuffer-&gt;setInitialAdvance(GlyphBufferAdvance(complexTextRun.initialAdvance().width(), complexTextRun.initialAdvance().height()));
631 
632         while (m_glyphInCurrentRun &lt; glyphCount) {
633             unsigned glyphStartOffset = complexTextRun.indexAt(glyphIndexIntoCurrentRun);
634             unsigned glyphEndOffset;
635             if (complexTextRun.isMonotonic()) {
636                 if (ltr)
637                     glyphEndOffset = std::max(glyphStartOffset, glyphIndexIntoCurrentRun + 1 &lt; glyphCount ? complexTextRun.indexAt(glyphIndexIntoCurrentRun + 1) : complexTextRun.indexEnd());
638                 else
639                     glyphEndOffset = std::max(glyphStartOffset, glyphIndexIntoCurrentRun &gt; 0 ? complexTextRun.indexAt(glyphIndexIntoCurrentRun - 1) : complexTextRun.indexEnd());
640             } else
641                 glyphEndOffset = complexTextRun.endOffsetAt(glyphIndexIntoCurrentRun);
642 
643             FloatSize adjustedBaseAdvance = m_adjustedBaseAdvances[glyphIndexIntoComplexTextController];
644 
645             if (glyphStartOffset + complexTextRun.stringLocation() &gt;= m_currentCharacter)
646                 return;
647 
648             if (glyphBuffer &amp;&amp; !m_characterInCurrentGlyph) {
649                 auto currentGlyphOrigin = glyphOrigin(glyphIndexIntoComplexTextController);
650                 GlyphBufferAdvance paintAdvance(adjustedBaseAdvance);
651                 if (!glyphIndexIntoCurrentRun) {
652                     // The first layout advance of every run includes the &quot;initial layout advance.&quot; However, here, we need
653                     // paint advances, so subtract it out before transforming the layout advance into a paint advance.
654                     paintAdvance.setWidth(paintAdvance.width() - (complexTextRun.initialAdvance().width() - currentGlyphOrigin.x()));
655                     paintAdvance.setHeight(paintAdvance.height() - (complexTextRun.initialAdvance().height() - currentGlyphOrigin.y()));
656                 }
657                 paintAdvance.setWidth(paintAdvance.width() + glyphOrigin(glyphIndexIntoComplexTextController + 1).x() - currentGlyphOrigin.x());
658                 paintAdvance.setHeight(paintAdvance.height() + glyphOrigin(glyphIndexIntoComplexTextController + 1).y() - currentGlyphOrigin.y());
659                 if (glyphIndexIntoCurrentRun == glyphCount - 1 &amp;&amp; currentRunIndex + 1 &lt; runCount) {
660                     // Our paint advance points to the end of the run. However, the next run may have an
661                     // initial advance, and our paint advance needs to point to the location of the next
662                     // glyph. So, we need to add in the next run&#39;s initial advance.
663                     paintAdvance.setWidth(paintAdvance.width() - glyphOrigin(glyphIndexIntoComplexTextController + 1).x() + m_complexTextRuns[currentRunIndex + 1]-&gt;initialAdvance().width());
664                     paintAdvance.setHeight(paintAdvance.height() - glyphOrigin(glyphIndexIntoComplexTextController + 1).y() + m_complexTextRuns[currentRunIndex + 1]-&gt;initialAdvance().height());
665                 }
666                 paintAdvance.setHeight(-paintAdvance.height()); // Increasing y points down
667                 glyphBuffer-&gt;add(m_adjustedGlyphs[glyphIndexIntoComplexTextController], &amp;complexTextRun.font(), paintAdvance, complexTextRun.indexAt(m_glyphInCurrentRun));
668             }
669 
670             unsigned oldCharacterInCurrentGlyph = m_characterInCurrentGlyph;
671             m_characterInCurrentGlyph = std::min(m_currentCharacter - complexTextRun.stringLocation(), glyphEndOffset) - glyphStartOffset;
672             m_runWidthSoFar += adjustedBaseAdvance.width() * runWidthSoFarFraction(glyphStartOffset, glyphEndOffset, oldCharacterInCurrentGlyph, iterationStyle);
673 
674             if (glyphEndOffset + complexTextRun.stringLocation() &gt; m_currentCharacter)
675                 return;
676 
677             m_numGlyphsSoFar++;
678             m_glyphInCurrentRun++;
679             m_characterInCurrentGlyph = 0;
680             if (ltr) {
681                 glyphIndexIntoCurrentRun++;
682                 glyphIndexIntoComplexTextController++;
683             } else {
684                 glyphIndexIntoCurrentRun--;
685                 glyphIndexIntoComplexTextController--;
686             }
687         }
688         currentRunIndex = incrementCurrentRun(indexOfLeftmostGlyphInCurrentRun);
689         m_glyphInCurrentRun = 0;
690     }
691 }
692 
693 static inline std::pair&lt;bool, bool&gt; expansionLocation(bool ideograph, bool treatAsSpace, bool ltr, bool isAfterExpansion, bool forbidLeadingExpansion, bool forbidTrailingExpansion, bool forceLeadingExpansion, bool forceTrailingExpansion)
694 {
695     bool expandLeft = ideograph;
696     bool expandRight = ideograph;
697     if (treatAsSpace) {
698         if (ltr)
699             expandRight = true;
700         else
701             expandLeft = true;
702     }
703     if (isAfterExpansion)
704         expandLeft = false;
705     ASSERT(!forbidLeadingExpansion || !forceLeadingExpansion);
706     ASSERT(!forbidTrailingExpansion || !forceTrailingExpansion);
707     if (forbidLeadingExpansion)
708         expandLeft = false;
709     if (forbidTrailingExpansion)
710         expandRight = false;
711     if (forceLeadingExpansion)
712         expandLeft = true;
713     if (forceTrailingExpansion)
714         expandRight = true;
715     return std::make_pair(expandLeft, expandRight);
716 }
717 
718 void ComplexTextController::adjustGlyphsAndAdvances()
719 {
720     bool afterExpansion = (m_run.expansionBehavior() &amp; LeadingExpansionMask) == ForbidLeadingExpansion;
721     size_t runCount = m_complexTextRuns.size();
722     bool hasExtraSpacing = (m_font.letterSpacing() || m_font.wordSpacing() || m_expansion) &amp;&amp; !m_run.spacingDisabled();
723     bool runForcesLeadingExpansion = (m_run.expansionBehavior() &amp; LeadingExpansionMask) == ForceLeadingExpansion;
724     bool runForcesTrailingExpansion = (m_run.expansionBehavior() &amp; TrailingExpansionMask) == ForceTrailingExpansion;
725     bool runForbidsLeadingExpansion = (m_run.expansionBehavior() &amp; LeadingExpansionMask) == ForbidLeadingExpansion;
726     bool runForbidsTrailingExpansion = (m_run.expansionBehavior() &amp; TrailingExpansionMask) == ForbidTrailingExpansion;
727 
728     // We are iterating in glyph order, not string order. Compare this to WidthIterator::advanceInternal()
729     for (size_t runIndex = 0; runIndex &lt; runCount; ++runIndex) {
730         ComplexTextRun&amp; complexTextRun = *m_complexTextRuns[runIndex];
731         unsigned glyphCount = complexTextRun.glyphCount();
732         const Font&amp; font = complexTextRun.font();
733 
734         if (!complexTextRun.isLTR())
735             m_isLTROnly = false;
736 
737         const CGGlyph* glyphs = complexTextRun.glyphs();
738         const FloatSize* advances = complexTextRun.baseAdvances();
739 
740         float spaceWidth = font.spaceWidth() - font.syntheticBoldOffset();
741         const UChar* cp = complexTextRun.characters();
742         FloatPoint glyphOrigin;
743         unsigned lastCharacterIndex = m_run.ltr() ? std::numeric_limits&lt;unsigned&gt;::min() : std::numeric_limits&lt;unsigned&gt;::max();
744         bool isMonotonic = true;
745 
746         for (unsigned i = 0; i &lt; glyphCount; i++) {
747             unsigned characterIndex = complexTextRun.indexAt(i);
748             if (m_run.ltr()) {
749                 if (characterIndex &lt; lastCharacterIndex)
750                     isMonotonic = false;
751             } else {
752                 if (characterIndex &gt; lastCharacterIndex)
753                     isMonotonic = false;
754             }
755             UChar ch = *(cp + characterIndex);
756 
757             bool treatAsSpace = FontCascade::treatAsSpace(ch);
758             CGGlyph glyph = treatAsSpace ? font.spaceGlyph() : glyphs[i];
759             FloatSize advance = treatAsSpace ? FloatSize(spaceWidth, advances[i].height()) : advances[i];
760 
761             if (ch == &#39;\t&#39; &amp;&amp; m_run.allowTabs())
762                 advance.setWidth(m_font.tabWidth(font, m_run.tabSize(), m_run.xPos() + m_totalWidth));
763             else if (FontCascade::treatAsZeroWidthSpace(ch) &amp;&amp; !treatAsSpace) {
764                 advance.setWidth(0);
765                 glyph = font.spaceGlyph();
766             }
767 
768             if (!i) {
769                 advance.expand(complexTextRun.initialAdvance().width(), complexTextRun.initialAdvance().height());
770                 if (auto* origins = complexTextRun.glyphOrigins())
771                     advance.expand(-origins[0].x(), -origins[0].y());
772             }
773 
774             advance.expand(font.syntheticBoldOffset(), 0);
775 
776             if (hasExtraSpacing) {
777                 // If we&#39;re a glyph with an advance, add in letter-spacing.
778                 // That way we weed out zero width lurkers. This behavior matches the fast text code path.
779                 if (advance.width())
780                     advance.expand(m_font.letterSpacing(), 0);
781 
782                 unsigned characterIndexInRun = characterIndex + complexTextRun.stringLocation();
783                 bool isFirstCharacter = !(characterIndex + complexTextRun.stringLocation());
784                 bool isLastCharacter = characterIndexInRun + 1 == m_run.length() || (U16_IS_LEAD(ch) &amp;&amp; characterIndexInRun + 2 == m_run.length() &amp;&amp; U16_IS_TRAIL(*(cp + characterIndex + 1)));
785 
786                 bool forceLeadingExpansion = false; // On the left, regardless of m_run.ltr()
787                 bool forceTrailingExpansion = false; // On the right, regardless of m_run.ltr()
788                 bool forbidLeadingExpansion = false;
789                 bool forbidTrailingExpansion = false;
790                 if (runForcesLeadingExpansion)
791                     forceLeadingExpansion = m_run.ltr() ? isFirstCharacter : isLastCharacter;
792                 if (runForcesTrailingExpansion)
793                     forceTrailingExpansion = m_run.ltr() ? isLastCharacter : isFirstCharacter;
794                 if (runForbidsLeadingExpansion)
795                     forbidLeadingExpansion = m_run.ltr() ? isFirstCharacter : isLastCharacter;
796                 if (runForbidsTrailingExpansion)
797                     forbidTrailingExpansion = m_run.ltr() ? isLastCharacter : isFirstCharacter;
798                 // Handle justification and word-spacing.
799                 bool ideograph = FontCascade::isCJKIdeographOrSymbol(ch);
800                 if (treatAsSpace || ideograph || forceLeadingExpansion || forceTrailingExpansion) {
801                     // Distribute the run&#39;s total expansion evenly over all expansion opportunities in the run.
802                     if (m_expansion) {
<a name="4" id="anc4"></a><span class="line-modified">803                         auto [expandLeft, expandRight] = expansionLocation(ideograph, treatAsSpace, m_run.ltr(), afterExpansion, forbidLeadingExpansion, forbidTrailingExpansion, forceLeadingExpansion, forceTrailingExpansion);</span>

804                         if (expandLeft) {
805                             m_expansion -= m_expansionPerOpportunity;
806                             // Increase previous width
807                             if (m_adjustedBaseAdvances.isEmpty()) {
808                                 advance.expand(m_expansionPerOpportunity, 0);
809                                 complexTextRun.growInitialAdvanceHorizontally(m_expansionPerOpportunity);
810                             } else {
811                                 m_adjustedBaseAdvances.last().expand(m_expansionPerOpportunity, 0);
812                                 m_totalWidth += m_expansionPerOpportunity;
813                             }
814                         }
815                         if (expandRight) {
816                             m_expansion -= m_expansionPerOpportunity;
817                             advance.expand(m_expansionPerOpportunity, 0);
818                             afterExpansion = true;
819                         }
820                     } else
821                         afterExpansion = false;
822 
823                     // Account for word-spacing.
824                     if (treatAsSpace &amp;&amp; (ch != &#39;\t&#39; || !m_run.allowTabs()) &amp;&amp; (characterIndex &gt; 0 || runIndex &gt; 0 || ch == noBreakSpace) &amp;&amp; m_font.wordSpacing())
825                         advance.expand(m_font.wordSpacing(), 0);
826                 } else
827                     afterExpansion = false;
828             }
829 
830             m_totalWidth += advance.width();
831 
832             // FIXME: Combining marks should receive a text emphasis mark if they are combine with a space.
833             if (m_forTextEmphasis &amp;&amp; (!FontCascade::canReceiveTextEmphasis(ch) || (U_GET_GC_MASK(ch) &amp; U_GC_M_MASK)))
834                 glyph = 0;
835 
836             m_adjustedBaseAdvances.append(advance);
837             if (auto* origins = complexTextRun.glyphOrigins()) {
838                 ASSERT(m_glyphOrigins.size() &lt; m_adjustedBaseAdvances.size());
839                 m_glyphOrigins.grow(m_adjustedBaseAdvances.size());
840                 m_glyphOrigins[m_glyphOrigins.size() - 1] = origins[i];
841                 ASSERT(m_glyphOrigins.size() == m_adjustedBaseAdvances.size());
842             }
843             m_adjustedGlyphs.append(glyph);
844 
845             FloatRect glyphBounds = font.boundsForGlyph(glyph);
846             glyphBounds.move(glyphOrigin.x(), glyphOrigin.y());
847             m_minGlyphBoundingBoxX = std::min(m_minGlyphBoundingBoxX, glyphBounds.x());
848             m_maxGlyphBoundingBoxX = std::max(m_maxGlyphBoundingBoxX, glyphBounds.maxX());
849             m_minGlyphBoundingBoxY = std::min(m_minGlyphBoundingBoxY, glyphBounds.y());
850             m_maxGlyphBoundingBoxY = std::max(m_maxGlyphBoundingBoxY, glyphBounds.maxY());
851             glyphOrigin.move(advance);
852 
853             lastCharacterIndex = characterIndex;
854         }
855         if (!isMonotonic)
856             complexTextRun.setIsNonMonotonic();
857     }
858 }
859 
860 // Missing glyphs run constructor. Core Text will not generate a run of missing glyphs, instead falling back on
861 // glyphs from LastResort. We want to use the primary font&#39;s missing glyph in order to match the fast text code path.
862 ComplexTextController::ComplexTextRun::ComplexTextRun(const Font&amp; font, const UChar* characters, unsigned stringLocation, unsigned stringLength, unsigned indexBegin, unsigned indexEnd, bool ltr)
863     : m_font(font)
864     , m_characters(characters)
865     , m_stringLength(stringLength)
866     , m_indexBegin(indexBegin)
867     , m_indexEnd(indexEnd)
868     , m_stringLocation(stringLocation)
869     , m_isLTR(ltr)
870 {
871     auto runLengthInCodeUnits = m_indexEnd - m_indexBegin;
872     m_coreTextIndices.reserveInitialCapacity(runLengthInCodeUnits);
873     unsigned r = m_indexBegin;
874     while (r &lt; m_indexEnd) {
875         m_coreTextIndices.uncheckedAppend(r);
876         UChar32 character;
877         U16_NEXT(m_characters, r, m_stringLength, character);
878     }
879     m_glyphCount = m_coreTextIndices.size();
880     if (!ltr) {
881         for (unsigned r = 0, end = m_glyphCount - 1; r &lt; m_glyphCount / 2; ++r, --end)
882             std::swap(m_coreTextIndices[r], m_coreTextIndices[end]);
883     }
884 
885     // Synthesize a run of missing glyphs.
886     m_glyphs.fill(0, m_glyphCount);
887     m_baseAdvances.fill(FloatSize(m_font.widthForGlyph(0), 0), m_glyphCount);
888 }
889 
890 ComplexTextController::ComplexTextRun::ComplexTextRun(const Vector&lt;FloatSize&gt;&amp; advances, const Vector&lt;FloatPoint&gt;&amp; origins, const Vector&lt;Glyph&gt;&amp; glyphs, const Vector&lt;unsigned&gt;&amp; stringIndices, FloatSize initialAdvance, const Font&amp; font, const UChar* characters, unsigned stringLocation, unsigned stringLength, unsigned indexBegin, unsigned indexEnd, bool ltr)
891     : m_baseAdvances(advances)
892     , m_glyphOrigins(origins)
893     , m_glyphs(glyphs)
894     , m_coreTextIndices(stringIndices)
895     , m_initialAdvance(initialAdvance)
896     , m_font(font)
897     , m_characters(characters)
898     , m_stringLength(stringLength)
899     , m_indexBegin(indexBegin)
900     , m_indexEnd(indexEnd)
901     , m_glyphCount(glyphs.size())
902     , m_stringLocation(stringLocation)
903     , m_isLTR(ltr)
904 {
905 }
906 
907 #endif
908 
909 } // namespace WebCore
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>