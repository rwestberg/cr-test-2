<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2011 Google Inc. All rights reserved.
   4  * Copyright (C) 2009 Joseph Pecoraro
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  *
  10  * 1.  Redistributions of source code must retain the above copyright
  11  *     notice, this list of conditions and the following disclaimer.
  12  * 2.  Redistributions in binary form must reproduce the above copyright
  13  *     notice, this list of conditions and the following disclaimer in the
  14  *     documentation and/or other materials provided with the distribution.
  15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16  *     its contributors may be used to endorse or promote products derived
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #include &quot;config.h&quot;
  32 #include &quot;InspectorDOMAgent.h&quot;
  33 
  34 #include &quot;AXObjectCache.h&quot;
  35 #include &quot;AccessibilityNodeObject.h&quot;
  36 #include &quot;Attr.h&quot;
  37 #include &quot;CSSComputedStyleDeclaration.h&quot;
  38 #include &quot;CSSPropertyNames.h&quot;
  39 #include &quot;CSSPropertySourceData.h&quot;
  40 #include &quot;CSSRule.h&quot;
  41 #include &quot;CSSRuleList.h&quot;
  42 #include &quot;CSSStyleRule.h&quot;
  43 #include &quot;CSSStyleSheet.h&quot;
  44 #include &quot;CharacterData.h&quot;
  45 #include &quot;CommandLineAPIHost.h&quot;
  46 #include &quot;ContainerNode.h&quot;
  47 #include &quot;Cookie.h&quot;
  48 #include &quot;CookieJar.h&quot;
  49 #include &quot;DOMEditor.h&quot;
  50 #include &quot;DOMException.h&quot;
  51 #include &quot;DOMPatchSupport.h&quot;
  52 #include &quot;DOMWindow.h&quot;
  53 #include &quot;Document.h&quot;
  54 #include &quot;DocumentType.h&quot;
  55 #include &quot;Editing.h&quot;
  56 #include &quot;Element.h&quot;
  57 #include &quot;Event.h&quot;
  58 #include &quot;EventListener.h&quot;
  59 #include &quot;EventNames.h&quot;
  60 #include &quot;Frame.h&quot;
  61 #include &quot;FrameTree.h&quot;
  62 #include &quot;HTMLElement.h&quot;
  63 #include &quot;HTMLFrameOwnerElement.h&quot;
  64 #include &quot;HTMLMediaElement.h&quot;
  65 #include &quot;HTMLNames.h&quot;
  66 #include &quot;HTMLParserIdioms.h&quot;
  67 #include &quot;HTMLScriptElement.h&quot;
  68 #include &quot;HTMLStyleElement.h&quot;
  69 #include &quot;HTMLTemplateElement.h&quot;
  70 #include &quot;HTMLVideoElement.h&quot;
  71 #include &quot;HitTestResult.h&quot;
  72 #include &quot;InspectorClient.h&quot;
  73 #include &quot;InspectorController.h&quot;
  74 #include &quot;InspectorHistory.h&quot;
  75 #include &quot;InspectorNodeFinder.h&quot;
  76 #include &quot;InspectorOverlay.h&quot;
  77 #include &quot;InspectorPageAgent.h&quot;
  78 #include &quot;InstrumentingAgents.h&quot;
  79 #include &quot;IntRect.h&quot;
  80 #include &quot;JSDOMBindingSecurity.h&quot;
  81 #include &quot;JSEventListener.h&quot;
  82 #include &quot;JSNode.h&quot;
  83 #include &quot;MutationEvent.h&quot;
  84 #include &quot;Node.h&quot;
  85 #include &quot;NodeList.h&quot;
  86 #include &quot;Page.h&quot;
  87 #include &quot;Pasteboard.h&quot;
  88 #include &quot;PseudoElement.h&quot;
  89 #include &quot;RenderStyle.h&quot;
  90 #include &quot;RenderStyleConstants.h&quot;
  91 #include &quot;ScriptState.h&quot;
  92 #include &quot;ShadowRoot.h&quot;
  93 #include &quot;StaticNodeList.h&quot;
  94 #include &quot;StyleProperties.h&quot;
  95 #include &quot;StyleResolver.h&quot;
  96 #include &quot;StyleSheetList.h&quot;
  97 #include &quot;Text.h&quot;
  98 #include &quot;TextNodeTraversal.h&quot;
  99 #include &quot;Timer.h&quot;
 100 #include &quot;VideoPlaybackQuality.h&quot;
 101 #include &quot;WebInjectedScriptManager.h&quot;
 102 #include &quot;XPathResult.h&quot;
 103 #include &quot;markup.h&quot;
 104 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 105 #include &lt;JavaScriptCore/InjectedScript.h&gt;
 106 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
 107 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 108 #include &lt;pal/crypto/CryptoDigest.h&gt;
 109 #include &lt;wtf/text/Base64.h&gt;
 110 #include &lt;wtf/text/CString.h&gt;
 111 #include &lt;wtf/text/WTFString.h&gt;
 112 
 113 namespace WebCore {
 114 
 115 using namespace Inspector;
 116 
 117 using namespace HTMLNames;
 118 
 119 static const size_t maxTextSize = 10000;
 120 static const UChar ellipsisUChar[] = { 0x2026, 0 };
 121 
 122 static Color parseColor(const JSON::Object* colorObject)
 123 {
 124     if (!colorObject)
 125         return Color::transparent;
 126 
 127     int r = 0;
 128     int g = 0;
 129     int b = 0;
 130     if (!colorObject-&gt;getInteger(&quot;r&quot;, r) || !colorObject-&gt;getInteger(&quot;g&quot;, g) || !colorObject-&gt;getInteger(&quot;b&quot;, b))
 131         return Color::transparent;
 132 
 133     double a = 1.0;
 134     if (!colorObject-&gt;getDouble(&quot;a&quot;, a))
 135         return Color(r, g, b);
 136 
 137     // Clamp alpha to the [0..1] range.
 138     if (a &lt; 0)
 139         a = 0;
 140     else if (a &gt; 1)
 141         a = 1;
 142 
 143     return Color(r, g, b, static_cast&lt;int&gt;(a * 255));
 144 }
 145 
 146 static Color parseConfigColor(const String&amp; fieldName, const JSON::Object* configObject)
 147 {
 148     RefPtr&lt;JSON::Object&gt; colorObject;
 149     configObject-&gt;getObject(fieldName, colorObject);
 150 
 151     return parseColor(colorObject.get());
 152 }
 153 
 154 static bool parseQuad(const JSON::Array&amp; quadArray, FloatQuad* quad)
 155 {
 156     const size_t coordinatesInQuad = 8;
 157     double coordinates[coordinatesInQuad];
 158     if (quadArray.length() != coordinatesInQuad)
 159         return false;
 160     for (size_t i = 0; i &lt; coordinatesInQuad; ++i) {
 161         if (!quadArray.get(i)-&gt;asDouble(*(coordinates + i)))
 162             return false;
 163     }
 164     quad-&gt;setP1(FloatPoint(coordinates[0], coordinates[1]));
 165     quad-&gt;setP2(FloatPoint(coordinates[2], coordinates[3]));
 166     quad-&gt;setP3(FloatPoint(coordinates[4], coordinates[5]));
 167     quad-&gt;setP4(FloatPoint(coordinates[6], coordinates[7]));
 168 
 169     return true;
 170 }
 171 
 172 class RevalidateStyleAttributeTask {
 173     WTF_MAKE_FAST_ALLOCATED;
 174 public:
 175     RevalidateStyleAttributeTask(InspectorDOMAgent*);
 176     void scheduleFor(Element*);
 177     void reset() { m_timer.stop(); }
 178     void timerFired();
 179 
 180 private:
 181     InspectorDOMAgent* m_domAgent;
 182     Timer m_timer;
 183     HashSet&lt;RefPtr&lt;Element&gt;&gt; m_elements;
 184 };
 185 
 186 RevalidateStyleAttributeTask::RevalidateStyleAttributeTask(InspectorDOMAgent* domAgent)
 187     : m_domAgent(domAgent)
 188     , m_timer(*this, &amp;RevalidateStyleAttributeTask::timerFired)
 189 {
 190 }
 191 
 192 void RevalidateStyleAttributeTask::scheduleFor(Element* element)
 193 {
 194     m_elements.add(element);
 195     if (!m_timer.isActive())
 196         m_timer.startOneShot(0_s);
 197 }
 198 
 199 void RevalidateStyleAttributeTask::timerFired()
 200 {
 201     // The timer is stopped on m_domAgent destruction, so this method will never be called after m_domAgent has been destroyed.
 202     Vector&lt;Element*&gt; elements;
 203     for (auto&amp; element : m_elements)
 204         elements.append(element.get());
 205     m_domAgent-&gt;styleAttributeInvalidated(elements);
 206 
 207     m_elements.clear();
 208 }
 209 
 210 class InspectableNode final : public CommandLineAPIHost::InspectableObject {
 211 public:
 212     explicit InspectableNode(Node* node)
 213         : m_node(node)
 214     {
 215     }
 216 
 217     JSC::JSValue get(JSC::ExecState&amp; state) final
 218     {
 219         return InspectorDOMAgent::nodeAsScriptValue(state, m_node.get());
 220     }
 221 private:
 222     RefPtr&lt;Node&gt; m_node;
 223 };
 224 
 225 class EventFiredCallback final : public EventListener {
 226 public:
 227     static Ref&lt;EventFiredCallback&gt; create(InspectorDOMAgent&amp; domAgent)
 228     {
 229         return adoptRef(*new EventFiredCallback(domAgent));
 230     }
 231 
 232     bool operator==(const EventListener&amp; other) const final
 233     {
 234         return this == &amp;other;
 235     }
 236 
 237     void handleEvent(ScriptExecutionContext&amp;, Event&amp; event) final
 238     {
 239         if (!is&lt;Node&gt;(event.target()) || m_domAgent.m_dispatchedEvents.contains(&amp;event))
 240             return;
 241 
 242         auto* node = downcast&lt;Node&gt;(event.target());
 243         int nodeId = m_domAgent.pushNodePathToFrontend(node);
 244         if (!nodeId)
 245             return;
 246 
 247         m_domAgent.m_dispatchedEvents.add(&amp;event);
 248 
 249         RefPtr&lt;JSON::Object&gt; data = JSON::Object::create();
 250 
 251 #if ENABLE(FULLSCREEN_API)
 252         if (event.type() == eventNames().webkitfullscreenchangeEvent)
 253             data-&gt;setBoolean(&quot;enabled&quot;_s, !!node-&gt;document().webkitFullscreenElement());
 254 #endif // ENABLE(FULLSCREEN_API)
 255 
 256         auto timestamp = m_domAgent.m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
 257         m_domAgent.m_frontendDispatcher-&gt;didFireEvent(nodeId, event.type(), timestamp, data-&gt;size() ? WTFMove(data) : nullptr);
 258     }
 259 
 260 private:
 261     EventFiredCallback(InspectorDOMAgent&amp; domAgent)
 262         : EventListener(EventListener::CPPEventListenerType)
 263         , m_domAgent(domAgent)
 264     {
 265     }
 266 
 267     InspectorDOMAgent&amp; m_domAgent;
 268 };
 269 
 270 String InspectorDOMAgent::toErrorString(ExceptionCode ec)
 271 {
 272     return ec ? String(DOMException::name(ec)) : emptyString();
 273 }
 274 
 275 String InspectorDOMAgent::toErrorString(Exception&amp;&amp; exception)
 276 {
 277     return DOMException::name(exception.code());
 278 }
 279 
 280 InspectorDOMAgent::InspectorDOMAgent(WebAgentContext&amp; context, InspectorPageAgent* pageAgent, InspectorOverlay* overlay)
 281     : InspectorAgentBase(&quot;DOM&quot;_s, context)
 282     , m_injectedScriptManager(context.injectedScriptManager)
 283     , m_frontendDispatcher(std::make_unique&lt;Inspector::DOMFrontendDispatcher&gt;(context.frontendRouter))
 284     , m_backendDispatcher(Inspector::DOMBackendDispatcher::create(context.backendDispatcher, this))
 285     , m_pageAgent(pageAgent)
 286     , m_overlay(overlay)
 287 #if ENABLE(VIDEO)
 288     , m_mediaMetricsTimer(*this, &amp;InspectorDOMAgent::mediaMetricsTimerFired)
 289 #endif
 290 {
 291 }
 292 
 293 InspectorDOMAgent::~InspectorDOMAgent()
 294 {
 295     reset();
 296     ASSERT(!m_searchingForNode);
 297 }
 298 
 299 void InspectorDOMAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 300 {
 301     m_history = std::make_unique&lt;InspectorHistory&gt;();
 302     m_domEditor = std::make_unique&lt;DOMEditor&gt;(*m_history);
 303 
 304     m_instrumentingAgents.setInspectorDOMAgent(this);
 305     m_document = m_pageAgent-&gt;mainFrame().document();
 306 
 307 #if ENABLE(VIDEO)
 308     if (m_document)
 309         addEventListenersToNode(*m_document);
 310 
 311     for (auto* mediaElement : HTMLMediaElement::allMediaElements())
 312         addEventListenersToNode(*mediaElement);
 313 #endif
 314 
 315     if (m_nodeToFocus)
 316         focusNode();
 317 }
 318 
 319 void InspectorDOMAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
 320 {
 321     m_history.reset();
 322     m_domEditor.reset();
 323     m_mousedOverNode = nullptr;
 324 
 325     ErrorString unused;
 326     setSearchingForNode(unused, false, nullptr);
 327     hideHighlight(unused);
 328 
 329     m_instrumentingAgents.setInspectorDOMAgent(nullptr);
 330     m_documentRequested = false;
 331     reset();
 332 }
 333 
 334 Vector&lt;Document*&gt; InspectorDOMAgent::documents()
 335 {
 336     Vector&lt;Document*&gt; result;
 337     for (Frame* frame = m_document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
 338         Document* document = frame-&gt;document();
 339         if (!document)
 340             continue;
 341         result.append(document);
 342     }
 343     return result;
 344 }
 345 
 346 void InspectorDOMAgent::reset()
 347 {
 348     if (m_history)
 349         m_history-&gt;reset();
 350     m_searchResults.clear();
 351     discardBindings();
 352     if (m_revalidateStyleAttrTask)
 353         m_revalidateStyleAttrTask-&gt;reset();
 354     m_document = nullptr;
 355 }
 356 
 357 void InspectorDOMAgent::setDOMListener(DOMListener* listener)
 358 {
 359     m_domListener = listener;
 360 }
 361 
 362 void InspectorDOMAgent::setDocument(Document* document)
 363 {
 364     if (document == m_document.get())
 365         return;
 366 
 367     reset();
 368 
 369     m_document = document;
 370 
 371     if (!m_documentRequested)
 372         return;
 373 
 374     // Immediately communicate null document or document that has finished loading.
 375     if (!document || !document-&gt;parsing())
 376         m_frontendDispatcher-&gt;documentUpdated();
 377 }
 378 
 379 void InspectorDOMAgent::releaseDanglingNodes()
 380 {
 381     m_danglingNodeToIdMaps.clear();
 382 }
 383 
 384 int InspectorDOMAgent::bind(Node* node, NodeToIdMap* nodesMap)
 385 {
 386     int id = nodesMap-&gt;get(node);
 387     if (id)
 388         return id;
 389     id = m_lastNodeId++;
 390     nodesMap-&gt;set(node, id);
 391     m_idToNode.set(id, node);
 392     m_idToNodesMap.set(id, nodesMap);
 393     return id;
 394 }
 395 
 396 void InspectorDOMAgent::unbind(Node* node, NodeToIdMap* nodesMap)
 397 {
 398     int id = nodesMap-&gt;get(node);
 399     if (!id)
 400         return;
 401 
 402     m_idToNode.remove(id);
 403 
 404     if (node-&gt;isFrameOwnerElement()) {
 405         const HTMLFrameOwnerElement* frameOwner = static_cast&lt;const HTMLFrameOwnerElement*&gt;(node);
 406         if (Document* contentDocument = frameOwner-&gt;contentDocument())
 407             unbind(contentDocument, nodesMap);
 408     }
 409 
 410     if (is&lt;Element&gt;(*node)) {
 411         Element&amp; element = downcast&lt;Element&gt;(*node);
 412         if (ShadowRoot* root = element.shadowRoot())
 413             unbind(root, nodesMap);
 414         if (PseudoElement* beforeElement = element.beforePseudoElement())
 415             unbind(beforeElement, nodesMap);
 416         if (PseudoElement* afterElement = element.afterPseudoElement())
 417             unbind(afterElement, nodesMap);
 418     }
 419 
 420     nodesMap-&gt;remove(node);
 421     if (m_domListener)
 422         m_domListener-&gt;didRemoveDOMNode(*node, id);
 423 
 424     if (m_childrenRequested.remove(id)) {
 425         // FIXME: Would be better to do this iteratively rather than recursively.
 426         for (Node* child = innerFirstChild(node); child; child = innerNextSibling(child))
 427             unbind(child, nodesMap);
 428     }
 429 }
 430 
 431 Node* InspectorDOMAgent::assertNode(ErrorString&amp; errorString, int nodeId)
 432 {
 433     Node* node = nodeForId(nodeId);
 434     if (!node) {
 435         errorString = &quot;Could not find node with given id&quot;_s;
 436         return nullptr;
 437     }
 438     return node;
 439 }
 440 
 441 Document* InspectorDOMAgent::assertDocument(ErrorString&amp; errorString, int nodeId)
 442 {
 443     Node* node = assertNode(errorString, nodeId);
 444     if (!node)
 445         return nullptr;
 446     if (!is&lt;Document&gt;(*node)) {
 447         errorString = &quot;Document is not available&quot;_s;
 448         return nullptr;
 449     }
 450     return downcast&lt;Document&gt;(node);
 451 }
 452 
 453 Element* InspectorDOMAgent::assertElement(ErrorString&amp; errorString, int nodeId)
 454 {
 455     Node* node = assertNode(errorString, nodeId);
 456     if (!node)
 457         return nullptr;
 458     if (!is&lt;Element&gt;(*node)) {
 459         errorString = &quot;Node is not an Element&quot;_s;
 460         return nullptr;
 461     }
 462     return downcast&lt;Element&gt;(node);
 463 }
 464 
 465 Node* InspectorDOMAgent::assertEditableNode(ErrorString&amp; errorString, int nodeId)
 466 {
 467     Node* node = assertNode(errorString, nodeId);
 468     if (!node)
 469         return nullptr;
 470     if (node-&gt;isInUserAgentShadowTree()) {
 471         errorString = &quot;Cannot edit nodes in user agent shadow trees&quot;_s;
 472         return nullptr;
 473     }
 474     if (node-&gt;isPseudoElement()) {
 475         errorString = &quot;Cannot edit pseudo elements&quot;_s;
 476         return nullptr;
 477     }
 478     return node;
 479 }
 480 
 481 Element* InspectorDOMAgent::assertEditableElement(ErrorString&amp; errorString, int nodeId)
 482 {
 483     Element* element = assertElement(errorString, nodeId);
 484     if (!element)
 485         return nullptr;
 486     if (element-&gt;isInUserAgentShadowTree()) {
 487         errorString = &quot;Cannot edit elements in user agent shadow trees&quot;_s;
 488         return nullptr;
 489     }
 490     if (element-&gt;isPseudoElement()) {
 491         errorString = &quot;Cannot edit pseudo elements&quot;_s;
 492         return nullptr;
 493     }
 494     return element;
 495 }
 496 
 497 void InspectorDOMAgent::getDocument(ErrorString&amp; errorString, RefPtr&lt;Inspector::Protocol::DOM::Node&gt;&amp; root)
 498 {
 499     m_documentRequested = true;
 500 
 501     if (!m_document) {
 502         errorString = &quot;Document is not available&quot;_s;
 503         return;
 504     }
 505 
 506     // Reset backend state.
 507     RefPtr&lt;Document&gt; document = m_document;
 508     reset();
 509     m_document = document;
 510 
 511     root = buildObjectForNode(m_document.get(), 2, &amp;m_documentNodeToIdMap);
 512 }
 513 
 514 void InspectorDOMAgent::pushChildNodesToFrontend(int nodeId, int depth)
 515 {
 516     Node* node = nodeForId(nodeId);
 517     if (!node || (node-&gt;nodeType() != Node::ELEMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_FRAGMENT_NODE))
 518         return;
 519 
 520     NodeToIdMap* nodeMap = m_idToNodesMap.get(nodeId);
 521 
 522     if (m_childrenRequested.contains(nodeId)) {
 523         if (depth &lt;= 1)
 524             return;
 525 
 526         depth--;
 527 
 528         for (node = innerFirstChild(node); node; node = innerNextSibling(node)) {
 529             int childNodeId = nodeMap-&gt;get(node);
 530             ASSERT(childNodeId);
 531             pushChildNodesToFrontend(childNodeId, depth);
 532         }
 533 
 534         return;
 535     }
 536 
 537     auto children = buildArrayForContainerChildren(node, depth, nodeMap);
 538     m_frontendDispatcher-&gt;setChildNodes(nodeId, WTFMove(children));
 539 }
 540 
 541 void InspectorDOMAgent::discardBindings()
 542 {
 543     m_documentNodeToIdMap.clear();
 544     m_idToNode.clear();
 545     m_dispatchedEvents.clear();
 546     m_eventListenerEntries.clear();
 547     releaseDanglingNodes();
 548     m_childrenRequested.clear();
 549 }
 550 
 551 int InspectorDOMAgent::pushNodeToFrontend(ErrorString&amp; errorString, int documentNodeId, Node* nodeToPush)
 552 {
 553     Document* document = assertDocument(errorString, documentNodeId);
 554     if (!document)
 555         return 0;
 556     if (&amp;nodeToPush-&gt;document() != document) {
 557         errorString = &quot;Node is not part of the document with given id&quot;_s;
 558         return 0;
 559     }
 560 
 561     return pushNodePathToFrontend(nodeToPush);
 562 }
 563 
 564 Node* InspectorDOMAgent::nodeForId(int id)
 565 {
 566     if (!m_idToNode.isValidKey(id))
 567         return nullptr;
 568 
 569     return m_idToNode.get(id);
 570 }
 571 
 572 void InspectorDOMAgent::requestChildNodes(ErrorString&amp; errorString, int nodeId, const int* depth)
 573 {
 574     int sanitizedDepth;
 575 
 576     if (!depth)
 577         sanitizedDepth = 1;
 578     else if (*depth == -1)
 579         sanitizedDepth = INT_MAX;
 580     else if (*depth &gt; 0)
 581         sanitizedDepth = *depth;
 582     else {
 583         errorString = &quot;Please provide a positive integer as a depth or -1 for entire subtree&quot;_s;
 584         return;
 585     }
 586 
 587     pushChildNodesToFrontend(nodeId, sanitizedDepth);
 588 }
 589 
 590 void InspectorDOMAgent::querySelector(ErrorString&amp; errorString, int nodeId, const String&amp; selectors, int* elementId)
 591 {
 592     *elementId = 0;
 593     Node* node = assertNode(errorString, nodeId);
 594     if (!node)
 595         return;
 596     if (!is&lt;ContainerNode&gt;(*node)) {
 597         assertElement(errorString, nodeId);
 598         return;
 599     }
 600 
 601     auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelector(selectors);
 602     if (queryResult.hasException()) {
 603         errorString = &quot;DOM Error while querying&quot;_s;
 604         return;
 605     }
 606 
 607     if (auto* element = queryResult.releaseReturnValue())
 608         *elementId = pushNodePathToFrontend(element);
 609 }
 610 
 611 void InspectorDOMAgent::querySelectorAll(ErrorString&amp; errorString, int nodeId, const String&amp; selectors, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result)
 612 {
 613     Node* node = assertNode(errorString, nodeId);
 614     if (!node)
 615         return;
 616     if (!is&lt;ContainerNode&gt;(*node)) {
 617         assertElement(errorString, nodeId);
 618         return;
 619     }
 620 
 621     auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelectorAll(selectors);
 622     if (queryResult.hasException()) {
 623         errorString = &quot;DOM Error while querying&quot;_s;
 624         return;
 625     }
 626 
 627     auto nodes = queryResult.releaseReturnValue();
 628     result = JSON::ArrayOf&lt;int&gt;::create();
 629     for (unsigned i = 0; i &lt; nodes-&gt;length(); ++i)
 630         result-&gt;addItem(pushNodePathToFrontend(nodes-&gt;item(i)));
 631 }
 632 
 633 int InspectorDOMAgent::pushNodePathToFrontend(Node* nodeToPush)
 634 {
 635     ASSERT(nodeToPush);  // Invalid input
 636 
 637     if (!m_document)
 638         return 0;
 639     if (!m_documentNodeToIdMap.contains(m_document))
 640         return 0;
 641 
 642     // Return id in case the node is known.
 643     int result = m_documentNodeToIdMap.get(nodeToPush);
 644     if (result)
 645         return result;
 646 
 647     Node* node = nodeToPush;
 648     Vector&lt;Node*&gt; path;
 649     NodeToIdMap* danglingMap = 0;
 650 
 651     while (true) {
 652         Node* parent = innerParentNode(node);
 653         if (!parent) {
 654             // Node being pushed is detached -&gt; push subtree root.
 655             auto newMap = std::make_unique&lt;NodeToIdMap&gt;();
 656             danglingMap = newMap.get();
 657             m_danglingNodeToIdMaps.append(newMap.release());
 658             auto children = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
 659             children-&gt;addItem(buildObjectForNode(node, 0, danglingMap));
 660             m_frontendDispatcher-&gt;setChildNodes(0, WTFMove(children));
 661             break;
 662         } else {
 663             path.append(parent);
 664             if (m_documentNodeToIdMap.get(parent))
 665                 break;
 666             else
 667                 node = parent;
 668         }
 669     }
 670 
 671     NodeToIdMap* map = danglingMap ? danglingMap : &amp;m_documentNodeToIdMap;
 672     for (int i = path.size() - 1; i &gt;= 0; --i) {
 673         int nodeId = map-&gt;get(path.at(i));
 674         ASSERT(nodeId);
 675         pushChildNodesToFrontend(nodeId);
 676     }
 677     return map-&gt;get(nodeToPush);
 678 }
 679 
 680 int InspectorDOMAgent::boundNodeId(const Node* node)
 681 {
 682     return m_documentNodeToIdMap.get(const_cast&lt;Node*&gt;(node));
 683 }
 684 
 685 void InspectorDOMAgent::setAttributeValue(ErrorString&amp; errorString, int elementId, const String&amp; name, const String&amp; value)
 686 {
 687     Element* element = assertEditableElement(errorString, elementId);
 688     if (!element)
 689         return;
 690 
 691     m_domEditor-&gt;setAttribute(*element, name, value, errorString);
 692 }
 693 
 694 void InspectorDOMAgent::setAttributesAsText(ErrorString&amp; errorString, int elementId, const String&amp; text, const String* name)
 695 {
 696     Element* element = assertEditableElement(errorString, elementId);
 697     if (!element)
 698         return;
 699 
 700     auto parsedElement = createHTMLElement(element-&gt;document(), spanTag);
 701     auto result = parsedElement.get().setInnerHTML(&quot;&lt;span &quot; + text + &quot;&gt;&lt;/span&gt;&quot;);
 702     if (result.hasException()) {
 703         errorString = toErrorString(result.releaseException());
 704         return;
 705     }
 706 
 707     Node* child = parsedElement-&gt;firstChild();
 708     if (!child) {
 709         errorString = &quot;Could not parse value as attributes&quot;_s;
 710         return;
 711     }
 712 
 713     Element* childElement = downcast&lt;Element&gt;(child);
 714     if (!childElement-&gt;hasAttributes() &amp;&amp; name) {
 715         m_domEditor-&gt;removeAttribute(*element, *name, errorString);
 716         return;
 717     }
 718 
 719     bool foundOriginalAttribute = false;
 720     for (const Attribute&amp; attribute : childElement-&gt;attributesIterator()) {
 721         // Add attribute pair
 722         foundOriginalAttribute = foundOriginalAttribute || (name &amp;&amp; attribute.name().toString() == *name);
 723         if (!m_domEditor-&gt;setAttribute(*element, attribute.name().toString(), attribute.value(), errorString))
 724             return;
 725     }
 726 
 727     if (!foundOriginalAttribute &amp;&amp; name &amp;&amp; !name-&gt;stripWhiteSpace().isEmpty())
 728         m_domEditor-&gt;removeAttribute(*element, *name, errorString);
 729 }
 730 
 731 void InspectorDOMAgent::removeAttribute(ErrorString&amp; errorString, int elementId, const String&amp; name)
 732 {
 733     Element* element = assertEditableElement(errorString, elementId);
 734     if (!element)
 735         return;
 736 
 737     m_domEditor-&gt;removeAttribute(*element, name, errorString);
 738 }
 739 
 740 void InspectorDOMAgent::removeNode(ErrorString&amp; errorString, int nodeId)
 741 {
 742     Node* node = assertEditableNode(errorString, nodeId);
 743     if (!node)
 744         return;
 745 
 746     ContainerNode* parentNode = node-&gt;parentNode();
 747     if (!parentNode) {
 748         errorString = &quot;Cannot remove detached node&quot;_s;
 749         return;
 750     }
 751 
 752     m_domEditor-&gt;removeChild(*parentNode, *node, errorString);
 753 }
 754 
 755 void InspectorDOMAgent::setNodeName(ErrorString&amp; errorString, int nodeId, const String&amp; tagName, int* newId)
 756 {
 757     *newId = 0;
 758 
 759     RefPtr&lt;Node&gt; oldNode = nodeForId(nodeId);
 760     if (!is&lt;Element&gt;(oldNode))
 761         return;
 762 
 763     auto createElementResult = oldNode-&gt;document().createElementForBindings(tagName);
 764     if (createElementResult.hasException())
 765         return;
 766     auto newElement = createElementResult.releaseReturnValue();
 767 
 768     // Copy over the original node&#39;s attributes.
 769     newElement-&gt;cloneAttributesFromElement(downcast&lt;Element&gt;(*oldNode));
 770 
 771     // Copy over the original node&#39;s children.
 772     RefPtr&lt;Node&gt; child;
 773     while ((child = oldNode-&gt;firstChild())) {
 774         if (!m_domEditor-&gt;insertBefore(newElement, *child, 0, errorString))
 775             return;
 776     }
 777 
 778     // Replace the old node with the new node
 779     RefPtr&lt;ContainerNode&gt; parent = oldNode-&gt;parentNode();
 780     if (!m_domEditor-&gt;insertBefore(*parent, newElement.copyRef(), oldNode-&gt;nextSibling(), errorString))
 781         return;
 782     if (!m_domEditor-&gt;removeChild(*parent, *oldNode, errorString))
 783         return;
 784 
 785     *newId = pushNodePathToFrontend(newElement.ptr());
 786     if (m_childrenRequested.contains(nodeId))
 787         pushChildNodesToFrontend(*newId);
 788 }
 789 
 790 void InspectorDOMAgent::getOuterHTML(ErrorString&amp; errorString, int nodeId, WTF::String* outerHTML)
 791 {
 792     Node* node = assertNode(errorString, nodeId);
 793     if (!node)
 794         return;
 795 
 796     *outerHTML = serializeFragment(*node, SerializedNodes::SubtreeIncludingNode);
 797 }
 798 
 799 void InspectorDOMAgent::setOuterHTML(ErrorString&amp; errorString, int nodeId, const String&amp; outerHTML)
 800 {
 801     if (!nodeId) {
 802         DOMPatchSupport { *m_domEditor, *m_document }.patchDocument(outerHTML);
 803         return;
 804     }
 805 
 806     Node* node = assertEditableNode(errorString, nodeId);
 807     if (!node)
 808         return;
 809 
 810     Document&amp; document = node-&gt;document();
 811     if (!document.isHTMLDocument() &amp;&amp; !document.isXMLDocument()) {
 812         errorString = &quot;Not an HTML/XML document&quot;_s;
 813         return;
 814     }
 815 
 816     Node* newNode = nullptr;
 817     if (!m_domEditor-&gt;setOuterHTML(*node, outerHTML, newNode, errorString))
 818         return;
 819 
 820     if (!newNode) {
 821         // The only child node has been deleted.
 822         return;
 823     }
 824 
 825     int newId = pushNodePathToFrontend(newNode);
 826 
 827     bool childrenRequested = m_childrenRequested.contains(nodeId);
 828     if (childrenRequested)
 829         pushChildNodesToFrontend(newId);
 830 }
 831 
 832 void InspectorDOMAgent::insertAdjacentHTML(ErrorString&amp; errorString, int nodeId, const String&amp; position, const String&amp; html)
 833 {
 834     Node* node = assertEditableNode(errorString, nodeId);
 835     if (!node)
 836         return;
 837 
 838     if (!is&lt;Element&gt;(node)) {
 839         errorString = &quot;Can only call insertAdjacentHTML on Elements.&quot;_s;
 840         return;
 841     }
 842 
 843     m_domEditor-&gt;insertAdjacentHTML(downcast&lt;Element&gt;(*node), position, html, errorString);
 844 }
 845 
 846 void InspectorDOMAgent::setNodeValue(ErrorString&amp; errorString, int nodeId, const String&amp; value)
 847 {
 848     Node* node = assertEditableNode(errorString, nodeId);
 849     if (!node)
 850         return;
 851 
 852     if (!is&lt;Text&gt;(*node)) {
 853         errorString = &quot;Can only set value of text nodes&quot;_s;
 854         return;
 855     }
 856 
 857     m_domEditor-&gt;replaceWholeText(downcast&lt;Text&gt;(*node), value, errorString);
 858 }
 859 
 860 void InspectorDOMAgent::getSupportedEventNames(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; eventNames)
 861 {
 862     eventNames = JSON::ArrayOf&lt;String&gt;::create();
 863 
 864 #define DOM_EVENT_NAMES_ADD(name) eventNames-&gt;addItem(#name);
 865     DOM_EVENT_NAMES_FOR_EACH(DOM_EVENT_NAMES_ADD)
 866 #undef DOM_EVENT_NAMES_ADD
 867 }
 868 
 869 void InspectorDOMAgent::getEventListenersForNode(ErrorString&amp; errorString, int nodeId, const String* objectGroup, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;&gt;&amp; listenersArray)
 870 {
 871     listenersArray = JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;::create();
 872     Node* node = assertNode(errorString, nodeId);
 873     if (!node)
 874         return;
 875     Vector&lt;EventListenerInfo&gt; eventInformation;
 876     getEventListeners(node, eventInformation, true);
 877 
 878     auto addListener = [&amp;] (RegisteredEventListener&amp; listener, const EventListenerInfo&amp; info) {
 879         int identifier = 0;
 880         bool disabled = false;
 881         bool hasBreakpoint = false;
 882 
 883         for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
 884             if (inspectorEventListener.matches(*info.node, info.eventType, listener.callback(), listener.useCapture())) {
 885                 identifier = inspectorEventListener.identifier;
 886                 disabled = inspectorEventListener.disabled;
 887                 hasBreakpoint = inspectorEventListener.hasBreakpoint;
 888                 break;
 889             }
 890         }
 891 
 892         if (!identifier) {
 893             InspectorEventListener inspectorEventListener(m_lastEventListenerId++, *info.node, info.eventType, listener.callback(), listener.useCapture());
 894 
 895             identifier = inspectorEventListener.identifier;
 896             disabled = inspectorEventListener.disabled;
 897             hasBreakpoint = inspectorEventListener.hasBreakpoint;
 898 
 899             m_eventListenerEntries.add(identifier, inspectorEventListener);
 900         }
 901 
 902         listenersArray-&gt;addItem(buildObjectForEventListener(listener, identifier, info.eventType, info.node, objectGroup, disabled, hasBreakpoint));
 903     };
 904 
 905     // Get Capturing Listeners (in this order)
 906     size_t eventInformationLength = eventInformation.size();
 907     for (auto&amp; info : eventInformation) {
 908         for (auto&amp; listener : info.eventListenerVector) {
 909             if (listener-&gt;useCapture())
 910                 addListener(*listener, info);
 911         }
 912     }
 913 
 914     // Get Bubbling Listeners (reverse order)
 915     for (size_t i = eventInformationLength; i; --i) {
 916         const EventListenerInfo&amp; info = eventInformation[i - 1];
 917         for (auto&amp; listener : info.eventListenerVector) {
 918             if (!listener-&gt;useCapture())
 919                 addListener(*listener, info);
 920         }
 921     }
 922 }
 923 
 924 void InspectorDOMAgent::getEventListeners(Node* node, Vector&lt;EventListenerInfo&gt;&amp; eventInformation, bool includeAncestors)
 925 {
 926     // The Node&#39;s Ancestors including self.
 927     Vector&lt;Node*&gt; ancestors;
 928     // Push this node as the firs element.
 929     ancestors.append(node);
 930     if (includeAncestors) {
 931         for (ContainerNode* ancestor = node-&gt;parentOrShadowHostNode(); ancestor; ancestor = ancestor-&gt;parentOrShadowHostNode())
 932             ancestors.append(ancestor);
 933     }
 934 
 935     // Nodes and their Listeners for the concerned event types (order is top to bottom)
 936     for (size_t i = ancestors.size(); i; --i) {
 937         Node* ancestor = ancestors[i - 1];
 938         EventTargetData* d = ancestor-&gt;eventTargetData();
 939         if (!d)
 940             continue;
 941         // Get the list of event types this Node is concerned with
 942         for (auto&amp; type : d-&gt;eventListenerMap.eventTypes()) {
 943             auto&amp; listeners = ancestor-&gt;eventListeners(type);
 944             EventListenerVector filteredListeners;
 945             filteredListeners.reserveInitialCapacity(listeners.size());
 946             for (auto&amp; listener : listeners) {
 947                 if (listener-&gt;callback().type() == EventListener::JSEventListenerType)
 948                     filteredListeners.uncheckedAppend(listener);
 949             }
 950             if (!filteredListeners.isEmpty())
 951                 eventInformation.append(EventListenerInfo(ancestor, type, WTFMove(filteredListeners)));
 952         }
 953     }
 954 }
 955 
 956 void InspectorDOMAgent::setEventListenerDisabled(ErrorString&amp; errorString, int eventListenerId, bool disabled)
 957 {
 958     auto it = m_eventListenerEntries.find(eventListenerId);
 959     if (it == m_eventListenerEntries.end()) {
 960         errorString = &quot;No event listener for given identifier.&quot;_s;
 961         return;
 962     }
 963 
 964     it-&gt;value.disabled = disabled;
 965 }
 966 
 967 void InspectorDOMAgent::setBreakpointForEventListener(ErrorString&amp; errorString, int eventListenerId)
 968 {
 969     auto it = m_eventListenerEntries.find(eventListenerId);
 970     if (it == m_eventListenerEntries.end()) {
 971         errorString = &quot;No event listener for given identifier.&quot;_s;
 972         return;
 973     }
 974 
 975     it-&gt;value.hasBreakpoint = true;
 976 }
 977 
 978 void InspectorDOMAgent::removeBreakpointForEventListener(ErrorString&amp; errorString, int eventListenerId)
 979 {
 980     auto it = m_eventListenerEntries.find(eventListenerId);
 981     if (it == m_eventListenerEntries.end()) {
 982         errorString = &quot;No event listener for given identifier.&quot;_s;
 983         return;
 984     }
 985 
 986     it-&gt;value.hasBreakpoint = false;
 987 }
 988 
 989 void InspectorDOMAgent::getAccessibilityPropertiesForNode(ErrorString&amp; errorString, int nodeId, RefPtr&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt;&amp; axProperties)
 990 {
 991     Node* node = assertNode(errorString, nodeId);
 992     if (!node)
 993         return;
 994 
 995     axProperties = buildObjectForAccessibilityProperties(node);
 996 }
 997 
 998 void InspectorDOMAgent::performSearch(ErrorString&amp; errorString, const String&amp; whitespaceTrimmedQuery, const JSON::Array* nodeIds, String* searchId, int* resultCount)
 999 {
1000     // FIXME: Search works with node granularity - number of matches within node is not calculated.
1001     InspectorNodeFinder finder(whitespaceTrimmedQuery);
1002 
1003     if (nodeIds) {
1004         for (auto&amp; nodeValue : *nodeIds) {
1005             if (!nodeValue) {
1006                 errorString = &quot;Invalid nodeIds item.&quot;_s;
1007                 return;
1008             }
1009             int nodeId = 0;
1010             if (!nodeValue-&gt;asInteger(nodeId)) {
1011                 errorString = &quot;Invalid nodeIds item type. Expecting integer types.&quot;_s;
1012                 return;
1013             }
1014             Node* node = assertNode(errorString, nodeId);
1015             if (!node) {
1016                 // assertNode should have filled the errorString for us.
1017                 ASSERT(errorString.length());
1018                 return;
1019             }
1020             finder.performSearch(node);
1021         }
1022     } else {
1023         // There&#39;s no need to iterate the frames tree because
1024         // the search helper will go inside the frame owner elements.
1025         finder.performSearch(m_document.get());
1026     }
1027 
1028     *searchId = IdentifiersFactory::createIdentifier();
1029 
1030     auto&amp; resultsVector = m_searchResults.add(*searchId, Vector&lt;RefPtr&lt;Node&gt;&gt;()).iterator-&gt;value;
1031     for (auto&amp; result : finder.results())
1032         resultsVector.append(result);
1033 
1034     *resultCount = resultsVector.size();
1035 }
1036 
1037 void InspectorDOMAgent::getSearchResults(ErrorString&amp; errorString, const String&amp; searchId, int fromIndex, int toIndex, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; nodeIds)
1038 {
1039     SearchResults::iterator it = m_searchResults.find(searchId);
1040     if (it == m_searchResults.end()) {
1041         errorString = &quot;No search session with given id found&quot;_s;
1042         return;
1043     }
1044 
1045     int size = it-&gt;value.size();
1046     if (fromIndex &lt; 0 || toIndex &gt; size || fromIndex &gt;= toIndex) {
1047         errorString = &quot;Invalid search result range&quot;_s;
1048         return;
1049     }
1050 
1051     nodeIds = JSON::ArrayOf&lt;int&gt;::create();
1052     for (int i = fromIndex; i &lt; toIndex; ++i)
1053         nodeIds-&gt;addItem(pushNodePathToFrontend((it-&gt;value)[i].get()));
1054 }
1055 
1056 void InspectorDOMAgent::discardSearchResults(ErrorString&amp;, const String&amp; searchId)
1057 {
1058     m_searchResults.remove(searchId);
1059 }
1060 
1061 bool InspectorDOMAgent::handleMousePress()
1062 {
1063     if (!m_searchingForNode)
1064         return false;
1065 
1066     if (Node* node = m_overlay-&gt;highlightedNode()) {
1067         inspect(node);
1068         return true;
1069     }
1070     return false;
1071 }
1072 
1073 bool InspectorDOMAgent::handleTouchEvent(Node&amp; node)
1074 {
1075     if (!m_searchingForNode)
1076         return false;
1077     if (m_inspectModeHighlightConfig) {
1078         m_overlay-&gt;highlightNode(&amp;node, *m_inspectModeHighlightConfig);
1079         inspect(&amp;node);
1080         return true;
1081     }
1082     return false;
1083 }
1084 
1085 void InspectorDOMAgent::inspect(Node* inspectedNode)
1086 {
1087     ErrorString unused;
1088     RefPtr&lt;Node&gt; node = inspectedNode;
1089     setSearchingForNode(unused, false, nullptr);
1090 
1091     if (node-&gt;nodeType() != Node::ELEMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_NODE)
1092         node = node-&gt;parentNode();
1093     m_nodeToFocus = node;
1094 
1095     if (!m_nodeToFocus)
1096         return;
1097 
1098     focusNode();
1099 }
1100 
1101 void InspectorDOMAgent::focusNode()
1102 {
1103     if (!m_frontendDispatcher)
1104         return;
1105 
1106     ASSERT(m_nodeToFocus);
1107 
1108     RefPtr&lt;Node&gt; node = m_nodeToFocus.get();
1109     m_nodeToFocus = nullptr;
1110 
1111     Frame* frame = node-&gt;document().frame();
1112     if (!frame)
1113         return;
1114 
1115     JSC::ExecState* scriptState = mainWorldExecState(frame);
1116     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(scriptState);
1117     if (injectedScript.hasNoValue())
1118         return;
1119 
1120     injectedScript.inspectObject(nodeAsScriptValue(*scriptState, node.get()));
1121 }
1122 
1123 void InspectorDOMAgent::mouseDidMoveOverElement(const HitTestResult&amp; result, unsigned)
1124 {
1125     m_mousedOverNode = result.innerNode();
1126 
1127     if (!m_searchingForNode)
1128         return;
1129 
1130     highlightMousedOverNode();
1131 }
1132 
1133 void InspectorDOMAgent::highlightMousedOverNode()
1134 {
1135     Node* node = m_mousedOverNode.get();
1136     while (node &amp;&amp; node-&gt;nodeType() == Node::TEXT_NODE)
1137         node = node-&gt;parentNode();
1138     if (node &amp;&amp; m_inspectModeHighlightConfig)
1139         m_overlay-&gt;highlightNode(node, *m_inspectModeHighlightConfig);
1140 }
1141 
1142 void InspectorDOMAgent::setSearchingForNode(ErrorString&amp; errorString, bool enabled, const JSON::Object* highlightInspectorObject)
1143 {
1144     if (m_searchingForNode == enabled)
1145         return;
1146 
1147     m_searchingForNode = enabled;
1148 
1149     if (enabled) {
1150         m_inspectModeHighlightConfig = highlightConfigFromInspectorObject(errorString, highlightInspectorObject);
1151         if (!m_inspectModeHighlightConfig)
1152             return;
1153         highlightMousedOverNode();
1154     } else
1155         hideHighlight(errorString);
1156 
1157     m_overlay-&gt;didSetSearchingForNode(m_searchingForNode);
1158 
1159     if (InspectorClient* client = m_pageAgent-&gt;page().inspectorController().inspectorClient())
1160         client-&gt;elementSelectionChanged(m_searchingForNode);
1161 }
1162 
1163 std::unique_ptr&lt;HighlightConfig&gt; InspectorDOMAgent::highlightConfigFromInspectorObject(ErrorString&amp; errorString, const JSON::Object* highlightInspectorObject)
1164 {
1165     if (!highlightInspectorObject) {
1166         errorString = &quot;Internal error: highlight configuration parameter is missing&quot;_s;
1167         return nullptr;
1168     }
1169 
1170     auto highlightConfig = std::make_unique&lt;HighlightConfig&gt;();
1171     bool showInfo = false; // Default: false (do not show a tooltip).
1172     highlightInspectorObject-&gt;getBoolean(&quot;showInfo&quot;, showInfo);
1173     highlightConfig-&gt;showInfo = showInfo;
1174     highlightConfig-&gt;content = parseConfigColor(&quot;contentColor&quot;, highlightInspectorObject);
1175     highlightConfig-&gt;contentOutline = parseConfigColor(&quot;contentOutlineColor&quot;, highlightInspectorObject);
1176     highlightConfig-&gt;padding = parseConfigColor(&quot;paddingColor&quot;, highlightInspectorObject);
1177     highlightConfig-&gt;border = parseConfigColor(&quot;borderColor&quot;, highlightInspectorObject);
1178     highlightConfig-&gt;margin = parseConfigColor(&quot;marginColor&quot;, highlightInspectorObject);
1179     return highlightConfig;
1180 }
1181 
1182 void InspectorDOMAgent::setInspectModeEnabled(ErrorString&amp; errorString, bool enabled, const JSON::Object* highlightConfig)
1183 {
1184     setSearchingForNode(errorString, enabled, highlightConfig ? highlightConfig : nullptr);
1185 }
1186 
1187 void InspectorDOMAgent::highlightRect(ErrorString&amp;, int x, int y, int width, int height, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1188 {
1189     auto quad = std::make_unique&lt;FloatQuad&gt;(FloatRect(x, y, width, height));
1190     innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
1191 }
1192 
1193 void InspectorDOMAgent::highlightQuad(ErrorString&amp; errorString, const JSON::Array&amp; quadArray, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1194 {
1195     auto quad = std::make_unique&lt;FloatQuad&gt;();
1196     if (!parseQuad(quadArray, quad.get())) {
1197         errorString = &quot;Invalid Quad format&quot;_s;
1198         return;
1199     }
1200     innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
1201 }
1202 
1203 void InspectorDOMAgent::innerHighlightQuad(std::unique_ptr&lt;FloatQuad&gt; quad, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1204 {
1205     auto highlightConfig = std::make_unique&lt;HighlightConfig&gt;();
1206     highlightConfig-&gt;content = parseColor(color);
1207     highlightConfig-&gt;contentOutline = parseColor(outlineColor);
1208     highlightConfig-&gt;usePageCoordinates = usePageCoordinates ? *usePageCoordinates : false;
1209     m_overlay-&gt;highlightQuad(WTFMove(quad), *highlightConfig);
1210 }
1211 
1212 void InspectorDOMAgent::highlightSelector(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const String&amp; selectorString, const String* frameId)
1213 {
1214     RefPtr&lt;Document&gt; document;
1215 
1216     if (frameId) {
1217         Frame* frame = m_pageAgent-&gt;frameForId(*frameId);
1218         if (!frame) {
1219             errorString = &quot;No frame for given id found&quot;_s;
1220             return;
1221         }
1222 
1223         document = frame-&gt;document();
1224     } else
1225         document = m_document;
1226 
1227     if (!document) {
1228         errorString = &quot;Document could not be found&quot;_s;
1229         return;
1230     }
1231 
1232     auto queryResult = document-&gt;querySelectorAll(selectorString);
1233     // FIXME: &lt;https://webkit.org/b/146161&gt; Web Inspector: DOM.highlightSelector should work for &quot;a:visited&quot;
1234     if (queryResult.hasException()) {
1235         errorString = &quot;DOM Error while querying&quot;_s;
1236         return;
1237     }
1238 
1239     auto highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1240     if (!highlightConfig)
1241         return;
1242 
1243     m_overlay-&gt;highlightNodeList(queryResult.releaseReturnValue(), *highlightConfig);
1244 }
1245 
1246 void InspectorDOMAgent::highlightNode(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const int* nodeId, const String* objectId)
1247 {
1248     Node* node = nullptr;
1249     if (nodeId)
1250         node = assertNode(errorString, *nodeId);
1251     else if (objectId) {
1252         node = nodeForObjectId(*objectId);
1253         if (!node)
1254             errorString = &quot;Node for given objectId not found&quot;_s;
1255     } else
1256         errorString = &quot;Either nodeId or objectId must be specified&quot;_s;
1257 
1258     if (!node)
1259         return;
1260 
1261     std::unique_ptr&lt;HighlightConfig&gt; highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1262     if (!highlightConfig)
1263         return;
1264 
1265     m_overlay-&gt;highlightNode(node, *highlightConfig);
1266 }
1267 
1268 void InspectorDOMAgent::highlightNodeList(ErrorString&amp; errorString, const JSON::Array&amp; nodeIds, const JSON::Object&amp; highlightInspectorObject)
1269 {
1270     Vector&lt;Ref&lt;Node&gt;&gt; nodes;
1271     for (auto&amp; nodeValue : nodeIds) {
1272         if (!nodeValue) {
1273             errorString = &quot;Invalid nodeIds item.&quot;_s;
1274             return;
1275         }
1276 
1277         int nodeId = 0;
1278         if (!nodeValue-&gt;asInteger(nodeId)) {
1279             errorString = &quot;Invalid nodeIds item type. Expecting integer types.&quot;_s;
1280             return;
1281         }
1282 
1283         // In the case that a node is removed in the time between when highlightNodeList is invoked
1284         // by the frontend and it is executed by the backend, we should still attempt to highlight
1285         // as many nodes as possible. As such, we should ignore any errors generated when attempting
1286         // to get a Node from a given nodeId.
1287         ErrorString ignored;
1288         Node* node = assertNode(ignored, nodeId);
1289         if (!node)
1290             continue;
1291 
1292         nodes.append(*node);
1293     }
1294 
1295     std::unique_ptr&lt;HighlightConfig&gt; highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1296     if (!highlightConfig)
1297         return;
1298 
1299     m_overlay-&gt;highlightNodeList(StaticNodeList::create(WTFMove(nodes)), *highlightConfig);
1300 }
1301 
1302 void InspectorDOMAgent::highlightFrame(ErrorString&amp; errorString, const String&amp; frameId, const JSON::Object* color, const JSON::Object* outlineColor)
1303 {
1304     Frame* frame = m_pageAgent-&gt;assertFrame(errorString, frameId);
1305     if (!frame)
1306         return;
1307 
1308     if (frame-&gt;ownerElement()) {
1309         auto highlightConfig = std::make_unique&lt;HighlightConfig&gt;();
1310         highlightConfig-&gt;showInfo = true; // Always show tooltips for frames.
1311         highlightConfig-&gt;content = parseColor(color);
1312         highlightConfig-&gt;contentOutline = parseColor(outlineColor);
1313         m_overlay-&gt;highlightNode(frame-&gt;ownerElement(), *highlightConfig);
1314     }
1315 }
1316 
1317 void InspectorDOMAgent::hideHighlight(ErrorString&amp;)
1318 {
1319     m_overlay-&gt;hideHighlight();
1320 }
1321 
1322 void InspectorDOMAgent::moveTo(ErrorString&amp; errorString, int nodeId, int targetElementId, const int* anchorNodeId, int* newNodeId)
1323 {
1324     Node* node = assertEditableNode(errorString, nodeId);
1325     if (!node)
1326         return;
1327 
1328     Element* targetElement = assertEditableElement(errorString, targetElementId);
1329     if (!targetElement)
1330         return;
1331 
1332     Node* anchorNode = 0;
1333     if (anchorNodeId &amp;&amp; *anchorNodeId) {
1334         anchorNode = assertEditableNode(errorString, *anchorNodeId);
1335         if (!anchorNode)
1336             return;
1337         if (anchorNode-&gt;parentNode() != targetElement) {
1338             errorString = &quot;Anchor node must be child of the target element&quot;_s;
1339             return;
1340         }
1341     }
1342 
1343     if (!m_domEditor-&gt;insertBefore(*targetElement, *node, anchorNode, errorString))
1344         return;
1345 
1346     *newNodeId = pushNodePathToFrontend(node);
1347 }
1348 
1349 void InspectorDOMAgent::undo(ErrorString&amp; errorString)
1350 {
1351     auto result = m_history-&gt;undo();
1352     if (result.hasException())
1353         errorString = toErrorString(result.releaseException());
1354 }
1355 
1356 void InspectorDOMAgent::redo(ErrorString&amp; errorString)
1357 {
1358     auto result = m_history-&gt;redo();
1359     if (result.hasException())
1360         errorString = toErrorString(result.releaseException());
1361 }
1362 
1363 void InspectorDOMAgent::markUndoableState(ErrorString&amp;)
1364 {
1365     m_history-&gt;markUndoableState();
1366 }
1367 
1368 void InspectorDOMAgent::focus(ErrorString&amp; errorString, int nodeId)
1369 {
1370     Element* element = assertElement(errorString, nodeId);
1371     if (!element)
1372         return;
1373     if (!element-&gt;isFocusable()) {
1374         errorString = &quot;Element is not focusable&quot;_s;
1375         return;
1376     }
1377     element-&gt;focus();
1378 }
1379 
1380 void InspectorDOMAgent::setInspectedNode(ErrorString&amp; errorString, int nodeId)
1381 {
1382     Node* node = nodeForId(nodeId);
1383     if (!node || node-&gt;isInUserAgentShadowTree()) {
1384         errorString = &quot;No node with given id found&quot;_s;
1385         return;
1386     }
1387 
1388     if (CommandLineAPIHost* commandLineAPIHost = static_cast&lt;WebInjectedScriptManager&amp;&gt;(m_injectedScriptManager).commandLineAPIHost())
1389         commandLineAPIHost-&gt;addInspectedObject(std::make_unique&lt;InspectableNode&gt;(node));
1390 }
1391 
1392 void InspectorDOMAgent::resolveNode(ErrorString&amp; errorString, int nodeId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
1393 {
1394     String objectGroupName = objectGroup ? *objectGroup : emptyString();
1395     Node* node = nodeForId(nodeId);
1396     if (!node) {
1397         errorString = &quot;No node with given id found&quot;_s;
1398         return;
1399     }
1400     RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; object = resolveNode(node, objectGroupName);
1401     if (!object) {
1402         errorString = &quot;Node with given id does not belong to the document&quot;_s;
1403         return;
1404     }
1405     result = object;
1406 }
1407 
1408 void InspectorDOMAgent::getAttributes(ErrorString&amp; errorString, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; result)
1409 {
1410     Element* element = assertElement(errorString, nodeId);
1411     if (!element)
1412         return;
1413 
1414     result = buildArrayForElementAttributes(element);
1415 }
1416 
1417 void InspectorDOMAgent::requestNode(ErrorString&amp;, const String&amp; objectId, int* nodeId)
1418 {
1419     Node* node = nodeForObjectId(objectId);
1420     if (node)
1421         *nodeId = pushNodePathToFrontend(node);
1422     else
1423         *nodeId = 0;
1424 }
1425 
1426 String InspectorDOMAgent::documentURLString(Document* document)
1427 {
1428     if (!document || document-&gt;url().isNull())
1429         return emptyString();
1430     return document-&gt;url().string();
1431 }
1432 
1433 static String documentBaseURLString(Document* document)
1434 {
1435     return document-&gt;completeURL(emptyString()).string();
1436 }
1437 
1438 static bool pseudoElementType(PseudoId pseudoId, Inspector::Protocol::DOM::PseudoType* type)
1439 {
1440     switch (pseudoId) {
1441     case PseudoId::Before:
1442         *type = Inspector::Protocol::DOM::PseudoType::Before;
1443         return true;
1444     case PseudoId::After:
1445         *type = Inspector::Protocol::DOM::PseudoType::After;
1446         return true;
1447     default:
1448         return false;
1449     }
1450 }
1451 
1452 static Inspector::Protocol::DOM::ShadowRootType shadowRootType(ShadowRootMode mode)
1453 {
1454     switch (mode) {
1455     case ShadowRootMode::UserAgent:
1456         return Inspector::Protocol::DOM::ShadowRootType::UserAgent;
1457     case ShadowRootMode::Closed:
1458         return Inspector::Protocol::DOM::ShadowRootType::Closed;
1459     case ShadowRootMode::Open:
1460         return Inspector::Protocol::DOM::ShadowRootType::Open;
1461     }
1462 
1463     ASSERT_NOT_REACHED();
1464     return Inspector::Protocol::DOM::ShadowRootType::UserAgent;
1465 }
1466 
1467 static Inspector::Protocol::DOM::CustomElementState customElementState(const Element&amp; element)
1468 {
1469     if (element.isDefinedCustomElement())
1470         return Inspector::Protocol::DOM::CustomElementState::Custom;
1471     if (element.isFailedCustomElement())
1472         return Inspector::Protocol::DOM::CustomElementState::Failed;
1473     if (element.isUndefinedCustomElement() || element.isCustomElementUpgradeCandidate())
1474         return Inspector::Protocol::DOM::CustomElementState::Waiting;
1475     return Inspector::Protocol::DOM::CustomElementState::Builtin;
1476 }
1477 
1478 static String computeContentSecurityPolicySHA256Hash(const Element&amp; element)
1479 {
1480     // FIXME: Compute the digest with respect to the raw bytes received from the page.
1481     // See &lt;https://bugs.webkit.org/show_bug.cgi?id=155184&gt;.
1482     TextEncoding documentEncoding = element.document().textEncoding();
1483     const TextEncoding&amp; encodingToUse = documentEncoding.isValid() ? documentEncoding : UTF8Encoding();
1484     auto content = encodingToUse.encode(TextNodeTraversal::contentsAsString(element), UnencodableHandling::Entities);
1485     auto cryptoDigest = PAL::CryptoDigest::create(PAL::CryptoDigest::Algorithm::SHA_256);
1486     cryptoDigest-&gt;addBytes(content.data(), content.size());
1487     auto digest = cryptoDigest-&gt;computeHash();
1488     return makeString(&quot;sha256-&quot;, base64Encode(digest.data(), digest.size()));
1489 }
1490 
1491 Ref&lt;Inspector::Protocol::DOM::Node&gt; InspectorDOMAgent::buildObjectForNode(Node* node, int depth, NodeToIdMap* nodesMap)
1492 {
1493     int id = bind(node, nodesMap);
1494     String nodeName;
1495     String localName;
1496     String nodeValue;
1497 
1498     switch (node-&gt;nodeType()) {
1499     case Node::PROCESSING_INSTRUCTION_NODE:
1500         nodeName = node-&gt;nodeName();
1501         localName = node-&gt;localName();
1502         FALLTHROUGH;
1503     case Node::TEXT_NODE:
1504     case Node::COMMENT_NODE:
1505     case Node::CDATA_SECTION_NODE:
1506         nodeValue = node-&gt;nodeValue();
1507         if (nodeValue.length() &gt; maxTextSize) {
1508             nodeValue = nodeValue.left(maxTextSize);
1509             nodeValue.append(ellipsisUChar);
1510         }
1511         break;
1512     case Node::ATTRIBUTE_NODE:
1513         localName = node-&gt;localName();
1514         break;
1515     case Node::DOCUMENT_FRAGMENT_NODE:
1516     case Node::DOCUMENT_NODE:
1517     case Node::ELEMENT_NODE:
1518     default:
1519         nodeName = node-&gt;nodeName();
1520         localName = node-&gt;localName();
1521         break;
1522     }
1523 
1524     auto value = Inspector::Protocol::DOM::Node::create()
1525         .setNodeId(id)
1526         .setNodeType(static_cast&lt;int&gt;(node-&gt;nodeType()))
1527         .setNodeName(nodeName)
1528         .setLocalName(localName)
1529         .setNodeValue(nodeValue)
1530         .release();
1531 
1532     if (node-&gt;isContainerNode()) {
1533         int nodeCount = innerChildNodeCount(node);
1534         value-&gt;setChildNodeCount(nodeCount);
1535         Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; children = buildArrayForContainerChildren(node, depth, nodesMap);
1536         if (children-&gt;length() &gt; 0)
1537             value-&gt;setChildren(WTFMove(children));
1538     }
1539 
1540     if (is&lt;Element&gt;(*node)) {
1541         Element&amp; element = downcast&lt;Element&gt;(*node);
1542         value-&gt;setAttributes(buildArrayForElementAttributes(&amp;element));
1543         if (is&lt;HTMLFrameOwnerElement&gt;(element)) {
1544             HTMLFrameOwnerElement&amp; frameOwner = downcast&lt;HTMLFrameOwnerElement&gt;(element);
1545             Frame* frame = frameOwner.contentFrame();
1546             if (frame)
1547                 value-&gt;setFrameId(m_pageAgent-&gt;frameId(frame));
1548             Document* document = frameOwner.contentDocument();
1549             if (document)
1550                 value-&gt;setContentDocument(buildObjectForNode(document, 0, nodesMap));
1551         }
1552 
1553         if (ShadowRoot* root = element.shadowRoot()) {
1554             auto shadowRoots = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
1555             shadowRoots-&gt;addItem(buildObjectForNode(root, 0, nodesMap));
1556             value-&gt;setShadowRoots(WTFMove(shadowRoots));
1557         }
1558 
1559         if (is&lt;HTMLTemplateElement&gt;(element))
1560             value-&gt;setTemplateContent(buildObjectForNode(&amp;downcast&lt;HTMLTemplateElement&gt;(element).content(), 0, nodesMap));
1561 
1562         if (is&lt;HTMLStyleElement&gt;(element) || (is&lt;HTMLScriptElement&gt;(element) &amp;&amp; !element.hasAttributeWithoutSynchronization(HTMLNames::srcAttr)))
1563             value-&gt;setContentSecurityPolicyHash(computeContentSecurityPolicySHA256Hash(element));
1564 
1565         auto state = customElementState(element);
1566         if (state != Inspector::Protocol::DOM::CustomElementState::Builtin)
1567             value-&gt;setCustomElementState(state);
1568 
1569         if (element.pseudoId() != PseudoId::None) {
1570             Inspector::Protocol::DOM::PseudoType pseudoType;
1571             if (pseudoElementType(element.pseudoId(), &amp;pseudoType))
1572                 value-&gt;setPseudoType(pseudoType);
1573         } else {
1574             if (auto pseudoElements = buildArrayForPseudoElements(element, nodesMap))
1575                 value-&gt;setPseudoElements(WTFMove(pseudoElements));
1576         }
1577 
1578     } else if (is&lt;Document&gt;(*node)) {
1579         Document&amp; document = downcast&lt;Document&gt;(*node);
1580         value-&gt;setFrameId(m_pageAgent-&gt;frameId(document.frame()));
1581         value-&gt;setDocumentURL(documentURLString(&amp;document));
1582         value-&gt;setBaseURL(documentBaseURLString(&amp;document));
1583         value-&gt;setXmlVersion(document.xmlVersion());
1584     } else if (is&lt;DocumentType&gt;(*node)) {
1585         DocumentType&amp; docType = downcast&lt;DocumentType&gt;(*node);
1586         value-&gt;setPublicId(docType.publicId());
1587         value-&gt;setSystemId(docType.systemId());
1588     } else if (is&lt;Attr&gt;(*node)) {
1589         Attr&amp; attribute = downcast&lt;Attr&gt;(*node);
1590         value-&gt;setName(attribute.name());
1591         value-&gt;setValue(attribute.value());
1592     } else if (is&lt;ShadowRoot&gt;(*node)) {
1593         ShadowRoot&amp; shadowRoot = downcast&lt;ShadowRoot&gt;(*node);
1594         value-&gt;setShadowRootType(shadowRootType(shadowRoot.mode()));
1595     }
1596 
1597     return value;
1598 }
1599 
1600 Ref&lt;JSON::ArrayOf&lt;String&gt;&gt; InspectorDOMAgent::buildArrayForElementAttributes(Element* element)
1601 {
1602     auto attributesValue = JSON::ArrayOf&lt;String&gt;::create();
1603     // Go through all attributes and serialize them.
1604     if (!element-&gt;hasAttributes())
1605         return attributesValue;
1606     for (const Attribute&amp; attribute : element-&gt;attributesIterator()) {
1607         // Add attribute pair
1608         attributesValue-&gt;addItem(attribute.name().toString());
1609         attributesValue-&gt;addItem(attribute.value());
1610     }
1611     return attributesValue;
1612 }
1613 
1614 Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; InspectorDOMAgent::buildArrayForContainerChildren(Node* container, int depth, NodeToIdMap* nodesMap)
1615 {
1616     auto children = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
1617     if (depth == 0) {
1618         // Special-case the only text child - pretend that container&#39;s children have been requested.
1619         Node* firstChild = container-&gt;firstChild();
1620         if (firstChild &amp;&amp; firstChild-&gt;nodeType() == Node::TEXT_NODE &amp;&amp; !firstChild-&gt;nextSibling()) {
1621             children-&gt;addItem(buildObjectForNode(firstChild, 0, nodesMap));
1622             m_childrenRequested.add(bind(container, nodesMap));
1623         }
1624         return children;
1625     }
1626 
1627     Node* child = innerFirstChild(container);
1628     depth--;
1629     m_childrenRequested.add(bind(container, nodesMap));
1630 
1631     while (child) {
1632         children-&gt;addItem(buildObjectForNode(child, depth, nodesMap));
1633         child = innerNextSibling(child);
1634     }
1635     return children;
1636 }
1637 
1638 RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; InspectorDOMAgent::buildArrayForPseudoElements(const Element&amp; element, NodeToIdMap* nodesMap)
1639 {
1640     PseudoElement* beforeElement = element.beforePseudoElement();
1641     PseudoElement* afterElement = element.afterPseudoElement();
1642     if (!beforeElement &amp;&amp; !afterElement)
1643         return nullptr;
1644 
1645     auto pseudoElements = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
1646     if (beforeElement)
1647         pseudoElements-&gt;addItem(buildObjectForNode(beforeElement, 0, nodesMap));
1648     if (afterElement)
1649         pseudoElements-&gt;addItem(buildObjectForNode(afterElement, 0, nodesMap));
1650     return WTFMove(pseudoElements);
1651 }
1652 
1653 Ref&lt;Inspector::Protocol::DOM::EventListener&gt; InspectorDOMAgent::buildObjectForEventListener(const RegisteredEventListener&amp; registeredEventListener, int identifier, const AtomicString&amp; eventType, Node* node, const String* objectGroupId, bool disabled, bool hasBreakpoint)
1654 {
1655     Ref&lt;EventListener&gt; eventListener = registeredEventListener.callback();
1656 
1657     JSC::ExecState* exec = nullptr;
1658     JSC::JSObject* handlerObject = nullptr;
1659     JSC::JSFunction* handlerFunction = nullptr;
1660     String handlerName;
1661     int lineNumber = 0;
1662     int columnNumber = 0;
1663     String scriptID;
1664     if (is&lt;JSEventListener&gt;(eventListener.get())) {
1665         auto&amp; scriptListener = downcast&lt;JSEventListener&gt;(eventListener.get());
1666 
1667         JSC::JSLockHolder lock(scriptListener.isolatedWorld().vm());
1668 
1669         exec = execStateFromNode(scriptListener.isolatedWorld(), &amp;node-&gt;document());
1670         handlerObject = scriptListener.jsFunction(node-&gt;document());
1671         if (handlerObject &amp;&amp; exec) {
1672             handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(exec-&gt;vm(), handlerObject);
1673 
1674             if (!handlerFunction) {
1675                 auto scope = DECLARE_CATCH_SCOPE(exec-&gt;vm());
1676 
1677                 // If the handler is not actually a function, see if it implements the EventListener interface and use that.
1678                 auto handleEventValue = handlerObject-&gt;get(exec, JSC::Identifier::fromString(exec, &quot;handleEvent&quot;));
1679 
1680                 if (UNLIKELY(scope.exception()))
1681                     scope.clearException();
1682 
1683                 if (handleEventValue)
1684                     handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(exec-&gt;vm(), handleEventValue);
1685             }
1686 
1687             if (handlerFunction &amp;&amp; !handlerFunction-&gt;isHostOrBuiltinFunction()) {
1688                 // If the listener implements the EventListener interface, use the class name instead of
1689                 // &quot;handleEvent&quot;, unless it is a plain object.
1690                 if (handlerFunction != handlerObject)
1691                     handlerName = JSC::JSObject::calculatedClassName(handlerObject);
1692                 if (handlerName.isEmpty() || handlerName == &quot;Object&quot;_s)
1693                     handlerName = handlerFunction-&gt;calculatedDisplayName(exec-&gt;vm());
1694 
1695                 if (auto executable = handlerFunction-&gt;jsExecutable()) {
1696                     lineNumber = executable-&gt;firstLine() - 1;
1697                     columnNumber = executable-&gt;startColumn() - 1;
1698                     scriptID = executable-&gt;sourceID() == JSC::SourceProvider::nullID ? emptyString() : String::number(executable-&gt;sourceID());
1699                 }
1700             }
1701         }
1702     }
1703 
1704     auto value = Inspector::Protocol::DOM::EventListener::create()
1705         .setEventListenerId(identifier)
1706         .setType(eventType)
1707         .setUseCapture(registeredEventListener.useCapture())
1708         .setIsAttribute(eventListener-&gt;isAttribute())
1709         .setNodeId(pushNodePathToFrontend(node))
1710         .release();
1711     if (objectGroupId &amp;&amp; handlerObject &amp;&amp; exec) {
1712         InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(exec);
1713         if (!injectedScript.hasNoValue())
1714             value-&gt;setHandlerObject(injectedScript.wrapObject(handlerObject, *objectGroupId));
1715     }
1716     if (!scriptID.isNull()) {
1717         auto location = Inspector::Protocol::Debugger::Location::create()
1718             .setScriptId(scriptID)
1719             .setLineNumber(lineNumber)
1720             .release();
1721         location-&gt;setColumnNumber(columnNumber);
1722         value-&gt;setLocation(WTFMove(location));
1723     }
1724     if (!handlerName.isEmpty())
1725         value-&gt;setHandlerName(handlerName);
1726     if (registeredEventListener.isPassive())
1727         value-&gt;setPassive(true);
1728     if (registeredEventListener.isOnce())
1729         value-&gt;setOnce(true);
1730     if (disabled)
1731         value-&gt;setDisabled(disabled);
1732     if (hasBreakpoint)
1733         value-&gt;setHasBreakpoint(hasBreakpoint);
1734     return value;
1735 }
1736 
1737 void InspectorDOMAgent::processAccessibilityChildren(AccessibilityObject&amp; axObject, JSON::ArrayOf&lt;int&gt;&amp; childNodeIds)
1738 {
1739     const auto&amp; children = axObject.children();
1740     if (!children.size())
1741         return;
1742 
1743     for (const auto&amp; childObject : children) {
1744         if (Node* childNode = childObject-&gt;node())
1745             childNodeIds.addItem(pushNodePathToFrontend(childNode));
1746         else
1747             processAccessibilityChildren(*childObject, childNodeIds);
1748     }
1749 }
1750 
1751 RefPtr&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt; InspectorDOMAgent::buildObjectForAccessibilityProperties(Node* node)
1752 {
1753     ASSERT(node);
1754     if (!node)
1755         return nullptr;
1756 
1757     if (!WebCore::AXObjectCache::accessibilityEnabled())
1758         WebCore::AXObjectCache::enableAccessibility();
1759 
1760     Node* activeDescendantNode = nullptr;
1761     bool busy = false;
1762     auto checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::False;
1763     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; childNodeIds;
1764     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; controlledNodeIds;
1765     auto currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::False;
1766     bool exists = false;
1767     bool expanded = false;
1768     bool disabled = false;
1769     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; flowedNodeIds;
1770     bool focused = false;
1771     bool ignored = true;
1772     bool ignoredByDefault = false;
1773     auto invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::False;
1774     bool hidden = false;
1775     String label;
1776     bool liveRegionAtomic = false;
1777     RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt; liveRegionRelevant;
1778     auto liveRegionStatus = Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Off;
1779     Node* mouseEventNode = nullptr;
1780     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; ownedNodeIds;
1781     Node* parentNode = nullptr;
1782     bool pressed = false;
1783     bool readonly = false;
1784     bool required = false;
1785     String role;
1786     bool selected = false;
1787     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; selectedChildNodeIds;
1788     bool supportsChecked = false;
1789     bool supportsExpanded = false;
1790     bool supportsLiveRegion = false;
1791     bool supportsPressed = false;
1792     bool supportsRequired = false;
1793     bool supportsFocused = false;
1794     bool isPopupButton = false;
1795     int headingLevel = 0;
1796     unsigned hierarchicalLevel = 0;
1797     unsigned level = 0;
1798 
1799     if (AXObjectCache* axObjectCache = node-&gt;document().axObjectCache()) {
1800         if (AccessibilityObject* axObject = axObjectCache-&gt;getOrCreate(node)) {
1801 
1802             if (AccessibilityObject* activeDescendant = axObject-&gt;activeDescendant())
1803                 activeDescendantNode = activeDescendant-&gt;node();
1804 
1805             // An AX object is &quot;busy&quot; if it or any ancestor has aria-busy=&quot;true&quot; set.
1806             AccessibilityObject* current = axObject;
1807             while (!busy &amp;&amp; current) {
1808                 busy = current-&gt;isBusy();
1809                 current = current-&gt;parentObject();
1810             }
1811 
1812             supportsChecked = axObject-&gt;supportsChecked();
1813             if (supportsChecked) {
1814                 AccessibilityButtonState checkValue = axObject-&gt;checkboxOrRadioValue(); // Element using aria-checked.
1815                 if (checkValue == AccessibilityButtonState::On)
1816                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::True;
1817                 else if (checkValue == AccessibilityButtonState::Mixed)
1818                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::Mixed;
1819                 else if (axObject-&gt;isChecked()) // Native checkbox.
1820                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::True;
1821             }
1822 
1823             if (!axObject-&gt;children().isEmpty()) {
1824                 childNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1825                 processAccessibilityChildren(*axObject, *childNodeIds);
1826             }
1827 
1828             Vector&lt;Element*&gt; controlledElements;
1829             axObject-&gt;elementsFromAttribute(controlledElements, aria_controlsAttr);
1830             if (controlledElements.size()) {
1831                 controlledNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1832                 for (Element* controlledElement : controlledElements)
1833                     controlledNodeIds-&gt;addItem(pushNodePathToFrontend(controlledElement));
1834             }
1835 
1836             switch (axObject-&gt;currentState()) {
1837             case AccessibilityCurrentState::False:
1838                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::False;
1839                 break;
1840             case AccessibilityCurrentState::Page:
1841                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Page;
1842                 break;
1843             case AccessibilityCurrentState::Step:
1844                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Step;
1845                 break;
1846             case AccessibilityCurrentState::Location:
1847                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Location;
1848                 break;
1849             case AccessibilityCurrentState::Date:
1850                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Date;
1851                 break;
1852             case AccessibilityCurrentState::Time:
1853                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Time;
1854                 break;
1855             case AccessibilityCurrentState::True:
1856                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::True;
1857                 break;
1858             }
1859 
1860             disabled = !axObject-&gt;isEnabled();
1861             exists = true;
1862 
1863             supportsExpanded = axObject-&gt;supportsExpanded();
1864             if (supportsExpanded)
1865                 expanded = axObject-&gt;isExpanded();
1866 
1867             Vector&lt;Element*&gt; flowedElements;
1868             axObject-&gt;elementsFromAttribute(flowedElements, aria_flowtoAttr);
1869             if (flowedElements.size()) {
1870                 flowedNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1871                 for (Element* flowedElement : flowedElements)
1872                     flowedNodeIds-&gt;addItem(pushNodePathToFrontend(flowedElement));
1873             }
1874 
1875             if (is&lt;Element&gt;(*node)) {
1876                 supportsFocused = axObject-&gt;canSetFocusAttribute();
1877                 if (supportsFocused)
1878                     focused = axObject-&gt;isFocused();
1879             }
1880 
1881             ignored = axObject-&gt;accessibilityIsIgnored();
1882             ignoredByDefault = axObject-&gt;accessibilityIsIgnoredByDefault();
1883 
1884             String invalidValue = axObject-&gt;invalidStatus();
1885             if (invalidValue == &quot;false&quot;)
1886                 invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::False;
1887             else if (invalidValue == &quot;grammar&quot;)
1888                 invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::Grammar;
1889             else if (invalidValue == &quot;spelling&quot;)
1890                 invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::Spelling;
1891             else // Future versions of ARIA may allow additional truthy values. Ex. format, order, or size.
1892                 invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::True;
1893 
1894             if (axObject-&gt;isAXHidden() || axObject-&gt;isDOMHidden())
1895                 hidden = true;
1896 
1897             label = axObject-&gt;computedLabel();
1898 
1899             if (axObject-&gt;supportsLiveRegion()) {
1900                 supportsLiveRegion = true;
1901                 liveRegionAtomic = axObject-&gt;liveRegionAtomic();
1902 
1903                 String ariaRelevantAttrValue = axObject-&gt;liveRegionRelevant();
1904                 if (!ariaRelevantAttrValue.isEmpty()) {
1905                     // FIXME: Pass enum values rather than strings once unblocked. http://webkit.org/b/133711
1906                     String ariaRelevantAdditions = Inspector::Protocol::InspectorHelpers::getEnumConstantValue(Inspector::Protocol::DOM::LiveRegionRelevant::Additions);
1907                     String ariaRelevantRemovals = Inspector::Protocol::InspectorHelpers::getEnumConstantValue(Inspector::Protocol::DOM::LiveRegionRelevant::Removals);
1908                     String ariaRelevantText = Inspector::Protocol::InspectorHelpers::getEnumConstantValue(Inspector::Protocol::DOM::LiveRegionRelevant::Text);
1909                     liveRegionRelevant = JSON::ArrayOf&lt;String&gt;::create();
1910                     const SpaceSplitString&amp; values = SpaceSplitString(ariaRelevantAttrValue, true);
1911                     // @aria-relevant=&quot;all&quot; is exposed as [&quot;additions&quot;,&quot;removals&quot;,&quot;text&quot;], in order.
1912                     // This order is controlled in WebCore and expected in WebInspectorUI.
1913                     if (values.contains(&quot;all&quot;)) {
1914                         liveRegionRelevant-&gt;addItem(ariaRelevantAdditions);
1915                         liveRegionRelevant-&gt;addItem(ariaRelevantRemovals);
1916                         liveRegionRelevant-&gt;addItem(ariaRelevantText);
1917                     } else {
1918                         if (values.contains(ariaRelevantAdditions))
1919                             liveRegionRelevant-&gt;addItem(ariaRelevantAdditions);
1920                         if (values.contains(ariaRelevantRemovals))
1921                             liveRegionRelevant-&gt;addItem(ariaRelevantRemovals);
1922                         if (values.contains(ariaRelevantText))
1923                             liveRegionRelevant-&gt;addItem(ariaRelevantText);
1924                     }
1925                 }
1926 
1927                 String ariaLive = axObject-&gt;liveRegionStatus();
1928                 if (ariaLive == &quot;assertive&quot;)
1929                     liveRegionStatus = Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Assertive;
1930                 else if (ariaLive == &quot;polite&quot;)
1931                     liveRegionStatus = Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Polite;
1932             }
1933 
1934             if (is&lt;AccessibilityNodeObject&gt;(*axObject))
1935                 mouseEventNode = downcast&lt;AccessibilityNodeObject&gt;(*axObject).mouseButtonListener(MouseButtonListenerResultFilter::IncludeBodyElement);
1936 
1937             if (axObject-&gt;supportsARIAOwns()) {
1938                 Vector&lt;Element*&gt; ownedElements;
1939                 axObject-&gt;elementsFromAttribute(ownedElements, aria_ownsAttr);
1940                 if (ownedElements.size()) {
1941                     ownedNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1942                     for (Element* ownedElement : ownedElements)
1943                         ownedNodeIds-&gt;addItem(pushNodePathToFrontend(ownedElement));
1944                 }
1945             }
1946 
1947             if (AccessibilityObject* parentObject = axObject-&gt;parentObjectUnignored())
1948                 parentNode = parentObject-&gt;node();
1949 
1950             supportsPressed = axObject-&gt;pressedIsPresent();
1951             if (supportsPressed)
1952                 pressed = axObject-&gt;isPressed();
1953 
1954             if (axObject-&gt;isTextControl())
1955                 readonly = !axObject-&gt;canSetValueAttribute();
1956 
1957             supportsRequired = axObject-&gt;supportsRequiredAttribute();
1958             if (supportsRequired)
1959                 required = axObject-&gt;isRequired();
1960 
1961             role = axObject-&gt;computedRoleString();
1962             selected = axObject-&gt;isSelected();
1963 
1964             AccessibilityObject::AccessibilityChildrenVector selectedChildren;
1965             axObject-&gt;selectedChildren(selectedChildren);
1966             if (selectedChildren.size()) {
1967                 selectedChildNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1968                 for (auto&amp; selectedChildObject : selectedChildren) {
1969                     if (Node* selectedChildNode = selectedChildObject-&gt;node())
1970                         selectedChildNodeIds-&gt;addItem(pushNodePathToFrontend(selectedChildNode));
1971                 }
1972             }
1973 
1974             headingLevel = axObject-&gt;headingLevel();
1975             hierarchicalLevel = axObject-&gt;hierarchicalLevel();
1976 
1977             level = hierarchicalLevel ? hierarchicalLevel : headingLevel;
1978             isPopupButton = axObject-&gt;isPopUpButton() || axObject-&gt;hasPopup();
1979         }
1980     }
1981 
1982     Ref&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt; value = Inspector::Protocol::DOM::AccessibilityProperties::create()
1983         .setExists(exists)
1984         .setLabel(label)
1985         .setRole(role)
1986         .setNodeId(pushNodePathToFrontend(node))
1987         .release();
1988 
1989     if (exists) {
1990         if (activeDescendantNode)
1991             value-&gt;setActiveDescendantNodeId(pushNodePathToFrontend(activeDescendantNode));
1992         if (busy)
1993             value-&gt;setBusy(busy);
1994         if (supportsChecked)
1995             value-&gt;setChecked(checked);
1996         if (childNodeIds)
1997             value-&gt;setChildNodeIds(childNodeIds);
1998         if (controlledNodeIds)
1999             value-&gt;setControlledNodeIds(controlledNodeIds);
2000         if (currentState != Inspector::Protocol::DOM::AccessibilityProperties::Current::False)
2001             value-&gt;setCurrent(currentState);
2002         if (disabled)
2003             value-&gt;setDisabled(disabled);
2004         if (supportsExpanded)
2005             value-&gt;setExpanded(expanded);
2006         if (flowedNodeIds)
2007             value-&gt;setFlowedNodeIds(flowedNodeIds);
2008         if (supportsFocused)
2009             value-&gt;setFocused(focused);
2010         if (ignored)
2011             value-&gt;setIgnored(ignored);
2012         if (ignoredByDefault)
2013             value-&gt;setIgnoredByDefault(ignoredByDefault);
2014         if (invalid != Inspector::Protocol::DOM::AccessibilityProperties::Invalid::False)
2015             value-&gt;setInvalid(invalid);
2016         if (hidden)
2017             value-&gt;setHidden(hidden);
2018         if (supportsLiveRegion) {
2019             value-&gt;setLiveRegionAtomic(liveRegionAtomic);
2020             if (liveRegionRelevant-&gt;length())
2021                 value-&gt;setLiveRegionRelevant(liveRegionRelevant);
2022             value-&gt;setLiveRegionStatus(liveRegionStatus);
2023         }
2024         if (mouseEventNode)
2025             value-&gt;setMouseEventNodeId(pushNodePathToFrontend(mouseEventNode));
2026         if (ownedNodeIds)
2027             value-&gt;setOwnedNodeIds(ownedNodeIds);
2028         if (parentNode)
2029             value-&gt;setParentNodeId(pushNodePathToFrontend(parentNode));
2030         if (supportsPressed)
2031             value-&gt;setPressed(pressed);
2032         if (readonly)
2033             value-&gt;setReadonly(readonly);
2034         if (supportsRequired)
2035             value-&gt;setRequired(required);
2036         if (selected)
2037             value-&gt;setSelected(selected);
2038         if (selectedChildNodeIds)
2039             value-&gt;setSelectedChildNodeIds(selectedChildNodeIds);
2040 
2041         // H1 -- H6 always have a headingLevel property that can be complimented by a hierarchicalLevel
2042         // property when aria-level is set on the element, in which case we want to remain calling
2043         // this value the &quot;Heading Level&quot; in the inspector.
2044         // Also, we do not want it to say Hierarchy Level: 0
2045         if (headingLevel)
2046             value-&gt;setHeadingLevel(level);
2047         else if (level)
2048             value-&gt;setHierarchyLevel(level);
2049         if (isPopupButton)
2050             value-&gt;setIsPopUpButton(isPopupButton);
2051     }
2052 
2053     return WTFMove(value);
2054 }
2055 
2056 static bool containsOnlyHTMLWhitespace(Node* node)
2057 {
2058     // FIXME: Respect ignoreWhitespace setting from inspector front end?
2059     return is&lt;Text&gt;(node) &amp;&amp; downcast&lt;Text&gt;(*node).data().isAllSpecialCharacters&lt;isHTMLSpace&gt;();
2060 }
2061 
2062 Node* InspectorDOMAgent::innerFirstChild(Node* node)
2063 {
2064     node = node-&gt;firstChild();
2065     while (containsOnlyHTMLWhitespace(node))
2066         node = node-&gt;nextSibling();
2067     return node;
2068 }
2069 
2070 Node* InspectorDOMAgent::innerNextSibling(Node* node)
2071 {
2072     do {
2073         node = node-&gt;nextSibling();
2074     } while (containsOnlyHTMLWhitespace(node));
2075     return node;
2076 }
2077 
2078 Node* InspectorDOMAgent::innerPreviousSibling(Node* node)
2079 {
2080     do {
2081         node = node-&gt;previousSibling();
2082     } while (containsOnlyHTMLWhitespace(node));
2083     return node;
2084 }
2085 
2086 unsigned InspectorDOMAgent::innerChildNodeCount(Node* node)
2087 {
2088     unsigned count = 0;
2089     for (Node* child = innerFirstChild(node); child; child = innerNextSibling(child))
2090         ++count;
2091     return count;
2092 }
2093 
2094 Node* InspectorDOMAgent::innerParentNode(Node* node)
2095 {
2096     ASSERT(node);
2097     if (is&lt;Document&gt;(*node))
2098         return downcast&lt;Document&gt;(*node).ownerElement();
2099     if (is&lt;ShadowRoot&gt;(*node))
2100         return downcast&lt;ShadowRoot&gt;(*node).host();
2101     return node-&gt;parentNode();
2102 }
2103 
2104 void InspectorDOMAgent::didCommitLoad(Document* document)
2105 {
2106     RefPtr&lt;Element&gt; frameOwner = document-&gt;ownerElement();
2107     if (!frameOwner)
2108         return;
2109 
2110     int frameOwnerId = m_documentNodeToIdMap.get(frameOwner);
2111     if (!frameOwnerId)
2112         return;
2113 
2114     // Re-add frame owner element together with its new children.
2115     int parentId = m_documentNodeToIdMap.get(innerParentNode(frameOwner.get()));
2116     m_frontendDispatcher-&gt;childNodeRemoved(parentId, frameOwnerId);
2117     unbind(frameOwner.get(), &amp;m_documentNodeToIdMap);
2118 
2119     Ref&lt;Inspector::Protocol::DOM::Node&gt; value = buildObjectForNode(frameOwner.get(), 0, &amp;m_documentNodeToIdMap);
2120     Node* previousSibling = innerPreviousSibling(frameOwner.get());
2121     int prevId = previousSibling ? m_documentNodeToIdMap.get(previousSibling) : 0;
2122     m_frontendDispatcher-&gt;childNodeInserted(parentId, prevId, WTFMove(value));
2123 }
2124 
2125 int InspectorDOMAgent::identifierForNode(Node&amp; node)
2126 {
2127     return pushNodePathToFrontend(&amp;node);
2128 }
2129 
2130 void InspectorDOMAgent::addEventListenersToNode(Node&amp; node)
2131 {
2132 #if ENABLE(VIDEO)
2133     auto callback = EventFiredCallback::create(*this);
2134 
2135     auto createEventListener = [&amp;] (const AtomicString&amp; eventName) {
2136         node.addEventListener(eventName, callback.copyRef(), false);
2137     };
2138 
2139 #if ENABLE(FULLSCREEN_API)
2140     if (is&lt;Document&gt;(node) || is&lt;HTMLMediaElement&gt;(node))
2141         createEventListener(eventNames().webkitfullscreenchangeEvent);
2142 #endif // ENABLE(FULLSCREEN_API)
2143 
2144     if (is&lt;HTMLMediaElement&gt;(node)) {
2145         createEventListener(eventNames().abortEvent);
2146         createEventListener(eventNames().canplayEvent);
2147         createEventListener(eventNames().canplaythroughEvent);
2148         createEventListener(eventNames().emptiedEvent);
2149         createEventListener(eventNames().endedEvent);
2150         createEventListener(eventNames().loadeddataEvent);
2151         createEventListener(eventNames().loadedmetadataEvent);
2152         createEventListener(eventNames().loadstartEvent);
2153         createEventListener(eventNames().pauseEvent);
2154         createEventListener(eventNames().playEvent);
2155         createEventListener(eventNames().playingEvent);
2156         createEventListener(eventNames().seekedEvent);
2157         createEventListener(eventNames().seekingEvent);
2158         createEventListener(eventNames().stalledEvent);
2159         createEventListener(eventNames().suspendEvent);
2160         createEventListener(eventNames().waitingEvent);
2161 
2162         if (!m_mediaMetricsTimer.isActive())
2163             m_mediaMetricsTimer.start(0_s, 1_s / 15.);
2164     }
2165 #else
2166     UNUSED_PARAM(node);
2167 #endif // ENABLE(VIDEO)
2168 }
2169 
2170 void InspectorDOMAgent::didInsertDOMNode(Node&amp; node)
2171 {
2172     if (containsOnlyHTMLWhitespace(&amp;node))
2173         return;
2174 
2175     // We could be attaching existing subtree. Forget the bindings.
2176     unbind(&amp;node, &amp;m_documentNodeToIdMap);
2177 
2178     ContainerNode* parent = node.parentNode();
2179     if (!parent)
2180         return;
2181 
2182     int parentId = m_documentNodeToIdMap.get(parent);
2183     // Return if parent is not mapped yet.
2184     if (!parentId)
2185         return;
2186 
2187     if (!m_childrenRequested.contains(parentId)) {
2188         // No children are mapped yet -&gt; only notify on changes of hasChildren.
2189         m_frontendDispatcher-&gt;childNodeCountUpdated(parentId, innerChildNodeCount(parent));
2190     } else {
2191         // Children have been requested -&gt; return value of a new child.
2192         Node* prevSibling = innerPreviousSibling(&amp;node);
2193         int prevId = prevSibling ? m_documentNodeToIdMap.get(prevSibling) : 0;
2194         Ref&lt;Inspector::Protocol::DOM::Node&gt; value = buildObjectForNode(&amp;node, 0, &amp;m_documentNodeToIdMap);
2195         m_frontendDispatcher-&gt;childNodeInserted(parentId, prevId, WTFMove(value));
2196     }
2197 }
2198 
2199 void InspectorDOMAgent::didRemoveDOMNode(Node&amp; node)
2200 {
2201     if (containsOnlyHTMLWhitespace(&amp;node))
2202         return;
2203 
2204     ContainerNode* parent = node.parentNode();
2205 
2206     // If parent is not mapped yet -&gt; ignore the event.
2207     if (!m_documentNodeToIdMap.contains(parent))
2208         return;
2209 
2210     int parentId = m_documentNodeToIdMap.get(parent);
2211 
2212     if (!m_childrenRequested.contains(parentId)) {
2213         // No children are mapped yet -&gt; only notify on changes of hasChildren.
2214         if (innerChildNodeCount(parent) == 1)
2215             m_frontendDispatcher-&gt;childNodeCountUpdated(parentId, 0);
2216     } else
2217         m_frontendDispatcher-&gt;childNodeRemoved(parentId, m_documentNodeToIdMap.get(&amp;node));
2218     unbind(&amp;node, &amp;m_documentNodeToIdMap);
2219 }
2220 
2221 void InspectorDOMAgent::willModifyDOMAttr(Element&amp;, const AtomicString&amp; oldValue, const AtomicString&amp; newValue)
2222 {
2223     m_suppressAttributeModifiedEvent = (oldValue == newValue);
2224 }
2225 
2226 void InspectorDOMAgent::didModifyDOMAttr(Element&amp; element, const AtomicString&amp; name, const AtomicString&amp; value)
2227 {
2228     bool shouldSuppressEvent = m_suppressAttributeModifiedEvent;
2229     m_suppressAttributeModifiedEvent = false;
2230     if (shouldSuppressEvent)
2231         return;
2232 
2233     int id = boundNodeId(&amp;element);
2234     // If node is not mapped yet -&gt; ignore the event.
2235     if (!id)
2236         return;
2237 
2238     if (m_domListener)
2239         m_domListener-&gt;didModifyDOMAttr(element);
2240 
2241     m_frontendDispatcher-&gt;attributeModified(id, name, value);
2242 }
2243 
2244 void InspectorDOMAgent::didRemoveDOMAttr(Element&amp; element, const AtomicString&amp; name)
2245 {
2246     int id = boundNodeId(&amp;element);
2247     // If node is not mapped yet -&gt; ignore the event.
2248     if (!id)
2249         return;
2250 
2251     if (m_domListener)
2252         m_domListener-&gt;didModifyDOMAttr(element);
2253 
2254     m_frontendDispatcher-&gt;attributeRemoved(id, name);
2255 }
2256 
2257 void InspectorDOMAgent::styleAttributeInvalidated(const Vector&lt;Element*&gt;&amp; elements)
2258 {
2259     auto nodeIds = JSON::ArrayOf&lt;int&gt;::create();
2260     for (auto&amp; element : elements) {
2261         int id = boundNodeId(element);
2262         // If node is not mapped yet -&gt; ignore the event.
2263         if (!id)
2264             continue;
2265 
2266         if (m_domListener)
2267             m_domListener-&gt;didModifyDOMAttr(*element);
2268         nodeIds-&gt;addItem(id);
2269     }
2270     m_frontendDispatcher-&gt;inlineStyleInvalidated(WTFMove(nodeIds));
2271 }
2272 
2273 void InspectorDOMAgent::characterDataModified(CharacterData&amp; characterData)
2274 {
2275     int id = m_documentNodeToIdMap.get(&amp;characterData);
2276     if (!id) {
2277         // Push text node if it is being created.
2278         didInsertDOMNode(characterData);
2279         return;
2280     }
2281     m_frontendDispatcher-&gt;characterDataModified(id, characterData.data());
2282 }
2283 
2284 void InspectorDOMAgent::didInvalidateStyleAttr(Node&amp; node)
2285 {
2286     int id = m_documentNodeToIdMap.get(&amp;node);
2287     // If node is not mapped yet -&gt; ignore the event.
2288     if (!id)
2289         return;
2290 
2291     if (!m_revalidateStyleAttrTask)
2292         m_revalidateStyleAttrTask = std::make_unique&lt;RevalidateStyleAttributeTask&gt;(this);
2293     m_revalidateStyleAttrTask-&gt;scheduleFor(downcast&lt;Element&gt;(&amp;node));
2294 }
2295 
2296 void InspectorDOMAgent::didPushShadowRoot(Element&amp; host, ShadowRoot&amp; root)
2297 {
2298     int hostId = m_documentNodeToIdMap.get(&amp;host);
2299     if (hostId)
2300         m_frontendDispatcher-&gt;shadowRootPushed(hostId, buildObjectForNode(&amp;root, 0, &amp;m_documentNodeToIdMap));
2301 }
2302 
2303 void InspectorDOMAgent::willPopShadowRoot(Element&amp; host, ShadowRoot&amp; root)
2304 {
2305     int hostId = m_documentNodeToIdMap.get(&amp;host);
2306     int rootId = m_documentNodeToIdMap.get(&amp;root);
2307     if (hostId &amp;&amp; rootId)
2308         m_frontendDispatcher-&gt;shadowRootPopped(hostId, rootId);
2309 }
2310 
2311 void InspectorDOMAgent::didChangeCustomElementState(Element&amp; element)
2312 {
2313     int elementId = m_documentNodeToIdMap.get(&amp;element);
2314     if (!elementId)
2315         return;
2316 
2317     m_frontendDispatcher-&gt;customElementStateChanged(elementId, customElementState(element));
2318 }
2319 
2320 void InspectorDOMAgent::frameDocumentUpdated(Frame&amp; frame)
2321 {
2322     Document* document = frame.document();
2323     if (!document)
2324         return;
2325 
2326     if (!frame.isMainFrame())
2327         return;
2328 
2329     // Only update the main frame document, nested frame document updates are not required
2330     // (will be handled by didCommitLoad()).
2331     setDocument(document);
2332 }
2333 
2334 void InspectorDOMAgent::pseudoElementCreated(PseudoElement&amp; pseudoElement)
2335 {
2336     Element* parent = pseudoElement.hostElement();
2337     if (!parent)
2338         return;
2339 
2340     int parentId = m_documentNodeToIdMap.get(parent);
2341     if (!parentId)
2342         return;
2343 
2344     pushChildNodesToFrontend(parentId, 1);
2345     m_frontendDispatcher-&gt;pseudoElementAdded(parentId, buildObjectForNode(&amp;pseudoElement, 0, &amp;m_documentNodeToIdMap));
2346 }
2347 
2348 void InspectorDOMAgent::pseudoElementDestroyed(PseudoElement&amp; pseudoElement)
2349 {
2350     int pseudoElementId = m_documentNodeToIdMap.get(&amp;pseudoElement);
2351     if (!pseudoElementId)
2352         return;
2353 
2354     // If a PseudoElement is bound, its parent element must have been bound.
2355     Element* parent = pseudoElement.hostElement();
2356     ASSERT(parent);
2357     int parentId = m_documentNodeToIdMap.get(parent);
2358     ASSERT(parentId);
2359 
2360     unbind(&amp;pseudoElement, &amp;m_documentNodeToIdMap);
2361     m_frontendDispatcher-&gt;pseudoElementRemoved(parentId, pseudoElementId);
2362 }
2363 
2364 void InspectorDOMAgent::didAddEventListener(EventTarget&amp; target)
2365 {
2366     if (!is&lt;Node&gt;(target))
2367         return;
2368 
2369     int nodeId = boundNodeId(&amp;downcast&lt;Node&gt;(target));
2370     if (!nodeId)
2371         return;
2372 
2373     m_frontendDispatcher-&gt;didAddEventListener(nodeId);
2374 }
2375 
2376 void InspectorDOMAgent::willRemoveEventListener(EventTarget&amp; target, const AtomicString&amp; eventType, EventListener&amp; listener, bool capture)
2377 {
2378     if (!is&lt;Node&gt;(target))
2379         return;
2380     auto&amp; node = downcast&lt;Node&gt;(target);
2381 
2382     int nodeId = boundNodeId(&amp;node);
2383     if (!nodeId)
2384         return;
2385 
2386     bool listenerExists = false;
2387     for (auto&amp; item : node.eventListeners(eventType)) {
2388         if (item-&gt;callback() == listener &amp;&amp; item-&gt;useCapture() == capture) {
2389             listenerExists = true;
2390             break;
2391         }
2392     }
2393 
2394     if (!listenerExists)
2395         return;
2396 
2397     m_eventListenerEntries.removeIf([&amp;] (auto&amp; entry) {
2398         return entry.value.matches(target, eventType, listener, capture);
2399     });
2400 
2401     m_frontendDispatcher-&gt;willRemoveEventListener(nodeId);
2402 }
2403 
2404 bool InspectorDOMAgent::isEventListenerDisabled(EventTarget&amp; target, const AtomicString&amp; eventType, EventListener&amp; listener, bool capture)
2405 {
2406     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2407         if (inspectorEventListener.matches(target, eventType, listener, capture))
2408             return inspectorEventListener.disabled;
2409     }
2410     return false;
2411 }
2412 
2413 void InspectorDOMAgent::eventDidResetAfterDispatch(const Event&amp; event)
2414 {
2415     m_dispatchedEvents.remove(&amp;event);
2416 }
2417 
2418 bool InspectorDOMAgent::hasBreakpointForEventListener(EventTarget&amp; target, const AtomicString&amp; eventType, EventListener&amp; listener, bool capture)
2419 {
2420     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2421         if (inspectorEventListener.matches(target, eventType, listener, capture))
2422             return inspectorEventListener.hasBreakpoint;
2423     }
2424     return false;
2425 }
2426 
2427 int InspectorDOMAgent::idForEventListener(EventTarget&amp; target, const AtomicString&amp; eventType, EventListener&amp; listener, bool capture)
2428 {
2429     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2430         if (inspectorEventListener.matches(target, eventType, listener, capture))
2431             return inspectorEventListener.identifier;
2432     }
2433     return 0;
2434 }
2435 
2436 #if ENABLE(VIDEO)
2437 void InspectorDOMAgent::mediaMetricsTimerFired()
2438 {
2439     // FIXME: remove metrics information for any media element when it&#39;s destroyed
2440 
2441     if (HTMLMediaElement::allMediaElements().isEmpty()) {
2442         if (m_mediaMetricsTimer.isActive())
2443             m_mediaMetricsTimer.stop();
2444         m_mediaMetrics.clear();
2445         return;
2446     }
2447 
2448     for (auto* mediaElement : HTMLMediaElement::allMediaElements()) {
2449         if (!is&lt;HTMLVideoElement&gt;(mediaElement) || !mediaElement-&gt;isPlaying())
2450             continue;
2451 
2452         auto videoPlaybackQuality = mediaElement-&gt;getVideoPlaybackQuality();
2453         unsigned displayCompositedVideoFrames = videoPlaybackQuality-&gt;displayCompositedVideoFrames();
2454 
2455         auto iterator = m_mediaMetrics.find(mediaElement);
2456         if (iterator == m_mediaMetrics.end()) {
2457             m_mediaMetrics.set(mediaElement, MediaMetrics(displayCompositedVideoFrames));
2458             continue;
2459         }
2460 
2461         bool isLowPower = (displayCompositedVideoFrames - iterator-&gt;value.displayCompositedFrames) &gt; 0;
2462         if (iterator-&gt;value.isLowPower != isLowPower) {
2463             iterator-&gt;value.isLowPower = isLowPower;
2464 
2465             int nodeId = pushNodePathToFrontend(mediaElement);
2466             if (nodeId) {
2467                 auto timestamp = m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
2468                 m_frontendDispatcher-&gt;videoLowPowerChanged(nodeId, timestamp, iterator-&gt;value.isLowPower);
2469             }
2470         }
2471 
2472         iterator-&gt;value.displayCompositedFrames = displayCompositedVideoFrames;
2473     }
2474 
2475     m_mediaMetrics.removeIf([&amp;] (auto&amp; entry) {
2476         return !HTMLMediaElement::allMediaElements().contains(entry.key);
2477     });
2478 }
2479 #endif
2480 
2481 Node* InspectorDOMAgent::nodeForPath(const String&amp; path)
2482 {
2483     // The path is of form &quot;1,HTML,2,BODY,1,DIV&quot;
2484     if (!m_document)
2485         return nullptr;
2486 
2487     Node* node = m_document.get();
2488     Vector&lt;String&gt; pathTokens = path.split(&#39;,&#39;);
2489     if (!pathTokens.size())
2490         return nullptr;
2491 
2492     for (size_t i = 0; i &lt; pathTokens.size() - 1; i += 2) {
2493         bool success = true;
2494         unsigned childNumber = pathTokens[i].toUInt(&amp;success);
2495         if (!success)
2496             return nullptr;
2497 
2498         Node* child;
2499         if (is&lt;HTMLFrameOwnerElement&gt;(*node)) {
2500             ASSERT(!childNumber);
2501             auto&amp; frameOwner = downcast&lt;HTMLFrameOwnerElement&gt;(*node);
2502             child = frameOwner.contentDocument();
2503         } else {
2504             if (childNumber &gt;= innerChildNodeCount(node))
2505                 return nullptr;
2506 
2507             child = innerFirstChild(node);
2508             for (size_t j = 0; child &amp;&amp; j &lt; childNumber; ++j)
2509                 child = innerNextSibling(child);
2510         }
2511 
2512         const auto&amp; childName = pathTokens[i + 1];
2513         if (!child || child-&gt;nodeName() != childName)
2514             return nullptr;
2515         node = child;
2516     }
2517     return node;
2518 }
2519 
2520 Node* InspectorDOMAgent::nodeForObjectId(const String&amp; objectId)
2521 {
2522     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
2523     if (injectedScript.hasNoValue())
2524         return nullptr;
2525 
2526     return scriptValueAsNode(injectedScript.findObjectById(objectId));
2527 }
2528 
2529 void InspectorDOMAgent::pushNodeByPathToFrontend(ErrorString&amp; errorString, const String&amp; path, int* nodeId)
2530 {
2531     if (Node* node = nodeForPath(path))
2532         *nodeId = pushNodePathToFrontend(node);
2533     else
2534         errorString = &quot;No node with given path found&quot;_s;
2535 }
2536 
2537 RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; InspectorDOMAgent::resolveNode(Node* node, const String&amp; objectGroup)
2538 {
2539     auto* frame = node-&gt;document().frame();
2540     if (!frame)
2541         return nullptr;
2542 
2543     auto&amp; state = *mainWorldExecState(frame);
2544     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
2545     if (injectedScript.hasNoValue())
2546         return nullptr;
2547 
2548     return injectedScript.wrapObject(nodeAsScriptValue(state, node), objectGroup);
2549 }
2550 
2551 Node* InspectorDOMAgent::scriptValueAsNode(JSC::JSValue value)
2552 {
2553     if (!value || !value.isObject())
2554         return nullptr;
2555     return JSNode::toWrapped(*value.getObject()-&gt;vm(), value.getObject());
2556 }
2557 
2558 JSC::JSValue InspectorDOMAgent::nodeAsScriptValue(JSC::ExecState&amp; state, Node* node)
2559 {
2560     JSC::JSLockHolder lock(&amp;state);
2561     return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), BindingSecurity::checkSecurityForNode(state, node));
2562 }
2563 
2564 } // namespace WebCore
    </pre>
  </body>
</html>