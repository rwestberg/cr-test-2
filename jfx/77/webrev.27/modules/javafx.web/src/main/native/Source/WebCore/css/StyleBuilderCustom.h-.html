<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/css/StyleBuilderCustom.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2013 Google Inc. All rights reserved.
   3  * Copyright (C) 2014-2017 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  24  * THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #include &quot;CSSAspectRatioValue.h&quot;
  30 #include &quot;CSSCursorImageValue.h&quot;
  31 #include &quot;CSSFontFamily.h&quot;
  32 #include &quot;CSSFontValue.h&quot;
  33 #include &quot;CSSGradientValue.h&quot;
  34 #include &quot;CSSGridTemplateAreasValue.h&quot;
  35 #include &quot;CSSRegisteredCustomProperty.h&quot;
  36 #include &quot;CSSShadowValue.h&quot;
  37 #include &quot;Counter.h&quot;
  38 #include &quot;CounterContent.h&quot;
  39 #include &quot;CursorList.h&quot;
  40 #include &quot;DashboardRegion.h&quot;
  41 #include &quot;ElementAncestorIterator.h&quot;
  42 #include &quot;FontVariantBuilder.h&quot;
  43 #include &quot;Frame.h&quot;
  44 #include &quot;HTMLElement.h&quot;
  45 #include &quot;Rect.h&quot;
  46 #include &quot;SVGElement.h&quot;
  47 #include &quot;SVGRenderStyle.h&quot;
  48 #include &quot;StyleBuilderConverter.h&quot;
  49 #include &quot;StyleCachedImage.h&quot;
  50 #include &quot;StyleFontSizeFunctions.h&quot;
  51 #include &quot;StyleGeneratedImage.h&quot;
  52 #include &quot;StyleResolver.h&quot;
  53 #include &quot;WillChangeData.h&quot;
  54 
  55 namespace WebCore {
  56 
  57 #define DECLARE_PROPERTY_CUSTOM_HANDLERS(property) \
  58     static void applyInherit##property(StyleResolver&amp;); \
  59     static void applyInitial##property(StyleResolver&amp;); \
  60     static void applyValue##property(StyleResolver&amp;, CSSValue&amp;)
  61 
  62 template&lt;typename T&gt; inline T forwardInheritedValue(T&amp;&amp; value) { return std::forward&lt;T&gt;(value); }
  63 inline Length forwardInheritedValue(const Length&amp; value) { auto copy = value; return copy; }
  64 inline LengthSize forwardInheritedValue(const LengthSize&amp; value) { auto copy = value; return copy; }
  65 inline LengthBox forwardInheritedValue(const LengthBox&amp; value) { auto copy = value; return copy; }
  66 inline GapLength forwardInheritedValue(const GapLength&amp; value) { auto copy = value; return copy; }
  67 
  68 // Note that we assume the CSS parser only allows valid CSSValue types.
  69 class StyleBuilderCustom {
  70 public:
  71     // Custom handling of inherit, initial and value setting.
  72     DECLARE_PROPERTY_CUSTOM_HANDLERS(BorderImageOutset);
  73     DECLARE_PROPERTY_CUSTOM_HANDLERS(BorderImageRepeat);
  74     DECLARE_PROPERTY_CUSTOM_HANDLERS(BorderImageSlice);
  75     DECLARE_PROPERTY_CUSTOM_HANDLERS(BorderImageWidth);
  76     DECLARE_PROPERTY_CUSTOM_HANDLERS(BoxShadow);
  77     DECLARE_PROPERTY_CUSTOM_HANDLERS(Clip);
  78     DECLARE_PROPERTY_CUSTOM_HANDLERS(Content);
  79     DECLARE_PROPERTY_CUSTOM_HANDLERS(CounterIncrement);
  80     DECLARE_PROPERTY_CUSTOM_HANDLERS(CounterReset);
  81     DECLARE_PROPERTY_CUSTOM_HANDLERS(Cursor);
  82     DECLARE_PROPERTY_CUSTOM_HANDLERS(Fill);
  83     DECLARE_PROPERTY_CUSTOM_HANDLERS(FontFamily);
  84     DECLARE_PROPERTY_CUSTOM_HANDLERS(FontSize);
  85     DECLARE_PROPERTY_CUSTOM_HANDLERS(FontStyle);
  86 #if ENABLE(CSS_IMAGE_RESOLUTION)
  87     DECLARE_PROPERTY_CUSTOM_HANDLERS(ImageResolution);
  88 #endif
  89 #if ENABLE(TEXT_AUTOSIZING)
  90     DECLARE_PROPERTY_CUSTOM_HANDLERS(LineHeight);
  91 #endif
  92     DECLARE_PROPERTY_CUSTOM_HANDLERS(OutlineStyle);
  93     DECLARE_PROPERTY_CUSTOM_HANDLERS(Size);
  94     DECLARE_PROPERTY_CUSTOM_HANDLERS(Stroke);
  95     DECLARE_PROPERTY_CUSTOM_HANDLERS(TextIndent);
  96     DECLARE_PROPERTY_CUSTOM_HANDLERS(TextShadow);
  97     DECLARE_PROPERTY_CUSTOM_HANDLERS(WebkitAspectRatio);
  98     DECLARE_PROPERTY_CUSTOM_HANDLERS(WebkitBoxShadow);
  99     DECLARE_PROPERTY_CUSTOM_HANDLERS(FontVariantLigatures);
 100     DECLARE_PROPERTY_CUSTOM_HANDLERS(FontVariantNumeric);
 101     DECLARE_PROPERTY_CUSTOM_HANDLERS(FontVariantEastAsian);
 102     DECLARE_PROPERTY_CUSTOM_HANDLERS(GridTemplateAreas);
 103     DECLARE_PROPERTY_CUSTOM_HANDLERS(GridTemplateColumns);
 104     DECLARE_PROPERTY_CUSTOM_HANDLERS(GridTemplateRows);
 105     DECLARE_PROPERTY_CUSTOM_HANDLERS(WebkitMaskBoxImageOutset);
 106     DECLARE_PROPERTY_CUSTOM_HANDLERS(WebkitMaskBoxImageRepeat);
 107     DECLARE_PROPERTY_CUSTOM_HANDLERS(WebkitMaskBoxImageSlice);
 108     DECLARE_PROPERTY_CUSTOM_HANDLERS(WebkitMaskBoxImageWidth);
 109     DECLARE_PROPERTY_CUSTOM_HANDLERS(WebkitTextEmphasisStyle);
 110     DECLARE_PROPERTY_CUSTOM_HANDLERS(Zoom);
 111 
 112     // Custom handling of initial + inherit value setting only.
 113     static void applyInitialWebkitMaskImage(StyleResolver&amp;) { }
 114     static void applyInheritWebkitMaskImage(StyleResolver&amp;) { }
 115     static void applyInitialFontFeatureSettings(StyleResolver&amp;) { }
 116     static void applyInheritFontFeatureSettings(StyleResolver&amp;) { }
 117 #if ENABLE(VARIATION_FONTS)
 118     static void applyInitialFontVariationSettings(StyleResolver&amp;) { }
 119     static void applyInheritFontVariationSettings(StyleResolver&amp;) { }
 120 #endif
 121 
 122     // Custom handling of inherit + value setting only.
 123     static void applyInheritDisplay(StyleResolver&amp;);
 124     static void applyValueDisplay(StyleResolver&amp;, CSSValue&amp;);
 125 
 126     // Custom handling of value setting only.
 127     static void applyValueBaselineShift(StyleResolver&amp;, CSSValue&amp;);
 128     static void applyValueDirection(StyleResolver&amp;, CSSValue&amp;);
 129     static void applyValueVerticalAlign(StyleResolver&amp;, CSSValue&amp;);
 130     static void applyInitialTextAlign(StyleResolver&amp;);
 131     static void applyValueTextAlign(StyleResolver&amp;, CSSValue&amp;);
 132 #if ENABLE(DASHBOARD_SUPPORT)
 133     static void applyValueWebkitDashboardRegion(StyleResolver&amp;, CSSValue&amp;);
 134 #endif
 135     static void applyValueWebkitLocale(StyleResolver&amp;, CSSValue&amp;);
 136     static void applyValueWebkitTextOrientation(StyleResolver&amp;, CSSValue&amp;);
 137 #if ENABLE(TEXT_AUTOSIZING)
 138     static void applyValueWebkitTextSizeAdjust(StyleResolver&amp;, CSSValue&amp;);
 139 #endif
 140     static void applyValueWebkitTextZoom(StyleResolver&amp;, CSSValue&amp;);
 141     static void applyValueWritingMode(StyleResolver&amp;, CSSValue&amp;);
 142     static void applyValueAlt(StyleResolver&amp;, CSSValue&amp;);
 143     static void applyValueWillChange(StyleResolver&amp;, CSSValue&amp;);
 144 
 145 #if ENABLE(DARK_MODE_CSS)
 146     static void applyValueSupportedColorSchemes(StyleResolver&amp;, CSSValue&amp;);
 147 #endif
 148 
 149     static void applyValueStrokeWidth(StyleResolver&amp;, CSSValue&amp;);
 150     static void applyValueStrokeColor(StyleResolver&amp;, CSSValue&amp;);
 151 
 152     static void applyInitialCustomProperty(StyleResolver&amp;, const CSSRegisteredCustomProperty*, const AtomicString&amp; name);
 153     static void applyInheritCustomProperty(StyleResolver&amp;, const CSSRegisteredCustomProperty*, const AtomicString&amp; name);
 154     static void applyValueCustomProperty(StyleResolver&amp;, const CSSRegisteredCustomProperty*, CSSCustomPropertyValue&amp;);
 155 
 156 private:
 157     static void resetEffectiveZoom(StyleResolver&amp;);
 158 
 159     static Length mmLength(double mm);
 160     static Length inchLength(double inch);
 161     static bool getPageSizeFromName(CSSPrimitiveValue* pageSizeName, CSSPrimitiveValue* pageOrientation, Length&amp; width, Length&amp; height);
 162 
 163     template &lt;CSSPropertyID id&gt;
 164     static void applyTextOrBoxShadowValue(StyleResolver&amp;, CSSValue&amp;);
 165     static bool isValidDisplayValue(StyleResolver&amp;, DisplayType);
 166 
 167     enum CounterBehavior {Increment = 0, Reset};
 168     template &lt;CounterBehavior counterBehavior&gt;
 169     static void applyInheritCounter(StyleResolver&amp;);
 170     template &lt;CounterBehavior counterBehavior&gt;
 171     static void applyValueCounter(StyleResolver&amp;, CSSValue&amp;);
 172 
 173     static float largerFontSize(float size);
 174     static float smallerFontSize(float size);
 175     static float determineRubyTextSizeMultiplier(StyleResolver&amp;);
 176 };
 177 
 178 inline void StyleBuilderCustom::applyValueDirection(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 179 {
 180     styleResolver.style()-&gt;setDirection(downcast&lt;CSSPrimitiveValue&gt;(value));
 181     styleResolver.style()-&gt;setHasExplicitlySetDirection(true);
 182 }
 183 
 184 inline void StyleBuilderCustom::applyInitialTextAlign(StyleResolver&amp; styleResolver)
 185 {
 186     styleResolver.style()-&gt;setTextAlign(RenderStyle::initialTextAlign());
 187     styleResolver.style()-&gt;setHasExplicitlySetTextAlign(true);
 188 }
 189 
 190 inline void StyleBuilderCustom::applyValueTextAlign(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 191 {
 192     styleResolver.style()-&gt;setTextAlign(StyleBuilderConverter::convertTextAlign(styleResolver, value));
 193     styleResolver.style()-&gt;setHasExplicitlySetTextAlign(true);
 194 }
 195 
 196 inline void StyleBuilderCustom::resetEffectiveZoom(StyleResolver&amp; styleResolver)
 197 {
 198     // Reset the zoom in effect. This allows the setZoom method to accurately compute a new zoom in effect.
 199     styleResolver.setEffectiveZoom(styleResolver.parentStyle() ? styleResolver.parentStyle()-&gt;effectiveZoom() : RenderStyle::initialZoom());
 200 }
 201 
 202 inline void StyleBuilderCustom::applyInitialZoom(StyleResolver&amp; styleResolver)
 203 {
 204     resetEffectiveZoom(styleResolver);
 205     styleResolver.setZoom(RenderStyle::initialZoom());
 206 }
 207 
 208 inline void StyleBuilderCustom::applyInheritZoom(StyleResolver&amp; styleResolver)
 209 {
 210     resetEffectiveZoom(styleResolver);
 211     styleResolver.setZoom(styleResolver.parentStyle()-&gt;zoom());
 212 }
 213 
 214 inline void StyleBuilderCustom::applyValueZoom(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 215 {
 216     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 217 
 218     if (primitiveValue.valueID() == CSSValueNormal) {
 219         resetEffectiveZoom(styleResolver);
 220         styleResolver.setZoom(RenderStyle::initialZoom());
 221     } else if (primitiveValue.valueID() == CSSValueReset) {
 222         styleResolver.setEffectiveZoom(RenderStyle::initialZoom());
 223         styleResolver.setZoom(RenderStyle::initialZoom());
 224     } else if (primitiveValue.valueID() == CSSValueDocument) {
 225         float docZoom = styleResolver.rootElementStyle() ? styleResolver.rootElementStyle()-&gt;zoom() : RenderStyle::initialZoom();
 226         styleResolver.setEffectiveZoom(docZoom);
 227         styleResolver.setZoom(docZoom);
 228     } else if (primitiveValue.isPercentage()) {
 229         resetEffectiveZoom(styleResolver);
 230         if (float percent = primitiveValue.floatValue())
 231             styleResolver.setZoom(percent / 100.0f);
 232     } else if (primitiveValue.isNumber()) {
 233         resetEffectiveZoom(styleResolver);
 234         if (float number = primitiveValue.floatValue())
 235             styleResolver.setZoom(number);
 236     }
 237 }
 238 inline Length StyleBuilderCustom::mmLength(double mm)
 239 {
 240     Ref&lt;CSSPrimitiveValue&gt; value(CSSPrimitiveValue::create(mm, CSSPrimitiveValue::CSS_MM));
 241     return value.get().computeLength&lt;Length&gt;(CSSToLengthConversionData());
 242 }
 243 inline Length StyleBuilderCustom::inchLength(double inch)
 244 {
 245     Ref&lt;CSSPrimitiveValue&gt; value(CSSPrimitiveValue::create(inch, CSSPrimitiveValue::CSS_IN));
 246     return value.get().computeLength&lt;Length&gt;(CSSToLengthConversionData());
 247 }
 248 bool StyleBuilderCustom::getPageSizeFromName(CSSPrimitiveValue* pageSizeName, CSSPrimitiveValue* pageOrientation, Length&amp; width, Length&amp; height)
 249 {
 250     static NeverDestroyed&lt;Length&gt; a5Width(mmLength(148));
 251     static NeverDestroyed&lt;Length&gt; a5Height(mmLength(210));
 252     static NeverDestroyed&lt;Length&gt; a4Width(mmLength(210));
 253     static NeverDestroyed&lt;Length&gt; a4Height(mmLength(297));
 254     static NeverDestroyed&lt;Length&gt; a3Width(mmLength(297));
 255     static NeverDestroyed&lt;Length&gt; a3Height(mmLength(420));
 256     static NeverDestroyed&lt;Length&gt; b5Width(mmLength(176));
 257     static NeverDestroyed&lt;Length&gt; b5Height(mmLength(250));
 258     static NeverDestroyed&lt;Length&gt; b4Width(mmLength(250));
 259     static NeverDestroyed&lt;Length&gt; b4Height(mmLength(353));
 260     static NeverDestroyed&lt;Length&gt; letterWidth(inchLength(8.5));
 261     static NeverDestroyed&lt;Length&gt; letterHeight(inchLength(11));
 262     static NeverDestroyed&lt;Length&gt; legalWidth(inchLength(8.5));
 263     static NeverDestroyed&lt;Length&gt; legalHeight(inchLength(14));
 264     static NeverDestroyed&lt;Length&gt; ledgerWidth(inchLength(11));
 265     static NeverDestroyed&lt;Length&gt; ledgerHeight(inchLength(17));
 266 
 267     if (!pageSizeName)
 268         return false;
 269 
 270     switch (pageSizeName-&gt;valueID()) {
 271     case CSSValueA5:
 272         width = a5Width;
 273         height = a5Height;
 274         break;
 275     case CSSValueA4:
 276         width = a4Width;
 277         height = a4Height;
 278         break;
 279     case CSSValueA3:
 280         width = a3Width;
 281         height = a3Height;
 282         break;
 283     case CSSValueB5:
 284         width = b5Width;
 285         height = b5Height;
 286         break;
 287     case CSSValueB4:
 288         width = b4Width;
 289         height = b4Height;
 290         break;
 291     case CSSValueLetter:
 292         width = letterWidth;
 293         height = letterHeight;
 294         break;
 295     case CSSValueLegal:
 296         width = legalWidth;
 297         height = legalHeight;
 298         break;
 299     case CSSValueLedger:
 300         width = ledgerWidth;
 301         height = ledgerHeight;
 302         break;
 303     default:
 304         return false;
 305     }
 306 
 307     if (pageOrientation) {
 308         switch (pageOrientation-&gt;valueID()) {
 309         case CSSValueLandscape:
 310             std::swap(width, height);
 311             break;
 312         case CSSValuePortrait:
 313             // Nothing to do.
 314             break;
 315         default:
 316             return false;
 317         }
 318     }
 319     return true;
 320 }
 321 
 322 inline void StyleBuilderCustom::applyValueVerticalAlign(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 323 {
 324     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 325     if (primitiveValue.valueID())
 326         styleResolver.style()-&gt;setVerticalAlign(primitiveValue);
 327     else
 328         styleResolver.style()-&gt;setVerticalAlignLength(primitiveValue.convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion&gt;(styleResolver.state().cssToLengthConversionData()));
 329 }
 330 
 331 #if ENABLE(DASHBOARD_SUPPORT)
 332 
 333 static Length convertToIntLength(const CSSPrimitiveValue* primitiveValue, const CSSToLengthConversionData&amp; conversionData)
 334 {
 335     return primitiveValue ? primitiveValue-&gt;convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion&gt;(conversionData) : Length(Undefined);
 336 }
 337 
 338 inline void StyleBuilderCustom::applyValueWebkitDashboardRegion(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 339 {
 340     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 341     if (primitiveValue.valueID() == CSSValueNone) {
 342         styleResolver.style()-&gt;setDashboardRegions(RenderStyle::noneDashboardRegions());
 343         return;
 344     }
 345 
 346     auto* region = primitiveValue.dashboardRegionValue();
 347     if (!region)
 348         return;
 349 
 350     auto* first = region;
 351     while (region) {
 352         Length top = convertToIntLength(region-&gt;top(), styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f));
 353         Length right = convertToIntLength(region-&gt;right(), styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f));
 354         Length bottom = convertToIntLength(region-&gt;bottom(), styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f));
 355         Length left = convertToIntLength(region-&gt;left(), styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f));
 356 
 357         if (top.isUndefined())
 358             top = Length();
 359         if (right.isUndefined())
 360             right = Length();
 361         if (bottom.isUndefined())
 362             bottom = Length();
 363         if (left.isUndefined())
 364             left = Length();
 365 
 366         if (region-&gt;m_isCircle)
 367             styleResolver.style()-&gt;setDashboardRegion(StyleDashboardRegion::Circle, region-&gt;m_label, WTFMove(top), WTFMove(right), WTFMove(bottom), WTFMove(left), region != first);
 368         else if (region-&gt;m_isRectangle)
 369             styleResolver.style()-&gt;setDashboardRegion(StyleDashboardRegion::Rectangle, region-&gt;m_label, WTFMove(top), WTFMove(right), WTFMove(bottom), WTFMove(left), region != first);
 370 
 371         region = region-&gt;m_next.get();
 372     }
 373 
 374     styleResolver.document().setHasAnnotatedRegions(true);
 375 }
 376 
 377 #endif // ENABLE(DASHBOARD_SUPPORT)
 378 
 379 #if ENABLE(CSS_IMAGE_RESOLUTION)
 380 
 381 inline void StyleBuilderCustom::applyInheritImageResolution(StyleResolver&amp; styleResolver)
 382 {
 383     styleResolver.style()-&gt;setImageResolutionSource(styleResolver.parentStyle()-&gt;imageResolutionSource());
 384     styleResolver.style()-&gt;setImageResolutionSnap(styleResolver.parentStyle()-&gt;imageResolutionSnap());
 385     styleResolver.style()-&gt;setImageResolution(styleResolver.parentStyle()-&gt;imageResolution());
 386 }
 387 
 388 inline void StyleBuilderCustom::applyInitialImageResolution(StyleResolver&amp; styleResolver)
 389 {
 390     styleResolver.style()-&gt;setImageResolutionSource(RenderStyle::initialImageResolutionSource());
 391     styleResolver.style()-&gt;setImageResolutionSnap(RenderStyle::initialImageResolutionSnap());
 392     styleResolver.style()-&gt;setImageResolution(RenderStyle::initialImageResolution());
 393 }
 394 
 395 inline void StyleBuilderCustom::applyValueImageResolution(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 396 {
 397     ImageResolutionSource source = RenderStyle::initialImageResolutionSource();
 398     ImageResolutionSnap snap = RenderStyle::initialImageResolutionSnap();
 399     double resolution = RenderStyle::initialImageResolution();
 400     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
 401         CSSPrimitiveValue&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(item.get());
 402         if (primitiveValue.valueID() == CSSValueFromImage)
 403             source = ImageResolutionSource::FromImage;
 404         else if (primitiveValue.valueID() == CSSValueSnap)
 405             snap = ImageResolutionSnap::Pixels;
 406         else
 407             resolution = primitiveValue.doubleValue(CSSPrimitiveValue::CSS_DPPX);
 408     }
 409     styleResolver.style()-&gt;setImageResolutionSource(source);
 410     styleResolver.style()-&gt;setImageResolutionSnap(snap);
 411     styleResolver.style()-&gt;setImageResolution(resolution);
 412 }
 413 
 414 #endif // ENABLE(CSS_IMAGE_RESOLUTION)
 415 
 416 inline void StyleBuilderCustom::applyInheritSize(StyleResolver&amp;) { }
 417 
 418 inline void StyleBuilderCustom::applyInitialSize(StyleResolver&amp;) { }
 419 
 420 inline void StyleBuilderCustom::applyValueSize(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 421 {
 422     styleResolver.style()-&gt;resetPageSizeType();
 423 
 424     if (!is&lt;CSSValueList&gt;(value))
 425         return;
 426 
 427     Length width;
 428     Length height;
 429     PageSizeType pageSizeType = PAGE_SIZE_AUTO;
 430 
 431     auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
 432     switch (valueList.length()) {
 433     case 2: {
 434         auto firstValue = valueList.itemWithoutBoundsCheck(0);
 435         auto secondValue = valueList.itemWithoutBoundsCheck(1);
 436         // &lt;length&gt;{2} | &lt;page-size&gt; &lt;orientation&gt;
 437         if (!is&lt;CSSPrimitiveValue&gt;(*firstValue) || !is&lt;CSSPrimitiveValue&gt;(*secondValue))
 438             return;
 439         auto&amp; firstPrimitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*firstValue);
 440         auto&amp; secondPrimitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*secondValue);
 441         if (firstPrimitiveValue.isLength()) {
 442             // &lt;length&gt;{2}
 443             if (!secondPrimitiveValue.isLength())
 444                 return;
 445             CSSToLengthConversionData conversionData = styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f);
 446             width = firstPrimitiveValue.computeLength&lt;Length&gt;(conversionData);
 447             height = secondPrimitiveValue.computeLength&lt;Length&gt;(conversionData);
 448         } else {
 449             // &lt;page-size&gt; &lt;orientation&gt;
 450             // The value order is guaranteed. See CSSParser::parseSizeParameter.
 451             if (!getPageSizeFromName(&amp;firstPrimitiveValue, &amp;secondPrimitiveValue, width, height))
 452                 return;
 453         }
 454         pageSizeType = PAGE_SIZE_RESOLVED;
 455         break;
 456     }
 457     case 1: {
 458         auto value = valueList.itemWithoutBoundsCheck(0);
 459         // &lt;length&gt; | auto | &lt;page-size&gt; | [ portrait | landscape]
 460         if (!is&lt;CSSPrimitiveValue&gt;(*value))
 461             return;
 462         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
 463         if (primitiveValue.isLength()) {
 464             // &lt;length&gt;
 465             pageSizeType = PAGE_SIZE_RESOLVED;
 466             width = height = primitiveValue.computeLength&lt;Length&gt;(styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f));
 467         } else {
 468             switch (primitiveValue.valueID()) {
 469             case 0:
 470                 return;
 471             case CSSValueAuto:
 472                 pageSizeType = PAGE_SIZE_AUTO;
 473                 break;
 474             case CSSValuePortrait:
 475                 pageSizeType = PAGE_SIZE_AUTO_PORTRAIT;
 476                 break;
 477             case CSSValueLandscape:
 478                 pageSizeType = PAGE_SIZE_AUTO_LANDSCAPE;
 479                 break;
 480             default:
 481                 // &lt;page-size&gt;
 482                 pageSizeType = PAGE_SIZE_RESOLVED;
 483                 if (!getPageSizeFromName(&amp;primitiveValue, nullptr, width, height))
 484                     return;
 485             }
 486         }
 487         break;
 488     }
 489     default:
 490         return;
 491     }
 492     styleResolver.style()-&gt;setPageSizeType(pageSizeType);
 493     styleResolver.style()-&gt;setPageSize({ WTFMove(width), WTFMove(height) });
 494 }
 495 
 496 inline void StyleBuilderCustom::applyInheritTextIndent(StyleResolver&amp; styleResolver)
 497 {
 498     styleResolver.style()-&gt;setTextIndent(Length { styleResolver.parentStyle()-&gt;textIndent() });
 499 #if ENABLE(CSS3_TEXT)
 500     styleResolver.style()-&gt;setTextIndentLine(styleResolver.parentStyle()-&gt;textIndentLine());
 501     styleResolver.style()-&gt;setTextIndentType(styleResolver.parentStyle()-&gt;textIndentType());
 502 #endif
 503 }
 504 
 505 inline void StyleBuilderCustom::applyInitialTextIndent(StyleResolver&amp; styleResolver)
 506 {
 507     styleResolver.style()-&gt;setTextIndent(RenderStyle::initialTextIndent());
 508 #if ENABLE(CSS3_TEXT)
 509     styleResolver.style()-&gt;setTextIndentLine(RenderStyle::initialTextIndentLine());
 510     styleResolver.style()-&gt;setTextIndentType(RenderStyle::initialTextIndentType());
 511 #endif
 512 }
 513 
 514 inline void StyleBuilderCustom::applyValueTextIndent(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 515 {
 516     Length lengthOrPercentageValue;
 517 #if ENABLE(CSS3_TEXT)
 518     TextIndentLine textIndentLineValue = RenderStyle::initialTextIndentLine();
 519     TextIndentType textIndentTypeValue = RenderStyle::initialTextIndentType();
 520 #endif
 521     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
 522         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(item.get());
 523         if (!primitiveValue.valueID())
 524             lengthOrPercentageValue = primitiveValue.convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion&gt;(styleResolver.state().cssToLengthConversionData());
 525 #if ENABLE(CSS3_TEXT)
 526         else if (primitiveValue.valueID() == CSSValueWebkitEachLine)
 527             textIndentLineValue = TextIndentLine::EachLine;
 528         else if (primitiveValue.valueID() == CSSValueWebkitHanging)
 529             textIndentTypeValue = TextIndentType::Hanging;
 530 #endif
 531     }
 532 
 533     if (lengthOrPercentageValue.isUndefined())
 534         return;
 535 
 536     styleResolver.style()-&gt;setTextIndent(WTFMove(lengthOrPercentageValue));
 537 #if ENABLE(CSS3_TEXT)
 538     styleResolver.style()-&gt;setTextIndentLine(textIndentLineValue);
 539     styleResolver.style()-&gt;setTextIndentType(textIndentTypeValue);
 540 #endif
 541 }
 542 
 543 enum BorderImageType { BorderImage, WebkitMaskBoxImage };
 544 enum BorderImageModifierType { Outset, Repeat, Slice, Width };
 545 template &lt;BorderImageType type, BorderImageModifierType modifier&gt;
 546 class ApplyPropertyBorderImageModifier {
 547 public:
 548     static void applyInheritValue(StyleResolver&amp; styleResolver)
 549     {
 550         NinePieceImage image(getValue(styleResolver.style()));
 551         switch (modifier) {
 552         case Outset:
 553             image.copyOutsetFrom(getValue(styleResolver.parentStyle()));
 554             break;
 555         case Repeat:
 556             image.copyRepeatFrom(getValue(styleResolver.parentStyle()));
 557             break;
 558         case Slice:
 559             image.copyImageSlicesFrom(getValue(styleResolver.parentStyle()));
 560             break;
 561         case Width:
 562             image.copyBorderSlicesFrom(getValue(styleResolver.parentStyle()));
 563             break;
 564         }
 565         setValue(styleResolver.style(), image);
 566     }
 567 
 568     static void applyInitialValue(StyleResolver&amp; styleResolver)
 569     {
 570         NinePieceImage image(getValue(styleResolver.style()));
 571         switch (modifier) {
 572         case Outset:
 573             image.setOutset(LengthBox(0));
 574             break;
 575         case Repeat:
 576             image.setHorizontalRule(StretchImageRule);
 577             image.setVerticalRule(StretchImageRule);
 578             break;
 579         case Slice:
 580             // Masks have a different initial value for slices. Preserve the value of 0 for backwards compatibility.
 581             image.setImageSlices(type == BorderImage ? LengthBox(Length(100, Percent), Length(100, Percent), Length(100, Percent), Length(100, Percent)) : LengthBox());
 582             image.setFill(false);
 583             break;
 584         case Width:
 585             // FIXME: This is a local variable to work around a bug in the GCC 8.1 Address Sanitizer.
 586             // Might be slightly less efficient when the type is not BorderImage since this is unused in that case.
 587             // Should be switched back to a temporary when possible. See https://webkit.org/b/186980
 588             LengthBox lengthBox(Length(1, Relative), Length(1, Relative), Length(1, Relative), Length(1, Relative));
 589             // Masks have a different initial value for widths. They use an &#39;auto&#39; value rather than trying to fit to the border.
 590             image.setBorderSlices(type == BorderImage ? lengthBox : LengthBox());
 591             break;
 592         }
 593         setValue(styleResolver.style(), image);
 594     }
 595 
 596     static void applyValue(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 597     {
 598         NinePieceImage image(getValue(styleResolver.style()));
 599         switch (modifier) {
 600         case Outset:
 601             image.setOutset(styleResolver.styleMap()-&gt;mapNinePieceImageQuad(value));
 602             break;
 603         case Repeat:
 604             styleResolver.styleMap()-&gt;mapNinePieceImageRepeat(value, image);
 605             break;
 606         case Slice:
 607             styleResolver.styleMap()-&gt;mapNinePieceImageSlice(value, image);
 608             break;
 609         case Width:
 610             image.setBorderSlices(styleResolver.styleMap()-&gt;mapNinePieceImageQuad(value));
 611             break;
 612         }
 613         setValue(styleResolver.style(), image);
 614     }
 615 
 616 private:
 617     static const NinePieceImage&amp; getValue(const RenderStyle* style)
 618     {
 619         return type == BorderImage ? style-&gt;borderImage() : style-&gt;maskBoxImage();
 620     }
 621 
 622     static void setValue(RenderStyle* style, const NinePieceImage&amp; value)
 623     {
 624         return type == BorderImage ? style-&gt;setBorderImage(value) : style-&gt;setMaskBoxImage(value);
 625     }
 626 };
 627 
 628 #define DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(type, modifier) \
 629 inline void StyleBuilderCustom::applyInherit##type##modifier(StyleResolver&amp; styleResolver) \
 630 { \
 631     ApplyPropertyBorderImageModifier&lt;type, modifier&gt;::applyInheritValue(styleResolver); \
 632 } \
 633 inline void StyleBuilderCustom::applyInitial##type##modifier(StyleResolver&amp; styleResolver) \
 634 { \
 635     ApplyPropertyBorderImageModifier&lt;type, modifier&gt;::applyInitialValue(styleResolver); \
 636 } \
 637 inline void StyleBuilderCustom::applyValue##type##modifier(StyleResolver&amp; styleResolver, CSSValue&amp; value) \
 638 { \
 639     ApplyPropertyBorderImageModifier&lt;type, modifier&gt;::applyValue(styleResolver, value); \
 640 }
 641 
 642 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(BorderImage, Outset)
 643 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(BorderImage, Repeat)
 644 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(BorderImage, Slice)
 645 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(BorderImage, Width)
 646 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(WebkitMaskBoxImage, Outset)
 647 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(WebkitMaskBoxImage, Repeat)
 648 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(WebkitMaskBoxImage, Slice)
 649 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(WebkitMaskBoxImage, Width)
 650 
 651 #if ENABLE(TEXT_AUTOSIZING)
 652 
 653 inline void StyleBuilderCustom::applyInheritLineHeight(StyleResolver&amp; styleResolver)
 654 {
 655     styleResolver.style()-&gt;setLineHeight(Length { styleResolver.parentStyle()-&gt;lineHeight() });
 656     styleResolver.style()-&gt;setSpecifiedLineHeight(Length { styleResolver.parentStyle()-&gt;specifiedLineHeight() });
 657 }
 658 
 659 inline void StyleBuilderCustom::applyInitialLineHeight(StyleResolver&amp; styleResolver)
 660 {
 661     styleResolver.style()-&gt;setLineHeight(RenderStyle::initialLineHeight());
 662     styleResolver.style()-&gt;setSpecifiedLineHeight(RenderStyle::initialSpecifiedLineHeight());
 663 }
 664 
 665 static inline float computeBaseSpecifiedFontSize(const Document&amp; document, const RenderStyle&amp; style, bool percentageAutosizingEnabled)
 666 {
 667     float result = style.specifiedFontSize();
 668     auto* frame = document.frame();
 669     if (frame &amp;&amp; style.textZoom() != TextZoom::Reset)
 670         result *= frame-&gt;textZoomFactor();
 671     result *= style.effectiveZoom();
 672     if (percentageAutosizingEnabled)
 673         result *= style.textSizeAdjust().multiplier();
 674     return result;
 675 }
 676 
 677 static inline float computeLineHeightMultiplierDueToFontSize(const Document&amp; document, const RenderStyle&amp; style, const CSSPrimitiveValue&amp; value)
 678 {
 679     bool percentageAutosizingEnabled = document.settings().textAutosizingEnabled() &amp;&amp; style.textSizeAdjust().isPercentage();
 680 
 681     if (value.isLength()) {
 682         auto minimumFontSize = document.settings().minimumFontSize();
 683         if (minimumFontSize &gt; 0) {
 684             auto specifiedFontSize = computeBaseSpecifiedFontSize(document, style, percentageAutosizingEnabled);
 685             // Small font sizes cause a preposterously large (near infinity) line-height. Add a fuzz-factor of 1px which opts out of
 686             // boosted line-height.
 687             if (specifiedFontSize &lt; minimumFontSize &amp;&amp; specifiedFontSize &gt;= 1) {
 688                 // FIXME: There are two settings which are relevant here: minimum font size, and minimum logical font size (as
 689                 // well as things like the zoom property, text zoom on the page, and text autosizing). The minimum logical font
 690                 // size is nonzero by default, and already incorporated into the computed font size, so if we just use the ratio
 691                 // of the computed : specified font size, it will be &gt; 1 in the cases where the minimum logical font size kicks
 692                 // in. In general, this is the right thing to do, however, this kind of blanket change is too risky to perform
 693                 // right now. https://bugs.webkit.org/show_bug.cgi?id=174570 tracks turning this on. For now, we can just pretend
 694                 // that the minimum font size is the only thing affecting the computed font size.
 695 
 696                 // This calculation matches the line-height computed size calculation in
 697                 // TextAutoSizing::Value::adjustTextNodeSizes().
 698                 auto scaleChange = minimumFontSize / specifiedFontSize;
 699                 return scaleChange;
 700             }
 701         }
 702     }
 703 
 704     if (percentageAutosizingEnabled)
 705         return style.textSizeAdjust().multiplier();
 706     return 1;
 707 }
 708 
 709 inline void StyleBuilderCustom::applyValueLineHeight(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 710 {
 711     Optional&lt;Length&gt; lineHeight = StyleBuilderConverter::convertLineHeight(styleResolver, value, 1);
 712     if (!lineHeight)
 713         return;
 714 
 715     Length computedLineHeight;
 716     if (lineHeight.value().isNegative())
 717         computedLineHeight = lineHeight.value();
 718     else {
 719         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 720         auto multiplier = computeLineHeightMultiplierDueToFontSize(styleResolver.document(), *styleResolver.style(), primitiveValue);
 721         if (multiplier == 1)
 722             computedLineHeight = lineHeight.value();
 723         else
 724             computedLineHeight = StyleBuilderConverter::convertLineHeight(styleResolver, value, multiplier).value();
 725     }
 726 
 727     styleResolver.style()-&gt;setLineHeight(WTFMove(computedLineHeight));
 728     styleResolver.style()-&gt;setSpecifiedLineHeight(WTFMove(lineHeight.value()));
 729 }
 730 
 731 #endif
 732 
 733 inline void StyleBuilderCustom::applyInheritOutlineStyle(StyleResolver&amp; styleResolver)
 734 {
 735     styleResolver.style()-&gt;setOutlineStyleIsAuto(styleResolver.parentStyle()-&gt;outlineStyleIsAuto());
 736     styleResolver.style()-&gt;setOutlineStyle(styleResolver.parentStyle()-&gt;outlineStyle());
 737 }
 738 
 739 inline void StyleBuilderCustom::applyInitialOutlineStyle(StyleResolver&amp; styleResolver)
 740 {
 741     styleResolver.style()-&gt;setOutlineStyleIsAuto(RenderStyle::initialOutlineStyleIsAuto());
 742     styleResolver.style()-&gt;setOutlineStyle(RenderStyle::initialBorderStyle());
 743 }
 744 
 745 inline void StyleBuilderCustom::applyValueOutlineStyle(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 746 {
 747     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 748 
 749     styleResolver.style()-&gt;setOutlineStyleIsAuto(primitiveValue);
 750     styleResolver.style()-&gt;setOutlineStyle(primitiveValue);
 751 }
 752 
 753 inline void StyleBuilderCustom::applyInitialClip(StyleResolver&amp; styleResolver)
 754 {
 755     styleResolver.style()-&gt;setClip(Length(), Length(), Length(), Length());
 756     styleResolver.style()-&gt;setHasClip(false);
 757 }
 758 
 759 inline void StyleBuilderCustom::applyInheritClip(StyleResolver&amp; styleResolver)
 760 {
 761     auto* parentStyle = styleResolver.parentStyle();
 762     if (!parentStyle-&gt;hasClip())
 763         return applyInitialClip(styleResolver);
 764     styleResolver.style()-&gt;setClip(Length { parentStyle-&gt;clipTop() }, Length { parentStyle-&gt;clipRight() },
 765         Length { parentStyle-&gt;clipBottom() }, Length { parentStyle-&gt;clipLeft() });
 766     styleResolver.style()-&gt;setHasClip(true);
 767 }
 768 
 769 inline void StyleBuilderCustom::applyValueClip(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 770 {
 771     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 772     if (auto* rect = primitiveValue.rectValue()) {
 773         auto conversionData = styleResolver.state().cssToLengthConversionData();
 774         auto top = rect-&gt;top()-&gt;convertToLength&lt;FixedIntegerConversion | PercentConversion | AutoConversion&gt;(conversionData);
 775         auto right = rect-&gt;right()-&gt;convertToLength&lt;FixedIntegerConversion | PercentConversion | AutoConversion&gt;(conversionData);
 776         auto bottom = rect-&gt;bottom()-&gt;convertToLength&lt;FixedIntegerConversion | PercentConversion | AutoConversion&gt;(conversionData);
 777         auto left = rect-&gt;left()-&gt;convertToLength&lt;FixedIntegerConversion | PercentConversion | AutoConversion&gt;(conversionData);
 778         styleResolver.style()-&gt;setClip(WTFMove(top), WTFMove(right), WTFMove(bottom), WTFMove(left));
 779         styleResolver.style()-&gt;setHasClip(true);
 780     } else {
 781         ASSERT(primitiveValue.valueID() == CSSValueAuto);
 782         applyInitialClip(styleResolver);
 783     }
 784 }
 785 
 786 inline void StyleBuilderCustom::applyValueWebkitLocale(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 787 {
 788     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 789 
 790     FontCascadeDescription fontDescription = styleResolver.style()-&gt;fontDescription();
 791     if (primitiveValue.valueID() == CSSValueAuto)
 792         fontDescription.setLocale(nullAtom());
 793     else
 794         fontDescription.setLocale(primitiveValue.stringValue());
 795     styleResolver.setFontDescription(WTFMove(fontDescription));
 796 }
 797 
 798 inline void StyleBuilderCustom::applyValueWritingMode(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 799 {
 800     styleResolver.setWritingMode(downcast&lt;CSSPrimitiveValue&gt;(value));
 801     styleResolver.style()-&gt;setHasExplicitlySetWritingMode(true);
 802 }
 803 
 804 inline void StyleBuilderCustom::applyValueWebkitTextOrientation(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 805 {
 806     styleResolver.setTextOrientation(downcast&lt;CSSPrimitiveValue&gt;(value));
 807 }
 808 
 809 #if ENABLE(TEXT_AUTOSIZING)
 810 inline void StyleBuilderCustom::applyValueWebkitTextSizeAdjust(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 811 {
 812     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 813     if (primitiveValue.valueID() == CSSValueAuto)
 814         styleResolver.style()-&gt;setTextSizeAdjust(TextSizeAdjustment(AutoTextSizeAdjustment));
 815     else if (primitiveValue.valueID() == CSSValueNone)
 816         styleResolver.style()-&gt;setTextSizeAdjust(TextSizeAdjustment(NoTextSizeAdjustment));
 817     else
 818         styleResolver.style()-&gt;setTextSizeAdjust(TextSizeAdjustment(primitiveValue.floatValue()));
 819 
 820     styleResolver.state().setFontDirty(true);
 821 }
 822 #endif
 823 
 824 inline void StyleBuilderCustom::applyValueWebkitTextZoom(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 825 {
 826     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 827     if (primitiveValue.valueID() == CSSValueNormal)
 828         styleResolver.style()-&gt;setTextZoom(TextZoom::Normal);
 829     else if (primitiveValue.valueID() == CSSValueReset)
 830         styleResolver.style()-&gt;setTextZoom(TextZoom::Reset);
 831     styleResolver.state().setFontDirty(true);
 832 }
 833 
 834 #if ENABLE(DARK_MODE_CSS)
 835 inline void StyleBuilderCustom::applyValueSupportedColorSchemes(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 836 {
 837     styleResolver.style()-&gt;setSupportedColorSchemes(StyleBuilderConverter::convertSupportedColorSchemes(styleResolver, value));
 838     styleResolver.style()-&gt;setHasExplicitlySetSupportedColorSchemes(true);
 839 }
 840 #endif
 841 
 842 template&lt;CSSPropertyID property&gt;
 843 inline void StyleBuilderCustom::applyTextOrBoxShadowValue(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 844 {
 845     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 846         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
 847         if (property == CSSPropertyTextShadow)
 848             styleResolver.style()-&gt;setTextShadow(nullptr);
 849         else
 850             styleResolver.style()-&gt;setBoxShadow(nullptr);
 851         return;
 852     }
 853 
 854     bool isFirstEntry = true;
 855     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
 856         auto&amp; shadowValue = downcast&lt;CSSShadowValue&gt;(item.get());
 857         auto conversionData = styleResolver.state().cssToLengthConversionData();
 858         int x = shadowValue.x-&gt;computeLength&lt;int&gt;(conversionData);
 859         int y = shadowValue.y-&gt;computeLength&lt;int&gt;(conversionData);
 860         int blur = shadowValue.blur ? shadowValue.blur-&gt;computeLength&lt;int&gt;(conversionData) : 0;
 861         int spread = shadowValue.spread ? shadowValue.spread-&gt;computeLength&lt;int&gt;(conversionData) : 0;
 862         ShadowStyle shadowStyle = shadowValue.style &amp;&amp; shadowValue.style-&gt;valueID() == CSSValueInset ? Inset : Normal;
 863         Color color;
 864         if (shadowValue.color)
 865             color = styleResolver.colorFromPrimitiveValue(*shadowValue.color);
 866         else
 867             color = styleResolver.style()-&gt;color();
 868         auto shadowData = std::make_unique&lt;ShadowData&gt;(IntPoint(x, y), blur, spread, shadowStyle, property == CSSPropertyWebkitBoxShadow, color.isValid() ? color : Color::transparent);
 869         if (property == CSSPropertyTextShadow)
 870             styleResolver.style()-&gt;setTextShadow(WTFMove(shadowData), !isFirstEntry); // add to the list if this is not the first entry
 871         else
 872             styleResolver.style()-&gt;setBoxShadow(WTFMove(shadowData), !isFirstEntry); // add to the list if this is not the first entry
 873         isFirstEntry = false;
 874     }
 875 }
 876 
 877 inline void StyleBuilderCustom::applyInitialTextShadow(StyleResolver&amp; styleResolver)
 878 {
 879     styleResolver.style()-&gt;setTextShadow(nullptr);
 880 }
 881 
 882 inline void StyleBuilderCustom::applyInheritTextShadow(StyleResolver&amp; styleResolver)
 883 {
 884     styleResolver.style()-&gt;setTextShadow(styleResolver.parentStyle()-&gt;textShadow() ? std::make_unique&lt;ShadowData&gt;(*styleResolver.parentStyle()-&gt;textShadow()) : nullptr);
 885 }
 886 
 887 inline void StyleBuilderCustom::applyValueTextShadow(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 888 {
 889     applyTextOrBoxShadowValue&lt;CSSPropertyTextShadow&gt;(styleResolver, value);
 890 }
 891 
 892 inline void StyleBuilderCustom::applyInitialBoxShadow(StyleResolver&amp; styleResolver)
 893 {
 894     styleResolver.style()-&gt;setBoxShadow(nullptr);
 895 }
 896 
 897 inline void StyleBuilderCustom::applyInheritBoxShadow(StyleResolver&amp; styleResolver)
 898 {
 899     styleResolver.style()-&gt;setBoxShadow(styleResolver.parentStyle()-&gt;boxShadow() ? std::make_unique&lt;ShadowData&gt;(*styleResolver.parentStyle()-&gt;boxShadow()) : nullptr);
 900 }
 901 
 902 inline void StyleBuilderCustom::applyValueBoxShadow(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 903 {
 904     applyTextOrBoxShadowValue&lt;CSSPropertyBoxShadow&gt;(styleResolver, value);
 905 }
 906 
 907 inline void StyleBuilderCustom::applyInitialWebkitBoxShadow(StyleResolver&amp; styleResolver)
 908 {
 909     applyInitialBoxShadow(styleResolver);
 910 }
 911 
 912 inline void StyleBuilderCustom::applyInheritWebkitBoxShadow(StyleResolver&amp; styleResolver)
 913 {
 914     applyInheritBoxShadow(styleResolver);
 915 }
 916 
 917 inline void StyleBuilderCustom::applyValueWebkitBoxShadow(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 918 {
 919     applyTextOrBoxShadowValue&lt;CSSPropertyWebkitBoxShadow&gt;(styleResolver, value);
 920 }
 921 
 922 inline void StyleBuilderCustom::applyInitialFontFamily(StyleResolver&amp; styleResolver)
 923 {
 924     auto fontDescription = styleResolver.style()-&gt;fontDescription();
 925     auto initialDesc = FontCascadeDescription();
 926 
 927     // We need to adjust the size to account for the generic family change from monospace to non-monospace.
 928     if (fontDescription.useFixedDefaultSize()) {
 929         if (CSSValueID sizeIdentifier = fontDescription.keywordSizeAsIdentifier())
 930             styleResolver.setFontSize(fontDescription, Style::fontSizeForKeyword(sizeIdentifier, false, styleResolver.document()));
 931     }
 932     if (!initialDesc.firstFamily().isEmpty())
 933         fontDescription.setFamilies(initialDesc.families());
 934 
 935     styleResolver.setFontDescription(WTFMove(fontDescription));
 936 }
 937 
 938 inline void StyleBuilderCustom::applyInheritFontFamily(StyleResolver&amp; styleResolver)
 939 {
 940     auto fontDescription = styleResolver.style()-&gt;fontDescription();
 941     auto parentFontDescription = styleResolver.parentStyle()-&gt;fontDescription();
 942 
 943     fontDescription.setFamilies(parentFontDescription.families());
 944     fontDescription.setIsSpecifiedFont(parentFontDescription.isSpecifiedFont());
 945     styleResolver.setFontDescription(WTFMove(fontDescription));
 946 }
 947 
 948 inline void StyleBuilderCustom::applyValueFontFamily(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 949 {
 950     auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
 951 
 952     auto fontDescription = styleResolver.style()-&gt;fontDescription();
 953     // Before mapping in a new font-family property, we should reset the generic family.
 954     bool oldFamilyUsedFixedDefaultSize = fontDescription.useFixedDefaultSize();
 955 
 956     Vector&lt;AtomicString&gt; families;
 957     families.reserveInitialCapacity(valueList.length());
 958 
 959     for (auto&amp; item : valueList) {
 960         auto&amp; contentValue = downcast&lt;CSSPrimitiveValue&gt;(item.get());
 961         AtomicString family;
 962         bool isGenericFamily = false;
 963         if (contentValue.isFontFamily()) {
 964             const CSSFontFamily&amp; fontFamily = contentValue.fontFamily();
 965             family = fontFamily.familyName;
 966             // If the family name was resolved by the CSS parser from a system font ID, then it is generic.
 967             isGenericFamily = fontFamily.fromSystemFontID;
 968         } else {
 969             switch (contentValue.valueID()) {
 970             case CSSValueWebkitBody:
 971                 family = styleResolver.settings().standardFontFamily();
 972                 break;
 973             case CSSValueSerif:
 974                 family = serifFamily;
 975                 isGenericFamily = true;
 976                 break;
 977             case CSSValueSansSerif:
 978                 family = sansSerifFamily;
 979                 isGenericFamily = true;
 980                 break;
 981             case CSSValueCursive:
 982                 family = cursiveFamily;
 983                 isGenericFamily = true;
 984                 break;
 985             case CSSValueFantasy:
 986                 family = fantasyFamily;
 987                 isGenericFamily = true;
 988                 break;
 989             case CSSValueMonospace:
 990                 family = monospaceFamily;
 991                 isGenericFamily = true;
 992                 break;
 993             case CSSValueWebkitPictograph:
 994                 family = pictographFamily;
 995                 isGenericFamily = true;
 996                 break;
 997             case CSSValueSystemUi:
 998                 family = systemUiFamily;
 999                 isGenericFamily = true;
1000                 break;
1001             default:
1002                 break;
1003             }
1004         }
1005 
1006         if (family.isEmpty())
1007             continue;
1008         if (families.isEmpty())
1009             fontDescription.setIsSpecifiedFont(!isGenericFamily);
1010         families.uncheckedAppend(family);
1011     }
1012 
1013     if (families.isEmpty())
1014         return;
1015     fontDescription.setFamilies(families);
1016 
1017     if (fontDescription.useFixedDefaultSize() != oldFamilyUsedFixedDefaultSize) {
1018         if (CSSValueID sizeIdentifier = fontDescription.keywordSizeAsIdentifier())
1019             styleResolver.setFontSize(fontDescription, Style::fontSizeForKeyword(sizeIdentifier, !oldFamilyUsedFixedDefaultSize, styleResolver.document()));
1020     }
1021 
1022     styleResolver.setFontDescription(WTFMove(fontDescription));
1023 }
1024 
1025 inline bool StyleBuilderCustom::isValidDisplayValue(StyleResolver&amp; styleResolver, DisplayType display)
1026 {
1027     if (is&lt;SVGElement&gt;(styleResolver.element()) &amp;&amp; styleResolver.style()-&gt;styleType() == PseudoId::None)
1028         return display == DisplayType::Inline || display == DisplayType::Block || display == DisplayType::None;
1029     return true;
1030 }
1031 
1032 inline void StyleBuilderCustom::applyInheritDisplay(StyleResolver&amp; styleResolver)
1033 {
1034     DisplayType display = styleResolver.parentStyle()-&gt;display();
1035     if (isValidDisplayValue(styleResolver, display))
1036         styleResolver.style()-&gt;setDisplay(display);
1037 }
1038 
1039 inline void StyleBuilderCustom::applyValueDisplay(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1040 {
1041     DisplayType display = downcast&lt;CSSPrimitiveValue&gt;(value);
1042     if (isValidDisplayValue(styleResolver, display))
1043         styleResolver.style()-&gt;setDisplay(display);
1044 }
1045 
1046 inline void StyleBuilderCustom::applyValueBaselineShift(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1047 {
1048     SVGRenderStyle&amp; svgStyle = styleResolver.style()-&gt;accessSVGStyle();
1049     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1050     if (primitiveValue.isValueID()) {
1051         switch (primitiveValue.valueID()) {
1052         case CSSValueBaseline:
1053             svgStyle.setBaselineShift(BaselineShift::Baseline);
1054             break;
1055         case CSSValueSub:
1056             svgStyle.setBaselineShift(BaselineShift::Sub);
1057             break;
1058         case CSSValueSuper:
1059             svgStyle.setBaselineShift(BaselineShift::Super);
1060             break;
1061         default:
1062             break;
1063         }
1064     } else {
1065         svgStyle.setBaselineShift(BaselineShift::Length);
1066         svgStyle.setBaselineShiftValue(SVGLengthValue::fromCSSPrimitiveValue(primitiveValue));
1067     }
1068 }
1069 
1070 inline void StyleBuilderCustom::applyInitialWebkitAspectRatio(StyleResolver&amp; styleResolver)
1071 {
1072     styleResolver.style()-&gt;setAspectRatioType(RenderStyle::initialAspectRatioType());
1073     styleResolver.style()-&gt;setAspectRatioDenominator(RenderStyle::initialAspectRatioDenominator());
1074     styleResolver.style()-&gt;setAspectRatioNumerator(RenderStyle::initialAspectRatioNumerator());
1075 }
1076 
1077 inline void StyleBuilderCustom::applyInheritWebkitAspectRatio(StyleResolver&amp; styleResolver)
1078 {
1079     if (styleResolver.parentStyle()-&gt;aspectRatioType() == AspectRatioType::Auto)
1080         return;
1081     styleResolver.style()-&gt;setAspectRatioType(styleResolver.parentStyle()-&gt;aspectRatioType());
1082     styleResolver.style()-&gt;setAspectRatioDenominator(styleResolver.parentStyle()-&gt;aspectRatioDenominator());
1083     styleResolver.style()-&gt;setAspectRatioNumerator(styleResolver.parentStyle()-&gt;aspectRatioNumerator());
1084 }
1085 
1086 inline void StyleBuilderCustom::applyValueWebkitAspectRatio(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1087 {
1088     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1089         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1090 
1091         if (primitiveValue.valueID() == CSSValueFromDimensions)
1092             return styleResolver.style()-&gt;setAspectRatioType(AspectRatioType::FromDimensions);
1093         if (primitiveValue.valueID() == CSSValueFromIntrinsic)
1094             return styleResolver.style()-&gt;setAspectRatioType(AspectRatioType::FromIntrinsic);
1095 
1096         ASSERT(primitiveValue.valueID() == CSSValueAuto);
1097         return styleResolver.style()-&gt;setAspectRatioType(AspectRatioType::Auto);
1098     }
1099 
1100     auto&amp; aspectRatioValue = downcast&lt;CSSAspectRatioValue&gt;(value);
1101     styleResolver.style()-&gt;setAspectRatioType(AspectRatioType::Specified);
1102     styleResolver.style()-&gt;setAspectRatioDenominator(aspectRatioValue.denominatorValue());
1103     styleResolver.style()-&gt;setAspectRatioNumerator(aspectRatioValue.numeratorValue());
1104 }
1105 
1106 inline void StyleBuilderCustom::applyInitialWebkitTextEmphasisStyle(StyleResolver&amp; styleResolver)
1107 {
1108     styleResolver.style()-&gt;setTextEmphasisFill(RenderStyle::initialTextEmphasisFill());
1109     styleResolver.style()-&gt;setTextEmphasisMark(RenderStyle::initialTextEmphasisMark());
1110     styleResolver.style()-&gt;setTextEmphasisCustomMark(RenderStyle::initialTextEmphasisCustomMark());
1111 }
1112 
1113 inline void StyleBuilderCustom::applyInheritWebkitTextEmphasisStyle(StyleResolver&amp; styleResolver)
1114 {
1115     styleResolver.style()-&gt;setTextEmphasisFill(styleResolver.parentStyle()-&gt;textEmphasisFill());
1116     styleResolver.style()-&gt;setTextEmphasisMark(styleResolver.parentStyle()-&gt;textEmphasisMark());
1117     styleResolver.style()-&gt;setTextEmphasisCustomMark(styleResolver.parentStyle()-&gt;textEmphasisCustomMark());
1118 }
1119 
1120 inline void StyleBuilderCustom::applyValueWebkitTextEmphasisStyle(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1121 {
1122     if (is&lt;CSSValueList&gt;(value)) {
1123         auto&amp; list = downcast&lt;CSSValueList&gt;(value);
1124         ASSERT(list.length() == 2);
1125 
1126         for (auto&amp; item : list) {
1127             CSSPrimitiveValue&amp; value = downcast&lt;CSSPrimitiveValue&gt;(item.get());
1128             if (value.valueID() == CSSValueFilled || value.valueID() == CSSValueOpen)
1129                 styleResolver.style()-&gt;setTextEmphasisFill(value);
1130             else
1131                 styleResolver.style()-&gt;setTextEmphasisMark(value);
1132         }
1133         styleResolver.style()-&gt;setTextEmphasisCustomMark(nullAtom());
1134         return;
1135     }
1136 
1137     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1138     if (primitiveValue.isString()) {
1139         styleResolver.style()-&gt;setTextEmphasisFill(TextEmphasisFill::Filled);
1140         styleResolver.style()-&gt;setTextEmphasisMark(TextEmphasisMark::Custom);
1141         styleResolver.style()-&gt;setTextEmphasisCustomMark(primitiveValue.stringValue());
1142         return;
1143     }
1144 
1145     styleResolver.style()-&gt;setTextEmphasisCustomMark(nullAtom());
1146 
1147     if (primitiveValue.valueID() == CSSValueFilled || primitiveValue.valueID() == CSSValueOpen) {
1148         styleResolver.style()-&gt;setTextEmphasisFill(primitiveValue);
1149         styleResolver.style()-&gt;setTextEmphasisMark(TextEmphasisMark::Auto);
1150     } else {
1151         styleResolver.style()-&gt;setTextEmphasisFill(TextEmphasisFill::Filled);
1152         styleResolver.style()-&gt;setTextEmphasisMark(primitiveValue);
1153     }
1154 }
1155 
1156 template &lt;StyleBuilderCustom::CounterBehavior counterBehavior&gt;
1157 inline void StyleBuilderCustom::applyInheritCounter(StyleResolver&amp; styleResolver)
1158 {
1159     auto&amp; map = styleResolver.style()-&gt;accessCounterDirectives();
1160     for (auto&amp; keyValue : const_cast&lt;RenderStyle*&gt;(styleResolver.parentStyle())-&gt;accessCounterDirectives()) {
1161         auto&amp; directives = map.add(keyValue.key, CounterDirectives { }).iterator-&gt;value;
1162         if (counterBehavior == Reset)
1163             directives.resetValue = keyValue.value.resetValue;
1164         else
1165             directives.incrementValue = keyValue.value.incrementValue;
1166     }
1167 }
1168 
1169 template &lt;StyleBuilderCustom::CounterBehavior counterBehavior&gt;
1170 inline void StyleBuilderCustom::applyValueCounter(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1171 {
1172     bool setCounterIncrementToNone = counterBehavior == Increment &amp;&amp; is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone;
1173 
1174     if (!is&lt;CSSValueList&gt;(value) &amp;&amp; !setCounterIncrementToNone)
1175         return;
1176 
1177     CounterDirectiveMap&amp; map = styleResolver.style()-&gt;accessCounterDirectives();
1178     for (auto&amp; keyValue : map) {
1179         if (counterBehavior == Reset)
1180             keyValue.value.resetValue = WTF::nullopt;
1181         else
1182             keyValue.value.incrementValue = WTF::nullopt;
1183     }
1184 
1185     if (setCounterIncrementToNone)
1186         return;
1187 
1188     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
1189         Pair* pair = downcast&lt;CSSPrimitiveValue&gt;(item.get()).pairValue();
1190         AtomicString identifier = pair-&gt;first()-&gt;stringValue();
1191         int value = pair-&gt;second()-&gt;intValue();
1192         auto&amp; directives = map.add(identifier, CounterDirectives { }).iterator-&gt;value;
1193         if (counterBehavior == Reset)
1194             directives.resetValue = value;
1195         else
1196             directives.incrementValue = saturatedAddition(directives.incrementValue.valueOr(0), value);
1197     }
1198 }
1199 
1200 inline void StyleBuilderCustom::applyInitialCounterIncrement(StyleResolver&amp;) { }
1201 
1202 inline void StyleBuilderCustom::applyInheritCounterIncrement(StyleResolver&amp; styleResolver)
1203 {
1204     applyInheritCounter&lt;Increment&gt;(styleResolver);
1205 }
1206 
1207 inline void StyleBuilderCustom::applyValueCounterIncrement(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1208 {
1209     applyValueCounter&lt;Increment&gt;(styleResolver, value);
1210 }
1211 
1212 inline void StyleBuilderCustom::applyInitialCounterReset(StyleResolver&amp;) { }
1213 
1214 inline void StyleBuilderCustom::applyInheritCounterReset(StyleResolver&amp; styleResolver)
1215 {
1216     applyInheritCounter&lt;Reset&gt;(styleResolver);
1217 }
1218 
1219 inline void StyleBuilderCustom::applyValueCounterReset(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1220 {
1221     applyValueCounter&lt;Reset&gt;(styleResolver, value);
1222 }
1223 
1224 inline void StyleBuilderCustom::applyInitialCursor(StyleResolver&amp; styleResolver)
1225 {
1226     styleResolver.style()-&gt;clearCursorList();
1227     styleResolver.style()-&gt;setCursor(RenderStyle::initialCursor());
1228 }
1229 
1230 inline void StyleBuilderCustom::applyInheritCursor(StyleResolver&amp; styleResolver)
1231 {
1232     styleResolver.style()-&gt;setCursor(styleResolver.parentStyle()-&gt;cursor());
1233     styleResolver.style()-&gt;setCursorList(styleResolver.parentStyle()-&gt;cursors());
1234 }
1235 
1236 inline void StyleBuilderCustom::applyValueCursor(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1237 {
1238     styleResolver.style()-&gt;clearCursorList();
1239     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1240         CursorType cursor = downcast&lt;CSSPrimitiveValue&gt;(value);
1241         if (styleResolver.style()-&gt;cursor() != cursor)
1242             styleResolver.style()-&gt;setCursor(cursor);
1243         return;
1244     }
1245 
1246     styleResolver.style()-&gt;setCursor(CursorType::Auto);
1247     auto&amp; list = downcast&lt;CSSValueList&gt;(value);
1248     for (auto&amp; item : list) {
1249         if (is&lt;CSSCursorImageValue&gt;(item)) {
1250             auto&amp; image = downcast&lt;CSSCursorImageValue&gt;(item.get());
1251             styleResolver.style()-&gt;addCursor(styleResolver.styleImage(image), image.hotSpot());
1252             continue;
1253         }
1254 
1255         styleResolver.style()-&gt;setCursor(downcast&lt;CSSPrimitiveValue&gt;(item.get()));
1256         ASSERT_WITH_MESSAGE(item.ptr() == list.item(list.length() - 1), &quot;Cursor ID fallback should always be last in the list&quot;);
1257         return;
1258     }
1259 }
1260 
1261 inline void StyleBuilderCustom::applyInitialFill(StyleResolver&amp; styleResolver)
1262 {
1263     auto&amp; svgStyle = styleResolver.style()-&gt;accessSVGStyle();
1264     svgStyle.setFillPaint(SVGRenderStyle::initialFillPaintType(), SVGRenderStyle::initialFillPaintColor(), SVGRenderStyle::initialFillPaintUri(), styleResolver.applyPropertyToRegularStyle(), styleResolver.applyPropertyToVisitedLinkStyle());
1265 }
1266 
1267 inline void StyleBuilderCustom::applyInheritFill(StyleResolver&amp; styleResolver)
1268 {
1269     auto&amp; svgStyle = styleResolver.style()-&gt;accessSVGStyle();
1270     auto&amp; svgParentStyle = styleResolver.parentStyle()-&gt;svgStyle();
1271     svgStyle.setFillPaint(svgParentStyle.fillPaintType(), svgParentStyle.fillPaintColor(), svgParentStyle.fillPaintUri(), styleResolver.applyPropertyToRegularStyle(), styleResolver.applyPropertyToVisitedLinkStyle());
1272 
1273 }
1274 
1275 inline void StyleBuilderCustom::applyValueFill(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1276 {
1277     auto&amp; svgStyle = styleResolver.style()-&gt;accessSVGStyle();
1278     const auto* localValue = value.isPrimitiveValue() ? &amp;downcast&lt;CSSPrimitiveValue&gt;(value) : nullptr;
1279     String url;
1280     if (value.isValueList()) {
1281         const CSSValueList&amp; list = downcast&lt;CSSValueList&gt;(value);
1282         url = downcast&lt;CSSPrimitiveValue&gt;(list.item(0))-&gt;stringValue();
1283         localValue = downcast&lt;CSSPrimitiveValue&gt;(list.item(1));
1284     }
1285 
1286     if (!localValue)
1287         return;
1288 
1289     Color color;
1290     auto paintType = SVGPaintType::RGBColor;
1291     if (localValue-&gt;isURI()) {
1292         paintType = SVGPaintType::URI;
1293         url = localValue-&gt;stringValue();
1294     } else if (localValue-&gt;isValueID() &amp;&amp; localValue-&gt;valueID() == CSSValueNone)
1295         paintType = url.isEmpty() ? SVGPaintType::None : SVGPaintType::URINone;
1296     else if (localValue-&gt;isValueID() &amp;&amp; localValue-&gt;valueID() == CSSValueCurrentcolor) {
1297         color = styleResolver.style()-&gt;color();
1298         paintType = url.isEmpty() ? SVGPaintType::CurrentColor : SVGPaintType::URICurrentColor;
1299     } else {
1300         color = styleResolver.colorFromPrimitiveValue(*localValue);
1301         paintType = url.isEmpty() ? SVGPaintType::RGBColor : SVGPaintType::URIRGBColor;
1302     }
1303     svgStyle.setFillPaint(paintType, color, url, styleResolver.applyPropertyToRegularStyle(), styleResolver.applyPropertyToVisitedLinkStyle());
1304 }
1305 
1306 inline void StyleBuilderCustom::applyInitialStroke(StyleResolver&amp; styleResolver)
1307 {
1308     SVGRenderStyle&amp; svgStyle = styleResolver.style()-&gt;accessSVGStyle();
1309     svgStyle.setStrokePaint(SVGRenderStyle::initialStrokePaintType(), SVGRenderStyle::initialStrokePaintColor(), SVGRenderStyle::initialStrokePaintUri(), styleResolver.applyPropertyToRegularStyle(), styleResolver.applyPropertyToVisitedLinkStyle());
1310 }
1311 
1312 inline void StyleBuilderCustom::applyInheritStroke(StyleResolver&amp; styleResolver)
1313 {
1314     auto&amp; svgStyle = styleResolver.style()-&gt;accessSVGStyle();
1315     auto&amp; svgParentStyle = styleResolver.parentStyle()-&gt;svgStyle();
1316     svgStyle.setStrokePaint(svgParentStyle.strokePaintType(), svgParentStyle.strokePaintColor(), svgParentStyle.strokePaintUri(), styleResolver.applyPropertyToRegularStyle(), styleResolver.applyPropertyToVisitedLinkStyle());
1317 }
1318 
1319 inline void StyleBuilderCustom::applyValueStroke(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1320 {
1321     auto&amp; svgStyle = styleResolver.style()-&gt;accessSVGStyle();
1322     const auto* localValue = value.isPrimitiveValue() ? &amp;downcast&lt;CSSPrimitiveValue&gt;(value) : nullptr;
1323     String url;
1324     if (value.isValueList()) {
1325         const CSSValueList&amp; list = downcast&lt;CSSValueList&gt;(value);
1326         url = downcast&lt;CSSPrimitiveValue&gt;(list.item(0))-&gt;stringValue();
1327         localValue = downcast&lt;CSSPrimitiveValue&gt;(list.item(1));
1328     }
1329 
1330     if (!localValue)
1331         return;
1332 
1333     Color color;
1334     auto paintType = SVGPaintType::RGBColor;
1335     if (localValue-&gt;isURI()) {
1336         paintType = SVGPaintType::URI;
1337         url = downcast&lt;CSSPrimitiveValue&gt;(localValue)-&gt;stringValue();
1338     } else if (localValue-&gt;isValueID() &amp;&amp; localValue-&gt;valueID() == CSSValueNone)
1339         paintType = url.isEmpty() ? SVGPaintType::None : SVGPaintType::URINone;
1340     else if (localValue-&gt;isValueID() &amp;&amp; localValue-&gt;valueID() == CSSValueCurrentcolor) {
1341         color = styleResolver.style()-&gt;color();
1342         paintType = url.isEmpty() ? SVGPaintType::CurrentColor : SVGPaintType::URICurrentColor;
1343     } else {
1344         color = styleResolver.colorFromPrimitiveValue(*localValue);
1345         paintType = url.isEmpty() ? SVGPaintType::RGBColor : SVGPaintType::URIRGBColor;
1346     }
1347     svgStyle.setStrokePaint(paintType, color, url, styleResolver.applyPropertyToRegularStyle(), styleResolver.applyPropertyToVisitedLinkStyle());
1348 }
1349 
1350 inline void StyleBuilderCustom::applyInitialContent(StyleResolver&amp; styleResolver)
1351 {
1352     styleResolver.style()-&gt;clearContent();
1353 }
1354 
1355 inline void StyleBuilderCustom::applyInheritContent(StyleResolver&amp;)
1356 {
1357     // FIXME: In CSS3, it will be possible to inherit content. In CSS2 it is not. This
1358     // note is a reminder that eventually &quot;inherit&quot; needs to be supported.
1359 }
1360 
1361 inline void StyleBuilderCustom::applyValueContent(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1362 {
1363     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1364         const auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1365         ASSERT_UNUSED(primitiveValue, primitiveValue.valueID() == CSSValueNormal || primitiveValue.valueID() == CSSValueNone);
1366         styleResolver.style()-&gt;clearContent();
1367         return;
1368     }
1369 
1370     bool didSet = false;
1371     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
1372         if (is&lt;CSSImageGeneratorValue&gt;(item)) {
1373             if (is&lt;CSSGradientValue&gt;(item))
1374                 styleResolver.style()-&gt;setContent(StyleGeneratedImage::create(downcast&lt;CSSGradientValue&gt;(item.get()).gradientWithStylesResolved(styleResolver)), didSet);
1375             else
1376                 styleResolver.style()-&gt;setContent(StyleGeneratedImage::create(downcast&lt;CSSImageGeneratorValue&gt;(item.get())), didSet);
1377             didSet = true;
1378         } else if (is&lt;CSSImageSetValue&gt;(item)) {
1379             styleResolver.style()-&gt;setContent(StyleCachedImage::create(item), didSet);
1380             didSet = true;
1381         }
1382 
1383         if (is&lt;CSSImageValue&gt;(item)) {
1384             styleResolver.style()-&gt;setContent(StyleCachedImage::create(item), didSet);
1385             didSet = true;
1386             continue;
1387         }
1388 
1389         if (!is&lt;CSSPrimitiveValue&gt;(item))
1390             continue;
1391 
1392         auto&amp; contentValue = downcast&lt;CSSPrimitiveValue&gt;(item.get());
1393         if (contentValue.isString()) {
1394             styleResolver.style()-&gt;setContent(contentValue.stringValue().impl(), didSet);
1395             didSet = true;
1396         } else if (contentValue.isAttr()) {
1397             // FIXME: Can a namespace be specified for an attr(foo)?
1398             if (styleResolver.style()-&gt;styleType() == PseudoId::None)
1399                 styleResolver.style()-&gt;setHasAttrContent();
1400             else
1401                 const_cast&lt;RenderStyle*&gt;(styleResolver.parentStyle())-&gt;setHasAttrContent();
1402             QualifiedName attr(nullAtom(), contentValue.stringValue().impl(), nullAtom());
1403             const AtomicString&amp; value = styleResolver.element()-&gt;getAttribute(attr);
1404             styleResolver.style()-&gt;setContent(value.isNull() ? emptyAtom() : value.impl(), didSet);
1405             didSet = true;
1406             // Register the fact that the attribute value affects the style.
1407             styleResolver.ruleSets().mutableFeatures().registerContentAttribute(attr.localName());
1408         } else if (contentValue.isCounter()) {
1409             auto* counterValue = contentValue.counterValue();
1410             ListStyleType listStyleType = ListStyleType::None;
1411             CSSValueID listStyleIdent = counterValue-&gt;listStyleIdent();
1412             if (listStyleIdent != CSSValueNone)
1413                 listStyleType = static_cast&lt;ListStyleType&gt;(listStyleIdent - CSSValueDisc);
1414             auto counter = std::make_unique&lt;CounterContent&gt;(counterValue-&gt;identifier(), listStyleType, counterValue-&gt;separator());
1415             styleResolver.style()-&gt;setContent(WTFMove(counter), didSet);
1416             didSet = true;
1417         } else {
1418             switch (contentValue.valueID()) {
1419             case CSSValueOpenQuote:
1420                 styleResolver.style()-&gt;setContent(QuoteType::OpenQuote, didSet);
1421                 didSet = true;
1422                 break;
1423             case CSSValueCloseQuote:
1424                 styleResolver.style()-&gt;setContent(QuoteType::CloseQuote, didSet);
1425                 didSet = true;
1426                 break;
1427             case CSSValueNoOpenQuote:
1428                 styleResolver.style()-&gt;setContent(QuoteType::NoOpenQuote, didSet);
1429                 didSet = true;
1430                 break;
1431             case CSSValueNoCloseQuote:
1432                 styleResolver.style()-&gt;setContent(QuoteType::NoCloseQuote, didSet);
1433                 didSet = true;
1434                 break;
1435             default:
1436                 // normal and none do not have any effect.
1437                 break;
1438             }
1439         }
1440     }
1441     if (!didSet)
1442         styleResolver.style()-&gt;clearContent();
1443 }
1444 
1445 inline void StyleBuilderCustom::applyInheritFontVariantLigatures(StyleResolver&amp; styleResolver)
1446 {
1447     auto fontDescription = styleResolver.fontDescription();
1448     fontDescription.setVariantCommonLigatures(styleResolver.parentFontDescription().variantCommonLigatures());
1449     fontDescription.setVariantDiscretionaryLigatures(styleResolver.parentFontDescription().variantDiscretionaryLigatures());
1450     fontDescription.setVariantHistoricalLigatures(styleResolver.parentFontDescription().variantHistoricalLigatures());
1451     fontDescription.setVariantContextualAlternates(styleResolver.parentFontDescription().variantContextualAlternates());
1452     styleResolver.setFontDescription(WTFMove(fontDescription));
1453 }
1454 
1455 inline void StyleBuilderCustom::applyInitialFontVariantLigatures(StyleResolver&amp; styleResolver)
1456 {
1457     auto fontDescription = styleResolver.fontDescription();
1458     fontDescription.setVariantCommonLigatures(FontVariantLigatures::Normal);
1459     fontDescription.setVariantDiscretionaryLigatures(FontVariantLigatures::Normal);
1460     fontDescription.setVariantHistoricalLigatures(FontVariantLigatures::Normal);
1461     fontDescription.setVariantContextualAlternates(FontVariantLigatures::Normal);
1462     styleResolver.setFontDescription(WTFMove(fontDescription));
1463 }
1464 
1465 inline void StyleBuilderCustom::applyValueFontVariantLigatures(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1466 {
1467     auto fontDescription = styleResolver.fontDescription();
1468     auto variantLigatures = extractFontVariantLigatures(value);
1469     fontDescription.setVariantCommonLigatures(variantLigatures.commonLigatures);
1470     fontDescription.setVariantDiscretionaryLigatures(variantLigatures.discretionaryLigatures);
1471     fontDescription.setVariantHistoricalLigatures(variantLigatures.historicalLigatures);
1472     fontDescription.setVariantContextualAlternates(variantLigatures.contextualAlternates);
1473     styleResolver.setFontDescription(WTFMove(fontDescription));
1474 }
1475 
1476 inline void StyleBuilderCustom::applyInheritFontVariantNumeric(StyleResolver&amp; styleResolver)
1477 {
1478     auto fontDescription = styleResolver.fontDescription();
1479     fontDescription.setVariantNumericFigure(styleResolver.parentFontDescription().variantNumericFigure());
1480     fontDescription.setVariantNumericSpacing(styleResolver.parentFontDescription().variantNumericSpacing());
1481     fontDescription.setVariantNumericFraction(styleResolver.parentFontDescription().variantNumericFraction());
1482     fontDescription.setVariantNumericOrdinal(styleResolver.parentFontDescription().variantNumericOrdinal());
1483     fontDescription.setVariantNumericSlashedZero(styleResolver.parentFontDescription().variantNumericSlashedZero());
1484     styleResolver.setFontDescription(WTFMove(fontDescription));
1485 }
1486 
1487 inline void StyleBuilderCustom::applyInitialFontVariantNumeric(StyleResolver&amp; styleResolver)
1488 {
1489     auto fontDescription = styleResolver.fontDescription();
1490     fontDescription.setVariantNumericFigure(FontVariantNumericFigure::Normal);
1491     fontDescription.setVariantNumericSpacing(FontVariantNumericSpacing::Normal);
1492     fontDescription.setVariantNumericFraction(FontVariantNumericFraction::Normal);
1493     fontDescription.setVariantNumericOrdinal(FontVariantNumericOrdinal::Normal);
1494     fontDescription.setVariantNumericSlashedZero(FontVariantNumericSlashedZero::Normal);
1495     styleResolver.setFontDescription(WTFMove(fontDescription));
1496 }
1497 
1498 inline void StyleBuilderCustom::applyValueFontVariantNumeric(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1499 {
1500     auto fontDescription = styleResolver.fontDescription();
1501     auto variantNumeric = extractFontVariantNumeric(value);
1502     fontDescription.setVariantNumericFigure(variantNumeric.figure);
1503     fontDescription.setVariantNumericSpacing(variantNumeric.spacing);
1504     fontDescription.setVariantNumericFraction(variantNumeric.fraction);
1505     fontDescription.setVariantNumericOrdinal(variantNumeric.ordinal);
1506     fontDescription.setVariantNumericSlashedZero(variantNumeric.slashedZero);
1507     styleResolver.setFontDescription(WTFMove(fontDescription));
1508 }
1509 
1510 inline void StyleBuilderCustom::applyInheritFontVariantEastAsian(StyleResolver&amp; styleResolver)
1511 {
1512     auto fontDescription = styleResolver.fontDescription();
1513     fontDescription.setVariantEastAsianVariant(styleResolver.parentFontDescription().variantEastAsianVariant());
1514     fontDescription.setVariantEastAsianWidth(styleResolver.parentFontDescription().variantEastAsianWidth());
1515     fontDescription.setVariantEastAsianRuby(styleResolver.parentFontDescription().variantEastAsianRuby());
1516     styleResolver.setFontDescription(WTFMove(fontDescription));
1517 }
1518 
1519 inline void StyleBuilderCustom::applyInitialFontVariantEastAsian(StyleResolver&amp; styleResolver)
1520 {
1521     auto fontDescription = styleResolver.fontDescription();
1522     fontDescription.setVariantEastAsianVariant(FontVariantEastAsianVariant::Normal);
1523     fontDescription.setVariantEastAsianWidth(FontVariantEastAsianWidth::Normal);
1524     fontDescription.setVariantEastAsianRuby(FontVariantEastAsianRuby::Normal);
1525     styleResolver.setFontDescription(WTFMove(fontDescription));
1526 }
1527 
1528 inline void StyleBuilderCustom::applyValueFontVariantEastAsian(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1529 {
1530     auto fontDescription = styleResolver.fontDescription();
1531     auto variantEastAsian = extractFontVariantEastAsian(value);
1532     fontDescription.setVariantEastAsianVariant(variantEastAsian.variant);
1533     fontDescription.setVariantEastAsianWidth(variantEastAsian.width);
1534     fontDescription.setVariantEastAsianRuby(variantEastAsian.ruby);
1535     styleResolver.setFontDescription(WTFMove(fontDescription));
1536 }
1537 
1538 inline void StyleBuilderCustom::applyInitialFontSize(StyleResolver&amp; styleResolver)
1539 {
1540     auto fontDescription = styleResolver.style()-&gt;fontDescription();
1541     float size = Style::fontSizeForKeyword(CSSValueMedium, fontDescription.useFixedDefaultSize(), styleResolver.document());
1542 
1543     if (size &lt; 0)
1544         return;
1545 
1546     fontDescription.setKeywordSizeFromIdentifier(CSSValueMedium);
1547     styleResolver.setFontSize(fontDescription, size);
1548     styleResolver.setFontDescription(WTFMove(fontDescription));
1549 }
1550 
1551 inline void StyleBuilderCustom::applyInheritFontSize(StyleResolver&amp; styleResolver)
1552 {
1553     const auto&amp; parentFontDescription = styleResolver.parentStyle()-&gt;fontDescription();
1554     float size = parentFontDescription.specifiedSize();
1555 
1556     if (size &lt; 0)
1557         return;
1558 
1559     auto fontDescription = styleResolver.style()-&gt;fontDescription();
1560     fontDescription.setKeywordSize(parentFontDescription.keywordSize());
1561     styleResolver.setFontSize(fontDescription, size);
1562     styleResolver.setFontDescription(WTFMove(fontDescription));
1563 }
1564 
1565 // When the CSS keyword &quot;larger&quot; is used, this function will attempt to match within the keyword
1566 // table, and failing that, will simply multiply by 1.2.
1567 inline float StyleBuilderCustom::largerFontSize(float size)
1568 {
1569     // FIXME: Figure out where we fall in the size ranges (xx-small to xxx-large) and scale up to
1570     // the next size level.
1571     return size * 1.2f;
1572 }
1573 
1574 // Like the previous function, but for the keyword &quot;smaller&quot;.
1575 inline float StyleBuilderCustom::smallerFontSize(float size)
1576 {
1577     // FIXME: Figure out where we fall in the size ranges (xx-small to xxx-large) and scale down to
1578     // the next size level.
1579     return size / 1.2f;
1580 }
1581 
1582 inline float StyleBuilderCustom::determineRubyTextSizeMultiplier(StyleResolver&amp; styleResolver)
1583 {
1584     if (styleResolver.style()-&gt;rubyPosition() != RubyPosition::InterCharacter)
1585         return 0.5f;
1586 
1587     // FIXME: This hack is to ensure tone marks are the same size as
1588     // the bopomofo. This code will go away if we make a special renderer
1589     // for the tone marks eventually.
1590     if (auto* element = styleResolver.state().element()) {
1591         for (auto&amp; ancestor : ancestorsOfType&lt;HTMLElement&gt;(*element)) {
1592             if (ancestor.hasTagName(HTMLNames::rtTag))
1593                 return 1.0f;
1594         }
1595     }
1596     return 0.25f;
1597 }
1598 
1599 inline void StyleBuilderCustom::applyInitialFontStyle(StyleResolver&amp; styleResolver)
1600 {
1601     auto fontDescription = styleResolver.fontDescription();
1602     fontDescription.setItalic(FontCascadeDescription::initialItalic());
1603     fontDescription.setFontStyleAxis(FontCascadeDescription::initialFontStyleAxis());
1604     styleResolver.setFontDescription(WTFMove(fontDescription));
1605 }
1606 
1607 inline void StyleBuilderCustom::applyInheritFontStyle(StyleResolver&amp; styleResolver)
1608 {
1609     auto fontDescription = styleResolver.fontDescription();
1610     fontDescription.setItalic(styleResolver.parentFontDescription().italic());
1611     fontDescription.setFontStyleAxis(styleResolver.parentFontDescription().fontStyleAxis());
1612     styleResolver.setFontDescription(WTFMove(fontDescription));
1613 }
1614 
1615 inline void StyleBuilderCustom::applyValueFontStyle(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1616 {
1617     auto&amp; fontStyleValue = downcast&lt;CSSFontStyleValue&gt;(value);
1618     auto fontDescription = styleResolver.fontDescription();
1619     fontDescription.setItalic(StyleBuilderConverter::convertFontStyleFromValue(fontStyleValue));
1620     fontDescription.setFontStyleAxis(fontStyleValue.fontStyleValue-&gt;valueID() == CSSValueItalic ? FontStyleAxis::ital : FontStyleAxis::slnt);
1621     styleResolver.setFontDescription(WTFMove(fontDescription));
1622 }
1623 
1624 inline void StyleBuilderCustom::applyValueFontSize(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1625 {
1626     auto fontDescription = styleResolver.style()-&gt;fontDescription();
1627     fontDescription.setKeywordSizeFromIdentifier(CSSValueInvalid);
1628 
1629     float parentSize = 0;
1630     bool parentIsAbsoluteSize = false;
1631     if (auto* parentStyle = styleResolver.parentStyle()) {
1632         parentSize = parentStyle-&gt;fontDescription().specifiedSize();
1633         parentIsAbsoluteSize = parentStyle-&gt;fontDescription().isAbsoluteSize();
1634     }
1635 
1636     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1637     float size;
1638     if (CSSValueID ident = primitiveValue.valueID()) {
1639         fontDescription.setIsAbsoluteSize(parentIsAbsoluteSize &amp;&amp; (ident == CSSValueLarger || ident == CSSValueSmaller || ident == CSSValueWebkitRubyText));
1640 
1641         // Keywords are being used.
1642         switch (ident) {
1643         case CSSValueXxSmall:
1644         case CSSValueXSmall:
1645         case CSSValueSmall:
1646         case CSSValueMedium:
1647         case CSSValueLarge:
1648         case CSSValueXLarge:
1649         case CSSValueXxLarge:
1650         case CSSValueWebkitXxxLarge:
1651             size = Style::fontSizeForKeyword(ident, fontDescription.useFixedDefaultSize(), styleResolver.document());
1652             fontDescription.setKeywordSizeFromIdentifier(ident);
1653             break;
1654         case CSSValueLarger:
1655             size = largerFontSize(parentSize);
1656             break;
1657         case CSSValueSmaller:
1658             size = smallerFontSize(parentSize);
1659             break;
1660         case CSSValueWebkitRubyText:
1661             size = determineRubyTextSizeMultiplier(styleResolver) * parentSize;
1662             break;
1663         default:
1664             return;
1665         }
1666     } else {
1667         fontDescription.setIsAbsoluteSize(parentIsAbsoluteSize || !(primitiveValue.isPercentage() || primitiveValue.isFontRelativeLength()));
1668         if (primitiveValue.isLength()) {
1669             size = primitiveValue.computeLength&lt;float&gt;(CSSToLengthConversionData(styleResolver.parentStyle(), styleResolver.rootElementStyle(), styleResolver.document().renderView(), 1.0f, true));
1670             styleResolver.state().setFontSizeHasViewportUnits(primitiveValue.isViewportPercentageLength());
1671         } else if (primitiveValue.isPercentage())
1672             size = (primitiveValue.floatValue() * parentSize) / 100.0f;
1673         else if (primitiveValue.isCalculatedPercentageWithLength()) {
1674             const auto&amp; conversionData = styleResolver.state().cssToLengthConversionData();
1675             CSSToLengthConversionData parentConversionData { styleResolver.parentStyle(), conversionData.rootStyle(), styleResolver.document().renderView(), 1.0f, true };
1676             size = primitiveValue.cssCalcValue()-&gt;createCalculationValue(parentConversionData)-&gt;evaluate(parentSize);
1677         } else
1678             return;
1679     }
1680 
1681     if (size &lt; 0)
1682         return;
1683 
1684     styleResolver.setFontSize(fontDescription, std::min(maximumAllowedFontSize, size));
1685     styleResolver.setFontDescription(WTFMove(fontDescription));
1686 }
1687 
1688 inline void StyleBuilderCustom::applyInitialGridTemplateAreas(StyleResolver&amp; styleResolver)
1689 {
1690     styleResolver.style()-&gt;setNamedGridArea(RenderStyle::initialNamedGridArea());
1691     styleResolver.style()-&gt;setNamedGridAreaRowCount(RenderStyle::initialNamedGridAreaCount());
1692     styleResolver.style()-&gt;setNamedGridAreaColumnCount(RenderStyle::initialNamedGridAreaCount());
1693 }
1694 
1695 inline void StyleBuilderCustom::applyInheritGridTemplateAreas(StyleResolver&amp; styleResolver)
1696 {
1697     styleResolver.style()-&gt;setNamedGridArea(styleResolver.parentStyle()-&gt;namedGridArea());
1698     styleResolver.style()-&gt;setNamedGridAreaRowCount(styleResolver.parentStyle()-&gt;namedGridAreaRowCount());
1699     styleResolver.style()-&gt;setNamedGridAreaColumnCount(styleResolver.parentStyle()-&gt;namedGridAreaColumnCount());
1700 }
1701 
1702 inline void StyleBuilderCustom::applyValueGridTemplateAreas(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1703 {
1704     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1705         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
1706         return;
1707     }
1708 
1709     auto&amp; gridTemplateAreasValue = downcast&lt;CSSGridTemplateAreasValue&gt;(value);
1710     const NamedGridAreaMap&amp; newNamedGridAreas = gridTemplateAreasValue.gridAreaMap();
1711 
1712     NamedGridLinesMap namedGridColumnLines = styleResolver.style()-&gt;namedGridColumnLines();
1713     NamedGridLinesMap namedGridRowLines = styleResolver.style()-&gt;namedGridRowLines();
1714     StyleBuilderConverter::createImplicitNamedGridLinesFromGridArea(newNamedGridAreas, namedGridColumnLines, ForColumns);
1715     StyleBuilderConverter::createImplicitNamedGridLinesFromGridArea(newNamedGridAreas, namedGridRowLines, ForRows);
1716     styleResolver.style()-&gt;setNamedGridColumnLines(namedGridColumnLines);
1717     styleResolver.style()-&gt;setNamedGridRowLines(namedGridRowLines);
1718 
1719     styleResolver.style()-&gt;setNamedGridArea(gridTemplateAreasValue.gridAreaMap());
1720     styleResolver.style()-&gt;setNamedGridAreaRowCount(gridTemplateAreasValue.rowCount());
1721     styleResolver.style()-&gt;setNamedGridAreaColumnCount(gridTemplateAreasValue.columnCount());
1722 }
1723 
1724 inline void StyleBuilderCustom::applyInitialGridTemplateColumns(StyleResolver&amp; styleResolver)
1725 {
1726     styleResolver.style()-&gt;setGridColumns(RenderStyle::initialGridColumns());
1727     styleResolver.style()-&gt;setNamedGridColumnLines(RenderStyle::initialNamedGridColumnLines());
1728     styleResolver.style()-&gt;setOrderedNamedGridColumnLines(RenderStyle::initialOrderedNamedGridColumnLines());
1729 }
1730 
1731 inline void StyleBuilderCustom::applyInheritGridTemplateColumns(StyleResolver&amp; styleResolver)
1732 {
1733     styleResolver.style()-&gt;setGridColumns(styleResolver.parentStyle()-&gt;gridColumns());
1734     styleResolver.style()-&gt;setNamedGridColumnLines(styleResolver.parentStyle()-&gt;namedGridColumnLines());
1735     styleResolver.style()-&gt;setOrderedNamedGridColumnLines(styleResolver.parentStyle()-&gt;orderedNamedGridColumnLines());
1736 }
1737 
1738 #define SET_TRACKS_DATA(tracksData, style, TrackType) \
1739     style-&gt;setGrid##TrackType##s(tracksData.m_trackSizes); \
1740     style-&gt;setNamedGrid##TrackType##Lines(tracksData.m_namedGridLines); \
1741     style-&gt;setOrderedNamedGrid##TrackType##Lines(tracksData.m_orderedNamedGridLines); \
1742     style-&gt;setGridAutoRepeat##TrackType##s(tracksData.m_autoRepeatTrackSizes); \
1743     style-&gt;setGridAutoRepeat##TrackType##sInsertionPoint(tracksData.m_autoRepeatInsertionPoint); \
1744     style-&gt;setAutoRepeatNamedGrid##TrackType##Lines(tracksData.m_autoRepeatNamedGridLines); \
1745     style-&gt;setAutoRepeatOrderedNamedGrid##TrackType##Lines(tracksData.m_autoRepeatOrderedNamedGridLines); \
1746     style-&gt;setGridAutoRepeat##TrackType##sType(tracksData.m_autoRepeatType); \
1747     style-&gt;setGridAutoRepeat##TrackType##sInsertionPoint(tracksData.m_autoRepeatInsertionPoint);
1748 
1749 inline void StyleBuilderCustom::applyValueGridTemplateColumns(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1750 {
1751     StyleBuilderConverter::TracksData tracksData;
1752     if (!StyleBuilderConverter::createGridTrackList(value, tracksData, styleResolver))
1753         return;
1754     const NamedGridAreaMap&amp; namedGridAreas = styleResolver.style()-&gt;namedGridArea();
1755     if (!namedGridAreas.isEmpty())
1756         StyleBuilderConverter::createImplicitNamedGridLinesFromGridArea(namedGridAreas, tracksData.m_namedGridLines, ForColumns);
1757 
1758     SET_TRACKS_DATA(tracksData, styleResolver.style(), Column);
1759 }
1760 
1761 inline void StyleBuilderCustom::applyInitialGridTemplateRows(StyleResolver&amp; styleResolver)
1762 {
1763     styleResolver.style()-&gt;setGridRows(RenderStyle::initialGridRows());
1764     styleResolver.style()-&gt;setNamedGridRowLines(RenderStyle::initialNamedGridRowLines());
1765     styleResolver.style()-&gt;setOrderedNamedGridRowLines(RenderStyle::initialOrderedNamedGridRowLines());
1766 }
1767 
1768 inline void StyleBuilderCustom::applyInheritGridTemplateRows(StyleResolver&amp; styleResolver)
1769 {
1770     styleResolver.style()-&gt;setGridRows(styleResolver.parentStyle()-&gt;gridRows());
1771     styleResolver.style()-&gt;setNamedGridRowLines(styleResolver.parentStyle()-&gt;namedGridRowLines());
1772     styleResolver.style()-&gt;setOrderedNamedGridRowLines(styleResolver.parentStyle()-&gt;orderedNamedGridRowLines());
1773 }
1774 
1775 inline void StyleBuilderCustom::applyValueGridTemplateRows(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1776 {
1777     StyleBuilderConverter::TracksData tracksData;
1778     if (!StyleBuilderConverter::createGridTrackList(value, tracksData, styleResolver))
1779         return;
1780     const NamedGridAreaMap&amp; namedGridAreas = styleResolver.style()-&gt;namedGridArea();
1781     if (!namedGridAreas.isEmpty())
1782         StyleBuilderConverter::createImplicitNamedGridLinesFromGridArea(namedGridAreas, tracksData.m_namedGridLines, ForRows);
1783 
1784     SET_TRACKS_DATA(tracksData, styleResolver.style(), Row);
1785 }
1786 
1787 void StyleBuilderCustom::applyValueAlt(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1788 {
1789     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1790     if (primitiveValue.isString())
1791         styleResolver.style()-&gt;setContentAltText(primitiveValue.stringValue());
1792     else if (primitiveValue.isAttr()) {
1793         // FIXME: Can a namespace be specified for an attr(foo)?
1794         if (styleResolver.style()-&gt;styleType() == PseudoId::None)
1795             styleResolver.style()-&gt;setUnique();
1796         else
1797             const_cast&lt;RenderStyle*&gt;(styleResolver.parentStyle())-&gt;setUnique();
1798 
1799         QualifiedName attr(nullAtom(), primitiveValue.stringValue(), nullAtom());
1800         const AtomicString&amp; value = styleResolver.element()-&gt;getAttribute(attr);
1801         styleResolver.style()-&gt;setContentAltText(value.isNull() ? emptyAtom() : value);
1802 
1803         // Register the fact that the attribute value affects the style.
1804         styleResolver.ruleSets().mutableFeatures().registerContentAttribute(attr.localName());
1805     } else
1806         styleResolver.style()-&gt;setContentAltText(emptyAtom());
1807 }
1808 
1809 inline void StyleBuilderCustom::applyValueWillChange(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1810 {
1811     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1812         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto);
1813         styleResolver.style()-&gt;setWillChange(nullptr);
1814         return;
1815     }
1816 
1817     auto willChange = WillChangeData::create();
1818     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
1819         if (!is&lt;CSSPrimitiveValue&gt;(item))
1820             continue;
1821         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(item.get());
1822         switch (primitiveValue.valueID()) {
1823         case CSSValueScrollPosition:
1824             willChange-&gt;addFeature(WillChangeData::Feature::ScrollPosition);
1825             break;
1826         case CSSValueContents:
1827             willChange-&gt;addFeature(WillChangeData::Feature::Contents);
1828             break;
1829         default:
1830             if (primitiveValue.isPropertyID())
1831                 willChange-&gt;addFeature(WillChangeData::Feature::Property, primitiveValue.propertyID());
1832             break;
1833         }
1834     }
1835     styleResolver.style()-&gt;setWillChange(WTFMove(willChange));
1836 }
1837 
1838 inline void StyleBuilderCustom::applyValueStrokeWidth(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1839 {
1840     styleResolver.style()-&gt;setStrokeWidth(StyleBuilderConverter::convertLength(styleResolver, value));
1841     styleResolver.style()-&gt;setHasExplicitlySetStrokeWidth(true);
1842 }
1843 
1844 inline void StyleBuilderCustom::applyValueStrokeColor(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1845 {
1846     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1847     if (styleResolver.applyPropertyToRegularStyle())
1848         styleResolver.style()-&gt;setStrokeColor(styleResolver.colorFromPrimitiveValue(primitiveValue, /* forVisitedLink */ false));
1849     if (styleResolver.applyPropertyToVisitedLinkStyle())
1850         styleResolver.style()-&gt;setVisitedLinkStrokeColor(styleResolver.colorFromPrimitiveValue(primitiveValue, /* forVisitedLink */ true));
1851     styleResolver.style()-&gt;setHasExplicitlySetStrokeColor(true);
1852 }
1853 
1854 inline void StyleBuilderCustom::applyInitialCustomProperty(StyleResolver&amp; styleResolver, const CSSRegisteredCustomProperty* registered, const AtomicString&amp; name)
1855 {
1856     if (registered &amp;&amp; registered-&gt;initialValue()) {
1857         auto initialValue = registered-&gt;initialValueCopy();
1858         applyValueCustomProperty(styleResolver, registered, *initialValue);
1859         return;
1860     }
1861 
1862     auto invalid = CSSCustomPropertyValue::createUnresolved(name, CSSValueInvalid);
1863     applyValueCustomProperty(styleResolver, registered, invalid.get());
1864 }
1865 
1866 inline void StyleBuilderCustom::applyInheritCustomProperty(StyleResolver&amp; styleResolver, const CSSRegisteredCustomProperty* registered, const AtomicString&amp; name)
1867 {
1868     auto* parentValue = styleResolver.parentStyle() ? styleResolver.parentStyle()-&gt;inheritedCustomProperties().get(name) : nullptr;
1869     if (parentValue &amp;&amp; !(registered &amp;&amp; !registered-&gt;inherits))
1870         applyValueCustomProperty(styleResolver, registered, *parentValue);
1871     else
1872         applyInitialCustomProperty(styleResolver, registered, name);
1873 }
1874 
1875 inline void StyleBuilderCustom::applyValueCustomProperty(StyleResolver&amp; styleResolver, const CSSRegisteredCustomProperty* registered, CSSCustomPropertyValue&amp; value)
1876 {
1877     ASSERT(value.isResolved());
1878     const auto&amp; name = value.name();
1879 
1880     if (!registered || registered-&gt;inherits)
1881         styleResolver.style()-&gt;setInheritedCustomPropertyValue(name, makeRef(value));
1882     else
1883         styleResolver.style()-&gt;setNonInheritedCustomPropertyValue(name, makeRef(value));
1884 }
1885 
1886 } // namespace WebCore
    </pre>
  </body>
</html>