diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp
@@ -27,18 +27,20 @@
 #include "SQLiteIDBBackingStore.h"
 
 #if ENABLE(INDEXED_DATABASE)
 
 #include "IDBBindingUtilities.h"
+#include "IDBCursorInfo.h"
 #include "IDBGetAllRecordsData.h"
 #include "IDBGetAllResult.h"
 #include "IDBGetRecordData.h"
 #include "IDBGetResult.h"
 #include "IDBIterateCursorData.h"
 #include "IDBKeyData.h"
 #include "IDBObjectStoreInfo.h"
 #include "IDBSerialization.h"
+#include "IDBSerializationContext.h"
 #include "IDBTransactionInfo.h"
 #include "IDBValue.h"
 #include "IndexKey.h"
 #include "Logging.h"
 #include "SQLiteDatabase.h"
@@ -46,15 +48,12 @@
 #include "SQLiteIDBCursor.h"
 #include "SQLiteStatement.h"
 #include "SQLiteTransaction.h"
 #include "ThreadSafeDataBuffer.h"
 #include <JavaScriptCore/AuxiliaryBarrierInlines.h>
-#include <JavaScriptCore/HeapInlines.h>
-#include <JavaScriptCore/JSCJSValueInlines.h>
-#include <JavaScriptCore/JSGlobalObject.h>
+#include <JavaScriptCore/JSCInlines.h>
 #include <JavaScriptCore/StrongInlines.h>
-#include <JavaScriptCore/StructureInlines.h>
 #include <wtf/FileSystem.h>
 #include <wtf/NeverDestroyed.h>
 #include <wtf/text/StringConcatenateNumbers.h>
 
 namespace WebCore {
@@ -228,52 +227,24 @@
 {
     static NeverDestroyed<String> blobFilesTableSchemaString(blobFilesTableSchema("\"BlobFiles\""));
     return blobFilesTableSchemaString;
 }
 
-SQLiteIDBBackingStore::SQLiteIDBBackingStore(const IDBDatabaseIdentifier& identifier, const String& databaseRootDirectory, IDBBackingStoreTemporaryFileHandler& fileHandler, uint64_t quota)
-    : m_identifier(identifier)
+SQLiteIDBBackingStore::SQLiteIDBBackingStore(PAL::SessionID sessionID, const IDBDatabaseIdentifier& identifier, const String& databaseRootDirectory, IDBBackingStoreTemporaryFileHandler& fileHandler)
+    : m_sessionID(sessionID)
+    , m_identifier(identifier)
+    , m_databaseRootDirectory(databaseRootDirectory)
     , m_temporaryFileHandler(fileHandler)
-    , m_quota(quota)
+    , m_serializationContext(IDBSerializationContext::getOrCreateIDBSerializationContext(sessionID))
 {
-    m_absoluteDatabaseDirectory = identifier.databaseDirectoryRelativeToRoot(databaseRootDirectory);
+    m_databaseDirectory = fullDatabaseDirectoryWithUpgrade();
 }
 
 SQLiteIDBBackingStore::~SQLiteIDBBackingStore()
 {
     if (m_sqliteDB)
         closeSQLiteDB();
-
-    if (m_vm) {
-        JSLockHolder locker(m_vm.get());
-        m_globalObject.clear();
-        m_vm = nullptr;
-    }
-}
-
-
-void SQLiteIDBBackingStore::initializeVM()
-{
-    if (!m_vm) {
-        ASSERT(!m_globalObject);
-        m_vm = VM::create();
-
-        JSLockHolder locker(m_vm.get());
-        m_globalObject.set(*m_vm, JSGlobalObject::create(*m_vm, JSGlobalObject::createStructure(*m_vm, jsNull())));
-    }
-}
-
-VM& SQLiteIDBBackingStore::vm()
-{
-    initializeVM();
-    return *m_vm;
-}
-
-JSGlobalObject& SQLiteIDBBackingStore::globalObject()
-{
-    initializeVM();
-    return **m_globalObject;
 }
 
 static bool createOrMigrateRecordsTableIfNecessary(SQLiteDatabase& database)
 {
     String currentSchema;
@@ -622,11 +593,11 @@
         closeSQLiteDB();
         return nullptr;
     }
 
     // This initial database info matches the default values we just put into the metadata database.
-    return std::make_unique<IDBDatabaseInfo>(m_identifier.databaseName(), 0);
+    return makeUnique<IDBDatabaseInfo>(m_identifier.databaseName(), 0);
 }
 
 std::unique_ptr<IDBDatabaseInfo> SQLiteIDBBackingStore::extractExistingDatabaseInfo()
 {
     ASSERT(m_sqliteDB);
@@ -657,11 +628,11 @@
             LOG_ERROR("Database version on disk ('%s') does not cleanly convert to an unsigned 64-bit integer version", stringVersion.utf8().data());
             return nullptr;
         }
     }
 
-    auto databaseInfo = std::make_unique<IDBDatabaseInfo>(databaseName, databaseVersion);
+    auto databaseInfo = makeUnique<IDBDatabaseInfo>(databaseName, databaseVersion);
 
     {
         SQLiteStatement sql(*m_sqliteDB, "SELECT id, name, keyPath, autoInc, maxIndexID FROM ObjectStoreInfo;"_s);
         if (sql.prepare() != SQLITE_OK)
             return nullptr;
@@ -762,22 +733,55 @@
     filename.replace('.', "%2E");
 
     return filename;
 }
 
-String SQLiteIDBBackingStore::fullDatabaseDirectory() const
+String SQLiteIDBBackingStore::fullDatabasePathForDirectory(const String& fullDatabaseDirectory)
 {
-    ASSERT(!m_identifier.databaseName().isNull());
-
-    return FileSystem::pathByAppendingComponent(m_absoluteDatabaseDirectory, filenameForDatabaseName());
+    return FileSystem::pathByAppendingComponent(fullDatabaseDirectory, "IndexedDB.sqlite3");
 }
 
 String SQLiteIDBBackingStore::fullDatabasePath() const
 {
-    ASSERT(!m_identifier.databaseName().isNull());
+    return fullDatabasePathForDirectory(m_databaseDirectory);
+}
 
-    return FileSystem::pathByAppendingComponent(fullDatabaseDirectory(), "IndexedDB.sqlite3");
+String SQLiteIDBBackingStore::databaseNameFromFile(const String& databasePath)
+{
+    SQLiteDatabase database;
+    if (!database.open(databasePath)) {
+        LOG_ERROR("Failed to open SQLite database at path '%s' when getting database name", databasePath.utf8().data());
+        return { };
+    }
+    if (!database.tableExists("IDBDatabaseInfo"_s)) {
+        LOG_ERROR("Could not find IDBDatabaseInfo table and get database name(%i) - %s", database.lastError(), database.lastErrorMsg());
+        database.close();
+        return { };
+    }
+    SQLiteStatement sql(database, "SELECT value FROM IDBDatabaseInfo WHERE key = 'DatabaseName';");
+    auto databaseName = sql.getColumnText(0);
+    database.close();
+    return databaseName;
+}
+
+String SQLiteIDBBackingStore::fullDatabaseDirectoryWithUpgrade()
+{
+    auto databaseRootDirectory = this->databaseRootDirectoryIsolatedCopy();
+    String oldOriginDirectory = m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectory, "v0");
+    String oldDatabaseDirectory = FileSystem::pathByAppendingComponent(oldOriginDirectory, filenameForDatabaseName());
+    String newOriginDirectory = m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectory, "v1");
+    String fileNameHash = SQLiteFileSystem::computeHashForFileName(m_identifier.databaseName());
+    Vector<String> directoriesWithSameHash = FileSystem::listDirectory(newOriginDirectory, fileNameHash + "*");
+    String newDatabaseDirectory = FileSystem::pathByAppendingComponent(newOriginDirectory, fileNameHash);
+    FileSystem::makeAllDirectories(newDatabaseDirectory);
+
+    if (FileSystem::fileExists(oldDatabaseDirectory)) {
+        FileSystem::moveFile(oldDatabaseDirectory, newDatabaseDirectory);
+        FileSystem::deleteEmptyDirectory(oldOriginDirectory);
+    }
+
+    return newDatabaseDirectory;
 }
 
 IDBError SQLiteIDBBackingStore::getOrEstablishDatabaseInfo(IDBDatabaseInfo& info)
 {
     LOG(IndexedDB, "SQLiteIDBBackingStore::getOrEstablishDatabaseInfo - database %s", m_identifier.databaseName().utf8().data());
@@ -785,14 +789,13 @@
     if (m_databaseInfo) {
         info = *m_databaseInfo;
         return IDBError { };
     }
 
-    FileSystem::makeAllDirectories(fullDatabaseDirectory());
     String dbFilename = fullDatabasePath();
 
-    m_sqliteDB = std::make_unique<SQLiteDatabase>();
+    m_sqliteDB = makeUnique<SQLiteDatabase>();
     if (!m_sqliteDB->open(dbFilename)) {
         LOG_ERROR("Failed to open SQLite database at path '%s'", dbFilename.utf8().data());
         closeSQLiteDB();
     }
 
@@ -840,69 +843,51 @@
     m_databaseInfo = WTFMove(databaseInfo);
     info = *m_databaseInfo;
     return IDBError { };
 }
 
-uint64_t SQLiteIDBBackingStore::quotaForOrigin() const
-{
-    ASSERT(!isMainThread());
-    uint64_t diskFreeSpaceSize = 0;
-    FileSystem::getVolumeFreeSpace(m_absoluteDatabaseDirectory, diskFreeSpaceSize);
-    return std::min(diskFreeSpaceSize / 2, m_quota);
-}
-
-uint64_t SQLiteIDBBackingStore::maximumSize() const
+uint64_t SQLiteIDBBackingStore::databasesSizeForDirectory(const String& directory)
 {
-    ASSERT(!isMainThread());
-
-    // The maximum size for one database file is the quota for its origin, minus size of all databases within that origin,
-    // and plus current size of the database file.
-    uint64_t databaseFileSize = SQLiteFileSystem::getDatabaseFileSize(fullDatabasePath());
-    uint64_t quota = quotaForOrigin();
-
     uint64_t diskUsage = 0;
-    for (auto& directory : FileSystem::listDirectory(m_absoluteDatabaseDirectory, "*")) {
-        for (auto& file : FileSystem::listDirectory(directory, "*.sqlite3"_s))
+    for (auto& dbDirectory : FileSystem::listDirectory(directory, "*")) {
+        for (auto& file : FileSystem::listDirectory(dbDirectory, "*.sqlite3"_s))
             diskUsage += SQLiteFileSystem::getDatabaseFileSize(file);
     }
-    ASSERT(diskUsage >= databaseFileSize);
-
-    if (quota < diskUsage)
-        return databaseFileSize;
+    return diskUsage;
+}
 
-    return quota - diskUsage + databaseFileSize;
+uint64_t SQLiteIDBBackingStore::databaseSize() const
+{
+    ASSERT(!isMainThread());
+    return SQLiteFileSystem::getDatabaseFileSize(fullDatabasePath());
 }
 
 IDBError SQLiteIDBBackingStore::beginTransaction(const IDBTransactionInfo& info)
 {
     LOG(IndexedDB, "SQLiteIDBBackingStore::beginTransaction - %s", info.identifier().loggingString().utf8().data());
 
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
     ASSERT(m_databaseInfo);
 
-    m_sqliteDB->setMaximumSize(maximumSize());
     auto addResult = m_transactions.add(info.identifier(), nullptr);
     if (!addResult.isNewEntry) {
         LOG_ERROR("Attempt to establish transaction identifier that already exists");
         return IDBError { UnknownError, "Attempt to establish transaction identifier that already exists"_s };
     }
 
-    addResult.iterator->value = std::make_unique<SQLiteIDBTransaction>(*this, info);
+    addResult.iterator->value = makeUnique<SQLiteIDBTransaction>(*this, info);
 
     auto error = addResult.iterator->value->begin(*m_sqliteDB);
     if (error.isNull() && info.mode() == IDBTransactionMode::Versionchange) {
-        m_originalDatabaseInfoBeforeVersionChange = std::make_unique<IDBDatabaseInfo>(*m_databaseInfo);
+        m_originalDatabaseInfoBeforeVersionChange = makeUnique<IDBDatabaseInfo>(*m_databaseInfo);
 
         SQLiteStatement sql(*m_sqliteDB, "UPDATE IDBDatabaseInfo SET value = ? where key = 'DatabaseVersion';"_s);
         if (sql.prepare() != SQLITE_OK
             || sql.bindText(1, String::number(info.newVersion())) != SQLITE_OK
             || sql.step() != SQLITE_DONE) {
-            if (m_sqliteDB->lastError() == SQLITE_FULL)
-                error = IDBError { QuotaExceededError, "Failed to store new database version in database because no enough space for domain"_s };
-            else
-                error = IDBError { UnknownError, "Failed to store new database version in database"_s };
+            error = IDBError { UnknownError, "Failed to store new database version in database"_s };
         }
     }
 
     return error;
 }
@@ -957,14 +942,13 @@
 
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to create an object store without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to create an object store without an in-progress transaction"_s };
-    }
+
     if (transaction->mode() != IDBTransactionMode::Versionchange) {
         LOG_ERROR("Attempt to create an object store in a non-version-change transaction");
         return IDBError { UnknownError, "Attempt to create an object store in a non-version-change transaction"_s };
     }
 
@@ -982,24 +966,20 @@
             || sql->bindBlob(3, keyPathBlob->data(), keyPathBlob->size()) != SQLITE_OK
             || sql->bindInt(4, info.autoIncrement()) != SQLITE_OK
             || sql->bindInt64(5, info.maxIndexID()) != SQLITE_OK
             || sql->step() != SQLITE_DONE) {
             LOG_ERROR("Could not add object store '%s' to ObjectStoreInfo table (%i) - %s", info.name().utf8().data(), m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
-            if (m_sqliteDB->lastError() == SQLITE_FULL)
-                return IDBError { QuotaExceededError, "Could not create object store because no enough space for domain"_s };
             return IDBError { UnknownError, "Could not create object store"_s };
         }
     }
 
     {
         auto* sql = cachedStatement(SQL::CreateObjectStoreKeyGenerator, "INSERT INTO KeyGenerators VALUES (?, 0);"_s);
         if (!sql
             || sql->bindInt64(1, info.identifier()) != SQLITE_OK
             || sql->step() != SQLITE_DONE) {
             LOG_ERROR("Could not seed initial key generator value for ObjectStoreInfo table (%i) - %s", m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
-            if (m_sqliteDB->lastError() == SQLITE_FULL)
-                return IDBError { QuotaExceededError, "Could not seed initial key generator value for object store because no enough space for domain"_s };
             return IDBError { UnknownError, "Could not seed initial key generator value for object store"_s };
         }
     }
 
     m_databaseInfo->addExistingObjectStore(info);
@@ -1013,14 +993,13 @@
 
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to delete an object store without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to delete an object store without an in-progress transaction"_s };
-    }
+
     if (transaction->mode() != IDBTransactionMode::Versionchange) {
         LOG_ERROR("Attempt to delete an object store in a non-version-change transaction");
         return IDBError { UnknownError, "Attempt to delete an object store in a non-version-change transaction"_s };
     }
 
@@ -1105,14 +1084,13 @@
 
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to rename an object store without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to rename an object store without an in-progress transaction"_s };
-    }
+
     if (transaction->mode() != IDBTransactionMode::Versionchange) {
         LOG_ERROR("Attempt to rename an object store in a non-version-change transaction");
         return IDBError { UnknownError, "Attempt to rename an object store in a non-version-change transaction"_s };
     }
 
@@ -1121,12 +1099,10 @@
         if (!sql
             || sql->bindText(1, newName) != SQLITE_OK
             || sql->bindInt64(2, objectStoreIdentifier) != SQLITE_OK
             || sql->step() != SQLITE_DONE) {
             LOG_ERROR("Could not update name for object store id %" PRIi64 " in ObjectStoreInfo table (%i) - %s", objectStoreIdentifier, m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
-            if (m_sqliteDB->lastError() == SQLITE_FULL)
-                return IDBError { QuotaExceededError, "Could not rename object store because no enough space for domain"_s };
             return IDBError { UnknownError, "Could not rename object store"_s };
         }
     }
 
     m_databaseInfo->renameObjectStore(objectStoreIdentifier, newName);
@@ -1140,14 +1116,13 @@
 
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to clear an object store without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to clear an object store without an in-progress transaction"_s };
-    }
+
     if (transaction->mode() == IDBTransactionMode::Readonly) {
         LOG_ERROR("Attempt to clear an object store in a read-only transaction");
         return IDBError { UnknownError, "Attempt to clear an object store in a read-only transaction"_s };
     }
 
@@ -1181,14 +1156,13 @@
     LOG(IndexedDB, "SQLiteIDBBackingStore::createIndex - ObjectStore %" PRIu64 ", Index %" PRIu64, info.objectStoreIdentifier(), info.identifier());
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to create an index without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to create an index without an in-progress transaction"_s };
-    }
+
     if (transaction->mode() != IDBTransactionMode::Versionchange) {
         LOG_ERROR("Attempt to create an index in a non-version-change transaction");
         return IDBError { UnknownError, "Attempt to create an index in a non-version-change transaction"_s };
     }
 
@@ -1206,12 +1180,10 @@
         || sql->bindBlob(4, keyPathBlob->data(), keyPathBlob->size()) != SQLITE_OK
         || sql->bindInt(5, info.unique()) != SQLITE_OK
         || sql->bindInt(6, info.multiEntry()) != SQLITE_OK
         || sql->step() != SQLITE_DONE) {
         LOG_ERROR("Could not add index '%s' to IndexInfo table (%i) - %s", info.name().utf8().data(), m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
-        if (m_sqliteDB->lastError() == SQLITE_FULL)
-            return IDBError { QuotaExceededError, "Unable to create index in database because no enough space for domain"_s };
         return IDBError { UnknownError, "Unable to create index in database"_s };
     }
 
     // Write index records for any records that already exist in this object store.
 
@@ -1247,10 +1219,16 @@
             LOG_ERROR("Error advancing cursor while indexing existing records for new index.");
             return IDBError { UnknownError, "Error advancing cursor while indexing existing records for new index"_s };
         }
     }
 
+    ASSERT(m_databaseInfo);
+    if (!m_databaseInfo) {
+        RELEASE_LOG_ERROR(IndexedDB, "%p - SQLiteIDBBackingStore::clearObjectStore: m_databaseInfo is null", this);
+        return IDBError { UnknownError, "Database info is invalid"_s };
+    }
+
     auto* objectStore = m_databaseInfo->infoForExistingObjectStore(info.objectStoreIdentifier());
     ASSERT(objectStore);
     objectStore->addExistingIndex(info);
 
     return IDBError { };
@@ -1350,12 +1328,10 @@
             || sql->bindBlob(3, indexKeyBuffer->data(), indexKeyBuffer->size()) != SQLITE_OK
             || sql->bindBlob(4, valueBuffer->data(), valueBuffer->size()) != SQLITE_OK
             || sql->bindInt64(5, recordID) != SQLITE_OK
             || sql->step() != SQLITE_DONE) {
             LOG_ERROR("Could not put index record for index %" PRIi64 " in object store %" PRIi64 " in Records table (%i) - %s", indexID, objectStoreID, m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
-            if (m_sqliteDB->lastError() == SQLITE_FULL)
-                return IDBError { QuotaExceededError, "Error putting index record into database because no enough space for domain"_s };
             return IDBError { UnknownError, "Error putting index record into database"_s };
         }
     }
 
     return IDBError { };
@@ -1368,14 +1344,12 @@
 
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to delete index without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to delete index without an in-progress transaction"_s };
-    }
 
     if (transaction->mode() != IDBTransactionMode::Versionchange) {
         LOG_ERROR("Attempt to delete index during a non-version-change transaction");
         return IDBError { UnknownError, "Attempt to delete index during a non-version-change transaction"_s };
     }
@@ -1423,14 +1397,12 @@
     auto* indexInfo = objectStoreInfo->infoForExistingIndex(indexIdentifier);
     if (!indexInfo)
         return IDBError { UnknownError, "Could not rename index"_s };
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to rename an index without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to rename an index without an in-progress transaction"_s };
-    }
 
     if (transaction->mode() != IDBTransactionMode::Versionchange) {
         LOG_ERROR("Attempt to rename an index in a non-version-change transaction");
         return IDBError { UnknownError, "Attempt to rename an index in a non-version-change transaction"_s };
     }
@@ -1441,12 +1413,10 @@
             || sql->bindText(1, newName) != SQLITE_OK
             || sql->bindInt64(2, objectStoreIdentifier) != SQLITE_OK
             || sql->bindInt64(3, indexIdentifier) != SQLITE_OK
             || sql->step() != SQLITE_DONE) {
             LOG_ERROR("Could not update name for index id (%" PRIi64 ", %" PRIi64 ") in IndexInfo table (%i) - %s", objectStoreIdentifier, indexIdentifier, m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
-            if (m_sqliteDB->lastError() == SQLITE_FULL)
-                return IDBError { QuotaExceededError, "Could not rename index because no enough space for domain"_s };
             return IDBError { UnknownError, "Could not rename index"_s };
         }
     }
 
     indexInfo->rename(newName);
@@ -1462,14 +1432,12 @@
     ASSERT(m_sqliteDB->isOpen());
 
     keyExists = false;
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to see if key exists in objectstore without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to see if key exists in objectstore without an in-progress transaction"_s };
-    }
 
     RefPtr<SharedBuffer> keyBuffer = serializeIDBKeyData(keyData);
     if (!keyBuffer) {
         LOG_ERROR("Unable to serialize IDBKey to check for existence in object store");
         return IDBError { UnknownError, "Unable to serialize IDBKey to check for existence in object store"_s };
@@ -1637,14 +1605,13 @@
 
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to delete range from database without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to delete range from database without an in-progress transaction"_s };
-    }
+
     if (transaction->mode() == IDBTransactionMode::Readonly) {
         LOG_ERROR("Attempt to delete records from an object store in a read-only transaction");
         return IDBError { UnknownError, "Attempt to delete records from an object store in a read-only transaction"_s };
     }
 
@@ -1692,38 +1659,40 @@
     return error;
 }
 
 IDBError SQLiteIDBBackingStore::updateOneIndexForAddRecord(const IDBIndexInfo& info, const IDBKeyData& key, const ThreadSafeDataBuffer& value, int64_t recordID)
 {
-    JSLockHolder locker(vm());
+    JSLockHolder locker(m_serializationContext->vm());
 
-    auto jsValue = deserializeIDBValueToJSValue(*globalObject().globalExec(), value);
+    auto jsValue = deserializeIDBValueToJSValue(m_serializationContext->execState(), value);
     if (jsValue.isUndefinedOrNull())
         return IDBError { };
 
     IndexKey indexKey;
-    generateIndexKeyForValue(*m_globalObject->globalExec(), info, jsValue, indexKey);
+    auto* objectStoreInfo = infoForObjectStore(info.objectStoreIdentifier());
+    ASSERT(objectStoreInfo);
+    generateIndexKeyForValue(m_serializationContext->execState(), info, jsValue, indexKey, objectStoreInfo->keyPath(), key);
 
     if (indexKey.isNull())
         return IDBError { };
 
     return uncheckedPutIndexKey(info, key, indexKey, recordID);
 }
 
 IDBError SQLiteIDBBackingStore::updateAllIndexesForAddRecord(const IDBObjectStoreInfo& info, const IDBKeyData& key, const ThreadSafeDataBuffer& value, int64_t recordID)
 {
-    JSLockHolder locker(vm());
+    JSLockHolder locker(m_serializationContext->vm());
 
-    auto jsValue = deserializeIDBValueToJSValue(*globalObject().globalExec(), value);
+    auto jsValue = deserializeIDBValueToJSValue(m_serializationContext->execState(), value);
     if (jsValue.isUndefinedOrNull())
         return IDBError { };
 
     IDBError error;
     bool anyRecordsSucceeded = false;
     for (auto& index : info.indexMap().values()) {
         IndexKey indexKey;
-        generateIndexKeyForValue(*m_globalObject->globalExec(), index, jsValue, indexKey);
+        generateIndexKeyForValue(m_serializationContext->execState(), index, jsValue, indexKey, info.keyPath(), key);
 
         if (indexKey.isNull())
             continue;
 
         error = uncheckedPutIndexKey(index, key, indexKey, recordID);
@@ -1758,14 +1727,13 @@
     ASSERT(m_sqliteDB->isOpen());
     ASSERT(value.data().data());
     ASSERT(value.blobURLs().size() == value.blobFilePaths().size());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to store a record in an object store without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to store a record in an object store without an in-progress transaction"_s };
-    }
+
     if (transaction->mode() == IDBTransactionMode::Readonly) {
         LOG_ERROR("Attempt to store a record in an object store in a read-only transaction");
         return IDBError { UnknownError, "Attempt to store a record in an object store in a read-only transaction"_s };
     }
 
@@ -1782,12 +1750,10 @@
             || sql->bindInt64(1, objectStoreInfo.identifier()) != SQLITE_OK
             || sql->bindBlob(2, keyBuffer->data(), keyBuffer->size()) != SQLITE_OK
             || sql->bindBlob(3, value.data().data()->data(), value.data().data()->size()) != SQLITE_OK
             || sql->step() != SQLITE_DONE) {
             LOG_ERROR("Could not put record for object store %" PRIi64 " in Records table (%i) - %s", objectStoreInfo.identifier(), m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
-            if (m_sqliteDB->lastError() == SQLITE_FULL)
-                return IDBError { QuotaExceededError, "Unable to store record in object store because no enough space for domain"_s };
             return IDBError { UnknownError, "Unable to store record in object store"_s };
         }
 
         recordID = m_sqliteDB->lastInsertRowID();
     }
@@ -1816,12 +1782,10 @@
             if (!sql
                 || sql->bindInt64(1, recordID) != SQLITE_OK
                 || sql->bindText(2, url) != SQLITE_OK
                 || sql->step() != SQLITE_DONE) {
                 LOG_ERROR("Unable to record Blob record in database");
-                if (m_sqliteDB->lastError() == SQLITE_FULL)
-                    return IDBError { QuotaExceededError, "Unable to record Blob record in database because no enough space for domain"_s };
                 return IDBError { UnknownError, "Unable to record Blob record in database"_s };
             }
         }
         int64_t potentialFileNameInteger = m_sqliteDB->lastInsertRowID();
 
@@ -1851,12 +1815,10 @@
             if (!sql
                 || sql->bindText(1, url) != SQLITE_OK
                 || sql->bindText(2, storedFilename) != SQLITE_OK
                 || sql->step() != SQLITE_DONE) {
                 LOG_ERROR("Unable to record Blob file record in database");
-                if (m_sqliteDB->lastError() == SQLITE_FULL)
-                    return IDBError { QuotaExceededError, "Unable to record Blob file in database because no enough space for domain"_s };
                 return IDBError { UnknownError, "Unable to record Blob file record in database"_s };
             }
         }
 
         transaction->addBlobFile(blobFiles[i], storedFilename);
@@ -1865,11 +1827,11 @@
     transaction->notifyCursorsOfChanges(objectStoreInfo.identifier());
 
     return error;
 }
 
-IDBError SQLiteIDBBackingStore::getBlobRecordsForObjectStoreRecord(int64_t objectStoreRecord, Vector<String>& blobURLs, PAL::SessionID& sessionID, Vector<String>& blobFilePaths)
+IDBError SQLiteIDBBackingStore::getBlobRecordsForObjectStoreRecord(int64_t objectStoreRecord, Vector<String>& blobURLs, Vector<String>& blobFilePaths)
 {
     ASSERT(objectStoreRecord);
 
     HashSet<String> blobURLSet;
     {
@@ -1896,11 +1858,10 @@
             return IDBError { UnknownError, "Failed to look up blobURL records in object store by key range"_s };
         }
     }
 
     ASSERT(!blobURLSet.isEmpty());
-    String databaseDirectory = fullDatabaseDirectory();
     for (auto& blobURL : blobURLSet) {
         auto* sql = cachedStatement(SQL::BlobFilenameForBlobURL, "SELECT fileName FROM BlobFiles WHERE blobURL = ?;"_s);
         if (!sql
             || sql->bindText(1, blobURL) != SQLITE_OK) {
             LOG_ERROR("Could not prepare statement to fetch blob filename for object store record (%i) - %s", m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
@@ -1913,14 +1874,12 @@
         }
 
         blobURLs.append(blobURL);
 
         String fileName = sql->getColumnText(0);
-        blobFilePaths.append(FileSystem::pathByAppendingComponent(databaseDirectory, fileName));
+        blobFilePaths.append(FileSystem::pathByAppendingComponent(m_databaseDirectory, fileName));
     }
-    sessionID = m_identifier.sessionID();
-
     return IDBError { };
 }
 
 IDBError SQLiteIDBBackingStore::getRecord(const IDBResourceIdentifier& transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData& keyRange, IDBGetRecordDataType type, IDBGetResult& resultValue)
 {
@@ -1928,14 +1887,12 @@
 
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to get a record from database without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to get a record from database without an in-progress transaction"_s };
-    }
 
     auto key = keyRange.lowerKey;
     if (key.isNull())
         key = IDBKeyData::minimum();
     RefPtr<SharedBuffer> lowerBuffer = serializeIDBKeyData(key);
@@ -1952,16 +1909,16 @@
         LOG_ERROR("Unable to serialize upper IDBKey in lookup range");
         return IDBError { UnknownError, "Unable to serialize upper IDBKey in lookup range"_s };
     }
 
     int64_t recordID = 0;
-    ThreadSafeDataBuffer resultBuffer;
+    ThreadSafeDataBuffer keyResultBuffer, valueResultBuffer;
     {
-        static const char* const lowerOpenUpperOpen = "SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key > CAST(? AS TEXT) AND key < CAST(? AS TEXT) ORDER BY key;";
-        static const char* const lowerOpenUpperClosed = "SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key > CAST(? AS TEXT) AND key <= CAST(? AS TEXT) ORDER BY key;";
-        static const char* const lowerClosedUpperOpen = "SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key >= CAST(? AS TEXT) AND key < CAST(? AS TEXT) ORDER BY key;";
-        static const char* const lowerClosedUpperClosed = "SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key >= CAST(? AS TEXT) AND key <= CAST(? AS TEXT) ORDER BY key;";
+        static const char* const lowerOpenUpperOpen = "SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key > CAST(? AS TEXT) AND key < CAST(? AS TEXT) ORDER BY key;";
+        static const char* const lowerOpenUpperClosed = "SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key > CAST(? AS TEXT) AND key <= CAST(? AS TEXT) ORDER BY key;";
+        static const char* const lowerClosedUpperOpen = "SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key >= CAST(? AS TEXT) AND key < CAST(? AS TEXT) ORDER BY key;";
+        static const char* const lowerClosedUpperClosed = "SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key >= CAST(? AS TEXT) AND key <= CAST(? AS TEXT) ORDER BY key;";
 
         static const char* const lowerOpenUpperOpenKeyOnly = "SELECT key FROM Records WHERE objectStoreID = ? AND key > CAST(? AS TEXT) AND key < CAST(? AS TEXT) ORDER BY key;";
         static const char* const lowerOpenUpperClosedKeyOnly = "SELECT key FROM Records WHERE objectStoreID = ? AND key > CAST(? AS TEXT) AND key <= CAST(? AS TEXT) ORDER BY key;";
         static const char* const lowerClosedUpperOpenKeyOnly = "SELECT key FROM Records WHERE objectStoreID = ? AND key >= CAST(? AS TEXT) AND key < CAST(? AS TEXT) ORDER BY key;";
         static const char* const lowerClosedUpperClosedKeyOnly = "SELECT key FROM Records WHERE objectStoreID = ? AND key >= CAST(? AS TEXT) AND key <= CAST(? AS TEXT) ORDER BY key;";
@@ -2014,45 +1971,50 @@
             // There was an error fetching the record from the database.
             LOG_ERROR("Could not get record from object store %" PRIi64 " from Records table (%i) - %s", objectStoreID, m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
             return IDBError { UnknownError, "Error looking up record in object store by key range"_s };
         }
 
-        Vector<uint8_t> buffer;
-        sql->getColumnBlobAsVector(0, buffer);
-        resultBuffer = ThreadSafeDataBuffer::create(WTFMove(buffer));
+        Vector<uint8_t> keyBuffer;
+        sql->getColumnBlobAsVector(0, keyBuffer);
+        keyResultBuffer = ThreadSafeDataBuffer::create(WTFMove(keyBuffer));
 
-        if (type == IDBGetRecordDataType::KeyAndValue)
-            recordID = sql->getColumnInt64(1);
+        if (type == IDBGetRecordDataType::KeyAndValue) {
+            Vector<uint8_t> valueBuffer;
+            sql->getColumnBlobAsVector(1, valueBuffer);
+            valueResultBuffer = ThreadSafeDataBuffer::create(WTFMove(valueBuffer));
+            recordID = sql->getColumnInt64(2);
+        }
     }
 
-    if (type == IDBGetRecordDataType::KeyOnly) {
-        auto* vector = resultBuffer.data();
-        if (!vector) {
-            LOG_ERROR("Unable to deserialize key data from database for IDBObjectStore.getKey()");
-            return IDBError { UnknownError, "Error extracting key data from database executing IDBObjectStore.getKey()"_s };
-        }
+    auto* keyVector = keyResultBuffer.data();
+    if (!keyVector) {
+        LOG_ERROR("Unable to deserialize key data from database for IDBObjectStore");
+        return IDBError { UnknownError, "Error extracting key data from database executing IDBObjectStore get"_s };
+    }
 
-        IDBKeyData keyData;
-        if (!deserializeIDBKeyData(vector->data(), vector->size(), keyData)) {
-            LOG_ERROR("Unable to deserialize key data from database for IDBObjectStore.getKey()");
-            return IDBError { UnknownError, "Error extracting key data from database executing IDBObjectStore.getKey()"_s };
-        }
+    IDBKeyData keyData;
+    if (!deserializeIDBKeyData(keyVector->data(), keyVector->size(), keyData)) {
+        LOG_ERROR("Unable to deserialize key data from database for IDBObjectStore");
+        return IDBError { UnknownError, "Error extracting key data from database executing IDBObjectStore get"_s };
+    }
 
+    if (type == IDBGetRecordDataType::KeyOnly) {
         resultValue = { keyData };
         return IDBError { };
     }
 
     ASSERT(recordID);
     Vector<String> blobURLs, blobFilePaths;
-    PAL::SessionID sessionID;
-    auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, sessionID, blobFilePaths);
+    auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);
     ASSERT(blobURLs.size() == blobFilePaths.size());
 
     if (!error.isNull())
         return error;
 
-    resultValue = { { resultBuffer, WTFMove(blobURLs), sessionID, WTFMove(blobFilePaths) } };
+    auto* objectStoreInfo = infoForObjectStore(objectStoreID);
+    ASSERT(objectStoreInfo);
+    resultValue = { keyData, { valueResultBuffer, WTFMove(blobURLs), WTFMove(blobFilePaths) }, objectStoreInfo->keyPath()};
     return IDBError { };
 }
 
 IDBError SQLiteIDBBackingStore::getAllRecords(const IDBResourceIdentifier& transactionIdentifier, const IDBGetAllRecordsData& getAllRecordsData, IDBGetAllResult& result)
 {
@@ -2063,14 +2025,14 @@
 {
     static const char* const lowerOpenUpperOpenKey ="SELECT key FROM Records WHERE objectStoreID = ? AND key > CAST(? AS TEXT) AND key < CAST(? AS TEXT) ORDER BY key;";
     static const char* const lowerOpenUpperClosedKey = "SELECT key FROM Records WHERE objectStoreID = ? AND key > CAST(? AS TEXT) AND key <= CAST(? AS TEXT) ORDER BY key;";
     static const char* const lowerClosedUpperOpenKey = "SELECT key FROM Records WHERE objectStoreID = ? AND key >= CAST(? AS TEXT) AND key < CAST(? AS TEXT) ORDER BY key;";
     static const char* const lowerClosedUpperClosedKey = "SELECT key FROM Records WHERE objectStoreID = ? AND key >= CAST(? AS TEXT) AND key <= CAST(? AS TEXT) ORDER BY key;";
-    static const char* const lowerOpenUpperOpenValue = "SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key > CAST(? AS TEXT) AND key < CAST(? AS TEXT) ORDER BY key;";
-    static const char* const lowerOpenUpperClosedValue = "SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key > CAST(? AS TEXT) AND key <= CAST(? AS TEXT) ORDER BY key;";
-    static const char* const lowerClosedUpperOpenValue = "SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key >= CAST(? AS TEXT) AND key < CAST(? AS TEXT) ORDER BY key;";
-    static const char* const lowerClosedUpperClosedValue = "SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key >= CAST(? AS TEXT) AND key <= CAST(? AS TEXT) ORDER BY key;";
+    static const char* const lowerOpenUpperOpenValue = "SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key > CAST(? AS TEXT) AND key < CAST(? AS TEXT) ORDER BY key;";
+    static const char* const lowerOpenUpperClosedValue = "SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key > CAST(? AS TEXT) AND key <= CAST(? AS TEXT) ORDER BY key;";
+    static const char* const lowerClosedUpperOpenValue = "SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key >= CAST(? AS TEXT) AND key < CAST(? AS TEXT) ORDER BY key;";
+    static const char* const lowerClosedUpperClosedValue = "SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key >= CAST(? AS TEXT) AND key <= CAST(? AS TEXT) ORDER BY key;";
 
     if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Keys) {
         if (getAllRecordsData.keyRangeData.lowerOpen) {
             if (getAllRecordsData.keyRangeData.upperOpen)
                 return cachedStatement(SQL::GetAllKeyRecordsLowerOpenUpperOpen, lowerOpenUpperOpenKey);
@@ -2099,14 +2061,12 @@
 
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to get records from database without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to get records from database without an in-progress transaction"_s };
-    }
 
     auto key = getAllRecordsData.keyRangeData.lowerKey;
     if (key.isNull())
         key = IDBKeyData::minimum();
     auto lowerBuffer = serializeIDBKeyData(key);
@@ -2131,11 +2091,13 @@
         || sql->bindBlob(3, upperBuffer->data(), upperBuffer->size()) != SQLITE_OK) {
         LOG_ERROR("Could not get key range record from object store %" PRIi64 " from Records table (%i) - %s", getAllRecordsData.objectStoreIdentifier, m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
         return IDBError { UnknownError, "Failed to look up record in object store by key range"_s };
     }
 
-    result = { getAllRecordsData.getAllType };
+    auto* objectStoreInfo = infoForObjectStore(getAllRecordsData.objectStoreIdentifier);
+    ASSERT(objectStoreInfo);
+    result = { getAllRecordsData.getAllType, objectStoreInfo->keyPath() };
 
     uint32_t targetResults;
     if (getAllRecordsData.count && getAllRecordsData.count.value())
         targetResults = getAllRecordsData.count.value();
     else
@@ -2143,38 +2105,35 @@
 
     int sqlResult = sql->step();
     uint32_t returnedResults = 0;
 
     while (sqlResult == SQLITE_ROW && returnedResults < targetResults) {
+        Vector<uint8_t> keyBuffer;
+        IDBKeyData keyData;
+        sql->getColumnBlobAsVector(0, keyBuffer);
+        if (!deserializeIDBKeyData(keyBuffer.data(), keyBuffer.size(), keyData)) {
+            LOG_ERROR("Unable to deserialize key data from database while getting all records");
+            return IDBError { UnknownError, "Unable to deserialize key data while getting all records"_s };
+        }
+        result.addKey(WTFMove(keyData));
+
         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values) {
-            Vector<uint8_t> buffer;
-            sql->getColumnBlobAsVector(0, buffer);
-            ThreadSafeDataBuffer resultBuffer = ThreadSafeDataBuffer::create(WTFMove(buffer));
+            Vector<uint8_t> valueBuffer;
+            sql->getColumnBlobAsVector(1, valueBuffer);
+            ThreadSafeDataBuffer valueResultBuffer = ThreadSafeDataBuffer::create(WTFMove(valueBuffer));
 
-            auto recordID = sql->getColumnInt64(1);
+            auto recordID = sql->getColumnInt64(2);
 
             ASSERT(recordID);
             Vector<String> blobURLs, blobFilePaths;
-            PAL::SessionID sessionID;
-            auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, sessionID, blobFilePaths);
+            auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);
             ASSERT(blobURLs.size() == blobFilePaths.size());
 
             if (!error.isNull())
                 return error;
 
-            result.addValue({ resultBuffer, WTFMove(blobURLs), sessionID, WTFMove(blobFilePaths) });
-        } else {
-            Vector<uint8_t> keyData;
-            IDBKeyData key;
-            sql->getColumnBlobAsVector(0, keyData);
-
-            if (!deserializeIDBKeyData(keyData.data(), keyData.size(), key)) {
-                LOG_ERROR("Unable to deserialize key data from database while getting all key records");
-                return IDBError { UnknownError, "Unable to deserialize key data while getting all key records"_s };
-            }
-
-            result.addKey(WTFMove(key));
+            result.addValue({ valueResultBuffer, WTFMove(blobURLs), WTFMove(blobFilePaths) });
         }
 
         ++returnedResults;
         sqlResult = sql->step();
     }
@@ -2195,14 +2154,12 @@
 
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to get all index records from database without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to get all index records from database without an in-progress transaction"_s };
-    }
 
     auto cursor = transaction->maybeOpenBackingStoreCursor(getAllRecordsData.objectStoreIdentifier, getAllRecordsData.indexIdentifier, getAllRecordsData.keyRangeData);
     if (!cursor) {
         LOG_ERROR("Cannot open cursor to perform index gets in database");
         return IDBError { UnknownError, "Cannot open cursor to perform index gets in database"_s };
@@ -2211,20 +2168,22 @@
     if (cursor->didError()) {
         LOG_ERROR("Cursor failed while looking up index records in database");
         return IDBError { UnknownError, "Cursor failed while looking up index records in database"_s };
     }
 
-    result = { getAllRecordsData.getAllType };
+    auto* objectStoreInfo = infoForObjectStore(getAllRecordsData.objectStoreIdentifier);
+    ASSERT(objectStoreInfo);
+    result = { getAllRecordsData.getAllType, objectStoreInfo->keyPath() };
+
     uint32_t currentCount = 0;
     uint32_t targetCount = getAllRecordsData.count ? getAllRecordsData.count.value() : 0;
     if (!targetCount)
         targetCount = std::numeric_limits<uint32_t>::max();
     while (!cursor->didComplete() && !cursor->didError() && currentCount < targetCount) {
-        if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Keys) {
-            IDBKeyData keyCopy = cursor->currentPrimaryKey();
-            result.addKey(WTFMove(keyCopy));
-        } else
+        IDBKeyData keyCopy = cursor->currentPrimaryKey();
+        result.addKey(WTFMove(keyCopy));
+        if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values)
             result.addValue(cursor->currentValue() ? *cursor->currentValue() : IDBValue());
 
         ++currentCount;
         cursor->advance(1);
     }
@@ -2243,14 +2202,12 @@
 
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to get an index record from database without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to get an index record from database without an in-progress transaction"_s };
-    }
 
     if (range.isExactlyOneKey())
         return uncheckedGetIndexRecordForOneKey(indexID, objectStoreID, type, range.lowerKey, getResult);
 
     auto cursor = transaction->maybeOpenBackingStoreCursor(objectStoreID, indexID, range);
@@ -2267,12 +2224,15 @@
     if (cursor->didComplete())
         getResult = { };
     else {
         if (type == IndexedDB::IndexRecordType::Key)
             getResult = { cursor->currentPrimaryKey() };
-        else
-            getResult = { cursor->currentValue() ? *cursor->currentValue() : IDBValue(), cursor->currentPrimaryKey() };
+        else {
+            auto* objectStoreInfo = infoForObjectStore(objectStoreID);
+            ASSERT(objectStoreInfo);
+            getResult = { cursor->currentPrimaryKey(), cursor->currentPrimaryKey(), cursor->currentValue() ? *cursor->currentValue() : IDBValue(), objectStoreInfo->keyPath() };
+        }
     }
 
     return IDBError { };
 }
 
@@ -2319,22 +2279,24 @@
     if (type == IndexedDB::IndexRecordType::Key) {
         getResult = { objectStoreKey };
         return IDBError { };
     }
 
-    sql->getColumnBlobAsVector(1, keyVector);
+    Vector<uint8_t> valueVector;
+    sql->getColumnBlobAsVector(1, valueVector);
 
     int64_t recordID = sql->getColumnInt64(2);
     Vector<String> blobURLs, blobFilePaths;
-    PAL::SessionID sessionID;
-    auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, sessionID, blobFilePaths);
+    auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);
     ASSERT(blobURLs.size() == blobFilePaths.size());
 
     if (!error.isNull())
         return error;
 
-    getResult = { { ThreadSafeDataBuffer::create(WTFMove(keyVector)), WTFMove(blobURLs), sessionID, WTFMove(blobFilePaths) }, objectStoreKey };
+    auto* objectStoreInfo = infoForObjectStore(objectStoreID);
+    ASSERT(objectStoreInfo);
+    getResult = { objectStoreKey, objectStoreKey, { ThreadSafeDataBuffer::create(WTFMove(valueVector)), WTFMove(blobURLs), WTFMove(blobFilePaths) }, objectStoreInfo->keyPath() };
     return IDBError { };
 }
 
 IDBError SQLiteIDBBackingStore::getCount(const IDBResourceIdentifier& transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData& range, uint64_t& outCount)
 {
@@ -2343,14 +2305,12 @@
     ASSERT(m_sqliteDB->isOpen());
 
     outCount = 0;
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to get count from database without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to get count from database without an in-progress transaction"_s };
-    }
 
     auto cursor = transaction->maybeOpenBackingStoreCursor(objectStoreIdentifier, indexIdentifier, range);
     if (!cursor) {
         LOG_ERROR("Cannot open cursor to populate indexes in database");
         return IDBError { UnknownError, "Unable to populate indexes in database"_s };
@@ -2390,12 +2350,10 @@
     if (!sql
         || sql->bindInt64(1, objectStoreID) != SQLITE_OK
         || sql->bindInt64(2, value) != SQLITE_OK
         || sql->step() != SQLITE_DONE) {
         LOG_ERROR("Could not update key generator value (%i) - %s", m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
-        if (m_sqliteDB->lastError() == SQLITE_FULL)
-            return IDBError { QuotaExceededError, "Error storing new key generator value in database because no enough space for domain"_s };
         return IDBError { ConstraintError, "Error storing new key generator value in database" };
     }
 
     return IDBError { };
 }
@@ -2406,14 +2364,13 @@
 
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to generate key in database without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to generate key in database without an in-progress transaction"_s };
-    }
+
     if (transaction->mode() == IDBTransactionMode::Readonly) {
         LOG_ERROR("Attempt to generate key in a read-only transaction");
         return IDBError { UnknownError, "Attempt to generate key in a read-only transaction"_s };
     }
 
@@ -2435,14 +2392,13 @@
 
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to revert key generator value in database without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to revert key generator value in database without an in-progress transaction"_s };
-    }
+
     if (transaction->mode() == IDBTransactionMode::Readonly) {
         LOG_ERROR("Attempt to revert key generator value in a read-only transaction");
         return IDBError { UnknownError, "Attempt to revert key generator value in a read-only transaction"_s };
     }
 
@@ -2456,14 +2412,13 @@
 
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to update key generator value in database without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to update key generator value in database without an in-progress transaction"_s };
-    }
+
     if (transaction->mode() == IDBTransactionMode::Readonly) {
         LOG_ERROR("Attempt to update key generator value in a read-only transaction");
         return IDBError { UnknownError, "Attempt to update key generator value in a read-only transaction"_s };
     }
 
@@ -2482,24 +2437,24 @@
 {
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
     auto* transaction = m_transactions.get(transactionIdentifier);
-    if (!transaction || !transaction->inProgress()) {
-        LOG_ERROR("Attempt to open a cursor in database without an in-progress transaction");
+    if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to open a cursor in database without an in-progress transaction"_s };
-    }
 
     auto* cursor = transaction->maybeOpenCursor(info);
     if (!cursor) {
         LOG_ERROR("Unable to open cursor");
         return IDBError { UnknownError, "Unable to open cursor"_s };
     }
 
     m_cursors.set(cursor->identifier(), cursor);
 
-    cursor->currentData(result);
+    auto* objectStoreInfo = infoForObjectStore(info.objectStoreIdentifier());
+    ASSERT(objectStoreInfo);
+    cursor->currentData(result, objectStoreInfo->keyPath());
     return IDBError { };
 }
 
 IDBError SQLiteIDBBackingStore::iterateCursor(const IDBResourceIdentifier& transactionIdentifier, const IDBResourceIdentifier& cursorIdentifier, const IDBIterateCursorData& data, IDBGetResult& result)
 {
@@ -2514,14 +2469,12 @@
         return IDBError { UnknownError, "Attempt to iterate a cursor that doesn't exist"_s };
     }
 
     ASSERT_UNUSED(transactionIdentifier, cursor->transaction()->transactionIdentifier() == transactionIdentifier);
 
-    if (!cursor->transaction() || !cursor->transaction()->inProgress()) {
-        LOG_ERROR("Attempt to iterate a cursor without an in-progress transaction");
+    if (!cursor->transaction() || !cursor->transaction()->inProgress())
         return IDBError { UnknownError, "Attempt to iterate a cursor without an in-progress transaction"_s };
-    }
 
     auto key = data.keyData;
     auto primaryKey = data.primaryKeyData;
     auto count = data.count;
 
@@ -2538,11 +2491,13 @@
             LOG_ERROR("Attempt to advance cursor failed");
             return IDBError { UnknownError, "Attempt to advance cursor failed"_s };
         }
     }
 
-    cursor->currentData(result);
+    auto* objectStoreInfo = infoForObjectStore(cursor->objectStoreID());
+    ASSERT(objectStoreInfo);
+    cursor->currentData(result, objectStoreInfo->keyPath());
     return IDBError { };
 }
 
 bool SQLiteIDBBackingStore::prefetchCursor(const IDBResourceIdentifier& transactionIdentifier, const IDBResourceIdentifier& cursorIdentifier)
 {
@@ -2592,23 +2547,22 @@
 
         if (errored)
             LOG_ERROR("Error getting all blob filenames to be deleted");
     }
 
-    String databaseDirectory = fullDatabaseDirectory();
     for (auto& file : blobFiles) {
-        String fullPath = FileSystem::pathByAppendingComponent(databaseDirectory, file);
+        String fullPath = FileSystem::pathByAppendingComponent(m_databaseDirectory, file);
         if (!FileSystem::deleteFile(fullPath))
             LOG_ERROR("Error deleting blob file %s", fullPath.utf8().data());
     }
 
     if (m_sqliteDB)
         closeSQLiteDB();
 
     SQLiteFileSystem::deleteDatabaseFile(dbFilename);
-    SQLiteFileSystem::deleteEmptyDatabaseDirectory(fullDatabaseDirectory());
-    SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_absoluteDatabaseDirectory);
+    SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_databaseDirectory);
+    SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectoryIsolatedCopy()));
 }
 
 void SQLiteIDBBackingStore::unregisterCursor(SQLiteIDBCursor& cursor)
 {
     ASSERT(m_cursors.contains(cursor.identifier()));
@@ -2627,18 +2581,23 @@
             return m_cachedStatements[static_cast<size_t>(sql)].get();
         m_cachedStatements[static_cast<size_t>(sql)] = nullptr;
     }
 
     if (m_sqliteDB) {
-        m_cachedStatements[static_cast<size_t>(sql)] = std::make_unique<SQLiteStatement>(*m_sqliteDB, statement);
+        m_cachedStatements[static_cast<size_t>(sql)] = makeUnique<SQLiteStatement>(*m_sqliteDB, statement);
         if (m_cachedStatements[static_cast<size_t>(sql)]->prepare() != SQLITE_OK)
             m_cachedStatements[static_cast<size_t>(sql)] = nullptr;
     }
 
     return m_cachedStatements[static_cast<size_t>(sql)].get();
 }
 
+void SQLiteIDBBackingStore::close()
+{
+    closeSQLiteDB();
+}
+
 void SQLiteIDBBackingStore::closeSQLiteDB()
 {
     for (size_t i = 0; i < static_cast<int>(SQL::Count); ++i)
         m_cachedStatements[i] = nullptr;
 
@@ -2646,9 +2605,15 @@
         m_sqliteDB->close();
 
     m_sqliteDB = nullptr;
 }
 
+bool SQLiteIDBBackingStore::hasTransaction(const IDBResourceIdentifier& transactionIdentifier) const
+{
+    ASSERT(isMainThread());
+    return m_transactions.contains(transactionIdentifier);
+}
+
 } // namespace IDBServer
 } // namespace WebCore
 
 #endif // ENABLE(INDEXED_DATABASE)
