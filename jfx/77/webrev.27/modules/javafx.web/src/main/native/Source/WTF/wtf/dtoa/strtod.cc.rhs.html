<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/strtod.cc</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Copyright 2010 the V8 project authors. All rights reserved.
  2 // Redistribution and use in source and binary forms, with or without
  3 // modification, are permitted provided that the following conditions are
  4 // met:
  5 //
  6 //     * Redistributions of source code must retain the above copyright
  7 //       notice, this list of conditions and the following disclaimer.
  8 //     * Redistributions in binary form must reproduce the above
  9 //       copyright notice, this list of conditions and the following
 10 //       disclaimer in the documentation and/or other materials provided
 11 //       with the distribution.
 12 //     * Neither the name of Google Inc. nor the names of its
 13 //       contributors may be used to endorse or promote products derived
 14 //       from this software without specific prior written permission.
 15 //
 16 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 17 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27 
 28 #include &quot;config.h&quot;
 29 
 30 #include &lt;climits&gt;
 31 #include &lt;cstdarg&gt;
 32 
 33 #include &lt;wtf/dtoa/bignum.h&gt;
 34 #include &lt;wtf/dtoa/cached-powers.h&gt;
 35 #include &lt;wtf/dtoa/ieee.h&gt;
 36 #include &lt;wtf/dtoa/strtod.h&gt;
 37 
 38 namespace WTF {
 39 namespace double_conversion {
 40 
 41 #if defined(DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS)
 42 // 2^53 = 9007199254740992.
 43 // Any integer with at most 15 decimal digits will hence fit into a double
 44 // (which has a 53bit significand) without loss of precision.
 45 static const int kMaxExactDoubleIntegerDecimalDigits = 15;
 46 #endif
 47 // 2^64 = 18446744073709551616 &gt; 10^19
 48 static const int kMaxUint64DecimalDigits = 19;
 49 
 50 // Max double: 1.7976931348623157 x 10^308
 51 // Min non-zero double: 4.9406564584124654 x 10^-324
 52 // Any x &gt;= 10^309 is interpreted as +infinity.
 53 // Any x &lt;= 10^-324 is interpreted as 0.
 54 // Note that 2.5e-324 (despite being smaller than the min double) will be read
 55 // as non-zero (equal to the min non-zero double).
 56 static const int kMaxDecimalPower = 309;
 57 static const int kMinDecimalPower = -324;
<a name="1" id="anc1"></a><span class="line-modified"> 58 </span>
 59 // 2^64 = 18446744073709551616
 60 static const uint64_t kMaxUint64 = UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF);
<a name="2" id="anc2"></a><span class="line-modified"> 61 </span>
<span class="line-modified"> 62 </span>
 63 #if defined(DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS)
 64 static const double exact_powers_of_ten[] = {
<a name="3" id="anc3"></a><span class="line-modified"> 65   1.0,  // 10^0</span>
<span class="line-modified"> 66   10.0,</span>
<span class="line-modified"> 67   100.0,</span>
<span class="line-modified"> 68   1000.0,</span>
<span class="line-modified"> 69   10000.0,</span>
<span class="line-modified"> 70   100000.0,</span>
<span class="line-modified"> 71   1000000.0,</span>
<span class="line-modified"> 72   10000000.0,</span>
<span class="line-modified"> 73   100000000.0,</span>
<span class="line-modified"> 74   1000000000.0,</span>
<span class="line-modified"> 75   10000000000.0,  // 10^10</span>
<span class="line-modified"> 76   100000000000.0,</span>
<span class="line-modified"> 77   1000000000000.0,</span>
<span class="line-modified"> 78   10000000000000.0,</span>
<span class="line-modified"> 79   100000000000000.0,</span>
<span class="line-modified"> 80   1000000000000000.0,</span>
<span class="line-modified"> 81   10000000000000000.0,</span>
<span class="line-modified"> 82   100000000000000000.0,</span>
<span class="line-modified"> 83   1000000000000000000.0,</span>
<span class="line-modified"> 84   10000000000000000000.0,</span>
<span class="line-modified"> 85   100000000000000000000.0,  // 10^20</span>
<span class="line-modified"> 86   1000000000000000000000.0,</span>
<span class="line-modified"> 87   // 10^22 = 0x21e19e0c9bab2400000 = 0x878678326eac9 * 2^22</span>
<span class="line-modified"> 88   10000000000000000000000.0</span>
 89 };
 90 static const int kExactPowersOfTenSize = ARRAY_SIZE(exact_powers_of_ten);
 91 #endif
<a name="4" id="anc4"></a><span class="line-modified"> 92 </span>
 93 // Maximum number of significant digits in the decimal representation.
 94 // In fact the value is 772 (see conversions.cc), but to give us some margin
 95 // we round up to 780.
 96 static const int kMaxSignificantDecimalDigits = 780;
<a name="5" id="anc5"></a><span class="line-modified"> 97 </span>
 98 static BufferReference&lt;const char&gt; TrimLeadingZeros(BufferReference&lt;const char&gt; buffer) {
<a name="6" id="anc6"></a><span class="line-modified"> 99   for (int i = 0; i &lt; buffer.length(); i++) {</span>
<span class="line-modified">100     if (buffer[i] != &#39;0&#39;) {</span>
<span class="line-modified">101       return buffer.SubBufferReference(i, buffer.length());</span>
<span class="line-modified">102     }</span>
<span class="line-modified">103   }</span>
<span class="line-modified">104   return BufferReference&lt;const char&gt;(buffer.start(), 0);</span>
105 }
<a name="7" id="anc7"></a><span class="line-modified">106 </span>
<span class="line-modified">107 </span>
108 static BufferReference&lt;const char&gt; TrimTrailingZeros(BufferReference&lt;const char&gt; buffer) {
<a name="8" id="anc8"></a><span class="line-modified">109   for (int i = buffer.length() - 1; i &gt;= 0; --i) {</span>
<span class="line-modified">110     if (buffer[i] != &#39;0&#39;) {</span>
<span class="line-modified">111       return buffer.SubBufferReference(0, i + 1);</span>
<span class="line-modified">112     }</span>
<span class="line-modified">113   }</span>
<span class="line-modified">114   return BufferReference&lt;const char&gt;(buffer.start(), 0);</span>
115 }
<a name="9" id="anc9"></a><span class="line-modified">116 </span>
<span class="line-modified">117 </span>
118 static void CutToMaxSignificantDigits(BufferReference&lt;const char&gt; buffer,
<a name="10" id="anc10"></a><span class="line-modified">119                                        int exponent,</span>
<span class="line-modified">120                                        char* significant_buffer,</span>
<span class="line-modified">121                                        int* significant_exponent) {</span>
<span class="line-modified">122   for (int i = 0; i &lt; kMaxSignificantDecimalDigits - 1; ++i) {</span>
<span class="line-modified">123     significant_buffer[i] = buffer[i];</span>
<span class="line-modified">124   }</span>
<span class="line-modified">125   // The input buffer has been trimmed. Therefore the last digit must be</span>
<span class="line-modified">126   // different from &#39;0&#39;.</span>
<span class="line-modified">127   ASSERT(buffer[buffer.length() - 1] != &#39;0&#39;);</span>
<span class="line-modified">128   // Set the last digit to be non-zero. This is sufficient to guarantee</span>
<span class="line-modified">129   // correct rounding.</span>
<span class="line-modified">130   significant_buffer[kMaxSignificantDecimalDigits - 1] = &#39;1&#39;;</span>
<span class="line-modified">131   *significant_exponent =</span>
<span class="line-modified">132       exponent + (buffer.length() - kMaxSignificantDecimalDigits);</span>
133 }
134 
135 
136 // Trims the buffer and cuts it to at most kMaxSignificantDecimalDigits.
137 // If possible the input-buffer is reused, but if the buffer needs to be
138 // modified (due to cutting), then the input needs to be copied into the
139 // buffer_copy_space.
140 static void TrimAndCut(BufferReference&lt;const char&gt; buffer, int exponent,
141                        char* buffer_copy_space, int space_size,
142                        BufferReference&lt;const char&gt;* trimmed, int* updated_exponent) {
143   BufferReference&lt;const char&gt; left_trimmed = TrimLeadingZeros(buffer);
144   BufferReference&lt;const char&gt; right_trimmed = TrimTrailingZeros(left_trimmed);
145   exponent += left_trimmed.length() - right_trimmed.length();
146   if (right_trimmed.length() &gt; kMaxSignificantDecimalDigits) {
147     (void) space_size;  // Mark variable as used.
148     ASSERT(space_size &gt;= kMaxSignificantDecimalDigits);
149     CutToMaxSignificantDigits(right_trimmed, exponent,
150                               buffer_copy_space, updated_exponent);
151     *trimmed = BufferReference&lt;const char&gt;(buffer_copy_space,
152                                  kMaxSignificantDecimalDigits);
153   } else {
154     *trimmed = right_trimmed;
155     *updated_exponent = exponent;
<a name="11" id="anc11"></a><span class="line-modified">156   }</span>
157 }
<a name="12" id="anc12"></a><span class="line-modified">158 </span>
159 
160 // Reads digits from the buffer and converts them to a uint64.
161 // Reads in as many digits as fit into a uint64.
162 // When the string starts with &quot;1844674407370955161&quot; no further digit is read.
163 // Since 2^64 = 18446744073709551616 it would still be possible read another
164 // digit if it was less or equal than 6, but this would complicate the code.
165 static uint64_t ReadUint64(BufferReference&lt;const char&gt; buffer,
<a name="13" id="anc13"></a><span class="line-modified">166                            int* number_of_read_digits) {</span>
<span class="line-modified">167   uint64_t result = 0;</span>
<span class="line-modified">168   int i = 0;</span>
<span class="line-modified">169   while (i &lt; buffer.length() &amp;&amp; result &lt;= (kMaxUint64 / 10 - 1)) {</span>
<span class="line-modified">170     int digit = buffer[i++] - &#39;0&#39;;</span>
<span class="line-modified">171     ASSERT(0 &lt;= digit &amp;&amp; digit &lt;= 9);</span>
<span class="line-modified">172     result = 10 * result + digit;</span>
<span class="line-modified">173   }</span>
<span class="line-modified">174   *number_of_read_digits = i;</span>
<span class="line-modified">175   return result;</span>
176 }
<a name="14" id="anc14"></a><span class="line-modified">177 </span>
<span class="line-modified">178 </span>
179 // Reads a DiyFp from the buffer.
180 // The returned DiyFp is not necessarily normalized.
181 // If remaining_decimals is zero then the returned DiyFp is accurate.
182 // Otherwise it has been rounded and has error of at most 1/2 ulp.
183 static void ReadDiyFp(BufferReference&lt;const char&gt; buffer,
<a name="15" id="anc15"></a><span class="line-modified">184                       DiyFp* result,</span>
<span class="line-modified">185                       int* remaining_decimals) {</span>
<span class="line-modified">186   int read_digits;</span>
<span class="line-modified">187   uint64_t significand = ReadUint64(buffer, &amp;read_digits);</span>
<span class="line-modified">188   if (buffer.length() == read_digits) {</span>
<span class="line-modified">189     *result = DiyFp(significand, 0);</span>
<span class="line-modified">190     *remaining_decimals = 0;</span>
<span class="line-modified">191   } else {</span>
<span class="line-modified">192     // Round the significand.</span>
<span class="line-modified">193     if (buffer[read_digits] &gt;= &#39;5&#39;) {</span>
<span class="line-modified">194       significand++;</span>
<span class="line-modified">195     }</span>
<span class="line-modified">196     // Compute the binary exponent.</span>
<span class="line-modified">197     int exponent = 0;</span>
<span class="line-modified">198     *result = DiyFp(significand, exponent);</span>
<span class="line-modified">199     *remaining_decimals = buffer.length() - read_digits;</span>
<span class="line-modified">200   }</span>
201 }
<a name="16" id="anc16"></a><span class="line-modified">202 </span>
<span class="line-modified">203 </span>
204 static bool DoubleStrtod(BufferReference&lt;const char&gt; trimmed,
<a name="17" id="anc17"></a><span class="line-modified">205                          int exponent,</span>
<span class="line-modified">206                          double* result) {</span>
207 #if !defined(DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS)
<a name="18" id="anc18"></a><span class="line-modified">208   UNUSED_PARAM(trimmed);</span>
<span class="line-modified">209   UNUSED_PARAM(exponent);</span>
<span class="line-modified">210   UNUSED_PARAM(result);</span>
<span class="line-modified">211   // On x86 the floating-point stack can be 64 or 80 bits wide. If it is</span>
<span class="line-modified">212   // 80 bits wide (as is the case on Linux) then double-rounding occurs and the</span>
<span class="line-modified">213   // result is not accurate.</span>
<span class="line-modified">214   // We know that Windows32 uses 64 bits and is therefore accurate.</span>
<span class="line-modified">215   // Note that the ARM simulator is compiled for 32bits. It therefore exhibits</span>
<span class="line-modified">216   // the same problem.</span>
<span class="line-modified">217   return false;</span>
218 #else
<a name="19" id="anc19"></a><span class="line-modified">219   if (trimmed.length() &lt;= kMaxExactDoubleIntegerDecimalDigits) {</span>
<span class="line-modified">220     int read_digits;</span>
<span class="line-modified">221     // The trimmed input fits into a double.</span>
<span class="line-modified">222     // If the 10^exponent (resp. 10^-exponent) fits into a double too then we</span>
<span class="line-modified">223     // can compute the result-double simply by multiplying (resp. dividing) the</span>
<span class="line-modified">224     // two numbers.</span>
<span class="line-modified">225     // This is possible because IEEE guarantees that floating-point operations</span>
<span class="line-modified">226     // return the best possible approximation.</span>
<span class="line-modified">227     if (exponent &lt; 0 &amp;&amp; -exponent &lt; kExactPowersOfTenSize) {</span>
<span class="line-modified">228       // 10^-exponent fits into a double.</span>
<span class="line-modified">229       *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="line-modified">230       ASSERT(read_digits == trimmed.length());</span>
<span class="line-modified">231       *result /= exact_powers_of_ten[-exponent];</span>
<span class="line-modified">232       return true;</span>
<span class="line-modified">233     }</span>
<span class="line-modified">234     if (0 &lt;= exponent &amp;&amp; exponent &lt; kExactPowersOfTenSize) {</span>
<span class="line-modified">235       // 10^exponent fits into a double.</span>
<span class="line-modified">236       *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="line-modified">237       ASSERT(read_digits == trimmed.length());</span>
<span class="line-modified">238       *result *= exact_powers_of_ten[exponent];</span>
<span class="line-modified">239       return true;</span>
<span class="line-modified">240     }</span>
<span class="line-modified">241     int remaining_digits =</span>
<span class="line-modified">242         kMaxExactDoubleIntegerDecimalDigits - trimmed.length();</span>
<span class="line-modified">243     if ((0 &lt;= exponent) &amp;&amp;</span>
<span class="line-modified">244         (exponent - remaining_digits &lt; kExactPowersOfTenSize)) {</span>
<span class="line-modified">245       // The trimmed string was short and we can multiply it with</span>
<span class="line-modified">246       // 10^remaining_digits. As a result the remaining exponent now fits</span>
<span class="line-modified">247       // into a double too.</span>
<span class="line-modified">248       *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="line-modified">249       ASSERT(read_digits == trimmed.length());</span>
<span class="line-modified">250       *result *= exact_powers_of_ten[remaining_digits];</span>
<span class="line-modified">251       *result *= exact_powers_of_ten[exponent - remaining_digits];</span>
<span class="line-modified">252       return true;</span>
<span class="line-modified">253     }</span>
<span class="line-modified">254   }</span>
<span class="line-modified">255   return false;</span>
256 #endif
257 }
<a name="20" id="anc20"></a><span class="line-modified">258 </span>
<span class="line-modified">259 </span>
260 // Returns 10^exponent as an exact DiyFp.
261 // The given exponent must be in the range [1; kDecimalExponentDistance[.
262 static DiyFp AdjustmentPowerOfTen(int exponent) {
<a name="21" id="anc21"></a><span class="line-modified">263   ASSERT(0 &lt; exponent);</span>
<span class="line-modified">264   ASSERT(exponent &lt; PowersOfTenCache::kDecimalExponentDistance);</span>
<span class="line-modified">265   // Simply hardcode the remaining powers for the given decimal exponent</span>
<span class="line-modified">266   // distance.</span>
<span class="line-modified">267   ASSERT(PowersOfTenCache::kDecimalExponentDistance == 8);</span>
<span class="line-modified">268   switch (exponent) {</span>
<span class="line-modified">269     case 1: return DiyFp(UINT64_2PART_C(0xa0000000, 00000000), -60);</span>
<span class="line-modified">270     case 2: return DiyFp(UINT64_2PART_C(0xc8000000, 00000000), -57);</span>
<span class="line-modified">271     case 3: return DiyFp(UINT64_2PART_C(0xfa000000, 00000000), -54);</span>
<span class="line-modified">272     case 4: return DiyFp(UINT64_2PART_C(0x9c400000, 00000000), -50);</span>
<span class="line-modified">273     case 5: return DiyFp(UINT64_2PART_C(0xc3500000, 00000000), -47);</span>
<span class="line-modified">274     case 6: return DiyFp(UINT64_2PART_C(0xf4240000, 00000000), -44);</span>
<span class="line-modified">275     case 7: return DiyFp(UINT64_2PART_C(0x98968000, 00000000), -40);</span>
<span class="line-modified">276     default:</span>
<span class="line-modified">277       UNREACHABLE();</span>
<span class="line-modified">278   }</span>
279 }
<a name="22" id="anc22"></a><span class="line-modified">280 </span>
<span class="line-modified">281 </span>
282 // If the function returns true then the result is the correct double.
283 // Otherwise it is either the correct double or the double that is just below
284 // the correct double.
285 static bool DiyFpStrtod(BufferReference&lt;const char&gt; buffer,
<a name="23" id="anc23"></a><span class="line-modified">286                         int exponent,</span>
<span class="line-modified">287                         double* result) {</span>
<span class="line-modified">288   DiyFp input;</span>
<span class="line-modified">289   int remaining_decimals;</span>
<span class="line-modified">290   ReadDiyFp(buffer, &amp;input, &amp;remaining_decimals);</span>
<span class="line-modified">291   // Since we may have dropped some digits the input is not accurate.</span>
<span class="line-modified">292   // If remaining_decimals is different than 0 than the error is at most</span>
<span class="line-modified">293   // .5 ulp (unit in the last place).</span>
<span class="line-modified">294   // We don&#39;t want to deal with fractions and therefore keep a common</span>
<span class="line-modified">295   // denominator.</span>
<span class="line-modified">296   const int kDenominatorLog = 3;</span>
<span class="line-modified">297   const int kDenominator = 1 &lt;&lt; kDenominatorLog;</span>
<span class="line-modified">298   // Move the remaining decimals into the exponent.</span>
<span class="line-modified">299   exponent += remaining_decimals;</span>
300   uint64_t error = (remaining_decimals == 0 ? 0 : kDenominator / 2);
<a name="24" id="anc24"></a><span class="line-modified">301 </span>
<span class="line-modified">302   int old_e = input.e();</span>
<span class="line-modified">303   input.Normalize();</span>
<span class="line-modified">304   error &lt;&lt;= old_e - input.e();</span>
<span class="line-modified">305 </span>
<span class="line-modified">306   ASSERT(exponent &lt;= PowersOfTenCache::kMaxDecimalExponent);</span>
<span class="line-modified">307   if (exponent &lt; PowersOfTenCache::kMinDecimalExponent) {</span>
<span class="line-modified">308     *result = 0.0;</span>
<span class="line-modified">309     return true;</span>
<span class="line-modified">310   }</span>
<span class="line-modified">311   DiyFp cached_power;</span>
<span class="line-modified">312   int cached_decimal_exponent;</span>
<span class="line-modified">313   PowersOfTenCache::GetCachedPowerForDecimalExponent(exponent,</span>
<span class="line-modified">314                                                      &amp;cached_power,</span>
<span class="line-modified">315                                                      &amp;cached_decimal_exponent);</span>
<span class="line-modified">316 </span>
<span class="line-modified">317   if (cached_decimal_exponent != exponent) {</span>
<span class="line-modified">318     int adjustment_exponent = exponent - cached_decimal_exponent;</span>
<span class="line-modified">319     DiyFp adjustment_power = AdjustmentPowerOfTen(adjustment_exponent);</span>
<span class="line-modified">320     input.Multiply(adjustment_power);</span>
<span class="line-modified">321     if (kMaxUint64DecimalDigits - buffer.length() &gt;= adjustment_exponent) {</span>
<span class="line-modified">322       // The product of input with the adjustment power fits into a 64 bit</span>
<span class="line-modified">323       // integer.</span>
<span class="line-modified">324       ASSERT(DiyFp::kSignificandSize == 64);</span>
<span class="line-modified">325     } else {</span>
<span class="line-modified">326       // The adjustment power is exact. There is hence only an error of 0.5.</span>
<span class="line-modified">327       error += kDenominator / 2;</span>
<span class="line-modified">328     }</span>
<span class="line-modified">329   }</span>
<span class="line-modified">330 </span>
<span class="line-modified">331   input.Multiply(cached_power);</span>
<span class="line-modified">332   // The error introduced by a multiplication of a*b equals</span>
<span class="line-modified">333   //   error_a + error_b + error_a*error_b/2^64 + 0.5</span>
<span class="line-modified">334   // Substituting a with &#39;input&#39; and b with &#39;cached_power&#39; we have</span>
<span class="line-modified">335   //   error_b = 0.5  (all cached powers have an error of less than 0.5 ulp),</span>
<span class="line-modified">336   //   error_ab = 0 or 1 / kDenominator &gt; error_a*error_b/ 2^64</span>
<span class="line-modified">337   int error_b = kDenominator / 2;</span>
<span class="line-modified">338   int error_ab = (error == 0 ? 0 : 1);  // We round up to 1.</span>
<span class="line-modified">339   int fixed_error = kDenominator / 2;</span>
<span class="line-modified">340   error += error_b + error_ab + fixed_error;</span>
<span class="line-modified">341 </span>
<span class="line-modified">342   old_e = input.e();</span>
<span class="line-modified">343   input.Normalize();</span>
<span class="line-modified">344   error &lt;&lt;= old_e - input.e();</span>
<span class="line-modified">345 </span>
<span class="line-modified">346   // See if the double&#39;s significand changes if we add/subtract the error.</span>
<span class="line-modified">347   int order_of_magnitude = DiyFp::kSignificandSize + input.e();</span>
<span class="line-modified">348   int effective_significand_size =</span>
<span class="line-modified">349       Double::SignificandSizeForOrderOfMagnitude(order_of_magnitude);</span>
<span class="line-modified">350   int precision_digits_count =</span>
<span class="line-modified">351       DiyFp::kSignificandSize - effective_significand_size;</span>
<span class="line-modified">352   if (precision_digits_count + kDenominatorLog &gt;= DiyFp::kSignificandSize) {</span>
<span class="line-modified">353     // This can only happen for very small denormals. In this case the</span>
<span class="line-modified">354     // half-way multiplied by the denominator exceeds the range of an uint64.</span>
<span class="line-modified">355     // Simply shift everything to the right.</span>
<span class="line-modified">356     int shift_amount = (precision_digits_count + kDenominatorLog) -</span>
<span class="line-modified">357         DiyFp::kSignificandSize + 1;</span>
<span class="line-modified">358     input.set_f(input.f() &gt;&gt; shift_amount);</span>
<span class="line-modified">359     input.set_e(input.e() + shift_amount);</span>
<span class="line-modified">360     // We add 1 for the lost precision of error, and kDenominator for</span>
<span class="line-modified">361     // the lost precision of input.f().</span>
<span class="line-modified">362     error = (error &gt;&gt; shift_amount) + 1 + kDenominator;</span>
<span class="line-modified">363     precision_digits_count -= shift_amount;</span>
<span class="line-modified">364   }</span>
<span class="line-modified">365   // We use uint64_ts now. This only works if the DiyFp uses uint64_ts too.</span>
<span class="line-modified">366   ASSERT(DiyFp::kSignificandSize == 64);</span>
<span class="line-modified">367   ASSERT(precision_digits_count &lt; 64);</span>
<span class="line-modified">368   uint64_t one64 = 1;</span>
<span class="line-modified">369   uint64_t precision_bits_mask = (one64 &lt;&lt; precision_digits_count) - 1;</span>
<span class="line-modified">370   uint64_t precision_bits = input.f() &amp; precision_bits_mask;</span>
<span class="line-modified">371   uint64_t half_way = one64 &lt;&lt; (precision_digits_count - 1);</span>
<span class="line-modified">372   precision_bits *= kDenominator;</span>
<span class="line-modified">373   half_way *= kDenominator;</span>
<span class="line-modified">374   DiyFp rounded_input(input.f() &gt;&gt; precision_digits_count,</span>
<span class="line-modified">375                       input.e() + precision_digits_count);</span>
<span class="line-modified">376   if (precision_bits &gt;= half_way + error) {</span>
<span class="line-modified">377     rounded_input.set_f(rounded_input.f() + 1);</span>
<span class="line-modified">378   }</span>
<span class="line-modified">379   // If the last_bits are too close to the half-way case than we are too</span>
<span class="line-modified">380   // inaccurate and round down. In this case we return false so that we can</span>
<span class="line-modified">381   // fall back to a more precise algorithm.</span>
<span class="line-modified">382 </span>
<span class="line-modified">383   *result = Double(rounded_input).value();</span>
<span class="line-modified">384   if (half_way - error &lt; precision_bits &amp;&amp; precision_bits &lt; half_way + error) {</span>
<span class="line-modified">385     // Too imprecise. The caller will have to fall back to a slower version.</span>
<span class="line-modified">386     // However the returned number is guaranteed to be either the correct</span>
<span class="line-modified">387     // double, or the next-lower double.</span>
<span class="line-modified">388     return false;</span>
<span class="line-modified">389   } else {</span>
<span class="line-modified">390     return true;</span>
<span class="line-modified">391   }</span>
392 }
<a name="25" id="anc25"></a><span class="line-modified">393 </span>
<span class="line-modified">394 </span>
395 // Returns
396 //   - -1 if buffer*10^exponent &lt; diy_fp.
397 //   -  0 if buffer*10^exponent == diy_fp.
398 //   - +1 if buffer*10^exponent &gt; diy_fp.
399 // Preconditions:
400 //   buffer.length() + exponent &lt;= kMaxDecimalPower + 1
401 //   buffer.length() + exponent &gt; kMinDecimalPower
402 //   buffer.length() &lt;= kMaxDecimalSignificantDigits
403 static int CompareBufferWithDiyFp(BufferReference&lt;const char&gt; buffer,
<a name="26" id="anc26"></a><span class="line-modified">404                                   int exponent,</span>
405                                   DiyFp diy_fp) {
<a name="27" id="anc27"></a><span class="line-modified">406   ASSERT(buffer.length() + exponent &lt;= kMaxDecimalPower + 1);</span>
<span class="line-modified">407   ASSERT(buffer.length() + exponent &gt; kMinDecimalPower);</span>
<span class="line-modified">408   ASSERT(buffer.length() &lt;= kMaxSignificantDecimalDigits);</span>
<span class="line-modified">409   // Make sure that the Bignum will be able to hold all our numbers.</span>
<span class="line-modified">410   // Our Bignum implementation has a separate field for exponents. Shifts will</span>
<span class="line-modified">411   // consume at most one bigit (&lt; 64 bits).</span>
<span class="line-modified">412   // ln(10) == 3.3219...</span>
<span class="line-modified">413   ASSERT(((kMaxDecimalPower + 1) * 333 / 100) &lt; Bignum::kMaxSignificantBits);</span>
414   Bignum buffer_bignum;
415   Bignum diy_fp_bignum;
416   buffer_bignum.AssignDecimalString(buffer);
417   diy_fp_bignum.AssignUInt64(diy_fp.f());
<a name="28" id="anc28"></a><span class="line-modified">418   if (exponent &gt;= 0) {</span>
419     buffer_bignum.MultiplyByPowerOfTen(exponent);
<a name="29" id="anc29"></a><span class="line-modified">420   } else {</span>
421     diy_fp_bignum.MultiplyByPowerOfTen(-exponent);
<a name="30" id="anc30"></a><span class="line-modified">422   }</span>
423   if (diy_fp.e() &gt; 0) {
424     diy_fp_bignum.ShiftLeft(diy_fp.e());
<a name="31" id="anc31"></a><span class="line-modified">425   } else {</span>
426     buffer_bignum.ShiftLeft(-diy_fp.e());
427   }
428   return Bignum::Compare(buffer_bignum, diy_fp_bignum);
429 }
430 
431 
432 // Returns true if the guess is the correct double.
433 // Returns false, when guess is either correct or the next-lower double.
434 static bool ComputeGuess(BufferReference&lt;const char&gt; trimmed, int exponent,
435                          double* guess) {
436   if (trimmed.length() == 0) {
437     *guess = 0.0;
438     return true;
<a name="32" id="anc32"></a><span class="line-modified">439   }</span>
440   if (exponent + trimmed.length() - 1 &gt;= kMaxDecimalPower) {
441     *guess = Double::Infinity();
442     return true;
443   }
444   if (exponent + trimmed.length() &lt;= kMinDecimalPower) {
445     *guess = 0.0;
446     return true;
447   }
448 
449   if (DoubleStrtod(trimmed, exponent, guess) ||
450       DiyFpStrtod(trimmed, exponent, guess)) {
451     return true;
452   }
453   if (*guess == Double::Infinity()) {
454     return true;
455   }
456   return false;
457 }
458 
459 double Strtod(BufferReference&lt;const char&gt; buffer, int exponent) {
460   char copy_buffer[kMaxSignificantDecimalDigits];
461   BufferReference&lt;const char&gt; trimmed;
462   int updated_exponent;
463   TrimAndCut(buffer, exponent, copy_buffer, kMaxSignificantDecimalDigits,
464              &amp;trimmed, &amp;updated_exponent);
465   exponent = updated_exponent;
466 
467   double guess;
468   bool is_correct = ComputeGuess(trimmed, exponent, &amp;guess);
469   if (is_correct) return guess;
470 
471   DiyFp upper_boundary = Double(guess).UpperBoundary();
472   int comparison = CompareBufferWithDiyFp(trimmed, exponent, upper_boundary);
<a name="33" id="anc33"></a><span class="line-modified">473   if (comparison &lt; 0) {</span>
<span class="line-modified">474     return guess;</span>
<span class="line-modified">475   } else if (comparison &gt; 0) {</span>
<span class="line-modified">476     return Double(guess).NextDouble();</span>
<span class="line-modified">477   } else if ((Double(guess).Significand() &amp; 1) == 0) {</span>
<span class="line-modified">478     // Round towards even.</span>
<span class="line-modified">479     return guess;</span>
<span class="line-modified">480   } else {</span>
<span class="line-modified">481     return Double(guess).NextDouble();</span>
<span class="line-modified">482   }</span>
483 }
<a name="34" id="anc34"></a><span class="line-modified">484 </span>
485 static float SanitizedDoubletof(double d) {
486   ASSERT(d &gt;= 0.0);
487   // ASAN has a sanitize check that disallows casting doubles to floats if
488   // they are too big.
489   // https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#available-checks
490   // The behavior should be covered by IEEE 754, but some projects use this
491   // flag, so work around it.
492   float max_finite = 3.4028234663852885981170418348451692544e+38;
493   // The half-way point between the max-finite and infinity value.
494   // Since infinity has an even significand everything equal or greater than
495   // this value should become infinity.
496   double half_max_finite_infinity =
497       3.40282356779733661637539395458142568448e+38;
498   if (d &gt;= max_finite) {
499     if (d &gt;= half_max_finite_infinity) {
500       return Single::Infinity();
501     } else {
502       return max_finite;
<a name="35" id="anc35"></a><span class="line-modified">503     }</span>
504   } else {
505     return static_cast&lt;float&gt;(d);
<a name="36" id="anc36"></a><span class="line-modified">506   }</span>
507 }
508 
509 float Strtof(BufferReference&lt;const char&gt; buffer, int exponent) {
510   char copy_buffer[kMaxSignificantDecimalDigits];
511   BufferReference&lt;const char&gt; trimmed;
512   int updated_exponent;
513   TrimAndCut(buffer, exponent, copy_buffer, kMaxSignificantDecimalDigits,
514              &amp;trimmed, &amp;updated_exponent);
515   exponent = updated_exponent;
516 
517   double double_guess;
518   bool is_correct = ComputeGuess(trimmed, exponent, &amp;double_guess);
519 
520   float float_guess = SanitizedDoubletof(double_guess);
521   if (float_guess == double_guess) {
522     // This shortcut triggers for integer values.
523     return float_guess;
524   }
525 
526   // We must catch double-rounding. Say the double has been rounded up, and is
527   // now a boundary of a float, and rounds up again. This is why we have to
528   // look at previous too.
529   // Example (in decimal numbers):
530   //    input: 12349
531   //    high-precision (4 digits): 1235
532   //    low-precision (3 digits):
533   //       when read from input: 123
534   //       when rounded from high precision: 124.
535   // To do this we simply look at the neigbors of the correct result and see
536   // if they would round to the same float. If the guess is not correct we have
537   // to look at four values (since two different doubles could be the correct
538   // double).
539 
540   double double_next = Double(double_guess).NextDouble();
541   double double_previous = Double(double_guess).PreviousDouble();
542 
543   float f1 = SanitizedDoubletof(double_previous);
544   float f2 = float_guess;
545   float f3 = SanitizedDoubletof(double_next);
546   float f4;
547   if (is_correct) {
548     f4 = f3;
549   } else {
550     double double_next2 = Double(double_next).NextDouble();
551     f4 = SanitizedDoubletof(double_next2);
<a name="37" id="anc37"></a><span class="line-modified">552   }</span>
553   (void) f2;  // Mark variable as used.
554   ASSERT(f1 &lt;= f2 &amp;&amp; f2 &lt;= f3 &amp;&amp; f3 &lt;= f4);
<a name="38" id="anc38"></a><span class="line-modified">555 </span>
556   // If the guess doesn&#39;t lie near a single-precision boundary we can simply
557   // return its float-value.
558   if (f1 == f4) {
559     return float_guess;
560   }
561 
562   ASSERT((f1 != f2 &amp;&amp; f2 == f3 &amp;&amp; f3 == f4) ||
563          (f1 == f2 &amp;&amp; f2 != f3 &amp;&amp; f3 == f4) ||
564          (f1 == f2 &amp;&amp; f2 == f3 &amp;&amp; f3 != f4));
565 
566   // guess and next are the two possible candidates (in the same way that
567   // double_guess was the lower candidate for a double-precision guess).
568   float guess = f1;
569   float next = f4;
570   DiyFp upper_boundary;
571   if (guess == 0.0f) {
572     float min_float = 1e-45f;
573     upper_boundary = Double(static_cast&lt;double&gt;(min_float) / 2).AsDiyFp();
574   } else {
575     upper_boundary = Single(guess).UpperBoundary();
<a name="39" id="anc39"></a><span class="line-modified">576   }</span>
577   int comparison = CompareBufferWithDiyFp(trimmed, exponent, upper_boundary);
578   if (comparison &lt; 0) {
579     return guess;
580   } else if (comparison &gt; 0) {
581     return next;
582   } else if ((Single(guess).Significand() &amp; 1) == 0) {
583     // Round towards even.
584     return guess;
585   } else {
586     return next;
<a name="40" id="anc40"></a><span class="line-modified">587   }</span>
588 }
<a name="41" id="anc41"></a><span class="line-modified">589 </span>
590 }  // namespace double_conversion
<a name="42" id="anc42"></a><span class="line-modified">591 }  // namespace WTF</span>
<a name="43" id="anc43"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="43" type="hidden" />
</body>
</html>