<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2006 Alexey Proskuryakov (ap@webkit.org)
   4  * Copyright (C) 2012 Digia Plc. and/or its subsidiary(-ies)
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  * 1. Redistributions of source code must retain the above copyright
  10  *    notice, this list of conditions and the following disclaimer.
  11  * 2. Redistributions in binary form must reproduce the above copyright
  12  *    notice, this list of conditions and the following disclaimer in the
  13  *    documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;EventHandler.h&quot;
  30 
  31 #include &quot;AutoscrollController.h&quot;
  32 #include &quot;BackForwardController.h&quot;
  33 #include &quot;CachedImage.h&quot;
  34 #include &quot;Chrome.h&quot;
  35 #include &quot;ChromeClient.h&quot;
  36 #include &quot;ComposedTreeAncestorIterator.h&quot;
  37 #include &quot;CursorList.h&quot;
  38 #include &quot;DocumentMarkerController.h&quot;
  39 #include &quot;DragController.h&quot;
  40 #include &quot;DragState.h&quot;
  41 #include &quot;Editing.h&quot;
  42 #include &quot;Editor.h&quot;
  43 #include &quot;EditorClient.h&quot;
  44 #include &quot;EventNames.h&quot;
  45 #include &quot;FileList.h&quot;
  46 #include &quot;FloatPoint.h&quot;
  47 #include &quot;FloatRect.h&quot;
  48 #include &quot;FocusController.h&quot;
  49 #include &quot;Frame.h&quot;
  50 #include &quot;FrameLoader.h&quot;
  51 #include &quot;FrameSelection.h&quot;
  52 #include &quot;FrameTree.h&quot;
  53 #include &quot;FrameView.h&quot;
  54 #include &quot;FullscreenManager.h&quot;
  55 #include &quot;HTMLDocument.h&quot;
  56 #include &quot;HTMLFrameElement.h&quot;
  57 #include &quot;HTMLFrameSetElement.h&quot;
  58 #include &quot;HTMLHtmlElement.h&quot;
  59 #include &quot;HTMLIFrameElement.h&quot;
  60 #include &quot;HTMLInputElement.h&quot;
  61 #include &quot;HTMLNames.h&quot;
  62 #include &quot;HitTestRequest.h&quot;
  63 #include &quot;HitTestResult.h&quot;
  64 #include &quot;Image.h&quot;
  65 #include &quot;InspectorInstrumentation.h&quot;
  66 #include &quot;KeyboardEvent.h&quot;
  67 #include &quot;Logging.h&quot;
  68 #include &quot;MouseEvent.h&quot;
  69 #include &quot;MouseEventWithHitTestResults.h&quot;
  70 #include &quot;NotImplemented.h&quot;
  71 #include &quot;Page.h&quot;
  72 #include &quot;PageOverlayController.h&quot;
  73 #include &quot;Pasteboard.h&quot;
  74 #include &quot;PlatformEvent.h&quot;
  75 #include &quot;PlatformKeyboardEvent.h&quot;
  76 #include &quot;PlatformWheelEvent.h&quot;
  77 #include &quot;PluginDocument.h&quot;
  78 #include &quot;Range.h&quot;
  79 #include &quot;RenderFrameSet.h&quot;
  80 #include &quot;RenderLayer.h&quot;
  81 #include &quot;RenderListBox.h&quot;
  82 #include &quot;RenderTextControlSingleLine.h&quot;
  83 #include &quot;RenderView.h&quot;
  84 #include &quot;RenderWidget.h&quot;
  85 #include &quot;ResourceLoadObserver.h&quot;
  86 #include &quot;RuntimeApplicationChecks.h&quot;
  87 #include &quot;SVGDocument.h&quot;
  88 #include &quot;SVGNames.h&quot;
  89 #include &quot;ScrollLatchingState.h&quot;
  90 #include &quot;Scrollbar.h&quot;
  91 #include &quot;Settings.h&quot;
  92 #include &quot;ShadowRoot.h&quot;
  93 #include &quot;SpatialNavigation.h&quot;
  94 #include &quot;StaticPasteboard.h&quot;
  95 #include &quot;StyleCachedImage.h&quot;
  96 #include &quot;TextEvent.h&quot;
  97 #include &quot;TextIterator.h&quot;
  98 #include &quot;UserGestureIndicator.h&quot;
  99 #include &quot;UserTypingGestureIndicator.h&quot;
 100 #include &quot;ValidationMessageClient.h&quot;
 101 #include &quot;VisibleUnits.h&quot;
 102 #include &quot;WheelEvent.h&quot;
 103 #include &quot;WheelEventDeltaFilter.h&quot;
 104 #include &quot;WindowsKeyboardCodes.h&quot;
 105 #include &lt;wtf/Assertions.h&gt;
 106 #include &lt;wtf/NeverDestroyed.h&gt;
 107 #include &lt;wtf/StdLibExtras.h&gt;
 108 
 109 #if ENABLE(IOS_TOUCH_EVENTS)
 110 #include &quot;PlatformTouchEventIOS.h&quot;
 111 #endif
 112 
 113 #if ENABLE(TOUCH_EVENTS)
 114 #include &quot;TouchEvent.h&quot;
 115 #include &quot;TouchList.h&quot;
 116 #endif
 117 
 118 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 119 #include &quot;PlatformTouchEvent.h&quot;
 120 #endif
 121 
 122 #if ENABLE(MAC_GESTURE_EVENTS)
 123 #include &quot;PlatformGestureEventMac.h&quot;
 124 #endif
 125 
 126 #if ENABLE(POINTER_LOCK)
 127 #include &quot;PointerLockController.h&quot;
 128 #endif
 129 
 130 #if ENABLE(POINTER_EVENTS)
 131 #include &quot;RuntimeEnabledFeatures.h&quot;
 132 #endif
 133 
 134 #if PLATFORM(IOS_FAMILY)
 135 #include &quot;DOMTimerHoldingTank.h&quot;
 136 #endif
 137 
 138 namespace WebCore {
 139 
 140 using namespace HTMLNames;
 141 
 142 #if ENABLE(DRAG_SUPPORT)
 143 // The link drag hysteresis is much larger than the others because there
 144 // needs to be enough space to cancel the link press without starting a link drag,
 145 // and because dragging links is rare.
 146 const int LinkDragHysteresis = 40;
 147 const int ImageDragHysteresis = 5;
 148 const int TextDragHysteresis = 3;
 149 const int ColorDragHystersis = 3;
 150 const int GeneralDragHysteresis = 3;
 151 #if PLATFORM(MAC)
 152 const Seconds EventHandler::TextDragDelay { 150_ms };
 153 #else
 154 const Seconds EventHandler::TextDragDelay { 0_s };
 155 #endif
 156 #endif // ENABLE(DRAG_SUPPORT)
 157 
 158 #if ENABLE(IOS_GESTURE_EVENTS) || ENABLE(MAC_GESTURE_EVENTS)
 159 const float GestureUnknown = 0;
 160 #endif
 161 
 162 #if ENABLE(IOS_TOUCH_EVENTS)
 163 // FIXME: Share this constant with EventHandler and SliderThumbElement.
 164 const unsigned InvalidTouchIdentifier = 0;
 165 #endif
 166 
 167 // Match key code of composition keydown event on windows.
 168 // IE sends VK_PROCESSKEY which has value 229;
 169 const int CompositionEventKeyCode = 229;
 170 
 171 using namespace SVGNames;
 172 
 173 #if !ENABLE(IOS_TOUCH_EVENTS)
 174 // The amount of time to wait before sending a fake mouse event, triggered
 175 // during a scroll. The short interval is used if the content responds to the mouse events
 176 // in fakeMouseMoveDurationThreshold or less, otherwise the long interval is used.
 177 const double fakeMouseMoveDurationThreshold = 0.01;
 178 const Seconds fakeMouseMoveShortInterval = { 100_ms };
 179 const Seconds fakeMouseMoveLongInterval = { 250_ms };
 180 #endif
 181 
 182 #if ENABLE(CURSOR_SUPPORT)
 183 // The amount of time to wait for a cursor update on style and layout changes
 184 // Set to 50Hz, no need to be faster than common screen refresh rate
 185 static const Seconds cursorUpdateInterval { 20_ms };
 186 
 187 const int maximumCursorSize = 128;
 188 #endif
 189 
 190 #if ENABLE(MOUSE_CURSOR_SCALE)
 191 // It&#39;s pretty unlikely that a scale of less than one would ever be used. But all we really
 192 // need to ensure here is that the scale isn&#39;t so small that integer overflow can occur when
 193 // dividing cursor sizes (limited above) by the scale.
 194 const double minimumCursorScale = 0.001;
 195 #endif
 196 
 197 class MaximumDurationTracker {
 198 public:
 199     explicit MaximumDurationTracker(double *maxDuration)
 200         : m_maxDuration(maxDuration)
 201         , m_start(MonotonicTime::now())
 202     {
 203     }
 204 
 205     ~MaximumDurationTracker()
 206     {
 207         *m_maxDuration = std::max(*m_maxDuration, (MonotonicTime::now() - m_start).seconds());
 208     }
 209 
 210 private:
 211     double* m_maxDuration;
 212     MonotonicTime m_start;
 213 };
 214 
 215 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 216 class SyntheticTouchPoint : public PlatformTouchPoint {
 217 public:
 218 
 219     // The default values are based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
 220     explicit SyntheticTouchPoint(const PlatformMouseEvent&amp; event)
 221     {
 222         const static int idDefaultValue = 0;
 223         const static int radiusYDefaultValue = 1;
 224         const static int radiusXDefaultValue = 1;
 225         const static float rotationAngleDefaultValue = 0.0f;
 226         const static float forceDefaultValue = 1.0f;
 227 
 228         m_id = idDefaultValue; // There is only one active TouchPoint.
 229         m_screenPos = event.globalPosition();
 230         m_pos = event.position();
 231         m_radiusY = radiusYDefaultValue;
 232         m_radiusX = radiusXDefaultValue;
 233         m_rotationAngle = rotationAngleDefaultValue;
 234         m_force = forceDefaultValue;
 235 
 236         PlatformEvent::Type type = event.type();
 237         ASSERT(type == PlatformEvent::MouseMoved || type == PlatformEvent::MousePressed || type == PlatformEvent::MouseReleased);
 238 
 239         switch (type) {
 240         case PlatformEvent::MouseMoved:
 241             m_state = TouchMoved;
 242             break;
 243         case PlatformEvent::MousePressed:
 244             m_state = TouchPressed;
 245             break;
 246         case PlatformEvent::MouseReleased:
 247             m_state = TouchReleased;
 248             break;
 249         default:
 250             ASSERT_NOT_REACHED();
 251             break;
 252         }
 253     }
 254 };
 255 
 256 class SyntheticSingleTouchEvent : public PlatformTouchEvent {
 257 public:
 258     explicit SyntheticSingleTouchEvent(const PlatformMouseEvent&amp; event)
 259     {
 260         switch (event.type()) {
 261         case PlatformEvent::MouseMoved:
 262             m_type = TouchMove;
 263             break;
 264         case PlatformEvent::MousePressed:
 265             m_type = TouchStart;
 266             break;
 267         case PlatformEvent::MouseReleased:
 268             m_type = TouchEnd;
 269             break;
 270         default:
 271             ASSERT_NOT_REACHED();
 272             m_type = NoType;
 273             break;
 274         }
 275         m_timestamp = event.timestamp();
 276         m_modifiers = event.modifiers();
 277         m_touchPoints.append(SyntheticTouchPoint(event));
 278     }
 279 };
 280 #endif // ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 281 
 282 static inline ScrollGranularity wheelGranularityToScrollGranularity(unsigned deltaMode)
 283 {
 284     switch (deltaMode) {
 285     case WheelEvent::DOM_DELTA_PAGE:
 286         return ScrollByPage;
 287     case WheelEvent::DOM_DELTA_LINE:
 288         return ScrollByLine;
 289     case WheelEvent::DOM_DELTA_PIXEL:
 290         return ScrollByPixel;
 291     default:
 292         return ScrollByPixel;
 293     }
 294 }
 295 
 296 static inline bool didScrollInScrollableArea(ScrollableArea* scrollableArea, WheelEvent&amp; wheelEvent)
 297 {
 298     ScrollGranularity scrollGranularity = wheelGranularityToScrollGranularity(wheelEvent.deltaMode());
 299     bool didHandleWheelEvent = false;
 300     if (float absoluteDelta = std::abs(wheelEvent.deltaX()))
 301         didHandleWheelEvent |= scrollableArea-&gt;scroll(wheelEvent.deltaX() &gt; 0 ? ScrollRight : ScrollLeft, scrollGranularity, absoluteDelta);
 302 
 303     if (float absoluteDelta = std::abs(wheelEvent.deltaY()))
 304         didHandleWheelEvent |= scrollableArea-&gt;scroll(wheelEvent.deltaY() &gt; 0 ? ScrollDown : ScrollUp, scrollGranularity, absoluteDelta);
 305 
 306     return didHandleWheelEvent;
 307 }
 308 
 309 static inline bool handleWheelEventInAppropriateEnclosingBox(Node* startNode, WheelEvent&amp; wheelEvent, Element** stopElement, const FloatSize&amp; filteredPlatformDelta, const FloatSize&amp; filteredVelocity)
 310 {
 311     bool shouldHandleEvent = wheelEvent.deltaX() || wheelEvent.deltaY();
 312 #if PLATFORM(MAC)
 313     shouldHandleEvent |= wheelEvent.phase() == PlatformWheelEventPhaseEnded;
 314 #if ENABLE(CSS_SCROLL_SNAP)
 315     shouldHandleEvent |= wheelEvent.momentumPhase() == PlatformWheelEventPhaseEnded;
 316 #endif
 317 #endif
 318     if (!startNode-&gt;renderer() || !shouldHandleEvent)
 319         return false;
 320 
 321     RenderBox&amp; initialEnclosingBox = startNode-&gt;renderer()-&gt;enclosingBox();
 322     if (initialEnclosingBox.isListBox())
 323         return didScrollInScrollableArea(static_cast&lt;RenderListBox*&gt;(&amp;initialEnclosingBox), wheelEvent);
 324 
 325     RenderBox* currentEnclosingBox = &amp;initialEnclosingBox;
 326     while (currentEnclosingBox) {
 327         if (RenderLayer* boxLayer = currentEnclosingBox-&gt;layer()) {
 328             auto platformEvent = wheelEvent.underlyingPlatformEvent();
 329             bool scrollingWasHandled;
 330             if (platformEvent) {
 331                 auto copiedEvent = platformEvent-&gt;copyWithDeltasAndVelocity(filteredPlatformDelta.width(), filteredPlatformDelta.height(), filteredVelocity);
 332                 scrollingWasHandled = boxLayer-&gt;handleWheelEvent(copiedEvent);
 333             } else
 334                 scrollingWasHandled = didScrollInScrollableArea(boxLayer, wheelEvent);
 335 
 336             if (scrollingWasHandled) {
 337                 if (stopElement)
 338                     *stopElement = currentEnclosingBox-&gt;element();
 339                 return true;
 340             }
 341         }
 342 
 343         if (stopElement &amp;&amp; *stopElement &amp;&amp; *stopElement == currentEnclosingBox-&gt;element())
 344             return true;
 345 
 346         currentEnclosingBox = currentEnclosingBox-&gt;containingBlock();
 347         if (!currentEnclosingBox || currentEnclosingBox-&gt;isRenderView())
 348             return false;
 349     }
 350     return false;
 351 }
 352 
 353 #if (ENABLE(TOUCH_EVENTS) &amp;&amp; !PLATFORM(IOS_FAMILY))
 354 static inline bool shouldGesturesTriggerActive()
 355 {
 356     // If the platform we&#39;re on supports GestureTapDown and GestureTapCancel then we&#39;ll
 357     // rely on them to set the active state. Unfortunately there&#39;s no generic way to
 358     // know in advance what event types are supported.
 359     return false;
 360 }
 361 #endif
 362 
 363 #if !PLATFORM(COCOA)
 364 
 365 inline bool EventHandler::eventLoopHandleMouseUp(const MouseEventWithHitTestResults&amp;)
 366 {
 367     return false;
 368 }
 369 
 370 #if ENABLE(DRAG_SUPPORT)
 371 inline bool EventHandler::eventLoopHandleMouseDragged(const MouseEventWithHitTestResults&amp;)
 372 {
 373     return false;
 374 }
 375 #endif
 376 
 377 #endif
 378 
 379 EventHandler::EventHandler(Frame&amp; frame)
 380     : m_frame(frame)
 381     , m_hoverTimer(*this, &amp;EventHandler::hoverTimerFired)
 382 #if ENABLE(CURSOR_SUPPORT)
 383     , m_cursorUpdateTimer(*this, &amp;EventHandler::cursorUpdateTimerFired)
 384 #endif
 385 #if PLATFORM(MAC)
 386     , m_pendingMomentumWheelEventsTimer(*this, &amp;EventHandler::clearLatchedState)
 387 #endif
 388     , m_autoscrollController(makeUnique&lt;AutoscrollController&gt;())
 389 #if !ENABLE(IOS_TOUCH_EVENTS)
 390     , m_fakeMouseMoveEventTimer(*this, &amp;EventHandler::fakeMouseMoveEventTimerFired)
 391 #endif
 392 #if ENABLE(CURSOR_VISIBILITY)
 393     , m_autoHideCursorTimer(*this, &amp;EventHandler::autoHideCursorTimerFired)
 394 #endif
 395 {
 396 }
 397 
 398 EventHandler::~EventHandler()
 399 {
 400 #if !ENABLE(IOS_TOUCH_EVENTS)
 401     ASSERT(!m_fakeMouseMoveEventTimer.isActive());
 402 #endif
 403 #if ENABLE(CURSOR_VISIBILITY)
 404     ASSERT(!m_autoHideCursorTimer.isActive());
 405 #endif
 406 }
 407 
 408 #if ENABLE(DRAG_SUPPORT)
 409 
 410 DragState&amp; EventHandler::dragState()
 411 {
 412     static NeverDestroyed&lt;DragState&gt; state;
 413     return state;
 414 }
 415 
 416 #endif
 417 
 418 void EventHandler::clear()
 419 {
 420     m_hoverTimer.stop();
 421 #if ENABLE(CURSOR_SUPPORT)
 422     m_cursorUpdateTimer.stop();
 423 #endif
 424 #if !ENABLE(IOS_TOUCH_EVENTS)
 425     m_fakeMouseMoveEventTimer.stop();
 426 #endif
 427 #if ENABLE(CURSOR_VISIBILITY)
 428     cancelAutoHideCursorTimer();
 429 #endif
 430     m_resizeLayer = nullptr;
 431     m_elementUnderMouse = nullptr;
 432     m_lastElementUnderMouse = nullptr;
 433     m_lastMouseMoveEventSubframe = nullptr;
 434     m_lastScrollbarUnderMouse = nullptr;
 435     m_clickCount = 0;
 436     m_clickNode = nullptr;
 437 #if ENABLE(IOS_GESTURE_EVENTS)
 438     m_gestureInitialDiameter = GestureUnknown;
 439     m_gestureInitialRotation = GestureUnknown;
 440 #endif
 441 #if ENABLE(IOS_GESTURE_EVENTS) || ENABLE(MAC_GESTURE_EVENTS)
 442     m_gestureLastDiameter = GestureUnknown;
 443     m_gestureLastRotation = GestureUnknown;
 444     m_gestureTargets.clear();
 445 #endif
 446 #if ENABLE(IOS_TOUCH_EVENTS)
 447     m_touches.clear();
 448     m_firstTouchID = InvalidTouchIdentifier;
 449     m_touchEventTargetSubframe = nullptr;
 450 #endif
 451     m_frameSetBeingResized = nullptr;
 452 #if ENABLE(DRAG_SUPPORT)
 453     m_dragTarget = nullptr;
 454     m_shouldOnlyFireDragOverEvent = false;
 455 #endif
 456     m_mousePositionIsUnknown = true;
 457     m_lastKnownMousePosition = IntPoint();
 458     m_lastKnownMouseGlobalPosition = IntPoint();
 459     m_mousePressNode = nullptr;
 460     m_mousePressed = false;
 461     m_capturesDragging = false;
 462     m_capturingMouseEventsElement = nullptr;
 463     clearLatchedState();
 464 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 465     m_originatingTouchPointTargets.clear();
 466     m_originatingTouchPointDocument = nullptr;
 467     m_originatingTouchPointTargetKey = 0;
 468 #endif
 469     m_maxMouseMovedDuration = 0;
 470     m_didStartDrag = false;
 471 }
 472 
 473 void EventHandler::nodeWillBeRemoved(Node&amp; nodeToBeRemoved)
 474 {
 475     if (nodeToBeRemoved.contains(m_clickNode.get()))
 476         m_clickNode = nullptr;
 477 }
 478 
 479 static void setSelectionIfNeeded(FrameSelection&amp; selection, const VisibleSelection&amp; newSelection)
 480 {
 481     if (selection.selection() != newSelection &amp;&amp; selection.shouldChangeSelection(newSelection))
 482         selection.setSelection(newSelection);
 483 }
 484 
 485 static inline bool dispatchSelectStart(Node* node)
 486 {
 487     if (!node || !node-&gt;renderer())
 488         return true;
 489 
 490     auto event = Event::create(eventNames().selectstartEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes);
 491     node-&gt;dispatchEvent(event);
 492     return !event-&gt;defaultPrevented();
 493 }
 494 
 495 static Node* nodeToSelectOnMouseDownForNode(Node&amp; targetNode)
 496 {
 497 #if ENABLE(USERSELECT_ALL)
 498     if (Node* rootUserSelectAll = Position::rootUserSelectAllForNode(&amp;targetNode))
 499         return rootUserSelectAll;
 500 #endif
 501 
 502     if (targetNode.shouldSelectOnMouseDown())
 503         return &amp;targetNode;
 504 
 505     return nullptr;
 506 }
 507 
 508 static VisibleSelection expandSelectionToRespectSelectOnMouseDown(Node&amp; targetNode, const VisibleSelection&amp; selection)
 509 {
 510     Node* nodeToSelect = nodeToSelectOnMouseDownForNode(targetNode);
 511     if (!nodeToSelect)
 512         return selection;
 513 
 514     VisibleSelection newSelection(selection);
 515     newSelection.setBase(positionBeforeNode(nodeToSelect).upstream(CanCrossEditingBoundary));
 516     newSelection.setExtent(positionAfterNode(nodeToSelect).downstream(CanCrossEditingBoundary));
 517 
 518     return newSelection;
 519 }
 520 
 521 bool EventHandler::updateSelectionForMouseDownDispatchingSelectStart(Node* targetNode, const VisibleSelection&amp; selection, TextGranularity granularity)
 522 {
 523     if (Position::nodeIsUserSelectNone(targetNode))
 524         return false;
 525 
 526     if (!dispatchSelectStart(targetNode)) {
 527         m_mouseDownMayStartSelect = false;
 528         return false;
 529     }
 530 
 531     if (selection.isRange())
 532         m_selectionInitiationState = ExtendedSelection;
 533     else {
 534         granularity = CharacterGranularity;
 535         m_selectionInitiationState = PlacedCaret;
 536     }
 537 
 538     m_frame.selection().setSelectionByMouseIfDifferent(selection, granularity);
 539 
 540     return true;
 541 }
 542 
 543 void EventHandler::selectClosestWordFromHitTestResult(const HitTestResult&amp; result, AppendTrailingWhitespace appendTrailingWhitespace)
 544 {
 545     Node* targetNode = result.targetNode();
 546     VisibleSelection newSelection;
 547 
 548     if (targetNode &amp;&amp; targetNode-&gt;renderer()) {
 549         VisiblePosition pos(targetNode-&gt;renderer()-&gt;positionForPoint(result.localPoint(), nullptr));
 550         if (pos.isNotNull()) {
 551             newSelection = VisibleSelection(pos);
 552             newSelection.expandUsingGranularity(WordGranularity);
 553         }
 554 
 555         if (appendTrailingWhitespace == ShouldAppendTrailingWhitespace &amp;&amp; newSelection.isRange())
 556             newSelection.appendTrailingWhitespace();
 557 
 558         updateSelectionForMouseDownDispatchingSelectStart(targetNode, expandSelectionToRespectSelectOnMouseDown(*targetNode, newSelection), WordGranularity);
 559     }
 560 }
 561 
 562 static AppendTrailingWhitespace shouldAppendTrailingWhitespace(const MouseEventWithHitTestResults&amp; result, const Frame&amp; frame)
 563 {
 564     return (result.event().clickCount() == 2 &amp;&amp; frame.editor().isSelectTrailingWhitespaceEnabled()) ? ShouldAppendTrailingWhitespace : DontAppendTrailingWhitespace;
 565 }
 566 
 567 void EventHandler::selectClosestWordFromMouseEvent(const MouseEventWithHitTestResults&amp; result)
 568 {
 569     if (m_mouseDownMayStartSelect)
 570         selectClosestWordFromHitTestResult(result.hitTestResult(), shouldAppendTrailingWhitespace(result, m_frame));
 571 }
 572 
 573 #if !PLATFORM(MAC)
 574 VisibleSelection EventHandler::selectClosestWordFromHitTestResultBasedOnLookup(const HitTestResult&amp;)
 575 {
 576     return VisibleSelection();
 577 }
 578 #endif
 579 
 580 void EventHandler::selectClosestContextualWordFromMouseEvent(const MouseEventWithHitTestResults&amp; mouseEvent)
 581 {
 582     Node* targetNode = mouseEvent.targetNode();
 583     const HitTestResult&amp; result = mouseEvent.hitTestResult();
 584     VisibleSelection newSelection;
 585     bool appendTrailingWhitespace = shouldAppendTrailingWhitespace(mouseEvent, m_frame);
 586 
 587     if (targetNode &amp;&amp; targetNode-&gt;renderer()) {
 588         newSelection = selectClosestWordFromHitTestResultBasedOnLookup(result);
 589         if (newSelection.isNone()) {
 590             VisiblePosition pos(targetNode-&gt;renderer()-&gt;positionForPoint(result.localPoint(), nullptr));
 591             if (pos.isNotNull()) {
 592                 newSelection = VisibleSelection(pos);
 593                 newSelection.expandUsingGranularity(WordGranularity);
 594             }
 595         }
 596 
 597         if (appendTrailingWhitespace == ShouldAppendTrailingWhitespace &amp;&amp; newSelection.isRange())
 598             newSelection.appendTrailingWhitespace();
 599 
 600         updateSelectionForMouseDownDispatchingSelectStart(targetNode, expandSelectionToRespectSelectOnMouseDown(*targetNode, newSelection), WordGranularity);
 601     }
 602 }
 603 
 604 void EventHandler::selectClosestContextualWordOrLinkFromMouseEvent(const MouseEventWithHitTestResults&amp; result)
 605 {
 606     Element* urlElement = result.hitTestResult().URLElement();
 607     if (!urlElement || !isDraggableLink(*urlElement)) {
 608         if (Node* targetNode = result.targetNode()) {
 609             if (isEditableNode(*targetNode))
 610                 return selectClosestWordFromMouseEvent(result);
 611         }
 612 
 613         return selectClosestContextualWordFromMouseEvent(result);
 614     }
 615 
 616     Node* targetNode = result.targetNode();
 617 
 618     if (targetNode &amp;&amp; targetNode-&gt;renderer() &amp;&amp; m_mouseDownMayStartSelect) {
 619         VisibleSelection newSelection;
 620         VisiblePosition pos(targetNode-&gt;renderer()-&gt;positionForPoint(result.localPoint(), nullptr));
 621         if (pos.isNotNull() &amp;&amp; pos.deepEquivalent().deprecatedNode()-&gt;isDescendantOf(*urlElement))
 622             newSelection = VisibleSelection::selectionFromContentsOfNode(urlElement);
 623 
 624         updateSelectionForMouseDownDispatchingSelectStart(targetNode, expandSelectionToRespectSelectOnMouseDown(*targetNode, newSelection), WordGranularity);
 625     }
 626 }
 627 
 628 bool EventHandler::handleMousePressEventDoubleClick(const MouseEventWithHitTestResults&amp; event)
 629 {
 630     if (event.event().button() != LeftButton)
 631         return false;
 632 
 633     if (m_frame.selection().isRange())
 634         // A double-click when range is already selected
 635         // should not change the selection.  So, do not call
 636         // selectClosestWordFromMouseEvent, but do set
 637         // m_beganSelectingText to prevent handleMouseReleaseEvent
 638         // from setting caret selection.
 639         m_selectionInitiationState = ExtendedSelection;
 640     else
 641         selectClosestWordFromMouseEvent(event);
 642 
 643     return true;
 644 }
 645 
 646 bool EventHandler::handleMousePressEventTripleClick(const MouseEventWithHitTestResults&amp; event)
 647 {
 648     if (event.event().button() != LeftButton)
 649         return false;
 650 
 651     Node* targetNode = event.targetNode();
 652     if (!(targetNode &amp;&amp; targetNode-&gt;renderer() &amp;&amp; m_mouseDownMayStartSelect))
 653         return false;
 654 
 655     VisibleSelection newSelection;
 656     VisiblePosition pos(targetNode-&gt;renderer()-&gt;positionForPoint(event.localPoint(), nullptr));
 657     if (pos.isNotNull()) {
 658         newSelection = VisibleSelection(pos);
 659         newSelection.expandUsingGranularity(ParagraphGranularity);
 660     }
 661 
 662     return updateSelectionForMouseDownDispatchingSelectStart(targetNode, expandSelectionToRespectSelectOnMouseDown(*targetNode, newSelection), ParagraphGranularity);
 663 }
 664 
 665 static int textDistance(const Position&amp; start, const Position&amp; end)
 666 {
 667     auto range = Range::create(start.anchorNode()-&gt;document(), start, end);
 668     return TextIterator::rangeLength(range.ptr(), true);
 669 }
 670 
 671 bool EventHandler::handleMousePressEventSingleClick(const MouseEventWithHitTestResults&amp; event)
 672 {
 673     Ref&lt;Frame&gt; protectedFrame(m_frame);
 674 
 675     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
 676     Node* targetNode = event.targetNode();
 677     if (!(targetNode &amp;&amp; targetNode-&gt;renderer() &amp;&amp; m_mouseDownMayStartSelect))
 678         return false;
 679 
 680     // Extend the selection if the Shift key is down, unless the click is in a link.
 681     bool extendSelection = event.event().shiftKey() &amp;&amp; !event.isOverLink();
 682 
 683     // Don&#39;t restart the selection when the mouse is pressed on an
 684     // existing selection so we can allow for text dragging.
 685     if (FrameView* view = m_frame.view()) {
 686         LayoutPoint vPoint = view-&gt;windowToContents(event.event().position());
 687         if (!extendSelection &amp;&amp; m_frame.selection().contains(vPoint)) {
 688             m_mouseDownWasSingleClickInSelection = true;
 689             return false;
 690         }
 691     }
 692 
 693     VisiblePosition visiblePos(targetNode-&gt;renderer()-&gt;positionForPoint(event.localPoint(), nullptr));
 694     if (visiblePos.isNull())
 695         visiblePos = VisiblePosition(firstPositionInOrBeforeNode(targetNode), DOWNSTREAM);
 696     Position pos = visiblePos.deepEquivalent();
 697 
 698     VisibleSelection newSelection = m_frame.selection().selection();
 699     TextGranularity granularity = CharacterGranularity;
 700 
 701     if (!m_frame.editor().client()-&gt;shouldAllowSingleClickToChangeSelection(*targetNode, newSelection))
 702         return true;
 703 
 704     if (extendSelection &amp;&amp; newSelection.isCaretOrRange()) {
 705         VisibleSelection selectionInUserSelectAll = expandSelectionToRespectSelectOnMouseDown(*targetNode, VisibleSelection(pos));
 706         if (selectionInUserSelectAll.isRange()) {
 707             if (comparePositions(selectionInUserSelectAll.start(), newSelection.start()) &lt; 0)
 708                 pos = selectionInUserSelectAll.start();
 709             else if (comparePositions(newSelection.end(), selectionInUserSelectAll.end()) &lt; 0)
 710                 pos = selectionInUserSelectAll.end();
 711         }
 712 
 713         if (!m_frame.editor().behavior().shouldConsiderSelectionAsDirectional() &amp;&amp; pos.isNotNull()) {
 714             // See &lt;rdar://problem/3668157&gt; REGRESSION (Mail): shift-click deselects when selection
 715             // was created right-to-left
 716             Position start = newSelection.start();
 717             Position end = newSelection.end();
 718             int distanceToStart = textDistance(start, pos);
 719             int distanceToEnd = textDistance(pos, end);
 720             if (distanceToStart &lt;= distanceToEnd)
 721                 newSelection = VisibleSelection(end, pos);
 722             else
 723                 newSelection = VisibleSelection(start, pos);
 724         } else
 725             newSelection.setExtent(pos);
 726 
 727         if (m_frame.selection().granularity() != CharacterGranularity) {
 728             granularity = m_frame.selection().granularity();
 729             newSelection.expandUsingGranularity(m_frame.selection().granularity());
 730         }
 731     } else
 732         newSelection = expandSelectionToRespectSelectOnMouseDown(*targetNode, visiblePos);
 733 
 734     bool handled = updateSelectionForMouseDownDispatchingSelectStart(targetNode, newSelection, granularity);
 735 
 736     if (event.event().button() == MiddleButton) {
 737         // Ignore handled, since we want to paste to where the caret was placed anyway.
 738         handled = handlePasteGlobalSelection(event.event()) || handled;
 739     }
 740     return handled;
 741 }
 742 
 743 static inline bool canMouseDownStartSelect(Node* node)
 744 {
 745     if (!node || !node-&gt;renderer())
 746         return true;
 747 
 748     return node-&gt;canStartSelection() || Position::nodeIsUserSelectAll(node);
 749 }
 750 
 751 bool EventHandler::handleMousePressEvent(const MouseEventWithHitTestResults&amp; event)
 752 {
 753     Ref&lt;Frame&gt; protectedFrame(m_frame);
 754 
 755 #if ENABLE(DRAG_SUPPORT)
 756     // Reset drag state.
 757     dragState().source = nullptr;
 758 #endif
 759 
 760 #if !ENABLE(IOS_TOUCH_EVENTS)
 761     cancelFakeMouseMoveEvent();
 762 #endif
 763 
 764     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
 765 
 766     if (ScrollView* scrollView = m_frame.view()) {
 767         if (scrollView-&gt;isPointInScrollbarCorner(event.event().position()))
 768             return false;
 769     }
 770 
 771     bool singleClick = event.event().clickCount() &lt;= 1;
 772 
 773     // If we got the event back, that must mean it wasn&#39;t prevented,
 774     // so it&#39;s allowed to start a drag or selection if it wasn&#39;t in a scrollbar.
 775     m_mouseDownMayStartSelect = canMouseDownStartSelect(event.targetNode()) &amp;&amp; !event.scrollbar();
 776 
 777 #if ENABLE(DRAG_SUPPORT)
 778     // Careful that the drag starting logic stays in sync with eventMayStartDrag()
 779     // FIXME: eventMayStartDrag() does not check for shift key press, link or image event targets.
 780     // Bug: https://bugs.webkit.org/show_bug.cgi?id=155390
 781 
 782     // Single mouse down on links or images can always trigger drag-n-drop.
 783     bool isMouseDownOnLinkOrImage = event.isOverLink() || event.hitTestResult().image();
 784     m_mouseDownMayStartDrag = singleClick &amp;&amp; (!event.event().shiftKey() || isMouseDownOnLinkOrImage) &amp;&amp; shouldAllowMouseDownToStartDrag();
 785 #endif
 786 
 787     m_mouseDownWasSingleClickInSelection = false;
 788 
 789     m_mouseDown = event.event();
 790 
 791     if (m_immediateActionStage != ImmediateActionStage::PerformedHitTest)
 792         m_immediateActionStage = ImmediateActionStage::None;
 793 
 794     if (event.isOverWidget() &amp;&amp; passWidgetMouseDownEventToWidget(event))
 795         return true;
 796 
 797     if (is&lt;SVGDocument&gt;(*m_frame.document()) &amp;&amp; downcast&lt;SVGDocument&gt;(*m_frame.document()).zoomAndPanEnabled()) {
 798         if (event.event().shiftKey() &amp;&amp; singleClick) {
 799             m_svgPan = true;
 800             downcast&lt;SVGDocument&gt;(*m_frame.document()).startPan(m_frame.view()-&gt;windowToContents(event.event().position()));
 801             return true;
 802         }
 803     }
 804 
 805     // We don&#39;t do this at the start of mouse down handling,
 806     // because we don&#39;t want to do it until we know we didn&#39;t hit a widget.
 807     if (singleClick)
 808         focusDocumentView();
 809 
 810     m_mousePressNode = event.targetNode();
 811     m_frame.document()-&gt;setFocusNavigationStartingNode(event.targetNode());
 812 
 813 #if ENABLE(DRAG_SUPPORT)
 814     m_dragStartPosition = event.event().position();
 815 #endif
 816 
 817     m_mousePressed = true;
 818     m_selectionInitiationState = HaveNotStartedSelection;
 819 
 820     bool swallowEvent = false;
 821     if (event.event().clickCount() == 2)
 822         swallowEvent = handleMousePressEventDoubleClick(event);
 823     else if (event.event().clickCount() &gt;= 3)
 824         swallowEvent = handleMousePressEventTripleClick(event);
 825     else
 826         swallowEvent = handleMousePressEventSingleClick(event);
 827 
 828     m_mouseDownMayStartAutoscroll = m_mouseDownMayStartSelect
 829         || (m_mousePressNode &amp;&amp; m_mousePressNode-&gt;renderBox() &amp;&amp; m_mousePressNode-&gt;renderBox()-&gt;canBeProgramaticallyScrolled());
 830 
 831     return swallowEvent;
 832 }
 833 
 834 VisiblePosition EventHandler::selectionExtentRespectingEditingBoundary(const VisibleSelection&amp; selection, const LayoutPoint&amp; localPoint, Node* targetNode)
 835 {
 836     FloatPoint selectionEndPoint = localPoint;
 837     Element* editableElement = selection.rootEditableElement();
 838 
 839     if (!targetNode || !targetNode-&gt;renderer())
 840         return VisiblePosition();
 841 
 842     if (editableElement &amp;&amp; !editableElement-&gt;contains(targetNode)) {
 843         if (!editableElement-&gt;renderer())
 844             return VisiblePosition();
 845 
 846         FloatPoint absolutePoint = targetNode-&gt;renderer()-&gt;localToAbsolute(FloatPoint(selectionEndPoint));
 847         selectionEndPoint = editableElement-&gt;renderer()-&gt;absoluteToLocal(absolutePoint);
 848         targetNode = editableElement;
 849     }
 850 
 851     return targetNode-&gt;renderer()-&gt;positionForPoint(LayoutPoint(selectionEndPoint), nullptr);
 852 }
 853 
 854 #if ENABLE(DRAG_SUPPORT)
 855 
 856 #if !PLATFORM(IOS_FAMILY)
 857 
 858 bool EventHandler::supportsSelectionUpdatesOnMouseDrag() const
 859 {
 860     return true;
 861 }
 862 
 863 bool EventHandler::shouldAllowMouseDownToStartDrag() const
 864 {
 865     return true;
 866 }
 867 
 868 #endif
 869 
 870 bool EventHandler::handleMouseDraggedEvent(const MouseEventWithHitTestResults&amp; event, CheckDragHysteresis checkDragHysteresis)
 871 {
 872     if (!m_mousePressed)
 873         return false;
 874 
 875     Ref&lt;Frame&gt; protectedFrame(m_frame);
 876 
 877     if (handleDrag(event, checkDragHysteresis))
 878         return true;
 879 
 880     Node* targetNode = event.targetNode();
 881     if (event.event().button() != LeftButton || !targetNode)
 882         return false;
 883 
 884     RenderObject* renderer = targetNode-&gt;renderer();
 885     if (!renderer) {
 886         Element* parent = targetNode-&gt;parentOrShadowHostElement();
 887         if (!parent)
 888             return false;
 889 
 890         renderer = parent-&gt;renderer();
 891         if (!renderer || !renderer-&gt;isListBox())
 892             return false;
 893     }
 894 
 895 #if PLATFORM(COCOA) // FIXME: Why does this assertion fire on other platforms?
 896     ASSERT(m_mouseDownMayStartSelect || m_mouseDownMayStartAutoscroll);
 897 #endif
 898 
 899     m_mouseDownMayStartDrag = false;
 900 
 901     if (m_mouseDownMayStartAutoscroll &amp;&amp; !panScrollInProgress()) {
 902         m_autoscrollController-&gt;startAutoscrollForSelection(renderer);
 903         m_mouseDownMayStartAutoscroll = false;
 904     }
 905 
 906     if (m_selectionInitiationState != ExtendedSelection) {
 907         HitTestResult result(m_mouseDownPos);
 908         m_frame.document()-&gt;hitTest(HitTestRequest(), result);
 909 
 910         updateSelectionForMouseDrag(result);
 911     }
 912     updateSelectionForMouseDrag(event.hitTestResult());
 913     return true;
 914 }
 915 
 916 bool EventHandler::eventMayStartDrag(const PlatformMouseEvent&amp; event) const
 917 {
 918     // This is a pre-flight check of whether the event might lead to a drag being started.  Be careful
 919     // that its logic needs to stay in sync with handleMouseMoveEvent() and the way we setMouseDownMayStartDrag
 920     // in handleMousePressEvent
 921     auto* document = m_frame.document();
 922     if (!document)
 923         return false;
 924 
 925     if (event.button() != LeftButton || event.clickCount() != 1)
 926         return false;
 927 
 928     FrameView* view = m_frame.view();
 929     if (!view)
 930         return false;
 931 
 932     Page* page = m_frame.page();
 933     if (!page)
 934         return false;
 935 
 936     Ref&lt;Frame&gt; protectedFrame(m_frame);
 937 
 938     updateDragSourceActionsAllowed();
 939     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
 940     HitTestResult result(view-&gt;windowToContents(event.position()));
 941     document-&gt;hitTest(request, result);
 942     DragState state;
 943     Element* targetElement = result.targetElement();
 944     return targetElement &amp;&amp; page-&gt;dragController().draggableElement(&amp;m_frame, targetElement, result.roundedPointInInnerNodeFrame(), state);
 945 }
 946 
 947 void EventHandler::updateSelectionForMouseDrag()
 948 {
 949     if (!supportsSelectionUpdatesOnMouseDrag())
 950         return;
 951 
 952     FrameView* view = m_frame.view();
 953     if (!view)
 954         return;
 955     auto* document = m_frame.document();
 956     if (!document)
 957         return;
 958 
 959     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::Move | HitTestRequest::DisallowUserAgentShadowContent);
 960     HitTestResult result(view-&gt;windowToContents(m_lastKnownMousePosition));
 961     document-&gt;hitTest(request, result);
 962     updateSelectionForMouseDrag(result);
 963 }
 964 
 965 void EventHandler::updateSelectionForMouseDrag(const HitTestResult&amp; hitTestResult)
 966 {
 967     if (!supportsSelectionUpdatesOnMouseDrag())
 968         return;
 969 
 970     if (!m_mouseDownMayStartSelect)
 971         return;
 972 
 973     Node* target = hitTestResult.targetNode();
 974     if (!target)
 975         return;
 976 
 977     VisiblePosition targetPosition = selectionExtentRespectingEditingBoundary(m_frame.selection().selection(), hitTestResult.localPoint(), target);
 978 
 979     // Don&#39;t modify the selection if we&#39;re not on a node.
 980     if (targetPosition.isNull())
 981         return;
 982 
 983     // Restart the selection if this is the first mouse move. This work is usually
 984     // done in handleMousePressEvent, but not if the mouse press was on an existing selection.
 985     VisibleSelection newSelection = m_frame.selection().selection();
 986 
 987     // Special case to limit selection to the containing block for SVG text.
 988     // FIXME: Isn&#39;t there a better non-SVG-specific way to do this?
 989     if (Node* selectionBaseNode = newSelection.base().deprecatedNode()) {
 990         if (RenderObject* selectionBaseRenderer = selectionBaseNode-&gt;renderer()) {
 991             if (selectionBaseRenderer-&gt;isSVGText()) {
 992                 if (target-&gt;renderer()-&gt;containingBlock() != selectionBaseRenderer-&gt;containingBlock())
 993                     return;
 994             }
 995         }
 996     }
 997 
 998 
 999     if (m_selectionInitiationState == HaveNotStartedSelection &amp;&amp; !dispatchSelectStart(target)) {
1000         m_mouseDownMayStartSelect = false;
1001         return;
1002     }
1003 
1004     if (m_selectionInitiationState != ExtendedSelection) {
1005         // Always extend selection here because it&#39;s caused by a mouse drag
1006         m_selectionInitiationState = ExtendedSelection;
1007         newSelection = VisibleSelection(targetPosition);
1008     }
1009 
1010 #if ENABLE(USERSELECT_ALL)
1011     Node* rootUserSelectAllForMousePressNode = Position::rootUserSelectAllForNode(m_mousePressNode.get());
1012     if (rootUserSelectAllForMousePressNode &amp;&amp; rootUserSelectAllForMousePressNode == Position::rootUserSelectAllForNode(target)) {
1013         newSelection.setBase(positionBeforeNode(rootUserSelectAllForMousePressNode).upstream(CanCrossEditingBoundary));
1014         newSelection.setExtent(positionAfterNode(rootUserSelectAllForMousePressNode).downstream(CanCrossEditingBoundary));
1015     } else {
1016         // Reset base for user select all when base is inside user-select-all area and extent &lt; base.
1017         if (rootUserSelectAllForMousePressNode &amp;&amp; comparePositions(target-&gt;renderer()-&gt;positionForPoint(hitTestResult.localPoint(), nullptr), m_mousePressNode-&gt;renderer()-&gt;positionForPoint(m_dragStartPosition, nullptr)) &lt; 0)
1018             newSelection.setBase(positionAfterNode(rootUserSelectAllForMousePressNode).downstream(CanCrossEditingBoundary));
1019 
1020         Node* rootUserSelectAllForTarget = Position::rootUserSelectAllForNode(target);
1021         if (rootUserSelectAllForTarget &amp;&amp; m_mousePressNode-&gt;renderer() &amp;&amp; comparePositions(target-&gt;renderer()-&gt;positionForPoint(hitTestResult.localPoint(), nullptr), m_mousePressNode-&gt;renderer()-&gt;positionForPoint(m_dragStartPosition, nullptr)) &lt; 0)
1022             newSelection.setExtent(positionBeforeNode(rootUserSelectAllForTarget).upstream(CanCrossEditingBoundary));
1023         else if (rootUserSelectAllForTarget &amp;&amp; m_mousePressNode-&gt;renderer())
1024             newSelection.setExtent(positionAfterNode(rootUserSelectAllForTarget).downstream(CanCrossEditingBoundary));
1025         else
1026             newSelection.setExtent(targetPosition);
1027     }
1028 #else
1029     newSelection.setExtent(targetPosition);
1030 #endif
1031 
1032     if (m_frame.selection().granularity() != CharacterGranularity)
1033         newSelection.expandUsingGranularity(m_frame.selection().granularity());
1034 
1035     m_frame.selection().setSelectionByMouseIfDifferent(newSelection, m_frame.selection().granularity(),
1036         FrameSelection::AdjustEndpointsAtBidiBoundary);
1037 }
1038 #endif // ENABLE(DRAG_SUPPORT)
1039 
1040 void EventHandler::lostMouseCapture()
1041 {
1042     m_frame.selection().setCaretBlinkingSuspended(false);
1043 }
1044 
1045 bool EventHandler::handleMouseUp(const MouseEventWithHitTestResults&amp; event)
1046 {
1047     if (eventLoopHandleMouseUp(event))
1048         return true;
1049 
1050     // If this was the first click in the window, we don&#39;t even want to clear the selection.
1051     // This case occurs when the user clicks on a draggable element, since we have to process
1052     // the mouse down and drag events to see if we might start a drag.  For other first clicks
1053     // in a window, we just don&#39;t acceptFirstMouse, and the whole down-drag-up sequence gets
1054     // ignored upstream of this layer.
1055     return eventActivatedView(event.event());
1056 }
1057 
1058 bool EventHandler::handleMouseReleaseEvent(const MouseEventWithHitTestResults&amp; event)
1059 {
1060     if (autoscrollInProgress())
1061         stopAutoscrollTimer();
1062 
1063     Ref&lt;Frame&gt; protectedFrame(m_frame);
1064 
1065     if (handleMouseUp(event))
1066         return true;
1067 
1068     // Used to prevent mouseMoveEvent from initiating a drag before
1069     // the mouse is pressed again.
1070     m_mousePressed = false;
1071     m_capturesDragging = false;
1072 #if ENABLE(DRAG_SUPPORT)
1073     m_mouseDownMayStartDrag = false;
1074 #endif
1075     m_mouseDownMayStartSelect = false;
1076     m_mouseDownMayStartAutoscroll = false;
1077     m_mouseDownWasInSubframe = false;
1078 
1079     bool handled = false;
1080 
1081     // Clear the selection if the mouse didn&#39;t move after the last mouse
1082     // press and it&#39;s not a context menu click.  We do this so when clicking
1083     // on the selection, the selection goes away.  However, if we are
1084     // editing, place the caret.
1085     if (m_mouseDownWasSingleClickInSelection &amp;&amp; m_selectionInitiationState != ExtendedSelection
1086 #if ENABLE(DRAG_SUPPORT)
1087             &amp;&amp; m_dragStartPosition == event.event().position()
1088 #endif
1089             &amp;&amp; m_frame.selection().isRange()
1090             &amp;&amp; event.event().button() != RightButton) {
1091         VisibleSelection newSelection;
1092         Node* node = event.targetNode();
1093         bool caretBrowsing = m_frame.settings().caretBrowsingEnabled();
1094         bool allowSelectionChanges = true;
1095         if (node &amp;&amp; node-&gt;renderer() &amp;&amp; (caretBrowsing || node-&gt;hasEditableStyle())) {
1096             VisiblePosition pos = node-&gt;renderer()-&gt;positionForPoint(event.localPoint(), nullptr);
1097             newSelection = VisibleSelection(pos);
1098 #if PLATFORM(IOS_FAMILY)
1099             // On iOS, selection changes are triggered using platform-specific text interaction gestures rather than
1100             // default behavior on click or mouseup. As such, the only time we should allow click events to change the
1101             // selection on iOS is when we focus a different editable element, in which case the text interaction
1102             // gestures will fail.
1103             allowSelectionChanges = m_frame.selection().selection().rootEditableElement() != newSelection.rootEditableElement();
1104 #endif
1105         }
1106 
1107         if (allowSelectionChanges)
1108             setSelectionIfNeeded(m_frame.selection(), newSelection);
1109 
1110         handled = true;
1111     }
1112 
1113     if (event.event().button() == MiddleButton) {
1114         // Ignore handled, since we want to paste to where the caret was placed anyway.
1115         handled = handlePasteGlobalSelection(event.event()) || handled;
1116     }
1117 
1118     return handled;
1119 }
1120 
1121 #if ENABLE(PAN_SCROLLING)
1122 
1123 void EventHandler::didPanScrollStart()
1124 {
1125     m_autoscrollController-&gt;didPanScrollStart();
1126 }
1127 
1128 void EventHandler::didPanScrollStop()
1129 {
1130     m_autoscrollController-&gt;didPanScrollStop();
1131 }
1132 
1133 void EventHandler::startPanScrolling(RenderElement&amp; renderer)
1134 {
1135 #if !PLATFORM(IOS_FAMILY)
1136     if (!is&lt;RenderBox&gt;(renderer))
1137         return;
1138     m_autoscrollController-&gt;startPanScrolling(&amp;downcast&lt;RenderBox&gt;(renderer), lastKnownMousePosition());
1139     invalidateClick();
1140 #endif
1141 }
1142 
1143 #endif // ENABLE(PAN_SCROLLING)
1144 
1145 RenderBox* EventHandler::autoscrollRenderer() const
1146 {
1147     return m_autoscrollController-&gt;autoscrollRenderer();
1148 }
1149 
1150 void EventHandler::updateAutoscrollRenderer()
1151 {
1152     m_autoscrollController-&gt;updateAutoscrollRenderer();
1153 }
1154 
1155 bool EventHandler::autoscrollInProgress() const
1156 {
1157     return m_autoscrollController-&gt;autoscrollInProgress();
1158 }
1159 
1160 bool EventHandler::panScrollInProgress() const
1161 {
1162     return m_autoscrollController-&gt;panScrollInProgress();
1163 }
1164 
1165 #if ENABLE(DRAG_SUPPORT)
1166 DragSourceAction EventHandler::updateDragSourceActionsAllowed() const
1167 {
1168     Page* page = m_frame.page();
1169     if (!page)
1170         return DragSourceActionNone;
1171 
1172     FrameView* view = m_frame.view();
1173     if (!view)
1174         return DragSourceActionNone;
1175 
1176     return page-&gt;dragController().delegateDragSourceAction(view-&gt;contentsToRootView(m_mouseDownPos));
1177 }
1178 #endif // ENABLE(DRAG_SUPPORT)
1179 
1180 HitTestResult EventHandler::hitTestResultAtPoint(const LayoutPoint&amp; point, HitTestRequest::HitTestRequestType hitType, const LayoutSize&amp; padding) const
1181 {
1182     ASSERT((hitType &amp; HitTestRequest::CollectMultipleElements) || padding.isEmpty());
1183 
1184     Ref&lt;Frame&gt; protectedFrame(m_frame);
1185 
1186     // We always send hitTestResultAtPoint to the main frame if we have one,
1187     // otherwise we might hit areas that are obscured by higher frames.
1188     if (!m_frame.isMainFrame()) {
1189         Frame&amp; mainFrame = m_frame.mainFrame();
1190         FrameView* frameView = m_frame.view();
1191         FrameView* mainView = mainFrame.view();
1192         if (frameView &amp;&amp; mainView) {
1193             IntPoint mainFramePoint = mainView-&gt;rootViewToContents(frameView-&gt;contentsToRootView(roundedIntPoint(point)));
1194             return mainFrame.eventHandler().hitTestResultAtPoint(mainFramePoint, hitType, padding);
1195         }
1196     }
1197 
1198     unsigned nonNegativePaddingWidth = std::max&lt;LayoutUnit&gt;(0, padding.width()).toUnsigned();
1199     unsigned nonNegativePaddingHeight = std::max&lt;LayoutUnit&gt;(0, padding.height()).toUnsigned();
1200 
1201     // We should always start hit testing a clean tree.
1202     if (auto* frameView = m_frame.view())
1203         frameView-&gt;updateLayoutAndStyleIfNeededRecursive();
1204 
1205     HitTestResult result(point, nonNegativePaddingHeight, nonNegativePaddingWidth, nonNegativePaddingHeight, nonNegativePaddingWidth);
1206     auto* document = m_frame.document();
1207     if (!document)
1208         return result;
1209 
1210     HitTestRequest request(hitType);
1211     document-&gt;hitTest(request, result);
1212     if (!request.readOnly())
1213         m_frame.document()-&gt;updateHoverActiveState(request, result.targetElement());
1214 
1215     if (request.disallowsUserAgentShadowContent())
1216         result.setToNonUserAgentShadowAncestor();
1217 
1218     return result;
1219 }
1220 
1221 void EventHandler::stopAutoscrollTimer(bool rendererIsBeingDestroyed)
1222 {
1223     m_autoscrollController-&gt;stopAutoscrollTimer(rendererIsBeingDestroyed);
1224 }
1225 
1226 bool EventHandler::scrollOverflow(ScrollDirection direction, ScrollGranularity granularity, Node* startingNode)
1227 {
1228     Node* node = startingNode;
1229 
1230     if (!node)
1231         node = m_frame.document()-&gt;focusedElement();
1232 
1233     if (!node)
1234         node = m_mousePressNode.get();
1235 
1236     if (node) {
1237         auto r = node-&gt;renderer();
1238         if (r &amp;&amp; !r-&gt;isListBox() &amp;&amp; r-&gt;enclosingBox().scroll(direction, granularity)) {
1239             setFrameWasScrolledByUser();
1240             return true;
1241         }
1242     }
1243 
1244     return false;
1245 }
1246 
1247 bool EventHandler::logicalScrollOverflow(ScrollLogicalDirection direction, ScrollGranularity granularity, Node* startingNode)
1248 {
1249     Node* node = startingNode;
1250 
1251     if (!node)
1252         node = m_frame.document()-&gt;focusedElement();
1253 
1254     if (!node)
1255         node = m_mousePressNode.get();
1256 
1257     if (node) {
1258         auto r = node-&gt;renderer();
1259         if (r &amp;&amp; !r-&gt;isListBox() &amp;&amp; r-&gt;enclosingBox().logicalScroll(direction, granularity)) {
1260             setFrameWasScrolledByUser();
1261             return true;
1262         }
1263     }
1264 
1265     return false;
1266 }
1267 
1268 bool EventHandler::scrollRecursively(ScrollDirection direction, ScrollGranularity granularity, Node* startingNode)
1269 {
1270     Ref&lt;Frame&gt; protectedFrame(m_frame);
1271 
1272     // The layout needs to be up to date to determine if we can scroll. We may be
1273     // here because of an onLoad event, in which case the final layout hasn&#39;t been performed yet.
1274     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
1275     if (scrollOverflow(direction, granularity, startingNode))
1276         return true;
1277     Frame* frame = &amp;m_frame;
1278     FrameView* view = frame-&gt;view();
1279     if (view &amp;&amp; view-&gt;scroll(direction, granularity))
1280         return true;
1281     frame = frame-&gt;tree().parent();
1282     if (!frame)
1283         return false;
1284     return frame-&gt;eventHandler().scrollRecursively(direction, granularity, m_frame.ownerElement());
1285 }
1286 
1287 bool EventHandler::logicalScrollRecursively(ScrollLogicalDirection direction, ScrollGranularity granularity, Node* startingNode)
1288 {
1289     Ref&lt;Frame&gt; protectedFrame(m_frame);
1290 
1291     // The layout needs to be up to date to determine if we can scroll. We may be
1292     // here because of an onLoad event, in which case the final layout hasn&#39;t been performed yet.
1293     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
1294     if (logicalScrollOverflow(direction, granularity, startingNode))
1295         return true;
1296     Frame* frame = &amp;m_frame;
1297     FrameView* view = frame-&gt;view();
1298 
1299     bool scrolled = false;
1300 #if PLATFORM(COCOA)
1301     // Mac also resets the scroll position in the inline direction.
1302     if (granularity == ScrollByDocument &amp;&amp; view &amp;&amp; view-&gt;logicalScroll(ScrollInlineDirectionBackward, ScrollByDocument))
1303         scrolled = true;
1304 #endif
1305     if (view &amp;&amp; view-&gt;logicalScroll(direction, granularity))
1306         scrolled = true;
1307 
1308     if (scrolled)
1309         return true;
1310 
1311     frame = frame-&gt;tree().parent();
1312     if (!frame)
1313         return false;
1314 
1315     return frame-&gt;eventHandler().logicalScrollRecursively(direction, granularity, m_frame.ownerElement());
1316 }
1317 
1318 IntPoint EventHandler::lastKnownMousePosition() const
1319 {
1320     return m_lastKnownMousePosition;
1321 }
1322 
1323 Frame* EventHandler::subframeForHitTestResult(const MouseEventWithHitTestResults&amp; hitTestResult)
1324 {
1325     if (!hitTestResult.isOverWidget())
1326         return 0;
1327     return subframeForTargetNode(hitTestResult.targetNode());
1328 }
1329 
1330 Frame* EventHandler::subframeForTargetNode(Node* node)
1331 {
1332     if (!node)
1333         return nullptr;
1334 
1335     auto renderer = node-&gt;renderer();
1336     if (!is&lt;RenderWidget&gt;(renderer))
1337         return nullptr;
1338 
1339     Widget* widget = downcast&lt;RenderWidget&gt;(*renderer).widget();
1340     if (!is&lt;FrameView&gt;(widget))
1341         return nullptr;
1342 
1343     return &amp;downcast&lt;FrameView&gt;(*widget).frame();
1344 }
1345 
1346 #if ENABLE(CURSOR_SUPPORT)
1347 static bool isSubmitImage(Node* node)
1348 {
1349     return is&lt;HTMLInputElement&gt;(node) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*node).isImageButton();
1350 }
1351 
1352 // Returns true if the node&#39;s editable block is not current focused for editing
1353 static bool nodeIsNotBeingEdited(const Node&amp; node, const Frame&amp; frame)
1354 {
1355     return frame.selection().selection().rootEditableElement() != node.rootEditableElement();
1356 }
1357 
1358 bool EventHandler::useHandCursor(Node* node, bool isOverLink, bool shiftKey)
1359 {
1360     if (!node)
1361         return false;
1362 
1363     bool editable = node-&gt;hasEditableStyle();
1364     bool editableLinkEnabled = false;
1365 
1366     // If the link is editable, then we need to check the settings to see whether or not the link should be followed
1367     if (editable) {
1368         switch (m_frame.settings().editableLinkBehavior()) {
1369         default:
1370         case EditableLinkDefaultBehavior:
1371         case EditableLinkAlwaysLive:
1372             editableLinkEnabled = true;
1373             break;
1374 
1375         case EditableLinkNeverLive:
1376             editableLinkEnabled = false;
1377             break;
1378 
1379         case EditableLinkLiveWhenNotFocused:
1380             editableLinkEnabled = nodeIsNotBeingEdited(*node, m_frame) || shiftKey;
1381             break;
1382 
1383         case EditableLinkOnlyLiveWithShiftKey:
1384             editableLinkEnabled = shiftKey;
1385             break;
1386         }
1387     }
1388 
1389     return ((isOverLink || isSubmitImage(node)) &amp;&amp; (!editable || editableLinkEnabled));
1390 }
1391 
1392 void EventHandler::cursorUpdateTimerFired()
1393 {
1394     ASSERT(m_frame.document());
1395     updateCursor();
1396 }
1397 
1398 void EventHandler::updateCursor()
1399 {
1400     if (m_mousePositionIsUnknown)
1401         return;
1402 
1403     FrameView* view = m_frame.view();
1404     if (!view)
1405         return;
1406 
1407     auto* document = m_frame.document();
1408     if (!document)
1409         return;
1410 
1411     if (!view-&gt;shouldSetCursor())
1412         return;
1413 
1414     bool shiftKey;
1415     bool ctrlKey;
1416     bool altKey;
1417     bool metaKey;
1418     PlatformKeyboardEvent::getCurrentModifierState(shiftKey, ctrlKey, altKey, metaKey);
1419 
1420     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::AllowFrameScrollbars);
1421     HitTestResult result(view-&gt;windowToContents(m_lastKnownMousePosition));
1422     document-&gt;hitTest(request, result);
1423 
1424     updateCursor(*view, result, shiftKey);
1425 }
1426 
1427 void EventHandler::updateCursor(FrameView&amp; view, const HitTestResult&amp; result, bool shiftKey)
1428 {
1429     if (auto optionalCursor = selectCursor(result, shiftKey)) {
1430         m_currentMouseCursor = WTFMove(optionalCursor.value());
1431         view.setCursor(m_currentMouseCursor);
1432     }
1433 }
1434 
1435 Optional&lt;Cursor&gt; EventHandler::selectCursor(const HitTestResult&amp; result, bool shiftKey)
1436 {
1437     if (m_resizeLayer &amp;&amp; m_resizeLayer-&gt;inResizeMode())
1438         return WTF::nullopt;
1439 
1440     if (!m_frame.page())
1441         return WTF::nullopt;
1442 
1443 #if ENABLE(PAN_SCROLLING)
1444     if (m_frame.mainFrame().eventHandler().panScrollInProgress())
1445         return WTF::nullopt;
1446 #endif
1447 
1448     Ref&lt;Frame&gt; protectedFrame(m_frame);
1449 
1450     // Use always pointer cursor for scrollbars.
1451     if (result.scrollbar()) {
1452 #if ENABLE(CURSOR_VISIBILITY)
1453         cancelAutoHideCursorTimer();
1454 #endif
1455         return pointerCursor();
1456     }
1457 
1458     Node* node = result.targetNode();
1459     if (!node)
1460         return WTF::nullopt;
1461 
1462     auto renderer = node-&gt;renderer();
1463     auto* style = renderer ? &amp;renderer-&gt;style() : nullptr;
1464     bool horizontalText = !style || style-&gt;isHorizontalWritingMode();
1465     const Cursor&amp; iBeam = horizontalText ? iBeamCursor() : verticalTextCursor();
1466 
1467 #if ENABLE(CURSOR_VISIBILITY)
1468     if (style &amp;&amp; style-&gt;cursorVisibility() == CursorVisibility::AutoHide)
1469         startAutoHideCursorTimer();
1470     else
1471         cancelAutoHideCursorTimer();
1472 #endif
1473 
1474     if (renderer) {
1475         Cursor overrideCursor;
1476         switch (renderer-&gt;getCursor(roundedIntPoint(result.localPoint()), overrideCursor)) {
1477         case SetCursorBasedOnStyle:
1478             break;
1479         case SetCursor:
1480             return overrideCursor;
1481         case DoNotSetCursor:
1482             return WTF::nullopt;
1483         }
1484     }
1485 
1486     if (style &amp;&amp; style-&gt;cursors()) {
1487         const CursorList* cursors = style-&gt;cursors();
1488         for (unsigned i = 0; i &lt; cursors-&gt;size(); ++i) {
1489             StyleImage* styleImage = (*cursors)[i].image();
1490             if (!styleImage)
1491                 continue;
1492             CachedImage* cachedImage = styleImage-&gt;cachedImage();
1493             if (!cachedImage)
1494                 continue;
1495             float scale = styleImage-&gt;imageScaleFactor();
1496             // Get hotspot and convert from logical pixels to physical pixels.
1497             IntPoint hotSpot = (*cursors)[i].hotSpot();
1498             FloatSize size = cachedImage-&gt;imageForRenderer(renderer)-&gt;size();
1499             if (cachedImage-&gt;errorOccurred())
1500                 continue;
1501             // Limit the size of cursors (in UI pixels) so that they cannot be
1502             // used to cover UI elements in chrome.
1503             size.scale(1 / scale);
1504             if (size.width() &gt; maximumCursorSize || size.height() &gt; maximumCursorSize)
1505                 continue;
1506 
1507             Image* image = cachedImage-&gt;imageForRenderer(renderer);
1508 #if ENABLE(MOUSE_CURSOR_SCALE)
1509             // Ensure no overflow possible in calculations above.
1510             if (scale &lt; minimumCursorScale)
1511                 continue;
1512             return Cursor(image, hotSpot, scale);
1513 #else
1514             ASSERT(scale == 1);
1515             return Cursor(image, hotSpot);
1516 #endif // ENABLE(MOUSE_CURSOR_SCALE)
1517         }
1518     }
1519 
1520     // During selection, use an I-beam regardless of the content beneath the cursor.
1521     // If a drag may be starting or we&#39;re capturing mouse events for a particular node, don&#39;t treat this as a selection.
1522     if (m_mousePressed
1523         &amp;&amp; m_mouseDownMayStartSelect
1524 #if ENABLE(DRAG_SUPPORT)
1525         &amp;&amp; !m_mouseDownMayStartDrag
1526 #endif
1527         &amp;&amp; m_frame.selection().isCaretOrRange()
1528         &amp;&amp; !m_capturingMouseEventsElement)
1529         return iBeam;
1530 
1531     switch (style ? style-&gt;cursor() : CursorType::Auto) {
1532     case CursorType::Auto: {
1533         bool editable = node-&gt;hasEditableStyle();
1534 
1535         if (useHandCursor(node, result.isOverLink(), shiftKey))
1536             return handCursor();
1537 
1538         bool inResizer = false;
1539         if (renderer) {
1540             if (RenderLayer* layer = renderer-&gt;enclosingLayer()) {
1541                 if (FrameView* view = m_frame.view())
1542                     inResizer = layer-&gt;isPointInResizeControl(view-&gt;windowToContents(roundedIntPoint(result.localPoint())));
1543             }
1544         }
1545 
1546         if ((editable || (renderer &amp;&amp; renderer-&gt;isText() &amp;&amp; node-&gt;canStartSelection())) &amp;&amp; !inResizer &amp;&amp; !result.scrollbar())
1547             return iBeam;
1548         return pointerCursor();
1549     }
1550     case CursorType::Default:
1551         return pointerCursor();
1552     case CursorType::None:
1553         return noneCursor();
1554     case CursorType::ContextMenu:
1555         return contextMenuCursor();
1556     case CursorType::Help:
1557         return helpCursor();
1558     case CursorType::Pointer:
1559         return handCursor();
1560     case CursorType::Progress:
1561         return progressCursor();
1562     case CursorType::Wait:
1563         return waitCursor();
1564     case CursorType::Cell:
1565         return cellCursor();
1566     case CursorType::Crosshair:
1567         return crossCursor();
1568     case CursorType::Text:
1569         return iBeamCursor();
1570     case CursorType::VerticalText:
1571         return verticalTextCursor();
1572     case CursorType::Alias:
1573         return aliasCursor();
1574     case CursorType::Copy:
1575         return copyCursor();
1576     case CursorType::Move:
1577         return moveCursor();
1578     case CursorType::NoDrop:
1579         return noDropCursor();
1580     case CursorType::NotAllowed:
1581         return notAllowedCursor();
1582     case CursorType::Grab:
1583         return grabCursor();
1584     case CursorType::Grabbing:
1585         return grabbingCursor();
1586     case CursorType::EResize:
1587         return eastResizeCursor();
1588     case CursorType::NResize:
1589         return northResizeCursor();
1590     case CursorType::NEResize:
1591         return northEastResizeCursor();
1592     case CursorType::NWResize:
1593         return northWestResizeCursor();
1594     case CursorType::SResize:
1595         return southResizeCursor();
1596     case CursorType::SEResize:
1597         return southEastResizeCursor();
1598     case CursorType::SWResize:
1599         return southWestResizeCursor();
1600     case CursorType::WResize:
1601         return westResizeCursor();
1602     case CursorType::EWResize:
1603         return eastWestResizeCursor();
1604     case CursorType::NSResize:
1605         return northSouthResizeCursor();
1606     case CursorType::NESWResize:
1607         return northEastSouthWestResizeCursor();
1608     case CursorType::NWSEResize:
1609         return northWestSouthEastResizeCursor();
1610     case CursorType::ColumnResize:
1611         return columnResizeCursor();
1612     case CursorType::RowResize:
1613         return rowResizeCursor();
1614     case CursorType::AllScroll:
1615         return moveCursor();
1616     case CursorType::ZoomIn:
1617         return zoomInCursor();
1618     case CursorType::ZoomOut:
1619         return zoomOutCursor();
1620     }
1621     return pointerCursor();
1622 }
1623 #endif // ENABLE(CURSOR_SUPPORT)
1624 
1625 #if ENABLE(CURSOR_VISIBILITY)
1626 void EventHandler::startAutoHideCursorTimer()
1627 {
1628     Page* page = m_frame.page();
1629     if (!page)
1630         return;
1631 
1632     m_autoHideCursorTimer.startOneShot(page-&gt;settings().timeWithoutMouseMovementBeforeHidingControls());
1633 
1634 #if !ENABLE(IOS_TOUCH_EVENTS)
1635     // The fake mouse move event screws up the auto-hide feature (by resetting the auto-hide timer)
1636     // so cancel any pending fake mouse moves.
1637     if (m_fakeMouseMoveEventTimer.isActive())
1638         m_fakeMouseMoveEventTimer.stop();
1639 #endif
1640 }
1641 
1642 void EventHandler::cancelAutoHideCursorTimer()
1643 {
1644     if (m_autoHideCursorTimer.isActive())
1645         m_autoHideCursorTimer.stop();
1646 }
1647 
1648 void EventHandler::autoHideCursorTimerFired()
1649 {
1650     FrameView* view = m_frame.view();
1651     if (!view || !view-&gt;isActive())
1652         return;
1653 
1654     if (auto page = m_frame.page())
1655         page-&gt;chrome().setCursorHiddenUntilMouseMoves(true);
1656 }
1657 #endif
1658 
1659 static LayoutPoint documentPointForWindowPoint(Frame&amp; frame, const IntPoint&amp; windowPoint)
1660 {
1661     FrameView* view = frame.view();
1662     // FIXME: Is it really OK to use the wrong coordinates here when view is 0?
1663     // Historically the code would just crash; this is clearly no worse than that.
1664     return view ? view-&gt;windowToContents(windowPoint) : windowPoint;
1665 }
1666 
1667 static Scrollbar* scrollbarForMouseEvent(const MouseEventWithHitTestResults&amp; mouseEvent, FrameView* view)
1668 {
1669     if (view) {
1670         if (auto* scrollbar = view-&gt;scrollbarAtPoint(mouseEvent.event().position()))
1671             return scrollbar;
1672     }
1673     return mouseEvent.scrollbar();
1674 
1675 }
1676 
1677 bool EventHandler::handleMousePressEvent(const PlatformMouseEvent&amp; platformMouseEvent)
1678 {
1679     Ref&lt;Frame&gt; protectedFrame(m_frame);
1680     RefPtr&lt;FrameView&gt; protector(m_frame.view());
1681 
1682     if (InspectorInstrumentation::handleMousePress(m_frame)) {
1683         invalidateClick();
1684         return true;
1685     }
1686 
1687 #if ENABLE(POINTER_LOCK)
1688     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
1689         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(platformMouseEvent, eventNames().mousedownEvent);
1690         return true;
1691     }
1692 #endif
1693 
1694     if (m_frame.page()-&gt;pageOverlayController().handleMouseEvent(platformMouseEvent))
1695         return true;
1696 
1697 #if ENABLE(TOUCH_EVENTS)
1698     bool defaultPrevented = dispatchSyntheticTouchEventIfEnabled(platformMouseEvent);
1699     if (defaultPrevented)
1700         return true;
1701 #endif
1702 
1703     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document());
1704 
1705     // FIXME (bug 68185): this call should be made at another abstraction layer
1706     m_frame.loader().resetMultipleFormSubmissionProtection();
1707 
1708 #if !ENABLE(IOS_TOUCH_EVENTS)
1709     cancelFakeMouseMoveEvent();
1710 #endif
1711     m_mousePressed = true;
1712     m_capturesDragging = true;
1713     setLastKnownMousePosition(platformMouseEvent);
1714     m_mouseDownTimestamp = platformMouseEvent.timestamp();
1715 #if ENABLE(DRAG_SUPPORT)
1716     m_mouseDownMayStartDrag = false;
1717 #endif
1718     m_mouseDownMayStartSelect = false;
1719     m_mouseDownMayStartAutoscroll = false;
1720     if (FrameView* view = m_frame.view())
1721         m_mouseDownPos = view-&gt;windowToContents(platformMouseEvent.position());
1722     else {
1723         invalidateClick();
1724         return false;
1725     }
1726     m_mouseDownWasInSubframe = false;
1727 
1728     HitTestRequest request(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent);
1729     // Save the document point we generate in case the window coordinate is invalidated by what happens
1730     // when we dispatch the event.
1731     LayoutPoint documentPoint = documentPointForWindowPoint(m_frame, platformMouseEvent.position());
1732     MouseEventWithHitTestResults mouseEvent = m_frame.document()-&gt;prepareMouseEvent(request, documentPoint, platformMouseEvent);
1733 
1734     if (!mouseEvent.targetNode()) {
1735         invalidateClick();
1736         return false;
1737     }
1738 
1739     m_mousePressNode = mouseEvent.targetNode();
1740     m_frame.document()-&gt;setFocusNavigationStartingNode(mouseEvent.targetNode());
1741 
1742     Scrollbar* scrollbar = scrollbarForMouseEvent(mouseEvent, m_frame.view());
1743     updateLastScrollbarUnderMouse(scrollbar, SetOrClearLastScrollbar::Set);
1744     bool passedToScrollbar = scrollbar &amp;&amp; passMousePressEventToScrollbar(mouseEvent, scrollbar);
1745 
1746     if (!passedToScrollbar) {
1747         RefPtr&lt;Frame&gt; subframe = subframeForHitTestResult(mouseEvent);
1748         if (subframe &amp;&amp; passMousePressEventToSubframe(mouseEvent, subframe.get())) {
1749             // Start capturing future events for this frame. We only do this if we didn&#39;t clear
1750             // the m_mousePressed flag, which may happen if an AppKit widget entered a modal event loop.
1751             m_capturesDragging = subframe-&gt;eventHandler().capturesDragging();
1752             if (m_mousePressed &amp;&amp; m_capturesDragging) {
1753                 m_capturingMouseEventsElement = subframe-&gt;ownerElement();
1754                 m_eventHandlerWillResetCapturingMouseEventsElement = true;
1755             }
1756             invalidateClick();
1757             return true;
1758         }
1759     }
1760 
1761 #if ENABLE(PAN_SCROLLING)
1762     // We store whether pan scrolling is in progress before calling stopAutoscrollTimer()
1763     // because it will set m_autoscrollType to NoAutoscroll on return.
1764     bool isPanScrollInProgress = m_frame.mainFrame().eventHandler().panScrollInProgress();
1765     stopAutoscrollTimer();
1766     if (isPanScrollInProgress) {
1767         // We invalidate the click when exiting pan scrolling so that we don&#39;t inadvertently navigate
1768         // away from the current page (e.g. the click was on a hyperlink). See &lt;rdar://problem/6095023&gt;.
1769         invalidateClick();
1770         return true;
1771     }
1772 #endif
1773 
1774     m_clickCount = platformMouseEvent.clickCount();
1775     m_clickNode = mouseEvent.targetNode();
1776 
1777     if (!m_clickNode) {
1778         invalidateClick();
1779         return false;
1780     }
1781 
1782     if (FrameView* view = m_frame.view()) {
1783         RenderLayer* layer = m_clickNode-&gt;renderer() ? m_clickNode-&gt;renderer()-&gt;enclosingLayer() : 0;
1784         IntPoint p = view-&gt;windowToContents(platformMouseEvent.position());
1785         if (layer &amp;&amp; layer-&gt;isPointInResizeControl(p)) {
1786             layer-&gt;setInResizeMode(true);
1787             m_resizeLayer = layer;
1788             m_offsetFromResizeCorner = layer-&gt;offsetFromResizeCorner(p);
1789             invalidateClick();
1790             return true;
1791         }
1792     }
1793 
1794     m_frame.selection().setCaretBlinkingSuspended(true);
1795 
1796     bool swallowEvent = !dispatchMouseEvent(eventNames().mousedownEvent, mouseEvent.targetNode(), true, m_clickCount, platformMouseEvent, true);
1797     m_capturesDragging = !swallowEvent || mouseEvent.scrollbar();
1798 
1799     // If the hit testing originally determined the event was in a scrollbar, refetch the MouseEventWithHitTestResults
1800     // in case the scrollbar widget was destroyed when the mouse event was handled.
1801     if (mouseEvent.scrollbar()) {
1802         const bool wasLastScrollBar = mouseEvent.scrollbar() == m_lastScrollbarUnderMouse;
1803         mouseEvent = m_frame.document()-&gt;prepareMouseEvent(HitTestRequest(), documentPoint, platformMouseEvent);
1804         if (wasLastScrollBar &amp;&amp; mouseEvent.scrollbar() != m_lastScrollbarUnderMouse)
1805             m_lastScrollbarUnderMouse = nullptr;
1806     }
1807 
1808     if (!swallowEvent) {
1809         // Refetch the event target node if it currently is the shadow node inside an &lt;input&gt; element.
1810         // If a mouse event handler changes the input element type to one that has a widget associated,
1811         // we&#39;d like to EventHandler::handleMousePressEvent to pass the event to the widget and thus the
1812         // event target node can&#39;t still be the shadow node.
1813         if (is&lt;ShadowRoot&gt;(*mouseEvent.targetNode()) &amp;&amp; is&lt;HTMLInputElement&gt;(*downcast&lt;ShadowRoot&gt;(*mouseEvent.targetNode()).host()))
1814             mouseEvent = m_frame.document()-&gt;prepareMouseEvent(HitTestRequest(), documentPoint, platformMouseEvent);
1815     }
1816 
1817     if (!swallowEvent) {
1818         if (passedToScrollbar)
1819             swallowEvent = true;
1820         else
1821             swallowEvent = handleMousePressEvent(mouseEvent);
1822     }
1823     return swallowEvent;
1824 }
1825 
1826 // This method only exists for platforms that don&#39;t know how to deliver
1827 bool EventHandler::handleMouseDoubleClickEvent(const PlatformMouseEvent&amp; platformMouseEvent)
1828 {
1829     Ref&lt;Frame&gt; protectedFrame(m_frame);
1830     RefPtr&lt;FrameView&gt; protector(m_frame.view());
1831 
1832     m_frame.selection().setCaretBlinkingSuspended(false);
1833 
1834     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document());
1835 
1836 #if ENABLE(POINTER_LOCK)
1837     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
1838         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(platformMouseEvent, eventNames().mouseupEvent);
1839         return true;
1840     }
1841 #endif
1842 
1843     // We get this instead of a second mouse-up
1844     m_mousePressed = false;
1845     setLastKnownMousePosition(platformMouseEvent);
1846 
1847     HitTestRequest request(HitTestRequest::Release | HitTestRequest::DisallowUserAgentShadowContent);
1848     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, platformMouseEvent);
1849     Frame* subframe = subframeForHitTestResult(mouseEvent);
1850     if (m_eventHandlerWillResetCapturingMouseEventsElement)
1851         m_capturingMouseEventsElement = nullptr;
1852     if (subframe &amp;&amp; passMousePressEventToSubframe(mouseEvent, subframe))
1853         return true;
1854 
1855     m_clickCount = platformMouseEvent.clickCount();
1856     bool swallowMouseUpEvent = !dispatchMouseEvent(eventNames().mouseupEvent, mouseEvent.targetNode(), true, m_clickCount, platformMouseEvent, false);
1857 
1858     bool swallowClickEvent = platformMouseEvent.button() != RightButton &amp;&amp; mouseEvent.targetNode() == m_clickNode &amp;&amp; !dispatchMouseEvent(eventNames().clickEvent, mouseEvent.targetNode(), true, m_clickCount, platformMouseEvent, true);
1859 
1860     if (m_lastScrollbarUnderMouse)
1861         swallowMouseUpEvent = m_lastScrollbarUnderMouse-&gt;mouseUp(platformMouseEvent);
1862 
1863     bool swallowMouseReleaseEvent = !swallowMouseUpEvent &amp;&amp; handleMouseReleaseEvent(mouseEvent);
1864 
1865     invalidateClick();
1866 
1867     return swallowMouseUpEvent || swallowClickEvent || swallowMouseReleaseEvent;
1868 }
1869 
1870 static ScrollableArea* enclosingScrollableArea(Node* node)
1871 {
1872     for (auto ancestor = node; ancestor; ancestor = ancestor-&gt;parentOrShadowHostNode()) {
1873         if (is&lt;HTMLIFrameElement&gt;(*ancestor) || is&lt;HTMLHtmlElement&gt;(*ancestor) || is&lt;HTMLDocument&gt;(*ancestor))
1874             return nullptr;
1875 
1876         auto renderer = ancestor-&gt;renderer();
1877         if (!renderer)
1878             continue;
1879 
1880         if (is&lt;RenderListBox&gt;(*renderer))
1881             return downcast&lt;RenderListBox&gt;(renderer);
1882 
1883         return renderer-&gt;enclosingLayer();
1884     }
1885 
1886     return nullptr;
1887 }
1888 
1889 bool EventHandler::mouseMoved(const PlatformMouseEvent&amp; event)
1890 {
1891     Ref&lt;Frame&gt; protectedFrame(m_frame);
1892     RefPtr&lt;FrameView&gt; protector(m_frame.view());
1893     MaximumDurationTracker maxDurationTracker(&amp;m_maxMouseMovedDuration);
1894 
1895     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;pageOverlayController().handleMouseEvent(event))
1896         return true;
1897 
1898     HitTestResult hoveredNode = HitTestResult(LayoutPoint());
1899     bool result = handleMouseMoveEvent(event, &amp;hoveredNode);
1900 
1901     Page* page = m_frame.page();
1902     if (!page)
1903         return result;
1904 
1905     if (auto scrolledArea = enclosingScrollableArea(hoveredNode.innerNode())) {
1906         if (FrameView* frameView = m_frame.view()) {
1907             if (frameView-&gt;containsScrollableArea(scrolledArea))
1908                 scrolledArea-&gt;mouseMovedInContentArea();
1909         }
1910     }
1911 
1912     if (FrameView* frameView = m_frame.view())
1913         frameView-&gt;mouseMovedInContentArea();
1914 
1915     hoveredNode.setToNonUserAgentShadowAncestor();
1916     page-&gt;chrome().mouseDidMoveOverElement(hoveredNode, event.modifierFlags());
1917     page-&gt;chrome().setToolTip(hoveredNode);
1918     return result;
1919 }
1920 
1921 bool EventHandler::passMouseMovedEventToScrollbars(const PlatformMouseEvent&amp; event)
1922 {
1923     HitTestResult hoveredNode;
1924     return handleMouseMoveEvent(event, &amp;hoveredNode, true);
1925 }
1926 
1927 bool EventHandler::handleMouseMoveEvent(const PlatformMouseEvent&amp; platformMouseEvent, HitTestResult* hoveredNode, bool onlyUpdateScrollbars)
1928 {
1929 #if ENABLE(TOUCH_EVENTS)
1930     bool defaultPrevented = dispatchSyntheticTouchEventIfEnabled(platformMouseEvent);
1931     if (defaultPrevented)
1932         return true;
1933 #endif
1934 
1935     Ref&lt;Frame&gt; protectedFrame(m_frame);
1936     RefPtr&lt;FrameView&gt; protector(m_frame.view());
1937 
1938 #if ENABLE(POINTER_LOCK)
1939     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
1940         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(platformMouseEvent, eventNames().mousemoveEvent);
1941         return true;
1942     }
1943 #endif
1944 
1945     setLastKnownMousePosition(platformMouseEvent);
1946 
1947     if (m_hoverTimer.isActive())
1948         m_hoverTimer.stop();
1949 
1950 #if ENABLE(CURSOR_SUPPORT)
1951     m_cursorUpdateTimer.stop();
1952 #endif
1953 
1954 #if !ENABLE(IOS_TOUCH_EVENTS)
1955     cancelFakeMouseMoveEvent();
1956 #endif
1957 
1958     if (m_svgPan) {
1959         downcast&lt;SVGDocument&gt;(*m_frame.document()).updatePan(m_frame.view()-&gt;windowToContents(m_lastKnownMousePosition));
1960         return true;
1961     }
1962 
1963     if (m_frameSetBeingResized)
1964         return !dispatchMouseEvent(eventNames().mousemoveEvent, m_frameSetBeingResized.get(), false, 0, platformMouseEvent, false);
1965 
1966     // On iOS, our scrollbars are managed by UIKit.
1967 #if !PLATFORM(IOS_FAMILY)
1968     // Send events right to a scrollbar if the mouse is pressed.
1969     if (m_lastScrollbarUnderMouse &amp;&amp; m_mousePressed)
1970         return m_lastScrollbarUnderMouse-&gt;mouseMoved(platformMouseEvent);
1971 #endif
1972 
1973     HitTestRequest::HitTestRequestType hitType = HitTestRequest::Move | HitTestRequest::DisallowUserAgentShadowContent | HitTestRequest::AllowFrameScrollbars;
1974     if (m_mousePressed)
1975         hitType |= HitTestRequest::Active;
1976     else if (onlyUpdateScrollbars) {
1977         // Mouse events should be treated as &quot;read-only&quot; if we&#39;re updating only scrollbars. This
1978         // means that :hover and :active freeze in the state they were in, rather than updating
1979         // for nodes the mouse moves while the window is not key (which will be the case if
1980         // onlyUpdateScrollbars is true).
1981         hitType |= HitTestRequest::ReadOnly;
1982     }
1983 
1984 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
1985     // Treat any mouse move events as readonly if the user is currently touching the screen.
1986     if (m_touchPressed)
1987         hitType |= HitTestRequest::Active | HitTestRequest::ReadOnly;
1988 #endif
1989     HitTestRequest request(hitType);
1990     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, platformMouseEvent);
1991     if (hoveredNode)
1992         *hoveredNode = mouseEvent.hitTestResult();
1993 
1994     if (m_resizeLayer &amp;&amp; m_resizeLayer-&gt;inResizeMode())
1995         m_resizeLayer-&gt;resize(platformMouseEvent, m_offsetFromResizeCorner);
1996     else {
1997         Scrollbar* scrollbar = mouseEvent.scrollbar();
1998         updateLastScrollbarUnderMouse(scrollbar, m_mousePressed ? SetOrClearLastScrollbar::Clear : SetOrClearLastScrollbar::Set);
1999 
2000         // On iOS, our scrollbars are managed by UIKit.
2001 #if !PLATFORM(IOS_FAMILY)
2002         if (!m_mousePressed &amp;&amp; scrollbar)
2003             scrollbar-&gt;mouseMoved(platformMouseEvent); // Handle hover effects on platforms that support visual feedback on scrollbar hovering.
2004 #endif
2005         if (onlyUpdateScrollbars) {
2006             if (shouldSendMouseEventsToInactiveWindows())
2007                 updateMouseEventTargetNode(mouseEvent.targetNode(), platformMouseEvent, FireMouseOverOut::Yes);
2008 
2009             return true;
2010         }
2011     }
2012 
2013     bool swallowEvent = false;
2014     RefPtr&lt;Frame&gt; newSubframe = m_capturingMouseEventsElement.get() ? subframeForTargetNode(m_capturingMouseEventsElement.get()) : subframeForHitTestResult(mouseEvent);
2015 
2016     // We want mouseouts to happen first, from the inside out.  First send a move event to the last subframe so that it will fire mouseouts.
2017     if (m_lastMouseMoveEventSubframe &amp;&amp; m_lastMouseMoveEventSubframe-&gt;tree().isDescendantOf(&amp;m_frame) &amp;&amp; m_lastMouseMoveEventSubframe != newSubframe)
2018         passMouseMoveEventToSubframe(mouseEvent, m_lastMouseMoveEventSubframe.get());
2019 
2020     if (newSubframe) {
2021         // Update over/out state before passing the event to the subframe.
2022         updateMouseEventTargetNode(mouseEvent.targetNode(), platformMouseEvent, FireMouseOverOut::Yes);
2023 
2024         // Event dispatch in updateMouseEventTargetNode may have caused the subframe of the target
2025         // node to be detached from its FrameView, in which case the event should not be passed.
2026         if (newSubframe-&gt;view())
2027             swallowEvent |= passMouseMoveEventToSubframe(mouseEvent, newSubframe.get(), hoveredNode);
2028     }
2029 
2030     if (!newSubframe || mouseEvent.scrollbar()) {
2031 #if ENABLE(CURSOR_SUPPORT)
2032         if (auto* view = m_frame.view())
2033             updateCursor(*view, mouseEvent.hitTestResult(), platformMouseEvent.shiftKey());
2034 #endif
2035     }
2036 
2037     m_lastMouseMoveEventSubframe = newSubframe;
2038 
2039     if (swallowEvent)
2040         return true;
2041 
2042     swallowEvent = !dispatchMouseEvent(eventNames().mousemoveEvent, mouseEvent.targetNode(), false, 0, platformMouseEvent, true);
2043 #if ENABLE(DRAG_SUPPORT)
2044     if (!swallowEvent)
2045         swallowEvent = handleMouseDraggedEvent(mouseEvent);
2046 #endif
2047 
2048     return swallowEvent;
2049 }
2050 
2051 bool EventHandler::shouldSendMouseEventsToInactiveWindows() const
2052 {
2053 #if PLATFORM(GTK)
2054     return true;
2055 #endif
2056     return false;
2057 }
2058 
2059 void EventHandler::invalidateClick()
2060 {
2061     m_clickCount = 0;
2062     m_clickNode = nullptr;
2063 }
2064 
2065 static Node* targetNodeForClickEvent(Node* mousePressNode, Node* mouseReleaseNode)
2066 {
2067     if (!mousePressNode || !mouseReleaseNode)
2068         return nullptr;
2069 
2070     if (mousePressNode == mouseReleaseNode)
2071         return mouseReleaseNode;
2072 
2073     // If mousePressNode and mouseReleaseNode differ, we should fire the event at their common ancestor if there is one.
2074     if (&amp;mousePressNode-&gt;document() == &amp;mouseReleaseNode-&gt;document()) {
2075         if (auto* commonAncestor = Range::commonAncestorContainer(mousePressNode, mouseReleaseNode))
2076             return commonAncestor;
2077     }
2078 
2079     Element* mouseReleaseShadowHost = mouseReleaseNode-&gt;shadowHost();
2080     if (mouseReleaseShadowHost &amp;&amp; mouseReleaseShadowHost == mousePressNode-&gt;shadowHost()) {
2081         // We want to dispatch the click to the shadow tree host element to give listeners the illusion that the
2082         // shadom tree is a single element. For example, we want to give the illusion that &lt;input type=&quot;range&quot;&gt;
2083         // is a single element even though it is a composition of multiple shadom tree elements.
2084         return mouseReleaseShadowHost;
2085     }
2086     return nullptr;
2087 }
2088 
2089 bool EventHandler::handleMouseReleaseEvent(const PlatformMouseEvent&amp; platformMouseEvent)
2090 {
2091     Ref&lt;Frame&gt; protectedFrame(m_frame);
2092     RefPtr&lt;FrameView&gt; protector(m_frame.view());
2093 
2094     m_frame.selection().setCaretBlinkingSuspended(false);
2095 
2096 #if ENABLE(POINTER_LOCK)
2097     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
2098         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(platformMouseEvent, eventNames().mouseupEvent);
2099         return true;
2100     }
2101 #endif
2102 
2103     if (m_frame.page()-&gt;pageOverlayController().handleMouseEvent(platformMouseEvent))
2104         return true;
2105 
2106 #if ENABLE(TOUCH_EVENTS)
2107     bool defaultPrevented = dispatchSyntheticTouchEventIfEnabled(platformMouseEvent);
2108     if (defaultPrevented)
2109         return true;
2110 #endif
2111 
2112     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document());
2113 
2114 #if ENABLE(PAN_SCROLLING)
2115     m_autoscrollController-&gt;handleMouseReleaseEvent(platformMouseEvent);
2116 #endif
2117 
2118     m_mousePressed = false;
2119     setLastKnownMousePosition(platformMouseEvent);
2120 
2121     if (m_svgPan) {
2122         m_svgPan = false;
2123         downcast&lt;SVGDocument&gt;(*m_frame.document()).updatePan(m_frame.view()-&gt;windowToContents(m_lastKnownMousePosition));
2124         return true;
2125     }
2126 
2127     if (m_frameSetBeingResized)
2128         return !dispatchMouseEvent(eventNames().mouseupEvent, m_frameSetBeingResized.get(), true, m_clickCount, platformMouseEvent, false);
2129 
2130     // If an immediate action began or was completed using this series of mouse events, then we should send mouseup to
2131     // the DOM and return now so that we don&#39;t perform our own default behaviors.
2132     if (m_immediateActionStage == ImmediateActionStage::ActionCompleted || m_immediateActionStage == ImmediateActionStage::ActionUpdated || m_immediateActionStage == ImmediateActionStage::ActionCancelledAfterUpdate) {
2133         m_immediateActionStage = ImmediateActionStage::None;
2134         return !dispatchMouseEvent(eventNames().mouseupEvent, m_lastElementUnderMouse.get(), true, m_clickCount, platformMouseEvent, false);
2135     }
2136     m_immediateActionStage = ImmediateActionStage::None;
2137 
2138     if (m_lastScrollbarUnderMouse) {
2139         invalidateClick();
2140         m_lastScrollbarUnderMouse-&gt;mouseUp(platformMouseEvent);
2141         bool cancelable = true;
2142         bool setUnder = false;
2143         return !dispatchMouseEvent(eventNames().mouseupEvent, m_lastElementUnderMouse.get(), cancelable, m_clickCount, platformMouseEvent, setUnder);
2144     }
2145 
2146     HitTestRequest request(HitTestRequest::Release | HitTestRequest::DisallowUserAgentShadowContent);
2147     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, platformMouseEvent);
2148     Frame* subframe = m_capturingMouseEventsElement.get() ? subframeForTargetNode(m_capturingMouseEventsElement.get()) : subframeForHitTestResult(mouseEvent);
2149     if (m_eventHandlerWillResetCapturingMouseEventsElement)
2150         m_capturingMouseEventsElement = nullptr;
2151     if (subframe &amp;&amp; passMouseReleaseEventToSubframe(mouseEvent, subframe))
2152         return true;
2153 
2154     bool swallowMouseUpEvent = !dispatchMouseEvent(eventNames().mouseupEvent, mouseEvent.targetNode(), true, m_clickCount, platformMouseEvent, false);
2155 
2156     bool contextMenuEvent = platformMouseEvent.button() == RightButton;
2157 
2158     Node* nodeToClick = targetNodeForClickEvent(m_clickNode.get(), mouseEvent.targetNode());
2159     bool swallowClickEvent = m_clickCount &gt; 0 &amp;&amp; !contextMenuEvent &amp;&amp; nodeToClick &amp;&amp; !dispatchMouseEvent(eventNames().clickEvent, nodeToClick, true, m_clickCount, platformMouseEvent, true);
2160 
2161     if (m_resizeLayer) {
2162         m_resizeLayer-&gt;setInResizeMode(false);
2163         m_resizeLayer = nullptr;
2164     }
2165 
2166     bool swallowMouseReleaseEvent = false;
2167     if (!swallowMouseUpEvent)
2168         swallowMouseReleaseEvent = handleMouseReleaseEvent(mouseEvent);
2169 
2170     invalidateClick();
2171 
2172     return swallowMouseUpEvent || swallowClickEvent || swallowMouseReleaseEvent;
2173 }
2174 
2175 #if ENABLE(MOUSE_FORCE_EVENTS)
2176 bool EventHandler::handleMouseForceEvent(const PlatformMouseEvent&amp; event)
2177 {
2178     Ref&lt;Frame&gt; protectedFrame(m_frame);
2179     RefPtr&lt;FrameView&gt; protector(m_frame.view());
2180 
2181 #if ENABLE(POINTER_LOCK)
2182     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
2183         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(event, eventNames().webkitmouseforcechangedEvent);
2184         if (event.type() == PlatformEvent::MouseForceDown)
2185             m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(event, eventNames().webkitmouseforcedownEvent);
2186         if (event.type() == PlatformEvent::MouseForceUp)
2187             m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(event, eventNames().webkitmouseforceupEvent);
2188         return true;
2189     }
2190 #endif
2191 
2192     setLastKnownMousePosition(event);
2193 
2194     HitTestRequest::HitTestRequestType hitType = HitTestRequest::DisallowUserAgentShadowContent;
2195 
2196     if (event.force())
2197         hitType |= HitTestRequest::Active;
2198 
2199     HitTestRequest request(hitType);
2200     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, event);
2201 
2202     bool swallowedEvent = !dispatchMouseEvent(eventNames().webkitmouseforcechangedEvent, mouseEvent.targetNode(), false, 0, event, false);
2203     if (event.type() == PlatformEvent::MouseForceDown)
2204         swallowedEvent |= !dispatchMouseEvent(eventNames().webkitmouseforcedownEvent, mouseEvent.targetNode(), false, 0, event, false);
2205     if (event.type() == PlatformEvent::MouseForceUp)
2206         swallowedEvent |= !dispatchMouseEvent(eventNames().webkitmouseforceupEvent, mouseEvent.targetNode(), false, 0, event, false);
2207 
2208     return swallowedEvent;
2209 }
2210 #else
2211 bool EventHandler::handleMouseForceEvent(const PlatformMouseEvent&amp; )
2212 {
2213     return false;
2214 }
2215 #endif // #if ENABLE(MOUSE_FORCE_EVENTS)
2216 
2217 bool EventHandler::handlePasteGlobalSelection(const PlatformMouseEvent&amp; platformMouseEvent)
2218 {
2219     // If the event was a middle click, attempt to copy global selection in after
2220     // the newly set caret position.
2221     //
2222     // This code is called from either the mouse up or mouse down handling. There
2223     // is some debate about when the global selection is pasted:
2224     //   xterm: pastes on up.
2225     //   GTK: pastes on down.
2226     //   Qt: pastes on up.
2227     //   Firefox: pastes on up.
2228     //   Chromium: pastes on up.
2229     //
2230     // There is something of a webcompat angle to this well, as highlighted by
2231     // crbug.com/14608. Pages can clear text boxes &#39;onclick&#39; and, if we paste on
2232     // down then the text is pasted just before the onclick handler runs and
2233     // clears the text box. So it&#39;s important this happens after the event
2234     // handlers have been fired.
2235 #if PLATFORM(GTK)
2236     if (platformMouseEvent.type() != PlatformEvent::MousePressed)
2237         return false;
2238 #else
2239     if (platformMouseEvent.type() != PlatformEvent::MouseReleased)
2240         return false;
2241 #endif
2242 
2243     if (!m_frame.page())
2244         return false;
2245     Frame&amp; focusFrame = m_frame.page()-&gt;focusController().focusedOrMainFrame();
2246     // Do not paste here if the focus was moved somewhere else.
2247     if (&amp;m_frame == &amp;focusFrame &amp;&amp; m_frame.editor().client()-&gt;supportsGlobalSelection())
2248         return m_frame.editor().command(&quot;PasteGlobalSelection&quot;_s).execute();
2249 
2250     return false;
2251 }
2252 
2253 #if ENABLE(DRAG_SUPPORT)
2254 
2255 bool EventHandler::dispatchDragEvent(const AtomString&amp; eventType, Element&amp; dragTarget, const PlatformMouseEvent&amp; event, DataTransfer&amp; dataTransfer)
2256 {
2257     Ref&lt;Frame&gt; protectedFrame(m_frame);
2258     FrameView* view = m_frame.view();
2259 
2260     // FIXME: We might want to dispatch a dragleave even if the view is gone.
2261     if (!view)
2262         return false;
2263 
2264     view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
2265     // FIXME: Use MouseEvent::create which takes PlatformMouseEvent.
2266     Ref&lt;MouseEvent&gt; me = MouseEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::Yes, Event::IsComposed::Yes,
2267         event.timestamp().approximateMonotonicTime(), &amp;m_frame.windowProxy(), 0,
2268         event.globalPosition(), event.position(),
2269 #if ENABLE(POINTER_LOCK)
2270         event.movementDelta(),
2271 #else
2272         { },
2273 #endif
2274         event.modifiers(), 0, 0, nullptr, event.force(), NoTap, &amp;dataTransfer);
2275 
2276     dragTarget.dispatchEvent(me);
2277     return me-&gt;defaultPrevented();
2278 }
2279 
2280 static bool targetIsFrame(Node* target, Frame*&amp; frame)
2281 {
2282     if (!is&lt;HTMLFrameElementBase&gt;(target))
2283         return false;
2284 
2285     frame = downcast&lt;HTMLFrameElementBase&gt;(*target).contentFrame();
2286     return true;
2287 }
2288 
2289 static DragOperation convertDropZoneOperationToDragOperation(const String&amp; dragOperation)
2290 {
2291     if (dragOperation == &quot;copy&quot;)
2292         return DragOperationCopy;
2293     if (dragOperation == &quot;move&quot;)
2294         return DragOperationMove;
2295     if (dragOperation == &quot;link&quot;)
2296         return DragOperationLink;
2297     return DragOperationNone;
2298 }
2299 
2300 static String convertDragOperationToDropZoneOperation(DragOperation operation)
2301 {
2302     switch (operation) {
2303     case DragOperationCopy:
2304         return &quot;copy&quot;_s;
2305     case DragOperationMove:
2306         return &quot;move&quot;_s;
2307     case DragOperationLink:
2308         return &quot;link&quot;_s;
2309     default:
2310         return &quot;copy&quot;_s;
2311     }
2312 }
2313 
2314 static bool hasDropZoneType(DataTransfer&amp; dataTransfer, const String&amp; keyword)
2315 {
2316     if (keyword.startsWith(&quot;file:&quot;))
2317         return dataTransfer.hasFileOfType(keyword.substring(5));
2318 
2319     if (keyword.startsWith(&quot;string:&quot;))
2320         return dataTransfer.hasStringOfType(keyword.substring(7));
2321 
2322     return false;
2323 }
2324 
2325 static bool findDropZone(Node&amp; target, DataTransfer&amp; dataTransfer)
2326 {
2327     RefPtr&lt;Element&gt; element = is&lt;Element&gt;(target) ? &amp;downcast&lt;Element&gt;(target) : target.parentElement();
2328     for (; element; element = element-&gt;parentElement()) {
2329         SpaceSplitString keywords(element-&gt;attributeWithoutSynchronization(webkitdropzoneAttr), true);
2330         bool matched = false;
2331         DragOperation dragOperation = DragOperationNone;
2332         for (unsigned i = 0, size = keywords.size(); i &lt; size; ++i) {
2333             DragOperation op = convertDropZoneOperationToDragOperation(keywords[i]);
2334             if (op != DragOperationNone) {
2335                 if (dragOperation == DragOperationNone)
2336                     dragOperation = op;
2337             } else
2338                 matched = matched || hasDropZoneType(dataTransfer, keywords[i].string());
2339             if (matched &amp;&amp; dragOperation != DragOperationNone)
2340                 break;
2341         }
2342         if (matched) {
2343             dataTransfer.setDropEffect(convertDragOperationToDropZoneOperation(dragOperation));
2344             return true;
2345         }
2346     }
2347     return false;
2348 }
2349 
2350 EventHandler::DragTargetResponse EventHandler::dispatchDragEnterOrDragOverEvent(const AtomString&amp; eventType, Element&amp; target, const PlatformMouseEvent&amp; event,
2351     std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2352 {
2353     auto dataTransfer = DataTransfer::createForUpdatingDropTarget(target.document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2354     bool accept = dispatchDragEvent(eventType, target, event, dataTransfer.get());
2355     if (!accept)
2356         accept = findDropZone(target, dataTransfer);
2357     dataTransfer-&gt;makeInvalidForSecurity();
2358     if (accept &amp;&amp; !dataTransfer-&gt;dropEffectIsUninitialized())
2359         return { true, dataTransfer-&gt;destinationOperation() };
2360     return { accept, WTF::nullopt };
2361 }
2362 
2363 EventHandler::DragTargetResponse EventHandler::updateDragAndDrop(const PlatformMouseEvent&amp; event, const std::function&lt;std::unique_ptr&lt;Pasteboard&gt;()&gt;&amp; makePasteboard, DragOperation sourceOperation, bool draggingFiles)
2364 {
2365     Ref&lt;Frame&gt; protectedFrame(m_frame);
2366     if (!m_frame.view())
2367         return { };
2368 
2369     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
2370     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, event);
2371 
2372     RefPtr&lt;Element&gt; newTarget;
2373     if (Node* targetNode = mouseEvent.targetNode()) {
2374         // Drag events should never go to non-element nodes (following IE, and proper mouseover/out dispatch)
2375         if (!is&lt;Element&gt;(*targetNode))
2376             newTarget = targetNode-&gt;parentOrShadowHostElement();
2377         else
2378             newTarget = downcast&lt;Element&gt;(targetNode);
2379     }
2380 
2381     m_autoscrollController-&gt;updateDragAndDrop(newTarget.get(), event.position(), event.timestamp());
2382 
2383     DragTargetResponse response;
2384     if (m_dragTarget != newTarget) {
2385         // FIXME: this ordering was explicitly chosen to match WinIE. However,
2386         // it is sometimes incorrect when dragging within subframes, as seen with
2387         // LayoutTests/fast/events/drag-in-frames.html.
2388         //
2389         // Moreover, this ordering conforms to section 7.9.4 of the HTML 5 spec. &lt;http://dev.w3.org/html5/spec/Overview.html#drag-and-drop-processing-model&gt;.
2390         Frame* targetFrame;
2391         if (targetIsFrame(newTarget.get(), targetFrame)) {
2392             if (targetFrame)
2393                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2394         } else if (newTarget) {
2395             // As per section 7.9.4 of the HTML 5 spec., we must always fire a drag event before firing a dragenter, dragleave, or dragover event.
2396             if (dragState().source &amp;&amp; dragState().shouldDispatchEvents)
2397                 dispatchDragSrcEvent(eventNames().dragEvent, event);
2398             response = dispatchDragEnterOrDragOverEvent(eventNames().dragenterEvent, *newTarget, event, makePasteboard(), sourceOperation, draggingFiles);
2399         }
2400 
2401         if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2402             // FIXME: Recursing again here doesn&#39;t make sense if the newTarget and m_dragTarget were in the same frame.
2403             if (targetFrame)
2404                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2405         } else if (m_dragTarget) {
2406             auto dataTransfer = DataTransfer::createForUpdatingDropTarget(m_dragTarget-&gt;document(), makePasteboard(), sourceOperation, draggingFiles);
2407             dispatchDragEvent(eventNames().dragleaveEvent, *m_dragTarget, event, dataTransfer.get());
2408             dataTransfer-&gt;makeInvalidForSecurity();
2409         }
2410 
2411         if (newTarget) {
2412             // We do not explicitly call dispatchDragEvent here because it could ultimately result in the appearance that
2413             // two dragover events fired. So, we mark that we should only fire a dragover event on the next call to this function.
2414             m_shouldOnlyFireDragOverEvent = true;
2415         }
2416     } else {
2417         Frame* targetFrame;
2418         if (targetIsFrame(newTarget.get(), targetFrame)) {
2419             if (targetFrame)
2420                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2421         } else if (newTarget) {
2422             // Note, when dealing with sub-frames, we may need to fire only a dragover event as a drag event may have been fired earlier.
2423             if (!m_shouldOnlyFireDragOverEvent &amp;&amp; dragState().source &amp;&amp; dragState().shouldDispatchEvents)
2424                 dispatchDragSrcEvent(eventNames().dragEvent, event);
2425             response = dispatchDragEnterOrDragOverEvent(eventNames().dragoverEvent, *newTarget, event, makePasteboard(), sourceOperation, draggingFiles);
2426             m_shouldOnlyFireDragOverEvent = false;
2427         }
2428     }
2429     m_dragTarget = WTFMove(newTarget);
2430     return response;
2431 }
2432 
2433 void EventHandler::cancelDragAndDrop(const PlatformMouseEvent&amp; event, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2434 {
2435     Ref&lt;Frame&gt; protectedFrame(m_frame);
2436 
2437     Frame* targetFrame;
2438     if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2439         if (targetFrame)
2440             targetFrame-&gt;eventHandler().cancelDragAndDrop(event, WTFMove(pasteboard), sourceOperation, draggingFiles);
2441     } else if (m_dragTarget) {
2442         if (dragState().source &amp;&amp; dragState().shouldDispatchEvents)
2443             dispatchDragSrcEvent(eventNames().dragEvent, event);
2444 
2445         auto dataTransfer = DataTransfer::createForUpdatingDropTarget(m_dragTarget-&gt;document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2446         dispatchDragEvent(eventNames().dragleaveEvent, *m_dragTarget, event, dataTransfer.get());
2447         dataTransfer-&gt;makeInvalidForSecurity();
2448     }
2449     clearDragState();
2450 }
2451 
2452 bool EventHandler::performDragAndDrop(const PlatformMouseEvent&amp; event, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2453 {
2454     Ref&lt;Frame&gt; protectedFrame(m_frame);
2455 
2456     Frame* targetFrame;
2457     bool preventedDefault = false;
2458     if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2459         if (targetFrame)
2460             preventedDefault = targetFrame-&gt;eventHandler().performDragAndDrop(event, WTFMove(pasteboard), sourceOperation, draggingFiles);
2461     } else if (m_dragTarget) {
2462         auto dataTransfer = DataTransfer::createForDrop(m_dragTarget-&gt;document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2463         preventedDefault = dispatchDragEvent(eventNames().dropEvent, *m_dragTarget, event, dataTransfer);
2464         dataTransfer-&gt;makeInvalidForSecurity();
2465     }
2466     clearDragState();
2467     return preventedDefault;
2468 }
2469 
2470 void EventHandler::clearDragState()
2471 {
2472     stopAutoscrollTimer();
2473     m_dragTarget = nullptr;
2474     m_capturingMouseEventsElement = nullptr;
2475     m_shouldOnlyFireDragOverEvent = false;
2476 #if PLATFORM(COCOA)
2477     m_sendingEventToSubview = false;
2478 #endif
2479 }
2480 
2481 #endif // ENABLE(DRAG_SUPPORT)
2482 
2483 void EventHandler::setCapturingMouseEventsElement(Element* element)
2484 {
2485     m_capturingMouseEventsElement = element;
2486     m_eventHandlerWillResetCapturingMouseEventsElement = false;
2487 }
2488 
2489 #if ENABLE(POINTER_EVENTS)
2490 void EventHandler::pointerCaptureElementDidChange(Element* element)
2491 {
2492     if (m_capturingMouseEventsElement == element)
2493         return;
2494 
2495     setCapturingMouseEventsElement(element);
2496 
2497     // Now that we have a new capture element, we need to dispatch boundary mouse events.
2498     updateMouseEventTargetNode(element, m_lastPlatformMouseEvent, FireMouseOverOut::Yes);
2499 }
2500 #endif
2501 
2502 MouseEventWithHitTestResults EventHandler::prepareMouseEvent(const HitTestRequest&amp; request, const PlatformMouseEvent&amp; mouseEvent)
2503 {
2504 #if ENABLE(POINTER_EVENTS)
2505     m_lastPlatformMouseEvent = mouseEvent;
2506 #endif
2507     Ref&lt;Frame&gt; protectedFrame(m_frame);
2508     ASSERT(m_frame.document());
2509     return m_frame.document()-&gt;prepareMouseEvent(request, documentPointForWindowPoint(m_frame, mouseEvent.position()), mouseEvent);
2510 }
2511 
2512 static bool hierarchyHasCapturingEventListeners(Element* element, const AtomString&amp; pointerEventName, const AtomString&amp; compatibilityMouseEventName)
2513 {
2514     for (ContainerNode* curr = element; curr; curr = curr-&gt;parentInComposedTree()) {
2515         if (curr-&gt;hasCapturingEventListeners(pointerEventName) || curr-&gt;hasCapturingEventListeners(compatibilityMouseEventName))
2516             return true;
2517     }
2518     return false;
2519 }
2520 
2521 void EventHandler::updateMouseEventTargetNode(Node* targetNode, const PlatformMouseEvent&amp; platformMouseEvent, FireMouseOverOut fireMouseOverOut)
2522 {
2523     Ref&lt;Frame&gt; protectedFrame(m_frame);
2524     Element* targetElement = nullptr;
2525 
2526     // If we&#39;re capturing, we always go right to that element.
2527     if (m_capturingMouseEventsElement)
2528         targetElement = m_capturingMouseEventsElement.get();
2529     else if (targetNode) {
2530         // If the target node is a non-element, dispatch on the parent. &lt;rdar://problem/4196646&gt;
2531         while (targetNode &amp;&amp; !is&lt;Element&gt;(*targetNode))
2532             targetNode = targetNode-&gt;parentInComposedTree();
2533         targetElement = downcast&lt;Element&gt;(targetNode);
2534     }
2535 
2536     m_elementUnderMouse = targetElement;
2537 
2538     // Fire mouseout/mouseover if the mouse has shifted to a different node.
2539     if (fireMouseOverOut == FireMouseOverOut::Yes) {
2540         auto scrollableAreaForLastNode = enclosingScrollableArea(m_lastElementUnderMouse.get());
2541         auto scrollableAreaForNodeUnderMouse = enclosingScrollableArea(m_elementUnderMouse.get());
2542         Page* page = m_frame.page();
2543 
2544         if (m_lastElementUnderMouse &amp;&amp; (!m_elementUnderMouse || &amp;m_elementUnderMouse-&gt;document() != m_frame.document())) {
2545             // The mouse has moved between frames.
2546             if (Frame* frame = m_lastElementUnderMouse-&gt;document().frame()) {
2547                 if (FrameView* frameView = frame-&gt;view())
2548                     frameView-&gt;mouseExitedContentArea();
2549             }
2550         } else if (page &amp;&amp; (scrollableAreaForLastNode &amp;&amp; (!scrollableAreaForNodeUnderMouse || scrollableAreaForNodeUnderMouse != scrollableAreaForLastNode))) {
2551             // The mouse has moved between layers.
2552             if (Frame* frame = m_lastElementUnderMouse-&gt;document().frame()) {
2553                 if (FrameView* frameView = frame-&gt;view()) {
2554                     if (frameView-&gt;containsScrollableArea(scrollableAreaForLastNode))
2555                         scrollableAreaForLastNode-&gt;mouseExitedContentArea();
2556                 }
2557             }
2558         }
2559 
2560         if (m_elementUnderMouse &amp;&amp; (!m_lastElementUnderMouse || &amp;m_lastElementUnderMouse-&gt;document() != m_frame.document())) {
2561             // The mouse has moved between frames.
2562             if (Frame* frame = m_elementUnderMouse-&gt;document().frame()) {
2563                 if (FrameView* frameView = frame-&gt;view())
2564                     frameView-&gt;mouseEnteredContentArea();
2565             }
2566         } else if (page &amp;&amp; (scrollableAreaForNodeUnderMouse &amp;&amp; (!scrollableAreaForLastNode || scrollableAreaForNodeUnderMouse != scrollableAreaForLastNode))) {
2567             // The mouse has moved between layers.
2568             if (Frame* frame = m_elementUnderMouse-&gt;document().frame()) {
2569                 if (FrameView* frameView = frame-&gt;view()) {
2570                     if (frameView-&gt;containsScrollableArea(scrollableAreaForNodeUnderMouse))
2571                         scrollableAreaForNodeUnderMouse-&gt;mouseEnteredContentArea();
2572                 }
2573             }
2574         }
2575 
2576         if (m_lastElementUnderMouse &amp;&amp; &amp;m_lastElementUnderMouse-&gt;document() != m_frame.document()) {
2577             m_lastElementUnderMouse = nullptr;
2578             m_lastScrollbarUnderMouse = nullptr;
2579         }
2580 
2581         if (m_lastElementUnderMouse != m_elementUnderMouse) {
2582             // mouseenter and mouseleave events are only dispatched if there is a capturing eventhandler on an ancestor
2583             // or a normal eventhandler on the element itself (they don&#39;t bubble).
2584             // This optimization is necessary since these events can cause O(n^2) capturing event-handler checks.
2585             bool hasCapturingMouseEnterListener = hierarchyHasCapturingEventListeners(m_elementUnderMouse.get(), eventNames().pointerenterEvent, eventNames().mouseenterEvent);
2586             bool hasCapturingMouseLeaveListener = hierarchyHasCapturingEventListeners(m_lastElementUnderMouse.get(), eventNames().pointerleaveEvent, eventNames().mouseleaveEvent);
2587 
2588             Vector&lt;Ref&lt;Element&gt;, 32&gt; leftElementsChain;
2589             for (Element* element = m_lastElementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree())
2590                 leftElementsChain.append(*element);
2591             Vector&lt;Ref&lt;Element&gt;, 32&gt; enteredElementsChain;
2592             for (Element* element = m_elementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree())
2593                 enteredElementsChain.append(*element);
2594 
2595             if (!leftElementsChain.isEmpty() &amp;&amp; !enteredElementsChain.isEmpty() &amp;&amp; leftElementsChain.last().ptr() == enteredElementsChain.last().ptr()) {
2596                 size_t minHeight = std::min(leftElementsChain.size(), enteredElementsChain.size());
2597                 size_t i;
2598                 for (i = 0; i &lt; minHeight; ++i) {
2599                     if (leftElementsChain[leftElementsChain.size() - i - 1].ptr() != enteredElementsChain[enteredElementsChain.size() - i - 1].ptr())
2600                         break;
2601                 }
2602                 leftElementsChain.shrink(leftElementsChain.size() - i);
2603                 enteredElementsChain.shrink(enteredElementsChain.size() - i);
2604             }
2605 
2606             if (m_lastElementUnderMouse)
2607                 m_lastElementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseoutEvent, 0, m_elementUnderMouse.get());
2608 
2609             for (auto&amp; chain : leftElementsChain) {
2610                 if (hasCapturingMouseLeaveListener || chain-&gt;hasEventListeners(eventNames().pointerleaveEvent) || chain-&gt;hasEventListeners(eventNames().mouseleaveEvent))
2611                     chain-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseleaveEvent, 0, m_elementUnderMouse.get());
2612             }
2613 
2614             if (m_elementUnderMouse)
2615                 m_elementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseoverEvent, 0, m_lastElementUnderMouse.get());
2616 
2617             for (auto&amp; chain : WTF::makeReversedRange(enteredElementsChain)) {
2618                 if (hasCapturingMouseEnterListener || chain-&gt;hasEventListeners(eventNames().pointerenterEvent) || chain-&gt;hasEventListeners(eventNames().mouseenterEvent))
2619                     chain-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseenterEvent, 0, m_lastElementUnderMouse.get());
2620             }
2621         }
2622         m_lastElementUnderMouse = m_elementUnderMouse;
2623     }
2624 }
2625 
2626 bool EventHandler::dispatchMouseEvent(const AtomString&amp; eventType, Node* targetNode, bool /*cancelable*/, int clickCount, const PlatformMouseEvent&amp; platformMouseEvent, bool setUnder)
2627 {
2628     Ref&lt;Frame&gt; protectedFrame(m_frame);
2629 
2630     if (auto* view = m_frame.view())
2631         view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
2632 
2633     updateMouseEventTargetNode(targetNode, platformMouseEvent, setUnder ? FireMouseOverOut::Yes : FireMouseOverOut::No);
2634 
2635     if (m_elementUnderMouse &amp;&amp; !m_elementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventType, clickCount))
2636         return false;
2637 
2638     if (eventType != eventNames().mousedownEvent)
2639         return true;
2640 
2641     // If clicking on a frame scrollbar, do not make any change to which element is focused.
2642     auto* view = m_frame.view();
2643     if (view &amp;&amp; view-&gt;scrollbarAtPoint(platformMouseEvent.position()))
2644         return true;
2645 
2646     // The layout needs to be up to date to determine if an element is focusable.
2647     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
2648 
2649     // Remove focus from the currently focused element when a link or button is clicked.
2650     // This is expected by some sites that rely on change event handlers running
2651     // from form fields before the button click is processed, behavior that was inherited
2652     // from the user interface of Windows, where pushing a button moves focus to the button.
2653 
2654     // Walk up the DOM tree to search for an element to focus.
2655     RefPtr&lt;Element&gt; element;
2656     for (element = m_elementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree()) {
2657         if (element-&gt;isMouseFocusable())
2658             break;
2659     }
2660 
2661     // To fix &lt;rdar://problem/4895428&gt; Can&#39;t drag selected ToDo, we don&#39;t focus an
2662     // element on mouse down if it&#39;s selected and inside a focused element. It will be
2663     // focused if the user does a mouseup over it, however, because the mouseup
2664     // will set a selection inside it, which will also set the focused element.
2665     if (element &amp;&amp; m_frame.selection().isRange()) {
2666         if (auto range = m_frame.selection().toNormalizedRange()) {
2667             auto result = range-&gt;compareNode(*element);
2668             if (!result.hasException() &amp;&amp; result.releaseReturnValue() == Range::NODE_INSIDE &amp;&amp; element-&gt;isDescendantOf(m_frame.document()-&gt;focusedElement()))
2669                 return true;
2670         }
2671     }
2672 
2673     // Only change the focus when clicking scrollbars if it can be transferred to a mouse focusable node.
2674     if (!element &amp;&amp; isInsideScrollbar(platformMouseEvent.position()))
2675         return false;
2676 
2677     // If focus shift is blocked, we eat the event.
2678     auto* page = m_frame.page();
2679     if (page &amp;&amp; !page-&gt;focusController().setFocusedElement(element.get(), m_frame))
2680         return false;
2681 
2682     return true;
2683 }
2684 
2685 bool EventHandler::isInsideScrollbar(const IntPoint&amp; windowPoint) const
2686 {
2687     if (auto* document = m_frame.document()) {
2688         HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
2689         HitTestResult result(windowPoint);
2690         document-&gt;hitTest(request, result);
2691         return result.scrollbar();
2692     }
2693 
2694     return false;
2695 }
2696 
2697 #if !USE(GLIB)
2698 
2699 bool EventHandler::shouldSwapScrollDirection(const HitTestResult&amp;, const PlatformWheelEvent&amp;) const
2700 {
2701     return false;
2702 }
2703 
2704 #endif
2705 
2706 #if !PLATFORM(MAC)
2707 
2708 void EventHandler::platformPrepareForWheelEvents(const PlatformWheelEvent&amp;, const HitTestResult&amp;, RefPtr&lt;Element&gt;&amp;, RefPtr&lt;ContainerNode&gt;&amp;, WeakPtr&lt;ScrollableArea&gt;&amp;, bool&amp;)
2709 {
2710 }
2711 
2712 void EventHandler::platformRecordWheelEvent(const PlatformWheelEvent&amp; event)
2713 {
2714     if (auto* page = m_frame.page())
2715         page-&gt;wheelEventDeltaFilter()-&gt;updateFromDelta(FloatSize(event.deltaX(), event.deltaY()));
2716 }
2717 
2718 bool EventHandler::platformCompleteWheelEvent(const PlatformWheelEvent&amp; event, ContainerNode*, const WeakPtr&lt;ScrollableArea&gt;&amp;)
2719 {
2720     Ref&lt;Frame&gt; protectedFrame(m_frame);
2721 
2722     // We do another check on the frame view because the event handler can run JS which results in the frame getting destroyed.
2723     FrameView* view = m_frame.view();
2724 
2725     bool didHandleEvent = view ? view-&gt;wheelEvent(event) : false;
2726     m_isHandlingWheelEvent = false;
2727     return didHandleEvent;
2728 }
2729 
2730 bool EventHandler::platformCompletePlatformWidgetWheelEvent(const PlatformWheelEvent&amp;, const Widget&amp;, ContainerNode*)
2731 {
2732     return true;
2733 }
2734 
2735 void EventHandler::platformNotifyIfEndGesture(const PlatformWheelEvent&amp;, const WeakPtr&lt;ScrollableArea&gt;&amp;)
2736 {
2737 }
2738 
2739 void EventHandler::clearOrScheduleClearingLatchedStateIfNeeded(const PlatformWheelEvent&amp;)
2740 {
2741     clearLatchedState();
2742 }
2743 
2744 #if !PLATFORM(IOS_FAMILY)
2745 
2746 IntPoint EventHandler::targetPositionInWindowForSelectionAutoscroll() const
2747 {
2748     return m_lastKnownMousePosition;
2749 }
2750 
2751 #endif // !PLATFORM(IOS_FAMILY)
2752 
2753 #endif // !PLATFORM(MAC)
2754 
2755 #if !PLATFORM(IOS_FAMILY)
2756 
2757 bool EventHandler::shouldUpdateAutoscroll()
2758 {
2759     return mousePressed();
2760 }
2761 
2762 #endif // !PLATFORM(IOS_FAMILY)
2763 
2764 Widget* EventHandler::widgetForEventTarget(Element* eventTarget)
2765 {
2766     if (!eventTarget)
2767         return nullptr;
2768 
2769     auto* target = eventTarget-&gt;renderer();
2770     if (!is&lt;RenderWidget&gt;(target))
2771         return nullptr;
2772 
2773     return downcast&lt;RenderWidget&gt;(*target).widget();
2774 }
2775 
2776 static WeakPtr&lt;Widget&gt; widgetForElement(const Element&amp; element)
2777 {
2778     auto target = element.renderer();
2779     if (!is&lt;RenderWidget&gt;(target) || !downcast&lt;RenderWidget&gt;(*target).widget())
2780         return { };
2781 
2782     return makeWeakPtr(*downcast&lt;RenderWidget&gt;(*target).widget());
2783 }
2784 
2785 bool EventHandler::completeWidgetWheelEvent(const PlatformWheelEvent&amp; event, const WeakPtr&lt;Widget&gt;&amp; widget, const WeakPtr&lt;ScrollableArea&gt;&amp; scrollableArea, ContainerNode* scrollableContainer)
2786 {
2787     m_isHandlingWheelEvent = false;
2788 
2789     // We do another check on the widget because the event handler can run JS which results in the frame getting destroyed.
2790     if (!widget)
2791         return false;
2792 
2793     if (scrollableArea)
2794         scrollableArea-&gt;setScrollShouldClearLatchedState(false);
2795 
2796     platformNotifyIfEndGesture(event, scrollableArea);
2797 
2798     if (!widget-&gt;platformWidget())
2799         return true;
2800 
2801     return platformCompletePlatformWidgetWheelEvent(event, *widget.get(), scrollableContainer);
2802 }
2803 
2804 bool EventHandler::handleWheelEvent(const PlatformWheelEvent&amp; event)
2805 {
2806     auto* document = m_frame.document();
2807     if (!document)
2808         return false;
2809 
2810     Ref&lt;Frame&gt; protectedFrame(m_frame);
2811     RefPtr&lt;FrameView&gt; protector(m_frame.view());
2812 
2813     FrameView* view = m_frame.view();
2814     if (!view)
2815         return false;
2816 
2817 #if ENABLE(POINTER_LOCK)
2818     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
2819         m_frame.page()-&gt;pointerLockController().dispatchLockedWheelEvent(event);
2820         return true;
2821     }
2822 #endif
2823 
2824     m_isHandlingWheelEvent = true;
2825     setFrameWasScrolledByUser();
2826 
2827     HitTestRequest request;
2828     HitTestResult result(view-&gt;windowToContents(event.position()));
2829     document-&gt;hitTest(request, result);
2830 
2831     RefPtr&lt;Element&gt; element = result.targetElement();
2832     RefPtr&lt;ContainerNode&gt; scrollableContainer;
2833     WeakPtr&lt;ScrollableArea&gt; scrollableArea;
2834     bool isOverWidget = result.isOverWidget();
2835     platformPrepareForWheelEvents(event, result, element, scrollableContainer, scrollableArea, isOverWidget);
2836 
2837 #if PLATFORM(MAC)
2838     if (event.phase() == PlatformWheelEventPhaseNone &amp;&amp; event.momentumPhase() == PlatformWheelEventPhaseNone &amp;&amp; m_frame.page())
2839         m_frame.page()-&gt;resetLatchingState();
2840 #endif
2841 
2842     // FIXME: It should not be necessary to do this mutation here.
2843     // Instead, the handlers should know convert vertical scrolls appropriately.
2844     PlatformWheelEvent adjustedEvent = shouldSwapScrollDirection(result, event) ? event.copySwappingDirection() : event;
2845     platformRecordWheelEvent(adjustedEvent);
2846 
2847     if (element) {
2848         if (isOverWidget) {
2849             if (WeakPtr&lt;Widget&gt; widget = widgetForElement(*element)) {
2850                 if (widgetDidHandleWheelEvent(event, *widget.get()))
2851                     return completeWidgetWheelEvent(adjustedEvent, widget, scrollableArea, scrollableContainer.get());
2852             }
2853         }
2854 
2855         if (!element-&gt;dispatchWheelEvent(adjustedEvent)) {
2856             m_isHandlingWheelEvent = false;
2857             if (scrollableArea &amp;&amp; scrollableArea-&gt;scrollShouldClearLatchedState()) {
2858                 // Web developer is controlling scrolling, so don&#39;t attempt to latch.
2859                 clearLatchedState();
2860                 scrollableArea-&gt;setScrollShouldClearLatchedState(false);
2861             }
2862 
2863             platformNotifyIfEndGesture(adjustedEvent, scrollableArea);
2864             return true;
2865         }
2866     }
2867 
2868     if (scrollableArea)
2869         scrollableArea-&gt;setScrollShouldClearLatchedState(false);
2870 
2871     bool handledEvent = platformCompleteWheelEvent(adjustedEvent, scrollableContainer.get(), scrollableArea);
2872     platformNotifyIfEndGesture(adjustedEvent, scrollableArea);
2873     return handledEvent;
2874 }
2875 
2876 void EventHandler::clearLatchedState()
2877 {
2878     auto* page = m_frame.page();
2879     if (!page)
2880         return;
2881 
2882 #if PLATFORM(MAC)
2883     page-&gt;resetLatchingState();
2884 #endif
2885     if (auto filter = page-&gt;wheelEventDeltaFilter())
2886         filter-&gt;endFilteringDeltas();
2887 }
2888 
2889 void EventHandler::defaultWheelEventHandler(Node* startNode, WheelEvent&amp; wheelEvent)
2890 {
2891     if (!startNode)
2892         return;
2893 
2894     auto protectedFrame = makeRef(m_frame);
2895 
2896     FloatSize filteredPlatformDelta(wheelEvent.deltaX(), wheelEvent.deltaY());
2897     FloatSize filteredVelocity;
2898     if (auto platformWheelEvent = wheelEvent.underlyingPlatformEvent()) {
2899         filteredPlatformDelta.setWidth(platformWheelEvent-&gt;deltaX());
2900         filteredPlatformDelta.setHeight(platformWheelEvent-&gt;deltaY());
2901     }
2902 
2903 #if PLATFORM(MAC)
2904     ScrollLatchingState* latchedState = m_frame.page() ? m_frame.page()-&gt;latchingState() : nullptr;
2905     Element* stopElement = latchedState ? latchedState-&gt;previousWheelScrolledElement() : nullptr;
2906 
2907     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;isFilteringDeltas()) {
2908         filteredPlatformDelta = m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;filteredDelta();
2909         filteredVelocity = m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;filteredVelocity();
2910     }
2911 #else
2912     Element* stopElement = nullptr;
2913 #endif
2914 
2915     if (handleWheelEventInAppropriateEnclosingBox(startNode, wheelEvent, &amp;stopElement, filteredPlatformDelta, filteredVelocity))
2916         wheelEvent.setDefaultHandled();
2917 
2918 #if PLATFORM(MAC)
2919     if (latchedState &amp;&amp; !latchedState-&gt;wheelEventElement())
2920         latchedState-&gt;setPreviousWheelScrolledElement(stopElement);
2921 #endif
2922 }
2923 
2924 #if ENABLE(CONTEXT_MENUS)
2925 bool EventHandler::sendContextMenuEvent(const PlatformMouseEvent&amp; event)
2926 {
2927     Ref&lt;Frame&gt; protectedFrame(m_frame);
2928 
2929     Document* doc = m_frame.document();
2930     FrameView* view = m_frame.view();
2931     if (!view)
2932         return false;
2933 
2934     // Caret blinking is normally un-suspended in handleMouseReleaseEvent, but we
2935     // won&#39;t receive that event once the context menu is up.
2936     m_frame.selection().setCaretBlinkingSuspended(false);
2937     // Clear mouse press state to avoid initiating a drag while context menu is up.
2938     m_mousePressed = false;
2939     bool swallowEvent;
2940     LayoutPoint viewportPos = view-&gt;windowToContents(event.position());
2941     HitTestRequest request(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent);
2942     MouseEventWithHitTestResults mouseEvent = doc-&gt;prepareMouseEvent(request, viewportPos, event);
2943 
2944     // Do not show context menus when clicking on scrollbars.
2945     if (mouseEvent.scrollbar() || view-&gt;scrollbarAtPoint(event.position()))
2946         return false;
2947 
2948     if (m_frame.editor().behavior().shouldSelectOnContextualMenuClick()
2949         &amp;&amp; !m_frame.selection().contains(viewportPos)
2950         // FIXME: In the editable case, word selection sometimes selects content that isn&#39;t underneath the mouse.
2951         // If the selection is non-editable, we do word selection to make it easier to use the contextual menu items
2952         // available for text selections.  But only if we&#39;re above text.
2953         &amp;&amp; (m_frame.selection().selection().isContentEditable() || (mouseEvent.targetNode() &amp;&amp; mouseEvent.targetNode()-&gt;isTextNode()))) {
2954         m_mouseDownMayStartSelect = true; // context menu events are always allowed to perform a selection
2955         selectClosestContextualWordOrLinkFromMouseEvent(mouseEvent);
2956     }
2957 
2958     swallowEvent = !dispatchMouseEvent(eventNames().contextmenuEvent, mouseEvent.targetNode(), true, 0, event, false);
2959 
2960     return swallowEvent;
2961 }
2962 
2963 bool EventHandler::sendContextMenuEventForKey()
2964 {
2965     Ref&lt;Frame&gt; protectedFrame(m_frame);
2966 
2967     FrameView* view = m_frame.view();
2968     if (!view)
2969         return false;
2970 
2971     Document* doc = m_frame.document();
2972     if (!doc)
2973         return false;
2974 
2975     // Clear mouse press state to avoid initiating a drag while context menu is up.
2976     m_mousePressed = false;
2977 
2978     static const int kContextMenuMargin = 1;
2979 
2980 #if OS(WINDOWS) &amp;&amp; !PLATFORM(JAVA)
2981     int rightAligned = ::GetSystemMetrics(SM_MENUDROPALIGNMENT);
2982 #else
2983     int rightAligned = 0;
2984 #endif
2985     IntPoint location;
2986 
2987     Element* focusedElement = doc-&gt;focusedElement();
2988     const VisibleSelection&amp; selection = m_frame.selection().selection();
2989     Position start = selection.start();
2990 
2991     if (start.deprecatedNode() &amp;&amp; (selection.rootEditableElement() || selection.isRange())) {
2992         RefPtr&lt;Range&gt; selectionRange = selection.toNormalizedRange();
2993         IntRect firstRect = m_frame.editor().firstRectForRange(selectionRange.get());
2994 
2995         int x = rightAligned ? firstRect.maxX() : firstRect.x();
2996         // In a multiline edit, firstRect.maxY() would endup on the next line, so -1.
2997         int y = firstRect.maxY() ? firstRect.maxY() - 1 : 0;
2998         location = IntPoint(x, y);
2999     } else if (focusedElement) {
3000         RenderBoxModelObject* box = focusedElement-&gt;renderBoxModelObject();
3001         if (!box)
3002             return false;
3003 
3004         IntRect boundingBoxRect = box-&gt;absoluteBoundingBoxRect(true);
3005         location = IntPoint(boundingBoxRect.x(), boundingBoxRect.maxY() - 1);
3006     } else {
3007         location = IntPoint(
3008             rightAligned ? view-&gt;contentsWidth() - kContextMenuMargin : kContextMenuMargin,
3009             kContextMenuMargin);
3010     }
3011 
3012     m_frame.view()-&gt;setCursor(pointerCursor());
3013 
3014     IntPoint position = view-&gt;contentsToRootView(location);
3015     IntPoint globalPosition = view-&gt;hostWindow()-&gt;rootViewToScreen(IntRect(position, IntSize())).location();
3016 
3017     Node* targetNode = doc-&gt;focusedElement();
3018     if (!targetNode)
3019         targetNode = doc;
3020 
3021     // Use the focused node as the target for hover and active.
3022     HitTestResult result(position);
3023     result.setInnerNode(targetNode);
3024     doc-&gt;updateHoverActiveState(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent, result.targetElement());
3025 
3026     // The contextmenu event is a mouse event even when invoked using the keyboard.
3027     // This is required for web compatibility.
3028 
3029 #if OS(WINDOWS)
3030     PlatformEvent::Type eventType = PlatformEvent::MouseReleased;
3031 #else
3032     PlatformEvent::Type eventType = PlatformEvent::MousePressed;
3033 #endif
3034 
3035     PlatformMouseEvent platformMouseEvent(position, globalPosition, RightButton, eventType, 1, false, false, false, false, WallTime::now(), ForceAtClick, NoTap);
3036 
3037     return sendContextMenuEvent(platformMouseEvent);
3038 }
3039 #endif // ENABLE(CONTEXT_MENUS)
3040 
3041 void EventHandler::scheduleHoverStateUpdate()
3042 {
3043     if (!m_hoverTimer.isActive())
3044         m_hoverTimer.startOneShot(0_s);
3045 }
3046 
3047 #if ENABLE(CURSOR_SUPPORT)
3048 void EventHandler::scheduleCursorUpdate()
3049 {
3050     if (!m_cursorUpdateTimer.isActive())
3051         m_cursorUpdateTimer.startOneShot(cursorUpdateInterval);
3052 }
3053 #endif
3054 
3055 void EventHandler::dispatchFakeMouseMoveEventSoon()
3056 {
3057 #if !ENABLE(IOS_TOUCH_EVENTS)
3058     if (m_mousePressed)
3059         return;
3060 
3061     if (m_mousePositionIsUnknown)
3062         return;
3063 
3064     if (Page* page = m_frame.page()) {
3065         if (!page-&gt;chrome().client().shouldDispatchFakeMouseMoveEvents())
3066             return;
3067     }
3068 
3069     // If the content has ever taken longer than fakeMouseMoveShortInterval we
3070     // reschedule the timer and use a longer time. This will cause the content
3071     // to receive these moves only after the user is done scrolling, reducing
3072     // pauses during the scroll.
3073     if (m_fakeMouseMoveEventTimer.isActive())
3074         m_fakeMouseMoveEventTimer.stop();
3075     m_fakeMouseMoveEventTimer.startOneShot(m_maxMouseMovedDuration &gt; fakeMouseMoveDurationThreshold ? fakeMouseMoveLongInterval : fakeMouseMoveShortInterval);
3076 #endif
3077 }
3078 
3079 void EventHandler::dispatchFakeMouseMoveEventSoonInQuad(const FloatQuad&amp; quad)
3080 {
3081 #if ENABLE(IOS_TOUCH_EVENTS)
3082     UNUSED_PARAM(quad);
3083 #else
3084     FrameView* view = m_frame.view();
3085     if (!view)
3086         return;
3087 
3088     if (!quad.containsPoint(view-&gt;windowToContents(m_lastKnownMousePosition)))
3089         return;
3090 
3091     dispatchFakeMouseMoveEventSoon();
3092 #endif
3093 }
3094 
3095 #if !ENABLE(IOS_TOUCH_EVENTS)
3096 void EventHandler::cancelFakeMouseMoveEvent()
3097 {
3098     m_fakeMouseMoveEventTimer.stop();
3099 }
3100 
3101 void EventHandler::fakeMouseMoveEventTimerFired()
3102 {
3103     ASSERT(!m_mousePressed);
3104 
3105     FrameView* view = m_frame.view();
3106     if (!view)
3107         return;
3108 
3109     if (!m_frame.page() || !m_frame.page()-&gt;isVisible() || !m_frame.page()-&gt;focusController().isActive())
3110         return;
3111 
3112     bool shiftKey;
3113     bool ctrlKey;
3114     bool altKey;
3115     bool metaKey;
3116     PlatformKeyboardEvent::getCurrentModifierState(shiftKey, ctrlKey, altKey, metaKey);
3117     PlatformMouseEvent fakeMouseMoveEvent(m_lastKnownMousePosition, m_lastKnownMouseGlobalPosition, NoButton, PlatformEvent::MouseMoved, 0, shiftKey, ctrlKey, altKey, metaKey, WallTime::now(), 0, NoTap);
3118     mouseMoved(fakeMouseMoveEvent);
3119 }
3120 #endif // !ENABLE(IOS_TOUCH_EVENTS)
3121 
3122 void EventHandler::setResizingFrameSet(HTMLFrameSetElement* frameSet)
3123 {
3124     m_frameSetBeingResized = frameSet;
3125 }
3126 
3127 void EventHandler::resizeLayerDestroyed()
3128 {
3129     ASSERT(m_resizeLayer);
3130     m_resizeLayer = nullptr;
3131 }
3132 
3133 void EventHandler::hoverTimerFired()
3134 {
3135     m_hoverTimer.stop();
3136 
3137     ASSERT(m_frame.document());
3138 
3139     Ref&lt;Frame&gt; protectedFrame(m_frame);
3140 
3141     if (auto* document = m_frame.document()) {
3142         if (FrameView* view = m_frame.view()) {
3143             HitTestRequest request(HitTestRequest::Move | HitTestRequest::DisallowUserAgentShadowContent);
3144             HitTestResult result(view-&gt;windowToContents(m_lastKnownMousePosition));
3145             document-&gt;hitTest(request, result);
3146             document-&gt;updateHoverActiveState(request, result.targetElement());
3147         }
3148     }
3149 }
3150 
3151 bool EventHandler::handleAccessKey(const PlatformKeyboardEvent&amp; event)
3152 {
3153     // FIXME: Ignoring the state of Shift key is what neither IE nor Firefox do.
3154     // IE matches lower and upper case access keys regardless of Shift key state - but if both upper and
3155     // lower case variants are present in a document, the correct element is matched based on Shift key state.
3156     // Firefox only matches an access key if Shift is not pressed, and does that case-insensitively.
3157     ASSERT(!accessKeyModifiers().contains(PlatformEvent::Modifier::ShiftKey));
3158 
3159     if ((event.modifiers() - PlatformEvent::Modifier::ShiftKey) != accessKeyModifiers())
3160         return false;
3161     auto* element = m_frame.document()-&gt;elementForAccessKey(event.unmodifiedText());
3162     if (!element)
3163         return false;
3164     element-&gt;accessKeyAction(false);
3165     return true;
3166 }
3167 
3168 #if !PLATFORM(MAC)
3169 bool EventHandler::needsKeyboardEventDisambiguationQuirks() const
3170 {
3171     return false;
3172 }
3173 #endif
3174 
3175 #if ENABLE(FULLSCREEN_API)
3176 bool EventHandler::isKeyEventAllowedInFullScreen(const PlatformKeyboardEvent&amp; keyEvent) const
3177 {
3178     Document* document = m_frame.document();
3179     if (document-&gt;fullscreenManager().isFullscreenKeyboardInputAllowed())
3180         return true;
3181 
3182     if (keyEvent.type() == PlatformKeyboardEvent::Char) {
3183         if (keyEvent.text().length() != 1)
3184             return false;
3185         UChar character = keyEvent.text()[0];
3186         return character == &#39; &#39;;
3187     }
3188 
3189     int keyCode = keyEvent.windowsVirtualKeyCode();
3190     return (keyCode &gt;= VK_BACK &amp;&amp; keyCode &lt;= VK_CAPITAL)
3191         || (keyCode &gt;= VK_SPACE &amp;&amp; keyCode &lt;= VK_DELETE)
3192         || (keyCode &gt;= VK_OEM_1 &amp;&amp; keyCode &lt;= VK_OEM_PLUS)
3193         || (keyCode &gt;= VK_MULTIPLY &amp;&amp; keyCode &lt;= VK_OEM_8);
3194 }
3195 #endif
3196 
3197 bool EventHandler::keyEvent(const PlatformKeyboardEvent&amp; keyEvent)
3198 {
3199     Document* topDocument = m_frame.document() ? &amp;m_frame.document()-&gt;topDocument() : nullptr;
3200     MonotonicTime savedLastHandledUserGestureTimestamp;
3201     bool savedUserDidInteractWithPage = topDocument ? topDocument-&gt;userDidInteractWithPage() : false;
3202 
3203     if (m_frame.document())
3204         savedLastHandledUserGestureTimestamp = m_frame.document()-&gt;lastHandledUserGestureTimestamp();
3205 
3206     bool wasHandled = internalKeyEvent(keyEvent);
3207 
3208     // If the key event was not handled, do not treat it as user interaction with the page.
3209     if (topDocument) {
3210         if (!wasHandled)
3211             topDocument-&gt;setUserDidInteractWithPage(savedUserDidInteractWithPage);
3212         else
3213             ResourceLoadObserver::shared().logUserInteractionWithReducedTimeResolution(*topDocument);
3214     }
3215 
3216     if (!wasHandled &amp;&amp; m_frame.document())
3217         m_frame.document()-&gt;updateLastHandledUserGestureTimestamp(savedLastHandledUserGestureTimestamp);
3218 
3219     return wasHandled;
3220 }
3221 
3222 void EventHandler::capsLockStateMayHaveChanged() const
3223 {
3224     auto* focusedElement = m_frame.document()-&gt;focusedElement();
3225     if (!is&lt;HTMLInputElement&gt;(focusedElement))
3226         return;
3227     downcast&lt;HTMLInputElement&gt;(*focusedElement).capsLockStateMayHaveChanged();
3228 }
3229 
3230 bool EventHandler::internalKeyEvent(const PlatformKeyboardEvent&amp; initialKeyEvent)
3231 {
3232     Ref&lt;Frame&gt; protectedFrame(m_frame);
3233     RefPtr&lt;FrameView&gt; protector(m_frame.view());
3234 
3235     LOG(Editing, &quot;EventHandler %p keyEvent (text %s keyIdentifier %s)&quot;, this, initialKeyEvent.text().utf8().data(), initialKeyEvent.keyIdentifier().utf8().data());
3236 
3237 #if ENABLE(POINTER_LOCK)
3238     if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE &amp;&amp; m_frame.page()-&gt;pointerLockController().element()) {
3239         m_frame.page()-&gt;pointerLockController().requestPointerUnlockAndForceCursorVisible();
3240     }
3241 #endif
3242 
3243     if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE) {
3244         if (auto* page = m_frame.page()) {
3245             if (auto* validationMessageClient = page-&gt;validationMessageClient())
3246                 validationMessageClient-&gt;hideAnyValidationMessage();
3247         }
3248     }
3249 
3250 #if ENABLE(FULLSCREEN_API)
3251     if (m_frame.document()-&gt;fullscreenManager().isFullscreen()) {
3252         if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE) {
3253             m_frame.document()-&gt;fullscreenManager().cancelFullscreen();
3254             return true;
3255         }
3256 
3257         if (!isKeyEventAllowedInFullScreen(initialKeyEvent))
3258             return false;
3259     }
3260 #endif
3261 
3262     if (initialKeyEvent.windowsVirtualKeyCode() == VK_CAPITAL)
3263         capsLockStateMayHaveChanged();
3264 
3265 #if ENABLE(PAN_SCROLLING)
3266     if (m_frame.mainFrame().eventHandler().panScrollInProgress()) {
3267         // If a key is pressed while the panScroll is in progress then we want to stop
3268         if (initialKeyEvent.type() == PlatformEvent::KeyDown || initialKeyEvent.type() == PlatformEvent::RawKeyDown)
3269             stopAutoscrollTimer();
3270 
3271         // If we were in panscroll mode, we swallow the key event
3272         return true;
3273     }
3274 #endif
3275 
3276     // Check for cases where we are too early for events -- possible unmatched key up
3277     // from pressing return in the location bar.
3278     RefPtr&lt;Element&gt; element = eventTargetElementForDocument(m_frame.document());
3279     if (!element)
3280         return false;
3281 
3282     UserGestureType gestureType = UserGestureType::Other;
3283     if (initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE)
3284         gestureType = UserGestureType::EscapeKey;
3285 
3286     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document(), gestureType, UserGestureIndicator::ProcessInteractionStyle::Delayed);
3287     UserTypingGestureIndicator typingGestureIndicator(m_frame);
3288 
3289     if (FrameView* view = m_frame.view())
3290         view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
3291 
3292     // FIXME (bug 68185): this call should be made at another abstraction layer
3293     m_frame.loader().resetMultipleFormSubmissionProtection();
3294 
3295     // In IE, access keys are special, they are handled after default keydown processing, but cannot be canceled - this is hard to match.
3296     // On Mac OS X, we process them before dispatching keydown, as the default keydown handler implements Emacs key bindings, which may conflict
3297     // with access keys. Then we dispatch keydown, but suppress its default handling.
3298     // On Windows, WebKit explicitly calls handleAccessKey() instead of dispatching a keypress event for WM_SYSCHAR messages.
3299     // Other platforms currently match either Mac or Windows behavior, depending on whether they send combined KeyDown events.
3300     bool matchedAnAccessKey = false;
3301     if (initialKeyEvent.type() == PlatformEvent::KeyDown)
3302         matchedAnAccessKey = handleAccessKey(initialKeyEvent);
3303 
3304     // FIXME: it would be fair to let an input method handle KeyUp events before DOM dispatch.
3305     if (initialKeyEvent.type() == PlatformEvent::KeyUp || initialKeyEvent.type() == PlatformEvent::Char)
3306         return !element-&gt;dispatchKeyEvent(initialKeyEvent);
3307 
3308     bool backwardCompatibilityMode = needsKeyboardEventDisambiguationQuirks();
3309 
3310     PlatformKeyboardEvent keyDownEvent = initialKeyEvent;
3311     if (keyDownEvent.type() != PlatformEvent::RawKeyDown)
3312         keyDownEvent.disambiguateKeyDownEvent(PlatformEvent::RawKeyDown, backwardCompatibilityMode);
3313     auto keydown = KeyboardEvent::create(keyDownEvent, &amp;m_frame.windowProxy());
3314     if (matchedAnAccessKey)
3315         keydown-&gt;preventDefault();
3316     keydown-&gt;setTarget(element);
3317 
3318     if (initialKeyEvent.type() == PlatformEvent::RawKeyDown) {
3319         element-&gt;dispatchEvent(keydown);
3320         // If frame changed as a result of keydown dispatch, then return true to avoid sending a subsequent keypress message to the new frame.
3321         bool changedFocusedFrame = m_frame.page() &amp;&amp; &amp;m_frame != &amp;m_frame.page()-&gt;focusController().focusedOrMainFrame();
3322         return keydown-&gt;defaultHandled() || keydown-&gt;defaultPrevented() || changedFocusedFrame;
3323     }
3324 
3325     // Run input method in advance of DOM event handling.  This may result in the IM
3326     // modifying the page prior the keydown event, but this behaviour is necessary
3327     // in order to match IE:
3328     // 1. preventing default handling of keydown and keypress events has no effect on IM input;
3329     // 2. if an input method handles the event, its keyCode is set to 229 in keydown event.
3330     m_frame.editor().handleInputMethodKeydown(keydown.get());
3331 
3332     bool handledByInputMethod = keydown-&gt;defaultHandled();
3333 
3334     if (handledByInputMethod) {
3335         keyDownEvent.setWindowsVirtualKeyCode(CompositionEventKeyCode);
3336         keydown = KeyboardEvent::create(keyDownEvent, &amp;m_frame.windowProxy());
3337         keydown-&gt;setTarget(element);
3338         keydown-&gt;setIsDefaultEventHandlerIgnored();
3339     }
3340 
3341     if (accessibilityPreventsEventPropagation(keydown))
3342         keydown-&gt;stopPropagation();
3343 
3344 #if PLATFORM(IOS_FAMILY)
3345     DeferDOMTimersForScope deferralScope { m_frame.document()-&gt;quirks().needsDeferKeyDownAndKeyPressTimersUntilNextEditingCommand() };
3346 #endif
3347 
3348     element-&gt;dispatchEvent(keydown);
3349     if (handledByInputMethod)
3350         return true;
3351 
3352     // If frame changed as a result of keydown dispatch, then return early to avoid sending a subsequent keypress message to the new frame.
3353     bool changedFocusedFrame = m_frame.page() &amp;&amp; &amp;m_frame != &amp;m_frame.page()-&gt;focusController().focusedOrMainFrame();
3354     bool keydownResult = keydown-&gt;defaultHandled() || keydown-&gt;defaultPrevented() || changedFocusedFrame;
3355     if (keydownResult &amp;&amp; !backwardCompatibilityMode)
3356         return keydownResult;
3357 
3358     // Focus may have changed during keydown handling, so refetch element.
3359     // But if we are dispatching a fake backward compatibility keypress, then we pretend that the keypress happened on the original element.
3360     if (!keydownResult) {
3361         element = eventTargetElementForDocument(m_frame.document());
3362         if (!element)
3363             return false;
3364     }
3365 
3366     PlatformKeyboardEvent keyPressEvent = initialKeyEvent;
3367     keyPressEvent.disambiguateKeyDownEvent(PlatformEvent::Char, backwardCompatibilityMode);
3368     if (keyPressEvent.text().isEmpty())
3369         return keydownResult;
3370     auto keypress = KeyboardEvent::create(keyPressEvent, &amp;m_frame.windowProxy());
3371     keypress-&gt;setTarget(element);
3372     if (keydownResult)
3373         keypress-&gt;preventDefault();
3374 #if PLATFORM(COCOA)
3375     keypress-&gt;keypressCommands() = keydown-&gt;keypressCommands();
3376 #endif
3377     element-&gt;dispatchEvent(keypress);
3378 
3379     return keydownResult || keypress-&gt;defaultPrevented() || keypress-&gt;defaultHandled();
3380 }
3381 
3382 static FocusDirection focusDirectionForKey(const AtomString&amp; keyIdentifier)
3383 {
3384     static NeverDestroyed&lt;AtomString&gt; Down(&quot;Down&quot;, AtomString::ConstructFromLiteral);
3385     static NeverDestroyed&lt;AtomString&gt; Up(&quot;Up&quot;, AtomString::ConstructFromLiteral);
3386     static NeverDestroyed&lt;AtomString&gt; Left(&quot;Left&quot;, AtomString::ConstructFromLiteral);
3387     static NeverDestroyed&lt;AtomString&gt; Right(&quot;Right&quot;, AtomString::ConstructFromLiteral);
3388 
3389     FocusDirection retVal = FocusDirectionNone;
3390 
3391     if (keyIdentifier == Down)
3392         retVal = FocusDirectionDown;
3393     else if (keyIdentifier == Up)
3394         retVal = FocusDirectionUp;
3395     else if (keyIdentifier == Left)
3396         retVal = FocusDirectionLeft;
3397     else if (keyIdentifier == Right)
3398         retVal = FocusDirectionRight;
3399 
3400     return retVal;
3401 }
3402 
3403 static void setInitialKeyboardSelection(Frame&amp; frame, SelectionDirection direction)
3404 {
3405     Document* document = frame.document();
3406     if (!document)
3407         return;
3408 
3409     FrameSelection&amp; selection = frame.selection();
3410 
3411     if (!selection.isNone())
3412         return;
3413 
3414     Element* focusedElement = document-&gt;focusedElement();
3415     VisiblePosition visiblePosition;
3416 
3417     switch (direction) {
3418     case DirectionBackward:
3419     case DirectionLeft:
3420         if (focusedElement)
3421             visiblePosition = VisiblePosition(positionBeforeNode(focusedElement));
3422         else
3423             visiblePosition = endOfDocument(document);
3424         break;
3425     case DirectionForward:
3426     case DirectionRight:
3427         if (focusedElement)
3428             visiblePosition = VisiblePosition(positionAfterNode(focusedElement));
3429         else
3430             visiblePosition = startOfDocument(document);
3431         break;
3432     }
3433 
3434     AXTextStateChangeIntent intent(AXTextStateChangeTypeSelectionMove, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityUnknown, false });
3435     selection.setSelection(visiblePosition, FrameSelection::defaultSetSelectionOptions(UserTriggered), intent);
3436 }
3437 
3438 static void handleKeyboardSelectionMovement(Frame&amp; frame, KeyboardEvent&amp; event)
3439 {
3440     FrameSelection&amp; selection = frame.selection();
3441 
3442     bool isCommanded = event.getModifierState(&quot;Meta&quot;);
3443     bool isOptioned = event.getModifierState(&quot;Alt&quot;);
3444     bool isSelection = !selection.isNone();
3445 
3446     FrameSelection::EAlteration alternation = event.getModifierState(&quot;Shift&quot;) ? FrameSelection::AlterationExtend : FrameSelection::AlterationMove;
3447     SelectionDirection direction = DirectionForward;
3448     TextGranularity granularity = CharacterGranularity;
3449 
3450     switch (focusDirectionForKey(event.keyIdentifier())) {
3451     case FocusDirectionNone:
3452         return;
3453     case FocusDirectionForward:
3454     case FocusDirectionBackward:
3455         ASSERT_NOT_REACHED();
3456         return;
3457     case FocusDirectionUp:
3458         direction = DirectionBackward;
3459         granularity = isCommanded ? DocumentBoundary : LineGranularity;
3460         break;
3461     case FocusDirectionDown:
3462         direction = DirectionForward;
3463         granularity = isCommanded ? DocumentBoundary : LineGranularity;
3464         break;
3465     case FocusDirectionLeft:
3466         direction = DirectionLeft;
3467         granularity = (isCommanded) ? LineBoundary : (isOptioned) ? WordGranularity : CharacterGranularity;
3468         break;
3469     case FocusDirectionRight:
3470         direction = DirectionRight;
3471         granularity = (isCommanded) ? LineBoundary : (isOptioned) ? WordGranularity : CharacterGranularity;
3472         break;
3473     }
3474 
3475     if (isSelection)
3476         selection.modify(alternation, direction, granularity, UserTriggered);
3477     else
3478         setInitialKeyboardSelection(frame, direction);
3479 
3480     event.setDefaultHandled();
3481 }
3482 
3483 void EventHandler::handleKeyboardSelectionMovementForAccessibility(KeyboardEvent&amp; event)
3484 {
3485     if (event.type() == eventNames().keydownEvent) {
3486         if (AXObjectCache::accessibilityEnhancedUserInterfaceEnabled())
3487             handleKeyboardSelectionMovement(m_frame, event);
3488     }
3489 }
3490 
3491 bool EventHandler::accessibilityPreventsEventPropagation(KeyboardEvent&amp; event)
3492 {
3493 #if PLATFORM(COCOA)
3494     if (!AXObjectCache::accessibilityEnhancedUserInterfaceEnabled())
3495         return false;
3496 
3497     if (!m_frame.settings().preventKeyboardDOMEventDispatch())
3498         return false;
3499 
3500     // Check for key events that are relevant to accessibility: tab and arrows keys that change focus
3501     if (event.keyIdentifier() == &quot;U+0009&quot;)
3502         return true;
3503     FocusDirection direction = focusDirectionForKey(event.keyIdentifier());
3504     if (direction != FocusDirectionNone)
3505         return true;
3506 #else
3507     UNUSED_PARAM(event);
3508 #endif
3509     return false;
3510 }
3511 
3512 void EventHandler::defaultKeyboardEventHandler(KeyboardEvent&amp; event)
3513 {
3514     Ref&lt;Frame&gt; protectedFrame(m_frame);
3515 
3516     if (event.type() == eventNames().keydownEvent) {
3517         m_frame.editor().handleKeyboardEvent(event);
3518         if (event.defaultHandled())
3519             return;
3520         if (event.keyIdentifier() == &quot;U+0009&quot;)
3521             defaultTabEventHandler(event);
3522         else if (event.keyIdentifier() == &quot;U+0008&quot;)
3523             defaultBackspaceEventHandler(event);
3524         else {
3525             FocusDirection direction = focusDirectionForKey(event.keyIdentifier());
3526             if (direction != FocusDirectionNone)
3527                 defaultArrowEventHandler(direction, event);
3528         }
3529 
3530         handleKeyboardSelectionMovementForAccessibility(event);
3531     }
3532     if (event.type() == eventNames().keypressEvent) {
3533         m_frame.editor().handleKeyboardEvent(event);
3534         if (event.defaultHandled())
3535             return;
3536         if (event.charCode() == &#39; &#39;)
3537             defaultSpaceEventHandler(event);
3538     }
3539 }
3540 
3541 #if ENABLE(DRAG_SUPPORT)
3542 bool EventHandler::dragHysteresisExceeded(const IntPoint&amp; floatDragViewportLocation) const
3543 {
3544     FloatPoint dragViewportLocation(floatDragViewportLocation.x(), floatDragViewportLocation.y());
3545     return dragHysteresisExceeded(dragViewportLocation);
3546 }
3547 
3548 bool EventHandler::dragHysteresisExceeded(const FloatPoint&amp; dragViewportLocation) const
3549 {
3550     int threshold = GeneralDragHysteresis;
3551     switch (dragState().type) {
3552     case DragSourceActionSelection:
3553         threshold = TextDragHysteresis;
3554         break;
3555     case DragSourceActionImage:
3556 #if ENABLE(ATTACHMENT_ELEMENT)
3557     case DragSourceActionAttachment:
3558 #endif
3559         threshold = ImageDragHysteresis;
3560         break;
3561     case DragSourceActionLink:
3562         threshold = LinkDragHysteresis;
3563         break;
3564 #if ENABLE(INPUT_TYPE_COLOR)
3565     case DragSourceActionColor:
3566         threshold = ColorDragHystersis;
3567         break;
3568 #endif
3569     case DragSourceActionDHTML:
3570         break;
3571     case DragSourceActionNone:
3572     case DragSourceActionAny:
3573         ASSERT_NOT_REACHED();
3574     }
3575 
3576     return mouseMovementExceedsThreshold(dragViewportLocation, threshold);
3577 }
3578 
3579 void EventHandler::invalidateDataTransfer()
3580 {
3581     if (!dragState().dataTransfer)
3582         return;
3583     dragState().dataTransfer-&gt;makeInvalidForSecurity();
3584     dragState().dataTransfer = nullptr;
3585 }
3586 
3587 static void removeDraggedContentDocumentMarkersFromAllFramesInPage(Page&amp; page)
3588 {
3589     for (Frame* frame = &amp;page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
3590         if (auto* document = frame-&gt;document())
3591             document-&gt;markers().removeMarkers(DocumentMarker::DraggedContent);
3592     }
3593 
3594     if (auto* mainFrameRenderer = page.mainFrame().contentRenderer())
3595         mainFrameRenderer-&gt;repaintRootContents();
3596 }
3597 
3598 void EventHandler::dragCancelled()
3599 {
3600 #if ENABLE(DATA_INTERACTION)
3601     if (auto* page = m_frame.page())
3602         removeDraggedContentDocumentMarkersFromAllFramesInPage(*page);
3603 #endif
3604 }
3605 
3606 void EventHandler::didStartDrag()
3607 {
3608 #if ENABLE(DATA_INTERACTION)
3609     auto dragSource = dragState().source;
3610     if (!dragSource)
3611         return;
3612 
3613     auto* renderer = dragSource-&gt;renderer();
3614     if (!renderer)
3615         return;
3616 
3617     RefPtr&lt;Range&gt; draggedContentRange;
3618     if (dragState().type &amp; DragSourceActionSelection)
3619         draggedContentRange = m_frame.selection().selection().toNormalizedRange();
3620     else {
3621         Position startPosition(dragSource.get(), Position::PositionIsBeforeAnchor);
3622         Position endPosition(dragSource.get(), Position::PositionIsAfterAnchor);
3623         draggedContentRange = Range::create(dragSource-&gt;document(), startPosition, endPosition);
3624     }
3625 
3626     if (draggedContentRange) {
3627         draggedContentRange-&gt;ownerDocument().markers().addDraggedContentMarker(*draggedContentRange);
3628         if (auto* renderer = m_frame.contentRenderer())
3629             renderer-&gt;repaintRootContents();
3630     }
3631 #endif
3632 }
3633 
3634 void EventHandler::dragSourceEndedAt(const PlatformMouseEvent&amp; event, DragOperation operation, MayExtendDragSession mayExtendDragSession)
3635 {
3636     // Send a hit test request so that RenderLayer gets a chance to update the :hover and :active pseudoclasses.
3637     HitTestRequest request(HitTestRequest::Release | HitTestRequest::DisallowUserAgentShadowContent);
3638     prepareMouseEvent(request, event);
3639 
3640     if (dragState().source &amp;&amp; dragState().shouldDispatchEvents) {
3641         dragState().dataTransfer-&gt;setDestinationOperation(operation);
3642         dispatchDragSrcEvent(eventNames().dragendEvent, event);
3643     }
3644     invalidateDataTransfer();
3645 
3646     if (mayExtendDragSession == MayExtendDragSession::No) {
3647         if (auto* page = m_frame.page())
3648             removeDraggedContentDocumentMarkersFromAllFramesInPage(*page);
3649     }
3650 
3651     dragState().source = nullptr;
3652     // In case the drag was ended due to an escape key press we need to ensure
3653     // that consecutive mousemove events don&#39;t reinitiate the drag and drop.
3654     m_mouseDownMayStartDrag = false;
3655 }
3656 
3657 void EventHandler::updateDragStateAfterEditDragIfNeeded(Element&amp; rootEditableElement)
3658 {
3659     // If inserting the dragged contents removed the drag source, we still want to fire dragend at the root editable element.
3660     if (dragState().source &amp;&amp; !dragState().source-&gt;isConnected())
3661         dragState().source = &amp;rootEditableElement;
3662 }
3663 
3664 void EventHandler::dispatchDragSrcEvent(const AtomString&amp; eventType, const PlatformMouseEvent&amp; event)
3665 {
3666     ASSERT(dragState().dataTransfer);
3667     dispatchDragEvent(eventType, *dragState().source, event, *dragState().dataTransfer);
3668 }
3669 
3670 bool EventHandler::dispatchDragStartEventOnSourceElement(DataTransfer&amp; dataTransfer)
3671 {
3672     return !dispatchDragEvent(eventNames().dragstartEvent, *dragState().source, m_mouseDown, dataTransfer) &amp;&amp; !m_frame.selection().selection().isInPasswordField();
3673 }
3674 
3675 static bool ExactlyOneBitSet(DragSourceAction n)
3676 {
3677     return n &amp;&amp; !(n &amp; (n - 1));
3678 }
3679 
3680 RefPtr&lt;Element&gt; EventHandler::draggedElement() const
3681 {
3682     return dragState().source;
3683 }
3684 
3685 bool EventHandler::handleDrag(const MouseEventWithHitTestResults&amp; event, CheckDragHysteresis checkDragHysteresis)
3686 {
3687     if (event.event().button() != LeftButton || event.event().type() != PlatformEvent::MouseMoved) {
3688         // If we allowed the other side of the bridge to handle a drag
3689         // last time, then m_mousePressed might still be set. So we
3690         // clear it now to make sure the next move after a drag
3691         // doesn&#39;t look like a drag.
3692         m_mousePressed = false;
3693         return false;
3694     }
3695 
3696     Ref&lt;Frame&gt; protectedFrame(m_frame);
3697 
3698     if (eventLoopHandleMouseDragged(event))
3699         return true;
3700 
3701     // Careful that the drag starting logic stays in sync with eventMayStartDrag()
3702 
3703     if (m_mouseDownMayStartDrag &amp;&amp; !dragState().source) {
3704         dragState().shouldDispatchEvents = (updateDragSourceActionsAllowed() &amp; DragSourceActionDHTML);
3705 
3706         // try to find an element that wants to be dragged
3707         HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
3708         HitTestResult result(m_mouseDownPos);
3709         m_frame.document()-&gt;hitTest(request, result);
3710         if (m_frame.page())
3711             dragState().source = m_frame.page()-&gt;dragController().draggableElement(&amp;m_frame, result.targetElement(), m_mouseDownPos, dragState());
3712 
3713         if (!dragState().source)
3714             m_mouseDownMayStartDrag = false; // no element is draggable
3715         else
3716             m_dragMayStartSelectionInstead = (dragState().type &amp; DragSourceActionSelection);
3717     }
3718 
3719     // For drags starting in the selection, the user must wait between the mousedown and mousedrag,
3720     // or else we bail on the dragging stuff and allow selection to occur
3721     if (m_mouseDownMayStartDrag &amp;&amp; m_dragMayStartSelectionInstead &amp;&amp; (dragState().type &amp; DragSourceActionSelection) &amp;&amp; event.event().timestamp() - m_mouseDownTimestamp &lt; TextDragDelay) {
3722         ASSERT(event.event().type() == PlatformEvent::MouseMoved);
3723         if ((dragState().type &amp; DragSourceActionImage)) {
3724             // ... unless the mouse is over an image, then we start dragging just the image
3725             dragState().type = DragSourceActionImage;
3726         } else if (!(dragState().type &amp; (DragSourceActionDHTML | DragSourceActionLink))) {
3727             // ... but only bail if we&#39;re not over an unselectable element.
3728             m_mouseDownMayStartDrag = false;
3729             dragState().source = nullptr;
3730             // ... but if this was the first click in the window, we don&#39;t even want to start selection
3731             if (eventActivatedView(event.event()))
3732                 m_mouseDownMayStartSelect = false;
3733         } else {
3734             // Prevent the following case from occuring:
3735             // 1. User starts a drag immediately after mouse down over an unselectable element.
3736             // 2. We enter this block and decided that since we&#39;re over an unselectable element, don&#39;t cancel the drag.
3737             // 3. The drag gets resolved as a potential selection drag below /but/ we haven&#39;t exceeded the drag hysteresis yet.
3738             // 4. We enter this block again, and since it&#39;s now marked as a selection drag, we cancel the drag.
3739             m_dragMayStartSelectionInstead = false;
3740         }
3741     }
3742 
3743     if (!m_mouseDownMayStartDrag)
3744         return !mouseDownMayStartSelect() &amp;&amp; !m_mouseDownMayStartAutoscroll;
3745     ASSERT(dragState().source);
3746 
3747     if (!ExactlyOneBitSet(dragState().type)) {
3748         ASSERT(dragState().type &amp; DragSourceActionSelection);
3749         ASSERT(ExactlyOneBitSet(static_cast&lt;DragSourceAction&gt;(dragState().type &amp; ~DragSourceActionSelection)));
3750 
3751         dragState().type = DragSourceActionSelection;
3752     }
3753 
3754     // We are starting a text/image/url drag, so the cursor should be an arrow
3755     if (FrameView* view = m_frame.view()) {
3756         // FIXME &lt;rdar://7577595&gt;: Custom cursors aren&#39;t supported during drag and drop (default to pointer).
3757         view-&gt;setCursor(pointerCursor());
3758     }
3759 
3760     if (checkDragHysteresis == ShouldCheckDragHysteresis &amp;&amp; !dragHysteresisExceeded(event.event().position()))
3761         return true;
3762 
3763     // Once we&#39;re past the hysteresis point, we don&#39;t want to treat this gesture as a click
3764     invalidateClick();
3765 
3766     DragOperation srcOp = DragOperationNone;
3767 
3768     // This does work only if we missed a dragEnd. Do it anyway, just to make sure the old dataTransfer gets numbed.
3769     invalidateDataTransfer();
3770 
3771     dragState().dataTransfer = DataTransfer::createForDrag(*m_frame.document());
3772     HasNonDefaultPasteboardData hasNonDefaultPasteboardData = HasNonDefaultPasteboardData::No;
3773 
3774     if (dragState().shouldDispatchEvents) {
3775         ASSERT(dragState().source);
3776         auto dragStartDataTransfer = DataTransfer::createForDragStartEvent(dragState().source-&gt;document());
3777         m_mouseDownMayStartDrag = dispatchDragStartEventOnSourceElement(dragStartDataTransfer);
3778         hasNonDefaultPasteboardData = dragStartDataTransfer-&gt;pasteboard().hasData() ? HasNonDefaultPasteboardData::Yes : HasNonDefaultPasteboardData::No;
3779         dragState().dataTransfer-&gt;moveDragState(WTFMove(dragStartDataTransfer));
3780 
3781         if (dragState().source &amp;&amp; dragState().type == DragSourceActionDHTML &amp;&amp; !dragState().dataTransfer-&gt;hasDragImage()) {
3782             dragState().source-&gt;document().updateStyleIfNeeded();
3783             if (auto* renderer = dragState().source-&gt;renderer()) {
3784                 auto absolutePosition = renderer-&gt;localToAbsolute();
3785                 auto delta = m_mouseDownPos - roundedIntPoint(absolutePosition);
3786                 dragState().dataTransfer-&gt;setDragImage(dragState().source.get(), delta.width(), delta.height());
3787             } else {
3788                 dispatchDragSrcEvent(eventNames().dragendEvent, event.event());
3789                 m_mouseDownMayStartDrag = false;
3790                 invalidateDataTransfer();
3791                 dragState().source = nullptr;
3792                 return true;
3793             }
3794         }
3795 
3796         dragState().dataTransfer-&gt;makeInvalidForSecurity();
3797 
3798         if (m_mouseDownMayStartDrag) {
3799             // Gather values from DHTML element, if it set any.
3800             srcOp = dragState().dataTransfer-&gt;sourceOperation();
3801 
3802             // Yuck, a draggedImage:moveTo: message can be fired as a result of kicking off the
3803             // drag with dragImage! Because of that dumb reentrancy, we may think we&#39;ve not
3804             // started the drag when that happens. So we have to assume it&#39;s started before we kick it off.
3805             dragState().dataTransfer-&gt;setDragHasStarted();
3806         }
3807     }
3808 
3809     if (m_mouseDownMayStartDrag) {
3810         Page* page = m_frame.page();
3811         m_didStartDrag = page &amp;&amp; page-&gt;dragController().startDrag(m_frame, dragState(), srcOp, event.event(), m_mouseDownPos, hasNonDefaultPasteboardData);
3812         // In WebKit2 we could re-enter this code and start another drag.
3813         // On OS X this causes problems with the ownership of the pasteboard and the promised types.
3814         if (m_didStartDrag) {
3815             m_mouseDownMayStartDrag = false;
3816             return true;
3817         }
3818         if (dragState().source &amp;&amp; dragState().shouldDispatchEvents) {
3819             // Drag was canned at the last minute. We owe dragSource a dragend event.
3820             dispatchDragSrcEvent(eventNames().dragendEvent, event.event());
3821             m_mouseDownMayStartDrag = false;
3822         }
3823     }
3824 
3825     if (!m_mouseDownMayStartDrag) {
3826         // Something failed to start the drag, clean up.
3827         invalidateDataTransfer();
3828         dragState().source = nullptr;
3829     }
3830 
3831     // No more default handling (like selection), whether we&#39;re past the hysteresis bounds or not
3832     return true;
3833 }
3834 #endif // ENABLE(DRAG_SUPPORT)
3835 
3836 bool EventHandler::mouseMovementExceedsThreshold(const FloatPoint&amp; viewportLocation, int pointsThreshold) const
3837 {
3838     FrameView* view = m_frame.view();
3839     if (!view)
3840         return false;
3841     IntPoint location = view-&gt;windowToContents(flooredIntPoint(viewportLocation));
3842     IntSize delta = location - m_mouseDownPos;
3843 
3844     return abs(delta.width()) &gt;= pointsThreshold || abs(delta.height()) &gt;= pointsThreshold;
3845 }
3846 
3847 bool EventHandler::handleTextInputEvent(const String&amp; text, Event* underlyingEvent, TextEventInputType inputType)
3848 {
3849     LOG(Editing, &quot;EventHandler %p handleTextInputEvent (text %s)&quot;, this, text.utf8().data());
3850 
3851     // Platforms should differentiate real commands like selectAll from text input in disguise (like insertNewline),
3852     // and avoid dispatching text input events from keydown default handlers.
3853     ASSERT(!is&lt;KeyboardEvent&gt;(underlyingEvent) || downcast&lt;KeyboardEvent&gt;(*underlyingEvent).type() == eventNames().keypressEvent);
3854 
3855     Ref&lt;Frame&gt; protectedFrame(m_frame);
3856 
3857     EventTarget* target;
3858     if (underlyingEvent)
3859         target = underlyingEvent-&gt;target();
3860     else
3861         target = eventTargetElementForDocument(m_frame.document());
3862     if (!target)
3863         return false;
3864 
3865     if (FrameView* view = m_frame.view())
3866         view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
3867 
3868     auto event = TextEvent::create(&amp;m_frame.windowProxy(), text, inputType);
3869     event-&gt;setUnderlyingEvent(underlyingEvent);
3870 
3871     target-&gt;dispatchEvent(event);
3872     return event-&gt;defaultHandled();
3873 }
3874 
3875 bool EventHandler::isKeyboardOptionTab(KeyboardEvent&amp; event)
3876 {
3877     return (event.type() == eventNames().keydownEvent || event.type() == eventNames().keypressEvent)
3878         &amp;&amp; event.altKey()
3879         &amp;&amp; event.keyIdentifier() == &quot;U+0009&quot;;
3880 }
3881 
3882 bool EventHandler::eventInvertsTabsToLinksClientCallResult(KeyboardEvent&amp; event)
3883 {
3884 #if PLATFORM(COCOA)
3885     return isKeyboardOptionTab(event);
3886 #else
3887     UNUSED_PARAM(event);
3888     return false;
3889 #endif
3890 }
3891 
3892 bool EventHandler::tabsToLinks(KeyboardEvent* event) const
3893 {
3894     // FIXME: This function needs a better name. It can be called for keypresses other than Tab when spatial navigation is enabled.
3895 
3896     Page* page = m_frame.page();
3897     if (!page)
3898         return false;
3899 
3900     bool tabsToLinksClientCallResult = page-&gt;chrome().client().keyboardUIMode() &amp; KeyboardAccessTabsToLinks;
3901     return (event &amp;&amp; eventInvertsTabsToLinksClientCallResult(*event)) ? !tabsToLinksClientCallResult : tabsToLinksClientCallResult;
3902 }
3903 
3904 void EventHandler::defaultTextInputEventHandler(TextEvent&amp; event)
3905 {
3906     if (m_frame.editor().handleTextEvent(event))
3907         event.setDefaultHandled();
3908 }
3909 
3910 
3911 void EventHandler::defaultSpaceEventHandler(KeyboardEvent&amp; event)
3912 {
3913     Ref&lt;Frame&gt; protectedFrame(m_frame);
3914 
3915     ASSERT(event.type() == eventNames().keypressEvent);
3916 
3917     if (event.ctrlKey() || event.metaKey() || event.altKey() || event.altGraphKey())
3918         return;
3919 
3920     ScrollLogicalDirection direction = event.shiftKey() ? ScrollBlockDirectionBackward : ScrollBlockDirectionForward;
3921     if (logicalScrollOverflow(direction, ScrollByPage)) {
3922         event.setDefaultHandled();
3923         return;
3924     }
3925 
3926     FrameView* view = m_frame.view();
3927     if (!view)
3928         return;
3929 
3930     if (view-&gt;logicalScroll(direction, ScrollByPage))
3931         event.setDefaultHandled();
3932 }
3933 
3934 void EventHandler::defaultBackspaceEventHandler(KeyboardEvent&amp; event)
3935 {
3936     ASSERT(event.type() == eventNames().keydownEvent);
3937 
3938     if (event.ctrlKey() || event.metaKey() || event.altKey() || event.altGraphKey())
3939         return;
3940 
3941     if (!m_frame.editor().behavior().shouldNavigateBackOnBackspace())
3942         return;
3943 
3944     Page* page = m_frame.page();
3945     if (!page)
3946         return;
3947 
3948     if (!m_frame.settings().backspaceKeyNavigationEnabled())
3949         return;
3950 
3951     bool handledEvent = false;
3952 
3953     if (event.shiftKey())
3954         handledEvent = page-&gt;backForward().goForward();
3955     else
3956         handledEvent = page-&gt;backForward().goBack();
3957 
3958     if (handledEvent)
3959         event.setDefaultHandled();
3960 }
3961 
3962 
3963 void EventHandler::defaultArrowEventHandler(FocusDirection focusDirection, KeyboardEvent&amp; event)
3964 {
3965     ASSERT(event.type() == eventNames().keydownEvent);
3966 
3967     if (event.ctrlKey() || event.metaKey() || event.altGraphKey() || event.shiftKey())
3968         return;
3969 
3970     Page* page = m_frame.page();
3971     if (!page)
3972         return;
3973 
3974     if (!isSpatialNavigationEnabled(&amp;m_frame))
3975         return;
3976 
3977     // Arrows and other possible directional navigation keys can be used in design
3978     // mode editing.
3979     if (m_frame.document()-&gt;inDesignMode())
3980         return;
3981 
3982     if (page-&gt;focusController().advanceFocus(focusDirection, &amp;event))
3983         event.setDefaultHandled();
3984 }
3985 
3986 void EventHandler::defaultTabEventHandler(KeyboardEvent&amp; event)
3987 {
3988     Ref&lt;Frame&gt; protectedFrame(m_frame);
3989 
3990     ASSERT(event.type() == eventNames().keydownEvent);
3991 
3992     // We should only advance focus on tabs if no special modifier keys are held down.
3993     if (event.ctrlKey() || event.metaKey() || event.altGraphKey())
3994         return;
3995 
3996     Page* page = m_frame.page();
3997     if (!page)
3998         return;
3999     if (!page-&gt;tabKeyCyclesThroughElements())
4000         return;
4001 
4002     FocusDirection focusDirection = event.shiftKey() ? FocusDirectionBackward : FocusDirectionForward;
4003 
4004     // Tabs can be used in design mode editing.
4005     if (m_frame.document()-&gt;inDesignMode())
4006         return;
4007 
4008     if (page-&gt;focusController().advanceFocus(focusDirection, &amp;event))
4009         event.setDefaultHandled();
4010 }
4011 
4012 void EventHandler::sendScrollEvent()
4013 {
4014     Ref&lt;Frame&gt; protectedFrame(m_frame);
4015     setFrameWasScrolledByUser();
4016     if (m_frame.view() &amp;&amp; m_frame.document())
4017         m_frame.document()-&gt;eventQueue().enqueueOrDispatchScrollEvent(*m_frame.document());
4018 }
4019 
4020 void EventHandler::setFrameWasScrolledByUser()
4021 {
4022     FrameView* v = m_frame.view();
4023     if (v)
4024         v-&gt;setWasScrolledByUser(true);
4025 }
4026 
4027 bool EventHandler::passMousePressEventToScrollbar(MouseEventWithHitTestResults&amp; mouseEvent, Scrollbar* scrollbar)
4028 {
4029     if (!scrollbar || !scrollbar-&gt;enabled())
4030         return false;
4031     setFrameWasScrolledByUser();
4032     return scrollbar-&gt;mouseDown(mouseEvent.event());
4033 }
4034 
4035 // If scrollbar (under mouse) is different from last, send a mouse exited.
4036 void EventHandler::updateLastScrollbarUnderMouse(Scrollbar* scrollbar, SetOrClearLastScrollbar setOrClear)
4037 {
4038     if (m_lastScrollbarUnderMouse != scrollbar) {
4039         // Send mouse exited to the old scrollbar.
4040         if (m_lastScrollbarUnderMouse)
4041             m_lastScrollbarUnderMouse-&gt;mouseExited();
4042 
4043         // Send mouse entered if we&#39;re setting a new scrollbar.
4044         if (scrollbar &amp;&amp; setOrClear == SetOrClearLastScrollbar::Set) {
4045             scrollbar-&gt;mouseEntered();
4046             m_lastScrollbarUnderMouse = makeWeakPtr(*scrollbar);
4047         } else
4048             m_lastScrollbarUnderMouse = nullptr;
4049     }
4050 }
4051 
4052 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
4053 static const AtomString&amp; eventNameForTouchPointState(PlatformTouchPoint::State state)
4054 {
4055     switch (state) {
4056     case PlatformTouchPoint::TouchReleased:
4057         return eventNames().touchendEvent;
4058     case PlatformTouchPoint::TouchCancelled:
4059         return eventNames().touchcancelEvent;
4060     case PlatformTouchPoint::TouchPressed:
4061         return eventNames().touchstartEvent;
4062     case PlatformTouchPoint::TouchMoved:
4063         return eventNames().touchmoveEvent;
4064     case PlatformTouchPoint::TouchStationary:
4065         // TouchStationary state is not converted to touch events, so fall through to assert.
4066     default:
4067         ASSERT_NOT_REACHED();
4068         return emptyAtom();
4069     }
4070 }
4071 
4072 static HitTestResult hitTestResultInFrame(Frame* frame, const LayoutPoint&amp; point, HitTestRequest::HitTestRequestType hitType)
4073 {
4074     HitTestResult result(point);
4075 
4076     if (!frame || !frame-&gt;contentRenderer())
4077         return result;
4078 
4079     if (frame-&gt;view()) {
4080         IntRect rect = frame-&gt;view()-&gt;visibleContentRect();
4081         if (!rect.contains(roundedIntPoint(point)))
4082             return result;
4083     }
4084     frame-&gt;document()-&gt;hitTest(HitTestRequest(hitType), result);
4085     return result;
4086 }
4087 
4088 bool EventHandler::handleTouchEvent(const PlatformTouchEvent&amp; event)
4089 {
4090     Ref&lt;Frame&gt; protectedFrame(m_frame);
4091 
4092     // First build up the lists to use for the &#39;touches&#39;, &#39;targetTouches&#39; and &#39;changedTouches&#39; attributes
4093     // in the JS event. See http://www.sitepen.com/blog/2008/07/10/touching-and-gesturing-on-the-iphone/
4094     // for an overview of how these lists fit together.
4095 
4096     // Holds the complete set of touches on the screen and will be used as the &#39;touches&#39; list in the JS event.
4097     RefPtr&lt;TouchList&gt; touches = TouchList::create();
4098 
4099     // A different view on the &#39;touches&#39; list above, filtered and grouped by event target. Used for the
4100     // &#39;targetTouches&#39; list in the JS event.
4101     typedef HashMap&lt;EventTarget*, RefPtr&lt;TouchList&gt;&gt; TargetTouchesMap;
4102     TargetTouchesMap touchesByTarget;
4103 
4104     // Array of touches per state, used to assemble the &#39;changedTouches&#39; list in the JS event.
4105     typedef HashSet&lt;RefPtr&lt;EventTarget&gt;&gt; EventTargetSet;
4106     struct {
4107         // The touches corresponding to the particular change state this struct instance represents.
4108         RefPtr&lt;TouchList&gt; m_touches;
4109         // Set of targets involved in m_touches.
4110         EventTargetSet m_targets;
4111     } changedTouches[PlatformTouchPoint::TouchStateEnd];
4112 
4113     const Vector&lt;PlatformTouchPoint&gt;&amp; points = event.touchPoints();
4114 
4115     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document());
4116 
4117     bool freshTouchEvents = true;
4118     bool allTouchReleased = true;
4119     for (auto&amp; point : points) {
4120         if (point.state() != PlatformTouchPoint::TouchPressed)
4121             freshTouchEvents = false;
4122         if (point.state() != PlatformTouchPoint::TouchReleased &amp;&amp; point.state() != PlatformTouchPoint::TouchCancelled)
4123             allTouchReleased = false;
4124     }
4125 
4126     for (auto&amp; point : points) {
4127         PlatformTouchPoint::State pointState = point.state();
4128         LayoutPoint pagePoint = documentPointForWindowPoint(m_frame, point.pos());
4129 
4130         HitTestRequest::HitTestRequestType hitType = HitTestRequest::TouchEvent;
4131         // The HitTestRequest types used for mouse events map quite adequately
4132         // to touch events. Note that in addition to meaning that the hit test
4133         // should affect the active state of the current node if necessary,
4134         // HitTestRequest::Active signifies that the hit test is taking place
4135         // with the mouse (or finger in this case) being pressed.
4136         switch (pointState) {
4137         case PlatformTouchPoint::TouchPressed:
4138             hitType |= HitTestRequest::Active;
4139             break;
4140         case PlatformTouchPoint::TouchMoved:
4141             hitType |= HitTestRequest::Active | HitTestRequest::Move | HitTestRequest::ReadOnly;
4142             break;
4143         case PlatformTouchPoint::TouchReleased:
4144         case PlatformTouchPoint::TouchCancelled:
4145             hitType |= HitTestRequest::Release;
4146             break;
4147         case PlatformTouchPoint::TouchStationary:
4148             hitType |= HitTestRequest::Active | HitTestRequest::ReadOnly;
4149             break;
4150         default:
4151             ASSERT_NOT_REACHED();
4152             break;
4153         }
4154 
4155         if (shouldGesturesTriggerActive())
4156             hitType |= HitTestRequest::ReadOnly;
4157 
4158         // Increment the platform touch id by 1 to avoid storing a key of 0 in the hashmap.
4159         unsigned touchPointTargetKey = point.id() + 1;
4160         RefPtr&lt;EventTarget&gt; touchTarget;
4161         if (pointState == PlatformTouchPoint::TouchPressed) {
4162             HitTestResult result;
4163             if (freshTouchEvents) {
4164                 result = hitTestResultAtPoint(pagePoint, hitType | HitTestRequest::AllowChildFrameContent);
4165                 m_originatingTouchPointTargetKey = touchPointTargetKey;
4166             } else if (m_originatingTouchPointDocument.get() &amp;&amp; m_originatingTouchPointDocument-&gt;frame()) {
4167                 LayoutPoint pagePointInOriginatingDocument = documentPointForWindowPoint(*m_originatingTouchPointDocument-&gt;frame(), point.pos());
4168                 result = hitTestResultInFrame(m_originatingTouchPointDocument-&gt;frame(), pagePointInOriginatingDocument, hitType);
4169                 if (!result.innerNode())
4170                     continue;
4171             } else
4172                 continue;
4173 
4174             Element* element = result.targetElement();
4175             ASSERT(element);
4176 
4177             if (element &amp;&amp; InspectorInstrumentation::handleTouchEvent(m_frame, *element))
4178                 return true;
4179 
4180             Document&amp; doc = element-&gt;document();
4181             // Record the originating touch document even if it does not have a touch listener.
4182             if (freshTouchEvents) {
4183                 m_originatingTouchPointDocument = &amp;doc;
4184                 freshTouchEvents = false;
4185             }
4186             if (!doc.hasTouchEventHandlers())
4187                 continue;
4188             m_originatingTouchPointTargets.set(touchPointTargetKey, element);
4189             touchTarget = element;
4190         } else if (pointState == PlatformTouchPoint::TouchReleased || pointState == PlatformTouchPoint::TouchCancelled) {
4191             // No need to perform a hit-test since we only need to unset :hover and :active states.
4192             if (!shouldGesturesTriggerActive() &amp;&amp; allTouchReleased)
4193                 m_frame.document()-&gt;updateHoverActiveState(hitType, 0);
4194             if (touchPointTargetKey == m_originatingTouchPointTargetKey)
4195                 m_originatingTouchPointTargetKey = 0;
4196 
4197             // The target should be the original target for this touch, so get it from the hashmap. As it&#39;s a release or cancel
4198             // we also remove it from the map.
4199             touchTarget = m_originatingTouchPointTargets.take(touchPointTargetKey);
4200         } else
4201             // No hittest is performed on move or stationary, since the target is not allowed to change anyway.
4202             touchTarget = m_originatingTouchPointTargets.get(touchPointTargetKey);
4203 
4204         if (!is&lt;Node&gt;(touchTarget))
4205             continue;
4206         auto&amp; document = downcast&lt;Node&gt;(*touchTarget).document();
4207         if (!document.hasTouchEventHandlers())
4208             continue;
4209         auto* targetFrame = document.frame();
4210         if (!targetFrame)
4211             continue;
4212 
4213         if (&amp;m_frame != targetFrame) {
4214             // pagePoint should always be relative to the target elements containing frame.
4215             pagePoint = documentPointForWindowPoint(*targetFrame, point.pos());
4216         }
4217 
4218         float scaleFactor = targetFrame-&gt;pageZoomFactor() * targetFrame-&gt;frameScaleFactor();
4219 
4220         int adjustedPageX = lroundf(pagePoint.x() / scaleFactor);
4221         int adjustedPageY = lroundf(pagePoint.y() / scaleFactor);
4222 
4223         auto touch = Touch::create(targetFrame, touchTarget.get(), point.id(),
4224             point.screenPos().x(), point.screenPos().y(), adjustedPageX, adjustedPageY,
4225             point.radiusX(), point.radiusY(), point.rotationAngle(), point.force());
4226 
4227         // Ensure this target&#39;s touch list exists, even if it ends up empty, so it can always be passed to TouchEvent::Create below.
4228         TargetTouchesMap::iterator targetTouchesIterator = touchesByTarget.find(touchTarget.get());
4229         if (targetTouchesIterator == touchesByTarget.end())
4230             targetTouchesIterator = touchesByTarget.set(touchTarget.get(), TouchList::create()).iterator;
4231 
4232         // touches and targetTouches should only contain information about touches still on the screen, so if this point is
4233         // released or cancelled it will only appear in the changedTouches list.
4234         if (pointState != PlatformTouchPoint::TouchReleased &amp;&amp; pointState != PlatformTouchPoint::TouchCancelled) {
4235             touches-&gt;append(touch.copyRef());
4236             targetTouchesIterator-&gt;value-&gt;append(touch.copyRef());
4237         }
4238 
4239         // Now build up the correct list for changedTouches.
4240         // Note that  any touches that are in the TouchStationary state (e.g. if
4241         // the user had several points touched but did not move them all) should
4242         // never be in the changedTouches list so we do not handle them explicitly here.
4243         // See https://bugs.webkit.org/show_bug.cgi?id=37609 for further discussion
4244         // about the TouchStationary state.
4245         if (pointState != PlatformTouchPoint::TouchStationary) {
4246             ASSERT(pointState &lt; PlatformTouchPoint::TouchStateEnd);
4247             if (!changedTouches[pointState].m_touches)
4248                 changedTouches[pointState].m_touches = TouchList::create();
4249             changedTouches[pointState].m_touches-&gt;append(WTFMove(touch));
4250             changedTouches[pointState].m_targets.add(touchTarget);
4251         }
4252     }
4253     m_touchPressed = touches-&gt;length() &gt; 0;
4254     if (allTouchReleased)
4255         m_originatingTouchPointDocument = nullptr;
4256 
4257     // Now iterate the changedTouches list and m_targets within it, sending events to the targets as required.
4258     bool swallowedEvent = false;
4259     RefPtr&lt;TouchList&gt; emptyList = TouchList::create();
4260     for (unsigned state = 0; state != PlatformTouchPoint::TouchStateEnd; ++state) {
4261         if (!changedTouches[state].m_touches)
4262             continue;
4263 
4264         // When sending a touch cancel event, use empty touches and targetTouches lists.
4265         bool isTouchCancelEvent = (state == PlatformTouchPoint::TouchCancelled);
4266         RefPtr&lt;TouchList&gt;&amp; effectiveTouches(isTouchCancelEvent ? emptyList : touches);
4267         const AtomString&amp; stateName(eventNameForTouchPointState(static_cast&lt;PlatformTouchPoint::State&gt;(state)));
4268 
4269         for (auto&amp; target : changedTouches[state].m_targets) {
4270             ASSERT(is&lt;Node&gt;(target));
4271 
4272             RefPtr&lt;TouchList&gt; targetTouches(isTouchCancelEvent ? emptyList : touchesByTarget.get(target.get()));
4273             ASSERT(targetTouches);
4274 
4275             Ref&lt;TouchEvent&gt; touchEvent = TouchEvent::create(effectiveTouches.get(), targetTouches.get(), changedTouches[state].m_touches.get(),
4276                 stateName, downcast&lt;Node&gt;(*target).document().windowProxy(), { }, event.modifiers());
4277             target-&gt;dispatchEvent(touchEvent);
4278             swallowedEvent = swallowedEvent || touchEvent-&gt;defaultPrevented() || touchEvent-&gt;defaultHandled();
4279         }
4280     }
4281 
4282     return swallowedEvent;
4283 }
4284 #endif // ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
4285 
4286 #if ENABLE(TOUCH_EVENTS)
4287 bool EventHandler::dispatchSyntheticTouchEventIfEnabled(const PlatformMouseEvent&amp; platformMouseEvent)
4288 {
4289 #if ENABLE(IOS_TOUCH_EVENTS)
4290     UNUSED_PARAM(platformMouseEvent);
4291     return false;
4292 #else
4293     if (!m_frame.settings().isTouchEventEmulationEnabled())
4294         return false;
4295 
4296     PlatformEvent::Type eventType = platformMouseEvent.type();
4297     if (eventType != PlatformEvent::MouseMoved &amp;&amp; eventType != PlatformEvent::MousePressed &amp;&amp; eventType != PlatformEvent::MouseReleased)
4298         return false;
4299 
4300     HitTestRequest request(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent);
4301     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, platformMouseEvent);
4302     if (mouseEvent.scrollbar() || subframeForHitTestResult(mouseEvent))
4303         return false;
4304 
4305     // The order is important. This check should follow the subframe test: http://webkit.org/b/111292.
4306     if (eventType == PlatformEvent::MouseMoved &amp;&amp; !m_touchPressed)
4307         return true;
4308 
4309     SyntheticSingleTouchEvent touchEvent(platformMouseEvent);
4310     return handleTouchEvent(touchEvent);
4311 #endif
4312 }
4313 #endif // ENABLE(TOUCH_EVENTS)
4314 
4315 void EventHandler::setLastKnownMousePosition(const PlatformMouseEvent&amp; event)
4316 {
4317     m_mousePositionIsUnknown = false;
4318     m_lastKnownMousePosition = event.position();
4319     m_lastKnownMouseGlobalPosition = event.globalPosition();
4320 }
4321 
4322 void EventHandler::setImmediateActionStage(ImmediateActionStage stage)
4323 {
4324     m_immediateActionStage = stage;
4325 }
4326 
4327 #if !PLATFORM(COCOA)
4328 OptionSet&lt;PlatformEvent::Modifier&gt; EventHandler::accessKeyModifiers()
4329 {
4330     return PlatformEvent::Modifier::AltKey;
4331 }
4332 
4333 bool EventHandler::passMousePressEventToSubframe(MouseEventWithHitTestResults&amp; mev, Frame* subframe)
4334 {
4335     subframe-&gt;eventHandler().handleMousePressEvent(mev.event());
4336     return true;
4337 }
4338 
4339 bool EventHandler::passMouseReleaseEventToSubframe(MouseEventWithHitTestResults&amp; mev, Frame* subframe)
4340 {
4341     subframe-&gt;eventHandler().handleMouseReleaseEvent(mev.event());
4342     return true;
4343 }
4344 
4345 bool EventHandler::widgetDidHandleWheelEvent(const PlatformWheelEvent&amp; event, Widget&amp; widget)
4346 {
4347     if (!is&lt;FrameView&gt;(widget))
4348         return false;
4349 
4350     return downcast&lt;FrameView&gt;(widget).frame().eventHandler().handleWheelEvent(event);
4351 }
4352 
4353 bool EventHandler::tabsToAllFormControls(KeyboardEvent*) const
4354 {
4355     // We always allow tabs to all controls
4356     return true;
4357 }
4358 
4359 bool EventHandler::passWidgetMouseDownEventToWidget(RenderWidget* renderWidget)
4360 {
4361     return passMouseDownEventToWidget(renderWidget-&gt;widget());
4362 }
4363 
4364 bool EventHandler::passWidgetMouseDownEventToWidget(const MouseEventWithHitTestResults&amp; event)
4365 {
4366     // Figure out which view to send the event to.
4367     RenderObject* target = event.targetNode() ? event.targetNode()-&gt;renderer() : nullptr;
4368     if (!is&lt;RenderWidget&gt;(target))
4369         return false;
4370     return passMouseDownEventToWidget(downcast&lt;RenderWidget&gt;(*target).widget());
4371 }
4372 
4373 bool EventHandler::passMouseDownEventToWidget(Widget*)
4374 {
4375     notImplemented();
4376     return false;
4377 }
4378 
4379 void EventHandler::focusDocumentView()
4380 {
4381     if (Page* page = m_frame.page())
4382         page-&gt;focusController().setFocusedFrame(&amp;m_frame);
4383 }
4384 #endif // !PLATFORM(COCOA)
4385 
4386 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(WIN) &amp;&amp; !PLATFORM(JAVA)
4387 bool EventHandler::eventActivatedView(const PlatformMouseEvent&amp;) const
4388 {
4389     notImplemented();
4390     return false;
4391 }
4392 
4393 bool EventHandler::passMouseMoveEventToSubframe(MouseEventWithHitTestResults&amp; mev, Frame* subframe, HitTestResult* hoveredNode)
4394 {
4395     subframe-&gt;eventHandler().handleMouseMoveEvent(mev.event(), hoveredNode);
4396     return true;
4397 }
4398 #endif // !PLATFORM(COCOA) &amp;&amp; !PLATFORM(WIN)
4399 
4400 } // namespace WebCore
    </pre>
  </body>
</html>