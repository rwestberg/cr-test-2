<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AXObjectCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../WebCorePrefix.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AXObjectCache.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AXObjectCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
<span class="line-modified">  31 #if HAVE(ACCESSIBILITY)</span>
  32 
  33 #include &quot;AXObjectCache.h&quot;
  34 
  35 #include &quot;AXIsolatedTree.h&quot;
  36 #include &quot;AXIsolatedTreeNode.h&quot;
  37 #include &quot;AccessibilityARIAGrid.h&quot;
  38 #include &quot;AccessibilityARIAGridCell.h&quot;
  39 #include &quot;AccessibilityARIAGridRow.h&quot;
  40 #include &quot;AccessibilityAttachment.h&quot;
  41 #include &quot;AccessibilityImageMapLink.h&quot;
  42 #include &quot;AccessibilityLabel.h&quot;
  43 #include &quot;AccessibilityList.h&quot;
  44 #include &quot;AccessibilityListBox.h&quot;
  45 #include &quot;AccessibilityListBoxOption.h&quot;
  46 #include &quot;AccessibilityMathMLElement.h&quot;
  47 #include &quot;AccessibilityMediaControls.h&quot;
  48 #include &quot;AccessibilityMediaObject.h&quot;
  49 #include &quot;AccessibilityMenuList.h&quot;
  50 #include &quot;AccessibilityMenuListOption.h&quot;
  51 #include &quot;AccessibilityMenuListPopup.h&quot;
</pre>
<hr />
<pre>
 834     // an AccessibilityRenderObject, because it was reparented to a location outside of a canvas.
 835     get(node);
 836 }
 837 
 838 void AXObjectCache::handleMenuOpened(Node* node)
 839 {
 840     if (!node || !node-&gt;renderer() || !nodeHasRole(node, &quot;menu&quot;))
 841         return;
 842 
 843     postNotification(getOrCreate(node), &amp;document(), AXMenuOpened);
 844 }
 845 
 846 void AXObjectCache::handleLiveRegionCreated(Node* node)
 847 {
 848     if (!is&lt;Element&gt;(node) || !node-&gt;renderer())
 849         return;
 850 
 851     Element* element = downcast&lt;Element&gt;(node);
 852     String liveRegionStatus = element-&gt;attributeWithoutSynchronization(aria_liveAttr);
 853     if (liveRegionStatus.isEmpty()) {
<span class="line-modified"> 854         const AtomicString&amp; ariaRole = element-&gt;attributeWithoutSynchronization(roleAttr);</span>
 855         if (!ariaRole.isEmpty())
 856             liveRegionStatus = AccessibilityObject::defaultLiveRegionStatusForRole(AccessibilityObject::ariaRoleToWebCoreRole(ariaRole));
 857     }
 858 
 859     if (AccessibilityObject::liveRegionStatusIsEnabled(liveRegionStatus))
 860         postNotification(getOrCreate(node), &amp;document(), AXLiveRegionCreated);
 861 }
 862 
 863 void AXObjectCache::childrenChanged(Node* node, Node* newChild)
 864 {
 865     if (newChild)
 866         m_deferredChildrenChangedNodeList.add(newChild);
 867 
 868     childrenChanged(get(node));
 869 }
 870 
 871 void AXObjectCache::childrenChanged(RenderObject* renderer, RenderObject* newChild)
 872 {
 873     if (!renderer)
 874         return;
</pre>
<hr />
<pre>
1558 
1559     startCachingComputedObjectAttributesUntilTreeMutates();
1560 }
1561 
1562 void AXObjectCache::labelChanged(Element* element)
1563 {
1564     ASSERT(is&lt;HTMLLabelElement&gt;(*element));
1565     auto correspondingControl = downcast&lt;HTMLLabelElement&gt;(*element).control();
1566     deferTextChangedIfNeeded(correspondingControl.get());
1567 }
1568 
1569 void AXObjectCache::recomputeIsIgnored(RenderObject* renderer)
1570 {
1571     if (AccessibilityObject* obj = get(renderer))
1572         obj-&gt;notifyIfIgnoredValueChanged();
1573 }
1574 
1575 void AXObjectCache::startCachingComputedObjectAttributesUntilTreeMutates()
1576 {
1577     if (!m_computedObjectAttributeCache)
<span class="line-modified">1578         m_computedObjectAttributeCache = std::make_unique&lt;AXComputedObjectAttributeCache&gt;();</span>
1579 }
1580 
1581 void AXObjectCache::stopCachingComputedObjectAttributes()
1582 {
1583     m_computedObjectAttributeCache = nullptr;
1584 }
1585 
1586 VisiblePosition AXObjectCache::visiblePositionForTextMarkerData(TextMarkerData&amp; textMarkerData)
1587 {
1588     if (!isNodeInUse(textMarkerData.node))
1589         return VisiblePosition();
1590 
1591     // FIXME: Accessability should make it clear these are DOM-compliant offsets or store Position objects.
1592     VisiblePosition visiblePos = VisiblePosition(createLegacyEditingPosition(textMarkerData.node, textMarkerData.offset), textMarkerData.affinity);
1593     Position deepPos = visiblePos.deepEquivalent();
1594     if (deepPos.isNull())
1595         return VisiblePosition();
1596 
1597     RenderObject* renderer = deepPos.deprecatedNode()-&gt;renderer();
1598     if (!renderer)
</pre>
<hr />
<pre>
1768 
1769     return length;
1770 }
1771 
1772 RefPtr&lt;Range&gt; AXObjectCache::rangeForNodeContents(Node* node)
1773 {
1774     if (!node)
1775         return nullptr;
1776     Document* document = &amp;node-&gt;document();
1777     if (!document)
1778         return nullptr;
1779     auto range = Range::create(*document);
1780     if (AccessibilityObject::replacedNodeNeedsCharacter(node)) {
1781         // For replaced nodes without children, the node itself is included in the range.
1782         if (range-&gt;selectNode(*node).hasException())
1783             return nullptr;
1784     } else {
1785         if (range-&gt;selectNodeContents(*node).hasException())
1786             return nullptr;
1787     }
<span class="line-modified">1788     return WTFMove(range);</span>
1789 }
1790 
1791 RefPtr&lt;Range&gt; AXObjectCache::rangeMatchesTextNearRange(RefPtr&lt;Range&gt; originalRange, const String&amp; matchText)
1792 {
1793     if (!originalRange)
1794         return nullptr;
1795 
1796     // Create a large enough range for searching the text within.
1797     unsigned textLength = matchText.length();
1798     auto startPosition = visiblePositionForPositionWithOffset(originalRange-&gt;startPosition(), -textLength);
1799     auto endPosition = visiblePositionForPositionWithOffset(originalRange-&gt;startPosition(), 2 * textLength);
1800 
1801     if (startPosition.isNull())
1802         startPosition = firstPositionInOrBeforeNode(&amp;originalRange-&gt;startContainer());
1803     if (endPosition.isNull())
1804         endPosition = lastPositionInOrAfterNode(&amp;originalRange-&gt;endContainer());
1805 
1806     auto searchRange = Range::create(m_document, startPosition, endPosition);
1807     if (searchRange-&gt;collapsed())
1808         return nullptr;
</pre>
<hr />
<pre>
1889             return false;
1890     }
1891 
1892     return true;
1893 }
1894 
1895 RefPtr&lt;Range&gt; AXObjectCache::rangeForUnorderedCharacterOffsets(const CharacterOffset&amp; characterOffset1, const CharacterOffset&amp; characterOffset2)
1896 {
1897     if (characterOffset1.isNull() || characterOffset2.isNull())
1898         return nullptr;
1899 
1900     bool alreadyInOrder = characterOffsetsInOrder(characterOffset1, characterOffset2);
1901     CharacterOffset startCharacterOffset = alreadyInOrder ? characterOffset1 : characterOffset2;
1902     CharacterOffset endCharacterOffset = alreadyInOrder ? characterOffset2 : characterOffset1;
1903 
1904     auto result = Range::create(m_document);
1905     if (!setRangeStartOrEndWithCharacterOffset(result, startCharacterOffset, true))
1906         return nullptr;
1907     if (!setRangeStartOrEndWithCharacterOffset(result, endCharacterOffset, false))
1908         return nullptr;
<span class="line-modified">1909     return WTFMove(result);</span>
1910 }
1911 
1912 void AXObjectCache::setTextMarkerDataWithCharacterOffset(TextMarkerData&amp; textMarkerData, const CharacterOffset&amp; characterOffset)
1913 {
1914     if (characterOffset.isNull())
1915         return;
1916 
1917     Node* domNode = characterOffset.node;
1918     if (is&lt;HTMLInputElement&gt;(*domNode) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*domNode).isPasswordField()) {
1919         textMarkerData.ignored = true;
1920         return;
1921     }
1922 
1923     RefPtr&lt;AccessibilityObject&gt; obj = this-&gt;getOrCreate(domNode);
1924     if (!obj)
1925         return;
1926 
1927     // Convert to visible position.
1928     VisiblePosition visiblePosition = visiblePositionFromCharacterOffset(characterOffset);
1929     int vpOffset = 0;
</pre>
<hr />
<pre>
2458     TextIterator it(searchRange.get(), TextIteratorEmitsObjectReplacementCharacters);
2459     unsigned next = forwardSearchForBoundaryWithTextIterator(it, string, prefixLength, searchFunction);
2460 
2461     if (it.atEnd() &amp;&amp; next == string.size())
2462         return end;
2463 
2464     // We should consider the node boundary that splits words.
2465     if (searchFunction == endWordBoundary &amp;&amp; next - prefixLength == 1)
2466         return nextCharacterOffset(characterOffset, false);
2467 
2468     // The endSentenceBoundary function will include a line break at the end of the sentence.
2469     if (searchFunction == endSentenceBoundary &amp;&amp; string[next - 1] == &#39;\n&#39;)
2470         next--;
2471 
2472     if (next &gt; prefixLength)
2473         return characterOffsetForNodeAndOffset(*characterOffset.node, characterOffset.offset + next - prefixLength);
2474 
2475     return characterOffset;
2476 }
2477 
<span class="line-modified">2478 CharacterOffset AXObjectCache::previousBoundary(const CharacterOffset&amp; characterOffset, BoundarySearchFunction searchFunction)</span>

2479 {
2480     if (characterOffset.isNull())
2481         return CharacterOffset();
2482 
2483     Node* boundary = parentEditingBoundary(characterOffset.node);
2484     if (!boundary)
2485         return CharacterOffset();
2486 
2487     RefPtr&lt;Range&gt; searchRange = rangeForNodeContents(boundary);
2488     Vector&lt;UChar, 1024&gt; string;
2489     unsigned suffixLength = 0;
2490 
<span class="line-modified">2491     if (requiresContextForWordBoundary(characterBefore(characterOffset))) {</span>










2492         auto forwardsScanRange = boundary-&gt;document().createRange();
2493         if (forwardsScanRange-&gt;setEndAfter(*boundary).hasException())
2494             return { };
2495         if (!setRangeStartOrEndWithCharacterOffset(forwardsScanRange, characterOffset, true))
2496             return { };
2497         suffixLength = suffixLengthForRange(forwardsScanRange, string);
2498     }
2499 
2500     if (!setRangeStartOrEndWithCharacterOffset(*searchRange, characterOffset, false))
2501         return { };
2502     CharacterOffset start = startOrEndCharacterOffsetForRange(searchRange, true);
2503 
2504     SimplifiedBackwardsTextIterator it(*searchRange);
2505     unsigned next = backwardSearchForBoundaryWithTextIterator(it, string, suffixLength, searchFunction);
2506 
2507     if (!next)
2508         return it.atEnd() ? start : characterOffset;
2509 
2510     Node&amp; node = it.atEnd() ? searchRange-&gt;startContainer() : it.range()-&gt;startContainer();
2511 
2512     // SimplifiedBackwardsTextIterator ignores replaced elements.
2513     if (AccessibilityObject::replacedNodeNeedsCharacter(characterOffset.node))
2514         return characterOffsetForNodeAndOffset(*characterOffset.node, 0);
2515     Node* nextSibling = node.nextSibling();
2516     if (&amp;node != characterOffset.node &amp;&amp; AccessibilityObject::replacedNodeNeedsCharacter(nextSibling))
2517         return startOrEndCharacterOffsetForRange(rangeForNodeContents(nextSibling), false);
2518 
<span class="line-modified">2519     if ((node.isTextNode() &amp;&amp; static_cast&lt;int&gt;(next) &lt;= node.maxCharacterOffset()) || (node.renderer() &amp;&amp; node.renderer()-&gt;isBR() &amp;&amp; !next)) {</span>
2520         // The next variable contains a usable index into a text node
2521         if (node.isTextNode())
2522             return traverseToOffsetInRange(rangeForNodeContents(&amp;node), next, TraverseOptionValidateOffset);
2523         return characterOffsetForNodeAndOffset(node, next, TraverseOptionIncludeStart);
2524     }
2525 
<span class="line-modified">2526     int characterCount = characterOffset.offset - (string.size() - suffixLength - next);</span>


2527     // We don&#39;t want to go to the previous node if the node is at the start of a new line.
2528     if (characterCount &lt; 0 &amp;&amp; (characterOffsetNodeIsBR(characterOffset) || string[string.size() - suffixLength - 1] == &#39;\n&#39;))
2529         characterCount = 0;
2530     return characterOffsetForNodeAndOffset(*characterOffset.node, characterCount, TraverseOptionIncludeStart);
2531 }
2532 
2533 CharacterOffset AXObjectCache::startCharacterOffsetOfParagraph(const CharacterOffset&amp; characterOffset, EditingBoundaryCrossingRule boundaryCrossingRule)
2534 {
2535     if (characterOffset.isNull())
2536         return CharacterOffset();
2537 
2538     auto* startNode = characterOffset.node;
2539 
2540     if (isRenderedAsNonInlineTableImageOrHR(startNode))
2541         return startOrEndCharacterOffsetForRange(rangeForNodeContents(startNode), true);
2542 
2543     auto* startBlock = enclosingBlock(startNode);
2544     int offset = characterOffset.startIndex + characterOffset.offset;
2545     auto* highestRoot = highestEditableRoot(firstPositionInOrBeforeNode(startNode));
2546     Position::AnchorType type = Position::PositionIsOffsetInAnchor;
</pre>
<hr />
<pre>
2596     if (characterOffsetNodeIsBR(next) &amp;&amp; !characterOffsetNodeIsBR(characterOffset))
2597         next = nextCharacterOffset(next);
2598 
2599     return endCharacterOffsetOfParagraph(next);
2600 }
2601 
2602 CharacterOffset AXObjectCache::previousParagraphStartCharacterOffset(const CharacterOffset&amp; characterOffset)
2603 {
2604     // make sure we move off of a paragraph start
2605     CharacterOffset previous = previousCharacterOffset(characterOffset);
2606 
2607     // We should skip the preceding BR node.
2608     if (characterOffsetNodeIsBR(previous) &amp;&amp; !characterOffsetNodeIsBR(characterOffset))
2609         previous = previousCharacterOffset(previous);
2610 
2611     return startCharacterOffsetOfParagraph(previous);
2612 }
2613 
2614 CharacterOffset AXObjectCache::startCharacterOffsetOfSentence(const CharacterOffset&amp; characterOffset)
2615 {
<span class="line-modified">2616     return previousBoundary(characterOffset, startSentenceBoundary);</span>
2617 }
2618 
2619 CharacterOffset AXObjectCache::endCharacterOffsetOfSentence(const CharacterOffset&amp; characterOffset)
2620 {
2621     return nextBoundary(characterOffset, endSentenceBoundary);
2622 }
2623 
2624 RefPtr&lt;Range&gt; AXObjectCache::sentenceForCharacterOffset(const CharacterOffset&amp; characterOffset)
2625 {
2626     CharacterOffset start = startCharacterOffsetOfSentence(characterOffset);
2627     CharacterOffset end = endCharacterOffsetOfSentence(start);
2628     return rangeForUnorderedCharacterOffsets(start, end);
2629 }
2630 
2631 CharacterOffset AXObjectCache::nextSentenceEndCharacterOffset(const CharacterOffset&amp; characterOffset)
2632 {
2633     // Make sure we move off of a sentence end.
2634     return endCharacterOffsetOfSentence(nextCharacterOffset(characterOffset));
2635 }
2636 
</pre>
<hr />
<pre>
2935     associateIsolatedTreeNode(object, isolatedTreeNode, tree.treeIdentifier());
2936 
2937     for (auto child : object.children()) {
2938         auto staticChild = createIsolatedAccessibilityTreeHierarchy(*child, isolatedTreeNode-&gt;identifier(), tree, nodeChanges);
2939         isolatedTreeNode-&gt;appendChild(staticChild-&gt;identifier());
2940     }
2941 
2942     return isolatedTreeNode;
2943 }
2944 
2945 Ref&lt;AXIsolatedTree&gt; AXObjectCache::generateIsolatedAccessibilityTree()
2946 {
2947     RELEASE_ASSERT(isMainThread());
2948 
2949     auto tree = AXIsolatedTree::treeForPageID(*m_document.pageID());
2950     if (!tree)
2951         tree = AXIsolatedTree::createTreeForPageID(*m_document.pageID());
2952 
2953     Vector&lt;Ref&lt;AXIsolatedTreeNode&gt;&gt; nodeChanges;
2954     auto root = createIsolatedAccessibilityTreeHierarchy(*rootObject(), InvalidAXID, *tree, nodeChanges);
<span class="line-modified">2955     root-&gt;setIsRootNode(true);</span>
2956     tree-&gt;appendNodeChanges(nodeChanges);
2957 
2958     return makeRef(*tree);
2959 }
2960 #endif
2961 
2962 void AXObjectCache::deferRecomputeIsIgnoredIfNeeded(Element* element)
2963 {
2964     if (!nodeAndRendererAreValid(element))
2965         return;
2966 
2967     if (rendererNeedsDeferredUpdate(*element-&gt;renderer())) {
2968         m_deferredRecomputeIsIgnoredList.add(element);
2969         return;
2970     }
2971     recomputeIsIgnored(element-&gt;renderer());
2972 }
2973 
2974 void AXObjectCache::deferRecomputeIsIgnored(Element* element)
2975 {
</pre>
<hr />
<pre>
3009     if (!renderer)
3010         return;
3011     m_deferredTextFormControlValue.add(&amp;formControlElement, previousValue);
3012 }
3013 
3014 bool isNodeAriaVisible(Node* node)
3015 {
3016     if (!node)
3017         return false;
3018 
3019     // ARIA Node visibility is controlled by aria-hidden
3020     //  1) if aria-hidden=true, the whole subtree is hidden
3021     //  2) if aria-hidden=false, and the object is rendered, there&#39;s no effect
3022     //  3) if aria-hidden=false, and the object is NOT rendered, then it must have
3023     //     aria-hidden=false on each parent until it gets to a rendered object
3024     //  3b) a text node inherits a parents aria-hidden value
3025     bool requiresAriaHiddenFalse = !node-&gt;renderer();
3026     bool ariaHiddenFalsePresent = false;
3027     for (Node* testNode = node; testNode; testNode = testNode-&gt;parentNode()) {
3028         if (is&lt;Element&gt;(*testNode)) {
<span class="line-modified">3029             const AtomicString&amp; ariaHiddenValue = downcast&lt;Element&gt;(*testNode).attributeWithoutSynchronization(aria_hiddenAttr);</span>
3030             if (equalLettersIgnoringASCIICase(ariaHiddenValue, &quot;true&quot;))
3031                 return false;
3032 
3033             bool ariaHiddenFalse = equalLettersIgnoringASCIICase(ariaHiddenValue, &quot;false&quot;);
3034             if (!testNode-&gt;renderer() &amp;&amp; !ariaHiddenFalse)
3035                 return false;
3036             if (!ariaHiddenFalsePresent &amp;&amp; ariaHiddenFalse)
3037                 ariaHiddenFalsePresent = true;
3038             // We should break early when it gets to a rendered object.
3039             if (testNode-&gt;renderer())
3040                 break;
3041         }
3042     }
3043 
3044     return !requiresAriaHiddenFalse || ariaHiddenFalsePresent;
3045 }
3046 
3047 AccessibilityObject* AXObjectCache::rootWebArea()
3048 {
3049     AccessibilityObject* rootObject = this-&gt;rootObject();
</pre>
<hr />
<pre>
3072     case AXTextEditTypeCut:
3073     case AXTextEditTypeDelete:
3074         return AXTextDeleted;
3075     case AXTextEditTypeInsert:
3076     case AXTextEditTypeDictation:
3077     case AXTextEditTypeTyping:
3078     case AXTextEditTypePaste:
3079         return AXTextInserted;
3080     case AXTextEditTypeAttributesChange:
3081         return AXTextAttributesChanged;
3082     case AXTextEditTypeUnknown:
3083         break;
3084     }
3085     ASSERT_NOT_REACHED();
3086     return AXTextInserted;
3087 }
3088 #endif
3089 
3090 } // namespace WebCore
3091 
<span class="line-modified">3092 #endif // HAVE(ACCESSIBILITY)</span>
</pre>
</td>
<td>
<hr />
<pre>
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
<span class="line-modified">  31 #if ENABLE(ACCESSIBILITY)</span>
  32 
  33 #include &quot;AXObjectCache.h&quot;
  34 
  35 #include &quot;AXIsolatedTree.h&quot;
  36 #include &quot;AXIsolatedTreeNode.h&quot;
  37 #include &quot;AccessibilityARIAGrid.h&quot;
  38 #include &quot;AccessibilityARIAGridCell.h&quot;
  39 #include &quot;AccessibilityARIAGridRow.h&quot;
  40 #include &quot;AccessibilityAttachment.h&quot;
  41 #include &quot;AccessibilityImageMapLink.h&quot;
  42 #include &quot;AccessibilityLabel.h&quot;
  43 #include &quot;AccessibilityList.h&quot;
  44 #include &quot;AccessibilityListBox.h&quot;
  45 #include &quot;AccessibilityListBoxOption.h&quot;
  46 #include &quot;AccessibilityMathMLElement.h&quot;
  47 #include &quot;AccessibilityMediaControls.h&quot;
  48 #include &quot;AccessibilityMediaObject.h&quot;
  49 #include &quot;AccessibilityMenuList.h&quot;
  50 #include &quot;AccessibilityMenuListOption.h&quot;
  51 #include &quot;AccessibilityMenuListPopup.h&quot;
</pre>
<hr />
<pre>
 834     // an AccessibilityRenderObject, because it was reparented to a location outside of a canvas.
 835     get(node);
 836 }
 837 
 838 void AXObjectCache::handleMenuOpened(Node* node)
 839 {
 840     if (!node || !node-&gt;renderer() || !nodeHasRole(node, &quot;menu&quot;))
 841         return;
 842 
 843     postNotification(getOrCreate(node), &amp;document(), AXMenuOpened);
 844 }
 845 
 846 void AXObjectCache::handleLiveRegionCreated(Node* node)
 847 {
 848     if (!is&lt;Element&gt;(node) || !node-&gt;renderer())
 849         return;
 850 
 851     Element* element = downcast&lt;Element&gt;(node);
 852     String liveRegionStatus = element-&gt;attributeWithoutSynchronization(aria_liveAttr);
 853     if (liveRegionStatus.isEmpty()) {
<span class="line-modified"> 854         const AtomString&amp; ariaRole = element-&gt;attributeWithoutSynchronization(roleAttr);</span>
 855         if (!ariaRole.isEmpty())
 856             liveRegionStatus = AccessibilityObject::defaultLiveRegionStatusForRole(AccessibilityObject::ariaRoleToWebCoreRole(ariaRole));
 857     }
 858 
 859     if (AccessibilityObject::liveRegionStatusIsEnabled(liveRegionStatus))
 860         postNotification(getOrCreate(node), &amp;document(), AXLiveRegionCreated);
 861 }
 862 
 863 void AXObjectCache::childrenChanged(Node* node, Node* newChild)
 864 {
 865     if (newChild)
 866         m_deferredChildrenChangedNodeList.add(newChild);
 867 
 868     childrenChanged(get(node));
 869 }
 870 
 871 void AXObjectCache::childrenChanged(RenderObject* renderer, RenderObject* newChild)
 872 {
 873     if (!renderer)
 874         return;
</pre>
<hr />
<pre>
1558 
1559     startCachingComputedObjectAttributesUntilTreeMutates();
1560 }
1561 
1562 void AXObjectCache::labelChanged(Element* element)
1563 {
1564     ASSERT(is&lt;HTMLLabelElement&gt;(*element));
1565     auto correspondingControl = downcast&lt;HTMLLabelElement&gt;(*element).control();
1566     deferTextChangedIfNeeded(correspondingControl.get());
1567 }
1568 
1569 void AXObjectCache::recomputeIsIgnored(RenderObject* renderer)
1570 {
1571     if (AccessibilityObject* obj = get(renderer))
1572         obj-&gt;notifyIfIgnoredValueChanged();
1573 }
1574 
1575 void AXObjectCache::startCachingComputedObjectAttributesUntilTreeMutates()
1576 {
1577     if (!m_computedObjectAttributeCache)
<span class="line-modified">1578         m_computedObjectAttributeCache = makeUnique&lt;AXComputedObjectAttributeCache&gt;();</span>
1579 }
1580 
1581 void AXObjectCache::stopCachingComputedObjectAttributes()
1582 {
1583     m_computedObjectAttributeCache = nullptr;
1584 }
1585 
1586 VisiblePosition AXObjectCache::visiblePositionForTextMarkerData(TextMarkerData&amp; textMarkerData)
1587 {
1588     if (!isNodeInUse(textMarkerData.node))
1589         return VisiblePosition();
1590 
1591     // FIXME: Accessability should make it clear these are DOM-compliant offsets or store Position objects.
1592     VisiblePosition visiblePos = VisiblePosition(createLegacyEditingPosition(textMarkerData.node, textMarkerData.offset), textMarkerData.affinity);
1593     Position deepPos = visiblePos.deepEquivalent();
1594     if (deepPos.isNull())
1595         return VisiblePosition();
1596 
1597     RenderObject* renderer = deepPos.deprecatedNode()-&gt;renderer();
1598     if (!renderer)
</pre>
<hr />
<pre>
1768 
1769     return length;
1770 }
1771 
1772 RefPtr&lt;Range&gt; AXObjectCache::rangeForNodeContents(Node* node)
1773 {
1774     if (!node)
1775         return nullptr;
1776     Document* document = &amp;node-&gt;document();
1777     if (!document)
1778         return nullptr;
1779     auto range = Range::create(*document);
1780     if (AccessibilityObject::replacedNodeNeedsCharacter(node)) {
1781         // For replaced nodes without children, the node itself is included in the range.
1782         if (range-&gt;selectNode(*node).hasException())
1783             return nullptr;
1784     } else {
1785         if (range-&gt;selectNodeContents(*node).hasException())
1786             return nullptr;
1787     }
<span class="line-modified">1788     return range;</span>
1789 }
1790 
1791 RefPtr&lt;Range&gt; AXObjectCache::rangeMatchesTextNearRange(RefPtr&lt;Range&gt; originalRange, const String&amp; matchText)
1792 {
1793     if (!originalRange)
1794         return nullptr;
1795 
1796     // Create a large enough range for searching the text within.
1797     unsigned textLength = matchText.length();
1798     auto startPosition = visiblePositionForPositionWithOffset(originalRange-&gt;startPosition(), -textLength);
1799     auto endPosition = visiblePositionForPositionWithOffset(originalRange-&gt;startPosition(), 2 * textLength);
1800 
1801     if (startPosition.isNull())
1802         startPosition = firstPositionInOrBeforeNode(&amp;originalRange-&gt;startContainer());
1803     if (endPosition.isNull())
1804         endPosition = lastPositionInOrAfterNode(&amp;originalRange-&gt;endContainer());
1805 
1806     auto searchRange = Range::create(m_document, startPosition, endPosition);
1807     if (searchRange-&gt;collapsed())
1808         return nullptr;
</pre>
<hr />
<pre>
1889             return false;
1890     }
1891 
1892     return true;
1893 }
1894 
1895 RefPtr&lt;Range&gt; AXObjectCache::rangeForUnorderedCharacterOffsets(const CharacterOffset&amp; characterOffset1, const CharacterOffset&amp; characterOffset2)
1896 {
1897     if (characterOffset1.isNull() || characterOffset2.isNull())
1898         return nullptr;
1899 
1900     bool alreadyInOrder = characterOffsetsInOrder(characterOffset1, characterOffset2);
1901     CharacterOffset startCharacterOffset = alreadyInOrder ? characterOffset1 : characterOffset2;
1902     CharacterOffset endCharacterOffset = alreadyInOrder ? characterOffset2 : characterOffset1;
1903 
1904     auto result = Range::create(m_document);
1905     if (!setRangeStartOrEndWithCharacterOffset(result, startCharacterOffset, true))
1906         return nullptr;
1907     if (!setRangeStartOrEndWithCharacterOffset(result, endCharacterOffset, false))
1908         return nullptr;
<span class="line-modified">1909     return result;</span>
1910 }
1911 
1912 void AXObjectCache::setTextMarkerDataWithCharacterOffset(TextMarkerData&amp; textMarkerData, const CharacterOffset&amp; characterOffset)
1913 {
1914     if (characterOffset.isNull())
1915         return;
1916 
1917     Node* domNode = characterOffset.node;
1918     if (is&lt;HTMLInputElement&gt;(*domNode) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*domNode).isPasswordField()) {
1919         textMarkerData.ignored = true;
1920         return;
1921     }
1922 
1923     RefPtr&lt;AccessibilityObject&gt; obj = this-&gt;getOrCreate(domNode);
1924     if (!obj)
1925         return;
1926 
1927     // Convert to visible position.
1928     VisiblePosition visiblePosition = visiblePositionFromCharacterOffset(characterOffset);
1929     int vpOffset = 0;
</pre>
<hr />
<pre>
2458     TextIterator it(searchRange.get(), TextIteratorEmitsObjectReplacementCharacters);
2459     unsigned next = forwardSearchForBoundaryWithTextIterator(it, string, prefixLength, searchFunction);
2460 
2461     if (it.atEnd() &amp;&amp; next == string.size())
2462         return end;
2463 
2464     // We should consider the node boundary that splits words.
2465     if (searchFunction == endWordBoundary &amp;&amp; next - prefixLength == 1)
2466         return nextCharacterOffset(characterOffset, false);
2467 
2468     // The endSentenceBoundary function will include a line break at the end of the sentence.
2469     if (searchFunction == endSentenceBoundary &amp;&amp; string[next - 1] == &#39;\n&#39;)
2470         next--;
2471 
2472     if (next &gt; prefixLength)
2473         return characterOffsetForNodeAndOffset(*characterOffset.node, characterOffset.offset + next - prefixLength);
2474 
2475     return characterOffset;
2476 }
2477 
<span class="line-modified">2478 // FIXME: Share code with the one in VisibleUnits.cpp.</span>
<span class="line-added">2479 CharacterOffset AXObjectCache::previousBoundary(const CharacterOffset&amp; characterOffset, BoundarySearchFunction searchFunction, NeedsContextAtParagraphStart needsContextAtParagraphStart)</span>
2480 {
2481     if (characterOffset.isNull())
2482         return CharacterOffset();
2483 
2484     Node* boundary = parentEditingBoundary(characterOffset.node);
2485     if (!boundary)
2486         return CharacterOffset();
2487 
2488     RefPtr&lt;Range&gt; searchRange = rangeForNodeContents(boundary);
2489     Vector&lt;UChar, 1024&gt; string;
2490     unsigned suffixLength = 0;
2491 
<span class="line-modified">2492     if (needsContextAtParagraphStart == NeedsContextAtParagraphStart::Yes &amp;&amp; startCharacterOffsetOfParagraph(characterOffset).isEqual(characterOffset)) {</span>
<span class="line-added">2493         auto forwardsScanRange = boundary-&gt;document().createRange();</span>
<span class="line-added">2494         auto endOfCurrentParagraph = endCharacterOffsetOfParagraph(characterOffset);</span>
<span class="line-added">2495         if (!setRangeStartOrEndWithCharacterOffset(forwardsScanRange, characterOffset, true))</span>
<span class="line-added">2496             return { };</span>
<span class="line-added">2497         if (!setRangeStartOrEndWithCharacterOffset(forwardsScanRange, endOfCurrentParagraph, false))</span>
<span class="line-added">2498             return { };</span>
<span class="line-added">2499         for (TextIterator forwardsIterator(forwardsScanRange.ptr()); !forwardsIterator.atEnd(); forwardsIterator.advance())</span>
<span class="line-added">2500             append(string, forwardsIterator.text());</span>
<span class="line-added">2501         suffixLength = string.size();</span>
<span class="line-added">2502     } else if (requiresContextForWordBoundary(characterBefore(characterOffset))) {</span>
2503         auto forwardsScanRange = boundary-&gt;document().createRange();
2504         if (forwardsScanRange-&gt;setEndAfter(*boundary).hasException())
2505             return { };
2506         if (!setRangeStartOrEndWithCharacterOffset(forwardsScanRange, characterOffset, true))
2507             return { };
2508         suffixLength = suffixLengthForRange(forwardsScanRange, string);
2509     }
2510 
2511     if (!setRangeStartOrEndWithCharacterOffset(*searchRange, characterOffset, false))
2512         return { };
2513     CharacterOffset start = startOrEndCharacterOffsetForRange(searchRange, true);
2514 
2515     SimplifiedBackwardsTextIterator it(*searchRange);
2516     unsigned next = backwardSearchForBoundaryWithTextIterator(it, string, suffixLength, searchFunction);
2517 
2518     if (!next)
2519         return it.atEnd() ? start : characterOffset;
2520 
2521     Node&amp; node = it.atEnd() ? searchRange-&gt;startContainer() : it.range()-&gt;startContainer();
2522 
2523     // SimplifiedBackwardsTextIterator ignores replaced elements.
2524     if (AccessibilityObject::replacedNodeNeedsCharacter(characterOffset.node))
2525         return characterOffsetForNodeAndOffset(*characterOffset.node, 0);
2526     Node* nextSibling = node.nextSibling();
2527     if (&amp;node != characterOffset.node &amp;&amp; AccessibilityObject::replacedNodeNeedsCharacter(nextSibling))
2528         return startOrEndCharacterOffsetForRange(rangeForNodeContents(nextSibling), false);
2529 
<span class="line-modified">2530     if ((!suffixLength &amp;&amp; node.isTextNode() &amp;&amp; static_cast&lt;int&gt;(next) &lt;= node.maxCharacterOffset()) || (node.renderer() &amp;&amp; node.renderer()-&gt;isBR() &amp;&amp; !next)) {</span>
2531         // The next variable contains a usable index into a text node
2532         if (node.isTextNode())
2533             return traverseToOffsetInRange(rangeForNodeContents(&amp;node), next, TraverseOptionValidateOffset);
2534         return characterOffsetForNodeAndOffset(node, next, TraverseOptionIncludeStart);
2535     }
2536 
<span class="line-modified">2537     int characterCount = characterOffset.offset;</span>
<span class="line-added">2538     if (next &lt; string.size() - suffixLength)</span>
<span class="line-added">2539         characterCount -= string.size() - suffixLength - next;</span>
2540     // We don&#39;t want to go to the previous node if the node is at the start of a new line.
2541     if (characterCount &lt; 0 &amp;&amp; (characterOffsetNodeIsBR(characterOffset) || string[string.size() - suffixLength - 1] == &#39;\n&#39;))
2542         characterCount = 0;
2543     return characterOffsetForNodeAndOffset(*characterOffset.node, characterCount, TraverseOptionIncludeStart);
2544 }
2545 
2546 CharacterOffset AXObjectCache::startCharacterOffsetOfParagraph(const CharacterOffset&amp; characterOffset, EditingBoundaryCrossingRule boundaryCrossingRule)
2547 {
2548     if (characterOffset.isNull())
2549         return CharacterOffset();
2550 
2551     auto* startNode = characterOffset.node;
2552 
2553     if (isRenderedAsNonInlineTableImageOrHR(startNode))
2554         return startOrEndCharacterOffsetForRange(rangeForNodeContents(startNode), true);
2555 
2556     auto* startBlock = enclosingBlock(startNode);
2557     int offset = characterOffset.startIndex + characterOffset.offset;
2558     auto* highestRoot = highestEditableRoot(firstPositionInOrBeforeNode(startNode));
2559     Position::AnchorType type = Position::PositionIsOffsetInAnchor;
</pre>
<hr />
<pre>
2609     if (characterOffsetNodeIsBR(next) &amp;&amp; !characterOffsetNodeIsBR(characterOffset))
2610         next = nextCharacterOffset(next);
2611 
2612     return endCharacterOffsetOfParagraph(next);
2613 }
2614 
2615 CharacterOffset AXObjectCache::previousParagraphStartCharacterOffset(const CharacterOffset&amp; characterOffset)
2616 {
2617     // make sure we move off of a paragraph start
2618     CharacterOffset previous = previousCharacterOffset(characterOffset);
2619 
2620     // We should skip the preceding BR node.
2621     if (characterOffsetNodeIsBR(previous) &amp;&amp; !characterOffsetNodeIsBR(characterOffset))
2622         previous = previousCharacterOffset(previous);
2623 
2624     return startCharacterOffsetOfParagraph(previous);
2625 }
2626 
2627 CharacterOffset AXObjectCache::startCharacterOffsetOfSentence(const CharacterOffset&amp; characterOffset)
2628 {
<span class="line-modified">2629     return previousBoundary(characterOffset, startSentenceBoundary, NeedsContextAtParagraphStart::Yes);</span>
2630 }
2631 
2632 CharacterOffset AXObjectCache::endCharacterOffsetOfSentence(const CharacterOffset&amp; characterOffset)
2633 {
2634     return nextBoundary(characterOffset, endSentenceBoundary);
2635 }
2636 
2637 RefPtr&lt;Range&gt; AXObjectCache::sentenceForCharacterOffset(const CharacterOffset&amp; characterOffset)
2638 {
2639     CharacterOffset start = startCharacterOffsetOfSentence(characterOffset);
2640     CharacterOffset end = endCharacterOffsetOfSentence(start);
2641     return rangeForUnorderedCharacterOffsets(start, end);
2642 }
2643 
2644 CharacterOffset AXObjectCache::nextSentenceEndCharacterOffset(const CharacterOffset&amp; characterOffset)
2645 {
2646     // Make sure we move off of a sentence end.
2647     return endCharacterOffsetOfSentence(nextCharacterOffset(characterOffset));
2648 }
2649 
</pre>
<hr />
<pre>
2948     associateIsolatedTreeNode(object, isolatedTreeNode, tree.treeIdentifier());
2949 
2950     for (auto child : object.children()) {
2951         auto staticChild = createIsolatedAccessibilityTreeHierarchy(*child, isolatedTreeNode-&gt;identifier(), tree, nodeChanges);
2952         isolatedTreeNode-&gt;appendChild(staticChild-&gt;identifier());
2953     }
2954 
2955     return isolatedTreeNode;
2956 }
2957 
2958 Ref&lt;AXIsolatedTree&gt; AXObjectCache::generateIsolatedAccessibilityTree()
2959 {
2960     RELEASE_ASSERT(isMainThread());
2961 
2962     auto tree = AXIsolatedTree::treeForPageID(*m_document.pageID());
2963     if (!tree)
2964         tree = AXIsolatedTree::createTreeForPageID(*m_document.pageID());
2965 
2966     Vector&lt;Ref&lt;AXIsolatedTreeNode&gt;&gt; nodeChanges;
2967     auto root = createIsolatedAccessibilityTreeHierarchy(*rootObject(), InvalidAXID, *tree, nodeChanges);
<span class="line-modified">2968     tree-&gt;setRootNodeID(root-&gt;identifier());</span>
2969     tree-&gt;appendNodeChanges(nodeChanges);
2970 
2971     return makeRef(*tree);
2972 }
2973 #endif
2974 
2975 void AXObjectCache::deferRecomputeIsIgnoredIfNeeded(Element* element)
2976 {
2977     if (!nodeAndRendererAreValid(element))
2978         return;
2979 
2980     if (rendererNeedsDeferredUpdate(*element-&gt;renderer())) {
2981         m_deferredRecomputeIsIgnoredList.add(element);
2982         return;
2983     }
2984     recomputeIsIgnored(element-&gt;renderer());
2985 }
2986 
2987 void AXObjectCache::deferRecomputeIsIgnored(Element* element)
2988 {
</pre>
<hr />
<pre>
3022     if (!renderer)
3023         return;
3024     m_deferredTextFormControlValue.add(&amp;formControlElement, previousValue);
3025 }
3026 
3027 bool isNodeAriaVisible(Node* node)
3028 {
3029     if (!node)
3030         return false;
3031 
3032     // ARIA Node visibility is controlled by aria-hidden
3033     //  1) if aria-hidden=true, the whole subtree is hidden
3034     //  2) if aria-hidden=false, and the object is rendered, there&#39;s no effect
3035     //  3) if aria-hidden=false, and the object is NOT rendered, then it must have
3036     //     aria-hidden=false on each parent until it gets to a rendered object
3037     //  3b) a text node inherits a parents aria-hidden value
3038     bool requiresAriaHiddenFalse = !node-&gt;renderer();
3039     bool ariaHiddenFalsePresent = false;
3040     for (Node* testNode = node; testNode; testNode = testNode-&gt;parentNode()) {
3041         if (is&lt;Element&gt;(*testNode)) {
<span class="line-modified">3042             const AtomString&amp; ariaHiddenValue = downcast&lt;Element&gt;(*testNode).attributeWithoutSynchronization(aria_hiddenAttr);</span>
3043             if (equalLettersIgnoringASCIICase(ariaHiddenValue, &quot;true&quot;))
3044                 return false;
3045 
3046             bool ariaHiddenFalse = equalLettersIgnoringASCIICase(ariaHiddenValue, &quot;false&quot;);
3047             if (!testNode-&gt;renderer() &amp;&amp; !ariaHiddenFalse)
3048                 return false;
3049             if (!ariaHiddenFalsePresent &amp;&amp; ariaHiddenFalse)
3050                 ariaHiddenFalsePresent = true;
3051             // We should break early when it gets to a rendered object.
3052             if (testNode-&gt;renderer())
3053                 break;
3054         }
3055     }
3056 
3057     return !requiresAriaHiddenFalse || ariaHiddenFalsePresent;
3058 }
3059 
3060 AccessibilityObject* AXObjectCache::rootWebArea()
3061 {
3062     AccessibilityObject* rootObject = this-&gt;rootObject();
</pre>
<hr />
<pre>
3085     case AXTextEditTypeCut:
3086     case AXTextEditTypeDelete:
3087         return AXTextDeleted;
3088     case AXTextEditTypeInsert:
3089     case AXTextEditTypeDictation:
3090     case AXTextEditTypeTyping:
3091     case AXTextEditTypePaste:
3092         return AXTextInserted;
3093     case AXTextEditTypeAttributesChange:
3094         return AXTextAttributesChanged;
3095     case AXTextEditTypeUnknown:
3096         break;
3097     }
3098     ASSERT_NOT_REACHED();
3099     return AXTextInserted;
3100 }
3101 #endif
3102 
3103 } // namespace WebCore
3104 
<span class="line-modified">3105 #endif // ENABLE(ACCESSIBILITY)</span>
</pre>
</td>
</tr>
</table>
<center><a href="../WebCorePrefix.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AXObjectCache.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>