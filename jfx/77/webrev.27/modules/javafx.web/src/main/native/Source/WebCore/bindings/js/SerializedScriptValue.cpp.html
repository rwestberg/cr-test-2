<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/js/SerializedScriptValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  *
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;SerializedScriptValue.h&quot;
  29 
  30 #include &quot;BlobRegistry.h&quot;
  31 #include &quot;CryptoKeyAES.h&quot;
  32 #include &quot;CryptoKeyEC.h&quot;
  33 #include &quot;CryptoKeyHMAC.h&quot;
  34 #include &quot;CryptoKeyRSA.h&quot;
  35 #include &quot;CryptoKeyRSAComponents.h&quot;
  36 #include &quot;CryptoKeyRaw.h&quot;
  37 #include &quot;IDBValue.h&quot;
  38 #include &quot;JSBlob.h&quot;
  39 #if PLATFORM(JAVA) &amp;&amp; ENABLE(SUBTLE_CRYPTO) // todo tav
  40 #include &quot;JSCryptoKey.h&quot;
  41 #endif
  42 #include &quot;JSDOMBinding.h&quot;
  43 #include &quot;JSDOMConvertBufferSource.h&quot;
  44 #include &quot;JSDOMGlobalObject.h&quot;
  45 #include &quot;JSDOMMatrix.h&quot;
  46 #include &quot;JSDOMPoint.h&quot;
  47 #include &quot;JSDOMQuad.h&quot;
  48 #include &quot;JSDOMRect.h&quot;
  49 #include &quot;JSFile.h&quot;
  50 #include &quot;JSFileList.h&quot;
  51 #include &quot;JSImageBitmap.h&quot;
  52 #include &quot;JSImageData.h&quot;
  53 #include &quot;JSMessagePort.h&quot;
  54 #include &quot;JSNavigator.h&quot;
  55 #include &quot;JSRTCCertificate.h&quot;
  56 #include &quot;ScriptExecutionContext.h&quot;
  57 #include &quot;ScriptState.h&quot;
  58 #include &quot;SharedBuffer.h&quot;
  59 #include &quot;WebCoreJSClientData.h&quot;
  60 #include &lt;JavaScriptCore/APICast.h&gt;
  61 #include &lt;JavaScriptCore/BooleanObject.h&gt;
  62 #include &lt;JavaScriptCore/CatchScope.h&gt;
  63 #include &lt;JavaScriptCore/DateInstance.h&gt;
  64 #include &lt;JavaScriptCore/Error.h&gt;
  65 #include &lt;JavaScriptCore/Exception.h&gt;
  66 #include &lt;JavaScriptCore/ExceptionHelpers.h&gt;
  67 #include &lt;JavaScriptCore/IterationKind.h&gt;
  68 #include &lt;JavaScriptCore/JSArrayBuffer.h&gt;
  69 #include &lt;JavaScriptCore/JSArrayBufferView.h&gt;
  70 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  71 #include &lt;JavaScriptCore/JSDataView.h&gt;
  72 #include &lt;JavaScriptCore/JSMap.h&gt;
  73 #include &lt;JavaScriptCore/JSMapIterator.h&gt;
  74 #include &lt;JavaScriptCore/JSSet.h&gt;
  75 #include &lt;JavaScriptCore/JSSetIterator.h&gt;
  76 #include &lt;JavaScriptCore/JSTypedArrays.h&gt;
  77 #include &lt;JavaScriptCore/JSWebAssemblyModule.h&gt;
  78 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
  79 #include &lt;JavaScriptCore/PropertyNameArray.h&gt;
  80 #include &lt;JavaScriptCore/RegExp.h&gt;
  81 #include &lt;JavaScriptCore/RegExpObject.h&gt;
  82 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
  83 #include &lt;JavaScriptCore/TypedArrays.h&gt;
  84 #include &lt;JavaScriptCore/WasmModule.h&gt;
  85 #include &lt;JavaScriptCore/YarrFlags.h&gt;
  86 #include &lt;limits&gt;
  87 #include &lt;wtf/CompletionHandler.h&gt;
  88 #include &lt;wtf/MainThread.h&gt;
  89 #include &lt;wtf/RunLoop.h&gt;
  90 #include &lt;wtf/Vector.h&gt;
  91 
  92 #if CPU(BIG_ENDIAN) || CPU(MIDDLE_ENDIAN) || CPU(NEEDS_ALIGNED_ACCESS)
  93 #define ASSUME_LITTLE_ENDIAN 0
  94 #else
  95 #define ASSUME_LITTLE_ENDIAN 1
  96 #endif
  97 
  98 namespace WebCore {
  99 using namespace JSC;
 100 
 101 static const unsigned maximumFilterRecursion = 40000;
 102 
 103 enum class SerializationReturnCode {
 104     SuccessfullyCompleted,
 105     StackOverflowError,
 106     InterruptedExecutionError,
 107     ValidationError,
 108     ExistingExceptionError,
 109     DataCloneError,
 110     UnspecifiedError
 111 };
 112 
 113 enum WalkerState { StateUnknown, ArrayStartState, ArrayStartVisitMember, ArrayEndVisitMember,
 114     ObjectStartState, ObjectStartVisitMember, ObjectEndVisitMember,
 115     MapDataStartVisitEntry, MapDataEndVisitKey, MapDataEndVisitValue,
 116     SetDataStartVisitEntry, SetDataEndVisitKey };
 117 
 118 // These can&#39;t be reordered, and any new types must be added to the end of the list
 119 // When making changes to these lists please cover your new type(s) in the API test &quot;IndexedDB.StructuredCloneBackwardCompatibility&quot;
 120 enum SerializationTag {
 121     ArrayTag = 1,
 122     ObjectTag = 2,
 123     UndefinedTag = 3,
 124     NullTag = 4,
 125     IntTag = 5,
 126     ZeroTag = 6,
 127     OneTag = 7,
 128     FalseTag = 8,
 129     TrueTag = 9,
 130     DoubleTag = 10,
 131     DateTag = 11,
 132     FileTag = 12,
 133     FileListTag = 13,
 134     ImageDataTag = 14,
 135     BlobTag = 15,
 136     StringTag = 16,
 137     EmptyStringTag = 17,
 138     RegExpTag = 18,
 139     ObjectReferenceTag = 19,
 140     MessagePortReferenceTag = 20,
 141     ArrayBufferTag = 21,
 142     ArrayBufferViewTag = 22,
 143     ArrayBufferTransferTag = 23,
 144     TrueObjectTag = 24,
 145     FalseObjectTag = 25,
 146     StringObjectTag = 26,
 147     EmptyStringObjectTag = 27,
 148     NumberObjectTag = 28,
 149     SetObjectTag = 29,
 150     MapObjectTag = 30,
 151     NonMapPropertiesTag = 31,
 152     NonSetPropertiesTag = 32,
 153 #if ENABLE(WEB_CRYPTO)
 154     CryptoKeyTag = 33,
 155 #endif
 156     SharedArrayBufferTag = 34,
 157 #if ENABLE(WEBASSEMBLY)
 158     WasmModuleTag = 35,
 159 #endif
 160     DOMPointReadOnlyTag = 36,
 161     DOMPointTag = 37,
 162     DOMRectReadOnlyTag = 38,
 163     DOMRectTag = 39,
 164     DOMMatrixReadOnlyTag = 40,
 165     DOMMatrixTag = 41,
 166     DOMQuadTag = 42,
 167     ImageBitmapTransferTag = 43,
 168 #if ENABLE(WEB_RTC)
 169     RTCCertificateTag = 44,
 170 #endif
 171     ErrorTag = 255
 172 };
 173 
 174 enum ArrayBufferViewSubtag {
 175     DataViewTag = 0,
 176     Int8ArrayTag = 1,
 177     Uint8ArrayTag = 2,
 178     Uint8ClampedArrayTag = 3,
 179     Int16ArrayTag = 4,
 180     Uint16ArrayTag = 5,
 181     Int32ArrayTag = 6,
 182     Uint32ArrayTag = 7,
 183     Float32ArrayTag = 8,
 184     Float64ArrayTag = 9
 185 };
 186 
 187 static unsigned typedArrayElementSize(ArrayBufferViewSubtag tag)
 188 {
 189     switch (tag) {
 190     case DataViewTag:
 191     case Int8ArrayTag:
 192     case Uint8ArrayTag:
 193     case Uint8ClampedArrayTag:
 194         return 1;
 195     case Int16ArrayTag:
 196     case Uint16ArrayTag:
 197         return 2;
 198     case Int32ArrayTag:
 199     case Uint32ArrayTag:
 200     case Float32ArrayTag:
 201         return 4;
 202     case Float64ArrayTag:
 203         return 8;
 204     default:
 205         return 0;
 206     }
 207 
 208 }
 209 
 210 #if ENABLE(WEB_CRYPTO)
 211 
 212 const uint32_t currentKeyFormatVersion = 1;
 213 
 214 enum class CryptoKeyClassSubtag {
 215     HMAC = 0,
 216     AES = 1,
 217     RSA = 2,
 218     EC = 3,
 219     Raw = 4,
 220 };
 221 const uint8_t cryptoKeyClassSubtagMaximumValue = 4;
 222 
 223 enum class CryptoKeyAsymmetricTypeSubtag {
 224     Public = 0,
 225     Private = 1
 226 };
 227 const uint8_t cryptoKeyAsymmetricTypeSubtagMaximumValue = 1;
 228 
 229 enum class CryptoKeyUsageTag {
 230     Encrypt = 0,
 231     Decrypt = 1,
 232     Sign = 2,
 233     Verify = 3,
 234     DeriveKey = 4,
 235     DeriveBits = 5,
 236     WrapKey = 6,
 237     UnwrapKey = 7
 238 };
 239 const uint8_t cryptoKeyUsageTagMaximumValue = 7;
 240 
 241 enum class CryptoAlgorithmIdentifierTag {
 242     RSAES_PKCS1_v1_5 = 0,
 243     RSASSA_PKCS1_v1_5 = 1,
 244     RSA_PSS = 2,
 245     RSA_OAEP = 3,
 246     ECDSA = 4,
 247     ECDH = 5,
 248     AES_CTR = 6,
 249     AES_CBC = 7,
 250     AES_GCM = 9,
 251     AES_CFB = 10,
 252     AES_KW = 11,
 253     HMAC = 12,
 254     SHA_1 = 14,
 255     SHA_224 = 15,
 256     SHA_256 = 16,
 257     SHA_384 = 17,
 258     SHA_512 = 18,
 259     HKDF = 20,
 260     PBKDF2 = 21,
 261 };
 262 const uint8_t cryptoAlgorithmIdentifierTagMaximumValue = 21;
 263 
 264 static unsigned countUsages(CryptoKeyUsageBitmap usages)
 265 {
 266     // Fast bit count algorithm for sparse bit maps.
 267     unsigned count = 0;
 268     while (usages) {
 269         usages = usages &amp; (usages - 1);
 270         ++count;
 271     }
 272     return count;
 273 }
 274 
 275 #endif
 276 
 277 /* CurrentVersion tracks the serialization version so that persistent stores
 278  * are able to correctly bail out in the case of encountering newer formats.
 279  *
 280  * Initial version was 1.
 281  * Version 2. added the ObjectReferenceTag and support for serialization of cyclic graphs.
 282  * Version 3. added the FalseObjectTag, TrueObjectTag, NumberObjectTag, StringObjectTag
 283  * and EmptyStringObjectTag for serialization of Boolean, Number and String objects.
 284  * Version 4. added support for serializing non-index properties of arrays.
 285  * Version 5. added support for Map and Set types.
 286  * Version 6. added support for 8-bit strings.
 287  * Version 7. added support for File&#39;s lastModified attribute.
 288  */
 289 static const unsigned CurrentVersion = 7;
 290 static const unsigned TerminatorTag = 0xFFFFFFFF;
 291 static const unsigned StringPoolTag = 0xFFFFFFFE;
 292 static const unsigned NonIndexPropertiesTag = 0xFFFFFFFD;
 293 
 294 // The high bit of a StringData&#39;s length determines the character size.
 295 static const unsigned StringDataIs8BitFlag = 0x80000000;
 296 
 297 /*
 298  * Object serialization is performed according to the following grammar, all tags
 299  * are recorded as a single uint8_t.
 300  *
 301  * IndexType (used for the object pool and StringData&#39;s constant pool) is the
 302  * minimum sized unsigned integer type required to represent the maximum index
 303  * in the constant pool.
 304  *
 305  * SerializedValue :- &lt;CurrentVersion:uint32_t&gt; Value
 306  * Value :- Array | Object | Map | Set | Terminal
 307  *
 308  * Array :-
 309  *     ArrayTag &lt;length:uint32_t&gt;(&lt;index:uint32_t&gt;&lt;value:Value&gt;)* TerminatorTag
 310  *
 311  * Object :-
 312  *     ObjectTag (&lt;name:StringData&gt;&lt;value:Value&gt;)* TerminatorTag
 313  *
 314  * Map :- MapObjectTag MapData
 315  *
 316  * Set :- SetObjectTag SetData
 317  *
 318  * MapData :- (&lt;key:Value&gt;&lt;value:Value&gt;)* NonMapPropertiesTag (&lt;name:StringData&gt;&lt;value:Value&gt;)* TerminatorTag
 319  * SetData :- (&lt;key:Value&gt;)* NonSetPropertiesTag (&lt;name:StringData&gt;&lt;value:Value&gt;)* TerminatorTag
 320  *
 321  * Terminal :-
 322  *      UndefinedTag
 323  *    | NullTag
 324  *    | IntTag &lt;value:int32_t&gt;
 325  *    | ZeroTag
 326  *    | OneTag
 327  *    | FalseTag
 328  *    | TrueTag
 329  *    | FalseObjectTag
 330  *    | TrueObjectTag
 331  *    | DoubleTag &lt;value:double&gt;
 332  *    | NumberObjectTag &lt;value:double&gt;
 333  *    | DateTag &lt;value:double&gt;
 334  *    | String
 335  *    | EmptyStringTag
 336  *    | EmptyStringObjectTag
 337  *    | File
 338  *    | FileList
 339  *    | ImageData
 340  *    | Blob
 341  *    | ObjectReference
 342  *    | MessagePortReferenceTag &lt;value:uint32_t&gt;
 343  *    | ArrayBuffer
 344  *    | ArrayBufferViewTag ArrayBufferViewSubtag &lt;byteOffset:uint32_t&gt; &lt;byteLength:uint32_t&gt; (ArrayBuffer | ObjectReference)
 345  *    | ArrayBufferTransferTag &lt;value:uint32_t&gt;
 346  *    | CryptoKeyTag &lt;wrappedKeyLength:uint32_t&gt; &lt;factor:byte{wrappedKeyLength}&gt;
 347  *    | DOMPoint
 348  *    | DOMRect
 349  *    | DOMMatrix
 350  *    | DOMQuad
 351  *    | ImageBitmapTransferTag &lt;value:uint32_t&gt;
 352  *    | RTCCertificateTag
 353  *
 354  * Inside certificate, data is serialized in this format as per spec:
 355  *
 356  * &lt;expires:double&gt; &lt;certificate:StringData&gt; &lt;origin:StringData&gt; &lt;keyingMaterial:StringData&gt;
 357  * We also add fingerprints to make sure we expose to JavaScript the same information.
 358  *
 359  * Inside wrapped crypto key, data is serialized in this format:
 360  *
 361  * &lt;keyFormatVersion:uint32_t&gt; &lt;extractable:int32_t&gt; &lt;usagesCount:uint32_t&gt; &lt;usages:byte{usagesCount}&gt; CryptoKeyClassSubtag (CryptoKeyHMAC | CryptoKeyAES | CryptoKeyRSA)
 362  *
 363  * String :-
 364  *      EmptyStringTag
 365  *      StringTag StringData
 366  *
 367  * StringObject:
 368  *      EmptyStringObjectTag
 369  *      StringObjectTag StringData
 370  *
 371  * StringData :-
 372  *      StringPoolTag &lt;cpIndex:IndexType&gt;
 373  *      (not (TerminatorTag | StringPoolTag))&lt;is8Bit:uint32_t:1&gt;&lt;length:uint32_t:31&gt;&lt;characters:CharType{length}&gt; // Added to constant pool when seen, string length 0xFFFFFFFF is disallowed
 374  *
 375  * File :-
 376  *    FileTag FileData
 377  *
 378  * FileData :-
 379  *    &lt;path:StringData&gt; &lt;url:StringData&gt; &lt;type:StringData&gt; &lt;name:StringData&gt; &lt;lastModified:double&gt;
 380  *
 381  * FileList :-
 382  *    FileListTag &lt;length:uint32_t&gt;(&lt;file:FileData&gt;){length}
 383  *
 384  * ImageData :-
 385  *    ImageDataTag &lt;width:int32_t&gt;&lt;height:int32_t&gt;&lt;length:uint32_t&gt;&lt;data:uint8_t{length}&gt;
 386  *
 387  * Blob :-
 388  *    BlobTag &lt;url:StringData&gt;&lt;type:StringData&gt;&lt;size:long long&gt;
 389  *
 390  * RegExp :-
 391  *    RegExpTag &lt;pattern:StringData&gt;&lt;flags:StringData&gt;
 392  *
 393  * ObjectReference :-
 394  *    ObjectReferenceTag &lt;opIndex:IndexType&gt;
 395  *
 396  * ArrayBuffer :-
 397  *    ArrayBufferTag &lt;length:uint32_t&gt; &lt;contents:byte{length}&gt;
 398  *
 399  * CryptoKeyHMAC :-
 400  *    &lt;keySize:uint32_t&gt; &lt;keyData:byte{keySize}&gt; CryptoAlgorithmIdentifierTag // Algorithm tag inner hash function.
 401  *
 402  * CryptoKeyAES :-
 403  *    CryptoAlgorithmIdentifierTag &lt;keySize:uint32_t&gt; &lt;keyData:byte{keySize}&gt;
 404  *
 405  * CryptoKeyRSA :-
 406  *    CryptoAlgorithmIdentifierTag &lt;isRestrictedToHash:int32_t&gt; CryptoAlgorithmIdentifierTag? CryptoKeyAsymmetricTypeSubtag CryptoKeyRSAPublicComponents CryptoKeyRSAPrivateComponents?
 407  *
 408  * CryptoKeyRSAPublicComponents :-
 409  *    &lt;modulusSize:uint32_t&gt; &lt;modulus:byte{modulusSize}&gt; &lt;exponentSize:uint32_t&gt; &lt;exponent:byte{exponentSize}&gt;
 410  *
 411  * CryptoKeyRSAPrivateComponents :-
 412  *    &lt;privateExponentSize:uint32_t&gt; &lt;privateExponent:byte{privateExponentSize}&gt; &lt;primeCount:uint32_t&gt; FirstPrimeInfo? PrimeInfo{primeCount - 1}
 413  *
 414  * // CRT data could be computed from prime factors. It is only serialized to reuse a code path that&#39;s needed for JWK.
 415  * FirstPrimeInfo :-
 416  *    &lt;factorSize:uint32_t&gt; &lt;factor:byte{factorSize}&gt; &lt;crtExponentSize:uint32_t&gt; &lt;crtExponent:byte{crtExponentSize}&gt;
 417  *
 418  * PrimeInfo :-
 419  *    &lt;factorSize:uint32_t&gt; &lt;factor:byte{factorSize}&gt; &lt;crtExponentSize:uint32_t&gt; &lt;crtExponent:byte{crtExponentSize}&gt; &lt;crtCoefficientSize:uint32_t&gt; &lt;crtCoefficient:byte{crtCoefficientSize}&gt;
 420  *
 421  * CryptoKeyEC :-
 422  *    CryptoAlgorithmIdentifierTag &lt;namedCurve:StringData&gt; CryptoKeyAsymmetricTypeSubtag &lt;keySize:uint32_t&gt; &lt;keyData:byte{keySize}&gt;
 423  *
 424  * CryptoKeyRaw :-
 425  *    CryptoAlgorithmIdentifierTag &lt;keySize:uint32_t&gt; &lt;keyData:byte{keySize}&gt;
 426  *
 427  * DOMPoint :-
 428  *        DOMPointReadOnlyTag DOMPointData
 429  *      | DOMPointTag DOMPointData
 430  *
 431  * DOMPointData :-
 432  *      &lt;x:double&gt; &lt;y:double&gt; &lt;z:double&gt; &lt;w:double&gt;
 433  *
 434  * DOMRect :-
 435  *        DOMRectReadOnlyTag DOMRectData
 436  *      | DOMRectTag DOMRectData
 437  *
 438  * DOMRectData :-
 439  *      &lt;x:double&gt; &lt;y:double&gt; &lt;width:double&gt; &lt;height:double&gt;
 440  *
 441  * DOMMatrix :-
 442  *        DOMMatrixReadOnlyTag DOMMatrixData
 443  *      | DOMMatrixTag DOMMatrixData
 444  *
 445  * DOMMatrixData :-
 446  *        &lt;is2D:uint8_t:true&gt; &lt;m11:double&gt; &lt;m12:double&gt; &lt;m21:double&gt; &lt;m22:double&gt; &lt;m41:double&gt; &lt;m42:double&gt;
 447  *      | &lt;is2D:uint8_t:false&gt; &lt;m11:double&gt; &lt;m12:double&gt; &lt;m13:double&gt; &lt;m14:double&gt; &lt;m21:double&gt; &lt;m22:double&gt; &lt;m23:double&gt; &lt;m24:double&gt; &lt;m31:double&gt; &lt;m32:double&gt; &lt;m33:double&gt; &lt;m34:double&gt; &lt;m41:double&gt; &lt;m42:double&gt; &lt;m43:double&gt; &lt;m44:double&gt;
 448  *
 449  * DOMQuad :-
 450  *      DOMQuadTag DOMQuadData
 451  *
 452  * DOMQuadData :-
 453  *      &lt;p1:DOMPointData&gt; &lt;p2:DOMPointData&gt; &lt;p3:DOMPointData&gt; &lt;p4:DOMPointData&gt;
 454  *
 455  */
 456 
 457 using DeserializationResult = std::pair&lt;JSC::JSValue, SerializationReturnCode&gt;;
 458 
 459 class CloneBase {
 460 protected:
 461     CloneBase(ExecState* exec)
 462         : m_exec(exec)
 463         , m_failed(false)
 464     {
 465     }
 466 
 467     bool shouldTerminate()
 468     {
 469         VM&amp; vm = m_exec-&gt;vm();
 470         auto scope = DECLARE_THROW_SCOPE(vm);
 471         return scope.exception();
 472     }
 473 
 474     void fail()
 475     {
 476         m_failed = true;
 477     }
 478 
 479     ExecState* m_exec;
 480     bool m_failed;
 481     MarkedArgumentBuffer m_gcBuffer;
 482 };
 483 
 484 #if ENABLE(WEB_CRYPTO)
 485 static bool wrapCryptoKey(ExecState* exec, const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
 486 {
 487     ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(exec);
 488     if (!scriptExecutionContext)
 489         return false;
 490     return scriptExecutionContext-&gt;wrapCryptoKey(key, wrappedKey);
 491 }
 492 
 493 static bool unwrapCryptoKey(ExecState* exec, const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
 494 {
 495     ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(exec);
 496     if (!scriptExecutionContext)
 497         return false;
 498     return scriptExecutionContext-&gt;unwrapCryptoKey(wrappedKey, key);
 499 }
 500 #endif
 501 
 502 #if ASSUME_LITTLE_ENDIAN
 503 template &lt;typename T&gt; static void writeLittleEndian(Vector&lt;uint8_t&gt;&amp; buffer, T value)
 504 {
 505     buffer.append(reinterpret_cast&lt;uint8_t*&gt;(&amp;value), sizeof(value));
 506 }
 507 #else
 508 template &lt;typename T&gt; static void writeLittleEndian(Vector&lt;uint8_t&gt;&amp; buffer, T value)
 509 {
 510     for (unsigned i = 0; i &lt; sizeof(T); i++) {
 511         buffer.append(value &amp; 0xFF);
 512         value &gt;&gt;= 8;
 513     }
 514 }
 515 #endif
 516 
 517 template &lt;&gt; void writeLittleEndian&lt;uint8_t&gt;(Vector&lt;uint8_t&gt;&amp; buffer, uint8_t value)
 518 {
 519     buffer.append(value);
 520 }
 521 
 522 template &lt;typename T&gt; static bool writeLittleEndian(Vector&lt;uint8_t&gt;&amp; buffer, const T* values, uint32_t length)
 523 {
 524     if (length &gt; std::numeric_limits&lt;uint32_t&gt;::max() / sizeof(T))
 525         return false;
 526 
 527 #if ASSUME_LITTLE_ENDIAN
 528     buffer.append(reinterpret_cast&lt;const uint8_t*&gt;(values), length * sizeof(T));
 529 #else
 530     for (unsigned i = 0; i &lt; length; i++) {
 531         T value = values[i];
 532         for (unsigned j = 0; j &lt; sizeof(T); j++) {
 533             buffer.append(static_cast&lt;uint8_t&gt;(value &amp; 0xFF));
 534             value &gt;&gt;= 8;
 535         }
 536     }
 537 #endif
 538     return true;
 539 }
 540 
 541 template &lt;&gt; bool writeLittleEndian&lt;uint8_t&gt;(Vector&lt;uint8_t&gt;&amp; buffer, const uint8_t* values, uint32_t length)
 542 {
 543     buffer.append(values, length);
 544     return true;
 545 }
 546 
 547 class CloneSerializer : CloneBase {
 548 public:
 549     static SerializationReturnCode serialize(ExecState* exec, JSValue value, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,
 550 #if ENABLE(WEBASSEMBLY)
 551             WasmModuleArray&amp; wasmModules,
 552 #endif
 553         Vector&lt;String&gt;&amp; blobURLs, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)
 554     {
 555         CloneSerializer serializer(exec, messagePorts, arrayBuffers, imageBitmaps,
 556 #if ENABLE(WEBASSEMBLY)
 557             wasmModules,
 558 #endif
 559             blobURLs, out, context, sharedBuffers);
 560         return serializer.serialize(value);
 561     }
 562 
 563     static bool serialize(StringView string, Vector&lt;uint8_t&gt;&amp; out)
 564     {
 565         writeLittleEndian(out, CurrentVersion);
 566         if (string.isEmpty()) {
 567             writeLittleEndian&lt;uint8_t&gt;(out, EmptyStringTag);
 568             return true;
 569         }
 570         writeLittleEndian&lt;uint8_t&gt;(out, StringTag);
 571         if (string.is8Bit()) {
 572             writeLittleEndian(out, string.length() | StringDataIs8BitFlag);
 573             return writeLittleEndian(out, string.characters8(), string.length());
 574         }
 575         writeLittleEndian(out, string.length());
 576         return writeLittleEndian(out, string.characters16(), string.length());
 577     }
 578 
 579 private:
 580     typedef HashMap&lt;JSObject*, uint32_t&gt; ObjectPool;
 581 
 582     CloneSerializer(ExecState* exec, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,
 583 #if ENABLE(WEBASSEMBLY)
 584             WasmModuleArray&amp; wasmModules,
 585 #endif
 586         Vector&lt;String&gt;&amp; blobURLs, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)
 587         : CloneBase(exec)
 588         , m_buffer(out)
 589         , m_blobURLs(blobURLs)
 590         , m_emptyIdentifier(Identifier::fromString(exec-&gt;vm(), emptyString()))
 591         , m_context(context)
 592         , m_sharedBuffers(sharedBuffers)
 593 #if ENABLE(WEBASSEMBLY)
 594         , m_wasmModules(wasmModules)
 595 #endif
 596     {
 597         write(CurrentVersion);
 598         fillTransferMap(messagePorts, m_transferredMessagePorts);
 599         fillTransferMap(arrayBuffers, m_transferredArrayBuffers);
 600         fillTransferMap(imageBitmaps, m_transferredImageBitmaps);
 601     }
 602 
 603     template &lt;class T&gt;
 604     void fillTransferMap(const Vector&lt;RefPtr&lt;T&gt;&gt;&amp; input, ObjectPool&amp; result)
 605     {
 606         if (input.isEmpty())
 607             return;
 608         JSDOMGlobalObject* globalObject = jsCast&lt;JSDOMGlobalObject*&gt;(m_exec-&gt;lexicalGlobalObject());
 609         for (size_t i = 0; i &lt; input.size(); i++) {
 610             JSC::JSValue value = toJS(m_exec, globalObject, input[i].get());
 611             JSC::JSObject* obj = value.getObject();
 612             if (obj &amp;&amp; !result.contains(obj))
 613                 result.add(obj, i);
 614         }
 615     }
 616 
 617     SerializationReturnCode serialize(JSValue in);
 618 
 619     bool isArray(VM&amp; vm, JSValue value)
 620     {
 621         if (!value.isObject())
 622             return false;
 623         JSObject* object = asObject(value);
 624         return object-&gt;inherits&lt;JSArray&gt;(vm);
 625     }
 626 
 627     bool isMap(VM&amp; vm, JSValue value)
 628     {
 629         if (!value.isObject())
 630             return false;
 631         JSObject* object = asObject(value);
 632         return object-&gt;inherits&lt;JSMap&gt;(vm);
 633     }
 634     bool isSet(VM&amp; vm, JSValue value)
 635     {
 636         if (!value.isObject())
 637             return false;
 638         JSObject* object = asObject(value);
 639         return object-&gt;inherits&lt;JSSet&gt;(vm);
 640     }
 641 
 642     bool checkForDuplicate(JSObject* object)
 643     {
 644         // Record object for graph reconstruction
 645         ObjectPool::const_iterator found = m_objectPool.find(object);
 646 
 647         // Handle duplicate references
 648         if (found != m_objectPool.end()) {
 649             write(ObjectReferenceTag);
 650             ASSERT(found-&gt;value &lt; m_objectPool.size());
 651             writeObjectIndex(found-&gt;value);
 652             return true;
 653         }
 654 
 655         return false;
 656     }
 657 
 658     void recordObject(JSObject* object)
 659     {
 660         m_objectPool.add(object, m_objectPool.size());
 661         m_gcBuffer.appendWithCrashOnOverflow(object);
 662     }
 663 
 664     bool startObjectInternal(JSObject* object)
 665     {
 666         if (checkForDuplicate(object))
 667             return false;
 668         recordObject(object);
 669         return true;
 670     }
 671 
 672     bool startObject(JSObject* object)
 673     {
 674         if (!startObjectInternal(object))
 675             return false;
 676         write(ObjectTag);
 677         return true;
 678     }
 679 
 680     bool startArray(JSArray* array)
 681     {
 682         if (!startObjectInternal(array))
 683             return false;
 684 
 685         unsigned length = array-&gt;length();
 686         write(ArrayTag);
 687         write(length);
 688         return true;
 689     }
 690 
 691     bool startSet(JSSet* set)
 692     {
 693         if (!startObjectInternal(set))
 694             return false;
 695 
 696         write(SetObjectTag);
 697         return true;
 698     }
 699 
 700     bool startMap(JSMap* map)
 701     {
 702         if (!startObjectInternal(map))
 703             return false;
 704 
 705         write(MapObjectTag);
 706         return true;
 707     }
 708 
 709     void endObject()
 710     {
 711         write(TerminatorTag);
 712     }
 713 
 714     JSValue getProperty(VM&amp; vm, JSObject* object, const Identifier&amp; propertyName)
 715     {
 716         PropertySlot slot(object, PropertySlot::InternalMethodType::Get);
 717         if (object-&gt;methodTable(vm)-&gt;getOwnPropertySlot(object, m_exec, propertyName, slot))
 718             return slot.getValue(m_exec, propertyName);
 719         return JSValue();
 720     }
 721 
 722     void dumpImmediate(JSValue value)
 723     {
 724         if (value.isNull())
 725             write(NullTag);
 726         else if (value.isUndefined())
 727             write(UndefinedTag);
 728         else if (value.isNumber()) {
 729             if (value.isInt32()) {
 730                 if (!value.asInt32())
 731                     write(ZeroTag);
 732                 else if (value.asInt32() == 1)
 733                     write(OneTag);
 734                 else {
 735                     write(IntTag);
 736                     write(static_cast&lt;uint32_t&gt;(value.asInt32()));
 737                 }
 738             } else {
 739                 write(DoubleTag);
 740                 write(value.asDouble());
 741             }
 742         } else if (value.isBoolean()) {
 743             if (value.isTrue())
 744                 write(TrueTag);
 745             else
 746                 write(FalseTag);
 747         }
 748     }
 749 
 750     void dumpString(const String&amp; string)
 751     {
 752         if (string.isEmpty())
 753             write(EmptyStringTag);
 754         else {
 755             write(StringTag);
 756             write(string);
 757         }
 758     }
 759 
 760     void dumpStringObject(const String&amp; string)
 761     {
 762         if (string.isEmpty())
 763             write(EmptyStringObjectTag);
 764         else {
 765             write(StringObjectTag);
 766             write(string);
 767         }
 768     }
 769 
 770     JSC::JSValue toJSArrayBuffer(ArrayBuffer&amp; arrayBuffer)
 771     {
 772         auto&amp; vm = m_exec-&gt;vm();
 773         auto* globalObject = m_exec-&gt;lexicalGlobalObject();
 774         if (globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(vm))
 775             return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(globalObject), &amp;arrayBuffer);
 776 
 777         if (auto* buffer = arrayBuffer.m_wrapper.get())
 778             return buffer;
 779 
 780         return JSC::JSArrayBuffer::create(vm, globalObject-&gt;arrayBufferStructure(arrayBuffer.sharingMode()), &amp;arrayBuffer);
 781     }
 782 
 783     bool dumpArrayBufferView(JSObject* obj, SerializationReturnCode&amp; code)
 784     {
 785         VM&amp; vm = m_exec-&gt;vm();
 786         write(ArrayBufferViewTag);
 787         if (obj-&gt;inherits&lt;JSDataView&gt;(vm))
 788             write(DataViewTag);
 789         else if (obj-&gt;inherits&lt;JSUint8ClampedArray&gt;(vm))
 790             write(Uint8ClampedArrayTag);
 791         else if (obj-&gt;inherits&lt;JSInt8Array&gt;(vm))
 792             write(Int8ArrayTag);
 793         else if (obj-&gt;inherits&lt;JSUint8Array&gt;(vm))
 794             write(Uint8ArrayTag);
 795         else if (obj-&gt;inherits&lt;JSInt16Array&gt;(vm))
 796             write(Int16ArrayTag);
 797         else if (obj-&gt;inherits&lt;JSUint16Array&gt;(vm))
 798             write(Uint16ArrayTag);
 799         else if (obj-&gt;inherits&lt;JSInt32Array&gt;(vm))
 800             write(Int32ArrayTag);
 801         else if (obj-&gt;inherits&lt;JSUint32Array&gt;(vm))
 802             write(Uint32ArrayTag);
 803         else if (obj-&gt;inherits&lt;JSFloat32Array&gt;(vm))
 804             write(Float32ArrayTag);
 805         else if (obj-&gt;inherits&lt;JSFloat64Array&gt;(vm))
 806             write(Float64ArrayTag);
 807         else
 808             return false;
 809 
 810         RefPtr&lt;ArrayBufferView&gt; arrayBufferView = toPossiblySharedArrayBufferView(vm, obj);
 811         write(static_cast&lt;uint32_t&gt;(arrayBufferView-&gt;byteOffset()));
 812         write(static_cast&lt;uint32_t&gt;(arrayBufferView-&gt;byteLength()));
 813         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = arrayBufferView-&gt;possiblySharedBuffer();
 814         if (!arrayBuffer) {
 815             code = SerializationReturnCode::ValidationError;
 816             return true;
 817         }
 818 
 819         return dumpIfTerminal(toJSArrayBuffer(*arrayBuffer), code);
 820     }
 821 
 822     void dumpDOMPoint(const DOMPointReadOnly&amp; point)
 823     {
 824         write(point.x());
 825         write(point.y());
 826         write(point.z());
 827         write(point.w());
 828     }
 829 
 830     void dumpDOMPoint(JSObject* obj)
 831     {
 832         VM&amp; vm = m_exec-&gt;vm();
 833         if (obj-&gt;inherits&lt;JSDOMPoint&gt;(vm))
 834             write(DOMPointTag);
 835         else
 836             write(DOMPointReadOnlyTag);
 837 
 838         dumpDOMPoint(jsCast&lt;JSDOMPointReadOnly*&gt;(obj)-&gt;wrapped());
 839     }
 840 
 841     void dumpDOMRect(JSObject* obj)
 842     {
 843         VM&amp; vm = m_exec-&gt;vm();
 844         if (obj-&gt;inherits&lt;JSDOMRect&gt;(vm))
 845             write(DOMRectTag);
 846         else
 847             write(DOMRectReadOnlyTag);
 848 
 849         auto&amp; rect = jsCast&lt;JSDOMRectReadOnly*&gt;(obj)-&gt;wrapped();
 850         write(rect.x());
 851         write(rect.y());
 852         write(rect.width());
 853         write(rect.height());
 854     }
 855 
 856     void dumpDOMMatrix(JSObject* obj)
 857     {
 858         VM&amp; vm = m_exec-&gt;vm();
 859         if (obj-&gt;inherits&lt;JSDOMMatrix&gt;(vm))
 860             write(DOMMatrixTag);
 861         else
 862             write(DOMMatrixReadOnlyTag);
 863 
 864         auto&amp; matrix = jsCast&lt;JSDOMMatrixReadOnly*&gt;(obj)-&gt;wrapped();
 865         bool is2D = matrix.is2D();
 866         write(static_cast&lt;uint8_t&gt;(is2D));
 867         if (is2D) {
 868             write(matrix.m11());
 869             write(matrix.m12());
 870             write(matrix.m21());
 871             write(matrix.m22());
 872             write(matrix.m41());
 873             write(matrix.m42());
 874         } else {
 875             write(matrix.m11());
 876             write(matrix.m12());
 877             write(matrix.m13());
 878             write(matrix.m14());
 879             write(matrix.m21());
 880             write(matrix.m22());
 881             write(matrix.m23());
 882             write(matrix.m24());
 883             write(matrix.m31());
 884             write(matrix.m32());
 885             write(matrix.m33());
 886             write(matrix.m34());
 887             write(matrix.m41());
 888             write(matrix.m42());
 889             write(matrix.m43());
 890             write(matrix.m44());
 891         }
 892     }
 893 
 894     void dumpDOMQuad(JSObject* obj)
 895     {
 896         write(DOMQuadTag);
 897 
 898         auto&amp; quad = jsCast&lt;JSDOMQuad*&gt;(obj)-&gt;wrapped();
 899         dumpDOMPoint(quad.p1());
 900         dumpDOMPoint(quad.p2());
 901         dumpDOMPoint(quad.p3());
 902         dumpDOMPoint(quad.p4());
 903     }
 904 
 905     void dumpImageBitmap(JSObject* obj, SerializationReturnCode&amp; code)
 906     {
 907         auto index = m_transferredImageBitmaps.find(obj);
 908         if (index != m_transferredImageBitmaps.end()) {
 909             write(ImageBitmapTransferTag);
 910             write(index-&gt;value);
 911             return;
 912         }
 913 
 914         // Copying ImageBitmaps is not yet supported.
 915         code = SerializationReturnCode::ValidationError;
 916     }
 917 
 918     bool dumpIfTerminal(JSValue value, SerializationReturnCode&amp; code)
 919     {
 920         if (!value.isCell()) {
 921             dumpImmediate(value);
 922             return true;
 923         }
 924         ASSERT(value.isCell());
 925 
 926         if (value.isString()) {
 927             dumpString(asString(value)-&gt;value(m_exec));
 928             return true;
 929         }
 930 
 931         if (value.isSymbol()) {
 932             code = SerializationReturnCode::DataCloneError;
 933             return true;
 934         }
 935 
 936         VM&amp; vm = m_exec-&gt;vm();
 937         if (isArray(vm, value))
 938             return false;
 939 
 940         if (value.isObject()) {
 941             auto* obj = asObject(value);
 942             if (auto* dateObject = jsDynamicCast&lt;DateInstance*&gt;(vm, obj)) {
 943                 write(DateTag);
 944                 write(dateObject-&gt;internalNumber());
 945                 return true;
 946             }
 947             if (auto* booleanObject = jsDynamicCast&lt;BooleanObject*&gt;(vm, obj)) {
 948                 if (!startObjectInternal(booleanObject)) // handle duplicates
 949                     return true;
 950                 write(booleanObject-&gt;internalValue().toBoolean(m_exec) ? TrueObjectTag : FalseObjectTag);
 951                 return true;
 952             }
 953             if (auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, obj)) {
 954                 if (!startObjectInternal(stringObject)) // handle duplicates
 955                     return true;
 956                 String str = asString(stringObject-&gt;internalValue())-&gt;value(m_exec);
 957                 dumpStringObject(str);
 958                 return true;
 959             }
 960             if (auto* numberObject = jsDynamicCast&lt;NumberObject*&gt;(vm, obj)) {
 961                 if (!startObjectInternal(numberObject)) // handle duplicates
 962                     return true;
 963                 write(NumberObjectTag);
 964                 write(numberObject-&gt;internalValue().asNumber());
 965                 return true;
 966             }
 967             if (auto* file = JSFile::toWrapped(vm, obj)) {
 968                 write(FileTag);
 969                 write(*file);
 970                 return true;
 971             }
 972             if (auto* list = JSFileList::toWrapped(vm, obj)) {
 973                 write(FileListTag);
 974                 write(list-&gt;length());
 975                 for (auto&amp; file : list-&gt;files())
 976                     write(file.get());
 977                 return true;
 978             }
 979             if (auto* blob = JSBlob::toWrapped(vm, obj)) {
 980                 write(BlobTag);
 981                 m_blobURLs.append(blob-&gt;url());
 982                 write(blob-&gt;url());
 983                 write(blob-&gt;type());
 984                 write(blob-&gt;size());
 985                 return true;
 986             }
 987             if (auto* data = JSImageData::toWrapped(vm, obj)) {
 988                 write(ImageDataTag);
 989                 write(data-&gt;width());
 990                 write(data-&gt;height());
 991                 write(data-&gt;data()-&gt;length());
 992                 write(data-&gt;data()-&gt;data(), data-&gt;data()-&gt;length());
 993                 return true;
 994             }
 995             if (auto* regExp = jsDynamicCast&lt;RegExpObject*&gt;(vm, obj)) {
 996                 char flags[3];
 997                 int flagCount = 0;
 998                 if (regExp-&gt;regExp()-&gt;global())
 999                     flags[flagCount++] = &#39;g&#39;;
1000                 if (regExp-&gt;regExp()-&gt;ignoreCase())
1001                     flags[flagCount++] = &#39;i&#39;;
1002                 if (regExp-&gt;regExp()-&gt;multiline())
1003                     flags[flagCount++] = &#39;m&#39;;
1004                 write(RegExpTag);
1005                 write(regExp-&gt;regExp()-&gt;pattern());
1006                 write(String(flags, flagCount));
1007                 return true;
1008             }
1009             if (obj-&gt;inherits&lt;JSMessagePort&gt;(vm)) {
1010                 auto index = m_transferredMessagePorts.find(obj);
1011                 if (index != m_transferredMessagePorts.end()) {
1012                     write(MessagePortReferenceTag);
1013                     write(index-&gt;value);
1014                     return true;
1015                 }
1016                 // MessagePort object could not be found in transferred message ports
1017                 code = SerializationReturnCode::ValidationError;
1018                 return true;
1019             }
1020             if (auto* arrayBuffer = toPossiblySharedArrayBuffer(vm, obj)) {
1021                 if (arrayBuffer-&gt;isNeutered()) {
1022                     code = SerializationReturnCode::ValidationError;
1023                     return true;
1024                 }
1025                 auto index = m_transferredArrayBuffers.find(obj);
1026                 if (index != m_transferredArrayBuffers.end()) {
1027                     write(ArrayBufferTransferTag);
1028                     write(index-&gt;value);
1029                     return true;
1030                 }
1031                 if (!startObjectInternal(obj)) // handle duplicates
1032                     return true;
1033 
1034                 if (arrayBuffer-&gt;isShared() &amp;&amp; m_context == SerializationContext::WorkerPostMessage) {
1035                     uint32_t index = m_sharedBuffers.size();
1036                     ArrayBufferContents contents;
1037                     if (arrayBuffer-&gt;shareWith(contents)) {
1038                         write(SharedArrayBufferTag);
1039                         m_sharedBuffers.append(WTFMove(contents));
1040                         write(index);
1041                         return true;
1042                     }
1043                 }
1044 
1045                 write(ArrayBufferTag);
1046                 write(arrayBuffer-&gt;byteLength());
1047                 write(static_cast&lt;const uint8_t*&gt;(arrayBuffer-&gt;data()), arrayBuffer-&gt;byteLength());
1048                 return true;
1049             }
1050             if (obj-&gt;inherits&lt;JSArrayBufferView&gt;(vm)) {
1051                 if (checkForDuplicate(obj))
1052                     return true;
1053                 bool success = dumpArrayBufferView(obj, code);
1054                 recordObject(obj);
1055                 return success;
1056             }
1057 #if ENABLE(WEB_CRYPTO)
1058             if (auto* key = JSCryptoKey::toWrapped(vm, obj)) {
1059                 write(CryptoKeyTag);
1060                 Vector&lt;uint8_t&gt; serializedKey;
1061                 Vector&lt;String&gt; dummyBlobURLs;
1062                 Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
1063                 Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
1064 #if ENABLE(WEBASSEMBLY)
1065                 WasmModuleArray dummyModules;
1066 #endif
1067                 ArrayBufferContentsArray dummySharedBuffers;
1068                 CloneSerializer rawKeySerializer(m_exec, dummyMessagePorts, dummyArrayBuffers, { },
1069 #if ENABLE(WEBASSEMBLY)
1070                     dummyModules,
1071 #endif
1072                     dummyBlobURLs, serializedKey, SerializationContext::Default, dummySharedBuffers);
1073                 rawKeySerializer.write(key);
1074                 Vector&lt;uint8_t&gt; wrappedKey;
1075                 if (!wrapCryptoKey(m_exec, serializedKey, wrappedKey))
1076                     return false;
1077                 write(wrappedKey);
1078                 return true;
1079             }
1080 #endif
1081 #if ENABLE(WEB_RTC)
1082             if (auto* rtcCertificate = JSRTCCertificate::toWrapped(vm, obj)) {
1083                 write(RTCCertificateTag);
1084                 write(rtcCertificate-&gt;expires());
1085                 write(rtcCertificate-&gt;pemCertificate());
1086                 write(rtcCertificate-&gt;origin().toString());
1087                 write(rtcCertificate-&gt;pemPrivateKey());
1088                 write(static_cast&lt;unsigned&gt;(rtcCertificate-&gt;getFingerprints().size()));
1089                 for (const auto&amp; fingerprint : rtcCertificate-&gt;getFingerprints()) {
1090                     write(fingerprint.algorithm);
1091                     write(fingerprint.value);
1092                 }
1093                 return true;
1094             }
1095 #endif
1096 #if ENABLE(WEBASSEMBLY)
1097             if (JSWebAssemblyModule* module = jsDynamicCast&lt;JSWebAssemblyModule*&gt;(vm, obj)) {
1098                 if (m_context != SerializationContext::WorkerPostMessage &amp;&amp; m_context != SerializationContext::WindowPostMessage)
1099                     return false;
1100 
1101                 uint32_t index = m_wasmModules.size();
1102                 m_wasmModules.append(makeRef(module-&gt;module()));
1103                 write(WasmModuleTag);
1104                 write(index);
1105                 return true;
1106             }
1107 #endif
1108             if (obj-&gt;inherits&lt;JSDOMPointReadOnly&gt;(vm)) {
1109                 dumpDOMPoint(obj);
1110                 return true;
1111             }
1112             if (obj-&gt;inherits&lt;JSDOMRectReadOnly&gt;(vm)) {
1113                 dumpDOMRect(obj);
1114                 return true;
1115             }
1116             if (obj-&gt;inherits&lt;JSDOMMatrixReadOnly&gt;(vm)) {
1117                 dumpDOMMatrix(obj);
1118                 return true;
1119             }
1120             if (obj-&gt;inherits&lt;JSDOMQuad&gt;(vm)) {
1121                 dumpDOMQuad(obj);
1122                 return true;
1123             }
1124             if (obj-&gt;inherits(vm, JSImageBitmap::info())) {
1125                 dumpImageBitmap(obj, code);
1126                 return true;
1127             }
1128             return false;
1129         }
1130         // Any other types are expected to serialize as null.
1131         write(NullTag);
1132         return true;
1133     }
1134 
1135     void write(SerializationTag tag)
1136     {
1137         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1138     }
1139 
1140     void write(ArrayBufferViewSubtag tag)
1141     {
1142         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1143     }
1144 
1145 #if ENABLE(WEB_CRYPTO)
1146     void write(CryptoKeyClassSubtag tag)
1147     {
1148         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1149     }
1150 
1151     void write(CryptoKeyAsymmetricTypeSubtag tag)
1152     {
1153         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1154     }
1155 
1156     void write(CryptoKeyUsageTag tag)
1157     {
1158         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1159     }
1160 
1161     void write(CryptoAlgorithmIdentifierTag tag)
1162     {
1163         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1164     }
1165 #endif
1166 
1167     void write(uint8_t c)
1168     {
1169         writeLittleEndian(m_buffer, c);
1170     }
1171 
1172     void write(uint32_t i)
1173     {
1174         writeLittleEndian(m_buffer, i);
1175     }
1176 
1177     void write(double d)
1178     {
1179         union {
1180             double d;
1181             int64_t i;
1182         } u;
1183         u.d = d;
1184         writeLittleEndian(m_buffer, u.i);
1185     }
1186 
1187     void write(int32_t i)
1188     {
1189         writeLittleEndian(m_buffer, i);
1190     }
1191 
1192     void write(unsigned long long i)
1193     {
1194         writeLittleEndian(m_buffer, i);
1195     }
1196 
1197     void write(uint16_t ch)
1198     {
1199         writeLittleEndian(m_buffer, ch);
1200     }
1201 
1202     void writeStringIndex(unsigned i)
1203     {
1204         writeConstantPoolIndex(m_constantPool, i);
1205     }
1206 
1207     void writeObjectIndex(unsigned i)
1208     {
1209         writeConstantPoolIndex(m_objectPool, i);
1210     }
1211 
1212     template &lt;class T&gt; void writeConstantPoolIndex(const T&amp; constantPool, unsigned i)
1213     {
1214         ASSERT(i &lt; constantPool.size());
1215         if (constantPool.size() &lt;= 0xFF)
1216             write(static_cast&lt;uint8_t&gt;(i));
1217         else if (constantPool.size() &lt;= 0xFFFF)
1218             write(static_cast&lt;uint16_t&gt;(i));
1219         else
1220             write(static_cast&lt;uint32_t&gt;(i));
1221     }
1222 
1223     void write(const Identifier&amp; ident)
1224     {
1225         const String&amp; str = ident.string();
1226         StringConstantPool::AddResult addResult = m_constantPool.add(ident.impl(), m_constantPool.size());
1227         if (!addResult.isNewEntry) {
1228             write(StringPoolTag);
1229             writeStringIndex(addResult.iterator-&gt;value);
1230             return;
1231         }
1232 
1233         unsigned length = str.length();
1234 
1235         // Guard against overflow
1236         if (length &gt; (std::numeric_limits&lt;uint32_t&gt;::max() - sizeof(uint32_t)) / sizeof(UChar)) {
1237             fail();
1238             return;
1239         }
1240 
1241         if (str.is8Bit())
1242             writeLittleEndian&lt;uint32_t&gt;(m_buffer, length | StringDataIs8BitFlag);
1243         else
1244             writeLittleEndian&lt;uint32_t&gt;(m_buffer, length);
1245 
1246         if (!length)
1247             return;
1248         if (str.is8Bit()) {
1249             if (!writeLittleEndian(m_buffer, str.characters8(), length))
1250                 fail();
1251             return;
1252         }
1253         if (!writeLittleEndian(m_buffer, str.characters16(), length))
1254             fail();
1255     }
1256 
1257     void write(const String&amp; str)
1258     {
1259         if (str.isNull())
1260             write(m_emptyIdentifier);
1261         else
1262             write(Identifier::fromString(m_exec-&gt;vm(), str));
1263     }
1264 
1265     void write(const Vector&lt;uint8_t&gt;&amp; vector)
1266     {
1267         uint32_t size = vector.size();
1268         write(size);
1269         writeLittleEndian(m_buffer, vector.data(), size);
1270     }
1271 
1272     void write(const File&amp; file)
1273     {
1274         m_blobURLs.append(file.url());
1275         write(file.path());
1276         write(file.url());
1277         write(file.type());
1278         write(file.name());
1279         write(static_cast&lt;double&gt;(file.lastModifiedOverride().valueOr(-1)));
1280     }
1281 
1282 #if ENABLE(WEB_CRYPTO)
1283     void write(CryptoAlgorithmIdentifier algorithm)
1284     {
1285         switch (algorithm) {
1286         case CryptoAlgorithmIdentifier::RSAES_PKCS1_v1_5:
1287             write(CryptoAlgorithmIdentifierTag::RSAES_PKCS1_v1_5);
1288             break;
1289         case CryptoAlgorithmIdentifier::RSASSA_PKCS1_v1_5:
1290             write(CryptoAlgorithmIdentifierTag::RSASSA_PKCS1_v1_5);
1291             break;
1292         case CryptoAlgorithmIdentifier::RSA_PSS:
1293             write(CryptoAlgorithmIdentifierTag::RSA_PSS);
1294             break;
1295         case CryptoAlgorithmIdentifier::RSA_OAEP:
1296             write(CryptoAlgorithmIdentifierTag::RSA_OAEP);
1297             break;
1298         case CryptoAlgorithmIdentifier::ECDSA:
1299             write(CryptoAlgorithmIdentifierTag::ECDSA);
1300             break;
1301         case CryptoAlgorithmIdentifier::ECDH:
1302             write(CryptoAlgorithmIdentifierTag::ECDH);
1303             break;
1304         case CryptoAlgorithmIdentifier::AES_CTR:
1305             write(CryptoAlgorithmIdentifierTag::AES_CTR);
1306             break;
1307         case CryptoAlgorithmIdentifier::AES_CBC:
1308             write(CryptoAlgorithmIdentifierTag::AES_CBC);
1309             break;
1310         case CryptoAlgorithmIdentifier::AES_GCM:
1311             write(CryptoAlgorithmIdentifierTag::AES_GCM);
1312             break;
1313         case CryptoAlgorithmIdentifier::AES_CFB:
1314             write(CryptoAlgorithmIdentifierTag::AES_CFB);
1315             break;
1316         case CryptoAlgorithmIdentifier::AES_KW:
1317             write(CryptoAlgorithmIdentifierTag::AES_KW);
1318             break;
1319         case CryptoAlgorithmIdentifier::HMAC:
1320             write(CryptoAlgorithmIdentifierTag::HMAC);
1321             break;
1322         case CryptoAlgorithmIdentifier::SHA_1:
1323             write(CryptoAlgorithmIdentifierTag::SHA_1);
1324             break;
1325         case CryptoAlgorithmIdentifier::SHA_224:
1326             write(CryptoAlgorithmIdentifierTag::SHA_224);
1327             break;
1328         case CryptoAlgorithmIdentifier::SHA_256:
1329             write(CryptoAlgorithmIdentifierTag::SHA_256);
1330             break;
1331         case CryptoAlgorithmIdentifier::SHA_384:
1332             write(CryptoAlgorithmIdentifierTag::SHA_384);
1333             break;
1334         case CryptoAlgorithmIdentifier::SHA_512:
1335             write(CryptoAlgorithmIdentifierTag::SHA_512);
1336             break;
1337         case CryptoAlgorithmIdentifier::HKDF:
1338             write(CryptoAlgorithmIdentifierTag::HKDF);
1339             break;
1340         case CryptoAlgorithmIdentifier::PBKDF2:
1341             write(CryptoAlgorithmIdentifierTag::PBKDF2);
1342             break;
1343         }
1344     }
1345 
1346     void write(CryptoKeyRSAComponents::Type type)
1347     {
1348         switch (type) {
1349         case CryptoKeyRSAComponents::Type::Public:
1350             write(CryptoKeyAsymmetricTypeSubtag::Public);
1351             return;
1352         case CryptoKeyRSAComponents::Type::Private:
1353             write(CryptoKeyAsymmetricTypeSubtag::Private);
1354             return;
1355         }
1356     }
1357 
1358     void write(const CryptoKeyRSAComponents&amp; key)
1359     {
1360         write(key.type());
1361         write(key.modulus());
1362         write(key.exponent());
1363         if (key.type() == CryptoKeyRSAComponents::Type::Public)
1364             return;
1365 
1366         write(key.privateExponent());
1367 
1368         unsigned primeCount = key.hasAdditionalPrivateKeyParameters() ? key.otherPrimeInfos().size() + 2 : 0;
1369         write(primeCount);
1370         if (!primeCount)
1371             return;
1372 
1373         write(key.firstPrimeInfo().primeFactor);
1374         write(key.firstPrimeInfo().factorCRTExponent);
1375         write(key.secondPrimeInfo().primeFactor);
1376         write(key.secondPrimeInfo().factorCRTExponent);
1377         write(key.secondPrimeInfo().factorCRTCoefficient);
1378         for (unsigned i = 2; i &lt; primeCount; ++i) {
1379             write(key.otherPrimeInfos()[i].primeFactor);
1380             write(key.otherPrimeInfos()[i].factorCRTExponent);
1381             write(key.otherPrimeInfos()[i].factorCRTCoefficient);
1382         }
1383     }
1384 
1385     void write(const CryptoKey* key)
1386     {
1387         write(currentKeyFormatVersion);
1388 
1389         write(key-&gt;extractable());
1390 
1391         CryptoKeyUsageBitmap usages = key-&gt;usagesBitmap();
1392         write(countUsages(usages));
1393         if (usages &amp; CryptoKeyUsageEncrypt)
1394             write(CryptoKeyUsageTag::Encrypt);
1395         if (usages &amp; CryptoKeyUsageDecrypt)
1396             write(CryptoKeyUsageTag::Decrypt);
1397         if (usages &amp; CryptoKeyUsageSign)
1398             write(CryptoKeyUsageTag::Sign);
1399         if (usages &amp; CryptoKeyUsageVerify)
1400             write(CryptoKeyUsageTag::Verify);
1401         if (usages &amp; CryptoKeyUsageDeriveKey)
1402             write(CryptoKeyUsageTag::DeriveKey);
1403         if (usages &amp; CryptoKeyUsageDeriveBits)
1404             write(CryptoKeyUsageTag::DeriveBits);
1405         if (usages &amp; CryptoKeyUsageWrapKey)
1406             write(CryptoKeyUsageTag::WrapKey);
1407         if (usages &amp; CryptoKeyUsageUnwrapKey)
1408             write(CryptoKeyUsageTag::UnwrapKey);
1409 
1410         switch (key-&gt;keyClass()) {
1411         case CryptoKeyClass::HMAC:
1412             write(CryptoKeyClassSubtag::HMAC);
1413             write(downcast&lt;CryptoKeyHMAC&gt;(*key).key());
1414             write(downcast&lt;CryptoKeyHMAC&gt;(*key).hashAlgorithmIdentifier());
1415             break;
1416         case CryptoKeyClass::AES:
1417             write(CryptoKeyClassSubtag::AES);
1418             write(key-&gt;algorithmIdentifier());
1419             write(downcast&lt;CryptoKeyAES&gt;(*key).key());
1420             break;
1421         case CryptoKeyClass::EC:
1422             write(CryptoKeyClassSubtag::EC);
1423             write(key-&gt;algorithmIdentifier());
1424             write(downcast&lt;CryptoKeyEC&gt;(*key).namedCurveString());
1425             switch (key-&gt;type()) {
1426             case CryptoKey::Type::Public: {
1427                 write(CryptoKeyAsymmetricTypeSubtag::Public);
1428                 auto result = downcast&lt;CryptoKeyEC&gt;(*key).exportRaw();
1429                 ASSERT(!result.hasException());
1430                 write(result.releaseReturnValue());
1431                 break;
1432             }
1433             case CryptoKey::Type::Private: {
1434                 write(CryptoKeyAsymmetricTypeSubtag::Private);
1435                 // Use the standard complied method is not very efficient, but simple/reliable.
1436                 auto result = downcast&lt;CryptoKeyEC&gt;(*key).exportPkcs8();
1437                 ASSERT(!result.hasException());
1438                 write(result.releaseReturnValue());
1439                 break;
1440             }
1441             default:
1442                 ASSERT_NOT_REACHED();
1443             }
1444             break;
1445         case CryptoKeyClass::Raw:
1446             write(CryptoKeyClassSubtag::Raw);
1447             write(key-&gt;algorithmIdentifier());
1448             write(downcast&lt;CryptoKeyRaw&gt;(*key).key());
1449             break;
1450         case CryptoKeyClass::RSA:
1451             write(CryptoKeyClassSubtag::RSA);
1452             write(key-&gt;algorithmIdentifier());
1453             CryptoAlgorithmIdentifier hash;
1454             bool isRestrictedToHash = downcast&lt;CryptoKeyRSA&gt;(*key).isRestrictedToHash(hash);
1455             write(isRestrictedToHash);
1456             if (isRestrictedToHash)
1457                 write(hash);
1458             write(*downcast&lt;CryptoKeyRSA&gt;(*key).exportData());
1459             break;
1460         }
1461     }
1462 #endif
1463 
1464     void write(const uint8_t* data, unsigned length)
1465     {
1466         m_buffer.append(data, length);
1467     }
1468 
1469     Vector&lt;uint8_t&gt;&amp; m_buffer;
1470     Vector&lt;String&gt;&amp; m_blobURLs;
1471     ObjectPool m_objectPool;
1472     ObjectPool m_transferredMessagePorts;
1473     ObjectPool m_transferredArrayBuffers;
1474     ObjectPool m_transferredImageBitmaps;
1475     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, uint32_t, IdentifierRepHash&gt; StringConstantPool;
1476     StringConstantPool m_constantPool;
1477     Identifier m_emptyIdentifier;
1478     SerializationContext m_context;
1479     ArrayBufferContentsArray&amp; m_sharedBuffers;
1480 #if ENABLE(WEBASSEMBLY)
1481     WasmModuleArray&amp; m_wasmModules;
1482 #endif
1483 };
1484 
1485 SerializationReturnCode CloneSerializer::serialize(JSValue in)
1486 {
1487     VM&amp; vm = m_exec-&gt;vm();
1488     Vector&lt;uint32_t, 16&gt; indexStack;
1489     Vector&lt;uint32_t, 16&gt; lengthStack;
1490     Vector&lt;PropertyNameArray, 16&gt; propertyStack;
1491     Vector&lt;JSObject*, 32&gt; inputObjectStack;
1492     Vector&lt;JSMapIterator*, 4&gt; mapIteratorStack;
1493     Vector&lt;JSSetIterator*, 4&gt; setIteratorStack;
1494     Vector&lt;JSValue, 4&gt; mapIteratorValueStack;
1495     Vector&lt;WalkerState, 16&gt; stateStack;
1496     WalkerState state = StateUnknown;
1497     JSValue inValue = in;
1498     while (1) {
1499         switch (state) {
1500             arrayStartState:
1501             case ArrayStartState: {
1502                 ASSERT(isArray(vm, inValue));
1503                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1504                     return SerializationReturnCode::StackOverflowError;
1505 
1506                 JSArray* inArray = asArray(inValue);
1507                 unsigned length = inArray-&gt;length();
1508                 if (!startArray(inArray))
1509                     break;
1510                 inputObjectStack.append(inArray);
1511                 indexStack.append(0);
1512                 lengthStack.append(length);
1513             }
1514             arrayStartVisitMember:
1515             FALLTHROUGH;
1516             case ArrayStartVisitMember: {
1517                 JSObject* array = inputObjectStack.last();
1518                 uint32_t index = indexStack.last();
1519                 if (index == lengthStack.last()) {
1520                     indexStack.removeLast();
1521                     lengthStack.removeLast();
1522 
1523                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
1524                     array-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(array, m_exec, propertyStack.last(), EnumerationMode());
1525                     if (propertyStack.last().size()) {
1526                         write(NonIndexPropertiesTag);
1527                         indexStack.append(0);
1528                         goto objectStartVisitMember;
1529                     }
1530                     propertyStack.removeLast();
1531 
1532                     endObject();
1533                     inputObjectStack.removeLast();
1534                     break;
1535                 }
1536                 inValue = array-&gt;getDirectIndex(m_exec, index);
1537                 if (!inValue) {
1538                     indexStack.last()++;
1539                     goto arrayStartVisitMember;
1540                 }
1541 
1542                 write(index);
1543                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1544                 if (dumpIfTerminal(inValue, terminalCode)) {
1545                     if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1546                         return terminalCode;
1547                     indexStack.last()++;
1548                     goto arrayStartVisitMember;
1549                 }
1550                 stateStack.append(ArrayEndVisitMember);
1551                 goto stateUnknown;
1552             }
1553             case ArrayEndVisitMember: {
1554                 indexStack.last()++;
1555                 goto arrayStartVisitMember;
1556             }
1557             objectStartState:
1558             case ObjectStartState: {
1559                 ASSERT(inValue.isObject());
1560                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1561                     return SerializationReturnCode::StackOverflowError;
1562                 JSObject* inObject = asObject(inValue);
1563                 if (!startObject(inObject))
1564                     break;
1565                 // At this point, all supported objects other than Object
1566                 // objects have been handled. If we reach this point and
1567                 // the input is not an Object object then we should throw
1568                 // a DataCloneError.
1569                 if (inObject-&gt;classInfo(vm) != JSFinalObject::info())
1570                     return SerializationReturnCode::DataCloneError;
1571                 inputObjectStack.append(inObject);
1572                 indexStack.append(0);
1573                 propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
1574                 inObject-&gt;methodTable(vm)-&gt;getOwnPropertyNames(inObject, m_exec, propertyStack.last(), EnumerationMode());
1575             }
1576             objectStartVisitMember:
1577             FALLTHROUGH;
1578             case ObjectStartVisitMember: {
1579                 JSObject* object = inputObjectStack.last();
1580                 uint32_t index = indexStack.last();
1581                 PropertyNameArray&amp; properties = propertyStack.last();
1582                 if (index == properties.size()) {
1583                     endObject();
1584                     inputObjectStack.removeLast();
1585                     indexStack.removeLast();
1586                     propertyStack.removeLast();
1587                     break;
1588                 }
1589                 inValue = getProperty(vm, object, properties[index]);
1590                 if (shouldTerminate())
1591                     return SerializationReturnCode::ExistingExceptionError;
1592 
1593                 if (!inValue) {
1594                     // Property was removed during serialisation
1595                     indexStack.last()++;
1596                     goto objectStartVisitMember;
1597                 }
1598                 write(properties[index]);
1599 
1600                 if (shouldTerminate())
1601                     return SerializationReturnCode::ExistingExceptionError;
1602 
1603                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1604                 if (!dumpIfTerminal(inValue, terminalCode)) {
1605                     stateStack.append(ObjectEndVisitMember);
1606                     goto stateUnknown;
1607                 }
1608                 if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1609                     return terminalCode;
1610                 FALLTHROUGH;
1611             }
1612             case ObjectEndVisitMember: {
1613                 if (shouldTerminate())
1614                     return SerializationReturnCode::ExistingExceptionError;
1615 
1616                 indexStack.last()++;
1617                 goto objectStartVisitMember;
1618             }
1619             mapStartState: {
1620                 ASSERT(inValue.isObject());
1621                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1622                     return SerializationReturnCode::StackOverflowError;
1623                 JSMap* inMap = jsCast&lt;JSMap*&gt;(inValue);
1624                 if (!startMap(inMap))
1625                     break;
1626                 JSMapIterator* iterator = JSMapIterator::create(vm, vm.mapIteratorStructure(), inMap, IterateKeyValue);
1627                 m_gcBuffer.appendWithCrashOnOverflow(inMap);
1628                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
1629                 mapIteratorStack.append(iterator);
1630                 inputObjectStack.append(inMap);
1631                 goto mapDataStartVisitEntry;
1632             }
1633             mapDataStartVisitEntry:
1634             case MapDataStartVisitEntry: {
1635                 JSMapIterator* iterator = mapIteratorStack.last();
1636                 JSValue key, value;
1637                 if (!iterator-&gt;nextKeyValue(m_exec, key, value)) {
1638                     mapIteratorStack.removeLast();
1639                     JSObject* object = inputObjectStack.last();
1640                     ASSERT(jsDynamicCast&lt;JSMap*&gt;(vm, object));
1641                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
1642                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());
1643                     write(NonMapPropertiesTag);
1644                     indexStack.append(0);
1645                     goto objectStartVisitMember;
1646                 }
1647                 inValue = key;
1648                 m_gcBuffer.appendWithCrashOnOverflow(value);
1649                 mapIteratorValueStack.append(value);
1650                 stateStack.append(MapDataEndVisitKey);
1651                 goto stateUnknown;
1652             }
1653             case MapDataEndVisitKey: {
1654                 inValue = mapIteratorValueStack.last();
1655                 mapIteratorValueStack.removeLast();
1656                 stateStack.append(MapDataEndVisitValue);
1657                 goto stateUnknown;
1658             }
1659             case MapDataEndVisitValue: {
1660                 goto mapDataStartVisitEntry;
1661             }
1662 
1663             setStartState: {
1664                 ASSERT(inValue.isObject());
1665                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1666                     return SerializationReturnCode::StackOverflowError;
1667                 JSSet* inSet = jsCast&lt;JSSet*&gt;(inValue);
1668                 if (!startSet(inSet))
1669                     break;
1670                 JSSetIterator* iterator = JSSetIterator::create(vm, vm.setIteratorStructure(), inSet, IterateKey);
1671                 m_gcBuffer.appendWithCrashOnOverflow(inSet);
1672                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
1673                 setIteratorStack.append(iterator);
1674                 inputObjectStack.append(inSet);
1675                 goto setDataStartVisitEntry;
1676             }
1677             setDataStartVisitEntry:
1678             case SetDataStartVisitEntry: {
1679                 JSSetIterator* iterator = setIteratorStack.last();
1680                 JSValue key;
1681                 if (!iterator-&gt;next(m_exec, key)) {
1682                     setIteratorStack.removeLast();
1683                     JSObject* object = inputObjectStack.last();
1684                     ASSERT(jsDynamicCast&lt;JSSet*&gt;(vm, object));
1685                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
1686                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());
1687                     write(NonSetPropertiesTag);
1688                     indexStack.append(0);
1689                     goto objectStartVisitMember;
1690                 }
1691                 inValue = key;
1692                 stateStack.append(SetDataEndVisitKey);
1693                 goto stateUnknown;
1694             }
1695             case SetDataEndVisitKey: {
1696                 goto setDataStartVisitEntry;
1697             }
1698 
1699             stateUnknown:
1700             case StateUnknown: {
1701                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1702                 if (dumpIfTerminal(inValue, terminalCode)) {
1703                     if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1704                         return terminalCode;
1705                     break;
1706                 }
1707 
1708                 if (isArray(vm, inValue))
1709                     goto arrayStartState;
1710                 if (isMap(vm, inValue))
1711                     goto mapStartState;
1712                 if (isSet(vm, inValue))
1713                     goto setStartState;
1714                 goto objectStartState;
1715             }
1716         }
1717         if (stateStack.isEmpty())
1718             break;
1719 
1720         state = stateStack.last();
1721         stateStack.removeLast();
1722     }
1723     if (m_failed)
1724         return SerializationReturnCode::UnspecifiedError;
1725 
1726     return SerializationReturnCode::SuccessfullyCompleted;
1727 }
1728 
1729 class CloneDeserializer : CloneBase {
1730 public:
1731     static String deserializeString(const Vector&lt;uint8_t&gt;&amp; buffer)
1732     {
1733         if (buffer.isEmpty())
1734             return String();
1735         const uint8_t* ptr = buffer.begin();
1736         const uint8_t* end = buffer.end();
1737         uint32_t version;
1738         if (!readLittleEndian(ptr, end, version) || version &gt; CurrentVersion)
1739             return String();
1740         uint8_t tag;
1741         if (!readLittleEndian(ptr, end, tag) || tag != StringTag)
1742             return String();
1743         uint32_t length;
1744         if (!readLittleEndian(ptr, end, length))
1745             return String();
1746         bool is8Bit = length &amp; StringDataIs8BitFlag;
1747         length &amp;= ~StringDataIs8BitFlag;
1748         String str;
1749         if (!readString(ptr, end, str, length, is8Bit))
1750             return String();
1751         return str;
1752     }
1753 
1754     static DeserializationResult deserialize(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers, ArrayBufferContentsArray* arrayBufferContentsArray, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers
1755 #if ENABLE(WEBASSEMBLY)
1756         , WasmModuleArray* wasmModules
1757 #endif
1758         )
1759     {
1760         if (!buffer.size())
1761             return std::make_pair(jsNull(), SerializationReturnCode::UnspecifiedError);
1762         CloneDeserializer deserializer(exec, globalObject, messagePorts, arrayBufferContentsArray, buffer, blobURLs, blobFilePaths, sharedBuffers, WTFMove(imageBuffers)
1763 #if ENABLE(WEBASSEMBLY)
1764             , wasmModules
1765 #endif
1766             );
1767         if (!deserializer.isValid())
1768             return std::make_pair(JSValue(), SerializationReturnCode::ValidationError);
1769         return deserializer.deserialize();
1770     }
1771 
1772 private:
1773     struct CachedString {
1774         CachedString(const String&amp; string)
1775             : m_string(string)
1776         {
1777         }
1778 
1779         JSValue jsString(ExecState* exec)
1780         {
1781             if (!m_jsString)
1782                 m_jsString = JSC::jsString(exec-&gt;vm(), m_string);
1783             return m_jsString;
1784         }
1785         const String&amp; string() { return m_string; }
1786         String takeString() { return WTFMove(m_string); }
1787 
1788     private:
1789         String m_string;
1790         JSValue m_jsString;
1791     };
1792 
1793     struct CachedStringRef {
1794         CachedStringRef()
1795             : m_base(0)
1796             , m_index(0)
1797         {
1798         }
1799         CachedStringRef(Vector&lt;CachedString&gt;* base, size_t index)
1800             : m_base(base)
1801             , m_index(index)
1802         {
1803         }
1804 
1805         CachedString* operator-&gt;() { ASSERT(m_base); return &amp;m_base-&gt;at(m_index); }
1806 
1807     private:
1808         Vector&lt;CachedString&gt;* m_base;
1809         size_t m_index;
1810     };
1811 
1812     CloneDeserializer(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers,
1813 #if ENABLE(WEBASSEMBLY)
1814         WasmModuleArray* wasmModules,
1815 #endif
1816         const Vector&lt;uint8_t&gt;&amp; buffer)
1817         : CloneBase(exec)
1818         , m_globalObject(globalObject)
1819         , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
1820         , m_ptr(buffer.data())
1821         , m_end(buffer.data() + buffer.size())
1822         , m_version(0xFFFFFFFF)
1823         , m_messagePorts(messagePorts)
1824         , m_arrayBufferContents(arrayBufferContents)
1825         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
1826         , m_imageBuffers(WTFMove(imageBuffers))
1827         , m_imageBitmaps(m_imageBuffers.size())
1828 #if ENABLE(WEBASSEMBLY)
1829         , m_wasmModules(wasmModules)
1830 #endif
1831     {
1832         if (!read(m_version))
1833             m_version = 0xFFFFFFFF;
1834     }
1835 
1836     CloneDeserializer(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers
1837 #if ENABLE(WEBASSEMBLY)
1838         , WasmModuleArray* wasmModules
1839 #endif
1840         )
1841         : CloneBase(exec)
1842         , m_globalObject(globalObject)
1843         , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
1844         , m_ptr(buffer.data())
1845         , m_end(buffer.data() + buffer.size())
1846         , m_version(0xFFFFFFFF)
1847         , m_messagePorts(messagePorts)
1848         , m_arrayBufferContents(arrayBufferContents)
1849         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
1850         , m_blobURLs(blobURLs)
1851         , m_blobFilePaths(blobFilePaths)
1852         , m_sharedBuffers(sharedBuffers)
1853         , m_imageBuffers(WTFMove(imageBuffers))
1854         , m_imageBitmaps(m_imageBuffers.size())
1855 #if ENABLE(WEBASSEMBLY)
1856         , m_wasmModules(wasmModules)
1857 #endif
1858     {
1859         if (!read(m_version))
1860             m_version = 0xFFFFFFFF;
1861     }
1862 
1863     DeserializationResult deserialize();
1864 
1865     bool isValid() const { return m_version &lt;= CurrentVersion; }
1866 
1867     template &lt;typename T&gt; bool readLittleEndian(T&amp; value)
1868     {
1869         if (m_failed || !readLittleEndian(m_ptr, m_end, value)) {
1870             fail();
1871             return false;
1872         }
1873         return true;
1874     }
1875 #if ASSUME_LITTLE_ENDIAN
1876     template &lt;typename T&gt; static bool readLittleEndian(const uint8_t*&amp; ptr, const uint8_t* end, T&amp; value)
1877     {
1878         if (ptr &gt; end - sizeof(value))
1879             return false;
1880 
1881         if (sizeof(T) == 1)
1882             value = *ptr++;
1883         else {
1884             value = *reinterpret_cast&lt;const T*&gt;(ptr);
1885             ptr += sizeof(T);
1886         }
1887         return true;
1888     }
1889 #else
1890     template &lt;typename T&gt; static bool readLittleEndian(const uint8_t*&amp; ptr, const uint8_t* end, T&amp; value)
1891     {
1892         if (ptr &gt; end - sizeof(value))
1893             return false;
1894 
1895         if (sizeof(T) == 1)
1896             value = *ptr++;
1897         else {
1898             value = 0;
1899             for (unsigned i = 0; i &lt; sizeof(T); i++)
1900                 value += ((T)*ptr++) &lt;&lt; (i * 8);
1901         }
1902         return true;
1903     }
1904 #endif
1905 
1906     bool read(uint32_t&amp; i)
1907     {
1908         return readLittleEndian(i);
1909     }
1910 
1911     bool read(int32_t&amp; i)
1912     {
1913         return readLittleEndian(*reinterpret_cast&lt;uint32_t*&gt;(&amp;i));
1914     }
1915 
1916     bool read(uint16_t&amp; i)
1917     {
1918         return readLittleEndian(i);
1919     }
1920 
1921     bool read(uint8_t&amp; i)
1922     {
1923         return readLittleEndian(i);
1924     }
1925 
1926     bool read(double&amp; d)
1927     {
1928         union {
1929             double d;
1930             uint64_t i64;
1931         } u;
1932         if (!readLittleEndian(u.i64))
1933             return false;
1934         d = u.d;
1935         return true;
1936     }
1937 
1938     bool read(unsigned long long&amp; i)
1939     {
1940         return readLittleEndian(i);
1941     }
1942 
1943     bool readStringIndex(uint32_t&amp; i)
1944     {
1945         return readConstantPoolIndex(m_constantPool, i);
1946     }
1947 
1948     template &lt;class T&gt; bool readConstantPoolIndex(const T&amp; constantPool, uint32_t&amp; i)
1949     {
1950         if (constantPool.size() &lt;= 0xFF) {
1951             uint8_t i8;
1952             if (!read(i8))
1953                 return false;
1954             i = i8;
1955             return true;
1956         }
1957         if (constantPool.size() &lt;= 0xFFFF) {
1958             uint16_t i16;
1959             if (!read(i16))
1960                 return false;
1961             i = i16;
1962             return true;
1963         }
1964         return read(i);
1965     }
1966 
1967     static bool readString(const uint8_t*&amp; ptr, const uint8_t* end, String&amp; str, unsigned length, bool is8Bit)
1968     {
1969         if (length &gt;= std::numeric_limits&lt;int32_t&gt;::max() / sizeof(UChar))
1970             return false;
1971 
1972         if (is8Bit) {
1973             if ((end - ptr) &lt; static_cast&lt;int&gt;(length))
1974                 return false;
1975             str = String(reinterpret_cast&lt;const LChar*&gt;(ptr), length);
1976             ptr += length;
1977             return true;
1978         }
1979 
1980         unsigned size = length * sizeof(UChar);
1981         if ((end - ptr) &lt; static_cast&lt;int&gt;(size))
1982             return false;
1983 
1984 #if ASSUME_LITTLE_ENDIAN
1985         str = String(reinterpret_cast&lt;const UChar*&gt;(ptr), length);
1986         ptr += length * sizeof(UChar);
1987 #else
1988         Vector&lt;UChar&gt; buffer;
1989         buffer.reserveCapacity(length);
1990         for (unsigned i = 0; i &lt; length; i++) {
1991             uint16_t ch;
1992             readLittleEndian(ptr, end, ch);
1993             buffer.append(ch);
1994         }
1995         str = String::adopt(WTFMove(buffer));
1996 #endif
1997         return true;
1998     }
1999 
2000     bool readStringData(CachedStringRef&amp; cachedString)
2001     {
2002         bool scratch;
2003         return readStringData(cachedString, scratch);
2004     }
2005 
2006     bool readStringData(CachedStringRef&amp; cachedString, bool&amp; wasTerminator)
2007     {
2008         if (m_failed)
2009             return false;
2010         uint32_t length = 0;
2011         if (!read(length))
2012             return false;
2013         if (length == TerminatorTag) {
2014             wasTerminator = true;
2015             return false;
2016         }
2017         if (length == StringPoolTag) {
2018             unsigned index = 0;
2019             if (!readStringIndex(index)) {
2020                 fail();
2021                 return false;
2022             }
2023             if (index &gt;= m_constantPool.size()) {
2024                 fail();
2025                 return false;
2026             }
2027             cachedString = CachedStringRef(&amp;m_constantPool, index);
2028             return true;
2029         }
2030         bool is8Bit = length &amp; StringDataIs8BitFlag;
2031         length &amp;= ~StringDataIs8BitFlag;
2032         String str;
2033         if (!readString(m_ptr, m_end, str, length, is8Bit)) {
2034             fail();
2035             return false;
2036         }
2037         m_constantPool.append(str);
2038         cachedString = CachedStringRef(&amp;m_constantPool, m_constantPool.size() - 1);
2039         return true;
2040     }
2041 
2042     SerializationTag readTag()
2043     {
2044         if (m_ptr &gt;= m_end)
2045             return ErrorTag;
2046         return static_cast&lt;SerializationTag&gt;(*m_ptr++);
2047     }
2048 
2049     bool readArrayBufferViewSubtag(ArrayBufferViewSubtag&amp; tag)
2050     {
2051         if (m_ptr &gt;= m_end)
2052             return false;
2053         tag = static_cast&lt;ArrayBufferViewSubtag&gt;(*m_ptr++);
2054         return true;
2055     }
2056 
2057     void putProperty(JSObject* object, unsigned index, JSValue value)
2058     {
2059         object-&gt;putDirectIndex(m_exec, index, value);
2060     }
2061 
2062     void putProperty(JSObject* object, const Identifier&amp; property, JSValue value)
2063     {
2064         object-&gt;putDirectMayBeIndex(m_exec, property, value);
2065     }
2066 
2067     bool readFile(RefPtr&lt;File&gt;&amp; file)
2068     {
2069         CachedStringRef path;
2070         if (!readStringData(path))
2071             return false;
2072         CachedStringRef url;
2073         if (!readStringData(url))
2074             return false;
2075         CachedStringRef type;
2076         if (!readStringData(type))
2077             return false;
2078         CachedStringRef name;
2079         if (!readStringData(name))
2080             return false;
2081         Optional&lt;int64_t&gt; optionalLastModified;
2082         if (m_version &gt; 6) {
2083             double lastModified;
2084             if (!read(lastModified))
2085                 return false;
2086             if (lastModified &gt;= 0)
2087                 optionalLastModified = lastModified;
2088         }
2089 
2090         // If the blob URL for this file has an associated blob file path, prefer that one over the &quot;built-in&quot; path.
2091         String filePath = blobFilePathForBlobURL(url-&gt;string());
2092         if (filePath.isEmpty())
2093             filePath = path-&gt;string();
2094 
2095         if (m_isDOMGlobalObject)
2096             file = File::deserialize(jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject)-&gt;scriptExecutionContext()-&gt;sessionID(), filePath, URL(URL(), url-&gt;string()), type-&gt;string(), name-&gt;string(), optionalLastModified);
2097         return true;
2098     }
2099 
2100     bool readArrayBuffer(RefPtr&lt;ArrayBuffer&gt;&amp; arrayBuffer)
2101     {
2102         uint32_t length;
2103         if (!read(length))
2104             return false;
2105         if (m_ptr + length &gt; m_end)
2106             return false;
2107         arrayBuffer = ArrayBuffer::create(m_ptr, length);
2108         m_ptr += length;
2109         return true;
2110     }
2111 
2112     bool readArrayBufferView(VM&amp; vm, JSValue&amp; arrayBufferView)
2113     {
2114         ArrayBufferViewSubtag arrayBufferViewSubtag;
2115         if (!readArrayBufferViewSubtag(arrayBufferViewSubtag))
2116             return false;
2117         uint32_t byteOffset;
2118         if (!read(byteOffset))
2119             return false;
2120         uint32_t byteLength;
2121         if (!read(byteLength))
2122             return false;
2123         JSObject* arrayBufferObj = asObject(readTerminal());
2124         if (!arrayBufferObj || !arrayBufferObj-&gt;inherits&lt;JSArrayBuffer&gt;(vm))
2125             return false;
2126 
2127         unsigned elementSize = typedArrayElementSize(arrayBufferViewSubtag);
2128         if (!elementSize)
2129             return false;
2130         unsigned length = byteLength / elementSize;
2131         if (length * elementSize != byteLength)
2132             return false;
2133 
2134         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = toPossiblySharedArrayBuffer(vm, arrayBufferObj);
2135         switch (arrayBufferViewSubtag) {
2136         case DataViewTag:
2137             arrayBufferView = toJS(m_exec, m_globalObject, DataView::create(WTFMove(arrayBuffer), byteOffset, length).get());
2138             return true;
2139         case Int8ArrayTag:
2140             arrayBufferView = toJS(m_exec, m_globalObject, Int8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2141             return true;
2142         case Uint8ArrayTag:
2143             arrayBufferView = toJS(m_exec, m_globalObject, Uint8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2144             return true;
2145         case Uint8ClampedArrayTag:
2146             arrayBufferView = toJS(m_exec, m_globalObject, Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2147             return true;
2148         case Int16ArrayTag:
2149             arrayBufferView = toJS(m_exec, m_globalObject, Int16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2150             return true;
2151         case Uint16ArrayTag:
2152             arrayBufferView = toJS(m_exec, m_globalObject, Uint16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2153             return true;
2154         case Int32ArrayTag:
2155             arrayBufferView = toJS(m_exec, m_globalObject, Int32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2156             return true;
2157         case Uint32ArrayTag:
2158             arrayBufferView = toJS(m_exec, m_globalObject, Uint32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2159             return true;
2160         case Float32ArrayTag:
2161             arrayBufferView = toJS(m_exec, m_globalObject, Float32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2162             return true;
2163         case Float64ArrayTag:
2164             arrayBufferView = toJS(m_exec, m_globalObject, Float64Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2165             return true;
2166         default:
2167             return false;
2168         }
2169     }
2170 
2171     bool read(Vector&lt;uint8_t&gt;&amp; result)
2172     {
2173         ASSERT(result.isEmpty());
2174         uint32_t size;
2175         if (!read(size))
2176             return false;
2177         if (m_ptr + size &gt; m_end)
2178             return false;
2179         result.append(m_ptr, size);
2180         m_ptr += size;
2181         return true;
2182     }
2183 
2184 #if ENABLE(WEB_CRYPTO)
2185     bool read(CryptoAlgorithmIdentifier&amp; result)
2186     {
2187         uint8_t algorithmTag;
2188         if (!read(algorithmTag))
2189             return false;
2190         if (algorithmTag &gt; cryptoAlgorithmIdentifierTagMaximumValue)
2191             return false;
2192         switch (static_cast&lt;CryptoAlgorithmIdentifierTag&gt;(algorithmTag)) {
2193         case CryptoAlgorithmIdentifierTag::RSAES_PKCS1_v1_5:
2194             result = CryptoAlgorithmIdentifier::RSAES_PKCS1_v1_5;
2195             break;
2196         case CryptoAlgorithmIdentifierTag::RSASSA_PKCS1_v1_5:
2197             result = CryptoAlgorithmIdentifier::RSASSA_PKCS1_v1_5;
2198             break;
2199         case CryptoAlgorithmIdentifierTag::RSA_PSS:
2200             result = CryptoAlgorithmIdentifier::RSA_PSS;
2201             break;
2202         case CryptoAlgorithmIdentifierTag::RSA_OAEP:
2203             result = CryptoAlgorithmIdentifier::RSA_OAEP;
2204             break;
2205         case CryptoAlgorithmIdentifierTag::ECDSA:
2206             result = CryptoAlgorithmIdentifier::ECDSA;
2207             break;
2208         case CryptoAlgorithmIdentifierTag::ECDH:
2209             result = CryptoAlgorithmIdentifier::ECDH;
2210             break;
2211         case CryptoAlgorithmIdentifierTag::AES_CTR:
2212             result = CryptoAlgorithmIdentifier::AES_CTR;
2213             break;
2214         case CryptoAlgorithmIdentifierTag::AES_CBC:
2215             result = CryptoAlgorithmIdentifier::AES_CBC;
2216             break;
2217         case CryptoAlgorithmIdentifierTag::AES_GCM:
2218             result = CryptoAlgorithmIdentifier::AES_GCM;
2219             break;
2220         case CryptoAlgorithmIdentifierTag::AES_CFB:
2221             result = CryptoAlgorithmIdentifier::AES_CFB;
2222             break;
2223         case CryptoAlgorithmIdentifierTag::AES_KW:
2224             result = CryptoAlgorithmIdentifier::AES_KW;
2225             break;
2226         case CryptoAlgorithmIdentifierTag::HMAC:
2227             result = CryptoAlgorithmIdentifier::HMAC;
2228             break;
2229         case CryptoAlgorithmIdentifierTag::SHA_1:
2230             result = CryptoAlgorithmIdentifier::SHA_1;
2231             break;
2232         case CryptoAlgorithmIdentifierTag::SHA_224:
2233             result = CryptoAlgorithmIdentifier::SHA_224;
2234             break;
2235         case CryptoAlgorithmIdentifierTag::SHA_256:
2236             result = CryptoAlgorithmIdentifier::SHA_256;
2237             break;
2238         case CryptoAlgorithmIdentifierTag::SHA_384:
2239             result = CryptoAlgorithmIdentifier::SHA_384;
2240             break;
2241         case CryptoAlgorithmIdentifierTag::SHA_512:
2242             result = CryptoAlgorithmIdentifier::SHA_512;
2243             break;
2244         case CryptoAlgorithmIdentifierTag::HKDF:
2245             result = CryptoAlgorithmIdentifier::HKDF;
2246             break;
2247         case CryptoAlgorithmIdentifierTag::PBKDF2:
2248             result = CryptoAlgorithmIdentifier::PBKDF2;
2249             break;
2250         }
2251         return true;
2252     }
2253 
2254     bool read(CryptoKeyClassSubtag&amp; result)
2255     {
2256         uint8_t tag;
2257         if (!read(tag))
2258             return false;
2259         if (tag &gt; cryptoKeyClassSubtagMaximumValue)
2260             return false;
2261         result = static_cast&lt;CryptoKeyClassSubtag&gt;(tag);
2262         return true;
2263     }
2264 
2265     bool read(CryptoKeyUsageTag&amp; result)
2266     {
2267         uint8_t tag;
2268         if (!read(tag))
2269             return false;
2270         if (tag &gt; cryptoKeyUsageTagMaximumValue)
2271             return false;
2272         result = static_cast&lt;CryptoKeyUsageTag&gt;(tag);
2273         return true;
2274     }
2275 
2276     bool read(CryptoKeyAsymmetricTypeSubtag&amp; result)
2277     {
2278         uint8_t tag;
2279         if (!read(tag))
2280             return false;
2281         if (tag &gt; cryptoKeyAsymmetricTypeSubtagMaximumValue)
2282             return false;
2283         result = static_cast&lt;CryptoKeyAsymmetricTypeSubtag&gt;(tag);
2284         return true;
2285     }
2286 
2287     bool readHMACKey(bool extractable, CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2288     {
2289         Vector&lt;uint8_t&gt; keyData;
2290         if (!read(keyData))
2291             return false;
2292         CryptoAlgorithmIdentifier hash;
2293         if (!read(hash))
2294             return false;
2295         result = CryptoKeyHMAC::importRaw(0, hash, WTFMove(keyData), extractable, usages);
2296         return true;
2297     }
2298 
2299     bool readAESKey(bool extractable, CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2300     {
2301         CryptoAlgorithmIdentifier algorithm;
2302         if (!read(algorithm))
2303             return false;
2304         if (!CryptoKeyAES::isValidAESAlgorithm(algorithm))
2305             return false;
2306         Vector&lt;uint8_t&gt; keyData;
2307         if (!read(keyData))
2308             return false;
2309         result = CryptoKeyAES::importRaw(algorithm, WTFMove(keyData), extractable, usages);
2310         return true;
2311     }
2312 
2313     bool readRSAKey(bool extractable, CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2314     {
2315         CryptoAlgorithmIdentifier algorithm;
2316         if (!read(algorithm))
2317             return false;
2318 
2319         int32_t isRestrictedToHash;
2320         CryptoAlgorithmIdentifier hash;
2321         if (!read(isRestrictedToHash))
2322             return false;
2323         if (isRestrictedToHash &amp;&amp; !read(hash))
2324             return false;
2325 
2326         CryptoKeyAsymmetricTypeSubtag type;
2327         if (!read(type))
2328             return false;
2329 
2330         Vector&lt;uint8_t&gt; modulus;
2331         if (!read(modulus))
2332             return false;
2333         Vector&lt;uint8_t&gt; exponent;
2334         if (!read(exponent))
2335             return false;
2336 
2337         if (type == CryptoKeyAsymmetricTypeSubtag::Public) {
2338             auto keyData = CryptoKeyRSAComponents::createPublic(modulus, exponent);
2339             auto key = CryptoKeyRSA::create(algorithm, hash, isRestrictedToHash, *keyData, extractable, usages);
2340             result = WTFMove(key);
2341             return true;
2342         }
2343 
2344         Vector&lt;uint8_t&gt; privateExponent;
2345         if (!read(privateExponent))
2346             return false;
2347 
2348         uint32_t primeCount;
2349         if (!read(primeCount))
2350             return false;
2351 
2352         if (!primeCount) {
2353             auto keyData = CryptoKeyRSAComponents::createPrivate(modulus, exponent, privateExponent);
2354             auto key = CryptoKeyRSA::create(algorithm, hash, isRestrictedToHash, *keyData, extractable, usages);
2355             result = WTFMove(key);
2356             return true;
2357         }
2358 
2359         if (primeCount &lt; 2)
2360             return false;
2361 
2362         CryptoKeyRSAComponents::PrimeInfo firstPrimeInfo;
2363         CryptoKeyRSAComponents::PrimeInfo secondPrimeInfo;
2364         Vector&lt;CryptoKeyRSAComponents::PrimeInfo&gt; otherPrimeInfos(primeCount - 2);
2365 
2366         if (!read(firstPrimeInfo.primeFactor))
2367             return false;
2368         if (!read(firstPrimeInfo.factorCRTExponent))
2369             return false;
2370         if (!read(secondPrimeInfo.primeFactor))
2371             return false;
2372         if (!read(secondPrimeInfo.factorCRTExponent))
2373             return false;
2374         if (!read(secondPrimeInfo.factorCRTCoefficient))
2375             return false;
2376         for (unsigned i = 2; i &lt; primeCount; ++i) {
2377             if (!read(otherPrimeInfos[i].primeFactor))
2378                 return false;
2379             if (!read(otherPrimeInfos[i].factorCRTExponent))
2380                 return false;
2381             if (!read(otherPrimeInfos[i].factorCRTCoefficient))
2382                 return false;
2383         }
2384 
2385         auto keyData = CryptoKeyRSAComponents::createPrivateWithAdditionalData(modulus, exponent, privateExponent, firstPrimeInfo, secondPrimeInfo, otherPrimeInfos);
2386         auto key = CryptoKeyRSA::create(algorithm, hash, isRestrictedToHash, *keyData, extractable, usages);
2387         result = WTFMove(key);
2388         return true;
2389     }
2390 
2391     bool readECKey(bool extractable, CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2392     {
2393         CryptoAlgorithmIdentifier algorithm;
2394         if (!read(algorithm))
2395             return false;
2396         if (!CryptoKeyEC::isValidECAlgorithm(algorithm))
2397             return false;
2398         CachedStringRef curve;
2399         if (!readStringData(curve))
2400             return false;
2401         CryptoKeyAsymmetricTypeSubtag type;
2402         if (!read(type))
2403             return false;
2404         Vector&lt;uint8_t&gt; keyData;
2405         if (!read(keyData))
2406             return false;
2407 
2408         switch (type) {
2409         case CryptoKeyAsymmetricTypeSubtag::Public:
2410             result = CryptoKeyEC::importRaw(algorithm, curve-&gt;string(), WTFMove(keyData), extractable, usages);
2411             break;
2412         case CryptoKeyAsymmetricTypeSubtag::Private:
2413             result = CryptoKeyEC::importPkcs8(algorithm, curve-&gt;string(), WTFMove(keyData), extractable, usages);
2414             break;
2415         }
2416 
2417         return true;
2418     }
2419 
2420     bool readRawKey(CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2421     {
2422         CryptoAlgorithmIdentifier algorithm;
2423         if (!read(algorithm))
2424             return false;
2425         Vector&lt;uint8_t&gt; keyData;
2426         if (!read(keyData))
2427             return false;
2428         result = CryptoKeyRaw::create(algorithm, WTFMove(keyData), usages);
2429         return true;
2430     }
2431 
2432     bool readCryptoKey(JSValue&amp; cryptoKey)
2433     {
2434         uint32_t keyFormatVersion;
2435         if (!read(keyFormatVersion) || keyFormatVersion &gt; currentKeyFormatVersion)
2436             return false;
2437 
2438         int32_t extractable;
2439         if (!read(extractable))
2440             return false;
2441 
2442         uint32_t usagesCount;
2443         if (!read(usagesCount))
2444             return false;
2445 
2446         CryptoKeyUsageBitmap usages = 0;
2447         for (uint32_t i = 0; i &lt; usagesCount; ++i) {
2448             CryptoKeyUsageTag usage;
2449             if (!read(usage))
2450                 return false;
2451             switch (usage) {
2452             case CryptoKeyUsageTag::Encrypt:
2453                 usages |= CryptoKeyUsageEncrypt;
2454                 break;
2455             case CryptoKeyUsageTag::Decrypt:
2456                 usages |= CryptoKeyUsageDecrypt;
2457                 break;
2458             case CryptoKeyUsageTag::Sign:
2459                 usages |= CryptoKeyUsageSign;
2460                 break;
2461             case CryptoKeyUsageTag::Verify:
2462                 usages |= CryptoKeyUsageVerify;
2463                 break;
2464             case CryptoKeyUsageTag::DeriveKey:
2465                 usages |= CryptoKeyUsageDeriveKey;
2466                 break;
2467             case CryptoKeyUsageTag::DeriveBits:
2468                 usages |= CryptoKeyUsageDeriveBits;
2469                 break;
2470             case CryptoKeyUsageTag::WrapKey:
2471                 usages |= CryptoKeyUsageWrapKey;
2472                 break;
2473             case CryptoKeyUsageTag::UnwrapKey:
2474                 usages |= CryptoKeyUsageUnwrapKey;
2475                 break;
2476             }
2477         }
2478 
2479         CryptoKeyClassSubtag cryptoKeyClass;
2480         if (!read(cryptoKeyClass))
2481             return false;
2482         RefPtr&lt;CryptoKey&gt; result;
2483         switch (cryptoKeyClass) {
2484         case CryptoKeyClassSubtag::HMAC:
2485             if (!readHMACKey(extractable, usages, result))
2486                 return false;
2487             break;
2488         case CryptoKeyClassSubtag::AES:
2489             if (!readAESKey(extractable, usages, result))
2490                 return false;
2491             break;
2492         case CryptoKeyClassSubtag::RSA:
2493             if (!readRSAKey(extractable, usages, result))
2494                 return false;
2495             break;
2496         case CryptoKeyClassSubtag::EC:
2497             if (!readECKey(extractable, usages, result))
2498                 return false;
2499             break;
2500         case CryptoKeyClassSubtag::Raw:
2501             if (!readRawKey(usages, result))
2502                 return false;
2503             break;
2504         }
2505         cryptoKey = getJSValue(result.get());
2506         return true;
2507     }
2508 #endif
2509 
2510     template&lt;class T&gt;
2511     JSValue getJSValue(T* nativeObj)
2512     {
2513         return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), nativeObj);
2514     }
2515 
2516     template&lt;class T&gt;
2517     JSValue getJSValue(T&amp; nativeObj)
2518     {
2519         return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), nativeObj);
2520     }
2521 
2522     template&lt;class T&gt;
2523     JSValue readDOMPoint()
2524     {
2525         double x;
2526         if (!read(x))
2527             return { };
2528         double y;
2529         if (!read(y))
2530             return { };
2531         double z;
2532         if (!read(z))
2533             return { };
2534         double w;
2535         if (!read(w))
2536             return { };
2537 
2538         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, z, w));
2539     }
2540 
2541     template&lt;class T&gt;
2542     JSValue readDOMMatrix()
2543     {
2544         uint8_t is2D;
2545         if (!read(is2D))
2546             return { };
2547 
2548         if (is2D) {
2549             double m11;
2550             if (!read(m11))
2551                 return { };
2552             double m12;
2553             if (!read(m12))
2554                 return { };
2555             double m21;
2556             if (!read(m21))
2557                 return { };
2558             double m22;
2559             if (!read(m22))
2560                 return { };
2561             double m41;
2562             if (!read(m41))
2563                 return { };
2564             double m42;
2565             if (!read(m42))
2566                 return { };
2567 
2568             TransformationMatrix matrix(m11, m12, m21, m22, m41, m42);
2569             return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::Yes));
2570         } else {
2571             double m11;
2572             if (!read(m11))
2573                 return { };
2574             double m12;
2575             if (!read(m12))
2576                 return { };
2577             double m13;
2578             if (!read(m13))
2579                 return { };
2580             double m14;
2581             if (!read(m14))
2582                 return { };
2583             double m21;
2584             if (!read(m21))
2585                 return { };
2586             double m22;
2587             if (!read(m22))
2588                 return { };
2589             double m23;
2590             if (!read(m23))
2591                 return { };
2592             double m24;
2593             if (!read(m24))
2594                 return { };
2595             double m31;
2596             if (!read(m31))
2597                 return { };
2598             double m32;
2599             if (!read(m32))
2600                 return { };
2601             double m33;
2602             if (!read(m33))
2603                 return { };
2604             double m34;
2605             if (!read(m34))
2606                 return { };
2607             double m41;
2608             if (!read(m41))
2609                 return { };
2610             double m42;
2611             if (!read(m42))
2612                 return { };
2613             double m43;
2614             if (!read(m43))
2615                 return { };
2616             double m44;
2617             if (!read(m44))
2618                 return { };
2619 
2620             TransformationMatrix matrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44);
2621             return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::No));
2622         }
2623     }
2624 
2625     template&lt;class T&gt;
2626     JSValue readDOMRect()
2627     {
2628         double x;
2629         if (!read(x))
2630             return { };
2631         double y;
2632         if (!read(y))
2633             return { };
2634         double width;
2635         if (!read(width))
2636             return { };
2637         double height;
2638         if (!read(height))
2639             return { };
2640 
2641         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, width, height));
2642     }
2643 
2644     Optional&lt;DOMPointInit&gt; readDOMPointInit()
2645     {
2646         DOMPointInit point;
2647         if (!read(point.x))
2648             return WTF::nullopt;
2649         if (!read(point.y))
2650             return WTF::nullopt;
2651         if (!read(point.z))
2652             return WTF::nullopt;
2653         if (!read(point.w))
2654             return WTF::nullopt;
2655 
2656         return point;
2657     }
2658 
2659     JSValue readDOMQuad()
2660     {
2661         auto p1 = readDOMPointInit();
2662         if (!p1)
2663             return JSValue();
2664         auto p2 = readDOMPointInit();
2665         if (!p2)
2666             return JSValue();
2667         auto p3 = readDOMPointInit();
2668         if (!p3)
2669             return JSValue();
2670         auto p4 = readDOMPointInit();
2671         if (!p4)
2672             return JSValue();
2673 
2674         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), DOMQuad::create(p1.value(), p2.value(), p3.value(), p4.value()));
2675     }
2676 
2677     JSValue readImageBitmap()
2678     {
2679         uint32_t index;
2680         bool indexSuccessfullyRead = read(index);
2681         if (!indexSuccessfullyRead || index &gt;= m_imageBuffers.size()) {
2682             fail();
2683             return JSValue();
2684         }
2685 
2686         if (!m_imageBitmaps[index])
2687             m_imageBitmaps[index] = ImageBitmap::create(WTFMove(m_imageBuffers.at(index)));
2688 
2689         auto bitmap = m_imageBitmaps[index].get();
2690         return getJSValue(bitmap);
2691     }
2692 
2693 #if ENABLE(WEB_RTC)
2694     JSValue readRTCCertificate()
2695     {
2696         double expires;
2697         if (!read(expires)) {
2698             fail();
2699             return JSValue();
2700         }
2701         CachedStringRef certificate;
2702         if (!readStringData(certificate)) {
2703             fail();
2704             return JSValue();
2705         }
2706         CachedStringRef origin;
2707         if (!readStringData(origin)) {
2708             fail();
2709             return JSValue();
2710         }
2711         CachedStringRef keyedMaterial;
2712         if (!readStringData(keyedMaterial)) {
2713             fail();
2714             return JSValue();
2715         }
2716         unsigned size = 0;
2717         if (!read(size))
2718             return JSValue();
2719 
2720         Vector&lt;RTCCertificate::DtlsFingerprint&gt; fingerprints;
2721         fingerprints.reserveInitialCapacity(size);
2722         for (unsigned i = 0; i &lt; size; i++) {
2723             CachedStringRef algorithm;
2724             if (!readStringData(algorithm))
2725                 return JSValue();
2726             CachedStringRef value;
2727             if (!readStringData(value))
2728                 return JSValue();
2729             fingerprints.uncheckedAppend(RTCCertificate::DtlsFingerprint { algorithm-&gt;string(), value-&gt;string() });
2730         }
2731 
2732         if (!m_isDOMGlobalObject)
2733             return constructEmptyObject(m_exec, m_globalObject-&gt;objectPrototype());
2734 
2735         auto rtcCertificate = RTCCertificate::create(SecurityOrigin::createFromString(origin-&gt;string()), expires, WTFMove(fingerprints), certificate-&gt;takeString(), keyedMaterial-&gt;takeString());
2736         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), WTFMove(rtcCertificate));
2737     }
2738 #endif
2739 
2740     JSValue readTerminal()
2741     {
2742         SerializationTag tag = readTag();
2743         switch (tag) {
2744         case UndefinedTag:
2745             return jsUndefined();
2746         case NullTag:
2747             return jsNull();
2748         case IntTag: {
2749             int32_t i;
2750             if (!read(i))
2751                 return JSValue();
2752             return jsNumber(i);
2753         }
2754         case ZeroTag:
2755             return jsNumber(0);
2756         case OneTag:
2757             return jsNumber(1);
2758         case FalseTag:
2759             return jsBoolean(false);
2760         case TrueTag:
2761             return jsBoolean(true);
2762         case FalseObjectTag: {
2763             BooleanObject* obj = BooleanObject::create(m_exec-&gt;vm(), m_globalObject-&gt;booleanObjectStructure());
2764             obj-&gt;setInternalValue(m_exec-&gt;vm(), jsBoolean(false));
2765             m_gcBuffer.appendWithCrashOnOverflow(obj);
2766             return obj;
2767         }
2768         case TrueObjectTag: {
2769             BooleanObject* obj = BooleanObject::create(m_exec-&gt;vm(), m_globalObject-&gt;booleanObjectStructure());
2770             obj-&gt;setInternalValue(m_exec-&gt;vm(), jsBoolean(true));
2771             m_gcBuffer.appendWithCrashOnOverflow(obj);
2772             return obj;
2773         }
2774         case DoubleTag: {
2775             double d;
2776             if (!read(d))
2777                 return JSValue();
2778             return jsNumber(d);
2779         }
2780         case NumberObjectTag: {
2781             double d;
2782             if (!read(d))
2783                 return JSValue();
2784             NumberObject* obj = constructNumber(m_exec, m_globalObject, jsNumber(d));
2785             m_gcBuffer.appendWithCrashOnOverflow(obj);
2786             return obj;
2787         }
2788         case DateTag: {
2789             double d;
2790             if (!read(d))
2791                 return JSValue();
2792             return DateInstance::create(m_exec-&gt;vm(), m_globalObject-&gt;dateStructure(), d);
2793         }
2794         case FileTag: {
2795             RefPtr&lt;File&gt; file;
2796             if (!readFile(file))
2797                 return JSValue();
2798             if (!m_isDOMGlobalObject)
2799                 return jsNull();
2800             return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), file.get());
2801         }
2802         case FileListTag: {
2803             unsigned length = 0;
2804             if (!read(length))
2805                 return JSValue();
2806             Vector&lt;Ref&lt;File&gt;&gt; files;
2807             for (unsigned i = 0; i &lt; length; i++) {
2808                 RefPtr&lt;File&gt; file;
2809                 if (!readFile(file))
2810                     return JSValue();
2811                 if (m_isDOMGlobalObject)
2812                     files.append(file.releaseNonNull());
2813             }
2814             if (!m_isDOMGlobalObject)
2815                 return jsNull();
2816             return getJSValue(FileList::create(WTFMove(files)).get());
2817         }
2818         case ImageDataTag: {
2819             uint32_t width;
2820             if (!read(width))
2821                 return JSValue();
2822             uint32_t height;
2823             if (!read(height))
2824                 return JSValue();
2825             uint32_t length;
2826             if (!read(length))
2827                 return JSValue();
2828             if (static_cast&lt;uint32_t&gt;(m_end - m_ptr) &lt; length) {
2829                 fail();
2830                 return JSValue();
2831             }
2832             if (!m_isDOMGlobalObject) {
2833                 m_ptr += length;
2834                 return jsNull();
2835             }
2836             IntSize imageSize(width, height);
2837             RELEASE_ASSERT(!length || (imageSize.area() * 4).unsafeGet() &lt;= length);
2838             auto result = ImageData::create(imageSize);
2839             if (!result) {
2840                 fail();
2841                 return JSValue();
2842             }
2843             if (length)
2844                 memcpy(result-&gt;data()-&gt;data(), m_ptr, length);
2845             else
2846                 result-&gt;data()-&gt;zeroFill();
2847             m_ptr += length;
2848             return getJSValue(result.get());
2849         }
2850         case BlobTag: {
2851             CachedStringRef url;
2852             if (!readStringData(url))
2853                 return JSValue();
2854             CachedStringRef type;
2855             if (!readStringData(type))
2856                 return JSValue();
2857             unsigned long long size = 0;
2858             if (!read(size))
2859                 return JSValue();
2860             if (!m_isDOMGlobalObject)
2861                 return jsNull();
2862             return getJSValue(Blob::deserialize(jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject)-&gt;scriptExecutionContext()-&gt;sessionID(), URL(URL(), url-&gt;string()), type-&gt;string(), size, blobFilePathForBlobURL(url-&gt;string())).get());
2863         }
2864         case StringTag: {
2865             CachedStringRef cachedString;
2866             if (!readStringData(cachedString))
2867                 return JSValue();
2868             return cachedString-&gt;jsString(m_exec);
2869         }
2870         case EmptyStringTag:
2871             return jsEmptyString(m_exec-&gt;vm());
2872         case StringObjectTag: {
2873             CachedStringRef cachedString;
2874             if (!readStringData(cachedString))
2875                 return JSValue();
2876             StringObject* obj = constructString(m_exec-&gt;vm(), m_globalObject, cachedString-&gt;jsString(m_exec));
2877             m_gcBuffer.appendWithCrashOnOverflow(obj);
2878             return obj;
2879         }
2880         case EmptyStringObjectTag: {
2881             VM&amp; vm = m_exec-&gt;vm();
2882             StringObject* obj = constructString(vm, m_globalObject, jsEmptyString(vm));
2883             m_gcBuffer.appendWithCrashOnOverflow(obj);
2884             return obj;
2885         }
2886         case RegExpTag: {
2887             CachedStringRef pattern;
2888             if (!readStringData(pattern))
2889                 return JSValue();
2890             CachedStringRef flags;
2891             if (!readStringData(flags))
2892                 return JSValue();
2893             auto reFlags = Yarr::parseFlags(flags-&gt;string());
2894             ASSERT(reFlags.hasValue());
2895             VM&amp; vm = m_exec-&gt;vm();
2896             RegExp* regExp = RegExp::create(vm, pattern-&gt;string(), reFlags.value());
2897             return RegExpObject::create(vm, m_globalObject-&gt;regExpStructure(), regExp);
2898         }
2899         case ObjectReferenceTag: {
2900             unsigned index = 0;
2901             if (!readConstantPoolIndex(m_gcBuffer, index)) {
2902                 fail();
2903                 return JSValue();
2904             }
2905             return m_gcBuffer.at(index);
2906         }
2907         case MessagePortReferenceTag: {
2908             uint32_t index;
2909             bool indexSuccessfullyRead = read(index);
2910             if (!indexSuccessfullyRead || index &gt;= m_messagePorts.size()) {
2911                 fail();
2912                 return JSValue();
2913             }
2914             return getJSValue(m_messagePorts[index].get());
2915         }
2916 #if ENABLE(WEBASSEMBLY)
2917         case WasmModuleTag: {
2918             uint32_t index;
2919             bool indexSuccessfullyRead = read(index);
2920             if (!indexSuccessfullyRead || !m_wasmModules || index &gt;= m_wasmModules-&gt;size()) {
2921                 fail();
2922                 return JSValue();
2923             }
2924             auto scope = DECLARE_THROW_SCOPE(m_exec-&gt;vm());
2925             JSValue result = JSC::JSWebAssemblyModule::createStub(m_exec-&gt;vm(), m_exec, m_globalObject-&gt;webAssemblyModuleStructure(), m_wasmModules-&gt;at(index));
2926             // Since we are cloning a JSWebAssemblyModule, it&#39;s impossible for that
2927             // module to not have been a valid module. Therefore, createStub should
2928             // not trow.
2929             scope.releaseAssertNoException();
2930             m_gcBuffer.appendWithCrashOnOverflow(result);
2931             return result;
2932         }
2933 #endif
2934         case ArrayBufferTag: {
2935             RefPtr&lt;ArrayBuffer&gt; arrayBuffer;
2936             if (!readArrayBuffer(arrayBuffer)) {
2937                 fail();
2938                 return JSValue();
2939             }
2940             Structure* structure = m_globalObject-&gt;arrayBufferStructure(arrayBuffer-&gt;sharingMode());
2941             // A crazy RuntimeFlags mismatch could mean that we are not equipped to handle shared
2942             // array buffers while the sender is. In that case, we would see a null structure here.
2943             if (!structure) {
2944                 fail();
2945                 return JSValue();
2946             }
2947             JSValue result = JSArrayBuffer::create(m_exec-&gt;vm(), structure, WTFMove(arrayBuffer));
2948             m_gcBuffer.appendWithCrashOnOverflow(result);
2949             return result;
2950         }
2951         case ArrayBufferTransferTag: {
2952             uint32_t index;
2953             bool indexSuccessfullyRead = read(index);
2954             if (!indexSuccessfullyRead || index &gt;= m_arrayBuffers.size()) {
2955                 fail();
2956                 return JSValue();
2957             }
2958 
2959             if (!m_arrayBuffers[index])
2960                 m_arrayBuffers[index] = ArrayBuffer::create(WTFMove(m_arrayBufferContents-&gt;at(index)));
2961 
2962             return getJSValue(m_arrayBuffers[index].get());
2963         }
2964         case SharedArrayBufferTag: {
2965             uint32_t index = UINT_MAX;
2966             bool indexSuccessfullyRead = read(index);
2967             if (!indexSuccessfullyRead || !m_sharedBuffers || index &gt;= m_sharedBuffers-&gt;size()) {
2968                 fail();
2969                 return JSValue();
2970             }
2971 
2972             RELEASE_ASSERT(m_sharedBuffers-&gt;at(index));
2973             auto buffer = ArrayBuffer::create(WTFMove(m_sharedBuffers-&gt;at(index)));
2974             JSValue result = getJSValue(buffer.get());
2975             m_gcBuffer.appendWithCrashOnOverflow(result);
2976             return result;
2977         }
2978         case ArrayBufferViewTag: {
2979             JSValue arrayBufferView;
2980             if (!readArrayBufferView(m_exec-&gt;vm(), arrayBufferView)) {
2981                 fail();
2982                 return JSValue();
2983             }
2984             m_gcBuffer.appendWithCrashOnOverflow(arrayBufferView);
2985             return arrayBufferView;
2986         }
2987 #if ENABLE(WEB_CRYPTO)
2988         case CryptoKeyTag: {
2989             Vector&lt;uint8_t&gt; wrappedKey;
2990             if (!read(wrappedKey)) {
2991                 fail();
2992                 return JSValue();
2993             }
2994             Vector&lt;uint8_t&gt; serializedKey;
2995             if (!unwrapCryptoKey(m_exec, wrappedKey, serializedKey)) {
2996                 fail();
2997                 return JSValue();
2998             }
2999             JSValue cryptoKey;
3000             Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
3001             CloneDeserializer rawKeyDeserializer(m_exec, m_globalObject, dummyMessagePorts, nullptr, { },
3002 #if ENABLE(WEBASSEMBLY)
3003                 nullptr,
3004 #endif
3005                 serializedKey);
3006             if (!rawKeyDeserializer.readCryptoKey(cryptoKey)) {
3007                 fail();
3008                 return JSValue();
3009             }
3010             m_gcBuffer.appendWithCrashOnOverflow(cryptoKey);
3011             return cryptoKey;
3012         }
3013 #endif
3014         case DOMPointReadOnlyTag:
3015             return readDOMPoint&lt;DOMPointReadOnly&gt;();
3016         case DOMPointTag:
3017             return readDOMPoint&lt;DOMPoint&gt;();
3018         case DOMRectReadOnlyTag:
3019             return readDOMRect&lt;DOMRectReadOnly&gt;();
3020         case DOMRectTag:
3021             return readDOMRect&lt;DOMRect&gt;();
3022         case DOMMatrixReadOnlyTag:
3023             return readDOMMatrix&lt;DOMMatrixReadOnly&gt;();
3024         case DOMMatrixTag:
3025             return readDOMMatrix&lt;DOMMatrix&gt;();
3026         case DOMQuadTag:
3027             return readDOMQuad();
3028         case ImageBitmapTransferTag:
3029             return readImageBitmap();
3030 #if ENABLE(WEB_RTC)
3031         case RTCCertificateTag:
3032             return readRTCCertificate();
3033 
3034 #endif
3035         default:
3036             m_ptr--; // Push the tag back
3037             return JSValue();
3038         }
3039     }
3040 
3041     template&lt;SerializationTag Tag&gt;
3042     bool consumeCollectionDataTerminationIfPossible()
3043     {
3044         if (readTag() == Tag)
3045             return true;
3046         m_ptr--;
3047         return false;
3048     }
3049 
3050     JSGlobalObject* m_globalObject;
3051     bool m_isDOMGlobalObject;
3052     const uint8_t* m_ptr;
3053     const uint8_t* m_end;
3054     unsigned m_version;
3055     Vector&lt;CachedString&gt; m_constantPool;
3056     const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; m_messagePorts;
3057     ArrayBufferContentsArray* m_arrayBufferContents;
3058     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; m_arrayBuffers;
3059     Vector&lt;String&gt; m_blobURLs;
3060     Vector&lt;String&gt; m_blobFilePaths;
3061     ArrayBufferContentsArray* m_sharedBuffers;
3062     Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt; m_imageBuffers;
3063     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; m_imageBitmaps;
3064 #if ENABLE(WEBASSEMBLY)
3065     WasmModuleArray* m_wasmModules;
3066 #endif
3067 
3068     String blobFilePathForBlobURL(const String&amp; blobURL)
3069     {
3070         size_t i = 0;
3071         for (; i &lt; m_blobURLs.size(); ++i) {
3072             if (m_blobURLs[i] == blobURL)
3073                 break;
3074         }
3075 
3076         return i &lt; m_blobURLs.size() ? m_blobFilePaths[i] : String();
3077     }
3078 };
3079 
3080 DeserializationResult CloneDeserializer::deserialize()
3081 {
3082     VM&amp; vm = m_exec-&gt;vm();
3083     auto scope = DECLARE_THROW_SCOPE(vm);
3084 
3085     Vector&lt;uint32_t, 16&gt; indexStack;
3086     Vector&lt;Identifier, 16&gt; propertyNameStack;
3087     Vector&lt;JSObject*, 32&gt; outputObjectStack;
3088     Vector&lt;JSValue, 4&gt; mapKeyStack;
3089     Vector&lt;JSMap*, 4&gt; mapStack;
3090     Vector&lt;JSSet*, 4&gt; setStack;
3091     Vector&lt;WalkerState, 16&gt; stateStack;
3092     WalkerState state = StateUnknown;
3093     JSValue outValue;
3094 
3095     while (1) {
3096         switch (state) {
3097         arrayStartState:
3098         case ArrayStartState: {
3099             uint32_t length;
3100             if (!read(length)) {
3101                 fail();
3102                 goto error;
3103             }
3104             JSArray* outArray = constructEmptyArray(m_exec, 0, m_globalObject, length);
3105             if (UNLIKELY(scope.exception()))
3106                 goto error;
3107             m_gcBuffer.appendWithCrashOnOverflow(outArray);
3108             outputObjectStack.append(outArray);
3109         }
3110         arrayStartVisitMember:
3111         FALLTHROUGH;
3112         case ArrayStartVisitMember: {
3113             uint32_t index;
3114             if (!read(index)) {
3115                 fail();
3116                 goto error;
3117             }
3118             if (index == TerminatorTag) {
3119                 JSObject* outArray = outputObjectStack.last();
3120                 outValue = outArray;
3121                 outputObjectStack.removeLast();
3122                 break;
3123             } else if (index == NonIndexPropertiesTag) {
3124                 goto objectStartVisitMember;
3125             }
3126 
3127             if (JSValue terminal = readTerminal()) {
3128                 putProperty(outputObjectStack.last(), index, terminal);
3129                 goto arrayStartVisitMember;
3130             }
3131             if (m_failed)
3132                 goto error;
3133             indexStack.append(index);
3134             stateStack.append(ArrayEndVisitMember);
3135             goto stateUnknown;
3136         }
3137         case ArrayEndVisitMember: {
3138             JSObject* outArray = outputObjectStack.last();
3139             putProperty(outArray, indexStack.last(), outValue);
3140             indexStack.removeLast();
3141             goto arrayStartVisitMember;
3142         }
3143         objectStartState:
3144         case ObjectStartState: {
3145             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3146                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
3147             JSObject* outObject = constructEmptyObject(m_exec, m_globalObject-&gt;objectPrototype());
3148             m_gcBuffer.appendWithCrashOnOverflow(outObject);
3149             outputObjectStack.append(outObject);
3150         }
3151         objectStartVisitMember:
3152         FALLTHROUGH;
3153         case ObjectStartVisitMember: {
3154             CachedStringRef cachedString;
3155             bool wasTerminator = false;
3156             if (!readStringData(cachedString, wasTerminator)) {
3157                 if (!wasTerminator)
3158                     goto error;
3159 
3160                 JSObject* outObject = outputObjectStack.last();
3161                 outValue = outObject;
3162                 outputObjectStack.removeLast();
3163                 break;
3164             }
3165 
3166             if (JSValue terminal = readTerminal()) {
3167                 putProperty(outputObjectStack.last(), Identifier::fromString(vm, cachedString-&gt;string()), terminal);
3168                 goto objectStartVisitMember;
3169             }
3170             stateStack.append(ObjectEndVisitMember);
3171             propertyNameStack.append(Identifier::fromString(vm, cachedString-&gt;string()));
3172             goto stateUnknown;
3173         }
3174         case ObjectEndVisitMember: {
3175             putProperty(outputObjectStack.last(), propertyNameStack.last(), outValue);
3176             propertyNameStack.removeLast();
3177             goto objectStartVisitMember;
3178         }
3179         mapObjectStartState: {
3180             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3181                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
3182             JSMap* map = JSMap::create(m_exec, m_exec-&gt;vm(), m_globalObject-&gt;mapStructure());
3183             if (UNLIKELY(scope.exception()))
3184                 goto error;
3185             m_gcBuffer.appendWithCrashOnOverflow(map);
3186             outputObjectStack.append(map);
3187             mapStack.append(map);
3188             goto mapDataStartVisitEntry;
3189         }
3190         mapDataStartVisitEntry:
3191         case MapDataStartVisitEntry: {
3192             if (consumeCollectionDataTerminationIfPossible&lt;NonMapPropertiesTag&gt;()) {
3193                 mapStack.removeLast();
3194                 goto objectStartVisitMember;
3195             }
3196             stateStack.append(MapDataEndVisitKey);
3197             goto stateUnknown;
3198         }
3199         case MapDataEndVisitKey: {
3200             mapKeyStack.append(outValue);
3201             stateStack.append(MapDataEndVisitValue);
3202             goto stateUnknown;
3203         }
3204         case MapDataEndVisitValue: {
3205             mapStack.last()-&gt;set(m_exec, mapKeyStack.last(), outValue);
3206             mapKeyStack.removeLast();
3207             goto mapDataStartVisitEntry;
3208         }
3209 
3210         setObjectStartState: {
3211             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3212                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
3213             JSSet* set = JSSet::create(m_exec, m_exec-&gt;vm(), m_globalObject-&gt;setStructure());
3214             if (UNLIKELY(scope.exception()))
3215                 goto error;
3216             m_gcBuffer.appendWithCrashOnOverflow(set);
3217             outputObjectStack.append(set);
3218             setStack.append(set);
3219             goto setDataStartVisitEntry;
3220         }
3221         setDataStartVisitEntry:
3222         case SetDataStartVisitEntry: {
3223             if (consumeCollectionDataTerminationIfPossible&lt;NonSetPropertiesTag&gt;()) {
3224                 setStack.removeLast();
3225                 goto objectStartVisitMember;
3226             }
3227             stateStack.append(SetDataEndVisitKey);
3228             goto stateUnknown;
3229         }
3230         case SetDataEndVisitKey: {
3231             JSSet* set = setStack.last();
3232             set-&gt;add(m_exec, outValue);
3233             goto setDataStartVisitEntry;
3234         }
3235 
3236         stateUnknown:
3237         case StateUnknown:
3238             if (JSValue terminal = readTerminal()) {
3239                 outValue = terminal;
3240                 break;
3241             }
3242             SerializationTag tag = readTag();
3243             if (tag == ArrayTag)
3244                 goto arrayStartState;
3245             if (tag == ObjectTag)
3246                 goto objectStartState;
3247             if (tag == MapObjectTag)
3248                 goto mapObjectStartState;
3249             if (tag == SetObjectTag)
3250                 goto setObjectStartState;
3251             goto error;
3252         }
3253         if (stateStack.isEmpty())
3254             break;
3255 
3256         state = stateStack.last();
3257         stateStack.removeLast();
3258     }
3259     ASSERT(outValue);
3260     ASSERT(!m_failed);
3261     return std::make_pair(outValue, SerializationReturnCode::SuccessfullyCompleted);
3262 error:
3263     fail();
3264     return std::make_pair(JSValue(), SerializationReturnCode::ValidationError);
3265 }
3266 
3267 SerializedScriptValue::~SerializedScriptValue() = default;
3268 
3269 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer)
3270     : m_data(WTFMove(buffer))
3271 {
3272 }
3273 
3274 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray)
3275     : m_data(WTFMove(buffer))
3276     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
3277 {
3278 }
3279 
3280 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray, std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBufferContentsArray, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers
3281 #if ENABLE(WEBASSEMBLY)
3282         , std::unique_ptr&lt;WasmModuleArray&gt; wasmModulesArray
3283 #endif
3284         )
3285     : m_data(WTFMove(buffer))
3286     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
3287     , m_sharedBufferContentsArray(WTFMove(sharedBufferContentsArray))
3288     , m_imageBuffers(WTFMove(imageBuffers))
3289 #if ENABLE(WEBASSEMBLY)
3290     , m_wasmModulesArray(WTFMove(wasmModulesArray))
3291 #endif
3292 {
3293     // Since this SerializedScriptValue is meant to be passed between threads, its String data members
3294     // need to be isolatedCopies so we don&#39;t run into thread safety issues for the StringImpls.
3295     m_blobURLs.reserveInitialCapacity(blobURLs.size());
3296     for (auto&amp; url : blobURLs)
3297         m_blobURLs.uncheckedAppend(url.isolatedCopy());
3298 }
3299 
3300 static ExceptionOr&lt;std::unique_ptr&lt;ArrayBufferContentsArray&gt;&gt; transferArrayBuffers(VM&amp; vm, const Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers)
3301 {
3302     if (arrayBuffers.isEmpty())
3303         return nullptr;
3304 
3305     auto contents = makeUnique&lt;ArrayBufferContentsArray&gt;(arrayBuffers.size());
3306 
3307     HashSet&lt;JSC::ArrayBuffer*&gt; visited;
3308     for (size_t arrayBufferIndex = 0; arrayBufferIndex &lt; arrayBuffers.size(); arrayBufferIndex++) {
3309         if (visited.contains(arrayBuffers[arrayBufferIndex].get()))
3310             continue;
3311         visited.add(arrayBuffers[arrayBufferIndex].get());
3312 
3313         bool result = arrayBuffers[arrayBufferIndex]-&gt;transferTo(vm, contents-&gt;at(arrayBufferIndex));
3314         if (!result)
3315             return Exception { TypeError };
3316     }
3317 
3318     return contents;
3319 }
3320 
3321 static void maybeThrowExceptionIfSerializationFailed(ExecState&amp; state, SerializationReturnCode code)
3322 {
3323     auto&amp; vm = state.vm();
3324     auto scope = DECLARE_THROW_SCOPE(vm);
3325 
3326     switch (code) {
3327     case SerializationReturnCode::SuccessfullyCompleted:
3328         break;
3329     case SerializationReturnCode::StackOverflowError:
3330         throwException(&amp;state, scope, createStackOverflowError(&amp;state));
3331         break;
3332     case SerializationReturnCode::ValidationError:
3333         throwTypeError(&amp;state, scope, &quot;Unable to deserialize data.&quot;_s);
3334         break;
3335     case SerializationReturnCode::DataCloneError:
3336         throwDataCloneError(state, scope);
3337         break;
3338     case SerializationReturnCode::ExistingExceptionError:
3339     case SerializationReturnCode::UnspecifiedError:
3340         break;
3341     case SerializationReturnCode::InterruptedExecutionError:
3342         ASSERT_NOT_REACHED();
3343     }
3344 }
3345 
3346 static Exception exceptionForSerializationFailure(SerializationReturnCode code)
3347 {
3348     ASSERT(code != SerializationReturnCode::SuccessfullyCompleted);
3349 
3350     switch (code) {
3351     case SerializationReturnCode::StackOverflowError:
3352         return Exception { StackOverflowError };
3353     case SerializationReturnCode::ValidationError:
3354         return Exception { TypeError };
3355     case SerializationReturnCode::DataCloneError:
3356         return Exception { DataCloneError };
3357     case SerializationReturnCode::ExistingExceptionError:
3358         return Exception { ExistingExceptionError };
3359     case SerializationReturnCode::UnspecifiedError:
3360         return Exception { TypeError };
3361     case SerializationReturnCode::SuccessfullyCompleted:
3362     case SerializationReturnCode::InterruptedExecutionError:
3363         ASSERT_NOT_REACHED();
3364         return Exception { TypeError };
3365     }
3366     ASSERT_NOT_REACHED();
3367     return Exception { TypeError };
3368 }
3369 
3370 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(ExecState&amp; exec, JSValue value, SerializationErrorMode throwExceptions)
3371 {
3372     Vector&lt;uint8_t&gt; buffer;
3373     Vector&lt;String&gt; blobURLs;
3374     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
3375     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; dummyImageBitmaps;
3376     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
3377 #if ENABLE(WEBASSEMBLY)
3378     WasmModuleArray dummyModules;
3379 #endif
3380     ArrayBufferContentsArray dummySharedBuffers;
3381     auto code = CloneSerializer::serialize(&amp;exec, value, dummyMessagePorts, dummyArrayBuffers, dummyImageBitmaps,
3382 #if ENABLE(WEBASSEMBLY)
3383         dummyModules,
3384 #endif
3385         blobURLs, buffer, SerializationContext::Default, dummySharedBuffers);
3386 
3387 #if ENABLE(WEBASSEMBLY)
3388     ASSERT_WITH_MESSAGE(dummyModules.isEmpty(), &quot;Wasm::Module serialization is only allowed in the postMessage context&quot;);
3389 #endif
3390 
3391     if (throwExceptions == SerializationErrorMode::Throwing)
3392         maybeThrowExceptionIfSerializationFailed(exec, code);
3393 
3394     if (code != SerializationReturnCode::SuccessfullyCompleted)
3395         return nullptr;
3396 
3397     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, nullptr, nullptr, { }
3398 #if ENABLE(WEBASSEMBLY)
3399         , nullptr
3400 #endif
3401             ));
3402 }
3403 
3404 static bool containsDuplicates(const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps)
3405 {
3406     HashSet&lt;ImageBitmap*&gt; visited;
3407     for (auto&amp; imageBitmap : imageBitmaps) {
3408         if (!visited.add(imageBitmap.get()))
3409             return true;
3410     }
3411     return false;
3412 }
3413 
3414 ExceptionOr&lt;Ref&lt;SerializedScriptValue&gt;&gt; SerializedScriptValue::create(ExecState&amp; state, JSValue value, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transferList, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationContext context)
3415 {
3416     VM&amp; vm = state.vm();
3417     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; arrayBuffers;
3418     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; imageBitmaps;
3419     for (auto&amp; transferable : transferList) {
3420         if (auto arrayBuffer = toPossiblySharedArrayBuffer(vm, transferable.get())) {
3421             if (arrayBuffer-&gt;isNeutered())
3422                 return Exception { DataCloneError };
3423             if (arrayBuffer-&gt;isLocked()) {
3424                 auto scope = DECLARE_THROW_SCOPE(vm);
3425                 throwVMTypeError(&amp;state, scope, errorMesasgeForTransfer(arrayBuffer));
3426                 return Exception { ExistingExceptionError };
3427             }
3428             arrayBuffers.append(WTFMove(arrayBuffer));
3429             continue;
3430         }
3431         if (auto port = JSMessagePort::toWrapped(vm, transferable.get())) {
3432             // FIXME: This should check if the port is detached as per https://html.spec.whatwg.org/multipage/infrastructure.html#istransferable.
3433             messagePorts.append(WTFMove(port));
3434             continue;
3435         }
3436 
3437         if (auto imageBitmap = JSImageBitmap::toWrapped(vm, transferable.get())) {
3438             if (imageBitmap-&gt;isDetached())
3439                 return Exception { DataCloneError };
3440 
3441             imageBitmaps.append(WTFMove(imageBitmap));
3442             continue;
3443         }
3444 
3445         return Exception { DataCloneError };
3446     }
3447 
3448     if (containsDuplicates(imageBitmaps))
3449         return Exception { DataCloneError };
3450 
3451     Vector&lt;uint8_t&gt; buffer;
3452     Vector&lt;String&gt; blobURLs;
3453 #if ENABLE(WEBASSEMBLY)
3454     WasmModuleArray wasmModules;
3455 #endif
3456     std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBuffers = makeUnique&lt;ArrayBufferContentsArray&gt;();
3457     auto code = CloneSerializer::serialize(&amp;state, value, messagePorts, arrayBuffers, imageBitmaps,
3458 #if ENABLE(WEBASSEMBLY)
3459         wasmModules,
3460 #endif
3461         blobURLs, buffer, context, *sharedBuffers);
3462 
3463     if (code != SerializationReturnCode::SuccessfullyCompleted)
3464         return exceptionForSerializationFailure(code);
3465 
3466     auto arrayBufferContentsArray = transferArrayBuffers(vm, arrayBuffers);
3467     if (arrayBufferContentsArray.hasException())
3468         return arrayBufferContentsArray.releaseException();
3469 
3470     auto imageBuffers = ImageBitmap::detachBitmaps(WTFMove(imageBitmaps));
3471 
3472     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, arrayBufferContentsArray.releaseReturnValue(), context == SerializationContext::WorkerPostMessage ? WTFMove(sharedBuffers) : nullptr, WTFMove(imageBuffers)
3473 #if ENABLE(WEBASSEMBLY)
3474                 , makeUnique&lt;WasmModuleArray&gt;(wasmModules)
3475 #endif
3476                 ));
3477 }
3478 
3479 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(StringView string)
3480 {
3481     Vector&lt;uint8_t&gt; buffer;
3482     if (!CloneSerializer::serialize(string, buffer))
3483         return nullptr;
3484     return adoptRef(*new SerializedScriptValue(WTFMove(buffer)));
3485 }
3486 
3487 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(JSContextRef originContext, JSValueRef apiValue, JSValueRef* exception)
3488 {
3489     ExecState* exec = toJS(originContext);
3490     VM&amp; vm = exec-&gt;vm();
3491     JSLockHolder locker(vm);
3492     auto scope = DECLARE_CATCH_SCOPE(vm);
3493 
3494     JSValue value = toJS(exec, apiValue);
3495     auto serializedValue = SerializedScriptValue::create(*exec, value);
3496     if (UNLIKELY(scope.exception())) {
3497         if (exception)
3498             *exception = toRef(exec, scope.exception()-&gt;value());
3499         scope.clearException();
3500         return nullptr;
3501     }
3502     ASSERT(serializedValue);
3503     return serializedValue;
3504 }
3505 
3506 String SerializedScriptValue::toString()
3507 {
3508     return CloneDeserializer::deserializeString(m_data);
3509 }
3510 
3511 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, SerializationErrorMode throwExceptions)
3512 {
3513     return deserialize(exec, globalObject, { }, throwExceptions);
3514 }
3515 
3516 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationErrorMode throwExceptions)
3517 {
3518     Vector&lt;String&gt; dummyBlobs;
3519     Vector&lt;String&gt; dummyPaths;
3520     return deserialize(exec, globalObject, messagePorts, dummyBlobs, dummyPaths, throwExceptions);
3521 }
3522 
3523 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt;&amp; blobFilePaths, SerializationErrorMode throwExceptions)
3524 {
3525     DeserializationResult result = CloneDeserializer::deserialize(&amp;exec, globalObject, messagePorts, WTFMove(m_imageBuffers), m_arrayBufferContentsArray.get(), m_data, blobURLs, blobFilePaths, m_sharedBufferContentsArray.get()
3526 #if ENABLE(WEBASSEMBLY)
3527         , m_wasmModulesArray.get()
3528 #endif
3529         );
3530     if (throwExceptions == SerializationErrorMode::Throwing)
3531         maybeThrowExceptionIfSerializationFailed(exec, result.second);
3532     return result.first ? result.first : jsNull();
3533 }
3534 
3535 JSValueRef SerializedScriptValue::deserialize(JSContextRef destinationContext, JSValueRef* exception)
3536 {
3537     ExecState* exec = toJS(destinationContext);
3538     VM&amp; vm = exec-&gt;vm();
3539     JSLockHolder locker(vm);
3540     auto scope = DECLARE_CATCH_SCOPE(vm);
3541 
3542     JSValue value = deserialize(*exec, exec-&gt;lexicalGlobalObject());
3543     if (UNLIKELY(scope.exception())) {
3544         if (exception)
3545             *exception = toRef(exec, scope.exception()-&gt;value());
3546         scope.clearException();
3547         return nullptr;
3548     }
3549     ASSERT(value);
3550     return toRef(exec, value);
3551 }
3552 
3553 Ref&lt;SerializedScriptValue&gt; SerializedScriptValue::nullValue()
3554 {
3555     return adoptRef(*new SerializedScriptValue(Vector&lt;uint8_t&gt;()));
3556 }
3557 
3558 uint32_t SerializedScriptValue::wireFormatVersion()
3559 {
3560     return CurrentVersion;
3561 }
3562 
3563 #if ENABLE(INDEXED_DATABASE)
3564 Vector&lt;String&gt; SerializedScriptValue::blobURLsIsolatedCopy() const
3565 {
3566     Vector&lt;String&gt; result;
3567     result.reserveInitialCapacity(m_blobURLs.size());
3568     for (auto&amp; url : m_blobURLs)
3569         result.uncheckedAppend(url.isolatedCopy());
3570 
3571     return result;
3572 }
3573 
3574 void SerializedScriptValue::writeBlobsToDiskForIndexedDB(PAL::SessionID sessionID, CompletionHandler&lt;void(IDBValue&amp;&amp;)&gt;&amp;&amp; completionHandler)
3575 {
3576     ASSERT(isMainThread());
3577     ASSERT(hasBlobURLs());
3578 
3579     blobRegistry().writeBlobsToTemporaryFiles(sessionID, m_blobURLs, [completionHandler = WTFMove(completionHandler), this, protectedThis = makeRef(*this)] (auto&amp;&amp; blobFilePaths) mutable {
3580         ASSERT(isMainThread());
3581 
3582         if (blobFilePaths.isEmpty()) {
3583             // We should have successfully written blobs to temporary files.
3584             // If we failed, then we can&#39;t successfully store this record.
3585             completionHandler({ });
3586             return;
3587         }
3588 
3589         ASSERT(m_blobURLs.size() == blobFilePaths.size());
3590 
3591         completionHandler({ *this, m_blobURLs, blobFilePaths });
3592     });
3593 }
3594 
3595 IDBValue SerializedScriptValue::writeBlobsToDiskForIndexedDBSynchronously(PAL::SessionID sessionID)
3596 {
3597     ASSERT(!isMainThread());
3598 
3599     IDBValue value;
3600     Lock lock;
3601     Condition condition;
3602     lock.lock();
3603 
3604     RunLoop::main().dispatch([this, sessionID, conditionPtr = &amp;condition, valuePtr = &amp;value] {
3605         writeBlobsToDiskForIndexedDB(sessionID, [conditionPtr, valuePtr](IDBValue&amp;&amp; result) {
3606             ASSERT(isMainThread());
3607             valuePtr-&gt;setAsIsolatedCopy(result);
3608 
3609             conditionPtr-&gt;notifyAll();
3610         });
3611     });
3612 
3613     condition.wait(lock);
3614 
3615     return value;
3616 }
3617 
3618 #endif // ENABLE(INDEXED_DATABASE)
3619 
3620 } // namespace WebCore
    </pre>
  </body>
</html>