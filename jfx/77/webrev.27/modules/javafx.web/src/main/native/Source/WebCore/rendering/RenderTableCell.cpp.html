<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTableCell.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1997 Martin Jones (mjones@kde.org)
   3  *           (C) 1997 Torben Weis (weis@kde.org)
   4  *           (C) 1998 Waldo Bastian (bastian@kde.org)
   5  *           (C) 1999 Lars Knoll (knoll@kde.org)
   6  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   7  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderTableCell.h&quot;
  27 
  28 #include &quot;CollapsedBorderValue.h&quot;
  29 #include &quot;FloatQuad.h&quot;
  30 #include &quot;GraphicsContext.h&quot;
  31 #include &quot;HTMLNames.h&quot;
  32 #include &quot;HTMLTableCellElement.h&quot;
  33 #include &quot;PaintInfo.h&quot;
  34 #include &quot;RenderTableCol.h&quot;
  35 #include &quot;RenderTheme.h&quot;
  36 #include &quot;RenderView.h&quot;
  37 #include &quot;Settings.h&quot;
  38 #include &quot;StyleProperties.h&quot;
  39 #include &quot;TransformState.h&quot;
  40 #include &lt;wtf/IsoMallocInlines.h&gt;
  41 #include &lt;wtf/StackStats.h&gt;
  42 
  43 #if ENABLE(MATHML)
  44 #include &quot;MathMLElement.h&quot;
  45 #include &quot;MathMLNames.h&quot;
  46 #endif
  47 
  48 namespace WebCore {
  49 
  50 using namespace HTMLNames;
  51 
  52 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderTableCell);
  53 
  54 struct SameSizeAsRenderTableCell : public RenderBlockFlow {
  55     unsigned bitfields;
  56     LayoutUnit paddings[2];
  57 };
  58 
  59 COMPILE_ASSERT(sizeof(RenderTableCell) == sizeof(SameSizeAsRenderTableCell), RenderTableCell_should_stay_small);
  60 COMPILE_ASSERT(sizeof(CollapsedBorderValue) &lt;= 24, CollapsedBorderValue_should_stay_small);
  61 
  62 RenderTableCell::RenderTableCell(Element&amp; element, RenderStyle&amp;&amp; style)
  63     : RenderBlockFlow(element, WTFMove(style))
  64     , m_column(unsetColumnIndex)
  65     , m_cellWidthChanged(false)
  66     , m_hasColSpan(false)
  67     , m_hasRowSpan(false)
  68     , m_hasEmptyCollapsedBeforeBorder(false)
  69     , m_hasEmptyCollapsedAfterBorder(false)
  70     , m_hasEmptyCollapsedStartBorder(false)
  71     , m_hasEmptyCollapsedEndBorder(false)
  72 {
  73     // We only update the flags when notified of DOM changes in colSpanOrRowSpanChanged()
  74     // so we need to set their initial values here in case something asks for colSpan()/rowSpan() before then.
  75     updateColAndRowSpanFlags();
  76 }
  77 
  78 RenderTableCell::RenderTableCell(Document&amp; document, RenderStyle&amp;&amp; style)
  79     : RenderBlockFlow(document, WTFMove(style))
  80     , m_column(unsetColumnIndex)
  81     , m_cellWidthChanged(false)
  82     , m_hasColSpan(false)
  83     , m_hasRowSpan(false)
  84     , m_hasEmptyCollapsedBeforeBorder(false)
  85     , m_hasEmptyCollapsedAfterBorder(false)
  86     , m_hasEmptyCollapsedStartBorder(false)
  87     , m_hasEmptyCollapsedEndBorder(false)
  88 {
  89 }
  90 
  91 void RenderTableCell::willBeRemovedFromTree()
  92 {
  93     RenderBlockFlow::willBeRemovedFromTree();
  94     if (!table() || !section())
  95         return;
  96     RenderTableSection* section = this-&gt;section();
  97     table()-&gt;invalidateCollapsedBorders();
  98     section-&gt;setNeedsCellRecalc();
  99 }
 100 
 101 unsigned RenderTableCell::parseColSpanFromDOM() const
 102 {
 103     ASSERT(element());
 104     if (is&lt;HTMLTableCellElement&gt;(*element()))
 105         return std::min&lt;unsigned&gt;(downcast&lt;HTMLTableCellElement&gt;(*element()).colSpan(), maxColumnIndex);
 106 #if ENABLE(MATHML)
 107     if (element()-&gt;hasTagName(MathMLNames::mtdTag))
 108         return std::min&lt;unsigned&gt;(downcast&lt;MathMLElement&gt;(*element()).colSpan(), maxColumnIndex);
 109 #endif
 110     return 1;
 111 }
 112 
 113 unsigned RenderTableCell::parseRowSpanFromDOM() const
 114 {
 115     ASSERT(element());
 116     if (is&lt;HTMLTableCellElement&gt;(*element()))
 117         return std::min&lt;unsigned&gt;(downcast&lt;HTMLTableCellElement&gt;(*element()).rowSpan(), maxRowIndex);
 118 #if ENABLE(MATHML)
 119     if (element()-&gt;hasTagName(MathMLNames::mtdTag))
 120         return std::min&lt;unsigned&gt;(downcast&lt;MathMLElement&gt;(*element()).rowSpan(), maxRowIndex);
 121 #endif
 122     return 1;
 123 }
 124 
 125 void RenderTableCell::updateColAndRowSpanFlags()
 126 {
 127     // The vast majority of table cells do not have a colspan or rowspan,
 128     // so we keep a bool to know if we need to bother reading from the DOM.
 129     m_hasColSpan = element() &amp;&amp; parseColSpanFromDOM() != 1;
 130     m_hasRowSpan = element() &amp;&amp; parseRowSpanFromDOM() != 1;
 131 }
 132 
 133 void RenderTableCell::colSpanOrRowSpanChanged()
 134 {
 135     ASSERT(element());
 136 #if ENABLE(MATHML)
 137     ASSERT(element()-&gt;hasTagName(tdTag) || element()-&gt;hasTagName(thTag) || element()-&gt;hasTagName(MathMLNames::mtdTag));
 138 #else
 139     ASSERT(element()-&gt;hasTagName(tdTag) || element()-&gt;hasTagName(thTag));
 140 #endif
 141 
 142     updateColAndRowSpanFlags();
 143 
 144     // FIXME: I suspect that we could return early here if !m_hasColSpan &amp;&amp; !m_hasRowSpan.
 145 
 146     setNeedsLayoutAndPrefWidthsRecalc();
 147     if (parent() &amp;&amp; section())
 148         section()-&gt;setNeedsCellRecalc();
 149 }
 150 
 151 Length RenderTableCell::logicalWidthFromColumns(RenderTableCol* firstColForThisCell, Length widthFromStyle) const
 152 {
 153     ASSERT(firstColForThisCell &amp;&amp; firstColForThisCell == table()-&gt;colElement(col()));
 154     RenderTableCol* tableCol = firstColForThisCell;
 155 
 156     unsigned colSpanCount = colSpan();
 157     LayoutUnit colWidthSum;
 158     for (unsigned i = 1; i &lt;= colSpanCount; i++) {
 159         Length colWidth = tableCol-&gt;style().logicalWidth();
 160 
 161         // Percentage value should be returned only for colSpan == 1.
 162         // Otherwise we return original width for the cell.
 163         if (!colWidth.isFixed()) {
 164             if (colSpanCount &gt; 1)
 165                 return widthFromStyle;
 166             return colWidth;
 167         }
 168 
 169         colWidthSum += colWidth.value();
 170         tableCol = tableCol-&gt;nextColumn();
 171         // If no next &lt;col&gt; tag found for the span we just return what we have for now.
 172         if (!tableCol)
 173             break;
 174     }
 175 
 176     // Column widths specified on &lt;col&gt; apply to the border box of the cell, see bug 8126.
 177     // FIXME: Why is border/padding ignored in the negative width case?
 178     if (colWidthSum &gt; 0)
 179         return Length(std::max&lt;LayoutUnit&gt;(0, colWidthSum - borderAndPaddingLogicalWidth()), Fixed);
 180     return Length(colWidthSum, Fixed);
 181 }
 182 
 183 void RenderTableCell::computePreferredLogicalWidths()
 184 {
 185     // The child cells rely on the grids up in the sections to do their computePreferredLogicalWidths work.  Normally the sections are set up early, as table
 186     // cells are added, but relayout can cause the cells to be freed, leaving stale pointers in the sections&#39;
 187     // grids.  We must refresh those grids before the child cells try to use them.
 188     table()-&gt;recalcSectionsIfNeeded();
 189 
 190     RenderBlockFlow::computePreferredLogicalWidths();
 191     if (!element() || !style().autoWrap() || !element()-&gt;hasAttributeWithoutSynchronization(nowrapAttr))
 192         return;
 193 
 194     Length w = styleOrColLogicalWidth();
 195     if (w.isFixed()) {
 196         // Nowrap is set, but we didn&#39;t actually use it because of the
 197         // fixed width set on the cell. Even so, it is a WinIE/Moz trait
 198         // to make the minwidth of the cell into the fixed width. They do this
 199         // even in strict mode, so do not make this a quirk. Affected the top
 200         // of hiptop.com.
 201         m_minPreferredLogicalWidth = std::max(LayoutUnit(w.value()), m_minPreferredLogicalWidth);
 202     }
 203 }
 204 
 205 void RenderTableCell::computeIntrinsicPadding(LayoutUnit rowHeight)
 206 {
 207     LayoutUnit oldIntrinsicPaddingBefore = intrinsicPaddingBefore();
 208     LayoutUnit oldIntrinsicPaddingAfter = intrinsicPaddingAfter();
 209     LayoutUnit logicalHeightWithoutIntrinsicPadding = logicalHeight() - oldIntrinsicPaddingBefore - oldIntrinsicPaddingAfter;
 210 
 211     LayoutUnit intrinsicPaddingBefore;
 212     switch (style().verticalAlign()) {
 213     case VerticalAlign::Sub:
 214     case VerticalAlign::Super:
 215     case VerticalAlign::TextTop:
 216     case VerticalAlign::TextBottom:
 217     case VerticalAlign::Length:
 218     case VerticalAlign::Baseline: {
 219         LayoutUnit baseline = cellBaselinePosition();
 220         if (baseline &gt; borderAndPaddingBefore())
 221             intrinsicPaddingBefore = section()-&gt;rowBaseline(rowIndex()) - (baseline - oldIntrinsicPaddingBefore);
 222         break;
 223     }
 224     case VerticalAlign::Top:
 225         break;
 226     case VerticalAlign::Middle:
 227         intrinsicPaddingBefore = (rowHeight - logicalHeightWithoutIntrinsicPadding) / 2;
 228         break;
 229     case VerticalAlign::Bottom:
 230         intrinsicPaddingBefore = rowHeight - logicalHeightWithoutIntrinsicPadding;
 231         break;
 232     case VerticalAlign::BaselineMiddle:
 233         break;
 234     }
 235 
 236     LayoutUnit intrinsicPaddingAfter = rowHeight - logicalHeightWithoutIntrinsicPadding - intrinsicPaddingBefore;
 237     setIntrinsicPaddingBefore(intrinsicPaddingBefore);
 238     setIntrinsicPaddingAfter(intrinsicPaddingAfter);
 239 
 240     // FIXME: Changing an intrinsic padding shouldn&#39;t trigger a relayout as it only shifts the cell inside the row but
 241     // doesn&#39;t change the logical height.
 242     if (intrinsicPaddingBefore != oldIntrinsicPaddingBefore || intrinsicPaddingAfter != oldIntrinsicPaddingAfter)
 243         setNeedsLayout(MarkOnlyThis);
 244 }
 245 
 246 void RenderTableCell::updateLogicalWidth()
 247 {
 248 }
 249 
 250 void RenderTableCell::setCellLogicalWidth(LayoutUnit tableLayoutLogicalWidth)
 251 {
 252     if (tableLayoutLogicalWidth == logicalWidth())
 253         return;
 254 
 255     setNeedsLayout(MarkOnlyThis);
 256     row()-&gt;setChildNeedsLayout(MarkOnlyThis);
 257 
 258     if (!table()-&gt;selfNeedsLayout() &amp;&amp; checkForRepaintDuringLayout())
 259         repaint();
 260 
 261     setLogicalWidth(tableLayoutLogicalWidth);
 262     setCellWidthChanged(true);
 263 }
 264 
 265 void RenderTableCell::layout()
 266 {
 267     StackStats::LayoutCheckPoint layoutCheckPoint;
 268 
 269     int oldCellBaseline = cellBaselinePosition();
 270     layoutBlock(cellWidthChanged());
 271 
 272     // If we have replaced content, the intrinsic height of our content may have changed since the last time we laid out. If that&#39;s the case the intrinsic padding we used
 273     // for layout (the padding required to push the contents of the cell down to the row&#39;s baseline) is included in our new height and baseline and makes both
 274     // of them wrong. So if our content&#39;s intrinsic height has changed push the new content up into the intrinsic padding and relayout so that the rest of
 275     // table and row layout can use the correct baseline and height for this cell.
 276     if (isBaselineAligned() &amp;&amp; section()-&gt;rowBaseline(rowIndex()) &amp;&amp; cellBaselinePosition() &gt; section()-&gt;rowBaseline(rowIndex())) {
 277         LayoutUnit newIntrinsicPaddingBefore = std::max&lt;LayoutUnit&gt;(0, intrinsicPaddingBefore() - std::max&lt;LayoutUnit&gt;(0, cellBaselinePosition() - oldCellBaseline));
 278         setIntrinsicPaddingBefore(newIntrinsicPaddingBefore);
 279         setNeedsLayout(MarkOnlyThis);
 280         layoutBlock(cellWidthChanged());
 281     }
 282     invalidateHasEmptyCollapsedBorders();
 283 
 284     // FIXME: This value isn&#39;t the intrinsic content logical height, but we need
 285     // to update the value as its used by flexbox layout. crbug.com/367324
 286     cacheIntrinsicContentLogicalHeightForFlexItem(contentLogicalHeight());
 287 
 288     setCellWidthChanged(false);
 289 }
 290 
 291 LayoutUnit RenderTableCell::paddingTop() const
 292 {
 293     LayoutUnit result = computedCSSPaddingTop();
 294     if (!isHorizontalWritingMode())
 295         return result;
 296     return result + (style().writingMode() == TopToBottomWritingMode ? intrinsicPaddingBefore() : intrinsicPaddingAfter());
 297 }
 298 
 299 LayoutUnit RenderTableCell::paddingBottom() const
 300 {
 301     LayoutUnit result = computedCSSPaddingBottom();
 302     if (!isHorizontalWritingMode())
 303         return result;
 304     return result + (style().writingMode() == TopToBottomWritingMode ? intrinsicPaddingAfter() : intrinsicPaddingBefore());
 305 }
 306 
 307 LayoutUnit RenderTableCell::paddingLeft() const
 308 {
 309     LayoutUnit result = computedCSSPaddingLeft();
 310     if (isHorizontalWritingMode())
 311         return result;
 312     return result + (style().writingMode() == LeftToRightWritingMode ? intrinsicPaddingBefore() : intrinsicPaddingAfter());
 313 }
 314 
 315 LayoutUnit RenderTableCell::paddingRight() const
 316 {
 317     LayoutUnit result = computedCSSPaddingRight();
 318     if (isHorizontalWritingMode())
 319         return result;
 320     return result + (style().writingMode() == LeftToRightWritingMode ? intrinsicPaddingAfter() : intrinsicPaddingBefore());
 321 }
 322 
 323 LayoutUnit RenderTableCell::paddingBefore() const
 324 {
 325     return computedCSSPaddingBefore() + intrinsicPaddingBefore();
 326 }
 327 
 328 LayoutUnit RenderTableCell::paddingAfter() const
 329 {
 330     return computedCSSPaddingAfter() + intrinsicPaddingAfter();
 331 }
 332 
 333 void RenderTableCell::setOverrideContentLogicalHeightFromRowHeight(LayoutUnit rowHeight)
 334 {
 335     clearIntrinsicPadding();
 336     setOverrideContentLogicalHeight(std::max&lt;LayoutUnit&gt;(0, rowHeight - borderAndPaddingLogicalHeight()));
 337 }
 338 
 339 LayoutSize RenderTableCell::offsetFromContainer(RenderElement&amp; container, const LayoutPoint&amp; point, bool* offsetDependsOnPoint) const
 340 {
 341     ASSERT(&amp;container == this-&gt;container());
 342 
 343     LayoutSize offset = RenderBlockFlow::offsetFromContainer(container, point, offsetDependsOnPoint);
 344     if (parent())
 345         offset -= parentBox()-&gt;locationOffset();
 346 
 347     return offset;
 348 }
 349 
 350 LayoutRect RenderTableCell::clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const
 351 {
 352     // If the table grid is dirty, we cannot get reliable information about adjoining cells,
 353     // so we ignore outside borders. This should not be a problem because it means that
 354     // the table is going to recalculate the grid, relayout and repaint its current rect, which
 355     // includes any outside borders of this cell.
 356     if (!table()-&gt;collapseBorders() || table()-&gt;needsSectionRecalc())
 357         return RenderBlockFlow::clippedOverflowRectForRepaint(repaintContainer);
 358 
 359     bool rtl = !styleForCellFlow().isLeftToRightDirection();
 360     LayoutUnit outlineSize { style().outlineSize() };
 361     LayoutUnit left = std::max(borderHalfLeft(true), outlineSize);
 362     LayoutUnit right = std::max(borderHalfRight(true), outlineSize);
 363     LayoutUnit top = std::max(borderHalfTop(true), outlineSize);
 364     LayoutUnit bottom = std::max(borderHalfBottom(true), outlineSize);
 365     if ((left &amp;&amp; !rtl) || (right &amp;&amp; rtl)) {
 366         if (RenderTableCell* before = table()-&gt;cellBefore(this)) {
 367             top = std::max(top, before-&gt;borderHalfTop(true));
 368             bottom = std::max(bottom, before-&gt;borderHalfBottom(true));
 369         }
 370     }
 371     if ((left &amp;&amp; rtl) || (right &amp;&amp; !rtl)) {
 372         if (RenderTableCell* after = table()-&gt;cellAfter(this)) {
 373             top = std::max(top, after-&gt;borderHalfTop(true));
 374             bottom = std::max(bottom, after-&gt;borderHalfBottom(true));
 375         }
 376     }
 377     if (top) {
 378         if (RenderTableCell* above = table()-&gt;cellAbove(this)) {
 379             left = std::max(left, above-&gt;borderHalfLeft(true));
 380             right = std::max(right, above-&gt;borderHalfRight(true));
 381         }
 382     }
 383     if (bottom) {
 384         if (RenderTableCell* below = table()-&gt;cellBelow(this)) {
 385             left = std::max(left, below-&gt;borderHalfLeft(true));
 386             right = std::max(right, below-&gt;borderHalfRight(true));
 387         }
 388     }
 389     LayoutPoint location(std::max&lt;LayoutUnit&gt;(left, -visualOverflowRect().x()), std::max&lt;LayoutUnit&gt;(top, -visualOverflowRect().y()));
 390     LayoutRect r(-location.x(), -location.y(), location.x() + std::max(width() + right, visualOverflowRect().maxX()), location.y() + std::max(height() + bottom, visualOverflowRect().maxY()));
 391 
 392     // FIXME: layoutDelta needs to be applied in parts before/after transforms and
 393     // repaint containers. https://bugs.webkit.org/show_bug.cgi?id=23308
 394     r.move(view().frameView().layoutContext().layoutDelta());
 395     return computeRectForRepaint(r, repaintContainer);
 396 }
 397 
 398 Optional&lt;LayoutRect&gt; RenderTableCell::computeVisibleRectInContainer(const LayoutRect&amp; rect, const RenderLayerModelObject* container, VisibleRectContext context) const
 399 {
 400     if (container == this)
 401         return rect;
 402     LayoutRect adjustedRect = rect;
 403     if ((!view().frameView().layoutContext().isPaintOffsetCacheEnabled() || container || context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection)) &amp;&amp; parent())
 404         adjustedRect.moveBy(-parentBox()-&gt;location()); // Rows are in the same coordinate space, so don&#39;t add their offset in.
 405     return RenderBlockFlow::computeVisibleRectInContainer(adjustedRect, container, context);
 406 }
 407 
 408 LayoutUnit RenderTableCell::cellBaselinePosition() const
 409 {
 410     // &lt;http://www.w3.org/TR/2007/CR-CSS21-20070719/tables.html#height-layout&gt;: The baseline of a cell is the baseline of
 411     // the first in-flow line box in the cell, or the first in-flow table-row in the cell, whichever comes first. If there
 412     // is no such line box or table-row, the baseline is the bottom of content edge of the cell box.
 413     return firstLineBaseline().valueOr(borderAndPaddingBefore() + contentLogicalHeight());
 414 }
 415 
 416 static inline void markCellDirtyWhenCollapsedBorderChanges(RenderTableCell* cell)
 417 {
 418     if (!cell)
 419         return;
 420     cell-&gt;setNeedsLayoutAndPrefWidthsRecalc();
 421 }
 422 
 423 void RenderTableCell::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
 424 {
 425     ASSERT(style().display() == DisplayType::TableCell);
 426     ASSERT(!row() || row()-&gt;rowIndexWasSet());
 427 
 428     RenderBlockFlow::styleDidChange(diff, oldStyle);
 429     setHasVisibleBoxDecorations(true); // FIXME: Optimize this to only set to true if necessary.
 430 
 431     if (parent() &amp;&amp; section() &amp;&amp; oldStyle &amp;&amp; style().height() != oldStyle-&gt;height())
 432         section()-&gt;rowLogicalHeightChanged(rowIndex());
 433 
 434     // Our intrinsic padding pushes us down to align with the baseline of other cells on the row. If our vertical-align
 435     // has changed then so will the padding needed to align with other cells - clear it so we can recalculate it from scratch.
 436     if (oldStyle &amp;&amp; style().verticalAlign() != oldStyle-&gt;verticalAlign())
 437         clearIntrinsicPadding();
 438 
 439     // If border was changed, notify table.
 440     RenderTable* table = this-&gt;table();
 441     if (table &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;border() != style().border()) {
 442         table-&gt;invalidateCollapsedBorders(this);
 443         if (table-&gt;collapseBorders() &amp;&amp; diff == StyleDifference::Layout) {
 444             markCellDirtyWhenCollapsedBorderChanges(table-&gt;cellBelow(this));
 445             markCellDirtyWhenCollapsedBorderChanges(table-&gt;cellAbove(this));
 446             markCellDirtyWhenCollapsedBorderChanges(table-&gt;cellBefore(this));
 447             markCellDirtyWhenCollapsedBorderChanges(table-&gt;cellAfter(this));
 448         }
 449     }
 450 }
 451 
 452 // The following rules apply for resolving conflicts and figuring out which border
 453 // to use.
 454 // (1) Borders with the &#39;border-style&#39; of &#39;hidden&#39; take precedence over all other conflicting
 455 // borders. Any border with this value suppresses all borders at this location.
 456 // (2) Borders with a style of &#39;none&#39; have the lowest priority. Only if the border properties of all
 457 // the elements meeting at this edge are &#39;none&#39; will the border be omitted (but note that &#39;none&#39; is
 458 // the default value for the border style.)
 459 // (3) If none of the styles are &#39;hidden&#39; and at least one of them is not &#39;none&#39;, then narrow borders
 460 // are discarded in favor of wider ones. If several have the same &#39;border-width&#39; then styles are preferred
 461 // in this order: &#39;double&#39;, &#39;solid&#39;, &#39;dashed&#39;, &#39;dotted&#39;, &#39;ridge&#39;, &#39;outset&#39;, &#39;groove&#39;, and the lowest: &#39;inset&#39;.
 462 // (4) If border styles differ only in color, then a style set on a cell wins over one on a row,
 463 // which wins over a row group, column, column group and, lastly, table. It is undefined which color
 464 // is used when two elements of the same type disagree.
 465 static int compareBorders(const CollapsedBorderValue&amp; border1, const CollapsedBorderValue&amp; border2)
 466 {
 467     // Sanity check the values passed in. The null border have lowest priority.
 468     if (!border2.exists()) {
 469         if (!border1.exists())
 470             return 0;
 471         return 1;
 472     }
 473     if (!border1.exists())
 474         return -1;
 475 
 476     // Rule #1 above.
 477     if (border2.style() == BorderStyle::Hidden) {
 478         if (border1.style() == BorderStyle::Hidden)
 479             return 0;
 480         return -1;
 481     }
 482     if (border1.style() == BorderStyle::Hidden)
 483         return 1;
 484 
 485     // Rule #2 above.  A style of &#39;none&#39; has lowest priority and always loses to any other border.
 486     if (border2.style() == BorderStyle::None) {
 487         if (border1.style() == BorderStyle::None)
 488             return 0;
 489         return 1;
 490     }
 491     if (border1.style() == BorderStyle::None)
 492         return -1;
 493 
 494     // The first part of rule #3 above. Wider borders win.
 495     if (border1.width() != border2.width())
 496         return border1.width() &lt; border2.width() ? -1 : 1;
 497 
 498     // The borders have equal width.  Sort by border style.
 499     if (border1.style() != border2.style())
 500         return border1.style() &lt; border2.style() ? -1 : 1;
 501 
 502     // The border have the same width and style.  Rely on precedence (cell over row over row group, etc.)
 503     if (border1.precedence() == border2.precedence())
 504         return 0;
 505     return border1.precedence() &lt; border2.precedence() ? -1 : 1;
 506 }
 507 
 508 static CollapsedBorderValue chooseBorder(const CollapsedBorderValue&amp; border1, const CollapsedBorderValue&amp; border2)
 509 {
 510     const CollapsedBorderValue&amp; border = compareBorders(border1, border2) &lt; 0 ? border2 : border1;
 511     return border.style() == BorderStyle::Hidden ? CollapsedBorderValue() : border;
 512 }
 513 
 514 bool RenderTableCell::hasStartBorderAdjoiningTable() const
 515 {
 516     bool isStartColumn = !col();
 517     bool isEndColumn = table()-&gt;colToEffCol(col() + colSpan() - 1) == table()-&gt;numEffCols() - 1;
 518     bool hasSameDirectionAsTable = isDirectionSame(this, section());
 519 
 520     // The table direction determines the row direction. In mixed directionality, we cannot guarantee that
 521     // we have a common border with the table (think a ltr table with rtl start cell).
 522     return (isStartColumn &amp;&amp; hasSameDirectionAsTable) || (isEndColumn &amp;&amp; !hasSameDirectionAsTable);
 523 }
 524 
 525 bool RenderTableCell::hasEndBorderAdjoiningTable() const
 526 {
 527     bool isStartColumn = !col();
 528     bool isEndColumn = table()-&gt;colToEffCol(col() + colSpan() - 1) == table()-&gt;numEffCols() - 1;
 529     bool hasSameDirectionAsTable = isDirectionSame(this, section());
 530 
 531     // The table direction determines the row direction. In mixed directionality, we cannot guarantee that
 532     // we have a common border with the table (think a ltr table with ltr end cell).
 533     return (isStartColumn &amp;&amp; !hasSameDirectionAsTable) || (isEndColumn &amp;&amp; hasSameDirectionAsTable);
 534 }
 535 
 536 static CollapsedBorderValue emptyBorder()
 537 {
 538     return CollapsedBorderValue(BorderValue(), Color(), BorderPrecedence::Cell);
 539 }
 540 
 541 CollapsedBorderValue RenderTableCell::collapsedStartBorder(IncludeBorderColorOrNot includeColor) const
 542 {
 543     if (!table() || !section())
 544         return emptyBorder();
 545 
 546     if (m_hasEmptyCollapsedStartBorder)
 547         return emptyBorder();
 548 
 549     if (table()-&gt;collapsedBordersAreValid())
 550         return section()-&gt;cachedCollapsedBorder(*this, CBSStart);
 551 
 552     CollapsedBorderValue result = computeCollapsedStartBorder(includeColor);
 553     setHasEmptyCollapsedBorder(CBSStart, !result.width());
 554     if (includeColor &amp;&amp; !m_hasEmptyCollapsedStartBorder)
 555         section()-&gt;setCachedCollapsedBorder(*this, CBSStart, result);
 556     return result;
 557 }
 558 
 559 CollapsedBorderValue RenderTableCell::computeCollapsedStartBorder(IncludeBorderColorOrNot includeColor) const
 560 {
 561     // For the start border, we need to check, in order of precedence:
 562     // (1) Our start border.
 563     CSSPropertyID startColorProperty = includeColor ? CSSProperty::resolveDirectionAwareProperty(CSSPropertyBorderInlineStartColor, styleForCellFlow().direction(), styleForCellFlow().writingMode()) : CSSPropertyInvalid;
 564     CSSPropertyID endColorProperty = includeColor ? CSSProperty::resolveDirectionAwareProperty(CSSPropertyBorderInlineEndColor, styleForCellFlow().direction(), styleForCellFlow().writingMode()) : CSSPropertyInvalid;
 565     CollapsedBorderValue result(style().borderStart(), includeColor ? style().visitedDependentColorWithColorFilter(startColorProperty) : Color(), BorderPrecedence::Cell);
 566 
 567     RenderTable* table = this-&gt;table();
 568     if (!table)
 569         return result;
 570     // (2) The end border of the preceding cell.
 571     RenderTableCell* cellBefore = table-&gt;cellBefore(this);
 572     if (cellBefore) {
 573         CollapsedBorderValue cellBeforeAdjoiningBorder = CollapsedBorderValue(cellBefore-&gt;borderAdjoiningCellAfter(*this), includeColor ? cellBefore-&gt;style().visitedDependentColorWithColorFilter(endColorProperty) : Color(), BorderPrecedence::Cell);
 574         // |result| should be the 2nd argument as |cellBefore| should win in case of equality per CSS 2.1 (Border conflict resolution, point 4).
 575         result = chooseBorder(cellBeforeAdjoiningBorder, result);
 576         if (!result.exists())
 577             return result;
 578     }
 579 
 580     bool startBorderAdjoinsTable = hasStartBorderAdjoiningTable();
 581     if (startBorderAdjoinsTable) {
 582         // (3) Our row&#39;s start border.
 583         result = chooseBorder(result, CollapsedBorderValue(row()-&gt;borderAdjoiningStartCell(*this), includeColor ? parent()-&gt;style().visitedDependentColorWithColorFilter(startColorProperty) : Color(), BorderPrecedence::Row));
 584         if (!result.exists())
 585             return result;
 586 
 587         // (4) Our row group&#39;s start border.
 588         result = chooseBorder(result, CollapsedBorderValue(section()-&gt;borderAdjoiningStartCell(*this), includeColor ? section()-&gt;style().visitedDependentColorWithColorFilter(startColorProperty) : Color(), BorderPrecedence::RowGroup));
 589         if (!result.exists())
 590             return result;
 591     }
 592 
 593     // (5) Our column and column group&#39;s start borders.
 594     bool startColEdge;
 595     bool endColEdge;
 596     if (RenderTableCol* colElt = table-&gt;colElement(col(), &amp;startColEdge, &amp;endColEdge)) {
 597         if (colElt-&gt;isTableColumnGroup() &amp;&amp; startColEdge) {
 598             // The |colElt| is a column group and is also the first colgroup (in case of spanned colgroups).
 599             result = chooseBorder(result, CollapsedBorderValue(colElt-&gt;borderAdjoiningCellStartBorder(), includeColor ? colElt-&gt;style().visitedDependentColorWithColorFilter(startColorProperty) : Color(), BorderPrecedence::ColumnGroup));
 600             if (!result.exists())
 601                 return result;
 602         } else if (!colElt-&gt;isTableColumnGroup()) {
 603             // We first consider the |colElt| and irrespective of whether it is a spanned col or not, we apply
 604             // its start border. This is as per HTML5 which states that: &quot;For the purposes of the CSS table model,
 605             // the col element is expected to be treated as if it was present as many times as its span attribute specifies&quot;.
 606             result = chooseBorder(result, CollapsedBorderValue(colElt-&gt;borderAdjoiningCellStartBorder(), includeColor ? colElt-&gt;style().visitedDependentColorWithColorFilter(startColorProperty) : Color(), BorderPrecedence::Column));
 607             if (!result.exists())
 608                 return result;
 609             // Next, apply the start border of the enclosing colgroup but only if it is adjacent to the cell&#39;s edge.
 610             if (RenderTableCol* enclosingColumnGroup = colElt-&gt;enclosingColumnGroupIfAdjacentBefore()) {
 611                 result = chooseBorder(result, CollapsedBorderValue(enclosingColumnGroup-&gt;borderAdjoiningCellStartBorder(), includeColor ? enclosingColumnGroup-&gt;style().visitedDependentColorWithColorFilter(startColorProperty) : Color(), BorderPrecedence::ColumnGroup));
 612                 if (!result.exists())
 613                     return result;
 614             }
 615         }
 616     }
 617 
 618     // (6) The end border of the preceding column.
 619     if (cellBefore) {
 620         if (RenderTableCol* colElt = table-&gt;colElement(col() - 1, &amp;startColEdge, &amp;endColEdge)) {
 621             if (colElt-&gt;isTableColumnGroup() &amp;&amp; endColEdge) {
 622                 // The element is a colgroup and is also the last colgroup (in case of spanned colgroups).
 623                 result = chooseBorder(CollapsedBorderValue(colElt-&gt;borderAdjoiningCellAfter(*this), includeColor ? colElt-&gt;style().visitedDependentColorWithColorFilter(endColorProperty) : Color(), BorderPrecedence::ColumnGroup), result);
 624                 if (!result.exists())
 625                     return result;
 626             } else if (colElt-&gt;isTableColumn()) {
 627                 // Resolve the collapsing border against the col&#39;s border ignoring any &#39;span&#39; as per HTML5.
 628                 result = chooseBorder(CollapsedBorderValue(colElt-&gt;borderAdjoiningCellAfter(*this), includeColor ? colElt-&gt;style().visitedDependentColorWithColorFilter(endColorProperty) : Color(), BorderPrecedence::Column), result);
 629                 if (!result.exists())
 630                     return result;
 631                 // Next, if the previous col has a parent colgroup then its end border should be applied
 632                 // but only if it is adjacent to the cell&#39;s edge.
 633                 if (RenderTableCol* enclosingColumnGroup = colElt-&gt;enclosingColumnGroupIfAdjacentAfter()) {
 634                     result = chooseBorder(CollapsedBorderValue(enclosingColumnGroup-&gt;borderAdjoiningCellEndBorder(), includeColor ? enclosingColumnGroup-&gt;style().visitedDependentColorWithColorFilter(endColorProperty) : Color(), BorderPrecedence::ColumnGroup), result);
 635                     if (!result.exists())
 636                         return result;
 637                 }
 638             }
 639         }
 640     }
 641 
 642     if (startBorderAdjoinsTable) {
 643         // (7) The table&#39;s start border.
 644         result = chooseBorder(result, CollapsedBorderValue(table-&gt;tableStartBorderAdjoiningCell(*this), includeColor ? table-&gt;style().visitedDependentColorWithColorFilter(startColorProperty) : Color(), BorderPrecedence::Table));
 645         if (!result.exists())
 646             return result;
 647     }
 648 
 649     return result;
 650 }
 651 
 652 CollapsedBorderValue RenderTableCell::collapsedEndBorder(IncludeBorderColorOrNot includeColor) const
 653 {
 654     if (!table() || !section())
 655         return emptyBorder();
 656 
 657     if (m_hasEmptyCollapsedEndBorder)
 658         return emptyBorder();
 659 
 660     if (table()-&gt;collapsedBordersAreValid())
 661         return section()-&gt;cachedCollapsedBorder(*this, CBSEnd);
 662 
 663     CollapsedBorderValue result = computeCollapsedEndBorder(includeColor);
 664     setHasEmptyCollapsedBorder(CBSEnd, !result.width());
 665     if (includeColor &amp;&amp; !m_hasEmptyCollapsedEndBorder)
 666         section()-&gt;setCachedCollapsedBorder(*this, CBSEnd, result);
 667     return result;
 668 }
 669 
 670 CollapsedBorderValue RenderTableCell::computeCollapsedEndBorder(IncludeBorderColorOrNot includeColor) const
 671 {
 672     // For end border, we need to check, in order of precedence:
 673     // (1) Our end border.
 674     CSSPropertyID startColorProperty = includeColor ? CSSProperty::resolveDirectionAwareProperty(CSSPropertyBorderInlineStartColor, styleForCellFlow().direction(), styleForCellFlow().writingMode()) : CSSPropertyInvalid;
 675     CSSPropertyID endColorProperty = includeColor ? CSSProperty::resolveDirectionAwareProperty(CSSPropertyBorderInlineEndColor, styleForCellFlow().direction(), styleForCellFlow().writingMode()) : CSSPropertyInvalid;
 676     CollapsedBorderValue result = CollapsedBorderValue(style().borderEnd(), includeColor ? style().visitedDependentColorWithColorFilter(endColorProperty) : Color(), BorderPrecedence::Cell);
 677 
 678     RenderTable* table = this-&gt;table();
 679     if (!table)
 680         return result;
 681     // Note: We have to use the effective column information instead of whether we have a cell after as a table doesn&#39;t
 682     // have to be regular (any row can have less cells than the total cell count).
 683     bool isEndColumn = table-&gt;colToEffCol(col() + colSpan() - 1) == table-&gt;numEffCols() - 1;
 684     // (2) The start border of the following cell.
 685     if (!isEndColumn) {
 686         if (RenderTableCell* cellAfter = table-&gt;cellAfter(this)) {
 687             CollapsedBorderValue cellAfterAdjoiningBorder = CollapsedBorderValue(cellAfter-&gt;borderAdjoiningCellBefore(*this), includeColor ? cellAfter-&gt;style().visitedDependentColorWithColorFilter(startColorProperty) : Color(), BorderPrecedence::Cell);
 688             result = chooseBorder(result, cellAfterAdjoiningBorder);
 689             if (!result.exists())
 690                 return result;
 691         }
 692     }
 693 
 694     bool endBorderAdjoinsTable = hasEndBorderAdjoiningTable();
 695     if (endBorderAdjoinsTable) {
 696         // (3) Our row&#39;s end border.
 697         result = chooseBorder(result, CollapsedBorderValue(row()-&gt;borderAdjoiningEndCell(*this), includeColor ? parent()-&gt;style().visitedDependentColorWithColorFilter(endColorProperty) : Color(), BorderPrecedence::Row));
 698         if (!result.exists())
 699             return result;
 700 
 701         // (4) Our row group&#39;s end border.
 702         result = chooseBorder(result, CollapsedBorderValue(section()-&gt;borderAdjoiningEndCell(*this), includeColor ? section()-&gt;style().visitedDependentColorWithColorFilter(endColorProperty) : Color(), BorderPrecedence::RowGroup));
 703         if (!result.exists())
 704             return result;
 705     }
 706 
 707     // (5) Our column and column group&#39;s end borders.
 708     bool startColEdge;
 709     bool endColEdge;
 710     if (RenderTableCol* colElt = table-&gt;colElement(col() + colSpan() - 1, &amp;startColEdge, &amp;endColEdge)) {
 711         if (colElt-&gt;isTableColumnGroup() &amp;&amp; endColEdge) {
 712             // The element is a colgroup and is also the last colgroup (in case of spanned colgroups).
 713             result = chooseBorder(result, CollapsedBorderValue(colElt-&gt;borderAdjoiningCellEndBorder(), includeColor ? colElt-&gt;style().visitedDependentColorWithColorFilter(endColorProperty) : Color(), BorderPrecedence::ColumnGroup));
 714             if (!result.exists())
 715                 return result;
 716         } else if (!colElt-&gt;isTableColumnGroup()) {
 717             // First apply the end border of the column irrespective of whether it is spanned or not. This is as per
 718             // HTML5 which states that: &quot;For the purposes of the CSS table model, the col element is expected to be
 719             // treated as if it was present as many times as its span attribute specifies&quot;.
 720             result = chooseBorder(result, CollapsedBorderValue(colElt-&gt;borderAdjoiningCellEndBorder(), includeColor ? colElt-&gt;style().visitedDependentColorWithColorFilter(endColorProperty) : Color(), BorderPrecedence::Column));
 721             if (!result.exists())
 722                 return result;
 723             // Next, if it has a parent colgroup then we apply its end border but only if it is adjacent to the cell.
 724             if (RenderTableCol* enclosingColumnGroup = colElt-&gt;enclosingColumnGroupIfAdjacentAfter()) {
 725                 result = chooseBorder(result, CollapsedBorderValue(enclosingColumnGroup-&gt;borderAdjoiningCellEndBorder(), includeColor ? enclosingColumnGroup-&gt;style().visitedDependentColorWithColorFilter(endColorProperty) : Color(), BorderPrecedence::ColumnGroup));
 726                 if (!result.exists())
 727                     return result;
 728             }
 729         }
 730     }
 731 
 732     // (6) The start border of the next column.
 733     if (!isEndColumn) {
 734         if (RenderTableCol* colElt = table-&gt;colElement(col() + colSpan(), &amp;startColEdge, &amp;endColEdge)) {
 735             if (colElt-&gt;isTableColumnGroup() &amp;&amp; startColEdge) {
 736                 // This case is a colgroup without any col, we only compute it if it is adjacent to the cell&#39;s edge.
 737                 result = chooseBorder(result, CollapsedBorderValue(colElt-&gt;borderAdjoiningCellBefore(*this), includeColor ? colElt-&gt;style().visitedDependentColorWithColorFilter(startColorProperty) : Color(), BorderPrecedence::ColumnGroup));
 738                 if (!result.exists())
 739                     return result;
 740             } else if (colElt-&gt;isTableColumn()) {
 741                 // Resolve the collapsing border against the col&#39;s border ignoring any &#39;span&#39; as per HTML5.
 742                 result = chooseBorder(result, CollapsedBorderValue(colElt-&gt;borderAdjoiningCellBefore(*this), includeColor ? colElt-&gt;style().visitedDependentColorWithColorFilter(startColorProperty) : Color(), BorderPrecedence::Column));
 743                 if (!result.exists())
 744                     return result;
 745                 // If we have a parent colgroup, resolve the border only if it is adjacent to the cell.
 746                 if (RenderTableCol* enclosingColumnGroup = colElt-&gt;enclosingColumnGroupIfAdjacentBefore()) {
 747                     result = chooseBorder(result, CollapsedBorderValue(enclosingColumnGroup-&gt;borderAdjoiningCellStartBorder(), includeColor ? enclosingColumnGroup-&gt;style().visitedDependentColorWithColorFilter(startColorProperty) : Color(), BorderPrecedence::ColumnGroup));
 748                     if (!result.exists())
 749                         return result;
 750                 }
 751             }
 752         }
 753     }
 754 
 755     if (endBorderAdjoinsTable) {
 756         // (7) The table&#39;s end border.
 757         result = chooseBorder(result, CollapsedBorderValue(table-&gt;tableEndBorderAdjoiningCell(*this), includeColor ? table-&gt;style().visitedDependentColorWithColorFilter(endColorProperty) : Color(), BorderPrecedence::Table));
 758         if (!result.exists())
 759             return result;
 760     }
 761 
 762     return result;
 763 }
 764 
 765 CollapsedBorderValue RenderTableCell::collapsedBeforeBorder(IncludeBorderColorOrNot includeColor) const
 766 {
 767     if (!table() || !section())
 768         return emptyBorder();
 769 
 770     if (m_hasEmptyCollapsedBeforeBorder)
 771         return emptyBorder();
 772 
 773     if (table()-&gt;collapsedBordersAreValid())
 774         return section()-&gt;cachedCollapsedBorder(*this, CBSBefore);
 775 
 776     CollapsedBorderValue result = computeCollapsedBeforeBorder(includeColor);
 777     setHasEmptyCollapsedBorder(CBSBefore, !result.width());
 778     if (includeColor &amp;&amp; !m_hasEmptyCollapsedBeforeBorder)
 779         section()-&gt;setCachedCollapsedBorder(*this, CBSBefore, result);
 780     return result;
 781 }
 782 
 783 CollapsedBorderValue RenderTableCell::computeCollapsedBeforeBorder(IncludeBorderColorOrNot includeColor) const
 784 {
 785     // For before border, we need to check, in order of precedence:
 786     // (1) Our before border.
 787     CSSPropertyID beforeColorProperty = includeColor ? CSSProperty::resolveDirectionAwareProperty(CSSPropertyBorderBlockStartColor, styleForCellFlow().direction(), styleForCellFlow().writingMode()) : CSSPropertyInvalid;
 788     CSSPropertyID afterColorProperty = includeColor ? CSSProperty::resolveDirectionAwareProperty(CSSPropertyBorderBlockEndColor, styleForCellFlow().direction(), styleForCellFlow().writingMode()) : CSSPropertyInvalid;
 789     CollapsedBorderValue result = CollapsedBorderValue(style().borderBefore(), includeColor ? style().visitedDependentColorWithColorFilter(beforeColorProperty) : Color(), BorderPrecedence::Cell);
 790 
 791     RenderTable* table = this-&gt;table();
 792     if (!table)
 793         return result;
 794     RenderTableCell* prevCell = table-&gt;cellAbove(this);
 795     if (prevCell) {
 796         // (2) A before cell&#39;s after border.
 797         result = chooseBorder(CollapsedBorderValue(prevCell-&gt;style().borderAfter(), includeColor ? prevCell-&gt;style().visitedDependentColorWithColorFilter(afterColorProperty) : Color(), BorderPrecedence::Cell), result);
 798         if (!result.exists())
 799             return result;
 800     }
 801 
 802     // (3) Our row&#39;s before border.
 803     result = chooseBorder(result, CollapsedBorderValue(parent()-&gt;style().borderBefore(), includeColor ? parent()-&gt;style().visitedDependentColorWithColorFilter(beforeColorProperty) : Color(), BorderPrecedence::Row));
 804     if (!result.exists())
 805         return result;
 806 
 807     // (4) The previous row&#39;s after border.
 808     if (prevCell) {
 809         RenderObject* prevRow = 0;
 810         if (prevCell-&gt;section() == section())
 811             prevRow = parent()-&gt;previousSibling();
 812         else
 813             prevRow = prevCell-&gt;section()-&gt;lastRow();
 814 
 815         if (prevRow) {
 816             result = chooseBorder(CollapsedBorderValue(prevRow-&gt;style().borderAfter(), includeColor ? prevRow-&gt;style().visitedDependentColorWithColorFilter(afterColorProperty) : Color(), BorderPrecedence::Row), result);
 817             if (!result.exists())
 818                 return result;
 819         }
 820     }
 821 
 822     // Now check row groups.
 823     RenderTableSection* currSection = section();
 824     if (!rowIndex()) {
 825         // (5) Our row group&#39;s before border.
 826         result = chooseBorder(result, CollapsedBorderValue(currSection-&gt;style().borderBefore(), includeColor ? currSection-&gt;style().visitedDependentColorWithColorFilter(beforeColorProperty) : Color(), BorderPrecedence::RowGroup));
 827         if (!result.exists())
 828             return result;
 829 
 830         // (6) Previous row group&#39;s after border.
 831         currSection = table-&gt;sectionAbove(currSection, SkipEmptySections);
 832         if (currSection) {
 833             result = chooseBorder(CollapsedBorderValue(currSection-&gt;style().borderAfter(), includeColor ? currSection-&gt;style().visitedDependentColorWithColorFilter(afterColorProperty) : Color(), BorderPrecedence::RowGroup), result);
 834             if (!result.exists())
 835                 return result;
 836         }
 837     }
 838 
 839     if (!currSection) {
 840         // (8) Our column and column group&#39;s before borders.
 841         RenderTableCol* colElt = table-&gt;colElement(col());
 842         if (colElt) {
 843             result = chooseBorder(result, CollapsedBorderValue(colElt-&gt;style().borderBefore(), includeColor ? colElt-&gt;style().visitedDependentColorWithColorFilter(beforeColorProperty) : Color(), BorderPrecedence::Column));
 844             if (!result.exists())
 845                 return result;
 846             if (RenderTableCol* enclosingColumnGroup = colElt-&gt;enclosingColumnGroup()) {
 847                 result = chooseBorder(result, CollapsedBorderValue(enclosingColumnGroup-&gt;style().borderBefore(), includeColor ? enclosingColumnGroup-&gt;style().visitedDependentColorWithColorFilter(beforeColorProperty) : Color(), BorderPrecedence::ColumnGroup));
 848                 if (!result.exists())
 849                     return result;
 850             }
 851         }
 852 
 853         // (9) The table&#39;s before border.
 854         result = chooseBorder(result, CollapsedBorderValue(table-&gt;style().borderBefore(), includeColor ? table-&gt;style().visitedDependentColorWithColorFilter(beforeColorProperty) : Color(), BorderPrecedence::Table));
 855         if (!result.exists())
 856             return result;
 857     }
 858 
 859     return result;
 860 }
 861 
 862 CollapsedBorderValue RenderTableCell::collapsedAfterBorder(IncludeBorderColorOrNot includeColor) const
 863 {
 864     if (!table() || !section())
 865         return emptyBorder();
 866 
 867     if (m_hasEmptyCollapsedAfterBorder)
 868         return emptyBorder();
 869 
 870     if (table()-&gt;collapsedBordersAreValid())
 871         return section()-&gt;cachedCollapsedBorder(*this, CBSAfter);
 872 
 873     CollapsedBorderValue result = computeCollapsedAfterBorder(includeColor);
 874     setHasEmptyCollapsedBorder(CBSAfter, !result.width());
 875     if (includeColor &amp;&amp; !m_hasEmptyCollapsedAfterBorder)
 876         section()-&gt;setCachedCollapsedBorder(*this, CBSAfter, result);
 877     return result;
 878 }
 879 
 880 CollapsedBorderValue RenderTableCell::computeCollapsedAfterBorder(IncludeBorderColorOrNot includeColor) const
 881 {
 882     // For after border, we need to check, in order of precedence:
 883     // (1) Our after border.
 884     CSSPropertyID beforeColorProperty = includeColor ? CSSProperty::resolveDirectionAwareProperty(CSSPropertyBorderBlockStartColor, styleForCellFlow().direction(), styleForCellFlow().writingMode()) : CSSPropertyInvalid;
 885     CSSPropertyID afterColorProperty = includeColor ? CSSProperty::resolveDirectionAwareProperty(CSSPropertyBorderBlockEndColor, styleForCellFlow().direction(), styleForCellFlow().writingMode()) : CSSPropertyInvalid;
 886     CollapsedBorderValue result = CollapsedBorderValue(style().borderAfter(), includeColor ? style().visitedDependentColorWithColorFilter(afterColorProperty) : Color(), BorderPrecedence::Cell);
 887 
 888     RenderTable* table = this-&gt;table();
 889     if (!table)
 890         return result;
 891     RenderTableCell* nextCell = table-&gt;cellBelow(this);
 892     if (nextCell) {
 893         // (2) An after cell&#39;s before border.
 894         result = chooseBorder(result, CollapsedBorderValue(nextCell-&gt;style().borderBefore(), includeColor ? nextCell-&gt;style().visitedDependentColorWithColorFilter(beforeColorProperty) : Color(), BorderPrecedence::Cell));
 895         if (!result.exists())
 896             return result;
 897     }
 898 
 899     // (3) Our row&#39;s after border. (FIXME: Deal with rowspan!)
 900     result = chooseBorder(result, CollapsedBorderValue(parent()-&gt;style().borderAfter(), includeColor ? parent()-&gt;style().visitedDependentColorWithColorFilter(afterColorProperty) : Color(), BorderPrecedence::Row));
 901     if (!result.exists())
 902         return result;
 903 
 904     // (4) The next row&#39;s before border.
 905     if (nextCell) {
 906         result = chooseBorder(result, CollapsedBorderValue(nextCell-&gt;parent()-&gt;style().borderBefore(), includeColor ? nextCell-&gt;parent()-&gt;style().visitedDependentColorWithColorFilter(beforeColorProperty) : Color(), BorderPrecedence::Row));
 907         if (!result.exists())
 908             return result;
 909     }
 910 
 911     // Now check row groups.
 912     RenderTableSection* currSection = section();
 913     if (rowIndex() + rowSpan() &gt;= currSection-&gt;numRows()) {
 914         // (5) Our row group&#39;s after border.
 915         result = chooseBorder(result, CollapsedBorderValue(currSection-&gt;style().borderAfter(), includeColor ? currSection-&gt;style().visitedDependentColorWithColorFilter(afterColorProperty) : Color(), BorderPrecedence::RowGroup));
 916         if (!result.exists())
 917             return result;
 918 
 919         // (6) Following row group&#39;s before border.
 920         currSection = table-&gt;sectionBelow(currSection, SkipEmptySections);
 921         if (currSection) {
 922             result = chooseBorder(result, CollapsedBorderValue(currSection-&gt;style().borderBefore(), includeColor ? currSection-&gt;style().visitedDependentColorWithColorFilter(beforeColorProperty) : Color(), BorderPrecedence::RowGroup));
 923             if (!result.exists())
 924                 return result;
 925         }
 926     }
 927 
 928     if (!currSection) {
 929         // (8) Our column and column group&#39;s after borders.
 930         RenderTableCol* colElt = table-&gt;colElement(col());
 931         if (colElt) {
 932             result = chooseBorder(result, CollapsedBorderValue(colElt-&gt;style().borderAfter(), includeColor ? colElt-&gt;style().visitedDependentColorWithColorFilter(afterColorProperty) : Color(), BorderPrecedence::Column));
 933             if (!result.exists()) return result;
 934             if (RenderTableCol* enclosingColumnGroup = colElt-&gt;enclosingColumnGroup()) {
 935                 result = chooseBorder(result, CollapsedBorderValue(enclosingColumnGroup-&gt;style().borderAfter(), includeColor ? enclosingColumnGroup-&gt;style().visitedDependentColorWithColorFilter(afterColorProperty) : Color(), BorderPrecedence::ColumnGroup));
 936                 if (!result.exists())
 937                     return result;
 938             }
 939         }
 940 
 941         // (9) The table&#39;s after border.
 942         result = chooseBorder(result, CollapsedBorderValue(table-&gt;style().borderAfter(), includeColor ? table-&gt;style().visitedDependentColorWithColorFilter(afterColorProperty) : Color(), BorderPrecedence::Table));
 943         if (!result.exists())
 944             return result;
 945     }
 946 
 947     return result;
 948 }
 949 
 950 inline CollapsedBorderValue RenderTableCell::cachedCollapsedLeftBorder(const RenderStyle&amp; styleForCellFlow) const
 951 {
 952     if (styleForCellFlow.isHorizontalWritingMode())
 953         return styleForCellFlow.isLeftToRightDirection() ? section()-&gt;cachedCollapsedBorder(*this, CBSStart) : section()-&gt;cachedCollapsedBorder(*this, CBSEnd);
 954     return styleForCellFlow.isFlippedBlocksWritingMode() ? section()-&gt;cachedCollapsedBorder(*this, CBSAfter) : section()-&gt;cachedCollapsedBorder(*this, CBSBefore);
 955 }
 956 
 957 inline CollapsedBorderValue RenderTableCell::cachedCollapsedRightBorder(const RenderStyle&amp; styleForCellFlow) const
 958 {
 959     if (styleForCellFlow.isHorizontalWritingMode())
 960         return styleForCellFlow.isLeftToRightDirection() ? section()-&gt;cachedCollapsedBorder(*this, CBSEnd) : section()-&gt;cachedCollapsedBorder(*this, CBSStart);
 961     return styleForCellFlow.isFlippedBlocksWritingMode() ? section()-&gt;cachedCollapsedBorder(*this, CBSBefore) : section()-&gt;cachedCollapsedBorder(*this, CBSAfter);
 962 }
 963 
 964 inline CollapsedBorderValue RenderTableCell::cachedCollapsedTopBorder(const RenderStyle&amp; styleForCellFlow) const
 965 {
 966     if (styleForCellFlow.isHorizontalWritingMode())
 967         return styleForCellFlow.isFlippedBlocksWritingMode() ? section()-&gt;cachedCollapsedBorder(*this, CBSAfter) : section()-&gt;cachedCollapsedBorder(*this, CBSBefore);
 968     return styleForCellFlow.isLeftToRightDirection() ? section()-&gt;cachedCollapsedBorder(*this, CBSStart) : section()-&gt;cachedCollapsedBorder(*this, CBSEnd);
 969 }
 970 
 971 inline CollapsedBorderValue RenderTableCell::cachedCollapsedBottomBorder(const RenderStyle&amp; styleForCellFlow) const
 972 {
 973     if (styleForCellFlow.isHorizontalWritingMode())
 974         return styleForCellFlow.isFlippedBlocksWritingMode() ? section()-&gt;cachedCollapsedBorder(*this, CBSBefore) : section()-&gt;cachedCollapsedBorder(*this, CBSAfter);
 975     return styleForCellFlow.isLeftToRightDirection() ? section()-&gt;cachedCollapsedBorder(*this, CBSEnd) : section()-&gt;cachedCollapsedBorder(*this, CBSStart);
 976 }
 977 
 978 LayoutUnit RenderTableCell::borderLeft() const
 979 {
 980     RenderTable* table = this-&gt;table();
 981     if (!table)
 982         return RenderBlockFlow::borderLeft();
 983     return table-&gt;collapseBorders() ? borderHalfLeft(false) : RenderBlockFlow::borderLeft();
 984 }
 985 
 986 LayoutUnit RenderTableCell::borderRight() const
 987 {
 988     RenderTable* table = this-&gt;table();
 989     if (!table)
 990         return RenderBlockFlow::borderRight();
 991     return table-&gt;collapseBorders() ? borderHalfRight(false) : RenderBlockFlow::borderRight();
 992 }
 993 
 994 LayoutUnit RenderTableCell::borderTop() const
 995 {
 996     RenderTable* table = this-&gt;table();
 997     if (!table)
 998         return RenderBlockFlow::borderTop();
 999     return table-&gt;collapseBorders() ? borderHalfTop(false) : RenderBlockFlow::borderTop();
1000 }
1001 
1002 LayoutUnit RenderTableCell::borderBottom() const
1003 {
1004     RenderTable* table = this-&gt;table();
1005     if (!table)
1006         return RenderBlockFlow::borderBottom();
1007     return table-&gt;collapseBorders() ? borderHalfBottom(false) : RenderBlockFlow::borderBottom();
1008 }
1009 
1010 // FIXME: https://bugs.webkit.org/show_bug.cgi?id=46191, make the collapsed border drawing
1011 // work with different block flow values instead of being hard-coded to top-to-bottom.
1012 LayoutUnit RenderTableCell::borderStart() const
1013 {
1014     RenderTable* table = this-&gt;table();
1015     if (!table)
1016         return RenderBlockFlow::borderStart();
1017     return table-&gt;collapseBorders() ? borderHalfStart(false) : RenderBlockFlow::borderStart();
1018 }
1019 
1020 LayoutUnit RenderTableCell::borderEnd() const
1021 {
1022     RenderTable* table = this-&gt;table();
1023     if (!table)
1024         return RenderBlockFlow::borderEnd();
1025     return table-&gt;collapseBorders() ? borderHalfEnd(false) : RenderBlockFlow::borderEnd();
1026 }
1027 
1028 LayoutUnit RenderTableCell::borderBefore() const
1029 {
1030     RenderTable* table = this-&gt;table();
1031     if (!table)
1032         return RenderBlockFlow::borderBefore();
1033     return table-&gt;collapseBorders() ? borderHalfBefore(false) : RenderBlockFlow::borderBefore();
1034 }
1035 
1036 LayoutUnit RenderTableCell::borderAfter() const
1037 {
1038     RenderTable* table = this-&gt;table();
1039     if (!table)
1040         return RenderBlockFlow::borderAfter();
1041     return table-&gt;collapseBorders() ? borderHalfAfter(false) : RenderBlockFlow::borderAfter();
1042 }
1043 
1044 LayoutUnit RenderTableCell::borderHalfLeft(bool outer) const
1045 {
1046     const RenderStyle&amp; styleForCellFlow = this-&gt;styleForCellFlow();
1047     if (styleForCellFlow.isHorizontalWritingMode())
1048         return styleForCellFlow.isLeftToRightDirection() ? borderHalfStart(outer) : borderHalfEnd(outer);
1049     return styleForCellFlow.isFlippedBlocksWritingMode() ? borderHalfAfter(outer) : borderHalfBefore(outer);
1050 }
1051 
1052 LayoutUnit RenderTableCell::borderHalfRight(bool outer) const
1053 {
1054     const RenderStyle&amp; styleForCellFlow = this-&gt;styleForCellFlow();
1055     if (styleForCellFlow.isHorizontalWritingMode())
1056         return styleForCellFlow.isLeftToRightDirection() ? borderHalfEnd(outer) : borderHalfStart(outer);
1057     return styleForCellFlow.isFlippedBlocksWritingMode() ? borderHalfBefore(outer) : borderHalfAfter(outer);
1058 }
1059 
1060 LayoutUnit RenderTableCell::borderHalfTop(bool outer) const
1061 {
1062     const RenderStyle&amp; styleForCellFlow = this-&gt;styleForCellFlow();
1063     if (styleForCellFlow.isHorizontalWritingMode())
1064         return styleForCellFlow.isFlippedBlocksWritingMode() ? borderHalfAfter(outer) : borderHalfBefore(outer);
1065     return styleForCellFlow.isLeftToRightDirection() ? borderHalfStart(outer) : borderHalfEnd(outer);
1066 }
1067 
1068 LayoutUnit RenderTableCell::borderHalfBottom(bool outer) const
1069 {
1070     const RenderStyle&amp; styleForCellFlow = this-&gt;styleForCellFlow();
1071     if (styleForCellFlow.isHorizontalWritingMode())
1072         return styleForCellFlow.isFlippedBlocksWritingMode() ? borderHalfBefore(outer) : borderHalfAfter(outer);
1073     return styleForCellFlow.isLeftToRightDirection() ? borderHalfEnd(outer) : borderHalfStart(outer);
1074 }
1075 
1076 LayoutUnit RenderTableCell::borderHalfStart(bool outer) const
1077 {
1078     CollapsedBorderValue border = collapsedStartBorder(DoNotIncludeBorderColor);
1079     if (border.exists())
1080         return CollapsedBorderValue::adjustedCollapsedBorderWidth(border.width(), document().deviceScaleFactor(), styleForCellFlow().isLeftToRightDirection() ^ outer);
1081     return 0;
1082 }
1083 
1084 LayoutUnit RenderTableCell::borderHalfEnd(bool outer) const
1085 {
1086     CollapsedBorderValue border = collapsedEndBorder(DoNotIncludeBorderColor);
1087     if (border.exists())
1088         return CollapsedBorderValue::adjustedCollapsedBorderWidth(border.width(), document().deviceScaleFactor(), !(styleForCellFlow().isLeftToRightDirection() ^ outer));
1089     return 0;
1090 }
1091 
1092 LayoutUnit RenderTableCell::borderHalfBefore(bool outer) const
1093 {
1094     CollapsedBorderValue border = collapsedBeforeBorder(DoNotIncludeBorderColor);
1095     if (border.exists())
1096         return CollapsedBorderValue::adjustedCollapsedBorderWidth(border.width(), document().deviceScaleFactor(), !(styleForCellFlow().isFlippedBlocksWritingMode() ^ outer));
1097     return 0;
1098 }
1099 
1100 LayoutUnit RenderTableCell::borderHalfAfter(bool outer) const
1101 {
1102     CollapsedBorderValue border = collapsedAfterBorder(DoNotIncludeBorderColor);
1103     if (border.exists())
1104         return CollapsedBorderValue::adjustedCollapsedBorderWidth(border.width(), document().deviceScaleFactor(), styleForCellFlow().isFlippedBlocksWritingMode() ^ outer);
1105     return 0;
1106 }
1107 
1108 void RenderTableCell::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1109 {
1110     ASSERT(paintInfo.phase != PaintPhase::CollapsedTableBorders);
1111     RenderBlockFlow::paint(paintInfo, paintOffset);
1112 }
1113 
1114 struct CollapsedBorder {
1115     CollapsedBorderValue borderValue;
1116     BoxSide side;
1117     bool shouldPaint;
1118     LayoutUnit x1;
1119     LayoutUnit y1;
1120     LayoutUnit x2;
1121     LayoutUnit y2;
1122     BorderStyle style;
1123 };
1124 
1125 class CollapsedBorders {
1126 public:
1127     CollapsedBorders()
1128         : m_count(0)
1129     {
1130     }
1131 
1132     void addBorder(const CollapsedBorderValue&amp; borderValue, BoxSide borderSide, bool shouldPaint,
1133         LayoutUnit x1, LayoutUnit y1, LayoutUnit x2, LayoutUnit y2, BorderStyle borderStyle)
1134     {
1135         if (borderValue.exists() &amp;&amp; shouldPaint) {
1136             m_borders[m_count].borderValue = borderValue;
1137             m_borders[m_count].side = borderSide;
1138             m_borders[m_count].shouldPaint = shouldPaint;
1139             m_borders[m_count].x1 = x1;
1140             m_borders[m_count].x2 = x2;
1141             m_borders[m_count].y1 = y1;
1142             m_borders[m_count].y2 = y2;
1143             m_borders[m_count].style = borderStyle;
1144             m_count++;
1145         }
1146     }
1147 
1148     CollapsedBorder* nextBorder()
1149     {
1150         for (unsigned i = 0; i &lt; m_count; i++) {
1151             if (m_borders[i].borderValue.exists() &amp;&amp; m_borders[i].shouldPaint) {
1152                 m_borders[i].shouldPaint = false;
1153                 return &amp;m_borders[i];
1154             }
1155         }
1156 
1157         return 0;
1158     }
1159 
1160     CollapsedBorder m_borders[4];
1161     unsigned m_count;
1162 };
1163 
1164 static void addBorderStyle(RenderTable::CollapsedBorderValues&amp; borderValues,
1165                            CollapsedBorderValue borderValue)
1166 {
1167     if (!borderValue.exists())
1168         return;
1169     size_t count = borderValues.size();
1170     for (size_t i = 0; i &lt; count; ++i)
1171         if (borderValues[i].isSameIgnoringColor(borderValue))
1172             return;
1173     borderValues.append(borderValue);
1174 }
1175 
1176 void RenderTableCell::collectBorderValues(RenderTable::CollapsedBorderValues&amp; borderValues) const
1177 {
1178     addBorderStyle(borderValues, collapsedStartBorder());
1179     addBorderStyle(borderValues, collapsedEndBorder());
1180     addBorderStyle(borderValues, collapsedBeforeBorder());
1181     addBorderStyle(borderValues, collapsedAfterBorder());
1182 }
1183 
1184 static int compareBorderValuesForQSort(const void* pa, const void* pb)
1185 {
1186     const CollapsedBorderValue* a = static_cast&lt;const CollapsedBorderValue*&gt;(pa);
1187     const CollapsedBorderValue* b = static_cast&lt;const CollapsedBorderValue*&gt;(pb);
1188     if (a-&gt;isSameIgnoringColor(*b))
1189         return 0;
1190     return compareBorders(*a, *b);
1191 }
1192 
1193 void RenderTableCell::sortBorderValues(RenderTable::CollapsedBorderValues&amp; borderValues)
1194 {
1195     qsort(borderValues.data(), borderValues.size(), sizeof(CollapsedBorderValue),
1196         compareBorderValuesForQSort);
1197 }
1198 
1199 void RenderTableCell::paintCollapsedBorders(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1200 {
1201     ASSERT(paintInfo.phase == PaintPhase::CollapsedTableBorders);
1202 
1203     if (!paintInfo.shouldPaintWithinRoot(*this) || style().visibility() != Visibility::Visible)
1204         return;
1205 
1206     LayoutRect localRepaintRect = paintInfo.rect;
1207     LayoutRect paintRect = LayoutRect(paintOffset + location(), frameRect().size());
1208     if (paintRect.y() - table()-&gt;outerBorderTop() &gt;= localRepaintRect.maxY())
1209         return;
1210 
1211     if (paintRect.maxY() + table()-&gt;outerBorderBottom() &lt;= localRepaintRect.y())
1212         return;
1213 
1214     GraphicsContext&amp; graphicsContext = paintInfo.context();
1215     if (!table()-&gt;currentBorderValue() || graphicsContext.paintingDisabled())
1216         return;
1217 
1218     const RenderStyle&amp; styleForCellFlow = this-&gt;styleForCellFlow();
1219     CollapsedBorderValue leftVal = cachedCollapsedLeftBorder(styleForCellFlow);
1220     CollapsedBorderValue rightVal = cachedCollapsedRightBorder(styleForCellFlow);
1221     CollapsedBorderValue topVal = cachedCollapsedTopBorder(styleForCellFlow);
1222     CollapsedBorderValue bottomVal = cachedCollapsedBottomBorder(styleForCellFlow);
1223 
1224     // Adjust our x/y/width/height so that we paint the collapsed borders at the correct location.
1225     LayoutUnit topWidth = topVal.width();
1226     LayoutUnit bottomWidth = bottomVal.width();
1227     LayoutUnit leftWidth = leftVal.width();
1228     LayoutUnit rightWidth = rightVal.width();
1229 
1230     float deviceScaleFactor = document().deviceScaleFactor();
1231     LayoutUnit leftHalfCollapsedBorder = CollapsedBorderValue::adjustedCollapsedBorderWidth(leftWidth , deviceScaleFactor, false);
1232     LayoutUnit topHalfCollapsedBorder = CollapsedBorderValue::adjustedCollapsedBorderWidth(topWidth, deviceScaleFactor, false);
1233     LayoutUnit righHalftCollapsedBorder = CollapsedBorderValue::adjustedCollapsedBorderWidth(rightWidth, deviceScaleFactor, true);
1234     LayoutUnit bottomHalfCollapsedBorder = CollapsedBorderValue::adjustedCollapsedBorderWidth(bottomWidth, deviceScaleFactor, true);
1235 
1236     LayoutRect borderRect = LayoutRect(paintRect.x() - leftHalfCollapsedBorder,
1237         paintRect.y() - topHalfCollapsedBorder,
1238         paintRect.width() + leftHalfCollapsedBorder + righHalftCollapsedBorder,
1239         paintRect.height() + topHalfCollapsedBorder + bottomHalfCollapsedBorder);
1240 
1241     BorderStyle topStyle = collapsedBorderStyle(topVal.style());
1242     BorderStyle bottomStyle = collapsedBorderStyle(bottomVal.style());
1243     BorderStyle leftStyle = collapsedBorderStyle(leftVal.style());
1244     BorderStyle rightStyle = collapsedBorderStyle(rightVal.style());
1245 
1246     bool renderTop = topStyle &gt; BorderStyle::Hidden &amp;&amp; !topVal.isTransparent() &amp;&amp; floorToDevicePixel(topWidth, deviceScaleFactor);
1247     bool renderBottom = bottomStyle &gt; BorderStyle::Hidden &amp;&amp; !bottomVal.isTransparent() &amp;&amp; floorToDevicePixel(bottomWidth, deviceScaleFactor);
1248     bool renderLeft = leftStyle &gt; BorderStyle::Hidden &amp;&amp; !leftVal.isTransparent() &amp;&amp; floorToDevicePixel(leftWidth, deviceScaleFactor);
1249     bool renderRight = rightStyle &gt; BorderStyle::Hidden &amp;&amp; !rightVal.isTransparent() &amp;&amp; floorToDevicePixel(rightWidth, deviceScaleFactor);
1250 
1251     // We never paint diagonals at the joins.  We simply let the border with the highest
1252     // precedence paint on top of borders with lower precedence.
1253     CollapsedBorders borders;
1254     borders.addBorder(topVal, BSTop, renderTop, borderRect.x(), borderRect.y(), borderRect.maxX(), borderRect.y() + topWidth, topStyle);
1255     borders.addBorder(bottomVal, BSBottom, renderBottom, borderRect.x(), borderRect.maxY() - bottomWidth, borderRect.maxX(), borderRect.maxY(), bottomStyle);
1256     borders.addBorder(leftVal, BSLeft, renderLeft, borderRect.x(), borderRect.y(), borderRect.x() + leftWidth, borderRect.maxY(), leftStyle);
1257     borders.addBorder(rightVal, BSRight, renderRight, borderRect.maxX() - rightWidth, borderRect.y(), borderRect.maxX(), borderRect.maxY(), rightStyle);
1258 
1259     bool antialias = shouldAntialiasLines(graphicsContext);
1260 
1261     for (CollapsedBorder* border = borders.nextBorder(); border; border = borders.nextBorder()) {
1262         if (border-&gt;borderValue.isSameIgnoringColor(*table()-&gt;currentBorderValue()))
1263             drawLineForBoxSide(graphicsContext, LayoutRect(LayoutPoint(border-&gt;x1, border-&gt;y1), LayoutPoint(border-&gt;x2, border-&gt;y2)), border-&gt;side,
1264                 border-&gt;borderValue.color(), border-&gt;style, 0, 0, antialias);
1265     }
1266 }
1267 
1268 void RenderTableCell::paintBackgroundsBehindCell(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, RenderElement* backgroundObject)
1269 {
1270     if (!paintInfo.shouldPaintWithinRoot(*this))
1271         return;
1272 
1273     if (!backgroundObject)
1274         return;
1275 
1276     if (style().visibility() != Visibility::Visible)
1277         return;
1278 
1279     RenderTable* tableElt = table();
1280     if (!tableElt-&gt;collapseBorders() &amp;&amp; style().emptyCells() == EmptyCell::Hide &amp;&amp; !firstChild())
1281         return;
1282 
1283     LayoutPoint adjustedPaintOffset = paintOffset;
1284     if (backgroundObject != this)
1285         adjustedPaintOffset.moveBy(location());
1286 
1287     const auto&amp; style = backgroundObject-&gt;style();
1288     auto&amp; bgLayer = style.backgroundLayers();
1289 
1290     auto color = style.visitedDependentColor(CSSPropertyBackgroundColor);
1291     auto compositeOp = document().compositeOperatorForBackgroundColor(color, *this);
1292 
1293     color = style.colorByApplyingColorFilter(color);
1294 
1295     if (bgLayer.hasImage() || color.isValid()) {
1296         // We have to clip here because the background would paint
1297         // on top of the borders otherwise.  This only matters for cells and rows.
1298         bool shouldClip = backgroundObject-&gt;hasLayer() &amp;&amp; (backgroundObject == this || backgroundObject == parent()) &amp;&amp; tableElt-&gt;collapseBorders();
1299         GraphicsContextStateSaver stateSaver(paintInfo.context(), shouldClip);
1300         if (shouldClip) {
1301             LayoutRect clipRect(adjustedPaintOffset.x() + borderLeft(), adjustedPaintOffset.y() + borderTop(),
1302                 width() - borderLeft() - borderRight(), height() - borderTop() - borderBottom());
1303             paintInfo.context().clip(clipRect);
1304         }
1305         paintFillLayers(paintInfo, color, bgLayer, LayoutRect(adjustedPaintOffset, frameRect().size()), BackgroundBleedNone, compositeOp, backgroundObject);
1306     }
1307 }
1308 
1309 void RenderTableCell::paintBoxDecorations(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1310 {
1311     if (!paintInfo.shouldPaintWithinRoot(*this))
1312         return;
1313 
1314     RenderTable* table = this-&gt;table();
1315     if (!table-&gt;collapseBorders() &amp;&amp; style().emptyCells() == EmptyCell::Hide &amp;&amp; !firstChild())
1316         return;
1317 
1318     LayoutRect paintRect = LayoutRect(paintOffset, frameRect().size());
1319     adjustBorderBoxRectForPainting(paintRect);
1320 
1321     paintBoxShadow(paintInfo, paintRect, style(), Normal);
1322 
1323     // Paint our cell background.
1324     paintBackgroundsBehindCell(paintInfo, paintOffset, this);
1325 
1326     paintBoxShadow(paintInfo, paintRect, style(), Inset);
1327 
1328     if (!style().hasBorder() || table-&gt;collapseBorders())
1329         return;
1330 
1331     paintBorder(paintInfo, paintRect, style());
1332 }
1333 
1334 void RenderTableCell::paintMask(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1335 {
1336     if (style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::Mask)
1337         return;
1338 
1339     RenderTable* tableElt = table();
1340     if (!tableElt-&gt;collapseBorders() &amp;&amp; style().emptyCells() == EmptyCell::Hide &amp;&amp; !firstChild())
1341         return;
1342 
1343     LayoutRect paintRect = LayoutRect(paintOffset, frameRect().size());
1344     adjustBorderBoxRectForPainting(paintRect);
1345 
1346     paintMaskImages(paintInfo, paintRect);
1347 }
1348 
1349 bool RenderTableCell::boxShadowShouldBeAppliedToBackground(const LayoutPoint&amp;, BackgroundBleedAvoidance, InlineFlowBox*) const
1350 {
1351     return false;
1352 }
1353 
1354 void RenderTableCell::scrollbarsChanged(bool horizontalScrollbarChanged, bool verticalScrollbarChanged)
1355 {
1356     LayoutUnit scrollbarHeight = scrollbarLogicalHeight();
1357     if (!scrollbarHeight)
1358         return; // Not sure if we should be doing something when a scrollbar goes away or not.
1359 
1360     // We only care if the scrollbar that affects our intrinsic padding has been added.
1361     if ((isHorizontalWritingMode() &amp;&amp; !horizontalScrollbarChanged) ||
1362         (!isHorizontalWritingMode() &amp;&amp; !verticalScrollbarChanged))
1363         return;
1364 
1365     // Shrink our intrinsic padding as much as possible to accommodate the scrollbar.
1366     if (style().verticalAlign() == VerticalAlign::Middle) {
1367         LayoutUnit totalHeight = logicalHeight();
1368         LayoutUnit heightWithoutIntrinsicPadding = totalHeight - intrinsicPaddingBefore() - intrinsicPaddingAfter();
1369         totalHeight -= scrollbarHeight;
1370         LayoutUnit newBeforePadding = (totalHeight - heightWithoutIntrinsicPadding) / 2;
1371         LayoutUnit newAfterPadding = totalHeight - heightWithoutIntrinsicPadding - newBeforePadding;
1372         setIntrinsicPaddingBefore(newBeforePadding);
1373         setIntrinsicPaddingAfter(newAfterPadding);
1374     } else
1375         setIntrinsicPaddingAfter(intrinsicPaddingAfter() - scrollbarHeight);
1376 }
1377 
1378 RenderPtr&lt;RenderTableCell&gt; RenderTableCell::createTableCellWithStyle(Document&amp; document, const RenderStyle&amp; style)
1379 {
1380     auto cell = createRenderer&lt;RenderTableCell&gt;(document, RenderStyle::createAnonymousStyleWithDisplay(style, DisplayType::TableCell));
1381     cell-&gt;initializeStyle();
1382     return cell;
1383 }
1384 
1385 RenderPtr&lt;RenderTableCell&gt; RenderTableCell::createAnonymousWithParentRenderer(const RenderTableRow&amp; parent)
1386 {
1387     return RenderTableCell::createTableCellWithStyle(parent.document(), parent.style());
1388 }
1389 
1390 bool RenderTableCell::hasLineIfEmpty() const
1391 {
1392     if (element() &amp;&amp; element()-&gt;hasEditableStyle())
1393         return true;
1394 
1395     return RenderBlock::hasLineIfEmpty();
1396 }
1397 
1398 } // namespace WebCore
    </pre>
  </body>
</html>