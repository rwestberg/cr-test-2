<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="VM.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VMTraps.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #pragma once
  30 
  31 #include &quot;CallData.h&quot;
  32 #include &quot;CodeSpecializationKind.h&quot;
  33 #include &quot;CompleteSubspace.h&quot;
  34 #include &quot;ConcurrentJSLock.h&quot;
  35 #include &quot;ControlFlowProfiler.h&quot;
  36 #include &quot;DateInstanceCache.h&quot;
  37 #include &quot;DeleteAllCodeEffort.h&quot;
  38 #include &quot;ExceptionEventLocation.h&quot;
  39 #include &quot;ExecutableAllocator.h&quot;
  40 #include &quot;FunctionHasExecutedCache.h&quot;

  41 #include &quot;Heap.h&quot;
  42 #include &quot;Intrinsic.h&quot;
  43 #include &quot;IsoCellSet.h&quot;
  44 #include &quot;IsoSubspace.h&quot;
  45 #include &quot;JITThunks.h&quot;
  46 #include &quot;JSCJSValue.h&quot;
  47 #include &quot;JSLock.h&quot;
  48 #include &quot;MacroAssemblerCodeRef.h&quot;
  49 #include &quot;Microtask.h&quot;
  50 #include &quot;NumericStrings.h&quot;
  51 #include &quot;SmallStrings.h&quot;
  52 #include &quot;Strong.h&quot;
  53 #include &quot;StructureCache.h&quot;
  54 #include &quot;SubspaceAccess.h&quot;
  55 #include &quot;VMTraps.h&quot;
  56 #include &quot;WasmContext.h&quot;
  57 #include &quot;Watchpoint.h&quot;
  58 #include &lt;wtf/BumpPointerAllocator.h&gt;
  59 #include &lt;wtf/CheckedArithmetic.h&gt;
  60 #include &lt;wtf/DateMath.h&gt;
</pre>
<hr />
<pre>
 105 class CommonIdentifiers;
 106 class CompactVariableMap;
 107 class CustomGetterSetter;
 108 class DOMAttributeGetterSetter;
 109 class ExecState;
 110 class Exception;
 111 class ExceptionScope;
 112 class FastMallocAlignedMemoryAllocator;
 113 class GigacageAlignedMemoryAllocator;
 114 class HandleStack;
 115 class TypeProfiler;
 116 class TypeProfilerLog;
 117 class HasOwnPropertyCache;
 118 class HeapProfiler;
 119 class Identifier;
 120 class Interpreter;
 121 class JSCustomGetterSetterFunction;
 122 class JSDestructibleObjectHeapCellType;
 123 class JSGlobalObject;
 124 class JSObject;


 125 class JSRunLoopTimer;
<span class="line-removed"> 126 class JSSegmentedVariableObjectHeapCellType;</span>
 127 class JSStringHeapCellType;
 128 class JSWebAssemblyCodeBlockHeapCellType;
 129 class JSWebAssemblyInstance;
 130 class LLIntOffsetsExtractor;
 131 class NativeExecutable;
 132 class PromiseDeferredTimer;
 133 class RegExp;
 134 class RegExpCache;
 135 class Register;
 136 class RegisterAtOffsetList;
 137 #if ENABLE(SAMPLING_PROFILER)
 138 class SamplingProfiler;
 139 #endif
 140 class ShadowChicken;
 141 class ScriptExecutable;
 142 class SourceProvider;
 143 class SourceProviderCache;
 144 class StackFrame;
 145 class Structure;
 146 #if ENABLE(REGEXP_TRACING)
 147 class RegExp;
 148 #endif
 149 class Symbol;
 150 class TypedArrayController;
 151 class UnlinkedCodeBlock;
 152 class UnlinkedEvalCodeBlock;
 153 class UnlinkedFunctionExecutable;
 154 class UnlinkedProgramCodeBlock;
 155 class UnlinkedModuleProgramCodeBlock;
 156 class VirtualRegister;
 157 class VMEntryScope;
 158 class Watchdog;
 159 class Watchpoint;
 160 class WatchpointSet;

 161 
 162 #if ENABLE(FTL_JIT)
 163 namespace FTL {
 164 class Thunks;
 165 }
 166 #endif // ENABLE(FTL_JIT)
 167 namespace Profiler {
 168 class Database;
 169 }
 170 namespace DOMJIT {
 171 class Signature;
 172 }
 173 
 174 struct EntryFrame;
 175 struct HashTable;
 176 struct Instruction;
 177 struct ValueProfile;
 178 
 179 typedef ExecState CallFrame;
 180 
 181 struct LocalTimeOffsetCache {
 182     LocalTimeOffsetCache()
 183         : start(0.0)
 184         , end(-1.0)
 185         , increment(0.0)
<span class="line-removed"> 186         , timeType(WTF::UTCTime)</span>
 187     {
 188     }
 189 
 190     void reset()
 191     {
 192         offset = LocalTimeOffset();
 193         start = 0.0;
 194         end = -1.0;
 195         increment = 0.0;
<span class="line-removed"> 196         timeType = WTF::UTCTime;</span>
 197     }
 198 
 199     LocalTimeOffset offset;
 200     double start;
 201     double end;
 202     double increment;
<span class="line-removed"> 203     WTF::TimeType timeType;</span>
 204 };
 205 
 206 class QueuedTask {
 207     WTF_MAKE_NONCOPYABLE(QueuedTask);
 208     WTF_MAKE_FAST_ALLOCATED;
 209 public:
 210     void run();
 211 
 212     QueuedTask(VM&amp; vm, JSGlobalObject* globalObject, Ref&lt;Microtask&gt;&amp;&amp; microtask)
 213         : m_globalObject(vm, globalObject)
 214         , m_microtask(WTFMove(microtask))
 215     {
 216     }
 217 
 218 private:
 219     Strong&lt;JSGlobalObject&gt; m_globalObject;
 220     Ref&lt;Microtask&gt; m_microtask;
 221 };
 222 
 223 class ConservativeRoots;
</pre>
<hr />
<pre>
 278     bool isSharedInstance() { return vmType == APIShared; }
 279     bool usingAPI() { return vmType != Default; }
 280     JS_EXPORT_PRIVATE static bool sharedInstanceExists();
 281     JS_EXPORT_PRIVATE static VM&amp; sharedInstance();
 282 
 283     JS_EXPORT_PRIVATE static Ref&lt;VM&gt; create(HeapType = SmallHeap);
 284     static Ref&lt;VM&gt; createContextGroup(HeapType = SmallHeap);
 285     JS_EXPORT_PRIVATE ~VM();
 286 
 287     Watchdog&amp; ensureWatchdog();
 288     Watchdog* watchdog() { return m_watchdog.get(); }
 289 
 290     HeapProfiler* heapProfiler() const { return m_heapProfiler.get(); }
 291     JS_EXPORT_PRIVATE HeapProfiler&amp; ensureHeapProfiler();
 292 
 293 #if ENABLE(SAMPLING_PROFILER)
 294     SamplingProfiler* samplingProfiler() { return m_samplingProfiler.get(); }
 295     JS_EXPORT_PRIVATE SamplingProfiler&amp; ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp;);
 296 #endif
 297 






 298     static unsigned numberOfIDs() { return s_numberOfIDs.load(); }
 299     unsigned id() const { return m_id; }
 300     bool isEntered() const { return !!entryScope; }
 301 
 302     inline CallFrame* topJSCallFrame() const;
 303 
 304     // Global object in which execution began.
 305     JS_EXPORT_PRIVATE JSGlobalObject* vmEntryGlobalObject(const CallFrame*) const;
 306 
 307 private:
 308     unsigned nextID();
 309 
 310     static Atomic&lt;unsigned&gt; s_numberOfIDs;
 311 
 312     unsigned m_id;
 313     RefPtr&lt;JSLock&gt; m_apiLock;
 314 #if USE(CF)
 315     // These need to be initialized before heap below.
 316     RetainPtr&lt;CFRunLoopRef&gt; m_runLoop;
 317 #endif
 318 
 319 public:
 320     Heap heap;
 321 
 322     std::unique_ptr&lt;FastMallocAlignedMemoryAllocator&gt; fastMallocAllocator;
 323     std::unique_ptr&lt;GigacageAlignedMemoryAllocator&gt; primitiveGigacageAllocator;
 324     std::unique_ptr&lt;GigacageAlignedMemoryAllocator&gt; jsValueGigacageAllocator;
 325 
 326     std::unique_ptr&lt;HeapCellType&gt; auxiliaryHeapCellType;
 327     std::unique_ptr&lt;HeapCellType&gt; immutableButterflyHeapCellType;
 328     std::unique_ptr&lt;HeapCellType&gt; cellHeapCellType;
 329     std::unique_ptr&lt;HeapCellType&gt; destructibleCellHeapCellType;
 330     std::unique_ptr&lt;JSStringHeapCellType&gt; stringHeapCellType;
 331     std::unique_ptr&lt;JSDestructibleObjectHeapCellType&gt; destructibleObjectHeapCellType;
<span class="line-removed"> 332     std::unique_ptr&lt;JSSegmentedVariableObjectHeapCellType&gt; segmentedVariableObjectHeapCellType;</span>
 333 #if ENABLE(WEBASSEMBLY)
 334     std::unique_ptr&lt;JSWebAssemblyCodeBlockHeapCellType&gt; webAssemblyCodeBlockHeapCellType;

 335 #endif
 336 
 337     CompleteSubspace primitiveGigacageAuxiliarySpace; // Typed arrays, strings, bitvectors, etc go here.
 338     CompleteSubspace jsValueGigacageAuxiliarySpace; // Butterflies, arrays of JSValues, etc go here.
 339     CompleteSubspace immutableButterflyJSValueGigacageAuxiliarySpace; // JSImmutableButterfly goes here.
 340 
 341     // We make cross-cutting assumptions about typed arrays being in the primitive Gigacage and butterflies
 342     // being in the JSValue gigacage. For some types, it&#39;s super obvious where they should go, and so we
 343     // can hardcode that fact. But sometimes it&#39;s not clear, so we abstract it by having a Gigacage::Kind
 344     // constant somewhere.
 345     // FIXME: Maybe it would be better if everyone abstracted this?
 346     // https://bugs.webkit.org/show_bug.cgi?id=175248
 347     ALWAYS_INLINE CompleteSubspace&amp; gigacageAuxiliarySpace(Gigacage::Kind kind)
 348     {
 349         switch (kind) {
 350         case Gigacage::ReservedForFlagsAndNotABasePtr:
 351             RELEASE_ASSERT_NOT_REACHED();
 352         case Gigacage::Primitive:
 353             return primitiveGigacageAuxiliarySpace;
 354         case Gigacage::JSValue:
 355             return jsValueGigacageAuxiliarySpace;
 356         }
 357         RELEASE_ASSERT_NOT_REACHED();
 358         return primitiveGigacageAuxiliarySpace;
 359     }
 360 
 361     // Whenever possible, use subspaceFor&lt;CellType&gt;(vm) to get one of these subspaces.
 362     CompleteSubspace cellSpace;
 363     CompleteSubspace jsValueGigacageCellSpace; // FIXME: This space is problematic because we have things in here like DirectArguments and ScopedArguments; those should be split into JSValueOOB cells and JSValueStrict auxiliaries. https://bugs.webkit.org/show_bug.cgi?id=182858
 364     CompleteSubspace destructibleCellSpace;
 365     CompleteSubspace stringSpace;
 366     CompleteSubspace destructibleObjectSpace;
 367     CompleteSubspace eagerlySweptDestructibleObjectSpace;
<span class="line-removed"> 368     CompleteSubspace segmentedVariableObjectSpace;</span>
 369 
 370     IsoSubspace executableToCodeBlockEdgeSpace;
 371     IsoSubspace functionSpace;
 372     IsoSubspace internalFunctionSpace;
 373     IsoSubspace nativeExecutableSpace;
 374     IsoSubspace propertyTableSpace;
 375     IsoSubspace structureRareDataSpace;
 376     IsoSubspace structureSpace;

 377 
 378 #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(name) \
 379     template&lt;SubspaceAccess mode&gt; \
 380     IsoSubspace* name() \
 381     { \
 382         if (m_##name || mode == SubspaceAccess::Concurrently) \
 383             return m_##name.get(); \
 384         return name##Slow(); \
 385     } \
 386     IsoSubspace* name##Slow(); \
 387     std::unique_ptr&lt;IsoSubspace&gt; m_##name;
 388 
 389 
 390 #if JSC_OBJC_API_ENABLED
 391     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(objCCallbackFunctionSpace)
 392 #endif
 393     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(boundFunctionSpace)
 394     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackFunctionSpace)
 395     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(customGetterSetterFunctionSpace)
 396     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(errorInstanceSpace)
 397     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(nativeStdFunctionSpace)
 398     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(proxyRevokeSpace)

 399     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakSetSpace)
 400     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakMapSpace)
 401 #if ENABLE(WEBASSEMBLY)
 402     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyCodeBlockSpace)
 403     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyFunctionSpace)
 404     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyWrapperFunctionSpace)
 405 #endif
 406 
 407 #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER
 408 
 409     IsoCellSet executableToCodeBlockEdgesWithConstraints;
 410     IsoCellSet executableToCodeBlockEdgesWithFinalizers;
 411 
 412 #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(name) \
 413     template&lt;SubspaceAccess mode&gt; \
 414     IsoSubspace* name() \
 415     { \
 416         if (auto* spaceAndSet = m_##name.get()) \
 417             return &amp;spaceAndSet-&gt;space; \
 418         if (mode == SubspaceAccess::Concurrently) \
</pre>
<hr />
<pre>
 428         IsoSubspace space;
 429         IsoCellSet set;
 430 
 431         template&lt;typename... Arguments&gt;
 432         SpaceAndSet(Arguments&amp;&amp;... arguments)
 433             : space(std::forward&lt;Arguments&gt;(arguments)...)
 434             , set(space)
 435         {
 436         }
 437 
 438         static IsoCellSet&amp; setFor(Subspace&amp; space)
 439         {
 440             return *bitwise_cast&lt;IsoCellSet*&gt;(
 441                 bitwise_cast&lt;char*&gt;(&amp;space) -
 442                 OBJECT_OFFSETOF(SpaceAndSet, space) +
 443                 OBJECT_OFFSETOF(SpaceAndSet, set));
 444         }
 445     };
 446 
 447     SpaceAndSet codeBlockSpace;
<span class="line-removed"> 448     DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(inferredValueSpace)</span>
 449 
 450     template&lt;typename Func&gt;
 451     void forEachCodeBlockSpace(const Func&amp; func)
 452     {
 453         // This should not include webAssemblyCodeBlockSpace because this is about subsclasses of
 454         // JSC::CodeBlock.
 455         func(codeBlockSpace);
 456     }
 457 
 458     DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(evalExecutableSpace)
 459     DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(moduleProgramExecutableSpace)
 460     SpaceAndSet functionExecutableSpace;
 461     SpaceAndSet programExecutableSpace;
 462 
 463     template&lt;typename Func&gt;
 464     void forEachScriptExecutableSpace(const Func&amp; func)
 465     {
 466         if (m_evalExecutableSpace)
 467             func(*m_evalExecutableSpace);
 468         func(functionExecutableSpace);
</pre>
<hr />
<pre>
 504 #endif
 505     Strong&lt;Structure&gt; moduleProgramExecutableStructure;
 506     Strong&lt;Structure&gt; regExpStructure;
 507     Strong&lt;Structure&gt; symbolStructure;
 508     Strong&lt;Structure&gt; symbolTableStructure;
 509     Strong&lt;Structure&gt; fixedArrayStructure;
 510     Strong&lt;Structure&gt; immutableButterflyStructures[NumberOfCopyOnWriteIndexingModes];
 511     Strong&lt;Structure&gt; sourceCodeStructure;
 512     Strong&lt;Structure&gt; scriptFetcherStructure;
 513     Strong&lt;Structure&gt; scriptFetchParametersStructure;
 514     Strong&lt;Structure&gt; structureChainStructure;
 515     Strong&lt;Structure&gt; sparseArrayValueMapStructure;
 516     Strong&lt;Structure&gt; templateObjectDescriptorStructure;
 517     Strong&lt;Structure&gt; arrayBufferNeuteringWatchpointStructure;
 518     Strong&lt;Structure&gt; unlinkedFunctionExecutableStructure;
 519     Strong&lt;Structure&gt; unlinkedProgramCodeBlockStructure;
 520     Strong&lt;Structure&gt; unlinkedEvalCodeBlockStructure;
 521     Strong&lt;Structure&gt; unlinkedFunctionCodeBlockStructure;
 522     Strong&lt;Structure&gt; unlinkedModuleProgramCodeBlockStructure;
 523     Strong&lt;Structure&gt; propertyTableStructure;
<span class="line-removed"> 524     Strong&lt;Structure&gt; inferredValueStructure;</span>
 525     Strong&lt;Structure&gt; functionRareDataStructure;
 526     Strong&lt;Structure&gt; exceptionStructure;
 527     Strong&lt;Structure&gt; promiseDeferredStructure;
 528     Strong&lt;Structure&gt; internalPromiseDeferredStructure;
 529     Strong&lt;Structure&gt; nativeStdFunctionCellStructure;
 530     Strong&lt;Structure&gt; programCodeBlockStructure;
 531     Strong&lt;Structure&gt; moduleProgramCodeBlockStructure;
 532     Strong&lt;Structure&gt; evalCodeBlockStructure;
 533     Strong&lt;Structure&gt; functionCodeBlockStructure;
 534     Strong&lt;Structure&gt; hashMapBucketSetStructure;
 535     Strong&lt;Structure&gt; hashMapBucketMapStructure;
<span class="line-removed"> 536     Strong&lt;Structure&gt; setIteratorStructure;</span>
<span class="line-removed"> 537     Strong&lt;Structure&gt; mapIteratorStructure;</span>
 538     Strong&lt;Structure&gt; bigIntStructure;
 539     Strong&lt;Structure&gt; executableToCodeBlockEdgeStructure;
 540 
<span class="line-modified"> 541     Strong&lt;JSCell&gt; emptyPropertyNameEnumerator;</span>



 542 
 543     Strong&lt;JSCell&gt; m_sentinelSetBucket;
 544     Strong&lt;JSCell&gt; m_sentinelMapBucket;
 545 
<span class="line-modified"> 546     std::unique_ptr&lt;PromiseDeferredTimer&gt; promiseDeferredTimer;</span>
 547 
 548     JSCell* currentlyDestructingCallbackObject;
 549     const ClassInfo* currentlyDestructingCallbackObjectClassInfo { nullptr };
 550 
<span class="line-modified"> 551     AtomicStringTable* m_atomicStringTable;</span>
 552     WTF::SymbolRegistry m_symbolRegistry;
 553     CommonIdentifiers* propertyNames;
 554     const ArgList* emptyList;
 555     SmallStrings smallStrings;
 556     NumericStrings numericStrings;
 557     DateInstanceCache dateInstanceCache;
 558     std::unique_ptr&lt;SimpleStats&gt; machineCodeBytesPerBytecodeWordForBaselineJIT;
 559     WeakGCMap&lt;std::pair&lt;CustomGetterSetter*, int&gt;, JSCustomGetterSetterFunction&gt; customGetterSetterFunctionMap;
 560     WeakGCMap&lt;StringImpl*, JSString, PtrHash&lt;StringImpl*&gt;&gt; stringCache;
 561     Strong&lt;JSString&gt; lastCachedString;
 562 
<span class="line-modified"> 563     AtomicStringTable* atomicStringTable() const { return m_atomicStringTable; }</span>
 564     WTF::SymbolRegistry&amp; symbolRegistry() { return m_symbolRegistry; }
 565 














 566     JSCell* sentinelSetBucket()
 567     {
 568         if (LIKELY(m_sentinelSetBucket))
 569             return m_sentinelSetBucket.get();
 570         return sentinelSetBucketSlow();
 571     }
 572 
 573     JSCell* sentinelMapBucket()
 574     {
 575         if (LIKELY(m_sentinelMapBucket))
 576             return m_sentinelMapBucket.get();
 577         return sentinelMapBucketSlow();
 578     }
 579 







 580     WeakGCMap&lt;SymbolImpl*, Symbol, PtrHash&lt;SymbolImpl*&gt;&gt; symbolImplToSymbolMap;
 581 
 582     enum class DeletePropertyMode {
 583         // Default behaviour of deleteProperty, matching the spec.
 584         Default,
 585         // This setting causes deleteProperty to force deletion of all
 586         // properties including those that are non-configurable (DontDelete).
 587         IgnoreConfigurable
 588     };
 589 
 590     DeletePropertyMode deletePropertyMode()
 591     {
 592         return m_deletePropertyMode;
 593     }
 594 
 595     class DeletePropertyModeScope {
 596     public:
 597         DeletePropertyModeScope(VM&amp; vm, DeletePropertyMode mode)
 598             : m_vm(vm)
 599             , m_previousMode(vm.m_deletePropertyMode)
 600         {
 601             m_vm.m_deletePropertyMode = mode;
 602         }
 603 
 604         ~DeletePropertyModeScope()
 605         {
 606             m_vm.m_deletePropertyMode = m_previousMode;
 607         }
 608 
 609     private:
 610         VM&amp; m_vm;
 611         DeletePropertyMode m_previousMode;
 612     };
 613 
 614     static JS_EXPORT_PRIVATE bool canUseAssembler();
<span class="line-modified"> 615     static JS_EXPORT_PRIVATE bool canUseRegExpJIT();</span>
<span class="line-modified"> 616     static JS_EXPORT_PRIVATE bool isInMiniMode();</span>







 617 
 618     static void computeCanUseJIT();
 619     ALWAYS_INLINE static bool canUseJIT()
 620     {
 621 #if ENABLE(JIT)
 622 #if !ASSERT_DISABLED
 623         RELEASE_ASSERT(s_canUseJITIsSet);
 624 #endif
 625         return s_canUseJIT;
 626 #else
 627         return false;
 628 #endif
 629     }
 630 
 631     SourceProviderCache* addSourceProviderCache(SourceProvider*);
 632     void clearSourceProviderCaches();
 633 
 634     StructureCache structureCache;
 635 
 636     typedef HashMap&lt;RefPtr&lt;SourceProvider&gt;, RefPtr&lt;SourceProviderCache&gt;&gt; SourceProviderCacheMap;
 637     SourceProviderCacheMap sourceProviderCacheMap;
 638     Interpreter* interpreter;
 639 #if ENABLE(JIT)
 640     std::unique_ptr&lt;JITThunks&gt; jitStubs;
 641     MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; getCTIStub(ThunkGenerator generator)
 642     {
<span class="line-modified"> 643         return jitStubs-&gt;ctiStub(this, generator);</span>
 644     }
 645 
 646 #endif // ENABLE(JIT)
 647 #if ENABLE(FTL_JIT)
 648     std::unique_ptr&lt;FTL::Thunks&gt; ftlThunks;
 649 #endif
 650     NativeExecutable* getHostFunction(NativeFunction, NativeFunction constructor, const String&amp; name);
 651     NativeExecutable* getHostFunction(NativeFunction, Intrinsic, NativeFunction constructor, const DOMJIT::Signature*, const String&amp; name);
 652 
 653     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; getCTIInternalFunctionTrampolineFor(CodeSpecializationKind);
 654 
 655     static ptrdiff_t exceptionOffset()
 656     {
 657         return OBJECT_OFFSETOF(VM, m_exception);
 658     }
 659 
 660     static ptrdiff_t callFrameForCatchOffset()
 661     {
 662         return OBJECT_OFFSETOF(VM, callFrameForCatch);
 663     }
 664 
 665     static ptrdiff_t topEntryFrameOffset()
 666     {
 667         return OBJECT_OFFSETOF(VM, topEntryFrame);
 668     }
 669 










 670     void restorePreviousException(Exception* exception) { setException(exception); }
 671 
 672     void clearLastException() { m_lastException = nullptr; }
 673 
 674     ExecState** addressOfCallFrameForCatch() { return &amp;callFrameForCatch; }
 675 
 676     JSCell** addressOfException() { return reinterpret_cast&lt;JSCell**&gt;(&amp;m_exception); }
 677 
 678     Exception* lastException() const { return m_lastException; }
 679     JSCell** addressOfLastException() { return reinterpret_cast&lt;JSCell**&gt;(&amp;m_lastException); }
 680 
 681     // This should only be used for test or assertion code that wants to inspect
 682     // the pending exception without interfering with Throw/CatchScopes.
 683     Exception* exceptionForInspection() const { return m_exception; }
 684 
 685     void setFailNextNewCodeBlock() { m_failNextNewCodeBlock = true; }
 686     bool getAndClearFailNextNewCodeBlock()
 687     {
 688         bool result = m_failNextNewCodeBlock;
 689         m_failNextNewCodeBlock = false;
</pre>
<hr />
<pre>
 693     ALWAYS_INLINE Structure* getStructure(StructureID id)
 694     {
 695         return heap.structureIDTable().get(decontaminate(id));
 696     }
 697 
 698     void* stackPointerAtVMEntry() const { return m_stackPointerAtVMEntry; }
 699     void setStackPointerAtVMEntry(void*);
 700 
 701     size_t softReservedZoneSize() const { return m_currentSoftReservedZoneSize; }
 702     size_t updateSoftReservedZoneSize(size_t softReservedZoneSize);
 703 
 704     static size_t committedStackByteCount();
 705     inline bool ensureStackCapacityFor(Register* newTopOfStack);
 706 
 707     void* stackLimit() { return m_stackLimit; }
 708     void* softStackLimit() { return m_softStackLimit; }
 709     void** addressOfSoftStackLimit() { return &amp;m_softStackLimit; }
 710 #if ENABLE(C_LOOP)
 711     void* cloopStackLimit() { return m_cloopStackLimit; }
 712     void setCLoopStackLimit(void* limit) { m_cloopStackLimit = limit; }

 713 #endif
 714 
 715     inline bool isSafeToRecurseSoft() const;
 716     bool isSafeToRecurse() const
 717     {
 718         return isSafeToRecurse(m_stackLimit);
 719     }
 720 
 721     void** addressOfLastStackTop() { return &amp;m_lastStackTop; }
 722     void* lastStackTop() { return m_lastStackTop; }
 723     void setLastStackTop(void*);
 724 
 725     void firePrimitiveGigacageEnabledIfNecessary()
 726     {
 727         if (m_needToFirePrimitiveGigacageEnabled) {
 728             m_needToFirePrimitiveGigacageEnabled = false;
 729             m_primitiveGigacageEnabled.fireAll(*this, &quot;Primitive gigacage disabled asynchronously&quot;);
 730         }
 731     }
 732 
</pre>
<hr />
<pre>
 745     // - You can only set the ScratchBuffer&#39;s activeLength from the main thread.
 746     // - You can only write to entries in the ScratchBuffer from the main thread.
 747     ScratchBuffer* scratchBufferForSize(size_t size);
 748     void clearScratchBuffers();
 749 
 750     EncodedJSValue* exceptionFuzzingBuffer(size_t size)
 751     {
 752         ASSERT(Options::useExceptionFuzz());
 753         if (!m_exceptionFuzzBuffer)
 754             m_exceptionFuzzBuffer = MallocPtr&lt;EncodedJSValue&gt;::malloc(size);
 755         return m_exceptionFuzzBuffer.get();
 756     }
 757 
 758     void gatherScratchBufferRoots(ConservativeRoots&amp;);
 759 
 760     VMEntryScope* entryScope;
 761 
 762     JSObject* stringRecursionCheckFirstObject { nullptr };
 763     HashSet&lt;JSObject*&gt; stringRecursionCheckVisitedObjects;
 764 

 765     LocalTimeOffsetCache localTimeOffsetCache;
 766 
 767     String cachedDateString;
 768     double cachedDateStringValue;
 769 
 770     std::unique_ptr&lt;Profiler::Database&gt; m_perBytecodeProfiler;
 771     RefPtr&lt;TypedArrayController&gt; m_typedArrayController;
 772     RegExpCache* m_regExpCache;
 773     BumpPointerAllocator m_regExpAllocator;
 774     ConcurrentJSLock m_regExpAllocatorLock;
 775 
 776 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 777     static constexpr size_t patternContextBufferSize = 8192; // Space allocated to save nested parenthesis context
 778     UniqueArray&lt;char&gt; m_regExpPatternContexBuffer;
 779     Lock m_regExpPatternContextLock;
 780     char* acquireRegExpPatternContexBuffer();
 781     void releaseRegExpPatternContexBuffer();


 782 #endif
 783 
 784     Ref&lt;CompactVariableMap&gt; m_compactVariableMap;
 785 
 786     std::unique_ptr&lt;HasOwnPropertyCache&gt; m_hasOwnPropertyCache;
 787     ALWAYS_INLINE HasOwnPropertyCache* hasOwnPropertyCache() { return m_hasOwnPropertyCache.get(); }
 788     HasOwnPropertyCache* ensureHasOwnPropertyCache();
 789 
 790 #if ENABLE(REGEXP_TRACING)
 791     typedef ListHashSet&lt;RegExp*&gt; RTTraceList;
 792     RTTraceList* m_rtTraceList;
 793 #endif
 794 
<span class="line-removed"> 795     std::unique_ptr&lt;ValueProfile&gt; noJITValueProfileSingleton;</span>
<span class="line-removed"> 796 </span>
 797     JS_EXPORT_PRIVATE void resetDateCache();
 798 
 799     RegExpCache* regExpCache() { return m_regExpCache; }
 800 #if ENABLE(REGEXP_TRACING)
 801     void addRegExpToTrace(RegExp*);
 802 #endif
 803     JS_EXPORT_PRIVATE void dumpRegExpTrace();
 804 
 805     bool isCollectorBusyOnCurrentThread() { return heap.isCurrentThreadBusy(); }
 806 
 807 #if ENABLE(GC_VALIDATION)
 808     bool isInitializingObject() const;
 809     void setInitializingObjectClass(const ClassInfo*);
 810 #endif
 811 
 812     bool currentThreadIsHoldingAPILock() const { return m_apiLock-&gt;currentThreadIsHoldingLock(); }
 813 
 814     JSLock&amp; apiLock() { return *m_apiLock; }
 815     CodeCache* codeCache() { return m_codeCache.get(); }
 816 
 817     JS_EXPORT_PRIVATE void whenIdle(Function&lt;void()&gt;&amp;&amp;);
 818 
 819     JS_EXPORT_PRIVATE void deleteAllCode(DeleteAllCodeEffort);
 820     JS_EXPORT_PRIVATE void deleteAllLinkedCode(DeleteAllCodeEffort);
 821 
 822     void shrinkFootprintWhenIdle();
 823 
 824     WatchpointSet* ensureWatchpointSetForImpureProperty(const Identifier&amp;);
 825     void registerWatchpointForImpureProperty(const Identifier&amp;, Watchpoint*);
 826 
<span class="line-modified"> 827     // FIXME: Use AtomicString once it got merged with Identifier.</span>
 828     JS_EXPORT_PRIVATE void addImpureProperty(const String&amp;);
 829 
 830     InlineWatchpointSet&amp; primitiveGigacageEnabled() { return m_primitiveGigacageEnabled; }
 831 
 832     BuiltinExecutables* builtinExecutables() { return m_builtinExecutables.get(); }
 833 
 834     bool enableTypeProfiler();
 835     bool disableTypeProfiler();
 836     TypeProfilerLog* typeProfilerLog() { return m_typeProfilerLog.get(); }
 837     TypeProfiler* typeProfiler() { return m_typeProfiler.get(); }
 838     JS_EXPORT_PRIVATE void dumpTypeProfilerData();
 839 
 840     FunctionHasExecutedCache* functionHasExecutedCache() { return &amp;m_functionHasExecutedCache; }
 841 
 842     ControlFlowProfiler* controlFlowProfiler() { return m_controlFlowProfiler.get(); }
 843     bool enableControlFlowProfiler();
 844     bool disableControlFlowProfiler();
 845 
 846     void queueMicrotask(JSGlobalObject&amp;, Ref&lt;Microtask&gt;&amp;&amp;);
 847     JS_EXPORT_PRIVATE void drainMicrotasks();
<span class="line-modified"> 848     ALWAYS_INLINE void setOnEachMicrotaskTick(WTF::Function&lt;void(VM&amp;)&gt;&amp;&amp; func) { m_onEachMicrotaskTick = WTFMove(func); }</span>



 849     void setGlobalConstRedeclarationShouldThrow(bool globalConstRedeclarationThrow) { m_globalConstRedeclarationShouldThrow = globalConstRedeclarationThrow; }
 850     ALWAYS_INLINE bool globalConstRedeclarationShouldThrow() const { return m_globalConstRedeclarationShouldThrow; }
 851 
 852     void setShouldBuildPCToCodeOriginMapping() { m_shouldBuildPCToCodeOriginMapping = true; }
 853     bool shouldBuilderPCToCodeOriginMapping() const { return m_shouldBuildPCToCodeOriginMapping; }
 854 
 855     BytecodeIntrinsicRegistry&amp; bytecodeIntrinsicRegistry() { return *m_bytecodeIntrinsicRegistry; }
 856 
 857     ShadowChicken* shadowChicken() { return m_shadowChicken.get(); }
 858     void ensureShadowChicken();
 859 
 860     template&lt;typename Func&gt;
 861     void logEvent(CodeBlock*, const char* summary, const Func&amp; func);
 862 
 863     Optional&lt;RefPtr&lt;Thread&gt;&gt; ownerThread() const { return m_apiLock-&gt;ownerThread(); }
 864 
 865     VMTraps&amp; traps() { return m_traps; }
 866 
 867     void handleTraps(ExecState* exec, VMTraps::Mask mask = VMTraps::Mask::allEventTypes()) { m_traps.handleTraps(exec, mask); }
 868 
 869     bool needTrapHandling() { return m_traps.needTrapHandling(); }
 870     bool needTrapHandling(VMTraps::Mask mask) { return m_traps.needTrapHandling(mask); }
 871     void* needTrapHandlingAddress() { return m_traps.needTrapHandlingAddress(); }
 872 
 873     void notifyNeedDebuggerBreak() { m_traps.fireTrap(VMTraps::NeedDebuggerBreak); }
 874     void notifyNeedTermination() { m_traps.fireTrap(VMTraps::NeedTermination); }
 875     void notifyNeedWatchdogCheck() { m_traps.fireTrap(VMTraps::NeedWatchdogCheck); }
 876 


 877 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 878     StackTrace* nativeStackTraceOfLastThrow() const { return m_nativeStackTraceOfLastThrow.get(); }
 879     Thread* throwingThread() const { return m_throwingThread.get(); }
 880     bool needExceptionCheck() const { return m_needExceptionCheck; }
 881 #endif
 882 
 883 #if USE(CF)
 884     CFRunLoopRef runLoop() const { return m_runLoop.get(); }
 885     JS_EXPORT_PRIVATE void setRunLoop(CFRunLoopRef);
 886 #endif // USE(CF)
 887 


 888     class DeferExceptionScope {
 889     public:
 890         DeferExceptionScope(VM&amp; vm)
 891             : m_savedException(vm.m_exception, nullptr)
 892             , m_savedLastException(vm.m_lastException, nullptr)
 893         {
 894         }
 895 
 896     private:
 897         SetForScope&lt;Exception*&gt; m_savedException;
 898         SetForScope&lt;Exception*&gt; m_savedLastException;
 899     };
 900 
 901 private:
 902     friend class LLIntOffsetsExtractor;
 903 
 904     VM(VMType, HeapType);
 905     static VM*&amp; sharedInstanceInternal();
 906     void createNativeThunk();
 907 


 908     JSCell* sentinelSetBucketSlow();
 909     JSCell* sentinelMapBucketSlow();

 910 
 911     void updateStackLimits();
 912 
 913     bool isSafeToRecurse(void* stackLimit) const
 914     {
 915         ASSERT(Thread::current().stack().isGrowingDownward());
 916         void* curr = currentStackPointer();
 917         return curr &gt;= stackLimit;
 918     }
 919 
 920     void setException(Exception* exception)
 921     {
 922         m_exception = exception;
 923         m_lastException = exception;
 924     }
 925     Exception* exception() const
 926     {
 927 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 928         m_needExceptionCheck = false;
 929 #endif
 930         return m_exception;
 931     }
 932     void clearException()
 933     {
 934 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 935         m_needExceptionCheck = false;
 936         m_nativeStackTraceOfLastThrow = nullptr;
 937         m_throwingThread = nullptr;
 938 #endif
 939         m_exception = nullptr;
 940     }
 941 
 942 #if ENABLE(C_LOOP)
 943     bool ensureStackCapacityForCLoop(Register* newTopOfStack);
 944     bool isSafeToRecurseSoftCLoop() const;
 945 #endif // ENABLE(C_LOOP)
 946 
<span class="line-modified"> 947     JS_EXPORT_PRIVATE void throwException(ExecState*, Exception*);</span>
<span class="line-modified"> 948     JS_EXPORT_PRIVATE JSValue throwException(ExecState*, JSValue);</span>
<span class="line-modified"> 949     JS_EXPORT_PRIVATE JSObject* throwException(ExecState*, JSObject*);</span>
 950 
 951 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 952     void verifyExceptionCheckNeedIsSatisfied(unsigned depth, ExceptionEventLocation&amp;);
 953 #endif
 954 
 955     static void primitiveGigacageDisabledCallback(void*);
 956     void primitiveGigacageDisabled();
 957 



 958 #if ENABLE(GC_VALIDATION)
 959     const ClassInfo* m_initializingObjectClass;
 960 #endif
 961 
 962     void* m_stackPointerAtVMEntry;
 963     size_t m_currentSoftReservedZoneSize;
 964     void* m_stackLimit { nullptr };
 965     void* m_softStackLimit { nullptr };
 966 #if ENABLE(C_LOOP)
 967     void* m_cloopStackLimit { nullptr };
 968 #endif
 969     void* m_lastStackTop { nullptr };
 970 
 971     Exception* m_exception { nullptr };
 972     Exception* m_lastException { nullptr };
 973 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 974     ExceptionScope* m_topExceptionScope { nullptr };
 975     ExceptionEventLocation m_simulatedThrowPointLocation;
 976     unsigned m_simulatedThrowPointRecursionDepth { 0 };
 977     mutable bool m_needExceptionCheck { false };
</pre>
<hr />
<pre>
 989     HashMap&lt;String, RefPtr&lt;WatchpointSet&gt;&gt; m_impurePropertyWatchpointSets;
 990     std::unique_ptr&lt;TypeProfiler&gt; m_typeProfiler;
 991     std::unique_ptr&lt;TypeProfilerLog&gt; m_typeProfilerLog;
 992     unsigned m_typeProfilerEnabledCount;
 993     bool m_needToFirePrimitiveGigacageEnabled { false };
 994     Lock m_scratchBufferLock;
 995     Vector&lt;ScratchBuffer*&gt; m_scratchBuffers;
 996     size_t m_sizeOfLastScratchBuffer { 0 };
 997     InlineWatchpointSet m_primitiveGigacageEnabled;
 998     FunctionHasExecutedCache m_functionHasExecutedCache;
 999     std::unique_ptr&lt;ControlFlowProfiler&gt; m_controlFlowProfiler;
1000     unsigned m_controlFlowProfilerEnabledCount;
1001     Deque&lt;std::unique_ptr&lt;QueuedTask&gt;&gt; m_microtaskQueue;
1002     MallocPtr&lt;EncodedJSValue&gt; m_exceptionFuzzBuffer;
1003     VMTraps m_traps;
1004     RefPtr&lt;Watchdog&gt; m_watchdog;
1005     std::unique_ptr&lt;HeapProfiler&gt; m_heapProfiler;
1006 #if ENABLE(SAMPLING_PROFILER)
1007     RefPtr&lt;SamplingProfiler&gt; m_samplingProfiler;
1008 #endif

1009     std::unique_ptr&lt;ShadowChicken&gt; m_shadowChicken;
1010     std::unique_ptr&lt;BytecodeIntrinsicRegistry&gt; m_bytecodeIntrinsicRegistry;
1011 



1012     WTF::Function&lt;void(VM&amp;)&gt; m_onEachMicrotaskTick;

1013 
1014 #if ENABLE(JIT)
1015 #if !ASSERT_DISABLED
1016     JS_EXPORT_PRIVATE static bool s_canUseJITIsSet;
1017 #endif
1018     JS_EXPORT_PRIVATE static bool s_canUseJIT;
1019 #endif
1020 
1021     VM* m_prev; // Required by DoublyLinkedListNode.
1022     VM* m_next; // Required by DoublyLinkedListNode.
1023 
1024     // Friends for exception checking purpose only.
1025     friend class Heap;
1026     friend class CatchScope;
1027     friend class ExceptionScope;
1028     friend class ThrowScope;
1029     friend class VMTraps;
1030     friend class WTF::DoublyLinkedListNode&lt;VM&gt;;
1031 };
1032 
1033 #if ENABLE(GC_VALIDATION)
1034 inline bool VM::isInitializingObject() const
1035 {
1036     return !!m_initializingObjectClass;
1037 }
1038 
1039 inline void VM::setInitializingObjectClass(const ClassInfo* initializingObjectClass)
1040 {
1041     m_initializingObjectClass = initializingObjectClass;
1042 }
1043 #endif
1044 
1045 inline Heap* WeakSet::heap() const
1046 {
<span class="line-modified">1047     return &amp;m_vm-&gt;heap;</span>
1048 }
1049 
1050 #if !ENABLE(C_LOOP)
1051 extern &quot;C&quot; void sanitizeStackForVMImpl(VM*);
1052 #endif
1053 
<span class="line-modified">1054 JS_EXPORT_PRIVATE void sanitizeStackForVM(VM*);</span>
<span class="line-modified">1055 void logSanitizeStack(VM*);</span>
1056 
1057 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #pragma once
  30 
  31 #include &quot;CallData.h&quot;
  32 #include &quot;CodeSpecializationKind.h&quot;
  33 #include &quot;CompleteSubspace.h&quot;
  34 #include &quot;ConcurrentJSLock.h&quot;
  35 #include &quot;ControlFlowProfiler.h&quot;
  36 #include &quot;DateInstanceCache.h&quot;
  37 #include &quot;DeleteAllCodeEffort.h&quot;
  38 #include &quot;ExceptionEventLocation.h&quot;
  39 #include &quot;ExecutableAllocator.h&quot;
  40 #include &quot;FunctionHasExecutedCache.h&quot;
<span class="line-added">  41 #include &quot;FuzzerAgent.h&quot;</span>
  42 #include &quot;Heap.h&quot;
  43 #include &quot;Intrinsic.h&quot;
  44 #include &quot;IsoCellSet.h&quot;
  45 #include &quot;IsoSubspace.h&quot;
  46 #include &quot;JITThunks.h&quot;
  47 #include &quot;JSCJSValue.h&quot;
  48 #include &quot;JSLock.h&quot;
  49 #include &quot;MacroAssemblerCodeRef.h&quot;
  50 #include &quot;Microtask.h&quot;
  51 #include &quot;NumericStrings.h&quot;
  52 #include &quot;SmallStrings.h&quot;
  53 #include &quot;Strong.h&quot;
  54 #include &quot;StructureCache.h&quot;
  55 #include &quot;SubspaceAccess.h&quot;
  56 #include &quot;VMTraps.h&quot;
  57 #include &quot;WasmContext.h&quot;
  58 #include &quot;Watchpoint.h&quot;
  59 #include &lt;wtf/BumpPointerAllocator.h&gt;
  60 #include &lt;wtf/CheckedArithmetic.h&gt;
  61 #include &lt;wtf/DateMath.h&gt;
</pre>
<hr />
<pre>
 106 class CommonIdentifiers;
 107 class CompactVariableMap;
 108 class CustomGetterSetter;
 109 class DOMAttributeGetterSetter;
 110 class ExecState;
 111 class Exception;
 112 class ExceptionScope;
 113 class FastMallocAlignedMemoryAllocator;
 114 class GigacageAlignedMemoryAllocator;
 115 class HandleStack;
 116 class TypeProfiler;
 117 class TypeProfilerLog;
 118 class HasOwnPropertyCache;
 119 class HeapProfiler;
 120 class Identifier;
 121 class Interpreter;
 122 class JSCustomGetterSetterFunction;
 123 class JSDestructibleObjectHeapCellType;
 124 class JSGlobalObject;
 125 class JSObject;
<span class="line-added"> 126 class JSPromise;</span>
<span class="line-added"> 127 class JSPropertyNameEnumerator;</span>
 128 class JSRunLoopTimer;

 129 class JSStringHeapCellType;
 130 class JSWebAssemblyCodeBlockHeapCellType;
 131 class JSWebAssemblyInstance;
 132 class LLIntOffsetsExtractor;
 133 class NativeExecutable;
 134 class PromiseDeferredTimer;
 135 class RegExp;
 136 class RegExpCache;
 137 class Register;
 138 class RegisterAtOffsetList;
 139 #if ENABLE(SAMPLING_PROFILER)
 140 class SamplingProfiler;
 141 #endif
 142 class ShadowChicken;
 143 class ScriptExecutable;
 144 class SourceProvider;
 145 class SourceProviderCache;
 146 class StackFrame;
 147 class Structure;
 148 #if ENABLE(REGEXP_TRACING)
 149 class RegExp;
 150 #endif
 151 class Symbol;
 152 class TypedArrayController;
 153 class UnlinkedCodeBlock;
 154 class UnlinkedEvalCodeBlock;
 155 class UnlinkedFunctionExecutable;
 156 class UnlinkedProgramCodeBlock;
 157 class UnlinkedModuleProgramCodeBlock;
 158 class VirtualRegister;
 159 class VMEntryScope;
 160 class Watchdog;
 161 class Watchpoint;
 162 class WatchpointSet;
<span class="line-added"> 163 class WebAssemblyFunctionHeapCellType;</span>
 164 
 165 #if ENABLE(FTL_JIT)
 166 namespace FTL {
 167 class Thunks;
 168 }
 169 #endif // ENABLE(FTL_JIT)
 170 namespace Profiler {
 171 class Database;
 172 }
 173 namespace DOMJIT {
 174 class Signature;
 175 }
 176 
 177 struct EntryFrame;
 178 struct HashTable;
 179 struct Instruction;
 180 struct ValueProfile;
 181 
 182 typedef ExecState CallFrame;
 183 
 184 struct LocalTimeOffsetCache {
 185     LocalTimeOffsetCache()
 186         : start(0.0)
 187         , end(-1.0)
 188         , increment(0.0)

 189     {
 190     }
 191 
 192     void reset()
 193     {
 194         offset = LocalTimeOffset();
 195         start = 0.0;
 196         end = -1.0;
 197         increment = 0.0;

 198     }
 199 
 200     LocalTimeOffset offset;
 201     double start;
 202     double end;
 203     double increment;

 204 };
 205 
 206 class QueuedTask {
 207     WTF_MAKE_NONCOPYABLE(QueuedTask);
 208     WTF_MAKE_FAST_ALLOCATED;
 209 public:
 210     void run();
 211 
 212     QueuedTask(VM&amp; vm, JSGlobalObject* globalObject, Ref&lt;Microtask&gt;&amp;&amp; microtask)
 213         : m_globalObject(vm, globalObject)
 214         , m_microtask(WTFMove(microtask))
 215     {
 216     }
 217 
 218 private:
 219     Strong&lt;JSGlobalObject&gt; m_globalObject;
 220     Ref&lt;Microtask&gt; m_microtask;
 221 };
 222 
 223 class ConservativeRoots;
</pre>
<hr />
<pre>
 278     bool isSharedInstance() { return vmType == APIShared; }
 279     bool usingAPI() { return vmType != Default; }
 280     JS_EXPORT_PRIVATE static bool sharedInstanceExists();
 281     JS_EXPORT_PRIVATE static VM&amp; sharedInstance();
 282 
 283     JS_EXPORT_PRIVATE static Ref&lt;VM&gt; create(HeapType = SmallHeap);
 284     static Ref&lt;VM&gt; createContextGroup(HeapType = SmallHeap);
 285     JS_EXPORT_PRIVATE ~VM();
 286 
 287     Watchdog&amp; ensureWatchdog();
 288     Watchdog* watchdog() { return m_watchdog.get(); }
 289 
 290     HeapProfiler* heapProfiler() const { return m_heapProfiler.get(); }
 291     JS_EXPORT_PRIVATE HeapProfiler&amp; ensureHeapProfiler();
 292 
 293 #if ENABLE(SAMPLING_PROFILER)
 294     SamplingProfiler* samplingProfiler() { return m_samplingProfiler.get(); }
 295     JS_EXPORT_PRIVATE SamplingProfiler&amp; ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp;);
 296 #endif
 297 
<span class="line-added"> 298     FuzzerAgent* fuzzerAgent() const { return m_fuzzerAgent.get(); }</span>
<span class="line-added"> 299     void setFuzzerAgent(std::unique_ptr&lt;FuzzerAgent&gt;&amp;&amp; fuzzerAgent)</span>
<span class="line-added"> 300     {</span>
<span class="line-added"> 301         m_fuzzerAgent = WTFMove(fuzzerAgent);</span>
<span class="line-added"> 302     }</span>
<span class="line-added"> 303 </span>
 304     static unsigned numberOfIDs() { return s_numberOfIDs.load(); }
 305     unsigned id() const { return m_id; }
 306     bool isEntered() const { return !!entryScope; }
 307 
 308     inline CallFrame* topJSCallFrame() const;
 309 
 310     // Global object in which execution began.
 311     JS_EXPORT_PRIVATE JSGlobalObject* vmEntryGlobalObject(const CallFrame*) const;
 312 
 313 private:
 314     unsigned nextID();
 315 
 316     static Atomic&lt;unsigned&gt; s_numberOfIDs;
 317 
 318     unsigned m_id;
 319     RefPtr&lt;JSLock&gt; m_apiLock;
 320 #if USE(CF)
 321     // These need to be initialized before heap below.
 322     RetainPtr&lt;CFRunLoopRef&gt; m_runLoop;
 323 #endif
 324 
 325 public:
 326     Heap heap;
 327 
 328     std::unique_ptr&lt;FastMallocAlignedMemoryAllocator&gt; fastMallocAllocator;
 329     std::unique_ptr&lt;GigacageAlignedMemoryAllocator&gt; primitiveGigacageAllocator;
 330     std::unique_ptr&lt;GigacageAlignedMemoryAllocator&gt; jsValueGigacageAllocator;
 331 
 332     std::unique_ptr&lt;HeapCellType&gt; auxiliaryHeapCellType;
 333     std::unique_ptr&lt;HeapCellType&gt; immutableButterflyHeapCellType;
 334     std::unique_ptr&lt;HeapCellType&gt; cellHeapCellType;
 335     std::unique_ptr&lt;HeapCellType&gt; destructibleCellHeapCellType;
 336     std::unique_ptr&lt;JSStringHeapCellType&gt; stringHeapCellType;
 337     std::unique_ptr&lt;JSDestructibleObjectHeapCellType&gt; destructibleObjectHeapCellType;

 338 #if ENABLE(WEBASSEMBLY)
 339     std::unique_ptr&lt;JSWebAssemblyCodeBlockHeapCellType&gt; webAssemblyCodeBlockHeapCellType;
<span class="line-added"> 340     std::unique_ptr&lt;WebAssemblyFunctionHeapCellType&gt; webAssemblyFunctionHeapCellType;</span>
 341 #endif
 342 
 343     CompleteSubspace primitiveGigacageAuxiliarySpace; // Typed arrays, strings, bitvectors, etc go here.
 344     CompleteSubspace jsValueGigacageAuxiliarySpace; // Butterflies, arrays of JSValues, etc go here.
 345     CompleteSubspace immutableButterflyJSValueGigacageAuxiliarySpace; // JSImmutableButterfly goes here.
 346 
 347     // We make cross-cutting assumptions about typed arrays being in the primitive Gigacage and butterflies
 348     // being in the JSValue gigacage. For some types, it&#39;s super obvious where they should go, and so we
 349     // can hardcode that fact. But sometimes it&#39;s not clear, so we abstract it by having a Gigacage::Kind
 350     // constant somewhere.
 351     // FIXME: Maybe it would be better if everyone abstracted this?
 352     // https://bugs.webkit.org/show_bug.cgi?id=175248
 353     ALWAYS_INLINE CompleteSubspace&amp; gigacageAuxiliarySpace(Gigacage::Kind kind)
 354     {
 355         switch (kind) {
 356         case Gigacage::ReservedForFlagsAndNotABasePtr:
 357             RELEASE_ASSERT_NOT_REACHED();
 358         case Gigacage::Primitive:
 359             return primitiveGigacageAuxiliarySpace;
 360         case Gigacage::JSValue:
 361             return jsValueGigacageAuxiliarySpace;
 362         }
 363         RELEASE_ASSERT_NOT_REACHED();
 364         return primitiveGigacageAuxiliarySpace;
 365     }
 366 
 367     // Whenever possible, use subspaceFor&lt;CellType&gt;(vm) to get one of these subspaces.
 368     CompleteSubspace cellSpace;
 369     CompleteSubspace jsValueGigacageCellSpace; // FIXME: This space is problematic because we have things in here like DirectArguments and ScopedArguments; those should be split into JSValueOOB cells and JSValueStrict auxiliaries. https://bugs.webkit.org/show_bug.cgi?id=182858
 370     CompleteSubspace destructibleCellSpace;
 371     CompleteSubspace stringSpace;
 372     CompleteSubspace destructibleObjectSpace;
 373     CompleteSubspace eagerlySweptDestructibleObjectSpace;

 374 
 375     IsoSubspace executableToCodeBlockEdgeSpace;
 376     IsoSubspace functionSpace;
 377     IsoSubspace internalFunctionSpace;
 378     IsoSubspace nativeExecutableSpace;
 379     IsoSubspace propertyTableSpace;
 380     IsoSubspace structureRareDataSpace;
 381     IsoSubspace structureSpace;
<span class="line-added"> 382     IsoSubspace symbolTableSpace;</span>
 383 
 384 #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(name) \
 385     template&lt;SubspaceAccess mode&gt; \
 386     IsoSubspace* name() \
 387     { \
 388         if (m_##name || mode == SubspaceAccess::Concurrently) \
 389             return m_##name.get(); \
 390         return name##Slow(); \
 391     } \
 392     IsoSubspace* name##Slow(); \
 393     std::unique_ptr&lt;IsoSubspace&gt; m_##name;
 394 
 395 
 396 #if JSC_OBJC_API_ENABLED
 397     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(objCCallbackFunctionSpace)
 398 #endif
 399     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(boundFunctionSpace)
 400     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackFunctionSpace)
 401     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(customGetterSetterFunctionSpace)
 402     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(errorInstanceSpace)
 403     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(nativeStdFunctionSpace)
 404     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(proxyRevokeSpace)
<span class="line-added"> 405     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakObjectRefSpace)</span>
 406     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakSetSpace)
 407     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakMapSpace)
 408 #if ENABLE(WEBASSEMBLY)
 409     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyCodeBlockSpace)
 410     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyFunctionSpace)
 411     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyWrapperFunctionSpace)
 412 #endif
 413 
 414 #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER
 415 
 416     IsoCellSet executableToCodeBlockEdgesWithConstraints;
 417     IsoCellSet executableToCodeBlockEdgesWithFinalizers;
 418 
 419 #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(name) \
 420     template&lt;SubspaceAccess mode&gt; \
 421     IsoSubspace* name() \
 422     { \
 423         if (auto* spaceAndSet = m_##name.get()) \
 424             return &amp;spaceAndSet-&gt;space; \
 425         if (mode == SubspaceAccess::Concurrently) \
</pre>
<hr />
<pre>
 435         IsoSubspace space;
 436         IsoCellSet set;
 437 
 438         template&lt;typename... Arguments&gt;
 439         SpaceAndSet(Arguments&amp;&amp;... arguments)
 440             : space(std::forward&lt;Arguments&gt;(arguments)...)
 441             , set(space)
 442         {
 443         }
 444 
 445         static IsoCellSet&amp; setFor(Subspace&amp; space)
 446         {
 447             return *bitwise_cast&lt;IsoCellSet*&gt;(
 448                 bitwise_cast&lt;char*&gt;(&amp;space) -
 449                 OBJECT_OFFSETOF(SpaceAndSet, space) +
 450                 OBJECT_OFFSETOF(SpaceAndSet, set));
 451         }
 452     };
 453 
 454     SpaceAndSet codeBlockSpace;

 455 
 456     template&lt;typename Func&gt;
 457     void forEachCodeBlockSpace(const Func&amp; func)
 458     {
 459         // This should not include webAssemblyCodeBlockSpace because this is about subsclasses of
 460         // JSC::CodeBlock.
 461         func(codeBlockSpace);
 462     }
 463 
 464     DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(evalExecutableSpace)
 465     DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(moduleProgramExecutableSpace)
 466     SpaceAndSet functionExecutableSpace;
 467     SpaceAndSet programExecutableSpace;
 468 
 469     template&lt;typename Func&gt;
 470     void forEachScriptExecutableSpace(const Func&amp; func)
 471     {
 472         if (m_evalExecutableSpace)
 473             func(*m_evalExecutableSpace);
 474         func(functionExecutableSpace);
</pre>
<hr />
<pre>
 510 #endif
 511     Strong&lt;Structure&gt; moduleProgramExecutableStructure;
 512     Strong&lt;Structure&gt; regExpStructure;
 513     Strong&lt;Structure&gt; symbolStructure;
 514     Strong&lt;Structure&gt; symbolTableStructure;
 515     Strong&lt;Structure&gt; fixedArrayStructure;
 516     Strong&lt;Structure&gt; immutableButterflyStructures[NumberOfCopyOnWriteIndexingModes];
 517     Strong&lt;Structure&gt; sourceCodeStructure;
 518     Strong&lt;Structure&gt; scriptFetcherStructure;
 519     Strong&lt;Structure&gt; scriptFetchParametersStructure;
 520     Strong&lt;Structure&gt; structureChainStructure;
 521     Strong&lt;Structure&gt; sparseArrayValueMapStructure;
 522     Strong&lt;Structure&gt; templateObjectDescriptorStructure;
 523     Strong&lt;Structure&gt; arrayBufferNeuteringWatchpointStructure;
 524     Strong&lt;Structure&gt; unlinkedFunctionExecutableStructure;
 525     Strong&lt;Structure&gt; unlinkedProgramCodeBlockStructure;
 526     Strong&lt;Structure&gt; unlinkedEvalCodeBlockStructure;
 527     Strong&lt;Structure&gt; unlinkedFunctionCodeBlockStructure;
 528     Strong&lt;Structure&gt; unlinkedModuleProgramCodeBlockStructure;
 529     Strong&lt;Structure&gt; propertyTableStructure;

 530     Strong&lt;Structure&gt; functionRareDataStructure;
 531     Strong&lt;Structure&gt; exceptionStructure;
 532     Strong&lt;Structure&gt; promiseDeferredStructure;
 533     Strong&lt;Structure&gt; internalPromiseDeferredStructure;
 534     Strong&lt;Structure&gt; nativeStdFunctionCellStructure;
 535     Strong&lt;Structure&gt; programCodeBlockStructure;
 536     Strong&lt;Structure&gt; moduleProgramCodeBlockStructure;
 537     Strong&lt;Structure&gt; evalCodeBlockStructure;
 538     Strong&lt;Structure&gt; functionCodeBlockStructure;
 539     Strong&lt;Structure&gt; hashMapBucketSetStructure;
 540     Strong&lt;Structure&gt; hashMapBucketMapStructure;


 541     Strong&lt;Structure&gt; bigIntStructure;
 542     Strong&lt;Structure&gt; executableToCodeBlockEdgeStructure;
 543 
<span class="line-modified"> 544     Strong&lt;Structure&gt; m_setIteratorStructure;</span>
<span class="line-added"> 545     Strong&lt;Structure&gt; m_mapIteratorStructure;</span>
<span class="line-added"> 546 </span>
<span class="line-added"> 547     Strong&lt;JSPropertyNameEnumerator&gt; m_emptyPropertyNameEnumerator;</span>
 548 
 549     Strong&lt;JSCell&gt; m_sentinelSetBucket;
 550     Strong&lt;JSCell&gt; m_sentinelMapBucket;
 551 
<span class="line-modified"> 552     Ref&lt;PromiseDeferredTimer&gt; promiseDeferredTimer;</span>
 553 
 554     JSCell* currentlyDestructingCallbackObject;
 555     const ClassInfo* currentlyDestructingCallbackObjectClassInfo { nullptr };
 556 
<span class="line-modified"> 557     AtomStringTable* m_atomStringTable;</span>
 558     WTF::SymbolRegistry m_symbolRegistry;
 559     CommonIdentifiers* propertyNames;
 560     const ArgList* emptyList;
 561     SmallStrings smallStrings;
 562     NumericStrings numericStrings;
 563     DateInstanceCache dateInstanceCache;
 564     std::unique_ptr&lt;SimpleStats&gt; machineCodeBytesPerBytecodeWordForBaselineJIT;
 565     WeakGCMap&lt;std::pair&lt;CustomGetterSetter*, int&gt;, JSCustomGetterSetterFunction&gt; customGetterSetterFunctionMap;
 566     WeakGCMap&lt;StringImpl*, JSString, PtrHash&lt;StringImpl*&gt;&gt; stringCache;
 567     Strong&lt;JSString&gt; lastCachedString;
 568 
<span class="line-modified"> 569     AtomStringTable* atomStringTable() const { return m_atomStringTable; }</span>
 570     WTF::SymbolRegistry&amp; symbolRegistry() { return m_symbolRegistry; }
 571 
<span class="line-added"> 572     Structure* setIteratorStructure()</span>
<span class="line-added"> 573     {</span>
<span class="line-added"> 574         if (LIKELY(m_setIteratorStructure))</span>
<span class="line-added"> 575             return m_setIteratorStructure.get();</span>
<span class="line-added"> 576         return setIteratorStructureSlow();</span>
<span class="line-added"> 577     }</span>
<span class="line-added"> 578 </span>
<span class="line-added"> 579     Structure* mapIteratorStructure()</span>
<span class="line-added"> 580     {</span>
<span class="line-added"> 581         if (LIKELY(m_mapIteratorStructure))</span>
<span class="line-added"> 582             return m_mapIteratorStructure.get();</span>
<span class="line-added"> 583         return mapIteratorStructureSlow();</span>
<span class="line-added"> 584     }</span>
<span class="line-added"> 585 </span>
 586     JSCell* sentinelSetBucket()
 587     {
 588         if (LIKELY(m_sentinelSetBucket))
 589             return m_sentinelSetBucket.get();
 590         return sentinelSetBucketSlow();
 591     }
 592 
 593     JSCell* sentinelMapBucket()
 594     {
 595         if (LIKELY(m_sentinelMapBucket))
 596             return m_sentinelMapBucket.get();
 597         return sentinelMapBucketSlow();
 598     }
 599 
<span class="line-added"> 600     JSPropertyNameEnumerator* emptyPropertyNameEnumerator()</span>
<span class="line-added"> 601     {</span>
<span class="line-added"> 602         if (LIKELY(m_emptyPropertyNameEnumerator))</span>
<span class="line-added"> 603             return m_emptyPropertyNameEnumerator.get();</span>
<span class="line-added"> 604         return emptyPropertyNameEnumeratorSlow();</span>
<span class="line-added"> 605     }</span>
<span class="line-added"> 606 </span>
 607     WeakGCMap&lt;SymbolImpl*, Symbol, PtrHash&lt;SymbolImpl*&gt;&gt; symbolImplToSymbolMap;
 608 
 609     enum class DeletePropertyMode {
 610         // Default behaviour of deleteProperty, matching the spec.
 611         Default,
 612         // This setting causes deleteProperty to force deletion of all
 613         // properties including those that are non-configurable (DontDelete).
 614         IgnoreConfigurable
 615     };
 616 
 617     DeletePropertyMode deletePropertyMode()
 618     {
 619         return m_deletePropertyMode;
 620     }
 621 
 622     class DeletePropertyModeScope {
 623     public:
 624         DeletePropertyModeScope(VM&amp; vm, DeletePropertyMode mode)
 625             : m_vm(vm)
 626             , m_previousMode(vm.m_deletePropertyMode)
 627         {
 628             m_vm.m_deletePropertyMode = mode;
 629         }
 630 
 631         ~DeletePropertyModeScope()
 632         {
 633             m_vm.m_deletePropertyMode = m_previousMode;
 634         }
 635 
 636     private:
 637         VM&amp; m_vm;
 638         DeletePropertyMode m_previousMode;
 639     };
 640 
 641     static JS_EXPORT_PRIVATE bool canUseAssembler();
<span class="line-modified"> 642     static bool isInMiniMode()</span>
<span class="line-modified"> 643     {</span>
<span class="line-added"> 644         return !canUseJIT() || Options::forceMiniVMMode();</span>
<span class="line-added"> 645     }</span>
<span class="line-added"> 646 </span>
<span class="line-added"> 647     static bool useUnlinkedCodeBlockJettisoning()</span>
<span class="line-added"> 648     {</span>
<span class="line-added"> 649         return Options::useUnlinkedCodeBlockJettisoning() || isInMiniMode();</span>
<span class="line-added"> 650     }</span>
 651 
 652     static void computeCanUseJIT();
 653     ALWAYS_INLINE static bool canUseJIT()
 654     {
 655 #if ENABLE(JIT)
 656 #if !ASSERT_DISABLED
 657         RELEASE_ASSERT(s_canUseJITIsSet);
 658 #endif
 659         return s_canUseJIT;
 660 #else
 661         return false;
 662 #endif
 663     }
 664 
 665     SourceProviderCache* addSourceProviderCache(SourceProvider*);
 666     void clearSourceProviderCaches();
 667 
 668     StructureCache structureCache;
 669 
 670     typedef HashMap&lt;RefPtr&lt;SourceProvider&gt;, RefPtr&lt;SourceProviderCache&gt;&gt; SourceProviderCacheMap;
 671     SourceProviderCacheMap sourceProviderCacheMap;
 672     Interpreter* interpreter;
 673 #if ENABLE(JIT)
 674     std::unique_ptr&lt;JITThunks&gt; jitStubs;
 675     MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; getCTIStub(ThunkGenerator generator)
 676     {
<span class="line-modified"> 677         return jitStubs-&gt;ctiStub(*this, generator);</span>
 678     }
 679 
 680 #endif // ENABLE(JIT)
 681 #if ENABLE(FTL_JIT)
 682     std::unique_ptr&lt;FTL::Thunks&gt; ftlThunks;
 683 #endif
 684     NativeExecutable* getHostFunction(NativeFunction, NativeFunction constructor, const String&amp; name);
 685     NativeExecutable* getHostFunction(NativeFunction, Intrinsic, NativeFunction constructor, const DOMJIT::Signature*, const String&amp; name);
 686 
 687     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; getCTIInternalFunctionTrampolineFor(CodeSpecializationKind);
 688 
 689     static ptrdiff_t exceptionOffset()
 690     {
 691         return OBJECT_OFFSETOF(VM, m_exception);
 692     }
 693 
 694     static ptrdiff_t callFrameForCatchOffset()
 695     {
 696         return OBJECT_OFFSETOF(VM, callFrameForCatch);
 697     }
 698 
 699     static ptrdiff_t topEntryFrameOffset()
 700     {
 701         return OBJECT_OFFSETOF(VM, topEntryFrame);
 702     }
 703 
<span class="line-added"> 704     static ptrdiff_t offsetOfHeapBarrierThreshold()</span>
<span class="line-added"> 705     {</span>
<span class="line-added"> 706         return OBJECT_OFFSETOF(VM, heap) + OBJECT_OFFSETOF(Heap, m_barrierThreshold);</span>
<span class="line-added"> 707     }</span>
<span class="line-added"> 708 </span>
<span class="line-added"> 709     static ptrdiff_t offsetOfHeapMutatorShouldBeFenced()</span>
<span class="line-added"> 710     {</span>
<span class="line-added"> 711         return OBJECT_OFFSETOF(VM, heap) + OBJECT_OFFSETOF(Heap, m_mutatorShouldBeFenced);</span>
<span class="line-added"> 712     }</span>
<span class="line-added"> 713 </span>
 714     void restorePreviousException(Exception* exception) { setException(exception); }
 715 
 716     void clearLastException() { m_lastException = nullptr; }
 717 
 718     ExecState** addressOfCallFrameForCatch() { return &amp;callFrameForCatch; }
 719 
 720     JSCell** addressOfException() { return reinterpret_cast&lt;JSCell**&gt;(&amp;m_exception); }
 721 
 722     Exception* lastException() const { return m_lastException; }
 723     JSCell** addressOfLastException() { return reinterpret_cast&lt;JSCell**&gt;(&amp;m_lastException); }
 724 
 725     // This should only be used for test or assertion code that wants to inspect
 726     // the pending exception without interfering with Throw/CatchScopes.
 727     Exception* exceptionForInspection() const { return m_exception; }
 728 
 729     void setFailNextNewCodeBlock() { m_failNextNewCodeBlock = true; }
 730     bool getAndClearFailNextNewCodeBlock()
 731     {
 732         bool result = m_failNextNewCodeBlock;
 733         m_failNextNewCodeBlock = false;
</pre>
<hr />
<pre>
 737     ALWAYS_INLINE Structure* getStructure(StructureID id)
 738     {
 739         return heap.structureIDTable().get(decontaminate(id));
 740     }
 741 
 742     void* stackPointerAtVMEntry() const { return m_stackPointerAtVMEntry; }
 743     void setStackPointerAtVMEntry(void*);
 744 
 745     size_t softReservedZoneSize() const { return m_currentSoftReservedZoneSize; }
 746     size_t updateSoftReservedZoneSize(size_t softReservedZoneSize);
 747 
 748     static size_t committedStackByteCount();
 749     inline bool ensureStackCapacityFor(Register* newTopOfStack);
 750 
 751     void* stackLimit() { return m_stackLimit; }
 752     void* softStackLimit() { return m_softStackLimit; }
 753     void** addressOfSoftStackLimit() { return &amp;m_softStackLimit; }
 754 #if ENABLE(C_LOOP)
 755     void* cloopStackLimit() { return m_cloopStackLimit; }
 756     void setCLoopStackLimit(void* limit) { m_cloopStackLimit = limit; }
<span class="line-added"> 757     JS_EXPORT_PRIVATE void* currentCLoopStackPointer() const;</span>
 758 #endif
 759 
 760     inline bool isSafeToRecurseSoft() const;
 761     bool isSafeToRecurse() const
 762     {
 763         return isSafeToRecurse(m_stackLimit);
 764     }
 765 
 766     void** addressOfLastStackTop() { return &amp;m_lastStackTop; }
 767     void* lastStackTop() { return m_lastStackTop; }
 768     void setLastStackTop(void*);
 769 
 770     void firePrimitiveGigacageEnabledIfNecessary()
 771     {
 772         if (m_needToFirePrimitiveGigacageEnabled) {
 773             m_needToFirePrimitiveGigacageEnabled = false;
 774             m_primitiveGigacageEnabled.fireAll(*this, &quot;Primitive gigacage disabled asynchronously&quot;);
 775         }
 776     }
 777 
</pre>
<hr />
<pre>
 790     // - You can only set the ScratchBuffer&#39;s activeLength from the main thread.
 791     // - You can only write to entries in the ScratchBuffer from the main thread.
 792     ScratchBuffer* scratchBufferForSize(size_t size);
 793     void clearScratchBuffers();
 794 
 795     EncodedJSValue* exceptionFuzzingBuffer(size_t size)
 796     {
 797         ASSERT(Options::useExceptionFuzz());
 798         if (!m_exceptionFuzzBuffer)
 799             m_exceptionFuzzBuffer = MallocPtr&lt;EncodedJSValue&gt;::malloc(size);
 800         return m_exceptionFuzzBuffer.get();
 801     }
 802 
 803     void gatherScratchBufferRoots(ConservativeRoots&amp;);
 804 
 805     VMEntryScope* entryScope;
 806 
 807     JSObject* stringRecursionCheckFirstObject { nullptr };
 808     HashSet&lt;JSObject*&gt; stringRecursionCheckVisitedObjects;
 809 
<span class="line-added"> 810     LocalTimeOffsetCache utcTimeOffsetCache;</span>
 811     LocalTimeOffsetCache localTimeOffsetCache;
 812 
 813     String cachedDateString;
 814     double cachedDateStringValue;
 815 
 816     std::unique_ptr&lt;Profiler::Database&gt; m_perBytecodeProfiler;
 817     RefPtr&lt;TypedArrayController&gt; m_typedArrayController;
 818     RegExpCache* m_regExpCache;
 819     BumpPointerAllocator m_regExpAllocator;
 820     ConcurrentJSLock m_regExpAllocatorLock;
 821 
 822 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 823     static constexpr size_t patternContextBufferSize = 8192; // Space allocated to save nested parenthesis context
 824     UniqueArray&lt;char&gt; m_regExpPatternContexBuffer;
 825     Lock m_regExpPatternContextLock;
 826     char* acquireRegExpPatternContexBuffer();
 827     void releaseRegExpPatternContexBuffer();
<span class="line-added"> 828 #else</span>
<span class="line-added"> 829     static constexpr size_t patternContextBufferSize = 0; // Space allocated to save nested parenthesis context</span>
 830 #endif
 831 
 832     Ref&lt;CompactVariableMap&gt; m_compactVariableMap;
 833 
 834     std::unique_ptr&lt;HasOwnPropertyCache&gt; m_hasOwnPropertyCache;
 835     ALWAYS_INLINE HasOwnPropertyCache* hasOwnPropertyCache() { return m_hasOwnPropertyCache.get(); }
 836     HasOwnPropertyCache* ensureHasOwnPropertyCache();
 837 
 838 #if ENABLE(REGEXP_TRACING)
 839     typedef ListHashSet&lt;RegExp*&gt; RTTraceList;
 840     RTTraceList* m_rtTraceList;
 841 #endif
 842 


 843     JS_EXPORT_PRIVATE void resetDateCache();
 844 
 845     RegExpCache* regExpCache() { return m_regExpCache; }
 846 #if ENABLE(REGEXP_TRACING)
 847     void addRegExpToTrace(RegExp*);
 848 #endif
 849     JS_EXPORT_PRIVATE void dumpRegExpTrace();
 850 
 851     bool isCollectorBusyOnCurrentThread() { return heap.isCurrentThreadBusy(); }
 852 
 853 #if ENABLE(GC_VALIDATION)
 854     bool isInitializingObject() const;
 855     void setInitializingObjectClass(const ClassInfo*);
 856 #endif
 857 
 858     bool currentThreadIsHoldingAPILock() const { return m_apiLock-&gt;currentThreadIsHoldingLock(); }
 859 
 860     JSLock&amp; apiLock() { return *m_apiLock; }
 861     CodeCache* codeCache() { return m_codeCache.get(); }
 862 
 863     JS_EXPORT_PRIVATE void whenIdle(Function&lt;void()&gt;&amp;&amp;);
 864 
 865     JS_EXPORT_PRIVATE void deleteAllCode(DeleteAllCodeEffort);
 866     JS_EXPORT_PRIVATE void deleteAllLinkedCode(DeleteAllCodeEffort);
 867 
 868     void shrinkFootprintWhenIdle();
 869 
 870     WatchpointSet* ensureWatchpointSetForImpureProperty(const Identifier&amp;);
 871     void registerWatchpointForImpureProperty(const Identifier&amp;, Watchpoint*);
 872 
<span class="line-modified"> 873     // FIXME: Use AtomString once it got merged with Identifier.</span>
 874     JS_EXPORT_PRIVATE void addImpureProperty(const String&amp;);
 875 
 876     InlineWatchpointSet&amp; primitiveGigacageEnabled() { return m_primitiveGigacageEnabled; }
 877 
 878     BuiltinExecutables* builtinExecutables() { return m_builtinExecutables.get(); }
 879 
 880     bool enableTypeProfiler();
 881     bool disableTypeProfiler();
 882     TypeProfilerLog* typeProfilerLog() { return m_typeProfilerLog.get(); }
 883     TypeProfiler* typeProfiler() { return m_typeProfiler.get(); }
 884     JS_EXPORT_PRIVATE void dumpTypeProfilerData();
 885 
 886     FunctionHasExecutedCache* functionHasExecutedCache() { return &amp;m_functionHasExecutedCache; }
 887 
 888     ControlFlowProfiler* controlFlowProfiler() { return m_controlFlowProfiler.get(); }
 889     bool enableControlFlowProfiler();
 890     bool disableControlFlowProfiler();
 891 
 892     void queueMicrotask(JSGlobalObject&amp;, Ref&lt;Microtask&gt;&amp;&amp;);
 893     JS_EXPORT_PRIVATE void drainMicrotasks();
<span class="line-modified"> 894     void setOnEachMicrotaskTick(WTF::Function&lt;void(VM&amp;)&gt;&amp;&amp; func) { m_onEachMicrotaskTick = WTFMove(func); }</span>
<span class="line-added"> 895     void finalizeSynchronousJSExecution() { ASSERT(currentThreadIsHoldingAPILock()); m_currentWeakRefVersion++; }</span>
<span class="line-added"> 896     uintptr_t currentWeakRefVersion() const { return m_currentWeakRefVersion; }</span>
<span class="line-added"> 897 </span>
 898     void setGlobalConstRedeclarationShouldThrow(bool globalConstRedeclarationThrow) { m_globalConstRedeclarationShouldThrow = globalConstRedeclarationThrow; }
 899     ALWAYS_INLINE bool globalConstRedeclarationShouldThrow() const { return m_globalConstRedeclarationShouldThrow; }
 900 
 901     void setShouldBuildPCToCodeOriginMapping() { m_shouldBuildPCToCodeOriginMapping = true; }
 902     bool shouldBuilderPCToCodeOriginMapping() const { return m_shouldBuildPCToCodeOriginMapping; }
 903 
 904     BytecodeIntrinsicRegistry&amp; bytecodeIntrinsicRegistry() { return *m_bytecodeIntrinsicRegistry; }
 905 
 906     ShadowChicken* shadowChicken() { return m_shadowChicken.get(); }
 907     void ensureShadowChicken();
 908 
 909     template&lt;typename Func&gt;
 910     void logEvent(CodeBlock*, const char* summary, const Func&amp; func);
 911 
 912     Optional&lt;RefPtr&lt;Thread&gt;&gt; ownerThread() const { return m_apiLock-&gt;ownerThread(); }
 913 
 914     VMTraps&amp; traps() { return m_traps; }
 915 
 916     void handleTraps(ExecState* exec, VMTraps::Mask mask = VMTraps::Mask::allEventTypes()) { m_traps.handleTraps(exec, mask); }
 917 
 918     bool needTrapHandling() { return m_traps.needTrapHandling(); }
 919     bool needTrapHandling(VMTraps::Mask mask) { return m_traps.needTrapHandling(mask); }
 920     void* needTrapHandlingAddress() { return m_traps.needTrapHandlingAddress(); }
 921 
 922     void notifyNeedDebuggerBreak() { m_traps.fireTrap(VMTraps::NeedDebuggerBreak); }
 923     void notifyNeedTermination() { m_traps.fireTrap(VMTraps::NeedTermination); }
 924     void notifyNeedWatchdogCheck() { m_traps.fireTrap(VMTraps::NeedWatchdogCheck); }
 925 
<span class="line-added"> 926     void promiseRejected(JSPromise*);</span>
<span class="line-added"> 927 </span>
 928 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 929     StackTrace* nativeStackTraceOfLastThrow() const { return m_nativeStackTraceOfLastThrow.get(); }
 930     Thread* throwingThread() const { return m_throwingThread.get(); }
 931     bool needExceptionCheck() const { return m_needExceptionCheck; }
 932 #endif
 933 
 934 #if USE(CF)
 935     CFRunLoopRef runLoop() const { return m_runLoop.get(); }
 936     JS_EXPORT_PRIVATE void setRunLoop(CFRunLoopRef);
 937 #endif // USE(CF)
 938 
<span class="line-added"> 939     static void setCrashOnVMCreation(bool);</span>
<span class="line-added"> 940 </span>
 941     class DeferExceptionScope {
 942     public:
 943         DeferExceptionScope(VM&amp; vm)
 944             : m_savedException(vm.m_exception, nullptr)
 945             , m_savedLastException(vm.m_lastException, nullptr)
 946         {
 947         }
 948 
 949     private:
 950         SetForScope&lt;Exception*&gt; m_savedException;
 951         SetForScope&lt;Exception*&gt; m_savedLastException;
 952     };
 953 
 954 private:
 955     friend class LLIntOffsetsExtractor;
 956 
 957     VM(VMType, HeapType);
 958     static VM*&amp; sharedInstanceInternal();
 959     void createNativeThunk();
 960 
<span class="line-added"> 961     JS_EXPORT_PRIVATE Structure* setIteratorStructureSlow();</span>
<span class="line-added"> 962     JS_EXPORT_PRIVATE Structure* mapIteratorStructureSlow();</span>
 963     JSCell* sentinelSetBucketSlow();
 964     JSCell* sentinelMapBucketSlow();
<span class="line-added"> 965     JSPropertyNameEnumerator* emptyPropertyNameEnumeratorSlow();</span>
 966 
 967     void updateStackLimits();
 968 
 969     bool isSafeToRecurse(void* stackLimit) const
 970     {
 971         ASSERT(Thread::current().stack().isGrowingDownward());
 972         void* curr = currentStackPointer();
 973         return curr &gt;= stackLimit;
 974     }
 975 
 976     void setException(Exception* exception)
 977     {
 978         m_exception = exception;
 979         m_lastException = exception;
 980     }
 981     Exception* exception() const
 982     {
 983 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 984         m_needExceptionCheck = false;
 985 #endif
 986         return m_exception;
 987     }
 988     void clearException()
 989     {
 990 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 991         m_needExceptionCheck = false;
 992         m_nativeStackTraceOfLastThrow = nullptr;
 993         m_throwingThread = nullptr;
 994 #endif
 995         m_exception = nullptr;
 996     }
 997 
 998 #if ENABLE(C_LOOP)
 999     bool ensureStackCapacityForCLoop(Register* newTopOfStack);
1000     bool isSafeToRecurseSoftCLoop() const;
1001 #endif // ENABLE(C_LOOP)
1002 
<span class="line-modified">1003     JS_EXPORT_PRIVATE Exception* throwException(ExecState*, Exception*);</span>
<span class="line-modified">1004     JS_EXPORT_PRIVATE Exception* throwException(ExecState*, JSValue);</span>
<span class="line-modified">1005     JS_EXPORT_PRIVATE Exception* throwException(ExecState*, JSObject*);</span>
1006 
1007 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1008     void verifyExceptionCheckNeedIsSatisfied(unsigned depth, ExceptionEventLocation&amp;);
1009 #endif
1010 
1011     static void primitiveGigacageDisabledCallback(void*);
1012     void primitiveGigacageDisabled();
1013 
<span class="line-added">1014     void callPromiseRejectionCallback(Strong&lt;JSPromise&gt;&amp;);</span>
<span class="line-added">1015     void didExhaustMicrotaskQueue();</span>
<span class="line-added">1016 </span>
1017 #if ENABLE(GC_VALIDATION)
1018     const ClassInfo* m_initializingObjectClass;
1019 #endif
1020 
1021     void* m_stackPointerAtVMEntry;
1022     size_t m_currentSoftReservedZoneSize;
1023     void* m_stackLimit { nullptr };
1024     void* m_softStackLimit { nullptr };
1025 #if ENABLE(C_LOOP)
1026     void* m_cloopStackLimit { nullptr };
1027 #endif
1028     void* m_lastStackTop { nullptr };
1029 
1030     Exception* m_exception { nullptr };
1031     Exception* m_lastException { nullptr };
1032 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1033     ExceptionScope* m_topExceptionScope { nullptr };
1034     ExceptionEventLocation m_simulatedThrowPointLocation;
1035     unsigned m_simulatedThrowPointRecursionDepth { 0 };
1036     mutable bool m_needExceptionCheck { false };
</pre>
<hr />
<pre>
1048     HashMap&lt;String, RefPtr&lt;WatchpointSet&gt;&gt; m_impurePropertyWatchpointSets;
1049     std::unique_ptr&lt;TypeProfiler&gt; m_typeProfiler;
1050     std::unique_ptr&lt;TypeProfilerLog&gt; m_typeProfilerLog;
1051     unsigned m_typeProfilerEnabledCount;
1052     bool m_needToFirePrimitiveGigacageEnabled { false };
1053     Lock m_scratchBufferLock;
1054     Vector&lt;ScratchBuffer*&gt; m_scratchBuffers;
1055     size_t m_sizeOfLastScratchBuffer { 0 };
1056     InlineWatchpointSet m_primitiveGigacageEnabled;
1057     FunctionHasExecutedCache m_functionHasExecutedCache;
1058     std::unique_ptr&lt;ControlFlowProfiler&gt; m_controlFlowProfiler;
1059     unsigned m_controlFlowProfilerEnabledCount;
1060     Deque&lt;std::unique_ptr&lt;QueuedTask&gt;&gt; m_microtaskQueue;
1061     MallocPtr&lt;EncodedJSValue&gt; m_exceptionFuzzBuffer;
1062     VMTraps m_traps;
1063     RefPtr&lt;Watchdog&gt; m_watchdog;
1064     std::unique_ptr&lt;HeapProfiler&gt; m_heapProfiler;
1065 #if ENABLE(SAMPLING_PROFILER)
1066     RefPtr&lt;SamplingProfiler&gt; m_samplingProfiler;
1067 #endif
<span class="line-added">1068     std::unique_ptr&lt;FuzzerAgent&gt; m_fuzzerAgent;</span>
1069     std::unique_ptr&lt;ShadowChicken&gt; m_shadowChicken;
1070     std::unique_ptr&lt;BytecodeIntrinsicRegistry&gt; m_bytecodeIntrinsicRegistry;
1071 
<span class="line-added">1072     // FIXME: We should remove handled promises from this list at GC flip. &lt;https://webkit.org/b/201005&gt;</span>
<span class="line-added">1073     Vector&lt;Strong&lt;JSPromise&gt;&gt; m_aboutToBeNotifiedRejectedPromises;</span>
<span class="line-added">1074 </span>
1075     WTF::Function&lt;void(VM&amp;)&gt; m_onEachMicrotaskTick;
<span class="line-added">1076     uintptr_t m_currentWeakRefVersion { 0 };</span>
1077 
1078 #if ENABLE(JIT)
1079 #if !ASSERT_DISABLED
1080     JS_EXPORT_PRIVATE static bool s_canUseJITIsSet;
1081 #endif
1082     JS_EXPORT_PRIVATE static bool s_canUseJIT;
1083 #endif
1084 
1085     VM* m_prev; // Required by DoublyLinkedListNode.
1086     VM* m_next; // Required by DoublyLinkedListNode.
1087 
1088     // Friends for exception checking purpose only.
1089     friend class Heap;
1090     friend class CatchScope;
1091     friend class ExceptionScope;
1092     friend class ThrowScope;
1093     friend class VMTraps;
1094     friend class WTF::DoublyLinkedListNode&lt;VM&gt;;
1095 };
1096 
1097 #if ENABLE(GC_VALIDATION)
1098 inline bool VM::isInitializingObject() const
1099 {
1100     return !!m_initializingObjectClass;
1101 }
1102 
1103 inline void VM::setInitializingObjectClass(const ClassInfo* initializingObjectClass)
1104 {
1105     m_initializingObjectClass = initializingObjectClass;
1106 }
1107 #endif
1108 
1109 inline Heap* WeakSet::heap() const
1110 {
<span class="line-modified">1111     return &amp;m_vm.heap;</span>
1112 }
1113 
1114 #if !ENABLE(C_LOOP)
1115 extern &quot;C&quot; void sanitizeStackForVMImpl(VM*);
1116 #endif
1117 
<span class="line-modified">1118 JS_EXPORT_PRIVATE void sanitizeStackForVM(VM&amp;);</span>
<span class="line-modified">1119 void logSanitizeStack(VM&amp;);</span>
1120 
1121 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="VM.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VMTraps.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>