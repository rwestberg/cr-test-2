<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StringPrototypeInlines.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringPrototype.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  81 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(ExecState*);
  82 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(ExecState*);
  83 EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(ExecState*);
  84 EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(ExecState*);
  85 EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(ExecState*);
  86 EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(ExecState*);
  87 EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(ExecState*);
  88 
  89 }
  90 
  91 #include &quot;StringPrototype.lut.h&quot;
  92 
  93 namespace JSC {
  94 
  95 const ClassInfo StringPrototype::s_info = { &quot;String&quot;, &amp;StringObject::s_info, &amp;stringPrototypeTable, nullptr, CREATE_METHOD_TABLE(StringPrototype) };
  96 
  97 /* Source for StringConstructor.lut.h
  98 @begin stringPrototypeTable
  99     concat    JSBuiltin    DontEnum|Function 1
 100     match     JSBuiltin    DontEnum|Function 1

 101     padStart  JSBuiltin    DontEnum|Function 1
 102     padEnd    JSBuiltin    DontEnum|Function 1
 103     repeat    JSBuiltin    DontEnum|Function 1
 104     replace   JSBuiltin    DontEnum|Function 2
 105     search    JSBuiltin    DontEnum|Function 1
 106     split     JSBuiltin    DontEnum|Function 1
 107     anchor    JSBuiltin    DontEnum|Function 1
 108     big       JSBuiltin    DontEnum|Function 0
 109     bold      JSBuiltin    DontEnum|Function 0
 110     blink     JSBuiltin    DontEnum|Function 0
 111     fixed     JSBuiltin    DontEnum|Function 0
 112     fontcolor JSBuiltin    DontEnum|Function 1
 113     fontsize  JSBuiltin    DontEnum|Function 1
 114     italics   JSBuiltin    DontEnum|Function 0
 115     link      JSBuiltin    DontEnum|Function 1
 116     small     JSBuiltin    DontEnum|Function 0
 117     strike    JSBuiltin    DontEnum|Function 0
 118     sub       JSBuiltin    DontEnum|Function 0
 119     sup       JSBuiltin    DontEnum|Function 0
 120 @end
</pre>
<hr />
<pre>
 145     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substring&quot;, stringProtoFuncSubstring, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 146     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;toLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeToLowerCaseIntrinsic);
 147     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 148     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;localeCompare&quot;, stringProtoFuncLocaleCompare, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 149 #if ENABLE(INTL)
 150     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleLowerCase&quot;, stringProtoFuncToLocaleLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 151     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleUpperCase&quot;, stringProtoFuncToLocaleUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 152 #else
 153     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 154     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 155 #endif
 156     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;trim&quot;, stringProtoFuncTrim, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 157     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;startsWith&quot;, stringProtoFuncStartsWith, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 158     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;endsWith&quot;, stringProtoFuncEndsWith, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 159     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;includes&quot;, stringProtoFuncIncludes, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 160     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;normalize&quot;, stringProtoFuncNormalize, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 161     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().charCodeAtPrivateName(), stringProtoFuncCharCodeAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
 162 
 163     JSFunction* trimStartFunction = JSFunction::create(vm, globalObject, 0, &quot;trimStart&quot;_s, stringProtoFuncTrimStart, NoIntrinsic);
 164     JSFunction* trimEndFunction = JSFunction::create(vm, globalObject, 0, &quot;trimEnd&quot;_s, stringProtoFuncTrimEnd, NoIntrinsic);
<span class="line-modified"> 165     putDirectWithoutTransition(vm, Identifier::fromString(&amp;vm, &quot;trimStart&quot;), trimStartFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 166     putDirectWithoutTransition(vm, Identifier::fromString(&amp;vm, &quot;trimLeft&quot;), trimStartFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 167     putDirectWithoutTransition(vm, Identifier::fromString(&amp;vm, &quot;trimEnd&quot;), trimEndFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 168     putDirectWithoutTransition(vm, Identifier::fromString(&amp;vm, &quot;trimRight&quot;), trimEndFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 169 
 170     JSFunction* iteratorFunction = JSFunction::create(vm, globalObject, 0, &quot;[Symbol.iterator]&quot;_s, stringProtoFuncIterator, NoIntrinsic);
 171     putDirectWithoutTransition(vm, vm.propertyNames-&gt;iteratorSymbol, iteratorFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 172 
 173     // The constructor will be added later, after StringConstructor has been built
 174     putDirectWithoutTransition(vm, vm.propertyNames-&gt;length, jsNumber(0), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 175 }
 176 
 177 StringPrototype* StringPrototype::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 178 {
<span class="line-modified"> 179     JSString* empty = jsEmptyString(&amp;vm);</span>
 180     StringPrototype* prototype = new (NotNull, allocateCell&lt;StringPrototype&gt;(vm.heap)) StringPrototype(vm, structure);
 181     prototype-&gt;finishCreation(vm, globalObject, empty);
 182     return prototype;
 183 }
 184 
 185 // ------------------------------ Functions --------------------------
 186 
 187 static NEVER_INLINE void substituteBackreferencesSlow(StringBuilder&amp; result, StringView replacement, StringView source, const int* ovector, RegExp* reg, size_t i)
 188 {
 189     bool hasNamedCaptures = reg &amp;&amp; reg-&gt;hasNamedCaptures();
 190     int offset = 0;
 191     do {
 192         if (i + 1 == replacement.length())
 193             break;
 194 
 195         UChar ref = replacement[i + 1];
 196         if (ref == &#39;$&#39;) {
 197             // &quot;$$&quot; -&gt; &quot;$&quot;
 198             ++i;
 199             result.append(replacement.substring(offset, i - offset));
</pre>
<hr />
<pre>
 305     StringRange()
 306     {
 307     }
 308 
 309     int position;
 310     int length;
 311 };
 312 
 313 static ALWAYS_INLINE JSString* jsSpliceSubstrings(ExecState* exec, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount)
 314 {
 315     VM&amp; vm = exec-&gt;vm();
 316     auto scope = DECLARE_THROW_SCOPE(vm);
 317 
 318     if (rangeCount == 1) {
 319         int sourceSize = source.length();
 320         int position = substringRanges[0].position;
 321         int length = substringRanges[0].length;
 322         if (position &lt;= 0 &amp;&amp; length &gt;= sourceSize)
 323             return sourceVal;
 324         // We could call String::substringSharingImpl(), but this would result in redundant checks.
<span class="line-modified"> 325         RELEASE_AND_RETURN(scope, jsString(exec, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));</span>
 326     }
 327 
 328     // We know that the sum of substringRanges lengths cannot exceed length of
 329     // source because the substringRanges were computed from the source string
 330     // in removeUsingRegExpSearch(). Hence, totalLength cannot exceed
 331     // String::MaxLength, and therefore, cannot overflow.
 332     Checked&lt;int, AssertNoOverflow&gt; totalLength = 0;
 333     for (int i = 0; i &lt; rangeCount; i++)
 334         totalLength += substringRanges[i].length;
 335     ASSERT(totalLength &lt;= String::MaxLength);
 336 
 337     if (!totalLength)
<span class="line-modified"> 338         return jsEmptyString(exec);</span>
 339 
 340     if (source.is8Bit()) {
 341         LChar* buffer;
 342         const LChar* sourceData = source.characters8();
 343         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 344         if (!impl) {
 345             throwOutOfMemoryError(exec, scope);
 346             return nullptr;
 347         }
 348 
 349         Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 350         for (int i = 0; i &lt; rangeCount; i++) {
 351             if (int srcLen = substringRanges[i].length) {
 352                 StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 353                 bufferPos += srcLen;
 354             }
 355         }
 356 
<span class="line-modified"> 357         RELEASE_AND_RETURN(scope, jsString(exec, WTFMove(impl)));</span>
 358     }
 359 
 360     UChar* buffer;
 361     const UChar* sourceData = source.characters16();
 362 
 363     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 364     if (!impl) {
 365         throwOutOfMemoryError(exec, scope);
 366         return nullptr;
 367     }
 368 
 369     Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 370     for (int i = 0; i &lt; rangeCount; i++) {
 371         if (int srcLen = substringRanges[i].length) {
 372             StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 373             bufferPos += srcLen;
 374         }
 375     }
 376 
<span class="line-modified"> 377     RELEASE_AND_RETURN(scope, jsString(exec, WTFMove(impl)));</span>
 378 }
 379 
 380 static ALWAYS_INLINE JSString* jsSpliceSubstringsWithSeparators(ExecState* exec, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount, const String* separators, int separatorCount)
 381 {
 382     VM&amp; vm = exec-&gt;vm();
 383     auto scope = DECLARE_THROW_SCOPE(vm);
 384 
 385     if (rangeCount == 1 &amp;&amp; separatorCount == 0) {
 386         int sourceSize = source.length();
 387         int position = substringRanges[0].position;
 388         int length = substringRanges[0].length;
 389         if (position &lt;= 0 &amp;&amp; length &gt;= sourceSize)
 390             return sourceVal;
 391         // We could call String::substringSharingImpl(), but this would result in redundant checks.
<span class="line-modified"> 392         RELEASE_AND_RETURN(scope, jsString(exec, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));</span>
 393     }
 394 
 395     Checked&lt;int, RecordOverflow&gt; totalLength = 0;
 396     bool allSeparators8Bit = true;
 397     for (int i = 0; i &lt; rangeCount; i++)
 398         totalLength += substringRanges[i].length;
 399     for (int i = 0; i &lt; separatorCount; i++) {
 400         totalLength += separators[i].length();
 401         if (separators[i].length() &amp;&amp; !separators[i].is8Bit())
 402             allSeparators8Bit = false;
 403     }
 404     if (totalLength.hasOverflowed()) {
 405         throwOutOfMemoryError(exec, scope);
 406         return nullptr;
 407     }
 408 
 409     if (!totalLength)
<span class="line-modified"> 410         return jsEmptyString(exec);</span>
 411 
 412     if (source.is8Bit() &amp;&amp; allSeparators8Bit) {
 413         LChar* buffer;
 414         const LChar* sourceData = source.characters8();
 415 
 416         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 417         if (!impl) {
 418             throwOutOfMemoryError(exec, scope);
 419             return nullptr;
 420         }
 421 
 422         int maxCount = std::max(rangeCount, separatorCount);
 423         Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 424         for (int i = 0; i &lt; maxCount; i++) {
 425             if (i &lt; rangeCount) {
 426                 if (int srcLen = substringRanges[i].length) {
 427                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 428                     bufferPos += srcLen;
 429                 }
 430             }
 431             if (i &lt; separatorCount) {
 432                 if (int sepLen = separators[i].length()) {
 433                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters8(), sepLen);
 434                     bufferPos += sepLen;
 435                 }
 436             }
 437         }
 438 
<span class="line-modified"> 439         RELEASE_AND_RETURN(scope, jsString(exec, WTFMove(impl)));</span>
 440     }
 441 
 442     UChar* buffer;
 443     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 444     if (!impl) {
 445         throwOutOfMemoryError(exec, scope);
 446         return nullptr;
 447     }
 448 
 449     int maxCount = std::max(rangeCount, separatorCount);
 450     Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 451     for (int i = 0; i &lt; maxCount; i++) {
 452         if (i &lt; rangeCount) {
 453             if (int srcLen = substringRanges[i].length) {
 454                 if (source.is8Bit())
 455                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), source.characters8() + substringRanges[i].position, srcLen);
 456                 else
 457                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), source.characters16() + substringRanges[i].position, srcLen);
 458                 bufferPos += srcLen;
 459             }
 460         }
 461         if (i &lt; separatorCount) {
 462             if (int sepLen = separators[i].length()) {
 463                 if (separators[i].is8Bit())
 464                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters8(), sepLen);
 465                 else
 466                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters16(), sepLen);
 467                 bufferPos += sepLen;
 468             }
 469         }
 470     }
 471 
<span class="line-modified"> 472     RELEASE_AND_RETURN(scope, jsString(exec, WTFMove(impl)));</span>
 473 }
 474 
 475 #define OUT_OF_MEMORY(exec__, scope__) \
 476     do { \
 477         throwOutOfMemoryError(exec__, scope__); \
 478         return nullptr; \
 479     } while (false)
 480 
 481 static ALWAYS_INLINE JSString* removeUsingRegExpSearch(VM&amp; vm, ExecState* exec, JSString* string, const String&amp; source, RegExp* regExp)
 482 {
 483     auto scope = DECLARE_THROW_SCOPE(vm);
 484     SuperSamplerScope superSamplerScope(false);
 485 
 486     size_t lastIndex = 0;
 487     unsigned startPosition = 0;
 488 
 489     Vector&lt;StringRange, 16&gt; sourceRanges;
 490     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 491     unsigned sourceLen = source.length();
 492 
</pre>
<hr />
<pre>
 510                 break;
 511         }
 512     }
 513 
 514     if (!lastIndex)
 515         return string;
 516 
 517     if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
 518         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
 519             OUT_OF_MEMORY(exec, scope);
 520     }
 521     RELEASE_AND_RETURN(scope, jsSpliceSubstrings(exec, string, source, sourceRanges.data(), sourceRanges.size()));
 522 }
 523 
 524 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(
 525     VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, CallData&amp; callData,
 526     CallType callType, String&amp; replacementString, JSValue replaceValue)
 527 {
 528     auto scope = DECLARE_THROW_SCOPE(vm);
 529 
<span class="line-modified"> 530     const String&amp; source = string-&gt;value(exec);</span>

 531     unsigned sourceLen = source.length();
 532     RETURN_IF_EXCEPTION(scope, nullptr);
 533     RegExpObject* regExpObject = jsCast&lt;RegExpObject*&gt;(searchValue);
 534     RegExp* regExp = regExpObject-&gt;regExp();
 535     bool global = regExp-&gt;global();
 536     bool hasNamedCaptures = regExp-&gt;hasNamedCaptures();
 537 
 538     if (global) {
 539         // ES5.1 15.5.4.10 step 8.a.
 540         regExpObject-&gt;setLastIndex(exec, 0);
 541         RETURN_IF_EXCEPTION(scope, nullptr);
 542 
 543         if (callType == CallType::None &amp;&amp; !replacementString.length())
 544             RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, exec, string, source, regExp));
 545     }
 546 
 547     // FIXME: This is wrong because we may be called directly from the FTL.
 548     // https://bugs.webkit.org/show_bug.cgi?id=154874
 549     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 550 
</pre>
<hr />
<pre>
 574                 OUT_OF_MEMORY(exec, scope);
 575 
 576             cachedCall.clearArguments();
 577 
 578             JSObject* groups = nullptr;
 579 
 580             if (hasNamedCaptures) {
 581                 JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 582                 groups = JSFinalObject::create(vm, JSFinalObject::createStructure(vm, globalObject, globalObject-&gt;objectPrototype(), 0));
 583             }
 584 
 585             for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
 586                 int matchStart = ovector[i * 2];
 587                 int matchLen = ovector[i * 2 + 1] - matchStart;
 588 
 589                 JSValue patternValue;
 590 
 591                 if (matchStart &lt; 0)
 592                     patternValue = jsUndefined();
 593                 else
<span class="line-modified"> 594                     patternValue = jsSubstring(&amp;vm, source, matchStart, matchLen);</span>
 595 
 596                 cachedCall.appendArgument(patternValue);
 597 
 598                 if (i &amp;&amp; hasNamedCaptures) {
 599                     String groupName = regExp-&gt;getCaptureGroupName(i);
 600                     if (!groupName.isEmpty())
<span class="line-modified"> 601                         groups-&gt;putDirect(vm, Identifier::fromString(&amp;vm, groupName), patternValue);</span>
 602                 }
 603             }
 604 
 605             cachedCall.appendArgument(jsNumber(result.start));
 606             cachedCall.appendArgument(string);
 607             if (hasNamedCaptures)
 608                 cachedCall.appendArgument(groups);
 609 
 610             cachedCall.setThis(jsUndefined());
 611             if (UNLIKELY(cachedCall.hasOverflowedArguments())) {
 612                 throwOutOfMemoryError(exec, scope);
 613                 return nullptr;
 614             }
 615 
 616             JSValue jsResult = cachedCall.call();
 617             RETURN_IF_EXCEPTION(scope, nullptr);
 618             replacements.append(jsResult.toWTFString(exec));
 619             RETURN_IF_EXCEPTION(scope, nullptr);
 620 
 621             lastIndex = result.end;
</pre>
<hr />
<pre>
 639             if (callType != CallType::None) {
 640                 if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
 641                     OUT_OF_MEMORY(exec, scope);
 642 
 643                 MarkedArgumentBuffer args;
 644                 JSObject* groups = nullptr;
 645 
 646                 if (hasNamedCaptures) {
 647                     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 648                     groups = JSFinalObject::create(vm, JSFinalObject::createStructure(vm, globalObject, globalObject-&gt;objectPrototype(), 0));
 649                 }
 650 
 651                 for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
 652                     int matchStart = ovector[i * 2];
 653                     int matchLen = ovector[i * 2 + 1] - matchStart;
 654 
 655                     JSValue patternValue;
 656 
 657                     if (matchStart &lt; 0)
 658                         patternValue = jsUndefined();
<span class="line-modified"> 659                     else</span>
<span class="line-modified"> 660                         patternValue = jsSubstring(exec, source, matchStart, matchLen);</span>


 661 
 662                     args.append(patternValue);
 663 
 664                     if (i &amp;&amp; hasNamedCaptures) {
 665                         String groupName = regExp-&gt;getCaptureGroupName(i);
 666                         if (!groupName.isEmpty())
<span class="line-modified"> 667                             groups-&gt;putDirect(vm, Identifier::fromString(&amp;vm, groupName), patternValue);</span>
 668                     }
 669 
 670                 }
 671 
 672                 args.append(jsNumber(result.start));
 673                 args.append(string);
 674                 if (hasNamedCaptures)
 675                     args.append(groups);
 676                 if (UNLIKELY(args.hasOverflowed())) {
 677                     throwOutOfMemoryError(exec, scope);
 678                     return nullptr;
 679                 }
 680 
 681                 JSValue replacement = call(exec, replaceValue, callType, callData, jsUndefined(), args);
 682                 RETURN_IF_EXCEPTION(scope, nullptr);
 683                 String replacementString = replacement.toWTFString(exec);
 684                 RETURN_IF_EXCEPTION(scope, nullptr);
 685                 replacements.append(replacementString);
 686                 RETURN_IF_EXCEPTION(scope, nullptr);
 687             } else {
</pre>
<hr />
<pre>
 710                 if (startPosition &gt; sourceLen)
 711                     break;
 712             }
 713         } while (global);
 714     }
 715 
 716     if (!lastIndex &amp;&amp; replacements.isEmpty())
 717         return string;
 718 
 719     if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
 720         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
 721             OUT_OF_MEMORY(exec, scope);
 722     }
 723     RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(exec, string, source, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));
 724 }
 725 
 726 JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpEmptyStr(
 727     ExecState* exec, JSString* thisValue, RegExpObject* searchValue)
 728 {
 729     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 730     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 731     auto scope = DECLARE_THROW_SCOPE(vm);
 732 
 733     RegExp* regExp = searchValue-&gt;regExp();
 734     if (regExp-&gt;global()) {
 735         // ES5.1 15.5.4.10 step 8.a.
 736         searchValue-&gt;setLastIndex(exec, 0);
 737         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 738         const String&amp; source = thisValue-&gt;value(exec);</span>
 739         RETURN_IF_EXCEPTION(scope, nullptr);
 740         RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, exec, thisValue, source, regExp));
 741     }
 742 
 743     CallData callData;
 744     String replacementString = emptyString();
 745     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
 746         vm, exec, thisValue, searchValue, callData, CallType::None, replacementString, JSValue()));
 747 }
 748 
 749 JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpString(
 750     ExecState* exec, JSString* thisValue, RegExpObject* searchValue, JSString* replaceString)
 751 {
 752     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 753     NativeCallFrameTracer tracer(&amp;vm, exec);</span>

 754 
 755     CallData callData;
 756     String replacementString = replaceString-&gt;value(exec);
<span class="line-modified"> 757     return replaceUsingRegExpSearch(</span>
<span class="line-modified"> 758         vm, exec, thisValue, searchValue, callData, CallType::None, replacementString, replaceString);</span>

 759 }
 760 
 761 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, JSValue replaceValue)
 762 {
 763     auto scope = DECLARE_THROW_SCOPE(vm);
 764 
 765     String replacementString;
 766     CallData callData;
 767     CallType callType = getCallData(vm, replaceValue, callData);
 768     if (callType == CallType::None) {
 769         replacementString = replaceValue.toWTFString(exec);
 770         RETURN_IF_EXCEPTION(scope, nullptr);
 771     }
 772 
 773     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
 774         vm, exec, string, searchValue, callData, callType, replacementString, replaceValue));
 775 }
 776 
 777 static ALWAYS_INLINE JSString* replaceUsingStringSearch(VM&amp; vm, ExecState* exec, JSString* jsString, JSValue searchValue, JSValue replaceValue)
 778 {
 779     auto scope = DECLARE_THROW_SCOPE(vm);
 780 
<span class="line-modified"> 781     const String&amp; string = jsString-&gt;value(exec);</span>
 782     RETURN_IF_EXCEPTION(scope, nullptr);
 783     String searchString = searchValue.toWTFString(exec);
 784     RETURN_IF_EXCEPTION(scope, nullptr);
 785 
 786     size_t matchStart = string.find(searchString);
 787 
 788     if (matchStart == notFound)
 789         return jsString;
 790 
 791     CallData callData;
 792     CallType callType = getCallData(vm, replaceValue, callData);
 793     if (callType != CallType::None) {
 794         MarkedArgumentBuffer args;
<span class="line-modified"> 795         args.append(jsSubstring(exec, string, matchStart, searchString.impl()-&gt;length()));</span>


 796         args.append(jsNumber(matchStart));
 797         args.append(jsString);
 798         ASSERT(!args.hasOverflowed());
 799         replaceValue = call(exec, replaceValue, callType, callData, jsUndefined(), args);
 800         RETURN_IF_EXCEPTION(scope, nullptr);
 801     }
 802 
 803     String replaceString = replaceValue.toWTFString(exec);
 804     RETURN_IF_EXCEPTION(scope, nullptr);
 805 
 806     StringImpl* stringImpl = string.impl();
 807     String leftPart(StringImpl::createSubstringSharingImpl(*stringImpl, 0, matchStart));
 808 
 809     size_t matchEnd = matchStart + searchString.impl()-&gt;length();
 810     int ovector[2] = { static_cast&lt;int&gt;(matchStart),  static_cast&lt;int&gt;(matchEnd)};
 811     String middlePart;
 812     if (callType != CallType::None)
 813         middlePart = replaceString;
 814     else {
 815         StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
</pre>
<hr />
<pre>
 850     ASSERT(exec-&gt;uncheckedArgument(0).isString());
 851     JSString* string = asString(exec-&gt;uncheckedArgument(0));
 852     ASSERT(string-&gt;length() == 1);
 853 
 854     JSValue repeatCountValue = exec-&gt;uncheckedArgument(1);
 855     RELEASE_ASSERT(repeatCountValue.isNumber());
 856     int32_t repeatCount;
 857     double value = repeatCountValue.asNumber();
 858     if (value &gt; JSString::MaxLength)
 859         return JSValue::encode(throwOutOfMemoryError(exec, scope));
 860     repeatCount = static_cast&lt;int32_t&gt;(value);
 861     ASSERT(repeatCount &gt;= 0);
 862     ASSERT(!repeatCountValue.isDouble() || repeatCountValue.asDouble() == repeatCount);
 863 
 864     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);
 865     StringView view = viewWithString.view;
 866     ASSERT(view.length() == 1);
 867     scope.assertNoException();
 868     UChar character = view[0];
 869     scope.release();
<span class="line-modified"> 870     if (!(character &amp; ~0xff))</span>
 871         return JSValue::encode(repeatCharacter(*exec, static_cast&lt;LChar&gt;(character), repeatCount));
 872     return JSValue::encode(repeatCharacter(*exec, character, repeatCount));
 873 }
 874 
 875 ALWAYS_INLINE JSString* replace(
 876     VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, JSValue replaceValue)
 877 {
 878     if (searchValue.inherits&lt;RegExpObject&gt;(vm))
 879         return replaceUsingRegExpSearch(vm, exec, string, searchValue, replaceValue);
 880     return replaceUsingStringSearch(vm, exec, string, searchValue, replaceValue);
 881 }
 882 
 883 ALWAYS_INLINE JSString* replace(
 884     VM&amp; vm, ExecState* exec, JSValue thisValue, JSValue searchValue, JSValue replaceValue)
 885 {
 886     auto scope = DECLARE_THROW_SCOPE(vm);
 887 
 888     if (!checkObjectCoercible(thisValue)) {
 889         throwVMTypeError(exec, scope);
 890         return nullptr;
</pre>
<hr />
<pre>
 908 
 909     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingRegExpSearch(vm, exec, string, searchValue, exec-&gt;argument(1))));
 910 }
 911 
 912 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(ExecState* exec)
 913 {
 914     VM&amp; vm = exec-&gt;vm();
 915     auto scope = DECLARE_THROW_SCOPE(vm);
 916 
 917     JSString* string = exec-&gt;thisValue().toString(exec);
 918     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 919 
 920     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, exec, string, exec-&gt;argument(0), exec-&gt;argument(1))));
 921 }
 922 
 923 JSCell* JIT_OPERATION operationStringProtoFuncReplaceGeneric(
 924     ExecState* exec, EncodedJSValue thisValue, EncodedJSValue searchValue,
 925     EncodedJSValue replaceValue)
 926 {
 927     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 928     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 929 
 930     return replace(
 931         vm, exec, JSValue::decode(thisValue), JSValue::decode(searchValue),
 932         JSValue::decode(replaceValue));
 933 }
 934 
 935 EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(ExecState* exec)
 936 {
 937     VM&amp; vm = exec-&gt;vm();
 938     auto scope = DECLARE_THROW_SCOPE(vm);
 939 
 940     JSValue thisValue = exec-&gt;thisValue();
 941     // Also used for valueOf.
 942 
 943     if (thisValue.isString())
 944         return JSValue::encode(thisValue);
 945 
 946     auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, thisValue);
 947     if (stringObject)
 948         return JSValue::encode(stringObject-&gt;internalValue());
 949 
 950     return throwVMTypeError(exec, scope);
 951 }
 952 
 953 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(ExecState* exec)
 954 {
 955     VM&amp; vm = exec-&gt;vm();
 956     auto scope = DECLARE_THROW_SCOPE(vm);
 957 
 958     JSValue thisValue = exec-&gt;thisValue();
 959     if (!checkObjectCoercible(thisValue))
 960         return throwVMTypeError(exec, scope);
 961     auto viewWithString = thisValue.toString(exec)-&gt;viewWithUnderlyingString(exec);
 962     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 963     StringView view = viewWithString.view;
 964     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 965     JSValue a0 = exec-&gt;argument(0);
 966     if (a0.isUInt32()) {
 967         uint32_t i = a0.asUInt32();
 968         if (i &lt; view.length())
<span class="line-modified"> 969             return JSValue::encode(jsSingleCharacterString(exec, view[i]));</span>
<span class="line-modified"> 970         return JSValue::encode(jsEmptyString(exec));</span>
 971     }
 972     double dpos = a0.toInteger(exec);
 973     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 974     if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
<span class="line-modified"> 975         return JSValue::encode(jsSingleCharacterString(exec, view[static_cast&lt;unsigned&gt;(dpos)]));</span>
<span class="line-modified"> 976     return JSValue::encode(jsEmptyString(exec));</span>
 977 }
 978 
 979 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(ExecState* exec)
 980 {
 981     VM&amp; vm = exec-&gt;vm();
 982     auto scope = DECLARE_THROW_SCOPE(vm);
 983 
 984     JSValue thisValue = exec-&gt;thisValue();
 985     if (!checkObjectCoercible(thisValue))
 986         return throwVMTypeError(exec, scope);
 987     auto viewWithString = thisValue.toString(exec)-&gt;viewWithUnderlyingString(exec);
 988     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 989     StringView view = viewWithString.view;
 990     JSValue a0 = exec-&gt;argument(0);
 991     if (a0.isUInt32()) {
 992         uint32_t i = a0.asUInt32();
 993         if (i &lt; view.length())
 994             return JSValue::encode(jsNumber(view[i]));
 995         return JSValue::encode(jsNaN());
 996     }
</pre>
<hr />
<pre>
1103     JSString* thisJSString = thisValue.toString(exec);
1104     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1105     unsigned len = thisJSString-&gt;length();
1106     JSString* otherJSString = a0.toString(exec);
1107     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1108 
1109     double dpos = a1.toIntegerPreserveNaN(exec);
1110     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1111     unsigned startPosition;
1112     if (dpos &lt; 0)
1113         startPosition = 0;
1114     else if (!(dpos &lt;= len)) // true for NaN
1115         startPosition = len;
1116     else
1117         startPosition = static_cast&lt;unsigned&gt;(dpos);
1118 
1119     if (len &lt; otherJSString-&gt;length())
1120         return JSValue::encode(jsNumber(-1));
1121 
1122     String thisString = thisJSString-&gt;value(exec);

1123     String otherString = otherJSString-&gt;value(exec);

1124     size_t result;
1125     if (!startPosition)
1126         result = thisString.startsWith(otherString) ? 0 : notFound;
1127     else
1128         result = thisString.reverseFind(otherString, startPosition);
1129     if (result == notFound)
1130         return JSValue::encode(jsNumber(-1));
1131     return JSValue::encode(jsNumber(result));
1132 }
1133 
1134 EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(ExecState* exec)
1135 {
1136     VM&amp; vm = exec-&gt;vm();
1137     auto scope = DECLARE_THROW_SCOPE(vm);
1138 
1139     JSValue thisValue = exec-&gt;thisValue();
1140     if (!checkObjectCoercible(thisValue))
1141         return throwVMTypeError(exec, scope);
<span class="line-modified">1142     String s = thisValue.toWTFString(exec);</span>
1143     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1144 
1145     JSValue a0 = exec-&gt;argument(0);
1146     JSValue a1 = exec-&gt;argument(1);
1147 
<span class="line-modified">1148     int len = s.length();</span>
<span class="line-modified">1149     RELEASE_ASSERT(len &gt;= 0);</span>
1150 
1151     // The arg processing is very much like ArrayProtoFunc::Slice
1152     double start = a0.toInteger(exec);
1153     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1154     double end = a1.isUndefined() ? len : a1.toInteger(exec);</span>
1155     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1156     scope.release();</span>
<span class="line-removed">1157     return JSValue::encode(stringSlice(exec, WTFMove(s), start, end));</span>
1158 }
1159 
1160 // Return true in case of early return (resultLength got to limitLength).
1161 template&lt;typename CharacterType&gt;
1162 static ALWAYS_INLINE bool splitStringByOneCharacterImpl(ExecState* exec, JSArray* result, JSValue originalValue, const String&amp; input, StringImpl* string, UChar separatorCharacter, size_t&amp; position, unsigned&amp; resultLength, unsigned limitLength)
1163 {
1164     VM&amp; vm = exec-&gt;vm();
1165     auto scope = DECLARE_THROW_SCOPE(vm);
1166 
1167     // 12. Let q = p.
1168     size_t matchPosition;
1169     const CharacterType* characters = string-&gt;characters&lt;CharacterType&gt;();
1170     // 13. Repeat, while q != s
1171     //   a. Call SplitMatch(S, q, R) and let z be its MatchResult result.
1172     //   b. If z is failure, then let q = q+1.
1173     //   c. Else, z is not failure
1174     while ((matchPosition = WTF::find(characters, string-&gt;length(), separatorCharacter, position)) != notFound) {
1175         // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1176         //    through q (exclusive).
1177         // 2. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA),
1178         //    Property Descriptor {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
<span class="line-modified">1179         result-&gt;putDirectIndex(exec, resultLength, jsSubstring(exec, originalValue, input, position, matchPosition - position));</span>


1180         RETURN_IF_EXCEPTION(scope, false);
1181         // 3. Increment lengthA by 1.
1182         // 4. If lengthA == lim, return A.
1183         if (++resultLength == limitLength)
1184             return true;
1185 
1186         // 5. Let p = e.
1187         // 8. Let q = p.
1188         position = matchPosition + 1;
1189     }
1190     return false;
1191 }
1192 
1193 // ES 21.1.3.17 String.prototype.split(separator, limit)
1194 EncodedJSValue JSC_HOST_CALL stringProtoFuncSplitFast(ExecState* exec)
1195 {
1196     VM&amp; vm = exec-&gt;vm();
1197     auto scope = DECLARE_THROW_SCOPE(vm);
1198     JSValue thisValue = exec-&gt;thisValue();
1199     ASSERT(checkObjectCoercible(thisValue));
</pre>
<hr />
<pre>
1242     // 12. If s == 0, then
1243     if (input.isEmpty()) {
1244         // a. Let z be SplitMatch(S, 0, R) where S is input, R is separator.
1245         // b. If z is not false, return A.
1246         // c. Call CreateDataProperty(A, &quot;0&quot;, S).
1247         // d. Return A.
1248         if (!separator.isEmpty()) {
1249             scope.release();
1250             result-&gt;putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));
1251         }
1252         return JSValue::encode(result);
1253     }
1254 
1255     // Optimized case for splitting on the empty string.
1256     if (separator.isEmpty()) {
1257         limit = std::min(limit, input.length());
1258         // Zero limt/input length handled in steps 9/11 respectively, above.
1259         ASSERT(limit);
1260 
1261         do {
<span class="line-modified">1262             result-&gt;putDirectIndex(exec, position, jsSingleCharacterString(exec, input[position]));</span>
1263             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1264         } while (++position &lt; limit);
1265 
1266         return JSValue::encode(result);
1267     }
1268 
1269     // 3 cases:
1270     // -separator length == 1, 8 bits
1271     // -separator length == 1, 16 bits
1272     // -separator length &gt; 1
1273     StringImpl* stringImpl = input.impl();
1274     StringImpl* separatorImpl = separator.impl();
1275     size_t separatorLength = separatorImpl-&gt;length();
1276 
1277     if (separatorLength == 1) {
1278         UChar separatorCharacter;
1279         if (separatorImpl-&gt;is8Bit())
1280             separatorCharacter = separatorImpl-&gt;characters8()[0];
1281         else
1282             separatorCharacter = separatorImpl-&gt;characters16()[0];
1283 
1284         if (stringImpl-&gt;is8Bit()) {
1285             if (splitStringByOneCharacterImpl&lt;LChar&gt;(exec, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))
1286                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
1287         } else {
1288             if (splitStringByOneCharacterImpl&lt;UChar&gt;(exec, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))
1289                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
1290         }
1291         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1292     } else {
1293         // 13. Let q = p.
1294         size_t matchPosition;
1295         // 14. Repeat, while q != s
1296         //   a. let e be SplitMatch(S, q, R).
1297         //   b. If e is failure, then let q = q+1.
1298         //   c. Else, e is an integer index &lt;= s.
1299         while ((matchPosition = stringImpl-&gt;find(separatorImpl, position)) != notFound) {
1300             // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1301             //    through q (exclusive).
1302             // 2. Call CreateDataProperty(A, ToString(lengthA), T).
<span class="line-modified">1303             result-&gt;putDirectIndex(exec, resultLength, jsSubstring(exec, thisValue, input, position, matchPosition - position));</span>
<span class="line-modified">1304             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>


1305             // 3. Increment lengthA by 1.
1306             // 4. If lengthA == lim, return A.
1307             if (++resultLength == limit)
1308                 return JSValue::encode(result);
1309 
1310             // 5. Let p = e.
1311             // 6. Let q = p.
1312             position = matchPosition + separator.length();
1313         }
1314     }
1315 
1316     // 15. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1317     //     through s (exclusive).
1318     // 16. Call CreateDataProperty(A, ToString(lengthA), T).


1319     scope.release();
<span class="line-modified">1320     result-&gt;putDirectIndex(exec, resultLength++, jsSubstring(exec, thisValue, input, position, input.length() - position));</span>
1321 
1322     // 17. Return A.
1323     return JSValue::encode(result);
1324 }
1325 
1326 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(ExecState* exec)
1327 {
1328     VM&amp; vm = exec-&gt;vm();
1329     auto scope = DECLARE_THROW_SCOPE(vm);
1330 
1331     JSValue thisValue = exec-&gt;thisValue();
1332     if (!checkObjectCoercible(thisValue))
1333         return throwVMTypeError(exec, scope);
1334     unsigned len;
1335     JSString* jsString = 0;
1336     String uString;
1337     if (thisValue.isString()) {
1338         jsString = asString(thisValue);
1339         len = jsString-&gt;length();
1340     } else {
1341         uString = thisValue.toWTFString(exec);
1342         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1343         len = uString.length();
1344     }
1345 
1346     JSValue a0 = exec-&gt;argument(0);
1347     JSValue a1 = exec-&gt;argument(1);
1348 
1349     double start = a0.toInteger(exec);
1350     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1351     double length = a1.isUndefined() ? len : a1.toInteger(exec);
1352     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1353     if (start &gt;= len || length &lt;= 0)
<span class="line-modified">1354         return JSValue::encode(jsEmptyString(exec));</span>
1355     if (start &lt; 0) {
1356         start += len;
1357         if (start &lt; 0)
1358             start = 0;
1359     }
1360     if (start + length &gt; len)
1361         length = len - start;
1362     unsigned substringStart = static_cast&lt;unsigned&gt;(start);
1363     unsigned substringLength = static_cast&lt;unsigned&gt;(length);

1364     if (jsString)
1365         return JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength));
<span class="line-modified">1366     return JSValue::encode(jsSubstring(exec, uString, substringStart, substringLength));</span>
1367 }
1368 
1369 EncodedJSValue JSC_HOST_CALL builtinStringSubstrInternal(ExecState* exec)
1370 {
1371     // @substrInternal should not have any observable side effects (e.g. it should not call
1372     // GetMethod(..., @@toPrimitive) on the thisValue).
1373 
1374     // It is ok to use the default stringProtoFuncSubstr as the implementation of
1375     // @substrInternal because @substrInternal will only be called by builtins, which will
1376     // guarantee that we only pass it a string thisValue. As a result, stringProtoFuncSubstr
1377     // will not need to call toString() on the thisValue, and there will be no observable
1378     // side-effects.
1379     ASSERT(exec-&gt;thisValue().isString());
1380     return stringProtoFuncSubstr(exec);
1381 }
1382 
1383 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(ExecState* exec)
1384 {
1385     VM&amp; vm = exec-&gt;vm();
1386     auto scope = DECLARE_THROW_SCOPE(vm);
</pre>
<hr />
<pre>
1404         start = 0;
1405     else if (start &gt; len)
1406         start = len;
1407     if (a1.isUndefined())
1408         end = len;
1409     else {
1410         end = a1.toNumber(exec);
1411         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1412         if (!(end &gt;= 0)) // check for negative values or NaN
1413             end = 0;
1414         else if (end &gt; len)
1415             end = len;
1416     }
1417     if (start &gt; end) {
1418         double temp = end;
1419         end = start;
1420         start = temp;
1421     }
1422     unsigned substringStart = static_cast&lt;unsigned&gt;(start);
1423     unsigned substringLength = static_cast&lt;unsigned&gt;(end) - substringStart;
<span class="line-modified">1424     return JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength));</span>
1425 }
1426 
1427 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(ExecState* exec)
1428 {
1429     VM&amp; vm = exec-&gt;vm();
1430     auto scope = DECLARE_THROW_SCOPE(vm);
1431 
1432     JSValue thisValue = exec-&gt;thisValue();
1433     if (!checkObjectCoercible(thisValue))
1434         return throwVMTypeError(exec, scope);
1435     JSString* sVal = thisValue.toString(exec);
1436     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1437     const String&amp; s = sVal-&gt;value(exec);</span>

1438     String lowercasedString = s.convertToLowercaseWithoutLocale();
1439     if (lowercasedString.impl() == s.impl())
1440         return JSValue::encode(sVal);
<span class="line-modified">1441     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(exec, lowercasedString)));</span>
1442 }
1443 
1444 EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(ExecState* exec)
1445 {
1446     VM&amp; vm = exec-&gt;vm();
1447     auto scope = DECLARE_THROW_SCOPE(vm);
1448 
1449     JSValue thisValue = exec-&gt;thisValue();
1450     if (!checkObjectCoercible(thisValue))
1451         return throwVMTypeError(exec, scope);
1452     JSString* sVal = thisValue.toString(exec);
1453     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1454     const String&amp; s = sVal-&gt;value(exec);</span>

1455     String uppercasedString = s.convertToUppercaseWithoutLocale();
1456     if (uppercasedString.impl() == s.impl())
1457         return JSValue::encode(sVal);
<span class="line-modified">1458     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(exec, uppercasedString)));</span>
1459 }
1460 
1461 EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(ExecState* exec)
1462 {
1463     // 13.1.1 String.prototype.localeCompare (that [, locales [, options ]]) (ECMA-402 2.0)
1464     // http://ecma-international.org/publications/standards/Ecma-402.htm
1465 
1466     VM&amp; vm = exec-&gt;vm();
1467     auto scope = DECLARE_THROW_SCOPE(vm);
1468 
1469     // 1. Let O be RequireObjectCoercible(this value).
1470     JSValue thisValue = exec-&gt;thisValue();
1471     if (!checkObjectCoercible(thisValue))
1472         return throwVMTypeError(exec, scope, &quot;String.prototype.localeCompare requires that |this| not be null or undefined&quot;_s);
1473 
1474     // 2. Let S be ToString(O).
1475     // 3. ReturnIfAbrupt(S).
1476     String string = thisValue.toWTFString(exec);
1477     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1478 
1479     // 4. Let That be ToString(that).
1480     // 5. ReturnIfAbrupt(That).
1481     JSValue thatValue = exec-&gt;argument(0);
1482     String that = thatValue.toWTFString(exec);
1483     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1484 
1485 #if ENABLE(INTL)
1486     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1487     JSValue locales = exec-&gt;argument(1);
1488     JSValue options = exec-&gt;argument(2);
1489     IntlCollator* collator = nullptr;
1490     if (locales.isUndefined() &amp;&amp; options.isUndefined()) {
1491         collator = globalObject-&gt;defaultCollator(exec);
<span class="line-modified">1492     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
1493     } else {
1494         collator = IntlCollator::create(vm, globalObject-&gt;collatorStructure());
1495         collator-&gt;initializeCollator(*exec, locales, options);
1496         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1497     }
1498     RELEASE_AND_RETURN(scope, JSValue::encode(collator-&gt;compareStrings(*exec, string, that)));
1499 #else
1500     return JSValue::encode(jsNumber(Collator().collate(string, that)));
1501 #endif
1502 }
1503 
1504 #if ENABLE(INTL)
1505 static EncodedJSValue toLocaleCase(ExecState* state, int32_t (*convertCase)(UChar*, int32_t, const UChar*, int32_t, const char*, UErrorCode*))
1506 {
1507     VM&amp; vm = state-&gt;vm();
1508     auto scope = DECLARE_THROW_SCOPE(vm);
1509 
1510     // 1. Let O be RequireObjectCoercible(this value).
1511     JSValue thisValue = state-&gt;thisValue();
1512     if (!checkObjectCoercible(thisValue))
</pre>
<hr />
<pre>
1566 
1567     // Most strings lower/upper case will be the same size as original, so try that first.
1568     UErrorCode error(U_ZERO_ERROR);
1569     Vector&lt;UChar&gt; buffer(viewLength);
1570     String lower;
1571     const int32_t resultLength = convertCase(buffer.data(), viewLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
1572     if (U_SUCCESS(error))
1573         lower = String(buffer.data(), resultLength);
1574     else if (error == U_BUFFER_OVERFLOW_ERROR) {
1575         // Converted case needs more space than original. Try again.
1576         UErrorCode error(U_ZERO_ERROR);
1577         Vector&lt;UChar&gt; buffer(resultLength);
1578         convertCase(buffer.data(), resultLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
1579         if (U_FAILURE(error))
1580             return throwVMTypeError(state, scope, u_errorName(error));
1581         lower = String(buffer.data(), resultLength);
1582     } else
1583         return throwVMTypeError(state, scope, u_errorName(error));
1584 
1585     // 18. Return L.
<span class="line-modified">1586     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(state, lower)));</span>
1587 }
1588 
1589 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(ExecState* state)
1590 {
1591     // 13.1.2 String.prototype.toLocaleLowerCase ([locales])
1592     // http://ecma-international.org/publications/standards/Ecma-402.htm
1593     return toLocaleCase(state, u_strToLower);
1594 }
1595 
1596 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(ExecState* state)
1597 {
1598     // 13.1.3 String.prototype.toLocaleUpperCase ([locales])
1599     // http://ecma-international.org/publications/standards/Ecma-402.htm
1600     // This function interprets a string value as a sequence of code points, as described in ES2015, 6.1.4. This function behaves in exactly the same way as String.prototype.toLocaleLowerCase, except that characters are mapped to their uppercase equivalents as specified in the Unicode character database.
1601     return toLocaleCase(state, u_strToUpper);
1602 }
1603 #endif // ENABLE(INTL)
1604 
1605 enum {
1606     TrimStart = 1,
</pre>
<hr />
<pre>
1615     if (!checkObjectCoercible(thisValue))
1616         return throwTypeError(exec, scope);
1617     String str = thisValue.toWTFString(exec);
1618     RETURN_IF_EXCEPTION(scope, { });
1619 
1620     unsigned left = 0;
1621     if (trimKind &amp; TrimStart) {
1622         while (left &lt; str.length() &amp;&amp; isStrWhiteSpace(str[left]))
1623             left++;
1624     }
1625     unsigned right = str.length();
1626     if (trimKind &amp; TrimEnd) {
1627         while (right &gt; left &amp;&amp; isStrWhiteSpace(str[right - 1]))
1628             right--;
1629     }
1630 
1631     // Don&#39;t gc allocate a new string if we don&#39;t have to.
1632     if (left == 0 &amp;&amp; right == str.length() &amp;&amp; thisValue.isString())
1633         return thisValue;
1634 
<span class="line-modified">1635     RELEASE_AND_RETURN(scope, jsString(exec, str.substringSharingImpl(left, right - left)));</span>
1636 }
1637 
1638 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(ExecState* exec)
1639 {
1640     JSValue thisValue = exec-&gt;thisValue();
1641     return JSValue::encode(trimString(exec, thisValue, TrimStart | TrimEnd));
1642 }
1643 
1644 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(ExecState* exec)
1645 {
1646     JSValue thisValue = exec-&gt;thisValue();
1647     return JSValue::encode(trimString(exec, thisValue, TrimStart));
1648 }
1649 
1650 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(ExecState* exec)
1651 {
1652     JSValue thisValue = exec-&gt;thisValue();
1653     return JSValue::encode(trimString(exec, thisValue, TrimEnd));
1654 }
1655 
</pre>
<hr />
<pre>
1866     auto characters = view.upconvertedCharacters();
1867 
1868     UErrorCode status = U_ZERO_ERROR;
1869     UBool isNormalized = unorm2_isNormalized(normalizer, characters, view.length(), &amp;status);
1870     ASSERT(U_SUCCESS(status));
1871     if (isNormalized)
1872         RELEASE_AND_RETURN(scope, string);
1873 
1874     int32_t normalizedStringLength = unorm2_normalize(normalizer, characters, view.length(), nullptr, 0, &amp;status);
1875     ASSERT(status == U_BUFFER_OVERFLOW_ERROR);
1876 
1877     UChar* buffer;
1878     auto result = StringImpl::tryCreateUninitialized(normalizedStringLength, buffer);
1879     if (!result)
1880         return throwOutOfMemoryError(exec, scope);
1881 
1882     status = U_ZERO_ERROR;
1883     unorm2_normalize(normalizer, characters, view.length(), buffer, normalizedStringLength, &amp;status);
1884     ASSERT(U_SUCCESS(status));
1885 
<span class="line-modified">1886     RELEASE_AND_RETURN(scope, jsString(&amp;vm, WTFMove(result)));</span>
1887 }
1888 
1889 EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(ExecState* exec)
1890 {
1891     VM&amp; vm = exec-&gt;vm();
1892     auto scope = DECLARE_THROW_SCOPE(vm);
1893 
1894     JSValue thisValue = exec-&gt;thisValue();
1895     if (!checkObjectCoercible(thisValue))
1896         return throwVMTypeError(exec, scope);
1897     JSString* string = thisValue.toString(exec);
1898     RETURN_IF_EXCEPTION(scope, { });
1899 
1900     auto form = NormalizationForm::NFC;
1901     JSValue formValue = exec-&gt;argument(0);
1902     if (!formValue.isUndefined()) {
1903         String formString = formValue.toWTFString(exec);
1904         RETURN_IF_EXCEPTION(scope, { });
1905 
1906         if (formString == &quot;NFC&quot;)
</pre>
</td>
<td>
<hr />
<pre>
  81 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(ExecState*);
  82 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(ExecState*);
  83 EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(ExecState*);
  84 EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(ExecState*);
  85 EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(ExecState*);
  86 EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(ExecState*);
  87 EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(ExecState*);
  88 
  89 }
  90 
  91 #include &quot;StringPrototype.lut.h&quot;
  92 
  93 namespace JSC {
  94 
  95 const ClassInfo StringPrototype::s_info = { &quot;String&quot;, &amp;StringObject::s_info, &amp;stringPrototypeTable, nullptr, CREATE_METHOD_TABLE(StringPrototype) };
  96 
  97 /* Source for StringConstructor.lut.h
  98 @begin stringPrototypeTable
  99     concat    JSBuiltin    DontEnum|Function 1
 100     match     JSBuiltin    DontEnum|Function 1
<span class="line-added"> 101     matchAll  JSBuiltin    DontEnum|Function 1</span>
 102     padStart  JSBuiltin    DontEnum|Function 1
 103     padEnd    JSBuiltin    DontEnum|Function 1
 104     repeat    JSBuiltin    DontEnum|Function 1
 105     replace   JSBuiltin    DontEnum|Function 2
 106     search    JSBuiltin    DontEnum|Function 1
 107     split     JSBuiltin    DontEnum|Function 1
 108     anchor    JSBuiltin    DontEnum|Function 1
 109     big       JSBuiltin    DontEnum|Function 0
 110     bold      JSBuiltin    DontEnum|Function 0
 111     blink     JSBuiltin    DontEnum|Function 0
 112     fixed     JSBuiltin    DontEnum|Function 0
 113     fontcolor JSBuiltin    DontEnum|Function 1
 114     fontsize  JSBuiltin    DontEnum|Function 1
 115     italics   JSBuiltin    DontEnum|Function 0
 116     link      JSBuiltin    DontEnum|Function 1
 117     small     JSBuiltin    DontEnum|Function 0
 118     strike    JSBuiltin    DontEnum|Function 0
 119     sub       JSBuiltin    DontEnum|Function 0
 120     sup       JSBuiltin    DontEnum|Function 0
 121 @end
</pre>
<hr />
<pre>
 146     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substring&quot;, stringProtoFuncSubstring, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 147     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;toLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeToLowerCaseIntrinsic);
 148     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 149     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;localeCompare&quot;, stringProtoFuncLocaleCompare, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 150 #if ENABLE(INTL)
 151     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleLowerCase&quot;, stringProtoFuncToLocaleLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 152     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleUpperCase&quot;, stringProtoFuncToLocaleUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 153 #else
 154     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 155     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 156 #endif
 157     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;trim&quot;, stringProtoFuncTrim, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 158     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;startsWith&quot;, stringProtoFuncStartsWith, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 159     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;endsWith&quot;, stringProtoFuncEndsWith, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 160     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;includes&quot;, stringProtoFuncIncludes, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 161     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;normalize&quot;, stringProtoFuncNormalize, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 162     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().charCodeAtPrivateName(), stringProtoFuncCharCodeAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
 163 
 164     JSFunction* trimStartFunction = JSFunction::create(vm, globalObject, 0, &quot;trimStart&quot;_s, stringProtoFuncTrimStart, NoIntrinsic);
 165     JSFunction* trimEndFunction = JSFunction::create(vm, globalObject, 0, &quot;trimEnd&quot;_s, stringProtoFuncTrimEnd, NoIntrinsic);
<span class="line-modified"> 166     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;trimStart&quot;), trimStartFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 167     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;trimLeft&quot;), trimStartFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 168     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;trimEnd&quot;), trimEndFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 169     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;trimRight&quot;), trimEndFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 170 
 171     JSFunction* iteratorFunction = JSFunction::create(vm, globalObject, 0, &quot;[Symbol.iterator]&quot;_s, stringProtoFuncIterator, NoIntrinsic);
 172     putDirectWithoutTransition(vm, vm.propertyNames-&gt;iteratorSymbol, iteratorFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 173 
 174     // The constructor will be added later, after StringConstructor has been built
 175     putDirectWithoutTransition(vm, vm.propertyNames-&gt;length, jsNumber(0), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 176 }
 177 
 178 StringPrototype* StringPrototype::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 179 {
<span class="line-modified"> 180     JSString* empty = jsEmptyString(vm);</span>
 181     StringPrototype* prototype = new (NotNull, allocateCell&lt;StringPrototype&gt;(vm.heap)) StringPrototype(vm, structure);
 182     prototype-&gt;finishCreation(vm, globalObject, empty);
 183     return prototype;
 184 }
 185 
 186 // ------------------------------ Functions --------------------------
 187 
 188 static NEVER_INLINE void substituteBackreferencesSlow(StringBuilder&amp; result, StringView replacement, StringView source, const int* ovector, RegExp* reg, size_t i)
 189 {
 190     bool hasNamedCaptures = reg &amp;&amp; reg-&gt;hasNamedCaptures();
 191     int offset = 0;
 192     do {
 193         if (i + 1 == replacement.length())
 194             break;
 195 
 196         UChar ref = replacement[i + 1];
 197         if (ref == &#39;$&#39;) {
 198             // &quot;$$&quot; -&gt; &quot;$&quot;
 199             ++i;
 200             result.append(replacement.substring(offset, i - offset));
</pre>
<hr />
<pre>
 306     StringRange()
 307     {
 308     }
 309 
 310     int position;
 311     int length;
 312 };
 313 
 314 static ALWAYS_INLINE JSString* jsSpliceSubstrings(ExecState* exec, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount)
 315 {
 316     VM&amp; vm = exec-&gt;vm();
 317     auto scope = DECLARE_THROW_SCOPE(vm);
 318 
 319     if (rangeCount == 1) {
 320         int sourceSize = source.length();
 321         int position = substringRanges[0].position;
 322         int length = substringRanges[0].length;
 323         if (position &lt;= 0 &amp;&amp; length &gt;= sourceSize)
 324             return sourceVal;
 325         // We could call String::substringSharingImpl(), but this would result in redundant checks.
<span class="line-modified"> 326         RELEASE_AND_RETURN(scope, jsString(vm, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));</span>
 327     }
 328 
 329     // We know that the sum of substringRanges lengths cannot exceed length of
 330     // source because the substringRanges were computed from the source string
 331     // in removeUsingRegExpSearch(). Hence, totalLength cannot exceed
 332     // String::MaxLength, and therefore, cannot overflow.
 333     Checked&lt;int, AssertNoOverflow&gt; totalLength = 0;
 334     for (int i = 0; i &lt; rangeCount; i++)
 335         totalLength += substringRanges[i].length;
 336     ASSERT(totalLength &lt;= String::MaxLength);
 337 
 338     if (!totalLength)
<span class="line-modified"> 339         return jsEmptyString(vm);</span>
 340 
 341     if (source.is8Bit()) {
 342         LChar* buffer;
 343         const LChar* sourceData = source.characters8();
 344         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 345         if (!impl) {
 346             throwOutOfMemoryError(exec, scope);
 347             return nullptr;
 348         }
 349 
 350         Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 351         for (int i = 0; i &lt; rangeCount; i++) {
 352             if (int srcLen = substringRanges[i].length) {
 353                 StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 354                 bufferPos += srcLen;
 355             }
 356         }
 357 
<span class="line-modified"> 358         RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));</span>
 359     }
 360 
 361     UChar* buffer;
 362     const UChar* sourceData = source.characters16();
 363 
 364     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 365     if (!impl) {
 366         throwOutOfMemoryError(exec, scope);
 367         return nullptr;
 368     }
 369 
 370     Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 371     for (int i = 0; i &lt; rangeCount; i++) {
 372         if (int srcLen = substringRanges[i].length) {
 373             StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 374             bufferPos += srcLen;
 375         }
 376     }
 377 
<span class="line-modified"> 378     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));</span>
 379 }
 380 
 381 static ALWAYS_INLINE JSString* jsSpliceSubstringsWithSeparators(ExecState* exec, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount, const String* separators, int separatorCount)
 382 {
 383     VM&amp; vm = exec-&gt;vm();
 384     auto scope = DECLARE_THROW_SCOPE(vm);
 385 
 386     if (rangeCount == 1 &amp;&amp; separatorCount == 0) {
 387         int sourceSize = source.length();
 388         int position = substringRanges[0].position;
 389         int length = substringRanges[0].length;
 390         if (position &lt;= 0 &amp;&amp; length &gt;= sourceSize)
 391             return sourceVal;
 392         // We could call String::substringSharingImpl(), but this would result in redundant checks.
<span class="line-modified"> 393         RELEASE_AND_RETURN(scope, jsString(vm, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));</span>
 394     }
 395 
 396     Checked&lt;int, RecordOverflow&gt; totalLength = 0;
 397     bool allSeparators8Bit = true;
 398     for (int i = 0; i &lt; rangeCount; i++)
 399         totalLength += substringRanges[i].length;
 400     for (int i = 0; i &lt; separatorCount; i++) {
 401         totalLength += separators[i].length();
 402         if (separators[i].length() &amp;&amp; !separators[i].is8Bit())
 403             allSeparators8Bit = false;
 404     }
 405     if (totalLength.hasOverflowed()) {
 406         throwOutOfMemoryError(exec, scope);
 407         return nullptr;
 408     }
 409 
 410     if (!totalLength)
<span class="line-modified"> 411         return jsEmptyString(vm);</span>
 412 
 413     if (source.is8Bit() &amp;&amp; allSeparators8Bit) {
 414         LChar* buffer;
 415         const LChar* sourceData = source.characters8();
 416 
 417         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 418         if (!impl) {
 419             throwOutOfMemoryError(exec, scope);
 420             return nullptr;
 421         }
 422 
 423         int maxCount = std::max(rangeCount, separatorCount);
 424         Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 425         for (int i = 0; i &lt; maxCount; i++) {
 426             if (i &lt; rangeCount) {
 427                 if (int srcLen = substringRanges[i].length) {
 428                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 429                     bufferPos += srcLen;
 430                 }
 431             }
 432             if (i &lt; separatorCount) {
 433                 if (int sepLen = separators[i].length()) {
 434                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters8(), sepLen);
 435                     bufferPos += sepLen;
 436                 }
 437             }
 438         }
 439 
<span class="line-modified"> 440         RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));</span>
 441     }
 442 
 443     UChar* buffer;
 444     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 445     if (!impl) {
 446         throwOutOfMemoryError(exec, scope);
 447         return nullptr;
 448     }
 449 
 450     int maxCount = std::max(rangeCount, separatorCount);
 451     Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 452     for (int i = 0; i &lt; maxCount; i++) {
 453         if (i &lt; rangeCount) {
 454             if (int srcLen = substringRanges[i].length) {
 455                 if (source.is8Bit())
 456                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), source.characters8() + substringRanges[i].position, srcLen);
 457                 else
 458                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), source.characters16() + substringRanges[i].position, srcLen);
 459                 bufferPos += srcLen;
 460             }
 461         }
 462         if (i &lt; separatorCount) {
 463             if (int sepLen = separators[i].length()) {
 464                 if (separators[i].is8Bit())
 465                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters8(), sepLen);
 466                 else
 467                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters16(), sepLen);
 468                 bufferPos += sepLen;
 469             }
 470         }
 471     }
 472 
<span class="line-modified"> 473     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));</span>
 474 }
 475 
 476 #define OUT_OF_MEMORY(exec__, scope__) \
 477     do { \
 478         throwOutOfMemoryError(exec__, scope__); \
 479         return nullptr; \
 480     } while (false)
 481 
 482 static ALWAYS_INLINE JSString* removeUsingRegExpSearch(VM&amp; vm, ExecState* exec, JSString* string, const String&amp; source, RegExp* regExp)
 483 {
 484     auto scope = DECLARE_THROW_SCOPE(vm);
 485     SuperSamplerScope superSamplerScope(false);
 486 
 487     size_t lastIndex = 0;
 488     unsigned startPosition = 0;
 489 
 490     Vector&lt;StringRange, 16&gt; sourceRanges;
 491     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 492     unsigned sourceLen = source.length();
 493 
</pre>
<hr />
<pre>
 511                 break;
 512         }
 513     }
 514 
 515     if (!lastIndex)
 516         return string;
 517 
 518     if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
 519         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
 520             OUT_OF_MEMORY(exec, scope);
 521     }
 522     RELEASE_AND_RETURN(scope, jsSpliceSubstrings(exec, string, source, sourceRanges.data(), sourceRanges.size()));
 523 }
 524 
 525 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(
 526     VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, CallData&amp; callData,
 527     CallType callType, String&amp; replacementString, JSValue replaceValue)
 528 {
 529     auto scope = DECLARE_THROW_SCOPE(vm);
 530 
<span class="line-modified"> 531     String source = string-&gt;value(exec);</span>
<span class="line-added"> 532     RETURN_IF_EXCEPTION(scope, nullptr);</span>
 533     unsigned sourceLen = source.length();
 534     RETURN_IF_EXCEPTION(scope, nullptr);
 535     RegExpObject* regExpObject = jsCast&lt;RegExpObject*&gt;(searchValue);
 536     RegExp* regExp = regExpObject-&gt;regExp();
 537     bool global = regExp-&gt;global();
 538     bool hasNamedCaptures = regExp-&gt;hasNamedCaptures();
 539 
 540     if (global) {
 541         // ES5.1 15.5.4.10 step 8.a.
 542         regExpObject-&gt;setLastIndex(exec, 0);
 543         RETURN_IF_EXCEPTION(scope, nullptr);
 544 
 545         if (callType == CallType::None &amp;&amp; !replacementString.length())
 546             RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, exec, string, source, regExp));
 547     }
 548 
 549     // FIXME: This is wrong because we may be called directly from the FTL.
 550     // https://bugs.webkit.org/show_bug.cgi?id=154874
 551     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 552 
</pre>
<hr />
<pre>
 576                 OUT_OF_MEMORY(exec, scope);
 577 
 578             cachedCall.clearArguments();
 579 
 580             JSObject* groups = nullptr;
 581 
 582             if (hasNamedCaptures) {
 583                 JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 584                 groups = JSFinalObject::create(vm, JSFinalObject::createStructure(vm, globalObject, globalObject-&gt;objectPrototype(), 0));
 585             }
 586 
 587             for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
 588                 int matchStart = ovector[i * 2];
 589                 int matchLen = ovector[i * 2 + 1] - matchStart;
 590 
 591                 JSValue patternValue;
 592 
 593                 if (matchStart &lt; 0)
 594                     patternValue = jsUndefined();
 595                 else
<span class="line-modified"> 596                     patternValue = jsSubstring(vm, source, matchStart, matchLen);</span>
 597 
 598                 cachedCall.appendArgument(patternValue);
 599 
 600                 if (i &amp;&amp; hasNamedCaptures) {
 601                     String groupName = regExp-&gt;getCaptureGroupName(i);
 602                     if (!groupName.isEmpty())
<span class="line-modified"> 603                         groups-&gt;putDirect(vm, Identifier::fromString(vm, groupName), patternValue);</span>
 604                 }
 605             }
 606 
 607             cachedCall.appendArgument(jsNumber(result.start));
 608             cachedCall.appendArgument(string);
 609             if (hasNamedCaptures)
 610                 cachedCall.appendArgument(groups);
 611 
 612             cachedCall.setThis(jsUndefined());
 613             if (UNLIKELY(cachedCall.hasOverflowedArguments())) {
 614                 throwOutOfMemoryError(exec, scope);
 615                 return nullptr;
 616             }
 617 
 618             JSValue jsResult = cachedCall.call();
 619             RETURN_IF_EXCEPTION(scope, nullptr);
 620             replacements.append(jsResult.toWTFString(exec));
 621             RETURN_IF_EXCEPTION(scope, nullptr);
 622 
 623             lastIndex = result.end;
</pre>
<hr />
<pre>
 641             if (callType != CallType::None) {
 642                 if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
 643                     OUT_OF_MEMORY(exec, scope);
 644 
 645                 MarkedArgumentBuffer args;
 646                 JSObject* groups = nullptr;
 647 
 648                 if (hasNamedCaptures) {
 649                     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 650                     groups = JSFinalObject::create(vm, JSFinalObject::createStructure(vm, globalObject, globalObject-&gt;objectPrototype(), 0));
 651                 }
 652 
 653                 for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
 654                     int matchStart = ovector[i * 2];
 655                     int matchLen = ovector[i * 2 + 1] - matchStart;
 656 
 657                     JSValue patternValue;
 658 
 659                     if (matchStart &lt; 0)
 660                         patternValue = jsUndefined();
<span class="line-modified"> 661                     else {</span>
<span class="line-modified"> 662                         patternValue = jsSubstring(vm, source, matchStart, matchLen);</span>
<span class="line-added"> 663                         RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 664                     }</span>
 665 
 666                     args.append(patternValue);
 667 
 668                     if (i &amp;&amp; hasNamedCaptures) {
 669                         String groupName = regExp-&gt;getCaptureGroupName(i);
 670                         if (!groupName.isEmpty())
<span class="line-modified"> 671                             groups-&gt;putDirect(vm, Identifier::fromString(vm, groupName), patternValue);</span>
 672                     }
 673 
 674                 }
 675 
 676                 args.append(jsNumber(result.start));
 677                 args.append(string);
 678                 if (hasNamedCaptures)
 679                     args.append(groups);
 680                 if (UNLIKELY(args.hasOverflowed())) {
 681                     throwOutOfMemoryError(exec, scope);
 682                     return nullptr;
 683                 }
 684 
 685                 JSValue replacement = call(exec, replaceValue, callType, callData, jsUndefined(), args);
 686                 RETURN_IF_EXCEPTION(scope, nullptr);
 687                 String replacementString = replacement.toWTFString(exec);
 688                 RETURN_IF_EXCEPTION(scope, nullptr);
 689                 replacements.append(replacementString);
 690                 RETURN_IF_EXCEPTION(scope, nullptr);
 691             } else {
</pre>
<hr />
<pre>
 714                 if (startPosition &gt; sourceLen)
 715                     break;
 716             }
 717         } while (global);
 718     }
 719 
 720     if (!lastIndex &amp;&amp; replacements.isEmpty())
 721         return string;
 722 
 723     if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
 724         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
 725             OUT_OF_MEMORY(exec, scope);
 726     }
 727     RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(exec, string, source, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));
 728 }
 729 
 730 JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpEmptyStr(
 731     ExecState* exec, JSString* thisValue, RegExpObject* searchValue)
 732 {
 733     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 734     NativeCallFrameTracer tracer(vm, exec);</span>
 735     auto scope = DECLARE_THROW_SCOPE(vm);
 736 
 737     RegExp* regExp = searchValue-&gt;regExp();
 738     if (regExp-&gt;global()) {
 739         // ES5.1 15.5.4.10 step 8.a.
 740         searchValue-&gt;setLastIndex(exec, 0);
 741         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 742         String source = thisValue-&gt;value(exec);</span>
 743         RETURN_IF_EXCEPTION(scope, nullptr);
 744         RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, exec, thisValue, source, regExp));
 745     }
 746 
 747     CallData callData;
 748     String replacementString = emptyString();
 749     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
 750         vm, exec, thisValue, searchValue, callData, CallType::None, replacementString, JSValue()));
 751 }
 752 
 753 JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpString(
 754     ExecState* exec, JSString* thisValue, RegExpObject* searchValue, JSString* replaceString)
 755 {
 756     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 757     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added"> 758     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 759 
 760     CallData callData;
 761     String replacementString = replaceString-&gt;value(exec);
<span class="line-modified"> 762     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-modified"> 763     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(</span>
<span class="line-added"> 764         vm, exec, thisValue, searchValue, callData, CallType::None, replacementString, replaceString));</span>
 765 }
 766 
 767 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, JSValue replaceValue)
 768 {
 769     auto scope = DECLARE_THROW_SCOPE(vm);
 770 
 771     String replacementString;
 772     CallData callData;
 773     CallType callType = getCallData(vm, replaceValue, callData);
 774     if (callType == CallType::None) {
 775         replacementString = replaceValue.toWTFString(exec);
 776         RETURN_IF_EXCEPTION(scope, nullptr);
 777     }
 778 
 779     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
 780         vm, exec, string, searchValue, callData, callType, replacementString, replaceValue));
 781 }
 782 
 783 static ALWAYS_INLINE JSString* replaceUsingStringSearch(VM&amp; vm, ExecState* exec, JSString* jsString, JSValue searchValue, JSValue replaceValue)
 784 {
 785     auto scope = DECLARE_THROW_SCOPE(vm);
 786 
<span class="line-modified"> 787     String string = jsString-&gt;value(exec);</span>
 788     RETURN_IF_EXCEPTION(scope, nullptr);
 789     String searchString = searchValue.toWTFString(exec);
 790     RETURN_IF_EXCEPTION(scope, nullptr);
 791 
 792     size_t matchStart = string.find(searchString);
 793 
 794     if (matchStart == notFound)
 795         return jsString;
 796 
 797     CallData callData;
 798     CallType callType = getCallData(vm, replaceValue, callData);
 799     if (callType != CallType::None) {
 800         MarkedArgumentBuffer args;
<span class="line-modified"> 801         auto* substring = jsSubstring(vm, string, matchStart, searchString.impl()-&gt;length());</span>
<span class="line-added"> 802         RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 803         args.append(substring);</span>
 804         args.append(jsNumber(matchStart));
 805         args.append(jsString);
 806         ASSERT(!args.hasOverflowed());
 807         replaceValue = call(exec, replaceValue, callType, callData, jsUndefined(), args);
 808         RETURN_IF_EXCEPTION(scope, nullptr);
 809     }
 810 
 811     String replaceString = replaceValue.toWTFString(exec);
 812     RETURN_IF_EXCEPTION(scope, nullptr);
 813 
 814     StringImpl* stringImpl = string.impl();
 815     String leftPart(StringImpl::createSubstringSharingImpl(*stringImpl, 0, matchStart));
 816 
 817     size_t matchEnd = matchStart + searchString.impl()-&gt;length();
 818     int ovector[2] = { static_cast&lt;int&gt;(matchStart),  static_cast&lt;int&gt;(matchEnd)};
 819     String middlePart;
 820     if (callType != CallType::None)
 821         middlePart = replaceString;
 822     else {
 823         StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
</pre>
<hr />
<pre>
 858     ASSERT(exec-&gt;uncheckedArgument(0).isString());
 859     JSString* string = asString(exec-&gt;uncheckedArgument(0));
 860     ASSERT(string-&gt;length() == 1);
 861 
 862     JSValue repeatCountValue = exec-&gt;uncheckedArgument(1);
 863     RELEASE_ASSERT(repeatCountValue.isNumber());
 864     int32_t repeatCount;
 865     double value = repeatCountValue.asNumber();
 866     if (value &gt; JSString::MaxLength)
 867         return JSValue::encode(throwOutOfMemoryError(exec, scope));
 868     repeatCount = static_cast&lt;int32_t&gt;(value);
 869     ASSERT(repeatCount &gt;= 0);
 870     ASSERT(!repeatCountValue.isDouble() || repeatCountValue.asDouble() == repeatCount);
 871 
 872     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);
 873     StringView view = viewWithString.view;
 874     ASSERT(view.length() == 1);
 875     scope.assertNoException();
 876     UChar character = view[0];
 877     scope.release();
<span class="line-modified"> 878     if (isLatin1(character))</span>
 879         return JSValue::encode(repeatCharacter(*exec, static_cast&lt;LChar&gt;(character), repeatCount));
 880     return JSValue::encode(repeatCharacter(*exec, character, repeatCount));
 881 }
 882 
 883 ALWAYS_INLINE JSString* replace(
 884     VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, JSValue replaceValue)
 885 {
 886     if (searchValue.inherits&lt;RegExpObject&gt;(vm))
 887         return replaceUsingRegExpSearch(vm, exec, string, searchValue, replaceValue);
 888     return replaceUsingStringSearch(vm, exec, string, searchValue, replaceValue);
 889 }
 890 
 891 ALWAYS_INLINE JSString* replace(
 892     VM&amp; vm, ExecState* exec, JSValue thisValue, JSValue searchValue, JSValue replaceValue)
 893 {
 894     auto scope = DECLARE_THROW_SCOPE(vm);
 895 
 896     if (!checkObjectCoercible(thisValue)) {
 897         throwVMTypeError(exec, scope);
 898         return nullptr;
</pre>
<hr />
<pre>
 916 
 917     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingRegExpSearch(vm, exec, string, searchValue, exec-&gt;argument(1))));
 918 }
 919 
 920 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(ExecState* exec)
 921 {
 922     VM&amp; vm = exec-&gt;vm();
 923     auto scope = DECLARE_THROW_SCOPE(vm);
 924 
 925     JSString* string = exec-&gt;thisValue().toString(exec);
 926     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 927 
 928     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, exec, string, exec-&gt;argument(0), exec-&gt;argument(1))));
 929 }
 930 
 931 JSCell* JIT_OPERATION operationStringProtoFuncReplaceGeneric(
 932     ExecState* exec, EncodedJSValue thisValue, EncodedJSValue searchValue,
 933     EncodedJSValue replaceValue)
 934 {
 935     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 936     NativeCallFrameTracer tracer(vm, exec);</span>
 937 
 938     return replace(
 939         vm, exec, JSValue::decode(thisValue), JSValue::decode(searchValue),
 940         JSValue::decode(replaceValue));
 941 }
 942 
 943 EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(ExecState* exec)
 944 {
 945     VM&amp; vm = exec-&gt;vm();
 946     auto scope = DECLARE_THROW_SCOPE(vm);
 947 
 948     JSValue thisValue = exec-&gt;thisValue();
 949     // Also used for valueOf.
 950 
 951     if (thisValue.isString())
 952         return JSValue::encode(thisValue);
 953 
 954     auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, thisValue);
 955     if (stringObject)
 956         return JSValue::encode(stringObject-&gt;internalValue());
 957 
 958     return throwVMTypeError(exec, scope);
 959 }
 960 
 961 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(ExecState* exec)
 962 {
 963     VM&amp; vm = exec-&gt;vm();
 964     auto scope = DECLARE_THROW_SCOPE(vm);
 965 
 966     JSValue thisValue = exec-&gt;thisValue();
 967     if (!checkObjectCoercible(thisValue))
 968         return throwVMTypeError(exec, scope);
 969     auto viewWithString = thisValue.toString(exec)-&gt;viewWithUnderlyingString(exec);
 970     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 971     StringView view = viewWithString.view;
 972     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 973     JSValue a0 = exec-&gt;argument(0);
 974     if (a0.isUInt32()) {
 975         uint32_t i = a0.asUInt32();
 976         if (i &lt; view.length())
<span class="line-modified"> 977             return JSValue::encode(jsSingleCharacterString(vm, view[i]));</span>
<span class="line-modified"> 978         return JSValue::encode(jsEmptyString(vm));</span>
 979     }
 980     double dpos = a0.toInteger(exec);
 981     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 982     if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
<span class="line-modified"> 983         return JSValue::encode(jsSingleCharacterString(vm, view[static_cast&lt;unsigned&gt;(dpos)]));</span>
<span class="line-modified"> 984     return JSValue::encode(jsEmptyString(vm));</span>
 985 }
 986 
 987 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(ExecState* exec)
 988 {
 989     VM&amp; vm = exec-&gt;vm();
 990     auto scope = DECLARE_THROW_SCOPE(vm);
 991 
 992     JSValue thisValue = exec-&gt;thisValue();
 993     if (!checkObjectCoercible(thisValue))
 994         return throwVMTypeError(exec, scope);
 995     auto viewWithString = thisValue.toString(exec)-&gt;viewWithUnderlyingString(exec);
 996     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 997     StringView view = viewWithString.view;
 998     JSValue a0 = exec-&gt;argument(0);
 999     if (a0.isUInt32()) {
1000         uint32_t i = a0.asUInt32();
1001         if (i &lt; view.length())
1002             return JSValue::encode(jsNumber(view[i]));
1003         return JSValue::encode(jsNaN());
1004     }
</pre>
<hr />
<pre>
1111     JSString* thisJSString = thisValue.toString(exec);
1112     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1113     unsigned len = thisJSString-&gt;length();
1114     JSString* otherJSString = a0.toString(exec);
1115     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1116 
1117     double dpos = a1.toIntegerPreserveNaN(exec);
1118     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1119     unsigned startPosition;
1120     if (dpos &lt; 0)
1121         startPosition = 0;
1122     else if (!(dpos &lt;= len)) // true for NaN
1123         startPosition = len;
1124     else
1125         startPosition = static_cast&lt;unsigned&gt;(dpos);
1126 
1127     if (len &lt; otherJSString-&gt;length())
1128         return JSValue::encode(jsNumber(-1));
1129 
1130     String thisString = thisJSString-&gt;value(exec);
<span class="line-added">1131     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
1132     String otherString = otherJSString-&gt;value(exec);
<span class="line-added">1133     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
1134     size_t result;
1135     if (!startPosition)
1136         result = thisString.startsWith(otherString) ? 0 : notFound;
1137     else
1138         result = thisString.reverseFind(otherString, startPosition);
1139     if (result == notFound)
1140         return JSValue::encode(jsNumber(-1));
1141     return JSValue::encode(jsNumber(result));
1142 }
1143 
1144 EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(ExecState* exec)
1145 {
1146     VM&amp; vm = exec-&gt;vm();
1147     auto scope = DECLARE_THROW_SCOPE(vm);
1148 
1149     JSValue thisValue = exec-&gt;thisValue();
1150     if (!checkObjectCoercible(thisValue))
1151         return throwVMTypeError(exec, scope);
<span class="line-modified">1152     JSString* string = thisValue.toString(exec);</span>
1153     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1154 
1155     JSValue a0 = exec-&gt;argument(0);
1156     JSValue a1 = exec-&gt;argument(1);
1157 
<span class="line-modified">1158     int length = string-&gt;length();</span>
<span class="line-modified">1159     RELEASE_ASSERT(length &gt;= 0);</span>
1160 
1161     // The arg processing is very much like ArrayProtoFunc::Slice
1162     double start = a0.toInteger(exec);
1163     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1164     double end = a1.isUndefined() ? length : a1.toInteger(exec);</span>
1165     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1166     RELEASE_AND_RETURN(scope, JSValue::encode(stringSlice(exec, vm, string, length, start, end)));</span>

1167 }
1168 
1169 // Return true in case of early return (resultLength got to limitLength).
1170 template&lt;typename CharacterType&gt;
1171 static ALWAYS_INLINE bool splitStringByOneCharacterImpl(ExecState* exec, JSArray* result, JSValue originalValue, const String&amp; input, StringImpl* string, UChar separatorCharacter, size_t&amp; position, unsigned&amp; resultLength, unsigned limitLength)
1172 {
1173     VM&amp; vm = exec-&gt;vm();
1174     auto scope = DECLARE_THROW_SCOPE(vm);
1175 
1176     // 12. Let q = p.
1177     size_t matchPosition;
1178     const CharacterType* characters = string-&gt;characters&lt;CharacterType&gt;();
1179     // 13. Repeat, while q != s
1180     //   a. Call SplitMatch(S, q, R) and let z be its MatchResult result.
1181     //   b. If z is failure, then let q = q+1.
1182     //   c. Else, z is not failure
1183     while ((matchPosition = WTF::find(characters, string-&gt;length(), separatorCharacter, position)) != notFound) {
1184         // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1185         //    through q (exclusive).
1186         // 2. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA),
1187         //    Property Descriptor {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
<span class="line-modified">1188         auto* substring = jsSubstring(exec, originalValue, input, position, matchPosition - position);</span>
<span class="line-added">1189         RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">1190         result-&gt;putDirectIndex(exec, resultLength, substring);</span>
1191         RETURN_IF_EXCEPTION(scope, false);
1192         // 3. Increment lengthA by 1.
1193         // 4. If lengthA == lim, return A.
1194         if (++resultLength == limitLength)
1195             return true;
1196 
1197         // 5. Let p = e.
1198         // 8. Let q = p.
1199         position = matchPosition + 1;
1200     }
1201     return false;
1202 }
1203 
1204 // ES 21.1.3.17 String.prototype.split(separator, limit)
1205 EncodedJSValue JSC_HOST_CALL stringProtoFuncSplitFast(ExecState* exec)
1206 {
1207     VM&amp; vm = exec-&gt;vm();
1208     auto scope = DECLARE_THROW_SCOPE(vm);
1209     JSValue thisValue = exec-&gt;thisValue();
1210     ASSERT(checkObjectCoercible(thisValue));
</pre>
<hr />
<pre>
1253     // 12. If s == 0, then
1254     if (input.isEmpty()) {
1255         // a. Let z be SplitMatch(S, 0, R) where S is input, R is separator.
1256         // b. If z is not false, return A.
1257         // c. Call CreateDataProperty(A, &quot;0&quot;, S).
1258         // d. Return A.
1259         if (!separator.isEmpty()) {
1260             scope.release();
1261             result-&gt;putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));
1262         }
1263         return JSValue::encode(result);
1264     }
1265 
1266     // Optimized case for splitting on the empty string.
1267     if (separator.isEmpty()) {
1268         limit = std::min(limit, input.length());
1269         // Zero limt/input length handled in steps 9/11 respectively, above.
1270         ASSERT(limit);
1271 
1272         do {
<span class="line-modified">1273             result-&gt;putDirectIndex(exec, position, jsSingleCharacterString(vm, input[position]));</span>
1274             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1275         } while (++position &lt; limit);
1276 
1277         return JSValue::encode(result);
1278     }
1279 
1280     // 3 cases:
1281     // -separator length == 1, 8 bits
1282     // -separator length == 1, 16 bits
1283     // -separator length &gt; 1
1284     StringImpl* stringImpl = input.impl();
1285     StringImpl* separatorImpl = separator.impl();
1286     size_t separatorLength = separatorImpl-&gt;length();
1287 
1288     if (separatorLength == 1) {
1289         UChar separatorCharacter;
1290         if (separatorImpl-&gt;is8Bit())
1291             separatorCharacter = separatorImpl-&gt;characters8()[0];
1292         else
1293             separatorCharacter = separatorImpl-&gt;characters16()[0];
1294 
1295         if (stringImpl-&gt;is8Bit()) {
1296             if (splitStringByOneCharacterImpl&lt;LChar&gt;(exec, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))
1297                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
1298         } else {
1299             if (splitStringByOneCharacterImpl&lt;UChar&gt;(exec, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))
1300                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
1301         }
1302         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1303     } else {
1304         // 13. Let q = p.
1305         size_t matchPosition;
1306         // 14. Repeat, while q != s
1307         //   a. let e be SplitMatch(S, q, R).
1308         //   b. If e is failure, then let q = q+1.
1309         //   c. Else, e is an integer index &lt;= s.
1310         while ((matchPosition = stringImpl-&gt;find(separatorImpl, position)) != notFound) {
1311             // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1312             //    through q (exclusive).
1313             // 2. Call CreateDataProperty(A, ToString(lengthA), T).
<span class="line-modified">1314             auto* substring = jsSubstring(exec, thisValue, input, position, matchPosition - position);</span>
<span class="line-modified">1315             RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">1316             result-&gt;putDirectIndex(exec, resultLength, substring);</span>
<span class="line-added">1317             RETURN_IF_EXCEPTION(scope, { });</span>
1318             // 3. Increment lengthA by 1.
1319             // 4. If lengthA == lim, return A.
1320             if (++resultLength == limit)
1321                 return JSValue::encode(result);
1322 
1323             // 5. Let p = e.
1324             // 6. Let q = p.
1325             position = matchPosition + separator.length();
1326         }
1327     }
1328 
1329     // 15. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1330     //     through s (exclusive).
1331     // 16. Call CreateDataProperty(A, ToString(lengthA), T).
<span class="line-added">1332     auto* substring = jsSubstring(exec, thisValue, input, position, input.length() - position);</span>
<span class="line-added">1333     RETURN_IF_EXCEPTION(scope, { });</span>
1334     scope.release();
<span class="line-modified">1335     result-&gt;putDirectIndex(exec, resultLength++, substring);</span>
1336 
1337     // 17. Return A.
1338     return JSValue::encode(result);
1339 }
1340 
1341 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(ExecState* exec)
1342 {
1343     VM&amp; vm = exec-&gt;vm();
1344     auto scope = DECLARE_THROW_SCOPE(vm);
1345 
1346     JSValue thisValue = exec-&gt;thisValue();
1347     if (!checkObjectCoercible(thisValue))
1348         return throwVMTypeError(exec, scope);
1349     unsigned len;
1350     JSString* jsString = 0;
1351     String uString;
1352     if (thisValue.isString()) {
1353         jsString = asString(thisValue);
1354         len = jsString-&gt;length();
1355     } else {
1356         uString = thisValue.toWTFString(exec);
1357         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1358         len = uString.length();
1359     }
1360 
1361     JSValue a0 = exec-&gt;argument(0);
1362     JSValue a1 = exec-&gt;argument(1);
1363 
1364     double start = a0.toInteger(exec);
1365     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1366     double length = a1.isUndefined() ? len : a1.toInteger(exec);
1367     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1368     if (start &gt;= len || length &lt;= 0)
<span class="line-modified">1369         return JSValue::encode(jsEmptyString(vm));</span>
1370     if (start &lt; 0) {
1371         start += len;
1372         if (start &lt; 0)
1373             start = 0;
1374     }
1375     if (start + length &gt; len)
1376         length = len - start;
1377     unsigned substringStart = static_cast&lt;unsigned&gt;(start);
1378     unsigned substringLength = static_cast&lt;unsigned&gt;(length);
<span class="line-added">1379     scope.release();</span>
1380     if (jsString)
1381         return JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength));
<span class="line-modified">1382     return JSValue::encode(jsSubstring(vm, uString, substringStart, substringLength));</span>
1383 }
1384 
1385 EncodedJSValue JSC_HOST_CALL builtinStringSubstrInternal(ExecState* exec)
1386 {
1387     // @substrInternal should not have any observable side effects (e.g. it should not call
1388     // GetMethod(..., @@toPrimitive) on the thisValue).
1389 
1390     // It is ok to use the default stringProtoFuncSubstr as the implementation of
1391     // @substrInternal because @substrInternal will only be called by builtins, which will
1392     // guarantee that we only pass it a string thisValue. As a result, stringProtoFuncSubstr
1393     // will not need to call toString() on the thisValue, and there will be no observable
1394     // side-effects.
1395     ASSERT(exec-&gt;thisValue().isString());
1396     return stringProtoFuncSubstr(exec);
1397 }
1398 
1399 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(ExecState* exec)
1400 {
1401     VM&amp; vm = exec-&gt;vm();
1402     auto scope = DECLARE_THROW_SCOPE(vm);
</pre>
<hr />
<pre>
1420         start = 0;
1421     else if (start &gt; len)
1422         start = len;
1423     if (a1.isUndefined())
1424         end = len;
1425     else {
1426         end = a1.toNumber(exec);
1427         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1428         if (!(end &gt;= 0)) // check for negative values or NaN
1429             end = 0;
1430         else if (end &gt; len)
1431             end = len;
1432     }
1433     if (start &gt; end) {
1434         double temp = end;
1435         end = start;
1436         start = temp;
1437     }
1438     unsigned substringStart = static_cast&lt;unsigned&gt;(start);
1439     unsigned substringLength = static_cast&lt;unsigned&gt;(end) - substringStart;
<span class="line-modified">1440     RELEASE_AND_RETURN(scope, JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength)));</span>
1441 }
1442 
1443 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(ExecState* exec)
1444 {
1445     VM&amp; vm = exec-&gt;vm();
1446     auto scope = DECLARE_THROW_SCOPE(vm);
1447 
1448     JSValue thisValue = exec-&gt;thisValue();
1449     if (!checkObjectCoercible(thisValue))
1450         return throwVMTypeError(exec, scope);
1451     JSString* sVal = thisValue.toString(exec);
1452     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1453     String s = sVal-&gt;value(exec);</span>
<span class="line-added">1454     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
1455     String lowercasedString = s.convertToLowercaseWithoutLocale();
1456     if (lowercasedString.impl() == s.impl())
1457         return JSValue::encode(sVal);
<span class="line-modified">1458     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lowercasedString)));</span>
1459 }
1460 
1461 EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(ExecState* exec)
1462 {
1463     VM&amp; vm = exec-&gt;vm();
1464     auto scope = DECLARE_THROW_SCOPE(vm);
1465 
1466     JSValue thisValue = exec-&gt;thisValue();
1467     if (!checkObjectCoercible(thisValue))
1468         return throwVMTypeError(exec, scope);
1469     JSString* sVal = thisValue.toString(exec);
1470     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1471     String s = sVal-&gt;value(exec);</span>
<span class="line-added">1472     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
1473     String uppercasedString = s.convertToUppercaseWithoutLocale();
1474     if (uppercasedString.impl() == s.impl())
1475         return JSValue::encode(sVal);
<span class="line-modified">1476     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, uppercasedString)));</span>
1477 }
1478 
1479 EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(ExecState* exec)
1480 {
1481     // 13.1.1 String.prototype.localeCompare (that [, locales [, options ]]) (ECMA-402 2.0)
1482     // http://ecma-international.org/publications/standards/Ecma-402.htm
1483 
1484     VM&amp; vm = exec-&gt;vm();
1485     auto scope = DECLARE_THROW_SCOPE(vm);
1486 
1487     // 1. Let O be RequireObjectCoercible(this value).
1488     JSValue thisValue = exec-&gt;thisValue();
1489     if (!checkObjectCoercible(thisValue))
1490         return throwVMTypeError(exec, scope, &quot;String.prototype.localeCompare requires that |this| not be null or undefined&quot;_s);
1491 
1492     // 2. Let S be ToString(O).
1493     // 3. ReturnIfAbrupt(S).
1494     String string = thisValue.toWTFString(exec);
1495     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1496 
1497     // 4. Let That be ToString(that).
1498     // 5. ReturnIfAbrupt(That).
1499     JSValue thatValue = exec-&gt;argument(0);
1500     String that = thatValue.toWTFString(exec);
1501     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1502 
1503 #if ENABLE(INTL)
1504     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1505     JSValue locales = exec-&gt;argument(1);
1506     JSValue options = exec-&gt;argument(2);
1507     IntlCollator* collator = nullptr;
1508     if (locales.isUndefined() &amp;&amp; options.isUndefined()) {
1509         collator = globalObject-&gt;defaultCollator(exec);
<span class="line-modified">1510         RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
1511     } else {
1512         collator = IntlCollator::create(vm, globalObject-&gt;collatorStructure());
1513         collator-&gt;initializeCollator(*exec, locales, options);
1514         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1515     }
1516     RELEASE_AND_RETURN(scope, JSValue::encode(collator-&gt;compareStrings(*exec, string, that)));
1517 #else
1518     return JSValue::encode(jsNumber(Collator().collate(string, that)));
1519 #endif
1520 }
1521 
1522 #if ENABLE(INTL)
1523 static EncodedJSValue toLocaleCase(ExecState* state, int32_t (*convertCase)(UChar*, int32_t, const UChar*, int32_t, const char*, UErrorCode*))
1524 {
1525     VM&amp; vm = state-&gt;vm();
1526     auto scope = DECLARE_THROW_SCOPE(vm);
1527 
1528     // 1. Let O be RequireObjectCoercible(this value).
1529     JSValue thisValue = state-&gt;thisValue();
1530     if (!checkObjectCoercible(thisValue))
</pre>
<hr />
<pre>
1584 
1585     // Most strings lower/upper case will be the same size as original, so try that first.
1586     UErrorCode error(U_ZERO_ERROR);
1587     Vector&lt;UChar&gt; buffer(viewLength);
1588     String lower;
1589     const int32_t resultLength = convertCase(buffer.data(), viewLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
1590     if (U_SUCCESS(error))
1591         lower = String(buffer.data(), resultLength);
1592     else if (error == U_BUFFER_OVERFLOW_ERROR) {
1593         // Converted case needs more space than original. Try again.
1594         UErrorCode error(U_ZERO_ERROR);
1595         Vector&lt;UChar&gt; buffer(resultLength);
1596         convertCase(buffer.data(), resultLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
1597         if (U_FAILURE(error))
1598             return throwVMTypeError(state, scope, u_errorName(error));
1599         lower = String(buffer.data(), resultLength);
1600     } else
1601         return throwVMTypeError(state, scope, u_errorName(error));
1602 
1603     // 18. Return L.
<span class="line-modified">1604     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lower)));</span>
1605 }
1606 
1607 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(ExecState* state)
1608 {
1609     // 13.1.2 String.prototype.toLocaleLowerCase ([locales])
1610     // http://ecma-international.org/publications/standards/Ecma-402.htm
1611     return toLocaleCase(state, u_strToLower);
1612 }
1613 
1614 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(ExecState* state)
1615 {
1616     // 13.1.3 String.prototype.toLocaleUpperCase ([locales])
1617     // http://ecma-international.org/publications/standards/Ecma-402.htm
1618     // This function interprets a string value as a sequence of code points, as described in ES2015, 6.1.4. This function behaves in exactly the same way as String.prototype.toLocaleLowerCase, except that characters are mapped to their uppercase equivalents as specified in the Unicode character database.
1619     return toLocaleCase(state, u_strToUpper);
1620 }
1621 #endif // ENABLE(INTL)
1622 
1623 enum {
1624     TrimStart = 1,
</pre>
<hr />
<pre>
1633     if (!checkObjectCoercible(thisValue))
1634         return throwTypeError(exec, scope);
1635     String str = thisValue.toWTFString(exec);
1636     RETURN_IF_EXCEPTION(scope, { });
1637 
1638     unsigned left = 0;
1639     if (trimKind &amp; TrimStart) {
1640         while (left &lt; str.length() &amp;&amp; isStrWhiteSpace(str[left]))
1641             left++;
1642     }
1643     unsigned right = str.length();
1644     if (trimKind &amp; TrimEnd) {
1645         while (right &gt; left &amp;&amp; isStrWhiteSpace(str[right - 1]))
1646             right--;
1647     }
1648 
1649     // Don&#39;t gc allocate a new string if we don&#39;t have to.
1650     if (left == 0 &amp;&amp; right == str.length() &amp;&amp; thisValue.isString())
1651         return thisValue;
1652 
<span class="line-modified">1653     RELEASE_AND_RETURN(scope, jsString(vm, str.substringSharingImpl(left, right - left)));</span>
1654 }
1655 
1656 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(ExecState* exec)
1657 {
1658     JSValue thisValue = exec-&gt;thisValue();
1659     return JSValue::encode(trimString(exec, thisValue, TrimStart | TrimEnd));
1660 }
1661 
1662 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(ExecState* exec)
1663 {
1664     JSValue thisValue = exec-&gt;thisValue();
1665     return JSValue::encode(trimString(exec, thisValue, TrimStart));
1666 }
1667 
1668 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(ExecState* exec)
1669 {
1670     JSValue thisValue = exec-&gt;thisValue();
1671     return JSValue::encode(trimString(exec, thisValue, TrimEnd));
1672 }
1673 
</pre>
<hr />
<pre>
1884     auto characters = view.upconvertedCharacters();
1885 
1886     UErrorCode status = U_ZERO_ERROR;
1887     UBool isNormalized = unorm2_isNormalized(normalizer, characters, view.length(), &amp;status);
1888     ASSERT(U_SUCCESS(status));
1889     if (isNormalized)
1890         RELEASE_AND_RETURN(scope, string);
1891 
1892     int32_t normalizedStringLength = unorm2_normalize(normalizer, characters, view.length(), nullptr, 0, &amp;status);
1893     ASSERT(status == U_BUFFER_OVERFLOW_ERROR);
1894 
1895     UChar* buffer;
1896     auto result = StringImpl::tryCreateUninitialized(normalizedStringLength, buffer);
1897     if (!result)
1898         return throwOutOfMemoryError(exec, scope);
1899 
1900     status = U_ZERO_ERROR;
1901     unorm2_normalize(normalizer, characters, view.length(), buffer, normalizedStringLength, &amp;status);
1902     ASSERT(U_SUCCESS(status));
1903 
<span class="line-modified">1904     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(result)));</span>
1905 }
1906 
1907 EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(ExecState* exec)
1908 {
1909     VM&amp; vm = exec-&gt;vm();
1910     auto scope = DECLARE_THROW_SCOPE(vm);
1911 
1912     JSValue thisValue = exec-&gt;thisValue();
1913     if (!checkObjectCoercible(thisValue))
1914         return throwVMTypeError(exec, scope);
1915     JSString* string = thisValue.toString(exec);
1916     RETURN_IF_EXCEPTION(scope, { });
1917 
1918     auto form = NormalizationForm::NFC;
1919     JSValue formValue = exec-&gt;argument(0);
1920     if (!formValue.isUndefined()) {
1921         String formString = formValue.toWTFString(exec);
1922         RETURN_IF_EXCEPTION(scope, { });
1923 
1924         if (formString == &quot;NFC&quot;)
</pre>
</td>
</tr>
</table>
<center><a href="StringObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StringPrototypeInlines.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>