<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/generateYarrUnicodePropertyTables.py</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 #!/usr/bin/env python
  2 
  3 # Copyright (C) 2017 Apple Inc. All rights reserved.
  4 #
  5 # Redistribution and use in source and binary forms, with or without
  6 # modification, are permitted provided that the following conditions
  7 # are met:
  8 #
  9 # 1.  Redistributions of source code must retain the above copyright
 10 #     notice, this list of conditions and the following disclaimer.
 11 # 2.  Redistributions in binary form must reproduce the above copyright
 12 #     notice, this list of conditions and the following disclaimer in the
 13 #     documentation and/or other materials provided with the distribution.
 14 #
 15 # THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 16 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17 # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18 # DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 19 # DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20 # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21 # LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 22 # ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25 
 26 # This tool processes the Unicode Character Database file CaseFolding.txt to create
 27 # canonicalization table as decribed in ECMAScript 6 standard in section
 28 # &quot;21.2.2.8.2 Runtime Semantics: Canonicalize()&quot;, step 2.
 29 
 30 import sys
 31 import copy
 32 import optparse
 33 import os
 34 import re
 35 from hasher import stringHash
 36 
 37 header = &quot;&quot;&quot;/*
 38 * Copyright (C) 2017-2018 Apple Inc. All rights reserved.
 39 *
 40 * Redistribution and use in source and binary forms, with or without
 41 * modification, are permitted provided that the following conditions
 42 * are met:
 43 *
 44 * 1.  Redistributions of source code must retain the above copyright
 45 *     notice, this list of conditions and the following disclaimer.
 46 * 2.  Redistributions in binary form must reproduce the above copyright
 47 *     notice, this list of conditions and the following disclaimer in the
 48 *     documentation and/or other materials provided with the distribution.
 49 *
 50 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 51 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 52 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 53 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 54 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 55 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 56 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 57 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 58 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 59 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 60 */
 61 
 62 // DO NO EDIT! - This file was generated by &quot;&quot;&quot; + __file__ + &quot;&quot;&quot;
 63 &quot;&quot;&quot;
 64 
 65 
 66 footer = &quot;&quot;&quot;
 67 &quot;&quot;&quot;
 68 
 69 RequiredUCDFiles = [&quot;DerivedBinaryProperties.txt&quot;, &quot;DerivedCoreProperties.txt&quot;, &quot;DerivedNormalizationProps.txt&quot;, &quot;PropList.txt&quot;, &quot;PropertyAliases.txt&quot;, &quot;PropertyValueAliases.txt&quot;, &quot;ScriptExtensions.txt&quot;, &quot;UnicodeData.txt&quot;, &quot;emoji-data.txt&quot;]
 70 UCDDirectoryPath = None
 71 
 72 SupportedBinaryProperties = [
 73     &quot;Alphabetic&quot;, &quot;Any&quot;, &quot;ASCII&quot;, &quot;ASCII_Hex_Digit&quot;, &quot;Assigned&quot;, &quot;Bidi_Control&quot;, &quot;Bidi_Mirrored&quot;, &quot;Case_Ignorable&quot;,
 74     &quot;Cased&quot;, &quot;Changes_When_Casefolded&quot;, &quot;Changes_When_Casemapped&quot;, &quot;Changes_When_Lowercased&quot;, &quot;Changes_When_NFKC_Casefolded&quot;,
 75     &quot;Changes_When_Titlecased&quot;, &quot;Changes_When_Uppercased&quot;, &quot;Dash&quot;, &quot;Default_Ignorable_Code_Point&quot;, &quot;Deprecated&quot;,
 76     &quot;Diacritic&quot;, &quot;Emoji&quot;, &quot;Emoji_Component&quot;, &quot;Emoji_Modifier_Base&quot;, &quot;Emoji_Modifier&quot;, &quot;Emoji_Presentation&quot;,
 77     &quot;Extended_Pictographic&quot;, &quot;Extender&quot;, &quot;Grapheme_Base&quot;, &quot;Grapheme_Extend&quot;, &quot;Hex_Digit&quot;, &quot;ID_Continue&quot;, &quot;ID_Start&quot;,
 78     &quot;Ideographic&quot;, &quot;IDS_Binary_Operator&quot;, &quot;IDS_Trinary_Operator&quot;, &quot;Join_Control&quot;, &quot;Logical_Order_Exception&quot;, &quot;Lowercase&quot;,
 79     &quot;Math&quot;, &quot;Noncharacter_Code_Point&quot;, &quot;Pattern_Syntax&quot;, &quot;Pattern_White_Space&quot;, &quot;Quotation_Mark&quot;, &quot;Radical&quot;,
 80     &quot;Regional_Indicator&quot;, &quot;Sentence_Terminal&quot;, &quot;Soft_Dotted&quot;, &quot;Terminal_Punctuation&quot;, &quot;Unified_Ideograph&quot;, &quot;Uppercase&quot;,
 81     &quot;Variation_Selector&quot;, &quot;White_Space&quot;, &quot;XID_Continue&quot;, &quot;XID_Start&quot;]
 82 
 83 lastASCIICodePoint = 0x7f
 84 firstUnicodeCodePoint = 0x80
 85 MaxUnicode = 0x10ffff
 86 MaxBMP = 0xffff
 87 commonAndSimpleLinesRE = re.compile(r&quot;(?P&lt;code&gt;[0-9A-F]+)\s*;\s*[CS]\s*;\s*(?P&lt;mapping&gt;[0-9A-F]+)&quot;, re.IGNORECASE)
 88 aliases = None
 89 
 90 
 91 def openOrExit(path, mode):
 92     try:
 93         if sys.version_info.major &gt;= 3:
 94             return open(path, mode, encoding=&quot;UTF-8&quot;)
 95         else:
 96             return open(path, mode)
 97     except IOError as e:
 98         print(&quot;I/O error opening {0}, ({1}): {2}&quot;.format(path, e.errno, e.strerror))
 99         exit(1)
100 
101 
102 def openUCDFileOrExit(path):
103     if not UCDDirectoryPath:
104         exit(1)
105 
106     return openOrExit(os.path.join(UCDDirectoryPath, path), &#39;r&#39;)
107 
108 
109 def verifyUCDFilesExist():
110     if not UCDDirectoryPath:
111         exit(1)
112 
113     missingFileCount = 0
114     for file in RequiredUCDFiles:
115         fullPath = os.path.join(UCDDirectoryPath, file)
116         if not os.path.exists(fullPath):
117             print(&quot;Couldn&#39;t find UCD file {0} at {1}&quot;.format(file, fullPath))
118             missingFileCount = missingFileCount + 1
119     if missingFileCount:
120         exit(1)
121 
122 
123 def ceilingToPowerOf2(size):
124     powerOf2 = 1
125     while size &gt; powerOf2:
126         powerOf2 = powerOf2 &lt;&lt; 1
127 
128     return powerOf2
129 
130 
131 class Aliases:
132     def __init__(self):
133         self.globalNameToAliases = {}
134         self.generalCategoryToAliases = {}
135         self.aliasToGeneralCategory = {}
136         self.scriptToAliases = {}
137         self.aliasToScript = {}
138 
139     def parsePropertyAliasesFile(self, file):
140         for line in file:
141             line = line.split(&#39;#&#39;, 1)[0]
142             line = line.rstrip()
143             if (not len(line)):
144                 continue
145 
146             fields = line.split(&#39;;&#39;)
147             if (not fields):
148                 continue
149 
150             aliases = [fields[0].strip()]
151             fullName = fields[1].strip()
152             for otherAlias in fields[2:]:
153                 aliases.append(otherAlias.strip())
154 
155             if fullName in self.globalNameToAliases:
156                 print(&quot;Error, already an alias for {}&quot;.format(fullName))
157             else:
158                 self.globalNameToAliases[fullName] = aliases
159 
160     def parsePropertyValueAliasesFile(self, file):
161         for line in file:
162             line = line.split(&#39;#&#39;, 1)[0]
163             line = line.rstrip()
164             if (not len(line)):
165                 continue
166 
167             fields = line.split(&#39;;&#39;)
168             if (not fields):
169                 continue
170 
171             propertyType = fields[0].strip()
172 
173             if propertyType == &quot;gc&quot;:
174                 mapToModify = self.generalCategoryToAliases
175                 reverseMapToModify = self.aliasToGeneralCategory
176             elif propertyType == &quot;sc&quot;:
177                 mapToModify = self.scriptToAliases
178                 reverseMapToModify = self.aliasToScript
179             else:
180                 continue
181 
182             primaryAlias = fields[1].strip()
183             fullName = fields[2].strip()
184             aliases = [primaryAlias]
185             for otherAlias in fields[3:]:
186                 aliases.append(otherAlias.strip())
187 
188             if fullName in mapToModify:
189                 print(&quot;Error, already an {} alias for {}&quot;.format(propertyType, fullName))
190             else:
191                 mapToModify[fullName] = aliases
192                 if reverseMapToModify != None:
193                     reverseMapToModify[primaryAlias] = fullName
194 
195     def globalAliasesFor(self, name):
196         if name not in self.globalNameToAliases:
197             return []
198         return self.globalNameToAliases[name]
199 
200     def generalCategoryAliasesFor(self, name):
201         if name not in self.generalCategoryToAliases:
202             return &quot;&quot;
203         return self.generalCategoryToAliases[name]
204 
205     def generalCategoryForAlias(self, name):
206         if name not in self.aliasToGeneralCategory:
207             return &quot;&quot;
208         return self.aliasToGeneralCategory[name]
209 
210     def scriptAliasesFor(self, name):
211         if name not in self.scriptToAliases:
212             return &quot;&quot;
213         return self.scriptToAliases[name]
214 
215     def scriptNameForAlias(self, name):
216         if name not in self.aliasToScript:
217             return &quot;&quot;
218         return self.aliasToScript[name]
219 
220 
221 class PropertyData:
222     allPropertyData = []
223 
224     def __init__(self, name):
225         self.name = name
226         self.aliases = []
227         self.index = len(PropertyData.allPropertyData)
228         self.hasNonBMPCharacters = False
229         self.matches = []
230         self.ranges = []
231         self.unicodeMatches = []
232         self.unicodeRanges = []
233         self.codePointCount = 0
234         PropertyData.allPropertyData.append(self)
235 
236     def setAliases(self, aliases):
237         self.aliases = aliases
238 
239     def makeCopy(self):
240         result = copy.deepcopy(self)
241         result.index = len(PropertyData.allPropertyData)
242         PropertyData.allPropertyData.append(result)
243         return result
244 
245     def getIndex(self):
246         return self.index
247 
248     def getCreateFuncName(self):
249         return &quot;createCharacterClass{}&quot;.format(self.index)
250 
251     def addMatch(self, codePoint):
252         if codePoint &gt; MaxBMP:
253             self.hasNonBMPCharacters = True
254         if codePoint &lt;= lastASCIICodePoint:
255             if (len(self.matches) and self.matches[-1] &gt; codePoint) or (len(self.ranges) and self.ranges[-1][1] &gt; codePoint):
256                 self.addMatchUnordered(codePoint)
257                 return
258 
259             self.codePointCount = self.codePointCount + 1
260             if len(self.matches) and self.matches[-1] == (codePoint - 1):
261                 lowCodePoint = self.matches.pop()
262                 self.ranges.append((lowCodePoint, codePoint))
263             elif len(self.ranges) and self.ranges[-1][1] == (codePoint - 1):
264                 priorRange = self.ranges.pop()
265                 self.ranges.append((priorRange[0], codePoint))
266             else:
267                 self.matches.append(codePoint)
268         else:
269             if (len(self.unicodeMatches) and self.unicodeMatches[-1] &gt; codePoint) or (len(self.unicodeRanges) and self.unicodeRanges[-1][1] &gt; codePoint):
270                 self.addMatchUnordered(codePoint)
271                 return
272 
273             self.codePointCount = self.codePointCount + 1
274             if len(self.unicodeMatches) and self.unicodeMatches[-1] == (codePoint - 1):
275                 lowCodePoint = self.unicodeMatches.pop()
276                 self.unicodeRanges.append((lowCodePoint, codePoint))
277             elif len(self.unicodeRanges) and self.unicodeRanges[-1][1] == (codePoint - 1):
278                 priorRange = self.unicodeRanges.pop()
279                 self.unicodeRanges.append((priorRange[0], codePoint))
280             else:
281                 self.unicodeMatches.append(codePoint)
282 
283     def addRange(self, lowCodePoint, highCodePoint):
284         if highCodePoint &gt; MaxBMP:
285             self.hasNonBMPCharacters = True
286         if highCodePoint &lt;= lastASCIICodePoint:
287             if (len(self.matches) and self.matches[-1] &gt; lowCodePoint) or (len(self.ranges) and self.ranges[-1][1] &gt; lowCodePoint):
288                 self.addRangeUnordered(lowCodePoint, highCodePoint)
289                 return
290 
291             self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
292             if len(self.matches) and self.matches[-1] == (lowCodePoint - 1):
293                 lowCodePoint = self.matches.pop()
294             elif len(self.ranges) and self.ranges[-1][1] == (lowCodePoint - 1):
295                 priorRange = self.ranges.pop()
296                 lowCodePoint = priorRange[0]
297             self.ranges.append((lowCodePoint, highCodePoint))
298         elif lowCodePoint &lt;= lastASCIICodePoint:
299             if lowCodePoint == lastASCIICodePoint:
300                 self.addMatch(lowCodePoint)
301             else:
302                 self.addRange(lowCodePoint, lastASCIICodePoint)
303             if highCodePoint == firstUnicodeCodePoint:
304                 self.addMatch(highCodePoint)
305             else:
306                 self.addRange(firstUnicodeCodePoint, highCodePoint)
307         else:
308             if (len(self.unicodeMatches) and self.unicodeMatches[-1] &gt; lowCodePoint) or (len(self.unicodeRanges) and self.unicodeRanges[-1][1] &gt; lowCodePoint):
309                 self.addRangeUnordered(lowCodePoint, highCodePoint)
310                 return
311 
312             self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
313             if len(self.unicodeMatches) and self.unicodeMatches[-1] == (lowCodePoint - 1):
314                 lowCodePoint = self.unicodeMatches.pop()
315                 self.unicodeRanges.append((lowCodePoint, highCodePoint))
316             elif len(self.unicodeRanges) and self.unicodeRanges[-1][1] == (lowCodePoint - 1):
317                 priorRange = self.unicodeRanges.pop()
318                 self.unicodeRanges.append((priorRange[0], highCodePoint))
319             else:
320                 self.unicodeRanges.append((lowCodePoint, highCodePoint))
321 
322     def addMatchUnorderedForMatchesAndRanges(self, codePoint, matches, ranges):
323         if codePoint in matches:
324             return
325         insertLocation = None
326         lowCodePoint = None
327         highCodePoint = None
328         for idx in range(len(matches)):
329             match = matches[idx]
330             if codePoint == match + 1:
331                 lowCodePoint = match
332                 if idx &lt; (len(matches) - 1) and codePoint == matches[idx + 1] - 1:
333                     highCodePoint = matches[idx + 1]
334                     del matches[idx + 1]
335                     self.codePointCount = self.codePointCount - 1
336                 else:
337                     highCodePoint = codePoint
338                 del matches[idx]
339                 self.codePointCount = self.codePointCount - 1
340                 break
341             elif codePoint == match - 1:
342                 lowCodePoint = codePoint
343                 highCodePoint = match
344                 del matches[idx]
345                 self.codePointCount = self.codePointCount - 1
346                 break
347             elif codePoint &lt; match:
348                 insertLocation = idx
349                 break
350 
351         if insertLocation is None:
352             insertLocation = len(matches)
353         if lowCodePoint is None:
354             lowCodePoint = codePoint
355             highCodePoint = codePoint
356 
357         for idx in range(len(ranges)):
358             cur_range = ranges[idx]
359             if lowCodePoint &gt;= cur_range[0] and highCodePoint &lt;= cur_range[1]:
360                 return
361             if lowCodePoint &lt;= (cur_range[1] + 1) and highCodePoint &gt;= (cur_range[0] - 1):
362                 while idx &lt; len(ranges) and highCodePoint &gt;= (ranges[idx][0] - 1):
363                     cur_range = ranges[idx]
364                     lowCodePoint = min(lowCodePoint, cur_range[0])
365                     highCodePoint = max(highCodePoint, cur_range[1])
366                     del ranges[idx]
367                     self.codePointCount = self.codePointCount - (cur_range[1] - cur_range[0]) - 1
368 
369                 ranges.insert(idx, (lowCodePoint, highCodePoint))
370                 self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
371                 return
372             elif highCodePoint &lt; cur_range[0]:
373                 if lowCodePoint != highCodePoint:
374                     ranges.insert(idx, (lowCodePoint, highCodePoint))
375                     self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
376                     return
377                 break
378 
379         if lowCodePoint != highCodePoint:
380             ranges.append((lowCodePoint, highCodePoint))
381             self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
382             return
383 
384         if insertLocation is not None:
385             matches.insert(insertLocation, codePoint)
386             self.codePointCount = self.codePointCount + 1
387 
388     def addRangeUnorderedForMatchesAndRanges(self, lowCodePoint, highCodePoint, matches, ranges):
389         if len(matches) and highCodePoint &gt;= matches[0] and lowCodePoint &lt;= matches[-1]:
390             for idx in range(len(matches)):
391                 match = matches[idx]
392                 if lowCodePoint &lt;= match and highCodePoint &gt;= match:
393                     while idx &lt; len(matches) and highCodePoint &gt;= matches[idx]:
394                         del matches[idx]
395                         self.codePointCount = self.codePointCount - 1
396                     if idx &lt; (len(matches) - 1) and highCodePoint == matches[idx + 1] - 1:
397                         highCodePoint = matches[idx + 1]
398                         del matches[idx + 1]
399                         self.codePointCount = self.codePointCount - 1
400                     break
401                 elif lowCodePoint == match + 1:
402                     lowCodePoint = match
403                     while idx &lt; len(matches) and highCodePoint &gt;= matches[idx]:
404                         del matches[idx]
405                         self.codePointCount = self.codePointCount - 1
406 
407                     if idx &lt; (len(matches) - 1) and highCodePoint == matches[idx + 1] - 1:
408                         highCodePoint = matches[idx + 1]
409                         del matches[idx + 1]
410                         self.codePointCount = self.codePointCount - 1
411                     break
412                 elif highCodePoint == match - 1:
413                     highCodePoint = match
414                     del matches[idx]
415                     self.codePointCount = self.codePointCount - 1
416                     break
417                 elif highCodePoint &lt; match:
418                     break
419 
420         for idx in range(len(ranges)):
421             cur_range = ranges[idx]
422             if lowCodePoint &gt;= cur_range[0] and highCodePoint &lt;= cur_range[1]:
423                 return
424             if lowCodePoint &lt;= (cur_range[1] + 1) and highCodePoint &gt;= (cur_range[0] - 1):
425                 while idx &lt; len(ranges) and highCodePoint &gt;= (ranges[idx][0] - 1):
426                     cur_range = ranges[idx]
427                     lowCodePoint = min(lowCodePoint, cur_range[0])
428                     highCodePoint = max(highCodePoint, cur_range[1])
429                     del ranges[idx]
430                     self.codePointCount = self.codePointCount - (cur_range[1] - cur_range[0]) - 1
431 
432                 ranges.insert(idx, (lowCodePoint, highCodePoint))
433                 self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
434                 return
435             elif highCodePoint &lt; cur_range[0]:
436                 ranges.insert(idx, (lowCodePoint, highCodePoint))
437                 self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
438                 return
439 
440         ranges.append((lowCodePoint, highCodePoint))
441         self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
442 
443     def addMatchUnordered(self, codePoint):
444         if codePoint &lt;= lastASCIICodePoint:
445             self.addMatchUnorderedForMatchesAndRanges(codePoint, self.matches, self.ranges)
446         else:
447             self.addMatchUnorderedForMatchesAndRanges(codePoint, self.unicodeMatches, self.unicodeRanges)
448 
449     def addRangeUnordered(self, lowCodePoint, highCodePoint):
450         if highCodePoint &lt;= lastASCIICodePoint:
451             self.addRangeUnorderedForMatchesAndRanges(lowCodePoint, highCodePoint, self.matches, self.ranges)
452         elif lowCodePoint &gt;= firstUnicodeCodePoint:
453             self.addRangeUnorderedForMatchesAndRanges(lowCodePoint, highCodePoint, self.unicodeMatches, self.unicodeRanges)
454         else:
455             if lowCodePoint == lastASCIICodePoint:
456                 self.addMatchUnorderedForMatchesAndRanges(lowCodePoint, self.matches, self.ranges)
457             else:
458                 self.addRangeUnorderedForMatchesAndRanges(lowCodePoint, lastASCIICodePoint, self.unicodeMatches, self.ranges)
459             if highCodePoint == firstUnicodeCodePoint:
460                 self.addMatchUnorderedForMatchesAndRanges(highCodePoint, self.unicodeMatches, self.unicodeRanges)
461             else:
462                 self.addRangeUnorderedForMatchesAndRanges(firstUnicodeCodePoint, highCodePoint, self.unicodeMatches, self.unicodeRanges)
463 
464     def removeMatchFromRanges(self, codePoint, ranges):
465         for idx in range(len(ranges)):
466             cur_range = ranges[idx]
467             if cur_range[0] &lt;= codePoint and codePoint &lt;= cur_range[1]:
468                 ranges.pop(idx)
469                 if cur_range[0] &lt; codePoint and codePoint &lt; cur_range[1]:
470                     lowRange = (cur_range[0], codePoint - 1)
471                     highRange = (codePoint + 1, cur_range[1])
472                     # Since list.insert inserts before the index given, handle the high range first
473                     if highRange[0] == highRange[1]:
474                         self.addMatchUnordered(highRange[0])
475                     else:
476                         ranges.insert(idx, highRange)
477                     if lowRange[0] == lowRange[1]:
478                         self.addMatchUnordered(lowRange[0])
479                     else:
480                         ranges.insert(idx, lowRange)
481                 else:
482                     if cur_range[0] == codePoint:
483                         cur_range = (codePoint + 1, cur_range[1])
484                     else:
485                         cur_range = (cur_range[0], codePoint - 1)
486                     if cur_range[0] == cur_range[1]:
487                         self.addMatchUnordered(cur_range[0])
488                     else:
489                         ranges.insert(idx, cur_range)
490                 self.codePointCount = self.codePointCount - 1
491                 return
492 
493     def removeMatch(self, codePoint):
494         if codePoint &lt;= lastASCIICodePoint:
495             if codePoint in self.matches:
496                 self.matches.remove(codePoint)
497                 self.codePointCount = self.codePointCount - 1
498             else:
499                 self.removeMatchFromRanges(codePoint, self.ranges)
500         else:
501             if codePoint in self.unicodeMatches:
502                 self.unicodeMatches.remove(codePoint)
503                 self.codePointCount = self.codePointCount - 1
504             else:
505                 self.removeMatchFromRanges(codePoint, self.unicodeRanges)
506 
507     def dumpMatchData(self, file, valuesPerLine, dataList, formatter):
508         valuesThisLine = 0
509         firstValue = True
510 
511         file.write(&quot;{&quot;)
512         for elem in dataList:
513             if firstValue:
514                 firstValue = False
515             else:
516                 file.write(&quot;, &quot;)
517             valuesThisLine = valuesThisLine + 1
518             if valuesThisLine &gt; valuesPerLine:
519                 file.write(&quot;\n                 &quot;)
520                 valuesThisLine = 1
521             formatter(file, elem)
522         file.write(&quot;}&quot;)
523 
524     def dump(self, file, commaAfter):
525         file.write(&quot;static std::unique_ptr&lt;CharacterClass&gt; {}()\n{{\n&quot;.format(self.getCreateFuncName()))
526         file.write(&quot;    // Name = {}, number of codePoints: {}\n&quot;.format(self.name, self.codePointCount))
527         file.write(&quot;    auto characterClass = std::make_unique&lt;CharacterClass&gt;(\n&quot;)
528         file.write(&quot;        std::initializer_list&lt;UChar32&gt;(&quot;)
529         self.dumpMatchData(file, 8, self.matches, lambda file, match: (file.write(&quot;{0:0=#4x}&quot;.format(match))))
530         file.write(&quot;),\n&quot;)
531         file.write(&quot;        std::initializer_list&lt;CharacterRange&gt;(&quot;)
532         self.dumpMatchData(file, 4, self.ranges, lambda file, range: (file.write(&quot;{{{0:0=#4x}, {1:0=#4x}}}&quot;.format(range[0], range[1]))))
533         file.write(&quot;),\n&quot;)
534         file.write(&quot;        std::initializer_list&lt;UChar32&gt;(&quot;)
535         self.dumpMatchData(file, 8, self.unicodeMatches, lambda file, match: (file.write(&quot;{0:0=#6x}&quot;.format(match))))
536         file.write(&quot;),\n&quot;)
537         file.write(&quot;        std::initializer_list&lt;CharacterRange&gt;(&quot;)
538         self.dumpMatchData(file, 4, self.unicodeRanges, lambda file, range: (file.write(&quot;{{{0:0=#6x}, {1:0=#6x}}}&quot;.format(range[0], range[1]))))
539         file.write(&quot;));\n&quot;)
540 
541         file.write(&quot;    characterClass-&gt;m_hasNonBMPCharacters = {};\n&quot;.format((&quot;false&quot;, &quot;true&quot;)[self.hasNonBMPCharacters]))
542         file.write(&quot;    return characterClass;\n}\n\n&quot;)
543 
544     @classmethod
545     def dumpAll(cls, file):
546         for propertyData in cls.allPropertyData:
547             propertyData.dump(file, propertyData != cls.allPropertyData[-1])
548 
549         file.write(&quot;typedef std::unique_ptr&lt;CharacterClass&gt; (*CreateCharacterClass)();\n&quot;)
550         file.write(&quot;static CreateCharacterClass createFunctions[{}] = {{\n   &quot;.format(len(cls.allPropertyData)))
551         functionsOnThisLine = 0
552         for propertyData in cls.allPropertyData:
553             file.write(&quot; {},&quot;.format(propertyData.getCreateFuncName()))
554             functionsOnThisLine = functionsOnThisLine + 1
555             if functionsOnThisLine == 4:
556                 file.write(&quot;\n   &quot;)
557                 functionsOnThisLine = 0
558 
559         file.write(&quot;};\n\n&quot;)
560 
561     @classmethod
562     def createAndDumpHashTable(self, file, propertyDict, tablePrefix):
563         propertyKeys = propertyDict.keys()
564         numberOfKeys = len(propertyKeys)
565         hashSize = ceilingToPowerOf2(numberOfKeys * 2)
566         hashMask = hashSize - 1
567         hashTable = [None] * hashSize
568         valueTable = []
569         tableSize = hashSize
570 
571         keyValuesToHash = []
572         for propertyName in propertyKeys:
573             propertyData = propertyDict[propertyName]
574             keyValuesToHash.append((propertyName, propertyData.getIndex()))
575             for alias in propertyData.aliases:
576                 keyValuesToHash.append((alias, propertyData.getIndex()))
577 
578         for keyValue in keyValuesToHash:
579             key = keyValue[0]
580             hash = stringHash(key) % hashSize
581             while hashTable[hash] is not None:
582                 if hashTable[hash][1] is not None:
583                     hash = hashTable[hash][1]
584                 else:
585                     hashTable[hash] = (hashTable[hash][0], tableSize)
586                     hashTable.append(None)
587                     hash = tableSize
588                     tableSize = tableSize + 1
589 
590             hashTable[hash] = (len(valueTable), None)
591             valueTable.append((key, keyValue[1]))
592 
593         file.write(&quot;static const struct HashIndex {}TableIndex[{}] = {{\n&quot;.format(tablePrefix, len(hashTable)))
594 
595         for tableIndex in hashTable:
596             value = -1
597             next = -1
598             if tableIndex is not None:
599                 value = tableIndex[0]
600                 if tableIndex[1] is not None:
601                     next = tableIndex[1]
602 
603             file.write(&quot;    {{ {}, {} }},\n&quot;.format(value, next))
604 
605         file.write(&quot;};\n\n&quot;)
606 
607         file.write(&quot;static const struct HashValue {}TableValue[{}] = {{\n&quot;.format(tablePrefix, len(valueTable)))
608         for value in valueTable:
609             file.write(&quot;    {{ \&quot;{}\&quot;, {} }},\n&quot;.format(value[0], value[1]))
610         file.write(&quot;};\n\n&quot;)
611 
612         file.write(&quot;static const struct HashTable {}HashTable = \n&quot;.format(tablePrefix))
613         file.write(&quot;    {{ {}, {}, {}TableValue, {}TableIndex }};\n\n&quot;.format(len(valueTable), hashMask, tablePrefix, tablePrefix))
614 
615 
616 class Scripts:
617     def __init__(self):
618         self.allPropertyData = []
619         self.scriptsByName = {}
620         self.scriptExtensionsByName = {}
621         self.unknownScript = PropertyData(&quot;Unknown&quot;)
622         self.unknownScript.setAliases(aliases.scriptAliasesFor(&quot;Unknown&quot;))
623         self.allPropertyData.append(self.unknownScript)
624         self.scriptsParsed = False
625 
626     def parseScriptsFile(self, file):
627         currentScriptName = None
628         currentPropertyData = None
629         # To calculate the Unknown, we gather all the codePoints asigned to a scripts as ranges,
630         # sort them, and then go the list to create the inverse of the assigned ranges.
631         assignedCodePointRanges = []
632 
633         for line in file:
634             line = line.split(&#39;#&#39;, 1)[0]
635             line = line.rstrip()
636             if (not len(line)):
637                 continue
638 
639             fields = line.split(&#39;;&#39;)
640             if (not fields):
641                 continue
642 
643             codePoints = fields[0].strip()
644             scriptName = fields[1].strip()
645 
646             if scriptName != currentScriptName:
647                 currentScriptName = scriptName
648                 currentPropertyData = PropertyData(scriptName)
649                 currentPropertyData.setAliases(aliases.scriptAliasesFor(scriptName))
650                 self.allPropertyData.append(currentPropertyData)
651                 self.scriptsByName[scriptName] = currentPropertyData
652 
653             dotDot = codePoints.find(&quot;..&quot;)
654             if dotDot == -1:
655                 codePoint = int(codePoints, 16)
656                 currentPropertyData.addMatch(codePoint)
657                 assignedCodePointRanges.append((codePoint, codePoint))
658             else:
659                 lowCodePoint = int(codePoints[:dotDot], 16)
660                 highCodePoint = int(codePoints[dotDot + 2:], 16)
661                 currentPropertyData.addRange(lowCodePoint, highCodePoint)
662                 assignedCodePointRanges.append((lowCodePoint, highCodePoint))
663 
664         assignedCodePointRanges.sort(key=lambda range: range[0])
665         lastAssignedCodePoint = 0
666 
667         for range in assignedCodePointRanges:
668             if range[0] - lastAssignedCodePoint &gt; 1:
669                 if range[0] - lastAssignedCodePoint == 2:
670                     self.unknownScript.addMatch(lastAssignedCodePoint + 1)
671                 else:
672                     self.unknownScript.addRange(lastAssignedCodePoint + 1, range[0] - 1)
673             lastAssignedCodePoint = range[1]
674 
675         if lastAssignedCodePoint &lt; MaxUnicode:
676             if MaxUnicode - lastAssignedCodePoint == 1:
677                 self.unknownScript.addMatch(MaxUnicode)
678             else:
679                 self.unknownScript.addRange(lastAssignedCodePoint + 1, MaxUnicode)
680 
681         self.scriptsParsed = True
682 
683     def parseScriptExtensionsFile(self, file):
684         currentPropertyData = None
685         # To calculate the Unknown, we gather all the codePoints asigned to a scripts as ranges,
686         # sort them, and then go the list to create the inverse of the assigned ranges.
687         assignedCodePointRanges = []
688 
689         if not self.scriptsParsed:
690             print(&quot;Error: parsing ScriptExtensions.txt before Scripts.txt&quot;)
691             exit(1)
692 
693         commonScriptExtenstionPropertyData = None
694         inheritedScriptExtensionPropertyData = None
695 
696         scriptName = &quot;Common&quot;
697         if scriptName in self.scriptsByName:
698             commonScriptExtenstionPropertyData = self.scriptsByName[scriptName].makeCopy()
699         else:
700             commonScriptExtenstionPropertyData = PropertyData(scriptName)
701             commonScriptExtenstionPropertyData.setAliases(aliases.scriptAliasesFor(scriptName))
702         self.allPropertyData.append(commonScriptExtenstionPropertyData)
703         self.scriptExtensionsByName[scriptName] = commonScriptExtenstionPropertyData
704 
705         scriptName = &quot;Inherited&quot;
706         if scriptName in self.scriptsByName:
707             inheritedScriptExtensionPropertyData = self.scriptsByName[scriptName].makeCopy()
708         else:
709             inheritedScriptExtensionPropertyData = PropertyData(scriptName)
710             inheritedScriptExtensionPropertyData.setAliases(aliases.scriptAliasesFor(scriptName))
711         self.allPropertyData.append(inheritedScriptExtensionPropertyData)
712         self.scriptExtensionsByName[scriptName] = inheritedScriptExtensionPropertyData
713 
714         for line in file:
715             line = line.split(&#39;#&#39;, 1)[0]
716             line = line.rstrip()
717             if (not len(line)):
718                 continue
719 
720             fields = line.split(&#39;;&#39;)
721             if (not fields):
722                 continue
723 
724             codePoints = fields[0].strip()
725             scriptAliasList = fields[1].strip()
726 
727             for scriptAlias in scriptAliasList.split(&#39; &#39;):
728                 scriptName = aliases.scriptNameForAlias(scriptAlias)
729                 currentPropertyData = None
730 
731                 if scriptName not in self.scriptExtensionsByName:
732                     currentPropertyData = self.scriptsByName[scriptName].makeCopy()
733                     self.allPropertyData.append(currentPropertyData)
734                     self.scriptExtensionsByName[scriptName] = currentPropertyData
735                 else:
736                     currentPropertyData = self.scriptExtensionsByName[scriptName]
737 
738                 dotDot = codePoints.find(&quot;..&quot;)
739                 if dotDot == -1:
740                     codePoint = int(codePoints, 16)
741                     currentPropertyData.addMatch(codePoint)
742                     commonScriptExtenstionPropertyData.removeMatch(codePoint)
743                     inheritedScriptExtensionPropertyData.removeMatch(codePoint)
744                 else:
745                     lowCodePoint = int(codePoints[:dotDot], 16)
746                     highCodePoint = int(codePoints[dotDot + 2:], 16)
747                     currentPropertyData.addRange(lowCodePoint, highCodePoint)
748                     for codePoint in range(lowCodePoint, highCodePoint + 1):
749                         commonScriptExtenstionPropertyData.removeMatch(codePoint)
750                         inheritedScriptExtensionPropertyData.removeMatch(codePoint)
751 
752         # For the scripts that don&#39;t have any additional extension codePoints, copy the script
753         # data to the script extension with the same name
754         for scriptName, propertyData in self.scriptsByName.items():
755             if scriptName not in self.scriptExtensionsByName:
756                 self.scriptExtensionsByName[scriptName] = propertyData
757 
758     def dump(self, file):
759         file.write(&quot;// Scripts:\n&quot;)
760         PropertyData.createAndDumpHashTable(file, self.scriptsByName, &quot;script&quot;)
761 
762         file.write(&quot;// Script_Extensions:\n&quot;)
763         PropertyData.createAndDumpHashTable(file, self.scriptExtensionsByName, &quot;scriptExtension&quot;)
764 
765 
766 class GeneralCategory:
767     def __init__(self, file):
768         self.file = file
769         self.allPropertyData = []
770         self.propertyDataByCategory = {}
771         self.createSpecialPropertyData(&quot;Any&quot;, (0, MaxUnicode))
772         self.createSpecialPropertyData(&quot;ASCII&quot;, (0, lastASCIICodePoint))
773         self.assignedPropertyData = self.createSpecialPropertyData(&quot;Assigned&quot;)
774         self.unassignedProperyData = self.findPropertyGroupFor(&quot;Cn&quot;)[1]
775         self.casedLetterPropertyData = self.findPropertyGroupFor(&quot;LC&quot;)[1]
776         self.lastAddedCodePoint = 0
777 
778     def createSpecialPropertyData(self, name, range=None):
779         propertyData = PropertyData(name)
780         self.allPropertyData.append(propertyData)
781         self.propertyDataByCategory[name] = propertyData
782         if range:
783             propertyData.addRange(range[0], range[1])
784 
785         return propertyData
786 
787     def findPropertyGroupFor(self, categoryAlias):
788         category = aliases.generalCategoryForAlias(categoryAlias)
789         allCategoryAliases = aliases.generalCategoryAliasesFor(category)
790         categoryGroupAlias = categoryAlias[0]
791         categoryGroup = aliases.generalCategoryForAlias(categoryGroupAlias)
792         allCategoryGroupAlias = aliases.generalCategoryAliasesFor(categoryGroup)
793         groupPropertyData = None
794         propertyData = None
795 
796         if categoryGroup not in self.propertyDataByCategory:
797             groupPropertyData = PropertyData(categoryGroup)
798             groupPropertyData.setAliases(allCategoryGroupAlias)
799             self.allPropertyData.append(groupPropertyData)
800             self.propertyDataByCategory[categoryGroup] = groupPropertyData
801         else:
802             groupPropertyData = self.propertyDataByCategory[categoryGroup]
803 
804         if category not in self.propertyDataByCategory:
805             propertyData = PropertyData(category)
806             propertyData.setAliases(allCategoryAliases)
807             self.allPropertyData.append(propertyData)
808             self.propertyDataByCategory[category] = propertyData
809         else:
810             propertyData = self.propertyDataByCategory[category]
811 
812         return (groupPropertyData, propertyData)
813 
814     def addNextCodePoints(self, categoryAlias, codePoint, highCodePoint=None):
815         if codePoint - self.lastAddedCodePoint &gt; 1:
816             propertyDatas = self.findPropertyGroupFor(&quot;Cn&quot;)
817             if codePoint - self.lastAddedCodePoint == 2:
818                 propertyDatas[0].addMatch(self.lastAddedCodePoint + 1)
819                 propertyDatas[1].addMatch(self.lastAddedCodePoint + 1)
820             else:
821                 propertyDatas[0].addRange(self.lastAddedCodePoint + 1, codePoint - 1)
822                 propertyDatas[1].addRange(self.lastAddedCodePoint + 1, codePoint - 1)
823 
824         propertyDatas = self.findPropertyGroupFor(categoryAlias)
825         if highCodePoint:
826             propertyDatas[0].addRange(codePoint, highCodePoint)
827             propertyDatas[1].addRange(codePoint, highCodePoint)
828             if categoryAlias == &quot;Ll&quot; or categoryAlias == &quot;Lt&quot; or categoryAlias == &quot;Lu&quot;:
829                 self.casedLetterPropertyData.addRange(codePoint, highCodePoint)
830             self.assignedPropertyData.addRange(codePoint, highCodePoint)
831 
832             self.lastAddedCodePoint = highCodePoint
833         else:
834             propertyDatas[0].addMatch(codePoint)
835             propertyDatas[1].addMatch(codePoint)
836             if categoryAlias == &quot;Ll&quot; or categoryAlias == &quot;Lt&quot; or categoryAlias == &quot;Lu&quot;:
837                 self.casedLetterPropertyData.addMatch(codePoint)
838             self.assignedPropertyData.addMatch(codePoint)
839 
840             self.lastAddedCodePoint = codePoint
841 
842     def parse(self):
843         lastLineFirstOfRange = None
844         lastLineCodePoint = 0
845         for line in self.file:
846             line = line.split(&#39;#&#39;, 1)[0]
847             line = line.rstrip()
848             if (not len(line)):
849                 continue
850 
851             fields = line.split(&#39;;&#39;)
852             if (not fields):
853                 continue
854 
855             codePoint = int(fields[0].strip(), 16)
856             description = fields[1].strip()
857             categoryAlias = fields[2].strip()
858 
859             if lastLineFirstOfRange:
860                 if description[-5:-1] == &quot;Last&quot;:
861                     self.addNextCodePoints(categoryAlias, lastLineFirstOfRange, codePoint)
862                     lastLineFirstOfRange = None
863                     continue
864                 else:
865                     print(&quot;Malformed First..Last pair of lines&quot;)
866 
867             if description[-6:-1] == &quot;First&quot;:
868                 lastLineFirstOfRange = codePoint
869                 continue
870 
871             self.addNextCodePoints(categoryAlias, codePoint)
872 
873         if self.lastAddedCodePoint &lt; MaxUnicode:
874             propertyDatas = self.findPropertyGroupFor(&quot;Cn&quot;)
875             if MaxUnicode - self.lastAddedCodePoint == 1:
876                 propertyDatas[0].addMatch(MaxUnicode)
877                 propertyDatas[1].addMatch(MaxUnicode)
878             else:
879                 propertyDatas[0].addRange(self.lastAddedCodePoint + 1, MaxUnicode)
880                 propertyDatas[1].addRange(self.lastAddedCodePoint + 1, MaxUnicode)
881 
882     def dump(self, file):
883         file.write(&quot;// General_Category:\n&quot;)
884         PropertyData.createAndDumpHashTable(file, self.propertyDataByCategory, &quot;generalCategory&quot;)
885 
886 
887 class BinaryProperty:
888     def __init__(self):
889         self.allPropertyData = []
890         self.propertyDataByProperty = {}
891 
892     def parsePropertyFile(self, file):
893         currentPropertyName = None
894         currentPropertyData = None
895 
896         for line in file:
897             line = line.split(&#39;#&#39;, 1)[0]
898             line = line.rstrip()
899             if (not len(line)):
900                 continue
901 
902             fields = line.split(&#39;;&#39;)
903             if (not fields):
904                 continue
905 
906             codePoints = fields[0].strip()
907             propertyName = fields[1].strip()
908 
909             if propertyName != currentPropertyName:
910                 if propertyName not in SupportedBinaryProperties:
911                     continue
912 
913                 currentPropertyName = propertyName
914                 currentPropertyData = PropertyData(propertyName)
915                 currentPropertyData.setAliases(aliases.globalAliasesFor(propertyName))
916                 self.allPropertyData.append(currentPropertyData)
917                 self.propertyDataByProperty[propertyName] = currentPropertyData
918 
919             dotDot = codePoints.find(&quot;..&quot;)
920             if dotDot == -1:
921                 currentPropertyData.addMatch(int(codePoints, 16))
922             else:
923                 currentPropertyData.addRange(int(codePoints[:dotDot], 16), int(codePoints[dotDot + 2:], 16))
924 
925     def dump(self, file):
926         file.write(&quot;// binary properties:\n&quot;)
927         PropertyData.createAndDumpHashTable(file, self.propertyDataByProperty, &quot;binaryProperty&quot;)
928 
929 if __name__ == &quot;__main__&quot;:
930     parser = optparse.OptionParser(usage=&quot;usage: %prog &lt;UCD-Directory&gt; &lt;YarrUnicodePropertyData.h&gt;&quot;)
931     (options, args) = parser.parse_args()
932 
933     if len(args) != 2:
934         parser.error(&quot;&lt;UCD-Directory&gt; &lt;YarrUnicodePropertyData.h&gt;&quot;)
935 
936     UCDDirectoryPath = args[0]
937     unicodeProertyDataHPath = args[1]
938 
939     verifyUCDFilesExist()
940 
941     propertyAliasesFile = openUCDFileOrExit(&quot;PropertyAliases.txt&quot;)
942     propertyValueAliasesFile = openUCDFileOrExit(&quot;PropertyValueAliases.txt&quot;)
943     scriptsFile = openUCDFileOrExit(&quot;Scripts.txt&quot;)
944     scriptExtensionsFile = openUCDFileOrExit(&quot;ScriptExtensions.txt&quot;)
945     unicodeDataFile = openUCDFileOrExit(&quot;UnicodeData.txt&quot;)
946     derivedBinaryPropertiesFile = openUCDFileOrExit(&quot;DerivedBinaryProperties.txt&quot;)
947     derivedCorePropertiesFile = openUCDFileOrExit(&quot;DerivedCoreProperties.txt&quot;)
948     derivedNormalizationPropertiesFile = openUCDFileOrExit(&quot;DerivedNormalizationProps.txt&quot;)
949     propListFile = openUCDFileOrExit(&quot;PropList.txt&quot;)
950     emojiDataFile = openUCDFileOrExit(&quot;emoji-data.txt&quot;)
951 
952     aliases = Aliases()
953 
954     propertyDataHFile = openOrExit(unicodeProertyDataHPath, &quot;w&quot;)
955 
956     propertyDataHFile.write(header)
957 
958     aliases.parsePropertyAliasesFile(propertyAliasesFile)
959     aliases.parsePropertyValueAliasesFile(propertyValueAliasesFile)
960 
961     generalCategory = GeneralCategory(unicodeDataFile)
962     generalCategory.parse()
963 
964     binaryProperty = BinaryProperty()
965     binaryProperty.parsePropertyFile(derivedBinaryPropertiesFile)
966     binaryProperty.parsePropertyFile(derivedCorePropertiesFile)
967     binaryProperty.parsePropertyFile(derivedNormalizationPropertiesFile)
968     binaryProperty.parsePropertyFile(propListFile)
969     binaryProperty.parsePropertyFile(emojiDataFile)
970 
971     scripts = Scripts()
972     scripts.parseScriptsFile(scriptsFile)
973     scripts.parseScriptExtensionsFile(scriptExtensionsFile)
974 
975     PropertyData.dumpAll(propertyDataHFile)
976     generalCategory.dump(propertyDataHFile)
977     binaryProperty.dump(propertyDataHFile)
978     scripts.dump(propertyDataHFile)
979 
980     propertyDataHFile.write(footer)
981 
982     exit(0)
    </pre>
  </body>
</html>