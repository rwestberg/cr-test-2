<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3ReduceStrength.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="B3PureCSE.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3SlotBaseValue.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3ReduceStrength.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;B3ReduceStrength.h&quot;
  28 
  29 #if ENABLE(B3_JIT)
  30 
  31 #include &quot;B3AtomicValue.h&quot;
  32 #include &quot;B3BasicBlockInlines.h&quot;
  33 #include &quot;B3BlockInsertionSet.h&quot;
  34 #include &quot;B3ComputeDivisionMagic.h&quot;
  35 #include &quot;B3Dominators.h&quot;

  36 #include &quot;B3InsertionSetInlines.h&quot;
  37 #include &quot;B3MemoryValueInlines.h&quot;
  38 #include &quot;B3PhaseScope.h&quot;
  39 #include &quot;B3PhiChildren.h&quot;
  40 #include &quot;B3ProcedureInlines.h&quot;
  41 #include &quot;B3PureCSE.h&quot;
  42 #include &quot;B3SlotBaseValue.h&quot;
  43 #include &quot;B3StackSlot.h&quot;
  44 #include &quot;B3UpsilonValue.h&quot;
  45 #include &quot;B3ValueKeyInlines.h&quot;
  46 #include &quot;B3ValueInlines.h&quot;
  47 #include &quot;B3Variable.h&quot;
  48 #include &quot;B3VariableValue.h&quot;
  49 #include &lt;wtf/GraphNodeWorklist.h&gt;
  50 #include &lt;wtf/HashMap.h&gt;
  51 #include &lt;wtf/IndexSet.h&gt;
  52 
  53 namespace JSC { namespace B3 {
  54 
  55 namespace {
</pre>
<hr />
<pre>
  97 class IntRange {
  98 public:
  99     IntRange()
 100     {
 101     }
 102 
 103     IntRange(int64_t min, int64_t max)
 104         : m_min(min)
 105         , m_max(max)
 106     {
 107     }
 108 
 109     template&lt;typename T&gt;
 110     static IntRange top()
 111     {
 112         return IntRange(std::numeric_limits&lt;T&gt;::min(), std::numeric_limits&lt;T&gt;::max());
 113     }
 114 
 115     static IntRange top(Type type)
 116     {
<span class="line-modified"> 117         switch (type) {</span>
 118         case Int32:
 119             return top&lt;int32_t&gt;();
 120         case Int64:
 121             return top&lt;int64_t&gt;();
 122         default:
 123             RELEASE_ASSERT_NOT_REACHED();
 124             return IntRange();
 125         }
 126     }
 127 
 128     template&lt;typename T&gt;
 129     static IntRange rangeForMask(T mask)
 130     {
 131         if (!(mask + 1))
 132             return top&lt;T&gt;();
 133         return IntRange(0, mask);
 134     }
 135 
 136     static IntRange rangeForMask(int64_t mask, Type type)
 137     {
<span class="line-modified"> 138         switch (type) {</span>
 139         case Int32:
 140             return rangeForMask&lt;int32_t&gt;(static_cast&lt;int32_t&gt;(mask));
 141         case Int64:
 142             return rangeForMask&lt;int64_t&gt;(mask);
 143         default:
 144             RELEASE_ASSERT_NOT_REACHED();
 145             return IntRange();
 146         }
 147     }
 148 
 149     template&lt;typename T&gt;
 150     static IntRange rangeForZShr(int32_t shiftAmount)
 151     {
 152         typename std::make_unsigned&lt;T&gt;::type mask = 0;
 153         mask--;
 154         mask &gt;&gt;= shiftAmount;
 155         return rangeForMask&lt;T&gt;(static_cast&lt;T&gt;(mask));
 156     }
 157 
 158     static IntRange rangeForZShr(int32_t shiftAmount, Type type)
 159     {
<span class="line-modified"> 160         switch (type) {</span>
 161         case Int32:
 162             return rangeForZShr&lt;int32_t&gt;(shiftAmount);
 163         case Int64:
 164             return rangeForZShr&lt;int64_t&gt;(shiftAmount);
 165         default:
 166             RELEASE_ASSERT_NOT_REACHED();
 167             return IntRange();
 168         }
 169     }
 170 
 171     int64_t min() const { return m_min; }
 172     int64_t max() const { return m_max; }
 173 
 174     void dump(PrintStream&amp; out) const
 175     {
 176         out.print(&quot;[&quot;, m_min, &quot;,&quot;, m_max, &quot;]&quot;);
 177     }
 178 
 179     template&lt;typename T&gt;
 180     bool couldOverflowAdd(const IntRange&amp; other)
 181     {
 182         return sumOverflows&lt;T&gt;(m_min, other.m_min)
 183             || sumOverflows&lt;T&gt;(m_min, other.m_max)
 184             || sumOverflows&lt;T&gt;(m_max, other.m_min)
 185             || sumOverflows&lt;T&gt;(m_max, other.m_max);
 186     }
 187 
 188     bool couldOverflowAdd(const IntRange&amp; other, Type type)
 189     {
<span class="line-modified"> 190         switch (type) {</span>
 191         case Int32:
 192             return couldOverflowAdd&lt;int32_t&gt;(other);
 193         case Int64:
 194             return couldOverflowAdd&lt;int64_t&gt;(other);
 195         default:
 196             return true;
 197         }
 198     }
 199 
 200     template&lt;typename T&gt;
 201     bool couldOverflowSub(const IntRange&amp; other)
 202     {
 203         return differenceOverflows&lt;T&gt;(m_min, other.m_min)
 204             || differenceOverflows&lt;T&gt;(m_min, other.m_max)
 205             || differenceOverflows&lt;T&gt;(m_max, other.m_min)
 206             || differenceOverflows&lt;T&gt;(m_max, other.m_max);
 207     }
 208 
 209     bool couldOverflowSub(const IntRange&amp; other, Type type)
 210     {
<span class="line-modified"> 211         switch (type) {</span>
 212         case Int32:
 213             return couldOverflowSub&lt;int32_t&gt;(other);
 214         case Int64:
 215             return couldOverflowSub&lt;int64_t&gt;(other);
 216         default:
 217             return true;
 218         }
 219     }
 220 
 221     template&lt;typename T&gt;
 222     bool couldOverflowMul(const IntRange&amp; other)
 223     {
 224         return productOverflows&lt;T&gt;(m_min, other.m_min)
 225             || productOverflows&lt;T&gt;(m_min, other.m_max)
 226             || productOverflows&lt;T&gt;(m_max, other.m_min)
 227             || productOverflows&lt;T&gt;(m_max, other.m_max);
 228     }
 229 
 230     bool couldOverflowMul(const IntRange&amp; other, Type type)
 231     {
<span class="line-modified"> 232         switch (type) {</span>
 233         case Int32:
 234             return couldOverflowMul&lt;int32_t&gt;(other);
 235         case Int64:
 236             return couldOverflowMul&lt;int64_t&gt;(other);
 237         default:
 238             return true;
 239         }
 240     }
 241 
 242     template&lt;typename T&gt;
 243     IntRange shl(int32_t shiftAmount)
 244     {
 245         T newMin = static_cast&lt;T&gt;(m_min) &lt;&lt; static_cast&lt;T&gt;(shiftAmount);
 246         T newMax = static_cast&lt;T&gt;(m_max) &lt;&lt; static_cast&lt;T&gt;(shiftAmount);
 247 
 248         if ((newMin &gt;&gt; shiftAmount) != static_cast&lt;T&gt;(m_min))
 249             newMin = std::numeric_limits&lt;T&gt;::min();
 250         if ((newMax &gt;&gt; shiftAmount) != static_cast&lt;T&gt;(m_max))
 251             newMax = std::numeric_limits&lt;T&gt;::max();
 252 
 253         return IntRange(newMin, newMax);
 254     }
 255 
 256     IntRange shl(int32_t shiftAmount, Type type)
 257     {
<span class="line-modified"> 258         switch (type) {</span>
 259         case Int32:
 260             return shl&lt;int32_t&gt;(shiftAmount);
 261         case Int64:
 262             return shl&lt;int64_t&gt;(shiftAmount);
 263         default:
 264             RELEASE_ASSERT_NOT_REACHED();
 265             return IntRange();
 266         }
 267     }
 268 
 269     template&lt;typename T&gt;
 270     IntRange sShr(int32_t shiftAmount)
 271     {
 272         T newMin = static_cast&lt;T&gt;(m_min) &gt;&gt; static_cast&lt;T&gt;(shiftAmount);
 273         T newMax = static_cast&lt;T&gt;(m_max) &gt;&gt; static_cast&lt;T&gt;(shiftAmount);
 274 
 275         return IntRange(newMin, newMax);
 276     }
 277 
 278     IntRange sShr(int32_t shiftAmount, Type type)
 279     {
<span class="line-modified"> 280         switch (type) {</span>
 281         case Int32:
 282             return sShr&lt;int32_t&gt;(shiftAmount);
 283         case Int64:
 284             return sShr&lt;int64_t&gt;(shiftAmount);
 285         default:
 286             RELEASE_ASSERT_NOT_REACHED();
 287             return IntRange();
 288         }
 289     }
 290 
 291     template&lt;typename T&gt;
 292     IntRange zShr(int32_t shiftAmount)
 293     {
 294         // This is an awkward corner case for all of the other logic.
 295         if (!shiftAmount)
 296             return *this;
 297 
 298         // If the input range may be negative, then all we can say about the output range is that it
 299         // will be masked. That&#39;s because -1 right shifted just produces that mask.
 300         if (m_min &lt; 0)
 301             return rangeForZShr&lt;T&gt;(shiftAmount);
 302 
 303         // If the input range is non-negative, then this just brings the range closer to zero.
 304         typedef typename std::make_unsigned&lt;T&gt;::type UnsignedT;
 305         UnsignedT newMin = static_cast&lt;UnsignedT&gt;(m_min) &gt;&gt; static_cast&lt;UnsignedT&gt;(shiftAmount);
 306         UnsignedT newMax = static_cast&lt;UnsignedT&gt;(m_max) &gt;&gt; static_cast&lt;UnsignedT&gt;(shiftAmount);
 307 
 308         return IntRange(newMin, newMax);
 309     }
 310 
 311     IntRange zShr(int32_t shiftAmount, Type type)
 312     {
<span class="line-modified"> 313         switch (type) {</span>
 314         case Int32:
 315             return zShr&lt;int32_t&gt;(shiftAmount);
 316         case Int64:
 317             return zShr&lt;int64_t&gt;(shiftAmount);
 318         default:
 319             RELEASE_ASSERT_NOT_REACHED();
 320             return IntRange();
 321         }
 322     }
 323 
 324     template&lt;typename T&gt;
 325     IntRange add(const IntRange&amp; other)
 326     {
 327         if (couldOverflowAdd&lt;T&gt;(other))
 328             return top&lt;T&gt;();
 329         return IntRange(m_min + other.m_min, m_max + other.m_max);
 330     }
 331 
 332     IntRange add(const IntRange&amp; other, Type type)
 333     {
<span class="line-modified"> 334         switch (type) {</span>
 335         case Int32:
 336             return add&lt;int32_t&gt;(other);
 337         case Int64:
 338             return add&lt;int64_t&gt;(other);
 339         default:
 340             RELEASE_ASSERT_NOT_REACHED();
 341             return IntRange();
 342         }
 343     }
 344 
 345     template&lt;typename T&gt;
 346     IntRange sub(const IntRange&amp; other)
 347     {
 348         if (couldOverflowSub&lt;T&gt;(other))
 349             return top&lt;T&gt;();
 350         return IntRange(m_min - other.m_max, m_max - other.m_min);
 351     }
 352 
 353     IntRange sub(const IntRange&amp; other, Type type)
 354     {
<span class="line-modified"> 355         switch (type) {</span>
 356         case Int32:
 357             return sub&lt;int32_t&gt;(other);
 358         case Int64:
 359             return sub&lt;int64_t&gt;(other);
 360         default:
 361             RELEASE_ASSERT_NOT_REACHED();
 362             return IntRange();
 363         }
 364     }
 365 
 366     template&lt;typename T&gt;
 367     IntRange mul(const IntRange&amp; other)
 368     {
 369         if (couldOverflowMul&lt;T&gt;(other))
 370             return top&lt;T&gt;();
 371         return IntRange(
 372             std::min(
 373                 std::min(m_min * other.m_min, m_min * other.m_max),
 374                 std::min(m_max * other.m_min, m_max * other.m_max)),
 375             std::max(
 376                 std::max(m_min * other.m_min, m_min * other.m_max),
 377                 std::max(m_max * other.m_min, m_max * other.m_max)));
 378     }
 379 
 380     IntRange mul(const IntRange&amp; other, Type type)
 381     {
<span class="line-modified"> 382         switch (type) {</span>
 383         case Int32:
 384             return mul&lt;int32_t&gt;(other);
 385         case Int64:
 386             return mul&lt;int64_t&gt;(other);
 387         default:
 388             RELEASE_ASSERT_NOT_REACHED();
 389             return IntRange();
 390         }
 391     }
 392 
 393 private:
 394     int64_t m_min { 0 };
 395     int64_t m_max { 0 };
 396 };
 397 
 398 class ReduceStrength {
 399 public:
 400     ReduceStrength(Procedure&amp; proc)
 401         : m_proc(proc)
 402         , m_insertionSet(proc)
 403         , m_blockInsertionSet(proc)

 404     {
 405     }
 406 
 407     bool run()
 408     {
 409         bool result = false;
 410         bool first = true;
 411         unsigned index = 0;
 412         do {
 413             m_changed = false;
 414             m_changedCFG = false;
 415             ++index;
 416 
 417             if (first)
 418                 first = false;
 419             else if (B3ReduceStrengthInternal::verbose) {
 420                 dataLog(&quot;B3 after iteration #&quot;, index - 1, &quot; of reduceStrength:\n&quot;);
 421                 dataLog(m_proc);
 422             }
 423 
 424             simplifyCFG();
 425 
 426             if (m_changedCFG) {
 427                 m_proc.resetReachability();
 428                 m_proc.invalidateCFG();
 429                 m_changed = true;
 430             }
 431 
 432             // We definitely want to do DCE before we do CSE so that we don&#39;t hoist things. For
 433             // example:
 434             //
 435             // @dead = Mul(@a, @b)
 436             // ... lots of control flow and stuff
 437             // @thing = Mul(@a, @b)
 438             //
 439             // If we do CSE before DCE, we will remove @thing and keep @dead. Effectively, we will
 440             // &quot;hoist&quot; @thing. On the other hand, if we run DCE before CSE, we will kill @dead and
 441             // keep @thing. That&#39;s better, since we usually want things to stay wherever the client
 442             // put them. We&#39;re not actually smart enough to move things around at random.
<span class="line-modified"> 443             killDeadCode();</span>

 444 
 445             simplifySSA();
 446 
 447             if (m_proc.optLevel() &gt;= 2) {
 448                 m_proc.resetValueOwners();
 449                 m_dominators = &amp;m_proc.dominators(); // Recompute if necessary.
 450                 m_pureCSE.clear();
 451             }
 452 
 453             for (BasicBlock* block : m_proc.blocksInPreOrder()) {
 454                 m_block = block;
 455 
 456                 for (m_index = 0; m_index &lt; block-&gt;size(); ++m_index) {
 457                     if (B3ReduceStrengthInternal::verbose) {
 458                         dataLog(
 459                             &quot;Looking at &quot;, *block, &quot; #&quot;, m_index, &quot;: &quot;,
 460                             deepDump(m_proc, block-&gt;at(m_index)), &quot;\n&quot;);
 461                     }
 462                     m_value = m_block-&gt;at(m_index);
 463                     m_value-&gt;performSubstitution();
</pre>
<hr />
<pre>
 585                 if (m_value-&gt;child(1)-&gt;opcode() == Neg) {
 586                     replaceWithNew&lt;Value&gt;(Sub, m_value-&gt;origin(), m_value-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
 587                     break;
 588                 }
 589 
 590                 // Turn this: Integer Add(Neg(value), otherValue)
 591                 // Into this: Sub(otherValue, value)
 592                 if (m_value-&gt;child(0)-&gt;opcode() == Neg) {
 593                     replaceWithNew&lt;Value&gt;(Sub, m_value-&gt;origin(), m_value-&gt;child(1), m_value-&gt;child(0)-&gt;child(0));
 594                     break;
 595                 }
 596 
 597                 // Turn this: Integer Add(Sub(0, value), -1)
 598                 // Into this: BitXor(value, -1)
 599                 if (m_value-&gt;child(0)-&gt;opcode() == Sub
 600                     &amp;&amp; m_value-&gt;child(1)-&gt;isInt(-1)
 601                     &amp;&amp; m_value-&gt;child(0)-&gt;child(0)-&gt;isInt(0)) {
 602                     replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(1), m_value-&gt;child(1));
 603                     break;
 604                 }



 605             }
 606 
 607             break;
 608 
 609         case Sub:
 610             // Turn this: Sub(constant1, constant2)
 611             // Into this: constant1 - constant2
 612             if (Value* constantSub = m_value-&gt;child(0)-&gt;subConstant(m_proc, m_value-&gt;child(1))) {
 613                 replaceWithNewValue(constantSub);
 614                 break;
 615             }
 616 
 617             if (m_value-&gt;isInteger()) {
 618                 // Turn this: Sub(value, constant)
 619                 // Into this: Add(value, -constant)
 620                 if (Value* negatedConstant = m_value-&gt;child(1)-&gt;negConstant(m_proc)) {
 621                     m_insertionSet.insertValue(m_index, negatedConstant);
 622                     replaceWithNew&lt;Value&gt;(
 623                         Add, m_value-&gt;origin(), m_value-&gt;child(0), negatedConstant);
 624                     break;
</pre>
<hr />
<pre>
 627                 // Turn this: Sub(0, value)
 628                 // Into this: Neg(value)
 629                 if (m_value-&gt;child(0)-&gt;isInt(0)) {
 630                     replaceWithNew&lt;Value&gt;(Neg, m_value-&gt;origin(), m_value-&gt;child(1));
 631                     break;
 632                 }
 633 
 634                 // Turn this: Sub(value, value)
 635                 // Into this: 0
 636                 if (m_value-&gt;child(0) == m_value-&gt;child(1)) {
 637                     replaceWithNewValue(m_proc.addIntConstant(m_value, 0));
 638                     break;
 639                 }
 640 
 641                 // Turn this: Sub(value, Neg(otherValue))
 642                 // Into this: Add(value, otherValue)
 643                 if (m_value-&gt;child(1)-&gt;opcode() == Neg) {
 644                     replaceWithNew&lt;Value&gt;(Add, m_value-&gt;origin(), m_value-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
 645                     break;
 646                 }




































 647             }
 648 
 649             break;
 650 
 651         case Neg:
 652             // Turn this: Neg(constant)
 653             // Into this: -constant
 654             if (Value* constant = m_value-&gt;child(0)-&gt;negConstant(m_proc)) {
 655                 replaceWithNewValue(constant);
 656                 break;
 657             }
 658 
 659             // Turn this: Neg(Neg(value))
 660             // Into this: value
 661             if (m_value-&gt;child(0)-&gt;opcode() == Neg) {
 662                 replaceWithIdentity(m_value-&gt;child(0)-&gt;child(0));
 663                 break;
 664             }
 665 
<span class="line-modified"> 666             // Turn this: Integer Neg(Sub(value, otherValue))</span>
<span class="line-modified"> 667             // Into this: Sub(otherValue, value)</span>
<span class="line-modified"> 668             if (m_value-&gt;isInteger() &amp;&amp; m_value-&gt;child(0)-&gt;opcode() == Sub) {</span>
<span class="line-modified"> 669                 replaceWithNew&lt;Value&gt;(Sub, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(1), m_value-&gt;child(0)-&gt;child(0));</span>
<span class="line-modified"> 670                 break;</span>















 671             }
 672 

 673             break;
 674 
 675         case Mul:
 676             handleCommutativity();
 677 
 678             // Turn this: Mul(constant1, constant2)
 679             // Into this: constant1 * constant2
 680             if (Value* value = m_value-&gt;child(0)-&gt;mulConstant(m_proc, m_value-&gt;child(1))) {
 681                 replaceWithNewValue(value);
 682                 break;
 683             }
 684 
 685             if (m_value-&gt;child(1)-&gt;hasInt()) {
 686                 int64_t factor = m_value-&gt;child(1)-&gt;asInt();
 687 
 688                 // Turn this: Mul(value, 0)
 689                 // Into this: 0
 690                 // Note that we don&#39;t do this for doubles because that&#39;s wrong. For example, -1 * 0
 691                 // and 1 * 0 yield different results.
 692                 if (!factor) {
 693                     replaceWithIdentity(m_value-&gt;child(1));
 694                     break;
 695                 }
 696 
 697                 // Turn this: Mul(value, 1)
 698                 // Into this: value
 699                 if (factor == 1) {
 700                     replaceWithIdentity(m_value-&gt;child(0));
 701                     break;
 702                 }
 703 
 704                 // Turn this: Mul(value, -1)
<span class="line-modified"> 705                 // Into this: Sub(0, value)</span>
 706                 if (factor == -1) {
<span class="line-modified"> 707                     replaceWithNewValue(</span>
<span class="line-removed"> 708                         m_proc.add&lt;Value&gt;(</span>
<span class="line-removed"> 709                             Sub, m_value-&gt;origin(),</span>
<span class="line-removed"> 710                             m_insertionSet.insertIntConstant(m_index, m_value, 0),</span>
<span class="line-removed"> 711                             m_value-&gt;child(0)));</span>
 712                     break;
 713                 }
 714 
 715                 // Turn this: Mul(value, constant)
 716                 // Into this: Shl(value, log2(constant))
 717                 if (hasOneBitSet(factor)) {
 718                     unsigned shiftAmount = WTF::fastLog2(static_cast&lt;uint64_t&gt;(factor));
 719                     replaceWithNewValue(
 720                         m_proc.add&lt;Value&gt;(
 721                             Shl, m_value-&gt;origin(), m_value-&gt;child(0),
 722                             m_insertionSet.insert&lt;Const32Value&gt;(
 723                                 m_index, m_value-&gt;origin(), shiftAmount)));
 724                     break;
 725                 }
 726             } else if (m_value-&gt;child(1)-&gt;hasDouble()) {
 727                 double factor = m_value-&gt;child(1)-&gt;asDouble();
 728 
 729                 // Turn this: Mul(value, 1)
 730                 // Into this: value
 731                 if (factor == 1) {
 732                     replaceWithIdentity(m_value-&gt;child(0));
 733                     break;
 734                 }
 735             }
 736 

















 737             break;
 738 
 739         case Div:
 740             // Turn this: Div(constant1, constant2)
 741             // Into this: constant1 / constant2
 742             // Note that this uses Div&lt;Chill&gt; semantics. That&#39;s fine, because the rules for Div
 743             // are strictly weaker: it has corner cases where it&#39;s allowed to do anything it
 744             // likes.
 745             if (replaceWithNewValue(m_value-&gt;child(0)-&gt;divConstant(m_proc, m_value-&gt;child(1))))
 746                 break;
 747 
 748             if (m_value-&gt;child(1)-&gt;hasInt()) {
 749                 switch (m_value-&gt;child(1)-&gt;asInt()) {
 750                 case -1:
 751                     // Turn this: Div(value, -1)
 752                     // Into this: Neg(value)
 753                     replaceWithNewValue(
 754                         m_proc.add&lt;Value&gt;(Neg, m_value-&gt;origin(), m_value-&gt;child(0)));
 755                     break;
 756 
</pre>
<hr />
<pre>
1183             // Turn this: BitXor(value, zero-constant)
1184             // Into this: value.
1185             if (m_value-&gt;child(1)-&gt;isInt(0)) {
1186                 replaceWithIdentity(m_value-&gt;child(0));
1187                 break;
1188             }
1189 
1190             if (handleBitAndDistributivity())
1191                 break;
1192 
1193             break;
1194 
1195         case Shl:
1196             // Turn this: Shl(constant1, constant2)
1197             // Into this: constant1 &lt;&lt; constant2
1198             if (Value* constant = m_value-&gt;child(0)-&gt;shlConstant(m_proc, m_value-&gt;child(1))) {
1199                 replaceWithNewValue(constant);
1200                 break;
1201             }
1202 













1203             handleShiftAmount();
1204             break;
1205 
1206         case SShr:
1207             // Turn this: SShr(constant1, constant2)
1208             // Into this: constant1 &gt;&gt; constant2
1209             if (Value* constant = m_value-&gt;child(0)-&gt;sShrConstant(m_proc, m_value-&gt;child(1))) {
1210                 replaceWithNewValue(constant);
1211                 break;
1212             }
1213 
1214             if (m_value-&gt;child(1)-&gt;hasInt32()
1215                 &amp;&amp; m_value-&gt;child(0)-&gt;opcode() == Shl
1216                 &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt32()
1217                 &amp;&amp; m_value-&gt;child(1)-&gt;asInt32() == m_value-&gt;child(0)-&gt;child(1)-&gt;asInt32()) {
1218                 switch (m_value-&gt;child(1)-&gt;asInt32()) {
1219                 case 16:
1220                     if (m_value-&gt;type() == Int32) {
1221                         // Turn this: SShr(Shl(value, 16), 16)
1222                         // Into this: SExt16(value)
</pre>
<hr />
<pre>
2080                 break;
2081             }
2082 
2083             if (m_proc.optLevel() &gt;= 2) {
2084                 // If a check for the same property dominates us, we can kill the branch. This sort
2085                 // of makes sense here because it&#39;s cheap, but hacks like this show that we&#39;re going
2086                 // to need SCCP.
2087                 Value* check = m_pureCSE.findMatch(
2088                     ValueKey(Check, Void, m_value-&gt;child(0)), m_block, *m_dominators);
2089                 if (check) {
2090                     // The Check would have side-exited if child(0) was non-zero. So, it must be
2091                     // zero here.
2092                     m_block-&gt;taken().block()-&gt;removePredecessor(m_block);
2093                     m_value-&gt;replaceWithJump(m_block, m_block-&gt;notTaken());
2094                     m_changedCFG = true;
2095                 }
2096             }
2097             break;
2098         }
2099 























2100         default:
2101             break;
2102         }
2103     }
2104 
2105     // Find a node that:
2106     //     - functor(node) returns true.
2107     //     - it&#39;s reachable from the given node via children.
2108     //     - it&#39;s in the last &quot;bound&quot; slots in the current basic block.
2109     // This algorithm is optimized under the assumption that the bound is small.
2110     template&lt;typename Functor&gt;
2111     Value* findRecentNodeMatching(Value* start, unsigned bound, const Functor&amp; functor)
2112     {
2113         unsigned startIndex = bound &lt; m_index ? m_index - bound : 0;
2114         Value* result = nullptr;
2115         start-&gt;walk(
2116             [&amp;] (Value* value) -&gt; Value::WalkStatus {
2117                 bool found = false;
2118                 for (unsigned i = startIndex; i &lt;= m_index; ++i) {
2119                     if (m_block-&gt;at(i) == value)
</pre>
<hr />
<pre>
2134 
2135     // This specializes a sequence of code up to a Select. This doesn&#39;t work when we&#39;re at a
2136     // terminal. It would be cool to fix that eventually. The main problem is that instead of
2137     // splitting the block, we should just insert the then/else blocks. We&#39;ll have to create
2138     // double the Phis and double the Upsilons. It&#39;ll probably be the sort of optimization that
2139     // we want to do only after we&#39;ve done loop optimizations, since this will *definitely*
2140     // obscure things. In fact, even this simpler form of select specialization will possibly
2141     // obscure other optimizations. It would be great to have two modes of strength reduction,
2142     // one that does obscuring optimizations and runs late, and another that does not do
2143     // obscuring optimizations and runs early.
2144     // FIXME: Make select specialization handle branches.
2145     // FIXME: Have a form of strength reduction that does no obscuring optimizations and runs
2146     // early.
2147     void specializeSelect(Value* source)
2148     {
2149         if (B3ReduceStrengthInternal::verbose)
2150             dataLog(&quot;Specializing select: &quot;, deepDump(m_proc, source), &quot;\n&quot;);
2151 
2152         // This mutates startIndex to account for the fact that m_block got the front of it
2153         // chopped off.
<span class="line-modified">2154         BasicBlock* predecessor =</span>
<span class="line-modified">2155             m_blockInsertionSet.splitForward(m_block, m_index, &amp;m_insertionSet);</span>



2156 
2157         // Splitting will commit the insertion set, which changes the exact position of the
2158         // source. That&#39;s why we do the search after splitting.
2159         unsigned startIndex = UINT_MAX;
2160         for (unsigned i = predecessor-&gt;size(); i--;) {
2161             if (predecessor-&gt;at(i) == source) {
2162                 startIndex = i;
2163                 break;
2164             }
2165         }
2166 
2167         RELEASE_ASSERT(startIndex != UINT_MAX);
2168 
2169         // By BasicBlock convention, caseIndex == 0 =&gt; then, caseIndex == 1 =&gt; else.
2170         static const unsigned numCases = 2;
2171         BasicBlock* cases[numCases];
2172         for (unsigned i = 0; i &lt; numCases; ++i)
2173             cases[i] = m_blockInsertionSet.insertBefore(m_block);
2174 
2175         HashMap&lt;Value*, Value*&gt; mappings[2];
</pre>
<hr />
<pre>
2266             return true;
2267 
2268         return false;
2269     }
2270 
2271     // Turn this: Add(constant, value)
2272     // Into this: Add(value, constant)
2273     //
2274     // Also:
2275     // Turn this: Add(value1, value2)
2276     // Into this: Add(value2, value1)
2277     // If we decide that value2 coming first is the canonical ordering.
2278     void handleCommutativity()
2279     {
2280         if (shouldSwapBinaryOperands(m_value)) {
2281             std::swap(m_value-&gt;child(0), m_value-&gt;child(1));
2282             m_changed = true;
2283         }
2284     }
2285 












































2286     // For Op==BitOr or BitXor, turn any of these:
2287     //      Op(BitAnd(x1, x2), BitAnd(x1, x3))
2288     //      Op(BitAnd(x2, x1), BitAnd(x1, x3))
2289     //      Op(BitAnd(x1, x2), BitAnd(x3, x1))
2290     //      Op(BitAnd(x2, x1), BitAnd(x3, x1))
2291     // Into this: BitAnd(Op(x2, x3), x1)
2292     // And any of these:
2293     //      Op(BitAnd(x1, x2), x1)
2294     //      Op(BitAnd(x2, x1), x1)
2295     //      Op(x1, BitAnd(x1, x2))
2296     //      Op(x1, BitAnd(x2, x1))
2297     // Into this: BitAnd(Op(x2, x1), x1)
2298     // This second set is equivalent to doing x1 =&gt; BitAnd(x1, x1), and then applying the first set.
2299     // It does not reduce the number of operations executed, but provides some useful normalization: we prefer to have BitAnd at the outermost, then BitXor, and finally BitOr at the innermost
2300     bool handleBitAndDistributivity()
2301     {
2302         ASSERT(m_value-&gt;opcode() == BitOr || m_value-&gt;opcode() == BitXor);
2303         Value* x1 = nullptr;
2304         Value* x2 = nullptr;
2305         Value* x3 = nullptr;
</pre>
<hr />
<pre>
2324         } else if (m_value-&gt;child(0)-&gt;opcode() == BitAnd) {
2325             if (m_value-&gt;child(0)-&gt;child(0) == m_value-&gt;child(1)) {
2326                 x1 = x3 = m_value-&gt;child(1);
2327                 x2 = m_value-&gt;child(0)-&gt;child(1);
2328             } else if (m_value-&gt;child(0)-&gt;child(1) == m_value-&gt;child(1)) {
2329                 x1 = x3 = m_value-&gt;child(1);
2330                 x2 = m_value-&gt;child(0)-&gt;child(0);
2331             }
2332         } else if (m_value-&gt;child(1)-&gt;opcode() == BitAnd) {
2333             if (m_value-&gt;child(1)-&gt;child(0) == m_value-&gt;child(0)) {
2334                 x1 = x3 = m_value-&gt;child(0);
2335                 x2 = m_value-&gt;child(1)-&gt;child(1);
2336             } else if (m_value-&gt;child(1)-&gt;child(1) == m_value-&gt;child(0)) {
2337                 x1 = x3 = m_value-&gt;child(0);
2338                 x2 = m_value-&gt;child(1)-&gt;child(0);
2339             }
2340         }
2341         if (x1 != nullptr) {
2342             ASSERT(x2 != nullptr &amp;&amp; x3 != nullptr);
2343             Value* bitOp = m_insertionSet.insert&lt;Value&gt;(m_index, m_value-&gt;opcode(), m_value-&gt;origin(), x2, x3);
<span class="line-modified">2344             replaceWithNew&lt;Value&gt;(BitAnd, m_value-&gt;origin(), bitOp, x1);</span>
2345             return true;
2346         }
2347         return false;
2348     }
2349 
2350     struct CanonicalizedComparison {
2351         Opcode opcode;
2352         Value* operands[2];
2353     };
2354     static CanonicalizedComparison canonicalizeComparison(Value* value)
2355     {
2356         auto flip = [] (Opcode opcode) {
2357             switch (opcode) {
2358             case LessThan:
2359                 return GreaterThan;
2360             case GreaterThan:
2361                 return LessThan;
2362             case LessEqual:
2363                 return GreaterEqual;
2364             case GreaterEqual:
</pre>
<hr />
<pre>
2620     {
2621         if (m_changedCFG) {
2622             m_proc.resetReachability();
2623             m_proc.invalidateCFG();
2624             m_dominators = nullptr; // Dominators are not valid anymore, and we don&#39;t need them yet.
2625             m_changed = true;
2626         }
2627     }
2628 
2629     void checkPredecessorValidity()
2630     {
2631         if (!shouldValidateIRAtEachPhase())
2632             return;
2633 
2634         for (BasicBlock* block : m_proc) {
2635             for (BasicBlock* successor : block-&gt;successorBlocks())
2636                 RELEASE_ASSERT(successor-&gt;containsPredecessor(block));
2637         }
2638     }
2639 
<span class="line-removed">2640     void killDeadCode()</span>
<span class="line-removed">2641     {</span>
<span class="line-removed">2642         GraphNodeWorklist&lt;Value*, IndexSet&lt;Value*&gt;&gt; worklist;</span>
<span class="line-removed">2643         Vector&lt;UpsilonValue*, 64&gt; upsilons;</span>
<span class="line-removed">2644         for (BasicBlock* block : m_proc) {</span>
<span class="line-removed">2645             for (Value* value : *block) {</span>
<span class="line-removed">2646                 Effects effects;</span>
<span class="line-removed">2647                 // We don&#39;t care about effects of SSA operations, since we model them more</span>
<span class="line-removed">2648                 // accurately than the effects() method does.</span>
<span class="line-removed">2649                 if (value-&gt;opcode() != Phi &amp;&amp; value-&gt;opcode() != Upsilon)</span>
<span class="line-removed">2650                     effects = value-&gt;effects();</span>
<span class="line-removed">2651 </span>
<span class="line-removed">2652                 if (effects.mustExecute())</span>
<span class="line-removed">2653                     worklist.push(value);</span>
<span class="line-removed">2654 </span>
<span class="line-removed">2655                 if (UpsilonValue* upsilon = value-&gt;as&lt;UpsilonValue&gt;())</span>
<span class="line-removed">2656                     upsilons.append(upsilon);</span>
<span class="line-removed">2657             }</span>
<span class="line-removed">2658         }</span>
<span class="line-removed">2659         for (;;) {</span>
<span class="line-removed">2660             while (Value* value = worklist.pop()) {</span>
<span class="line-removed">2661                 for (Value* child : value-&gt;children())</span>
<span class="line-removed">2662                     worklist.push(child);</span>
<span class="line-removed">2663             }</span>
<span class="line-removed">2664 </span>
<span class="line-removed">2665             bool didPush = false;</span>
<span class="line-removed">2666             for (size_t upsilonIndex = 0; upsilonIndex &lt; upsilons.size(); ++upsilonIndex) {</span>
<span class="line-removed">2667                 UpsilonValue* upsilon = upsilons[upsilonIndex];</span>
<span class="line-removed">2668                 if (worklist.saw(upsilon-&gt;phi())) {</span>
<span class="line-removed">2669                     worklist.push(upsilon);</span>
<span class="line-removed">2670                     upsilons[upsilonIndex--] = upsilons.last();</span>
<span class="line-removed">2671                     upsilons.takeLast();</span>
<span class="line-removed">2672                     didPush = true;</span>
<span class="line-removed">2673                 }</span>
<span class="line-removed">2674             }</span>
<span class="line-removed">2675             if (!didPush)</span>
<span class="line-removed">2676                 break;</span>
<span class="line-removed">2677         }</span>
<span class="line-removed">2678 </span>
<span class="line-removed">2679         IndexSet&lt;Variable*&gt; liveVariables;</span>
<span class="line-removed">2680 </span>
<span class="line-removed">2681         for (BasicBlock* block : m_proc) {</span>
<span class="line-removed">2682             size_t sourceIndex = 0;</span>
<span class="line-removed">2683             size_t targetIndex = 0;</span>
<span class="line-removed">2684             while (sourceIndex &lt; block-&gt;size()) {</span>
<span class="line-removed">2685                 Value* value = block-&gt;at(sourceIndex++);</span>
<span class="line-removed">2686                 if (worklist.saw(value)) {</span>
<span class="line-removed">2687                     if (VariableValue* variableValue = value-&gt;as&lt;VariableValue&gt;())</span>
<span class="line-removed">2688                         liveVariables.add(variableValue-&gt;variable());</span>
<span class="line-removed">2689                     block-&gt;at(targetIndex++) = value;</span>
<span class="line-removed">2690                 } else {</span>
<span class="line-removed">2691                     m_proc.deleteValue(value);</span>
<span class="line-removed">2692                     m_changed = true;</span>
<span class="line-removed">2693                 }</span>
<span class="line-removed">2694             }</span>
<span class="line-removed">2695             block-&gt;values().resize(targetIndex);</span>
<span class="line-removed">2696         }</span>
<span class="line-removed">2697 </span>
<span class="line-removed">2698         for (Variable* variable : m_proc.variables()) {</span>
<span class="line-removed">2699             if (!liveVariables.contains(variable))</span>
<span class="line-removed">2700                 m_proc.deleteVariable(variable);</span>
<span class="line-removed">2701         }</span>
<span class="line-removed">2702     }</span>
<span class="line-removed">2703 </span>
2704     void simplifySSA()
2705     {
2706         // This runs Aycock and Horspool&#39;s algorithm on our Phi functions [1]. For most CFG patterns,
2707         // this can take a suboptimal arrangement of Phi functions and make it optimal, as if you had
2708         // run Cytron, Ferrante, Rosen, Wegman, and Zadeck. It&#39;s only suboptimal for irreducible
2709         // CFGs. In practice, that doesn&#39;t matter, since we expect clients of B3 to run their own SSA
2710         // conversion before lowering to B3, and in the case of the DFG, that conversion uses Cytron
2711         // et al. In that context, this algorithm is intended to simplify Phi functions that were
2712         // made redundant by prior CFG simplification. But according to Aycock and Horspool&#39;s paper,
2713         // this algorithm is good enough that a B3 client could just give us maximal Phi&#39;s (i.e. Phi
2714         // for each variable at each basic block) and we will make them optimal.
2715         // [1] http://pages.cpsc.ucalgary.ca/~aycock/papers/ssa.ps
2716 
2717         // Aycock and Horspool prescribe two rules that are to be run to fixpoint:
2718         //
2719         // 1) If all of the Phi&#39;s children are the same (i.e. it&#39;s one child referenced from one or
2720         //    more Upsilons), then replace all uses of the Phi with the one child.
2721         //
2722         // 2) If all of the Phi&#39;s children are either the Phi itself or exactly one other child, then
2723         //    replace all uses of the Phi with the one other child.
</pre>
<hr />
<pre>
2748             if (!ok)
2749                 continue;
2750             if (!otherChild) {
2751                 // Wow, this would be super weird. It probably won&#39;t happen, except that things could
2752                 // get weird as a consequence of stepwise simplifications in the strength reduction
2753                 // fixpoint.
2754                 continue;
2755             }
2756 
2757             // Turn the Phi into an Identity and turn the Upsilons into Nops.
2758             m_changed = true;
2759             for (Value* upsilon : phiChildren[phi])
2760                 upsilon-&gt;replaceWithNop();
2761             phi-&gt;replaceWithIdentity(otherChild);
2762         }
2763     }
2764 
2765     Procedure&amp; m_proc;
2766     InsertionSet m_insertionSet;
2767     BlockInsertionSet m_blockInsertionSet;


2768     BasicBlock* m_block { nullptr };
2769     unsigned m_index { 0 };
2770     Value* m_value { nullptr };
2771     Dominators* m_dominators { nullptr };
2772     PureCSE m_pureCSE;
2773     bool m_changed { false };
2774     bool m_changedCFG { false };
2775 };
2776 
2777 } // anonymous namespace
2778 
2779 bool reduceStrength(Procedure&amp; proc)
2780 {
2781     PhaseScope phaseScope(proc, &quot;reduceStrength&quot;);
2782     ReduceStrength reduceStrength(proc);
2783     return reduceStrength.run();
2784 }
2785 
2786 } } // namespace JSC::B3
2787 
</pre>
</td>
<td>
<hr />
<pre>
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;B3ReduceStrength.h&quot;
  28 
  29 #if ENABLE(B3_JIT)
  30 
  31 #include &quot;B3AtomicValue.h&quot;
  32 #include &quot;B3BasicBlockInlines.h&quot;
  33 #include &quot;B3BlockInsertionSet.h&quot;
  34 #include &quot;B3ComputeDivisionMagic.h&quot;
  35 #include &quot;B3Dominators.h&quot;
<span class="line-added">  36 #include &quot;B3EliminateDeadCode.h&quot;</span>
  37 #include &quot;B3InsertionSetInlines.h&quot;
  38 #include &quot;B3MemoryValueInlines.h&quot;
  39 #include &quot;B3PhaseScope.h&quot;
  40 #include &quot;B3PhiChildren.h&quot;
  41 #include &quot;B3ProcedureInlines.h&quot;
  42 #include &quot;B3PureCSE.h&quot;
  43 #include &quot;B3SlotBaseValue.h&quot;
  44 #include &quot;B3StackSlot.h&quot;
  45 #include &quot;B3UpsilonValue.h&quot;
  46 #include &quot;B3ValueKeyInlines.h&quot;
  47 #include &quot;B3ValueInlines.h&quot;
  48 #include &quot;B3Variable.h&quot;
  49 #include &quot;B3VariableValue.h&quot;
  50 #include &lt;wtf/GraphNodeWorklist.h&gt;
  51 #include &lt;wtf/HashMap.h&gt;
  52 #include &lt;wtf/IndexSet.h&gt;
  53 
  54 namespace JSC { namespace B3 {
  55 
  56 namespace {
</pre>
<hr />
<pre>
  98 class IntRange {
  99 public:
 100     IntRange()
 101     {
 102     }
 103 
 104     IntRange(int64_t min, int64_t max)
 105         : m_min(min)
 106         , m_max(max)
 107     {
 108     }
 109 
 110     template&lt;typename T&gt;
 111     static IntRange top()
 112     {
 113         return IntRange(std::numeric_limits&lt;T&gt;::min(), std::numeric_limits&lt;T&gt;::max());
 114     }
 115 
 116     static IntRange top(Type type)
 117     {
<span class="line-modified"> 118         switch (type.kind()) {</span>
 119         case Int32:
 120             return top&lt;int32_t&gt;();
 121         case Int64:
 122             return top&lt;int64_t&gt;();
 123         default:
 124             RELEASE_ASSERT_NOT_REACHED();
 125             return IntRange();
 126         }
 127     }
 128 
 129     template&lt;typename T&gt;
 130     static IntRange rangeForMask(T mask)
 131     {
 132         if (!(mask + 1))
 133             return top&lt;T&gt;();
 134         return IntRange(0, mask);
 135     }
 136 
 137     static IntRange rangeForMask(int64_t mask, Type type)
 138     {
<span class="line-modified"> 139         switch (type.kind()) {</span>
 140         case Int32:
 141             return rangeForMask&lt;int32_t&gt;(static_cast&lt;int32_t&gt;(mask));
 142         case Int64:
 143             return rangeForMask&lt;int64_t&gt;(mask);
 144         default:
 145             RELEASE_ASSERT_NOT_REACHED();
 146             return IntRange();
 147         }
 148     }
 149 
 150     template&lt;typename T&gt;
 151     static IntRange rangeForZShr(int32_t shiftAmount)
 152     {
 153         typename std::make_unsigned&lt;T&gt;::type mask = 0;
 154         mask--;
 155         mask &gt;&gt;= shiftAmount;
 156         return rangeForMask&lt;T&gt;(static_cast&lt;T&gt;(mask));
 157     }
 158 
 159     static IntRange rangeForZShr(int32_t shiftAmount, Type type)
 160     {
<span class="line-modified"> 161         switch (type.kind()) {</span>
 162         case Int32:
 163             return rangeForZShr&lt;int32_t&gt;(shiftAmount);
 164         case Int64:
 165             return rangeForZShr&lt;int64_t&gt;(shiftAmount);
 166         default:
 167             RELEASE_ASSERT_NOT_REACHED();
 168             return IntRange();
 169         }
 170     }
 171 
 172     int64_t min() const { return m_min; }
 173     int64_t max() const { return m_max; }
 174 
 175     void dump(PrintStream&amp; out) const
 176     {
 177         out.print(&quot;[&quot;, m_min, &quot;,&quot;, m_max, &quot;]&quot;);
 178     }
 179 
 180     template&lt;typename T&gt;
 181     bool couldOverflowAdd(const IntRange&amp; other)
 182     {
 183         return sumOverflows&lt;T&gt;(m_min, other.m_min)
 184             || sumOverflows&lt;T&gt;(m_min, other.m_max)
 185             || sumOverflows&lt;T&gt;(m_max, other.m_min)
 186             || sumOverflows&lt;T&gt;(m_max, other.m_max);
 187     }
 188 
 189     bool couldOverflowAdd(const IntRange&amp; other, Type type)
 190     {
<span class="line-modified"> 191         switch (type.kind()) {</span>
 192         case Int32:
 193             return couldOverflowAdd&lt;int32_t&gt;(other);
 194         case Int64:
 195             return couldOverflowAdd&lt;int64_t&gt;(other);
 196         default:
 197             return true;
 198         }
 199     }
 200 
 201     template&lt;typename T&gt;
 202     bool couldOverflowSub(const IntRange&amp; other)
 203     {
 204         return differenceOverflows&lt;T&gt;(m_min, other.m_min)
 205             || differenceOverflows&lt;T&gt;(m_min, other.m_max)
 206             || differenceOverflows&lt;T&gt;(m_max, other.m_min)
 207             || differenceOverflows&lt;T&gt;(m_max, other.m_max);
 208     }
 209 
 210     bool couldOverflowSub(const IntRange&amp; other, Type type)
 211     {
<span class="line-modified"> 212         switch (type.kind()) {</span>
 213         case Int32:
 214             return couldOverflowSub&lt;int32_t&gt;(other);
 215         case Int64:
 216             return couldOverflowSub&lt;int64_t&gt;(other);
 217         default:
 218             return true;
 219         }
 220     }
 221 
 222     template&lt;typename T&gt;
 223     bool couldOverflowMul(const IntRange&amp; other)
 224     {
 225         return productOverflows&lt;T&gt;(m_min, other.m_min)
 226             || productOverflows&lt;T&gt;(m_min, other.m_max)
 227             || productOverflows&lt;T&gt;(m_max, other.m_min)
 228             || productOverflows&lt;T&gt;(m_max, other.m_max);
 229     }
 230 
 231     bool couldOverflowMul(const IntRange&amp; other, Type type)
 232     {
<span class="line-modified"> 233         switch (type.kind()) {</span>
 234         case Int32:
 235             return couldOverflowMul&lt;int32_t&gt;(other);
 236         case Int64:
 237             return couldOverflowMul&lt;int64_t&gt;(other);
 238         default:
 239             return true;
 240         }
 241     }
 242 
 243     template&lt;typename T&gt;
 244     IntRange shl(int32_t shiftAmount)
 245     {
 246         T newMin = static_cast&lt;T&gt;(m_min) &lt;&lt; static_cast&lt;T&gt;(shiftAmount);
 247         T newMax = static_cast&lt;T&gt;(m_max) &lt;&lt; static_cast&lt;T&gt;(shiftAmount);
 248 
 249         if ((newMin &gt;&gt; shiftAmount) != static_cast&lt;T&gt;(m_min))
 250             newMin = std::numeric_limits&lt;T&gt;::min();
 251         if ((newMax &gt;&gt; shiftAmount) != static_cast&lt;T&gt;(m_max))
 252             newMax = std::numeric_limits&lt;T&gt;::max();
 253 
 254         return IntRange(newMin, newMax);
 255     }
 256 
 257     IntRange shl(int32_t shiftAmount, Type type)
 258     {
<span class="line-modified"> 259         switch (type.kind()) {</span>
 260         case Int32:
 261             return shl&lt;int32_t&gt;(shiftAmount);
 262         case Int64:
 263             return shl&lt;int64_t&gt;(shiftAmount);
 264         default:
 265             RELEASE_ASSERT_NOT_REACHED();
 266             return IntRange();
 267         }
 268     }
 269 
 270     template&lt;typename T&gt;
 271     IntRange sShr(int32_t shiftAmount)
 272     {
 273         T newMin = static_cast&lt;T&gt;(m_min) &gt;&gt; static_cast&lt;T&gt;(shiftAmount);
 274         T newMax = static_cast&lt;T&gt;(m_max) &gt;&gt; static_cast&lt;T&gt;(shiftAmount);
 275 
 276         return IntRange(newMin, newMax);
 277     }
 278 
 279     IntRange sShr(int32_t shiftAmount, Type type)
 280     {
<span class="line-modified"> 281         switch (type.kind()) {</span>
 282         case Int32:
 283             return sShr&lt;int32_t&gt;(shiftAmount);
 284         case Int64:
 285             return sShr&lt;int64_t&gt;(shiftAmount);
 286         default:
 287             RELEASE_ASSERT_NOT_REACHED();
 288             return IntRange();
 289         }
 290     }
 291 
 292     template&lt;typename T&gt;
 293     IntRange zShr(int32_t shiftAmount)
 294     {
 295         // This is an awkward corner case for all of the other logic.
 296         if (!shiftAmount)
 297             return *this;
 298 
 299         // If the input range may be negative, then all we can say about the output range is that it
 300         // will be masked. That&#39;s because -1 right shifted just produces that mask.
 301         if (m_min &lt; 0)
 302             return rangeForZShr&lt;T&gt;(shiftAmount);
 303 
 304         // If the input range is non-negative, then this just brings the range closer to zero.
 305         typedef typename std::make_unsigned&lt;T&gt;::type UnsignedT;
 306         UnsignedT newMin = static_cast&lt;UnsignedT&gt;(m_min) &gt;&gt; static_cast&lt;UnsignedT&gt;(shiftAmount);
 307         UnsignedT newMax = static_cast&lt;UnsignedT&gt;(m_max) &gt;&gt; static_cast&lt;UnsignedT&gt;(shiftAmount);
 308 
 309         return IntRange(newMin, newMax);
 310     }
 311 
 312     IntRange zShr(int32_t shiftAmount, Type type)
 313     {
<span class="line-modified"> 314         switch (type.kind()) {</span>
 315         case Int32:
 316             return zShr&lt;int32_t&gt;(shiftAmount);
 317         case Int64:
 318             return zShr&lt;int64_t&gt;(shiftAmount);
 319         default:
 320             RELEASE_ASSERT_NOT_REACHED();
 321             return IntRange();
 322         }
 323     }
 324 
 325     template&lt;typename T&gt;
 326     IntRange add(const IntRange&amp; other)
 327     {
 328         if (couldOverflowAdd&lt;T&gt;(other))
 329             return top&lt;T&gt;();
 330         return IntRange(m_min + other.m_min, m_max + other.m_max);
 331     }
 332 
 333     IntRange add(const IntRange&amp; other, Type type)
 334     {
<span class="line-modified"> 335         switch (type.kind()) {</span>
 336         case Int32:
 337             return add&lt;int32_t&gt;(other);
 338         case Int64:
 339             return add&lt;int64_t&gt;(other);
 340         default:
 341             RELEASE_ASSERT_NOT_REACHED();
 342             return IntRange();
 343         }
 344     }
 345 
 346     template&lt;typename T&gt;
 347     IntRange sub(const IntRange&amp; other)
 348     {
 349         if (couldOverflowSub&lt;T&gt;(other))
 350             return top&lt;T&gt;();
 351         return IntRange(m_min - other.m_max, m_max - other.m_min);
 352     }
 353 
 354     IntRange sub(const IntRange&amp; other, Type type)
 355     {
<span class="line-modified"> 356         switch (type.kind()) {</span>
 357         case Int32:
 358             return sub&lt;int32_t&gt;(other);
 359         case Int64:
 360             return sub&lt;int64_t&gt;(other);
 361         default:
 362             RELEASE_ASSERT_NOT_REACHED();
 363             return IntRange();
 364         }
 365     }
 366 
 367     template&lt;typename T&gt;
 368     IntRange mul(const IntRange&amp; other)
 369     {
 370         if (couldOverflowMul&lt;T&gt;(other))
 371             return top&lt;T&gt;();
 372         return IntRange(
 373             std::min(
 374                 std::min(m_min * other.m_min, m_min * other.m_max),
 375                 std::min(m_max * other.m_min, m_max * other.m_max)),
 376             std::max(
 377                 std::max(m_min * other.m_min, m_min * other.m_max),
 378                 std::max(m_max * other.m_min, m_max * other.m_max)));
 379     }
 380 
 381     IntRange mul(const IntRange&amp; other, Type type)
 382     {
<span class="line-modified"> 383         switch (type.kind()) {</span>
 384         case Int32:
 385             return mul&lt;int32_t&gt;(other);
 386         case Int64:
 387             return mul&lt;int64_t&gt;(other);
 388         default:
 389             RELEASE_ASSERT_NOT_REACHED();
 390             return IntRange();
 391         }
 392     }
 393 
 394 private:
 395     int64_t m_min { 0 };
 396     int64_t m_max { 0 };
 397 };
 398 
 399 class ReduceStrength {
 400 public:
 401     ReduceStrength(Procedure&amp; proc)
 402         : m_proc(proc)
 403         , m_insertionSet(proc)
 404         , m_blockInsertionSet(proc)
<span class="line-added"> 405         , m_root(proc.at(0))</span>
 406     {
 407     }
 408 
 409     bool run()
 410     {
 411         bool result = false;
 412         bool first = true;
 413         unsigned index = 0;
 414         do {
 415             m_changed = false;
 416             m_changedCFG = false;
 417             ++index;
 418 
 419             if (first)
 420                 first = false;
 421             else if (B3ReduceStrengthInternal::verbose) {
 422                 dataLog(&quot;B3 after iteration #&quot;, index - 1, &quot; of reduceStrength:\n&quot;);
 423                 dataLog(m_proc);
 424             }
 425 
 426             simplifyCFG();
 427 
 428             if (m_changedCFG) {
 429                 m_proc.resetReachability();
 430                 m_proc.invalidateCFG();
 431                 m_changed = true;
 432             }
 433 
 434             // We definitely want to do DCE before we do CSE so that we don&#39;t hoist things. For
 435             // example:
 436             //
 437             // @dead = Mul(@a, @b)
 438             // ... lots of control flow and stuff
 439             // @thing = Mul(@a, @b)
 440             //
 441             // If we do CSE before DCE, we will remove @thing and keep @dead. Effectively, we will
 442             // &quot;hoist&quot; @thing. On the other hand, if we run DCE before CSE, we will kill @dead and
 443             // keep @thing. That&#39;s better, since we usually want things to stay wherever the client
 444             // put them. We&#39;re not actually smart enough to move things around at random.
<span class="line-modified"> 445             m_changed |= eliminateDeadCodeImpl(m_proc);</span>
<span class="line-added"> 446             m_valueForConstant.clear();</span>
 447 
 448             simplifySSA();
 449 
 450             if (m_proc.optLevel() &gt;= 2) {
 451                 m_proc.resetValueOwners();
 452                 m_dominators = &amp;m_proc.dominators(); // Recompute if necessary.
 453                 m_pureCSE.clear();
 454             }
 455 
 456             for (BasicBlock* block : m_proc.blocksInPreOrder()) {
 457                 m_block = block;
 458 
 459                 for (m_index = 0; m_index &lt; block-&gt;size(); ++m_index) {
 460                     if (B3ReduceStrengthInternal::verbose) {
 461                         dataLog(
 462                             &quot;Looking at &quot;, *block, &quot; #&quot;, m_index, &quot;: &quot;,
 463                             deepDump(m_proc, block-&gt;at(m_index)), &quot;\n&quot;);
 464                     }
 465                     m_value = m_block-&gt;at(m_index);
 466                     m_value-&gt;performSubstitution();
</pre>
<hr />
<pre>
 588                 if (m_value-&gt;child(1)-&gt;opcode() == Neg) {
 589                     replaceWithNew&lt;Value&gt;(Sub, m_value-&gt;origin(), m_value-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
 590                     break;
 591                 }
 592 
 593                 // Turn this: Integer Add(Neg(value), otherValue)
 594                 // Into this: Sub(otherValue, value)
 595                 if (m_value-&gt;child(0)-&gt;opcode() == Neg) {
 596                     replaceWithNew&lt;Value&gt;(Sub, m_value-&gt;origin(), m_value-&gt;child(1), m_value-&gt;child(0)-&gt;child(0));
 597                     break;
 598                 }
 599 
 600                 // Turn this: Integer Add(Sub(0, value), -1)
 601                 // Into this: BitXor(value, -1)
 602                 if (m_value-&gt;child(0)-&gt;opcode() == Sub
 603                     &amp;&amp; m_value-&gt;child(1)-&gt;isInt(-1)
 604                     &amp;&amp; m_value-&gt;child(0)-&gt;child(0)-&gt;isInt(0)) {
 605                     replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(1), m_value-&gt;child(1));
 606                     break;
 607                 }
<span class="line-added"> 608 </span>
<span class="line-added"> 609                 if (handleMulDistributivity())</span>
<span class="line-added"> 610                     break;</span>
 611             }
 612 
 613             break;
 614 
 615         case Sub:
 616             // Turn this: Sub(constant1, constant2)
 617             // Into this: constant1 - constant2
 618             if (Value* constantSub = m_value-&gt;child(0)-&gt;subConstant(m_proc, m_value-&gt;child(1))) {
 619                 replaceWithNewValue(constantSub);
 620                 break;
 621             }
 622 
 623             if (m_value-&gt;isInteger()) {
 624                 // Turn this: Sub(value, constant)
 625                 // Into this: Add(value, -constant)
 626                 if (Value* negatedConstant = m_value-&gt;child(1)-&gt;negConstant(m_proc)) {
 627                     m_insertionSet.insertValue(m_index, negatedConstant);
 628                     replaceWithNew&lt;Value&gt;(
 629                         Add, m_value-&gt;origin(), m_value-&gt;child(0), negatedConstant);
 630                     break;
</pre>
<hr />
<pre>
 633                 // Turn this: Sub(0, value)
 634                 // Into this: Neg(value)
 635                 if (m_value-&gt;child(0)-&gt;isInt(0)) {
 636                     replaceWithNew&lt;Value&gt;(Neg, m_value-&gt;origin(), m_value-&gt;child(1));
 637                     break;
 638                 }
 639 
 640                 // Turn this: Sub(value, value)
 641                 // Into this: 0
 642                 if (m_value-&gt;child(0) == m_value-&gt;child(1)) {
 643                     replaceWithNewValue(m_proc.addIntConstant(m_value, 0));
 644                     break;
 645                 }
 646 
 647                 // Turn this: Sub(value, Neg(otherValue))
 648                 // Into this: Add(value, otherValue)
 649                 if (m_value-&gt;child(1)-&gt;opcode() == Neg) {
 650                     replaceWithNew&lt;Value&gt;(Add, m_value-&gt;origin(), m_value-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
 651                     break;
 652                 }
<span class="line-added"> 653 </span>
<span class="line-added"> 654                 // Turn this: Sub(Neg(value), value2)</span>
<span class="line-added"> 655                 // Into this: Neg(Add(value, value2))</span>
<span class="line-added"> 656                 if (m_value-&gt;child(0)-&gt;opcode() == Neg) {</span>
<span class="line-added"> 657                     replaceWithNew&lt;Value&gt;(Neg, m_value-&gt;origin(),</span>
<span class="line-added"> 658                         m_insertionSet.insert&lt;Value&gt;(m_index, Add, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)));</span>
<span class="line-added"> 659                     break;</span>
<span class="line-added"> 660                 }</span>
<span class="line-added"> 661 </span>
<span class="line-added"> 662                 // Turn this: Sub(Sub(a, b), c)</span>
<span class="line-added"> 663                 // Into this: Sub(a, Add(b, c))</span>
<span class="line-added"> 664                 if (m_value-&gt;child(0)-&gt;opcode() == Sub) {</span>
<span class="line-added"> 665                     replaceWithNew&lt;Value&gt;(Sub, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0),</span>
<span class="line-added"> 666                         m_insertionSet.insert&lt;Value&gt;(m_index, Add, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(1), m_value-&gt;child(1)));</span>
<span class="line-added"> 667                     break;</span>
<span class="line-added"> 668                 }</span>
<span class="line-added"> 669 </span>
<span class="line-added"> 670                 // Turn this: Sub(a, Sub(b, c))</span>
<span class="line-added"> 671                 // Into this: Add(Sub(a, b), c)</span>
<span class="line-added"> 672                 if (m_value-&gt;child(1)-&gt;opcode() == Sub) {</span>
<span class="line-added"> 673                     replaceWithNew&lt;Value&gt;(Add, m_value-&gt;origin(),</span>
<span class="line-added"> 674                         m_insertionSet.insert&lt;Value&gt;(m_index, Sub, m_value-&gt;origin(), m_value-&gt;child(0), m_value-&gt;child(1)-&gt;child(0)),</span>
<span class="line-added"> 675                         m_value-&gt;child(1)-&gt;child(1));</span>
<span class="line-added"> 676                     break;</span>
<span class="line-added"> 677                 }</span>
<span class="line-added"> 678 </span>
<span class="line-added"> 679                 // Turn this: Sub(Add(a, b), c)</span>
<span class="line-added"> 680                 // Into this: Add(a, Sub(b, c))</span>
<span class="line-added"> 681                 if (m_value-&gt;child(0)-&gt;opcode() == Add) {</span>
<span class="line-added"> 682                     replaceWithNew&lt;Value&gt;(Add, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0),</span>
<span class="line-added"> 683                         m_insertionSet.insert&lt;Value&gt;(m_index, Sub, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(1), m_value-&gt;child(1)));</span>
<span class="line-added"> 684                     break;</span>
<span class="line-added"> 685                 }</span>
<span class="line-added"> 686 </span>
<span class="line-added"> 687                 if (handleMulDistributivity())</span>
<span class="line-added"> 688                     break;</span>
 689             }
 690 
 691             break;
 692 
 693         case Neg:
 694             // Turn this: Neg(constant)
 695             // Into this: -constant
 696             if (Value* constant = m_value-&gt;child(0)-&gt;negConstant(m_proc)) {
 697                 replaceWithNewValue(constant);
 698                 break;
 699             }
 700 
 701             // Turn this: Neg(Neg(value))
 702             // Into this: value
 703             if (m_value-&gt;child(0)-&gt;opcode() == Neg) {
 704                 replaceWithIdentity(m_value-&gt;child(0)-&gt;child(0));
 705                 break;
 706             }
 707 
<span class="line-modified"> 708             if (m_value-&gt;isInteger()) {</span>
<span class="line-modified"> 709                 // Turn this: Integer Neg(Sub(value, otherValue))</span>
<span class="line-modified"> 710                 // Into this: Sub(otherValue, value)</span>
<span class="line-modified"> 711                 if (m_value-&gt;child(0)-&gt;opcode() == Sub) {</span>
<span class="line-modified"> 712                     replaceWithNew&lt;Value&gt;(Sub, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(1), m_value-&gt;child(0)-&gt;child(0));</span>
<span class="line-added"> 713                     break;</span>
<span class="line-added"> 714                 }</span>
<span class="line-added"> 715 </span>
<span class="line-added"> 716                 // Turn this: Integer Neg(Mul(value, c))</span>
<span class="line-added"> 717                 // Into this: Mul(value, -c), as long as -c does not overflow</span>
<span class="line-added"> 718                 if (m_value-&gt;child(0)-&gt;opcode() == Mul &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt()) {</span>
<span class="line-added"> 719                     int64_t factor = m_value-&gt;child(0)-&gt;child(1)-&gt;asInt();</span>
<span class="line-added"> 720                     if (m_value-&gt;type() == Int32 &amp;&amp; factor != std::numeric_limits&lt;int32_t&gt;::min()) {</span>
<span class="line-added"> 721                         Value* newFactor = m_insertionSet.insert&lt;Const32Value&gt;(m_index, m_value-&gt;child(0)-&gt;child(1)-&gt;origin(), -factor);</span>
<span class="line-added"> 722                         replaceWithNew&lt;Value&gt;(Mul, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), newFactor);</span>
<span class="line-added"> 723                     } else if (m_value-&gt;type() == Int64 &amp;&amp; factor != std::numeric_limits&lt;int64_t&gt;::min()) {</span>
<span class="line-added"> 724                         Value* newFactor = m_insertionSet.insert&lt;Const64Value&gt;(m_index, m_value-&gt;child(0)-&gt;child(1)-&gt;origin(), -factor);</span>
<span class="line-added"> 725                         replaceWithNew&lt;Value&gt;(Mul, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), newFactor);</span>
<span class="line-added"> 726                     }</span>
<span class="line-added"> 727                 }</span>
 728             }
 729 
<span class="line-added"> 730 </span>
 731             break;
 732 
 733         case Mul:
 734             handleCommutativity();
 735 
 736             // Turn this: Mul(constant1, constant2)
 737             // Into this: constant1 * constant2
 738             if (Value* value = m_value-&gt;child(0)-&gt;mulConstant(m_proc, m_value-&gt;child(1))) {
 739                 replaceWithNewValue(value);
 740                 break;
 741             }
 742 
 743             if (m_value-&gt;child(1)-&gt;hasInt()) {
 744                 int64_t factor = m_value-&gt;child(1)-&gt;asInt();
 745 
 746                 // Turn this: Mul(value, 0)
 747                 // Into this: 0
 748                 // Note that we don&#39;t do this for doubles because that&#39;s wrong. For example, -1 * 0
 749                 // and 1 * 0 yield different results.
 750                 if (!factor) {
 751                     replaceWithIdentity(m_value-&gt;child(1));
 752                     break;
 753                 }
 754 
 755                 // Turn this: Mul(value, 1)
 756                 // Into this: value
 757                 if (factor == 1) {
 758                     replaceWithIdentity(m_value-&gt;child(0));
 759                     break;
 760                 }
 761 
 762                 // Turn this: Mul(value, -1)
<span class="line-modified"> 763                 // Into this: Neg(value)</span>
 764                 if (factor == -1) {
<span class="line-modified"> 765                     replaceWithNew&lt;Value&gt;(Neg, m_value-&gt;origin(), m_value-&gt;child(0));</span>




 766                     break;
 767                 }
 768 
 769                 // Turn this: Mul(value, constant)
 770                 // Into this: Shl(value, log2(constant))
 771                 if (hasOneBitSet(factor)) {
 772                     unsigned shiftAmount = WTF::fastLog2(static_cast&lt;uint64_t&gt;(factor));
 773                     replaceWithNewValue(
 774                         m_proc.add&lt;Value&gt;(
 775                             Shl, m_value-&gt;origin(), m_value-&gt;child(0),
 776                             m_insertionSet.insert&lt;Const32Value&gt;(
 777                                 m_index, m_value-&gt;origin(), shiftAmount)));
 778                     break;
 779                 }
 780             } else if (m_value-&gt;child(1)-&gt;hasDouble()) {
 781                 double factor = m_value-&gt;child(1)-&gt;asDouble();
 782 
 783                 // Turn this: Mul(value, 1)
 784                 // Into this: value
 785                 if (factor == 1) {
 786                     replaceWithIdentity(m_value-&gt;child(0));
 787                     break;
 788                 }
 789             }
 790 
<span class="line-added"> 791             if (m_value-&gt;isInteger()) {</span>
<span class="line-added"> 792                 // Turn this: Integer Mul(value, Neg(otherValue))</span>
<span class="line-added"> 793                 // Into this: Neg(Mul(value, otherValue))</span>
<span class="line-added"> 794                 if (m_value-&gt;child(1)-&gt;opcode() == Neg) {</span>
<span class="line-added"> 795                     Value* newMul = m_insertionSet.insert&lt;Value&gt;(m_index, Mul, m_value-&gt;origin(), m_value-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));</span>
<span class="line-added"> 796                     replaceWithNew&lt;Value&gt;(Neg, m_value-&gt;origin(), newMul);</span>
<span class="line-added"> 797                     break;</span>
<span class="line-added"> 798                 }</span>
<span class="line-added"> 799                 // Turn this: Integer Mul(Neg(value), otherValue)</span>
<span class="line-added"> 800                 // Into this: Neg(Mul(value, value2))</span>
<span class="line-added"> 801                 if (m_value-&gt;child(0)-&gt;opcode() == Neg) {</span>
<span class="line-added"> 802                     Value* newMul = m_insertionSet.insert&lt;Value&gt;(m_index, Mul, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1));</span>
<span class="line-added"> 803                     replaceWithNew&lt;Value&gt;(Neg, m_value-&gt;origin(), newMul);</span>
<span class="line-added"> 804                     break;</span>
<span class="line-added"> 805                 }</span>
<span class="line-added"> 806             }</span>
<span class="line-added"> 807 </span>
 808             break;
 809 
 810         case Div:
 811             // Turn this: Div(constant1, constant2)
 812             // Into this: constant1 / constant2
 813             // Note that this uses Div&lt;Chill&gt; semantics. That&#39;s fine, because the rules for Div
 814             // are strictly weaker: it has corner cases where it&#39;s allowed to do anything it
 815             // likes.
 816             if (replaceWithNewValue(m_value-&gt;child(0)-&gt;divConstant(m_proc, m_value-&gt;child(1))))
 817                 break;
 818 
 819             if (m_value-&gt;child(1)-&gt;hasInt()) {
 820                 switch (m_value-&gt;child(1)-&gt;asInt()) {
 821                 case -1:
 822                     // Turn this: Div(value, -1)
 823                     // Into this: Neg(value)
 824                     replaceWithNewValue(
 825                         m_proc.add&lt;Value&gt;(Neg, m_value-&gt;origin(), m_value-&gt;child(0)));
 826                     break;
 827 
</pre>
<hr />
<pre>
1254             // Turn this: BitXor(value, zero-constant)
1255             // Into this: value.
1256             if (m_value-&gt;child(1)-&gt;isInt(0)) {
1257                 replaceWithIdentity(m_value-&gt;child(0));
1258                 break;
1259             }
1260 
1261             if (handleBitAndDistributivity())
1262                 break;
1263 
1264             break;
1265 
1266         case Shl:
1267             // Turn this: Shl(constant1, constant2)
1268             // Into this: constant1 &lt;&lt; constant2
1269             if (Value* constant = m_value-&gt;child(0)-&gt;shlConstant(m_proc, m_value-&gt;child(1))) {
1270                 replaceWithNewValue(constant);
1271                 break;
1272             }
1273 
<span class="line-added">1274             // Turn this: Shl(&lt;S|Z&gt;Shr(@x, @const), @const)</span>
<span class="line-added">1275             // Into this: BitAnd(@x, -(1&lt;&lt;@const))</span>
<span class="line-added">1276             if ((m_value-&gt;child(0)-&gt;opcode() == SShr || m_value-&gt;child(0)-&gt;opcode() == ZShr)</span>
<span class="line-added">1277                 &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt()</span>
<span class="line-added">1278                 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt()</span>
<span class="line-added">1279                 &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;asInt() == m_value-&gt;child(1)-&gt;asInt()) {</span>
<span class="line-added">1280                 int shiftAmount = m_value-&gt;child(1)-&gt;asInt() &amp; (m_value-&gt;type() == Int32 ? 31 : 63);</span>
<span class="line-added">1281                 Value* newConst = m_proc.addIntConstant(m_value, - static_cast&lt;int64_t&gt;(1ull &lt;&lt; shiftAmount));</span>
<span class="line-added">1282                 m_insertionSet.insertValue(m_index, newConst);</span>
<span class="line-added">1283                 replaceWithNew&lt;Value&gt;(BitAnd, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), newConst);</span>
<span class="line-added">1284                 break;</span>
<span class="line-added">1285             }</span>
<span class="line-added">1286 </span>
1287             handleShiftAmount();
1288             break;
1289 
1290         case SShr:
1291             // Turn this: SShr(constant1, constant2)
1292             // Into this: constant1 &gt;&gt; constant2
1293             if (Value* constant = m_value-&gt;child(0)-&gt;sShrConstant(m_proc, m_value-&gt;child(1))) {
1294                 replaceWithNewValue(constant);
1295                 break;
1296             }
1297 
1298             if (m_value-&gt;child(1)-&gt;hasInt32()
1299                 &amp;&amp; m_value-&gt;child(0)-&gt;opcode() == Shl
1300                 &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt32()
1301                 &amp;&amp; m_value-&gt;child(1)-&gt;asInt32() == m_value-&gt;child(0)-&gt;child(1)-&gt;asInt32()) {
1302                 switch (m_value-&gt;child(1)-&gt;asInt32()) {
1303                 case 16:
1304                     if (m_value-&gt;type() == Int32) {
1305                         // Turn this: SShr(Shl(value, 16), 16)
1306                         // Into this: SExt16(value)
</pre>
<hr />
<pre>
2164                 break;
2165             }
2166 
2167             if (m_proc.optLevel() &gt;= 2) {
2168                 // If a check for the same property dominates us, we can kill the branch. This sort
2169                 // of makes sense here because it&#39;s cheap, but hacks like this show that we&#39;re going
2170                 // to need SCCP.
2171                 Value* check = m_pureCSE.findMatch(
2172                     ValueKey(Check, Void, m_value-&gt;child(0)), m_block, *m_dominators);
2173                 if (check) {
2174                     // The Check would have side-exited if child(0) was non-zero. So, it must be
2175                     // zero here.
2176                     m_block-&gt;taken().block()-&gt;removePredecessor(m_block);
2177                     m_value-&gt;replaceWithJump(m_block, m_block-&gt;notTaken());
2178                     m_changedCFG = true;
2179                 }
2180             }
2181             break;
2182         }
2183 
<span class="line-added">2184         case Const32:</span>
<span class="line-added">2185         case Const64:</span>
<span class="line-added">2186         case ConstFloat:</span>
<span class="line-added">2187         case ConstDouble: {</span>
<span class="line-added">2188             ValueKey key = m_value-&gt;key();</span>
<span class="line-added">2189             if (Value* constInRoot = m_valueForConstant.get(key)) {</span>
<span class="line-added">2190                 if (constInRoot != m_value) {</span>
<span class="line-added">2191                     m_value-&gt;replaceWithIdentity(constInRoot);</span>
<span class="line-added">2192                     m_changed = true;</span>
<span class="line-added">2193                 }</span>
<span class="line-added">2194             } else if (m_block == m_root)</span>
<span class="line-added">2195                 m_valueForConstant.add(key, m_value);</span>
<span class="line-added">2196             else {</span>
<span class="line-added">2197                 Value* constInRoot = m_proc.clone(m_value);</span>
<span class="line-added">2198                 ASSERT(m_root &amp;&amp; m_root-&gt;size() &gt;= 1);</span>
<span class="line-added">2199                 m_root-&gt;appendNonTerminal(constInRoot);</span>
<span class="line-added">2200                 m_valueForConstant.add(key, constInRoot);</span>
<span class="line-added">2201                 m_value-&gt;replaceWithIdentity(constInRoot);</span>
<span class="line-added">2202                 m_changed = true;</span>
<span class="line-added">2203             }</span>
<span class="line-added">2204             break;</span>
<span class="line-added">2205         }</span>
<span class="line-added">2206 </span>
2207         default:
2208             break;
2209         }
2210     }
2211 
2212     // Find a node that:
2213     //     - functor(node) returns true.
2214     //     - it&#39;s reachable from the given node via children.
2215     //     - it&#39;s in the last &quot;bound&quot; slots in the current basic block.
2216     // This algorithm is optimized under the assumption that the bound is small.
2217     template&lt;typename Functor&gt;
2218     Value* findRecentNodeMatching(Value* start, unsigned bound, const Functor&amp; functor)
2219     {
2220         unsigned startIndex = bound &lt; m_index ? m_index - bound : 0;
2221         Value* result = nullptr;
2222         start-&gt;walk(
2223             [&amp;] (Value* value) -&gt; Value::WalkStatus {
2224                 bool found = false;
2225                 for (unsigned i = startIndex; i &lt;= m_index; ++i) {
2226                     if (m_block-&gt;at(i) == value)
</pre>
<hr />
<pre>
2241 
2242     // This specializes a sequence of code up to a Select. This doesn&#39;t work when we&#39;re at a
2243     // terminal. It would be cool to fix that eventually. The main problem is that instead of
2244     // splitting the block, we should just insert the then/else blocks. We&#39;ll have to create
2245     // double the Phis and double the Upsilons. It&#39;ll probably be the sort of optimization that
2246     // we want to do only after we&#39;ve done loop optimizations, since this will *definitely*
2247     // obscure things. In fact, even this simpler form of select specialization will possibly
2248     // obscure other optimizations. It would be great to have two modes of strength reduction,
2249     // one that does obscuring optimizations and runs late, and another that does not do
2250     // obscuring optimizations and runs early.
2251     // FIXME: Make select specialization handle branches.
2252     // FIXME: Have a form of strength reduction that does no obscuring optimizations and runs
2253     // early.
2254     void specializeSelect(Value* source)
2255     {
2256         if (B3ReduceStrengthInternal::verbose)
2257             dataLog(&quot;Specializing select: &quot;, deepDump(m_proc, source), &quot;\n&quot;);
2258 
2259         // This mutates startIndex to account for the fact that m_block got the front of it
2260         // chopped off.
<span class="line-modified">2261         BasicBlock* predecessor = m_blockInsertionSet.splitForward(m_block, m_index, &amp;m_insertionSet);</span>
<span class="line-modified">2262         if (m_block == m_root) {</span>
<span class="line-added">2263             m_root = predecessor;</span>
<span class="line-added">2264             m_valueForConstant.clear();</span>
<span class="line-added">2265         }</span>
2266 
2267         // Splitting will commit the insertion set, which changes the exact position of the
2268         // source. That&#39;s why we do the search after splitting.
2269         unsigned startIndex = UINT_MAX;
2270         for (unsigned i = predecessor-&gt;size(); i--;) {
2271             if (predecessor-&gt;at(i) == source) {
2272                 startIndex = i;
2273                 break;
2274             }
2275         }
2276 
2277         RELEASE_ASSERT(startIndex != UINT_MAX);
2278 
2279         // By BasicBlock convention, caseIndex == 0 =&gt; then, caseIndex == 1 =&gt; else.
2280         static const unsigned numCases = 2;
2281         BasicBlock* cases[numCases];
2282         for (unsigned i = 0; i &lt; numCases; ++i)
2283             cases[i] = m_blockInsertionSet.insertBefore(m_block);
2284 
2285         HashMap&lt;Value*, Value*&gt; mappings[2];
</pre>
<hr />
<pre>
2376             return true;
2377 
2378         return false;
2379     }
2380 
2381     // Turn this: Add(constant, value)
2382     // Into this: Add(value, constant)
2383     //
2384     // Also:
2385     // Turn this: Add(value1, value2)
2386     // Into this: Add(value2, value1)
2387     // If we decide that value2 coming first is the canonical ordering.
2388     void handleCommutativity()
2389     {
2390         if (shouldSwapBinaryOperands(m_value)) {
2391             std::swap(m_value-&gt;child(0), m_value-&gt;child(1));
2392             m_changed = true;
2393         }
2394     }
2395 
<span class="line-added">2396     // For Op==Add or Sub, turn any of these:</span>
<span class="line-added">2397     //      Op(Mul(x1, x2), Mul(x1, x3))</span>
<span class="line-added">2398     //      Op(Mul(x2, x1), Mul(x1, x3))</span>
<span class="line-added">2399     //      Op(Mul(x1, x2), Mul(x3, x1))</span>
<span class="line-added">2400     //      Op(Mul(x2, x1), Mul(x3, x1))</span>
<span class="line-added">2401     // Into this: Mul(x1, Op(x2, x3))</span>
<span class="line-added">2402     bool handleMulDistributivity()</span>
<span class="line-added">2403     {</span>
<span class="line-added">2404         ASSERT(m_value-&gt;opcode() == Add || m_value-&gt;opcode() == Sub);</span>
<span class="line-added">2405         Value* x1 = nullptr;</span>
<span class="line-added">2406         Value* x2 = nullptr;</span>
<span class="line-added">2407         Value* x3 = nullptr;</span>
<span class="line-added">2408         if (m_value-&gt;child(0)-&gt;opcode() == Mul &amp;&amp; m_value-&gt;child(1)-&gt;opcode() == Mul) {</span>
<span class="line-added">2409             if (m_value-&gt;child(0)-&gt;child(0) == m_value-&gt;child(1)-&gt;child(0)) {</span>
<span class="line-added">2410                 // Op(Mul(x1, x2), Mul(x1, x3))</span>
<span class="line-added">2411                 x1 = m_value-&gt;child(0)-&gt;child(0);</span>
<span class="line-added">2412                 x2 = m_value-&gt;child(0)-&gt;child(1);</span>
<span class="line-added">2413                 x3 = m_value-&gt;child(1)-&gt;child(1);</span>
<span class="line-added">2414             } else if (m_value-&gt;child(0)-&gt;child(1) == m_value-&gt;child(1)-&gt;child(0)) {</span>
<span class="line-added">2415                 // Op(Mul(x2, x1), Mul(x1, x3))</span>
<span class="line-added">2416                 x1 = m_value-&gt;child(0)-&gt;child(1);</span>
<span class="line-added">2417                 x2 = m_value-&gt;child(0)-&gt;child(0);</span>
<span class="line-added">2418                 x3 = m_value-&gt;child(1)-&gt;child(1);</span>
<span class="line-added">2419             } else if (m_value-&gt;child(0)-&gt;child(0) == m_value-&gt;child(1)-&gt;child(1)) {</span>
<span class="line-added">2420                 // Op(Mul(x1, x2), Mul(x3, x1))</span>
<span class="line-added">2421                 x1 = m_value-&gt;child(0)-&gt;child(0);</span>
<span class="line-added">2422                 x2 = m_value-&gt;child(0)-&gt;child(1);</span>
<span class="line-added">2423                 x3 = m_value-&gt;child(1)-&gt;child(0);</span>
<span class="line-added">2424             } else if (m_value-&gt;child(0)-&gt;child(1) == m_value-&gt;child(1)-&gt;child(1)) {</span>
<span class="line-added">2425                 // Op(Mul(x2, x1), Mul(x3, x1))</span>
<span class="line-added">2426                 x1 = m_value-&gt;child(0)-&gt;child(1);</span>
<span class="line-added">2427                 x2 = m_value-&gt;child(0)-&gt;child(0);</span>
<span class="line-added">2428                 x3 = m_value-&gt;child(1)-&gt;child(0);</span>
<span class="line-added">2429             }</span>
<span class="line-added">2430         }</span>
<span class="line-added">2431         if (x1 != nullptr) {</span>
<span class="line-added">2432             ASSERT(x2 != nullptr &amp;&amp; x3 != nullptr);</span>
<span class="line-added">2433             Value* newOp = m_insertionSet.insert&lt;Value&gt;(m_index, m_value-&gt;opcode(), m_value-&gt;origin(), x2, x3);</span>
<span class="line-added">2434             replaceWithNew&lt;Value&gt;(Mul, m_value-&gt;origin(), x1, newOp);</span>
<span class="line-added">2435             return true;</span>
<span class="line-added">2436         }</span>
<span class="line-added">2437         return false;</span>
<span class="line-added">2438     }</span>
<span class="line-added">2439 </span>
2440     // For Op==BitOr or BitXor, turn any of these:
2441     //      Op(BitAnd(x1, x2), BitAnd(x1, x3))
2442     //      Op(BitAnd(x2, x1), BitAnd(x1, x3))
2443     //      Op(BitAnd(x1, x2), BitAnd(x3, x1))
2444     //      Op(BitAnd(x2, x1), BitAnd(x3, x1))
2445     // Into this: BitAnd(Op(x2, x3), x1)
2446     // And any of these:
2447     //      Op(BitAnd(x1, x2), x1)
2448     //      Op(BitAnd(x2, x1), x1)
2449     //      Op(x1, BitAnd(x1, x2))
2450     //      Op(x1, BitAnd(x2, x1))
2451     // Into this: BitAnd(Op(x2, x1), x1)
2452     // This second set is equivalent to doing x1 =&gt; BitAnd(x1, x1), and then applying the first set.
2453     // It does not reduce the number of operations executed, but provides some useful normalization: we prefer to have BitAnd at the outermost, then BitXor, and finally BitOr at the innermost
2454     bool handleBitAndDistributivity()
2455     {
2456         ASSERT(m_value-&gt;opcode() == BitOr || m_value-&gt;opcode() == BitXor);
2457         Value* x1 = nullptr;
2458         Value* x2 = nullptr;
2459         Value* x3 = nullptr;
</pre>
<hr />
<pre>
2478         } else if (m_value-&gt;child(0)-&gt;opcode() == BitAnd) {
2479             if (m_value-&gt;child(0)-&gt;child(0) == m_value-&gt;child(1)) {
2480                 x1 = x3 = m_value-&gt;child(1);
2481                 x2 = m_value-&gt;child(0)-&gt;child(1);
2482             } else if (m_value-&gt;child(0)-&gt;child(1) == m_value-&gt;child(1)) {
2483                 x1 = x3 = m_value-&gt;child(1);
2484                 x2 = m_value-&gt;child(0)-&gt;child(0);
2485             }
2486         } else if (m_value-&gt;child(1)-&gt;opcode() == BitAnd) {
2487             if (m_value-&gt;child(1)-&gt;child(0) == m_value-&gt;child(0)) {
2488                 x1 = x3 = m_value-&gt;child(0);
2489                 x2 = m_value-&gt;child(1)-&gt;child(1);
2490             } else if (m_value-&gt;child(1)-&gt;child(1) == m_value-&gt;child(0)) {
2491                 x1 = x3 = m_value-&gt;child(0);
2492                 x2 = m_value-&gt;child(1)-&gt;child(0);
2493             }
2494         }
2495         if (x1 != nullptr) {
2496             ASSERT(x2 != nullptr &amp;&amp; x3 != nullptr);
2497             Value* bitOp = m_insertionSet.insert&lt;Value&gt;(m_index, m_value-&gt;opcode(), m_value-&gt;origin(), x2, x3);
<span class="line-modified">2498             replaceWithNew&lt;Value&gt;(BitAnd, m_value-&gt;origin(), x1, bitOp);</span>
2499             return true;
2500         }
2501         return false;
2502     }
2503 
2504     struct CanonicalizedComparison {
2505         Opcode opcode;
2506         Value* operands[2];
2507     };
2508     static CanonicalizedComparison canonicalizeComparison(Value* value)
2509     {
2510         auto flip = [] (Opcode opcode) {
2511             switch (opcode) {
2512             case LessThan:
2513                 return GreaterThan;
2514             case GreaterThan:
2515                 return LessThan;
2516             case LessEqual:
2517                 return GreaterEqual;
2518             case GreaterEqual:
</pre>
<hr />
<pre>
2774     {
2775         if (m_changedCFG) {
2776             m_proc.resetReachability();
2777             m_proc.invalidateCFG();
2778             m_dominators = nullptr; // Dominators are not valid anymore, and we don&#39;t need them yet.
2779             m_changed = true;
2780         }
2781     }
2782 
2783     void checkPredecessorValidity()
2784     {
2785         if (!shouldValidateIRAtEachPhase())
2786             return;
2787 
2788         for (BasicBlock* block : m_proc) {
2789             for (BasicBlock* successor : block-&gt;successorBlocks())
2790                 RELEASE_ASSERT(successor-&gt;containsPredecessor(block));
2791         }
2792     }
2793 
































































2794     void simplifySSA()
2795     {
2796         // This runs Aycock and Horspool&#39;s algorithm on our Phi functions [1]. For most CFG patterns,
2797         // this can take a suboptimal arrangement of Phi functions and make it optimal, as if you had
2798         // run Cytron, Ferrante, Rosen, Wegman, and Zadeck. It&#39;s only suboptimal for irreducible
2799         // CFGs. In practice, that doesn&#39;t matter, since we expect clients of B3 to run their own SSA
2800         // conversion before lowering to B3, and in the case of the DFG, that conversion uses Cytron
2801         // et al. In that context, this algorithm is intended to simplify Phi functions that were
2802         // made redundant by prior CFG simplification. But according to Aycock and Horspool&#39;s paper,
2803         // this algorithm is good enough that a B3 client could just give us maximal Phi&#39;s (i.e. Phi
2804         // for each variable at each basic block) and we will make them optimal.
2805         // [1] http://pages.cpsc.ucalgary.ca/~aycock/papers/ssa.ps
2806 
2807         // Aycock and Horspool prescribe two rules that are to be run to fixpoint:
2808         //
2809         // 1) If all of the Phi&#39;s children are the same (i.e. it&#39;s one child referenced from one or
2810         //    more Upsilons), then replace all uses of the Phi with the one child.
2811         //
2812         // 2) If all of the Phi&#39;s children are either the Phi itself or exactly one other child, then
2813         //    replace all uses of the Phi with the one other child.
</pre>
<hr />
<pre>
2838             if (!ok)
2839                 continue;
2840             if (!otherChild) {
2841                 // Wow, this would be super weird. It probably won&#39;t happen, except that things could
2842                 // get weird as a consequence of stepwise simplifications in the strength reduction
2843                 // fixpoint.
2844                 continue;
2845             }
2846 
2847             // Turn the Phi into an Identity and turn the Upsilons into Nops.
2848             m_changed = true;
2849             for (Value* upsilon : phiChildren[phi])
2850                 upsilon-&gt;replaceWithNop();
2851             phi-&gt;replaceWithIdentity(otherChild);
2852         }
2853     }
2854 
2855     Procedure&amp; m_proc;
2856     InsertionSet m_insertionSet;
2857     BlockInsertionSet m_blockInsertionSet;
<span class="line-added">2858     HashMap&lt;ValueKey, Value*&gt; m_valueForConstant;</span>
<span class="line-added">2859     BasicBlock* m_root { nullptr };</span>
2860     BasicBlock* m_block { nullptr };
2861     unsigned m_index { 0 };
2862     Value* m_value { nullptr };
2863     Dominators* m_dominators { nullptr };
2864     PureCSE m_pureCSE;
2865     bool m_changed { false };
2866     bool m_changedCFG { false };
2867 };
2868 
2869 } // anonymous namespace
2870 
2871 bool reduceStrength(Procedure&amp; proc)
2872 {
2873     PhaseScope phaseScope(proc, &quot;reduceStrength&quot;);
2874     ReduceStrength reduceStrength(proc);
2875     return reduceStrength.run();
2876 }
2877 
2878 } } // namespace JSC::B3
2879 
</pre>
</td>
</tr>
</table>
<center><a href="B3PureCSE.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3SlotBaseValue.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>