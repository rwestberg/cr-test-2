<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowCustom.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMWindowBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMWindowProperties.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowCustom.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2007-2017 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2011 Google Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;JSDOMWindowCustom.h&quot;
 23 
 24 #include &quot;DOMWindowIndexedDatabase.h&quot;

 25 #include &quot;Frame.h&quot;
 26 #include &quot;HTMLCollection.h&quot;
 27 #include &quot;HTMLDocument.h&quot;
 28 #include &quot;HTMLFrameOwnerElement.h&quot;
 29 #include &quot;HTTPParsers.h&quot;
 30 #include &quot;JSDOMBindingSecurity.h&quot;
 31 #include &quot;JSDOMConvertNullable.h&quot;
 32 #include &quot;JSDOMConvertNumbers.h&quot;
 33 #include &quot;JSDOMConvertStrings.h&quot;


 34 #include &quot;JSEvent.h&quot;
 35 #include &quot;JSEventListener.h&quot;
 36 #include &quot;JSHTMLAudioElement.h&quot;
 37 #include &quot;JSHTMLCollection.h&quot;
 38 #include &quot;JSHTMLOptionElement.h&quot;
 39 #include &quot;JSIDBFactory.h&quot;
 40 #include &quot;JSRemoteDOMWindow.h&quot;
 41 #include &quot;JSWindowProxy.h&quot;
 42 #include &quot;JSWorker.h&quot;
 43 #include &quot;Location.h&quot;
 44 #include &quot;RuntimeEnabledFeatures.h&quot;
 45 #include &quot;ScheduledAction.h&quot;
 46 #include &quot;Settings.h&quot;
 47 #include &quot;WebCoreJSClientData.h&quot;
 48 #include &lt;JavaScriptCore/BuiltinNames.h&gt;
<span class="line-modified"> 49 #include &lt;JavaScriptCore/HeapSnapshotBuilder.h&gt;</span>
 50 #include &lt;JavaScriptCore/JSCInlines.h&gt;

 51 #include &lt;JavaScriptCore/JSMicrotask.h&gt;
 52 #include &lt;JavaScriptCore/Lookup.h&gt;

 53 
 54 #if ENABLE(USER_MESSAGE_HANDLERS)
 55 #include &quot;JSWebKitNamespace.h&quot;
 56 #endif
 57 
 58 
 59 namespace WebCore {
 60 using namespace JSC;
 61 
 62 EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionShowModalDialog(ExecState*);

 63 
 64 void JSDOMWindow::visitAdditionalChildren(SlotVisitor&amp; visitor)
 65 {
 66     if (Frame* frame = wrapped().frame())
 67         visitor.addOpaqueRoot(frame);
 68 


 69     // Normally JSEventTargetCustom.cpp&#39;s JSEventTarget::visitAdditionalChildren() would call this. But
 70     // even though DOMWindow is an EventTarget, JSDOMWindow does not subclass JSEventTarget, so we need
 71     // to do this here.
 72     wrapped().visitJSEventListeners(visitor);
 73 }
 74 
 75 #if ENABLE(USER_MESSAGE_HANDLERS)
 76 static EncodedJSValue jsDOMWindowWebKit(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 77 {
 78     VM&amp; vm = exec-&gt;vm();
 79     JSDOMWindow* castedThis = toJSDOMWindow(vm, JSValue::decode(thisValue));
 80     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, castedThis-&gt;wrapped()))
 81         return JSValue::encode(jsUndefined());
 82     return JSValue::encode(toJS(exec, castedThis-&gt;globalObject(), castedThis-&gt;wrapped().webkitNamespace()));
 83 }
 84 #endif
 85 
 86 template &lt;DOMWindowType windowType&gt;
 87 bool jsDOMWindowGetOwnPropertySlotRestrictedAccess(JSDOMGlobalObject* thisObject, AbstractDOMWindow&amp; window, ExecState&amp; state, PropertyName propertyName, PropertySlot&amp; slot, const String&amp; errorMessage)
 88 {
</pre>
<hr />
<pre>
131             CustomGetterSetter* customGetterSetter = CustomGetterSetter::create(vm, entry-&gt;propertyGetter(), shouldExposeSetter ? entry-&gt;propertyPutter() : nullptr);
132             slot.setCustomGetterSetter(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DontEnum), customGetterSetter);
133             return true;
134         }
135 
136         // For any other entries in the static property table, deny access. (Early return also prevents
137         // named getter from returning frames with matching names - this seems a little questionable, see
138         // FIXME comment on prototype search below.)
139         throwSecurityError(state, scope, errorMessage);
140         slot.setUndefined();
141         return false;
142     }
143 
144     // Check for child frames by name before built-in properties to match Mozilla. This does
145     // not match IE, but some sites end up naming frames things that conflict with window
146     // properties that are in Moz but not IE. Since we have some of these, we have to do it
147     // the Moz way.
148     // FIXME: Add support to named attributes on RemoteFrames.
149     auto* frame = window.frame();
150     if (frame &amp;&amp; is&lt;Frame&gt;(*frame)) {
<span class="line-modified">151         if (auto* scopedChild = downcast&lt;Frame&gt;(*frame).tree().scopedChild(propertyNameToAtomicString(propertyName))) {</span>
152             slot.setValue(thisObject, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum, toJS(&amp;state, scopedChild-&gt;document()-&gt;domWindow()));
153             return true;
154         }
155     }
156 
157     if (handleCommonCrossOriginProperties(thisObject, vm, propertyName, slot))
158         return true;
159 
160     throwSecurityError(state, scope, errorMessage);
161     slot.setUndefined();
162     return false;
163 }
164 template bool jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(JSDOMGlobalObject*, AbstractDOMWindow&amp;, ExecState&amp;, PropertyName, PropertySlot&amp;, const String&amp;);
165 template bool jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Remote&gt;(JSDOMGlobalObject*, AbstractDOMWindow&amp;, ExecState&amp;, PropertyName, PropertySlot&amp;, const String&amp;);
166 
167 // https://html.spec.whatwg.org/#crossorigingetownpropertyhelper-(-o,-p-)
168 bool handleCommonCrossOriginProperties(JSObject* thisObject, VM&amp; vm, PropertyName propertyName, PropertySlot&amp; slot)
169 {
170     auto&amp; propertyNames =  vm.propertyNames;
171     if (propertyName == propertyNames-&gt;builtinNames().thenPublicName() || propertyName == propertyNames-&gt;toStringTagSymbol || propertyName == propertyNames-&gt;hasInstanceSymbol || propertyName == propertyNames-&gt;isConcatSpreadableSymbol) {
</pre>
<hr />
<pre>
211             return true;
212         slot = slotCopy;
213     }
214 
215 #if ENABLE(USER_MESSAGE_HANDLERS)
216     if (propertyName == static_cast&lt;JSVMClientData*&gt;(state-&gt;vm().clientData)-&gt;builtinNames().webkitPublicName() &amp;&amp; thisObject-&gt;wrapped().shouldHaveWebKitNamespaceForWorld(thisObject-&gt;world())) {
217         slot.setCacheableCustom(thisObject, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly, jsDOMWindowWebKit);
218         return true;
219     }
220 #endif
221 
222     return false;
223 }
224 
225 // Property access sequence is:
226 // (1) indexed properties,
227 // (2) regular own properties,
228 // (3) named properties (in fact, these shouldn&#39;t be on the window, should be on the NPO).
229 bool JSDOMWindow::getOwnPropertySlotByIndex(JSObject* object, ExecState* state, unsigned index, PropertySlot&amp; slot)
230 {

231     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
232     auto&amp; window = thisObject-&gt;wrapped();
233     auto* frame = window.frame();
234 
235     // Indexed getters take precendence over regular properties, so caching would be invalid.
236     slot.disableCaching();
237 
238     String errorMessage;
239     Optional&lt;bool&gt; cachedIsCrossOriginAccess;
240     auto isCrossOriginAccess = [&amp;] {
241         if (!cachedIsCrossOriginAccess)
242             cachedIsCrossOriginAccess = !BindingSecurity::shouldAllowAccessToDOMWindow(*state, window, errorMessage);
243         return *cachedIsCrossOriginAccess;
244     };
245 
246     // (1) First, indexed properties.
247     // These are also allowed cross-origin, so come before the access check.
248     if (frame &amp;&amp; index &lt; frame-&gt;tree().scopedChildCount()) {
249         slot.setValue(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::ReadOnly), toJS(state, frame-&gt;tree().scopedChild(index)-&gt;document()-&gt;domWindow()));
250         return true;
251     }
252 
253     // Hand off all cross-domain/frameless access to jsDOMWindowGetOwnPropertySlotRestrictedAccess.
254     if (isCrossOriginAccess())
<span class="line-modified">255         return jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(thisObject, window, *state, Identifier::from(state, index), slot, errorMessage);</span>
256 
257     // (2) Regular own properties.
258     return Base::getOwnPropertySlotByIndex(thisObject, state, index, slot);
259 }
260 



















261 bool JSDOMWindow::put(JSCell* cell, ExecState* state, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
262 {
263     VM&amp; vm = state-&gt;vm();
264     auto scope = DECLARE_THROW_SCOPE(vm);
265 
266     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
267     if (!thisObject-&gt;wrapped().frame())
268         return false;
269 
270     String errorMessage;
271     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*state, thisObject-&gt;wrapped(), errorMessage)) {
272         // We only allow setting &quot;location&quot; attribute cross-origin.
273         if (propertyName == static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().locationPublicName()) {
274             bool putResult = false;
275             if (lookupPut(state, propertyName, thisObject, value, *s_info.staticPropHashTable, slot, putResult))
276                 return putResult;
277             return false;
278         }
279         throwSecurityError(*state, scope, errorMessage);
280         return false;
</pre>
<hr />
<pre>
293 }
294 
295 bool JSDOMWindow::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)
296 {
297     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
298     // Only allow deleting properties by frames in the same origin.
299     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), ThrowSecurityError))
300         return false;
301     return Base::deleteProperty(thisObject, exec, propertyName);
302 }
303 
304 bool JSDOMWindow::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned propertyName)
305 {
306     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
307     // Only allow deleting properties by frames in the same origin.
308     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), ThrowSecurityError))
309         return false;
310     return Base::deletePropertyByIndex(thisObject, exec, propertyName);
311 }
312 
<span class="line-modified">313 void JSDOMWindow::heapSnapshot(JSCell* cell, HeapSnapshotBuilder&amp; builder)</span>
314 {
315     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
316     auto&amp; location = thisObject-&gt;wrapped().location();
<span class="line-modified">317     builder.setLabelForCell(cell, location.href());</span>
318 
<span class="line-modified">319     Base::heapSnapshot(cell, builder);</span>
320 }
321 
322 // https://html.spec.whatwg.org/#crossoriginproperties-(-o-)
323 template &lt;CrossOriginObject objectType&gt;
324 static void addCrossOriginPropertyNames(VM&amp; vm, PropertyNameArray&amp; propertyNames)
325 {
326     auto&amp; builtinNames = static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames();
327     switch (objectType) {
328     case CrossOriginObject::Location: {
329         static const Identifier* const properties[] = { &amp;builtinNames.hrefPublicName(), &amp;vm.propertyNames-&gt;replace };
330         for (auto* property : properties)
331             propertyNames.add(*property);
332         break;
333     }
334     case CrossOriginObject::Window: {
335         static const Identifier* const properties[] = {
336             &amp;builtinNames.blurPublicName(), &amp;builtinNames.closePublicName(), &amp;builtinNames.closedPublicName(),
337             &amp;builtinNames.focusPublicName(), &amp;builtinNames.framesPublicName(), &amp;vm.propertyNames-&gt;length,
338             &amp;builtinNames.locationPublicName(), &amp;builtinNames.openerPublicName(), &amp;builtinNames.parentPublicName(),
339             &amp;builtinNames.postMessagePublicName(), &amp;builtinNames.selfPublicName(), &amp;builtinNames.topPublicName(),
</pre>
<hr />
<pre>
358         &amp;vm.propertyNames-&gt;builtinNames().thenPublicName(), &amp;vm.propertyNames-&gt;toStringTagSymbol, &amp;vm.propertyNames-&gt;hasInstanceSymbol, &amp;vm.propertyNames-&gt;isConcatSpreadableSymbol
359     };
360 
361     for (auto* property : properties)
362         propertyNames.add(*property);
363 
364 }
365 template void addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Window&gt;(JSC::ExecState&amp;, JSC::PropertyNameArray&amp;);
366 template void addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Location&gt;(JSC::ExecState&amp;, JSC::PropertyNameArray&amp;);
367 
368 static void addScopedChildrenIndexes(ExecState&amp; state, DOMWindow&amp; window, PropertyNameArray&amp; propertyNames)
369 {
370     auto* document = window.document();
371     if (!document)
372         return;
373 
374     auto* frame = document-&gt;frame();
375     if (!frame)
376         return;
377 

378     unsigned scopedChildCount = frame-&gt;tree().scopedChildCount();
379     for (unsigned i = 0; i &lt; scopedChildCount; ++i)
<span class="line-modified">380         propertyNames.add(Identifier::from(&amp;state, i));</span>
381 }
382 
383 // https://html.spec.whatwg.org/#windowproxy-ownpropertykeys
384 void JSDOMWindow::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
385 {
386     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
387 
388     addScopedChildrenIndexes(*exec, thisObject-&gt;wrapped(), propertyNames);
389 
390     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), DoNotReportSecurityError)) {
391         if (mode.includeDontEnumProperties())
392             addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Window&gt;(*exec, propertyNames);
393         return;
394     }
395     Base::getOwnPropertyNames(thisObject, exec, propertyNames, mode);
396 }
397 
398 bool JSDOMWindow::defineOwnProperty(JSC::JSObject* object, JSC::ExecState* exec, JSC::PropertyName propertyName, const JSC::PropertyDescriptor&amp; descriptor, bool shouldThrow)
399 {

400     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
401     // Only allow defining properties in this way by frames in the same origin, as it allows setters to be introduced.
402     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), ThrowSecurityError))
403         return false;
404 
405     // Don&#39;t allow shadowing location using accessor properties.
<span class="line-modified">406     if (descriptor.isAccessorDescriptor() &amp;&amp; propertyName == Identifier::fromString(exec, &quot;location&quot;))</span>
407         return false;
408 
409     return Base::defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow);
410 }
411 
412 JSValue JSDOMWindow::getPrototype(JSObject* object, ExecState* exec)
413 {
414     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
415     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), DoNotReportSecurityError))
416         return jsNull();
417 
418     return Base::getPrototype(object, exec);
419 }
420 
421 bool JSDOMWindow::preventExtensions(JSObject*, ExecState* exec)
422 {
423     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
424 
425     throwTypeError(exec, scope, &quot;Cannot prevent extensions on this object&quot;_s);
426     return false;
</pre>
<hr />
<pre>
446 
447 // Custom functions
448 
449 class DialogHandler {
450 public:
451     explicit DialogHandler(ExecState&amp; exec)
452         : m_exec(exec)
453     {
454     }
455 
456     void dialogCreated(DOMWindow&amp;);
457     JSValue returnValue() const;
458 
459 private:
460     ExecState&amp; m_exec;
461     RefPtr&lt;Frame&gt; m_frame;
462 };
463 
464 inline void DialogHandler::dialogCreated(DOMWindow&amp; dialog)
465 {

466     m_frame = dialog.frame();
467 
468     // FIXME: This looks like a leak between the normal world and an isolated
469     //        world if dialogArguments comes from an isolated world.
<span class="line-modified">470     JSDOMWindow* globalObject = toJSDOMWindow(m_frame.get(), normalWorld(m_exec.vm()));</span>
471     if (JSValue dialogArguments = m_exec.argument(1))
<span class="line-modified">472         globalObject-&gt;putDirect(m_exec.vm(), Identifier::fromString(&amp;m_exec, &quot;dialogArguments&quot;), dialogArguments);</span>
473 }
474 
475 inline JSValue DialogHandler::returnValue() const
476 {
<span class="line-modified">477     JSDOMWindow* globalObject = toJSDOMWindow(m_frame.get(), normalWorld(m_exec.vm()));</span>

478     if (!globalObject)
479         return jsUndefined();
<span class="line-modified">480     Identifier identifier = Identifier::fromString(&amp;m_exec, &quot;returnValue&quot;);</span>
481     PropertySlot slot(globalObject, PropertySlot::InternalMethodType::Get);
482     if (!JSGlobalObject::getOwnPropertySlot(globalObject, &amp;m_exec, identifier, slot))
483         return jsUndefined();
484     return slot.getValue(&amp;m_exec, identifier);
485 }
486 
487 JSValue JSDOMWindow::showModalDialog(ExecState&amp; state)
488 {
489     VM&amp; vm = state.vm();
490     auto scope = DECLARE_THROW_SCOPE(vm);
491 
492     if (UNLIKELY(state.argumentCount() &lt; 1))
493         return throwException(&amp;state, scope, createNotEnoughArgumentsError(&amp;state));
494 
495     String urlString = convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(state, state.argument(0));
496     RETURN_IF_EXCEPTION(scope, JSValue());
497     String dialogFeaturesString = convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(state, state.argument(2));
498     RETURN_IF_EXCEPTION(scope, JSValue());
499 
500     DialogHandler handler(state);
</pre>
<hr />
<pre>
529         return nullptr;
530     JSObject* object = asObject(value);
531     if (object-&gt;inherits&lt;JSDOMWindow&gt;(vm))
532         return &amp;jsCast&lt;JSDOMWindow*&gt;(object)-&gt;wrapped();
533     if (object-&gt;inherits&lt;JSWindowProxy&gt;(vm)) {
534         if (auto* jsDOMWindow = jsDynamicCast&lt;JSDOMWindow*&gt;(vm, jsCast&lt;JSWindowProxy*&gt;(object)-&gt;window()))
535             return &amp;jsDOMWindow-&gt;wrapped();
536     }
537     return nullptr;
538 }
539 
540 void JSDOMWindow::setOpener(JSC::ExecState&amp; state, JSC::JSValue value)
541 {
542     if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, wrapped(), ThrowSecurityError))
543         return;
544 
545     if (value.isNull()) {
546         wrapped().disownOpener();
547         return;
548     }
<span class="line-modified">549     replaceStaticPropertySlot(state.vm(), this, Identifier::fromString(&amp;state.vm(), &quot;opener&quot;), value);</span>

550 }
551 












































































552 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2011 Google Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;JSDOMWindowCustom.h&quot;
 23 
 24 #include &quot;DOMWindowIndexedDatabase.h&quot;
<span class="line-added"> 25 #include &quot;DOMWindowWebDatabase.h&quot;</span>
 26 #include &quot;Frame.h&quot;
 27 #include &quot;HTMLCollection.h&quot;
 28 #include &quot;HTMLDocument.h&quot;
 29 #include &quot;HTMLFrameOwnerElement.h&quot;
 30 #include &quot;HTTPParsers.h&quot;
 31 #include &quot;JSDOMBindingSecurity.h&quot;
 32 #include &quot;JSDOMConvertNullable.h&quot;
 33 #include &quot;JSDOMConvertNumbers.h&quot;
 34 #include &quot;JSDOMConvertStrings.h&quot;
<span class="line-added"> 35 #include &quot;JSDatabase.h&quot;</span>
<span class="line-added"> 36 #include &quot;JSDatabaseCallback.h&quot;</span>
 37 #include &quot;JSEvent.h&quot;
 38 #include &quot;JSEventListener.h&quot;
 39 #include &quot;JSHTMLAudioElement.h&quot;
 40 #include &quot;JSHTMLCollection.h&quot;
 41 #include &quot;JSHTMLOptionElement.h&quot;
 42 #include &quot;JSIDBFactory.h&quot;
 43 #include &quot;JSRemoteDOMWindow.h&quot;
 44 #include &quot;JSWindowProxy.h&quot;
 45 #include &quot;JSWorker.h&quot;
 46 #include &quot;Location.h&quot;
 47 #include &quot;RuntimeEnabledFeatures.h&quot;
 48 #include &quot;ScheduledAction.h&quot;
 49 #include &quot;Settings.h&quot;
 50 #include &quot;WebCoreJSClientData.h&quot;
 51 #include &lt;JavaScriptCore/BuiltinNames.h&gt;
<span class="line-modified"> 52 #include &lt;JavaScriptCore/HeapAnalyzer.h&gt;</span>
 53 #include &lt;JavaScriptCore/JSCInlines.h&gt;
<span class="line-added"> 54 #include &lt;JavaScriptCore/JSFunction.h&gt;</span>
 55 #include &lt;JavaScriptCore/JSMicrotask.h&gt;
 56 #include &lt;JavaScriptCore/Lookup.h&gt;
<span class="line-added"> 57 #include &lt;JavaScriptCore/Structure.h&gt;</span>
 58 
 59 #if ENABLE(USER_MESSAGE_HANDLERS)
 60 #include &quot;JSWebKitNamespace.h&quot;
 61 #endif
 62 
 63 
 64 namespace WebCore {
 65 using namespace JSC;
 66 
 67 EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionShowModalDialog(ExecState*);
<span class="line-added"> 68 EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionOpenDatabase(ExecState*);</span>
 69 
 70 void JSDOMWindow::visitAdditionalChildren(SlotVisitor&amp; visitor)
 71 {
 72     if (Frame* frame = wrapped().frame())
 73         visitor.addOpaqueRoot(frame);
 74 
<span class="line-added"> 75     visitor.addOpaqueRoot(&amp;wrapped());</span>
<span class="line-added"> 76 </span>
 77     // Normally JSEventTargetCustom.cpp&#39;s JSEventTarget::visitAdditionalChildren() would call this. But
 78     // even though DOMWindow is an EventTarget, JSDOMWindow does not subclass JSEventTarget, so we need
 79     // to do this here.
 80     wrapped().visitJSEventListeners(visitor);
 81 }
 82 
 83 #if ENABLE(USER_MESSAGE_HANDLERS)
 84 static EncodedJSValue jsDOMWindowWebKit(ExecState* exec, EncodedJSValue thisValue, PropertyName)
 85 {
 86     VM&amp; vm = exec-&gt;vm();
 87     JSDOMWindow* castedThis = toJSDOMWindow(vm, JSValue::decode(thisValue));
 88     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, castedThis-&gt;wrapped()))
 89         return JSValue::encode(jsUndefined());
 90     return JSValue::encode(toJS(exec, castedThis-&gt;globalObject(), castedThis-&gt;wrapped().webkitNamespace()));
 91 }
 92 #endif
 93 
 94 template &lt;DOMWindowType windowType&gt;
 95 bool jsDOMWindowGetOwnPropertySlotRestrictedAccess(JSDOMGlobalObject* thisObject, AbstractDOMWindow&amp; window, ExecState&amp; state, PropertyName propertyName, PropertySlot&amp; slot, const String&amp; errorMessage)
 96 {
</pre>
<hr />
<pre>
139             CustomGetterSetter* customGetterSetter = CustomGetterSetter::create(vm, entry-&gt;propertyGetter(), shouldExposeSetter ? entry-&gt;propertyPutter() : nullptr);
140             slot.setCustomGetterSetter(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DontEnum), customGetterSetter);
141             return true;
142         }
143 
144         // For any other entries in the static property table, deny access. (Early return also prevents
145         // named getter from returning frames with matching names - this seems a little questionable, see
146         // FIXME comment on prototype search below.)
147         throwSecurityError(state, scope, errorMessage);
148         slot.setUndefined();
149         return false;
150     }
151 
152     // Check for child frames by name before built-in properties to match Mozilla. This does
153     // not match IE, but some sites end up naming frames things that conflict with window
154     // properties that are in Moz but not IE. Since we have some of these, we have to do it
155     // the Moz way.
156     // FIXME: Add support to named attributes on RemoteFrames.
157     auto* frame = window.frame();
158     if (frame &amp;&amp; is&lt;Frame&gt;(*frame)) {
<span class="line-modified">159         if (auto* scopedChild = downcast&lt;Frame&gt;(*frame).tree().scopedChild(propertyNameToAtomString(propertyName))) {</span>
160             slot.setValue(thisObject, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum, toJS(&amp;state, scopedChild-&gt;document()-&gt;domWindow()));
161             return true;
162         }
163     }
164 
165     if (handleCommonCrossOriginProperties(thisObject, vm, propertyName, slot))
166         return true;
167 
168     throwSecurityError(state, scope, errorMessage);
169     slot.setUndefined();
170     return false;
171 }
172 template bool jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(JSDOMGlobalObject*, AbstractDOMWindow&amp;, ExecState&amp;, PropertyName, PropertySlot&amp;, const String&amp;);
173 template bool jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Remote&gt;(JSDOMGlobalObject*, AbstractDOMWindow&amp;, ExecState&amp;, PropertyName, PropertySlot&amp;, const String&amp;);
174 
175 // https://html.spec.whatwg.org/#crossorigingetownpropertyhelper-(-o,-p-)
176 bool handleCommonCrossOriginProperties(JSObject* thisObject, VM&amp; vm, PropertyName propertyName, PropertySlot&amp; slot)
177 {
178     auto&amp; propertyNames =  vm.propertyNames;
179     if (propertyName == propertyNames-&gt;builtinNames().thenPublicName() || propertyName == propertyNames-&gt;toStringTagSymbol || propertyName == propertyNames-&gt;hasInstanceSymbol || propertyName == propertyNames-&gt;isConcatSpreadableSymbol) {
</pre>
<hr />
<pre>
219             return true;
220         slot = slotCopy;
221     }
222 
223 #if ENABLE(USER_MESSAGE_HANDLERS)
224     if (propertyName == static_cast&lt;JSVMClientData*&gt;(state-&gt;vm().clientData)-&gt;builtinNames().webkitPublicName() &amp;&amp; thisObject-&gt;wrapped().shouldHaveWebKitNamespaceForWorld(thisObject-&gt;world())) {
225         slot.setCacheableCustom(thisObject, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly, jsDOMWindowWebKit);
226         return true;
227     }
228 #endif
229 
230     return false;
231 }
232 
233 // Property access sequence is:
234 // (1) indexed properties,
235 // (2) regular own properties,
236 // (3) named properties (in fact, these shouldn&#39;t be on the window, should be on the NPO).
237 bool JSDOMWindow::getOwnPropertySlotByIndex(JSObject* object, ExecState* state, unsigned index, PropertySlot&amp; slot)
238 {
<span class="line-added">239     VM&amp; vm = state-&gt;vm();</span>
240     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
241     auto&amp; window = thisObject-&gt;wrapped();
242     auto* frame = window.frame();
243 
244     // Indexed getters take precendence over regular properties, so caching would be invalid.
245     slot.disableCaching();
246 
247     String errorMessage;
248     Optional&lt;bool&gt; cachedIsCrossOriginAccess;
249     auto isCrossOriginAccess = [&amp;] {
250         if (!cachedIsCrossOriginAccess)
251             cachedIsCrossOriginAccess = !BindingSecurity::shouldAllowAccessToDOMWindow(*state, window, errorMessage);
252         return *cachedIsCrossOriginAccess;
253     };
254 
255     // (1) First, indexed properties.
256     // These are also allowed cross-origin, so come before the access check.
257     if (frame &amp;&amp; index &lt; frame-&gt;tree().scopedChildCount()) {
258         slot.setValue(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::ReadOnly), toJS(state, frame-&gt;tree().scopedChild(index)-&gt;document()-&gt;domWindow()));
259         return true;
260     }
261 
262     // Hand off all cross-domain/frameless access to jsDOMWindowGetOwnPropertySlotRestrictedAccess.
263     if (isCrossOriginAccess())
<span class="line-modified">264         return jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(thisObject, window, *state, Identifier::from(vm, index), slot, errorMessage);</span>
265 
266     // (2) Regular own properties.
267     return Base::getOwnPropertySlotByIndex(thisObject, state, index, slot);
268 }
269 
<span class="line-added">270 void JSDOMWindow::doPutPropertySecurityCheck(JSObject* cell, ExecState* state, PropertyName propertyName, PutPropertySlot&amp;)</span>
<span class="line-added">271 {</span>
<span class="line-added">272     VM&amp; vm = state-&gt;vm();</span>
<span class="line-added">273     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">274 </span>
<span class="line-added">275     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);</span>
<span class="line-added">276     if (!thisObject-&gt;wrapped().frame())</span>
<span class="line-added">277         return;</span>
<span class="line-added">278 </span>
<span class="line-added">279     String errorMessage;</span>
<span class="line-added">280     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*state, thisObject-&gt;wrapped(), errorMessage)) {</span>
<span class="line-added">281         // We only allow setting &quot;location&quot; attribute cross-origin.</span>
<span class="line-added">282         if (propertyName == static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().locationPublicName())</span>
<span class="line-added">283             return;</span>
<span class="line-added">284         throwSecurityError(*state, scope, errorMessage);</span>
<span class="line-added">285         return;</span>
<span class="line-added">286     }</span>
<span class="line-added">287 }</span>
<span class="line-added">288 </span>
289 bool JSDOMWindow::put(JSCell* cell, ExecState* state, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
290 {
291     VM&amp; vm = state-&gt;vm();
292     auto scope = DECLARE_THROW_SCOPE(vm);
293 
294     auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
295     if (!thisObject-&gt;wrapped().frame())
296         return false;
297 
298     String errorMessage;
299     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*state, thisObject-&gt;wrapped(), errorMessage)) {
300         // We only allow setting &quot;location&quot; attribute cross-origin.
301         if (propertyName == static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().locationPublicName()) {
302             bool putResult = false;
303             if (lookupPut(state, propertyName, thisObject, value, *s_info.staticPropHashTable, slot, putResult))
304                 return putResult;
305             return false;
306         }
307         throwSecurityError(*state, scope, errorMessage);
308         return false;
</pre>
<hr />
<pre>
321 }
322 
323 bool JSDOMWindow::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)
324 {
325     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
326     // Only allow deleting properties by frames in the same origin.
327     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), ThrowSecurityError))
328         return false;
329     return Base::deleteProperty(thisObject, exec, propertyName);
330 }
331 
332 bool JSDOMWindow::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned propertyName)
333 {
334     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
335     // Only allow deleting properties by frames in the same origin.
336     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), ThrowSecurityError))
337         return false;
338     return Base::deletePropertyByIndex(thisObject, exec, propertyName);
339 }
340 
<span class="line-modified">341 void JSDOMWindow::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)</span>
342 {
343     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
344     auto&amp; location = thisObject-&gt;wrapped().location();
<span class="line-modified">345     analyzer.setLabelForCell(cell, location.href());</span>
346 
<span class="line-modified">347     Base::analyzeHeap(cell, analyzer);</span>
348 }
349 
350 // https://html.spec.whatwg.org/#crossoriginproperties-(-o-)
351 template &lt;CrossOriginObject objectType&gt;
352 static void addCrossOriginPropertyNames(VM&amp; vm, PropertyNameArray&amp; propertyNames)
353 {
354     auto&amp; builtinNames = static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames();
355     switch (objectType) {
356     case CrossOriginObject::Location: {
357         static const Identifier* const properties[] = { &amp;builtinNames.hrefPublicName(), &amp;vm.propertyNames-&gt;replace };
358         for (auto* property : properties)
359             propertyNames.add(*property);
360         break;
361     }
362     case CrossOriginObject::Window: {
363         static const Identifier* const properties[] = {
364             &amp;builtinNames.blurPublicName(), &amp;builtinNames.closePublicName(), &amp;builtinNames.closedPublicName(),
365             &amp;builtinNames.focusPublicName(), &amp;builtinNames.framesPublicName(), &amp;vm.propertyNames-&gt;length,
366             &amp;builtinNames.locationPublicName(), &amp;builtinNames.openerPublicName(), &amp;builtinNames.parentPublicName(),
367             &amp;builtinNames.postMessagePublicName(), &amp;builtinNames.selfPublicName(), &amp;builtinNames.topPublicName(),
</pre>
<hr />
<pre>
386         &amp;vm.propertyNames-&gt;builtinNames().thenPublicName(), &amp;vm.propertyNames-&gt;toStringTagSymbol, &amp;vm.propertyNames-&gt;hasInstanceSymbol, &amp;vm.propertyNames-&gt;isConcatSpreadableSymbol
387     };
388 
389     for (auto* property : properties)
390         propertyNames.add(*property);
391 
392 }
393 template void addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Window&gt;(JSC::ExecState&amp;, JSC::PropertyNameArray&amp;);
394 template void addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Location&gt;(JSC::ExecState&amp;, JSC::PropertyNameArray&amp;);
395 
396 static void addScopedChildrenIndexes(ExecState&amp; state, DOMWindow&amp; window, PropertyNameArray&amp; propertyNames)
397 {
398     auto* document = window.document();
399     if (!document)
400         return;
401 
402     auto* frame = document-&gt;frame();
403     if (!frame)
404         return;
405 
<span class="line-added">406     VM&amp; vm = state.vm();</span>
407     unsigned scopedChildCount = frame-&gt;tree().scopedChildCount();
408     for (unsigned i = 0; i &lt; scopedChildCount; ++i)
<span class="line-modified">409         propertyNames.add(Identifier::from(vm, i));</span>
410 }
411 
412 // https://html.spec.whatwg.org/#windowproxy-ownpropertykeys
413 void JSDOMWindow::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
414 {
415     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
416 
417     addScopedChildrenIndexes(*exec, thisObject-&gt;wrapped(), propertyNames);
418 
419     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), DoNotReportSecurityError)) {
420         if (mode.includeDontEnumProperties())
421             addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Window&gt;(*exec, propertyNames);
422         return;
423     }
424     Base::getOwnPropertyNames(thisObject, exec, propertyNames, mode);
425 }
426 
427 bool JSDOMWindow::defineOwnProperty(JSC::JSObject* object, JSC::ExecState* exec, JSC::PropertyName propertyName, const JSC::PropertyDescriptor&amp; descriptor, bool shouldThrow)
428 {
<span class="line-added">429     JSC::VM&amp; vm = exec-&gt;vm();</span>
430     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
431     // Only allow defining properties in this way by frames in the same origin, as it allows setters to be introduced.
432     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), ThrowSecurityError))
433         return false;
434 
435     // Don&#39;t allow shadowing location using accessor properties.
<span class="line-modified">436     if (descriptor.isAccessorDescriptor() &amp;&amp; propertyName == Identifier::fromString(vm, &quot;location&quot;))</span>
437         return false;
438 
439     return Base::defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow);
440 }
441 
442 JSValue JSDOMWindow::getPrototype(JSObject* object, ExecState* exec)
443 {
444     JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
445     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), DoNotReportSecurityError))
446         return jsNull();
447 
448     return Base::getPrototype(object, exec);
449 }
450 
451 bool JSDOMWindow::preventExtensions(JSObject*, ExecState* exec)
452 {
453     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
454 
455     throwTypeError(exec, scope, &quot;Cannot prevent extensions on this object&quot;_s);
456     return false;
</pre>
<hr />
<pre>
476 
477 // Custom functions
478 
479 class DialogHandler {
480 public:
481     explicit DialogHandler(ExecState&amp; exec)
482         : m_exec(exec)
483     {
484     }
485 
486     void dialogCreated(DOMWindow&amp;);
487     JSValue returnValue() const;
488 
489 private:
490     ExecState&amp; m_exec;
491     RefPtr&lt;Frame&gt; m_frame;
492 };
493 
494 inline void DialogHandler::dialogCreated(DOMWindow&amp; dialog)
495 {
<span class="line-added">496     VM&amp; vm = m_exec.vm();</span>
497     m_frame = dialog.frame();
498 
499     // FIXME: This looks like a leak between the normal world and an isolated
500     //        world if dialogArguments comes from an isolated world.
<span class="line-modified">501     JSDOMWindow* globalObject = toJSDOMWindow(m_frame.get(), normalWorld(vm));</span>
502     if (JSValue dialogArguments = m_exec.argument(1))
<span class="line-modified">503         globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;dialogArguments&quot;), dialogArguments);</span>
504 }
505 
506 inline JSValue DialogHandler::returnValue() const
507 {
<span class="line-modified">508     VM&amp; vm = m_exec.vm();</span>
<span class="line-added">509     JSDOMWindow* globalObject = toJSDOMWindow(m_frame.get(), normalWorld(vm));</span>
510     if (!globalObject)
511         return jsUndefined();
<span class="line-modified">512     Identifier identifier = Identifier::fromString(vm, &quot;returnValue&quot;);</span>
513     PropertySlot slot(globalObject, PropertySlot::InternalMethodType::Get);
514     if (!JSGlobalObject::getOwnPropertySlot(globalObject, &amp;m_exec, identifier, slot))
515         return jsUndefined();
516     return slot.getValue(&amp;m_exec, identifier);
517 }
518 
519 JSValue JSDOMWindow::showModalDialog(ExecState&amp; state)
520 {
521     VM&amp; vm = state.vm();
522     auto scope = DECLARE_THROW_SCOPE(vm);
523 
524     if (UNLIKELY(state.argumentCount() &lt; 1))
525         return throwException(&amp;state, scope, createNotEnoughArgumentsError(&amp;state));
526 
527     String urlString = convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(state, state.argument(0));
528     RETURN_IF_EXCEPTION(scope, JSValue());
529     String dialogFeaturesString = convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(state, state.argument(2));
530     RETURN_IF_EXCEPTION(scope, JSValue());
531 
532     DialogHandler handler(state);
</pre>
<hr />
<pre>
561         return nullptr;
562     JSObject* object = asObject(value);
563     if (object-&gt;inherits&lt;JSDOMWindow&gt;(vm))
564         return &amp;jsCast&lt;JSDOMWindow*&gt;(object)-&gt;wrapped();
565     if (object-&gt;inherits&lt;JSWindowProxy&gt;(vm)) {
566         if (auto* jsDOMWindow = jsDynamicCast&lt;JSDOMWindow*&gt;(vm, jsCast&lt;JSWindowProxy*&gt;(object)-&gt;window()))
567             return &amp;jsDOMWindow-&gt;wrapped();
568     }
569     return nullptr;
570 }
571 
572 void JSDOMWindow::setOpener(JSC::ExecState&amp; state, JSC::JSValue value)
573 {
574     if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, wrapped(), ThrowSecurityError))
575         return;
576 
577     if (value.isNull()) {
578         wrapped().disownOpener();
579         return;
580     }
<span class="line-modified">581     VM&amp; vm = state.vm();</span>
<span class="line-added">582     replaceStaticPropertySlot(vm, this, Identifier::fromString(vm, &quot;opener&quot;), value);</span>
583 }
584 
<span class="line-added">585 JSValue JSDOMWindow::self(JSC::ExecState&amp;) const</span>
<span class="line-added">586 {</span>
<span class="line-added">587     return globalThis();</span>
<span class="line-added">588 }</span>
<span class="line-added">589 </span>
<span class="line-added">590 JSValue JSDOMWindow::window(JSC::ExecState&amp;) const</span>
<span class="line-added">591 {</span>
<span class="line-added">592     return globalThis();</span>
<span class="line-added">593 }</span>
<span class="line-added">594 </span>
<span class="line-added">595 JSValue JSDOMWindow::frames(JSC::ExecState&amp;) const</span>
<span class="line-added">596 {</span>
<span class="line-added">597     return globalThis();</span>
<span class="line-added">598 }</span>
<span class="line-added">599 </span>
<span class="line-added">600 static inline JSC::EncodedJSValue jsDOMWindowInstanceFunctionOpenDatabaseBody(JSC::ExecState* state, typename IDLOperation&lt;JSDOMWindow&gt;::ClassParameter castedThis, JSC::ThrowScope&amp; throwScope)</span>
<span class="line-added">601 {</span>
<span class="line-added">602     if (!BindingSecurity::shouldAllowAccessToDOMWindow(state, castedThis-&gt;wrapped(), ThrowSecurityError))</span>
<span class="line-added">603         return JSValue::encode(jsUndefined());</span>
<span class="line-added">604     auto&amp; impl = castedThis-&gt;wrapped();</span>
<span class="line-added">605     if (UNLIKELY(state-&gt;argumentCount() &lt; 4))</span>
<span class="line-added">606         return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));</span>
<span class="line-added">607     auto name = convert&lt;IDLDOMString&gt;(*state, state-&gt;uncheckedArgument(0));</span>
<span class="line-added">608     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());</span>
<span class="line-added">609     auto version = convert&lt;IDLDOMString&gt;(*state, state-&gt;uncheckedArgument(1));</span>
<span class="line-added">610     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());</span>
<span class="line-added">611     auto displayName = convert&lt;IDLDOMString&gt;(*state, state-&gt;uncheckedArgument(2));</span>
<span class="line-added">612     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());</span>
<span class="line-added">613     auto estimatedSize = convert&lt;IDLUnsignedLong&gt;(*state, state-&gt;uncheckedArgument(3));</span>
<span class="line-added">614     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());</span>
<span class="line-added">615 </span>
<span class="line-added">616     if (!RuntimeEnabledFeatures::sharedFeatures().webSQLEnabled()) {</span>
<span class="line-added">617         if (name != &quot;null&quot; || version != &quot;null&quot; || displayName != &quot;null&quot; || estimatedSize)</span>
<span class="line-added">618             propagateException(*state, throwScope, Exception(UnknownError, &quot;Web SQL is deprecated&quot;_s));</span>
<span class="line-added">619         return JSValue::encode(constructEmptyObject(state, castedThis-&gt;globalObject()-&gt;objectPrototype()));</span>
<span class="line-added">620     }</span>
<span class="line-added">621 </span>
<span class="line-added">622     auto creationCallback = convert&lt;IDLNullable&lt;IDLCallbackFunction&lt;JSDatabaseCallback&gt;&gt;&gt;(*state, state-&gt;argument(4), *castedThis-&gt;globalObject(), [](JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope) {</span>
<span class="line-added">623         throwArgumentMustBeFunctionError(state, scope, 4, &quot;creationCallback&quot;, &quot;Window&quot;, &quot;openDatabase&quot;);</span>
<span class="line-added">624     });</span>
<span class="line-added">625     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());</span>
<span class="line-added">626     return JSValue::encode(toJS&lt;IDLNullable&lt;IDLInterface&lt;Database&gt;&gt;&gt;(*state, *castedThis-&gt;globalObject(), throwScope, WebCore::DOMWindowWebDatabase::openDatabase(impl, WTFMove(name), WTFMove(version), WTFMove(displayName), WTFMove(estimatedSize), WTFMove(creationCallback))));</span>
<span class="line-added">627 }</span>
<span class="line-added">628 </span>
<span class="line-added">629 template&lt;&gt; inline JSDOMWindow* IDLOperation&lt;JSDOMWindow&gt;::cast(ExecState&amp; state)</span>
<span class="line-added">630 {</span>
<span class="line-added">631     return toJSDOMWindow(state.vm(), state.thisValue().toThis(&amp;state, NotStrictMode));</span>
<span class="line-added">632 }</span>
<span class="line-added">633 </span>
<span class="line-added">634 EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionOpenDatabase(JSGlobalObject*, CallFrame* callFrame)</span>
<span class="line-added">635 {</span>
<span class="line-added">636     return IDLOperation&lt;JSDOMWindow&gt;::call&lt;jsDOMWindowInstanceFunctionOpenDatabaseBody&gt;(*callFrame, &quot;openDatabase&quot;);</span>
<span class="line-added">637 }</span>
<span class="line-added">638 </span>
<span class="line-added">639 // // FIXME-java: Currently WebSQL feature is not implemented completely in JavaFX port.</span>
<span class="line-added">640 // #if !PLATFORM(JAVA)</span>
<span class="line-added">641 // JSValue JSDOMWindow::openDatabase(JSC::ExecState&amp; state) const</span>
<span class="line-added">642 // {</span>
<span class="line-added">643 //     VM&amp; vm = state.vm();</span>
<span class="line-added">644 //     StringImpl* name = PropertyName(static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().openDatabasePublicName()).publicName();</span>
<span class="line-added">645 //     if (RuntimeEnabledFeatures::sharedFeatures().webSQLEnabled())</span>
<span class="line-added">646 //         return JSFunction::create(vm, state.lexicalGlobalObject(), 4, name, jsDOMWindowInstanceFunctionOpenDatabase, NoIntrinsic);</span>
<span class="line-added">647 </span>
<span class="line-added">648 //     return JSFunction::createFunctionThatMasqueradesAsUndefined(vm, state.lexicalGlobalObject(), 4, name, jsDOMWindowInstanceFunctionOpenDatabase, NoIntrinsic);</span>
<span class="line-added">649 // }</span>
<span class="line-added">650 </span>
<span class="line-added">651 // void JSDOMWindow::setOpenDatabase(JSC::ExecState&amp; state, JSC::JSValue value)</span>
<span class="line-added">652 // {</span>
<span class="line-added">653 //     if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, wrapped(), ThrowSecurityError))</span>
<span class="line-added">654 //         return;</span>
<span class="line-added">655 </span>
<span class="line-added">656 //     VM&amp; vm = state.vm();</span>
<span class="line-added">657 //     replaceStaticPropertySlot(vm, this, Identifier::fromString(vm, &quot;openDatabase&quot;), value);</span>
<span class="line-added">658 // }</span>
<span class="line-added">659 // #endif</span>
<span class="line-added">660 </span>
661 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="JSDOMWindowBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMWindowProperties.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>