<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLMediaElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLMenuElement.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 109 
 110 #if ENABLE(VIDEO_TRACK)
 111 using CueIntervalTree = PODIntervalTree&lt;MediaTime, TextTrackCue*&gt;;
 112 using CueInterval = CueIntervalTree::IntervalType;
 113 using CueList = Vector&lt;CueInterval&gt;;
 114 #endif
 115 
 116 using MediaProvider = Optional&lt;Variant&lt;
 117 #if ENABLE(MEDIA_STREAM)
 118     RefPtr&lt;MediaStream&gt;,
 119 #endif
 120 #if ENABLE(MEDIA_SOURCE)
 121     RefPtr&lt;MediaSource&gt;,
 122 #endif
 123     RefPtr&lt;Blob&gt;&gt;&gt;;
 124 
 125 class HTMLMediaElement
 126     : public HTMLElement
 127     , public ActiveDOMObject
 128     , public MediaControllerInterface
<span class="line-removed"> 129     , public CanMakeWeakPtr&lt;HTMLMediaElement&gt;</span>
 130     , public PlatformMediaSessionClient
 131     , private MediaCanStartListener
 132     , private MediaPlayerClient
 133     , private MediaProducer
 134     , private VisibilityChangeClient
 135     , private ApplicationStateChangeListener
 136 #if ENABLE(VIDEO_TRACK)
 137     , private AudioTrackClient
 138     , private TextTrackClient
 139     , private VideoTrackClient
 140 #endif
 141 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 142     , private AudioSession::MutedStateObserver
 143 #endif
 144 #if ENABLE(ENCRYPTED_MEDIA)
 145     , private CDMClient
 146 #endif
 147 #if !RELEASE_LOG_DISABLED
 148     , private LoggerHelper
 149 #endif
 150 {
 151     WTF_MAKE_ISO_ALLOCATED(HTMLMediaElement);
 152 public:



 153     RefPtr&lt;MediaPlayer&gt; player() const { return m_player; }
 154 
 155     virtual bool isVideo() const { return false; }
 156     bool hasVideo() const override { return false; }
 157     bool hasAudio() const override;
 158 
 159     static HashSet&lt;HTMLMediaElement*&gt;&amp; allMediaElements();
 160 
 161     WEBCORE_EXPORT static RefPtr&lt;HTMLMediaElement&gt; bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose);
 162 
 163     static bool isRunningDestructor();
 164 
 165     WEBCORE_EXPORT void rewind(double timeDelta);
 166     WEBCORE_EXPORT void returnToRealtime() override;
 167 
 168     // Eventually overloaded in HTMLVideoElement
 169     bool supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenMode) const override { return false; };
 170 
 171     bool supportsScanning() const override;
 172 
 173     bool canSaveMediaData() const;
 174 
<span class="line-modified"> 175     bool doesHaveAttribute(const AtomicString&amp;, AtomicString* value = nullptr) const override;</span>
 176 
 177     PlatformLayer* platformLayer() const;
 178     bool isVideoLayerInline();
 179     void setPreparedToReturnVideoLayerToInline(bool);
 180     void waitForPreparedForInlineThen(WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
 181 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 182     void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
 183 #ifdef __OBJC__
 184     PlatformLayer* videoFullscreenLayer() const { return m_videoFullscreenLayer.get(); }
 185 #endif
 186     void setVideoFullscreenFrame(FloatRect);
 187     void setVideoFullscreenGravity(MediaPlayerEnums::VideoGravity);
 188     MediaPlayerEnums::VideoGravity videoFullscreenGravity() const { return m_videoFullscreenGravity; }
 189 #endif
 190 
 191     void scheduleCheckPlaybackTargetCompatability();
 192     void checkPlaybackTargetCompatablity();
 193     void scheduleResolvePendingPlayPromises();
 194     void scheduleRejectPendingPlayPromises(Ref&lt;DOMException&gt;&amp;&amp;);
 195     using PlayPromiseVector = Vector&lt;DOMPromiseDeferred&lt;void&gt;&gt;;
 196     void rejectPendingPlayPromises(PlayPromiseVector&amp;&amp;, Ref&lt;DOMException&gt;&amp;&amp;);
 197     void resolvePendingPlayPromises(PlayPromiseVector&amp;&amp;);
 198     void scheduleNotifyAboutPlaying();
 199     void notifyAboutPlaying(PlayPromiseVector&amp;&amp;);
 200 
 201     MediaPlayerEnums::MovieLoadType movieLoadType() const;
 202 
 203     bool inActiveDocument() const { return m_inActiveDocument; }
 204 
 205     Document* hostingDocument() const final { return &amp;document(); }
 206 
 207 // DOM API
 208 // error state
 209     WEBCORE_EXPORT MediaError* error() const;
 210 
 211     const URL&amp; currentSrc() const { return m_currentSrc; }
 212 
 213     const MediaProvider&amp; srcObject() const { return m_mediaProvider; }
 214     void setSrcObject(MediaProvider&amp;&amp;);
 215 
<span class="line-modified"> 216     WEBCORE_EXPORT void setCrossOrigin(const AtomicString&amp;);</span>
 217     WEBCORE_EXPORT String crossOrigin() const;
 218 
 219 // network state
 220     using HTMLMediaElementEnums::NetworkState;
 221     WEBCORE_EXPORT NetworkState networkState() const;
 222 
 223     WEBCORE_EXPORT String preload() const;
 224     WEBCORE_EXPORT void setPreload(const String&amp;);
 225 
 226     Ref&lt;TimeRanges&gt; buffered() const override;
 227     WEBCORE_EXPORT void load();
 228     WEBCORE_EXPORT String canPlayType(const String&amp; mimeType) const;
 229 
 230 // ready state
 231     using HTMLMediaElementEnums::ReadyState;
 232     ReadyState readyState() const override;
 233     WEBCORE_EXPORT bool seeking() const;
 234 
 235 // playback state
 236     WEBCORE_EXPORT double currentTime() const override;
</pre>
<hr />
<pre>
 252     MediaTime durationMediaTime() const;
 253     WEBCORE_EXPORT void fastSeek(const MediaTime&amp;);
 254 
 255     void updatePlaybackRate();
 256     WEBCORE_EXPORT bool webkitPreservesPitch() const;
 257     WEBCORE_EXPORT void setWebkitPreservesPitch(bool);
 258     Ref&lt;TimeRanges&gt; played() override;
 259     Ref&lt;TimeRanges&gt; seekable() const override;
 260     double seekableTimeRangesLastModifiedTime() const;
 261     double liveUpdateInterval() const;
 262     WEBCORE_EXPORT bool ended() const;
 263     bool autoplay() const;
 264     bool isAutoplaying() const { return m_autoplaying; }
 265     bool loop() const;
 266     void setLoop(bool b);
 267 
 268     void play(DOMPromiseDeferred&lt;void&gt;&amp;&amp;);
 269 
 270     WEBCORE_EXPORT void play() override;
 271     WEBCORE_EXPORT void pause() override;
<span class="line-removed"> 272     void setShouldBufferData(bool);</span>
<span class="line-removed"> 273     WEBCORE_EXPORT bool shouldBufferData() const { return m_shouldBufferData; }</span>
 274     WEBCORE_EXPORT void fastSeek(double);
 275     double minFastReverseRate() const;
 276     double maxFastForwardRate() const;
 277 
<span class="line-modified"> 278     void purgeBufferedDataIfPossible();</span>



 279 
 280 // captions
 281     WEBCORE_EXPORT bool webkitHasClosedCaptions() const;
 282     WEBCORE_EXPORT bool webkitClosedCaptionsVisible() const;
 283     WEBCORE_EXPORT void setWebkitClosedCaptionsVisible(bool);
 284 
 285     bool elementIsHidden() const { return m_elementIsHidden; }
 286 
 287 #if ENABLE(MEDIA_STATISTICS)
 288 // Statistics
 289     unsigned webkitAudioDecodedByteCount() const;
 290     unsigned webkitVideoDecodedByteCount() const;
 291 #endif
 292 
 293 #if ENABLE(MEDIA_SOURCE)
 294 //  Media Source.
 295     void detachMediaSource();
 296     void incrementDroppedFrameCount() { ++m_droppedVideoFrames; }
 297     size_t maximumSourceBufferSize(const SourceBuffer&amp;) const;
 298 #endif
</pre>
<hr />
<pre>
 387     void textTrackReadyStateChanged(TextTrack*);
 388 
 389     // TextTrackClient
 390     void textTrackKindChanged(TextTrack&amp;) override;
 391     void textTrackModeChanged(TextTrack&amp;) override;
 392     void textTrackAddCues(TextTrack&amp;, const TextTrackCueList&amp;) override;
 393     void textTrackRemoveCues(TextTrack&amp;, const TextTrackCueList&amp;) override;
 394     void textTrackAddCue(TextTrack&amp;, TextTrackCue&amp;) override;
 395     void textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp;) override;
 396 
 397     // VideoTrackClient
 398     void videoTrackSelectedChanged(VideoTrack&amp;) final;
 399 
 400     bool requiresTextTrackRepresentation() const;
 401     void setTextTrackRepresentation(TextTrackRepresentation*);
 402     void syncTextTrackBounds();
 403 #endif
 404 
 405 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 406     void webkitShowPlaybackTargetPicker();
<span class="line-modified"> 407     bool addEventListener(const AtomicString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) override;</span>
<span class="line-modified"> 408     bool removeEventListener(const AtomicString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) override;</span>
 409 
 410     void wirelessRoutesAvailableDidChange() override;
 411     void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;) override;
 412     void setShouldPlayToPlaybackTarget(bool) override;
 413 #endif
 414     bool isPlayingToWirelessPlaybackTarget() const override { return m_isPlayingToWirelessTarget; };
 415     void setIsPlayingToWirelessTarget(bool);
 416     bool webkitCurrentPlaybackTargetIsWireless() const;
 417 
 418     void setPlayingOnSecondScreen(bool value);
 419     bool isPlayingOnSecondScreen() const override { return m_playingOnSecondScreen; }
 420 
 421     bool isPlayingToExternalTarget() const { return isPlayingToWirelessPlaybackTarget() || isPlayingOnSecondScreen(); }
 422 
 423     // EventTarget function.
 424     // Both Node (via HTMLElement) and ActiveDOMObject define this method, which
 425     // causes an ambiguity error at compile time. This class&#39;s constructor
 426     // ensures that both implementations return document, so return the result
 427     // of one of them here.
 428     using HTMLElement::scriptExecutionContext;
</pre>
<hr />
<pre>
 436     void toggleStandardFullscreenState();
 437 
 438     using MediaPlayerEnums::VideoFullscreenMode;
 439     VideoFullscreenMode fullscreenMode() const { return m_videoFullscreenMode; }
 440     virtual void fullscreenModeChanged(VideoFullscreenMode);
 441 
 442     void enterFullscreen(VideoFullscreenMode);
 443     void enterFullscreen() override;
 444     WEBCORE_EXPORT void exitFullscreen();
 445     WEBCORE_EXPORT void setVideoFullscreenStandby(bool);
 446 
 447     bool hasClosedCaptions() const override;
 448     bool closedCaptionsVisible() const override;
 449     void setClosedCaptionsVisible(bool) override;
 450 
 451     MediaControls* mediaControls() const;
 452 
 453     void sourceWasRemoved(HTMLSourceElement&amp;);
 454     void sourceWasAdded(HTMLSourceElement&amp;);
 455 
<span class="line-modified"> 456     void privateBrowsingStateDidChange() override;</span>
 457 
 458     // Media cache management.
 459     WEBCORE_EXPORT static void setMediaCacheDirectory(const String&amp;);
 460     WEBCORE_EXPORT static const String&amp; mediaCacheDirectory();
 461     WEBCORE_EXPORT static HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp;);
 462     WEBCORE_EXPORT static void clearMediaCache(const String&amp;, WallTime modifiedSince = { });
 463     WEBCORE_EXPORT static void clearMediaCacheForOrigins(const String&amp;, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;);
 464     static void resetMediaEngines();
 465 
 466     bool isPlaying() const { return m_playing; }
 467 
 468     bool hasPendingActivity() const override;
 469 
 470 #if ENABLE(WEB_AUDIO)
 471     MediaElementAudioSourceNode* audioSourceNode() { return m_audioSourceNode; }
 472     void setAudioSourceNode(MediaElementAudioSourceNode*);
 473 
 474     AudioSourceProvider* audioSourceProvider();
 475 #endif
 476 
</pre>
<hr />
<pre>
 544     bool hasEverHadVideo() const { return m_hasEverHadVideo; }
 545 
 546     double playbackStartedTime() const { return m_playbackStartedTime; }
 547 
 548     bool isTemporarilyAllowingInlinePlaybackAfterFullscreen() const {return m_temporarilyAllowingInlinePlaybackAfterFullscreen; }
 549 
 550     void isVisibleInViewportChanged();
 551     void updateRateChangeRestrictions();
 552 
 553     WEBCORE_EXPORT const MediaResourceLoader* lastMediaResourceLoaderForTesting() const;
 554 
 555 #if ENABLE(MEDIA_STREAM)
 556     void mediaStreamCaptureStarted() { resumeAutoplaying(); }
 557     bool hasMediaStreamSrcObject() const { return m_mediaProvider &amp;&amp; WTF::holds_alternative&lt;RefPtr&lt;MediaStream&gt;&gt;(*m_mediaProvider); }
 558 #endif
 559 
 560     bool supportsSeeking() const override;
 561 
 562 #if !RELEASE_LOG_DISABLED
 563     const Logger&amp; logger() const final { return *m_logger.get(); }
<span class="line-modified"> 564     const void* logIdentifier() const final { return reinterpret_cast&lt;const void*&gt;(m_logIdentifier); }</span>

 565     WTFLogChannel&amp; logChannel() const final;
 566 #endif
 567 
 568     bool willLog(WTFLogLevel) const;
 569 
 570     bool isSuspended() const final;
 571 
 572     WEBCORE_EXPORT void didBecomeFullscreenElement() override;
 573     WEBCORE_EXPORT void willExitFullscreen();
 574 
 575     enum class AutoplayEventPlaybackState { None, PreventedAutoplay, StartedWithUserGesture, StartedWithoutUserGesture };
 576 
 577 protected:
 578     HTMLMediaElement(const QualifiedName&amp;, Document&amp;, bool createdByParser);
 579     virtual void finishInitialization();
 580     virtual ~HTMLMediaElement();
 581 
<span class="line-modified"> 582     void parseAttribute(const QualifiedName&amp;, const AtomicString&amp;) override;</span>
 583     void finishParsingChildren() override;
 584     bool isURLAttribute(const Attribute&amp;) const override;
 585     void willAttachRenderers() override;
 586     void didAttachRenderers() override;
 587     void willDetachRenderers() override;
 588     void didDetachRenderers() override;
 589 
 590     void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument) override;
 591 
 592     enum DisplayMode { Unknown, None, Poster, PosterWaitingForVideo, Video };
 593     DisplayMode displayMode() const { return m_displayMode; }
 594     virtual void setDisplayMode(DisplayMode mode) { m_displayMode = mode; }
 595 
 596     bool isMediaElement() const final { return true; }
 597 
 598 #if ENABLE(VIDEO_TRACK)
 599     bool ignoreTrackDisplayUpdateRequests() const { return m_ignoreTrackDisplayUpdate &gt; 0 || !m_textTracks || !m_cueTree.size(); }
 600     void beginIgnoringTrackDisplayUpdateRequests();
 601     void endIgnoringTrackDisplayUpdateRequests();
 602 #endif
 603 
 604     RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;) override;
 605 
 606 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 607     bool mediaControlsDependOnPageScaleFactor() const { return m_mediaControlsDependOnPageScaleFactor; }
 608     void setMediaControlsDependOnPageScaleFactor(bool);
 609     void updateMediaControlsAfterPresentationModeChange();
 610 #endif
 611 
<span class="line-modified"> 612     void scheduleEvent(const AtomicString&amp; eventName);</span>
 613 
 614 private:
 615     void createMediaPlayer();
 616 
 617     bool supportsFocus() const override;
 618     bool isMouseFocusable() const override;
 619     bool rendererIsNeeded(const RenderStyle&amp;) override;
 620     bool childShouldCreateRenderer(const Node&amp;) const override;
 621     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
 622     void didFinishInsertingNode() override;
 623     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
 624     void didRecalcStyle(Style::Change) override;

 625 
 626     void willBecomeFullscreenElement() override;
 627     void willStopBeingFullscreenElement() override;
 628 
 629     // ActiveDOMObject API.
 630     const char* activeDOMObjectName() const override;
 631     bool canSuspendForDocumentSuspension() const override;
 632     void suspend(ReasonForSuspension) override;
 633     void resume() override;
 634     void stop() override;
 635     void stopWithoutDestroyingMediaPlayer();
 636     void contextDestroyed() override;
 637 
 638     void mediaVolumeDidChange() override;
 639 
 640     void visibilityStateChanged() override;
 641 
 642     virtual void updateDisplayState() { }
 643 
 644     void setReadyState(MediaPlayerEnums::ReadyState);
</pre>
<hr />
<pre>
 832 
 833     // Pauses playback without changing any states or generating events
 834     void setPausedInternal(bool);
 835 
 836     void setPlaybackRateInternal(double);
 837 
 838     void mediaCanStart(Document&amp;) final;
 839 
 840     void invalidateCachedTime() const;
 841     void refreshCachedTime() const;
 842 
 843     bool hasMediaControls() const;
 844     bool createMediaControls();
 845     void configureMediaControls();
 846 
 847     void prepareMediaFragmentURI();
 848     void applyMediaFragmentURI();
 849 
 850     void changeNetworkStateFromLoadingToIdle();
 851 
<span class="line-modified"> 852     void removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::BehaviorRestrictions mask = MediaElementSession::AllRestrictions);</span>
 853 
 854     void updateMediaController();
 855     bool isBlocked() const;
 856     bool isBlockedOnMediaController() const;
 857     bool hasCurrentSrc() const override { return !m_currentSrc.isEmpty(); }
 858     bool isLiveStream() const override { return movieLoadType() == MediaPlayerEnums::LiveStream; }
 859 
 860     void updateSleepDisabling();
 861     enum class SleepType {
 862         None,
 863         Display,
 864         System,
 865     };
 866     SleepType shouldDisableSleep() const;
 867 
 868 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 869     void didAddUserAgentShadowRoot(ShadowRoot&amp;) override;
 870     DOMWrapperWorld&amp; ensureIsolatedWorld();
 871     bool ensureMediaControlsInjectedScript();
 872 #endif
 873 
 874     PlatformMediaSession::MediaType mediaType() const override;
 875     PlatformMediaSession::MediaType presentationType() const override;
 876     PlatformMediaSession::DisplayType displayType() const override;
 877     PlatformMediaSession::CharacteristicsFlags characteristics() const final;
 878 
 879     void suspendPlayback() override;
 880     void resumeAutoplaying() override;
 881     void mayResumePlayback(bool shouldResume) override;
 882     uint64_t mediaSessionUniqueIdentifier() const final;
 883     String mediaSessionTitle() const override;
 884     double mediaSessionDuration() const override { return duration(); }
 885     double mediaSessionCurrentTime() const override { return currentTime(); }
 886     bool canReceiveRemoteControlCommands() const override { return true; }
 887     void didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType, const PlatformMediaSession::RemoteCommandArgument*) override;
 888     bool shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType) const override;
 889     bool shouldOverrideBackgroundLoadingRestriction() const override;
 890     bool canProduceAudio() const final;
 891     bool processingUserGestureForMedia() const final;


 892 
 893     void pageMutedStateDidChange() override;
 894 
 895 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 896     void hardwareMutedStateDidChange(AudioSession*) final;
 897 #endif
 898 
 899     bool effectiveMuted() const;

 900 
 901     void registerWithDocument(Document&amp;);
 902     void unregisterWithDocument(Document&amp;);
 903 
 904     void updateCaptionContainer();
 905     void ensureMediaControlsShadowRoot();
 906 
 907     using JSSetupFunction = WTF::Function&lt;bool(JSDOMGlobalObject&amp;, JSC::ExecState&amp;, ScriptController&amp;, DOMWrapperWorld&amp;)&gt;;
 908     bool setupAndCallJS(const JSSetupFunction&amp;);
 909 
 910 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 911     void prepareForDocumentSuspension() final;
 912     void resumeFromDocumentSuspension() final;
 913 
 914     void scheduleUpdateMediaState();
 915     void updateMediaState();
 916     bool hasPlaybackTargetAvailabilityListeners() const { return m_hasPlaybackTargetAvailabilityListeners; }
 917 #endif
 918 
 919     bool isVideoTooSmallForInlinePlayback();
</pre>
<hr />
<pre>
 923     void updatePlaybackControlsManager();
 924     void schedulePlaybackControlsManagerUpdate();
 925     void playbackControlsManagerBehaviorRestrictionsTimerFired();
 926 
 927     void updateRenderer();
 928 
 929     void updatePageScaleFactorJSProperty();
 930     void updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
 931     void setControllerJSProperty(const char*, JSC::JSValue);
 932 
 933     void addBehaviorRestrictionsOnEndIfNecessary();
 934     void handleSeekToPlaybackPosition(double);
 935     void seekToPlaybackPositionEndedTimerFired();
 936 
 937     void applicationWillResignActive() final;
 938     void applicationDidBecomeActive() final;
 939 
 940     void setInActiveDocument(bool);
 941 
 942 #if !RELEASE_LOG_DISABLED
<span class="line-removed"> 943     const char* logClassName() const final { return &quot;HTMLMediaElement&quot;; }</span>
<span class="line-removed"> 944 </span>
 945     const void* mediaPlayerLogIdentifier() final { return logIdentifier(); }
 946     const Logger&amp; mediaPlayerLogger() final { return logger(); }
 947 #endif
 948 
 949     Timer m_progressEventTimer;
 950     Timer m_playbackProgressTimer;
 951     Timer m_scanTimer;
 952     Timer m_playbackControlsManagerBehaviorRestrictionsTimer;
 953     Timer m_seekToPlaybackPositionEndedTimer;
 954     DeferrableTask&lt;Timer&gt; m_configureTextTracksTask;
 955     DeferrableTask&lt;Timer&gt; m_checkPlaybackTargetCompatablityTask;
 956     DeferrableTask&lt;Timer&gt; m_updateMediaStateTask;
 957     DeferrableTask&lt;Timer&gt; m_mediaEngineUpdatedTask;
 958     DeferrableTask&lt;Timer&gt; m_updatePlayStateTask;
 959     DeferrableTask&lt;Timer&gt; m_resumeTaskQueue;
 960     DeferrableTask&lt;Timer&gt; m_seekTaskQueue;
 961     DeferrableTask&lt;Timer&gt; m_playbackControlsManagerBehaviorRestrictionsQueue;
 962     GenericTaskQueue&lt;Timer&gt; m_promiseTaskQueue;
 963     GenericTaskQueue&lt;Timer&gt; m_pauseAfterDetachedTaskQueue;
 964     GenericTaskQueue&lt;Timer&gt; m_resourceSelectionTaskQueue;
 965     GenericTaskQueue&lt;Timer&gt; m_visibilityChangeTaskQueue;
 966     GenericTaskQueue&lt;Timer&gt; m_fullscreenTaskQueue;
 967     GenericTaskQueue&lt;Timer&gt; m_playbackTargetIsWirelessQueue;
 968     RefPtr&lt;TimeRanges&gt; m_playedTimeRanges;
 969     GenericEventQueue m_asyncEventQueue;



 970 
 971     PlayPromiseVector m_pendingPlayPromises;
 972 
 973     double m_requestedPlaybackRate { 1 };
 974     double m_reportedPlaybackRate { 1 };
 975     double m_defaultPlaybackRate { 1 };
 976     bool m_webkitPreservesPitch { true };
 977     NetworkState m_networkState { NETWORK_EMPTY };
 978     ReadyState m_readyState { HAVE_NOTHING };
 979     ReadyState m_readyStateMaximum { HAVE_NOTHING };
 980     URL m_currentSrc;
 981 
 982     RefPtr&lt;MediaError&gt; m_error;
 983 
 984     struct PendingSeek {

 985         PendingSeek(const MediaTime&amp; now, const MediaTime&amp; targetTime, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance)
 986             : now(now)
 987             , targetTime(targetTime)
 988             , negativeTolerance(negativeTolerance)
 989             , positiveTolerance(positiveTolerance)
 990         {
 991         }
 992         MediaTime now;
 993         MediaTime targetTime;
 994         MediaTime negativeTolerance;
 995         MediaTime positiveTolerance;
 996     };
 997     std::unique_ptr&lt;PendingSeek&gt; m_pendingSeek;
 998     SeekType m_pendingSeekType { NoSeek };
 999 
1000     double m_volume { 1 };
1001     bool m_volumeInitialized { false };
1002     MediaTime m_lastSeekTime;
1003 
1004     MonotonicTime m_previousProgressTime { MonotonicTime::infinity() };
</pre>
<hr />
<pre>
1051     unsigned m_droppedVideoFrames { 0 };
1052 #endif
1053 
1054     mutable MediaTime m_cachedTime;
1055     mutable MonotonicTime m_clockTimeAtLastCachedTimeUpdate;
1056     mutable MonotonicTime m_minimumClockTimeToUpdateCachedTime;
1057 
1058     MediaTime m_fragmentStartTime;
1059     MediaTime m_fragmentEndTime;
1060 
1061     using PendingActionFlags = unsigned;
1062     PendingActionFlags m_pendingActionFlags { 0 };
1063 
1064     enum ActionAfterScanType { Nothing, Play, Pause };
1065     ActionAfterScanType m_actionAfterScan { Nothing };
1066 
1067     enum ScanType { Seek, Scan };
1068     ScanType m_scanType { Scan };
1069     ScanDirection m_scanDirection { Forward };
1070 


1071     bool m_firstTimePlaying : 1;
1072     bool m_playing : 1;
1073     bool m_isWaitingUntilMediaCanStart : 1;
1074     bool m_shouldDelayLoadEvent : 1;
1075     bool m_haveFiredLoadedData : 1;
1076     bool m_inActiveDocument : 1;
1077     bool m_autoplaying : 1;
1078     bool m_muted : 1;
1079     bool m_explicitlyMuted : 1;
1080     bool m_initiallyMuted : 1;
1081     bool m_paused : 1;
1082     bool m_seeking : 1;
1083     bool m_seekRequested : 1;
1084 
1085     // data has not been loaded since sending a &quot;stalled&quot; event
1086     bool m_sentStalledEvent : 1;
1087 
1088     // time has not changed since sending an &quot;ended&quot; event
1089     bool m_sentEndEvent : 1;
1090 
1091     bool m_pausedInternal : 1;
1092 
1093     bool m_closedCaptionsVisible : 1;
1094     bool m_webkitLegacyClosedCaptionOverride : 1;
1095     bool m_completelyLoaded : 1;
1096     bool m_havePreparedToPlay : 1;
1097     bool m_parsingInProgress : 1;
<span class="line-removed">1098     bool m_shouldBufferData : 1;</span>
1099     bool m_elementIsHidden : 1;
1100     bool m_elementWasRemovedFromDOM : 1;
1101     bool m_creatingControls : 1;
1102     bool m_receivedLayoutSizeChanged : 1;
1103     bool m_hasEverNotifiedAboutPlaying : 1;
1104 
1105     bool m_hasEverHadAudio : 1;
1106     bool m_hasEverHadVideo : 1;
1107 
1108 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1109     bool m_mediaControlsDependOnPageScaleFactor : 1;
1110     bool m_haveSetUpCaptionContainer : 1;
1111 #endif
1112 
1113     bool m_isScrubbingRemotely : 1;
1114     bool m_waitingToEnterFullscreen : 1;
1115 
1116 #if ENABLE(VIDEO_TRACK)
1117     bool m_tracksAreReady : 1;
1118     bool m_haveVisibleTextTrack : 1;
</pre>
<hr />
<pre>
1156     friend class TrackDisplayUpdateScope;
1157 
1158     RefPtr&lt;Blob&gt; m_blob;
1159     MediaProvider m_mediaProvider;
1160 
1161 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
1162     RefPtr&lt;WebKitMediaKeys&gt; m_webKitMediaKeys;
1163 #endif
1164 #if ENABLE(ENCRYPTED_MEDIA)
1165     RefPtr&lt;MediaKeys&gt; m_mediaKeys;
1166     bool m_attachingMediaKeys { false };
1167     bool m_playbackBlockedWaitingForKey { false };
1168     GenericTaskQueue&lt;Timer&gt; m_encryptedMediaQueue;
1169 #endif
1170 
1171     std::unique_ptr&lt;MediaElementSession&gt; m_mediaSession;
1172     size_t m_reportedExtraMemoryCost { 0 };
1173 
1174 #if !RELEASE_LOG_DISABLED
1175     RefPtr&lt;Logger&gt; m_logger;
<span class="line-modified">1176     uint64_t m_logIdentifier;</span>
1177 #endif
1178 
1179 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1180     friend class MediaControlsHost;
1181     RefPtr&lt;MediaControlsHost&gt; m_mediaControlsHost;
1182     RefPtr&lt;DOMWrapperWorld&gt; m_isolatedWorld;
1183 #endif
1184 
1185 #if ENABLE(MEDIA_STREAM)
1186     RefPtr&lt;MediaStream&gt; m_mediaStreamSrcObject;
1187     bool m_settingMediaStreamSrcObject { false };
1188 #endif
1189 
1190 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1191     MediaProducer::MediaStateFlags m_mediaState { MediaProducer::IsNotPlaying };
1192     bool m_hasPlaybackTargetAvailabilityListeners { false };
1193     bool m_failedToPlayToWirelessTarget { false };
1194 #endif
1195 
1196     bool m_isPlayingToWirelessTarget { false };
1197     bool m_playingOnSecondScreen { false };

1198 };
1199 
1200 String convertEnumerationToString(HTMLMediaElement::AutoplayEventPlaybackState);
1201 
1202 } // namespace WebCore
1203 
1204 namespace WTF {
1205 
1206 template&lt;&gt; struct LogArgument&lt;WebCore::HTMLMediaElement::AutoplayEventPlaybackState&gt; {
1207     static String toString(WebCore::HTMLMediaElement::AutoplayEventPlaybackState reason) { return convertEnumerationToString(reason); }
1208 };
1209 
1210 #if ENABLE(VIDEO_TRACK) &amp;&amp; !defined(NDEBUG)
1211 
1212 // Template specialization required by PodIntervalTree in debug mode.
1213 template&lt;&gt; struct ValueToString&lt;WebCore::TextTrackCue*&gt; {
1214     static String string(const WebCore::TextTrackCue* cue) { return cue-&gt;debugString(); }
1215 };
1216 
1217 #endif
</pre>
</td>
<td>
<hr />
<pre>
 109 
 110 #if ENABLE(VIDEO_TRACK)
 111 using CueIntervalTree = PODIntervalTree&lt;MediaTime, TextTrackCue*&gt;;
 112 using CueInterval = CueIntervalTree::IntervalType;
 113 using CueList = Vector&lt;CueInterval&gt;;
 114 #endif
 115 
 116 using MediaProvider = Optional&lt;Variant&lt;
 117 #if ENABLE(MEDIA_STREAM)
 118     RefPtr&lt;MediaStream&gt;,
 119 #endif
 120 #if ENABLE(MEDIA_SOURCE)
 121     RefPtr&lt;MediaSource&gt;,
 122 #endif
 123     RefPtr&lt;Blob&gt;&gt;&gt;;
 124 
 125 class HTMLMediaElement
 126     : public HTMLElement
 127     , public ActiveDOMObject
 128     , public MediaControllerInterface

 129     , public PlatformMediaSessionClient
 130     , private MediaCanStartListener
 131     , private MediaPlayerClient
 132     , private MediaProducer
 133     , private VisibilityChangeClient
 134     , private ApplicationStateChangeListener
 135 #if ENABLE(VIDEO_TRACK)
 136     , private AudioTrackClient
 137     , private TextTrackClient
 138     , private VideoTrackClient
 139 #endif
 140 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 141     , private AudioSession::MutedStateObserver
 142 #endif
 143 #if ENABLE(ENCRYPTED_MEDIA)
 144     , private CDMClient
 145 #endif
 146 #if !RELEASE_LOG_DISABLED
 147     , private LoggerHelper
 148 #endif
 149 {
 150     WTF_MAKE_ISO_ALLOCATED(HTMLMediaElement);
 151 public:
<span class="line-added"> 152     using WeakValueType = HTMLElement::WeakValueType;</span>
<span class="line-added"> 153     using HTMLElement::weakPtrFactory;</span>
<span class="line-added"> 154 </span>
 155     RefPtr&lt;MediaPlayer&gt; player() const { return m_player; }
 156 
 157     virtual bool isVideo() const { return false; }
 158     bool hasVideo() const override { return false; }
 159     bool hasAudio() const override;
 160 
 161     static HashSet&lt;HTMLMediaElement*&gt;&amp; allMediaElements();
 162 
 163     WEBCORE_EXPORT static RefPtr&lt;HTMLMediaElement&gt; bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose);
 164 
 165     static bool isRunningDestructor();
 166 
 167     WEBCORE_EXPORT void rewind(double timeDelta);
 168     WEBCORE_EXPORT void returnToRealtime() override;
 169 
 170     // Eventually overloaded in HTMLVideoElement
 171     bool supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenMode) const override { return false; };
 172 
 173     bool supportsScanning() const override;
 174 
 175     bool canSaveMediaData() const;
 176 
<span class="line-modified"> 177     bool doesHaveAttribute(const AtomString&amp;, AtomString* value = nullptr) const override;</span>
 178 
 179     PlatformLayer* platformLayer() const;
 180     bool isVideoLayerInline();
 181     void setPreparedToReturnVideoLayerToInline(bool);
 182     void waitForPreparedForInlineThen(WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
 183 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 184     void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
 185 #ifdef __OBJC__
 186     PlatformLayer* videoFullscreenLayer() const { return m_videoFullscreenLayer.get(); }
 187 #endif
 188     void setVideoFullscreenFrame(FloatRect);
 189     void setVideoFullscreenGravity(MediaPlayerEnums::VideoGravity);
 190     MediaPlayerEnums::VideoGravity videoFullscreenGravity() const { return m_videoFullscreenGravity; }
 191 #endif
 192 
 193     void scheduleCheckPlaybackTargetCompatability();
 194     void checkPlaybackTargetCompatablity();
 195     void scheduleResolvePendingPlayPromises();
 196     void scheduleRejectPendingPlayPromises(Ref&lt;DOMException&gt;&amp;&amp;);
 197     using PlayPromiseVector = Vector&lt;DOMPromiseDeferred&lt;void&gt;&gt;;
 198     void rejectPendingPlayPromises(PlayPromiseVector&amp;&amp;, Ref&lt;DOMException&gt;&amp;&amp;);
 199     void resolvePendingPlayPromises(PlayPromiseVector&amp;&amp;);
 200     void scheduleNotifyAboutPlaying();
 201     void notifyAboutPlaying(PlayPromiseVector&amp;&amp;);
 202 
 203     MediaPlayerEnums::MovieLoadType movieLoadType() const;
 204 
 205     bool inActiveDocument() const { return m_inActiveDocument; }
 206 
 207     Document* hostingDocument() const final { return &amp;document(); }
 208 
 209 // DOM API
 210 // error state
 211     WEBCORE_EXPORT MediaError* error() const;
 212 
 213     const URL&amp; currentSrc() const { return m_currentSrc; }
 214 
 215     const MediaProvider&amp; srcObject() const { return m_mediaProvider; }
 216     void setSrcObject(MediaProvider&amp;&amp;);
 217 
<span class="line-modified"> 218     WEBCORE_EXPORT void setCrossOrigin(const AtomString&amp;);</span>
 219     WEBCORE_EXPORT String crossOrigin() const;
 220 
 221 // network state
 222     using HTMLMediaElementEnums::NetworkState;
 223     WEBCORE_EXPORT NetworkState networkState() const;
 224 
 225     WEBCORE_EXPORT String preload() const;
 226     WEBCORE_EXPORT void setPreload(const String&amp;);
 227 
 228     Ref&lt;TimeRanges&gt; buffered() const override;
 229     WEBCORE_EXPORT void load();
 230     WEBCORE_EXPORT String canPlayType(const String&amp; mimeType) const;
 231 
 232 // ready state
 233     using HTMLMediaElementEnums::ReadyState;
 234     ReadyState readyState() const override;
 235     WEBCORE_EXPORT bool seeking() const;
 236 
 237 // playback state
 238     WEBCORE_EXPORT double currentTime() const override;
</pre>
<hr />
<pre>
 254     MediaTime durationMediaTime() const;
 255     WEBCORE_EXPORT void fastSeek(const MediaTime&amp;);
 256 
 257     void updatePlaybackRate();
 258     WEBCORE_EXPORT bool webkitPreservesPitch() const;
 259     WEBCORE_EXPORT void setWebkitPreservesPitch(bool);
 260     Ref&lt;TimeRanges&gt; played() override;
 261     Ref&lt;TimeRanges&gt; seekable() const override;
 262     double seekableTimeRangesLastModifiedTime() const;
 263     double liveUpdateInterval() const;
 264     WEBCORE_EXPORT bool ended() const;
 265     bool autoplay() const;
 266     bool isAutoplaying() const { return m_autoplaying; }
 267     bool loop() const;
 268     void setLoop(bool b);
 269 
 270     void play(DOMPromiseDeferred&lt;void&gt;&amp;&amp;);
 271 
 272     WEBCORE_EXPORT void play() override;
 273     WEBCORE_EXPORT void pause() override;


 274     WEBCORE_EXPORT void fastSeek(double);
 275     double minFastReverseRate() const;
 276     double maxFastForwardRate() const;
 277 
<span class="line-modified"> 278     using HTMLMediaElementEnums::BufferingPolicy;</span>
<span class="line-added"> 279     void setBufferingPolicy(BufferingPolicy);</span>
<span class="line-added"> 280     WEBCORE_EXPORT BufferingPolicy bufferingPolicy() const;</span>
<span class="line-added"> 281     WEBCORE_EXPORT void purgeBufferedDataIfPossible();</span>
 282 
 283 // captions
 284     WEBCORE_EXPORT bool webkitHasClosedCaptions() const;
 285     WEBCORE_EXPORT bool webkitClosedCaptionsVisible() const;
 286     WEBCORE_EXPORT void setWebkitClosedCaptionsVisible(bool);
 287 
 288     bool elementIsHidden() const { return m_elementIsHidden; }
 289 
 290 #if ENABLE(MEDIA_STATISTICS)
 291 // Statistics
 292     unsigned webkitAudioDecodedByteCount() const;
 293     unsigned webkitVideoDecodedByteCount() const;
 294 #endif
 295 
 296 #if ENABLE(MEDIA_SOURCE)
 297 //  Media Source.
 298     void detachMediaSource();
 299     void incrementDroppedFrameCount() { ++m_droppedVideoFrames; }
 300     size_t maximumSourceBufferSize(const SourceBuffer&amp;) const;
 301 #endif
</pre>
<hr />
<pre>
 390     void textTrackReadyStateChanged(TextTrack*);
 391 
 392     // TextTrackClient
 393     void textTrackKindChanged(TextTrack&amp;) override;
 394     void textTrackModeChanged(TextTrack&amp;) override;
 395     void textTrackAddCues(TextTrack&amp;, const TextTrackCueList&amp;) override;
 396     void textTrackRemoveCues(TextTrack&amp;, const TextTrackCueList&amp;) override;
 397     void textTrackAddCue(TextTrack&amp;, TextTrackCue&amp;) override;
 398     void textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp;) override;
 399 
 400     // VideoTrackClient
 401     void videoTrackSelectedChanged(VideoTrack&amp;) final;
 402 
 403     bool requiresTextTrackRepresentation() const;
 404     void setTextTrackRepresentation(TextTrackRepresentation*);
 405     void syncTextTrackBounds();
 406 #endif
 407 
 408 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 409     void webkitShowPlaybackTargetPicker();
<span class="line-modified"> 410     bool addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) override;</span>
<span class="line-modified"> 411     bool removeEventListener(const AtomString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) override;</span>
 412 
 413     void wirelessRoutesAvailableDidChange() override;
 414     void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;) override;
 415     void setShouldPlayToPlaybackTarget(bool) override;
 416 #endif
 417     bool isPlayingToWirelessPlaybackTarget() const override { return m_isPlayingToWirelessTarget; };
 418     void setIsPlayingToWirelessTarget(bool);
 419     bool webkitCurrentPlaybackTargetIsWireless() const;
 420 
 421     void setPlayingOnSecondScreen(bool value);
 422     bool isPlayingOnSecondScreen() const override { return m_playingOnSecondScreen; }
 423 
 424     bool isPlayingToExternalTarget() const { return isPlayingToWirelessPlaybackTarget() || isPlayingOnSecondScreen(); }
 425 
 426     // EventTarget function.
 427     // Both Node (via HTMLElement) and ActiveDOMObject define this method, which
 428     // causes an ambiguity error at compile time. This class&#39;s constructor
 429     // ensures that both implementations return document, so return the result
 430     // of one of them here.
 431     using HTMLElement::scriptExecutionContext;
</pre>
<hr />
<pre>
 439     void toggleStandardFullscreenState();
 440 
 441     using MediaPlayerEnums::VideoFullscreenMode;
 442     VideoFullscreenMode fullscreenMode() const { return m_videoFullscreenMode; }
 443     virtual void fullscreenModeChanged(VideoFullscreenMode);
 444 
 445     void enterFullscreen(VideoFullscreenMode);
 446     void enterFullscreen() override;
 447     WEBCORE_EXPORT void exitFullscreen();
 448     WEBCORE_EXPORT void setVideoFullscreenStandby(bool);
 449 
 450     bool hasClosedCaptions() const override;
 451     bool closedCaptionsVisible() const override;
 452     void setClosedCaptionsVisible(bool) override;
 453 
 454     MediaControls* mediaControls() const;
 455 
 456     void sourceWasRemoved(HTMLSourceElement&amp;);
 457     void sourceWasAdded(HTMLSourceElement&amp;);
 458 
<span class="line-modified"> 459     void privateBrowsingStateDidChange(PAL::SessionID) override;</span>
 460 
 461     // Media cache management.
 462     WEBCORE_EXPORT static void setMediaCacheDirectory(const String&amp;);
 463     WEBCORE_EXPORT static const String&amp; mediaCacheDirectory();
 464     WEBCORE_EXPORT static HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp;);
 465     WEBCORE_EXPORT static void clearMediaCache(const String&amp;, WallTime modifiedSince = { });
 466     WEBCORE_EXPORT static void clearMediaCacheForOrigins(const String&amp;, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;);
 467     static void resetMediaEngines();
 468 
 469     bool isPlaying() const { return m_playing; }
 470 
 471     bool hasPendingActivity() const override;
 472 
 473 #if ENABLE(WEB_AUDIO)
 474     MediaElementAudioSourceNode* audioSourceNode() { return m_audioSourceNode; }
 475     void setAudioSourceNode(MediaElementAudioSourceNode*);
 476 
 477     AudioSourceProvider* audioSourceProvider();
 478 #endif
 479 
</pre>
<hr />
<pre>
 547     bool hasEverHadVideo() const { return m_hasEverHadVideo; }
 548 
 549     double playbackStartedTime() const { return m_playbackStartedTime; }
 550 
 551     bool isTemporarilyAllowingInlinePlaybackAfterFullscreen() const {return m_temporarilyAllowingInlinePlaybackAfterFullscreen; }
 552 
 553     void isVisibleInViewportChanged();
 554     void updateRateChangeRestrictions();
 555 
 556     WEBCORE_EXPORT const MediaResourceLoader* lastMediaResourceLoaderForTesting() const;
 557 
 558 #if ENABLE(MEDIA_STREAM)
 559     void mediaStreamCaptureStarted() { resumeAutoplaying(); }
 560     bool hasMediaStreamSrcObject() const { return m_mediaProvider &amp;&amp; WTF::holds_alternative&lt;RefPtr&lt;MediaStream&gt;&gt;(*m_mediaProvider); }
 561 #endif
 562 
 563     bool supportsSeeking() const override;
 564 
 565 #if !RELEASE_LOG_DISABLED
 566     const Logger&amp; logger() const final { return *m_logger.get(); }
<span class="line-modified"> 567     const void* logIdentifier() const final { return m_logIdentifier; }</span>
<span class="line-added"> 568     const char* logClassName() const final { return &quot;HTMLMediaElement&quot;; }</span>
 569     WTFLogChannel&amp; logChannel() const final;
 570 #endif
 571 
 572     bool willLog(WTFLogLevel) const;
 573 
 574     bool isSuspended() const final;
 575 
 576     WEBCORE_EXPORT void didBecomeFullscreenElement() override;
 577     WEBCORE_EXPORT void willExitFullscreen();
 578 
 579     enum class AutoplayEventPlaybackState { None, PreventedAutoplay, StartedWithUserGesture, StartedWithoutUserGesture };
 580 
 581 protected:
 582     HTMLMediaElement(const QualifiedName&amp;, Document&amp;, bool createdByParser);
 583     virtual void finishInitialization();
 584     virtual ~HTMLMediaElement();
 585 
<span class="line-modified"> 586     void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) override;</span>
 587     void finishParsingChildren() override;
 588     bool isURLAttribute(const Attribute&amp;) const override;
 589     void willAttachRenderers() override;
 590     void didAttachRenderers() override;
 591     void willDetachRenderers() override;
 592     void didDetachRenderers() override;
 593 
 594     void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument) override;
 595 
 596     enum DisplayMode { Unknown, None, Poster, PosterWaitingForVideo, Video };
 597     DisplayMode displayMode() const { return m_displayMode; }
 598     virtual void setDisplayMode(DisplayMode mode) { m_displayMode = mode; }
 599 
 600     bool isMediaElement() const final { return true; }
 601 
 602 #if ENABLE(VIDEO_TRACK)
 603     bool ignoreTrackDisplayUpdateRequests() const { return m_ignoreTrackDisplayUpdate &gt; 0 || !m_textTracks || !m_cueTree.size(); }
 604     void beginIgnoringTrackDisplayUpdateRequests();
 605     void endIgnoringTrackDisplayUpdateRequests();
 606 #endif
 607 
 608     RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;) override;
 609 
 610 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 611     bool mediaControlsDependOnPageScaleFactor() const { return m_mediaControlsDependOnPageScaleFactor; }
 612     void setMediaControlsDependOnPageScaleFactor(bool);
 613     void updateMediaControlsAfterPresentationModeChange();
 614 #endif
 615 
<span class="line-modified"> 616     void scheduleEvent(const AtomString&amp; eventName);</span>
 617 
 618 private:
 619     void createMediaPlayer();
 620 
 621     bool supportsFocus() const override;
 622     bool isMouseFocusable() const override;
 623     bool rendererIsNeeded(const RenderStyle&amp;) override;
 624     bool childShouldCreateRenderer(const Node&amp;) const override;
 625     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
 626     void didFinishInsertingNode() override;
 627     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
 628     void didRecalcStyle(Style::Change) override;
<span class="line-added"> 629     bool isInteractiveContent() const override;</span>
 630 
 631     void willBecomeFullscreenElement() override;
 632     void willStopBeingFullscreenElement() override;
 633 
 634     // ActiveDOMObject API.
 635     const char* activeDOMObjectName() const override;
 636     bool canSuspendForDocumentSuspension() const override;
 637     void suspend(ReasonForSuspension) override;
 638     void resume() override;
 639     void stop() override;
 640     void stopWithoutDestroyingMediaPlayer();
 641     void contextDestroyed() override;
 642 
 643     void mediaVolumeDidChange() override;
 644 
 645     void visibilityStateChanged() override;
 646 
 647     virtual void updateDisplayState() { }
 648 
 649     void setReadyState(MediaPlayerEnums::ReadyState);
</pre>
<hr />
<pre>
 837 
 838     // Pauses playback without changing any states or generating events
 839     void setPausedInternal(bool);
 840 
 841     void setPlaybackRateInternal(double);
 842 
 843     void mediaCanStart(Document&amp;) final;
 844 
 845     void invalidateCachedTime() const;
 846     void refreshCachedTime() const;
 847 
 848     bool hasMediaControls() const;
 849     bool createMediaControls();
 850     void configureMediaControls();
 851 
 852     void prepareMediaFragmentURI();
 853     void applyMediaFragmentURI();
 854 
 855     void changeNetworkStateFromLoadingToIdle();
 856 
<span class="line-modified"> 857     void removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::BehaviorRestrictions mask = MediaElementSession::AllRestrictions);</span>
 858 
 859     void updateMediaController();
 860     bool isBlocked() const;
 861     bool isBlockedOnMediaController() const;
 862     bool hasCurrentSrc() const override { return !m_currentSrc.isEmpty(); }
 863     bool isLiveStream() const override { return movieLoadType() == MediaPlayerEnums::LiveStream; }
 864 
 865     void updateSleepDisabling();
 866     enum class SleepType {
 867         None,
 868         Display,
 869         System,
 870     };
 871     SleepType shouldDisableSleep() const;
 872 
 873 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 874     void didAddUserAgentShadowRoot(ShadowRoot&amp;) override;
 875     DOMWrapperWorld&amp; ensureIsolatedWorld();
 876     bool ensureMediaControlsInjectedScript();
 877 #endif
 878 
 879     PlatformMediaSession::MediaType mediaType() const override;
 880     PlatformMediaSession::MediaType presentationType() const override;
 881     PlatformMediaSession::DisplayType displayType() const override;
 882     PlatformMediaSession::CharacteristicsFlags characteristics() const final;
 883 
 884     void suspendPlayback() override;
 885     void resumeAutoplaying() override;
 886     void mayResumePlayback(bool shouldResume) override;
 887     uint64_t mediaSessionUniqueIdentifier() const final;
 888     String mediaSessionTitle() const override;
 889     double mediaSessionDuration() const override { return duration(); }
 890     double mediaSessionCurrentTime() const override { return currentTime(); }
 891     bool canReceiveRemoteControlCommands() const override { return true; }
 892     void didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType, const PlatformMediaSession::RemoteCommandArgument*) override;
 893     bool shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType) const override;
 894     bool shouldOverrideBackgroundLoadingRestriction() const override;
 895     bool canProduceAudio() const final;
 896     bool processingUserGestureForMedia() const final;
<span class="line-added"> 897     bool hasMediaStreamSource() const final;</span>
<span class="line-added"> 898     void processIsSuspendedChanged() final;</span>
 899 
 900     void pageMutedStateDidChange() override;
 901 
 902 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 903     void hardwareMutedStateDidChange(AudioSession*) final;
 904 #endif
 905 
 906     bool effectiveMuted() const;
<span class="line-added"> 907     double effectiveVolume() const;</span>
 908 
 909     void registerWithDocument(Document&amp;);
 910     void unregisterWithDocument(Document&amp;);
 911 
 912     void updateCaptionContainer();
 913     void ensureMediaControlsShadowRoot();
 914 
 915     using JSSetupFunction = WTF::Function&lt;bool(JSDOMGlobalObject&amp;, JSC::ExecState&amp;, ScriptController&amp;, DOMWrapperWorld&amp;)&gt;;
 916     bool setupAndCallJS(const JSSetupFunction&amp;);
 917 
 918 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 919     void prepareForDocumentSuspension() final;
 920     void resumeFromDocumentSuspension() final;
 921 
 922     void scheduleUpdateMediaState();
 923     void updateMediaState();
 924     bool hasPlaybackTargetAvailabilityListeners() const { return m_hasPlaybackTargetAvailabilityListeners; }
 925 #endif
 926 
 927     bool isVideoTooSmallForInlinePlayback();
</pre>
<hr />
<pre>
 931     void updatePlaybackControlsManager();
 932     void schedulePlaybackControlsManagerUpdate();
 933     void playbackControlsManagerBehaviorRestrictionsTimerFired();
 934 
 935     void updateRenderer();
 936 
 937     void updatePageScaleFactorJSProperty();
 938     void updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
 939     void setControllerJSProperty(const char*, JSC::JSValue);
 940 
 941     void addBehaviorRestrictionsOnEndIfNecessary();
 942     void handleSeekToPlaybackPosition(double);
 943     void seekToPlaybackPositionEndedTimerFired();
 944 
 945     void applicationWillResignActive() final;
 946     void applicationDidBecomeActive() final;
 947 
 948     void setInActiveDocument(bool);
 949 
 950 #if !RELEASE_LOG_DISABLED


 951     const void* mediaPlayerLogIdentifier() final { return logIdentifier(); }
 952     const Logger&amp; mediaPlayerLogger() final { return logger(); }
 953 #endif
 954 
 955     Timer m_progressEventTimer;
 956     Timer m_playbackProgressTimer;
 957     Timer m_scanTimer;
 958     Timer m_playbackControlsManagerBehaviorRestrictionsTimer;
 959     Timer m_seekToPlaybackPositionEndedTimer;
 960     DeferrableTask&lt;Timer&gt; m_configureTextTracksTask;
 961     DeferrableTask&lt;Timer&gt; m_checkPlaybackTargetCompatablityTask;
 962     DeferrableTask&lt;Timer&gt; m_updateMediaStateTask;
 963     DeferrableTask&lt;Timer&gt; m_mediaEngineUpdatedTask;
 964     DeferrableTask&lt;Timer&gt; m_updatePlayStateTask;
 965     DeferrableTask&lt;Timer&gt; m_resumeTaskQueue;
 966     DeferrableTask&lt;Timer&gt; m_seekTaskQueue;
 967     DeferrableTask&lt;Timer&gt; m_playbackControlsManagerBehaviorRestrictionsQueue;
 968     GenericTaskQueue&lt;Timer&gt; m_promiseTaskQueue;
 969     GenericTaskQueue&lt;Timer&gt; m_pauseAfterDetachedTaskQueue;
 970     GenericTaskQueue&lt;Timer&gt; m_resourceSelectionTaskQueue;
 971     GenericTaskQueue&lt;Timer&gt; m_visibilityChangeTaskQueue;
 972     GenericTaskQueue&lt;Timer&gt; m_fullscreenTaskQueue;
 973     GenericTaskQueue&lt;Timer&gt; m_playbackTargetIsWirelessQueue;
 974     RefPtr&lt;TimeRanges&gt; m_playedTimeRanges;
 975     GenericEventQueue m_asyncEventQueue;
<span class="line-added"> 976 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added"> 977     DeferrableTask&lt;Timer&gt; m_volumeRevertTaskQueue;</span>
<span class="line-added"> 978 #endif</span>
 979 
 980     PlayPromiseVector m_pendingPlayPromises;
 981 
 982     double m_requestedPlaybackRate { 1 };
 983     double m_reportedPlaybackRate { 1 };
 984     double m_defaultPlaybackRate { 1 };
 985     bool m_webkitPreservesPitch { true };
 986     NetworkState m_networkState { NETWORK_EMPTY };
 987     ReadyState m_readyState { HAVE_NOTHING };
 988     ReadyState m_readyStateMaximum { HAVE_NOTHING };
 989     URL m_currentSrc;
 990 
 991     RefPtr&lt;MediaError&gt; m_error;
 992 
 993     struct PendingSeek {
<span class="line-added"> 994         WTF_MAKE_STRUCT_FAST_ALLOCATED;</span>
 995         PendingSeek(const MediaTime&amp; now, const MediaTime&amp; targetTime, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance)
 996             : now(now)
 997             , targetTime(targetTime)
 998             , negativeTolerance(negativeTolerance)
 999             , positiveTolerance(positiveTolerance)
1000         {
1001         }
1002         MediaTime now;
1003         MediaTime targetTime;
1004         MediaTime negativeTolerance;
1005         MediaTime positiveTolerance;
1006     };
1007     std::unique_ptr&lt;PendingSeek&gt; m_pendingSeek;
1008     SeekType m_pendingSeekType { NoSeek };
1009 
1010     double m_volume { 1 };
1011     bool m_volumeInitialized { false };
1012     MediaTime m_lastSeekTime;
1013 
1014     MonotonicTime m_previousProgressTime { MonotonicTime::infinity() };
</pre>
<hr />
<pre>
1061     unsigned m_droppedVideoFrames { 0 };
1062 #endif
1063 
1064     mutable MediaTime m_cachedTime;
1065     mutable MonotonicTime m_clockTimeAtLastCachedTimeUpdate;
1066     mutable MonotonicTime m_minimumClockTimeToUpdateCachedTime;
1067 
1068     MediaTime m_fragmentStartTime;
1069     MediaTime m_fragmentEndTime;
1070 
1071     using PendingActionFlags = unsigned;
1072     PendingActionFlags m_pendingActionFlags { 0 };
1073 
1074     enum ActionAfterScanType { Nothing, Play, Pause };
1075     ActionAfterScanType m_actionAfterScan { Nothing };
1076 
1077     enum ScanType { Seek, Scan };
1078     ScanType m_scanType { Scan };
1079     ScanDirection m_scanDirection { Forward };
1080 
<span class="line-added">1081     BufferingPolicy m_bufferingPolicy { BufferingPolicy::Default };</span>
<span class="line-added">1082 </span>
1083     bool m_firstTimePlaying : 1;
1084     bool m_playing : 1;
1085     bool m_isWaitingUntilMediaCanStart : 1;
1086     bool m_shouldDelayLoadEvent : 1;
1087     bool m_haveFiredLoadedData : 1;
1088     bool m_inActiveDocument : 1;
1089     bool m_autoplaying : 1;
1090     bool m_muted : 1;
1091     bool m_explicitlyMuted : 1;
1092     bool m_initiallyMuted : 1;
1093     bool m_paused : 1;
1094     bool m_seeking : 1;
1095     bool m_seekRequested : 1;
1096 
1097     // data has not been loaded since sending a &quot;stalled&quot; event
1098     bool m_sentStalledEvent : 1;
1099 
1100     // time has not changed since sending an &quot;ended&quot; event
1101     bool m_sentEndEvent : 1;
1102 
1103     bool m_pausedInternal : 1;
1104 
1105     bool m_closedCaptionsVisible : 1;
1106     bool m_webkitLegacyClosedCaptionOverride : 1;
1107     bool m_completelyLoaded : 1;
1108     bool m_havePreparedToPlay : 1;
1109     bool m_parsingInProgress : 1;

1110     bool m_elementIsHidden : 1;
1111     bool m_elementWasRemovedFromDOM : 1;
1112     bool m_creatingControls : 1;
1113     bool m_receivedLayoutSizeChanged : 1;
1114     bool m_hasEverNotifiedAboutPlaying : 1;
1115 
1116     bool m_hasEverHadAudio : 1;
1117     bool m_hasEverHadVideo : 1;
1118 
1119 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1120     bool m_mediaControlsDependOnPageScaleFactor : 1;
1121     bool m_haveSetUpCaptionContainer : 1;
1122 #endif
1123 
1124     bool m_isScrubbingRemotely : 1;
1125     bool m_waitingToEnterFullscreen : 1;
1126 
1127 #if ENABLE(VIDEO_TRACK)
1128     bool m_tracksAreReady : 1;
1129     bool m_haveVisibleTextTrack : 1;
</pre>
<hr />
<pre>
1167     friend class TrackDisplayUpdateScope;
1168 
1169     RefPtr&lt;Blob&gt; m_blob;
1170     MediaProvider m_mediaProvider;
1171 
1172 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
1173     RefPtr&lt;WebKitMediaKeys&gt; m_webKitMediaKeys;
1174 #endif
1175 #if ENABLE(ENCRYPTED_MEDIA)
1176     RefPtr&lt;MediaKeys&gt; m_mediaKeys;
1177     bool m_attachingMediaKeys { false };
1178     bool m_playbackBlockedWaitingForKey { false };
1179     GenericTaskQueue&lt;Timer&gt; m_encryptedMediaQueue;
1180 #endif
1181 
1182     std::unique_ptr&lt;MediaElementSession&gt; m_mediaSession;
1183     size_t m_reportedExtraMemoryCost { 0 };
1184 
1185 #if !RELEASE_LOG_DISABLED
1186     RefPtr&lt;Logger&gt; m_logger;
<span class="line-modified">1187     const void* m_logIdentifier;</span>
1188 #endif
1189 
1190 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1191     friend class MediaControlsHost;
1192     RefPtr&lt;MediaControlsHost&gt; m_mediaControlsHost;
1193     RefPtr&lt;DOMWrapperWorld&gt; m_isolatedWorld;
1194 #endif
1195 
1196 #if ENABLE(MEDIA_STREAM)
1197     RefPtr&lt;MediaStream&gt; m_mediaStreamSrcObject;
1198     bool m_settingMediaStreamSrcObject { false };
1199 #endif
1200 
1201 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1202     MediaProducer::MediaStateFlags m_mediaState { MediaProducer::IsNotPlaying };
1203     bool m_hasPlaybackTargetAvailabilityListeners { false };
1204     bool m_failedToPlayToWirelessTarget { false };
1205 #endif
1206 
1207     bool m_isPlayingToWirelessTarget { false };
1208     bool m_playingOnSecondScreen { false };
<span class="line-added">1209     bool m_removedBehaviorRestrictionsAfterFirstUserGesture { false };</span>
1210 };
1211 
1212 String convertEnumerationToString(HTMLMediaElement::AutoplayEventPlaybackState);
1213 
1214 } // namespace WebCore
1215 
1216 namespace WTF {
1217 
1218 template&lt;&gt; struct LogArgument&lt;WebCore::HTMLMediaElement::AutoplayEventPlaybackState&gt; {
1219     static String toString(WebCore::HTMLMediaElement::AutoplayEventPlaybackState reason) { return convertEnumerationToString(reason); }
1220 };
1221 
1222 #if ENABLE(VIDEO_TRACK) &amp;&amp; !defined(NDEBUG)
1223 
1224 // Template specialization required by PodIntervalTree in debug mode.
1225 template&lt;&gt; struct ValueToString&lt;WebCore::TextTrackCue*&gt; {
1226     static String string(const WebCore::TextTrackCue* cue) { return cue-&gt;debugString(); }
1227 };
1228 
1229 #endif
</pre>
</td>
</tr>
</table>
<center><a href="HTMLMediaElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLMenuElement.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>