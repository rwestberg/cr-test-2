<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2007 Alp Toker &lt;alp@atoker.com&gt;
   4  * Copyright (C) 2010 Torch Mobile (Beijing) Co. Ltd. All rights reserved.
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  * 1. Redistributions of source code must retain the above copyright
  10  *    notice, this list of conditions and the following disclaimer.
  11  * 2. Redistributions in binary form must reproduce the above copyright
  12  *    notice, this list of conditions and the following disclaimer in the
  13  *    documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;HTMLCanvasElement.h&quot;
  30 
  31 #include &quot;Blob.h&quot;
  32 #include &quot;BlobCallback.h&quot;
  33 #include &quot;CanvasGradient.h&quot;
  34 #include &quot;CanvasPattern.h&quot;
  35 #include &quot;CanvasRenderingContext2D.h&quot;
  36 #include &quot;Document.h&quot;
  37 #include &quot;Frame.h&quot;
  38 #include &quot;FrameLoaderClient.h&quot;
  39 #include &quot;GPUBasedCanvasRenderingContext.h&quot;
  40 #include &quot;GeometryUtilities.h&quot;
  41 #include &quot;GraphicsContext.h&quot;
  42 #include &quot;HTMLNames.h&quot;
  43 #include &quot;HTMLParserIdioms.h&quot;
  44 #include &quot;ImageBitmapRenderingContext.h&quot;
  45 #include &quot;ImageBuffer.h&quot;
  46 #include &quot;ImageData.h&quot;
  47 #include &quot;InspectorInstrumentation.h&quot;
  48 #include &quot;JSDOMConvertDictionary.h&quot;
  49 #include &quot;MIMETypeRegistry.h&quot;
  50 #include &quot;RenderElement.h&quot;
  51 #include &quot;RenderHTMLCanvas.h&quot;
  52 #include &quot;ResourceLoadObserver.h&quot;
  53 #include &quot;RuntimeEnabledFeatures.h&quot;
  54 #include &quot;ScriptController.h&quot;
  55 #include &quot;Settings.h&quot;
  56 #include &quot;StringAdaptors.h&quot;
  57 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  58 #include &lt;JavaScriptCore/JSLock.h&gt;
  59 #include &lt;math.h&gt;
  60 #include &lt;wtf/IsoMallocInlines.h&gt;
  61 #include &lt;wtf/RAMSize.h&gt;
  62 #include &lt;wtf/text/StringBuilder.h&gt;
  63 
  64 #if ENABLE(MEDIA_STREAM)
  65 #include &quot;CanvasCaptureMediaStreamTrack.h&quot;
  66 #include &quot;MediaStream.h&quot;
  67 #endif
  68 
  69 #if ENABLE(WEBGL)
  70 #include &quot;WebGLContextAttributes.h&quot;
  71 #include &quot;WebGLRenderingContext.h&quot;
  72 #endif
  73 
  74 #if ENABLE(WEBGL2)
  75 #include &quot;WebGL2RenderingContext.h&quot;
  76 #endif
  77 
  78 #if ENABLE(WEBGPU)
<a name="1" id="anc1"></a><span class="line-modified">  79 #include &quot;WebGPURenderingContext.h&quot;</span>
<span class="line-removed">  80 #endif</span>
<span class="line-removed">  81 </span>
<span class="line-removed">  82 #if ENABLE(WEBMETAL)</span>
<span class="line-removed">  83 #include &quot;WebMetalRenderingContext.h&quot;</span>
  84 #endif
  85 
  86 #if PLATFORM(COCOA)
  87 #include &quot;MediaSampleAVFObjC.h&quot;
  88 #include &lt;pal/cf/CoreMediaSoftLink.h&gt;
  89 #endif
  90 
  91 namespace WebCore {
  92 
  93 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLCanvasElement);
  94 
  95 using namespace PAL;
  96 using namespace HTMLNames;
  97 
  98 // These values come from the WhatWG/W3C HTML spec.
  99 const int defaultWidth = 300;
 100 const int defaultHeight = 150;
 101 
 102 // Firefox limits width/height to 32767 pixels, but slows down dramatically before it
 103 // reaches that limit. We limit by area instead, giving us larger maximum dimensions,
 104 // in exchange for a smaller maximum canvas size. The maximum canvas size is in device pixels.
 105 #if PLATFORM(IOS_FAMILY)
 106 const unsigned maxCanvasArea = 4096 * 4096;
 107 #else
 108 const unsigned maxCanvasArea = 16384 * 16384;
 109 #endif
 110 
 111 #if USE(CG)
 112 // FIXME: It seems strange that the default quality is not the one that is literally named &quot;default&quot;.
 113 // Should fix names to make this easier to understand, or write an excellent comment here explaining why not.
 114 const InterpolationQuality defaultInterpolationQuality = InterpolationLow;
 115 #else
 116 const InterpolationQuality defaultInterpolationQuality = InterpolationDefault;
 117 #endif
 118 
 119 static size_t activePixelMemory = 0;
 120 
 121 HTMLCanvasElement::HTMLCanvasElement(const QualifiedName&amp; tagName, Document&amp; document)
 122     : HTMLElement(tagName, document)
 123     , m_size(defaultWidth, defaultHeight)
 124 {
 125     ASSERT(hasTagName(canvasTag));
 126 }
 127 
 128 Ref&lt;HTMLCanvasElement&gt; HTMLCanvasElement::create(Document&amp; document)
 129 {
 130     return adoptRef(*new HTMLCanvasElement(canvasTag, document));
 131 }
 132 
 133 Ref&lt;HTMLCanvasElement&gt; HTMLCanvasElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 134 {
 135     return adoptRef(*new HTMLCanvasElement(tagName, document));
 136 }
 137 
 138 static void removeFromActivePixelMemory(size_t pixelsReleased)
 139 {
 140     if (!pixelsReleased)
 141         return;
 142 
 143     if (pixelsReleased &lt; activePixelMemory)
 144         activePixelMemory -= pixelsReleased;
 145     else
 146         activePixelMemory = 0;
 147 }
 148 
 149 HTMLCanvasElement::~HTMLCanvasElement()
 150 {
 151     notifyObserversCanvasDestroyed();
 152 
 153     m_context = nullptr; // Ensure this goes away before the ImageBuffer.
 154 
 155     releaseImageBufferAndContext();
 156 }
 157 
<a name="2" id="anc2"></a><span class="line-modified"> 158 void HTMLCanvasElement::parseAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
 159 {
 160     if (name == widthAttr || name == heightAttr)
 161         reset();
 162     HTMLElement::parseAttribute(name, value);
 163 }
 164 
 165 RenderPtr&lt;RenderElement&gt; HTMLCanvasElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp; insertionPosition)
 166 {
 167     RefPtr&lt;Frame&gt; frame = document().frame();
 168     if (frame &amp;&amp; frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
 169         return createRenderer&lt;RenderHTMLCanvas&gt;(*this, WTFMove(style));
 170     return HTMLElement::createElementRenderer(WTFMove(style), insertionPosition);
 171 }
 172 
 173 bool HTMLCanvasElement::canContainRangeEndPoint() const
 174 {
 175     return false;
 176 }
 177 
 178 bool HTMLCanvasElement::canStartSelection() const
 179 {
 180     return false;
 181 }
 182 
 183 ExceptionOr&lt;void&gt; HTMLCanvasElement::setHeight(unsigned value)
 184 {
 185     if (m_context &amp;&amp; m_context-&gt;isPlaceholder())
 186         return Exception { InvalidStateError };
<a name="3" id="anc3"></a><span class="line-modified"> 187     setAttributeWithoutSynchronization(heightAttr, AtomicString::number(limitToOnlyHTMLNonNegative(value, defaultHeight)));</span>
 188     return { };
 189 }
 190 
 191 ExceptionOr&lt;void&gt; HTMLCanvasElement::setWidth(unsigned value)
 192 {
 193     if (m_context &amp;&amp; m_context-&gt;isPlaceholder())
 194         return Exception { InvalidStateError };
<a name="4" id="anc4"></a><span class="line-modified"> 195     setAttributeWithoutSynchronization(widthAttr, AtomicString::number(limitToOnlyHTMLNonNegative(value, defaultWidth)));</span>
 196     return { };
 197 }
 198 
 199 static inline size_t maxActivePixelMemory()
 200 {
 201     static size_t maxPixelMemory;
 202     static std::once_flag onceFlag;
 203     std::call_once(onceFlag, [] {
 204 #if PLATFORM(IOS_FAMILY)
 205         maxPixelMemory = ramSize() / 4;
 206 #else
 207         maxPixelMemory = std::max(ramSize() / 4, 2151 * MB);
 208 #endif
 209     });
 210     return maxPixelMemory;
 211 }
 212 
 213 ExceptionOr&lt;Optional&lt;RenderingContext&gt;&gt; HTMLCanvasElement::getContext(JSC::ExecState&amp; state, const String&amp; contextId, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
 214 {
 215     if (m_context) {
 216         if (m_context-&gt;isPlaceholder())
 217             return Exception { InvalidStateError };
 218 
 219         if (m_context-&gt;is2d()) {
 220             if (!is2dType(contextId))
 221                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 222             return Optional&lt;RenderingContext&gt; { RefPtr&lt;CanvasRenderingContext2D&gt; { &amp;downcast&lt;CanvasRenderingContext2D&gt;(*m_context) } };
 223         }
 224 
 225         if (m_context-&gt;isBitmapRenderer()) {
 226             if (!isBitmapRendererType(contextId))
 227                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 228             return Optional&lt;RenderingContext&gt; { RefPtr&lt;ImageBitmapRenderingContext&gt; { &amp;downcast&lt;ImageBitmapRenderingContext&gt;(*m_context) } };
 229         }
 230 
 231 #if ENABLE(WEBGL)
 232         if (m_context-&gt;isWebGL()) {
 233             if (!isWebGLType(contextId))
 234                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 235             if (is&lt;WebGLRenderingContext&gt;(*m_context))
 236                 return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };
 237 #if ENABLE(WEBGL2)
 238             ASSERT(is&lt;WebGL2RenderingContext&gt;(*m_context));
 239             return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*m_context) } };
 240 #endif
 241         }
 242 #endif
 243 
 244 #if ENABLE(WEBGPU)
 245         if (m_context-&gt;isWebGPU()) {
 246             if (!isWebGPUType(contextId))
 247                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
<a name="5" id="anc5"></a><span class="line-modified"> 248             return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGPURenderingContext&gt; { &amp;downcast&lt;WebGPURenderingContext&gt;(*m_context) } };</span>
<span class="line-removed"> 249         }</span>
<span class="line-removed"> 250 #endif</span>
<span class="line-removed"> 251 </span>
<span class="line-removed"> 252 #if ENABLE(WEBMETAL)</span>
<span class="line-removed"> 253         if (m_context-&gt;isWebMetal()) {</span>
<span class="line-removed"> 254             if (!isWebMetalType(contextId))</span>
<span class="line-removed"> 255                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };</span>
<span class="line-removed"> 256             return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebMetalRenderingContext&gt; { &amp;downcast&lt;WebMetalRenderingContext&gt;(*m_context) } };</span>
 257         }
 258 #endif
 259 
 260         ASSERT_NOT_REACHED();
 261         return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 262     }
 263 
 264     if (is2dType(contextId)) {
 265         auto context = createContext2d(contextId);
 266         if (!context)
 267             return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 268         return Optional&lt;RenderingContext&gt; { RefPtr&lt;CanvasRenderingContext2D&gt; { context } };
 269     }
 270 
 271     if (isBitmapRendererType(contextId)) {
 272         auto scope = DECLARE_THROW_SCOPE(state.vm());
 273         auto attributes = convert&lt;IDLDictionary&lt;ImageBitmapRenderingContextSettings&gt;&gt;(state, !arguments.isEmpty() ? arguments[0].get() : JSC::jsUndefined());
 274         RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 275 
 276         auto context = createContextBitmapRenderer(contextId, WTFMove(attributes));
 277         if (!context)
 278             return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 279         return Optional&lt;RenderingContext&gt; { RefPtr&lt;ImageBitmapRenderingContext&gt; { context } };
 280     }
 281 
 282 #if ENABLE(WEBGL)
 283     if (isWebGLType(contextId)) {
 284         auto scope = DECLARE_THROW_SCOPE(state.vm());
 285         auto attributes = convert&lt;IDLDictionary&lt;WebGLContextAttributes&gt;&gt;(state, !arguments.isEmpty() ? arguments[0].get() : JSC::jsUndefined());
 286         RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 287 
 288         auto context = createContextWebGL(contextId, WTFMove(attributes));
 289         if (!context)
 290             return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 291 
 292         if (is&lt;WebGLRenderingContext&gt;(*context))
 293             return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*context) } };
 294 #if ENABLE(WEBGL2)
 295         ASSERT(is&lt;WebGL2RenderingContext&gt;(*context));
 296         return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*context) } };
 297 #endif
 298     }
 299 #endif
 300 
 301 #if ENABLE(WEBGPU)
 302     if (isWebGPUType(contextId)) {
 303         auto context = createContextWebGPU(contextId);
 304         if (!context)
 305             return Optional&lt;RenderingContext&gt; { WTF::nullopt };
<a name="6" id="anc6"></a><span class="line-modified"> 306         return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGPURenderingContext&gt; { context } };</span>
<span class="line-removed"> 307     }</span>
<span class="line-removed"> 308 #endif</span>
<span class="line-removed"> 309 </span>
<span class="line-removed"> 310 #if ENABLE(WEBMETAL)</span>
<span class="line-removed"> 311     if (isWebMetalType(contextId)) {</span>
<span class="line-removed"> 312         auto context = createContextWebMetal(contextId);</span>
<span class="line-removed"> 313         if (!context)</span>
<span class="line-removed"> 314             return Optional&lt;RenderingContext&gt; { WTF::nullopt };</span>
<span class="line-removed"> 315         return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebMetalRenderingContext&gt; { context } };</span>
 316     }
 317 #endif
 318 
 319     return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 320 }
 321 
 322 CanvasRenderingContext* HTMLCanvasElement::getContext(const String&amp; type)
 323 {
 324     if (HTMLCanvasElement::is2dType(type))
 325         return getContext2d(type);
 326 
 327     if (HTMLCanvasElement::isBitmapRendererType(type))
 328         return getContextBitmapRenderer(type);
 329 
<a name="7" id="anc7"></a><span class="line-removed"> 330 #if ENABLE(WEBMETAL)</span>
<span class="line-removed"> 331     if (HTMLCanvasElement::isWebMetalType(type) &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().webMetalEnabled())</span>
<span class="line-removed"> 332         return getContextWebMetal(type);</span>
<span class="line-removed"> 333 #endif</span>
<span class="line-removed"> 334 </span>
 335 #if ENABLE(WEBGL)
 336     if (HTMLCanvasElement::isWebGLType(type))
 337         return getContextWebGL(type);
 338 #endif
 339 
 340 #if ENABLE(WEBGPU)
 341     if (HTMLCanvasElement::isWebGPUType(type))
 342         return getContextWebGPU(type);
 343 #endif
 344 
 345     return nullptr;
 346 }
 347 
 348 bool HTMLCanvasElement::is2dType(const String&amp; type)
 349 {
 350     return type == &quot;2d&quot;;
 351 }
 352 
 353 CanvasRenderingContext2D* HTMLCanvasElement::createContext2d(const String&amp; type)
 354 {
 355     ASSERT_UNUSED(HTMLCanvasElement::is2dType(type), type);
 356     ASSERT(!m_context);
 357 
<a name="8" id="anc8"></a><span class="line-removed"> 358     bool usesDashboardCompatibilityMode = false;</span>
<span class="line-removed"> 359 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 360     usesDashboardCompatibilityMode = document().settings().usesDashboardBackwardCompatibilityMode();</span>
<span class="line-removed"> 361 #endif</span>
<span class="line-removed"> 362 </span>
 363     // Make sure we don&#39;t use more pixel memory than the system can support.
 364     size_t requestedPixelMemory = 4 * width() * height();
 365     if (activePixelMemory + requestedPixelMemory &gt; maxActivePixelMemory()) {
 366         StringBuilder stringBuilder;
 367         stringBuilder.appendLiteral(&quot;Total canvas memory use exceeds the maximum limit (&quot;);
 368         stringBuilder.appendNumber(maxActivePixelMemory() / 1024 / 1024);
 369         stringBuilder.appendLiteral(&quot; MB).&quot;);
 370         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
 371         return nullptr;
 372     }
 373 
<a name="9" id="anc9"></a><span class="line-modified"> 374     m_context = CanvasRenderingContext2D::create(*this, document().inQuirksMode(), usesDashboardCompatibilityMode);</span>
 375 
 376     downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setUsesDisplayListDrawing(m_usesDisplayListDrawing);
 377     downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setTracksDisplayListReplay(m_tracksDisplayListReplay);
 378 
 379 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 380     // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
 381     invalidateStyleAndLayerComposition();
 382 #endif
 383 
 384     return static_cast&lt;CanvasRenderingContext2D*&gt;(m_context.get());
 385 }
 386 
 387 CanvasRenderingContext2D* HTMLCanvasElement::getContext2d(const String&amp; type)
 388 {
 389     ASSERT_UNUSED(HTMLCanvasElement::is2dType(type), type);
 390 
 391     if (m_context &amp;&amp; !m_context-&gt;is2d())
 392         return nullptr;
 393 
 394     if (!m_context)
 395         return createContext2d(type);
 396     return static_cast&lt;CanvasRenderingContext2D*&gt;(m_context.get());
 397 }
 398 
 399 #if ENABLE(WEBGL)
 400 
 401 static bool requiresAcceleratedCompositingForWebGL()
 402 {
 403 #if PLATFORM(GTK) || PLATFORM(WIN_CAIRO)
 404     return false;
 405 #else
 406     return true;
 407 #endif
 408 
 409 }
 410 static bool shouldEnableWebGL(const Settings&amp; settings)
 411 {
 412     if (!settings.webGLEnabled())
 413         return false;
 414 
 415     if (!requiresAcceleratedCompositingForWebGL())
 416         return true;
 417 
 418     return settings.acceleratedCompositingEnabled();
 419 }
 420 
 421 bool HTMLCanvasElement::isWebGLType(const String&amp; type)
 422 {
 423     // Retain support for the legacy &quot;webkit-3d&quot; name.
 424     return type == &quot;webgl&quot; || type == &quot;experimental-webgl&quot;
 425 #if ENABLE(WEBGL2)
 426         || type == &quot;webgl2&quot;
 427 #endif
 428         || type == &quot;webkit-3d&quot;;
 429 }
 430 
 431 WebGLRenderingContextBase* HTMLCanvasElement::createContextWebGL(const String&amp; type, WebGLContextAttributes&amp;&amp; attrs)
 432 {
 433     ASSERT(HTMLCanvasElement::isWebGLType(type));
 434     ASSERT(!m_context);
 435 
 436     if (!shouldEnableWebGL(document().settings()))
 437         return nullptr;
 438 
 439     m_context = WebGLRenderingContextBase::create(*this, attrs, type);
 440     if (m_context) {
 441         // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
 442         invalidateStyleAndLayerComposition();
 443     }
 444 
 445     return downcast&lt;WebGLRenderingContextBase&gt;(m_context.get());
 446 }
 447 
 448 WebGLRenderingContextBase* HTMLCanvasElement::getContextWebGL(const String&amp; type, WebGLContextAttributes&amp;&amp; attrs)
 449 {
 450     ASSERT(HTMLCanvasElement::isWebGLType(type));
 451 
 452     if (!shouldEnableWebGL(document().settings()))
 453         return nullptr;
 454 
 455     if (m_context &amp;&amp; !m_context-&gt;isWebGL())
 456         return nullptr;
 457 
 458     if (!m_context)
 459         return createContextWebGL(type, WTFMove(attrs));
 460     return &amp;downcast&lt;WebGLRenderingContextBase&gt;(*m_context);
 461 }
 462 
 463 #endif // ENABLE(WEBGL)
 464 
 465 #if ENABLE(WEBGPU)
 466 
 467 bool HTMLCanvasElement::isWebGPUType(const String&amp; type)
 468 {
<a name="10" id="anc10"></a><span class="line-modified"> 469     return type == &quot;webgpu&quot;;</span>
 470 }
 471 
<a name="11" id="anc11"></a><span class="line-modified"> 472 WebGPURenderingContext* HTMLCanvasElement::createContextWebGPU(const String&amp; type)</span>
 473 {
 474     ASSERT_UNUSED(type, HTMLCanvasElement::isWebGPUType(type));
 475     ASSERT(!m_context);
 476 
 477     if (!RuntimeEnabledFeatures::sharedFeatures().webGPUEnabled())
 478         return nullptr;
 479 
<a name="12" id="anc12"></a><span class="line-modified"> 480     m_context = WebGPURenderingContext::create(*this);</span>
 481     if (m_context) {
 482         // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
 483         invalidateStyleAndLayerComposition();
 484     }
 485 
<a name="13" id="anc13"></a><span class="line-modified"> 486     return static_cast&lt;WebGPURenderingContext*&gt;(m_context.get());</span>
 487 }
 488 
<a name="14" id="anc14"></a><span class="line-modified"> 489 WebGPURenderingContext* HTMLCanvasElement::getContextWebGPU(const String&amp; type)</span>
 490 {
 491     ASSERT_UNUSED(type, HTMLCanvasElement::isWebGPUType(type));
 492 
 493     if (!RuntimeEnabledFeatures::sharedFeatures().webGPUEnabled())
 494         return nullptr;
 495 
 496     if (m_context &amp;&amp; !m_context-&gt;isWebGPU())
 497         return nullptr;
 498 
 499     if (!m_context)
 500         return createContextWebGPU(type);
<a name="15" id="anc15"></a><span class="line-modified"> 501     return static_cast&lt;WebGPURenderingContext*&gt;(m_context.get());</span>
 502 }
 503 
 504 #endif // ENABLE(WEBGPU)
 505 
<a name="16" id="anc16"></a><span class="line-removed"> 506 #if ENABLE(WEBMETAL)</span>
<span class="line-removed"> 507 </span>
<span class="line-removed"> 508 bool HTMLCanvasElement::isWebMetalType(const String&amp; type)</span>
<span class="line-removed"> 509 {</span>
<span class="line-removed"> 510     return type == &quot;webmetal&quot;;</span>
<span class="line-removed"> 511 }</span>
<span class="line-removed"> 512 </span>
<span class="line-removed"> 513 WebMetalRenderingContext* HTMLCanvasElement::createContextWebMetal(const String&amp; type)</span>
<span class="line-removed"> 514 {</span>
<span class="line-removed"> 515     ASSERT_UNUSED(type, HTMLCanvasElement::isWebMetalType(type));</span>
<span class="line-removed"> 516     ASSERT(!m_context);</span>
<span class="line-removed"> 517 </span>
<span class="line-removed"> 518     if (!RuntimeEnabledFeatures::sharedFeatures().webMetalEnabled())</span>
<span class="line-removed"> 519         return nullptr;</span>
<span class="line-removed"> 520 </span>
<span class="line-removed"> 521     m_context = WebMetalRenderingContext::create(*this);</span>
<span class="line-removed"> 522     if (m_context) {</span>
<span class="line-removed"> 523         // Need to make sure a RenderLayer and compositing layer get created for the Canvas.</span>
<span class="line-removed"> 524         invalidateStyleAndLayerComposition();</span>
<span class="line-removed"> 525     }</span>
<span class="line-removed"> 526 </span>
<span class="line-removed"> 527     return static_cast&lt;WebMetalRenderingContext*&gt;(m_context.get());</span>
<span class="line-removed"> 528 }</span>
<span class="line-removed"> 529 </span>
<span class="line-removed"> 530 WebMetalRenderingContext* HTMLCanvasElement::getContextWebMetal(const String&amp; type)</span>
<span class="line-removed"> 531 {</span>
<span class="line-removed"> 532     ASSERT_UNUSED(type, HTMLCanvasElement::isWebMetalType(type));</span>
<span class="line-removed"> 533 </span>
<span class="line-removed"> 534     if (!RuntimeEnabledFeatures::sharedFeatures().webMetalEnabled())</span>
<span class="line-removed"> 535         return nullptr;</span>
<span class="line-removed"> 536 </span>
<span class="line-removed"> 537     if (m_context &amp;&amp; !m_context-&gt;isWebMetal())</span>
<span class="line-removed"> 538         return nullptr;</span>
<span class="line-removed"> 539 </span>
<span class="line-removed"> 540     if (!m_context)</span>
<span class="line-removed"> 541         return createContextWebMetal(type);</span>
<span class="line-removed"> 542     return static_cast&lt;WebMetalRenderingContext*&gt;(m_context.get());</span>
<span class="line-removed"> 543 }</span>
<span class="line-removed"> 544 #endif</span>
<span class="line-removed"> 545 </span>
 546 bool HTMLCanvasElement::isBitmapRendererType(const String&amp; type)
 547 {
 548     return type == &quot;bitmaprenderer&quot;;
 549 }
 550 
 551 ImageBitmapRenderingContext* HTMLCanvasElement::createContextBitmapRenderer(const String&amp; type, ImageBitmapRenderingContextSettings&amp;&amp; settings)
 552 {
 553     ASSERT_UNUSED(type, HTMLCanvasElement::isBitmapRendererType(type));
 554     ASSERT(!m_context);
 555 
 556     m_context = ImageBitmapRenderingContext::create(*this, WTFMove(settings));
 557 
 558 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 559     // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
 560     invalidateStyleAndLayerComposition();
 561 #endif
 562 
 563     return static_cast&lt;ImageBitmapRenderingContext*&gt;(m_context.get());
 564 }
 565 
 566 ImageBitmapRenderingContext* HTMLCanvasElement::getContextBitmapRenderer(const String&amp; type, ImageBitmapRenderingContextSettings&amp;&amp; settings)
 567 {
 568     ASSERT_UNUSED(type, HTMLCanvasElement::isBitmapRendererType(type));
 569     if (!m_context)
 570         return createContextBitmapRenderer(type, WTFMove(settings));
 571     return static_cast&lt;ImageBitmapRenderingContext*&gt;(m_context.get());
 572 }
 573 
 574 void HTMLCanvasElement::didDraw(const FloatRect&amp; rect)
 575 {
 576     clearCopiedImage();
 577 
 578     FloatRect dirtyRect = rect;
 579     if (auto* renderer = renderBox()) {
 580         FloatRect destRect;
 581         if (is&lt;RenderReplaced&gt;(renderer))
 582             destRect = downcast&lt;RenderReplaced&gt;(renderer)-&gt;replacedContentRect();
 583         else
 584             destRect = renderer-&gt;contentBoxRect();
 585 
 586         // Inflate dirty rect to cover antialiasing on image buffers.
 587         if (drawingContext() &amp;&amp; drawingContext()-&gt;shouldAntialias())
 588             dirtyRect.inflate(1);
 589 
 590         FloatRect r = mapRect(dirtyRect, FloatRect(0, 0, size().width(), size().height()), destRect);
 591         r.intersect(destRect);
 592 
 593         if (!r.isEmpty() &amp;&amp; !m_dirtyRect.contains(r)) {
 594             m_dirtyRect.unite(r);
 595             renderer-&gt;repaintRectangle(enclosingIntRect(m_dirtyRect));
 596         }
 597     }
 598     notifyObserversCanvasChanged(dirtyRect);
 599 }
 600 
 601 void HTMLCanvasElement::reset()
 602 {
 603     if (m_ignoreReset)
 604         return;
 605 
 606     bool hadImageBuffer = hasCreatedImageBuffer();
 607 
 608     int w = limitToOnlyHTMLNonNegative(attributeWithoutSynchronization(widthAttr), defaultWidth);
 609     int h = limitToOnlyHTMLNonNegative(attributeWithoutSynchronization(heightAttr), defaultHeight);
 610 
 611     if (m_contextStateSaver) {
 612         // Reset to the initial graphics context state.
 613         m_contextStateSaver-&gt;restore();
 614         m_contextStateSaver-&gt;save();
 615     }
 616 
 617     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 618         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).reset();
 619 
 620     IntSize oldSize = size();
 621     IntSize newSize(w, h);
 622     // If the size of an existing buffer matches, we can just clear it instead of reallocating.
 623     // This optimization is only done for 2D canvases for now.
 624     if (m_hasCreatedImageBuffer &amp;&amp; oldSize == newSize &amp;&amp; m_context &amp;&amp; m_context-&gt;is2d()) {
 625         if (!m_didClearImageBuffer)
 626             clearImageBuffer();
 627         return;
 628     }
 629 
 630     setSurfaceSize(newSize);
 631 
 632     if (isGPUBased() &amp;&amp; oldSize != size())
 633         downcast&lt;GPUBasedCanvasRenderingContext&gt;(*m_context).reshape(width(), height());
 634 
 635     auto renderer = this-&gt;renderer();
 636     if (is&lt;RenderHTMLCanvas&gt;(renderer)) {
 637         auto&amp; canvasRenderer = downcast&lt;RenderHTMLCanvas&gt;(*renderer);
 638         if (oldSize != size()) {
 639             canvasRenderer.canvasSizeChanged();
 640             if (canvasRenderer.hasAcceleratedCompositing())
 641                 canvasRenderer.contentChanged(CanvasChanged);
 642         }
 643         if (hadImageBuffer)
 644             canvasRenderer.repaint();
 645     }
 646 
 647     notifyObserversCanvasResized();
 648 }
 649 
 650 bool HTMLCanvasElement::paintsIntoCanvasBuffer() const
 651 {
 652     ASSERT(m_context);
 653 #if USE(IOSURFACE_CANVAS_BACKING_STORE)
 654     if (m_context-&gt;is2d() || m_context-&gt;isBitmapRenderer())
 655         return true;
 656 #endif
 657 
 658     if (!m_context-&gt;isAccelerated())
 659         return true;
 660 
 661     if (renderBox() &amp;&amp; renderBox()-&gt;hasAcceleratedCompositing())
 662         return false;
 663 
 664     return true;
 665 }
 666 
 667 
 668 void HTMLCanvasElement::paint(GraphicsContext&amp; context, const LayoutRect&amp; r)
 669 {
<a name="17" id="anc17"></a><span class="line-removed"> 670     if (UNLIKELY(m_context &amp;&amp; m_context-&gt;callTracingActive()))</span>
<span class="line-removed"> 671         InspectorInstrumentation::didFinishRecordingCanvasFrame(*m_context);</span>
<span class="line-removed"> 672 </span>
 673     // Clear the dirty rect
 674     m_dirtyRect = FloatRect();
 675 
<a name="18" id="anc18"></a><span class="line-modified"> 676     if (context.paintingDisabled())</span>
<span class="line-modified"> 677         return;</span>
 678 
<a name="19" id="anc19"></a><span class="line-modified"> 679     if (m_context) {</span>
<span class="line-modified"> 680         if (!paintsIntoCanvasBuffer() &amp;&amp; !document().printing())</span>
<span class="line-modified"> 681             return;</span>


 682 
<a name="20" id="anc20"></a><span class="line-modified"> 683         m_context-&gt;paintRenderingResultsToCanvas();</span>
<span class="line-modified"> 684     }</span>





 685 
<a name="21" id="anc21"></a><span class="line-modified"> 686     if (hasCreatedImageBuffer()) {</span>
<span class="line-modified"> 687         ImageBuffer* imageBuffer = buffer();</span>
<span class="line-removed"> 688         if (imageBuffer) {</span>
<span class="line-removed"> 689             if (m_presentedImage) {</span>
<span class="line-removed"> 690                 ImageOrientationDescription orientationDescription;</span>
<span class="line-removed"> 691 #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
<span class="line-removed"> 692                 orientationDescription.setImageOrientationEnum(renderer()-&gt;style().imageOrientation());</span>
<span class="line-removed"> 693 #endif</span>
<span class="line-removed"> 694                 context.drawImage(*m_presentedImage, snappedIntRect(r), ImagePaintingOptions(orientationDescription));</span>
<span class="line-removed"> 695             } else</span>
<span class="line-removed"> 696                 context.drawImageBuffer(*imageBuffer, snappedIntRect(r));</span>
 697         }
 698     }
 699 
<a name="22" id="anc22"></a><span class="line-modified"> 700     if (isGPUBased())</span>
<span class="line-modified"> 701         downcast&lt;GPUBasedCanvasRenderingContext&gt;(*m_context).markLayerComposited();</span>
 702 }
 703 
 704 bool HTMLCanvasElement::isGPUBased() const
 705 {
 706     return m_context &amp;&amp; m_context-&gt;isGPUBased();
 707 }
 708 
 709 void HTMLCanvasElement::makeRenderingResultsAvailable()
 710 {
 711     if (m_context)
 712         m_context-&gt;paintRenderingResultsToCanvas();
 713 }
 714 
 715 void HTMLCanvasElement::makePresentationCopy()
 716 {
 717     if (!m_presentedImage) {
 718         // The buffer contains the last presented data, so save a copy of it.
 719         m_presentedImage = buffer()-&gt;copyImage(CopyBackingStore, PreserveResolution::Yes);
 720     }
 721 }
 722 
 723 void HTMLCanvasElement::clearPresentationCopy()
 724 {
 725     m_presentedImage = nullptr;
 726 }
 727 
 728 void HTMLCanvasElement::releaseImageBufferAndContext()
 729 {
 730     m_contextStateSaver = nullptr;
 731     setImageBuffer(nullptr);
 732 }
 733 
 734 void HTMLCanvasElement::setSurfaceSize(const IntSize&amp; size)
 735 {
 736     m_size = size;
 737     m_hasCreatedImageBuffer = false;
 738     releaseImageBufferAndContext();
 739     clearCopiedImage();
 740 }
 741 
 742 static String toEncodingMimeType(const String&amp; mimeType)
 743 {
 744     if (!MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(mimeType))
 745         return &quot;image/png&quot;_s;
 746     return mimeType.convertToASCIILowercase();
 747 }
 748 
 749 // https://html.spec.whatwg.org/multipage/canvas.html#a-serialisation-of-the-bitmap-as-a-file
 750 static Optional&lt;double&gt; qualityFromJSValue(JSC::JSValue qualityValue)
 751 {
 752     if (!qualityValue.isNumber())
 753         return WTF::nullopt;
 754 
 755     double qualityNumber = qualityValue.asNumber();
 756     if (qualityNumber &lt; 0 || qualityNumber &gt; 1)
 757         return WTF::nullopt;
 758 
 759     return qualityNumber;
 760 }
 761 
 762 ExceptionOr&lt;UncachedString&gt; HTMLCanvasElement::toDataURL(const String&amp; mimeType, JSC::JSValue qualityValue)
 763 {
 764     if (!originClean())
 765         return Exception { SecurityError };
 766 
 767     if (m_size.isEmpty() || !buffer())
 768         return UncachedString { &quot;data:,&quot;_s };
 769     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 770         ResourceLoadObserver::shared().logCanvasRead(document());
 771 
 772     auto encodingMIMEType = toEncodingMimeType(mimeType);
 773     auto quality = qualityFromJSValue(qualityValue);
 774 
 775 #if USE(CG)
 776     // Try to get ImageData first, as that may avoid lossy conversions.
 777     if (auto imageData = getImageData())
 778         return UncachedString { dataURL(*imageData, encodingMIMEType, quality) };
 779 #endif
 780 
 781     makeRenderingResultsAvailable();
 782 
 783     return UncachedString { buffer()-&gt;toDataURL(encodingMIMEType, quality) };
 784 }
 785 
 786 ExceptionOr&lt;UncachedString&gt; HTMLCanvasElement::toDataURL(const String&amp; mimeType)
 787 {
 788     return toDataURL(mimeType, { });
 789 }
 790 
 791 ExceptionOr&lt;void&gt; HTMLCanvasElement::toBlob(ScriptExecutionContext&amp; context, Ref&lt;BlobCallback&gt;&amp;&amp; callback, const String&amp; mimeType, JSC::JSValue qualityValue)
 792 {
 793     if (!originClean())
 794         return Exception { SecurityError };
 795 
 796     if (m_size.isEmpty() || !buffer()) {
 797         callback-&gt;scheduleCallback(context, nullptr);
 798         return { };
 799     }
 800     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 801         ResourceLoadObserver::shared().logCanvasRead(document());
 802 
 803     auto encodingMIMEType = toEncodingMimeType(mimeType);
 804     auto quality = qualityFromJSValue(qualityValue);
 805 
 806 #if USE(CG)
 807     if (auto imageData = getImageData()) {
 808         RefPtr&lt;Blob&gt; blob;
 809         Vector&lt;uint8_t&gt; blobData = data(*imageData, encodingMIMEType, quality);
 810         if (!blobData.isEmpty())
<a name="23" id="anc23"></a><span class="line-modified"> 811             blob = Blob::create(WTFMove(blobData), encodingMIMEType);</span>
 812         callback-&gt;scheduleCallback(context, WTFMove(blob));
 813         return { };
 814     }
 815 #endif
 816 
 817     makeRenderingResultsAvailable();
 818 
 819     RefPtr&lt;Blob&gt; blob;
 820     Vector&lt;uint8_t&gt; blobData = buffer()-&gt;toData(encodingMIMEType, quality);
 821     if (!blobData.isEmpty())
<a name="24" id="anc24"></a><span class="line-modified"> 822         blob = Blob::create(WTFMove(blobData), encodingMIMEType);</span>
 823     callback-&gt;scheduleCallback(context, WTFMove(blob));
 824     return { };
 825 }
 826 
 827 RefPtr&lt;ImageData&gt; HTMLCanvasElement::getImageData()
 828 {
 829 #if ENABLE(WEBGL)
 830     if (is&lt;WebGLRenderingContextBase&gt;(m_context.get())) {
 831         if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 832             ResourceLoadObserver::shared().logCanvasRead(document());
 833         return downcast&lt;WebGLRenderingContextBase&gt;(*m_context).paintRenderingResultsToImageData();
 834     }
 835 #endif
 836     return nullptr;
 837 }
 838 
 839 #if ENABLE(MEDIA_STREAM)
 840 
 841 RefPtr&lt;MediaSample&gt; HTMLCanvasElement::toMediaSample()
 842 {
 843     auto* imageBuffer = buffer();
 844     if (!imageBuffer)
 845         return nullptr;
 846     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 847         ResourceLoadObserver::shared().logCanvasRead(document());
 848 
 849 #if PLATFORM(COCOA)
 850     makeRenderingResultsAvailable();
 851     return MediaSampleAVFObjC::createImageSample(imageBuffer-&gt;toBGRAData(), width(), height());
 852 #else
 853     return nullptr;
 854 #endif
 855 }
 856 
<a name="25" id="anc25"></a><span class="line-modified"> 857 ExceptionOr&lt;Ref&lt;MediaStream&gt;&gt; HTMLCanvasElement::captureStream(ScriptExecutionContext&amp; context, Optional&lt;double&gt;&amp;&amp; frameRequestRate)</span>
 858 {
 859     if (!originClean())
 860         return Exception(SecurityError, &quot;Canvas is tainted&quot;_s);
 861     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
<a name="26" id="anc26"></a><span class="line-modified"> 862         ResourceLoadObserver::shared().logCanvasRead(document());</span>
 863 
 864     if (frameRequestRate &amp;&amp; frameRequestRate.value() &lt; 0)
 865         return Exception(NotSupportedError, &quot;frameRequestRate is negative&quot;_s);
 866 
<a name="27" id="anc27"></a><span class="line-modified"> 867     auto track = CanvasCaptureMediaStreamTrack::create(context, *this, WTFMove(frameRequestRate));</span>
<span class="line-modified"> 868     auto stream =  MediaStream::create(context);</span>
 869     stream-&gt;addTrack(track);
<a name="28" id="anc28"></a><span class="line-modified"> 870     return WTFMove(stream);</span>
 871 }
 872 #endif
 873 
 874 SecurityOrigin* HTMLCanvasElement::securityOrigin() const
 875 {
 876     return &amp;document().securityOrigin();
 877 }
 878 
 879 bool HTMLCanvasElement::shouldAccelerate(const IntSize&amp; size) const
 880 {
 881     auto&amp; settings = document().settings();
 882 
 883     auto area = size.area&lt;RecordOverflow&gt;();
 884     if (area.hasOverflowed())
 885         return false;
 886 
 887     if (area &gt; settings.maximumAccelerated2dCanvasSize())
 888         return false;
 889 
 890 #if USE(IOSURFACE_CANVAS_BACKING_STORE)
 891     return settings.canvasUsesAcceleratedDrawing();
 892 #elif ENABLE(ACCELERATED_2D_CANVAS)
 893     if (m_context &amp;&amp; !m_context-&gt;is2d())
 894         return false;
 895 
 896     if (!settings.accelerated2dCanvasEnabled())
 897         return false;
 898 
 899     if (area &lt; settings.minimumAccelerated2dCanvasSize())
 900         return false;
 901 
 902     return true;
 903 #else
 904     UNUSED_PARAM(size);
 905     return false;
 906 #endif
 907 }
 908 
 909 size_t HTMLCanvasElement::memoryCost() const
 910 {
 911     // memoryCost() may be invoked concurrently from a GC thread, and we need to be careful
 912     // about what data we access here and how. We need to hold a lock to prevent m_imageBuffer
 913     // from being changed while we access it.
 914     auto locker = holdLock(m_imageBufferAssignmentLock);
 915     if (!m_imageBuffer)
 916         return 0;
 917     return m_imageBuffer-&gt;memoryCost();
 918 }
 919 
 920 size_t HTMLCanvasElement::externalMemoryCost() const
 921 {
 922     // externalMemoryCost() may be invoked concurrently from a GC thread, and we need to be careful
 923     // about what data we access here and how. We need to hold a lock to prevent m_imageBuffer
 924     // from being changed while we access it.
 925     auto locker = holdLock(m_imageBufferAssignmentLock);
 926     if (!m_imageBuffer)
 927         return 0;
 928     return m_imageBuffer-&gt;externalMemoryCost();
 929 }
 930 
 931 void HTMLCanvasElement::setUsesDisplayListDrawing(bool usesDisplayListDrawing)
 932 {
 933     if (usesDisplayListDrawing == m_usesDisplayListDrawing)
 934         return;
 935 
 936     m_usesDisplayListDrawing = usesDisplayListDrawing;
 937 
 938     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 939         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setUsesDisplayListDrawing(m_usesDisplayListDrawing);
 940 }
 941 
 942 void HTMLCanvasElement::setTracksDisplayListReplay(bool tracksDisplayListReplay)
 943 {
 944     if (tracksDisplayListReplay == m_tracksDisplayListReplay)
 945         return;
 946 
 947     m_tracksDisplayListReplay = tracksDisplayListReplay;
 948 
 949     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 950         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setTracksDisplayListReplay(m_tracksDisplayListReplay);
 951 }
 952 
 953 String HTMLCanvasElement::displayListAsText(DisplayList::AsTextFlags flags) const
 954 {
 955     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 956         return downcast&lt;CanvasRenderingContext2D&gt;(*m_context).displayListAsText(flags);
 957 
 958     return String();
 959 }
 960 
 961 String HTMLCanvasElement::replayDisplayListAsText(DisplayList::AsTextFlags flags) const
 962 {
 963     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 964         return downcast&lt;CanvasRenderingContext2D&gt;(*m_context).replayDisplayListAsText(flags);
 965 
 966     return String();
 967 }
 968 
 969 void HTMLCanvasElement::createImageBuffer() const
 970 {
 971     ASSERT(!m_imageBuffer);
 972 
 973     m_hasCreatedImageBuffer = true;
 974     m_didClearImageBuffer = true;
 975 
 976     // Perform multiplication as floating point to avoid overflow
 977     if (float(width()) * height() &gt; maxCanvasArea) {
 978         StringBuilder stringBuilder;
 979         stringBuilder.appendLiteral(&quot;Canvas area exceeds the maximum limit (width * height &gt; &quot;);
 980         stringBuilder.appendNumber(maxCanvasArea);
 981         stringBuilder.appendLiteral(&quot;).&quot;);
 982         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
 983         return;
 984     }
 985 
 986     // Make sure we don&#39;t use more pixel memory than the system can support.
 987     size_t requestedPixelMemory = 4 * width() * height();
 988     if (activePixelMemory + requestedPixelMemory &gt; maxActivePixelMemory()) {
 989         StringBuilder stringBuilder;
 990         stringBuilder.appendLiteral(&quot;Total canvas memory use exceeds the maximum limit (&quot;);
 991         stringBuilder.appendNumber(maxActivePixelMemory() / 1024 / 1024);
 992         stringBuilder.appendLiteral(&quot; MB).&quot;);
 993         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
 994         return;
 995     }
 996 
 997     if (!width() || !height())
 998         return;
 999 
1000     RenderingMode renderingMode = shouldAccelerate(size()) ? Accelerated : Unaccelerated;
1001 
1002     auto hostWindow = (document().view() &amp;&amp; document().view()-&gt;root()) ? document().view()-&gt;root()-&gt;hostWindow() : nullptr;
1003     setImageBuffer(ImageBuffer::create(size(), renderingMode, 1, ColorSpaceSRGB, hostWindow));
1004 }
1005 
1006 void HTMLCanvasElement::setImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer) const
1007 {
1008     size_t previousMemoryCost = memoryCost();
1009     removeFromActivePixelMemory(previousMemoryCost);
1010 
1011     {
1012         auto locker = holdLock(m_imageBufferAssignmentLock);
1013         m_contextStateSaver = nullptr;
1014         m_imageBuffer = WTFMove(buffer);
1015     }
1016 
1017     if (m_imageBuffer &amp;&amp; m_size != m_imageBuffer-&gt;internalSize())
1018         m_size = m_imageBuffer-&gt;internalSize();
1019 
1020     size_t currentMemoryCost = memoryCost();
1021     activePixelMemory += currentMemoryCost;
1022 
1023     if (m_context &amp;&amp; m_imageBuffer &amp;&amp; previousMemoryCost != currentMemoryCost)
1024         InspectorInstrumentation::didChangeCanvasMemory(*m_context);
1025 
1026     if (!m_imageBuffer)
1027         return;
1028     m_imageBuffer-&gt;context().setShadowsIgnoreTransforms(true);
1029     m_imageBuffer-&gt;context().setImageInterpolationQuality(defaultInterpolationQuality);
1030     m_imageBuffer-&gt;context().setStrokeThickness(1);
<a name="29" id="anc29"></a><span class="line-modified">1031     m_contextStateSaver = std::make_unique&lt;GraphicsContextStateSaver&gt;(m_imageBuffer-&gt;context());</span>
1032 
1033     JSC::JSLockHolder lock(HTMLElement::scriptExecutionContext()-&gt;vm());
1034     HTMLElement::scriptExecutionContext()-&gt;vm().heap.reportExtraMemoryAllocated(memoryCost());
1035 
1036 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
1037     if (m_context &amp;&amp; m_context-&gt;is2d()) {
1038         // Recalculate compositing requirements if acceleration state changed.
1039         const_cast&lt;HTMLCanvasElement*&gt;(this)-&gt;invalidateStyleAndLayerComposition();
1040     }
1041 #endif
1042 }
1043 
1044 void HTMLCanvasElement::setImageBufferAndMarkDirty(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer)
1045 {
1046     m_hasCreatedImageBuffer = true;
1047     setImageBuffer(WTFMove(buffer));
1048     didDraw(FloatRect(FloatPoint(), m_size));
1049 }
1050 
1051 GraphicsContext* HTMLCanvasElement::drawingContext() const
1052 {
1053     if (m_context &amp;&amp; !m_context-&gt;is2d())
1054         return nullptr;
1055 
1056     return buffer() ? &amp;m_imageBuffer-&gt;context() : nullptr;
1057 }
1058 
1059 GraphicsContext* HTMLCanvasElement::existingDrawingContext() const
1060 {
1061     if (!m_hasCreatedImageBuffer)
1062         return nullptr;
1063 
1064     return drawingContext();
1065 }
1066 
1067 ImageBuffer* HTMLCanvasElement::buffer() const
1068 {
1069     if (!m_hasCreatedImageBuffer)
1070         createImageBuffer();
1071     return m_imageBuffer.get();
1072 }
1073 
1074 Image* HTMLCanvasElement::copiedImage() const
1075 {
1076     if (!m_copiedImage &amp;&amp; buffer()) {
1077         if (m_context)
1078             m_context-&gt;paintRenderingResultsToCanvas();
1079         m_copiedImage = buffer()-&gt;copyImage(CopyBackingStore, PreserveResolution::Yes);
1080     }
1081     return m_copiedImage.get();
1082 }
1083 
1084 void HTMLCanvasElement::clearImageBuffer() const
1085 {
1086     ASSERT(m_hasCreatedImageBuffer);
1087     ASSERT(!m_didClearImageBuffer);
1088     ASSERT(m_context);
1089 
1090     m_didClearImageBuffer = true;
1091 
1092     if (is&lt;CanvasRenderingContext2D&gt;(*m_context)) {
1093         // No need to undo transforms/clip/etc. because we are called right after the context is reset.
1094         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).clearRect(0, 0, width(), height());
1095     }
1096 }
1097 
1098 void HTMLCanvasElement::clearCopiedImage()
1099 {
1100     m_copiedImage = nullptr;
1101     m_didClearImageBuffer = false;
1102 }
1103 
1104 AffineTransform HTMLCanvasElement::baseTransform() const
1105 {
1106     ASSERT(m_hasCreatedImageBuffer);
1107     return m_imageBuffer-&gt;baseTransform();
1108 }
1109 
1110 }
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>