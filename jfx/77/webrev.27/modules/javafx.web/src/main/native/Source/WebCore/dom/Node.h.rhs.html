<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/Node.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  5  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
  6  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  *
 23  */
 24 
 25 #pragma once
 26 
 27 #include &quot;EventTarget.h&quot;
 28 #include &quot;ExceptionOr.h&quot;
 29 #include &quot;LayoutRect.h&quot;
 30 #include &quot;MutationObserver.h&quot;
 31 #include &quot;RenderStyleConstants.h&quot;
 32 #include &quot;StyleValidity.h&quot;
 33 #include &quot;TreeScope.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 34 #include &lt;wtf/CompactPointerTuple.h&gt;</span>
 35 #include &lt;wtf/Forward.h&gt;
 36 #include &lt;wtf/IsoMalloc.h&gt;
 37 #include &lt;wtf/ListHashSet.h&gt;
 38 #include &lt;wtf/MainThread.h&gt;
 39 #include &lt;wtf/URLHash.h&gt;
 40 
 41 // This needs to be here because Document.h also depends on it.
 42 #define DUMP_NODE_STATISTICS 0
 43 
 44 namespace WebCore {
 45 
 46 class ContainerNode;
 47 class Document;
 48 class Element;
 49 class FloatPoint;
 50 class HTMLQualifiedName;
 51 class HTMLSlotElement;
 52 class MathMLQualifiedName;
 53 class NamedNodeMap;
 54 class NodeList;
 55 class NodeListsNodeData;
 56 class NodeRareData;
 57 class QualifiedName;
 58 class RenderBox;
 59 class RenderBoxModelObject;
 60 class RenderObject;
 61 class RenderStyle;
 62 class SVGQualifiedName;
 63 class ShadowRoot;
 64 class TouchEvent;
 65 
 66 using NodeOrString = Variant&lt;RefPtr&lt;Node&gt;, String&gt;;
 67 
<a name="2" id="anc2"></a>













 68 class Node : public EventTarget {
 69     WTF_MAKE_ISO_ALLOCATED(Node);
 70 
 71     friend class Document;
 72     friend class TreeScope;
 73 public:
 74     enum NodeType {
 75         ELEMENT_NODE = 1,
 76         ATTRIBUTE_NODE = 2,
 77         TEXT_NODE = 3,
 78         CDATA_SECTION_NODE = 4,
 79         PROCESSING_INSTRUCTION_NODE = 7,
 80         COMMENT_NODE = 8,
 81         DOCUMENT_NODE = 9,
 82         DOCUMENT_TYPE_NODE = 10,
 83         DOCUMENT_FRAGMENT_NODE = 11,
 84     };
 85     enum DeprecatedNodeType {
 86         ENTITY_REFERENCE_NODE = 5,
 87         ENTITY_NODE = 6,
 88         NOTATION_NODE = 12,
 89     };
 90     enum DocumentPosition {
 91         DOCUMENT_POSITION_EQUIVALENT = 0x00,
 92         DOCUMENT_POSITION_DISCONNECTED = 0x01,
 93         DOCUMENT_POSITION_PRECEDING = 0x02,
 94         DOCUMENT_POSITION_FOLLOWING = 0x04,
 95         DOCUMENT_POSITION_CONTAINS = 0x08,
 96         DOCUMENT_POSITION_CONTAINED_BY = 0x10,
 97         DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20,
 98     };
 99 
100     WEBCORE_EXPORT static void startIgnoringLeaks();
101     WEBCORE_EXPORT static void stopIgnoringLeaks();
102 
103     static void dumpStatistics();
104 
105     virtual ~Node();
106     void willBeDeletedFrom(Document&amp;);
107 
108     // DOM methods &amp; attributes for Node
109 
110     bool hasTagName(const HTMLQualifiedName&amp;) const;
111     bool hasTagName(const MathMLQualifiedName&amp;) const;
112     bool hasTagName(const SVGQualifiedName&amp;) const;
113     virtual String nodeName() const = 0;
114     virtual String nodeValue() const;
115     virtual ExceptionOr&lt;void&gt; setNodeValue(const String&amp;);
116     virtual NodeType nodeType() const = 0;
117     virtual size_t approximateMemoryCost() const { return sizeof(*this); }
118     ContainerNode* parentNode() const;
119     static ptrdiff_t parentNodeMemoryOffset() { return OBJECT_OFFSETOF(Node, m_parentNode); }
120     Element* parentElement() const;
121     Node* previousSibling() const { return m_previous; }
122     static ptrdiff_t previousSiblingMemoryOffset() { return OBJECT_OFFSETOF(Node, m_previous); }
123     Node* nextSibling() const { return m_next; }
124     static ptrdiff_t nextSiblingMemoryOffset() { return OBJECT_OFFSETOF(Node, m_next); }
125     WEBCORE_EXPORT RefPtr&lt;NodeList&gt; childNodes();
126     Node* firstChild() const;
127     Node* lastChild() const;
128     bool hasAttributes() const;
129     NamedNodeMap* attributes() const;
130     Node* pseudoAwareNextSibling() const;
131     Node* pseudoAwarePreviousSibling() const;
132     Node* pseudoAwareFirstChild() const;
133     Node* pseudoAwareLastChild() const;
134 
135     WEBCORE_EXPORT const URL&amp; baseURI() const;
136 
137     void getSubresourceURLs(ListHashSet&lt;URL&gt;&amp;) const;
138 
139     WEBCORE_EXPORT ExceptionOr&lt;void&gt; insertBefore(Node&amp; newChild, Node* refChild);
140     WEBCORE_EXPORT ExceptionOr&lt;void&gt; replaceChild(Node&amp; newChild, Node&amp; oldChild);
141     WEBCORE_EXPORT ExceptionOr&lt;void&gt; removeChild(Node&amp; child);
142     WEBCORE_EXPORT ExceptionOr&lt;void&gt; appendChild(Node&amp; newChild);
143 
144     bool hasChildNodes() const { return firstChild(); }
145 
146     enum class CloningOperation {
147         OnlySelf,
148         SelfWithTemplateContent,
149         Everything,
150     };
151     virtual Ref&lt;Node&gt; cloneNodeInternal(Document&amp;, CloningOperation) = 0;
152     Ref&lt;Node&gt; cloneNode(bool deep) { return cloneNodeInternal(document(), deep ? CloningOperation::Everything : CloningOperation::OnlySelf); }
153     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Node&gt;&gt; cloneNodeForBindings(bool deep);
154 
<a name="3" id="anc3"></a><span class="line-modified">155     virtual const AtomString&amp; localName() const;</span>
<span class="line-modified">156     virtual const AtomString&amp; namespaceURI() const;</span>
<span class="line-modified">157     virtual const AtomString&amp; prefix() const;</span>
<span class="line-modified">158     virtual ExceptionOr&lt;void&gt; setPrefix(const AtomString&amp;);</span>
159     WEBCORE_EXPORT void normalize();
160 
161     bool isSameNode(Node* other) const { return this == other; }
162     WEBCORE_EXPORT bool isEqualNode(Node*) const;
<a name="4" id="anc4"></a><span class="line-modified">163     WEBCORE_EXPORT bool isDefaultNamespace(const AtomString&amp; namespaceURI) const;</span>
<span class="line-modified">164     WEBCORE_EXPORT const AtomString&amp; lookupPrefix(const AtomString&amp; namespaceURI) const;</span>
<span class="line-modified">165     WEBCORE_EXPORT const AtomString&amp; lookupNamespaceURI(const AtomString&amp; prefix) const;</span>
166 
167     WEBCORE_EXPORT String textContent(bool convertBRsToNewlines = false) const;
168     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setTextContent(const String&amp;);
169 
170     Node* lastDescendant() const;
171     Node* firstDescendant() const;
172 
173     // From the NonDocumentTypeChildNode - https://dom.spec.whatwg.org/#nondocumenttypechildnode
174     WEBCORE_EXPORT Element* previousElementSibling() const;
175     WEBCORE_EXPORT Element* nextElementSibling() const;
176 
177     // From the ChildNode - https://dom.spec.whatwg.org/#childnode
178     ExceptionOr&lt;void&gt; before(Vector&lt;NodeOrString&gt;&amp;&amp;);
179     ExceptionOr&lt;void&gt; after(Vector&lt;NodeOrString&gt;&amp;&amp;);
180     ExceptionOr&lt;void&gt; replaceWith(Vector&lt;NodeOrString&gt;&amp;&amp;);
181     WEBCORE_EXPORT ExceptionOr&lt;void&gt; remove();
182 
183     // Other methods (not part of DOM)
184 
185     bool isElementNode() const { return getFlag(IsElementFlag); }
186     bool isContainerNode() const { return getFlag(IsContainerFlag); }
187     bool isTextNode() const { return getFlag(IsTextFlag); }
188     bool isHTMLElement() const { return getFlag(IsHTMLFlag); }
189     bool isSVGElement() const { return getFlag(IsSVGFlag); }
190     bool isMathMLElement() const { return getFlag(IsMathMLFlag); }
191 
192     bool isPseudoElement() const { return pseudoId() != PseudoId::None; }
193     bool isBeforePseudoElement() const { return pseudoId() == PseudoId::Before; }
194     bool isAfterPseudoElement() const { return pseudoId() == PseudoId::After; }
195     PseudoId pseudoId() const { return (isElementNode() &amp;&amp; hasCustomStyleResolveCallbacks()) ? customPseudoId() : PseudoId::None; }
196 
197     virtual bool isMediaControlElement() const { return false; }
198     virtual bool isMediaControls() const { return false; }
199 #if ENABLE(VIDEO_TRACK)
200     virtual bool isWebVTTElement() const { return false; }
201 #endif
202     bool isStyledElement() const { return getFlag(IsHTMLFlag) || getFlag(IsSVGFlag) || getFlag(IsMathMLFlag); }
203     virtual bool isAttributeNode() const { return false; }
204     virtual bool isCharacterDataNode() const { return false; }
205     virtual bool isFrameOwnerElement() const { return false; }
206     virtual bool isPluginElement() const { return false; }
207 #if ENABLE(SERVICE_CONTROLS)
208     virtual bool isImageControlsRootElement() const { return false; }
209     virtual bool isImageControlsButtonElement() const { return false; }
210 #endif
211 
212     bool isDocumentNode() const { return getFlag(IsDocumentNodeFlag); }
213     bool isTreeScope() const { return getFlag(IsDocumentNodeFlag) || getFlag(IsShadowRootFlag); }
214     bool isDocumentFragment() const { return getFlag(IsContainerFlag) &amp;&amp; !(getFlag(IsElementFlag) || getFlag(IsDocumentNodeFlag)); }
215     bool isShadowRoot() const { return getFlag(IsShadowRootFlag); }
216 
217     bool hasCustomStyleResolveCallbacks() const { return getFlag(HasCustomStyleResolveCallbacksFlag); }
218 
219     bool hasSyntheticAttrChildNodes() const { return getFlag(HasSyntheticAttrChildNodesFlag); }
220     void setHasSyntheticAttrChildNodes(bool flag) { setFlag(flag, HasSyntheticAttrChildNodesFlag); }
221 
222     // If this node is in a shadow tree, returns its shadow host. Otherwise, returns null.
223     WEBCORE_EXPORT Element* shadowHost() const;
224     ShadowRoot* containingShadowRoot() const;
225     ShadowRoot* shadowRoot() const;
226     bool isClosedShadowHidden(const Node&amp;) const;
227 
228     HTMLSlotElement* assignedSlot() const;
229     HTMLSlotElement* assignedSlotForBindings() const;
230 
231     bool isUndefinedCustomElement() const { return isElementNode() &amp;&amp; getFlag(IsEditingTextOrUndefinedCustomElementFlag); }
232     bool isCustomElementUpgradeCandidate() const { return getFlag(IsCustomElement) &amp;&amp; getFlag(IsEditingTextOrUndefinedCustomElementFlag); }
233     bool isDefinedCustomElement() const { return getFlag(IsCustomElement) &amp;&amp; !getFlag(IsEditingTextOrUndefinedCustomElementFlag); }
234     bool isFailedCustomElement() const { return isElementNode() &amp;&amp; !getFlag(IsCustomElement) &amp;&amp; getFlag(IsEditingTextOrUndefinedCustomElementFlag); }
235 
236     // Returns null, a child of ShadowRoot, or a legacy shadow root.
237     Node* nonBoundaryShadowTreeRootNode();
238 
239     // Node&#39;s parent or shadow tree host.
240     ContainerNode* parentOrShadowHostNode() const;
241     ContainerNode* parentInComposedTree() const;
242     Element* parentElementInComposedTree() const;
243     Element* parentOrShadowHostElement() const;
244     void setParentNode(ContainerNode*);
245     Node&amp; rootNode() const;
246     Node&amp; traverseToRootNode() const;
247     Node&amp; shadowIncludingRoot() const;
248 
249     struct GetRootNodeOptions {
250         bool composed;
251     };
252     Node&amp; getRootNode(const GetRootNodeOptions&amp;) const;
253 
254     void* opaqueRoot() const;
255 
256     // Use when it&#39;s guaranteed to that shadowHost is null.
257     ContainerNode* parentNodeGuaranteedHostFree() const;
258     // Returns the parent node, but null if the parent node is a ShadowRoot.
259     ContainerNode* nonShadowBoundaryParentNode() const;
260 
261     bool selfOrAncestorHasDirAutoAttribute() const { return getFlag(SelfOrAncestorHasDirAutoFlag); }
262     void setSelfOrAncestorHasDirAutoAttribute(bool flag) { setFlag(flag, SelfOrAncestorHasDirAutoFlag); }
263 
264     // Returns the enclosing event parent Element (or self) that, when clicked, would trigger a navigation.
265     Element* enclosingLinkEventParentOrSelf();
266 
267     // These low-level calls give the caller responsibility for maintaining the integrity of the tree.
268     void setPreviousSibling(Node* previous) { m_previous = previous; }
269     void setNextSibling(Node* next) { m_next = next; }
270 
271     virtual bool canContainRangeEndPoint() const { return false; }
272 
<a name="5" id="anc5"></a><span class="line-modified">273     WEBCORE_EXPORT bool isRootEditableElement() const;</span>
274     WEBCORE_EXPORT Element* rootEditableElement() const;
275 
276     // Called by the parser when this element&#39;s close tag is reached,
277     // signaling that all child tags have been parsed and added.
278     // This is needed for &lt;applet&gt; and &lt;object&gt; elements, which can&#39;t lay themselves out
279     // until they know all of their nested &lt;param&gt;s. [Radar 3603191, 4040848].
280     // Also used for script elements and some SVG elements for similar purposes,
281     // but making parsing a special case in this respect should be avoided if possible.
282     virtual void finishParsingChildren() { }
283     virtual void beginParsingChildren() { }
284 
285     // For &lt;link&gt; and &lt;style&gt; elements.
286     virtual bool sheetLoaded() { return true; }
287     virtual void notifyLoadedSheetAndAllCriticalSubresources(bool /* error loading subresource */) { }
288     virtual void startLoadingDynamicSheet() { ASSERT_NOT_REACHED(); }
289 
290     bool isUserActionElement() const { return getFlag(IsUserActionElement); }
291     void setUserActionElement(bool flag) { setFlag(flag, IsUserActionElement); }
292 
293     bool inRenderedDocument() const;
294     bool needsStyleRecalc() const { return styleValidity() != Style::Validity::Valid; }
295     Style::Validity styleValidity() const;
296     bool styleResolutionShouldRecompositeLayer() const;
297     bool childNeedsStyleRecalc() const { return getFlag(ChildNeedsStyleRecalcFlag); }
298     bool styleIsAffectedByPreviousSibling() const { return getFlag(StyleIsAffectedByPreviousSibling); }
299     bool isEditingText() const { return getFlag(IsTextFlag) &amp;&amp; getFlag(IsEditingTextOrUndefinedCustomElementFlag); }
300 
301     void setChildNeedsStyleRecalc() { setFlag(ChildNeedsStyleRecalcFlag); }
302     void clearChildNeedsStyleRecalc() { m_nodeFlags &amp;= ~(ChildNeedsStyleRecalcFlag | DirectChildNeedsStyleRecalcFlag); }
303 
304     void setHasValidStyle();
305 
306     bool isLink() const { return getFlag(IsLinkFlag); }
307     void setIsLink(bool flag) { setFlag(flag, IsLinkFlag); }
308 
309     bool hasEventTargetData() const { return getFlag(HasEventTargetDataFlag); }
310     void setHasEventTargetData(bool flag) { setFlag(flag, HasEventTargetDataFlag); }
311 
312     enum UserSelectAllTreatment {
313         UserSelectAllDoesNotAffectEditability,
314         UserSelectAllIsAlwaysNonEditable
315     };
316     WEBCORE_EXPORT bool isContentEditable();
317     bool isContentRichlyEditable();
318 
319     WEBCORE_EXPORT void inspect();
320 
321     bool hasEditableStyle(UserSelectAllTreatment treatment = UserSelectAllIsAlwaysNonEditable) const
322     {
323         return computeEditability(treatment, ShouldUpdateStyle::DoNotUpdate) != Editability::ReadOnly;
324     }
325     // FIXME: Replace every use of this function by helpers in Editing.h
326     bool hasRichlyEditableStyle() const
327     {
328         return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::DoNotUpdate) == Editability::CanEditRichly;
329     }
330 
331     enum class Editability { ReadOnly, CanEditPlainText, CanEditRichly };
332     enum class ShouldUpdateStyle { Update, DoNotUpdate };
333     WEBCORE_EXPORT Editability computeEditability(UserSelectAllTreatment, ShouldUpdateStyle) const;
334 
335     WEBCORE_EXPORT LayoutRect renderRect(bool* isReplaced);
336     IntRect pixelSnappedRenderRect(bool* isReplaced) { return snappedIntRect(renderRect(isReplaced)); }
337 
338     WEBCORE_EXPORT unsigned computeNodeIndex() const;
339 
340     // Returns the DOM ownerDocument attribute. This method never returns null, except in the case
341     // of a Document node.
342     WEBCORE_EXPORT Document* ownerDocument() const;
343 
344     // Returns the document associated with this node.
345     // A Document node returns itself.
346     Document&amp; document() const
347     {
348         return treeScope().documentScope();
349     }
350 
351     TreeScope&amp; treeScope() const
352     {
353         ASSERT(m_treeScope);
354         return *m_treeScope;
355     }
356     void setTreeScopeRecursively(TreeScope&amp;);
357     static ptrdiff_t treeScopeMemoryOffset() { return OBJECT_OFFSETOF(Node, m_treeScope); }
358 
359     // Returns true if this node is associated with a document and is in its associated document&#39;s
360     // node tree, false otherwise (https://dom.spec.whatwg.org/#connected).
361     bool isConnected() const
362     {
363         return getFlag(IsConnectedFlag);
364     }
365     bool isInUserAgentShadowTree() const;
366     bool isInShadowTree() const { return getFlag(IsInShadowTreeFlag); }
367     bool isInTreeScope() const { return getFlag(static_cast&lt;NodeFlags&gt;(IsConnectedFlag | IsInShadowTreeFlag)); }
368 
369     bool isDocumentTypeNode() const { return nodeType() == DOCUMENT_TYPE_NODE; }
370     virtual bool childTypeAllowed(NodeType) const { return false; }
371     unsigned countChildNodes() const;
372     Node* traverseToChildAt(unsigned) const;
373 
<a name="6" id="anc6"></a><span class="line-modified">374     ExceptionOr&lt;void&gt; checkSetPrefix(const AtomString&amp; prefix);</span>
375 
376     WEBCORE_EXPORT bool isDescendantOf(const Node&amp;) const;
377     bool isDescendantOf(const Node* other) const { return other &amp;&amp; isDescendantOf(*other); }
378 
379     bool isDescendantOrShadowDescendantOf(const Node*) const;
380     WEBCORE_EXPORT bool contains(const Node*) const;
381     bool containsIncludingShadowDOM(const Node*) const;
382 
383     // Number of DOM 16-bit units contained in node. Note that rendered text length can be different - e.g. because of
384     // css-transform:capitalize breaking up precomposed characters and ligatures.
385     virtual int maxCharacterOffset() const;
386 
387     // Whether or not a selection can be started in this object
388     virtual bool canStartSelection() const;
389 
390     virtual bool shouldSelectOnMouseDown() { return false; }
391 
392     // Getting points into and out of screen space
393     FloatPoint convertToPage(const FloatPoint&amp;) const;
394     FloatPoint convertFromPage(const FloatPoint&amp;) const;
395 
396     // -----------------------------------------------------------------------------
397     // Integration with rendering tree
398 
399     // As renderer() includes a branch you should avoid calling it repeatedly in hot code paths.
<a name="7" id="anc7"></a><span class="line-modified">400     RenderObject* renderer() const { return m_rendererWithStyleFlags.pointer(); }</span>
<span class="line-modified">401     void setRenderer(RenderObject*); // Defined in RenderObject.h</span>






402 
403     // Use these two methods with caution.
404     WEBCORE_EXPORT RenderBox* renderBox() const;
405     RenderBoxModelObject* renderBoxModelObject() const;
406 
407     // Wrapper for nodes that don&#39;t have a renderer, but still cache the style (like HTMLOptionElement).
408     const RenderStyle* renderStyle() const;
409 
410     virtual const RenderStyle* computedStyle(PseudoId pseudoElementSpecifier = PseudoId::None);
411 
412     enum class InsertedIntoAncestorResult {
413         Done,
414         NeedsPostInsertionCallback,
415     };
416 
417     struct InsertionType {
418         bool connectedToDocument { false };
419         bool treeScopeChanged { false };
420     };
421     // Called *after* this node or its ancestor is inserted into a new parent (may or may not be a part of document) by scripts or parser.
422     // insertedInto **MUST NOT** invoke scripts. Return NeedsPostInsertionCallback and implement didFinishInsertingNode instead to run scripts.
423     virtual InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp; parentOfInsertedTree);
424     virtual void didFinishInsertingNode() { }
425 
426     struct RemovalType {
427         bool disconnectedFromDocument { false };
428         bool treeScopeChanged { false };
429     };
430     virtual void removedFromAncestor(RemovalType, ContainerNode&amp; oldParentOfRemovedTree);
431 
432 #if ENABLE(TREE_DEBUGGING)
433     virtual void formatForDebugger(char* buffer, unsigned length) const;
434 
435     void showNode(const char* prefix = &quot;&quot;) const;
436     void showTreeForThis() const;
437     void showNodePathForThis() const;
438     void showTreeAndMark(const Node* markedNode1, const char* markedLabel1, const Node* markedNode2 = nullptr, const char* markedLabel2 = nullptr) const;
439     void showTreeForThisAcrossFrame() const;
440 #endif // ENABLE(TREE_DEBUGGING)
441 
442     void invalidateNodeListAndCollectionCachesInAncestors();
443     void invalidateNodeListAndCollectionCachesInAncestorsForAttribute(const QualifiedName&amp; attrName);
444     NodeListsNodeData* nodeLists();
445     void clearNodeLists();
446 
447     virtual bool willRespondToMouseMoveEvents();
448     virtual bool willRespondToMouseClickEvents();
449     virtual bool willRespondToMouseWheelEvents();
450 
451     WEBCORE_EXPORT unsigned short compareDocumentPosition(Node&amp;);
452 
453     EventTargetInterface eventTargetInterface() const override;
454     ScriptExecutionContext* scriptExecutionContext() const final; // Implemented in Document.h
455 
<a name="8" id="anc8"></a><span class="line-modified">456     WEBCORE_EXPORT bool addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) override;</span>
<span class="line-modified">457     bool removeEventListener(const AtomString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) override;</span>
458 
459     using EventTarget::dispatchEvent;
460     void dispatchEvent(Event&amp;) override;
461 
462     void dispatchScopedEvent(Event&amp;);
463 
464     virtual void handleLocalEvents(Event&amp;, EventInvokePhase);
465 
466     void dispatchSubtreeModifiedEvent();
467     void dispatchDOMActivateEvent(Event&amp; underlyingClickEvent);
468 
469 #if ENABLE(TOUCH_EVENTS)
470     virtual bool allowsDoubleTapGesture() const { return true; }
471 #endif
472 
473     bool dispatchBeforeLoadEvent(const String&amp; sourceURL);
474 
475     WEBCORE_EXPORT void dispatchInputEvent();
476 
477     // Perform the default action for an event.
478     virtual void defaultEventHandler(Event&amp;);
479 
480     void ref();
481     void deref();
482     bool hasOneRef() const;
<a name="9" id="anc9"></a><span class="line-modified">483     unsigned refCount() const;</span>
484 
485 #ifndef NDEBUG
486     bool m_deletionHasBegun { false };
487     bool m_inRemovedLastRefFunction { false };
488     bool m_adoptionIsRequired { true };
489 #endif
490 
491     EventTargetData* eventTargetData() final;
492     EventTargetData* eventTargetDataConcurrently() final;
493     EventTargetData&amp; ensureEventTargetData() final;
494 
495     HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; registeredMutationObservers(MutationObserver::MutationType, const QualifiedName* attributeName);
<a name="10" id="anc10"></a><span class="line-modified">496     void registerMutationObserver(MutationObserver&amp;, MutationObserverOptions, const HashSet&lt;AtomString&gt;&amp; attributeFilter);</span>
497     void unregisterMutationObserver(MutationObserverRegistration&amp;);
498     void registerTransientMutationObserver(MutationObserverRegistration&amp;);
499     void unregisterTransientMutationObserver(MutationObserverRegistration&amp;);
500     void notifyMutationObserversNodeWillDetach();
501 
502     WEBCORE_EXPORT void textRects(Vector&lt;IntRect&gt;&amp;) const;
503 
504     unsigned connectedSubframeCount() const;
505     void incrementConnectedSubframeCount(unsigned amount = 1);
506     void decrementConnectedSubframeCount(unsigned amount = 1);
507     void updateAncestorConnectedSubframeCountForRemoval() const;
508     void updateAncestorConnectedSubframeCountForInsertion() const;
509 
510 #if ENABLE(JIT)
511     static ptrdiff_t nodeFlagsMemoryOffset() { return OBJECT_OFFSETOF(Node, m_nodeFlags); }
<a name="11" id="anc11"></a><span class="line-modified">512     static ptrdiff_t rareDataMemoryOffset() { return OBJECT_OFFSETOF(Node, m_rareData); }</span>
513     static int32_t flagIsText() { return IsTextFlag; }
514     static int32_t flagIsContainer() { return IsContainerFlag; }
515     static int32_t flagIsElement() { return IsElementFlag; }
516     static int32_t flagIsShadowRoot() { return IsShadowRootFlag; }
517     static int32_t flagIsHTML() { return IsHTMLFlag; }
518     static int32_t flagIsLink() { return IsLinkFlag; }
519     static int32_t flagHasFocusWithin() { return HasFocusWithin; }
<a name="12" id="anc12"></a>
520     static int32_t flagIsParsingChildrenFinished() { return IsParsingChildrenFinishedFlag; }
521     static int32_t flagChildrenAffectedByFirstChildRulesFlag() { return ChildrenAffectedByFirstChildRulesFlag; }
522     static int32_t flagChildrenAffectedByLastChildRulesFlag() { return ChildrenAffectedByLastChildRulesFlag; }
523 
524     static int32_t flagAffectsNextSiblingElementStyle() { return AffectsNextSiblingElementStyle; }
525     static int32_t flagStyleIsAffectedByPreviousSibling() { return StyleIsAffectedByPreviousSibling; }
526 #endif // ENABLE(JIT)
527 
528 protected:
529     enum NodeFlags {
530         IsTextFlag = 1,
531         IsContainerFlag = 1 &lt;&lt; 1,
532         IsElementFlag = 1 &lt;&lt; 2,
533         IsHTMLFlag = 1 &lt;&lt; 3,
534         IsSVGFlag = 1 &lt;&lt; 4,
535         IsMathMLFlag = 1 &lt;&lt; 5,
536         IsDocumentNodeFlag = 1 &lt;&lt; 6,
537         IsShadowRootFlag = 1 &lt;&lt; 7,
538         IsConnectedFlag = 1 &lt;&lt; 8,
539         IsInShadowTreeFlag = 1 &lt;&lt; 9,
<a name="13" id="anc13"></a><span class="line-modified">540         StyleAffectedByFocusWithinFlag = 1 &lt;&lt; 10,</span>
541         HasEventTargetDataFlag = 1 &lt;&lt; 11,
542 
543         // These bits are used by derived classes, pulled up here so they can
544         // be stored in the same memory word as the Node bits above.
545         ChildNeedsStyleRecalcFlag = 1 &lt;&lt; 12, // ContainerNode
546         DirectChildNeedsStyleRecalcFlag = 1 &lt;&lt; 13,
547 
548         IsEditingTextOrUndefinedCustomElementFlag = 1 &lt;&lt; 14, // Text and Element
549         IsCustomElement = 1 &lt;&lt; 15, // Element
550         HasFocusWithin = 1 &lt;&lt; 16,
551         IsLinkFlag = 1 &lt;&lt; 17,
552         IsUserActionElement = 1 &lt;&lt; 18,
553         IsParsingChildrenFinishedFlag = 1 &lt;&lt; 19,
554         HasSyntheticAttrChildNodesFlag = 1 &lt;&lt; 20,
555         SelfOrAncestorHasDirAutoFlag = 1 &lt;&lt; 21,
556 
557         // The following flags are used in style invalidation.
558         StyleValidityShift = 22,
559         StyleValidityMask = 3 &lt;&lt; StyleValidityShift,
560         StyleResolutionShouldRecompositeLayerFlag = 1 &lt;&lt; 24,
561 
562         ChildrenAffectedByFirstChildRulesFlag = 1 &lt;&lt; 25,
563         ChildrenAffectedByLastChildRulesFlag = 1 &lt;&lt; 26,
564         ChildrenAffectedByHoverRulesFlag = 1 &lt;&lt; 27,
565 
566         AffectsNextSiblingElementStyle = 1 &lt;&lt; 28,
567         StyleIsAffectedByPreviousSibling = 1 &lt;&lt; 29,
568         DescendantsAffectedByPreviousSiblingFlag = 1 &lt;&lt; 30,
569 
570         HasCustomStyleResolveCallbacksFlag = 1 &lt;&lt; 31,
571 
572         DefaultNodeFlags = IsParsingChildrenFinishedFlag
573     };
574 
575     bool getFlag(NodeFlags mask) const { return m_nodeFlags &amp; mask; }
576     void setFlag(bool f, NodeFlags mask) const { m_nodeFlags = (m_nodeFlags &amp; ~mask) | (-(int32_t)f &amp; mask); }
577     void setFlag(NodeFlags mask) const { m_nodeFlags |= mask; }
578     void clearFlag(NodeFlags mask) const { m_nodeFlags &amp;= ~mask; }
579 
580     bool isParsingChildrenFinished() const { return getFlag(IsParsingChildrenFinishedFlag); }
581     void setIsParsingChildrenFinished() { setFlag(IsParsingChildrenFinishedFlag); }
582     void clearIsParsingChildrenFinished() { clearFlag(IsParsingChildrenFinishedFlag); }
583 
584     enum ConstructionType {
585         CreateOther = DefaultNodeFlags,
586         CreateText = DefaultNodeFlags | IsTextFlag,
587         CreateContainer = DefaultNodeFlags | IsContainerFlag,
588         CreateElement = CreateContainer | IsElementFlag,
589         CreatePseudoElement =  CreateElement | IsConnectedFlag,
590         CreateShadowRoot = CreateContainer | IsShadowRootFlag | IsInShadowTreeFlag,
591         CreateDocumentFragment = CreateContainer,
592         CreateHTMLElement = CreateElement | IsHTMLFlag,
593         CreateSVGElement = CreateElement | IsSVGFlag | HasCustomStyleResolveCallbacksFlag,
594         CreateMathMLElement = CreateElement | IsMathMLFlag,
595         CreateDocument = CreateContainer | IsDocumentNodeFlag | IsConnectedFlag,
596         CreateEditingText = CreateText | IsEditingTextOrUndefinedCustomElementFlag,
597     };
598     Node(Document&amp;, ConstructionType);
599 
<a name="14" id="anc14"></a><span class="line-modified">600     static constexpr uint32_t s_refCountIncrement = 2;</span>
<span class="line-added">601     static constexpr uint32_t s_refCountMask = ~static_cast&lt;uint32_t&gt;(1);</span>
<span class="line-added">602 </span>
<span class="line-added">603     enum class ElementStyleFlag : uint8_t {</span>
<span class="line-added">604         StyleAffectedByActive = 1 &lt;&lt; 0,</span>
<span class="line-added">605         StyleAffectedByEmpty = 1 &lt;&lt; 1,</span>
<span class="line-added">606         ChildrenAffectedByDrag = 1 &lt;&lt; 2,</span>
<span class="line-added">607 </span>
<span class="line-added">608         // Bits for dynamic child matching.</span>
<span class="line-added">609         // We optimize for :first-child and :last-child. The other positional child selectors like nth-child or</span>
<span class="line-added">610         // *-child-of-type, we will just give up and re-evaluate whenever children change at all.</span>
<span class="line-added">611         ChildrenAffectedByForwardPositionalRules = 1 &lt;&lt; 3,</span>
<span class="line-added">612         DescendantsAffectedByForwardPositionalRules = 1 &lt;&lt; 4,</span>
<span class="line-added">613         ChildrenAffectedByBackwardPositionalRules = 1 &lt;&lt; 5,</span>
<span class="line-added">614         DescendantsAffectedByBackwardPositionalRules = 1 &lt;&lt; 6,</span>
<span class="line-added">615         ChildrenAffectedByPropertyBasedBackwardPositionalRules = 1 &lt;&lt; 7,</span>
<span class="line-added">616     };</span>
<span class="line-added">617 </span>
<span class="line-added">618     bool hasStyleFlag(ElementStyleFlag state) const { return m_rendererWithStyleFlags.type() &amp; static_cast&lt;uint8_t&gt;(state); }</span>
<span class="line-added">619     void setStyleFlag(ElementStyleFlag state) { m_rendererWithStyleFlags.setType(m_rendererWithStyleFlags.type() | static_cast&lt;uint8_t&gt;(state)); }</span>
<span class="line-added">620     void clearStyleFlags() { m_rendererWithStyleFlags.setType(0); }</span>
621 
<a name="15" id="anc15"></a><span class="line-modified">622     virtual void addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp;) const { }</span>
623 
<a name="16" id="anc16"></a><span class="line-modified">624     bool hasRareData() const { return !!m_rareData; }</span>
<span class="line-added">625     NodeRareData* rareData() const { return m_rareData.get(); }</span>
626     NodeRareData&amp; ensureRareData();
627     void clearRareData();
628 
629     void clearEventTargetData();
630 
631     void setHasCustomStyleResolveCallbacks() { setFlag(true, HasCustomStyleResolveCallbacksFlag); }
632 
633     void setTreeScope(TreeScope&amp; scope) { m_treeScope = &amp;scope; }
634 
635     void invalidateStyle(Style::Validity, Style::InvalidationMode = Style::InvalidationMode::Normal);
636     void updateAncestorsForStyleRecalc();
637 
638     ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; convertNodesOrStringsIntoNode(Vector&lt;NodeOrString&gt;&amp;&amp;);
639 
640 private:
641     virtual PseudoId customPseudoId() const
642     {
643         ASSERT(hasCustomStyleResolveCallbacks());
644         return PseudoId::None;
645     }
646 
647     WEBCORE_EXPORT void removedLastRef();
648 
649     void refEventTarget() final;
650     void derefEventTarget() final;
651     bool isNode() const final;
652 
653     void trackForDebugging();
654     void materializeRareData();
655 
656     Vector&lt;std::unique_ptr&lt;MutationObserverRegistration&gt;&gt;* mutationObserverRegistry();
657     HashSet&lt;MutationObserverRegistration*&gt;* transientMutationObserverRegistry();
658 
659     void adjustStyleValidity(Style::Validity, Style::InvalidationMode);
660 
661     void* opaqueRootSlow() const;
662 
663     static void moveShadowTreeToNewDocument(ShadowRoot&amp;, Document&amp; oldDocument, Document&amp; newDocument);
664     static void moveTreeToNewScope(Node&amp;, TreeScope&amp; oldScope, TreeScope&amp; newScope);
665     void moveNodeToNewDocument(Document&amp; oldDocument, Document&amp; newDocument);
666 
<a name="17" id="anc17"></a><span class="line-modified">667     struct NodeRareDataDeleter {</span>
<span class="line-added">668         void operator()(NodeRareData*) const;</span>
<span class="line-added">669     };</span>
<span class="line-added">670 </span>
<span class="line-added">671     uint32_t m_refCountAndParentBit { s_refCountIncrement };</span>
672     mutable uint32_t m_nodeFlags;
673 
674     ContainerNode* m_parentNode { nullptr };
675     TreeScope* m_treeScope { nullptr };
676     Node* m_previous { nullptr };
677     Node* m_next { nullptr };
<a name="18" id="anc18"></a><span class="line-modified">678     CompactPointerTuple&lt;RenderObject*, uint8_t&gt; m_rendererWithStyleFlags;</span>
<span class="line-modified">679     std::unique_ptr&lt;NodeRareData, NodeRareDataDeleter&gt; m_rareData;</span>



680 };
681 
682 #ifndef NDEBUG
683 inline void adopted(Node* node)
684 {
685     if (!node)
686         return;
687     ASSERT(!node-&gt;m_deletionHasBegun);
688     ASSERT(!node-&gt;m_inRemovedLastRefFunction);
689     node-&gt;m_adoptionIsRequired = false;
690 }
691 #endif
692 
693 ALWAYS_INLINE void Node::ref()
694 {
695     ASSERT(isMainThread());
696     ASSERT(!m_deletionHasBegun);
697     ASSERT(!m_inRemovedLastRefFunction);
698     ASSERT(!m_adoptionIsRequired);
<a name="19" id="anc19"></a><span class="line-modified">699     m_refCountAndParentBit += s_refCountIncrement;</span>
700 }
701 
702 ALWAYS_INLINE void Node::deref()
703 {
704     ASSERT(isMainThread());
<a name="20" id="anc20"></a><span class="line-modified">705     ASSERT(refCount());</span>
706     ASSERT(!m_deletionHasBegun);
707     ASSERT(!m_inRemovedLastRefFunction);
708     ASSERT(!m_adoptionIsRequired);
<a name="21" id="anc21"></a><span class="line-modified">709     auto updatedRefCount = m_refCountAndParentBit - s_refCountIncrement;</span>
<span class="line-added">710     if (!updatedRefCount) {</span>
<span class="line-added">711         // Don&#39;t update m_refCountAndParentBit to avoid double destruction through use of Ref&lt;T&gt;/RefPtr&lt;T&gt;.</span>
<span class="line-added">712         // (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)</span>
713 #ifndef NDEBUG
714         m_inRemovedLastRefFunction = true;
715 #endif
716         removedLastRef();
<a name="22" id="anc22"></a><span class="line-added">717         return;</span>
718     }
<a name="23" id="anc23"></a><span class="line-added">719     m_refCountAndParentBit = updatedRefCount;</span>
720 }
721 
722 ALWAYS_INLINE bool Node::hasOneRef() const
723 {
724     ASSERT(!m_deletionHasBegun);
725     ASSERT(!m_inRemovedLastRefFunction);
<a name="24" id="anc24"></a><span class="line-modified">726     return refCount() == 1;</span>
727 }
728 
<a name="25" id="anc25"></a><span class="line-modified">729 ALWAYS_INLINE unsigned Node::refCount() const</span>
730 {
<a name="26" id="anc26"></a><span class="line-modified">731     return m_refCountAndParentBit / s_refCountIncrement;</span>
732 }
733 
734 // Used in Node::addSubresourceAttributeURLs() and in addSubresourceStyleURLs()
735 inline void addSubresourceURL(ListHashSet&lt;URL&gt;&amp; urls, const URL&amp; url)
736 {
737     if (!url.isNull())
738         urls.add(url);
739 }
740 
741 inline void Node::setParentNode(ContainerNode* parent)
742 {
743     ASSERT(isMainThread());
744     m_parentNode = parent;
<a name="27" id="anc27"></a><span class="line-added">745     m_refCountAndParentBit = (m_refCountAndParentBit &amp; s_refCountMask) | !!parent;</span>
746 }
747 
748 inline ContainerNode* Node::parentNode() const
749 {
750     ASSERT(isMainThreadOrGCThread());
751     return m_parentNode;
752 }
753 
754 inline void* Node::opaqueRoot() const
755 {
756     // FIXME: Possible race?
757     // https://bugs.webkit.org/show_bug.cgi?id=165713
758     if (isConnected())
759         return &amp;document();
760     return opaqueRootSlow();
761 }
762 
763 inline ContainerNode* Node::parentNodeGuaranteedHostFree() const
764 {
765     ASSERT(!isShadowRoot());
766     return parentNode();
767 }
768 
769 inline Style::Validity Node::styleValidity() const
770 {
771     return static_cast&lt;Style::Validity&gt;((m_nodeFlags &amp; StyleValidityMask) &gt;&gt; StyleValidityShift);
772 }
773 
774 inline bool Node::styleResolutionShouldRecompositeLayer() const
775 {
776     return getFlag(StyleResolutionShouldRecompositeLayerFlag);
777 }
778 
779 inline void Node::setHasValidStyle()
780 {
781     m_nodeFlags &amp;= ~StyleValidityMask;
782     clearFlag(StyleResolutionShouldRecompositeLayerFlag);
783 }
784 
785 inline void Node::setTreeScopeRecursively(TreeScope&amp; newTreeScope)
786 {
787     ASSERT(!isDocumentNode());
788     ASSERT(!m_deletionHasBegun);
789     if (m_treeScope != &amp;newTreeScope)
790         moveTreeToNewScope(*this, *m_treeScope, newTreeScope);
791 }
792 
793 } // namespace WebCore
794 
795 #if ENABLE(TREE_DEBUGGING)
796 // Outside the WebCore namespace for ease of invocation from the debugger.
797 void showTree(const WebCore::Node*);
798 void showNodePath(const WebCore::Node*);
799 #endif
800 
801 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::Node)
802     static bool isType(const WebCore::EventTarget&amp; target) { return target.isNode(); }
803 SPECIALIZE_TYPE_TRAITS_END()
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>