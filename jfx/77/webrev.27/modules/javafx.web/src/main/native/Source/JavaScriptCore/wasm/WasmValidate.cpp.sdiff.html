<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmValidate.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmTierUpCount.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmWorklist.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmValidate.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmValidate.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 

 31 #include &quot;WasmFunctionParser.h&quot;
 32 #include &lt;wtf/CommaPrinter.h&gt;
 33 
 34 namespace JSC { namespace Wasm {
 35 
 36 class Validate {
 37 public:
 38     class ControlData {
 39     public:
 40         ControlData(BlockType type, Type signature)
 41             : m_blockType(type)
 42             , m_signature(signature)
 43         {
 44         }
 45 
 46         ControlData()
 47         {
 48         }
 49 
 50         void dump(PrintStream&amp; out) const
</pre>
<hr />
<pre>
 61                 break;
 62             case BlockType::TopLevel:
 63                 out.print(&quot;TopLevel: &quot;);
 64                 break;
 65             }
 66             out.print(makeString(signature()));
 67         }
 68 
 69         bool hasNonVoidSignature() const { return m_signature != Void; }
 70 
 71         BlockType type() const { return m_blockType; }
 72         Type signature() const { return m_signature; }
 73         Type branchTargetSignature() const { return type() == BlockType::Loop ? Void : signature(); }
 74     private:
 75         BlockType m_blockType;
 76         Type m_signature;
 77     };
 78     typedef String ErrorType;
 79     typedef Unexpected&lt;ErrorType&gt; UnexpectedResult;
 80     typedef Expected&lt;void, ErrorType&gt; Result;
<span class="line-modified"> 81     typedef Type ExpressionType;</span>


 82     typedef ControlData ControlType;
<span class="line-removed"> 83     typedef Vector&lt;ExpressionType, 1&gt; ExpressionList;</span>
 84     typedef FunctionParser&lt;Validate&gt;::ControlEntry ControlEntry;
 85 
 86     static constexpr ExpressionType emptyExpression() { return Void; }

 87 
 88     template &lt;typename ...Args&gt;
 89     NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN fail(Args... args) const
 90     {
 91         using namespace FailureHelper; // See ADL comment in WasmParser.h.
 92         return UnexpectedResult(makeString(&quot;WebAssembly.Module doesn&#39;t validate: &quot;_s, makeString(args)...));
 93     }
 94 #define WASM_VALIDATOR_FAIL_IF(condition, ...) do { \
 95         if (UNLIKELY(condition))                    \
 96         return fail(__VA_ARGS__);                   \
 97     } while (0)
 98 
 99     Result WARN_UNUSED_RETURN addArguments(const Signature&amp;);
100     Result WARN_UNUSED_RETURN addLocal(Type, uint32_t);
101     ExpressionType addConstant(Type type, uint64_t) { return type; }
102 










103     // Locals
104     Result WARN_UNUSED_RETURN getLocal(uint32_t index, ExpressionType&amp; result);
105     Result WARN_UNUSED_RETURN setLocal(uint32_t index, ExpressionType value);
106 
107     // Globals
108     Result WARN_UNUSED_RETURN getGlobal(uint32_t index, ExpressionType&amp; result);
109     Result WARN_UNUSED_RETURN setGlobal(uint32_t index, ExpressionType value);
110 
111     // Memory
112     Result WARN_UNUSED_RETURN load(LoadOpType, ExpressionType pointer, ExpressionType&amp; result, uint32_t offset);
113     Result WARN_UNUSED_RETURN store(StoreOpType, ExpressionType pointer, ExpressionType value, uint32_t offset);
114 
115     // Basic operators
116     template&lt;OpType&gt;
117     Result WARN_UNUSED_RETURN addOp(ExpressionType arg, ExpressionType&amp; result);
118     template&lt;OpType&gt;
119     Result WARN_UNUSED_RETURN addOp(ExpressionType left, ExpressionType right, ExpressionType&amp; result);
120     Result WARN_UNUSED_RETURN addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result);
121 
122     // Control flow
123     ControlData WARN_UNUSED_RETURN addTopLevel(Type signature);
124     ControlData WARN_UNUSED_RETURN addBlock(Type signature);
<span class="line-modified">125     ControlData WARN_UNUSED_RETURN addLoop(Type signature);</span>
126     Result WARN_UNUSED_RETURN addIf(ExpressionType condition, Type signature, ControlData&amp; result);
<span class="line-modified">127     Result WARN_UNUSED_RETURN addElse(ControlData&amp;, const ExpressionList&amp;);</span>
128     Result WARN_UNUSED_RETURN addElseToUnreachable(ControlData&amp;);
129 
<span class="line-modified">130     Result WARN_UNUSED_RETURN addReturn(ControlData&amp; topLevel, const ExpressionList&amp; returnValues);</span>
<span class="line-modified">131     Result WARN_UNUSED_RETURN addBranch(ControlData&amp;, ExpressionType condition, const ExpressionList&amp; expressionStack);</span>
<span class="line-modified">132     Result WARN_UNUSED_RETURN addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const ExpressionList&amp; expressionStack);</span>
<span class="line-modified">133     Result WARN_UNUSED_RETURN endBlock(ControlEntry&amp;, ExpressionList&amp; expressionStack);</span>
134     Result WARN_UNUSED_RETURN addEndToUnreachable(ControlEntry&amp;);
135     Result WARN_UNUSED_RETURN addGrowMemory(ExpressionType delta, ExpressionType&amp; result);
136     Result WARN_UNUSED_RETURN addCurrentMemory(ExpressionType&amp; result);
137 
138     Result WARN_UNUSED_RETURN addUnreachable() { return { }; }
139 
140     // Calls
141     Result WARN_UNUSED_RETURN addCall(unsigned calleeIndex, const Signature&amp;, const Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);
<span class="line-modified">142     Result WARN_UNUSED_RETURN addCallIndirect(const Signature&amp;, const Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);</span>
143 
144     ALWAYS_INLINE void didKill(ExpressionType) { }
145 
146     bool hasMemory() const { return !!m_module.memory; }
147 
148     Validate(const ModuleInformation&amp; module)
149         : m_module(module)
150     {
151     }
152 
<span class="line-modified">153     void dump(const Vector&lt;ControlEntry&gt;&amp;, const ExpressionList*);</span>
154     void setParser(FunctionParser&lt;Validate&gt;*) { }
155 
156 private:
<span class="line-modified">157     Result WARN_UNUSED_RETURN unify(const ExpressionList&amp;, const ControlData&amp;);</span>
158 
<span class="line-modified">159     Result WARN_UNUSED_RETURN checkBranchTarget(ControlData&amp; target, const ExpressionList&amp; expressionStack);</span>
160 
161     Vector&lt;Type&gt; m_locals;
162     const ModuleInformation&amp; m_module;
163 };
164 
165 auto Validate::addArguments(const Signature&amp; signature) -&gt; Result
166 {
167     for (size_t i = 0; i &lt; signature.argumentCount(); ++i)
168         WASM_FAIL_IF_HELPER_FAILS(addLocal(signature.argument(i), 1));
169     return { };
170 }
171 

































































172 auto Validate::addLocal(Type type, uint32_t count) -&gt; Result
173 {
<span class="line-modified">174     size_t size = m_locals.size() + count;</span>
<span class="line-modified">175     WASM_VALIDATOR_FAIL_IF(!m_locals.tryReserveCapacity(size), &quot;can&#39;t allocate memory for &quot;, size, &quot; locals&quot;);</span>


176 
177     for (uint32_t i = 0; i &lt; count; ++i)
178         m_locals.uncheckedAppend(type);
179     return { };
180 }
181 
182 auto Validate::getLocal(uint32_t index, ExpressionType&amp; result) -&gt; Result
183 {
184     WASM_VALIDATOR_FAIL_IF(index &gt;= m_locals.size(), &quot;attempt to use unknown local &quot;, index, &quot; last one is &quot;, m_locals.size());
185     result = m_locals[index];
186     return { };
187 }
188 
189 auto Validate::setLocal(uint32_t index, ExpressionType value) -&gt; Result
190 {
191     ExpressionType localType;
192     WASM_FAIL_IF_HELPER_FAILS(getLocal(index, localType));
<span class="line-modified">193     WASM_VALIDATOR_FAIL_IF(localType != value, &quot;set_local to type &quot;, value, &quot; expected &quot;, localType);</span>
194     return { };
195 }
196 
197 auto Validate::getGlobal(uint32_t index, ExpressionType&amp; result) -&gt; Result
198 {
199     WASM_VALIDATOR_FAIL_IF(index &gt;= m_module.globals.size(), &quot;get_global &quot;, index, &quot; of unknown global, limit is &quot;, m_module.globals.size());
200     result = m_module.globals[index].type;
201     ASSERT(isValueType(result));
202     return { };
203 }
204 
205 auto Validate::setGlobal(uint32_t index, ExpressionType value) -&gt; Result
206 {
207     WASM_VALIDATOR_FAIL_IF(index &gt;= m_module.globals.size(), &quot;set_global &quot;, index, &quot; of unknown global, limit is &quot;, m_module.globals.size());
208     WASM_VALIDATOR_FAIL_IF(m_module.globals[index].mutability == Global::Immutable, &quot;set_global &quot;, index, &quot; is immutable&quot;);
209 
210     ExpressionType globalType = m_module.globals[index].type;
211     ASSERT(isValueType(globalType));
212     WASM_VALIDATOR_FAIL_IF(globalType != value, &quot;set_global &quot;, index, &quot; with type &quot;, globalType, &quot; with a variable of type &quot;, value);
213     return { };
214 }
215 
216 Validate::ControlType Validate::addTopLevel(Type signature)
217 {
218     return ControlData(BlockType::TopLevel, signature);
219 }
220 
221 Validate::ControlType Validate::addBlock(Type signature)
222 {
223     return ControlData(BlockType::Block, signature);
224 }
225 
<span class="line-modified">226 Validate::ControlType Validate::addLoop(Type signature)</span>
227 {
228     return ControlData(BlockType::Loop, signature);
229 }
230 
231 auto Validate::addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result) -&gt; Result
232 {
233     WASM_VALIDATOR_FAIL_IF(condition != I32, &quot;select condition must be i32, got &quot;, condition);
234     WASM_VALIDATOR_FAIL_IF(nonZero != zero, &quot;select result types must match, got &quot;, nonZero, &quot; and &quot;, zero);
235     result = zero;
236     return { };
237 }
238 
239 auto Validate::addIf(ExpressionType condition, Type signature, ControlType&amp; result) -&gt; Result
240 {
241     WASM_VALIDATOR_FAIL_IF(condition != I32, &quot;if condition must be i32, got &quot;, condition);
242     result = ControlData(BlockType::If, signature);
243     return { };
244 }
245 
<span class="line-modified">246 auto Validate::addElse(ControlType&amp; current, const ExpressionList&amp; values) -&gt; Result</span>
247 {
248     WASM_FAIL_IF_HELPER_FAILS(unify(values, current));
249     return addElseToUnreachable(current);
250 }
251 
252 auto Validate::addElseToUnreachable(ControlType&amp; current) -&gt; Result
253 {
254     WASM_VALIDATOR_FAIL_IF(current.type() != BlockType::If, &quot;else block isn&#39;t associated to an if&quot;);
255     current = ControlData(BlockType::Block, current.signature());
256     return { };
257 }
258 
259 auto Validate::addReturn(ControlType&amp; topLevel, const ExpressionList&amp; returnValues) -&gt; Result
260 {
261     ASSERT(topLevel.type() == BlockType::TopLevel);
262     if (topLevel.signature() == Void)
263         return { };
264     ASSERT(returnValues.size() == 1);
265     WASM_VALIDATOR_FAIL_IF(topLevel.signature() != returnValues[0], &quot;return type &quot;, returnValues[0], &quot; doesn&#39;t match function&#39;s return type &quot;, topLevel.signature());
266     return { };
267 }
268 
<span class="line-modified">269 auto Validate::checkBranchTarget(ControlType&amp; target, const ExpressionList&amp; expressionStack) -&gt; Result</span>
270 {
271     if (target.branchTargetSignature() == Void)
272         return { };
273 
274     WASM_VALIDATOR_FAIL_IF(expressionStack.isEmpty(), target.type() == BlockType::TopLevel ? &quot;branch out of function&quot; : &quot;branch to block&quot;, &quot; on empty expression stack, but expected &quot;, target.signature());
275     WASM_VALIDATOR_FAIL_IF(target.branchTargetSignature() != expressionStack.last(), &quot;branch&#39;s stack type doesn&#39;t match block&#39;s type&quot;);
276 
277     return { };
278 }
279 
<span class="line-modified">280 auto Validate::addBranch(ControlType&amp; target, ExpressionType condition, const ExpressionList&amp; stack) -&gt; Result</span>
281 {
282     // Void means this is an unconditional branch.
283     WASM_VALIDATOR_FAIL_IF(condition != Void &amp;&amp; condition != I32, &quot;conditional branch with non-i32 condition &quot;, condition);
284     return checkBranchTarget(target, stack);
285 }
286 
<span class="line-modified">287 auto Validate::addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const ExpressionList&amp; expressionStack) -&gt; Result</span>
288 {
289     WASM_VALIDATOR_FAIL_IF(condition != I32, &quot;br_table with non-i32 condition &quot;, condition);
290 
291     for (auto target : targets)
292         WASM_VALIDATOR_FAIL_IF(defaultTarget.branchTargetSignature() != target-&gt;branchTargetSignature(), &quot;br_table target type mismatch&quot;);
293 
294     return checkBranchTarget(defaultTarget, expressionStack);
295 }
296 
297 auto Validate::addGrowMemory(ExpressionType delta, ExpressionType&amp; result) -&gt; Result
298 {
299     WASM_VALIDATOR_FAIL_IF(delta != I32, &quot;grow_memory with non-i32 delta&quot;);
300     result = I32;
301     return { };
302 }
303 
304 auto Validate::addCurrentMemory(ExpressionType&amp; result) -&gt; Result
305 {
306     result = I32;
307     return { };
308 }
309 
<span class="line-modified">310 auto Validate::endBlock(ControlEntry&amp; entry, ExpressionList&amp; stack) -&gt; Result</span>
311 {
312     WASM_FAIL_IF_HELPER_FAILS(unify(stack, entry.controlData));
313     return addEndToUnreachable(entry);
314 }
315 
316 auto Validate::addEndToUnreachable(ControlEntry&amp; entry) -&gt; Result
317 {
318     auto block = entry.controlData;
319     if (block.signature() != Void) {
320         WASM_VALIDATOR_FAIL_IF(block.type() == BlockType::If, &quot;If-block had a non-void result type: &quot;, block.signature(), &quot; but had no else-block&quot;);
321         entry.enclosedExpressionStack.append(block.signature());
322     }
323     return { };
324 }
325 
326 auto Validate::addCall(unsigned, const Signature&amp; signature, const Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; Result
327 {
328     WASM_VALIDATOR_FAIL_IF(signature.argumentCount() != args.size(), &quot;arity mismatch in call, got &quot;, args.size(), &quot; arguments, expected &quot;, signature.argumentCount());
329 
330     for (unsigned i = 0; i &lt; args.size(); ++i)
<span class="line-modified">331         WASM_VALIDATOR_FAIL_IF(args[i] != signature.argument(i), &quot;argument type mismatch in call, got &quot;, args[i], &quot;, expected &quot;, signature.argument(i));</span>
332 
333     result = signature.returnType();
334     return { };
335 }
336 
<span class="line-modified">337 auto Validate::addCallIndirect(const Signature&amp; signature, const Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; Result</span>
338 {


339     const auto argumentCount = signature.argumentCount();
340     WASM_VALIDATOR_FAIL_IF(argumentCount != args.size() - 1, &quot;arity mismatch in call_indirect, got &quot;, args.size() - 1, &quot; arguments, expected &quot;, argumentCount);
341 
342     for (unsigned i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">343         WASM_VALIDATOR_FAIL_IF(args[i] != signature.argument(i), &quot;argument type mismatch in call_indirect, got &quot;, args[i], &quot;, expected &quot;, signature.argument(i));</span>
344 
345     WASM_VALIDATOR_FAIL_IF(args.last() != I32, &quot;non-i32 call_indirect index &quot;, args.last());
346 
347     result = signature.returnType();
348     return { };
349 }
350 
<span class="line-modified">351 auto Validate::unify(const ExpressionList&amp; values, const ControlType&amp; block) -&gt; Result</span>
352 {
353     if (block.signature() == Void) {
354         WASM_VALIDATOR_FAIL_IF(!values.isEmpty(), &quot;void block should end with an empty stack&quot;);
355         return { };
356     }
357 
358     WASM_VALIDATOR_FAIL_IF(values.size() != 1, &quot;block with type: &quot;, block.signature(), &quot; ends with a stack containing more than one value&quot;);
<span class="line-modified">359     WASM_VALIDATOR_FAIL_IF(values[0] != block.signature(), &quot;control flow returns with unexpected type&quot;);</span>
360     return { };
361 }
362 
<span class="line-modified">363 static void dumpExpressionStack(const CommaPrinter&amp; comma, const Validate::ExpressionList&amp; expressionStack)</span>
364 {
365     dataLog(comma, &quot; ExpressionStack:&quot;);
366     for (const auto&amp; expression : expressionStack)
367         dataLog(comma, makeString(expression));
368 }
369 
<span class="line-modified">370 void Validate::dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const ExpressionList* expressionStack)</span>
371 {
372     for (size_t i = controlStack.size(); i--;) {
373         dataLog(&quot;  &quot;, controlStack[i].controlData);
374         CommaPrinter comma(&quot;, &quot;, &quot;&quot;);
375         dumpExpressionStack(comma, *expressionStack);
376         expressionStack = &amp;controlStack[i].enclosedExpressionStack;
377         dataLogLn();
378     }
379     dataLogLn();
380 }
381 
382 Expected&lt;void, String&gt; validateFunction(const uint8_t* source, size_t length, const Signature&amp; signature, const ModuleInformation&amp; module)
383 {
384     Validate context(module);
385     FunctionParser&lt;Validate&gt; validator(context, source, length, signature, module);
386     WASM_FAIL_IF_HELPER_FAILS(validator.parse());
387     return { };
388 }
389 
390 } } // namespace JSC::Wasm
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmValidate.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
<span class="line-added"> 31 #include &quot;JSCJSValueInlines.h&quot;</span>
 32 #include &quot;WasmFunctionParser.h&quot;
 33 #include &lt;wtf/CommaPrinter.h&gt;
 34 
 35 namespace JSC { namespace Wasm {
 36 
 37 class Validate {
 38 public:
 39     class ControlData {
 40     public:
 41         ControlData(BlockType type, Type signature)
 42             : m_blockType(type)
 43             , m_signature(signature)
 44         {
 45         }
 46 
 47         ControlData()
 48         {
 49         }
 50 
 51         void dump(PrintStream&amp; out) const
</pre>
<hr />
<pre>
 62                 break;
 63             case BlockType::TopLevel:
 64                 out.print(&quot;TopLevel: &quot;);
 65                 break;
 66             }
 67             out.print(makeString(signature()));
 68         }
 69 
 70         bool hasNonVoidSignature() const { return m_signature != Void; }
 71 
 72         BlockType type() const { return m_blockType; }
 73         Type signature() const { return m_signature; }
 74         Type branchTargetSignature() const { return type() == BlockType::Loop ? Void : signature(); }
 75     private:
 76         BlockType m_blockType;
 77         Type m_signature;
 78     };
 79     typedef String ErrorType;
 80     typedef Unexpected&lt;ErrorType&gt; UnexpectedResult;
 81     typedef Expected&lt;void, ErrorType&gt; Result;
<span class="line-modified"> 82     using ExpressionType = Type;</span>
<span class="line-added"> 83     using ExpressionList = Vector&lt;ExpressionType, 1&gt;;</span>
<span class="line-added"> 84     using Stack = ExpressionList;</span>
 85     typedef ControlData ControlType;

 86     typedef FunctionParser&lt;Validate&gt;::ControlEntry ControlEntry;
 87 
 88     static constexpr ExpressionType emptyExpression() { return Void; }
<span class="line-added"> 89     Stack createStack() { return Stack(); }</span>
 90 
 91     template &lt;typename ...Args&gt;
 92     NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN fail(Args... args) const
 93     {
 94         using namespace FailureHelper; // See ADL comment in WasmParser.h.
 95         return UnexpectedResult(makeString(&quot;WebAssembly.Module doesn&#39;t validate: &quot;_s, makeString(args)...));
 96     }
 97 #define WASM_VALIDATOR_FAIL_IF(condition, ...) do { \
 98         if (UNLIKELY(condition))                    \
 99         return fail(__VA_ARGS__);                   \
100     } while (0)
101 
102     Result WARN_UNUSED_RETURN addArguments(const Signature&amp;);
103     Result WARN_UNUSED_RETURN addLocal(Type, uint32_t);
104     ExpressionType addConstant(Type type, uint64_t) { return type; }
105 
<span class="line-added">106     // References</span>
<span class="line-added">107     Result WARN_UNUSED_RETURN addRefIsNull(ExpressionType&amp; value, ExpressionType&amp; result);</span>
<span class="line-added">108     Result WARN_UNUSED_RETURN addRefFunc(uint32_t index, ExpressionType&amp; result);</span>
<span class="line-added">109 </span>
<span class="line-added">110     // Tables</span>
<span class="line-added">111     Result WARN_UNUSED_RETURN addTableGet(unsigned, ExpressionType&amp; index, ExpressionType&amp; result);</span>
<span class="line-added">112     Result WARN_UNUSED_RETURN addTableSet(unsigned, ExpressionType&amp; index, ExpressionType&amp; value);</span>
<span class="line-added">113     Result WARN_UNUSED_RETURN addTableSize(unsigned, ExpressionType&amp; result);</span>
<span class="line-added">114     Result WARN_UNUSED_RETURN addTableGrow(unsigned, ExpressionType&amp; fill, ExpressionType&amp; delta, ExpressionType&amp; result);</span>
<span class="line-added">115     Result WARN_UNUSED_RETURN addTableFill(unsigned, ExpressionType&amp; offset, ExpressionType&amp; fill, ExpressionType&amp; count);</span>
116     // Locals
117     Result WARN_UNUSED_RETURN getLocal(uint32_t index, ExpressionType&amp; result);
118     Result WARN_UNUSED_RETURN setLocal(uint32_t index, ExpressionType value);
119 
120     // Globals
121     Result WARN_UNUSED_RETURN getGlobal(uint32_t index, ExpressionType&amp; result);
122     Result WARN_UNUSED_RETURN setGlobal(uint32_t index, ExpressionType value);
123 
124     // Memory
125     Result WARN_UNUSED_RETURN load(LoadOpType, ExpressionType pointer, ExpressionType&amp; result, uint32_t offset);
126     Result WARN_UNUSED_RETURN store(StoreOpType, ExpressionType pointer, ExpressionType value, uint32_t offset);
127 
128     // Basic operators
129     template&lt;OpType&gt;
130     Result WARN_UNUSED_RETURN addOp(ExpressionType arg, ExpressionType&amp; result);
131     template&lt;OpType&gt;
132     Result WARN_UNUSED_RETURN addOp(ExpressionType left, ExpressionType right, ExpressionType&amp; result);
133     Result WARN_UNUSED_RETURN addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result);
134 
135     // Control flow
136     ControlData WARN_UNUSED_RETURN addTopLevel(Type signature);
137     ControlData WARN_UNUSED_RETURN addBlock(Type signature);
<span class="line-modified">138     ControlData WARN_UNUSED_RETURN addLoop(Type signature, const Stack&amp;, uint32_t);</span>
139     Result WARN_UNUSED_RETURN addIf(ExpressionType condition, Type signature, ControlData&amp; result);
<span class="line-modified">140     Result WARN_UNUSED_RETURN addElse(ControlData&amp;, const Stack&amp;);</span>
141     Result WARN_UNUSED_RETURN addElseToUnreachable(ControlData&amp;);
142 
<span class="line-modified">143     Result WARN_UNUSED_RETURN addReturn(ControlData&amp; topLevel, const Stack&amp; returnValues);</span>
<span class="line-modified">144     Result WARN_UNUSED_RETURN addBranch(ControlData&amp;, ExpressionType condition, const Stack&amp; expressionStack);</span>
<span class="line-modified">145     Result WARN_UNUSED_RETURN addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const Stack&amp; expressionStack);</span>
<span class="line-modified">146     Result WARN_UNUSED_RETURN endBlock(ControlEntry&amp;, Stack&amp; expressionStack);</span>
147     Result WARN_UNUSED_RETURN addEndToUnreachable(ControlEntry&amp;);
148     Result WARN_UNUSED_RETURN addGrowMemory(ExpressionType delta, ExpressionType&amp; result);
149     Result WARN_UNUSED_RETURN addCurrentMemory(ExpressionType&amp; result);
150 
151     Result WARN_UNUSED_RETURN addUnreachable() { return { }; }
152 
153     // Calls
154     Result WARN_UNUSED_RETURN addCall(unsigned calleeIndex, const Signature&amp;, const Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);
<span class="line-modified">155     Result WARN_UNUSED_RETURN addCallIndirect(unsigned tableIndex, const Signature&amp;, const Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);</span>
156 
157     ALWAYS_INLINE void didKill(ExpressionType) { }
158 
159     bool hasMemory() const { return !!m_module.memory; }
160 
161     Validate(const ModuleInformation&amp; module)
162         : m_module(module)
163     {
164     }
165 
<span class="line-modified">166     void dump(const Vector&lt;ControlEntry&gt;&amp;, const Stack*);</span>
167     void setParser(FunctionParser&lt;Validate&gt;*) { }
168 
169 private:
<span class="line-modified">170     Result WARN_UNUSED_RETURN unify(const Stack&amp;, const ControlData&amp;);</span>
171 
<span class="line-modified">172     Result WARN_UNUSED_RETURN checkBranchTarget(ControlData&amp; target, const Stack&amp; expressionStack);</span>
173 
174     Vector&lt;Type&gt; m_locals;
175     const ModuleInformation&amp; m_module;
176 };
177 
178 auto Validate::addArguments(const Signature&amp; signature) -&gt; Result
179 {
180     for (size_t i = 0; i &lt; signature.argumentCount(); ++i)
181         WASM_FAIL_IF_HELPER_FAILS(addLocal(signature.argument(i), 1));
182     return { };
183 }
184 
<span class="line-added">185 auto Validate::addTableGet(unsigned tableIndex, ExpressionType&amp; index, ExpressionType&amp; result) -&gt; Result</span>
<span class="line-added">186 {</span>
<span class="line-added">187     WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_module.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_module.tableCount());</span>
<span class="line-added">188     result = m_module.tables[tableIndex].wasmType();</span>
<span class="line-added">189     WASM_VALIDATOR_FAIL_IF(Type::I32 != index, &quot;table.get index to type &quot;, index, &quot; expected &quot;, Type::I32);</span>
<span class="line-added">190 </span>
<span class="line-added">191     return { };</span>
<span class="line-added">192 }</span>
<span class="line-added">193 </span>
<span class="line-added">194 auto Validate::addTableSet(unsigned tableIndex, ExpressionType&amp; index, ExpressionType&amp; value) -&gt; Result</span>
<span class="line-added">195 {</span>
<span class="line-added">196     WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_module.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_module.tableCount());</span>
<span class="line-added">197     auto type = m_module.tables[tableIndex].wasmType();</span>
<span class="line-added">198     WASM_VALIDATOR_FAIL_IF(Type::I32 != index, &quot;table.set index to type &quot;, index, &quot; expected &quot;, Type::I32);</span>
<span class="line-added">199     WASM_VALIDATOR_FAIL_IF(!isSubtype(value, type), &quot;table.set value to type &quot;, value, &quot; expected &quot;, type);</span>
<span class="line-added">200     RELEASE_ASSERT(m_module.tables[tableIndex].type() == TableElementType::Anyref || m_module.tables[tableIndex].type() == TableElementType::Funcref);</span>
<span class="line-added">201 </span>
<span class="line-added">202     return { };</span>
<span class="line-added">203 }</span>
<span class="line-added">204 </span>
<span class="line-added">205 auto Validate::addTableSize(unsigned tableIndex, ExpressionType&amp; result) -&gt; Result</span>
<span class="line-added">206 {</span>
<span class="line-added">207     result = Type::I32;</span>
<span class="line-added">208     WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_module.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_module.tableCount());</span>
<span class="line-added">209 </span>
<span class="line-added">210     return { };</span>
<span class="line-added">211 }</span>
<span class="line-added">212 </span>
<span class="line-added">213 auto Validate::addTableGrow(unsigned tableIndex, ExpressionType&amp; fill, ExpressionType&amp; delta, ExpressionType&amp; result) -&gt; Result</span>
<span class="line-added">214 {</span>
<span class="line-added">215     result = Type::I32;</span>
<span class="line-added">216     WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_module.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_module.tableCount());</span>
<span class="line-added">217     WASM_VALIDATOR_FAIL_IF(!isSubtype(fill, m_module.tables[tableIndex].wasmType()), &quot;table.grow expects fill value of type &quot;, m_module.tables[tableIndex].wasmType(), &quot; got &quot;, fill);</span>
<span class="line-added">218     WASM_VALIDATOR_FAIL_IF(Type::I32 != delta, &quot;table.grow expects an i32 delta value, got &quot;, delta);</span>
<span class="line-added">219 </span>
<span class="line-added">220     return { };</span>
<span class="line-added">221 }</span>
<span class="line-added">222 </span>
<span class="line-added">223 auto Validate::addTableFill(unsigned tableIndex, ExpressionType&amp; offset, ExpressionType&amp; fill, ExpressionType&amp; count) -&gt; Result</span>
<span class="line-added">224 {</span>
<span class="line-added">225     WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_module.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_module.tableCount());</span>
<span class="line-added">226     WASM_VALIDATOR_FAIL_IF(!isSubtype(fill, m_module.tables[tableIndex].wasmType()), &quot;table.fill expects fill value of type &quot;, m_module.tables[tableIndex].wasmType(), &quot; got &quot;, fill);</span>
<span class="line-added">227     WASM_VALIDATOR_FAIL_IF(Type::I32 != offset, &quot;table.fill expects an i32 offset value, got &quot;, offset);</span>
<span class="line-added">228     WASM_VALIDATOR_FAIL_IF(Type::I32 != count, &quot;table.fill expects an i32 count value, got &quot;, count);</span>
<span class="line-added">229 </span>
<span class="line-added">230     return { };</span>
<span class="line-added">231 }</span>
<span class="line-added">232 </span>
<span class="line-added">233 auto Validate::addRefIsNull(ExpressionType&amp; value, ExpressionType&amp; result) -&gt; Result</span>
<span class="line-added">234 {</span>
<span class="line-added">235     result = Type::I32;</span>
<span class="line-added">236     WASM_VALIDATOR_FAIL_IF(!isSubtype(value, Type::Anyref), &quot;ref.is_null to type &quot;, value, &quot; expected &quot;, Type::Anyref);</span>
<span class="line-added">237 </span>
<span class="line-added">238     return { };</span>
<span class="line-added">239 }</span>
<span class="line-added">240 </span>
<span class="line-added">241 auto Validate::addRefFunc(uint32_t index, ExpressionType&amp; result) -&gt; Result</span>
<span class="line-added">242 {</span>
<span class="line-added">243     result = Type::Funcref;</span>
<span class="line-added">244     WASM_VALIDATOR_FAIL_IF(index &gt;= m_module.functionIndexSpaceSize(), &quot;ref.func index &quot;, index, &quot; is too large, max is &quot;, m_module.functionIndexSpaceSize());</span>
<span class="line-added">245     m_module.addReferencedFunction(index);</span>
<span class="line-added">246 </span>
<span class="line-added">247     return { };</span>
<span class="line-added">248 }</span>
<span class="line-added">249 </span>
250 auto Validate::addLocal(Type type, uint32_t count) -&gt; Result
251 {
<span class="line-modified">252     size_t newSize = m_locals.size() + count;</span>
<span class="line-modified">253     ASSERT(!(CheckedUint32(count) + m_locals.size()).hasOverflowed());</span>
<span class="line-added">254     ASSERT(newSize &lt;= maxFunctionLocals);</span>
<span class="line-added">255     WASM_VALIDATOR_FAIL_IF(!m_locals.tryReserveCapacity(newSize), &quot;can&#39;t allocate memory for &quot;, newSize, &quot; locals&quot;);</span>
256 
257     for (uint32_t i = 0; i &lt; count; ++i)
258         m_locals.uncheckedAppend(type);
259     return { };
260 }
261 
262 auto Validate::getLocal(uint32_t index, ExpressionType&amp; result) -&gt; Result
263 {
264     WASM_VALIDATOR_FAIL_IF(index &gt;= m_locals.size(), &quot;attempt to use unknown local &quot;, index, &quot; last one is &quot;, m_locals.size());
265     result = m_locals[index];
266     return { };
267 }
268 
269 auto Validate::setLocal(uint32_t index, ExpressionType value) -&gt; Result
270 {
271     ExpressionType localType;
272     WASM_FAIL_IF_HELPER_FAILS(getLocal(index, localType));
<span class="line-modified">273     WASM_VALIDATOR_FAIL_IF(!isSubtype(value, localType), &quot;set_local to type &quot;, value, &quot; expected &quot;, localType);</span>
274     return { };
275 }
276 
277 auto Validate::getGlobal(uint32_t index, ExpressionType&amp; result) -&gt; Result
278 {
279     WASM_VALIDATOR_FAIL_IF(index &gt;= m_module.globals.size(), &quot;get_global &quot;, index, &quot; of unknown global, limit is &quot;, m_module.globals.size());
280     result = m_module.globals[index].type;
281     ASSERT(isValueType(result));
282     return { };
283 }
284 
285 auto Validate::setGlobal(uint32_t index, ExpressionType value) -&gt; Result
286 {
287     WASM_VALIDATOR_FAIL_IF(index &gt;= m_module.globals.size(), &quot;set_global &quot;, index, &quot; of unknown global, limit is &quot;, m_module.globals.size());
288     WASM_VALIDATOR_FAIL_IF(m_module.globals[index].mutability == Global::Immutable, &quot;set_global &quot;, index, &quot; is immutable&quot;);
289 
290     ExpressionType globalType = m_module.globals[index].type;
291     ASSERT(isValueType(globalType));
292     WASM_VALIDATOR_FAIL_IF(globalType != value, &quot;set_global &quot;, index, &quot; with type &quot;, globalType, &quot; with a variable of type &quot;, value);
293     return { };
294 }
295 
296 Validate::ControlType Validate::addTopLevel(Type signature)
297 {
298     return ControlData(BlockType::TopLevel, signature);
299 }
300 
301 Validate::ControlType Validate::addBlock(Type signature)
302 {
303     return ControlData(BlockType::Block, signature);
304 }
305 
<span class="line-modified">306 Validate::ControlType Validate::addLoop(Type signature, const Stack&amp;, uint32_t)</span>
307 {
308     return ControlData(BlockType::Loop, signature);
309 }
310 
311 auto Validate::addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result) -&gt; Result
312 {
313     WASM_VALIDATOR_FAIL_IF(condition != I32, &quot;select condition must be i32, got &quot;, condition);
314     WASM_VALIDATOR_FAIL_IF(nonZero != zero, &quot;select result types must match, got &quot;, nonZero, &quot; and &quot;, zero);
315     result = zero;
316     return { };
317 }
318 
319 auto Validate::addIf(ExpressionType condition, Type signature, ControlType&amp; result) -&gt; Result
320 {
321     WASM_VALIDATOR_FAIL_IF(condition != I32, &quot;if condition must be i32, got &quot;, condition);
322     result = ControlData(BlockType::If, signature);
323     return { };
324 }
325 
<span class="line-modified">326 auto Validate::addElse(ControlType&amp; current, const Stack&amp; values) -&gt; Result</span>
327 {
328     WASM_FAIL_IF_HELPER_FAILS(unify(values, current));
329     return addElseToUnreachable(current);
330 }
331 
332 auto Validate::addElseToUnreachable(ControlType&amp; current) -&gt; Result
333 {
334     WASM_VALIDATOR_FAIL_IF(current.type() != BlockType::If, &quot;else block isn&#39;t associated to an if&quot;);
335     current = ControlData(BlockType::Block, current.signature());
336     return { };
337 }
338 
339 auto Validate::addReturn(ControlType&amp; topLevel, const ExpressionList&amp; returnValues) -&gt; Result
340 {
341     ASSERT(topLevel.type() == BlockType::TopLevel);
342     if (topLevel.signature() == Void)
343         return { };
344     ASSERT(returnValues.size() == 1);
345     WASM_VALIDATOR_FAIL_IF(topLevel.signature() != returnValues[0], &quot;return type &quot;, returnValues[0], &quot; doesn&#39;t match function&#39;s return type &quot;, topLevel.signature());
346     return { };
347 }
348 
<span class="line-modified">349 auto Validate::checkBranchTarget(ControlType&amp; target, const Stack&amp; expressionStack) -&gt; Result</span>
350 {
351     if (target.branchTargetSignature() == Void)
352         return { };
353 
354     WASM_VALIDATOR_FAIL_IF(expressionStack.isEmpty(), target.type() == BlockType::TopLevel ? &quot;branch out of function&quot; : &quot;branch to block&quot;, &quot; on empty expression stack, but expected &quot;, target.signature());
355     WASM_VALIDATOR_FAIL_IF(target.branchTargetSignature() != expressionStack.last(), &quot;branch&#39;s stack type doesn&#39;t match block&#39;s type&quot;);
356 
357     return { };
358 }
359 
<span class="line-modified">360 auto Validate::addBranch(ControlType&amp; target, ExpressionType condition, const Stack&amp; stack) -&gt; Result</span>
361 {
362     // Void means this is an unconditional branch.
363     WASM_VALIDATOR_FAIL_IF(condition != Void &amp;&amp; condition != I32, &quot;conditional branch with non-i32 condition &quot;, condition);
364     return checkBranchTarget(target, stack);
365 }
366 
<span class="line-modified">367 auto Validate::addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const Stack&amp; expressionStack) -&gt; Result</span>
368 {
369     WASM_VALIDATOR_FAIL_IF(condition != I32, &quot;br_table with non-i32 condition &quot;, condition);
370 
371     for (auto target : targets)
372         WASM_VALIDATOR_FAIL_IF(defaultTarget.branchTargetSignature() != target-&gt;branchTargetSignature(), &quot;br_table target type mismatch&quot;);
373 
374     return checkBranchTarget(defaultTarget, expressionStack);
375 }
376 
377 auto Validate::addGrowMemory(ExpressionType delta, ExpressionType&amp; result) -&gt; Result
378 {
379     WASM_VALIDATOR_FAIL_IF(delta != I32, &quot;grow_memory with non-i32 delta&quot;);
380     result = I32;
381     return { };
382 }
383 
384 auto Validate::addCurrentMemory(ExpressionType&amp; result) -&gt; Result
385 {
386     result = I32;
387     return { };
388 }
389 
<span class="line-modified">390 auto Validate::endBlock(ControlEntry&amp; entry, Stack&amp; stack) -&gt; Result</span>
391 {
392     WASM_FAIL_IF_HELPER_FAILS(unify(stack, entry.controlData));
393     return addEndToUnreachable(entry);
394 }
395 
396 auto Validate::addEndToUnreachable(ControlEntry&amp; entry) -&gt; Result
397 {
398     auto block = entry.controlData;
399     if (block.signature() != Void) {
400         WASM_VALIDATOR_FAIL_IF(block.type() == BlockType::If, &quot;If-block had a non-void result type: &quot;, block.signature(), &quot; but had no else-block&quot;);
401         entry.enclosedExpressionStack.append(block.signature());
402     }
403     return { };
404 }
405 
406 auto Validate::addCall(unsigned, const Signature&amp; signature, const Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; Result
407 {
408     WASM_VALIDATOR_FAIL_IF(signature.argumentCount() != args.size(), &quot;arity mismatch in call, got &quot;, args.size(), &quot; arguments, expected &quot;, signature.argumentCount());
409 
410     for (unsigned i = 0; i &lt; args.size(); ++i)
<span class="line-modified">411         WASM_VALIDATOR_FAIL_IF(!isSubtype(args[i], signature.argument(i)), &quot;argument type mismatch in call, got &quot;, args[i], &quot;, expected &quot;, signature.argument(i));</span>
412 
413     result = signature.returnType();
414     return { };
415 }
416 
<span class="line-modified">417 auto Validate::addCallIndirect(unsigned tableIndex, const Signature&amp; signature, const Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; Result</span>
418 {
<span class="line-added">419     RELEASE_ASSERT(tableIndex &lt; m_module.tableCount());</span>
<span class="line-added">420     RELEASE_ASSERT(m_module.tables[tableIndex].type() == TableElementType::Funcref);</span>
421     const auto argumentCount = signature.argumentCount();
422     WASM_VALIDATOR_FAIL_IF(argumentCount != args.size() - 1, &quot;arity mismatch in call_indirect, got &quot;, args.size() - 1, &quot; arguments, expected &quot;, argumentCount);
423 
424     for (unsigned i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">425         WASM_VALIDATOR_FAIL_IF(!isSubtype(args[i], signature.argument(i)), &quot;argument type mismatch in call_indirect, got &quot;, args[i], &quot;, expected &quot;, signature.argument(i));</span>
426 
427     WASM_VALIDATOR_FAIL_IF(args.last() != I32, &quot;non-i32 call_indirect index &quot;, args.last());
428 
429     result = signature.returnType();
430     return { };
431 }
432 
<span class="line-modified">433 auto Validate::unify(const Stack&amp; values, const ControlType&amp; block) -&gt; Result</span>
434 {
435     if (block.signature() == Void) {
436         WASM_VALIDATOR_FAIL_IF(!values.isEmpty(), &quot;void block should end with an empty stack&quot;);
437         return { };
438     }
439 
440     WASM_VALIDATOR_FAIL_IF(values.size() != 1, &quot;block with type: &quot;, block.signature(), &quot; ends with a stack containing more than one value&quot;);
<span class="line-modified">441     WASM_VALIDATOR_FAIL_IF(!isSubtype(values[0], block.signature()), &quot;control flow returns with unexpected type&quot;);</span>
442     return { };
443 }
444 
<span class="line-modified">445 static void dumpExpressionStack(const CommaPrinter&amp; comma, const Validate::Stack&amp; expressionStack)</span>
446 {
447     dataLog(comma, &quot; ExpressionStack:&quot;);
448     for (const auto&amp; expression : expressionStack)
449         dataLog(comma, makeString(expression));
450 }
451 
<span class="line-modified">452 void Validate::dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const Stack* expressionStack)</span>
453 {
454     for (size_t i = controlStack.size(); i--;) {
455         dataLog(&quot;  &quot;, controlStack[i].controlData);
456         CommaPrinter comma(&quot;, &quot;, &quot;&quot;);
457         dumpExpressionStack(comma, *expressionStack);
458         expressionStack = &amp;controlStack[i].enclosedExpressionStack;
459         dataLogLn();
460     }
461     dataLogLn();
462 }
463 
464 Expected&lt;void, String&gt; validateFunction(const uint8_t* source, size_t length, const Signature&amp; signature, const ModuleInformation&amp; module)
465 {
466     Validate context(module);
467     FunctionParser&lt;Validate&gt; validator(context, source, length, signature, module);
468     WASM_FAIL_IF_HELPER_FAILS(validator.parse());
469     return { };
470 }
471 
472 } } // namespace JSC::Wasm
</pre>
</td>
</tr>
</table>
<center><a href="WasmTierUpCount.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmWorklist.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>