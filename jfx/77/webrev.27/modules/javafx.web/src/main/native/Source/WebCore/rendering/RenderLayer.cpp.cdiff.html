<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderInline.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 266,13 ***</span>
<span class="line-new-header">--- 266,28 ---</span>
      if (!has3DRendering)
          matrix.makeAffine();
  #endif
  }
  
<span class="line-added">+ #if !LOG_DISABLED</span>
<span class="line-added">+ static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipRects&amp; clipRects)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     TextStream::GroupScope scope(ts);</span>
<span class="line-added">+     ts &lt;&lt; indent &lt;&lt; &quot;ClipRects\n&quot;;</span>
<span class="line-added">+     ts &lt;&lt; indent &lt;&lt; &quot;  overflow  : &quot; &lt;&lt; clipRects.overflowClipRect() &lt;&lt; &quot;\n&quot;;</span>
<span class="line-added">+     ts &lt;&lt; indent &lt;&lt; &quot;  fixed     : &quot; &lt;&lt; clipRects.fixedClipRect() &lt;&lt; &quot;\n&quot;;</span>
<span class="line-added">+     ts &lt;&lt; indent &lt;&lt; &quot;  positioned: &quot; &lt;&lt; clipRects.posClipRect() &lt;&lt; &quot;\n&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return ts;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  RenderLayer::RenderLayer(RenderLayerModelObject&amp; rendererLayerModelObject)
      : m_isRenderViewLayer(rendererLayerModelObject.isRenderView())
      , m_forcedStackingContext(rendererLayerModelObject.isMedia())
<span class="line-added">+     , m_isOpportunisticStackingContext(false)</span>
      , m_zOrderListsDirty(false)
      , m_normalFlowListDirty(true)
      , m_hadNegativeZOrderList(false)
      , m_inResizeMode(false)
      , m_scrollDimensionsDirty(true)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,24 ***</span>
      , m_hasVisibleContent(false)
      , m_visibleDescendantStatusDirty(false)
      , m_hasVisibleDescendant(false)
      , m_registeredScrollableArea(false)
      , m_isFixedIntersectingViewport(false)
      , m_3DTransformedDescendantStatusDirty(true)
      , m_has3DTransformedDescendant(false)
      , m_hasCompositingDescendant(false)
      , m_hasTransformedAncestor(false)
      , m_has3DTransformedAncestor(false)
      , m_indirectCompositingReason(static_cast&lt;unsigned&gt;(IndirectCompositingReason::None))
      , m_viewportConstrainedNotCompositedReason(NoNotCompositedReason)
  #if PLATFORM(IOS_FAMILY)
  #if ENABLE(IOS_TOUCH_EVENTS)
      , m_registeredAsTouchEventListenerForScrolling(false)
  #endif
      , m_adjustForIOSCaretWhenScrolling(false)
  #endif
<span class="line-removed">-     , m_inUserScroll(false)</span>
      , m_requiresScrollPositionReconciliation(false)
      , m_containsDirtyOverlayScrollbars(false)
      , m_updatingMarqueePosition(false)
  #if !ASSERT_DISABLED
      , m_layerListMutationAllowed(true)
<span class="line-new-header">--- 301,26 ---</span>
      , m_hasVisibleContent(false)
      , m_visibleDescendantStatusDirty(false)
      , m_hasVisibleDescendant(false)
      , m_registeredScrollableArea(false)
      , m_isFixedIntersectingViewport(false)
<span class="line-added">+     , m_behavesAsFixed(false)</span>
      , m_3DTransformedDescendantStatusDirty(true)
      , m_has3DTransformedDescendant(false)
      , m_hasCompositingDescendant(false)
<span class="line-added">+     , m_hasCompositedScrollingAncestor(false)</span>
<span class="line-added">+     , m_hasCompositedScrollableOverflow(false)</span>
      , m_hasTransformedAncestor(false)
      , m_has3DTransformedAncestor(false)
      , m_indirectCompositingReason(static_cast&lt;unsigned&gt;(IndirectCompositingReason::None))
      , m_viewportConstrainedNotCompositedReason(NoNotCompositedReason)
  #if PLATFORM(IOS_FAMILY)
  #if ENABLE(IOS_TOUCH_EVENTS)
      , m_registeredAsTouchEventListenerForScrolling(false)
  #endif
      , m_adjustForIOSCaretWhenScrolling(false)
  #endif
      , m_requiresScrollPositionReconciliation(false)
      , m_containsDirtyOverlayScrollbars(false)
      , m_updatingMarqueePosition(false)
  #if !ASSERT_DISABLED
      , m_layerListMutationAllowed(true)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 315,11 ***</span>
      , m_hasNotIsolatedBlendingDescendantsStatusDirty(false)
  #endif
      , m_renderer(rendererLayerModelObject)
  {
      setIsNormalFlowOnly(shouldBeNormalFlowOnly());
<span class="line-modified">!     setIsStackingContext(shouldBeStackingContext());</span>
  
      m_isSelfPaintingLayer = shouldBeSelfPaintingLayer();
  
      if (!renderer().firstChild()) {
          m_visibleContentStatusDirty = false;
<span class="line-new-header">--- 332,11 ---</span>
      , m_hasNotIsolatedBlendingDescendantsStatusDirty(false)
  #endif
      , m_renderer(rendererLayerModelObject)
  {
      setIsNormalFlowOnly(shouldBeNormalFlowOnly());
<span class="line-modified">!     setIsCSSStackingContext(shouldBeCSSStackingContext());</span>
  
      m_isSelfPaintingLayer = shouldBeSelfPaintingLayer();
  
      if (!renderer().firstChild()) {
          m_visibleContentStatusDirty = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 363,10 ***</span>
<span class="line-new-header">--- 380,16 ---</span>
      clearScrollCorner();
      clearResizer();
  
      clearLayerFilters();
  
<span class="line-added">+     if (paintsIntoProvidedBacking()) {</span>
<span class="line-added">+         auto* backingProviderLayer = this-&gt;backingProviderLayer();</span>
<span class="line-added">+         if (backingProviderLayer-&gt;backing())</span>
<span class="line-added">+             backingProviderLayer-&gt;backing()-&gt;removeBackingSharingLayer(*this);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // Child layers will be deleted by their corresponding render objects, so
      // we don&#39;t need to delete them ourselves.
  
      clearBacking(true);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 558,13 ***</span>
          || (renderer().isRenderImage() &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage())
          || (renderer().style().specifiesColumns() &amp;&amp; !isRenderViewLayer())
          || renderer().isInFlowRenderFragmentedFlow();
  }
  
<span class="line-modified">! bool RenderLayer::shouldBeStackingContext() const</span>
  {
<span class="line-modified">!     return !renderer().style().hasAutoZIndex() || isRenderViewLayer() || isForcedStackingContext();</span>
  }
  
  bool RenderLayer::setIsNormalFlowOnly(bool isNormalFlowOnly)
  {
      if (isNormalFlowOnly == m_isNormalFlowOnly)
<span class="line-new-header">--- 581,13 ---</span>
          || (renderer().isRenderImage() &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage())
          || (renderer().style().specifiesColumns() &amp;&amp; !isRenderViewLayer())
          || renderer().isInFlowRenderFragmentedFlow();
  }
  
<span class="line-modified">! bool RenderLayer::shouldBeCSSStackingContext() const</span>
  {
<span class="line-modified">!     return !renderer().style().hasAutoZIndex() || isRenderViewLayer();</span>
  }
  
  bool RenderLayer::setIsNormalFlowOnly(bool isNormalFlowOnly)
  {
      if (isNormalFlowOnly == m_isNormalFlowOnly)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 576,23 ***</span>
          p-&gt;dirtyNormalFlowList();
      dirtyStackingContextZOrderLists();
      return true;
  }
  
<span class="line-modified">! bool RenderLayer::setIsStackingContext(bool isStackingContext)</span>
  {
<span class="line-removed">-     if (isStackingContext == m_isStackingContext)</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_isStackingContext = isStackingContext;</span>
<span class="line-removed">- </span>
      dirtyStackingContextZOrderLists();
<span class="line-modified">!     if (isStackingContext)</span>
          dirtyZOrderLists();
      else
          clearZOrderLists();
  
      return true;
  }
  
  void RenderLayer::setParent(RenderLayer* parent)
  {
<span class="line-new-header">--- 599,38 ---</span>
          p-&gt;dirtyNormalFlowList();
      dirtyStackingContextZOrderLists();
      return true;
  }
  
<span class="line-modified">! void RenderLayer::isStackingContextChanged()</span>
  {
      dirtyStackingContextZOrderLists();
<span class="line-modified">!     if (isStackingContext())</span>
          dirtyZOrderLists();
      else
          clearZOrderLists();
<span class="line-added">+ }</span>
  
<span class="line-added">+ bool RenderLayer::setIsOpportunisticStackingContext(bool isStacking)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     bool wasStacking = isStackingContext();</span>
<span class="line-added">+     m_isOpportunisticStackingContext = isStacking;</span>
<span class="line-added">+     if (wasStacking == isStackingContext())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     isStackingContextChanged();</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool RenderLayer::setIsCSSStackingContext(bool isCSSStackingContext)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     bool wasStacking = isStackingContext();</span>
<span class="line-added">+     m_isCSSStackingContext = isCSSStackingContext;</span>
<span class="line-added">+     if (wasStacking == isStackingContext())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     isStackingContextChanged();</span>
      return true;
  }
  
  void RenderLayer::setParent(RenderLayer* parent)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 661,11 ***</span>
  
      for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
          // Ignore non-overflow layers and reflections.
          if (child-&gt;isNormalFlowOnly() &amp;&amp; !isReflectionLayer(*child)) {
              if (!m_normalFlowList)
<span class="line-modified">!                 m_normalFlowList = std::make_unique&lt;Vector&lt;RenderLayer*&gt;&gt;();</span>
              m_normalFlowList-&gt;append(child);
          }
      }
  
      m_normalFlowListDirty = false;
<span class="line-new-header">--- 699,11 ---</span>
  
      for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
          // Ignore non-overflow layers and reflections.
          if (child-&gt;isNormalFlowOnly() &amp;&amp; !isReflectionLayer(*child)) {
              if (!m_normalFlowList)
<span class="line-modified">!                 m_normalFlowList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();</span>
              m_normalFlowList-&gt;append(child);
          }
      }
  
      m_normalFlowListDirty = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 717,11 ***</span>
      // Overflow layers are just painted by their enclosing layers, so they don&#39;t get put in zorder lists.
      bool includeHiddenLayer = includeHiddenLayers || (m_hasVisibleContent || (m_hasVisibleDescendant &amp;&amp; isStacking));
      if (includeHiddenLayer &amp;&amp; !isNormalFlowOnly()) {
          auto&amp; layerList = (zIndex() &gt;= 0) ? positiveZOrderList : negativeZOrderList;
          if (!layerList)
<span class="line-modified">!             layerList = std::make_unique&lt;Vector&lt;RenderLayer*&gt;&gt;();</span>
          layerList-&gt;append(this);
      }
  
      // Recur into our children to collect more layers, but only if we don&#39;t establish
      // a stacking context/container.
<span class="line-new-header">--- 755,11 ---</span>
      // Overflow layers are just painted by their enclosing layers, so they don&#39;t get put in zorder lists.
      bool includeHiddenLayer = includeHiddenLayers || (m_hasVisibleContent || (m_hasVisibleDescendant &amp;&amp; isStacking));
      if (includeHiddenLayer &amp;&amp; !isNormalFlowOnly()) {
          auto&amp; layerList = (zIndex() &gt;= 0) ? positiveZOrderList : negativeZOrderList;
          if (!layerList)
<span class="line-modified">!             layerList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();</span>
          layerList-&gt;append(this);
      }
  
      // Recur into our children to collect more layers, but only if we don&#39;t establish
      // a stacking context/container.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 835,25 ***</span>
          return false;
  
      return m_filters &amp;&amp; m_filters-&gt;hasFilterThatMovesPixels();
  }
  
<span class="line-modified">! void RenderLayer::updateLayerPositionsAfterLayout(const RenderLayer* rootLayer, OptionSet&lt;UpdateLayerPositionsFlag&gt; flags)</span>
  {
      LOG(Compositing, &quot;RenderLayer %p updateLayerPositionsAfterLayout&quot;, this);
      RenderGeometryMap geometryMap(UseTransforms);
<span class="line-modified">!     if (this != rootLayer)</span>
          geometryMap.pushMappingsToAncestor(parent(), nullptr);
<span class="line-modified">!     updateLayerPositions(&amp;geometryMap, flags);</span>
  }
  
  void RenderLayer::updateLayerPositions(RenderGeometryMap* geometryMap, OptionSet&lt;UpdateLayerPositionsFlag&gt; flags)
  {
<span class="line-modified">!     updateLayerPosition(); // For relpositioned layers or non-positioned layers,</span>
<span class="line-removed">-                            // we need to keep in sync, since we may have shifted relative</span>
<span class="line-removed">-                            // to our parent layer.</span>
<span class="line-removed">- </span>
      applyPostLayoutScrollPositionIfNeeded();
  
      if (geometryMap)
          geometryMap-&gt;pushMappingsToAncestor(this, parent());
  
<span class="line-new-header">--- 873,60 ---</span>
          return false;
  
      return m_filters &amp;&amp; m_filters-&gt;hasFilterThatMovesPixels();
  }
  
<span class="line-modified">! OptionSet&lt;RenderLayer::UpdateLayerPositionsFlag&gt; RenderLayer::flagsForUpdateLayerPositions(RenderLayer&amp; startingLayer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     OptionSet&lt;UpdateLayerPositionsFlag&gt; flags = { CheckForRepaint };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (auto* parent = startingLayer.parent()) {</span>
<span class="line-added">+         if (parent-&gt;hasTransformedAncestor() || parent-&gt;transform())</span>
<span class="line-added">+             flags.add(SeenTransformedLayer);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (parent-&gt;has3DTransformedAncestor() || (parent-&gt;transform() &amp;&amp; !parent-&gt;transform()-&gt;isAffine()))</span>
<span class="line-added">+             flags.add(Seen3DTransformedLayer);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (parent-&gt;behavesAsFixed() || (parent-&gt;renderer().isFixedPositioned() &amp;&amp; !parent-&gt;hasTransformedAncestor()))</span>
<span class="line-added">+             flags.add(SeenFixedLayer);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (parent-&gt;hasCompositedScrollingAncestor() || parent-&gt;hasCompositedScrollableOverflow())</span>
<span class="line-added">+             flags.add(SeenCompositedScrollingLayer);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return flags;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RenderLayer::updateLayerPositionsAfterStyleChange()</span>
  {
<span class="line-added">+     updateLayerPositions(nullptr, flagsForUpdateLayerPositions(*this));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RenderLayer::updateLayerPositionsAfterLayout(bool isRelayoutingSubtree, bool didFullRepaint)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto updateLayerPositionFlags = [&amp;](bool isRelayoutingSubtree, bool didFullRepaint) {</span>
<span class="line-added">+         auto flags = flagsForUpdateLayerPositions(*this);</span>
<span class="line-added">+         if (didFullRepaint) {</span>
<span class="line-added">+             flags.remove(RenderLayer::CheckForRepaint);</span>
<span class="line-added">+             flags.add(RenderLayer::NeedsFullRepaintInBacking);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (isRelayoutingSubtree &amp;&amp; enclosingPaginationLayer(RenderLayer::IncludeCompositedPaginatedLayers))</span>
<span class="line-added">+             flags.add(RenderLayer::UpdatePagination);</span>
<span class="line-added">+         return flags;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
      LOG(Compositing, &quot;RenderLayer %p updateLayerPositionsAfterLayout&quot;, this);
      RenderGeometryMap geometryMap(UseTransforms);
<span class="line-modified">!     if (!isRenderViewLayer())</span>
          geometryMap.pushMappingsToAncestor(parent(), nullptr);
<span class="line-modified">! </span>
<span class="line-added">+     updateLayerPositions(&amp;geometryMap, updateLayerPositionFlags(isRelayoutingSubtree, didFullRepaint));</span>
  }
  
  void RenderLayer::updateLayerPositions(RenderGeometryMap* geometryMap, OptionSet&lt;UpdateLayerPositionsFlag&gt; flags)
  {
<span class="line-modified">!     updateLayerPosition(&amp;flags);</span>
      applyPostLayoutScrollPositionIfNeeded();
  
      if (geometryMap)
          geometryMap-&gt;pushMappingsToAncestor(this, parent());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 864,11 ***</span>
          LayoutSize offsetFromRoot;
          if (geometryMap)
              offsetFromRoot = LayoutSize(toFloatSize(geometryMap-&gt;absolutePoint(FloatPoint())));
          else {
              // FIXME: It looks suspicious to call convertToLayerCoords here
<span class="line-modified">!             // as canUseConvertToLayerCoords may be true for an ancestor layer.</span>
              offsetFromRoot = offsetFromAncestor(root());
          }
          positionOverflowControls(roundedIntSize(offsetFromRoot));
      }
  
<span class="line-new-header">--- 937,11 ---</span>
          LayoutSize offsetFromRoot;
          if (geometryMap)
              offsetFromRoot = LayoutSize(toFloatSize(geometryMap-&gt;absolutePoint(FloatPoint())));
          else {
              // FIXME: It looks suspicious to call convertToLayerCoords here
<span class="line-modified">!             // as canUseOffsetFromAncestor may be true for an ancestor layer.</span>
              offsetFromRoot = offsetFromAncestor(root());
          }
          positionOverflowControls(roundedIntSize(offsetFromRoot));
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 913,10 ***</span>
<span class="line-new-header">--- 986,12 ---</span>
          clearRepaintRects();
  
      m_repaintStatus = NeedsNormalRepaint;
      m_hasTransformedAncestor = flags.contains(SeenTransformedLayer);
      m_has3DTransformedAncestor = flags.contains(Seen3DTransformedLayer);
<span class="line-added">+     m_behavesAsFixed = flags.contains(SeenFixedLayer);</span>
<span class="line-added">+     setHasCompositedScrollingAncestor(flags.contains(SeenCompositedScrollingLayer));</span>
  
      // Update the reflection&#39;s position and size.
      if (m_reflection)
          m_reflection-&gt;layout();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 929,10 ***</span>
<span class="line-new-header">--- 1004,19 ---</span>
          flags.add(SeenTransformedLayer);
          if (!transform()-&gt;isAffine())
              flags.add(Seen3DTransformedLayer);
      }
  
<span class="line-added">+     // Fixed inside transform behaves like absolute (per spec).</span>
<span class="line-added">+     if (renderer().isFixedPositioned() &amp;&amp; !m_hasTransformedAncestor) {</span>
<span class="line-added">+         m_behavesAsFixed = true;</span>
<span class="line-added">+         flags.add(SeenFixedLayer);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (hasCompositedScrollableOverflow())</span>
<span class="line-added">+         flags.add(SeenCompositedScrollingLayer);</span>
<span class="line-added">+ </span>
      for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
          child-&gt;updateLayerPositions(geometryMap, flags);
  
      // With all our children positioned, now update our marquee if we need to.
      if (m_marquee) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 941,20 ***</span>
          m_updatingMarqueePosition = true;
          m_marquee-&gt;updateMarqueePosition();
          m_updatingMarqueePosition = oldUpdatingMarqueePosition;
      }
  
<span class="line-modified">!     if (renderer().isOutOfFlowPositioned() &amp;&amp; renderer().style().position() == PositionType::Fixed &amp;&amp; renderer().settings().acceleratedCompositingForFixedPositionEnabled()) {</span>
          bool intersectsViewport = compositor().fixedLayerIntersectsViewport(*this);
          if (intersectsViewport != m_isFixedIntersectingViewport) {
              m_isFixedIntersectingViewport = intersectsViewport;
              setNeedsPostLayoutCompositingUpdate();
          }
      }
  
      if (isComposited())
<span class="line-modified">!         backing()-&gt;updateAfterLayout(flags.contains(NeedsFullRepaintInBacking));</span>
  
      if (geometryMap)
          geometryMap-&gt;popMappingsToAncestor(parent());
  
      renderer().document().markers().invalidateRectsForAllMarkers();
<span class="line-new-header">--- 1025,20 ---</span>
          m_updatingMarqueePosition = true;
          m_marquee-&gt;updateMarqueePosition();
          m_updatingMarqueePosition = oldUpdatingMarqueePosition;
      }
  
<span class="line-modified">!     if (renderer().isFixedPositioned() &amp;&amp; renderer().settings().acceleratedCompositingForFixedPositionEnabled()) {</span>
          bool intersectsViewport = compositor().fixedLayerIntersectsViewport(*this);
          if (intersectsViewport != m_isFixedIntersectingViewport) {
              m_isFixedIntersectingViewport = intersectsViewport;
              setNeedsPostLayoutCompositingUpdate();
          }
      }
  
      if (isComposited())
<span class="line-modified">!         backing()-&gt;updateAfterLayout(flags.contains(ContainingClippingLayerChangedSize), flags.contains(NeedsFullRepaintInBacking));</span>
  
      if (geometryMap)
          geometryMap-&gt;popMappingsToAncestor(parent());
  
      renderer().document().markers().invalidateRectsForAllMarkers();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1122,21 ***</span>
      BlendMode newBlendMode = renderer().style().blendMode();
      if (newBlendMode != static_cast&lt;BlendMode&gt;(m_blendMode))
          m_blendMode = static_cast&lt;unsigned&gt;(newBlendMode);
  }
  
  void RenderLayer::updateAncestorChainHasBlendingDescendants()
  {
      for (auto* layer = this; layer; layer = layer-&gt;parent()) {
          if (!layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; layer-&gt;hasNotIsolatedBlendingDescendants())
              break;
          layer-&gt;m_hasNotIsolatedBlendingDescendants = true;
          layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = false;
  
          layer-&gt;updateSelfPaintingLayer();
  
<span class="line-modified">!         if (layer-&gt;isStackingContext())</span>
              break;
      }
  }
  
  void RenderLayer::dirtyAncestorChainHasBlendingDescendants()
<span class="line-new-header">--- 1206,26 ---</span>
      BlendMode newBlendMode = renderer().style().blendMode();
      if (newBlendMode != static_cast&lt;BlendMode&gt;(m_blendMode))
          m_blendMode = static_cast&lt;unsigned&gt;(newBlendMode);
  }
  
<span class="line-added">+ void RenderLayer::willRemoveChildWithBlendMode()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void RenderLayer::updateAncestorChainHasBlendingDescendants()
  {
      for (auto* layer = this; layer; layer = layer-&gt;parent()) {
          if (!layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; layer-&gt;hasNotIsolatedBlendingDescendants())
              break;
          layer-&gt;m_hasNotIsolatedBlendingDescendants = true;
          layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = false;
  
          layer-&gt;updateSelfPaintingLayer();
  
<span class="line-modified">!         if (layer-&gt;isCSSStackingContext())</span>
              break;
      }
  }
  
  void RenderLayer::dirtyAncestorChainHasBlendingDescendants()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1145,11 ***</span>
          if (layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty())
              break;
  
          layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = true;
  
<span class="line-modified">!         if (layer-&gt;isStackingContext())</span>
              break;
      }
  }
  #endif
  
<span class="line-new-header">--- 1234,11 ---</span>
          if (layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty())
              break;
  
          layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = true;
  
<span class="line-modified">!         if (layer-&gt;isCSSStackingContext())</span>
              break;
      }
  }
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1159,11 ***</span>
      bool had3DTransform = has3DTransform();
  
      bool hadTransform = !!m_transform;
      if (hasTransform != hadTransform) {
          if (hasTransform)
<span class="line-modified">!             m_transform = std::make_unique&lt;TransformationMatrix&gt;();</span>
          else
              m_transform = nullptr;
  
          // Layers with transforms act as clip rects roots, so clear the cached clip rects here.
          clearClipRectsIncludingDescendants();
<span class="line-new-header">--- 1248,11 ---</span>
      bool had3DTransform = has3DTransform();
  
      bool hadTransform = !!m_transform;
      if (hasTransform != hadTransform) {
          if (hasTransform)
<span class="line-modified">!             m_transform = makeUnique&lt;TransformationMatrix&gt;();</span>
          else
              m_transform = nullptr;
  
          // Layers with transforms act as clip rects roots, so clear the cached clip rects here.
          clearClipRectsIncludingDescendants();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1496,11 ***</span>
          return has3DTransform() || m_has3DTransformedDescendant;
  
      return has3DTransform();
  }
  
<span class="line-modified">! bool RenderLayer::updateLayerPosition()</span>
  {
      LayoutPoint localPoint;
      LayoutSize inlineBoundingBoxOffset; // We don&#39;t put this into the RenderLayer x/y for inlines, so we need to subtract it out when done.
      if (renderer().isInline() &amp;&amp; is&lt;RenderInline&gt;(renderer())) {
          auto&amp; inlineFlow = downcast&lt;RenderInline&gt;(renderer());
<span class="line-new-header">--- 1585,11 ---</span>
          return has3DTransform() || m_has3DTransformedDescendant;
  
      return has3DTransform();
  }
  
<span class="line-modified">! bool RenderLayer::updateLayerPosition(OptionSet&lt;UpdateLayerPositionsFlag&gt;* flags)</span>
  {
      LayoutPoint localPoint;
      LayoutSize inlineBoundingBoxOffset; // We don&#39;t put this into the RenderLayer x/y for inlines, so we need to subtract it out when done.
      if (renderer().isInline() &amp;&amp; is&lt;RenderInline&gt;(renderer())) {
          auto&amp; inlineFlow = downcast&lt;RenderInline&gt;(renderer());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1514,10 ***</span>
<span class="line-new-header">--- 1603,14 ---</span>
          if (newSize != size()) {
              if (is&lt;RenderWidget&gt;(*box) &amp;&amp; downcast&lt;RenderWidget&gt;(*box).requiresAcceleratedCompositing()) {
                  // Trigger RenderLayerCompositor::requiresCompositingForFrame() which depends on the contentBoxRect size.
                  setNeedsPostLayoutCompositingUpdate();
              }
<span class="line-added">+ </span>
<span class="line-added">+             if (flags &amp;&amp; renderer().hasOverflowClip())</span>
<span class="line-added">+                 flags-&gt;add(ContainingClippingLayerChangedSize);</span>
<span class="line-added">+ </span>
              setSize(newSize);
          }
  
          box-&gt;applyTopLeftLocationOffset(localPoint);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1640,35 ***</span>
          ASSERT_NOT_REACHED();
          return false;
      }
  }
  
  RenderLayer* RenderLayer::enclosingAncestorForPosition(PositionType position) const
  {
      RenderLayer* curr = parent();
      while (curr &amp;&amp; !isContainerForPositioned(*curr, position))
          curr = curr-&gt;parent();
  
      return curr;
  }
  
<span class="line-modified">! static RenderLayer* parentLayerCrossFrame(const RenderLayer&amp; layer)</span>
  {
<span class="line-modified">!     if (layer.parent())</span>
<span class="line-removed">-         return layer.parent();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     HTMLFrameOwnerElement* ownerElement = layer.renderer().document().ownerElement();</span>
      if (!ownerElement)
          return nullptr;
  
<span class="line-modified">!     RenderElement* ownerRenderer = ownerElement-&gt;renderer();</span>
      if (!ownerRenderer)
          return nullptr;
  
      return ownerRenderer-&gt;enclosingLayer();
  }
  
  RenderLayer* RenderLayer::enclosingScrollableLayer() const
  {
      for (RenderLayer* nextLayer = parentLayerCrossFrame(*this); nextLayer; nextLayer = parentLayerCrossFrame(*nextLayer)) {
          if (is&lt;RenderBox&gt;(nextLayer-&gt;renderer()) &amp;&amp; downcast&lt;RenderBox&gt;(nextLayer-&gt;renderer()).canBeScrolledAndHasScrollableArea())
              return nextLayer;
<span class="line-new-header">--- 1733,57 ---</span>
          ASSERT_NOT_REACHED();
          return false;
      }
  }
  
<span class="line-added">+ bool RenderLayer::ancestorLayerIsInContainingBlockChain(const RenderLayer&amp; ancestor, const RenderLayer* checkLimit) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (&amp;ancestor == this)</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (const auto* currentBlock = renderer().containingBlock(); currentBlock &amp;&amp; !is&lt;RenderView&gt;(*currentBlock); currentBlock = currentBlock-&gt;containingBlock()) {</span>
<span class="line-added">+         auto* currLayer = currentBlock-&gt;layer();</span>
<span class="line-added">+         if (currLayer == &amp;ancestor)</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (currLayer &amp;&amp; currLayer == checkLimit)</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  RenderLayer* RenderLayer::enclosingAncestorForPosition(PositionType position) const
  {
      RenderLayer* curr = parent();
      while (curr &amp;&amp; !isContainerForPositioned(*curr, position))
          curr = curr-&gt;parent();
  
      return curr;
  }
  
<span class="line-modified">! static RenderLayer* enclosingFrameRenderLayer(const RenderLayer&amp; layer)</span>
  {
<span class="line-modified">!     auto* ownerElement = layer.renderer().document().ownerElement();</span>
      if (!ownerElement)
          return nullptr;
  
<span class="line-modified">!     auto* ownerRenderer = ownerElement-&gt;renderer();</span>
      if (!ownerRenderer)
          return nullptr;
  
      return ownerRenderer-&gt;enclosingLayer();
  }
  
<span class="line-added">+ static RenderLayer* parentLayerCrossFrame(const RenderLayer&amp; layer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (auto* parent = layer.parent())</span>
<span class="line-added">+         return parent;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return enclosingFrameRenderLayer(layer);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  RenderLayer* RenderLayer::enclosingScrollableLayer() const
  {
      for (RenderLayer* nextLayer = parentLayerCrossFrame(*this); nextLayer; nextLayer = parentLayerCrossFrame(*nextLayer)) {
          if (is&lt;RenderBox&gt;(nextLayer-&gt;renderer()) &amp;&amp; downcast&lt;RenderBox&gt;(nextLayer-&gt;renderer()).canBeScrolledAndHasScrollableArea())
              return nextLayer;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1718,10 ***</span>
<span class="line-new-header">--- 1833,31 ---</span>
      // layout, don&#39;t need to be repainted. They just need to be recomposited.
      ASSERT(m_repaintStatus == NeedsFullRepaintForPositionedMovementLayout);
      return !isComposited() || backing()-&gt;paintsIntoCompositedAncestor();
  }
  
<span class="line-added">+ void RenderLayer::setBackingProviderLayer(RenderLayer* backingProvider)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (backingProvider == m_backingProviderLayer)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!renderer().renderTreeBeingDestroyed())</span>
<span class="line-added">+         clearClipRectsIncludingDescendants();</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_backingProviderLayer = makeWeakPtr(backingProvider);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RenderLayer::disconnectFromBackingProviderLayer()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_backingProviderLayer)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(m_backingProviderLayer-&gt;isComposited());</span>
<span class="line-added">+     if (m_backingProviderLayer-&gt;isComposited())</span>
<span class="line-added">+         m_backingProviderLayer-&gt;backing()-&gt;removeBackingSharingLayer(*this);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool compositedWithOwnBackingStore(const RenderLayer&amp; layer)
  {
      return layer.isComposited() &amp;&amp; !layer.backing()-&gt;paintsIntoCompositedAncestor();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1738,16 ***</span>
      return nullptr;
  }
  
  RenderLayer* RenderLayer::enclosingCompositingLayerForRepaint(IncludeSelfOrNot includeSelf) const
  {
<span class="line-modified">!     if (includeSelf == IncludeSelf &amp;&amp; compositedWithOwnBackingStore(*this))</span>
<span class="line-modified">!         return const_cast&lt;RenderLayer*&gt;(this);</span>
  
      for (const RenderLayer* curr = paintOrderParent(); curr; curr = curr-&gt;paintOrderParent()) {
<span class="line-modified">!         if (compositedWithOwnBackingStore(*curr))</span>
<span class="line-modified">!             return const_cast&lt;RenderLayer*&gt;(curr);</span>
      }
  
      return nullptr;
  }
  
<span class="line-new-header">--- 1874,27 ---</span>
      return nullptr;
  }
  
  RenderLayer* RenderLayer::enclosingCompositingLayerForRepaint(IncludeSelfOrNot includeSelf) const
  {
<span class="line-modified">!     auto repaintTargetForLayer = [](const RenderLayer&amp; layer) -&gt; RenderLayer* {</span>
<span class="line-modified">!         if (compositedWithOwnBackingStore(layer))</span>
<span class="line-added">+             return const_cast&lt;RenderLayer*&gt;(&amp;layer);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (layer.paintsIntoProvidedBacking())</span>
<span class="line-added">+             return layer.backingProviderLayer();</span>
<span class="line-added">+ </span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     RenderLayer* repaintTarget = nullptr;</span>
<span class="line-added">+     if (includeSelf == IncludeSelf &amp;&amp; (repaintTarget = repaintTargetForLayer(*this)))</span>
<span class="line-added">+         return repaintTarget;</span>
  
      for (const RenderLayer* curr = paintOrderParent(); curr; curr = curr-&gt;paintOrderParent()) {
<span class="line-modified">!         if ((repaintTarget = repaintTargetForLayer(*curr)))</span>
<span class="line-modified">!             return repaintTarget;</span>
      }
  
      return nullptr;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1825,19 ***</span>
<span class="line-new-header">--- 1972,25 ---</span>
  RenderLayer* RenderLayer::clippingRootForPainting() const
  {
      if (isComposited())
          return const_cast&lt;RenderLayer*&gt;(this);
  
<span class="line-added">+     if (paintsIntoProvidedBacking())</span>
<span class="line-added">+         return backingProviderLayer();</span>
<span class="line-added">+ </span>
      const RenderLayer* current = this;
      while (current) {
          if (current-&gt;isRenderViewLayer())
              return const_cast&lt;RenderLayer*&gt;(current);
  
          current = current-&gt;paintOrderParent();
          ASSERT(current);
          if (current-&gt;transform() || compositedWithOwnBackingStore(*current))
              return const_cast&lt;RenderLayer*&gt;(current);
<span class="line-added">+ </span>
<span class="line-added">+         if (current-&gt;paintsIntoProvidedBacking())</span>
<span class="line-added">+             return current-&gt;backingProviderLayer();</span>
      }
  
      ASSERT_NOT_REACHED();
      return nullptr;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1967,11 ***</span>
      RenderLayer* ancestor = transparentPaintingAncestor();
      if (ancestor)
          ancestor-&gt;beginTransparencyLayers(context, paintingInfo, dirtyRect);
  
      if (paintsWithTransparency(paintingInfo.paintBehavior)) {
<span class="line-modified">!         ASSERT(isStackingContext());</span>
          m_usedTransparency = true;
          context.save();
          LayoutRect adjustedClipRect = paintingExtent(*this, paintingInfo.rootLayer, dirtyRect, paintingInfo.paintBehavior);
          adjustedClipRect.move(paintingInfo.subpixelOffset);
          FloatRect pixelSnappedClipRect = snapRectToDevicePixels(adjustedClipRect, renderer().document().deviceScaleFactor());
<span class="line-new-header">--- 2120,11 ---</span>
      RenderLayer* ancestor = transparentPaintingAncestor();
      if (ancestor)
          ancestor-&gt;beginTransparencyLayers(context, paintingInfo, dirtyRect);
  
      if (paintsWithTransparency(paintingInfo.paintBehavior)) {
<span class="line-modified">!         ASSERT(isCSSStackingContext());</span>
          m_usedTransparency = true;
          context.save();
          LayoutRect adjustedClipRect = paintingExtent(*this, paintingInfo.rootLayer, dirtyRect, paintingInfo.paintBehavior);
          adjustedClipRect.move(paintingInfo.subpixelOffset);
          FloatRect pixelSnappedClipRect = snapRectToDevicePixels(adjustedClipRect, renderer().document().deviceScaleFactor());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2166,25 ***</span>
      return toLayoutSize(convertToLayerCoords(ancestorLayer, LayoutPoint(), adjustForColumns));
  }
  
  bool RenderLayer::canUseCompositedScrolling() const
  {
      if (renderer().settings().asyncOverflowScrollingEnabled())
<span class="line-modified">!         return scrollsOverflow();</span>
  
<span class="line-modified">! #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
<span class="line-modified">!     return scrollsOverflow() &amp;&amp; (renderer().style().useTouchOverflowScrolling() || renderer().settings().alwaysUseAcceleratedOverflowScroll());</span>
  #else
      return false;
  #endif
  }
  
<span class="line-removed">- bool RenderLayer::hasCompositedScrollableOverflow() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return canUseCompositedScrolling() &amp;&amp; (hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  #if ENABLE(IOS_TOUCH_EVENTS)
  bool RenderLayer::handleTouchEvent(const PlatformTouchEvent&amp; touchEvent)
  {
      // If we have accelerated scrolling, let the scrolling be handled outside of WebKit.
      if (hasCompositedScrollableOverflow())
<span class="line-new-header">--- 2319,21 ---</span>
      return toLayoutSize(convertToLayerCoords(ancestorLayer, LayoutPoint(), adjustForColumns));
  }
  
  bool RenderLayer::canUseCompositedScrolling() const
  {
<span class="line-added">+     bool isVisible = renderer().style().visibility() == Visibility::Visible;</span>
      if (renderer().settings().asyncOverflowScrollingEnabled())
<span class="line-modified">!         return isVisible &amp;&amp; scrollsOverflow();</span>
  
<span class="line-modified">! #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>
<span class="line-modified">!     return isVisible &amp;&amp; scrollsOverflow() &amp;&amp; (renderer().style().useTouchOverflowScrolling() || renderer().settings().alwaysUseAcceleratedOverflowScroll());</span>
  #else
      return false;
  #endif
  }
  
  #if ENABLE(IOS_TOUCH_EVENTS)
  bool RenderLayer::handleTouchEvent(const PlatformTouchEvent&amp; touchEvent)
  {
      // If we have accelerated scrolling, let the scrolling be handled outside of WebKit.
      if (hasCompositedScrollableOverflow())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2313,41 ***</span>
  
      scrollToOffset(scrollOffsetFromPosition(m_postLayoutScrollPosition.value()));
      m_postLayoutScrollPosition = WTF::nullopt;
  }
  
<span class="line-modified">! void RenderLayer::scrollToXPosition(int x, ScrollClamping clamping)</span>
  {
      ScrollPosition position(x, m_scrollPosition.y());
<span class="line-modified">!     scrollToOffset(scrollOffsetFromPosition(position), clamping);</span>
  }
  
<span class="line-modified">! void RenderLayer::scrollToYPosition(int y, ScrollClamping clamping)</span>
  {
      ScrollPosition position(m_scrollPosition.x(), y);
<span class="line-modified">!     scrollToOffset(scrollOffsetFromPosition(position), clamping);</span>
  }
  
  ScrollOffset RenderLayer::clampScrollOffset(const ScrollOffset&amp; scrollOffset) const
  {
      return scrollOffset.constrainedBetween(IntPoint(), maximumScrollOffset());
  }
  
<span class="line-modified">! void RenderLayer::scrollToOffset(const ScrollOffset&amp; scrollOffset, ScrollClamping clamping)</span>
  {
<span class="line-modified">!     ScrollOffset newScrollOffset = clamping == ScrollClamping::Clamped ? clampScrollOffset(scrollOffset) : scrollOffset;</span>
<span class="line-modified">!     if (newScrollOffset != this-&gt;scrollOffset())</span>
<span class="line-modified">!         scrollToOffsetWithoutAnimation(newScrollOffset, clamping);</span>
  }
  
  void RenderLayer::scrollTo(const ScrollPosition&amp; position)
  {
      RenderBox* box = renderBox();
      if (!box)
          return;
  
<span class="line-modified">!     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayer::scrollTo &quot; &lt;&lt; position &lt;&lt; &quot; from &quot; &lt;&lt; m_scrollPosition &lt;&lt; &quot; (in user scroll &quot; &lt;&lt; isInUserScroll() &lt;&lt; &quot;)&quot;);</span>
  
      ScrollPosition newPosition = position;
      if (!box-&gt;isHTMLMarquee()) {
          // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).
          if (m_scrollDimensionsDirty)
<span class="line-new-header">--- 2462,55 ---</span>
  
      scrollToOffset(scrollOffsetFromPosition(m_postLayoutScrollPosition.value()));
      m_postLayoutScrollPosition = WTF::nullopt;
  }
  
<span class="line-modified">! void RenderLayer::scrollToXPosition(int x, ScrollType scrollType, ScrollClamping clamping)</span>
  {
      ScrollPosition position(x, m_scrollPosition.y());
<span class="line-modified">!     scrollToOffset(scrollOffsetFromPosition(position), scrollType, clamping);</span>
  }
  
<span class="line-modified">! void RenderLayer::scrollToYPosition(int y, ScrollType scrollType, ScrollClamping clamping)</span>
  {
      ScrollPosition position(m_scrollPosition.x(), y);
<span class="line-modified">!     scrollToOffset(scrollOffsetFromPosition(position), scrollType, clamping);</span>
  }
  
  ScrollOffset RenderLayer::clampScrollOffset(const ScrollOffset&amp; scrollOffset) const
  {
      return scrollOffset.constrainedBetween(IntPoint(), maximumScrollOffset());
  }
  
<span class="line-modified">! void RenderLayer::scrollToOffset(const ScrollOffset&amp; scrollOffset, ScrollType scrollType, ScrollClamping clamping)</span>
  {
<span class="line-modified">!     ScrollOffset clampedScrollOffset = clamping == ScrollClamping::Clamped ? clampScrollOffset(scrollOffset) : scrollOffset;</span>
<span class="line-modified">!     if (clampedScrollOffset == this-&gt;scrollOffset())</span>
<span class="line-modified">!         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto previousScrollType = currentScrollType();</span>
<span class="line-added">+     setCurrentScrollType(scrollType);</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool handled = false;</span>
<span class="line-added">+ #if ENABLE(ASYNC_SCROLLING)</span>
<span class="line-added">+     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())</span>
<span class="line-added">+         handled = scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, scrollPositionFromOffset(clampedScrollOffset));</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!handled)</span>
<span class="line-added">+         scrollToOffsetWithoutAnimation(clampedScrollOffset, clamping);</span>
<span class="line-added">+ </span>
<span class="line-added">+     setCurrentScrollType(previousScrollType);</span>
  }
  
  void RenderLayer::scrollTo(const ScrollPosition&amp; position)
  {
      RenderBox* box = renderBox();
      if (!box)
          return;
  
<span class="line-modified">!     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayer::scrollTo &quot; &lt;&lt; position &lt;&lt; &quot; from &quot; &lt;&lt; m_scrollPosition &lt;&lt; &quot; (is user scroll &quot; &lt;&lt; (currentScrollType() == ScrollType::User) &lt;&lt; &quot;)&quot;);</span>
  
      ScrollPosition newPosition = position;
      if (!box-&gt;isHTMLMarquee()) {
          // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).
          if (m_scrollDimensionsDirty)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2398,18 ***</span>
              // positions. Updating layer positions requires a full walk of up-to-date RenderLayers, and
              // in this case we&#39;re still updating their positions; we&#39;ll update compositing layers later
              // when that completes.
              if (usesCompositedScrolling()) {
                  setNeedsCompositingGeometryUpdate();
<span class="line-modified">!                 setDescendantsNeedUpdateBackingAndHierarchyTraversal();</span>
              }
  
              updateCompositingLayersAfterScroll();
          }
  
          // Update regions, scrolling may change the clip of a particular region.
<span class="line-modified">!         renderer().document().invalidateRenderingDependentRegions(Document::AnnotationsAction::Update);</span>
          DebugPageOverlays::didLayout(renderer().frame());
      }
  
      Frame&amp; frame = renderer().frame();
      RenderLayerModelObject* repaintContainer = renderer().containerForRepaint();
<span class="line-new-header">--- 2561,22 ---</span>
              // positions. Updating layer positions requires a full walk of up-to-date RenderLayers, and
              // in this case we&#39;re still updating their positions; we&#39;ll update compositing layers later
              // when that completes.
              if (usesCompositedScrolling()) {
                  setNeedsCompositingGeometryUpdate();
<span class="line-modified">! </span>
<span class="line-added">+                 // Scroll position can affect the location of a composited descendant (which may be a sibling in z-order),</span>
<span class="line-added">+                 // so trigger a descendant walk from the paint-order parent.</span>
<span class="line-added">+                 if (auto* paintParent = paintOrderParent())</span>
<span class="line-added">+                     paintParent-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();</span>
              }
  
              updateCompositingLayersAfterScroll();
          }
  
          // Update regions, scrolling may change the clip of a particular region.
<span class="line-modified">!         renderer().document().invalidateRenderingDependentRegions();</span>
          DebugPageOverlays::didLayout(renderer().frame());
      }
  
      Frame&amp; frame = renderer().frame();
      RenderLayerModelObject* repaintContainer = renderer().containerForRepaint();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2500,10 ***</span>
<span class="line-new-header">--- 2667,15 ---</span>
          // Don&#39;t scroll to reveal an overflow layer that is restricted by the -webkit-line-clamp property.
          // This will prevent us from revealing text hidden by the slider in Safari RSS.
          RenderBox* box = renderBox();
          ASSERT(box);
          LayoutRect localExposeRect(box-&gt;absoluteToLocalQuad(FloatQuad(FloatRect(absoluteRect))).boundingBox());
<span class="line-added">+         if (shouldPlaceBlockDirectionScrollbarOnLeft()) {</span>
<span class="line-added">+             // For direction: rtl; writing-mode: horizontal-tb box, the scroll bar is on the left side. The visible rect</span>
<span class="line-added">+             // starts from the right side of scroll bar. So the x of localExposeRect should start from the same position too.</span>
<span class="line-added">+             localExposeRect.moveBy(LayoutPoint(-verticalScrollbarWidth(), 0));</span>
<span class="line-added">+         }</span>
          LayoutRect layerBounds(0_lu, 0_lu, box-&gt;clientWidth(), box-&gt;clientHeight());
          LayoutRect revealRect = getRectToExpose(layerBounds, localExposeRect, insideFixed, options.alignX, options.alignY);
  
          ScrollOffset clampedScrollOffset = clampScrollOffset(scrollOffset() + toIntSize(roundedIntRect(revealRect).location()));
          if (clampedScrollOffset != scrollOffset()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2544,22 ***</span>
              }
          } else {
              if (options.revealMode == SelectionRevealMode::RevealUpToMainFrame &amp;&amp; frameView.frame().isMainFrame())
                  return;
  
  #if !PLATFORM(IOS_FAMILY)
              LayoutRect viewRect = frameView.visibleContentRect();
  #else
<span class="line-modified">!             LayoutRect viewRect = frameView.unobscuredContentRectExpandedByContentInsets();</span>
  #endif
              // Move the target rect into &quot;scrollView contents&quot; coordinates.
              LayoutRect targetRect = absoluteRect;
              targetRect.move(0, frameView.headerHeight());
  
              LayoutRect revealRect = getRectToExpose(viewRect, targetRect, insideFixed, options.alignX, options.alignY);
<span class="line-modified">! </span>
<span class="line-modified">!             frameView.setScrollPosition(roundedIntPoint(revealRect.location()));</span>
  
              // This is the outermost view of a web page, so after scrolling this view we
              // scroll its container by calling Page::scrollRectIntoView.
              // This only has an effect on the Mac platform in applications
              // that put web views into scrolling containers, such as Mac OS X Mail.
<span class="line-new-header">--- 2716,37 ---</span>
              }
          } else {
              if (options.revealMode == SelectionRevealMode::RevealUpToMainFrame &amp;&amp; frameView.frame().isMainFrame())
                  return;
  
<span class="line-added">+             auto minScrollPosition = frameView.minimumScrollPosition();</span>
<span class="line-added">+             auto maxScrollPosition = frameView.maximumScrollPosition();</span>
<span class="line-added">+ </span>
  #if !PLATFORM(IOS_FAMILY)
              LayoutRect viewRect = frameView.visibleContentRect();
  #else
<span class="line-modified">!             // FIXME: ContentInsets should be taken care of in UI process side. webkit.org/b/199682</span>
<span class="line-added">+             // To do that, getRectToExpose needs to return the additional scrolling to do beyond content rect.</span>
<span class="line-added">+             LayoutRect viewRect = frameView.viewRectExpandedByContentInsets();</span>
<span class="line-added">+ </span>
<span class="line-added">+             // FIXME: webkit.org/b/199683 FrameView::visibleContentRect is wrong when content insets are present</span>
<span class="line-added">+             maxScrollPosition = frameView.scrollPositionFromOffset(ScrollPosition(frameView.totalContentsSize() - flooredIntSize(viewRect.size())));</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto contentInsets = page().contentInsets();</span>
<span class="line-added">+             minScrollPosition.move(-contentInsets.left(), -contentInsets.top());</span>
<span class="line-added">+             maxScrollPosition.move(contentInsets.right(), contentInsets.bottom());</span>
  #endif
              // Move the target rect into &quot;scrollView contents&quot; coordinates.
              LayoutRect targetRect = absoluteRect;
              targetRect.move(0, frameView.headerHeight());
  
              LayoutRect revealRect = getRectToExpose(viewRect, targetRect, insideFixed, options.alignX, options.alignY);
<span class="line-modified">!             // Avoid scrolling to the rounded value of revealRect.location() if we don&#39;t actually need to scroll</span>
<span class="line-modified">!             if (revealRect != viewRect) {</span>
<span class="line-added">+                 ScrollOffset clampedScrollPosition = roundedIntPoint(revealRect.location()).constrainedBetween(minScrollPosition, maxScrollPosition);</span>
<span class="line-added">+                 frameView.setScrollPosition(clampedScrollPosition);</span>
<span class="line-added">+             }</span>
  
              // This is the outermost view of a web page, so after scrolling this view we
              // scroll its container by calling Page::scrollRectIntoView.
              // This only has an effect on the Mac platform in applications
              // that put web views into scrolling containers, such as Mac OS X Mail.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2768,30 ***</span>
      document.updateLayout();
  
      // FIXME (Radar 4118564): We should also autoscroll the window as necessary to keep the point under the cursor in view.
  }
  
<span class="line-removed">- int RenderLayer::scrollSize(ScrollbarOrientation orientation) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     Scrollbar* scrollbar = ((orientation == HorizontalScrollbar) ? m_hBar : m_vBar).get();</span>
<span class="line-removed">-     return scrollbar ? (scrollbar-&gt;totalSize() - scrollbar-&gt;visibleSize()) : 0;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void RenderLayer::setScrollOffset(const ScrollOffset&amp; offset)
  {
      scrollTo(scrollPositionFromOffset(offset));
  }
  
<span class="line-modified">! int RenderLayer::scrollOffset(ScrollbarOrientation orientation) const</span>
  {
<span class="line-modified">!     if (orientation == HorizontalScrollbar)</span>
<span class="line-modified">!         return scrollOffset().x();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (orientation == VerticalScrollbar)</span>
<span class="line-removed">-         return scrollOffset().y();</span>
  
<span class="line-modified">!     return 0;</span>
  }
  
  IntRect RenderLayer::visibleContentRectInternal(VisibleContentRectIncludesScrollbars scrollbarInclusion, VisibleContentRectBehavior) const
  {
      IntSize scrollbarSpace;
<span class="line-new-header">--- 2955,21 ---</span>
      document.updateLayout();
  
      // FIXME (Radar 4118564): We should also autoscroll the window as necessary to keep the point under the cursor in view.
  }
  
  void RenderLayer::setScrollOffset(const ScrollOffset&amp; offset)
  {
      scrollTo(scrollPositionFromOffset(offset));
  }
  
<span class="line-modified">! ScrollingNodeID RenderLayer::scrollingNodeID() const</span>
  {
<span class="line-modified">!     if (!isComposited())</span>
<span class="line-modified">!         return 0;</span>
  
<span class="line-modified">!     return backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);</span>
  }
  
  IntRect RenderLayer::visibleContentRectInternal(VisibleContentRectIncludesScrollbars scrollbarInclusion, VisibleContentRectBehavior) const
  {
      IntSize scrollbarSpace;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2810,19 ***</span>
  
      IntSize stretch;
  
      // FIXME: use maximumScrollOffset(), or just move this to ScrollableArea.
      ScrollOffset scrollOffset = scrollOffsetFromPosition(scrollPosition());
      if (scrollOffset.y() &lt; 0)
          stretch.setHeight(scrollOffset.y());
<span class="line-modified">!     else if (scrollableContentsSize().height() &amp;&amp; scrollOffset.y() &gt; scrollableContentsSize().height() - visibleHeight())</span>
<span class="line-modified">!         stretch.setHeight(scrollOffset.y() - (scrollableContentsSize().height() - visibleHeight()));</span>
  
      if (scrollOffset.x() &lt; 0)
          stretch.setWidth(scrollOffset.x());
<span class="line-modified">!     else if (scrollableContentsSize().width() &amp;&amp; scrollOffset.x() &gt; scrollableContentsSize().width() - visibleWidth())</span>
<span class="line-modified">!         stretch.setWidth(scrollOffset.x() - (scrollableContentsSize().width() - visibleWidth()));</span>
  
      return stretch;
  #else
      return IntSize();
  #endif
<span class="line-new-header">--- 2988,20 ---</span>
  
      IntSize stretch;
  
      // FIXME: use maximumScrollOffset(), or just move this to ScrollableArea.
      ScrollOffset scrollOffset = scrollOffsetFromPosition(scrollPosition());
<span class="line-added">+     auto reachableSize = reachableTotalContentsSize();</span>
      if (scrollOffset.y() &lt; 0)
          stretch.setHeight(scrollOffset.y());
<span class="line-modified">!     else if (reachableSize.height() &amp;&amp; scrollOffset.y() &gt; reachableSize.height() - visibleHeight())</span>
<span class="line-modified">!         stretch.setHeight(scrollOffset.y() - (reachableSize.height() - visibleHeight()));</span>
  
      if (scrollOffset.x() &lt; 0)
          stretch.setWidth(scrollOffset.x());
<span class="line-modified">!     else if (reachableSize.width() &amp;&amp; scrollOffset.x() &gt; reachableSize.width() - visibleWidth())</span>
<span class="line-modified">!         stretch.setWidth(scrollOffset.x() - (reachableSize.width() - visibleWidth()));</span>
  
      return stretch;
  #else
      return IntSize();
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2945,11 ***</span>
  IntSize RenderLayer::contentsSize() const
  {
      return IntSize(scrollWidth(), scrollHeight());
  }
  
<span class="line-modified">! IntSize RenderLayer::scrollableContentsSize() const</span>
  {
      IntSize contentsSize = this-&gt;contentsSize();
  
      if (!hasScrollableHorizontalOverflow())
          contentsSize.setWidth(std::min(contentsSize.width(), visibleSize().width()));
<span class="line-new-header">--- 3124,11 ---</span>
  IntSize RenderLayer::contentsSize() const
  {
      return IntSize(scrollWidth(), scrollHeight());
  }
  
<span class="line-modified">! IntSize RenderLayer::reachableTotalContentsSize() const</span>
  {
      IntSize contentsSize = this-&gt;contentsSize();
  
      if (!hasScrollableHorizontalOverflow())
          contentsSize.setWidth(std::min(contentsSize.width(), visibleSize().width()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3110,10 ***</span>
<span class="line-new-header">--- 3289,30 ---</span>
          m_scrollCorner-&gt;repaintRectangle(rect);
      if (m_resizer)
          m_resizer-&gt;repaintRectangle(rect);
  }
  
<span class="line-added">+ static bool scrollbarHiddenByStyle(Scrollbar* scrollbar)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!scrollbar || !scrollbar-&gt;isCustomScrollbar())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     std::unique_ptr&lt;RenderStyle&gt; scrollbarStyle = static_cast&lt;RenderScrollbar*&gt;(scrollbar)-&gt;getScrollbarPseudoStyle(ScrollbarBGPart, PseudoId::Scrollbar);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return scrollbarStyle &amp;&amp; scrollbarStyle-&gt;display() == DisplayType::None;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool RenderLayer::horizontalScrollbarHiddenByStyle() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return scrollbarHiddenByStyle(horizontalScrollbar());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool RenderLayer::verticalScrollbarHiddenByStyle() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return scrollbarHiddenByStyle(verticalScrollbar());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static inline RenderElement* rendererForScrollbar(RenderLayerModelObject&amp; renderer)
  {
      if (Element* element = renderer.element()) {
          if (ShadowRoot* shadowRoot = element-&gt;containingShadowRoot()) {
              if (shadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3184,12 ***</span>
      // Destroying or creating one bar can cause our scrollbar corner to come and go.  We need to update the opposite scrollbar&#39;s style.
      if (m_hBar)
          m_hBar-&gt;styleChanged();
      if (m_vBar)
          m_vBar-&gt;styleChanged();
<span class="line-removed">- </span>
<span class="line-removed">-     renderer().document().invalidateScrollbarDependentRegions();</span>
  }
  
  void RenderLayer::setHasVerticalScrollbar(bool hasScrollbar)
  {
      if (hasScrollbar == hasVerticalScrollbar())
<span class="line-new-header">--- 3383,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3211,12 ***</span>
       // Destroying or creating one bar can cause our scrollbar corner to come and go.  We need to update the opposite scrollbar&#39;s style.
      if (m_hBar)
          m_hBar-&gt;styleChanged();
      if (m_vBar)
          m_vBar-&gt;styleChanged();
<span class="line-removed">- </span>
<span class="line-removed">-     renderer().document().invalidateScrollbarDependentRegions();</span>
  }
  
  ScrollableArea* RenderLayer::enclosingScrollableArea() const
  {
      if (RenderLayer* scrollableLayer = enclosingScrollableLayer())
<span class="line-new-header">--- 3408,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3413,10 ***</span>
<span class="line-new-header">--- 3608,12 ---</span>
      int scrollableLeftOverflow = roundToInt(overflowLeft() - box-&gt;borderLeft());
      if (shouldPlaceBlockDirectionScrollbarOnLeft())
          scrollableLeftOverflow -= verticalScrollbarWidth();
      int scrollableTopOverflow = roundToInt(overflowTop() - box-&gt;borderTop());
      setScrollOrigin(IntPoint(-scrollableLeftOverflow, -scrollableTopOverflow));
<span class="line-added">+ </span>
<span class="line-added">+     m_hasCompositedScrollableOverflow = canUseCompositedScrolling() &amp;&amp; (hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());</span>
  }
  
  bool RenderLayer::hasScrollableHorizontalOverflow() const
  {
      return hasHorizontalOverflow() &amp;&amp; renderBox()-&gt;scrollsOverflowX();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3483,11 ***</span>
          if (box-&gt;hasVerticalScrollbarWithAutoBehavior())
              setHasVerticalScrollbar(hasVerticalOverflow);
  
          updateSelfPaintingLayer();
  
<span class="line-removed">-         renderer().document().invalidateScrollbarDependentRegions();</span>
          renderer().repaint();
  
          if (renderer().style().overflowX() == Overflow::Auto || renderer().style().overflowY() == Overflow::Auto) {
              if (!m_inOverflowRelayout) {
                  m_inOverflowRelayout = true;
<span class="line-new-header">--- 3680,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3568,14 ***</span>
      if (isComposited()) {
          setNeedsCompositingGeometryUpdate();
          setNeedsCompositingConfigurationUpdate();
      }
  
<span class="line-removed">- #if PLATFORM(IOS_FAMILY)</span>
      if (canUseCompositedScrolling())
          setNeedsPostLayoutCompositingUpdate();
<span class="line-removed">- #endif</span>
  
      updateScrollSnapState();
  }
  
  bool RenderLayer::overflowControlsIntersectRect(const IntRect&amp; localRect) const
<span class="line-new-header">--- 3764,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3848,41 ***</span>
      paintLayer(context, paintingInfo, PaintLayerPaintingOverlayScrollbars);
  
      m_containsDirtyOverlayScrollbars = false;
  }
  
<span class="line-removed">- static bool inContainingBlockChain(RenderLayer* startLayer, RenderLayer* endLayer)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (startLayer == endLayer)</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     for (const auto* currentBlock = startLayer-&gt;renderer().containingBlock(); currentBlock &amp;&amp; !is&lt;RenderView&gt;(*currentBlock); currentBlock = currentBlock-&gt;containingBlock()) {</span>
<span class="line-removed">-         if (currentBlock-&gt;layer() == endLayer)</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void RenderLayer::clipToRect(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect, BorderRadiusClippingRule rule)
  {
      float deviceScaleFactor = renderer().document().deviceScaleFactor();
      bool needsClipping = !clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect;
      if (needsClipping || clipRect.affectedByRadius())
          context.save();
  
      if (needsClipping) {
          LayoutRect adjustedClipRect = clipRect.rect();
          adjustedClipRect.move(paintingInfo.subpixelOffset);
<span class="line-modified">!         context.clip(snapRectToDevicePixels(adjustedClipRect, deviceScaleFactor));</span>
      }
  
      if (clipRect.affectedByRadius()) {
          // If the clip rect has been tainted by a border radius, then we have to walk up our layer chain applying the clips from
          // any layers with overflow. The condition for being able to apply these clips is that the overflow object be in our
          // containing block chain so we check that also.
          for (RenderLayer* layer = rule == IncludeSelfForBorderRadius ? this : parent(); layer; layer = layer-&gt;parent()) {
<span class="line-modified">!             if (layer-&gt;renderer().hasOverflowClip() &amp;&amp; layer-&gt;renderer().style().hasBorderRadius() &amp;&amp; inContainingBlockChain(this, layer)) {</span>
                  LayoutRect adjustedClipRect = LayoutRect(toLayoutPoint(layer-&gt;offsetFromAncestor(paintingInfo.rootLayer, AdjustForColumns)), layer-&gt;size());
                  adjustedClipRect.move(paintingInfo.subpixelOffset);
                  FloatRoundedRect roundedRect = layer-&gt;renderer().style().getRoundedInnerBorderFor(adjustedClipRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor);
                  if (roundedRect.intersectionIsRectangular(paintingInfo.paintDirtyRect))
                      context.clip(snapRectToDevicePixels(intersection(paintingInfo.paintDirtyRect, adjustedClipRect), deviceScaleFactor));
<span class="line-new-header">--- 4042,33 ---</span>
      paintLayer(context, paintingInfo, PaintLayerPaintingOverlayScrollbars);
  
      m_containsDirtyOverlayScrollbars = false;
  }
  
  void RenderLayer::clipToRect(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect, BorderRadiusClippingRule rule)
  {
      float deviceScaleFactor = renderer().document().deviceScaleFactor();
      bool needsClipping = !clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect;
      if (needsClipping || clipRect.affectedByRadius())
          context.save();
  
      if (needsClipping) {
          LayoutRect adjustedClipRect = clipRect.rect();
          adjustedClipRect.move(paintingInfo.subpixelOffset);
<span class="line-modified">!         auto snappedClipRect = snapRectToDevicePixels(adjustedClipRect, deviceScaleFactor);</span>
<span class="line-added">+         context.clip(snappedClipRect);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (paintingInfo.eventRegionContext)</span>
<span class="line-added">+             paintingInfo.eventRegionContext-&gt;pushClip(enclosingIntRect(snappedClipRect));</span>
      }
  
      if (clipRect.affectedByRadius()) {
          // If the clip rect has been tainted by a border radius, then we have to walk up our layer chain applying the clips from
          // any layers with overflow. The condition for being able to apply these clips is that the overflow object be in our
          // containing block chain so we check that also.
          for (RenderLayer* layer = rule == IncludeSelfForBorderRadius ? this : parent(); layer; layer = layer-&gt;parent()) {
<span class="line-modified">!             if (layer-&gt;renderer().hasOverflowClip() &amp;&amp; layer-&gt;renderer().style().hasBorderRadius() &amp;&amp; ancestorLayerIsInContainingBlockChain(*layer)) {</span>
                  LayoutRect adjustedClipRect = LayoutRect(toLayoutPoint(layer-&gt;offsetFromAncestor(paintingInfo.rootLayer, AdjustForColumns)), layer-&gt;size());
                  adjustedClipRect.move(paintingInfo.subpixelOffset);
                  FloatRoundedRect roundedRect = layer-&gt;renderer().style().getRoundedInnerBorderFor(adjustedClipRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor);
                  if (roundedRect.intersectionIsRectangular(paintingInfo.paintDirtyRect))
                      context.clip(snapRectToDevicePixels(intersection(paintingInfo.paintDirtyRect, adjustedClipRect), deviceScaleFactor));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3896,16 ***</span>
      }
  }
  
  void RenderLayer::restoreClip(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect)
  {
<span class="line-modified">!     if ((!clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect) || clipRect.affectedByRadius())</span>
          context.restore();
  }
  
  static void performOverlapTests(OverlapTestRequestMap&amp; overlapTestRequests, const RenderLayer* rootLayer, const RenderLayer* layer)
  {
      Vector&lt;OverlapTestRequestClient*&gt; overlappedRequestClients;
      LayoutRect boundingBox = layer-&gt;boundingBox(rootLayer, layer-&gt;offsetFromAncestor(rootLayer));
      for (auto&amp; request : overlapTestRequests) {
          if (!boundingBox.intersects(request.value))
              continue;
<span class="line-new-header">--- 4082,23 ---</span>
      }
  }
  
  void RenderLayer::restoreClip(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect)
  {
<span class="line-modified">!     if ((!clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect) || clipRect.affectedByRadius()) {</span>
          context.restore();
<span class="line-added">+ </span>
<span class="line-added">+         if (paintingInfo.eventRegionContext)</span>
<span class="line-added">+             paintingInfo.eventRegionContext-&gt;popClip();</span>
<span class="line-added">+     }</span>
  }
  
  static void performOverlapTests(OverlapTestRequestMap&amp; overlapTestRequests, const RenderLayer* rootLayer, const RenderLayer* layer)
  {
<span class="line-added">+     if (overlapTestRequests.isEmpty())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      Vector&lt;OverlapTestRequestClient*&gt; overlappedRequestClients;
      LayoutRect boundingBox = layer-&gt;boundingBox(rootLayer, layer-&gt;offsetFromAncestor(rootLayer));
      for (auto&amp; request : overlapTestRequests) {
          if (!boundingBox.intersects(request.value))
              continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3940,29 ***</span>
      return layer-&gt;renderer().isDocumentElementRenderer() &amp;&amp; (paintFlags &amp; RenderLayer::PaintLayerPaintingRootBackgroundOnly);
  }
  
  void RenderLayer::paintLayer(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
  {
<span class="line-modified">!     if (isComposited()) {</span>
<span class="line-modified">!         // The performingPaintInvalidation() painting pass goes through compositing layers,</span>
<span class="line-modified">!         // but we need to ensure that we don&#39;t cache clip rects computed with the wrong root in this case.</span>
<span class="line-modified">!         if (context.performingPaintInvalidation() || (paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))</span>
<span class="line-modified">!             paintFlags.add(PaintLayerTemporaryClipRects);</span>
<span class="line-modified">!         else if (!backing()-&gt;paintsIntoWindow()</span>
<span class="line-modified">!             &amp;&amp; !backing()-&gt;paintsIntoCompositedAncestor()</span>
<span class="line-modified">!             &amp;&amp; !shouldDoSoftwarePaint(this, paintFlags.contains(PaintLayerPaintingReflection))</span>
<span class="line-modified">!             &amp;&amp; !paintForFixedRootBackground(this, paintFlags)) {</span>
<span class="line-modified">!             // If this RenderLayer should paint into its backing, that will be done via RenderLayerBacking::paintIntoLayer().</span>
              return;
<span class="line-modified">!         }</span>
<span class="line-modified">!     } else if (viewportConstrainedNotCompositedReason() == NotCompositedForBoundsOutOfView) {</span>
          // Don&#39;t paint out-of-view viewport constrained layers (when doing prepainting) because they will never be visible
          // unless their position or viewport size is changed.
          ASSERT(renderer().isFixedPositioned());
          return;
      }
  
      // Non self-painting leaf layers don&#39;t need to be painted as their renderer() should properly paint itself.
      if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
          return;
  
      if (shouldSuppressPaintingLayer(this))
<span class="line-new-header">--- 4133,46 ---</span>
      return layer-&gt;renderer().isDocumentElementRenderer() &amp;&amp; (paintFlags &amp; RenderLayer::PaintLayerPaintingRootBackgroundOnly);
  }
  
  void RenderLayer::paintLayer(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
  {
<span class="line-modified">!     auto shouldContinuePaint = [&amp;] () {</span>
<span class="line-modified">!         return backing()-&gt;paintsIntoWindow()</span>
<span class="line-modified">!             || backing()-&gt;paintsIntoCompositedAncestor()</span>
<span class="line-modified">!             || shouldDoSoftwarePaint(this, paintFlags.contains(PaintLayerPaintingReflection))</span>
<span class="line-modified">!             || paintForFixedRootBackground(this, paintFlags);</span>
<span class="line-modified">!     };</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto paintsIntoDifferentCompositedDestination = [&amp;]() {</span>
<span class="line-modified">!         if (paintsIntoProvidedBacking())</span>
<span class="line-modified">!             return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (isComposited() &amp;&amp; !shouldContinuePaint())</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (paintsIntoDifferentCompositedDestination()) {</span>
<span class="line-added">+         if (!context.performingPaintInvalidation() &amp;&amp; !(paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))</span>
              return;
<span class="line-modified">! </span>
<span class="line-modified">!         paintFlags.add(PaintLayerTemporaryClipRects);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (viewportConstrainedNotCompositedReason() == NotCompositedForBoundsOutOfView) {</span>
          // Don&#39;t paint out-of-view viewport constrained layers (when doing prepainting) because they will never be visible
          // unless their position or viewport size is changed.
          ASSERT(renderer().isFixedPositioned());
          return;
      }
  
<span class="line-added">+     paintLayerWithEffects(context, paintingInfo, paintFlags);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RenderLayer::paintLayerWithEffects(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)</span>
<span class="line-added">+ {</span>
      // Non self-painting leaf layers don&#39;t need to be painted as their renderer() should properly paint itself.
      if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
          return;
  
      if (shouldSuppressPaintingLayer(this))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4234,20 ***</span>
      bool isPaintingOverlayScrollbars = paintFlags.contains(PaintLayerPaintingOverlayScrollbars);
      bool isPaintingScrollingContent = paintFlags.contains(PaintLayerPaintingCompositingScrollingPhase);
      bool isPaintingCompositedForeground = paintFlags.contains(PaintLayerPaintingCompositingForegroundPhase);
      bool isPaintingCompositedBackground = paintFlags.contains(PaintLayerPaintingCompositingBackgroundPhase);
      bool isPaintingOverflowContents = paintFlags.contains(PaintLayerPaintingOverflowContents);
      // Outline always needs to be painted even if we have no visible content. Also,
      // the outline is painted in the background phase during composited scrolling.
      // If it were painted in the foreground phase, it would move with the scrolled
      // content. When not composited scrolling, the outline is painted in the
      // foreground phase. Since scrolled contents are moved by repainting in this
      // case, the outline won&#39;t get &#39;dragged along&#39;.
<span class="line-modified">!     bool shouldPaintOutline = isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars</span>
          &amp;&amp; ((isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground)
          || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedForeground));
<span class="line-modified">!     bool shouldPaintContent = m_hasVisibleContent &amp;&amp; isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars;</span>
  
      if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly &amp;&amp; !renderer().isRenderView() &amp;&amp; !renderer().isDocumentElementRenderer())
          return;
  
      updateLayerListsIfNeeded();
<span class="line-new-header">--- 4444,22 ---</span>
      bool isPaintingOverlayScrollbars = paintFlags.contains(PaintLayerPaintingOverlayScrollbars);
      bool isPaintingScrollingContent = paintFlags.contains(PaintLayerPaintingCompositingScrollingPhase);
      bool isPaintingCompositedForeground = paintFlags.contains(PaintLayerPaintingCompositingForegroundPhase);
      bool isPaintingCompositedBackground = paintFlags.contains(PaintLayerPaintingCompositingBackgroundPhase);
      bool isPaintingOverflowContents = paintFlags.contains(PaintLayerPaintingOverflowContents);
<span class="line-added">+     bool isCollectingEventRegion = paintFlags.contains(PaintLayerCollectingEventRegion);</span>
      // Outline always needs to be painted even if we have no visible content. Also,
      // the outline is painted in the background phase during composited scrolling.
      // If it were painted in the foreground phase, it would move with the scrolled
      // content. When not composited scrolling, the outline is painted in the
      // foreground phase. Since scrolled contents are moved by repainting in this
      // case, the outline won&#39;t get &#39;dragged along&#39;.
<span class="line-modified">!     bool shouldPaintOutline = isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion</span>
<span class="line-added">+         &amp;&amp; (renderer().view().printing() || renderer().view().hasRenderersWithOutline())</span>
          &amp;&amp; ((isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground)
          || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedForeground));
<span class="line-modified">!     bool shouldPaintContent = m_hasVisibleContent &amp;&amp; isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion;</span>
  
      if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly &amp;&amp; !renderer().isRenderView() &amp;&amp; !renderer().isDocumentElementRenderer())
          return;
  
      updateLayerListsIfNeeded();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4314,11 ***</span>
  
          if (paintingInfo.paintBehavior &amp; PaintBehavior::ExcludeSelection)
              paintBehavior.add(PaintBehavior::ExcludeSelection);
  
          LayoutRect paintDirtyRect = localPaintingInfo.paintDirtyRect;
<span class="line-modified">!         if (shouldPaintContent || shouldPaintOutline || isPaintingOverlayScrollbars) {</span>
              // Collect the fragments. This will compute the clip rectangles and paint offsets for each layer fragment, as well as whether or not the content of each
              // fragment should paint. If the parent&#39;s filter dictates full repaint to ensure proper filter effect,
              // use the overflow clip as dirty rect, instead of no clipping. It maintains proper clipping for overflow::scroll.
              if (!localPaintingInfo.clipToDirtyRect &amp;&amp; renderer().hasOverflowClip()) {
                  // We can turn clipping back by requesting full repaint for the overflow area.
<span class="line-new-header">--- 4526,11 ---</span>
  
          if (paintingInfo.paintBehavior &amp; PaintBehavior::ExcludeSelection)
              paintBehavior.add(PaintBehavior::ExcludeSelection);
  
          LayoutRect paintDirtyRect = localPaintingInfo.paintDirtyRect;
<span class="line-modified">!         if (shouldPaintContent || shouldPaintOutline || isPaintingOverlayScrollbars || isCollectingEventRegion) {</span>
              // Collect the fragments. This will compute the clip rectangles and paint offsets for each layer fragment, as well as whether or not the content of each
              // fragment should paint. If the parent&#39;s filter dictates full repaint to ensure proper filter effect,
              // use the overflow clip as dirty rect, instead of no clipping. It maintains proper clipping for overflow::scroll.
              if (!localPaintingInfo.clipToDirtyRect &amp;&amp; renderer().hasOverflowClip()) {
                  // We can turn clipping back by requesting full repaint for the overflow area.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4348,10 ***</span>
<span class="line-new-header">--- 4560,13 ---</span>
                  paintForegroundForFragments(layerFragments, currentContext, context, paintingInfo.paintDirtyRect, haveTransparency,
                      localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
              }
          }
  
<span class="line-added">+         if (isCollectingEventRegion)</span>
<span class="line-added">+             collectEventRegionForFragments(layerFragments, currentContext, localPaintingInfo);</span>
<span class="line-added">+ </span>
          if (shouldPaintOutline)
              paintOutlineForFragments(layerFragments, currentContext, localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
  
          if (isPaintingCompositedForeground) {
              // Paint any child layers that have overflow.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4434,21 ***</span>
      // We handle accumulated subpixels through nested layers here. Since the context gets translated to device pixels,
      // all we need to do is add the delta to the accumulated pixels coming from ancestor layers.
      // Translate the graphics context to the snapping position to avoid off-device-pixel positing.
      transform.translateRight(devicePixelSnappedOffsetForThisLayer.width(), devicePixelSnappedOffsetForThisLayer.height());
      // Apply the transform.
<span class="line-modified">!     AffineTransform oldTransfrom = context.getCTM();</span>
<span class="line-modified">!     context.concatCTM(transform.toAffineTransform());</span>
  
      // Now do a paint with the root layer shifted to be us.
      LayoutSize adjustedSubpixelOffset = offsetForThisLayer - LayoutSize(devicePixelSnappedOffsetForThisLayer);
      LayerPaintingInfo transformedPaintingInfo(paintingInfo);
      transformedPaintingInfo.rootLayer = this;
      transformedPaintingInfo.paintDirtyRect = LayoutRect(encloseRectToDevicePixels(transform.inverse().valueOr(AffineTransform()).mapRect(paintingInfo.paintDirtyRect), deviceScaleFactor));
      transformedPaintingInfo.subpixelOffset = adjustedSubpixelOffset;
      paintLayerContentsAndReflection(context, transformedPaintingInfo, paintFlags);
<span class="line-modified">!     context.setCTM(oldTransfrom);</span>
  }
  
  void RenderLayer::paintList(LayerList layerIterator, GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
  {
      if (layerIterator.begin() == layerIterator.end())
<span class="line-new-header">--- 4649,29 ---</span>
      // We handle accumulated subpixels through nested layers here. Since the context gets translated to device pixels,
      // all we need to do is add the delta to the accumulated pixels coming from ancestor layers.
      // Translate the graphics context to the snapping position to avoid off-device-pixel positing.
      transform.translateRight(devicePixelSnappedOffsetForThisLayer.width(), devicePixelSnappedOffsetForThisLayer.height());
      // Apply the transform.
<span class="line-modified">!     auto oldTransform = context.getCTM();</span>
<span class="line-modified">!     auto affineTransform = transform.toAffineTransform();</span>
<span class="line-added">+     context.concatCTM(affineTransform);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (paintingInfo.eventRegionContext)</span>
<span class="line-added">+         paintingInfo.eventRegionContext-&gt;pushTransform(affineTransform);</span>
  
      // Now do a paint with the root layer shifted to be us.
      LayoutSize adjustedSubpixelOffset = offsetForThisLayer - LayoutSize(devicePixelSnappedOffsetForThisLayer);
      LayerPaintingInfo transformedPaintingInfo(paintingInfo);
      transformedPaintingInfo.rootLayer = this;
      transformedPaintingInfo.paintDirtyRect = LayoutRect(encloseRectToDevicePixels(transform.inverse().valueOr(AffineTransform()).mapRect(paintingInfo.paintDirtyRect), deviceScaleFactor));
      transformedPaintingInfo.subpixelOffset = adjustedSubpixelOffset;
      paintLayerContentsAndReflection(context, transformedPaintingInfo, paintFlags);
<span class="line-modified">! </span>
<span class="line-added">+     if (paintingInfo.eventRegionContext)</span>
<span class="line-added">+         paintingInfo.eventRegionContext-&gt;popTransform();</span>
<span class="line-added">+ </span>
<span class="line-added">+     context.setCTM(oldTransform);</span>
  }
  
  void RenderLayer::paintList(LayerList layerIterator, GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
  {
      if (layerIterator.begin() == layerIterator.end())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4729,15 ***</span>
          clipToRect(context, localPaintingInfo, clippedRect);
      }
  
      // We have to loop through every fragment multiple times, since we have to repaint in each specific phase in order for
      // interleaving of the fragments to work properly.
<span class="line-modified">!     bool selectionOnly = localPaintingInfo.paintBehavior.containsAny({ PaintBehavior::SelectionAndBackgroundsOnly, PaintBehavior::SelectionOnly });</span>
<span class="line-modified">!     paintForegroundForFragmentsWithPhase(selectionOnly ? PaintPhase::Selection : PaintPhase::ChildBlockBackgrounds, layerFragments,</span>
<span class="line-modified">!         context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);</span>
  
<span class="line-modified">!     if (!selectionOnly) {</span>
          paintForegroundForFragmentsWithPhase(PaintPhase::Float, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
          paintForegroundForFragmentsWithPhase(PaintPhase::Foreground, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
          paintForegroundForFragmentsWithPhase(PaintPhase::ChildOutlines, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
      }
  
<span class="line-new-header">--- 4952,19 ---</span>
          clipToRect(context, localPaintingInfo, clippedRect);
      }
  
      // We have to loop through every fragment multiple times, since we have to repaint in each specific phase in order for
      // interleaving of the fragments to work properly.
<span class="line-modified">!     bool selectionOnly = localPaintingInfo.paintBehavior.contains(PaintBehavior::SelectionOnly);</span>
<span class="line-modified">!     bool selectionAndBackgroundsOnly = localPaintingInfo.paintBehavior.contains(PaintBehavior::SelectionAndBackgroundsOnly);</span>
<span class="line-modified">! </span>
<span class="line-added">+     if (!selectionOnly)</span>
<span class="line-added">+         paintForegroundForFragmentsWithPhase(PaintPhase::ChildBlockBackgrounds, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);</span>
  
<span class="line-modified">!     if (selectionOnly || selectionAndBackgroundsOnly)</span>
<span class="line-added">+         paintForegroundForFragmentsWithPhase(PaintPhase::Selection, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);</span>
<span class="line-added">+     else {</span>
          paintForegroundForFragmentsWithPhase(PaintPhase::Float, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
          paintForegroundForFragmentsWithPhase(PaintPhase::Foreground, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
          paintForegroundForFragmentsWithPhase(PaintPhase::ChildOutlines, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4830,10 ***</span>
<span class="line-new-header">--- 5057,21 ---</span>
              snappedIntRect(fragment.backgroundRect.rect()), true);
          restoreClip(context, localPaintingInfo, fragment.backgroundRect);
      }
  }
  
<span class="line-added">+ void RenderLayer::collectEventRegionForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(localPaintingInfo.eventRegionContext);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (const auto&amp; fragment : layerFragments) {</span>
<span class="line-added">+         PaintInfo paintInfo(context, fragment.foregroundRect.rect(), PaintPhase::EventRegion, { });</span>
<span class="line-added">+         paintInfo.eventRegionContext = localPaintingInfo.eventRegionContext;</span>
<span class="line-added">+         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool RenderLayer::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
  {
      return hitTest(request, result.hitTestLocation(), result);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5335,21 ***</span>
              return *clipRects; // We have the correct cached value.
          }
      }
  
      if (!m_clipRectsCache)
<span class="line-modified">!         m_clipRectsCache = std::make_unique&lt;ClipRectsCache&gt;();</span>
  #ifndef NDEBUG
      m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType] = clipRectsContext.rootLayer;
      m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] = clipRectsContext.overlayScrollbarSizeRelevancy;
  #endif
  
      RefPtr&lt;ClipRects&gt; parentClipRects;
      // For transformed layers, the root layer was shifted to be us, so there is no need to
      // examine the parent. We want to cache clip rects with us as the root.
<span class="line-modified">!     if (auto* parentLayer = (clipRectsContext.rootLayer != this ? parent() : nullptr))</span>
<span class="line-modified">!         parentClipRects = parentLayer-&gt;updateClipRects(clipRectsContext);</span>
  
      auto clipRects = ClipRects::create();
      calculateClipRects(clipRectsContext, clipRects);
  
      if (parentClipRects &amp;&amp; *parentClipRects == clipRects) {
<span class="line-new-header">--- 5573,21 ---</span>
              return *clipRects; // We have the correct cached value.
          }
      }
  
      if (!m_clipRectsCache)
<span class="line-modified">!         m_clipRectsCache = makeUnique&lt;ClipRectsCache&gt;();</span>
  #ifndef NDEBUG
      m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType] = clipRectsContext.rootLayer;
      m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] = clipRectsContext.overlayScrollbarSizeRelevancy;
  #endif
  
      RefPtr&lt;ClipRects&gt; parentClipRects;
      // For transformed layers, the root layer was shifted to be us, so there is no need to
      // examine the parent. We want to cache clip rects with us as the root.
<span class="line-modified">!     if (clipRectsContext.rootLayer != this &amp;&amp; parent())</span>
<span class="line-modified">!         parentClipRects = this-&gt;parentClipRects(clipRectsContext);</span>
  
      auto clipRects = ClipRects::create();
      calculateClipRects(clipRectsContext, clipRects);
  
      if (parentClipRects &amp;&amp; *parentClipRects == clipRects) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5366,10 ***</span>
<span class="line-new-header">--- 5604,16 ---</span>
      if (!m_clipRectsCache)
          return nullptr;
      return m_clipRectsCache-&gt;getClipRects(context.clipRectsType, context.respectOverflowClip);
  }
  
<span class="line-added">+ bool RenderLayer::clipCrossesPaintingBoundary() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return parent()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers) != enclosingPaginationLayer(IncludeCompositedPaginatedLayers)</span>
<span class="line-added">+         || parent()-&gt;enclosingCompositingLayerForRepaint() != enclosingCompositingLayerForRepaint();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void RenderLayer::calculateClipRects(const ClipRectsContext&amp; clipRectsContext, ClipRects&amp; clipRects) const
  {
      if (!parent()) {
          // The root layer&#39;s clip rect is always infinite.
          clipRects.reset();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5388,10 ***</span>
<span class="line-new-header">--- 5632,14 ---</span>
          if (useCached &amp;&amp; parentLayer-&gt;clipRects(clipRectsContext))
              clipRects = *parentLayer-&gt;clipRects(clipRectsContext);
          else {
              ClipRectsContext parentContext(clipRectsContext);
              parentContext.overlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize; // FIXME: why?
<span class="line-added">+ </span>
<span class="line-added">+             if ((parentContext.clipRectsType != TemporaryClipRects &amp;&amp; parentContext.clipRectsType != AbsoluteClipRects) &amp;&amp; clipCrossesPaintingBoundary())</span>
<span class="line-added">+                 parentContext.clipRectsType = TemporaryClipRects;</span>
<span class="line-added">+ </span>
              parentLayer-&gt;calculateClipRects(parentContext, clipRects);
          }
      } else
          clipRects.reset();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5411,15 ***</span>
      if (renderer().hasClipOrOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) {
  #else
      if ((renderer().hasOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) || renderer().hasClip()) {
  #endif
          // This layer establishes a clip of some kind.
  
<span class="line-removed">-         // This offset cannot use convertToLayerCoords, because sometimes our rootLayer may be across</span>
<span class="line-removed">-         // some transformed layer boundary, for example, in the RenderLayerCompositor overlapMap, where</span>
<span class="line-removed">-         // clipRects are needed in view space.</span>
<span class="line-removed">-         LayoutPoint offset(renderer().localToContainerPoint(FloatPoint(), &amp;clipRectsContext.rootLayer-&gt;renderer()));</span>
          if (clipRects.fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;renderer().view())
              offset -= toLayoutSize(renderer().view().frameView().scrollPositionForFixedPosition());
  
          if (renderer().hasOverflowClip()) {
              ClipRect newOverflowClip = downcast&lt;RenderBox&gt;(renderer()).overflowClipRectForChildLayers(offset, nullptr, clipRectsContext.overlayScrollbarSizeRelevancy);
<span class="line-new-header">--- 5659,16 ---</span>
      if (renderer().hasClipOrOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) {
  #else
      if ((renderer().hasOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) || renderer().hasClip()) {
  #endif
          // This layer establishes a clip of some kind.
<span class="line-added">+         LayoutPoint offset;</span>
<span class="line-added">+         if (!m_hasTransformedAncestor &amp;&amp; canUseOffsetFromAncestor())</span>
<span class="line-added">+             offset = toLayoutPoint(offsetFromAncestor(clipRectsContext.rootLayer, AdjustForColumns));</span>
<span class="line-added">+         else</span>
<span class="line-added">+             offset = LayoutPoint(renderer().localToContainerPoint(FloatPoint(), &amp;clipRectsContext.rootLayer-&gt;renderer()));</span>
  
          if (clipRects.fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;renderer().view())
              offset -= toLayoutSize(renderer().view().frameView().scrollPositionForFixedPosition());
  
          if (renderer().hasOverflowClip()) {
              ClipRect newOverflowClip = downcast&lt;RenderBox&gt;(renderer()).overflowClipRectForChildLayers(offset, nullptr, clipRectsContext.overlayScrollbarSizeRelevancy);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5433,20 ***</span>
              clipRects.setPosClipRect(intersection(newPosClip, clipRects.posClipRect()));
              clipRects.setOverflowClipRect(intersection(newPosClip, clipRects.overflowClipRect()));
              clipRects.setFixedClipRect(intersection(newPosClip, clipRects.fixedClipRect()));
          }
      }
  }
  
  Ref&lt;ClipRects&gt; RenderLayer::parentClipRects(const ClipRectsContext&amp; clipRectsContext) const
  {
      ASSERT(parent());
  
<span class="line-modified">!     if (clipRectsContext.clipRectsType == TemporaryClipRects) {</span>
          auto parentClipRects = ClipRects::create();
<span class="line-modified">!         parent()-&gt;calculateClipRects(clipRectsContext, parentClipRects);</span>
          return parentClipRects;
      }
  
      return parent()-&gt;updateClipRects(clipRectsContext);
  }
  
<span class="line-new-header">--- 5682,31 ---</span>
              clipRects.setPosClipRect(intersection(newPosClip, clipRects.posClipRect()));
              clipRects.setOverflowClipRect(intersection(newPosClip, clipRects.overflowClipRect()));
              clipRects.setFixedClipRect(intersection(newPosClip, clipRects.fixedClipRect()));
          }
      }
<span class="line-added">+ </span>
<span class="line-added">+     LOG_WITH_STREAM(ClipRects, stream &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; this &lt;&lt; &quot; calculateClipRects &quot; &lt;&lt; clipRects);</span>
  }
  
  Ref&lt;ClipRects&gt; RenderLayer::parentClipRects(const ClipRectsContext&amp; clipRectsContext) const
  {
      ASSERT(parent());
  
<span class="line-modified">!     auto temporaryParentClipRects = [&amp;](const ClipRectsContext&amp; clipContext) {</span>
          auto parentClipRects = ClipRects::create();
<span class="line-modified">!         parent()-&gt;calculateClipRects(clipContext, parentClipRects);</span>
          return parentClipRects;
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (clipRectsContext.clipRectsType == TemporaryClipRects)</span>
<span class="line-added">+         return temporaryParentClipRects(clipRectsContext);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (clipRectsContext.clipRectsType != AbsoluteClipRects &amp;&amp; clipCrossesPaintingBoundary()) {</span>
<span class="line-added">+         ClipRectsContext tempClipRectsContext(clipRectsContext);</span>
<span class="line-added">+         tempClipRectsContext.clipRectsType = TemporaryClipRects;</span>
<span class="line-added">+         return temporaryParentClipRects(tempClipRectsContext);</span>
      }
  
      return parent()-&gt;updateClipRects(clipRectsContext);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5462,30 ***</span>
  }
  
  ClipRect RenderLayer::backgroundClipRect(const ClipRectsContext&amp; clipRectsContext) const
  {
      ASSERT(parent());
<span class="line-modified">!     auto computeParentRects = [&amp;] {</span>
<span class="line-removed">-         if (clipRectsContext.clipRectsType == TemporaryClipRects)</span>
<span class="line-removed">-             return parentClipRects(clipRectsContext);</span>
<span class="line-removed">-         // If we cross into a different composition/pagination context, then we can&#39;t rely on the cache since the root layer differs.</span>
<span class="line-removed">-         bool crossesPaginationBoundary = parent()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers) != enclosingPaginationLayer(IncludeCompositedPaginatedLayers);</span>
<span class="line-removed">-         bool crossesCompositingBoundary = parent()-&gt;enclosingCompositingLayerForRepaint() != enclosingCompositingLayerForRepaint();</span>
<span class="line-removed">-         if (!crossesPaginationBoundary &amp;&amp; !crossesCompositingBoundary)</span>
<span class="line-removed">-             return parentClipRects(clipRectsContext);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ClipRectsContext tempContext(clipRectsContext);</span>
<span class="line-removed">-         tempContext.clipRectsType = TemporaryClipRects;</span>
<span class="line-removed">-         return parentClipRects(tempContext);</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto parentRects = computeParentRects();</span>
      ClipRect backgroundClipRect = backgroundClipRectForPosition(parentRects, renderer().style().position());
      RenderView&amp; view = renderer().view();
      // Note: infinite clipRects should not be scrolled here, otherwise they will accidentally no longer be considered infinite.
      if (parentRects-&gt;fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;view &amp;&amp; !backgroundClipRect.isInfinite())
          backgroundClipRect.moveBy(view.frameView().scrollPositionForFixedPosition());
      return backgroundClipRect;
  }
  
  void RenderLayer::calculateRects(const ClipRectsContext&amp; clipRectsContext, const LayoutRect&amp; paintDirtyRect, LayoutRect&amp; layerBounds,
      ClipRect&amp; backgroundRect, ClipRect&amp; foregroundRect, const LayoutSize&amp; offsetFromRoot) const
<span class="line-new-header">--- 5722,18 ---</span>
  }
  
  ClipRect RenderLayer::backgroundClipRect(const ClipRectsContext&amp; clipRectsContext) const
  {
      ASSERT(parent());
<span class="line-modified">!     auto parentRects = parentClipRects(clipRectsContext);</span>
      ClipRect backgroundClipRect = backgroundClipRectForPosition(parentRects, renderer().style().position());
      RenderView&amp; view = renderer().view();
      // Note: infinite clipRects should not be scrolled here, otherwise they will accidentally no longer be considered infinite.
      if (parentRects-&gt;fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;view &amp;&amp; !backgroundClipRect.isInfinite())
          backgroundClipRect.moveBy(view.frameView().scrollPositionForFixedPosition());
<span class="line-added">+ </span>
<span class="line-added">+     LOG_WITH_STREAM(ClipRects, stream &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; this &lt;&lt; &quot; backgroundClipRect with context &quot; &lt;&lt; clipRectsContext &lt;&lt; &quot; returning &quot; &lt;&lt; backgroundClipRect);</span>
      return backgroundClipRect;
  }
  
  void RenderLayer::calculateRects(const ClipRectsContext&amp; clipRectsContext, const LayoutRect&amp; paintDirtyRect, LayoutRect&amp; layerBounds,
      ClipRect&amp; backgroundRect, ClipRect&amp; foregroundRect, const LayoutSize&amp; offsetFromRoot) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5688,17 ***</span>
          RenderBox* box = renderBox();
          ASSERT(box);
          if (!(flags &amp; DontConstrainForMask) &amp;&amp; box-&gt;hasMask()) {
              result = box-&gt;maskClipRect(LayoutPoint());
              box-&gt;flipForWritingMode(result); // The mask clip rect is in physical coordinates, so we have to flip, since localBoundingBox is not.
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             LayoutRect bbox = box-&gt;borderBoxRect();</span>
<span class="line-removed">-             result = bbox;</span>
<span class="line-removed">-             LayoutRect overflowRect = box-&gt;visualOverflowRect();</span>
<span class="line-removed">-             if (bbox != overflowRect)</span>
<span class="line-removed">-                 result.unite(overflowRect);</span>
<span class="line-removed">-         }</span>
      }
      return result;
  }
  
  LayoutRect RenderLayer::boundingBox(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
<span class="line-new-header">--- 5936,12 ---</span>
          RenderBox* box = renderBox();
          ASSERT(box);
          if (!(flags &amp; DontConstrainForMask) &amp;&amp; box-&gt;hasMask()) {
              result = box-&gt;maskClipRect(LayoutPoint());
              box-&gt;flipForWritingMode(result); // The mask clip rect is in physical coordinates, so we have to flip, since localBoundingBox is not.
<span class="line-modified">!         } else</span>
<span class="line-modified">!             result = box-&gt;visualOverflowRect();</span>
      }
      return result;
  }
  
  LayoutRect RenderLayer::boundingBox(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5849,11 ***</span>
  #if !ASSERT_DISABLED
      LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(*this));
  #endif
  
      auto computeLayersUnion = [this, &amp;unionBounds, flags, descendantFlags] (const RenderLayer&amp; childLayer) {
<span class="line-modified">!         if (!(flags &amp; IncludeCompositedDescendants) &amp;&amp; childLayer.isComposited())</span>
              return;
          LayoutRect childBounds = childLayer.calculateLayerBounds(this, childLayer.offsetFromAncestor(this), descendantFlags);
          // Ignore child layer (and behave as if we had overflow: hidden) when it is positioned off the parent layer so much
          // that we hit the max LayoutUnit value.
          unionBounds.checkedUnite(childBounds);
<span class="line-new-header">--- 6092,11 ---</span>
  #if !ASSERT_DISABLED
      LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(*this));
  #endif
  
      auto computeLayersUnion = [this, &amp;unionBounds, flags, descendantFlags] (const RenderLayer&amp; childLayer) {
<span class="line-modified">!         if (!(flags &amp; IncludeCompositedDescendants) &amp;&amp; (childLayer.isComposited() || childLayer.paintsIntoProvidedBacking()))</span>
              return;
          LayoutRect childBounds = childLayer.calculateLayerBounds(this, childLayer.offsetFromAncestor(this), descendantFlags);
          // Ignore child layer (and behave as if we had overflow: hidden) when it is positioned off the parent layer so much
          // that we hit the max LayoutUnit value.
          unionBounds.checkedUnite(childBounds);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5904,11 ***</span>
  }
  
  RenderLayerBacking* RenderLayer::ensureBacking()
  {
      if (!m_backing) {
<span class="line-modified">!         m_backing = std::make_unique&lt;RenderLayerBacking&gt;(*this);</span>
          compositor().layerBecameComposited(*this);
  
          updateFilterPaintingStrategy();
      }
      return m_backing.get();
<span class="line-new-header">--- 6147,11 ---</span>
  }
  
  RenderLayerBacking* RenderLayer::ensureBacking()
  {
      if (!m_backing) {
<span class="line-modified">!         m_backing = makeUnique&lt;RenderLayerBacking&gt;(*this);</span>
          compositor().layerBecameComposited(*this);
  
          updateFilterPaintingStrategy();
      }
      return m_backing.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6043,11 ***</span>
      for (auto iter = list.rbegin(); iter != list.rend(); ++iter) {
          const auto* childLayer = *iter;
          if (childLayer-&gt;isComposited())
              continue;
  
<span class="line-modified">!         if (!childLayer-&gt;canUseConvertToLayerCoords())</span>
              continue;
  
          LayoutRect childLocalRect(localRect);
          childLocalRect.move(-childLayer-&gt;offsetFromAncestor(this));
  
<span class="line-new-header">--- 6286,11 ---</span>
      for (auto iter = list.rbegin(); iter != list.rend(); ++iter) {
          const auto* childLayer = *iter;
          if (childLayer-&gt;isComposited())
              continue;
  
<span class="line-modified">!         if (!childLayer-&gt;canUseOffsetFromAncestor())</span>
              continue;
  
          LayoutRect childLocalRect(localRect);
          childLocalRect.move(-childLayer-&gt;offsetFromAncestor(this));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6155,11 ***</span>
              return;
          }
  
          if (is&lt;RenderText&gt;(child)) {
              const auto&amp; renderText = downcast&lt;RenderText&gt;(child);
<span class="line-modified">!             if (renderText.linesBoundingBox().isEmpty())</span>
                  continue;
  
              if (renderer.style().userSelect() != UserSelect::None)
                  request.setHasPaintedContent();
  
<span class="line-new-header">--- 6398,11 ---</span>
              return;
          }
  
          if (is&lt;RenderText&gt;(child)) {
              const auto&amp; renderText = downcast&lt;RenderText&gt;(child);
<span class="line-modified">!             if (!renderText.hasRenderedText())</span>
                  continue;
  
              if (renderer.style().userSelect() != UserSelect::None)
                  request.setHasPaintedContent();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6294,14 ***</span>
  
  void RenderLayer::styleChanged(StyleDifference diff, const RenderStyle* oldStyle)
  {
      setIsNormalFlowOnly(shouldBeNormalFlowOnly());
  
<span class="line-modified">!     if (setIsStackingContext(shouldBeStackingContext())) {</span>
  #if ENABLE(CSS_COMPOSITING)
          if (parent()) {
<span class="line-modified">!             if (isStackingContext()) {</span>
                  if (!hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; hasNotIsolatedBlendingDescendants())
                      parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
              } else {
                  if (hasNotIsolatedBlendingDescendantsStatusDirty())
                      parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
<span class="line-new-header">--- 6537,14 ---</span>
  
  void RenderLayer::styleChanged(StyleDifference diff, const RenderStyle* oldStyle)
  {
      setIsNormalFlowOnly(shouldBeNormalFlowOnly());
  
<span class="line-modified">!     if (setIsCSSStackingContext(shouldBeCSSStackingContext())) {</span>
  #if ENABLE(CSS_COMPOSITING)
          if (parent()) {
<span class="line-modified">!             if (isCSSStackingContext()) {</span>
                  if (!hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; hasNotIsolatedBlendingDescendants())
                      parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
              } else {
                  if (hasNotIsolatedBlendingDescendantsStatusDirty())
                      parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6322,11 ***</span>
          }
      }
  
      if (renderer().isHTMLMarquee() &amp;&amp; renderer().style().marqueeBehavior() != MarqueeBehavior::None &amp;&amp; renderer().isBox()) {
          if (!m_marquee)
<span class="line-modified">!             m_marquee = std::make_unique&lt;RenderMarquee&gt;(this);</span>
          m_marquee-&gt;updateMarqueeStyle();
      } else if (m_marquee)
          m_marquee = nullptr;
  
      updateScrollbarsAfterStyleChange(oldStyle);
<span class="line-new-header">--- 6565,11 ---</span>
          }
      }
  
      if (renderer().isHTMLMarquee() &amp;&amp; renderer().style().marqueeBehavior() != MarqueeBehavior::None &amp;&amp; renderer().isBox()) {
          if (!m_marquee)
<span class="line-modified">!             m_marquee = makeUnique&lt;RenderMarquee&gt;(this);</span>
          m_marquee-&gt;updateMarqueeStyle();
      } else if (m_marquee)
          m_marquee = nullptr;
  
      updateScrollbarsAfterStyleChange(oldStyle);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6534,11 ***</span>
  void RenderLayer::ensureLayerFilters()
  {
      if (m_filters)
          return;
  
<span class="line-modified">!     m_filters = std::make_unique&lt;RenderLayerFilters&gt;(*this);</span>
  }
  
  void RenderLayer::clearLayerFilters()
  {
      m_filters = nullptr;
<span class="line-new-header">--- 6777,11 ---</span>
  void RenderLayer::ensureLayerFilters()
  {
      if (m_filters)
          return;
  
<span class="line-modified">!     m_filters = makeUnique&lt;RenderLayerFilters&gt;(*this);</span>
  }
  
  void RenderLayer::clearLayerFilters()
  {
      m_filters = nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6590,10 ***</span>
<span class="line-new-header">--- 6833,93 ---</span>
          element-&gt;invalidateStyleAndLayerComposition();
      }
      renderer().repaint();
  }
  
<span class="line-added">+ bool RenderLayer::isTransparentOrFullyClippedRespectingParentFrames() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     static const double minimumVisibleOpacity = 0.01;</span>
<span class="line-added">+ </span>
<span class="line-added">+     float currentOpacity = 1;</span>
<span class="line-added">+     for (auto* layer = this; layer; layer = parentLayerCrossFrame(*layer)) {</span>
<span class="line-added">+         currentOpacity *= layer-&gt;renderer().style().opacity();</span>
<span class="line-added">+         if (currentOpacity &lt; minimumVisibleOpacity)</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto hasEmptyClipRect = [] (const RenderLayer&amp; layer) -&gt; bool {</span>
<span class="line-added">+         auto* frameView = layer.renderer().document().view();</span>
<span class="line-added">+         if (!frameView)</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto* renderView = frameView-&gt;renderView();</span>
<span class="line-added">+         if (!renderView)</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto* renderViewLayer = renderView-&gt;layer();</span>
<span class="line-added">+         if (!renderViewLayer)</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (is&lt;HTMLFrameOwnerElement&gt;(layer.renderer().element()) &amp;&amp; layer.visibleSize().isEmpty())</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+         LayoutRect layerBounds;</span>
<span class="line-added">+         ClipRect backgroundRect;</span>
<span class="line-added">+         ClipRect foregroundRect;</span>
<span class="line-added">+         layer.calculateRects({ renderViewLayer, TemporaryClipRects }, LayoutRect::infiniteRect(), layerBounds, backgroundRect, foregroundRect, layer.offsetFromAncestor(renderViewLayer));</span>
<span class="line-added">+         return backgroundRect.isEmpty();</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto* layer = this; layer; layer = enclosingFrameRenderLayer(*layer)) {</span>
<span class="line-added">+         if (hasEmptyClipRect(*layer))</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RenderLayer::invalidateEventRegion()</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">+     auto* compositingLayer = enclosingCompositingLayerForRepaint();</span>
<span class="line-added">+     if (!compositingLayer)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto maintainsEventRegion = [&amp;] {</span>
<span class="line-added">+         // UI side scroll overlap testing.</span>
<span class="line-added">+         if (!compositingLayer-&gt;isRenderViewLayer())</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+ #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">+         // UI side touch-action resolution.</span>
<span class="line-added">+         if (renderer().document().mayHaveElementsWithNonAutoTouchAction())</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!maintainsEventRegion())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     compositingLayer-&gt;setNeedsCompositingConfigurationUpdate();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp; ts, ClipRectsType clipRectsType)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (clipRectsType) {</span>
<span class="line-added">+     case PaintingClipRects: ts &lt;&lt; &quot;painting&quot;; break;</span>
<span class="line-added">+     case RootRelativeClipRects: ts &lt;&lt; &quot;root-relative&quot;; break;</span>
<span class="line-added">+     case AbsoluteClipRects: ts &lt;&lt; &quot;absolute&quot;; break;</span>
<span class="line-added">+     case TemporaryClipRects: ts &lt;&lt; &quot;temporary&quot;; break;</span>
<span class="line-added">+     case NumCachedClipRectsTypes:</span>
<span class="line-added">+     case AllClipRectTypes:</span>
<span class="line-added">+         ts &lt;&lt; &quot;?&quot;;</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return ts;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayer&amp; layer)
  {
      ts &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layer.size();
      if (layer.transform())
          ts &lt;&lt; &quot; has transform&quot;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6608,20 ***</span>
      if (layer.isComposited())
          ts &lt;&lt; &quot; &quot; &lt;&lt; *layer.backing();
      return ts;
  }
  
  } // namespace WebCore
  
  #if ENABLE(TREE_DEBUGGING)
  
  void showLayerTree(const WebCore::RenderLayer* layer)
  {
      if (!layer)
          return;
  
<span class="line-modified">!     WTF::String output = externalRepresentation(&amp;layer-&gt;renderer().frame(), WebCore::RenderAsTextShowAllLayers | WebCore::RenderAsTextShowLayerNesting | WebCore::RenderAsTextShowCompositedLayers | WebCore::RenderAsTextShowAddresses | WebCore::RenderAsTextShowIDAndClass | WebCore::RenderAsTextDontUpdateLayout | WebCore::RenderAsTextShowLayoutState | WebCore::RenderAsTextShowOverflow | WebCore::RenderAsTextShowSVGGeometry | WebCore::RenderAsTextShowLayerFragments);</span>
      fprintf(stderr, &quot;\n%s\n&quot;, output.utf8().data());
  }
  
  void showLayerTree(const WebCore::RenderObject* renderer)
  {
<span class="line-new-header">--- 6934,56 ---</span>
      if (layer.isComposited())
          ts &lt;&lt; &quot; &quot; &lt;&lt; *layer.backing();
      return ts;
  }
  
<span class="line-added">+ TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayer::ClipRectsContext&amp; context)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ts.dumpProperty(&quot;root layer:&quot;, context.rootLayer);</span>
<span class="line-added">+     ts.dumpProperty(&quot;type:&quot;, context.clipRectsType);</span>
<span class="line-added">+     ts.dumpProperty(&quot;overflow-clip:&quot;, context.respectOverflowClip == IgnoreOverflowClip ? &quot;ignore&quot; : &quot;respect&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return ts;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, IndirectCompositingReason reason)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (reason) {</span>
<span class="line-added">+     case IndirectCompositingReason::None: ts &lt;&lt; &quot;none&quot;; break;</span>
<span class="line-added">+     case IndirectCompositingReason::Stacking: ts &lt;&lt; &quot;stacking&quot;; break;</span>
<span class="line-added">+     case IndirectCompositingReason::OverflowScrollPositioning: ts &lt;&lt; &quot;overflow positioning&quot;; break;</span>
<span class="line-added">+     case IndirectCompositingReason::Overlap: ts &lt;&lt; &quot;overlap&quot;; break;</span>
<span class="line-added">+     case IndirectCompositingReason::BackgroundLayer: ts &lt;&lt; &quot;background layer&quot;; break;</span>
<span class="line-added">+     case IndirectCompositingReason::GraphicalEffect: ts &lt;&lt; &quot;graphical effect&quot;; break;</span>
<span class="line-added">+     case IndirectCompositingReason::Perspective: ts &lt;&lt; &quot;perspective&quot;; break;</span>
<span class="line-added">+     case IndirectCompositingReason::Preserve3D: ts &lt;&lt; &quot;preserve-3d&quot;; break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return ts;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace WebCore
  
  #if ENABLE(TREE_DEBUGGING)
  
  void showLayerTree(const WebCore::RenderLayer* layer)
  {
      if (!layer)
          return;
  
<span class="line-modified">!     WTF::String output = externalRepresentation(&amp;layer-&gt;renderer().frame(), {</span>
<span class="line-added">+         WebCore::RenderAsTextFlag::ShowAllLayers,</span>
<span class="line-added">+         WebCore::RenderAsTextFlag::ShowLayerNesting,</span>
<span class="line-added">+         WebCore::RenderAsTextFlag::ShowCompositedLayers,</span>
<span class="line-added">+         WebCore::RenderAsTextFlag::ShowOverflow,</span>
<span class="line-added">+         WebCore::RenderAsTextFlag::ShowSVGGeometry,</span>
<span class="line-added">+         WebCore::RenderAsTextFlag::ShowLayerFragments,</span>
<span class="line-added">+         WebCore::RenderAsTextFlag::ShowAddresses,</span>
<span class="line-added">+         WebCore::RenderAsTextFlag::ShowIDAndClass,</span>
<span class="line-added">+         WebCore::RenderAsTextFlag::DontUpdateLayout,</span>
<span class="line-added">+         WebCore::RenderAsTextFlag::ShowLayoutState,</span>
<span class="line-added">+     });</span>
      fprintf(stderr, &quot;\n%s\n&quot;, output.utf8().data());
  }
  
  void showLayerTree(const WebCore::RenderObject* renderer)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6631,11 ***</span>
  }
  
  static void outputPaintOrderTreeLegend(TextStream&amp; stream)
  {
      stream.nextLine();
<span class="line-modified">!     stream &lt;&lt; &quot;(S)tacking Context, (N)ormal flow only, (O)verflow clip, (A)lpha (opacity or mask), has (B)lend mode, (I)solates blending, (T)ransform-ish, (F)ilter, Fi(X)ed position, (C)omposited, (c)omposited descendant\n&quot;</span>
          &quot;Dirty (z)-lists, Dirty (n)ormal flow lists\n&quot;
          &quot;Traversal needs: requirements (t)raversal on descendants, (b)acking or hierarchy traversal on descendants, (r)equirements traversal on all descendants, requirements traversal on all (s)ubsequent layers, (h)ierarchy traversal on all descendants, update of paint (o)rder children\n&quot;
          &quot;Update needs:    post-(l)ayout requirements, (g)eometry, (k)ids geometry, (c)onfig, layer conne(x)ion, (s)crolling tree\n&quot;;
      stream.nextLine();
  }
<span class="line-new-header">--- 6993,11 ---</span>
  }
  
  static void outputPaintOrderTreeLegend(TextStream&amp; stream)
  {
      stream.nextLine();
<span class="line-modified">!     stream &lt;&lt; &quot;(S)tacking Context/(F)orced SC/O(P)portunistic SC, (N)ormal flow only, (O)verflow clip, (A)lpha (opacity or mask), has (B)lend mode, (I)solates blending, (T)ransform-ish, (F)ilter, Fi(X)ed position, Behaves as fi(x)ed, (C)omposited, (P)rovides backing/uses (p)rovided backing/paints to (a)ncestor, (c)omposited descendant, (s)scrolling ancestor, (t)transformed ancestor\n&quot;</span>
          &quot;Dirty (z)-lists, Dirty (n)ormal flow lists\n&quot;
          &quot;Traversal needs: requirements (t)raversal on descendants, (b)acking or hierarchy traversal on descendants, (r)equirements traversal on all descendants, requirements traversal on all (s)ubsequent layers, (h)ierarchy traversal on all descendants, update of paint (o)rder children\n&quot;
          &quot;Update needs:    post-(l)ayout requirements, (g)eometry, (k)ids geometry, (c)onfig, layer conne(x)ion, (s)crolling tree\n&quot;;
      stream.nextLine();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6647,21 ***</span>
          stream &lt;&lt; &quot; &quot;;
  }
  
  static void outputPaintOrderTreeRecursive(TextStream&amp; stream, const WebCore::RenderLayer&amp; layer, const char* prefix, unsigned depth = 0)
  {
<span class="line-modified">!     stream &lt;&lt; (layer.isStackingContext() ? &quot;S&quot; : &quot;-&quot;);</span>
      stream &lt;&lt; (layer.isNormalFlowOnly() ? &quot;N&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.renderer().hasOverflowClip() ? &quot;O&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.isTransparent() ? &quot;A&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.hasBlendMode() ? &quot;B&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.isolatesBlending() ? &quot;I&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.renderer().hasTransformRelatedProperty() ? &quot;T&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.hasFilter() ? &quot;F&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.renderer().isFixedPositioned() ? &quot;X&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.isComposited() ? &quot;C&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.hasCompositingDescendant() ? &quot;c&quot; : &quot;-&quot;);
  
      stream &lt;&lt; &quot; &quot;;
  
      stream &lt;&lt; (layer.zOrderListsDirty() ? &quot;z&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.normalFlowListDirty() ? &quot;n&quot; : &quot;-&quot;);
<span class="line-new-header">--- 7009,42 ---</span>
          stream &lt;&lt; &quot; &quot;;
  }
  
  static void outputPaintOrderTreeRecursive(TextStream&amp; stream, const WebCore::RenderLayer&amp; layer, const char* prefix, unsigned depth = 0)
  {
<span class="line-modified">!     stream &lt;&lt; (layer.isCSSStackingContext() ? &quot;S&quot; : (layer.isForcedStackingContext() ? &quot;F&quot; : (layer.isOpportunisticStackingContext() ? &quot;P&quot; : &quot;-&quot;)));</span>
      stream &lt;&lt; (layer.isNormalFlowOnly() ? &quot;N&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.renderer().hasOverflowClip() ? &quot;O&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.isTransparent() ? &quot;A&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.hasBlendMode() ? &quot;B&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.isolatesBlending() ? &quot;I&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.renderer().hasTransformRelatedProperty() ? &quot;T&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.hasFilter() ? &quot;F&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.renderer().isFixedPositioned() ? &quot;X&quot; : &quot;-&quot;);
<span class="line-added">+     stream &lt;&lt; (layer.behavesAsFixed() ? &quot;x&quot; : &quot;-&quot;);</span>
      stream &lt;&lt; (layer.isComposited() ? &quot;C&quot; : &quot;-&quot;);
<span class="line-added">+ </span>
<span class="line-added">+     auto compositedPaintingDestinationString = [&amp;layer]() {</span>
<span class="line-added">+         if (layer.paintsIntoProvidedBacking())</span>
<span class="line-added">+             return &quot;p&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!layer.isComposited())</span>
<span class="line-added">+             return &quot;-&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (layer.backing()-&gt;hasBackingSharingLayers())</span>
<span class="line-added">+             return &quot;P&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (layer.backing()-&gt;paintsIntoCompositedAncestor())</span>
<span class="line-added">+             return &quot;a&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+         return &quot;-&quot;;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     stream &lt;&lt; compositedPaintingDestinationString();</span>
      stream &lt;&lt; (layer.hasCompositingDescendant() ? &quot;c&quot; : &quot;-&quot;);
<span class="line-added">+     stream &lt;&lt; (layer.hasCompositedScrollingAncestor() ? &quot;s&quot; : &quot;-&quot;);</span>
<span class="line-added">+     stream &lt;&lt; (layer.hasTransformedAncestor() ? &quot;t&quot; : &quot;-&quot;);</span>
  
      stream &lt;&lt; &quot; &quot;;
  
      stream &lt;&lt; (layer.zOrderListsDirty() ? &quot;z&quot; : &quot;-&quot;);
      stream &lt;&lt; (layer.normalFlowListDirty() ? &quot;n&quot; : &quot;-&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6695,15 ***</span>
      stream &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layerRect;
      if (layer.isComposited()) {
          auto&amp; backing = *layer.backing();
          stream &lt;&lt; &quot; (layerID &quot; &lt;&lt; backing.graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;)&quot;;
  
          auto scrollingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::Scrolling);
          auto frameHostingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::FrameHosting);
          auto viewportConstrainedNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::ViewportConstrained);
  
<span class="line-modified">!         if (scrollingNodeID || frameHostingNodeID || viewportConstrainedNodeID) {</span>
              stream &lt;&lt; &quot; {&quot;;
              bool first = true;
              if (scrollingNodeID) {
                  stream &lt;&lt; &quot;sc &quot; &lt;&lt; scrollingNodeID;
                  first = false;
<span class="line-new-header">--- 7078,19 ---</span>
      stream &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layerRect;
      if (layer.isComposited()) {
          auto&amp; backing = *layer.backing();
          stream &lt;&lt; &quot; (layerID &quot; &lt;&lt; backing.graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;)&quot;;
  
<span class="line-added">+         if (layer.indirectCompositingReason() != WebCore::IndirectCompositingReason::None)</span>
<span class="line-added">+             stream &lt;&lt; &quot; &quot; &lt;&lt; layer.indirectCompositingReason();</span>
<span class="line-added">+ </span>
          auto scrollingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::Scrolling);
          auto frameHostingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::FrameHosting);
          auto viewportConstrainedNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::ViewportConstrained);
<span class="line-added">+         auto positionedNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::Positioning);</span>
  
<span class="line-modified">!         if (scrollingNodeID || frameHostingNodeID || viewportConstrainedNodeID || positionedNodeID) {</span>
              stream &lt;&lt; &quot; {&quot;;
              bool first = true;
              if (scrollingNodeID) {
                  stream &lt;&lt; &quot;sc &quot; &lt;&lt; scrollingNodeID;
                  first = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6718,10 ***</span>
<span class="line-new-header">--- 7105,17 ---</span>
  
              if (viewportConstrainedNodeID) {
                  if (!first)
                      stream &lt;&lt; &quot;, &quot;;
                  stream &lt;&lt; &quot;vc &quot; &lt;&lt; viewportConstrainedNodeID;
<span class="line-added">+                 first = false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (positionedNodeID) {</span>
<span class="line-added">+                 if (!first)</span>
<span class="line-added">+                     stream &lt;&lt; &quot;, &quot;;</span>
<span class="line-added">+                 stream &lt;&lt; &quot;pos &quot; &lt;&lt; positionedNodeID;</span>
              }
  
              stream &lt;&lt; &quot;}&quot;;
          }
      }
</pre>
<center><a href="RenderInline.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>