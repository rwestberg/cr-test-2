<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   4  *  Copyright (C) 2009 Torch Mobile, Inc.
   5  *  Copyright (C) 2015 Jordan Harband (ljharb@gmail.com)
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;StringPrototype.h&quot;
  25 
  26 #include &quot;BuiltinNames.h&quot;
  27 #include &quot;ButterflyInlines.h&quot;
  28 #include &quot;CachedCall.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;FrameTracers.h&quot;
  31 #include &quot;InterpreterInlines.h&quot;
  32 #include &quot;IntlCollator.h&quot;
  33 #include &quot;IntlObject.h&quot;
  34 #include &quot;JITCodeInlines.h&quot;
  35 #include &quot;JSArray.h&quot;
  36 #include &quot;JSCBuiltins.h&quot;
  37 #include &quot;JSCInlines.h&quot;
  38 #include &quot;JSFunction.h&quot;
  39 #include &quot;JSGlobalObjectFunctions.h&quot;
  40 #include &quot;JSStringIterator.h&quot;
  41 #include &quot;Lookup.h&quot;
  42 #include &quot;ObjectPrototype.h&quot;
  43 #include &quot;ParseInt.h&quot;
  44 #include &quot;PropertyNameArray.h&quot;
  45 #include &quot;RegExpCache.h&quot;
  46 #include &quot;RegExpConstructor.h&quot;
  47 #include &quot;RegExpGlobalDataInlines.h&quot;
  48 #include &quot;StringPrototypeInlines.h&quot;
  49 #include &quot;SuperSampler.h&quot;
  50 #include &lt;algorithm&gt;
  51 #include &lt;unicode/uconfig.h&gt;
  52 #include &lt;unicode/unorm2.h&gt;
  53 #include &lt;unicode/ustring.h&gt;
  54 #include &lt;wtf/ASCIICType.h&gt;
  55 #include &lt;wtf/MathExtras.h&gt;
  56 #include &lt;wtf/text/StringBuilder.h&gt;
  57 #include &lt;wtf/text/StringView.h&gt;
  58 #include &lt;wtf/unicode/Collator.h&gt;
  59 
  60 namespace JSC {
  61 
  62 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(StringPrototype);
  63 
  64 EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(ExecState*);
  65 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(ExecState*);
  66 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(ExecState*);
  67 EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(ExecState*);
  68 EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(ExecState*);
  69 EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(ExecState*);
  70 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(ExecState*);
  71 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(ExecState*);
  72 EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(ExecState*);
  73 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(ExecState*);
  74 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(ExecState*);
  75 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(ExecState*);
  76 EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(ExecState*);
  77 EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(ExecState*);
  78 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(ExecState*);
  79 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(ExecState*);
  80 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(ExecState*);
  81 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(ExecState*);
  82 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(ExecState*);
  83 EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(ExecState*);
  84 EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(ExecState*);
  85 EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(ExecState*);
  86 EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(ExecState*);
  87 EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(ExecState*);
  88 
  89 }
  90 
  91 #include &quot;StringPrototype.lut.h&quot;
  92 
  93 namespace JSC {
  94 
  95 const ClassInfo StringPrototype::s_info = { &quot;String&quot;, &amp;StringObject::s_info, &amp;stringPrototypeTable, nullptr, CREATE_METHOD_TABLE(StringPrototype) };
  96 
  97 /* Source for StringConstructor.lut.h
  98 @begin stringPrototypeTable
  99     concat    JSBuiltin    DontEnum|Function 1
 100     match     JSBuiltin    DontEnum|Function 1
 101     padStart  JSBuiltin    DontEnum|Function 1
 102     padEnd    JSBuiltin    DontEnum|Function 1
 103     repeat    JSBuiltin    DontEnum|Function 1
 104     replace   JSBuiltin    DontEnum|Function 2
 105     search    JSBuiltin    DontEnum|Function 1
 106     split     JSBuiltin    DontEnum|Function 1
 107     anchor    JSBuiltin    DontEnum|Function 1
 108     big       JSBuiltin    DontEnum|Function 0
 109     bold      JSBuiltin    DontEnum|Function 0
 110     blink     JSBuiltin    DontEnum|Function 0
 111     fixed     JSBuiltin    DontEnum|Function 0
 112     fontcolor JSBuiltin    DontEnum|Function 1
 113     fontsize  JSBuiltin    DontEnum|Function 1
 114     italics   JSBuiltin    DontEnum|Function 0
 115     link      JSBuiltin    DontEnum|Function 1
 116     small     JSBuiltin    DontEnum|Function 0
 117     strike    JSBuiltin    DontEnum|Function 0
 118     sub       JSBuiltin    DontEnum|Function 0
 119     sup       JSBuiltin    DontEnum|Function 0
 120 @end
 121 */
 122 
 123 // ECMA 15.5.4
 124 StringPrototype::StringPrototype(VM&amp; vm, Structure* structure)
 125     : StringObject(vm, structure)
 126 {
 127 }
 128 
 129 void StringPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject, JSString* nameAndMessage)
 130 {
 131     Base::finishCreation(vm, nameAndMessage);
 132     ASSERT(inherits(vm, info()));
 133 
 134     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;toString, stringProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
 135     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;valueOf, stringProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
 136     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;charAt&quot;, stringProtoFuncCharAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharAtIntrinsic);
 137     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;charCodeAt&quot;, stringProtoFuncCharCodeAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
 138     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;codePointAt&quot;, stringProtoFuncCodePointAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 139     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;indexOf&quot;, stringProtoFuncIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 140     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;lastIndexOf&quot;, stringProtoFuncLastIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 141     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceUsingRegExpPrivateName(), stringProtoFuncReplaceUsingRegExp, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, StringPrototypeReplaceRegExpIntrinsic);
 142     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceUsingStringSearchPrivateName(), stringProtoFuncReplaceUsingStringSearch, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 143     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;slice&quot;, stringProtoFuncSlice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, StringPrototypeSliceIntrinsic);
 144     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substr&quot;, stringProtoFuncSubstr, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 145     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substring&quot;, stringProtoFuncSubstring, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 146     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;toLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeToLowerCaseIntrinsic);
 147     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 148     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;localeCompare&quot;, stringProtoFuncLocaleCompare, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 149 #if ENABLE(INTL)
 150     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleLowerCase&quot;, stringProtoFuncToLocaleLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 151     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleUpperCase&quot;, stringProtoFuncToLocaleUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 152 #else
 153     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 154     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 155 #endif
 156     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;trim&quot;, stringProtoFuncTrim, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 157     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;startsWith&quot;, stringProtoFuncStartsWith, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 158     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;endsWith&quot;, stringProtoFuncEndsWith, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 159     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;includes&quot;, stringProtoFuncIncludes, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 160     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;normalize&quot;, stringProtoFuncNormalize, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 161     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().charCodeAtPrivateName(), stringProtoFuncCharCodeAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
 162 
 163     JSFunction* trimStartFunction = JSFunction::create(vm, globalObject, 0, &quot;trimStart&quot;_s, stringProtoFuncTrimStart, NoIntrinsic);
 164     JSFunction* trimEndFunction = JSFunction::create(vm, globalObject, 0, &quot;trimEnd&quot;_s, stringProtoFuncTrimEnd, NoIntrinsic);
 165     putDirectWithoutTransition(vm, Identifier::fromString(&amp;vm, &quot;trimStart&quot;), trimStartFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 166     putDirectWithoutTransition(vm, Identifier::fromString(&amp;vm, &quot;trimLeft&quot;), trimStartFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 167     putDirectWithoutTransition(vm, Identifier::fromString(&amp;vm, &quot;trimEnd&quot;), trimEndFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 168     putDirectWithoutTransition(vm, Identifier::fromString(&amp;vm, &quot;trimRight&quot;), trimEndFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 169 
 170     JSFunction* iteratorFunction = JSFunction::create(vm, globalObject, 0, &quot;[Symbol.iterator]&quot;_s, stringProtoFuncIterator, NoIntrinsic);
 171     putDirectWithoutTransition(vm, vm.propertyNames-&gt;iteratorSymbol, iteratorFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 172 
 173     // The constructor will be added later, after StringConstructor has been built
 174     putDirectWithoutTransition(vm, vm.propertyNames-&gt;length, jsNumber(0), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 175 }
 176 
 177 StringPrototype* StringPrototype::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 178 {
 179     JSString* empty = jsEmptyString(&amp;vm);
 180     StringPrototype* prototype = new (NotNull, allocateCell&lt;StringPrototype&gt;(vm.heap)) StringPrototype(vm, structure);
 181     prototype-&gt;finishCreation(vm, globalObject, empty);
 182     return prototype;
 183 }
 184 
 185 // ------------------------------ Functions --------------------------
 186 
 187 static NEVER_INLINE void substituteBackreferencesSlow(StringBuilder&amp; result, StringView replacement, StringView source, const int* ovector, RegExp* reg, size_t i)
 188 {
 189     bool hasNamedCaptures = reg &amp;&amp; reg-&gt;hasNamedCaptures();
 190     int offset = 0;
 191     do {
 192         if (i + 1 == replacement.length())
 193             break;
 194 
 195         UChar ref = replacement[i + 1];
 196         if (ref == &#39;$&#39;) {
 197             // &quot;$$&quot; -&gt; &quot;$&quot;
 198             ++i;
 199             result.append(replacement.substring(offset, i - offset));
 200             offset = i + 1;
 201             continue;
 202         }
 203 
 204         int backrefStart;
 205         int backrefLength;
 206         int advance = 0;
 207         if (ref == &#39;&amp;&#39;) {
 208             backrefStart = ovector[0];
 209             backrefLength = ovector[1] - backrefStart;
 210         } else if (ref == &#39;`&#39;) {
 211             backrefStart = 0;
 212             backrefLength = ovector[0];
 213         } else if (ref == &#39;\&#39;&#39;) {
 214             backrefStart = ovector[1];
 215             backrefLength = source.length() - backrefStart;
 216         } else if (reg &amp;&amp; ref == &#39;&lt;&#39;) {
 217             // Named back reference
 218             if (!hasNamedCaptures) {
 219                 result.append(replacement.substring(i, 2));
 220                 offset = i + 2;
 221                 advance = 1;
 222                 continue;
 223             }
 224 
 225             size_t closingBracket = replacement.find(&#39;&gt;&#39;, i + 2);
 226             if (closingBracket == WTF::notFound) {
 227                 // FIXME: https://bugs.webkit.org/show_bug.cgi?id=176434
 228                 // Current proposed spec change throws a syntax error in this case.
 229                 // We have made the case that it makes more sense to treat this a literal
 230                 // If throwSyntaxError(exec, scope, &quot;Missing closing &#39;&gt;&#39; in replacement text&quot;);
 231                 continue;
 232             }
 233 
 234             unsigned nameLength = closingBracket - i - 2;
 235             unsigned backrefIndex = reg-&gt;subpatternForName(replacement.substring(i + 2, nameLength).toString());
 236 
 237             if (!backrefIndex || backrefIndex &gt; reg-&gt;numSubpatterns()) {
 238                 // FIXME: https://bugs.webkit.org/show_bug.cgi?id=176434
 239                 // Proposed spec change throws a throw syntax error in this case.
 240                 // We have made the case that a non-existent back reference should be replaced with
 241                 // and empty string.
 242                 // throwSyntaxError(exec, scope, makeString(&quot;Replacement text references non-existent backreference \&quot;&quot; + replacement.substring(i + 2, nameLength).toString()));
 243                 backrefStart = 0;
 244                 backrefLength = 0;
 245             } else {
 246                 backrefStart = ovector[2 * backrefIndex];
 247                 backrefLength = ovector[2 * backrefIndex + 1] - backrefStart;
 248             }
 249             advance = nameLength + 1;
 250         } else if (reg &amp;&amp; isASCIIDigit(ref)) {
 251             // 1- and 2-digit back references are allowed
 252             unsigned backrefIndex = ref - &#39;0&#39;;
 253             if (backrefIndex &gt; reg-&gt;numSubpatterns())
 254                 continue;
 255             if (replacement.length() &gt; i + 2) {
 256                 ref = replacement[i + 2];
 257                 if (isASCIIDigit(ref)) {
 258                     backrefIndex = 10 * backrefIndex + ref - &#39;0&#39;;
 259                     if (backrefIndex &gt; reg-&gt;numSubpatterns())
 260                         backrefIndex = backrefIndex / 10;   // Fall back to the 1-digit reference
 261                     else
 262                         advance = 1;
 263                 }
 264             }
 265             if (!backrefIndex)
 266                 continue;
 267             backrefStart = ovector[2 * backrefIndex];
 268             backrefLength = ovector[2 * backrefIndex + 1] - backrefStart;
 269         } else
 270             continue;
 271 
 272         if (i - offset)
 273             result.append(replacement.substring(offset, i - offset));
 274         i += 1 + advance;
 275         offset = i + 1;
 276         if (backrefStart &gt;= 0)
 277             result.append(source.substring(backrefStart, backrefLength));
 278     } while ((i = replacement.find(&#39;$&#39;, i + 1)) != notFound);
 279 
 280     if (replacement.length() - offset)
 281         result.append(replacement.substring(offset));
 282 }
 283 
 284 inline void substituteBackreferencesInline(StringBuilder&amp; result, const String&amp; replacement, StringView source, const int* ovector, RegExp* reg)
 285 {
 286     size_t i = replacement.find(&#39;$&#39;);
 287     if (UNLIKELY(i != notFound))
 288         return substituteBackreferencesSlow(result, replacement, source, ovector, reg, i);
 289 
 290     result.append(replacement);
 291 }
 292 
 293 void substituteBackreferences(StringBuilder&amp; result, const String&amp; replacement, StringView source, const int* ovector, RegExp* reg)
 294 {
 295     substituteBackreferencesInline(result, replacement, source, ovector, reg);
 296 }
 297 
 298 struct StringRange {
 299     StringRange(int pos, int len)
 300         : position(pos)
 301         , length(len)
 302     {
 303     }
 304 
 305     StringRange()
 306     {
 307     }
 308 
 309     int position;
 310     int length;
 311 };
 312 
 313 static ALWAYS_INLINE JSString* jsSpliceSubstrings(ExecState* exec, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount)
 314 {
 315     VM&amp; vm = exec-&gt;vm();
 316     auto scope = DECLARE_THROW_SCOPE(vm);
 317 
 318     if (rangeCount == 1) {
 319         int sourceSize = source.length();
 320         int position = substringRanges[0].position;
 321         int length = substringRanges[0].length;
 322         if (position &lt;= 0 &amp;&amp; length &gt;= sourceSize)
 323             return sourceVal;
 324         // We could call String::substringSharingImpl(), but this would result in redundant checks.
 325         RELEASE_AND_RETURN(scope, jsString(exec, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));
 326     }
 327 
 328     // We know that the sum of substringRanges lengths cannot exceed length of
 329     // source because the substringRanges were computed from the source string
 330     // in removeUsingRegExpSearch(). Hence, totalLength cannot exceed
 331     // String::MaxLength, and therefore, cannot overflow.
 332     Checked&lt;int, AssertNoOverflow&gt; totalLength = 0;
 333     for (int i = 0; i &lt; rangeCount; i++)
 334         totalLength += substringRanges[i].length;
 335     ASSERT(totalLength &lt;= String::MaxLength);
 336 
 337     if (!totalLength)
 338         return jsEmptyString(exec);
 339 
 340     if (source.is8Bit()) {
 341         LChar* buffer;
 342         const LChar* sourceData = source.characters8();
 343         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 344         if (!impl) {
 345             throwOutOfMemoryError(exec, scope);
 346             return nullptr;
 347         }
 348 
 349         Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 350         for (int i = 0; i &lt; rangeCount; i++) {
 351             if (int srcLen = substringRanges[i].length) {
 352                 StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 353                 bufferPos += srcLen;
 354             }
 355         }
 356 
 357         RELEASE_AND_RETURN(scope, jsString(exec, WTFMove(impl)));
 358     }
 359 
 360     UChar* buffer;
 361     const UChar* sourceData = source.characters16();
 362 
 363     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 364     if (!impl) {
 365         throwOutOfMemoryError(exec, scope);
 366         return nullptr;
 367     }
 368 
 369     Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 370     for (int i = 0; i &lt; rangeCount; i++) {
 371         if (int srcLen = substringRanges[i].length) {
 372             StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 373             bufferPos += srcLen;
 374         }
 375     }
 376 
 377     RELEASE_AND_RETURN(scope, jsString(exec, WTFMove(impl)));
 378 }
 379 
 380 static ALWAYS_INLINE JSString* jsSpliceSubstringsWithSeparators(ExecState* exec, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount, const String* separators, int separatorCount)
 381 {
 382     VM&amp; vm = exec-&gt;vm();
 383     auto scope = DECLARE_THROW_SCOPE(vm);
 384 
 385     if (rangeCount == 1 &amp;&amp; separatorCount == 0) {
 386         int sourceSize = source.length();
 387         int position = substringRanges[0].position;
 388         int length = substringRanges[0].length;
 389         if (position &lt;= 0 &amp;&amp; length &gt;= sourceSize)
 390             return sourceVal;
 391         // We could call String::substringSharingImpl(), but this would result in redundant checks.
 392         RELEASE_AND_RETURN(scope, jsString(exec, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));
 393     }
 394 
 395     Checked&lt;int, RecordOverflow&gt; totalLength = 0;
 396     bool allSeparators8Bit = true;
 397     for (int i = 0; i &lt; rangeCount; i++)
 398         totalLength += substringRanges[i].length;
 399     for (int i = 0; i &lt; separatorCount; i++) {
 400         totalLength += separators[i].length();
 401         if (separators[i].length() &amp;&amp; !separators[i].is8Bit())
 402             allSeparators8Bit = false;
 403     }
 404     if (totalLength.hasOverflowed()) {
 405         throwOutOfMemoryError(exec, scope);
 406         return nullptr;
 407     }
 408 
 409     if (!totalLength)
 410         return jsEmptyString(exec);
 411 
 412     if (source.is8Bit() &amp;&amp; allSeparators8Bit) {
 413         LChar* buffer;
 414         const LChar* sourceData = source.characters8();
 415 
 416         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 417         if (!impl) {
 418             throwOutOfMemoryError(exec, scope);
 419             return nullptr;
 420         }
 421 
 422         int maxCount = std::max(rangeCount, separatorCount);
 423         Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 424         for (int i = 0; i &lt; maxCount; i++) {
 425             if (i &lt; rangeCount) {
 426                 if (int srcLen = substringRanges[i].length) {
 427                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 428                     bufferPos += srcLen;
 429                 }
 430             }
 431             if (i &lt; separatorCount) {
 432                 if (int sepLen = separators[i].length()) {
 433                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters8(), sepLen);
 434                     bufferPos += sepLen;
 435                 }
 436             }
 437         }
 438 
 439         RELEASE_AND_RETURN(scope, jsString(exec, WTFMove(impl)));
 440     }
 441 
 442     UChar* buffer;
 443     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 444     if (!impl) {
 445         throwOutOfMemoryError(exec, scope);
 446         return nullptr;
 447     }
 448 
 449     int maxCount = std::max(rangeCount, separatorCount);
 450     Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 451     for (int i = 0; i &lt; maxCount; i++) {
 452         if (i &lt; rangeCount) {
 453             if (int srcLen = substringRanges[i].length) {
 454                 if (source.is8Bit())
 455                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), source.characters8() + substringRanges[i].position, srcLen);
 456                 else
 457                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), source.characters16() + substringRanges[i].position, srcLen);
 458                 bufferPos += srcLen;
 459             }
 460         }
 461         if (i &lt; separatorCount) {
 462             if (int sepLen = separators[i].length()) {
 463                 if (separators[i].is8Bit())
 464                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters8(), sepLen);
 465                 else
 466                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters16(), sepLen);
 467                 bufferPos += sepLen;
 468             }
 469         }
 470     }
 471 
 472     RELEASE_AND_RETURN(scope, jsString(exec, WTFMove(impl)));
 473 }
 474 
 475 #define OUT_OF_MEMORY(exec__, scope__) \
 476     do { \
 477         throwOutOfMemoryError(exec__, scope__); \
 478         return nullptr; \
 479     } while (false)
 480 
 481 static ALWAYS_INLINE JSString* removeUsingRegExpSearch(VM&amp; vm, ExecState* exec, JSString* string, const String&amp; source, RegExp* regExp)
 482 {
 483     auto scope = DECLARE_THROW_SCOPE(vm);
 484     SuperSamplerScope superSamplerScope(false);
 485 
 486     size_t lastIndex = 0;
 487     unsigned startPosition = 0;
 488 
 489     Vector&lt;StringRange, 16&gt; sourceRanges;
 490     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 491     unsigned sourceLen = source.length();
 492 
 493     while (true) {
 494         MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition);
 495         RETURN_IF_EXCEPTION(scope, nullptr);
 496         if (!result)
 497             break;
 498 
 499         if (lastIndex &lt; result.start) {
 500             if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
 501                 OUT_OF_MEMORY(exec, scope);
 502         }
 503         lastIndex = result.end;
 504         startPosition = lastIndex;
 505 
 506         // special case of empty match
 507         if (result.empty()) {
 508             startPosition++;
 509             if (startPosition &gt; sourceLen)
 510                 break;
 511         }
 512     }
 513 
 514     if (!lastIndex)
 515         return string;
 516 
 517     if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
 518         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
 519             OUT_OF_MEMORY(exec, scope);
 520     }
 521     RELEASE_AND_RETURN(scope, jsSpliceSubstrings(exec, string, source, sourceRanges.data(), sourceRanges.size()));
 522 }
 523 
 524 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(
 525     VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, CallData&amp; callData,
 526     CallType callType, String&amp; replacementString, JSValue replaceValue)
 527 {
 528     auto scope = DECLARE_THROW_SCOPE(vm);
 529 
 530     const String&amp; source = string-&gt;value(exec);
 531     unsigned sourceLen = source.length();
 532     RETURN_IF_EXCEPTION(scope, nullptr);
 533     RegExpObject* regExpObject = jsCast&lt;RegExpObject*&gt;(searchValue);
 534     RegExp* regExp = regExpObject-&gt;regExp();
 535     bool global = regExp-&gt;global();
 536     bool hasNamedCaptures = regExp-&gt;hasNamedCaptures();
 537 
 538     if (global) {
 539         // ES5.1 15.5.4.10 step 8.a.
 540         regExpObject-&gt;setLastIndex(exec, 0);
 541         RETURN_IF_EXCEPTION(scope, nullptr);
 542 
 543         if (callType == CallType::None &amp;&amp; !replacementString.length())
 544             RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, exec, string, source, regExp));
 545     }
 546 
 547     // FIXME: This is wrong because we may be called directly from the FTL.
 548     // https://bugs.webkit.org/show_bug.cgi?id=154874
 549     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 550 
 551     size_t lastIndex = 0;
 552     unsigned startPosition = 0;
 553 
 554     Vector&lt;StringRange, 16&gt; sourceRanges;
 555     Vector&lt;String, 16&gt; replacements;
 556 
 557     // This is either a loop (if global is set) or a one-way (if not).
 558     if (global &amp;&amp; callType == CallType::JS) {
 559         // regExp-&gt;numSubpatterns() + 1 for pattern args, + 2 for match start and string
 560         int argCount = regExp-&gt;numSubpatterns() + 1 + 2;
 561         if (hasNamedCaptures)
 562             ++argCount;
 563         JSFunction* func = jsCast&lt;JSFunction*&gt;(replaceValue);
 564         CachedCall cachedCall(exec, func, argCount);
 565         RETURN_IF_EXCEPTION(scope, nullptr);
 566         while (true) {
 567             int* ovector;
 568             MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition, &amp;ovector);
 569             RETURN_IF_EXCEPTION(scope, nullptr);
 570             if (!result)
 571                 break;
 572 
 573             if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
 574                 OUT_OF_MEMORY(exec, scope);
 575 
 576             cachedCall.clearArguments();
 577 
 578             JSObject* groups = nullptr;
 579 
 580             if (hasNamedCaptures) {
 581                 JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 582                 groups = JSFinalObject::create(vm, JSFinalObject::createStructure(vm, globalObject, globalObject-&gt;objectPrototype(), 0));
 583             }
 584 
 585             for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
 586                 int matchStart = ovector[i * 2];
 587                 int matchLen = ovector[i * 2 + 1] - matchStart;
 588 
 589                 JSValue patternValue;
 590 
 591                 if (matchStart &lt; 0)
 592                     patternValue = jsUndefined();
 593                 else
 594                     patternValue = jsSubstring(&amp;vm, source, matchStart, matchLen);
 595 
 596                 cachedCall.appendArgument(patternValue);
 597 
 598                 if (i &amp;&amp; hasNamedCaptures) {
 599                     String groupName = regExp-&gt;getCaptureGroupName(i);
 600                     if (!groupName.isEmpty())
 601                         groups-&gt;putDirect(vm, Identifier::fromString(&amp;vm, groupName), patternValue);
 602                 }
 603             }
 604 
 605             cachedCall.appendArgument(jsNumber(result.start));
 606             cachedCall.appendArgument(string);
 607             if (hasNamedCaptures)
 608                 cachedCall.appendArgument(groups);
 609 
 610             cachedCall.setThis(jsUndefined());
 611             if (UNLIKELY(cachedCall.hasOverflowedArguments())) {
 612                 throwOutOfMemoryError(exec, scope);
 613                 return nullptr;
 614             }
 615 
 616             JSValue jsResult = cachedCall.call();
 617             RETURN_IF_EXCEPTION(scope, nullptr);
 618             replacements.append(jsResult.toWTFString(exec));
 619             RETURN_IF_EXCEPTION(scope, nullptr);
 620 
 621             lastIndex = result.end;
 622             startPosition = lastIndex;
 623 
 624             // special case of empty match
 625             if (result.empty()) {
 626                 startPosition++;
 627                 if (startPosition &gt; sourceLen)
 628                     break;
 629             }
 630         }
 631     } else {
 632         do {
 633             int* ovector;
 634             MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition, &amp;ovector);
 635             RETURN_IF_EXCEPTION(scope, nullptr);
 636             if (!result)
 637                 break;
 638 
 639             if (callType != CallType::None) {
 640                 if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
 641                     OUT_OF_MEMORY(exec, scope);
 642 
 643                 MarkedArgumentBuffer args;
 644                 JSObject* groups = nullptr;
 645 
 646                 if (hasNamedCaptures) {
 647                     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 648                     groups = JSFinalObject::create(vm, JSFinalObject::createStructure(vm, globalObject, globalObject-&gt;objectPrototype(), 0));
 649                 }
 650 
 651                 for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
 652                     int matchStart = ovector[i * 2];
 653                     int matchLen = ovector[i * 2 + 1] - matchStart;
 654 
 655                     JSValue patternValue;
 656 
 657                     if (matchStart &lt; 0)
 658                         patternValue = jsUndefined();
 659                     else
 660                         patternValue = jsSubstring(exec, source, matchStart, matchLen);
 661 
 662                     args.append(patternValue);
 663 
 664                     if (i &amp;&amp; hasNamedCaptures) {
 665                         String groupName = regExp-&gt;getCaptureGroupName(i);
 666                         if (!groupName.isEmpty())
 667                             groups-&gt;putDirect(vm, Identifier::fromString(&amp;vm, groupName), patternValue);
 668                     }
 669 
 670                 }
 671 
 672                 args.append(jsNumber(result.start));
 673                 args.append(string);
 674                 if (hasNamedCaptures)
 675                     args.append(groups);
 676                 if (UNLIKELY(args.hasOverflowed())) {
 677                     throwOutOfMemoryError(exec, scope);
 678                     return nullptr;
 679                 }
 680 
 681                 JSValue replacement = call(exec, replaceValue, callType, callData, jsUndefined(), args);
 682                 RETURN_IF_EXCEPTION(scope, nullptr);
 683                 String replacementString = replacement.toWTFString(exec);
 684                 RETURN_IF_EXCEPTION(scope, nullptr);
 685                 replacements.append(replacementString);
 686                 RETURN_IF_EXCEPTION(scope, nullptr);
 687             } else {
 688                 int replLen = replacementString.length();
 689                 if (lastIndex &lt; result.start || replLen) {
 690                     if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
 691                         OUT_OF_MEMORY(exec, scope);
 692 
 693                     if (replLen) {
 694                         StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
 695                         substituteBackreferences(replacement, replacementString, source, ovector, regExp);
 696                         if (UNLIKELY(replacement.hasOverflowed()))
 697                             OUT_OF_MEMORY(exec, scope);
 698                         replacements.append(replacement.toString());
 699                     } else
 700                         replacements.append(String());
 701                 }
 702             }
 703 
 704             lastIndex = result.end;
 705             startPosition = lastIndex;
 706 
 707             // special case of empty match
 708             if (result.empty()) {
 709                 startPosition++;
 710                 if (startPosition &gt; sourceLen)
 711                     break;
 712             }
 713         } while (global);
 714     }
 715 
 716     if (!lastIndex &amp;&amp; replacements.isEmpty())
 717         return string;
 718 
 719     if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
 720         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
 721             OUT_OF_MEMORY(exec, scope);
 722     }
 723     RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(exec, string, source, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));
 724 }
 725 
 726 JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpEmptyStr(
 727     ExecState* exec, JSString* thisValue, RegExpObject* searchValue)
 728 {
 729     VM&amp; vm = exec-&gt;vm();
 730     NativeCallFrameTracer tracer(&amp;vm, exec);
 731     auto scope = DECLARE_THROW_SCOPE(vm);
 732 
 733     RegExp* regExp = searchValue-&gt;regExp();
 734     if (regExp-&gt;global()) {
 735         // ES5.1 15.5.4.10 step 8.a.
 736         searchValue-&gt;setLastIndex(exec, 0);
 737         RETURN_IF_EXCEPTION(scope, nullptr);
 738         const String&amp; source = thisValue-&gt;value(exec);
 739         RETURN_IF_EXCEPTION(scope, nullptr);
 740         RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, exec, thisValue, source, regExp));
 741     }
 742 
 743     CallData callData;
 744     String replacementString = emptyString();
 745     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
 746         vm, exec, thisValue, searchValue, callData, CallType::None, replacementString, JSValue()));
 747 }
 748 
 749 JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpString(
 750     ExecState* exec, JSString* thisValue, RegExpObject* searchValue, JSString* replaceString)
 751 {
 752     VM&amp; vm = exec-&gt;vm();
 753     NativeCallFrameTracer tracer(&amp;vm, exec);
 754 
 755     CallData callData;
 756     String replacementString = replaceString-&gt;value(exec);
 757     return replaceUsingRegExpSearch(
 758         vm, exec, thisValue, searchValue, callData, CallType::None, replacementString, replaceString);
 759 }
 760 
 761 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, JSValue replaceValue)
 762 {
 763     auto scope = DECLARE_THROW_SCOPE(vm);
 764 
 765     String replacementString;
 766     CallData callData;
 767     CallType callType = getCallData(vm, replaceValue, callData);
 768     if (callType == CallType::None) {
 769         replacementString = replaceValue.toWTFString(exec);
 770         RETURN_IF_EXCEPTION(scope, nullptr);
 771     }
 772 
 773     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
 774         vm, exec, string, searchValue, callData, callType, replacementString, replaceValue));
 775 }
 776 
 777 static ALWAYS_INLINE JSString* replaceUsingStringSearch(VM&amp; vm, ExecState* exec, JSString* jsString, JSValue searchValue, JSValue replaceValue)
 778 {
 779     auto scope = DECLARE_THROW_SCOPE(vm);
 780 
 781     const String&amp; string = jsString-&gt;value(exec);
 782     RETURN_IF_EXCEPTION(scope, nullptr);
 783     String searchString = searchValue.toWTFString(exec);
 784     RETURN_IF_EXCEPTION(scope, nullptr);
 785 
 786     size_t matchStart = string.find(searchString);
 787 
 788     if (matchStart == notFound)
 789         return jsString;
 790 
 791     CallData callData;
 792     CallType callType = getCallData(vm, replaceValue, callData);
 793     if (callType != CallType::None) {
 794         MarkedArgumentBuffer args;
 795         args.append(jsSubstring(exec, string, matchStart, searchString.impl()-&gt;length()));
 796         args.append(jsNumber(matchStart));
 797         args.append(jsString);
 798         ASSERT(!args.hasOverflowed());
 799         replaceValue = call(exec, replaceValue, callType, callData, jsUndefined(), args);
 800         RETURN_IF_EXCEPTION(scope, nullptr);
 801     }
 802 
 803     String replaceString = replaceValue.toWTFString(exec);
 804     RETURN_IF_EXCEPTION(scope, nullptr);
 805 
 806     StringImpl* stringImpl = string.impl();
 807     String leftPart(StringImpl::createSubstringSharingImpl(*stringImpl, 0, matchStart));
 808 
 809     size_t matchEnd = matchStart + searchString.impl()-&gt;length();
 810     int ovector[2] = { static_cast&lt;int&gt;(matchStart),  static_cast&lt;int&gt;(matchEnd)};
 811     String middlePart;
 812     if (callType != CallType::None)
 813         middlePart = replaceString;
 814     else {
 815         StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
 816         substituteBackreferences(replacement, replaceString, string, ovector, 0);
 817         if (UNLIKELY(replacement.hasOverflowed()))
 818             OUT_OF_MEMORY(exec, scope);
 819         middlePart = replacement.toString();
 820     }
 821 
 822     size_t leftLength = stringImpl-&gt;length() - matchEnd;
 823     String rightPart(StringImpl::createSubstringSharingImpl(*stringImpl, matchEnd, leftLength));
 824     RELEASE_AND_RETURN(scope, JSC::jsString(exec, leftPart, middlePart, rightPart));
 825 }
 826 
 827 static inline bool checkObjectCoercible(JSValue thisValue)
 828 {
 829     if (thisValue.isString())
 830         return true;
 831 
 832     if (thisValue.isUndefinedOrNull())
 833         return false;
 834 
 835     if (thisValue.isObject() &amp;&amp; asObject(thisValue)-&gt;isEnvironment())
 836         return false;
 837 
 838     return true;
 839 }
 840 
 841 EncodedJSValue JSC_HOST_CALL stringProtoFuncRepeatCharacter(ExecState* exec)
 842 {
 843     VM&amp; vm = exec-&gt;vm();
 844     auto scope = DECLARE_THROW_SCOPE(vm);
 845 
 846     // For a string which length is single, instead of creating ropes,
 847     // allocating a sequential buffer and fill with the repeated string for efficiency.
 848     ASSERT(exec-&gt;argumentCount() == 2);
 849 
 850     ASSERT(exec-&gt;uncheckedArgument(0).isString());
 851     JSString* string = asString(exec-&gt;uncheckedArgument(0));
 852     ASSERT(string-&gt;length() == 1);
 853 
 854     JSValue repeatCountValue = exec-&gt;uncheckedArgument(1);
 855     RELEASE_ASSERT(repeatCountValue.isNumber());
 856     int32_t repeatCount;
 857     double value = repeatCountValue.asNumber();
 858     if (value &gt; JSString::MaxLength)
 859         return JSValue::encode(throwOutOfMemoryError(exec, scope));
 860     repeatCount = static_cast&lt;int32_t&gt;(value);
 861     ASSERT(repeatCount &gt;= 0);
 862     ASSERT(!repeatCountValue.isDouble() || repeatCountValue.asDouble() == repeatCount);
 863 
 864     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);
 865     StringView view = viewWithString.view;
 866     ASSERT(view.length() == 1);
 867     scope.assertNoException();
 868     UChar character = view[0];
 869     scope.release();
 870     if (!(character &amp; ~0xff))
 871         return JSValue::encode(repeatCharacter(*exec, static_cast&lt;LChar&gt;(character), repeatCount));
 872     return JSValue::encode(repeatCharacter(*exec, character, repeatCount));
 873 }
 874 
 875 ALWAYS_INLINE JSString* replace(
 876     VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, JSValue replaceValue)
 877 {
 878     if (searchValue.inherits&lt;RegExpObject&gt;(vm))
 879         return replaceUsingRegExpSearch(vm, exec, string, searchValue, replaceValue);
 880     return replaceUsingStringSearch(vm, exec, string, searchValue, replaceValue);
 881 }
 882 
 883 ALWAYS_INLINE JSString* replace(
 884     VM&amp; vm, ExecState* exec, JSValue thisValue, JSValue searchValue, JSValue replaceValue)
 885 {
 886     auto scope = DECLARE_THROW_SCOPE(vm);
 887 
 888     if (!checkObjectCoercible(thisValue)) {
 889         throwVMTypeError(exec, scope);
 890         return nullptr;
 891     }
 892     JSString* string = thisValue.toString(exec);
 893     RETURN_IF_EXCEPTION(scope, nullptr);
 894     RELEASE_AND_RETURN(scope, replace(vm, exec, string, searchValue, replaceValue));
 895 }
 896 
 897 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(ExecState* exec)
 898 {
 899     VM&amp; vm = exec-&gt;vm();
 900     auto scope = DECLARE_THROW_SCOPE(vm);
 901 
 902     JSString* string = exec-&gt;thisValue().toString(exec);
 903     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 904 
 905     JSValue searchValue = exec-&gt;argument(0);
 906     if (!searchValue.inherits&lt;RegExpObject&gt;(vm))
 907         return JSValue::encode(jsUndefined());
 908 
 909     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingRegExpSearch(vm, exec, string, searchValue, exec-&gt;argument(1))));
 910 }
 911 
 912 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(ExecState* exec)
 913 {
 914     VM&amp; vm = exec-&gt;vm();
 915     auto scope = DECLARE_THROW_SCOPE(vm);
 916 
 917     JSString* string = exec-&gt;thisValue().toString(exec);
 918     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 919 
 920     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, exec, string, exec-&gt;argument(0), exec-&gt;argument(1))));
 921 }
 922 
 923 JSCell* JIT_OPERATION operationStringProtoFuncReplaceGeneric(
 924     ExecState* exec, EncodedJSValue thisValue, EncodedJSValue searchValue,
 925     EncodedJSValue replaceValue)
 926 {
 927     VM&amp; vm = exec-&gt;vm();
 928     NativeCallFrameTracer tracer(&amp;vm, exec);
 929 
 930     return replace(
 931         vm, exec, JSValue::decode(thisValue), JSValue::decode(searchValue),
 932         JSValue::decode(replaceValue));
 933 }
 934 
 935 EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(ExecState* exec)
 936 {
 937     VM&amp; vm = exec-&gt;vm();
 938     auto scope = DECLARE_THROW_SCOPE(vm);
 939 
 940     JSValue thisValue = exec-&gt;thisValue();
 941     // Also used for valueOf.
 942 
 943     if (thisValue.isString())
 944         return JSValue::encode(thisValue);
 945 
 946     auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, thisValue);
 947     if (stringObject)
 948         return JSValue::encode(stringObject-&gt;internalValue());
 949 
 950     return throwVMTypeError(exec, scope);
 951 }
 952 
 953 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(ExecState* exec)
 954 {
 955     VM&amp; vm = exec-&gt;vm();
 956     auto scope = DECLARE_THROW_SCOPE(vm);
 957 
 958     JSValue thisValue = exec-&gt;thisValue();
 959     if (!checkObjectCoercible(thisValue))
 960         return throwVMTypeError(exec, scope);
 961     auto viewWithString = thisValue.toString(exec)-&gt;viewWithUnderlyingString(exec);
 962     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 963     StringView view = viewWithString.view;
 964     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 965     JSValue a0 = exec-&gt;argument(0);
 966     if (a0.isUInt32()) {
 967         uint32_t i = a0.asUInt32();
 968         if (i &lt; view.length())
 969             return JSValue::encode(jsSingleCharacterString(exec, view[i]));
 970         return JSValue::encode(jsEmptyString(exec));
 971     }
 972     double dpos = a0.toInteger(exec);
 973     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 974     if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
 975         return JSValue::encode(jsSingleCharacterString(exec, view[static_cast&lt;unsigned&gt;(dpos)]));
 976     return JSValue::encode(jsEmptyString(exec));
 977 }
 978 
 979 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(ExecState* exec)
 980 {
 981     VM&amp; vm = exec-&gt;vm();
 982     auto scope = DECLARE_THROW_SCOPE(vm);
 983 
 984     JSValue thisValue = exec-&gt;thisValue();
 985     if (!checkObjectCoercible(thisValue))
 986         return throwVMTypeError(exec, scope);
 987     auto viewWithString = thisValue.toString(exec)-&gt;viewWithUnderlyingString(exec);
 988     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 989     StringView view = viewWithString.view;
 990     JSValue a0 = exec-&gt;argument(0);
 991     if (a0.isUInt32()) {
 992         uint32_t i = a0.asUInt32();
 993         if (i &lt; view.length())
 994             return JSValue::encode(jsNumber(view[i]));
 995         return JSValue::encode(jsNaN());
 996     }
 997     double dpos = a0.toInteger(exec);
 998     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 999     if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
1000         return JSValue::encode(jsNumber(view[static_cast&lt;int&gt;(dpos)]));
1001     return JSValue::encode(jsNaN());
1002 }
1003 
1004 static inline UChar32 codePointAt(const String&amp; string, unsigned position, unsigned length)
1005 {
1006     RELEASE_ASSERT(position &lt; length);
1007     if (string.is8Bit())
1008         return string.characters8()[position];
1009     UChar32 character;
1010     U16_NEXT(string.characters16(), position, length, character);
1011     return character;
1012 }
1013 
1014 EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(ExecState* exec)
1015 {
1016     VM&amp; vm = exec-&gt;vm();
1017     auto scope = DECLARE_THROW_SCOPE(vm);
1018 
1019     JSValue thisValue = exec-&gt;thisValue();
1020     if (!checkObjectCoercible(thisValue))
1021         return throwVMTypeError(exec, scope);
1022 
1023     String string = thisValue.toWTFString(exec);
1024     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1025     unsigned length = string.length();
1026 
1027     JSValue argument0 = exec-&gt;argument(0);
1028     if (argument0.isUInt32()) {
1029         unsigned position = argument0.asUInt32();
1030         if (position &lt; length)
1031             return JSValue::encode(jsNumber(codePointAt(string, position, length)));
1032         return JSValue::encode(jsUndefined());
1033     }
1034 
1035     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1036 
1037     double doublePosition = argument0.toInteger(exec);
1038     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1039     if (doublePosition &gt;= 0 &amp;&amp; doublePosition &lt; length)
1040         return JSValue::encode(jsNumber(codePointAt(string, static_cast&lt;unsigned&gt;(doublePosition), length)));
1041     return JSValue::encode(jsUndefined());
1042 }
1043 
1044 EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(ExecState* exec)
1045 {
1046     VM&amp; vm = exec-&gt;vm();
1047     auto scope = DECLARE_THROW_SCOPE(vm);
1048 
1049     JSValue thisValue = exec-&gt;thisValue();
1050     if (!checkObjectCoercible(thisValue))
1051         return throwVMTypeError(exec, scope);
1052 
1053     JSValue a0 = exec-&gt;argument(0);
1054     JSValue a1 = exec-&gt;argument(1);
1055 
1056     JSString* thisJSString = thisValue.toString(exec);
1057     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1058     JSString* otherJSString = a0.toString(exec);
1059     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1060 
1061     unsigned pos = 0;
1062     if (!a1.isUndefined()) {
1063         int len = thisJSString-&gt;length();
1064         RELEASE_ASSERT(len &gt;= 0);
1065         if (a1.isUInt32())
1066             pos = std::min&lt;uint32_t&gt;(a1.asUInt32(), len);
1067         else {
1068             double dpos = a1.toInteger(exec);
1069             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1070             if (dpos &lt; 0)
1071                 dpos = 0;
1072             else if (dpos &gt; len)
1073                 dpos = len;
1074             pos = static_cast&lt;unsigned&gt;(dpos);
1075         }
1076     }
1077 
1078     if (thisJSString-&gt;length() &lt; otherJSString-&gt;length() + pos)
1079         return JSValue::encode(jsNumber(-1));
1080 
1081     auto thisViewWithString = thisJSString-&gt;viewWithUnderlyingString(exec);
1082     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1083     auto otherViewWithString = otherJSString-&gt;viewWithUnderlyingString(exec);
1084     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1085     size_t result = thisViewWithString.view.find(otherViewWithString.view, pos);
1086     if (result == notFound)
1087         return JSValue::encode(jsNumber(-1));
1088     return JSValue::encode(jsNumber(result));
1089 }
1090 
1091 EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(ExecState* exec)
1092 {
1093     VM&amp; vm = exec-&gt;vm();
1094     auto scope = DECLARE_THROW_SCOPE(vm);
1095 
1096     JSValue thisValue = exec-&gt;thisValue();
1097     if (!checkObjectCoercible(thisValue))
1098         return throwVMTypeError(exec, scope);
1099 
1100     JSValue a0 = exec-&gt;argument(0);
1101     JSValue a1 = exec-&gt;argument(1);
1102 
1103     JSString* thisJSString = thisValue.toString(exec);
1104     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1105     unsigned len = thisJSString-&gt;length();
1106     JSString* otherJSString = a0.toString(exec);
1107     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1108 
1109     double dpos = a1.toIntegerPreserveNaN(exec);
1110     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1111     unsigned startPosition;
1112     if (dpos &lt; 0)
1113         startPosition = 0;
1114     else if (!(dpos &lt;= len)) // true for NaN
1115         startPosition = len;
1116     else
1117         startPosition = static_cast&lt;unsigned&gt;(dpos);
1118 
1119     if (len &lt; otherJSString-&gt;length())
1120         return JSValue::encode(jsNumber(-1));
1121 
1122     String thisString = thisJSString-&gt;value(exec);
1123     String otherString = otherJSString-&gt;value(exec);
1124     size_t result;
1125     if (!startPosition)
1126         result = thisString.startsWith(otherString) ? 0 : notFound;
1127     else
1128         result = thisString.reverseFind(otherString, startPosition);
1129     if (result == notFound)
1130         return JSValue::encode(jsNumber(-1));
1131     return JSValue::encode(jsNumber(result));
1132 }
1133 
1134 EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(ExecState* exec)
1135 {
1136     VM&amp; vm = exec-&gt;vm();
1137     auto scope = DECLARE_THROW_SCOPE(vm);
1138 
1139     JSValue thisValue = exec-&gt;thisValue();
1140     if (!checkObjectCoercible(thisValue))
1141         return throwVMTypeError(exec, scope);
1142     String s = thisValue.toWTFString(exec);
1143     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1144 
1145     JSValue a0 = exec-&gt;argument(0);
1146     JSValue a1 = exec-&gt;argument(1);
1147 
1148     int len = s.length();
1149     RELEASE_ASSERT(len &gt;= 0);
1150 
1151     // The arg processing is very much like ArrayProtoFunc::Slice
1152     double start = a0.toInteger(exec);
1153     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1154     double end = a1.isUndefined() ? len : a1.toInteger(exec);
1155     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1156     scope.release();
1157     return JSValue::encode(stringSlice(exec, WTFMove(s), start, end));
1158 }
1159 
1160 // Return true in case of early return (resultLength got to limitLength).
1161 template&lt;typename CharacterType&gt;
1162 static ALWAYS_INLINE bool splitStringByOneCharacterImpl(ExecState* exec, JSArray* result, JSValue originalValue, const String&amp; input, StringImpl* string, UChar separatorCharacter, size_t&amp; position, unsigned&amp; resultLength, unsigned limitLength)
1163 {
1164     VM&amp; vm = exec-&gt;vm();
1165     auto scope = DECLARE_THROW_SCOPE(vm);
1166 
1167     // 12. Let q = p.
1168     size_t matchPosition;
1169     const CharacterType* characters = string-&gt;characters&lt;CharacterType&gt;();
1170     // 13. Repeat, while q != s
1171     //   a. Call SplitMatch(S, q, R) and let z be its MatchResult result.
1172     //   b. If z is failure, then let q = q+1.
1173     //   c. Else, z is not failure
1174     while ((matchPosition = WTF::find(characters, string-&gt;length(), separatorCharacter, position)) != notFound) {
1175         // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1176         //    through q (exclusive).
1177         // 2. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA),
1178         //    Property Descriptor {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
1179         result-&gt;putDirectIndex(exec, resultLength, jsSubstring(exec, originalValue, input, position, matchPosition - position));
1180         RETURN_IF_EXCEPTION(scope, false);
1181         // 3. Increment lengthA by 1.
1182         // 4. If lengthA == lim, return A.
1183         if (++resultLength == limitLength)
1184             return true;
1185 
1186         // 5. Let p = e.
1187         // 8. Let q = p.
1188         position = matchPosition + 1;
1189     }
1190     return false;
1191 }
1192 
1193 // ES 21.1.3.17 String.prototype.split(separator, limit)
1194 EncodedJSValue JSC_HOST_CALL stringProtoFuncSplitFast(ExecState* exec)
1195 {
1196     VM&amp; vm = exec-&gt;vm();
1197     auto scope = DECLARE_THROW_SCOPE(vm);
1198     JSValue thisValue = exec-&gt;thisValue();
1199     ASSERT(checkObjectCoercible(thisValue));
1200 
1201     // 3. Let S be the result of calling ToString, giving it the this value as its argument.
1202     // 7. Let s be the number of characters in S.
1203     String input = thisValue.toWTFString(exec);
1204     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1205     ASSERT(!input.isNull());
1206 
1207     // 4. Let A be a new array created as if by the expression new Array()
1208     //    where Array is the standard built-in constructor with that name.
1209     JSArray* result = constructEmptyArray(exec, 0);
1210     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1211 
1212     // 5. Let lengthA be 0.
1213     unsigned resultLength = 0;
1214 
1215     // 6. If limit is undefined, let lim = 2^32-1; else let lim = ToUint32(limit).
1216     JSValue limitValue = exec-&gt;uncheckedArgument(1);
1217     unsigned limit = limitValue.isUndefined() ? 0xFFFFFFFFu : limitValue.toUInt32(exec);
1218     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1219 
1220     // 8. Let p = 0.
1221     size_t position = 0;
1222 
1223     // 9. If separator is a RegExp object (its [[Class]] is &quot;RegExp&quot;), let R = separator;
1224     //    otherwise let R = ToString(separator).
1225     JSValue separatorValue = exec-&gt;uncheckedArgument(0);
1226     String separator = separatorValue.toWTFString(exec);
1227     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1228 
1229     // 10. If lim == 0, return A.
1230     if (!limit)
1231         return JSValue::encode(result);
1232 
1233     // 11. If separator is undefined, then
1234     if (separatorValue.isUndefined()) {
1235         // a. Call the [[DefineOwnProperty]] internal method of A with arguments &quot;0&quot;,
1236         scope.release();
1237         result-&gt;putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));
1238         // b. Return A.
1239         return JSValue::encode(result);
1240     }
1241 
1242     // 12. If s == 0, then
1243     if (input.isEmpty()) {
1244         // a. Let z be SplitMatch(S, 0, R) where S is input, R is separator.
1245         // b. If z is not false, return A.
1246         // c. Call CreateDataProperty(A, &quot;0&quot;, S).
1247         // d. Return A.
1248         if (!separator.isEmpty()) {
1249             scope.release();
1250             result-&gt;putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));
1251         }
1252         return JSValue::encode(result);
1253     }
1254 
1255     // Optimized case for splitting on the empty string.
1256     if (separator.isEmpty()) {
1257         limit = std::min(limit, input.length());
1258         // Zero limt/input length handled in steps 9/11 respectively, above.
1259         ASSERT(limit);
1260 
1261         do {
1262             result-&gt;putDirectIndex(exec, position, jsSingleCharacterString(exec, input[position]));
1263             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1264         } while (++position &lt; limit);
1265 
1266         return JSValue::encode(result);
1267     }
1268 
1269     // 3 cases:
1270     // -separator length == 1, 8 bits
1271     // -separator length == 1, 16 bits
1272     // -separator length &gt; 1
1273     StringImpl* stringImpl = input.impl();
1274     StringImpl* separatorImpl = separator.impl();
1275     size_t separatorLength = separatorImpl-&gt;length();
1276 
1277     if (separatorLength == 1) {
1278         UChar separatorCharacter;
1279         if (separatorImpl-&gt;is8Bit())
1280             separatorCharacter = separatorImpl-&gt;characters8()[0];
1281         else
1282             separatorCharacter = separatorImpl-&gt;characters16()[0];
1283 
1284         if (stringImpl-&gt;is8Bit()) {
1285             if (splitStringByOneCharacterImpl&lt;LChar&gt;(exec, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))
1286                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
1287         } else {
1288             if (splitStringByOneCharacterImpl&lt;UChar&gt;(exec, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))
1289                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
1290         }
1291         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1292     } else {
1293         // 13. Let q = p.
1294         size_t matchPosition;
1295         // 14. Repeat, while q != s
1296         //   a. let e be SplitMatch(S, q, R).
1297         //   b. If e is failure, then let q = q+1.
1298         //   c. Else, e is an integer index &lt;= s.
1299         while ((matchPosition = stringImpl-&gt;find(separatorImpl, position)) != notFound) {
1300             // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1301             //    through q (exclusive).
1302             // 2. Call CreateDataProperty(A, ToString(lengthA), T).
1303             result-&gt;putDirectIndex(exec, resultLength, jsSubstring(exec, thisValue, input, position, matchPosition - position));
1304             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1305             // 3. Increment lengthA by 1.
1306             // 4. If lengthA == lim, return A.
1307             if (++resultLength == limit)
1308                 return JSValue::encode(result);
1309 
1310             // 5. Let p = e.
1311             // 6. Let q = p.
1312             position = matchPosition + separator.length();
1313         }
1314     }
1315 
1316     // 15. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1317     //     through s (exclusive).
1318     // 16. Call CreateDataProperty(A, ToString(lengthA), T).
1319     scope.release();
1320     result-&gt;putDirectIndex(exec, resultLength++, jsSubstring(exec, thisValue, input, position, input.length() - position));
1321 
1322     // 17. Return A.
1323     return JSValue::encode(result);
1324 }
1325 
1326 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(ExecState* exec)
1327 {
1328     VM&amp; vm = exec-&gt;vm();
1329     auto scope = DECLARE_THROW_SCOPE(vm);
1330 
1331     JSValue thisValue = exec-&gt;thisValue();
1332     if (!checkObjectCoercible(thisValue))
1333         return throwVMTypeError(exec, scope);
1334     unsigned len;
1335     JSString* jsString = 0;
1336     String uString;
1337     if (thisValue.isString()) {
1338         jsString = asString(thisValue);
1339         len = jsString-&gt;length();
1340     } else {
1341         uString = thisValue.toWTFString(exec);
1342         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1343         len = uString.length();
1344     }
1345 
1346     JSValue a0 = exec-&gt;argument(0);
1347     JSValue a1 = exec-&gt;argument(1);
1348 
1349     double start = a0.toInteger(exec);
1350     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1351     double length = a1.isUndefined() ? len : a1.toInteger(exec);
1352     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1353     if (start &gt;= len || length &lt;= 0)
1354         return JSValue::encode(jsEmptyString(exec));
1355     if (start &lt; 0) {
1356         start += len;
1357         if (start &lt; 0)
1358             start = 0;
1359     }
1360     if (start + length &gt; len)
1361         length = len - start;
1362     unsigned substringStart = static_cast&lt;unsigned&gt;(start);
1363     unsigned substringLength = static_cast&lt;unsigned&gt;(length);
1364     if (jsString)
1365         return JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength));
1366     return JSValue::encode(jsSubstring(exec, uString, substringStart, substringLength));
1367 }
1368 
1369 EncodedJSValue JSC_HOST_CALL builtinStringSubstrInternal(ExecState* exec)
1370 {
1371     // @substrInternal should not have any observable side effects (e.g. it should not call
1372     // GetMethod(..., @@toPrimitive) on the thisValue).
1373 
1374     // It is ok to use the default stringProtoFuncSubstr as the implementation of
1375     // @substrInternal because @substrInternal will only be called by builtins, which will
1376     // guarantee that we only pass it a string thisValue. As a result, stringProtoFuncSubstr
1377     // will not need to call toString() on the thisValue, and there will be no observable
1378     // side-effects.
1379     ASSERT(exec-&gt;thisValue().isString());
1380     return stringProtoFuncSubstr(exec);
1381 }
1382 
1383 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(ExecState* exec)
1384 {
1385     VM&amp; vm = exec-&gt;vm();
1386     auto scope = DECLARE_THROW_SCOPE(vm);
1387 
1388     JSValue thisValue = exec-&gt;thisValue();
1389     if (!checkObjectCoercible(thisValue))
1390         return throwVMTypeError(exec, scope);
1391 
1392     JSString* jsString = thisValue.toString(exec);
1393     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1394 
1395     JSValue a0 = exec-&gt;argument(0);
1396     JSValue a1 = exec-&gt;argument(1);
1397     int len = jsString-&gt;length();
1398     RELEASE_ASSERT(len &gt;= 0);
1399 
1400     double start = a0.toNumber(exec);
1401     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1402     double end;
1403     if (!(start &gt;= 0)) // check for negative values or NaN
1404         start = 0;
1405     else if (start &gt; len)
1406         start = len;
1407     if (a1.isUndefined())
1408         end = len;
1409     else {
1410         end = a1.toNumber(exec);
1411         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1412         if (!(end &gt;= 0)) // check for negative values or NaN
1413             end = 0;
1414         else if (end &gt; len)
1415             end = len;
1416     }
1417     if (start &gt; end) {
1418         double temp = end;
1419         end = start;
1420         start = temp;
1421     }
1422     unsigned substringStart = static_cast&lt;unsigned&gt;(start);
1423     unsigned substringLength = static_cast&lt;unsigned&gt;(end) - substringStart;
1424     return JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength));
1425 }
1426 
1427 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(ExecState* exec)
1428 {
1429     VM&amp; vm = exec-&gt;vm();
1430     auto scope = DECLARE_THROW_SCOPE(vm);
1431 
1432     JSValue thisValue = exec-&gt;thisValue();
1433     if (!checkObjectCoercible(thisValue))
1434         return throwVMTypeError(exec, scope);
1435     JSString* sVal = thisValue.toString(exec);
1436     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1437     const String&amp; s = sVal-&gt;value(exec);
1438     String lowercasedString = s.convertToLowercaseWithoutLocale();
1439     if (lowercasedString.impl() == s.impl())
1440         return JSValue::encode(sVal);
1441     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(exec, lowercasedString)));
1442 }
1443 
1444 EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(ExecState* exec)
1445 {
1446     VM&amp; vm = exec-&gt;vm();
1447     auto scope = DECLARE_THROW_SCOPE(vm);
1448 
1449     JSValue thisValue = exec-&gt;thisValue();
1450     if (!checkObjectCoercible(thisValue))
1451         return throwVMTypeError(exec, scope);
1452     JSString* sVal = thisValue.toString(exec);
1453     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1454     const String&amp; s = sVal-&gt;value(exec);
1455     String uppercasedString = s.convertToUppercaseWithoutLocale();
1456     if (uppercasedString.impl() == s.impl())
1457         return JSValue::encode(sVal);
1458     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(exec, uppercasedString)));
1459 }
1460 
1461 EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(ExecState* exec)
1462 {
1463     // 13.1.1 String.prototype.localeCompare (that [, locales [, options ]]) (ECMA-402 2.0)
1464     // http://ecma-international.org/publications/standards/Ecma-402.htm
1465 
1466     VM&amp; vm = exec-&gt;vm();
1467     auto scope = DECLARE_THROW_SCOPE(vm);
1468 
1469     // 1. Let O be RequireObjectCoercible(this value).
1470     JSValue thisValue = exec-&gt;thisValue();
1471     if (!checkObjectCoercible(thisValue))
1472         return throwVMTypeError(exec, scope, &quot;String.prototype.localeCompare requires that |this| not be null or undefined&quot;_s);
1473 
1474     // 2. Let S be ToString(O).
1475     // 3. ReturnIfAbrupt(S).
1476     String string = thisValue.toWTFString(exec);
1477     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1478 
1479     // 4. Let That be ToString(that).
1480     // 5. ReturnIfAbrupt(That).
1481     JSValue thatValue = exec-&gt;argument(0);
1482     String that = thatValue.toWTFString(exec);
1483     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1484 
1485 #if ENABLE(INTL)
1486     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1487     JSValue locales = exec-&gt;argument(1);
1488     JSValue options = exec-&gt;argument(2);
1489     IntlCollator* collator = nullptr;
1490     if (locales.isUndefined() &amp;&amp; options.isUndefined()) {
1491         collator = globalObject-&gt;defaultCollator(exec);
1492     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1493     } else {
1494         collator = IntlCollator::create(vm, globalObject-&gt;collatorStructure());
1495         collator-&gt;initializeCollator(*exec, locales, options);
1496         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1497     }
1498     RELEASE_AND_RETURN(scope, JSValue::encode(collator-&gt;compareStrings(*exec, string, that)));
1499 #else
1500     return JSValue::encode(jsNumber(Collator().collate(string, that)));
1501 #endif
1502 }
1503 
1504 #if ENABLE(INTL)
1505 static EncodedJSValue toLocaleCase(ExecState* state, int32_t (*convertCase)(UChar*, int32_t, const UChar*, int32_t, const char*, UErrorCode*))
1506 {
1507     VM&amp; vm = state-&gt;vm();
1508     auto scope = DECLARE_THROW_SCOPE(vm);
1509 
1510     // 1. Let O be RequireObjectCoercible(this value).
1511     JSValue thisValue = state-&gt;thisValue();
1512     if (!checkObjectCoercible(thisValue))
1513         return throwVMTypeError(state, scope);
1514 
1515     // 2. Let S be ToString(O).
1516     JSString* sVal = thisValue.toString(state);
1517     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1518     const String&amp; s = sVal-&gt;value(state);
1519 
1520     // 3. ReturnIfAbrupt(S).
1521     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1522 
1523     // Optimization for empty strings.
1524     if (s.isEmpty())
1525         return JSValue::encode(sVal);
1526 
1527     // 4. Let requestedLocales be CanonicalizeLocaleList(locales).
1528     Vector&lt;String&gt; requestedLocales = canonicalizeLocaleList(*state, state-&gt;argument(0));
1529 
1530     // 5. ReturnIfAbrupt(requestedLocales).
1531     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1532 
1533     // 6. Let len be the number of elements in requestedLocales.
1534     size_t len = requestedLocales.size();
1535 
1536     // 7. If len &gt; 0, then
1537     // a. Let requestedLocale be the first element of requestedLocales.
1538     // 8. Else
1539     // a. Let requestedLocale be DefaultLocale().
1540     String requestedLocale = len &gt; 0 ? requestedLocales.first() : defaultLocale(*state);
1541 
1542     // 9. Let noExtensionsLocale be the String value that is requestedLocale with all Unicode locale extension sequences (6.2.1) removed.
1543     String noExtensionsLocale = removeUnicodeLocaleExtension(requestedLocale);
1544 
1545     // 10. Let availableLocales be a List with the language tags of the languages for which the Unicode character database contains language sensitive case mappings.
1546     // Note 1: As of Unicode 5.1, the availableLocales list contains the elements &quot;az&quot;, &quot;lt&quot;, and &quot;tr&quot;.
1547     const HashSet&lt;String&gt; availableLocales({ &quot;az&quot;_s, &quot;lt&quot;_s, &quot;tr&quot;_s });
1548 
1549     // 11. Let locale be BestAvailableLocale(availableLocales, noExtensionsLocale).
1550     String locale = bestAvailableLocale(availableLocales, noExtensionsLocale);
1551 
1552     // 12. If locale is undefined, let locale be &quot;und&quot;.
1553     if (locale.isNull())
1554         locale = &quot;und&quot;_s;
1555 
1556     CString utf8LocaleBuffer = locale.utf8();
1557     const StringView view(s);
1558     const int32_t viewLength = view.length();
1559 
1560     // Delegate the following steps to icu u_strToLower or u_strToUpper.
1561     // 13. Let cpList be a List containing in order the code points of S as defined in ES2015, 6.1.4, starting at the first element of S.
1562     // 14. For each code point c in cpList, if the Unicode Character Database provides a lower(/upper) case equivalent of c that is either language insensitive or for the language locale, then replace c in cpList with that/those equivalent code point(s).
1563     // 15. Let cuList be a new List.
1564     // 16. For each code point c in cpList, in order, append to cuList the elements of the UTF-16 Encoding (defined in ES2015, 6.1.4) of c.
1565     // 17. Let L be a String whose elements are, in order, the elements of cuList.
1566 
1567     // Most strings lower/upper case will be the same size as original, so try that first.
1568     UErrorCode error(U_ZERO_ERROR);
1569     Vector&lt;UChar&gt; buffer(viewLength);
1570     String lower;
1571     const int32_t resultLength = convertCase(buffer.data(), viewLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
1572     if (U_SUCCESS(error))
1573         lower = String(buffer.data(), resultLength);
1574     else if (error == U_BUFFER_OVERFLOW_ERROR) {
1575         // Converted case needs more space than original. Try again.
1576         UErrorCode error(U_ZERO_ERROR);
1577         Vector&lt;UChar&gt; buffer(resultLength);
1578         convertCase(buffer.data(), resultLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
1579         if (U_FAILURE(error))
1580             return throwVMTypeError(state, scope, u_errorName(error));
1581         lower = String(buffer.data(), resultLength);
1582     } else
1583         return throwVMTypeError(state, scope, u_errorName(error));
1584 
1585     // 18. Return L.
1586     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(state, lower)));
1587 }
1588 
1589 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(ExecState* state)
1590 {
1591     // 13.1.2 String.prototype.toLocaleLowerCase ([locales])
1592     // http://ecma-international.org/publications/standards/Ecma-402.htm
1593     return toLocaleCase(state, u_strToLower);
1594 }
1595 
1596 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(ExecState* state)
1597 {
1598     // 13.1.3 String.prototype.toLocaleUpperCase ([locales])
1599     // http://ecma-international.org/publications/standards/Ecma-402.htm
1600     // This function interprets a string value as a sequence of code points, as described in ES2015, 6.1.4. This function behaves in exactly the same way as String.prototype.toLocaleLowerCase, except that characters are mapped to their uppercase equivalents as specified in the Unicode character database.
1601     return toLocaleCase(state, u_strToUpper);
1602 }
1603 #endif // ENABLE(INTL)
1604 
1605 enum {
1606     TrimStart = 1,
1607     TrimEnd = 2
1608 };
1609 
1610 static inline JSValue trimString(ExecState* exec, JSValue thisValue, int trimKind)
1611 {
1612     VM&amp; vm = exec-&gt;vm();
1613     auto scope = DECLARE_THROW_SCOPE(vm);
1614 
1615     if (!checkObjectCoercible(thisValue))
1616         return throwTypeError(exec, scope);
1617     String str = thisValue.toWTFString(exec);
1618     RETURN_IF_EXCEPTION(scope, { });
1619 
1620     unsigned left = 0;
1621     if (trimKind &amp; TrimStart) {
1622         while (left &lt; str.length() &amp;&amp; isStrWhiteSpace(str[left]))
1623             left++;
1624     }
1625     unsigned right = str.length();
1626     if (trimKind &amp; TrimEnd) {
1627         while (right &gt; left &amp;&amp; isStrWhiteSpace(str[right - 1]))
1628             right--;
1629     }
1630 
1631     // Don&#39;t gc allocate a new string if we don&#39;t have to.
1632     if (left == 0 &amp;&amp; right == str.length() &amp;&amp; thisValue.isString())
1633         return thisValue;
1634 
1635     RELEASE_AND_RETURN(scope, jsString(exec, str.substringSharingImpl(left, right - left)));
1636 }
1637 
1638 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(ExecState* exec)
1639 {
1640     JSValue thisValue = exec-&gt;thisValue();
1641     return JSValue::encode(trimString(exec, thisValue, TrimStart | TrimEnd));
1642 }
1643 
1644 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(ExecState* exec)
1645 {
1646     JSValue thisValue = exec-&gt;thisValue();
1647     return JSValue::encode(trimString(exec, thisValue, TrimStart));
1648 }
1649 
1650 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(ExecState* exec)
1651 {
1652     JSValue thisValue = exec-&gt;thisValue();
1653     return JSValue::encode(trimString(exec, thisValue, TrimEnd));
1654 }
1655 
1656 static inline unsigned clampAndTruncateToUnsigned(double value, unsigned min, unsigned max)
1657 {
1658     if (value &lt; min)
1659         return min;
1660     if (value &gt; max)
1661         return max;
1662     return static_cast&lt;unsigned&gt;(value);
1663 }
1664 
1665 EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(ExecState* exec)
1666 {
1667     VM&amp; vm = exec-&gt;vm();
1668     auto scope = DECLARE_THROW_SCOPE(vm);
1669 
1670     JSValue thisValue = exec-&gt;thisValue();
1671     if (!checkObjectCoercible(thisValue))
1672         return throwVMTypeError(exec, scope);
1673 
1674     String stringToSearchIn = thisValue.toWTFString(exec);
1675     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1676 
1677     JSValue a0 = exec-&gt;argument(0);
1678     bool isRegularExpression = isRegExp(vm, exec, a0);
1679     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1680     if (isRegularExpression)
1681         return throwVMTypeError(exec, scope, &quot;Argument to String.prototype.startsWith cannot be a RegExp&quot;);
1682 
1683     String searchString = a0.toWTFString(exec);
1684     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1685 
1686     JSValue positionArg = exec-&gt;argument(1);
1687     unsigned start = 0;
1688     if (positionArg.isInt32())
1689         start = std::max(0, positionArg.asInt32());
1690     else {
1691         unsigned length = stringToSearchIn.length();
1692         start = clampAndTruncateToUnsigned(positionArg.toInteger(exec), 0, length);
1693         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1694     }
1695 
1696     return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixStartingAt(searchString, start)));
1697 }
1698 
1699 EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(ExecState* exec)
1700 {
1701     VM&amp; vm = exec-&gt;vm();
1702     auto scope = DECLARE_THROW_SCOPE(vm);
1703 
1704     JSValue thisValue = exec-&gt;thisValue();
1705     if (!checkObjectCoercible(thisValue))
1706         return throwVMTypeError(exec, scope);
1707 
1708     String stringToSearchIn = thisValue.toWTFString(exec);
1709     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1710 
1711     JSValue a0 = exec-&gt;argument(0);
1712     bool isRegularExpression = isRegExp(vm, exec, a0);
1713     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1714     if (isRegularExpression)
1715         return throwVMTypeError(exec, scope, &quot;Argument to String.prototype.endsWith cannot be a RegExp&quot;);
1716 
1717     String searchString = a0.toWTFString(exec);
1718     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1719 
1720     unsigned length = stringToSearchIn.length();
1721 
1722     JSValue endPositionArg = exec-&gt;argument(1);
1723     unsigned end = length;
1724     if (endPositionArg.isInt32())
1725         end = std::max(0, endPositionArg.asInt32());
1726     else if (!endPositionArg.isUndefined()) {
1727         end = clampAndTruncateToUnsigned(endPositionArg.toInteger(exec), 0, length);
1728         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1729     }
1730 
1731     return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixEndingAt(searchString, std::min(end, length))));
1732 }
1733 
1734 static EncodedJSValue JSC_HOST_CALL stringIncludesImpl(VM&amp; vm, ExecState* exec, String stringToSearchIn, String searchString, JSValue positionArg)
1735 {
1736     auto scope = DECLARE_THROW_SCOPE(vm);
1737     unsigned start = 0;
1738     if (positionArg.isInt32())
1739         start = std::max(0, positionArg.asInt32());
1740     else {
1741         unsigned length = stringToSearchIn.length();
1742         start = clampAndTruncateToUnsigned(positionArg.toInteger(exec), 0, length);
1743         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1744     }
1745 
1746     return JSValue::encode(jsBoolean(stringToSearchIn.find(searchString, start) != notFound));
1747 }
1748 
1749 EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(ExecState* exec)
1750 {
1751     VM&amp; vm = exec-&gt;vm();
1752     auto scope = DECLARE_THROW_SCOPE(vm);
1753 
1754     JSValue thisValue = exec-&gt;thisValue();
1755     if (!checkObjectCoercible(thisValue))
1756         return throwVMTypeError(exec, scope);
1757 
1758     String stringToSearchIn = thisValue.toWTFString(exec);
1759     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1760 
1761     JSValue a0 = exec-&gt;argument(0);
1762     bool isRegularExpression = isRegExp(vm, exec, a0);
1763     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1764     if (isRegularExpression)
1765         return throwVMTypeError(exec, scope, &quot;Argument to String.prototype.includes cannot be a RegExp&quot;);
1766 
1767     String searchString = a0.toWTFString(exec);
1768     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1769 
1770     JSValue positionArg = exec-&gt;argument(1);
1771 
1772     RELEASE_AND_RETURN(scope, stringIncludesImpl(vm, exec, stringToSearchIn, searchString, positionArg));
1773 }
1774 
1775 EncodedJSValue JSC_HOST_CALL builtinStringIncludesInternal(ExecState* exec)
1776 {
1777     VM&amp; vm = exec-&gt;vm();
1778     auto scope = DECLARE_THROW_SCOPE(vm);
1779 
1780     JSValue thisValue = exec-&gt;thisValue();
1781     ASSERT(checkObjectCoercible(thisValue));
1782 
1783     String stringToSearchIn = thisValue.toWTFString(exec);
1784     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1785 
1786     JSValue a0 = exec-&gt;uncheckedArgument(0);
1787     String searchString = a0.toWTFString(exec);
1788     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1789 
1790     JSValue positionArg = exec-&gt;argument(1);
1791 
1792     RELEASE_AND_RETURN(scope, stringIncludesImpl(vm, exec, stringToSearchIn, searchString, positionArg));
1793 }
1794 
1795 EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(ExecState* exec)
1796 {
1797     VM&amp; vm = exec-&gt;vm();
1798     auto scope = DECLARE_THROW_SCOPE(vm);
1799 
1800     JSValue thisValue = exec-&gt;thisValue();
1801     if (!checkObjectCoercible(thisValue))
1802         return throwVMTypeError(exec, scope);
1803     JSString* string = thisValue.toString(exec);
1804     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1805     return JSValue::encode(JSStringIterator::create(exec, exec-&gt;jsCallee()-&gt;globalObject(vm)-&gt;stringIteratorStructure(), string));
1806 }
1807 
1808 enum class NormalizationForm { NFC, NFD, NFKC, NFKD };
1809 
1810 static constexpr bool normalizationAffects8Bit(NormalizationForm form)
1811 {
1812     switch (form) {
1813     case NormalizationForm::NFC:
1814         return false;
1815     case NormalizationForm::NFD:
1816         return true;
1817     case NormalizationForm::NFKC:
1818         return false;
1819     case NormalizationForm::NFKD:
1820         return true;
1821     default:
1822         ASSERT_NOT_REACHED();
1823     }
1824     return true;
1825 }
1826 
1827 static const UNormalizer2* normalizer(NormalizationForm form)
1828 {
1829     UErrorCode status = U_ZERO_ERROR;
1830     const UNormalizer2* normalizer = nullptr;
1831     switch (form) {
1832     case NormalizationForm::NFC:
1833         normalizer = unorm2_getNFCInstance(&amp;status);
1834         break;
1835     case NormalizationForm::NFD:
1836         normalizer = unorm2_getNFDInstance(&amp;status);
1837         break;
1838     case NormalizationForm::NFKC:
1839         normalizer = unorm2_getNFKCInstance(&amp;status);
1840         break;
1841     case NormalizationForm::NFKD:
1842         normalizer = unorm2_getNFKDInstance(&amp;status);
1843         break;
1844     }
1845     ASSERT(normalizer);
1846     ASSERT(U_SUCCESS(status));
1847     return normalizer;
1848 }
1849 
1850 static JSValue normalize(ExecState* exec, JSString* string, NormalizationForm form)
1851 {
1852     VM&amp; vm = exec-&gt;vm();
1853     auto scope = DECLARE_THROW_SCOPE(vm);
1854 
1855     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);
1856     RETURN_IF_EXCEPTION(scope, { });
1857 
1858     StringView view = viewWithString.view;
1859     if (view.is8Bit() &amp;&amp; (!normalizationAffects8Bit(form) || charactersAreAllASCII(view.characters8(), view.length())))
1860         RELEASE_AND_RETURN(scope, string);
1861 
1862     const UNormalizer2* normalizer = JSC::normalizer(form);
1863 
1864     // Since ICU does not offer functions that can perform normalization or check for
1865     // normalization with input that is Latin-1, we need to upconvert to UTF-16 at this point.
1866     auto characters = view.upconvertedCharacters();
1867 
1868     UErrorCode status = U_ZERO_ERROR;
1869     UBool isNormalized = unorm2_isNormalized(normalizer, characters, view.length(), &amp;status);
1870     ASSERT(U_SUCCESS(status));
1871     if (isNormalized)
1872         RELEASE_AND_RETURN(scope, string);
1873 
1874     int32_t normalizedStringLength = unorm2_normalize(normalizer, characters, view.length(), nullptr, 0, &amp;status);
1875     ASSERT(status == U_BUFFER_OVERFLOW_ERROR);
1876 
1877     UChar* buffer;
1878     auto result = StringImpl::tryCreateUninitialized(normalizedStringLength, buffer);
1879     if (!result)
1880         return throwOutOfMemoryError(exec, scope);
1881 
1882     status = U_ZERO_ERROR;
1883     unorm2_normalize(normalizer, characters, view.length(), buffer, normalizedStringLength, &amp;status);
1884     ASSERT(U_SUCCESS(status));
1885 
1886     RELEASE_AND_RETURN(scope, jsString(&amp;vm, WTFMove(result)));
1887 }
1888 
1889 EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(ExecState* exec)
1890 {
1891     VM&amp; vm = exec-&gt;vm();
1892     auto scope = DECLARE_THROW_SCOPE(vm);
1893 
1894     JSValue thisValue = exec-&gt;thisValue();
1895     if (!checkObjectCoercible(thisValue))
1896         return throwVMTypeError(exec, scope);
1897     JSString* string = thisValue.toString(exec);
1898     RETURN_IF_EXCEPTION(scope, { });
1899 
1900     auto form = NormalizationForm::NFC;
1901     JSValue formValue = exec-&gt;argument(0);
1902     if (!formValue.isUndefined()) {
1903         String formString = formValue.toWTFString(exec);
1904         RETURN_IF_EXCEPTION(scope, { });
1905 
1906         if (formString == &quot;NFC&quot;)
1907             form = NormalizationForm::NFC;
1908         else if (formString == &quot;NFD&quot;)
1909             form = NormalizationForm::NFD;
1910         else if (formString == &quot;NFKC&quot;)
1911             form = NormalizationForm::NFKC;
1912         else if (formString == &quot;NFKD&quot;)
1913             form = NormalizationForm::NFKD;
1914         else
1915             return throwVMRangeError(exec, scope, &quot;argument does not match any normalization form&quot;_s);
1916     }
1917 
1918     RELEASE_AND_RETURN(scope, JSValue::encode(normalize(exec, string, form)));
1919 }
1920 
1921 } // namespace JSC
    </pre>
  </body>
</html>