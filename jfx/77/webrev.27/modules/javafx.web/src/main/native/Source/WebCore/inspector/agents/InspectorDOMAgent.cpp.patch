diff a/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp b/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2009-2017 Apple Inc. All rights reserved.
+ * Copyright (C) 2009-2019 Apple Inc. All rights reserved.
  * Copyright (C) 2011 Google Inc. All rights reserved.
  * Copyright (C) 2009 Joseph Pecoraro
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -57,20 +57,23 @@
 #include "Event.h"
 #include "EventListener.h"
 #include "EventNames.h"
 #include "Frame.h"
 #include "FrameTree.h"
+#include "FrameView.h"
+#include "FullscreenManager.h"
 #include "HTMLElement.h"
 #include "HTMLFrameOwnerElement.h"
 #include "HTMLMediaElement.h"
 #include "HTMLNames.h"
 #include "HTMLParserIdioms.h"
 #include "HTMLScriptElement.h"
 #include "HTMLStyleElement.h"
 #include "HTMLTemplateElement.h"
 #include "HTMLVideoElement.h"
 #include "HitTestResult.h"
+#include "InspectorCSSAgent.h"
 #include "InspectorClient.h"
 #include "InspectorController.h"
 #include "InspectorHistory.h"
 #include "InspectorNodeFinder.h"
 #include "InspectorOverlay.h"
@@ -248,11 +251,11 @@
 
         RefPtr<JSON::Object> data = JSON::Object::create();
 
 #if ENABLE(FULLSCREEN_API)
         if (event.type() == eventNames().webkitfullscreenchangeEvent)
-            data->setBoolean("enabled"_s, !!node->document().webkitFullscreenElement());
+            data->setBoolean("enabled"_s, !!node->document().fullscreenManager().fullscreenElement());
 #endif // ENABLE(FULLSCREEN_API)
 
         auto timestamp = m_domAgent.m_environment.executionStopwatch()->elapsedTime().seconds();
         m_domAgent.m_frontendDispatcher->didFireEvent(nodeId, event.type(), timestamp, data->size() ? WTFMove(data) : nullptr);
     }
@@ -275,58 +278,53 @@
 String InspectorDOMAgent::toErrorString(Exception&& exception)
 {
     return DOMException::name(exception.code());
 }
 
-InspectorDOMAgent::InspectorDOMAgent(WebAgentContext& context, InspectorPageAgent* pageAgent, InspectorOverlay* overlay)
+InspectorDOMAgent::InspectorDOMAgent(PageAgentContext& context, InspectorOverlay* overlay)
     : InspectorAgentBase("DOM"_s, context)
     , m_injectedScriptManager(context.injectedScriptManager)
-    , m_frontendDispatcher(std::make_unique<Inspector::DOMFrontendDispatcher>(context.frontendRouter))
+    , m_frontendDispatcher(makeUnique<Inspector::DOMFrontendDispatcher>(context.frontendRouter))
     , m_backendDispatcher(Inspector::DOMBackendDispatcher::create(context.backendDispatcher, this))
-    , m_pageAgent(pageAgent)
+    , m_inspectedPage(context.inspectedPage)
     , m_overlay(overlay)
 #if ENABLE(VIDEO)
     , m_mediaMetricsTimer(*this, &InspectorDOMAgent::mediaMetricsTimerFired)
 #endif
 {
 }
 
-InspectorDOMAgent::~InspectorDOMAgent()
-{
-    reset();
-    ASSERT(!m_searchingForNode);
-}
+InspectorDOMAgent::~InspectorDOMAgent() = default;
 
 void InspectorDOMAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 {
-    m_history = std::make_unique<InspectorHistory>();
-    m_domEditor = std::make_unique<DOMEditor>(*m_history);
+    m_history = makeUnique<InspectorHistory>();
+    m_domEditor = makeUnique<DOMEditor>(*m_history);
 
     m_instrumentingAgents.setInspectorDOMAgent(this);
-    m_document = m_pageAgent->mainFrame().document();
+    m_document = m_inspectedPage.mainFrame().document();
 
 #if ENABLE(VIDEO)
     if (m_document)
         addEventListenersToNode(*m_document);
 
     for (auto* mediaElement : HTMLMediaElement::allMediaElements())
         addEventListenersToNode(*mediaElement);
 #endif
-
-    if (m_nodeToFocus)
-        focusNode();
 }
 
 void InspectorDOMAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
 {
     m_history.reset();
     m_domEditor.reset();
+    m_nodeToFocus = nullptr;
     m_mousedOverNode = nullptr;
+    m_inspectedNode = nullptr;
 
-    ErrorString unused;
-    setSearchingForNode(unused, false, nullptr);
-    hideHighlight(unused);
+    ErrorString ignored;
+    setSearchingForNode(ignored, false, nullptr, false);
+    hideHighlight(ignored);
 
     m_instrumentingAgents.setInspectorDOMAgent(nullptr);
     m_documentRequested = false;
     reset();
 }
@@ -352,15 +350,10 @@
     if (m_revalidateStyleAttrTask)
         m_revalidateStyleAttrTask->reset();
     m_document = nullptr;
 }
 
-void InspectorDOMAgent::setDOMListener(DOMListener* listener)
-{
-    m_domListener = listener;
-}
-
 void InspectorDOMAgent::setDocument(Document* document)
 {
     if (document == m_document.get())
         return;
 
@@ -416,12 +409,13 @@
         if (PseudoElement* afterElement = element.afterPseudoElement())
             unbind(afterElement, nodesMap);
     }
 
     nodesMap->remove(node);
-    if (m_domListener)
-        m_domListener->didRemoveDOMNode(*node, id);
+
+    if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())
+        cssAgent->didRemoveDOMNode(*node, id);
 
     if (m_childrenRequested.remove(id)) {
         // FIXME: Would be better to do this iteratively rather than recursively.
         for (Node* child = innerFirstChild(node); child; child = innerNextSibling(child))
             unbind(child, nodesMap);
@@ -430,35 +424,35 @@
 
 Node* InspectorDOMAgent::assertNode(ErrorString& errorString, int nodeId)
 {
     Node* node = nodeForId(nodeId);
     if (!node) {
-        errorString = "Could not find node with given id"_s;
+        errorString = "Missing node for given nodeId"_s;
         return nullptr;
     }
     return node;
 }
 
 Document* InspectorDOMAgent::assertDocument(ErrorString& errorString, int nodeId)
 {
     Node* node = assertNode(errorString, nodeId);
     if (!node)
         return nullptr;
-    if (!is<Document>(*node)) {
-        errorString = "Document is not available"_s;
+    if (!is<Document>(node)) {
+        errorString = "Node for given nodeId is not a document"_s;
         return nullptr;
     }
     return downcast<Document>(node);
 }
 
 Element* InspectorDOMAgent::assertElement(ErrorString& errorString, int nodeId)
 {
     Node* node = assertNode(errorString, nodeId);
     if (!node)
         return nullptr;
-    if (!is<Element>(*node)) {
-        errorString = "Node is not an Element"_s;
+    if (!is<Element>(node)) {
+        errorString = "Node for given nodeId is not an element"_s;
         return nullptr;
     }
     return downcast<Element>(node);
 }
 
@@ -466,51 +460,50 @@
 {
     Node* node = assertNode(errorString, nodeId);
     if (!node)
         return nullptr;
     if (node->isInUserAgentShadowTree()) {
-        errorString = "Cannot edit nodes in user agent shadow trees"_s;
+        errorString = "Node for given nodeId is in a shadow tree"_s;
         return nullptr;
     }
     if (node->isPseudoElement()) {
-        errorString = "Cannot edit pseudo elements"_s;
+        errorString = "Node for given nodeId is a pseudo-element"_s;
         return nullptr;
     }
     return node;
 }
 
 Element* InspectorDOMAgent::assertEditableElement(ErrorString& errorString, int nodeId)
 {
-    Element* element = assertElement(errorString, nodeId);
-    if (!element)
-        return nullptr;
-    if (element->isInUserAgentShadowTree()) {
-        errorString = "Cannot edit elements in user agent shadow trees"_s;
+    Node* node = assertEditableNode(errorString, nodeId);
+    if (!node)
         return nullptr;
-    }
-    if (element->isPseudoElement()) {
-        errorString = "Cannot edit pseudo elements"_s;
+    if (!is<Element>(node)) {
+        errorString = "Node for given nodeId is not an element"_s;
         return nullptr;
     }
-    return element;
+    return downcast<Element>(node);
 }
 
 void InspectorDOMAgent::getDocument(ErrorString& errorString, RefPtr<Inspector::Protocol::DOM::Node>& root)
 {
     m_documentRequested = true;
 
     if (!m_document) {
-        errorString = "Document is not available"_s;
+        errorString = "Internal error: missing document"_s;
         return;
     }
 
     // Reset backend state.
     RefPtr<Document> document = m_document;
     reset();
     m_document = document;
 
     root = buildObjectForNode(m_document.get(), 2, &m_documentNodeToIdMap);
+
+    if (m_nodeToFocus)
+        focusNode();
 }
 
 void InspectorDOMAgent::pushChildNodesToFrontend(int nodeId, int depth)
 {
     Node* node = nodeForId(nodeId);
@@ -552,11 +545,11 @@
 {
     Document* document = assertDocument(errorString, documentNodeId);
     if (!document)
         return 0;
     if (&nodeToPush->document() != document) {
-        errorString = "Node is not part of the document with given id"_s;
+        errorString = "nodeToPush is not part of the document with given documentNodeId"_s;
         return 0;
     }
 
     return pushNodePathToFrontend(nodeToPush);
 }
@@ -578,11 +571,11 @@
     else if (*depth == -1)
         sanitizedDepth = INT_MAX;
     else if (*depth > 0)
         sanitizedDepth = *depth;
     else {
-        errorString = "Please provide a positive integer as a depth or -1 for entire subtree"_s;
+        errorString = "Unexpected value below -1 for given depth"_s;
         return;
     }
 
     pushChildNodesToFrontend(nodeId, sanitizedDepth);
 }
@@ -598,11 +591,11 @@
         return;
     }
 
     auto queryResult = downcast<ContainerNode>(*node).querySelector(selectors);
     if (queryResult.hasException()) {
-        errorString = "DOM Error while querying"_s;
+        errorString = "DOM Error while querying with given selectors"_s;
         return;
     }
 
     if (auto* element = queryResult.releaseReturnValue())
         *elementId = pushNodePathToFrontend(element);
@@ -618,11 +611,11 @@
         return;
     }
 
     auto queryResult = downcast<ContainerNode>(*node).querySelectorAll(selectors);
     if (queryResult.hasException()) {
-        errorString = "DOM Error while querying"_s;
+        errorString = "DOM Error while querying with given selectors"_s;
         return;
     }
 
     auto nodes = queryResult.releaseReturnValue();
     result = JSON::ArrayOf<int>::create();
@@ -650,11 +643,11 @@
 
     while (true) {
         Node* parent = innerParentNode(node);
         if (!parent) {
             // Node being pushed is detached -> push subtree root.
-            auto newMap = std::make_unique<NodeToIdMap>();
+            auto newMap = makeUnique<NodeToIdMap>();
             danglingMap = newMap.get();
             m_danglingNodeToIdMaps.append(newMap.release());
             auto children = JSON::ArrayOf<Inspector::Protocol::DOM::Node>::create();
             children->addItem(buildObjectForNode(node, 0, danglingMap));
             m_frontendDispatcher->setChildNodes(0, WTFMove(children));
@@ -704,11 +697,11 @@
         return;
     }
 
     Node* child = parsedElement->firstChild();
     if (!child) {
-        errorString = "Could not parse value as attributes"_s;
+        errorString = "Could not parse given text"_s;
         return;
     }
 
     Element* childElement = downcast<Element>(child);
     if (!childElement->hasAttributes() && name) {
@@ -807,11 +800,11 @@
     if (!node)
         return;
 
     Document& document = node->document();
     if (!document.isHTMLDocument() && !document.isXMLDocument()) {
-        errorString = "Not an HTML/XML document"_s;
+        errorString = "Document of node for given nodeId is not HTML/XML"_s;
         return;
     }
 
     Node* newNode = nullptr;
     if (!m_domEditor->setOuterHTML(*node, outerHTML, newNode, errorString))
@@ -834,11 +827,11 @@
     Node* node = assertEditableNode(errorString, nodeId);
     if (!node)
         return;
 
     if (!is<Element>(node)) {
-        errorString = "Can only call insertAdjacentHTML on Elements."_s;
+        errorString = "Node for given nodeId is not an element"_s;
         return;
     }
 
     m_domEditor->insertAdjacentHTML(downcast<Element>(*node), position, html, errorString);
 }
@@ -848,11 +841,11 @@
     Node* node = assertEditableNode(errorString, nodeId);
     if (!node)
         return;
 
     if (!is<Text>(*node)) {
-        errorString = "Can only set value of text nodes"_s;
+        errorString = "Node for given nodeId is not text"_s;
         return;
     }
 
     m_domEditor->replaceWholeText(downcast<Text>(*node), value, errorString);
 }
@@ -864,124 +857,131 @@
 #define DOM_EVENT_NAMES_ADD(name) eventNames->addItem(#name);
     DOM_EVENT_NAMES_FOR_EACH(DOM_EVENT_NAMES_ADD)
 #undef DOM_EVENT_NAMES_ADD
 }
 
-void InspectorDOMAgent::getEventListenersForNode(ErrorString& errorString, int nodeId, const String* objectGroup, RefPtr<JSON::ArrayOf<Inspector::Protocol::DOM::EventListener>>& listenersArray)
+void InspectorDOMAgent::getDataBindingsForNode(ErrorString& errorString, int /* nodeId */, RefPtr<JSON::ArrayOf<Inspector::Protocol::DOM::DataBinding>>& /* dataBindings */)
+{
+    errorString = "Not supported"_s;
+}
+
+void InspectorDOMAgent::getAssociatedDataForNode(ErrorString& errorString, int /* nodeId */, Optional<String>& /* associatedData */)
+{
+    errorString = "Not supported"_s;
+}
+
+void InspectorDOMAgent::getEventListenersForNode(ErrorString& errorString, int nodeId, RefPtr<JSON::ArrayOf<Inspector::Protocol::DOM::EventListener>>& listenersArray)
 {
     listenersArray = JSON::ArrayOf<Inspector::Protocol::DOM::EventListener>::create();
-    Node* node = assertNode(errorString, nodeId);
+
+    auto* node = assertNode(errorString, nodeId);
     if (!node)
         return;
+
+    Vector<RefPtr<EventTarget>> ancestors;
+    ancestors.append(node);
+    for (auto* ancestor = node->parentOrShadowHostNode(); ancestor; ancestor = ancestor->parentOrShadowHostNode())
+        ancestors.append(ancestor);
+    if (auto* window = node->document().domWindow())
+        ancestors.append(window);
+
+    struct EventListenerInfo {
+        RefPtr<EventTarget> eventTarget;
+        const AtomString eventType;
+        const EventListenerVector eventListeners;
+    };
+
     Vector<EventListenerInfo> eventInformation;
-    getEventListeners(node, eventInformation, true);
+    for (size_t i = ancestors.size(); i; --i) {
+        auto& ancestor = ancestors[i - 1];
+        for (auto& eventType : ancestor->eventTypes()) {
+            EventListenerVector filteredListeners;
+            for (auto& listener : ancestor->eventListeners(eventType)) {
+                if (listener->callback().type() == EventListener::JSEventListenerType)
+                    filteredListeners.append(listener);
+            }
+            if (!filteredListeners.isEmpty())
+                eventInformation.append({ ancestor, eventType, WTFMove(filteredListeners) });
+        }
+    }
 
     auto addListener = [&] (RegisteredEventListener& listener, const EventListenerInfo& info) {
         int identifier = 0;
         bool disabled = false;
         bool hasBreakpoint = false;
 
         for (auto& inspectorEventListener : m_eventListenerEntries.values()) {
-            if (inspectorEventListener.matches(*info.node, info.eventType, listener.callback(), listener.useCapture())) {
+            if (inspectorEventListener.matches(*info.eventTarget, info.eventType, listener.callback(), listener.useCapture())) {
                 identifier = inspectorEventListener.identifier;
                 disabled = inspectorEventListener.disabled;
                 hasBreakpoint = inspectorEventListener.hasBreakpoint;
                 break;
             }
         }
 
         if (!identifier) {
-            InspectorEventListener inspectorEventListener(m_lastEventListenerId++, *info.node, info.eventType, listener.callback(), listener.useCapture());
+            InspectorEventListener inspectorEventListener(m_lastEventListenerId++, *info.eventTarget, info.eventType, listener.callback(), listener.useCapture());
 
             identifier = inspectorEventListener.identifier;
             disabled = inspectorEventListener.disabled;
             hasBreakpoint = inspectorEventListener.hasBreakpoint;
 
             m_eventListenerEntries.add(identifier, inspectorEventListener);
         }
 
-        listenersArray->addItem(buildObjectForEventListener(listener, identifier, info.eventType, info.node, objectGroup, disabled, hasBreakpoint));
+        listenersArray->addItem(buildObjectForEventListener(listener, identifier, *info.eventTarget, info.eventType, disabled, hasBreakpoint));
     };
 
     // Get Capturing Listeners (in this order)
     size_t eventInformationLength = eventInformation.size();
     for (auto& info : eventInformation) {
-        for (auto& listener : info.eventListenerVector) {
+        for (auto& listener : info.eventListeners) {
             if (listener->useCapture())
                 addListener(*listener, info);
         }
     }
 
     // Get Bubbling Listeners (reverse order)
     for (size_t i = eventInformationLength; i; --i) {
         const EventListenerInfo& info = eventInformation[i - 1];
-        for (auto& listener : info.eventListenerVector) {
+        for (auto& listener : info.eventListeners) {
             if (!listener->useCapture())
                 addListener(*listener, info);
         }
     }
-}
-
-void InspectorDOMAgent::getEventListeners(Node* node, Vector<EventListenerInfo>& eventInformation, bool includeAncestors)
-{
-    // The Node's Ancestors including self.
-    Vector<Node*> ancestors;
-    // Push this node as the firs element.
-    ancestors.append(node);
-    if (includeAncestors) {
-        for (ContainerNode* ancestor = node->parentOrShadowHostNode(); ancestor; ancestor = ancestor->parentOrShadowHostNode())
-            ancestors.append(ancestor);
-    }
 
-    // Nodes and their Listeners for the concerned event types (order is top to bottom)
-    for (size_t i = ancestors.size(); i; --i) {
-        Node* ancestor = ancestors[i - 1];
-        EventTargetData* d = ancestor->eventTargetData();
-        if (!d)
-            continue;
-        // Get the list of event types this Node is concerned with
-        for (auto& type : d->eventListenerMap.eventTypes()) {
-            auto& listeners = ancestor->eventListeners(type);
-            EventListenerVector filteredListeners;
-            filteredListeners.reserveInitialCapacity(listeners.size());
-            for (auto& listener : listeners) {
-                if (listener->callback().type() == EventListener::JSEventListenerType)
-                    filteredListeners.uncheckedAppend(listener);
-            }
-            if (!filteredListeners.isEmpty())
-                eventInformation.append(EventListenerInfo(ancestor, type, WTFMove(filteredListeners)));
-        }
-    }
+    if (m_inspectedNode == node)
+        m_suppressEventListenerChangedEvent = false;
 }
 
 void InspectorDOMAgent::setEventListenerDisabled(ErrorString& errorString, int eventListenerId, bool disabled)
 {
     auto it = m_eventListenerEntries.find(eventListenerId);
     if (it == m_eventListenerEntries.end()) {
-        errorString = "No event listener for given identifier."_s;
+        errorString = "Missing event listener for given eventListenerId"_s;
         return;
     }
 
     it->value.disabled = disabled;
 }
 
 void InspectorDOMAgent::setBreakpointForEventListener(ErrorString& errorString, int eventListenerId)
 {
     auto it = m_eventListenerEntries.find(eventListenerId);
     if (it == m_eventListenerEntries.end()) {
-        errorString = "No event listener for given identifier."_s;
+        errorString = "Missing event listener for given eventListenerId"_s;
         return;
     }
 
     it->value.hasBreakpoint = true;
 }
 
 void InspectorDOMAgent::removeBreakpointForEventListener(ErrorString& errorString, int eventListenerId)
 {
     auto it = m_eventListenerEntries.find(eventListenerId);
     if (it == m_eventListenerEntries.end()) {
-        errorString = "No event listener for given identifier."_s;
+        errorString = "Missing event listener for given eventListenerId"_s;
         return;
     }
 
     it->value.hasBreakpoint = false;
 }
@@ -993,24 +993,24 @@
         return;
 
     axProperties = buildObjectForAccessibilityProperties(node);
 }
 
-void InspectorDOMAgent::performSearch(ErrorString& errorString, const String& whitespaceTrimmedQuery, const JSON::Array* nodeIds, String* searchId, int* resultCount)
+void InspectorDOMAgent::performSearch(ErrorString& errorString, const String& query, const JSON::Array* nodeIds, const bool* caseSensitive, String* searchId, int* resultCount)
 {
     // FIXME: Search works with node granularity - number of matches within node is not calculated.
-    InspectorNodeFinder finder(whitespaceTrimmedQuery);
+    InspectorNodeFinder finder(query, caseSensitive && *caseSensitive);
 
     if (nodeIds) {
         for (auto& nodeValue : *nodeIds) {
             if (!nodeValue) {
-                errorString = "Invalid nodeIds item."_s;
+                errorString = "Unexpected non-integer item in given nodeIds"_s;
                 return;
             }
             int nodeId = 0;
             if (!nodeValue->asInteger(nodeId)) {
-                errorString = "Invalid nodeIds item type. Expecting integer types."_s;
+                errorString = "Unexpected non-integer item in given nodeIds"_s;
                 return;
             }
             Node* node = assertNode(errorString, nodeId);
             if (!node) {
                 // assertNode should have filled the errorString for us.
@@ -1036,17 +1036,17 @@
 
 void InspectorDOMAgent::getSearchResults(ErrorString& errorString, const String& searchId, int fromIndex, int toIndex, RefPtr<JSON::ArrayOf<int>>& nodeIds)
 {
     SearchResults::iterator it = m_searchResults.find(searchId);
     if (it == m_searchResults.end()) {
-        errorString = "No search session with given id found"_s;
+        errorString = "Missing search result for given searchId"_s;
         return;
     }
 
     int size = it->value.size();
     if (fromIndex < 0 || toIndex > size || fromIndex >= toIndex) {
-        errorString = "Invalid search result range"_s;
+        errorString = "Invalid search result range for given fromIndex and toIndex"_s;
         return;
     }
 
     nodeIds = JSON::ArrayOf<int>::create();
     for (int i = fromIndex; i < toIndex; ++i)
@@ -1082,13 +1082,13 @@
     return false;
 }
 
 void InspectorDOMAgent::inspect(Node* inspectedNode)
 {
-    ErrorString unused;
+    ErrorString ignored;
     RefPtr<Node> node = inspectedNode;
-    setSearchingForNode(unused, false, nullptr);
+    setSearchingForNode(ignored, false, nullptr, false);
 
     if (node->nodeType() != Node::ELEMENT_NODE && node->nodeType() != Node::DOCUMENT_NODE)
         node = node->parentNode();
     m_nodeToFocus = node;
 
@@ -1098,11 +1098,11 @@
     focusNode();
 }
 
 void InspectorDOMAgent::focusNode()
 {
-    if (!m_frontendDispatcher)
+    if (!m_documentRequested)
         return;
 
     ASSERT(m_nodeToFocus);
 
     RefPtr<Node> node = m_nodeToFocus.get();
@@ -1137,39 +1137,41 @@
         node = node->parentNode();
     if (node && m_inspectModeHighlightConfig)
         m_overlay->highlightNode(node, *m_inspectModeHighlightConfig);
 }
 
-void InspectorDOMAgent::setSearchingForNode(ErrorString& errorString, bool enabled, const JSON::Object* highlightInspectorObject)
+void InspectorDOMAgent::setSearchingForNode(ErrorString& errorString, bool enabled, const JSON::Object* highlightInspectorObject, bool showRulers)
 {
     if (m_searchingForNode == enabled)
         return;
 
     m_searchingForNode = enabled;
 
-    if (enabled) {
+    m_overlay->setShowRulersDuringElementSelection(m_searchingForNode && showRulers);
+
+    if (m_searchingForNode) {
         m_inspectModeHighlightConfig = highlightConfigFromInspectorObject(errorString, highlightInspectorObject);
         if (!m_inspectModeHighlightConfig)
             return;
         highlightMousedOverNode();
     } else
         hideHighlight(errorString);
 
     m_overlay->didSetSearchingForNode(m_searchingForNode);
 
-    if (InspectorClient* client = m_pageAgent->page().inspectorController().inspectorClient())
+    if (InspectorClient* client = m_inspectedPage.inspectorController().inspectorClient())
         client->elementSelectionChanged(m_searchingForNode);
 }
 
 std::unique_ptr<HighlightConfig> InspectorDOMAgent::highlightConfigFromInspectorObject(ErrorString& errorString, const JSON::Object* highlightInspectorObject)
 {
     if (!highlightInspectorObject) {
         errorString = "Internal error: highlight configuration parameter is missing"_s;
         return nullptr;
     }
 
-    auto highlightConfig = std::make_unique<HighlightConfig>();
+    auto highlightConfig = makeUnique<HighlightConfig>();
     bool showInfo = false; // Default: false (do not show a tooltip).
     highlightInspectorObject->getBoolean("showInfo", showInfo);
     highlightConfig->showInfo = showInfo;
     highlightConfig->content = parseConfigColor("contentColor", highlightInspectorObject);
     highlightConfig->contentOutline = parseConfigColor("contentOutlineColor", highlightInspectorObject);
@@ -1177,34 +1179,34 @@
     highlightConfig->border = parseConfigColor("borderColor", highlightInspectorObject);
     highlightConfig->margin = parseConfigColor("marginColor", highlightInspectorObject);
     return highlightConfig;
 }
 
-void InspectorDOMAgent::setInspectModeEnabled(ErrorString& errorString, bool enabled, const JSON::Object* highlightConfig)
+void InspectorDOMAgent::setInspectModeEnabled(ErrorString& errorString, bool enabled, const JSON::Object* highlightConfig, const bool* showRulers)
 {
-    setSearchingForNode(errorString, enabled, highlightConfig ? highlightConfig : nullptr);
+    setSearchingForNode(errorString, enabled, highlightConfig ? highlightConfig : nullptr, showRulers && *showRulers);
 }
 
 void InspectorDOMAgent::highlightRect(ErrorString&, int x, int y, int width, int height, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
 {
-    auto quad = std::make_unique<FloatQuad>(FloatRect(x, y, width, height));
+    auto quad = makeUnique<FloatQuad>(FloatRect(x, y, width, height));
     innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
 }
 
 void InspectorDOMAgent::highlightQuad(ErrorString& errorString, const JSON::Array& quadArray, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
 {
-    auto quad = std::make_unique<FloatQuad>();
+    auto quad = makeUnique<FloatQuad>();
     if (!parseQuad(quadArray, quad.get())) {
-        errorString = "Invalid Quad format"_s;
+        errorString = "Unexpected invalid quadArray"_s;
         return;
     }
     innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
 }
 
 void InspectorDOMAgent::innerHighlightQuad(std::unique_ptr<FloatQuad> quad, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
 {
-    auto highlightConfig = std::make_unique<HighlightConfig>();
+    auto highlightConfig = makeUnique<HighlightConfig>();
     highlightConfig->content = parseColor(color);
     highlightConfig->contentOutline = parseColor(outlineColor);
     highlightConfig->usePageCoordinates = usePageCoordinates ? *usePageCoordinates : false;
     m_overlay->highlightQuad(WTFMove(quad), *highlightConfig);
 }
@@ -1212,29 +1214,33 @@
 void InspectorDOMAgent::highlightSelector(ErrorString& errorString, const JSON::Object& highlightInspectorObject, const String& selectorString, const String* frameId)
 {
     RefPtr<Document> document;
 
     if (frameId) {
-        Frame* frame = m_pageAgent->frameForId(*frameId);
-        if (!frame) {
-            errorString = "No frame for given id found"_s;
+        auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
+        if (!pageAgent) {
+            errorString = "Page domain must be enabled"_s;
             return;
         }
 
+        auto* frame = pageAgent->assertFrame(errorString, *frameId);
+        if (!frame)
+            return;
+
         document = frame->document();
     } else
         document = m_document;
 
     if (!document) {
-        errorString = "Document could not be found"_s;
+        errorString = "Missing document of frame for given frameId"_s;
         return;
     }
 
     auto queryResult = document->querySelectorAll(selectorString);
     // FIXME: <https://webkit.org/b/146161> Web Inspector: DOM.highlightSelector should work for "a:visited"
     if (queryResult.hasException()) {
-        errorString = "DOM Error while querying"_s;
+        errorString = "DOM Error while querying with given selectorString"_s;
         return;
     }
 
     auto highlightConfig = highlightConfigFromInspectorObject(errorString, &highlightInspectorObject);
     if (!highlightConfig)
@@ -1249,11 +1255,11 @@
     if (nodeId)
         node = assertNode(errorString, *nodeId);
     else if (objectId) {
         node = nodeForObjectId(*objectId);
         if (!node)
-            errorString = "Node for given objectId not found"_s;
+            errorString = "Missing node for given objectId"_s;
     } else
         errorString = "Either nodeId or objectId must be specified"_s;
 
     if (!node)
         return;
@@ -1268,17 +1274,17 @@
 void InspectorDOMAgent::highlightNodeList(ErrorString& errorString, const JSON::Array& nodeIds, const JSON::Object& highlightInspectorObject)
 {
     Vector<Ref<Node>> nodes;
     for (auto& nodeValue : nodeIds) {
         if (!nodeValue) {
-            errorString = "Invalid nodeIds item."_s;
+            errorString = "Unexpected non-integer item in given nodeIds"_s;
             return;
         }
 
         int nodeId = 0;
         if (!nodeValue->asInteger(nodeId)) {
-            errorString = "Invalid nodeIds item type. Expecting integer types."_s;
+            errorString = "Unexpected non-integer item in given nodeIds"_s;
             return;
         }
 
         // In the case that a node is removed in the time between when highlightNodeList is invoked
         // by the frontend and it is executed by the backend, we should still attempt to highlight
@@ -1299,16 +1305,22 @@
     m_overlay->highlightNodeList(StaticNodeList::create(WTFMove(nodes)), *highlightConfig);
 }
 
 void InspectorDOMAgent::highlightFrame(ErrorString& errorString, const String& frameId, const JSON::Object* color, const JSON::Object* outlineColor)
 {
-    Frame* frame = m_pageAgent->assertFrame(errorString, frameId);
+    auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
+    if (!pageAgent) {
+        errorString = "Page domain must be enabled"_s;
+        return;
+    }
+
+    auto* frame = pageAgent->assertFrame(errorString, frameId);
     if (!frame)
         return;
 
     if (frame->ownerElement()) {
-        auto highlightConfig = std::make_unique<HighlightConfig>();
+        auto highlightConfig = makeUnique<HighlightConfig>();
         highlightConfig->showInfo = true; // Always show tooltips for frames.
         highlightConfig->content = parseColor(color);
         highlightConfig->contentOutline = parseColor(outlineColor);
         m_overlay->highlightNode(frame->ownerElement(), *highlightConfig);
     }
@@ -1333,11 +1345,11 @@
     if (anchorNodeId && *anchorNodeId) {
         anchorNode = assertEditableNode(errorString, *anchorNodeId);
         if (!anchorNode)
             return;
         if (anchorNode->parentNode() != targetElement) {
-            errorString = "Anchor node must be child of the target element"_s;
+            errorString = "Given anchorNodeId must be a child of given targetElementId"_s;
             return;
         }
     }
 
     if (!m_domEditor->insertBefore(*targetElement, *node, anchorNode, errorString))
@@ -1369,39 +1381,44 @@
 {
     Element* element = assertElement(errorString, nodeId);
     if (!element)
         return;
     if (!element->isFocusable()) {
-        errorString = "Element is not focusable"_s;
+        errorString = "Element for given nodeId is not focusable"_s;
         return;
     }
     element->focus();
 }
 
 void InspectorDOMAgent::setInspectedNode(ErrorString& errorString, int nodeId)
 {
-    Node* node = nodeForId(nodeId);
-    if (!node || node->isInUserAgentShadowTree()) {
-        errorString = "No node with given id found"_s;
+    Node* node = assertNode(errorString, nodeId);
+    if (!node)
+        return;
+
+    if (node->isInUserAgentShadowTree()) {
+        errorString = "Node for given nodeId is in a shadow tree"_s;
         return;
     }
 
-    if (CommandLineAPIHost* commandLineAPIHost = static_cast<WebInjectedScriptManager&>(m_injectedScriptManager).commandLineAPIHost())
-        commandLineAPIHost->addInspectedObject(std::make_unique<InspectableNode>(node));
+    m_inspectedNode = node;
+
+    if (auto& commandLineAPIHost = static_cast<WebInjectedScriptManager&>(m_injectedScriptManager).commandLineAPIHost())
+        commandLineAPIHost->addInspectedObject(makeUnique<InspectableNode>(node));
+
+    m_suppressEventListenerChangedEvent = false;
 }
 
 void InspectorDOMAgent::resolveNode(ErrorString& errorString, int nodeId, const String* objectGroup, RefPtr<Inspector::Protocol::Runtime::RemoteObject>& result)
 {
     String objectGroupName = objectGroup ? *objectGroup : emptyString();
-    Node* node = nodeForId(nodeId);
-    if (!node) {
-        errorString = "No node with given id found"_s;
+    Node* node = assertNode(errorString, nodeId);
+    if (!node)
         return;
-    }
     RefPtr<Inspector::Protocol::Runtime::RemoteObject> object = resolveNode(node, objectGroupName);
     if (!object) {
-        errorString = "Node with given id does not belong to the document"_s;
+        errorString = "Missing injected script for given nodeId"_s;
         return;
     }
     result = object;
 }
 
@@ -1535,20 +1552,21 @@
         Ref<JSON::ArrayOf<Inspector::Protocol::DOM::Node>> children = buildArrayForContainerChildren(node, depth, nodesMap);
         if (children->length() > 0)
             value->setChildren(WTFMove(children));
     }
 
+    auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
+    if (pageAgent) {
+        if (auto* frameView = node->document().view())
+            value->setFrameId(pageAgent->frameId(&frameView->frame()));
+    }
+
     if (is<Element>(*node)) {
         Element& element = downcast<Element>(*node);
         value->setAttributes(buildArrayForElementAttributes(&element));
         if (is<HTMLFrameOwnerElement>(element)) {
-            HTMLFrameOwnerElement& frameOwner = downcast<HTMLFrameOwnerElement>(element);
-            Frame* frame = frameOwner.contentFrame();
-            if (frame)
-                value->setFrameId(m_pageAgent->frameId(frame));
-            Document* document = frameOwner.contentDocument();
-            if (document)
+            if (auto* document = downcast<HTMLFrameOwnerElement>(element).contentDocument())
                 value->setContentDocument(buildObjectForNode(document, 0, nodesMap));
         }
 
         if (ShadowRoot* root = element.shadowRoot()) {
             auto shadowRoots = JSON::ArrayOf<Inspector::Protocol::DOM::Node>::create();
@@ -1572,14 +1590,14 @@
                 value->setPseudoType(pseudoType);
         } else {
             if (auto pseudoElements = buildArrayForPseudoElements(element, nodesMap))
                 value->setPseudoElements(WTFMove(pseudoElements));
         }
-
     } else if (is<Document>(*node)) {
         Document& document = downcast<Document>(*node);
-        value->setFrameId(m_pageAgent->frameId(document.frame()));
+        if (pageAgent)
+            value->setFrameId(pageAgent->frameId(document.frame()));
         value->setDocumentURL(documentURLString(&document));
         value->setBaseURL(documentBaseURLString(&document));
         value->setXmlVersion(document.xmlVersion());
     } else if (is<DocumentType>(*node)) {
         DocumentType& docType = downcast<DocumentType>(*node);
@@ -1645,54 +1663,65 @@
     auto pseudoElements = JSON::ArrayOf<Inspector::Protocol::DOM::Node>::create();
     if (beforeElement)
         pseudoElements->addItem(buildObjectForNode(beforeElement, 0, nodesMap));
     if (afterElement)
         pseudoElements->addItem(buildObjectForNode(afterElement, 0, nodesMap));
-    return WTFMove(pseudoElements);
+    return pseudoElements;
 }
 
-Ref<Inspector::Protocol::DOM::EventListener> InspectorDOMAgent::buildObjectForEventListener(const RegisteredEventListener& registeredEventListener, int identifier, const AtomicString& eventType, Node* node, const String* objectGroupId, bool disabled, bool hasBreakpoint)
+Ref<Inspector::Protocol::DOM::EventListener> InspectorDOMAgent::buildObjectForEventListener(const RegisteredEventListener& registeredEventListener, int identifier, EventTarget& eventTarget, const AtomString& eventType, bool disabled, bool hasBreakpoint)
 {
     Ref<EventListener> eventListener = registeredEventListener.callback();
 
-    JSC::ExecState* exec = nullptr;
-    JSC::JSObject* handlerObject = nullptr;
-    JSC::JSFunction* handlerFunction = nullptr;
     String handlerName;
     int lineNumber = 0;
     int columnNumber = 0;
     String scriptID;
     if (is<JSEventListener>(eventListener.get())) {
         auto& scriptListener = downcast<JSEventListener>(eventListener.get());
 
+        Document* document = nullptr;
+        if (auto* scriptExecutionContext = eventTarget.scriptExecutionContext()) {
+            if (is<Document>(scriptExecutionContext))
+                document = downcast<Document>(scriptExecutionContext);
+        } else if (is<Node>(eventTarget))
+            document = &downcast<Node>(eventTarget).document();
+
+        JSC::JSObject* handlerObject = nullptr;
+        JSC::ExecState* exec = nullptr;
+
         JSC::JSLockHolder lock(scriptListener.isolatedWorld().vm());
 
-        exec = execStateFromNode(scriptListener.isolatedWorld(), &node->document());
-        handlerObject = scriptListener.jsFunction(node->document());
+        if (document) {
+            handlerObject = scriptListener.jsFunction(*document);
+            exec = execStateFromNode(scriptListener.isolatedWorld(), document);
+        }
+
         if (handlerObject && exec) {
-            handlerFunction = JSC::jsDynamicCast<JSC::JSFunction*>(exec->vm(), handlerObject);
+            JSC::VM& vm = exec->vm();
+            JSC::JSFunction* handlerFunction = JSC::jsDynamicCast<JSC::JSFunction*>(vm, handlerObject);
 
             if (!handlerFunction) {
-                auto scope = DECLARE_CATCH_SCOPE(exec->vm());
+                auto scope = DECLARE_CATCH_SCOPE(vm);
 
                 // If the handler is not actually a function, see if it implements the EventListener interface and use that.
-                auto handleEventValue = handlerObject->get(exec, JSC::Identifier::fromString(exec, "handleEvent"));
+                auto handleEventValue = handlerObject->get(exec, JSC::Identifier::fromString(vm, "handleEvent"));
 
                 if (UNLIKELY(scope.exception()))
                     scope.clearException();
 
                 if (handleEventValue)
-                    handlerFunction = JSC::jsDynamicCast<JSC::JSFunction*>(exec->vm(), handleEventValue);
+                    handlerFunction = JSC::jsDynamicCast<JSC::JSFunction*>(vm, handleEventValue);
             }
 
             if (handlerFunction && !handlerFunction->isHostOrBuiltinFunction()) {
                 // If the listener implements the EventListener interface, use the class name instead of
                 // "handleEvent", unless it is a plain object.
                 if (handlerFunction != handlerObject)
                     handlerName = JSC::JSObject::calculatedClassName(handlerObject);
                 if (handlerName.isEmpty() || handlerName == "Object"_s)
-                    handlerName = handlerFunction->calculatedDisplayName(exec->vm());
+                    handlerName = handlerFunction->calculatedDisplayName(vm);
 
                 if (auto executable = handlerFunction->jsExecutable()) {
                     lineNumber = executable->firstLine() - 1;
                     columnNumber = executable->startColumn() - 1;
                     scriptID = executable->sourceID() == JSC::SourceProvider::nullID ? emptyString() : String::number(executable->sourceID());
@@ -1704,17 +1733,15 @@
     auto value = Inspector::Protocol::DOM::EventListener::create()
         .setEventListenerId(identifier)
         .setType(eventType)
         .setUseCapture(registeredEventListener.useCapture())
         .setIsAttribute(eventListener->isAttribute())
-        .setNodeId(pushNodePathToFrontend(node))
         .release();
-    if (objectGroupId && handlerObject && exec) {
-        InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(exec);
-        if (!injectedScript.hasNoValue())
-            value->setHandlerObject(injectedScript.wrapObject(handlerObject, *objectGroupId));
-    }
+    if (is<Node>(eventTarget))
+        value->setNodeId(pushNodePathToFrontend(&downcast<Node>(eventTarget)));
+    else if (is<DOMWindow>(eventTarget))
+        value->setOnWindow(true);
     if (!scriptID.isNull()) {
         auto location = Inspector::Protocol::Debugger::Location::create()
             .setScriptId(scriptID)
             .setLineNumber(lineNumber)
             .release();
@@ -2048,11 +2075,11 @@
             value->setHierarchyLevel(level);
         if (isPopupButton)
             value->setIsPopUpButton(isPopupButton);
     }
 
-    return WTFMove(value);
+    return value;
 }
 
 static bool containsOnlyHTMLWhitespace(Node* node)
 {
     // FIXME: Respect ignoreWhitespace setting from inspector front end?
@@ -2101,10 +2128,19 @@
     return node->parentNode();
 }
 
 void InspectorDOMAgent::didCommitLoad(Document* document)
 {
+    if (m_nodeToFocus && &m_nodeToFocus->document() == document)
+        m_nodeToFocus = nullptr;
+
+    if (m_mousedOverNode && &m_mousedOverNode->document() == document)
+        m_mousedOverNode = nullptr;
+
+    if (m_inspectedNode && &m_inspectedNode->document() == document)
+        m_inspectedNode = nullptr;
+
     RefPtr<Element> frameOwner = document->ownerElement();
     if (!frameOwner)
         return;
 
     int frameOwnerId = m_documentNodeToIdMap.get(frameOwner);
@@ -2130,11 +2166,11 @@
 void InspectorDOMAgent::addEventListenersToNode(Node& node)
 {
 #if ENABLE(VIDEO)
     auto callback = EventFiredCallback::create(*this);
 
-    auto createEventListener = [&] (const AtomicString& eventName) {
+    auto createEventListener = [&] (const AtomString& eventName) {
         node.addEventListener(eventName, callback.copyRef(), false);
     };
 
 #if ENABLE(FULLSCREEN_API)
     if (is<Document>(node) || is<HTMLMediaElement>(node))
@@ -2216,57 +2252,55 @@
     } else
         m_frontendDispatcher->childNodeRemoved(parentId, m_documentNodeToIdMap.get(&node));
     unbind(&node, &m_documentNodeToIdMap);
 }
 
-void InspectorDOMAgent::willModifyDOMAttr(Element&, const AtomicString& oldValue, const AtomicString& newValue)
+void InspectorDOMAgent::willModifyDOMAttr(Element&, const AtomString& oldValue, const AtomString& newValue)
 {
     m_suppressAttributeModifiedEvent = (oldValue == newValue);
 }
 
-void InspectorDOMAgent::didModifyDOMAttr(Element& element, const AtomicString& name, const AtomicString& value)
+void InspectorDOMAgent::didModifyDOMAttr(Element& element, const AtomString& name, const AtomString& value)
 {
     bool shouldSuppressEvent = m_suppressAttributeModifiedEvent;
     m_suppressAttributeModifiedEvent = false;
     if (shouldSuppressEvent)
         return;
 
     int id = boundNodeId(&element);
-    // If node is not mapped yet -> ignore the event.
     if (!id)
         return;
 
-    if (m_domListener)
-        m_domListener->didModifyDOMAttr(element);
+    if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())
+        cssAgent->didModifyDOMAttr(element);
 
     m_frontendDispatcher->attributeModified(id, name, value);
 }
 
-void InspectorDOMAgent::didRemoveDOMAttr(Element& element, const AtomicString& name)
+void InspectorDOMAgent::didRemoveDOMAttr(Element& element, const AtomString& name)
 {
     int id = boundNodeId(&element);
-    // If node is not mapped yet -> ignore the event.
     if (!id)
         return;
 
-    if (m_domListener)
-        m_domListener->didModifyDOMAttr(element);
+    if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())
+        cssAgent->didModifyDOMAttr(element);
 
     m_frontendDispatcher->attributeRemoved(id, name);
 }
 
 void InspectorDOMAgent::styleAttributeInvalidated(const Vector<Element*>& elements)
 {
     auto nodeIds = JSON::ArrayOf<int>::create();
     for (auto& element : elements) {
         int id = boundNodeId(element);
-        // If node is not mapped yet -> ignore the event.
         if (!id)
             continue;
 
-        if (m_domListener)
-            m_domListener->didModifyDOMAttr(*element);
+        if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())
+            cssAgent->didModifyDOMAttr(*element);
+
         nodeIds->addItem(id);
     }
     m_frontendDispatcher->inlineStyleInvalidated(WTFMove(nodeIds));
 }
 
@@ -2279,20 +2313,19 @@
         return;
     }
     m_frontendDispatcher->characterDataModified(id, characterData.data());
 }
 
-void InspectorDOMAgent::didInvalidateStyleAttr(Node& node)
+void InspectorDOMAgent::didInvalidateStyleAttr(Element& element)
 {
-    int id = m_documentNodeToIdMap.get(&node);
-    // If node is not mapped yet -> ignore the event.
+    int id = m_documentNodeToIdMap.get(&element);
     if (!id)
         return;
 
     if (!m_revalidateStyleAttrTask)
-        m_revalidateStyleAttrTask = std::make_unique<RevalidateStyleAttributeTask>(this);
-    m_revalidateStyleAttrTask->scheduleFor(downcast<Element>(&node));
+        m_revalidateStyleAttrTask = makeUnique<RevalidateStyleAttributeTask>(this);
+    m_revalidateStyleAttrTask->scheduleFor(&element);
 }
 
 void InspectorDOMAgent::didPushShadowRoot(Element& host, ShadowRoot& root)
 {
     int hostId = m_documentNodeToIdMap.get(&host);
@@ -2364,22 +2397,34 @@
 void InspectorDOMAgent::didAddEventListener(EventTarget& target)
 {
     if (!is<Node>(target))
         return;
 
-    int nodeId = boundNodeId(&downcast<Node>(target));
+    auto& node = downcast<Node>(target);
+    if (!node.contains(m_inspectedNode.get()))
+        return;
+
+    int nodeId = boundNodeId(&node);
     if (!nodeId)
         return;
 
+    if (m_suppressEventListenerChangedEvent)
+        return;
+
+    m_suppressEventListenerChangedEvent = true;
+
     m_frontendDispatcher->didAddEventListener(nodeId);
 }
 
-void InspectorDOMAgent::willRemoveEventListener(EventTarget& target, const AtomicString& eventType, EventListener& listener, bool capture)
+void InspectorDOMAgent::willRemoveEventListener(EventTarget& target, const AtomString& eventType, EventListener& listener, bool capture)
 {
     if (!is<Node>(target))
         return;
+
     auto& node = downcast<Node>(target);
+    if (!node.contains(m_inspectedNode.get()))
+        return;
 
     int nodeId = boundNodeId(&node);
     if (!nodeId)
         return;
 
@@ -2396,14 +2441,19 @@
 
     m_eventListenerEntries.removeIf([&] (auto& entry) {
         return entry.value.matches(target, eventType, listener, capture);
     });
 
+    if (m_suppressEventListenerChangedEvent)
+        return;
+
+    m_suppressEventListenerChangedEvent = true;
+
     m_frontendDispatcher->willRemoveEventListener(nodeId);
 }
 
-bool InspectorDOMAgent::isEventListenerDisabled(EventTarget& target, const AtomicString& eventType, EventListener& listener, bool capture)
+bool InspectorDOMAgent::isEventListenerDisabled(EventTarget& target, const AtomString& eventType, EventListener& listener, bool capture)
 {
     for (auto& inspectorEventListener : m_eventListenerEntries.values()) {
         if (inspectorEventListener.matches(target, eventType, listener, capture))
             return inspectorEventListener.disabled;
     }
@@ -2413,20 +2463,20 @@
 void InspectorDOMAgent::eventDidResetAfterDispatch(const Event& event)
 {
     m_dispatchedEvents.remove(&event);
 }
 
-bool InspectorDOMAgent::hasBreakpointForEventListener(EventTarget& target, const AtomicString& eventType, EventListener& listener, bool capture)
+bool InspectorDOMAgent::hasBreakpointForEventListener(EventTarget& target, const AtomString& eventType, EventListener& listener, bool capture)
 {
     for (auto& inspectorEventListener : m_eventListenerEntries.values()) {
         if (inspectorEventListener.matches(target, eventType, listener, capture))
             return inspectorEventListener.hasBreakpoint;
     }
     return false;
 }
 
-int InspectorDOMAgent::idForEventListener(EventTarget& target, const AtomicString& eventType, EventListener& listener, bool capture)
+int InspectorDOMAgent::idForEventListener(EventTarget& target, const AtomString& eventType, EventListener& listener, bool capture)
 {
     for (auto& inspectorEventListener : m_eventListenerEntries.values()) {
         if (inspectorEventListener.matches(target, eventType, listener, capture))
             return inspectorEventListener.identifier;
     }
@@ -2456,18 +2506,18 @@
         if (iterator == m_mediaMetrics.end()) {
             m_mediaMetrics.set(mediaElement, MediaMetrics(displayCompositedVideoFrames));
             continue;
         }
 
-        bool isLowPower = (displayCompositedVideoFrames - iterator->value.displayCompositedFrames) > 0;
-        if (iterator->value.isLowPower != isLowPower) {
-            iterator->value.isLowPower = isLowPower;
+        bool isPowerEfficient = (displayCompositedVideoFrames - iterator->value.displayCompositedFrames) > 0;
+        if (iterator->value.isPowerEfficient != isPowerEfficient) {
+            iterator->value.isPowerEfficient = isPowerEfficient;
 
             int nodeId = pushNodePathToFrontend(mediaElement);
             if (nodeId) {
                 auto timestamp = m_environment.executionStopwatch()->elapsedTime().seconds();
-                m_frontendDispatcher->videoLowPowerChanged(nodeId, timestamp, iterator->value.isLowPower);
+                m_frontendDispatcher->powerEfficientPlaybackStateChanged(nodeId, timestamp, iterator->value.isPowerEfficient);
             }
         }
 
         iterator->value.displayCompositedFrames = displayCompositedVideoFrames;
     }
@@ -2529,16 +2579,19 @@
 void InspectorDOMAgent::pushNodeByPathToFrontend(ErrorString& errorString, const String& path, int* nodeId)
 {
     if (Node* node = nodeForPath(path))
         *nodeId = pushNodePathToFrontend(node);
     else
-        errorString = "No node with given path found"_s;
+        errorString = "Missing node for given path"_s;
 }
 
 RefPtr<Inspector::Protocol::Runtime::RemoteObject> InspectorDOMAgent::resolveNode(Node* node, const String& objectGroup)
 {
-    auto* frame = node->document().frame();
+    Document* document = &node->document();
+    if (auto* templateHost = document->templateDocumentHost())
+        document = templateHost;
+    auto* frame =  document->frame();
     if (!frame)
         return nullptr;
 
     auto& state = *mainWorldExecState(frame);
     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&state);
@@ -2550,11 +2603,11 @@
 
 Node* InspectorDOMAgent::scriptValueAsNode(JSC::JSValue value)
 {
     if (!value || !value.isObject())
         return nullptr;
-    return JSNode::toWrapped(*value.getObject()->vm(), value.getObject());
+    return JSNode::toWrapped(value.getObject()->vm(), value.getObject());
 }
 
 JSC::JSValue InspectorDOMAgent::nodeAsScriptValue(JSC::ExecState& state, Node* node)
 {
     JSC::JSLockHolder lock(&state);
