<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/Frame.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1998, 1999 Torben Weis &lt;weis@kde.org&gt;
   3  *                     1999 Lars Knoll &lt;knoll@kde.org&gt;
   4  *                     1999 Antti Koivisto &lt;koivisto@kde.org&gt;
   5  *                     2000 Simon Hausmann &lt;hausmann@kde.org&gt;
   6  *                     2000 Stefan Schimanski &lt;1Stein@gmx.de&gt;
   7  *                     2001 George Staikos &lt;staikos@kde.org&gt;
<a name="1" id="anc1"></a><span class="line-modified">   8  * Copyright (C) 2004-2016 Apple Inc. All rights reserved.</span>
   9  * Copyright (C) 2005 Alexey Proskuryakov &lt;ap@nypop.com&gt;
  10  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
  11  * Copyright (C) 2008 Eric Seidel &lt;eric@webkit.org&gt;
  12  * Copyright (C) 2008 Google Inc.
  13  *
  14  * This library is free software; you can redistribute it and/or
  15  * modify it under the terms of the GNU Library General Public
  16  * License as published by the Free Software Foundation; either
  17  * version 2 of the License, or (at your option) any later version.
  18  *
  19  * This library is distributed in the hope that it will be useful,
  20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  22  * Library General Public License for more details.
  23  *
  24  * You should have received a copy of the GNU Library General Public License
  25  * along with this library; see the file COPYING.LIB.  If not, write to
  26  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  27  * Boston, MA 02110-1301, USA.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;Frame.h&quot;
  32 
  33 #include &quot;ApplyStyleCommand.h&quot;
  34 #include &quot;BackForwardController.h&quot;
  35 #include &quot;CSSAnimationController.h&quot;
  36 #include &quot;CSSComputedStyleDeclaration.h&quot;
  37 #include &quot;CSSPropertyNames.h&quot;
  38 #include &quot;CachedCSSStyleSheet.h&quot;
  39 #include &quot;CachedResourceLoader.h&quot;
  40 #include &quot;Chrome.h&quot;
  41 #include &quot;ChromeClient.h&quot;
  42 #include &quot;DOMWindow.h&quot;
  43 #include &quot;DocumentTimeline.h&quot;
  44 #include &quot;DocumentType.h&quot;
  45 #include &quot;Editing.h&quot;
  46 #include &quot;Editor.h&quot;
  47 #include &quot;EditorClient.h&quot;
  48 #include &quot;Event.h&quot;
  49 #include &quot;EventHandler.h&quot;
  50 #include &quot;EventNames.h&quot;
  51 #include &quot;FloatQuad.h&quot;
  52 #include &quot;FocusController.h&quot;
  53 #include &quot;FrameDestructionObserver.h&quot;
  54 #include &quot;FrameLoader.h&quot;
  55 #include &quot;FrameLoaderClient.h&quot;
  56 #include &quot;FrameSelection.h&quot;
  57 #include &quot;FrameView.h&quot;
  58 #include &quot;GraphicsContext.h&quot;
  59 #include &quot;GraphicsLayer.h&quot;
  60 #include &quot;HTMLFormControlElement.h&quot;
  61 #include &quot;HTMLFormElement.h&quot;
  62 #include &quot;HTMLFrameElementBase.h&quot;
  63 #include &quot;HTMLNames.h&quot;
  64 #include &quot;HTMLTableCellElement.h&quot;
  65 #include &quot;HTMLTableRowElement.h&quot;
  66 #include &quot;HitTestResult.h&quot;
  67 #include &quot;ImageBuffer.h&quot;
  68 #include &quot;InspectorInstrumentation.h&quot;
  69 #include &quot;JSWindowProxy.h&quot;
  70 #include &quot;Logging.h&quot;
  71 #include &quot;NavigationScheduler.h&quot;
  72 #include &quot;Navigator.h&quot;
  73 #include &quot;NodeList.h&quot;
  74 #include &quot;NodeTraversal.h&quot;
  75 #include &quot;Page.h&quot;
  76 #include &quot;PageCache.h&quot;
  77 #include &quot;ProcessWarming.h&quot;
  78 #include &quot;RenderLayerCompositor.h&quot;
  79 #include &quot;RenderTableCell.h&quot;
  80 #include &quot;RenderText.h&quot;
  81 #include &quot;RenderTextControl.h&quot;
  82 #include &quot;RenderTheme.h&quot;
  83 #include &quot;RenderView.h&quot;
  84 #include &quot;RenderWidget.h&quot;
  85 #include &quot;RuntimeEnabledFeatures.h&quot;
  86 #include &quot;SVGDocument.h&quot;
  87 #include &quot;SVGDocumentExtensions.h&quot;
  88 #include &quot;ScriptController.h&quot;
  89 #include &quot;ScriptSourceCode.h&quot;
  90 #include &quot;ScrollingCoordinator.h&quot;
  91 #include &quot;Settings.h&quot;
  92 #include &quot;StyleProperties.h&quot;
  93 #include &quot;StyleScope.h&quot;
  94 #include &quot;TextNodeTraversal.h&quot;
  95 #include &quot;TextResourceDecoder.h&quot;
  96 #include &quot;UserContentController.h&quot;
  97 #include &quot;UserContentURLPattern.h&quot;
<a name="2" id="anc2"></a>
  98 #include &quot;UserScript.h&quot;
  99 #include &quot;UserTypingGestureIndicator.h&quot;
 100 #include &quot;VisibleUnits.h&quot;
 101 #include &quot;markup.h&quot;
 102 #include &quot;npruntime_impl.h&quot;
 103 #include &quot;runtime_root.h&quot;
 104 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 105 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 106 #include &lt;wtf/StdLibExtras.h&gt;
 107 #include &lt;wtf/text/StringBuilder.h&gt;
 108 
<a name="3" id="anc3"></a><span class="line-removed"> 109 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 110 #include &quot;WKContentObservation.h&quot;</span>
<span class="line-removed"> 111 #endif</span>
<span class="line-removed"> 112 </span>
 113 namespace WebCore {
 114 
 115 using namespace HTMLNames;
 116 
 117 #if PLATFORM(IOS_FAMILY)
 118 static const Seconds scrollFrequency { 1000_s / 60. };
 119 #endif
 120 
 121 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, frameCounter, (&quot;Frame&quot;));
 122 
<a name="4" id="anc4"></a>


 123 static inline Frame* parentFromOwnerElement(HTMLFrameOwnerElement* ownerElement)
 124 {
 125     if (!ownerElement)
 126         return 0;
 127     return ownerElement-&gt;document().frame();
 128 }
 129 
 130 static inline float parentPageZoomFactor(Frame* frame)
 131 {
 132     Frame* parent = frame-&gt;tree().parent();
 133     if (!parent)
 134         return 1;
 135     return parent-&gt;pageZoomFactor();
 136 }
 137 
 138 static inline float parentTextZoomFactor(Frame* frame)
 139 {
 140     Frame* parent = frame-&gt;tree().parent();
 141     if (!parent)
 142         return 1;
 143     return parent-&gt;textZoomFactor();
 144 }
 145 
 146 Frame::Frame(Page&amp; page, HTMLFrameOwnerElement* ownerElement, FrameLoaderClient&amp; frameLoaderClient)
 147     : m_mainFrame(ownerElement ? page.mainFrame() : *this)
 148     , m_page(&amp;page)
 149     , m_settings(&amp;page.settings())
 150     , m_treeNode(*this, parentFromOwnerElement(ownerElement))
 151     , m_loader(makeUniqueRef&lt;FrameLoader&gt;(*this, frameLoaderClient))
 152     , m_navigationScheduler(makeUniqueRef&lt;NavigationScheduler&gt;(*this))
 153     , m_ownerElement(ownerElement)
 154     , m_script(makeUniqueRef&lt;ScriptController&gt;(*this))
 155     , m_editor(makeUniqueRef&lt;Editor&gt;(*this))
 156     , m_selection(makeUniqueRef&lt;FrameSelection&gt;(this))
 157     , m_animationController(makeUniqueRef&lt;CSSAnimationController&gt;(*this))
<a name="5" id="anc5"></a><span class="line-removed"> 158 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 159     , m_overflowAutoScrollTimer(*this, &amp;Frame::overflowAutoScrollTimerFired)</span>
<span class="line-removed"> 160     , m_selectionChangeCallbacksDisabled(false)</span>
<span class="line-removed"> 161 #endif</span>
 162     , m_pageZoomFactor(parentPageZoomFactor(this))
 163     , m_textZoomFactor(parentTextZoomFactor(this))
<a name="6" id="anc6"></a><span class="line-removed"> 164     , m_activeDOMObjectsAndAnimationsSuspendedCount(0)</span>
 165     , m_eventHandler(makeUniqueRef&lt;EventHandler&gt;(*this))
 166 {
 167     ProcessWarming::initializeNames();
 168 
 169     if (ownerElement) {
 170         m_mainFrame.selfOnlyRef();
 171         page.incrementSubframeCount();
 172         ownerElement-&gt;setContentFrame(this);
 173     }
 174 
 175 #ifndef NDEBUG
 176     frameCounter.increment();
 177 #endif
 178 
 179     // Pause future ActiveDOMObjects if this frame is being created while the page is in a paused state.
 180     Frame* parent = parentFromOwnerElement(ownerElement);
 181     if (parent &amp;&amp; parent-&gt;activeDOMObjectsAndAnimationsSuspended())
 182         suspendActiveDOMObjectsAndAnimations();
 183 }
 184 
 185 void Frame::init()
 186 {
 187     m_loader-&gt;init();
 188 }
 189 
 190 Ref&lt;Frame&gt; Frame::create(Page* page, HTMLFrameOwnerElement* ownerElement, FrameLoaderClient* client)
 191 {
 192     ASSERT(page);
 193     ASSERT(client);
 194     return adoptRef(*new Frame(*page, ownerElement, *client));
 195 }
 196 
 197 Frame::~Frame()
 198 {
 199     setView(nullptr);
 200     loader().cancelAndClear();
 201 
 202     // FIXME: We should not be doing all this work inside the destructor
 203 
 204 #ifndef NDEBUG
 205     frameCounter.decrement();
 206 #endif
 207 
 208     disconnectOwnerElement();
 209 
 210     while (auto* destructionObserver = m_destructionObservers.takeAny())
 211         destructionObserver-&gt;frameDestroyed();
 212 
 213     if (!isMainFrame())
 214         m_mainFrame.selfOnlyDeref();
 215 }
 216 
 217 void Frame::addDestructionObserver(FrameDestructionObserver* observer)
 218 {
 219     m_destructionObservers.add(observer);
 220 }
 221 
 222 void Frame::removeDestructionObserver(FrameDestructionObserver* observer)
 223 {
 224     m_destructionObservers.remove(observer);
 225 }
 226 
 227 void Frame::setView(RefPtr&lt;FrameView&gt;&amp;&amp; view)
 228 {
 229     // We the custom scroll bars as early as possible to prevent m_doc-&gt;detach()
 230     // from messing with the view such that its scroll bars won&#39;t be torn down.
 231     // FIXME: We should revisit this.
 232     if (m_view)
 233         m_view-&gt;prepareForDetach();
 234 
 235     // Prepare for destruction now, so any unload event handlers get run and the DOMWindow is
 236     // notified. If we wait until the view is destroyed, then things won&#39;t be hooked up enough for
 237     // these calls to work.
 238     if (!view &amp;&amp; m_doc &amp;&amp; m_doc-&gt;pageCacheState() != Document::InPageCache)
 239         m_doc-&gt;prepareForDestruction();
 240 
 241     if (m_view)
 242         m_view-&gt;layoutContext().unscheduleLayout();
 243 
 244     m_eventHandler-&gt;clear();
 245 
 246     RELEASE_ASSERT(!m_doc || !m_doc-&gt;hasLivingRenderTree());
 247 
 248     m_view = WTFMove(view);
 249 
 250     // Only one form submission is allowed per view of a part.
 251     // Since this part may be getting reused as a result of being
 252     // pulled from the back/forward cache, reset this flag.
 253     loader().resetMultipleFormSubmissionProtection();
 254 }
 255 
 256 void Frame::setDocument(RefPtr&lt;Document&gt;&amp;&amp; newDocument)
 257 {
 258     ASSERT(!newDocument || newDocument-&gt;frame() == this);
 259 
 260     if (m_documentIsBeingReplaced)
 261         return;
 262 
 263     m_documentIsBeingReplaced = true;
 264 
 265     if (isMainFrame()) {
 266         if (m_page)
 267             m_page-&gt;didChangeMainDocument();
 268         m_loader-&gt;client().dispatchDidChangeMainDocument();
 269 
 270         // We want to generate the same unique names whenever a page is loaded to avoid making layout tests
 271         // flaky and for things like form state restoration to work. To achieve this, we reset our frame
 272         // identifier generator every time the page is navigated.
 273         tree().resetFrameIdentifiers();
 274     }
 275 
 276 #if ENABLE(ATTACHMENT_ELEMENT)
 277     if (m_doc) {
 278         for (auto&amp; attachment : m_doc-&gt;attachmentElementsByIdentifier().values())
 279             editor().didRemoveAttachmentElement(attachment);
 280     }
 281 #endif
 282 
 283     if (m_doc &amp;&amp; m_doc-&gt;pageCacheState() != Document::InPageCache)
 284         m_doc-&gt;prepareForDestruction();
 285 
 286     m_doc = newDocument.copyRef();
 287     ASSERT(!m_doc || m_doc-&gt;domWindow());
 288     ASSERT(!m_doc || m_doc-&gt;domWindow()-&gt;frame() == this);
 289 
 290     // Don&#39;t use m_doc because it can be overwritten and we want to guarantee
 291     // that the document is not destroyed during this function call.
 292     if (newDocument)
 293         newDocument-&gt;didBecomeCurrentDocumentInFrame();
 294 
 295 #if ENABLE(ATTACHMENT_ELEMENT)
 296     if (m_doc) {
 297         for (auto&amp; attachment : m_doc-&gt;attachmentElementsByIdentifier().values())
 298             editor().didInsertAttachmentElement(attachment);
 299     }
 300 #endif
 301 
 302     InspectorInstrumentation::frameDocumentUpdated(*this);
 303 
 304     m_documentIsBeingReplaced = false;
 305 }
 306 
 307 #if ENABLE(ORIENTATION_EVENTS)
 308 void Frame::orientationChanged()
 309 {
 310     Vector&lt;Ref&lt;Frame&gt;&gt; frames;
 311     for (Frame* frame = this; frame; frame = frame-&gt;tree().traverseNext())
 312         frames.append(*frame);
 313 
 314     auto newOrientation = orientation();
 315     for (auto&amp; frame : frames) {
 316         if (Document* document = frame-&gt;document())
 317             document-&gt;orientationChanged(newOrientation);
 318     }
 319 }
 320 
 321 int Frame::orientation() const
 322 {
 323     if (m_page)
 324         return m_page-&gt;chrome().client().deviceOrientation();
 325     return 0;
 326 }
 327 #endif // ENABLE(ORIENTATION_EVENTS)
 328 
 329 static JSC::Yarr::RegularExpression createRegExpForLabels(const Vector&lt;String&gt;&amp; labels)
 330 {
 331     // REVIEW- version of this call in FrameMac.mm caches based on the NSArray ptrs being
 332     // the same across calls.  We can&#39;t do that.
 333 
 334     static NeverDestroyed&lt;JSC::Yarr::RegularExpression&gt; wordRegExp(&quot;\\w&quot;);
 335     StringBuilder pattern;
 336     pattern.append(&#39;(&#39;);
 337     unsigned int numLabels = labels.size();
 338     unsigned int i;
 339     for (i = 0; i &lt; numLabels; i++) {
 340         String label = labels[i];
 341 
 342         bool startsWithWordChar = false;
 343         bool endsWithWordChar = false;
 344         if (label.length()) {
 345             startsWithWordChar = wordRegExp.get().match(label.substring(0, 1)) &gt;= 0;
 346             endsWithWordChar = wordRegExp.get().match(label.substring(label.length() - 1, 1)) &gt;= 0;
 347         }
 348 
 349         if (i)
 350             pattern.append(&#39;|&#39;);
 351         // Search for word boundaries only if label starts/ends with &quot;word characters&quot;.
 352         // If we always searched for word boundaries, this wouldn&#39;t work for languages
 353         // such as Japanese.
 354         if (startsWithWordChar)
 355             pattern.appendLiteral(&quot;\\b&quot;);
 356         pattern.append(label);
 357         if (endsWithWordChar)
 358             pattern.appendLiteral(&quot;\\b&quot;);
 359     }
 360     pattern.append(&#39;)&#39;);
 361     return JSC::Yarr::RegularExpression(pattern.toString(), JSC::Yarr::TextCaseInsensitive);
 362 }
 363 
 364 String Frame::searchForLabelsAboveCell(const JSC::Yarr::RegularExpression&amp; regExp, HTMLTableCellElement* cell, size_t* resultDistanceFromStartOfCell)
 365 {
 366     HTMLTableCellElement* aboveCell = cell-&gt;cellAbove();
 367     if (aboveCell) {
 368         // search within the above cell we found for a match
 369         size_t lengthSearched = 0;
 370         for (Text* textNode = TextNodeTraversal::firstWithin(*aboveCell); textNode; textNode = TextNodeTraversal::next(*textNode, aboveCell)) {
 371             if (!textNode-&gt;renderer() || textNode-&gt;renderer()-&gt;style().visibility() != Visibility::Visible)
 372                 continue;
 373             // For each text chunk, run the regexp
 374             String nodeString = textNode-&gt;data();
 375             int pos = regExp.searchRev(nodeString);
 376             if (pos &gt;= 0) {
 377                 if (resultDistanceFromStartOfCell)
 378                     *resultDistanceFromStartOfCell = lengthSearched;
 379                 return nodeString.substring(pos, regExp.matchedLength());
 380             }
 381             lengthSearched += nodeString.length();
 382         }
 383     }
 384 
 385     // Any reason in practice to search all cells in that are above cell?
 386     if (resultDistanceFromStartOfCell)
 387         *resultDistanceFromStartOfCell = notFound;
 388     return String();
 389 }
 390 
 391 // FIXME: This should take an Element&amp;.
 392 String Frame::searchForLabelsBeforeElement(const Vector&lt;String&gt;&amp; labels, Element* element, size_t* resultDistance, bool* resultIsInCellAbove)
 393 {
 394     ASSERT(element);
 395     JSC::Yarr::RegularExpression regExp = createRegExpForLabels(labels);
 396     // We stop searching after we&#39;ve seen this many chars
 397     const unsigned int charsSearchedThreshold = 500;
 398     // This is the absolute max we search.  We allow a little more slop than
 399     // charsSearchedThreshold, to make it more likely that we&#39;ll search whole nodes.
 400     const unsigned int maxCharsSearched = 600;
 401     // If the starting element is within a table, the cell that contains it
 402     HTMLTableCellElement* startingTableCell = nullptr;
 403     bool searchedCellAbove = false;
 404 
 405     if (resultDistance)
 406         *resultDistance = notFound;
 407     if (resultIsInCellAbove)
 408         *resultIsInCellAbove = false;
 409 
 410     // walk backwards in the node tree, until another element, or form, or end of tree
 411     int unsigned lengthSearched = 0;
 412     Node* n;
 413     for (n = NodeTraversal::previous(*element); n &amp;&amp; lengthSearched &lt; charsSearchedThreshold; n = NodeTraversal::previous(*n)) {
 414         // We hit another form element or the start of the form - bail out
 415         if (is&lt;HTMLFormElement&gt;(*n) || is&lt;HTMLFormControlElement&gt;(*n))
 416             break;
 417 
 418         if (n-&gt;hasTagName(tdTag) &amp;&amp; !startingTableCell)
 419             startingTableCell = downcast&lt;HTMLTableCellElement&gt;(n);
 420         else if (is&lt;HTMLTableRowElement&gt;(*n) &amp;&amp; startingTableCell) {
 421             String result = searchForLabelsAboveCell(regExp, startingTableCell, resultDistance);
 422             if (!result.isEmpty()) {
 423                 if (resultIsInCellAbove)
 424                     *resultIsInCellAbove = true;
 425                 return result;
 426             }
 427             searchedCellAbove = true;
 428         } else if (n-&gt;isTextNode() &amp;&amp; n-&gt;renderer() &amp;&amp; n-&gt;renderer()-&gt;style().visibility() == Visibility::Visible) {
 429             // For each text chunk, run the regexp
 430             String nodeString = n-&gt;nodeValue();
 431             // add 100 for slop, to make it more likely that we&#39;ll search whole nodes
 432             if (lengthSearched + nodeString.length() &gt; maxCharsSearched)
 433                 nodeString = nodeString.right(charsSearchedThreshold - lengthSearched);
 434             int pos = regExp.searchRev(nodeString);
 435             if (pos &gt;= 0) {
 436                 if (resultDistance)
 437                     *resultDistance = lengthSearched;
 438                 return nodeString.substring(pos, regExp.matchedLength());
 439             }
 440             lengthSearched += nodeString.length();
 441         }
 442     }
 443 
 444     // If we started in a cell, but bailed because we found the start of the form or the
 445     // previous element, we still might need to search the row above us for a label.
 446     if (startingTableCell &amp;&amp; !searchedCellAbove) {
 447         String result = searchForLabelsAboveCell(regExp, startingTableCell, resultDistance);
 448         if (!result.isEmpty()) {
 449             if (resultIsInCellAbove)
 450                 *resultIsInCellAbove = true;
 451             return result;
 452         }
 453     }
 454     return String();
 455 }
 456 
 457 static String matchLabelsAgainstString(const Vector&lt;String&gt;&amp; labels, const String&amp; stringToMatch)
 458 {
 459     if (stringToMatch.isEmpty())
 460         return String();
 461 
 462     String mutableStringToMatch = stringToMatch;
 463 
 464     // Make numbers and _&#39;s in field names behave like word boundaries, e.g., &quot;address2&quot;
 465     replace(mutableStringToMatch, JSC::Yarr::RegularExpression(&quot;\\d&quot;), &quot; &quot;);
 466     mutableStringToMatch.replace(&#39;_&#39;, &#39; &#39;);
 467 
 468     JSC::Yarr::RegularExpression regExp = createRegExpForLabels(labels);
 469     // Use the largest match we can find in the whole string
 470     int pos;
 471     int length;
 472     int bestPos = -1;
 473     int bestLength = -1;
 474     int start = 0;
 475     do {
 476         pos = regExp.match(mutableStringToMatch, start);
 477         if (pos != -1) {
 478             length = regExp.matchedLength();
 479             if (length &gt;= bestLength) {
 480                 bestPos = pos;
 481                 bestLength = length;
 482             }
 483             start = pos + 1;
 484         }
 485     } while (pos != -1);
 486 
 487     if (bestPos != -1)
 488         return mutableStringToMatch.substring(bestPos, bestLength);
 489     return String();
 490 }
 491 
 492 String Frame::matchLabelsAgainstElement(const Vector&lt;String&gt;&amp; labels, Element* element)
 493 {
 494     // Match against the name element, then against the id element if no match is found for the name element.
 495     // See 7538330 for one popular site that benefits from the id element check.
 496     // FIXME: This code is mirrored in FrameMac.mm. It would be nice to make the Mac code call the platform-agnostic
 497     // code, which would require converting the NSArray of NSStrings to a Vector of Strings somewhere along the way.
 498     String resultFromNameAttribute = matchLabelsAgainstString(labels, element-&gt;getNameAttribute());
 499     if (!resultFromNameAttribute.isEmpty())
 500         return resultFromNameAttribute;
 501 
 502     return matchLabelsAgainstString(labels, element-&gt;attributeWithoutSynchronization(idAttr));
 503 }
 504 
 505 #if PLATFORM(IOS_FAMILY)
<a name="7" id="anc7"></a><span class="line-removed"> 506 void Frame::scrollOverflowLayer(RenderLayer* layer, const IntRect&amp; visibleRect, const IntRect&amp; exposeRect)</span>
<span class="line-removed"> 507 {</span>
<span class="line-removed"> 508     if (!layer)</span>
<span class="line-removed"> 509         return;</span>
<span class="line-removed"> 510 </span>
<span class="line-removed"> 511     RenderBox* box = layer-&gt;renderBox();</span>
<span class="line-removed"> 512     if (!box)</span>
<span class="line-removed"> 513         return;</span>
<span class="line-removed"> 514 </span>
<span class="line-removed"> 515     if (visibleRect.intersects(exposeRect))</span>
<span class="line-removed"> 516         return;</span>
<span class="line-removed"> 517 </span>
<span class="line-removed"> 518     // FIXME: Why isn&#39;t this just calling RenderLayer::scrollRectToVisible()?</span>
<span class="line-removed"> 519     ScrollOffset scrollOffset = layer-&gt;scrollOffset();</span>
<span class="line-removed"> 520     int exposeLeft = exposeRect.x();</span>
<span class="line-removed"> 521     int exposeRight = exposeLeft + exposeRect.width();</span>
<span class="line-removed"> 522     int clientWidth = roundToInt(box-&gt;clientWidth());</span>
<span class="line-removed"> 523     if (exposeLeft &lt;= 0)</span>
<span class="line-removed"> 524         scrollOffset.setX(std::max(0, scrollOffset.x() + exposeLeft - clientWidth / 2));</span>
<span class="line-removed"> 525     else if (exposeRight &gt;= clientWidth)</span>
<span class="line-removed"> 526         scrollOffset.setX(std::min(box-&gt;scrollWidth() - clientWidth, scrollOffset.x() + clientWidth / 2));</span>
<span class="line-removed"> 527 </span>
<span class="line-removed"> 528     int exposeTop = exposeRect.y();</span>
<span class="line-removed"> 529     int exposeBottom = exposeTop + exposeRect.height();</span>
<span class="line-removed"> 530     int clientHeight = roundToInt(box-&gt;clientHeight());</span>
<span class="line-removed"> 531     if (exposeTop &lt;= 0)</span>
<span class="line-removed"> 532         scrollOffset.setY(std::max(0, scrollOffset.y() + exposeTop - clientHeight / 2));</span>
<span class="line-removed"> 533     else if (exposeBottom &gt;= clientHeight)</span>
<span class="line-removed"> 534         scrollOffset.setY(std::min(box-&gt;scrollHeight() - clientHeight, scrollOffset.y() + clientHeight / 2));</span>
<span class="line-removed"> 535 </span>
<span class="line-removed"> 536     layer-&gt;scrollToOffset(scrollOffset, ScrollClamping::Unclamped);</span>
<span class="line-removed"> 537     selection().setCaretRectNeedsUpdate();</span>
<span class="line-removed"> 538     selection().updateAppearance();</span>
<span class="line-removed"> 539 }</span>
 540 
<a name="8" id="anc8"></a><span class="line-modified"> 541 void Frame::overflowAutoScrollTimerFired()</span>
 542 {
<a name="9" id="anc9"></a><span class="line-modified"> 543     if (!eventHandler().mousePressed() || checkOverflowScroll(PerformOverflowScroll) == OverflowScrollNone) {</span>
<span class="line-removed"> 544         if (m_overflowAutoScrollTimer.isActive())</span>
<span class="line-removed"> 545             m_overflowAutoScrollTimer.stop();</span>
<span class="line-removed"> 546     }</span>
 547 }
 548 
<a name="10" id="anc10"></a><span class="line-modified"> 549 void Frame::startOverflowAutoScroll(const IntPoint&amp; mousePosition)</span>
 550 {
<a name="11" id="anc11"></a><span class="line-modified"> 551     m_overflowAutoScrollPos = mousePosition;</span>
<span class="line-removed"> 552 </span>
<span class="line-removed"> 553     if (m_overflowAutoScrollTimer.isActive())</span>
<span class="line-removed"> 554         return;</span>
<span class="line-removed"> 555 </span>
<span class="line-removed"> 556     if (checkOverflowScroll(DoNotPerformOverflowScroll) == OverflowScrollNone)</span>
<span class="line-removed"> 557         return;</span>
<span class="line-removed"> 558 </span>
<span class="line-removed"> 559     m_overflowAutoScrollTimer.startRepeating(scrollFrequency);</span>
<span class="line-removed"> 560     m_overflowAutoScrollDelta = 3;</span>
 561 }
<a name="12" id="anc12"></a>
 562 
<a name="13" id="anc13"></a><span class="line-modified"> 563 int Frame::checkOverflowScroll(OverflowScrollAction action)</span>
 564 {
<a name="14" id="anc14"></a><span class="line-modified"> 565     Position extent = selection().selection().extent();</span>
<span class="line-modified"> 566     if (extent.isNull())</span>
<span class="line-removed"> 567         return OverflowScrollNone;</span>
<span class="line-removed"> 568 </span>
<span class="line-removed"> 569     RenderObject* renderer = extent.deprecatedNode()-&gt;renderer();</span>
<span class="line-removed"> 570     if (!renderer)</span>
<span class="line-removed"> 571         return OverflowScrollNone;</span>
<span class="line-removed"> 572 </span>
<span class="line-removed"> 573     FrameView* view = this-&gt;view();</span>
<span class="line-removed"> 574     if (!view)</span>
<span class="line-removed"> 575         return OverflowScrollNone;</span>
<span class="line-removed"> 576 </span>
<span class="line-removed"> 577     RenderBlock* containingBlock = renderer-&gt;containingBlock();</span>
<span class="line-removed"> 578     if (!containingBlock || !containingBlock-&gt;hasOverflowClip())</span>
<span class="line-removed"> 579         return OverflowScrollNone;</span>
<span class="line-removed"> 580     RenderLayer* layer = containingBlock-&gt;layer();</span>
<span class="line-removed"> 581     ASSERT(layer);</span>
<span class="line-removed"> 582 </span>
<span class="line-removed"> 583     IntRect visibleRect = IntRect(view-&gt;scrollX(), view-&gt;scrollY(), view-&gt;visibleWidth(), view-&gt;visibleHeight());</span>
<span class="line-removed"> 584     IntPoint position = m_overflowAutoScrollPos;</span>
<span class="line-removed"> 585     if (visibleRect.contains(position.x(), position.y()))</span>
<span class="line-removed"> 586         return OverflowScrollNone;</span>
<span class="line-removed"> 587 </span>
<span class="line-removed"> 588     int scrollType = 0;</span>
<span class="line-removed"> 589     int deltaX = 0;</span>
<span class="line-removed"> 590     int deltaY = 0;</span>
<span class="line-removed"> 591     IntPoint selectionPosition;</span>
<span class="line-removed"> 592 </span>
<span class="line-removed"> 593     // This constant will make the selection draw a little bit beyond the edge of the visible area.</span>
<span class="line-removed"> 594     // This prevents a visual glitch, in that you can fail to select a portion of a character that</span>
<span class="line-removed"> 595     // is being rendered right at the edge of the visible rectangle.</span>
<span class="line-removed"> 596     // FIXME: This probably needs improvement, and may need to take the font size into account.</span>
<span class="line-removed"> 597     static const int scrollBoundsAdjustment = 3;</span>
<span class="line-removed"> 598 </span>
<span class="line-removed"> 599     // FIXME: Make a small buffer at the end of a visible rectangle so that autoscrolling works</span>
<span class="line-removed"> 600     // even if the visible extends to the limits of the screen.</span>
<span class="line-removed"> 601     if (position.x() &lt; visibleRect.x()) {</span>
<span class="line-removed"> 602         scrollType |= OverflowScrollLeft;</span>
<span class="line-removed"> 603         if (action == PerformOverflowScroll) {</span>
<span class="line-removed"> 604             deltaX -= static_cast&lt;int&gt;(m_overflowAutoScrollDelta);</span>
<span class="line-removed"> 605             selectionPosition.setX(view-&gt;scrollX() - scrollBoundsAdjustment);</span>
<span class="line-removed"> 606         }</span>
<span class="line-removed"> 607     } else if (position.x() &gt; visibleRect.maxX()) {</span>
<span class="line-removed"> 608         scrollType |= OverflowScrollRight;</span>
<span class="line-removed"> 609         if (action == PerformOverflowScroll) {</span>
<span class="line-removed"> 610             deltaX += static_cast&lt;int&gt;(m_overflowAutoScrollDelta);</span>
<span class="line-removed"> 611             selectionPosition.setX(view-&gt;scrollX() + view-&gt;visibleWidth() + scrollBoundsAdjustment);</span>
<span class="line-removed"> 612         }</span>
<span class="line-removed"> 613     }</span>
 614 
<a name="15" id="anc15"></a><span class="line-modified"> 615     if (position.y() &lt; visibleRect.y()) {</span>
<span class="line-modified"> 616         scrollType |= OverflowScrollUp;</span>
<span class="line-removed"> 617         if (action == PerformOverflowScroll) {</span>
<span class="line-removed"> 618             deltaY -= static_cast&lt;int&gt;(m_overflowAutoScrollDelta);</span>
<span class="line-removed"> 619             selectionPosition.setY(view-&gt;scrollY() - scrollBoundsAdjustment);</span>
<span class="line-removed"> 620         }</span>
<span class="line-removed"> 621     } else if (position.y() &gt; visibleRect.maxY()) {</span>
<span class="line-removed"> 622         scrollType |= OverflowScrollDown;</span>
<span class="line-removed"> 623         if (action == PerformOverflowScroll) {</span>
<span class="line-removed"> 624             deltaY += static_cast&lt;int&gt;(m_overflowAutoScrollDelta);</span>
<span class="line-removed"> 625             selectionPosition.setY(view-&gt;scrollY() + view-&gt;visibleHeight() + scrollBoundsAdjustment);</span>
<span class="line-removed"> 626         }</span>
<span class="line-removed"> 627     }</span>
<span class="line-removed"> 628 </span>
<span class="line-removed"> 629     Ref&lt;Frame&gt; protectedThis(*this);</span>
 630 
<a name="16" id="anc16"></a><span class="line-modified"> 631     if (action == PerformOverflowScroll &amp;&amp; (deltaX || deltaY)) {</span>
<span class="line-modified"> 632         layer-&gt;scrollToOffset(layer-&gt;scrollOffset() + IntSize(deltaX, deltaY), ScrollClamping::Unclamped);</span>

 633 
<a name="17" id="anc17"></a><span class="line-modified"> 634         // Handle making selection.</span>
<span class="line-modified"> 635         VisiblePosition visiblePosition(renderer-&gt;positionForPoint(selectionPosition, nullptr));</span>
<span class="line-modified"> 636         if (visiblePosition.isNotNull()) {</span>
<span class="line-modified"> 637             VisibleSelection visibleSelection = selection().selection();</span>
<span class="line-modified"> 638             visibleSelection.setExtent(visiblePosition);</span>
<span class="line-modified"> 639             if (selection().granularity() != CharacterGranularity)</span>
<span class="line-modified"> 640                 visibleSelection.expandUsingGranularity(selection().granularity());</span>
<span class="line-modified"> 641             if (selection().shouldChangeSelection(visibleSelection))</span>
<span class="line-modified"> 642                 selection().setSelection(visibleSelection);</span>









 643         }
<a name="18" id="anc18"></a><span class="line-removed"> 644 </span>
<span class="line-removed"> 645         m_overflowAutoScrollDelta *= 1.02f; // Accelerate the scroll</span>
 646     }
<a name="19" id="anc19"></a><span class="line-modified"> 647     return scrollType;</span>
<span class="line-removed"> 648 }</span>
<span class="line-removed"> 649 </span>
<span class="line-removed"> 650 void Frame::setSelectionChangeCallbacksDisabled(bool selectionChangeCallbacksDisabled)</span>
<span class="line-removed"> 651 {</span>
<span class="line-removed"> 652     m_selectionChangeCallbacksDisabled = selectionChangeCallbacksDisabled;</span>
<span class="line-removed"> 653 }</span>
 654 
<a name="20" id="anc20"></a><span class="line-modified"> 655 bool Frame::selectionChangeCallbacksDisabled() const</span>
<span class="line-modified"> 656 {</span>
<span class="line-removed"> 657     return m_selectionChangeCallbacksDisabled;</span>
 658 }
<a name="21" id="anc21"></a><span class="line-removed"> 659 #endif // PLATFORM(IOS_FAMILY)</span>
 660 
 661 void Frame::setPrinting(bool printing, const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkRatio, AdjustViewSizeOrNot shouldAdjustViewSize)
 662 {
 663     if (!view())
 664         return;
 665     // In setting printing, we should not validate resources already cached for the document.
 666     // See https://bugs.webkit.org/show_bug.cgi?id=43704
 667     ResourceCacheValidationSuppressor validationSuppressor(m_doc-&gt;cachedResourceLoader());
 668 
 669     m_doc-&gt;setPrinting(printing);
 670     auto&amp; frameView = *view();
 671     frameView.adjustMediaTypeForPrinting(printing);
 672 
 673     m_doc-&gt;styleScope().didChangeStyleSheetEnvironment();
 674     if (shouldUsePrintingLayout())
 675         frameView.forceLayoutForPagination(pageSize, originalPageSize, maximumShrinkRatio, shouldAdjustViewSize);
 676     else {
 677         frameView.forceLayout();
 678         if (shouldAdjustViewSize == AdjustViewSize)
 679             frameView.adjustViewSize();
 680     }
 681 
 682     // Subframes of the one we&#39;re printing don&#39;t lay out to the page size.
 683     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
 684         child-&gt;setPrinting(printing, FloatSize(), FloatSize(), 0, shouldAdjustViewSize);
 685 }
 686 
 687 bool Frame::shouldUsePrintingLayout() const
 688 {
 689     // Only top frame being printed should be fit to page size.
 690     // Subframes should be constrained by parents only.
 691     return m_doc-&gt;printing() &amp;&amp; (!tree().parent() || !tree().parent()-&gt;m_doc-&gt;printing());
 692 }
 693 
 694 FloatSize Frame::resizePageRectsKeepingRatio(const FloatSize&amp; originalSize, const FloatSize&amp; expectedSize)
 695 {
 696     FloatSize resultSize;
 697     if (!contentRenderer())
 698         return FloatSize();
 699 
 700     if (contentRenderer()-&gt;style().isHorizontalWritingMode()) {
 701         ASSERT(fabs(originalSize.width()) &gt; std::numeric_limits&lt;float&gt;::epsilon());
 702         float ratio = originalSize.height() / originalSize.width();
 703         resultSize.setWidth(floorf(expectedSize.width()));
 704         resultSize.setHeight(floorf(resultSize.width() * ratio));
 705     } else {
 706         ASSERT(fabs(originalSize.height()) &gt; std::numeric_limits&lt;float&gt;::epsilon());
 707         float ratio = originalSize.width() / originalSize.height();
 708         resultSize.setHeight(floorf(expectedSize.height()));
 709         resultSize.setWidth(floorf(resultSize.height() * ratio));
 710     }
 711     return resultSize;
 712 }
 713 
 714 void Frame::injectUserScripts(UserScriptInjectionTime injectionTime)
 715 {
 716     if (!m_page)
 717         return;
 718 
 719     if (loader().stateMachine().creatingInitialEmptyDocument() &amp;&amp; !settings().shouldInjectUserScriptsInInitialEmptyDocument())
 720         return;
 721 
 722     m_page-&gt;userContentProvider().forEachUserScript([this, protectedThis = makeRef(*this), injectionTime](DOMWrapperWorld&amp; world, const UserScript&amp; script) {
 723         if (script.injectionTime() == injectionTime)
 724             injectUserScriptImmediately(world, script);
 725     });
 726 }
 727 
 728 void Frame::injectUserScriptImmediately(DOMWrapperWorld&amp; world, const UserScript&amp; script)
 729 {
 730     auto* document = this-&gt;document();
 731     if (!document)
 732         return;
 733     if (script.injectedFrames() == InjectInTopFrameOnly &amp;&amp; !isMainFrame())
 734         return;
 735     if (!UserContentURLPattern::matchesPatterns(document-&gt;url(), script.whitelist(), script.blacklist()))
 736         return;
<a name="22" id="anc22"></a>

 737 
<a name="23" id="anc23"></a><span class="line-modified"> 738     document-&gt;topDocument().setAsRunningUserScripts();</span>
 739     loader().client().willInjectUserScript(world);
 740     m_script-&gt;evaluateInWorld(ScriptSourceCode(script.source(), URL(script.url())), world);
 741 }
 742 
 743 RenderView* Frame::contentRenderer() const
 744 {
 745     return document() ? document()-&gt;renderView() : nullptr;
 746 }
 747 
 748 RenderWidget* Frame::ownerRenderer() const
 749 {
 750     auto* ownerElement = m_ownerElement;
 751     if (!ownerElement)
 752         return nullptr;
 753     auto* object = ownerElement-&gt;renderer();
 754     // FIXME: If &lt;object&gt; is ever fixed to disassociate itself from frames
 755     // that it has started but canceled, then this can turn into an ASSERT
 756     // since m_ownerElement would be nullptr when the load is canceled.
 757     // https://bugs.webkit.org/show_bug.cgi?id=18585
 758     if (!is&lt;RenderWidget&gt;(object))
 759         return nullptr;
 760     return downcast&lt;RenderWidget&gt;(object);
 761 }
 762 
 763 Frame* Frame::frameForWidget(const Widget&amp; widget)
 764 {
 765     if (auto* renderer = RenderWidget::find(widget))
 766         return renderer-&gt;frameOwnerElement().document().frame();
 767 
 768     // Assume all widgets are either a FrameView or owned by a RenderWidget.
 769     // FIXME: That assumption is not right for scroll bars!
 770     return &amp;downcast&lt;FrameView&gt;(widget).frame();
 771 }
 772 
 773 void Frame::clearTimers(FrameView *view, Document *document)
 774 {
 775     if (view) {
 776         view-&gt;layoutContext().unscheduleLayout();
 777         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
 778             if (auto* timeline = document-&gt;existingTimeline())
 779                 timeline-&gt;suspendAnimations();
 780         } else
 781             view-&gt;frame().animation().suspendAnimationsForDocument(document);
 782         view-&gt;frame().eventHandler().stopAutoscrollTimer();
 783     }
 784 }
 785 
 786 void Frame::clearTimers()
 787 {
 788     clearTimers(m_view.get(), document());
 789 }
 790 
 791 void Frame::willDetachPage()
 792 {
 793     if (Frame* parent = tree().parent())
 794         parent-&gt;loader().checkLoadComplete();
 795 
 796     for (auto&amp; observer : m_destructionObservers)
 797         observer-&gt;willDetachPage();
 798 
 799     // FIXME: It&#39;s unclear as to why this is called more than once, but it is,
 800     // so page() could be NULL.
 801     if (page() &amp;&amp; page()-&gt;focusController().focusedFrame() == this)
 802         page()-&gt;focusController().setFocusedFrame(nullptr);
 803 
 804     if (page() &amp;&amp; page()-&gt;scrollingCoordinator() &amp;&amp; m_view)
 805         page()-&gt;scrollingCoordinator()-&gt;willDestroyScrollableArea(*m_view);
 806 
<a name="24" id="anc24"></a><span class="line-removed"> 807 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 808     if (WebThreadCountOfObservedDOMTimers() &gt; 0 &amp;&amp; m_page) {</span>
<span class="line-removed"> 809         LOG(ContentObservation, &quot;Frame::willDetachPage: remove registered timers.&quot;);</span>
<span class="line-removed"> 810         m_page-&gt;chrome().client().clearContentChangeObservers(*this);</span>
<span class="line-removed"> 811     }</span>
<span class="line-removed"> 812 #endif</span>
<span class="line-removed"> 813 </span>
 814     script().clearScriptObjects();
 815     script().updatePlatformScriptObjects();
 816 
 817     // We promise that the Frame is always connected to a Page while the render tree is live.
 818     //
 819     // The render tree can be torn down in a few different ways, but the two important ones are:
 820     //
 821     // - When calling Frame::setView() with a null FrameView*. This is always done before calling
 822     //   Frame::willDetachPage (this function.) Hence the assertion below.
 823     //
 824     // - When adding a document to the page cache, the tree is torn down before instantiating
 825     //   the CachedPage+CachedFrame object tree.
 826     ASSERT(!document() || !document()-&gt;renderView());
 827 }
 828 
 829 void Frame::disconnectOwnerElement()
 830 {
 831     if (m_ownerElement) {
 832         m_ownerElement-&gt;clearContentFrame();
 833         if (m_page)
 834             m_page-&gt;decrementSubframeCount();
 835     }
 836     m_ownerElement = nullptr;
 837 
 838     if (auto* document = this-&gt;document())
 839         document-&gt;frameWasDisconnectedFromOwner();
 840 }
 841 
 842 String Frame::displayStringModifiedByEncoding(const String&amp; str) const
 843 {
 844     return document() ? document()-&gt;displayStringModifiedByEncoding(str) : str;
 845 }
 846 
 847 VisiblePosition Frame::visiblePositionForPoint(const IntPoint&amp; framePoint) const
 848 {
<a name="25" id="anc25"></a><span class="line-modified"> 849     HitTestResult result = eventHandler().hitTestResultAtPoint(framePoint, HitTestRequest::ReadOnly | HitTestRequest::Active);</span>
 850     Node* node = result.innerNonSharedNode();
 851     if (!node)
 852         return VisiblePosition();
 853     auto renderer = node-&gt;renderer();
 854     if (!renderer)
 855         return VisiblePosition();
 856     VisiblePosition visiblePos = renderer-&gt;positionForPoint(result.localPoint(), nullptr);
 857     if (visiblePos.isNull())
 858         visiblePos = firstPositionInOrBeforeNode(node);
 859     return visiblePos;
 860 }
 861 
 862 Document* Frame::documentAtPoint(const IntPoint&amp; point)
 863 {
 864     if (!view())
 865         return nullptr;
 866 
 867     IntPoint pt = view()-&gt;windowToContents(point);
 868     HitTestResult result = HitTestResult(pt);
 869 
 870     if (contentRenderer())
<a name="26" id="anc26"></a><span class="line-modified"> 871         result = eventHandler().hitTestResultAtPoint(pt);</span>
 872     return result.innerNode() ? &amp;result.innerNode()-&gt;document() : 0;
 873 }
 874 
 875 RefPtr&lt;Range&gt; Frame::rangeForPoint(const IntPoint&amp; framePoint)
 876 {
 877     VisiblePosition position = visiblePositionForPoint(framePoint);
 878     if (position.isNull())
 879         return nullptr;
 880 
 881     Position deepPosition = position.deepEquivalent();
 882     Text* containerText = deepPosition.containerText();
 883     if (!containerText || !containerText-&gt;renderer() || containerText-&gt;renderer()-&gt;style().userSelect() == UserSelect::None)
 884         return nullptr;
 885 
 886     VisiblePosition previous = position.previous();
 887     if (previous.isNotNull()) {
 888         RefPtr&lt;Range&gt; previousCharacterRange = makeRange(previous, position);
 889         LayoutRect rect = editor().firstRectForRange(previousCharacterRange.get());
 890         if (rect.contains(framePoint))
 891             return previousCharacterRange;
 892     }
 893 
 894     VisiblePosition next = position.next();
 895     if (RefPtr&lt;Range&gt; nextCharacterRange = makeRange(position, next)) {
 896         LayoutRect rect = editor().firstRectForRange(nextCharacterRange.get());
 897         if (rect.contains(framePoint))
 898             return nextCharacterRange;
 899     }
 900 
 901     return nullptr;
 902 }
 903 
 904 void Frame::createView(const IntSize&amp; viewportSize, const Optional&lt;Color&gt;&amp; backgroundColor,
 905     const IntSize&amp; fixedLayoutSize, const IntRect&amp; fixedVisibleContentRect,
 906     bool useFixedLayout, ScrollbarMode horizontalScrollbarMode, bool horizontalLock,
 907     ScrollbarMode verticalScrollbarMode, bool verticalLock)
 908 {
 909     ASSERT(m_page);
 910 
 911     bool isMainFrame = this-&gt;isMainFrame();
 912 
 913     if (isMainFrame &amp;&amp; view())
 914         view()-&gt;setParentVisible(false);
 915 
 916     setView(nullptr);
 917 
 918     RefPtr&lt;FrameView&gt; frameView;
 919     if (isMainFrame) {
 920         frameView = FrameView::create(*this, viewportSize);
 921         frameView-&gt;setFixedLayoutSize(fixedLayoutSize);
 922 #if USE(COORDINATED_GRAPHICS)
 923         frameView-&gt;setFixedVisibleContentRect(fixedVisibleContentRect);
 924 #else
 925         UNUSED_PARAM(fixedVisibleContentRect);
 926 #endif
 927         frameView-&gt;setUseFixedLayout(useFixedLayout);
 928     } else
 929         frameView = FrameView::create(*this);
 930 
 931     frameView-&gt;setScrollbarModes(horizontalScrollbarMode, verticalScrollbarMode, horizontalLock, verticalLock);
 932 
 933     setView(frameView.copyRef());
 934 
 935     frameView-&gt;updateBackgroundRecursively(backgroundColor);
 936 
 937     if (isMainFrame)
 938         frameView-&gt;setParentVisible(true);
 939 
 940     if (ownerRenderer())
 941         ownerRenderer()-&gt;setWidget(frameView);
 942 
 943     if (HTMLFrameOwnerElement* owner = ownerElement())
 944         view()-&gt;setCanHaveScrollbars(owner-&gt;scrollingMode() != ScrollbarAlwaysOff);
 945 }
 946 
 947 DOMWindow* Frame::window() const
 948 {
 949     return document() ? document()-&gt;domWindow() : nullptr;
 950 }
 951 
 952 AbstractDOMWindow* Frame::virtualWindow() const
 953 {
 954     return window();
 955 }
 956 
 957 String Frame::layerTreeAsText(LayerTreeFlags flags) const
 958 {
 959     document()-&gt;updateLayout();
 960 
 961     if (!contentRenderer())
 962         return String();
 963 
 964     return contentRenderer()-&gt;compositor().layerTreeAsText(flags);
 965 }
 966 
 967 String Frame::trackedRepaintRectsAsText() const
 968 {
 969     if (!m_view)
 970         return String();
 971     return m_view-&gt;trackedRepaintRectsAsText();
 972 }
 973 
 974 void Frame::setPageZoomFactor(float factor)
 975 {
 976     setPageAndTextZoomFactors(factor, m_textZoomFactor);
 977 }
 978 
 979 void Frame::setTextZoomFactor(float factor)
 980 {
 981     setPageAndTextZoomFactors(m_pageZoomFactor, factor);
 982 }
 983 
 984 void Frame::setPageAndTextZoomFactors(float pageZoomFactor, float textZoomFactor)
 985 {
 986     if (m_pageZoomFactor == pageZoomFactor &amp;&amp; m_textZoomFactor == textZoomFactor)
 987         return;
 988 
 989     Page* page = this-&gt;page();
 990     if (!page)
 991         return;
 992 
 993     Document* document = this-&gt;document();
 994     if (!document)
 995         return;
 996 
 997     m_editor-&gt;dismissCorrectionPanelAsIgnored();
 998 
 999     // Respect SVGs zoomAndPan=&quot;disabled&quot; property in standalone SVG documents.
1000     // FIXME: How to handle compound documents + zoomAndPan=&quot;disabled&quot;? Needs SVG WG clarification.
1001     if (is&lt;SVGDocument&gt;(*document) &amp;&amp; !downcast&lt;SVGDocument&gt;(*document).zoomAndPanEnabled())
1002         return;
1003 
1004     if (m_pageZoomFactor != pageZoomFactor) {
1005         if (FrameView* view = this-&gt;view()) {
1006             // Update the scroll position when doing a full page zoom, so the content stays in relatively the same position.
1007             LayoutPoint scrollPosition = view-&gt;scrollPosition();
1008             float percentDifference = (pageZoomFactor / m_pageZoomFactor);
1009             view-&gt;setScrollPosition(IntPoint(scrollPosition.x() * percentDifference, scrollPosition.y() * percentDifference));
1010         }
1011     }
1012 
1013     m_pageZoomFactor = pageZoomFactor;
1014     m_textZoomFactor = textZoomFactor;
1015 
1016     document-&gt;resolveStyle(Document::ResolveStyleType::Rebuild);
1017 
1018     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
1019         child-&gt;setPageAndTextZoomFactors(m_pageZoomFactor, m_textZoomFactor);
1020 
1021     if (FrameView* view = this-&gt;view()) {
1022         if (document-&gt;renderView() &amp;&amp; document-&gt;renderView()-&gt;needsLayout() &amp;&amp; view-&gt;didFirstLayout())
1023             view-&gt;layoutContext().layout();
1024     }
1025 }
1026 
1027 float Frame::frameScaleFactor() const
1028 {
1029     Page* page = this-&gt;page();
1030 
1031     // Main frame is scaled with respect to he container but inner frames are not scaled with respect to the main frame.
1032     if (!page || &amp;page-&gt;mainFrame() != this || settings().delegatesPageScaling())
1033         return 1;
1034 
1035     return page-&gt;pageScaleFactor();
1036 }
1037 
1038 void Frame::suspendActiveDOMObjectsAndAnimations()
1039 {
1040     bool wasSuspended = activeDOMObjectsAndAnimationsSuspended();
1041 
1042     m_activeDOMObjectsAndAnimationsSuspendedCount++;
1043 
1044     if (wasSuspended)
1045         return;
1046 
1047     // FIXME: Suspend/resume calls will not match if the frame is navigated, and gets a new document.
1048     clearTimers(); // Suspends animations and pending relayouts.
1049     if (m_doc)
1050         m_doc-&gt;suspendScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
1051 }
1052 
1053 void Frame::resumeActiveDOMObjectsAndAnimations()
1054 {
1055     if (!activeDOMObjectsAndAnimationsSuspended())
1056         return;
1057 
1058     m_activeDOMObjectsAndAnimationsSuspendedCount--;
1059 
1060     if (activeDOMObjectsAndAnimationsSuspended())
1061         return;
1062 
1063     if (!m_doc)
1064         return;
1065 
1066     // FIXME: Suspend/resume calls will not match if the frame is navigated, and gets a new document.
1067     m_doc-&gt;resumeScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
1068 
1069     // Frame::clearTimers() suspended animations and pending relayouts.
1070     animation().resumeAnimationsForDocument(m_doc.get());
1071     if (m_view)
1072         m_view-&gt;layoutContext().scheduleLayout();
1073 }
1074 
1075 void Frame::deviceOrPageScaleFactorChanged()
1076 {
1077     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
1078         child-&gt;deviceOrPageScaleFactorChanged();
1079 
1080     if (RenderView* root = contentRenderer())
1081         root-&gt;compositor().deviceOrPageScaleFactorChanged();
1082 }
1083 
<a name="27" id="anc27"></a><span class="line-removed">1084 bool Frame::isURLAllowed(const URL&amp; url) const</span>
<span class="line-removed">1085 {</span>
<span class="line-removed">1086     // We allow one level of self-reference because some sites depend on that,</span>
<span class="line-removed">1087     // but we don&#39;t allow more than one.</span>
<span class="line-removed">1088     if (m_page-&gt;subframeCount() &gt;= Page::maxNumberOfFrames)</span>
<span class="line-removed">1089         return false;</span>
<span class="line-removed">1090     bool foundSelfReference = false;</span>
<span class="line-removed">1091     for (const Frame* frame = this; frame; frame = frame-&gt;tree().parent()) {</span>
<span class="line-removed">1092         if (equalIgnoringFragmentIdentifier(frame-&gt;document()-&gt;url(), url)) {</span>
<span class="line-removed">1093             if (foundSelfReference)</span>
<span class="line-removed">1094                 return false;</span>
<span class="line-removed">1095             foundSelfReference = true;</span>
<span class="line-removed">1096         }</span>
<span class="line-removed">1097     }</span>
<span class="line-removed">1098     return true;</span>
<span class="line-removed">1099 }</span>
<span class="line-removed">1100 </span>
1101 bool Frame::isAlwaysOnLoggingAllowed() const
1102 {
1103     return page() &amp;&amp; page()-&gt;isAlwaysOnLoggingAllowed();
1104 }
1105 
1106 void Frame::dropChildren()
1107 {
1108     ASSERT(isMainFrame());
1109     while (Frame* child = tree().firstChild())
1110         tree().removeChild(*child);
1111 }
1112 
<a name="28" id="anc28"></a>












1113 void Frame::selfOnlyRef()
1114 {
1115     ASSERT(isMainFrame());
1116     if (m_selfOnlyRefCount++)
1117         return;
1118 
1119     ref();
1120 }
1121 
1122 void Frame::selfOnlyDeref()
1123 {
1124     ASSERT(isMainFrame());
1125     ASSERT(m_selfOnlyRefCount);
1126     if (--m_selfOnlyRefCount)
1127         return;
1128 
1129     if (hasOneRef())
1130         dropChildren();
1131 
1132     deref();
1133 }
1134 
<a name="29" id="anc29"></a>




1135 } // namespace WebCore
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>