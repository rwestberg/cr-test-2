<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/svg/animation/SVGSMILElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;SVGSMILElement.h&quot;
  28 
  29 #include &quot;CSSPropertyNames.h&quot;
  30 #include &quot;Document.h&quot;
  31 #include &quot;Event.h&quot;
  32 #include &quot;EventListener.h&quot;
  33 #include &quot;EventNames.h&quot;
  34 #include &quot;EventSender.h&quot;
  35 #include &quot;FloatConversion.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;SMILTimeContainer.h&quot;
  38 #include &quot;SVGDocumentExtensions.h&quot;
  39 #include &quot;SVGNames.h&quot;
  40 #include &quot;SVGParserUtilities.h&quot;
  41 #include &quot;SVGSVGElement.h&quot;
  42 #include &quot;SVGURIReference.h&quot;
  43 #include &quot;SVGUseElement.h&quot;
  44 #include &quot;XLinkNames.h&quot;
  45 #include &lt;wtf/IsoMallocInlines.h&gt;
  46 #include &lt;wtf/MathExtras.h&gt;
  47 #include &lt;wtf/StdLibExtras.h&gt;
  48 #include &lt;wtf/Vector.h&gt;
  49 
  50 namespace WebCore {
  51 
  52 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGSMILElement);
  53 
  54 static SMILEventSender&amp; smilBeginEventSender()
  55 {
  56     static NeverDestroyed&lt;SMILEventSender&gt; sender(eventNames().beginEventEvent);
  57     return sender;
  58 }
  59 
  60 static SMILEventSender&amp; smilEndEventSender()
  61 {
  62     static NeverDestroyed&lt;SMILEventSender&gt; sender(eventNames().endEventEvent);
  63     return sender;
  64 }
  65 
  66 // This is used for duration type time values that can&#39;t be negative.
  67 static const double invalidCachedTime = -1.;
  68 
  69 class ConditionEventListener final : public EventListener {
  70 public:
  71     static Ref&lt;ConditionEventListener&gt; create(SVGSMILElement* animation, SVGSMILElement::Condition* condition)
  72     {
  73         return adoptRef(*new ConditionEventListener(animation, condition));
  74     }
  75 
  76     static const ConditionEventListener* cast(const EventListener* listener)
  77     {
  78         return listener-&gt;type() == ConditionEventListenerType
  79             ? static_cast&lt;const ConditionEventListener*&gt;(listener)
  80             : nullptr;
  81     }
  82 
  83     bool operator==(const EventListener&amp; other) const final;
  84 
  85     void disconnectAnimation()
  86     {
  87         m_animation = nullptr;
  88     }
  89 
  90 private:
  91     ConditionEventListener(SVGSMILElement* animation, SVGSMILElement::Condition* condition)
  92         : EventListener(ConditionEventListenerType)
  93         , m_animation(animation)
  94         , m_condition(condition)
  95     {
  96     }
  97 
  98     void handleEvent(ScriptExecutionContext&amp;, Event&amp;) final;
  99 
 100     SVGSMILElement* m_animation;
 101     SVGSMILElement::Condition* m_condition;
 102 };
 103 
 104 bool ConditionEventListener::operator==(const EventListener&amp; listener) const
 105 {
 106     if (const ConditionEventListener* conditionEventListener = ConditionEventListener::cast(&amp;listener))
 107         return m_animation == conditionEventListener-&gt;m_animation &amp;&amp; m_condition == conditionEventListener-&gt;m_condition;
 108     return false;
 109 }
 110 
 111 void ConditionEventListener::handleEvent(ScriptExecutionContext&amp;, Event&amp;)
 112 {
 113     if (!m_animation)
 114         return;
 115     m_animation-&gt;handleConditionEvent(m_condition);
 116 }
 117 
 118 SVGSMILElement::Condition::Condition(Type type, BeginOrEnd beginOrEnd, const String&amp; baseID, const String&amp; name, SMILTime offset, int repeats)
 119     : m_type(type)
 120     , m_beginOrEnd(beginOrEnd)
 121     , m_baseID(baseID)
 122     , m_name(name)
 123     , m_offset(offset)
 124     , m_repeats(repeats)
 125 {
 126 }
 127 
 128 SVGSMILElement::SVGSMILElement(const QualifiedName&amp; tagName, Document&amp; doc)
 129     : SVGElement(tagName, doc)
 130     , m_attributeName(anyQName())
 131     , m_targetElement(nullptr)
 132     , m_conditionsConnected(false)
 133     , m_hasEndEventConditions(false)
 134     , m_isWaitingForFirstInterval(true)
 135     , m_intervalBegin(SMILTime::unresolved())
 136     , m_intervalEnd(SMILTime::unresolved())
 137     , m_previousIntervalBegin(SMILTime::unresolved())
 138     , m_activeState(Inactive)
 139     , m_lastPercent(0)
 140     , m_lastRepeat(0)
 141     , m_nextProgressTime(0)
 142     , m_documentOrderIndex(0)
 143     , m_cachedDur(invalidCachedTime)
 144     , m_cachedRepeatDur(invalidCachedTime)
 145     , m_cachedRepeatCount(invalidCachedTime)
 146     , m_cachedMin(invalidCachedTime)
 147     , m_cachedMax(invalidCachedTime)
 148 {
 149     resolveFirstInterval();
 150 }
 151 
 152 SVGSMILElement::~SVGSMILElement()
 153 {
 154     clearResourceReferences();
 155     smilBeginEventSender().cancelEvent(*this);
 156     smilEndEventSender().cancelEvent(*this);
 157     disconnectConditions();
 158     if (m_timeContainer &amp;&amp; m_targetElement &amp;&amp; hasValidAttributeName())
 159         m_timeContainer-&gt;unschedule(this, m_targetElement, m_attributeName);
 160 }
 161 
 162 void SVGSMILElement::clearResourceReferences()
 163 {
 164     document().accessSVGExtensions().removeAllTargetReferencesForElement(*this);
 165 }
 166 
 167 void SVGSMILElement::clearTarget()
 168 {
 169     setTargetElement(nullptr);
 170 }
 171 
 172 void SVGSMILElement::buildPendingResource()
 173 {
 174     clearResourceReferences();
 175 
 176     if (!isConnected()) {
 177         // Reset the target element if we are no longer in the document.
 178         setTargetElement(nullptr);
 179         return;
 180     }
 181 
 182     String id;
 183     RefPtr&lt;Element&gt; target;
 184     auto&amp; href = getAttribute(SVGNames::hrefAttr, XLinkNames::hrefAttr);
 185     if (href.isEmpty())
 186         target = parentElement();
 187     else {
 188         auto result = SVGURIReference::targetElementFromIRIString(href.string(), treeScope());
 189         target = WTFMove(result.element);
 190         id = WTFMove(result.identifier);
 191     }
 192     SVGElement* svgTarget = is&lt;SVGElement&gt;(target) ? downcast&lt;SVGElement&gt;(target.get()) : nullptr;
 193 
 194     if (svgTarget &amp;&amp; !svgTarget-&gt;isConnected())
 195         svgTarget = nullptr;
 196 
 197     if (svgTarget != targetElement())
 198         setTargetElement(svgTarget);
 199 
 200     if (!svgTarget) {
 201         // Do not register as pending if we are already pending this resource.
 202         if (document().accessSVGExtensions().isPendingResource(*this, id))
 203             return;
 204 
 205         if (!id.isEmpty()) {
 206             document().accessSVGExtensions().addPendingResource(id, *this);
 207             ASSERT(hasPendingResources());
 208         }
 209     } else {
 210         // Register us with the target in the dependencies map. Any change of hrefElement
 211         // that leads to relayout/repainting now informs us, so we can react to it.
 212         document().accessSVGExtensions().addElementReferencingTarget(*this, *svgTarget);
 213     }
 214 }
 215 
 216 inline QualifiedName SVGSMILElement::constructAttributeName() const
 217 {
 218     auto parseResult = Document::parseQualifiedName(attributeWithoutSynchronization(SVGNames::attributeNameAttr));
 219     if (parseResult.hasException())
 220         return anyQName();
 221 
 222     auto [prefix, localName] = parseResult.releaseReturnValue();
 223 
 224     if (prefix.isNull())
 225         return { nullAtom(), localName, nullAtom() };
 226 
 227     auto namespaceURI = lookupNamespaceURI(prefix);
 228     if (namespaceURI.isEmpty())
 229         return anyQName();
 230 
 231     return { nullAtom(), localName, namespaceURI };
 232 }
 233 
 234 inline void SVGSMILElement::updateAttributeName()
 235 {
 236     setAttributeName(constructAttributeName());
 237 }
 238 
 239 static inline void clearTimesWithDynamicOrigins(Vector&lt;SMILTimeWithOrigin&gt;&amp; timeList)
 240 {
 241     timeList.removeAllMatching([] (const SMILTimeWithOrigin&amp; time) {
 242         return time.originIsScript();
 243     });
 244 }
 245 
 246 void SVGSMILElement::reset()
 247 {
 248     clearAnimatedType(m_targetElement);
 249 
 250     m_activeState = Inactive;
 251     m_isWaitingForFirstInterval = true;
 252     m_intervalBegin = SMILTime::unresolved();
 253     m_intervalEnd = SMILTime::unresolved();
 254     m_previousIntervalBegin = SMILTime::unresolved();
 255     m_lastPercent = 0;
 256     m_lastRepeat = 0;
 257     m_nextProgressTime = 0;
 258     resolveFirstInterval();
 259 }
 260 
 261 Node::InsertedIntoAncestorResult SVGSMILElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 262 {
 263     SVGElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 264     if (!insertionType.connectedToDocument)
 265         return InsertedIntoAncestorResult::Done;
 266 
 267     // Verify we are not in &lt;use&gt; instance tree.
 268     ASSERT(!isInShadowTree() || !is&lt;SVGUseElement&gt;(shadowHost()));
 269 
 270     updateAttributeName();
 271 
 272     auto owner = makeRefPtr(ownerSVGElement());
 273     if (!owner)
 274         return InsertedIntoAncestorResult::Done;
 275 
 276     m_timeContainer = &amp;owner-&gt;timeContainer();
 277     m_timeContainer-&gt;setDocumentOrderIndexesDirty();
 278 
 279     // &quot;If no attribute is present, the default begin value (an offset-value of 0) must be evaluated.&quot;
 280     if (!hasAttributeWithoutSynchronization(SVGNames::beginAttr))
 281         m_beginTimes.append(SMILTimeWithOrigin());
 282 
 283     if (m_isWaitingForFirstInterval)
 284         resolveFirstInterval();
 285 
 286     if (m_timeContainer)
 287         m_timeContainer-&gt;notifyIntervalsChanged();
 288 
 289     return InsertedIntoAncestorResult::NeedsPostInsertionCallback;
 290 }
 291 
 292 void SVGSMILElement::didFinishInsertingNode()
 293 {
 294     buildPendingResource();
 295 }
 296 
 297 void SVGSMILElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
 298 {
 299     if (removalType.disconnectedFromDocument) {
 300         clearResourceReferences();
 301         disconnectConditions();
 302         setTargetElement(nullptr);
 303         setAttributeName(anyQName());
 304         animationAttributeChanged();
 305         m_timeContainer = nullptr;
 306     }
 307 
 308     SVGElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
 309 }
 310 
 311 bool SVGSMILElement::hasValidAttributeName() const
 312 {
 313     return attributeName() != anyQName();
 314 }
 315 
 316 SMILTime SVGSMILElement::parseOffsetValue(const String&amp; data)
 317 {
 318     bool ok;
 319     double result = 0;
 320     String parse = data.stripWhiteSpace();
 321     if (parse.endsWith(&#39;h&#39;))
 322         result = parse.left(parse.length() - 1).toDouble(&amp;ok) * 60 * 60;
 323     else if (parse.endsWith(&quot;min&quot;))
 324         result = parse.left(parse.length() - 3).toDouble(&amp;ok) * 60;
 325     else if (parse.endsWith(&quot;ms&quot;))
 326         result = parse.left(parse.length() - 2).toDouble(&amp;ok) / 1000;
 327     else if (parse.endsWith(&#39;s&#39;))
 328         result = parse.left(parse.length() - 1).toDouble(&amp;ok);
 329     else
 330         result = parse.toDouble(&amp;ok);
 331     if (!ok || !SMILTime(result).isFinite())
 332         return SMILTime::unresolved();
 333     return result;
 334 }
 335 
 336 SMILTime SVGSMILElement::parseClockValue(const String&amp; data)
 337 {
 338     if (data.isNull())
 339         return SMILTime::unresolved();
 340 
 341     String parse = data.stripWhiteSpace();
 342 
 343     static NeverDestroyed&lt;const AtomString&gt; indefiniteValue(&quot;indefinite&quot;, AtomString::ConstructFromLiteral);
 344     if (parse == indefiniteValue)
 345         return SMILTime::indefinite();
 346 
 347     double result = 0;
 348     bool ok;
 349     size_t doublePointOne = parse.find(&#39;:&#39;);
 350     size_t doublePointTwo = parse.find(&#39;:&#39;, doublePointOne + 1);
 351     if (doublePointOne == 2 &amp;&amp; doublePointTwo == 5 &amp;&amp; parse.length() &gt;= 8) {
 352         result += parse.substring(0, 2).toUIntStrict(&amp;ok) * 60 * 60;
 353         if (!ok)
 354             return SMILTime::unresolved();
 355         result += parse.substring(3, 2).toUIntStrict(&amp;ok) * 60;
 356         if (!ok)
 357             return SMILTime::unresolved();
 358         result += parse.substring(6).toDouble(&amp;ok);
 359     } else if (doublePointOne == 2 &amp;&amp; doublePointTwo == notFound &amp;&amp; parse.length() &gt;= 5) {
 360         result += parse.substring(0, 2).toUIntStrict(&amp;ok) * 60;
 361         if (!ok)
 362             return SMILTime::unresolved();
 363         result += parse.substring(3).toDouble(&amp;ok);
 364     } else
 365         return parseOffsetValue(parse);
 366 
 367     if (!ok || !SMILTime(result).isFinite())
 368         return SMILTime::unresolved();
 369     return result;
 370 }
 371 
 372 static void sortTimeList(Vector&lt;SMILTimeWithOrigin&gt;&amp; timeList)
 373 {
 374     std::sort(timeList.begin(), timeList.end());
 375 }
 376 
 377 bool SVGSMILElement::parseCondition(const String&amp; value, BeginOrEnd beginOrEnd)
 378 {
 379     String parseString = value.stripWhiteSpace();
 380 
 381     double sign = 1.;
 382     bool ok;
 383     size_t pos = parseString.find(&#39;+&#39;);
 384     if (pos == notFound) {
 385         pos = parseString.find(&#39;-&#39;);
 386         if (pos != notFound)
 387             sign = -1.;
 388     }
 389     String conditionString;
 390     SMILTime offset = 0;
 391     if (pos == notFound)
 392         conditionString = parseString;
 393     else {
 394         conditionString = parseString.left(pos).stripWhiteSpace();
 395         String offsetString = parseString.substring(pos + 1).stripWhiteSpace();
 396         offset = parseOffsetValue(offsetString);
 397         if (offset.isUnresolved())
 398             return false;
 399         offset = offset * sign;
 400     }
 401     if (conditionString.isEmpty())
 402         return false;
 403     pos = conditionString.find(&#39;.&#39;);
 404 
 405     String baseID;
 406     String nameString;
 407     if (pos == notFound)
 408         nameString = conditionString;
 409     else {
 410         baseID = conditionString.left(pos);
 411         nameString = conditionString.substring(pos + 1);
 412     }
 413     if (nameString.isEmpty())
 414         return false;
 415 
 416     Condition::Type type;
 417     int repeats = -1;
 418     if (nameString.startsWith(&quot;repeat(&quot;) &amp;&amp; nameString.endsWith(&#39;)&#39;)) {
 419         // FIXME: For repeat events we just need to add the data carrying TimeEvent class and
 420         // fire the events at appropiate times.
 421         repeats = nameString.substring(7, nameString.length() - 8).toUIntStrict(&amp;ok);
 422         if (!ok)
 423             return false;
 424         nameString = &quot;repeat&quot;;
 425         type = Condition::EventBase;
 426     } else if (nameString == &quot;begin&quot; || nameString == &quot;end&quot;) {
 427         if (baseID.isEmpty())
 428             return false;
 429         type = Condition::Syncbase;
 430     } else if (nameString.startsWith(&quot;accesskey(&quot;)) {
 431         // FIXME: accesskey() support.
 432         type = Condition::AccessKey;
 433     } else
 434         type = Condition::EventBase;
 435 
 436     m_conditions.append(Condition(type, beginOrEnd, baseID, nameString, offset, repeats));
 437 
 438     if (type == Condition::EventBase &amp;&amp; beginOrEnd == End)
 439         m_hasEndEventConditions = true;
 440 
 441     return true;
 442 }
 443 
 444 void SVGSMILElement::parseBeginOrEnd(const String&amp; parseString, BeginOrEnd beginOrEnd)
 445 {
 446     Vector&lt;SMILTimeWithOrigin&gt;&amp; timeList = beginOrEnd == Begin ? m_beginTimes : m_endTimes;
 447     if (beginOrEnd == End)
 448         m_hasEndEventConditions = false;
 449     HashSet&lt;double&gt; existing;
 450     for (auto&amp; time : timeList)
 451         existing.add(time.time().value());
 452     for (auto&amp; string : parseString.split(&#39;;&#39;)) {
 453         SMILTime value = parseClockValue(string);
 454         if (value.isUnresolved())
 455             parseCondition(string, beginOrEnd);
 456         else if (!existing.contains(value.value()))
 457             timeList.append(SMILTimeWithOrigin(value, SMILTimeWithOrigin::ParserOrigin));
 458     }
 459     sortTimeList(timeList);
 460 }
 461 
 462 bool SVGSMILElement::isSupportedAttribute(const QualifiedName&amp; attrName)
 463 {
 464     static const auto supportedAttributes = makeNeverDestroyed(HashSet&lt;QualifiedName&gt; {
 465         SVGNames::beginAttr,
 466         SVGNames::endAttr,
 467         SVGNames::durAttr,
 468         SVGNames::repeatDurAttr,
 469         SVGNames::repeatCountAttr,
 470         SVGNames::minAttr,
 471         SVGNames::maxAttr,
 472         SVGNames::attributeNameAttr,
 473         SVGNames::hrefAttr,
 474         XLinkNames::hrefAttr,
 475     });
 476     return supportedAttributes.get().contains&lt;SVGAttributeHashTranslator&gt;(attrName);
 477 }
 478 
 479 void SVGSMILElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 480 {
 481     if (name == SVGNames::beginAttr) {
 482         if (!m_conditions.isEmpty()) {
 483             disconnectConditions();
 484             m_conditions.clear();
 485             parseBeginOrEnd(attributeWithoutSynchronization(SVGNames::endAttr), End);
 486         }
 487         parseBeginOrEnd(value.string(), Begin);
 488         if (isConnected())
 489             connectConditions();
 490     } else if (name == SVGNames::endAttr) {
 491         if (!m_conditions.isEmpty()) {
 492             disconnectConditions();
 493             m_conditions.clear();
 494             parseBeginOrEnd(attributeWithoutSynchronization(SVGNames::beginAttr), Begin);
 495         }
 496         parseBeginOrEnd(value.string(), End);
 497         if (isConnected())
 498             connectConditions();
 499     } else if (name == SVGNames::onendAttr)
 500         setAttributeEventListener(eventNames().endEventEvent, name, value);
 501     else if (name == SVGNames::onbeginAttr)
 502         setAttributeEventListener(eventNames().beginEventEvent, name, value);
 503     else
 504         SVGElement::parseAttribute(name, value);
 505 }
 506 
 507 void SVGSMILElement::svgAttributeChanged(const QualifiedName&amp; attrName)
 508 {
 509     if (!isSupportedAttribute(attrName)) {
 510         SVGElement::svgAttributeChanged(attrName);
 511         return;
 512     }
 513 
 514     if (attrName == SVGNames::durAttr)
 515         m_cachedDur = invalidCachedTime;
 516     else if (attrName == SVGNames::repeatDurAttr)
 517         m_cachedRepeatDur = invalidCachedTime;
 518     else if (attrName == SVGNames::repeatCountAttr)
 519         m_cachedRepeatCount = invalidCachedTime;
 520     else if (attrName == SVGNames::minAttr)
 521         m_cachedMin = invalidCachedTime;
 522     else if (attrName == SVGNames::maxAttr)
 523         m_cachedMax = invalidCachedTime;
 524     else if (attrName == SVGNames::attributeNameAttr)
 525         updateAttributeName();
 526     else if (attrName.matches(SVGNames::hrefAttr) || attrName.matches(XLinkNames::hrefAttr)) {
 527         InstanceInvalidationGuard guard(*this);
 528         buildPendingResource();
 529     } else if (isConnected()) {
 530         if (attrName == SVGNames::beginAttr)
 531             beginListChanged(elapsed());
 532         else if (attrName == SVGNames::endAttr)
 533             endListChanged(elapsed());
 534     }
 535 
 536     animationAttributeChanged();
 537 }
 538 
 539 inline Element* SVGSMILElement::eventBaseFor(const Condition&amp; condition)
 540 {
 541     return condition.m_baseID.isEmpty() ? targetElement() : treeScope().getElementById(condition.m_baseID);
 542 }
 543 
 544 void SVGSMILElement::connectConditions()
 545 {
 546     if (m_conditionsConnected)
 547         disconnectConditions();
 548     m_conditionsConnected = true;
 549     for (auto&amp; condition : m_conditions) {
 550         if (condition.m_type == Condition::EventBase) {
 551             ASSERT(!condition.m_syncbase);
 552             auto eventBase = makeRefPtr(eventBaseFor(condition));
 553             if (!eventBase)
 554                 continue;
 555             ASSERT(!condition.m_eventListener);
 556             condition.m_eventListener = ConditionEventListener::create(this, &amp;condition);
 557             eventBase-&gt;addEventListener(condition.m_name, *condition.m_eventListener, false);
 558         } else if (condition.m_type == Condition::Syncbase) {
 559             ASSERT(!condition.m_baseID.isEmpty());
 560             condition.m_syncbase = treeScope().getElementById(condition.m_baseID);
 561             if (!condition.m_syncbase)
 562                 continue;
 563             if (!is&lt;SVGSMILElement&gt;(*condition.m_syncbase)) {
 564                 condition.m_syncbase = nullptr;
 565                 continue;
 566             }
 567             downcast&lt;SVGSMILElement&gt;(*condition.m_syncbase).addTimeDependent(this);
 568         }
 569     }
 570 }
 571 
 572 void SVGSMILElement::disconnectConditions()
 573 {
 574     if (!m_conditionsConnected)
 575         return;
 576     m_conditionsConnected = false;
 577     for (auto&amp; condition : m_conditions) {
 578         if (condition.m_type == Condition::EventBase) {
 579             ASSERT(!condition.m_syncbase);
 580             if (!condition.m_eventListener)
 581                 continue;
 582             // Note: It&#39;s a memory optimization to try to remove our condition
 583             // event listener, but it&#39;s not guaranteed to work, since we have
 584             // no guarantee that eventBaseFor() will be able to find our condition&#39;s
 585             // original eventBase. So, we also have to disconnect ourselves from
 586             // our condition event listener, in case it later fires.
 587             auto eventBase = makeRefPtr(eventBaseFor(condition));
 588             if (eventBase)
 589                 eventBase-&gt;removeEventListener(condition.m_name, *condition.m_eventListener, false);
 590             condition.m_eventListener-&gt;disconnectAnimation();
 591             condition.m_eventListener = nullptr;
 592         } else if (condition.m_type == Condition::Syncbase) {
 593             if (condition.m_syncbase)
 594                 downcast&lt;SVGSMILElement&gt;(condition.m_syncbase.get())-&gt;removeTimeDependent(this);
 595         }
 596         condition.m_syncbase = nullptr;
 597     }
 598 }
 599 
 600 void SVGSMILElement::setAttributeName(const QualifiedName&amp; attributeName)
 601 {
 602     if (m_timeContainer &amp;&amp; m_targetElement &amp;&amp; m_attributeName != attributeName) {
 603         if (hasValidAttributeName())
 604             m_timeContainer-&gt;unschedule(this, m_targetElement, m_attributeName);
 605         m_attributeName = attributeName;
 606         if (hasValidAttributeName())
 607             m_timeContainer-&gt;schedule(this, m_targetElement, m_attributeName);
 608     } else
 609         m_attributeName = attributeName;
 610 
 611     // Only clear the animated type, if we had a target before.
 612     if (m_targetElement)
 613         clearAnimatedType(m_targetElement);
 614 }
 615 
 616 void SVGSMILElement::setTargetElement(SVGElement* target)
 617 {
 618     if (m_timeContainer &amp;&amp; hasValidAttributeName()) {
 619         if (m_targetElement)
 620             m_timeContainer-&gt;unschedule(this, m_targetElement, m_attributeName);
 621         if (target)
 622             m_timeContainer-&gt;schedule(this, target, m_attributeName);
 623     }
 624 
 625     if (m_targetElement) {
 626         // Clear values that may depend on the previous target.
 627         clearAnimatedType(m_targetElement);
 628         disconnectConditions();
 629     }
 630 
 631     // If the animation state is not Inactive, always reset to a clear state before leaving the old target element.
 632     if (m_activeState != Inactive)
 633         endedActiveInterval();
 634 
 635     m_targetElement = target;
 636 }
 637 
 638 SMILTime SVGSMILElement::elapsed() const
 639 {
 640     return m_timeContainer ? m_timeContainer-&gt;elapsed() : 0;
 641 }
 642 
 643 bool SVGSMILElement::isInactive() const
 644 {
 645      return m_activeState == Inactive;
 646 }
 647 
 648 bool SVGSMILElement::isFrozen() const
 649 {
 650     return m_activeState == Frozen;
 651 }
 652 
 653 SVGSMILElement::Restart SVGSMILElement::restart() const
 654 {
 655     static NeverDestroyed&lt;const AtomString&gt; never(&quot;never&quot;, AtomString::ConstructFromLiteral);
 656     static NeverDestroyed&lt;const AtomString&gt; whenNotActive(&quot;whenNotActive&quot;, AtomString::ConstructFromLiteral);
 657     const AtomString&amp; value = attributeWithoutSynchronization(SVGNames::restartAttr);
 658     if (value == never)
 659         return RestartNever;
 660     if (value == whenNotActive)
 661         return RestartWhenNotActive;
 662     return RestartAlways;
 663 }
 664 
 665 SVGSMILElement::FillMode SVGSMILElement::fill() const
 666 {
 667     static NeverDestroyed&lt;const AtomString&gt; freeze(&quot;freeze&quot;, AtomString::ConstructFromLiteral);
 668     const AtomString&amp; value = attributeWithoutSynchronization(SVGNames::fillAttr);
 669     return value == freeze ? FillFreeze : FillRemove;
 670 }
 671 
 672 SMILTime SVGSMILElement::dur() const
 673 {
 674     if (m_cachedDur != invalidCachedTime)
 675         return m_cachedDur;
 676     const AtomString&amp; value = attributeWithoutSynchronization(SVGNames::durAttr);
 677     SMILTime clockValue = parseClockValue(value);
 678     return m_cachedDur = clockValue &lt;= 0 ? SMILTime::unresolved() : clockValue;
 679 }
 680 
 681 SMILTime SVGSMILElement::repeatDur() const
 682 {
 683     if (m_cachedRepeatDur != invalidCachedTime)
 684         return m_cachedRepeatDur;
 685     const AtomString&amp; value = attributeWithoutSynchronization(SVGNames::repeatDurAttr);
 686     SMILTime clockValue = parseClockValue(value);
 687     m_cachedRepeatDur = clockValue &lt;= 0 ? SMILTime::unresolved() : clockValue;
 688     return m_cachedRepeatDur;
 689 }
 690 
 691 // So a count is not really a time but let just all pretend we did not notice.
 692 SMILTime SVGSMILElement::repeatCount() const
 693 {
 694     if (m_cachedRepeatCount != invalidCachedTime)
 695         return m_cachedRepeatCount;
 696     const AtomString&amp; value = attributeWithoutSynchronization(SVGNames::repeatCountAttr);
 697     if (value.isNull())
 698         return SMILTime::unresolved();
 699 
 700     static NeverDestroyed&lt;const AtomString&gt; indefiniteValue(&quot;indefinite&quot;, AtomString::ConstructFromLiteral);
 701     if (value == indefiniteValue)
 702         return SMILTime::indefinite();
 703     bool ok;
 704     double result = value.string().toDouble(&amp;ok);
 705     return m_cachedRepeatCount = ok &amp;&amp; result &gt; 0 ? result : SMILTime::unresolved();
 706 }
 707 
 708 SMILTime SVGSMILElement::maxValue() const
 709 {
 710     if (m_cachedMax != invalidCachedTime)
 711         return m_cachedMax;
 712     const AtomString&amp; value = attributeWithoutSynchronization(SVGNames::maxAttr);
 713     SMILTime result = parseClockValue(value);
 714     return m_cachedMax = (result.isUnresolved() || result &lt;= 0) ? SMILTime::indefinite() : result;
 715 }
 716 
 717 SMILTime SVGSMILElement::minValue() const
 718 {
 719     if (m_cachedMin != invalidCachedTime)
 720         return m_cachedMin;
 721     const AtomString&amp; value = attributeWithoutSynchronization(SVGNames::minAttr);
 722     SMILTime result = parseClockValue(value);
 723     return m_cachedMin = (result.isUnresolved() || result &lt; 0) ? 0 : result;
 724 }
 725 
 726 SMILTime SVGSMILElement::simpleDuration() const
 727 {
 728     return std::min(dur(), SMILTime::indefinite());
 729 }
 730 
 731 void SVGSMILElement::addBeginTime(SMILTime eventTime, SMILTime beginTime, SMILTimeWithOrigin::Origin origin)
 732 {
 733     ASSERT(!std::isnan(beginTime.value()));
 734     m_beginTimes.append(SMILTimeWithOrigin(beginTime, origin));
 735     sortTimeList(m_beginTimes);
 736     beginListChanged(eventTime);
 737 }
 738 
 739 void SVGSMILElement::addEndTime(SMILTime eventTime, SMILTime endTime, SMILTimeWithOrigin::Origin origin)
 740 {
 741     ASSERT(!std::isnan(endTime.value()));
 742     m_endTimes.append(SMILTimeWithOrigin(endTime, origin));
 743     sortTimeList(m_endTimes);
 744     endListChanged(eventTime);
 745 }
 746 
 747 inline SMILTime extractTimeFromVector(const SMILTimeWithOrigin* position)
 748 {
 749     return position-&gt;time();
 750 }
 751 
 752 SMILTime SVGSMILElement::findInstanceTime(BeginOrEnd beginOrEnd, SMILTime minimumTime, bool equalsMinimumOK) const
 753 {
 754     const Vector&lt;SMILTimeWithOrigin&gt;&amp; list = beginOrEnd == Begin ? m_beginTimes : m_endTimes;
 755     int sizeOfList = list.size();
 756 
 757     if (!sizeOfList)
 758         return beginOrEnd == Begin ? SMILTime::unresolved() : SMILTime::indefinite();
 759 
 760     const SMILTimeWithOrigin* result = approximateBinarySearch&lt;const SMILTimeWithOrigin, SMILTime&gt;(list, sizeOfList, minimumTime, extractTimeFromVector);
 761     int indexOfResult = result - list.begin();
 762     ASSERT_WITH_SECURITY_IMPLICATION(indexOfResult &lt; sizeOfList);
 763 
 764     if (list[indexOfResult].time() &lt; minimumTime &amp;&amp; indexOfResult &lt; sizeOfList - 1)
 765         ++indexOfResult;
 766 
 767     const SMILTime&amp; currentTime = list[indexOfResult].time();
 768 
 769     // The special value &quot;indefinite&quot; does not yield an instance time in the begin list.
 770     if (currentTime.isIndefinite() &amp;&amp; beginOrEnd == Begin)
 771         return SMILTime::unresolved();
 772 
 773     if (currentTime &lt; minimumTime)
 774         return beginOrEnd == Begin ? SMILTime::unresolved() : SMILTime::indefinite();
 775     if (currentTime &gt; minimumTime)
 776         return currentTime;
 777 
 778     ASSERT(currentTime == minimumTime);
 779     if (equalsMinimumOK)
 780         return currentTime;
 781 
 782     // If the equals is not accepted, return the next bigger item in the list.
 783     SMILTime nextTime = currentTime;
 784     while (indexOfResult &lt; sizeOfList - 1) {
 785         nextTime = list[indexOfResult + 1].time();
 786         if (nextTime &gt; minimumTime)
 787             return nextTime;
 788         ++indexOfResult;
 789     }
 790 
 791     return beginOrEnd == Begin ? SMILTime::unresolved() : SMILTime::indefinite();
 792 }
 793 
 794 SMILTime SVGSMILElement::repeatingDuration() const
 795 {
 796     // Computing the active duration
 797     // http://www.w3.org/TR/SMIL2/smil-timing.html#Timing-ComputingActiveDur
 798     SMILTime repeatCount = this-&gt;repeatCount();
 799     SMILTime repeatDur = this-&gt;repeatDur();
 800     SMILTime simpleDuration = this-&gt;simpleDuration();
 801     if (!simpleDuration || (repeatDur.isUnresolved() &amp;&amp; repeatCount.isUnresolved()))
 802         return simpleDuration;
 803     SMILTime repeatCountDuration = simpleDuration * repeatCount;
 804     return std::min(repeatCountDuration, std::min(repeatDur, SMILTime::indefinite()));
 805 }
 806 
 807 SMILTime SVGSMILElement::resolveActiveEnd(SMILTime resolvedBegin, SMILTime resolvedEnd) const
 808 {
 809     // Computing the active duration
 810     // http://www.w3.org/TR/SMIL2/smil-timing.html#Timing-ComputingActiveDur
 811     SMILTime preliminaryActiveDuration;
 812     if (!resolvedEnd.isUnresolved() &amp;&amp; dur().isUnresolved() &amp;&amp; repeatDur().isUnresolved() &amp;&amp; repeatCount().isUnresolved())
 813         preliminaryActiveDuration = resolvedEnd - resolvedBegin;
 814     else if (!resolvedEnd.isFinite())
 815         preliminaryActiveDuration = repeatingDuration();
 816     else
 817         preliminaryActiveDuration = std::min(repeatingDuration(), resolvedEnd - resolvedBegin);
 818 
 819     SMILTime minValue = this-&gt;minValue();
 820     SMILTime maxValue = this-&gt;maxValue();
 821     if (minValue &gt; maxValue) {
 822         // Ignore both.
 823         // http://www.w3.org/TR/2001/REC-smil-animation-20010904/#MinMax
 824         minValue = 0;
 825         maxValue = SMILTime::indefinite();
 826     }
 827     return resolvedBegin + std::min(maxValue, std::max(minValue, preliminaryActiveDuration));
 828 }
 829 
 830 void SVGSMILElement::resolveInterval(bool first, SMILTime&amp; beginResult, SMILTime&amp; endResult) const
 831 {
 832     // See the pseudocode in http://www.w3.org/TR/SMIL3/smil-timing.html#q90.
 833     SMILTime beginAfter = first ? -std::numeric_limits&lt;double&gt;::infinity() : m_intervalEnd;
 834     SMILTime lastIntervalTempEnd = std::numeric_limits&lt;double&gt;::infinity();
 835     while (true) {
 836         bool equalsMinimumOK = !first || m_intervalEnd &gt; m_intervalBegin;
 837         SMILTime tempBegin = findInstanceTime(Begin, beginAfter, equalsMinimumOK);
 838         if (tempBegin.isUnresolved())
 839             break;
 840         SMILTime tempEnd;
 841         if (m_endTimes.isEmpty())
 842             tempEnd = resolveActiveEnd(tempBegin, SMILTime::indefinite());
 843         else {
 844             tempEnd = findInstanceTime(End, tempBegin, true);
 845             if ((first &amp;&amp; tempBegin == tempEnd &amp;&amp; tempEnd == lastIntervalTempEnd) || (!first &amp;&amp; tempEnd == m_intervalEnd))
 846                 tempEnd = findInstanceTime(End, tempBegin, false);
 847             if (tempEnd.isUnresolved()) {
 848                 if (!m_endTimes.isEmpty() &amp;&amp; !m_hasEndEventConditions)
 849                     break;
 850             }
 851             tempEnd = resolveActiveEnd(tempBegin, tempEnd);
 852         }
 853         if (!first || (tempEnd &gt; 0 || (!tempBegin.value() &amp;&amp; !tempEnd.value()))) {
 854             beginResult = tempBegin;
 855             endResult = tempEnd;
 856             return;
 857         }
 858 
 859         beginAfter = tempEnd;
 860         lastIntervalTempEnd = tempEnd;
 861     }
 862     beginResult = SMILTime::unresolved();
 863     endResult = SMILTime::unresolved();
 864 }
 865 
 866 void SVGSMILElement::resolveFirstInterval()
 867 {
 868     SMILTime begin;
 869     SMILTime end;
 870     resolveInterval(true, begin, end);
 871     ASSERT(!begin.isIndefinite());
 872 
 873     if (!begin.isUnresolved() &amp;&amp; (begin != m_intervalBegin || end != m_intervalEnd)) {
 874         bool wasUnresolved = m_intervalBegin.isUnresolved();
 875         m_intervalBegin = begin;
 876         m_intervalEnd = end;
 877         notifyDependentsIntervalChanged(wasUnresolved ? NewInterval : ExistingInterval);
 878         m_nextProgressTime = std::min(m_nextProgressTime, m_intervalBegin);
 879 
 880         if (m_timeContainer)
 881             m_timeContainer-&gt;notifyIntervalsChanged();
 882     }
 883 }
 884 
 885 void SVGSMILElement::resolveNextInterval(bool notifyDependents)
 886 {
 887     SMILTime begin;
 888     SMILTime end;
 889     resolveInterval(false, begin, end);
 890     ASSERT(!begin.isIndefinite());
 891 
 892     if (!begin.isUnresolved() &amp;&amp; begin != m_intervalBegin) {
 893         m_intervalBegin = begin;
 894         m_intervalEnd = end;
 895         if (notifyDependents)
 896             notifyDependentsIntervalChanged(NewInterval);
 897         m_nextProgressTime = std::min(m_nextProgressTime, m_intervalBegin);
 898     }
 899 }
 900 
 901 SMILTime SVGSMILElement::nextProgressTime() const
 902 {
 903     return m_nextProgressTime;
 904 }
 905 
 906 void SVGSMILElement::beginListChanged(SMILTime eventTime)
 907 {
 908     if (m_isWaitingForFirstInterval)
 909         resolveFirstInterval();
 910     else {
 911         SMILTime newBegin = findInstanceTime(Begin, eventTime, true);
 912         if (newBegin.isFinite() &amp;&amp; (m_intervalEnd &lt;= eventTime || newBegin &lt; m_intervalBegin)) {
 913             // Begin time changed, re-resolve the interval.
 914             SMILTime oldBegin = m_intervalBegin;
 915             m_intervalEnd = eventTime;
 916             resolveInterval(false, m_intervalBegin, m_intervalEnd);
 917             ASSERT(!m_intervalBegin.isUnresolved());
 918             if (m_intervalBegin != oldBegin) {
 919                 if (m_activeState == Active &amp;&amp; m_intervalBegin &gt; eventTime) {
 920                     m_activeState = determineActiveState(eventTime);
 921                     if (m_activeState != Active)
 922                         endedActiveInterval();
 923                 }
 924                 notifyDependentsIntervalChanged(ExistingInterval);
 925             }
 926         }
 927     }
 928     m_nextProgressTime = elapsed();
 929 
 930     if (m_timeContainer)
 931         m_timeContainer-&gt;notifyIntervalsChanged();
 932 }
 933 
 934 void SVGSMILElement::endListChanged(SMILTime)
 935 {
 936     SMILTime elapsed = this-&gt;elapsed();
 937     if (m_isWaitingForFirstInterval)
 938         resolveFirstInterval();
 939     else if (elapsed &lt; m_intervalEnd &amp;&amp; m_intervalBegin.isFinite()) {
 940         SMILTime newEnd = findInstanceTime(End, m_intervalBegin, false);
 941         if (newEnd &lt; m_intervalEnd) {
 942             newEnd = resolveActiveEnd(m_intervalBegin, newEnd);
 943             if (newEnd != m_intervalEnd) {
 944                 m_intervalEnd = newEnd;
 945                 notifyDependentsIntervalChanged(ExistingInterval);
 946             }
 947         }
 948     }
 949     m_nextProgressTime = elapsed;
 950 
 951     if (m_timeContainer)
 952         m_timeContainer-&gt;notifyIntervalsChanged();
 953 }
 954 
 955 void SVGSMILElement::checkRestart(SMILTime elapsed)
 956 {
 957     ASSERT(!m_isWaitingForFirstInterval);
 958     ASSERT(elapsed &gt;= m_intervalBegin);
 959 
 960     Restart restart = this-&gt;restart();
 961     if (restart == RestartNever)
 962         return;
 963 
 964     if (elapsed &lt; m_intervalEnd) {
 965         if (restart != RestartAlways)
 966             return;
 967         SMILTime nextBegin = findInstanceTime(Begin, m_intervalBegin, false);
 968         if (nextBegin &lt; m_intervalEnd) {
 969             m_intervalEnd = nextBegin;
 970             notifyDependentsIntervalChanged(ExistingInterval);
 971         }
 972     }
 973 
 974     if (elapsed &gt;= m_intervalEnd)
 975         resolveNextInterval(true);
 976 }
 977 
 978 void SVGSMILElement::seekToIntervalCorrespondingToTime(SMILTime elapsed)
 979 {
 980     ASSERT(!m_isWaitingForFirstInterval);
 981     ASSERT(elapsed &gt;= m_intervalBegin);
 982 
 983     // Manually seek from interval to interval, just as if the animation would run regulary.
 984     while (true) {
 985         // Figure out the next value in the begin time list after the current interval begin.
 986         SMILTime nextBegin = findInstanceTime(Begin, m_intervalBegin, false);
 987 
 988         // If the &#39;nextBegin&#39; time is unresolved (eg. just one defined interval), we&#39;re done seeking.
 989         if (nextBegin.isUnresolved())
 990             return;
 991 
 992         // If the &#39;nextBegin&#39; time is larger than or equal to the current interval end time, we&#39;re done seeking.
 993         // If the &#39;elapsed&#39; time is smaller than the next begin interval time, we&#39;re done seeking.
 994         if (nextBegin &lt; m_intervalEnd &amp;&amp; elapsed &gt;= nextBegin) {
 995             // End current interval, and start a new interval from the &#39;nextBegin&#39; time.
 996             m_intervalEnd = nextBegin;
 997             resolveNextInterval(false);
 998             continue;
 999         }
1000 
1001         // If the desired &#39;elapsed&#39; time is past the current interval, advance to the next.
1002         if (elapsed &gt;= m_intervalEnd) {
1003             resolveNextInterval(false);
1004             continue;
1005         }
1006 
1007         return;
1008     }
1009 }
1010 
1011 float SVGSMILElement::calculateAnimationPercentAndRepeat(SMILTime elapsed, unsigned&amp; repeat) const
1012 {
1013     SMILTime simpleDuration = this-&gt;simpleDuration();
1014     repeat = 0;
1015     if (simpleDuration.isIndefinite()) {
1016         repeat = 0;
1017         return 0.f;
1018     }
1019     if (!simpleDuration) {
1020         repeat = 0;
1021         return 1.f;
1022     }
1023     ASSERT(m_intervalBegin.isFinite());
1024     ASSERT(simpleDuration.isFinite());
1025     SMILTime activeTime = elapsed - m_intervalBegin;
1026     SMILTime repeatingDuration = this-&gt;repeatingDuration();
1027     if (elapsed &gt;= m_intervalEnd || activeTime &gt; repeatingDuration) {
1028         repeat = static_cast&lt;unsigned&gt;(repeatingDuration.value() / simpleDuration.value()) - 1;
1029 
1030         double percent = (m_intervalEnd.value() - m_intervalBegin.value()) / simpleDuration.value();
1031         percent = percent - floor(percent);
1032         if (percent &lt; std::numeric_limits&lt;float&gt;::epsilon() || 1 - percent &lt; std::numeric_limits&lt;float&gt;::epsilon())
1033             return 1.0f;
1034         return narrowPrecisionToFloat(percent);
1035     }
1036     repeat = static_cast&lt;unsigned&gt;(activeTime.value() / simpleDuration.value());
1037     SMILTime simpleTime = fmod(activeTime.value(), simpleDuration.value());
1038     return narrowPrecisionToFloat(simpleTime.value() / simpleDuration.value());
1039 }
1040 
1041 SMILTime SVGSMILElement::calculateNextProgressTime(SMILTime elapsed) const
1042 {
1043     if (m_timeContainer &amp;&amp; m_activeState == Active) {
1044         // If duration is indefinite the value does not actually change over time. Same is true for &lt;set&gt;.
1045         SMILTime simpleDuration = this-&gt;simpleDuration();
1046         if (simpleDuration.isIndefinite() || hasTagName(SVGNames::setTag)) {
1047             SMILTime repeatingDurationEnd = m_intervalBegin + repeatingDuration();
1048             // We are supposed to do freeze semantics when repeating ends, even if the element is still active.
1049             // Take care that we get a timer callback at that point.
1050             if (elapsed &lt; repeatingDurationEnd &amp;&amp; repeatingDurationEnd &lt; m_intervalEnd &amp;&amp; repeatingDurationEnd.isFinite())
1051                 return repeatingDurationEnd;
1052             return m_intervalEnd;
1053         }
1054         return elapsed + m_timeContainer-&gt;animationFrameDelay();
1055     }
1056     return m_intervalBegin &gt;= elapsed ? m_intervalBegin : SMILTime::unresolved();
1057 }
1058 
1059 SVGSMILElement::ActiveState SVGSMILElement::determineActiveState(SMILTime elapsed) const
1060 {
1061     if (elapsed &gt;= m_intervalBegin &amp;&amp; elapsed &lt; m_intervalEnd)
1062         return Active;
1063 
1064     return fill() == FillFreeze ? Frozen : Inactive;
1065 }
1066 
1067 bool SVGSMILElement::isContributing(SMILTime elapsed) const
1068 {
1069     // Animation does not contribute during the active time if it is past its repeating duration and has fill=remove.
1070     return (m_activeState == Active &amp;&amp; (fill() == FillFreeze || elapsed &lt;= m_intervalBegin + repeatingDuration())) || m_activeState == Frozen;
1071 }
1072 
1073 bool SVGSMILElement::progress(SMILTime elapsed, SVGSMILElement* resultElement, bool seekToTime)
1074 {
1075     ASSERT(resultElement);
1076     ASSERT(m_timeContainer);
1077     ASSERT(m_isWaitingForFirstInterval || m_intervalBegin.isFinite());
1078 
1079     if (!m_intervalBegin.isFinite()) {
1080         ASSERT(m_activeState == Inactive);
1081         m_nextProgressTime = SMILTime::unresolved();
1082         return false;
1083     }
1084 
1085     if (elapsed &lt; m_intervalBegin) {
1086         ASSERT(m_activeState != Active);
1087         if (m_activeState == Frozen) {
1088             if (this == resultElement)
1089                 resetAnimatedType();
1090             updateAnimation(m_lastPercent, m_lastRepeat, resultElement);
1091         }
1092         m_nextProgressTime = m_intervalBegin;
1093         return false;
1094     }
1095 
1096     m_previousIntervalBegin = m_intervalBegin;
1097 
1098     if (m_isWaitingForFirstInterval) {
1099         m_isWaitingForFirstInterval = false;
1100         resolveFirstInterval();
1101     }
1102 
1103     // This call may obtain a new interval -- never call calculateAnimationPercentAndRepeat() before!
1104     if (seekToTime) {
1105         seekToIntervalCorrespondingToTime(elapsed);
1106         if (elapsed &lt; m_intervalBegin) {
1107             // elapsed is not within an interval.
1108             m_nextProgressTime = m_intervalBegin;
1109             return false;
1110         }
1111     }
1112 
1113     unsigned repeat = 0;
1114     float percent = calculateAnimationPercentAndRepeat(elapsed, repeat);
1115     checkRestart(elapsed);
1116 
1117     ActiveState oldActiveState = m_activeState;
1118     m_activeState = determineActiveState(elapsed);
1119     bool animationIsContributing = isContributing(elapsed);
1120 
1121     // Only reset the animated type to the base value once for the lowest priority animation that animates and contributes to a particular element/attribute pair.
1122     if (this == resultElement &amp;&amp; animationIsContributing)
1123         resetAnimatedType();
1124 
1125     if (animationIsContributing) {
1126         if (oldActiveState == Inactive)
1127             startedActiveInterval();
1128 
1129         updateAnimation(percent, repeat, resultElement);
1130         m_lastPercent = percent;
1131         m_lastRepeat = repeat;
1132     }
1133 
1134     if (oldActiveState == Active &amp;&amp; m_activeState != Active) {
1135         smilEndEventSender().dispatchEventSoon(*this);
1136         endedActiveInterval();
1137         if (m_activeState != Frozen)
1138             clearAnimatedType(m_targetElement);
1139     } else if (oldActiveState != Active &amp;&amp; m_activeState == Active)
1140         smilBeginEventSender().dispatchEventSoon(*this);
1141 
1142     // Triggering all the pending events if the animation timeline is changed.
1143     if (seekToTime) {
1144         if (m_activeState == Inactive || m_activeState == Frozen)
1145             smilEndEventSender().dispatchEventSoon(*this);
1146     }
1147 
1148     m_nextProgressTime = calculateNextProgressTime(elapsed);
1149     return animationIsContributing;
1150 }
1151 
1152 void SVGSMILElement::notifyDependentsIntervalChanged(NewOrExistingInterval newOrExisting)
1153 {
1154     ASSERT(m_intervalBegin.isFinite());
1155     static NeverDestroyed&lt;HashSet&lt;SVGSMILElement*&gt;&gt; loopBreaker;
1156     if (loopBreaker.get().contains(this))
1157         return;
1158     loopBreaker.get().add(this);
1159 
1160     for (auto&amp; dependent : m_timeDependents) {
1161         dependent-&gt;createInstanceTimesFromSyncbase(this, newOrExisting);
1162     }
1163 
1164     loopBreaker.get().remove(this);
1165 }
1166 
1167 void SVGSMILElement::createInstanceTimesFromSyncbase(SVGSMILElement* syncbase, NewOrExistingInterval)
1168 {
1169     // FIXME: To be really correct, this should handle updating exising interval by changing
1170     // the associated times instead of creating new ones.
1171     for (auto&amp; condition : m_conditions) {
1172         if (condition.m_type == Condition::Syncbase &amp;&amp; condition.m_syncbase == syncbase) {
1173             ASSERT(condition.m_name == &quot;begin&quot; || condition.m_name == &quot;end&quot;);
1174             // No nested time containers in SVG, no need for crazy time space conversions. Phew!
1175             SMILTime time = 0;
1176             if (condition.m_name == &quot;begin&quot;)
1177                 time = syncbase-&gt;m_intervalBegin + condition.m_offset;
1178             else
1179                 time = syncbase-&gt;m_intervalEnd + condition.m_offset;
1180             if (!time.isFinite())
1181                 continue;
1182             if (condition.m_beginOrEnd == Begin)
1183                 addBeginTime(elapsed(), time);
1184             else
1185                 addEndTime(elapsed(), time);
1186         }
1187     }
1188 }
1189 
1190 void SVGSMILElement::addTimeDependent(SVGSMILElement* animation)
1191 {
1192     m_timeDependents.add(animation);
1193     if (m_intervalBegin.isFinite())
1194         animation-&gt;createInstanceTimesFromSyncbase(this, NewInterval);
1195 }
1196 
1197 void SVGSMILElement::removeTimeDependent(SVGSMILElement* animation)
1198 {
1199     m_timeDependents.remove(animation);
1200 }
1201 
1202 void SVGSMILElement::handleConditionEvent(Condition* condition)
1203 {
1204     SMILTime elapsed = this-&gt;elapsed();
1205     if (condition-&gt;m_beginOrEnd == Begin)
1206         addBeginTime(elapsed, elapsed + condition-&gt;m_offset);
1207     else
1208         addEndTime(elapsed, elapsed + condition-&gt;m_offset);
1209 }
1210 
1211 void SVGSMILElement::beginByLinkActivation()
1212 {
1213     SMILTime elapsed = this-&gt;elapsed();
1214     addBeginTime(elapsed, elapsed);
1215 }
1216 
1217 void SVGSMILElement::endedActiveInterval()
1218 {
1219     clearTimesWithDynamicOrigins(m_beginTimes);
1220     clearTimesWithDynamicOrigins(m_endTimes);
1221 }
1222 
1223 void SVGSMILElement::dispatchPendingEvent(SMILEventSender* eventSender)
1224 {
1225     ASSERT(eventSender == &amp;smilBeginEventSender() || eventSender == &amp;smilEndEventSender());
1226     const AtomString&amp; eventType = eventSender-&gt;eventType();
1227     dispatchEvent(Event::create(eventType, Event::CanBubble::No, Event::IsCancelable::No));
1228 }
1229 
1230 }
    </pre>
  </body>
</html>