<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCJSValueInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;CatchScope.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;ExceptionHelpers.h&quot;
  31 #include &quot;Identifier.h&quot;
  32 #include &quot;InternalFunction.h&quot;
  33 #include &quot;JSBigInt.h&quot;
  34 #include &quot;JSCJSValue.h&quot;
  35 #include &quot;JSCellInlines.h&quot;
  36 #include &quot;JSFunction.h&quot;
  37 #include &quot;JSObject.h&quot;
  38 #include &quot;JSProxy.h&quot;
  39 #include &quot;JSStringInlines.h&quot;
  40 #include &quot;MathCommon.h&quot;
  41 #include &lt;wtf/Variant.h&gt;
  42 #include &lt;wtf/text/StringImpl.h&gt;
  43 
  44 namespace JSC {
  45 
  46 ALWAYS_INLINE int32_t JSValue::toInt32(ExecState* exec) const
  47 {
  48     if (isInt32())
  49         return asInt32();
  50     return JSC::toInt32(toNumber(exec));
  51 }
  52 
  53 inline uint32_t JSValue::toUInt32(ExecState* exec) const
  54 {
  55     // See comment on JSC::toUInt32, in JSCJSValue.h.
  56     return toInt32(exec);
  57 }
  58 
  59 inline uint32_t JSValue::toIndex(ExecState* exec, const char* errorName) const
  60 {
  61     VM&amp; vm = exec-&gt;vm();
  62     auto scope = DECLARE_THROW_SCOPE(vm);
  63 
  64     double d = toNumber(exec);
  65     RETURN_IF_EXCEPTION(scope, 0);
  66     if (d &lt;= -1) {
  67         throwException(exec, scope, createRangeError(exec, makeString(errorName, &quot; cannot be negative&quot;)));
  68         return 0;
  69     }
  70     if (d &gt; std::numeric_limits&lt;unsigned&gt;::max()) {
  71         throwException(exec, scope, createRangeError(exec, makeString(errorName, &quot; too large&quot;)));
  72         return 0;
  73     }
  74 
  75     if (isInt32())
  76         return asInt32();
  77     RELEASE_AND_RETURN(scope, JSC::toInt32(d));
  78 }
  79 
  80 inline bool JSValue::isUInt32() const
  81 {
  82     return isInt32() &amp;&amp; asInt32() &gt;= 0;
  83 }
  84 
  85 inline uint32_t JSValue::asUInt32() const
  86 {
  87     ASSERT(isUInt32());
  88     return asInt32();
  89 }
  90 
  91 inline double JSValue::asNumber() const
  92 {
  93     ASSERT(isNumber());
  94     return isInt32() ? asInt32() : asDouble();
  95 }
  96 
  97 inline JSValue jsNaN()
  98 {
  99     return JSValue(JSValue::EncodeAsDouble, PNaN);
 100 }
 101 
 102 inline JSValue::JSValue(char i)
 103 {
 104     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 105 }
 106 
 107 inline JSValue::JSValue(unsigned char i)
 108 {
 109     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 110 }
 111 
 112 inline JSValue::JSValue(short i)
 113 {
 114     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 115 }
 116 
 117 inline JSValue::JSValue(unsigned short i)
 118 {
 119     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 120 }
 121 
 122 inline JSValue::JSValue(unsigned i)
 123 {
 124     if (static_cast&lt;int32_t&gt;(i) &lt; 0) {
 125         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 126         return;
 127     }
 128     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 129 }
 130 
 131 inline JSValue::JSValue(long i)
 132 {
 133     if (static_cast&lt;int32_t&gt;(i) != i) {
 134         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 135         return;
 136     }
 137     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 138 }
 139 
 140 inline JSValue::JSValue(unsigned long i)
 141 {
 142     if (static_cast&lt;uint32_t&gt;(i) != i) {
 143         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 144         return;
 145     }
 146     *this = JSValue(static_cast&lt;uint32_t&gt;(i));
 147 }
 148 
 149 inline JSValue::JSValue(long long i)
 150 {
 151     if (static_cast&lt;int32_t&gt;(i) != i) {
 152         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 153         return;
 154     }
 155     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 156 }
 157 
 158 inline JSValue::JSValue(unsigned long long i)
 159 {
 160     if (static_cast&lt;uint32_t&gt;(i) != i) {
 161         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 162         return;
 163     }
 164     *this = JSValue(static_cast&lt;uint32_t&gt;(i));
 165 }
 166 
 167 inline JSValue::JSValue(double d)
 168 {
 169     if (canBeStrictInt32(d)) {
 170         *this = JSValue(static_cast&lt;int32_t&gt;(d));
 171         return;
 172     }
 173     *this = JSValue(EncodeAsDouble, d);
 174 }
 175 
 176 inline EncodedJSValue JSValue::encode(JSValue value)
 177 {
 178     return value.u.asInt64;
 179 }
 180 
 181 inline JSValue JSValue::decode(EncodedJSValue encodedJSValue)
 182 {
 183     JSValue v;
 184     v.u.asInt64 = encodedJSValue;
 185     return v;
 186 }
 187 
 188 #if USE(JSVALUE32_64)
 189 inline JSValue::JSValue()
 190 {
 191     u.asBits.tag = EmptyValueTag;
 192     u.asBits.payload = 0;
 193 }
 194 
 195 inline JSValue::JSValue(JSNullTag)
 196 {
 197     u.asBits.tag = NullTag;
 198     u.asBits.payload = 0;
 199 }
 200 
 201 inline JSValue::JSValue(JSUndefinedTag)
 202 {
 203     u.asBits.tag = UndefinedTag;
 204     u.asBits.payload = 0;
 205 }
 206 
 207 inline JSValue::JSValue(JSTrueTag)
 208 {
 209     u.asBits.tag = BooleanTag;
 210     u.asBits.payload = 1;
 211 }
 212 
 213 inline JSValue::JSValue(JSFalseTag)
 214 {
 215     u.asBits.tag = BooleanTag;
 216     u.asBits.payload = 0;
 217 }
 218 
 219 inline JSValue::JSValue(HashTableDeletedValueTag)
 220 {
 221     u.asBits.tag = DeletedValueTag;
 222     u.asBits.payload = 0;
 223 }
 224 
 225 inline JSValue::JSValue(JSCell* ptr)
 226 {
 227     if (ptr)
 228         u.asBits.tag = CellTag;
 229     else
 230         u.asBits.tag = EmptyValueTag;
 231     u.asBits.payload = reinterpret_cast&lt;int32_t&gt;(ptr);
 232 }
 233 
 234 inline JSValue::JSValue(const JSCell* ptr)
 235 {
 236     if (ptr)
 237         u.asBits.tag = CellTag;
 238     else
 239         u.asBits.tag = EmptyValueTag;
 240     u.asBits.payload = reinterpret_cast&lt;int32_t&gt;(const_cast&lt;JSCell*&gt;(ptr));
 241 }
 242 
 243 inline JSValue::operator bool() const
 244 {
 245     ASSERT(tag() != DeletedValueTag);
 246     return tag() != EmptyValueTag;
 247 }
 248 
 249 inline bool JSValue::operator==(const JSValue&amp; other) const
 250 {
 251     return u.asInt64 == other.u.asInt64;
 252 }
 253 
 254 inline bool JSValue::operator!=(const JSValue&amp; other) const
 255 {
 256     return u.asInt64 != other.u.asInt64;
 257 }
 258 
 259 inline bool JSValue::isEmpty() const
 260 {
 261     return tag() == EmptyValueTag;
 262 }
 263 
 264 inline bool JSValue::isUndefined() const
 265 {
 266     return tag() == UndefinedTag;
 267 }
 268 
 269 inline bool JSValue::isNull() const
 270 {
 271     return tag() == NullTag;
 272 }
 273 
 274 inline bool JSValue::isUndefinedOrNull() const
 275 {
 276     return isUndefined() || isNull();
 277 }
 278 
 279 inline bool JSValue::isCell() const
 280 {
 281     return tag() == CellTag;
 282 }
 283 
 284 inline bool JSValue::isInt32() const
 285 {
 286     return tag() == Int32Tag;
 287 }
 288 
 289 inline bool JSValue::isDouble() const
 290 {
 291     return tag() &lt; LowestTag;
 292 }
 293 
 294 inline bool JSValue::isTrue() const
 295 {
 296     return tag() == BooleanTag &amp;&amp; payload();
 297 }
 298 
 299 inline bool JSValue::isFalse() const
 300 {
 301     return tag() == BooleanTag &amp;&amp; !payload();
 302 }
 303 
 304 inline uint32_t JSValue::tag() const
 305 {
 306     return u.asBits.tag;
 307 }
 308 
 309 inline int32_t JSValue::payload() const
 310 {
 311     return u.asBits.payload;
 312 }
 313 
 314 inline int32_t JSValue::asInt32() const
 315 {
 316     ASSERT(isInt32());
 317     return u.asBits.payload;
 318 }
 319 
 320 inline double JSValue::asDouble() const
 321 {
 322     ASSERT(isDouble());
 323     return u.asDouble;
 324 }
 325 
 326 ALWAYS_INLINE JSCell* JSValue::asCell() const
 327 {
 328     ASSERT(isCell());
 329     return reinterpret_cast&lt;JSCell*&gt;(u.asBits.payload);
 330 }
 331 
 332 ALWAYS_INLINE JSValue::JSValue(EncodeAsDoubleTag, double d)
 333 {
 334     ASSERT(!isImpureNaN(d));
 335     u.asDouble = d;
 336 }
 337 
 338 inline JSValue::JSValue(int i)
 339 {
 340     u.asBits.tag = Int32Tag;
 341     u.asBits.payload = i;
 342 }
 343 
 344 inline JSValue::JSValue(int32_t tag, int32_t payload)
 345 {
 346     u.asBits.tag = tag;
 347     u.asBits.payload = payload;
 348 }
 349 
 350 inline bool JSValue::isNumber() const
 351 {
 352     return isInt32() || isDouble();
 353 }
 354 
 355 inline bool JSValue::isBoolean() const
 356 {
 357     return tag() == BooleanTag;
 358 }
 359 
 360 inline bool JSValue::asBoolean() const
 361 {
 362     ASSERT(isBoolean());
 363     return payload();
 364 }
 365 
 366 #else // !USE(JSVALUE32_64) i.e. USE(JSVALUE64)
 367 
 368 // 0x0 can never occur naturally because it has a tag of 00, indicating a pointer value, but a payload of 0x0, which is in the (invalid) zero page.
 369 inline JSValue::JSValue()
 370 {
 371     u.asInt64 = ValueEmpty;
 372 }
 373 
 374 // 0x4 can never occur naturally because it has a tag of 00, indicating a pointer value, but a payload of 0x4, which is in the (invalid) zero page.
 375 inline JSValue::JSValue(HashTableDeletedValueTag)
 376 {
 377     u.asInt64 = ValueDeleted;
 378 }
 379 
 380 inline JSValue::JSValue(JSCell* ptr)
 381 {
 382     u.asInt64 = reinterpret_cast&lt;uintptr_t&gt;(ptr);
 383 }
 384 
 385 inline JSValue::JSValue(const JSCell* ptr)
 386 {
 387     u.asInt64 = reinterpret_cast&lt;uintptr_t&gt;(const_cast&lt;JSCell*&gt;(ptr));
 388 }
 389 
 390 inline JSValue::operator bool() const
 391 {
 392     return u.asInt64;
 393 }
 394 
 395 inline bool JSValue::operator==(const JSValue&amp; other) const
 396 {
 397     return u.asInt64 == other.u.asInt64;
 398 }
 399 
 400 inline bool JSValue::operator!=(const JSValue&amp; other) const
 401 {
 402     return u.asInt64 != other.u.asInt64;
 403 }
 404 
 405 inline bool JSValue::isEmpty() const
 406 {
 407     return u.asInt64 == ValueEmpty;
 408 }
 409 
 410 inline bool JSValue::isUndefined() const
 411 {
 412     return asValue() == JSValue(JSUndefined);
 413 }
 414 
 415 inline bool JSValue::isNull() const
 416 {
 417     return asValue() == JSValue(JSNull);
 418 }
 419 
 420 inline bool JSValue::isTrue() const
 421 {
 422     return asValue() == JSValue(JSTrue);
 423 }
 424 
 425 inline bool JSValue::isFalse() const
 426 {
 427     return asValue() == JSValue(JSFalse);
 428 }
 429 
 430 inline bool JSValue::asBoolean() const
 431 {
 432     ASSERT(isBoolean());
 433     return asValue() == JSValue(JSTrue);
 434 }
 435 
 436 inline int32_t JSValue::asInt32() const
 437 {
 438     ASSERT(isInt32());
 439     return static_cast&lt;int32_t&gt;(u.asInt64);
 440 }
 441 
 442 inline bool JSValue::isDouble() const
 443 {
 444     return isNumber() &amp;&amp; !isInt32();
 445 }
 446 
 447 inline JSValue::JSValue(JSNullTag)
 448 {
 449     u.asInt64 = ValueNull;
 450 }
 451 
 452 inline JSValue::JSValue(JSUndefinedTag)
 453 {
 454     u.asInt64 = ValueUndefined;
 455 }
 456 
 457 inline JSValue::JSValue(JSTrueTag)
 458 {
 459     u.asInt64 = ValueTrue;
 460 }
 461 
 462 inline JSValue::JSValue(JSFalseTag)
 463 {
 464     u.asInt64 = ValueFalse;
 465 }
 466 
 467 inline bool JSValue::isUndefinedOrNull() const
 468 {
 469     // Undefined and null share the same value, bar the &#39;undefined&#39; bit in the extended tag.
 470     return (u.asInt64 &amp; ~TagBitUndefined) == ValueNull;
 471 }
 472 
 473 inline bool JSValue::isBoolean() const
 474 {
 475     return (u.asInt64 &amp; ~1) == ValueFalse;
 476 }
 477 
 478 inline bool JSValue::isCell() const
 479 {
 480     return !(u.asInt64 &amp; TagMask);
 481 }
 482 
 483 inline bool JSValue::isInt32() const
 484 {
 485     return (u.asInt64 &amp; TagTypeNumber) == TagTypeNumber;
 486 }
 487 
 488 inline int64_t reinterpretDoubleToInt64(double value)
 489 {
 490     return bitwise_cast&lt;int64_t&gt;(value);
 491 }
 492 inline double reinterpretInt64ToDouble(int64_t value)
 493 {
 494     return bitwise_cast&lt;double&gt;(value);
 495 }
 496 
 497 ALWAYS_INLINE JSValue::JSValue(EncodeAsDoubleTag, double d)
 498 {
 499     ASSERT(!isImpureNaN(d));
 500     u.asInt64 = reinterpretDoubleToInt64(d) + DoubleEncodeOffset;
 501 }
 502 
 503 inline JSValue::JSValue(int i)
 504 {
 505     u.asInt64 = TagTypeNumber | static_cast&lt;uint32_t&gt;(i);
 506 }
 507 
 508 inline double JSValue::asDouble() const
 509 {
 510     ASSERT(isDouble());
 511     return reinterpretInt64ToDouble(u.asInt64 - DoubleEncodeOffset);
 512 }
 513 
 514 inline bool JSValue::isNumber() const
 515 {
 516     return u.asInt64 &amp; TagTypeNumber;
 517 }
 518 
 519 ALWAYS_INLINE JSCell* JSValue::asCell() const
 520 {
 521     ASSERT(isCell());
 522     return u.ptr;
 523 }
 524 
 525 #endif // USE(JSVALUE64)
 526 
 527 inline int64_t tryConvertToInt52(double number)
 528 {
 529     if (number != number)
 530         return JSValue::notInt52;
 531 #if OS(WINDOWS) &amp;&amp; CPU(X86)
 532     // The VS Compiler for 32-bit builds generates a floating point error when attempting to cast
 533     // from an infinity to a 64-bit integer. We leave this routine with the floating point error
 534     // left in a register, causing undefined behavior in later floating point operations.
 535     //
 536     // To avoid this issue, we check for infinity here, and return false in that case.
 537     if (std::isinf(number))
 538         return JSValue::notInt52;
 539 #endif
 540     int64_t asInt64 = static_cast&lt;int64_t&gt;(number);
 541     if (asInt64 != number)
 542         return JSValue::notInt52;
 543     if (!asInt64 &amp;&amp; std::signbit(number))
 544         return JSValue::notInt52;
 545     if (asInt64 &gt;= (static_cast&lt;int64_t&gt;(1) &lt;&lt; (JSValue::numberOfInt52Bits - 1)))
 546         return JSValue::notInt52;
 547     if (asInt64 &lt; -(static_cast&lt;int64_t&gt;(1) &lt;&lt; (JSValue::numberOfInt52Bits - 1)))
 548         return JSValue::notInt52;
 549     return asInt64;
 550 }
 551 
 552 inline bool isInt52(double number)
 553 {
 554     return tryConvertToInt52(number) != JSValue::notInt52;
 555 }
 556 
 557 inline bool JSValue::isAnyInt() const
 558 {
 559     if (isInt32())
 560         return true;
 561     if (!isNumber())
 562         return false;
 563     return isInt52(asDouble());
 564 }
 565 
 566 inline int64_t JSValue::asAnyInt() const
 567 {
 568     ASSERT(isAnyInt());
 569     if (isInt32())
 570         return asInt32();
 571     return static_cast&lt;int64_t&gt;(asDouble());
 572 }
 573 
<a name="2" id="anc2"></a><span class="line-added"> 574 inline bool JSValue::isInt32AsAnyInt() const</span>
<span class="line-added"> 575 {</span>
<span class="line-added"> 576     if (!isAnyInt())</span>
<span class="line-added"> 577         return false;</span>
<span class="line-added"> 578     int64_t value = asAnyInt();</span>
<span class="line-added"> 579     return value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX;</span>
<span class="line-added"> 580 }</span>
<span class="line-added"> 581 </span>
<span class="line-added"> 582 inline int32_t JSValue::asInt32AsAnyInt() const</span>
<span class="line-added"> 583 {</span>
<span class="line-added"> 584     ASSERT(isInt32AsAnyInt());</span>
<span class="line-added"> 585     if (isInt32())</span>
<span class="line-added"> 586         return asInt32();</span>
<span class="line-added"> 587     return static_cast&lt;int32_t&gt;(asDouble());</span>
<span class="line-added"> 588 }</span>
<span class="line-added"> 589 </span>
<span class="line-added"> 590 inline bool JSValue::isUInt32AsAnyInt() const</span>
<span class="line-added"> 591 {</span>
<span class="line-added"> 592     if (!isAnyInt())</span>
<span class="line-added"> 593         return false;</span>
<span class="line-added"> 594     int64_t value = asAnyInt();</span>
<span class="line-added"> 595     return value &gt;= 0 &amp;&amp; value &lt;= UINT32_MAX;</span>
<span class="line-added"> 596 }</span>
<span class="line-added"> 597 </span>
<span class="line-added"> 598 inline uint32_t JSValue::asUInt32AsAnyInt() const</span>
<span class="line-added"> 599 {</span>
<span class="line-added"> 600     ASSERT(isUInt32AsAnyInt());</span>
<span class="line-added"> 601     if (isUInt32())</span>
<span class="line-added"> 602         return asUInt32();</span>
<span class="line-added"> 603     return static_cast&lt;uint32_t&gt;(asDouble());</span>
<span class="line-added"> 604 }</span>
<span class="line-added"> 605 </span>
 606 inline bool JSValue::isString() const
 607 {
 608     return isCell() &amp;&amp; asCell()-&gt;isString();
 609 }
 610 
 611 inline bool JSValue::isBigInt() const
 612 {
 613     return isCell() &amp;&amp; asCell()-&gt;isBigInt();
 614 }
 615 
 616 inline bool JSValue::isSymbol() const
 617 {
 618     return isCell() &amp;&amp; asCell()-&gt;isSymbol();
 619 }
 620 
 621 inline bool JSValue::isPrimitive() const
 622 {
 623     return !isCell() || asCell()-&gt;isString() || asCell()-&gt;isSymbol() || asCell()-&gt;isBigInt();
 624 }
 625 
 626 inline bool JSValue::isGetterSetter() const
 627 {
 628     return isCell() &amp;&amp; asCell()-&gt;isGetterSetter();
 629 }
 630 
 631 inline bool JSValue::isCustomGetterSetter() const
 632 {
 633     return isCell() &amp;&amp; asCell()-&gt;isCustomGetterSetter();
 634 }
 635 
 636 inline bool JSValue::isObject() const
 637 {
 638     return isCell() &amp;&amp; asCell()-&gt;isObject();
 639 }
 640 
 641 inline bool JSValue::getString(ExecState* exec, String&amp; s) const
 642 {
 643     return isCell() &amp;&amp; asCell()-&gt;getString(exec, s);
 644 }
 645 
 646 inline String JSValue::getString(ExecState* exec) const
 647 {
 648     return isCell() ? asCell()-&gt;getString(exec) : String();
 649 }
 650 
 651 template &lt;typename Base&gt; String HandleConverter&lt;Base, Unknown&gt;::getString(ExecState* exec) const
 652 {
 653     return jsValue().getString(exec);
 654 }
 655 
 656 inline JSObject* JSValue::getObject() const
 657 {
 658     return isCell() ? asCell()-&gt;getObject() : 0;
 659 }
 660 
 661 ALWAYS_INLINE bool JSValue::getUInt32(uint32_t&amp; v) const
 662 {
 663     if (isInt32()) {
 664         int32_t i = asInt32();
 665         v = static_cast&lt;uint32_t&gt;(i);
 666         return i &gt;= 0;
 667     }
 668     if (isDouble()) {
 669         double d = asDouble();
 670         v = static_cast&lt;uint32_t&gt;(d);
 671         return v == d;
 672     }
 673     return false;
 674 }
 675 
 676 ALWAYS_INLINE Identifier JSValue::toPropertyKey(ExecState* exec) const
 677 {
 678     VM&amp; vm = exec-&gt;vm();
 679     auto scope = DECLARE_THROW_SCOPE(vm);
 680 
 681     if (isString())
 682         RELEASE_AND_RETURN(scope, asString(*this)-&gt;toIdentifier(exec));
 683 
 684     JSValue primitive = toPrimitive(exec, PreferString);
 685     RETURN_IF_EXCEPTION(scope, vm.propertyNames-&gt;emptyIdentifier);
 686     if (primitive.isSymbol())
 687         RELEASE_AND_RETURN(scope, Identifier::fromUid(asSymbol(primitive)-&gt;privateName()));
 688 
<a name="3" id="anc3"></a><span class="line-modified"> 689     auto string = primitive.toString(exec);</span>
<span class="line-added"> 690     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added"> 691     RELEASE_AND_RETURN(scope, string-&gt;toIdentifier(exec));</span>
 692 }
 693 
 694 inline JSValue JSValue::toPrimitive(ExecState* exec, PreferredPrimitiveType preferredType) const
 695 {
 696     return isCell() ? asCell()-&gt;toPrimitive(exec, preferredType) : asValue();
 697 }
 698 
 699 inline PreferredPrimitiveType toPreferredPrimitiveType(ExecState* exec, JSValue value)
 700 {
 701     VM&amp; vm = exec-&gt;vm();
 702     auto scope = DECLARE_THROW_SCOPE(vm);
 703 
 704     if (!value.isString()) {
 705         throwTypeError(exec, scope, &quot;Primitive hint is not a string.&quot;_s);
 706         return NoPreference;
 707     }
 708 
 709     StringImpl* hintString = asString(value)-&gt;value(exec).impl();
 710     RETURN_IF_EXCEPTION(scope, NoPreference);
 711 
 712     if (WTF::equal(hintString, &quot;default&quot;))
 713         return NoPreference;
 714     if (WTF::equal(hintString, &quot;number&quot;))
 715         return PreferNumber;
 716     if (WTF::equal(hintString, &quot;string&quot;))
 717         return PreferString;
 718 
 719     throwTypeError(exec, scope, &quot;Expected primitive hint to match one of &#39;default&#39;, &#39;number&#39;, &#39;string&#39;.&quot;_s);
 720     return NoPreference;
 721 }
 722 
 723 inline bool JSValue::getPrimitiveNumber(ExecState* exec, double&amp; number, JSValue&amp; value)
 724 {
 725     if (isInt32()) {
 726         number = asInt32();
 727         value = *this;
 728         return true;
 729     }
 730     if (isDouble()) {
 731         number = asDouble();
 732         value = *this;
 733         return true;
 734     }
 735     if (isCell())
 736         return asCell()-&gt;getPrimitiveNumber(exec, number, value);
 737     if (isTrue()) {
 738         number = 1.0;
 739         value = *this;
 740         return true;
 741     }
 742     if (isFalse() || isNull()) {
 743         number = 0.0;
 744         value = *this;
 745         return true;
 746     }
 747     ASSERT(isUndefined());
 748     number = PNaN;
 749     value = *this;
 750     return true;
 751 }
 752 
 753 ALWAYS_INLINE double JSValue::toNumber(ExecState* exec) const
 754 {
 755     if (isInt32())
 756         return asInt32();
 757     if (isDouble())
 758         return asDouble();
 759     return toNumberSlowCase(exec);
 760 }
 761 
 762 ALWAYS_INLINE Variant&lt;JSBigInt*, double&gt; JSValue::toNumeric(ExecState* exec) const
 763 {
 764     if (isInt32())
 765         return asInt32();
 766     if (isDouble())
 767         return asDouble();
 768     if (isBigInt())
 769         return asBigInt(*this);
 770 
 771     VM&amp; vm = exec-&gt;vm();
 772     auto scope = DECLARE_THROW_SCOPE(vm);
 773     JSValue primValue = this-&gt;toPrimitive(exec, PreferNumber);
 774     RETURN_IF_EXCEPTION(scope, 0);
 775     if (primValue.isBigInt())
 776         return asBigInt(primValue);
 777     double value = primValue.toNumber(exec);
 778     RETURN_IF_EXCEPTION(scope, 0);
 779     return value;
 780 }
 781 
 782 ALWAYS_INLINE Variant&lt;JSBigInt*, int32_t&gt; JSValue::toBigIntOrInt32(ExecState* exec) const
 783 {
 784     if (isInt32())
 785         return asInt32();
 786     if (isDouble() &amp;&amp; canBeInt32(asDouble()))
 787         return static_cast&lt;int32_t&gt;(asDouble());
 788     if (isBigInt())
 789         return asBigInt(*this);
 790 
 791     VM&amp; vm = exec-&gt;vm();
 792     auto scope = DECLARE_THROW_SCOPE(vm);
 793     JSValue primValue = this-&gt;toPrimitive(exec, PreferNumber);
 794     RETURN_IF_EXCEPTION(scope, 0);
 795     if (primValue.isBigInt())
 796         return asBigInt(primValue);
 797     int32_t value = primValue.toInt32(exec);
 798     RETURN_IF_EXCEPTION(scope, 0);
 799     return value;
 800 }
 801 
 802 inline JSObject* JSValue::toObject(ExecState* exec) const
 803 {
 804     return isCell() ? asCell()-&gt;toObject(exec, exec-&gt;lexicalGlobalObject()) : toObjectSlowCase(exec, exec-&gt;lexicalGlobalObject());
 805 }
 806 
 807 inline JSObject* JSValue::toObject(ExecState* exec, JSGlobalObject* globalObject) const
 808 {
 809     return isCell() ? asCell()-&gt;toObject(exec, globalObject) : toObjectSlowCase(exec, globalObject);
 810 }
 811 
 812 inline bool JSValue::isFunction(VM&amp; vm) const
 813 {
 814     if (!isCell())
 815         return false;
 816     return asCell()-&gt;isFunction(vm);
 817 }
 818 
 819 inline bool JSValue::isCallable(VM&amp; vm, CallType&amp; callType, CallData&amp; callData) const
 820 {
 821     if (!isCell())
 822         return false;
 823     return asCell()-&gt;isCallable(vm, callType, callData);
 824 }
 825 
 826 inline bool JSValue::isConstructor(VM&amp; vm) const
 827 {
 828     if (!isCell())
 829         return false;
 830     return asCell()-&gt;isConstructor(vm);
 831 }
 832 
 833 inline bool JSValue::isConstructor(VM&amp; vm, ConstructType&amp; constructType, ConstructData&amp; constructData) const
 834 {
 835     if (!isCell())
 836         return false;
 837     return asCell()-&gt;isConstructor(vm, constructType, constructData);
 838 }
 839 
 840 // this method is here to be after the inline declaration of JSCell::inherits
 841 inline bool JSValue::inherits(VM&amp; vm, const ClassInfo* classInfo) const
 842 {
 843     return isCell() &amp;&amp; asCell()-&gt;inherits(vm, classInfo);
 844 }
 845 
 846 template&lt;typename Target&gt;
 847 inline bool JSValue::inherits(VM&amp; vm) const
 848 {
 849     return isCell() &amp;&amp; asCell()-&gt;inherits&lt;Target&gt;(vm);
 850 }
 851 
 852 inline const ClassInfo* JSValue::classInfoOrNull(VM&amp; vm) const
 853 {
 854     return isCell() ? asCell()-&gt;classInfo(vm) : nullptr;
 855 }
 856 
 857 inline JSValue JSValue::toThis(ExecState* exec, ECMAMode ecmaMode) const
 858 {
 859     return isCell() ? asCell()-&gt;methodTable(exec-&gt;vm())-&gt;toThis(asCell(), exec, ecmaMode) : toThisSlowCase(exec, ecmaMode);
 860 }
 861 
 862 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, PropertyName propertyName) const
 863 {
 864     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
 865     return get(exec, propertyName, slot);
 866 }
 867 
 868 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot) const
 869 {
 870     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
 871     bool hasSlot = getPropertySlot(exec, propertyName, slot);
 872     EXCEPTION_ASSERT(!scope.exception() || !hasSlot);
 873     if (!hasSlot)
 874         return jsUndefined();
 875     RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));
 876 }
 877 
 878 template&lt;typename CallbackWhenNoException&gt;
 879 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSValue::getPropertySlot(ExecState* exec, PropertyName propertyName, CallbackWhenNoException callback) const
 880 {
 881     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
 882     return getPropertySlot(exec, propertyName, slot, callback);
 883 }
 884 
 885 template&lt;typename CallbackWhenNoException&gt;
 886 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSValue::getPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot, CallbackWhenNoException callback) const
 887 {
 888     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
 889     bool found = getPropertySlot(exec, propertyName, slot);
 890     RETURN_IF_EXCEPTION(scope, { });
 891     RELEASE_AND_RETURN(scope, callback(found, slot));
 892 }
 893 
 894 ALWAYS_INLINE bool JSValue::getPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot) const
 895 {
 896     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
 897     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 898     // and if it&#39;s a string there are special properties to check first.
 899     JSObject* object;
 900     if (UNLIKELY(!isObject())) {
 901         if (isString()) {
 902             bool hasProperty = asString(*this)-&gt;getStringPropertySlot(exec, propertyName, slot);
 903             RETURN_IF_EXCEPTION(scope, false);
 904             if (hasProperty)
 905                 return true;
 906         }
 907         object = synthesizePrototype(exec);
 908         EXCEPTION_ASSERT(!!scope.exception() == !object);
 909         if (UNLIKELY(!object))
 910             return false;
 911     } else
 912         object = asObject(asCell());
 913 
 914     RELEASE_AND_RETURN(scope, object-&gt;getPropertySlot(exec, propertyName, slot));
 915 }
 916 
 917 ALWAYS_INLINE bool JSValue::getOwnPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot) const
 918 {
 919     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 920     // and if it&#39;s a string there are special properties to check first.
 921     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
 922     if (UNLIKELY(!isObject())) {
 923         if (isString())
 924             RELEASE_AND_RETURN(scope, asString(*this)-&gt;getStringPropertySlot(exec, propertyName, slot));
 925 
 926         if (isUndefinedOrNull())
 927             throwException(exec, scope, createNotAnObjectError(exec, *this));
 928         return false;
 929     }
 930     RELEASE_AND_RETURN(scope, asObject(asCell())-&gt;getOwnPropertySlotInline(exec, propertyName, slot));
 931 }
 932 
 933 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, unsigned propertyName) const
 934 {
 935     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
 936     return get(exec, propertyName, slot);
 937 }
 938 
 939 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, unsigned propertyName, PropertySlot&amp; slot) const
 940 {
 941     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());
 942     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 943     // and if it&#39;s a string there are special properties to check first.
 944     JSObject* object;
 945     if (UNLIKELY(!isObject())) {
 946         if (isString()) {
 947             bool hasProperty = asString(*this)-&gt;getStringPropertySlot(exec, propertyName, slot);
 948             RETURN_IF_EXCEPTION(scope, { });
 949             if (hasProperty)
 950                 RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));
 951         }
 952         object = synthesizePrototype(exec);
 953         EXCEPTION_ASSERT(!!scope.exception() == !object);
 954         if (UNLIKELY(!object))
 955             return JSValue();
 956     } else
 957         object = asObject(asCell());
 958 
 959     bool hasSlot = object-&gt;getPropertySlot(exec, propertyName, slot);
 960     EXCEPTION_ASSERT(!scope.exception() || !hasSlot);
 961     if (!hasSlot)
 962         return jsUndefined();
 963     RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));
 964 }
 965 
 966 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, uint64_t propertyName) const
 967 {
 968     if (LIKELY(propertyName &lt;= std::numeric_limits&lt;unsigned&gt;::max()))
 969         return get(exec, static_cast&lt;unsigned&gt;(propertyName));
<a name="4" id="anc4"></a><span class="line-modified"> 970     return get(exec, Identifier::from(exec-&gt;vm(), static_cast&lt;double&gt;(propertyName)));</span>
 971 }
 972 
 973 inline bool JSValue::put(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 974 {
 975     if (UNLIKELY(!isCell()))
 976         return putToPrimitive(exec, propertyName, value, slot);
 977 
 978     return asCell()-&gt;methodTable(exec-&gt;vm())-&gt;put(asCell(), exec, propertyName, value, slot);
 979 }
 980 
 981 ALWAYS_INLINE bool JSValue::putInline(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 982 {
 983     if (UNLIKELY(!isCell()))
 984         return putToPrimitive(exec, propertyName, value, slot);
 985     return asCell()-&gt;putInline(exec, propertyName, value, slot);
 986 }
 987 
 988 inline bool JSValue::putByIndex(ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)
 989 {
 990     if (UNLIKELY(!isCell()))
 991         return putToPrimitiveByIndex(exec, propertyName, value, shouldThrow);
 992 
 993     return asCell()-&gt;methodTable(exec-&gt;vm())-&gt;putByIndex(asCell(), exec, propertyName, value, shouldThrow);
 994 }
 995 
 996 inline Structure* JSValue::structureOrNull() const
 997 {
 998     if (isCell())
 999         return asCell()-&gt;structure();
1000     return nullptr;
1001 }
1002 
1003 inline JSValue JSValue::structureOrUndefined() const
1004 {
1005     if (isCell())
1006         return JSValue(asCell()-&gt;structure());
1007     return jsUndefined();
1008 }
1009 
1010 // ECMA 11.9.3
1011 inline bool JSValue::equal(ExecState* exec, JSValue v1, JSValue v2)
1012 {
1013     if (v1.isInt32() &amp;&amp; v2.isInt32())
1014         return v1 == v2;
1015 
1016     return equalSlowCase(exec, v1, v2);
1017 }
1018 
1019 ALWAYS_INLINE bool JSValue::equalSlowCaseInline(ExecState* exec, JSValue v1, JSValue v2)
1020 {
1021     VM&amp; vm = exec-&gt;vm();
1022     auto scope = DECLARE_THROW_SCOPE(vm);
1023     do {
1024         if (v1.isNumber() &amp;&amp; v2.isNumber())
1025             return v1.asNumber() == v2.asNumber();
1026 
1027         bool s1 = v1.isString();
1028         bool s2 = v2.isString();
1029         if (s1 &amp;&amp; s2)
1030             RELEASE_AND_RETURN(scope, asString(v1)-&gt;equal(exec, asString(v2)));
1031 
1032         if (v1.isBigInt() &amp;&amp; s2) {
1033             JSBigInt* n = JSBigInt::stringToBigInt(exec, asString(v2)-&gt;value(exec));
1034             RETURN_IF_EXCEPTION(scope, false);
1035             if (!n)
1036                 return false;
1037 
1038             v2 = JSValue(n);
1039             continue;
1040         }
1041 
1042         if (s1 &amp;&amp; v2.isBigInt()) {
1043             JSBigInt* n = JSBigInt::stringToBigInt(exec, asString(v1)-&gt;value(exec));
1044             RETURN_IF_EXCEPTION(scope, false);
1045             if (!n)
1046                 return false;
1047 
1048             v1 = JSValue(n);
1049             continue;
1050         }
1051 
1052         if (v1.isUndefinedOrNull()) {
1053             if (v2.isUndefinedOrNull())
1054                 return true;
1055             if (!v2.isCell())
1056                 return false;
1057             return v2.asCell()-&gt;structure(vm)-&gt;masqueradesAsUndefined(exec-&gt;lexicalGlobalObject());
1058         }
1059 
1060         if (v2.isUndefinedOrNull()) {
1061             if (!v1.isCell())
1062                 return false;
1063             return v1.asCell()-&gt;structure(vm)-&gt;masqueradesAsUndefined(exec-&gt;lexicalGlobalObject());
1064         }
1065 
1066         if (v1.isObject()) {
1067             if (v2.isObject())
1068                 return v1 == v2;
1069             JSValue p1 = v1.toPrimitive(exec);
1070             RETURN_IF_EXCEPTION(scope, false);
1071             v1 = p1;
1072             if (v1.isInt32() &amp;&amp; v2.isInt32())
1073                 return v1 == v2;
1074             continue;
1075         }
1076 
1077         if (v2.isObject()) {
1078             JSValue p2 = v2.toPrimitive(exec);
1079             RETURN_IF_EXCEPTION(scope, false);
1080             v2 = p2;
1081             if (v1.isInt32() &amp;&amp; v2.isInt32())
1082                 return v1 == v2;
1083             continue;
1084         }
1085 
1086         bool sym1 = v1.isSymbol();
1087         bool sym2 = v2.isSymbol();
1088         if (sym1 || sym2) {
1089             if (sym1 &amp;&amp; sym2)
1090                 return asSymbol(v1) == asSymbol(v2);
1091             return false;
1092         }
1093 
1094         if (s1 || s2) {
1095             double d1 = v1.toNumber(exec);
1096             RETURN_IF_EXCEPTION(scope, false);
1097             double d2 = v2.toNumber(exec);
1098             RETURN_IF_EXCEPTION(scope, false);
1099             return d1 == d2;
1100         }
1101 
1102         if (v1.isBoolean()) {
1103             if (v2.isNumber())
1104                 return static_cast&lt;double&gt;(v1.asBoolean()) == v2.asNumber();
1105             else if (v2.isBigInt()) {
1106                 v1 = JSValue(v1.toNumber(exec));
1107                 continue;
1108             }
1109         } else if (v2.isBoolean()) {
1110             if (v1.isNumber())
1111                 return v1.asNumber() == static_cast&lt;double&gt;(v2.asBoolean());
1112             else if (v1.isBigInt()) {
1113                 v2 = JSValue(v2.toNumber(exec));
1114                 continue;
1115             }
1116         }
1117 
1118         if (v1.isBigInt() &amp;&amp; v2.isBigInt())
1119             return JSBigInt::equals(asBigInt(v1), asBigInt(v2));
1120 
1121         if (v1.isBigInt() &amp;&amp; v2.isNumber())
1122             return asBigInt(v1)-&gt;equalsToNumber(v2);
1123 
1124         if (v2.isBigInt() &amp;&amp; v1.isNumber())
1125             return asBigInt(v2)-&gt;equalsToNumber(v1);
1126 
1127         return v1 == v2;
1128     } while (true);
1129 }
1130 
1131 // ECMA 11.9.3
1132 ALWAYS_INLINE bool JSValue::strictEqualSlowCaseInline(ExecState* exec, JSValue v1, JSValue v2)
1133 {
1134     ASSERT(v1.isCell() &amp;&amp; v2.isCell());
1135 
1136     if (v1.asCell()-&gt;isString() &amp;&amp; v2.asCell()-&gt;isString())
1137         return asString(v1)-&gt;equal(exec, asString(v2));
1138     if (v1.isBigInt() &amp;&amp; v2.isBigInt())
1139         return JSBigInt::equals(asBigInt(v1), asBigInt(v2));
1140     return v1 == v2;
1141 }
1142 
1143 inline bool JSValue::strictEqual(ExecState* exec, JSValue v1, JSValue v2)
1144 {
1145     if (v1.isInt32() &amp;&amp; v2.isInt32())
1146         return v1 == v2;
1147 
1148     if (v1.isNumber() &amp;&amp; v2.isNumber())
1149         return v1.asNumber() == v2.asNumber();
1150 
1151     if (!v1.isCell() || !v2.isCell())
1152         return v1 == v2;
1153 
1154     return strictEqualSlowCaseInline(exec, v1, v2);
1155 }
1156 
1157 inline int32_t JSValue::asInt32ForArithmetic() const
1158 {
1159     if (isBoolean())
1160         return asBoolean();
1161     return asInt32();
1162 }
1163 
1164 inline TriState JSValue::pureStrictEqual(JSValue v1, JSValue v2)
1165 {
1166     if (v1.isInt32() &amp;&amp; v2.isInt32())
1167         return triState(v1 == v2);
1168 
1169     if (v1.isNumber() &amp;&amp; v2.isNumber())
1170         return triState(v1.asNumber() == v2.asNumber());
1171 
1172     if (!v1.isCell() || !v2.isCell())
1173         return triState(v1 == v2);
1174 
1175     if (v1.asCell()-&gt;isString() &amp;&amp; v2.asCell()-&gt;isString()) {
1176         const StringImpl* v1String = asString(v1)-&gt;tryGetValueImpl();
1177         const StringImpl* v2String = asString(v2)-&gt;tryGetValueImpl();
1178         if (!v1String || !v2String)
1179             return MixedTriState;
1180         return triState(WTF::equal(*v1String, *v2String));
1181     }
1182 
1183     return triState(v1 == v2);
1184 }
1185 
1186 inline TriState JSValue::pureToBoolean() const
1187 {
1188     if (isInt32())
1189         return asInt32() ? TrueTriState : FalseTriState;
1190     if (isDouble())
1191         return isNotZeroAndOrdered(asDouble()) ? TrueTriState : FalseTriState; // false for NaN
1192     if (isCell())
1193         return asCell()-&gt;pureToBoolean();
1194     return isTrue() ? TrueTriState : FalseTriState;
1195 }
1196 
1197 ALWAYS_INLINE bool JSValue::requireObjectCoercible(ExecState* exec) const
1198 {
1199     VM&amp; vm = exec-&gt;vm();
1200     auto scope = DECLARE_THROW_SCOPE(vm);
1201 
1202     if (!isUndefinedOrNull())
1203         return true;
1204     throwException(exec, scope, createNotAnObjectError(exec, *this));
1205     return false;
1206 }
1207 
1208 ALWAYS_INLINE bool isThisValueAltered(const PutPropertySlot&amp; slot, JSObject* baseObject)
1209 {
1210     JSValue thisValue = slot.thisValue();
1211     if (LIKELY(thisValue == baseObject))
1212         return false;
1213 
1214     if (!thisValue.isObject())
1215         return true;
1216     JSObject* thisObject = asObject(thisValue);
1217     // Only PureForwardingProxyType can be seen as the same to the original target object.
1218     if (thisObject-&gt;type() == PureForwardingProxyType &amp;&amp; jsCast&lt;JSProxy*&gt;(thisObject)-&gt;target() == baseObject)
1219         return false;
1220     return true;
1221 }
1222 
1223 // See section 7.2.9: https://tc39.github.io/ecma262/#sec-samevalue
1224 ALWAYS_INLINE bool sameValue(ExecState* exec, JSValue a, JSValue b)
1225 {
1226     if (!a.isNumber())
1227         return JSValue::strictEqual(exec, a, b);
1228     if (!b.isNumber())
1229         return false;
1230     double x = a.asNumber();
1231     double y = b.asNumber();
1232     bool xIsNaN = std::isnan(x);
1233     bool yIsNaN = std::isnan(y);
1234     if (xIsNaN || yIsNaN)
1235         return xIsNaN &amp;&amp; yIsNaN;
1236     return bitwise_cast&lt;uint64_t&gt;(x) == bitwise_cast&lt;uint64_t&gt;(y);
1237 }
1238 
1239 } // namespace JSC
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>