<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderDeprecatedFlexibleBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderElement.h&quot;
  27 
  28 #include &quot;AXObjectCache.h&quot;



  29 #include &quot;ContentData.h&quot;
  30 #include &quot;CursorList.h&quot;
  31 #include &quot;ElementChildIterator.h&quot;
  32 #include &quot;EventHandler.h&quot;
  33 #include &quot;FocusController.h&quot;
  34 #include &quot;Frame.h&quot;
  35 #include &quot;FrameSelection.h&quot;
  36 #include &quot;HTMLAnchorElement.h&quot;
  37 #include &quot;HTMLBodyElement.h&quot;
  38 #include &quot;HTMLHtmlElement.h&quot;
  39 #include &quot;HTMLImageElement.h&quot;
  40 #include &quot;HTMLNames.h&quot;

  41 #include &quot;Logging.h&quot;
  42 #include &quot;Page.h&quot;
  43 #include &quot;PathUtilities.h&quot;
  44 #include &quot;RenderBlock.h&quot;
  45 #include &quot;RenderChildIterator.h&quot;
  46 #include &quot;RenderCounter.h&quot;
  47 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  48 #include &quot;RenderDescendantIterator.h&quot;
  49 #include &quot;RenderFlexibleBox.h&quot;
  50 #include &quot;RenderFragmentedFlow.h&quot;
  51 #include &quot;RenderGrid.h&quot;
  52 #include &quot;RenderImage.h&quot;
  53 #include &quot;RenderImageResourceStyleImage.h&quot;
  54 #include &quot;RenderInline.h&quot;
  55 #include &quot;RenderIterator.h&quot;
  56 #include &quot;RenderLayer.h&quot;
  57 #include &quot;RenderLayerCompositor.h&quot;
  58 #include &quot;RenderLineBreak.h&quot;
  59 #include &quot;RenderListItem.h&quot;
  60 #if !ASSERT_DISABLED
</pre>
<hr />
<pre>
 129 {
 130 }
 131 
 132 RenderElement::~RenderElement()
 133 {
 134     // Do not add any code here. Add it to willBeDestroyed() instead.
 135     ASSERT(!m_firstChild);
 136 }
 137 
 138 RenderPtr&lt;RenderElement&gt; RenderElement::createFor(Element&amp; element, RenderStyle&amp;&amp; style, RendererCreationType creationType)
 139 {
 140     // Minimal support for content properties replacing an entire element.
 141     // Works only if we have exactly one piece of content and it&#39;s a URL.
 142     // Otherwise acts as if we didn&#39;t support this feature.
 143     const ContentData* contentData = style.contentData();
 144     if (creationType == CreateAllRenderers &amp;&amp; contentData &amp;&amp; !contentData-&gt;next() &amp;&amp; is&lt;ImageContentData&gt;(*contentData) &amp;&amp; !element.isPseudoElement()) {
 145         Style::loadPendingResources(style, element.document(), &amp;element);
 146         auto&amp; styleImage = downcast&lt;ImageContentData&gt;(*contentData).image();
 147         auto image = createRenderer&lt;RenderImage&gt;(element, WTFMove(style), const_cast&lt;StyleImage*&gt;(&amp;styleImage));
 148         image-&gt;setIsGeneratedContent();
<span class="line-modified"> 149         return WTFMove(image);</span>
 150     }
 151 
 152     switch (style.display()) {
 153     case DisplayType::None:
 154     case DisplayType::Contents:
 155         return nullptr;
 156     case DisplayType::Inline:
 157         if (creationType == CreateAllRenderers)
 158             return createRenderer&lt;RenderInline&gt;(element, WTFMove(style));
 159         FALLTHROUGH; // Fieldsets should make a block flow if display:inline is set.
 160     case DisplayType::Block:

 161     case DisplayType::InlineBlock:
 162     case DisplayType::Compact:
 163         return createRenderer&lt;RenderBlockFlow&gt;(element, WTFMove(style));
 164     case DisplayType::ListItem:
 165         return createRenderer&lt;RenderListItem&gt;(element, WTFMove(style));
 166     case DisplayType::Flex:
 167     case DisplayType::InlineFlex:
 168     case DisplayType::WebKitFlex:
 169     case DisplayType::WebKitInlineFlex:
 170         return createRenderer&lt;RenderFlexibleBox&gt;(element, WTFMove(style));
 171     case DisplayType::Grid:
 172     case DisplayType::InlineGrid:
 173         return createRenderer&lt;RenderGrid&gt;(element, WTFMove(style));
 174     case DisplayType::Box:
 175     case DisplayType::InlineBox:
 176         return createRenderer&lt;RenderDeprecatedFlexibleBox&gt;(element, WTFMove(style));
 177     default: {
 178         if (creationType == OnlyCreateBlockAndFlexboxRenderers)
 179             return createRenderer&lt;RenderBlockFlow&gt;(element, WTFMove(style));
 180         switch (style.display()) {
</pre>
<hr />
<pre>
 713             document().invalidateRenderingDependentRegions();
 714 
 715         if (visibilityChanged) {
 716             if (AXObjectCache* cache = document().existingAXObjectCache())
 717                 cache-&gt;childrenChanged(parent(), this);
 718         }
 719 
 720         // Keep layer hierarchy visibility bits up to date if visibility changes.
 721         if (m_style.visibility() != newStyle.visibility()) {
 722             if (RenderLayer* layer = enclosingLayer()) {
 723                 if (newStyle.visibility() == Visibility::Visible)
 724                     layer-&gt;setHasVisibleContent();
 725                 else if (layer-&gt;hasVisibleContent() &amp;&amp; (this == &amp;layer-&gt;renderer() || layer-&gt;renderer().style().visibility() != Visibility::Visible)) {
 726                     layer-&gt;dirtyVisibleContentStatus();
 727                     if (diff &gt; StyleDifference::RepaintLayer)
 728                         repaint();
 729                 }
 730             }
 731         }
 732 
















 733         if (m_parent &amp;&amp; (newStyle.outlineSize() &lt; m_style.outlineSize() || shouldRepaintForStyleDifference(diff)))
 734             repaint();
 735 
 736         if (isFloating() &amp;&amp; m_style.floating() != newStyle.floating()) {
 737             // For changes in float styles, we need to conceivably remove ourselves
 738             // from the floating objects list.
 739             downcast&lt;RenderBox&gt;(*this).removeFloatingOrPositionedChildFromBlockLists();
 740         } else if (isOutOfFlowPositioned() &amp;&amp; m_style.position() != newStyle.position()) {
 741             // For changes in positioning styles, we need to conceivably remove ourselves
 742             // from the positioned objects list.
 743             downcast&lt;RenderBox&gt;(*this).removeFloatingOrPositionedChildFromBlockLists();
 744         }
 745 
 746         // reset style flags
 747         if (diff == StyleDifference::Layout || diff == StyleDifference::LayoutPositionedMovementOnly) {
 748             setFloating(false);
 749             clearPositionedState();
 750         }

 751         if (newStyle.hasPseudoStyle(PseudoId::FirstLine) || oldStyle-&gt;hasPseudoStyle(PseudoId::FirstLine))
 752             invalidateCachedFirstLineStyle();
 753 
 754         setHorizontalWritingMode(true);
 755         setHasVisibleBoxDecorations(false);
 756         setHasOverflowClip(false);
 757         setHasTransformRelatedProperty(false);
 758         setHasReflection(false);
 759     }
 760 









 761     bool newStyleSlowScroll = false;
 762     if (newStyle.hasFixedBackgroundImage() &amp;&amp; !settings().fixedBackgroundsPaintRelativeToDocument()) {
 763         newStyleSlowScroll = true;
 764         bool drawsRootBackground = isDocumentElementRenderer() || (isBody() &amp;&amp; !rendererHasBackground(document().documentElement()-&gt;renderer()));
 765         if (drawsRootBackground &amp;&amp; newStyle.hasEntirelyFixedBackground() &amp;&amp; view().compositor().supportsFixedRootBackgroundCompositing())
 766             newStyleSlowScroll = false;
 767     }
 768 
 769     if (view().frameView().hasSlowRepaintObject(*this)) {
 770         if (!newStyleSlowScroll)
 771             view().frameView().removeSlowRepaintObject(*this);
 772     } else if (newStyleSlowScroll)
 773         view().frameView().addSlowRepaintObject(*this);
 774 
 775     if (isDocumentElementRenderer() || isBody())
 776         view().frameView().updateExtendBackgroundIfNecessary();
 777 }
 778 
 779 #if !PLATFORM(IOS_FAMILY)
 780 static bool areNonIdenticalCursorListsEqual(const RenderStyle* a, const RenderStyle* b)
</pre>
<hr />
<pre>
 813         if (needsLayout() &amp;&amp; oldStyle-&gt;position() != m_style.position())
 814             markContainingBlocksForLayout();
 815 
 816         if (diff == StyleDifference::Layout)
 817             setNeedsLayoutAndPrefWidthsRecalc();
 818         else
 819             setNeedsSimplifiedNormalFlowLayout();
 820     } else if (diff == StyleDifference::SimplifiedLayoutAndPositionedMovement) {
 821         setNeedsPositionedMovementLayout(oldStyle);
 822         setNeedsSimplifiedNormalFlowLayout();
 823     } else if (diff == StyleDifference::LayoutPositionedMovementOnly)
 824         setNeedsPositionedMovementLayout(oldStyle);
 825 
 826     // Don&#39;t check for repaint here; we need to wait until the layer has been
 827     // updated by subclasses before we know if we have to repaint (in setStyle()).
 828 
 829 #if !PLATFORM(IOS_FAMILY)
 830     if (oldStyle &amp;&amp; !areCursorsEqual(oldStyle, &amp;style()))
 831         frame().eventHandler().scheduleCursorUpdate();
 832 #endif

 833     bool hadOutlineAuto = oldStyle &amp;&amp; oldStyle-&gt;outlineStyleIsAuto() == OutlineIsAuto::On;
 834     bool hasOutlineAuto = outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On;
 835     if (hasOutlineAuto != hadOutlineAuto) {
 836         updateOutlineAutoAncestor(hasOutlineAuto);
 837         issueRepaintForOutlineAuto(hasOutlineAuto ? outlineStyleForRepaint().outlineSize() : oldStyle-&gt;outlineSize());
 838     }
 839 }
 840 
 841 void RenderElement::insertedIntoTree()
 842 {
 843     // Keep our layer hierarchy updated. Optimize for the common case where we don&#39;t have any children
 844     // and don&#39;t have a layer attached to ourselves.
 845     RenderLayer* layer = nullptr;
 846     if (firstChild() || hasLayer()) {
 847         layer = parent()-&gt;enclosingLayer();
 848         addLayers(layer);
 849     }
 850 
 851     // If |this| is visible but this object was not, tell the layer it has some visible content
 852     // that needs to be drawn and layer visibility optimization can&#39;t be used
</pre>
<hr />
<pre>
 884 inline void RenderElement::clearSubtreeLayoutRootIfNeeded() const
 885 {
 886     if (renderTreeBeingDestroyed())
 887         return;
 888 
 889     if (view().frameView().layoutContext().subtreeLayoutRoot() != this)
 890         return;
 891 
 892     // Normally when a renderer is detached from the tree, the appropriate dirty bits get set
 893     // which ensures that this renderer is no longer the layout root.
 894     ASSERT_NOT_REACHED();
 895 
 896     // This indicates a failure to layout the child, which is why
 897     // the layout root is still set to |this|. Make sure to clear it
 898     // since we are getting destroyed.
 899     view().frameView().layoutContext().clearSubtreeLayoutRoot();
 900 }
 901 
 902 void RenderElement::willBeDestroyed()
 903 {




 904     if (m_style.hasFixedBackgroundImage() &amp;&amp; !settings().fixedBackgroundsPaintRelativeToDocument())
 905         view().frameView().removeSlowRepaintObject(*this);
 906 
 907     unregisterForVisibleInViewportCallback();
 908 
 909     if (hasCounterNodeMap())
 910         RenderCounter::destroyCounterNodes(*this);
 911 



 912     RenderObject::willBeDestroyed();
 913 
 914     clearSubtreeLayoutRootIfNeeded();
 915 
 916     if (hasInitializedStyle()) {
 917         for (auto* bgLayer = &amp;m_style.backgroundLayers(); bgLayer; bgLayer = bgLayer-&gt;next()) {
 918             if (auto* backgroundImage = bgLayer-&gt;image())
 919                 backgroundImage-&gt;removeClient(this);
 920         }
 921         for (auto* maskLayer = &amp;m_style.maskLayers(); maskLayer; maskLayer = maskLayer-&gt;next()) {
 922             if (auto* maskImage = maskLayer-&gt;image())
 923                 maskImage-&gt;removeClient(this);
 924         }
 925         if (auto* borderImage = m_style.borderImage().image())
 926             borderImage-&gt;removeClient(this);
 927         if (auto* maskBoxImage = m_style.maskBoxImage().image())
 928             maskBoxImage-&gt;removeClient(this);
 929         if (auto shapeValue = m_style.shapeOutside()) {
 930             if (auto shapeImage = shapeValue-&gt;image())
 931                 shapeImage-&gt;removeClient(this);
</pre>
<hr />
<pre>
 965     if (needsSimplifiedNormalFlowLayout())
 966         return;
 967     setNeedsSimplifiedNormalFlowLayoutBit(true);
 968     markContainingBlocksForLayout();
 969     if (hasLayer())
 970         setLayerNeedsFullRepaint();
 971 }
 972 
 973 static inline void paintPhase(RenderElement&amp; element, PaintPhase phase, PaintInfo&amp; paintInfo, const LayoutPoint&amp; childPoint)
 974 {
 975     paintInfo.phase = phase;
 976     element.paint(paintInfo, childPoint);
 977 }
 978 
 979 void RenderElement::paintAsInlineBlock(PaintInfo&amp; paintInfo, const LayoutPoint&amp; childPoint)
 980 {
 981     // Paint all phases atomically, as though the element established its own stacking context.
 982     // (See Appendix E.2, section 6.4 on inline block/table/replaced elements in the CSS2.1 specification.)
 983     // This is also used by other elements (e.g. flex items and grid items).
 984     PaintPhase paintPhaseToUse = isExcludedAndPlacedInBorder() ? paintInfo.phase : PaintPhase::Foreground;
<span class="line-modified"> 985     if (paintInfo.phase == PaintPhase::Selection)</span>
 986         paint(paintInfo, childPoint);
 987     else if (paintInfo.phase == paintPhaseToUse) {
 988         paintPhase(*this, PaintPhase::BlockBackground, paintInfo, childPoint);
 989         paintPhase(*this, PaintPhase::ChildBlockBackgrounds, paintInfo, childPoint);
 990         paintPhase(*this, PaintPhase::Float, paintInfo, childPoint);
 991         paintPhase(*this, PaintPhase::Foreground, paintInfo, childPoint);
 992         paintPhase(*this, PaintPhase::Outline, paintInfo, childPoint);
 993 
 994         // Reset |paintInfo| to the original phase.
 995         paintInfo.phase = paintPhaseToUse;
 996     }
 997 }
 998 
 999 void RenderElement::layout()
1000 {
1001     StackStats::LayoutCheckPoint layoutCheckPoint;
1002     ASSERT(needsLayout());
1003     for (auto* child = firstChild(); child; child = child-&gt;nextSibling()) {
1004         if (child-&gt;needsLayout())
1005             downcast&lt;RenderElement&gt;(*child).layout();
</pre>
<hr />
<pre>
1106         repaintUsingContainer(repaintContainer, LayoutRect(newBounds.maxX(), oldBounds.y(), -deltaRight, oldBounds.height()));
1107 
1108     LayoutUnit deltaTop = newBounds.y() - oldBounds.y();
1109     if (deltaTop &gt; 0)
1110         repaintUsingContainer(repaintContainer, LayoutRect(oldBounds.x(), oldBounds.y(), oldBounds.width(), deltaTop));
1111     else if (deltaTop &lt; 0)
1112         repaintUsingContainer(repaintContainer, LayoutRect(newBounds.x(), newBounds.y(), newBounds.width(), -deltaTop));
1113 
1114     LayoutUnit deltaBottom = newBounds.maxY() - oldBounds.maxY();
1115     if (deltaBottom &gt; 0)
1116         repaintUsingContainer(repaintContainer, LayoutRect(newBounds.x(), oldBounds.maxY(), newBounds.width(), deltaBottom));
1117     else if (deltaBottom &lt; 0)
1118         repaintUsingContainer(repaintContainer, LayoutRect(oldBounds.x(), newBounds.maxY(), oldBounds.width(), -deltaBottom));
1119 
1120     if (newOutlineBox == oldOutlineBox)
1121         return false;
1122 
1123     // We didn&#39;t move, but we did change size. Invalidate the delta, which will consist of possibly
1124     // two rectangles (but typically only one).
1125     const RenderStyle&amp; outlineStyle = outlineStyleForRepaint();
<span class="line-modified">1126     LayoutUnit outlineWidth = outlineStyle.outlineSize();</span>
1127     LayoutBoxExtent insetShadowExtent = style().getBoxShadowInsetExtent();
1128     LayoutUnit width = absoluteValue(newOutlineBox.width() - oldOutlineBox.width());
1129     if (width) {
1130         LayoutUnit shadowLeft;
1131         LayoutUnit shadowRight;
1132         style().getBoxShadowHorizontalExtent(shadowLeft, shadowRight);
1133         LayoutUnit borderRight = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).borderRight() : 0_lu;
1134         LayoutUnit boxWidth = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).width() : 0_lu;
1135         LayoutUnit minInsetRightShadowExtent = std::min&lt;LayoutUnit&gt;(-insetShadowExtent.right(), std::min(newBounds.width(), oldBounds.width()));
1136         LayoutUnit borderWidth = std::max(borderRight, std::max(valueForLength(style().borderTopRightRadius().width, boxWidth), valueForLength(style().borderBottomRightRadius().width, boxWidth)));
<span class="line-modified">1137         LayoutUnit decorationsWidth = std::max&lt;LayoutUnit&gt;(-outlineStyle.outlineOffset(), borderWidth + minInsetRightShadowExtent) + std::max(outlineWidth, shadowRight);</span>
1138         LayoutRect rightRect(newOutlineBox.x() + std::min(newOutlineBox.width(), oldOutlineBox.width()) - decorationsWidth,
1139             newOutlineBox.y(),
1140             width + decorationsWidth,
1141             std::max(newOutlineBox.height(), oldOutlineBox.height()));
1142         LayoutUnit right = std::min(newBounds.maxX(), oldBounds.maxX());
1143         if (rightRect.x() &lt; right) {
1144             rightRect.setWidth(std::min(rightRect.width(), right - rightRect.x()));
1145             repaintUsingContainer(repaintContainer, rightRect);
1146         }
1147     }
1148     LayoutUnit height = absoluteValue(newOutlineBox.height() - oldOutlineBox.height());
1149     if (height) {
1150         LayoutUnit shadowTop;
1151         LayoutUnit shadowBottom;
1152         style().getBoxShadowVerticalExtent(shadowTop, shadowBottom);
1153         LayoutUnit borderBottom = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).borderBottom() : 0_lu;
1154         LayoutUnit boxHeight = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).height() : 0_lu;
1155         LayoutUnit minInsetBottomShadowExtent = std::min&lt;LayoutUnit&gt;(-insetShadowExtent.bottom(), std::min(newBounds.height(), oldBounds.height()));
1156         LayoutUnit borderHeight = std::max(borderBottom, std::max(valueForLength(style().borderBottomLeftRadius().height, boxHeight),
1157             valueForLength(style().borderBottomRightRadius().height, boxHeight)));
<span class="line-modified">1158         LayoutUnit decorationsHeight = std::max&lt;LayoutUnit&gt;(-outlineStyle.outlineOffset(), borderHeight + minInsetBottomShadowExtent) + std::max(outlineWidth, shadowBottom);</span>
1159         LayoutRect bottomRect(newOutlineBox.x(),
1160             std::min(newOutlineBox.maxY(), oldOutlineBox.maxY()) - decorationsHeight,
1161             std::max(newOutlineBox.width(), oldOutlineBox.width()),
1162             height + decorationsHeight);
1163         LayoutUnit bottom = std::min(newBounds.maxY(), oldBounds.maxY());
1164         if (bottomRect.y() &lt; bottom) {
1165             bottomRect.setHeight(std::min(bottomRect.height(), bottom - bottomRect.y()));
1166             repaintUsingContainer(repaintContainer, bottomRect);
1167         }
1168     }
1169     return false;
1170 }
1171 
1172 bool RenderElement::borderImageIsLoadedAndCanBeRendered() const
1173 {
1174     ASSERT(style().hasBorder());
1175 
1176     StyleImage* borderImage = style().borderImage().image();
1177     return borderImage &amp;&amp; borderImage-&gt;canRender(this, style().effectiveZoom()) &amp;&amp; borderImage-&gt;isLoaded();
1178 }
</pre>
<hr />
<pre>
1602         graphicsContext.drawLine(roundPointToDevicePixels(LayoutPoint(x1, y1), deviceScaleFactor), roundPointToDevicePixels(LayoutPoint(x2, y2), deviceScaleFactor));
1603         graphicsContext.setShouldAntialias(wasAntialiased);
1604         graphicsContext.setStrokeStyle(oldStrokeStyle);
1605         break;
1606     }
1607     case BorderStyle::Double: {
1608         float thirdOfThickness = ceilToDevicePixel(thickness / 3, deviceScaleFactor);
1609         ASSERT(thirdOfThickness);
1610 
1611         if (!adjacentWidth1 &amp;&amp; !adjacentWidth2) {
1612             StrokeStyle oldStrokeStyle = graphicsContext.strokeStyle();
1613             graphicsContext.setStrokeStyle(NoStroke);
1614             graphicsContext.setFillColor(color);
1615 
1616             bool wasAntialiased = graphicsContext.shouldAntialias();
1617             graphicsContext.setShouldAntialias(antialias);
1618 
1619             switch (side) {
1620             case BSTop:
1621             case BSBottom:
<span class="line-modified">1622                 drawBorderRect(snapRectToDevicePixels(x1, y1, length, thirdOfThickness, deviceScaleFactor));</span>
<span class="line-modified">1623                 drawBorderRect(snapRectToDevicePixels(x1, y2 - thirdOfThickness, length, thirdOfThickness, deviceScaleFactor));</span>
1624                 break;
1625             case BSLeft:
1626             case BSRight:
<span class="line-modified">1627                 drawBorderRect(snapRectToDevicePixels(x1, y1, thirdOfThickness, length, deviceScaleFactor));</span>
<span class="line-modified">1628                 drawBorderRect(snapRectToDevicePixels(x2 - thirdOfThickness, y1, thirdOfThickness, length, deviceScaleFactor));</span>
1629                 break;
1630             }
1631 
1632             graphicsContext.setShouldAntialias(wasAntialiased);
1633             graphicsContext.setStrokeStyle(oldStrokeStyle);
1634         } else {
1635             float adjacent1BigThird = ceilToDevicePixel(adjacentWidth1 / 3, deviceScaleFactor);
1636             float adjacent2BigThird = ceilToDevicePixel(adjacentWidth2 / 3, deviceScaleFactor);
1637 
1638             float offset1 = floorToDevicePixel(fabs(adjacentWidth1) * 2 / 3, deviceScaleFactor);
1639             float offset2 = floorToDevicePixel(fabs(adjacentWidth2) * 2 / 3, deviceScaleFactor);
1640 
1641             float mitreOffset1 = adjacentWidth1 &lt; 0 ? offset1 : 0;
1642             float mitreOffset2 = adjacentWidth1 &gt; 0 ? offset1 : 0;
1643             float mitreOffset3 = adjacentWidth2 &lt; 0 ? offset2 : 0;
1644             float mitreOffset4 = adjacentWidth2 &gt; 0 ? offset2 : 0;
1645 
1646             FloatRect paintBorderRect;
1647             switch (side) {
1648             case BSTop:
</pre>
<hr />
<pre>
1738         case BSRight:
1739             drawLineFor(FloatRect(FloatPoint(x1, y1 + offset1), FloatPoint(adjustedX, y2 - offset2)), side, s2, FloatSize(adjacent1BigHalf, adjacent2BigHalf));
1740             drawLineFor(FloatRect(FloatPoint(adjustedX, y1 + offset3), FloatPoint(x2, y2 - offset4)), side, s1, FloatSize(adjacent1SmallHalf, adjacent2SmallHalf));
1741             break;
1742         }
1743         break;
1744     }
1745     case BorderStyle::Inset:
1746     case BorderStyle::Outset:
1747         calculateBorderStyleColor(borderStyle, side, color);
1748         FALLTHROUGH;
1749     case BorderStyle::Solid: {
1750         StrokeStyle oldStrokeStyle = graphicsContext.strokeStyle();
1751         ASSERT(x2 &gt;= x1);
1752         ASSERT(y2 &gt;= y1);
1753         if (!adjacentWidth1 &amp;&amp; !adjacentWidth2) {
1754             graphicsContext.setStrokeStyle(NoStroke);
1755             graphicsContext.setFillColor(color);
1756             bool wasAntialiased = graphicsContext.shouldAntialias();
1757             graphicsContext.setShouldAntialias(antialias);
<span class="line-modified">1758             drawBorderRect(snapRectToDevicePixels(x1, y1, x2 - x1, y2 - y1, deviceScaleFactor));</span>
1759             graphicsContext.setShouldAntialias(wasAntialiased);
1760             graphicsContext.setStrokeStyle(oldStrokeStyle);
1761             return;
1762         }
1763 
1764         // FIXME: These roundings should be replaced by ASSERT(device pixel positioned) when all the callers have transitioned to device pixels.
1765         x1 = roundToDevicePixel(x1, deviceScaleFactor);
1766         y1 = roundToDevicePixel(y1, deviceScaleFactor);
1767         x2 = roundToDevicePixel(x2, deviceScaleFactor);
1768         y2 = roundToDevicePixel(y2, deviceScaleFactor);
1769 
1770         Vector&lt;FloatPoint&gt; quad;
1771         quad.reserveInitialCapacity(4);
1772         switch (side) {
1773         case BSTop:
1774             quad.uncheckedAppend({ x1 + std::max&lt;float&gt;(-adjacentWidth1, 0), y1 });
1775             quad.uncheckedAppend({ x1 + std::max&lt;float&gt;( adjacentWidth1, 0), y2 });
1776             quad.uncheckedAppend({ x2 - std::max&lt;float&gt;( adjacentWidth2, 0), y2 });
1777             quad.uncheckedAppend({ x2 - std::max&lt;float&gt;(-adjacentWidth2, 0), y1 });
1778             break;
</pre>
<hr />
<pre>
1879     if (needsRepaint)
1880         page().focusController().setFocusedElementNeedsRepaint();
1881 }
1882 
1883 void RenderElement::paintOutline(PaintInfo&amp; paintInfo, const LayoutRect&amp; paintRect)
1884 {
1885     GraphicsContext&amp; graphicsContext = paintInfo.context();
1886     if (graphicsContext.paintingDisabled())
1887         return;
1888 
1889     if (!hasOutline())
1890         return;
1891 
1892     auto&amp; styleToUse = style();
1893     float outlineWidth = floorToDevicePixel(styleToUse.outlineWidth(), document().deviceScaleFactor());
1894     float outlineOffset = floorToDevicePixel(styleToUse.outlineOffset(), document().deviceScaleFactor());
1895 
1896     // Only paint the focus ring by hand if the theme isn&#39;t able to draw it.
1897     if (styleToUse.outlineStyleIsAuto() == OutlineIsAuto::On &amp;&amp; !theme().supportsFocusRing(styleToUse)) {
1898         Vector&lt;LayoutRect&gt; focusRingRects;
<span class="line-modified">1899         addFocusRingRects(focusRingRects, paintRect.location(), paintInfo.paintContainer);</span>










1900         paintFocusRing(paintInfo, styleToUse, focusRingRects);
1901     }
1902 
1903     if (hasOutlineAnnotation() &amp;&amp; styleToUse.outlineStyleIsAuto() == OutlineIsAuto::Off &amp;&amp; !theme().supportsFocusRing(styleToUse))
1904         addPDFURLRect(paintInfo, paintRect.location());
1905 
1906     if (styleToUse.outlineStyleIsAuto() == OutlineIsAuto::On || styleToUse.outlineStyle() == BorderStyle::None)
1907         return;
1908 
1909     FloatRect outer = paintRect;
1910     outer.inflate(outlineOffset + outlineWidth);
1911     FloatRect inner = outer;
1912     inner.inflate(-outlineWidth);
1913 
1914     // FIXME: This prevents outlines from painting inside the object. See bug 12042
1915     if (outer.isEmpty())
1916         return;
1917 
1918     BorderStyle outlineStyle = styleToUse.outlineStyle();
1919     Color outlineColor = styleToUse.visitedDependentColorWithColorFilter(CSSPropertyOutlineColor);
</pre>
<hr />
<pre>
1985 bool RenderElement::hasOutlineAnnotation() const
1986 {
1987     return element() &amp;&amp; element()-&gt;isLink() &amp;&amp; document().printing();
1988 }
1989 
1990 bool RenderElement::hasSelfPaintingLayer() const
1991 {
1992     if (!hasLayer())
1993         return false;
1994     auto&amp; layerModelObject = downcast&lt;RenderLayerModelObject&gt;(*this);
1995     return layerModelObject.hasSelfPaintingLayer();
1996 }
1997 
1998 bool RenderElement::checkForRepaintDuringLayout() const
1999 {
2000     if (document().view()-&gt;layoutContext().needsFullRepaint() || !everHadLayout() || hasSelfPaintingLayer())
2001         return false;
2002     return !settings().repaintOutsideLayoutEnabled();
2003 }
2004 
<span class="line-modified">2005 RespectImageOrientationEnum RenderElement::shouldRespectImageOrientation() const</span>
2006 {
<span class="line-modified">2007 #if USE(CG) || USE(CAIRO)</span>
2008     // This can only be enabled for ports which honor the orientation flag in their drawing code.
2009     if (document().isImageDocument())
<span class="line-modified">2010         return RespectImageOrientation;</span>
2011 #endif
2012     // Respect the image&#39;s orientation if it&#39;s being used as a full-page image or it&#39;s
2013     // an &lt;img&gt; and the setting to respect it everywhere is set.
<span class="line-modified">2014     return settings().shouldRespectImageOrientation() &amp;&amp; is&lt;HTMLImageElement&gt;(element()) ? RespectImageOrientation : DoNotRespectImageOrientation;</span>


2015 }
2016 
2017 void RenderElement::adjustFragmentedFlowStateOnContainingBlockChangeIfNeeded()
2018 {
2019     if (fragmentedFlowState() == NotInsideFragmentedFlow)
2020         return;
2021 
2022     // Invalidate the containing block caches.
2023     if (is&lt;RenderBlock&gt;(*this))
2024         downcast&lt;RenderBlock&gt;(*this).resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants();
2025 
2026     // Adjust the flow tread state on the subtree.
2027     setFragmentedFlowState(RenderObject::computedFragmentedFlowState(*this));
2028     for (auto&amp; descendant : descendantsOfType&lt;RenderObject&gt;(*this))
2029         descendant.setFragmentedFlowState(RenderObject::computedFragmentedFlowState(descendant));
2030 }
2031 
2032 void RenderElement::removeFromRenderFragmentedFlow()
2033 {
2034     ASSERT(fragmentedFlowState() != NotInsideFragmentedFlow);
</pre>
</td>
<td>
<hr />
<pre>
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderElement.h&quot;
  27 
  28 #include &quot;AXObjectCache.h&quot;
<span class="line-added">  29 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">  30 #include &quot;ContentChangeObserver.h&quot;</span>
<span class="line-added">  31 #endif</span>
  32 #include &quot;ContentData.h&quot;
  33 #include &quot;CursorList.h&quot;
  34 #include &quot;ElementChildIterator.h&quot;
  35 #include &quot;EventHandler.h&quot;
  36 #include &quot;FocusController.h&quot;
  37 #include &quot;Frame.h&quot;
  38 #include &quot;FrameSelection.h&quot;
  39 #include &quot;HTMLAnchorElement.h&quot;
  40 #include &quot;HTMLBodyElement.h&quot;
  41 #include &quot;HTMLHtmlElement.h&quot;
  42 #include &quot;HTMLImageElement.h&quot;
  43 #include &quot;HTMLNames.h&quot;
<span class="line-added">  44 #include &quot;LengthFunctions.h&quot;</span>
  45 #include &quot;Logging.h&quot;
  46 #include &quot;Page.h&quot;
  47 #include &quot;PathUtilities.h&quot;
  48 #include &quot;RenderBlock.h&quot;
  49 #include &quot;RenderChildIterator.h&quot;
  50 #include &quot;RenderCounter.h&quot;
  51 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  52 #include &quot;RenderDescendantIterator.h&quot;
  53 #include &quot;RenderFlexibleBox.h&quot;
  54 #include &quot;RenderFragmentedFlow.h&quot;
  55 #include &quot;RenderGrid.h&quot;
  56 #include &quot;RenderImage.h&quot;
  57 #include &quot;RenderImageResourceStyleImage.h&quot;
  58 #include &quot;RenderInline.h&quot;
  59 #include &quot;RenderIterator.h&quot;
  60 #include &quot;RenderLayer.h&quot;
  61 #include &quot;RenderLayerCompositor.h&quot;
  62 #include &quot;RenderLineBreak.h&quot;
  63 #include &quot;RenderListItem.h&quot;
  64 #if !ASSERT_DISABLED
</pre>
<hr />
<pre>
 133 {
 134 }
 135 
 136 RenderElement::~RenderElement()
 137 {
 138     // Do not add any code here. Add it to willBeDestroyed() instead.
 139     ASSERT(!m_firstChild);
 140 }
 141 
 142 RenderPtr&lt;RenderElement&gt; RenderElement::createFor(Element&amp; element, RenderStyle&amp;&amp; style, RendererCreationType creationType)
 143 {
 144     // Minimal support for content properties replacing an entire element.
 145     // Works only if we have exactly one piece of content and it&#39;s a URL.
 146     // Otherwise acts as if we didn&#39;t support this feature.
 147     const ContentData* contentData = style.contentData();
 148     if (creationType == CreateAllRenderers &amp;&amp; contentData &amp;&amp; !contentData-&gt;next() &amp;&amp; is&lt;ImageContentData&gt;(*contentData) &amp;&amp; !element.isPseudoElement()) {
 149         Style::loadPendingResources(style, element.document(), &amp;element);
 150         auto&amp; styleImage = downcast&lt;ImageContentData&gt;(*contentData).image();
 151         auto image = createRenderer&lt;RenderImage&gt;(element, WTFMove(style), const_cast&lt;StyleImage*&gt;(&amp;styleImage));
 152         image-&gt;setIsGeneratedContent();
<span class="line-modified"> 153         return image;</span>
 154     }
 155 
 156     switch (style.display()) {
 157     case DisplayType::None:
 158     case DisplayType::Contents:
 159         return nullptr;
 160     case DisplayType::Inline:
 161         if (creationType == CreateAllRenderers)
 162             return createRenderer&lt;RenderInline&gt;(element, WTFMove(style));
 163         FALLTHROUGH; // Fieldsets should make a block flow if display:inline is set.
 164     case DisplayType::Block:
<span class="line-added"> 165     case DisplayType::FlowRoot:</span>
 166     case DisplayType::InlineBlock:
 167     case DisplayType::Compact:
 168         return createRenderer&lt;RenderBlockFlow&gt;(element, WTFMove(style));
 169     case DisplayType::ListItem:
 170         return createRenderer&lt;RenderListItem&gt;(element, WTFMove(style));
 171     case DisplayType::Flex:
 172     case DisplayType::InlineFlex:
 173     case DisplayType::WebKitFlex:
 174     case DisplayType::WebKitInlineFlex:
 175         return createRenderer&lt;RenderFlexibleBox&gt;(element, WTFMove(style));
 176     case DisplayType::Grid:
 177     case DisplayType::InlineGrid:
 178         return createRenderer&lt;RenderGrid&gt;(element, WTFMove(style));
 179     case DisplayType::Box:
 180     case DisplayType::InlineBox:
 181         return createRenderer&lt;RenderDeprecatedFlexibleBox&gt;(element, WTFMove(style));
 182     default: {
 183         if (creationType == OnlyCreateBlockAndFlexboxRenderers)
 184             return createRenderer&lt;RenderBlockFlow&gt;(element, WTFMove(style));
 185         switch (style.display()) {
</pre>
<hr />
<pre>
 718             document().invalidateRenderingDependentRegions();
 719 
 720         if (visibilityChanged) {
 721             if (AXObjectCache* cache = document().existingAXObjectCache())
 722                 cache-&gt;childrenChanged(parent(), this);
 723         }
 724 
 725         // Keep layer hierarchy visibility bits up to date if visibility changes.
 726         if (m_style.visibility() != newStyle.visibility()) {
 727             if (RenderLayer* layer = enclosingLayer()) {
 728                 if (newStyle.visibility() == Visibility::Visible)
 729                     layer-&gt;setHasVisibleContent();
 730                 else if (layer-&gt;hasVisibleContent() &amp;&amp; (this == &amp;layer-&gt;renderer() || layer-&gt;renderer().style().visibility() != Visibility::Visible)) {
 731                     layer-&gt;dirtyVisibleContentStatus();
 732                     if (diff &gt; StyleDifference::RepaintLayer)
 733                         repaint();
 734                 }
 735             }
 736         }
 737 
<span class="line-added"> 738         auto needsInvalidateEventRegion = [&amp;] {</span>
<span class="line-added"> 739             if (m_style.pointerEvents() != newStyle.pointerEvents())</span>
<span class="line-added"> 740                 return true;</span>
<span class="line-added"> 741 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added"> 742             if (m_style.effectiveTouchActions() != newStyle.effectiveTouchActions())</span>
<span class="line-added"> 743                 return true;</span>
<span class="line-added"> 744 #endif</span>
<span class="line-added"> 745             return false;</span>
<span class="line-added"> 746         };</span>
<span class="line-added"> 747 </span>
<span class="line-added"> 748         if (needsInvalidateEventRegion()) {</span>
<span class="line-added"> 749             // Usually the event region gets updated as a result of paint invalidation. Here we need to request an update explicitly.</span>
<span class="line-added"> 750             if (auto* layer = enclosingLayer())</span>
<span class="line-added"> 751                 layer-&gt;invalidateEventRegion();</span>
<span class="line-added"> 752         }</span>
<span class="line-added"> 753 </span>
 754         if (m_parent &amp;&amp; (newStyle.outlineSize() &lt; m_style.outlineSize() || shouldRepaintForStyleDifference(diff)))
 755             repaint();
 756 
 757         if (isFloating() &amp;&amp; m_style.floating() != newStyle.floating()) {
 758             // For changes in float styles, we need to conceivably remove ourselves
 759             // from the floating objects list.
 760             downcast&lt;RenderBox&gt;(*this).removeFloatingOrPositionedChildFromBlockLists();
 761         } else if (isOutOfFlowPositioned() &amp;&amp; m_style.position() != newStyle.position()) {
 762             // For changes in positioning styles, we need to conceivably remove ourselves
 763             // from the positioned objects list.
 764             downcast&lt;RenderBox&gt;(*this).removeFloatingOrPositionedChildFromBlockLists();
 765         }
 766 
 767         // reset style flags
 768         if (diff == StyleDifference::Layout || diff == StyleDifference::LayoutPositionedMovementOnly) {
 769             setFloating(false);
 770             clearPositionedState();
 771         }
<span class="line-added"> 772 </span>
 773         if (newStyle.hasPseudoStyle(PseudoId::FirstLine) || oldStyle-&gt;hasPseudoStyle(PseudoId::FirstLine))
 774             invalidateCachedFirstLineStyle();
 775 
 776         setHorizontalWritingMode(true);
 777         setHasVisibleBoxDecorations(false);
 778         setHasOverflowClip(false);
 779         setHasTransformRelatedProperty(false);
 780         setHasReflection(false);
 781     }
 782 
<span class="line-added"> 783     bool hadOutline = oldStyle &amp;&amp; oldStyle-&gt;hasOutline();</span>
<span class="line-added"> 784     bool hasOutline = newStyle.hasOutline();</span>
<span class="line-added"> 785     if (hadOutline != hasOutline) {</span>
<span class="line-added"> 786         if (hasOutline)</span>
<span class="line-added"> 787             view().incrementRendersWithOutline();</span>
<span class="line-added"> 788         else</span>
<span class="line-added"> 789             view().decrementRendersWithOutline();</span>
<span class="line-added"> 790     }</span>
<span class="line-added"> 791 </span>
 792     bool newStyleSlowScroll = false;
 793     if (newStyle.hasFixedBackgroundImage() &amp;&amp; !settings().fixedBackgroundsPaintRelativeToDocument()) {
 794         newStyleSlowScroll = true;
 795         bool drawsRootBackground = isDocumentElementRenderer() || (isBody() &amp;&amp; !rendererHasBackground(document().documentElement()-&gt;renderer()));
 796         if (drawsRootBackground &amp;&amp; newStyle.hasEntirelyFixedBackground() &amp;&amp; view().compositor().supportsFixedRootBackgroundCompositing())
 797             newStyleSlowScroll = false;
 798     }
 799 
 800     if (view().frameView().hasSlowRepaintObject(*this)) {
 801         if (!newStyleSlowScroll)
 802             view().frameView().removeSlowRepaintObject(*this);
 803     } else if (newStyleSlowScroll)
 804         view().frameView().addSlowRepaintObject(*this);
 805 
 806     if (isDocumentElementRenderer() || isBody())
 807         view().frameView().updateExtendBackgroundIfNecessary();
 808 }
 809 
 810 #if !PLATFORM(IOS_FAMILY)
 811 static bool areNonIdenticalCursorListsEqual(const RenderStyle* a, const RenderStyle* b)
</pre>
<hr />
<pre>
 844         if (needsLayout() &amp;&amp; oldStyle-&gt;position() != m_style.position())
 845             markContainingBlocksForLayout();
 846 
 847         if (diff == StyleDifference::Layout)
 848             setNeedsLayoutAndPrefWidthsRecalc();
 849         else
 850             setNeedsSimplifiedNormalFlowLayout();
 851     } else if (diff == StyleDifference::SimplifiedLayoutAndPositionedMovement) {
 852         setNeedsPositionedMovementLayout(oldStyle);
 853         setNeedsSimplifiedNormalFlowLayout();
 854     } else if (diff == StyleDifference::LayoutPositionedMovementOnly)
 855         setNeedsPositionedMovementLayout(oldStyle);
 856 
 857     // Don&#39;t check for repaint here; we need to wait until the layer has been
 858     // updated by subclasses before we know if we have to repaint (in setStyle()).
 859 
 860 #if !PLATFORM(IOS_FAMILY)
 861     if (oldStyle &amp;&amp; !areCursorsEqual(oldStyle, &amp;style()))
 862         frame().eventHandler().scheduleCursorUpdate();
 863 #endif
<span class="line-added"> 864 </span>
 865     bool hadOutlineAuto = oldStyle &amp;&amp; oldStyle-&gt;outlineStyleIsAuto() == OutlineIsAuto::On;
 866     bool hasOutlineAuto = outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On;
 867     if (hasOutlineAuto != hadOutlineAuto) {
 868         updateOutlineAutoAncestor(hasOutlineAuto);
 869         issueRepaintForOutlineAuto(hasOutlineAuto ? outlineStyleForRepaint().outlineSize() : oldStyle-&gt;outlineSize());
 870     }
 871 }
 872 
 873 void RenderElement::insertedIntoTree()
 874 {
 875     // Keep our layer hierarchy updated. Optimize for the common case where we don&#39;t have any children
 876     // and don&#39;t have a layer attached to ourselves.
 877     RenderLayer* layer = nullptr;
 878     if (firstChild() || hasLayer()) {
 879         layer = parent()-&gt;enclosingLayer();
 880         addLayers(layer);
 881     }
 882 
 883     // If |this| is visible but this object was not, tell the layer it has some visible content
 884     // that needs to be drawn and layer visibility optimization can&#39;t be used
</pre>
<hr />
<pre>
 916 inline void RenderElement::clearSubtreeLayoutRootIfNeeded() const
 917 {
 918     if (renderTreeBeingDestroyed())
 919         return;
 920 
 921     if (view().frameView().layoutContext().subtreeLayoutRoot() != this)
 922         return;
 923 
 924     // Normally when a renderer is detached from the tree, the appropriate dirty bits get set
 925     // which ensures that this renderer is no longer the layout root.
 926     ASSERT_NOT_REACHED();
 927 
 928     // This indicates a failure to layout the child, which is why
 929     // the layout root is still set to |this|. Make sure to clear it
 930     // since we are getting destroyed.
 931     view().frameView().layoutContext().clearSubtreeLayoutRoot();
 932 }
 933 
 934 void RenderElement::willBeDestroyed()
 935 {
<span class="line-added"> 936 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added"> 937     if (!renderTreeBeingDestroyed() &amp;&amp; element())</span>
<span class="line-added"> 938         document().contentChangeObserver().rendererWillBeDestroyed(*element());</span>
<span class="line-added"> 939 #endif</span>
 940     if (m_style.hasFixedBackgroundImage() &amp;&amp; !settings().fixedBackgroundsPaintRelativeToDocument())
 941         view().frameView().removeSlowRepaintObject(*this);
 942 
 943     unregisterForVisibleInViewportCallback();
 944 
 945     if (hasCounterNodeMap())
 946         RenderCounter::destroyCounterNodes(*this);
 947 
<span class="line-added"> 948     if (style().hasOutline())</span>
<span class="line-added"> 949         view().decrementRendersWithOutline();</span>
<span class="line-added"> 950 </span>
 951     RenderObject::willBeDestroyed();
 952 
 953     clearSubtreeLayoutRootIfNeeded();
 954 
 955     if (hasInitializedStyle()) {
 956         for (auto* bgLayer = &amp;m_style.backgroundLayers(); bgLayer; bgLayer = bgLayer-&gt;next()) {
 957             if (auto* backgroundImage = bgLayer-&gt;image())
 958                 backgroundImage-&gt;removeClient(this);
 959         }
 960         for (auto* maskLayer = &amp;m_style.maskLayers(); maskLayer; maskLayer = maskLayer-&gt;next()) {
 961             if (auto* maskImage = maskLayer-&gt;image())
 962                 maskImage-&gt;removeClient(this);
 963         }
 964         if (auto* borderImage = m_style.borderImage().image())
 965             borderImage-&gt;removeClient(this);
 966         if (auto* maskBoxImage = m_style.maskBoxImage().image())
 967             maskBoxImage-&gt;removeClient(this);
 968         if (auto shapeValue = m_style.shapeOutside()) {
 969             if (auto shapeImage = shapeValue-&gt;image())
 970                 shapeImage-&gt;removeClient(this);
</pre>
<hr />
<pre>
1004     if (needsSimplifiedNormalFlowLayout())
1005         return;
1006     setNeedsSimplifiedNormalFlowLayoutBit(true);
1007     markContainingBlocksForLayout();
1008     if (hasLayer())
1009         setLayerNeedsFullRepaint();
1010 }
1011 
1012 static inline void paintPhase(RenderElement&amp; element, PaintPhase phase, PaintInfo&amp; paintInfo, const LayoutPoint&amp; childPoint)
1013 {
1014     paintInfo.phase = phase;
1015     element.paint(paintInfo, childPoint);
1016 }
1017 
1018 void RenderElement::paintAsInlineBlock(PaintInfo&amp; paintInfo, const LayoutPoint&amp; childPoint)
1019 {
1020     // Paint all phases atomically, as though the element established its own stacking context.
1021     // (See Appendix E.2, section 6.4 on inline block/table/replaced elements in the CSS2.1 specification.)
1022     // This is also used by other elements (e.g. flex items and grid items).
1023     PaintPhase paintPhaseToUse = isExcludedAndPlacedInBorder() ? paintInfo.phase : PaintPhase::Foreground;
<span class="line-modified">1024     if (paintInfo.phase == PaintPhase::Selection || paintInfo.phase == PaintPhase::EventRegion)</span>
1025         paint(paintInfo, childPoint);
1026     else if (paintInfo.phase == paintPhaseToUse) {
1027         paintPhase(*this, PaintPhase::BlockBackground, paintInfo, childPoint);
1028         paintPhase(*this, PaintPhase::ChildBlockBackgrounds, paintInfo, childPoint);
1029         paintPhase(*this, PaintPhase::Float, paintInfo, childPoint);
1030         paintPhase(*this, PaintPhase::Foreground, paintInfo, childPoint);
1031         paintPhase(*this, PaintPhase::Outline, paintInfo, childPoint);
1032 
1033         // Reset |paintInfo| to the original phase.
1034         paintInfo.phase = paintPhaseToUse;
1035     }
1036 }
1037 
1038 void RenderElement::layout()
1039 {
1040     StackStats::LayoutCheckPoint layoutCheckPoint;
1041     ASSERT(needsLayout());
1042     for (auto* child = firstChild(); child; child = child-&gt;nextSibling()) {
1043         if (child-&gt;needsLayout())
1044             downcast&lt;RenderElement&gt;(*child).layout();
</pre>
<hr />
<pre>
1145         repaintUsingContainer(repaintContainer, LayoutRect(newBounds.maxX(), oldBounds.y(), -deltaRight, oldBounds.height()));
1146 
1147     LayoutUnit deltaTop = newBounds.y() - oldBounds.y();
1148     if (deltaTop &gt; 0)
1149         repaintUsingContainer(repaintContainer, LayoutRect(oldBounds.x(), oldBounds.y(), oldBounds.width(), deltaTop));
1150     else if (deltaTop &lt; 0)
1151         repaintUsingContainer(repaintContainer, LayoutRect(newBounds.x(), newBounds.y(), newBounds.width(), -deltaTop));
1152 
1153     LayoutUnit deltaBottom = newBounds.maxY() - oldBounds.maxY();
1154     if (deltaBottom &gt; 0)
1155         repaintUsingContainer(repaintContainer, LayoutRect(newBounds.x(), oldBounds.maxY(), newBounds.width(), deltaBottom));
1156     else if (deltaBottom &lt; 0)
1157         repaintUsingContainer(repaintContainer, LayoutRect(oldBounds.x(), newBounds.maxY(), oldBounds.width(), -deltaBottom));
1158 
1159     if (newOutlineBox == oldOutlineBox)
1160         return false;
1161 
1162     // We didn&#39;t move, but we did change size. Invalidate the delta, which will consist of possibly
1163     // two rectangles (but typically only one).
1164     const RenderStyle&amp; outlineStyle = outlineStyleForRepaint();
<span class="line-modified">1165     LayoutUnit outlineWidth { outlineStyle.outlineSize() };</span>
1166     LayoutBoxExtent insetShadowExtent = style().getBoxShadowInsetExtent();
1167     LayoutUnit width = absoluteValue(newOutlineBox.width() - oldOutlineBox.width());
1168     if (width) {
1169         LayoutUnit shadowLeft;
1170         LayoutUnit shadowRight;
1171         style().getBoxShadowHorizontalExtent(shadowLeft, shadowRight);
1172         LayoutUnit borderRight = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).borderRight() : 0_lu;
1173         LayoutUnit boxWidth = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).width() : 0_lu;
1174         LayoutUnit minInsetRightShadowExtent = std::min&lt;LayoutUnit&gt;(-insetShadowExtent.right(), std::min(newBounds.width(), oldBounds.width()));
1175         LayoutUnit borderWidth = std::max(borderRight, std::max(valueForLength(style().borderTopRightRadius().width, boxWidth), valueForLength(style().borderBottomRightRadius().width, boxWidth)));
<span class="line-modified">1176         LayoutUnit decorationsWidth = std::max(LayoutUnit(-outlineStyle.outlineOffset()), borderWidth + minInsetRightShadowExtent) + std::max(outlineWidth, shadowRight);</span>
1177         LayoutRect rightRect(newOutlineBox.x() + std::min(newOutlineBox.width(), oldOutlineBox.width()) - decorationsWidth,
1178             newOutlineBox.y(),
1179             width + decorationsWidth,
1180             std::max(newOutlineBox.height(), oldOutlineBox.height()));
1181         LayoutUnit right = std::min(newBounds.maxX(), oldBounds.maxX());
1182         if (rightRect.x() &lt; right) {
1183             rightRect.setWidth(std::min(rightRect.width(), right - rightRect.x()));
1184             repaintUsingContainer(repaintContainer, rightRect);
1185         }
1186     }
1187     LayoutUnit height = absoluteValue(newOutlineBox.height() - oldOutlineBox.height());
1188     if (height) {
1189         LayoutUnit shadowTop;
1190         LayoutUnit shadowBottom;
1191         style().getBoxShadowVerticalExtent(shadowTop, shadowBottom);
1192         LayoutUnit borderBottom = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).borderBottom() : 0_lu;
1193         LayoutUnit boxHeight = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).height() : 0_lu;
1194         LayoutUnit minInsetBottomShadowExtent = std::min&lt;LayoutUnit&gt;(-insetShadowExtent.bottom(), std::min(newBounds.height(), oldBounds.height()));
1195         LayoutUnit borderHeight = std::max(borderBottom, std::max(valueForLength(style().borderBottomLeftRadius().height, boxHeight),
1196             valueForLength(style().borderBottomRightRadius().height, boxHeight)));
<span class="line-modified">1197         LayoutUnit decorationsHeight = std::max(LayoutUnit(-outlineStyle.outlineOffset()), borderHeight + minInsetBottomShadowExtent) + std::max(outlineWidth, shadowBottom);</span>
1198         LayoutRect bottomRect(newOutlineBox.x(),
1199             std::min(newOutlineBox.maxY(), oldOutlineBox.maxY()) - decorationsHeight,
1200             std::max(newOutlineBox.width(), oldOutlineBox.width()),
1201             height + decorationsHeight);
1202         LayoutUnit bottom = std::min(newBounds.maxY(), oldBounds.maxY());
1203         if (bottomRect.y() &lt; bottom) {
1204             bottomRect.setHeight(std::min(bottomRect.height(), bottom - bottomRect.y()));
1205             repaintUsingContainer(repaintContainer, bottomRect);
1206         }
1207     }
1208     return false;
1209 }
1210 
1211 bool RenderElement::borderImageIsLoadedAndCanBeRendered() const
1212 {
1213     ASSERT(style().hasBorder());
1214 
1215     StyleImage* borderImage = style().borderImage().image();
1216     return borderImage &amp;&amp; borderImage-&gt;canRender(this, style().effectiveZoom()) &amp;&amp; borderImage-&gt;isLoaded();
1217 }
</pre>
<hr />
<pre>
1641         graphicsContext.drawLine(roundPointToDevicePixels(LayoutPoint(x1, y1), deviceScaleFactor), roundPointToDevicePixels(LayoutPoint(x2, y2), deviceScaleFactor));
1642         graphicsContext.setShouldAntialias(wasAntialiased);
1643         graphicsContext.setStrokeStyle(oldStrokeStyle);
1644         break;
1645     }
1646     case BorderStyle::Double: {
1647         float thirdOfThickness = ceilToDevicePixel(thickness / 3, deviceScaleFactor);
1648         ASSERT(thirdOfThickness);
1649 
1650         if (!adjacentWidth1 &amp;&amp; !adjacentWidth2) {
1651             StrokeStyle oldStrokeStyle = graphicsContext.strokeStyle();
1652             graphicsContext.setStrokeStyle(NoStroke);
1653             graphicsContext.setFillColor(color);
1654 
1655             bool wasAntialiased = graphicsContext.shouldAntialias();
1656             graphicsContext.setShouldAntialias(antialias);
1657 
1658             switch (side) {
1659             case BSTop:
1660             case BSBottom:
<span class="line-modified">1661                 drawBorderRect(snapRectToDevicePixels(LayoutRect(x1, y1, length, thirdOfThickness), deviceScaleFactor));</span>
<span class="line-modified">1662                 drawBorderRect(snapRectToDevicePixels(LayoutRect(x1, y2 - thirdOfThickness, length, thirdOfThickness), deviceScaleFactor));</span>
1663                 break;
1664             case BSLeft:
1665             case BSRight:
<span class="line-modified">1666                 drawBorderRect(snapRectToDevicePixels(LayoutRect(x1, y1, thirdOfThickness, length), deviceScaleFactor));</span>
<span class="line-modified">1667                 drawBorderRect(snapRectToDevicePixels(LayoutRect(x2 - thirdOfThickness, y1, thirdOfThickness, length), deviceScaleFactor));</span>
1668                 break;
1669             }
1670 
1671             graphicsContext.setShouldAntialias(wasAntialiased);
1672             graphicsContext.setStrokeStyle(oldStrokeStyle);
1673         } else {
1674             float adjacent1BigThird = ceilToDevicePixel(adjacentWidth1 / 3, deviceScaleFactor);
1675             float adjacent2BigThird = ceilToDevicePixel(adjacentWidth2 / 3, deviceScaleFactor);
1676 
1677             float offset1 = floorToDevicePixel(fabs(adjacentWidth1) * 2 / 3, deviceScaleFactor);
1678             float offset2 = floorToDevicePixel(fabs(adjacentWidth2) * 2 / 3, deviceScaleFactor);
1679 
1680             float mitreOffset1 = adjacentWidth1 &lt; 0 ? offset1 : 0;
1681             float mitreOffset2 = adjacentWidth1 &gt; 0 ? offset1 : 0;
1682             float mitreOffset3 = adjacentWidth2 &lt; 0 ? offset2 : 0;
1683             float mitreOffset4 = adjacentWidth2 &gt; 0 ? offset2 : 0;
1684 
1685             FloatRect paintBorderRect;
1686             switch (side) {
1687             case BSTop:
</pre>
<hr />
<pre>
1777         case BSRight:
1778             drawLineFor(FloatRect(FloatPoint(x1, y1 + offset1), FloatPoint(adjustedX, y2 - offset2)), side, s2, FloatSize(adjacent1BigHalf, adjacent2BigHalf));
1779             drawLineFor(FloatRect(FloatPoint(adjustedX, y1 + offset3), FloatPoint(x2, y2 - offset4)), side, s1, FloatSize(adjacent1SmallHalf, adjacent2SmallHalf));
1780             break;
1781         }
1782         break;
1783     }
1784     case BorderStyle::Inset:
1785     case BorderStyle::Outset:
1786         calculateBorderStyleColor(borderStyle, side, color);
1787         FALLTHROUGH;
1788     case BorderStyle::Solid: {
1789         StrokeStyle oldStrokeStyle = graphicsContext.strokeStyle();
1790         ASSERT(x2 &gt;= x1);
1791         ASSERT(y2 &gt;= y1);
1792         if (!adjacentWidth1 &amp;&amp; !adjacentWidth2) {
1793             graphicsContext.setStrokeStyle(NoStroke);
1794             graphicsContext.setFillColor(color);
1795             bool wasAntialiased = graphicsContext.shouldAntialias();
1796             graphicsContext.setShouldAntialias(antialias);
<span class="line-modified">1797             drawBorderRect(snapRectToDevicePixels(LayoutRect(x1, y1, x2 - x1, y2 - y1), deviceScaleFactor));</span>
1798             graphicsContext.setShouldAntialias(wasAntialiased);
1799             graphicsContext.setStrokeStyle(oldStrokeStyle);
1800             return;
1801         }
1802 
1803         // FIXME: These roundings should be replaced by ASSERT(device pixel positioned) when all the callers have transitioned to device pixels.
1804         x1 = roundToDevicePixel(x1, deviceScaleFactor);
1805         y1 = roundToDevicePixel(y1, deviceScaleFactor);
1806         x2 = roundToDevicePixel(x2, deviceScaleFactor);
1807         y2 = roundToDevicePixel(y2, deviceScaleFactor);
1808 
1809         Vector&lt;FloatPoint&gt; quad;
1810         quad.reserveInitialCapacity(4);
1811         switch (side) {
1812         case BSTop:
1813             quad.uncheckedAppend({ x1 + std::max&lt;float&gt;(-adjacentWidth1, 0), y1 });
1814             quad.uncheckedAppend({ x1 + std::max&lt;float&gt;( adjacentWidth1, 0), y2 });
1815             quad.uncheckedAppend({ x2 - std::max&lt;float&gt;( adjacentWidth2, 0), y2 });
1816             quad.uncheckedAppend({ x2 - std::max&lt;float&gt;(-adjacentWidth2, 0), y1 });
1817             break;
</pre>
<hr />
<pre>
1918     if (needsRepaint)
1919         page().focusController().setFocusedElementNeedsRepaint();
1920 }
1921 
1922 void RenderElement::paintOutline(PaintInfo&amp; paintInfo, const LayoutRect&amp; paintRect)
1923 {
1924     GraphicsContext&amp; graphicsContext = paintInfo.context();
1925     if (graphicsContext.paintingDisabled())
1926         return;
1927 
1928     if (!hasOutline())
1929         return;
1930 
1931     auto&amp; styleToUse = style();
1932     float outlineWidth = floorToDevicePixel(styleToUse.outlineWidth(), document().deviceScaleFactor());
1933     float outlineOffset = floorToDevicePixel(styleToUse.outlineOffset(), document().deviceScaleFactor());
1934 
1935     // Only paint the focus ring by hand if the theme isn&#39;t able to draw it.
1936     if (styleToUse.outlineStyleIsAuto() == OutlineIsAuto::On &amp;&amp; !theme().supportsFocusRing(styleToUse)) {
1937         Vector&lt;LayoutRect&gt; focusRingRects;
<span class="line-modified">1938         LayoutRect paintRectToUse { paintRect };</span>
<span class="line-added">1939 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">1940         // Workaround for &lt;rdar://problem/6209763&gt;. Force the painting bounds of checkboxes and radio controls to be square.</span>
<span class="line-added">1941         // FIXME: Consolidate this code with the same code in RenderBox::paintBoxDecorations(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=194781&gt;.</span>
<span class="line-added">1942         if (style().appearance() == CheckboxPart || style().appearance() == RadioPart) {</span>
<span class="line-added">1943             int width = std::min(paintRect.width(), paintRect.height());</span>
<span class="line-added">1944             int height = width;</span>
<span class="line-added">1945             paintRectToUse = IntRect { paintRect.x(), paintRect.y() + (downcast&lt;RenderBox&gt;(*this).height() - height) / 2, width, height }; // Vertically center the checkbox, like on desktop</span>
<span class="line-added">1946         }</span>
<span class="line-added">1947 #endif</span>
<span class="line-added">1948         addFocusRingRects(focusRingRects, paintRectToUse.location(), paintInfo.paintContainer);</span>
1949         paintFocusRing(paintInfo, styleToUse, focusRingRects);
1950     }
1951 
1952     if (hasOutlineAnnotation() &amp;&amp; styleToUse.outlineStyleIsAuto() == OutlineIsAuto::Off &amp;&amp; !theme().supportsFocusRing(styleToUse))
1953         addPDFURLRect(paintInfo, paintRect.location());
1954 
1955     if (styleToUse.outlineStyleIsAuto() == OutlineIsAuto::On || styleToUse.outlineStyle() == BorderStyle::None)
1956         return;
1957 
1958     FloatRect outer = paintRect;
1959     outer.inflate(outlineOffset + outlineWidth);
1960     FloatRect inner = outer;
1961     inner.inflate(-outlineWidth);
1962 
1963     // FIXME: This prevents outlines from painting inside the object. See bug 12042
1964     if (outer.isEmpty())
1965         return;
1966 
1967     BorderStyle outlineStyle = styleToUse.outlineStyle();
1968     Color outlineColor = styleToUse.visitedDependentColorWithColorFilter(CSSPropertyOutlineColor);
</pre>
<hr />
<pre>
2034 bool RenderElement::hasOutlineAnnotation() const
2035 {
2036     return element() &amp;&amp; element()-&gt;isLink() &amp;&amp; document().printing();
2037 }
2038 
2039 bool RenderElement::hasSelfPaintingLayer() const
2040 {
2041     if (!hasLayer())
2042         return false;
2043     auto&amp; layerModelObject = downcast&lt;RenderLayerModelObject&gt;(*this);
2044     return layerModelObject.hasSelfPaintingLayer();
2045 }
2046 
2047 bool RenderElement::checkForRepaintDuringLayout() const
2048 {
2049     if (document().view()-&gt;layoutContext().needsFullRepaint() || !everHadLayout() || hasSelfPaintingLayer())
2050         return false;
2051     return !settings().repaintOutsideLayoutEnabled();
2052 }
2053 
<span class="line-modified">2054 ImageOrientation RenderElement::imageOrientation() const</span>
2055 {
<span class="line-modified">2056 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)</span>
2057     // This can only be enabled for ports which honor the orientation flag in their drawing code.
2058     if (document().isImageDocument())
<span class="line-modified">2059         return ImageOrientation::FromImage;</span>
2060 #endif
2061     // Respect the image&#39;s orientation if it&#39;s being used as a full-page image or it&#39;s
2062     // an &lt;img&gt; and the setting to respect it everywhere is set.
<span class="line-modified">2063     if (settings().shouldRespectImageOrientation() &amp;&amp; is&lt;HTMLImageElement&gt;(element()))</span>
<span class="line-added">2064         return ImageOrientation::FromImage;</span>
<span class="line-added">2065     return style().imageOrientation();</span>
2066 }
2067 
2068 void RenderElement::adjustFragmentedFlowStateOnContainingBlockChangeIfNeeded()
2069 {
2070     if (fragmentedFlowState() == NotInsideFragmentedFlow)
2071         return;
2072 
2073     // Invalidate the containing block caches.
2074     if (is&lt;RenderBlock&gt;(*this))
2075         downcast&lt;RenderBlock&gt;(*this).resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants();
2076 
2077     // Adjust the flow tread state on the subtree.
2078     setFragmentedFlowState(RenderObject::computedFragmentedFlowState(*this));
2079     for (auto&amp; descendant : descendantsOfType&lt;RenderObject&gt;(*this))
2080         descendant.setFragmentedFlowState(RenderObject::computedFragmentedFlowState(descendant));
2081 }
2082 
2083 void RenderElement::removeFromRenderFragmentedFlow()
2084 {
2085     ASSERT(fragmentedFlowState() != NotInsideFragmentedFlow);
</pre>
</td>
</tr>
</table>
<center><a href="RenderDeprecatedFlexibleBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>