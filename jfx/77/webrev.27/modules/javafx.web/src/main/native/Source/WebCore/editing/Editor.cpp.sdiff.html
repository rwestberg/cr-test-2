<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/Editor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EditingStyle.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Editor.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/Editor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 105 #include &quot;Text.h&quot;
 106 #include &quot;TextCheckerClient.h&quot;
 107 #include &quot;TextCheckingHelper.h&quot;
 108 #include &quot;TextEvent.h&quot;
 109 #include &quot;TextIterator.h&quot;
 110 #include &quot;TypingCommand.h&quot;
 111 #include &quot;UserTypingGestureIndicator.h&quot;
 112 #include &quot;VisibleUnits.h&quot;
 113 #include &quot;markup.h&quot;
 114 #include &lt;pal/FileSizeFormatter.h&gt;
 115 #include &lt;pal/system/Sound.h&gt;
 116 #include &lt;pal/text/KillRing.h&gt;
 117 #include &lt;wtf/unicode/CharacterNames.h&gt;
 118 
 119 #if PLATFORM(MAC)
 120 #include &quot;ServicesOverlayController.h&quot;
 121 #endif
 122 
 123 namespace WebCore {
 124 
<span class="line-modified"> 125 static bool dispatchBeforeInputEvent(Element&amp; element, const AtomicString&amp; inputType, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { }, Event::IsCancelable cancelable = Event::IsCancelable::Yes)</span>
 126 {
 127     if (!element.document().settings().inputEventsEnabled())
 128         return true;
 129 
 130     auto event = InputEvent::create(eventNames().beforeinputEvent, inputType, cancelable, element.document().windowProxy(), data, WTFMove(dataTransfer), targetRanges, 0);
 131     element.dispatchEvent(event);
 132     return !event-&gt;defaultPrevented();
 133 }
 134 
<span class="line-modified"> 135 static void dispatchInputEvent(Element&amp; element, const AtomicString&amp; inputType, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { })</span>
 136 {
 137     if (element.document().settings().inputEventsEnabled()) {
 138         // FIXME: We should not be dispatching to the scoped queue here. Normally, input events are dispatched in CompositeEditCommand::apply after the end of the scope,
 139         // but TypingCommands are special in that existing TypingCommands that are applied again fire input events *from within* the scope by calling typingAddedToOpenCommand.
 140         // Instead, TypingCommands should always dispatch events synchronously after the end of the scoped queue in CompositeEditCommand::apply. To work around this for the
 141         // time being, just revert back to calling dispatchScopedEvent.
 142         element.dispatchScopedEvent(InputEvent::create(eventNames().inputEvent, inputType, Event::IsCancelable::No,
 143             element.document().windowProxy(), data, WTFMove(dataTransfer), targetRanges, 0));
 144     } else
 145         element.dispatchInputEvent();
 146 }
 147 
 148 static String inputEventDataForEditingStyleAndAction(const StyleProperties* style, EditAction action)
 149 {
 150     if (!style)
 151         return { };
 152 
 153     switch (action) {
 154     case EditAction::SetColor:
 155         return style-&gt;getPropertyValue(CSSPropertyColor);
<span class="line-modified"> 156     case EditAction::SetWritingDirection:</span>

 157         return style-&gt;getPropertyValue(CSSPropertyDirection);
 158     default:
 159         return { };
 160     }
 161 }
 162 
 163 static String inputEventDataForEditingStyleAndAction(EditingStyle&amp; style, EditAction action)
 164 {
 165     return inputEventDataForEditingStyleAndAction(style.style(), action);
 166 }
 167 
 168 class ClearTextCommand : public DeleteSelectionCommand {
 169 public:
 170     ClearTextCommand(Document&amp; document);
 171     static void CreateAndApply(const RefPtr&lt;Frame&gt; frame);
 172 
 173 private:
 174     EditAction editingAction() const override;
 175 };
 176 
</pre>
<hr />
<pre>
 273 {
 274     return EditingBehavior(m_frame.settings().editingBehaviorType());
 275 }
 276 
 277 EditorClient* Editor::client() const
 278 {
 279     if (Page* page = m_frame.page())
 280         return &amp;page-&gt;editorClient();
 281     return nullptr;
 282 }
 283 
 284 TextCheckerClient* Editor::textChecker() const
 285 {
 286     if (EditorClient* owner = client())
 287         return owner-&gt;textChecker();
 288     return 0;
 289 }
 290 
 291 void Editor::handleKeyboardEvent(KeyboardEvent&amp; event)
 292 {
<span class="line-modified"> 293     if (EditorClient* c = client())</span>
<span class="line-modified"> 294         c-&gt;handleKeyboardEvent(&amp;event);</span>
 295 }
 296 
 297 void Editor::handleInputMethodKeydown(KeyboardEvent&amp; event)
 298 {
<span class="line-modified"> 299     if (EditorClient* c = client())</span>
<span class="line-modified"> 300         c-&gt;handleInputMethodKeydown(&amp;event);</span>
 301 }
 302 
 303 bool Editor::handleTextEvent(TextEvent&amp; event)
 304 {
 305     LOG(Editing, &quot;Editor %p handleTextEvent (data %s)&quot;, this, event.data().utf8().data());
 306 
 307     // Default event handling for Drag and Drop will be handled by DragController
 308     // so we leave the event for it.
 309     if (event.isDrop())
 310         return false;
 311 
 312     if (event.isPaste()) {
 313         if (event.pastingFragment()) {
 314 #if PLATFORM(IOS_FAMILY)
 315             if (client()-&gt;performsTwoStepPaste(event.pastingFragment()))
 316                 return true;
 317 #endif
 318             replaceSelectionWithFragment(*event.pastingFragment(), SelectReplacement::No, event.shouldSmartReplace() ? SmartReplace::Yes : SmartReplace::No, event.shouldMatchStyle() ? MatchStyle::Yes : MatchStyle::No, EditAction::Paste, event.mailBlockquoteHandling());
 319         } else
 320             replaceSelectionWithText(event.data(), SelectReplacement::No, event.shouldSmartReplace() ? SmartReplace::Yes : SmartReplace::No, EditAction::Paste);
</pre>
<hr />
<pre>
 335 {
 336     return m_frame.selection().selection().rootEditableElement();
 337 }
 338 
 339 bool Editor::canEditRichly() const
 340 {
 341     return m_frame.selection().selection().isContentRichlyEditable();
 342 }
 343 
 344 enum class ClipboardEventKind {
 345     Copy,
 346     Cut,
 347     Paste,
 348     PasteAsPlainText,
 349     PasteAsQuotation,
 350     BeforeCopy,
 351     BeforeCut,
 352     BeforePaste,
 353 };
 354 
<span class="line-modified"> 355 static AtomicString eventNameForClipboardEvent(ClipboardEventKind kind)</span>
 356 {
 357     switch (kind) {
 358     case ClipboardEventKind::Copy:
 359         return eventNames().copyEvent;
 360     case ClipboardEventKind::Cut:
 361         return eventNames().cutEvent;
 362     case ClipboardEventKind::Paste:
 363     case ClipboardEventKind::PasteAsPlainText:
 364     case ClipboardEventKind::PasteAsQuotation:
 365         return eventNames().pasteEvent;
 366     case ClipboardEventKind::BeforeCopy:
 367         return eventNames().beforecopyEvent;
 368     case ClipboardEventKind::BeforeCut:
 369         return eventNames().beforecutEvent;
 370     case ClipboardEventKind::BeforePaste:
 371         return eventNames().beforepasteEvent;
 372     }
 373     ASSERT_NOT_REACHED();
 374     return { };
 375 }
 376 
 377 static Ref&lt;DataTransfer&gt; createDataTransferForClipboardEvent(Document&amp; document, ClipboardEventKind kind)
 378 {
 379     switch (kind) {
 380     case ClipboardEventKind::Copy:
 381     case ClipboardEventKind::Cut:
<span class="line-modified"> 382         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::ReadWrite, std::make_unique&lt;StaticPasteboard&gt;());</span>
 383     case ClipboardEventKind::PasteAsPlainText:
 384         if (RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled()) {
 385             auto plainTextType = &quot;text/plain&quot;_s;
 386             auto plainText = Pasteboard::createForCopyAndPaste()-&gt;readString(plainTextType);
<span class="line-modified"> 387             auto pasteboard = std::make_unique&lt;StaticPasteboard&gt;();</span>
 388             pasteboard-&gt;writeString(plainTextType, plainText);
 389             return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Readonly, WTFMove(pasteboard));
 390         }
 391         FALLTHROUGH;
 392     case ClipboardEventKind::Paste:
 393     case ClipboardEventKind::PasteAsQuotation:
 394         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Readonly, Pasteboard::createForCopyAndPaste());
 395     case ClipboardEventKind::BeforeCopy:
 396     case ClipboardEventKind::BeforeCut:
 397     case ClipboardEventKind::BeforePaste:
<span class="line-modified"> 398         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Invalid, std::make_unique&lt;StaticPasteboard&gt;());</span>
 399     }
 400     ASSERT_NOT_REACHED();
<span class="line-modified"> 401     return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Invalid, std::make_unique&lt;StaticPasteboard&gt;());</span>
 402 }
 403 
 404 // Returns whether caller should continue with &quot;the default processing&quot;, which is the same as
 405 // the event handler NOT setting the return value to false
 406 // https://w3c.github.io/clipboard-apis/#fire-a-clipboard-event
 407 static bool dispatchClipboardEvent(RefPtr&lt;Element&gt;&amp;&amp; target, ClipboardEventKind kind)
 408 {
 409     // FIXME: Move the target selection code here.
 410     if (!target)
 411         return true;
 412 
 413     auto dataTransfer = createDataTransferForClipboardEvent(target-&gt;document(), kind);
 414 
 415     auto event = ClipboardEvent::create(eventNameForClipboardEvent(kind), dataTransfer.copyRef());
 416 
 417     target-&gt;dispatchEvent(event);
 418     bool noDefaultProcessing = event-&gt;defaultPrevented();
 419     if (noDefaultProcessing &amp;&amp; (kind == ClipboardEventKind::Copy || kind == ClipboardEventKind::Cut)) {
 420         auto pasteboard = Pasteboard::createForCopyAndPaste();
 421         pasteboard-&gt;clear();
</pre>
<hr />
<pre>
 495 }
 496 
 497 bool Editor::canDeleteRange(Range* range) const
 498 {
 499     Node&amp; startContainer = range-&gt;startContainer();
 500     Node&amp; endContainer = range-&gt;endContainer();
 501 
 502     if (!startContainer.hasEditableStyle() || !endContainer.hasEditableStyle())
 503         return false;
 504 
 505     if (range-&gt;collapsed()) {
 506         VisiblePosition start(range-&gt;startPosition(), DOWNSTREAM);
 507         VisiblePosition previous = start.previous();
 508         // FIXME: We sometimes allow deletions at the start of editable roots, like when the caret is in an empty list item.
 509         if (previous.isNull() || previous.deepEquivalent().deprecatedNode()-&gt;rootEditableElement() != startContainer.rootEditableElement())
 510             return false;
 511     }
 512     return true;
 513 }
 514 







 515 bool Editor::smartInsertDeleteEnabled()
 516 {
 517     return client() &amp;&amp; client()-&gt;smartInsertDeleteEnabled();
 518 }
 519 
 520 bool Editor::canSmartCopyOrDelete()
 521 {
<span class="line-modified"> 522     return client() &amp;&amp; client()-&gt;smartInsertDeleteEnabled() &amp;&amp; m_frame.selection().granularity() == WordGranularity;</span>
 523 }
 524 
 525 bool Editor::isSelectTrailingWhitespaceEnabled() const
 526 {
 527     return client() &amp;&amp; client()-&gt;isSelectTrailingWhitespaceEnabled();
 528 }
 529 
 530 bool Editor::deleteWithDirection(SelectionDirection direction, TextGranularity granularity, bool shouldAddToKillRing, bool isTypingAction)
 531 {
 532     if (!canEdit())
 533         return false;
 534 
 535     if (m_frame.selection().isRange()) {
 536         if (isTypingAction) {
 537             TypingCommand::deleteKeyPressed(document(), canSmartCopyOrDelete() ? TypingCommand::SmartDelete : 0, granularity);
 538             revealSelectionAfterEditingOperation();
 539         } else {
 540             if (shouldAddToKillRing)
 541                 addRangeToKillRing(*selectedRange().get(), KillRingInsertionMode::AppendText);
 542             deleteSelectionWithSmartDelete(canSmartCopyOrDelete());
</pre>
<hr />
<pre>
1031 void Editor::indent()
1032 {
1033     IndentOutdentCommand::create(document(), IndentOutdentCommand::Indent)-&gt;apply();
1034 }
1035 
1036 void Editor::outdent()
1037 {
1038     IndentOutdentCommand::create(document(), IndentOutdentCommand::Outdent)-&gt;apply();
1039 }
1040 
1041 static void notifyTextFromControls(Element* startRoot, Element* endRoot)
1042 {
1043     HTMLTextFormControlElement* startingTextControl = enclosingTextFormControl(firstPositionInOrBeforeNode(startRoot));
1044     HTMLTextFormControlElement* endingTextControl = enclosingTextFormControl(firstPositionInOrBeforeNode(endRoot));
1045     if (startingTextControl)
1046         startingTextControl-&gt;didEditInnerTextValue();
1047     if (endingTextControl &amp;&amp; startingTextControl != endingTextControl)
1048         endingTextControl-&gt;didEditInnerTextValue();
1049 }
1050 
<span class="line-modified">1051 static bool dispatchBeforeInputEvents(RefPtr&lt;Element&gt; startRoot, RefPtr&lt;Element&gt; endRoot, const AtomicString&amp; inputTypeName, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { }, Event::IsCancelable cancelable = Event::IsCancelable::Yes)</span>
1052 {
1053     bool continueWithDefaultBehavior = true;
1054     if (startRoot)
1055         continueWithDefaultBehavior &amp;= dispatchBeforeInputEvent(*startRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges, cancelable);
1056     if (endRoot &amp;&amp; endRoot != startRoot)
1057         continueWithDefaultBehavior &amp;= dispatchBeforeInputEvent(*endRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges, cancelable);
1058     return continueWithDefaultBehavior;
1059 }
1060 
<span class="line-modified">1061 static void dispatchInputEvents(RefPtr&lt;Element&gt; startRoot, RefPtr&lt;Element&gt; endRoot, const AtomicString&amp; inputTypeName, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { })</span>
1062 {
1063     if (startRoot)
1064         dispatchInputEvent(*startRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges);
1065     if (endRoot &amp;&amp; endRoot != startRoot)
1066         dispatchInputEvent(*endRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges);
1067 }
1068 
1069 bool Editor::willApplyEditing(CompositeEditCommand&amp; command, Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp;&amp; targetRanges) const
1070 {
1071     if (!command.shouldDispatchInputEvents())
1072         return true;
1073 
1074     auto* composition = command.composition();
1075     if (!composition)
1076         return true;
1077 
1078     return dispatchBeforeInputEvents(composition-&gt;startingRootEditableElement(), composition-&gt;endingRootEditableElement(), command.inputEventTypeName(),
1079         command.inputEventData(), command.inputEventDataTransfer(), targetRanges, command.isBeforeInputEventCancelable() ? Event::IsCancelable::Yes : Event::IsCancelable::No);
1080 }
1081 
</pre>
<hr />
<pre>
1158 void Editor::reappliedEditing(EditCommandComposition&amp; composition)
1159 {
1160     document().updateLayout();
1161 
1162     notifyTextFromControls(composition.startingRootEditableElement(), composition.endingRootEditableElement());
1163 
1164     VisibleSelection newSelection(composition.endingSelection());
1165     changeSelectionAfterCommand(newSelection, FrameSelection::defaultSetSelectionOptions());
1166     dispatchInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), &quot;historyRedo&quot;);
1167 
1168     updateEditorUINowIfScheduled();
1169 
1170     m_lastEditCommand = nullptr;
1171     if (auto* client = this-&gt;client())
1172         client-&gt;registerUndoStep(composition);
1173     respondToChangedContents(newSelection);
1174 }
1175 
1176 Editor::Editor(Frame&amp; frame)
1177     : m_frame(frame)
<span class="line-modified">1178     , m_killRing(std::make_unique&lt;PAL::KillRing&gt;())</span>
<span class="line-modified">1179     , m_spellChecker(std::make_unique&lt;SpellChecker&gt;(frame))</span>
<span class="line-modified">1180     , m_alternativeTextController(std::make_unique&lt;AlternativeTextController&gt;(frame))</span>
1181     , m_editorUIUpdateTimer(*this, &amp;Editor::editorUIUpdateTimerFired)
1182 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
1183     , m_telephoneNumberDetectionUpdateTimer(*this, &amp;Editor::scanSelectionForTelephoneNumbers)
1184 #endif
1185 {
1186 }
1187 
1188 Editor::~Editor() = default;
1189 
1190 void Editor::clear()
1191 {
1192     m_lastEditCommand = nullptr;
1193     if (m_compositionNode) {
1194         m_compositionNode = nullptr;
1195         if (EditorClient* client = this-&gt;client())
1196             client-&gt;discardedComposition(&amp;m_frame);
1197     }
1198     m_customCompositionUnderlines.clear();
1199     m_shouldStyleWithCSS = false;
1200     m_defaultParagraphSeparator = EditorParagraphSeparatorIsDiv;
</pre>
<hr />
<pre>
1255         if (Node* selectionStart = selection.start().deprecatedNode()) {
1256             Ref&lt;Document&gt; document(selectionStart-&gt;document());
1257 
1258             // Insert the text
1259             if (triggeringEvent &amp;&amp; triggeringEvent-&gt;isDictation())
1260                 DictationCommand::insertText(document, text, triggeringEvent-&gt;dictationAlternatives(), selection);
1261             else {
1262                 TypingCommand::Options options = 0;
1263                 if (selectInsertedText)
1264                     options |= TypingCommand::SelectInsertedText;
1265                 if (autocorrectionWasApplied)
1266                     options |= TypingCommand::RetainAutocorrectionIndicator;
1267                 if (triggeringEvent &amp;&amp; triggeringEvent-&gt;isAutocompletion())
1268                     options |= TypingCommand::IsAutocompletion;
1269                 TypingCommand::insertText(document, text, selection, options, triggeringEvent &amp;&amp; triggeringEvent-&gt;isComposition() ? TypingCommand::TextCompositionFinal : TypingCommand::TextCompositionNone);
1270             }
1271 
1272             // Reveal the current selection
1273             if (Frame* editedFrame = document-&gt;frame())
1274                 if (Page* page = editedFrame-&gt;page()) {
<span class="line-removed">1275 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">1276                     SelectionRevealMode revealMode = SelectionRevealMode::RevealUpToMainFrame;</span>
<span class="line-removed">1277 #else</span>
1278                     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;
<span class="line-removed">1279 #endif</span>
1280                     page-&gt;focusController().focusedOrMainFrame().selection().revealSelection(revealMode, ScrollAlignment::alignCenterIfNeeded);
1281                 }
1282         }
1283     }
1284 
1285     return true;
1286 }
1287 
1288 bool Editor::insertLineBreak()
1289 {
1290     if (!canEdit())
1291         return false;
1292 
1293     if (!shouldInsertText(&quot;\n&quot;, m_frame.selection().toNormalizedRange().get(), EditorInsertAction::Typed))
1294         return true;
1295 
1296     VisiblePosition caret = m_frame.selection().selection().visibleStart();
1297     bool alignToEdge = isEndOfEditableOrNonEditableContent(caret);
1298     bool autocorrectionIsApplied = m_alternativeTextController-&gt;applyAutocorrectionBeforeTypingIfAppropriate();
1299     TypingCommand::insertLineBreak(document(), autocorrectionIsApplied ? TypingCommand::RetainAutocorrectionIndicator : 0);
</pre>
<hr />
<pre>
1442 }
1443 
1444 void Editor::pasteAsQuotation()
1445 {
1446     if (!dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::PasteAsQuotation))
1447         return;
1448     if (!canPaste())
1449         return;
1450     updateMarkersForWordsAffectedByEditing(false);
1451     ResourceCacheValidationSuppressor validationSuppressor(document().cachedResourceLoader());
1452     auto pasteboard = Pasteboard::createForCopyAndPaste();
1453     if (m_frame.selection().selection().isContentRichlyEditable())
1454         pasteWithPasteboard(pasteboard.get(), { PasteOption::AllowPlainText, PasteOption::AsQuotation });
1455     else
1456         pasteAsPlainTextWithPasteboard(*pasteboard);
1457 }
1458 
1459 void Editor::quoteFragmentForPasting(DocumentFragment&amp; fragment)
1460 {
1461     auto blockQuote = HTMLQuoteElement::create(blockquoteTag, document());
<span class="line-modified">1462     blockQuote-&gt;setAttributeWithoutSynchronization(typeAttr, AtomicString(&quot;cite&quot;));</span>
<span class="line-modified">1463     blockQuote-&gt;setAttributeWithoutSynchronization(classAttr, AtomicString(ApplePasteAsQuotation));</span>
1464 
1465     auto childNode = fragment.firstChild();
1466 
1467     if (childNode) {
1468         while (childNode) {
1469             blockQuote-&gt;appendChild(*childNode);
1470             childNode = fragment.firstChild();
1471         }
1472     } else
1473         blockQuote-&gt;appendChild(HTMLBRElement::create(document()));
1474 
1475     fragment.appendChild(blockQuote);
1476 }
1477 
1478 void Editor::performDelete()
1479 {
1480     if (!canDelete()) {
1481         PAL::systemBeep();
1482         return;
1483     }
</pre>
<hr />
<pre>
1779 void Editor::toggleUnderline()
1780 {
1781     command(&quot;ToggleUnderline&quot;).execute();
1782 }
1783 
1784 void Editor::setBaseWritingDirection(WritingDirection direction)
1785 {
1786 #if PLATFORM(IOS_FAMILY)
1787     if (inSameParagraph(m_frame.selection().selection().visibleStart(), m_frame.selection().selection().visibleEnd()) &amp;&amp;
1788         baseWritingDirectionForSelectionStart() == direction)
1789         return;
1790 #endif
1791 
1792     Element* focusedElement = document().focusedElement();
1793     if (focusedElement &amp;&amp; focusedElement-&gt;isTextField()) {
1794         if (direction == WritingDirection::Natural)
1795             return;
1796 
1797         auto&amp; focusedFormElement = downcast&lt;HTMLTextFormControlElement&gt;(*focusedElement);
1798         auto directionValue = direction == WritingDirection::LeftToRight ? &quot;ltr&quot; : &quot;rtl&quot;;
<span class="line-modified">1799         auto writingDirectionInputTypeName = inputTypeNameForEditingAction(EditAction::SetWritingDirection);</span>
1800         if (!dispatchBeforeInputEvent(focusedFormElement, writingDirectionInputTypeName, directionValue))
1801             return;
1802 
1803         focusedFormElement.setAttributeWithoutSynchronization(dirAttr, directionValue);
1804         dispatchInputEvent(focusedFormElement, writingDirectionInputTypeName, directionValue);
1805         document().updateStyleIfNeeded();
1806         return;
1807     }
1808 
1809     auto style = MutableStyleProperties::create();
1810     style-&gt;setProperty(CSSPropertyDirection, direction == WritingDirection::LeftToRight ? &quot;ltr&quot; : direction == WritingDirection::RightToLeft ? &quot;rtl&quot; : &quot;inherit&quot;, false);
<span class="line-modified">1811     applyParagraphStyleToSelection(style.ptr(), EditAction::SetWritingDirection);</span>
1812 }
1813 
1814 WritingDirection Editor::baseWritingDirectionForSelectionStart() const
1815 {
1816     auto result = WritingDirection::LeftToRight;
1817 
1818     Position pos = m_frame.selection().selection().visibleStart().deepEquivalent();
1819     Node* node = pos.deprecatedNode();
1820     if (!node)
1821         return result;
1822 
1823     auto renderer = node-&gt;renderer();
1824     if (!renderer)
1825         return result;
1826 
1827     if (!renderer-&gt;isRenderBlockFlow()) {
1828         renderer = renderer-&gt;containingBlock();
1829         if (!renderer)
1830             return result;
1831     }
</pre>
<hr />
<pre>
2383     if (!client())
2384         return false;
2385     return client()-&gt;spellingUIIsShowing();
2386 }
2387 
2388 void Editor::clearMisspellingsAndBadGrammar(const VisibleSelection&amp; movingSelection)
2389 {
2390     if (auto selectedRange = movingSelection.toNormalizedRange())
2391         document().markers().removeMarkers(*selectedRange, { DocumentMarker::Spelling, DocumentMarker::Grammar });
2392 }
2393 
2394 void Editor::markMisspellingsAndBadGrammar(const VisibleSelection &amp;movingSelection)
2395 {
2396     markMisspellingsAndBadGrammar(movingSelection, isContinuousSpellCheckingEnabled() &amp;&amp; isGrammarCheckingEnabled(), movingSelection);
2397 }
2398 
2399 void Editor::markMisspellingsAfterTypingToWord(const VisiblePosition &amp;wordStart, const VisibleSelection&amp; selectionAfterTyping, bool doReplacement)
2400 {
2401     Ref&lt;Frame&gt; protection(m_frame);
2402 



2403 #if PLATFORM(IOS_FAMILY)
2404     UNUSED_PARAM(selectionAfterTyping);
2405     UNUSED_PARAM(doReplacement);
2406     OptionSet&lt;TextCheckingType&gt; textCheckingOptions;
2407     if (isContinuousSpellCheckingEnabled())
2408         textCheckingOptions.add(TextCheckingType::Spelling);
2409     if (!textCheckingOptions.contains(TextCheckingType::Spelling))
2410         return;
2411 
2412     VisibleSelection adjacentWords = VisibleSelection(startOfWord(wordStart, LeftWordIfOnBoundary), endOfWord(wordStart, RightWordIfOnBoundary));
2413     auto adjacentWordRange = adjacentWords.toNormalizedRange();
2414     markAllMisspellingsAndBadGrammarInRanges(textCheckingOptions, adjacentWordRange.copyRef(), adjacentWordRange.copyRef(), adjacentWordRange.copyRef());
2415 #else
2416 #if !USE(AUTOMATIC_TEXT_REPLACEMENT)
2417     UNUSED_PARAM(doReplacement);
2418 #endif
2419 
2420     if (unifiedTextCheckerEnabled()) {
2421         m_alternativeTextController-&gt;applyPendingCorrection(selectionAfterTyping);
2422 
</pre>
<hr />
<pre>
2605     return isSpellCheckingEnabledFor(m_frame.selection().selection().start().deprecatedNode());
2606 }
2607 
2608 void Editor::markMisspellings(const VisibleSelection&amp; selection, RefPtr&lt;Range&gt;&amp; firstMisspellingRange)
2609 {
2610     markMisspellingsOrBadGrammar(selection, true, firstMisspellingRange);
2611 }
2612 
2613 void Editor::markBadGrammar(const VisibleSelection&amp; selection)
2614 {
2615 #if USE(GRAMMAR_CHECKING)
2616     RefPtr&lt;Range&gt; firstMisspellingRange;
2617     markMisspellingsOrBadGrammar(selection, false, firstMisspellingRange);
2618 #else
2619     ASSERT_NOT_REACHED();
2620 #endif
2621 }
2622 
2623 void Editor::markAllMisspellingsAndBadGrammarInRanges(OptionSet&lt;TextCheckingType&gt; textCheckingOptions, RefPtr&lt;Range&gt;&amp;&amp; spellingRange, RefPtr&lt;Range&gt;&amp;&amp; automaticReplacementRange, RefPtr&lt;Range&gt;&amp;&amp; grammarRange)
2624 {



2625     ASSERT(unifiedTextCheckerEnabled());
2626 
2627     // There shouldn&#39;t be pending autocorrection at this moment.
2628     ASSERT(!m_alternativeTextController-&gt;hasPendingCorrection());
2629 
2630     bool shouldMarkGrammar = textCheckingOptions.contains(TextCheckingType::Grammar);
2631     bool shouldShowCorrectionPanel = textCheckingOptions.contains(TextCheckingType::ShowCorrectionPanel);
2632 
2633     // This function is called with selections already expanded to word boundaries.
2634     if (!client() || !spellingRange || (shouldMarkGrammar &amp;&amp; !grammarRange))
2635         return;
2636 
2637     // If we&#39;re not in an editable node, bail.
2638     Node&amp; editableNode = spellingRange-&gt;startContainer();
2639     if (!editableNode.hasEditableStyle())
2640         return;
2641 
2642     if (!isSpellCheckingEnabledFor(&amp;editableNode))
2643         return;
2644 
</pre>
<hr />
<pre>
2668 
2669 static bool isAutomaticTextReplacementType(TextCheckingType type)
2670 {
2671     switch (type) {
2672     case TextCheckingType::None:
2673     case TextCheckingType::Spelling:
2674     case TextCheckingType::Grammar:
2675         return false;
2676     case TextCheckingType::Link:
2677     case TextCheckingType::Quote:
2678     case TextCheckingType::Dash:
2679     case TextCheckingType::Replacement:
2680     case TextCheckingType::Correction:
2681     case TextCheckingType::ShowCorrectionPanel:
2682         return true;
2683     }
2684     ASSERT_NOT_REACHED();
2685     return false;
2686 }
2687 





2688 static void correctSpellcheckingPreservingTextCheckingParagraph(TextCheckingParagraph&amp; paragraph, Range&amp; rangeToReplace, const String&amp; replacement, int resultLocation, int resultLength)
2689 {
2690     auto&amp; scope = downcast&lt;ContainerNode&gt;(paragraph.paragraphRange().startContainer().rootNode());
2691 
2692     size_t paragraphLocation;
2693     size_t paragraphLength;
2694     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;paragraph.paragraphRange(), paragraphLocation, paragraphLength);
2695 
2696     SpellingCorrectionCommand::create(rangeToReplace, replacement)-&gt;apply();
2697 
2698     // TextCheckingParagraph may be orphaned after SpellingCorrectionCommand mutated DOM.
2699     // See &lt;rdar://10305315&gt;, http://webkit.org/b/89526.
2700 
2701     RefPtr&lt;Range&gt; newParagraphRange = TextIterator::rangeFromLocationAndLength(&amp;scope, paragraphLocation, paragraphLength + replacement.length() - resultLength);
2702 
2703     auto spellCheckingRange = TextIterator::subrange(*newParagraphRange, resultLocation, replacement.length());
2704     paragraph = TextCheckingParagraph(spellCheckingRange.copyRef(), spellCheckingRange.copyRef(), newParagraphRange.get());
2705 }
2706 
2707 void Editor::markAndReplaceFor(const SpellCheckRequest&amp; request, const Vector&lt;TextCheckingResult&gt;&amp; results)
</pre>
<hr />
<pre>
2880 
2881     RefPtr&lt;Range&gt; selection = selectedRange();
2882     if (!shouldInsertText(replacedString, selection.get(), EditorInsertAction::Pasted))
2883         return;
2884 
2885     m_alternativeTextController-&gt;recordAutocorrectionResponse(AutocorrectionResponse::Reverted, replacedString, selection.get());
2886     TextCheckingParagraph paragraph(*selection);
2887     replaceSelectionWithText(replacedString, SelectReplacement::No, SmartReplace::No, EditAction::Insert);
2888     auto changedRange = paragraph.subrange(paragraph.checkingStart(), replacedString.length());
2889     changedRange-&gt;startContainer().document().markers().addMarker(changedRange, DocumentMarker::Replacement, String());
2890     m_alternativeTextController-&gt;markReversed(changedRange);
2891 #else
2892     ASSERT_NOT_REACHED();
2893     UNUSED_PARAM(replacedString);
2894 #endif // !PLATFORM(IOS_FAMILY)
2895 }
2896 
2897 
2898 void Editor::markMisspellingsAndBadGrammar(const VisibleSelection&amp; spellingSelection, bool markGrammar, const VisibleSelection&amp; grammarSelection)
2899 {



2900     if (unifiedTextCheckerEnabled()) {
2901         if (!isContinuousSpellCheckingEnabled())
2902             return;
2903 
2904         // markMisspellingsAndBadGrammar() is triggered by selection change, in which case we check spelling and grammar, but don&#39;t autocorrect misspellings.
2905         OptionSet&lt;TextCheckingType&gt; textCheckingOptions { TextCheckingType::Spelling };
2906         if (markGrammar &amp;&amp; isGrammarCheckingEnabled())
2907             textCheckingOptions.add(TextCheckingType::Grammar);
2908         auto spellCheckingRange = spellingSelection.toNormalizedRange();
2909         markAllMisspellingsAndBadGrammarInRanges(textCheckingOptions, spellCheckingRange.copyRef(), spellCheckingRange.copyRef(), grammarSelection.toNormalizedRange());
2910         return;
2911     }
2912 
2913     RefPtr&lt;Range&gt; firstMisspellingRange;
2914     markMisspellings(spellingSelection, firstMisspellingRange);
2915     if (markGrammar)
2916         markBadGrammar(grammarSelection);
2917 }
2918 
2919 void Editor::unappliedSpellCorrection(const VisibleSelection&amp; selectionOfCorrected, const String&amp; corrected, const String&amp; correction)
</pre>
<hr />
<pre>
3016     Document* document = m_frame.documentAtPoint(windowPoint);
3017     if (!document)
3018         return nullptr;
3019 
3020     Frame* frame = document-&gt;frame();
3021     ASSERT(frame);
3022     FrameView* frameView = frame-&gt;view();
3023     if (!frameView)
3024         return nullptr;
3025     IntPoint framePoint = frameView-&gt;windowToContents(windowPoint);
3026     VisibleSelection selection(frame-&gt;visiblePositionForPoint(framePoint));
3027 
3028     return selection.toNormalizedRange();
3029 }
3030 
3031 void Editor::revealSelectionAfterEditingOperation(const ScrollAlignment&amp; alignment, RevealExtentOption revealExtentOption)
3032 {
3033     if (m_ignoreSelectionChanges)
3034         return;
3035 
<span class="line-removed">3036 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">3037     SelectionRevealMode revealMode = SelectionRevealMode::RevealUpToMainFrame;</span>
<span class="line-removed">3038 #else</span>
3039     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;
<span class="line-removed">3040 #endif</span>
<span class="line-removed">3041 </span>
3042     m_frame.selection().revealSelection(revealMode, alignment, revealExtentOption);
3043 }
3044 
3045 void Editor::setIgnoreSelectionChanges(bool ignore, RevealSelection shouldRevealExistingSelection)
3046 {
3047     if (m_ignoreSelectionChanges == ignore)
3048         return;
3049 
3050     m_ignoreSelectionChanges = ignore;
3051 #if PLATFORM(IOS_FAMILY)
3052     // FIXME: Should suppress selection change notifications during a composition change &lt;https://webkit.org/b/38830&gt;
3053     if (!ignore)
3054         respondToChangedSelection(m_frame.selection().selection(), { });
3055 #endif
3056     if (!ignore &amp;&amp; shouldRevealExistingSelection == RevealSelection::Yes)
3057         revealSelectionAfterEditingOperation(ScrollAlignment::alignToEdgeIfNeeded, RevealExtent);
3058 }
3059 
3060 RefPtr&lt;Range&gt; Editor::compositionRange() const
3061 {
3062     if (!m_compositionNode)
3063         return nullptr;
3064     unsigned length = m_compositionNode-&gt;length();
3065     unsigned start = std::min(m_compositionStart, length);
3066     unsigned end = std::min(std::max(start, m_compositionEnd), length);

3067     if (start &gt;= end)
3068         return nullptr;
3069     return Range::create(m_compositionNode-&gt;document(), m_compositionNode.get(), start, m_compositionNode.get(), end);
3070 }
3071 
3072 bool Editor::getCompositionSelection(unsigned&amp; selectionStart, unsigned&amp; selectionEnd) const
3073 {
3074     if (!m_compositionNode)
3075         return false;
3076     const VisibleSelection&amp; selection = m_frame.selection().selection();
3077     Position start = selection.start();
3078     if (start.deprecatedNode() != m_compositionNode)
3079         return false;
3080     Position end = selection.end();
3081     if (end.deprecatedNode() != m_compositionNode)
3082         return false;
3083 
3084     if (static_cast&lt;unsigned&gt;(start.deprecatedEditingOffset()) &lt; m_compositionStart)
3085         return false;
3086     if (static_cast&lt;unsigned&gt;(end.deprecatedEditingOffset()) &gt; m_compositionEnd)
</pre>
<hr />
<pre>
4234     Node* pastEnd = range-&gt;pastLastNode();
4235     // In the loop below, node should eventually match pastEnd and not become null, but we&#39;ve seen at least one
4236     // unreproducible case where this didn&#39;t happen, so check for null also.
4237     for (Node* node = startNode; node &amp;&amp; node != pastEnd; node = NodeTraversal::next(*node)) {
4238         auto renderer = node-&gt;renderer();
4239         if (!renderer)
4240             continue;
4241         // FIXME: Are there any node types that have renderers, but that we should be skipping?
4242         const Font&amp; primaryFont = renderer-&gt;style().fontCascade().primaryFont();
4243         if (!font)
4244             font = &amp;primaryFont;
4245         else if (font != &amp;primaryFont) {
4246             hasMultipleFonts = true;
4247             break;
4248         }
4249     }
4250 
4251     return font;
4252 }
4253 
<span class="line-removed">4254 String Editor::clientReplacementURLForResource(Ref&lt;SharedBuffer&gt;&amp;&amp; resourceData, const String&amp; mimeType)</span>
<span class="line-removed">4255 {</span>
<span class="line-removed">4256     if (auto* editorClient = client())</span>
<span class="line-removed">4257         return editorClient-&gt;replacementURLForResource(WTFMove(resourceData), mimeType);</span>
<span class="line-removed">4258 </span>
<span class="line-removed">4259     return { };</span>
<span class="line-removed">4260 }</span>
<span class="line-removed">4261 </span>
4262 RefPtr&lt;HTMLImageElement&gt; Editor::insertEditableImage()
4263 {
4264     return InsertEditableImageCommand::insertEditableImage(document());
4265 }
4266 
4267 bool Editor::canCopyExcludingStandaloneImages() const
4268 {
4269     auto&amp; selection = m_frame.selection().selection();
4270     return selection.isRange() &amp;&amp; !selection.isInPasswordField();
4271 }
4272 
4273 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 105 #include &quot;Text.h&quot;
 106 #include &quot;TextCheckerClient.h&quot;
 107 #include &quot;TextCheckingHelper.h&quot;
 108 #include &quot;TextEvent.h&quot;
 109 #include &quot;TextIterator.h&quot;
 110 #include &quot;TypingCommand.h&quot;
 111 #include &quot;UserTypingGestureIndicator.h&quot;
 112 #include &quot;VisibleUnits.h&quot;
 113 #include &quot;markup.h&quot;
 114 #include &lt;pal/FileSizeFormatter.h&gt;
 115 #include &lt;pal/system/Sound.h&gt;
 116 #include &lt;pal/text/KillRing.h&gt;
 117 #include &lt;wtf/unicode/CharacterNames.h&gt;
 118 
 119 #if PLATFORM(MAC)
 120 #include &quot;ServicesOverlayController.h&quot;
 121 #endif
 122 
 123 namespace WebCore {
 124 
<span class="line-modified"> 125 static bool dispatchBeforeInputEvent(Element&amp; element, const AtomString&amp; inputType, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { }, Event::IsCancelable cancelable = Event::IsCancelable::Yes)</span>
 126 {
 127     if (!element.document().settings().inputEventsEnabled())
 128         return true;
 129 
 130     auto event = InputEvent::create(eventNames().beforeinputEvent, inputType, cancelable, element.document().windowProxy(), data, WTFMove(dataTransfer), targetRanges, 0);
 131     element.dispatchEvent(event);
 132     return !event-&gt;defaultPrevented();
 133 }
 134 
<span class="line-modified"> 135 static void dispatchInputEvent(Element&amp; element, const AtomString&amp; inputType, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { })</span>
 136 {
 137     if (element.document().settings().inputEventsEnabled()) {
 138         // FIXME: We should not be dispatching to the scoped queue here. Normally, input events are dispatched in CompositeEditCommand::apply after the end of the scope,
 139         // but TypingCommands are special in that existing TypingCommands that are applied again fire input events *from within* the scope by calling typingAddedToOpenCommand.
 140         // Instead, TypingCommands should always dispatch events synchronously after the end of the scoped queue in CompositeEditCommand::apply. To work around this for the
 141         // time being, just revert back to calling dispatchScopedEvent.
 142         element.dispatchScopedEvent(InputEvent::create(eventNames().inputEvent, inputType, Event::IsCancelable::No,
 143             element.document().windowProxy(), data, WTFMove(dataTransfer), targetRanges, 0));
 144     } else
 145         element.dispatchInputEvent();
 146 }
 147 
 148 static String inputEventDataForEditingStyleAndAction(const StyleProperties* style, EditAction action)
 149 {
 150     if (!style)
 151         return { };
 152 
 153     switch (action) {
 154     case EditAction::SetColor:
 155         return style-&gt;getPropertyValue(CSSPropertyColor);
<span class="line-modified"> 156     case EditAction::SetInlineWritingDirection:</span>
<span class="line-added"> 157     case EditAction::SetBlockWritingDirection:</span>
 158         return style-&gt;getPropertyValue(CSSPropertyDirection);
 159     default:
 160         return { };
 161     }
 162 }
 163 
 164 static String inputEventDataForEditingStyleAndAction(EditingStyle&amp; style, EditAction action)
 165 {
 166     return inputEventDataForEditingStyleAndAction(style.style(), action);
 167 }
 168 
 169 class ClearTextCommand : public DeleteSelectionCommand {
 170 public:
 171     ClearTextCommand(Document&amp; document);
 172     static void CreateAndApply(const RefPtr&lt;Frame&gt; frame);
 173 
 174 private:
 175     EditAction editingAction() const override;
 176 };
 177 
</pre>
<hr />
<pre>
 274 {
 275     return EditingBehavior(m_frame.settings().editingBehaviorType());
 276 }
 277 
 278 EditorClient* Editor::client() const
 279 {
 280     if (Page* page = m_frame.page())
 281         return &amp;page-&gt;editorClient();
 282     return nullptr;
 283 }
 284 
 285 TextCheckerClient* Editor::textChecker() const
 286 {
 287     if (EditorClient* owner = client())
 288         return owner-&gt;textChecker();
 289     return 0;
 290 }
 291 
 292 void Editor::handleKeyboardEvent(KeyboardEvent&amp; event)
 293 {
<span class="line-modified"> 294     if (auto* client = this-&gt;client())</span>
<span class="line-modified"> 295         client-&gt;handleKeyboardEvent(event);</span>
 296 }
 297 
 298 void Editor::handleInputMethodKeydown(KeyboardEvent&amp; event)
 299 {
<span class="line-modified"> 300     if (auto* client = this-&gt;client())</span>
<span class="line-modified"> 301         client-&gt;handleInputMethodKeydown(event);</span>
 302 }
 303 
 304 bool Editor::handleTextEvent(TextEvent&amp; event)
 305 {
 306     LOG(Editing, &quot;Editor %p handleTextEvent (data %s)&quot;, this, event.data().utf8().data());
 307 
 308     // Default event handling for Drag and Drop will be handled by DragController
 309     // so we leave the event for it.
 310     if (event.isDrop())
 311         return false;
 312 
 313     if (event.isPaste()) {
 314         if (event.pastingFragment()) {
 315 #if PLATFORM(IOS_FAMILY)
 316             if (client()-&gt;performsTwoStepPaste(event.pastingFragment()))
 317                 return true;
 318 #endif
 319             replaceSelectionWithFragment(*event.pastingFragment(), SelectReplacement::No, event.shouldSmartReplace() ? SmartReplace::Yes : SmartReplace::No, event.shouldMatchStyle() ? MatchStyle::Yes : MatchStyle::No, EditAction::Paste, event.mailBlockquoteHandling());
 320         } else
 321             replaceSelectionWithText(event.data(), SelectReplacement::No, event.shouldSmartReplace() ? SmartReplace::Yes : SmartReplace::No, EditAction::Paste);
</pre>
<hr />
<pre>
 336 {
 337     return m_frame.selection().selection().rootEditableElement();
 338 }
 339 
 340 bool Editor::canEditRichly() const
 341 {
 342     return m_frame.selection().selection().isContentRichlyEditable();
 343 }
 344 
 345 enum class ClipboardEventKind {
 346     Copy,
 347     Cut,
 348     Paste,
 349     PasteAsPlainText,
 350     PasteAsQuotation,
 351     BeforeCopy,
 352     BeforeCut,
 353     BeforePaste,
 354 };
 355 
<span class="line-modified"> 356 static AtomString eventNameForClipboardEvent(ClipboardEventKind kind)</span>
 357 {
 358     switch (kind) {
 359     case ClipboardEventKind::Copy:
 360         return eventNames().copyEvent;
 361     case ClipboardEventKind::Cut:
 362         return eventNames().cutEvent;
 363     case ClipboardEventKind::Paste:
 364     case ClipboardEventKind::PasteAsPlainText:
 365     case ClipboardEventKind::PasteAsQuotation:
 366         return eventNames().pasteEvent;
 367     case ClipboardEventKind::BeforeCopy:
 368         return eventNames().beforecopyEvent;
 369     case ClipboardEventKind::BeforeCut:
 370         return eventNames().beforecutEvent;
 371     case ClipboardEventKind::BeforePaste:
 372         return eventNames().beforepasteEvent;
 373     }
 374     ASSERT_NOT_REACHED();
 375     return { };
 376 }
 377 
 378 static Ref&lt;DataTransfer&gt; createDataTransferForClipboardEvent(Document&amp; document, ClipboardEventKind kind)
 379 {
 380     switch (kind) {
 381     case ClipboardEventKind::Copy:
 382     case ClipboardEventKind::Cut:
<span class="line-modified"> 383         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::ReadWrite, makeUnique&lt;StaticPasteboard&gt;());</span>
 384     case ClipboardEventKind::PasteAsPlainText:
 385         if (RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled()) {
 386             auto plainTextType = &quot;text/plain&quot;_s;
 387             auto plainText = Pasteboard::createForCopyAndPaste()-&gt;readString(plainTextType);
<span class="line-modified"> 388             auto pasteboard = makeUnique&lt;StaticPasteboard&gt;();</span>
 389             pasteboard-&gt;writeString(plainTextType, plainText);
 390             return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Readonly, WTFMove(pasteboard));
 391         }
 392         FALLTHROUGH;
 393     case ClipboardEventKind::Paste:
 394     case ClipboardEventKind::PasteAsQuotation:
 395         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Readonly, Pasteboard::createForCopyAndPaste());
 396     case ClipboardEventKind::BeforeCopy:
 397     case ClipboardEventKind::BeforeCut:
 398     case ClipboardEventKind::BeforePaste:
<span class="line-modified"> 399         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Invalid, makeUnique&lt;StaticPasteboard&gt;());</span>
 400     }
 401     ASSERT_NOT_REACHED();
<span class="line-modified"> 402     return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Invalid, makeUnique&lt;StaticPasteboard&gt;());</span>
 403 }
 404 
 405 // Returns whether caller should continue with &quot;the default processing&quot;, which is the same as
 406 // the event handler NOT setting the return value to false
 407 // https://w3c.github.io/clipboard-apis/#fire-a-clipboard-event
 408 static bool dispatchClipboardEvent(RefPtr&lt;Element&gt;&amp;&amp; target, ClipboardEventKind kind)
 409 {
 410     // FIXME: Move the target selection code here.
 411     if (!target)
 412         return true;
 413 
 414     auto dataTransfer = createDataTransferForClipboardEvent(target-&gt;document(), kind);
 415 
 416     auto event = ClipboardEvent::create(eventNameForClipboardEvent(kind), dataTransfer.copyRef());
 417 
 418     target-&gt;dispatchEvent(event);
 419     bool noDefaultProcessing = event-&gt;defaultPrevented();
 420     if (noDefaultProcessing &amp;&amp; (kind == ClipboardEventKind::Copy || kind == ClipboardEventKind::Cut)) {
 421         auto pasteboard = Pasteboard::createForCopyAndPaste();
 422         pasteboard-&gt;clear();
</pre>
<hr />
<pre>
 496 }
 497 
 498 bool Editor::canDeleteRange(Range* range) const
 499 {
 500     Node&amp; startContainer = range-&gt;startContainer();
 501     Node&amp; endContainer = range-&gt;endContainer();
 502 
 503     if (!startContainer.hasEditableStyle() || !endContainer.hasEditableStyle())
 504         return false;
 505 
 506     if (range-&gt;collapsed()) {
 507         VisiblePosition start(range-&gt;startPosition(), DOWNSTREAM);
 508         VisiblePosition previous = start.previous();
 509         // FIXME: We sometimes allow deletions at the start of editable roots, like when the caret is in an empty list item.
 510         if (previous.isNull() || previous.deepEquivalent().deprecatedNode()-&gt;rootEditableElement() != startContainer.rootEditableElement())
 511             return false;
 512     }
 513     return true;
 514 }
 515 
<span class="line-added"> 516 bool Editor::shouldSmartDelete()</span>
<span class="line-added"> 517 {</span>
<span class="line-added"> 518     if (behavior().shouldAlwaysSmartDelete())</span>
<span class="line-added"> 519         return true;</span>
<span class="line-added"> 520     return m_frame.selection().granularity() == WordGranularity;</span>
<span class="line-added"> 521 }</span>
<span class="line-added"> 522 </span>
 523 bool Editor::smartInsertDeleteEnabled()
 524 {
 525     return client() &amp;&amp; client()-&gt;smartInsertDeleteEnabled();
 526 }
 527 
 528 bool Editor::canSmartCopyOrDelete()
 529 {
<span class="line-modified"> 530     return client() &amp;&amp; client()-&gt;smartInsertDeleteEnabled() &amp;&amp; shouldSmartDelete();</span>
 531 }
 532 
 533 bool Editor::isSelectTrailingWhitespaceEnabled() const
 534 {
 535     return client() &amp;&amp; client()-&gt;isSelectTrailingWhitespaceEnabled();
 536 }
 537 
 538 bool Editor::deleteWithDirection(SelectionDirection direction, TextGranularity granularity, bool shouldAddToKillRing, bool isTypingAction)
 539 {
 540     if (!canEdit())
 541         return false;
 542 
 543     if (m_frame.selection().isRange()) {
 544         if (isTypingAction) {
 545             TypingCommand::deleteKeyPressed(document(), canSmartCopyOrDelete() ? TypingCommand::SmartDelete : 0, granularity);
 546             revealSelectionAfterEditingOperation();
 547         } else {
 548             if (shouldAddToKillRing)
 549                 addRangeToKillRing(*selectedRange().get(), KillRingInsertionMode::AppendText);
 550             deleteSelectionWithSmartDelete(canSmartCopyOrDelete());
</pre>
<hr />
<pre>
1039 void Editor::indent()
1040 {
1041     IndentOutdentCommand::create(document(), IndentOutdentCommand::Indent)-&gt;apply();
1042 }
1043 
1044 void Editor::outdent()
1045 {
1046     IndentOutdentCommand::create(document(), IndentOutdentCommand::Outdent)-&gt;apply();
1047 }
1048 
1049 static void notifyTextFromControls(Element* startRoot, Element* endRoot)
1050 {
1051     HTMLTextFormControlElement* startingTextControl = enclosingTextFormControl(firstPositionInOrBeforeNode(startRoot));
1052     HTMLTextFormControlElement* endingTextControl = enclosingTextFormControl(firstPositionInOrBeforeNode(endRoot));
1053     if (startingTextControl)
1054         startingTextControl-&gt;didEditInnerTextValue();
1055     if (endingTextControl &amp;&amp; startingTextControl != endingTextControl)
1056         endingTextControl-&gt;didEditInnerTextValue();
1057 }
1058 
<span class="line-modified">1059 static bool dispatchBeforeInputEvents(RefPtr&lt;Element&gt; startRoot, RefPtr&lt;Element&gt; endRoot, const AtomString&amp; inputTypeName, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { }, Event::IsCancelable cancelable = Event::IsCancelable::Yes)</span>
1060 {
1061     bool continueWithDefaultBehavior = true;
1062     if (startRoot)
1063         continueWithDefaultBehavior &amp;= dispatchBeforeInputEvent(*startRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges, cancelable);
1064     if (endRoot &amp;&amp; endRoot != startRoot)
1065         continueWithDefaultBehavior &amp;= dispatchBeforeInputEvent(*endRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges, cancelable);
1066     return continueWithDefaultBehavior;
1067 }
1068 
<span class="line-modified">1069 static void dispatchInputEvents(RefPtr&lt;Element&gt; startRoot, RefPtr&lt;Element&gt; endRoot, const AtomString&amp; inputTypeName, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { })</span>
1070 {
1071     if (startRoot)
1072         dispatchInputEvent(*startRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges);
1073     if (endRoot &amp;&amp; endRoot != startRoot)
1074         dispatchInputEvent(*endRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges);
1075 }
1076 
1077 bool Editor::willApplyEditing(CompositeEditCommand&amp; command, Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp;&amp; targetRanges) const
1078 {
1079     if (!command.shouldDispatchInputEvents())
1080         return true;
1081 
1082     auto* composition = command.composition();
1083     if (!composition)
1084         return true;
1085 
1086     return dispatchBeforeInputEvents(composition-&gt;startingRootEditableElement(), composition-&gt;endingRootEditableElement(), command.inputEventTypeName(),
1087         command.inputEventData(), command.inputEventDataTransfer(), targetRanges, command.isBeforeInputEventCancelable() ? Event::IsCancelable::Yes : Event::IsCancelable::No);
1088 }
1089 
</pre>
<hr />
<pre>
1166 void Editor::reappliedEditing(EditCommandComposition&amp; composition)
1167 {
1168     document().updateLayout();
1169 
1170     notifyTextFromControls(composition.startingRootEditableElement(), composition.endingRootEditableElement());
1171 
1172     VisibleSelection newSelection(composition.endingSelection());
1173     changeSelectionAfterCommand(newSelection, FrameSelection::defaultSetSelectionOptions());
1174     dispatchInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), &quot;historyRedo&quot;);
1175 
1176     updateEditorUINowIfScheduled();
1177 
1178     m_lastEditCommand = nullptr;
1179     if (auto* client = this-&gt;client())
1180         client-&gt;registerUndoStep(composition);
1181     respondToChangedContents(newSelection);
1182 }
1183 
1184 Editor::Editor(Frame&amp; frame)
1185     : m_frame(frame)
<span class="line-modified">1186     , m_killRing(makeUnique&lt;PAL::KillRing&gt;())</span>
<span class="line-modified">1187     , m_spellChecker(makeUnique&lt;SpellChecker&gt;(frame))</span>
<span class="line-modified">1188     , m_alternativeTextController(makeUnique&lt;AlternativeTextController&gt;(frame))</span>
1189     , m_editorUIUpdateTimer(*this, &amp;Editor::editorUIUpdateTimerFired)
1190 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
1191     , m_telephoneNumberDetectionUpdateTimer(*this, &amp;Editor::scanSelectionForTelephoneNumbers)
1192 #endif
1193 {
1194 }
1195 
1196 Editor::~Editor() = default;
1197 
1198 void Editor::clear()
1199 {
1200     m_lastEditCommand = nullptr;
1201     if (m_compositionNode) {
1202         m_compositionNode = nullptr;
1203         if (EditorClient* client = this-&gt;client())
1204             client-&gt;discardedComposition(&amp;m_frame);
1205     }
1206     m_customCompositionUnderlines.clear();
1207     m_shouldStyleWithCSS = false;
1208     m_defaultParagraphSeparator = EditorParagraphSeparatorIsDiv;
</pre>
<hr />
<pre>
1263         if (Node* selectionStart = selection.start().deprecatedNode()) {
1264             Ref&lt;Document&gt; document(selectionStart-&gt;document());
1265 
1266             // Insert the text
1267             if (triggeringEvent &amp;&amp; triggeringEvent-&gt;isDictation())
1268                 DictationCommand::insertText(document, text, triggeringEvent-&gt;dictationAlternatives(), selection);
1269             else {
1270                 TypingCommand::Options options = 0;
1271                 if (selectInsertedText)
1272                     options |= TypingCommand::SelectInsertedText;
1273                 if (autocorrectionWasApplied)
1274                     options |= TypingCommand::RetainAutocorrectionIndicator;
1275                 if (triggeringEvent &amp;&amp; triggeringEvent-&gt;isAutocompletion())
1276                     options |= TypingCommand::IsAutocompletion;
1277                 TypingCommand::insertText(document, text, selection, options, triggeringEvent &amp;&amp; triggeringEvent-&gt;isComposition() ? TypingCommand::TextCompositionFinal : TypingCommand::TextCompositionNone);
1278             }
1279 
1280             // Reveal the current selection
1281             if (Frame* editedFrame = document-&gt;frame())
1282                 if (Page* page = editedFrame-&gt;page()) {



1283                     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;

1284                     page-&gt;focusController().focusedOrMainFrame().selection().revealSelection(revealMode, ScrollAlignment::alignCenterIfNeeded);
1285                 }
1286         }
1287     }
1288 
1289     return true;
1290 }
1291 
1292 bool Editor::insertLineBreak()
1293 {
1294     if (!canEdit())
1295         return false;
1296 
1297     if (!shouldInsertText(&quot;\n&quot;, m_frame.selection().toNormalizedRange().get(), EditorInsertAction::Typed))
1298         return true;
1299 
1300     VisiblePosition caret = m_frame.selection().selection().visibleStart();
1301     bool alignToEdge = isEndOfEditableOrNonEditableContent(caret);
1302     bool autocorrectionIsApplied = m_alternativeTextController-&gt;applyAutocorrectionBeforeTypingIfAppropriate();
1303     TypingCommand::insertLineBreak(document(), autocorrectionIsApplied ? TypingCommand::RetainAutocorrectionIndicator : 0);
</pre>
<hr />
<pre>
1446 }
1447 
1448 void Editor::pasteAsQuotation()
1449 {
1450     if (!dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::PasteAsQuotation))
1451         return;
1452     if (!canPaste())
1453         return;
1454     updateMarkersForWordsAffectedByEditing(false);
1455     ResourceCacheValidationSuppressor validationSuppressor(document().cachedResourceLoader());
1456     auto pasteboard = Pasteboard::createForCopyAndPaste();
1457     if (m_frame.selection().selection().isContentRichlyEditable())
1458         pasteWithPasteboard(pasteboard.get(), { PasteOption::AllowPlainText, PasteOption::AsQuotation });
1459     else
1460         pasteAsPlainTextWithPasteboard(*pasteboard);
1461 }
1462 
1463 void Editor::quoteFragmentForPasting(DocumentFragment&amp; fragment)
1464 {
1465     auto blockQuote = HTMLQuoteElement::create(blockquoteTag, document());
<span class="line-modified">1466     blockQuote-&gt;setAttributeWithoutSynchronization(typeAttr, AtomString(&quot;cite&quot;));</span>
<span class="line-modified">1467     blockQuote-&gt;setAttributeWithoutSynchronization(classAttr, AtomString(ApplePasteAsQuotation));</span>
1468 
1469     auto childNode = fragment.firstChild();
1470 
1471     if (childNode) {
1472         while (childNode) {
1473             blockQuote-&gt;appendChild(*childNode);
1474             childNode = fragment.firstChild();
1475         }
1476     } else
1477         blockQuote-&gt;appendChild(HTMLBRElement::create(document()));
1478 
1479     fragment.appendChild(blockQuote);
1480 }
1481 
1482 void Editor::performDelete()
1483 {
1484     if (!canDelete()) {
1485         PAL::systemBeep();
1486         return;
1487     }
</pre>
<hr />
<pre>
1783 void Editor::toggleUnderline()
1784 {
1785     command(&quot;ToggleUnderline&quot;).execute();
1786 }
1787 
1788 void Editor::setBaseWritingDirection(WritingDirection direction)
1789 {
1790 #if PLATFORM(IOS_FAMILY)
1791     if (inSameParagraph(m_frame.selection().selection().visibleStart(), m_frame.selection().selection().visibleEnd()) &amp;&amp;
1792         baseWritingDirectionForSelectionStart() == direction)
1793         return;
1794 #endif
1795 
1796     Element* focusedElement = document().focusedElement();
1797     if (focusedElement &amp;&amp; focusedElement-&gt;isTextField()) {
1798         if (direction == WritingDirection::Natural)
1799             return;
1800 
1801         auto&amp; focusedFormElement = downcast&lt;HTMLTextFormControlElement&gt;(*focusedElement);
1802         auto directionValue = direction == WritingDirection::LeftToRight ? &quot;ltr&quot; : &quot;rtl&quot;;
<span class="line-modified">1803         auto writingDirectionInputTypeName = inputTypeNameForEditingAction(EditAction::SetBlockWritingDirection);</span>
1804         if (!dispatchBeforeInputEvent(focusedFormElement, writingDirectionInputTypeName, directionValue))
1805             return;
1806 
1807         focusedFormElement.setAttributeWithoutSynchronization(dirAttr, directionValue);
1808         dispatchInputEvent(focusedFormElement, writingDirectionInputTypeName, directionValue);
1809         document().updateStyleIfNeeded();
1810         return;
1811     }
1812 
1813     auto style = MutableStyleProperties::create();
1814     style-&gt;setProperty(CSSPropertyDirection, direction == WritingDirection::LeftToRight ? &quot;ltr&quot; : direction == WritingDirection::RightToLeft ? &quot;rtl&quot; : &quot;inherit&quot;, false);
<span class="line-modified">1815     applyParagraphStyleToSelection(style.ptr(), EditAction::SetBlockWritingDirection);</span>
1816 }
1817 
1818 WritingDirection Editor::baseWritingDirectionForSelectionStart() const
1819 {
1820     auto result = WritingDirection::LeftToRight;
1821 
1822     Position pos = m_frame.selection().selection().visibleStart().deepEquivalent();
1823     Node* node = pos.deprecatedNode();
1824     if (!node)
1825         return result;
1826 
1827     auto renderer = node-&gt;renderer();
1828     if (!renderer)
1829         return result;
1830 
1831     if (!renderer-&gt;isRenderBlockFlow()) {
1832         renderer = renderer-&gt;containingBlock();
1833         if (!renderer)
1834             return result;
1835     }
</pre>
<hr />
<pre>
2387     if (!client())
2388         return false;
2389     return client()-&gt;spellingUIIsShowing();
2390 }
2391 
2392 void Editor::clearMisspellingsAndBadGrammar(const VisibleSelection&amp; movingSelection)
2393 {
2394     if (auto selectedRange = movingSelection.toNormalizedRange())
2395         document().markers().removeMarkers(*selectedRange, { DocumentMarker::Spelling, DocumentMarker::Grammar });
2396 }
2397 
2398 void Editor::markMisspellingsAndBadGrammar(const VisibleSelection &amp;movingSelection)
2399 {
2400     markMisspellingsAndBadGrammar(movingSelection, isContinuousSpellCheckingEnabled() &amp;&amp; isGrammarCheckingEnabled(), movingSelection);
2401 }
2402 
2403 void Editor::markMisspellingsAfterTypingToWord(const VisiblePosition &amp;wordStart, const VisibleSelection&amp; selectionAfterTyping, bool doReplacement)
2404 {
2405     Ref&lt;Frame&gt; protection(m_frame);
2406 
<span class="line-added">2407     if (platformDrivenTextCheckerEnabled())</span>
<span class="line-added">2408         return;</span>
<span class="line-added">2409 </span>
2410 #if PLATFORM(IOS_FAMILY)
2411     UNUSED_PARAM(selectionAfterTyping);
2412     UNUSED_PARAM(doReplacement);
2413     OptionSet&lt;TextCheckingType&gt; textCheckingOptions;
2414     if (isContinuousSpellCheckingEnabled())
2415         textCheckingOptions.add(TextCheckingType::Spelling);
2416     if (!textCheckingOptions.contains(TextCheckingType::Spelling))
2417         return;
2418 
2419     VisibleSelection adjacentWords = VisibleSelection(startOfWord(wordStart, LeftWordIfOnBoundary), endOfWord(wordStart, RightWordIfOnBoundary));
2420     auto adjacentWordRange = adjacentWords.toNormalizedRange();
2421     markAllMisspellingsAndBadGrammarInRanges(textCheckingOptions, adjacentWordRange.copyRef(), adjacentWordRange.copyRef(), adjacentWordRange.copyRef());
2422 #else
2423 #if !USE(AUTOMATIC_TEXT_REPLACEMENT)
2424     UNUSED_PARAM(doReplacement);
2425 #endif
2426 
2427     if (unifiedTextCheckerEnabled()) {
2428         m_alternativeTextController-&gt;applyPendingCorrection(selectionAfterTyping);
2429 
</pre>
<hr />
<pre>
2612     return isSpellCheckingEnabledFor(m_frame.selection().selection().start().deprecatedNode());
2613 }
2614 
2615 void Editor::markMisspellings(const VisibleSelection&amp; selection, RefPtr&lt;Range&gt;&amp; firstMisspellingRange)
2616 {
2617     markMisspellingsOrBadGrammar(selection, true, firstMisspellingRange);
2618 }
2619 
2620 void Editor::markBadGrammar(const VisibleSelection&amp; selection)
2621 {
2622 #if USE(GRAMMAR_CHECKING)
2623     RefPtr&lt;Range&gt; firstMisspellingRange;
2624     markMisspellingsOrBadGrammar(selection, false, firstMisspellingRange);
2625 #else
2626     ASSERT_NOT_REACHED();
2627 #endif
2628 }
2629 
2630 void Editor::markAllMisspellingsAndBadGrammarInRanges(OptionSet&lt;TextCheckingType&gt; textCheckingOptions, RefPtr&lt;Range&gt;&amp;&amp; spellingRange, RefPtr&lt;Range&gt;&amp;&amp; automaticReplacementRange, RefPtr&lt;Range&gt;&amp;&amp; grammarRange)
2631 {
<span class="line-added">2632     if (platformDrivenTextCheckerEnabled())</span>
<span class="line-added">2633         return;</span>
<span class="line-added">2634 </span>
2635     ASSERT(unifiedTextCheckerEnabled());
2636 
2637     // There shouldn&#39;t be pending autocorrection at this moment.
2638     ASSERT(!m_alternativeTextController-&gt;hasPendingCorrection());
2639 
2640     bool shouldMarkGrammar = textCheckingOptions.contains(TextCheckingType::Grammar);
2641     bool shouldShowCorrectionPanel = textCheckingOptions.contains(TextCheckingType::ShowCorrectionPanel);
2642 
2643     // This function is called with selections already expanded to word boundaries.
2644     if (!client() || !spellingRange || (shouldMarkGrammar &amp;&amp; !grammarRange))
2645         return;
2646 
2647     // If we&#39;re not in an editable node, bail.
2648     Node&amp; editableNode = spellingRange-&gt;startContainer();
2649     if (!editableNode.hasEditableStyle())
2650         return;
2651 
2652     if (!isSpellCheckingEnabledFor(&amp;editableNode))
2653         return;
2654 
</pre>
<hr />
<pre>
2678 
2679 static bool isAutomaticTextReplacementType(TextCheckingType type)
2680 {
2681     switch (type) {
2682     case TextCheckingType::None:
2683     case TextCheckingType::Spelling:
2684     case TextCheckingType::Grammar:
2685         return false;
2686     case TextCheckingType::Link:
2687     case TextCheckingType::Quote:
2688     case TextCheckingType::Dash:
2689     case TextCheckingType::Replacement:
2690     case TextCheckingType::Correction:
2691     case TextCheckingType::ShowCorrectionPanel:
2692         return true;
2693     }
2694     ASSERT_NOT_REACHED();
2695     return false;
2696 }
2697 
<span class="line-added">2698 void Editor::replaceRangeForSpellChecking(Range&amp; rangeToReplace, const String&amp; replacement)</span>
<span class="line-added">2699 {</span>
<span class="line-added">2700     SpellingCorrectionCommand::create(rangeToReplace, replacement)-&gt;apply();</span>
<span class="line-added">2701 }</span>
<span class="line-added">2702 </span>
2703 static void correctSpellcheckingPreservingTextCheckingParagraph(TextCheckingParagraph&amp; paragraph, Range&amp; rangeToReplace, const String&amp; replacement, int resultLocation, int resultLength)
2704 {
2705     auto&amp; scope = downcast&lt;ContainerNode&gt;(paragraph.paragraphRange().startContainer().rootNode());
2706 
2707     size_t paragraphLocation;
2708     size_t paragraphLength;
2709     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;paragraph.paragraphRange(), paragraphLocation, paragraphLength);
2710 
2711     SpellingCorrectionCommand::create(rangeToReplace, replacement)-&gt;apply();
2712 
2713     // TextCheckingParagraph may be orphaned after SpellingCorrectionCommand mutated DOM.
2714     // See &lt;rdar://10305315&gt;, http://webkit.org/b/89526.
2715 
2716     RefPtr&lt;Range&gt; newParagraphRange = TextIterator::rangeFromLocationAndLength(&amp;scope, paragraphLocation, paragraphLength + replacement.length() - resultLength);
2717 
2718     auto spellCheckingRange = TextIterator::subrange(*newParagraphRange, resultLocation, replacement.length());
2719     paragraph = TextCheckingParagraph(spellCheckingRange.copyRef(), spellCheckingRange.copyRef(), newParagraphRange.get());
2720 }
2721 
2722 void Editor::markAndReplaceFor(const SpellCheckRequest&amp; request, const Vector&lt;TextCheckingResult&gt;&amp; results)
</pre>
<hr />
<pre>
2895 
2896     RefPtr&lt;Range&gt; selection = selectedRange();
2897     if (!shouldInsertText(replacedString, selection.get(), EditorInsertAction::Pasted))
2898         return;
2899 
2900     m_alternativeTextController-&gt;recordAutocorrectionResponse(AutocorrectionResponse::Reverted, replacedString, selection.get());
2901     TextCheckingParagraph paragraph(*selection);
2902     replaceSelectionWithText(replacedString, SelectReplacement::No, SmartReplace::No, EditAction::Insert);
2903     auto changedRange = paragraph.subrange(paragraph.checkingStart(), replacedString.length());
2904     changedRange-&gt;startContainer().document().markers().addMarker(changedRange, DocumentMarker::Replacement, String());
2905     m_alternativeTextController-&gt;markReversed(changedRange);
2906 #else
2907     ASSERT_NOT_REACHED();
2908     UNUSED_PARAM(replacedString);
2909 #endif // !PLATFORM(IOS_FAMILY)
2910 }
2911 
2912 
2913 void Editor::markMisspellingsAndBadGrammar(const VisibleSelection&amp; spellingSelection, bool markGrammar, const VisibleSelection&amp; grammarSelection)
2914 {
<span class="line-added">2915     if (platformDrivenTextCheckerEnabled())</span>
<span class="line-added">2916         return;</span>
<span class="line-added">2917 </span>
2918     if (unifiedTextCheckerEnabled()) {
2919         if (!isContinuousSpellCheckingEnabled())
2920             return;
2921 
2922         // markMisspellingsAndBadGrammar() is triggered by selection change, in which case we check spelling and grammar, but don&#39;t autocorrect misspellings.
2923         OptionSet&lt;TextCheckingType&gt; textCheckingOptions { TextCheckingType::Spelling };
2924         if (markGrammar &amp;&amp; isGrammarCheckingEnabled())
2925             textCheckingOptions.add(TextCheckingType::Grammar);
2926         auto spellCheckingRange = spellingSelection.toNormalizedRange();
2927         markAllMisspellingsAndBadGrammarInRanges(textCheckingOptions, spellCheckingRange.copyRef(), spellCheckingRange.copyRef(), grammarSelection.toNormalizedRange());
2928         return;
2929     }
2930 
2931     RefPtr&lt;Range&gt; firstMisspellingRange;
2932     markMisspellings(spellingSelection, firstMisspellingRange);
2933     if (markGrammar)
2934         markBadGrammar(grammarSelection);
2935 }
2936 
2937 void Editor::unappliedSpellCorrection(const VisibleSelection&amp; selectionOfCorrected, const String&amp; corrected, const String&amp; correction)
</pre>
<hr />
<pre>
3034     Document* document = m_frame.documentAtPoint(windowPoint);
3035     if (!document)
3036         return nullptr;
3037 
3038     Frame* frame = document-&gt;frame();
3039     ASSERT(frame);
3040     FrameView* frameView = frame-&gt;view();
3041     if (!frameView)
3042         return nullptr;
3043     IntPoint framePoint = frameView-&gt;windowToContents(windowPoint);
3044     VisibleSelection selection(frame-&gt;visiblePositionForPoint(framePoint));
3045 
3046     return selection.toNormalizedRange();
3047 }
3048 
3049 void Editor::revealSelectionAfterEditingOperation(const ScrollAlignment&amp; alignment, RevealExtentOption revealExtentOption)
3050 {
3051     if (m_ignoreSelectionChanges)
3052         return;
3053 



3054     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;


3055     m_frame.selection().revealSelection(revealMode, alignment, revealExtentOption);
3056 }
3057 
3058 void Editor::setIgnoreSelectionChanges(bool ignore, RevealSelection shouldRevealExistingSelection)
3059 {
3060     if (m_ignoreSelectionChanges == ignore)
3061         return;
3062 
3063     m_ignoreSelectionChanges = ignore;
3064 #if PLATFORM(IOS_FAMILY)
3065     // FIXME: Should suppress selection change notifications during a composition change &lt;https://webkit.org/b/38830&gt;
3066     if (!ignore)
3067         respondToChangedSelection(m_frame.selection().selection(), { });
3068 #endif
3069     if (!ignore &amp;&amp; shouldRevealExistingSelection == RevealSelection::Yes)
3070         revealSelectionAfterEditingOperation(ScrollAlignment::alignToEdgeIfNeeded, RevealExtent);
3071 }
3072 
3073 RefPtr&lt;Range&gt; Editor::compositionRange() const
3074 {
3075     if (!m_compositionNode)
3076         return nullptr;
3077     unsigned length = m_compositionNode-&gt;length();
3078     unsigned start = std::min(m_compositionStart, length);
3079     unsigned end = std::min(std::max(start, m_compositionEnd), length);
<span class="line-added">3080     // FIXME: Why is this early return neeed?</span>
3081     if (start &gt;= end)
3082         return nullptr;
3083     return Range::create(m_compositionNode-&gt;document(), m_compositionNode.get(), start, m_compositionNode.get(), end);
3084 }
3085 
3086 bool Editor::getCompositionSelection(unsigned&amp; selectionStart, unsigned&amp; selectionEnd) const
3087 {
3088     if (!m_compositionNode)
3089         return false;
3090     const VisibleSelection&amp; selection = m_frame.selection().selection();
3091     Position start = selection.start();
3092     if (start.deprecatedNode() != m_compositionNode)
3093         return false;
3094     Position end = selection.end();
3095     if (end.deprecatedNode() != m_compositionNode)
3096         return false;
3097 
3098     if (static_cast&lt;unsigned&gt;(start.deprecatedEditingOffset()) &lt; m_compositionStart)
3099         return false;
3100     if (static_cast&lt;unsigned&gt;(end.deprecatedEditingOffset()) &gt; m_compositionEnd)
</pre>
<hr />
<pre>
4248     Node* pastEnd = range-&gt;pastLastNode();
4249     // In the loop below, node should eventually match pastEnd and not become null, but we&#39;ve seen at least one
4250     // unreproducible case where this didn&#39;t happen, so check for null also.
4251     for (Node* node = startNode; node &amp;&amp; node != pastEnd; node = NodeTraversal::next(*node)) {
4252         auto renderer = node-&gt;renderer();
4253         if (!renderer)
4254             continue;
4255         // FIXME: Are there any node types that have renderers, but that we should be skipping?
4256         const Font&amp; primaryFont = renderer-&gt;style().fontCascade().primaryFont();
4257         if (!font)
4258             font = &amp;primaryFont;
4259         else if (font != &amp;primaryFont) {
4260             hasMultipleFonts = true;
4261             break;
4262         }
4263     }
4264 
4265     return font;
4266 }
4267 








4268 RefPtr&lt;HTMLImageElement&gt; Editor::insertEditableImage()
4269 {
4270     return InsertEditableImageCommand::insertEditableImage(document());
4271 }
4272 
4273 bool Editor::canCopyExcludingStandaloneImages() const
4274 {
4275     auto&amp; selection = m_frame.selection().selection();
4276     return selection.isRange() &amp;&amp; !selection.isInPasswordField();
4277 }
4278 
4279 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="EditingStyle.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Editor.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>