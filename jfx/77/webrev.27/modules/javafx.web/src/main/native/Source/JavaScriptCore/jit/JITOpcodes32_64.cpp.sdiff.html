<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOpcodes32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITOpcodes.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOperations.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOpcodes32_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 363 
 364     emitLoad(src, regT1, regT0);
 365     addSlowCase(branchIfNotBoolean(regT1, InvalidGPRReg));
 366     xor32(TrustedImm32(1), regT0);
 367 
 368     emitStoreBool(dst, regT0, (dst == src));
 369 }
 370 
 371 void JIT::emit_op_jfalse(const Instruction* currentInstruction)
 372 {
 373     auto bytecode = currentInstruction-&gt;as&lt;OpJfalse&gt;();
 374     int cond = bytecode.m_condition.offset();
 375     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
 376 
 377     emitLoad(cond, regT1, regT0);
 378 
 379     JSValueRegs value(regT1, regT0);
 380     GPRReg scratch1 = regT2;
 381     GPRReg scratch2 = regT3;
 382     bool shouldCheckMasqueradesAsUndefined = true;
<span class="line-modified"> 383     addJump(branchIfFalsey(*vm(), value, scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);</span>
 384 }
 385 
 386 void JIT::emit_op_jtrue(const Instruction* currentInstruction)
 387 {
 388     auto bytecode = currentInstruction-&gt;as&lt;OpJtrue&gt;();
 389     int cond = bytecode.m_condition.offset();
 390     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
 391 
 392     emitLoad(cond, regT1, regT0);
 393     bool shouldCheckMasqueradesAsUndefined = true;
 394     JSValueRegs value(regT1, regT0);
 395     GPRReg scratch1 = regT2;
 396     GPRReg scratch2 = regT3;
<span class="line-modified"> 397     addJump(branchIfTruthy(*vm(), value, scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);</span>
 398 }
 399 
 400 void JIT::emit_op_jeq_null(const Instruction* currentInstruction)
 401 {
 402     auto bytecode = currentInstruction-&gt;as&lt;OpJeqNull&gt;();
 403     int src = bytecode.m_value.offset();
 404     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
 405 
 406     emitLoad(src, regT1, regT0);
 407 
 408     Jump isImmediate = branchIfNotCell(regT1);
 409 
 410     Jump isNotMasqueradesAsUndefined = branchTest8(Zero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
 411     loadPtr(Address(regT0, JSCell::structureIDOffset()), regT2);
 412     move(TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0);
 413     addJump(branchPtr(Equal, Address(regT2, Structure::globalObjectOffset()), regT0), target);
 414     Jump masqueradesGlobalObjectIsForeign = jump();
 415 
 416     // Now handle the immediate cases - undefined &amp; null
 417     isImmediate.link(this);
</pre>
<hr />
<pre>
 432     emitLoad(src, regT1, regT0);
 433 
 434     Jump isImmediate = branchIfNotCell(regT1);
 435 
 436     addJump(branchTest8(Zero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined)), target);
 437     loadPtr(Address(regT0, JSCell::structureIDOffset()), regT2);
 438     move(TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0);
 439     addJump(branchPtr(NotEqual, Address(regT2, Structure::globalObjectOffset()), regT0), target);
 440     Jump wasNotImmediate = jump();
 441 
 442     // Now handle the immediate cases - undefined &amp; null
 443     isImmediate.link(this);
 444 
 445     static_assert((JSValue::UndefinedTag + 1 == JSValue::NullTag) &amp;&amp; (JSValue::NullTag &amp; 0x1), &quot;&quot;);
 446     or32(TrustedImm32(1), regT1);
 447     addJump(branchIfNotNull(regT1), target);
 448 
 449     wasNotImmediate.link(this);
 450 }
 451 
























 452 void JIT::emit_op_jneq_ptr(const Instruction* currentInstruction)
 453 {
 454     auto bytecode = currentInstruction-&gt;as&lt;OpJneqPtr&gt;();
 455     auto&amp; metadata = bytecode.metadata(m_codeBlock);
 456     int src = bytecode.m_value.offset();
 457     Special::Pointer ptr = bytecode.m_specialPointer;
 458     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
 459 
 460     emitLoad(src, regT1, regT0);
 461     Jump notCell = branchIfNotCell(regT1);
 462     Jump equal = branchPtr(Equal, regT0, TrustedImmPtr(actualPointerFor(m_codeBlock, ptr)));
 463     notCell.link(this);
 464     store8(TrustedImm32(1), &amp;metadata.m_hasJumped);
 465     addJump(jump(), target);
 466     equal.link(this);
 467 }
 468 
 469 void JIT::emit_op_eq(const Instruction* currentInstruction)
 470 {
 471     auto bytecode = currentInstruction-&gt;as&lt;OpEq&gt;();
</pre>
<hr />
<pre>
 774     loadPtr(Address(regT2, Structure::globalObjectOffset()), regT2);
 775     compare32(NotEqual, regT0, regT2, regT1);
 776     Jump wasNotImmediate = jump();
 777 
 778     isImmediate.link(this);
 779 
 780     compare32(NotEqual, regT1, TrustedImm32(JSValue::NullTag), regT2);
 781     compare32(NotEqual, regT1, TrustedImm32(JSValue::UndefinedTag), regT1);
 782     and32(regT2, regT1);
 783 
 784     wasNotImmediate.link(this);
 785     wasNotMasqueradesAsUndefined.link(this);
 786 
 787     emitStoreBool(dst, regT1);
 788 }
 789 
 790 void JIT::emit_op_throw(const Instruction* currentInstruction)
 791 {
 792     auto bytecode = currentInstruction-&gt;as&lt;OpThrow&gt;();
 793     ASSERT(regT0 == returnValueGPR);
<span class="line-modified"> 794     copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm()-&gt;topEntryFrame);</span>
 795     emitLoad(bytecode.m_value.offset(), regT1, regT0);
 796     callOperationNoExceptionCheck(operationThrow, JSValueRegs(regT1, regT0));
<span class="line-modified"> 797     jumpToExceptionHandler(*vm());</span>
 798 }
 799 
 800 void JIT::emit_op_to_number(const Instruction* currentInstruction)
 801 {
 802     auto bytecode = currentInstruction-&gt;as&lt;OpToNumber&gt;();
 803     int dst = bytecode.m_dst.offset();
 804     int src = bytecode.m_operand.offset();
 805 
 806     emitLoad(src, regT1, regT0);
 807 
 808     Jump isInt32 = branchIfInt32(regT1);
 809     addSlowCase(branch32(AboveOrEqual, regT1, TrustedImm32(JSValue::LowestTag)));
 810     isInt32.link(this);
 811 
 812     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 813     if (src != dst)
 814         emitStore(dst, regT1, regT0);
 815 }
 816 
 817 void JIT::emit_op_to_string(const Instruction* currentInstruction)
</pre>
<hr />
<pre>
 832 void JIT::emit_op_to_object(const Instruction* currentInstruction)
 833 {
 834     auto bytecode = currentInstruction-&gt;as&lt;OpToObject&gt;();
 835     int dst = bytecode.m_dst.offset();
 836     int src = bytecode.m_operand.offset();
 837 
 838     emitLoad(src, regT1, regT0);
 839 
 840     addSlowCase(branchIfNotCell(regT1));
 841     addSlowCase(branchIfNotObject(regT0));
 842 
 843     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 844     if (src != dst)
 845         emitStore(dst, regT1, regT0);
 846 }
 847 
 848 void JIT::emit_op_catch(const Instruction* currentInstruction)
 849 {
 850     auto bytecode = currentInstruction-&gt;as&lt;OpCatch&gt;();
 851 
<span class="line-modified"> 852     restoreCalleeSavesFromEntryFrameCalleeSavesBuffer(vm()-&gt;topEntryFrame);</span>
 853 
 854     move(TrustedImmPtr(m_vm), regT3);
 855     // operationThrow returns the callFrame for the handler.
 856     load32(Address(regT3, VM::callFrameForCatchOffset()), callFrameRegister);
 857     storePtr(TrustedImmPtr(nullptr), Address(regT3, VM::callFrameForCatchOffset()));
 858 
 859     addPtr(TrustedImm32(stackPointerOffsetFor(codeBlock()) * sizeof(Register)), callFrameRegister, stackPointerRegister);
 860 
 861     callOperationNoExceptionCheck(operationCheckIfExceptionIsUncatchableAndNotifyProfiler);
 862     Jump isCatchableException = branchTest32(Zero, returnValueGPR);
<span class="line-modified"> 863     jumpToExceptionHandler(*vm());</span>
 864     isCatchableException.link(this);
 865 
 866     move(TrustedImmPtr(m_vm), regT3);
 867 
 868     // Now store the exception returned by operationThrow.
 869     load32(Address(regT3, VM::exceptionOffset()), regT2);
 870     move(TrustedImm32(JSValue::CellTag), regT1);
 871 
 872     store32(TrustedImm32(0), Address(regT3, VM::exceptionOffset()));
 873 
 874     unsigned exception = bytecode.m_exception.offset();
 875     emitStore(exception, regT1, regT2);
 876 
 877     load32(Address(regT2, Exception::valueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), regT0);
 878     load32(Address(regT2, Exception::valueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), regT1);
 879 
 880     unsigned thrownValue = bytecode.m_thrownValue.offset();
 881     emitStore(thrownValue, regT1, regT0);
 882 
 883 #if ENABLE(DFG_JIT)
 884     // FIXME: consider inline caching the process of doing OSR entry, including
 885     // argument type proofs, storing locals to the buffer, etc
 886     // https://bugs.webkit.org/show_bug.cgi?id=175598
 887 
 888     auto&amp; metadata = bytecode.metadata(m_codeBlock);
 889     ValueProfileAndOperandBuffer* buffer = metadata.m_buffer;
 890     if (buffer || !shouldEmitProfiling())
 891         callOperation(operationTryOSREnterAtCatch, m_bytecodeOffset);
 892     else
 893         callOperation(operationTryOSREnterAtCatchAndValueProfile, m_bytecodeOffset);
 894     auto skipOSREntry = branchTestPtr(Zero, returnValueGPR);
 895     emitRestoreCalleeSaves();
<span class="line-modified"> 896     jump(returnValueGPR, NoPtrTag);</span>
 897     skipOSREntry.link(this);
 898     if (buffer &amp;&amp; shouldEmitProfiling()) {
 899         buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {
 900             JSValueRegs regs(regT1, regT0);
 901             emitGetVirtualRegister(profile.m_operand, regs);
<span class="line-modified"> 902             emitValueProfilingSite(profile.m_profile);</span>
 903         });
 904     }
 905 #endif // ENABLE(DFG_JIT)
 906 }
 907 
 908 void JIT::emit_op_identity_with_profile(const Instruction*)
 909 {
 910     // We don&#39;t need to do anything here...
 911 }
 912 
 913 void JIT::emit_op_get_parent_scope(const Instruction* currentInstruction)
 914 {
 915     auto bytecode = currentInstruction-&gt;as&lt;OpGetParentScope&gt;();
 916     int currentScope = bytecode.m_scope.offset();
 917     emitLoadPayload(currentScope, regT0);
 918     loadPtr(Address(regT0, JSScope::offsetOfNext()), regT0);
 919     emitStoreCell(bytecode.m_dst.offset(), regT0);
 920 }
 921 
 922 void JIT::emit_op_switch_imm(const Instruction* currentInstruction)
 923 {
 924     auto bytecode = currentInstruction-&gt;as&lt;OpSwitchImm&gt;();
 925     size_t tableIndex = bytecode.m_tableIndex;
 926     unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
 927     unsigned scrutinee = bytecode.m_scrutinee.offset();
 928 
 929     // create jump table for switch destinations, track this switch statement.
 930     SimpleJumpTable* jumpTable = &amp;m_codeBlock-&gt;switchJumpTable(tableIndex);
 931     m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Immediate));
 932     jumpTable-&gt;ensureCTITable();
 933 
 934     emitLoad(scrutinee, regT1, regT0);
 935     callOperation(operationSwitchImmWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);
<span class="line-modified"> 936     jump(returnValueGPR, NoPtrTag);</span>
 937 }
 938 
 939 void JIT::emit_op_switch_char(const Instruction* currentInstruction)
 940 {
 941     auto bytecode = currentInstruction-&gt;as&lt;OpSwitchChar&gt;();
 942     size_t tableIndex = bytecode.m_tableIndex;
 943     unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
 944     unsigned scrutinee = bytecode.m_scrutinee.offset();
 945 
 946     // create jump table for switch destinations, track this switch statement.
 947     SimpleJumpTable* jumpTable = &amp;m_codeBlock-&gt;switchJumpTable(tableIndex);
 948     m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Character));
 949     jumpTable-&gt;ensureCTITable();
 950 
 951     emitLoad(scrutinee, regT1, regT0);
 952     callOperation(operationSwitchCharWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);
<span class="line-modified"> 953     jump(returnValueGPR, NoPtrTag);</span>
 954 }
 955 
 956 void JIT::emit_op_switch_string(const Instruction* currentInstruction)
 957 {
 958     auto bytecode = currentInstruction-&gt;as&lt;OpSwitchString&gt;();
 959     size_t tableIndex = bytecode.m_tableIndex;
 960     unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
 961     unsigned scrutinee = bytecode.m_scrutinee.offset();
 962 
 963     // create jump table for switch destinations, track this switch statement.
 964     StringJumpTable* jumpTable = &amp;m_codeBlock-&gt;stringSwitchJumpTable(tableIndex);
 965     m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset));
 966 
 967     emitLoad(scrutinee, regT1, regT0);
 968     callOperation(operationSwitchStringWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);
<span class="line-modified"> 969     jump(returnValueGPR, NoPtrTag);</span>
 970 }
 971 
 972 void JIT::emit_op_debug(const Instruction* currentInstruction)
 973 {
 974     auto bytecode = currentInstruction-&gt;as&lt;OpDebug&gt;();
 975     load32(codeBlock()-&gt;debuggerRequestsAddress(), regT0);
 976     Jump noDebuggerRequests = branchTest32(Zero, regT0);
 977     callOperation(operationDebug, static_cast&lt;int&gt;(bytecode.m_debugHookType));
 978     noDebuggerRequests.link(this);
 979 }
 980 
<span class="line-removed"> 981 </span>
<span class="line-removed"> 982 void JIT::emit_op_enter(const Instruction* currentInstruction)</span>
<span class="line-removed"> 983 {</span>
<span class="line-removed"> 984     emitEnterOptimizationCheck();</span>
<span class="line-removed"> 985 </span>
<span class="line-removed"> 986     // Even though JIT code doesn&#39;t use them, we initialize our constant</span>
<span class="line-removed"> 987     // registers to zap stale pointers, to avoid unnecessarily prolonging</span>
<span class="line-removed"> 988     // object lifetime and increasing GC pressure.</span>
<span class="line-removed"> 989     for (int i = CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters(); i &lt; m_codeBlock-&gt;numVars(); ++i)</span>
<span class="line-removed"> 990         emitStore(virtualRegisterForLocal(i).offset(), jsUndefined());</span>
<span class="line-removed"> 991 </span>
<span class="line-removed"> 992     JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_enter);</span>
<span class="line-removed"> 993     slowPathCall.call();</span>
<span class="line-removed"> 994 }</span>
<span class="line-removed"> 995 </span>
 996 void JIT::emit_op_get_scope(const Instruction* currentInstruction)
 997 {
 998     auto bytecode = currentInstruction-&gt;as&lt;OpGetScope&gt;();
 999     int dst = bytecode.m_dst.offset();
1000     emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, regT0);
1001     loadPtr(Address(regT0, JSFunction::offsetOfScopeChain()), regT0);
1002     emitStoreCell(dst, regT0);
1003 }
1004 
1005 void JIT::emit_op_create_this(const Instruction* currentInstruction)
1006 {
1007     auto bytecode = currentInstruction-&gt;as&lt;OpCreateThis&gt;();
1008     auto&amp; metadata = bytecode.metadata(m_codeBlock);
1009     int callee = bytecode.m_callee.offset();
1010     WriteBarrierBase&lt;JSCell&gt;* cachedFunction = &amp;metadata.m_cachedCallee;
1011     RegisterID calleeReg = regT0;
1012     RegisterID rareDataReg = regT4;
1013     RegisterID resultReg = regT0;
1014     RegisterID allocatorReg = regT1;
1015     RegisterID structureReg = regT2;
1016     RegisterID cachedFunctionReg = regT4;
1017     RegisterID scratchReg = regT3;
1018 
1019     emitLoadPayload(callee, calleeReg);
1020     addSlowCase(branchIfNotFunction(calleeReg));
1021     loadPtr(Address(calleeReg, JSFunction::offsetOfRareData()), rareDataReg);
1022     addSlowCase(branchTestPtr(Zero, rareDataReg));
<span class="line-modified">1023     load32(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfAllocator()), allocatorReg);</span>
<span class="line-modified">1024     loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfStructure()), structureReg);</span>
1025 
1026     loadPtr(cachedFunction, cachedFunctionReg);
1027     Jump hasSeenMultipleCallees = branchPtr(Equal, cachedFunctionReg, TrustedImmPtr(JSCell::seenMultipleCalleeObjects()));
1028     addSlowCase(branchPtr(NotEqual, calleeReg, cachedFunctionReg));
1029     hasSeenMultipleCallees.link(this);
1030 
1031     JumpList slowCases;
1032     auto butterfly = TrustedImmPtr(nullptr);
1033     emitAllocateJSObject(resultReg, JITAllocator::variable(), allocatorReg, structureReg, butterfly, scratchReg, slowCases);
<span class="line-modified">1034     emitLoadPayload(callee, scratchReg);</span>
<span class="line-removed">1035     loadPtr(Address(scratchReg, JSFunction::offsetOfRareData()), scratchReg);</span>
<span class="line-removed">1036     load32(Address(scratchReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfInlineCapacity()), scratchReg);</span>
1037     emitInitializeInlineStorage(resultReg, scratchReg);
1038     addSlowCase(slowCases);
1039     emitStoreCell(bytecode.m_dst.offset(), resultReg);
1040 }
1041 
1042 void JIT::emit_op_to_this(const Instruction* currentInstruction)
1043 {
1044     auto bytecode = currentInstruction-&gt;as&lt;OpToThis&gt;();
1045     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">1046     WriteBarrierBase&lt;Structure&gt;* cachedStructure = &amp;metadata.m_cachedStructure;</span>
1047     int thisRegister = bytecode.m_srcDst.offset();
1048 
1049     emitLoad(thisRegister, regT3, regT2);
1050 
1051     addSlowCase(branchIfNotCell(regT3));
1052     addSlowCase(branchIfNotType(regT2, FinalObjectType));
1053     loadPtr(Address(regT2, JSCell::structureIDOffset()), regT0);
<span class="line-modified">1054     loadPtr(cachedStructure, regT2);</span>
1055     addSlowCase(branchPtr(NotEqual, regT0, regT2));
1056 }
1057 
1058 void JIT::emit_op_check_tdz(const Instruction* currentInstruction)
1059 {
1060     auto bytecode = currentInstruction-&gt;as&lt;OpCheckTdz&gt;();
1061     emitLoadTag(bytecode.m_targetVirtualRegister.offset(), regT0);
1062     addSlowCase(branchIfEmpty(regT0));
1063 }
1064 
1065 void JIT::emit_op_has_structure_property(const Instruction* currentInstruction)
1066 {
1067     auto bytecode = currentInstruction-&gt;as&lt;OpHasStructureProperty&gt;();
1068     int dst = bytecode.m_dst.offset();
1069     int base = bytecode.m_base.offset();
1070     int enumerator = bytecode.m_enumerator.offset();
1071 
1072     emitLoadPayload(base, regT0);
1073     emitJumpSlowCaseIfNotJSCell(base);
1074 
</pre>
<hr />
<pre>
1104         m_codeBlock, patchBuffer, JITStubRoutinePtrTag,
1105         &quot;Baseline has_indexed_property stub for %s, return point %p&quot;, toCString(*m_codeBlock).data(), returnAddress.value());
1106 
1107     MacroAssembler::repatchJump(byValInfo-&gt;badTypeJump, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(byValInfo-&gt;stubRoutine-&gt;code().code()));
1108     MacroAssembler::repatchCall(CodeLocationCall&lt;NoPtrTag&gt;(MacroAssemblerCodePtr&lt;NoPtrTag&gt;(returnAddress)), FunctionPtr&lt;OperationPtrTag&gt;(operationHasIndexedPropertyGeneric));
1109 }
1110 
1111 void JIT::emit_op_has_indexed_property(const Instruction* currentInstruction)
1112 {
1113     auto bytecode = currentInstruction-&gt;as&lt;OpHasIndexedProperty&gt;();
1114     auto&amp; metadata = bytecode.metadata(m_codeBlock);
1115     int dst = bytecode.m_dst.offset();
1116     int base = bytecode.m_base.offset();
1117     int property = bytecode.m_property.offset();
1118     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
1119     ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
1120 
1121     emitLoadPayload(base, regT0);
1122     emitJumpSlowCaseIfNotJSCell(base);
1123 
<span class="line-modified">1124     emitLoadPayload(property, regT1);</span>

1125 
1126     // This is technically incorrect - we&#39;re zero-extending an int32. On the hot path this doesn&#39;t matter.
1127     // We check the value as if it was a uint32 against the m_vectorLength - which will always fail if
1128     // number was signed since m_vectorLength is always less than intmax (since the total allocation
1129     // size is always less than 4Gb). As such zero extending will have been correct (and extending the value
1130     // to 64-bits is necessary since it&#39;s used in the address calculation. We zero extend rather than sign
1131     // extending since it makes it easier to re-tag the value in the slow case.
1132     zeroExtend32ToPtr(regT1, regT1);
1133 
1134     emitArrayProfilingSiteWithCell(regT0, regT2, profile);
1135     and32(TrustedImm32(IndexingShapeMask), regT2);
1136 
1137     JITArrayMode mode = chooseArrayMode(profile);
1138     PatchableJump badType;
1139 
1140     // FIXME: Add support for other types like TypedArrays and Arguments.
1141     // See https://bugs.webkit.org/show_bug.cgi?id=135033 and https://bugs.webkit.org/show_bug.cgi?id=135034.
1142     JumpList slowCases = emitLoadForArrayMode(currentInstruction, mode, badType);
1143     move(TrustedImm32(1), regT0);
1144 
</pre>
<hr />
<pre>
1318     notCell.link(this);
1319     store32(TrustedImm32(0), Address(regT1, TypeProfilerLog::LogEntry::structureIDOffset()));
1320     skipNotCell.link(this);
1321 
1322     // Store the typeLocation on the log entry.
1323     move(TrustedImmPtr(cachedTypeLocation), regT0);
1324     store32(regT0, Address(regT1, TypeProfilerLog::LogEntry::locationOffset()));
1325 
1326     // Increment the current log entry.
1327     addPtr(TrustedImm32(sizeof(TypeProfilerLog::LogEntry)), regT1);
1328     store32(regT1, Address(regT2, TypeProfilerLog::currentLogEntryOffset()));
1329     jumpToEnd.append(branchPtr(NotEqual, regT1, TrustedImmPtr(cachedTypeProfilerLog-&gt;logEndPtr())));
1330     // Clear the log if we&#39;re at the end of the log.
1331     callOperation(operationProcessTypeProfilerLog);
1332 
1333     jumpToEnd.link(this);
1334 }
1335 
1336 void JIT::emit_op_log_shadow_chicken_prologue(const Instruction* currentInstruction)
1337 {
<span class="line-modified">1338     RELEASE_ASSERT(vm()-&gt;shadowChicken());</span>
1339     updateTopCallFrame();
1340     static_assert(nonArgGPR0 != regT0 &amp;&amp; nonArgGPR0 != regT2, &quot;we will have problems if this is true.&quot;);
1341     auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenPrologue&gt;();
1342     GPRReg shadowPacketReg = regT0;
1343     GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
1344     GPRReg scratch2Reg = regT2;
<span class="line-modified">1345     ensureShadowChickenPacket(*vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
1346 
1347     scratch1Reg = regT4;
1348     emitLoadPayload(bytecode.m_scope.offset(), regT3);
1349     logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, regT3);
1350 }
1351 
1352 void JIT::emit_op_log_shadow_chicken_tail(const Instruction* currentInstruction)
1353 {
<span class="line-modified">1354     RELEASE_ASSERT(vm()-&gt;shadowChicken());</span>
1355     updateTopCallFrame();
1356     static_assert(nonArgGPR0 != regT0 &amp;&amp; nonArgGPR0 != regT2, &quot;we will have problems if this is true.&quot;);
1357     auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenTail&gt;();
1358     GPRReg shadowPacketReg = regT0;
1359     GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
1360     GPRReg scratch2Reg = regT2;
<span class="line-modified">1361     ensureShadowChickenPacket(*vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
1362     emitLoadPayload(bytecode.m_thisValue.offset(), regT2);
1363     emitLoadTag(bytecode.m_thisValue.offset(), regT1);
1364     JSValueRegs thisRegs(regT1, regT2);
1365     emitLoadPayload(bytecode.m_scope.offset(), regT3);
1366     logShadowChickenTailPacket(shadowPacketReg, thisRegs, regT3, m_codeBlock, CallSiteIndex(currentInstruction));
1367 }
1368 
1369 } // namespace JSC
1370 
1371 #endif // USE(JSVALUE32_64)
1372 #endif // ENABLE(JIT)
</pre>
</td>
<td>
<hr />
<pre>
 363 
 364     emitLoad(src, regT1, regT0);
 365     addSlowCase(branchIfNotBoolean(regT1, InvalidGPRReg));
 366     xor32(TrustedImm32(1), regT0);
 367 
 368     emitStoreBool(dst, regT0, (dst == src));
 369 }
 370 
 371 void JIT::emit_op_jfalse(const Instruction* currentInstruction)
 372 {
 373     auto bytecode = currentInstruction-&gt;as&lt;OpJfalse&gt;();
 374     int cond = bytecode.m_condition.offset();
 375     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
 376 
 377     emitLoad(cond, regT1, regT0);
 378 
 379     JSValueRegs value(regT1, regT0);
 380     GPRReg scratch1 = regT2;
 381     GPRReg scratch2 = regT3;
 382     bool shouldCheckMasqueradesAsUndefined = true;
<span class="line-modified"> 383     addJump(branchIfFalsey(vm(), value, scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);</span>
 384 }
 385 
 386 void JIT::emit_op_jtrue(const Instruction* currentInstruction)
 387 {
 388     auto bytecode = currentInstruction-&gt;as&lt;OpJtrue&gt;();
 389     int cond = bytecode.m_condition.offset();
 390     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
 391 
 392     emitLoad(cond, regT1, regT0);
 393     bool shouldCheckMasqueradesAsUndefined = true;
 394     JSValueRegs value(regT1, regT0);
 395     GPRReg scratch1 = regT2;
 396     GPRReg scratch2 = regT3;
<span class="line-modified"> 397     addJump(branchIfTruthy(vm(), value, scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);</span>
 398 }
 399 
 400 void JIT::emit_op_jeq_null(const Instruction* currentInstruction)
 401 {
 402     auto bytecode = currentInstruction-&gt;as&lt;OpJeqNull&gt;();
 403     int src = bytecode.m_value.offset();
 404     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
 405 
 406     emitLoad(src, regT1, regT0);
 407 
 408     Jump isImmediate = branchIfNotCell(regT1);
 409 
 410     Jump isNotMasqueradesAsUndefined = branchTest8(Zero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
 411     loadPtr(Address(regT0, JSCell::structureIDOffset()), regT2);
 412     move(TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0);
 413     addJump(branchPtr(Equal, Address(regT2, Structure::globalObjectOffset()), regT0), target);
 414     Jump masqueradesGlobalObjectIsForeign = jump();
 415 
 416     // Now handle the immediate cases - undefined &amp; null
 417     isImmediate.link(this);
</pre>
<hr />
<pre>
 432     emitLoad(src, regT1, regT0);
 433 
 434     Jump isImmediate = branchIfNotCell(regT1);
 435 
 436     addJump(branchTest8(Zero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined)), target);
 437     loadPtr(Address(regT0, JSCell::structureIDOffset()), regT2);
 438     move(TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0);
 439     addJump(branchPtr(NotEqual, Address(regT2, Structure::globalObjectOffset()), regT0), target);
 440     Jump wasNotImmediate = jump();
 441 
 442     // Now handle the immediate cases - undefined &amp; null
 443     isImmediate.link(this);
 444 
 445     static_assert((JSValue::UndefinedTag + 1 == JSValue::NullTag) &amp;&amp; (JSValue::NullTag &amp; 0x1), &quot;&quot;);
 446     or32(TrustedImm32(1), regT1);
 447     addJump(branchIfNotNull(regT1), target);
 448 
 449     wasNotImmediate.link(this);
 450 }
 451 
<span class="line-added"> 452 void JIT::emit_op_jundefined_or_null(const Instruction* currentInstruction)</span>
<span class="line-added"> 453 {</span>
<span class="line-added"> 454     auto bytecode = currentInstruction-&gt;as&lt;OpJundefinedOrNull&gt;();</span>
<span class="line-added"> 455     int value = bytecode.m_value.offset();</span>
<span class="line-added"> 456     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);</span>
<span class="line-added"> 457 </span>
<span class="line-added"> 458     emitLoadTag(value, regT0);</span>
<span class="line-added"> 459     static_assert((JSValue::UndefinedTag + 1 == JSValue::NullTag) &amp;&amp; (JSValue::NullTag &amp; 0x1), &quot;&quot;);</span>
<span class="line-added"> 460     or32(TrustedImm32(1), regT0);</span>
<span class="line-added"> 461     addJump(branchIfNull(regT0), target);</span>
<span class="line-added"> 462 }</span>
<span class="line-added"> 463 </span>
<span class="line-added"> 464 void JIT::emit_op_jnundefined_or_null(const Instruction* currentInstruction)</span>
<span class="line-added"> 465 {</span>
<span class="line-added"> 466     auto bytecode = currentInstruction-&gt;as&lt;OpJnundefinedOrNull&gt;();</span>
<span class="line-added"> 467     int value = bytecode.m_value.offset();</span>
<span class="line-added"> 468     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);</span>
<span class="line-added"> 469 </span>
<span class="line-added"> 470     emitLoadTag(value, regT0);</span>
<span class="line-added"> 471     static_assert((JSValue::UndefinedTag + 1 == JSValue::NullTag) &amp;&amp; (JSValue::NullTag &amp; 0x1), &quot;&quot;);</span>
<span class="line-added"> 472     or32(TrustedImm32(1), regT0);</span>
<span class="line-added"> 473     addJump(branchIfNotNull(regT0), target);</span>
<span class="line-added"> 474 }</span>
<span class="line-added"> 475 </span>
 476 void JIT::emit_op_jneq_ptr(const Instruction* currentInstruction)
 477 {
 478     auto bytecode = currentInstruction-&gt;as&lt;OpJneqPtr&gt;();
 479     auto&amp; metadata = bytecode.metadata(m_codeBlock);
 480     int src = bytecode.m_value.offset();
 481     Special::Pointer ptr = bytecode.m_specialPointer;
 482     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
 483 
 484     emitLoad(src, regT1, regT0);
 485     Jump notCell = branchIfNotCell(regT1);
 486     Jump equal = branchPtr(Equal, regT0, TrustedImmPtr(actualPointerFor(m_codeBlock, ptr)));
 487     notCell.link(this);
 488     store8(TrustedImm32(1), &amp;metadata.m_hasJumped);
 489     addJump(jump(), target);
 490     equal.link(this);
 491 }
 492 
 493 void JIT::emit_op_eq(const Instruction* currentInstruction)
 494 {
 495     auto bytecode = currentInstruction-&gt;as&lt;OpEq&gt;();
</pre>
<hr />
<pre>
 798     loadPtr(Address(regT2, Structure::globalObjectOffset()), regT2);
 799     compare32(NotEqual, regT0, regT2, regT1);
 800     Jump wasNotImmediate = jump();
 801 
 802     isImmediate.link(this);
 803 
 804     compare32(NotEqual, regT1, TrustedImm32(JSValue::NullTag), regT2);
 805     compare32(NotEqual, regT1, TrustedImm32(JSValue::UndefinedTag), regT1);
 806     and32(regT2, regT1);
 807 
 808     wasNotImmediate.link(this);
 809     wasNotMasqueradesAsUndefined.link(this);
 810 
 811     emitStoreBool(dst, regT1);
 812 }
 813 
 814 void JIT::emit_op_throw(const Instruction* currentInstruction)
 815 {
 816     auto bytecode = currentInstruction-&gt;as&lt;OpThrow&gt;();
 817     ASSERT(regT0 == returnValueGPR);
<span class="line-modified"> 818     copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);</span>
 819     emitLoad(bytecode.m_value.offset(), regT1, regT0);
 820     callOperationNoExceptionCheck(operationThrow, JSValueRegs(regT1, regT0));
<span class="line-modified"> 821     jumpToExceptionHandler(vm());</span>
 822 }
 823 
 824 void JIT::emit_op_to_number(const Instruction* currentInstruction)
 825 {
 826     auto bytecode = currentInstruction-&gt;as&lt;OpToNumber&gt;();
 827     int dst = bytecode.m_dst.offset();
 828     int src = bytecode.m_operand.offset();
 829 
 830     emitLoad(src, regT1, regT0);
 831 
 832     Jump isInt32 = branchIfInt32(regT1);
 833     addSlowCase(branch32(AboveOrEqual, regT1, TrustedImm32(JSValue::LowestTag)));
 834     isInt32.link(this);
 835 
 836     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 837     if (src != dst)
 838         emitStore(dst, regT1, regT0);
 839 }
 840 
 841 void JIT::emit_op_to_string(const Instruction* currentInstruction)
</pre>
<hr />
<pre>
 856 void JIT::emit_op_to_object(const Instruction* currentInstruction)
 857 {
 858     auto bytecode = currentInstruction-&gt;as&lt;OpToObject&gt;();
 859     int dst = bytecode.m_dst.offset();
 860     int src = bytecode.m_operand.offset();
 861 
 862     emitLoad(src, regT1, regT0);
 863 
 864     addSlowCase(branchIfNotCell(regT1));
 865     addSlowCase(branchIfNotObject(regT0));
 866 
 867     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 868     if (src != dst)
 869         emitStore(dst, regT1, regT0);
 870 }
 871 
 872 void JIT::emit_op_catch(const Instruction* currentInstruction)
 873 {
 874     auto bytecode = currentInstruction-&gt;as&lt;OpCatch&gt;();
 875 
<span class="line-modified"> 876     restoreCalleeSavesFromEntryFrameCalleeSavesBuffer(vm().topEntryFrame);</span>
 877 
 878     move(TrustedImmPtr(m_vm), regT3);
 879     // operationThrow returns the callFrame for the handler.
 880     load32(Address(regT3, VM::callFrameForCatchOffset()), callFrameRegister);
 881     storePtr(TrustedImmPtr(nullptr), Address(regT3, VM::callFrameForCatchOffset()));
 882 
 883     addPtr(TrustedImm32(stackPointerOffsetFor(codeBlock()) * sizeof(Register)), callFrameRegister, stackPointerRegister);
 884 
 885     callOperationNoExceptionCheck(operationCheckIfExceptionIsUncatchableAndNotifyProfiler);
 886     Jump isCatchableException = branchTest32(Zero, returnValueGPR);
<span class="line-modified"> 887     jumpToExceptionHandler(vm());</span>
 888     isCatchableException.link(this);
 889 
 890     move(TrustedImmPtr(m_vm), regT3);
 891 
 892     // Now store the exception returned by operationThrow.
 893     load32(Address(regT3, VM::exceptionOffset()), regT2);
 894     move(TrustedImm32(JSValue::CellTag), regT1);
 895 
 896     store32(TrustedImm32(0), Address(regT3, VM::exceptionOffset()));
 897 
 898     unsigned exception = bytecode.m_exception.offset();
 899     emitStore(exception, regT1, regT2);
 900 
 901     load32(Address(regT2, Exception::valueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), regT0);
 902     load32(Address(regT2, Exception::valueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), regT1);
 903 
 904     unsigned thrownValue = bytecode.m_thrownValue.offset();
 905     emitStore(thrownValue, regT1, regT0);
 906 
 907 #if ENABLE(DFG_JIT)
 908     // FIXME: consider inline caching the process of doing OSR entry, including
 909     // argument type proofs, storing locals to the buffer, etc
 910     // https://bugs.webkit.org/show_bug.cgi?id=175598
 911 
 912     auto&amp; metadata = bytecode.metadata(m_codeBlock);
 913     ValueProfileAndOperandBuffer* buffer = metadata.m_buffer;
 914     if (buffer || !shouldEmitProfiling())
 915         callOperation(operationTryOSREnterAtCatch, m_bytecodeOffset);
 916     else
 917         callOperation(operationTryOSREnterAtCatchAndValueProfile, m_bytecodeOffset);
 918     auto skipOSREntry = branchTestPtr(Zero, returnValueGPR);
 919     emitRestoreCalleeSaves();
<span class="line-modified"> 920     farJump(returnValueGPR, NoPtrTag);</span>
 921     skipOSREntry.link(this);
 922     if (buffer &amp;&amp; shouldEmitProfiling()) {
 923         buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {
 924             JSValueRegs regs(regT1, regT0);
 925             emitGetVirtualRegister(profile.m_operand, regs);
<span class="line-modified"> 926             emitValueProfilingSite(static_cast&lt;ValueProfile&amp;&gt;(profile));</span>
 927         });
 928     }
 929 #endif // ENABLE(DFG_JIT)
 930 }
 931 
 932 void JIT::emit_op_identity_with_profile(const Instruction*)
 933 {
 934     // We don&#39;t need to do anything here...
 935 }
 936 
 937 void JIT::emit_op_get_parent_scope(const Instruction* currentInstruction)
 938 {
 939     auto bytecode = currentInstruction-&gt;as&lt;OpGetParentScope&gt;();
 940     int currentScope = bytecode.m_scope.offset();
 941     emitLoadPayload(currentScope, regT0);
 942     loadPtr(Address(regT0, JSScope::offsetOfNext()), regT0);
 943     emitStoreCell(bytecode.m_dst.offset(), regT0);
 944 }
 945 
 946 void JIT::emit_op_switch_imm(const Instruction* currentInstruction)
 947 {
 948     auto bytecode = currentInstruction-&gt;as&lt;OpSwitchImm&gt;();
 949     size_t tableIndex = bytecode.m_tableIndex;
 950     unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
 951     unsigned scrutinee = bytecode.m_scrutinee.offset();
 952 
 953     // create jump table for switch destinations, track this switch statement.
 954     SimpleJumpTable* jumpTable = &amp;m_codeBlock-&gt;switchJumpTable(tableIndex);
 955     m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Immediate));
 956     jumpTable-&gt;ensureCTITable();
 957 
 958     emitLoad(scrutinee, regT1, regT0);
 959     callOperation(operationSwitchImmWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);
<span class="line-modified"> 960     farJump(returnValueGPR, NoPtrTag);</span>
 961 }
 962 
 963 void JIT::emit_op_switch_char(const Instruction* currentInstruction)
 964 {
 965     auto bytecode = currentInstruction-&gt;as&lt;OpSwitchChar&gt;();
 966     size_t tableIndex = bytecode.m_tableIndex;
 967     unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
 968     unsigned scrutinee = bytecode.m_scrutinee.offset();
 969 
 970     // create jump table for switch destinations, track this switch statement.
 971     SimpleJumpTable* jumpTable = &amp;m_codeBlock-&gt;switchJumpTable(tableIndex);
 972     m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Character));
 973     jumpTable-&gt;ensureCTITable();
 974 
 975     emitLoad(scrutinee, regT1, regT0);
 976     callOperation(operationSwitchCharWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);
<span class="line-modified"> 977     farJump(returnValueGPR, NoPtrTag);</span>
 978 }
 979 
 980 void JIT::emit_op_switch_string(const Instruction* currentInstruction)
 981 {
 982     auto bytecode = currentInstruction-&gt;as&lt;OpSwitchString&gt;();
 983     size_t tableIndex = bytecode.m_tableIndex;
 984     unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
 985     unsigned scrutinee = bytecode.m_scrutinee.offset();
 986 
 987     // create jump table for switch destinations, track this switch statement.
 988     StringJumpTable* jumpTable = &amp;m_codeBlock-&gt;stringSwitchJumpTable(tableIndex);
 989     m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset));
 990 
 991     emitLoad(scrutinee, regT1, regT0);
 992     callOperation(operationSwitchStringWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);
<span class="line-modified"> 993     farJump(returnValueGPR, NoPtrTag);</span>
 994 }
 995 
 996 void JIT::emit_op_debug(const Instruction* currentInstruction)
 997 {
 998     auto bytecode = currentInstruction-&gt;as&lt;OpDebug&gt;();
 999     load32(codeBlock()-&gt;debuggerRequestsAddress(), regT0);
1000     Jump noDebuggerRequests = branchTest32(Zero, regT0);
1001     callOperation(operationDebug, static_cast&lt;int&gt;(bytecode.m_debugHookType));
1002     noDebuggerRequests.link(this);
1003 }
1004 















1005 void JIT::emit_op_get_scope(const Instruction* currentInstruction)
1006 {
1007     auto bytecode = currentInstruction-&gt;as&lt;OpGetScope&gt;();
1008     int dst = bytecode.m_dst.offset();
1009     emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, regT0);
1010     loadPtr(Address(regT0, JSFunction::offsetOfScopeChain()), regT0);
1011     emitStoreCell(dst, regT0);
1012 }
1013 
1014 void JIT::emit_op_create_this(const Instruction* currentInstruction)
1015 {
1016     auto bytecode = currentInstruction-&gt;as&lt;OpCreateThis&gt;();
1017     auto&amp; metadata = bytecode.metadata(m_codeBlock);
1018     int callee = bytecode.m_callee.offset();
1019     WriteBarrierBase&lt;JSCell&gt;* cachedFunction = &amp;metadata.m_cachedCallee;
1020     RegisterID calleeReg = regT0;
1021     RegisterID rareDataReg = regT4;
1022     RegisterID resultReg = regT0;
1023     RegisterID allocatorReg = regT1;
1024     RegisterID structureReg = regT2;
1025     RegisterID cachedFunctionReg = regT4;
1026     RegisterID scratchReg = regT3;
1027 
1028     emitLoadPayload(callee, calleeReg);
1029     addSlowCase(branchIfNotFunction(calleeReg));
1030     loadPtr(Address(calleeReg, JSFunction::offsetOfRareData()), rareDataReg);
1031     addSlowCase(branchTestPtr(Zero, rareDataReg));
<span class="line-modified">1032     load32(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator()), allocatorReg);</span>
<span class="line-modified">1033     loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure()), structureReg);</span>
1034 
1035     loadPtr(cachedFunction, cachedFunctionReg);
1036     Jump hasSeenMultipleCallees = branchPtr(Equal, cachedFunctionReg, TrustedImmPtr(JSCell::seenMultipleCalleeObjects()));
1037     addSlowCase(branchPtr(NotEqual, calleeReg, cachedFunctionReg));
1038     hasSeenMultipleCallees.link(this);
1039 
1040     JumpList slowCases;
1041     auto butterfly = TrustedImmPtr(nullptr);
1042     emitAllocateJSObject(resultReg, JITAllocator::variable(), allocatorReg, structureReg, butterfly, scratchReg, slowCases);
<span class="line-modified">1043     load8(Address(structureReg, Structure::inlineCapacityOffset()), scratchReg);</span>


1044     emitInitializeInlineStorage(resultReg, scratchReg);
1045     addSlowCase(slowCases);
1046     emitStoreCell(bytecode.m_dst.offset(), resultReg);
1047 }
1048 
1049 void JIT::emit_op_to_this(const Instruction* currentInstruction)
1050 {
1051     auto bytecode = currentInstruction-&gt;as&lt;OpToThis&gt;();
1052     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">1053     StructureID* cachedStructureID = &amp;metadata.m_cachedStructureID;</span>
1054     int thisRegister = bytecode.m_srcDst.offset();
1055 
1056     emitLoad(thisRegister, regT3, regT2);
1057 
1058     addSlowCase(branchIfNotCell(regT3));
1059     addSlowCase(branchIfNotType(regT2, FinalObjectType));
1060     loadPtr(Address(regT2, JSCell::structureIDOffset()), regT0);
<span class="line-modified">1061     load32(cachedStructureID, regT2);</span>
1062     addSlowCase(branchPtr(NotEqual, regT0, regT2));
1063 }
1064 
1065 void JIT::emit_op_check_tdz(const Instruction* currentInstruction)
1066 {
1067     auto bytecode = currentInstruction-&gt;as&lt;OpCheckTdz&gt;();
1068     emitLoadTag(bytecode.m_targetVirtualRegister.offset(), regT0);
1069     addSlowCase(branchIfEmpty(regT0));
1070 }
1071 
1072 void JIT::emit_op_has_structure_property(const Instruction* currentInstruction)
1073 {
1074     auto bytecode = currentInstruction-&gt;as&lt;OpHasStructureProperty&gt;();
1075     int dst = bytecode.m_dst.offset();
1076     int base = bytecode.m_base.offset();
1077     int enumerator = bytecode.m_enumerator.offset();
1078 
1079     emitLoadPayload(base, regT0);
1080     emitJumpSlowCaseIfNotJSCell(base);
1081 
</pre>
<hr />
<pre>
1111         m_codeBlock, patchBuffer, JITStubRoutinePtrTag,
1112         &quot;Baseline has_indexed_property stub for %s, return point %p&quot;, toCString(*m_codeBlock).data(), returnAddress.value());
1113 
1114     MacroAssembler::repatchJump(byValInfo-&gt;badTypeJump, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(byValInfo-&gt;stubRoutine-&gt;code().code()));
1115     MacroAssembler::repatchCall(CodeLocationCall&lt;NoPtrTag&gt;(MacroAssemblerCodePtr&lt;NoPtrTag&gt;(returnAddress)), FunctionPtr&lt;OperationPtrTag&gt;(operationHasIndexedPropertyGeneric));
1116 }
1117 
1118 void JIT::emit_op_has_indexed_property(const Instruction* currentInstruction)
1119 {
1120     auto bytecode = currentInstruction-&gt;as&lt;OpHasIndexedProperty&gt;();
1121     auto&amp; metadata = bytecode.metadata(m_codeBlock);
1122     int dst = bytecode.m_dst.offset();
1123     int base = bytecode.m_base.offset();
1124     int property = bytecode.m_property.offset();
1125     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
1126     ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
1127 
1128     emitLoadPayload(base, regT0);
1129     emitJumpSlowCaseIfNotJSCell(base);
1130 
<span class="line-modified">1131     emitLoad(property, regT3, regT1);</span>
<span class="line-added">1132     addSlowCase(branchIfNotInt32(regT3));</span>
1133 
1134     // This is technically incorrect - we&#39;re zero-extending an int32. On the hot path this doesn&#39;t matter.
1135     // We check the value as if it was a uint32 against the m_vectorLength - which will always fail if
1136     // number was signed since m_vectorLength is always less than intmax (since the total allocation
1137     // size is always less than 4Gb). As such zero extending will have been correct (and extending the value
1138     // to 64-bits is necessary since it&#39;s used in the address calculation. We zero extend rather than sign
1139     // extending since it makes it easier to re-tag the value in the slow case.
1140     zeroExtend32ToPtr(regT1, regT1);
1141 
1142     emitArrayProfilingSiteWithCell(regT0, regT2, profile);
1143     and32(TrustedImm32(IndexingShapeMask), regT2);
1144 
1145     JITArrayMode mode = chooseArrayMode(profile);
1146     PatchableJump badType;
1147 
1148     // FIXME: Add support for other types like TypedArrays and Arguments.
1149     // See https://bugs.webkit.org/show_bug.cgi?id=135033 and https://bugs.webkit.org/show_bug.cgi?id=135034.
1150     JumpList slowCases = emitLoadForArrayMode(currentInstruction, mode, badType);
1151     move(TrustedImm32(1), regT0);
1152 
</pre>
<hr />
<pre>
1326     notCell.link(this);
1327     store32(TrustedImm32(0), Address(regT1, TypeProfilerLog::LogEntry::structureIDOffset()));
1328     skipNotCell.link(this);
1329 
1330     // Store the typeLocation on the log entry.
1331     move(TrustedImmPtr(cachedTypeLocation), regT0);
1332     store32(regT0, Address(regT1, TypeProfilerLog::LogEntry::locationOffset()));
1333 
1334     // Increment the current log entry.
1335     addPtr(TrustedImm32(sizeof(TypeProfilerLog::LogEntry)), regT1);
1336     store32(regT1, Address(regT2, TypeProfilerLog::currentLogEntryOffset()));
1337     jumpToEnd.append(branchPtr(NotEqual, regT1, TrustedImmPtr(cachedTypeProfilerLog-&gt;logEndPtr())));
1338     // Clear the log if we&#39;re at the end of the log.
1339     callOperation(operationProcessTypeProfilerLog);
1340 
1341     jumpToEnd.link(this);
1342 }
1343 
1344 void JIT::emit_op_log_shadow_chicken_prologue(const Instruction* currentInstruction)
1345 {
<span class="line-modified">1346     RELEASE_ASSERT(vm().shadowChicken());</span>
1347     updateTopCallFrame();
1348     static_assert(nonArgGPR0 != regT0 &amp;&amp; nonArgGPR0 != regT2, &quot;we will have problems if this is true.&quot;);
1349     auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenPrologue&gt;();
1350     GPRReg shadowPacketReg = regT0;
1351     GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
1352     GPRReg scratch2Reg = regT2;
<span class="line-modified">1353     ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
1354 
1355     scratch1Reg = regT4;
1356     emitLoadPayload(bytecode.m_scope.offset(), regT3);
1357     logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, regT3);
1358 }
1359 
1360 void JIT::emit_op_log_shadow_chicken_tail(const Instruction* currentInstruction)
1361 {
<span class="line-modified">1362     RELEASE_ASSERT(vm().shadowChicken());</span>
1363     updateTopCallFrame();
1364     static_assert(nonArgGPR0 != regT0 &amp;&amp; nonArgGPR0 != regT2, &quot;we will have problems if this is true.&quot;);
1365     auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenTail&gt;();
1366     GPRReg shadowPacketReg = regT0;
1367     GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
1368     GPRReg scratch2Reg = regT2;
<span class="line-modified">1369     ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
1370     emitLoadPayload(bytecode.m_thisValue.offset(), regT2);
1371     emitLoadTag(bytecode.m_thisValue.offset(), regT1);
1372     JSValueRegs thisRegs(regT1, regT2);
1373     emitLoadPayload(bytecode.m_scope.offset(), regT3);
1374     logShadowChickenTailPacket(shadowPacketReg, thisRegs, regT3, m_codeBlock, CallSiteIndex(currentInstruction));
1375 }
1376 
1377 } // namespace JSC
1378 
1379 #endif // USE(JSVALUE32_64)
1380 #endif // ENABLE(JIT)
</pre>
</td>
</tr>
</table>
<center><a href="JITOpcodes.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOperations.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>