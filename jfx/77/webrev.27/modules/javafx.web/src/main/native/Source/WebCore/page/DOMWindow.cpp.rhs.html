<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;DOMWindow.h&quot;
  29 
  30 #include &quot;BackForwardController.h&quot;
  31 #include &quot;BarProp.h&quot;
  32 #include &quot;CSSComputedStyleDeclaration.h&quot;
  33 #include &quot;CSSRule.h&quot;
  34 #include &quot;CSSRuleList.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;ChromeClient.h&quot;
  37 #include &quot;ComposedTreeIterator.h&quot;
  38 #include &quot;ContentExtensionActions.h&quot;
  39 #include &quot;ContentExtensionRule.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  40 #include &quot;ContentRuleListResults.h&quot;</span>
  41 #include &quot;Crypto.h&quot;
  42 #include &quot;CustomElementRegistry.h&quot;
  43 #include &quot;DOMApplicationCache.h&quot;
  44 #include &quot;DOMSelection.h&quot;
  45 #include &quot;DOMStringList.h&quot;
  46 #include &quot;DOMTimer.h&quot;
  47 #include &quot;DOMTokenList.h&quot;
  48 #include &quot;DOMURL.h&quot;
<a name="2" id="anc2"></a>
  49 #include &quot;DeviceMotionController.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  50 #include &quot;DeviceMotionData.h&quot;</span>
<span class="line-added">  51 #include &quot;DeviceMotionEvent.h&quot;</span>
<span class="line-added">  52 #include &quot;DeviceOrientationAndMotionAccessController.h&quot;</span>
  53 #include &quot;DeviceOrientationController.h&quot;
  54 #include &quot;Document.h&quot;
  55 #include &quot;DocumentLoader.h&quot;
  56 #include &quot;Editor.h&quot;
  57 #include &quot;Element.h&quot;
  58 #include &quot;EventHandler.h&quot;
  59 #include &quot;EventListener.h&quot;
  60 #include &quot;EventNames.h&quot;
  61 #include &quot;FloatRect.h&quot;
  62 #include &quot;FocusController.h&quot;
  63 #include &quot;Frame.h&quot;
  64 #include &quot;FrameLoadRequest.h&quot;
  65 #include &quot;FrameLoader.h&quot;
  66 #include &quot;FrameLoaderClient.h&quot;
  67 #include &quot;FrameTree.h&quot;
  68 #include &quot;FrameView.h&quot;
  69 #include &quot;HTTPParsers.h&quot;
  70 #include &quot;History.h&quot;
  71 #include &quot;InspectorInstrumentation.h&quot;
  72 #include &quot;JSDOMWindowBase.h&quot;
  73 #include &quot;JSExecState.h&quot;
  74 #include &quot;Location.h&quot;
  75 #include &quot;MediaQueryList.h&quot;
  76 #include &quot;MediaQueryMatcher.h&quot;
  77 #include &quot;MessageEvent.h&quot;
  78 #include &quot;MessageWithMessagePorts.h&quot;
  79 #include &quot;NavigationScheduler.h&quot;
  80 #include &quot;Navigator.h&quot;
  81 #include &quot;Page.h&quot;
  82 #include &quot;PageConsoleClient.h&quot;
  83 #include &quot;PageTransitionEvent.h&quot;
  84 #include &quot;Performance.h&quot;
  85 #include &quot;RequestAnimationFrameCallback.h&quot;
  86 #include &quot;ResourceLoadInfo.h&quot;
  87 #include &quot;ResourceLoadObserver.h&quot;
  88 #include &quot;RuntimeApplicationChecks.h&quot;
  89 #include &quot;RuntimeEnabledFeatures.h&quot;
  90 #include &quot;ScheduledAction.h&quot;
  91 #include &quot;Screen.h&quot;
  92 #include &quot;SecurityOrigin.h&quot;
  93 #include &quot;SecurityOriginData.h&quot;
  94 #include &quot;SecurityPolicy.h&quot;
  95 #include &quot;SelectorQuery.h&quot;
  96 #include &quot;SerializedScriptValue.h&quot;
  97 #include &quot;Settings.h&quot;
  98 #include &quot;StaticNodeList.h&quot;
  99 #include &quot;Storage.h&quot;
 100 #include &quot;StorageArea.h&quot;
 101 #include &quot;StorageNamespace.h&quot;
 102 #include &quot;StorageNamespaceProvider.h&quot;
 103 #include &quot;StyleMedia.h&quot;
 104 #include &quot;StyleResolver.h&quot;
 105 #include &quot;StyleScope.h&quot;
 106 #include &quot;SuddenTermination.h&quot;
 107 #include &lt;wtf/URL.h&gt;
 108 #include &quot;UserGestureIndicator.h&quot;
 109 #include &quot;VisualViewport.h&quot;
 110 #include &quot;WebKitPoint.h&quot;
 111 #include &quot;WindowFeatures.h&quot;
 112 #include &quot;WindowFocusAllowedIndicator.h&quot;
 113 #include &quot;WindowProxy.h&quot;
 114 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 115 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
 116 #include &lt;algorithm&gt;
 117 #include &lt;memory&gt;
<a name="4" id="anc4"></a><span class="line-added"> 118 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
 119 #include &lt;wtf/Language.h&gt;
 120 #include &lt;wtf/MainThread.h&gt;
 121 #include &lt;wtf/MathExtras.h&gt;
 122 #include &lt;wtf/NeverDestroyed.h&gt;
 123 #include &lt;wtf/Ref.h&gt;
<a name="5" id="anc5"></a><span class="line-added"> 124 #include &lt;wtf/SetForScope.h&gt;</span>
 125 #include &lt;wtf/Variant.h&gt;
 126 #include &lt;wtf/text/WTFString.h&gt;
 127 
 128 #if ENABLE(USER_MESSAGE_HANDLERS)
 129 #include &quot;UserContentController.h&quot;
 130 #include &quot;UserMessageHandlerDescriptor.h&quot;
 131 #include &quot;WebKitNamespace.h&quot;
 132 #endif
 133 
 134 #if ENABLE(GAMEPAD)
 135 #include &quot;GamepadManager.h&quot;
 136 #endif
 137 
 138 #if ENABLE(GEOLOCATION)
 139 #include &quot;NavigatorGeolocation.h&quot;
 140 #endif
 141 
 142 #if ENABLE(POINTER_LOCK)
 143 #include &quot;PointerLockController.h&quot;
 144 #endif
 145 
<a name="6" id="anc6"></a>





 146 namespace WebCore {
 147 using namespace Inspector;
 148 
<a name="7" id="anc7"></a><span class="line-added"> 149 WTF_MAKE_ISO_ALLOCATED_IMPL(DOMWindow);</span>
<span class="line-added"> 150 </span>
 151 class PostMessageTimer : public TimerBase {
 152 public:
 153     PostMessageTimer(DOMWindow&amp; window, MessageWithMessagePorts&amp;&amp; message, const String&amp; sourceOrigin, RefPtr&lt;WindowProxy&gt;&amp;&amp; source, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; targetOrigin, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; stackTrace)
 154         : m_window(window)
 155         , m_message(WTFMove(message))
 156         , m_origin(sourceOrigin)
 157         , m_source(source)
 158         , m_targetOrigin(WTFMove(targetOrigin))
 159         , m_stackTrace(stackTrace)
 160         , m_userGestureToForward(UserGestureIndicator::currentUserGesture())
 161     {
 162     }
 163 
 164     Ref&lt;MessageEvent&gt; event(ScriptExecutionContext&amp; context)
 165     {
 166         return MessageEvent::create(MessagePort::entanglePorts(context, WTFMove(m_message.transferredPorts)), m_message.message.releaseNonNull(), m_origin, { }, m_source ? makeOptional(MessageEventSource(WTFMove(m_source))) : WTF::nullopt);
 167     }
 168 
 169     SecurityOrigin* targetOrigin() const { return m_targetOrigin.get(); }
 170     ScriptCallStack* stackTrace() const { return m_stackTrace.get(); }
 171 
 172 private:
 173     void fired() override
 174     {
 175         // This object gets deleted when std::unique_ptr falls out of scope..
 176         std::unique_ptr&lt;PostMessageTimer&gt; timer(this);
 177 
 178         UserGestureIndicator userGestureIndicator(m_userGestureToForward);
 179         m_window-&gt;postMessageTimerFired(*timer);
 180     }
 181 
 182     Ref&lt;DOMWindow&gt; m_window;
 183     MessageWithMessagePorts m_message;
 184     String m_origin;
 185     RefPtr&lt;WindowProxy&gt; m_source;
 186     RefPtr&lt;SecurityOrigin&gt; m_targetOrigin;
 187     RefPtr&lt;ScriptCallStack&gt; m_stackTrace;
 188     RefPtr&lt;UserGestureToken&gt; m_userGestureToForward;
 189 };
 190 
 191 typedef HashCountedSet&lt;DOMWindow*&gt; DOMWindowSet;
 192 
 193 static DOMWindowSet&amp; windowsWithUnloadEventListeners()
 194 {
 195     static NeverDestroyed&lt;DOMWindowSet&gt; windowsWithUnloadEventListeners;
 196     return windowsWithUnloadEventListeners;
 197 }
 198 
 199 static DOMWindowSet&amp; windowsWithBeforeUnloadEventListeners()
 200 {
 201     static NeverDestroyed&lt;DOMWindowSet&gt; windowsWithBeforeUnloadEventListeners;
 202     return windowsWithBeforeUnloadEventListeners;
 203 }
 204 
 205 static void addUnloadEventListener(DOMWindow* domWindow)
 206 {
 207     if (windowsWithUnloadEventListeners().add(domWindow).isNewEntry)
 208         domWindow-&gt;disableSuddenTermination();
 209 }
 210 
 211 static void removeUnloadEventListener(DOMWindow* domWindow)
 212 {
 213     if (windowsWithUnloadEventListeners().remove(domWindow))
 214         domWindow-&gt;enableSuddenTermination();
 215 }
 216 
 217 static void removeAllUnloadEventListeners(DOMWindow* domWindow)
 218 {
 219     if (windowsWithUnloadEventListeners().removeAll(domWindow))
 220         domWindow-&gt;enableSuddenTermination();
 221 }
 222 
 223 static void addBeforeUnloadEventListener(DOMWindow* domWindow)
 224 {
 225     if (windowsWithBeforeUnloadEventListeners().add(domWindow).isNewEntry)
 226         domWindow-&gt;disableSuddenTermination();
 227 }
 228 
 229 static void removeBeforeUnloadEventListener(DOMWindow* domWindow)
 230 {
 231     if (windowsWithBeforeUnloadEventListeners().remove(domWindow))
 232         domWindow-&gt;enableSuddenTermination();
 233 }
 234 
 235 static void removeAllBeforeUnloadEventListeners(DOMWindow* domWindow)
 236 {
 237     if (windowsWithBeforeUnloadEventListeners().removeAll(domWindow))
 238         domWindow-&gt;enableSuddenTermination();
 239 }
 240 
 241 static bool allowsBeforeUnloadListeners(DOMWindow* window)
 242 {
 243     ASSERT_ARG(window, window);
 244     Frame* frame = window-&gt;frame();
 245     if (!frame)
 246         return false;
 247     if (!frame-&gt;page())
 248         return false;
 249     return frame-&gt;isMainFrame();
 250 }
 251 
 252 bool DOMWindow::dispatchAllPendingBeforeUnloadEvents()
 253 {
 254     DOMWindowSet&amp; set = windowsWithBeforeUnloadEventListeners();
 255     if (set.isEmpty())
 256         return true;
 257 
 258     static bool alreadyDispatched = false;
 259     ASSERT(!alreadyDispatched);
 260     if (alreadyDispatched)
 261         return true;
 262 
 263     Vector&lt;Ref&lt;DOMWindow&gt;&gt; windows;
 264     windows.reserveInitialCapacity(set.size());
 265     for (auto&amp; window : set)
 266         windows.uncheckedAppend(*window.key);
 267 
 268     for (auto&amp; window : windows) {
 269         if (!set.contains(window.ptr()))
 270             continue;
 271 
 272         Frame* frame = window-&gt;frame();
 273         if (!frame)
 274             continue;
 275 
 276         if (!frame-&gt;loader().shouldClose())
 277             return false;
 278 
 279         window-&gt;enableSuddenTermination();
 280     }
 281 
 282     alreadyDispatched = true;
 283     return true;
 284 }
 285 
 286 unsigned DOMWindow::pendingUnloadEventListeners() const
 287 {
 288     return windowsWithUnloadEventListeners().count(const_cast&lt;DOMWindow*&gt;(this));
 289 }
 290 
 291 void DOMWindow::dispatchAllPendingUnloadEvents()
 292 {
 293     DOMWindowSet&amp; set = windowsWithUnloadEventListeners();
 294     if (set.isEmpty())
 295         return;
 296 
 297     static bool alreadyDispatched = false;
 298     ASSERT(!alreadyDispatched);
 299     if (alreadyDispatched)
 300         return;
 301 
 302     auto windows = WTF::map(set, [] (auto&amp; keyValue) {
 303         return Ref&lt;DOMWindow&gt;(*(keyValue.key));
 304     });
 305 
 306     for (auto&amp; window : windows) {
 307         if (!set.contains(window.ptr()))
 308             continue;
 309 
 310         window-&gt;dispatchEvent(PageTransitionEvent::create(eventNames().pagehideEvent, false), window-&gt;document());
 311         window-&gt;dispatchEvent(Event::create(eventNames().unloadEvent, Event::CanBubble::No, Event::IsCancelable::No), window-&gt;document());
 312 
 313         window-&gt;enableSuddenTermination();
 314     }
 315 
 316     alreadyDispatched = true;
 317 }
 318 
 319 // This function:
 320 // 1) Validates the pending changes are not changing any value to NaN; in that case keep original value.
 321 // 2) Constrains the window rect to the minimum window size and no bigger than the float rect&#39;s dimensions.
 322 // 3) Constrains the window rect to within the top and left boundaries of the available screen rect.
 323 // 4) Constrains the window rect to within the bottom and right boundaries of the available screen rect.
 324 // 5) Translate the window rect coordinates to be within the coordinate space of the screen.
 325 FloatRect DOMWindow::adjustWindowRect(Page&amp; page, const FloatRect&amp; pendingChanges)
 326 {
 327     FloatRect screen = screenAvailableRect(page.mainFrame().view());
 328     FloatRect window = page.chrome().windowRect();
 329 
 330     // Make sure we&#39;re in a valid state before adjusting dimensions.
 331     ASSERT(std::isfinite(screen.x()));
 332     ASSERT(std::isfinite(screen.y()));
 333     ASSERT(std::isfinite(screen.width()));
 334     ASSERT(std::isfinite(screen.height()));
 335     ASSERT(std::isfinite(window.x()));
 336     ASSERT(std::isfinite(window.y()));
 337     ASSERT(std::isfinite(window.width()));
 338     ASSERT(std::isfinite(window.height()));
 339 
 340     // Update window values if new requested values are not NaN.
 341     if (!std::isnan(pendingChanges.x()))
 342         window.setX(pendingChanges.x());
 343     if (!std::isnan(pendingChanges.y()))
 344         window.setY(pendingChanges.y());
 345     if (!std::isnan(pendingChanges.width()))
 346         window.setWidth(pendingChanges.width());
 347     if (!std::isnan(pendingChanges.height()))
 348         window.setHeight(pendingChanges.height());
 349 
 350     FloatSize minimumSize = page.chrome().client().minimumWindowSize();
 351     window.setWidth(std::min(std::max(minimumSize.width(), window.width()), screen.width()));
 352     window.setHeight(std::min(std::max(minimumSize.height(), window.height()), screen.height()));
 353 
 354     // Constrain the window position within the valid screen area.
 355     window.setX(std::max(screen.x(), std::min(window.x(), screen.maxX() - window.width())));
 356     window.setY(std::max(screen.y(), std::min(window.y(), screen.maxY() - window.height())));
 357 
 358     return window;
 359 }
 360 
 361 bool DOMWindow::allowPopUp(Frame&amp; firstFrame)
 362 {
 363     if (DocumentLoader* documentLoader = firstFrame.loader().documentLoader()) {
 364         // If pop-up policy was set during navigation, use it. If not, use the global settings.
 365         PopUpPolicy popUpPolicy = documentLoader-&gt;popUpPolicy();
 366         if (popUpPolicy == PopUpPolicy::Allow)
 367             return true;
 368 
 369         if (popUpPolicy == PopUpPolicy::Block)
 370             return false;
 371     }
 372 
 373     return UserGestureIndicator::processingUserGesture()
 374         || firstFrame.settings().javaScriptCanOpenWindowsAutomatically();
 375 }
 376 
 377 bool DOMWindow::allowPopUp()
 378 {
 379     auto* frame = this-&gt;frame();
 380     return frame &amp;&amp; allowPopUp(*frame);
 381 }
 382 
 383 bool DOMWindow::canShowModalDialog(const Frame&amp; frame)
 384 {
 385     // Override support for layout testing purposes.
 386     if (auto* document = frame.document()) {
 387         if (auto* window = document-&gt;domWindow()) {
 388             if (window-&gt;m_canShowModalDialogOverride)
 389                 return window-&gt;m_canShowModalDialogOverride.value();
 390         }
 391     }
 392 
 393     auto* page = frame.page();
 394     return page &amp;&amp; page-&gt;chrome().canRunModal();
 395 }
 396 
 397 static void languagesChangedCallback(void* context)
 398 {
 399     static_cast&lt;DOMWindow*&gt;(context)-&gt;languagesChanged();
 400 }
 401 
 402 void DOMWindow::setCanShowModalDialogOverride(bool allow)
 403 {
 404     m_canShowModalDialogOverride = allow;
 405 }
 406 
 407 DOMWindow::DOMWindow(Document&amp; document)
 408     : AbstractDOMWindow(GlobalWindowIdentifier { Process::identifier(), WindowIdentifier::generate() })
 409     , ContextDestructionObserver(&amp;document)
 410 {
 411     ASSERT(frame());
 412     addLanguageChangeObserver(this, &amp;languagesChangedCallback);
 413 }
 414 
 415 void DOMWindow::didSecureTransitionTo(Document&amp; document)
 416 {
 417     observeContext(&amp;document);
<a name="8" id="anc8"></a><span class="line-added"> 418 </span>
<span class="line-added"> 419     // The Window is being transferred from one document to another so we need to reset data</span>
<span class="line-added"> 420     // members that store the window&#39;s document (rather than the window itself).</span>
<span class="line-added"> 421     m_crypto = nullptr;</span>
<span class="line-added"> 422     m_navigator = nullptr;</span>
<span class="line-added"> 423     m_performance = nullptr;</span>
<span class="line-added"> 424 }</span>
<span class="line-added"> 425 </span>
<span class="line-added"> 426 void DOMWindow::prewarmLocalStorageIfNecessary()</span>
<span class="line-added"> 427 {</span>
<span class="line-added"> 428     auto* page = this-&gt;page();</span>
<span class="line-added"> 429 </span>
<span class="line-added"> 430     // No need to prewarm for ephemeral sessions since the data is in memory only.</span>
<span class="line-added"> 431     if (!page || page-&gt;usesEphemeralSession())</span>
<span class="line-added"> 432         return;</span>
<span class="line-added"> 433 </span>
<span class="line-added"> 434     if (!page-&gt;mainFrame().mayPrewarmLocalStorage())</span>
<span class="line-added"> 435         return;</span>
<span class="line-added"> 436 </span>
<span class="line-added"> 437     auto localStorageResult = this-&gt;localStorage();</span>
<span class="line-added"> 438     if (localStorageResult.hasException())</span>
<span class="line-added"> 439         return;</span>
<span class="line-added"> 440 </span>
<span class="line-added"> 441     auto* localStorage = localStorageResult.returnValue();</span>
<span class="line-added"> 442     if (!localStorage)</span>
<span class="line-added"> 443         return;</span>
<span class="line-added"> 444 </span>
<span class="line-added"> 445     page-&gt;mainFrame().didPrewarmLocalStorage();</span>
 446 }
 447 
 448 DOMWindow::~DOMWindow()
 449 {
 450     if (m_suspendedForDocumentSuspension)
 451         willDestroyCachedFrame();
 452     else
 453         willDestroyDocumentInFrame();
 454 
 455     removeAllUnloadEventListeners(this);
 456     removeAllBeforeUnloadEventListeners(this);
 457 
 458 #if ENABLE(GAMEPAD)
 459     if (m_gamepadEventListenerCount)
 460         GamepadManager::singleton().unregisterDOMWindow(this);
 461 #endif
 462 
 463     removeLanguageChangeObserver(this);
 464 }
 465 
 466 RefPtr&lt;MediaQueryList&gt; DOMWindow::matchMedia(const String&amp; media)
 467 {
 468     return document() ? document()-&gt;mediaQueryMatcher().matchMedia(media) : nullptr;
 469 }
 470 
 471 Page* DOMWindow::page()
 472 {
 473     return frame() ? frame()-&gt;page() : nullptr;
 474 }
 475 
 476 void DOMWindow::frameDestroyed()
 477 {
 478     Ref&lt;DOMWindow&gt; protectedThis(*this);
 479 
 480     willDestroyDocumentInFrame();
 481     JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(this);
 482 }
 483 
 484 void DOMWindow::willDestroyCachedFrame()
 485 {
<a name="9" id="anc9"></a><span class="line-modified"> 486     // It is necessary to copy m_observers to a separate vector because the Observer may</span>
 487     // unregister themselves from the DOMWindow as a result of the call to willDestroyGlobalObjectInCachedFrame.
<a name="10" id="anc10"></a><span class="line-modified"> 488     for (auto* observer : copyToVector(m_observers)) {</span>
<span class="line-modified"> 489         if (m_observers.contains(observer))</span>
<span class="line-modified"> 490             observer-&gt;willDestroyGlobalObjectInCachedFrame();</span>
 491     }
 492 }
 493 
 494 void DOMWindow::willDestroyDocumentInFrame()
 495 {
<a name="11" id="anc11"></a><span class="line-modified"> 496     // It is necessary to copy m_observers to a separate vector because the Observer may</span>
 497     // unregister themselves from the DOMWindow as a result of the call to willDestroyGlobalObjectInFrame.
<a name="12" id="anc12"></a><span class="line-modified"> 498     for (auto* observer : copyToVector(m_observers)) {</span>
<span class="line-modified"> 499         if (m_observers.contains(observer))</span>
<span class="line-modified"> 500             observer-&gt;willDestroyGlobalObjectInFrame();</span>
 501     }
 502 }
 503 
 504 void DOMWindow::willDetachDocumentFromFrame()
 505 {
 506     if (!frame())
 507         return;
 508 
<a name="13" id="anc13"></a><span class="line-modified"> 509     RELEASE_ASSERT(!m_isSuspendingObservers);</span>
<span class="line-added"> 510 </span>
<span class="line-added"> 511     // It is necessary to copy m_observers to a separate vector because the Observer may</span>
 512     // unregister themselves from the DOMWindow as a result of the call to willDetachGlobalObjectFromFrame.
<a name="14" id="anc14"></a><span class="line-modified"> 513     for (auto&amp; observer : copyToVector(m_observers)) {</span>
<span class="line-modified"> 514         if (m_observers.contains(observer))</span>
<span class="line-modified"> 515             observer-&gt;willDetachGlobalObjectFromFrame();</span>
 516     }
 517 
 518     if (m_performance)
 519         m_performance-&gt;clearResourceTimings();
 520 
 521     JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(this);
 522     InspectorInstrumentation::frameWindowDiscarded(*frame(), this);
 523 }
 524 
 525 #if ENABLE(GAMEPAD)
 526 
 527 void DOMWindow::incrementGamepadEventListenerCount()
 528 {
 529     if (++m_gamepadEventListenerCount == 1)
 530         GamepadManager::singleton().registerDOMWindow(this);
 531 }
 532 
 533 void DOMWindow::decrementGamepadEventListenerCount()
 534 {
 535     ASSERT(m_gamepadEventListenerCount);
 536 
 537     if (!--m_gamepadEventListenerCount)
 538         GamepadManager::singleton().unregisterDOMWindow(this);
 539 }
 540 
 541 #endif
 542 
<a name="15" id="anc15"></a><span class="line-modified"> 543 void DOMWindow::registerObserver(Observer&amp; observer)</span>
 544 {
<a name="16" id="anc16"></a><span class="line-modified"> 545     m_observers.add(&amp;observer);</span>
 546 }
 547 
<a name="17" id="anc17"></a><span class="line-modified"> 548 void DOMWindow::unregisterObserver(Observer&amp; observer)</span>
 549 {
<a name="18" id="anc18"></a><span class="line-modified"> 550     m_observers.remove(&amp;observer);</span>
 551 }
 552 
 553 void DOMWindow::resetUnlessSuspendedForDocumentSuspension()
 554 {
 555     if (m_suspendedForDocumentSuspension)
 556         return;
 557     willDestroyDocumentInFrame();
<a name="19" id="anc19"></a>
 558 }
 559 
 560 void DOMWindow::suspendForPageCache()
 561 {
<a name="20" id="anc20"></a><span class="line-modified"> 562     SetForScope&lt;bool&gt; isSuspendingObservers(m_isSuspendingObservers, true);</span>
<span class="line-modified"> 563     RELEASE_ASSERT(frame());</span>
<span class="line-modified"> 564 </span>
<span class="line-added"> 565     for (auto* observer : copyToVector(m_observers)) {</span>
<span class="line-added"> 566         if (m_observers.contains(observer))</span>
<span class="line-added"> 567             observer-&gt;suspendForPageCache();</span>
 568     }
<a name="21" id="anc21"></a><span class="line-added"> 569     RELEASE_ASSERT(frame());</span>
 570 
 571     m_suspendedForDocumentSuspension = true;
 572 }
 573 
 574 void DOMWindow::resumeFromPageCache()
 575 {
<a name="22" id="anc22"></a><span class="line-modified"> 576     for (auto* observer : copyToVector(m_observers)) {</span>
<span class="line-modified"> 577         if (m_observers.contains(observer))</span>
<span class="line-modified"> 578             observer-&gt;resumeFromPageCache();</span>
 579     }
 580 
 581     m_suspendedForDocumentSuspension = false;
 582 }
 583 
<a name="23" id="anc23"></a>























 584 bool DOMWindow::isCurrentlyDisplayedInFrame() const
 585 {
 586     auto* frame = this-&gt;frame();
 587     return frame &amp;&amp; frame-&gt;document()-&gt;domWindow() == this;
 588 }
 589 
 590 CustomElementRegistry&amp; DOMWindow::ensureCustomElementRegistry()
 591 {
 592     if (!m_customElementRegistry)
 593         m_customElementRegistry = CustomElementRegistry::create(*this, scriptExecutionContext());
 594     return *m_customElementRegistry;
 595 }
 596 
 597 static ExceptionOr&lt;SelectorQuery&amp;&gt; selectorQueryInFrame(Frame* frame, const String&amp; selectors)
 598 {
 599     if (!frame)
 600         return Exception { NotSupportedError };
 601 
 602     Document* document = frame-&gt;document();
 603     if (!document)
 604         return Exception { NotSupportedError };
 605 
 606     return document-&gt;selectorQueryForString(selectors);
 607 }
 608 
 609 ExceptionOr&lt;Ref&lt;NodeList&gt;&gt; DOMWindow::collectMatchingElementsInFlatTree(Node&amp; scope, const String&amp; selectors)
 610 {
 611     auto queryOrException = selectorQueryInFrame(frame(), selectors);
 612     if (queryOrException.hasException())
 613         return queryOrException.releaseException();
 614 
 615     if (!is&lt;ContainerNode&gt;(scope))
 616         return Ref&lt;NodeList&gt; { StaticElementList::create() };
 617 
 618     SelectorQuery&amp; query = queryOrException.releaseReturnValue();
 619 
 620     Vector&lt;Ref&lt;Element&gt;&gt; result;
 621     for (auto&amp; node : composedTreeDescendants(downcast&lt;ContainerNode&gt;(scope))) {
 622         if (is&lt;Element&gt;(node) &amp;&amp; query.matches(downcast&lt;Element&gt;(node)) &amp;&amp; !node.isInUserAgentShadowTree())
 623             result.append(downcast&lt;Element&gt;(node));
 624     }
 625 
 626     return Ref&lt;NodeList&gt; { StaticElementList::create(WTFMove(result)) };
 627 }
 628 
 629 ExceptionOr&lt;RefPtr&lt;Element&gt;&gt; DOMWindow::matchingElementInFlatTree(Node&amp; scope, const String&amp; selectors)
 630 {
 631     auto queryOrException = selectorQueryInFrame(frame(), selectors);
 632     if (queryOrException.hasException())
 633         return queryOrException.releaseException();
 634 
 635     if (!is&lt;ContainerNode&gt;(scope))
 636         return RefPtr&lt;Element&gt; { nullptr };
 637 
 638     SelectorQuery&amp; query = queryOrException.releaseReturnValue();
 639 
 640     for (auto&amp; node : composedTreeDescendants(downcast&lt;ContainerNode&gt;(scope))) {
 641         if (is&lt;Element&gt;(node) &amp;&amp; query.matches(downcast&lt;Element&gt;(node)) &amp;&amp; !node.isInUserAgentShadowTree())
 642             return &amp;downcast&lt;Element&gt;(node);
 643     }
 644 
 645     return RefPtr&lt;Element&gt; { nullptr };
 646 }
 647 
 648 #if ENABLE(ORIENTATION_EVENTS)
 649 
 650 int DOMWindow::orientation() const
 651 {
 652     auto* frame = this-&gt;frame();
 653     if (!frame)
 654         return 0;
 655 
 656     return frame-&gt;orientation();
 657 }
 658 
 659 #endif
 660 
 661 Screen&amp; DOMWindow::screen()
 662 {
 663     if (!m_screen)
 664         m_screen = Screen::create(*this);
 665     return *m_screen;
 666 }
 667 
 668 History&amp; DOMWindow::history()
 669 {
 670     if (!m_history)
 671         m_history = History::create(*this);
 672     return *m_history;
 673 }
 674 
 675 Crypto&amp; DOMWindow::crypto() const
 676 {
 677     if (!m_crypto)
 678         m_crypto = Crypto::create(document());
<a name="24" id="anc24"></a><span class="line-added"> 679     ASSERT(m_crypto-&gt;scriptExecutionContext() == document());</span>
 680     return *m_crypto;
 681 }
 682 
 683 BarProp&amp; DOMWindow::locationbar()
 684 {
 685     if (!m_locationbar)
 686         m_locationbar = BarProp::create(*this, BarProp::Locationbar);
 687     return *m_locationbar;
 688 }
 689 
 690 BarProp&amp; DOMWindow::menubar()
 691 {
 692     if (!m_menubar)
 693         m_menubar = BarProp::create(*this, BarProp::Menubar);
 694     return *m_menubar;
 695 }
 696 
 697 BarProp&amp; DOMWindow::personalbar()
 698 {
 699     if (!m_personalbar)
 700         m_personalbar = BarProp::create(*this, BarProp::Personalbar);
 701     return *m_personalbar;
 702 }
 703 
 704 BarProp&amp; DOMWindow::scrollbars()
 705 {
 706     if (!m_scrollbars)
 707         m_scrollbars = BarProp::create(*this, BarProp::Scrollbars);
 708     return *m_scrollbars;
 709 }
 710 
 711 BarProp&amp; DOMWindow::statusbar()
 712 {
 713     if (!m_statusbar)
 714         m_statusbar = BarProp::create(*this, BarProp::Statusbar);
 715     return *m_statusbar;
 716 }
 717 
 718 BarProp&amp; DOMWindow::toolbar()
 719 {
 720     if (!m_toolbar)
 721         m_toolbar = BarProp::create(*this, BarProp::Toolbar);
 722     return *m_toolbar;
 723 }
 724 
 725 PageConsoleClient* DOMWindow::console() const
 726 {
 727     // FIXME: This should not return nullptr when frameless.
 728     if (!isCurrentlyDisplayedInFrame())
 729         return nullptr;
 730     auto* frame = this-&gt;frame();
 731     return frame-&gt;page() ? &amp;frame-&gt;page()-&gt;console() : nullptr;
 732 }
 733 
 734 DOMApplicationCache&amp; DOMWindow::applicationCache()
 735 {
 736     if (!m_applicationCache)
 737         m_applicationCache = DOMApplicationCache::create(*this);
 738     return *m_applicationCache;
 739 }
 740 
 741 Navigator&amp; DOMWindow::navigator()
 742 {
 743     if (!m_navigator)
 744         m_navigator = Navigator::create(scriptExecutionContext(), *this);
<a name="25" id="anc25"></a><span class="line-added"> 745     ASSERT(m_navigator-&gt;scriptExecutionContext() == document());</span>
 746 
 747     return *m_navigator;
 748 }
 749 
 750 Performance&amp; DOMWindow::performance() const
 751 {
 752     if (!m_performance) {
 753         MonotonicTime timeOrigin = document() &amp;&amp; document()-&gt;loader() ? document()-&gt;loader()-&gt;timing().referenceMonotonicTime() : MonotonicTime::now();
 754         m_performance = Performance::create(document(), timeOrigin);
 755     }
<a name="26" id="anc26"></a><span class="line-added"> 756     ASSERT(m_performance-&gt;scriptExecutionContext() == document());</span>
 757     return *m_performance;
 758 }
 759 
 760 double DOMWindow::nowTimestamp() const
 761 {
 762     return performance().now() / 1000.;
 763 }
 764 
 765 Location&amp; DOMWindow::location()
 766 {
 767     if (!m_location)
 768         m_location = Location::create(*this);
 769     return *m_location;
 770 }
 771 
 772 VisualViewport&amp; DOMWindow::visualViewport()
 773 {
 774     if (!m_visualViewport)
 775         m_visualViewport = VisualViewport::create(*this);
 776     return *m_visualViewport;
 777 }
 778 
 779 #if ENABLE(USER_MESSAGE_HANDLERS)
 780 
 781 bool DOMWindow::shouldHaveWebKitNamespaceForWorld(DOMWrapperWorld&amp; world)
 782 {
 783     auto* frame = this-&gt;frame();
 784     if (!frame)
 785         return false;
 786 
 787     auto* page = frame-&gt;page();
 788     if (!page)
 789         return false;
 790 
 791     bool hasUserMessageHandler = false;
 792     page-&gt;userContentProvider().forEachUserMessageHandler([&amp;](const UserMessageHandlerDescriptor&amp; descriptor) {
 793         if (&amp;descriptor.world() == &amp;world) {
 794             hasUserMessageHandler = true;
 795             return;
 796         }
 797     });
 798 
 799     return hasUserMessageHandler;
 800 }
 801 
 802 WebKitNamespace* DOMWindow::webkitNamespace()
 803 {
 804     if (!isCurrentlyDisplayedInFrame())
 805         return nullptr;
 806     auto* page = frame()-&gt;page();
 807     if (!page)
 808         return nullptr;
 809     if (!m_webkitNamespace)
 810         m_webkitNamespace = WebKitNamespace::create(*this, page-&gt;userContentProvider());
 811     return m_webkitNamespace.get();
 812 }
 813 
 814 #endif
 815 
 816 ExceptionOr&lt;Storage*&gt; DOMWindow::sessionStorage()
 817 {
 818     if (!isCurrentlyDisplayedInFrame())
 819         return nullptr;
 820 
 821     auto* document = this-&gt;document();
 822     if (!document)
 823         return nullptr;
 824 
 825     if (!document-&gt;securityOrigin().canAccessSessionStorage(document-&gt;topOrigin()))
 826         return Exception { SecurityError };
 827 
 828     if (m_sessionStorage)
 829         return m_sessionStorage.get();
 830 
 831     auto* page = document-&gt;page();
 832     if (!page)
 833         return nullptr;
 834 
 835     auto storageArea = page-&gt;sessionStorage()-&gt;storageArea(document-&gt;securityOrigin().data());
 836     m_sessionStorage = Storage::create(*this, WTFMove(storageArea));
 837     return m_sessionStorage.get();
 838 }
 839 
 840 ExceptionOr&lt;Storage*&gt; DOMWindow::localStorage()
 841 {
 842     if (!isCurrentlyDisplayedInFrame())
 843         return nullptr;
 844 
 845     auto* document = this-&gt;document();
 846     if (!document)
 847         return nullptr;
 848 
 849     if (!document-&gt;securityOrigin().canAccessLocalStorage(nullptr))
 850         return Exception { SecurityError };
 851 
 852     auto* page = document-&gt;page();
 853     // FIXME: We should consider supporting access/modification to local storage
 854     // after calling window.close(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=135330&gt;.
 855     if (!page || !page-&gt;isClosing()) {
 856         if (m_localStorage)
 857             return m_localStorage.get();
 858     }
 859 
 860     if (!page)
 861         return nullptr;
 862 
 863     if (page-&gt;isClosing())
 864         return nullptr;
 865 
 866     if (!page-&gt;settings().localStorageEnabled())
 867         return nullptr;
 868 
 869     auto storageArea = page-&gt;storageNamespaceProvider().localStorageArea(*document);
 870     m_localStorage = Storage::create(*this, WTFMove(storageArea));
 871     return m_localStorage.get();
 872 }
 873 
 874 ExceptionOr&lt;void&gt; DOMWindow::postMessage(JSC::ExecState&amp; state, DOMWindow&amp; incumbentWindow, JSC::JSValue messageValue, const String&amp; targetOrigin, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transfer)
 875 {
 876     if (!isCurrentlyDisplayedInFrame())
 877         return { };
 878 
 879     Document* sourceDocument = incumbentWindow.document();
 880 
 881     // Compute the target origin.  We need to do this synchronously in order
 882     // to generate the SyntaxError exception correctly.
 883     RefPtr&lt;SecurityOrigin&gt; target;
 884     if (targetOrigin == &quot;/&quot;) {
 885         if (!sourceDocument)
 886             return { };
 887         target = &amp;sourceDocument-&gt;securityOrigin();
 888     } else if (targetOrigin != &quot;*&quot;) {
 889         target = SecurityOrigin::createFromString(targetOrigin);
 890         // It doesn&#39;t make sense target a postMessage at a unique origin
 891         // because there&#39;s no way to represent a unique origin in a string.
 892         if (target-&gt;isUnique())
 893             return Exception { SyntaxError };
 894     }
 895 
 896     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
 897     auto messageData = SerializedScriptValue::create(state, messageValue, WTFMove(transfer), ports, SerializationContext::WindowPostMessage);
 898     if (messageData.hasException())
 899         return messageData.releaseException();
 900 
 901     auto disentangledPorts = MessagePort::disentanglePorts(WTFMove(ports));
 902     if (disentangledPorts.hasException())
 903         return disentangledPorts.releaseException();
 904 
 905     // Capture the source of the message.  We need to do this synchronously
 906     // in order to capture the source of the message correctly.
 907     if (!sourceDocument)
 908         return { };
 909     auto sourceOrigin = sourceDocument-&gt;securityOrigin().toString();
 910 
 911     // Capture stack trace only when inspector front-end is loaded as it may be time consuming.
 912     RefPtr&lt;ScriptCallStack&gt; stackTrace;
 913     if (InspectorInstrumentation::consoleAgentEnabled(sourceDocument))
 914         stackTrace = createScriptCallStack(JSExecState::currentState());
 915 
 916     MessageWithMessagePorts message { messageData.releaseReturnValue(), disentangledPorts.releaseReturnValue() };
 917 
 918     // Schedule the message.
 919     RefPtr&lt;WindowProxy&gt; incumbentWindowProxy = incumbentWindow.frame() ? &amp;incumbentWindow.frame()-&gt;windowProxy() : nullptr;
 920     auto* timer = new PostMessageTimer(*this, WTFMove(message), sourceOrigin, WTFMove(incumbentWindowProxy), WTFMove(target), WTFMove(stackTrace));
 921     timer-&gt;startOneShot(0_s);
 922 
 923     InspectorInstrumentation::didPostMessage(*frame(), *timer, state);
 924 
 925     return { };
 926 }
 927 
 928 void DOMWindow::postMessageTimerFired(PostMessageTimer&amp; timer)
 929 {
 930     if (!document() || !isCurrentlyDisplayedInFrame())
 931         return;
 932 
 933     Ref&lt;Frame&gt; frame = *this-&gt;frame();
 934     if (auto* intendedTargetOrigin = timer.targetOrigin()) {
 935         // Check target origin now since the target document may have changed since the timer was scheduled.
 936         if (!intendedTargetOrigin-&gt;isSameSchemeHostPort(document()-&gt;securityOrigin())) {
 937             if (auto* pageConsole = console()) {
 938                 String message = makeString(&quot;Unable to post message to &quot;, intendedTargetOrigin-&gt;toString(), &quot;. Recipient has origin &quot;, document()-&gt;securityOrigin().toString(), &quot;.\n&quot;);
 939                 if (timer.stackTrace())
 940                     pageConsole-&gt;addMessage(MessageSource::Security, MessageLevel::Error, message, *timer.stackTrace());
 941                 else
 942                     pageConsole-&gt;addMessage(MessageSource::Security, MessageLevel::Error, message);
 943             }
 944 
 945             InspectorInstrumentation::didFailPostMessage(frame, timer);
 946             return;
 947         }
 948     }
 949 
 950     InspectorInstrumentation::willDispatchPostMessage(frame, timer);
 951 
 952     dispatchEvent(timer.event(*document()));
 953 
 954     InspectorInstrumentation::didDispatchPostMessage(frame, timer);
 955 }
 956 
 957 DOMSelection* DOMWindow::getSelection()
 958 {
 959     if (!isCurrentlyDisplayedInFrame())
 960         return nullptr;
 961     if (!m_selection)
 962         m_selection = DOMSelection::create(*this);
 963     return m_selection.get();
 964 }
 965 
 966 Element* DOMWindow::frameElement() const
 967 {
 968     auto* frame = this-&gt;frame();
 969     if (!frame)
 970         return nullptr;
 971 
 972     return frame-&gt;ownerElement();
 973 }
 974 
 975 void DOMWindow::focus(DOMWindow&amp; incumbentWindow)
 976 {
<a name="27" id="anc27"></a><span class="line-modified"> 977     auto* frame = this-&gt;frame();</span>
<span class="line-modified"> 978     auto* openerFrame = frame ? frame-&gt;loader().opener() : nullptr;</span>
<span class="line-added"> 979     focus(openerFrame &amp;&amp; openerFrame != frame &amp;&amp; incumbentWindow.frame() == openerFrame);</span>
 980 }
 981 
 982 void DOMWindow::focus(bool allowFocus)
 983 {
 984     if (!frame())
 985         return;
 986 
 987     Page* page = frame()-&gt;page();
 988     if (!page)
 989         return;
 990 
 991     allowFocus = allowFocus || WindowFocusAllowedIndicator::windowFocusAllowed() || !frame()-&gt;settings().windowFocusRestricted();
 992 
 993     // If we&#39;re a top level window, bring the window to the front.
 994     if (frame()-&gt;isMainFrame() &amp;&amp; allowFocus)
 995         page-&gt;chrome().focus();
 996 
 997     if (!frame())
 998         return;
 999 
<a name="28" id="anc28"></a><span class="line-added">1000     if (!frame()-&gt;hasHadUserInteraction() &amp;&amp; !isSameSecurityOriginAsMainFrame())</span>
<span class="line-added">1001         return;</span>
<span class="line-added">1002 </span>
1003     // Clear the current frame&#39;s focused node if a new frame is about to be focused.
1004     Frame* focusedFrame = page-&gt;focusController().focusedFrame();
1005     if (focusedFrame &amp;&amp; focusedFrame != frame())
1006         focusedFrame-&gt;document()-&gt;setFocusedElement(nullptr);
1007 
1008     // setFocusedElement may clear frame(), so recheck before using it.
1009     if (auto* frame = this-&gt;frame())
1010         frame-&gt;eventHandler().focusDocumentView();
1011 }
1012 
1013 void DOMWindow::blur()
1014 {
1015     auto* frame = this-&gt;frame();
1016     if (!frame)
1017         return;
1018 
1019     Page* page = frame-&gt;page();
1020     if (!page)
1021         return;
1022 
1023     if (frame-&gt;settings().windowFocusRestricted())
1024         return;
1025 
1026     if (!frame-&gt;isMainFrame())
1027         return;
1028 
1029     page-&gt;chrome().unfocus();
1030 }
1031 
1032 void DOMWindow::close(Document&amp; document)
1033 {
1034     if (!document.canNavigate(frame()))
1035         return;
1036     close();
1037 }
1038 
1039 void DOMWindow::close()
1040 {
1041     auto* frame = this-&gt;frame();
1042     if (!frame)
1043         return;
1044 
1045     Page* page = frame-&gt;page();
1046     if (!page)
1047         return;
1048 
1049     if (!frame-&gt;isMainFrame())
1050         return;
1051 
1052     if (!(page-&gt;openedByDOM() || page-&gt;backForward().count() &lt;= 1)) {
1053         console()-&gt;addMessage(MessageSource::JS, MessageLevel::Warning, &quot;Can&#39;t close the window since it was not opened by JavaScript&quot;_s);
1054         return;
1055     }
1056 
1057     if (!frame-&gt;loader().shouldClose())
1058         return;
1059 
1060     page-&gt;setIsClosing();
1061     page-&gt;chrome().closeWindowSoon();
1062 }
1063 
1064 void DOMWindow::print()
1065 {
1066     auto* frame = this-&gt;frame();
1067     if (!frame)
1068         return;
1069 
1070     auto* page = frame-&gt;page();
1071     if (!page)
1072         return;
1073 
1074     if (!page-&gt;arePromptsAllowed()) {
1075         printErrorMessage(&quot;Use of window.print is not allowed while unloading a page.&quot;);
1076         return;
1077     }
1078 
1079     if (frame-&gt;loader().activeDocumentLoader()-&gt;isLoading()) {
1080         m_shouldPrintWhenFinishedLoading = true;
1081         return;
1082     }
1083     m_shouldPrintWhenFinishedLoading = false;
1084     page-&gt;chrome().print(*frame);
1085 }
1086 
1087 void DOMWindow::stop()
1088 {
1089     auto* frame = this-&gt;frame();
1090     if (!frame)
1091         return;
1092 
1093     // We must check whether the load is complete asynchronously, because we might still be parsing
1094     // the document until the callstack unwinds.
1095     frame-&gt;loader().stopForUserCancel(true);
1096 }
1097 
1098 void DOMWindow::alert(const String&amp; message)
1099 {
1100     auto* frame = this-&gt;frame();
1101     if (!frame)
1102         return;
1103 
1104     if (document()-&gt;isSandboxed(SandboxModals)) {
1105         printErrorMessage(&quot;Use of window.alert is not allowed in a sandboxed frame when the allow-modals flag is not set.&quot;);
1106         return;
1107     }
1108 
1109     auto* page = frame-&gt;page();
1110     if (!page)
1111         return;
1112 
1113     if (!page-&gt;arePromptsAllowed()) {
1114         printErrorMessage(&quot;Use of window.alert is not allowed while unloading a page.&quot;);
1115         return;
1116     }
1117 
1118     frame-&gt;document()-&gt;updateStyleIfNeeded();
1119 #if ENABLE(POINTER_LOCK)
1120     page-&gt;pointerLockController().requestPointerUnlock();
1121 #endif
1122 
1123     page-&gt;chrome().runJavaScriptAlert(*frame, message);
1124 }
1125 
1126 bool DOMWindow::confirm(const String&amp; message)
1127 {
1128     auto* frame = this-&gt;frame();
1129     if (!frame)
1130         return false;
1131 
1132     if (document()-&gt;isSandboxed(SandboxModals)) {
1133         printErrorMessage(&quot;Use of window.confirm is not allowed in a sandboxed frame when the allow-modals flag is not set.&quot;);
1134         return false;
1135     }
1136 
1137     auto* page = frame-&gt;page();
1138     if (!page)
1139         return false;
1140 
1141     if (!page-&gt;arePromptsAllowed()) {
1142         printErrorMessage(&quot;Use of window.confirm is not allowed while unloading a page.&quot;);
1143         return false;
1144     }
1145 
1146     frame-&gt;document()-&gt;updateStyleIfNeeded();
1147 #if ENABLE(POINTER_LOCK)
1148     page-&gt;pointerLockController().requestPointerUnlock();
1149 #endif
1150 
1151     return page-&gt;chrome().runJavaScriptConfirm(*frame, message);
1152 }
1153 
1154 String DOMWindow::prompt(const String&amp; message, const String&amp; defaultValue)
1155 {
1156     auto* frame = this-&gt;frame();
1157     if (!frame)
1158         return String();
1159 
1160     if (document()-&gt;isSandboxed(SandboxModals)) {
1161         printErrorMessage(&quot;Use of window.prompt is not allowed in a sandboxed frame when the allow-modals flag is not set.&quot;);
1162         return String();
1163     }
1164 
1165     auto* page = frame-&gt;page();
1166     if (!page)
1167         return String();
1168 
1169     if (!page-&gt;arePromptsAllowed()) {
1170         printErrorMessage(&quot;Use of window.prompt is not allowed while unloading a page.&quot;);
1171         return String();
1172     }
1173 
1174     frame-&gt;document()-&gt;updateStyleIfNeeded();
1175 #if ENABLE(POINTER_LOCK)
1176     page-&gt;pointerLockController().requestPointerUnlock();
1177 #endif
1178 
1179     String returnValue;
1180     if (page-&gt;chrome().runJavaScriptPrompt(*frame, message, defaultValue, returnValue))
1181         return returnValue;
1182 
1183     return String();
1184 }
1185 
1186 bool DOMWindow::find(const String&amp; string, bool caseSensitive, bool backwards, bool wrap, bool /*wholeWord*/, bool /*searchInFrames*/, bool /*showDialog*/) const
1187 {
1188     if (!isCurrentlyDisplayedInFrame())
1189         return false;
1190 
1191     // FIXME (13016): Support wholeWord, searchInFrames and showDialog.
1192     FindOptions options { DoNotTraverseFlatTree };
1193     if (backwards)
1194         options.add(Backwards);
1195     if (!caseSensitive)
1196         options.add(CaseInsensitive);
1197     if (wrap)
1198         options.add(WrapAround);
1199     return frame()-&gt;editor().findString(string, options);
1200 }
1201 
1202 bool DOMWindow::offscreenBuffering() const
1203 {
1204     return true;
1205 }
1206 
1207 int DOMWindow::outerHeight() const
1208 {
1209 #if PLATFORM(IOS_FAMILY)
1210     if (!frame())
1211         return 0;
1212 
1213     auto* view = frame()-&gt;isMainFrame() ? frame()-&gt;view() : frame()-&gt;mainFrame().view();
1214     if (!view)
1215         return 0;
1216 
1217     return view-&gt;frameRect().height();
1218 #else
1219     auto* frame = this-&gt;frame();
1220     if (!frame)
1221         return 0;
1222 
1223     Page* page = frame-&gt;page();
1224     if (!page)
1225         return 0;
1226 
1227     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().height());
1228 #endif
1229 }
1230 
1231 int DOMWindow::outerWidth() const
1232 {
1233 #if PLATFORM(IOS_FAMILY)
1234     if (!frame())
1235         return 0;
1236 
1237     auto* view = frame()-&gt;isMainFrame() ? frame()-&gt;view() : frame()-&gt;mainFrame().view();
1238     if (!view)
1239         return 0;
1240 
1241     return view-&gt;frameRect().width();
1242 #else
1243     auto* frame = this-&gt;frame();
1244     if (!frame)
1245         return 0;
1246 
1247     Page* page = frame-&gt;page();
1248     if (!page)
1249         return 0;
1250 
1251     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().width());
1252 #endif
1253 }
1254 
1255 int DOMWindow::innerHeight() const
1256 {
1257     if (!frame())
1258         return 0;
1259 
1260     // Force enough layout in the parent document to ensure that the FrameView has been resized.
<a name="29" id="anc29"></a><span class="line-modified">1261     if (auto ownerElement = makeRefPtr(frameElement()))</span>
<span class="line-modified">1262         ownerElement-&gt;document().updateLayoutIfDimensionsOutOfDate(*ownerElement, HeightDimensionsCheck);</span>
1263 
<a name="30" id="anc30"></a><span class="line-modified">1264     auto frame = makeRefPtr(this-&gt;frame());</span>
1265     if (!frame)
1266         return 0;
1267 
<a name="31" id="anc31"></a><span class="line-modified">1268     auto view = makeRefPtr(frame-&gt;view());</span>
1269     if (!view)
1270         return 0;
1271 
1272     return view-&gt;mapFromLayoutToCSSUnits(static_cast&lt;int&gt;(view-&gt;unobscuredContentRectIncludingScrollbars().height()));
1273 }
1274 
1275 int DOMWindow::innerWidth() const
1276 {
1277     if (!frame())
1278         return 0;
1279 
1280     // Force enough layout in the parent document to ensure that the FrameView has been resized.
<a name="32" id="anc32"></a><span class="line-modified">1281     if (auto ownerElement = makeRefPtr(frameElement()))</span>
<span class="line-modified">1282         ownerElement-&gt;document().updateLayoutIfDimensionsOutOfDate(*ownerElement, WidthDimensionsCheck);</span>
1283 
<a name="33" id="anc33"></a><span class="line-modified">1284     auto frame = makeRefPtr(this-&gt;frame());</span>
1285     if (!frame)
1286         return 0;
1287 
<a name="34" id="anc34"></a><span class="line-modified">1288     auto view = makeRefPtr(frame-&gt;view());</span>
1289     if (!view)
1290         return 0;
1291 
1292     return view-&gt;mapFromLayoutToCSSUnits(static_cast&lt;int&gt;(view-&gt;unobscuredContentRectIncludingScrollbars().width()));
1293 }
1294 
1295 int DOMWindow::screenX() const
1296 {
<a name="35" id="anc35"></a><span class="line-modified">1297     auto frame = makeRefPtr(this-&gt;frame());</span>
1298     if (!frame)
1299         return 0;
1300 
1301     Page* page = frame-&gt;page();
1302     if (!page)
1303         return 0;
1304 
1305     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().x());
1306 }
1307 
1308 int DOMWindow::screenY() const
1309 {
<a name="36" id="anc36"></a><span class="line-modified">1310     auto frame = makeRefPtr(this-&gt;frame());</span>
1311     if (!frame)
1312         return 0;
1313 
1314     Page* page = frame-&gt;page();
1315     if (!page)
1316         return 0;
1317 
1318     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().y());
1319 }
1320 
1321 int DOMWindow::scrollX() const
1322 {
<a name="37" id="anc37"></a><span class="line-modified">1323     auto frame = makeRefPtr(this-&gt;frame());</span>
1324     if (!frame)
1325         return 0;
1326 
<a name="38" id="anc38"></a><span class="line-modified">1327     auto view = makeRefPtr(frame-&gt;view());</span>
1328     if (!view)
1329         return 0;
1330 
1331     int scrollX = view-&gt;contentsScrollPosition().x();
1332     if (!scrollX)
1333         return 0;
1334 
1335     frame-&gt;document()-&gt;updateLayoutIgnorePendingStylesheets();
1336 
1337     // Layout may have affected the current frame:
<a name="39" id="anc39"></a><span class="line-modified">1338     auto frameAfterLayout = makeRefPtr(this-&gt;frame());</span>
1339     if (!frameAfterLayout)
1340         return 0;
1341 
<a name="40" id="anc40"></a><span class="line-modified">1342     auto viewAfterLayout = makeRefPtr(frameAfterLayout-&gt;view());</span>
1343     if (!viewAfterLayout)
1344         return 0;
1345 
1346     return viewAfterLayout-&gt;mapFromLayoutToCSSUnits(viewAfterLayout-&gt;contentsScrollPosition().x());
1347 }
1348 
1349 int DOMWindow::scrollY() const
1350 {
<a name="41" id="anc41"></a><span class="line-modified">1351     auto frame = makeRefPtr(this-&gt;frame());</span>
1352     if (!frame)
1353         return 0;
1354 
<a name="42" id="anc42"></a><span class="line-modified">1355     auto view = makeRefPtr(frame-&gt;view());</span>
1356     if (!view)
1357         return 0;
1358 
1359     int scrollY = view-&gt;contentsScrollPosition().y();
1360     if (!scrollY)
1361         return 0;
1362 
1363     frame-&gt;document()-&gt;updateLayoutIgnorePendingStylesheets();
1364 
1365     // Layout may have affected the current frame:
<a name="43" id="anc43"></a><span class="line-modified">1366     auto frameAfterLayout = makeRefPtr(this-&gt;frame());</span>
1367     if (!frameAfterLayout)
1368         return 0;
1369 
<a name="44" id="anc44"></a><span class="line-modified">1370     auto viewAfterLayout = makeRefPtr(frameAfterLayout-&gt;view());</span>
1371     if (!viewAfterLayout)
1372         return 0;
1373 
1374     return viewAfterLayout-&gt;mapFromLayoutToCSSUnits(viewAfterLayout-&gt;contentsScrollPosition().y());
1375 }
1376 
1377 bool DOMWindow::closed() const
1378 {
<a name="45" id="anc45"></a><span class="line-modified">1379     auto* frame = this-&gt;frame();</span>
<span class="line-added">1380     if (!frame)</span>
<span class="line-added">1381         return true;</span>
<span class="line-added">1382 </span>
<span class="line-added">1383     auto* page = frame-&gt;page();</span>
<span class="line-added">1384     return !page || page-&gt;isClosing();</span>
1385 }
1386 
1387 unsigned DOMWindow::length() const
1388 {
1389     if (!isCurrentlyDisplayedInFrame())
1390         return 0;
1391 
1392     return frame()-&gt;tree().scopedChildCount();
1393 }
1394 
1395 String DOMWindow::name() const
1396 {
1397     auto* frame = this-&gt;frame();
1398     if (!frame)
1399         return String();
1400 
1401     return frame-&gt;tree().name();
1402 }
1403 
1404 void DOMWindow::setName(const String&amp; string)
1405 {
1406     auto* frame = this-&gt;frame();
1407     if (!frame)
1408         return;
1409 
1410     frame-&gt;tree().setName(string);
1411 }
1412 
1413 void DOMWindow::setStatus(const String&amp; string)
1414 {
1415     m_status = string;
1416 
1417     auto* frame = this-&gt;frame();
1418     if (!frame)
1419         return;
1420 
1421     Page* page = frame-&gt;page();
1422     if (!page)
1423         return;
1424 
1425     ASSERT(frame-&gt;document()); // Client calls shouldn&#39;t be made when the frame is in inconsistent state.
1426     page-&gt;chrome().setStatusbarText(*frame, m_status);
1427 }
1428 
1429 void DOMWindow::setDefaultStatus(const String&amp; string)
1430 {
1431     m_defaultStatus = string;
1432 
1433     auto* frame = this-&gt;frame();
1434     if (!frame)
1435         return;
1436 
1437     Page* page = frame-&gt;page();
1438     if (!page)
1439         return;
1440 
1441     ASSERT(frame-&gt;document()); // Client calls shouldn&#39;t be made when the frame is in inconsistent state.
1442     page-&gt;chrome().setStatusbarText(*frame, m_defaultStatus);
1443 }
1444 
<a name="46" id="anc46"></a>








1445 WindowProxy* DOMWindow::opener() const
1446 {
1447     auto* frame = this-&gt;frame();
1448     if (!frame)
1449         return nullptr;
1450 
1451     auto* openerFrame = frame-&gt;loader().opener();
1452     if (!openerFrame)
1453         return nullptr;
1454 
1455     return &amp;openerFrame-&gt;windowProxy();
1456 }
1457 
1458 void DOMWindow::disownOpener()
1459 {
1460     if (auto* frame = this-&gt;frame())
1461         frame-&gt;loader().setOpener(nullptr);
1462 }
1463 
1464 WindowProxy* DOMWindow::parent() const
1465 {
1466     auto* frame = this-&gt;frame();
1467     if (!frame)
1468         return nullptr;
1469 
1470     auto* parentFrame = frame-&gt;tree().parent();
1471     if (parentFrame)
1472         return &amp;parentFrame-&gt;windowProxy();
1473 
1474     return &amp;frame-&gt;windowProxy();
1475 }
1476 
1477 WindowProxy* DOMWindow::top() const
1478 {
1479     auto* frame = this-&gt;frame();
1480     if (!frame)
1481         return nullptr;
1482 
1483     if (!frame-&gt;page())
1484         return nullptr;
1485 
1486     return &amp;frame-&gt;tree().top().windowProxy();
1487 }
1488 
1489 String DOMWindow::origin() const
1490 {
1491     auto document = this-&gt;document();
1492     return document ? document-&gt;securityOrigin().toString() : emptyString();
1493 }
1494 
1495 Document* DOMWindow::document() const
1496 {
1497     return downcast&lt;Document&gt;(ContextDestructionObserver::scriptExecutionContext());
1498 }
1499 
1500 StyleMedia&amp; DOMWindow::styleMedia()
1501 {
1502     if (!m_media)
1503         m_media = StyleMedia::create(*this);
1504     return *m_media;
1505 }
1506 
1507 Ref&lt;CSSStyleDeclaration&gt; DOMWindow::getComputedStyle(Element&amp; element, const String&amp; pseudoElt) const
1508 {
1509     return CSSComputedStyleDeclaration::create(element, false, pseudoElt);
1510 }
1511 
1512 RefPtr&lt;CSSRuleList&gt; DOMWindow::getMatchedCSSRules(Element* element, const String&amp; pseudoElement, bool authorOnly) const
1513 {
1514     if (!isCurrentlyDisplayedInFrame())
1515         return nullptr;
1516 
1517     unsigned colonStart = pseudoElement[0] == &#39;:&#39; ? (pseudoElement[1] == &#39;:&#39; ? 2 : 1) : 0;
<a name="47" id="anc47"></a><span class="line-modified">1518     auto pseudoType = CSSSelector::parsePseudoElementType(StringView { pseudoElement }.substring(colonStart));</span>
1519     if (pseudoType == CSSSelector::PseudoElementUnknown &amp;&amp; !pseudoElement.isEmpty())
1520         return nullptr;
1521 
1522     auto* frame = this-&gt;frame();
1523     frame-&gt;document()-&gt;styleScope().flushPendingUpdate();
1524 
1525     unsigned rulesToInclude = StyleResolver::AuthorCSSRules;
1526     if (!authorOnly)
1527         rulesToInclude |= StyleResolver::UAAndUserCSSRules;
1528 
1529     PseudoId pseudoId = CSSSelector::pseudoId(pseudoType);
1530 
1531     auto matchedRules = frame-&gt;document()-&gt;styleScope().resolver().pseudoStyleRulesForElement(element, pseudoId, rulesToInclude);
1532     if (matchedRules.isEmpty())
1533         return nullptr;
1534 
1535     bool allowCrossOrigin = frame-&gt;settings().crossOriginCheckInGetMatchedCSSRulesDisabled();
1536 
1537     auto ruleList = StaticCSSRuleList::create();
1538     for (auto&amp; rule : matchedRules) {
1539         if (!allowCrossOrigin &amp;&amp; !rule-&gt;hasDocumentSecurityOrigin())
1540             continue;
1541         ruleList-&gt;rules().append(rule-&gt;createCSSOMWrapper());
1542     }
1543 
1544     if (ruleList-&gt;rules().isEmpty())
1545         return nullptr;
1546 
<a name="48" id="anc48"></a><span class="line-modified">1547     return ruleList;</span>
1548 }
1549 
1550 RefPtr&lt;WebKitPoint&gt; DOMWindow::webkitConvertPointFromNodeToPage(Node* node, const WebKitPoint* p) const
1551 {
1552     if (!node || !p)
1553         return nullptr;
1554 
1555     if (!document())
1556         return nullptr;
1557 
1558     document()-&gt;updateLayoutIgnorePendingStylesheets();
1559 
1560     FloatPoint pagePoint(p-&gt;x(), p-&gt;y());
1561     pagePoint = node-&gt;convertToPage(pagePoint);
1562     return WebKitPoint::create(pagePoint.x(), pagePoint.y());
1563 }
1564 
1565 RefPtr&lt;WebKitPoint&gt; DOMWindow::webkitConvertPointFromPageToNode(Node* node, const WebKitPoint* p) const
1566 {
1567     if (!node || !p)
1568         return nullptr;
1569 
1570     if (!document())
1571         return nullptr;
1572 
1573     document()-&gt;updateLayoutIgnorePendingStylesheets();
1574 
1575     FloatPoint nodePoint(p-&gt;x(), p-&gt;y());
1576     nodePoint = node-&gt;convertFromPage(nodePoint);
1577     return WebKitPoint::create(nodePoint.x(), nodePoint.y());
1578 }
1579 
1580 double DOMWindow::devicePixelRatio() const
1581 {
1582     auto* frame = this-&gt;frame();
1583     if (!frame)
1584         return 0.0;
1585 
1586     Page* page = frame-&gt;page();
1587     if (!page)
1588         return 0.0;
1589 
1590     return page-&gt;deviceScaleFactor();
1591 }
1592 
1593 void DOMWindow::scrollBy(double x, double y) const
1594 {
1595     scrollBy({ x, y });
1596 }
1597 
1598 void DOMWindow::scrollBy(const ScrollToOptions&amp; options) const
1599 {
1600     if (!isCurrentlyDisplayedInFrame())
1601         return;
1602 
1603     document()-&gt;updateLayoutIgnorePendingStylesheets();
1604 
1605     FrameView* view = frame()-&gt;view();
1606     if (!view)
1607         return;
1608 
1609     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options, 0, 0);
1610     scrollToOptions.left.value() += view-&gt;mapFromLayoutToCSSUnits(view-&gt;contentsScrollPosition().x());
1611     scrollToOptions.top.value() += view-&gt;mapFromLayoutToCSSUnits(view-&gt;contentsScrollPosition().y());
1612     scrollTo(scrollToOptions);
1613 }
1614 
1615 void DOMWindow::scrollTo(double x, double y, ScrollClamping clamping) const
1616 {
1617     scrollTo({ x, y }, clamping);
1618 }
1619 
1620 void DOMWindow::scrollTo(const ScrollToOptions&amp; options, ScrollClamping) const
1621 {
1622     if (!isCurrentlyDisplayedInFrame())
1623         return;
1624 
1625     RefPtr&lt;FrameView&gt; view = frame()-&gt;view();
1626     if (!view)
1627         return;
1628 
1629     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options,
1630         view-&gt;contentsScrollPosition().x(), view-&gt;contentsScrollPosition().y()
1631     );
1632 
1633     if (!scrollToOptions.left.value() &amp;&amp; !scrollToOptions.top.value() &amp;&amp; view-&gt;contentsScrollPosition() == IntPoint(0, 0))
1634         return;
1635 
1636     document()-&gt;updateLayoutIgnorePendingStylesheets();
1637 
1638     IntPoint layoutPos(view-&gt;mapFromCSSToLayoutUnits(scrollToOptions.left.value()), view-&gt;mapFromCSSToLayoutUnits(scrollToOptions.top.value()));
1639     view-&gt;setContentsScrollPosition(layoutPos);
1640 }
1641 
1642 bool DOMWindow::allowedToChangeWindowGeometry() const
1643 {
1644     auto* frame = this-&gt;frame();
1645     if (!frame)
1646         return false;
1647     if (!frame-&gt;page())
1648         return false;
1649     if (!frame-&gt;isMainFrame())
1650         return false;
1651     // Prevent web content from tricking the user into initiating a drag.
1652     if (frame-&gt;eventHandler().mousePressed())
1653         return false;
1654     return true;
1655 }
1656 
1657 void DOMWindow::moveBy(float x, float y) const
1658 {
1659     if (!allowedToChangeWindowGeometry())
1660         return;
1661 
1662     auto* page = frame()-&gt;page();
1663     FloatRect fr = page-&gt;chrome().windowRect();
1664     FloatRect update = fr;
1665     update.move(x, y);
1666     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1667 }
1668 
1669 void DOMWindow::moveTo(float x, float y) const
1670 {
1671     if (!allowedToChangeWindowGeometry())
1672         return;
1673 
1674     auto* page = frame()-&gt;page();
1675     FloatRect fr = page-&gt;chrome().windowRect();
1676     FloatRect sr = screenAvailableRect(page-&gt;mainFrame().view());
1677     fr.setLocation(sr.location());
1678     FloatRect update = fr;
1679     update.move(x, y);
1680     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1681 }
1682 
1683 void DOMWindow::resizeBy(float x, float y) const
1684 {
1685     if (!allowedToChangeWindowGeometry())
1686         return;
1687 
1688     auto* page = frame()-&gt;page();
1689     FloatRect fr = page-&gt;chrome().windowRect();
1690     FloatSize dest = fr.size() + FloatSize(x, y);
1691     FloatRect update(fr.location(), dest);
1692     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1693 }
1694 
1695 void DOMWindow::resizeTo(float width, float height) const
1696 {
1697     if (!allowedToChangeWindowGeometry())
1698         return;
1699 
1700     auto* page = frame()-&gt;page();
1701     FloatRect fr = page-&gt;chrome().windowRect();
1702     FloatSize dest = FloatSize(width, height);
1703     FloatRect update(fr.location(), dest);
1704     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1705 }
1706 
1707 ExceptionOr&lt;int&gt; DOMWindow::setTimeout(JSC::ExecState&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
1708 {
1709     auto* context = scriptExecutionContext();
1710     if (!context)
1711         return Exception { InvalidAccessError };
1712 
1713     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
1714     if (action-&gt;type() == ScheduledAction::Type::Code) {
1715         if (!context-&gt;contentSecurityPolicy()-&gt;allowEval(&amp;state))
1716             return 0;
1717     }
1718 
1719     action-&gt;addArguments(WTFMove(arguments));
1720 
1721     return DOMTimer::install(*context, WTFMove(action), Seconds::fromMilliseconds(timeout), true);
1722 }
1723 
1724 void DOMWindow::clearTimeout(int timeoutId)
1725 {
<a name="49" id="anc49"></a>
















1726     ScriptExecutionContext* context = scriptExecutionContext();
1727     if (!context)
1728         return;
1729     DOMTimer::removeById(*context, timeoutId);
1730 }
1731 
1732 ExceptionOr&lt;int&gt; DOMWindow::setInterval(JSC::ExecState&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
1733 {
1734     auto* context = scriptExecutionContext();
1735     if (!context)
1736         return Exception { InvalidAccessError };
1737 
1738     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
1739     if (action-&gt;type() == ScheduledAction::Type::Code) {
1740         if (!context-&gt;contentSecurityPolicy()-&gt;allowEval(&amp;state))
1741             return 0;
1742     }
1743 
1744     action-&gt;addArguments(WTFMove(arguments));
1745 
1746     return DOMTimer::install(*context, WTFMove(action), Seconds::fromMilliseconds(timeout), false);
1747 }
1748 
1749 void DOMWindow::clearInterval(int timeoutId)
1750 {
1751     ScriptExecutionContext* context = scriptExecutionContext();
1752     if (!context)
1753         return;
1754     DOMTimer::removeById(*context, timeoutId);
1755 }
1756 
1757 int DOMWindow::requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
1758 {
<a name="50" id="anc50"></a>
1759     auto* document = this-&gt;document();
1760     if (!document)
1761         return 0;
1762     return document-&gt;requestAnimationFrame(WTFMove(callback));
1763 }
1764 
1765 int DOMWindow::webkitRequestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
1766 {
<a name="51" id="anc51"></a><span class="line-modified">1767     static bool firstTime = true;</span>
<span class="line-modified">1768     if (firstTime &amp;&amp; document()) {</span>
<span class="line-modified">1769         document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;webkitRequestAnimationFrame() is deprecated and will be removed. Please use requestAnimationFrame() instead.&quot;_s);</span>
<span class="line-modified">1770         firstTime = false;</span>
<span class="line-modified">1771     }</span>
<span class="line-added">1772     return requestAnimationFrame(WTFMove(callback));</span>
1773 }
1774 
1775 void DOMWindow::cancelAnimationFrame(int id)
1776 {
1777     auto* document = this-&gt;document();
1778     if (!document)
1779         return;
1780     document-&gt;cancelAnimationFrame(id);
1781 }
1782 
1783 void DOMWindow::createImageBitmap(ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
1784 {
1785     auto* document = this-&gt;document();
1786     if (!document) {
1787         promise.reject(InvalidStateError);
1788         return;
1789     }
1790     ImageBitmap::createPromise(*document, WTFMove(source), WTFMove(options), WTFMove(promise));
1791 }
1792 
1793 void DOMWindow::createImageBitmap(ImageBitmap::Source&amp;&amp; source, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
1794 {
1795     auto* document = this-&gt;document();
1796     if (!document) {
1797         promise.reject(InvalidStateError);
1798         return;
1799     }
1800     ImageBitmap::createPromise(*document, WTFMove(source), WTFMove(options), sx, sy, sw, sh, WTFMove(promise));
1801 }
1802 
1803 bool DOMWindow::isSecureContext() const
1804 {
1805     auto* document = this-&gt;document();
1806     if (!document)
1807         return false;
1808     return document-&gt;isSecureContext();
1809 }
1810 
1811 static void didAddStorageEventListener(DOMWindow&amp; window)
1812 {
1813     // Creating these WebCore::Storage objects informs the system that we&#39;d like to receive
1814     // notifications about storage events that might be triggered in other processes. Rather
1815     // than subscribe to these notifications explicitly, we subscribe to them implicitly to
1816     // simplify the work done by the system.
1817     window.localStorage();
1818     window.sessionStorage();
1819 }
1820 
1821 bool DOMWindow::isSameSecurityOriginAsMainFrame() const
1822 {
1823     auto* frame = this-&gt;frame();
1824     if (!frame || !frame-&gt;page() || !document())
1825         return false;
1826 
1827     if (frame-&gt;isMainFrame())
1828         return true;
1829 
1830     Document* mainFrameDocument = frame-&gt;mainFrame().document();
1831 
1832     if (mainFrameDocument &amp;&amp; document()-&gt;securityOrigin().canAccess(mainFrameDocument-&gt;securityOrigin()))
1833         return true;
1834 
1835     return false;
1836 }
1837 
<a name="52" id="anc52"></a><span class="line-modified">1838 bool DOMWindow::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
1839 {
1840     if (!EventTarget::addEventListener(eventType, WTFMove(listener), options))
1841         return false;
1842 
<a name="53" id="anc53"></a><span class="line-modified">1843     auto* document = this-&gt;document();</span>
<span class="line-added">1844     if (document) {</span>
1845         document-&gt;addListenerTypeIfNeeded(eventType);
1846         if (eventNames().isWheelEventType(eventType))
1847             document-&gt;didAddWheelEventHandler(*document);
<a name="54" id="anc54"></a><span class="line-modified">1848         else if (eventNames().isTouchRelatedEventType(*document, eventType))</span>
1849             document-&gt;didAddTouchEventHandler(*document);
1850         else if (eventType == eventNames().storageEvent)
1851             didAddStorageEventListener(*this);
1852     }
1853 
1854     if (eventType == eventNames().unloadEvent)
1855         addUnloadEventListener(this);
1856     else if (eventType == eventNames().beforeunloadEvent &amp;&amp; allowsBeforeUnloadListeners(this))
1857         addBeforeUnloadEventListener(this);
1858 #if PLATFORM(IOS_FAMILY)
1859     else if (eventType == eventNames().scrollEvent)
1860         incrementScrollEventListenersCount();
1861 #endif
1862 #if ENABLE(IOS_TOUCH_EVENTS)
<a name="55" id="anc55"></a><span class="line-modified">1863     else if (document &amp;&amp; eventNames().isTouchRelatedEventType(*document, eventType))</span>
1864         ++m_touchAndGestureEventListenerCount;
1865 #endif
1866 #if ENABLE(IOS_GESTURE_EVENTS)
1867     else if (eventNames().isGestureEventType(eventType))
1868         ++m_touchAndGestureEventListenerCount;
1869 #endif
1870 #if ENABLE(GAMEPAD)
1871     else if (eventNames().isGamepadEventType(eventType))
1872         incrementGamepadEventListenerCount();
1873 #endif
<a name="56" id="anc56"></a><span class="line-added">1874 #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-added">1875     else if (eventType == eventNames().deviceorientationEvent)</span>
<span class="line-added">1876         startListeningForDeviceOrientationIfNecessary();</span>
<span class="line-added">1877     else if (eventType == eventNames().devicemotionEvent)</span>
<span class="line-added">1878         startListeningForDeviceMotionIfNecessary();</span>
<span class="line-added">1879 #endif</span>
<span class="line-added">1880 </span>
<span class="line-added">1881     return true;</span>
<span class="line-added">1882 }</span>
1883 
1884 #if ENABLE(DEVICE_ORIENTATION)
<a name="57" id="anc57"></a><span class="line-modified">1885 </span>
<span class="line-added">1886 DeviceOrientationController* DOMWindow::deviceOrientationController() const</span>
<span class="line-added">1887 {</span>
1888 #if PLATFORM(IOS_FAMILY)
<a name="58" id="anc58"></a><span class="line-modified">1889     return document() ? &amp;document()-&gt;deviceOrientationController() : nullptr;</span>












1890 #else
<a name="59" id="anc59"></a><span class="line-modified">1891     return DeviceOrientationController::from(page());</span>
<span class="line-modified">1892 #endif</span>
<span class="line-modified">1893 }</span>
<span class="line-modified">1894 </span>
<span class="line-modified">1895 DeviceMotionController* DOMWindow::deviceMotionController() const</span>
<span class="line-modified">1896 {</span>
<span class="line-modified">1897 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">1898     return document() ? &amp;document()-&gt;deviceMotionController() : nullptr;</span>
<span class="line-modified">1899 #else</span>
<span class="line-modified">1900     return DeviceMotionController::from(page());</span>
<span class="line-modified">1901 #endif</span>
<span class="line-modified">1902 }</span>
<span class="line-modified">1903 </span>
<span class="line-modified">1904 bool DOMWindow::isAllowedToUseDeviceMotionOrientation(String&amp; message) const</span>
<span class="line-modified">1905 {</span>
<span class="line-modified">1906     if (!frame() || !frame()-&gt;settings().deviceOrientationEventEnabled()) {</span>
<span class="line-added">1907         message = &quot;API is disabled&quot;_s;</span>
<span class="line-added">1908         return false;</span>
<span class="line-added">1909     }</span>
<span class="line-added">1910 </span>
<span class="line-added">1911     if (!isSecureContext()) {</span>
<span class="line-added">1912         message = &quot;Browsing context is not secure&quot;_s;</span>
<span class="line-added">1913         return false;</span>
<span class="line-added">1914     }</span>
<span class="line-added">1915 </span>
<span class="line-added">1916     if (!isSameSecurityOriginAsMainFrame()) {</span>
<span class="line-added">1917         message = &quot;Source frame did not have the same security origin as the main page&quot;_s;</span>
<span class="line-added">1918         return false;</span>
<span class="line-added">1919     }</span>
<span class="line-added">1920     return true;</span>
<span class="line-added">1921 }</span>
<span class="line-added">1922 </span>
<span class="line-added">1923 bool DOMWindow::isAllowedToAddDeviceMotionOrientationListener(String&amp; message) const</span>
<span class="line-added">1924 {</span>
<span class="line-added">1925     String innerMessage;</span>
<span class="line-added">1926     if (!isAllowedToUseDeviceMotionOrientation(innerMessage)) {</span>
<span class="line-added">1927         message = makeString(&quot;Blocked attempt to add a device motion or orientation event listener, reason: &quot;, innerMessage, &quot;.&quot;);</span>
<span class="line-added">1928         return false;</span>
<span class="line-added">1929     }</span>
<span class="line-added">1930 </span>
<span class="line-added">1931     if (frame()-&gt;settings().deviceOrientationPermissionAPIEnabled()) {</span>
<span class="line-added">1932         auto accessState = document()-&gt;deviceOrientationAndMotionAccessController().accessState();</span>
<span class="line-added">1933         switch (accessState) {</span>
<span class="line-added">1934         case DeviceOrientationOrMotionPermissionState::Denied:</span>
<span class="line-added">1935             message = &quot;No device motion or orientation events will be fired because permission to use the API was denied.&quot;_s;</span>
<span class="line-added">1936             return false;</span>
<span class="line-added">1937         case DeviceOrientationOrMotionPermissionState::Prompt:</span>
<span class="line-added">1938             message = &quot;No device motion or orientation events will be fired until permission has been requested and granted.&quot;_s;</span>
<span class="line-added">1939             return false;</span>
<span class="line-added">1940         case DeviceOrientationOrMotionPermissionState::Granted:</span>
<span class="line-added">1941             break;</span>
1942         }
<a name="60" id="anc60"></a>
1943     }
<a name="61" id="anc61"></a>
1944 
1945     return true;
1946 }
1947 
<a name="62" id="anc62"></a><span class="line-added">1948 void DOMWindow::startListeningForDeviceOrientationIfNecessary()</span>
<span class="line-added">1949 {</span>
<span class="line-added">1950     if (!hasEventListeners(eventNames().deviceorientationEvent))</span>
<span class="line-added">1951         return;</span>
<span class="line-added">1952 </span>
<span class="line-added">1953     auto* deviceController = deviceOrientationController();</span>
<span class="line-added">1954     if (!deviceController || deviceController-&gt;hasDeviceEventListener(*this))</span>
<span class="line-added">1955         return;</span>
<span class="line-added">1956 </span>
<span class="line-added">1957     String errorMessage;</span>
<span class="line-added">1958     if (!isAllowedToAddDeviceMotionOrientationListener(errorMessage)) {</span>
<span class="line-added">1959         if (auto* document = this-&gt;document())</span>
<span class="line-added">1960             document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, errorMessage);</span>
<span class="line-added">1961         return;</span>
<span class="line-added">1962     }</span>
<span class="line-added">1963 </span>
<span class="line-added">1964     deviceController-&gt;addDeviceEventListener(*this);</span>
<span class="line-added">1965 }</span>
<span class="line-added">1966 </span>
<span class="line-added">1967 void DOMWindow::stopListeningForDeviceOrientationIfNecessary()</span>
<span class="line-added">1968 {</span>
<span class="line-added">1969     if (hasEventListeners(eventNames().deviceorientationEvent))</span>
<span class="line-added">1970         return;</span>
<span class="line-added">1971 </span>
<span class="line-added">1972     if (auto* deviceController = deviceOrientationController())</span>
<span class="line-added">1973         deviceController-&gt;removeDeviceEventListener(*this);</span>
<span class="line-added">1974 }</span>
<span class="line-added">1975 </span>
<span class="line-added">1976 void DOMWindow::startListeningForDeviceMotionIfNecessary()</span>
<span class="line-added">1977 {</span>
<span class="line-added">1978     if (!hasEventListeners(eventNames().devicemotionEvent))</span>
<span class="line-added">1979         return;</span>
<span class="line-added">1980 </span>
<span class="line-added">1981     auto* deviceController = deviceMotionController();</span>
<span class="line-added">1982     if (!deviceController || deviceController-&gt;hasDeviceEventListener(*this))</span>
<span class="line-added">1983         return;</span>
<span class="line-added">1984 </span>
<span class="line-added">1985     String errorMessage;</span>
<span class="line-added">1986     if (!isAllowedToAddDeviceMotionOrientationListener(errorMessage)) {</span>
<span class="line-added">1987         failedToRegisterDeviceMotionEventListener();</span>
<span class="line-added">1988         if (auto* document = this-&gt;document())</span>
<span class="line-added">1989             document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, errorMessage);</span>
<span class="line-added">1990         return;</span>
<span class="line-added">1991     }</span>
<span class="line-added">1992 </span>
<span class="line-added">1993     deviceController-&gt;addDeviceEventListener(*this);</span>
<span class="line-added">1994 }</span>
<span class="line-added">1995 </span>
<span class="line-added">1996 void DOMWindow::stopListeningForDeviceMotionIfNecessary()</span>
<span class="line-added">1997 {</span>
<span class="line-added">1998     if (hasEventListeners(eventNames().devicemotionEvent))</span>
<span class="line-added">1999         return;</span>
<span class="line-added">2000 </span>
<span class="line-added">2001     if (auto* deviceController = deviceMotionController())</span>
<span class="line-added">2002         deviceController-&gt;removeDeviceEventListener(*this);</span>
<span class="line-added">2003 }</span>
<span class="line-added">2004 </span>
<span class="line-added">2005 void DOMWindow::failedToRegisterDeviceMotionEventListener()</span>
<span class="line-added">2006 {</span>
<span class="line-added">2007 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">2008     if (!isSameSecurityOriginAsMainFrame() || !isSecureContext())</span>
<span class="line-added">2009         return;</span>
<span class="line-added">2010 </span>
<span class="line-added">2011     // FIXME: This is a quirk for chase.com on iPad (&lt;rdar://problem/48423023&gt;).</span>
<span class="line-added">2012     if (RegistrableDomain::uncheckedCreateFromRegistrableDomainString(&quot;chase.com&quot;_s).matches(document()-&gt;url())) {</span>
<span class="line-added">2013         // Fire a fake DeviceMotionEvent with acceleration data to unblock the site&#39;s login flow.</span>
<span class="line-added">2014         document()-&gt;postTask([](auto&amp; context) {</span>
<span class="line-added">2015             if (auto* window = downcast&lt;Document&gt;(context).domWindow()) {</span>
<span class="line-added">2016                 auto acceleration = DeviceMotionData::Acceleration::create();</span>
<span class="line-added">2017                 window-&gt;dispatchEvent(DeviceMotionEvent::create(eventNames().devicemotionEvent, DeviceMotionData::create(acceleration.copyRef(), acceleration.copyRef(), DeviceMotionData::RotationRate::create(), WTF::nullopt).ptr()));</span>
<span class="line-added">2018             }</span>
<span class="line-added">2019         });</span>
<span class="line-added">2020     }</span>
<span class="line-added">2021 #endif // PLATFORM(IOS_FAMILY)</span>
<span class="line-added">2022 }</span>
<span class="line-added">2023 </span>
<span class="line-added">2024 #endif // ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-added">2025 </span>
2026 #if PLATFORM(IOS_FAMILY)
2027 
2028 void DOMWindow::incrementScrollEventListenersCount()
2029 {
2030     Document* document = this-&gt;document();
2031     if (++m_scrollEventListenerCount == 1 &amp;&amp; document == &amp;document-&gt;topDocument()) {
2032         Frame* frame = this-&gt;frame();
2033         if (frame &amp;&amp; frame-&gt;page())
2034             frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, true);
2035     }
2036 }
2037 
2038 void DOMWindow::decrementScrollEventListenersCount()
2039 {
2040     Document* document = this-&gt;document();
2041     if (!--m_scrollEventListenerCount &amp;&amp; document == &amp;document-&gt;topDocument()) {
2042         Frame* frame = this-&gt;frame();
2043         if (frame &amp;&amp; frame-&gt;page() &amp;&amp; document-&gt;pageCacheState() == Document::NotInPageCache)
2044             frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, false);
2045     }
2046 }
2047 
2048 #endif
2049 
2050 void DOMWindow::resetAllGeolocationPermission()
2051 {
2052     // FIXME: Can we remove the PLATFORM(IOS_FAMILY)-guard?
2053 #if ENABLE(GEOLOCATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2054     if (m_navigator)
<a name="63" id="anc63"></a><span class="line-modified">2055         NavigatorGeolocation::from(*m_navigator)-&gt;resetAllGeolocationPermission();</span>
2056 #endif
2057 }
2058 
<a name="64" id="anc64"></a><span class="line-modified">2059 bool DOMWindow::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
2060 {
2061     if (!EventTarget::removeEventListener(eventType, listener, options.capture))
2062         return false;
2063 
<a name="65" id="anc65"></a><span class="line-modified">2064     auto* document = this-&gt;document();</span>
<span class="line-added">2065     if (document) {</span>
2066         if (eventNames().isWheelEventType(eventType))
2067             document-&gt;didRemoveWheelEventHandler(*document);
<a name="66" id="anc66"></a><span class="line-modified">2068         else if (eventNames().isTouchRelatedEventType(*document, eventType))</span>
2069             document-&gt;didRemoveTouchEventHandler(*document);
2070     }
2071 
2072     if (eventType == eventNames().unloadEvent)
2073         removeUnloadEventListener(this);
2074     else if (eventType == eventNames().beforeunloadEvent &amp;&amp; allowsBeforeUnloadListeners(this))
2075         removeBeforeUnloadEventListener(this);
<a name="67" id="anc67"></a>















2076 #if PLATFORM(IOS_FAMILY)
2077     else if (eventType == eventNames().scrollEvent)
2078         decrementScrollEventListenersCount();
2079 #endif
2080 #if ENABLE(IOS_TOUCH_EVENTS)
<a name="68" id="anc68"></a><span class="line-modified">2081     else if (document &amp;&amp; eventNames().isTouchRelatedEventType(*document, eventType)) {</span>
2082         ASSERT(m_touchAndGestureEventListenerCount &gt; 0);
2083         --m_touchAndGestureEventListenerCount;
2084     }
2085 #endif
2086 #if ENABLE(IOS_GESTURE_EVENTS)
2087     else if (eventNames().isGestureEventType(eventType)) {
2088         ASSERT(m_touchAndGestureEventListenerCount &gt; 0);
2089         --m_touchAndGestureEventListenerCount;
2090     }
2091 #endif
2092 #if ENABLE(GAMEPAD)
2093     else if (eventNames().isGamepadEventType(eventType))
2094         decrementGamepadEventListenerCount();
2095 #endif
<a name="69" id="anc69"></a><span class="line-added">2096 #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-added">2097     else if (eventType == eventNames().deviceorientationEvent)</span>
<span class="line-added">2098         stopListeningForDeviceOrientationIfNecessary();</span>
<span class="line-added">2099     else if (eventType == eventNames().devicemotionEvent)</span>
<span class="line-added">2100         stopListeningForDeviceMotionIfNecessary();</span>
<span class="line-added">2101 #endif</span>
2102 
2103     return true;
2104 }
2105 
2106 void DOMWindow::languagesChanged()
2107 {
2108     if (auto* document = this-&gt;document())
2109         document-&gt;enqueueWindowEvent(Event::create(eventNames().languagechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
2110 }
2111 
2112 void DOMWindow::dispatchLoadEvent()
2113 {
2114     // If we did not protect it, the document loader and its timing subobject might get destroyed
2115     // as a side effect of what event handling code does.
2116     auto protectedThis = makeRef(*this);
2117     auto protectedLoader = makeRefPtr(frame() ? frame()-&gt;loader().documentLoader() : nullptr);
2118     bool shouldMarkLoadEventTimes = protectedLoader &amp;&amp; !protectedLoader-&gt;timing().loadEventStart();
2119 
2120     if (shouldMarkLoadEventTimes)
2121         protectedLoader-&gt;timing().markLoadEventStart();
2122 
2123     dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No), document());
2124 
2125     if (shouldMarkLoadEventTimes)
2126         protectedLoader-&gt;timing().markLoadEventEnd();
2127 
2128     // Send a separate load event to the element that owns this frame.
2129     if (frame()) {
2130         if (auto* owner = frame()-&gt;ownerElement())
2131             owner-&gt;dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
2132     }
2133 
2134     InspectorInstrumentation::loadEventFired(frame());
2135 }
2136 
2137 void DOMWindow::dispatchEvent(Event&amp; event, EventTarget* target)
2138 {
2139     // FIXME: It&#39;s confusing to have both the inherited EventTarget::dispatchEvent function
2140     // and this function, which does something nearly identical but subtly different if
2141     // called with a target of null. Most callers pass the document as the target, though.
2142     // Fixing this could allow us to remove the special case in DocumentEventQueue::dispatchEvent.
2143 
2144     auto protectedThis = makeRef(*this);
2145 
2146     // Pausing a page may trigger pagehide and pageshow events. WebCore also implicitly fires these
2147     // events when closing a WebView. Here we keep track of the state of the page to prevent duplicate,
2148     // unbalanced events per the definition of the pageshow event:
2149     // &lt;http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html#event-pageshow&gt;.
2150     // FIXME: This code should go at call sites where pageshowEvent and pagehideEvents are
2151     // generated, not here inside the event dispatching process.
2152     if (event.eventInterface() == PageTransitionEventInterfaceType) {
2153         if (event.type() == eventNames().pageshowEvent) {
2154             if (m_lastPageStatus == PageStatus::Shown)
2155                 return; // Event was previously dispatched; do not fire a duplicate event.
2156             m_lastPageStatus = PageStatus::Shown;
2157         } else if (event.type() == eventNames().pagehideEvent) {
2158             if (m_lastPageStatus == PageStatus::Hidden)
2159                 return; // Event was previously dispatched; do not fire a duplicate event.
2160             m_lastPageStatus = PageStatus::Hidden;
2161         }
2162     }
2163 
2164     // FIXME: It doesn&#39;t seem right to have the inspector instrumentation here since not all
2165     // events dispatched to the window object are guaranteed to flow through this function.
2166     // But the instrumentation prevents us from calling EventDispatcher::dispatchEvent here.
2167     event.setTarget(target ? target : this);
2168     event.setCurrentTarget(this);
2169     event.setEventPhase(Event::AT_TARGET);
2170     event.resetBeforeDispatch();
2171     auto cookie = InspectorInstrumentation::willDispatchEventOnWindow(frame(), event, *this);
2172     // FIXME: We should use EventDispatcher everywhere.
2173     fireEventListeners(event, EventInvokePhase::Capturing);
2174     fireEventListeners(event, EventInvokePhase::Bubbling);
<a name="70" id="anc70"></a><span class="line-modified">2175     InspectorInstrumentation::didDispatchEventOnWindow(cookie, event.defaultPrevented());</span>
2176     event.resetAfterDispatch();
2177 }
2178 
2179 void DOMWindow::removeAllEventListeners()
2180 {
2181     EventTarget::removeAllEventListeners();
2182 
2183 #if ENABLE(DEVICE_ORIENTATION)
<a name="71" id="anc71"></a><span class="line-modified">2184         stopListeningForDeviceOrientationIfNecessary();</span>
<span class="line-modified">2185         stopListeningForDeviceMotionIfNecessary();</span>
<span class="line-modified">2186 #endif</span>









2187 
2188 #if PLATFORM(IOS_FAMILY)
2189     if (m_scrollEventListenerCount) {
2190         m_scrollEventListenerCount = 1;
2191         decrementScrollEventListenersCount();
2192     }
2193 #endif
2194 
2195 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS)
2196     m_touchAndGestureEventListenerCount = 0;
2197 #endif
2198 
2199 #if ENABLE(TOUCH_EVENTS)
2200     if (Document* document = this-&gt;document())
2201         document-&gt;didRemoveEventTargetNode(*document);
2202 #endif
2203 
2204     if (m_performance) {
2205         m_performance-&gt;removeAllEventListeners();
2206         m_performance-&gt;removeAllObservers();
2207     }
2208 
2209     removeAllUnloadEventListeners(this);
2210     removeAllBeforeUnloadEventListeners(this);
2211 }
2212 
2213 void DOMWindow::captureEvents()
2214 {
2215     // Not implemented.
2216 }
2217 
2218 void DOMWindow::releaseEvents()
2219 {
2220     // Not implemented.
2221 }
2222 
2223 void DOMWindow::finishedLoading()
2224 {
2225     if (m_shouldPrintWhenFinishedLoading) {
2226         m_shouldPrintWhenFinishedLoading = false;
2227         if (frame()-&gt;loader().activeDocumentLoader()-&gt;mainDocumentError().isNull())
2228             print();
2229     }
2230 }
2231 
2232 void DOMWindow::setLocation(DOMWindow&amp; activeWindow, const URL&amp; completedURL, SetLocationLocking locking)
2233 {
2234     if (!isCurrentlyDisplayedInFrame())
2235         return;
2236 
2237     Document* activeDocument = activeWindow.document();
2238     if (!activeDocument)
2239         return;
2240 
2241     auto* frame = this-&gt;frame();
2242     if (!activeDocument-&gt;canNavigate(frame, completedURL))
2243         return;
2244 
2245     if (isInsecureScriptAccess(activeWindow, completedURL))
2246         return;
2247 
2248     // We want a new history item if we are processing a user gesture.
2249     LockHistory lockHistory = (locking != LockHistoryBasedOnGestureState || !UserGestureIndicator::processingUserGesture()) ? LockHistory::Yes : LockHistory::No;
2250     LockBackForwardList lockBackForwardList = (locking != LockHistoryBasedOnGestureState) ? LockBackForwardList::Yes : LockBackForwardList::No;
2251     frame-&gt;navigationScheduler().scheduleLocationChange(*activeDocument, activeDocument-&gt;securityOrigin(),
2252         // FIXME: What if activeDocument()-&gt;frame() is 0?
2253         completedURL, activeDocument-&gt;frame()-&gt;loader().outgoingReferrer(),
2254         lockHistory, lockBackForwardList);
2255 }
2256 
2257 void DOMWindow::printErrorMessage(const String&amp; message)
2258 {
2259     if (message.isEmpty())
2260         return;
2261 
2262     if (PageConsoleClient* pageConsole = console())
2263         pageConsole-&gt;addMessage(MessageSource::JS, MessageLevel::Error, message);
2264 }
2265 
2266 String DOMWindow::crossDomainAccessErrorMessage(const DOMWindow&amp; activeWindow, IncludeTargetOrigin includeTargetOrigin)
2267 {
2268     const URL&amp; activeWindowURL = activeWindow.document()-&gt;url();
2269     if (activeWindowURL.isNull())
2270         return String();
2271 
2272     ASSERT(!activeWindow.document()-&gt;securityOrigin().canAccess(document()-&gt;securityOrigin()));
2273 
2274     // FIXME: This message, and other console messages, have extra newlines. Should remove them.
2275     SecurityOrigin&amp; activeOrigin = activeWindow.document()-&gt;securityOrigin();
2276     SecurityOrigin&amp; targetOrigin = document()-&gt;securityOrigin();
2277     String message;
2278     if (includeTargetOrigin == IncludeTargetOrigin::Yes)
2279         message = makeString(&quot;Blocked a frame with origin \&quot;&quot;, activeOrigin.toString(), &quot;\&quot; from accessing a frame with origin \&quot;&quot;, targetOrigin.toString(), &quot;\&quot;. &quot;);
2280     else
2281         message = makeString(&quot;Blocked a frame with origin \&quot;&quot;, activeOrigin.toString(), &quot;\&quot; from accessing a cross-origin frame. &quot;);
2282 
2283     // Sandbox errors: Use the origin of the frames&#39; location, rather than their actual origin (since we know that at least one will be &quot;null&quot;).
2284     URL activeURL = activeWindow.document()-&gt;url();
2285     URL targetURL = document()-&gt;url();
2286     if (document()-&gt;isSandboxed(SandboxOrigin) || activeWindow.document()-&gt;isSandboxed(SandboxOrigin)) {
2287         if (includeTargetOrigin == IncludeTargetOrigin::Yes)
2288             message = makeString(&quot;Blocked a frame at \&quot;&quot;, SecurityOrigin::create(activeURL).get().toString(), &quot;\&quot; from accessing a frame at \&quot;&quot;, SecurityOrigin::create(targetURL).get().toString(), &quot;\&quot;. &quot;);
2289         else
2290             message = makeString(&quot;Blocked a frame at \&quot;&quot;, SecurityOrigin::create(activeURL).get().toString(), &quot;\&quot; from accessing a cross-origin frame. &quot;);
2291 
2292         if (document()-&gt;isSandboxed(SandboxOrigin) &amp;&amp; activeWindow.document()-&gt;isSandboxed(SandboxOrigin))
2293             return makeString(&quot;Sandbox access violation: &quot;, message, &quot; Both frames are sandboxed and lack the \&quot;allow-same-origin\&quot; flag.&quot;);
2294         if (document()-&gt;isSandboxed(SandboxOrigin))
2295             return makeString(&quot;Sandbox access violation: &quot;, message, &quot; The frame being accessed is sandboxed and lacks the \&quot;allow-same-origin\&quot; flag.&quot;);
2296         return makeString(&quot;Sandbox access violation: &quot;, message, &quot; The frame requesting access is sandboxed and lacks the \&quot;allow-same-origin\&quot; flag.&quot;);
2297     }
2298 
2299     if (includeTargetOrigin == IncludeTargetOrigin::Yes) {
2300         // Protocol errors: Use the URL&#39;s protocol rather than the origin&#39;s protocol so that we get a useful message for non-heirarchal URLs like &#39;data:&#39;.
2301         if (targetOrigin.protocol() != activeOrigin.protocol())
2302             return message + &quot; The frame requesting access has a protocol of \&quot;&quot; + activeURL.protocol() + &quot;\&quot;, the frame being accessed has a protocol of \&quot;&quot; + targetURL.protocol() + &quot;\&quot;. Protocols must match.\n&quot;;
2303 
2304         // &#39;document.domain&#39; errors.
2305         if (targetOrigin.domainWasSetInDOM() &amp;&amp; activeOrigin.domainWasSetInDOM())
2306             return message + &quot;The frame requesting access set \&quot;document.domain\&quot; to \&quot;&quot; + activeOrigin.domain() + &quot;\&quot;, the frame being accessed set it to \&quot;&quot; + targetOrigin.domain() + &quot;\&quot;. Both must set \&quot;document.domain\&quot; to the same value to allow access.&quot;;
2307         if (activeOrigin.domainWasSetInDOM())
2308             return message + &quot;The frame requesting access set \&quot;document.domain\&quot; to \&quot;&quot; + activeOrigin.domain() + &quot;\&quot;, but the frame being accessed did not. Both must set \&quot;document.domain\&quot; to the same value to allow access.&quot;;
2309         if (targetOrigin.domainWasSetInDOM())
2310             return message + &quot;The frame being accessed set \&quot;document.domain\&quot; to \&quot;&quot; + targetOrigin.domain() + &quot;\&quot;, but the frame requesting access did not. Both must set \&quot;document.domain\&quot; to the same value to allow access.&quot;;
2311     }
2312 
2313     // Default.
2314     return message + &quot;Protocols, domains, and ports must match.&quot;;
2315 }
2316 
2317 bool DOMWindow::isInsecureScriptAccess(DOMWindow&amp; activeWindow, const String&amp; urlString)
2318 {
2319     if (!WTF::protocolIsJavaScript(urlString))
2320         return false;
2321 
2322     // If this DOMWindow isn&#39;t currently active in the Frame, then there&#39;s no
2323     // way we should allow the access.
2324     // FIXME: Remove this check if we&#39;re able to disconnect DOMWindow from
2325     // Frame on navigation: https://bugs.webkit.org/show_bug.cgi?id=62054
2326     if (isCurrentlyDisplayedInFrame()) {
2327         // FIXME: Is there some way to eliminate the need for a separate &quot;activeWindow == this&quot; check?
2328         if (&amp;activeWindow == this)
2329             return false;
2330 
2331         // FIXME: The name canAccess seems to be a roundabout way to ask &quot;can execute script&quot;.
2332         // Can we name the SecurityOrigin function better to make this more clear?
2333         if (activeWindow.document()-&gt;securityOrigin().canAccess(document()-&gt;securityOrigin()))
2334             return false;
2335     }
2336 
2337     printErrorMessage(crossDomainAccessErrorMessage(activeWindow, IncludeTargetOrigin::Yes));
2338     return true;
2339 }
2340 
<a name="72" id="anc72"></a><span class="line-modified">2341 ExceptionOr&lt;RefPtr&lt;Frame&gt;&gt; DOMWindow::createWindow(const String&amp; urlString, const AtomString&amp; frameName, const WindowFeatures&amp; windowFeatures, DOMWindow&amp; activeWindow, Frame&amp; firstFrame, Frame&amp; openerFrame, const WTF::Function&lt;void(DOMWindow&amp;)&gt;&amp; prepareDialogFunction)</span>
2342 {
2343     Frame* activeFrame = activeWindow.frame();
2344     if (!activeFrame)
2345         return RefPtr&lt;Frame&gt; { nullptr };
2346 
2347     Document* activeDocument = activeWindow.document();
2348     if (!activeDocument)
2349         return RefPtr&lt;Frame&gt; { nullptr };
2350 
2351     URL completedURL = urlString.isEmpty() ? URL({ }, emptyString()) : firstFrame.document()-&gt;completeURL(urlString);
2352     if (!completedURL.isEmpty() &amp;&amp; !completedURL.isValid())
2353         return Exception { SyntaxError };
2354 
2355     // For whatever reason, Firefox uses the first frame to determine the outgoingReferrer. We replicate that behavior here.
<a name="73" id="anc73"></a><span class="line-modified">2356     String referrer = windowFeatures.noreferrer ? String() : SecurityPolicy::generateReferrerHeader(firstFrame.document()-&gt;referrerPolicy(), completedURL, firstFrame.loader().outgoingReferrer());</span>
2357     auto initiatedByMainFrame = activeFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
2358 
2359     ResourceRequest resourceRequest { completedURL, referrer };
2360     FrameLoader::addHTTPOriginIfNeeded(resourceRequest, firstFrame.loader().outgoingOrigin());
2361     FrameLoadRequest frameLoadRequest { *activeDocument, activeDocument-&gt;securityOrigin(), resourceRequest, frameName, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, activeDocument-&gt;shouldOpenExternalURLsPolicyToPropagate(), initiatedByMainFrame };
2362 
2363     // We pass the opener frame for the lookupFrame in case the active frame is different from
2364     // the opener frame, and the name references a frame relative to the opener frame.
2365     bool created;
2366     auto newFrame = WebCore::createWindow(*activeFrame, openerFrame, WTFMove(frameLoadRequest), windowFeatures, created);
2367     if (!newFrame)
2368         return RefPtr&lt;Frame&gt; { nullptr };
2369 
<a name="74" id="anc74"></a><span class="line-modified">2370     bool noopener = windowFeatures.noopener || windowFeatures.noreferrer;</span>
<span class="line-added">2371     if (!noopener)</span>
2372         newFrame-&gt;loader().setOpener(&amp;openerFrame);
2373 
2374     if (created)
2375         newFrame-&gt;page()-&gt;setOpenedByDOM();
2376 
2377     if (newFrame-&gt;document()-&gt;domWindow()-&gt;isInsecureScriptAccess(activeWindow, completedURL))
<a name="75" id="anc75"></a><span class="line-modified">2378         return noopener ? RefPtr&lt;Frame&gt; { nullptr } : newFrame;</span>
2379 
2380     if (prepareDialogFunction)
2381         prepareDialogFunction(*newFrame-&gt;document()-&gt;domWindow());
2382 
2383     if (created) {
2384         ResourceRequest resourceRequest { completedURL, referrer, ResourceRequestCachePolicy::UseProtocolCachePolicy };
2385         FrameLoader::addSameSiteInfoToRequestIfNeeded(resourceRequest, openerFrame.document());
2386         FrameLoadRequest frameLoadRequest { *activeWindow.document(), activeWindow.document()-&gt;securityOrigin(), resourceRequest, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, activeDocument-&gt;shouldOpenExternalURLsPolicyToPropagate(), initiatedByMainFrame };
2387         newFrame-&gt;loader().changeLocation(WTFMove(frameLoadRequest));
2388     } else if (!urlString.isEmpty()) {
2389         LockHistory lockHistory = UserGestureIndicator::processingUserGesture() ? LockHistory::No : LockHistory::Yes;
2390         newFrame-&gt;navigationScheduler().scheduleLocationChange(*activeDocument, activeDocument-&gt;securityOrigin(), completedURL, referrer, lockHistory, LockBackForwardList::No);
2391     }
2392 
2393     // Navigating the new frame could result in it being detached from its page by a navigation policy delegate.
2394     if (!newFrame-&gt;page())
2395         return RefPtr&lt;Frame&gt; { nullptr };
2396 
<a name="76" id="anc76"></a><span class="line-modified">2397     return noopener ? RefPtr&lt;Frame&gt; { nullptr } : newFrame;</span>
2398 }
2399 
<a name="77" id="anc77"></a><span class="line-modified">2400 ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; DOMWindow::open(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; urlStringToOpen, const AtomString&amp; frameName, const String&amp; windowFeaturesString)</span>
2401 {
2402     if (!isCurrentlyDisplayedInFrame())
2403         return RefPtr&lt;WindowProxy&gt; { nullptr };
2404 
2405     auto* activeDocument = activeWindow.document();
2406     if (!activeDocument)
2407         return RefPtr&lt;WindowProxy&gt; { nullptr };
2408 
2409     auto* firstFrame = firstWindow.frame();
2410     if (!firstFrame)
2411         return RefPtr&lt;WindowProxy&gt; { nullptr };
2412 
<a name="78" id="anc78"></a><span class="line-added">2413     auto urlString = urlStringToOpen;</span>
<span class="line-added">2414     if (activeDocument-&gt;quirks().shouldOpenAsAboutBlank(urlStringToOpen))</span>
<span class="line-added">2415         urlString = &quot;about:blank&quot;_s;</span>
<span class="line-added">2416 </span>
2417 #if ENABLE(CONTENT_EXTENSIONS)
2418     if (firstFrame-&gt;document()
2419         &amp;&amp; firstFrame-&gt;page()
2420         &amp;&amp; firstFrame-&gt;mainFrame().document()
2421         &amp;&amp; firstFrame-&gt;mainFrame().document()-&gt;loader()) {
<a name="79" id="anc79"></a><span class="line-modified">2422         auto results = firstFrame-&gt;page()-&gt;userContentProvider().processContentRuleListsForLoad(firstFrame-&gt;document()-&gt;completeURL(urlString), ContentExtensions::ResourceType::Popup, *firstFrame-&gt;mainFrame().document()-&gt;loader());</span>
<span class="line-modified">2423         if (results.summary.blockedLoad)</span>
<span class="line-modified">2424             return RefPtr&lt;WindowProxy&gt; { nullptr };</span>


2425     }
2426 #endif
2427 
2428     auto* frame = this-&gt;frame();
2429     if (!firstWindow.allowPopUp()) {
2430         // Because FrameTree::findFrameForNavigation() returns true for empty strings, we must check for empty frame names.
2431         // Otherwise, illegitimate window.open() calls with no name will pass right through the popup blocker.
2432         if (frameName.isEmpty() || !frame-&gt;loader().findFrameForNavigation(frameName, activeDocument))
2433             return RefPtr&lt;WindowProxy&gt; { nullptr };
2434     }
2435 
2436     // Get the target frame for the special cases of _top and _parent.
2437     // In those cases, we schedule a location change right now and return early.
2438     Frame* targetFrame = nullptr;
2439     if (equalIgnoringASCIICase(frameName, &quot;_top&quot;))
2440         targetFrame = &amp;frame-&gt;tree().top();
2441     else if (equalIgnoringASCIICase(frameName, &quot;_parent&quot;)) {
2442         if (Frame* parent = frame-&gt;tree().parent())
2443             targetFrame = parent;
2444         else
2445             targetFrame = frame;
2446     }
2447     if (targetFrame) {
2448         if (!activeDocument-&gt;canNavigate(targetFrame))
2449             return RefPtr&lt;WindowProxy&gt; { nullptr };
2450 
2451         URL completedURL = firstFrame-&gt;document()-&gt;completeURL(urlString);
2452 
2453         if (targetFrame-&gt;document()-&gt;domWindow()-&gt;isInsecureScriptAccess(activeWindow, completedURL))
2454             return &amp;targetFrame-&gt;windowProxy();
2455 
2456         if (urlString.isEmpty())
2457             return &amp;targetFrame-&gt;windowProxy();
2458 
2459         // For whatever reason, Firefox uses the first window rather than the active window to
2460         // determine the outgoing referrer. We replicate that behavior here.
2461         LockHistory lockHistory = UserGestureIndicator::processingUserGesture() ? LockHistory::No : LockHistory::Yes;
2462         targetFrame-&gt;navigationScheduler().scheduleLocationChange(*activeDocument, activeDocument-&gt;securityOrigin(), completedURL, firstFrame-&gt;loader().outgoingReferrer(),
2463             lockHistory, LockBackForwardList::No);
2464         return &amp;targetFrame-&gt;windowProxy();
2465     }
2466 
2467     auto newFrameOrException = createWindow(urlString, frameName, parseWindowFeatures(windowFeaturesString), activeWindow, *firstFrame, *frame);
2468     if (newFrameOrException.hasException())
2469         return newFrameOrException.releaseException();
2470 
2471     auto newFrame = newFrameOrException.releaseReturnValue();
2472     return newFrame ? &amp;newFrame-&gt;windowProxy() : RefPtr&lt;WindowProxy&gt; { nullptr };
2473 }
2474 
2475 void DOMWindow::showModalDialog(const String&amp; urlString, const String&amp; dialogFeaturesString, DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const WTF::Function&lt;void (DOMWindow&amp;)&gt;&amp; prepareDialogFunction)
2476 {
2477     if (!isCurrentlyDisplayedInFrame())
2478         return;
2479     if (!activeWindow.frame())
2480         return;
2481     Frame* firstFrame = firstWindow.frame();
2482     if (!firstFrame)
2483         return;
2484 
2485     auto* frame = this-&gt;frame();
2486     auto* page = frame-&gt;page();
2487     if (!page)
2488         return;
2489 
2490     if (!page-&gt;arePromptsAllowed()) {
2491         printErrorMessage(&quot;Use of window.showModalDialog is not allowed while unloading a page.&quot;);
2492         return;
2493     }
2494 
2495     if (!canShowModalDialog(*frame) || !firstWindow.allowPopUp())
2496         return;
2497 
2498     auto dialogFrameOrException = createWindow(urlString, emptyAtom(), parseDialogFeatures(dialogFeaturesString, screenAvailableRect(frame-&gt;view())), activeWindow, *firstFrame, *frame, prepareDialogFunction);
2499     if (dialogFrameOrException.hasException())
2500         return;
2501     RefPtr&lt;Frame&gt; dialogFrame = dialogFrameOrException.releaseReturnValue();
2502     if (!dialogFrame)
2503         return;
2504     dialogFrame-&gt;page()-&gt;chrome().runModal();
2505 }
2506 
2507 void DOMWindow::enableSuddenTermination()
2508 {
2509     if (Page* page = this-&gt;page())
2510         page-&gt;chrome().enableSuddenTermination();
2511 }
2512 
2513 void DOMWindow::disableSuddenTermination()
2514 {
2515     if (Page* page = this-&gt;page())
2516         page-&gt;chrome().disableSuddenTermination();
2517 }
2518 
2519 Frame* DOMWindow::frame() const
2520 {
2521     auto* document = this-&gt;document();
2522     return document ? document-&gt;frame() : nullptr;
2523 }
2524 
2525 } // namespace WebCore
<a name="80" id="anc80"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="80" type="hidden" />
</body>
</html>