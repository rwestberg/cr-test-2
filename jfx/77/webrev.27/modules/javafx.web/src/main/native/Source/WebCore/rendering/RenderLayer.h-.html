<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2003, 2009, 2012, 2015 Apple Inc. All rights reserved.
   3  *
   4  * Portions are Copyright (C) 1998 Netscape Communications Corporation.
   5  *
   6  * Other contributors:
   7  *   Robert O&#39;Callahan &lt;roc+@cs.cmu.edu&gt;
   8  *   David Baron &lt;dbaron@fas.harvard.edu&gt;
   9  *   Christian Biesinger &lt;cbiesinger@web.de&gt;
  10  *   Randall Jesup &lt;rjesup@wgate.com&gt;
  11  *   Roland Mainz &lt;roland.mainz@informatik.med.uni-giessen.de&gt;
  12  *   Josh Soref &lt;timeless@mac.com&gt;
  13  *   Boris Zbarsky &lt;bzbarsky@mit.edu&gt;
  14  *
  15  * This library is free software; you can redistribute it and/or
  16  * modify it under the terms of the GNU Lesser General Public
  17  * License as published by the Free Software Foundation; either
  18  * version 2.1 of the License, or (at your option) any later version.
  19  *
  20  * This library is distributed in the hope that it will be useful,
  21  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  22  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  23  * Lesser General Public License for more details.
  24  *
  25  * You should have received a copy of the GNU Lesser General Public
  26  * License along with this library; if not, write to the Free Software
  27  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  28  *
  29  * Alternatively, the contents of this file may be used under the terms
  30  * of either the Mozilla Public License Version 1.1, found at
  31  * http://www.mozilla.org/MPL/ (the &quot;MPL&quot;) or the GNU General Public
  32  * License Version 2.0, found at http://www.fsf.org/copyleft/gpl.html
  33  * (the &quot;GPL&quot;), in which case the provisions of the MPL or the GPL are
  34  * applicable instead of those above.  If you wish to allow use of your
  35  * version of this file only under the terms of one of those two
  36  * licenses (the MPL or the GPL) and not to allow others to use your
  37  * version of this file under the LGPL, indicate your decision by
  38  * deletingthe provisions above and replace them with the notice and
  39  * other provisions required by the MPL or the GPL, as the case may be.
  40  * If you do not delete the provisions above, a recipient may use your
  41  * version of this file under any of the LGPL, the MPL or the GPL.
  42  */
  43 
  44 #pragma once
  45 
  46 #include &quot;ClipRect.h&quot;
  47 #include &quot;GraphicsLayer.h&quot;
  48 #include &quot;LayerFragment.h&quot;
  49 #include &quot;PaintFrequencyTracker.h&quot;
  50 #include &quot;PaintInfo.h&quot;
  51 #include &quot;RenderBox.h&quot;
  52 #include &quot;RenderPtr.h&quot;
  53 #include &quot;ScrollableArea.h&quot;
  54 #include &lt;memory&gt;
  55 #include &lt;wtf/WeakPtr.h&gt;
  56 
  57 namespace WTF {
  58 class TextStream;
  59 }
  60 
  61 namespace WebCore {
  62 
  63 class CSSFilter;
  64 class ClipRects;
  65 class ClipRectsCache;
  66 class HitTestRequest;
  67 class HitTestResult;
  68 class HitTestingTransformState;
  69 class RenderFragmentedFlow;
  70 class RenderGeometryMap;
  71 class RenderLayerBacking;
  72 class RenderLayerCompositor;
  73 class RenderLayerFilters;
  74 class RenderMarquee;
  75 class RenderReplica;
  76 class RenderScrollbarPart;
  77 class RenderStyle;
  78 class RenderView;
  79 class Scrollbar;
  80 class TransformationMatrix;
  81 
  82 enum BorderRadiusClippingRule { IncludeSelfForBorderRadius, DoNotIncludeSelfForBorderRadius };
  83 enum IncludeSelfOrNot { IncludeSelf, ExcludeSelf };
  84 
  85 enum RepaintStatus {
  86     NeedsNormalRepaint,
  87     NeedsFullRepaint,
  88     NeedsFullRepaintForPositionedMovementLayout
  89 };
  90 
  91 enum ClipRectsType {
  92     PaintingClipRects, // Relative to painting ancestor. Used for painting.
  93     RootRelativeClipRects, // Relative to the ancestor treated as the root (e.g. transformed layer). Used for hit testing.
  94     AbsoluteClipRects, // Relative to the RenderView&#39;s layer. Used for compositing overlap testing.
  95     NumCachedClipRectsTypes,
  96     AllClipRectTypes,
  97     TemporaryClipRects
  98 };
  99 
 100 enum ShouldRespectOverflowClip {
 101     IgnoreOverflowClip,
 102     RespectOverflowClip
 103 };
 104 
 105 enum ShouldApplyRootOffsetToFragments {
 106     ApplyRootOffsetToFragments,
 107     IgnoreRootOffsetForFragments
 108 };
 109 
 110 enum class RequestState {
 111     Unknown,
 112     DontCare,
 113     False,
 114     True,
 115     Undetermined
 116 };
 117 
 118 struct ScrollRectToVisibleOptions {
 119     SelectionRevealMode revealMode { SelectionRevealMode::Reveal };
 120     const ScrollAlignment&amp; alignX { ScrollAlignment::alignCenterIfNeeded };
 121     const ScrollAlignment&amp; alignY { ScrollAlignment::alignCenterIfNeeded };
 122     ShouldAllowCrossOriginScrolling shouldAllowCrossOriginScrolling { ShouldAllowCrossOriginScrolling::No };
 123 };
 124 
 125 class RenderLayer final : public ScrollableArea {
 126     WTF_MAKE_FAST_ALLOCATED;
 127 public:
 128     friend class RenderReplica;
 129     friend class RenderLayerFilters;
 130 
 131     explicit RenderLayer(RenderLayerModelObject&amp;);
 132     virtual ~RenderLayer();
 133 
 134 #if PLATFORM(IOS_FAMILY)
 135     // Called before the renderer&#39;s widget (if any) has been nulled out.
 136     void willBeDestroyed();
 137 #endif
 138     String name() const;
 139 
 140     Page&amp; page() const { return renderer().page(); }
 141     RenderLayerModelObject&amp; renderer() const { return m_renderer; }
 142     RenderBox* renderBox() const { return is&lt;RenderBox&gt;(renderer()) ? &amp;downcast&lt;RenderBox&gt;(renderer()) : nullptr; }
 143 
 144     RenderLayer* parent() const { return m_parent; }
 145     RenderLayer* previousSibling() const { return m_previous; }
 146     RenderLayer* nextSibling() const { return m_next; }
 147     RenderLayer* firstChild() const { return m_first; }
 148     RenderLayer* lastChild() const { return m_last; }
 149     bool isDescendantOf(const RenderLayer&amp;) const;
 150 
 151     // This does an ancestor tree walk. Avoid it!
 152     const RenderLayer* root() const
 153     {
 154         const RenderLayer* curr = this;
 155         while (curr-&gt;parent())
 156             curr = curr-&gt;parent();
 157         return curr;
 158     }
 159 
 160     void addChild(RenderLayer&amp; newChild, RenderLayer* beforeChild = nullptr);
 161     void removeChild(RenderLayer&amp;);
 162 
 163     void insertOnlyThisLayer();
 164     void removeOnlyThisLayer();
 165 
 166     bool isNormalFlowOnly() const { return m_isNormalFlowOnly; }
 167     bool isStackingContext() const { return m_isStackingContext; }
 168 
 169     // Gets the enclosing stacking context for this layer, excluding this layer itself.
 170     RenderLayer* stackingContext() const;
 171 
 172     // Gets the enclosing stacking container for this layer, possibly the layer
 173     // itself, if it is a stacking container.
 174     RenderLayer* enclosingStackingContext() { return isStackingContext() ? this : stackingContext(); }
 175 
 176     RenderLayer* paintOrderParent() const;
 177 
 178     void dirtyNormalFlowList();
 179     void dirtyZOrderLists();
 180     void dirtyStackingContextZOrderLists();
 181 
 182     bool normalFlowListDirty() const { return m_normalFlowListDirty; }
 183     bool zOrderListsDirty() const { return m_zOrderListsDirty; }
 184 
 185 #if !ASSERT_DISABLED
 186     bool layerListMutationAllowed() const { return m_layerListMutationAllowed; }
 187     void setLayerListMutationAllowed(bool flag) { m_layerListMutationAllowed = flag; }
 188 #endif
 189 
 190 private:
 191     // These flags propagate in paint order (z-order tree).
 192     enum class Compositing {
 193         HasDescendantNeedingRequirementsTraversal           = 1 &lt;&lt; 0, // Need to do the overlap-testing tree walk because hierarchy or geometry changed.
 194         HasDescendantNeedingBackingOrHierarchyTraversal     = 1 &lt;&lt; 1, // Need to update geometry, configuration and update the GraphicsLayer tree.
 195 
 196         // Things that trigger HasDescendantNeedingRequirementsTraversal
 197         NeedsPaintOrderChildrenUpdate                       = 1 &lt;&lt; 2, // The paint order children of this layer changed (gained/lost child, order change).
 198         NeedsPostLayoutUpdate                               = 1 &lt;&lt; 3, // Needs compositing to be re-evaluated after layout (it depends on geometry).
 199         DescendantsNeedRequirementsTraversal                = 1 &lt;&lt; 4, // Something changed that forces computeCompositingRequirements to traverse all descendant layers.
 200         SubsequentLayersNeedRequirementsTraversal           = 1 &lt;&lt; 5, // Something changed that forces computeCompositingRequirements to traverse all layers later in paint order.
 201 
 202         // Things that trigger HasDescendantNeedingBackingOrHierarchyTraversal
 203         NeedsGeometryUpdate                                 = 1 &lt;&lt; 6, // This layer needs a geometry update.
 204         NeedsConfigurationUpdate                            = 1 &lt;&lt; 7, // This layer needs a configuration update (updating its internal compositing hierarchy).
 205         NeedsScrollingTreeUpdate                            = 1 &lt;&lt; 8, // Something changed that requires this layer&#39;s scrolling tree node to be updated.
 206         NeedsLayerConnection                                = 1 &lt;&lt; 9, // This layer needs hookup with its parents or children.
 207         ChildrenNeedGeometryUpdate                          = 1 &lt;&lt; 10, // This layer&#39;s composited children need a geometry update.
 208         DescendantsNeedBackingAndHierarchyTraversal         = 1 &lt;&lt; 11, // Something changed that forces us to traverse all descendant layers in updateBackingAndHierarchy.
 209     };
 210 
 211     static constexpr OptionSet&lt;Compositing&gt; computeCompositingRequirementsFlags()
 212     {
 213         return {
 214             Compositing::NeedsPaintOrderChildrenUpdate,
 215             Compositing::NeedsPostLayoutUpdate,
 216             Compositing::DescendantsNeedRequirementsTraversal,
 217             Compositing::SubsequentLayersNeedRequirementsTraversal,
 218         };
 219     }
 220 
 221     static constexpr OptionSet&lt;Compositing&gt; updateBackingOrHierarchyFlags()
 222     {
 223         return {
 224             Compositing::NeedsLayerConnection,
 225             Compositing::NeedsGeometryUpdate,
 226             Compositing::NeedsConfigurationUpdate,
 227             Compositing::NeedsScrollingTreeUpdate,
 228             Compositing::ChildrenNeedGeometryUpdate,
 229             Compositing::DescendantsNeedBackingAndHierarchyTraversal,
 230         };
 231     }
 232 
 233     void setAncestorsHaveCompositingDirtyFlag(Compositing);
 234 
 235 public:
 236     bool hasDescendantNeedingCompositingRequirementsTraversal() const { return m_compositingDirtyBits.contains(Compositing::HasDescendantNeedingRequirementsTraversal); }
 237     bool hasDescendantNeedingUpdateBackingOrHierarchyTraversal() const { return m_compositingDirtyBits.contains(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal); }
 238 
 239     bool needsCompositingPaintOrderChildrenUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsPaintOrderChildrenUpdate); }
 240     bool needsPostLayoutCompositingUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsPostLayoutUpdate); }
 241     bool descendantsNeedCompositingRequirementsTraversal() const { return m_compositingDirtyBits.contains(Compositing::DescendantsNeedRequirementsTraversal); }
 242     bool subsequentLayersNeedCompositingRequirementsTraversal() const { return m_compositingDirtyBits.contains(Compositing::SubsequentLayersNeedRequirementsTraversal); }
 243 
 244     bool needsCompositingLayerConnection() const { return m_compositingDirtyBits.contains(Compositing::NeedsLayerConnection); }
 245     bool needsCompositingGeometryUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsGeometryUpdate); }
 246     bool needsCompositingConfigurationUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsConfigurationUpdate); }
 247     bool needsScrollingTreeUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsScrollingTreeUpdate); }
 248     bool childrenNeedCompositingGeometryUpdate() const { return m_compositingDirtyBits.contains(Compositing::ChildrenNeedGeometryUpdate); }
 249     bool descendantsNeedUpdateBackingAndHierarchyTraversal() const { return m_compositingDirtyBits.contains(Compositing::DescendantsNeedBackingAndHierarchyTraversal); }
 250 
 251     template&lt;Compositing V&gt;
 252     void setRequirementsTraversalDirtyBit()
 253     {
 254         m_compositingDirtyBits.add(V);
 255         setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingRequirementsTraversal);
 256     }
 257 
 258     void setNeedsCompositingPaintOrderChildrenUpdate() { setRequirementsTraversalDirtyBit&lt;Compositing::NeedsPaintOrderChildrenUpdate&gt;(); }
 259     void setNeedsPostLayoutCompositingUpdate() { setRequirementsTraversalDirtyBit&lt;Compositing::NeedsPostLayoutUpdate&gt;(); }
 260     void setDescendantsNeedCompositingRequirementsTraversal() { setRequirementsTraversalDirtyBit&lt;Compositing::DescendantsNeedRequirementsTraversal&gt;(); }
 261     void setSubsequentLayersNeedCompositingRequirementsTraversal() { setRequirementsTraversalDirtyBit&lt;Compositing::SubsequentLayersNeedRequirementsTraversal&gt;(); }
 262 
 263     void setNeedsPostLayoutCompositingUpdateOnAncestors() { setAncestorsHaveCompositingDirtyFlag(Compositing::NeedsPostLayoutUpdate); }
 264 
 265     template&lt;Compositing V&gt;
 266     void setBackingAndHierarchyTraversalDirtyBit()
 267     {
 268         m_compositingDirtyBits.add(V);
 269         setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal);
 270     }
 271 
 272     void setNeedsCompositingLayerConnection() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsLayerConnection&gt;(); }
 273     void setNeedsCompositingGeometryUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsGeometryUpdate&gt;(); }
 274     void setNeedsCompositingConfigurationUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsConfigurationUpdate&gt;(); }
 275     void setNeedsScrollingTreeUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsScrollingTreeUpdate&gt;(); }
 276     void setChildrenNeedCompositingGeometryUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::ChildrenNeedGeometryUpdate&gt;(); }
 277     void setDescendantsNeedUpdateBackingAndHierarchyTraversal() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::DescendantsNeedBackingAndHierarchyTraversal&gt;(); }
 278 
 279     void setNeedsCompositingGeometryUpdateOnAncestors() { setAncestorsHaveCompositingDirtyFlag(Compositing::NeedsGeometryUpdate); }
 280 
 281     bool needsCompositingRequirementsTraversal() const { return m_compositingDirtyBits.containsAny(computeCompositingRequirementsFlags()); }
 282     void clearCompositingRequirementsTraversalState()
 283     {
 284         m_compositingDirtyBits.remove(Compositing::HasDescendantNeedingRequirementsTraversal);
 285         m_compositingDirtyBits.remove(computeCompositingRequirementsFlags());
 286     }
 287 
 288     bool needsUpdateBackingOrHierarchyTraversal() const { return m_compositingDirtyBits.containsAny(updateBackingOrHierarchyFlags()); }
 289     void clearUpdateBackingOrHierarchyTraversalState()
 290     {
 291         m_compositingDirtyBits.remove(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal);
 292         m_compositingDirtyBits.remove(updateBackingOrHierarchyFlags());
 293     }
 294 
 295     bool needsAnyCompositingTraversal() const { return !m_compositingDirtyBits.isEmpty(); }
 296     void clearCompositingPaintOrderState() { m_compositingDirtyBits = { }; }
 297 
 298     class LayerList {
 299         friend class RenderLayer;
 300     public:
 301         using iterator = RenderLayer**;
 302         using const_iterator = RenderLayer * const *;
 303         using reverse_iterator = std::reverse_iterator&lt;iterator&gt;;
 304         using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;
 305 
 306         iterator begin() { return m_layerList ? m_layerList-&gt;begin() : nullptr; }
 307         iterator end() { return m_layerList ? m_layerList-&gt;end() : nullptr; }
 308 
 309         reverse_iterator rbegin() { return reverse_iterator(end()); }
 310         reverse_iterator rend() { return reverse_iterator(begin()); }
 311 
 312         const_iterator begin() const { return m_layerList ? m_layerList-&gt;begin() : nullptr; }
 313         const_iterator end() const { return m_layerList ? m_layerList-&gt;end() : nullptr; }
 314 
 315         const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
 316         const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
 317 
 318         size_t size() const { return m_layerList ? m_layerList-&gt;size() : 0; }
 319 
 320     private:
 321         LayerList(Vector&lt;RenderLayer*&gt;* layerList)
 322             : m_layerList(layerList)
 323         {
 324         }
 325 
 326         Vector&lt;RenderLayer*&gt;* m_layerList;
 327     };
 328 
 329     LayerList normalFlowLayers() const
 330     {
 331         ASSERT(!m_normalFlowListDirty);
 332         return LayerList(m_normalFlowList.get());
 333     }
 334 
 335     LayerList positiveZOrderLayers() const
 336     {
 337         ASSERT(!m_zOrderListsDirty);
 338         ASSERT(isStackingContext() || !m_posZOrderList);
 339         return LayerList(m_posZOrderList.get());
 340     }
 341 
 342     bool hasNegativeZOrderLayers() const
 343     {
 344         return m_negZOrderList &amp;&amp; m_negZOrderList-&gt;size();
 345     }
 346 
 347     LayerList negativeZOrderLayers() const
 348     {
 349         ASSERT(!m_zOrderListsDirty);
 350         ASSERT(isStackingContext() || !m_negZOrderList);
 351         return LayerList(m_negZOrderList.get());
 352     }
 353 
 354     // Update our normal and z-index lists.
 355     void updateLayerListsIfNeeded();
 356     void updateDescendantDependentFlags();
 357     bool descendantDependentFlagsAreDirty() const
 358     {
 359         return m_visibleDescendantStatusDirty || m_visibleContentStatusDirty || m_hasSelfPaintingLayerDescendantDirty
 360 #if ENABLE(CSS_COMPOSITING)
 361             || m_hasNotIsolatedBlendingDescendantsStatusDirty
 362 #endif
 363         ;
 364     }
 365 
 366     void repaintIncludingDescendants();
 367 
 368     // Indicate that the layer contents need to be repainted. Only has an effect
 369     // if layer compositing is being used.
 370     void setBackingNeedsRepaint(GraphicsLayer::ShouldClipToLayer = GraphicsLayer::ClipToLayer);
 371 
 372     // The rect is in the coordinate space of the layer&#39;s render object.
 373     void setBackingNeedsRepaintInRect(const LayoutRect&amp;, GraphicsLayer::ShouldClipToLayer = GraphicsLayer::ClipToLayer);
 374     void repaintIncludingNonCompositingDescendants(RenderLayerModelObject* repaintContainer);
 375 
 376     void styleChanged(StyleDifference, const RenderStyle* oldStyle);
 377 
 378     RenderMarquee* marquee() const { return m_marquee.get(); }
 379 
 380     bool isSelfPaintingLayer() const { return m_isSelfPaintingLayer; }
 381 
 382     bool cannotBlitToWindow() const;
 383 
 384     bool isTransparent() const { return renderer().isTransparent() || renderer().hasMask(); }
 385 
 386     bool hasReflection() const { return renderer().hasReflection(); }
 387     bool isReflection() const { return renderer().isReplica(); }
 388     RenderReplica* reflection() const { return m_reflection.get(); }
 389     RenderLayer* reflectionLayer() const;
 390     bool isReflectionLayer(const RenderLayer&amp;) const;
 391 
 392     const LayoutPoint&amp; location() const { return m_topLeft; }
 393     void setLocation(const LayoutPoint&amp; p) { m_topLeft = p; }
 394 
 395     const IntSize&amp; size() const { return m_layerSize; }
 396     void setSize(const IntSize&amp; size) { m_layerSize = size; } // Only public for RenderTreeAsText.
 397 
 398     LayoutRect rect() const { return LayoutRect(location(), size()); }
 399 
 400     IntSize visibleSize() const override;
 401     IntSize contentsSize() const override;
 402 
 403     int scrollWidth() const;
 404     int scrollHeight() const;
 405 
 406     void panScrollFromPoint(const IntPoint&amp;);
 407 
 408     // Scrolling methods for layers that can scroll their overflow.
 409     void scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea = nullptr);
 410 
 411     WEBCORE_EXPORT void scrollToOffset(const ScrollOffset&amp;, ScrollClamping = ScrollClamping::Clamped);
 412     void scrollToXOffset(int x, ScrollClamping clamping = ScrollClamping::Clamped) { scrollToOffset(ScrollOffset(x, scrollOffset().y()), clamping); }
 413     void scrollToYOffset(int y, ScrollClamping clamping = ScrollClamping::Clamped) { scrollToOffset(ScrollOffset(scrollOffset().x(), y), clamping); }
 414 
 415     void scrollToXPosition(int x, ScrollClamping = ScrollClamping::Clamped);
 416     void scrollToYPosition(int y, ScrollClamping = ScrollClamping::Clamped);
 417 
 418     void setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt;);
 419     void applyPostLayoutScrollPositionIfNeeded();
 420 
 421     ScrollOffset scrollOffset() const { return scrollOffsetFromPosition(m_scrollPosition); }
 422     IntSize scrollableContentsSize() const;
 423 
 424     void availableContentSizeChanged(AvailableSizeChangeReason) override;
 425 
 426     // &quot;absoluteRect&quot; is in scaled document coordinates.
 427     void scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
 428 
 429     bool scrollsOverflow() const;
 430     bool hasScrollbars() const { return m_hBar || m_vBar; }
 431     void setHasHorizontalScrollbar(bool);
 432     void setHasVerticalScrollbar(bool);
 433 
 434     Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation);
 435     void destroyScrollbar(ScrollbarOrientation);
 436 
 437     bool hasHorizontalScrollbar() const { return horizontalScrollbar(); }
 438     bool hasVerticalScrollbar() const { return verticalScrollbar(); }
 439 
 440     // ScrollableArea overrides
 441     ScrollPosition scrollPosition() const override { return m_scrollPosition; }
 442 
 443     Scrollbar* horizontalScrollbar() const override { return m_hBar.get(); }
 444     Scrollbar* verticalScrollbar() const override { return m_vBar.get(); }
 445     ScrollableArea* enclosingScrollableArea() const override;
 446     bool isScrollableOrRubberbandable() override;
 447     bool hasScrollableOrRubberbandableAncestor() override;
 448     bool useDarkAppearance() const final;
 449 #if ENABLE(CSS_SCROLL_SNAP)
 450     void updateSnapOffsets() override;
 451 #endif
 452 
 453     void setIsUserScroll(bool isUserScroll) override { m_inUserScroll = isUserScroll; }
 454     bool isInUserScroll() const { return m_inUserScroll; }
 455 
 456     bool requiresScrollPositionReconciliation() const { return m_requiresScrollPositionReconciliation; }
 457     void setRequiresScrollPositionReconciliation(bool requiresReconciliation = true) { m_requiresScrollPositionReconciliation = requiresReconciliation; }
 458 
 459 #if PLATFORM(IOS_FAMILY)
 460 #if ENABLE(IOS_TOUCH_EVENTS)
 461     bool handleTouchEvent(const PlatformTouchEvent&amp;) override;
 462 #endif
 463 
 464     void didStartScroll() override;
 465     void didEndScroll() override;
 466     void didUpdateScroll() override;
 467 #endif
 468 
 469     // Returns true when the layer could do touch scrolling, but doesn&#39;t look at whether there is actually scrollable overflow.
 470     bool canUseCompositedScrolling() const;
 471     // Returns true when there is actually scrollable overflow (requires layout to be up-to-date).
 472     bool hasCompositedScrollableOverflow() const;
 473 
 474     int verticalScrollbarWidth(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
 475     int horizontalScrollbarHeight(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
 476 
 477     bool hasOverflowControls() const;
 478     bool isPointInResizeControl(const IntPoint&amp; absolutePoint) const;
 479     bool hitTestOverflowControls(HitTestResult&amp;, const IntPoint&amp; localPoint);
 480     IntSize offsetFromResizeCorner(const IntPoint&amp; absolutePoint) const;
 481 
 482     void paintOverflowControls(GraphicsContext&amp;, const IntPoint&amp;, const IntRect&amp; damageRect, bool paintingOverlayControls = false);
 483     void paintScrollCorner(GraphicsContext&amp;, const IntPoint&amp;, const IntRect&amp; damageRect);
 484     void paintResizer(GraphicsContext&amp;, const LayoutPoint&amp;, const LayoutRect&amp; damageRect);
 485 
 486     void updateScrollInfoAfterLayout();
 487 
 488     bool scroll(ScrollDirection, ScrollGranularity, float multiplier = 1);
 489     void autoscroll(const IntPoint&amp;);
 490 
 491     bool canResize() const;
 492     void resize(const PlatformMouseEvent&amp;, const LayoutSize&amp;);
 493     bool inResizeMode() const { return m_inResizeMode; }
 494     void setInResizeMode(bool b) { m_inResizeMode = b; }
 495 
 496     bool isRenderViewLayer() const { return m_isRenderViewLayer; }
 497     bool isForcedStackingContext() const { return m_forcedStackingContext; }
 498 
 499     RenderLayerCompositor&amp; compositor() const;
 500 
 501     // Notification from the renderer that its content changed (e.g. current frame of image changed).
 502     // Allows updates of layer content without repainting.
 503     void contentChanged(ContentChangeType);
 504 
 505     bool canRender3DTransforms() const;
 506 
 507     enum UpdateLayerPositionsFlag {
 508         CheckForRepaint                 = 1 &lt;&lt; 0,
 509         NeedsFullRepaintInBacking       = 1 &lt;&lt; 1,
 510         UpdatePagination                = 1 &lt;&lt; 2,
 511         SeenTransformedLayer            = 1 &lt;&lt; 3,
 512         Seen3DTransformedLayer          = 1 &lt;&lt; 4,
 513     };
 514     static constexpr OptionSet&lt;UpdateLayerPositionsFlag&gt; updateLayerPositionsDefaultFlags() { return { CheckForRepaint }; }
 515 
 516     void updateLayerPositionsAfterLayout(const RenderLayer* rootLayer, OptionSet&lt;UpdateLayerPositionsFlag&gt;);
 517 
 518     void updateLayerPositionsAfterOverflowScroll();
 519     void updateLayerPositionsAfterDocumentScroll();
 520 
 521     bool hasCompositedLayerInEnclosingPaginationChain() const;
 522     enum PaginationInclusionMode { ExcludeCompositedPaginatedLayers, IncludeCompositedPaginatedLayers };
 523     RenderLayer* enclosingPaginationLayer(PaginationInclusionMode mode) const
 524     {
 525         if (mode == ExcludeCompositedPaginatedLayers &amp;&amp; hasCompositedLayerInEnclosingPaginationChain())
 526             return nullptr;
 527         return m_enclosingPaginationLayer.get();
 528     }
 529 
 530     void updateTransform();
 531 
 532 #if ENABLE(CSS_COMPOSITING)
 533     void updateBlendMode();
 534 #endif
 535 
 536     const LayoutSize&amp; offsetForInFlowPosition() const { return m_offsetForInFlowPosition; }
 537 
 538     void clearClipRectsIncludingDescendants(ClipRectsType typeToClear = AllClipRectTypes);
 539     void clearClipRects(ClipRectsType typeToClear = AllClipRectTypes);
 540 
 541     void addBlockSelectionGapsBounds(const LayoutRect&amp;);
 542     void clearBlockSelectionGapsBounds();
 543     void repaintBlockSelectionGaps();
 544 
 545     // FIXME: We should ASSERT(!m_visibleContentStatusDirty) here, but see https://bugs.webkit.org/show_bug.cgi?id=71044
 546     // ditto for hasVisibleDescendant(), see https://bugs.webkit.org/show_bug.cgi?id=71277
 547     bool hasVisibleContent() const { return m_hasVisibleContent; }
 548     bool hasVisibleDescendant() const { return m_hasVisibleDescendant; }
 549 
 550     void setHasVisibleContent();
 551     void dirtyVisibleContentStatus();
 552 
 553     bool hasVisibleBoxDecorationsOrBackground() const;
 554     bool hasVisibleBoxDecorations() const;
 555 
 556     struct PaintedContentRequest {
 557         void makeStatesUndetermined()
 558         {
 559             if (hasPaintedContent == RequestState::Unknown)
 560                 hasPaintedContent = RequestState::Undetermined;
 561 
 562             if (hasSubpixelAntialiasedText == RequestState::Unknown)
 563                 hasSubpixelAntialiasedText = RequestState::Undetermined;
 564         }
 565 
 566         void setHasPaintedContent() { hasPaintedContent = RequestState::True; }
 567         void setHasSubpixelAntialiasedText() { hasSubpixelAntialiasedText = RequestState::True; }
 568 
 569         bool needToDeterminePaintedContentState() const { return hasPaintedContent == RequestState::Unknown; }
 570         bool needToDetermineSubpixelAntialiasedTextState() const { return hasSubpixelAntialiasedText == RequestState::Unknown; }
 571 
 572         bool probablyHasPaintedContent() const { return hasPaintedContent == RequestState::True || hasPaintedContent == RequestState::Undetermined; }
 573         bool probablyHasSubpixelAntialiasedText() const { return hasSubpixelAntialiasedText == RequestState::True || hasSubpixelAntialiasedText == RequestState::Undetermined; }
 574 
 575         bool isSatisfied() const { return hasPaintedContent != RequestState::Unknown &amp;&amp; hasSubpixelAntialiasedText != RequestState::Unknown; }
 576 
 577         RequestState hasPaintedContent { RequestState::Unknown };
 578         RequestState hasSubpixelAntialiasedText { RequestState::DontCare };
 579     };
 580 
 581     // Returns true if this layer has visible content (ignoring any child layers).
 582     bool isVisuallyNonEmpty(PaintedContentRequest* = nullptr) const;
 583     // True if this layer container renderers that paint.
 584     bool hasNonEmptyChildRenderers(PaintedContentRequest&amp;) const;
 585 
 586     // FIXME: We should ASSERT(!m_hasSelfPaintingLayerDescendantDirty); here but we hit the same bugs as visible content above.
 587     // Part of the issue is with subtree relayout: we don&#39;t check if our ancestors have some descendant flags dirty, missing some updates.
 588     bool hasSelfPaintingLayerDescendant() const { return m_hasSelfPaintingLayerDescendant; }
 589 
 590     // Gets the nearest enclosing positioned ancestor layer (also includes
 591     // the &lt;html&gt; layer and the root layer).
 592     RenderLayer* enclosingAncestorForPosition(PositionType) const;
 593 
 594     // Returns the nearest enclosing layer that is scrollable.
 595     RenderLayer* enclosingScrollableLayer() const;
 596 
 597     // The layer relative to which clipping rects for this layer are computed.
 598     RenderLayer* clippingRootForPainting() const;
 599 
 600     RenderLayer* enclosingOverflowClipLayer(IncludeSelfOrNot) const;
 601 
 602     // Enclosing compositing layer; if includeSelf is true, may return this.
 603     RenderLayer* enclosingCompositingLayer(IncludeSelfOrNot = IncludeSelf) const;
 604     RenderLayer* enclosingCompositingLayerForRepaint(IncludeSelfOrNot = IncludeSelf) const;
 605     // Ancestor compositing layer, excluding this.
 606     RenderLayer* ancestorCompositingLayer() const { return enclosingCompositingLayer(ExcludeSelf); }
 607 
 608     RenderLayer* enclosingFilterLayer(IncludeSelfOrNot = IncludeSelf) const;
 609     RenderLayer* enclosingFilterRepaintLayer() const;
 610     void setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp;);
 611     bool hasAncestorWithFilterOutsets() const;
 612 
 613     bool canUseConvertToLayerCoords() const
 614     {
 615         // These RenderObject have an impact on their layers&#39; without them knowing about it.
 616         return !renderer().hasTransform() &amp;&amp; !renderer().isSVGRoot();
 617     }
 618 
 619     // FIXME: adjustForColumns allows us to position compositing layers in columns correctly, but eventually they need to be split across columns too.
 620     enum ColumnOffsetAdjustment { DontAdjustForColumns, AdjustForColumns };
 621     void convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; location, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 622     LayoutPoint convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp;, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 623     LayoutSize offsetFromAncestor(const RenderLayer*, ColumnOffsetAdjustment = DontAdjustForColumns) const;
 624 
 625     int zIndex() const { return renderer().style().zIndex(); }
 626 
 627     enum PaintLayerFlag {
 628         PaintLayerHaveTransparency                      = 1 &lt;&lt; 0,
 629         PaintLayerAppliedTransform                      = 1 &lt;&lt; 1,
 630         PaintLayerTemporaryClipRects                    = 1 &lt;&lt; 2,
 631         PaintLayerPaintingReflection                    = 1 &lt;&lt; 3,
 632         PaintLayerPaintingOverlayScrollbars             = 1 &lt;&lt; 4,
 633         PaintLayerPaintingCompositingBackgroundPhase    = 1 &lt;&lt; 5,
 634         PaintLayerPaintingCompositingForegroundPhase    = 1 &lt;&lt; 6,
 635         PaintLayerPaintingCompositingMaskPhase          = 1 &lt;&lt; 7,
 636         PaintLayerPaintingCompositingClipPathPhase      = 1 &lt;&lt; 8,
 637         PaintLayerPaintingCompositingScrollingPhase     = 1 &lt;&lt; 9,
 638         PaintLayerPaintingOverflowContents              = 1 &lt;&lt; 10,
 639         PaintLayerPaintingRootBackgroundOnly            = 1 &lt;&lt; 11,
 640         PaintLayerPaintingSkipRootBackground            = 1 &lt;&lt; 12,
 641         PaintLayerPaintingChildClippingMaskPhase        = 1 &lt;&lt; 13,
 642     };
 643     static constexpr OptionSet&lt;PaintLayerFlag&gt; paintLayerPaintingCompositingAllPhasesFlags() { return { PaintLayerPaintingCompositingBackgroundPhase,  PaintLayerPaintingCompositingForegroundPhase }; }
 644 
 645     enum class SecurityOriginPaintPolicy { AnyOrigin, AccessibleOriginOnly };
 646 
 647     // The two main functions that use the layer system.  The paint method
 648     // paints the layers that intersect the damage rect from back to
 649     // front.  The hitTest method looks for mouse events by walking
 650     // layers that intersect the point from front to back.
 651     void paint(GraphicsContext&amp;, const LayoutRect&amp; damageRect, const LayoutSize&amp; subpixelOffset = LayoutSize(), OptionSet&lt;PaintBehavior&gt; = PaintBehavior::Normal,
 652         RenderObject* subtreePaintRoot = nullptr, OptionSet&lt;PaintLayerFlag&gt; = { }, SecurityOriginPaintPolicy = SecurityOriginPaintPolicy::AnyOrigin);
 653     bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;);
 654     bool hitTest(const HitTestRequest&amp;, const HitTestLocation&amp;, HitTestResult&amp;);
 655     void paintOverlayScrollbars(GraphicsContext&amp;, const LayoutRect&amp; damageRect, OptionSet&lt;PaintBehavior&gt;, RenderObject* subtreePaintRoot = nullptr);
 656 
 657     struct ClipRectsContext {
 658         ClipRectsContext(const RenderLayer* inRootLayer, ClipRectsType inClipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize, ShouldRespectOverflowClip inRespectOverflowClip = RespectOverflowClip)
 659             : rootLayer(inRootLayer)
 660             , clipRectsType(inClipRectsType)
 661             , overlayScrollbarSizeRelevancy(inOverlayScrollbarSizeRelevancy)
 662             , respectOverflowClip(inRespectOverflowClip)
 663         { }
 664         const RenderLayer* rootLayer;
 665         ClipRectsType clipRectsType;
 666         OverlayScrollbarSizeRelevancy overlayScrollbarSizeRelevancy;
 667         ShouldRespectOverflowClip respectOverflowClip;
 668     };
 669 
 670     // This method figures out our layerBounds in coordinates relative to
 671     // |rootLayer}.  It also computes our background and foreground clip rects
 672     // for painting/event handling.
 673     // Pass offsetFromRoot if known.
 674     void calculateRects(const ClipRectsContext&amp;, const LayoutRect&amp; paintDirtyRect, LayoutRect&amp; layerBounds,
 675         ClipRect&amp; backgroundRect, ClipRect&amp; foregroundRect, const LayoutSize&amp; offsetFromRoot) const;
 676 
 677     // Public just for RenderTreeAsText.
 678     void collectFragments(LayerFragments&amp;, const RenderLayer* rootLayer, const LayoutRect&amp; dirtyRect,
 679         PaginationInclusionMode,
 680         ClipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy, ShouldRespectOverflowClip, const LayoutSize&amp; offsetFromRoot,
 681         const LayoutRect* layerBoundingBox = nullptr, ShouldApplyRootOffsetToFragments = IgnoreRootOffsetForFragments);
 682 
 683     LayoutRect childrenClipRect() const; // Returns the foreground clip rect of the layer in the document&#39;s coordinate space.
 684     LayoutRect selfClipRect() const; // Returns the background clip rect of the layer in the document&#39;s coordinate space.
 685     LayoutRect localClipRect(bool&amp; clipExceedsBounds) const; // Returns the background clip rect of the layer in the local coordinate space.
 686 
 687     // Pass offsetFromRoot if known.
 688     bool intersectsDamageRect(const LayoutRect&amp; layerBounds, const LayoutRect&amp; damageRect, const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot, const LayoutRect* cachedBoundingBox = nullptr) const;
 689 
 690     enum CalculateLayerBoundsFlag {
 691         IncludeSelfTransform                    = 1 &lt;&lt; 0,
 692         UseLocalClipRectIfPossible              = 1 &lt;&lt; 1,
 693         IncludeFilterOutsets                    = 1 &lt;&lt; 2,
 694         IncludePaintedFilterOutsets             = 1 &lt;&lt; 3,
 695         ExcludeHiddenDescendants                = 1 &lt;&lt; 4,
 696         DontConstrainForMask                    = 1 &lt;&lt; 5,
 697         IncludeCompositedDescendants            = 1 &lt;&lt; 6,
 698         UseFragmentBoxesExcludingCompositing    = 1 &lt;&lt; 7,
 699         UseFragmentBoxesIncludingCompositing    = 1 &lt;&lt; 8,
 700     };
 701     static constexpr OptionSet&lt;CalculateLayerBoundsFlag&gt; defaultCalculateLayerBoundsFlags() { return { IncludeSelfTransform, UseLocalClipRectIfPossible, IncludePaintedFilterOutsets, UseFragmentBoxesExcludingCompositing }; }
 702 
 703     // Bounding box relative to some ancestor layer. Pass offsetFromRoot if known.
 704     LayoutRect boundingBox(const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot = LayoutSize(), OptionSet&lt;CalculateLayerBoundsFlag&gt; = { }) const;
 705     // Bounding box in the coordinates of this layer.
 706     LayoutRect localBoundingBox(OptionSet&lt;CalculateLayerBoundsFlag&gt; = { }) const;
 707     // Deprecated: Pixel snapped bounding box relative to the root.
 708     WEBCORE_EXPORT IntRect absoluteBoundingBox() const;
 709     // Device pixel snapped bounding box relative to the root. absoluteBoundingBox() callers will be directed to this.
 710     FloatRect absoluteBoundingBoxForPainting() const;
 711 
 712     // Bounds used for layer overlap testing in RenderLayerCompositor.
 713     LayoutRect overlapBounds() const;
 714 
 715     // Takes transform animations into account, returning true if they could be cheaply computed.
 716     // Unlike overlapBounds, these bounds include descendant layers.
 717     bool getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(LayoutRect&amp;, OptionSet&lt;CalculateLayerBoundsFlag&gt; additionalFlags = { }) const;
 718 
 719     // If true, this layer&#39;s children are included in its bounds for overlap testing.
 720     // We can&#39;t rely on the children&#39;s positions if this layer has a filter that could have moved the children&#39;s pixels around.
 721     bool overlapBoundsIncludeChildren() const { return hasFilter() &amp;&amp; renderer().style().filter().hasFilterThatMovesPixels(); }
 722 
 723     // Can pass offsetFromRoot if known.
 724     LayoutRect calculateLayerBounds(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; = defaultCalculateLayerBoundsFlags()) const;
 725 
 726     // Return a cached repaint rect, computed relative to the layer renderer&#39;s containerForRepaint.
 727     bool hasComputedRepaintRects() const { return renderer().hasRepaintLayoutRects(); }
 728     LayoutRect repaintRectIncludingNonCompositingDescendants() const;
 729 
 730     void setRepaintStatus(RepaintStatus status) { m_repaintStatus = status; }
 731     RepaintStatus repaintStatus() const { return static_cast&lt;RepaintStatus&gt;(m_repaintStatus); }
 732 
 733     LayoutUnit staticInlinePosition() const { return m_staticInlinePosition; }
 734     LayoutUnit staticBlockPosition() const { return m_staticBlockPosition; }
 735 
 736     void setStaticInlinePosition(LayoutUnit position) { m_staticInlinePosition = position; }
 737     void setStaticBlockPosition(LayoutUnit position) { m_staticBlockPosition = position; }
 738 
 739 #if PLATFORM(IOS_FAMILY)
 740     bool adjustForIOSCaretWhenScrolling() const { return m_adjustForIOSCaretWhenScrolling; }
 741     void setAdjustForIOSCaretWhenScrolling(bool adjustForIOSCaretWhenScrolling) { m_adjustForIOSCaretWhenScrolling = adjustForIOSCaretWhenScrolling; }
 742 #endif
 743 
 744     bool hasTransform() const { return renderer().hasTransform(); }
 745     // Note that this transform has the transform-origin baked in.
 746     TransformationMatrix* transform() const { return m_transform.get(); }
 747     // currentTransform computes a transform which takes accelerated animations into account. The
 748     // resulting transform has transform-origin baked in. If the layer does not have a transform,
 749     // returns the identity matrix.
 750     TransformationMatrix currentTransform(RenderStyle::ApplyTransformOrigin = RenderStyle::IncludeTransformOrigin) const;
 751     TransformationMatrix renderableTransform(OptionSet&lt;PaintBehavior&gt;) const;
 752 
 753     // Get the perspective transform, which is applied to transformed sublayers.
 754     // Returns true if the layer has a -webkit-perspective.
 755     // Note that this transform has the perspective-origin baked in.
 756     TransformationMatrix perspectiveTransform() const;
 757     FloatPoint perspectiveOrigin() const;
 758     bool preserves3D() const { return renderer().style().transformStyle3D() == TransformStyle3D::Preserve3D; }
 759     bool has3DTransform() const { return m_transform &amp;&amp; !m_transform-&gt;isAffine(); }
 760 
 761     void filterNeedsRepaint();
 762     bool hasFilter() const { return renderer().hasFilter(); }
 763     bool hasBackdropFilter() const
 764     {
 765 #if ENABLE(FILTERS_LEVEL_2)
 766         return renderer().hasBackdropFilter();
 767 #else
 768         return false;
 769 #endif
 770     }
 771 
 772 #if ENABLE(CSS_COMPOSITING)
 773     bool hasBlendMode() const { return renderer().hasBlendMode(); }
 774     BlendMode blendMode() const { return static_cast&lt;BlendMode&gt;(m_blendMode); }
 775 
 776     bool isolatesCompositedBlending() const { return m_hasNotIsolatedCompositedBlendingDescendants &amp;&amp; isStackingContext(); }
 777     bool hasNotIsolatedCompositedBlendingDescendants() const { return m_hasNotIsolatedCompositedBlendingDescendants; }
 778     void setHasNotIsolatedCompositedBlendingDescendants(bool hasNotIsolatedCompositedBlendingDescendants)
 779     {
 780         m_hasNotIsolatedCompositedBlendingDescendants = hasNotIsolatedCompositedBlendingDescendants;
 781     }
 782 
 783     bool isolatesBlending() const { return hasNotIsolatedBlendingDescendants() &amp;&amp; isStackingContext(); }
 784 
 785     // FIXME: We should ASSERT(!m_hasNotIsolatedBlendingDescendantsStatusDirty); here but we hit the same bugs as visible content above.
 786     bool hasNotIsolatedBlendingDescendants() const { return m_hasNotIsolatedBlendingDescendants; }
 787     bool hasNotIsolatedBlendingDescendantsStatusDirty() const { return m_hasNotIsolatedBlendingDescendantsStatusDirty; }
 788 #else
 789     bool hasBlendMode() const { return false; }
 790     bool isolatesCompositedBlending() const { return false; }
 791     bool isolatesBlending() const { return false; }
 792     bool hasNotIsolatedBlendingDescendantsStatusDirty() const { return false; }
 793 #endif
 794 
 795     bool isComposited() const { return m_backing != nullptr; }
 796     bool hasCompositingDescendant() const { return m_hasCompositingDescendant; }
 797     bool hasCompositedMask() const;
 798 
 799     RenderLayerBacking* backing() const { return m_backing.get(); }
 800     RenderLayerBacking* ensureBacking();
 801     void clearBacking(bool layerBeingDestroyed = false);
 802 
 803     GraphicsLayer* layerForHorizontalScrollbar() const override;
 804     GraphicsLayer* layerForVerticalScrollbar() const override;
 805     GraphicsLayer* layerForScrollCorner() const override;
 806 
 807     bool usesCompositedScrolling() const override;
 808     bool usesAsyncScrolling() const override;
 809 
 810     bool paintsWithTransparency(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
 811     {
 812         return (isTransparent() || hasBlendMode() || (isolatesBlending() &amp;&amp; !renderer().isDocumentElementRenderer())) &amp;&amp; ((paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) || !isComposited());
 813     }
 814 
 815     bool paintsWithTransform(OptionSet&lt;PaintBehavior&gt;) const;
 816     bool shouldPaintMask(OptionSet&lt;PaintBehavior&gt;, OptionSet&lt;PaintLayerFlag&gt;) const;
 817     bool shouldApplyClipPath(OptionSet&lt;PaintBehavior&gt;, OptionSet&lt;PaintLayerFlag&gt;) const;
 818 
 819     // Returns true if background phase is painted opaque in the given rect.
 820     // The query rect is given in local coordinates.
 821     bool backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp;) const;
 822 
 823     bool scrollingMayRevealBackground() const;
 824 
 825     bool containsDirtyOverlayScrollbars() const { return m_containsDirtyOverlayScrollbars; }
 826     void setContainsDirtyOverlayScrollbars(bool dirtyScrollbars) { m_containsDirtyOverlayScrollbars = dirtyScrollbars; }
 827 
 828     bool paintsWithFilters() const;
 829     bool requiresFullLayerImageForFilters() const;
 830 
 831     Element* enclosingElement() const;
 832 
 833     enum ViewportConstrainedNotCompositedReason {
 834         NoNotCompositedReason,
 835         NotCompositedForBoundsOutOfView,
 836         NotCompositedForNonViewContainer,
 837         NotCompositedForNoVisibleContent,
 838     };
 839 
 840     void setViewportConstrainedNotCompositedReason(ViewportConstrainedNotCompositedReason reason) { m_viewportConstrainedNotCompositedReason = reason; }
 841     ViewportConstrainedNotCompositedReason viewportConstrainedNotCompositedReason() const { return static_cast&lt;ViewportConstrainedNotCompositedReason&gt;(m_viewportConstrainedNotCompositedReason); }
 842 
 843     bool isRenderFragmentedFlow() const { return renderer().isRenderFragmentedFlow(); }
 844     bool isOutOfFlowRenderFragmentedFlow() const { return renderer().isOutOfFlowRenderFragmentedFlow(); }
 845     bool isInsideFragmentedFlow() const { return renderer().fragmentedFlowState() != RenderObject::NotInsideFragmentedFlow; }
 846     bool isDirtyRenderFragmentedFlow() const
 847     {
 848         ASSERT(isRenderFragmentedFlow());
 849         return zOrderListsDirty() || normalFlowListDirty();
 850     }
 851 
 852     RenderLayer* enclosingFragmentedFlowAncestor() const;
 853 
 854     bool shouldPlaceBlockDirectionScrollbarOnLeft() const final { return renderer().shouldPlaceBlockDirectionScrollbarOnLeft(); }
 855 
 856     void simulateFrequentPaint() { SinglePaintFrequencyTracking { m_paintFrequencyTracker }; }
 857     bool paintingFrequently() const { return m_paintFrequencyTracker.paintingFrequently(); }
 858 
 859 private:
 860 
 861     void setNextSibling(RenderLayer* next) { m_next = next; }
 862     void setPreviousSibling(RenderLayer* prev) { m_previous = prev; }
 863     void setParent(RenderLayer*);
 864     void setFirstChild(RenderLayer* first) { m_first = first; }
 865     void setLastChild(RenderLayer* last) { m_last = last; }
 866 
 867     void dirtyPaintOrderListsOnChildChange(RenderLayer&amp;);
 868 
 869     bool shouldBeNormalFlowOnly() const;
 870     bool shouldBeStackingContext() const;
 871 
 872     // Return true if changed.
 873     bool setIsNormalFlowOnly(bool);
 874     bool setIsStackingContext(bool);
 875 
 876     bool isDirtyStackingContext() const { return m_zOrderListsDirty &amp;&amp; isStackingContext(); }
 877 
 878     void updateZOrderLists();
 879     void rebuildZOrderLists();
 880     void rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;);
 881     void collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;);
 882     void clearZOrderLists();
 883 
 884     void updateNormalFlowList();
 885 
 886     struct LayerPaintingInfo {
 887         LayerPaintingInfo(RenderLayer* inRootLayer, const LayoutRect&amp; inDirtyRect, OptionSet&lt;PaintBehavior&gt; inPaintBehavior, const LayoutSize&amp; inSubpixelOffset, RenderObject* inSubtreePaintRoot = nullptr, OverlapTestRequestMap* inOverlapTestRequests = nullptr, bool inRequireSecurityOriginAccessForWidgets = false)
 888             : rootLayer(inRootLayer)
 889             , subtreePaintRoot(inSubtreePaintRoot)
 890             , paintDirtyRect(inDirtyRect)
 891             , subpixelOffset(inSubpixelOffset)
 892             , overlapTestRequests(inOverlapTestRequests)
 893             , paintBehavior(inPaintBehavior)
 894             , requireSecurityOriginAccessForWidgets(inRequireSecurityOriginAccessForWidgets)
 895         { }
 896 
 897         RenderLayer* rootLayer;
 898         RenderObject* subtreePaintRoot; // Only paint descendants of this object.
 899         LayoutRect paintDirtyRect; // Relative to rootLayer;
 900         LayoutSize subpixelOffset;
 901         OverlapTestRequestMap* overlapTestRequests; // May be null.
 902         OptionSet&lt;PaintBehavior&gt; paintBehavior;
 903         bool requireSecurityOriginAccessForWidgets;
 904         bool clipToDirtyRect { true };
 905     };
 906 
 907     // Compute, cache and return clip rects computed with the given layer as the root.
 908     Ref&lt;ClipRects&gt; updateClipRects(const ClipRectsContext&amp;);
 909     // Compute and return the clip rects. If useCached is true, will used previously computed clip rects on ancestors
 910     // (rather than computing them all from scratch up the parent chain).
 911     void calculateClipRects(const ClipRectsContext&amp;, ClipRects&amp;) const;
 912     ClipRects* clipRects(const ClipRectsContext&amp;) const;
 913 
 914     void setAncestorChainHasSelfPaintingLayerDescendant();
 915     void dirtyAncestorChainHasSelfPaintingLayerDescendantStatus();
 916 
 917     void computeRepaintRects(const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* = nullptr);
 918     void computeRepaintRectsIncludingDescendants();
 919     void clearRepaintRects();
 920 
 921     LayoutRect clipRectRelativeToAncestor(RenderLayer* ancestor, LayoutSize offsetFromAncestor, const LayoutRect&amp; constrainingRect) const;
 922 
 923     void clipToRect(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const ClipRect&amp;, BorderRadiusClippingRule = IncludeSelfForBorderRadius);
 924     void restoreClip(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const ClipRect&amp;);
 925 
 926     bool shouldRepaintAfterLayout() const;
 927 
 928     void updateSelfPaintingLayer();
 929 
 930     void updateScrollbarsAfterStyleChange(const RenderStyle* oldStyle);
 931     void updateScrollbarsAfterLayout();
 932 
 933     // Returns true if the position changed.
 934     bool updateLayerPosition();
 935 
 936     void updateLayerPositions(RenderGeometryMap* = nullptr, OptionSet&lt;UpdateLayerPositionsFlag&gt; = updateLayerPositionsDefaultFlags());
 937 
 938     enum UpdateLayerPositionsAfterScrollFlag {
 939         IsOverflowScroll                        = 1 &lt;&lt; 0,
 940         HasSeenViewportConstrainedAncestor      = 1 &lt;&lt; 1,
 941         HasSeenAncestorWithOverflowClip         = 1 &lt;&lt; 2,
 942         HasChangedAncestor                      = 1 &lt;&lt; 3,
 943     };
 944     void updateLayerPositionsAfterScroll(RenderGeometryMap*, OptionSet&lt;UpdateLayerPositionsAfterScrollFlag&gt; = { });
 945 
 946     ScrollOffset clampScrollOffset(const ScrollOffset&amp;) const;
 947 
 948     RenderLayer* enclosingPaginationLayerInSubtree(const RenderLayer* rootLayer, PaginationInclusionMode) const;
 949 
 950     LayoutPoint renderBoxLocation() const { return is&lt;RenderBox&gt;(renderer()) ? downcast&lt;RenderBox&gt;(renderer()).location() : LayoutPoint(); }
 951 
 952     bool setupFontSubpixelQuantization(GraphicsContext&amp;, bool&amp; didQuantizeFonts);
 953 
 954     Path computeClipPath(const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, WindRule&amp;) const;
 955 
 956     bool setupClipPath(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed);
 957 
 958     void ensureLayerFilters();
 959     void clearLayerFilters();
 960 
 961     RenderLayerFilters* filtersForPainting(GraphicsContext&amp;, OptionSet&lt;PaintLayerFlag&gt;) const;
 962     GraphicsContext* setupFilters(GraphicsContext&amp; destinationContext, LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed);
 963     void applyFilters(GraphicsContext&amp; originalContext, const LayerPaintingInfo&amp;, const LayerFragments&amp;);
 964 
 965     void paintLayer(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
 966     void paintLayerContentsAndReflection(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
 967     void paintLayerByApplyingTransform(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, const LayoutSize&amp; translationOffset = LayoutSize());
 968     void paintLayerContents(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
 969     void paintList(LayerList, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
 970 
 971     void updatePaintingInfoForFragments(LayerFragments&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, bool shouldPaintContent, const LayoutSize&amp; offsetFromRoot);
 972     void paintBackgroundForFragments(const LayerFragments&amp;, GraphicsContext&amp;, GraphicsContext&amp; transparencyLayerContext,
 973         const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
 974     void paintForegroundForFragments(const LayerFragments&amp;, GraphicsContext&amp;, GraphicsContext&amp; transparencyLayerContext,
 975         const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
 976     void paintForegroundForFragmentsWithPhase(PaintPhase, const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
 977     void paintOutlineForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
 978     void paintOverflowControlsForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;);
 979     void paintMaskForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
 980     void paintChildClippingMaskForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
 981     void paintTransformedLayerIntoFragments(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
 982 
 983     RenderLayer* transparentPaintingAncestor();
 984     void beginTransparencyLayers(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const LayoutRect&amp; dirtyRect);
 985 
 986     RenderLayer* hitTestLayer(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
 987         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, bool appliedTransform,
 988         const HitTestingTransformState* = nullptr, double* zOffset = nullptr);
 989     RenderLayer* hitTestLayerByApplyingTransform(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
 990         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, const HitTestingTransformState* = nullptr, double* zOffset = nullptr,
 991         const LayoutSize&amp; translationOffset = LayoutSize());
 992     RenderLayer* hitTestList(LayerList, RenderLayer* rootLayer, const HitTestRequest&amp;, HitTestResult&amp;,
 993         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;,
 994         const HitTestingTransformState*, double* zOffsetForDescendants, double* zOffset,
 995         const HitTestingTransformState* unflattenedTransformState, bool depthSortDescendants);
 996 
 997     Ref&lt;HitTestingTransformState&gt; createLocalTransformState(RenderLayer* rootLayer, RenderLayer* containerLayer,
 998         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;,
 999         const HitTestingTransformState* containerTransformState,
1000         const LayoutSize&amp; translationOffset = LayoutSize()) const;
1001 
1002     bool hitTestContents(const HitTestRequest&amp;, HitTestResult&amp;, const LayoutRect&amp; layerBounds, const HitTestLocation&amp;, HitTestFilter) const;
1003     bool hitTestContentsForFragments(const LayerFragments&amp;, const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp;, HitTestFilter, bool&amp; insideClipRect) const;
1004     bool hitTestResizerInFragments(const LayerFragments&amp;, const HitTestLocation&amp;) const;
1005     RenderLayer* hitTestTransformedLayerInFragments(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1006         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, const HitTestingTransformState* = nullptr, double* zOffset = nullptr);
1007 
1008     bool listBackgroundIsKnownToBeOpaqueInRect(const LayerList&amp;, const LayoutRect&amp;) const;
1009 
1010     void computeScrollDimensions();
1011     bool hasHorizontalOverflow() const;
1012     bool hasVerticalOverflow() const;
1013     bool hasScrollableHorizontalOverflow() const;
1014     bool hasScrollableVerticalOverflow() const;
1015 
1016     bool showsOverflowControls() const;
1017 
1018     bool shouldBeSelfPaintingLayer() const;
1019 
1020     int scrollOffset(ScrollbarOrientation) const override;
1021 
1022     // ScrollableArea interface
1023     void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) override;
1024     void invalidateScrollCornerRect(const IntRect&amp;) override;
1025     bool isActive() const override;
1026     bool isScrollCornerVisible() const override;
1027     IntRect scrollCornerRect() const override;
1028     IntRect convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntRect&amp;) const override;
1029     IntRect convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntRect&amp;) const override;
1030     IntPoint convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntPoint&amp;) const override;
1031     IntPoint convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntPoint&amp;) const override;
1032     int scrollSize(ScrollbarOrientation) const override;
1033     void setScrollOffset(const ScrollOffset&amp;) override;
1034 
1035     IntRect visibleContentRectInternal(VisibleContentRectIncludesScrollbars, VisibleContentRectBehavior) const override;
1036     IntSize overhangAmount() const override;
1037     IntPoint lastKnownMousePosition() const override;
1038     bool isHandlingWheelEvent() const override;
1039     bool shouldSuspendScrollAnimations() const override;
1040     IntRect scrollableAreaBoundingBox(bool* isInsideFixed = nullptr) const override;
1041     bool isRubberBandInProgress() const override;
1042     bool forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const override;
1043 #if ENABLE(CSS_SCROLL_SNAP)
1044     bool isScrollSnapInProgress() const override;
1045 #endif
1046     bool usesMockScrollAnimator() const override;
1047     void logMockScrollAnimatorMessage(const String&amp;) const override;
1048 
1049 #if ENABLE(IOS_TOUCH_EVENTS)
1050     void registerAsTouchEventListenerForScrolling();
1051     void unregisterAsTouchEventListenerForScrolling();
1052 #endif
1053 
1054     // Rectangle encompassing the scroll corner and resizer rect.
1055     LayoutRect scrollCornerAndResizerRect() const;
1056 
1057     // NOTE: This should only be called by the overridden setScrollOffset from ScrollableArea.
1058     void scrollTo(const ScrollPosition&amp;);
1059     void updateCompositingLayersAfterScroll();
1060 
1061     IntSize scrollbarOffset(const Scrollbar&amp;) const;
1062 
1063     void updateScrollableAreaSet(bool hasOverflow);
1064 
1065     bool allowsCurrentScroll() const;
1066 
1067     void dirtyAncestorChainVisibleDescendantStatus();
1068     void setAncestorChainHasVisibleDescendant();
1069 
1070     bool has3DTransformedDescendant() const { return m_has3DTransformedDescendant; }
1071 
1072     bool hasTransformedAncestor() const { return m_hasTransformedAncestor; }
1073     bool has3DTransformedAncestor() const { return m_has3DTransformedAncestor; }
1074 
1075     void dirty3DTransformedDescendantStatus();
1076     // Both updates the status, and returns true if descendants of this have 3d.
1077     bool update3DTransformedDescendantStatus();
1078 
1079     void createReflection();
1080     void removeReflection();
1081 
1082     RenderStyle createReflectionStyle();
1083     bool paintingInsideReflection() const { return m_paintingInsideReflection; }
1084     void setPaintingInsideReflection(bool b) { m_paintingInsideReflection = b; }
1085 
1086     void updateFiltersAfterStyleChange();
1087     void updateFilterPaintingStrategy();
1088 
1089 #if ENABLE(CSS_COMPOSITING)
1090     void updateAncestorChainHasBlendingDescendants();
1091     void dirtyAncestorChainHasBlendingDescendants();
1092 #endif
1093 
1094     Ref&lt;ClipRects&gt; parentClipRects(const ClipRectsContext&amp;) const;
1095     ClipRect backgroundClipRect(const ClipRectsContext&amp;) const;
1096 
1097     RenderLayer* enclosingTransformedAncestor() const;
1098 
1099     LayoutRect getRectToExpose(const LayoutRect&amp; visibleRect, const LayoutRect&amp; exposeRect, bool insideFixed, const ScrollAlignment&amp; alignX, const ScrollAlignment&amp; alignY) const;
1100 
1101     // Convert a point in absolute coords into layer coords, taking transforms into account
1102     LayoutPoint absoluteToContents(const LayoutPoint&amp;) const;
1103 
1104     void positionOverflowControls(const IntSize&amp;);
1105     void updateScrollCornerStyle();
1106     void clearScrollCorner();
1107     void updateResizerStyle();
1108     void clearResizer();
1109 
1110     void drawPlatformResizerImage(GraphicsContext&amp;, const LayoutRect&amp; resizerCornerRect);
1111 
1112     void updatePagination();
1113 
1114     void setHasCompositingDescendant(bool b)  { m_hasCompositingDescendant = b; }
1115 
1116     enum class IndirectCompositingReason {
1117         None,
1118         Stacking,
1119         Overlap,
1120         BackgroundLayer,
1121         GraphicalEffect, // opacity, mask, filter, transform etc.
1122         Perspective,
1123         Preserve3D
1124     };
1125 
1126     void setIndirectCompositingReason(IndirectCompositingReason reason) { m_indirectCompositingReason = static_cast&lt;unsigned&gt;(reason); }
1127     IndirectCompositingReason indirectCompositingReason() const { return static_cast&lt;IndirectCompositingReason&gt;(m_indirectCompositingReason); }
1128     bool mustCompositeForIndirectReasons() const { return m_indirectCompositingReason; }
1129 
1130     friend class RenderLayerBacking;
1131     friend class RenderLayerCompositor;
1132     friend class RenderLayerModelObject;
1133 
1134     LayoutUnit overflowTop() const;
1135     LayoutUnit overflowBottom() const;
1136     LayoutUnit overflowLeft() const;
1137     LayoutUnit overflowRight() const;
1138 
1139     IntRect rectForHorizontalScrollbar(const IntRect&amp; borderBoxRect) const;
1140     IntRect rectForVerticalScrollbar(const IntRect&amp; borderBoxRect) const;
1141 
1142     LayoutUnit verticalScrollbarStart(int minX, int maxX) const;
1143     LayoutUnit horizontalScrollbarStart(int minX) const;
1144 
1145     bool overflowControlsIntersectRect(const IntRect&amp; localRect) const;
1146 
1147     OptionSet&lt;Compositing&gt; m_compositingDirtyBits;
1148 
1149     const bool m_isRenderViewLayer : 1;
1150     const bool m_forcedStackingContext : 1;
1151 
1152     bool m_isNormalFlowOnly : 1;
1153     bool m_isStackingContext : 1;
1154 
1155     bool m_zOrderListsDirty : 1;
1156     bool m_normalFlowListDirty: 1;
1157     bool m_hadNegativeZOrderList : 1;
1158 
1159     // Keeps track of whether the layer is currently resizing, so events can cause resizing to start and stop.
1160     bool m_inResizeMode : 1;
1161 
1162     bool m_scrollDimensionsDirty : 1;
1163     bool m_isSelfPaintingLayer : 1;
1164 
1165     // If have no self-painting descendants, we don&#39;t have to walk our children during painting. This can lead to
1166     // significant savings, especially if the tree has lots of non-self-painting layers grouped together (e.g. table cells).
1167     bool m_hasSelfPaintingLayerDescendant : 1;
1168     bool m_hasSelfPaintingLayerDescendantDirty : 1;
1169 
1170     bool m_usedTransparency : 1; // Tracks whether we need to close a transparent layer, i.e., whether
1171                                  // we ended up painting this layer or any descendants (and therefore need to
1172                                  // blend).
1173     bool m_paintingInsideReflection : 1;  // A state bit tracking if we are painting inside a replica.
1174     bool m_inOverflowRelayout : 1;
1175     unsigned m_repaintStatus : 2; // RepaintStatus
1176 
1177     bool m_visibleContentStatusDirty : 1;
1178     bool m_hasVisibleContent : 1;
1179     bool m_visibleDescendantStatusDirty : 1;
1180     bool m_hasVisibleDescendant : 1;
1181     bool m_registeredScrollableArea : 1;
1182     bool m_isFixedIntersectingViewport : 1;
1183 
1184     bool m_3DTransformedDescendantStatusDirty : 1;
1185     bool m_has3DTransformedDescendant : 1;  // Set on a stacking context layer that has 3D descendants anywhere
1186                                             // in a preserves3D hierarchy. Hint to do 3D-aware hit testing.
1187     bool m_hasCompositingDescendant : 1; // In the z-order tree.
1188 
1189     bool m_hasTransformedAncestor : 1;
1190     bool m_has3DTransformedAncestor : 1;
1191 
1192     unsigned m_indirectCompositingReason : 3;
1193     unsigned m_viewportConstrainedNotCompositedReason : 2;
1194 
1195 #if PLATFORM(IOS_FAMILY)
1196 #if ENABLE(IOS_TOUCH_EVENTS)
1197     bool m_registeredAsTouchEventListenerForScrolling : 1;
1198 #endif
1199     bool m_adjustForIOSCaretWhenScrolling : 1;
1200 #endif
1201 
1202     bool m_inUserScroll : 1;
1203     bool m_requiresScrollPositionReconciliation : 1;
1204     bool m_containsDirtyOverlayScrollbars : 1;
1205     bool m_updatingMarqueePosition : 1;
1206 
1207 #if !ASSERT_DISABLED
1208     bool m_layerListMutationAllowed : 1;
1209 #endif
1210 
1211 #if ENABLE(CSS_COMPOSITING)
1212     unsigned m_blendMode : 5;
1213     bool m_hasNotIsolatedCompositedBlendingDescendants : 1;
1214     bool m_hasNotIsolatedBlendingDescendants : 1;
1215     bool m_hasNotIsolatedBlendingDescendantsStatusDirty : 1;
1216 #endif
1217 
1218     RenderLayerModelObject&amp; m_renderer;
1219 
1220     RenderLayer* m_parent { nullptr };
1221     RenderLayer* m_previous { nullptr };
1222     RenderLayer* m_next { nullptr };
1223     RenderLayer* m_first { nullptr };
1224     RenderLayer* m_last { nullptr };
1225 
1226     // For layers that establish stacking contexts, m_posZOrderList holds a sorted list of all the
1227     // descendant layers within the stacking context that have z-indices of 0 or greater
1228     // (auto will count as 0). m_negZOrderList holds descendants within our stacking context with negative
1229     // z-indices.
1230     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_posZOrderList;
1231     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_negZOrderList;
1232 
1233     // This list contains child layers that cannot create stacking contexts and appear in normal flow order.
1234     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_normalFlowList;
1235 
1236     // Our current relative position offset.
1237     LayoutSize m_offsetForInFlowPosition;
1238 
1239     // Our (x,y) coordinates are in our parent layer&#39;s coordinate space.
1240     LayoutPoint m_topLeft;
1241 
1242     // The layer&#39;s width/height
1243     IntSize m_layerSize;
1244 
1245     ScrollPosition m_scrollPosition;
1246     Optional&lt;ScrollPosition&gt; m_postLayoutScrollPosition;
1247 
1248     // The width/height of our scrolled area.
1249     IntSize m_scrollSize;
1250 
1251     // For layers with overflow, we have a pair of scrollbars.
1252     RefPtr&lt;Scrollbar&gt; m_hBar;
1253     RefPtr&lt;Scrollbar&gt; m_vBar;
1254 
1255     std::unique_ptr&lt;ClipRectsCache&gt; m_clipRectsCache;
1256 
1257     IntPoint m_cachedOverlayScrollbarOffset;
1258 
1259     std::unique_ptr&lt;RenderMarquee&gt; m_marquee; // Used for &lt;marquee&gt;.
1260 
1261     // Cached normal flow values for absolute positioned elements with static left/top values.
1262     LayoutUnit m_staticInlinePosition;
1263     LayoutUnit m_staticBlockPosition;
1264 
1265     std::unique_ptr&lt;TransformationMatrix&gt; m_transform;
1266 
1267     // May ultimately be extended to many replicas (with their own paint order).
1268     RenderPtr&lt;RenderReplica&gt; m_reflection;
1269 
1270     // Renderers to hold our custom scroll corner and resizer.
1271     RenderPtr&lt;RenderScrollbarPart&gt; m_scrollCorner;
1272     RenderPtr&lt;RenderScrollbarPart&gt; m_resizer;
1273 
1274     // Pointer to the enclosing RenderLayer that caused us to be paginated. It is 0 if we are not paginated.
1275     WeakPtr&lt;RenderLayer&gt; m_enclosingPaginationLayer;
1276 
1277     IntRect m_blockSelectionGapsBounds;
1278 
1279     std::unique_ptr&lt;RenderLayerFilters&gt; m_filters;
1280     std::unique_ptr&lt;RenderLayerBacking&gt; m_backing;
1281 
1282     PaintFrequencyTracker m_paintFrequencyTracker;
1283 };
1284 
1285 inline void RenderLayer::clearZOrderLists()
1286 {
1287     ASSERT(!isStackingContext());
1288     ASSERT(layerListMutationAllowed());
1289 
1290     m_posZOrderList = nullptr;
1291     m_negZOrderList = nullptr;
1292 }
1293 
1294 inline void RenderLayer::updateZOrderLists()
1295 {
1296     if (!m_zOrderListsDirty)
1297         return;
1298 
1299     if (!isStackingContext()) {
1300         clearZOrderLists();
1301         m_zOrderListsDirty = false;
1302         return;
1303     }
1304 
1305     rebuildZOrderLists();
1306 }
1307 
1308 inline RenderLayer* RenderLayer::paintOrderParent() const
1309 {
1310     return m_isNormalFlowOnly ? m_parent : stackingContext();
1311 }
1312 
1313 #if !ASSERT_DISABLED
1314 class LayerListMutationDetector {
1315 public:
1316     LayerListMutationDetector(RenderLayer&amp; layer)
1317         : m_layer(layer)
1318         , m_previousMutationAllowedState(layer.layerListMutationAllowed())
1319     {
1320         m_layer.setLayerListMutationAllowed(false);
1321     }
1322 
1323     ~LayerListMutationDetector()
1324     {
1325         m_layer.setLayerListMutationAllowed(m_previousMutationAllowedState);
1326     }
1327 
1328 private:
1329     RenderLayer&amp; m_layer;
1330     bool m_previousMutationAllowedState;
1331 };
1332 #endif
1333 
1334 void makeMatrixRenderable(TransformationMatrix&amp;, bool has3DRendering);
1335 
1336 bool compositedWithOwnBackingStore(const RenderLayer&amp;);
1337 
1338 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer&amp;);
1339 
1340 } // namespace WebCore
1341 
1342 #if ENABLE(TREE_DEBUGGING)
1343 // Outside the WebCore namespace for ease of invocation from lldb.
1344 void showLayerTree(const WebCore::RenderLayer*);
1345 void showPaintOrderTree(const WebCore::RenderLayer*);
1346 void showLayerTree(const WebCore::RenderObject*);
1347 #endif
    </pre>
  </body>
</html>