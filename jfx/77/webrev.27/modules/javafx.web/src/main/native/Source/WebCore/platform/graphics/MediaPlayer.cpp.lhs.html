<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2007-2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;MediaPlayer.h&quot;
  28 
  29 #if ENABLE(VIDEO)
  30 
  31 #include &quot;ContentType.h&quot;
  32 #include &quot;DeprecatedGlobalSettings.h&quot;
  33 #include &quot;Document.h&quot;
  34 #include &quot;IntRect.h&quot;
  35 #include &quot;Logging.h&quot;
  36 #include &quot;MIMETypeRegistry.h&quot;
  37 #include &quot;MediaPlayerPrivate.h&quot;
  38 #include &quot;PlatformTimeRanges.h&quot;
  39 #include &lt;wtf/NeverDestroyed.h&gt;
  40 #include &lt;wtf/text/CString.h&gt;
  41 
  42 #if ENABLE(VIDEO_TRACK)
  43 #include &quot;InbandTextTrackPrivate.h&quot;
  44 #endif
  45 
  46 #if ENABLE(MEDIA_SOURCE)
  47 #include &quot;MediaSourcePrivateClient.h&quot;
  48 #endif
  49 
  50 #if ENABLE(MEDIA_STREAM)
  51 #include &quot;MediaStreamPrivate.h&quot;
  52 #endif
  53 
  54 #if USE(GSTREAMER)
  55 #include &quot;MediaPlayerPrivateGStreamer.h&quot;
  56 #define PlatformMediaEngineClassName MediaPlayerPrivateGStreamer
  57 #if ENABLE(MEDIA_SOURCE) &amp;&amp; ENABLE(VIDEO_TRACK)
  58 #include &quot;MediaPlayerPrivateGStreamerMSE.h&quot;
  59 #endif
  60 #endif // USE(GSTREAMER)
  61 
  62 #if USE(MEDIA_FOUNDATION)
  63 #include &quot;MediaPlayerPrivateMediaFoundation.h&quot;
  64 #define PlatformMediaEngineClassName MediaPlayerPrivateMediaFoundation
  65 #endif
  66 
  67 #if PLATFORM(COCOA)
  68 
  69 #if USE(AVFOUNDATION)
  70 #include &quot;MediaPlayerPrivateAVFoundationObjC.h&quot;
  71 #endif
  72 
  73 #if ENABLE(MEDIA_SOURCE) &amp;&amp; USE(AVFOUNDATION)
  74 #include &quot;MediaPlayerPrivateMediaSourceAVFObjC.h&quot;
  75 #endif
  76 
  77 #if ENABLE(MEDIA_STREAM) &amp;&amp; USE(AVFOUNDATION)
  78 #include &quot;MediaPlayerPrivateMediaStreamAVFObjC.h&quot;
  79 #endif
  80 
  81 #endif // PLATFORM(COCOA)
  82 
  83 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION) &amp;&amp; !USE(GSTREAMER)
  84 #include &quot;MediaPlayerPrivateAVFoundationCF.h&quot;
  85 #endif // USE(AVFOUNDATION)
  86 
  87 #if PLATFORM(JAVA)
  88 #include &quot;MediaPlayerPrivateJava.h&quot;
  89 #define PlatformMediaEngineClassName MediaPlayerPrivate
  90 #endif  // PLATFORM(JAVA)
  91 
  92 #if USE(EXTERNAL_HOLEPUNCH)
  93 #include &quot;MediaPlayerPrivateHolePunch.h&quot;
  94 #endif
  95 
  96 namespace WebCore {
  97 
  98 #if !RELEASE_LOG_DISABLED
  99 static RefPtr&lt;Logger&gt;&amp; nullLogger()
 100 {
 101     static NeverDestroyed&lt;RefPtr&lt;Logger&gt;&gt; logger;
 102     return logger;
 103 }
 104 #endif
 105 
 106 // a null player to make MediaPlayer logic simpler
 107 
<a name="1" id="anc1"></a><span class="line-modified"> 108 class NullMediaPlayerPrivate : public MediaPlayerPrivateInterface {</span>
 109 public:
 110     explicit NullMediaPlayerPrivate(MediaPlayer*) { }
 111 
<a name="2" id="anc2"></a><span class="line-modified"> 112     void load(const String&amp;) override { }</span>
 113 #if ENABLE(MEDIA_SOURCE)
<a name="3" id="anc3"></a><span class="line-modified"> 114     void load(const String&amp;, MediaSourcePrivateClient*) override { }</span>
 115 #endif
 116 #if ENABLE(MEDIA_STREAM)
<a name="4" id="anc4"></a><span class="line-modified"> 117     void load(MediaStreamPrivate&amp;) override { }</span>
 118 #endif
<a name="5" id="anc5"></a><span class="line-modified"> 119     void cancelLoad() override { }</span>
 120 
<a name="6" id="anc6"></a><span class="line-modified"> 121     void prepareToPlay() override { }</span>
<span class="line-modified"> 122     void play() override { }</span>
<span class="line-modified"> 123     void pause() override { }</span>
 124 
<a name="7" id="anc7"></a><span class="line-modified"> 125     PlatformLayer* platformLayer() const override { return 0; }</span>
 126 
<a name="8" id="anc8"></a><span class="line-modified"> 127     FloatSize naturalSize() const override { return FloatSize(); }</span>
 128 
<a name="9" id="anc9"></a><span class="line-modified"> 129     bool hasVideo() const override { return false; }</span>
<span class="line-modified"> 130     bool hasAudio() const override { return false; }</span>
 131 
<a name="10" id="anc10"></a><span class="line-modified"> 132     void setVisible(bool) override { }</span>
 133 
<a name="11" id="anc11"></a><span class="line-modified"> 134     double durationDouble() const override { return 0; }</span>
 135 
<a name="12" id="anc12"></a><span class="line-modified"> 136     double currentTimeDouble() const override { return 0; }</span>
<span class="line-modified"> 137     void seekDouble(double) override { }</span>
<span class="line-modified"> 138     bool seeking() const override { return false; }</span>
 139 
<a name="13" id="anc13"></a><span class="line-modified"> 140     void setRateDouble(double) override { }</span>
<span class="line-modified"> 141     void setPreservesPitch(bool) override { }</span>
<span class="line-modified"> 142     bool paused() const override { return true; }</span>
 143 
<a name="14" id="anc14"></a><span class="line-modified"> 144     void setVolumeDouble(double) override { }</span>
 145 
<a name="15" id="anc15"></a><span class="line-modified"> 146     bool supportsMuting() const override { return false; }</span>
<span class="line-removed"> 147     void setMuted(bool) override { }</span>
 148 
<a name="16" id="anc16"></a><span class="line-modified"> 149     bool hasClosedCaptions() const override { return false; }</span>
<span class="line-modified"> 150     void setClosedCaptionsVisible(bool) override { };</span>
 151 
<a name="17" id="anc17"></a><span class="line-modified"> 152     MediaPlayer::NetworkState networkState() const override { return MediaPlayer::Empty; }</span>
<span class="line-modified"> 153     MediaPlayer::ReadyState readyState() const override { return MediaPlayer::HaveNothing; }</span>
 154 
<a name="18" id="anc18"></a><span class="line-modified"> 155     float maxTimeSeekable() const override { return 0; }</span>
<span class="line-modified"> 156     double minTimeSeekable() const override { return 0; }</span>
<span class="line-modified"> 157     std::unique_ptr&lt;PlatformTimeRanges&gt; buffered() const override { return std::make_unique&lt;PlatformTimeRanges&gt;(); }</span>
 158 
<a name="19" id="anc19"></a><span class="line-modified"> 159     double seekableTimeRangesLastModifiedTime() const override { return 0; }</span>
<span class="line-modified"> 160     double liveUpdateInterval() const override { return 0; }</span>
 161 
<a name="20" id="anc20"></a><span class="line-modified"> 162     unsigned long long totalBytes() const override { return 0; }</span>
<span class="line-modified"> 163     bool didLoadingProgress() const override { return false; }</span>
 164 
<a name="21" id="anc21"></a><span class="line-modified"> 165     void setSize(const IntSize&amp;) override { }</span>
 166 
<a name="22" id="anc22"></a><span class="line-modified"> 167     void paint(GraphicsContext&amp;, const FloatRect&amp;) override { }</span>
 168 
<a name="23" id="anc23"></a><span class="line-modified"> 169     bool canLoadPoster() const override { return false; }</span>
<span class="line-modified"> 170     void setPoster(const String&amp;) override { }</span>
 171 
<a name="24" id="anc24"></a><span class="line-modified"> 172     bool hasSingleSecurityOrigin() const override { return true; }</span>
 173 };
 174 
 175 class NullMediaPlayerClient : public MediaPlayerClient {
 176 public:
 177 #if !RELEASE_LOG_DISABLED
 178     const Logger&amp; mediaPlayerLogger() final
 179     {
 180         if (!nullLogger().get()) {
 181             nullLogger() = Logger::create(this);
 182             nullLogger()-&gt;setEnabled(this, false);
 183         }
 184 
 185         return *nullLogger().get();
 186     }
 187 #endif
 188 };
 189 
 190 const Vector&lt;ContentType&gt;&amp; MediaPlayerClient::mediaContentTypesRequiringHardwareSupport() const
 191 {
 192     static NeverDestroyed&lt;Vector&lt;ContentType&gt;&gt; contentTypes;
 193     return contentTypes;
 194 }
 195 
 196 static MediaPlayerClient&amp; nullMediaPlayerClient()
 197 {
 198     static NeverDestroyed&lt;NullMediaPlayerClient&gt; client;
 199     return client.get();
 200 }
 201 
 202 // engine support
 203 
 204 struct MediaPlayerFactory {
 205     CreateMediaEnginePlayer constructor;
 206     MediaEngineSupportedTypes getSupportedTypes;
 207     MediaEngineSupportsType supportsTypeAndCodecs;
 208     MediaEngineOriginsInMediaCache originsInMediaCache;
 209     MediaEngineClearMediaCache clearMediaCache;
 210     MediaEngineClearMediaCacheForOrigins clearMediaCacheForOrigins;
 211     MediaEngineSupportsKeySystem supportsKeySystem;
 212 };
 213 
 214 static void addMediaEngine(CreateMediaEnginePlayer&amp;&amp;, MediaEngineSupportedTypes, MediaEngineSupportsType, MediaEngineOriginsInMediaCache, MediaEngineClearMediaCache, MediaEngineClearMediaCacheForOrigins, MediaEngineSupportsKeySystem);
 215 
 216 static Lock mediaEngineVectorLock;
 217 
 218 static bool&amp; haveMediaEnginesVector()
 219 {
 220     static bool haveVector;
 221     return haveVector;
 222 }
 223 
 224 static Vector&lt;MediaPlayerFactory&gt;&amp; mutableInstalledMediaEnginesVector()
 225 {
 226     static NeverDestroyed&lt;Vector&lt;MediaPlayerFactory&gt;&gt; installedEngines;
 227     return installedEngines;
 228 }
 229 
 230 static void buildMediaEnginesVector()
 231 {
 232     ASSERT(mediaEngineVectorLock.isLocked());
 233 
 234 #if USE(AVFOUNDATION)
 235     if (DeprecatedGlobalSettings::isAVFoundationEnabled()) {
 236 
 237 #if PLATFORM(COCOA)
 238         MediaPlayerPrivateAVFoundationObjC::registerMediaEngine(addMediaEngine);
 239 #endif
 240 
 241 #if ENABLE(MEDIA_SOURCE)
 242         MediaPlayerPrivateMediaSourceAVFObjC::registerMediaEngine(addMediaEngine);
 243 #endif
 244 
 245 #if ENABLE(MEDIA_STREAM)
 246         MediaPlayerPrivateMediaStreamAVFObjC::registerMediaEngine(addMediaEngine);
 247 #endif
 248 
 249 #if PLATFORM(WIN)
 250         MediaPlayerPrivateAVFoundationCF::registerMediaEngine(addMediaEngine);
 251 #endif
 252     }
 253 #endif // USE(AVFOUNDATION)
 254 
 255 #if defined(PlatformMediaEngineClassName)
 256 #if USE(GSTREAMER)
 257     if (DeprecatedGlobalSettings::isGStreamerEnabled())
 258 #endif
 259         PlatformMediaEngineClassName::registerMediaEngine(addMediaEngine);
 260 #endif
 261 
 262 #if USE(GSTREAMER) &amp;&amp; ENABLE(MEDIA_SOURCE) &amp;&amp; ENABLE(VIDEO_TRACK)
 263     if (DeprecatedGlobalSettings::isGStreamerEnabled())
 264         MediaPlayerPrivateGStreamerMSE::registerMediaEngine(addMediaEngine);
 265 #endif
 266 
 267 #if USE(EXTERNAL_HOLEPUNCH)
 268     MediaPlayerPrivateHolePunch::registerMediaEngine(addMediaEngine);
 269 #endif
 270 
 271     haveMediaEnginesVector() = true;
 272 }
 273 
 274 static const Vector&lt;MediaPlayerFactory&gt;&amp; installedMediaEngines()
 275 {
 276     {
 277         auto locker = holdLock(mediaEngineVectorLock);
 278         if (!haveMediaEnginesVector())
 279             buildMediaEnginesVector();
 280     }
 281 
 282     return mutableInstalledMediaEnginesVector();
 283 }
 284 
 285 static void addMediaEngine(CreateMediaEnginePlayer&amp;&amp; constructor, MediaEngineSupportedTypes getSupportedTypes, MediaEngineSupportsType supportsType,
 286     MediaEngineOriginsInMediaCache originsInMediaCache, MediaEngineClearMediaCache clearMediaCache, MediaEngineClearMediaCacheForOrigins clearMediaCacheForOrigins, MediaEngineSupportsKeySystem supportsKeySystem)
 287 {
 288     ASSERT(constructor);
 289     ASSERT(getSupportedTypes);
 290     ASSERT(supportsType);
 291 
 292     mutableInstalledMediaEnginesVector().append(MediaPlayerFactory { WTFMove(constructor), getSupportedTypes, supportsType, originsInMediaCache, clearMediaCache, clearMediaCacheForOrigins, supportsKeySystem });
 293 }
 294 
<a name="25" id="anc25"></a><span class="line-modified"> 295 static const AtomicString&amp; applicationOctetStream()</span>
 296 {
<a name="26" id="anc26"></a><span class="line-modified"> 297     static NeverDestroyed&lt;const AtomicString&gt; applicationOctetStream(&quot;application/octet-stream&quot;, AtomicString::ConstructFromLiteral);</span>
 298     return applicationOctetStream;
 299 }
 300 
<a name="27" id="anc27"></a><span class="line-modified"> 301 static const AtomicString&amp; textPlain()</span>
 302 {
<a name="28" id="anc28"></a><span class="line-modified"> 303     static NeverDestroyed&lt;const AtomicString&gt; textPlain(&quot;text/plain&quot;, AtomicString::ConstructFromLiteral);</span>
 304     return textPlain;
 305 }
 306 
 307 static const MediaPlayerFactory* bestMediaEngineForSupportParameters(const MediaEngineSupportParameters&amp; parameters, const MediaPlayerFactory* current = nullptr)
 308 {
 309     if (parameters.type.isEmpty() &amp;&amp; !parameters.isMediaSource &amp;&amp; !parameters.isMediaStream)
 310         return nullptr;
 311 
 312     // 4.8.10.3 MIME types - In the absence of a specification to the contrary, the MIME type &quot;application/octet-stream&quot;
 313     // when used with parameters, e.g. &quot;application/octet-stream;codecs=theora&quot;, is a type that the user agent knows
 314     // it cannot render.
 315     if (parameters.type.containerType() == applicationOctetStream()) {
 316         if (!parameters.type.codecs().isEmpty())
 317             return nullptr;
 318     }
 319 
 320     const MediaPlayerFactory* foundEngine = nullptr;
 321     MediaPlayer::SupportsType supported = MediaPlayer::IsNotSupported;
 322     for (auto&amp; engine : installedMediaEngines()) {
 323         if (current) {
 324             if (current == &amp;engine)
 325                 current = nullptr;
 326             continue;
 327         }
 328         MediaPlayer::SupportsType engineSupport = engine.supportsTypeAndCodecs(parameters);
 329         if (engineSupport &gt; supported) {
 330             supported = engineSupport;
 331             foundEngine = &amp;engine;
 332         }
 333     }
 334 
 335     return foundEngine;
 336 }
 337 
 338 static const MediaPlayerFactory* nextMediaEngine(const MediaPlayerFactory* current)
 339 {
 340     auto&amp; engines = installedMediaEngines();
 341     if (engines.isEmpty())
 342         return nullptr;
 343 
 344     if (!current)
 345         return &amp;engines.first();
 346 
 347     size_t currentIndex = current - &amp;engines.first();
 348     if (currentIndex + 1 &gt;= engines.size())
 349         return nullptr;
 350 
 351     return &amp;engines[currentIndex + 1];
 352 }
 353 
 354 // media player
 355 
 356 Ref&lt;MediaPlayer&gt; MediaPlayer::create(MediaPlayerClient&amp; client)
 357 {
 358     return adoptRef(*new MediaPlayer(client));
 359 }
 360 
 361 MediaPlayer::MediaPlayer(MediaPlayerClient&amp; client)
 362     : m_client(&amp;client)
 363     , m_reloadTimer(*this, &amp;MediaPlayer::reloadTimerFired)
<a name="29" id="anc29"></a><span class="line-modified"> 364     , m_private(std::make_unique&lt;NullMediaPlayerPrivate&gt;(this))</span>
 365 {
 366 }
 367 
 368 MediaPlayer::~MediaPlayer()
 369 {
 370     ASSERT(!m_initializingMediaEngine);
 371 }
 372 
 373 void MediaPlayer::invalidate()
 374 {
 375     m_client = &amp;nullMediaPlayerClient();
 376 }
 377 
 378 bool MediaPlayer::load(const URL&amp; url, const ContentType&amp; contentType, const String&amp; keySystem)
 379 {
 380     ASSERT(!m_reloadTimer.isActive());
 381 
 382     // Protect against MediaPlayer being destroyed during a MediaPlayerClient callback.
 383     Ref&lt;MediaPlayer&gt; protectedThis(*this);
 384 
 385     m_contentType = contentType;
 386     m_url = url;
 387     m_keySystem = keySystem.convertToASCIILowercase();
 388     m_contentMIMETypeWasInferredFromExtension = false;
 389 
 390 #if ENABLE(MEDIA_SOURCE)
 391     m_mediaSource = nullptr;
 392 #endif
 393 #if ENABLE(MEDIA_STREAM)
 394     m_mediaStream = nullptr;
 395 #endif
 396 
 397     // If the MIME type is missing or is not meaningful, try to figure it out from the URL.
<a name="30" id="anc30"></a><span class="line-modified"> 398     AtomicString containerType = m_contentType.containerType();</span>
 399     if (containerType.isEmpty() || containerType == applicationOctetStream() || containerType == textPlain()) {
 400         if (m_url.protocolIsData())
 401             m_contentType = ContentType(mimeTypeFromDataURL(m_url.string()));
 402         else {
 403             String lastPathComponent = url.lastPathComponent();
 404             size_t pos = lastPathComponent.reverseFind(&#39;.&#39;);
 405             if (pos != notFound) {
 406                 String extension = lastPathComponent.substring(pos + 1);
 407                 String mediaType = MIMETypeRegistry::getMediaMIMETypeForExtension(extension);
 408                 if (!mediaType.isEmpty()) {
 409                     m_contentType = ContentType { WTFMove(mediaType) };
 410                     m_contentMIMETypeWasInferredFromExtension = true;
 411                 }
 412             }
 413         }
 414     }
 415 
 416     loadWithNextMediaEngine(nullptr);
 417     return m_currentMediaEngine;
 418 }
 419 
 420 #if ENABLE(MEDIA_SOURCE)
 421 bool MediaPlayer::load(const URL&amp; url, const ContentType&amp; contentType, MediaSourcePrivateClient* mediaSource)
 422 {
 423     ASSERT(!m_reloadTimer.isActive());
 424     ASSERT(mediaSource);
 425 
 426     m_mediaSource = mediaSource;
 427     m_contentType = contentType;
 428     m_url = url;
 429     m_keySystem = emptyString();
 430     m_contentMIMETypeWasInferredFromExtension = false;
 431     loadWithNextMediaEngine(nullptr);
 432     return m_currentMediaEngine;
 433 }
 434 #endif
 435 
 436 #if ENABLE(MEDIA_STREAM)
 437 bool MediaPlayer::load(MediaStreamPrivate&amp; mediaStream)
 438 {
 439     ASSERT(!m_reloadTimer.isActive());
 440 
 441     m_mediaStream = &amp;mediaStream;
 442     m_keySystem = emptyString();
 443     m_contentType = { };
 444     m_contentMIMETypeWasInferredFromExtension = false;
 445     loadWithNextMediaEngine(nullptr);
 446     return m_currentMediaEngine;
 447 }
 448 #endif
 449 
 450 const MediaPlayerFactory* MediaPlayer::nextBestMediaEngine(const MediaPlayerFactory* current) const
 451 {
 452     MediaEngineSupportParameters parameters;
 453     parameters.type = m_contentType;
 454     parameters.url = m_url;
 455 #if ENABLE(MEDIA_SOURCE)
 456     parameters.isMediaSource = !!m_mediaSource;
 457 #endif
 458 #if ENABLE(MEDIA_STREAM)
 459     parameters.isMediaStream = !!m_mediaStream;
 460 #endif
 461 
 462     return bestMediaEngineForSupportParameters(parameters, current);
 463 }
 464 
 465 void MediaPlayer::loadWithNextMediaEngine(const MediaPlayerFactory* current)
 466 {
 467 #if ENABLE(MEDIA_SOURCE)
 468 #define MEDIASOURCE m_mediaSource
 469 #else
 470 #define MEDIASOURCE 0
 471 #endif
 472 
 473 #if ENABLE(MEDIA_STREAM)
 474 #define MEDIASTREAM m_mediaStream
 475 #else
 476 #define MEDIASTREAM 0
 477 #endif
 478 
 479     ASSERT(!m_initializingMediaEngine);
 480     m_initializingMediaEngine = true;
 481 
 482     const MediaPlayerFactory* engine = nullptr;
 483 
 484     if (!m_contentType.isEmpty() || MEDIASTREAM || MEDIASOURCE)
 485         engine = nextBestMediaEngine(current);
 486 
 487     // If no MIME type is specified or the type was inferred from the file extension, just use the next engine.
 488     if (!engine &amp;&amp; (m_contentType.isEmpty() || m_contentMIMETypeWasInferredFromExtension))
 489         engine = nextMediaEngine(current);
 490 
 491     // Don&#39;t delete and recreate the player unless it comes from a different engine.
 492     if (!engine) {
 493         LOG(Media, &quot;MediaPlayer::loadWithNextMediaEngine - no media engine found for type \&quot;%s\&quot;&quot;, m_contentType.raw().utf8().data());
 494         m_currentMediaEngine = engine;
 495         m_private = nullptr;
 496     } else if (m_currentMediaEngine != engine) {
 497         m_currentMediaEngine = engine;
 498         m_private = engine-&gt;constructor(this);
 499         client().mediaPlayerEngineUpdated(this);
 500         m_private-&gt;setPrivateBrowsingMode(m_privateBrowsing);
 501         m_private-&gt;setPreload(m_preload);
 502         m_private-&gt;setPreservesPitch(preservesPitch());
 503         if (m_shouldPrepareToRender)
 504             m_private-&gt;prepareForRendering();
 505     }
 506 
 507     if (m_private) {
 508 #if ENABLE(MEDIA_SOURCE)
 509         if (m_mediaSource)
 510             m_private-&gt;load(m_url.string(), m_mediaSource.get());
 511         else
 512 #endif
 513 #if ENABLE(MEDIA_STREAM)
 514         if (m_mediaStream)
 515             m_private-&gt;load(*m_mediaStream);
 516         else
 517 #endif
 518         m_private-&gt;load(m_url.string());
 519     } else {
<a name="31" id="anc31"></a><span class="line-modified"> 520         m_private = std::make_unique&lt;NullMediaPlayerPrivate&gt;(this);</span>
 521         client().mediaPlayerEngineUpdated(this);
 522         client().mediaPlayerResourceNotSupported(this);
 523     }
 524 
 525     m_initializingMediaEngine = false;
 526 }
 527 
 528 bool MediaPlayer::hasAvailableVideoFrame() const
 529 {
 530     return m_private-&gt;hasAvailableVideoFrame();
 531 }
 532 
 533 void MediaPlayer::prepareForRendering()
 534 {
 535     m_shouldPrepareToRender = true;
 536     m_private-&gt;prepareForRendering();
 537 }
 538 
 539 bool MediaPlayer::canLoadPoster() const
 540 {
 541     return m_private-&gt;canLoadPoster();
 542 }
 543 
 544 void MediaPlayer::setPoster(const String&amp; url)
 545 {
 546     m_private-&gt;setPoster(url);
 547 }
 548 
 549 void MediaPlayer::cancelLoad()
 550 {
 551     m_private-&gt;cancelLoad();
 552 }
 553 
 554 void MediaPlayer::prepareToPlay()
 555 {
 556     Ref&lt;MediaPlayer&gt; protectedThis(*this);
 557 
 558     m_private-&gt;prepareToPlay();
 559 }
 560 
 561 void MediaPlayer::play()
 562 {
 563     m_private-&gt;play();
 564 }
 565 
 566 void MediaPlayer::pause()
 567 {
 568     m_private-&gt;pause();
 569 }
 570 
<a name="32" id="anc32"></a><span class="line-modified"> 571 void MediaPlayer::setShouldBufferData(bool shouldBuffer)</span>
 572 {
<a name="33" id="anc33"></a><span class="line-modified"> 573     m_private-&gt;setShouldBufferData(shouldBuffer);</span>
 574 }
 575 
 576 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 577 
 578 std::unique_ptr&lt;LegacyCDMSession&gt; MediaPlayer::createSession(const String&amp; keySystem, LegacyCDMSessionClient* client)
 579 {
 580     return m_private-&gt;createSession(keySystem, client);
 581 }
 582 
 583 void MediaPlayer::setCDMSession(LegacyCDMSession* session)
 584 {
 585     m_private-&gt;setCDMSession(session);
 586 }
 587 
 588 void MediaPlayer::keyAdded()
 589 {
 590     m_private-&gt;keyAdded();
 591 }
 592 
 593 #endif
 594 
 595 #if ENABLE(ENCRYPTED_MEDIA)
 596 
 597 void MediaPlayer::cdmInstanceAttached(CDMInstance&amp; instance)
 598 {
 599     m_private-&gt;cdmInstanceAttached(instance);
 600 }
 601 
 602 void MediaPlayer::cdmInstanceDetached(CDMInstance&amp; instance)
 603 {
 604     m_private-&gt;cdmInstanceDetached(instance);
 605 }
 606 
 607 void MediaPlayer::attemptToDecryptWithInstance(CDMInstance&amp; instance)
 608 {
 609     m_private-&gt;attemptToDecryptWithInstance(instance);
 610 }
 611 
 612 #endif
 613 
 614 MediaTime MediaPlayer::duration() const
 615 {
 616     return m_private-&gt;durationMediaTime();
 617 }
 618 
 619 MediaTime MediaPlayer::startTime() const
 620 {
 621     return m_private-&gt;startTime();
 622 }
 623 
 624 MediaTime MediaPlayer::initialTime() const
 625 {
 626     return m_private-&gt;initialTime();
 627 }
 628 
 629 MediaTime MediaPlayer::currentTime() const
 630 {
 631     return m_private-&gt;currentMediaTime();
 632 }
 633 
 634 MediaTime MediaPlayer::getStartDate() const
 635 {
 636     return m_private-&gt;getStartDate();
 637 }
 638 
 639 void MediaPlayer::seekWithTolerance(const MediaTime&amp; time, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance)
 640 {
 641     m_private-&gt;seekWithTolerance(time, negativeTolerance, positiveTolerance);
 642 }
 643 
 644 void MediaPlayer::seek(const MediaTime&amp; time)
 645 {
 646     m_private-&gt;seek(time);
 647 }
 648 
 649 bool MediaPlayer::paused() const
 650 {
 651     return m_private-&gt;paused();
 652 }
 653 
 654 bool MediaPlayer::seeking() const
 655 {
 656     return m_private-&gt;seeking();
 657 }
 658 
 659 bool MediaPlayer::supportsFullscreen() const
 660 {
 661     return m_private-&gt;supportsFullscreen();
 662 }
 663 
 664 bool MediaPlayer::canSaveMediaData() const
 665 {
 666     return m_private-&gt;canSaveMediaData();
 667 }
 668 
 669 bool MediaPlayer::supportsScanning() const
 670 {
 671     return m_private-&gt;supportsScanning();
 672 }
 673 
 674 bool MediaPlayer::requiresImmediateCompositing() const
 675 {
 676     return m_private-&gt;requiresImmediateCompositing();
 677 }
 678 
 679 FloatSize MediaPlayer::naturalSize()
 680 {
 681     return m_private-&gt;naturalSize();
 682 }
 683 
 684 bool MediaPlayer::hasVideo() const
 685 {
 686     return m_private-&gt;hasVideo();
 687 }
 688 
 689 bool MediaPlayer::hasAudio() const
 690 {
 691     return m_private-&gt;hasAudio();
 692 }
 693 
 694 bool MediaPlayer::inMediaDocument() const
 695 {
 696     return m_visible &amp;&amp; client().mediaPlayerIsInMediaDocument();
 697 }
 698 
 699 PlatformLayer* MediaPlayer::platformLayer() const
 700 {
 701     return m_private-&gt;platformLayer();
 702 }
 703 
 704 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 705 
 706 void MediaPlayer::setVideoFullscreenLayer(PlatformLayer* layer, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
 707 {
 708     m_private-&gt;setVideoFullscreenLayer(layer, WTFMove(completionHandler));
 709 }
 710 
 711 void MediaPlayer::updateVideoFullscreenInlineImage()
 712 {
 713     m_private-&gt;updateVideoFullscreenInlineImage();
 714 }
 715 
 716 void MediaPlayer::setVideoFullscreenFrame(FloatRect frame)
 717 {
 718     m_private-&gt;setVideoFullscreenFrame(frame);
 719 }
 720 
 721 void MediaPlayer::setVideoFullscreenGravity(MediaPlayer::VideoGravity gravity)
 722 {
 723     m_private-&gt;setVideoFullscreenGravity(gravity);
 724 }
 725 
 726 void MediaPlayer::setVideoFullscreenMode(MediaPlayer::VideoFullscreenMode mode)
 727 {
 728     m_private-&gt;setVideoFullscreenMode(mode);
 729 }
 730 
 731 MediaPlayer::VideoFullscreenMode MediaPlayer::fullscreenMode() const
 732 {
 733     return client().mediaPlayerFullscreenMode();
 734 }
 735 
 736 void MediaPlayer::videoFullscreenStandbyChanged()
 737 {
 738     m_private-&gt;videoFullscreenStandbyChanged();
 739 }
 740 
 741 bool MediaPlayer::isVideoFullscreenStandby() const
 742 {
 743     return client().mediaPlayerIsVideoFullscreenStandby();
 744 }
 745 
 746 #endif
 747 
 748 #if PLATFORM(IOS_FAMILY)
 749 
 750 NSArray* MediaPlayer::timedMetadata() const
 751 {
 752     return m_private-&gt;timedMetadata();
 753 }
 754 
 755 String MediaPlayer::accessLog() const
 756 {
 757     return m_private-&gt;accessLog();
 758 }
 759 
 760 String MediaPlayer::errorLog() const
 761 {
 762     return m_private-&gt;errorLog();
 763 }
 764 
 765 #endif
 766 
 767 MediaPlayer::NetworkState MediaPlayer::networkState()
 768 {
 769     return m_private-&gt;networkState();
 770 }
 771 
 772 MediaPlayer::ReadyState MediaPlayer::readyState()
 773 {
 774     return m_private-&gt;readyState();
 775 }
 776 
 777 double MediaPlayer::volume() const
 778 {
 779     return m_volume;
 780 }
 781 
 782 void MediaPlayer::setVolume(double volume)
 783 {
 784     m_volume = volume;
<a name="34" id="anc34"></a><span class="line-modified"> 785 </span>
<span class="line-removed"> 786     if (m_private-&gt;supportsMuting() || !m_muted)</span>
<span class="line-removed"> 787         m_private-&gt;setVolumeDouble(volume);</span>
 788 }
 789 
 790 bool MediaPlayer::muted() const
 791 {
 792     return m_muted;
 793 }
 794 
 795 void MediaPlayer::setMuted(bool muted)
 796 {
 797     m_muted = muted;
 798 
<a name="35" id="anc35"></a><span class="line-modified"> 799     if (m_private-&gt;supportsMuting())</span>
<span class="line-removed"> 800         m_private-&gt;setMuted(muted);</span>
<span class="line-removed"> 801     else</span>
<span class="line-removed"> 802         m_private-&gt;setVolume(muted ? 0 : m_volume);</span>
 803 }
 804 
 805 bool MediaPlayer::hasClosedCaptions() const
 806 {
 807     return m_private-&gt;hasClosedCaptions();
 808 }
 809 
 810 void MediaPlayer::setClosedCaptionsVisible(bool closedCaptionsVisible)
 811 {
 812     m_private-&gt;setClosedCaptionsVisible(closedCaptionsVisible);
 813 }
 814 
 815 double MediaPlayer::rate() const
 816 {
 817     return m_private-&gt;rate();
 818 }
 819 
 820 void MediaPlayer::setRate(double rate)
 821 {
 822     m_private-&gt;setRateDouble(rate);
 823 }
 824 
 825 double MediaPlayer::requestedRate() const
 826 {
 827     return client().mediaPlayerRequestedPlaybackRate();
 828 }
 829 
 830 bool MediaPlayer::preservesPitch() const
 831 {
 832     return m_preservesPitch;
 833 }
 834 
 835 void MediaPlayer::setPreservesPitch(bool preservesPitch)
 836 {
 837     m_preservesPitch = preservesPitch;
 838     m_private-&gt;setPreservesPitch(preservesPitch);
 839 }
 840 
 841 std::unique_ptr&lt;PlatformTimeRanges&gt; MediaPlayer::buffered()
 842 {
 843     return m_private-&gt;buffered();
 844 }
 845 
 846 std::unique_ptr&lt;PlatformTimeRanges&gt; MediaPlayer::seekable()
 847 {
 848     return m_private-&gt;seekable();
 849 }
 850 
 851 MediaTime MediaPlayer::maxTimeSeekable()
 852 {
 853     return m_private-&gt;maxMediaTimeSeekable();
 854 }
 855 
 856 MediaTime MediaPlayer::minTimeSeekable()
 857 {
 858     return m_private-&gt;minMediaTimeSeekable();
 859 }
 860 
 861 double MediaPlayer::seekableTimeRangesLastModifiedTime()
 862 {
 863     return m_private-&gt;seekableTimeRangesLastModifiedTime();
 864 }
 865 
 866 double MediaPlayer::liveUpdateInterval()
 867 {
 868     return m_private-&gt;liveUpdateInterval();
 869 }
 870 
 871 bool MediaPlayer::didLoadingProgress()
 872 {
 873     return m_private-&gt;didLoadingProgress();
 874 }
 875 
 876 void MediaPlayer::setSize(const IntSize&amp; size)
 877 {
 878     m_size = size;
 879     m_private-&gt;setSize(size);
 880 }
 881 
 882 bool MediaPlayer::visible() const
 883 {
 884     return m_visible;
 885 }
 886 
 887 void MediaPlayer::setVisible(bool b)
 888 {
 889     m_visible = b;
 890     m_private-&gt;setVisible(b);
 891 }
 892 
 893 MediaPlayer::Preload MediaPlayer::preload() const
 894 {
 895     return m_preload;
 896 }
 897 
 898 void MediaPlayer::setPreload(MediaPlayer::Preload preload)
 899 {
 900     m_preload = preload;
 901     m_private-&gt;setPreload(preload);
 902 }
 903 
 904 void MediaPlayer::paint(GraphicsContext&amp; p, const FloatRect&amp; r)
 905 {
 906     m_private-&gt;paint(p, r);
 907 }
 908 
 909 void MediaPlayer::paintCurrentFrameInContext(GraphicsContext&amp; p, const FloatRect&amp; r)
 910 {
 911     m_private-&gt;paintCurrentFrameInContext(p, r);
 912 }
 913 
 914 bool MediaPlayer::copyVideoTextureToPlatformTexture(GraphicsContext3D* context, Platform3DObject texture, GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY)
 915 {
 916     return m_private-&gt;copyVideoTextureToPlatformTexture(context, texture, target, level, internalFormat, format, type, premultiplyAlpha, flipY);
 917 }
 918 
 919 NativeImagePtr MediaPlayer::nativeImageForCurrentTime()
 920 {
 921     return m_private-&gt;nativeImageForCurrentTime();
 922 }
 923 
 924 MediaPlayer::SupportsType MediaPlayer::supportsType(const MediaEngineSupportParameters&amp; parameters)
 925 {
 926     // 4.8.10.3 MIME types - The canPlayType(type) method must return the empty string if type is a type that the
 927     // user agent knows it cannot render or is the type &quot;application/octet-stream&quot;
<a name="36" id="anc36"></a><span class="line-modified"> 928     AtomicString containerType = parameters.type.containerType();</span>
 929     if (containerType == applicationOctetStream())
 930         return IsNotSupported;
 931 
 932     const MediaPlayerFactory* engine = bestMediaEngineForSupportParameters(parameters);
 933     if (!engine)
 934         return IsNotSupported;
 935 
 936     return engine-&gt;supportsTypeAndCodecs(parameters);
 937 }
 938 
 939 void MediaPlayer::getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types)
 940 {
 941     for (auto&amp; engine : installedMediaEngines()) {
 942         HashSet&lt;String, ASCIICaseInsensitiveHash&gt; engineTypes;
 943         engine.getSupportedTypes(engineTypes);
 944         types.add(engineTypes.begin(), engineTypes.end());
 945     }
 946 }
 947 
 948 bool MediaPlayer::isAvailable()
 949 {
 950 #if PLATFORM(IOS_FAMILY)
 951     if (DeprecatedGlobalSettings::isAVFoundationEnabled())
 952         return true;
 953 #endif
 954     return !installedMediaEngines().isEmpty();
 955 }
 956 
 957 bool MediaPlayer::supportsPictureInPicture() const
 958 {
 959     return m_private-&gt;supportsPictureInPicture();
 960 }
 961 
 962 #if USE(NATIVE_FULLSCREEN_VIDEO)
 963 
 964 void MediaPlayer::enterFullscreen()
 965 {
 966     m_private-&gt;enterFullscreen();
 967 }
 968 
 969 void MediaPlayer::exitFullscreen()
 970 {
 971     m_private-&gt;exitFullscreen();
 972 }
 973 
 974 #endif
 975 
 976 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 977 
 978 bool MediaPlayer::isCurrentPlaybackTargetWireless() const
 979 {
 980     return m_private-&gt;isCurrentPlaybackTargetWireless();
 981 }
 982 
 983 String MediaPlayer::wirelessPlaybackTargetName() const
 984 {
 985     return m_private-&gt;wirelessPlaybackTargetName();
 986 }
 987 
 988 MediaPlayer::WirelessPlaybackTargetType MediaPlayer::wirelessPlaybackTargetType() const
 989 {
 990     return m_private-&gt;wirelessPlaybackTargetType();
 991 }
 992 
 993 bool MediaPlayer::wirelessVideoPlaybackDisabled() const
 994 {
 995     return m_private-&gt;wirelessVideoPlaybackDisabled();
 996 }
 997 
 998 void MediaPlayer::setWirelessVideoPlaybackDisabled(bool disabled)
 999 {
1000     m_private-&gt;setWirelessVideoPlaybackDisabled(disabled);
1001 }
1002 
1003 void MediaPlayer::currentPlaybackTargetIsWirelessChanged()
1004 {
1005     client().mediaPlayerCurrentPlaybackTargetIsWirelessChanged(this);
1006 }
1007 
1008 bool MediaPlayer::canPlayToWirelessPlaybackTarget() const
1009 {
1010     return m_private-&gt;canPlayToWirelessPlaybackTarget();
1011 }
1012 
1013 void MediaPlayer::setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
1014 {
1015     m_private-&gt;setWirelessPlaybackTarget(WTFMove(device));
1016 }
1017 
1018 void MediaPlayer::setShouldPlayToPlaybackTarget(bool shouldPlay)
1019 {
1020     m_private-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
1021 }
1022 
1023 #endif
1024 
1025 double MediaPlayer::maxFastForwardRate() const
1026 {
1027     return m_private-&gt;maxFastForwardRate();
1028 }
1029 
1030 double MediaPlayer::minFastReverseRate() const
1031 {
1032     return m_private-&gt;minFastReverseRate();
1033 }
1034 
1035 #if USE(NATIVE_FULLSCREEN_VIDEO)
1036 
1037 bool MediaPlayer::canEnterFullscreen() const
1038 {
1039     return m_private-&gt;canEnterFullscreen();
1040 }
1041 
1042 #endif
1043 
1044 void MediaPlayer::acceleratedRenderingStateChanged()
1045 {
1046     m_private-&gt;acceleratedRenderingStateChanged();
1047 }
1048 
1049 bool MediaPlayer::supportsAcceleratedRendering() const
1050 {
1051     return m_private-&gt;supportsAcceleratedRendering();
1052 }
1053 
1054 bool MediaPlayer::shouldMaintainAspectRatio() const
1055 {
1056     return m_private-&gt;shouldMaintainAspectRatio();
1057 }
1058 
1059 void MediaPlayer::setShouldMaintainAspectRatio(bool maintainAspectRatio)
1060 {
1061     m_private-&gt;setShouldMaintainAspectRatio(maintainAspectRatio);
1062 }
1063 
1064 bool MediaPlayer::hasSingleSecurityOrigin() const
1065 {
1066     return m_private-&gt;hasSingleSecurityOrigin();
1067 }
1068 
1069 bool MediaPlayer::didPassCORSAccessCheck() const
1070 {
1071     return m_private-&gt;didPassCORSAccessCheck();
1072 }
1073 
1074 bool MediaPlayer::wouldTaintOrigin(const SecurityOrigin&amp; origin) const
1075 {
1076     auto wouldTaint = m_private-&gt;wouldTaintOrigin(origin);
1077     if (wouldTaint.hasValue())
1078         return wouldTaint.value();
1079 
1080     if (m_url.protocolIsData())
1081         return false;
1082 
1083     return !origin.canRequest(m_url);
1084 }
1085 
1086 MediaPlayer::MovieLoadType MediaPlayer::movieLoadType() const
1087 {
1088     return m_private-&gt;movieLoadType();
1089 }
1090 
1091 MediaTime MediaPlayer::mediaTimeForTimeValue(const MediaTime&amp; timeValue) const
1092 {
1093     return m_private-&gt;mediaTimeForTimeValue(timeValue);
1094 }
1095 
1096 double MediaPlayer::maximumDurationToCacheMediaTime() const
1097 {
1098     return m_private-&gt;maximumDurationToCacheMediaTime();
1099 }
1100 
1101 unsigned MediaPlayer::decodedFrameCount() const
1102 {
1103     return m_private-&gt;decodedFrameCount();
1104 }
1105 
1106 unsigned MediaPlayer::droppedFrameCount() const
1107 {
1108     return m_private-&gt;droppedFrameCount();
1109 }
1110 
1111 unsigned MediaPlayer::audioDecodedByteCount() const
1112 {
1113     return m_private-&gt;audioDecodedByteCount();
1114 }
1115 
1116 unsigned MediaPlayer::videoDecodedByteCount() const
1117 {
1118     return m_private-&gt;videoDecodedByteCount();
1119 }
1120 
1121 void MediaPlayer::reloadTimerFired()
1122 {
1123     m_private-&gt;cancelLoad();
1124     loadWithNextMediaEngine(m_currentMediaEngine);
1125 }
1126 
1127 template&lt;typename T&gt;
1128 static void addToHash(HashSet&lt;T&gt;&amp; toHash, HashSet&lt;T&gt;&amp;&amp; fromHash)
1129 {
1130     if (toHash.isEmpty())
1131         toHash = WTFMove(fromHash);
1132     else
1133         toHash.add(fromHash.begin(), fromHash.end());
1134 }
1135 
1136 HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; MediaPlayer::originsInMediaCache(const String&amp; path)
1137 {
1138     HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; origins;
1139     for (auto&amp; engine : installedMediaEngines()) {
1140         if (!engine.originsInMediaCache)
1141             continue;
1142         addToHash(origins, engine.originsInMediaCache(path));
1143     }
1144     return origins;
1145 }
1146 
1147 void MediaPlayer::clearMediaCache(const String&amp; path, WallTime modifiedSince)
1148 {
1149     for (auto&amp; engine : installedMediaEngines()) {
1150         if (engine.clearMediaCache)
1151             engine.clearMediaCache(path, modifiedSince);
1152     }
1153 }
1154 
1155 void MediaPlayer::clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; origins)
1156 {
1157     for (auto&amp; engine : installedMediaEngines()) {
1158         if (engine.clearMediaCacheForOrigins)
1159             engine.clearMediaCacheForOrigins(path, origins);
1160     }
1161 }
1162 
1163 bool MediaPlayer::supportsKeySystem(const String&amp; keySystem, const String&amp; mimeType)
1164 {
1165     for (auto&amp; engine : installedMediaEngines()) {
1166         if (engine.supportsKeySystem &amp;&amp; engine.supportsKeySystem(keySystem, mimeType))
1167             return true;
1168     }
1169     return false;
1170 }
1171 
1172 void MediaPlayer::setPrivateBrowsingMode(bool privateBrowsingMode)
1173 {
1174     m_privateBrowsing = privateBrowsingMode;
1175     if (m_private)
1176         m_private-&gt;setPrivateBrowsingMode(m_privateBrowsing);
1177 }
1178 
1179 // Client callbacks.
1180 void MediaPlayer::networkStateChanged()
1181 {
1182     // If more than one media engine is installed and this one failed before finding metadata,
1183     // let the next engine try.
1184     if (m_private-&gt;networkState() &gt;= FormatError &amp;&amp; m_private-&gt;readyState() &lt; HaveMetadata) {
1185         client().mediaPlayerEngineFailedToLoad();
1186         if (installedMediaEngines().size() &gt; 1 &amp;&amp; (m_contentType.isEmpty() || nextBestMediaEngine(m_currentMediaEngine))) {
1187             m_reloadTimer.startOneShot(0_s);
1188             return;
1189         }
1190     }
1191     client().mediaPlayerNetworkStateChanged(this);
1192 }
1193 
1194 void MediaPlayer::readyStateChanged()
1195 {
1196     client().mediaPlayerReadyStateChanged(this);
1197 }
1198 
1199 void MediaPlayer::volumeChanged(double newVolume)
1200 {
1201 #if PLATFORM(IOS_FAMILY)
1202     UNUSED_PARAM(newVolume);
1203     m_volume = m_private-&gt;volume();
1204 #else
1205     m_volume = newVolume;
1206 #endif
1207     client().mediaPlayerVolumeChanged(this);
1208 }
1209 
1210 void MediaPlayer::muteChanged(bool newMuted)
1211 {
1212     if (newMuted == m_muted)
1213         return;
1214 
1215     m_muted = newMuted;
1216     client().mediaPlayerMuteChanged(this);
1217 }
1218 
1219 void MediaPlayer::timeChanged()
1220 {
1221     client().mediaPlayerTimeChanged(this);
1222 }
1223 
1224 void MediaPlayer::sizeChanged()
1225 {
1226     client().mediaPlayerSizeChanged(this);
1227 }
1228 
1229 void MediaPlayer::repaint()
1230 {
1231     client().mediaPlayerRepaint(this);
1232 }
1233 
1234 void MediaPlayer::durationChanged()
1235 {
1236     client().mediaPlayerDurationChanged(this);
1237 }
1238 
1239 void MediaPlayer::rateChanged()
1240 {
1241     client().mediaPlayerRateChanged(this);
1242 }
1243 
1244 void MediaPlayer::playbackStateChanged()
1245 {
1246     client().mediaPlayerPlaybackStateChanged(this);
1247 }
1248 
1249 void MediaPlayer::firstVideoFrameAvailable()
1250 {
1251     client().mediaPlayerFirstVideoFrameAvailable(this);
1252 }
1253 
1254 void MediaPlayer::characteristicChanged()
1255 {
1256     client().mediaPlayerCharacteristicChanged(this);
1257 }
1258 
1259 #if ENABLE(WEB_AUDIO)
1260 
1261 AudioSourceProvider* MediaPlayer::audioSourceProvider()
1262 {
1263     return m_private-&gt;audioSourceProvider();
1264 }
1265 
1266 #endif
1267 
1268 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
1269 
1270 RefPtr&lt;ArrayBuffer&gt; MediaPlayer::cachedKeyForKeyId(const String&amp; keyId) const
1271 {
1272     return client().mediaPlayerCachedKeyForKeyId(keyId);
1273 }
1274 
1275 bool MediaPlayer::keyNeeded(Uint8Array* initData)
1276 {
1277     return client().mediaPlayerKeyNeeded(this, initData);
1278 }
1279 
1280 String MediaPlayer::mediaKeysStorageDirectory() const
1281 {
1282     return client().mediaPlayerMediaKeysStorageDirectory();
1283 }
1284 
1285 #endif
1286 
1287 #if ENABLE(ENCRYPTED_MEDIA)
1288 
1289 void MediaPlayer::initializationDataEncountered(const String&amp; initDataType, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; initData)
1290 {
1291     client().mediaPlayerInitializationDataEncountered(initDataType, WTFMove(initData));
1292 }
1293 
1294 void MediaPlayer::waitingForKeyChanged()
1295 {
1296     client().mediaPlayerWaitingForKeyChanged();
1297 }
1298 
1299 bool MediaPlayer::waitingForKey() const
1300 {
1301     if (!m_private)
1302         return false;
1303     return m_private-&gt;waitingForKey();
1304 }
1305 #endif
1306 
1307 String MediaPlayer::referrer() const
1308 {
1309     return client().mediaPlayerReferrer();
1310 }
1311 
1312 String MediaPlayer::userAgent() const
1313 {
1314     return client().mediaPlayerUserAgent();
1315 }
1316 
1317 String MediaPlayer::engineDescription() const
1318 {
1319     if (!m_private)
1320         return String();
1321 
1322     return m_private-&gt;engineDescription();
1323 }
1324 
1325 long MediaPlayer::platformErrorCode() const
1326 {
1327     if (!m_private)
1328         return 0;
1329 
1330     return m_private-&gt;platformErrorCode();
1331 }
1332 
1333 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
1334 GraphicsDeviceAdapter* MediaPlayer::graphicsDeviceAdapter() const
1335 {
1336     return client().mediaPlayerGraphicsDeviceAdapter(this);
1337 }
1338 #endif
1339 
1340 CachedResourceLoader* MediaPlayer::cachedResourceLoader()
1341 {
1342     return client().mediaPlayerCachedResourceLoader();
1343 }
1344 
1345 RefPtr&lt;PlatformMediaResourceLoader&gt; MediaPlayer::createResourceLoader()
1346 {
1347     return client().mediaPlayerCreateResourceLoader();
1348 }
1349 
1350 #if ENABLE(VIDEO_TRACK)
1351 
1352 void MediaPlayer::addAudioTrack(AudioTrackPrivate&amp; track)
1353 {
1354     client().mediaPlayerDidAddAudioTrack(track);
1355 }
1356 
1357 void MediaPlayer::removeAudioTrack(AudioTrackPrivate&amp; track)
1358 {
1359     client().mediaPlayerDidRemoveAudioTrack(track);
1360 }
1361 
1362 void MediaPlayer::addTextTrack(InbandTextTrackPrivate&amp; track)
1363 {
1364     client().mediaPlayerDidAddTextTrack(track);
1365 }
1366 
1367 void MediaPlayer::removeTextTrack(InbandTextTrackPrivate&amp; track)
1368 {
1369     client().mediaPlayerDidRemoveTextTrack(track);
1370 }
1371 
1372 void MediaPlayer::addVideoTrack(VideoTrackPrivate&amp; track)
1373 {
1374     client().mediaPlayerDidAddVideoTrack(track);
1375 }
1376 
1377 void MediaPlayer::removeVideoTrack(VideoTrackPrivate&amp; track)
1378 {
1379     client().mediaPlayerDidRemoveVideoTrack(track);
1380 }
1381 
1382 bool MediaPlayer::requiresTextTrackRepresentation() const
1383 {
1384     return m_private-&gt;requiresTextTrackRepresentation();
1385 }
1386 
1387 void MediaPlayer::setTextTrackRepresentation(TextTrackRepresentation* representation)
1388 {
1389     m_private-&gt;setTextTrackRepresentation(representation);
1390 }
1391 
1392 void MediaPlayer::syncTextTrackBounds()
1393 {
1394     m_private-&gt;syncTextTrackBounds();
1395 }
1396 
1397 void MediaPlayer::tracksChanged()
1398 {
1399     m_private-&gt;tracksChanged();
1400 }
1401 
1402 #if ENABLE(AVF_CAPTIONS)
1403 
1404 void MediaPlayer::notifyTrackModeChanged()
1405 {
1406     if (m_private)
1407         m_private-&gt;notifyTrackModeChanged();
1408 }
1409 
1410 Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; MediaPlayer::outOfBandTrackSources()
1411 {
1412     return client().outOfBandTrackSources();
1413 }
1414 
1415 #endif
1416 
1417 #endif // ENABLE(VIDEO_TRACK)
1418 
1419 void MediaPlayer::resetMediaEngines()
1420 {
1421     auto locker = holdLock(mediaEngineVectorLock);
1422 
1423     mutableInstalledMediaEnginesVector().clear();
1424     haveMediaEnginesVector() = false;
1425 }
1426 
1427 #if USE(GSTREAMER)
1428 void MediaPlayer::simulateAudioInterruption()
1429 {
1430     if (!m_private)
1431         return;
1432 
1433     m_private-&gt;simulateAudioInterruption();
1434 }
1435 #endif
1436 
1437 void MediaPlayer::beginSimulatedHDCPError()
1438 {
1439     if (m_private)
1440         m_private-&gt;beginSimulatedHDCPError();
1441 }
1442 
1443 void MediaPlayer::endSimulatedHDCPError()
1444 {
1445     if (m_private)
1446         m_private-&gt;endSimulatedHDCPError();
1447 }
1448 
1449 String MediaPlayer::languageOfPrimaryAudioTrack() const
1450 {
1451     if (!m_private)
1452         return emptyString();
1453 
1454     return m_private-&gt;languageOfPrimaryAudioTrack();
1455 }
1456 
1457 size_t MediaPlayer::extraMemoryCost() const
1458 {
1459     if (!m_private)
1460         return 0;
1461 
1462     return m_private-&gt;extraMemoryCost();
1463 }
1464 
1465 unsigned long long MediaPlayer::fileSize() const
1466 {
1467     if (!m_private)
1468         return 0;
1469 
1470     return m_private-&gt;fileSize();
1471 }
1472 
1473 bool MediaPlayer::ended() const
1474 {
1475     return m_private-&gt;ended();
1476 }
1477 
1478 Optional&lt;VideoPlaybackQualityMetrics&gt; MediaPlayer::videoPlaybackQualityMetrics()
1479 {
1480     if (!m_private)
1481         return WTF::nullopt;
1482 
1483     return m_private-&gt;videoPlaybackQualityMetrics();
1484 }
1485 
1486 void MediaPlayer::handlePlaybackCommand(PlatformMediaSession::RemoteControlCommandType command)
1487 {
1488     client().mediaPlayerHandlePlaybackCommand(command);
1489 }
1490 
1491 String MediaPlayer::sourceApplicationIdentifier() const
1492 {
1493     return client().mediaPlayerSourceApplicationIdentifier();
1494 }
1495 
1496 Vector&lt;String&gt; MediaPlayer::preferredAudioCharacteristics() const
1497 {
1498     return client().mediaPlayerPreferredAudioCharacteristics();
1499 }
1500 
1501 void MediaPlayerFactorySupport::callRegisterMediaEngine(MediaEngineRegister registerMediaEngine)
1502 {
1503     registerMediaEngine(addMediaEngine);
1504 }
1505 
<a name="37" id="anc37"></a><span class="line-modified">1506 bool MediaPlayer::doesHaveAttribute(const AtomicString&amp; attribute, AtomicString* value) const</span>
1507 {
1508     return client().doesHaveAttribute(attribute, value);
1509 }
1510 
1511 #if PLATFORM(IOS_FAMILY)
1512 String MediaPlayer::mediaPlayerNetworkInterfaceName() const
1513 {
1514     return client().mediaPlayerNetworkInterfaceName();
1515 }
1516 
1517 bool MediaPlayer::getRawCookies(const URL&amp; url, Vector&lt;Cookie&gt;&amp; cookies) const
1518 {
1519     return client().mediaPlayerGetRawCookies(url, cookies);
1520 }
1521 #endif
1522 
1523 void MediaPlayer::setShouldDisableSleep(bool flag)
1524 {
1525     if (m_private)
1526         m_private-&gt;setShouldDisableSleep(flag);
1527 }
1528 
1529 bool MediaPlayer::shouldDisableSleep() const
1530 {
1531     return client().mediaPlayerShouldDisableSleep();
1532 }
1533 
1534 const Vector&lt;ContentType&gt;&amp; MediaPlayer::mediaContentTypesRequiringHardwareSupport() const
1535 {
1536     return client().mediaContentTypesRequiringHardwareSupport();
1537 }
1538 
1539 bool MediaPlayer::shouldCheckHardwareSupport() const
1540 {
1541     return client().mediaPlayerShouldCheckHardwareSupport();
1542 }
1543 
1544 void MediaPlayer::applicationWillResignActive()
1545 {
1546     m_private-&gt;applicationWillResignActive();
1547 }
1548 
1549 void MediaPlayer::applicationDidBecomeActive()
1550 {
1551     m_private-&gt;applicationDidBecomeActive();
1552 }
1553 
1554 #if USE(AVFOUNDATION)
1555 
1556 AVPlayer* MediaPlayer::objCAVFoundationAVPlayer() const
1557 {
1558     return m_private-&gt;objCAVFoundationAVPlayer();
1559 }
1560 
1561 #endif
1562 
1563 bool MediaPlayer::performTaskAtMediaTime(WTF::Function&lt;void()&gt;&amp;&amp; task, MediaTime time)
1564 {
1565     return m_private-&gt;performTaskAtMediaTime(WTFMove(task), time);
1566 }
1567 
1568 bool MediaPlayer::shouldIgnoreIntrinsicSize()
1569 {
1570     return m_private-&gt;shouldIgnoreIntrinsicSize();
1571 }
1572 
1573 #if !RELEASE_LOG_DISABLED
1574 const Logger&amp; MediaPlayer::mediaPlayerLogger()
1575 {
1576     return client().mediaPlayerLogger();
1577 }
1578 #endif
1579 
1580 String convertEnumerationToString(MediaPlayerEnums::ReadyState enumerationValue)
1581 {
1582     static const NeverDestroyed&lt;String&gt; values[] = {
1583         MAKE_STATIC_STRING_IMPL(&quot;HaveNothing&quot;),
1584         MAKE_STATIC_STRING_IMPL(&quot;HaveMetadata&quot;),
1585         MAKE_STATIC_STRING_IMPL(&quot;HaveCurrentData&quot;),
1586         MAKE_STATIC_STRING_IMPL(&quot;HaveFutureData&quot;),
1587         MAKE_STATIC_STRING_IMPL(&quot;HaveEnoughData&quot;),
1588     };
1589     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveNothing) == 0, &quot;MediaPlayerEnums::HaveNothing is not 0 as expected&quot;);
1590     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveMetadata) == 1, &quot;MediaPlayerEnums::HaveMetadata is not 1 as expected&quot;);
1591     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveCurrentData) == 2, &quot;MediaPlayerEnums::HaveCurrentData is not 2 as expected&quot;);
1592     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveFutureData) == 3, &quot;MediaPlayerEnums::HaveFutureData is not 3 as expected&quot;);
1593     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveEnoughData) == 4, &quot;MediaPlayerEnums::HaveEnoughData is not 4 as expected&quot;);
1594     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1595     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1596 }
1597 
1598 String convertEnumerationToString(MediaPlayerEnums::NetworkState enumerationValue)
1599 {
1600     static const NeverDestroyed&lt;String&gt; values[] = {
1601         MAKE_STATIC_STRING_IMPL(&quot;Empty&quot;),
1602         MAKE_STATIC_STRING_IMPL(&quot;Idle&quot;),
1603         MAKE_STATIC_STRING_IMPL(&quot;Loading&quot;),
1604         MAKE_STATIC_STRING_IMPL(&quot;Loaded&quot;),
1605         MAKE_STATIC_STRING_IMPL(&quot;FormatError&quot;),
1606         MAKE_STATIC_STRING_IMPL(&quot;NetworkError&quot;),
1607         MAKE_STATIC_STRING_IMPL(&quot;DecodeError&quot;),
1608     };
1609     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Empty) == 0, &quot;MediaPlayerEnums::Empty is not 0 as expected&quot;);
1610     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Idle) == 1, &quot;MediaPlayerEnums::Idle is not 1 as expected&quot;);
1611     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Loading) == 2, &quot;MediaPlayerEnums::Loading is not 2 as expected&quot;);
1612     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Loaded) == 3, &quot;MediaPlayerEnums::Loaded is not 3 as expected&quot;);
1613     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::FormatError) == 4, &quot;MediaPlayerEnums::FormatError is not 4 as expected&quot;);
1614     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::NetworkError) == 5, &quot;MediaPlayerEnums::NetworkError is not 5 as expected&quot;);
1615     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::DecodeError) == 6, &quot;MediaPlayerEnums::DecodeError is not 6 as expected&quot;);
1616     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1617     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1618 }
1619 
1620 String convertEnumerationToString(MediaPlayerEnums::Preload enumerationValue)
1621 {
1622     static const NeverDestroyed&lt;String&gt; values[] = {
1623         MAKE_STATIC_STRING_IMPL(&quot;None&quot;),
1624         MAKE_STATIC_STRING_IMPL(&quot;MetaData&quot;),
1625         MAKE_STATIC_STRING_IMPL(&quot;Auto&quot;),
1626     };
1627     static_assert(!static_cast&lt;size_t&gt;(MediaPlayerEnums::None), &quot;MediaPlayerEnums::None is not 0 as expected&quot;);
1628     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::MetaData) == 1, &quot;MediaPlayerEnums::MetaData is not 1 as expected&quot;);
1629     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Auto) == 2, &quot;MediaPlayerEnums::Auto is not 2 as expected&quot;);
1630     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1631     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1632 }
1633 
1634 String convertEnumerationToString(MediaPlayerEnums::SupportsType enumerationValue)
1635 {
1636     static const NeverDestroyed&lt;String&gt; values[] = {
1637         MAKE_STATIC_STRING_IMPL(&quot;IsNotSupported&quot;),
1638         MAKE_STATIC_STRING_IMPL(&quot;IsSupported&quot;),
1639         MAKE_STATIC_STRING_IMPL(&quot;MayBeSupported&quot;),
1640     };
1641     static_assert(!static_cast&lt;size_t&gt;(MediaPlayerEnums::IsNotSupported), &quot;MediaPlayerEnums::IsNotSupported is not 0 as expected&quot;);
1642     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::IsSupported) == 1, &quot;MediaPlayerEnums::IsSupported is not 1 as expected&quot;);
1643     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::MayBeSupported) == 2, &quot;MediaPlayerEnums::MayBeSupported is not 2 as expected&quot;);
1644     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1645     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1646 }
1647 
<a name="38" id="anc38"></a>















1648 }
1649 
1650 #endif
<a name="39" id="anc39"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="39" type="hidden" />
</body>
</html>