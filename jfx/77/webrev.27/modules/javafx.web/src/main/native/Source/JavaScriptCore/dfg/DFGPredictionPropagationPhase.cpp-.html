<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPredictionPropagationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGPredictionPropagationPhase.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;DFGGraph.h&quot;
  32 #include &quot;DFGPhase.h&quot;
  33 #include &quot;JSCInlines.h&quot;
  34 
  35 namespace JSC { namespace DFG {
  36 
  37 namespace {
  38 
  39 bool verboseFixPointLoops = false;
  40 
  41 class PredictionPropagationPhase : public Phase {
  42 public:
  43     PredictionPropagationPhase(Graph&amp; graph)
  44         : Phase(graph, &quot;prediction propagation&quot;)
  45     {
  46     }
  47 
  48     bool run()
  49     {
  50         ASSERT(m_graph.m_form == ThreadedCPS);
  51         ASSERT(m_graph.m_unificationState == GloballyUnified);
  52 
  53         m_pass = PrimaryPass;
  54 
  55         propagateThroughArgumentPositions();
  56 
  57         processInvariants();
  58 
  59         propagateToFixpoint();
  60 
  61         m_pass = RareCasePass;
  62         propagateToFixpoint();
  63 
  64         m_pass = DoubleVotingPass;
  65         unsigned counter = 0;
  66         do {
  67             if (verboseFixPointLoops)
  68                 ++counter;
  69 
  70             m_changed = false;
  71             doRoundOfDoubleVoting();
  72             if (!m_changed)
  73                 break;
  74             m_changed = false;
  75             propagateForward();
  76         } while (m_changed);
  77 
  78         if (verboseFixPointLoops)
  79             dataLog(&quot;Iterated &quot;, counter, &quot; times in double voting fixpoint.\n&quot;);
  80 
  81         return true;
  82     }
  83 
  84 private:
  85     void propagateToFixpoint()
  86     {
  87         unsigned counter = 0;
  88         do {
  89             if (verboseFixPointLoops)
  90                 ++counter;
  91 
  92             m_changed = false;
  93 
  94             // Forward propagation is near-optimal for both topologically-sorted and
  95             // DFS-sorted code.
  96             propagateForward();
  97             if (!m_changed)
  98                 break;
  99 
 100             // Backward propagation reduces the likelihood that pathological code will
 101             // cause slowness. Loops (especially nested ones) resemble backward flow.
 102             // This pass captures two cases: (1) it detects if the forward fixpoint
 103             // found a sound solution and (2) short-circuits backward flow.
 104             m_changed = false;
 105             propagateBackward();
 106         } while (m_changed);
 107 
 108         if (verboseFixPointLoops)
 109             dataLog(&quot;Iterated &quot;, counter, &quot; times in propagateToFixpoint.\n&quot;);
 110     }
 111 
 112     bool setPrediction(SpeculatedType prediction)
 113     {
 114         ASSERT(m_currentNode-&gt;hasResult());
 115 
 116         // setPrediction() is used when we know that there is no way that we can change
 117         // our minds about what the prediction is going to be. There is no semantic
 118         // difference between setPrediction() and mergeSpeculation() other than the
 119         // increased checking to validate this property.
 120         ASSERT(m_currentNode-&gt;prediction() == SpecNone || m_currentNode-&gt;prediction() == prediction);
 121 
 122         return m_currentNode-&gt;predict(prediction);
 123     }
 124 
 125     bool mergePrediction(SpeculatedType prediction)
 126     {
 127         ASSERT(m_currentNode-&gt;hasResult());
 128 
 129         return m_currentNode-&gt;predict(prediction);
 130     }
 131 
 132     SpeculatedType speculatedDoubleTypeForPrediction(SpeculatedType value)
 133     {
 134         SpeculatedType result = SpecDoubleReal;
 135         if (value &amp; SpecDoubleImpureNaN)
 136             result |= SpecDoubleImpureNaN;
 137         if (value &amp; SpecDoublePureNaN)
 138             result |= SpecDoublePureNaN;
 139         if (!isFullNumberOrBooleanSpeculation(value))
 140             result |= SpecDoublePureNaN;
 141         return result;
 142     }
 143 
 144     SpeculatedType speculatedDoubleTypeForPredictions(SpeculatedType left, SpeculatedType right)
 145     {
 146         return speculatedDoubleTypeForPrediction(mergeSpeculations(left, right));
 147     }
 148 
 149     void propagate(Node* node)
 150     {
 151         NodeType op = node-&gt;op();
 152 
 153         bool changed = false;
 154 
 155         switch (op) {
 156         case GetLocal: {
 157             VariableAccessData* variable = node-&gt;variableAccessData();
 158             SpeculatedType prediction = variable-&gt;prediction();
 159             if (!variable-&gt;couldRepresentInt52() &amp;&amp; (prediction &amp; SpecInt52Only))
 160                 prediction = (prediction | SpecAnyIntAsDouble) &amp; ~SpecInt52Only;
 161             if (prediction)
 162                 changed |= mergePrediction(prediction);
 163             break;
 164         }
 165 
 166         case SetLocal: {
 167             VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 168             changed |= variableAccessData-&gt;predict(node-&gt;child1()-&gt;prediction());
 169             break;
 170         }
 171 
 172         case UInt32ToNumber: {
 173             if (node-&gt;canSpeculateInt32(m_pass))
 174                 changed |= mergePrediction(SpecInt32Only);
 175             else if (enableInt52())
 176                 changed |= mergePrediction(SpecAnyInt);
 177             else
 178                 changed |= mergePrediction(SpecBytecodeNumber);
 179             break;
 180         }
 181 
 182         case ValueAdd: {
 183             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 184             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 185 
 186             if (left &amp;&amp; right) {
 187                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 188                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 189                     if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 190                         changed |= mergePrediction(SpecInt32Only);
 191                     else if (m_graph.addShouldSpeculateAnyInt(node))
 192                         changed |= mergePrediction(SpecInt52Only);
 193                     else
 194                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 195                 } else if (isStringOrStringObjectSpeculation(left) || isStringOrStringObjectSpeculation(right)) {
 196                     // left or right is definitely something other than a number.
 197                     changed |= mergePrediction(SpecString);
 198                 } else if (isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 199                     changed |= mergePrediction(SpecBigInt);
 200                 else {
 201                     changed |= mergePrediction(SpecInt32Only);
 202                     if (node-&gt;mayHaveDoubleResult())
 203                         changed |= mergePrediction(SpecBytecodeDouble);
 204                     if (node-&gt;mayHaveBigIntResult())
 205                         changed |= mergePrediction(SpecBigInt);
 206                     if (node-&gt;mayHaveNonNumericResult())
 207                         changed |= mergePrediction(SpecString);
 208                 }
 209             }
 210             break;
 211         }
 212 
 213         case ArithAdd: {
 214             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 215             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 216 
 217             if (left &amp;&amp; right) {
 218                 if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 219                     changed |= mergePrediction(SpecInt32Only);
 220                 else if (m_graph.addShouldSpeculateAnyInt(node))
 221                     changed |= mergePrediction(SpecInt52Only);
 222                 else if (isFullNumberOrBooleanSpeculation(left) &amp;&amp; isFullNumberOrBooleanSpeculation(right))
 223                     changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 224                 else if (node-&gt;mayHaveNonIntResult() || (left &amp; SpecBytecodeDouble) || (right &amp; SpecBytecodeDouble))
 225                     changed |= mergePrediction(SpecInt32Only | SpecBytecodeDouble);
 226                 else
 227                     changed |= mergePrediction(SpecInt32Only);
 228             }
 229             break;
 230         }
 231 
 232         case ArithSub: {
 233             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 234             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 235 
 236             if (left &amp;&amp; right) {
 237                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 238                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 239                     if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 240                         changed |= mergePrediction(SpecInt32Only);
 241                     else if (m_graph.addShouldSpeculateAnyInt(node))
 242                         changed |= mergePrediction(SpecInt52Only);
 243                     else
 244                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 245                 } else if (node-&gt;mayHaveNonIntResult() || (left &amp; SpecBytecodeDouble) || (right &amp; SpecBytecodeDouble))
 246                     changed |= mergePrediction(SpecInt32Only | SpecBytecodeDouble);
 247                 else
 248                     changed |= mergePrediction(SpecInt32Only);
 249             }
 250             break;
 251         }
 252 
 253         case ValueSub: {
 254             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 255             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 256 
 257             if (left &amp;&amp; right) {
 258                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 259                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 260                     if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 261                         changed |= mergePrediction(SpecInt32Only);
 262                     else if (m_graph.addShouldSpeculateAnyInt(node))
 263                         changed |= mergePrediction(SpecInt52Only);
 264                     else
 265                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 266                 } else if (isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 267                     changed |= mergePrediction(SpecBigInt);
 268                 else {
 269                     changed |= mergePrediction(SpecInt32Only);
 270                     if (node-&gt;mayHaveDoubleResult())
 271                         changed |= mergePrediction(SpecBytecodeDouble);
 272                     if (node-&gt;mayHaveBigIntResult())
 273                         changed |= mergePrediction(SpecBigInt);
 274                 }
 275             }
 276 
 277             break;
 278         }
 279 
 280         case ValueNegate:
 281         case ArithNegate: {
 282             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 283             if (prediction) {
 284                 if (isInt32OrBooleanSpeculation(prediction) &amp;&amp; node-&gt;canSpeculateInt32(m_pass))
 285                     changed |= mergePrediction(SpecInt32Only);
 286                 else if (m_graph.unaryArithShouldSpeculateAnyInt(node, m_pass))
 287                     changed |= mergePrediction(SpecInt52Only);
 288                 else if (isBytecodeNumberSpeculation(prediction))
 289                     changed |= mergePrediction(speculatedDoubleTypeForPrediction(node-&gt;child1()-&gt;prediction()));
 290                 else {
 291                     changed |= mergePrediction(SpecInt32Only);
 292                     if (node-&gt;op() == ValueNegate &amp;&amp; node-&gt;mayHaveBigIntResult())
 293                         changed |= mergePrediction(SpecBigInt);
 294                     if (node-&gt;mayHaveDoubleResult())
 295                         changed |= mergePrediction(SpecBytecodeDouble);
 296                 }
 297             }
 298             break;
 299         }
 300         case ArithMin:
 301         case ArithMax: {
 302             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 303             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 304 
 305             if (left &amp;&amp; right) {
 306                 if (Node::shouldSpeculateInt32OrBooleanForArithmetic(node-&gt;child1().node(), node-&gt;child2().node())
 307                     &amp;&amp; node-&gt;canSpeculateInt32(m_pass))
 308                     changed |= mergePrediction(SpecInt32Only);
 309                 else
 310                     changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 311             }
 312             break;
 313         }
 314 
 315         case ValueMul:
 316         case ArithMul: {
 317             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 318             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 319 
 320             if (left &amp;&amp; right) {
 321                 // FIXME: We&#39;re currently relying on prediction propagation and backwards propagation
 322                 // whenever we can, and only falling back on result flags if that fails. And the result
 323                 // flags logic doesn&#39;t know how to use backwards propagation. We should get rid of the
 324                 // prediction propagation logic and rely solely on the result type.
 325                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 326                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 327                     if (m_graph.binaryArithShouldSpeculateInt32(node, m_pass))
 328                         changed |= mergePrediction(SpecInt32Only);
 329                     else if (m_graph.binaryArithShouldSpeculateAnyInt(node, m_pass))
 330                         changed |= mergePrediction(SpecInt52Only);
 331                     else
 332                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 333                 } else if (op == ValueMul &amp;&amp; isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 334                     changed |= mergePrediction(SpecBigInt);
 335                 else {
 336                     changed |= mergePrediction(SpecInt32Only);
 337                     if (node-&gt;mayHaveDoubleResult()
 338                         || (left &amp; SpecBytecodeDouble)
 339                         || (right &amp; SpecBytecodeDouble))
 340                         changed |= mergePrediction(SpecBytecodeDouble);
 341                     if ((op == ValueMul &amp;&amp; node-&gt;mayHaveBigIntResult())
 342                         || (left &amp; SpecBigInt)
 343                         || (right &amp; SpecBigInt))
 344                         changed |= mergePrediction(SpecBigInt);
 345                 }
 346             }
 347             break;
 348         }
 349 
 350         case ValueDiv:
 351         case ArithDiv:
 352         case ArithMod: {
 353             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 354             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 355 
 356             if (left &amp;&amp; right) {
 357                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 358                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 359                     if (m_graph.binaryArithShouldSpeculateInt32(node, m_pass))
 360                         changed |= mergePrediction(SpecInt32Only);
 361                     else
 362                         changed |= mergePrediction(SpecBytecodeDouble);
 363                 } else if (op == ValueDiv &amp;&amp; isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 364                     changed |= mergePrediction(SpecBigInt);
 365                 else {
 366                     changed |= mergePrediction(SpecInt32Only | SpecBytecodeDouble);
 367                     if (op == ValueDiv &amp;&amp; (node-&gt;mayHaveBigIntResult()
 368                         || (left &amp; SpecBigInt)
 369                         || (right &amp; SpecBigInt)))
 370                         changed |= mergePrediction(SpecBigInt);
 371                 }
 372             }
 373             break;
 374         }
 375 
 376         case ArithAbs: {
 377             SpeculatedType childPrediction = node-&gt;child1()-&gt;prediction();
 378             if (isInt32OrBooleanSpeculation(childPrediction)
 379                 &amp;&amp; node-&gt;canSpeculateInt32(m_pass))
 380                 changed |= mergePrediction(SpecInt32Only);
 381             else
 382                 changed |= mergePrediction(SpecBytecodeDouble);
 383             break;
 384         }
 385 
 386         case GetByVal:
 387         case AtomicsAdd:
 388         case AtomicsAnd:
 389         case AtomicsCompareExchange:
 390         case AtomicsExchange:
 391         case AtomicsLoad:
 392         case AtomicsOr:
 393         case AtomicsStore:
 394         case AtomicsSub:
 395         case AtomicsXor: {
 396             Edge child1 = m_graph.child(node, 0);
 397             if (!child1-&gt;prediction())
 398                 break;
 399 
 400             Edge child2 = m_graph.child(node, 1);
 401             ArrayMode arrayMode = node-&gt;arrayMode().refine(
 402                 m_graph, node,
 403                 child1-&gt;prediction(),
 404                 child2-&gt;prediction(),
 405                 SpecNone);
 406 
 407             switch (arrayMode.type()) {
 408             case Array::Int32:
 409                 if (arrayMode.isOutOfBounds())
 410                     changed |= mergePrediction(node-&gt;getHeapPrediction() | SpecInt32Only);
 411                 else
 412                     changed |= mergePrediction(SpecInt32Only);
 413                 break;
 414             case Array::Double:
 415                 if (arrayMode.isOutOfBounds())
 416                     changed |= mergePrediction(node-&gt;getHeapPrediction() | SpecDoubleReal);
 417                 else if (node-&gt;getHeapPrediction() &amp; SpecNonIntAsDouble)
 418                     changed |= mergePrediction(SpecDoubleReal);
 419                 else
 420                     changed |= mergePrediction(SpecAnyIntAsDouble);
 421                 break;
 422             case Array::Float32Array:
 423             case Array::Float64Array:
 424                 changed |= mergePrediction(SpecFullDouble);
 425                 break;
 426             case Array::Uint32Array:
 427                 if (isInt32SpeculationForArithmetic(node-&gt;getHeapPrediction()) &amp;&amp; node-&gt;op() == GetByVal)
 428                     changed |= mergePrediction(SpecInt32Only);
 429                 else if (enableInt52())
 430                     changed |= mergePrediction(SpecAnyInt);
 431                 else
 432                     changed |= mergePrediction(SpecInt32Only | SpecAnyIntAsDouble);
 433                 break;
 434             case Array::Int8Array:
 435             case Array::Uint8Array:
 436             case Array::Int16Array:
 437             case Array::Uint16Array:
 438             case Array::Int32Array:
 439                 changed |= mergePrediction(SpecInt32Only);
 440                 break;
 441             default:
 442                 changed |= mergePrediction(node-&gt;getHeapPrediction());
 443                 break;
 444             }
 445             break;
 446         }
 447 
 448         case ToThis: {
 449             // ToThis in methods for primitive types should speculate primitive types in strict mode.
 450             ECMAMode ecmaMode = m_graph.executableFor(node-&gt;origin.semantic)-&gt;isStrictMode() ? StrictMode : NotStrictMode;
 451             if (ecmaMode == StrictMode) {
 452                 if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
 453                     changed |= mergePrediction(SpecBoolean);
 454                     break;
 455                 }
 456 
 457                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
 458                     changed |= mergePrediction(SpecInt32Only);
 459                     break;
 460                 }
 461 
 462                 if (enableInt52() &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateAnyInt()) {
 463                     changed |= mergePrediction(SpecAnyInt);
 464                     break;
 465                 }
 466 
 467                 if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
 468                     changed |= mergePrediction(SpecBytecodeNumber);
 469                     break;
 470                 }
 471 
 472                 if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
 473                     changed |= mergePrediction(SpecSymbol);
 474                     break;
 475                 }
 476 
 477                 if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {
 478                     changed |= mergePrediction(SpecBigInt);
 479                     break;
 480                 }
 481 
 482                 if (node-&gt;child1()-&gt;shouldSpeculateStringIdent()) {
 483                     changed |= mergePrediction(SpecStringIdent);
 484                     break;
 485                 }
 486 
 487                 if (node-&gt;child1()-&gt;shouldSpeculateString()) {
 488                     changed |= mergePrediction(SpecString);
 489                     break;
 490                 }
 491             } else {
 492                 if (node-&gt;child1()-&gt;shouldSpeculateString()) {
 493                     changed |= mergePrediction(SpecStringObject);
 494                     break;
 495                 }
 496             }
 497 
 498             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 499             if (ecmaMode == StrictMode)
 500                 changed |= mergePrediction(node-&gt;getHeapPrediction());
 501             else if (prediction) {
 502                 if (prediction &amp; ~SpecObject) {
 503                     // Wrapper objects are created only in sloppy mode.
 504                     prediction &amp;= SpecObject;
 505                     prediction = mergeSpeculations(prediction, SpecObjectOther);
 506                 }
 507                 changed |= mergePrediction(prediction);
 508             }
 509             break;
 510         }
 511 
 512         case ToPrimitive: {
 513             SpeculatedType child = node-&gt;child1()-&gt;prediction();
 514             if (child)
 515                 changed |= mergePrediction(resultOfToPrimitive(child));
 516             break;
 517         }
 518 
 519         case NormalizeMapKey: {
 520             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 521             if (prediction)
 522                 changed |= mergePrediction(prediction);
 523             break;
 524         }
 525 
 526         default:
 527             break;
 528         }
 529 
 530         m_changed |= changed;
 531     }
 532 
 533     void propagateForward()
 534     {
 535         for (Node* node : m_dependentNodes) {
 536             m_currentNode = node;
 537             propagate(m_currentNode);
 538         }
 539     }
 540 
 541     void propagateBackward()
 542     {
 543         for (unsigned i = m_dependentNodes.size(); i--;) {
 544             m_currentNode = m_dependentNodes[i];
 545             propagate(m_currentNode);
 546         }
 547     }
 548 
 549     void doDoubleVoting(Node* node, float weight)
 550     {
 551         // Loop pre-headers created by OSR entrypoint creation may have NaN weight to indicate
 552         // that we actually don&#39;t know they weight. Assume that they execute once. This turns
 553         // out to be an OK assumption since the pre-header doesn&#39;t have any meaningful code.
 554         if (weight != weight)
 555             weight = 1;
 556 
 557         switch (node-&gt;op()) {
 558         case ValueAdd:
 559         case ValueSub:
 560         case ArithAdd:
 561         case ArithSub: {
 562             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 563             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 564 
 565             DoubleBallot ballot;
 566 
 567             if (isFullNumberSpeculation(left)
 568                 &amp;&amp; isFullNumberSpeculation(right)
 569                 &amp;&amp; !m_graph.addShouldSpeculateInt32(node, m_pass)
 570                 &amp;&amp; !m_graph.addShouldSpeculateAnyInt(node))
 571                 ballot = VoteDouble;
 572             else
 573                 ballot = VoteValue;
 574 
 575             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 576             m_graph.voteNode(node-&gt;child2(), ballot, weight);
 577             break;
 578         }
 579 
 580         case ValueMul:
 581         case ArithMul: {
 582             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 583             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 584 
 585             DoubleBallot ballot;
 586 
 587             if (isFullNumberSpeculation(left)
 588                 &amp;&amp; isFullNumberSpeculation(right)
 589                 &amp;&amp; !m_graph.binaryArithShouldSpeculateInt32(node, m_pass)
 590                 &amp;&amp; !m_graph.binaryArithShouldSpeculateAnyInt(node, m_pass))
 591                 ballot = VoteDouble;
 592             else
 593                 ballot = VoteValue;
 594 
 595             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 596             m_graph.voteNode(node-&gt;child2(), ballot, weight);
 597             break;
 598         }
 599 
 600         case ArithMin:
 601         case ArithMax:
 602         case ArithMod:
 603         case ValueDiv:
 604         case ArithDiv: {
 605             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 606             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 607 
 608             DoubleBallot ballot;
 609 
 610             if (isFullNumberSpeculation(left)
 611                 &amp;&amp; isFullNumberSpeculation(right)
 612                 &amp;&amp; !m_graph.binaryArithShouldSpeculateInt32(node, m_pass))
 613                 ballot = VoteDouble;
 614             else
 615                 ballot = VoteValue;
 616 
 617             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 618             m_graph.voteNode(node-&gt;child2(), ballot, weight);
 619             break;
 620         }
 621 
 622         case ArithAbs:
 623             DoubleBallot ballot;
 624             if (node-&gt;child1()-&gt;shouldSpeculateNumber()
 625                 &amp;&amp; !m_graph.unaryArithShouldSpeculateInt32(node, m_pass))
 626                 ballot = VoteDouble;
 627             else
 628                 ballot = VoteValue;
 629 
 630             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 631             break;
 632 
 633         case ArithSqrt:
 634         case ArithUnary:
 635             if (node-&gt;child1()-&gt;shouldSpeculateNumber())
 636                 m_graph.voteNode(node-&gt;child1(), VoteDouble, weight);
 637             else
 638                 m_graph.voteNode(node-&gt;child1(), VoteValue, weight);
 639             break;
 640 
 641         case SetLocal: {
 642             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 643             if (isDoubleSpeculation(prediction))
 644                 node-&gt;variableAccessData()-&gt;vote(VoteDouble, weight);
 645             else if (!isFullNumberSpeculation(prediction)
 646                 || isInt32Speculation(prediction) || isAnyIntSpeculation(prediction))
 647                 node-&gt;variableAccessData()-&gt;vote(VoteValue, weight);
 648             break;
 649         }
 650 
 651         case PutByValDirect:
 652         case PutByVal:
 653         case PutByValAlias: {
 654             Edge child1 = m_graph.varArgChild(node, 0);
 655             Edge child2 = m_graph.varArgChild(node, 1);
 656             Edge child3 = m_graph.varArgChild(node, 2);
 657             m_graph.voteNode(child1, VoteValue, weight);
 658             m_graph.voteNode(child2, VoteValue, weight);
 659             switch (node-&gt;arrayMode().type()) {
 660             case Array::Double:
 661                 m_graph.voteNode(child3, VoteDouble, weight);
 662                 break;
 663             default:
 664                 m_graph.voteNode(child3, VoteValue, weight);
 665                 break;
 666             }
 667             break;
 668         }
 669 
 670         case DataViewSet: {
 671             DataViewData data = node-&gt;dataViewData();
 672             if (data.isFloatingPoint)
 673                 m_graph.voteNode(m_graph.varArgChild(node, 2), VoteValue, weight);
 674             break;
 675         }
 676 
 677         case MovHint:
 678             // Ignore these since they have no effect on in-DFG execution.
 679             break;
 680 
 681         default:
 682             m_graph.voteChildren(node, VoteValue, weight);
 683             break;
 684         }
 685     }
 686 
 687     void doRoundOfDoubleVoting()
 688     {
 689         for (unsigned i = 0; i &lt; m_graph.m_variableAccessData.size(); ++i)
 690             m_graph.m_variableAccessData[i].find()-&gt;clearVotes();
 691         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 692             BasicBlock* block = m_graph.block(blockIndex);
 693             if (!block)
 694                 continue;
 695             ASSERT(block-&gt;isReachable);
 696             for (unsigned i = 0; i &lt; block-&gt;size(); ++i) {
 697                 m_currentNode = block-&gt;at(i);
 698                 doDoubleVoting(m_currentNode, block-&gt;executionCount);
 699             }
 700         }
 701         for (unsigned i = 0; i &lt; m_graph.m_variableAccessData.size(); ++i) {
 702             VariableAccessData* variableAccessData = &amp;m_graph.m_variableAccessData[i];
 703             if (!variableAccessData-&gt;isRoot())
 704                 continue;
 705             m_changed |= variableAccessData-&gt;tallyVotesForShouldUseDoubleFormat();
 706         }
 707         propagateThroughArgumentPositions();
 708         for (unsigned i = 0; i &lt; m_graph.m_variableAccessData.size(); ++i) {
 709             VariableAccessData* variableAccessData = &amp;m_graph.m_variableAccessData[i];
 710             if (!variableAccessData-&gt;isRoot())
 711                 continue;
 712             m_changed |= variableAccessData-&gt;makePredictionForDoubleFormat();
 713         }
 714     }
 715 
 716     void propagateThroughArgumentPositions()
 717     {
 718         for (unsigned i = 0; i &lt; m_graph.m_argumentPositions.size(); ++i)
 719             m_changed |= m_graph.m_argumentPositions[i].mergeArgumentPredictionAwareness();
 720     }
 721 
 722     // Sets any predictions that do not depends on other nodes.
 723     void processInvariants()
 724     {
 725         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 726             for (Node* node : *block) {
 727                 m_currentNode = node;
 728                 processInvariantsForNode();
 729             }
 730         }
 731     }
 732 
 733     void processInvariantsForNode()
 734     {
 735         switch (m_currentNode-&gt;op()) {
 736         case JSConstant: {
 737             SpeculatedType type = speculationFromValue(m_currentNode-&gt;asJSValue());
 738             if (type == SpecAnyIntAsDouble &amp;&amp; enableInt52())
 739                 type = SpecInt52Only;
 740             setPrediction(type);
 741             break;
 742         }
 743         case DoubleConstant: {
 744             SpeculatedType type = speculationFromValue(m_currentNode-&gt;asJSValue());
 745             setPrediction(type);
 746             break;
 747         }
 748 
 749         case ArithBitNot:
 750         case ArithBitAnd:
 751         case ArithBitOr:
 752         case ArithBitXor:
 753         case BitRShift:
 754         case BitLShift:
 755         case BitURShift:
 756         case ArithIMul:
 757         case ArithClz32: {
 758             setPrediction(SpecInt32Only);
 759             break;
 760         }
 761 
 762         case ArrayPop:
 763         case ArrayPush:
 764         case RegExpExec:
 765         case RegExpExecNonGlobalOrSticky:
 766         case RegExpTest:
 767         case RegExpMatchFast:
 768         case RegExpMatchFastGlobal:
 769         case StringReplace:
 770         case StringReplaceRegExp:
 771         case GetById:
 772         case GetByIdFlush:
 773         case GetByIdWithThis:
 774         case GetByIdDirect:
 775         case GetByIdDirectFlush:
 776         case TryGetById:
 777         case GetByValWithThis:
 778         case GetByOffset:
 779         case MultiGetByOffset:
 780         case GetDirectPname:
 781         case Call:
 782         case DirectCall:
 783         case TailCallInlinedCaller:
 784         case DirectTailCallInlinedCaller:
 785         case Construct:
 786         case DirectConstruct:
 787         case CallVarargs:
 788         case CallEval:
 789         case TailCallVarargsInlinedCaller:
 790         case ConstructVarargs:
 791         case CallForwardVarargs:
 792         case ConstructForwardVarargs:
 793         case TailCallForwardVarargsInlinedCaller:
 794         case GetGlobalVar:
 795         case GetGlobalLexicalVariable:
 796         case GetClosureVar:
 797         case GetFromArguments:
 798         case LoadKeyFromMapBucket:
 799         case LoadValueFromMapBucket:
 800         case ToNumber:
 801         case ToObject:
 802         case ValueBitAnd:
 803         case ValueBitXor:
 804         case ValueBitOr:
 805         case CallObjectConstructor:
 806         case GetArgument:
 807         case CallDOMGetter:
 808         case GetDynamicVar:
 809         case GetPrototypeOf:
 810         case ExtractValueFromWeakMapGet:
 811         case DataViewGetInt:
 812         case DataViewGetFloat: {
 813             setPrediction(m_currentNode-&gt;getHeapPrediction());
 814             break;
 815         }
 816 
 817         case WeakMapGet:
 818         case ResolveScopeForHoistingFuncDeclInEval: {
 819             setPrediction(SpecBytecodeTop);
 820             break;
 821         }
 822 
 823         case GetGetterSetterByOffset:
 824         case GetExecutable: {
 825             setPrediction(SpecCellOther);
 826             break;
 827         }
 828 
 829         case GetGetter:
 830         case GetSetter:
 831         case GetCallee:
 832         case NewFunction:
 833         case NewGeneratorFunction:
 834         case NewAsyncGeneratorFunction:
 835         case NewAsyncFunction: {
 836             setPrediction(SpecFunction);
 837             break;
 838         }
 839 
 840         case GetArgumentCountIncludingThis: {
 841             setPrediction(SpecInt32Only);
 842             break;
 843         }
 844 
 845         case SetCallee:
 846         case SetArgumentCountIncludingThis:
 847             break;
 848 
 849         case MapHash:
 850             setPrediction(SpecInt32Only);
 851             break;
 852 
 853         case GetMapBucket:
 854         case GetMapBucketHead:
 855         case GetMapBucketNext:
 856         case SetAdd:
 857         case MapSet:
 858             setPrediction(SpecCellOther);
 859             break;
 860 
 861         case GetRestLength:
 862         case ArrayIndexOf: {
 863             setPrediction(SpecInt32Only);
 864             break;
 865         }
 866 
 867         case GetTypedArrayByteOffset:
 868         case GetArrayLength:
 869         case GetVectorLength: {
 870             setPrediction(SpecInt32Only);
 871             break;
 872         }
 873 
 874         case StringCharCodeAt: {
 875             setPrediction(SpecInt32Only);
 876             break;
 877         }
 878 
 879         case StringValueOf:
 880         case StringSlice:
 881         case ToLowerCase:
 882             setPrediction(SpecString);
 883             break;
 884 
 885         case ArithPow:
 886         case ArithSqrt:
 887         case ArithFRound:
 888         case ArithUnary: {
 889             setPrediction(SpecBytecodeDouble);
 890             break;
 891         }
 892 
 893         case ArithRound:
 894         case ArithFloor:
 895         case ArithCeil:
 896         case ArithTrunc: {
 897             if (isInt32OrBooleanSpeculation(m_currentNode-&gt;getHeapPrediction())
 898                 &amp;&amp; m_graph.roundShouldSpeculateInt32(m_currentNode, m_pass))
 899                 setPrediction(SpecInt32Only);
 900             else
 901                 setPrediction(SpecBytecodeDouble);
 902             break;
 903         }
 904 
 905         case ArithRandom: {
 906             setPrediction(SpecDoubleReal);
 907             break;
 908         }
 909         case DeleteByVal:
 910         case DeleteById:
 911         case LogicalNot:
 912         case CompareLess:
 913         case CompareLessEq:
 914         case CompareGreater:
 915         case CompareGreaterEq:
 916         case CompareBelow:
 917         case CompareBelowEq:
 918         case CompareEq:
 919         case CompareStrictEq:
 920         case CompareEqPtr:
 921         case SameValue:
 922         case OverridesHasInstance:
 923         case InstanceOf:
 924         case InstanceOfCustom:
 925         case IsEmpty:
 926         case IsUndefined:
 927         case IsUndefinedOrNull:
 928         case IsBoolean:
 929         case IsNumber:
 930         case NumberIsInteger:
 931         case IsObject:
 932         case IsObjectOrNull:
 933         case IsFunction:
 934         case IsCellWithType:
 935         case IsTypedArrayView:
 936         case MatchStructure: {
 937             setPrediction(SpecBoolean);
 938             break;
 939         }
 940 
 941         case TypeOf: {
 942             setPrediction(SpecStringIdent);
 943             break;
 944         }
 945         case GetButterfly:
 946         case GetIndexedPropertyStorage:
 947         case AllocatePropertyStorage:
 948         case ReallocatePropertyStorage: {
 949             setPrediction(SpecOther);
 950             break;
 951         }
 952 
 953         case CheckSubClass:
 954             break;
 955 
 956         case SkipScope:
 957         case GetGlobalObject: {
 958             setPrediction(SpecObjectOther);
 959             break;
 960         }
 961 
 962         case GetGlobalThis:
 963             setPrediction(SpecObject);
 964             break;
 965 
 966         case ResolveScope: {
 967             setPrediction(SpecObjectOther);
 968             break;
 969         }
 970 
 971         case ObjectCreate:
 972         case CreateThis:
 973         case NewObject: {
 974             setPrediction(SpecFinalObject);
 975             break;
 976         }
 977 
 978         case ArraySlice:
 979         case NewArrayWithSpread:
 980         case NewArray:
 981         case NewArrayWithSize:
 982         case CreateRest:
 983         case NewArrayBuffer:
 984         case ObjectKeys: {
 985             setPrediction(SpecArray);
 986             break;
 987         }
 988 
 989         case Spread:
 990             setPrediction(SpecCellOther);
 991             break;
 992 
 993         case NewTypedArray: {
 994             setPrediction(speculationFromTypedArrayType(m_currentNode-&gt;typedArrayType()));
 995             break;
 996         }
 997 
 998         case NewRegexp: {
 999             setPrediction(SpecRegExpObject);
1000             break;
1001         }
1002 
1003         case PushWithScope:
1004         case CreateActivation: {
1005             setPrediction(SpecObjectOther);
1006             break;
1007         }
1008 
1009         case StringFromCharCode: {
1010             setPrediction(SpecString);
1011             m_currentNode-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsInt);
1012             break;
1013         }
1014         case StringCharAt:
1015         case CallStringConstructor:
1016         case ToString:
1017         case NumberToStringWithRadix:
1018         case NumberToStringWithValidRadixConstant:
1019         case MakeRope:
1020         case StrCat: {
1021             setPrediction(SpecString);
1022             break;
1023         }
1024         case NewStringObject: {
1025             setPrediction(SpecStringObject);
1026             break;
1027         }
1028         case NewSymbol: {
1029             setPrediction(SpecSymbol);
1030             break;
1031         }
1032 
1033         case CreateDirectArguments: {
1034             setPrediction(SpecDirectArguments);
1035             break;
1036         }
1037 
1038         case CreateScopedArguments: {
1039             setPrediction(SpecScopedArguments);
1040             break;
1041         }
1042 
1043         case CreateClonedArguments: {
1044             setPrediction(SpecObjectOther);
1045             break;
1046         }
1047 
1048         case FiatInt52: {
1049             RELEASE_ASSERT(enableInt52());
1050             setPrediction(SpecAnyInt);
1051             break;
1052         }
1053 
1054         case GetScope:
1055             setPrediction(SpecObjectOther);
1056             break;
1057 
1058         case InByVal:
1059         case InById:
1060             setPrediction(SpecBoolean);
1061             break;
1062 
1063         case HasOwnProperty:
1064             setPrediction(SpecBoolean);
1065             break;
1066 
1067         case GetEnumerableLength: {
1068             setPrediction(SpecInt32Only);
1069             break;
1070         }
1071         case HasGenericProperty:
1072         case HasStructureProperty:
1073         case HasIndexedProperty: {
1074             setPrediction(SpecBoolean);
1075             break;
1076         }
1077         case GetPropertyEnumerator: {
1078             setPrediction(SpecCell);
1079             break;
1080         }
1081         case GetEnumeratorStructurePname: {
1082             setPrediction(SpecCell | SpecOther);
1083             break;
1084         }
1085         case GetEnumeratorGenericPname: {
1086             setPrediction(SpecCell | SpecOther);
1087             break;
1088         }
1089         case ToIndexString: {
1090             setPrediction(SpecString);
1091             break;
1092         }
1093         case ParseInt: {
1094             // We expect this node to almost always produce an int32. However,
1095             // it&#39;s possible it produces NaN or integers out of int32 range. We
1096             // rely on the heap prediction since the parseInt() call profiled
1097             // its result.
1098             setPrediction(m_currentNode-&gt;getHeapPrediction());
1099             break;
1100         }
1101 
1102         case IdentityWithProfile: {
1103             setPrediction(m_currentNode-&gt;getForcedPrediction());
1104             break;
1105         }
1106 
1107         case ExtractCatchLocal: {
1108             setPrediction(m_currentNode-&gt;catchLocalPrediction());
1109             break;
1110         }
1111 
1112         case GetLocal:
1113         case SetLocal:
1114         case UInt32ToNumber:
1115         case ValueNegate:
1116         case ValueAdd:
1117         case ValueSub:
1118         case ValueMul:
1119         case ValueDiv:
1120         case ArithAdd:
1121         case ArithSub:
1122         case ArithNegate:
1123         case ArithMin:
1124         case ArithMax:
1125         case ArithMul:
1126         case ArithDiv:
1127         case ArithMod:
1128         case ArithAbs:
1129         case GetByVal:
1130         case ToThis:
1131         case ToPrimitive:
1132         case NormalizeMapKey:
1133         case AtomicsAdd:
1134         case AtomicsAnd:
1135         case AtomicsCompareExchange:
1136         case AtomicsExchange:
1137         case AtomicsLoad:
1138         case AtomicsOr:
1139         case AtomicsStore:
1140         case AtomicsSub:
1141         case AtomicsXor: {
1142             m_dependentNodes.append(m_currentNode);
1143             break;
1144         }
1145 
1146         case AtomicsIsLockFree: {
1147             setPrediction(SpecBoolean);
1148             break;
1149         }
1150 
1151         case CPUIntrinsic: {
1152             if (m_currentNode-&gt;intrinsic() == CPURdtscIntrinsic)
1153                 setPrediction(SpecInt32Only);
1154             else
1155                 setPrediction(SpecOther);
1156             break;
1157         }
1158 
1159         case PutByValAlias:
1160         case DoubleAsInt32:
1161         case CheckArray:
1162         case CheckTypeInfoFlags:
1163         case Arrayify:
1164         case ArrayifyToStructure:
1165         case CheckTierUpInLoop:
1166         case CheckTierUpAtReturn:
1167         case CheckTierUpAndOSREnter:
1168         case CheckInBounds:
1169         case ValueToInt32:
1170         case DoubleRep:
1171         case ValueRep:
1172         case Int52Rep:
1173         case Int52Constant:
1174         case Identity:
1175         case BooleanToNumber:
1176         case PhantomNewObject:
1177         case PhantomNewFunction:
1178         case PhantomNewGeneratorFunction:
1179         case PhantomNewAsyncGeneratorFunction:
1180         case PhantomNewAsyncFunction:
1181         case PhantomCreateActivation:
1182         case PhantomDirectArguments:
1183         case PhantomCreateRest:
1184         case PhantomSpread:
1185         case PhantomNewArrayWithSpread:
1186         case PhantomNewArrayBuffer:
1187         case PhantomClonedArguments:
1188         case PhantomNewRegexp:
1189         case GetMyArgumentByVal:
1190         case GetMyArgumentByValOutOfBounds:
1191         case PutHint:
1192         case CheckStructureImmediate:
1193         case CheckStructureOrEmpty:
1194         case MaterializeNewObject:
1195         case MaterializeCreateActivation:
1196         case PutStack:
1197         case KillStack:
1198         case StoreBarrier:
1199         case FencedStoreBarrier:
1200         case GetStack:
1201         case GetRegExpObjectLastIndex:
1202         case SetRegExpObjectLastIndex:
1203         case RecordRegExpCachedResult:
1204         case LazyJSConstant:
1205         case CallDOM: {
1206             // This node should never be visible at this stage of compilation.
1207             DFG_CRASH(m_graph, m_currentNode, &quot;Unexpected node during prediction propagation&quot;);
1208             break;
1209         }
1210 
1211         case Phi:
1212             // Phis should not be visible here since we&#39;re iterating the all-but-Phi&#39;s
1213             // part of basic blocks.
1214             RELEASE_ASSERT_NOT_REACHED();
1215             break;
1216 
1217         case EntrySwitch:
1218         case Upsilon:
1219             // These don&#39;t get inserted until we go into SSA.
1220             RELEASE_ASSERT_NOT_REACHED();
1221             break;
1222 
1223 #ifndef NDEBUG
1224         // These get ignored because they don&#39;t return anything.
1225         case PutByValDirect:
1226         case PutByValWithThis:
1227         case PutByIdWithThis:
1228         case PutByVal:
1229         case PutClosureVar:
1230         case PutToArguments:
1231         case Return:
1232         case Throw:
1233         case ThrowStaticError:
1234         case TailCall:
1235         case DirectTailCall:
1236         case TailCallVarargs:
1237         case TailCallForwardVarargs:
1238         case PutById:
1239         case PutByIdFlush:
1240         case PutByIdDirect:
1241         case PutByOffset:
1242         case MultiPutByOffset:
1243         case PutGetterById:
1244         case PutSetterById:
1245         case PutGetterSetterById:
1246         case PutGetterByVal:
1247         case PutSetterByVal:
1248         case DefineDataProperty:
1249         case DefineAccessorProperty:
1250         case DFG::Jump:
1251         case Branch:
1252         case Switch:
1253         case ProfileType:
1254         case ProfileControlFlow:
1255         case ForceOSRExit:
1256         case SetArgument:
1257         case SetFunctionName:
1258         case CheckStructure:
1259         case CheckCell:
1260         case CheckNotEmpty:
1261         case AssertNotEmpty:
1262         case CheckStringIdent:
1263         case CheckBadCell:
1264         case PutStructure:
1265         case Phantom:
1266         case Check:
1267         case CheckVarargs:
1268         case PutGlobalVariable:
1269         case CheckTraps:
1270         case LogShadowChickenPrologue:
1271         case LogShadowChickenTail:
1272         case Unreachable:
1273         case LoopHint:
1274         case NotifyWrite:
1275         case ConstantStoragePointer:
1276         case MovHint:
1277         case ZombieHint:
1278         case ExitOK:
1279         case LoadVarargs:
1280         case ForwardVarargs:
1281         case PutDynamicVar:
1282         case NukeStructureAndSetButterfly:
1283         case InitializeEntrypointArguments:
1284         case WeakSetAdd:
1285         case WeakMapSet:
1286         case FilterCallLinkStatus:
1287         case FilterGetByIdStatus:
1288         case FilterPutByIdStatus:
1289         case FilterInByIdStatus:
1290         case ClearCatchLocals:
1291         case DataViewSet:
1292         case InvalidationPoint:
1293             break;
1294 
1295         // This gets ignored because it only pretends to produce a value.
1296         case BottomValue:
1297             break;
1298 
1299         // This gets ignored because it already has a prediction.
1300         case ExtractOSREntryLocal:
1301             break;
1302 
1303         // These gets ignored because it doesn&#39;t do anything.
1304         case CountExecution:
1305         case SuperSamplerBegin:
1306         case SuperSamplerEnd:
1307         case PhantomLocal:
1308         case Flush:
1309             break;
1310 
1311         case LastNodeType:
1312             RELEASE_ASSERT_NOT_REACHED();
1313             break;
1314 #else
1315         default:
1316             break;
1317 #endif
1318         }
1319     }
1320 
1321     SpeculatedType resultOfToPrimitive(SpeculatedType type)
1322     {
1323         if (type &amp; SpecObject) {
1324             // We try to be optimistic here about StringObjects since it&#39;s unlikely that
1325             // someone overrides the valueOf or toString methods.
1326             if (type &amp; SpecStringObject &amp;&amp; m_graph.canOptimizeStringObjectAccess(m_currentNode-&gt;origin.semantic))
1327                 return mergeSpeculations(type &amp; ~SpecObject, SpecString);
1328 
1329             return mergeSpeculations(type &amp; ~SpecObject, SpecPrimitive);
1330         }
1331 
1332         return type;
1333     }
1334 
1335     Vector&lt;Node*&gt; m_dependentNodes;
1336     Node* m_currentNode;
1337     bool m_changed { false };
1338     PredictionPass m_pass { PrimaryPass }; // We use different logic for considering predictions depending on how far along we are in propagation.
1339 };
1340 
1341 } // Anonymous namespace.
1342 
1343 bool performPredictionPropagation(Graph&amp; graph)
1344 {
1345     return runPhase&lt;PredictionPropagationPhase&gt;(graph);
1346 }
1347 
1348 } } // namespace JSC::DFG
1349 
1350 #endif // ENABLE(DFG_JIT)
1351 
    </pre>
  </body>
</html>