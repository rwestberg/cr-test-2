<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DirectArguments.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DirectArguments.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DirectEvalExecutable.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DirectArguments.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 84,11 ***</span>
          return m_length;
      }
  
      bool isMappedArgument(uint32_t i) const
      {
<span class="line-modified">!         return i &lt; m_length &amp;&amp; (!m_mappedArguments || !m_mappedArguments[i]);</span>
      }
  
      bool isMappedArgumentInDFG(uint32_t i) const
      {
          return i &lt; m_length &amp;&amp; !overrodeThings();
<span class="line-new-header">--- 84,11 ---</span>
          return m_length;
      }
  
      bool isMappedArgument(uint32_t i) const
      {
<span class="line-modified">!         return i &lt; m_length &amp;&amp; (!m_mappedArguments || !m_mappedArguments.at(i, m_length));</span>
      }
  
      bool isMappedArgumentInDFG(uint32_t i) const
      {
          return i &lt; m_length &amp;&amp; !overrodeThings();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,9 ***</span>
      unsigned mappedArgumentsSize();
  
      WriteBarrier&lt;JSFunction&gt; m_callee;
      uint32_t m_length; // Always the actual length of captured arguments and never what was stored into the length property.
      uint32_t m_minCapacity; // The max of this and length determines the capacity of this object. It may be the actual capacity, or maybe something smaller. We arrange it this way to be kind to the JITs.
<span class="line-modified">!     CagedBarrierPtr&lt;Gigacage::Primitive, bool&gt; m_mappedArguments; // If non-null, it means that length, callee, and caller are fully materialized properties.</span>
  };
  
  } // namespace JSC
<span class="line-new-header">--- 180,10 ---</span>
      unsigned mappedArgumentsSize();
  
      WriteBarrier&lt;JSFunction&gt; m_callee;
      uint32_t m_length; // Always the actual length of captured arguments and never what was stored into the length property.
      uint32_t m_minCapacity; // The max of this and length determines the capacity of this object. It may be the actual capacity, or maybe something smaller. We arrange it this way to be kind to the JITs.
<span class="line-modified">!     using MappedArguments = CagedBarrierPtr&lt;Gigacage::Primitive, bool&gt;;</span>
<span class="line-added">+     MappedArguments m_mappedArguments; // If non-null, it means that length, callee, and caller are fully materialized properties.</span>
  };
  
  } // namespace JSC
</pre>
<center><a href="DirectArguments.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DirectEvalExecutable.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>