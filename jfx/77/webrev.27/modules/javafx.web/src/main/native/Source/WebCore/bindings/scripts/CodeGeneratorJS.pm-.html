<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 #
   2 # Copyright (C) 2005, 2006, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
   3 # Copyright (C) 2006 Anders Carlsson &lt;andersca@mac.com&gt;
   4 # Copyright (C) 2006, 2007 Samuel Weinig &lt;sam@webkit.org&gt;
   5 # Copyright (C) 2006 Alexey Proskuryakov &lt;ap@webkit.org&gt;
   6 # Copyright (C) 2006-2019 Apple Inc. All rights reserved.
   7 # Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
   8 # Copyright (C) Research In Motion Limited 2010. All rights reserved.
   9 # Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  10 # Copyright (C) 2011 Patrick Gansterer &lt;paroga@webkit.org&gt;
  11 # Copyright (C) 2012 Ericsson AB. All rights reserved.
  12 # Copyright (C) 2007, 2008, 2009, 2012 Google Inc.
  13 # Copyright (C) 2013 Samsung Electronics. All rights reserved.
  14 # Copyright (C) 2015, 2016 Canon Inc. All rights reserved.
  15 #
  16 # This library is free software; you can redistribute it and/or
  17 # modify it under the terms of the GNU Library General Public
  18 # License as published by the Free Software Foundation; either
  19 # version 2 of the License, or (at your option) any later version.
  20 #
  21 # This library is distributed in the hope that it will be useful,
  22 # but WITHOUT ANY WARRANTY; without even the implied warranty of
  23 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  24 # Library General Public License for more details.
  25 #
  26 # You should have received a copy of the GNU Library General Public License
  27 # along with this library; see the file COPYING.LIB.  If not, write to
  28 # the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  29 # Boston, MA 02110-1301, USA.
  30 
  31 
  32 package CodeGeneratorJS;
  33 
  34 use strict;
  35 use constant FileNamePrefix =&gt; &quot;JS&quot;;
  36 use Carp qw&lt;longmess&gt;;
  37 use Data::Dumper;
  38 use Hasher;
  39 
  40 my $codeGenerator;
  41 my $writeDependencies;
  42 
  43 my @headerContentHeader = ();
  44 my @headerContent = ();
  45 my %headerIncludes = ();
  46 my %headerTrailingIncludes = ();
  47 
  48 my @implContentHeader = ();
  49 my @implContent = ();
  50 my %implIncludes = ();
  51 my @depsContent = ();
  52 my $numCachedAttributes = 0;
  53 
  54 my $beginAppleCopyrightForHeaderFiles = &lt;&lt;END;
  55 // ------- Begin Apple Copyright -------
  56 /*
  57  * Copyright (C) 2008 Apple Inc. All rights reserved.
  58  *
  59  * Permission is granted by Apple to use this file to the extent
  60  * necessary to relink with LGPL WebKit files.
  61  *
  62  * No license or rights are granted by Apple expressly or by
  63  * implication, estoppel, or otherwise, to Apple patents and
  64  * trademarks. For the sake of clarity, no license or rights are
  65  * granted by Apple expressly or by implication, estoppel, or otherwise,
  66  * under any Apple patents, copyrights and trademarks to underlying
  67  * implementations of any application programming interfaces (APIs)
  68  * or to any functionality that is invoked by calling any API.
  69  */
  70 
  71 END
  72 my $beginAppleCopyrightForSourceFiles = &lt;&lt;END;
  73 // ------- Begin Apple Copyright -------
  74 /*
  75  * Copyright (C) 2008 Apple Inc. All rights reserved.
  76  *
  77  * No license or rights are granted by Apple expressly or by implication,
  78  * estoppel, or otherwise, to Apple copyrights, patents, trademarks, trade
  79  * secrets or other rights.
  80  */
  81 
  82 END
  83 my $endAppleCopyright   = &lt;&lt;END;
  84 // ------- End Apple Copyright   -------
  85 
  86 END
  87 
  88 # Default .h template
  89 my $headerTemplate = &lt;&lt; &quot;EOF&quot;;
  90 /*
  91     This file is part of the WebKit open source project.
  92     This file has been generated by generate-bindings.pl. DO NOT MODIFY!
  93 
  94     This library is free software; you can redistribute it and/or
  95     modify it under the terms of the GNU Library General Public
  96     License as published by the Free Software Foundation; either
  97     version 2 of the License, or (at your option) any later version.
  98 
  99     This library is distributed in the hope that it will be useful,
 100     but WITHOUT ANY WARRANTY; without even the implied warranty of
 101     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 102     Library General Public License for more details.
 103 
 104     You should have received a copy of the GNU Library General Public License
 105     along with this library; see the file COPYING.LIB.  If not, write to
 106     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 107     Boston, MA 02110-1301, USA.
 108 */
 109 EOF
 110 
 111 sub assert
 112 {
 113     my $message = shift;
 114 
 115     my $mess = longmess();
 116     print Dumper($mess);
 117 
 118     die $message;
 119 }
 120 
 121 # Default constructor
 122 sub new
 123 {
 124     my $object = shift;
 125     my $reference = { };
 126 
 127     $codeGenerator = shift;
 128     $writeDependencies = shift;
 129 
 130     bless($reference, $object);
 131     return $reference;
 132 }
 133 
 134 sub GenerateEnumeration
 135 {
 136     my ($object, $enumeration) = @_;
 137 
 138     my $className = GetEnumerationClassName($enumeration-&gt;type);
 139     $object-&gt;GenerateEnumerationHeader($enumeration, $className);
 140     $object-&gt;GenerateEnumerationImplementation($enumeration, $className);
 141 }
 142 
 143 sub GenerateDictionary
 144 {
 145     my ($object, $dictionary, $enumerations, $otherDictionaries) = @_;
 146 
 147     my $className = GetDictionaryClassName($dictionary-&gt;type);
 148     $object-&gt;GenerateDictionaryHeader($dictionary, $className, $enumerations, $otherDictionaries);
 149     $object-&gt;GenerateDictionaryImplementation($dictionary, $className, $enumerations, $otherDictionaries);
 150 }
 151 
 152 sub GenerateCallbackFunction
 153 {
 154     my ($object, $callbackFunction, $enumerations, $dictionaries) = @_;
 155 
 156     $object-&gt;GenerateCallbackFunctionHeader($callbackFunction, $enumerations, $dictionaries);
 157     $object-&gt;GenerateCallbackFunctionImplementation($callbackFunction, $enumerations, $dictionaries);
 158 }
 159 
 160 sub GenerateInterface
 161 {
 162     my ($object, $interface, $defines, $enumerations, $dictionaries) = @_;
 163 
 164     $codeGenerator-&gt;LinkOverloadedOperations($interface);
 165 
 166     AddStringifierOperationIfNeeded($interface);
 167     AddLegacyCallerOperationIfNeeded($interface);
 168 
 169     if ($interface-&gt;isCallback) {
 170         $object-&gt;GenerateCallbackInterfaceHeader($interface, $enumerations, $dictionaries);
 171         $object-&gt;GenerateCallbackInterfaceImplementation($interface, $enumerations, $dictionaries);
 172     } else {
 173         $object-&gt;GenerateHeader($interface, $enumerations, $dictionaries);
 174         $object-&gt;GenerateImplementation($interface, $enumerations, $dictionaries);
 175     }
 176 }
 177 
 178 sub AddStringifierOperationIfNeeded
 179 {
 180     my $interface = shift;
 181 
 182     foreach my $property (@{$interface-&gt;attributes}, @{$interface-&gt;operations}, @{$interface-&gt;anonymousOperations}) {
 183         next unless $property-&gt;isStringifier;
 184 
 185         if (ref($property) eq &quot;IDLAttribute&quot;) {
 186             assert(&quot;stringifier can only be used on attributes with type DOMString or USVString&quot;) unless $property-&gt;type-&gt;name eq &quot;DOMString&quot; || $property-&gt;type-&gt;name eq &quot;USVString&quot;;
 187         }
 188 
 189         if (ref($property) eq &quot;IDLOperation&quot;) {
 190             assert(&quot;stringifier can only be used on operations with a return type of DOMString&quot;) unless $property-&gt;type-&gt;name eq &quot;DOMString&quot;;
 191             assert(&quot;stringifier can only be used on operations with zero arguments&quot;) unless scalar(@{$property-&gt;arguments}) == 0;
 192 
 193             # Don&#39;t duplicate the operation if it was declared with the name &#39;toString&#39;.
 194             return if $property-&gt;name eq &quot;toString&quot;;
 195         }
 196 
 197         my $stringifier = IDLOperation-&gt;new();
 198         $stringifier-&gt;name(&quot;toString&quot;);
 199         $stringifier-&gt;type(IDLParser::cloneType($property-&gt;type));
 200         $stringifier-&gt;isStringifier(1);
 201 
 202         IDLParser::copyExtendedAttributes($stringifier-&gt;extendedAttributes, $property-&gt;extendedAttributes);
 203 
 204         if ($property-&gt;name &amp;&amp; !$stringifier-&gt;extendedAttributes-&gt;{ImplementedAs}) {
 205             $stringifier-&gt;extendedAttributes-&gt;{ImplementedAs} = $property-&gt;name;
 206         }
 207 
 208         # If the stringifier was declared as read-write attribute and had [CEReactions], we need to remove
 209         # it from the operation, as the operation should act like attribute getter, which doesn&#39;t respect
 210         # [CEReactions].
 211         if (ref($property) eq &quot;IDLAttribute&quot; &amp;&amp; !$property-&gt;isReadOnly &amp;&amp; $stringifier-&gt;extendedAttributes-&gt;{CEReactions}) {
 212              delete $stringifier-&gt;extendedAttributes-&gt;{CEReactions};
 213         }
 214 
 215         push(@{$interface-&gt;operations}, $stringifier);
 216         return;
 217     }
 218 }
 219 
 220 sub AddLegacyCallerOperationIfNeeded
 221 {
 222     my $interface = shift;
 223 
 224     foreach my $operation (@{$interface-&gt;operations}, @{$interface-&gt;anonymousOperations}) {
 225         my $isLegacyCaller = grep { $_ eq &quot;legacycaller&quot; } @{$operation-&gt;specials};
 226         if ($isLegacyCaller) {
 227             $interface-&gt;{LegacyCallers} = [] if !exists $interface-&gt;{LegacyCallers};
 228 
 229             my $clonedOperation = IDLParser::cloneOperation($operation);
 230             push(@{$interface-&gt;{LegacyCallers}}, $clonedOperation);
 231     
 232             $clonedOperation-&gt;{overloads} = $interface-&gt;{LegacyCallers};
 233             $clonedOperation-&gt;{overloadIndex} = @{$interface-&gt;{LegacyCallers}};
 234         }
 235     }
 236 }
 237 
 238 sub EventHandlerAttributeEventName
 239 {
 240     my $attribute = shift;
 241     my $eventType = $attribute-&gt;extendedAttributes-&gt;{ImplementedAs} || $attribute-&gt;name;
 242 
 243     # Remove the &quot;on&quot; prefix.
 244     $eventType = substr($eventType, 2);
 245 
 246     return &quot;eventNames().${eventType}Event&quot;;
 247 }
 248 
 249 sub GetParentClassName
 250 {
 251     my $interface = shift;
 252 
 253     return $interface-&gt;extendedAttributes-&gt;{JSLegacyParent} if $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
 254     return &quot;JSDOMObject&quot; unless NeedsImplementationClass($interface);
 255     return &quot;JSDOMWrapper&lt;&quot; . GetImplClassName($interface) . &quot;&gt;&quot; unless $interface-&gt;parentType;
 256     return &quot;JS&quot; . $interface-&gt;parentType-&gt;name;
 257 }
 258 
 259 sub GetCallbackClassName
 260 {
 261     my $className = shift;
 262 
 263     return &quot;JS$className&quot;;
 264 }
 265 
 266 sub GetExportMacroForJSClass
 267 {
 268     my $interface = shift;
 269 
 270     return $interface-&gt;extendedAttributes-&gt;{ExportMacro} . &quot; &quot; if $interface-&gt;extendedAttributes-&gt;{ExportMacro};
 271     return &quot;&quot;;
 272 }
 273 
 274 sub AddIncludesForImplementationTypeInImpl
 275 {
 276     my $implementationType = shift;
 277     
 278     AddIncludesForImplementationType($implementationType, \%implIncludes);
 279 }
 280 
 281 sub AddIncludesForImplementationTypeInHeader
 282 {
 283     my $implementationType = shift;
 284     
 285     AddIncludesForImplementationType($implementationType, \%headerIncludes);
 286 }
 287 
 288 sub AddIncludesForImplementationType
 289 {
 290     my ($implementationType, $includesRef) = @_;
 291 
 292     $includesRef-&gt;{&quot;${implementationType}.h&quot;} = 1;
 293 }
 294 
 295 sub AddToImplIncludesForIDLType
 296 {
 297     my ($type, $conditional) = @_;
 298 
 299     return AddToIncludesForIDLType($type, \%implIncludes, $conditional)
 300 }
 301 
 302 sub AddToIncludesForIDLType
 303 {
 304     my ($type, $includesRef, $conditional) = @_;
 305 
 306     if ($type-&gt;isNullable) {
 307         AddToIncludes(&quot;JSDOMConvertNullable.h&quot;, $includesRef, $conditional);
 308     }
 309 
 310     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
 311         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
 312         if ($overrideTypeName eq &quot;IDLIDBKey&quot;) {
 313             AddToIncludes(&quot;JSDOMConvertIndexedDB.h&quot;, $includesRef, $conditional);
 314             return;
 315         }
 316 
 317         if ($overrideTypeName eq &quot;IDLWebGLAny&quot; || $overrideTypeName eq &quot;IDLWebGLExtension&quot;) {
 318             AddToIncludes(&quot;JSDOMConvertWebGL.h&quot;, $includesRef, $conditional);
 319             return;
 320         }
 321     }
 322 
 323     if ($type-&gt;name eq &quot;any&quot;) {
 324         AddToIncludes(&quot;JSDOMConvertAny.h&quot;, $includesRef, $conditional);
 325         return;
 326     }
 327 
 328     if ($type-&gt;name eq &quot;boolean&quot;) {
 329         AddToIncludes(&quot;JSDOMConvertBoolean.h&quot;, $includesRef, $conditional);
 330         return;
 331     }
 332 
 333     if ($codeGenerator-&gt;IsBufferSourceType($type)) {
 334         AddToIncludes(&quot;JSDOMConvertBufferSource.h&quot;, $includesRef, $conditional);
 335         return;
 336     }
 337 
 338     if ($codeGenerator-&gt;IsCallbackFunction($type) || $codeGenerator-&gt;IsCallbackInterface($type)) {
 339         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 340         AddToIncludes(&quot;JSDOMConvertCallbacks.h&quot;, $includesRef, $conditional);
 341         return;
 342     }
 343 
 344     if ($type-&gt;name eq &quot;Date&quot;) {
 345         AddToIncludes(&quot;JSDOMConvertDate.h&quot;, $includesRef, $conditional);
 346         return;
 347     }
 348 
 349     if ($codeGenerator-&gt;IsExternalDictionaryType($type)) {
 350         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 351         AddToIncludes(&quot;JSDOMConvertDictionary.h&quot;, $includesRef, $conditional);
 352         return;
 353     }
 354 
 355     if ($codeGenerator-&gt;IsExternalEnumType($type)) {
 356         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 357         AddToIncludes(&quot;JSDOMConvertEnumeration.h&quot;, $includesRef, $conditional);
 358         return;
 359     }
 360 
 361     if ($type-&gt;name eq &quot;EventListener&quot;) {
 362         AddToIncludes(&quot;JSEventListener.h&quot;, $includesRef, $conditional);
 363         AddToIncludes(&quot;JSDOMConvertEventListener.h&quot;, $includesRef, $conditional);
 364         return;
 365     }
 366 
 367     if ($codeGenerator-&gt;IsInterfaceType($type)) {
 368         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 369         AddToIncludes(&quot;JSDOMConvertInterface.h&quot;, $includesRef, $conditional);
 370         return;
 371     }
 372 
 373     if ($type-&gt;name eq &quot;JSON&quot;) {
 374         AddToIncludes(&quot;JSDOMConvertJSON.h&quot;, $includesRef, $conditional);
 375         return;
 376     }
 377 
 378     if ($codeGenerator-&gt;IsNumericType($type)) {
 379         AddToIncludes(&quot;JSDOMConvertNumbers.h&quot;, $includesRef, $conditional);
 380         return;
 381     }
 382 
 383     if ($type-&gt;name eq &quot;object&quot;) {
 384         AddToIncludes(&quot;JSDOMConvertObject.h&quot;, $includesRef, $conditional);
 385         return;
 386     }
 387 
 388     if ($codeGenerator-&gt;IsPromiseType($type)) {
 389         AddToIncludes(&quot;DOMPromiseProxy.h&quot;, $includesRef, $conditional);
 390         AddToIncludes(&quot;JSDOMConvertPromise.h&quot;, $includesRef, $conditional);
 391 
 392         AddToIncludesForIDLType(@{$type-&gt;subtypes}[0], $includesRef, $conditional);
 393         return;
 394     }
 395 
 396     if ($codeGenerator-&gt;IsRecordType($type)) {
 397         AddToIncludes(&quot;&lt;wtf/Vector.h&gt;&quot;, $includesRef, $conditional);
 398         AddToIncludes(&quot;JSDOMConvertRecord.h&quot;, $includesRef, $conditional);
 399 
 400         AddToIncludesForIDLType(@{$type-&gt;subtypes}[0], $includesRef, $conditional);
 401         AddToIncludesForIDLType(@{$type-&gt;subtypes}[1], $includesRef, $conditional);
 402         return;
 403     }
 404 
 405     if ($codeGenerator-&gt;IsSequenceOrFrozenArrayType($type)) {
 406         AddToIncludes(&quot;&lt;JavaScriptCore/JSArray.h&gt;&quot;, $includesRef, $conditional);
 407         AddToIncludes(&quot;JSDOMConvertSequences.h&quot;, $includesRef, $conditional);
 408 
 409         AddToIncludesForIDLType(@{$type-&gt;subtypes}[0], $includesRef, $conditional);
 410         return;
 411     }
 412 
 413     if ($type-&gt;name eq &quot;ScheduledAction&quot;) {
 414         AddToIncludes(&quot;JSDOMConvertScheduledAction.h&quot;, $includesRef, $conditional);
 415         return;
 416     }
 417 
 418     if ($type-&gt;name eq &quot;SerializedScriptValue&quot;) {
 419         AddToIncludes(&quot;SerializedScriptValue.h&quot;, $includesRef, $conditional);
 420         AddToIncludes(&quot;JSDOMConvertSerializedScriptValue.h&quot;, $includesRef, $conditional);
 421         return;
 422     }
 423 
 424     if ($codeGenerator-&gt;IsStringType($type)) {
 425         AddToIncludes(&quot;JSDOMConvertStrings.h&quot;, $includesRef, $conditional);
 426         return;
 427     }
 428 
 429     if ($type-&gt;isUnion) {
 430         AddToIncludes(&quot;&lt;wtf/Variant.h&gt;&quot;, $includesRef, $conditional);
 431         AddToIncludes(&quot;JSDOMConvertUnion.h&quot;, $includesRef, $conditional);
 432 
 433         foreach my $memberType (@{$type-&gt;subtypes}) {
 434             AddToIncludesForIDLType($memberType, $includesRef, $conditional);
 435         }
 436 
 437         return;
 438     }
 439 
 440     if ($type-&gt;name eq &quot;XPathNSResolver&quot;) {
 441         AddToIncludes(&quot;JSXPathNSResolver.h&quot;, $includesRef, $conditional);
 442         AddToIncludes(&quot;JSDOMConvertXPathNSResolver.h&quot;, $includesRef, $conditional);
 443         return;
 444     }
 445 }
 446 
 447 sub AddToImplIncludes
 448 {
 449     my ($header, $conditional) = @_;
 450 
 451     AddToIncludes($header, \%implIncludes, $conditional);
 452 }
 453 
 454 sub AddToIncludes
 455 {
 456     my ($header, $includesRef, $conditional) = @_;
 457 
 458     if (not $conditional) {
 459         $includesRef-&gt;{$header} = 1;
 460     } elsif (not exists($includesRef-&gt;{$header})) {
 461         $includesRef-&gt;{$header} = $conditional;
 462     } else {
 463         my $oldValue = $includesRef-&gt;{$header};
 464         $includesRef-&gt;{$header} = &quot;$oldValue|$conditional&quot; if $oldValue ne 1;
 465     }
 466 }
 467 
 468 sub IsReadonly
 469 {
 470     my $attribute = shift;
 471     return $attribute-&gt;isReadOnly &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{Replaceable} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{PutForwards};
 472 }
 473 
 474 sub AddClassForwardIfNeeded
 475 {
 476     my $type = shift;
 477 
 478     # SVGAnimatedLength/Number/etc. are not classes so they can&#39;t be forward declared as classes.
 479     return if $codeGenerator-&gt;IsSVGAnimatedType($type);
 480     return if $codeGenerator-&gt;IsBufferSourceType($type);
 481 
 482     push(@headerContent, &quot;class &quot; . $type-&gt;name . &quot;;\n\n&quot;);
 483 }
 484 
 485 sub GetGenerateIsReachable
 486 {
 487     my $interface = shift;
 488     return $interface-&gt;extendedAttributes-&gt;{GenerateIsReachable};
 489 }
 490 
 491 sub GetCustomIsReachable
 492 {
 493     my $interface = shift;
 494     return $interface-&gt;extendedAttributes-&gt;{CustomIsReachable};
 495 }
 496 
 497 sub IsDOMGlobalObject
 498 {
 499     my $interface = shift;
 500     return $interface-&gt;type-&gt;name eq &quot;DOMWindow&quot; || $interface-&gt;type-&gt;name eq &quot;RemoteDOMWindow&quot; || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;) || $interface-&gt;type-&gt;name eq &quot;TestGlobalObject&quot;;
 501 }
 502 
 503 sub ShouldUseGlobalObjectPrototype
 504 {
 505     my $interface = shift;
 506 
 507     # For workers, the global object is a DedicatedWorkerGlobalScope.
 508     return 0 if $interface-&gt;type-&gt;name eq &quot;WorkerGlobalScope&quot;;
 509     # For worklets, the global object is a PaintWorkletGlobalScope.
 510     return 0 if $interface-&gt;type-&gt;name eq &quot;WorkletGlobalScope&quot;;
 511 
 512     return IsDOMGlobalObject($interface);
 513 }
 514 
 515 sub GenerateIndexedGetter
 516 {
 517     my ($interface, $indexedGetterOperation, $indexExpression) = @_;
 518     
 519     # NOTE: This abstractly implements steps 1.2.1 - 1.2.8 of the LegacyPlatformObjectGetOwnProperty
 520     #       algorithm. Returing the conversion expression and attributes expression for use
 521     #       by the caller.
 522     
 523     # 1.2.1 Let operation be the operation used to declare the indexed property getter.
 524     # 1.2.2 Let value be an uninitialized variable.
 525     # 1.2.3 If operation was defined without an identifier, then set value to the result
 526     #       of performing the steps listed in the interface description to determine the
 527     #       value of an indexed property with index as the index.
 528     # 1.2.4 Otherwise, operation was defined with an identifier. Set value to the result
 529     #       of performing the steps listed in the description of operation with index as
 530     #       the only argument value.
 531     # 1.2.5 Let desc be a newly created Property Descriptor with no fields.
 532     # 1.2.6 Set desc.[[Value]] to the result of converting value to an ECMAScript value.
 533     # 1.2.7 If O implements an interface with an indexed property setter, then set
 534     #       desc.[[Writable]] to true, otherwise set it to false.
 535     # 1.2.8 Return desc.
 536     
 537     my @attributes = ();
 538     push(@attributes, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if !GetIndexedSetterOperation($interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin};
 539     
 540     my $attributeString = &quot;static_cast&lt;unsigned&gt;(&quot; . ((@attributes &gt; 0) ? join(&quot; | &quot;, @attributes) : &quot;0&quot;) . &quot;)&quot;;
 541 
 542     my $indexedGetterFunctionName = $indexedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $indexedGetterOperation-&gt;name || &quot;item&quot;;
 543     my $nativeToJSConversion = NativeToJSValueUsingPointers($indexedGetterOperation, $interface, &quot;thisObject-&gt;wrapped().${indexedGetterFunctionName}(${indexExpression})&quot;, &quot;*thisObject-&gt;globalObject()&quot;);
 544     
 545     return ($nativeToJSConversion, $attributeString);
 546 }
 547 
 548 sub GenerateNamedGetter
 549 {
 550     my ($interface, $namedGetterOperation, $namedPropertyExpression) = @_;
 551     
 552     # NOTE: This abstractly implements steps 2.1 - 2.10 of the LegacyPlatformObjectGetOwnProperty
 553     #       algorithm. Returing the conversion expression and attributes expression for use
 554     #       by the caller.
 555     
 556     # 2.1  Let operation be the operation used to declare the named property getter.
 557     # 2.2  Let value be an uninitialized variable.
 558     # 2.3  If operation was defined without an identifier, then set value to the result
 559     #      of performing the steps listed in the interface description to determine the
 560     #      value of a named property with P as the name.
 561     # 2.4  Otherwise, operation was defined with an identifier. Set value to the result
 562     #      of performing the steps listed in the description of operation with P as the
 563     #      only argument value..
 564     # 2.5  Let desc be a newly created Property Descriptor with no fields.
 565     # 2.6  Set desc.[[Value]] to the result of converting value to an ECMAScript value.
 566     # 2.7  If O implements an interface with a named property setter, then set desc.[[Writable]]
 567     #      to true, otherwise set it to false.
 568     # 2.8  If O implements an interface with the [LegacyUnenumerableNamedProperties]
 569     #      extended attribute, then set desc.[[Enumerable]] to false, otherwise set it
 570     #      to true.
 571     # 2.9  Set desc.[[Configurable]] to true.
 572     # 2.10 Return desc.
 573     
 574     my @attributes = ();
 575     push(@attributes, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if !GetNamedSetterOperation($interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin};
 576     push(@attributes, &quot;JSC::PropertyAttribute::DontEnum&quot;) if $interface-&gt;extendedAttributes-&gt;{LegacyUnenumerableNamedProperties};
 577     
 578     my $attributeString = &quot;static_cast&lt;unsigned&gt;(&quot; . ((@attributes &gt; 0) ? join(&quot; | &quot;, @attributes) : &quot;0&quot;) . &quot;)&quot;;
 579     my $nativeToJSConversion = NativeToJSValueUsingPointers($namedGetterOperation, $interface, $namedPropertyExpression, &quot;*thisObject-&gt;globalObject()&quot;);
 580     
 581     return ($nativeToJSConversion, $attributeString);
 582 }
 583 
 584 sub GenerateNamedGetterLambda
 585 {
 586     my ($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, $IDLType) = @_;
 587     
 588     # NOTE: Named getters are little odd. To avoid doing duplicate lookups (once when checking if
 589     #       the property name is a &#39;supported property name&#39; and once to get the value) we signal
 590     #       that a property is supported by whether or not it is &#39;null&#39; (where what null means is
 591     #       dependant on the IDL type). This is based on the assumption that no named getter will
 592     #       ever actually want to return null as an actual return value, which seems like an ok
 593     #       assumption to make (should it turn out this doesn&#39;t hold in the future, we have lots
 594     #       of options; do two lookups, add an extra layer of Optional, etc.).
 595     
 596     my $resultType = &quot;typename ${IDLType}::ImplementationType&quot;;
 597     $resultType = &quot;ExceptionOr&lt;&quot; . $resultType . &quot;&gt;&quot; if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 598     my $returnType = &quot;Optional&lt;&quot; . $resultType . &quot;&gt;&quot;;
 599 
 600     push(@$outputArray, &quot;    auto getterFunctor = [] (auto&amp; thisObject, auto propertyName) -&gt; ${returnType} {\n&quot;);
 601 
 602     my @arguments = GenerateCallWithUsingReferences($namedGetterOperation-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;WTF::nullopt&quot;, &quot;thisObject&quot;, &quot;        &quot;);
 603     push(@arguments, &quot;propertyNameToAtomicString(propertyName)&quot;);
 604 
 605     push(@$outputArray, &quot;        auto result = thisObject.wrapped().${namedGetterFunctionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;);\n&quot;);
 606     
 607     if ($namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) {
 608         push(@$outputArray, &quot;        if (result.hasException())\n&quot;);
 609         push(@$outputArray, &quot;            return ${resultType} { result.releaseException() };\n&quot;);
 610         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result.returnValue()))\n&quot;);
 611         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result.releaseReturnValue()) };\n&quot;);
 612         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 613     } else {
 614         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result))\n&quot;);
 615         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result) };\n&quot;);
 616         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 617     }
 618     push(@$outputArray, &quot;    };\n&quot;);
 619 }
 620 
 621 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 622 sub GenerateGetOwnPropertySlot
 623 {
 624     my ($outputArray, $interface, $className) = @_;
 625     
 626     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
 627     
 628     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlot(JSObject* object, ExecState* state, PropertyName propertyName, PropertySlot&amp; slot)\n&quot;);
 629     push(@$outputArray, &quot;{\n&quot;);
 630     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 631     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
 632     
 633     my $namedGetterOperation = GetNamedGetterOperation($interface);
 634     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 635     
 636     if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
 637         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);
 638     }
 639     
 640     # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
 641     # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
 642     
 643     # Therefore, the following steps are from the LegacyPlatformObjectGetOwnProperty algorithm
 644     # https://heycam.github.io/webidl/#LegacyPlatformObjectGetOwnProperty
 645     
 646     # 1. If O supports indexed properties and P is an array index property name, then:
 647     if ($indexedGetterOperation) {
 648         # 1.1. Let index be the result of calling ToUint32(P).
 649         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
 650         
 651         # 1.2. If index is a supported property index, then:
 652         # FIXME: This should support non-contiguous indices.
 653         push(@$outputArray, &quot;        if (index.value() &lt; thisObject-&gt;wrapped().length()) {\n&quot;);
 654         
 655         # NOTE: GenerateIndexedGetter implements steps 1.2.1 - 1.2.8.
 656         
 657         my ($nativeToJSConversion, $attributeString) = GenerateIndexedGetter($interface, $indexedGetterOperation, &quot;index.value()&quot;);
 658         
 659         push(@$outputArray, &quot;            auto value = ${nativeToJSConversion};\n&quot;);
 660         push(@$outputArray, &quot;            RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 661         
 662         push(@$outputArray, &quot;            slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 663         push(@$outputArray, &quot;            return true;\n&quot;);
 664         
 665         push(@$outputArray, &quot;        }\n&quot;);
 666         
 667         # 1.3. Set ignoreNamedProps to true.
 668         # NOTE: Setting ignoreNamedProps has the effect of skipping step 2, so we can early return here
 669         #       rather than going through the paces of having an actual ignoreNamedProps update.
 670         if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
 671             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlot(object, state, propertyName, slot);\n&quot;);
 672         }
 673         push(@$outputArray, &quot;    }\n&quot;);
 674     }
 675     
 676     # 2. If O supports named properties, the result of running the named property visibility
 677     #    algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
 678     if ($namedGetterOperation) {
 679         # NOTE: ignoreNamedProps is guarenteed to be false here, as it is initially false, and never set
 680         #       to true, due to the early return in step 1.3
 681         AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;);
 682                 
 683         my $namedGetterFunctionName = $namedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $namedGetterOperation-&gt;name || &quot;namedItem&quot;;
 684         my $IDLType = GetIDLTypeExcludingNullability($interface, $namedGetterOperation-&gt;type);
 685         
 686         push(@$outputArray, &quot;    using GetterIDLType = ${IDLType};\n&quot;);
 687         
 688         GenerateNamedGetterLambda($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, &quot;GetterIDLType&quot;);
 689         
 690         my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
 691         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*state, *thisObject, propertyName, getterFunctor)) {\n&quot;);
 692         
 693         # NOTE: GenerateNamedGetter implements steps 2.1 - 2.10.
 694         
 695         my ($nativeToJSConversion, $attributeString) = GenerateNamedGetter($interface, $namedGetterOperation, &quot;WTFMove(namedProperty.value())&quot;);
 696         
 697         push(@$outputArray, &quot;        auto value = ${nativeToJSConversion};\n&quot;);
 698         push(@$outputArray, &quot;        RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 699         
 700         push(@$outputArray, &quot;        slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 701         push(@$outputArray, &quot;        return true;\n&quot;);
 702         push(@$outputArray, &quot;    }\n&quot;);
 703     }
 704 
 705     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 706         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
 707         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, state, propertyName, slot))\n&quot;);
 708         push(@$outputArray, &quot;        return true;\n&quot;);
 709     }
 710 
 711     # 3. Return OrdinaryGetOwnProperty(O, P).
 712     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlot(object, state, propertyName, slot);\n&quot;);
 713     
 714     push(@$outputArray, &quot;}\n\n&quot;);
 715 }
 716 
 717 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 718 sub GenerateGetOwnPropertySlotByIndex
 719 {
 720     my ($outputArray, $interface, $className) = @_;
 721     
 722     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
 723 
 724     # Sink the int-to-string conversion that happens when we create a PropertyName
 725     # to the point where we actually need it.
 726     my $didGeneratePropertyName = 0;
 727     my $propertyNameGeneration = sub {
 728         return if $didGeneratePropertyName;
 729         
 730         push(@$outputArray, &quot;    auto propertyName = Identifier::from(state, index);\n&quot;);
 731         $didGeneratePropertyName = 1;
 732     };
 733     
 734     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlotByIndex(JSObject* object, ExecState* state, unsigned index, PropertySlot&amp; slot)\n&quot;);
 735     push(@$outputArray, &quot;{\n&quot;);
 736     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 737     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
 738     
 739     my $namedGetterOperation = GetNamedGetterOperation($interface);
 740     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 741     
 742     if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
 743         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);
 744     }
 745     
 746     # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
 747     # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
 748     
 749     # Therefore, the following steps are from the LegacyPlatformObjectGetOwnProperty algorithm
 750     # https://heycam.github.io/webidl/#LegacyPlatformObjectGetOwnProperty
 751     
 752     # 1. If O supports indexed properties and P is an array index property name, then:
 753     if ($indexedGetterOperation) {
 754         # 1.1. Let index be the result of calling ToUint32(P).
 755         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
 756         
 757         # 1.2. If index is a supported property index, then:
 758         # FIXME: This should support non-contiguous indices.
 759         push(@$outputArray, &quot;        if (index &lt; thisObject-&gt;wrapped().length()) {\n&quot;);
 760         
 761         # NOTE: GenerateIndexedGetter implements steps 1.2.1 - 1.2.8.
 762         
 763         my ($nativeToJSConversion, $attributeString) = GenerateIndexedGetter($interface, $indexedGetterOperation, &quot;index&quot;);
 764         
 765         push(@$outputArray, &quot;            auto value = ${nativeToJSConversion};\n&quot;);
 766         push(@$outputArray, &quot;            RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 767         
 768         push(@$outputArray, &quot;            slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 769         push(@$outputArray, &quot;            return true;\n&quot;);
 770         
 771         push(@$outputArray, &quot;        }\n&quot;);
 772         
 773         # 1.3. Set ignoreNamedProps to true.
 774         # NOTE: Setting ignoreNamedProps has the effect of skipping step 2, so we can early return here
 775         #       rather than going through the paces of having an actual ignoreNamedProps update.
 776         if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
 777             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlotByIndex(object, state, index, slot);\n&quot;);
 778         }
 779         push(@$outputArray, &quot;    }\n&quot;);
 780     }
 781     
 782     # 2. If O supports named properties, the result of running the named property visibility
 783     #    algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
 784     if ($namedGetterOperation) {
 785         # NOTE: ignoreNamedProps is guarenteed to be false here, as it is initially false, and never set
 786         #       to true, due to the early return in step 1.3
 787         AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;);
 788                 
 789         &amp;$propertyNameGeneration();
 790         
 791         my $namedGetterFunctionName = $namedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $namedGetterOperation-&gt;name || &quot;namedItem&quot;;
 792         my $IDLType = GetIDLTypeExcludingNullability($interface, $namedGetterOperation-&gt;type);
 793         
 794         push(@$outputArray, &quot;    using GetterIDLType = ${IDLType};\n&quot;);
 795         
 796         GenerateNamedGetterLambda($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, &quot;GetterIDLType&quot;);
 797         
 798         my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
 799         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*state, *thisObject, propertyName, getterFunctor)) {\n&quot;);
 800         
 801         # NOTE: GenerateNamedGetter implements steps 2.1 - 2.10.
 802         
 803         my ($nativeToJSConversion, $attributeString) = GenerateNamedGetter($interface, $namedGetterOperation, &quot;WTFMove(namedProperty.value())&quot;);
 804 
 805         push(@$outputArray, &quot;        auto value = ${nativeToJSConversion};\n&quot;);
 806         push(@$outputArray, &quot;        RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 807         
 808         push(@$outputArray, &quot;        slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 809         push(@$outputArray, &quot;        return true;\n&quot;);
 810         push(@$outputArray, &quot;    }\n&quot;);
 811     }
 812     
 813     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 814         &amp;$propertyNameGeneration();
 815 
 816         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
 817         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, state, propertyName, slot))\n&quot;);
 818         push(@$outputArray, &quot;        return true;\n&quot;);
 819     }
 820 
 821     # 3. Return OrdinaryGetOwnProperty(O, P).
 822     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlotByIndex(object, state, index, slot);\n&quot;);
 823     
 824     push(@$outputArray, &quot;}\n\n&quot;);
 825 }
 826 
 827 # https://heycam.github.io/webidl/#legacy-platform-object-property-enumeration
 828 sub GenerateGetOwnPropertyNames
 829 {
 830     my ($outputArray, $interface, $className) = @_;
 831     
 832     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertyNames};
 833     
 834     my $namedGetterOperation = GetNamedGetterOperation($interface);
 835     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 836     
 837     push(@$outputArray, &quot;void ${className}::getOwnPropertyNames(JSObject* object, ExecState* state, PropertyNameArray&amp; propertyNames, EnumerationMode mode)\n&quot;);
 838     push(@$outputArray, &quot;{\n&quot;);
 839     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 840     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(object, info());\n&quot;);
 841     
 842     # 1. If the object supports indexed properties, then the object’s supported
 843     #    property indices are enumerated first, in numerical order.
 844     # FIXME: This should support non-contiguous indices.
 845     if ($indexedGetterOperation) {
 846         push(@$outputArray, &quot;    for (unsigned i = 0, count = thisObject-&gt;wrapped().length(); i &lt; count; ++i)\n&quot;);
 847         push(@$outputArray, &quot;        propertyNames.add(Identifier::from(state, i));\n&quot;);
 848     }
 849 
 850     # 2. If the object supports named properties and doesn’t implement an interface
 851     #    with the [LegacyUnenumerableNamedProperties] extended attribute, then the
 852     #    object’s supported property names that are visible according to the named
 853     #    property visibility algorithm are enumerated next, in the order given in
 854     #    the definition of the set of supported property names.
 855     if ($namedGetterOperation) {
 856         if (!$interface-&gt;extendedAttributes-&gt;{LegacyUnenumerableNamedProperties}) {
 857             push(@$outputArray, &quot;    for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
 858             push(@$outputArray, &quot;        propertyNames.add(Identifier::fromString(state, propertyName));\n&quot;);
 859         } else {
 860             push(@$outputArray, &quot;    if (mode.includeDontEnumProperties()) {\n&quot;);
 861             push(@$outputArray, &quot;        for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
 862             push(@$outputArray, &quot;            propertyNames.add(Identifier::fromString(state, propertyName));\n&quot;);
 863             push(@$outputArray, &quot;    }\n&quot;);
 864         }
 865     }
 866     
 867     # 3. Finally, any enumerable own properties or properties from the object’s
 868     #    prototype chain are then enumerated, in no defined order.
 869     push(@$outputArray, &quot;    JSObject::getOwnPropertyNames(object, state, propertyNames, mode);\n&quot;);
 870     push(@$outputArray, &quot;}\n\n&quot;);
 871 }
 872 
 873 # https://heycam.github.io/webidl/#invoke-indexed-setter
 874 sub GenerateInvokeIndexedPropertySetter
 875 {
 876     my ($outputArray, $indent, $interface, $indexedSetterOperation, $indexExpression, $value) = @_;
 877     
 878     # The second argument of the indexed setter operation is the argument being converted.
 879     my $argument = @{$indexedSetterOperation-&gt;arguments}[1];
 880     my $nativeValue = JSValueToNative($interface, $argument, $value, $indexedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;state&quot;, &quot;*state&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);
 881     
 882     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);
 883     push(@$outputArray, $indent . &quot;auto nativeValue = ${nativeValue};\n&quot;);
 884     push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, true);\n&quot;);
 885     
 886     my $indexedSetterFunctionName = $indexedSetterOperation-&gt;name || &quot;setItem&quot;;
 887     my $nativeValuePassExpression = PassArgumentExpression(&quot;nativeValue&quot;, $argument);
 888     my $functionString = &quot;thisObject-&gt;wrapped().${indexedSetterFunctionName}(${indexExpression}, ${nativeValuePassExpression})&quot;;
 889     $functionString = &quot;propagateException(*state, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($indexedSetterOperation);
 890     
 891     push(@$outputArray, $indent . $functionString . &quot;;\n&quot;);
 892 }
 893 
 894 # https://heycam.github.io/webidl/#invoke-named-setter
 895 sub GenerateInvokeNamedPropertySetter
 896 {
 897     my ($outputArray, $indent, $interface, $namedSetterOperation, $value) = @_;
 898     
 899     my $argument = @{$namedSetterOperation-&gt;arguments}[1];
 900     my $nativeValue = JSValueToNative($interface, $argument, $value, $namedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;state&quot;, &quot;*state&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);
 901     
 902     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);
 903     push(@$outputArray, $indent . &quot;auto nativeValue = ${nativeValue};\n&quot;);
 904     push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, true);\n&quot;);
 905 
 906     push(@$outputArray, $indent . &quot;bool isPropertySupported = true;\n&quot;) if $namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
 907 
 908     my $namedSetterFunctionName = $namedSetterOperation-&gt;name || &quot;setNamedItem&quot;;
 909     my $nativeValuePassExpression = PassArgumentExpression(&quot;nativeValue&quot;, $argument);
 910 
 911     my @arguments = ();
 912     push(@arguments, &quot;propertyNameToString(propertyName)&quot;);
 913     push(@arguments, $nativeValuePassExpression);
 914     push(@arguments, &quot;isPropertySupported&quot;) if $namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
 915 
 916     my $functionString = &quot;thisObject-&gt;wrapped().${namedSetterFunctionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
 917     $functionString = &quot;propagateException(*state, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($namedSetterOperation);
 918 
 919     push(@$outputArray, $indent . $functionString . &quot;;\n&quot;);
 920 }
 921 
 922 sub GeneratePut
 923 {
 924     my ($outputArray, $interface, $className) = @_;
 925     
 926     return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
 927     
 928     my $namedSetterOperation = GetNamedSetterOperation($interface);
 929     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
 930     
 931     push(@$outputArray, &quot;bool ${className}::put(JSCell* cell, ExecState* state, PropertyName propertyName, JSValue value, PutPropertySlot&amp; putPropertySlot)\n&quot;);
 932     push(@$outputArray, &quot;{\n&quot;);
 933     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
 934     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
 935 
 936     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
 937         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
 938     if ($namedSetterOperation) {
 939         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*state&quot;);
 940     }
 941     if ($indexedSetterOperation) {
 942         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*state&quot;);
 943     }
 944     
 945     if ($indexedSetterOperation) {
 946         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
 947         
 948         GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index.value()&quot;, &quot;value&quot;);
 949         
 950         push(@$outputArray, &quot;        return true;\n&quot;);
 951         push(@$outputArray, &quot;    }\n\n&quot;);
 952     }
 953     
 954     if ($namedSetterOperation) {
 955         # FIMXE: We need a more comprehensive story for Symbols.
 956         push(@$outputArray, &quot;    if (!propertyName.isSymbol()) {\n&quot;);
 957         
 958         my $additionalIndent = &quot;&quot;;
 959         
 960         my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
 961         if (!$overrideBuiltins) {
 962             push(@$outputArray, &quot;        PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
 963             push(@$outputArray, &quot;        JSValue prototype = thisObject-&gt;getPrototypeDirect(state-&gt;vm());\n&quot;);
 964             push(@$outputArray, &quot;        if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(state, propertyName, slot))) {\n&quot;);
 965             $additionalIndent .= &quot;    &quot;;
 966         }
 967 
 968         GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;        &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
 969         if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
 970             push(@$outputArray, $additionalIndent . &quot;        if (!isPropertySupported)\n&quot;);
 971             push(@$outputArray, $additionalIndent . &quot;            return JSObject::put(thisObject, state, propertyName, value, putPropertySlot);\n&quot;);
 972         }
 973         push(@$outputArray, $additionalIndent . &quot;        return true;\n&quot;);
 974 
 975         if (!$overrideBuiltins) {
 976             push(@$outputArray, &quot;        }\n&quot;);
 977         }
 978         
 979         push(@$outputArray, &quot;    }\n\n&quot;);
 980     }
 981     
 982     assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
 983     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 984         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
 985 
 986         push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
 987         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, state, propertyName, value, putPropertySlot, putResult))\n&quot;);
 988         push(@$outputArray, &quot;        return putResult;\n\n&quot;);
 989     }
 990 
 991     push(@$outputArray, &quot;    return JSObject::put(thisObject, state, propertyName, value, putPropertySlot);\n&quot;);
 992     push(@$outputArray, &quot;}\n\n&quot;);
 993 }
 994 
 995 sub GeneratePutByIndex
 996 {
 997     my ($outputArray, $interface, $className) = @_;
 998     
 999     return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
1000 
1001     my $namedSetterOperation = GetNamedSetterOperation($interface);
1002     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
1003     
1004     my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
1005     my $ellidesCallsToBase = ($namedSetterOperation &amp;&amp; $overrideBuiltins) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin} &amp;&amp; !$namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
1006     
1007     push(@$outputArray, &quot;bool ${className}::putByIndex(JSCell* cell, ExecState* state, unsigned index, JSValue value, bool&quot; . (!$ellidesCallsToBase ? &quot; shouldThrow&quot; : &quot;&quot;) . &quot;)\n&quot;);
1008     push(@$outputArray, &quot;{\n&quot;);
1009     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
1010     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
1011 
1012     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
1013         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
1014     if ($namedSetterOperation) {
1015         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*state&quot;);
1016     }
1017     if ($indexedSetterOperation) {
1018         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*state&quot;);
1019     }
1020     
1021     if ($indexedSetterOperation ) {
1022         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
1023         
1024         GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index&quot;, &quot;value&quot;);
1025         
1026         push(@$outputArray, &quot;        return true;\n&quot;);
1027         push(@$outputArray, &quot;    }\n\n&quot;);
1028     }
1029     
1030     if ($namedSetterOperation) {
1031         push(@$outputArray, &quot;    auto propertyName = Identifier::from(state, index);\n&quot;);
1032                 
1033         my $additionalIndent = &quot;&quot;;
1034         if (!$overrideBuiltins) {
1035             push(@$outputArray, &quot;    PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
1036             push(@$outputArray, &quot;    JSValue prototype = thisObject-&gt;getPrototypeDirect(state-&gt;vm());\n&quot;);
1037             push(@$outputArray, &quot;    if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(state, propertyName, slot))) {\n&quot;);
1038             $additionalIndent .= &quot;    &quot;;
1039         }
1040         
1041         GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;    &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
1042         if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
1043             push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
1044             push(@$outputArray, $additionalIndent . &quot;        return JSObject::putByIndex(cell, state, index, value, shouldThrow);\n&quot;);
1045         }
1046         push(@$outputArray, $additionalIndent . &quot;    return true;\n&quot;);
1047         
1048         if (!$overrideBuiltins) {
1049             push(@$outputArray, &quot;    }\n\n&quot;);
1050         }
1051     }
1052 
1053     assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
1054     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
1055         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
1056         push(@$outputArray, &quot;    auto propertyName = Identifier::from(state, index);\n&quot;);
1057         push(@$outputArray, &quot;    PutPropertySlot putPropertySlot(thisObject, shouldThrow);\n&quot;);
1058         push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
1059         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, state, propertyName, value, putPropertySlot, putResult))\n&quot;);
1060         push(@$outputArray, &quot;        return putResult;\n\n&quot;);
1061     }
1062 
1063     if (!$ellidesCallsToBase) {
1064         push(@$outputArray, &quot;    return JSObject::putByIndex(cell, state, index, value, shouldThrow);\n&quot;);
1065     }
1066     
1067     push(@$outputArray, &quot;}\n\n&quot;);
1068 }
1069 
1070 sub GenerateIsUnforgeablePropertyName
1071 {
1072     my ($outputArray, $interface) = @_;
1073     
1074     my @unforgeablePropertyNames = ();
1075     foreach my $property (@{$interface-&gt;attributes}, @{$interface-&gt;operations}) {
1076         next if $property-&gt;isStatic;
1077         
1078         if (IsUnforgeable($interface, $property)) {
1079             push(@unforgeablePropertyNames, $property-&gt;name);
1080         }
1081     }
1082     
1083     return 0 if (scalar(@unforgeablePropertyNames) == 0);
1084     
1085     my $condition = join(&quot; || &quot;, map { &quot;propertyName == \&quot;&quot; . $_ . &quot;\&quot;&quot; } @unforgeablePropertyNames);
1086     
1087     push(@$outputArray, &quot;static bool isUnforgeablePropertyName(PropertyName propertyName)\n&quot;);
1088     push(@$outputArray, &quot;{\n&quot;);
1089     push(@$outputArray, &quot;    return ${condition};\n&quot;);
1090     push(@$outputArray, &quot;}\n\n&quot;);
1091     
1092     return 1;
1093 }
1094 
1095 # https://heycam.github.io/webidl/#legacy-platform-object-defineownproperty
1096 sub GenerateDefineOwnProperty
1097 {
1098     my ($outputArray, $interface, $className) = @_;
1099     
1100     return if $interface-&gt;extendedAttributes-&gt;{CustomDefineOwnProperty};
1101     
1102     my $namedSetterOperation = GetNamedSetterOperation($interface);
1103     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
1104     
1105     return if !$namedSetterOperation &amp;&amp; !$indexedSetterOperation;
1106     
1107     push(@$outputArray, &quot;bool ${className}::defineOwnProperty(JSObject* object, ExecState* state, PropertyName propertyName, const PropertyDescriptor&amp; propertyDescriptor, bool shouldThrow)\n&quot;);
1108     push(@$outputArray, &quot;{\n&quot;);
1109     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
1110     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
1111 
1112     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
1113         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
1114     if ($namedSetterOperation) {
1115         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*state&quot;);
1116     }
1117     if ($indexedSetterOperation) {
1118         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*state&quot;);
1119     }
1120     
1121     # 1. If O supports indexed properties and P is an array index property name, then:
1122     if (GetIndexedGetterOperation($interface)) {
1123         # NOTE: The numbers are out of order because there is no reason doing steps 1, 3, and 4 if there
1124         # is no indexed property setter.
1125 
1126         if (!$indexedSetterOperation) {
1127             # 2. If O does not implement an interface with an indexed property setter, then return false.
1128             push(@$outputArray, &quot;    if (parseIndex(propertyName))\n&quot;);
1129             push(@$outputArray, &quot;        return false;\n\n&quot;);
1130         } else {
1131             push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
1132 
1133             # 1. If the result of calling IsDataDescriptor(Desc) is false, then return false.
1134             push(@$outputArray, &quot;        if (!propertyDescriptor.isDataDescriptor())\n&quot;);
1135             push(@$outputArray, &quot;            return false;\n&quot;);
1136             
1137             # 3. Invoke the indexed property setter with P and Desc.[[Value]].
1138             GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index.value()&quot;, &quot;propertyDescriptor.value()&quot;);
1139             
1140             # 4. Return true.
1141             push(@$outputArray, &quot;        return true;\n&quot;);
1142             push(@$outputArray, &quot;    }\n\n&quot;);
1143         }
1144     }
1145     
1146     # 2. If O supports named properties, O does not implement an interface with the [Global] or [PrimaryGlobal]
1147     #    extended attribute and P is not an unforgeable property name of O, then:
1148     if (GetNamedGetterOperation($interface) &amp;&amp; !IsGlobalOrPrimaryGlobalInterface($interface)) {
1149         # FIMXE: We need a more comprehensive story for Symbols.
1150         push(@$outputArray, &quot;    if (!propertyName.isSymbol()) {\n&quot;);
1151         
1152         my $additionalIndent = &quot;&quot;;
1153         
1154         my $hasUnforgableProperties = GenerateIsUnforgeablePropertyName($outputArray, $interface);
1155         if ($hasUnforgableProperties) {
1156             push(@$outputArray, &quot;        if (!isUnforgeablePropertyName(propertyName)) {\n&quot;);
1157             $additionalIndent .= &quot;    &quot;;
1158         }
1159         
1160         # 1. Let creating be true if P is not a supported property name, and false otherwise.
1161         # NOTE: This step is strength reduced into the only use of &#39;creating&#39; in step 2.2.1
1162         
1163         # 2. If O implements an interface with the [OverrideBuiltins] extended attribute or O
1164         #    does not have an own property named P, then:
1165         my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
1166         if (!$overrideBuiltins) {
1167             # FIXME: Is JSObject::getOwnPropertySlot the right function to call? Is there a function that will
1168             #        only look at the actual properties, and not call into our implementation of the
1169             #        [[GetOwnProperty]] hook?
1170             push(@$outputArray, $additionalIndent. &quot;        PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
1171             push(@$outputArray, $additionalIndent. &quot;        if (!JSObject::getOwnPropertySlot(thisObject, state, propertyName, slot)) {\n&quot;);
1172             $additionalIndent .= &quot;    &quot;;
1173         }
1174         if (!$namedSetterOperation) {
1175             # 2.1. If creating is false and O does not implement an interface with a named property setter, then return false.
1176             push(@$outputArray, $additionalIndent . &quot;        if (thisObject-&gt;wrapped().isSupportedPropertyName(propertyNameToString(propertyName)))\n&quot;);
1177             push(@$outputArray, $additionalIndent . &quot;            return false;\n&quot;);
1178         } else {
1179             # 2.2. If O implements an interface with a named property setter, then:
1180             
1181             # 2.2.1. If the result of calling IsDataDescriptor(Desc) is false, then return false.
1182             push(@$outputArray, $additionalIndent . &quot;        if (!propertyDescriptor.isDataDescriptor())\n&quot;);
1183             push(@$outputArray, $additionalIndent . &quot;            return false;\n&quot;);
1184             
1185             # 2.2.2. Invoke the named property setter with P and Desc.[[Value]].
1186             GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;        &quot;, $interface, $namedSetterOperation, &quot;propertyDescriptor.value()&quot;);
1187             if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
1188                 push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
1189                 push(@$outputArray, $additionalIndent . &quot;        return JSObject::defineOwnProperty(object, state, propertyName, propertyDescriptor, shouldThrow);\n&quot;);
1190             }
1191             # 2.2.3. Return true.
1192             push(@$outputArray, $additionalIndent . &quot;        return true;\n&quot;);
1193         }
1194         
1195         if (!$overrideBuiltins) {
1196             push(@$outputArray, $additionalIndent . &quot;    }\n&quot;);
1197         }
1198         
1199         if ($hasUnforgableProperties) {
1200             push(@$outputArray, &quot;        }\n&quot;);
1201         }
1202         
1203         # Close the !propertyName.isSymbol() condition.
1204         push(@$outputArray, &quot;    }\n\n&quot;);
1205     }
1206     
1207     push(@$outputArray, &quot;    PropertyDescriptor newPropertyDescriptor = propertyDescriptor;\n&quot;);
1208         
1209     # 3. If O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute,
1210     #    then set Desc.[[Configurable]] to true.
1211     if (!IsGlobalOrPrimaryGlobalInterface($interface)) {
1212         push(@$outputArray, &quot;    newPropertyDescriptor.setConfigurable(true);\n&quot;);
1213     }
1214     
1215     # 4. Return OrdinaryDefineOwnProperty(O, P, Desc).
1216     # FIXME: Does this do the same thing?
1217     push(@$outputArray, &quot;    return JSObject::defineOwnProperty(object, state, propertyName, newPropertyDescriptor, shouldThrow);\n&quot;);
1218     
1219     push(@$outputArray, &quot;}\n\n&quot;);
1220 }
1221 
1222 sub GenerateDeletePropertyCommon
1223 {
1224     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1225     
1226     # This implements step 2 of https://heycam.github.io/webidl/#legacy-platform-object-delete
1227     # so it can be shared between the generation of deleteProperty and deletePropertyByIndex.
1228 
1229     # 2. If O supports named properties, O does not implement an interface with the
1230     #    [Global] or [PrimaryGlobal] extended attribute and the result of calling the
1231     #    named property visibility algorithm with property name P and object O is true,
1232     #    then:
1233     assert(&quot;Named property deleters are not allowed without a corresponding named property getter.&quot;) if !GetNamedGetterOperation($interface);
1234     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalOrPrimaryGlobalInterface($interface);
1235 
1236     AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;, $conditional);
1237     my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
1238     push(@$outputArray, &quot;    if (isVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*state, thisObject, propertyName)) {\n&quot;);
1239 
1240     GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*state&quot;);
1241 
1242     # 2.1. If O does not implement an interface with a named property deleter, then return false.
1243     # 2.2. Let operation be the operation used to declare the named property deleter.
1244     # NOTE: We only add a deleteProperty implementation of we have a named property deleter.
1245 
1246     # 2.3. If operation was defined without an identifier, then:
1247     #      1. Perform the steps listed in the interface description to delete an existing named
1248     #         property with P as the name.
1249     #      2. If the steps indicated that the deletion failed, then return false.
1250     # 2.4. Otherwise, operation was defined with an identifier:
1251     #      1. Perform the steps listed in the description of operation with P as the only argument
1252     #         value.
1253     #      2. If operation was declared with a return type of boolean and the steps returned false,
1254     #         then return false.
1255 
1256     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name) || &quot;deleteNamedProperty&quot;;
1257     my $functionCall = &quot;impl.&quot; . $functionImplementationName . &quot;(propertyNameToString(propertyName))&quot;;
1258 
1259     # NOTE: We expect the implementation function of named deleters without an identifier to
1260     #       return either bool or ExceptionOr&lt;bool&gt;. the implementation function of named deleters
1261     #       with an identifier have no restriction, but if the return value of the operation is
1262     #       boolean, we return that value, otherwise it is ignored (as per section 4.2).
1263 
1264     if ($operation-&gt;extendedAttributes-&gt;{MayThrowException}) {
1265         push(@$outputArray, &quot;        auto result = ${functionCall};\n&quot;);
1266         push(@$outputArray, &quot;        if (result.hasException()) {\n&quot;);
1267         push(@$outputArray, &quot;            auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);
1268         push(@$outputArray, &quot;            propagateException(*state, throwScope, result.releaseException());\n&quot;);
1269         push(@$outputArray, &quot;            return true;\n&quot;);
1270         push(@$outputArray, &quot;        }\n\n&quot;);
1271 
1272         if (!$operation-&gt;name || $operation-&gt;name &amp;&amp; $operation-&gt;type-&gt;name eq &quot;boolean&quot;) {
1273             push(@$outputArray, &quot;        return result.releaseReturnValue();\n&quot;);
1274         } else {
1275             push(@$outputArray, &quot;        return true;\n&quot;);
1276         }
1277     } else {
1278         if (!$operation-&gt;name || $operation-&gt;name &amp;&amp; $operation-&gt;type-&gt;name eq &quot;boolean&quot;) {
1279             push(@$outputArray, &quot;        return ${functionCall};\n&quot;);
1280         } else {
1281             push(@$outputArray, &quot;        ${functionCall};\n&quot;);
1282             push(@$outputArray, &quot;        return true;\n&quot;);
1283         }
1284     }
1285 
1286     push(@$outputArray, &quot;    }\n&quot;);
1287 }
1288 
1289 sub GenerateDeleteProperty
1290 {
1291     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1292 
1293     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
1294     # for the deleteProperty override hook.
1295 
1296     push(@$outputArray, &quot;bool ${className}::deleteProperty(JSCell* cell, ExecState* state, PropertyName propertyName)\n&quot;);
1297     push(@$outputArray, &quot;{\n&quot;);
1298 
1299     push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
1300     push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
1301 
1302     # 1. If O supports indexed properties and P is an array index property name, then:
1303     #    1. Let index be the result of calling ToUint32(P).
1304     #    2. If index is not a supported property index, then return true.
1305     #    3. Return false.
1306     if (GetIndexedGetterOperation($interface)) {
1307         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName))\n&quot;);
1308         push(@$outputArray, &quot;        return !impl.isSupportedPropertyIndex(index.value());\n&quot;);
1309     }
1310 
1311     # GenerateDeletePropertyCommon implements step 2.
1312     GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
1313 
1314     # FIXME: Instead of calling down JSObject::deleteProperty, perhaps we should implement
1315     # the remained of the algorithm ourselves.
1316     push(@$outputArray, &quot;    return JSObject::deleteProperty(cell, state, propertyName);\n&quot;);
1317     push(@$outputArray, &quot;}\n\n&quot;);
1318 }
1319 
1320 sub GenerateDeletePropertyByIndex
1321 {
1322     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1323 
1324     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
1325     # for the deletePropertyByIndex override hook.
1326 
1327     push(@$outputArray, &quot;bool ${className}::deletePropertyByIndex(JSCell* cell, ExecState* state, unsigned index)\n&quot;);
1328     push(@$outputArray, &quot;{\n&quot;);
1329 
1330     push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
1331     push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
1332 
1333     # 1. If O supports indexed properties and P is an array index property name, then:
1334     #    1. Let index be the result of calling ToUint32(P).
1335     #    2. If index is not a supported property index, then return true.
1336     #    3. Return false.
1337 
1338     # NOTE: For deletePropertyByIndex, if there is an indexed getter, checking isSupportedPropertyIndex()
1339     #       is all that needs to be done, no need to generate the .
1340 
1341     if (GetIndexedGetterOperation($interface)) {
1342         push(@$outputArray, &quot;    return !impl.isSupportedPropertyIndex(index);\n&quot;);
1343     } else {
1344         push(@$outputArray, &quot;    auto propertyName = Identifier::from(state, index);\n&quot;);
1345 
1346         # GenerateDeletePropertyCommon implements step 2.
1347         GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
1348 
1349         # FIXME: Instead of calling down JSObject::deletePropertyByIndex, perhaps we should implement
1350         # the remaineder of the algoritm (steps 3 and 4) ourselves.
1351         
1352         # 3. If O has an own property with name P, then:
1353         #    1. If the property is not configurable, then return false.
1354         #    2. Otherwise, remove the property from O.
1355         # 3. Return true.
1356         
1357         push(@$outputArray, &quot;    return JSObject::deletePropertyByIndex(cell, state, index);\n&quot;);
1358     }
1359 
1360     push(@$outputArray, &quot;}\n\n&quot;);
1361 }
1362 
1363 
1364 sub GenerateNamedDeleterDefinition
1365 {
1366     my ($outputArray, $interface, $className) = @_;
1367     
1368     return if $interface-&gt;extendedAttributes-&gt;{CustomDeleteProperty};
1369 
1370     my $namedDeleterOperation = GetNamedDeleterOperation($interface);
1371     
1372     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete using
1373     # the deleteProperty and deletePropertyByIndex override hooks.
1374 
1375     assert(&quot;Named property deleters are not allowed without a corresponding named property getter.&quot;) if !GetNamedGetterOperation($interface);
1376     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalOrPrimaryGlobalInterface($interface);
1377 
1378     my $conditional = $namedDeleterOperation-&gt;extendedAttributes-&gt;{Conditional};
1379     if ($conditional) {
1380         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
1381         push(@$outputArray, &quot;#if ${conditionalString}\n\n&quot;);;
1382     }
1383 
1384     GenerateDeleteProperty($outputArray, $interface, $className, $namedDeleterOperation, $conditional);
1385     GenerateDeletePropertyByIndex($outputArray, $interface, $className, $namedDeleterOperation, $conditional);
1386 
1387     push(@implContent, &quot;#endif\n\n&quot;) if $conditional;
1388 }
1389 
1390 sub GenerateHeaderContentHeader
1391 {
1392     my $interface = shift;
1393     my $className = &quot;JS&quot; . $interface-&gt;type-&gt;name;
1394 
1395     my @headerContentHeader;
1396     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
1397         @headerContentHeader = split(&quot;\r&quot;, $beginAppleCopyrightForHeaderFiles);
1398     } else {
1399         @headerContentHeader = split(&quot;\r&quot;, $headerTemplate);
1400     }
1401 
1402     push(@headerContentHeader, &quot;\n#pragma once\n\n&quot;);
1403 
1404     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
1405     push(@headerContentHeader, &quot;#if ${conditionalString}\n\n&quot;) if $conditionalString;
1406     return @headerContentHeader;
1407 }
1408 
1409 sub GenerateImplementationContentHeader
1410 {
1411     my $interface = shift;
1412     my $className = &quot;JS&quot; . $interface-&gt;type-&gt;name;
1413 
1414     my @implContentHeader;
1415     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
1416         @implContentHeader = split(&quot;\r&quot;, $beginAppleCopyrightForSourceFiles);
1417     } else {
1418         @implContentHeader = split(&quot;\r&quot;, $headerTemplate);
1419     }
1420 
1421     push(@implContentHeader, &quot;\n#include \&quot;config.h\&quot;\n&quot;);
1422     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
1423     push(@implContentHeader, &quot;\n#if ${conditionalString}\n\n&quot;) if $conditionalString;
1424     push(@implContentHeader, &quot;#include \&quot;$className.h\&quot;\n\n&quot;);
1425     return @implContentHeader;
1426 }
1427 
1428 sub NeedsImplementationClass
1429 {
1430     my ($interface) = @_;
1431 
1432     return 0 if $interface-&gt;extendedAttributes-&gt;{JSBuiltin};
1433     return 1;
1434 }
1435 
1436 sub ShouldGenerateToWrapped
1437 {
1438     my ($hasParent, $interface) = @_;
1439 
1440     return 0 if not NeedsImplementationClass($interface);
1441     return 1 if !$hasParent or $interface-&gt;extendedAttributes-&gt;{JSGenerateToNativeObject};
1442     return 1 if $interface-&gt;parentType &amp;&amp; $interface-&gt;parentType-&gt;name eq &quot;EventTarget&quot;;
1443     return 0;
1444 }
1445 
1446 sub ShouldGenerateWrapperOwnerCode
1447 {
1448     my ($hasParent, $interface) = @_;
1449 
1450     return 0 if not NeedsImplementationClass($interface);
1451     return 1 if !$hasParent;
1452     return 1 if GetGenerateIsReachable($interface);
1453     return 1 if GetCustomIsReachable($interface);
1454     return 1 if $interface-&gt;extendedAttributes-&gt;{JSCustomFinalize};
1455     return 1 if $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;ActiveDOMObject&quot;);
1456     return 0;
1457 }
1458 
1459 sub ShouldGenerateToJSDeclaration
1460 {
1461     my ($hasParent, $interface) = @_;
1462 
1463     return 0 if ($interface-&gt;extendedAttributes-&gt;{SuppressToJSObject});
1464     return 0 if not NeedsImplementationClass($interface);
1465     return 0 if $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject};
1466     return 1 if (!$hasParent or $interface-&gt;extendedAttributes-&gt;{JSGenerateToJSObject} or $interface-&gt;extendedAttributes-&gt;{CustomToJSObject});
1467     return 1 if $interface-&gt;parentType &amp;&amp; $interface-&gt;parentType-&gt;name eq &quot;EventTarget&quot;;
1468     return 1 if $interface-&gt;extendedAttributes-&gt;{Constructor} or $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
1469     return 0;
1470 }
1471 
1472 sub ShouldGenerateToJSImplementation
1473 {
1474     my ($hasParent, $interface) = @_;
1475 
1476     return 0 if not ShouldGenerateToJSDeclaration($hasParent, $interface);
1477     return 1 if not $interface-&gt;extendedAttributes-&gt;{CustomToJSObject};
1478     return 0;
1479 }
1480 
1481 sub GetTypeNameForDisplayInException
1482 {
1483     my ($type) = @_;
1484 
1485     # FIXME: Add more type specializations.
1486     return &quot;(&quot; . join(&quot; or &quot;, map { $_-&gt;name } GetFlattenedMemberTypes($type)) . &quot;)&quot; if $type-&gt;isUnion;
1487     return $type-&gt;name;
1488 }
1489 
1490 sub GetArgumentExceptionFunction
1491 {
1492     my ($interface, $argument, $argumentIndex, $quotedFunctionName) = @_;
1493 
1494     my $name = $argument-&gt;name;
1495     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
1496     my $typeName = GetTypeNameForDisplayInException($argument-&gt;type);
1497 
1498     if ($codeGenerator-&gt;IsCallbackInterface($argument-&gt;type) || $codeGenerator-&gt;IsCallbackFunction($argument-&gt;type)) {
1499         # FIXME: We should have specialized messages for callback interfaces vs. callback functions.
1500         return &quot;throwArgumentMustBeFunctionError(state, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName});&quot;;
1501     }
1502 
1503     if ($codeGenerator-&gt;IsWrapperType($argument-&gt;type) || $codeGenerator-&gt;IsBufferSourceType($argument-&gt;type)) {
1504         return &quot;throwArgumentTypeError(state, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, \&quot;${typeName}\&quot;);&quot;;
1505     }
1506 
1507     if ($codeGenerator-&gt;IsEnumType($argument-&gt;type)) {
1508         my $className = GetEnumerationClassName($argument-&gt;type, $interface);
1509         return &quot;throwArgumentMustBeEnumError(state, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, expectedEnumerationValues&lt;${className}&gt;());&quot;;
1510     }
1511 
1512     return undef;
1513 }
1514 
1515 sub GetArgumentExceptionThrower
1516 {
1517     my ($interface, $argument, $argumentIndex, $quotedFunctionName) = @_;
1518 
1519     my $functionCall = GetArgumentExceptionFunction($interface, $argument, $argumentIndex, $quotedFunctionName);
1520     return &quot;[](JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;
1521 }
1522 
1523 sub GetAttributeExceptionFunction
1524 {
1525     my ($interface, $attribute) = @_;
1526     
1527     my $name = $attribute-&gt;name;
1528     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
1529     my $typeName = GetTypeNameForDisplayInException($attribute-&gt;type);
1530 
1531     if ($codeGenerator-&gt;IsWrapperType($attribute-&gt;type) || $codeGenerator-&gt;IsBufferSourceType($attribute-&gt;type)) {
1532         return &quot;throwAttributeTypeError(state, scope, \&quot;${visibleInterfaceName}\&quot;, \&quot;${name}\&quot;, \&quot;${typeName}\&quot;);&quot;;
1533     }
1534 }
1535 
1536 sub GetAttributeExceptionThrower
1537 {
1538     my ($interface, $attribute) = @_;
1539 
1540     my $functionCall = GetAttributeExceptionFunction($interface, $attribute);
1541     return &quot;[](JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;
1542 
1543 }
1544 
1545 sub PassArgumentExpression
1546 {
1547     my ($name, $context) = @_;
1548 
1549     my $type = $context-&gt;type;
1550 
1551     return &quot;WTFMove(${name})&quot; if $type-&gt;isNullable;
1552 
1553     if ($codeGenerator-&gt;IsBufferSourceType($type)) {
1554         return &quot;*${name}&quot; if $type-&gt;name eq &quot;ArrayBuffer&quot;;
1555         return &quot;${name}.releaseNonNull()&quot;;
1556     }
1557 
1558     return &quot;${name}.releaseNonNull()&quot; if $codeGenerator-&gt;IsCallbackInterface($type) || $codeGenerator-&gt;IsCallbackFunction($type) || ($codeGenerator-&gt;IsPromiseType($type) &amp;&amp; (ref($context) ne &quot;IDLArgument&quot; || !$context-&gt;isOptional));
1559     return &quot;*${name}&quot; if $codeGenerator-&gt;IsWrapperType($type);
1560     return &quot;WTFMove(${name})&quot;;
1561 }
1562 
1563 sub GetAttributeGetterName
1564 {
1565     my ($interface, $className, $attribute) = @_;
1566 
1567     return $codeGenerator-&gt;WK_lcfirst($className) . &quot;Constructor&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) if $attribute-&gt;isStatic;
1568     return GetJSBuiltinFunctionName($className, $attribute) if IsJSBuiltin($interface, $attribute);
1569     return &quot;js&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) ? &quot;Constructor&quot; : &quot;&quot;);
1570 }
1571 
1572 sub GetAttributeSetterName
1573 {
1574     my ($interface, $className, $attribute) = @_;
1575 
1576     return &quot;set&quot; . $codeGenerator-&gt;WK_ucfirst($className) . &quot;Constructor&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) if $attribute-&gt;isStatic;
1577     return &quot;set&quot; . $codeGenerator-&gt;WK_ucfirst(GetJSBuiltinFunctionName($className, $attribute)) if IsJSBuiltin($interface, $attribute);
1578     return &quot;setJS&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) ? &quot;Constructor&quot; : &quot;&quot;);
1579 }
1580 
1581 sub GetFunctionName
1582 {
1583     my ($interface, $className, $operation) = @_;
1584 
1585     return GetJSBuiltinFunctionName($className, $operation) if IsJSBuiltin($interface, $operation);
1586 
1587     my $functionName = $operation-&gt;name;
1588     $functionName = &quot;SymbolIterator&quot; if $functionName eq &quot;[Symbol.Iterator]&quot;;
1589 
1590     my $kind = $operation-&gt;isStatic ? &quot;Constructor&quot; : (OperationShouldBeOnInstance($interface, $operation) ? &quot;Instance&quot; : &quot;Prototype&quot;);
1591     return $codeGenerator-&gt;WK_lcfirst($className) . $kind . &quot;Function&quot; . $codeGenerator-&gt;WK_ucfirst($functionName);
1592 }
1593 
1594 sub GetFullyQualifiedImplementationCallName
1595 {
1596     my ($interface, $property, $implementationName, $implExpression, $conditional) = @_;
1597     
1598     my $implementedBy = $property-&gt;extendedAttributes-&gt;{ImplementedBy};
1599     if ($implementedBy) {
1600         AddToImplIncludes(&quot;${implementedBy}.h&quot;, $conditional);
1601         return &quot;WebCore::${implementedBy}::${implementationName}&quot;;
1602     }
1603     
1604     if ($property-&gt;isStatic || $property-&gt;extendedAttributes-&gt;{Constructor} || $property-&gt;extendedAttributes-&gt;{NamedConstructor}) {
1605         return $interface-&gt;type-&gt;name . &quot;::${implementationName}&quot;;
1606     }
1607     
1608     if ($property-&gt;isMapLike) {
1609         return &quot;forward&quot; . $codeGenerator-&gt;WK_ucfirst($property-&gt;name) . &quot;ToMapLike&quot;;
1610     }
1611     
1612     return &quot;${implExpression}.${implementationName}&quot;;
1613 }
1614 
1615 sub AddAdditionalArgumentsForImplementationCall
1616 {
1617     my ($arguments, $interface, $property, $implExpression, $stateExpression, $thisObjectExpression) = @_;
1618     
1619     if ($property-&gt;extendedAttributes-&gt;{ImplementedBy} &amp;&amp; !$property-&gt;isStatic) {
1620         unshift(@$arguments, $implExpression);
1621     }
1622     
1623     if ($property-&gt;isMapLike) {
1624         push(@$arguments, $stateExpression);
1625         push(@$arguments, $thisObjectExpression);
1626     }
1627 }
1628 
1629 sub GetSpecialAccessorOperationForType
1630 {
1631     my ($interface, $special, $firstParameterType, $numberOfParameters) = @_;
1632 
1633     foreach my $operation (@{$interface-&gt;operations}, @{$interface-&gt;anonymousOperations}) {
1634         my $specials = $operation-&gt;specials;
1635         my $specialExists = grep { $_ eq $special } @$specials;
1636         my $arguments = $operation-&gt;arguments;
1637         if ($specialExists and scalar(@$arguments) == $numberOfParameters and $arguments-&gt;[0]-&gt;type-&gt;name eq $firstParameterType) {
1638             return $operation;
1639         }
1640     }
1641 
1642     return 0;
1643 }
1644 
1645 sub IsGlobalOrPrimaryGlobalInterface
1646 {
1647     my $interface = shift;
1648 
1649     return $interface-&gt;extendedAttributes-&gt;{Global} || $interface-&gt;extendedAttributes-&gt;{PrimaryGlobal};
1650 }
1651 
1652 sub AttributeShouldBeOnInstance
1653 {
1654     my $interface = shift;
1655     my $attribute = shift;
1656 
1657     return 1 if IsGlobalOrPrimaryGlobalInterface($interface);
1658     return 1 if $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1659 
1660     # [Unforgeable] attributes should be on the instance.
1661     # https://heycam.github.io/webidl/#Unforgeable
1662     return 1 if IsUnforgeable($interface, $attribute);
1663 
1664     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity}) {
1665         return 0 if $attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity};
1666         return 0 if $attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnGetter};
1667         return 1;
1668     }
1669 
1670     return 0;
1671 }
1672 
1673 sub IsAlwaysExposedOnInterface
1674 {
1675     my ($interfaceExposures, $contextExposures) = @_;
1676 
1677     my %contextExposureSet = ();
1678 
1679     if (ref($contextExposures) eq &quot;ARRAY&quot;) {
1680         foreach my $contextExposure (@$contextExposures) {
1681             $contextExposureSet{$contextExposure} = 1;
1682         }
1683     } else {
1684         $contextExposureSet{$contextExposures} = 1;
1685     }
1686 
1687     if (ref($interfaceExposures) ne &quot;ARRAY&quot;) {
1688         $interfaceExposures = [$interfaceExposures];
1689     }
1690 
1691     foreach my $interfaceExposure (@$interfaceExposures) {
1692         return 0 unless exists $contextExposureSet{$interfaceExposure};
1693     }
1694 
1695     return 1;
1696 }
1697 
1698 sub NeedsRuntimeCheck
1699 {
1700     my ($interface, $context) = @_;
1701 
1702     if ($context-&gt;extendedAttributes-&gt;{Exposed}) {
1703         my $interfaceExposures = $interface-&gt;extendedAttributes-&gt;{Exposed} || &quot;Window&quot;;
1704         return 1 if !IsAlwaysExposedOnInterface($interfaceExposures, $context-&gt;extendedAttributes-&gt;{Exposed});
1705     }
1706 
1707     return $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}
1708         || $context-&gt;extendedAttributes-&gt;{EnabledForWorld}
1709         || $context-&gt;extendedAttributes-&gt;{EnabledBySetting}
1710         || $context-&gt;extendedAttributes-&gt;{DisabledByQuirk}
1711         || $context-&gt;extendedAttributes-&gt;{SecureContext}
1712         || $context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme};
1713 }
1714 
1715 # https://heycam.github.io/webidl/#es-operations
1716 sub OperationShouldBeOnInstance
1717 {
1718     my ($interface, $operation) = @_;
1719 
1720     return 1 if IsGlobalOrPrimaryGlobalInterface($interface);
1721 
1722     # [Unforgeable] operations should be on the instance. https://heycam.github.io/webidl/#Unforgeable
1723     if (IsUnforgeable($interface, $operation)) {
1724         assert(&quot;The bindings generator does not support putting runtime-enabled operations on the instance yet (except for global objects):[&quot; . $interface-&gt;type-&gt;name . &quot;::&quot; . $operation-&gt;name . &quot;]&quot;) if NeedsRuntimeCheck($interface, $operation);
1725         return 1;
1726     }
1727 
1728     return 0;
1729 }
1730 
1731 sub OperationHasForcedReturnValue
1732 {
1733     my ($operation) = @_;
1734 
1735     foreach my $argument (@{$operation-&gt;arguments}) {
1736         return 1 if $argument-&gt;extendedAttributes-&gt;{ReturnValue};
1737     }
1738     return 0;
1739 }
1740 
1741 sub IsAcceleratedDOMAttribute
1742 {
1743     my ($interface, $attribute) = @_;
1744 
1745     # If we use CustomGetterSetter in IDL code generator we cannot skip type check.
1746     return 0 if NeedsRuntimeCheck($interface, $attribute) and AttributeShouldBeOnInstance($interface, $attribute);
1747     return 0 if $attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier} and AttributeShouldBeOnInstance($interface, $attribute);
1748 
1749     # If the interface has special logic for casting we cannot hoist type check to JSC.
1750     return 0 if $interface-&gt;extendedAttributes-&gt;{ImplicitThis};
1751     return 0 if $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject};
1752 
1753     return 0 if $attribute-&gt;isStatic;
1754     return 0 if $attribute-&gt;isMapLike;
1755     return 0 if $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1756     return 0 if IsJSBuiltin($interface, $attribute);
1757     return 0 if $attribute-&gt;extendedAttributes-&gt;{LenientThis};
1758     return 0 if $codeGenerator-&gt;IsPromiseType($attribute-&gt;type);
1759     return 0 if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
1760     return 1;
1761 }
1762 
1763 sub GetJSCAttributesForAttribute
1764 {
1765     my $interface = shift;
1766     my $attribute = shift;
1767 
1768     my @specials = ();
1769     push(@specials, &quot;JSC::PropertyAttribute::DontDelete&quot;) if IsUnforgeable($interface, $attribute);
1770 
1771     # As per Web IDL specification, constructor properties on the ECMAScript global object should not be enumerable.
1772     my $isGlobalConstructor = $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1773     push(@specials, &quot;JSC::PropertyAttribute::DontEnum&quot;) if ($attribute-&gt;extendedAttributes-&gt;{NotEnumerable} || $isGlobalConstructor);
1774     push(@specials, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if IsReadonly($attribute);
1775     push(@specials, &quot;JSC::PropertyAttribute::CustomAccessor&quot;) unless $isGlobalConstructor or IsJSBuiltin($interface, $attribute);
1776     push(@specials, &quot;JSC::PropertyAttribute::DOMAttribute&quot;) if IsAcceleratedDOMAttribute($interface, $attribute);
1777     push(@specials, &quot;JSC::PropertyAttribute::DOMJITAttribute&quot;) if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
1778     push(@specials, &quot;JSC::PropertyAttribute::Accessor | JSC::PropertyAttribute::Builtin&quot;) if  IsJSBuiltin($interface, $attribute);
1779     return &quot;static_cast&lt;unsigned&gt;(&quot; . ((@specials &gt; 0) ? join(&quot; | &quot;, @specials) : &quot;0&quot;) . &quot;)&quot;;
1780 }
1781 
1782 sub GetIndexedGetterOperation
1783 {
1784     my $interface = shift;
1785     return GetSpecialAccessorOperationForType($interface, &quot;getter&quot;, &quot;unsigned long&quot;, 1);
1786 }
1787 
1788 sub GetIndexedSetterOperation
1789 {
1790     my $interface = shift;
1791     return GetSpecialAccessorOperationForType($interface, &quot;setter&quot;, &quot;unsigned long&quot;, 2);
1792 }
1793 
1794 sub GetNamedGetterOperation
1795 {
1796     my $interface = shift;
1797     return GetSpecialAccessorOperationForType($interface, &quot;getter&quot;, &quot;DOMString&quot;, 1);
1798 }
1799 
1800 sub GetNamedSetterOperation
1801 {
1802     my $interface = shift;
1803     return GetSpecialAccessorOperationForType($interface, &quot;setter&quot;, &quot;DOMString&quot;, 2);
1804 }
1805 
1806 sub GetNamedDeleterOperation
1807 {
1808     my $interface = shift;
1809     return GetSpecialAccessorOperationForType($interface, &quot;deleter&quot;, &quot;DOMString&quot;, 1);
1810 }
1811 
1812 sub InstanceOperationCount
1813 {
1814     my $interface = shift;
1815     my $count = 0;
1816 
1817     foreach my $operation (@{$interface-&gt;operations}) {
1818         $count++ if OperationShouldBeOnInstance($interface, $operation);
1819     }
1820 
1821     return $count;
1822 }
1823 
1824 sub PrototypeOperationCount
1825 {
1826     my $interface = shift;
1827     my $count = 0;
1828 
1829     foreach my $operation (@{$interface-&gt;operations}) {
1830         $count++ if !$operation-&gt;isStatic &amp;&amp; !OperationShouldBeOnInstance($interface, $operation);
1831     }
1832 
1833     $count += scalar @{$interface-&gt;iterable-&gt;operations} if $interface-&gt;iterable;
1834     $count += scalar @{$interface-&gt;mapLike-&gt;operations} if $interface-&gt;mapLike;
1835     $count += scalar @{$interface-&gt;serializable-&gt;operations} if $interface-&gt;serializable;
1836 
1837     return $count;
1838 }
1839 
1840 sub InstancePropertyCount
1841 {
1842     my $interface = shift;
1843     my $count = 0;
1844     foreach my $attribute (@{$interface-&gt;attributes}) {
1845         $count++ if AttributeShouldBeOnInstance($interface, $attribute);
1846     }
1847     $count += InstanceOperationCount($interface);
1848     return $count;
1849 }
1850 
1851 sub PrototypePropertyCount
1852 {
1853     my $interface = shift;
1854     my $count = 0;
1855     foreach my $attribute (@{$interface-&gt;attributes}) {
1856         $count++ if !AttributeShouldBeOnInstance($interface, $attribute);
1857     }
1858     $count += PrototypeOperationCount($interface);
1859     $count++ if NeedsConstructorProperty($interface);
1860     return $count;
1861 }
1862 
1863 sub InstanceOverridesGetOwnPropertySlot
1864 {
1865     my $interface = shift;
1866     return $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot}
1867         || $interface-&gt;extendedAttributes-&gt;{Plugin}
1868         || GetIndexedGetterOperation($interface)
1869         || GetNamedGetterOperation($interface);
1870 }
1871 
1872 sub InstanceOverridesGetOwnPropertyNames
1873 {
1874     my $interface = shift;
1875     return $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertyNames}
1876         || GetIndexedGetterOperation($interface)
1877         || GetNamedGetterOperation($interface);
1878 }
1879 
1880 sub InstanceOverridesPut
1881 {
1882     my $interface = shift;
1883     return $interface-&gt;extendedAttributes-&gt;{CustomPut}
1884         || $interface-&gt;extendedAttributes-&gt;{Plugin}
1885         || GetIndexedSetterOperation($interface)
1886         || GetNamedSetterOperation($interface);
1887 }
1888 
1889 sub InstanceOverridesDefineOwnProperty
1890 {
1891     my $interface = shift;
1892 
1893     return 0 if $interface-&gt;extendedAttributes-&gt;{DefaultDefineOwnProperty};
1894 
1895     return $interface-&gt;extendedAttributes-&gt;{CustomDefineOwnProperty}
1896         || GetIndexedSetterOperation($interface)
1897         || GetNamedSetterOperation($interface);
1898 }
1899 
1900 sub InstanceOverridesDeleteProperty
1901 {
1902     my $interface = shift;
1903     return $interface-&gt;extendedAttributes-&gt;{CustomDeleteProperty}
1904         || GetNamedDeleterOperation($interface);
1905 }
1906 
1907 sub PrototypeHasStaticPropertyTable
1908 {
1909     my $interface = shift;
1910     my $numConstants = @{$interface-&gt;constants};
1911     return $numConstants &gt; 0 || PrototypePropertyCount($interface) &gt; 0;
1912 }
1913 
1914 sub InstanceNeedsVisitChildren
1915 {
1916     my $interface = shift;
1917     
1918     foreach my $attribute (@{$interface-&gt;attributes}) {
1919         return 1 if $attribute-&gt;extendedAttributes-&gt;{CachedAttribute};
1920     }
1921 
1922     return 1 if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
1923     return 1 if $interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost};
1924     return 0;
1925 }
1926 
1927 sub InstanceNeedsEstimatedSize
1928 {
1929     my $interface = shift;
1930     return $interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost};
1931 }
1932 
1933 sub GetImplClassName
1934 {
1935     my $interface = shift;
1936 
1937     return $interface-&gt;type-&gt;name;
1938 }
1939 
1940 sub IsClassNameWordBoundary
1941 {
1942     my ($name, $i) = @_;
1943 
1944     # Interpret negative numbers as distance from end of string, just as the substr function does.
1945     $i += length($name) if $i &lt; 0;
1946 
1947     return 0 if $i &lt; 0;
1948     return 1 if $i == 0;
1949     return 1 if $i == length($name);
1950     return 0 if $i &gt; length($name);
1951 
1952     my $checkString = substr($name, $i - 1);
1953     return $checkString =~ /^[^A-Z][A-Z]/ || $checkString =~ /^[A-Z][A-Z][^A-Z]/;
1954 }
1955 
1956 sub IsPrefixRemovable
1957 {
1958     my ($class, $name, $i) = @_;
1959 
1960     return IsClassNameWordBoundary($name, $i)
1961         &amp;&amp; (IsClassNameWordBoundary($class, $i) &amp;&amp; substr($class, 0, $i) eq substr($name, 0, $i)
1962             || IsClassNameWordBoundary($class, -$i) &amp;&amp; substr($class, -$i) eq substr($name, 0, $i));
1963 }
1964 
1965 sub GetNestedClassName
1966 {
1967     my ($interface, $name) = @_;
1968 
1969     my $class = GetImplClassName($interface);
1970     my $member = $codeGenerator-&gt;WK_ucfirst($name);
1971 
1972     # Since the enumeration name will be nested in the class name&#39;s namespace, remove any words
1973     # that happen to match the start or end of the class name. If an enumeration is named TrackType or
1974     # TextTrackType, and the class is named TextTrack, then we will get a name like TextTrack::Type.
1975     my $memberLength = length($member);
1976     my $longestPrefixLength = 0;
1977     if ($member =~ /^[A-Z]./) {
1978         for (my $i = 2; $i &lt; $memberLength - 1; $i++) {
1979             $longestPrefixLength = $i if IsPrefixRemovable($class, $member, $i);
1980         }
1981     }
1982     $member = substr($member, $longestPrefixLength);
1983 
1984     return &quot;${class}::$member&quot;;
1985 }
1986 
1987 sub GetEnumerationClassName
1988 {
1989     my ($type, $interface) = @_;
1990 
1991     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1992 
1993     if ($codeGenerator-&gt;HasEnumImplementationNameOverride($type)) {
1994         return $codeGenerator-&gt;GetEnumImplementationNameOverride($type);
1995     }
1996 
1997     my $name = $type-&gt;name;
1998 
1999     return $name if $codeGenerator-&gt;IsExternalEnumType($type);
2000     return $name unless defined($interface);
2001 
2002     return GetNestedClassName($interface, $name);
2003 }
2004 
2005 sub GetEnumerationValueName
2006 {
2007     my ($name) = @_;
2008 
2009     return &quot;EmptyString&quot; if $name eq &quot;&quot;;
2010     $name = join(&quot;&quot;, map { $codeGenerator-&gt;WK_ucfirst($_) } split(&quot;-&quot;, $name));
2011     $name = &quot;_$name&quot; if $name =~ /^\d/;
2012     return $name;
2013 }
2014 
2015 sub GenerateEnumerationHeader
2016 {
2017     my ($object, $enumeration, $className) = @_;
2018  
2019     # - Add default header template and header protection.
2020     push(@headerContentHeader, GenerateHeaderContentHeader($enumeration));
2021 
2022     $headerIncludes{&quot;${className}.h&quot;} = 1;
2023 
2024     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
2025     push(@headerContent, GenerateEnumerationHeaderContent($enumeration, $className));
2026     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
2027      
2028     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2029     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
2030 }
2031  
2032 sub GenerateEnumerationImplementation
2033 {
2034     my ($object, $enumeration, $className) = @_;
2035  
2036     # - Add default header template
2037     push(@implContentHeader, GenerateImplementationContentHeader($enumeration));
2038 
2039     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
2040     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
2041     push(@implContent, GenerateEnumerationImplementationContent($enumeration, $className));
2042     push(@implContent, &quot;} // namespace WebCore\n&quot;);
2043      
2044     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2045     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
2046 }
2047 
2048 sub GenerateEnumerationImplementationContent
2049 {
2050     my ($enumeration, $className, $interface, $conditionalString) = @_;
2051 
2052     # FIXME: A little ugly to have this be a side effect instead of a return value.
2053     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSString.h&gt;&quot;);
2054     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
2055     AddToImplIncludes(&quot;JSDOMConvertEnumeration.h&quot;);
2056 
2057     my $result = &quot;&quot;;
2058     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
2059 
2060 
2061     $result .= &quot;String convertEnumerationToString($className enumerationValue)\n&quot;;
2062     $result .= &quot;{\n&quot;;
2063     AddToImplIncludes(&quot;&lt;wtf/NeverDestroyed.h&gt;&quot;);
2064     $result .= &quot;    static const NeverDestroyed&lt;String&gt; values[] = {\n&quot;;
2065     foreach my $value (@{$enumeration-&gt;values}) {
2066         if ($value eq &quot;&quot;) {
2067             $result .= &quot;        emptyString(),\n&quot;;
2068         } else {
2069             $result .= &quot;        MAKE_STATIC_STRING_IMPL(\&quot;$value\&quot;),\n&quot;;
2070         }
2071     }
2072     $result .= &quot;    };\n&quot;;
2073     my $index = 0;
2074     foreach my $value (@{$enumeration-&gt;values}) {
2075         my $enumerationValueName = GetEnumerationValueName($value);
2076         $result .= &quot;    static_assert(static_cast&lt;size_t&gt;(${className}::$enumerationValueName) == $index, \&quot;${className}::$enumerationValueName is not $index as expected\&quot;);\n&quot;;
2077         $index++;
2078     }
2079     $result .= &quot;    ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));\n&quot;;
2080     $result .= &quot;    return values[static_cast&lt;size_t&gt;(enumerationValue)];\n&quot;;
2081     $result .= &quot;}\n\n&quot;;
2082 
2083 
2084     # FIXME: Change to take VM&amp; instead of ExecState*.
2085     $result .= &quot;template&lt;&gt; JSString* convertEnumerationToJS(ExecState&amp; state, $className enumerationValue)\n&quot;;
2086     $result .= &quot;{\n&quot;;
2087     $result .= &quot;    return jsStringWithCache(&amp;state, convertEnumerationToString(enumerationValue));\n&quot;;
2088     $result .= &quot;}\n\n&quot;;
2089 
2090     # FIXME: Change to take VM&amp; instead of ExecState&amp;.
2091     # FIXME: Consider using toStringOrNull to make exception checking faster.
2092     # FIXME: Consider finding a more efficient way to match against all the strings quickly.
2093     $result .= &quot;template&lt;&gt; Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(ExecState&amp; state, JSValue value)\n&quot;;
2094     $result .= &quot;{\n&quot;;
2095     $result .= &quot;    auto stringValue = value.toWTFString(&amp;state);\n&quot;;
2096     foreach my $value (@{$enumeration-&gt;values}) {
2097         my $enumerationValueName = GetEnumerationValueName($value);
2098         if ($value eq &quot;&quot;) {
2099             $result .= &quot;    if (stringValue.isEmpty())\n&quot;;
2100         } else {
2101             $result .= &quot;    if (stringValue == \&quot;$value\&quot;)\n&quot;;
2102         }
2103         $result .= &quot;        return ${className}::${enumerationValueName};\n&quot;;
2104     }
2105     $result .= &quot;    return WTF::nullopt;\n&quot;;
2106     $result .= &quot;}\n\n&quot;;
2107 
2108     $result .= &quot;template&lt;&gt; const char* expectedEnumerationValues&lt;$className&gt;()\n&quot;;
2109     $result .= &quot;{\n&quot;;
2110     $result .= &quot;    return \&quot;\\\&quot;&quot; . join (&quot;\\\&quot;, \\\&quot;&quot;, @{$enumeration-&gt;values}) . &quot;\\\&quot;\&quot;;\n&quot;;
2111     $result .= &quot;}\n\n&quot;;
2112 
2113     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2114 
2115     return $result;
2116 }
2117 
2118 sub GenerateEnumerationsImplementationContent
2119 {
2120     my ($interface, $enumerations) = @_;
2121 
2122     return &quot;&quot; unless @$enumerations;
2123 
2124     my $result = &quot;&quot;;
2125     foreach my $enumeration (@$enumerations) {
2126         my $className = GetEnumerationClassName($enumeration-&gt;type, $interface);
2127         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2128         $result .= GenerateEnumerationImplementationContent($enumeration, $className, $interface, $conditionalString);
2129     }
2130     return $result;
2131 }
2132 
2133 sub GenerateEnumerationHeaderContent
2134 {
2135     my ($enumeration, $className, $conditionalString) = @_;
2136 
2137     $headerIncludes{&quot;JSDOMConvertEnumeration.h&quot;} = 1;
2138 
2139     my $result = &quot;&quot;;
2140     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
2141 
2142     my $exportMacro = GetExportMacroForJSClass($enumeration);
2143 
2144     $result .= &quot;${exportMacro}String convertEnumerationToString($className);\n&quot;;
2145     $result .= &quot;template&lt;&gt; ${exportMacro}JSC::JSString* convertEnumerationToJS(JSC::ExecState&amp;, $className);\n\n&quot;;
2146     $result .= &quot;template&lt;&gt; ${exportMacro}Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(JSC::ExecState&amp;, JSC::JSValue);\n&quot;;
2147     $result .= &quot;template&lt;&gt; ${exportMacro}const char* expectedEnumerationValues&lt;$className&gt;();\n\n&quot;;
2148     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2149     
2150     return $result;
2151 }
2152 
2153 sub GenerateEnumerationsHeaderContent
2154 {
2155     my ($interface, $enumerations) = @_;
2156 
2157     return &quot;&quot; unless @$enumerations;
2158 
2159     # FIXME: Could optimize this to only generate the parts of each enumeration that are actually
2160     # used, which would require iterating over everything in the interface.
2161 
2162     my $result = &quot;&quot;;
2163     foreach my $enumeration (@$enumerations) {
2164         my $className = GetEnumerationClassName($enumeration-&gt;type, $interface);
2165         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2166         $result .= GenerateEnumerationHeaderContent($enumeration, $className, $conditionalString);
2167     }
2168     return $result;
2169 }
2170 
2171 sub GetDictionaryClassName
2172 {
2173     my ($type, $interface) = @_;
2174 
2175     if ($codeGenerator-&gt;HasDictionaryImplementationNameOverride($type)) {
2176         return $codeGenerator-&gt;GetDictionaryImplementationNameOverride($type);
2177     }
2178 
2179     my $name = $type-&gt;name;
2180     return $name if $codeGenerator-&gt;IsExternalDictionaryType($type);
2181     return $name unless defined($interface);
2182     return GetNestedClassName($interface, $name);
2183 }
2184 
2185 sub GenerateDefaultValue
2186 {
2187     my ($typeScope, $context, $type, $defaultValue) = @_;
2188 
2189     if ($codeGenerator-&gt;IsStringType($type)) {
2190         my $useAtomicString = $type-&gt;extendedAttributes-&gt;{AtomicString};
2191         if ($defaultValue eq &quot;null&quot;) {
2192             return $useAtomicString ? &quot;nullAtom()&quot; : &quot;String()&quot;;
2193         } elsif ($defaultValue eq &quot;\&quot;\&quot;&quot;) {
2194             return $useAtomicString ? &quot;emptyAtom()&quot; : &quot;emptyString()&quot;;
2195         } else {
2196             return $useAtomicString ? &quot;AtomicString(${defaultValue}, AtomicString::ConstructFromLiteral)&quot; : &quot;${defaultValue}_s&quot;;
2197         }
2198     }
2199 
2200     if ($codeGenerator-&gt;IsEnumType($type)) {
2201         # FIXME: Would be nice to report an error if the value does not have quote marks around it.
2202         # FIXME: Would be nice to report an error if the value is not one of the enumeration values.
2203         if ($defaultValue eq &quot;null&quot;) {
2204             die if !$type-&gt;isNullable;
2205             return &quot;WTF::nullopt&quot;;
2206         }
2207         my $className = GetEnumerationClassName($type, $typeScope);
2208         my $enumerationValueName = GetEnumerationValueName(substr($defaultValue, 1, -1));
2209         return $className . &quot;::&quot; . $enumerationValueName;
2210     }
2211     if ($defaultValue eq &quot;null&quot;) {
2212         if ($type-&gt;isUnion) {
2213             return &quot;WTF::nullopt&quot; if $type-&gt;isNullable;
2214 
2215             my $IDLType = GetIDLType($typeScope, $type);
2216             return &quot;convert&lt;${IDLType}&gt;(state, jsNull());&quot;;
2217         }
2218 
2219         return &quot;jsNull()&quot; if $type-&gt;name eq &quot;any&quot;;
2220         return &quot;nullptr&quot; if $codeGenerator-&gt;IsWrapperType($type) || $codeGenerator-&gt;IsBufferSourceType($type);
2221         return &quot;String()&quot; if $codeGenerator-&gt;IsStringType($type);
2222         return &quot;WTF::nullopt&quot;;
2223     }
2224 
2225     if ($defaultValue eq &quot;[]&quot;) {
2226         my $IDLType = GetIDLType($typeScope, $type);
2227         return &quot;Converter&lt;${IDLType}&gt;::ReturnType{ }&quot;;
2228     }
2229 
2230     return &quot;jsUndefined()&quot; if $defaultValue eq &quot;undefined&quot;;
2231     return &quot;PNaN&quot; if $defaultValue eq &quot;NaN&quot;;
2232 
2233     return $defaultValue;
2234 }
2235 
2236 sub GenerateDictionaryHeaderContent
2237 {
2238     my ($dictionary, $className, $conditionalString) = @_;
2239 
2240     $headerIncludes{&quot;JSDOMConvertDictionary.h&quot;} = 1;
2241 
2242     my $exportMacro = GetExportMacroForJSClass($dictionary);
2243 
2244     my $result = &quot;&quot;;
2245     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
2246     $result .= &quot;template&lt;&gt; ${exportMacro}${className} convertDictionary&lt;${className}&gt;(JSC::ExecState&amp;, JSC::JSValue);\n\n&quot;;
2247 
2248     if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
2249         $result .= &quot;${exportMacro}JSC::JSObject* convertDictionaryToJS(JSC::ExecState&amp;, JSDOMGlobalObject&amp;, const ${className}&amp;);\n\n&quot;;
2250     }
2251 
2252     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2253     return $result;
2254 }
2255 
2256 sub GenerateDictionariesHeaderContent
2257 {
2258     my ($typeScope, $allDictionaries) = @_;
2259 
2260     return &quot;&quot; unless @$allDictionaries;
2261 
2262     my $result = &quot;&quot;;
2263     foreach my $dictionary (@$allDictionaries) {
2264         $headerIncludes{$typeScope-&gt;type-&gt;name . &quot;.h&quot;} = 1 if $typeScope;
2265         my $className = GetDictionaryClassName($dictionary-&gt;type, $typeScope);
2266         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
2267         $result .= GenerateDictionaryHeaderContent($dictionary, $className, $conditionalString);
2268     }
2269     return $result;
2270 }
2271 
2272 sub GenerateDictionaryImplementationContent
2273 {
2274     my ($dictionary, $className, $interface) = @_;
2275 
2276     my $result = &quot;&quot;;
2277 
2278     my $name = $dictionary-&gt;type-&gt;name;
2279     my $typeScope = $interface || $dictionary;
2280 
2281     my $conditional = $dictionary-&gt;extendedAttributes-&gt;{Conditional};
2282     if ($conditional) {
2283         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
2284         $result .= &quot;#if ${conditionalString}\n\n&quot;;
2285     }
2286 
2287     # FIXME: A little ugly to have this be a side effect instead of a return value.
2288     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
2289     AddToImplIncludes(&quot;JSDOMConvertDictionary.h&quot;);
2290 
2291     # https://heycam.github.io/webidl/#es-dictionary
2292     $result .= &quot;template&lt;&gt; $className convertDictionary&lt;$className&gt;(ExecState&amp; state, JSValue value)\n&quot;;
2293     $result .= &quot;{\n&quot;;
2294     $result .= &quot;    VM&amp; vm = state.vm();\n&quot;;
2295     $result .= &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;;
2296     $result .= &quot;    bool isNullOrUndefined = value.isUndefinedOrNull();\n&quot;;
2297     $result .= &quot;    auto* object = isNullOrUndefined ? nullptr : value.getObject();\n&quot;;
2298 
2299     # 1. If Type(V) is not Undefined, Null or Object, then throw a TypeError.
2300     $result .= &quot;    if (UNLIKELY(!isNullOrUndefined &amp;&amp; !object)) {\n&quot;;
2301     $result .= &quot;        throwTypeError(&amp;state, throwScope);\n&quot;;
2302     $result .= &quot;        return { };\n&quot;;
2303     $result .= &quot;    }\n&quot;;
2304 
2305     # 2. Let dict be an empty dictionary value of type D; every dictionary member is initially considered to be not present.
2306 
2307     # 3. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries, in order from least to most derived.
2308     my @dictionaries;
2309     push(@dictionaries, $dictionary);
2310     my $parentType = $dictionary-&gt;parentType;
2311     while (defined($parentType)) {
2312         my $parentDictionary = $codeGenerator-&gt;GetDictionaryByType($parentType);
2313         assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless defined($parentDictionary);
2314         unshift(@dictionaries, $parentDictionary);
2315         $parentType = $parentDictionary-&gt;parentType;
2316     }
2317 
2318     my $arguments = &quot;&quot;;
2319     my $comma = &quot;&quot;;
2320 
2321     $result .= &quot;    $className result;\n&quot;;
2322 
2323     # 4. For each dictionary dictionary in dictionaries, in order:
2324     foreach my $dictionary (@dictionaries) {
2325         # For each dictionary member member declared on dictionary, in lexicographical order:
2326         my @sortedMembers = sort { $a-&gt;name cmp $b-&gt;name } @{$dictionary-&gt;members};
2327         foreach my $member (@sortedMembers) {
2328             $member-&gt;default(&quot;undefined&quot;) if $member-&gt;type-&gt;name eq &quot;any&quot; and !defined($member-&gt;default); # Use undefined as default value for member of type &#39;any&#39; unless specified otherwise.
2329 
2330             my $type = $member-&gt;type;
2331             AddToImplIncludesForIDLType($type);
2332 
2333             # 4.1. Let key be the identifier of member.
2334             my $key = $member-&gt;name;
2335             my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2336 
2337             # 4.2. Let value be an ECMAScript value, depending on Type(V):
2338             $result .= &quot;    JSValue ${key}Value;\n&quot;;
2339             $result .= &quot;    if (isNullOrUndefined)\n&quot;;
2340             $result .= &quot;        ${key}Value = jsUndefined();\n&quot;;
2341             $result .= &quot;    else {\n&quot;;
2342             $result .= &quot;        ${key}Value = object-&gt;get(&amp;state, Identifier::fromString(&amp;state, \&quot;${key}\&quot;));\n&quot;;
2343             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2344             $result .= &quot;    }\n&quot;;
2345 
2346             my $IDLType = GetIDLType($typeScope, $type);
2347 
2348             # 4.3. If value is not undefined, then:
2349             $result .= &quot;    if (!${key}Value.isUndefined()) {\n&quot;;
2350 
2351             my $nativeValue = JSValueToNative($typeScope, $member, &quot;${key}Value&quot;, $member-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;state&quot;, &quot;state&quot;, &quot;&quot;, &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())&quot;);
2352             $result .= &quot;        result.$implementedAsKey = $nativeValue;\n&quot;;
2353             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2354 
2355             # Value is undefined.
2356             # 4.4. Otherwise, if value is undefined but the dictionary member has a default value, then:
2357             if (!$member-&gt;isRequired &amp;&amp; defined $member-&gt;default) {
2358                 $result .= &quot;    } else\n&quot;;
2359                 $result .= &quot;        result.$implementedAsKey = &quot; . GenerateDefaultValue($typeScope, $member, $member-&gt;type, $member-&gt;default) . &quot;;\n&quot;;
2360             } elsif ($member-&gt;isRequired) {
2361                 # 4.5. Otherwise, if value is undefined and the dictionary member is a required dictionary member, then throw a TypeError.
2362                 $result .= &quot;    } else {\n&quot;;
2363                 $result .= &quot;        throwRequiredMemberTypeError(state, throwScope, \&quot;&quot;. $member-&gt;name .&quot;\&quot;, \&quot;$name\&quot;, \&quot;&quot;. GetTypeNameForDisplayInException($type) .&quot;\&quot;);\n&quot;;
2364                 $result .= &quot;        return { };\n&quot;;
2365                 $result .= &quot;    }\n&quot;;
2366             } else {
2367                 $result .= &quot;    }\n&quot;;
2368             }
2369         }
2370     }
2371 
2372     # 5. Return dict.
2373     $result .= &quot;    return result;\n&quot;;
2374     $result .= &quot;}\n\n&quot;;
2375 
2376     if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
2377         AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;);
2378         AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
2379 
2380         $result .= &quot;JSC::JSObject* convertDictionaryToJS(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const ${className}&amp; dictionary)\n&quot;;
2381         $result .= &quot;{\n&quot;;
2382         $result .= &quot;    auto&amp; vm = state.vm();\n\n&quot;;
2383 
2384         # 1. Let O be ! ObjectCreate(%ObjectPrototype%).
2385         $result .= &quot;    auto result = constructEmptyObject(&amp;state, globalObject.objectPrototype());\n\n&quot;;
2386 
2387         # 2. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries,
2388         #    in order from least to most derived.
2389         #    NOTE: This was done above.
2390 
2391         # 3. For each dictionary dictionary in dictionaries, in order:
2392         foreach my $dictionary (@dictionaries) {
2393             # 3.1. For each dictionary member member declared on dictionary, in lexicographical order:
2394             my @sortedMembers = sort { $a-&gt;name cmp $b-&gt;name } @{$dictionary-&gt;members};
2395             foreach my $member (@sortedMembers) {
2396                 my $key = $member-&gt;name;
2397                 my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2398                 my $valueExpression = &quot;dictionary.${implementedAsKey}&quot;;
2399 
2400                 # 1. Let key be the identifier of member.
2401                 # 2. If the dictionary member named key is present in V, then:
2402                     # 1. Let idlValue be the value of member on V.
2403                     # 2. Let value be the result of converting idlValue to an ECMAScript value.
2404                     # 3. Perform ! CreateDataProperty(O, key, value).
2405 
2406                 if (!$member-&gt;isRequired &amp;&amp; not defined $member-&gt;default) {
2407                     my $IDLType = GetIDLType($typeScope, $member-&gt;type);
2408                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, &quot;${IDLType}::extractValueFromNullable(${valueExpression})&quot;, &quot;globalObject&quot;);
2409 
2410                     $result .= &quot;    if (!${IDLType}::isNullValue(${valueExpression})) {\n&quot;;
2411                     $result .= &quot;        auto ${key}Value = ${conversionExpression};\n&quot;;
2412                     $result .= &quot;        result-&gt;putDirect(vm, JSC::Identifier::fromString(&amp;vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;
2413                     $result .= &quot;    }\n&quot;;
2414                 } else {
2415                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, $valueExpression, &quot;globalObject&quot;);
2416 
2417                     $result .= &quot;    auto ${key}Value = ${conversionExpression};\n&quot;;
2418                     $result .= &quot;    result-&gt;putDirect(vm, JSC::Identifier::fromString(&amp;vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;
2419                 }
2420             }
2421         }
2422 
2423         $result .= &quot;    return result;\n&quot;;
2424         $result .= &quot;}\n\n&quot;;
2425     }
2426 
2427     $result .= &quot;#endif\n\n&quot; if $conditional;
2428 
2429     return $result;
2430 }
2431 
2432 sub GenerateDictionariesImplementationContent
2433 {
2434     my ($typeScope, $allDictionaries) = @_;
2435 
2436     my $result = &quot;&quot;;
2437     foreach my $dictionary (@$allDictionaries) {
2438         my $className = GetDictionaryClassName($dictionary-&gt;type, $typeScope);
2439         $result .= GenerateDictionaryImplementationContent($dictionary, $className, $typeScope);
2440     }
2441     return $result;
2442 }
2443 
2444 sub GetJSTypeForNode
2445 {
2446     my ($interface) = @_;
2447 
2448     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Document&quot;)) {
2449         return &quot;JSDocumentWrapperType&quot;;
2450     }
2451     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;DocumentFragment&quot;)) {
2452         return &quot;JSDocumentFragmentNodeType&quot;;
2453     }
2454     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;DocumentType&quot;)) {
2455         return &quot;JSDocumentTypeNodeType&quot;;
2456     }
2457     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;ProcessingInstruction&quot;)) {
2458         return &quot;JSProcessingInstructionNodeType&quot;;
2459     }
2460     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;CDATASection&quot;)) {
2461         return &quot;JSCDATASectionNodeType&quot;;
2462     }
2463     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Attr&quot;)) {
2464         return &quot;JSAttrNodeType&quot;;
2465     }
2466     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Comment&quot;)) {
2467         return &quot;JSCommentNodeType&quot;;
2468     }
2469     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Text&quot;)) {
2470         return &quot;JSTextNodeType&quot;;
2471     }
2472     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Element&quot;)) {
2473         return &quot;JSElementType&quot;;
2474     }
2475     return &quot;JSNodeType&quot;;
2476 }
2477 
2478 sub GenerateHeader
2479 {
2480     my ($object, $interface, $enumerations, $dictionaries) = @_;
2481 
2482     my $interfaceName = $interface-&gt;type-&gt;name;
2483     my $className = &quot;JS$interfaceName&quot;;
2484     my %structureFlags = ();
2485 
2486     my $hasParent = $interface-&gt;parentType || $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
2487     my $parentClassName = GetParentClassName($interface);
2488     my $needsVisitChildren = InstanceNeedsVisitChildren($interface);
2489 
2490     # - Add default header template and header protection
2491     push(@headerContentHeader, GenerateHeaderContentHeader($interface));
2492 
2493     if ($hasParent) {
2494         $headerIncludes{&quot;$parentClassName.h&quot;} = 1;
2495     } else {
2496         $headerIncludes{&quot;JSDOMWrapper.h&quot;} = 1;
2497         if ($interface-&gt;isException) {
2498             $headerIncludes{&quot;&lt;JavaScriptCore/ErrorPrototype.h&gt;&quot;} = 1;
2499         }
2500     }
2501 
2502     $headerIncludes{&quot;$interfaceName.h&quot;} = 1 if $hasParent &amp;&amp; $interface-&gt;extendedAttributes-&gt;{JSGenerateToNativeObject};
2503 
2504     $headerIncludes{&quot;SVGElement.h&quot;} = 1 if $className =~ /^JSSVG/;
2505 
2506     my $implType = GetImplClassName($interface);
2507 
2508     my $numConstants = @{$interface-&gt;constants};
2509     my $numAttributes = @{$interface-&gt;attributes};
2510     my $numOperations = @{$interface-&gt;operations};
2511 
2512     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
2513 
2514     if ($codeGenerator-&gt;IsSVGAnimatedType($interface-&gt;type)) {
2515         $headerIncludes{&quot;$interfaceName.h&quot;} = 1;
2516     } else {
2517         # Implementation class forward declaration
2518         if (IsDOMGlobalObject($interface)) {
2519             AddClassForwardIfNeeded($interface-&gt;type);
2520         }
2521     }
2522 
2523     push(@headerContent, &quot;class JSWindowProxy;\n\n&quot;) if $interfaceName eq &quot;DOMWindow&quot; or $interfaceName eq &quot;RemoteDOMWindow&quot;;
2524 
2525     my $exportMacro = GetExportMacroForJSClass($interface);
2526 
2527     # Class declaration
2528     push(@headerContent, &quot;class $exportMacro$className : public $parentClassName {\n&quot;);
2529 
2530     # Static create methods
2531     push(@headerContent, &quot;public:\n&quot;);
2532     push(@headerContent, &quot;    using Base = $parentClassName;\n&quot;);
2533     push(@headerContent, &quot;    using DOMWrapped = $implType;\n&quot;) if $hasParent;
2534 
2535     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2536         push(@headerContent, &quot;    static $className* create(JSC::VM&amp; vm, JSC::Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl, JSWindowProxy* proxy)\n&quot;);
2537         push(@headerContent, &quot;    {\n&quot;);
2538         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(vm.heap)) ${className}(vm, structure, WTFMove(impl), proxy);\n&quot;);
2539         push(@headerContent, &quot;        ptr-&gt;finishCreation(vm, proxy);\n&quot;);
2540         push(@headerContent, &quot;        return ptr;\n&quot;);
2541         push(@headerContent, &quot;    }\n\n&quot;);
2542     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
2543         push(@headerContent, &quot;    static $className* create(JSC::VM&amp; vm, JSC::Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl, JSC::JSProxy* proxy)\n&quot;);
2544         push(@headerContent, &quot;    {\n&quot;);
2545         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(vm.heap)) ${className}(vm, structure, WTFMove(impl));\n&quot;);
2546         push(@headerContent, &quot;        ptr-&gt;finishCreation(vm, proxy);\n&quot;);
2547         push(@headerContent, &quot;        return ptr;\n&quot;);
2548         push(@headerContent, &quot;    }\n\n&quot;);
2549     } elsif ($interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined}) {
2550         AddIncludesForImplementationTypeInHeader($implType);
2551         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
2552         push(@headerContent, &quot;    {\n&quot;);
2553         push(@headerContent, &quot;        globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(globalObject-&gt;vm(), \&quot;Allocated masquerading object\&quot;);\n&quot;);
2554         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject, WTFMove(impl));\n&quot;);
2555         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2556         push(@headerContent, &quot;        return ptr;\n&quot;);
2557         push(@headerContent, &quot;    }\n\n&quot;);
2558     } elsif (!NeedsImplementationClass($interface)) {
2559         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject)\n&quot;);
2560         push(@headerContent, &quot;    {\n&quot;);
2561         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject);\n&quot;);
2562         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2563         push(@headerContent, &quot;        return ptr;\n&quot;);
2564         push(@headerContent, &quot;    }\n\n&quot;);  
2565     } else {
2566         AddIncludesForImplementationTypeInHeader($implType);
2567         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
2568         push(@headerContent, &quot;    {\n&quot;);
2569         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject, WTFMove(impl));\n&quot;);
2570         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2571         push(@headerContent, &quot;        return ptr;\n&quot;);
2572         push(@headerContent, &quot;    }\n\n&quot;);
2573     }
2574 
2575     push(@headerContent, &quot;    static const bool needsDestruction = false;\n\n&quot;) if IsDOMGlobalObject($interface);
2576 
2577     $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1 if InstancePropertyCount($interface) &gt; 0;
2578     $structureFlags{&quot;JSC::NewImpurePropertyFiresWatchpoints&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{NewImpurePropertyFiresWatchpoints};
2579     $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObject};
2580     $structureFlags{&quot;JSC::MasqueradesAsUndefined&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined};
2581     $structureFlags{&quot;JSC::ImplementsHasInstance | JSC::ImplementsDefaultHasInstance&quot;} = 1 if $interfaceName eq &quot;DOMWindow&quot;;
2582         
2583     # Prototype
2584     unless (ShouldUseGlobalObjectPrototype($interface)) {
2585         push(@headerContent, &quot;    static JSC::JSObject* createPrototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
2586         push(@headerContent, &quot;    static JSC::JSObject* prototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
2587     }
2588 
2589     # JSValue to implementation type
2590     if (ShouldGenerateToWrapped($hasParent, $interface)) {
2591         # FIXME: Add extended attribute for this.
2592         my @toWrappedArguments = ();
2593         push(@toWrappedArguments, &quot;JSC::VM&amp;&quot;);
2594         push(@toWrappedArguments, &quot;JSC::ExecState&amp;&quot;) if $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot;;
2595         push(@toWrappedArguments, &quot;JSC::JSValue&quot;);
2596 
2597         my $toWrappedType = $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot; ? &quot;RefPtr&lt;${implType}&gt;&quot; : &quot;${implType}*&quot;;
2598 
2599         my $export = &quot;&quot;;
2600         $export = &quot;WEBCORE_EXPORT &quot; if $interface-&gt;extendedAttributes-&gt;{ExportToWrappedFunction};
2601         push(@headerContent, &quot;    static ${export}${toWrappedType} toWrapped(&quot; . join(&quot;, &quot;, @toWrappedArguments) . &quot;);\n&quot;);
2602     }
2603 
2604     $headerTrailingIncludes{&quot;${className}Custom.h&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{JSCustomHeader};
2605 
2606     my $namedGetterOperation = GetNamedGetterOperation($interface);
2607     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
2608 
2609     # FIXME: Why doesn&#39;t this also include Indexed Getters and [CustomGetOwnPropertySlot]
2610     if ($namedGetterOperation) {
2611         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;)) {
2612             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpure&quot;} = 1;
2613         } else {
2614             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpureForPropertyAbsence&quot;} = 1;
2615         }
2616     }
2617     
2618     # ClassInfo MethodTable declarations.
2619     
2620     if (InstanceOverridesGetOwnPropertySlot($interface)) {
2621         push(@headerContent, &quot;    static bool getOwnPropertySlot(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, JSC::PropertySlot&amp;);\n&quot;);
2622         $structureFlags{&quot;JSC::OverridesGetOwnPropertySlot&quot;} = 1;
2623         push(@headerContent, &quot;    static bool getOwnPropertySlotByIndex(JSC::JSObject*, JSC::ExecState*, unsigned propertyName, JSC::PropertySlot&amp;);\n&quot;);
2624         $structureFlags{&quot;JSC::InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero&quot;} = 1;
2625     }
2626     
2627     if (InstanceOverridesGetOwnPropertyNames($interface)) {
2628         push(@headerContent, &quot;    static void getOwnPropertyNames(JSC::JSObject*, JSC::ExecState*, JSC::PropertyNameArray&amp;, JSC::EnumerationMode = JSC::EnumerationMode());\n&quot;);
2629         $structureFlags{&quot;JSC::OverridesGetPropertyNames&quot;} = 1;
2630     }
2631     
2632     if (InstanceOverridesPut($interface)) {
2633         push(@headerContent, &quot;    static bool put(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);
2634         push(@headerContent, &quot;    static bool putByIndex(JSC::JSCell*, JSC::ExecState*, unsigned propertyName, JSC::JSValue, bool shouldThrow);\n&quot;);
2635     }
2636     
2637     if (InstanceOverridesDefineOwnProperty($interface)) {
2638         push(@headerContent, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);
2639     }
2640 
2641     if (InstanceOverridesDeleteProperty($interface)) {
2642         push(@headerContent, &quot;    static bool deleteProperty(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName);\n&quot;);
2643         push(@headerContent, &quot;    static bool deletePropertyByIndex(JSC::JSCell*, JSC::ExecState*, unsigned);\n&quot;);
2644     }
2645 
2646     if (InstanceOverridesGetCallData($interface)) {
2647         push(@headerContent, &quot;    static JSC::CallType getCallData(JSC::JSCell*, JSC::CallData&amp;);\n\n&quot;);
2648         $headerIncludes{&quot;&lt;JavaScriptCore/CallData.h&gt;&quot;} = 1;
2649         $structureFlags{&quot;JSC::OverridesGetCallData&quot;} = 1;
2650     }
2651     
2652     if ($interface-&gt;extendedAttributes-&gt;{CustomGetPrototype}) {
2653         push(@headerContent, &quot;    static JSC::JSValue getPrototype(JSC::JSObject*, JSC::ExecState*);\n&quot;);
2654     }
2655     
2656     if ($interface-&gt;extendedAttributes-&gt;{CustomToStringName}) {
2657         push(@headerContent, &quot;    static String toStringName(const JSC::JSObject*, JSC::ExecState*);\n&quot;);
2658     }
2659     
2660     if ($interface-&gt;extendedAttributes-&gt;{CustomPreventExtensions}) {
2661         push(@headerContent, &quot;    static bool preventExtensions(JSC::JSObject*, JSC::ExecState*);\n&quot;);
2662     }
2663 
2664     if (InstanceNeedsEstimatedSize($interface)) {
2665         push(@headerContent, &quot;    static size_t estimatedSize(JSCell*, JSC::VM&amp;);\n&quot;);
2666     }
2667     
2668     if (!$hasParent) {
2669         push(@headerContent, &quot;    static void destroy(JSC::JSCell*);\n&quot;);
2670     }
2671 
2672     # Class info
2673     if ($interfaceName eq &quot;Node&quot;) {
2674         push(@headerContent, &quot;\n&quot;);
2675         push(@headerContent, &quot;protected:\n&quot;);
2676         push(@headerContent, &quot;    static const JSC::ClassInfo s_info;\n&quot;);
2677         push(@headerContent, &quot;public:\n&quot;);
2678         push(@headerContent, &quot;    static constexpr const JSC::ClassInfo* info() { return &amp;s_info; }\n\n&quot;);
2679     } else {
2680         push(@headerContent, &quot;\n&quot;);
2681         push(@headerContent, &quot;    DECLARE_INFO;\n\n&quot;);
2682     }
2683 
2684     # Structure ID
2685     push(@headerContent, &quot;    static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)\n&quot;);
2686     push(@headerContent, &quot;    {\n&quot;);
2687     if (IsDOMGlobalObject($interface)) {
2688         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::GlobalObjectType, StructureFlags), info());\n&quot;);
2689     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;Node&quot;)) {
2690         my $type = GetJSTypeForNode($interface);
2691         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType($type), StructureFlags), info());\n&quot;);
2692     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;Event&quot;)) {
2693         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType(JSEventType), StructureFlags), info());\n&quot;);
2694     } else {
2695         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());\n&quot;);
2696     }
2697     push(@headerContent, &quot;    }\n\n&quot;);
2698 
2699     # Custom pushEventHandlerScope function
2700     if ($interface-&gt;extendedAttributes-&gt;{CustomPushEventHandlerScope}) {
2701         push(@headerContent, &quot;    JSC::JSScope* pushEventHandlerScope(JSC::ExecState*, JSC::JSScope*) const;\n\n&quot;);
2702     }
2703     
2704     # Constructor object getter
2705     unless ($interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
2706         push(@headerContent, &quot;    static JSC::JSValue getConstructor(JSC::VM&amp;, const JSC::JSGlobalObject*);\n&quot;);
2707         push(@headerContent, &quot;    static JSC::JSValue getNamedConstructor(JSC::VM&amp;, JSC::JSGlobalObject*);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
2708     }
2709 
2710     # Serializer function.
2711     if ($interface-&gt;serializable) {
2712         push(@headerContent, &quot;    static JSC::JSObject* serialize(JSC::ExecState&amp;, ${className}&amp; thisObject, JSDOMGlobalObject&amp;, JSC::ThrowScope&amp;);\n&quot;);
2713     }
2714     
2715     my $numCustomOperations = 0;
2716     my $numCustomAttributes = 0;
2717 
2718     my $hasForwardDeclaringOperations = 0;
2719     my $hasForwardDeclaringAttributes = 0;
2720 
2721     my $hasDOMJITAttributes = 0;
2722 
2723     # Attribute and function enums
2724     if ($numAttributes &gt; 0) {
2725         foreach my $attribute (@{$interface-&gt;attributes}) {
2726             $numCustomAttributes++ if HasCustomGetter($attribute);
2727             $numCustomAttributes++ if HasCustomSetter($attribute);
2728             if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
2729                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2730                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2731                 push(@headerContent, &quot;    mutable JSC::WriteBarrier&lt;JSC::Unknown&gt; m_&quot; . $attribute-&gt;name . &quot;;\n&quot;);
2732                 $numCachedAttributes++;
2733                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2734             }
2735             $hasDOMJITAttributes = 1 if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
2736 
2737             $hasForwardDeclaringAttributes = 1 if $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2738         }
2739     }
2740 
2741     # visit function
2742     if ($needsVisitChildren) {
2743         push(@headerContent, &quot;    static void visitChildren(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
2744         push(@headerContent, &quot;    void visitAdditionalChildren(JSC::SlotVisitor&amp;);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
2745         push(@headerContent, &quot;\n&quot;);
2746 
2747         if ($interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction}) {
2748             # We assume that the logic in visitAdditionalChildren is highly volatile, and during a
2749             # concurrent GC or in between eden GCs something may happen that would lead to this
2750             # logic behaving differently. Since this could mark objects or add opaque roots, this
2751             # means that after any increment of mutator resumption in a concurrent GC and at least
2752             # once during any eden GC we need to re-execute visitAdditionalChildren on any objects
2753             # that we had executed it on before. We do this using the DOM&#39;s own MarkingConstraint,
2754             # which will call visitOutputConstraints on all objects in the DOM&#39;s own
2755             # outputConstraintSubspace. visitOutputConstraints is the name JSC uses for the method
2756             # that the GC calls to ask an object is it would like to mark anything else after the
2757             # program resumed since the last call to visitChildren or visitOutputConstraints. Since
2758             # this just calls visitAdditionalChildren, you usually don&#39;t have to worry about this.
2759             push(@headerContent, &quot;    static void visitOutputConstraints(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
2760             my $subspaceFunc = IsDOMGlobalObject($interface) ? &quot;globalObjectOutputConstraintSubspaceFor&quot; : &quot;outputConstraintSubspaceFor&quot;;
2761             push(@headerContent, &quot;    template&lt;typename, JSC::SubspaceAccess&gt; static JSC::CompleteSubspace* subspaceFor(JSC::VM&amp; vm) { return $subspaceFunc(vm); }\n&quot;);
2762         }
2763     }
2764 
2765     if (NeedsImplementationClass($interface)) {
2766         push(@headerContent, &quot;    static void heapSnapshot(JSCell*, JSC::HeapSnapshotBuilder&amp;);\n&quot;);
2767     }
2768     
2769     if ($numCustomAttributes &gt; 0) {
2770         push(@headerContent, &quot;\n    // Custom attributes\n&quot;);
2771 
2772         foreach my $attribute (@{$interface-&gt;attributes}) {
2773             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2774             if (HasCustomGetter($attribute)) {
2775                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2776                 my $methodName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;name);
2777                 push(@headerContent, &quot;    JSC::JSValue &quot; . $methodName . &quot;(JSC::ExecState&amp;) const;\n&quot;);
2778                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2779             }
2780             if (HasCustomSetter($attribute) &amp;&amp; !IsReadonly($attribute)) {
2781                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2782                 push(@headerContent, &quot;    void set&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . &quot;(JSC::ExecState&amp;, JSC::JSValue);\n&quot;);
2783                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2784             }
2785         }
2786     }
2787 
2788     foreach my $operation (@{$interface-&gt;operations}) {
2789         $numCustomOperations++ if HasCustomMethod($operation);
2790         $hasForwardDeclaringOperations = 1 if $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2791     }
2792 
2793     if ($numCustomOperations &gt; 0) {
2794         my $inAppleCopyright = 0;
2795         push(@headerContent, &quot;\n    // Custom functions\n&quot;);
2796         foreach my $operation (@{$interface-&gt;operations}) {
2797             next unless HasCustomMethod($operation);
2798             next if $operation-&gt;{overloads} &amp;&amp; $operation-&gt;{overloadIndex} != 1;
2799 
2800             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
2801                 if (!$inAppleCopyright) {
2802                     push(@headerContent, $beginAppleCopyrightForHeaderFiles);
2803                     $inAppleCopyright = 1;
2804                 }
2805             } elsif ($inAppleCopyright) {
2806                 push(@headerContent, $endAppleCopyright);
2807                 $inAppleCopyright = 0;
2808             }
2809 
2810             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
2811             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2812 
2813             my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name);
2814 
2815             my @functionArguments = ();
2816             push(@functionArguments, &quot;JSC::ExecState&amp;&quot;);
2817             push(@functionArguments, &quot;Ref&lt;DeferredPromise&gt;&amp;&amp;&quot;) if $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
2818 
2819             push(@headerContent, &quot;    &quot; . ($operation-&gt;isStatic ? &quot;static &quot; : &quot;&quot;) . &quot;JSC::JSValue &quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @functionArguments) . &quot;);\n&quot;);
2820 
2821             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2822         }
2823         push(@headerContent, $endAppleCopyright) if $inAppleCopyright;
2824     }
2825 
2826     if (NeedsImplementationClass($interface)) {
2827         if ($hasParent) {
2828             push(@headerContent, &quot;    $interfaceName&amp; wrapped() const\n&quot;);
2829             push(@headerContent, &quot;    {\n&quot;);
2830             push(@headerContent, &quot;        return static_cast&lt;$interfaceName&amp;&gt;(Base::wrapped());\n&quot;);
2831             push(@headerContent, &quot;    }\n&quot;);
2832         }
2833     }
2834 
2835     # structure flags
2836     if (%structureFlags) {
2837         push(@headerContent, &quot;public:\n&quot;);
2838         push(@headerContent, &quot;    static const unsigned StructureFlags = Base::StructureFlags&quot;);
2839         foreach my $structureFlag (sort (keys %structureFlags)) {
2840             push(@headerContent, &quot; | &quot; . $structureFlag);
2841         }
2842         push(@headerContent, &quot;;\n&quot;);
2843     }
2844 
2845     push(@headerContent, &quot;protected:\n&quot;);
2846 
2847     # Constructor
2848     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2849         push(@headerContent, &quot;    $className(JSC::VM&amp;, JSC::Structure*, Ref&lt;$implType&gt;&amp;&amp;, JSWindowProxy*);\n&quot;);
2850     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
2851         push(@headerContent, &quot;    $className(JSC::VM&amp;, JSC::Structure*, Ref&lt;$implType&gt;&amp;&amp;);\n&quot;);
2852     } elsif (!NeedsImplementationClass($interface)) {
2853         push(@headerContent, &quot;    $className(JSC::Structure*, JSDOMGlobalObject&amp;);\n\n&quot;);
2854      } else {
2855         push(@headerContent, &quot;    $className(JSC::Structure*, JSDOMGlobalObject&amp;, Ref&lt;$implType&gt;&amp;&amp;);\n\n&quot;);
2856     }
2857 
2858     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2859         push(@headerContent, &quot;    void finishCreation(JSC::VM&amp;, JSWindowProxy*);\n&quot;);
2860     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
2861         push(@headerContent, &quot;    void finishCreation(JSC::VM&amp;, JSC::JSProxy*);\n&quot;);
2862     } else {
2863         push(@headerContent, &quot;    void finishCreation(JSC::VM&amp;);\n&quot;);
2864     }
2865 
2866     push(@headerContent, &quot;};\n\n&quot;);
2867 
2868     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface)) {
2869         if ($interfaceName ne &quot;Node&quot; &amp;&amp; $codeGenerator-&gt;InheritsInterface($interface, &quot;Node&quot;)) {
2870             $headerIncludes{&quot;JSNode.h&quot;} = 1;
2871             push(@headerContent, &quot;class JS${interfaceName}Owner : public JSNodeOwner {\n&quot;);
2872         } else {
2873             push(@headerContent, &quot;class JS${interfaceName}Owner : public JSC::WeakHandleOwner {\n&quot;);
2874         }
2875         $headerIncludes{&quot;&lt;wtf/NeverDestroyed.h&gt;&quot;} = 1;
2876         push(@headerContent, &quot;public:\n&quot;);
2877         push(@headerContent, &quot;    virtual bool isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt;, void* context, JSC::SlotVisitor&amp;, const char**);\n&quot;);
2878         push(@headerContent, &quot;    virtual void finalize(JSC::Handle&lt;JSC::Unknown&gt;, void* context);\n&quot;);
2879         push(@headerContent, &quot;};\n&quot;);
2880         push(@headerContent, &quot;\n&quot;);
2881         push(@headerContent, &quot;inline JSC::WeakHandleOwner* wrapperOwner(DOMWrapperWorld&amp;, $implType*)\n&quot;);
2882         push(@headerContent, &quot;{\n&quot;);
2883         push(@headerContent, &quot;    static NeverDestroyed&lt;JS${interfaceName}Owner&gt; owner;\n&quot;);
2884         push(@headerContent, &quot;    return &amp;owner.get();\n&quot;);
2885         push(@headerContent, &quot;}\n&quot;);
2886         push(@headerContent, &quot;\n&quot;);
2887         push(@headerContent, &quot;inline void* wrapperKey($implType* wrappableObject)\n&quot;);
2888         push(@headerContent, &quot;{\n&quot;);
2889         push(@headerContent, &quot;    return wrappableObject;\n&quot;);
2890         push(@headerContent, &quot;}\n&quot;);
2891         push(@headerContent, &quot;\n&quot;);
2892     }
2893     if (ShouldGenerateToJSDeclaration($hasParent, $interface)) {
2894         # Node and NodeList have custom inline implementations which thus cannot be exported.
2895         # FIXME: The special case for Node and NodeList should probably be implemented via an IDL attribute.
2896         if ($implType eq &quot;Node&quot; or $implType eq &quot;NodeList&quot;) {
2897             push(@headerContent, &quot;JSC::JSValue toJS(JSC::ExecState*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);
2898         } else {
2899             push(@headerContent, $exportMacro.&quot;JSC::JSValue toJS(JSC::ExecState*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);
2900         }
2901         push(@headerContent, &quot;inline JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject* globalObject, $implType* impl) { return impl ? toJS(state, globalObject, *impl) : JSC::jsNull(); }\n&quot;);
2902 
2903         push(@headerContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::ExecState*, JSDOMGlobalObject*, Ref&lt;$implType&gt;&amp;&amp;);\n&quot;);
2904         push(@headerContent, &quot;inline JSC::JSValue toJSNewlyCreated(JSC::ExecState* state, JSDOMGlobalObject* globalObject, RefPtr&lt;$implType&gt;&amp;&amp; impl) { return impl ? toJSNewlyCreated(state, globalObject, impl.releaseNonNull()) : JSC::jsNull(); }\n&quot;);
2905    }
2906 
2907     push(@headerContent, &quot;\n&quot;);
2908 
2909     GeneratePrototypeDeclaration(\@headerContent, $className, $interface) if HeaderNeedsPrototypeDeclaration($interface);
2910 
2911     if ($hasForwardDeclaringOperations) {
2912         my $inAppleCopyright = 0;
2913         push(@headerContent,&quot;// Functions\n\n&quot;);
2914         foreach my $operation (@{$interface-&gt;operations}) {
2915             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
2916             next unless $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2917 
2918             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
2919                 if (!$inAppleCopyright) {
2920                     push(@headerContent, $beginAppleCopyrightForHeaderFiles);
2921                     $inAppleCopyright = 1;
2922                 }
2923             } elsif ($inAppleCopyright) {
2924                 push(@headerContent, $endAppleCopyright);
2925                 $inAppleCopyright = 0;
2926             }
2927 
2928             my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
2929             my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
2930             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2931             my $functionName = GetFunctionName($interface, $className, $operation);
2932             push(@headerContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::ExecState*);\n&quot;);
2933             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2934         }
2935 
2936         push(@headerContent, $endAppleCopyright) if $inAppleCopyright;
2937         push(@headerContent,&quot;\n&quot;);
2938     }
2939 
2940     if ($hasForwardDeclaringAttributes) {
2941         push(@headerContent,&quot;// Attributes\n\n&quot;);
2942         foreach my $attribute (@{$interface-&gt;attributes}) {
2943             next unless $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2944 
2945             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2946             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2947             my $getter = GetAttributeGetterName($interface, $className, $attribute);
2948             push(@headerContent, &quot;JSC::EncodedJSValue ${getter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);
2949             if (!IsReadonly($attribute)) {
2950                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
2951                 push(@headerContent, &quot;bool ${setter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);
2952             }
2953             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2954         }
2955     }
2956 
2957     # CheckSubClass Snippet function.
2958     if ($interface-&gt;extendedAttributes-&gt;{DOMJIT}) {
2959         $headerIncludes{&quot;&lt;JavaScriptCore/Snippet.h&gt;&quot;} = 1;
2960         push(@headerContent, &quot;#if ENABLE(JIT)\n&quot;);
2961         push(@headerContent, &quot;Ref&lt;JSC::Snippet&gt; checkSubClassSnippetFor${className}();\n&quot;);
2962         push(@headerContent, &quot;#endif\n&quot;);
2963     }
2964 
2965     if ($hasDOMJITAttributes) {
2966         $headerIncludes{&quot;&lt;JavaScriptCore/DOMJITGetterSetter.h&gt;&quot;} = 1;
2967         push(@headerContent,&quot;// DOM JIT Attributes\n\n&quot;);
2968         foreach my $attribute (@{$interface-&gt;attributes}) {
2969             next unless $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
2970             assert(&quot;Only DOMJIT=Getter is supported for attributes&quot;) unless $codeGenerator-&gt;ExtendedAttributeContains($attribute-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;Getter&quot;);
2971 
2972             my $interfaceName = $interface-&gt;type-&gt;name;
2973             my $className = $interfaceName . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
2974             my $domJITClassName = $className . &quot;Attribute&quot;;
2975 
2976             push(@headerContent, &quot;#if ENABLE(JIT)\n&quot;);
2977             push(@headerContent, &quot;Ref&lt;JSC::DOMJIT::CallDOMGetterSnippet&gt; compile${domJITClassName}();\n&quot;);
2978             push(@headerContent, &quot;#endif\n\n&quot;);
2979         }
2980     }
2981 
2982     if (HasCustomConstructor($interface)) {
2983         push(@headerContent, &quot;// Custom constructor\n&quot;);
2984         push(@headerContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL construct${className}(JSC::ExecState&amp;);\n\n&quot;);
2985     }
2986 
2987     if (NeedsImplementationClass($interface)) {
2988         my $toWrappedType = $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot; ? &quot;RefPtr&lt;${implType}&gt;&quot; : &quot;${implType}*&quot;;
2989         $headerIncludes{&quot;JSDOMWrapper.h&quot;} = 1;
2990 
2991         push(@headerContent, &quot;template&lt;&gt; struct JSDOMWrapperConverterTraits&lt;${implType}&gt; {\n&quot;);
2992         push(@headerContent, &quot;    using WrapperClass = ${className};\n&quot;);
2993         push(@headerContent, &quot;    using ToWrappedReturnType = ${toWrappedType};\n&quot;);
2994         push(@headerContent, &quot;};\n&quot;);
2995     }
2996 
2997     push(@headerContent, GenerateEnumerationsHeaderContent($interface, $enumerations));
2998     push(@headerContent, GenerateDictionariesHeaderContent($interface, $dictionaries));
2999 
3000     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
3001     push(@headerContent, &quot;\n} // namespace WebCore\n&quot;);
3002     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
3003 
3004     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
3005         push(@headerContent, &quot;\n&quot;);
3006         push(@headerContent, split(&quot;\r&quot;, $endAppleCopyright));
3007     }
3008 
3009     # - Generate dependencies.
3010     if ($writeDependencies) {
3011         my @ancestors;
3012         $codeGenerator-&gt;ForAllParents($interface, sub {
3013             my $currentInterface = shift;
3014             push(@ancestors, $currentInterface-&gt;type-&gt;name);
3015         }, 0);
3016         for my $dictionary (@$dictionaries) {
3017             my $parentType = $dictionary-&gt;parentType;
3018             while (defined($parentType)) {
3019                 push(@ancestors, $parentType-&gt;name) if $codeGenerator-&gt;IsExternalDictionaryType($parentType);
3020                 my $parentDictionary = $codeGenerator-&gt;GetDictionaryByType($parentType);
3021                 assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless defined($parentDictionary);
3022                 $parentType = $parentDictionary-&gt;parentType;
3023             }
3024         }
3025         push(@depsContent, &quot;$className.h : &quot;, join(&quot; &quot;, map { &quot;$_.idl&quot; } @ancestors), &quot;\n&quot;);
3026         push(@depsContent, map { &quot;$_.idl :\n&quot; } @ancestors);
3027     }
3028 }
3029 
3030 sub GeneratePropertiesHashTable
3031 {
3032     my ($object, $interface, $isInstance, $hashKeys, $hashSpecials, $hashValue1, $hashValue2, $conditionals, $readWriteConditionals, $runtimeEnabledOperations, $runtimeEnabledAttributes) = @_;
3033 
3034     # FIXME: These should be functions on $interface.
3035     my $interfaceName = $interface-&gt;type-&gt;name;
3036     my $className = &quot;JS$interfaceName&quot;;
3037     
3038     # - Add all properties in a hashtable definition
3039     my $propertyCount = $isInstance ? InstancePropertyCount($interface) : PrototypePropertyCount($interface);
3040 
3041     if (!$isInstance &amp;&amp; NeedsConstructorProperty($interface)) {
3042         die if !$propertyCount;
3043         push(@$hashKeys, &quot;constructor&quot;);
3044         my $getter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
3045         push(@$hashValue1, $getter);
3046 
3047         my $setter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
3048         push(@$hashValue2, $setter);
3049         push(@$hashSpecials, &quot;static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum)&quot;);
3050     }
3051 
3052     return 0 if !$propertyCount;
3053 
3054     my @attributes = @{$interface-&gt;attributes};
3055     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
3056 
3057     foreach my $attribute (@attributes) {
3058         next if ($attribute-&gt;isStatic);
3059         next if AttributeShouldBeOnInstance($interface, $attribute) != $isInstance;
3060         next if ($attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $attribute-&gt;extendedAttributes-&gt;{PublicIdentifier});
3061 
3062         # Global objects add RuntimeEnabled attributes after creation so do not add them to the static table.
3063         if ($isInstance &amp;&amp; NeedsRuntimeCheck($interface, $attribute)) {
3064             $propertyCount -= 1;
3065             next;
3066         }
3067 
3068         my $name = $attribute-&gt;name;
3069         push(@$hashKeys, $name);
3070 
3071         my $special = GetJSCAttributesForAttribute($interface, $attribute);
3072         push(@$hashSpecials, $special);
3073 
3074         if ($attribute-&gt;extendedAttributes-&gt;{DOMJIT}) {
3075             push(@$hashValue1, &quot;&amp;DOMJITAttributeFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name));
3076         } else {
3077             my $getter = GetAttributeGetterName($interface, $className, $attribute);
3078             push(@$hashValue1, $getter);
3079         }
3080 
3081         if (IsReadonly($attribute)) {
3082             push(@$hashValue2, &quot;0&quot;);
3083         } else {
3084             my $setter = GetAttributeSetterName($interface, $className, $attribute);
3085             push(@$hashValue2, $setter);
3086         }
3087 
3088         my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
3089         $conditionals-&gt;{$name} = $conditional if $conditional;
3090         my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
3091         $readWriteConditionals-&gt;{$name} = $readWriteConditional if $readWriteConditional;
3092 
3093         if (NeedsRuntimeCheck($interface, $attribute)) {
3094             push(@$runtimeEnabledAttributes, $attribute);
3095         }
3096     }
3097 
3098     my @operations = @{$interface-&gt;operations};
3099     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
3100     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
3101     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
3102     foreach my $operation (@operations) {
3103         next if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
3104         next if ($operation-&gt;isStatic);
3105         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
3106         next if OperationShouldBeOnInstance($interface, $operation) != $isInstance;
3107         next if $operation-&gt;name eq &quot;[Symbol.Iterator]&quot;;
3108 
3109         # Global objects add RuntimeEnabled operations after creation so do not add them to the static table.
3110         if ($isInstance &amp;&amp; NeedsRuntimeCheck($interface, $operation)) {
3111             $propertyCount -= 1;
3112             next;
3113         }
3114 
3115         my $name = $operation-&gt;name;
3116         push(@$hashKeys, $name);
3117 
3118         my $functionName = GetFunctionName($interface, $className, $operation);
3119         push(@$hashValue1, $functionName);
3120 
3121         my $functionLength = GetFunctionLength($operation);
3122 
3123         if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
3124             push(@$hashValue2, &quot;&amp;DOMJITSignatureFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($operation-&gt;name));
3125         } else {
3126             push(@$hashValue2, $functionLength);
3127         }
3128 
3129         push(@$hashSpecials, ComputeFunctionSpecial($interface, $operation));
3130 
3131         my $conditional = GetConditionalForOperationConsideringOverloads($operation);
3132         $conditionals-&gt;{$name} = $conditional if $conditional;
3133 
3134         if (NeedsRuntimeCheck($interface, $operation)) {
3135             push(@$runtimeEnabledOperations, $operation);
3136         }
3137     }
3138 
3139     return $propertyCount;
3140 }
3141 
3142 # This computes an effective overload set for a given operation / constructor,
3143 # which represents the allowable invocations.This set is used as input for
3144 # the Web IDL overload resolution algorithm.
3145 # http://heycam.github.io/webidl/#dfn-effective-overload-set
3146 sub ComputeEffectiveOverloadSet
3147 {
3148     my ($overloads) = @_;
3149 
3150     my %allSets;
3151     my $addTuple = sub {
3152         my $tuple = shift;
3153         # The Web IDL specification uses a flat set of tuples but we use a hash where the key is the
3154         # number of parameters and the value is the set of tuples for the given number of parameters.
3155         my $length = scalar(@{@$tuple[1]});
3156         if (!exists($allSets{$length})) {
3157             $allSets{$length} = [ $tuple ];
3158         } else {
3159             push(@{$allSets{$length}}, $tuple);
3160         }
3161     };
3162 
3163     my $m = LengthOfLongestOperationParameterList($overloads);
3164     foreach my $overload (@{$overloads}) {
3165         my $n = @{$overload-&gt;arguments};
3166         my @t;
3167         my @o;
3168         my $isVariadic = 0;
3169         foreach my $argument (@{$overload-&gt;arguments}) {
3170             push(@t, $argument-&gt;type);
3171             if ($argument-&gt;isOptional) {
3172                 push(@o, &quot;optional&quot;);
3173             } elsif ($argument-&gt;isVariadic) {
3174                 push(@o, &quot;variadic&quot;);
3175                 $isVariadic = 1;
3176             } else {
3177                 push(@o, &quot;required&quot;);
3178             }
3179         }
3180         &amp;$addTuple([$overload, [@t], [@o]]);
3181         if ($isVariadic) {
3182             my @newT = @t;
3183             my @newO = @o;
3184             for (my $i = $n; $i &lt; $m; $i++) {
3185                 push(@newT, $t[-1]);
3186                 push(@newO, &quot;variadic&quot;);
3187                 &amp;$addTuple([$overload, [@newT], [@newO]]);
3188             }
3189         }
3190         for (my $i = $n - 1; $i &gt;= 0; $i--) {
3191             my $argument = @{$overload-&gt;arguments}[$i];
3192             last unless ($argument-&gt;isOptional || $argument-&gt;isVariadic);
3193             pop(@t);
3194             pop(@o);
3195             &amp;$addTuple([$overload, [@t], [@o]]);
3196         }
3197     }
3198     return %allSets;
3199 }
3200 
3201 sub IsIDLTypeDistinguishableWithUnionForOverloadResolution
3202 {
3203     my ($type, $unionSubtypes) = @_;
3204 
3205     assert(&quot;First type should not be a union&quot;) if $type-&gt;isUnion;
3206     for my $unionSubType (@$unionSubtypes) {
3207         return 0 unless AreTypesDistinguishableForOverloadResolution($type, $unionSubType);
3208     }
3209     return 1;
3210 }
3211 
3212 # Determines if two types are distinguishable in the context of overload resolution,
3213 # according to the Web IDL specification:
3214 # http://heycam.github.io/webidl/#dfn-distinguishable
3215 sub AreTypesDistinguishableForOverloadResolution
3216 {
3217     my ($typeA, $typeB) = @_;
3218 
3219     my $isCallbackFunctionOrDictionary = sub {
3220         my $type = shift;
3221         return $codeGenerator-&gt;IsCallbackFunction($type) || $codeGenerator-&gt;IsDictionaryType($type);
3222     };
3223 
3224     # Two types are distinguishable for overload resolution if at most one of the two includes a nullable type.
3225     return 0 if $typeA-&gt;isNullable &amp;&amp; $typeB-&gt;isNullable;
3226 
3227     # Union types: typeA and typeB  are distinguishable if:
3228     # - Both types are either a union type or nullable union type, and each member type of the one is
3229     #   distinguishable with each member type of the other.
3230     # - One type is a union type or nullable union type, the other is neither a union type nor a nullable
3231     #   union type, and each member type of the first is distinguishable with the second.
3232     if ($typeA-&gt;isUnion &amp;&amp; $typeB-&gt;isUnion) {
3233         for my $unionASubType (@{$typeA-&gt;subtypes}) {
3234             return 0 unless IsIDLTypeDistinguishableWithUnionForOverloadResolution($unionASubType, $typeB-&gt;subtypes);
3235         }
3236         return 1;
3237     } elsif ($typeA-&gt;isUnion) {
3238         return IsIDLTypeDistinguishableWithUnionForOverloadResolution($typeB, $typeA-&gt;subtypes);
3239     } elsif ($typeB-&gt;isUnion) {
3240         return IsIDLTypeDistinguishableWithUnionForOverloadResolution($typeA, $typeB-&gt;subtypes);
3241     }
3242 
3243     return 0 if $typeA-&gt;name eq $typeB-&gt;name;
3244     return 0 if $typeA-&gt;name eq &quot;object&quot; or $typeB-&gt;name eq &quot;object&quot;;
3245     return 0 if $codeGenerator-&gt;IsNumericType($typeA) &amp;&amp; $codeGenerator-&gt;IsNumericType($typeB);
3246     return 0 if $codeGenerator-&gt;IsStringOrEnumType($typeA) &amp;&amp; $codeGenerator-&gt;IsStringOrEnumType($typeB);
3247     return 0 if $codeGenerator-&gt;IsDictionaryType($typeA) &amp;&amp; $codeGenerator-&gt;IsDictionaryType($typeB);
3248     return 0 if $codeGenerator-&gt;IsCallbackInterface($typeA) &amp;&amp; $codeGenerator-&gt;IsCallbackInterface($typeB);
3249     return 0 if &amp;$isCallbackFunctionOrDictionary($typeA) &amp;&amp; &amp;$isCallbackFunctionOrDictionary($typeB);
3250     return 0 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($typeA) &amp;&amp; $codeGenerator-&gt;IsSequenceOrFrozenArrayType($typeB);
3251     # FIXME: return 0 if $typeA and $typeB are both exception types.
3252     return 1;
3253 }
3254 
3255 # If there is more than one entry in an effective overload set that has a given type list length,
3256 # then for those entries there must be an index i such that for each pair of entries the types
3257 # at index i are distinguishable. The lowest such index is termed the distinguishing argument index.
3258 # http://heycam.github.io/webidl/#dfn-distinguishing-argument-index
3259 sub GetDistinguishingArgumentIndex
3260 {
3261     my ($operation, $S) = @_;
3262 
3263     # FIXME: Consider all the tuples, not just the 2 first ones?
3264     my $firstTupleTypes = @{@{$S}[0]}[1];
3265     my $secondTupleTypes = @{@{$S}[1]}[1];
3266     for (my $index = 0; $index &lt; scalar(@$firstTupleTypes); $index++) {
3267         return $index if AreTypesDistinguishableForOverloadResolution(@{$firstTupleTypes}[$index], @{$secondTupleTypes}[$index]);
3268     }
3269     die &quot;Undistinguishable overloads for operation &quot; . $operation-&gt;name . &quot; with length: &quot; . scalar(@$firstTupleTypes);
3270 }
3271 
3272 sub GetOverloadThatMatches
3273 {
3274     my ($S, $parameterIndex, $matches) = @_;
3275 
3276     for my $tuple (@{$S}) {
3277         my $type = @{@{$tuple}[1]}[$parameterIndex];
3278         my $optionality = @{@{$tuple}[2]}[$parameterIndex];
3279         if ($type-&gt;isUnion) {
3280             for my $subtype (GetFlattenedMemberTypes($type)) {
3281                 return @{$tuple}[0] if $matches-&gt;($subtype, $optionality);
3282             }
3283         } else {
3284             return @{$tuple}[0] if $matches-&gt;($type, $optionality);
3285         }
3286     }
3287 }
3288 
3289 sub GetOverloadThatMatchesIgnoringUnionSubtypes
3290 {
3291     my ($S, $parameterIndex, $matches) = @_;
3292 
3293     for my $tuple (@{$S}) {
3294         my $type = @{@{$tuple}[1]}[$parameterIndex];
3295         my $optionality = @{@{$tuple}[2]}[$parameterIndex];
3296         return @{$tuple}[0] if $matches-&gt;($type, $optionality);
3297     }
3298 }
3299 
3300 sub GetConditionalForOperationConsideringOverloads
3301 {
3302     my $operation = shift;
3303 
3304     return $operation-&gt;extendedAttributes-&gt;{Conditional} unless $operation-&gt;{overloads};
3305 
3306     my %conditions;
3307     foreach my $overload (@{$operation-&gt;{overloads}}) {
3308         my $conditional = $overload-&gt;extendedAttributes-&gt;{Conditional};
3309         return unless $conditional;
3310         $conditions{$conditional} = 1;
3311     }
3312     return join(&quot;|&quot;, keys %conditions);
3313 }
3314 
3315 # Implements the overload resolution algorithm, as defined in the Web IDL specification:
3316 # http://heycam.github.io/webidl/#es-overloads
3317 sub GenerateOverloadDispatcher
3318 {
3319     my ($operation, $interface, $overloadFunctionPrefix, $overloadFunctionSuffix, $parametersToForward) = @_;
3320     
3321     my %allSets = ComputeEffectiveOverloadSet($operation-&gt;{overloads});
3322 
3323     my $generateOverloadCallIfNecessary = sub {
3324         my ($overload, $condition, $include) = @_;
3325         return unless $overload;
3326         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($overload);
3327         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3328         push(@implContent, &quot;        if ($condition)\n    &quot;) if $condition;
3329         push(@implContent, &quot;        return &quot; . $overloadFunctionPrefix . $overload-&gt;{overloadIndex} . $overloadFunctionSuffix . &quot;(${parametersToForward});\n&quot;);
3330         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
3331         AddToImplIncludes($include, $overload-&gt;extendedAttributes-&gt;{Conditional}) if $include;
3332     };
3333     my $isOptionalParameter = sub {
3334         my ($type, $optionality) = @_;
3335         return $optionality eq &quot;optional&quot;;
3336     };
3337     my $isDictionaryOrRecordParameter = sub {
3338         my ($type, $optionality) = @_;
3339         return $codeGenerator-&gt;IsDictionaryType($type) || $codeGenerator-&gt;IsRecordType($type);
3340     };
3341     my $isNullableOrDictionaryOrRecordOrUnionContainingOne = sub {
3342         my ($type, $optionality) = @_;
3343         return 1 if $type-&gt;isNullable;
3344         if ($type-&gt;isUnion) {
3345             for my $subtype (GetFlattenedMemberTypes($type)) {
3346                 return 1 if $type-&gt;isNullable || &amp;$isDictionaryOrRecordParameter($subtype, $optionality);
3347             }
3348             return 0;
3349         } else {
3350             return &amp;$isDictionaryOrRecordParameter($type, $optionality);
3351         }
3352     };
3353     my $isObjectOrErrorParameter = sub {
3354         my ($type, $optionality) = @_;
3355         return $type-&gt;name eq &quot;object&quot; || $type-&gt;name eq &quot;Error&quot;;
3356     };
3357     my $isObjectOrErrorOrDOMExceptionParameter = sub {
3358         my ($type, $optionality) = @_;
3359         return 1 if &amp;$isObjectOrErrorParameter($type, $optionality);
3360         return $type-&gt;name eq &quot;DOMException&quot;;
3361     };
3362     my $isObjectOrCallbackFunctionParameter = sub {
3363         my ($type, $optionality) = @_;
3364         return $type-&gt;name eq &quot;object&quot; || $codeGenerator-&gt;IsCallbackFunction($type);
3365     };
3366     my $isSequenceOrFrozenArrayParameter = sub {
3367         my ($type, $optionality) = @_;
3368         return $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
3369     };
3370     my $isDictionaryOrRecordOrObjectOrCallbackInterfaceParameter = sub {
3371         my ($type, $optionality) = @_;
3372         return 1 if &amp;$isDictionaryOrRecordParameter($type, $optionality);
3373         return 1 if $type-&gt;name eq &quot;object&quot;;
3374         return 1 if $codeGenerator-&gt;IsCallbackInterface($type) &amp;&amp; !$codeGenerator-&gt;IsCallbackFunction($type);
3375         return 0;
3376     };
3377     my $isBooleanParameter = sub {
3378         my ($type, $optionality) = @_;
3379         return $type-&gt;name eq &quot;boolean&quot;;
3380     };
3381     my $isNumericParameter = sub {
3382         my ($type, $optionality) = @_;
3383         return $codeGenerator-&gt;IsNumericType($type);
3384     };
3385     my $isStringOrEnumParameter = sub {
3386         my ($type, $optionality) = @_;
3387         return $codeGenerator-&gt;IsStringOrEnumType($type);
3388     };
3389     my $isAnyParameter = sub {
3390         my ($type, $optionality) = @_;
3391         return $type-&gt;name eq &quot;any&quot;;
3392     };
3393 
3394     my $maxArgCount = LengthOfLongestOperationParameterList($operation-&gt;{overloads});
3395 
3396     push(@implContent, &quot;    size_t argsCount = std::min&lt;size_t&gt;(${maxArgCount}, state-&gt;argumentCount());\n&quot;);
3397 
3398     for my $length ( sort keys %allSets ) {
3399         push(@implContent, &quot;    if (argsCount == ${length}) {\n&quot;);
3400 
3401         my $S = $allSets{$length};
3402         if (scalar(@$S) &gt; 1) {
3403             my $d = GetDistinguishingArgumentIndex($operation, $S);
3404             push(@implContent, &quot;        JSValue distinguishingArg = state-&gt;uncheckedArgument($d);\n&quot;);
3405 
3406             my $overload = GetOverloadThatMatchesIgnoringUnionSubtypes($S, $d, \&amp;$isOptionalParameter);
3407             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isUndefined()&quot;);
3408 
3409             $overload = GetOverloadThatMatchesIgnoringUnionSubtypes($S, $d, \&amp;$isNullableOrDictionaryOrRecordOrUnionContainingOne);
3410             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isUndefinedOrNull()&quot;);
3411 
3412             for my $tuple (@{$S}) {
3413                 my $overload = @{$tuple}[0];
3414                 my $type = @{@{$tuple}[1]}[$d];
3415 
3416                 my @subtypes = $type-&gt;isUnion ? GetFlattenedMemberTypes($type) : ( $type );
3417                 for my $subtype (@subtypes) {
3418                     if ($codeGenerator-&gt;IsWrapperType($subtype) || $codeGenerator-&gt;IsBufferSourceType($subtype)) {
3419                         if ($subtype-&gt;name eq &quot;DOMWindow&quot;) {
3420                             AddToImplIncludes(&quot;JSWindowProxy.h&quot;);
3421                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; (asObject(distinguishingArg)-&gt;inherits&lt;JSWindowProxy&gt;(vm) || asObject(distinguishingArg)-&gt;inherits&lt;JSDOMWindow&gt;(vm))&quot;);
3422                         } elsif ($subtype-&gt;name eq &quot;RemoteDOMWindow&quot;) {
3423                             AddToImplIncludes(&quot;JSWindowProxy.h&quot;);
3424                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; (asObject(distinguishingArg)-&gt;inherits&lt;JSWindowProxy&gt;(vm) || asObject(distinguishingArg)-&gt;inherits&lt;JSRemoteDOMWindow&gt;(vm))&quot;);
3425                         } else {
3426                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;inherits&lt;JS&quot; . $subtype-&gt;name . &quot;&gt;(vm)&quot;);
3427                         }
3428                     }
3429                 }
3430             }
3431 
3432             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrErrorOrDOMExceptionParameter);
3433             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;inherits&lt;JSDOMException&gt;(vm)&quot;);
3434 
3435             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrErrorParameter);
3436             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;type() == ErrorInstanceType&quot;);
3437 
3438             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrCallbackFunctionParameter);
3439             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isFunction(vm)&quot;);
3440 
3441             # FIXME: Avoid invoking GetMethod(object, Symbol.iterator) again in convert&lt;IDLSequence&lt;T&gt;&gt;(...).
3442             $overload = GetOverloadThatMatches($S, $d, \&amp;$isSequenceOrFrozenArrayParameter);
3443             &amp;$generateOverloadCallIfNecessary($overload, &quot;hasIteratorMethod(*state, distinguishingArg)&quot;, &quot;&lt;JavaScriptCore/IteratorOperations.h&gt;&quot;);
3444 
3445             $overload = GetOverloadThatMatches($S, $d, \&amp;$isDictionaryOrRecordOrObjectOrCallbackInterfaceParameter);
3446             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject()&quot;);
3447 
3448             my $booleanOverload = GetOverloadThatMatches($S, $d, \&amp;$isBooleanParameter);
3449             &amp;$generateOverloadCallIfNecessary($booleanOverload, &quot;distinguishingArg.isBoolean()&quot;);
3450 
3451             my $numericOverload = GetOverloadThatMatches($S, $d, \&amp;$isNumericParameter);
3452             &amp;$generateOverloadCallIfNecessary($numericOverload, &quot;distinguishingArg.isNumber()&quot;);
3453 
3454             # Fallbacks.
3455             $overload = GetOverloadThatMatches($S, $d, \&amp;$isStringOrEnumParameter);
3456             if ($overload) {
3457                 &amp;$generateOverloadCallIfNecessary($overload);
3458             } elsif ($numericOverload) {
3459                 &amp;$generateOverloadCallIfNecessary($numericOverload);
3460             } elsif ($booleanOverload) {
3461                 &amp;$generateOverloadCallIfNecessary($booleanOverload);
3462             } else {
3463                 $overload = GetOverloadThatMatches($S, $d, \&amp;$isAnyParameter);
3464                 &amp;$generateOverloadCallIfNecessary($overload);
3465             }
3466         } else {
3467             # Only 1 overload with this number of parameters.
3468             my $overload = @{@{$S}[0]}[0];
3469             &amp;$generateOverloadCallIfNecessary($overload);
3470         }
3471         push(@implContent, &lt;&lt;END);
3472     }
3473 END
3474     }
3475     my $minArgCount = GetFunctionLength($operation);
3476     if ($minArgCount &gt; 0) {
3477         push(@implContent, &quot;    return argsCount &lt; $minArgCount ? throwVMError(state, throwScope, createNotEnoughArgumentsError(state)) : throwVMTypeError(state, throwScope);\n&quot;)
3478     } else {
3479         push(@implContent, &quot;    return throwVMTypeError(state, throwScope);\n&quot;)
3480     }
3481 }
3482 
3483 # As per Web IDL specification, the length of a function Object is its number of mandatory parameters.
3484 sub GetFunctionLength
3485 {
3486     my $operation = shift;
3487 
3488     my $getOverloadLength = sub {
3489         my $operation = shift;
3490 
3491         my $length = 0;
3492         foreach my $argument (@{$operation-&gt;arguments}) {
3493             last if $argument-&gt;isOptional || $argument-&gt;isVariadic;
3494             $length++;
3495         }
3496         return $length;
3497     };
3498 
3499     my $length = &amp;$getOverloadLength($operation);
3500     foreach my $overload (@{$operation-&gt;{overloads}}) {
3501         my $newLength = &amp;$getOverloadLength($overload);
3502         $length = $newLength if $newLength &lt; $length;
3503     }
3504     return $length;
3505 }
3506 
3507 sub LengthOfLongestOperationParameterList
3508 {
3509     my ($overloads) = @_;
3510     my $result = 0;
3511     foreach my $overload (@{$overloads}) {
3512         my @arguments = @{$overload-&gt;arguments};
3513         $result = @arguments if $result &lt; @arguments;
3514     }
3515     return $result;
3516 }
3517 
3518 # See http://refspecs.linux-foundation.org/cxxabi-1.83.html.
3519 sub GetGnuVTableRefForInterface
3520 {
3521     my $interface = shift;
3522     my $vtableName = GetGnuVTableNameForInterface($interface);
3523     if (!$vtableName) {
3524         return &quot;0&quot;;
3525     }
3526     my $typename = $interface-&gt;type-&gt;name;
3527     my $offset = GetGnuVTableOffsetForType($typename);
3528     return &quot;&amp;&quot; . $vtableName . &quot;[&quot; . $offset . &quot;]&quot;;
3529 }
3530 
3531 sub GetGnuVTableNameForInterface
3532 {
3533     my $interface = shift;
3534     my $typename = $interface-&gt;type-&gt;name;
3535     my $templatePosition = index($typename, &quot;&lt;&quot;);
3536     return &quot;&quot; if $templatePosition != -1;
3537     return &quot;&quot; if GetImplementationLacksVTableForInterface($interface);
3538     return &quot;&quot; if GetSkipVTableValidationForInterface($interface);
3539     return &quot;_ZTV&quot; . GetGnuMangledNameForInterface($interface);
3540 }
3541 
3542 sub GetGnuMangledNameForInterface
3543 {
3544     my $interface = shift;
3545     my $typename = $interface-&gt;type-&gt;name;
3546     my $templatePosition = index($typename, &quot;&lt;&quot;);
3547     if ($templatePosition != -1) {
3548         return &quot;&quot;;
3549     }
3550     my $mangledType = length($typename) . $typename;
3551     my $namespace = &quot;WebCore&quot;;
3552     my $mangledNamespace =  &quot;N&quot; . length($namespace) . $namespace;
3553     return $mangledNamespace . $mangledType . &quot;E&quot;;
3554 }
3555 
3556 sub GetGnuVTableOffsetForType
3557 {
3558     my $typename = shift;
3559     if ($typename eq &quot;ApplePaySession&quot;
3560         || $typename eq &quot;SVGAElement&quot;
3561         || $typename eq &quot;SVGCircleElement&quot;
3562         || $typename eq &quot;SVGClipPathElement&quot;
3563         || $typename eq &quot;SVGDefsElement&quot;
3564         || $typename eq &quot;SVGEllipseElement&quot;
3565         || $typename eq &quot;SVGForeignObjectElement&quot;
3566         || $typename eq &quot;SVGGElement&quot;
3567         || $typename eq &quot;SVGImageElement&quot;
3568         || $typename eq &quot;SVGLineElement&quot;
3569         || $typename eq &quot;SVGPathElement&quot;
3570         || $typename eq &quot;SVGPolyElement&quot;
3571         || $typename eq &quot;SVGPolygonElement&quot;
3572         || $typename eq &quot;SVGPolylineElement&quot;
3573         || $typename eq &quot;SVGRectElement&quot;
3574         || $typename eq &quot;SVGSVGElement&quot;
3575         || $typename eq &quot;SVGGeometryElement&quot;
3576         || $typename eq &quot;SVGGraphicsElement&quot;
3577         || $typename eq &quot;SVGSwitchElement&quot;
3578         || $typename eq &quot;SVGTextElement&quot;
3579         || $typename eq &quot;SVGUseElement&quot;) {
3580         return &quot;3&quot;;
3581     }
3582     return &quot;2&quot;;
3583 }
3584 
3585 # See http://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B_Name_Mangling.
3586 sub GetWinVTableRefForInterface
3587 {
3588     my $interface = shift;
3589     my $vtableName = GetWinVTableNameForInterface($interface);
3590     return 0 if !$vtableName;
3591     return &quot;__identifier(\&quot;&quot; . $vtableName . &quot;\&quot;)&quot;;
3592 }
3593 
3594 sub GetWinVTableNameForInterface
3595 {
3596     my $interface = shift;
3597     my $typename = $interface-&gt;type-&gt;name;
3598     my $templatePosition = index($typename, &quot;&lt;&quot;);
3599     return &quot;&quot; if $templatePosition != -1;
3600     return &quot;&quot; if GetImplementationLacksVTableForInterface($interface);
3601     return &quot;&quot; if GetSkipVTableValidationForInterface($interface);
3602     return &quot;??_7&quot; . GetWinMangledNameForInterface($interface) . &quot;6B@&quot;;
3603 }
3604 
3605 sub GetWinMangledNameForInterface
3606 {
3607     my $interface = shift;
3608     my $typename = $interface-&gt;type-&gt;name;
3609     my $namespace = &quot;WebCore&quot;;
3610     return $typename . &quot;@&quot; . $namespace . &quot;@@&quot;;
3611 }
3612 
3613 sub GetImplementationLacksVTableForInterface
3614 {
3615     my $interface = shift;
3616     return $interface-&gt;extendedAttributes-&gt;{ImplementationLacksVTable};
3617 }
3618 
3619 sub GetSkipVTableValidationForInterface
3620 {
3621     my $interface = shift;
3622     return $interface-&gt;extendedAttributes-&gt;{SkipVTableValidation};
3623 }
3624 
3625 # URL becomes url, but SetURL becomes setURL.
3626 sub ToMethodName
3627 {
3628     my $param = shift;
3629     my $ret = lcfirst($param);
3630     $ret =~ s/cSS/css/ if $ret =~ /^cSS/;
3631     $ret =~ s/dOM/dom/ if $ret =~ /^dOM/;
3632     $ret =~ s/hTML/html/ if $ret =~ /^hTML/;
3633     $ret =~ s/jS/js/ if $ret =~ /^jS/;
3634     $ret =~ s/uRL/url/ if $ret =~ /^uRL/;
3635     $ret =~ s/xML/xml/ if $ret =~ /^xML/;
3636     $ret =~ s/xSLT/xslt/ if $ret =~ /^xSLT/;
3637 
3638     # For HTML5 FileSystem API Flags attributes.
3639     # (create is widely used to instantiate an object and must be avoided.)
3640     $ret =~ s/^create/isCreate/ if $ret =~ /^create$/;
3641     $ret =~ s/^exclusive/isExclusive/ if $ret =~ /^exclusive$/;
3642 
3643     return $ret;
3644 }
3645 
3646 sub GenerateRuntimeEnableConditionalStringForExposed
3647 {
3648     my ($interface, $context, $conjuncts, $globalObjectIsParam) = @_;
3649 
3650     assert(&quot;Must specify value for Exposed.&quot;) if $context-&gt;extendedAttributes-&gt;{Exposed} eq &quot;VALUE_IS_MISSING&quot;;
3651 
3652     AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3653 
3654     my $exposed = $context-&gt;extendedAttributes-&gt;{Exposed};
3655     if (ref($exposed) eq &#39;ARRAY&#39;) {
3656         if (scalar(@$exposed) &gt; 1) {
3657             return;
3658         }
3659         $exposed = @$exposed[0];
3660     }
3661 
3662     my $globalObjectPtr = $globalObjectIsParam ? &quot;&amp;globalObject&quot; : &quot;globalObject()&quot;;
3663 
3664     if ($exposed eq &quot;Window&quot;) {
3665         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isDocument()&quot;);
3666     } elsif ($exposed eq &quot;Worker&quot;) {
3667         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isWorkerGlobalScope()&quot;);
3668     } elsif ($exposed eq &quot;Worklet&quot;) {
3669         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isWorkletGlobalScope()&quot;);
3670     } else {
3671         assert(&quot;Unrecognized value &#39;&quot; . Dumper($context-&gt;extendedAttributes-&gt;{Exposed}) . &quot;&#39; for the Exposed extended attribute on &#39;&quot; . ref($context) . &quot;&#39;.&quot;);
3672     }
3673 }
3674 
3675 # Returns the conditional string that determines whether a method/attribute is enabled at runtime.
3676 # A method/attribute is enabled at runtime if either its RuntimeEnabledFeatures function returns
3677 # true or its EnabledForWorld function returns true (or both).
3678 # NOTE: Parameter passed in must have an &#39;extendedAttributes&#39; property.
3679 # (e.g. IDLInterface, IDLAttribute, IDLOperation, IDLIterable, etc.)
3680 sub GenerateRuntimeEnableConditionalString
3681 {
3682     my ($interface, $context, $globalObjectIsParam) = @_;
3683 
3684     my @conjuncts;
3685     my $globalObjectPtr = $globalObjectIsParam ? &quot;&amp;globalObject&quot; : &quot;globalObject()&quot;;
3686     
3687     if ($context-&gt;extendedAttributes-&gt;{SecureContext}) {
3688         AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3689 
3690         if ($context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}) {
3691             push(@conjuncts, &quot;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;
3692                 . &quot;|| jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;hasServiceWorkerScheme())&quot;);
3693         } elsif ($context-&gt;extendedAttributes-&gt;{ContextAllowsMediaDevices}) {
3694             push(@conjuncts, &quot;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;
3695                 . &quot;|| jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;allowsMediaDevices())&quot;);
3696         } else {
3697             push(@conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(globalObject())-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;);
3698         }
3699     } else {
3700         if ($context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}) {
3701             AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3702 
3703             push(@conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;hasServiceWorkerScheme()&quot;);
3704         }
3705     }
3706 
3707     if ($context-&gt;extendedAttributes-&gt;{Exposed}) {
3708         GenerateRuntimeEnableConditionalStringForExposed($interface, $context, \@conjuncts);
3709     }
3710 
3711     if ($context-&gt;extendedAttributes-&gt;{EnabledForWorld}) {
3712         assert(&quot;Must specify value for EnabledForWorld.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledForWorld} eq &quot;VALUE_IS_MISSING&quot;;
3713 
3714         AddToImplIncludes(&quot;DOMWrapperWorld.h&quot;);
3715 
3716         push(@conjuncts, &quot;worldForDOMObject(*this).&quot; . ToMethodName($context-&gt;extendedAttributes-&gt;{EnabledForWorld}) . &quot;()&quot;);
3717     }
3718 
3719     if ($context-&gt;extendedAttributes-&gt;{EnabledBySetting}) {
3720         assert(&quot;Must specify value for EnabledBySetting.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledBySetting} eq &quot;VALUE_IS_MISSING&quot;;
3721 
3722         AddToImplIncludes(&quot;Document.h&quot;);
3723         AddToImplIncludes(&quot;Settings.h&quot;);
3724 
3725         assert(&quot;EnabledBySetting can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3726 
3727         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{EnabledBySetting});
3728         foreach my $flag (@flags) {
3729             push(@conjuncts, &quot;downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;settings().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3730         }
3731     }
3732 
3733     if ($context-&gt;extendedAttributes-&gt;{DisabledByQuirk}) {
3734         assert(&quot;Must specify value for DisabledByQuirk.&quot;) if $context-&gt;extendedAttributes-&gt;{DisabledByQuirk} eq &quot;VALUE_IS_MISSING&quot;;
3735 
3736         AddToImplIncludes(&quot;Document.h&quot;);
3737         AddToImplIncludes(&quot;Quirks.h&quot;);
3738 
3739         assert(&quot;DisabledByQuirk can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3740 
3741         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{DisabledByQuirk});
3742         foreach my $flag (@flags) {
3743             push(@conjuncts, &quot;!downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;quirks().&quot; . ToMethodName($flag) . &quot;Quirk()&quot;);
3744         }
3745     }
3746 
3747     if ($context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}) {
3748         assert(&quot;Must specify value for EnabledAtRuntime.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime} eq &quot;VALUE_IS_MISSING&quot;;
3749 
3750         AddToImplIncludes(&quot;RuntimeEnabledFeatures.h&quot;);
3751 
3752         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime});
3753         foreach my $flag (@flags) {
3754             push(@conjuncts, &quot;RuntimeEnabledFeatures::sharedFeatures().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3755         }
3756     }
3757 
3758     my $result = join(&quot; &amp;&amp; &quot;, @conjuncts);
3759     $result = &quot;($result)&quot; if @conjuncts &gt; 1;
3760     return $result;
3761 }
3762 
3763 sub GetCastingHelperForThisObject
3764 {
3765     my $interface = shift;
3766     my $interfaceName = $interface-&gt;type-&gt;name;
3767     return &quot;jsDynamicCast&lt;JS$interfaceName*&gt;&quot;;
3768 }
3769 
3770 # http://heycam.github.io/webidl/#Unscopable
3771 sub addUnscopableProperties
3772 {
3773     my $interface = shift;
3774 
3775     my @unscopables;
3776     foreach my $operationOrAttribute (@{$interface-&gt;operations}, @{$interface-&gt;attributes}) {
3777         push(@unscopables, $operationOrAttribute-&gt;name) if $operationOrAttribute-&gt;extendedAttributes-&gt;{Unscopable};
3778     }
3779     return if scalar(@unscopables) == 0;
3780 
3781     AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
3782     push(@implContent, &quot;    JSObject&amp; unscopables = *constructEmptyObject(globalObject()-&gt;globalExec(), globalObject()-&gt;nullPrototypeObjectStructure());\n&quot;);
3783     foreach my $unscopable (@unscopables) {
3784         push(@implContent, &quot;    unscopables.putDirect(vm, Identifier::fromString(&amp;vm, \&quot;$unscopable\&quot;), jsBoolean(true));\n&quot;);
3785     }
3786     push(@implContent, &quot;    putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, &amp;unscopables, JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);\n&quot;);
3787 }
3788 
3789 sub GetUnsafeArgumentType
3790 {
3791     my ($interface, $type) = @_;
3792 
3793     my $IDLType = GetIDLType($interface, $type);
3794     return &quot;DOMJIT::IDLJSArgumentType&lt;${IDLType}&gt;&quot;;
3795 }
3796 
3797 sub GetArgumentTypeFilter
3798 {
3799     my ($interface, $type) = @_;
3800 
3801     my $IDLType = GetIDLType($interface, $type);
3802     return &quot;DOMJIT::IDLArgumentTypeFilter&lt;${IDLType}&gt;::value&quot;;
3803 }
3804 
3805 sub GetResultTypeFilter
3806 {
3807     my ($interface, $type) = @_;
3808 
3809     my $IDLType = GetIDLType($interface, $type);
3810     return &quot;DOMJIT::IDLResultTypeFilter&lt;${IDLType}&gt;::value&quot;;
3811 }
3812 
3813 sub GetAttributeWithName
3814 {
3815     my ($interface, $attributeName) = @_;
3816     
3817     foreach my $attribute (@{$interface-&gt;attributes}) {
3818         return $attribute if $attribute-&gt;name eq $attributeName;
3819     }
3820 }
3821 
3822 # https://heycam.github.io/webidl/#es-iterator
3823 sub InterfaceNeedsIterator
3824 {
3825     my ($interface) = @_;
3826 
3827     # FIXME: This should return 1 for setlike once we support it.
3828     return 1 if $interface-&gt;mapLike;
3829     return 1 if $interface-&gt;iterable;
3830 
3831     if (GetIndexedGetterOperation($interface)) {
3832         my $lengthAttribute = GetAttributeWithName($interface, &quot;length&quot;);
3833         return 1 if $lengthAttribute and $codeGenerator-&gt;IsIntegerType($lengthAttribute-&gt;type);
3834     }
3835     return 0;
3836 }
3837 
3838 sub GenerateImplementation
3839 {
3840     my ($object, $interface, $enumerations, $dictionaries) = @_;
3841 
3842     my $interfaceName = $interface-&gt;type-&gt;name;
3843     my $className = &quot;JS$interfaceName&quot;;
3844 
3845     my $hasParent = $interface-&gt;parentType || $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
3846     my $parentClassName = GetParentClassName($interface);
3847     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
3848     my $needsVisitChildren = InstanceNeedsVisitChildren($interface);
3849 
3850     my $namedGetterOperation = GetNamedGetterOperation($interface);
3851     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
3852 
3853     # - Add default header template
3854     push(@implContentHeader, GenerateImplementationContentHeader($interface));
3855 
3856     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
3857     AddToImplIncludes(&quot;JSDOMBinding.h&quot;);
3858     AddToImplIncludes(&quot;JSDOMExceptionHandling.h&quot;);
3859     AddToImplIncludes(&quot;JSDOMWrapperCache.h&quot;);
3860     AddToImplIncludes(&quot;&lt;wtf/GetPtr.h&gt;&quot;);
3861     AddToImplIncludes(&quot;&lt;wtf/PointerPreparations.h&gt;&quot;);
3862     AddToImplIncludes(&quot;&lt;JavaScriptCore/PropertyNameArray.h&gt;&quot;) if $indexedGetterOperation;
3863     AddToImplIncludes(&quot;JSDOMMapLike.h&quot;) if $interface-&gt;mapLike;
3864     AddJSBuiltinIncludesIfNeeded($interface);
3865 
3866     my $implType = GetImplClassName($interface);
3867 
3868     @implContent = ();
3869 
3870     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
3871     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
3872 
3873     push(@implContent, GenerateEnumerationsImplementationContent($interface, $enumerations));
3874     push(@implContent, GenerateDictionariesImplementationContent($interface, $dictionaries));
3875 
3876     my @operations = @{$interface-&gt;operations};
3877     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
3878     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
3879     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
3880 
3881     my @attributes = @{$interface-&gt;attributes};
3882     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
3883 
3884     my $numConstants = @{$interface-&gt;constants};
3885     my $numOperations = @operations;
3886     my $numAttributes = @attributes;
3887 
3888     if ($numOperations &gt; 0) {
3889         my $inAppleCopyright = 0;
3890         push(@implContent,&quot;// Functions\n\n&quot;);
3891         foreach my $operation (@operations) {
3892             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
3893             next if $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
3894             next if IsJSBuiltin($interface, $operation);
3895 
3896             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
3897                 if (!$inAppleCopyright) {
3898                     push(@implContent, $beginAppleCopyrightForHeaderFiles);
3899                     $inAppleCopyright = 1;
3900                 }
3901             } elsif ($inAppleCopyright) {
3902                 push(@implContent, $endAppleCopyright);
3903                 $inAppleCopyright = 0;
3904             }
3905 
3906             my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
3907             my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
3908             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3909             my $functionName = GetFunctionName($interface, $className, $operation);
3910             push(@implContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::ExecState*);\n&quot;);
3911             if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
3912                 $implIncludes{&quot;DOMJITIDLType.h&quot;} = 1;
3913                 my $unsafeFunctionName = &quot;unsafe&quot; . $codeGenerator-&gt;WK_ucfirst($functionName);
3914                 my $functionSignature = &quot;JSC::EncodedJSValue JIT_OPERATION ${unsafeFunctionName}(JSC::ExecState*, $className*&quot;;
3915                 foreach my $argument (@{$operation-&gt;arguments}) {
3916                     my $type = $argument-&gt;type;
3917                     my $argumentType = GetUnsafeArgumentType($interface, $type);
3918                     $functionSignature .= &quot;, ${argumentType}&quot;;
3919                 }
3920                 push(@implContent, $functionSignature . &quot;);\n&quot;);
3921             }
3922             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
3923         }
3924 
3925         push(@implContent, $endAppleCopyright) if $inAppleCopyright;
3926         push(@implContent, &quot;\n&quot;);
3927     }
3928 
3929     if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
3930         push(@implContent, &quot;// Attributes\n\n&quot;);
3931 
3932         if (NeedsConstructorProperty($interface)) {
3933             my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
3934             push(@implContent, &quot;JSC::EncodedJSValue ${constructorGetter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);
3935 
3936             my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
3937             push(@implContent, &quot;bool ${constructorSetter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);
3938         }
3939 
3940         foreach my $attribute (@attributes) {
3941             next if $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
3942             next if IsJSBuiltin($interface, $attribute);
3943 
3944             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
3945             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3946             my $getter = GetAttributeGetterName($interface, $className, $attribute);
3947             push(@implContent, &quot;JSC::EncodedJSValue ${getter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);
3948             if (!IsReadonly($attribute)) {
3949                 my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
3950                 if ($readWriteConditional) {
3951                     my $readWriteConditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
3952                     push(@implContent, &quot;#if ${readWriteConditionalString}\n&quot;);
3953                 }
3954                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
3955                 push(@implContent, &quot;bool ${setter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);
3956                 push(@implContent, &quot;#endif\n&quot;) if $readWriteConditional;
3957             }
3958             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
3959         }
3960 
3961         push(@implContent, &quot;\n&quot;);
3962     }
3963 
3964     if ($numOperations &gt; 0) {
3965         foreach my $operation (@operations) {
3966             next unless $operation-&gt;extendedAttributes-&gt;{DOMJIT};
3967             $implIncludes{&quot;DOMJITIDLTypeFilter.h&quot;} = 1;
3968             $implIncludes{&quot;DOMJITAbstractHeapRepository.h&quot;} = 1;
3969 
3970             my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
3971             die &quot;Overloads is not supported in DOMJIT&quot; if $isOverloaded;
3972             die &quot;Currently ReadDOM value is only allowed&quot; unless $codeGenerator-&gt;ExtendedAttributeContains($operation-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;ReadDOM&quot;);
3973 
3974             my $interfaceName = $interface-&gt;type-&gt;name;
3975             my $functionName = GetFunctionName($interface, $className, $operation);
3976             my $unsafeFunctionName = &quot;unsafe&quot; . $codeGenerator-&gt;WK_ucfirst($functionName);
3977             my $domJITSignatureName = &quot;DOMJITSignatureFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($operation-&gt;name);
3978             my $classInfo = &quot;JS&quot; . $interface-&gt;type-&gt;name . &quot;::info()&quot;;
3979             my $resultType = GetResultTypeFilter($interface, $operation-&gt;type);
3980             my $domJITSignatureHeader = &quot;static const JSC::DOMJIT::Signature ${domJITSignatureName}((uintptr_t)${unsafeFunctionName},&quot;;
3981             my $domJITSignatureFooter = &quot;$classInfo, JSC::DOMJIT::Effect::forRead(DOMJIT::AbstractHeapRepository::DOM), ${resultType}&quot;;
3982             foreach my $argument (@{$operation-&gt;arguments}) {
3983                 my $type = $argument-&gt;type;
3984                 my $argumentType = GetArgumentTypeFilter($interface, $type);
3985                 $domJITSignatureFooter .= &quot;, ${argumentType}&quot;;
3986             }
3987             $domJITSignatureFooter .= &quot;);&quot;;
3988             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
3989             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3990             push(@implContent, &quot;$domJITSignatureHeader $domJITSignatureFooter\n&quot;);
3991             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
3992             push(@implContent, &quot;\n&quot;);
3993         }
3994     }
3995 
3996     if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
3997         foreach my $attribute (@attributes) {
3998             next unless $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
3999             assert(&quot;Only DOMJIT=Getter is supported for attributes&quot;) unless $codeGenerator-&gt;ExtendedAttributeContains($attribute-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;Getter&quot;);
4000 
4001             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4002             push(@implContent, &quot;#if ${conditionalString}\n\n&quot;) if $conditionalString;
4003             AddToImplIncludes(&quot;DOMJITIDLTypeFilter.h&quot;, $conditionalString);
4004             my $interfaceName = $interface-&gt;type-&gt;name;
4005             my $generatorName = $interfaceName . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
4006             my $domJITClassName = $generatorName . &quot;Attribute&quot;;
4007             my $getter = GetAttributeGetterName($interface, $generatorName, $attribute);
4008             my $resultType = &quot;JSC::SpecBytecodeTop&quot;;
4009             if ($attribute-&gt;extendedAttributes-&gt;{DOMJIT}) {
4010                 $resultType = GetResultTypeFilter($interface, $attribute-&gt;type);
4011             }
4012             push(@implContent, &quot;static const JSC::DOMJIT::GetterSetter DOMJITAttributeFor${generatorName} {\n&quot;);
4013             push(@implContent, &quot;    $getter,\n&quot;);
4014             push(@implContent, &quot;#if ENABLE(JIT)\n&quot;);
4015             push(@implContent, &quot;    &amp;compile${domJITClassName},\n&quot;);
4016             push(@implContent, &quot;#else\n&quot;);
4017             push(@implContent, &quot;    nullptr,\n&quot;);
4018             push(@implContent, &quot;#endif\n&quot;);
4019             push(@implContent, &quot;    $resultType\n&quot;);
4020             push(@implContent, &quot;};\n\n&quot;);
4021             push(@implContent, &quot;#endif\n\n&quot;) if $conditionalString;
4022         }
4023     }
4024 
4025     GeneratePrototypeDeclaration(\@implContent, $className, $interface) if !HeaderNeedsPrototypeDeclaration($interface);
4026 
4027     GenerateConstructorDeclaration(\@implContent, $className, $interface) if NeedsConstructorProperty($interface);
4028 
4029     my @hashKeys = ();
4030     my @hashValue1 = ();
4031     my @hashValue2 = ();
4032     my @hashSpecials = ();
4033     my %conditionals = ();
4034     my %readWriteConditionals = ();
4035     my $hashName = $className . &quot;Table&quot;;
4036     my @runtimeEnabledOperations = ();
4037     my @runtimeEnabledAttributes = ();
4038 
4039     # Generate hash table for properties on the instance.
4040     my $numInstanceProperties = GeneratePropertiesHashTable($object, $interface, 1, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, \@runtimeEnabledOperations, \@runtimeEnabledAttributes);
4041     $object-&gt;GenerateHashTable($className, $hashName, $numInstanceProperties, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, 0) if $numInstanceProperties &gt; 0;
4042 
4043     # - Add all interface object (aka constructor) properties (constants, static attributes, static operations).
4044     if (NeedsConstructorProperty($interface)) {
4045         my $hashSize = 0;
4046         my $hashName = $className . &quot;ConstructorTable&quot;;
4047 
4048         my @hashKeys = ();
4049         my @hashValue1 = ();
4050         my @hashValue2 = ();
4051         my @hashSpecials = ();
4052         my %conditionals = ();
4053         my %readWriteConditionals = ();
4054 
4055         my $needsConstructorTable = 0;
4056 
4057         foreach my $constant (@{$interface-&gt;constants}) {
4058             my $name = $constant-&gt;name;
4059             push(@hashKeys, $name);
4060             push(@hashValue1, $constant-&gt;value);
4061             push(@hashValue2, &quot;0&quot;);
4062             push(@hashSpecials, &quot;JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::ConstantInteger&quot;);
4063 
4064             my $implementedBy = $constant-&gt;extendedAttributes-&gt;{ImplementedBy};
4065             $implIncludes{&quot;${implementedBy}.h&quot;} = 1 if $implementedBy;
4066 
4067             my $conditional = $constant-&gt;extendedAttributes-&gt;{Conditional};
4068             $conditionals{$name} = $conditional if $conditional;
4069 
4070             $hashSize++;
4071         }
4072 
4073         foreach my $attribute (@{$interface-&gt;attributes}) {
4074             next unless ($attribute-&gt;isStatic);
4075             my $name = $attribute-&gt;name;
4076             push(@hashKeys, $name);
4077 
4078             my @specials = ();
4079             push(@specials, &quot;JSC::PropertyAttribute::DontDelete&quot;) if IsUnforgeable($interface, $attribute);
4080             push(@specials, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if IsReadonly($attribute);
4081             push(@specials, &quot;JSC::PropertyAttribute::DOMAttribute&quot;) if IsAcceleratedDOMAttribute($interface, $attribute);
4082             push(@specials, &quot;JSC::PropertyAttribute::DOMJITAttribute&quot;) if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
4083             my $special = &quot;static_cast&lt;unsigned&gt;(&quot; . ((@specials &gt; 0) ? join(&quot; | &quot;, @specials) : &quot;0&quot;) . &quot;)&quot;;
4084             push(@hashSpecials, $special);
4085 
4086             if ($attribute-&gt;extendedAttributes-&gt;{DOMJIT}) {
4087                 push(@hashValue1, &quot;&amp;DOMJITAttributeFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name));
4088             } else {
4089                 my $getter = GetAttributeGetterName($interface, $className, $attribute);
4090                 push(@hashValue1, $getter);
4091             }
4092 
4093             if (IsReadonly($attribute)) {
4094                 push(@hashValue2, &quot;0&quot;);
4095             } else {
4096                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
4097                 push(@hashValue2, $setter);
4098             }
4099 
4100             my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
4101             $conditionals{$name} = $conditional if $conditional;
4102 
4103             my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
4104             $readWriteConditionals{$name} = $readWriteConditional if $readWriteConditional;
4105 
4106             $hashSize++;
4107         }
4108 
4109         foreach my $operation (@{$interface-&gt;operations}) {
4110             next unless ($operation-&gt;isStatic);
4111             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
4112             my $name = $operation-&gt;name;
4113             push(@hashKeys, $name);
4114 
4115             my $functionName = GetFunctionName($interface, $className, $operation);
4116             push(@hashValue1, $functionName);
4117 
4118             my $functionLength = GetFunctionLength($operation);
4119             if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
4120                 push(@hashValue2, &quot;DOMJITFunctionFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($operation-&gt;name));
4121             } else {
4122                 push(@hashValue2, $functionLength);
4123             }
4124 
4125             push(@hashSpecials, ComputeFunctionSpecial($interface, $operation));
4126 
4127             my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
4128             $conditionals{$name} = $conditional if $conditional;
4129 
4130             $hashSize++;
4131         }
4132 
4133         $object-&gt;GenerateHashTable($className, $hashName, $hashSize, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, 1) if $hashSize &gt; 0;
4134 
4135         push(@implContent, $codeGenerator-&gt;GenerateCompileTimeCheckForEnumsIfNeeded($interface));
4136 
4137         my $protoClassName = &quot;${className}Prototype&quot;;
4138         GenerateConstructorDefinitions(\@implContent, $className, $protoClassName, $visibleInterfaceName, $interface);
4139 
4140         my $namedConstructor = $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
4141         GenerateConstructorDefinitions(\@implContent, $className, $protoClassName, $namedConstructor, $interface, &quot;GeneratingNamedConstructor&quot;) if $namedConstructor;
4142     }
4143 
4144     # - Add functions and constants to a hashtable definition
4145 
4146     $hashName = $className . &quot;PrototypeTable&quot;;
4147 
4148     @hashKeys = ();
4149     @hashValue1 = ();
4150     @hashValue2 = ();
4151     @hashSpecials = ();
4152     %conditionals = ();
4153     %readWriteConditionals = ();
4154     @runtimeEnabledOperations = ();
4155     @runtimeEnabledAttributes = ();
4156 
4157     # Generate hash table for properties on the prototype.
4158     my $numPrototypeProperties = GeneratePropertiesHashTable($object, $interface, 0,
4159         \@hashKeys, \@hashSpecials,
4160         \@hashValue1, \@hashValue2,
4161         \%conditionals, \%readWriteConditionals,
4162         \@runtimeEnabledOperations, \@runtimeEnabledAttributes);
4163 
4164     my $hashSize = $numPrototypeProperties;
4165 
4166     foreach my $constant (@{$interface-&gt;constants}) {
4167         my $name = $constant-&gt;name;
4168 
4169         push(@hashKeys, $name);
4170         push(@hashValue1, $constant-&gt;value);
4171         push(@hashValue2, &quot;0&quot;);
4172         push(@hashSpecials, &quot;JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::ConstantInteger&quot;);
4173 
4174         my $conditional = $constant-&gt;extendedAttributes-&gt;{Conditional};
4175         $conditionals{$name} = $conditional if $conditional;
4176 
4177         $hashSize++;
4178     }
4179 
4180     my $justGenerateValueArray = !IsDOMGlobalObject($interface);
4181 
4182     $object-&gt;GenerateHashTable($className, $hashName, $hashSize, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, $justGenerateValueArray);
4183 
4184     if ($justGenerateValueArray) {
4185         push(@implContent, &quot;const ClassInfo ${className}Prototype::s_info = { \&quot;${visibleInterfaceName}Prototype\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${className}Prototype) };\n\n&quot;);
4186     } else {
4187         push(@implContent, &quot;const ClassInfo ${className}Prototype::s_info = { \&quot;${visibleInterfaceName}Prototype\&quot;, &amp;Base::s_info, &amp;${className}PrototypeTable, nullptr, CREATE_METHOD_TABLE(${className}Prototype) };\n\n&quot;);
4188     }
4189 
4190     if (PrototypeHasStaticPropertyTable($interface) &amp;&amp; !IsGlobalOrPrimaryGlobalInterface($interface)) {
4191         push(@implContent, &quot;void ${className}Prototype::finishCreation(VM&amp; vm)\n&quot;);
4192         push(@implContent, &quot;{\n&quot;);
4193         push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
4194         push(@implContent, &quot;    reifyStaticProperties(vm, ${className}::info(), ${className}PrototypeTableValues, *this);\n&quot;);
4195 
4196         my @runtimeEnabledProperties = @runtimeEnabledOperations;
4197         push(@runtimeEnabledProperties, @runtimeEnabledAttributes);
4198 
4199         if (@runtimeEnabledProperties) {
4200             push(@implContent, &quot;    bool hasDisabledRuntimeProperties = false;\n&quot;);
4201         }
4202 
4203         foreach my $operationOrAttribute (@runtimeEnabledProperties) {
4204             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
4205             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4206             my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute);
4207             my $name = $operationOrAttribute-&gt;name;
4208             push(@implContent, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
4209             push(@implContent, &quot;        hasDisabledRuntimeProperties = true;\n&quot;);
4210             push(@implContent, &quot;        auto propertyName = Identifier::fromString(&amp;vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);
4211             push(@implContent, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
4212             push(@implContent, &quot;        JSObject::deleteProperty(this, globalObject()-&gt;globalExec(), propertyName);\n&quot;);
4213             push(@implContent, &quot;    }\n&quot;);
4214             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4215         }
4216 
4217         if (@runtimeEnabledProperties) {
4218             push(@implContent, &quot;    if (hasDisabledRuntimeProperties &amp;&amp; structure()-&gt;isDictionary())\n&quot;);
4219             push(@implContent, &quot;        flattenDictionaryObject(vm);\n&quot;);
4220         }
4221 
4222         foreach my $operation (@{$interface-&gt;operations}) {
4223             next unless ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier});
4224             AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4225             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4226             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4227             push(@implContent, &quot;    putDirect(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $operation-&gt;name . &quot;PrivateName(), JSFunction::create(vm, globalObject(), 0, String(), &quot; . GetFunctionName($interface, $className, $operation) . &quot;), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4228             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4229         }
4230 
4231         if (InterfaceNeedsIterator($interface)) {
4232             AddToImplIncludes(&quot;&lt;JavaScriptCore/BuiltinNames.h&gt;&quot;);
4233             if (IsKeyValueIterableInterface($interface) or $interface-&gt;mapLike) {
4234                 push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4235             } else {
4236                 AddToImplIncludes(&quot;&lt;JavaScriptCore/ArrayPrototype.h&gt;&quot;);
4237                 push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, globalObject()-&gt;arrayPrototype()-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName()), static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4238             }
4239         }
4240         push(@implContent, &quot;    addValueIterableMethods(*globalObject(), *this);\n&quot;) if $interface-&gt;iterable and !IsKeyValueIterableInterface($interface);
4241 
4242         addUnscopableProperties($interface);
4243 
4244         push(@implContent, &quot;}\n\n&quot;);
4245     }
4246 
4247     # - Initialize static ClassInfo object
4248     push(@implContent, &quot;const ClassInfo $className&quot; . &quot;::s_info = { \&quot;${visibleInterfaceName}\&quot;, &amp;Base::s_info, &quot;);
4249 
4250     if ($numInstanceProperties &gt; 0) {
4251         push(@implContent, &quot;&amp;${className}Table&quot;);
4252     } else {
4253         push(@implContent, &quot;nullptr&quot;);
4254     }
4255     if ($interface-&gt;extendedAttributes-&gt;{DOMJIT}) {
4256         push(@implContent, &quot;\n&quot;);
4257         push(@implContent, &quot;#if ENABLE(JIT)\n&quot;);
4258         push(@implContent, &quot;, &amp;checkSubClassSnippetFor${className}\n&quot;);
4259         push(@implContent, &quot;#else\n&quot;);
4260         push(@implContent, &quot;, nullptr\n&quot;);
4261         push(@implContent, &quot;#endif\n&quot;);
4262     } else {
4263         push(@implContent, &quot;, nullptr&quot;);
4264     }
4265     push(@implContent, &quot;, CREATE_METHOD_TABLE($className) };\n\n&quot;);
4266 
4267     # Constructor
4268     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
4269         AddIncludesForImplementationTypeInImpl(&quot;JSWindowProxy&quot;);
4270         push(@implContent, &quot;${className}::$className(VM&amp; vm, Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl, JSWindowProxy* proxy)\n&quot;);
4271         push(@implContent, &quot;    : $parentClassName(vm, structure, WTFMove(impl), proxy)\n&quot;);
4272         push(@implContent, &quot;{\n&quot;);
4273         push(@implContent, &quot;}\n\n&quot;);
4274     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
4275         AddIncludesForImplementationTypeInImpl($interfaceName);
4276         push(@implContent, &quot;${className}::$className(VM&amp; vm, Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
4277         push(@implContent, &quot;    : $parentClassName(vm, structure, WTFMove(impl))\n&quot;);
4278         push(@implContent, &quot;{\n&quot;);
4279         push(@implContent, &quot;}\n\n&quot;);
4280     } elsif (!NeedsImplementationClass($interface)) {
4281         push(@implContent, &quot;${className}::$className(Structure* structure, JSDOMGlobalObject&amp; globalObject)\n&quot;);
4282         push(@implContent, &quot;    : $parentClassName(structure, globalObject) { }\n\n&quot;);
4283     } else {
4284         push(@implContent, &quot;${className}::$className(Structure* structure, JSDOMGlobalObject&amp; globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
4285         push(@implContent, &quot;    : $parentClassName(structure, globalObject, WTFMove(impl))\n&quot;);
4286         push(@implContent, &quot;{\n&quot;);
4287         push(@implContent, &quot;}\n\n&quot;);
4288     }
4289 
4290     # Finish Creation
4291     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
4292         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm, JSWindowProxy* proxy)\n&quot;);
4293         push(@implContent, &quot;{\n&quot;);
4294         push(@implContent, &quot;    Base::finishCreation(vm, proxy);\n\n&quot;);
4295     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
4296         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm, JSProxy* proxy)\n&quot;);
4297         push(@implContent, &quot;{\n&quot;);
4298         push(@implContent, &quot;    Base::finishCreation(vm, proxy);\n\n&quot;);
4299     } else {
4300         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm)\n&quot;);
4301         push(@implContent, &quot;{\n&quot;);
4302         push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
4303         push(@implContent, &quot;    ASSERT(inherits(vm, info()));\n\n&quot;);
4304     }
4305 
4306     if ($interfaceName eq &quot;Location&quot;) {
4307         push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;valueOf, globalObject()-&gt;objectProtoValueOfFunction(), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4308         push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;toPrimitiveSymbol, jsUndefined(), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4309     }
4310 
4311     if ($interface-&gt;mapLike) {
4312         push(@implContent, &quot;    synchronizeBackingMap(*globalObject()-&gt;globalExec(), *globalObject(), *this);\n&quot;);
4313     }
4314 
4315     # Support for RuntimeEnabled attributes on instances.
4316     foreach my $attribute (@{$interface-&gt;attributes}) {
4317         next unless NeedsRuntimeCheck($interface, $attribute);
4318         next unless AttributeShouldBeOnInstance($interface, $attribute);
4319 
4320         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4321         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $attribute);
4322         my $attributeName = $attribute-&gt;name;
4323         my $getter = GetAttributeGetterName($interface, $className, $attribute);
4324         my $setter = IsReadonly($attribute) ? &quot;nullptr&quot; : GetAttributeSetterName($interface, $className, $attribute);
4325         my $jscAttributes = GetJSCAttributesForAttribute($interface, $attribute);
4326 
4327         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4328         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4329         push(@implContent, &quot;    if (${runtimeEnableConditionalString})\n&quot;);
4330         push(@implContent, &quot;        putDirectCustomAccessor(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $attributeName . &quot;PublicName(), CustomGetterSetter::create(vm, $getter, $setter), attributesForStructure($jscAttributes));\n&quot;);
4331         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4332     }
4333 
4334     # Support PrivateIdentifier attributes on instances.
4335     foreach my $attribute (@{$interface-&gt;attributes}) {
4336         next unless $attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier};
4337         next unless AttributeShouldBeOnInstance($interface, $attribute);
4338 
4339         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4340         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4341         my $attributeName = $attribute-&gt;name;
4342         my $getter = GetAttributeGetterName($interface, $className, $attribute);
4343 
4344         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4345         push(@implContent, &quot;    putDirectCustomAccessor(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $attributeName . &quot;PrivateName(), CustomGetterSetter::create(vm, $getter, nullptr), attributesForStructure(JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly));\n&quot;);
4346         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4347     }
4348 
4349     # Support for RuntimeEnabled operations on instances.
4350     foreach my $operation (@{$interface-&gt;operations}) {
4351         next unless NeedsRuntimeCheck($interface, $operation);
4352         next unless OperationShouldBeOnInstance($interface, $operation);
4353         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
4354 
4355         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4356         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operation);
4357         my $functionName = $operation-&gt;name;
4358         my $implementationFunction = GetFunctionName($interface, $className, $operation);
4359         my $functionLength = GetFunctionLength($operation);
4360         my $jsAttributes = ComputeFunctionSpecial($interface, $operation);
4361 
4362         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4363         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4364         push(@implContent, &quot;    if (${runtimeEnableConditionalString})\n&quot;);
4365         my $propertyName = &quot;static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $functionName . ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} ? &quot;PrivateName()&quot; : &quot;PublicName()&quot;);
4366         if (IsJSBuiltin($interface, $operation)) {
4367             push(@implContent, &quot;        putDirectBuiltinFunction(vm, this, $propertyName, $implementationFunction(vm), attributesForStructure($jsAttributes));\n&quot;);
4368         } else {
4369             push(@implContent, &quot;        putDirectNativeFunction(vm, this, $propertyName, $functionLength, $implementationFunction, NoIntrinsic, attributesForStructure($jsAttributes));\n&quot;);
4370         }
4371         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4372     }
4373     push(@implContent, &quot;}\n\n&quot;);
4374 
4375     unless (ShouldUseGlobalObjectPrototype($interface)) {
4376         push(@implContent, &quot;JSObject* ${className}::createPrototype(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
4377         push(@implContent, &quot;{\n&quot;);
4378         if ($interface-&gt;parentType) {
4379             my $parentClassNameForPrototype = &quot;JS&quot; . $interface-&gt;parentType-&gt;name;
4380             push(@implContent, &quot;    return ${className}Prototype::create(vm, &amp;globalObject, ${className}Prototype::createStructure(vm, &amp;globalObject, ${parentClassNameForPrototype}::prototype(vm, globalObject)));\n&quot;);
4381         } else {
4382             my $prototype = $interface-&gt;isException ? &quot;errorPrototype&quot; : &quot;objectPrototype&quot;;
4383             push(@implContent, &quot;    return ${className}Prototype::create(vm, &amp;globalObject, ${className}Prototype::createStructure(vm, &amp;globalObject, globalObject.${prototype}()));\n&quot;);
4384         }
4385         push(@implContent, &quot;}\n\n&quot;);
4386 
4387         push(@implContent, &quot;JSObject* ${className}::prototype(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
4388         push(@implContent, &quot;{\n&quot;);
4389         push(@implContent, &quot;    return getDOMPrototype&lt;${className}&gt;(vm, globalObject);\n&quot;);
4390         push(@implContent, &quot;}\n\n&quot;);
4391     }
4392 
4393     if (!$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
4394         push(@implContent, &quot;JSValue ${className}::getConstructor(VM&amp; vm, const JSGlobalObject* globalObject)\n&quot;);
4395         push(@implContent, &quot;{\n&quot;);
4396         push(@implContent, &quot;    return getDOMConstructor&lt;${className}Constructor&gt;(vm, *jsCast&lt;const JSDOMGlobalObject*&gt;(globalObject));\n&quot;);
4397         push(@implContent, &quot;}\n\n&quot;);
4398 
4399         if ($interface-&gt;extendedAttributes-&gt;{NamedConstructor}) {
4400             push(@implContent, &quot;JSValue ${className}::getNamedConstructor(VM&amp; vm, JSGlobalObject* globalObject)\n&quot;);
4401             push(@implContent, &quot;{\n&quot;);
4402             push(@implContent, &quot;    return getDOMConstructor&lt;${className}NamedConstructor&gt;(vm, *jsCast&lt;JSDOMGlobalObject*&gt;(globalObject));\n&quot;);
4403             push(@implContent, &quot;}\n\n&quot;);
4404         }
4405     }
4406 
4407     if (!$hasParent) {
4408         push(@implContent, &quot;void ${className}::destroy(JSC::JSCell* cell)\n&quot;);
4409         push(@implContent, &quot;{\n&quot;);
4410         push(@implContent, &quot;    ${className}* thisObject = static_cast&lt;${className}*&gt;(cell);\n&quot;);
4411         push(@implContent, &quot;    thisObject-&gt;${className}::~${className}();\n&quot;);
4412         push(@implContent, &quot;}\n\n&quot;);
4413     }
4414 
4415     if (InstanceOverridesGetOwnPropertySlot($interface)) {
4416         GenerateGetOwnPropertySlot(\@implContent, $interface, $className);
4417         GenerateGetOwnPropertySlotByIndex(\@implContent, $interface, $className);
4418     }
4419     
4420     if (InstanceOverridesGetOwnPropertyNames($interface)) {
4421         GenerateGetOwnPropertyNames(\@implContent, $interface, $className);
4422     }
4423     
4424     if (InstanceOverridesPut($interface)) {
4425         GeneratePut(\@implContent, $interface, $className);
4426         GeneratePutByIndex(\@implContent, $interface, $className);
4427     }
4428     
4429     if (InstanceOverridesDefineOwnProperty($interface)) {
4430         GenerateDefineOwnProperty(\@implContent, $interface, $className);
4431     }
4432 
4433     if (InstanceOverridesDeleteProperty($interface)) {
4434         GenerateNamedDeleterDefinition(\@implContent, $interface, $className);
4435     }
4436     
4437     if (InstanceOverridesGetCallData($interface)) {
4438         GenerateGetCallData(\@implContent, $interface, $className);
4439     }
4440     
4441     if ($numAttributes &gt; 0) {
4442         AddToImplIncludes(&quot;JSDOMAttribute.h&quot;);
4443 
4444         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
4445         # FIXME: Remove ImplicitThis keyword as it is no longer defined by WebIDL spec and is only used in DOMWindow.
4446         if ($interface-&gt;extendedAttributes-&gt;{ImplicitThis}) {
4447             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(ExecState&amp; state, EncodedJSValue thisValue)\n&quot;);
4448             push(@implContent, &quot;{\n&quot;);
4449             push(@implContent, &quot;    auto decodedThisValue = JSValue::decode(thisValue);\n&quot;);
4450             push(@implContent, &quot;    if (decodedThisValue.isUndefinedOrNull())\n&quot;);
4451             push(@implContent, &quot;        decodedThisValue = state.thisValue().toThis(&amp;state, NotStrictMode);\n&quot;);
4452             push(@implContent, &quot;    return $castingFunction(state.vm(), decodedThisValue);&quot;);
4453             push(@implContent, &quot;}\n\n&quot;);
4454         } else {
4455             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(ExecState&amp; state, EncodedJSValue thisValue)\n&quot;);
4456             push(@implContent, &quot;{\n&quot;);
4457             push(@implContent, &quot;    return $castingFunction(state.vm(), JSValue::decode(thisValue));\n&quot;);
4458             push(@implContent, &quot;}\n\n&quot;);
4459         }
4460     }
4461 
4462     if ($numOperations &gt; 0 &amp;&amp; $interfaceName ne &quot;EventTarget&quot;) {
4463         AddToImplIncludes(&quot;JSDOMOperation.h&quot;);
4464 
4465         # FIXME: Make consistent IDLAttribute&lt;&gt;::cast and IDLOperation&lt;&gt;::cast in case of CustomProxyToJSObject.
4466         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
4467         my $thisValue = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;state.thisValue().toThis(&amp;state, NotStrictMode)&quot; : &quot;state.thisValue()&quot;;
4468         push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLOperation&lt;${className}&gt;::cast(ExecState&amp; state)\n&quot;);
4469         push(@implContent, &quot;{\n&quot;);
4470         push(@implContent, &quot;    return $castingFunction(state.vm(), $thisValue);\n&quot;);
4471         push(@implContent, &quot;}\n\n&quot;);
4472     }
4473 
4474     if (NeedsConstructorProperty($interface)) {
4475         my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
4476 
4477         push(@implContent, &quot;EncodedJSValue ${constructorGetter}(ExecState* state, EncodedJSValue thisValue, PropertyName)\n&quot;);
4478         push(@implContent, &quot;{\n&quot;);
4479         push(@implContent, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
4480         push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
4481         push(@implContent, &quot;    auto* prototype = jsDynamicCast&lt;${className}Prototype*&gt;(vm, JSValue::decode(thisValue));\n&quot;);
4482         push(@implContent, &quot;    if (UNLIKELY(!prototype))\n&quot;);
4483         push(@implContent, &quot;        return throwVMTypeError(state, throwScope);\n&quot;);
4484 
4485         if (!$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
4486             push(@implContent, &quot;    return JSValue::encode(${className}::getConstructor(state-&gt;vm(), prototype-&gt;globalObject()));\n&quot;);
4487         } else {
4488             push(@implContent, &quot;    JSValue constructor = ${className}Constructor::create(state-&gt;vm(), ${className}Constructor::createStructure(state-&gt;vm(), *prototype-&gt;globalObject(), prototype-&gt;globalObject()-&gt;objectPrototype()), *jsCast&lt;JSDOMGlobalObject*&gt;(prototype-&gt;globalObject()));\n&quot;);
4489             push(@implContent, &quot;    // Shadowing constructor property to ensure reusing the same constructor object\n&quot;);
4490             push(@implContent, &quot;    prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, constructor, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4491             push(@implContent, &quot;    return JSValue::encode(constructor);\n&quot;);
4492         }
4493         push(@implContent, &quot;}\n\n&quot;);
4494 
4495         my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
4496 
4497         push(@implContent, &quot;bool ${constructorSetter}(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);
4498         push(@implContent, &quot;{\n&quot;);
4499         push(@implContent, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
4500         push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
4501         push(@implContent, &quot;    auto* prototype = jsDynamicCast&lt;${className}Prototype*&gt;(vm, JSValue::decode(thisValue));\n&quot;);
4502         push(@implContent, &quot;    if (UNLIKELY(!prototype)) {\n&quot;);
4503         push(@implContent, &quot;        throwVMTypeError(state, throwScope);\n&quot;);
4504         push(@implContent, &quot;        return false;\n&quot;);
4505         push(@implContent, &quot;    }\n&quot;);
4506         push(@implContent, &quot;    // Shadowing a built-in constructor\n&quot;);
4507         push(@implContent, &quot;    return prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, JSValue::decode(encodedValue));\n&quot;);
4508         push(@implContent, &quot;}\n\n&quot;);
4509 
4510     }
4511 
4512     foreach my $attribute (@attributes) {
4513         GenerateAttributeGetterDefinition(\@implContent, $interface, $className, $attribute);
4514         GenerateAttributeSetterDefinition(\@implContent, $interface, $className, $attribute);
4515     }
4516 
4517     foreach my $operation (@operations) {
4518         GenerateOperationDefinition(\@implContent, $interface, $className, $operation);
4519     }
4520     
4521     GenerateIterableDefinition($interface) if $interface-&gt;iterable;
4522     GenerateSerializerDefinition($interface, $className) if $interface-&gt;serializable;
4523 
4524     if ($needsVisitChildren) {
4525         push(@implContent, &quot;void ${className}::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)\n&quot;);
4526         push(@implContent, &quot;{\n&quot;);
4527         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4528         push(@implContent, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
4529         push(@implContent, &quot;    Base::visitChildren(thisObject, visitor);\n&quot;);
4530         push(@implContent, &quot;    thisObject-&gt;visitAdditionalChildren(visitor);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
4531         if ($interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost}) {
4532             push(@implContent, &quot;    visitor.reportExtraMemoryVisited(thisObject-&gt;wrapped().memoryCost());\n&quot;);
4533             if ($interface-&gt;extendedAttributes-&gt;{ReportExternalMemoryCost}) {;
4534                 push(@implContent, &quot;#if ENABLE(RESOURCE_USAGE)\n&quot;);
4535                 push(@implContent, &quot;    visitor.reportExternalMemoryVisited(thisObject-&gt;wrapped().externalMemoryCost());\n&quot;);
4536                 push(@implContent, &quot;#endif\n&quot;);
4537             }
4538         }
4539         if ($numCachedAttributes &gt; 0) {
4540             foreach my $attribute (@{$interface-&gt;attributes}) {
4541                 if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
4542                     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4543                     push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4544                     push(@implContent, &quot;    visitor.append(thisObject-&gt;m_&quot; . $attribute-&gt;name . &quot;);\n&quot;);
4545                     push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4546                 }
4547             }
4548         }
4549         push(@implContent, &quot;}\n\n&quot;);
4550         if ($interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction}) {
4551             push(@implContent, &quot;void ${className}::visitOutputConstraints(JSCell* cell, SlotVisitor&amp; visitor)\n&quot;);
4552             push(@implContent, &quot;{\n&quot;);
4553             push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4554             push(@implContent, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
4555             push(@implContent, &quot;    Base::visitOutputConstraints(thisObject, visitor);\n&quot;);
4556             push(@implContent, &quot;    thisObject-&gt;visitAdditionalChildren(visitor);\n&quot;);
4557             push(@implContent, &quot;}\n\n&quot;);
4558         }
4559     }
4560 
4561     if (InstanceNeedsEstimatedSize($interface)) {
4562         push(@implContent, &quot;size_t ${className}::estimatedSize(JSCell* cell, VM&amp; vm)\n&quot;);
4563         push(@implContent, &quot;{\n&quot;);
4564         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4565         push(@implContent, &quot;    return Base::estimatedSize(thisObject, vm) + thisObject-&gt;wrapped().memoryCost();\n&quot;);
4566         push(@implContent, &quot;}\n\n&quot;);
4567     }
4568 
4569     if (NeedsImplementationClass($interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{CustomHeapSnapshot}) {
4570         AddToImplIncludes(&quot;&lt;JavaScriptCore/HeapSnapshotBuilder.h&gt;&quot;);
4571         AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
4572         AddToImplIncludes(&quot;&lt;wtf/URL.h&gt;&quot;);
4573         push(@implContent, &quot;void ${className}::heapSnapshot(JSCell* cell, HeapSnapshotBuilder&amp; builder)\n&quot;);
4574         push(@implContent, &quot;{\n&quot;);
4575         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4576         push(@implContent, &quot;    builder.setWrappedObjectForCell(cell, &amp;thisObject-&gt;wrapped());\n&quot;);
4577         push(@implContent, &quot;    if (thisObject-&gt;scriptExecutionContext())\n&quot;);
4578         push(@implContent, &quot;        builder.setLabelForCell(cell, \&quot;url \&quot; + thisObject-&gt;scriptExecutionContext()-&gt;url().string());\n&quot;);
4579         push(@implContent, &quot;    Base::heapSnapshot(cell, builder);\n&quot;);
4580         push(@implContent, &quot;}\n\n&quot;);
4581     }
4582 
4583     if ($indexedGetterOperation) {
4584         $implIncludes{&quot;&lt;wtf/URL.h&gt;&quot;} = 1 if $indexedGetterOperation-&gt;type-&gt;name eq &quot;DOMString&quot;;
4585         if ($interfaceName =~ /^HTML\w*Collection$/ or $interfaceName eq &quot;RadioNodeList&quot;) {
4586             $implIncludes{&quot;JSNode.h&quot;} = 1;
4587             $implIncludes{&quot;Node.h&quot;} = 1;
4588         }
4589     }
4590 
4591     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface) &amp;&amp; !GetCustomIsReachable($interface)) {
4592         push(@implContent, &quot;bool JS${interfaceName}Owner::isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason)\n&quot;);
4593         push(@implContent, &quot;{\n&quot;);
4594         # All ActiveDOMObjects implement hasPendingActivity(), but not all of them
4595         # increment their C++ reference counts when hasPendingActivity() becomes
4596         # true. As a result, ActiveDOMObjects can be prematurely destroyed before
4597         # their pending activities complete. To wallpaper over this bug, JavaScript
4598         # wrappers unconditionally keep ActiveDOMObjects with pending activity alive.
4599         # FIXME: Fix this lifetime issue in the DOM, and move this hasPendingActivity
4600         # check just above the (GetGenerateIsReachable($interface) eq &quot;Impl&quot;) check below.
4601         my $emittedJSCast = 0;
4602         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;ActiveDOMObject&quot;)) {
4603             push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4604             $emittedJSCast = 1;
4605             push(@implContent, &quot;    if (js${interfaceName}-&gt;wrapped().hasPendingActivity()) {\n&quot;);
4606             push(@implContent, &quot;        if (UNLIKELY(reason))\n&quot;);
4607             push(@implContent, &quot;            *reason = \&quot;ActiveDOMObject with pending activity\&quot;;\n&quot;);
4608             push(@implContent, &quot;        return true;\n&quot;);
4609             push(@implContent, &quot;     }\n&quot;);
4610         }
4611         if ($codeGenerator-&gt;InheritsInterface($interface, &quot;EventTarget&quot;)) {
4612             if (!$emittedJSCast) {
4613                 push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4614                 $emittedJSCast = 1;
4615             }
4616             push(@implContent, &quot;    if (js${interfaceName}-&gt;wrapped().isFiringEventListeners()) {\n&quot;);
4617             push(@implContent, &quot;        if (UNLIKELY(reason))\n&quot;);
4618             push(@implContent, &quot;            *reason = \&quot;EventTarget firing event listeners\&quot;;\n&quot;);
4619             push(@implContent, &quot;        return true;\n&quot;);
4620             push(@implContent, &quot;    }\n&quot;);
4621         }
4622         if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Node&quot;)) {
4623             if (!$emittedJSCast) {
4624                 push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4625                 $emittedJSCast = 1;
4626             }
4627             push(@implContent, &quot;    if (JSNodeOwner::isReachableFromOpaqueRoots(handle, 0, visitor, reason))\n&quot;);
4628             push(@implContent, &quot;        return true;\n&quot;);
4629         }
4630         if (GetGenerateIsReachable($interface)) {
4631             if (!$emittedJSCast) {
4632                 push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4633                 $emittedJSCast = 1;
4634             }
4635 
4636             my $rootString;
4637             if (GetGenerateIsReachable($interface) eq &quot;Impl&quot;) {
4638                 $rootString  = &quot;    ${implType}* root = &amp;js${interfaceName}-&gt;wrapped();\n&quot;;
4639                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4640                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}\&quot;;\n&quot;;
4641             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplWebGLRenderingContext&quot;) {
4642                 $rootString  = &quot;    WebGLRenderingContextBase* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().context());\n&quot;;
4643                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4644                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}\&quot;;\n&quot;;
4645             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplFrame&quot;) {
4646                 $rootString  = &quot;    Frame* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().frame());\n&quot;;
4647                 $rootString .= &quot;    if (!root)\n&quot;;
4648                 $rootString .= &quot;        return false;\n&quot;;
4649                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4650                 $rootString .= &quot;        *reason = \&quot;Reachable from Frame\&quot;;\n&quot;;
4651             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplDocument&quot;) {
4652                 $rootString  = &quot;    Document* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().document());\n&quot;;
4653                 $rootString .= &quot;    if (!root)\n&quot;;
4654                 $rootString .= &quot;        return false;\n&quot;;
4655                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4656                 $rootString .= &quot;        *reason = \&quot;Reachable from Document\&quot;;\n&quot;;
4657             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplElementRoot&quot;) {
4658                 $implIncludes{&quot;Element.h&quot;} = 1;
4659                 $implIncludes{&quot;JSNodeCustom.h&quot;} = 1;
4660                 $rootString  = &quot;    Element* element = WTF::getPtr(js${interfaceName}-&gt;wrapped().element());\n&quot;;
4661                 $rootString .= &quot;    if (!element)\n&quot;;
4662                 $rootString .= &quot;        return false;\n&quot;;
4663                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4664                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}Owner\&quot;;\n&quot;;
4665                 $rootString .= &quot;    void* root = WebCore::root(element);\n&quot;;
4666             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplOwnerNodeRoot&quot;) {
4667                 $implIncludes{&quot;Element.h&quot;} = 1;
4668                 $implIncludes{&quot;JSNodeCustom.h&quot;} = 1;
4669                 $rootString  = &quot;    void* root = WebCore::root(js${interfaceName}-&gt;wrapped().ownerNode());\n&quot;;
4670                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4671                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName} ownerNode\&quot;;\n&quot;;
4672             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplScriptExecutionContext&quot;) {
4673                 $rootString  = &quot;    ScriptExecutionContext* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().scriptExecutionContext());\n&quot;;
4674                 $rootString .= &quot;    if (!root)\n&quot;;
4675                 $rootString .= &quot;        return false;\n&quot;;
4676                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4677                 $rootString .= &quot;        *reason = \&quot;Reachable from ScriptExecutionContext\&quot;;\n&quot;;
4678             } else {
4679                 $rootString  = &quot;    void* root = WebCore::root(&amp;js${interfaceName}-&gt;wrapped());\n&quot;;
4680                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4681                 $rootString .= &quot;        *reason = \&quot;Reachable from js${interfaceName}\&quot;;\n&quot;;
4682             }
4683 
4684             push(@implContent, $rootString);
4685             push(@implContent, &quot;    return root &amp;&amp; visitor.containsOpaqueRoot(root);\n&quot;);
4686         } else {
4687             if (!$emittedJSCast) {
4688                 push(@implContent, &quot;    UNUSED_PARAM(handle);\n&quot;);
4689             }
4690             push(@implContent, &quot;    UNUSED_PARAM(visitor);\n&quot;);
4691             push(@implContent, &quot;    UNUSED_PARAM(reason);\n&quot;);
4692             push(@implContent, &quot;    return false;\n&quot;);
4693         }
4694         push(@implContent, &quot;}\n\n&quot;);
4695     }
4696 
4697     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{JSCustomFinalize}) {
4698         push(@implContent, &quot;void JS${interfaceName}Owner::finalize(JSC::Handle&lt;JSC::Unknown&gt; handle, void* context)\n&quot;);
4699         push(@implContent, &quot;{\n&quot;);
4700         push(@implContent, &quot;    auto* js${interfaceName} = static_cast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4701         push(@implContent, &quot;    auto&amp; world = *static_cast&lt;DOMWrapperWorld*&gt;(context);\n&quot;);
4702         push(@implContent, &quot;    uncacheWrapper(world, &amp;js${interfaceName}-&gt;wrapped(), js${interfaceName});\n&quot;);
4703         push(@implContent, &quot;}\n\n&quot;);
4704     }
4705 
4706     if (ShouldGenerateToJSImplementation($hasParent, $interface)) {
4707         my $vtableNameGnu = GetGnuVTableNameForInterface($interface);
4708         my $vtableRefGnu = GetGnuVTableRefForInterface($interface);
4709         my $vtableRefWin = GetWinVTableRefForInterface($interface);
4710 
4711         push(@implContent, &lt;&lt;END) if $vtableNameGnu;
4712 #if ENABLE(BINDING_INTEGRITY)
4713 #if PLATFORM(WIN)
4714 #pragma warning(disable: 4483)
4715 extern &quot;C&quot; { extern void (*const ${vtableRefWin}[])(); }
4716 #else
4717 extern &quot;C&quot; { extern void* ${vtableNameGnu}[]; }
4718 #endif
4719 #endif
4720 
4721 END
4722 
4723         push(@implContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::ExecState*, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
4724         push(@implContent, &quot;{\n&quot;);
4725         push(@implContent, &lt;&lt;END) if $vtableNameGnu;
4726 
4727 #if ENABLE(BINDING_INTEGRITY)
4728     void* actualVTablePointer = *(reinterpret_cast&lt;void**&gt;(impl.ptr()));
4729 #if PLATFORM(WIN)
4730     void* expectedVTablePointer = WTF_PREPARE_VTBL_POINTER_FOR_INSPECTION(${vtableRefWin});
4731 #else
4732     void* expectedVTablePointer = WTF_PREPARE_VTBL_POINTER_FOR_INSPECTION(${vtableRefGnu});
4733 #endif
4734 
4735     // If this fails ${implType} does not have a vtable, so you need to add the
4736     // ImplementationLacksVTable attribute to the interface definition
4737     static_assert(std::is_polymorphic&lt;${implType}&gt;::value, &quot;${implType} is not polymorphic&quot;);
4738 
4739     // If you hit this assertion you either have a use after free bug, or
4740     // ${implType} has subclasses. If ${implType} has subclasses that get passed
4741     // to toJS() we currently require $interfaceName you to opt out of binding hardening
4742     // by adding the SkipVTableValidation attribute to the interface IDL definition
4743     RELEASE_ASSERT(actualVTablePointer == expectedVTablePointer);
4744 #endif
4745 END
4746         push(@implContent, &lt;&lt;END) if $interface-&gt;extendedAttributes-&gt;{ImplementationLacksVTable};
4747     // If you hit this failure the interface definition has the ImplementationLacksVTable
4748     // attribute. You should remove that attribute. If the class has subclasses
4749     // that may be passed through this toJS() function you should use the SkipVTableValidation
4750     // attribute to $interfaceName.
4751     static_assert(!std::is_polymorphic&lt;${implType}&gt;::value, &quot;${implType} is polymorphic but the IDL claims it is not&quot;);
4752 END
4753         push(@implContent, &lt;&lt;END) if $interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost};
4754     globalObject-&gt;vm().heap.reportExtraMemoryAllocated(impl-&gt;memoryCost());
4755 END
4756 
4757         push(@implContent, &quot;    return createWrapper&lt;${implType}&gt;(globalObject, WTFMove(impl));\n&quot;);
4758         push(@implContent, &quot;}\n\n&quot;);
4759 
4760         push(@implContent, &quot;JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject* globalObject, ${implType}&amp; impl)\n&quot;);
4761         push(@implContent, &quot;{\n&quot;);
4762         push(@implContent, &quot;    return wrap(state, globalObject, impl);\n&quot;);
4763         push(@implContent, &quot;}\n\n&quot;);
4764     }
4765 
4766     if (ShouldGenerateToWrapped($hasParent, $interface) and !$interface-&gt;extendedAttributes-&gt;{JSCustomToNativeObject}) {
4767         push(@implContent, &quot;${implType}* ${className}::toWrapped(JSC::VM&amp; vm, JSC::JSValue value)\n&quot;);
4768         push(@implContent, &quot;{\n&quot;);
4769         push(@implContent, &quot;    if (auto* wrapper = &quot; . GetCastingHelperForThisObject($interface) . &quot;(vm, value))\n&quot;);
4770         push(@implContent, &quot;        return &amp;wrapper-&gt;wrapped();\n&quot;);
4771         push(@implContent, &quot;    return nullptr;\n&quot;);
4772         push(@implContent, &quot;}\n&quot;);
4773     }
4774 
4775     push(@implContent, &quot;\n}\n&quot;);
4776 
4777     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
4778     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
4779 }
4780 
4781 sub GenerateAttributeGetterBodyDefinition
4782 {
4783     my ($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional) = @_;
4784     
4785     my @signatureArguments = ();
4786     push(@signatureArguments, &quot;ExecState&amp; state&quot;);
4787     push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
4788     push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
4789     
4790     push(@$outputArray, &quot;static inline JSValue ${attributeGetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
4791     push(@$outputArray, &quot;{\n&quot;);
4792     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
4793     push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);
4794 
4795     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp;
4796         !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp;
4797         !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnGetter}) {
4798         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
4799         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
4800             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped(), ThrowSecurityError))\n&quot;);
4801         } else {
4802             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);
4803         }
4804         push(@$outputArray, &quot;        return jsUndefined();\n&quot;);
4805     }
4806     
4807     if (HasCustomGetter($attribute)) {
4808         my $implGetterFunctionName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;extendedAttributes-&gt;{ImplementedAs} || $attribute-&gt;name);
4809         push(@$outputArray, &quot;    return thisObject.${implGetterFunctionName}(state);\n&quot;);
4810     } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
4811         $implIncludes{&quot;EventNames.h&quot;} = 1;
4812         my $getter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;windowEventHandlerAttribute&quot;
4813             : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;documentEventHandlerAttribute&quot;
4814             : &quot;eventHandlerAttribute&quot;;
4815         my $eventName = EventHandlerAttributeEventName($attribute);
4816         push(@$outputArray, &quot;    return $getter(thisObject.wrapped(), $eventName, worldForDOMObject(thisObject));\n&quot;);
4817     } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
4818         my $constructorType = $attribute-&gt;type-&gt;name;
4819         $constructorType =~ s/Constructor$//;
4820         # When Constructor attribute is used by DOMWindow.idl, it&#39;s correct to pass thisObject as the global object
4821         # When JSDOMWrappers have a back-pointer to the globalObject we can pass thisObject-&gt;globalObject()
4822         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
4823             my $named = ($constructorType =~ /Named$/) ? &quot;Named&quot; : &quot;&quot;;
4824             $constructorType =~ s/Named$//;
4825             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::get${named}Constructor(state.vm(), &amp;thisObject);\n&quot;);
4826         } else {
4827             AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
4828             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::getConstructor(state.vm(), thisObject.globalObject());\n&quot;);
4829         }
4830     } else {
4831         if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
4832             push(@$outputArray, &quot;    if (JSValue cachedValue = thisObject.m_&quot; . $attribute-&gt;name . &quot;.get())\n&quot;);
4833             push(@$outputArray, &quot;        return cachedValue;\n&quot;);
4834         }
4835         
4836         my @callWithArgs = GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;jsUndefined()&quot;, &quot;thisObject&quot;);
4837         
4838         my ($baseFunctionName, @arguments) = $codeGenerator-&gt;GetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
4839         my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
4840         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;state&quot;, &quot;thisObject&quot;);
4841         
4842         unshift(@arguments, @callWithArgs);
4843 
4844         my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())&quot; : &quot;*thisObject.globalObject()&quot;;
4845         my $toJSExpression = NativeToJSValueUsingReferences($attribute, $interface, &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;, $globalObjectReference);
4846         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) unless $attribute-&gt;isStatic or $attribute-&gt;isMapLike;
4847 
4848         if (!IsReadonly($attribute)) {
4849             my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
4850             if ($callTracingCallback) {
4851                 my @callTracerArguments = ();
4852                 GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, &quot;    &quot;);
4853             }
4854         }
4855 
4856         push(@$outputArray, &quot;    JSValue result = ${toJSExpression};\n&quot;);
4857         push(@$outputArray, &quot;    thisObject.m_&quot; . $attribute-&gt;name . &quot;.set(state.vm(), &amp;thisObject, result);\n&quot;) if $attribute-&gt;extendedAttributes-&gt;{CachedAttribute};
4858         push(@$outputArray, &quot;    return result;\n&quot;);
4859     }
4860     push(@$outputArray, &quot;}\n\n&quot;);
4861 }
4862 
4863 sub GenerateAttributeGetterTrampolineDefinition
4864 {
4865     my ($outputArray, $interface, $className, $attribute, $attributeGetterName, $attributeGetterBodyName, $conditional) = @_;
4866     
4867     AddToImplIncludes(&quot;JSDOMAttribute.h&quot;, $conditional);
4868     
4869     my $callAttributeGetterName = &quot;get&quot;;
4870     $callAttributeGetterName .= &quot;Static&quot; if $attribute-&gt;isStatic;
4871     
4872     my @templateParameters = ();
4873     push(@templateParameters, $attributeGetterBodyName);
4874     if ($attribute-&gt;extendedAttributes-&gt;{LenientThis}) {
4875         push(@templateParameters, &quot;CastedThisErrorBehavior::ReturnEarly&quot;)
4876     } elsif ($codeGenerator-&gt;IsPromiseType($attribute-&gt;type)) {
4877         push(@templateParameters, &quot;CastedThisErrorBehavior::RejectPromise&quot;)
4878     } elsif (IsAcceleratedDOMAttribute($interface, $attribute)) {
4879         push(@templateParameters, &quot;CastedThisErrorBehavior::Assert&quot;);
4880     }
4881     
4882     push(@$outputArray, &quot;EncodedJSValue ${attributeGetterName}(ExecState* state, EncodedJSValue thisValue, PropertyName)\n&quot;);
4883     push(@$outputArray, &quot;{\n&quot;);
4884     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeGetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*state, thisValue, \&quot;&quot; . $attribute-&gt;name .  &quot;\&quot;);\n&quot;);
4885     push(@$outputArray, &quot;}\n\n&quot;);
4886 }
4887 
4888 sub GenerateAttributeGetterDefinition
4889 {
4890     my ($outputArray, $interface, $className, $attribute) = @_;
4891 
4892     return if IsJSBuiltin($interface, $attribute);
4893 
4894     my $attributeGetterName = GetAttributeGetterName($interface, $className, $attribute);
4895     my $attributeGetterBodyName = $attributeGetterName . &quot;Getter&quot;;
4896     
4897     my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
4898     if ($conditional) {
4899         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
4900         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
4901     }
4902     
4903     GenerateAttributeGetterBodyDefinition($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional);
4904     GenerateAttributeGetterTrampolineDefinition($outputArray, $interface, $className, $attribute, $attributeGetterName, $attributeGetterBodyName, $conditional);
4905     
4906     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
4907 }
4908 
4909 sub GenerateAttributeSetterBodyDefinition
4910 {
4911     my ($outputArray, $interface, $className, $attribute, $attributeSetterBodyName, $conditional) = @_;
4912 
4913     my @signatureArguments = ();
4914     push(@signatureArguments, &quot;ExecState&amp; state&quot;);
4915     push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
4916     push(@signatureArguments, &quot;JSValue value&quot;);
4917     push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
4918     
4919     push(@$outputArray, &quot;static inline bool ${attributeSetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
4920     push(@$outputArray, &quot;{\n&quot;);
4921     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
4922 
4923     GenerateCustomElementReactionsStackIfNeeded($outputArray, $attribute, &quot;state&quot;);
4924 
4925     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnSetter}) {
4926         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
4927         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
4928             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped(), ThrowSecurityError))\n&quot;);
4929         } else {
4930             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);
4931         }
4932         push(@$outputArray, &quot;        return false;\n&quot;);
4933     }
4934     
4935     if (HasCustomSetter($attribute)) {
4936         my $implSetterFunctionName = $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
4937         push(@$outputArray, &quot;    thisObject.set${implSetterFunctionName}(state, value);\n&quot;);
4938         push(@$outputArray, &quot;    return true;\n&quot;);
4939     } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
4940         AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
4941         my $eventName = EventHandlerAttributeEventName($attribute);
4942         # FIXME: Find a way to do this special case without hardcoding the class and attribute names here.
4943         if (($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot; or $interface-&gt;type-&gt;name eq &quot;WorkerGlobalScope&quot;) and $attribute-&gt;name eq &quot;onerror&quot;) {
4944             AddToImplIncludes(&quot;JSErrorHandler.h&quot;, $conditional);
4945             push(@$outputArray, &quot;    thisObject.wrapped().setAttributeEventListener($eventName, createJSErrorHandler(state, value, thisObject), worldForDOMObject(thisObject));\n&quot;);
4946         } else {
4947             AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
4948             my $setter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;setWindowEventHandlerAttribute&quot;
4949                 : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;setDocumentEventHandlerAttribute&quot;
4950                 : &quot;setEventHandlerAttribute&quot;;
4951             push(@$outputArray, &quot;    $setter(state, thisObject, thisObject.wrapped(), ${eventName}, value);\n&quot;);
4952         }
4953         push(@$outputArray, &quot;    return true;\n&quot;);
4954     } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
4955         my $constructorType = $attribute-&gt;type-&gt;name;
4956         $constructorType =~ s/Constructor$//;
4957         # $constructorType ~= /Constructor$/ indicates that it is NamedConstructor.
4958         # We do not generate the header file for NamedConstructor of class XXXX,
4959         # since we generate the NamedConstructor declaration into the header file of class XXXX.
4960         if ($constructorType ne &quot;any&quot; and $constructorType !~ /Named$/) {
4961             AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
4962         }
4963         my $id = $attribute-&gt;name;
4964         push(@$outputArray, &quot;    // Shadowing a built-in constructor.\n&quot;);
4965         push(@$outputArray, &quot;    return thisObject.putDirect(state.vm(), Identifier::fromString(&amp;state.vm(), reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
4966     } elsif ($attribute-&gt;extendedAttributes-&gt;{Replaceable}) {
4967         my $id = $attribute-&gt;name;
4968         push(@$outputArray, &quot;    // Shadowing a built-in property.\n&quot;);
4969         if (AttributeShouldBeOnInstance($interface, $attribute)) {
4970             push(@$outputArray, &quot;    return replaceStaticPropertySlot(state.vm(), &amp;thisObject, Identifier::fromString(&amp;state.vm(), reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
4971         } else {
4972             push(@$outputArray, &quot;    return thisObject.putDirect(state.vm(), Identifier::fromString(&amp;state.vm(), reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
4973         }
4974     } elsif ($attribute-&gt;extendedAttributes-&gt;{PutForwards}) {
4975         assert(&quot;[PutForwards] is not compatible with static attributes&quot;) if $attribute-&gt;isStatic;
4976         
4977         # 3.5.9.1. Let Q be ? Get(O, id).
4978         my $id = $attribute-&gt;name;
4979         push(@$outputArray, &quot;    auto id = Identifier::fromString(&amp;state.vm(), reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;));\n&quot;);
4980         push(@$outputArray, &quot;    auto valueToForwardTo = thisObject.get(&amp;state, id);\n&quot;);
4981         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
4982         
4983         # 3.5.9.2. If Type(Q) is not Object, then throw a TypeError.
4984         push(@$outputArray, &quot;    if (UNLIKELY(!valueToForwardTo.isObject())) {\n&quot;);
4985         push(@$outputArray, &quot;        throwTypeError(&amp;state, throwScope);\n&quot;);
4986         push(@$outputArray, &quot;        return false;\n&quot;);
4987         push(@$outputArray, &quot;    }\n&quot;);
4988         
4989         # 3.5.9.3. Let forwardId be the identifier argument of the [PutForwards] extended attribute.
4990         my $forwardId = $attribute-&gt;extendedAttributes-&gt;{PutForwards};
4991         push(@$outputArray, &quot;    auto forwardId = Identifier::fromString(&amp;state.vm(), reinterpret_cast&lt;const LChar*&gt;(\&quot;${forwardId}\&quot;), strlen(\&quot;${forwardId}\&quot;));\n&quot;);
4992         
4993         # 3.5.9.4. Perform ? Set(Q, forwardId, V).
4994         # FIXME: What should the second value to the PutPropertySlot be?
4995         # (https://github.com/heycam/webidl/issues/368)
4996         push(@$outputArray, &quot;    PutPropertySlot slot(valueToForwardTo, false);\n&quot;);
4997         push(@$outputArray, &quot;    asObject(valueToForwardTo)-&gt;methodTable(state.vm())-&gt;put(asObject(valueToForwardTo), &amp;state, forwardId, value, slot);\n&quot;);
4998         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
4999         
5000         push(@$outputArray, &quot;    return true;\n&quot;);
5001     } else {
5002         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) if !$attribute-&gt;isStatic;
5003        
5004         if ($codeGenerator-&gt;IsEnumType($attribute-&gt;type)) {
5005             # As per section 3.5.6 of https://heycam.github.io/webidl/#dfn-attribute-setter, enumerations do not use
5006             # the standard conversion, but rather silently fail on invalid enumeration values.
5007             push(@$outputArray, &quot;    auto optionalNativeValue = parseEnumeration&lt;&quot; . GetEnumerationClassName($attribute-&gt;type, $interface) . &quot;&gt;(state, value);\n&quot;);
5008             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5009             push(@$outputArray, &quot;    if (UNLIKELY(!optionalNativeValue))\n&quot;);
5010             push(@$outputArray, &quot;        return false;\n&quot;);
5011             push(@$outputArray, &quot;    auto nativeValue = optionalNativeValue.value();\n&quot;);
5012         } else {
5013             my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*thisObject.globalObject()&quot;;
5014             my $exceptionThrower = GetAttributeExceptionThrower($interface, $attribute);
5015 
5016             my $toNativeExpression = JSValueToNative($interface, $attribute, &quot;value&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;state&quot;, &quot;state&quot;, &quot;thisObject&quot;, $globalObjectReference, $exceptionThrower);
5017             push(@$outputArray, &quot;    auto nativeValue = ${toNativeExpression};\n&quot;);
5018             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5019         }
5020 
5021         my ($baseFunctionName, @arguments) = $codeGenerator-&gt;SetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
5022 
5023         push(@arguments, PassArgumentExpression(&quot;nativeValue&quot;, $attribute));
5024 
5025         my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
5026         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;state&quot;, &quot;thisObject&quot;);
5027 
5028         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{SetterCallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5029         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5030 
5031         my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
5032         if ($callTracingCallback) {
5033             my $indent = &quot;    &quot;;
5034             my @callTracerArguments = ();
5035             push(@callTracerArguments, GenerateCallTracerParameter(&quot;nativeValue&quot;, $attribute-&gt;type, 0, $indent));
5036             GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, $indent);
5037         }
5038 
5039         my $functionString = &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5040         push(@$outputArray, &quot;    AttributeSetter::call(state, throwScope, [&amp;] {\n&quot;);
5041         push(@$outputArray, &quot;        return $functionString;\n&quot;);
5042         push(@$outputArray, &quot;    });\n&quot;);
5043         push(@$outputArray, &quot;    return true;\n&quot;);
5044     }
5045     push(@$outputArray, &quot;}\n\n&quot;);
5046 }
5047 
5048 sub GenerateAttributeSetterTrampolineDefinition
5049 {
5050     my ($outputArray, $interface, $className, $attribute, $attributeSetterName, $attributeSetterBodyName, $conditional) = @_;
5051     
5052     AddToImplIncludes(&quot;JSDOMAttribute.h&quot;, $conditional);
5053     
5054     my $callAttributeSetterName = &quot;set&quot;;
5055     $callAttributeSetterName .= &quot;Static&quot; if $attribute-&gt;isStatic;
5056     
5057     my @templateParameters = ();
5058     push(@templateParameters, $attributeSetterBodyName);
5059     push(@templateParameters, &quot;CastedThisErrorBehavior::ReturnEarly&quot;) if $attribute-&gt;extendedAttributes-&gt;{LenientThis};
5060     
5061     push(@$outputArray, &quot;bool ${attributeSetterName}(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);
5062     push(@$outputArray, &quot;{\n&quot;);
5063     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeSetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*state, thisValue, encodedValue, \&quot;&quot; . $attribute-&gt;name . &quot;\&quot;);\n&quot;);
5064     push(@$outputArray, &quot;}\n\n&quot;);
5065 }
5066 
5067 sub GenerateAttributeSetterDefinition
5068 {
5069     my ($outputArray, $interface, $className, $attribute) = @_;
5070     
5071     return if IsReadonly($attribute);
5072     return if IsJSBuiltin($interface, $attribute);
5073     
5074     my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
5075     if ($conditional) {
5076         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5077         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
5078     }
5079 
5080     my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
5081     if ($readWriteConditional) {
5082         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
5083         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
5084     }
5085 
5086     my $attributeSetterName = GetAttributeSetterName($interface, $className, $attribute);
5087     my $attributeSetterBodyName = $attributeSetterName . &quot;Setter&quot;;
5088     
5089     GenerateAttributeSetterBodyDefinition($outputArray, $interface, $className, $attribute, $attributeSetterBodyName, $conditional);
5090     GenerateAttributeSetterTrampolineDefinition($outputArray, $interface, $className, $attribute, $attributeSetterName, $attributeSetterBodyName, $conditional);
5091 
5092     push(@$outputArray, &quot;#endif\n\n&quot;) if $readWriteConditional;
5093     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5094 }
5095 
5096 sub GenerateOperationTrampolineDefinition
5097 {
5098     my ($outputArray, $interface, $className, $operation, $functionName, $functionBodyName) = @_;
5099 
5100     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5101     my $idlOperationType = $hasPromiseReturnType ? &quot;IDLOperationReturningPromise&quot; : &quot;IDLOperation&quot;;
5102     my $exposureScope = $interface-&gt;extendedAttributes-&gt;{Exposed} ? &quot;WindowOrWorker&quot; : &quot;WindowOnly&quot;;
5103 
5104     my $callFunctionName = &quot;call&quot;;
5105     $callFunctionName .= &quot;Static&quot; if $operation-&gt;isStatic;
5106     $callFunctionName .= &quot;ReturningOwnPromise&quot; if $hasPromiseReturnType &amp;&amp; $operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5107 
5108     my @callFunctionTemplateArguments = ();
5109     push(@callFunctionTemplateArguments, $functionBodyName);
5110     push(@callFunctionTemplateArguments, &quot;PromiseExecutionScope::${exposureScope}&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5111     push(@callFunctionTemplateArguments, &quot;CastedThisErrorBehavior::Assert&quot;) if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
5112 
5113     push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${functionName}(ExecState* state)\n&quot;);
5114     push(@$outputArray, &quot;{\n&quot;);
5115     push(@$outputArray, &quot;    return ${idlOperationType}&lt;${className}&gt;::${callFunctionName}&lt;&quot; . join(&quot;, &quot;, @callFunctionTemplateArguments) . &quot;&gt;(*state, \&quot;&quot; . $operation-&gt;name . &quot;\&quot;);\n&quot;);
5116     push(@$outputArray, &quot;}\n\n&quot;);
5117 }
5118 
5119 sub GenerateOperationBodyDefinition
5120 {
5121     my ($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName, $generatingOverloadDispatcher) = @_;
5122 
5123     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5124     my $idlOperationType = $hasPromiseReturnType ? &quot;IDLOperationReturningPromise&quot; : &quot;IDLOperation&quot;;
5125     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5126 
5127     my @signatureArguments = ();
5128     push(@signatureArguments, &quot;JSC::ExecState* state&quot;);
5129     push(@signatureArguments, &quot;typename ${idlOperationType}&lt;${className}&gt;::ClassParameter castedThis&quot;) if !$operation-&gt;isStatic;
5130     push(@signatureArguments, &quot;Ref&lt;DeferredPromise&gt;&amp;&amp; promise&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5131     push(@signatureArguments, &quot;JSC::ThrowScope&amp; throwScope&quot;);
5132 
5133     push(@$outputArray, &quot;static inline JSC::EncodedJSValue ${functionBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
5134     push(@$outputArray, &quot;{\n&quot;);
5135     push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);
5136     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5137 
5138     if (!$generatingOverloadDispatcher) {
5139         GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*state&quot;);
5140 
5141         if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} and !$operation-&gt;extendedAttributes-&gt;{DoNotCheckSecurity}) {
5142             assert(&quot;Security checks are not supported for static operations.&quot;) if $operation-&gt;isStatic;
5143             
5144             AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
5145             if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
5146                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(state, castedThis-&gt;wrapped(), ThrowSecurityError))\n&quot;);
5147                 push(@$outputArray, &quot;        return JSValue::encode(jsUndefined());\n&quot;);
5148             } else {
5149                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(state, castedThis-&gt;wrapped().window(), ThrowSecurityError))\n&quot;);
5150                 push(@$outputArray, &quot;        return JSValue::encode(jsUndefined());\n&quot;);
5151             }
5152         }
5153     }
5154 
5155     my $indent = &quot;    &quot;;
5156 
5157     if ($generatingOverloadDispatcher) {
5158         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
5159         push(@$outputArray, &quot;    UNUSED_PARAM(vm);\n&quot;);
5160 
5161         my @argumentsToForward = ();
5162         push(@argumentsToForward, &quot;state&quot;);
5163         push(@argumentsToForward, &quot;castedThis&quot;) if !$operation-&gt;isStatic;
5164         push(@argumentsToForward, &quot;WTFMove(promise)&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5165         push(@argumentsToForward, &quot;throwScope&quot;);
5166 
5167         GenerateOverloadDispatcher($operation, $interface, $functionName, &quot;Body&quot;, join(&quot;, &quot;, @argumentsToForward));
5168     } elsif (HasCustomMethod($operation)) {
5169         GenerateImplementationCustomFunctionCall($outputArray, $operation, $interface, $className, $functionImplementationName, $indent);
5170     } else {
5171         if (!$operation-&gt;isMapLike &amp;&amp; !$operation-&gt;isStatic) {
5172             push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5173         }
5174 
5175         GenerateArgumentsCountCheck($outputArray, $operation, $interface, $indent);
5176         my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, $indent);
5177 
5178         if ($operation-&gt;extendedAttributes-&gt;{ResultField}) {
5179             my $resultName = $operation-&gt;extendedAttributes-&gt;{ResultField};
5180             push(@$outputArray, &quot;    auto implResult = $functionString;\n&quot;);
5181             GenerateImplementationFunctionCall($outputArray, $operation, $interface, &quot;WTFMove(implResult.$resultName)&quot;, $indent);
5182         } else {
5183             GenerateImplementationFunctionCall($outputArray, $operation, $interface, $functionString, $indent);
5184         }
5185     }
5186 
5187     push(@$outputArray, &quot;}\n\n&quot;);
5188 }
5189 
5190 sub GenerateOperationDefinition
5191 {
5192     my ($outputArray, $interface, $className, $operation) = @_;
5193 
5194     return if IsJSBuiltin($interface, $operation);
5195     return if $operation-&gt;isIterable;
5196     return if $operation-&gt;isSerializer;
5197 
5198     my $isCustom = HasCustomMethod($operation);
5199     my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5200 
5201     assert(&quot;[Custom] is not supported for overloaded operations.&quot;) if $isCustom &amp;&amp; $isOverloaded;
5202 
5203     my $inAppleCopyright = 0;
5204 
5205     if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
5206         if (!$inAppleCopyright) {
5207             push(@$outputArray, $beginAppleCopyrightForSourceFiles);
5208             $inAppleCopyright = 1;
5209         }
5210     } elsif ($inAppleCopyright) {
5211         push(@$outputArray, $endAppleCopyright);
5212         $inAppleCopyright = 0;
5213     }
5214 
5215     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5216     if ($conditional) {
5217         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5218         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
5219     }
5220 
5221     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5222 
5223     AddToImplIncludesForIDLType($operation-&gt;type, $conditional) unless $isCustom or $hasPromiseReturnType;
5224     AddToImplIncludes(&quot;JSDOMOperation.h&quot;, $conditional) if !$hasPromiseReturnType;
5225     AddToImplIncludes(&quot;JSDOMOperationReturningPromise.h&quot;, $conditional) if $hasPromiseReturnType;
5226 
5227     my $functionName = GetFunctionName($interface, $className, $operation);
5228     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name);
5229     my $functionBodyName = ($isOverloaded ? $functionName . $operation-&gt;{overloadIndex} : $functionName) . &quot;Body&quot;;
5230 
5231     GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName);
5232 
5233     # Overloaded operations don&#39;t generate a trampoline for each overload, and instead have a single dispatch trampoline
5234     # that gets generated after the last overload body has been generated.
5235     unless ($isOverloaded) {
5236         GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $functionBodyName);
5237     }
5238 
5239     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5240 
5241     # Generate a function dispatching call to the rest of the overloads.
5242     if ($isOverloaded &amp;&amp; $operation-&gt;{overloadIndex} == @{$operation-&gt;{overloads}}) {
5243         my $overloadsConditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
5244         my $overloadsConditionalString = $overloadsConditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($overloadsConditionalAttribute) : undef;
5245         push(@$outputArray, &quot;#if ${overloadsConditionalString}\n\n&quot;) if $overloadsConditionalString;
5246 
5247         my $overloadDispatcherFunctionBodyName = $functionName . &quot;OverloadDispatcher&quot;;
5248         GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $overloadDispatcherFunctionBodyName, 1);
5249         GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $overloadDispatcherFunctionBodyName);
5250     
5251         push(@$outputArray, &quot;#endif\n\n&quot;) if $overloadsConditionalString;
5252     }
5253 
5254 
5255     if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
5256         if ($conditional) {
5257             my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5258             push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
5259         }
5260 
5261         AddToImplIncludes(&quot;&lt;JavaScriptCore/FrameTracers.h&gt;&quot;, $conditional);
5262         my $unsafeFunctionName = &quot;unsafe&quot; . $codeGenerator-&gt;WK_ucfirst($functionName);
5263         push(@$outputArray, &quot;JSC::EncodedJSValue JIT_OPERATION ${unsafeFunctionName}(JSC::ExecState* state, $className* castedThis&quot;);
5264         foreach my $argument (@{$operation-&gt;arguments}) {
5265             my $type = $argument-&gt;type;
5266             my $argumentType = GetUnsafeArgumentType($interface, $type);
5267             my $name = $argument-&gt;name;
5268             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5269             push(@$outputArray, &quot;, ${argumentType} ${encodedName}&quot;);
5270         }
5271         push(@$outputArray, &quot;)\n&quot;);
5272         push(@$outputArray, &quot;{\n&quot;);
5273         push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);
5274         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
5275         push(@$outputArray, &quot;    JSC::NativeCallFrameTracer tracer(&amp;vm, state);\n&quot;);
5276         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5277         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5278         push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5279         
5280         my $implFunctionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
5281         
5282         my @arguments = ();
5283         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*state&quot;, &quot;*castedThis&quot;);
5284         
5285         foreach my $argument (@{$operation-&gt;arguments}) {
5286             my $value = &quot;&quot;;
5287             my $type = $argument-&gt;type;
5288             my $name = $argument-&gt;name;
5289             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5290             my $shouldPassByReference = ShouldPassArgumentByReference($argument);
5291 
5292             my ($nativeValue, $mayThrowException) = UnsafeToNative($interface, $argument, $encodedName, $operation-&gt;extendedAttributes-&gt;{Conditional});
5293             push(@$outputArray, &quot;    auto $name = ${nativeValue};\n&quot;);
5294             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;) if $mayThrowException;
5295             $value = &quot;WTFMove($name)&quot;;
5296 
5297             if ($shouldPassByReference) {
5298                 $value = &quot;*$name&quot;;
5299             }
5300             push(@arguments, $value);
5301         }
5302         my $functionString = &quot;$implFunctionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5303         $functionString = &quot;propagateException(*state, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);
5304         push(@$outputArray, &quot;    return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, &quot;*castedThis-&gt;globalObject()&quot;) . &quot;);\n&quot;);
5305         push(@$outputArray, &quot;}\n\n&quot;);
5306 
5307         push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5308     }
5309 
5310     push(@$outputArray, $endAppleCopyright) if $inAppleCopyright;
5311 }
5312 
5313 sub GenerateSerializerDefinition
5314 {
5315     my ($interface, $className) = @_;
5316 
5317     my $interfaceName = $interface-&gt;type-&gt;name;
5318 
5319     my $parentSerializerInterface = 0;
5320     if ($interface-&gt;serializable-&gt;hasInherit) {
5321         $codeGenerator-&gt;ForAllParents($interface, sub {
5322             my $parentInterface = shift;
5323             if ($parentInterface-&gt;serializable &amp;&amp; !$parentSerializerInterface) {
5324                 $parentSerializerInterface = $parentInterface;
5325             }
5326         }, 0);
5327         die &quot;Failed to find parent interface with \&quot;serializer\&quot; for \&quot;inherit\&quot; serializer in $interfaceName\n&quot; if !$parentSerializerInterface;
5328     }
5329 
5330     my @serializedAttributes = ();
5331 
5332     foreach my $attributeName (@{$interface-&gt;serializable-&gt;attributes}) {
5333         my $foundAttribute = 0;
5334         foreach my $attribute (@{$interface-&gt;attributes}) {
5335             if ($attributeName eq $attribute-&gt;name) {
5336                 $foundAttribute = 1;
5337                 if ($codeGenerator-&gt;IsSerializableAttribute($interface, $attribute)) {
5338                     push(@serializedAttributes, $attribute);                
5339                     last;
5340                 }                    
5341                 die &quot;Explicit \&quot;serializer\&quot; attribute \&quot;$attributeName\&quot; is not serializable\n&quot; if !$interface-&gt;serializable-&gt;hasAttribute;
5342                 last;
5343             }
5344         }
5345         die &quot;Failed to find \&quot;serializer\&quot; attribute \&quot;$attributeName\&quot; in $interfaceName\n&quot; if !$foundAttribute;
5346     }
5347 
5348     my $serializerFunctionName = &quot;toJSON&quot;;
5349     my $serializerNativeFunctionName = $codeGenerator-&gt;WK_lcfirst($className) . &quot;PrototypeFunction&quot; . $codeGenerator-&gt;WK_ucfirst($serializerFunctionName);
5350 
5351     AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
5352 
5353     push(@implContent, &quot;JSC::JSObject* JS${interfaceName}::serialize(ExecState&amp; state, ${className}&amp; thisObject, JSDOMGlobalObject&amp; globalObject, ThrowScope&amp; throwScope)\n&quot;);
5354     push(@implContent, &quot;{\n&quot;);
5355     push(@implContent, &quot;    auto&amp; vm = state.vm();\n&quot;);
5356 
5357     if ($interface-&gt;serializable-&gt;hasInherit) {
5358         my $parentSerializerInterfaceName = $parentSerializerInterface-&gt;type-&gt;name;
5359         push(@implContent, &quot;    auto* result = JS${parentSerializerInterfaceName}::serialize(state, thisObject, globalObject, throwScope);\n&quot;);
5360     } else {
5361         push(@implContent, &quot;    auto* result = constructEmptyObject(&amp;state, globalObject.objectPrototype());\n&quot;);
5362     }
5363     push(@implContent, &quot;\n&quot;);
5364 
5365     foreach my $attribute (@serializedAttributes) {
5366         # FIXME: Attributes that throw exceptions are not supported with serializers yet.
5367 
5368         my $name = $attribute-&gt;name;
5369         my $getFunctionName = GetAttributeGetterName($interface, $className, $attribute);
5370         push(@implContent, &quot;    auto ${name}Value = ${getFunctionName}Getter(state, thisObject, throwScope);\n&quot;);
5371         push(@implContent, &quot;    throwScope.assertNoException();\n&quot;);
5372 
5373         if ($codeGenerator-&gt;IsInterfaceType($attribute-&gt;type)) {
5374             my $attributeInterfaceName = $attribute-&gt;type-&gt;name;
5375             if ($attribute-&gt;type-&gt;isNullable) {
5376                 push(@implContent, &quot;    if (!${name}Value.isNull()) {\n&quot;);
5377                 push(@implContent, &quot;        auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(state, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);
5378                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(&amp;vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);
5379                 push(@implContent, &quot;    } else\n&quot;);
5380                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(&amp;vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);
5381             } else {
5382                 push(@implContent, &quot;    auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(state, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);
5383                 push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(&amp;vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);
5384             }
5385         } else {
5386             push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(&amp;vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);
5387         }
5388 
5389         push(@implContent, &quot;\n&quot;);
5390     }
5391 
5392     push(@implContent, &quot;    return result;\n&quot;);
5393     push(@implContent, &quot;}\n&quot;);
5394     push(@implContent, &quot;\n&quot;);
5395 
5396     push(@implContent, &quot;static inline EncodedJSValue ${serializerNativeFunctionName}Body(ExecState* state, ${className}* thisObject, JSC::ThrowScope&amp; throwScope)\n&quot;);
5397     push(@implContent, &quot;{\n&quot;);
5398     push(@implContent, &quot;    return JSValue::encode(JS${interfaceName}::serialize(*state, *thisObject, *thisObject-&gt;globalObject(), throwScope));\n&quot;);
5399     push(@implContent, &quot;}\n&quot;);
5400     push(@implContent, &quot;\n&quot;);
5401     push(@implContent, &quot;EncodedJSValue JSC_HOST_CALL ${serializerNativeFunctionName}(ExecState* state)\n&quot;);
5402     push(@implContent, &quot;{\n&quot;);
5403     push(@implContent, &quot;    return IDLOperation&lt;JS${interfaceName}&gt;::call&lt;${serializerNativeFunctionName}Body&gt;(*state, \&quot;${serializerFunctionName}\&quot;);\n&quot;);
5404     push(@implContent, &quot;}\n&quot;);
5405     push(@implContent, &quot;\n&quot;);
5406 }
5407 
5408 sub GenerateGetCallData
5409 {
5410     my ($outputArray, $interface, $className) = @_;
5411 
5412     return if $interface-&gt;extendedAttributes-&gt;{CustomGetCallData};
5413 
5414     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
5415         GeneratePluginCall($outputArray, $interface, $className);
5416     } else {
5417         GenerateLegacyCallerDefinitions($outputArray, $interface, $className);
5418     }
5419 }
5420 
5421 sub GeneratePluginCall
5422 {
5423     my ($outputArray, $interface, $className) = @_;
5424 
5425     AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
5426 
5427     push(@$outputArray, &quot;CallType ${className}::getCallData(JSCell* cell, CallData&amp; callData)\n&quot;);
5428     push(@$outputArray, &quot;{\n&quot;);
5429     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
5430     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
5431 
5432     push(@$outputArray, &quot;    return pluginElementCustomGetCallData(thisObject, callData);\n&quot;);
5433     push(@$outputArray, &quot;}\n&quot;);
5434     push(@$outputArray, &quot;\n&quot;);
5435 }
5436 
5437 sub GenerateLegacyCallerDefinitions
5438 {
5439     my ($outputArray, $interface, $className) = @_;
5440 
5441     my @legacyCallers = @{$interface-&gt;{LegacyCallers}};
5442     if (@legacyCallers &gt; 1) {
5443         foreach my $legacyCaller (@legacyCallers) {
5444             GenerateLegacyCallerDefinition($outputArray, $interface, $className, $legacyCaller);
5445         }
5446 
5447         my $overloadFunctionPrefix = &quot;call${className}&quot;;
5448 
5449         push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${overloadFunctionPrefix}(ExecState* state)\n&quot;);
5450         push(@$outputArray, &quot;{\n&quot;);
5451         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
5452         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5453         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5454 
5455         GenerateOverloadDispatcher($legacyCallers[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;state&quot;);
5456 
5457         push(@$outputArray, &quot;}\n\n&quot;);
5458     } else {
5459         GenerateLegacyCallerDefinition($outputArray, $interface, $className, $legacyCallers[0]);
5460     }
5461 
5462     push(@$outputArray, &quot;CallType ${className}::getCallData(JSCell*, CallData&amp; callData)\n&quot;);
5463     push(@$outputArray, &quot;{\n&quot;);
5464     push(@$outputArray, &quot;    callData.native.function = call${className};\n&quot;);
5465     push(@$outputArray, &quot;    return CallType::Host;\n&quot;);
5466     push(@$outputArray, &quot;}\n&quot;);
5467     push(@$outputArray, &quot;\n&quot;);
5468 }
5469 
5470 sub GenerateLegacyCallerDefinition
5471 {
5472     my ($outputArray, $interface, $className, $operation) = @_;
5473 
5474     my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5475     if ($isOverloaded) {
5476         push(@$outputArray, &quot;static inline EncodedJSValue call${className}$operation-&gt;{overloadIndex}(ExecState* state)\n&quot;);
5477     } else {
5478         push(@$outputArray, &quot;static EncodedJSValue JSC_HOST_CALL call${className}(ExecState* state)\n&quot;);
5479     }
5480 
5481     push(@$outputArray, &quot;{\n&quot;);
5482     push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
5483     push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5484     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5485 
5486     my $indent = &quot;    &quot;;
5487     GenerateArgumentsCountCheck($outputArray, $operation, $interface, $indent);
5488 
5489     push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${className}*&gt;(state-&gt;jsCallee());\n&quot;);
5490     push(@$outputArray, &quot;    ASSERT(castedThis);\n&quot;);
5491     push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5492 
5493     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name) || &quot;legacyCallerOperationFromBindings&quot;;
5494     my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, $indent);
5495 
5496     GenerateImplementationFunctionCall($outputArray, $operation, $interface, $functionString, $indent);
5497 
5498     push(@$outputArray, &quot;}\n\n&quot;);
5499 }
5500 
5501 sub GenerateCallWithUsingReferences
5502 {
5503     my ($callWith, $outputArray, $returnValue, $thisReference, $indent) = @_;
5504 
5505     my $statePointer = &quot;&amp;state&quot;;
5506     my $stateReference = &quot;state&quot;;
5507     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())&quot;;
5508 
5509     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $statePointer, $stateReference, $globalObject, $globalObject, $thisReference, $indent);
5510 }
5511 
5512 # FIXME: We should remove GenerateCallWithUsingPointers and combine GenerateCallWithUsingReferences and GenerateCallWith
5513 sub GenerateCallWithUsingPointers
5514 {
5515     my ($callWith, $outputArray, $returnValue, $thisReference, $indent) = @_;
5516 
5517     my $statePointer = &quot;state&quot;;
5518     my $stateReference = &quot;*state&quot;;
5519     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot;;
5520 
5521     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $statePointer, $stateReference, $globalObject, $globalObject, $thisReference, $indent);
5522 }
5523 
5524 sub GenerateConstructorCallWithUsingPointers
5525 {
5526     my ($callWith, $outputArray, $visibleInterfaceName, $thisReference, $indent) = @_;
5527 
5528     my $statePointer = &quot;state&quot;;
5529     my $stateReference = &quot;*state&quot;;
5530     my $globalObject = &quot;castedThis-&gt;globalObject()&quot;;
5531     my $contextMissing = &quot;throwConstructorScriptExecutionContextUnavailableError(*state, throwScope, \&quot;${visibleInterfaceName}\&quot;)&quot;;
5532     my $scriptExecutionContextAccessor = &quot;castedThis&quot;;
5533 
5534     return GenerateCallWith($callWith, $outputArray, &quot;&quot;, $contextMissing, $statePointer, $stateReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent);
5535 }
5536 
5537 sub GenerateCallWith
5538 {
5539     my ($callWith, $outputArray, $returnValue, $contextMissing, $statePointer, $stateReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent) = @_;
5540 
5541     return () unless $callWith;
5542 
5543     $indent ||= &quot;    &quot;;
5544 
5545     my @callWithArgs;
5546     push(@callWithArgs, $stateReference) if $codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ExecState&quot;);
5547     push(@callWithArgs, &quot;*${globalObject}&quot;) if $codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;GlobalObject&quot;);
5548     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ScriptExecutionContext&quot;)) {
5549         push(@$outputArray, $indent . &quot;auto* context = ${scriptExecutionContextAccessor}-&gt;scriptExecutionContext();\n&quot;);
5550         push(@$outputArray, $indent . &quot;if (UNLIKELY(!context))\n&quot;);
5551         push(@$outputArray, $indent . &quot;    return&quot; . ($contextMissing ? &quot; &quot; . $contextMissing : &quot;&quot;) . &quot;;\n&quot;);
5552         push(@callWithArgs, &quot;*context&quot;);
5553     }
5554     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;Document&quot;)) {
5555         AddToImplIncludes(&quot;Document.h&quot;);
5556         push(@$outputArray, $indent . &quot;auto* context = ${scriptExecutionContextAccessor}-&gt;scriptExecutionContext();\n&quot;);
5557         push(@$outputArray, $indent . &quot;if (UNLIKELY(!context))\n&quot;);
5558         push(@$outputArray, $indent . &quot;    return&quot; . ($contextMissing ? &quot; &quot; . $contextMissing : &quot;&quot;) . &quot;;\n&quot;);
5559         push(@$outputArray, $indent . &quot;ASSERT(context-&gt;isDocument());\n&quot;);
5560         push(@$outputArray, $indent . &quot;auto&amp; document = downcast&lt;Document&gt;(*context);\n&quot;);
5561         push(@callWithArgs, &quot;document&quot;);
5562     }
5563     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;IncumbentDocument&quot;)) {
5564         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5565         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5566         push(@$outputArray, $indent . &quot;auto* incumbentDocument = incumbentDOMWindow($stateReference).document();\n&quot;);
5567         push(@$outputArray, $indent . &quot;if (!incumbentDocument)\n&quot;);
5568         push(@$outputArray, $indent . &quot;    return&quot; . ($returnValue ? &quot; &quot; . $returnValue : &quot;&quot;) . &quot;;\n&quot;);
5569         push(@callWithArgs, &quot;*incumbentDocument&quot;);
5570     }
5571     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ResponsibleDocument&quot;)) {
5572         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5573         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5574         push(@callWithArgs, &quot;responsibleDocument($stateReference)&quot;);
5575     }
5576     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ActiveWindow&quot;)) {
5577         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5578         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5579         push(@callWithArgs, &quot;activeDOMWindow($stateReference)&quot;);
5580     }
5581     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;FirstWindow&quot;)) {
5582         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5583         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5584         push(@callWithArgs, &quot;firstDOMWindow($stateReference)&quot;);
5585     }
5586     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;IncumbentWindow&quot;)) {
5587         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5588         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5589         push(@callWithArgs, &quot;incumbentDOMWindow($stateReference)&quot;);
5590     }
5591     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;RuntimeFlags&quot;)) {
5592         push(@callWithArgs, &quot;${globalObject}-&gt;runtimeFlags()&quot;);
5593     }
5594     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;World&quot;)) {
5595         push(@callWithArgs, &quot;worldForDOMObject(${thisReference})&quot;);
5596     }
5597 
5598     return @callWithArgs;
5599 }
5600 
5601 sub GenerateArgumentsCountCheck
5602 {
5603     my ($outputArray, $operation, $interface, $indent) = @_;
5604 
5605     # Overloaded operations don&#39;t need to check the argument count since the 
5606     # dispatch function does for them.
5607     return if $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5608 
5609     my $numMandatoryArguments = @{$operation-&gt;arguments};
5610     foreach my $argument (reverse(@{$operation-&gt;arguments})) {
5611         if ($argument-&gt;isOptional or $argument-&gt;isVariadic) {
5612             $numMandatoryArguments--;
5613         } else {
5614             last;
5615         }
5616     }
5617     if ($numMandatoryArguments &gt;= 1) {
5618         push(@$outputArray, $indent . &quot;if (UNLIKELY(state-&gt;argumentCount() &lt; $numMandatoryArguments))\n&quot;);
5619         push(@$outputArray, $indent . &quot;    return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));\n&quot;);
5620     }
5621 }
5622 
5623 my %automaticallyGeneratedDefaultValues = (
5624     &quot;any&quot; =&gt; &quot;undefined&quot;,
5625 
5626     # toString() will convert undefined to the string &quot;undefined&quot;;
5627     # (note that this optimizes a behavior that is almost never useful)
5628     &quot;DOMString&quot; =&gt; &quot;\&quot;undefined\&quot;&quot;,
5629     &quot;USVString&quot; =&gt; &quot;\&quot;undefined\&quot;&quot;,
5630 
5631     # JSValue::toBoolean() will convert undefined to false.
5632     &quot;boolean&quot; =&gt; &quot;false&quot;,
5633 
5634     # JSValue::toInt*() / JSValue::toUint*() will convert undefined to 0.
5635     &quot;byte&quot; =&gt; &quot;0&quot;,
5636     &quot;long long&quot; =&gt; &quot;0&quot;,
5637     &quot;long&quot; =&gt; &quot;0&quot;,
5638     &quot;octet&quot; =&gt; &quot;0&quot;,
5639     &quot;short&quot; =&gt; &quot;0&quot;,
5640     &quot;unsigned long long&quot; =&gt; &quot;0&quot;,
5641     &quot;unsigned long&quot; =&gt; &quot;0&quot;,
5642     &quot;unsigned short&quot; =&gt; &quot;0&quot;,
5643 
5644     # toNumber() / toFloat() convert undefined to NaN.
5645     &quot;double&quot; =&gt; &quot;NaN&quot;,
5646     &quot;float&quot; =&gt; &quot;NaN&quot;,
5647     &quot;unrestricted double&quot; =&gt; &quot;NaN&quot;,
5648     &quot;unrestricted float&quot; =&gt; &quot;NaN&quot;,
5649 );
5650 
5651 sub WillConvertUndefinedToDefaultParameterValue
5652 {
5653     my ($parameterType, $defaultValue) = @_;
5654 
5655     my $automaticallyGeneratedDefaultValue = $automaticallyGeneratedDefaultValues{$parameterType-&gt;name};
5656     return 1 if defined $automaticallyGeneratedDefaultValue &amp;&amp; $automaticallyGeneratedDefaultValue eq $defaultValue;
5657 
5658     return 1 if $defaultValue eq &quot;null&quot; &amp;&amp; $codeGenerator-&gt;IsWrapperType($parameterType);
5659     return 1 if $defaultValue eq &quot;[]&quot; &amp;&amp; $codeGenerator-&gt;IsDictionaryType($parameterType);
5660 
5661     return 0;
5662 }
5663 
5664 sub NeedsExplicitPropagateExceptionCall
5665 {
5666     my ($operation) = @_;
5667 
5668     return 0 unless $operation-&gt;extendedAttributes-&gt;{MayThrowException};
5669 
5670     return $operation-&gt;type &amp;&amp; ($operation-&gt;type-&gt;name eq &quot;void&quot; || $codeGenerator-&gt;IsPromiseType($operation-&gt;type) || OperationHasForcedReturnValue($operation));
5671 }
5672 
5673 sub GenerateParametersCheck
5674 {
5675     my ($outputArray, $operation, $interface, $functionImplementationName, $indent) = @_;
5676 
5677     my $interfaceName = $interface-&gt;type-&gt;name;
5678     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
5679     my $numArguments = @{$operation-&gt;arguments};
5680     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5681     my $isConstructor = $operation-&gt;extendedAttributes-&gt;{Constructor} || $operation-&gt;extendedAttributes-&gt;{NamedConstructor};
5682 
5683     my $functionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
5684     
5685     my @arguments = ();
5686     AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*state&quot;, &quot;*castedThis&quot;);
5687     
5688     my $quotedFunctionName;
5689     if (!$isConstructor) {
5690         my $name = $operation-&gt;name;
5691         $quotedFunctionName = &quot;\&quot;$name\&quot;&quot;;
5692         push(@arguments, GenerateCallWithUsingPointers($operation-&gt;extendedAttributes-&gt;{CallWith}, \@$outputArray, &quot;JSValue::encode(jsUndefined())&quot;, &quot;*castedThis&quot;));
5693     } else {
5694         $quotedFunctionName = &quot;nullptr&quot;;
5695         push(@arguments, GenerateConstructorCallWithUsingPointers($operation-&gt;extendedAttributes-&gt;{ConstructorCallWith}, \@$outputArray, $visibleInterfaceName, &quot;*castedThis&quot;));
5696     }
5697 
5698     my $argumentIndex = 0;
5699     foreach my $argument (@{$operation-&gt;arguments}) {
5700         my $type = $argument-&gt;type;
5701 
5702         assert &quot;Optional arguments of non-nullable wrapper types are not supported (&quot; . $operation-&gt;name . &quot;)&quot; if $argument-&gt;isOptional &amp;&amp; !$type-&gt;isNullable &amp;&amp; $codeGenerator-&gt;IsWrapperType($type);
5703 
5704         if ($argument-&gt;isOptional &amp;&amp; !defined($argument-&gt;default)) {
5705             # As per Web IDL, optional dictionary arguments are always considered to have a default value of an empty dictionary, unless otherwise specified.
5706             $argument-&gt;default(&quot;[]&quot;) if $codeGenerator-&gt;IsDictionaryType($type);
5707 
5708             # Treat undefined the same as an empty sequence Or frozen array.
5709             $argument-&gt;default(&quot;[]&quot;) if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
5710 
5711             # We use undefined as default value for optional arguments of type &#39;any&#39; unless specified otherwise.
5712             $argument-&gt;default(&quot;undefined&quot;) if $type-&gt;name eq &quot;any&quot;;
5713 
5714             # We use the null string as default value for arguments of type DOMString unless specified otherwise.
5715             $argument-&gt;default(&quot;null&quot;) if $codeGenerator-&gt;IsStringType($type);
5716 
5717             # As per Web IDL, passing undefined for a nullable argument is treated as null. Therefore, use null as
5718             # default value for nullable arguments unless otherwise specified.
5719             $argument-&gt;default(&quot;null&quot;) if $type-&gt;isNullable;
5720 
5721             # For callback arguments, the generated bindings treat undefined as null, so use null as implicit default value.
5722             $argument-&gt;default(&quot;null&quot;) if $codeGenerator-&gt;IsCallbackInterface($type) || $codeGenerator-&gt;IsCallbackFunction($type);
5723         }
5724 
5725         my $name = $argument-&gt;name;
5726         my $value = $name;
5727 
5728         if ($argument-&gt;isVariadic) {
5729             AddToImplIncludes(&quot;JSDOMConvertVariadic.h&quot;, $conditional);
5730             AddToImplIncludesForIDLType($type, $conditional);
5731         
5732             my $IDLType = GetIDLType($interface, $type);
5733 
5734             push(@$outputArray, $indent . &quot;auto ${name} = convertVariadicArguments&lt;${IDLType}&gt;(*state, ${argumentIndex});\n&quot;);
5735             push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;);
5736 
5737             $value = &quot;WTFMove(${name})&quot;;
5738         } else {
5739             my $argumentLookupForConversion;
5740             my $optionalCheck;
5741             my $nativeValueCastFunction;
5742 
5743             if ($argument-&gt;isOptional) {
5744                 assert(&quot;[ReturnValue] is not supported for optional arguments&quot;) if $argument-&gt;extendedAttributes-&gt;{ReturnValue};
5745 
5746                 if (defined($argument-&gt;default)) {
5747                     if (WillConvertUndefinedToDefaultParameterValue($type, $argument-&gt;default)) {
5748                         $argumentLookupForConversion = &quot;state-&gt;argument($argumentIndex)&quot;;
5749                     } else {
5750                         my $defaultValue = GenerateDefaultValue($interface, $argument, $argument-&gt;type, $argument-&gt;default);
5751                         $optionalCheck = &quot;state-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;
5752                         $argumentLookupForConversion = &quot;state-&gt;uncheckedArgument($argumentIndex)&quot;
5753                     }
5754                 } else {
5755                     my $argumentIDLType = GetIDLType($interface, $argument-&gt;type);
5756 
5757                     my $defaultValue;
5758                     if ($codeGenerator-&gt;IsPromiseType($argument-&gt;type)) {
5759                         $defaultValue = &quot;nullptr&quot;;
5760                     } else {
5761                         $defaultValue = &quot;Optional&lt;Converter&lt;$argumentIDLType&gt;::ReturnType&gt;()&quot;;
5762                         $nativeValueCastFunction = &quot;Optional&lt;Converter&lt;$argumentIDLType&gt;::ReturnType&gt;&quot;;
5763                     }
5764 
5765                     $optionalCheck = &quot;state-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;
5766                     $argumentLookupForConversion = &quot;state-&gt;uncheckedArgument($argumentIndex)&quot;;
5767                 }
5768             } else {
5769                 if ($argument-&gt;extendedAttributes-&gt;{ReturnValue}) {
5770                     push(@$outputArray, $indent . &quot;auto returnValue = state-&gt;uncheckedArgument($argumentIndex);\n&quot;);
5771                     $argumentLookupForConversion = &quot;returnValue&quot;;
5772                 } else {
5773                     $argumentLookupForConversion = &quot;state-&gt;uncheckedArgument($argumentIndex)&quot;;
5774                 }
5775             }
5776 
5777             my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*castedThis-&gt;globalObject()&quot;;
5778             my $argumentExceptionThrower = GetArgumentExceptionThrower($interface, $argument, $argumentIndex, $quotedFunctionName);
5779 
5780             my $nativeValue = JSValueToNative($interface, $argument, $argumentLookupForConversion, $conditional, &quot;state&quot;, &quot;*state&quot;, &quot;*castedThis&quot;, $globalObjectReference, $argumentExceptionThrower);
5781 
5782             $nativeValue = &quot;${nativeValueCastFunction}(&quot; . $nativeValue . &quot;)&quot; if defined $nativeValueCastFunction;
5783             $nativeValue = $optionalCheck . $nativeValue if defined $optionalCheck;
5784 
5785             push(@$outputArray, $indent . &quot;auto $name = ${nativeValue};\n&quot;);
5786             push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;);
5787 
5788             $value = PassArgumentExpression($name, $argument);
5789         }
5790 
5791         push(@arguments, $value);
5792         $argumentIndex++;
5793     }
5794 
5795     push(@arguments, &quot;WTFMove(promise)&quot;) if $operation-&gt;type &amp;&amp; $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy};
5796 
5797     my $functionString = &quot;$functionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5798     $functionString = &quot;propagateException(*state, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);
5799 
5800     return $functionString;
5801 }
5802 
5803 sub GenerateDictionaryHeader
5804 {
5805     my ($object, $dictionary, $className, $enumerations, $otherDictionaries) = @_;
5806 
5807     # - Add default header template and header protection.
5808     push(@headerContentHeader, GenerateHeaderContentHeader($dictionary));
5809 
5810     $headerIncludes{&quot;${className}.h&quot;} = 1;
5811 
5812     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
5813     push(@headerContent, GenerateDictionaryHeaderContent($dictionary, $className));
5814     push(@headerContent, GenerateEnumerationsHeaderContent($dictionary, $enumerations));
5815     push(@headerContent, GenerateDictionariesHeaderContent($dictionary, $otherDictionaries)) if $otherDictionaries;
5816     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
5817 
5818     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
5819     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
5820     
5821     # - Generate dependencies.
5822     if ($writeDependencies) {
5823         my @ancestors;
5824         my $parentType = $dictionary-&gt;parentType;
5825         while (defined($parentType)) {
5826             push(@ancestors, $parentType-&gt;name) if $codeGenerator-&gt;IsExternalDictionaryType($parentType);
5827             my $parentDictionary = $codeGenerator-&gt;GetDictionaryByType($parentType);
5828             assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless $parentDictionary;
5829             $parentType = $parentDictionary-&gt;parentType;
5830         }
5831         push(@depsContent, &quot;$className.h : &quot;, join(&quot; &quot;, map { &quot;$_.idl&quot; } @ancestors), &quot;\n&quot;);
5832         push(@depsContent, map { &quot;$_.idl :\n&quot; } @ancestors);
5833     }
5834 }
5835 
5836 sub GenerateDictionaryImplementation
5837 {
5838     my ($object, $dictionary, $className, $enumerations, $otherDictionaries) = @_;
5839 
5840     # - Add default header template
5841     push(@implContentHeader, GenerateImplementationContentHeader($dictionary));
5842 
5843     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
5844     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
5845     push(@implContent, GenerateDictionaryImplementationContent($dictionary, $className));
5846     push(@implContent, GenerateEnumerationsImplementationContent($dictionary, $enumerations));
5847     push(@implContent, GenerateDictionariesImplementationContent($dictionary, $otherDictionaries)) if $otherDictionaries;
5848     push(@implContent, &quot;} // namespace WebCore\n&quot;);
5849 
5850     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
5851     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
5852 }
5853 
5854 sub GenerateCallbackFunctionHeader
5855 {
5856     my ($object, $callbackFunction, $enumerations, $dictionaries) = @_;
5857 
5858     push(@headerContentHeader, GenerateHeaderContentHeader($callbackFunction));
5859 
5860     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
5861 
5862     my @operations = ();
5863     push(@operations, $callbackFunction-&gt;operation);
5864     my @constants = ();
5865 
5866     $object-&gt;GenerateCallbackHeaderContent($callbackFunction, \@operations, \@constants, \@headerContent, \%headerIncludes);
5867 
5868     push(@headerContent, GenerateEnumerationsHeaderContent($callbackFunction, $enumerations));
5869     push(@headerContent, GenerateDictionariesHeaderContent($callbackFunction, $dictionaries));
5870 
5871     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
5872 
5873     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackFunction);
5874     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
5875 }
5876 
5877 sub GenerateCallbackFunctionImplementation
5878 {
5879     my ($object, $callbackFunction, $enumerations, $dictionaries) = @_;
5880 
5881     push(@implContentHeader, GenerateImplementationContentHeader($callbackFunction));
5882 
5883     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
5884     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
5885 
5886     push(@implContent, GenerateEnumerationsImplementationContent($callbackFunction, $enumerations));
5887     push(@implContent, GenerateDictionariesImplementationContent($callbackFunction, $dictionaries));
5888 
5889     my @operations = ();
5890     push(@operations, $callbackFunction-&gt;operation);
5891     my @constants = ();
5892 
5893     $object-&gt;GenerateCallbackImplementationContent($callbackFunction, \@operations, \@constants, \@implContent, \%implIncludes);
5894 
5895     push(@implContent, &quot;} // namespace WebCore\n&quot;);
5896 
5897     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackFunction);
5898     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
5899 }
5900 
5901 sub GenerateCallbackInterfaceHeader
5902 {
5903     my ($object, $callbackInterface, $enumerations, $dictionaries) = @_;
5904 
5905     push(@headerContentHeader, GenerateHeaderContentHeader($callbackInterface));
5906 
5907     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
5908     
5909     $object-&gt;GenerateCallbackHeaderContent($callbackInterface, $callbackInterface-&gt;operations, $callbackInterface-&gt;constants, \@headerContent, \%headerIncludes);
5910 
5911     push(@headerContent, GenerateEnumerationsHeaderContent($callbackInterface, $enumerations));
5912     push(@headerContent, GenerateDictionariesHeaderContent($callbackInterface, $dictionaries));
5913 
5914     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
5915 
5916     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackInterface);
5917     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
5918 }
5919 
5920 sub GenerateCallbackInterfaceImplementation
5921 {
5922     my ($object, $callbackInterface, $enumerations, $dictionaries) = @_;
5923 
5924     push(@implContentHeader, GenerateImplementationContentHeader($callbackInterface));
5925 
5926     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
5927     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
5928 
5929     push(@implContent, GenerateEnumerationsImplementationContent($callbackInterface, $enumerations));
5930     push(@implContent, GenerateDictionariesImplementationContent($callbackInterface, $dictionaries));
5931 
5932     $object-&gt;GenerateCallbackImplementationContent($callbackInterface, $callbackInterface-&gt;operations, $callbackInterface-&gt;constants, \@implContent, \%implIncludes);
5933 
5934     push(@implContent, &quot;} // namespace WebCore\n&quot;);
5935 
5936     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackInterface);
5937     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
5938 }
5939 
5940 sub GenerateCallbackHeaderContent
5941 {
5942     my ($object, $interfaceOrCallback, $operations, $constants, $contentRef, $includesRef) = @_;
5943 
5944     my $name = $interfaceOrCallback-&gt;type-&gt;name;
5945     my $callbackDataType = $interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback} ? &quot;JSCallbackDataWeak&quot; : &quot;JSCallbackDataStrong&quot;;
5946     my $className = &quot;JS${name}&quot;;
5947 
5948     $includesRef-&gt;{&quot;IDLTypes.h&quot;} = 1;
5949     $includesRef-&gt;{&quot;JSCallbackData.h&quot;} = 1;
5950     $includesRef-&gt;{&quot;&lt;wtf/Forward.h&gt;&quot;} = 1;
5951     $includesRef-&gt;{&quot;${name}.h&quot;} = 1;
5952 
5953     my $exportMacro = GetExportMacroForJSClass($interfaceOrCallback);
5954 
5955     push(@$contentRef, &quot;class $exportMacro$className final : public ${name} {\n&quot;);
5956     push(@$contentRef, &quot;public:\n&quot;);
5957 
5958     # The static create() method.
5959     push(@$contentRef, &quot;    static Ref&lt;$className&gt; create(JSC::JSObject* callback, JSDOMGlobalObject* globalObject)\n&quot;);
5960     push(@$contentRef, &quot;    {\n&quot;);
5961     push(@$contentRef, &quot;        return adoptRef(*new ${className}(callback, globalObject));\n&quot;);
5962     push(@$contentRef, &quot;    }\n\n&quot;);
5963 
5964     push(@$contentRef, &quot;    virtual ScriptExecutionContext* scriptExecutionContext() const { return ContextDestructionObserver::scriptExecutionContext(); }\n\n&quot;);
5965 
5966     push(@$contentRef, &quot;    virtual ~$className();\n&quot;);
5967 
5968     push(@$contentRef, &quot;    ${callbackDataType}* callbackData() { return m_data; }\n&quot;);
5969 
5970     push(@$contentRef, &quot;    static JSC::JSValue getConstructor(JSC::VM&amp;, const JSC::JSGlobalObject*);\n&quot;) if @{$constants};
5971 
5972     push(@$contentRef, &quot;    virtual bool operator==(const ${name}&amp;) const override;\n\n&quot;) if $interfaceOrCallback-&gt;extendedAttributes-&gt;{CallbackNeedsOperatorEqual};
5973 
5974     # Operations
5975     my $numOperations = @{$operations};
5976     if ($numOperations &gt; 0) {
5977         push(@$contentRef, &quot;\n    // Functions\n&quot;);
5978         foreach my $operation (@{$operations}) {
5979             my @arguments = ();
5980 
5981             my $callbackThisObject = $operation-&gt;extendedAttributes-&gt;{CallbackThisObject};
5982             if ($callbackThisObject) {
5983                 my $thisObjectType = $codeGenerator-&gt;ParseType($callbackThisObject);
5984                 my $IDLType = GetIDLType($interfaceOrCallback, $thisObjectType);
5985                 push(@arguments, &quot;typename ${IDLType}::ParameterType thisObject&quot;);
5986             }
5987 
5988             foreach my $argument (@{$operation-&gt;arguments}) {
5989                 my $IDLType = GetIDLType($interfaceOrCallback, $argument-&gt;type);
5990                 push(@arguments, &quot;typename ${IDLType}::ParameterType &quot; . $argument-&gt;name);
5991             }
5992 
5993             my $nativeReturnType = &quot;CallbackResult&lt;typename &quot; . GetIDLType($interfaceOrCallback, $operation-&gt;type) . &quot;::ImplementationType&gt;&quot;;
5994             
5995             # FIXME: Change the default name (used for callback functions) to something other than handleEvent. It makes little sense.
5996             my $functionName = $operation-&gt;name || &quot;handleEvent&quot;;
5997 
5998             push(@$contentRef, &quot;    ${nativeReturnType} ${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;) override;\n&quot;);
5999         }
6000     }
6001 
6002     push(@$contentRef, &quot;\nprivate:\n&quot;);
6003 
6004     push(@$contentRef, &quot;    ${className}(JSC::JSObject*, JSDOMGlobalObject*);\n\n&quot;);
6005 
6006     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback}) {
6007         push(@$contentRef, &quot;    bool hasCallback() const final { return m_data &amp;&amp; m_data-&gt;callback(); }\n\n&quot;);
6008     }
6009 
6010     push(@$contentRef, &quot;    void visitJSFunction(JSC::SlotVisitor&amp;) override;\n\n&quot;) if $interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback};
6011 
6012     push(@$contentRef, &quot;    ${callbackDataType}* m_data;\n&quot;);
6013     push(@$contentRef, &quot;};\n\n&quot;);
6014 
6015     # toJS().
6016     push(@$contentRef, $exportMacro . &quot;JSC::JSValue toJS(${name}&amp;);\n&quot;);
6017     push(@$contentRef, &quot;inline JSC::JSValue toJS(${name}* impl) { return impl ? toJS(*impl) : JSC::jsNull(); }\n\n&quot;);
6018 }
6019 
6020 sub GenerateCallbackImplementationContent
6021 {
6022     my ($object, $interfaceOrCallback, $operations, $constants, $contentRef, $includesRef) = @_;
6023 
6024     my $name = $interfaceOrCallback-&gt;type-&gt;name;
6025     my $callbackDataType = $interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback} ? &quot;JSCallbackDataWeak&quot; : &quot;JSCallbackDataStrong&quot;;
6026     my $visibleName = $codeGenerator-&gt;GetVisibleInterfaceName($interfaceOrCallback);
6027     my $className = &quot;JS${name}&quot;;
6028 
6029     $includesRef-&gt;{&quot;ScriptExecutionContext.h&quot;} = 1;
6030 
6031     # Constructor
6032     push(@$contentRef, &quot;${className}::${className}(JSObject* callback, JSDOMGlobalObject* globalObject)\n&quot;);
6033     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{CallbackNeedsOperatorEqual}) {
6034         push(@$contentRef, &quot;    : ${name}(globalObject-&gt;scriptExecutionContext(), ${className}Type)\n&quot;);
6035     } else {
6036         push(@$contentRef, &quot;    : ${name}(globalObject-&gt;scriptExecutionContext())\n&quot;);
6037     }
6038     push(@$contentRef, &quot;    , m_data(new ${callbackDataType}(callback, globalObject, this))\n&quot;);
6039     push(@$contentRef, &quot;{\n&quot;);
6040     push(@$contentRef, &quot;}\n\n&quot;);
6041 
6042     # Destructor
6043     push(@$contentRef, &quot;${className}::~${className}()\n&quot;);
6044     push(@$contentRef, &quot;{\n&quot;);
6045     push(@$contentRef, &quot;    ScriptExecutionContext* context = scriptExecutionContext();\n&quot;);
6046     push(@$contentRef, &quot;    // When the context is destroyed, all tasks with a reference to a callback\n&quot;);
6047     push(@$contentRef, &quot;    // should be deleted. So if the context is 0, we are on the context thread.\n&quot;);
6048     push(@$contentRef, &quot;    if (!context || context-&gt;isContextThread())\n&quot;);
6049     push(@$contentRef, &quot;        delete m_data;\n&quot;);
6050     push(@$contentRef, &quot;    else\n&quot;);
6051     push(@$contentRef, &quot;        context-&gt;postTask(DeleteCallbackDataTask(m_data));\n&quot;);
6052     push(@$contentRef, &quot;#ifndef NDEBUG\n&quot;);
6053     push(@$contentRef, &quot;    m_data = nullptr;\n&quot;);
6054     push(@$contentRef, &quot;#endif\n&quot;);
6055     push(@$contentRef, &quot;}\n\n&quot;);
6056 
6057     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{CallbackNeedsOperatorEqual}) {
6058         push(@$contentRef, &quot;bool ${className}::operator==(const ${name}&amp; other) const\n&quot;);
6059         push(@$contentRef, &quot;{\n&quot;);
6060         push(@$contentRef, &quot;    if (other.type() != type())\n&quot;);
6061         push(@$contentRef, &quot;        return false;\n&quot;);
6062         push(@$contentRef, &quot;    return static_cast&lt;const ${className}*&gt;(&amp;other)-&gt;m_data-&gt;callback() == m_data-&gt;callback();\n&quot;);
6063         push(@$contentRef, &quot;}\n\n&quot;);
6064     }
6065 
6066     # Constants.
6067     my $numConstants = @{$constants};
6068     if ($numConstants &gt; 0) {
6069         GenerateConstructorDeclaration($contentRef, $className, $interfaceOrCallback, $name);
6070 
6071         my $hashSize = 0;
6072         my $hashName = $className . &quot;ConstructorTable&quot;;
6073 
6074         my @hashKeys = ();
6075         my @hashValue1 = ();
6076         my @hashValue2 = ();
6077         my @hashSpecials = ();
6078         my %conditionals = ();
6079         my %readWriteConditionals = ();
6080 
6081         foreach my $constant (@{$constants}) {
6082             my $name = $constant-&gt;name;
6083             push(@hashKeys, $name);
6084             push(@hashValue1, $constant-&gt;value);
6085             push(@hashValue2, &quot;0&quot;);
6086             push(@hashSpecials, &quot;JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::ConstantInteger&quot;);
6087 
6088             my $implementedBy = $constant-&gt;extendedAttributes-&gt;{ImplementedBy};
6089             $implIncludes{&quot;${implementedBy}.h&quot;} = 1 if $implementedBy;
6090 
6091             my $conditional = $constant-&gt;extendedAttributes-&gt;{Conditional};
6092             $conditionals{$name} = $conditional if $conditional;
6093 
6094             $hashSize++;
6095         }
6096         $object-&gt;GenerateHashTable($className, $hashName, $hashSize, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, 1) if $hashSize &gt; 0;
6097 
6098         push(@$contentRef, $codeGenerator-&gt;GenerateCompileTimeCheckForEnumsIfNeeded($interfaceOrCallback));
6099 
6100         GenerateConstructorDefinitions($contentRef, $className, &quot;&quot;, $visibleName, $interfaceOrCallback);
6101 
6102         push(@$contentRef, &quot;JSValue ${className}::getConstructor(VM&amp; vm, const JSGlobalObject* globalObject)\n&quot;);
6103         push(@$contentRef, &quot;{\n&quot;);
6104         push(@$contentRef, &quot;    return getDOMConstructor&lt;${className}Constructor&gt;(vm, *jsCast&lt;const JSDOMGlobalObject*&gt;(globalObject));\n&quot;);
6105         push(@$contentRef, &quot;}\n\n&quot;);
6106     }
6107 
6108     # Operations
6109     my $numOperations = @{$operations};
6110     if ($numOperations &gt; 0) {
6111         foreach my $operation (@{$operations}) {
6112             next if $operation-&gt;extendedAttributes-&gt;{Custom};
6113         
6114             AddToIncludesForIDLType($operation-&gt;type, $includesRef);
6115 
6116             my $nativeReturnType = &quot;CallbackResult&lt;typename &quot; . GetIDLType($interfaceOrCallback, $operation-&gt;type) . &quot;::ImplementationType&gt;&quot;;
6117             
6118             # FIXME: Change the default name (used for callback functions) to something other than handleEvent. It makes little sense.
6119             my $functionName = $operation-&gt;name || &quot;handleEvent&quot;;
6120 
6121             my @arguments = ();
6122 
6123             my $thisValue = &quot;jsUndefined()&quot;;
6124 
6125             my $callbackThisObject = $operation-&gt;extendedAttributes-&gt;{CallbackThisObject};
6126             if ($callbackThisObject) {
6127                 my $thisObjectType = $codeGenerator-&gt;ParseType($callbackThisObject);
6128 
6129                 AddToIncludesForIDLType($thisObjectType, $includesRef, 1);
6130                 my $IDLType = GetIDLType($interfaceOrCallback, $thisObjectType);
6131                 push(@arguments, &quot;typename ${IDLType}::ParameterType thisObject&quot;);
6132 
6133                 my $thisObjectArgument = IDLArgument-&gt;new();
6134                 $thisObjectArgument-&gt;type($thisObjectType);
6135 
6136                 $thisValue = NativeToJSValueUsingReferences($thisObjectArgument, $interfaceOrCallback, &quot;thisObject&quot;, &quot;globalObject&quot;);
6137             }
6138 
6139             foreach my $argument (@{$operation-&gt;arguments}) {
6140                 AddToIncludesForIDLType($argument-&gt;type, $includesRef, 1);
6141                 my $IDLType = GetIDLType($interfaceOrCallback, $argument-&gt;type);
6142                 push(@arguments, &quot;typename ${IDLType}::ParameterType &quot; . $argument-&gt;name);
6143             }
6144             
6145             push(@$contentRef, &quot;${nativeReturnType} ${className}::${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)\n&quot;);
6146             push(@$contentRef, &quot;{\n&quot;);
6147 
6148             # FIXME: This is needed for NodeFilter, which works even for disconnected iframes. We should investigate
6149             # if that behavior is needed for other callbacks.
6150             if (!$operation-&gt;extendedAttributes-&gt;{SkipCallbackInvokeCheck}) {
6151                 push(@$contentRef, &quot;    if (!canInvokeCallback())\n&quot;);
6152                 push(@$contentRef, &quot;        return CallbackResultType::UnableToExecute;\n\n&quot;);
6153             }
6154 
6155             push(@$contentRef, &quot;    Ref&lt;$className&gt; protectedThis(*this);\n\n&quot;);
6156             push(@$contentRef, &quot;    auto&amp; globalObject = *m_data-&gt;globalObject();\n&quot;);
6157             push(@$contentRef, &quot;    auto&amp; vm = globalObject.vm();\n\n&quot;);
6158             push(@$contentRef, &quot;    JSLockHolder lock(vm);\n&quot;);
6159 
6160             push(@$contentRef, &quot;    auto&amp; state = *globalObject.globalExec();\n&quot;);
6161 
6162             push(@$contentRef, &quot;    JSValue thisValue = ${thisValue};\n&quot;);
6163             push(@$contentRef, &quot;    MarkedArgumentBuffer args;\n&quot;);
6164 
6165             foreach my $argument (@{$operation-&gt;arguments}) {
6166                 push(@$contentRef, &quot;    args.append(&quot; . NativeToJSValueUsingReferences($argument, $interfaceOrCallback, $argument-&gt;name, &quot;globalObject&quot;) . &quot;);\n&quot;);
6167             }
6168             push(@$contentRef, &quot;    ASSERT(!args.hasOverflowed());\n&quot;);
6169 
6170             push(@$contentRef, &quot;\n    NakedPtr&lt;JSC::Exception&gt; returnedException;\n&quot;);
6171 
6172             my $callbackInvocation;
6173             if (ref($interfaceOrCallback) eq &quot;IDLCallbackFunction&quot;) {
6174                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::Function, Identifier(), returnedException)&quot;;
6175             } else {
6176                 my $callbackType = $numOperations &gt; 1 ? &quot;Object&quot; : &quot;FunctionOrObject&quot;;
6177                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::${callbackType}, Identifier::fromString(&amp;vm, \&quot;${functionName}\&quot;), returnedException)&quot;;
6178             }
6179 
6180             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6181                 push(@$contentRef, &quot;    ${callbackInvocation};\n&quot;);
6182             } else {
6183                 push(@$contentRef, &quot;    auto jsResult = ${callbackInvocation};\n&quot;);
6184             }
6185 
6186             $includesRef-&gt;{&quot;JSDOMExceptionHandling.h&quot;} = 1;
6187             push(@$contentRef, &quot;    if (returnedException) {\n&quot;);
6188             if ($operation-&gt;extendedAttributes-&gt;{RethrowException}) {
6189                 push(@$contentRef, &quot;        auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
6190                 push(@$contentRef, &quot;        throwException(&amp;state, throwScope, returnedException);\n&quot;);
6191             } else {
6192                 push(@$contentRef, &quot;        reportException(&amp;state, returnedException);\n&quot;);
6193             }
6194             push(@$contentRef, &quot;        return CallbackResultType::ExceptionThrown;\n&quot;);
6195             push(@$contentRef, &quot;     }\n\n&quot;);
6196 
6197             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6198                 push(@$contentRef, &quot;    return { };\n&quot;);
6199             } else {
6200                 my $nativeValue = JSValueToNative($interfaceOrCallback, $operation, &quot;jsResult&quot;, &quot;&quot;, &quot;&amp;state&quot;, &quot;state&quot;);
6201             
6202                 push(@$contentRef, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
6203                 push(@$contentRef, &quot;    auto returnValue = ${nativeValue};\n&quot;);
6204                 push(@$contentRef, &quot;    RETURN_IF_EXCEPTION(throwScope, CallbackResultType::ExceptionThrown);\n&quot;);
6205                 push(@$contentRef, &quot;    return WTFMove(returnValue);\n&quot;);
6206             }
6207 
6208             push(@$contentRef, &quot;}\n\n&quot;);
6209         }
6210     }
6211 
6212     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback}) {
6213         push(@$contentRef, &quot;void ${className}::visitJSFunction(JSC::SlotVisitor&amp; visitor)\n&quot;);
6214         push(@$contentRef, &quot;{\n&quot;);
6215         push(@$contentRef, &quot;    m_data-&gt;visitJSFunction(visitor);\n&quot;);
6216         push(@$contentRef, &quot;}\n\n&quot;);
6217     }
6218 
6219     push(@$contentRef, &quot;JSC::JSValue toJS(${name}&amp; impl)\n&quot;);
6220     push(@$contentRef, &quot;{\n&quot;);
6221     push(@$contentRef, &quot;    if (!static_cast&lt;${className}&amp;&gt;(impl).callbackData())\n&quot;);
6222     push(@$contentRef, &quot;        return jsNull();\n\n&quot;);
6223     push(@$contentRef, &quot;    return static_cast&lt;${className}&amp;&gt;(impl).callbackData()-&gt;callback();\n&quot;);
6224     push(@$contentRef, &quot;}\n\n&quot;);
6225 }
6226 
6227 sub GenerateImplementationFunctionCall
6228 {
6229     my ($outputArray, $operation, $interface, $functionString, $indent) = @_;
6230 
6231     my $callTracingCallback = $operation-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
6232     if ($callTracingCallback) {
6233         my @callTracerArguments = ();
6234         foreach my $argument (@{$operation-&gt;arguments}) {
6235             push(@callTracerArguments, GenerateCallTracerParameter($argument-&gt;name, $argument-&gt;type, $argument-&gt;isOptional &amp;&amp; !defined($argument-&gt;default), $indent));
6236         }
6237         GenerateCallTracer($outputArray, $callTracingCallback, $operation-&gt;name, \@callTracerArguments, $indent);
6238     }
6239 
6240     if (OperationHasForcedReturnValue($operation)) {
6241         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6242         push(@$outputArray, $indent . &quot;return JSValue::encode(returnValue);\n&quot;);
6243     } elsif ($operation-&gt;type-&gt;name eq &quot;void&quot; || ($codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy})) {
6244         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6245         push(@$outputArray, $indent . &quot;return JSValue::encode(jsUndefined());\n&quot;);
6246     } else {
6247         my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*castedThis-&gt;globalObject()&quot;;
6248         push(@$outputArray, $indent . &quot;return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, $globalObjectReference) . &quot;);\n&quot;);
6249     }
6250 }
6251 
6252 sub GenerateImplementationCustomFunctionCall
6253 {
6254     my ($outputArray, $operation, $interface, $className, $functionImplementationName, $indent) = @_;
6255 
6256     my @customFunctionArguments = ();
6257     push(@customFunctionArguments, &quot;*state&quot;);
6258     push(@customFunctionArguments, &quot;WTFMove(promise)&quot;) if $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
6259 
6260     if ($operation-&gt;isStatic) {
6261         push(@$outputArray, $indent . &quot;return JSValue::encode(${className}::&quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @customFunctionArguments) . &quot;));\n&quot;);
6262     } else {
6263         push(@$outputArray, $indent . &quot;return JSValue::encode(castedThis-&gt;&quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @customFunctionArguments) . &quot;));\n&quot;);
6264     }
6265 }
6266 
6267 sub IsValueIterableInterface
6268 {
6269     my $interface = shift;
6270     return 0 unless $interface-&gt;iterable;
6271     return 0 if length $interface-&gt;iterable-&gt;keyType;
6272     # FIXME: See https://webkit.org/b/159140, we should die if the next check is false.
6273     return 0 unless GetIndexedGetterOperation($interface);
6274     return 1;
6275 }
6276 
6277 sub IsKeyValueIterableInterface
6278 {
6279     my $interface = shift;
6280     return 0 unless $interface-&gt;iterable;
6281     return 0 if IsValueIterableInterface($interface);
6282     return 1;
6283 }
6284 
6285 sub GenerateIterableDefinition
6286 {
6287     my $interface = shift;
6288 
6289     my $interfaceName = $interface-&gt;type-&gt;name;
6290     my $className = &quot;JS$interfaceName&quot;;
6291     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
6292 
6293     AddToImplIncludes(&quot;JSDOMIterator.h&quot;);
6294 
6295     return unless IsKeyValueIterableInterface($interface);
6296 
6297     my $iteratorName = &quot;${interfaceName}Iterator&quot;;
6298     my $iteratorPrototypeName = &quot;${interfaceName}IteratorPrototype&quot;;
6299 
6300     my $iteratorTraitsName = &quot;${interfaceName}IteratorTraits&quot;;
6301     my $iteratorTraitsType = $interface-&gt;iterable-&gt;isKeyValue ? &quot;JSDOMIteratorType::Map&quot; : &quot;JSDOMIteratorType::Set&quot;;
6302     my $iteratorTraitsKeyType = $interface-&gt;iterable-&gt;isKeyValue ? GetIDLType($interface, $interface-&gt;iterable-&gt;keyType) : &quot;void&quot;;
6303     my $iteratorTraitsValueType = GetIDLType($interface, $interface-&gt;iterable-&gt;valueType);
6304 
6305     push(@implContent,  &lt;&lt;END);
6306 struct ${iteratorTraitsName} {
6307     static constexpr JSDOMIteratorType type = ${iteratorTraitsType};
6308     using KeyType = ${iteratorTraitsKeyType};
6309     using ValueType = ${iteratorTraitsValueType};
6310 };
6311 
6312 using ${iteratorName} = JSDOMIterator&lt;${className}, ${iteratorTraitsName}&gt;;
6313 using ${iteratorPrototypeName} = JSDOMIteratorPrototype&lt;${className}, ${iteratorTraitsName}&gt;;
6314 
6315 template&lt;&gt;
6316 const JSC::ClassInfo ${iteratorName}::s_info = { &quot;${visibleInterfaceName} Iterator&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${iteratorName}) };
6317 
6318 template&lt;&gt;
6319 const JSC::ClassInfo ${iteratorPrototypeName}::s_info = { &quot;${visibleInterfaceName} Iterator&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${iteratorPrototypeName}) };
6320 
6321 END
6322 
6323     foreach my $operation (@{$interface-&gt;iterable-&gt;operations}) {
6324         my $propertyName = $operation-&gt;name;
6325         my $functionName = GetFunctionName($interface, $className, $operation);
6326 
6327         next if $propertyName eq &quot;[Symbol.Iterator]&quot;;
6328 
6329         if ($propertyName eq &quot;forEach&quot;) {
6330             push(@implContent,  &lt;&lt;END);
6331 static inline EncodedJSValue ${functionName}Caller(ExecState* state, JS$interfaceName* thisObject, JSC::ThrowScope&amp; throwScope)
6332 {
6333     return JSValue::encode(iteratorForEach&lt;${iteratorName}&gt;(*state, *thisObject, throwScope));
6334 }
6335 
6336 END
6337         } else {
6338             my $iterationKind = &quot;KeyValue&quot;;
6339             $iterationKind = &quot;Key&quot; if $propertyName eq &quot;keys&quot;;
6340             $iterationKind = &quot;Value&quot; if $propertyName eq &quot;values&quot;;
6341             $iterationKind = &quot;Value&quot; if $propertyName eq &quot;entries&quot; and not $interface-&gt;iterable-&gt;isKeyValue;
6342 
6343             push(@implContent,  &lt;&lt;END);
6344 static inline EncodedJSValue ${functionName}Caller(ExecState*, JS$interfaceName* thisObject, JSC::ThrowScope&amp;)
6345 {
6346     return JSValue::encode(iteratorCreate&lt;${iteratorName}&gt;(*thisObject, IterationKind::${iterationKind}));
6347 }
6348 
6349 END
6350         }
6351 
6352         push(@implContent,  &lt;&lt;END);
6353 JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::ExecState* state)
6354 {
6355     return IDLOperation&lt;${className}&gt;::call&lt;${functionName}Caller&gt;(*state, &quot;${propertyName}&quot;);
6356 }
6357 
6358 END
6359     }
6360 }
6361 
6362 # http://heycam.github.io/webidl/#dfn-flattened-union-member-types
6363 sub GetFlattenedMemberTypes
6364 {
6365     my ($idlUnionType) = @_;
6366 
6367     my @flattenedMemberTypes = ();
6368 
6369     foreach my $memberType (@{$idlUnionType-&gt;subtypes}) {
6370         if ($memberType-&gt;isUnion) {
6371             push(@flattenedMemberTypes, GetFlattenedMemberTypes($memberType));
6372         } else {
6373             push(@flattenedMemberTypes, $memberType);
6374         }
6375     }
6376 
6377     return @flattenedMemberTypes;
6378 }
6379 
6380 # http://heycam.github.io/webidl/#dfn-number-of-nullable-member-types
6381 sub GetNumberOfNullableMemberTypes
6382 {
6383     my ($idlUnionType) = @_;
6384 
6385     my $count = 0;
6386 
6387     foreach my $memberType (@{$idlUnionType-&gt;subtypes}) {
6388         $count++ if $memberType-&gt;isNullable;
6389         $count += GetNumberOfNullableMemberTypes($memberType) if $memberType-&gt;isUnion;
6390     }
6391 
6392     return $count;
6393 }
6394 
6395 sub GetIDLUnionMemberTypes
6396 {
6397     my ($interface, $idlUnionType) = @_;
6398 
6399     my $numberOfNullableMembers = GetNumberOfNullableMemberTypes($idlUnionType);
6400     assert(&quot;Union types must only have 0 or 1 nullable types.&quot;) if $numberOfNullableMembers &gt; 1;
6401 
6402     my @idlUnionMemberTypes = ();
6403 
6404     push(@idlUnionMemberTypes, &quot;IDLNull&quot;) if $numberOfNullableMembers == 1;
6405 
6406     foreach my $memberType (GetFlattenedMemberTypes($idlUnionType)) {
6407         push(@idlUnionMemberTypes, GetIDLTypeExcludingNullability($interface, $memberType));
6408     }
6409 
6410     return @idlUnionMemberTypes;
6411 }
6412 
6413 sub IsAnnotatedType
6414 {
6415     my ($type) = @_;
6416 
6417     return 1 if $type-&gt;extendedAttributes-&gt;{Clamp};
6418     return 1 if $type-&gt;extendedAttributes-&gt;{EnforceRange};
6419     return 1 if $type-&gt;extendedAttributes-&gt;{TreatNullAs} &amp;&amp; $type-&gt;extendedAttributes-&gt;{TreatNullAs} eq &quot;EmptyString&quot;;
6420     return 1 if $type-&gt;extendedAttributes-&gt;{AtomicString};
6421     return 1 if $type-&gt;extendedAttributes-&gt;{RequiresExistingAtomicString};
6422 }
6423 
6424 sub GetAnnotatedIDLType
6425 {
6426     my ($type) = @_;
6427 
6428     return &quot;IDLClampAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{Clamp};
6429     return &quot;IDLEnforceRangeAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{EnforceRange};
6430     return &quot;IDLTreatNullAsEmptyAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{TreatNullAs} &amp;&amp; $type-&gt;extendedAttributes-&gt;{TreatNullAs} eq &quot;EmptyString&quot;;
6431     return &quot;IDLAtomicStringAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{AtomicString};
6432     return &quot;IDLRequiresExistingAtomicStringAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{RequiresExistingAtomicString};
6433 }
6434 
6435 sub GetBaseIDLType
6436 {
6437     my ($interface, $type) = @_;
6438 
6439     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6440         return $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6441     }
6442 
6443     my %IDLTypes = (
6444         &quot;void&quot; =&gt; &quot;IDLVoid&quot;,
6445         &quot;any&quot; =&gt; &quot;IDLAny&quot;,
6446         &quot;boolean&quot; =&gt; &quot;IDLBoolean&quot;,
6447         &quot;byte&quot; =&gt; &quot;IDLByte&quot;,
6448         &quot;octet&quot; =&gt; &quot;IDLOctet&quot;,
6449         &quot;short&quot; =&gt; &quot;IDLShort&quot;,
6450         &quot;unsigned short&quot; =&gt; &quot;IDLUnsignedShort&quot;,
6451         &quot;long&quot; =&gt; &quot;IDLLong&quot;,
6452         &quot;unsigned long&quot; =&gt; &quot;IDLUnsignedLong&quot;,
6453         &quot;long long&quot; =&gt; &quot;IDLLongLong&quot;,
6454         &quot;unsigned long long&quot; =&gt; &quot;IDLUnsignedLongLong&quot;,
6455         &quot;float&quot; =&gt; &quot;IDLFloat&quot;,
6456         &quot;unrestricted float&quot; =&gt; &quot;IDLUnrestrictedFloat&quot;,
6457         &quot;double&quot; =&gt; &quot;IDLDouble&quot;,
6458         &quot;unrestricted double&quot; =&gt; &quot;IDLUnrestrictedDouble&quot;,
6459         &quot;DOMString&quot; =&gt; &quot;IDLDOMString&quot;,
6460         &quot;ByteString&quot; =&gt; &quot;IDLByteString&quot;,
6461         &quot;USVString&quot; =&gt; &quot;IDLUSVString&quot;,
6462         &quot;object&quot; =&gt; &quot;IDLObject&quot;,
6463         &quot;ArrayBuffer&quot; =&gt; &quot;IDLArrayBuffer&quot;,
6464         &quot;ArrayBufferView&quot; =&gt; &quot;IDLArrayBufferView&quot;,
6465         &quot;DataView&quot; =&gt; &quot;IDLDataView&quot;,
6466         &quot;Int8Array&quot; =&gt; &quot;IDLInt8Array&quot;,
6467         &quot;Int16Array&quot; =&gt; &quot;IDLInt16Array&quot;,
6468         &quot;Int32Array&quot; =&gt; &quot;IDLInt32Array&quot;,
6469         &quot;Uint8Array&quot; =&gt; &quot;IDLUint8Array&quot;,
6470         &quot;Uint16Array&quot; =&gt; &quot;IDLUint16Array&quot;,
6471         &quot;Uint32Array&quot; =&gt; &quot;IDLUint32Array&quot;,
6472         &quot;Uint8ClampedArray&quot; =&gt; &quot;IDLUint8ClampedArray&quot;,
6473         &quot;Float32Array&quot; =&gt; &quot;IDLFloat32Array&quot;,
6474         &quot;Float64Array&quot; =&gt; &quot;IDLFloat64Array&quot;,
6475 
6476         # Non-WebIDL extensions
6477         &quot;Date&quot; =&gt; &quot;IDLDate&quot;,
6478         &quot;EventListener&quot; =&gt; &quot;IDLEventListener&lt;JSEventListener&gt;&quot;,
6479         &quot;JSON&quot; =&gt; &quot;IDLJSON&quot;,
6480         &quot;ScheduledAction&quot; =&gt; &quot;IDLScheduledAction&quot;,
6481         &quot;SerializedScriptValue&quot; =&gt; &quot;IDLSerializedScriptValue&lt;SerializedScriptValue&gt;&quot;,
6482         &quot;XPathNSResolver&quot; =&gt; &quot;IDLXPathNSResolver&lt;XPathNSResolver&gt;&quot;,
6483     );
6484 
6485     return $IDLTypes{$type-&gt;name} if exists $IDLTypes{$type-&gt;name};
6486     return &quot;IDLEnumeration&lt;&quot; . GetEnumerationClassName($type, $interface) . &quot;&gt;&quot; if $codeGenerator-&gt;IsEnumType($type);
6487     return &quot;IDLDictionary&lt;&quot; . GetDictionaryClassName($type, $interface) . &quot;&gt;&quot; if $codeGenerator-&gt;IsDictionaryType($type);
6488     return &quot;IDLSequence&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsSequenceType($type);
6489     return &quot;IDLFrozenArray&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsFrozenArrayType($type);
6490     return &quot;IDLRecord&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;, &quot; . GetIDLType($interface, @{$type-&gt;subtypes}[1]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsRecordType($type);
6491     return &quot;IDLPromise&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsPromiseType($type);
6492     return &quot;IDLUnion&lt;&quot; . join(&quot;, &quot;, GetIDLUnionMemberTypes($interface, $type)) . &quot;&gt;&quot; if $type-&gt;isUnion;
6493     return &quot;IDLCallbackFunction&lt;&quot; . GetCallbackClassName($type-&gt;name) . &quot;&gt;&quot; if $codeGenerator-&gt;IsCallbackFunction($type);
6494     return &quot;IDLCallbackInterface&lt;&quot; . GetCallbackClassName($type-&gt;name) . &quot;&gt;&quot; if $codeGenerator-&gt;IsCallbackInterface($type);
6495 
6496     assert(&quot;Unknown type &#39;&quot; . $type-&gt;name . &quot;&#39;.\n&quot;) unless $codeGenerator-&gt;IsInterfaceType($type);
6497     return &quot;IDLInterface&lt;&quot; . $type-&gt;name . &quot;&gt;&quot;;
6498 }
6499 
6500 sub GetIDLTypeExcludingNullability
6501 {
6502     my ($interface, $type) = @_;
6503 
6504     my $baseIDLType = GetBaseIDLType($interface, $type);
6505     $baseIDLType = GetAnnotatedIDLType($type) . &quot;&lt;&quot; . $baseIDLType . &quot;&gt;&quot; if IsAnnotatedType($type);
6506     return $baseIDLType;
6507 }
6508 
6509 sub GetIDLType
6510 {
6511     my ($interface, $type) = @_;
6512 
6513     my $baseIDLType = GetIDLTypeExcludingNullability($interface, $type);
6514     $baseIDLType = &quot;IDLNullable&lt;&quot; . $baseIDLType . &quot;&gt;&quot; if $type-&gt;isNullable;
6515     return $baseIDLType;
6516 }
6517 
6518 sub ShouldPassArgumentByReference
6519 {
6520     my ($argument) = @_;
6521 
6522     my $type = $argument-&gt;type;
6523 
6524     return 0 if $type-&gt;isNullable;
6525     return 0 if $codeGenerator-&gt;IsCallbackInterface($type);
6526     return 0 if $codeGenerator-&gt;IsCallbackFunction($type);
6527     return 0 if !$codeGenerator-&gt;IsWrapperType($type) &amp;&amp; !$codeGenerator-&gt;IsBufferSourceType($type);
6528 
6529     return 1;
6530 }
6531 
6532 sub JSValueToNativeDOMConvertNeedsThisObject
6533 {
6534     my $type = shift;
6535 
6536     return 1 if $type-&gt;name eq &quot;EventListener&quot;;
6537     return 0;
6538 }
6539 
6540 sub JSValueToNativeDOMConvertNeedsGlobalObject
6541 {
6542     my $type = shift;
6543 
6544     return 1 if $codeGenerator-&gt;IsCallbackInterface($type);
6545     return 1 if $codeGenerator-&gt;IsCallbackFunction($type);
6546     return 1 if $type-&gt;name eq &quot;ScheduledAction&quot;;
6547     return 0;
6548 }
6549 
6550 sub IsValidContextForJSValueToNative
6551 {
6552     my $context = shift;
6553     return (ref($context) eq &quot;IDLAttribute&quot; &amp;&amp; !$codeGenerator-&gt;IsEnumType($context-&gt;type)) || ref($context) eq &quot;IDLArgument&quot; || ref($context) eq &quot;IDLDictionaryMember&quot; || ref($context) eq &quot;IDLOperation&quot;;
6554 }
6555 
6556 sub JSValueToNative
6557 {
6558     my ($interface, $context, $value, $conditional, $statePointer, $stateReference, $thisObjectReference, $globalObjectReference, $exceptionThrower) = @_;
6559 
6560     assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
6561 
6562     my $type = $context-&gt;type;
6563 
6564     # FIXME: Remove these 3 variables when all JSValueToNative use references.
6565     $statePointer = &quot;state&quot; unless $statePointer;
6566     $stateReference = &quot;*state&quot; unless $stateReference;
6567     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6568 
6569     AddToImplIncludesForIDLType($type, $conditional);
6570     AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6571 
6572     my $IDLType = GetIDLType($interface, $type);
6573 
6574     my @conversionArguments = ();
6575     push(@conversionArguments, $stateReference);
6576     push(@conversionArguments, $value);
6577     push(@conversionArguments, $thisObjectReference) if JSValueToNativeDOMConvertNeedsThisObject($type);
6578     push(@conversionArguments, $globalObjectReference) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6579     push(@conversionArguments, $exceptionThrower) if $exceptionThrower;
6580 
6581     return &quot;convert&lt;$IDLType&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
6582 }
6583 
6584 sub UnsafeToNative
6585 {
6586     my ($interface, $context, $value, $conditional, $statePointer, $stateReference, $thisObjectReference) = @_;
6587 
6588     assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
6589 
6590     my $type = $context-&gt;type;
6591 
6592     # FIXME: Remove these 3 variables when all JSValueToNative use references.
6593     $statePointer = &quot;state&quot; unless $statePointer;
6594     $stateReference = &quot;*state&quot; unless $stateReference;
6595     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6596 
6597     AddToImplIncludesForIDLType($type, $conditional);
6598 
6599     # FIXME: Support more types.
6600 
6601     AddToImplIncludes(&quot;DOMJITIDLConvert.h&quot;);
6602 
6603     my $IDLType = GetIDLType($interface, $type);
6604 
6605     my @conversionArguments = ();
6606     push(@conversionArguments, &quot;$stateReference&quot;);
6607     push(@conversionArguments, &quot;$value&quot;);
6608 
6609     return (&quot;DOMJIT::DirectConverter&lt;$IDLType&gt;::directConvert(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;, 1);
6610 }
6611 
6612 sub NativeToJSValueDOMConvertNeedsState
6613 {
6614     my ($type) = @_;
6615 
6616     # FIXME: We need a more robust way to specify this requirement so as not
6617     # to require specializing each type. Perhaps just requiring all override
6618     # types to take both state and the global object would work?
6619     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6620         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6621         return 1 if $overrideTypeName eq &quot;IDLIDBKey&quot;;
6622         return 1 if $overrideTypeName eq &quot;IDLWebGLAny&quot;;
6623         return 1 if $overrideTypeName eq &quot;IDLWebGLExtension&quot;;
6624 
6625         return 0;
6626     }
6627 
6628     # FIXME: This should actually check if all the sub-objects of the union need the state.
6629     return 1 if $type-&gt;isUnion;
6630     return 1 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
6631     return 1 if $codeGenerator-&gt;IsRecordType($type);
6632     return 1 if $codeGenerator-&gt;IsStringType($type);
6633     return 1 if $codeGenerator-&gt;IsEnumType($type);
6634     return 1 if $codeGenerator-&gt;IsDictionaryType($type);
6635     return 1 if $codeGenerator-&gt;IsInterfaceType($type);
6636     return 1 if $codeGenerator-&gt;IsBufferSourceType($type);
6637     return 1 if $codeGenerator-&gt;IsPromiseType($type);
6638     return 1 if $type-&gt;name eq &quot;Date&quot;;
6639     return 1 if $type-&gt;name eq &quot;JSON&quot;;
6640     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
6641     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
6642     
6643     return 0;
6644 }
6645 
6646 sub NativeToJSValueDOMConvertNeedsGlobalObject
6647 {
6648     my ($type) = @_;
6649     
6650     # FIXME: We need a more robust way to specify this requirement so as not
6651     # to require specializing each type. Perhaps just requiring all override
6652     # types to take both state and the global object would work?
6653     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6654         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6655         return 1 if $overrideTypeName eq &quot;IDLIDBKey&quot;;
6656         return 1 if $overrideTypeName eq &quot;IDLWebGLAny&quot;;
6657         return 1 if $overrideTypeName eq &quot;IDLWebGLExtension&quot;;
6658 
6659         return 0;
6660     }
6661 
6662     # FIXME: This should actually check if all the sub-objects of the union need the global object.
6663     return 1 if $type-&gt;isUnion;
6664     return 1 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
6665     return 1 if $codeGenerator-&gt;IsRecordType($type);
6666     return 1 if $codeGenerator-&gt;IsDictionaryType($type);
6667     return 1 if $codeGenerator-&gt;IsInterfaceType($type);
6668     return 1 if $codeGenerator-&gt;IsBufferSourceType($type);
6669     return 1 if $codeGenerator-&gt;IsPromiseType($type);
6670     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
6671     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
6672 
6673     return 0;
6674 }
6675 
6676 sub NativeToJSValueUsingReferences
6677 {
6678     my ($context, $interface, $value, $globalObjectReference) = @_;
6679 
6680     return NativeToJSValue($context, $interface, $value, &quot;state&quot;, $globalObjectReference);
6681 }
6682 
6683 # FIXME: We should remove NativeToJSValueUsingPointers and combine NativeToJSValueUsingReferences and NativeToJSValue
6684 sub NativeToJSValueUsingPointers
6685 {
6686     my ($context, $interface, $value, $globalObjectReference) = @_;
6687 
6688     return NativeToJSValue($context, $interface, $value, &quot;*state&quot;, $globalObjectReference);
6689 }
6690 
6691 sub IsValidContextForNativeToJSValue
6692 {
6693     my $context = shift;
6694     
6695     return ref($context) eq &quot;IDLAttribute&quot; || ref($context) eq &quot;IDLArgument&quot; || ref($context) eq &quot;IDLDictionaryMember&quot; || ref($context) eq &quot;IDLOperation&quot;;
6696 }
6697 
6698 sub NativeToJSValue
6699 {
6700     my ($context, $interface, $value, $stateReference, $globalObjectReference) = @_;
6701 
6702     assert(&quot;Invalid context type&quot;) if !IsValidContextForNativeToJSValue($context);
6703 
6704     my $conditional = $context-&gt;extendedAttributes-&gt;{Conditional};
6705     my $type = $context-&gt;type;
6706     my $mayThrowException = ref($context) eq &quot;IDLAttribute&quot; || $context-&gt;extendedAttributes-&gt;{MayThrowException};
6707 
6708     # We could instead overload a function to work with optional as well as non-optional numbers, but this
6709     # is slightly better because it guarantees we will fail to compile if the IDL file doesn&#39;t match the C++.
6710     if ($context-&gt;extendedAttributes-&gt;{Reflect} and ($type-&gt;name eq &quot;unsigned long&quot; or $type-&gt;name eq &quot;unsigned short&quot;)) {
6711         $value =~ s/getUnsignedIntegralAttribute/getIntegralAttribute/g;
6712         $value = &quot;std::max(0, $value)&quot;;
6713     }
6714 
6715     AddToImplIncludesForIDLType($type, $conditional);
6716     AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if NativeToJSValueDOMConvertNeedsGlobalObject($type);
6717 
6718     if ($context-&gt;extendedAttributes-&gt;{CheckSecurityForNode}) {
6719         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
6720         $value = &quot;BindingSecurity::checkSecurityForNode($stateReference, $value)&quot;;
6721     }
6722 
6723     my $IDLType = GetIDLType($interface, $type);
6724 
6725     my @conversionArguments = ();
6726     push(@conversionArguments, $stateReference) if NativeToJSValueDOMConvertNeedsState($type) || $mayThrowException;
6727     push(@conversionArguments, $globalObjectReference) if NativeToJSValueDOMConvertNeedsGlobalObject($type);
6728     push(@conversionArguments, &quot;throwScope&quot;) if $mayThrowException;
6729     push(@conversionArguments, $value);
6730 
6731     my $functionName = $context-&gt;extendedAttributes-&gt;{NewObject} ? &quot;toJSNewlyCreated&quot; : &quot;toJS&quot;;
6732 
6733     return &quot;${functionName}&lt;${IDLType}&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
6734 }
6735 
6736 sub ceilingToPowerOf2
6737 {
6738     my ($size) = @_;
6739 
6740     my $powerOf2 = 1;
6741     while ($size &gt; $powerOf2) {
6742         $powerOf2 &lt;&lt;= 1;
6743     }
6744 
6745     return $powerOf2;
6746 }
6747 
6748 # Internal Helper
6749 sub GenerateHashTableValueArray
6750 {
6751     my $keys = shift;
6752     my $specials = shift;
6753     my $value1 = shift;
6754     my $value2 = shift;
6755     my $conditionals = shift;
6756     my $readWriteConditionals = shift;
6757     my $nameEntries = shift;
6758 
6759     my $packedSize = scalar @{$keys};
6760     push(@implContent, &quot;\nstatic const HashTableValue $nameEntries\[\] =\n\{\n&quot;);
6761 
6762     my $hasSetter = &quot;false&quot;;
6763 
6764     my $i = 0;
6765     foreach my $key (@{$keys}) {
6766         my $firstTargetType;
6767         my $secondTargetType = &quot;&quot;;
6768         my $conditional;
6769 
6770         if ($conditionals) {
6771             $conditional = $conditionals-&gt;{$key};
6772         }
6773         if ($conditional) {
6774             my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
6775             push(@implContent, &quot;#if ${conditionalString}\n&quot;);
6776         }
6777 
6778         if (&quot;@$specials[$i]&quot; =~ m/DOMJITFunction/) {
6779             $firstTargetType = &quot;static_cast&lt;RawNativeFunction&gt;&quot;;
6780             $secondTargetType = &quot;static_cast&lt;const JSC::DOMJIT::Signature*&gt;&quot;;
6781         } elsif (&quot;@$specials[$i]&quot; =~ m/Function/) {
6782             $firstTargetType = &quot;static_cast&lt;RawNativeFunction&gt;&quot;;
6783         } elsif (&quot;@$specials[$i]&quot; =~ m/Builtin/) {
6784             $firstTargetType = &quot;static_cast&lt;BuiltinGenerator&gt;&quot;;
6785         } elsif (&quot;@$specials[$i]&quot; =~ m/ConstantInteger/) {
6786             $firstTargetType = &quot;&quot;;
6787         } elsif (&quot;@$specials[$i]&quot; =~ m/DOMJITAttribute/) {
6788             $firstTargetType = &quot;static_cast&lt;const JSC::DOMJIT::GetterSetter*&gt;&quot;;
6789         } else {
6790             $firstTargetType = &quot;static_cast&lt;PropertySlot::GetValueFunc&gt;&quot;;
6791             $secondTargetType = &quot;static_cast&lt;PutPropertySlot::PutValueFunc&gt;&quot;;
6792             $hasSetter = &quot;true&quot;;
6793         }
6794         if (&quot;@$specials[$i]&quot; =~ m/ConstantInteger/) {
6795             push(@implContent, &quot;    { \&quot;$key\&quot;, @$specials[$i], NoIntrinsic, { (long long)&quot; . $firstTargetType . &quot;(@$value1[$i]) } },\n&quot;);
6796         } else {
6797             my $readWriteConditional = $readWriteConditionals ? $readWriteConditionals-&gt;{$key} : undef;
6798             if ($readWriteConditional) {
6799                 my $readWriteConditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
6800                 push(@implContent, &quot;#if ${readWriteConditionalString}\n&quot;);
6801             }
6802 
6803             push(@implContent, &quot;    { \&quot;$key\&quot;, @$specials[$i], NoIntrinsic, { (intptr_t)&quot; . $firstTargetType . &quot;(@$value1[$i]), (intptr_t) &quot; . $secondTargetType . &quot;(@$value2[$i]) } },\n&quot;);
6804 
6805             if ($readWriteConditional) {
6806                 push(@implContent, &quot;#else\n&quot;) ;
6807                 push(@implContent, &quot;    { \&quot;$key\&quot;, JSC::PropertyAttribute::ReadOnly | @$specials[$i], NoIntrinsic, { (intptr_t)&quot; . $firstTargetType . &quot;(@$value1[$i]), (intptr_t) static_cast&lt;PutPropertySlot::PutValueFunc&gt;(0) } },\n&quot;);
6808                 push(@implContent, &quot;#endif\n&quot;);
6809             }
6810         }
6811         if ($conditional) {
6812             push(@implContent, &quot;#else\n&quot;);
6813             push(@implContent, &quot;    { 0, 0, NoIntrinsic, { 0, 0 } },\n&quot;);
6814             push(@implContent, &quot;#endif\n&quot;);
6815         }
6816         ++$i;
6817     }
6818 
6819     push(@implContent, &quot;    { 0, 0, NoIntrinsic, { 0, 0 } }\n&quot;) if (!$packedSize);
6820     push(@implContent, &quot;};\n\n&quot;);
6821 
6822     return $hasSetter;
6823 }
6824 
6825 sub GenerateHashTable
6826 {
6827     my $object = shift;
6828 
6829     my $className = shift;
6830     my $name = shift;
6831     my $size = shift;
6832     my $keys = shift;
6833     my $specials = shift;
6834     my $value1 = shift;
6835     my $value2 = shift;
6836     my $conditionals = shift;
6837     my $readWriteConditionals = shift;
6838     my $justGenerateValueArray = shift;
6839 
6840     my $nameEntries = &quot;${name}Values&quot;;
6841     $nameEntries =~ s/:/_/g;
6842     my $nameIndex = &quot;${name}Index&quot;;
6843     $nameIndex =~ s/:/_/g;
6844 
6845     if (($name =~ /Prototype/) or ($name =~ /Constructor/)) {
6846         my $type = $name;
6847         my $implClass;
6848 
6849         if ($name =~ /Prototype/) {
6850             $type =~ s/Prototype.*//;
6851             $implClass = $type; $implClass =~ s/Wrapper$//;
6852             push(@implContent, &quot;/* Hash table for prototype */\n&quot;);
6853         } else {
6854             $type =~ s/Constructor.*//;
6855             $implClass = $type; $implClass =~ s/Constructor$//;
6856             push(@implContent, &quot;/* Hash table for constructor */\n&quot;);
6857         }
6858     } else {
6859         push(@implContent, &quot;/* Hash table */\n&quot;);
6860     }
6861 
6862     if ($justGenerateValueArray) {
6863         GenerateHashTableValueArray($keys, $specials, $value1, $value2, $conditionals, $readWriteConditionals, $nameEntries) if $size;
6864         return;
6865     }
6866 
6867     # Generate size data for compact&#39; size hash table
6868 
6869     my @table = ();
6870     my @links = ();
6871 
6872     my $compactSize = ceilingToPowerOf2($size * 2);
6873 
6874     my $maxDepth = 0;
6875     my $collisions = 0;
6876     my $numEntries = $compactSize;
6877 
6878     my $i = 0;
6879     foreach (@{$keys}) {
6880         my $depth = 0;
6881         my $h = Hasher::GenerateHashValue($_) % $numEntries;
6882 
6883         while (defined($table[$h])) {
6884             if (defined($links[$h])) {
6885                 $h = $links[$h];
6886                 $depth++;
6887             } else {
6888                 $collisions++;
6889                 $links[$h] = $compactSize;
6890                 $h = $compactSize;
6891                 $compactSize++;
6892             }
6893         }
6894 
6895         $table[$h] = $i;
6896 
6897         $i++;
6898         $maxDepth = $depth if ($depth &gt; $maxDepth);
6899     }
6900 
6901     push(@implContent, &quot;\nstatic const struct CompactHashIndex ${nameIndex}\[$compactSize\] = {\n&quot;);
6902     for (my $i = 0; $i &lt; $compactSize; $i++) {
6903         my $T = -1;
6904         if (defined($table[$i])) { $T = $table[$i]; }
6905         my $L = -1;
6906         if (defined($links[$i])) { $L = $links[$i]; }
6907         push(@implContent, &quot;    { $T, $L },\n&quot;);
6908     }
6909     push(@implContent, &quot;};\n\n&quot;);
6910 
6911     # Dump the hash table
6912     my $hasSetter = GenerateHashTableValueArray($keys, $specials, $value1, $value2, $conditionals, $readWriteConditionals, $nameEntries);
6913     my $packedSize = scalar @{$keys};
6914 
6915     my $compactSizeMask = $numEntries - 1;
6916     push(@implContent, &quot;static const HashTable $name = { $packedSize, $compactSizeMask, $hasSetter, ${className}::info(), $nameEntries, $nameIndex };\n&quot;);
6917 }
6918 
6919 sub WriteData
6920 {
6921     my $object = shift;
6922     my $interface = shift;
6923     my $outputDir = shift;
6924 
6925     my $name = $interface-&gt;type-&gt;name;
6926     my $headerFileName = &quot;$outputDir/JS$name.h&quot;;
6927     my $implFileName = &quot;$outputDir/JS$name.cpp&quot;;
6928     my $depsFileName = &quot;$outputDir/JS$name.dep&quot;;
6929 
6930     # Update a .cpp file if the contents are changed.
6931     my $contents = join &quot;&quot;, @implContentHeader;
6932 
6933     my @includes = ();
6934     my %implIncludeConditions = ();
6935     foreach my $include (keys %implIncludes) {
6936         next if $headerIncludes{$include};
6937         next if $headerTrailingIncludes{$include};
6938 
6939         my $condition = $implIncludes{$include};
6940 
6941         my $checkType = $include;
6942         $checkType =~ s/\.h//;
6943         next if $codeGenerator-&gt;IsSVGAnimatedTypeName($checkType);
6944 
6945         $include = &quot;\&quot;$include\&quot;&quot; unless $include =~ /^[&quot;&lt;]/; # &quot;
6946 
6947         if ($condition eq 1) {
6948             push @includes, $include;
6949         } else {
6950             push @{$implIncludeConditions{$codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($condition)}}, $include;
6951         }
6952     }
6953     foreach my $include (sort @includes) {
6954         $contents .= &quot;#include $include\n&quot;;
6955     }
6956     foreach my $condition (sort keys %implIncludeConditions) {
6957         $contents .= &quot;\n#if &quot; . $condition . &quot;\n&quot;;
6958         foreach my $include (sort @{$implIncludeConditions{$condition}}) {
6959             $contents .= &quot;#include $include\n&quot;;
6960         }
6961         $contents .= &quot;#endif\n&quot;;
6962     }
6963 
6964     $contents .= join &quot;&quot;, @implContent;
6965     $codeGenerator-&gt;UpdateFile($implFileName, $contents);
6966 
6967     @implContentHeader = ();
6968     @implContent = ();
6969     %implIncludes = ();
6970 
6971     # Update a .h file if the contents are changed.
6972     $contents = join &quot;&quot;, @headerContentHeader;
6973 
6974     @includes = ();
6975     foreach my $include (keys %headerIncludes) {
6976         $include = &quot;\&quot;$include\&quot;&quot; unless $include =~ /^[&quot;&lt;]/; # &quot;
6977         push @includes, $include;
6978     }
6979     foreach my $include (sort @includes) {
6980         # &quot;JSClassName.h&quot; is already included right after config.h.
6981         next if $include eq &quot;\&quot;JS$name.h\&quot;&quot;;
6982         $contents .= &quot;#include $include\n&quot;;
6983     }
6984 
6985     $contents .= join &quot;&quot;, @headerContent;
6986 
6987     @includes = ();
6988     foreach my $include (keys %headerTrailingIncludes) {
6989         $include = &quot;\&quot;$include\&quot;&quot; unless $include =~ /^[&quot;&lt;]/; # &quot;
6990         push @includes, $include;
6991     }
6992     foreach my $include (sort @includes) {
6993         $contents .= &quot;#include $include\n&quot;;
6994     }
6995     $codeGenerator-&gt;UpdateFile($headerFileName, $contents);
6996 
6997     @headerContentHeader = ();
6998     @headerContent = ();
6999     %headerIncludes = ();
7000     %headerTrailingIncludes = ();
7001 
7002     if (@depsContent) {
7003         # Update a .dep file if the contents are changed.
7004         $contents = join &quot;&quot;, @depsContent;
7005         $codeGenerator-&gt;UpdateFile($depsFileName, $contents);
7006 
7007         @depsContent = ();
7008     }
7009 }
7010 
7011 sub GeneratePrototypeDeclaration
7012 {
7013     my ($outputArray, $className, $interface) = @_;
7014 
7015     my $prototypeClassName = &quot;${className}Prototype&quot;;
7016 
7017     my %structureFlags = ();
7018     push(@$outputArray, &quot;class ${prototypeClassName} : public JSC::JSNonFinalObject {\n&quot;);
7019     push(@$outputArray, &quot;public:\n&quot;);
7020     push(@$outputArray, &quot;    using Base = JSC::JSNonFinalObject;\n&quot;);
7021 
7022     push(@$outputArray, &quot;    static ${prototypeClassName}* create(JSC::VM&amp; vm, JSDOMGlobalObject* globalObject, JSC::Structure* structure)\n&quot;);
7023     push(@$outputArray, &quot;    {\n&quot;);
7024     push(@$outputArray, &quot;        ${className}Prototype* ptr = new (NotNull, JSC::allocateCell&lt;${className}Prototype&gt;(vm.heap)) ${className}Prototype(vm, globalObject, structure);\n&quot;);
7025     push(@$outputArray, &quot;        ptr-&gt;finishCreation(vm);\n&quot;);
7026     push(@$outputArray, &quot;        return ptr;\n&quot;);
7027     push(@$outputArray, &quot;    }\n\n&quot;);
7028 
7029     push(@$outputArray, &quot;    DECLARE_INFO;\n&quot;);
7030 
7031     push(@$outputArray, &quot;    static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)\n&quot;);
7032     push(@$outputArray, &quot;    {\n&quot;);
7033     push(@$outputArray, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());\n&quot;);
7034     push(@$outputArray, &quot;    }\n&quot;);
7035 
7036     push(@$outputArray, &quot;\nprivate:\n&quot;);
7037     push(@$outputArray, &quot;    ${prototypeClassName}(JSC::VM&amp; vm, JSC::JSGlobalObject*, JSC::Structure* structure)\n&quot;);
7038     push(@$outputArray, &quot;        : JSC::JSNonFinalObject(vm, structure)\n&quot;);
7039     push(@$outputArray, &quot;    {\n&quot;);
7040     push(@$outputArray, &quot;    }\n&quot;);
7041 
7042     if (PrototypeHasStaticPropertyTable($interface)) {
7043         if (IsGlobalOrPrimaryGlobalInterface($interface)) {
7044             $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1;
7045         } else {
7046             push(@$outputArray, &quot;\n&quot;);
7047             push(@$outputArray, &quot;    void finishCreation(JSC::VM&amp;);\n&quot;);
7048         }
7049     }
7050 
7051     # FIXME: Should this override putByIndex as well?
7052     if ($interface-&gt;extendedAttributes-&gt;{CustomPutOnPrototype}) {
7053         push(@$outputArray, &quot;\n&quot;);
7054         push(@$outputArray, &quot;    static bool put(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);
7055     }
7056 
7057     if ($interface-&gt;extendedAttributes-&gt;{CustomDefineOwnPropertyOnPrototype}) {
7058         push(@$outputArray, &quot;\n&quot;);
7059         push(@$outputArray, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);
7060     }
7061 
7062     $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObjectOnPrototype};
7063 
7064     # structure flags
7065     if (%structureFlags) {
7066         push(@$outputArray, &quot;public:\n&quot;);
7067         push(@$outputArray, &quot;    static const unsigned StructureFlags = Base::StructureFlags&quot;);
7068         foreach my $structureFlag (sort (keys %structureFlags)) {
7069             push(@$outputArray, &quot; | &quot; . $structureFlag);
7070         }
7071         push(@$outputArray, &quot;;\n&quot;);
7072     }
7073 
7074     push(@$outputArray, &quot;};\n\n&quot;);
7075 }
7076 
7077 sub GetConstructorTemplateClassName
7078 {
7079     my $interface = shift;
7080     return &quot;JSDOMConstructorNotConstructable&quot; if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7081     return &quot;JSDOMConstructorNotConstructable&quot; unless IsConstructable($interface);
7082     return &quot;JSDOMBuiltinConstructor&quot; if IsJSBuiltinConstructor($interface);
7083     return &quot;JSDOMConstructor&quot;;
7084 }
7085 
7086 sub GenerateConstructorDeclaration
7087 {
7088     my ($outputArray, $className, $interface) = @_;
7089 
7090     my $interfaceName = $interface-&gt;type-&gt;name;
7091     my $constructorClassName = &quot;${className}Constructor&quot;;
7092     my $templateClassName = GetConstructorTemplateClassName($interface);
7093 
7094     AddToImplIncludes(&quot;${templateClassName}.h&quot;);
7095     AddToImplIncludes(&quot;JSDOMNamedConstructor.h&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7096 
7097     push(@$outputArray, &quot;using $constructorClassName = $templateClassName&lt;$className&gt;;\n&quot;);
7098     push(@$outputArray, &quot;using JS${interfaceName}NamedConstructor = JSDOMNamedConstructor&lt;$className&gt;;\n&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7099     push(@$outputArray, &quot;\n&quot;);
7100 }
7101 
7102 sub GenerateConstructorDefinitions
7103 {
7104     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor) = @_;
7105 
7106     if (IsConstructable($interface)) {
7107         my @constructors = @{$interface-&gt;constructors};
7108         if (@constructors &gt; 1) {
7109             foreach my $constructor (@constructors) {
7110                 GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $constructor);
7111             }
7112 
7113             my $overloadFunctionPrefix = &quot;construct${className}&quot;;
7114 
7115             push(@implContent, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${className}Constructor::construct(ExecState* state)\n&quot;);
7116             push(@implContent, &quot;{\n&quot;);
7117             push(@implContent, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
7118             push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
7119             push(@implContent, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
7120 
7121             GenerateOverloadDispatcher(@{$interface-&gt;constructors}[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;state&quot;);
7122 
7123             push(@implContent, &quot;}\n\n&quot;);
7124         } elsif (@constructors == 1) {
7125             GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $constructors[0]);
7126         } else {
7127             GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor);
7128         }
7129     }
7130 
7131     GenerateConstructorHelperMethods($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor);
7132 }
7133 
7134 sub GenerateConstructorDefinition
7135 {
7136     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $operation) = @_;
7137 
7138     return if IsJSBuiltinConstructor($interface);
7139 
7140     my $interfaceName = $interface-&gt;type-&gt;name;
7141     my $constructorClassName = $generatingNamedConstructor ? &quot;${className}NamedConstructor&quot; : &quot;${className}Constructor&quot;;
7142 
7143     if (IsConstructable($interface)) {
7144         if ($interface-&gt;extendedAttributes-&gt;{CustomConstructor}) {
7145             push(@$outputArray, &quot;template&lt;&gt; JSC::EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(JSC::ExecState* exec)\n&quot;);
7146             push(@$outputArray, &quot;{\n&quot;);
7147             push(@$outputArray, &quot;    ASSERT(exec);\n&quot;);
7148             push(@$outputArray, &quot;    return construct${className}(*exec);\n&quot;);
7149             push(@$outputArray, &quot;}\n\n&quot;);
7150          } elsif (!HasCustomConstructor($interface) &amp;&amp; (!$interface-&gt;extendedAttributes-&gt;{NamedConstructor} || $generatingNamedConstructor)) {
7151             my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
7152             if ($isOverloaded) {
7153                 push(@$outputArray, &quot;static inline EncodedJSValue construct${className}$operation-&gt;{overloadIndex}(ExecState* state)\n&quot;);
7154             } else {
7155                 push(@$outputArray, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(ExecState* state)\n&quot;);
7156             }
7157 
7158             push(@$outputArray, &quot;{\n&quot;);
7159             push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
7160             push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
7161             push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
7162             push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${constructorClassName}*&gt;(state-&gt;jsCallee());\n&quot;);
7163             push(@$outputArray, &quot;    ASSERT(castedThis);\n&quot;);
7164 
7165             GenerateArgumentsCountCheck($outputArray, $operation, $interface, &quot;    &quot;);
7166 
7167             my $functionImplementationName = $generatingNamedConstructor ? &quot;createForJSConstructor&quot; : &quot;create&quot;;
7168             my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, &quot;    &quot;);
7169 
7170             push(@$outputArray, &quot;    auto object = ${functionString};\n&quot;);
7171             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;) if $codeGenerator-&gt;ExtendedAttributeContains($interface-&gt;extendedAttributes-&gt;{ConstructorCallWith}, &quot;ExecState&quot;);
7172 
7173             my $IDLType = GetIDLType($interface, $interface-&gt;type);
7174 
7175             AddToImplIncludes(&quot;JSDOMConvertInterface.h&quot;);
7176 
7177             my @constructionConversionArguments = ();
7178             push(@constructionConversionArguments, &quot;*state&quot;);
7179             push(@constructionConversionArguments, &quot;*castedThis-&gt;globalObject()&quot;);
7180             push(@constructionConversionArguments, &quot;throwScope&quot;) if $interface-&gt;extendedAttributes-&gt;{ConstructorMayThrowException};
7181             push(@constructionConversionArguments, &quot;WTFMove(object)&quot;);
7182 
7183             push(@$outputArray, &quot;    return JSValue::encode(toJSNewlyCreated&lt;${IDLType}&gt;(&quot; . join(&quot;, &quot;, @constructionConversionArguments) . &quot;));\n&quot;);
7184             push(@$outputArray, &quot;}\n\n&quot;);
7185         }
7186     }
7187 }
7188 
7189 sub ConstructorHasProperties
7190 {
7191     my $interface = shift;
7192 
7193     foreach my $constant (@{$interface-&gt;constants}) {
7194         return 1;
7195     }
7196 
7197     foreach my $attribute (@{$interface-&gt;attributes}) {
7198         next unless ($attribute-&gt;isStatic);
7199         return 1;
7200     }
7201 
7202     foreach my $operation (@{$interface-&gt;operations}) {
7203         next unless ($operation-&gt;isStatic);
7204         return 1;
7205     }
7206 
7207     return 0;
7208 }
7209 
7210 sub GetRuntimeEnabledStaticProperties
7211 {
7212     my ($interface) = @_;
7213 
7214     my @runtimeEnabledProperties = ();
7215 
7216     my @attributes = @{$interface-&gt;attributes};
7217     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
7218 
7219     foreach my $attribute (@attributes) {
7220         next if AttributeShouldBeOnInstance($interface, $attribute) != 0;
7221         next if not $attribute-&gt;isStatic;
7222 
7223         if (NeedsRuntimeCheck($interface, $attribute)) {
7224             push(@runtimeEnabledProperties, $attribute);
7225         }
7226     }
7227 
7228     my @operations = @{$interface-&gt;operations};
7229     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
7230     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
7231     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
7232     foreach my $operation (@operations) {
7233         next if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
7234         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
7235         next if OperationShouldBeOnInstance($interface, $operation) != 0;
7236         next if $operation-&gt;name eq &quot;[Symbol.Iterator]&quot;;
7237         next if not $operation-&gt;isStatic;
7238 
7239         if (NeedsRuntimeCheck($interface, $operation)) {
7240             push(@runtimeEnabledProperties, $operation);
7241         }
7242     }
7243 
7244     return @runtimeEnabledProperties;
7245 }
7246 
7247 sub GenerateConstructorHelperMethods
7248 {
7249     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor) = @_;
7250 
7251     my $constructorClassName = $generatingNamedConstructor ? &quot;${className}NamedConstructor&quot; : &quot;${className}Constructor&quot;;
7252     my $leastConstructorLength = 0;
7253     if ($interface-&gt;extendedAttributes-&gt;{Constructor} || $interface-&gt;extendedAttributes-&gt;{CustomConstructor}) {
7254         my @constructors = @{$interface-&gt;constructors};
7255         my @customConstructors = @{$interface-&gt;customConstructors};
7256         $leastConstructorLength = 255;
7257         foreach my $constructor (@constructors, @customConstructors) {
7258             my $constructorLength = GetFunctionLength($constructor);
7259             $leastConstructorLength = $constructorLength if ($constructorLength &lt; $leastConstructorLength);
7260         }
7261     } else {
7262         $leastConstructorLength = 0;
7263     }
7264 
7265     # If the interface has a parent interface which does not have [NoInterfaceObject], then use its interface object as prototype,
7266     # otherwise use FunctionPrototype: http://heycam.github.io/webidl/#interface-object
7267     push(@$outputArray, &quot;template&lt;&gt; JSValue ${constructorClassName}::prototypeForStructure(JSC::VM&amp; vm, const JSDOMGlobalObject&amp; globalObject)\n&quot;);
7268     push(@$outputArray, &quot;{\n&quot;);
7269 
7270     assert(&quot;An interface cannot inherit from another interface that is marked as [NoInterfaceObject]&quot;) if $interface-&gt;parentType &amp;&amp; $codeGenerator-&gt;GetInterfaceExtendedAttributesFromName($interface-&gt;parentType-&gt;name)-&gt;{NoInterfaceObject};
7271 
7272     if (!$generatingNamedConstructor and $interface-&gt;parentType) {
7273         my $parentClassName = &quot;JS&quot; . $interface-&gt;parentType-&gt;name;
7274         push(@$outputArray, &quot;    return ${parentClassName}::getConstructor(vm, &amp;globalObject);\n&quot;);
7275     } else {
7276         AddToImplIncludes(&quot;&lt;JavaScriptCore/FunctionPrototype.h&gt;&quot;);
7277         push(@$outputArray, &quot;    UNUSED_PARAM(vm);\n&quot;);
7278         push(@$outputArray, &quot;    return globalObject.functionPrototype();\n&quot;);
7279     }
7280     push(@$outputArray, &quot;}\n\n&quot;);
7281 
7282 
7283     push(@$outputArray, &quot;template&lt;&gt; void ${constructorClassName}::initializeProperties(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
7284     push(@$outputArray, &quot;{\n&quot;);
7285 
7286     # There must exist an interface prototype object for every non-callback interface defined, regardless
7287     # of whether the interface was declared with the [NoInterfaceObject] extended attribute.
7288     # https://heycam.github.io/webidl/#interface-prototype-object
7289     if (ShouldUseGlobalObjectPrototype($interface)) {
7290         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, globalObject.getPrototypeDirect(vm), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7291     } elsif ($interface-&gt;isCallback) {
7292         push(@$outputArray, &quot;    UNUSED_PARAM(globalObject);\n&quot;);
7293     } else {
7294         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, ${className}::prototype(vm, globalObject), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7295     }
7296 
7297     push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;name, jsNontrivialString(&amp;vm, String(\&quot;$visibleInterfaceName\&quot;_s)), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7298     push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;length, jsNumber(${leastConstructorLength}), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;) if defined $leastConstructorLength;
7299 
7300     my $classForThis = &quot;${className}::info()&quot;;
7301     if ($interface-&gt;isCallback) {
7302         $classForThis = &quot;nullptr&quot;;
7303     }
7304     push(@$outputArray, &quot;    reifyStaticProperties(vm, ${classForThis}, ${className}ConstructorTableValues, *this);\n&quot;) if ConstructorHasProperties($interface);
7305 
7306     my @runtimeEnabledProperties = GetRuntimeEnabledStaticProperties($interface);
7307 
7308     foreach my $operationOrAttribute (@runtimeEnabledProperties) {
7309         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
7310         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
7311         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute, &quot;true&quot;);
7312         my $name = $operationOrAttribute-&gt;name;
7313         push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
7314         push(@$outputArray, &quot;        auto propertyName = Identifier::fromString(&amp;vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);
7315         push(@$outputArray, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
7316         push(@$outputArray, &quot;        JSObject::deleteProperty(this, globalObject.globalExec(), propertyName);\n&quot;);
7317         push(@$outputArray, &quot;    }\n&quot;);
7318         push(@$outputArray, &quot;#endif\n&quot;) if $conditionalString;
7319     }
7320 
7321     push(@$outputArray, &quot;}\n\n&quot;);
7322 
7323     if (IsJSBuiltinConstructor($interface)) {
7324         push(@$outputArray, &quot;template&lt;&gt; FunctionExecutable* ${constructorClassName}::initializeExecutable(VM&amp; vm)\n&quot;);
7325         push(@$outputArray, &quot;{\n&quot;);
7326         push(@$outputArray, &quot;    return &quot; . GetJSBuiltinFunctionNameFromString($interface-&gt;type-&gt;name, &quot;initialize&quot; . $interface-&gt;type-&gt;name) . &quot;(vm);\n&quot;);
7327         push(@$outputArray, &quot;}\n&quot;);
7328         push(@$outputArray, &quot;\n&quot;);
7329     }
7330     push(@$outputArray, &quot;template&lt;&gt; const ClassInfo ${constructorClassName}::s_info = { \&quot;${visibleInterfaceName}\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE($constructorClassName) };\n\n&quot;);
7331 }
7332 
7333 sub HasCustomConstructor
7334 {
7335     my $interface = shift;
7336     return $interface-&gt;extendedAttributes-&gt;{CustomConstructor};
7337 }
7338 
7339 sub HasCustomGetter
7340 {
7341     my $attribute = shift;
7342     return $attribute-&gt;extendedAttributes-&gt;{Custom} || $attribute-&gt;extendedAttributes-&gt;{CustomGetter};
7343 }
7344 
7345 sub HasCustomSetter
7346 {
7347     my $attribute = shift;
7348     return $attribute-&gt;extendedAttributes-&gt;{Custom} || $attribute-&gt;extendedAttributes-&gt;{CustomSetter};
7349 }
7350 
7351 sub HasCustomMethod
7352 {
7353     my $operation = shift;
7354     return $operation-&gt;extendedAttributes-&gt;{Custom};
7355 }
7356 
7357 sub NeedsConstructorProperty
7358 {
7359     my $interface = shift;
7360     
7361     return !$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject};
7362 }
7363 
7364 sub IsConstructable
7365 {
7366     my $interface = shift;
7367     return HasCustomConstructor($interface)
7368         || $interface-&gt;extendedAttributes-&gt;{Constructor}
7369         || $interface-&gt;extendedAttributes-&gt;{NamedConstructor}
7370         || $interface-&gt;extendedAttributes-&gt;{JSBuiltinConstructor};
7371 }
7372 
7373 sub InstanceOverridesGetCallData
7374 {
7375     my $interface = shift;
7376     return $interface-&gt;{LegacyCallers} || $interface-&gt;extendedAttributes-&gt;{CustomGetCallData} || $interface-&gt;extendedAttributes-&gt;{Plugin};
7377 }
7378 
7379 sub HeaderNeedsPrototypeDeclaration
7380 {
7381     my $interface = shift;
7382     return IsDOMGlobalObject($interface)
7383         || $interface-&gt;extendedAttributes-&gt;{CustomPutOnPrototype}
7384         || $interface-&gt;extendedAttributes-&gt;{CustomDefineOwnPropertyOnPrototype};
7385 }
7386 
7387 sub IsUnforgeable
7388 {
7389     my ($interface, $property) = @_;
7390 
7391     return $property-&gt;extendedAttributes-&gt;{Unforgeable} || $interface-&gt;extendedAttributes-&gt;{Unforgeable};
7392 }
7393 
7394 sub ComputeFunctionSpecial
7395 {
7396     my ($interface, $operation) = @_;
7397 
7398     my @specials = ();
7399     push(@specials, (&quot;JSC::PropertyAttribute::DontDelete&quot;, &quot;JSC::PropertyAttribute::ReadOnly&quot;)) if IsUnforgeable($interface, $operation);
7400     push(@specials, &quot;JSC::PropertyAttribute::DontEnum&quot;) if $operation-&gt;extendedAttributes-&gt;{NotEnumerable};
7401     if (IsJSBuiltin($interface, $operation)) {
7402         push(@specials, &quot;JSC::PropertyAttribute::Builtin&quot;);
7403     } else {
7404         push(@specials, &quot;JSC::PropertyAttribute::Function&quot;);
7405     }
7406     if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
7407         push(@specials, &quot;JSC::PropertyAttribute::DOMJITFunction&quot;) if $operation-&gt;extendedAttributes-&gt;{DOMJIT};
7408     }
7409     return &quot;static_cast&lt;unsigned&gt;(&quot; . ((@specials &gt; 0) ? join(&quot; | &quot;, @specials) : &quot;0&quot;) . &quot;)&quot;;
7410 }
7411 
7412 sub IsJSBuiltin
7413 {
7414     my ($interface, $object) = @_;
7415 
7416     return 0 if $object-&gt;extendedAttributes-&gt;{Custom};
7417     return 0 if $object-&gt;extendedAttributes-&gt;{CustomGetter};
7418     return 0 if $object-&gt;extendedAttributes-&gt;{CustomSetter};
7419 
7420     return 1 if $object-&gt;extendedAttributes-&gt;{JSBuiltin};
7421     return 1 if $interface-&gt;extendedAttributes-&gt;{JSBuiltin};
7422 
7423     return 0;
7424 }
7425 
7426 sub IsJSBuiltinConstructor
7427 {
7428     my ($interface) = @_;
7429 
7430     return 0 if $interface-&gt;extendedAttributes-&gt;{CustomConstructor};
7431     return 1 if $interface-&gt;extendedAttributes-&gt;{JSBuiltin};
7432     return 1 if $interface-&gt;extendedAttributes-&gt;{JSBuiltinConstructor};
7433     return 0;
7434 }
7435 
7436 sub GetJSBuiltinFunctionName
7437 {
7438     my ($className, $operation) = @_;
7439 
7440     my $scopeName = $operation-&gt;extendedAttributes-&gt;{ImplementedBy};
7441     $scopeName = substr $className, 2 unless $scopeName;
7442     return GetJSBuiltinFunctionNameFromString($scopeName, $operation-&gt;name);
7443 }
7444 
7445 sub GetJSBuiltinFunctionNameFromString
7446 {
7447     my ($scopeName, $functionName) = @_;
7448 
7449     return $codeGenerator-&gt;WK_lcfirst($scopeName) . $codeGenerator-&gt;WK_ucfirst($functionName) . &quot;CodeGenerator&quot;;
7450 }
7451 
7452 sub GetJSBuiltinScopeName
7453 {
7454     my ($interface, $object) = @_;
7455     return $object-&gt;extendedAttributes-&gt;{ImplementedBy} || $interface-&gt;type-&gt;name;
7456 }
7457 
7458 sub AddJSBuiltinIncludesIfNeeded()
7459 {
7460     my $interface = shift;
7461 
7462     if ($interface-&gt;extendedAttributes-&gt;{JSBuiltin} || $interface-&gt;extendedAttributes-&gt;{JSBuiltinConstructor}) {
7463         AddToImplIncludes($interface-&gt;type-&gt;name . &quot;Builtins.h&quot;);
7464         return;
7465     }
7466 
7467     foreach my $operation (@{$interface-&gt;operations}) {
7468         AddToImplIncludes(GetJSBuiltinScopeName($interface, $operation) . &quot;Builtins.h&quot;, $operation-&gt;extendedAttributes-&gt;{Conditional}) if IsJSBuiltin($interface, $operation);
7469     }
7470 
7471     foreach my $attribute (@{$interface-&gt;attributes}) {
7472         AddToImplIncludes(GetJSBuiltinScopeName($interface, $attribute) . &quot;Builtins.h&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}) if IsJSBuiltin($interface, $attribute);
7473     }
7474 }
7475 
7476 sub GenerateCallTracerParameter()
7477 {
7478     my ($name, $type, $optional, $indent) = @_;
7479 
7480     my $result = &quot;&quot;;
7481 
7482     if ($optional || $type-&gt;isNullable) {
7483         $result .= $indent . &quot;    if (&quot; . $name . &quot;)\n&quot;;
7484         $result .= &quot;    &quot;;
7485     }
7486 
7487     $result .= $indent . &quot;    &quot;;
7488 
7489     if ($type-&gt;isUnion) {
7490         $result .= &quot;WTF::visit([&amp;] (auto&amp; value) { callTracerParameters.append(value); }, &quot;;
7491     } else {
7492         $result .= &quot;callTracerParameters.append(&quot;;
7493     }
7494 
7495     if ($optional || ($type-&gt;isUnion &amp;&amp; $type-&gt;isNullable)) {
7496         $result .= &quot;*&quot;;
7497     }
7498 
7499     $result .= $name . &quot;);&quot;;
7500 
7501     return $result;
7502 }
7503 
7504 sub GenerateCallTracer()
7505 {
7506     my ($outputArray, $callTracingCallback, $name, $arguments, $indent) = @_;
7507 
7508     AddToImplIncludes(&quot;CallTracer.h&quot;);
7509 
7510     my $count = scalar(@$arguments);
7511 
7512     push(@$outputArray, $indent . &quot;if (UNLIKELY(impl.callTracingActive()))&quot;);
7513     if ($count) {
7514         push(@$outputArray, &quot; {\n&quot;);
7515         push(@$outputArray, $indent . &quot;    Vector&lt;&quot; . $codeGenerator-&gt;WK_ucfirst($callTracingCallback) . &quot;Variant&gt; callTracerParameters;\n&quot;);
7516         push(@$outputArray, join(&quot;\n&quot;, @$arguments));
7517     }
7518     push(@$outputArray, &quot;\n&quot;);
7519     push(@$outputArray, $indent . &quot;    CallTracer::&quot; . $callTracingCallback . &quot;(impl, \&quot;&quot; . $name . &quot;\&quot;_s&quot;);
7520     if ($count) {
7521         push(@$outputArray, &quot;, WTFMove(callTracerParameters)&quot;);
7522     }
7523     push(@$outputArray, &quot;);\n&quot;);
7524     if ($count) {
7525         push(@$outputArray, $indent . &quot;}\n&quot;)
7526     }
7527 }
7528 
7529 sub GenerateCustomElementReactionsStackIfNeeded
7530 {
7531     my ($outputArray, $context, $stateVariable) = @_;
7532 
7533     my $CEReactions = $context-&gt;extendedAttributes-&gt;{CEReactions};
7534 
7535     return if !$CEReactions;
7536 
7537     AddToImplIncludes(&quot;CustomElementReactionQueue.h&quot;);
7538 
7539     if ($CEReactions eq &quot;NotNeeded&quot;) {
7540         push(@$outputArray, &quot;    CustomElementReactionDisallowedScope customElementReactionDisallowedScope;\n&quot;);
7541     } else {
7542         push(@$outputArray, &quot;    CustomElementReactionStack customElementReactionStack($stateVariable);\n&quot;);
7543     }
7544 }
7545 
7546 1;
    </pre>
  </body>
</html>