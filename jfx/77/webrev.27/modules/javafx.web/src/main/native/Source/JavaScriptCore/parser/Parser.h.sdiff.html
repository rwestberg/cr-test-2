<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Parser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ParserArena.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">   4  *  Copyright (C) 2003, 2006, 2007, 2008, 2009, 2010, 2011, 2013 Apple Inc. All rights reserved.</span>
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
</pre>
<hr />
<pre>
 100 typedef uint8_t DeclarationResultMask;
 101 
 102 enum class DeclarationDefaultContext {
 103     Standard,
 104     ExportDefault,
 105 };
 106 
 107 enum class InferName {
 108     Allowed,
 109     Disallowed,
 110 };
 111 
 112 template &lt;typename T&gt; inline bool isEvalNode() { return false; }
 113 template &lt;&gt; inline bool isEvalNode&lt;EvalNode&gt;() { return true; }
 114 
 115 struct ScopeLabelInfo {
 116     UniquedStringImpl* uid;
 117     bool isLoop;
 118 };
 119 
<span class="line-modified"> 120 ALWAYS_INLINE static bool isArguments(const VM* vm, const Identifier* ident)</span>
 121 {
<span class="line-modified"> 122     return vm-&gt;propertyNames-&gt;arguments == *ident;</span>
 123 }
<span class="line-modified"> 124 ALWAYS_INLINE static bool isEval(const VM* vm, const Identifier* ident)</span>
 125 {
<span class="line-modified"> 126     return vm-&gt;propertyNames-&gt;eval == *ident;</span>
 127 }
<span class="line-modified"> 128 ALWAYS_INLINE static bool isEvalOrArgumentsIdentifier(const VM* vm, const Identifier* ident)</span>
 129 {
 130     return isEval(vm, ident) || isArguments(vm, ident);
 131 }
 132 ALWAYS_INLINE static bool isIdentifierOrKeyword(const JSToken&amp; token)
 133 {
 134     return token.m_type == IDENT || token.m_type &amp; KeywordTokenFlag;
 135 }
 136 // _Any_ContextualKeyword includes keywords such as &quot;let&quot; or &quot;yield&quot;, which have a specific meaning depending on the current parse mode
 137 // or strict mode. These helpers allow to treat all contextual keywords as identifiers as required.
 138 ALWAYS_INLINE static bool isAnyContextualKeyword(const JSToken&amp; token)
 139 {
 140     return token.m_type &gt;= FirstContextualKeywordToken &amp;&amp; token.m_type &lt;= LastContextualKeywordToken;
 141 }
 142 ALWAYS_INLINE static bool isIdentifierOrAnyContextualKeyword(const JSToken&amp; token)
 143 {
 144     return token.m_type == IDENT || isAnyContextualKeyword(token);
 145 }
 146 // _Safe_ContextualKeyword includes only contextual keywords which can be treated as identifiers independently from parse mode. The exeption
 147 // to this rule is `await`, but matchSpecIdentifier() always treats it as an identifier regardless.
 148 ALWAYS_INLINE static bool isSafeContextualKeyword(const JSToken&amp; token)
 149 {
 150     return token.m_type &gt;= FirstSafeContextualKeywordToken &amp;&amp; token.m_type &lt;= LastSafeContextualKeywordToken;
 151 }
 152 


 153 struct Scope {
 154     WTF_MAKE_NONCOPYABLE(Scope);
 155 
 156 public:
<span class="line-modified"> 157     Scope(const VM* vm, bool isFunction, bool isGenerator, bool strictMode, bool isArrowFunction, bool isAsyncFunction)</span>
 158         : m_vm(vm)
 159         , m_shadowsArguments(false)
 160         , m_usesEval(false)
 161         , m_needsFullActivation(false)
 162         , m_hasDirectSuper(false)
 163         , m_needsSuperBinding(false)
 164         , m_allowsVarDeclarations(true)
 165         , m_allowsLexicalDeclarations(true)
 166         , m_strictMode(strictMode)
 167         , m_isFunction(isFunction)
 168         , m_isGenerator(isGenerator)
 169         , m_isGeneratorBoundary(false)
 170         , m_isArrowFunction(isArrowFunction)
 171         , m_isArrowFunctionBoundary(false)
 172         , m_isAsyncFunction(isAsyncFunction)
 173         , m_isAsyncFunctionBoundary(false)
 174         , m_isLexicalScope(false)
 175         , m_isGlobalCodeScope(false)
 176         , m_isSimpleCatchParameterScope(false)
 177         , m_isFunctionBoundary(false)
</pre>
<hr />
<pre>
 185         , m_loopDepth(0)
 186         , m_switchDepth(0)
 187         , m_innerArrowFunctionFeatures(0)
 188     {
 189         m_usedVariables.append(UniquedStringImplPtrSet());
 190     }
 191 
 192     Scope(Scope&amp;&amp;) = default;
 193 
 194     void startSwitch() { m_switchDepth++; }
 195     void endSwitch() { m_switchDepth--; }
 196     void startLoop() { m_loopDepth++; }
 197     void endLoop() { ASSERT(m_loopDepth); m_loopDepth--; }
 198     bool inLoop() { return !!m_loopDepth; }
 199     bool breakIsValid() { return m_loopDepth || m_switchDepth; }
 200     bool continueIsValid() { return m_loopDepth; }
 201 
 202     void pushLabel(const Identifier* label, bool isLoop)
 203     {
 204         if (!m_labels)
<span class="line-modified"> 205             m_labels = std::make_unique&lt;LabelStack&gt;();</span>
 206         m_labels-&gt;append(ScopeLabelInfo { label-&gt;impl(), isLoop });
 207     }
 208 
 209     void popLabel()
 210     {
 211         ASSERT(m_labels);
 212         ASSERT(m_labels-&gt;size());
 213         m_labels-&gt;removeLast();
 214     }
 215 
 216     ScopeLabelInfo* getLabel(const Identifier* label)
 217     {
 218         if (!m_labels)
 219             return 0;
 220         for (int i = m_labels-&gt;size(); i &gt; 0; i--) {
 221             if (m_labels-&gt;at(i - 1).uid == label-&gt;impl())
 222                 return &amp;m_labels-&gt;at(i - 1);
 223         }
 224         return 0;
 225     }
</pre>
<hr />
<pre>
 470     {
 471         return m_declaredParameters.contains(ident.get()) || hasDeclaredVariable(ident);
 472     }
 473 
 474     void preventAllVariableDeclarations()
 475     {
 476         m_allowsVarDeclarations = false;
 477         m_allowsLexicalDeclarations = false;
 478     }
 479     void preventVarDeclarations() { m_allowsVarDeclarations = false; }
 480     bool allowsVarDeclarations() const { return m_allowsVarDeclarations; }
 481     bool allowsLexicalDeclarations() const { return m_allowsLexicalDeclarations; }
 482 
 483     DeclarationResultMask declareParameter(const Identifier* ident)
 484     {
 485         ASSERT(m_allowsVarDeclarations);
 486         DeclarationResultMask result = DeclarationResult::Valid;
 487         bool isArgumentsIdent = isArguments(m_vm, ident);
 488         auto addResult = m_declaredVariables.add(ident-&gt;impl());
 489         bool isValidStrictMode = (addResult.isNewEntry || !addResult.iterator-&gt;value.isParameter())
<span class="line-modified"> 490             &amp;&amp; m_vm-&gt;propertyNames-&gt;eval != *ident &amp;&amp; !isArgumentsIdent;</span>
 491         addResult.iterator-&gt;value.clearIsVar();
 492         addResult.iterator-&gt;value.setIsParameter();
 493         m_isValidStrictMode = m_isValidStrictMode &amp;&amp; isValidStrictMode;
 494         m_declaredParameters.add(ident-&gt;impl());
 495         if (!isValidStrictMode)
 496             result |= DeclarationResult::InvalidStrictMode;
 497         if (isArgumentsIdent)
 498             m_shadowsArguments = true;
 499         if (!addResult.isNewEntry)
 500             result |= DeclarationResult::InvalidDuplicateDeclaration;
 501 
 502         return result;
 503     }
 504 
 505     bool usedVariablesContains(UniquedStringImpl* impl) const
 506     {
 507         for (const UniquedStringImplPtrSet&amp; set : m_usedVariables) {
 508             if (set.contains(impl))
 509                 return true;
 510         }
</pre>
<hr />
<pre>
 554     void setConstructorKind(ConstructorKind constructorKind) { m_constructorKind = static_cast&lt;unsigned&gt;(constructorKind); }
 555     ConstructorKind constructorKind() const { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
 556 
 557     void setInnerArrowFunctionUsesSuperCall() { m_innerArrowFunctionFeatures |= SuperCallInnerArrowFunctionFeature; }
 558     void setInnerArrowFunctionUsesSuperProperty() { m_innerArrowFunctionFeatures |= SuperPropertyInnerArrowFunctionFeature; }
 559     void setInnerArrowFunctionUsesEval() { m_innerArrowFunctionFeatures |= EvalInnerArrowFunctionFeature; }
 560     void setInnerArrowFunctionUsesThis() { m_innerArrowFunctionFeatures |= ThisInnerArrowFunctionFeature; }
 561     void setInnerArrowFunctionUsesNewTarget() { m_innerArrowFunctionFeatures |= NewTargetInnerArrowFunctionFeature; }
 562     void setInnerArrowFunctionUsesArguments() { m_innerArrowFunctionFeatures |= ArgumentsInnerArrowFunctionFeature; }
 563 
 564     bool isEvalContext() const { return m_isEvalContext; }
 565     void setIsEvalContext(bool isEvalContext) { m_isEvalContext = isEvalContext; }
 566 
 567     void setInnerArrowFunctionUsesEvalAndUseArgumentsIfNeeded()
 568     {
 569         ASSERT(m_isArrowFunction);
 570 
 571         if (m_usesEval)
 572             setInnerArrowFunctionUsesEval();
 573 
<span class="line-modified"> 574         if (usedVariablesContains(m_vm-&gt;propertyNames-&gt;arguments.impl()))</span>
 575             setInnerArrowFunctionUsesArguments();
 576     }
 577 
 578     void addClosedVariableCandidateUnconditionally(UniquedStringImpl* impl)
 579     {
 580         m_closedVariableCandidates.add(impl);
 581     }
 582 
 583     void collectFreeVariables(Scope* nestedScope, bool shouldTrackClosedVariables)
 584     {
 585         if (nestedScope-&gt;m_usesEval)
 586             m_usesEval = true;
 587 
 588         {
 589             UniquedStringImplPtrSet&amp; destinationSet = m_usedVariables.last();
 590             for (const UniquedStringImplPtrSet&amp; usedVariablesSet : nestedScope-&gt;m_usedVariables) {
 591                 for (UniquedStringImpl* impl : usedVariablesSet) {
 592                     if (nestedScope-&gt;m_declaredVariables.contains(impl) || nestedScope-&gt;m_lexicalVariables.contains(impl))
 593                         continue;
 594 
 595                     // &quot;arguments&quot; reference should be resolved at function boudary.
<span class="line-modified"> 596                     if (nestedScope-&gt;isFunctionBoundary() &amp;&amp; nestedScope-&gt;hasArguments() &amp;&amp; impl == m_vm-&gt;propertyNames-&gt;arguments.impl() &amp;&amp; !nestedScope-&gt;isArrowFunctionBoundary())</span>
 597                         continue;
 598 
 599                     destinationSet.add(impl);
 600                     // We don&#39;t want a declared variable that is used in an inner scope to be thought of as captured if
 601                     // that inner scope is both a lexical scope and not a function. Only inner functions and &quot;catch&quot;
 602                     // statements can cause variables to be captured.
 603                     if (shouldTrackClosedVariables &amp;&amp; (nestedScope-&gt;m_isFunctionBoundary || !nestedScope-&gt;m_isLexicalScope))
 604                         m_closedVariableCandidates.add(impl);
 605                 }
 606             }
 607         }
 608         // Propagate closed variable candidates downwards within the same function.
 609         // Cross function captures will be realized via m_usedVariables propagation.
 610         if (shouldTrackClosedVariables &amp;&amp; !nestedScope-&gt;m_isFunctionBoundary &amp;&amp; nestedScope-&gt;m_closedVariableCandidates.size()) {
 611             auto end = nestedScope-&gt;m_closedVariableCandidates.end();
 612             auto begin = nestedScope-&gt;m_closedVariableCandidates.begin();
 613             m_closedVariableCandidates.add(begin, end);
 614         }
 615     }
 616 
</pre>
<hr />
<pre>
 776         m_isAsyncFunction = true;
 777         m_isAsyncFunctionBoundary = true;
 778     }
 779 
 780     void setIsAsyncFunctionBody()
 781     {
 782         setIsFunction();
 783         m_hasArguments = false;
 784         m_isAsyncFunction = true;
 785         m_isAsyncFunctionBoundary = true;
 786     }
 787 
 788     void setIsAsyncArrowFunctionBody()
 789     {
 790         setIsArrowFunction();
 791         m_hasArguments = false;
 792         m_isAsyncFunction = true;
 793         m_isAsyncFunctionBoundary = true;
 794     }
 795 
<span class="line-modified"> 796     const VM* m_vm;</span>
 797     bool m_shadowsArguments;
 798     bool m_usesEval;
 799     bool m_needsFullActivation;
 800     bool m_hasDirectSuper;
 801     bool m_needsSuperBinding;
 802     bool m_allowsVarDeclarations;
 803     bool m_allowsLexicalDeclarations;
 804     bool m_strictMode;
 805     bool m_isFunction;
 806     bool m_isGenerator;
 807     bool m_isGeneratorBoundary;
 808     bool m_isArrowFunction;
 809     bool m_isArrowFunctionBoundary;
 810     bool m_isAsyncFunction;
 811     bool m_isAsyncFunctionBoundary;
 812     bool m_isLexicalScope;
 813     bool m_isGlobalCodeScope;
 814     bool m_isSimpleCatchParameterScope;
 815     bool m_isFunctionBoundary;
 816     bool m_isValidStrictMode;
</pre>
<hr />
<pre>
 866 
 867     bool operator!=(const ScopeRef&amp; other)
 868     {
 869         return !(*this == other);
 870     }
 871 
 872 private:
 873     ScopeStack* m_scopeStack;
 874     unsigned m_index;
 875 };
 876 
 877 enum class ArgumentType { Normal, Spread };
 878 enum class ParsingContext { Program, FunctionConstructor, Eval };
 879 
 880 template &lt;typename LexerType&gt;
 881 class Parser {
 882     WTF_MAKE_NONCOPYABLE(Parser);
 883     WTF_MAKE_FAST_ALLOCATED;
 884 
 885 public:
<span class="line-modified"> 886     Parser(VM*, const SourceCode&amp;, JSParserBuiltinMode, JSParserStrictMode, JSParserScriptMode, SourceParseMode, SuperBinding, ConstructorKind defaultConstructorKind = ConstructorKind::None, DerivedContextType = DerivedContextType::None, bool isEvalContext = false, EvalContextType = EvalContextType::None, DebuggerParseData* = nullptr);</span>
 887     ~Parser();
 888 
 889     template &lt;class ParsedNode&gt;
 890     std::unique_ptr&lt;ParsedNode&gt; parse(ParserError&amp;, const Identifier&amp;, SourceParseMode, ParsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
 891 
 892     JSTextPosition positionBeforeLastNewline() const { return m_lexer-&gt;positionBeforeLastNewline(); }
 893     JSTokenLocation locationBeforeLastToken() const { return m_lexer-&gt;lastTokenLocation(); }
 894 
 895     struct CallOrApplyDepthScope {
 896         CallOrApplyDepthScope(Parser* parser)
 897             : m_parser(parser)
 898             , m_parent(parser-&gt;m_callOrApplyDepthScope)
 899             , m_depth(m_parent ? m_parent-&gt;m_depth + 1 : 0)
 900             , m_depthOfInnermostChild(m_depth)
 901         {
 902             parser-&gt;m_callOrApplyDepthScope = this;
 903         }
 904 
 905         size_t distanceToInnermostChild() const
 906         {
</pre>
<hr />
<pre>
1648 
1649     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression createResolveAndUseVariable(TreeBuilder&amp;, const Identifier*, bool isEval, const JSTextPosition&amp;, const JSTokenLocation&amp;);
1650 
1651     enum class FunctionDefinitionType { Expression, Declaration, Method };
1652     template &lt;class TreeBuilder&gt; NEVER_INLINE bool parseFunctionInfo(TreeBuilder&amp;, FunctionNameRequirements, SourceParseMode, bool nameIsInContainingScope, ConstructorKind, SuperBinding, int functionKeywordStart, ParserFunctionInfo&lt;TreeBuilder&gt;&amp;, FunctionDefinitionType, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1653 
1654     ALWAYS_INLINE bool isArrowFunctionParameters();
1655 
1656     template &lt;class TreeBuilder, class FunctionInfoType&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList parseFunctionParameters(TreeBuilder&amp;, SourceParseMode, FunctionInfoType&amp;);
1657     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList createGeneratorParameters(TreeBuilder&amp;, unsigned&amp; parameterCount);
1658 
1659     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeClassExpression parseClass(TreeBuilder&amp;, FunctionNameRequirements, ParserClassInfo&lt;TreeBuilder&gt;&amp;);
1660 
1661     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::TemplateString parseTemplateString(TreeBuilder&amp; context, bool isTemplateHead, typename LexerType::RawStringsBuildMode, bool&amp; elementIsTail);
1662     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::TemplateLiteral parseTemplateLiteral(TreeBuilder&amp;, typename LexerType::RawStringsBuildMode);
1663 
1664     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool shouldCheckPropertyForUnderscoreProtoDuplicate(TreeBuilder&amp;, const TreeProperty&amp;);
1665 
1666     template &lt;class TreeBuilder&gt; NEVER_INLINE const char* metaPropertyName(TreeBuilder&amp;, TreeExpression);
1667 


1668     ALWAYS_INLINE int isBinaryOperator(JSTokenType);
1669     bool allowAutomaticSemicolon();
1670 
1671     bool autoSemiColon()
1672     {
1673         if (m_token.m_type == SEMICOLON) {
1674             next();
1675             return true;
1676         }
1677         return allowAutomaticSemicolon();
1678     }
1679 
1680     bool canRecurse()
1681     {
<span class="line-modified">1682         return m_vm-&gt;isSafeToRecurse();</span>
1683     }
1684 
1685     const JSTextPosition&amp; lastTokenEndPosition() const
1686     {
1687         return m_lastTokenEndPosition;
1688     }
1689 
1690     bool hasError() const
1691     {
1692         return !m_errorMessage.isNull();
1693     }
1694 
1695     bool isDisallowedIdentifierLet(const JSToken&amp; token)
1696     {
1697         return token.m_type == LET &amp;&amp; strictMode();
1698     }
1699 
1700     bool isDisallowedIdentifierAwait(const JSToken&amp; token)
1701     {
1702         return token.m_type == AWAIT &amp;&amp; (!m_parserState.allowAwait || currentScope()-&gt;isAsyncFunctionBoundary() || m_scriptMode == JSParserScriptMode::Module);
</pre>
<hr />
<pre>
1845     ALWAYS_INLINE void internalRestoreState(const SavePoint&amp; savePoint)
1846     {
1847         restoreLexerState(savePoint.lexerState);
1848         restoreParserState(savePoint.parserState);
1849     }
1850 
1851     ALWAYS_INLINE void restoreSavePointWithError(const SavePointWithError&amp; savePoint)
1852     {
1853         internalRestoreState(savePoint);
1854         m_lexer-&gt;setSawError(savePoint.lexerError);
1855         m_lexer-&gt;setErrorMessage(savePoint.lexerErrorMessage);
1856         m_errorMessage = savePoint.parserErrorMessage;
1857     }
1858 
1859     ALWAYS_INLINE void restoreSavePoint(const SavePoint&amp; savePoint)
1860     {
1861         internalRestoreState(savePoint);
1862         m_errorMessage = String();
1863     }
1864 
<span class="line-modified">1865     VM* m_vm;</span>
1866     const SourceCode* m_source;
1867     ParserArena m_parserArena;
1868     std::unique_ptr&lt;LexerType&gt; m_lexer;
1869     FunctionParameters* m_parameters { nullptr };
1870 
1871     ParserState m_parserState;
1872 
1873     bool m_hasStackOverflow;
1874     String m_errorMessage;
1875     JSToken m_token;
1876     bool m_allowsIn;
1877     JSTextPosition m_lastTokenEndPosition;
1878     int m_statementDepth;
1879     RefPtr&lt;SourceProviderCache&gt; m_functionCache;
1880     SourceElements* m_sourceElements;
1881     bool m_parsingBuiltin;
1882     JSParserScriptMode m_scriptMode;
1883     SuperBinding m_superBinding;
1884     ConstructorKind m_defaultConstructorKind;
1885     VariableEnvironment m_varDeclarations;
</pre>
<hr />
<pre>
1920 
1921     int lineNumber = m_lexer-&gt;lineNumber();
1922     bool lexError = m_lexer-&gt;sawError();
1923     String lexErrorMessage = lexError ? m_lexer-&gt;getErrorMessage() : String();
1924     ASSERT(lexErrorMessage.isNull() != lexError);
1925     m_lexer-&gt;clear();
1926 
1927     if (!parseError.isNull() || lexError) {
1928         errLine = lineNumber;
1929         errMsg = !lexErrorMessage.isNull() ? lexErrorMessage : parseError;
1930         m_sourceElements = 0;
1931     }
1932 
1933     std::unique_ptr&lt;ParsedNode&gt; result;
1934     if (m_sourceElements) {
1935         JSTokenLocation endLocation;
1936         endLocation.line = m_lexer-&gt;lineNumber();
1937         endLocation.lineStartOffset = m_lexer-&gt;currentLineStartOffset();
1938         endLocation.startOffset = m_lexer-&gt;currentOffset();
1939         unsigned endColumn = endLocation.startOffset - endLocation.lineStartOffset;
<span class="line-modified">1940         result = std::make_unique&lt;ParsedNode&gt;(m_parserArena,</span>
1941                                     startLocation,
1942                                     endLocation,
1943                                     startColumn,
1944                                     endColumn,
1945                                     m_sourceElements,
1946                                     m_varDeclarations,
1947                                     WTFMove(m_funcDeclarations),
1948                                     currentScope()-&gt;finalizeLexicalEnvironment(),
1949                                     WTFMove(m_sloppyModeHoistedFunctions),
1950                                     m_parameters,
1951                                     *m_source,
1952                                     m_features,
1953                                     currentScope()-&gt;innerArrowFunctionFeatures(),
1954                                     m_numConstants,
1955                                     WTFMove(m_moduleScopeData));
1956         result-&gt;setLoc(m_source-&gt;firstLine().oneBasedInt(), m_lexer-&gt;lineNumber(), m_lexer-&gt;currentOffset(), m_lexer-&gt;currentLineStartOffset());
1957         result-&gt;setEndOffset(m_lexer-&gt;currentOffset());
1958 
1959         if (!isFunctionParseMode(parseMode)) {
1960             m_source-&gt;provider()-&gt;setSourceURLDirective(m_lexer-&gt;sourceURLDirective());
</pre>
<hr />
<pre>
1976             else if (m_token.m_type &amp; UnterminatedErrorTokenFlag) {
1977                 // Treat multiline capable unterminated literals as recoverable.
1978                 if (m_token.m_type == UNTERMINATED_MULTILINE_COMMENT_ERRORTOK || m_token.m_type == UNTERMINATED_TEMPLATE_LITERAL_ERRORTOK)
1979                     errorType = ParserError::SyntaxErrorRecoverable;
1980                 else
1981                     errorType = ParserError::SyntaxErrorUnterminatedLiteral;
1982             }
1983 
1984             if (isEvalNode&lt;ParsedNode&gt;())
1985                 error = ParserError(ParserError::EvalError, errorType, m_token, errMsg, errLine);
1986             else
1987                 error = ParserError(ParserError::SyntaxError, errorType, m_token, errMsg, errLine);
1988         }
1989     }
1990 
1991     return result;
1992 }
1993 
1994 template &lt;class ParsedNode&gt;
1995 std::unique_ptr&lt;ParsedNode&gt; parse(
<span class="line-modified">1996     VM* vm, const SourceCode&amp; source,</span>
1997     const Identifier&amp; name, JSParserBuiltinMode builtinMode,
1998     JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding,
1999     ParserError&amp; error, JSTextPosition* positionBeforeLastNewline = nullptr,
2000     ConstructorKind defaultConstructorKind = ConstructorKind::None,
2001     DerivedContextType derivedContextType = DerivedContextType::None,
2002     EvalContextType evalContextType = EvalContextType::None,
2003     DebuggerParseData* debuggerParseData = nullptr)
2004 {
2005     ASSERT(!source.provider()-&gt;source().isNull());
2006 
2007     MonotonicTime before;
2008     if (UNLIKELY(Options::reportParseTimes()))
2009         before = MonotonicTime::now();
2010 
2011     std::unique_ptr&lt;ParsedNode&gt; result;
2012     if (source.provider()-&gt;source().is8Bit()) {
2013         Parser&lt;Lexer&lt;LChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKind, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);
2014         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program);
2015         if (positionBeforeLastNewline)
2016             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2017         if (builtinMode == JSParserBuiltinMode::Builtin) {
2018             if (!result) {
2019                 ASSERT(error.isValid());
2020                 if (error.type() != ParserError::StackOverflow)
2021                     dataLogLn(&quot;Unexpected error compiling builtin: &quot;, error.message());
2022             }
2023         }
2024     } else {
2025         ASSERT_WITH_MESSAGE(defaultConstructorKind == ConstructorKind::None, &quot;BuiltinExecutables::createDefaultConstructor should always use a 8-bit string&quot;);
2026         Parser&lt;Lexer&lt;UChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKind, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);
2027         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program);
2028         if (positionBeforeLastNewline)
2029             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2030     }
2031 



2032     if (UNLIKELY(Options::reportParseTimes())) {
2033         MonotonicTime after = MonotonicTime::now();
2034         ParseHash hash(source);
2035         dataLogLn(result ? &quot;Parsed #&quot; : &quot;Failed to parse #&quot;, hash.hashForCall(), &quot;/#&quot;, hash.hashForConstruct(), &quot; in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
2036     }
2037 
2038     return result;
2039 }
2040 
2041 inline std::unique_ptr&lt;ProgramNode&gt; parseFunctionForFunctionConstructor(VM&amp; vm, const SourceCode&amp; source, ParserError&amp; error, JSTextPosition* positionBeforeLastNewline, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2042 {
2043     ASSERT(!source.provider()-&gt;source().isNull());
2044 
2045     MonotonicTime before;
2046     if (UNLIKELY(Options::reportParseTimes()))
2047         before = MonotonicTime::now();
2048 
2049     Identifier name;
2050     bool isEvalNode = false;
2051     std::unique_ptr&lt;ProgramNode&gt; result;
2052     if (source.provider()-&gt;source().is8Bit()) {
<span class="line-modified">2053         Parser&lt;Lexer&lt;LChar&gt;&gt; parser(&amp;vm, source, JSParserBuiltinMode::NotBuiltin, JSParserStrictMode::NotStrict, JSParserScriptMode::Classic, SourceParseMode::ProgramMode, SuperBinding::NotNeeded, ConstructorKind::None, DerivedContextType::None, isEvalNode, EvalContextType::None, nullptr);</span>
2054         result = parser.parse&lt;ProgramNode&gt;(error, name, SourceParseMode::ProgramMode, ParsingContext::FunctionConstructor, functionConstructorParametersEndPosition);
2055         if (positionBeforeLastNewline)
2056             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2057     } else {
<span class="line-modified">2058         Parser&lt;Lexer&lt;UChar&gt;&gt; parser(&amp;vm, source, JSParserBuiltinMode::NotBuiltin, JSParserStrictMode::NotStrict, JSParserScriptMode::Classic, SourceParseMode::ProgramMode, SuperBinding::NotNeeded, ConstructorKind::None, DerivedContextType::None, isEvalNode, EvalContextType::None, nullptr);</span>
2059         result = parser.parse&lt;ProgramNode&gt;(error, name, SourceParseMode::ProgramMode, ParsingContext::FunctionConstructor, functionConstructorParametersEndPosition);
2060         if (positionBeforeLastNewline)
2061             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2062     }
2063 



2064     if (UNLIKELY(Options::reportParseTimes())) {
2065         MonotonicTime after = MonotonicTime::now();
2066         ParseHash hash(source);
2067         dataLogLn(result ? &quot;Parsed #&quot; : &quot;Failed to parse #&quot;, hash.hashForCall(), &quot;/#&quot;, hash.hashForConstruct(), &quot; in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
2068     }
2069 
2070     return result;
2071 }
2072 
2073 
2074 } // namespace
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
</pre>
<hr />
<pre>
 100 typedef uint8_t DeclarationResultMask;
 101 
 102 enum class DeclarationDefaultContext {
 103     Standard,
 104     ExportDefault,
 105 };
 106 
 107 enum class InferName {
 108     Allowed,
 109     Disallowed,
 110 };
 111 
 112 template &lt;typename T&gt; inline bool isEvalNode() { return false; }
 113 template &lt;&gt; inline bool isEvalNode&lt;EvalNode&gt;() { return true; }
 114 
 115 struct ScopeLabelInfo {
 116     UniquedStringImpl* uid;
 117     bool isLoop;
 118 };
 119 
<span class="line-modified"> 120 ALWAYS_INLINE static bool isArguments(const VM&amp; vm, const Identifier* ident)</span>
 121 {
<span class="line-modified"> 122     return vm.propertyNames-&gt;arguments == *ident;</span>
 123 }
<span class="line-modified"> 124 ALWAYS_INLINE static bool isEval(const VM&amp; vm, const Identifier* ident)</span>
 125 {
<span class="line-modified"> 126     return vm.propertyNames-&gt;eval == *ident;</span>
 127 }
<span class="line-modified"> 128 ALWAYS_INLINE static bool isEvalOrArgumentsIdentifier(const VM&amp; vm, const Identifier* ident)</span>
 129 {
 130     return isEval(vm, ident) || isArguments(vm, ident);
 131 }
 132 ALWAYS_INLINE static bool isIdentifierOrKeyword(const JSToken&amp; token)
 133 {
 134     return token.m_type == IDENT || token.m_type &amp; KeywordTokenFlag;
 135 }
 136 // _Any_ContextualKeyword includes keywords such as &quot;let&quot; or &quot;yield&quot;, which have a specific meaning depending on the current parse mode
 137 // or strict mode. These helpers allow to treat all contextual keywords as identifiers as required.
 138 ALWAYS_INLINE static bool isAnyContextualKeyword(const JSToken&amp; token)
 139 {
 140     return token.m_type &gt;= FirstContextualKeywordToken &amp;&amp; token.m_type &lt;= LastContextualKeywordToken;
 141 }
 142 ALWAYS_INLINE static bool isIdentifierOrAnyContextualKeyword(const JSToken&amp; token)
 143 {
 144     return token.m_type == IDENT || isAnyContextualKeyword(token);
 145 }
 146 // _Safe_ContextualKeyword includes only contextual keywords which can be treated as identifiers independently from parse mode. The exeption
 147 // to this rule is `await`, but matchSpecIdentifier() always treats it as an identifier regardless.
 148 ALWAYS_INLINE static bool isSafeContextualKeyword(const JSToken&amp; token)
 149 {
 150     return token.m_type &gt;= FirstSafeContextualKeywordToken &amp;&amp; token.m_type &lt;= LastSafeContextualKeywordToken;
 151 }
 152 
<span class="line-added"> 153 JS_EXPORT_PRIVATE extern std::atomic&lt;unsigned&gt; globalParseCount;</span>
<span class="line-added"> 154 </span>
 155 struct Scope {
 156     WTF_MAKE_NONCOPYABLE(Scope);
 157 
 158 public:
<span class="line-modified"> 159     Scope(const VM&amp; vm, bool isFunction, bool isGenerator, bool strictMode, bool isArrowFunction, bool isAsyncFunction)</span>
 160         : m_vm(vm)
 161         , m_shadowsArguments(false)
 162         , m_usesEval(false)
 163         , m_needsFullActivation(false)
 164         , m_hasDirectSuper(false)
 165         , m_needsSuperBinding(false)
 166         , m_allowsVarDeclarations(true)
 167         , m_allowsLexicalDeclarations(true)
 168         , m_strictMode(strictMode)
 169         , m_isFunction(isFunction)
 170         , m_isGenerator(isGenerator)
 171         , m_isGeneratorBoundary(false)
 172         , m_isArrowFunction(isArrowFunction)
 173         , m_isArrowFunctionBoundary(false)
 174         , m_isAsyncFunction(isAsyncFunction)
 175         , m_isAsyncFunctionBoundary(false)
 176         , m_isLexicalScope(false)
 177         , m_isGlobalCodeScope(false)
 178         , m_isSimpleCatchParameterScope(false)
 179         , m_isFunctionBoundary(false)
</pre>
<hr />
<pre>
 187         , m_loopDepth(0)
 188         , m_switchDepth(0)
 189         , m_innerArrowFunctionFeatures(0)
 190     {
 191         m_usedVariables.append(UniquedStringImplPtrSet());
 192     }
 193 
 194     Scope(Scope&amp;&amp;) = default;
 195 
 196     void startSwitch() { m_switchDepth++; }
 197     void endSwitch() { m_switchDepth--; }
 198     void startLoop() { m_loopDepth++; }
 199     void endLoop() { ASSERT(m_loopDepth); m_loopDepth--; }
 200     bool inLoop() { return !!m_loopDepth; }
 201     bool breakIsValid() { return m_loopDepth || m_switchDepth; }
 202     bool continueIsValid() { return m_loopDepth; }
 203 
 204     void pushLabel(const Identifier* label, bool isLoop)
 205     {
 206         if (!m_labels)
<span class="line-modified"> 207             m_labels = makeUnique&lt;LabelStack&gt;();</span>
 208         m_labels-&gt;append(ScopeLabelInfo { label-&gt;impl(), isLoop });
 209     }
 210 
 211     void popLabel()
 212     {
 213         ASSERT(m_labels);
 214         ASSERT(m_labels-&gt;size());
 215         m_labels-&gt;removeLast();
 216     }
 217 
 218     ScopeLabelInfo* getLabel(const Identifier* label)
 219     {
 220         if (!m_labels)
 221             return 0;
 222         for (int i = m_labels-&gt;size(); i &gt; 0; i--) {
 223             if (m_labels-&gt;at(i - 1).uid == label-&gt;impl())
 224                 return &amp;m_labels-&gt;at(i - 1);
 225         }
 226         return 0;
 227     }
</pre>
<hr />
<pre>
 472     {
 473         return m_declaredParameters.contains(ident.get()) || hasDeclaredVariable(ident);
 474     }
 475 
 476     void preventAllVariableDeclarations()
 477     {
 478         m_allowsVarDeclarations = false;
 479         m_allowsLexicalDeclarations = false;
 480     }
 481     void preventVarDeclarations() { m_allowsVarDeclarations = false; }
 482     bool allowsVarDeclarations() const { return m_allowsVarDeclarations; }
 483     bool allowsLexicalDeclarations() const { return m_allowsLexicalDeclarations; }
 484 
 485     DeclarationResultMask declareParameter(const Identifier* ident)
 486     {
 487         ASSERT(m_allowsVarDeclarations);
 488         DeclarationResultMask result = DeclarationResult::Valid;
 489         bool isArgumentsIdent = isArguments(m_vm, ident);
 490         auto addResult = m_declaredVariables.add(ident-&gt;impl());
 491         bool isValidStrictMode = (addResult.isNewEntry || !addResult.iterator-&gt;value.isParameter())
<span class="line-modified"> 492             &amp;&amp; m_vm.propertyNames-&gt;eval != *ident &amp;&amp; !isArgumentsIdent;</span>
 493         addResult.iterator-&gt;value.clearIsVar();
 494         addResult.iterator-&gt;value.setIsParameter();
 495         m_isValidStrictMode = m_isValidStrictMode &amp;&amp; isValidStrictMode;
 496         m_declaredParameters.add(ident-&gt;impl());
 497         if (!isValidStrictMode)
 498             result |= DeclarationResult::InvalidStrictMode;
 499         if (isArgumentsIdent)
 500             m_shadowsArguments = true;
 501         if (!addResult.isNewEntry)
 502             result |= DeclarationResult::InvalidDuplicateDeclaration;
 503 
 504         return result;
 505     }
 506 
 507     bool usedVariablesContains(UniquedStringImpl* impl) const
 508     {
 509         for (const UniquedStringImplPtrSet&amp; set : m_usedVariables) {
 510             if (set.contains(impl))
 511                 return true;
 512         }
</pre>
<hr />
<pre>
 556     void setConstructorKind(ConstructorKind constructorKind) { m_constructorKind = static_cast&lt;unsigned&gt;(constructorKind); }
 557     ConstructorKind constructorKind() const { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
 558 
 559     void setInnerArrowFunctionUsesSuperCall() { m_innerArrowFunctionFeatures |= SuperCallInnerArrowFunctionFeature; }
 560     void setInnerArrowFunctionUsesSuperProperty() { m_innerArrowFunctionFeatures |= SuperPropertyInnerArrowFunctionFeature; }
 561     void setInnerArrowFunctionUsesEval() { m_innerArrowFunctionFeatures |= EvalInnerArrowFunctionFeature; }
 562     void setInnerArrowFunctionUsesThis() { m_innerArrowFunctionFeatures |= ThisInnerArrowFunctionFeature; }
 563     void setInnerArrowFunctionUsesNewTarget() { m_innerArrowFunctionFeatures |= NewTargetInnerArrowFunctionFeature; }
 564     void setInnerArrowFunctionUsesArguments() { m_innerArrowFunctionFeatures |= ArgumentsInnerArrowFunctionFeature; }
 565 
 566     bool isEvalContext() const { return m_isEvalContext; }
 567     void setIsEvalContext(bool isEvalContext) { m_isEvalContext = isEvalContext; }
 568 
 569     void setInnerArrowFunctionUsesEvalAndUseArgumentsIfNeeded()
 570     {
 571         ASSERT(m_isArrowFunction);
 572 
 573         if (m_usesEval)
 574             setInnerArrowFunctionUsesEval();
 575 
<span class="line-modified"> 576         if (usedVariablesContains(m_vm.propertyNames-&gt;arguments.impl()))</span>
 577             setInnerArrowFunctionUsesArguments();
 578     }
 579 
 580     void addClosedVariableCandidateUnconditionally(UniquedStringImpl* impl)
 581     {
 582         m_closedVariableCandidates.add(impl);
 583     }
 584 
 585     void collectFreeVariables(Scope* nestedScope, bool shouldTrackClosedVariables)
 586     {
 587         if (nestedScope-&gt;m_usesEval)
 588             m_usesEval = true;
 589 
 590         {
 591             UniquedStringImplPtrSet&amp; destinationSet = m_usedVariables.last();
 592             for (const UniquedStringImplPtrSet&amp; usedVariablesSet : nestedScope-&gt;m_usedVariables) {
 593                 for (UniquedStringImpl* impl : usedVariablesSet) {
 594                     if (nestedScope-&gt;m_declaredVariables.contains(impl) || nestedScope-&gt;m_lexicalVariables.contains(impl))
 595                         continue;
 596 
 597                     // &quot;arguments&quot; reference should be resolved at function boudary.
<span class="line-modified"> 598                     if (nestedScope-&gt;isFunctionBoundary() &amp;&amp; nestedScope-&gt;hasArguments() &amp;&amp; impl == m_vm.propertyNames-&gt;arguments.impl() &amp;&amp; !nestedScope-&gt;isArrowFunctionBoundary())</span>
 599                         continue;
 600 
 601                     destinationSet.add(impl);
 602                     // We don&#39;t want a declared variable that is used in an inner scope to be thought of as captured if
 603                     // that inner scope is both a lexical scope and not a function. Only inner functions and &quot;catch&quot;
 604                     // statements can cause variables to be captured.
 605                     if (shouldTrackClosedVariables &amp;&amp; (nestedScope-&gt;m_isFunctionBoundary || !nestedScope-&gt;m_isLexicalScope))
 606                         m_closedVariableCandidates.add(impl);
 607                 }
 608             }
 609         }
 610         // Propagate closed variable candidates downwards within the same function.
 611         // Cross function captures will be realized via m_usedVariables propagation.
 612         if (shouldTrackClosedVariables &amp;&amp; !nestedScope-&gt;m_isFunctionBoundary &amp;&amp; nestedScope-&gt;m_closedVariableCandidates.size()) {
 613             auto end = nestedScope-&gt;m_closedVariableCandidates.end();
 614             auto begin = nestedScope-&gt;m_closedVariableCandidates.begin();
 615             m_closedVariableCandidates.add(begin, end);
 616         }
 617     }
 618 
</pre>
<hr />
<pre>
 778         m_isAsyncFunction = true;
 779         m_isAsyncFunctionBoundary = true;
 780     }
 781 
 782     void setIsAsyncFunctionBody()
 783     {
 784         setIsFunction();
 785         m_hasArguments = false;
 786         m_isAsyncFunction = true;
 787         m_isAsyncFunctionBoundary = true;
 788     }
 789 
 790     void setIsAsyncArrowFunctionBody()
 791     {
 792         setIsArrowFunction();
 793         m_hasArguments = false;
 794         m_isAsyncFunction = true;
 795         m_isAsyncFunctionBoundary = true;
 796     }
 797 
<span class="line-modified"> 798     const VM&amp; m_vm;</span>
 799     bool m_shadowsArguments;
 800     bool m_usesEval;
 801     bool m_needsFullActivation;
 802     bool m_hasDirectSuper;
 803     bool m_needsSuperBinding;
 804     bool m_allowsVarDeclarations;
 805     bool m_allowsLexicalDeclarations;
 806     bool m_strictMode;
 807     bool m_isFunction;
 808     bool m_isGenerator;
 809     bool m_isGeneratorBoundary;
 810     bool m_isArrowFunction;
 811     bool m_isArrowFunctionBoundary;
 812     bool m_isAsyncFunction;
 813     bool m_isAsyncFunctionBoundary;
 814     bool m_isLexicalScope;
 815     bool m_isGlobalCodeScope;
 816     bool m_isSimpleCatchParameterScope;
 817     bool m_isFunctionBoundary;
 818     bool m_isValidStrictMode;
</pre>
<hr />
<pre>
 868 
 869     bool operator!=(const ScopeRef&amp; other)
 870     {
 871         return !(*this == other);
 872     }
 873 
 874 private:
 875     ScopeStack* m_scopeStack;
 876     unsigned m_index;
 877 };
 878 
 879 enum class ArgumentType { Normal, Spread };
 880 enum class ParsingContext { Program, FunctionConstructor, Eval };
 881 
 882 template &lt;typename LexerType&gt;
 883 class Parser {
 884     WTF_MAKE_NONCOPYABLE(Parser);
 885     WTF_MAKE_FAST_ALLOCATED;
 886 
 887 public:
<span class="line-modified"> 888     Parser(VM&amp;, const SourceCode&amp;, JSParserBuiltinMode, JSParserStrictMode, JSParserScriptMode, SourceParseMode, SuperBinding, ConstructorKind defaultConstructorKind = ConstructorKind::None, DerivedContextType = DerivedContextType::None, bool isEvalContext = false, EvalContextType = EvalContextType::None, DebuggerParseData* = nullptr);</span>
 889     ~Parser();
 890 
 891     template &lt;class ParsedNode&gt;
 892     std::unique_ptr&lt;ParsedNode&gt; parse(ParserError&amp;, const Identifier&amp;, SourceParseMode, ParsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
 893 
 894     JSTextPosition positionBeforeLastNewline() const { return m_lexer-&gt;positionBeforeLastNewline(); }
 895     JSTokenLocation locationBeforeLastToken() const { return m_lexer-&gt;lastTokenLocation(); }
 896 
 897     struct CallOrApplyDepthScope {
 898         CallOrApplyDepthScope(Parser* parser)
 899             : m_parser(parser)
 900             , m_parent(parser-&gt;m_callOrApplyDepthScope)
 901             , m_depth(m_parent ? m_parent-&gt;m_depth + 1 : 0)
 902             , m_depthOfInnermostChild(m_depth)
 903         {
 904             parser-&gt;m_callOrApplyDepthScope = this;
 905         }
 906 
 907         size_t distanceToInnermostChild() const
 908         {
</pre>
<hr />
<pre>
1650 
1651     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression createResolveAndUseVariable(TreeBuilder&amp;, const Identifier*, bool isEval, const JSTextPosition&amp;, const JSTokenLocation&amp;);
1652 
1653     enum class FunctionDefinitionType { Expression, Declaration, Method };
1654     template &lt;class TreeBuilder&gt; NEVER_INLINE bool parseFunctionInfo(TreeBuilder&amp;, FunctionNameRequirements, SourceParseMode, bool nameIsInContainingScope, ConstructorKind, SuperBinding, int functionKeywordStart, ParserFunctionInfo&lt;TreeBuilder&gt;&amp;, FunctionDefinitionType, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1655 
1656     ALWAYS_INLINE bool isArrowFunctionParameters();
1657 
1658     template &lt;class TreeBuilder, class FunctionInfoType&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList parseFunctionParameters(TreeBuilder&amp;, SourceParseMode, FunctionInfoType&amp;);
1659     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList createGeneratorParameters(TreeBuilder&amp;, unsigned&amp; parameterCount);
1660 
1661     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeClassExpression parseClass(TreeBuilder&amp;, FunctionNameRequirements, ParserClassInfo&lt;TreeBuilder&gt;&amp;);
1662 
1663     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::TemplateString parseTemplateString(TreeBuilder&amp; context, bool isTemplateHead, typename LexerType::RawStringsBuildMode, bool&amp; elementIsTail);
1664     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::TemplateLiteral parseTemplateLiteral(TreeBuilder&amp;, typename LexerType::RawStringsBuildMode);
1665 
1666     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool shouldCheckPropertyForUnderscoreProtoDuplicate(TreeBuilder&amp;, const TreeProperty&amp;);
1667 
1668     template &lt;class TreeBuilder&gt; NEVER_INLINE const char* metaPropertyName(TreeBuilder&amp;, TreeExpression);
1669 
<span class="line-added">1670     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool isSimpleAssignmentTarget(TreeBuilder&amp;, TreeExpression);</span>
<span class="line-added">1671 </span>
1672     ALWAYS_INLINE int isBinaryOperator(JSTokenType);
1673     bool allowAutomaticSemicolon();
1674 
1675     bool autoSemiColon()
1676     {
1677         if (m_token.m_type == SEMICOLON) {
1678             next();
1679             return true;
1680         }
1681         return allowAutomaticSemicolon();
1682     }
1683 
1684     bool canRecurse()
1685     {
<span class="line-modified">1686         return m_vm.isSafeToRecurse();</span>
1687     }
1688 
1689     const JSTextPosition&amp; lastTokenEndPosition() const
1690     {
1691         return m_lastTokenEndPosition;
1692     }
1693 
1694     bool hasError() const
1695     {
1696         return !m_errorMessage.isNull();
1697     }
1698 
1699     bool isDisallowedIdentifierLet(const JSToken&amp; token)
1700     {
1701         return token.m_type == LET &amp;&amp; strictMode();
1702     }
1703 
1704     bool isDisallowedIdentifierAwait(const JSToken&amp; token)
1705     {
1706         return token.m_type == AWAIT &amp;&amp; (!m_parserState.allowAwait || currentScope()-&gt;isAsyncFunctionBoundary() || m_scriptMode == JSParserScriptMode::Module);
</pre>
<hr />
<pre>
1849     ALWAYS_INLINE void internalRestoreState(const SavePoint&amp; savePoint)
1850     {
1851         restoreLexerState(savePoint.lexerState);
1852         restoreParserState(savePoint.parserState);
1853     }
1854 
1855     ALWAYS_INLINE void restoreSavePointWithError(const SavePointWithError&amp; savePoint)
1856     {
1857         internalRestoreState(savePoint);
1858         m_lexer-&gt;setSawError(savePoint.lexerError);
1859         m_lexer-&gt;setErrorMessage(savePoint.lexerErrorMessage);
1860         m_errorMessage = savePoint.parserErrorMessage;
1861     }
1862 
1863     ALWAYS_INLINE void restoreSavePoint(const SavePoint&amp; savePoint)
1864     {
1865         internalRestoreState(savePoint);
1866         m_errorMessage = String();
1867     }
1868 
<span class="line-modified">1869     VM&amp; m_vm;</span>
1870     const SourceCode* m_source;
1871     ParserArena m_parserArena;
1872     std::unique_ptr&lt;LexerType&gt; m_lexer;
1873     FunctionParameters* m_parameters { nullptr };
1874 
1875     ParserState m_parserState;
1876 
1877     bool m_hasStackOverflow;
1878     String m_errorMessage;
1879     JSToken m_token;
1880     bool m_allowsIn;
1881     JSTextPosition m_lastTokenEndPosition;
1882     int m_statementDepth;
1883     RefPtr&lt;SourceProviderCache&gt; m_functionCache;
1884     SourceElements* m_sourceElements;
1885     bool m_parsingBuiltin;
1886     JSParserScriptMode m_scriptMode;
1887     SuperBinding m_superBinding;
1888     ConstructorKind m_defaultConstructorKind;
1889     VariableEnvironment m_varDeclarations;
</pre>
<hr />
<pre>
1924 
1925     int lineNumber = m_lexer-&gt;lineNumber();
1926     bool lexError = m_lexer-&gt;sawError();
1927     String lexErrorMessage = lexError ? m_lexer-&gt;getErrorMessage() : String();
1928     ASSERT(lexErrorMessage.isNull() != lexError);
1929     m_lexer-&gt;clear();
1930 
1931     if (!parseError.isNull() || lexError) {
1932         errLine = lineNumber;
1933         errMsg = !lexErrorMessage.isNull() ? lexErrorMessage : parseError;
1934         m_sourceElements = 0;
1935     }
1936 
1937     std::unique_ptr&lt;ParsedNode&gt; result;
1938     if (m_sourceElements) {
1939         JSTokenLocation endLocation;
1940         endLocation.line = m_lexer-&gt;lineNumber();
1941         endLocation.lineStartOffset = m_lexer-&gt;currentLineStartOffset();
1942         endLocation.startOffset = m_lexer-&gt;currentOffset();
1943         unsigned endColumn = endLocation.startOffset - endLocation.lineStartOffset;
<span class="line-modified">1944         result = makeUnique&lt;ParsedNode&gt;(m_parserArena,</span>
1945                                     startLocation,
1946                                     endLocation,
1947                                     startColumn,
1948                                     endColumn,
1949                                     m_sourceElements,
1950                                     m_varDeclarations,
1951                                     WTFMove(m_funcDeclarations),
1952                                     currentScope()-&gt;finalizeLexicalEnvironment(),
1953                                     WTFMove(m_sloppyModeHoistedFunctions),
1954                                     m_parameters,
1955                                     *m_source,
1956                                     m_features,
1957                                     currentScope()-&gt;innerArrowFunctionFeatures(),
1958                                     m_numConstants,
1959                                     WTFMove(m_moduleScopeData));
1960         result-&gt;setLoc(m_source-&gt;firstLine().oneBasedInt(), m_lexer-&gt;lineNumber(), m_lexer-&gt;currentOffset(), m_lexer-&gt;currentLineStartOffset());
1961         result-&gt;setEndOffset(m_lexer-&gt;currentOffset());
1962 
1963         if (!isFunctionParseMode(parseMode)) {
1964             m_source-&gt;provider()-&gt;setSourceURLDirective(m_lexer-&gt;sourceURLDirective());
</pre>
<hr />
<pre>
1980             else if (m_token.m_type &amp; UnterminatedErrorTokenFlag) {
1981                 // Treat multiline capable unterminated literals as recoverable.
1982                 if (m_token.m_type == UNTERMINATED_MULTILINE_COMMENT_ERRORTOK || m_token.m_type == UNTERMINATED_TEMPLATE_LITERAL_ERRORTOK)
1983                     errorType = ParserError::SyntaxErrorRecoverable;
1984                 else
1985                     errorType = ParserError::SyntaxErrorUnterminatedLiteral;
1986             }
1987 
1988             if (isEvalNode&lt;ParsedNode&gt;())
1989                 error = ParserError(ParserError::EvalError, errorType, m_token, errMsg, errLine);
1990             else
1991                 error = ParserError(ParserError::SyntaxError, errorType, m_token, errMsg, errLine);
1992         }
1993     }
1994 
1995     return result;
1996 }
1997 
1998 template &lt;class ParsedNode&gt;
1999 std::unique_ptr&lt;ParsedNode&gt; parse(
<span class="line-modified">2000     VM&amp; vm, const SourceCode&amp; source,</span>
2001     const Identifier&amp; name, JSParserBuiltinMode builtinMode,
2002     JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding,
2003     ParserError&amp; error, JSTextPosition* positionBeforeLastNewline = nullptr,
2004     ConstructorKind defaultConstructorKind = ConstructorKind::None,
2005     DerivedContextType derivedContextType = DerivedContextType::None,
2006     EvalContextType evalContextType = EvalContextType::None,
2007     DebuggerParseData* debuggerParseData = nullptr)
2008 {
2009     ASSERT(!source.provider()-&gt;source().isNull());
2010 
2011     MonotonicTime before;
2012     if (UNLIKELY(Options::reportParseTimes()))
2013         before = MonotonicTime::now();
2014 
2015     std::unique_ptr&lt;ParsedNode&gt; result;
2016     if (source.provider()-&gt;source().is8Bit()) {
2017         Parser&lt;Lexer&lt;LChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKind, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);
2018         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program);
2019         if (positionBeforeLastNewline)
2020             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2021         if (builtinMode == JSParserBuiltinMode::Builtin) {
2022             if (!result) {
2023                 ASSERT(error.isValid());
2024                 if (error.type() != ParserError::StackOverflow)
2025                     dataLogLn(&quot;Unexpected error compiling builtin: &quot;, error.message());
2026             }
2027         }
2028     } else {
2029         ASSERT_WITH_MESSAGE(defaultConstructorKind == ConstructorKind::None, &quot;BuiltinExecutables::createDefaultConstructor should always use a 8-bit string&quot;);
2030         Parser&lt;Lexer&lt;UChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKind, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);
2031         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program);
2032         if (positionBeforeLastNewline)
2033             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2034     }
2035 
<span class="line-added">2036     if (UNLIKELY(Options::countParseTimes()))</span>
<span class="line-added">2037         globalParseCount++;</span>
<span class="line-added">2038 </span>
2039     if (UNLIKELY(Options::reportParseTimes())) {
2040         MonotonicTime after = MonotonicTime::now();
2041         ParseHash hash(source);
2042         dataLogLn(result ? &quot;Parsed #&quot; : &quot;Failed to parse #&quot;, hash.hashForCall(), &quot;/#&quot;, hash.hashForConstruct(), &quot; in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
2043     }
2044 
2045     return result;
2046 }
2047 
2048 inline std::unique_ptr&lt;ProgramNode&gt; parseFunctionForFunctionConstructor(VM&amp; vm, const SourceCode&amp; source, ParserError&amp; error, JSTextPosition* positionBeforeLastNewline, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2049 {
2050     ASSERT(!source.provider()-&gt;source().isNull());
2051 
2052     MonotonicTime before;
2053     if (UNLIKELY(Options::reportParseTimes()))
2054         before = MonotonicTime::now();
2055 
2056     Identifier name;
2057     bool isEvalNode = false;
2058     std::unique_ptr&lt;ProgramNode&gt; result;
2059     if (source.provider()-&gt;source().is8Bit()) {
<span class="line-modified">2060         Parser&lt;Lexer&lt;LChar&gt;&gt; parser(vm, source, JSParserBuiltinMode::NotBuiltin, JSParserStrictMode::NotStrict, JSParserScriptMode::Classic, SourceParseMode::ProgramMode, SuperBinding::NotNeeded, ConstructorKind::None, DerivedContextType::None, isEvalNode, EvalContextType::None, nullptr);</span>
2061         result = parser.parse&lt;ProgramNode&gt;(error, name, SourceParseMode::ProgramMode, ParsingContext::FunctionConstructor, functionConstructorParametersEndPosition);
2062         if (positionBeforeLastNewline)
2063             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2064     } else {
<span class="line-modified">2065         Parser&lt;Lexer&lt;UChar&gt;&gt; parser(vm, source, JSParserBuiltinMode::NotBuiltin, JSParserStrictMode::NotStrict, JSParserScriptMode::Classic, SourceParseMode::ProgramMode, SuperBinding::NotNeeded, ConstructorKind::None, DerivedContextType::None, isEvalNode, EvalContextType::None, nullptr);</span>
2066         result = parser.parse&lt;ProgramNode&gt;(error, name, SourceParseMode::ProgramMode, ParsingContext::FunctionConstructor, functionConstructorParametersEndPosition);
2067         if (positionBeforeLastNewline)
2068             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2069     }
2070 
<span class="line-added">2071     if (UNLIKELY(Options::countParseTimes()))</span>
<span class="line-added">2072         globalParseCount++;</span>
<span class="line-added">2073 </span>
2074     if (UNLIKELY(Options::reportParseTimes())) {
2075         MonotonicTime after = MonotonicTime::now();
2076         ParseHash hash(source);
2077         dataLogLn(result ? &quot;Parsed #&quot; : &quot;Failed to parse #&quot;, hash.hashForCall(), &quot;/#&quot;, hash.hashForConstruct(), &quot; in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
2078     }
2079 
2080     return result;
2081 }
2082 
2083 
2084 } // namespace
</pre>
</td>
</tr>
</table>
<center><a href="Parser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ParserArena.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>