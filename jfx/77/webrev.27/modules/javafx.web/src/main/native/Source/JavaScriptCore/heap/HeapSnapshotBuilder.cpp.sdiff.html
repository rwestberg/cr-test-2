<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapSnapshotBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HeapSnapshot.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HeapSnapshotBuilder.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapSnapshotBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2016 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 29 #include &quot;DeferGC.h&quot;
 30 #include &quot;Heap.h&quot;
 31 #include &quot;HeapProfiler.h&quot;
 32 #include &quot;HeapSnapshot.h&quot;
 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;JSCast.h&quot;
 35 #include &quot;PreventCollectionScope.h&quot;
 36 #include &quot;VM.h&quot;
 37 #include &lt;wtf/HexNumber.h&gt;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 
 40 namespace JSC {
 41 
 42 static const char* rootTypeToString(SlotVisitor::RootMarkReason);
 43 
 44 NodeIdentifier HeapSnapshotBuilder::nextAvailableObjectIdentifier = 1;
 45 NodeIdentifier HeapSnapshotBuilder::getNextObjectIdentifier() { return nextAvailableObjectIdentifier++; }
 46 void HeapSnapshotBuilder::resetNextAvailableObjectIdentifier() { HeapSnapshotBuilder::nextAvailableObjectIdentifier = 1; }
 47 
 48 HeapSnapshotBuilder::HeapSnapshotBuilder(HeapProfiler&amp; profiler, SnapshotType type)
<span class="line-modified"> 49     : m_profiler(profiler)</span>

 50     , m_snapshotType(type)
 51 {
 52 }
 53 
 54 HeapSnapshotBuilder::~HeapSnapshotBuilder()
 55 {
 56     if (m_snapshotType == SnapshotType::GCDebuggingSnapshot)
 57         m_profiler.clearSnapshots();
 58 }
 59 
 60 void HeapSnapshotBuilder::buildSnapshot()
 61 {
 62     // GCDebuggingSnapshot are always full snapshots, so clear any existing snapshots.
 63     if (m_snapshotType == SnapshotType::GCDebuggingSnapshot)
 64         m_profiler.clearSnapshots();
 65 
 66     PreventCollectionScope preventCollectionScope(m_profiler.vm().heap);
 67 
<span class="line-modified"> 68     m_snapshot = std::make_unique&lt;HeapSnapshot&gt;(m_profiler.mostRecentSnapshot());</span>
 69     {
<span class="line-modified"> 70         m_profiler.setActiveSnapshotBuilder(this);</span>

 71         m_profiler.vm().heap.collectNow(Sync, CollectionScope::Full);
<span class="line-modified"> 72         m_profiler.setActiveSnapshotBuilder(nullptr);</span>
 73     }
 74     m_snapshot-&gt;finalize();
 75 
 76     m_profiler.appendSnapshot(WTFMove(m_snapshot));
 77 }
 78 
<span class="line-modified"> 79 void HeapSnapshotBuilder::appendNode(JSCell* cell)</span>
 80 {
<span class="line-modified"> 81     ASSERT(m_profiler.activeSnapshotBuilder() == this);</span>
 82 
<span class="line-modified"> 83     ASSERT(Heap::isMarked(cell));</span>
 84 
 85     NodeIdentifier identifier;
 86     if (previousSnapshotHasNodeForCell(cell, identifier))
 87         return;
 88 
 89     std::lock_guard&lt;Lock&gt; lock(m_buildingNodeMutex);
 90     m_snapshot-&gt;appendNode(HeapSnapshotNode(cell, getNextObjectIdentifier()));
 91 }
 92 
<span class="line-modified"> 93 void HeapSnapshotBuilder::appendEdge(JSCell* from, JSCell* to, SlotVisitor::RootMarkReason rootMarkReason)</span>
 94 {
<span class="line-modified"> 95     ASSERT(m_profiler.activeSnapshotBuilder() == this);</span>
 96     ASSERT(to);
 97 
 98     // Avoid trivial edges.
 99     if (from == to)
100         return;
101 
102     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
103 
104     if (m_snapshotType == SnapshotType::GCDebuggingSnapshot &amp;&amp; !from) {
105         if (rootMarkReason == SlotVisitor::RootMarkReason::None &amp;&amp; m_snapshotType == SnapshotType::GCDebuggingSnapshot)
106             WTFLogAlways(&quot;Cell %p is a root but no root marking reason was supplied&quot;, to);
107 
108         m_rootData.ensure(to, [] () -&gt; RootData {
109             return { };
110         }).iterator-&gt;value.markReason = rootMarkReason;
111     }
112 
113     m_edges.append(HeapSnapshotEdge(from, to));
114 }
115 
<span class="line-modified">116 void HeapSnapshotBuilder::appendPropertyNameEdge(JSCell* from, JSCell* to, UniquedStringImpl* propertyName)</span>
117 {
<span class="line-modified">118     ASSERT(m_profiler.activeSnapshotBuilder() == this);</span>
119     ASSERT(to);
120 
121     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
122 
123     m_edges.append(HeapSnapshotEdge(from, to, EdgeType::Property, propertyName));
124 }
125 
<span class="line-modified">126 void HeapSnapshotBuilder::appendVariableNameEdge(JSCell* from, JSCell* to, UniquedStringImpl* variableName)</span>
127 {
<span class="line-modified">128     ASSERT(m_profiler.activeSnapshotBuilder() == this);</span>
129     ASSERT(to);
130 
131     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
132 
133     m_edges.append(HeapSnapshotEdge(from, to, EdgeType::Variable, variableName));
134 }
135 
<span class="line-modified">136 void HeapSnapshotBuilder::appendIndexEdge(JSCell* from, JSCell* to, uint32_t index)</span>
137 {
<span class="line-modified">138     ASSERT(m_profiler.activeSnapshotBuilder() == this);</span>
139     ASSERT(to);
140 
141     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
142 
143     m_edges.append(HeapSnapshotEdge(from, to, index));
144 }
145 
146 void HeapSnapshotBuilder::setOpaqueRootReachabilityReasonForCell(JSCell* cell, const char* reason)
147 {
148     if (!reason || !*reason || m_snapshotType != SnapshotType::GCDebuggingSnapshot)
149         return;
150 
151     m_rootData.ensure(cell, [] () -&gt; RootData {
152         return { };
153     }).iterator-&gt;value.reachabilityFromOpaqueRootReasons = reason;
154 }
155 
156 void HeapSnapshotBuilder::setWrappedObjectForCell(JSCell* cell, void* wrappedPtr)
157 {
158     m_wrappedObjectPointers.set(cell, wrappedPtr);
</pre>
<hr />
<pre>
160 
161 bool HeapSnapshotBuilder::previousSnapshotHasNodeForCell(JSCell* cell, NodeIdentifier&amp; identifier)
162 {
163     if (!m_snapshot-&gt;previous())
164         return false;
165 
166     auto existingNode = m_snapshot-&gt;previous()-&gt;nodeForCell(cell);
167     if (existingNode) {
168         identifier = existingNode.value().identifier;
169         return true;
170     }
171 
172     return false;
173 }
174 
175 // Heap Snapshot JSON Format:
176 //
177 //  Inspector snapshots:
178 //
179 //   {
<span class="line-modified">180 //      &quot;version&quot;: 1.0,</span>
181 //      &quot;type&quot;: &quot;Inspector&quot;,
<span class="line-modified">182 //      // [&lt;address&gt;, &lt;labelIndex&gt;, &lt;wrappedEddress&gt;] only present in GCDebuggingSnapshot-type snapshots</span>
183 //      &quot;nodes&quot;: [
<span class="line-modified">184 //          &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;internal&gt;</span>
<span class="line-modified">185 //          &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;internal&gt;</span>
186 //          ...
187 //      ],
188 //      &quot;nodeClassNames&quot;: [
189 //          &quot;string&quot;, &quot;Structure&quot;, &quot;Object&quot;, ...
190 //      ],
191 //      &quot;edges&quot;: [
192 //          &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;,
193 //          &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;,
194 //          ...
195 //      ],
196 //      &quot;edgeTypes&quot;: [
197 //          &quot;Internal&quot;, &quot;Property&quot;, &quot;Index&quot;, &quot;Variable&quot;
198 //      ],
199 //      &quot;edgeNames&quot;: [
200 //          &quot;propertyName&quot;, &quot;variableName&quot;, ...
201 //      ]
202 //   }
203 //
204 //  GC heap debugger snapshots:
205 //
206 //   {
<span class="line-modified">207 //      &quot;version&quot;: 1.0,</span>
208 //      &quot;type&quot;: &quot;GCDebugging&quot;,
209 //      &quot;nodes&quot;: [
<span class="line-modified">210 //          &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;internal&gt;, &lt;labelIndex&gt;, &lt;cellEddress&gt;, &lt;wrappedEddress&gt;,</span>
<span class="line-modified">211 //          &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;internal&gt;, &lt;labelIndex&gt;, &lt;cellEddress&gt;, &lt;wrappedEddress&gt;,</span>
212 //          ...
213 //      ],
214 //      &quot;nodeClassNames&quot;: [
215 //          &quot;string&quot;, &quot;Structure&quot;, &quot;Object&quot;, ...
216 //      ],
217 //      &quot;edges&quot;: [
218 //          &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;,
219 //          &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;,
220 //          ...
221 //      ],
222 //      &quot;edgeTypes&quot;: [
223 //          &quot;Internal&quot;, &quot;Property&quot;, &quot;Index&quot;, &quot;Variable&quot;
224 //      ],
225 //      &quot;edgeNames&quot;: [
226 //          &quot;propertyName&quot;, &quot;variableName&quot;, ...
227 //      ],
228 //      &quot;roots&quot; : [
229 //          &lt;nodeId&gt;, &lt;rootReasonIndex&gt;, &lt;reachabilityReasonIndex&gt;,
230 //          &lt;nodeId&gt;, &lt;rootReasonIndex&gt;, &lt;reachabilityReasonIndex&gt;,
231 //          ... // &lt;nodeId&gt; may be repeated
232 //      ],
233 //      &quot;labels&quot; : [
234 //          &quot;foo&quot;, &quot;bar&quot;, ...
235 //      ]
236 //   }
237 //
238 // Notes:
239 //
240 //     &lt;nodeClassNameIndex&gt;
241 //       - index into the &quot;nodeClassNames&quot; list.
242 //
<span class="line-modified">243 //     &lt;internal&gt;</span>
<span class="line-modified">244 //       - 0 = false, 1 = true.</span>


245 //
246 //     &lt;edgeTypeIndex&gt;
247 //       - index into the &quot;edgeTypes&quot; list.
248 //
249 //     &lt;edgeExtraData&gt;
250 //       - for Internal edges this should be ignored (0).
251 //       - for Index edges this is the index value.
252 //       - for Property or Variable edges this is an index into the &quot;edgeNames&quot; list.
253 //
254 //      &lt;rootReasonIndex&gt;
255 //       - index into the &quot;labels&quot; list.
256 





257 static uint8_t edgeTypeToNumber(EdgeType type)
258 {
259     return static_cast&lt;uint8_t&gt;(type);
260 }
261 
262 static const char* edgeTypeToString(EdgeType type)
263 {
264     switch (type) {
265     case EdgeType::Internal:
266         return &quot;Internal&quot;;
267     case EdgeType::Property:
268         return &quot;Property&quot;;
269     case EdgeType::Index:
270         return &quot;Index&quot;;
271     case EdgeType::Variable:
272         return &quot;Variable&quot;;
273     }
274     ASSERT_NOT_REACHED();
275     return &quot;Internal&quot;;
276 }
</pre>
<hr />
<pre>
341     VM&amp; vm = m_profiler.vm();
342     Structure* structure = cell-&gt;structure(vm);
343 
344     if (structure-&gt;classInfo()-&gt;isSubClassOf(Structure::info())) {
345         Structure* cellAsStructure = jsCast&lt;Structure*&gt;(cell);
346         return cellAsStructure-&gt;classInfo()-&gt;className;
347     }
348 
349     return emptyString();
350 }
351 
352 String HeapSnapshotBuilder::json(Function&lt;bool (const HeapSnapshotNode&amp;)&gt; allowNodeCallback)
353 {
354     VM&amp; vm = m_profiler.vm();
355     DeferGCForAWhile deferGC(vm.heap);
356 
357     // Build a node to identifier map of allowed nodes to use when serializing edges.
358     HashMap&lt;JSCell*, NodeIdentifier&gt; allowedNodeIdentifiers;
359 
360     // Build a list of used class names.
<span class="line-modified">361     HashMap&lt;const char*, unsigned&gt; classNameIndexes;</span>
<span class="line-modified">362     classNameIndexes.set(&quot;&lt;root&gt;&quot;, 0);</span>
363     unsigned nextClassNameIndex = 1;
364 
365     // Build a list of labels (this is just a string table).
366     HashMap&lt;String, unsigned&gt; labelIndexes;
367     labelIndexes.set(emptyString(), 0);
368     unsigned nextLabelIndex = 1;
369 
370     // Build a list of used edge names.
371     HashMap&lt;UniquedStringImpl*, unsigned&gt; edgeNameIndexes;
372     unsigned nextEdgeNameIndex = 0;
373 
374     StringBuilder json;
375 
376     auto appendNodeJSON = [&amp;] (const HeapSnapshotNode&amp; node) {
377         // Let the client decide if they want to allow or disallow certain nodes.
378         if (!allowNodeCallback(node))
379             return;
380 


381         allowedNodeIdentifiers.set(node.cell, node.identifier);
382 
<span class="line-modified">383         auto result = classNameIndexes.add(node.cell-&gt;classInfo(vm)-&gt;className, nextClassNameIndex);</span>
















384         if (result.isNewEntry)
385             nextClassNameIndex++;
386         unsigned classNameIndex = result.iterator-&gt;value;
387 
<span class="line-removed">388         bool isInternal = false;</span>
389         void* wrappedAddress = 0;
390         unsigned labelIndex = 0;
<span class="line-modified">391         if (!node.cell-&gt;isString()) {</span>
392             Structure* structure = node.cell-&gt;structure(vm);
<span class="line-modified">393             isInternal = !structure || !structure-&gt;globalObject();</span>

394 
395             if (m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
396                 String nodeLabel;
397                 auto it = m_cellLabels.find(node.cell);
398                 if (it != m_cellLabels.end())
399                     nodeLabel = it-&gt;value;
400 
401                 if (nodeLabel.isEmpty()) {
402                     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, node.cell)) {
403                         if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(vm, object))
404                             nodeLabel = function-&gt;calculatedDisplayName(vm);
405                     }
406                 }
407 
408                 String description = descriptionForCell(node.cell);
409                 if (description.length()) {
410                     if (nodeLabel.length())
411                         nodeLabel.append(&#39; &#39;);
412                     nodeLabel.append(description);
413                 }
414 
415                 if (!nodeLabel.isEmpty() &amp;&amp; m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
416                     auto result = labelIndexes.add(nodeLabel, nextLabelIndex);
417                     if (result.isNewEntry)
418                         nextLabelIndex++;
419                     labelIndex = result.iterator-&gt;value;
420                 }
421 
422                 wrappedAddress = m_wrappedObjectPointers.get(node.cell);
423             }
424         }
425 
<span class="line-modified">426         // &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;internal&gt;, [&lt;labelIndex&gt;, &lt;cellEddress&gt;, &lt;wrappedEddress&gt;]</span>
427         json.append(&#39;,&#39;);
428         json.appendNumber(node.identifier);
429         json.append(&#39;,&#39;);
430         json.appendNumber(node.cell-&gt;estimatedSizeInBytes(vm));
431         json.append(&#39;,&#39;);
432         json.appendNumber(classNameIndex);
433         json.append(&#39;,&#39;);
<span class="line-modified">434         json.append(isInternal ? &#39;1&#39; : &#39;0&#39;);</span>
435         if (m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
436             json.append(&#39;,&#39;);
437             json.appendNumber(labelIndex);
438             json.appendLiteral(&quot;,\&quot;0x&quot;);
439             appendUnsignedAsHex(reinterpret_cast&lt;uintptr_t&gt;(node.cell), json, Lowercase);
440             json.appendLiteral(&quot;\&quot;,\&quot;0x&quot;);
441             appendUnsignedAsHex(reinterpret_cast&lt;uintptr_t&gt;(wrappedAddress), json, Lowercase);
442             json.append(&#39;&quot;&#39;);
443         }
444     };
445 
446     bool firstEdge = true;
447     auto appendEdgeJSON = [&amp;] (const HeapSnapshotEdge&amp; edge) {
448         if (!firstEdge)
449             json.append(&#39;,&#39;);
450         firstEdge = false;
451 
452         // &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;
453         json.appendNumber(edge.from.identifier);
454         json.append(&#39;,&#39;);
</pre>
<hr />
<pre>
462             auto result = edgeNameIndexes.add(edge.u.name, nextEdgeNameIndex);
463             if (result.isNewEntry)
464                 nextEdgeNameIndex++;
465             unsigned edgeNameIndex = result.iterator-&gt;value;
466             json.appendNumber(edgeNameIndex);
467             break;
468         }
469         case EdgeType::Index:
470             json.appendNumber(edge.u.index);
471             break;
472         default:
473             // No data for this edge type.
474             json.append(&#39;0&#39;);
475             break;
476         }
477     };
478 
479     json.append(&#39;{&#39;);
480 
481     // version
<span class="line-modified">482     json.appendLiteral(&quot;\&quot;version\&quot;:1&quot;);</span>
483 
484     // type
485     json.append(&#39;,&#39;);
486     json.appendLiteral(&quot;\&quot;type\&quot;:&quot;);
487     json.appendQuotedJSONString(snapshotTypeToString(m_snapshotType));
488 
489     // nodes
490     json.append(&#39;,&#39;);
491     json.appendLiteral(&quot;\&quot;nodes\&quot;:&quot;);
492     json.append(&#39;[&#39;);
493     // &lt;root&gt;
494     if (m_snapshotType == SnapshotType::GCDebuggingSnapshot)
495         json.appendLiteral(&quot;0,0,0,0,0,\&quot;0x0\&quot;,\&quot;0x0\&quot;&quot;);
496     else
497         json.appendLiteral(&quot;0,0,0,0&quot;);
498 
499     for (HeapSnapshot* snapshot = m_profiler.mostRecentSnapshot(); snapshot; snapshot = snapshot-&gt;previous()) {
500         for (auto&amp; node : snapshot-&gt;m_nodes)
501             appendNodeJSON(node);
502     }
503     json.append(&#39;]&#39;);
504 
505     // node class names
506     json.append(&#39;,&#39;);
507     json.appendLiteral(&quot;\&quot;nodeClassNames\&quot;:&quot;);
508     json.append(&#39;[&#39;);
<span class="line-modified">509     Vector&lt;const char *&gt; orderedClassNames(classNameIndexes.size());</span>
510     for (auto&amp; entry : classNameIndexes)
511         orderedClassNames[entry.value] = entry.key;
512     classNameIndexes.clear();
513     bool firstClassName = true;
514     for (auto&amp; className : orderedClassNames) {
515         if (!firstClassName)
516             json.append(&#39;,&#39;);
517         firstClassName = false;
518         json.appendQuotedJSONString(className);
519     }
520     orderedClassNames.clear();
521     json.append(&#39;]&#39;);
522 
523     // Process edges.
524     // Replace pointers with identifiers.
525     // Remove any edges that we won&#39;t need.
526     m_edges.removeAllMatching([&amp;] (HeapSnapshotEdge&amp; edge) {
527         // If the from cell is null, this means a &lt;root&gt; edge.
528         if (!edge.from.cell)
529             edge.from.identifier = 0;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 29 #include &quot;DeferGC.h&quot;
 30 #include &quot;Heap.h&quot;
 31 #include &quot;HeapProfiler.h&quot;
 32 #include &quot;HeapSnapshot.h&quot;
 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;JSCast.h&quot;
 35 #include &quot;PreventCollectionScope.h&quot;
 36 #include &quot;VM.h&quot;
 37 #include &lt;wtf/HexNumber.h&gt;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 
 40 namespace JSC {
 41 
 42 static const char* rootTypeToString(SlotVisitor::RootMarkReason);
 43 
 44 NodeIdentifier HeapSnapshotBuilder::nextAvailableObjectIdentifier = 1;
 45 NodeIdentifier HeapSnapshotBuilder::getNextObjectIdentifier() { return nextAvailableObjectIdentifier++; }
 46 void HeapSnapshotBuilder::resetNextAvailableObjectIdentifier() { HeapSnapshotBuilder::nextAvailableObjectIdentifier = 1; }
 47 
 48 HeapSnapshotBuilder::HeapSnapshotBuilder(HeapProfiler&amp; profiler, SnapshotType type)
<span class="line-modified"> 49     : HeapAnalyzer()</span>
<span class="line-added"> 50     , m_profiler(profiler)</span>
 51     , m_snapshotType(type)
 52 {
 53 }
 54 
 55 HeapSnapshotBuilder::~HeapSnapshotBuilder()
 56 {
 57     if (m_snapshotType == SnapshotType::GCDebuggingSnapshot)
 58         m_profiler.clearSnapshots();
 59 }
 60 
 61 void HeapSnapshotBuilder::buildSnapshot()
 62 {
 63     // GCDebuggingSnapshot are always full snapshots, so clear any existing snapshots.
 64     if (m_snapshotType == SnapshotType::GCDebuggingSnapshot)
 65         m_profiler.clearSnapshots();
 66 
 67     PreventCollectionScope preventCollectionScope(m_profiler.vm().heap);
 68 
<span class="line-modified"> 69     m_snapshot = makeUnique&lt;HeapSnapshot&gt;(m_profiler.mostRecentSnapshot());</span>
 70     {
<span class="line-modified"> 71         ASSERT(!m_profiler.activeHeapAnalyzer());</span>
<span class="line-added"> 72         m_profiler.setActiveHeapAnalyzer(this);</span>
 73         m_profiler.vm().heap.collectNow(Sync, CollectionScope::Full);
<span class="line-modified"> 74         m_profiler.setActiveHeapAnalyzer(nullptr);</span>
 75     }
 76     m_snapshot-&gt;finalize();
 77 
 78     m_profiler.appendSnapshot(WTFMove(m_snapshot));
 79 }
 80 
<span class="line-modified"> 81 void HeapSnapshotBuilder::analyzeNode(JSCell* cell)</span>
 82 {
<span class="line-modified"> 83     ASSERT(m_profiler.activeHeapAnalyzer() == this);</span>
 84 
<span class="line-modified"> 85     ASSERT(m_profiler.vm().heap.isMarked(cell));</span>
 86 
 87     NodeIdentifier identifier;
 88     if (previousSnapshotHasNodeForCell(cell, identifier))
 89         return;
 90 
 91     std::lock_guard&lt;Lock&gt; lock(m_buildingNodeMutex);
 92     m_snapshot-&gt;appendNode(HeapSnapshotNode(cell, getNextObjectIdentifier()));
 93 }
 94 
<span class="line-modified"> 95 void HeapSnapshotBuilder::analyzeEdge(JSCell* from, JSCell* to, SlotVisitor::RootMarkReason rootMarkReason)</span>
 96 {
<span class="line-modified"> 97     ASSERT(m_profiler.activeHeapAnalyzer() == this);</span>
 98     ASSERT(to);
 99 
100     // Avoid trivial edges.
101     if (from == to)
102         return;
103 
104     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
105 
106     if (m_snapshotType == SnapshotType::GCDebuggingSnapshot &amp;&amp; !from) {
107         if (rootMarkReason == SlotVisitor::RootMarkReason::None &amp;&amp; m_snapshotType == SnapshotType::GCDebuggingSnapshot)
108             WTFLogAlways(&quot;Cell %p is a root but no root marking reason was supplied&quot;, to);
109 
110         m_rootData.ensure(to, [] () -&gt; RootData {
111             return { };
112         }).iterator-&gt;value.markReason = rootMarkReason;
113     }
114 
115     m_edges.append(HeapSnapshotEdge(from, to));
116 }
117 
<span class="line-modified">118 void HeapSnapshotBuilder::analyzePropertyNameEdge(JSCell* from, JSCell* to, UniquedStringImpl* propertyName)</span>
119 {
<span class="line-modified">120     ASSERT(m_profiler.activeHeapAnalyzer() == this);</span>
121     ASSERT(to);
122 
123     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
124 
125     m_edges.append(HeapSnapshotEdge(from, to, EdgeType::Property, propertyName));
126 }
127 
<span class="line-modified">128 void HeapSnapshotBuilder::analyzeVariableNameEdge(JSCell* from, JSCell* to, UniquedStringImpl* variableName)</span>
129 {
<span class="line-modified">130     ASSERT(m_profiler.activeHeapAnalyzer() == this);</span>
131     ASSERT(to);
132 
133     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
134 
135     m_edges.append(HeapSnapshotEdge(from, to, EdgeType::Variable, variableName));
136 }
137 
<span class="line-modified">138 void HeapSnapshotBuilder::analyzeIndexEdge(JSCell* from, JSCell* to, uint32_t index)</span>
139 {
<span class="line-modified">140     ASSERT(m_profiler.activeHeapAnalyzer() == this);</span>
141     ASSERT(to);
142 
143     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
144 
145     m_edges.append(HeapSnapshotEdge(from, to, index));
146 }
147 
148 void HeapSnapshotBuilder::setOpaqueRootReachabilityReasonForCell(JSCell* cell, const char* reason)
149 {
150     if (!reason || !*reason || m_snapshotType != SnapshotType::GCDebuggingSnapshot)
151         return;
152 
153     m_rootData.ensure(cell, [] () -&gt; RootData {
154         return { };
155     }).iterator-&gt;value.reachabilityFromOpaqueRootReasons = reason;
156 }
157 
158 void HeapSnapshotBuilder::setWrappedObjectForCell(JSCell* cell, void* wrappedPtr)
159 {
160     m_wrappedObjectPointers.set(cell, wrappedPtr);
</pre>
<hr />
<pre>
162 
163 bool HeapSnapshotBuilder::previousSnapshotHasNodeForCell(JSCell* cell, NodeIdentifier&amp; identifier)
164 {
165     if (!m_snapshot-&gt;previous())
166         return false;
167 
168     auto existingNode = m_snapshot-&gt;previous()-&gt;nodeForCell(cell);
169     if (existingNode) {
170         identifier = existingNode.value().identifier;
171         return true;
172     }
173 
174     return false;
175 }
176 
177 // Heap Snapshot JSON Format:
178 //
179 //  Inspector snapshots:
180 //
181 //   {
<span class="line-modified">182 //      &quot;version&quot;: 2,</span>
183 //      &quot;type&quot;: &quot;Inspector&quot;,
<span class="line-modified">184 //      // [&lt;address&gt;, &lt;labelIndex&gt;, &lt;wrappedAddress&gt;] only present in GCDebuggingSnapshot-type snapshots</span>
185 //      &quot;nodes&quot;: [
<span class="line-modified">186 //          &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;flags&gt;</span>
<span class="line-modified">187 //          &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;flags&gt;</span>
188 //          ...
189 //      ],
190 //      &quot;nodeClassNames&quot;: [
191 //          &quot;string&quot;, &quot;Structure&quot;, &quot;Object&quot;, ...
192 //      ],
193 //      &quot;edges&quot;: [
194 //          &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;,
195 //          &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;,
196 //          ...
197 //      ],
198 //      &quot;edgeTypes&quot;: [
199 //          &quot;Internal&quot;, &quot;Property&quot;, &quot;Index&quot;, &quot;Variable&quot;
200 //      ],
201 //      &quot;edgeNames&quot;: [
202 //          &quot;propertyName&quot;, &quot;variableName&quot;, ...
203 //      ]
204 //   }
205 //
206 //  GC heap debugger snapshots:
207 //
208 //   {
<span class="line-modified">209 //      &quot;version&quot;: 2,</span>
210 //      &quot;type&quot;: &quot;GCDebugging&quot;,
211 //      &quot;nodes&quot;: [
<span class="line-modified">212 //          &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;flags&gt;, &lt;labelIndex&gt;, &lt;cellEddress&gt;, &lt;wrappedAddress&gt;,</span>
<span class="line-modified">213 //          &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;flags&gt;, &lt;labelIndex&gt;, &lt;cellEddress&gt;, &lt;wrappedAddress&gt;,</span>
214 //          ...
215 //      ],
216 //      &quot;nodeClassNames&quot;: [
217 //          &quot;string&quot;, &quot;Structure&quot;, &quot;Object&quot;, ...
218 //      ],
219 //      &quot;edges&quot;: [
220 //          &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;,
221 //          &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;,
222 //          ...
223 //      ],
224 //      &quot;edgeTypes&quot;: [
225 //          &quot;Internal&quot;, &quot;Property&quot;, &quot;Index&quot;, &quot;Variable&quot;
226 //      ],
227 //      &quot;edgeNames&quot;: [
228 //          &quot;propertyName&quot;, &quot;variableName&quot;, ...
229 //      ],
230 //      &quot;roots&quot; : [
231 //          &lt;nodeId&gt;, &lt;rootReasonIndex&gt;, &lt;reachabilityReasonIndex&gt;,
232 //          &lt;nodeId&gt;, &lt;rootReasonIndex&gt;, &lt;reachabilityReasonIndex&gt;,
233 //          ... // &lt;nodeId&gt; may be repeated
234 //      ],
235 //      &quot;labels&quot; : [
236 //          &quot;foo&quot;, &quot;bar&quot;, ...
237 //      ]
238 //   }
239 //
240 // Notes:
241 //
242 //     &lt;nodeClassNameIndex&gt;
243 //       - index into the &quot;nodeClassNames&quot; list.
244 //
<span class="line-modified">245 //     &lt;flags&gt;</span>
<span class="line-modified">246 //       - 0b0000 - no flags</span>
<span class="line-added">247 //       - 0b0001 - internal instance</span>
<span class="line-added">248 //       - 0b0010 - Object subclassification</span>
249 //
250 //     &lt;edgeTypeIndex&gt;
251 //       - index into the &quot;edgeTypes&quot; list.
252 //
253 //     &lt;edgeExtraData&gt;
254 //       - for Internal edges this should be ignored (0).
255 //       - for Index edges this is the index value.
256 //       - for Property or Variable edges this is an index into the &quot;edgeNames&quot; list.
257 //
258 //      &lt;rootReasonIndex&gt;
259 //       - index into the &quot;labels&quot; list.
260 
<span class="line-added">261 enum class NodeFlags {</span>
<span class="line-added">262     Internal      = 1 &lt;&lt; 0,</span>
<span class="line-added">263     ObjectSubtype = 1 &lt;&lt; 1,</span>
<span class="line-added">264 };</span>
<span class="line-added">265 </span>
266 static uint8_t edgeTypeToNumber(EdgeType type)
267 {
268     return static_cast&lt;uint8_t&gt;(type);
269 }
270 
271 static const char* edgeTypeToString(EdgeType type)
272 {
273     switch (type) {
274     case EdgeType::Internal:
275         return &quot;Internal&quot;;
276     case EdgeType::Property:
277         return &quot;Property&quot;;
278     case EdgeType::Index:
279         return &quot;Index&quot;;
280     case EdgeType::Variable:
281         return &quot;Variable&quot;;
282     }
283     ASSERT_NOT_REACHED();
284     return &quot;Internal&quot;;
285 }
</pre>
<hr />
<pre>
350     VM&amp; vm = m_profiler.vm();
351     Structure* structure = cell-&gt;structure(vm);
352 
353     if (structure-&gt;classInfo()-&gt;isSubClassOf(Structure::info())) {
354         Structure* cellAsStructure = jsCast&lt;Structure*&gt;(cell);
355         return cellAsStructure-&gt;classInfo()-&gt;className;
356     }
357 
358     return emptyString();
359 }
360 
361 String HeapSnapshotBuilder::json(Function&lt;bool (const HeapSnapshotNode&amp;)&gt; allowNodeCallback)
362 {
363     VM&amp; vm = m_profiler.vm();
364     DeferGCForAWhile deferGC(vm.heap);
365 
366     // Build a node to identifier map of allowed nodes to use when serializing edges.
367     HashMap&lt;JSCell*, NodeIdentifier&gt; allowedNodeIdentifiers;
368 
369     // Build a list of used class names.
<span class="line-modified">370     HashMap&lt;String, unsigned&gt; classNameIndexes;</span>
<span class="line-modified">371     classNameIndexes.set(&quot;&lt;root&gt;&quot;_s, 0);</span>
372     unsigned nextClassNameIndex = 1;
373 
374     // Build a list of labels (this is just a string table).
375     HashMap&lt;String, unsigned&gt; labelIndexes;
376     labelIndexes.set(emptyString(), 0);
377     unsigned nextLabelIndex = 1;
378 
379     // Build a list of used edge names.
380     HashMap&lt;UniquedStringImpl*, unsigned&gt; edgeNameIndexes;
381     unsigned nextEdgeNameIndex = 0;
382 
383     StringBuilder json;
384 
385     auto appendNodeJSON = [&amp;] (const HeapSnapshotNode&amp; node) {
386         // Let the client decide if they want to allow or disallow certain nodes.
387         if (!allowNodeCallback(node))
388             return;
389 
<span class="line-added">390         unsigned flags = 0;</span>
<span class="line-added">391 </span>
392         allowedNodeIdentifiers.set(node.cell, node.identifier);
393 
<span class="line-modified">394         String className = node.cell-&gt;classInfo(vm)-&gt;className;</span>
<span class="line-added">395         if (node.cell-&gt;isObject() &amp;&amp; className == JSObject::info()-&gt;className) {</span>
<span class="line-added">396             flags |= static_cast&lt;unsigned&gt;(NodeFlags::ObjectSubtype);</span>
<span class="line-added">397 </span>
<span class="line-added">398             // Skip calculating a class name if this object has a `constructor` own property.</span>
<span class="line-added">399             // These cases are typically F.prototype objects and we want to treat these as</span>
<span class="line-added">400             // &quot;Object&quot; in snapshots and not get the name of the prototype&#39;s parent.</span>
<span class="line-added">401             JSObject* object = asObject(node.cell);</span>
<span class="line-added">402             if (JSGlobalObject* globalObject = object-&gt;globalObject(vm)) {</span>
<span class="line-added">403                 ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-added">404                 PropertySlot slot(object, PropertySlot::InternalMethodType::VMInquiry);</span>
<span class="line-added">405                 if (!object-&gt;getOwnPropertySlot(object, exec, vm.propertyNames-&gt;constructor, slot))</span>
<span class="line-added">406                     className = JSObject::calculatedClassName(object);</span>
<span class="line-added">407             }</span>
<span class="line-added">408         }</span>
<span class="line-added">409 </span>
<span class="line-added">410         auto result = classNameIndexes.add(className, nextClassNameIndex);</span>
411         if (result.isNewEntry)
412             nextClassNameIndex++;
413         unsigned classNameIndex = result.iterator-&gt;value;
414 

415         void* wrappedAddress = 0;
416         unsigned labelIndex = 0;
<span class="line-modified">417         if (!node.cell-&gt;isString() &amp;&amp; !node.cell-&gt;isBigInt()) {</span>
418             Structure* structure = node.cell-&gt;structure(vm);
<span class="line-modified">419             if (!structure || !structure-&gt;globalObject())</span>
<span class="line-added">420                 flags |= static_cast&lt;unsigned&gt;(NodeFlags::Internal);</span>
421 
422             if (m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
423                 String nodeLabel;
424                 auto it = m_cellLabels.find(node.cell);
425                 if (it != m_cellLabels.end())
426                     nodeLabel = it-&gt;value;
427 
428                 if (nodeLabel.isEmpty()) {
429                     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, node.cell)) {
430                         if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(vm, object))
431                             nodeLabel = function-&gt;calculatedDisplayName(vm);
432                     }
433                 }
434 
435                 String description = descriptionForCell(node.cell);
436                 if (description.length()) {
437                     if (nodeLabel.length())
438                         nodeLabel.append(&#39; &#39;);
439                     nodeLabel.append(description);
440                 }
441 
442                 if (!nodeLabel.isEmpty() &amp;&amp; m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
443                     auto result = labelIndexes.add(nodeLabel, nextLabelIndex);
444                     if (result.isNewEntry)
445                         nextLabelIndex++;
446                     labelIndex = result.iterator-&gt;value;
447                 }
448 
449                 wrappedAddress = m_wrappedObjectPointers.get(node.cell);
450             }
451         }
452 
<span class="line-modified">453         // &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;flags&gt;, [&lt;labelIndex&gt;, &lt;cellEddress&gt;, &lt;wrappedAddress&gt;]</span>
454         json.append(&#39;,&#39;);
455         json.appendNumber(node.identifier);
456         json.append(&#39;,&#39;);
457         json.appendNumber(node.cell-&gt;estimatedSizeInBytes(vm));
458         json.append(&#39;,&#39;);
459         json.appendNumber(classNameIndex);
460         json.append(&#39;,&#39;);
<span class="line-modified">461         json.appendNumber(flags);</span>
462         if (m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
463             json.append(&#39;,&#39;);
464             json.appendNumber(labelIndex);
465             json.appendLiteral(&quot;,\&quot;0x&quot;);
466             appendUnsignedAsHex(reinterpret_cast&lt;uintptr_t&gt;(node.cell), json, Lowercase);
467             json.appendLiteral(&quot;\&quot;,\&quot;0x&quot;);
468             appendUnsignedAsHex(reinterpret_cast&lt;uintptr_t&gt;(wrappedAddress), json, Lowercase);
469             json.append(&#39;&quot;&#39;);
470         }
471     };
472 
473     bool firstEdge = true;
474     auto appendEdgeJSON = [&amp;] (const HeapSnapshotEdge&amp; edge) {
475         if (!firstEdge)
476             json.append(&#39;,&#39;);
477         firstEdge = false;
478 
479         // &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;
480         json.appendNumber(edge.from.identifier);
481         json.append(&#39;,&#39;);
</pre>
<hr />
<pre>
489             auto result = edgeNameIndexes.add(edge.u.name, nextEdgeNameIndex);
490             if (result.isNewEntry)
491                 nextEdgeNameIndex++;
492             unsigned edgeNameIndex = result.iterator-&gt;value;
493             json.appendNumber(edgeNameIndex);
494             break;
495         }
496         case EdgeType::Index:
497             json.appendNumber(edge.u.index);
498             break;
499         default:
500             // No data for this edge type.
501             json.append(&#39;0&#39;);
502             break;
503         }
504     };
505 
506     json.append(&#39;{&#39;);
507 
508     // version
<span class="line-modified">509     json.appendLiteral(&quot;\&quot;version\&quot;:2&quot;);</span>
510 
511     // type
512     json.append(&#39;,&#39;);
513     json.appendLiteral(&quot;\&quot;type\&quot;:&quot;);
514     json.appendQuotedJSONString(snapshotTypeToString(m_snapshotType));
515 
516     // nodes
517     json.append(&#39;,&#39;);
518     json.appendLiteral(&quot;\&quot;nodes\&quot;:&quot;);
519     json.append(&#39;[&#39;);
520     // &lt;root&gt;
521     if (m_snapshotType == SnapshotType::GCDebuggingSnapshot)
522         json.appendLiteral(&quot;0,0,0,0,0,\&quot;0x0\&quot;,\&quot;0x0\&quot;&quot;);
523     else
524         json.appendLiteral(&quot;0,0,0,0&quot;);
525 
526     for (HeapSnapshot* snapshot = m_profiler.mostRecentSnapshot(); snapshot; snapshot = snapshot-&gt;previous()) {
527         for (auto&amp; node : snapshot-&gt;m_nodes)
528             appendNodeJSON(node);
529     }
530     json.append(&#39;]&#39;);
531 
532     // node class names
533     json.append(&#39;,&#39;);
534     json.appendLiteral(&quot;\&quot;nodeClassNames\&quot;:&quot;);
535     json.append(&#39;[&#39;);
<span class="line-modified">536     Vector&lt;String&gt; orderedClassNames(classNameIndexes.size());</span>
537     for (auto&amp; entry : classNameIndexes)
538         orderedClassNames[entry.value] = entry.key;
539     classNameIndexes.clear();
540     bool firstClassName = true;
541     for (auto&amp; className : orderedClassNames) {
542         if (!firstClassName)
543             json.append(&#39;,&#39;);
544         firstClassName = false;
545         json.appendQuotedJSONString(className);
546     }
547     orderedClassNames.clear();
548     json.append(&#39;]&#39;);
549 
550     // Process edges.
551     // Replace pointers with identifiers.
552     // Remove any edges that we won&#39;t need.
553     m_edges.removeAllMatching([&amp;] (HeapSnapshotEdge&amp; edge) {
554         // If the from cell is null, this means a &lt;root&gt; edge.
555         if (!edge.from.cell)
556             edge.from.identifier = 0;
</pre>
</td>
</tr>
</table>
<center><a href="HeapSnapshot.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HeapSnapshotBuilder.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>