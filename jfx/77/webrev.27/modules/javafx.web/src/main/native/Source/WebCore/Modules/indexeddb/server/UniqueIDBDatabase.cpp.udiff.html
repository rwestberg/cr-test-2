<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SQLiteIDBTransaction.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="UniqueIDBDatabase.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -39,23 +39,74 @@</span>
  #include &quot;IDBServer.h&quot;
  #include &quot;IDBTransactionInfo.h&quot;
  #include &quot;IDBValue.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;SerializedScriptValue.h&quot;
<span class="udiff-line-added">+ #include &quot;StorageQuotaManager.h&quot;</span>
  #include &quot;UniqueIDBDatabaseConnection.h&quot;
  #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
<span class="udiff-line-modified-removed">- #include &lt;JavaScriptCore/HeapInlines.h&gt;</span>
<span class="udiff-line-modified-added">+ #include &lt;JavaScriptCore/JSCInlines.h&gt;</span>
  #include &lt;JavaScriptCore/StrongInlines.h&gt;
<span class="udiff-line-removed">- #include &lt;JavaScriptCore/StructureInlines.h&gt;</span>
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/Scope.h&gt;
  
  namespace WebCore {
  using namespace JSC;
  namespace IDBServer {
  
<span class="udiff-line-added">+ static const uint64_t defaultWriteOperationCost = 4;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline uint64_t estimateSize(const IDBKeyData&amp; keyData)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     uint64_t size = 4;</span>
<span class="udiff-line-added">+     switch (keyData.type()) {</span>
<span class="udiff-line-added">+     case IndexedDB::KeyType::String:</span>
<span class="udiff-line-added">+         size += keyData.string().sizeInBytes();</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case IndexedDB::KeyType::Binary: {</span>
<span class="udiff-line-added">+         size += keyData.binary().size();</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     case IndexedDB::KeyType::Array:</span>
<span class="udiff-line-added">+         for (auto&amp; data : keyData.array())</span>
<span class="udiff-line-added">+             size += estimateSize(data);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return size;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline uint64_t estimateSize(const IDBValue&amp; value)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     uint64_t size = 4;</span>
<span class="udiff-line-added">+     size += value.data().size();</span>
<span class="udiff-line-added">+     for (auto&amp; url : value.blobURLs())</span>
<span class="udiff-line-added">+         size += url.sizeInBytes();</span>
<span class="udiff-line-added">+     for (auto&amp; path : value.blobFilePaths())</span>
<span class="udiff-line-added">+         size += path.sizeInBytes();</span>
<span class="udiff-line-added">+     return size;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline uint64_t estimateSize(const IDBIndexInfo&amp; info)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     uint64_t size = 4;</span>
<span class="udiff-line-added">+     size += info.name().sizeInBytes();</span>
<span class="udiff-line-added">+     return size;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline uint64_t estimateSize(const IDBObjectStoreInfo&amp; info)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     uint64_t size = 4;</span>
<span class="udiff-line-added">+     size += info.name().sizeInBytes();</span>
<span class="udiff-line-added">+     // FIXME: estimate keyPath.</span>
<span class="udiff-line-added">+     for (auto&amp; indexInfo : info.indexMap().values())</span>
<span class="udiff-line-added">+         size += estimateSize(indexInfo);</span>
<span class="udiff-line-added">+     return size;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  UniqueIDBDatabase::UniqueIDBDatabase(IDBServer&amp; server, const IDBDatabaseIdentifier&amp; identifier)
      : m_server(server)
      , m_identifier(identifier)
      , m_operationAndTransactionTimer(*this, &amp;UniqueIDBDatabase::operationAndTransactionTimerFired)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -116,23 +167,76 @@</span>
  #endif
  
      return m_versionChangeDatabaseConnection;
  }
  
<span class="udiff-line-added">+ static inline String quotaErrorMessageName(const char* taskName)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return makeString(&quot;Failed to &quot;, taskName, &quot; in database because not enough space for domain&quot;);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::requestSpace(uint64_t taskSize, const char* taskName, CompletionHandler&lt;void(Optional&lt;IDBError&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     m_server-&gt;requestSpace(m_identifier.origin(), taskSize, [weakThis = makeWeakPtr(this), this, taskName, callback = WTFMove(callback)](auto decision) mutable {</span>
<span class="udiff-line-added">+         if (!weakThis) {</span>
<span class="udiff-line-added">+             callback(IDBError { UnknownError });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (m_owningPointerForClose) {</span>
<span class="udiff-line-added">+             // We are closing the database, there is no point in trying to modify the database at that point.</span>
<span class="udiff-line-added">+             callback(IDBError { UnknownError });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         switch (decision) {</span>
<span class="udiff-line-added">+         case StorageQuotaManager::Decision::Deny:</span>
<span class="udiff-line-added">+             callback(IDBError { QuotaExceededError, quotaErrorMessageName(taskName) });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         case StorageQuotaManager::Decision::Grant:</span>
<span class="udiff-line-added">+             callback({ });</span>
<span class="udiff-line-added">+         };</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::waitForRequestSpaceCompletion(CompletionHandler&lt;void(Optional&lt;IDBError&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     requestSpace(0, &quot;&quot;, WTFMove(callback));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void UniqueIDBDatabase::performCurrentOpenOperation()
  {
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::performCurrentOpenOperation (%p)&quot;, this);
  
      ASSERT(m_currentOpenDBRequest);
      ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
  
      if (!m_databaseInfo) {
          if (!m_isOpeningBackingStore) {
              m_isOpeningBackingStore = true;
<span class="udiff-line-modified-removed">-             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::openBackingStore, m_identifier));</span>
<span class="udiff-line-modified-added">+             // We do not know whether this is an existing or a new database.</span>
<span class="udiff-line-added">+             // We set a small cost so that it is not possible to open an infinite number of database.</span>
<span class="udiff-line-added">+             m_server-&gt;requestSpace(m_identifier.origin(), defaultWriteOperationCost, [this, weakThis = makeWeakPtr(this)](auto decision) mutable {</span>
<span class="udiff-line-added">+                 if (!weakThis)</span>
<span class="udiff-line-added">+                     return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (m_owningPointerForClose)</span>
<span class="udiff-line-added">+                     return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 switch (decision) {</span>
<span class="udiff-line-added">+                 case StorageQuotaManager::Decision::Deny: {</span>
<span class="udiff-line-added">+                     auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), IDBError { QuotaExceededError, quotaErrorMessageName(&quot;openDatabase&quot;) });</span>
<span class="udiff-line-added">+                     m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);</span>
<span class="udiff-line-added">+                     m_currentOpenDBRequest = nullptr;</span>
<span class="udiff-line-added">+                     m_isOpeningBackingStore = false;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 case StorageQuotaManager::Decision::Grant:</span>
<span class="udiff-line-added">+                     this-&gt;postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::openBackingStore, m_identifier));</span>
<span class="udiff-line-added">+                 };</span>
<span class="udiff-line-added">+             });</span>
          }
<span class="udiff-line-removed">- </span>
          return;
      }
  
      // If we previously started a version change operation but were blocked by having open connections,
      // we might now be unblocked.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -238,23 +342,27 @@</span>
  
      uint64_t deletedVersion = 0;
  
      if (m_backingStore) {
          m_backingStore-&gt;deleteBackingStore();
<span class="udiff-line-added">+         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="udiff-line-added">+ </span>
          m_backingStore = nullptr;
          m_backingStoreSupportsSimultaneousTransactions = false;
          m_backingStoreIsEphemeral = false;
      } else {
<span class="udiff-line-modified-removed">-         auto backingStore = m_server.createBackingStore(identifier);</span>
<span class="udiff-line-modified-added">+         auto backingStore = m_server-&gt;createBackingStore(identifier);</span>
<span class="udiff-line-added">+         m_currentDatabaseSize = backingStore-&gt;databaseSize();</span>
  
          IDBDatabaseInfo databaseInfo;
          auto error = backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
          if (!error.isNull())
              LOG_ERROR(&quot;Error getting database info from database %s that we are trying to delete&quot;, identifier.debugString().utf8().data());
  
          deletedVersion = databaseInfo.version();
          backingStore-&gt;deleteBackingStore();
<span class="udiff-line-added">+         m_newDatabaseSize = backingStore-&gt;databaseSize();</span>
      }
  
      postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didDeleteBackingStore, deletedVersion));
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -274,11 +382,11 @@</span>
      ASSERT(isMainThread());
  
      m_operationAndTransactionTimer.stop();
  
      RELEASE_ASSERT(!m_owningPointerForClose);
<span class="udiff-line-modified-removed">-     m_owningPointerForClose = m_server.closeAndTakeUniqueIDBDatabase(*this);</span>
<span class="udiff-line-modified-added">+     m_owningPointerForClose = m_server-&gt;closeAndTakeUniqueIDBDatabase(*this);</span>
  
      postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));
  }
  
  void UniqueIDBDatabase::shutdownForClose()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -286,10 +394,15 @@</span>
      ASSERT(!isMainThread());
      ASSERT(m_owningPointerForClose.get() == this);
  
      LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::shutdownForClose&quot;);
  
<span class="udiff-line-added">+     if (m_backingStore) {</span>
<span class="udiff-line-added">+         m_backingStore-&gt;close();</span>
<span class="udiff-line-added">+         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      m_backingStore = nullptr;
      m_backingStoreSupportsSimultaneousTransactions = false;
      m_backingStoreIsEphemeral = false;
  
      if (!m_databaseQueue.isEmpty()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -303,10 +416,12 @@</span>
  
  void UniqueIDBDatabase::didShutdownForClose()
  {
      ASSERT(m_databaseReplyQueue.isEmpty());
      m_databaseReplyQueue.kill();
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     updateSpaceUsedIfNeeded();</span>
  }
  
  void UniqueIDBDatabase::didDeleteBackingStore(uint64_t deletedVersion)
  {
      ASSERT(isMainThread());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -327,17 +442,19 @@</span>
  
      // If this UniqueIDBDatabase was brought into existence for the purpose of deleting the file on disk,
      // we won&#39;t have a m_mostRecentDeletedDatabaseInfo. In that case, we&#39;ll manufacture one using the
      // passed in deletedVersion argument.
      if (!m_mostRecentDeletedDatabaseInfo)
<span class="udiff-line-modified-removed">-         m_mostRecentDeletedDatabaseInfo = std::make_unique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), deletedVersion);</span>
<span class="udiff-line-modified-added">+         m_mostRecentDeletedDatabaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), deletedVersion);</span>
  
      if (m_currentOpenDBRequest) {
          m_currentOpenDBRequest-&gt;notifyDidDeleteDatabase(*m_mostRecentDeletedDatabaseInfo);
          m_currentOpenDBRequest = nullptr;
      }
  
<span class="udiff-line-added">+     updateSpaceUsedIfNeeded();</span>
<span class="udiff-line-added">+ </span>
      m_deleteBackingStoreInProgress = false;
  
      if (m_hardClosedForUserDelete)
          return;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -354,11 +471,11 @@</span>
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDatabaseOperations - There are %u pending&quot;, m_pendingOpenDBRequests.size());
      ASSERT(!m_hardClosedForUserDelete);
  
<span class="udiff-line-modified-removed">-     if (m_deleteBackingStoreInProgress)</span>
<span class="udiff-line-modified-added">+     if (m_deleteBackingStoreInProgress || m_isOpeningBackingStore)</span>
          return;
  
      clearStalePendingOpenDBRequests();
  
      if (m_versionChangeDatabaseConnection || m_versionChangeTransaction || (m_currentOpenDBRequest &amp;&amp; !m_currentOpenDBRequest-&gt;connection().isClosed())) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -421,34 +538,46 @@</span>
      ASSERT(isMainThread());
      static uint64_t currentID = 0;
      return ++currentID;
  }
  
<span class="udiff-line-modified-removed">- uint64_t UniqueIDBDatabase::storeCallbackOrFireError(ErrorCallback&amp;&amp; callback)</span>
<span class="udiff-line-modified-added">+ uint64_t UniqueIDBDatabase::storeCallbackOrFireError(ErrorCallback&amp;&amp; callback, uint64_t taskSize)</span>
  {
      if (m_hardClosedForUserDelete) {
          callback(IDBError::userDeleteError());
          return 0;
      }
  
      uint64_t identifier = generateUniqueCallbackIdentifier();
      ASSERT(!m_errorCallbacks.contains(identifier));
      m_errorCallbacks.add(identifier, WTFMove(callback));
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (taskSize) {</span>
<span class="udiff-line-added">+         m_server-&gt;increasePotentialSpaceUsed(m_identifier.origin(), taskSize);</span>
<span class="udiff-line-added">+         m_pendingSpaceIncreasingTasks.add(identifier, taskSize);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      m_callbackQueue.append(identifier);
      return identifier;
  }
  
<span class="udiff-line-modified-removed">- uint64_t UniqueIDBDatabase::storeCallbackOrFireError(KeyDataCallback&amp;&amp; callback)</span>
<span class="udiff-line-modified-added">+ uint64_t UniqueIDBDatabase::storeCallbackOrFireError(KeyDataCallback&amp;&amp; callback, uint64_t taskSize)</span>
  {
      if (m_hardClosedForUserDelete) {
          callback(IDBError::userDeleteError(), { });
          return 0;
      }
  
      uint64_t identifier = generateUniqueCallbackIdentifier();
      ASSERT(!m_keyDataCallbacks.contains(identifier));
      m_keyDataCallbacks.add(identifier, WTFMove(callback));
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (taskSize) {</span>
<span class="udiff-line-added">+         m_server-&gt;increasePotentialSpaceUsed(m_identifier.origin(), taskSize);</span>
<span class="udiff-line-added">+         m_pendingSpaceIncreasingTasks.add(identifier, taskSize);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      m_callbackQueue.append(identifier);
      return identifier;
  }
  
  uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetResultCallback&amp;&amp; callback)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -509,32 +638,53 @@</span>
      ASSERT(!m_versionChangeTransaction);
      ASSERT(m_currentOpenDBRequest);
      ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
      ASSERT(m_versionChangeDatabaseConnection);
  
<span class="udiff-line-modified-removed">-     auto operation = WTFMove(m_currentOpenDBRequest);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     uint64_t requestedVersion = operation-&gt;requestData().requestedVersion();</span>
<span class="udiff-line-modified-added">+     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();</span>
      if (!requestedVersion)
          requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
  
<span class="udiff-line-removed">-     addOpenDatabaseConnection(*m_versionChangeDatabaseConnection);</span>
<span class="udiff-line-removed">- </span>
      m_versionChangeTransaction = &amp;m_versionChangeDatabaseConnection-&gt;createVersionChangeTransaction(requestedVersion);
<span class="udiff-line-removed">-     m_databaseInfo-&gt;setVersion(requestedVersion);</span>
<span class="udiff-line-removed">- </span>
      m_inProgressTransactions.set(m_versionChangeTransaction-&gt;info().identifier(), m_versionChangeTransaction);
<span class="udiff-line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::beginTransactionInBackingStore, m_versionChangeTransaction-&gt;info()));</span>
  
<span class="udiff-line-modified-removed">-     auto result = IDBResultData::openDatabaseUpgradeNeeded(operation-&gt;requestData().requestIdentifier(), *m_versionChangeTransaction);</span>
<span class="udiff-line-removed">-     operation-&gt;connection().didOpenDatabase(result);</span>
<span class="udiff-line-modified-added">+     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performStartVersionChangeTransaction, m_versionChangeTransaction-&gt;info()));</span>
  }
  
<span class="udiff-line-modified-removed">- void UniqueIDBDatabase::beginTransactionInBackingStore(const IDBTransactionInfo&amp; info)</span>
<span class="udiff-line-modified-added">+ void UniqueIDBDatabase::performStartVersionChangeTransaction(const IDBTransactionInfo&amp; info)</span>
  {
<span class="udiff-line-modified-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::beginTransactionInBackingStore&quot;);</span>
<span class="udiff-line-modified-removed">-     m_backingStore-&gt;beginTransaction(info);</span>
<span class="udiff-line-modified-added">+     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performStartVersionChangeTransaction&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     IDBError error = m_backingStore-&gt;beginTransaction(info);</span>
<span class="udiff-line-added">+     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformStartVersionChangeTransaction, error));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::didPerformStartVersionChangeTransaction(const IDBError&amp; error)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformStartVersionChangeTransaction&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Open request may already be canceled by client or user, or connection to client is lost.</span>
<span class="udiff-line-added">+     if (!m_versionChangeDatabaseConnection)</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ASSERT(m_currentOpenDBRequest);</span>
<span class="udiff-line-added">+     ASSERT(m_versionChangeTransaction);</span>
<span class="udiff-line-added">+     auto operation = WTFMove(m_currentOpenDBRequest);</span>
<span class="udiff-line-added">+     IDBResultData result;</span>
<span class="udiff-line-added">+     if (error.isNull()) {</span>
<span class="udiff-line-added">+         addOpenDatabaseConnection(*m_versionChangeDatabaseConnection);</span>
<span class="udiff-line-added">+         m_databaseInfo-&gt;setVersion(m_versionChangeTransaction-&gt;info().newVersion());</span>
<span class="udiff-line-added">+         result = IDBResultData::openDatabaseUpgradeNeeded(operation-&gt;requestData().requestIdentifier(), *m_versionChangeTransaction);</span>
<span class="udiff-line-added">+         operation-&gt;connection().didOpenDatabase(result);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+         m_versionChangeDatabaseConnection-&gt;abortTransactionWithoutCallback(*m_versionChangeTransaction);</span>
<span class="udiff-line-added">+         m_versionChangeDatabaseConnection = nullptr;</span>
<span class="udiff-line-added">+         result = IDBResultData::error(operation-&gt;requestData().requestIdentifier(), error);</span>
<span class="udiff-line-added">+         operation-&gt;connection().didOpenDatabase(result);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     invokeOperationAndTransactionTimer();</span>
  }
  
  void UniqueIDBDatabase::maybeNotifyConnectionsOfVersionChange()
  {
      ASSERT(m_currentOpenDBRequest);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -630,14 +780,18 @@</span>
  {
      ASSERT(!isMainThread());
      LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::openBackingStore (%p)&quot;, this);
  
      ASSERT(!m_backingStore);
<span class="udiff-line-modified-removed">-     m_backingStore = m_server.createBackingStore(identifier);</span>
<span class="udiff-line-modified-added">+     m_backingStore = m_server-&gt;createBackingStore(identifier);</span>
      m_backingStoreSupportsSimultaneousTransactions = m_backingStore-&gt;supportsSimultaneousTransactions();
      m_backingStoreIsEphemeral = m_backingStore-&gt;isEphemeral();
  
<span class="udiff-line-added">+     // QuotaUser should have initiliazed storage usage, which contains the</span>
<span class="udiff-line-added">+     // size of this database.</span>
<span class="udiff-line-added">+     m_currentDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="udiff-line-added">+ </span>
      IDBDatabaseInfo databaseInfo;
      auto error = m_backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
  
      postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didOpenBackingStore, databaseInfo, error));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -645,16 +799,18 @@</span>
  void UniqueIDBDatabase::didOpenBackingStore(const IDBDatabaseInfo&amp; info, const IDBError&amp; error)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didOpenBackingStore&quot;);
  
<span class="udiff-line-modified-removed">-     m_databaseInfo = std::make_unique&lt;IDBDatabaseInfo&gt;(info);</span>
<span class="udiff-line-modified-added">+     m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(info);</span>
      m_backingStoreOpenError = error;
  
      ASSERT(m_isOpeningBackingStore);
      m_isOpeningBackingStore = false;
  
<span class="udiff-line-added">+     updateSpaceUsedIfNeeded();</span>
<span class="udiff-line-added">+ </span>
      if (m_hardClosedForUserDelete)
          return;
  
      handleDatabaseOperations();
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -662,11 +818,27 @@</span>
  void UniqueIDBDatabase::createObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createObjectStore&quot;);
  
<span class="udiff-line-modified-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="udiff-line-modified-added">+     auto taskSize = defaultWriteOperationCost + estimateSize(info);</span>
<span class="udiff-line-added">+     requestSpace(taskSize, &quot;createObjectStore&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="udiff-line-added">+         if (error) {</span>
<span class="udiff-line-added">+             callback(WTFMove(*error));</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (!transaction) {</span>
<span class="udiff-line-added">+             callback(IDBError { UnknownError });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this-&gt;createObjectStoreAfterQuotaCheck(taskSize, *transaction, info, WTFMove(callback));</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::createObjectStoreAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
      if (!callbackID)
          return;
  
      postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateObjectStore, callbackID, transaction.info().identifier(), info));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -697,10 +869,25 @@</span>
  void UniqueIDBDatabase::deleteObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteObjectStore&quot;);
  
<span class="udiff-line-added">+     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="udiff-line-added">+         if (error) {</span>
<span class="udiff-line-added">+             callback(WTFMove(*error));</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (!transaction) {</span>
<span class="udiff-line-added">+             callback(IDBError { UnknownError });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this-&gt;deleteObjectStoreAfterQuotaCheck(*transaction, objectStoreName, WTFMove(callback));</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::deleteObjectStoreAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)</span>
<span class="udiff-line-added">+ {</span>
      uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
      if (!callbackID)
          return;
  
      auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreName);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -738,11 +925,27 @@</span>
  void UniqueIDBDatabase::renameObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameObjectStore&quot;);
  
<span class="udiff-line-modified-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="udiff-line-modified-added">+     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();</span>
<span class="udiff-line-added">+     requestSpace(taskSize, &quot;renameObjectStore&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), objectStoreIdentifier, newName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="udiff-line-added">+         if (error) {</span>
<span class="udiff-line-added">+             callback(WTFMove(*error));</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (!transaction) {</span>
<span class="udiff-line-added">+             callback(IDBError { UnknownError });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this-&gt;renameObjectStoreAfterQuotaCheck(taskSize, *transaction, objectStoreIdentifier, newName, WTFMove(callback));</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::renameObjectStoreAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
      if (!callbackID)
          return;
  
      auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
      if (!info) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -779,10 +982,25 @@</span>
  void UniqueIDBDatabase::clearObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::clearObjectStore&quot;);
  
<span class="udiff-line-added">+     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreIdentifier, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="udiff-line-added">+         if (error) {</span>
<span class="udiff-line-added">+             callback(WTFMove(*error));</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (!transaction) {</span>
<span class="udiff-line-added">+             callback(IDBError { UnknownError });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this-&gt;clearObjectStoreAfetQuotaCheck(*transaction, objectStoreIdentifier, WTFMove(callback));</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::clearObjectStoreAfetQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)</span>
<span class="udiff-line-added">+ {</span>
      uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
      if (!callbackID)
          return;
      postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performClearObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -810,24 +1028,47 @@</span>
  void UniqueIDBDatabase::createIndex(UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createIndex&quot;);
  
<span class="udiff-line-modified-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="udiff-line-modified-added">+     auto taskSize = defaultWriteOperationCost + estimateSize(info);</span>
<span class="udiff-line-added">+     requestSpace(taskSize, &quot;createIndex&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="udiff-line-added">+         if (error) {</span>
<span class="udiff-line-added">+             callback(WTFMove(*error));</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (!transaction) {</span>
<span class="udiff-line-added">+             callback(IDBError { UnknownError });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this-&gt;createIndexAfterQuotaCheck(taskSize, *transaction, info, WTFMove(callback));</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::createIndexAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
      if (!callbackID)
          return;
      postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateIndex, callbackID, transaction.info().identifier(), info));
  }
  
  void UniqueIDBDatabase::performCreateIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)
  {
      ASSERT(!isMainThread());
      LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateIndex&quot;);
  
<span class="udiff-line-added">+     IDBError error;</span>
      ASSERT(m_backingStore);
<span class="udiff-line-modified-removed">-     IDBError error = m_backingStore-&gt;createIndex(transactionIdentifier, info);</span>
<span class="udiff-line-modified-added">+     if (!m_backingStore) {</span>
<span class="udiff-line-added">+         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - UniqueIDBDatabase::performCreateIndex: m_backingStore is null&quot;, this);</span>
<span class="udiff-line-added">+         error = IDBError(InvalidStateError, &quot;Backing store is invalid for call to create index&quot;_s);</span>
<span class="udiff-line-added">+         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-added">+     error = m_backingStore-&gt;createIndex(transactionIdentifier, info);</span>
      postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));
  }
  
  void UniqueIDBDatabase::didPerformCreateIndex(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBIndexInfo&amp; info)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -847,10 +1088,25 @@</span>
  void UniqueIDBDatabase::deleteIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteIndex&quot;);
  
<span class="udiff-line-added">+     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreIdentifier, indexName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="udiff-line-added">+         if (error) {</span>
<span class="udiff-line-added">+             callback(WTFMove(*error));</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (!transaction) {</span>
<span class="udiff-line-added">+             callback(IDBError { UnknownError });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this-&gt;deleteIndexAfterQuotaCheck(*transaction, objectStoreIdentifier, indexName, WTFMove(callback));</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::deleteIndexAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)</span>
<span class="udiff-line-added">+ {</span>
      uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
      if (!callbackID)
          return;
  
      auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -897,11 +1153,27 @@</span>
  void UniqueIDBDatabase::renameIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameIndex&quot;);
  
<span class="udiff-line-modified-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="udiff-line-modified-added">+     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();</span>
<span class="udiff-line-added">+     requestSpace(taskSize, &quot;renameIndex&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), objectStoreIdentifier, indexIdentifier, newName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="udiff-line-added">+         if (error) {</span>
<span class="udiff-line-added">+             callback(WTFMove(*error));</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (!transaction) {</span>
<span class="udiff-line-added">+             callback(IDBError { UnknownError });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this-&gt;renameIndexAfterQuotaCheck(taskSize, *transaction, objectStoreIdentifier, indexIdentifier, newName, WTFMove(callback));</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::renameIndexAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
      if (!callbackID)
          return;
  
      auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
      if (!objectStoreInfo) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -951,31 +1223,26 @@</span>
  void UniqueIDBDatabase::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::putOrAdd&quot;);
  
<span class="udiff-line-modified-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="udiff-line-modified-removed">-     if (!callbackID)</span>
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPutOrAdd, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyData, value, overwriteMode));</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- VM&amp; UniqueIDBDatabase::databaseThreadVM()</span>
<span class="udiff-line-modified-removed">- {</span>
<span class="udiff-line-removed">-     ASSERT(!isMainThread());</span>
<span class="udiff-line-removed">-     static VM* vm = &amp;VM::create().leakRef();</span>
<span class="udiff-line-removed">-     return *vm;</span>
<span class="udiff-line-modified-added">+     auto taskSize = defaultWriteOperationCost + estimateSize(keyData) + estimateSize(value);</span>
<span class="udiff-line-modified-added">+     requestSpace(taskSize, &quot;putOrAdd&quot;, [this, taskSize, requestData, keyData, value, callback = WTFMove(callback), overwriteMode](auto error) mutable {</span>
<span class="udiff-line-modified-added">+         if (error) {</span>
<span class="udiff-line-modified-added">+             callback(WTFMove(*error), { });</span>
<span class="udiff-line-modified-added">+             return;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         this-&gt;putOrAddAfterQuotaCheck(taskSize, requestData, keyData, value, overwriteMode, WTFMove(callback));</span>
<span class="udiff-line-modified-added">+     });</span>
  }
  
<span class="udiff-line-modified-removed">- ExecState&amp; UniqueIDBDatabase::databaseThreadExecState()</span>
<span class="udiff-line-modified-added">+ void UniqueIDBDatabase::putOrAddAfterQuotaCheck(uint64_t taskSize, const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)</span>
  {
<span class="udiff-line-modified-removed">-     ASSERT(!isMainThread());</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     static NeverDestroyed&lt;Strong&lt;JSGlobalObject&gt;&gt; globalObject(databaseThreadVM(), JSGlobalObject::create(databaseThreadVM(), JSGlobalObject::createStructure(databaseThreadVM(), jsNull())));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     RELEASE_ASSERT(globalObject.get()-&gt;globalExec());</span>
<span class="udiff-line-removed">-     return *globalObject.get()-&gt;globalExec();</span>
<span class="udiff-line-modified-added">+     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
<span class="udiff-line-modified-added">+     if (!callbackID)</span>
<span class="udiff-line-modified-added">+         return;</span>
<span class="udiff-line-modified-added">+     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPutOrAdd, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyData, value, overwriteMode));</span>
  }
  
  void UniqueIDBDatabase::performPutOrAdd(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyData&amp; keyData, const IDBValue&amp; originalRecordValue, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
  {
      ASSERT(!isMainThread());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -985,10 +1252,17 @@</span>
      ASSERT(objectStoreIdentifier);
  
      IDBKeyData usedKey;
      IDBError error;
  
<span class="udiff-line-added">+     if (!m_backingStore) {</span>
<span class="udiff-line-added">+         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - UniqueIDBDatabase::performPutOrAdd: m_backingStore is null&quot;, this);</span>
<span class="udiff-line-added">+         error = IDBError(InvalidStateError, &quot;Backing store is invalid for call to put or add&quot;_s);</span>
<span class="udiff-line-added">+         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      auto* objectStoreInfo = m_backingStore-&gt;infoForObjectStore(objectStoreIdentifier);
      if (!objectStoreInfo) {
          error = IDBError(InvalidStateError, &quot;Object store cannot be found in the backing store&quot;_s);
          postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
          return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1022,53 +1296,21 @@</span>
              postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
              return;
          }
      }
  
<span class="udiff-line-removed">-     // 3.4.1.2 Object Store Storage Operation</span>
<span class="udiff-line-removed">-     // If ObjectStore has a key path and the key is autogenerated, then inject the key into the value</span>
<span class="udiff-line-removed">-     // using steps to assign a key to a value using a key path.</span>
<span class="udiff-line-removed">-     ThreadSafeDataBuffer injectedRecordValue;</span>
<span class="udiff-line-removed">-     if (usedKeyIsGenerated &amp;&amp; objectStoreInfo-&gt;keyPath()) {</span>
<span class="udiff-line-removed">-         VM&amp; vm = databaseThreadVM();</span>
<span class="udiff-line-removed">-         JSLockHolder locker(vm);</span>
<span class="udiff-line-removed">-         auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         auto value = deserializeIDBValueToJSValue(databaseThreadExecState(), originalRecordValue.data());</span>
<span class="udiff-line-removed">-         if (value.isUndefined()) {</span>
<span class="udiff-line-removed">-             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, IDBError(ConstraintError, &quot;Unable to deserialize record value for record key injection&quot;_s), usedKey));</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (!injectIDBKeyIntoScriptValue(databaseThreadExecState(), usedKey, value, objectStoreInfo-&gt;keyPath().value())) {</span>
<span class="udiff-line-removed">-             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, IDBError(ConstraintError, &quot;Unable to inject record key into record value&quot;_s), usedKey));</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         auto serializedValue = SerializedScriptValue::create(databaseThreadExecState(), value);</span>
<span class="udiff-line-removed">-         if (UNLIKELY(scope.exception())) {</span>
<span class="udiff-line-removed">-             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, IDBError(ConstraintError, &quot;Unable to serialize record value after injecting record key&quot;_s), usedKey));</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         injectedRecordValue = ThreadSafeDataBuffer::copyVector(serializedValue-&gt;data());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      // 3.4.1 Object Store Storage Operation
      // ...If a record already exists in store ...
      // then remove the record from store using the steps for deleting records from an object store...
      // This is important because formally deleting it from from the object store also removes it from the appropriate indexes.
      error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, usedKey);
      if (!error.isNull()) {
          postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
          return;
      }
  
<span class="udiff-line-modified-removed">-     if (injectedRecordValue.data())</span>
<span class="udiff-line-removed">-         error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, { injectedRecordValue, originalRecordValue.blobURLs(), originalRecordValue.sessionID(), originalRecordValue.blobFilePaths() });</span>
<span class="udiff-line-removed">-     else</span>
<span class="udiff-line-removed">-         error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, originalRecordValue);</span>
<span class="udiff-line-modified-added">+     error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, originalRecordValue);</span>
  
      if (!error.isNull()) {
          postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1091,10 +1333,21 @@</span>
  void UniqueIDBDatabase::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getRecord&quot;);
  
<span class="udiff-line-added">+     waitForRequestSpaceCompletion([this, requestData, getRecordData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="udiff-line-added">+         if (error) {</span>
<span class="udiff-line-added">+             callback(WTFMove(*error), { });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this-&gt;getRecordAfterQuotaCheck(requestData, getRecordData, WTFMove(callback));</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::getRecordAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)</span>
<span class="udiff-line-added">+ {</span>
      uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
      if (!callbackID)
          return;
  
      if (uint64_t indexIdentifier = requestData.indexIdentifier())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1106,10 +1359,21 @@</span>
  void UniqueIDBDatabase::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getAllRecords&quot;);
  
<span class="udiff-line-added">+     waitForRequestSpaceCompletion([this, requestData, getAllRecordsData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="udiff-line-added">+         if (error) {</span>
<span class="udiff-line-added">+             callback(WTFMove(*error), { });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this-&gt;getAllRecordsAfterQuotaCheck(requestData, getAllRecordsData, WTFMove(callback));</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::getAllRecordsAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)</span>
<span class="udiff-line-added">+ {</span>
      uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
      if (!callbackID)
          return;
  
      postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetAllRecords, callbackID, requestData.transactionIdentifier(), getAllRecordsData));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1173,10 +1437,21 @@</span>
  void UniqueIDBDatabase::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getCount&quot;);
  
<span class="udiff-line-added">+     waitForRequestSpaceCompletion([this, requestData, range, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="udiff-line-added">+         if (error) {</span>
<span class="udiff-line-added">+             callback(WTFMove(*error), { });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this-&gt;getCountAfterQuotaCheck(requestData, range, WTFMove(callback));</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::getCountAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)</span>
<span class="udiff-line-added">+ {</span>
      uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
      if (!callbackID)
          return;
      postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetCount, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), requestData.indexIdentifier(), range));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1206,10 +1481,21 @@</span>
  void UniqueIDBDatabase::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteRecord&quot;);
  
<span class="udiff-line-added">+     waitForRequestSpaceCompletion([this, requestData, keyRangeData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="udiff-line-added">+         if (error) {</span>
<span class="udiff-line-added">+             callback(WTFMove(*error));</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this-&gt;deleteRecordAfterQuotaCheck(requestData, keyRangeData, WTFMove(callback));</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::deleteRecordAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)</span>
<span class="udiff-line-added">+ {</span>
      uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
      if (!callbackID)
          return;
      postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyRangeData));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1235,10 +1521,21 @@</span>
  void UniqueIDBDatabase::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::openCursor&quot;);
  
<span class="udiff-line-added">+     waitForRequestSpaceCompletion([this, requestData, info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="udiff-line-added">+         if (error) {</span>
<span class="udiff-line-added">+             callback(WTFMove(*error), { });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this-&gt;openCursorAfterQuotaCheck(requestData, info, WTFMove(callback));</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::openCursorAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)</span>
<span class="udiff-line-added">+ {</span>
      uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
      if (!callbackID)
          return;
      postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performOpenCursor, callbackID, requestData.transactionIdentifier(), info));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1265,10 +1562,21 @@</span>
  void UniqueIDBDatabase::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::iterateCursor&quot;);
  
<span class="udiff-line-added">+     waitForRequestSpaceCompletion([this, requestData, data, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="udiff-line-added">+         if (error) {</span>
<span class="udiff-line-added">+             callback(WTFMove(*error), { });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this-&gt;iterateCursorAfterQuotaCheck(requestData, data, WTFMove(callback));</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::iterateCursorAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)</span>
<span class="udiff-line-added">+ {</span>
      uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
      if (!callbackID)
          return;
      postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performIterateCursor, callbackID, requestData.transactionIdentifier(), requestData.cursorIdentifier(), data));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1308,17 +1616,18 @@</span>
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformIterateCursor&quot;);
  
      performGetResultCallback(callbackIdentifier, error, result);
  }
  
<span class="udiff-line-modified-removed">- bool UniqueIDBDatabase::prepareToFinishTransaction(UniqueIDBDatabaseTransaction&amp; transaction)</span>
<span class="udiff-line-modified-added">+ bool UniqueIDBDatabase::prepareToFinishTransaction(UniqueIDBDatabaseTransaction&amp; transaction, UniqueIDBDatabaseTransaction::State state)</span>
  {
      auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());
      if (!takenTransaction)
          return false;
  
      ASSERT(!m_finishingTransactions.contains(transaction.info().identifier()));
<span class="udiff-line-added">+     takenTransaction-&gt;setState(state);</span>
      m_finishingTransactions.set(transaction.info().identifier(), WTFMove(takenTransaction));
  
      return true;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1327,15 +1636,30 @@</span>
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::commitTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());
  
      ASSERT(transaction.databaseConnection().database() == this);
  
<span class="udiff-line-added">+     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), callback = WTFMove(callback)](auto error) mutable {</span>
<span class="udiff-line-added">+         if (error) {</span>
<span class="udiff-line-added">+             callback(WTFMove(*error));</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (!transaction) {</span>
<span class="udiff-line-added">+             callback(IDBError { UnknownError });</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this-&gt;commitTransactionAfterQuotaCheck(*transaction, WTFMove(callback));</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::commitTransactionAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)</span>
<span class="udiff-line-added">+ {</span>
      uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
      if (!callbackID)
          return;
  
<span class="udiff-line-modified-removed">-     if (!prepareToFinishTransaction(transaction)) {</span>
<span class="udiff-line-modified-added">+     if (!prepareToFinishTransaction(transaction, UniqueIDBDatabaseTransaction::State::Committing)) {</span>
          if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {
              // This database connection is closing or has already closed, so there is no point in messaging back to it about the commit failing.
              forgetErrorCallback(callbackID);
              return;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1359,27 +1683,58 @@</span>
  void UniqueIDBDatabase::didPerformCommitTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
  
<span class="udiff-line-modified-removed">-     performErrorCallback(callbackIdentifier, error);</span>
<span class="udiff-line-modified-added">+     IDBError result = error;</span>
<span class="udiff-line-added">+     auto transaction = m_finishingTransactions.get(transactionIdentifier);</span>
<span class="udiff-line-added">+     switch (transaction-&gt;state()) {</span>
<span class="udiff-line-added">+     case UniqueIDBDatabaseTransaction::State::Aborted:</span>
<span class="udiff-line-added">+         result = IDBError { UnknownError, &quot;Transaction is already aborted&quot;_s };</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case UniqueIDBDatabaseTransaction::State::Committed:</span>
<span class="udiff-line-added">+         result = transaction-&gt;result();</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case UniqueIDBDatabaseTransaction::State::Committing:</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case UniqueIDBDatabaseTransaction::State::Running:</span>
<span class="udiff-line-added">+     case UniqueIDBDatabaseTransaction::State::Aborting:</span>
<span class="udiff-line-added">+         ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     performErrorCallback(callbackIdentifier, result);</span>
  
      transactionCompleted(m_finishingTransactions.take(transactionIdentifier));
  }
  
<span class="udiff-line-modified-removed">- void UniqueIDBDatabase::abortTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)</span>
<span class="udiff-line-modified-added">+ void UniqueIDBDatabase::abortTransaction(UniqueIDBDatabaseTransaction&amp; transaction, WaitForPendingTasks waitForPendingTasks, ErrorCallback callback)</span>
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::abortTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());
  
      ASSERT(transaction.databaseConnection().database() == this);
  
<span class="udiff-line-added">+     if (waitForPendingTasks == WaitForPendingTasks::Yes) {</span>
<span class="udiff-line-added">+         waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), callback = WTFMove(callback)](auto&amp;&amp; error) mutable {</span>
<span class="udiff-line-added">+             if (error) {</span>
<span class="udiff-line-added">+                 callback(WTFMove(*error));</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (!transaction) {</span>
<span class="udiff-line-added">+                 callback(IDBError { UnknownError });</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             this-&gt;abortTransaction(*transaction, WaitForPendingTasks::No, WTFMove(callback));</span>
<span class="udiff-line-added">+         });</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
      if (!callbackID)
          return;
  
<span class="udiff-line-modified-removed">-     if (!prepareToFinishTransaction(transaction)) {</span>
<span class="udiff-line-modified-added">+     if (!prepareToFinishTransaction(transaction, UniqueIDBDatabaseTransaction::State::Aborting)) {</span>
          if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {
              // This database connection is closing or has already closed, so there is no point in messaging back to it about the abort failing.
              forgetErrorCallback(callbackID);
              return;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1429,14 +1784,15 @@</span>
  
      if (m_versionChangeTransaction &amp;&amp; m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier) {
          ASSERT(m_versionChangeTransaction == transaction);
          ASSERT(!m_versionChangeDatabaseConnection || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
          ASSERT(m_versionChangeTransaction-&gt;originalDatabaseInfo());
<span class="udiff-line-modified-removed">-         m_databaseInfo = std::make_unique&lt;IDBDatabaseInfo&gt;(*m_versionChangeTransaction-&gt;originalDatabaseInfo());</span>
<span class="udiff-line-modified-added">+         m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(*m_versionChangeTransaction-&gt;originalDatabaseInfo());</span>
      }
  
<span class="udiff-line-modified-removed">-     performErrorCallback(callbackIdentifier, error);</span>
<span class="udiff-line-modified-added">+     IDBError result = transaction-&gt;state() == UniqueIDBDatabaseTransaction::State::Aborted ? transaction-&gt;result() : error;</span>
<span class="udiff-line-added">+     performErrorCallback(callbackIdentifier, result);</span>
  
      transactionCompleted(WTFMove(transaction));
  }
  
  void UniqueIDBDatabase::transactionDestroyed(UniqueIDBDatabaseTransaction&amp; transaction)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1448,10 +1804,17 @@</span>
  void UniqueIDBDatabase::connectionClosedFromClient(UniqueIDBDatabaseConnection&amp; connection)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::connectionClosedFromClient - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
  
<span class="udiff-line-added">+     if (m_serverClosePendingDatabaseConnections.contains(&amp;connection)) {</span>
<span class="udiff-line-added">+         m_serverClosePendingDatabaseConnections.remove(&amp;connection);</span>
<span class="udiff-line-added">+         if (m_hardClosedForUserDelete)</span>
<span class="udiff-line-added">+             maybeFinishHardClose();</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
      m_openDatabaseConnections.remove(&amp;connection);
  
      if (m_versionChangeDatabaseConnection == &amp;connection) {
          if (m_versionChangeTransaction) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1527,14 +1890,16 @@</span>
  void UniqueIDBDatabase::confirmDidCloseFromServer(UniqueIDBDatabaseConnection&amp; connection)
  {
      ASSERT(isMainThread());
      LOG(IndexedDB, &quot;UniqueIDBDatabase::confirmDidCloseFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
  
<span class="udiff-line-added">+     if (!m_serverClosePendingDatabaseConnections.contains(&amp;connection))</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     m_serverClosePendingDatabaseConnections.remove(&amp;connection);</span>
<span class="udiff-line-added">+ </span>
      if (m_hardClosedForUserDelete)
          maybeFinishHardClose();
<span class="udiff-line-removed">-     ASSERT(m_serverClosePendingDatabaseConnections.contains(&amp;connection));</span>
<span class="udiff-line-removed">-     m_serverClosePendingDatabaseConnections.remove(&amp;connection);</span>
  }
  
  void UniqueIDBDatabase::enqueueTransaction(Ref&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
  {
      LOG(IndexedDB, &quot;UniqueIDBDatabase::enqueueTransaction - %s&quot;, transaction-&gt;info().loggingString().utf8().data());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1757,17 +2122,20 @@</span>
  }
  
  void UniqueIDBDatabase::postDatabaseTask(CrossThreadTask&amp;&amp; task)
  {
      m_databaseQueue.append(WTFMove(task));
<span class="udiff-line-modified-removed">-     m_server.postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTask));</span>
<span class="udiff-line-modified-added">+     m_server-&gt;postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTask));</span>
  }
  
  void UniqueIDBDatabase::postDatabaseTaskReply(CrossThreadTask&amp;&amp; task)
  {
<span class="udiff-line-added">+     if (m_backingStore)</span>
<span class="udiff-line-added">+         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="udiff-line-added">+ </span>
      m_databaseReplyQueue.append(WTFMove(task));
<span class="udiff-line-modified-removed">-     m_server.postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTaskReply));</span>
<span class="udiff-line-modified-added">+     m_server-&gt;postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTaskReply));</span>
  }
  
  void UniqueIDBDatabase::executeNextDatabaseTask()
  {
      ASSERT(!isMainThread());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1826,10 +2194,13 @@</span>
  {
      LOG(IndexedDB, &quot;UniqueIDBDatabase::immediateCloseForUserDelete - Cancelling (%i, %i, %i, %i) callbacks&quot;, m_errorCallbacks.size(), m_keyDataCallbacks.size(), m_getResultCallbacks.size(), m_countCallbacks.size());
  
      ASSERT(isMainThread());
  
<span class="udiff-line-added">+     m_pendingSpaceIncreasingTasks.clear();</span>
<span class="udiff-line-added">+     m_server-&gt;resetSpaceUsed(m_identifier.origin());</span>
<span class="udiff-line-added">+ </span>
      // Error out all transactions
      for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys()))
          m_inProgressTransactions.get(identifier)-&gt;abortWithoutCallback();
  
      ASSERT(m_inProgressTransactions.isEmpty());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1876,10 +2247,15 @@</span>
      // Close all open connections
      auto openDatabaseConnections = m_openDatabaseConnections;
      for (auto&amp; connection : openDatabaseConnections)
          connectionClosedFromServer(*connection);
  
<span class="udiff-line-added">+     if (m_versionChangeDatabaseConnection) {</span>
<span class="udiff-line-added">+         connectionClosedFromServer(*m_versionChangeDatabaseConnection);</span>
<span class="udiff-line-added">+         m_versionChangeDatabaseConnection = nullptr;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      // Cancel the operation timer
      m_operationAndTransactionTimer.stop();
  
      // Set up the database to remain alive-but-inert until all of its background activity finishes and all
      // database connections confirm that they have closed.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1891,16 +2267,41 @@</span>
      if (m_owningPointerForClose)
          return;
  
      // Otherwise, this database is still potentially active.
      // So we&#39;ll have it own itself and then perform a clean unconditional delete on the background thread.
<span class="udiff-line-modified-removed">-     m_owningPointerForClose = m_server.closeAndTakeUniqueIDBDatabase(*this);</span>
<span class="udiff-line-modified-added">+     m_owningPointerForClose = m_server-&gt;closeAndTakeUniqueIDBDatabase(*this);</span>
      postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performUnconditionalDeleteBackingStore));
  }
  
<span class="udiff-line-added">+ void UniqueIDBDatabase::updateSpaceUsedIfNeeded(Optional&lt;uint64_t&gt; optionalCallbackIdentifier)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(isMainThread());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (optionalCallbackIdentifier) {</span>
<span class="udiff-line-added">+         uint64_t callbackIdentifier = optionalCallbackIdentifier.value();</span>
<span class="udiff-line-added">+         auto iterator = m_pendingSpaceIncreasingTasks.find(callbackIdentifier);</span>
<span class="udiff-line-added">+         if (iterator != m_pendingSpaceIncreasingTasks.end()) {</span>
<span class="udiff-line-added">+             m_server-&gt;decreasePotentialSpaceUsed(m_identifier.origin(), iterator-&gt;value);</span>
<span class="udiff-line-added">+             m_pendingSpaceIncreasingTasks.remove(iterator);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     uint64_t databaseSize = m_newDatabaseSize;</span>
<span class="udiff-line-added">+     if (databaseSize != m_currentDatabaseSize) {</span>
<span class="udiff-line-added">+         if (databaseSize &gt; m_currentDatabaseSize)</span>
<span class="udiff-line-added">+             m_server-&gt;increaseSpaceUsed(m_identifier.origin(), databaseSize - m_currentDatabaseSize);</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             m_server-&gt;decreaseSpaceUsed(m_identifier.origin(), m_currentDatabaseSize - databaseSize);</span>
<span class="udiff-line-added">+         m_currentDatabaseSize = databaseSize;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void UniqueIDBDatabase::performErrorCallback(uint64_t callbackIdentifier, const IDBError&amp; error)
  {
<span class="udiff-line-added">+     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="udiff-line-added">+ </span>
      auto callback = m_errorCallbacks.take(callbackIdentifier);
      ASSERT(callback || m_hardClosedForUserDelete);
      if (callback) {
          callback(error);
          ASSERT(m_callbackQueue.first() == callbackIdentifier);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1908,10 +2309,12 @@</span>
      }
  }
  
  void UniqueIDBDatabase::performKeyDataCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)
  {
<span class="udiff-line-added">+     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="udiff-line-added">+ </span>
      auto callback = m_keyDataCallbacks.take(callbackIdentifier);
      ASSERT(callback || m_hardClosedForUserDelete);
      if (callback) {
          callback(error, resultKey);
          ASSERT(m_callbackQueue.first() == callbackIdentifier);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1952,20 +2355,57 @@</span>
      }
  }
  
  void UniqueIDBDatabase::forgetErrorCallback(uint64_t callbackIdentifier)
  {
<span class="udiff-line-added">+     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(m_errorCallbacks.contains(callbackIdentifier));
      ASSERT(m_callbackQueue.last() == callbackIdentifier);
      m_callbackQueue.removeLast();
      m_errorCallbacks.remove(callbackIdentifier);
  }
  
<span class="udiff-line-modified-removed">- void UniqueIDBDatabase::setQuota(uint64_t quota)</span>
<span class="udiff-line-modified-added">+ void UniqueIDBDatabase::abortTransactionOnMainThread(UniqueIDBDatabaseTransaction&amp; transaction)</span>
  {
<span class="udiff-line-modified-removed">-     if (m_backingStore)</span>
<span class="udiff-line-modified-removed">-         m_backingStore-&gt;setQuota(quota);</span>
<span class="udiff-line-modified-added">+     transaction.setResult(m_backingStore-&gt;abortTransaction(transaction.info().identifier()));</span>
<span class="udiff-line-modified-added">+     transaction.setState(UniqueIDBDatabaseTransaction::State::Aborted);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::commitTransactionOnMainThread(UniqueIDBDatabaseTransaction&amp; transaction)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     transaction.setResult(m_backingStore-&gt;commitTransaction(transaction.info().identifier()));</span>
<span class="udiff-line-added">+     transaction.setState(UniqueIDBDatabaseTransaction::State::Committed);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void UniqueIDBDatabase::finishActiveTransactions()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(isMainThread());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys())) {</span>
<span class="udiff-line-added">+         auto transaction = m_inProgressTransactions.get(identifier);</span>
<span class="udiff-line-added">+         abortTransactionOnMainThread(*transaction);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (auto&amp; identifier : copyToVector(m_finishingTransactions.keys())) {</span>
<span class="udiff-line-added">+         if (!m_backingStore-&gt;hasTransaction(identifier))</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         auto transaction = m_finishingTransactions.get(identifier);</span>
<span class="udiff-line-added">+         switch (transaction-&gt;state()) {</span>
<span class="udiff-line-added">+         case UniqueIDBDatabaseTransaction::State::Aborting:</span>
<span class="udiff-line-added">+             abortTransactionOnMainThread(*transaction);</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         case UniqueIDBDatabaseTransaction::State::Committing:</span>
<span class="udiff-line-added">+             commitTransactionOnMainThread(*transaction);</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         case UniqueIDBDatabaseTransaction::State::Running:</span>
<span class="udiff-line-added">+         case UniqueIDBDatabaseTransaction::State::Aborted:</span>
<span class="udiff-line-added">+         case UniqueIDBDatabaseTransaction::State::Committed:</span>
<span class="udiff-line-added">+             ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  }
  
  } // namespace IDBServer
  } // namespace WebCore
  
</pre>
<center><a href="SQLiteIDBTransaction.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="UniqueIDBDatabase.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>