<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webaudio/AudioContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AudioBufferSourceNode.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AudioContext.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webaudio/AudioContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -93,20 +93,24 @@</span>
  #include &quot;Settings.h&quot;
  #endif
  
  #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
  #include &lt;wtf/Atomics.h&gt;
<span class="udiff-line-added">+ #include &lt;wtf/IsoMallocInlines.h&gt;</span>
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/Ref.h&gt;
  #include &lt;wtf/RefCounted.h&gt;
<span class="udiff-line-added">+ #include &lt;wtf/Scope.h&gt;</span>
  #include &lt;wtf/text/WTFString.h&gt;
  
  const unsigned MaxPeriodicWaveLength = 4096;
  
  namespace WebCore {
  
<span class="udiff-line-modified-removed">- #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(document()-&gt;page() &amp;&amp; document()-&gt;page()-&gt;isAlwaysOnLoggingAllowed(), Media, &quot;%p - AudioContext::&quot; fmt, this, ##__VA_ARGS__)</span>
<span class="udiff-line-modified-added">+ WTF_MAKE_ISO_ALLOCATED_IMPL(AudioContext);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(document() &amp;&amp; document()-&gt;page() &amp;&amp; document()-&gt;page()-&gt;isAlwaysOnLoggingAllowed(), Media, &quot;%p - AudioContext::&quot; fmt, this, ##__VA_ARGS__)</span>
  
  bool AudioContext::isSampleRateRangeGood(float sampleRate)
  {
      // FIXME: It would be nice if the minimum sample-rate could be less than 44.1KHz,
      // but that will require some fixes in HRTFPanner::fftSizeForSampleRate(), and some testing there.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -129,45 +133,57 @@</span>
  }
  
  // Constructor for rendering to the audio hardware.
  AudioContext::AudioContext(Document&amp; document)
      : ActiveDOMObject(document)
<span class="udiff-line-added">+ #if !RELEASE_LOG_DISABLED</span>
<span class="udiff-line-added">+     , m_logger(document.logger())</span>
<span class="udiff-line-added">+     , m_logIdentifier(uniqueLogIdentifier())</span>
<span class="udiff-line-added">+ #endif</span>
      , m_mediaSession(PlatformMediaSession::create(*this))
<span class="udiff-line-modified-removed">-     , m_eventQueue(std::make_unique&lt;GenericEventQueue&gt;(*this))</span>
<span class="udiff-line-modified-added">+     , m_eventQueue(makeUnique&lt;GenericEventQueue&gt;(*this))</span>
  {
<span class="udiff-line-added">+     // According to spec AudioContext must die only after page navigate.</span>
<span class="udiff-line-added">+     // Lets mark it as ActiveDOMObject with pending activity and unmark it in clear method.</span>
<span class="udiff-line-added">+     makePendingActivity();</span>
<span class="udiff-line-added">+ </span>
      constructCommon();
  
      m_destinationNode = DefaultAudioDestinationNode::create(*this);
  
      // Initialize the destination node&#39;s muted state to match the page&#39;s current muted state.
      pageMutedStateDidChange();
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     document.addAudioProducer(*this);</span>
<span class="udiff-line-added">+     document.registerForVisibilityStateChangedCallbacks(*this);</span>
  }
  
  // Constructor for offline (non-realtime) rendering.
  AudioContext::AudioContext(Document&amp; document, unsigned numberOfChannels, size_t numberOfFrames, float sampleRate)
      : ActiveDOMObject(document)
<span class="udiff-line-added">+ #if !RELEASE_LOG_DISABLED</span>
<span class="udiff-line-added">+     , m_logger(document.logger())</span>
<span class="udiff-line-added">+     , m_logIdentifier(uniqueLogIdentifier())</span>
<span class="udiff-line-added">+ #endif</span>
      , m_isOfflineContext(true)
      , m_mediaSession(PlatformMediaSession::create(*this))
<span class="udiff-line-modified-removed">-     , m_eventQueue(std::make_unique&lt;GenericEventQueue&gt;(*this))</span>
<span class="udiff-line-modified-added">+     , m_eventQueue(makeUnique&lt;GenericEventQueue&gt;(*this))</span>
  {
      constructCommon();
  
      // Create a new destination for offline rendering.
      m_renderTarget = AudioBuffer::create(numberOfChannels, numberOfFrames, sampleRate);
      m_destinationNode = OfflineAudioDestinationNode::create(*this, m_renderTarget.get());
  }
  
  void AudioContext::constructCommon()
  {
<span class="udiff-line-removed">-     // According to spec AudioContext must die only after page navigate.</span>
<span class="udiff-line-removed">-     // Lets mark it as ActiveDOMObject with pending activity and unmark it in clear method.</span>
<span class="udiff-line-removed">-     setPendingActivity(*this);</span>
<span class="udiff-line-removed">- </span>
      FFTFrame::initialize();
  
      m_listener = AudioListener::create();
  
<span class="udiff-line-added">+     ASSERT(document());</span>
      if (document()-&gt;audioPlaybackRequiresUserGesture())
          addBehaviorRestriction(RequireUserGestureForAudioStartRestriction);
      else
          m_restrictions = NoRestrictions;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -189,14 +205,21 @@</span>
      ASSERT(m_automaticPullNodes.isEmpty());
      if (m_automaticPullNodesNeedUpdating)
          m_renderingAutomaticPullNodes.resize(m_automaticPullNodes.size());
      ASSERT(m_renderingAutomaticPullNodes.isEmpty());
      // FIXME: Can we assert that m_deferredFinishDerefList is empty?
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!isOfflineContext() &amp;&amp; scriptExecutionContext()) {</span>
<span class="udiff-line-added">+         document()-&gt;removeAudioProducer(*this);</span>
<span class="udiff-line-added">+         document()-&gt;unregisterForVisibilityStateChangedCallbacks(*this);</span>
<span class="udiff-line-added">+     }</span>
  }
  
  void AudioContext::lazyInitialize()
  {
<span class="udiff-line-added">+     ASSERT(!m_isStopScheduled);</span>
<span class="udiff-line-added">+ </span>
      if (m_isInitialized)
          return;
  
      // Don&#39;t allow the context to initialize a second time after it&#39;s already been explicitly uninitialized.
      ASSERT(!m_isAudioThreadFinished);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -205,13 +228,10 @@</span>
  
      if (m_destinationNode) {
          m_destinationNode-&gt;initialize();
  
          if (!isOfflineContext()) {
<span class="udiff-line-removed">-             document()-&gt;addAudioProducer(*this);</span>
<span class="udiff-line-removed">-             document()-&gt;registerForVisibilityStateChangedCallbacks(*this);</span>
<span class="udiff-line-removed">- </span>
              // This starts the audio thread. The destination node&#39;s provideInput() method will now be called repeatedly to render audio.
              // Each time provideInput() is called, a portion of the audio stream is rendered. Let&#39;s call this time period a &quot;render quantum&quot;.
              // NOTE: for now default AudioContext does not need an explicit startRendering() call from JavaScript.
              // We may want to consider requiring it for symmetry with OfflineAudioContext.
              startRendering();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -221,10 +241,12 @@</span>
      m_isInitialized = true;
  }
  
  void AudioContext::clear()
  {
<span class="udiff-line-added">+     Ref&lt;AudioContext&gt; protectedThis(*this);</span>
<span class="udiff-line-added">+ </span>
      // We have to release our reference to the destination node before the context will ever be deleted since the destination node holds a reference to the context.
      if (m_destinationNode)
          m_destinationNode = nullptr;
  
      // Audio thread is dead. Nobody will schedule node deletion action. Let&#39;s do it ourselves.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -232,31 +254,30 @@</span>
          deleteMarkedNodes();
          m_nodesToDelete.appendVector(m_nodesMarkedForDeletion);
          m_nodesMarkedForDeletion.clear();
      } while (m_nodesToDelete.size());
  
<span class="udiff-line-modified-removed">-     // It was set in constructCommon.</span>
<span class="udiff-line-removed">-     unsetPendingActivity(*this);</span>
<span class="udiff-line-modified-added">+     clearPendingActivity();</span>
  }
  
  void AudioContext::uninitialize()
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
  
      if (!m_isInitialized)
          return;
  
      // This stops the audio thread and all audio rendering.
<span class="udiff-line-modified-removed">-     m_destinationNode-&gt;uninitialize();</span>
<span class="udiff-line-modified-added">+     if (m_destinationNode)</span>
<span class="udiff-line-added">+         m_destinationNode-&gt;uninitialize();</span>
  
      // Don&#39;t allow the context to initialize a second time after it&#39;s already been explicitly uninitialized.
      m_isAudioThreadFinished = true;
  
      if (!isOfflineContext()) {
<span class="udiff-line-removed">-         document()-&gt;removeAudioProducer(*this);</span>
<span class="udiff-line-removed">-         document()-&gt;unregisterForVisibilityStateChangedCallbacks(*this);</span>
<span class="udiff-line-removed">- </span>
          ASSERT(s_hardwareContextCount);
          --s_hardwareContextCount;
  
          // Offline contexts move to &#39;Closed&#39; state when dispatching the completion event.
          setState(State::Closed);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -301,17 +322,20 @@</span>
          promise.resolve();
  }
  
  void AudioContext::stop()
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
  
      // Usually ScriptExecutionContext calls stop twice.
      if (m_isStopScheduled)
          return;
      m_isStopScheduled = true;
  
<span class="udiff-line-added">+     ASSERT(document());</span>
      document()-&gt;updateIsPlayingMedia();
  
      m_eventQueue-&gt;close();
  
      uninitialize();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -329,11 +353,10 @@</span>
      return &quot;AudioContext&quot;;
  }
  
  Document* AudioContext::document() const
  {
<span class="udiff-line-removed">-     ASSERT(m_scriptExecutionContext);</span>
      return downcast&lt;Document&gt;(m_scriptExecutionContext);
  }
  
  Document* AudioContext::hostingDocument() const
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -361,11 +384,11 @@</span>
  }
  
  void AudioContext::visibilityStateChanged()
  {
      // Do not suspend if audio is audible.
<span class="udiff-line-modified-removed">-     if (mediaState() == MediaProducer::IsPlayingAudio)</span>
<span class="udiff-line-modified-added">+     if (!document() || mediaState() == MediaProducer::IsPlayingAudio || m_isStopScheduled)</span>
          return;
  
      if (document()-&gt;hidden()) {
          if (state() == State::Running) {
              RELEASE_LOG_IF_ALLOWED(&quot;visibilityStateChanged() Suspending playback after going to the background&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -406,18 +429,26 @@</span>
      return audioBuffer.releaseNonNull();
  }
  
  void AudioContext::decodeAudioData(Ref&lt;ArrayBuffer&gt;&amp;&amp; audioData, RefPtr&lt;AudioBufferCallback&gt;&amp;&amp; successCallback, RefPtr&lt;AudioBufferCallback&gt;&amp;&amp; errorCallback)
  {
<span class="udiff-line-modified-removed">-     m_audioDecoder.decodeAsync(WTFMove(audioData), sampleRate(), WTFMove(successCallback), WTFMove(errorCallback));</span>
<span class="udiff-line-modified-added">+     if (!m_audioDecoder)</span>
<span class="udiff-line-added">+         m_audioDecoder = makeUnique&lt;AsyncAudioDecoder&gt;();</span>
<span class="udiff-line-added">+     m_audioDecoder-&gt;decodeAsync(WTFMove(audioData), sampleRate(), WTFMove(successCallback), WTFMove(errorCallback));</span>
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;AudioBufferSourceNode&gt; AudioContext::createBufferSource()</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;AudioBufferSourceNode&gt;&gt; AudioContext::createBufferSource()</span>
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      lazyInitialize();
<span class="udiff-line-modified-removed">-     Ref&lt;AudioBufferSourceNode&gt; node = AudioBufferSourceNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
<span class="udiff-line-modified-added">+     Ref&lt;AudioBufferSourceNode&gt; node = AudioBufferSourceNode::create(*this, sampleRate());</span>
  
      // Because this is an AudioScheduledSourceNode, the context keeps a reference until it has finished playing.
      // When this happens, AudioScheduledSourceNode::finish() calls AudioContext::notifyNodeFinishedProcessing().
      refNode(node);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -426,32 +457,40 @@</span>
  
  #if ENABLE(VIDEO)
  
  ExceptionOr&lt;Ref&lt;MediaElementAudioSourceNode&gt;&gt; AudioContext::createMediaElementSource(HTMLMediaElement&amp; mediaElement)
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-removed">-     lazyInitialize();</span>
  
<span class="udiff-line-modified-removed">-     if (mediaElement.audioSourceNode())</span>
<span class="udiff-line-modified-added">+     if (m_isStopScheduled || mediaElement.audioSourceNode())</span>
          return Exception { InvalidStateError };
  
<span class="udiff-line-added">+     lazyInitialize();</span>
<span class="udiff-line-added">+ </span>
      auto node = MediaElementAudioSourceNode::create(*this, mediaElement);
  
      mediaElement.setAudioSourceNode(node.ptr());
  
      refNode(node.get()); // context keeps reference until node is disconnected
<span class="udiff-line-modified-removed">-     return WTFMove(node);</span>
<span class="udiff-line-modified-added">+     return node;</span>
  }
  
  #endif
  
  #if ENABLE(MEDIA_STREAM)
  
  ExceptionOr&lt;Ref&lt;MediaStreamAudioSourceNode&gt;&gt; AudioContext::createMediaStreamSource(MediaStream&amp; mediaStream)
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
  
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      auto audioTracks = mediaStream.getAudioTracks();
      if (audioTracks.isEmpty())
          return Exception { InvalidStateError };
  
      MediaStreamTrack* providerTrack = nullptr;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -468,25 +507,34 @@</span>
  
      auto node = MediaStreamAudioSourceNode::create(*this, mediaStream, *providerTrack);
      node-&gt;setFormat(2, sampleRate());
  
      refNode(node); // context keeps reference until node is disconnected
<span class="udiff-line-modified-removed">-     return WTFMove(node);</span>
<span class="udiff-line-modified-added">+     return node;</span>
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;MediaStreamAudioDestinationNode&gt; AudioContext::createMediaStreamDestination()</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;MediaStreamAudioDestinationNode&gt;&gt; AudioContext::createMediaStreamDestination()</span>
  {
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      // FIXME: Add support for an optional argument which specifies the number of channels.
      // FIXME: The default should probably be stereo instead of mono.
      return MediaStreamAudioDestinationNode::create(*this, 1);
  }
  
  #endif
  
  ExceptionOr&lt;Ref&lt;ScriptProcessorNode&gt;&gt; AudioContext::createScriptProcessor(size_t bufferSize, size_t numberOfInputChannels, size_t numberOfOutputChannels)
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      lazyInitialize();
  
      // W3C Editor&#39;s Draft 06 June 2017
      //  https://webaudio.github.io/web-audio-api/#widl-BaseAudioContext-createScriptProcessor-ScriptProcessorNode-unsigned-long-bufferSize-unsigned-long-numberOfInputChannels-unsigned-long-numberOfOutputChannels
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -532,109 +580,170 @@</span>
      // up to 32 must be supported. A NotSupportedError must be thrown if the number of channels is not supported.
  
      if (numberOfOutputChannels &gt; maxNumberOfChannels())
          return Exception { NotSupportedError };
  
<span class="udiff-line-modified-removed">-     auto node = ScriptProcessorNode::create(*this, m_destinationNode-&gt;sampleRate(), bufferSize, numberOfInputChannels, numberOfOutputChannels);</span>
<span class="udiff-line-modified-added">+     auto node = ScriptProcessorNode::create(*this, sampleRate(), bufferSize, numberOfInputChannels, numberOfOutputChannels);</span>
  
      refNode(node); // context keeps reference until we stop making javascript rendering callbacks
<span class="udiff-line-modified-removed">-     return WTFMove(node);</span>
<span class="udiff-line-modified-added">+     return node;</span>
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;BiquadFilterNode&gt; AudioContext::createBiquadFilter()</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;BiquadFilterNode&gt;&gt; AudioContext::createBiquadFilter()</span>
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      lazyInitialize();
<span class="udiff-line-modified-removed">-     return BiquadFilterNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     return BiquadFilterNode::create(*this, sampleRate());</span>
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;WaveShaperNode&gt; AudioContext::createWaveShaper()</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;WaveShaperNode&gt;&gt; AudioContext::createWaveShaper()</span>
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      lazyInitialize();
      return WaveShaperNode::create(*this);
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;PannerNode&gt; AudioContext::createPanner()</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;PannerNode&gt;&gt; AudioContext::createPanner()</span>
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      lazyInitialize();
<span class="udiff-line-modified-removed">-     return PannerNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
<span class="udiff-line-modified-added">+     return PannerNode::create(*this, sampleRate());</span>
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;ConvolverNode&gt; AudioContext::createConvolver()</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;ConvolverNode&gt;&gt; AudioContext::createConvolver()</span>
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      lazyInitialize();
<span class="udiff-line-modified-removed">-     return ConvolverNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
<span class="udiff-line-modified-added">+     return ConvolverNode::create(*this, sampleRate());</span>
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;DynamicsCompressorNode&gt; AudioContext::createDynamicsCompressor()</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;DynamicsCompressorNode&gt;&gt; AudioContext::createDynamicsCompressor()</span>
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      lazyInitialize();
<span class="udiff-line-modified-removed">-     return DynamicsCompressorNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
<span class="udiff-line-modified-added">+     return DynamicsCompressorNode::create(*this, sampleRate());</span>
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;AnalyserNode&gt; AudioContext::createAnalyser()</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;AnalyserNode&gt;&gt; AudioContext::createAnalyser()</span>
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      lazyInitialize();
<span class="udiff-line-modified-removed">-     return AnalyserNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
<span class="udiff-line-modified-added">+     return AnalyserNode::create(*this, sampleRate());</span>
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;GainNode&gt; AudioContext::createGain()</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;GainNode&gt;&gt; AudioContext::createGain()</span>
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      lazyInitialize();
<span class="udiff-line-modified-removed">-     return GainNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
<span class="udiff-line-modified-added">+     return GainNode::create(*this, sampleRate());</span>
  }
  
  ExceptionOr&lt;Ref&lt;DelayNode&gt;&gt; AudioContext::createDelay(double maxDelayTime)
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      lazyInitialize();
<span class="udiff-line-modified-removed">-     return DelayNode::create(*this, m_destinationNode-&gt;sampleRate(), maxDelayTime);</span>
<span class="udiff-line-modified-added">+     return DelayNode::create(*this, sampleRate(), maxDelayTime);</span>
  }
  
  ExceptionOr&lt;Ref&lt;ChannelSplitterNode&gt;&gt; AudioContext::createChannelSplitter(size_t numberOfOutputs)
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      lazyInitialize();
<span class="udiff-line-modified-removed">-     auto node = ChannelSplitterNode::create(*this, m_destinationNode-&gt;sampleRate(), numberOfOutputs);</span>
<span class="udiff-line-modified-added">+     auto node = ChannelSplitterNode::create(*this, sampleRate(), numberOfOutputs);</span>
      if (!node)
          return Exception { IndexSizeError };
      return node.releaseNonNull();
  }
  
  ExceptionOr&lt;Ref&lt;ChannelMergerNode&gt;&gt; AudioContext::createChannelMerger(size_t numberOfInputs)
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      lazyInitialize();
<span class="udiff-line-modified-removed">-     auto node = ChannelMergerNode::create(*this, m_destinationNode-&gt;sampleRate(), numberOfInputs);</span>
<span class="udiff-line-modified-added">+     auto node = ChannelMergerNode::create(*this, sampleRate(), numberOfInputs);</span>
      if (!node)
          return Exception { IndexSizeError };
      return node.releaseNonNull();
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;OscillatorNode&gt; AudioContext::createOscillator()</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;OscillatorNode&gt;&gt; AudioContext::createOscillator()</span>
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      lazyInitialize();
  
<span class="udiff-line-modified-removed">-     Ref&lt;OscillatorNode&gt; node = OscillatorNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
<span class="udiff-line-modified-added">+     Ref&lt;OscillatorNode&gt; node = OscillatorNode::create(*this, sampleRate());</span>
  
      // Because this is an AudioScheduledSourceNode, the context keeps a reference until it has finished playing.
      // When this happens, AudioScheduledSourceNode::finish() calls AudioContext::notifyNodeFinishedProcessing().
      refNode(node);
  
      return node;
  }
  
  ExceptionOr&lt;Ref&lt;PeriodicWave&gt;&gt; AudioContext::createPeriodicWave(Float32Array&amp; real, Float32Array&amp; imaginary)
  {
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(isMainThread());
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError };</span>
<span class="udiff-line-added">+ </span>
      if (real.length() != imaginary.length() || (real.length() &gt; MaxPeriodicWaveLength) || !real.length())
          return Exception { IndexSizeError };
      lazyInitialize();
      return PeriodicWave::create(sampleRate(), real, imaginary);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -960,11 +1069,11 @@</span>
          node-&gt;processIfNecessary(framesToProcess);
  }
  
  ScriptExecutionContext* AudioContext::scriptExecutionContext() const
  {
<span class="udiff-line-modified-removed">-     return m_isStopScheduled ? 0 : ActiveDOMObject::scriptExecutionContext();</span>
<span class="udiff-line-modified-added">+     return ActiveDOMObject::scriptExecutionContext();</span>
  }
  
  void AudioContext::nodeWillBeginPlayback()
  {
      // Called by scheduled AudioNodes when clients schedule their start times.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -978,30 +1087,42 @@</span>
          startRendering();
  }
  
  bool AudioContext::willBeginPlayback()
  {
<span class="udiff-line-added">+     if (!document())</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
      if (userGestureRequiredForAudioStart()) {
<span class="udiff-line-modified-removed">-         if (!processingUserGestureForMedia() &amp;&amp; !document()-&gt;isCapturing())</span>
<span class="udiff-line-modified-added">+         if (!processingUserGestureForMedia() &amp;&amp; !document()-&gt;isCapturing()) {</span>
<span class="udiff-line-added">+             ALWAYS_LOG(LOGIDENTIFIER, &quot;returning false, not processing user gesture or capturing&quot;);</span>
              return false;
<span class="udiff-line-added">+         }</span>
          removeBehaviorRestriction(AudioContext::RequireUserGestureForAudioStartRestriction);
      }
  
      if (pageConsentRequiredForAudioStart()) {
          Page* page = document()-&gt;page();
          if (page &amp;&amp; !page-&gt;canStartMedia()) {
              document()-&gt;addMediaCanStartListener(*this);
<span class="udiff-line-added">+             ALWAYS_LOG(LOGIDENTIFIER, &quot;returning false, page doesn&#39;t allow media to start&quot;);</span>
              return false;
          }
          removeBehaviorRestriction(AudioContext::RequirePageConsentForAudioStartRestriction);
      }
  
<span class="udiff-line-modified-removed">-     return m_mediaSession-&gt;clientWillBeginPlayback();</span>
<span class="udiff-line-modified-added">+     auto willBegin = m_mediaSession-&gt;clientWillBeginPlayback();</span>
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER, &quot;returning &quot;, willBegin);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return willBegin;</span>
  }
  
  bool AudioContext::willPausePlayback()
  {
<span class="udiff-line-added">+     if (!document())</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
      if (userGestureRequiredForAudioStart()) {
          if (!processingUserGestureForMedia())
              return false;
          removeBehaviorRestriction(AudioContext::RequireUserGestureForAudioStartRestriction);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1018,13 +1139,16 @@</span>
      return m_mediaSession-&gt;clientWillPausePlayback();
  }
  
  void AudioContext::startRendering()
  {
<span class="udiff-line-modified-removed">-     if (!willBeginPlayback())</span>
<span class="udiff-line-modified-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+     if (m_isStopScheduled || !willBeginPlayback())</span>
          return;
  
<span class="udiff-line-added">+     makePendingActivity();</span>
<span class="udiff-line-added">+ </span>
      destination()-&gt;startRendering();
      setState(State::Running);
  }
  
  void AudioContext::mediaCanStart(Document&amp; document)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1042,11 +1166,11 @@</span>
      return MediaProducer::IsNotPlaying;
  }
  
  void AudioContext::pageMutedStateDidChange()
  {
<span class="udiff-line-modified-removed">-     if (m_destinationNode &amp;&amp; document()-&gt;page())</span>
<span class="udiff-line-modified-added">+     if (m_destinationNode &amp;&amp; document() &amp;&amp; document()-&gt;page())</span>
          m_destinationNode-&gt;setMuted(document()-&gt;page()-&gt;isAudioMuted());
  }
  
  void AudioContext::isPlayingAudioDidChange()
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1056,28 +1180,47 @@</span>
          if (protectedThis-&gt;document())
              protectedThis-&gt;document()-&gt;updateIsPlayingMedia();
      });
  }
  
<span class="udiff-line-modified-removed">- void AudioContext::fireCompletionEvent()</span>
<span class="udiff-line-modified-added">+ void AudioContext::finishedRendering(bool didRendering)</span>
  {
<span class="udiff-line-added">+     ASSERT(isOfflineContext());</span>
      ASSERT(isMainThread());
      if (!isMainThread())
          return;
  
<span class="udiff-line-added">+     auto clearPendingActivityIfExitEarly = WTF::makeScopeExit([this] {</span>
<span class="udiff-line-added">+         clearPendingActivity();</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!didRendering)</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
      AudioBuffer* renderedBuffer = m_renderTarget.get();
      setState(State::Closed);
  
      ASSERT(renderedBuffer);
      if (!renderedBuffer)
          return;
  
      // Avoid firing the event if the document has already gone away.
<span class="udiff-line-modified-removed">-     if (scriptExecutionContext()) {</span>
<span class="udiff-line-modified-removed">-         // Call the offline rendering completion event listener.</span>
<span class="udiff-line-modified-removed">-         m_eventQueue-&gt;enqueueEvent(OfflineAudioCompletionEvent::create(renderedBuffer));</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-modified-added">+         return;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     clearPendingActivityIfExitEarly.release();</span>
<span class="udiff-line-added">+     m_eventQueue-&gt;enqueueEvent(OfflineAudioCompletionEvent::create(renderedBuffer));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void AudioContext::dispatchEvent(Event&amp; event)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     EventTarget::dispatchEvent(event);</span>
<span class="udiff-line-added">+     if (event.eventInterface() == OfflineAudioCompletionEventInterfaceType)</span>
<span class="udiff-line-added">+         clearPendingActivity();</span>
  }
  
  void AudioContext::incrementActiveSourceCount()
  {
      ++m_activeSourceCount;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1088,11 +1231,11 @@</span>
      --m_activeSourceCount;
  }
  
  void AudioContext::suspend(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
  {
<span class="udiff-line-modified-removed">-     if (isOfflineContext()) {</span>
<span class="udiff-line-modified-added">+     if (isOfflineContext() || m_isStopScheduled) {</span>
          promise.reject(InvalidStateError);
          return;
      }
  
      if (m_state == State::Suspended) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1117,11 +1260,11 @@</span>
      });
  }
  
  void AudioContext::resume(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
  {
<span class="udiff-line-modified-removed">-     if (isOfflineContext()) {</span>
<span class="udiff-line-modified-added">+     if (isOfflineContext() || m_isStopScheduled) {</span>
          promise.reject(InvalidStateError);
          return;
      }
  
      if (m_state == State::Running) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1146,11 +1289,11 @@</span>
      });
  }
  
  void AudioContext::close(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
  {
<span class="udiff-line-modified-removed">-     if (isOfflineContext()) {</span>
<span class="udiff-line-modified-added">+     if (isOfflineContext() || m_isStopScheduled) {</span>
          promise.reject(InvalidStateError);
          return;
      }
  
      if (m_state == State::Closed || !m_destinationNode) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1206,9 +1349,51 @@</span>
      m_destinationNode-&gt;resume([this, protectedThis = makeRef(*this)] {
          setState(State::Running);
      });
  }
  
<span class="udiff-line-added">+ void AudioContext::postTask(WTF::Function&lt;void()&gt;&amp;&amp; task)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (m_isStopScheduled)</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_scriptExecutionContext-&gt;postTask(WTFMove(task));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ const SecurityOrigin* AudioContext::origin() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return m_scriptExecutionContext ? m_scriptExecutionContext-&gt;securityOrigin() : nullptr;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void AudioContext::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (m_scriptExecutionContext)</span>
<span class="udiff-line-added">+         m_scriptExecutionContext-&gt;addConsoleMessage(source, level, message);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void AudioContext::clearPendingActivity()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (!m_pendingActivity)</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     m_pendingActivity = nullptr;</span>
<span class="udiff-line-added">+     // FIXME: Remove this specific deref() and ref() call in makePendingActivity().</span>
<span class="udiff-line-added">+     deref();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void AudioContext::makePendingActivity()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (m_pendingActivity)</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     m_pendingActivity = ActiveDOMObject::makePendingActivity(*this);</span>
<span class="udiff-line-added">+     ref();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if !RELEASE_LOG_DISABLED</span>
<span class="udiff-line-added">+ WTFLogChannel&amp; AudioContext::logChannel() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return LogMedia;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif</span>
  
  } // namespace WebCore
  
  #endif // ENABLE(WEB_AUDIO)
</pre>
<center><a href="AudioBufferSourceNode.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AudioContext.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>