diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/RefCounted.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/RefCounted.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/RefCounted.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/RefCounted.h
@@ -20,10 +20,11 @@
 
 #pragma once
 
 #include <wtf/Assertions.h>
 #include <wtf/FastMalloc.h>
+#include <wtf/MainThread.h>
 #include <wtf/Noncopyable.h>
 
 namespace WTF {
 
 #if defined(NDEBUG) && !ENABLE(SECURITY_ASSERTIONS)
@@ -37,10 +38,12 @@
 // generated by the compiler (technique called template hoisting).
 class RefCountedBase {
 public:
     void ref() const
     {
+        applyRefDerefThreadingCheck();
+
 #if CHECK_REF_COUNTED_LIFECYCLE
         ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
         ASSERT(!m_adoptionIsRequired);
 #endif
         ++m_refCount;
@@ -66,20 +69,56 @@
         ASSERT(m_adoptionIsRequired);
         m_adoptionIsRequired = false;
 #endif
     }
 
+    // Please only call this method if you really know that what you're doing is safe (e.g.
+    // locking at call sites).
+    void disableThreadingChecks()
+    {
+#if !ASSERT_DISABLED
+        m_areThreadingChecksEnabled = false;
+#endif
+    }
+
+    static void enableThreadingChecksGlobally()
+    {
+#if !ASSERT_DISABLED
+        areThreadingChecksEnabledGlobally = true;
+#endif
+    }
+
 protected:
     RefCountedBase()
         : m_refCount(1)
+#if !ASSERT_DISABLED
+        , m_isOwnedByMainThread(isMainThreadIfInitialized())
+        , m_areThreadingChecksEnabled(isMainThreadInitialized())
+#endif
 #if CHECK_REF_COUNTED_LIFECYCLE
         , m_deletionHasBegun(false)
         , m_adoptionIsRequired(true)
 #endif
     {
     }
 
+    void applyRefDerefThreadingCheck() const
+    {
+#if !ASSERT_DISABLED
+        if (hasOneRef()) {
+            // Likely an ownership transfer across threads that may be safe.
+            m_isOwnedByMainThread = isMainThreadIfInitialized();
+        } else if (areThreadingChecksEnabledGlobally && m_areThreadingChecksEnabled) {
+            // If you hit this assertion, it means that the RefCounted object was ref/deref'd
+            // from both the main thread and another in a way that is likely concurrent and unsafe.
+            // Derive from ThreadSafeRefCounted and make sure the destructor is safe on threads
+            // that call deref, or ref/deref from a single thread.
+            ASSERT_WITH_MESSAGE(m_isOwnedByMainThread == isMainThread(), "Unsafe to ref/deref from different threads");
+        }
+#endif
+    }
+
     ~RefCountedBase()
     {
 #if CHECK_REF_COUNTED_LIFECYCLE
         ASSERT(m_deletionHasBegun);
         ASSERT(!m_adoptionIsRequired);
@@ -87,10 +126,12 @@
     }
 
     // Returns whether the pointer should be freed or not.
     bool derefBase() const
     {
+        applyRefDerefThreadingCheck();
+
 #if CHECK_REF_COUNTED_LIFECYCLE
         ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
         ASSERT(!m_adoptionIsRequired);
 #endif
 
@@ -118,10 +159,15 @@
 #if CHECK_REF_COUNTED_LIFECYCLE
     friend void adopted(RefCountedBase*);
 #endif
 
     mutable unsigned m_refCount;
+#if !ASSERT_DISABLED
+    mutable bool m_isOwnedByMainThread;
+    bool m_areThreadingChecksEnabled { true };
+    WTF_EXPORT_PRIVATE static bool areThreadingChecksEnabledGlobally;
+#endif
 #if CHECK_REF_COUNTED_LIFECYCLE
     mutable bool m_deletionHasBegun;
     mutable bool m_adoptionIsRequired;
 #endif
 };
@@ -134,17 +180,17 @@
     ASSERT_WITH_SECURITY_IMPLICATION(!object->m_deletionHasBegun);
     object->m_adoptionIsRequired = false;
 }
 #endif
 
-template<typename T> class RefCounted : public RefCountedBase {
+template<typename T, typename Deleter = std::default_delete<T>> class RefCounted : public RefCountedBase {
     WTF_MAKE_NONCOPYABLE(RefCounted); WTF_MAKE_FAST_ALLOCATED;
 public:
     void deref() const
     {
         if (derefBase())
-            delete static_cast<const T*>(this);
+            Deleter()(const_cast<T*>(static_cast<const T*>(this)));
     }
 
 protected:
     RefCounted() { }
     ~RefCounted()
