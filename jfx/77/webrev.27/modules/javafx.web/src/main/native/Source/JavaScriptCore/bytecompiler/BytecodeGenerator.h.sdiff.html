<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeGenerator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NodesCodegen.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   4  * Copyright (C) 2012 Igalia, S.L.
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  *
  10  * 1.  Redistributions of source code must retain the above copyright
  11  *     notice, this list of conditions and the following disclaimer.
  12  * 2.  Redistributions in binary form must reproduce the above copyright
  13  *     notice, this list of conditions and the following disclaimer in the
  14  *     documentation and/or other materials provided with the distribution.
  15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16  *     its contributors may be used to endorse or promote products derived
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
</pre>
<hr />
<pre>
  32 
  33 #include &quot;CodeBlock.h&quot;
  34 #include &quot;Instruction.h&quot;
  35 #include &quot;Interpreter.h&quot;
  36 #include &quot;JSAsyncGeneratorFunction.h&quot;
  37 #include &quot;JSBigInt.h&quot;
  38 #include &quot;JSGeneratorFunction.h&quot;
  39 #include &quot;JSTemplateObjectDescriptor.h&quot;
  40 #include &quot;Label.h&quot;
  41 #include &quot;LabelScope.h&quot;
  42 #include &quot;Nodes.h&quot;
  43 #include &quot;ParserError.h&quot;
  44 #include &quot;ProfileTypeBytecodeFlag.h&quot;
  45 #include &quot;RegisterID.h&quot;
  46 #include &quot;StaticPropertyAnalyzer.h&quot;
  47 #include &quot;SymbolTable.h&quot;
  48 #include &quot;UnlinkedCodeBlock.h&quot;
  49 #include &lt;functional&gt;
  50 #include &lt;wtf/CheckedArithmetic.h&gt;
  51 #include &lt;wtf/HashFunctions.h&gt;

  52 #include &lt;wtf/SegmentedVector.h&gt;
  53 #include &lt;wtf/SetForScope.h&gt;
  54 #include &lt;wtf/Vector.h&gt;
  55 
  56 namespace JSC {
  57 
  58     class JSImmutableButterfly;
  59     class Identifier;
  60     class IndexedForInContext;
  61     class StructureForInContext;
  62 
  63     enum ExpectedFunction {
  64         NoExpectedFunction,
  65         ExpectObjectConstructor,
  66         ExpectArrayConstructor
  67     };
  68 
  69     enum class EmitAwait { Yes, No };
  70 
  71     enum class DebuggableCall { Yes, No };
</pre>
<hr />
<pre>
  81         unsigned argumentCountIncludingThis() { return m_argv.size() - m_padding; }
  82         ArgumentsNode* argumentsNode() { return m_argumentsNode; }
  83 
  84     private:
  85         ArgumentsNode* m_argumentsNode;
  86         Vector&lt;RefPtr&lt;RegisterID&gt;, 8, UnsafeVectorOverflow&gt; m_argv;
  87         unsigned m_padding;
  88     };
  89 
  90     // https://tc39.github.io/ecma262/#sec-completion-record-specification-type
  91     //
  92     // For the Break and Continue cases, instead of using the Break and Continue enum values
  93     // below, we use the unique jumpID of the break and continue statement as the encoding
  94     // for the CompletionType value. emitFinallyCompletion() uses this jumpID value later
  95     // to determine the appropriate jump target to jump to after executing the relevant finally
  96     // blocks. The jumpID is computed as:
  97     //     jumpID = bytecodeOffset (of the break/continue node) + CompletionType::NumberOfTypes.
  98     // Hence, there won&#39;t be any collision between jumpIDs and CompletionType enums.
  99     enum class CompletionType : int {
 100         Normal,
<span class="line-removed"> 101         Break,</span>
<span class="line-removed"> 102         Continue,</span>
<span class="line-removed"> 103         Return,</span>
 104         Throw,
<span class="line-modified"> 105 </span>
 106         NumberOfTypes
 107     };
 108 
 109     inline CompletionType bytecodeOffsetToJumpID(unsigned offset)
 110     {
 111         int jumpIDAsInt = offset + static_cast&lt;int&gt;(CompletionType::NumberOfTypes);
 112         ASSERT(jumpIDAsInt &gt;= static_cast&lt;int&gt;(CompletionType::NumberOfTypes));
 113         return static_cast&lt;CompletionType&gt;(jumpIDAsInt);
 114     }
 115 
 116     struct FinallyJump {
 117         FinallyJump(CompletionType jumpID, int targetLexicalScopeIndex, Label&amp; targetLabel)
 118             : jumpID(jumpID)
 119             , targetLexicalScopeIndex(targetLexicalScopeIndex)
 120             , targetLabel(targetLabel)
 121         { }
 122 
 123         CompletionType jumpID;
 124         int targetLexicalScopeIndex;
 125         Ref&lt;Label&gt; targetLabel;
 126     };
 127 
<span class="line-modified"> 128     struct FinallyContext {</span>

 129         FinallyContext() { }
<span class="line-modified"> 130         FinallyContext(FinallyContext* outerContext, Label&amp; finallyLabel)</span>
<span class="line-removed"> 131             : m_outerContext(outerContext)</span>
<span class="line-removed"> 132             , m_finallyLabel(&amp;finallyLabel)</span>
<span class="line-removed"> 133         {</span>
<span class="line-removed"> 134             ASSERT(m_jumps.isEmpty());</span>
<span class="line-removed"> 135         }</span>
 136 
 137         FinallyContext* outerContext() const { return m_outerContext; }
 138         Label* finallyLabel() const { return m_finallyLabel; }
 139 



 140         uint32_t numberOfBreaksOrContinues() const { return m_numberOfBreaksOrContinues.unsafeGet(); }
 141         void incNumberOfBreaksOrContinues() { m_numberOfBreaksOrContinues++; }
 142 
 143         bool handlesReturns() const { return m_handlesReturns; }
 144         void setHandlesReturns() { m_handlesReturns = true; }
 145 
 146         void registerJump(CompletionType jumpID, int lexicalScopeIndex, Label&amp; targetLabel)
 147         {
 148             m_jumps.append(FinallyJump(jumpID, lexicalScopeIndex, targetLabel));
 149         }
 150 
 151         size_t numberOfJumps() const { return m_jumps.size(); }
 152         FinallyJump&amp; jumps(size_t i) { return m_jumps[i]; }
 153 
 154     private:
 155         FinallyContext* m_outerContext { nullptr };
 156         Label* m_finallyLabel { nullptr };
 157         Checked&lt;uint32_t, WTF::CrashOnOverflow&gt; m_numberOfBreaksOrContinues;
 158         bool m_handlesReturns { false };
 159         Vector&lt;FinallyJump&gt; m_jumps;




 160     };
 161 
 162     struct ControlFlowScope {
 163         typedef uint8_t Type;
 164         enum {
 165             Label,
 166             Finally
 167         };
<span class="line-modified"> 168         ControlFlowScope(Type type, int lexicalScopeIndex, FinallyContext&amp;&amp; finallyContext = FinallyContext())</span>
 169             : type(type)
 170             , lexicalScopeIndex(lexicalScopeIndex)
<span class="line-modified"> 171             , finallyContext(std::forward&lt;FinallyContext&gt;(finallyContext))</span>
 172         { }
 173 
 174         bool isLabelScope() const { return type == Label; }
 175         bool isFinallyScope() const { return type == Finally; }
 176 
 177         Type type;
 178         int lexicalScopeIndex;
<span class="line-modified"> 179         FinallyContext finallyContext;</span>
 180     };
 181 
 182     class ForInContext : public RefCounted&lt;ForInContext&gt; {
 183         WTF_MAKE_FAST_ALLOCATED;
 184         WTF_MAKE_NONCOPYABLE(ForInContext);
 185     public:
 186         virtual ~ForInContext() = default;
 187 
 188         bool isValid() const { return m_isValid; }
 189         void invalidate() { m_isValid = false; }
 190 
 191         enum class Type : uint8_t {
 192             IndexedForIn,
 193             StructureForIn
 194         };
 195 
 196         Type type() const { return m_type; }
 197         bool isIndexedForInContext() const { return m_type == Type::IndexedForIn; }
 198         bool isStructureForInContext() const { return m_type == Type::StructureForIn; }
 199 
</pre>
<hr />
<pre>
 347         Identifier m_ident;
 348         VarOffset m_offset;
 349         RegisterID* m_local;
 350         unsigned m_attributes;
 351         VariableKind m_kind;
 352         int m_symbolTableConstantIndex;
 353         bool m_isLexicallyScoped;
 354     };
 355 
 356     struct TryRange {
 357         Ref&lt;Label&gt; start;
 358         Ref&lt;Label&gt; end;
 359         TryData* tryData;
 360     };
 361 
 362     class BytecodeGenerator {
 363         WTF_MAKE_FAST_ALLOCATED;
 364         WTF_MAKE_NONCOPYABLE(BytecodeGenerator);
 365 
 366         friend class BoundLabel;

 367         friend class Label;
 368         friend class IndexedForInContext;
 369         friend class StructureForInContext;
 370     public:
 371         typedef DeclarationStacks::FunctionStack FunctionStack;
 372 
<span class="line-modified"> 373         BytecodeGenerator(VM&amp;, ProgramNode*, UnlinkedProgramCodeBlock*, DebuggerMode, const VariableEnvironment*);</span>
<span class="line-modified"> 374         BytecodeGenerator(VM&amp;, FunctionNode*, UnlinkedFunctionCodeBlock*, DebuggerMode, const VariableEnvironment*);</span>
<span class="line-modified"> 375         BytecodeGenerator(VM&amp;, EvalNode*, UnlinkedEvalCodeBlock*, DebuggerMode, const VariableEnvironment*);</span>
<span class="line-modified"> 376         BytecodeGenerator(VM&amp;, ModuleProgramNode*, UnlinkedModuleProgramCodeBlock*, DebuggerMode, const VariableEnvironment*);</span>
 377 
 378         ~BytecodeGenerator();
 379 
<span class="line-modified"> 380         VM* vm() const { return m_vm; }</span>
 381         ParserArena&amp; parserArena() const { return m_scopeNode-&gt;parserArena(); }
<span class="line-modified"> 382         const CommonIdentifiers&amp; propertyNames() const { return *m_vm-&gt;propertyNames; }</span>
 383 
 384         bool isConstructor() const { return m_codeBlock-&gt;isConstructor(); }
 385         DerivedContextType derivedContextType() const { return m_derivedContextType; }
 386         bool usesArrowFunction() const { return m_scopeNode-&gt;usesArrowFunction(); }
 387         bool needsToUpdateArrowFunctionContext() const { return m_needsToUpdateArrowFunctionContext; }
 388         bool usesEval() const { return m_scopeNode-&gt;usesEval(); }
 389         bool usesThis() const { return m_scopeNode-&gt;usesThis(); }
 390         ConstructorKind constructorKind() const { return m_codeBlock-&gt;constructorKind(); }
 391         SuperBinding superBinding() const { return m_codeBlock-&gt;superBinding(); }
 392         JSParserScriptMode scriptMode() const { return m_codeBlock-&gt;scriptMode(); }
 393 
 394         template&lt;typename Node, typename UnlinkedCodeBlock&gt;
<span class="line-modified"> 395         static ParserError generate(VM&amp; vm, Node* node, const SourceCode&amp; sourceCode, UnlinkedCodeBlock* unlinkedCodeBlock, DebuggerMode debuggerMode, const VariableEnvironment* environment)</span>
 396         {
 397             MonotonicTime before;
 398             if (UNLIKELY(Options::reportBytecodeCompileTimes()))
 399                 before = MonotonicTime::now();
 400 
 401             DeferGC deferGC(vm.heap);
<span class="line-modified"> 402             auto bytecodeGenerator = std::make_unique&lt;BytecodeGenerator&gt;(vm, node, unlinkedCodeBlock, debuggerMode, environment);</span>
 403             auto result = bytecodeGenerator-&gt;generate();
 404 
 405             if (UNLIKELY(Options::reportBytecodeCompileTimes())) {
 406                 MonotonicTime after = MonotonicTime::now();
 407                 dataLogLn(result.isValid() ? &quot;Failed to compile #&quot; : &quot;Compiled #&quot;, CodeBlockHash(sourceCode, unlinkedCodeBlock-&gt;isConstructor() ? CodeForConstruct : CodeForCall), &quot; into bytecode &quot;, bytecodeGenerator-&gt;instructions().size(), &quot; instructions in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
 408             }
 409             return result;
 410         }
 411 
 412         bool isArgumentNumber(const Identifier&amp;, int);
 413 
 414         Variable variable(const Identifier&amp;, ThisResolutionType = ThisResolutionType::Local);
 415 
 416         enum ExistingVariableMode { VerifyExisting, IgnoreExisting };
 417         void createVariable(const Identifier&amp;, VarKind, SymbolTable*, ExistingVariableMode = VerifyExisting); // Creates the variable, or asserts that the already-created variable is sufficiently compatible.
 418 
 419         // Returns the register storing &quot;this&quot;
 420         RegisterID* thisRegister() { return &amp;m_thisRegister; }
 421         RegisterID* argumentsRegister() { return m_argumentsRegister; }
 422         RegisterID* newTarget()
 423         {

 424             return m_newTargetRegister;
 425         }
 426 
 427         RegisterID* scopeRegister() { return m_scopeRegister; }
 428 
 429         RegisterID* generatorRegister() { return m_generatorRegister; }
 430 
 431         RegisterID* promiseCapabilityRegister() { return m_promiseCapabilityRegister; }
 432 
 433         // Returns the next available temporary register. Registers returned by
 434         // newTemporary require a modified form of reference counting: any
 435         // register with a refcount of 0 is considered &quot;available&quot;, meaning that
 436         // the next instruction may overwrite it.
 437         RegisterID* newTemporary();
 438 
 439         // The same as newTemporary(), but this function returns &quot;suggestion&quot; if
 440         // &quot;suggestion&quot; is a temporary. This function is helpful in situations
 441         // where you&#39;ve put &quot;suggestion&quot; in a RefPtr, but you&#39;d like to allow
 442         // the next instruction to overwrite it anyway.
 443         RegisterID* newTemporaryOr(RegisterID* suggestion) { return suggestion-&gt;isTemporary() ? suggestion : newTemporary(); }
</pre>
<hr />
<pre>
 481         // Moves src to dst if dst is not null and is different from src, otherwise just returns src.
 482         RegisterID* move(RegisterID* dst, RegisterID* src)
 483         {
 484             return dst == ignoredResult() ? nullptr : (dst &amp;&amp; dst != src) ? emitMove(dst, src) : src;
 485         }
 486 
 487         Ref&lt;LabelScope&gt; newLabelScope(LabelScope::Type, const Identifier* = 0);
 488         Ref&lt;Label&gt; newLabel();
 489         Ref&lt;Label&gt; newEmittedLabel();
 490 
 491         void emitNode(RegisterID* dst, StatementNode* n)
 492         {
 493             SetForScope&lt;bool&gt; tailPositionPoisoner(m_inTailPosition, false);
 494             return emitNodeInTailPosition(dst, n);
 495         }
 496 
 497         void emitNodeInTailPosition(RegisterID* dst, StatementNode* n)
 498         {
 499             // Node::emitCode assumes that dst, if provided, is either a local or a referenced temporary.
 500             ASSERT(!dst || dst == ignoredResult() || !dst-&gt;isTemporary() || dst-&gt;refCount());
<span class="line-modified"> 501             if (UNLIKELY(!m_vm-&gt;isSafeToRecurse())) {</span>
 502                 emitThrowExpressionTooDeepException();
 503                 return;
 504             }
 505             if (UNLIKELY(n-&gt;needsDebugHook()))
 506                 emitDebugHook(n);
 507             n-&gt;emitBytecode(*this, dst);
 508         }
 509 
 510         void recordOpcode(OpcodeID);
 511 
 512         ALWAYS_INLINE unsigned addMetadataFor(OpcodeID opcodeID)
 513         {
 514             return m_codeBlock-&gt;metadata().addEntry(opcodeID);
 515         }
 516 
 517         void emitNode(StatementNode* n)
 518         {
 519             emitNode(nullptr, n);
 520         }
 521 
 522         void emitNodeInTailPosition(StatementNode* n)
 523         {
 524             emitNodeInTailPosition(nullptr, n);
 525         }
 526 
 527         RegisterID* emitNode(RegisterID* dst, ExpressionNode* n)
 528         {
 529             SetForScope&lt;bool&gt; tailPositionPoisoner(m_inTailPosition, false);
 530             return emitNodeInTailPosition(dst, n);
 531         }
 532 
 533         RegisterID* emitNodeInTailPosition(RegisterID* dst, ExpressionNode* n)
 534         {
 535             // Node::emitCode assumes that dst, if provided, is either a local or a referenced temporary.
 536             ASSERT(!dst || dst == ignoredResult() || !dst-&gt;isTemporary() || dst-&gt;refCount());
<span class="line-modified"> 537             if (UNLIKELY(!m_vm-&gt;isSafeToRecurse()))</span>
 538                 return emitThrowExpressionTooDeepException();
 539             if (UNLIKELY(n-&gt;needsDebugHook()))
 540                 emitDebugHook(n);
 541             return n-&gt;emitBytecode(*this, dst);
 542         }
 543 
 544         RegisterID* emitNode(ExpressionNode* n)
 545         {
 546             return emitNode(nullptr, n);
 547         }
 548 
 549         RegisterID* emitNodeInTailPosition(ExpressionNode* n)
 550         {
 551             return emitNodeInTailPosition(nullptr, n);
 552         }
 553 
 554         RegisterID* emitDefineClassElements(PropertyListNode* n, RegisterID* constructor, RegisterID* prototype)
 555         {
 556             ASSERT(constructor-&gt;refCount() &amp;&amp; prototype-&gt;refCount());
<span class="line-modified"> 557             if (UNLIKELY(!m_vm-&gt;isSafeToRecurse()))</span>
 558                 return emitThrowExpressionTooDeepException();
 559             if (UNLIKELY(n-&gt;needsDebugHook()))
 560                 emitDebugHook(n);
 561             return n-&gt;emitBytecode(*this, constructor, prototype);
 562         }
 563 
 564         RegisterID* emitNodeForProperty(RegisterID* dst, ExpressionNode* node)
 565         {
 566             if (node-&gt;isString()) {
 567                 if (Optional&lt;uint32_t&gt; index = parseIndex(static_cast&lt;StringNode*&gt;(node)-&gt;value()))
 568                     return emitLoad(dst, jsNumber(index.value()));
 569             }
 570             return emitNode(dst, node);
 571         }
 572 
 573         RegisterID* emitNodeForProperty(ExpressionNode* n)
 574         {
 575             return emitNodeForProperty(nullptr, n);
 576         }
 577 
 578         void emitNodeInConditionContext(ExpressionNode* n, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
 579         {
<span class="line-modified"> 580             if (UNLIKELY(!m_vm-&gt;isSafeToRecurse())) {</span>
 581                 emitThrowExpressionTooDeepException();
 582                 return;
 583             }
 584             n-&gt;emitBytecodeInConditionContext(*this, trueTarget, falseTarget, fallThroughMode);
 585         }
 586 
 587         void emitExpressionInfo(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
 588         {
 589             ASSERT(divot.offset &gt;= divotStart.offset);
 590             ASSERT(divotEnd.offset &gt;= divot.offset);
 591 
 592             int sourceOffset = m_scopeNode-&gt;source().startOffset();
 593             unsigned firstLine = m_scopeNode-&gt;source().firstLine().oneBasedInt();
 594 
 595             int divotOffset = divot.offset - sourceOffset;
 596             int startOffset = divot.offset - divotStart.offset;
 597             int endOffset = divotEnd.offset - divot.offset;
 598 
 599             unsigned line = divot.line;
 600             ASSERT(line &gt;= firstLine);
</pre>
<hr />
<pre>
 693             BinaryOp::emit(this, dst, src1, src2);
 694             return dst;
 695         }
 696 
 697         template&lt;typename BinaryOp&gt;
 698         std::enable_if_t&lt;
 699             BinaryOp::opcodeID == op_add
 700             || BinaryOp::opcodeID == op_mul
 701             || BinaryOp::opcodeID == op_sub
 702             || BinaryOp::opcodeID == op_div,
 703             RegisterID*&gt;
 704         emitBinaryOp(RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes types)
 705         {
 706             BinaryOp::emit(this, dst, src1, src2, types);
 707             return dst;
 708         }
 709 
 710         RegisterID* emitBinaryOp(OpcodeID, RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes);
 711 
 712         template&lt;typename EqOp&gt;
<span class="line-modified"> 713         RegisterID* emitEqualityOp(RegisterID* dst, RegisterID* src1, RegisterID* src2);</span>








 714         RegisterID* emitCreateThis(RegisterID* dst);
 715         void emitTDZCheck(RegisterID* target);
 716         bool needsTDZCheck(const Variable&amp;);
 717         void emitTDZCheckIfNecessary(const Variable&amp;, RegisterID* target, RegisterID* scope);
 718         void liftTDZCheckIfPossible(const Variable&amp;);
 719         RegisterID* emitNewObject(RegisterID* dst);
 720         RegisterID* emitNewArray(RegisterID* dst, ElementNode*, unsigned length, IndexingType recommendedIndexingType); // stops at first elision
 721         RegisterID* emitNewArrayBuffer(RegisterID* dst, JSImmutableButterfly*, IndexingType recommendedIndexingType);
 722         // FIXME: new_array_with_spread should use an array allocation profile and take a recommendedIndexingType
 723         RegisterID* emitNewArrayWithSpread(RegisterID* dst, ElementNode*);
 724         RegisterID* emitNewArrayWithSize(RegisterID* dst, RegisterID* length);
 725 
 726         RegisterID* emitNewFunction(RegisterID* dst, FunctionMetadataNode*);
 727         RegisterID* emitNewFunctionExpression(RegisterID* dst, FuncExprNode*);
 728         RegisterID* emitNewDefaultConstructor(RegisterID* dst, ConstructorKind, const Identifier&amp; name, const Identifier&amp; ecmaName, const SourceCode&amp; classSource);
 729         RegisterID* emitNewArrowFunctionExpression(RegisterID*, ArrowFuncExprNode*);
 730         RegisterID* emitNewMethodDefinition(RegisterID* dst, MethodDefinitionNode*);
 731         RegisterID* emitNewRegExp(RegisterID* dst, RegExp*);
 732 
 733         void emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name);
</pre>
<hr />
<pre>
 819 
 820         RegisterID* emitResolveScopeForHoistingFuncDeclInEval(RegisterID* dst, const Identifier&amp;);
 821 
 822         RegisterID* initializeVariable(const Variable&amp;, RegisterID* value);
 823 
 824         void emitLabel(Label&amp;);
 825         void emitLoopHint();
 826         void emitJump(Label&amp; target);
 827         void emitJumpIfTrue(RegisterID* cond, Label&amp; target);
 828         void emitJumpIfFalse(RegisterID* cond, Label&amp; target);
 829         void emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target);
 830         void emitJumpIfNotFunctionApply(RegisterID* cond, Label&amp; target);
 831 
 832         template&lt;typename BinOp, typename JmpOp&gt;
 833         bool fuseCompareAndJump(RegisterID* cond, Label&amp; target, bool swapOperands = false);
 834 
 835         template&lt;typename UnaryOp, typename JmpOp&gt;
 836         bool fuseTestAndJmp(RegisterID* cond, Label&amp; target);
 837 
 838         void emitEnter();
<span class="line-removed"> 839         void emitCheckTraps();</span>
 840 
 841         RegisterID* emitHasIndexedProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName);
 842         RegisterID* emitHasStructureProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName, RegisterID* enumerator);
 843         RegisterID* emitHasGenericProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName);
 844         RegisterID* emitGetPropertyEnumerator(RegisterID* dst, RegisterID* base);
 845         RegisterID* emitGetEnumerableLength(RegisterID* dst, RegisterID* base);
 846         RegisterID* emitGetStructurePropertyEnumerator(RegisterID* dst, RegisterID* base, RegisterID* length);
 847         RegisterID* emitGetGenericPropertyEnumerator(RegisterID* dst, RegisterID* base, RegisterID* length, RegisterID* structureEnumerator);
 848         RegisterID* emitEnumeratorStructurePropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index);
 849         RegisterID* emitEnumeratorGenericPropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index);
 850         RegisterID* emitToIndexString(RegisterID* dst, RegisterID* index);
 851 
 852         RegisterID* emitIsCellWithType(RegisterID* dst, RegisterID* src, JSType);
 853         RegisterID* emitIsJSArray(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, ArrayType); }
 854         RegisterID* emitIsProxyObject(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, ProxyObjectType); }
 855         RegisterID* emitIsRegExpObject(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, RegExpObjectType); }
 856         RegisterID* emitIsMap(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSMapType); }
 857         RegisterID* emitIsSet(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSSetType); }
 858         RegisterID* emitIsObject(RegisterID* dst, RegisterID* src);
 859         RegisterID* emitIsNumber(RegisterID* dst, RegisterID* src);
 860         RegisterID* emitIsUndefined(RegisterID* dst, RegisterID* src);
 861         RegisterID* emitIsUndefinedOrNull(RegisterID* dst, RegisterID* src);
 862         RegisterID* emitIsEmpty(RegisterID* dst, RegisterID* src);
 863         RegisterID* emitIsDerivedArray(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, DerivedArrayType); }
 864         void emitRequireObjectCoercible(RegisterID* value, const String&amp; error);
 865 
 866         RegisterID* emitIteratorNext(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, const ThrowableExpressionData* node, JSC::EmitAwait = JSC::EmitAwait::No);
 867         RegisterID* emitIteratorNextWithValue(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, RegisterID* value, const ThrowableExpressionData* node);
 868         void emitIteratorClose(RegisterID* iterator, const ThrowableExpressionData* node, EmitAwait = EmitAwait::No);
 869 
 870         RegisterID* emitRestParameter(RegisterID* result, unsigned numParametersToSkip);
 871 
 872         bool emitReadOnlyExceptionIfNeeded(const Variable&amp;);
 873 
 874         // Start a try block. &#39;start&#39; must have been emitted.
 875         TryData* pushTry(Label&amp; start, Label&amp; handlerLabel, HandlerType);
 876         // End a try block. &#39;end&#39; must have been emitted.
 877         void popTry(TryData*, Label&amp; end);
<span class="line-modified"> 878         void emitCatch(RegisterID* exceptionRegister, RegisterID* thrownValueRegister, TryData*);</span>


 879 
 880     private:
 881         static const int CurrentLexicalScopeIndex = -2;
 882         static const int OutermostLexicalScopeIndex = -1;
 883 
 884         int currentLexicalScopeIndex() const
 885         {
 886             int size = static_cast&lt;int&gt;(m_lexicalScopeStack.size());
 887             ASSERT(static_cast&lt;size_t&gt;(size) == m_lexicalScopeStack.size());
 888             ASSERT(size &gt;= 0);
 889             if (!size)
 890                 return OutermostLexicalScopeIndex;
 891             return size - 1;
 892         }
 893 


 894     public:
 895         void restoreScopeRegister();
 896         void restoreScopeRegister(int lexicalScopeIndex);
 897 
 898         int labelScopeDepthToLexicalScopeIndex(int labelScopeDepth);
 899 
 900         void emitThrow(RegisterID*);
 901         RegisterID* emitArgumentCount(RegisterID*);
 902 
 903         void emitThrowStaticError(ErrorType, RegisterID*);
 904         void emitThrowStaticError(ErrorType, const Identifier&amp; message);
 905         void emitThrowReferenceError(const String&amp; message);
 906         void emitThrowTypeError(const String&amp; message);
 907         void emitThrowTypeError(const Identifier&amp; message);
 908         void emitThrowRangeError(const Identifier&amp; message);
 909         void emitThrowOutOfMemoryError();
 910 
 911         void emitPushCatchScope(VariableEnvironment&amp;);
 912         void emitPopCatchScope(VariableEnvironment&amp;);
 913 
 914         RegisterID* emitGetIterator(RegisterID*, ThrowableExpressionData*);
 915         RegisterID* emitGetAsyncIterator(RegisterID*, ThrowableExpressionData*);
 916 
 917         void emitAwait(RegisterID*);
 918         void emitGetScope();
 919         RegisterID* emitPushWithScope(RegisterID* objectScope);
 920         void emitPopWithScope();
 921         void emitPutThisToArrowFunctionContextScope();
 922         void emitPutNewTargetToArrowFunctionContextScope();
 923         void emitPutDerivedConstructorToArrowFunctionContextScope();
 924         RegisterID* emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();
 925 
 926         void emitDebugHook(DebugHookType, const JSTextPosition&amp;);
 927         void emitDebugHook(DebugHookType, unsigned line, unsigned charOffset, unsigned lineStart);
 928         void emitDebugHook(StatementNode*);
 929         void emitDebugHook(ExpressionNode*);
 930         void emitWillLeaveCallFrameDebugHook();
 931 
<span class="line-modified"> 932         class CompletionRecordScope {</span>
<span class="line-removed"> 933         public:</span>
<span class="line-removed"> 934             CompletionRecordScope(BytecodeGenerator&amp; generator, bool needCompletionRecordRegisters = true)</span>
<span class="line-removed"> 935                 : m_generator(generator)</span>
<span class="line-removed"> 936             {</span>
<span class="line-removed"> 937                 if (needCompletionRecordRegisters &amp;&amp; m_generator.allocateCompletionRecordRegisters())</span>
<span class="line-removed"> 938                     m_needToReleaseOnDestruction = true;</span>
<span class="line-removed"> 939             }</span>
<span class="line-removed"> 940             ~CompletionRecordScope()</span>
<span class="line-removed"> 941             {</span>
<span class="line-removed"> 942                 if (m_needToReleaseOnDestruction)</span>
<span class="line-removed"> 943                     m_generator.releaseCompletionRecordRegisters();</span>
<span class="line-removed"> 944             }</span>
<span class="line-removed"> 945 </span>
<span class="line-removed"> 946         private:</span>
<span class="line-removed"> 947             BytecodeGenerator&amp; m_generator;</span>
<span class="line-removed"> 948             bool m_needToReleaseOnDestruction { false };</span>
<span class="line-removed"> 949         };</span>
<span class="line-removed"> 950 </span>
<span class="line-removed"> 951         RegisterID* completionTypeRegister() const</span>
<span class="line-removed"> 952         {</span>
<span class="line-removed"> 953             ASSERT(m_completionTypeRegister);</span>
<span class="line-removed"> 954             return m_completionTypeRegister.get();</span>
<span class="line-removed"> 955         }</span>
<span class="line-removed"> 956         RegisterID* completionValueRegister() const</span>
<span class="line-removed"> 957         {</span>
<span class="line-removed"> 958             ASSERT(m_completionValueRegister);</span>
<span class="line-removed"> 959             return m_completionValueRegister.get();</span>
<span class="line-removed"> 960         }</span>
<span class="line-removed"> 961 </span>
<span class="line-removed"> 962         void emitSetCompletionType(CompletionType type)</span>
<span class="line-removed"> 963         {</span>
<span class="line-removed"> 964             emitLoad(completionTypeRegister(), JSValue(static_cast&lt;int&gt;(type)));</span>
<span class="line-removed"> 965         }</span>
<span class="line-removed"> 966         void emitSetCompletionValue(RegisterID* reg)</span>
 967         {
<span class="line-modified"> 968             move(completionValueRegister(), reg);</span>
 969         }
 970 
 971         template&lt;typename CompareOp&gt;
 972         void emitJumpIf(RegisterID* completionTypeRegister, CompletionType, Label&amp; jumpTarget);
 973 
 974         bool emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget);
 975         bool emitReturnViaFinallyIfNeeded(RegisterID* returnRegister);
<span class="line-modified"> 976         void emitFinallyCompletion(FinallyContext&amp;, RegisterID* completionTypeRegister, Label&amp; normalCompletionLabel);</span>
<span class="line-removed"> 977 </span>
<span class="line-removed"> 978     private:</span>
<span class="line-removed"> 979         bool allocateCompletionRecordRegisters();</span>
<span class="line-removed"> 980         void releaseCompletionRecordRegisters();</span>
 981 
 982     public:
<span class="line-modified"> 983         FinallyContext* pushFinallyControlFlowScope(Label&amp; finallyLabel);</span>
<span class="line-modified"> 984         FinallyContext popFinallyControlFlowScope();</span>





 985 
 986         void pushIndexedForInScope(RegisterID* local, RegisterID* index);
 987         void popIndexedForInScope(RegisterID* local);
 988         void pushStructureForInScope(RegisterID* local, RegisterID* index, RegisterID* property, RegisterID* enumerator);
 989         void popStructureForInScope(RegisterID* local);
 990 
 991         LabelScope* breakTarget(const Identifier&amp;);
 992         LabelScope* continueTarget(const Identifier&amp;);
 993 
 994         void beginSwitch(RegisterID*, SwitchInfo::SwitchType);
 995         void endSwitch(uint32_t clauseCount, const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp;, ExpressionNode**, Label&amp; defaultLabel, int32_t min, int32_t range);
 996 
 997         void emitYieldPoint(RegisterID*, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason);
 998 
 999         void emitGeneratorStateLabel();
1000         void emitGeneratorStateChange(int32_t state);
1001         RegisterID* emitYield(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason = JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Yield);
1002         RegisterID* emitDelegateYield(RegisterID* argument, ThrowableExpressionData*);
1003         RegisterID* generatorStateRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::State)]; }
1004         RegisterID* generatorValueRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::Value)]; }
1005         RegisterID* generatorResumeModeRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::ResumeMode)]; }
1006         RegisterID* generatorFrameRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::Frame)]; }
1007 
1008         CodeType codeType() const { return m_codeType; }
1009 
1010         bool shouldBeConcernedWithCompletionValue() const { return m_codeType != FunctionCode; }
1011 
<span class="line-modified">1012         bool shouldEmitDebugHooks() const { return m_shouldEmitDebugHooks; }</span>


1013 
1014         bool isStrictMode() const { return m_codeBlock-&gt;isStrictMode(); }
1015 
1016         SourceParseMode parseMode() const { return m_codeBlock-&gt;parseMode(); }
1017 
1018         bool isBuiltinFunction() const { return m_isBuiltinFunction; }
1019 
1020         OpcodeID lastOpcodeID() const { return m_lastOpcodeID; }
1021 
1022         bool isDerivedConstructorContext() { return m_derivedContextType == DerivedContextType::DerivedConstructorContext; }
1023         bool isDerivedClassContext() { return m_derivedContextType == DerivedContextType::DerivedMethodContext; }
1024         bool isArrowFunction() { return m_codeBlock-&gt;isArrowFunction(); }
1025 
1026         enum class TDZCheckOptimization { Optimize, DoNotOptimize };
1027         enum class NestedScopeType { IsNested, IsNotNested };
1028     private:
1029         enum class TDZRequirement { UnderTDZ, NotUnderTDZ };
1030         enum class ScopeType { CatchScope, LetConstScope, FunctionNameScope };
1031         enum class ScopeRegisterType { Var, Block };
1032         void pushLexicalScopeInternal(VariableEnvironment&amp;, TDZCheckOptimization, NestedScopeType, RegisterID** constantSymbolTableResult, TDZRequirement, ScopeType, ScopeRegisterType);
1033         void initializeBlockScopedFunctions(VariableEnvironment&amp;, FunctionStack&amp;, RegisterID* constantSymbolTable);
1034         void popLexicalScopeInternal(VariableEnvironment&amp;);
1035         template&lt;typename LookUpVarKindFunctor&gt;
1036         bool instantiateLexicalVariables(const VariableEnvironment&amp;, SymbolTable*, ScopeRegisterType, LookUpVarKindFunctor);
1037         void emitPrefillStackTDZVariables(const VariableEnvironment&amp;, SymbolTable*);
1038         void emitPopScope(RegisterID* dst, RegisterID* scope);
1039         RegisterID* emitGetParentScope(RegisterID* dst, RegisterID* scope);
1040         void emitPushFunctionNameScope(const Identifier&amp; property, RegisterID* value, bool isCaptured);
1041         void emitNewFunctionExpressionCommon(RegisterID*, FunctionMetadataNode*);
1042 
1043         bool isNewTargetUsedInInnerArrowFunction();
1044         bool isArgumentsUsedInInnerArrowFunction();
1045 
1046         void emitToThis();
1047 
1048         RegisterID* emitMove(RegisterID* dst, RegisterID* src);
1049 


1050     public:
1051         bool isSuperUsedInInnerArrowFunction();
1052         bool isSuperCallUsedInInnerArrowFunction();
1053         bool isThisUsedInInnerArrowFunction();
1054         void pushLexicalScope(VariableEnvironmentNode*, TDZCheckOptimization, NestedScopeType = NestedScopeType::IsNotNested, RegisterID** constantSymbolTableResult = nullptr, bool shouldInitializeBlockScopedFunctions = true);
1055         void popLexicalScope(VariableEnvironmentNode*);
1056         void prepareLexicalScopeForNextForLoopIteration(VariableEnvironmentNode*, RegisterID* loopSymbolTable);
1057         int labelScopeDepth() const;
1058         UnlinkedArrayProfile newArrayProfile();
1059 
1060     private:
1061         ParserError generate();
1062         void reclaimFreeRegisters();
1063         Variable variableForLocalEntry(const Identifier&amp;, const SymbolTableEntry&amp;, int symbolTableConstantIndex, bool isLexicallyScoped);
1064 
1065         RegisterID* kill(RegisterID* dst)
1066         {
1067             m_staticPropertyAnalyzer.kill(dst);
1068             return dst;
1069         }
1070 
1071         void retrieveLastUnaryOp(int&amp; dstIndex, int&amp; srcIndex);
1072         ALWAYS_INLINE void rewind();
1073 
1074         void allocateCalleeSaveSpace();
1075         void allocateAndEmitScope();
1076 
1077         template&lt;typename JumpOp&gt;
1078         void setTargetForJumpInstruction(InstructionStream::MutableRef&amp;, int target);
1079 
1080         using BigIntMapEntry = std::tuple&lt;UniquedStringImpl*, uint8_t, bool&gt;;
1081 
1082         using NumberMap = HashMap&lt;double, JSValue&gt;;
1083         using IdentifierStringMap = HashMap&lt;UniquedStringImpl*, JSString*, IdentifierRepHash&gt;;
1084         using IdentifierBigIntMap = HashMap&lt;BigIntMapEntry, JSBigInt*&gt;;
<span class="line-modified">1085         using TemplateObjectDescriptorMap = HashMap&lt;Ref&lt;TemplateObjectDescriptor&gt;, JSTemplateObjectDescriptor*&gt;;</span>

1086 
1087         // Helper for emitCall() and emitConstruct(). This works because the set of
1088         // expected functions have identical behavior for both call and construct
1089         // (i.e. &quot;Object()&quot; is identical to &quot;new Object()&quot;).
1090         ExpectedFunction emitExpectedFunctionSnippet(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, Label&amp; done);
1091 
1092         template&lt;typename CallOp&gt;
1093         RegisterID* emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1094 
1095         RegisterID* emitCallIterator(RegisterID* iterator, RegisterID* argument, ThrowableExpressionData*);
1096         RegisterID* newRegister();
1097 
1098         // Adds an anonymous local var slot. To give this slot a name, add it to symbolTable().
1099         RegisterID* addVar()
1100         {
1101             ++m_codeBlock-&gt;m_numVars;
1102             RegisterID* result = newRegister();
1103             ASSERT(VirtualRegister(result-&gt;index()).toLocal() == m_codeBlock-&gt;m_numVars - 1);
1104             result-&gt;ref(); // We should never free this slot.
1105             return result;
</pre>
<hr />
<pre>
1120             ASSERT(m_parameters.size());
1121             return m_parameters[reg.toArgument()];
1122         }
1123 
1124         bool hasConstant(const Identifier&amp;) const;
1125         unsigned addConstant(const Identifier&amp;);
1126         RegisterID* addConstantValue(JSValue, SourceCodeRepresentation = SourceCodeRepresentation::Other);
1127         RegisterID* addConstantEmptyValue();
1128 
1129         UnlinkedFunctionExecutable* makeFunction(FunctionMetadataNode* metadata)
1130         {
1131             DerivedContextType newDerivedContextType = DerivedContextType::None;
1132 
1133             if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode, SourceParseMode::AsyncArrowFunctionBodyMode).contains(metadata-&gt;parseMode())) {
1134                 if (constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext())
1135                     newDerivedContextType = DerivedContextType::DerivedConstructorContext;
1136                 else if (m_codeBlock-&gt;isClassContext() || isDerivedClassContext())
1137                     newDerivedContextType = DerivedContextType::DerivedMethodContext;
1138             }
1139 
<span class="line-modified">1140             CompactVariableMap::Handle variablesUnderTDZ = getVariablesUnderTDZ();</span>
1141 
1142             // FIXME: These flags, ParserModes and propagation to XXXCodeBlocks should be reorganized.
1143             // https://bugs.webkit.org/show_bug.cgi?id=151547
1144             SourceParseMode parseMode = metadata-&gt;parseMode();
1145             ConstructAbility constructAbility = constructAbilityForParseMode(parseMode);
1146             if (parseMode == SourceParseMode::MethodMode &amp;&amp; metadata-&gt;constructorKind() != ConstructorKind::None)
1147                 constructAbility = ConstructAbility::CanConstruct;
1148 
<span class="line-modified">1149             return UnlinkedFunctionExecutable::create(m_vm, m_scopeNode-&gt;source(), metadata, isBuiltinFunction() ? UnlinkedBuiltinFunction : UnlinkedNormalFunction, constructAbility, scriptMode(), WTFMove(variablesUnderTDZ), newDerivedContextType);</span>
1150         }
1151 
<span class="line-modified">1152         CompactVariableMap::Handle getVariablesUnderTDZ();</span>
1153 
1154         RegisterID* emitConstructVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1155         template&lt;typename CallOp&gt;
1156         RegisterID* emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1157 
1158         void emitLogShadowChickenPrologueIfNecessary();
1159         void emitLogShadowChickenTailIfNecessary();
1160 
1161         void initializeParameters(FunctionParameters&amp;);
1162         void initializeVarLexicalEnvironment(int symbolTableConstantIndex, SymbolTable* functionSymbolTable, bool hasCapturedVariables);
1163         void initializeDefaultParameterValuesAndSetupFunctionScopeStack(FunctionParameters&amp;, bool isSimpleParameterList, FunctionNode*, SymbolTable*, int symbolTableConstantIndex, const ScopedLambda&lt;bool (UniquedStringImpl*)&gt;&amp; captures, bool shouldCreateArgumentsVariableInParameterScope);
1164         void initializeArrowFunctionContextScopeIfNeeded(SymbolTable* functionSymbolTable = nullptr, bool canReuseLexicalEnvironment = false);
1165         bool needsDerivedConstructorInArrowFunctionLexicalEnvironment();
1166 
1167         enum class TDZNecessityLevel {
1168             NotNeeded,
1169             Optimize,
1170             DoNotOptimize
1171         };
1172         typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, TDZNecessityLevel, IdentifierRepHash&gt; TDZMap;
1173 
1174     public:
1175         JSString* addStringConstant(const Identifier&amp;);
1176         JSValue addBigIntConstant(const Identifier&amp;, uint8_t radix, bool sign);
<span class="line-modified">1177         RegisterID* addTemplateObjectConstant(Ref&lt;TemplateObjectDescriptor&gt;&amp;&amp;);</span>
1178 
1179         const InstructionStream&amp; instructions() const { return m_writer; }
1180 
1181         RegisterID* emitThrowExpressionTooDeepException();
1182 
1183         void write(uint8_t byte) { m_writer.write(byte); }

1184         void write(uint32_t i) { m_writer.write(i); }
<span class="line-modified">1185         void alignWideOpcode();</span>




1186 
1187         class PreservedTDZStack {
1188         private:
1189             Vector&lt;TDZMap&gt; m_preservedTDZStack;
1190             friend class BytecodeGenerator;
1191         };
1192 
1193         void preserveTDZStack(PreservedTDZStack&amp;);
1194         void restoreTDZStack(const PreservedTDZStack&amp;);
1195 
1196         template&lt;typename Func&gt;
1197         void withWriter(InstructionStreamWriter&amp; writer, const Func&amp; fn)
1198         {
1199             auto prevLastOpcodeID = m_lastOpcodeID;
1200             auto prevLastInstruction = m_lastInstruction;
1201             m_writer.swap(writer);
1202             m_lastOpcodeID = op_end;
1203             m_lastInstruction = m_writer.ref();
1204             fn();
1205             m_writer.swap(writer);
1206             m_lastOpcodeID = prevLastOpcodeID;
1207             m_lastInstruction = prevLastInstruction;
1208         }
1209 
1210     private:
1211         InstructionStreamWriter m_writer;
1212 
<span class="line-modified">1213         bool m_shouldEmitDebugHooks;</span>
1214 
1215         struct LexicalScopeStackEntry {
1216             SymbolTable* m_symbolTable;
1217             RegisterID* m_scope;
1218             bool m_isWithScope;
1219             int m_symbolTableConstantIndex;
1220         };
1221         Vector&lt;LexicalScopeStackEntry&gt; m_lexicalScopeStack;
1222 
1223         Vector&lt;TDZMap&gt; m_TDZStack;
1224         Optional&lt;size_t&gt; m_varScopeLexicalScopeStackIndex;
1225         void pushTDZVariables(const VariableEnvironment&amp;, TDZCheckOptimization, TDZRequirement);
1226 
1227         ScopeNode* const m_scopeNode;
1228         Strong&lt;UnlinkedCodeBlock&gt; m_codeBlock;
1229 
1230         // Some of these objects keep pointers to one another. They are arranged
1231         // to ensure a sane destruction order that avoids references to freed memory.
1232         HashSet&lt;RefPtr&lt;UniquedStringImpl&gt;, IdentifierRepHash&gt; m_functions;
1233         RegisterID m_ignoredResultRegister;
1234         RegisterID m_thisRegister;
1235         RegisterID m_calleeRegister;
1236         RegisterID* m_scopeRegister { nullptr };
1237         RegisterID* m_topMostScope { nullptr };
1238         RegisterID* m_argumentsRegister { nullptr };
1239         RegisterID* m_lexicalEnvironmentRegister { nullptr };
1240         RegisterID* m_generatorRegister { nullptr };
1241         RegisterID* m_emptyValueRegister { nullptr };
1242         RegisterID* m_newTargetRegister { nullptr };
1243         RegisterID* m_isDerivedConstuctor { nullptr };
1244         RegisterID* m_linkTimeConstantRegisters[LinkTimeConstantCount];
1245         RegisterID* m_arrowFunctionContextLexicalEnvironmentRegister { nullptr };
1246         RegisterID* m_promiseCapabilityRegister { nullptr };
1247 
<span class="line-removed">1248         RefPtr&lt;RegisterID&gt; m_completionTypeRegister;</span>
<span class="line-removed">1249         RefPtr&lt;RegisterID&gt; m_completionValueRegister;</span>
<span class="line-removed">1250 </span>
1251         FinallyContext* m_currentFinallyContext { nullptr };
1252 
1253         SegmentedVector&lt;RegisterID*, 16&gt; m_localRegistersForCalleeSaveRegisters;
1254         SegmentedVector&lt;RegisterID, 32&gt; m_constantPoolRegisters;
1255         SegmentedVector&lt;RegisterID, 32&gt; m_calleeLocals;
1256         SegmentedVector&lt;RegisterID, 32&gt; m_parameters;
1257         SegmentedVector&lt;Label, 32&gt; m_labels;
1258         SegmentedVector&lt;LabelScope, 32&gt; m_labelScopes;
1259         unsigned m_finallyDepth { 0 };
<span class="line-modified">1260         int m_localScopeDepth { 0 };</span>
1261         const CodeType m_codeType;
1262 
<span class="line-modified">1263         int localScopeDepth() const;</span>
1264         void pushLocalControlFlowScope();
1265         void popLocalControlFlowScope();
1266 
1267         // FIXME: Restore overflow checking with UnsafeVectorOverflow once SegmentVector supports it.
1268         // https://bugs.webkit.org/show_bug.cgi?id=165980
1269         SegmentedVector&lt;ControlFlowScope, 16&gt; m_controlFlowScopeStack;
1270         Vector&lt;SwitchInfo&gt; m_switchContextStack;
1271         Vector&lt;Ref&lt;ForInContext&gt;&gt; m_forInContextStack;
1272         Vector&lt;TryContext&gt; m_tryContextStack;
1273         unsigned m_yieldPoints { 0 };
1274 
1275         Strong&lt;SymbolTable&gt; m_generatorFrameSymbolTable;
1276         int m_generatorFrameSymbolTableIndex { 0 };
1277 
1278         enum FunctionVariableType : uint8_t { NormalFunctionVariable, TopLevelFunctionVariable };
1279         Vector&lt;std::pair&lt;FunctionMetadataNode*, FunctionVariableType&gt;&gt; m_functionsToInitialize;
1280         bool m_needToInitializeArguments { false };
1281         RestParameterNode* m_restParameter { nullptr };
1282 
1283         Vector&lt;TryRange&gt; m_tryRanges;
1284         SegmentedVector&lt;TryData, 8&gt; m_tryData;
1285 


1286         int m_nextConstantOffset { 0 };
1287 
1288         typedef HashMap&lt;FunctionMetadataNode*, unsigned&gt; FunctionOffsetMap;
1289         FunctionOffsetMap m_functionOffsets;
1290 
1291         // Constant pool
1292         IdentifierMap m_identifierMap;
1293 
1294         typedef HashMap&lt;EncodedJSValueWithRepresentation, unsigned, EncodedJSValueWithRepresentationHash, EncodedJSValueWithRepresentationHashTraits&gt; JSValueMap;
1295         JSValueMap m_jsValueMap;
1296         IdentifierStringMap m_stringMap;
1297         IdentifierBigIntMap m_bigIntMap;
<span class="line-modified">1298         TemplateObjectDescriptorMap m_templateObjectDescriptorMap;</span>

1299 
1300         StaticPropertyAnalyzer m_staticPropertyAnalyzer;
1301 
<span class="line-modified">1302         VM* m_vm;</span>
1303 
1304         OpcodeID m_lastOpcodeID = op_end;
1305         InstructionStream::MutableRef m_lastInstruction { m_writer.ref() };
1306 
1307         bool m_usesExceptions { false };
1308         bool m_expressionTooDeep { false };
1309         bool m_isBuiltinFunction { false };
1310         bool m_usesNonStrictEval { false };
1311         bool m_inTailPosition { false };
1312         bool m_needsToUpdateArrowFunctionContext;

1313         DerivedContextType m_derivedContextType { DerivedContextType::None };
1314 
1315         CompactVariableMap::Handle m_cachedVariablesUnderTDZ;
1316 
<span class="line-modified">1317         using CatchEntry = std::tuple&lt;TryData*, VirtualRegister, VirtualRegister&gt;;</span>
<span class="line-modified">1318         Vector&lt;CatchEntry&gt; m_catchesToEmit;</span>





1319     };
1320 
<span class="line-removed">1321 </span>
1322 } // namespace JSC
1323 
1324 namespace WTF {
1325 
1326 void printInternal(PrintStream&amp;, JSC::Variable::VariableKind);
1327 
1328 } // namespace WTF
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   4  * Copyright (C) 2012 Igalia, S.L.
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  *
  10  * 1.  Redistributions of source code must retain the above copyright
  11  *     notice, this list of conditions and the following disclaimer.
  12  * 2.  Redistributions in binary form must reproduce the above copyright
  13  *     notice, this list of conditions and the following disclaimer in the
  14  *     documentation and/or other materials provided with the distribution.
  15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16  *     its contributors may be used to endorse or promote products derived
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
</pre>
<hr />
<pre>
  32 
  33 #include &quot;CodeBlock.h&quot;
  34 #include &quot;Instruction.h&quot;
  35 #include &quot;Interpreter.h&quot;
  36 #include &quot;JSAsyncGeneratorFunction.h&quot;
  37 #include &quot;JSBigInt.h&quot;
  38 #include &quot;JSGeneratorFunction.h&quot;
  39 #include &quot;JSTemplateObjectDescriptor.h&quot;
  40 #include &quot;Label.h&quot;
  41 #include &quot;LabelScope.h&quot;
  42 #include &quot;Nodes.h&quot;
  43 #include &quot;ParserError.h&quot;
  44 #include &quot;ProfileTypeBytecodeFlag.h&quot;
  45 #include &quot;RegisterID.h&quot;
  46 #include &quot;StaticPropertyAnalyzer.h&quot;
  47 #include &quot;SymbolTable.h&quot;
  48 #include &quot;UnlinkedCodeBlock.h&quot;
  49 #include &lt;functional&gt;
  50 #include &lt;wtf/CheckedArithmetic.h&gt;
  51 #include &lt;wtf/HashFunctions.h&gt;
<span class="line-added">  52 #include &lt;wtf/Optional.h&gt;</span>
  53 #include &lt;wtf/SegmentedVector.h&gt;
  54 #include &lt;wtf/SetForScope.h&gt;
  55 #include &lt;wtf/Vector.h&gt;
  56 
  57 namespace JSC {
  58 
  59     class JSImmutableButterfly;
  60     class Identifier;
  61     class IndexedForInContext;
  62     class StructureForInContext;
  63 
  64     enum ExpectedFunction {
  65         NoExpectedFunction,
  66         ExpectObjectConstructor,
  67         ExpectArrayConstructor
  68     };
  69 
  70     enum class EmitAwait { Yes, No };
  71 
  72     enum class DebuggableCall { Yes, No };
</pre>
<hr />
<pre>
  82         unsigned argumentCountIncludingThis() { return m_argv.size() - m_padding; }
  83         ArgumentsNode* argumentsNode() { return m_argumentsNode; }
  84 
  85     private:
  86         ArgumentsNode* m_argumentsNode;
  87         Vector&lt;RefPtr&lt;RegisterID&gt;, 8, UnsafeVectorOverflow&gt; m_argv;
  88         unsigned m_padding;
  89     };
  90 
  91     // https://tc39.github.io/ecma262/#sec-completion-record-specification-type
  92     //
  93     // For the Break and Continue cases, instead of using the Break and Continue enum values
  94     // below, we use the unique jumpID of the break and continue statement as the encoding
  95     // for the CompletionType value. emitFinallyCompletion() uses this jumpID value later
  96     // to determine the appropriate jump target to jump to after executing the relevant finally
  97     // blocks. The jumpID is computed as:
  98     //     jumpID = bytecodeOffset (of the break/continue node) + CompletionType::NumberOfTypes.
  99     // Hence, there won&#39;t be any collision between jumpIDs and CompletionType enums.
 100     enum class CompletionType : int {
 101         Normal,



 102         Throw,
<span class="line-modified"> 103         Return,</span>
 104         NumberOfTypes
 105     };
 106 
 107     inline CompletionType bytecodeOffsetToJumpID(unsigned offset)
 108     {
 109         int jumpIDAsInt = offset + static_cast&lt;int&gt;(CompletionType::NumberOfTypes);
 110         ASSERT(jumpIDAsInt &gt;= static_cast&lt;int&gt;(CompletionType::NumberOfTypes));
 111         return static_cast&lt;CompletionType&gt;(jumpIDAsInt);
 112     }
 113 
 114     struct FinallyJump {
 115         FinallyJump(CompletionType jumpID, int targetLexicalScopeIndex, Label&amp; targetLabel)
 116             : jumpID(jumpID)
 117             , targetLexicalScopeIndex(targetLexicalScopeIndex)
 118             , targetLabel(targetLabel)
 119         { }
 120 
 121         CompletionType jumpID;
 122         int targetLexicalScopeIndex;
 123         Ref&lt;Label&gt; targetLabel;
 124     };
 125 
<span class="line-modified"> 126     class FinallyContext {</span>
<span class="line-added"> 127     public:</span>
 128         FinallyContext() { }
<span class="line-modified"> 129         FinallyContext(BytecodeGenerator&amp;, Label&amp; finallyLabel);</span>





 130 
 131         FinallyContext* outerContext() const { return m_outerContext; }
 132         Label* finallyLabel() const { return m_finallyLabel; }
 133 
<span class="line-added"> 134         RegisterID* completionTypeRegister() const { return m_completionRecord.typeRegister.get(); }</span>
<span class="line-added"> 135         RegisterID* completionValueRegister() const { return m_completionRecord.valueRegister.get(); }</span>
<span class="line-added"> 136 </span>
 137         uint32_t numberOfBreaksOrContinues() const { return m_numberOfBreaksOrContinues.unsafeGet(); }
 138         void incNumberOfBreaksOrContinues() { m_numberOfBreaksOrContinues++; }
 139 
 140         bool handlesReturns() const { return m_handlesReturns; }
 141         void setHandlesReturns() { m_handlesReturns = true; }
 142 
 143         void registerJump(CompletionType jumpID, int lexicalScopeIndex, Label&amp; targetLabel)
 144         {
 145             m_jumps.append(FinallyJump(jumpID, lexicalScopeIndex, targetLabel));
 146         }
 147 
 148         size_t numberOfJumps() const { return m_jumps.size(); }
 149         FinallyJump&amp; jumps(size_t i) { return m_jumps[i]; }
 150 
 151     private:
 152         FinallyContext* m_outerContext { nullptr };
 153         Label* m_finallyLabel { nullptr };
 154         Checked&lt;uint32_t, WTF::CrashOnOverflow&gt; m_numberOfBreaksOrContinues;
 155         bool m_handlesReturns { false };
 156         Vector&lt;FinallyJump&gt; m_jumps;
<span class="line-added"> 157         struct {</span>
<span class="line-added"> 158             RefPtr&lt;RegisterID&gt; typeRegister;</span>
<span class="line-added"> 159             RefPtr&lt;RegisterID&gt; valueRegister;</span>
<span class="line-added"> 160         } m_completionRecord;</span>
 161     };
 162 
 163     struct ControlFlowScope {
 164         typedef uint8_t Type;
 165         enum {
 166             Label,
 167             Finally
 168         };
<span class="line-modified"> 169         ControlFlowScope(Type type, int lexicalScopeIndex, FinallyContext* finallyContext = nullptr)</span>
 170             : type(type)
 171             , lexicalScopeIndex(lexicalScopeIndex)
<span class="line-modified"> 172             , finallyContext(finallyContext)</span>
 173         { }
 174 
 175         bool isLabelScope() const { return type == Label; }
 176         bool isFinallyScope() const { return type == Finally; }
 177 
 178         Type type;
 179         int lexicalScopeIndex;
<span class="line-modified"> 180         FinallyContext* finallyContext;</span>
 181     };
 182 
 183     class ForInContext : public RefCounted&lt;ForInContext&gt; {
 184         WTF_MAKE_FAST_ALLOCATED;
 185         WTF_MAKE_NONCOPYABLE(ForInContext);
 186     public:
 187         virtual ~ForInContext() = default;
 188 
 189         bool isValid() const { return m_isValid; }
 190         void invalidate() { m_isValid = false; }
 191 
 192         enum class Type : uint8_t {
 193             IndexedForIn,
 194             StructureForIn
 195         };
 196 
 197         Type type() const { return m_type; }
 198         bool isIndexedForInContext() const { return m_type == Type::IndexedForIn; }
 199         bool isStructureForInContext() const { return m_type == Type::StructureForIn; }
 200 
</pre>
<hr />
<pre>
 348         Identifier m_ident;
 349         VarOffset m_offset;
 350         RegisterID* m_local;
 351         unsigned m_attributes;
 352         VariableKind m_kind;
 353         int m_symbolTableConstantIndex;
 354         bool m_isLexicallyScoped;
 355     };
 356 
 357     struct TryRange {
 358         Ref&lt;Label&gt; start;
 359         Ref&lt;Label&gt; end;
 360         TryData* tryData;
 361     };
 362 
 363     class BytecodeGenerator {
 364         WTF_MAKE_FAST_ALLOCATED;
 365         WTF_MAKE_NONCOPYABLE(BytecodeGenerator);
 366 
 367         friend class BoundLabel;
<span class="line-added"> 368         friend class FinallyContext;</span>
 369         friend class Label;
 370         friend class IndexedForInContext;
 371         friend class StructureForInContext;
 372     public:
 373         typedef DeclarationStacks::FunctionStack FunctionStack;
 374 
<span class="line-modified"> 375         BytecodeGenerator(VM&amp;, ProgramNode*, UnlinkedProgramCodeBlock*, OptionSet&lt;CodeGenerationMode&gt;, const VariableEnvironment*);</span>
<span class="line-modified"> 376         BytecodeGenerator(VM&amp;, FunctionNode*, UnlinkedFunctionCodeBlock*, OptionSet&lt;CodeGenerationMode&gt;, const VariableEnvironment*);</span>
<span class="line-modified"> 377         BytecodeGenerator(VM&amp;, EvalNode*, UnlinkedEvalCodeBlock*, OptionSet&lt;CodeGenerationMode&gt;, const VariableEnvironment*);</span>
<span class="line-modified"> 378         BytecodeGenerator(VM&amp;, ModuleProgramNode*, UnlinkedModuleProgramCodeBlock*, OptionSet&lt;CodeGenerationMode&gt;, const VariableEnvironment*);</span>
 379 
 380         ~BytecodeGenerator();
 381 
<span class="line-modified"> 382         VM&amp; vm() const { return m_vm; }</span>
 383         ParserArena&amp; parserArena() const { return m_scopeNode-&gt;parserArena(); }
<span class="line-modified"> 384         const CommonIdentifiers&amp; propertyNames() const { return *m_vm.propertyNames; }</span>
 385 
 386         bool isConstructor() const { return m_codeBlock-&gt;isConstructor(); }
 387         DerivedContextType derivedContextType() const { return m_derivedContextType; }
 388         bool usesArrowFunction() const { return m_scopeNode-&gt;usesArrowFunction(); }
 389         bool needsToUpdateArrowFunctionContext() const { return m_needsToUpdateArrowFunctionContext; }
 390         bool usesEval() const { return m_scopeNode-&gt;usesEval(); }
 391         bool usesThis() const { return m_scopeNode-&gt;usesThis(); }
 392         ConstructorKind constructorKind() const { return m_codeBlock-&gt;constructorKind(); }
 393         SuperBinding superBinding() const { return m_codeBlock-&gt;superBinding(); }
 394         JSParserScriptMode scriptMode() const { return m_codeBlock-&gt;scriptMode(); }
 395 
 396         template&lt;typename Node, typename UnlinkedCodeBlock&gt;
<span class="line-modified"> 397         static ParserError generate(VM&amp; vm, Node* node, const SourceCode&amp; sourceCode, UnlinkedCodeBlock* unlinkedCodeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* environment)</span>
 398         {
 399             MonotonicTime before;
 400             if (UNLIKELY(Options::reportBytecodeCompileTimes()))
 401                 before = MonotonicTime::now();
 402 
 403             DeferGC deferGC(vm.heap);
<span class="line-modified"> 404             auto bytecodeGenerator = makeUnique&lt;BytecodeGenerator&gt;(vm, node, unlinkedCodeBlock, codeGenerationMode, environment);</span>
 405             auto result = bytecodeGenerator-&gt;generate();
 406 
 407             if (UNLIKELY(Options::reportBytecodeCompileTimes())) {
 408                 MonotonicTime after = MonotonicTime::now();
 409                 dataLogLn(result.isValid() ? &quot;Failed to compile #&quot; : &quot;Compiled #&quot;, CodeBlockHash(sourceCode, unlinkedCodeBlock-&gt;isConstructor() ? CodeForConstruct : CodeForCall), &quot; into bytecode &quot;, bytecodeGenerator-&gt;instructions().size(), &quot; instructions in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
 410             }
 411             return result;
 412         }
 413 
 414         bool isArgumentNumber(const Identifier&amp;, int);
 415 
 416         Variable variable(const Identifier&amp;, ThisResolutionType = ThisResolutionType::Local);
 417 
 418         enum ExistingVariableMode { VerifyExisting, IgnoreExisting };
 419         void createVariable(const Identifier&amp;, VarKind, SymbolTable*, ExistingVariableMode = VerifyExisting); // Creates the variable, or asserts that the already-created variable is sufficiently compatible.
 420 
 421         // Returns the register storing &quot;this&quot;
 422         RegisterID* thisRegister() { return &amp;m_thisRegister; }
 423         RegisterID* argumentsRegister() { return m_argumentsRegister; }
 424         RegisterID* newTarget()
 425         {
<span class="line-added"> 426             ASSERT(m_newTargetRegister);</span>
 427             return m_newTargetRegister;
 428         }
 429 
 430         RegisterID* scopeRegister() { return m_scopeRegister; }
 431 
 432         RegisterID* generatorRegister() { return m_generatorRegister; }
 433 
 434         RegisterID* promiseCapabilityRegister() { return m_promiseCapabilityRegister; }
 435 
 436         // Returns the next available temporary register. Registers returned by
 437         // newTemporary require a modified form of reference counting: any
 438         // register with a refcount of 0 is considered &quot;available&quot;, meaning that
 439         // the next instruction may overwrite it.
 440         RegisterID* newTemporary();
 441 
 442         // The same as newTemporary(), but this function returns &quot;suggestion&quot; if
 443         // &quot;suggestion&quot; is a temporary. This function is helpful in situations
 444         // where you&#39;ve put &quot;suggestion&quot; in a RefPtr, but you&#39;d like to allow
 445         // the next instruction to overwrite it anyway.
 446         RegisterID* newTemporaryOr(RegisterID* suggestion) { return suggestion-&gt;isTemporary() ? suggestion : newTemporary(); }
</pre>
<hr />
<pre>
 484         // Moves src to dst if dst is not null and is different from src, otherwise just returns src.
 485         RegisterID* move(RegisterID* dst, RegisterID* src)
 486         {
 487             return dst == ignoredResult() ? nullptr : (dst &amp;&amp; dst != src) ? emitMove(dst, src) : src;
 488         }
 489 
 490         Ref&lt;LabelScope&gt; newLabelScope(LabelScope::Type, const Identifier* = 0);
 491         Ref&lt;Label&gt; newLabel();
 492         Ref&lt;Label&gt; newEmittedLabel();
 493 
 494         void emitNode(RegisterID* dst, StatementNode* n)
 495         {
 496             SetForScope&lt;bool&gt; tailPositionPoisoner(m_inTailPosition, false);
 497             return emitNodeInTailPosition(dst, n);
 498         }
 499 
 500         void emitNodeInTailPosition(RegisterID* dst, StatementNode* n)
 501         {
 502             // Node::emitCode assumes that dst, if provided, is either a local or a referenced temporary.
 503             ASSERT(!dst || dst == ignoredResult() || !dst-&gt;isTemporary() || dst-&gt;refCount());
<span class="line-modified"> 504             if (UNLIKELY(!m_vm.isSafeToRecurse())) {</span>
 505                 emitThrowExpressionTooDeepException();
 506                 return;
 507             }
 508             if (UNLIKELY(n-&gt;needsDebugHook()))
 509                 emitDebugHook(n);
 510             n-&gt;emitBytecode(*this, dst);
 511         }
 512 
 513         void recordOpcode(OpcodeID);
 514 
 515         ALWAYS_INLINE unsigned addMetadataFor(OpcodeID opcodeID)
 516         {
 517             return m_codeBlock-&gt;metadata().addEntry(opcodeID);
 518         }
 519 
 520         void emitNode(StatementNode* n)
 521         {
 522             emitNode(nullptr, n);
 523         }
 524 
 525         void emitNodeInTailPosition(StatementNode* n)
 526         {
 527             emitNodeInTailPosition(nullptr, n);
 528         }
 529 
 530         RegisterID* emitNode(RegisterID* dst, ExpressionNode* n)
 531         {
 532             SetForScope&lt;bool&gt; tailPositionPoisoner(m_inTailPosition, false);
 533             return emitNodeInTailPosition(dst, n);
 534         }
 535 
 536         RegisterID* emitNodeInTailPosition(RegisterID* dst, ExpressionNode* n)
 537         {
 538             // Node::emitCode assumes that dst, if provided, is either a local or a referenced temporary.
 539             ASSERT(!dst || dst == ignoredResult() || !dst-&gt;isTemporary() || dst-&gt;refCount());
<span class="line-modified"> 540             if (UNLIKELY(!m_vm.isSafeToRecurse()))</span>
 541                 return emitThrowExpressionTooDeepException();
 542             if (UNLIKELY(n-&gt;needsDebugHook()))
 543                 emitDebugHook(n);
 544             return n-&gt;emitBytecode(*this, dst);
 545         }
 546 
 547         RegisterID* emitNode(ExpressionNode* n)
 548         {
 549             return emitNode(nullptr, n);
 550         }
 551 
 552         RegisterID* emitNodeInTailPosition(ExpressionNode* n)
 553         {
 554             return emitNodeInTailPosition(nullptr, n);
 555         }
 556 
 557         RegisterID* emitDefineClassElements(PropertyListNode* n, RegisterID* constructor, RegisterID* prototype)
 558         {
 559             ASSERT(constructor-&gt;refCount() &amp;&amp; prototype-&gt;refCount());
<span class="line-modified"> 560             if (UNLIKELY(!m_vm.isSafeToRecurse()))</span>
 561                 return emitThrowExpressionTooDeepException();
 562             if (UNLIKELY(n-&gt;needsDebugHook()))
 563                 emitDebugHook(n);
 564             return n-&gt;emitBytecode(*this, constructor, prototype);
 565         }
 566 
 567         RegisterID* emitNodeForProperty(RegisterID* dst, ExpressionNode* node)
 568         {
 569             if (node-&gt;isString()) {
 570                 if (Optional&lt;uint32_t&gt; index = parseIndex(static_cast&lt;StringNode*&gt;(node)-&gt;value()))
 571                     return emitLoad(dst, jsNumber(index.value()));
 572             }
 573             return emitNode(dst, node);
 574         }
 575 
 576         RegisterID* emitNodeForProperty(ExpressionNode* n)
 577         {
 578             return emitNodeForProperty(nullptr, n);
 579         }
 580 
 581         void emitNodeInConditionContext(ExpressionNode* n, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
 582         {
<span class="line-modified"> 583             if (UNLIKELY(!m_vm.isSafeToRecurse())) {</span>
 584                 emitThrowExpressionTooDeepException();
 585                 return;
 586             }
 587             n-&gt;emitBytecodeInConditionContext(*this, trueTarget, falseTarget, fallThroughMode);
 588         }
 589 
 590         void emitExpressionInfo(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
 591         {
 592             ASSERT(divot.offset &gt;= divotStart.offset);
 593             ASSERT(divotEnd.offset &gt;= divot.offset);
 594 
 595             int sourceOffset = m_scopeNode-&gt;source().startOffset();
 596             unsigned firstLine = m_scopeNode-&gt;source().firstLine().oneBasedInt();
 597 
 598             int divotOffset = divot.offset - sourceOffset;
 599             int startOffset = divot.offset - divotStart.offset;
 600             int endOffset = divotEnd.offset - divot.offset;
 601 
 602             unsigned line = divot.line;
 603             ASSERT(line &gt;= firstLine);
</pre>
<hr />
<pre>
 696             BinaryOp::emit(this, dst, src1, src2);
 697             return dst;
 698         }
 699 
 700         template&lt;typename BinaryOp&gt;
 701         std::enable_if_t&lt;
 702             BinaryOp::opcodeID == op_add
 703             || BinaryOp::opcodeID == op_mul
 704             || BinaryOp::opcodeID == op_sub
 705             || BinaryOp::opcodeID == op_div,
 706             RegisterID*&gt;
 707         emitBinaryOp(RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes types)
 708         {
 709             BinaryOp::emit(this, dst, src1, src2, types);
 710             return dst;
 711         }
 712 
 713         RegisterID* emitBinaryOp(OpcodeID, RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes);
 714 
 715         template&lt;typename EqOp&gt;
<span class="line-modified"> 716         RegisterID* emitEqualityOp(RegisterID* dst, RegisterID* src1, RegisterID* src2)</span>
<span class="line-added"> 717         {</span>
<span class="line-added"> 718             if (!emitEqualityOpImpl(dst, src1, src2))</span>
<span class="line-added"> 719                 EqOp::emit(this, dst, src1, src2);</span>
<span class="line-added"> 720             return dst;</span>
<span class="line-added"> 721         }</span>
<span class="line-added"> 722 </span>
<span class="line-added"> 723         bool emitEqualityOpImpl(RegisterID* dst, RegisterID* src1, RegisterID* src2);</span>
<span class="line-added"> 724 </span>
 725         RegisterID* emitCreateThis(RegisterID* dst);
 726         void emitTDZCheck(RegisterID* target);
 727         bool needsTDZCheck(const Variable&amp;);
 728         void emitTDZCheckIfNecessary(const Variable&amp;, RegisterID* target, RegisterID* scope);
 729         void liftTDZCheckIfPossible(const Variable&amp;);
 730         RegisterID* emitNewObject(RegisterID* dst);
 731         RegisterID* emitNewArray(RegisterID* dst, ElementNode*, unsigned length, IndexingType recommendedIndexingType); // stops at first elision
 732         RegisterID* emitNewArrayBuffer(RegisterID* dst, JSImmutableButterfly*, IndexingType recommendedIndexingType);
 733         // FIXME: new_array_with_spread should use an array allocation profile and take a recommendedIndexingType
 734         RegisterID* emitNewArrayWithSpread(RegisterID* dst, ElementNode*);
 735         RegisterID* emitNewArrayWithSize(RegisterID* dst, RegisterID* length);
 736 
 737         RegisterID* emitNewFunction(RegisterID* dst, FunctionMetadataNode*);
 738         RegisterID* emitNewFunctionExpression(RegisterID* dst, FuncExprNode*);
 739         RegisterID* emitNewDefaultConstructor(RegisterID* dst, ConstructorKind, const Identifier&amp; name, const Identifier&amp; ecmaName, const SourceCode&amp; classSource);
 740         RegisterID* emitNewArrowFunctionExpression(RegisterID*, ArrowFuncExprNode*);
 741         RegisterID* emitNewMethodDefinition(RegisterID* dst, MethodDefinitionNode*);
 742         RegisterID* emitNewRegExp(RegisterID* dst, RegExp*);
 743 
 744         void emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name);
</pre>
<hr />
<pre>
 830 
 831         RegisterID* emitResolveScopeForHoistingFuncDeclInEval(RegisterID* dst, const Identifier&amp;);
 832 
 833         RegisterID* initializeVariable(const Variable&amp;, RegisterID* value);
 834 
 835         void emitLabel(Label&amp;);
 836         void emitLoopHint();
 837         void emitJump(Label&amp; target);
 838         void emitJumpIfTrue(RegisterID* cond, Label&amp; target);
 839         void emitJumpIfFalse(RegisterID* cond, Label&amp; target);
 840         void emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target);
 841         void emitJumpIfNotFunctionApply(RegisterID* cond, Label&amp; target);
 842 
 843         template&lt;typename BinOp, typename JmpOp&gt;
 844         bool fuseCompareAndJump(RegisterID* cond, Label&amp; target, bool swapOperands = false);
 845 
 846         template&lt;typename UnaryOp, typename JmpOp&gt;
 847         bool fuseTestAndJmp(RegisterID* cond, Label&amp; target);
 848 
 849         void emitEnter();

 850 
 851         RegisterID* emitHasIndexedProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName);
 852         RegisterID* emitHasStructureProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName, RegisterID* enumerator);
 853         RegisterID* emitHasGenericProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName);
 854         RegisterID* emitGetPropertyEnumerator(RegisterID* dst, RegisterID* base);
 855         RegisterID* emitGetEnumerableLength(RegisterID* dst, RegisterID* base);
 856         RegisterID* emitGetStructurePropertyEnumerator(RegisterID* dst, RegisterID* base, RegisterID* length);
 857         RegisterID* emitGetGenericPropertyEnumerator(RegisterID* dst, RegisterID* base, RegisterID* length, RegisterID* structureEnumerator);
 858         RegisterID* emitEnumeratorStructurePropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index);
 859         RegisterID* emitEnumeratorGenericPropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index);
 860         RegisterID* emitToIndexString(RegisterID* dst, RegisterID* index);
 861 
 862         RegisterID* emitIsCellWithType(RegisterID* dst, RegisterID* src, JSType);
 863         RegisterID* emitIsJSArray(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, ArrayType); }
 864         RegisterID* emitIsProxyObject(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, ProxyObjectType); }
 865         RegisterID* emitIsRegExpObject(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, RegExpObjectType); }
 866         RegisterID* emitIsMap(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSMapType); }
 867         RegisterID* emitIsSet(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSSetType); }
 868         RegisterID* emitIsObject(RegisterID* dst, RegisterID* src);
 869         RegisterID* emitIsNumber(RegisterID* dst, RegisterID* src);
 870         RegisterID* emitIsUndefined(RegisterID* dst, RegisterID* src);
 871         RegisterID* emitIsUndefinedOrNull(RegisterID* dst, RegisterID* src);
 872         RegisterID* emitIsEmpty(RegisterID* dst, RegisterID* src);
 873         RegisterID* emitIsDerivedArray(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, DerivedArrayType); }
 874         void emitRequireObjectCoercible(RegisterID* value, const String&amp; error);
 875 
 876         RegisterID* emitIteratorNext(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, const ThrowableExpressionData* node, JSC::EmitAwait = JSC::EmitAwait::No);
 877         RegisterID* emitIteratorNextWithValue(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, RegisterID* value, const ThrowableExpressionData* node);
 878         void emitIteratorClose(RegisterID* iterator, const ThrowableExpressionData* node, EmitAwait = EmitAwait::No);
 879 
 880         RegisterID* emitRestParameter(RegisterID* result, unsigned numParametersToSkip);
 881 
 882         bool emitReadOnlyExceptionIfNeeded(const Variable&amp;);
 883 
 884         // Start a try block. &#39;start&#39; must have been emitted.
 885         TryData* pushTry(Label&amp; start, Label&amp; handlerLabel, HandlerType);
 886         // End a try block. &#39;end&#39; must have been emitted.
 887         void popTry(TryData*, Label&amp; end);
<span class="line-modified"> 888 </span>
<span class="line-added"> 889         void emitOutOfLineCatchHandler(RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData*);</span>
<span class="line-added"> 890         void emitOutOfLineFinallyHandler(RegisterID* exceptionRegister, RegisterID* completionTypeRegister, TryData*);</span>
 891 
 892     private:
 893         static const int CurrentLexicalScopeIndex = -2;
 894         static const int OutermostLexicalScopeIndex = -1;
 895 
 896         int currentLexicalScopeIndex() const
 897         {
 898             int size = static_cast&lt;int&gt;(m_lexicalScopeStack.size());
 899             ASSERT(static_cast&lt;size_t&gt;(size) == m_lexicalScopeStack.size());
 900             ASSERT(size &gt;= 0);
 901             if (!size)
 902                 return OutermostLexicalScopeIndex;
 903             return size - 1;
 904         }
 905 
<span class="line-added"> 906         void emitOutOfLineExceptionHandler(RegisterID* exceptionRegister, RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData*);</span>
<span class="line-added"> 907 </span>
 908     public:
 909         void restoreScopeRegister();
 910         void restoreScopeRegister(int lexicalScopeIndex);
 911 
 912         int labelScopeDepthToLexicalScopeIndex(int labelScopeDepth);
 913 
 914         void emitThrow(RegisterID*);
 915         RegisterID* emitArgumentCount(RegisterID*);
 916 
 917         void emitThrowStaticError(ErrorType, RegisterID*);
 918         void emitThrowStaticError(ErrorType, const Identifier&amp; message);
 919         void emitThrowReferenceError(const String&amp; message);
 920         void emitThrowTypeError(const String&amp; message);
 921         void emitThrowTypeError(const Identifier&amp; message);
 922         void emitThrowRangeError(const Identifier&amp; message);
 923         void emitThrowOutOfMemoryError();
 924 
 925         void emitPushCatchScope(VariableEnvironment&amp;);
 926         void emitPopCatchScope(VariableEnvironment&amp;);
 927 
 928         RegisterID* emitGetIterator(RegisterID*, ThrowableExpressionData*);
 929         RegisterID* emitGetAsyncIterator(RegisterID*, ThrowableExpressionData*);
 930 
 931         void emitAwait(RegisterID*);
 932         void emitGetScope();
 933         RegisterID* emitPushWithScope(RegisterID* objectScope);
 934         void emitPopWithScope();
 935         void emitPutThisToArrowFunctionContextScope();
 936         void emitPutNewTargetToArrowFunctionContextScope();
 937         void emitPutDerivedConstructorToArrowFunctionContextScope();
 938         RegisterID* emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();
 939 
 940         void emitDebugHook(DebugHookType, const JSTextPosition&amp;);
 941         void emitDebugHook(DebugHookType, unsigned line, unsigned charOffset, unsigned lineStart);
 942         void emitDebugHook(StatementNode*);
 943         void emitDebugHook(ExpressionNode*);
 944         void emitWillLeaveCallFrameDebugHook();
 945 
<span class="line-modified"> 946         void emitLoad(RegisterID* completionTypeRegister, CompletionType type)</span>


































 947         {
<span class="line-modified"> 948             emitLoad(completionTypeRegister, JSValue(static_cast&lt;int&gt;(type)));</span>
 949         }
 950 
 951         template&lt;typename CompareOp&gt;
 952         void emitJumpIf(RegisterID* completionTypeRegister, CompletionType, Label&amp; jumpTarget);
 953 
 954         bool emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget);
 955         bool emitReturnViaFinallyIfNeeded(RegisterID* returnRegister);
<span class="line-modified"> 956         void emitFinallyCompletion(FinallyContext&amp;, Label&amp; normalCompletionLabel);</span>




 957 
 958     public:
<span class="line-modified"> 959         void pushFinallyControlFlowScope(FinallyContext&amp;);</span>
<span class="line-modified"> 960         void popFinallyControlFlowScope();</span>
<span class="line-added"> 961 </span>
<span class="line-added"> 962         void pushOptionalChainTarget();</span>
<span class="line-added"> 963         void popOptionalChainTarget();</span>
<span class="line-added"> 964         void popOptionalChainTarget(RegisterID* dst, bool isDelete);</span>
<span class="line-added"> 965         void emitOptionalCheck(RegisterID* src);</span>
 966 
 967         void pushIndexedForInScope(RegisterID* local, RegisterID* index);
 968         void popIndexedForInScope(RegisterID* local);
 969         void pushStructureForInScope(RegisterID* local, RegisterID* index, RegisterID* property, RegisterID* enumerator);
 970         void popStructureForInScope(RegisterID* local);
 971 
 972         LabelScope* breakTarget(const Identifier&amp;);
 973         LabelScope* continueTarget(const Identifier&amp;);
 974 
 975         void beginSwitch(RegisterID*, SwitchInfo::SwitchType);
 976         void endSwitch(uint32_t clauseCount, const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp;, ExpressionNode**, Label&amp; defaultLabel, int32_t min, int32_t range);
 977 
 978         void emitYieldPoint(RegisterID*, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason);
 979 
 980         void emitGeneratorStateLabel();
 981         void emitGeneratorStateChange(int32_t state);
 982         RegisterID* emitYield(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason = JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Yield);
 983         RegisterID* emitDelegateYield(RegisterID* argument, ThrowableExpressionData*);
 984         RegisterID* generatorStateRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::State)]; }
 985         RegisterID* generatorValueRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::Value)]; }
 986         RegisterID* generatorResumeModeRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::ResumeMode)]; }
 987         RegisterID* generatorFrameRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::Frame)]; }
 988 
 989         CodeType codeType() const { return m_codeType; }
 990 
 991         bool shouldBeConcernedWithCompletionValue() const { return m_codeType != FunctionCode; }
 992 
<span class="line-modified"> 993         bool shouldEmitDebugHooks() const { return m_codeGenerationMode.contains(CodeGenerationMode::Debugger) &amp;&amp; !m_isBuiltinFunction; }</span>
<span class="line-added"> 994         bool shouldEmitTypeProfilerHooks() const { return m_codeGenerationMode.contains(CodeGenerationMode::TypeProfiler); }</span>
<span class="line-added"> 995         bool shouldEmitControlFlowProfilerHooks() const { return m_codeGenerationMode.contains(CodeGenerationMode::ControlFlowProfiler); }</span>
 996 
 997         bool isStrictMode() const { return m_codeBlock-&gt;isStrictMode(); }
 998 
 999         SourceParseMode parseMode() const { return m_codeBlock-&gt;parseMode(); }
1000 
1001         bool isBuiltinFunction() const { return m_isBuiltinFunction; }
1002 
1003         OpcodeID lastOpcodeID() const { return m_lastOpcodeID; }
1004 
1005         bool isDerivedConstructorContext() { return m_derivedContextType == DerivedContextType::DerivedConstructorContext; }
1006         bool isDerivedClassContext() { return m_derivedContextType == DerivedContextType::DerivedMethodContext; }
1007         bool isArrowFunction() { return m_codeBlock-&gt;isArrowFunction(); }
1008 
1009         enum class TDZCheckOptimization { Optimize, DoNotOptimize };
1010         enum class NestedScopeType { IsNested, IsNotNested };
1011     private:
1012         enum class TDZRequirement { UnderTDZ, NotUnderTDZ };
1013         enum class ScopeType { CatchScope, LetConstScope, FunctionNameScope };
1014         enum class ScopeRegisterType { Var, Block };
1015         void pushLexicalScopeInternal(VariableEnvironment&amp;, TDZCheckOptimization, NestedScopeType, RegisterID** constantSymbolTableResult, TDZRequirement, ScopeType, ScopeRegisterType);
1016         void initializeBlockScopedFunctions(VariableEnvironment&amp;, FunctionStack&amp;, RegisterID* constantSymbolTable);
1017         void popLexicalScopeInternal(VariableEnvironment&amp;);
1018         template&lt;typename LookUpVarKindFunctor&gt;
1019         bool instantiateLexicalVariables(const VariableEnvironment&amp;, SymbolTable*, ScopeRegisterType, LookUpVarKindFunctor);
1020         void emitPrefillStackTDZVariables(const VariableEnvironment&amp;, SymbolTable*);
1021         void emitPopScope(RegisterID* dst, RegisterID* scope);
1022         RegisterID* emitGetParentScope(RegisterID* dst, RegisterID* scope);
1023         void emitPushFunctionNameScope(const Identifier&amp; property, RegisterID* value, bool isCaptured);
1024         void emitNewFunctionExpressionCommon(RegisterID*, FunctionMetadataNode*);
1025 
1026         bool isNewTargetUsedInInnerArrowFunction();
1027         bool isArgumentsUsedInInnerArrowFunction();
1028 
1029         void emitToThis();
1030 
1031         RegisterID* emitMove(RegisterID* dst, RegisterID* src);
1032 
<span class="line-added">1033         bool canDoPeepholeOptimization() const { return m_lastOpcodeID != op_end; }</span>
<span class="line-added">1034 </span>
1035     public:
1036         bool isSuperUsedInInnerArrowFunction();
1037         bool isSuperCallUsedInInnerArrowFunction();
1038         bool isThisUsedInInnerArrowFunction();
1039         void pushLexicalScope(VariableEnvironmentNode*, TDZCheckOptimization, NestedScopeType = NestedScopeType::IsNotNested, RegisterID** constantSymbolTableResult = nullptr, bool shouldInitializeBlockScopedFunctions = true);
1040         void popLexicalScope(VariableEnvironmentNode*);
1041         void prepareLexicalScopeForNextForLoopIteration(VariableEnvironmentNode*, RegisterID* loopSymbolTable);
1042         int labelScopeDepth() const;
1043         UnlinkedArrayProfile newArrayProfile();
1044 
1045     private:
1046         ParserError generate();
1047         void reclaimFreeRegisters();
1048         Variable variableForLocalEntry(const Identifier&amp;, const SymbolTableEntry&amp;, int symbolTableConstantIndex, bool isLexicallyScoped);
1049 
1050         RegisterID* kill(RegisterID* dst)
1051         {
1052             m_staticPropertyAnalyzer.kill(dst);
1053             return dst;
1054         }
1055 
1056         void retrieveLastUnaryOp(int&amp; dstIndex, int&amp; srcIndex);
1057         ALWAYS_INLINE void rewind();
1058 
1059         void allocateCalleeSaveSpace();
1060         void allocateAndEmitScope();
1061 
1062         template&lt;typename JumpOp&gt;
1063         void setTargetForJumpInstruction(InstructionStream::MutableRef&amp;, int target);
1064 
1065         using BigIntMapEntry = std::tuple&lt;UniquedStringImpl*, uint8_t, bool&gt;;
1066 
1067         using NumberMap = HashMap&lt;double, JSValue&gt;;
1068         using IdentifierStringMap = HashMap&lt;UniquedStringImpl*, JSString*, IdentifierRepHash&gt;;
1069         using IdentifierBigIntMap = HashMap&lt;BigIntMapEntry, JSBigInt*&gt;;
<span class="line-modified">1070         using TemplateObjectDescriptorSet = HashSet&lt;Ref&lt;TemplateObjectDescriptor&gt;&gt;;</span>
<span class="line-added">1071         using TemplateDescriptorMap = HashMap&lt;uint64_t, JSTemplateObjectDescriptor*, WTF::IntHash&lt;uint64_t&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;uint64_t&gt;&gt;;</span>
1072 
1073         // Helper for emitCall() and emitConstruct(). This works because the set of
1074         // expected functions have identical behavior for both call and construct
1075         // (i.e. &quot;Object()&quot; is identical to &quot;new Object()&quot;).
1076         ExpectedFunction emitExpectedFunctionSnippet(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, Label&amp; done);
1077 
1078         template&lt;typename CallOp&gt;
1079         RegisterID* emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1080 
1081         RegisterID* emitCallIterator(RegisterID* iterator, RegisterID* argument, ThrowableExpressionData*);
1082         RegisterID* newRegister();
1083 
1084         // Adds an anonymous local var slot. To give this slot a name, add it to symbolTable().
1085         RegisterID* addVar()
1086         {
1087             ++m_codeBlock-&gt;m_numVars;
1088             RegisterID* result = newRegister();
1089             ASSERT(VirtualRegister(result-&gt;index()).toLocal() == m_codeBlock-&gt;m_numVars - 1);
1090             result-&gt;ref(); // We should never free this slot.
1091             return result;
</pre>
<hr />
<pre>
1106             ASSERT(m_parameters.size());
1107             return m_parameters[reg.toArgument()];
1108         }
1109 
1110         bool hasConstant(const Identifier&amp;) const;
1111         unsigned addConstant(const Identifier&amp;);
1112         RegisterID* addConstantValue(JSValue, SourceCodeRepresentation = SourceCodeRepresentation::Other);
1113         RegisterID* addConstantEmptyValue();
1114 
1115         UnlinkedFunctionExecutable* makeFunction(FunctionMetadataNode* metadata)
1116         {
1117             DerivedContextType newDerivedContextType = DerivedContextType::None;
1118 
1119             if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode, SourceParseMode::AsyncArrowFunctionBodyMode).contains(metadata-&gt;parseMode())) {
1120                 if (constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext())
1121                     newDerivedContextType = DerivedContextType::DerivedConstructorContext;
1122                 else if (m_codeBlock-&gt;isClassContext() || isDerivedClassContext())
1123                     newDerivedContextType = DerivedContextType::DerivedMethodContext;
1124             }
1125 
<span class="line-modified">1126             Optional&lt;CompactVariableMap::Handle&gt; optionalVariablesUnderTDZ = getVariablesUnderTDZ();</span>
1127 
1128             // FIXME: These flags, ParserModes and propagation to XXXCodeBlocks should be reorganized.
1129             // https://bugs.webkit.org/show_bug.cgi?id=151547
1130             SourceParseMode parseMode = metadata-&gt;parseMode();
1131             ConstructAbility constructAbility = constructAbilityForParseMode(parseMode);
1132             if (parseMode == SourceParseMode::MethodMode &amp;&amp; metadata-&gt;constructorKind() != ConstructorKind::None)
1133                 constructAbility = ConstructAbility::CanConstruct;
1134 
<span class="line-modified">1135             return UnlinkedFunctionExecutable::create(m_vm, m_scopeNode-&gt;source(), metadata, isBuiltinFunction() ? UnlinkedBuiltinFunction : UnlinkedNormalFunction, constructAbility, scriptMode(), WTFMove(optionalVariablesUnderTDZ), newDerivedContextType);</span>
1136         }
1137 
<span class="line-modified">1138         Optional&lt;CompactVariableMap::Handle&gt; getVariablesUnderTDZ();</span>
1139 
1140         RegisterID* emitConstructVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1141         template&lt;typename CallOp&gt;
1142         RegisterID* emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1143 
1144         void emitLogShadowChickenPrologueIfNecessary();
1145         void emitLogShadowChickenTailIfNecessary();
1146 
1147         void initializeParameters(FunctionParameters&amp;);
1148         void initializeVarLexicalEnvironment(int symbolTableConstantIndex, SymbolTable* functionSymbolTable, bool hasCapturedVariables);
1149         void initializeDefaultParameterValuesAndSetupFunctionScopeStack(FunctionParameters&amp;, bool isSimpleParameterList, FunctionNode*, SymbolTable*, int symbolTableConstantIndex, const ScopedLambda&lt;bool (UniquedStringImpl*)&gt;&amp; captures, bool shouldCreateArgumentsVariableInParameterScope);
1150         void initializeArrowFunctionContextScopeIfNeeded(SymbolTable* functionSymbolTable = nullptr, bool canReuseLexicalEnvironment = false);
1151         bool needsDerivedConstructorInArrowFunctionLexicalEnvironment();
1152 
1153         enum class TDZNecessityLevel {
1154             NotNeeded,
1155             Optimize,
1156             DoNotOptimize
1157         };
1158         typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, TDZNecessityLevel, IdentifierRepHash&gt; TDZMap;
1159 
1160     public:
1161         JSString* addStringConstant(const Identifier&amp;);
1162         JSValue addBigIntConstant(const Identifier&amp;, uint8_t radix, bool sign);
<span class="line-modified">1163         RegisterID* addTemplateObjectConstant(Ref&lt;TemplateObjectDescriptor&gt;&amp;&amp;, int);</span>
1164 
1165         const InstructionStream&amp; instructions() const { return m_writer; }
1166 
1167         RegisterID* emitThrowExpressionTooDeepException();
1168 
1169         void write(uint8_t byte) { m_writer.write(byte); }
<span class="line-added">1170         void write(uint16_t h) { m_writer.write(h); }</span>
1171         void write(uint32_t i) { m_writer.write(i); }
<span class="line-modified">1172         void write(int8_t byte) { m_writer.write(static_cast&lt;uint8_t&gt;(byte)); }</span>
<span class="line-added">1173         void write(int16_t h) { m_writer.write(static_cast&lt;uint16_t&gt;(h)); }</span>
<span class="line-added">1174         void write(int32_t i) { m_writer.write(static_cast&lt;uint32_t&gt;(i)); }</span>
<span class="line-added">1175         void alignWideOpcode16();</span>
<span class="line-added">1176         void alignWideOpcode32();</span>
1177 
1178         class PreservedTDZStack {
1179         private:
1180             Vector&lt;TDZMap&gt; m_preservedTDZStack;
1181             friend class BytecodeGenerator;
1182         };
1183 
1184         void preserveTDZStack(PreservedTDZStack&amp;);
1185         void restoreTDZStack(const PreservedTDZStack&amp;);
1186 
1187         template&lt;typename Func&gt;
1188         void withWriter(InstructionStreamWriter&amp; writer, const Func&amp; fn)
1189         {
1190             auto prevLastOpcodeID = m_lastOpcodeID;
1191             auto prevLastInstruction = m_lastInstruction;
1192             m_writer.swap(writer);
1193             m_lastOpcodeID = op_end;
1194             m_lastInstruction = m_writer.ref();
1195             fn();
1196             m_writer.swap(writer);
1197             m_lastOpcodeID = prevLastOpcodeID;
1198             m_lastInstruction = prevLastInstruction;
1199         }
1200 
1201     private:
1202         InstructionStreamWriter m_writer;
1203 
<span class="line-modified">1204         OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;</span>
1205 
1206         struct LexicalScopeStackEntry {
1207             SymbolTable* m_symbolTable;
1208             RegisterID* m_scope;
1209             bool m_isWithScope;
1210             int m_symbolTableConstantIndex;
1211         };
1212         Vector&lt;LexicalScopeStackEntry&gt; m_lexicalScopeStack;
1213 
1214         Vector&lt;TDZMap&gt; m_TDZStack;
1215         Optional&lt;size_t&gt; m_varScopeLexicalScopeStackIndex;
1216         void pushTDZVariables(const VariableEnvironment&amp;, TDZCheckOptimization, TDZRequirement);
1217 
1218         ScopeNode* const m_scopeNode;
1219         Strong&lt;UnlinkedCodeBlock&gt; m_codeBlock;
1220 
1221         // Some of these objects keep pointers to one another. They are arranged
1222         // to ensure a sane destruction order that avoids references to freed memory.
1223         HashSet&lt;RefPtr&lt;UniquedStringImpl&gt;, IdentifierRepHash&gt; m_functions;
1224         RegisterID m_ignoredResultRegister;
1225         RegisterID m_thisRegister;
1226         RegisterID m_calleeRegister;
1227         RegisterID* m_scopeRegister { nullptr };
1228         RegisterID* m_topMostScope { nullptr };
1229         RegisterID* m_argumentsRegister { nullptr };
1230         RegisterID* m_lexicalEnvironmentRegister { nullptr };
1231         RegisterID* m_generatorRegister { nullptr };
1232         RegisterID* m_emptyValueRegister { nullptr };
1233         RegisterID* m_newTargetRegister { nullptr };
1234         RegisterID* m_isDerivedConstuctor { nullptr };
1235         RegisterID* m_linkTimeConstantRegisters[LinkTimeConstantCount];
1236         RegisterID* m_arrowFunctionContextLexicalEnvironmentRegister { nullptr };
1237         RegisterID* m_promiseCapabilityRegister { nullptr };
1238 



1239         FinallyContext* m_currentFinallyContext { nullptr };
1240 
1241         SegmentedVector&lt;RegisterID*, 16&gt; m_localRegistersForCalleeSaveRegisters;
1242         SegmentedVector&lt;RegisterID, 32&gt; m_constantPoolRegisters;
1243         SegmentedVector&lt;RegisterID, 32&gt; m_calleeLocals;
1244         SegmentedVector&lt;RegisterID, 32&gt; m_parameters;
1245         SegmentedVector&lt;Label, 32&gt; m_labels;
1246         SegmentedVector&lt;LabelScope, 32&gt; m_labelScopes;
1247         unsigned m_finallyDepth { 0 };
<span class="line-modified">1248         unsigned m_localScopeDepth { 0 };</span>
1249         const CodeType m_codeType;
1250 
<span class="line-modified">1251         unsigned localScopeDepth() const;</span>
1252         void pushLocalControlFlowScope();
1253         void popLocalControlFlowScope();
1254 
1255         // FIXME: Restore overflow checking with UnsafeVectorOverflow once SegmentVector supports it.
1256         // https://bugs.webkit.org/show_bug.cgi?id=165980
1257         SegmentedVector&lt;ControlFlowScope, 16&gt; m_controlFlowScopeStack;
1258         Vector&lt;SwitchInfo&gt; m_switchContextStack;
1259         Vector&lt;Ref&lt;ForInContext&gt;&gt; m_forInContextStack;
1260         Vector&lt;TryContext&gt; m_tryContextStack;
1261         unsigned m_yieldPoints { 0 };
1262 
1263         Strong&lt;SymbolTable&gt; m_generatorFrameSymbolTable;
1264         int m_generatorFrameSymbolTableIndex { 0 };
1265 
1266         enum FunctionVariableType : uint8_t { NormalFunctionVariable, TopLevelFunctionVariable };
1267         Vector&lt;std::pair&lt;FunctionMetadataNode*, FunctionVariableType&gt;&gt; m_functionsToInitialize;
1268         bool m_needToInitializeArguments { false };
1269         RestParameterNode* m_restParameter { nullptr };
1270 
1271         Vector&lt;TryRange&gt; m_tryRanges;
1272         SegmentedVector&lt;TryData, 8&gt; m_tryData;
1273 
<span class="line-added">1274         Vector&lt;Ref&lt;Label&gt;&gt; m_optionalChainTargetStack;</span>
<span class="line-added">1275 </span>
1276         int m_nextConstantOffset { 0 };
1277 
1278         typedef HashMap&lt;FunctionMetadataNode*, unsigned&gt; FunctionOffsetMap;
1279         FunctionOffsetMap m_functionOffsets;
1280 
1281         // Constant pool
1282         IdentifierMap m_identifierMap;
1283 
1284         typedef HashMap&lt;EncodedJSValueWithRepresentation, unsigned, EncodedJSValueWithRepresentationHash, EncodedJSValueWithRepresentationHashTraits&gt; JSValueMap;
1285         JSValueMap m_jsValueMap;
1286         IdentifierStringMap m_stringMap;
1287         IdentifierBigIntMap m_bigIntMap;
<span class="line-modified">1288         TemplateObjectDescriptorSet m_templateObjectDescriptorSet;</span>
<span class="line-added">1289         TemplateDescriptorMap m_templateDescriptorMap;</span>
1290 
1291         StaticPropertyAnalyzer m_staticPropertyAnalyzer;
1292 
<span class="line-modified">1293         VM&amp; m_vm;</span>
1294 
1295         OpcodeID m_lastOpcodeID = op_end;
1296         InstructionStream::MutableRef m_lastInstruction { m_writer.ref() };
1297 
1298         bool m_usesExceptions { false };
1299         bool m_expressionTooDeep { false };
1300         bool m_isBuiltinFunction { false };
1301         bool m_usesNonStrictEval { false };
1302         bool m_inTailPosition { false };
1303         bool m_needsToUpdateArrowFunctionContext;
<span class="line-added">1304         bool m_hasCachedVariablesUnderTDZ { false };</span>
1305         DerivedContextType m_derivedContextType { DerivedContextType::None };
1306 
1307         CompactVariableMap::Handle m_cachedVariablesUnderTDZ;
1308 
<span class="line-modified">1309         struct CatchEntry {</span>
<span class="line-modified">1310             TryData* tryData;</span>
<span class="line-added">1311             VirtualRegister exceptionRegister;</span>
<span class="line-added">1312             VirtualRegister thrownValueRegister;</span>
<span class="line-added">1313             VirtualRegister completionTypeRegister;</span>
<span class="line-added">1314         };</span>
<span class="line-added">1315         Vector&lt;CatchEntry&gt; m_exceptionHandlersToEmit;</span>
1316     };
1317 

1318 } // namespace JSC
1319 
1320 namespace WTF {
1321 
1322 void printInternal(PrintStream&amp;, JSC::Variable::VariableKind);
1323 
1324 } // namespace WTF
</pre>
</td>
</tr>
</table>
<center><a href="BytecodeGenerator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NodesCodegen.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>