<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLAbstractHeapRepository.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTLAbstractHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLAbstractHeapRepository.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLAbstractHeapRepository.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 69     FOR_EACH_NUMBERED_ABSTRACT_HEAP(NUMBERED_ABSTRACT_HEAP_INITIALIZATION)
 70 #undef NUMBERED_ABSTRACT_HEAP_INITIALIZATION
 71 
 72     , JSString_value(JSRopeString_fiber0)
 73 
 74     , absolute(&amp;root, &quot;absolute&quot;)
 75 {
 76     // Make sure that our explicit assumptions about the StructureIDBlob match reality.
 77     RELEASE_ASSERT(!(JSCell_indexingTypeAndMisc.offset() &amp; (sizeof(int32_t) - 1)));
 78     RELEASE_ASSERT(JSCell_indexingTypeAndMisc.offset() + 1 == JSCell_typeInfoType.offset());
 79     RELEASE_ASSERT(JSCell_indexingTypeAndMisc.offset() + 2 == JSCell_typeInfoFlags.offset());
 80     RELEASE_ASSERT(JSCell_indexingTypeAndMisc.offset() + 3 == JSCell_cellState.offset());
 81 
 82     JSCell_structureID.changeParent(&amp;JSCell_header);
 83     JSCell_usefulBytes.changeParent(&amp;JSCell_header);
 84     JSCell_indexingTypeAndMisc.changeParent(&amp;JSCell_usefulBytes);
 85     JSCell_typeInfoType.changeParent(&amp;JSCell_usefulBytes);
 86     JSCell_typeInfoFlags.changeParent(&amp;JSCell_usefulBytes);
 87     JSCell_cellState.changeParent(&amp;JSCell_usefulBytes);
 88     JSRopeString_flags.changeParent(&amp;JSRopeString_fiber0);

 89 
 90     RELEASE_ASSERT(!JSCell_freeListNext.offset());
 91 }
 92 
 93 AbstractHeapRepository::~AbstractHeapRepository()
 94 {
 95 }
 96 
 97 void AbstractHeapRepository::decorateMemory(const AbstractHeap* heap, B3::Value* value)
 98 {
 99     m_heapForMemory.append(HeapForValue(heap, value));
100 }
101 
102 void AbstractHeapRepository::decorateCCallRead(const AbstractHeap* heap, B3::Value* value)
103 {
104     m_heapForCCallRead.append(HeapForValue(heap, value));
105 }
106 
107 void AbstractHeapRepository::decorateCCallWrite(const AbstractHeap* heap, B3::Value* value)
108 {
</pre>
</td>
<td>
<hr />
<pre>
 69     FOR_EACH_NUMBERED_ABSTRACT_HEAP(NUMBERED_ABSTRACT_HEAP_INITIALIZATION)
 70 #undef NUMBERED_ABSTRACT_HEAP_INITIALIZATION
 71 
 72     , JSString_value(JSRopeString_fiber0)
 73 
 74     , absolute(&amp;root, &quot;absolute&quot;)
 75 {
 76     // Make sure that our explicit assumptions about the StructureIDBlob match reality.
 77     RELEASE_ASSERT(!(JSCell_indexingTypeAndMisc.offset() &amp; (sizeof(int32_t) - 1)));
 78     RELEASE_ASSERT(JSCell_indexingTypeAndMisc.offset() + 1 == JSCell_typeInfoType.offset());
 79     RELEASE_ASSERT(JSCell_indexingTypeAndMisc.offset() + 2 == JSCell_typeInfoFlags.offset());
 80     RELEASE_ASSERT(JSCell_indexingTypeAndMisc.offset() + 3 == JSCell_cellState.offset());
 81 
 82     JSCell_structureID.changeParent(&amp;JSCell_header);
 83     JSCell_usefulBytes.changeParent(&amp;JSCell_header);
 84     JSCell_indexingTypeAndMisc.changeParent(&amp;JSCell_usefulBytes);
 85     JSCell_typeInfoType.changeParent(&amp;JSCell_usefulBytes);
 86     JSCell_typeInfoFlags.changeParent(&amp;JSCell_usefulBytes);
 87     JSCell_cellState.changeParent(&amp;JSCell_usefulBytes);
 88     JSRopeString_flags.changeParent(&amp;JSRopeString_fiber0);
<span class="line-added"> 89     JSRopeString_length.changeParent(&amp;JSRopeString_fiber1);</span>
 90 
 91     RELEASE_ASSERT(!JSCell_freeListNext.offset());
 92 }
 93 
 94 AbstractHeapRepository::~AbstractHeapRepository()
 95 {
 96 }
 97 
 98 void AbstractHeapRepository::decorateMemory(const AbstractHeap* heap, B3::Value* value)
 99 {
100     m_heapForMemory.append(HeapForValue(heap, value));
101 }
102 
103 void AbstractHeapRepository::decorateCCallRead(const AbstractHeap* heap, B3::Value* value)
104 {
105     m_heapForCCallRead.append(HeapForValue(heap, value));
106 }
107 
108 void AbstractHeapRepository::decorateCCallWrite(const AbstractHeap* heap, B3::Value* value)
109 {
</pre>
</td>
</tr>
</table>
<center><a href="FTLAbstractHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLAbstractHeapRepository.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>