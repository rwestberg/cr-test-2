<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2018 Apple Inc. All rights reserved.
   3  * Copyright (C) 2011 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;DocumentLoader.h&quot;
  32 
  33 #include &quot;ApplicationCacheHost.h&quot;
  34 #include &quot;Archive.h&quot;
  35 #include &quot;ArchiveResourceCollection.h&quot;
  36 #include &quot;CachedPage.h&quot;
  37 #include &quot;CachedRawResource.h&quot;
  38 #include &quot;CachedResourceLoader.h&quot;
  39 #include &quot;ContentExtensionError.h&quot;
  40 #include &quot;ContentSecurityPolicy.h&quot;
  41 #include &quot;DOMWindow.h&quot;
  42 #include &quot;Document.h&quot;
  43 #include &quot;DocumentParser.h&quot;
  44 #include &quot;DocumentWriter.h&quot;
  45 #include &quot;ElementChildIterator.h&quot;
  46 #include &quot;Event.h&quot;
  47 #include &quot;EventNames.h&quot;
  48 #include &quot;ExtensionStyleSheets.h&quot;
  49 #include &quot;FormState.h&quot;
  50 #include &quot;Frame.h&quot;
  51 #include &quot;FrameLoader.h&quot;
  52 #include &quot;FrameLoaderClient.h&quot;
  53 #include &quot;FrameTree.h&quot;
  54 #include &quot;HTMLFormElement.h&quot;
  55 #include &quot;HTMLFrameOwnerElement.h&quot;
  56 #include &quot;HTTPHeaderField.h&quot;
  57 #include &quot;HTTPHeaderNames.h&quot;
  58 #include &quot;HistoryItem.h&quot;
  59 #include &quot;HistoryController.h&quot;
  60 #include &quot;IconLoader.h&quot;
  61 #include &quot;InspectorInstrumentation.h&quot;
  62 #include &quot;LinkIconCollector.h&quot;
  63 #include &quot;LinkIconType.h&quot;
  64 #include &quot;LoaderStrategy.h&quot;
  65 #include &quot;Logging.h&quot;
  66 #include &quot;MemoryCache.h&quot;
  67 #include &quot;NetworkLoadMetrics.h&quot;
  68 #include &quot;Page.h&quot;
  69 #include &quot;PingLoader.h&quot;
  70 #include &quot;PlatformStrategies.h&quot;
  71 #include &quot;PolicyChecker.h&quot;
  72 #include &quot;ProgressTracker.h&quot;
  73 #include &quot;ResourceHandle.h&quot;
  74 #include &quot;ResourceLoadObserver.h&quot;
  75 #include &quot;RuntimeEnabledFeatures.h&quot;
  76 #include &quot;SWClientConnection.h&quot;
  77 #include &quot;SchemeRegistry.h&quot;
  78 #include &quot;ScriptableDocumentParser.h&quot;
  79 #include &quot;SecurityPolicy.h&quot;
  80 #include &quot;ServiceWorker.h&quot;
  81 #include &quot;ServiceWorkerClientData.h&quot;
  82 #include &quot;ServiceWorkerProvider.h&quot;
  83 #include &quot;Settings.h&quot;
  84 #include &quot;SubresourceLoader.h&quot;
  85 #include &quot;TextResourceDecoder.h&quot;
  86 #include &lt;wtf/Assertions.h&gt;
  87 #include &lt;wtf/CompletionHandler.h&gt;
  88 #include &lt;wtf/NeverDestroyed.h&gt;
  89 #include &lt;wtf/Ref.h&gt;
  90 #include &lt;wtf/text/CString.h&gt;
  91 #include &lt;wtf/text/WTFString.h&gt;
  92 
  93 #if ENABLE(APPLICATION_MANIFEST)
  94 #include &quot;ApplicationManifestLoader.h&quot;
  95 #include &quot;HTMLHeadElement.h&quot;
  96 #include &quot;HTMLLinkElement.h&quot;
  97 #endif
  98 
  99 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 100 #include &quot;ArchiveFactory.h&quot;
 101 #endif
 102 
 103 #if ENABLE(CONTENT_FILTERING)
 104 #include &quot;ContentFilter.h&quot;
 105 #endif
 106 
 107 #if USE(QUICK_LOOK)
 108 #include &quot;PreviewConverter.h&quot;
 109 #include &quot;QuickLook.h&quot;
 110 #endif
 111 
 112 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - DocumentLoader::&quot; fmt, this, ##__VA_ARGS__)
 113 
 114 namespace WebCore {
 115 
 116 static void cancelAll(const ResourceLoaderMap&amp; loaders)
 117 {
 118     for (auto&amp; loader : copyToVector(loaders.values()))
 119         loader-&gt;cancel();
 120 }
 121 
 122 static void setAllDefersLoading(const ResourceLoaderMap&amp; loaders, bool defers)
 123 {
 124     for (auto&amp; loader : copyToVector(loaders.values()))
 125         loader-&gt;setDefersLoading(defers);
 126 }
 127 
 128 static bool areAllLoadersPageCacheAcceptable(const ResourceLoaderMap&amp; loaders)
 129 {
 130     for (auto&amp; loader : copyToVector(loaders.values())) {
 131         if (!loader-&gt;frameLoader() || !loader-&gt;frameLoader()-&gt;frame().page())
 132             return false;
 133 
 134         CachedResource* cachedResource = MemoryCache::singleton().resourceForRequest(loader-&gt;request(), loader-&gt;frameLoader()-&gt;frame().page()-&gt;sessionID());
 135         if (!cachedResource)
 136             return false;
 137 
 138         // Only image and XHR loads do prevent the page from entering the PageCache.
 139         // All non-image loads will prevent the page from entering the PageCache.
 140         if (!cachedResource-&gt;isImage() &amp;&amp; !cachedResource-&gt;areAllClientsXMLHttpRequests())
 141             return false;
 142     }
 143     return true;
 144 }
 145 
 146 DocumentLoader::DocumentLoader(const ResourceRequest&amp; request, const SubstituteData&amp; substituteData)
 147     : FrameDestructionObserver(nullptr)
 148     , m_cachedResourceLoader(CachedResourceLoader::create(this))
 149     , m_originalRequest(request)
 150     , m_substituteData(substituteData)
 151     , m_originalRequestCopy(request)
 152     , m_request(request)
 153     , m_originalSubstituteDataWasValid(substituteData.isValid())
 154     , m_substituteResourceDeliveryTimer(*this, &amp;DocumentLoader::substituteResourceDeliveryTimerFired)
 155     , m_dataLoadTimer(*this, &amp;DocumentLoader::handleSubstituteDataLoadNow)
 156     , m_applicationCacheHost(std::make_unique&lt;ApplicationCacheHost&gt;(*this))
 157 {
 158 }
 159 
 160 FrameLoader* DocumentLoader::frameLoader() const
 161 {
 162     if (!m_frame)
 163         return nullptr;
 164     return &amp;m_frame-&gt;loader();
 165 }
 166 
 167 SubresourceLoader* DocumentLoader::mainResourceLoader() const
 168 {
 169     if (!m_mainResource)
 170         return nullptr;
 171     return m_mainResource-&gt;loader();
 172 }
 173 
 174 DocumentLoader::~DocumentLoader()
 175 {
 176     ASSERT(!m_frame || !isLoading() || frameLoader()-&gt;activeDocumentLoader() != this);
 177     ASSERT_WITH_MESSAGE(!m_waitingForContentPolicy, &quot;The content policy callback should never outlive its DocumentLoader.&quot;);
 178     ASSERT_WITH_MESSAGE(!m_waitingForNavigationPolicy, &quot;The navigation policy callback should never outlive its DocumentLoader.&quot;);
 179 
 180     m_cachedResourceLoader-&gt;clearDocumentLoader();
 181     clearMainResource();
 182 }
 183 
 184 RefPtr&lt;SharedBuffer&gt; DocumentLoader::mainResourceData() const
 185 {
 186     if (m_substituteData.isValid())
 187         return m_substituteData.content()-&gt;copy();
 188     if (m_mainResource)
 189         return m_mainResource-&gt;resourceBuffer();
 190     return nullptr;
 191 }
 192 
 193 Document* DocumentLoader::document() const
 194 {
 195     if (m_frame &amp;&amp; m_frame-&gt;loader().documentLoader() == this)
 196         return m_frame-&gt;document();
 197     return nullptr;
 198 }
 199 
 200 void DocumentLoader::replaceRequestURLForSameDocumentNavigation(const URL&amp; url)
 201 {
 202     m_originalRequestCopy.setURL(url);
 203     m_request.setURL(url);
 204 }
 205 
 206 void DocumentLoader::setRequest(const ResourceRequest&amp; req)
 207 {
 208     // Replacing an unreachable URL with alternate content looks like a server-side
 209     // redirect at this point, but we can replace a committed dataSource.
 210     bool handlingUnreachableURL = false;
 211 
 212     handlingUnreachableURL = m_substituteData.isValid() &amp;&amp; !m_substituteData.failingURL().isEmpty();
 213 
 214     bool shouldNotifyAboutProvisionalURLChange = false;
 215     if (handlingUnreachableURL)
 216         m_committed = false;
 217     else if (isLoadingMainResource() &amp;&amp; req.url() != m_request.url())
 218         shouldNotifyAboutProvisionalURLChange = true;
 219 
 220     // We should never be getting a redirect callback after the data
 221     // source is committed, except in the unreachable URL case. It
 222     // would be a WebFoundation bug if it sent a redirect callback after commit.
 223     ASSERT(!m_committed);
 224 
 225     m_request = req;
 226     if (shouldNotifyAboutProvisionalURLChange)
 227         frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
 228 }
 229 
 230 void DocumentLoader::setMainDocumentError(const ResourceError&amp; error)
 231 {
 232     if (!error.isNull())
 233         RELEASE_LOG_IF_ALLOWED(&quot;setMainDocumentError: (frame = %p, main = %d, type = %d, code = %d)&quot;, m_frame, m_frame-&gt;isMainFrame(), static_cast&lt;int&gt;(error.type()), error.errorCode());
 234 
 235     m_mainDocumentError = error;
 236     frameLoader()-&gt;client().setMainDocumentError(this, error);
 237 }
 238 
 239 void DocumentLoader::mainReceivedError(const ResourceError&amp; error)
 240 {
 241     ASSERT(!error.isNull());
 242 
 243     if (!frameLoader())
 244         return;
 245 
 246     if (!error.isNull())
 247         RELEASE_LOG_IF_ALLOWED(&quot;mainReceivedError: (frame = %p, main = %d, type = %d, code = %d)&quot;, m_frame, m_frame-&gt;isMainFrame(), static_cast&lt;int&gt;(error.type()), error.errorCode());
 248 
 249     if (m_identifierForLoadWithoutResourceLoader) {
 250         ASSERT(!mainResourceLoader());
 251         frameLoader()-&gt;client().dispatchDidFailLoading(this, m_identifierForLoadWithoutResourceLoader, error);
 252     }
 253 
 254     // There is a bug in CFNetwork where callbacks can be dispatched even when loads are deferred.
 255     // See &lt;rdar://problem/6304600&gt; for more details.
 256 #if !USE(CF)
 257     ASSERT(!mainResourceLoader() || !mainResourceLoader()-&gt;defersLoading());
 258 #endif
 259 
 260     m_applicationCacheHost-&gt;failedLoadingMainResource();
 261 
 262     setMainDocumentError(error);
 263     clearMainResourceLoader();
 264     frameLoader()-&gt;receivedMainResourceError(error);
 265 }
 266 
 267 // Cancels the data source&#39;s pending loads.  Conceptually, a data source only loads
 268 // one document at a time, but one document may have many related resources.
 269 // stopLoading will stop all loads initiated by the data source,
 270 // but not loads initiated by child frames&#39; data sources -- that&#39;s the WebFrame&#39;s job.
 271 void DocumentLoader::stopLoading()
 272 {
 273     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
 274     Ref&lt;DocumentLoader&gt; protectedThis(*this);
 275 
 276     // In some rare cases, calling FrameLoader::stopLoading could cause isLoading() to return false.
 277     // (This can happen when there&#39;s a single XMLHttpRequest currently loading and stopLoading causes it
 278     // to stop loading. Because of this, we need to save it so we don&#39;t return early.
 279     bool loading = isLoading();
 280 
 281     // We may want to audit the existing subresource loaders when we are on a page which has completed
 282     // loading but there are subresource loads during cancellation. This must be done before the
 283     // frame-&gt;stopLoading() call, which may evict the CachedResources, which we rely on to check
 284     // the type of the resource loads.
 285     if (loading &amp;&amp; m_committed &amp;&amp; !mainResourceLoader() &amp;&amp; !m_subresourceLoaders.isEmpty())
 286         m_subresourceLoadersArePageCacheAcceptable = areAllLoadersPageCacheAcceptable(m_subresourceLoaders);
 287 
 288     if (m_committed) {
 289         // Attempt to stop the frame if the document loader is loading, or if it is done loading but
 290         // still  parsing. Failure to do so can cause a world leak.
 291         Document* doc = m_frame-&gt;document();
 292 
 293         if (loading || doc-&gt;parsing())
 294             m_frame-&gt;loader().stopLoading(UnloadEventPolicyNone);
 295     }
 296 
 297     for (auto callbackIdentifier : m_iconLoaders.values())
 298         notifyFinishedLoadingIcon(callbackIdentifier, nullptr);
 299     m_iconLoaders.clear();
 300     m_iconsPendingLoadDecision.clear();
 301 
 302 #if ENABLE(APPLICATION_MANIFEST)
 303     for (auto callbackIdentifier : m_applicationManifestLoaders.values())
 304         notifyFinishedLoadingApplicationManifest(callbackIdentifier, WTF::nullopt);
 305     m_applicationManifestLoaders.clear();
 306 #endif
 307 
 308     // Always cancel multipart loaders
 309     cancelAll(m_multipartSubresourceLoaders);
 310 
 311     // Appcache uses ResourceHandle directly, DocumentLoader doesn&#39;t count these loads.
 312     m_applicationCacheHost-&gt;stopLoadingInFrame(*m_frame);
 313 
 314 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 315     clearArchiveResources();
 316 #endif
 317 
 318     if (!loading) {
 319         // If something above restarted loading we might run into mysterious crashes like
 320         // https://bugs.webkit.org/show_bug.cgi?id=62764 and &lt;rdar://problem/9328684&gt;
 321         ASSERT(!isLoading());
 322         return;
 323     }
 324 
 325     // We might run in to infinite recursion if we&#39;re stopping loading as the result of
 326     // detaching from the frame, so break out of that recursion here.
 327     // See &lt;rdar://problem/9673866&gt; for more details.
 328     if (m_isStopping)
 329         return;
 330 
 331     m_isStopping = true;
 332 
 333     // The frame may have been detached from this document by the onunload handler
 334     if (auto* frameLoader = DocumentLoader::frameLoader()) {
 335         RELEASE_LOG_IF_ALLOWED(&quot;stopLoading: canceling load (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 336         if (isLoadingMainResource()) {
 337             // Stop the main resource loader and let it send the cancelled message.
 338             cancelMainResourceLoad(frameLoader-&gt;cancelledError(m_request));
 339         } else if (!m_subresourceLoaders.isEmpty() || !m_plugInStreamLoaders.isEmpty()) {
 340             // The main resource loader already finished loading. Set the cancelled error on the
 341             // document and let the subresourceLoaders and pluginLoaders send individual cancelled messages below.
 342             setMainDocumentError(frameLoader-&gt;cancelledError(m_request));
 343         } else {
 344             // If there are no resource loaders, we need to manufacture a cancelled message.
 345             // (A back/forward navigation has no resource loaders because its resources are cached.)
 346             mainReceivedError(frameLoader-&gt;cancelledError(m_request));
 347         }
 348     }
 349 
 350     // We always need to explicitly cancel the Document&#39;s parser when stopping the load.
 351     // Otherwise cancelling the parser while starting the next page load might result
 352     // in unexpected side effects such as erroneous event dispatch. ( http://webkit.org/b/117112 )
 353     if (Document* document = this-&gt;document())
 354         document-&gt;cancelParsing();
 355 
 356     stopLoadingSubresources();
 357     stopLoadingPlugIns();
 358 
 359     m_isStopping = false;
 360 }
 361 
 362 void DocumentLoader::commitIfReady()
 363 {
 364     if (!m_committed) {
 365         m_committed = true;
 366         frameLoader()-&gt;commitProvisionalLoad();
 367     }
 368 }
 369 
 370 bool DocumentLoader::isLoading() const
 371 {
 372     // if (document() &amp;&amp; document()-&gt;hasActiveParser())
 373     //     return true;
 374     // FIXME: The above code should be enabled, but it seems to cause
 375     // http/tests/security/feed-urls-from-remote.html to timeout on Mac WK1
 376     // see http://webkit.org/b/110554 and http://webkit.org/b/110401
 377 
 378     return isLoadingMainResource() || !m_subresourceLoaders.isEmpty() || !m_plugInStreamLoaders.isEmpty();
 379 }
 380 
 381 void DocumentLoader::notifyFinished(CachedResource&amp; resource)
 382 {
 383     ASSERT(isMainThread());
 384 #if ENABLE(CONTENT_FILTERING)
 385     if (m_contentFilter &amp;&amp; !m_contentFilter-&gt;continueAfterNotifyFinished(resource))
 386         return;
 387 #endif
 388 
 389     ASSERT_UNUSED(resource, m_mainResource == &amp;resource);
 390     ASSERT(m_mainResource);
 391     if (!m_mainResource-&gt;errorOccurred() &amp;&amp; !m_mainResource-&gt;wasCanceled()) {
 392         finishedLoading();
 393         return;
 394     }
 395 
 396     if (m_request.cachePolicy() == ResourceRequestCachePolicy::ReturnCacheDataDontLoad &amp;&amp; !m_mainResource-&gt;wasCanceled()) {
 397         frameLoader()-&gt;retryAfterFailedCacheOnlyMainResourceLoad();
 398         return;
 399     }
 400 
 401     if (!m_mainResource-&gt;resourceError().isNull())
 402         RELEASE_LOG_IF_ALLOWED(&quot;notifyFinished: canceling load (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 403 
 404     mainReceivedError(m_mainResource-&gt;resourceError());
 405 }
 406 
 407 void DocumentLoader::finishedLoading()
 408 {
 409     // There is a bug in CFNetwork where callbacks can be dispatched even when loads are deferred.
 410     // See &lt;rdar://problem/6304600&gt; for more details.
 411 #if !USE(CF)
 412     ASSERT(!m_frame-&gt;page()-&gt;defersLoading() || frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument() || InspectorInstrumentation::isDebuggerPaused(m_frame));
 413 #endif
 414 
 415     Ref&lt;DocumentLoader&gt; protectedThis(*this);
 416 
 417     if (m_identifierForLoadWithoutResourceLoader) {
 418         // A didFinishLoading delegate might try to cancel the load (despite it
 419         // being finished). Clear m_identifierForLoadWithoutResourceLoader
 420         // before calling dispatchDidFinishLoading so that we don&#39;t later try to
 421         // cancel the already-finished substitute load.
 422         NetworkLoadMetrics emptyMetrics;
 423         unsigned long identifier = m_identifierForLoadWithoutResourceLoader;
 424         m_identifierForLoadWithoutResourceLoader = 0;
 425         frameLoader()-&gt;notifier().dispatchDidFinishLoading(this, identifier, emptyMetrics, nullptr);
 426     }
 427 
 428     maybeFinishLoadingMultipartContent();
 429 
 430     MonotonicTime responseEndTime = m_timeOfLastDataReceived ? m_timeOfLastDataReceived : MonotonicTime::now();
 431     timing().setResponseEnd(responseEndTime);
 432 
 433     commitIfReady();
 434     if (!frameLoader())
 435         return;
 436 
 437     if (!maybeCreateArchive()) {
 438         // If this is an empty document, it will not have actually been created yet. Commit dummy data so that
 439         // DocumentWriter::begin() gets called and creates the Document.
 440         if (!m_gotFirstByte)
 441             commitData(0, 0);
 442         frameLoader()-&gt;client().finishedLoading(this);
 443     }
 444 
 445     m_writer.end();
 446     if (!m_mainDocumentError.isNull())
 447         return;
 448     clearMainResourceLoader();
 449     if (!frameLoader())
 450         return;
 451     if (!frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument())
 452         frameLoader()-&gt;checkLoadComplete();
 453 
 454     // If the document specified an application cache manifest, it violates the author&#39;s intent if we store it in the memory cache
 455     // and deny the appcache the chance to intercept it in the future, so remove from the memory cache.
 456     if (m_frame) {
 457         if (m_mainResource &amp;&amp; m_frame-&gt;document()-&gt;hasManifest())
 458             MemoryCache::singleton().remove(*m_mainResource);
 459     }
 460     m_applicationCacheHost-&gt;finishedLoadingMainResource();
 461 }
 462 
 463 bool DocumentLoader::isPostOrRedirectAfterPost(const ResourceRequest&amp; newRequest, const ResourceResponse&amp; redirectResponse)
 464 {
 465     if (newRequest.httpMethod() == &quot;POST&quot;)
 466         return true;
 467 
 468     int status = redirectResponse.httpStatusCode();
 469     if (((status &gt;= 301 &amp;&amp; status &lt;= 303) || status == 307)
 470         &amp;&amp; m_originalRequest.httpMethod() == &quot;POST&quot;)
 471         return true;
 472 
 473     return false;
 474 }
 475 
 476 void DocumentLoader::handleSubstituteDataLoadNow()
 477 {
 478     ResourceResponse response = m_substituteData.response();
 479     if (response.url().isEmpty())
 480         response = ResourceResponse(m_request.url(), m_substituteData.mimeType(), m_substituteData.content()-&gt;size(), m_substituteData.textEncoding());
 481 
 482     responseReceived(response, nullptr);
 483 }
 484 
 485 void DocumentLoader::startDataLoadTimer()
 486 {
 487     m_dataLoadTimer.startOneShot(0_s);
 488 
 489 #if HAVE(RUNLOOP_TIMER)
 490     if (SchedulePairHashSet* scheduledPairs = m_frame-&gt;page()-&gt;scheduledRunLoopPairs())
 491         m_dataLoadTimer.schedule(*scheduledPairs);
 492 #endif
 493 }
 494 
 495 #if ENABLE(SERVICE_WORKER)
 496 void DocumentLoader::matchRegistration(const URL&amp; url, SWClientConnection::RegistrationCallback&amp;&amp; callback)
 497 {
 498     auto shouldTryLoadingThroughServiceWorker = !frameLoader()-&gt;isReloadingFromOrigin() &amp;&amp; m_frame-&gt;page() &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; SchemeRegistry::canServiceWorkersHandleURLScheme(url.protocol().toStringWithoutCopying());
 499     if (!shouldTryLoadingThroughServiceWorker) {
 500         callback(WTF::nullopt);
 501         return;
 502     }
 503 
 504     auto origin = (!m_frame-&gt;isMainFrame() &amp;&amp; m_frame-&gt;document()) ? m_frame-&gt;document()-&gt;topOrigin().data() : SecurityOriginData::fromURL(url);
 505     auto sessionID = m_frame-&gt;page()-&gt;sessionID();
 506     auto&amp; provider = ServiceWorkerProvider::singleton();
 507     if (!provider.mayHaveServiceWorkerRegisteredForOrigin(sessionID, origin)) {
 508         callback(WTF::nullopt);
 509         return;
 510     }
 511 
 512     auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID);
 513     connection.matchRegistration(WTFMove(origin), url, WTFMove(callback));
 514 }
 515 
 516 static inline bool areRegistrationsEqual(const Optional&lt;ServiceWorkerRegistrationData&gt;&amp; a, const Optional&lt;ServiceWorkerRegistrationData&gt;&amp; b)
 517 {
 518     if (!a)
 519         return !b;
 520     if (!b)
 521         return false;
 522     return a-&gt;identifier == b-&gt;identifier;
 523 }
 524 #endif
 525 
 526 void DocumentLoader::redirectReceived(CachedResource&amp; resource, ResourceRequest&amp;&amp; request, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
 527 {
 528     ASSERT_UNUSED(resource, &amp;resource == m_mainResource);
 529 #if ENABLE(SERVICE_WORKER)
 530     bool isRedirectionFromServiceWorker = redirectResponse.source() == ResourceResponse::Source::ServiceWorker;
 531     willSendRequest(WTFMove(request), redirectResponse, [isRedirectionFromServiceWorker, completionHandler = WTFMove(completionHandler), protectedThis = makeRef(*this), this] (auto&amp;&amp; request) mutable {
 532         ASSERT(!m_substituteData.isValid());
 533         if (request.isNull() || !m_mainDocumentError.isNull() || !m_frame) {
 534             completionHandler({ });
 535             return;
 536         }
 537 
 538         auto url = request.url();
 539         this-&gt;matchRegistration(url, [request = WTFMove(request), isRedirectionFromServiceWorker, completionHandler = WTFMove(completionHandler), protectedThis = WTFMove(protectedThis), this] (auto&amp;&amp; registrationData) mutable {
 540             if (!m_mainDocumentError.isNull() || !m_frame) {
 541                 completionHandler({ });
 542                 return;
 543             }
 544 
 545             if (!registrationData &amp;&amp; this-&gt;tryLoadingRedirectRequestFromApplicationCache(request)) {
 546                 completionHandler({ });
 547                 return;
 548             }
 549 
 550             bool shouldContinueLoad = areRegistrationsEqual(m_serviceWorkerRegistrationData, registrationData)
 551                 &amp;&amp; isRedirectionFromServiceWorker == !!registrationData;
 552 
 553             if (shouldContinueLoad) {
 554                 completionHandler(WTFMove(request));
 555                 return;
 556             }
 557 
 558             this-&gt;restartLoadingDueToServiceWorkerRegistrationChange(WTFMove(request), WTFMove(registrationData));
 559             completionHandler({ });
 560             return;
 561         });
 562     });
 563 #else
 564     willSendRequest(WTFMove(request), redirectResponse, WTFMove(completionHandler));
 565 #endif
 566 }
 567 
 568 void DocumentLoader::willSendRequest(ResourceRequest&amp;&amp; newRequest, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
 569 {
 570     // Note that there are no asserts here as there are for the other callbacks. This is due to the
 571     // fact that this &quot;callback&quot; is sent when starting every load, and the state of callback
 572     // deferrals plays less of a part in this function in preventing the bad behavior deferring
 573     // callbacks is meant to prevent.
 574     ASSERT(!newRequest.isNull());
 575 
 576     bool didReceiveRedirectResponse = !redirectResponse.isNull();
 577     if (!frameLoader()-&gt;checkIfFormActionAllowedByCSP(newRequest.url(), didReceiveRedirectResponse)) {
 578         RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - form action not allowed by CSP (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 579         cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 580         return completionHandler(WTFMove(newRequest));
 581     }
 582 
 583     ASSERT(timing().fetchStart());
 584     if (didReceiveRedirectResponse) {
 585         // If the redirecting url is not allowed to display content from the target origin,
 586         // then block the redirect.
 587         Ref&lt;SecurityOrigin&gt; redirectingOrigin(SecurityOrigin::create(redirectResponse.url()));
 588         if (!redirectingOrigin.get().canDisplay(newRequest.url())) {
 589             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - redirecting URL not allowed to display content from target(frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 590             FrameLoader::reportLocalLoadFailed(m_frame, newRequest.url().string());
 591             cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 592             return completionHandler(WTFMove(newRequest));
 593         }
 594         if (!portAllowed(newRequest.url())) {
 595             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - port not allowed (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 596             FrameLoader::reportBlockedPortFailed(m_frame, newRequest.url().string());
 597             cancelMainResourceLoad(frameLoader()-&gt;blockedError(newRequest));
 598             return completionHandler(WTFMove(newRequest));
 599         }
 600         timing().addRedirect(redirectResponse.url(), newRequest.url());
 601     }
 602 
 603     ASSERT(m_frame);
 604 
 605     Frame&amp; topFrame = m_frame-&gt;tree().top();
 606 
 607     ASSERT(m_frame-&gt;document());
 608     ASSERT(topFrame.document());
 609 
 610     // Update cookie policy base URL as URL changes, except for subframes, which use the
 611     // URL of the main frame which doesn&#39;t change when we redirect.
 612     if (m_frame-&gt;isMainFrame())
 613         newRequest.setFirstPartyForCookies(newRequest.url());
 614 
 615     FrameLoader::addSameSiteInfoToRequestIfNeeded(newRequest, m_frame-&gt;document());
 616 
 617     if (!didReceiveRedirectResponse)
 618         frameLoader()-&gt;client().dispatchWillChangeDocument(m_frame-&gt;document()-&gt;url(), newRequest.url());
 619 
 620     // If we&#39;re fielding a redirect in response to a POST, force a load from origin, since
 621     // this is a common site technique to return to a page viewing some data that the POST
 622     // just modified.
 623     // Also, POST requests always load from origin, but this does not affect subresources.
 624     if (newRequest.cachePolicy() == ResourceRequestCachePolicy::UseProtocolCachePolicy &amp;&amp; isPostOrRedirectAfterPost(newRequest, redirectResponse))
 625         newRequest.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
 626 
 627     if (&amp;topFrame != m_frame) {
 628         if (!m_frame-&gt;loader().mixedContentChecker().canDisplayInsecureContent(m_frame-&gt;document()-&gt;securityOrigin(), MixedContentChecker::ContentType::Active, newRequest.url(), MixedContentChecker::AlwaysDisplayInNonStrictMode::Yes)) {
 629             cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 630             return completionHandler(WTFMove(newRequest));
 631         }
 632         if (!frameLoader()-&gt;mixedContentChecker().canDisplayInsecureContent(topFrame.document()-&gt;securityOrigin(), MixedContentChecker::ContentType::Active, newRequest.url())) {
 633             cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 634             return completionHandler(WTFMove(newRequest));
 635         }
 636     }
 637 
 638 #if ENABLE(CONTENT_FILTERING)
 639     if (m_contentFilter &amp;&amp; !m_contentFilter-&gt;continueAfterWillSendRequest(newRequest, redirectResponse))
 640         return completionHandler(WTFMove(newRequest));
 641 #endif
 642 
 643     setRequest(newRequest);
 644 
 645     if (!didReceiveRedirectResponse)
 646         return completionHandler(WTFMove(newRequest));
 647 
 648     auto navigationPolicyCompletionHandler = [this, protectedThis = makeRef(*this), completionHandler = WTFMove(completionHandler)] (ResourceRequest&amp;&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) mutable {
 649         m_waitingForNavigationPolicy = false;
 650         switch (navigationPolicyDecision) {
 651         case NavigationPolicyDecision::IgnoreLoad:
 652         case NavigationPolicyDecision::StopAllLoads:
 653             stopLoadingForPolicyChange();
 654             break;
 655         case NavigationPolicyDecision::ContinueLoad:
 656             break;
 657         }
 658 
 659         completionHandler(WTFMove(request));
 660     };
 661 
 662     ASSERT(!m_waitingForNavigationPolicy);
 663     m_waitingForNavigationPolicy = true;
 664 
 665     // FIXME: Add a load type check.
 666     auto&amp; policyChecker = frameLoader()-&gt;policyChecker();
 667     RELEASE_ASSERT(!isBackForwardLoadType(policyChecker.loadType()) || frameLoader()-&gt;history().provisionalItem());
 668     policyChecker.checkNavigationPolicy(WTFMove(newRequest), redirectResponse, WTFMove(navigationPolicyCompletionHandler));
 669 }
 670 
 671 bool DocumentLoader::tryLoadingRequestFromApplicationCache()
 672 {
 673     m_applicationCacheHost-&gt;maybeLoadMainResource(m_request, m_substituteData);
 674     return tryLoadingSubstituteData();
 675 }
 676 
 677 bool DocumentLoader::tryLoadingSubstituteData()
 678 {
 679     if (!m_substituteData.isValid() || !m_frame-&gt;page())
 680         return false;
 681 
 682     RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Returning substitute data (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 683     m_identifierForLoadWithoutResourceLoader = m_frame-&gt;page()-&gt;progress().createUniqueIdentifier();
 684     frameLoader()-&gt;notifier().assignIdentifierToInitialRequest(m_identifierForLoadWithoutResourceLoader, this, m_request);
 685     frameLoader()-&gt;notifier().dispatchWillSendRequest(this, m_identifierForLoadWithoutResourceLoader, m_request, ResourceResponse());
 686 
 687     if (!m_deferMainResourceDataLoad || frameLoader()-&gt;loadsSynchronously())
 688         handleSubstituteDataLoadNow();
 689     else
 690         startDataLoadTimer();
 691 
 692     return true;
 693 }
 694 
 695 bool DocumentLoader::tryLoadingRedirectRequestFromApplicationCache(const ResourceRequest&amp; request)
 696 {
 697     m_applicationCacheHost-&gt;maybeLoadMainResourceForRedirect(request, m_substituteData);
 698     if (!m_substituteData.isValid())
 699         return false;
 700 
 701     RELEASE_ASSERT(m_mainResource);
 702     auto* loader = m_mainResource-&gt;loader();
 703     m_identifierForLoadWithoutResourceLoader = loader ? loader-&gt;identifier() : m_mainResource-&gt;identifierForLoadWithoutResourceLoader();
 704 
 705     // We need to remove our reference to the CachedResource in favor of a SubstituteData load, which can triger the cancellation of the underyling ResourceLoader.
 706     // If the ResourceLoader is indeed cancelled, it would normally send resource load callbacks.
 707     // Therefore, sever our relationship with the network load but prevent the ResourceLoader from sending ResourceLoadNotifier callbacks.
 708 
 709     auto resourceLoader = makeRefPtr(mainResourceLoader());
 710     if (resourceLoader) {
 711         ASSERT(resourceLoader-&gt;shouldSendResourceLoadCallbacks());
 712         resourceLoader-&gt;setSendCallbackPolicy(SendCallbackPolicy::DoNotSendCallbacks);
 713     }
 714 
 715     clearMainResource();
 716 
 717     if (resourceLoader)
 718         resourceLoader-&gt;setSendCallbackPolicy(SendCallbackPolicy::SendCallbacks);
 719 
 720     handleSubstituteDataLoadNow();
 721     return true;
 722 }
 723 
 724 #if ENABLE(SERVICE_WORKER)
 725 void DocumentLoader::restartLoadingDueToServiceWorkerRegistrationChange(ResourceRequest&amp;&amp; request, Optional&lt;ServiceWorkerRegistrationData&gt;&amp;&amp; registrationData)
 726 {
 727     clearMainResource();
 728 
 729     ASSERT(!isCommitted());
 730     m_serviceWorkerRegistrationData = WTFMove(registrationData);
 731     loadMainResource(WTFMove(request));
 732 
 733     if (m_mainResource)
 734         frameLoader()-&gt;client().dispatchDidReceiveServerRedirectForProvisionalLoad();
 735 }
 736 #endif
 737 
 738 void DocumentLoader::stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(unsigned long identifier, const ResourceResponse&amp; response)
 739 {
 740     Ref&lt;DocumentLoader&gt; protectedThis { *this };
 741     InspectorInstrumentation::continueAfterXFrameOptionsDenied(*m_frame, identifier, *this, response);
 742     m_frame-&gt;document()-&gt;enforceSandboxFlags(SandboxOrigin);
 743     if (HTMLFrameOwnerElement* ownerElement = m_frame-&gt;ownerElement())
 744         ownerElement-&gt;dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
 745 
 746     // The load event might have detached this frame. In that case, the load will already have been cancelled during detach.
 747     if (FrameLoader* frameLoader = this-&gt;frameLoader())
 748         cancelMainResourceLoad(frameLoader-&gt;cancelledError(m_request));
 749 }
 750 
 751 void DocumentLoader::responseReceived(CachedResource&amp; resource, const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 752 {
 753     ASSERT_UNUSED(resource, m_mainResource == &amp;resource);
 754     responseReceived(response, WTFMove(completionHandler));
 755 }
 756 
 757 void DocumentLoader::responseReceived(const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 758 {
 759     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
 760 
 761 #if ENABLE(CONTENT_FILTERING)
 762     if (m_contentFilter &amp;&amp; !m_contentFilter-&gt;continueAfterResponseReceived(response))
 763         return;
 764 #endif
 765 
 766     Ref&lt;DocumentLoader&gt; protectedThis(*this);
 767     bool willLoadFallback = m_applicationCacheHost-&gt;maybeLoadFallbackForMainResponse(request(), response);
 768 
 769     // The memory cache doesn&#39;t understand the application cache or its caching rules. So if a main resource is served
 770     // from the application cache, ensure we don&#39;t save the result for future use.
 771     if (willLoadFallback)
 772         MemoryCache::singleton().remove(*m_mainResource);
 773 
 774     if (willLoadFallback)
 775         return;
 776 
 777     ASSERT(m_identifierForLoadWithoutResourceLoader || m_mainResource);
 778     unsigned long identifier = m_identifierForLoadWithoutResourceLoader ? m_identifierForLoadWithoutResourceLoader : m_mainResource-&gt;identifier();
 779     ASSERT(identifier);
 780 
 781     if (m_substituteData.isValid() || !platformStrategies()-&gt;loaderStrategy()-&gt;havePerformedSecurityChecks(response)) {
 782         auto url = response.url();
 783         ContentSecurityPolicy contentSecurityPolicy(URL { url }, this);
 784         contentSecurityPolicy.didReceiveHeaders(ContentSecurityPolicyResponseHeaders { response }, m_request.httpReferrer());
 785         if (!contentSecurityPolicy.allowFrameAncestors(*m_frame, url)) {
 786             stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(identifier, response);
 787             return;
 788         }
 789 
 790         String frameOptions = response.httpHeaderFields().get(HTTPHeaderName::XFrameOptions);
 791         if (!frameOptions.isNull()) {
 792             if (frameLoader()-&gt;shouldInterruptLoadForXFrameOptions(frameOptions, url, identifier)) {
 793                 String message = &quot;Refused to display &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39; in a frame because it set &#39;X-Frame-Options&#39; to &#39;&quot; + frameOptions + &quot;&#39;.&quot;;
 794                 m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, identifier);
 795                 stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(identifier, response);
 796                 return;
 797             }
 798         }
 799     }
 800 
 801     // There is a bug in CFNetwork where callbacks can be dispatched even when loads are deferred.
 802     // See &lt;rdar://problem/6304600&gt; for more details.
 803 #if !USE(CF)
 804     ASSERT(!mainResourceLoader() || !mainResourceLoader()-&gt;defersLoading());
 805 #endif
 806 
 807     if (m_isLoadingMultipartContent) {
 808         setupForReplace();
 809         m_mainResource-&gt;clear();
 810     } else if (response.isMultipart())
 811         m_isLoadingMultipartContent = true;
 812 
 813     m_response = response;
 814 
 815     if (m_identifierForLoadWithoutResourceLoader) {
 816         if (m_mainResource &amp;&amp; m_mainResource-&gt;wasRedirected()) {
 817             ASSERT(m_mainResource-&gt;status() == CachedResource::Status::Cached);
 818             frameLoader()-&gt;client().dispatchDidReceiveServerRedirectForProvisionalLoad();
 819         }
 820         addResponse(m_response);
 821         frameLoader()-&gt;notifier().dispatchDidReceiveResponse(this, m_identifierForLoadWithoutResourceLoader, m_response, 0);
 822     }
 823 
 824     ASSERT(!m_waitingForContentPolicy);
 825     ASSERT(frameLoader());
 826     m_waitingForContentPolicy = true;
 827 
 828     // Always show content with valid substitute data.
 829     if (m_substituteData.isValid()) {
 830         continueAfterContentPolicy(PolicyAction::Use);
 831         return;
 832     }
 833 
 834 #if ENABLE(FTPDIR)
 835     // Respect the hidden FTP Directory Listing pref so it can be tested even if the policy delegate might otherwise disallow it
 836     if (m_frame-&gt;settings().forceFTPDirectoryListings() &amp;&amp; m_response.mimeType() == &quot;application/x-ftp-directory&quot;) {
 837         continueAfterContentPolicy(PolicyAction::Use);
 838         return;
 839     }
 840 #endif
 841 
 842     RefPtr&lt;SubresourceLoader&gt; mainResourceLoader = this-&gt;mainResourceLoader();
 843     if (mainResourceLoader)
 844         mainResourceLoader-&gt;markInAsyncResponsePolicyCheck();
 845     auto requestIdentifier = PolicyCheckIdentifier::create();
 846     frameLoader()-&gt;checkContentPolicy(m_response, requestIdentifier, [this, protectedThis = makeRef(*this), mainResourceLoader = WTFMove(mainResourceLoader),
 847         completionHandler = completionHandlerCaller.release(), requestIdentifier] (PolicyAction policy, PolicyCheckIdentifier responseIdentifeir) mutable {
 848         RELEASE_ASSERT(responseIdentifeir.isValidFor(requestIdentifier));
 849         continueAfterContentPolicy(policy);
 850         if (mainResourceLoader)
 851             mainResourceLoader-&gt;didReceiveResponsePolicy();
 852         if (completionHandler)
 853             completionHandler();
 854     });
 855 }
 856 
 857 // Prevent web archives from loading if
 858 // 1) it is remote;
 859 // 2) it is not the main frame;
 860 // 3) it is not any of { loaded by clients; loaded by drag; reloaded from any of the previous two };
 861 // because they can claim to be from any domain and thus avoid cross-domain security checks (4120255, 45524528, 47610130).
 862 bool DocumentLoader::disallowWebArchive() const
 863 {
 864     using MIMETypeHashSet = HashSet&lt;String, ASCIICaseInsensitiveHash&gt;;
 865     static NeverDestroyed&lt;MIMETypeHashSet&gt; webArchiveMIMETypes {
 866         MIMETypeHashSet {
 867             &quot;application/x-webarchive&quot;_s,
 868             &quot;application/x-mimearchive&quot;_s,
 869             &quot;multipart/related&quot;_s,
 870 #if PLATFORM(GTK)
 871             &quot;message/rfc822&quot;_s,
 872 #endif
 873         }
 874     };
 875 
 876     String mimeType = m_response.mimeType();
 877     if (mimeType.isNull() || !webArchiveMIMETypes.get().contains(mimeType))
 878         return false;
 879 
 880 #if USE(QUICK_LOOK)
 881     if (isQuickLookPreviewURL(m_response.url()))
 882         return false;
 883 #endif
 884 
 885     if (m_substituteData.isValid())
 886         return false;
 887 
 888     if (!SchemeRegistry::shouldTreatURLSchemeAsLocal(m_request.url().protocol().toStringWithoutCopying()))
 889         return true;
 890 
 891     if (!frame() || (frame()-&gt;isMainFrame() &amp;&amp; m_allowsWebArchiveForMainFrame))
 892         return false;
 893 
 894     // On purpose of maintaining existing tests.
 895     if (frame()-&gt;mainFrame().loader().alwaysAllowLocalWebarchive())
 896         return false;
 897     return true;
 898 }
 899 
 900 void DocumentLoader::continueAfterContentPolicy(PolicyAction policy)
 901 {
 902     ASSERT(m_waitingForContentPolicy);
 903     m_waitingForContentPolicy = false;
 904     if (isStopping())
 905         return;
 906 
 907     switch (policy) {
 908     case PolicyAction::Use: {
 909         if (!frameLoader()-&gt;client().canShowMIMEType(m_response.mimeType()) || disallowWebArchive()) {
 910             frameLoader()-&gt;policyChecker().cannotShowMIMEType(m_response);
 911             // Check reachedTerminalState since the load may have already been canceled inside of _handleUnimplementablePolicyWithErrorCode::.
 912             stopLoadingForPolicyChange();
 913             return;
 914         }
 915         break;
 916     }
 917 
 918     case PolicyAction::Download: {
 919         // m_mainResource can be null, e.g. when loading a substitute resource from application cache.
 920         if (!m_mainResource) {
 921             RELEASE_LOG_IF_ALLOWED(&quot;continueAfterContentPolicy: cannot show URL (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 922             mainReceivedError(frameLoader()-&gt;client().cannotShowURLError(m_request));
 923             return;
 924         }
 925 
 926         if (ResourceLoader* mainResourceLoader = this-&gt;mainResourceLoader())
 927             InspectorInstrumentation::continueWithPolicyDownload(*m_frame, mainResourceLoader-&gt;identifier(), *this, m_response);
 928 
 929         // When starting the request, we didn&#39;t know that it would result in download and not navigation. Now we know that main document URL didn&#39;t change.
 930         // Download may use this knowledge for purposes unrelated to cookies, notably for setting file quarantine data.
 931         frameLoader()-&gt;setOriginalURLForDownloadRequest(m_request);
 932 
 933         PAL::SessionID sessionID = PAL::SessionID::defaultSessionID();
 934         if (frame() &amp;&amp; frame()-&gt;page())
 935             sessionID = frame()-&gt;page()-&gt;sessionID();
 936 
 937         if (m_request.url().protocolIsData()) {
 938             // We decode data URL internally, there is no resource load to convert.
 939             frameLoader()-&gt;client().startDownload(m_request);
 940         } else
 941             frameLoader()-&gt;client().convertMainResourceLoadToDownload(this, sessionID, m_request, m_response);
 942 
 943         // It might have gone missing
 944         if (mainResourceLoader())
 945             static_cast&lt;ResourceLoader*&gt;(mainResourceLoader())-&gt;didFail(interruptedForPolicyChangeError());
 946         return;
 947     }
 948     case PolicyAction::StopAllLoads:
 949         ASSERT_NOT_REACHED();
 950 #if ASSERT_DISABLED
 951         FALLTHROUGH;
 952 #endif
 953     case PolicyAction::Ignore:
 954         if (ResourceLoader* mainResourceLoader = this-&gt;mainResourceLoader())
 955             InspectorInstrumentation::continueWithPolicyIgnore(*m_frame, mainResourceLoader-&gt;identifier(), *this, m_response);
 956         stopLoadingForPolicyChange();
 957         return;
 958     }
 959 
 960     if (m_response.isHTTP()) {
 961         int status = m_response.httpStatusCode(); // Status may be zero when loading substitute data, in particular from a WebArchive.
 962         if (status &amp;&amp; (status &lt; 200 || status &gt;= 300)) {
 963             bool hostedByObject = frameLoader()-&gt;isHostedByObjectElement();
 964 
 965             frameLoader()-&gt;handleFallbackContent();
 966             // object elements are no longer rendered after we fallback, so don&#39;t
 967             // keep trying to process data from their load
 968 
 969             if (hostedByObject)
 970                 cancelMainResourceLoad(frameLoader()-&gt;cancelledError(m_request));
 971         }
 972     }
 973 
 974     if (!isStopping() &amp;&amp; m_substituteData.isValid() &amp;&amp; isLoadingMainResource()) {
 975         auto content = m_substituteData.content();
 976         if (content &amp;&amp; content-&gt;size())
 977             dataReceived(content-&gt;data(), content-&gt;size());
 978         if (isLoadingMainResource())
 979             finishedLoading();
 980 
 981         // Remove ourselves as a client of this CachedResource as we&#39;ve decided to commit substitute data but the
 982         // load may keep going and be useful to other clients of the CachedResource. If we did not do this, we
 983         // may receive data later on even though this DocumentLoader has finished loading.
 984         clearMainResource();
 985     }
 986 }
 987 
 988 void DocumentLoader::commitLoad(const char* data, int length)
 989 {
 990     // Both unloading the old page and parsing the new page may execute JavaScript which destroys the datasource
 991     // by starting a new load, so retain temporarily.
 992     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
 993     Ref&lt;DocumentLoader&gt; protectedThis(*this);
 994 
 995     commitIfReady();
 996     FrameLoader* frameLoader = DocumentLoader::frameLoader();
 997     if (!frameLoader)
 998         return;
 999 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1000     if (ArchiveFactory::isArchiveMIMEType(response().mimeType()))
1001         return;
1002 #endif
1003     frameLoader-&gt;client().committedLoad(this, data, length);
1004 
1005     if (isMultipartReplacingLoad())
1006         frameLoader-&gt;client().didReplaceMultipartContent();
1007 }
1008 
1009 ResourceError DocumentLoader::interruptedForPolicyChangeError() const
1010 {
1011     return frameLoader()-&gt;client().interruptedForPolicyChangeError(request());
1012 }
1013 
1014 void DocumentLoader::stopLoadingForPolicyChange()
1015 {
1016     ResourceError error = interruptedForPolicyChangeError();
1017     error.setType(ResourceError::Type::Cancellation);
1018     cancelMainResourceLoad(error);
1019 }
1020 
1021 #if ENABLE(SERVICE_WORKER)
1022 static inline bool isLocalURL(const URL&amp; url)
1023 {
1024     // https://fetch.spec.whatwg.org/#is-local
1025     auto protocol = url.protocol().toStringWithoutCopying();
1026     return equalLettersIgnoringASCIICase(protocol, &quot;data&quot;) || equalLettersIgnoringASCIICase(protocol, &quot;blob&quot;) || equalLettersIgnoringASCIICase(protocol, &quot;about&quot;);
1027 }
1028 #endif
1029 
1030 void DocumentLoader::commitData(const char* bytes, size_t length)
1031 {
1032     if (!m_gotFirstByte) {
1033         m_gotFirstByte = true;
1034         bool hasBegun = m_writer.begin(documentURL(), false);
1035         m_writer.setDocumentWasLoadedAsPartOfNavigation();
1036 
1037         if (SecurityPolicy::allowSubstituteDataAccessToLocal() &amp;&amp; m_originalSubstituteDataWasValid) {
1038             // If this document was loaded with substituteData, then the document can
1039             // load local resources. See https://bugs.webkit.org/show_bug.cgi?id=16756
1040             // and https://bugs.webkit.org/show_bug.cgi?id=19760 for further
1041             // discussion.
1042             m_frame-&gt;document()-&gt;securityOrigin().grantLoadLocalResources();
1043         }
1044 
1045         if (frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument())
1046             return;
1047 
1048 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1049         if (m_archive &amp;&amp; m_archive-&gt;shouldOverrideBaseURL())
1050             m_frame-&gt;document()-&gt;setBaseURLOverride(m_archive-&gt;mainResource()-&gt;url());
1051 #endif
1052 #if ENABLE(SERVICE_WORKER)
1053         if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled()) {
1054             if (m_serviceWorkerRegistrationData &amp;&amp; m_serviceWorkerRegistrationData-&gt;activeWorker) {
1055                 m_frame-&gt;document()-&gt;setActiveServiceWorker(ServiceWorker::getOrCreate(*m_frame-&gt;document(), WTFMove(m_serviceWorkerRegistrationData-&gt;activeWorker.value())));
1056                 m_serviceWorkerRegistrationData = { };
1057             } else if (isLocalURL(m_frame-&gt;document()-&gt;url())) {
1058                 if (auto* parent = m_frame-&gt;document()-&gt;parentDocument())
1059                     m_frame-&gt;document()-&gt;setActiveServiceWorker(parent-&gt;activeServiceWorker());
1060             }
1061 
1062             if (m_frame-&gt;document()-&gt;activeServiceWorker() || SchemeRegistry::canServiceWorkersHandleURLScheme(m_frame-&gt;document()-&gt;url().protocol().toStringWithoutCopying()))
1063                 m_frame-&gt;document()-&gt;setServiceWorkerConnection(ServiceWorkerProvider::singleton().existingServiceWorkerConnectionForSession(m_frame-&gt;page()-&gt;sessionID()));
1064 
1065             // We currently unregister the temporary service worker client since we now registered the real document.
1066             // FIXME: We should make the real document use the temporary client identifier.
1067             unregisterTemporaryServiceWorkerClient();
1068         }
1069 #endif
1070         // Call receivedFirstData() exactly once per load. We should only reach this point multiple times
1071         // for multipart loads, and FrameLoader::isReplacing() will be true after the first time.
1072         if (!isMultipartReplacingLoad())
1073             frameLoader()-&gt;receivedFirstData();
1074 
1075         // The load could be canceled under receivedFirstData(), which makes delegate calls and even sometimes dispatches DOM events.
1076         if (!isLoading())
1077             return;
1078 
1079         bool userChosen;
1080         String encoding;
1081         if (overrideEncoding().isNull()) {
1082             userChosen = false;
1083             encoding = response().textEncodingName();
1084 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1085             if (m_archive &amp;&amp; m_archive-&gt;shouldUseMainResourceEncoding())
1086                 encoding = m_archive-&gt;mainResource()-&gt;textEncoding();
1087 #endif
1088         } else {
1089             userChosen = true;
1090             encoding = overrideEncoding();
1091         }
1092 
1093         m_writer.setEncoding(encoding, userChosen);
1094 
1095         RELEASE_ASSERT(hasBegun);
1096     }
1097 
1098 #if ENABLE(CONTENT_EXTENSIONS)
1099     auto&amp; extensionStyleSheets = m_frame-&gt;document()-&gt;extensionStyleSheets();
1100 
1101     for (auto&amp; pendingStyleSheet : m_pendingNamedContentExtensionStyleSheets)
1102         extensionStyleSheets.maybeAddContentExtensionSheet(pendingStyleSheet.key, *pendingStyleSheet.value);
1103     for (auto&amp; pendingSelectorEntry : m_pendingContentExtensionDisplayNoneSelectors) {
1104         for (const auto&amp; pendingSelector : pendingSelectorEntry.value)
1105             extensionStyleSheets.addDisplayNoneSelector(pendingSelectorEntry.key, pendingSelector.first, pendingSelector.second);
1106     }
1107 
1108     m_pendingNamedContentExtensionStyleSheets.clear();
1109     m_pendingContentExtensionDisplayNoneSelectors.clear();
1110 #endif
1111 
1112     ASSERT(m_frame-&gt;document()-&gt;parsing());
1113     m_writer.addData(bytes, length);
1114 }
1115 
1116 void DocumentLoader::dataReceived(CachedResource&amp; resource, const char* data, int length)
1117 {
1118     ASSERT_UNUSED(resource, &amp;resource == m_mainResource);
1119     dataReceived(data, length);
1120 }
1121 
1122 void DocumentLoader::dataReceived(const char* data, int length)
1123 {
1124 #if ENABLE(CONTENT_FILTERING)
1125     if (m_contentFilter &amp;&amp; !m_contentFilter-&gt;continueAfterDataReceived(data, length))
1126         return;
1127 #endif
1128 
1129     ASSERT(data);
1130     ASSERT(length);
1131     ASSERT(!m_response.isNull());
1132 
1133     // There is a bug in CFNetwork where callbacks can be dispatched even when loads are deferred.
1134     // See &lt;rdar://problem/6304600&gt; for more details.
1135 #if !USE(CF)
1136     ASSERT(!mainResourceLoader() || !mainResourceLoader()-&gt;defersLoading());
1137 #endif
1138 
1139     if (m_identifierForLoadWithoutResourceLoader)
1140         frameLoader()-&gt;notifier().dispatchDidReceiveData(this, m_identifierForLoadWithoutResourceLoader, data, length, -1);
1141 
1142     m_applicationCacheHost-&gt;mainResourceDataReceived(data, length, -1, false);
1143     m_timeOfLastDataReceived = MonotonicTime::now();
1144 
1145     if (!isMultipartReplacingLoad())
1146         commitLoad(data, length);
1147 }
1148 
1149 void DocumentLoader::setupForReplace()
1150 {
1151     if (!mainResourceData())
1152         return;
1153 
1154     frameLoader()-&gt;client().willReplaceMultipartContent();
1155 
1156     maybeFinishLoadingMultipartContent();
1157     maybeCreateArchive();
1158     m_writer.end();
1159     frameLoader()-&gt;setReplacing();
1160     m_gotFirstByte = false;
1161 
1162     stopLoadingSubresources();
1163     stopLoadingPlugIns();
1164 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1165     clearArchiveResources();
1166 #endif
1167 }
1168 
1169 void DocumentLoader::checkLoadComplete()
1170 {
1171     if (!m_frame || isLoading())
1172         return;
1173 
1174     // ASSERT(this == frameLoader()-&gt;activeDocumentLoader());
1175     m_frame-&gt;document()-&gt;domWindow()-&gt;finishedLoading();
1176 }
1177 
1178 void DocumentLoader::attachToFrame(Frame&amp; frame)
1179 {
1180     if (m_frame == &amp;frame)
1181         return;
1182 
1183     ASSERT(!m_frame);
1184     observeFrame(&amp;frame);
1185     m_writer.setFrame(frame);
1186     attachToFrame();
1187 
1188 #ifndef NDEBUG
1189     m_hasEverBeenAttached = true;
1190 #endif
1191 }
1192 
1193 void DocumentLoader::attachToFrame()
1194 {
1195     ASSERT(m_frame);
1196 }
1197 
1198 void DocumentLoader::detachFromFrame()
1199 {
1200 #ifndef NDEBUG
1201     if (m_hasEverBeenAttached)
1202         ASSERT_WITH_MESSAGE(m_frame, &quot;detachFromFrame() is being called on a DocumentLoader twice without an attachToFrame() inbetween&quot;);
1203     else
1204         ASSERT_WITH_MESSAGE(m_frame, &quot;detachFromFrame() is being called on a DocumentLoader that has never attached to any Frame&quot;);
1205 #endif
1206     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
1207     Ref&lt;DocumentLoader&gt; protectedThis(*this);
1208 
1209     // It never makes sense to have a document loader that is detached from its
1210     // frame have any loads active, so kill all the loads.
1211     stopLoading();
1212     if (m_mainResource &amp;&amp; m_mainResource-&gt;hasClient(*this))
1213         m_mainResource-&gt;removeClient(*this);
1214 #if ENABLE(CONTENT_FILTERING)
1215     if (m_contentFilter)
1216         m_contentFilter-&gt;stopFilteringMainResource();
1217 #endif
1218 
1219     m_applicationCacheHost-&gt;setDOMApplicationCache(nullptr);
1220 
1221     cancelPolicyCheckIfNeeded();
1222 
1223     // cancelPolicyCheckIfNeeded can clear m_frame if the policy check
1224     // is stopped, resulting in a recursive call into this detachFromFrame.
1225     // If m_frame is nullptr after cancelPolicyCheckIfNeeded, our work is
1226     // already done so just return.
1227     if (!m_frame)
1228         return;
1229 
1230     InspectorInstrumentation::loaderDetachedFromFrame(*m_frame, *this);
1231 
1232     observeFrame(nullptr);
1233 }
1234 
1235 void DocumentLoader::clearMainResourceLoader()
1236 {
1237     m_loadingMainResource = false;
1238 
1239     if (this == frameLoader()-&gt;activeDocumentLoader())
1240         checkLoadComplete();
1241 }
1242 
1243 #if ENABLE(APPLICATION_MANIFEST)
1244 uint64_t DocumentLoader::loadApplicationManifest()
1245 {
1246     static uint64_t nextCallbackID = 1;
1247 
1248     auto* document = this-&gt;document();
1249     if (!document)
1250         return 0;
1251 
1252     if (!m_frame-&gt;isMainFrame())
1253         return 0;
1254 
1255     if (document-&gt;url().isEmpty() || document-&gt;url().protocolIsAbout())
1256         return 0;
1257 
1258     auto head = document-&gt;head();
1259     if (!head)
1260         return 0;
1261 
1262     URL manifestURL;
1263     bool useCredentials = false;
1264     for (const auto&amp; link : childrenOfType&lt;HTMLLinkElement&gt;(*head)) {
1265         if (link.isApplicationManifest()) {
1266             manifestURL = link.href();
1267             useCredentials = equalIgnoringASCIICase(link.attributeWithoutSynchronization(HTMLNames::crossoriginAttr), &quot;use-credentials&quot;);
1268             break;
1269         }
1270     }
1271 
1272     if (manifestURL.isEmpty() || !manifestURL.isValid())
1273         return 0;
1274 
1275     auto manifestLoader = std::make_unique&lt;ApplicationManifestLoader&gt;(*this, manifestURL, useCredentials);
1276     auto* rawManifestLoader = manifestLoader.get();
1277     auto callbackID = nextCallbackID++;
1278     m_applicationManifestLoaders.set(WTFMove(manifestLoader), callbackID);
1279 
1280     if (!rawManifestLoader-&gt;startLoading()) {
1281         m_applicationManifestLoaders.remove(rawManifestLoader);
1282         return 0;
1283     }
1284 
1285     return callbackID;
1286 }
1287 
1288 void DocumentLoader::finishedLoadingApplicationManifest(ApplicationManifestLoader&amp; loader)
1289 {
1290     // If the DocumentLoader has detached from its frame, all manifest loads should have already been canceled.
1291     ASSERT(m_frame);
1292 
1293     auto callbackIdentifier = m_applicationManifestLoaders.get(&amp;loader);
1294     notifyFinishedLoadingApplicationManifest(callbackIdentifier, loader.processManifest());
1295     m_applicationManifestLoaders.remove(&amp;loader);
1296 }
1297 
1298 void DocumentLoader::notifyFinishedLoadingApplicationManifest(uint64_t callbackIdentifier, Optional&lt;ApplicationManifest&gt; manifest)
1299 {
1300     RELEASE_ASSERT(callbackIdentifier);
1301     RELEASE_ASSERT(m_frame);
1302     m_frame-&gt;loader().client().finishedLoadingApplicationManifest(callbackIdentifier, manifest);
1303 }
1304 #endif
1305 
1306 void DocumentLoader::setCustomHeaderFields(Vector&lt;HTTPHeaderField&gt;&amp;&amp; fields)
1307 {
1308     m_customHeaderFields = WTFMove(fields);
1309 }
1310 
1311 bool DocumentLoader::isLoadingInAPISense() const
1312 {
1313     // Once a frame has loaded, we no longer need to consider subresources,
1314     // but we still need to consider subframes.
1315     if (frameLoader()-&gt;state() != FrameStateComplete) {
1316         if (m_frame-&gt;settings().needsIsLoadingInAPISenseQuirk() &amp;&amp; !m_subresourceLoaders.isEmpty())
1317             return true;
1318 
1319         ASSERT(m_frame-&gt;document());
1320         auto&amp; document = *m_frame-&gt;document();
1321         if ((isLoadingMainResource() || !document.loadEventFinished()) &amp;&amp; isLoading())
1322             return true;
1323         if (m_cachedResourceLoader-&gt;requestCount())
1324             return true;
1325         if (document.isDelayingLoadEvent())
1326             return true;
1327         if (document.processingLoadEvent())
1328             return true;
1329         if (document.hasActiveParser())
1330             return true;
1331         auto* scriptableParser = document.scriptableDocumentParser();
1332         if (scriptableParser &amp;&amp; scriptableParser-&gt;hasScriptsWaitingForStylesheets())
1333             return true;
1334     }
1335     return frameLoader()-&gt;subframeIsLoading();
1336 }
1337 
1338 bool DocumentLoader::maybeCreateArchive()
1339 {
1340 #if !ENABLE(WEB_ARCHIVE) &amp;&amp; !ENABLE(MHTML)
1341     return false;
1342 #else
1343     // Give the archive machinery a crack at this document. If the MIME type is not an archive type, it will return 0.
1344     m_archive = ArchiveFactory::create(m_response.url(), mainResourceData().get(), m_response.mimeType());
1345     if (!m_archive)
1346         return false;
1347 
1348     addAllArchiveResources(*m_archive);
1349     ASSERT(m_archive-&gt;mainResource());
1350     auto&amp; mainResource = *m_archive-&gt;mainResource();
1351     m_parsedArchiveData = &amp;mainResource.data();
1352     m_writer.setMIMEType(mainResource.mimeType());
1353 
1354     ASSERT(m_frame-&gt;document());
1355     commitData(mainResource.data().data(), mainResource.data().size());
1356     return true;
1357 #endif
1358 }
1359 
1360 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1361 
1362 void DocumentLoader::setArchive(Ref&lt;Archive&gt;&amp;&amp; archive)
1363 {
1364     m_archive = WTFMove(archive);
1365     addAllArchiveResources(*m_archive);
1366 }
1367 
1368 void DocumentLoader::addAllArchiveResources(Archive&amp; archive)
1369 {
1370     if (!m_archiveResourceCollection)
1371         m_archiveResourceCollection = std::make_unique&lt;ArchiveResourceCollection&gt;();
1372     m_archiveResourceCollection-&gt;addAllResources(archive);
1373 }
1374 
1375 // FIXME: Adding a resource directly to a DocumentLoader/ArchiveResourceCollection seems like bad design, but is API some apps rely on.
1376 // Can we change the design in a manner that will let us deprecate that API without reducing functionality of those apps?
1377 void DocumentLoader::addArchiveResource(Ref&lt;ArchiveResource&gt;&amp;&amp; resource)
1378 {
1379     if (!m_archiveResourceCollection)
1380         m_archiveResourceCollection = std::make_unique&lt;ArchiveResourceCollection&gt;();
1381     m_archiveResourceCollection-&gt;addResource(WTFMove(resource));
1382 }
1383 
1384 RefPtr&lt;Archive&gt; DocumentLoader::popArchiveForSubframe(const String&amp; frameName, const URL&amp; url)
1385 {
1386     return m_archiveResourceCollection ? m_archiveResourceCollection-&gt;popSubframeArchive(frameName, url) : nullptr;
1387 }
1388 
1389 void DocumentLoader::clearArchiveResources()
1390 {
1391     m_archiveResourceCollection = nullptr;
1392     m_substituteResourceDeliveryTimer.stop();
1393 }
1394 
1395 SharedBuffer* DocumentLoader::parsedArchiveData() const
1396 {
1397     return m_parsedArchiveData.get();
1398 }
1399 
1400 #endif // ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1401 
1402 ArchiveResource* DocumentLoader::archiveResourceForURL(const URL&amp; url) const
1403 {
1404     if (!m_archiveResourceCollection)
1405         return nullptr;
1406     auto* resource = m_archiveResourceCollection-&gt;archiveResourceForURL(url);
1407     if (!resource || resource-&gt;shouldIgnoreWhenUnarchiving())
1408         return nullptr;
1409     return resource;
1410 }
1411 
1412 RefPtr&lt;ArchiveResource&gt; DocumentLoader::mainResource() const
1413 {
1414     RefPtr&lt;SharedBuffer&gt; data = mainResourceData();
1415     if (!data)
1416         data = SharedBuffer::create();
1417     auto&amp; response = this-&gt;response();
1418     return ArchiveResource::create(WTFMove(data), response.url(), response.mimeType(), response.textEncodingName(), frame()-&gt;tree().uniqueName());
1419 }
1420 
1421 RefPtr&lt;ArchiveResource&gt; DocumentLoader::subresource(const URL&amp; url) const
1422 {
1423     if (!isCommitted())
1424         return nullptr;
1425 
1426     auto* resource = m_cachedResourceLoader-&gt;cachedResource(url);
1427     if (!resource || !resource-&gt;isLoaded())
1428         return archiveResourceForURL(url);
1429 
1430     if (resource-&gt;type() == CachedResource::Type::MainResource)
1431         return nullptr;
1432 
1433     auto* data = resource-&gt;resourceBuffer();
1434     if (!data)
1435         return nullptr;
1436 
1437     return ArchiveResource::create(data, url, resource-&gt;response());
1438 }
1439 
1440 Vector&lt;Ref&lt;ArchiveResource&gt;&gt; DocumentLoader::subresources() const
1441 {
1442     if (!isCommitted())
1443         return { };
1444 
1445     Vector&lt;Ref&lt;ArchiveResource&gt;&gt; subresources;
1446     for (auto&amp; handle : m_cachedResourceLoader-&gt;allCachedResources().values()) {
1447         if (auto subresource = this-&gt;subresource({ { }, handle-&gt;url() }))
1448             subresources.append(subresource.releaseNonNull());
1449     }
1450     return subresources;
1451 }
1452 
1453 void DocumentLoader::deliverSubstituteResourcesAfterDelay()
1454 {
1455     if (m_pendingSubstituteResources.isEmpty())
1456         return;
1457     ASSERT(m_frame);
1458     ASSERT(m_frame-&gt;page());
1459     if (m_frame-&gt;page()-&gt;defersLoading())
1460         return;
1461 
1462     if (!m_substituteResourceDeliveryTimer.isActive())
1463         m_substituteResourceDeliveryTimer.startOneShot(0_s);
1464 }
1465 
1466 void DocumentLoader::substituteResourceDeliveryTimerFired()
1467 {
1468     if (m_pendingSubstituteResources.isEmpty())
1469         return;
1470     ASSERT(m_frame);
1471     ASSERT(m_frame-&gt;page());
1472     if (m_frame-&gt;page()-&gt;defersLoading())
1473         return;
1474 
1475     auto pendingSubstituteResources = WTFMove(m_pendingSubstituteResources);
1476     for (auto&amp; pendingSubstituteResource : pendingSubstituteResources) {
1477         auto&amp; loader = pendingSubstituteResource.key;
1478         if (auto&amp; resource = pendingSubstituteResource.value)
1479             resource-&gt;deliver(*loader);
1480         else {
1481             // A null resource means that we should fail the load.
1482             // FIXME: Maybe we should use another error here - something like &quot;not in cache&quot;.
1483             loader-&gt;didFail(loader-&gt;cannotShowURLError());
1484         }
1485     }
1486 }
1487 
1488 #ifndef NDEBUG
1489 
1490 bool DocumentLoader::isSubstituteLoadPending(ResourceLoader* loader) const
1491 {
1492     return m_pendingSubstituteResources.contains(loader);
1493 }
1494 
1495 #endif
1496 
1497 void DocumentLoader::cancelPendingSubstituteLoad(ResourceLoader* loader)
1498 {
1499     if (m_pendingSubstituteResources.isEmpty())
1500         return;
1501     m_pendingSubstituteResources.remove(loader);
1502     if (m_pendingSubstituteResources.isEmpty())
1503         m_substituteResourceDeliveryTimer.stop();
1504 }
1505 
1506 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1507 
1508 bool DocumentLoader::scheduleArchiveLoad(ResourceLoader&amp; loader, const ResourceRequest&amp; request)
1509 {
1510     if (auto* resource = archiveResourceForURL(request.url())) {
1511         scheduleSubstituteResourceLoad(loader, *resource);
1512         return true;
1513     }
1514 
1515     if (!m_archive)
1516         return false;
1517 
1518 #if ENABLE(WEB_ARCHIVE)
1519     // The idea of WebArchiveDebugMode is that we should fail instead of trying to fetch from the network.
1520     // Returning true ensures the caller will not try to fetch from the network.
1521     if (m_frame-&gt;settings().webArchiveDebugModeEnabled() &amp;&amp; responseMIMEType() == &quot;application/x-webarchive&quot;)
1522         return true;
1523 #endif
1524 
1525     // If we want to load from the archive only, then we should always return true so that the caller
1526     // does not try to fetch form the network.
1527     return m_archive-&gt;shouldLoadFromArchiveOnly();
1528 }
1529 
1530 #endif
1531 
1532 void DocumentLoader::scheduleSubstituteResourceLoad(ResourceLoader&amp; loader, SubstituteResource&amp; resource)
1533 {
1534 #if ENABLE(SERVICE_WORKER)
1535     ASSERT(!loader.options().serviceWorkerRegistrationIdentifier);
1536 #endif
1537     m_pendingSubstituteResources.set(&amp;loader, &amp;resource);
1538     deliverSubstituteResourcesAfterDelay();
1539 }
1540 
1541 void DocumentLoader::scheduleCannotShowURLError(ResourceLoader&amp; loader)
1542 {
1543     m_pendingSubstituteResources.set(&amp;loader, nullptr);
1544     deliverSubstituteResourcesAfterDelay();
1545 }
1546 
1547 void DocumentLoader::addResponse(const ResourceResponse&amp; response)
1548 {
1549     if (!m_stopRecordingResponses)
1550         m_responses.append(response);
1551 }
1552 
1553 void DocumentLoader::stopRecordingResponses()
1554 {
1555     m_stopRecordingResponses = true;
1556     m_responses.shrinkToFit();
1557 }
1558 
1559 void DocumentLoader::setTitle(const StringWithDirection&amp; title)
1560 {
1561     if (m_pageTitle == title)
1562         return;
1563 
1564     frameLoader()-&gt;willChangeTitle(this);
1565     m_pageTitle = title;
1566     frameLoader()-&gt;didChangeTitle(this);
1567 }
1568 
1569 URL DocumentLoader::urlForHistory() const
1570 {
1571     // Return the URL to be used for history and B/F list.
1572     // Returns nil for WebDataProtocol URLs that aren&#39;t alternates
1573     // for unreachable URLs, because these can&#39;t be stored in history.
1574     if (m_substituteData.isValid() &amp;&amp; !m_substituteData.shouldRevealToSessionHistory())
1575         return unreachableURL();
1576 
1577     return m_originalRequestCopy.url();
1578 }
1579 
1580 bool DocumentLoader::urlForHistoryReflectsFailure() const
1581 {
1582     return m_substituteData.isValid() || m_response.httpStatusCode() &gt;= 400;
1583 }
1584 
1585 URL DocumentLoader::documentURL() const
1586 {
1587     URL url = substituteData().response().url();
1588 #if ENABLE(WEB_ARCHIVE)
1589     if (url.isEmpty() &amp;&amp; m_archive &amp;&amp; m_archive-&gt;shouldUseMainResourceURL())
1590         url = m_archive-&gt;mainResource()-&gt;url();
1591 #endif
1592     if (url.isEmpty())
1593         url = m_request.url();
1594     if (url.isEmpty())
1595         url = m_response.url();
1596     return url;
1597 }
1598 
1599 #if PLATFORM(IOS_FAMILY)
1600 
1601 // FIXME: This method seems to violate the encapsulation of this class.
1602 void DocumentLoader::setResponseMIMEType(const String&amp; responseMimeType)
1603 {
1604     m_response.setMimeType(responseMimeType);
1605 }
1606 
1607 #endif
1608 
1609 void DocumentLoader::setDefersLoading(bool defers)
1610 {
1611     // Multiple frames may be loading the same main resource simultaneously. If deferral state changes,
1612     // each frame&#39;s DocumentLoader will try to send a setDefersLoading() to the same underlying ResourceLoader. Ensure only
1613     // the &quot;owning&quot; DocumentLoader does so, as setDefersLoading() is not resilient to setting the same value repeatedly.
1614     if (mainResourceLoader() &amp;&amp; mainResourceLoader()-&gt;documentLoader() == this)
1615         mainResourceLoader()-&gt;setDefersLoading(defers);
1616 
1617     setAllDefersLoading(m_subresourceLoaders, defers);
1618     setAllDefersLoading(m_plugInStreamLoaders, defers);
1619     if (!defers)
1620         deliverSubstituteResourcesAfterDelay();
1621 }
1622 
1623 void DocumentLoader::setMainResourceDataBufferingPolicy(DataBufferingPolicy dataBufferingPolicy)
1624 {
1625     if (m_mainResource)
1626         m_mainResource-&gt;setDataBufferingPolicy(dataBufferingPolicy);
1627 }
1628 
1629 void DocumentLoader::stopLoadingPlugIns()
1630 {
1631     cancelAll(m_plugInStreamLoaders);
1632 }
1633 
1634 void DocumentLoader::stopLoadingSubresources()
1635 {
1636     cancelAll(m_subresourceLoaders);
1637     ASSERT(m_subresourceLoaders.isEmpty());
1638 }
1639 
1640 void DocumentLoader::addSubresourceLoader(ResourceLoader* loader)
1641 {
1642     // The main resource&#39;s underlying ResourceLoader will ask to be added here.
1643     // It is much simpler to handle special casing of main resource loads if we don&#39;t
1644     // let it be added. In the main resource load case, mainResourceLoader()
1645     // will still be null at this point, but m_gotFirstByte should be false here if and only
1646     // if we are just starting the main resource load.
1647     if (!m_gotFirstByte)
1648         return;
1649     ASSERT(loader-&gt;identifier());
1650     ASSERT(!m_subresourceLoaders.contains(loader-&gt;identifier()));
1651     ASSERT(!mainResourceLoader() || mainResourceLoader() != loader);
1652 
1653     // Application Cache loaders are handled by their ApplicationCacheGroup directly.
1654     if (loader-&gt;options().applicationCacheMode == ApplicationCacheMode::Bypass)
1655         return;
1656 
1657     // A page in the PageCache or about to enter PageCache should not be able to start loads.
1658     ASSERT_WITH_SECURITY_IMPLICATION(!document() || document()-&gt;pageCacheState() == Document::NotInPageCache);
1659 
1660     m_subresourceLoaders.add(loader-&gt;identifier(), loader);
1661 }
1662 
1663 void DocumentLoader::removeSubresourceLoader(LoadCompletionType type, ResourceLoader* loader)
1664 {
1665     ASSERT(loader-&gt;identifier());
1666 
1667     if (!m_subresourceLoaders.remove(loader-&gt;identifier()))
1668         return;
1669     checkLoadComplete();
1670     if (Frame* frame = m_frame)
1671         frame-&gt;loader().subresourceLoadDone(type);
1672 }
1673 
1674 void DocumentLoader::addPlugInStreamLoader(ResourceLoader&amp; loader)
1675 {
1676     ASSERT(loader.identifier());
1677     ASSERT(!m_plugInStreamLoaders.contains(loader.identifier()));
1678 
1679     m_plugInStreamLoaders.add(loader.identifier(), &amp;loader);
1680 }
1681 
1682 void DocumentLoader::removePlugInStreamLoader(ResourceLoader&amp; loader)
1683 {
1684     ASSERT(loader.identifier());
1685     ASSERT(&amp;loader == m_plugInStreamLoaders.get(loader.identifier()));
1686 
1687     m_plugInStreamLoaders.remove(loader.identifier());
1688     checkLoadComplete();
1689 }
1690 
1691 bool DocumentLoader::isMultipartReplacingLoad() const
1692 {
1693     return isLoadingMultipartContent() &amp;&amp; frameLoader()-&gt;isReplacing();
1694 }
1695 
1696 bool DocumentLoader::maybeLoadEmpty()
1697 {
1698     bool shouldLoadEmpty = !m_substituteData.isValid() &amp;&amp; (m_request.url().isEmpty() || SchemeRegistry::shouldLoadURLSchemeAsEmptyDocument(m_request.url().protocol().toStringWithoutCopying()));
1699     if (!shouldLoadEmpty &amp;&amp; !frameLoader()-&gt;client().representationExistsForURLScheme(m_request.url().protocol().toStringWithoutCopying()))
1700         return false;
1701 
1702     if (m_request.url().isEmpty() &amp;&amp; !frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument()) {
1703         m_request.setURL(WTF::blankURL());
1704         if (isLoadingMainResource())
1705             frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
1706     }
1707 
1708     String mimeType = shouldLoadEmpty ? &quot;text/html&quot; : frameLoader()-&gt;client().generatedMIMETypeForURLScheme(m_request.url().protocol().toStringWithoutCopying());
1709     m_response = ResourceResponse(m_request.url(), mimeType, 0, String());
1710     finishedLoading();
1711     return true;
1712 }
1713 
1714 void DocumentLoader::startLoadingMainResource()
1715 {
1716     m_mainDocumentError = ResourceError();
1717     timing().markStartTimeAndFetchStart();
1718     ASSERT(!m_mainResource);
1719     ASSERT(!m_loadingMainResource);
1720     m_loadingMainResource = true;
1721 
1722     Ref&lt;DocumentLoader&gt; protectedThis(*this);
1723 
1724     if (maybeLoadEmpty()) {
1725         RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Returning empty document (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);
1726         return;
1727     }
1728 
1729 #if ENABLE(CONTENT_FILTERING)
1730     m_contentFilter = !m_substituteData.isValid() ? ContentFilter::create(*this) : nullptr;
1731 #endif
1732 
1733     // Make sure we re-apply the user agent to the Document&#39;s ResourceRequest upon reload in case the embedding
1734     // application has changed it.
1735     m_request.clearHTTPUserAgent();
1736     frameLoader()-&gt;addExtraFieldsToMainResourceRequest(m_request);
1737 
1738     ASSERT(timing().startTime());
1739     ASSERT(timing().fetchStart());
1740 
1741     willSendRequest(ResourceRequest(m_request), ResourceResponse(), [this, protectedThis = WTFMove(protectedThis)] (ResourceRequest&amp;&amp; request) mutable {
1742         m_request = request;
1743 
1744         // willSendRequest() may lead to our Frame being detached or cancelling the load via nulling the ResourceRequest.
1745         if (!m_frame || m_request.isNull()) {
1746             RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Load canceled after willSendRequest (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);
1747             return;
1748         }
1749 
1750         request.setRequester(ResourceRequest::Requester::Main);
1751         // If this is a reload the cache layer might have made the previous request conditional. DocumentLoader can&#39;t handle 304 responses itself.
1752         request.makeUnconditional();
1753 
1754         RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Starting load (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1755 
1756 #if ENABLE(SERVICE_WORKER)
1757         // FIXME: Implement local URL interception by getting the service worker of the parent.
1758         auto url = request.url();
1759         matchRegistration(url, [request = WTFMove(request), protectedThis = WTFMove(protectedThis), this] (auto&amp;&amp; registrationData) mutable {
1760             if (!m_mainDocumentError.isNull() || !m_frame) {
1761                 RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Load canceled because of main document error (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);
1762                 return;
1763             }
1764 
1765             m_serviceWorkerRegistrationData = WTFMove(registrationData);
1766 
1767             // Prefer existing substitute data (from WKWebView.loadData etc) over service worker fetch.
1768             if (this-&gt;tryLoadingSubstituteData()) {
1769                 RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Load canceled because of substitute data (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);
1770                 return;
1771             }
1772             // Try app cache only if there is no service worker.
1773             if (!m_serviceWorkerRegistrationData &amp;&amp; this-&gt;tryLoadingRequestFromApplicationCache()) {
1774                 RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Loaded from Application Cache (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1775                 return;
1776             }
1777             this-&gt;loadMainResource(WTFMove(request));
1778         });
1779 #else
1780         if (tryLoadingRequestFromApplicationCache()) {
1781             RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Loaded from Application Cache (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1782             return;
1783         }
1784         loadMainResource(WTFMove(request));
1785 #endif
1786     });
1787 }
1788 
1789 void DocumentLoader::registerTemporaryServiceWorkerClient(const URL&amp; url)
1790 {
1791 #if ENABLE(SERVICE_WORKER)
1792     ASSERT(!m_temporaryServiceWorkerClient);
1793 
1794     if (!m_serviceWorkerRegistrationData)
1795         return;
1796 
1797     m_temporaryServiceWorkerClient = TemporaryServiceWorkerClient {
1798         DocumentIdentifier::generate(),
1799         *ServiceWorkerProvider::singleton().existingServiceWorkerConnectionForSession(m_frame-&gt;page()-&gt;sessionID())
1800     };
1801 
1802     // FIXME: Compute ServiceWorkerClientFrameType appropriately.
1803     ServiceWorkerClientData data { { m_temporaryServiceWorkerClient-&gt;serviceWorkerConnection-&gt;serverConnectionIdentifier(), m_temporaryServiceWorkerClient-&gt;documentIdentifier }, ServiceWorkerClientType::Window, ServiceWorkerClientFrameType::None, url };
1804 
1805     RefPtr&lt;SecurityOrigin&gt; topOrigin;
1806     if (m_frame-&gt;isMainFrame())
1807         topOrigin = SecurityOrigin::create(url);
1808     else
1809         topOrigin = &amp;m_frame-&gt;mainFrame().document()-&gt;topOrigin();
1810     m_temporaryServiceWorkerClient-&gt;serviceWorkerConnection-&gt;registerServiceWorkerClient(*topOrigin, WTFMove(data), m_serviceWorkerRegistrationData-&gt;identifier, m_frame-&gt;loader().userAgent(url));
1811 #else
1812     UNUSED_PARAM(url);
1813 #endif
1814 }
1815 
1816 void DocumentLoader::unregisterTemporaryServiceWorkerClient()
1817 {
1818 #if ENABLE(SERVICE_WORKER)
1819     if (!m_temporaryServiceWorkerClient)
1820         return;
1821 
1822     m_temporaryServiceWorkerClient-&gt;serviceWorkerConnection-&gt;unregisterServiceWorkerClient(m_temporaryServiceWorkerClient-&gt;documentIdentifier);
1823     m_temporaryServiceWorkerClient = WTF::nullopt;
1824 #endif
1825 }
1826 
1827 void DocumentLoader::loadMainResource(ResourceRequest&amp;&amp; request)
1828 {
1829     static NeverDestroyed&lt;ResourceLoaderOptions&gt; mainResourceLoadOptions(
1830         SendCallbackPolicy::SendCallbacks,
1831         ContentSniffingPolicy::SniffContent,
1832         DataBufferingPolicy::BufferData,
1833         StoredCredentialsPolicy::Use,
1834         ClientCredentialPolicy::MayAskClientForCredentials,
1835         FetchOptions::Credentials::Include,
1836         SecurityCheckPolicy::SkipSecurityCheck,
1837         FetchOptions::Mode::Navigate,
1838         CertificateInfoPolicy::IncludeCertificateInfo,
1839         ContentSecurityPolicyImposition::SkipPolicyCheck,
1840         DefersLoadingPolicy::AllowDefersLoading,
1841         CachingPolicy::AllowCaching);
1842     CachedResourceRequest mainResourceRequest(WTFMove(request), mainResourceLoadOptions);
1843     if (!m_frame-&gt;isMainFrame() &amp;&amp; m_frame-&gt;document()) {
1844         // If we are loading the main resource of a subframe, use the cache partition of the main document.
1845         mainResourceRequest.setDomainForCachePartition(*m_frame-&gt;document());
1846     } else {
1847         auto origin = SecurityOrigin::create(mainResourceRequest.resourceRequest().url());
1848         origin-&gt;setStorageBlockingPolicy(frameLoader()-&gt;frame().settings().storageBlockingPolicy());
1849         mainResourceRequest.setDomainForCachePartition(origin-&gt;domainForCachePartition());
1850     }
1851 
1852 #if ENABLE(SERVICE_WORKER)
1853     mainResourceRequest.setNavigationServiceWorkerRegistrationData(m_serviceWorkerRegistrationData);
1854     if (mainResourceRequest.options().serviceWorkersMode != ServiceWorkersMode::None) {
1855         // As per step 12 of https://w3c.github.io/ServiceWorker/#on-fetch-request-algorithm, the active service worker should be controlling the document.
1856         // Since we did not yet create the document, we register a temporary service worker client instead.
1857         registerTemporaryServiceWorkerClient(mainResourceRequest.resourceRequest().url());
1858     }
1859 #endif
1860 
1861     m_mainResource = m_cachedResourceLoader-&gt;requestMainResource(WTFMove(mainResourceRequest)).value_or(nullptr);
1862 
1863     if (!m_mainResource) {
1864         // The frame may have gone away if this load was cancelled synchronously and this was the last pending load.
1865         // This is because we may have fired the load event in a parent frame.
1866         if (!m_frame) {
1867             RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, frame has gone away (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1868             return;
1869         }
1870 
1871         if (!m_request.url().isValid()) {
1872             RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, URL is invalid (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1873             cancelMainResourceLoad(frameLoader()-&gt;client().cannotShowURLError(m_request));
1874             return;
1875         }
1876 
1877         RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, returning empty document (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1878 
1879         setRequest(ResourceRequest());
1880         // If the load was aborted by clearing m_request, it&#39;s possible the ApplicationCacheHost
1881         // is now in a state where starting an empty load will be inconsistent. Replace it with
1882         // a new ApplicationCacheHost.
1883         m_applicationCacheHost = std::make_unique&lt;ApplicationCacheHost&gt;(*this);
1884         maybeLoadEmpty();
1885         return;
1886     }
1887 
1888     ASSERT(m_frame);
1889 
1890 #if ENABLE(CONTENT_EXTENSIONS)
1891     if (m_mainResource-&gt;errorOccurred() &amp;&amp; m_frame-&gt;page() &amp;&amp; m_mainResource-&gt;resourceError().domain() == ContentExtensions::WebKitContentBlockerDomain) {
1892         RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Blocked by content blocker error (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1893         cancelMainResourceLoad(frameLoader()-&gt;blockedByContentBlockerError(m_request));
1894         return;
1895     }
1896 #endif
1897 
1898     if (!mainResourceLoader()) {
1899         m_identifierForLoadWithoutResourceLoader = m_frame-&gt;page()-&gt;progress().createUniqueIdentifier();
1900         frameLoader()-&gt;notifier().assignIdentifierToInitialRequest(m_identifierForLoadWithoutResourceLoader, this, mainResourceRequest.resourceRequest());
1901         frameLoader()-&gt;notifier().dispatchWillSendRequest(this, m_identifierForLoadWithoutResourceLoader, mainResourceRequest.resourceRequest(), ResourceResponse());
1902     }
1903 
1904     becomeMainResourceClient();
1905 
1906     // A bunch of headers are set when the underlying ResourceLoader is created, and m_request needs to include those.
1907     ResourceRequest updatedRequest = mainResourceLoader() ? mainResourceLoader()-&gt;originalRequest() : mainResourceRequest.resourceRequest();
1908     // If there was a fragment identifier on m_request, the cache will have stripped it. m_request should include
1909     // the fragment identifier, so add that back in.
1910     if (equalIgnoringFragmentIdentifier(m_request.url(), updatedRequest.url()))
1911         updatedRequest.setURL(m_request.url());
1912     setRequest(updatedRequest);
1913 }
1914 
1915 void DocumentLoader::cancelPolicyCheckIfNeeded()
1916 {
1917     if (m_waitingForContentPolicy || m_waitingForNavigationPolicy) {
1918         RELEASE_ASSERT(frameLoader());
1919         frameLoader()-&gt;policyChecker().stopCheck();
1920         m_waitingForContentPolicy = false;
1921         m_waitingForNavigationPolicy = false;
1922     }
1923 }
1924 
1925 void DocumentLoader::cancelMainResourceLoad(const ResourceError&amp; resourceError)
1926 {
1927     Ref&lt;DocumentLoader&gt; protectedThis(*this);
1928     ResourceError error = resourceError.isNull() ? frameLoader()-&gt;cancelledError(m_request) : resourceError;
1929 
1930     RELEASE_LOG_IF_ALLOWED(&quot;cancelMainResourceLoad: (frame = %p, main = %d, type = %d, code = %d)&quot;, m_frame, m_frame-&gt;isMainFrame(), static_cast&lt;int&gt;(error.type()), error.errorCode());
1931 
1932     m_dataLoadTimer.stop();
1933 
1934     cancelPolicyCheckIfNeeded();
1935 
1936     if (mainResourceLoader())
1937         mainResourceLoader()-&gt;cancel(error);
1938 
1939     clearMainResource();
1940 
1941     mainReceivedError(error);
1942 }
1943 
1944 void DocumentLoader::willContinueMainResourceLoadAfterRedirect(const ResourceRequest&amp; newRequest)
1945 {
1946     setRequest(newRequest);
1947 }
1948 
1949 void DocumentLoader::clearMainResource()
1950 {
1951     ASSERT(isMainThread());
1952     if (m_mainResource &amp;&amp; m_mainResource-&gt;hasClient(*this))
1953         m_mainResource-&gt;removeClient(*this);
1954 #if ENABLE(CONTENT_FILTERING)
1955     if (m_contentFilter)
1956         m_contentFilter-&gt;stopFilteringMainResource();
1957 #endif
1958 
1959     m_mainResource = nullptr;
1960 
1961     unregisterTemporaryServiceWorkerClient();
1962 }
1963 
1964 void DocumentLoader::subresourceLoaderFinishedLoadingOnePart(ResourceLoader* loader)
1965 {
1966     unsigned long identifier = loader-&gt;identifier();
1967     ASSERT(identifier);
1968 
1969     if (!m_multipartSubresourceLoaders.add(identifier, loader).isNewEntry) {
1970         ASSERT(m_multipartSubresourceLoaders.get(identifier) == loader);
1971         ASSERT(!m_subresourceLoaders.contains(identifier));
1972     } else {
1973         ASSERT(m_subresourceLoaders.contains(identifier));
1974         m_subresourceLoaders.remove(identifier);
1975     }
1976 
1977     checkLoadComplete();
1978     if (Frame* frame = m_frame)
1979         frame-&gt;loader().checkLoadComplete();
1980 }
1981 
1982 void DocumentLoader::maybeFinishLoadingMultipartContent()
1983 {
1984     if (!isMultipartReplacingLoad())
1985         return;
1986 
1987     frameLoader()-&gt;setupForReplace();
1988     m_committed = false;
1989     RefPtr&lt;SharedBuffer&gt; resourceData = mainResourceData();
1990     commitLoad(resourceData-&gt;data(), resourceData-&gt;size());
1991 }
1992 
1993 void DocumentLoader::startIconLoading()
1994 {
1995     static uint64_t nextIconCallbackID = 1;
1996 
1997     auto* document = this-&gt;document();
1998     if (!document)
1999         return;
2000 
2001     if (!m_frame-&gt;isMainFrame())
2002         return;
2003 
2004     if (document-&gt;url().isEmpty() || document-&gt;url().protocolIsAbout())
2005         return;
2006 
2007     m_linkIcons = LinkIconCollector { *document }.iconsOfTypes({ LinkIconType::Favicon, LinkIconType::TouchIcon, LinkIconType::TouchPrecomposedIcon });
2008 
2009     auto findResult = m_linkIcons.findMatching([](auto&amp; icon) { return icon.type == LinkIconType::Favicon; });
2010     if (findResult == notFound)
2011         m_linkIcons.append({ document-&gt;completeURL(&quot;/favicon.ico&quot;_s), LinkIconType::Favicon, String(), WTF::nullopt, { } });
2012 
2013     if (!m_linkIcons.size())
2014         return;
2015 
2016     Vector&lt;std::pair&lt;WebCore::LinkIcon&amp;, uint64_t&gt;&gt; iconDecisions;
2017     iconDecisions.reserveInitialCapacity(m_linkIcons.size());
2018     for (auto&amp; icon : m_linkIcons) {
2019         auto result = m_iconsPendingLoadDecision.add(nextIconCallbackID++, icon);
2020         iconDecisions.uncheckedAppend({ icon, result.iterator-&gt;key });
2021     }
2022 
2023     m_frame-&gt;loader().client().getLoadDecisionForIcons(iconDecisions);
2024 }
2025 
2026 void DocumentLoader::didGetLoadDecisionForIcon(bool decision, uint64_t loadIdentifier, uint64_t newCallbackID)
2027 {
2028     auto icon = m_iconsPendingLoadDecision.take(loadIdentifier);
2029 
2030     // If the decision was not to load or this DocumentLoader is already detached, there is no load to perform.
2031     if (!decision || !m_frame)
2032         return;
2033 
2034     // If the LinkIcon we just took is empty, then the DocumentLoader had all of its loaders stopped
2035     // while this icon load decision was pending.
2036     // In this case we need to notify the client that the icon finished loading with empty data.
2037     if (icon.url.isEmpty()) {
2038         notifyFinishedLoadingIcon(newCallbackID, nullptr);
2039         return;
2040     }
2041 
2042     auto iconLoader = std::make_unique&lt;IconLoader&gt;(*this, icon.url);
2043     auto* rawIconLoader = iconLoader.get();
2044     m_iconLoaders.set(WTFMove(iconLoader), newCallbackID);
2045 
2046     rawIconLoader-&gt;startLoading();
2047 }
2048 
2049 void DocumentLoader::finishedLoadingIcon(IconLoader&amp; loader, SharedBuffer* buffer)
2050 {
2051     // If the DocumentLoader has detached from its frame, all icon loads should have already been cancelled.
2052     ASSERT(m_frame);
2053 
2054     auto callbackIdentifier = m_iconLoaders.take(&amp;loader);
2055     notifyFinishedLoadingIcon(callbackIdentifier, buffer);
2056 }
2057 
2058 void DocumentLoader::notifyFinishedLoadingIcon(uint64_t callbackIdentifier, SharedBuffer* buffer)
2059 {
2060     RELEASE_ASSERT(callbackIdentifier);
2061     RELEASE_ASSERT(m_frame);
2062     m_frame-&gt;loader().client().finishedLoadingIcon(callbackIdentifier, buffer);
2063 }
2064 
2065 void DocumentLoader::dispatchOnloadEvents()
2066 {
2067     m_wasOnloadDispatched = true;
2068     m_applicationCacheHost-&gt;stopDeferringEvents();
2069 }
2070 
2071 void DocumentLoader::setTriggeringAction(NavigationAction&amp;&amp; action)
2072 {
2073     m_triggeringAction = WTFMove(action);
2074     m_triggeringAction.setShouldOpenExternalURLsPolicy(m_frame ? shouldOpenExternalURLsPolicyToPropagate() : m_shouldOpenExternalURLsPolicy);
2075 }
2076 
2077 ShouldOpenExternalURLsPolicy DocumentLoader::shouldOpenExternalURLsPolicyToPropagate() const
2078 {
2079     if (!m_frame || !m_frame-&gt;isMainFrame())
2080         return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
2081 
2082     return m_shouldOpenExternalURLsPolicy;
2083 }
2084 
2085 void DocumentLoader::becomeMainResourceClient()
2086 {
2087 #if ENABLE(CONTENT_FILTERING)
2088     if (m_contentFilter)
2089         m_contentFilter-&gt;startFilteringMainResource(*m_mainResource);
2090 #endif
2091     m_mainResource-&gt;addClient(*this);
2092 }
2093 
2094 #if ENABLE(CONTENT_EXTENSIONS)
2095 void DocumentLoader::addPendingContentExtensionSheet(const String&amp; identifier, StyleSheetContents&amp; sheet)
2096 {
2097     ASSERT(!m_gotFirstByte);
2098     m_pendingNamedContentExtensionStyleSheets.set(identifier, &amp;sheet);
2099 }
2100 
2101 void DocumentLoader::addPendingContentExtensionDisplayNoneSelector(const String&amp; identifier, const String&amp; selector, uint32_t selectorID)
2102 {
2103     ASSERT(!m_gotFirstByte);
2104     auto addResult = m_pendingContentExtensionDisplayNoneSelectors.add(identifier, Vector&lt;std::pair&lt;String, uint32_t&gt;&gt;());
2105     addResult.iterator-&gt;value.append(std::make_pair(selector, selectorID));
2106 }
2107 #endif
2108 
2109 bool DocumentLoader::isAlwaysOnLoggingAllowed() const
2110 {
2111     return !m_frame || m_frame-&gt;isAlwaysOnLoggingAllowed();
2112 }
2113 
2114 #if USE(QUICK_LOOK)
2115 
2116 void DocumentLoader::setPreviewConverter(std::unique_ptr&lt;PreviewConverter&gt;&amp;&amp; previewConverter)
2117 {
2118     m_previewConverter = WTFMove(previewConverter);
2119 }
2120 
2121 PreviewConverter* DocumentLoader::previewConverter() const
2122 {
2123     return m_previewConverter.get();
2124 }
2125 
2126 #endif
2127 
2128 void DocumentLoader::addConsoleMessage(MessageSource messageSource, MessageLevel messageLevel, const String&amp; message, unsigned long requestIdentifier)
2129 {
2130     static_cast&lt;ScriptExecutionContext*&gt;(m_frame-&gt;document())-&gt;addConsoleMessage(messageSource, messageLevel, message, requestIdentifier);
2131 }
2132 
2133 void DocumentLoader::sendCSPViolationReport(URL&amp;&amp; reportURL, Ref&lt;FormData&gt;&amp;&amp; report)
2134 {
2135     PingLoader::sendViolationReport(*m_frame, WTFMove(reportURL), WTFMove(report), ViolationReportType::ContentSecurityPolicy);
2136 }
2137 
2138 void DocumentLoader::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
2139 {
2140     m_frame-&gt;document()-&gt;enqueueSecurityPolicyViolationEvent(WTFMove(eventInit));
2141 }
2142 
2143 } // namespace WebCore
    </pre>
  </body>
</html>