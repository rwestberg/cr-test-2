<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorOverlay.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorNodeFinder.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorOverlay.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorOverlay.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2011 Google Inc. All rights reserved.

   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;InspectorOverlay.h&quot;
  31 
<span class="line-modified">  32 #include &quot;CacheStorageProvider.h&quot;</span>
<span class="line-modified">  33 #include &quot;DocumentLoader.h&quot;</span>
<span class="line-modified">  34 #include &quot;EditorClient.h&quot;</span>

  35 #include &quot;Element.h&quot;
<span class="line-modified">  36 #include &quot;EmptyClients.h&quot;</span>




  37 #include &quot;Frame.h&quot;
  38 #include &quot;FrameView.h&quot;
  39 #include &quot;GraphicsContext.h&quot;
  40 #include &quot;InspectorClient.h&quot;
<span class="line-modified">  41 #include &quot;InspectorOverlayPage.h&quot;</span>
<span class="line-modified">  42 #include &quot;LibWebRTCProvider.h&quot;</span>

  43 #include &quot;Node.h&quot;

  44 #include &quot;Page.h&quot;
<span class="line-removed">  45 #include &quot;PageConfiguration.h&quot;</span>
<span class="line-removed">  46 #include &quot;PolygonShape.h&quot;</span>
  47 #include &quot;PseudoElement.h&quot;
<span class="line-modified">  48 #include &quot;RTCController.h&quot;</span>
<span class="line-removed">  49 #include &quot;RectangleShape.h&quot;</span>
  50 #include &quot;RenderBoxModelObject.h&quot;
<span class="line-removed">  51 #include &quot;RenderElement.h&quot;</span>
  52 #include &quot;RenderInline.h&quot;
<span class="line-modified">  53 #include &quot;RenderView.h&quot;</span>
<span class="line-removed">  54 #include &quot;ScriptController.h&quot;</span>
<span class="line-removed">  55 #include &quot;ScriptSourceCode.h&quot;</span>
  56 #include &quot;Settings.h&quot;
<span class="line-modified">  57 #include &quot;SocketProvider.h&quot;</span>
<span class="line-modified">  58 #include &quot;StyledElement.h&quot;</span>
<span class="line-removed">  59 #include &lt;JavaScriptCore/InspectorProtocolObjects.h&gt;</span>
<span class="line-removed">  60 #include &lt;wtf/JSONValues.h&gt;</span>
<span class="line-removed">  61 </span>
<span class="line-removed">  62 #if PLATFORM(MAC)</span>
<span class="line-removed">  63 #include &quot;LocalDefaultSystemAppearance.h&quot;</span>
<span class="line-removed">  64 #endif</span>
  65 
  66 namespace WebCore {
  67 
  68 using namespace Inspector;
  69 



























  70 static void contentsQuadToCoordinateSystem(const FrameView* mainView, const FrameView* view, FloatQuad&amp; quad, InspectorOverlay::CoordinateSystem coordinateSystem)
  71 {
<span class="line-modified">  72     quad.setP1(view-&gt;contentsToRootView(roundedIntPoint(quad.p1())));</span>
<span class="line-modified">  73     quad.setP2(view-&gt;contentsToRootView(roundedIntPoint(quad.p2())));</span>
<span class="line-modified">  74     quad.setP3(view-&gt;contentsToRootView(roundedIntPoint(quad.p3())));</span>
<span class="line-modified">  75     quad.setP4(view-&gt;contentsToRootView(roundedIntPoint(quad.p4())));</span>
  76 
  77     if (coordinateSystem == InspectorOverlay::CoordinateSystem::View)
  78         quad += toIntSize(mainView-&gt;scrollPosition());
  79 }
  80 
<span class="line-modified">  81 static void contentsQuadToPage(const FrameView* mainView, const FrameView* view, FloatQuad&amp; quad)</span>
  82 {
<span class="line-modified">  83     contentsQuadToCoordinateSystem(mainView, view, quad, InspectorOverlay::CoordinateSystem::View);</span>










  84 }
  85 
  86 static void buildRendererHighlight(RenderObject* renderer, const HighlightConfig&amp; highlightConfig, Highlight&amp; highlight, InspectorOverlay::CoordinateSystem coordinateSystem)
  87 {
  88     Frame* containingFrame = renderer-&gt;document().frame();
  89     if (!containingFrame)
  90         return;
  91 
  92     highlight.setDataFromConfig(highlightConfig);
  93     FrameView* containingView = containingFrame-&gt;view();
  94     FrameView* mainView = containingFrame-&gt;page()-&gt;mainFrame().view();
  95 
  96     // RenderSVGRoot should be highlighted through the isBox() code path, all other SVG elements should just dump their absoluteQuads().
  97     bool isSVGRenderer = renderer-&gt;node() &amp;&amp; renderer-&gt;node()-&gt;isSVGElement() &amp;&amp; !renderer-&gt;isSVGRoot();
  98 
  99     if (isSVGRenderer) {
 100         highlight.type = HighlightType::Rects;
 101         renderer-&gt;absoluteQuads(highlight.quads);
 102         for (auto&amp; quad : highlight.quads)
 103             contentsQuadToCoordinateSystem(mainView, containingView, quad, coordinateSystem);
</pre>
<hr />
<pre>
 149         highlight.quads.append(absContentQuad);
 150     }
 151 }
 152 
 153 static void buildNodeHighlight(Node&amp; node, const HighlightConfig&amp; highlightConfig, Highlight&amp; highlight, InspectorOverlay::CoordinateSystem coordinateSystem)
 154 {
 155     RenderObject* renderer = node.renderer();
 156     if (!renderer)
 157         return;
 158 
 159     buildRendererHighlight(renderer, highlightConfig, highlight, coordinateSystem);
 160 }
 161 
 162 static void buildQuadHighlight(const FloatQuad&amp; quad, const HighlightConfig&amp; highlightConfig, Highlight&amp; highlight)
 163 {
 164     highlight.setDataFromConfig(highlightConfig);
 165     highlight.type = HighlightType::Rects;
 166     highlight.quads.append(quad);
 167 }
 168 
































































































































































 169 InspectorOverlay::InspectorOverlay(Page&amp; page, InspectorClient* client)
 170     : m_page(page)
 171     , m_client(client)
 172     , m_paintRectUpdateTimer(*this, &amp;InspectorOverlay::updatePaintRectsTimerFired)
 173 {
 174 }
 175 
 176 InspectorOverlay::~InspectorOverlay() = default;
 177 
 178 void InspectorOverlay::paint(GraphicsContext&amp; context)
 179 {
 180     if (!shouldShowOverlay())
 181         return;
 182 
<span class="line-modified"> 183     Page* overlayPage = this-&gt;overlayPage();</span>
<span class="line-modified"> 184     if (!overlayPage)</span>
<span class="line-modified"> 185         return;</span>
 186 
 187     GraphicsContextStateSaver stateSaver(context);
<span class="line-removed"> 188     FrameView* view = overlayPage-&gt;mainFrame().view();</span>
 189 
<span class="line-modified"> 190 #if PLATFORM(MAC)</span>
<span class="line-modified"> 191     LocalDefaultSystemAppearance localAppearance(view-&gt;useDarkAppearance());</span>
<span class="line-modified"> 192 #endif</span>





























 193 
<span class="line-modified"> 194     view-&gt;updateLayoutAndStyleIfNeededRecursive();</span>
<span class="line-modified"> 195     view-&gt;paint(context, IntRect(0, 0, view-&gt;width(), view-&gt;height()));</span>
 196 }
 197 
 198 void InspectorOverlay::getHighlight(Highlight&amp; highlight, InspectorOverlay::CoordinateSystem coordinateSystem) const
 199 {
 200     if (!m_highlightNode &amp;&amp; !m_highlightQuad &amp;&amp; !m_highlightNodeList)
 201         return;
 202 
 203     highlight.type = HighlightType::Rects;
 204     if (m_highlightNode)
 205         buildNodeHighlight(*m_highlightNode, m_nodeHighlightConfig, highlight, coordinateSystem);
 206     else if (m_highlightNodeList) {
 207         highlight.setDataFromConfig(m_nodeHighlightConfig);
 208         for (unsigned i = 0; i &lt; m_highlightNodeList-&gt;length(); ++i) {
 209             Highlight nodeHighlight;
 210             buildNodeHighlight(*(m_highlightNodeList-&gt;item(i)), m_nodeHighlightConfig, nodeHighlight, coordinateSystem);
 211             if (nodeHighlight.type == HighlightType::Node)
 212                 highlight.quads.appendVector(nodeHighlight.quads);
 213         }
 214         highlight.type = HighlightType::NodeList;
 215     } else
 216         buildQuadHighlight(*m_highlightQuad, m_quadHighlightConfig, highlight);
 217 }
 218 
<span class="line-removed"> 219 void InspectorOverlay::setPausedInDebuggerMessage(const String* message)</span>
<span class="line-removed"> 220 {</span>
<span class="line-removed"> 221     m_pausedInDebuggerMessage = message ? *message : String();</span>
<span class="line-removed"> 222     update();</span>
<span class="line-removed"> 223 }</span>
<span class="line-removed"> 224 </span>
 225 void InspectorOverlay::hideHighlight()
 226 {
 227     m_highlightNode = nullptr;
 228     m_highlightNodeList = nullptr;
 229     m_highlightQuad = nullptr;
 230     update();
 231 }
 232 
 233 void InspectorOverlay::highlightNodeList(RefPtr&lt;NodeList&gt;&amp;&amp; nodes, const HighlightConfig&amp; highlightConfig)
 234 {
 235     m_nodeHighlightConfig = highlightConfig;
 236     m_highlightNodeList = WTFMove(nodes);
 237     m_highlightNode = nullptr;
 238     update();
 239 }
 240 
 241 void InspectorOverlay::highlightNode(Node* node, const HighlightConfig&amp; highlightConfig)
 242 {
 243     m_nodeHighlightConfig = highlightConfig;
 244     m_highlightNode = node;
</pre>
<hr />
<pre>
 251     if (highlightConfig.usePageCoordinates)
 252         *quad -= toIntSize(m_page.mainFrame().view()-&gt;scrollPosition());
 253 
 254     m_quadHighlightConfig = highlightConfig;
 255     m_highlightQuad = WTFMove(quad);
 256     update();
 257 }
 258 
 259 Node* InspectorOverlay::highlightedNode() const
 260 {
 261     return m_highlightNode.get();
 262 }
 263 
 264 void InspectorOverlay::didSetSearchingForNode(bool enabled)
 265 {
 266     m_client-&gt;didSetSearchingForNode(enabled);
 267 }
 268 
 269 void InspectorOverlay::setIndicating(bool indicating)
 270 {
<span class="line-modified"> 271     m_indicating = indicating;</span>

 272 
<span class="line-modified"> 273     if (m_indicating)</span>
<span class="line-removed"> 274         evaluateInOverlay(&quot;showPageIndication&quot;_s);</span>
<span class="line-removed"> 275     else</span>
<span class="line-removed"> 276         evaluateInOverlay(&quot;hidePageIndication&quot;_s);</span>
 277 
 278     update();
 279 }
 280 
 281 bool InspectorOverlay::shouldShowOverlay() const
 282 {
<span class="line-modified"> 283     return m_highlightNode || m_highlightNodeList || m_highlightQuad || m_indicating || m_showingPaintRects || m_showRulers || !m_pausedInDebuggerMessage.isNull();</span>


 284 }
 285 
 286 void InspectorOverlay::update()
 287 {
 288     if (!shouldShowOverlay()) {
 289         m_client-&gt;hideHighlight();
 290         return;
 291     }
 292 
 293     FrameView* view = m_page.mainFrame().view();
 294     if (!view)
 295         return;
 296 
<span class="line-modified"> 297     Page* overlayPage = this-&gt;overlayPage();</span>
<span class="line-removed"> 298     if (overlayPage) {</span>
<span class="line-removed"> 299         FrameView* overlayView = overlayPage-&gt;mainFrame().view();</span>
<span class="line-removed"> 300         IntSize frameViewFullSize = view-&gt;sizeForVisibleContent(ScrollableArea::IncludeScrollbars);</span>
<span class="line-removed"> 301         overlayView-&gt;resize(frameViewFullSize);</span>
<span class="line-removed"> 302     }</span>
<span class="line-removed"> 303 </span>
<span class="line-removed"> 304     // Clear canvas and paint things.</span>
<span class="line-removed"> 305     IntSize viewportSize = view-&gt;sizeForVisibleContent();</span>
<span class="line-removed"> 306     IntPoint scrollOffset = view-&gt;scrollPosition();</span>
<span class="line-removed"> 307     reset(viewportSize, scrollOffset);</span>
<span class="line-removed"> 308 </span>
<span class="line-removed"> 309     // Include scrollbars to avoid masking them by the gutter.</span>
<span class="line-removed"> 310     drawNodeHighlight();</span>
<span class="line-removed"> 311     drawQuadHighlight();</span>
<span class="line-removed"> 312     drawPausedInDebuggerMessage();</span>
<span class="line-removed"> 313     drawPaintRects();</span>
<span class="line-removed"> 314 </span>
<span class="line-removed"> 315     if (m_showRulers)</span>
<span class="line-removed"> 316         drawRulers();</span>
<span class="line-removed"> 317 </span>
<span class="line-removed"> 318     // Position DOM elements.</span>
<span class="line-removed"> 319     if (overlayPage) {</span>
<span class="line-removed"> 320         overlayPage-&gt;mainFrame().document()-&gt;resolveStyle(Document::ResolveStyleType::Rebuild);</span>
<span class="line-removed"> 321         FrameView* overlayView = overlayPage-&gt;mainFrame().view();</span>
<span class="line-removed"> 322         if (overlayView-&gt;needsLayout())</span>
<span class="line-removed"> 323             overlayView-&gt;layoutContext().layout();</span>
<span class="line-removed"> 324     }</span>
<span class="line-removed"> 325 </span>
<span class="line-removed"> 326     forcePaint();</span>
<span class="line-removed"> 327 }</span>
<span class="line-removed"> 328 </span>
<span class="line-removed"> 329 static Ref&lt;Inspector::Protocol::OverlayTypes::Point&gt; buildObjectForPoint(const FloatPoint&amp; point)</span>
<span class="line-removed"> 330 {</span>
<span class="line-removed"> 331     return Inspector::Protocol::OverlayTypes::Point::create()</span>
<span class="line-removed"> 332         .setX(point.x())</span>
<span class="line-removed"> 333         .setY(point.y())</span>
<span class="line-removed"> 334         .release();</span>
<span class="line-removed"> 335 }</span>
<span class="line-removed"> 336 </span>
<span class="line-removed"> 337 static Ref&lt;Inspector::Protocol::OverlayTypes::Rect&gt; buildObjectForRect(const FloatRect&amp; rect)</span>
<span class="line-removed"> 338 {</span>
<span class="line-removed"> 339     return Inspector::Protocol::OverlayTypes::Rect::create()</span>
<span class="line-removed"> 340         .setX(rect.x())</span>
<span class="line-removed"> 341         .setY(rect.y())</span>
<span class="line-removed"> 342         .setWidth(rect.width())</span>
<span class="line-removed"> 343         .setHeight(rect.height())</span>
<span class="line-removed"> 344         .release();</span>
<span class="line-removed"> 345 }</span>
<span class="line-removed"> 346 </span>
<span class="line-removed"> 347 static Ref&lt;Inspector::Protocol::OverlayTypes::Quad&gt; buildArrayForQuad(const FloatQuad&amp; quad)</span>
<span class="line-removed"> 348 {</span>
<span class="line-removed"> 349     auto array = Inspector::Protocol::OverlayTypes::Quad::create();</span>
<span class="line-removed"> 350     array-&gt;addItem(buildObjectForPoint(quad.p1()));</span>
<span class="line-removed"> 351     array-&gt;addItem(buildObjectForPoint(quad.p2()));</span>
<span class="line-removed"> 352     array-&gt;addItem(buildObjectForPoint(quad.p3()));</span>
<span class="line-removed"> 353     array-&gt;addItem(buildObjectForPoint(quad.p4()));</span>
<span class="line-removed"> 354     return array;</span>
<span class="line-removed"> 355 }</span>
<span class="line-removed"> 356 </span>
<span class="line-removed"> 357 static Ref&lt;Inspector::Protocol::OverlayTypes::FragmentHighlightData&gt; buildObjectForHighlight(const Highlight&amp; highlight)</span>
<span class="line-removed"> 358 {</span>
<span class="line-removed"> 359     auto arrayOfQuads = JSON::ArrayOf&lt;Inspector::Protocol::OverlayTypes::Quad&gt;::create();</span>
<span class="line-removed"> 360     for (auto&amp; quad : highlight.quads)</span>
<span class="line-removed"> 361         arrayOfQuads-&gt;addItem(buildArrayForQuad(quad));</span>
<span class="line-removed"> 362 </span>
<span class="line-removed"> 363     return Inspector::Protocol::OverlayTypes::FragmentHighlightData::create()</span>
<span class="line-removed"> 364         .setQuads(WTFMove(arrayOfQuads))</span>
<span class="line-removed"> 365         .setContentColor(highlight.contentColor.serialized())</span>
<span class="line-removed"> 366         .setContentOutlineColor(highlight.contentOutlineColor.serialized())</span>
<span class="line-removed"> 367         .setPaddingColor(highlight.paddingColor.serialized())</span>
<span class="line-removed"> 368         .setBorderColor(highlight.borderColor.serialized())</span>
<span class="line-removed"> 369         .setMarginColor(highlight.marginColor.serialized())</span>
<span class="line-removed"> 370         .release();</span>
<span class="line-removed"> 371 }</span>
<span class="line-removed"> 372 </span>
<span class="line-removed"> 373 static Ref&lt;Inspector::Protocol::OverlayTypes::Size&gt; buildObjectForSize(const IntSize&amp; size)</span>
<span class="line-removed"> 374 {</span>
<span class="line-removed"> 375     return Inspector::Protocol::OverlayTypes::Size::create()</span>
<span class="line-removed"> 376         .setWidth(size.width())</span>
<span class="line-removed"> 377         .setHeight(size.height())</span>
<span class="line-removed"> 378         .release();</span>
 379 }
 380 
<span class="line-modified"> 381 void InspectorOverlay::setShowingPaintRects(bool showingPaintRects)</span>
 382 {
<span class="line-modified"> 383     if (m_showingPaintRects == showingPaintRects)</span>
 384         return;
 385 
<span class="line-modified"> 386     m_showingPaintRects = showingPaintRects;</span>
<span class="line-modified"> 387     if (!m_showingPaintRects) {</span>
 388         m_paintRects.clear();
 389         m_paintRectUpdateTimer.stop();
<span class="line-modified"> 390         drawPaintRects();</span>
<span class="line-removed"> 391         forcePaint();</span>
 392     }
 393 }
 394 
 395 void InspectorOverlay::showPaintRect(const FloatRect&amp; rect)
 396 {
<span class="line-modified"> 397     if (!m_showingPaintRects)</span>
 398         return;
 399 
 400     IntRect rootRect = m_page.mainFrame().view()-&gt;contentsToRootView(enclosingIntRect(rect));
 401 
 402     const auto removeDelay = 250_ms;
 403 
 404     MonotonicTime removeTime = MonotonicTime::now() + removeDelay;
 405     m_paintRects.append(TimeRectPair(removeTime, rootRect));
 406 
 407     if (!m_paintRectUpdateTimer.isActive()) {
 408         const Seconds paintRectsUpdateInterval { 32_ms };
 409         m_paintRectUpdateTimer.startRepeating(paintRectsUpdateInterval);
 410     }
 411 
<span class="line-modified"> 412     drawPaintRects();</span>
<span class="line-removed"> 413     forcePaint();</span>
 414 }
 415 
 416 void InspectorOverlay::setShowRulers(bool showRulers)
 417 {
 418     if (m_showRulers == showRulers)
 419         return;
 420 
 421     m_showRulers = showRulers;
 422 
 423     update();
 424 }
 425 
 426 void InspectorOverlay::updatePaintRectsTimerFired()
 427 {
 428     MonotonicTime now = MonotonicTime::now();
 429     bool rectsChanged = false;
 430     while (!m_paintRects.isEmpty() &amp;&amp; m_paintRects.first().first &lt; now) {
 431         m_paintRects.removeFirst();
 432         rectsChanged = true;
 433     }
 434 
 435     if (m_paintRects.isEmpty())
 436         m_paintRectUpdateTimer.stop();
 437 
<span class="line-modified"> 438     if (rectsChanged) {</span>
<span class="line-modified"> 439         drawPaintRects();</span>
<span class="line-removed"> 440         forcePaint();</span>
<span class="line-removed"> 441     }</span>
 442 }
 443 
<span class="line-modified"> 444 void InspectorOverlay::drawPaintRects()</span>
 445 {
<span class="line-modified"> 446     auto arrayOfRects = JSON::ArrayOf&lt;Inspector::Protocol::OverlayTypes::Rect&gt;::create();</span>
<span class="line-removed"> 447     for (const auto&amp; pair : m_paintRects)</span>
<span class="line-removed"> 448         arrayOfRects-&gt;addItem(buildObjectForRect(pair.second));</span>
 449 
<span class="line-modified"> 450     evaluateInOverlay(&quot;updatePaintRects&quot;_s, WTFMove(arrayOfRects));</span>
<span class="line-removed"> 451 }</span>
 452 
<span class="line-modified"> 453 void InspectorOverlay::drawRulers()</span>
<span class="line-modified"> 454 {</span>
<span class="line-modified"> 455     evaluateInOverlay(&quot;drawRulers&quot;_s);</span>








 456 }
 457 
<span class="line-modified"> 458 static RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::OverlayTypes::FragmentHighlightData&gt;&gt; buildArrayForRendererFragments(RenderObject* renderer, const HighlightConfig&amp; config)</span>
 459 {
<span class="line-modified"> 460     auto arrayOfFragments = JSON::ArrayOf&lt;Inspector::Protocol::OverlayTypes::FragmentHighlightData&gt;::create();</span>
 461 
 462     Highlight highlight;
<span class="line-modified"> 463     buildRendererHighlight(renderer, config, highlight, InspectorOverlay::CoordinateSystem::View);</span>
<span class="line-modified"> 464     arrayOfFragments-&gt;addItem(buildObjectForHighlight(highlight));</span>


 465 
<span class="line-modified"> 466     return WTFMove(arrayOfFragments);</span>




 467 }
 468 
<span class="line-modified"> 469 static FloatPoint localPointToRoot(RenderObject* renderer, const FrameView* mainView, const FrameView* view, const FloatPoint&amp; point)</span>
 470 {
<span class="line-modified"> 471     FloatPoint result = renderer-&gt;localToAbsolute(point);</span>
<span class="line-removed"> 472     result = view-&gt;contentsToRootView(roundedIntPoint(result));</span>
<span class="line-removed"> 473     result += toIntSize(mainView-&gt;scrollPosition());</span>
<span class="line-removed"> 474     return result;</span>
<span class="line-removed"> 475 }</span>
 476 
<span class="line-modified"> 477 struct PathApplyInfo {</span>
<span class="line-modified"> 478     FrameView* rootView;</span>
<span class="line-removed"> 479     FrameView* view;</span>
<span class="line-removed"> 480     Inspector::Protocol::OverlayTypes::DisplayPath* pathArray;</span>
<span class="line-removed"> 481     RenderObject* renderer;</span>
<span class="line-removed"> 482     const ShapeOutsideInfo* shapeOutsideInfo;</span>
<span class="line-removed"> 483 };</span>
 484 
<span class="line-modified"> 485 static void appendPathCommandAndPoints(PathApplyInfo&amp; info, const String&amp; command, const FloatPoint points[], unsigned length)</span>




 486 {
<span class="line-modified"> 487     FloatPoint point;</span>
<span class="line-modified"> 488     info.pathArray-&gt;addItem(command);</span>
<span class="line-modified"> 489     for (unsigned i = 0; i &lt; length; i++) {</span>
<span class="line-modified"> 490         point = info.shapeOutsideInfo-&gt;shapeToRendererPoint(points[i]);</span>
<span class="line-modified"> 491         point = localPointToRoot(info.renderer, info.rootView, info.view, point);</span>
<span class="line-modified"> 492         info.pathArray-&gt;addItem(point.x());</span>
<span class="line-modified"> 493         info.pathArray-&gt;addItem(point.y());</span>













 494     }
<span class="line-removed"> 495 }</span>
 496 
<span class="line-modified"> 497 static void appendPathSegment(PathApplyInfo&amp; pathApplyInfo, const PathElement&amp; pathElement)</span>
<span class="line-modified"> 498 {</span>
<span class="line-modified"> 499     FloatPoint point;</span>
<span class="line-modified"> 500     switch (pathElement.type) {</span>
<span class="line-modified"> 501     // The points member will contain 1 value.</span>
<span class="line-modified"> 502     case PathElementMoveToPoint:</span>
<span class="line-modified"> 503         appendPathCommandAndPoints(pathApplyInfo, &quot;M&quot;_s, pathElement.points, 1);</span>
<span class="line-modified"> 504         break;</span>
<span class="line-modified"> 505     // The points member will contain 1 value.</span>
<span class="line-modified"> 506     case PathElementAddLineToPoint:</span>
<span class="line-modified"> 507         appendPathCommandAndPoints(pathApplyInfo, &quot;L&quot;_s, pathElement.points, 1);</span>
<span class="line-modified"> 508         break;</span>
<span class="line-modified"> 509     // The points member will contain 3 values.</span>
<span class="line-modified"> 510     case PathElementAddCurveToPoint:</span>
<span class="line-removed"> 511         appendPathCommandAndPoints(pathApplyInfo, &quot;C&quot;_s, pathElement.points, 3);</span>
<span class="line-removed"> 512         break;</span>
<span class="line-removed"> 513     // The points member will contain 2 values.</span>
<span class="line-removed"> 514     case PathElementAddQuadCurveToPoint:</span>
<span class="line-removed"> 515         appendPathCommandAndPoints(pathApplyInfo, &quot;Q&quot;_s, pathElement.points, 2);</span>
<span class="line-removed"> 516         break;</span>
<span class="line-removed"> 517     // The points member will contain no values.</span>
<span class="line-removed"> 518     case PathElementCloseSubpath:</span>
<span class="line-removed"> 519         appendPathCommandAndPoints(pathApplyInfo, &quot;Z&quot;_s, nullptr, 0);</span>
<span class="line-removed"> 520         break;</span>
 521     }









 522 }
 523 
<span class="line-modified"> 524 static RefPtr&lt;Inspector::Protocol::OverlayTypes::ShapeOutsideData&gt; buildObjectForShapeOutside(Frame* containingFrame, RenderBox* renderer)</span>
 525 {
<span class="line-modified"> 526     const ShapeOutsideInfo* shapeOutsideInfo = renderer-&gt;shapeOutsideInfo();</span>
<span class="line-modified"> 527     if (!shapeOutsideInfo)</span>
<span class="line-modified"> 528         return nullptr;</span>
















































 529 
<span class="line-modified"> 530     LayoutRect shapeBounds = shapeOutsideInfo-&gt;computedShapePhysicalBoundingBox();</span>
<span class="line-modified"> 531     FloatQuad shapeQuad = renderer-&gt;localToAbsoluteQuad(FloatRect(shapeBounds));</span>
<span class="line-removed"> 532     contentsQuadToPage(containingFrame-&gt;page()-&gt;mainFrame().view(), containingFrame-&gt;view(), shapeQuad);</span>
 533 
<span class="line-modified"> 534     auto shapeObject = Inspector::Protocol::OverlayTypes::ShapeOutsideData::create()</span>
<span class="line-modified"> 535         .setBounds(buildArrayForQuad(shapeQuad))</span>
<span class="line-modified"> 536         .release();</span>
 537 
<span class="line-modified"> 538     Shape::DisplayPaths paths;</span>
<span class="line-removed"> 539     shapeOutsideInfo-&gt;computedShape().buildDisplayPaths(paths);</span>
 540 
<span class="line-modified"> 541     if (paths.shape.length()) {</span>
<span class="line-modified"> 542         auto shapePath = Inspector::Protocol::OverlayTypes::DisplayPath::create();</span>
<span class="line-modified"> 543         PathApplyInfo info;</span>
<span class="line-modified"> 544         info.rootView = containingFrame-&gt;page()-&gt;mainFrame().view();</span>
<span class="line-modified"> 545         info.view = containingFrame-&gt;view();</span>
<span class="line-modified"> 546         info.pathArray = &amp;shapePath.get();</span>
<span class="line-modified"> 547         info.renderer = renderer;</span>
<span class="line-modified"> 548         info.shapeOutsideInfo = shapeOutsideInfo;</span>
<span class="line-modified"> 549 </span>
<span class="line-modified"> 550         paths.shape.apply([&amp;info](const PathElement&amp; pathElement) {</span>
<span class="line-modified"> 551             appendPathSegment(info, pathElement);</span>
<span class="line-modified"> 552         });</span>





































 553 
<span class="line-modified"> 554         shapeObject-&gt;setShape(shapePath.copyRef());</span>

 555 
<span class="line-modified"> 556         if (paths.marginShape.length()) {</span>
<span class="line-modified"> 557             auto marginShapePath = Inspector::Protocol::OverlayTypes::DisplayPath::create();</span>
<span class="line-modified"> 558             info.pathArray = &amp;marginShapePath.get();</span>

 559 
<span class="line-modified"> 560             paths.marginShape.apply([&amp;info](const PathElement&amp; pathElement) {</span>
<span class="line-modified"> 561                 appendPathSegment(info, pathElement);</span>
<span class="line-modified"> 562             });</span>


 563 
<span class="line-modified"> 564             shapeObject-&gt;setMarginShape(marginShapePath.copyRef());</span>



































 565         }
 566     }
 567 
<span class="line-modified"> 568     return WTFMove(shapeObject);</span>

























































 569 }
 570 
<span class="line-modified"> 571 static RefPtr&lt;Inspector::Protocol::OverlayTypes::ElementData&gt; buildObjectForElementData(Node* node, HighlightType)</span>
 572 {
<span class="line-modified"> 573     if (!is&lt;Element&gt;(node) || !node-&gt;document().frame())</span>
<span class="line-modified"> 574         return nullptr;</span>
 575 
<span class="line-modified"> 576     Element* effectiveElement = downcast&lt;Element&gt;(node);</span>
<span class="line-modified"> 577     if (node-&gt;isPseudoElement()) {</span>
<span class="line-modified"> 578         Element* hostElement = downcast&lt;PseudoElement&gt;(*node).hostElement();</span>
<span class="line-removed"> 579         if (!hostElement)</span>
<span class="line-removed"> 580             return nullptr;</span>
<span class="line-removed"> 581         effectiveElement = hostElement;</span>
<span class="line-removed"> 582     }</span>
 583 
<span class="line-modified"> 584     Element&amp; element = *effectiveElement;</span>
<span class="line-modified"> 585     bool isXHTML = element.document().isXHTMLDocument();</span>
<span class="line-modified"> 586     auto elementData = Inspector::Protocol::OverlayTypes::ElementData::create()</span>
<span class="line-modified"> 587         .setTagName(isXHTML ? element.nodeName() : element.nodeName().convertToASCIILowercase())</span>
<span class="line-modified"> 588         .setIdValue(element.getIdAttribute())</span>
<span class="line-modified"> 589         .release();</span>
<span class="line-modified"> 590 </span>
<span class="line-modified"> 591     if (element.hasClass() &amp;&amp; is&lt;StyledElement&gt;(element)) {</span>
<span class="line-modified"> 592         auto classes = JSON::ArrayOf&lt;String&gt;::create();</span>
<span class="line-modified"> 593         HashSet&lt;AtomicString&gt; usedClassNames;</span>
<span class="line-modified"> 594         const SpaceSplitString&amp; classNamesString = downcast&lt;StyledElement&gt;(element).classNames();</span>
<span class="line-modified"> 595         for (size_t i = 0; i &lt; classNamesString.size(); ++i) {</span>
<span class="line-modified"> 596             const AtomicString&amp; className = classNamesString[i];</span>
<span class="line-modified"> 597             if (usedClassNames.contains(className))</span>
<span class="line-modified"> 598                 continue;</span>
<span class="line-modified"> 599 </span>
<span class="line-modified"> 600             usedClassNames.add(className);</span>
<span class="line-modified"> 601             classes-&gt;addItem(className);</span>

 602         }
<span class="line-removed"> 603         elementData-&gt;setClasses(WTFMove(classes));</span>
<span class="line-removed"> 604     }</span>
 605 
<span class="line-modified"> 606     if (node-&gt;isPseudoElement()) {</span>
<span class="line-modified"> 607         if (node-&gt;pseudoId() == PseudoId::Before)</span>
<span class="line-removed"> 608             elementData-&gt;setPseudoElement(&quot;before&quot;);</span>
<span class="line-removed"> 609         else if (node-&gt;pseudoId() == PseudoId::After)</span>
<span class="line-removed"> 610             elementData-&gt;setPseudoElement(&quot;after&quot;);</span>
 611     }
 612 
<span class="line-modified"> 613     RenderElement* renderer = element.renderer();</span>
<span class="line-modified"> 614     if (!renderer)</span>
<span class="line-modified"> 615         return nullptr;</span>
<span class="line-modified"> 616 </span>
<span class="line-modified"> 617     Frame* containingFrame = node-&gt;document().frame();</span>
<span class="line-modified"> 618     FrameView* containingView = containingFrame-&gt;view();</span>
<span class="line-modified"> 619     IntRect boundingBox = snappedIntRect(containingView-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect()));</span>
<span class="line-modified"> 620     RenderBoxModelObject* modelObject = is&lt;RenderBoxModelObject&gt;(*renderer) ? downcast&lt;RenderBoxModelObject&gt;(renderer) : nullptr;</span>
<span class="line-modified"> 621     auto sizeObject = Inspector::Protocol::OverlayTypes::Size::create()</span>
<span class="line-modified"> 622         .setWidth(modelObject ? adjustForAbsoluteZoom(roundToInt(modelObject-&gt;offsetWidth()), *modelObject) : boundingBox.width())</span>
<span class="line-modified"> 623         .setHeight(modelObject ? adjustForAbsoluteZoom(roundToInt(modelObject-&gt;offsetHeight()), *modelObject) : boundingBox.height())</span>
<span class="line-modified"> 624         .release();</span>
<span class="line-modified"> 625     elementData-&gt;setSize(WTFMove(sizeObject));</span>
<span class="line-modified"> 626 </span>
<span class="line-modified"> 627     if (is&lt;RenderBox&gt;(*renderer)) {</span>
<span class="line-modified"> 628         auto&amp; renderBox = downcast&lt;RenderBox&gt;(*renderer);</span>
<span class="line-modified"> 629         if (RefPtr&lt;Inspector::Protocol::OverlayTypes::ShapeOutsideData&gt; shapeObject = buildObjectForShapeOutside(containingFrame, &amp;renderBox))</span>
<span class="line-removed"> 630             elementData-&gt;setShapeOutsideData(WTFMove(shapeObject));</span>
 631     }
 632 
 633     // Need to enable AX to get the computed role.
 634     if (!WebCore::AXObjectCache::accessibilityEnabled())
 635         WebCore::AXObjectCache::enableAccessibility();
 636 
<span class="line-modified"> 637     if (AXObjectCache* axObjectCache = node-&gt;document().axObjectCache()) {</span>
<span class="line-modified"> 638         if (AccessibilityObject* axObject = axObjectCache-&gt;getOrCreate(node))</span>
<span class="line-modified"> 639             elementData-&gt;setRole(axObject-&gt;computedRoleString());</span>

 640     }
 641 
<span class="line-modified"> 642     return WTFMove(elementData);</span>
<span class="line-modified"> 643 }</span>

 644 
<span class="line-modified"> 645 RefPtr&lt;Inspector::Protocol::OverlayTypes::NodeHighlightData&gt; InspectorOverlay::buildHighlightObjectForNode(Node* node, HighlightType type) const</span>
<span class="line-modified"> 646 {</span>
<span class="line-removed"> 647     if (!node)</span>
<span class="line-removed"> 648         return nullptr;</span>
 649 
<span class="line-modified"> 650     RenderObject* renderer = node-&gt;renderer();</span>
<span class="line-removed"> 651     if (!renderer)</span>
<span class="line-removed"> 652         return nullptr;</span>
 653 
<span class="line-modified"> 654     RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::OverlayTypes::FragmentHighlightData&gt;&gt; arrayOfFragmentHighlights = buildArrayForRendererFragments(renderer, m_nodeHighlightConfig);</span>
<span class="line-modified"> 655     if (!arrayOfFragmentHighlights)</span>
<span class="line-modified"> 656         return nullptr;</span>
 657 
<span class="line-modified"> 658     // The main view&#39;s scroll offset is shared across all quads.</span>
<span class="line-modified"> 659     FrameView* mainView = m_page.mainFrame().view();</span>

 660 
<span class="line-modified"> 661     auto nodeHighlightObject = Inspector::Protocol::OverlayTypes::NodeHighlightData::create()</span>
<span class="line-modified"> 662         .setScrollOffset(buildObjectForPoint(!mainView-&gt;delegatesScrolling() ? mainView-&gt;visibleContentRect().location() : FloatPoint()))</span>
<span class="line-removed"> 663         .setFragments(WTFMove(arrayOfFragmentHighlights))</span>
<span class="line-removed"> 664         .release();</span>
 665 
<span class="line-modified"> 666     if (m_nodeHighlightConfig.showInfo) {</span>
<span class="line-modified"> 667         if (RefPtr&lt;Inspector::Protocol::OverlayTypes::ElementData&gt; elementData = buildObjectForElementData(node, type))</span>
<span class="line-modified"> 668             nodeHighlightObject-&gt;setElementData(WTFMove(elementData));</span>
 669     }
 670 
<span class="line-modified"> 671     return WTFMove(nodeHighlightObject);</span>
<span class="line-removed"> 672 }</span>
 673 
<span class="line-modified"> 674 Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::OverlayTypes::NodeHighlightData&gt;&gt; InspectorOverlay::buildObjectForHighlightedNodes() const</span>
<span class="line-modified"> 675 {</span>
<span class="line-removed"> 676     auto highlights = JSON::ArrayOf&lt;Inspector::Protocol::OverlayTypes::NodeHighlightData&gt;::create();</span>
 677 
<span class="line-modified"> 678     if (m_highlightNode) {</span>
<span class="line-modified"> 679         if (RefPtr&lt;Inspector::Protocol::OverlayTypes::NodeHighlightData&gt; nodeHighlightData = buildHighlightObjectForNode(m_highlightNode.get(), HighlightType::Node))</span>
<span class="line-modified"> 680             highlights-&gt;addItem(WTFMove(nodeHighlightData));</span>
<span class="line-modified"> 681     } else if (m_highlightNodeList) {</span>
<span class="line-modified"> 682         for (unsigned i = 0; i &lt; m_highlightNodeList-&gt;length(); ++i) {</span>
<span class="line-modified"> 683             if (RefPtr&lt;Inspector::Protocol::OverlayTypes::NodeHighlightData&gt; nodeHighlightData = buildHighlightObjectForNode(m_highlightNodeList-&gt;item(i), HighlightType::NodeList))</span>
<span class="line-modified"> 684                 highlights-&gt;addItem(WTFMove(nodeHighlightData));</span>
<span class="line-modified"> 685         }</span>






























 686     }
 687 
<span class="line-modified"> 688     return highlights;</span>
<span class="line-modified"> 689 }</span>














 690 
<span class="line-modified"> 691 void InspectorOverlay::drawNodeHighlight()</span>
<span class="line-removed"> 692 {</span>
<span class="line-removed"> 693     if (m_highlightNode || m_highlightNodeList)</span>
<span class="line-removed"> 694         evaluateInOverlay(&quot;drawNodeHighlight&quot;, buildObjectForHighlightedNodes());</span>
<span class="line-removed"> 695 }</span>
 696 
<span class="line-modified"> 697 void InspectorOverlay::drawQuadHighlight()</span>
<span class="line-removed"> 698 {</span>
<span class="line-removed"> 699     if (!m_highlightQuad)</span>
<span class="line-removed"> 700         return;</span>
 701 
<span class="line-modified"> 702     Highlight highlight;</span>
<span class="line-modified"> 703     buildQuadHighlight(*m_highlightQuad, m_quadHighlightConfig, highlight);</span>
<span class="line-removed"> 704     evaluateInOverlay(&quot;drawQuadHighlight&quot;, buildObjectForHighlight(highlight));</span>
<span class="line-removed"> 705 }</span>
<span class="line-removed"> 706 </span>
<span class="line-removed"> 707 void InspectorOverlay::drawPausedInDebuggerMessage()</span>
<span class="line-removed"> 708 {</span>
<span class="line-removed"> 709     if (!m_pausedInDebuggerMessage.isNull())</span>
<span class="line-removed"> 710         evaluateInOverlay(&quot;drawPausedInDebuggerMessage&quot;, m_pausedInDebuggerMessage);</span>
<span class="line-removed"> 711 }</span>
<span class="line-removed"> 712 </span>
<span class="line-removed"> 713 Page* InspectorOverlay::overlayPage()</span>
<span class="line-removed"> 714 {</span>
<span class="line-removed"> 715 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 716     return nullptr;</span>
<span class="line-removed"> 717 #else</span>
<span class="line-removed"> 718     if (m_overlayPage)</span>
<span class="line-removed"> 719         return m_overlayPage.get();</span>
<span class="line-removed"> 720 </span>
<span class="line-removed"> 721     auto pageConfiguration = pageConfigurationWithEmptyClients();</span>
<span class="line-removed"> 722     m_overlayPage = std::make_unique&lt;Page&gt;(WTFMove(pageConfiguration));</span>
<span class="line-removed"> 723     m_overlayPage-&gt;setDeviceScaleFactor(m_page.deviceScaleFactor());</span>
<span class="line-removed"> 724 </span>
<span class="line-removed"> 725     Settings&amp; settings = m_page.settings();</span>
<span class="line-removed"> 726     Settings&amp; overlaySettings = m_overlayPage-&gt;settings();</span>
<span class="line-removed"> 727 </span>
<span class="line-removed"> 728     overlaySettings.setStandardFontFamily(settings.standardFontFamily());</span>
<span class="line-removed"> 729     overlaySettings.setSerifFontFamily(settings.serifFontFamily());</span>
<span class="line-removed"> 730     overlaySettings.setSansSerifFontFamily(settings.sansSerifFontFamily());</span>
<span class="line-removed"> 731     overlaySettings.setCursiveFontFamily(settings.cursiveFontFamily());</span>
<span class="line-removed"> 732     overlaySettings.setFantasyFontFamily(settings.fantasyFontFamily());</span>
<span class="line-removed"> 733     overlaySettings.setPictographFontFamily(settings.pictographFontFamily());</span>
<span class="line-removed"> 734     overlaySettings.setMinimumFontSize(settings.minimumFontSize());</span>
<span class="line-removed"> 735     overlaySettings.setMinimumLogicalFontSize(settings.minimumLogicalFontSize());</span>
<span class="line-removed"> 736     overlaySettings.setMediaEnabled(false);</span>
<span class="line-removed"> 737     overlaySettings.setScriptEnabled(true);</span>
<span class="line-removed"> 738     overlaySettings.setPluginsEnabled(false);</span>
<span class="line-removed"> 739 </span>
<span class="line-removed"> 740     Frame&amp; frame = m_overlayPage-&gt;mainFrame();</span>
<span class="line-removed"> 741     frame.setView(FrameView::create(frame));</span>
<span class="line-removed"> 742     frame.init();</span>
<span class="line-removed"> 743     FrameLoader&amp; loader = frame.loader();</span>
<span class="line-removed"> 744     frame.view()-&gt;setCanHaveScrollbars(false);</span>
<span class="line-removed"> 745     frame.view()-&gt;setTransparent(true);</span>
<span class="line-removed"> 746     ASSERT(loader.activeDocumentLoader());</span>
<span class="line-removed"> 747     auto&amp; writer = loader.activeDocumentLoader()-&gt;writer();</span>
<span class="line-removed"> 748     writer.setMIMEType(&quot;text/html&quot;);</span>
<span class="line-removed"> 749     writer.begin();</span>
<span class="line-removed"> 750     writer.insertDataSynchronously(String(reinterpret_cast&lt;const char*&gt;(InspectorOverlayPage_html), sizeof(InspectorOverlayPage_html)));</span>
<span class="line-removed"> 751     writer.end();</span>
<span class="line-removed"> 752 </span>
<span class="line-removed"> 753 #if OS(WINDOWS)</span>
<span class="line-removed"> 754     evaluateInOverlay(&quot;setPlatform&quot;, &quot;windows&quot;);</span>
<span class="line-removed"> 755 #elif OS(MAC_OS_X)</span>
<span class="line-removed"> 756     evaluateInOverlay(&quot;setPlatform&quot;, &quot;mac&quot;);</span>
<span class="line-removed"> 757 #elif OS(UNIX)</span>
<span class="line-removed"> 758     evaluateInOverlay(&quot;setPlatform&quot;, &quot;linux&quot;);</span>
<span class="line-removed"> 759 #endif</span>
<span class="line-removed"> 760 </span>
<span class="line-removed"> 761     return m_overlayPage.get();</span>
<span class="line-removed"> 762 #endif</span>
<span class="line-removed"> 763 }</span>
<span class="line-removed"> 764 </span>
<span class="line-removed"> 765 void InspectorOverlay::forcePaint()</span>
<span class="line-removed"> 766 {</span>
<span class="line-removed"> 767     // This overlay page is very weird and doesn&#39;t automatically paint. We have to force paints manually.</span>
<span class="line-removed"> 768     m_client-&gt;highlight();</span>
<span class="line-removed"> 769 }</span>
 770 
<span class="line-modified"> 771 void InspectorOverlay::reset(const IntSize&amp; viewportSize, const IntPoint&amp; scrollOffset)</span>
<span class="line-removed"> 772 {</span>
<span class="line-removed"> 773     auto configObject = Inspector::Protocol::OverlayTypes::OverlayConfiguration::create()</span>
<span class="line-removed"> 774         .setDeviceScaleFactor(m_page.deviceScaleFactor())</span>
<span class="line-removed"> 775         .setViewportSize(buildObjectForSize(viewportSize))</span>
<span class="line-removed"> 776         .setPageScaleFactor(m_page.pageScaleFactor())</span>
<span class="line-removed"> 777         .setPageZoomFactor(m_page.mainFrame().pageZoomFactor())</span>
<span class="line-removed"> 778         .setScrollOffset(buildObjectForPoint(scrollOffset))</span>
<span class="line-removed"> 779         .setContentInset(buildObjectForSize(IntSize(0, m_page.mainFrame().view()-&gt;topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset))))</span>
<span class="line-removed"> 780         .setShowRulers(m_showRulers)</span>
<span class="line-removed"> 781         .release();</span>
<span class="line-removed"> 782     evaluateInOverlay(&quot;reset&quot;, WTFMove(configObject));</span>
<span class="line-removed"> 783 }</span>
 784 
<span class="line-modified"> 785 static void evaluateCommandInOverlay(Page* page, Ref&lt;JSON::Array&gt;&amp;&amp; command)</span>
<span class="line-removed"> 786 {</span>
<span class="line-removed"> 787     if (!page)</span>
<span class="line-removed"> 788         return;</span>
 789 
<span class="line-modified"> 790     page-&gt;mainFrame().script().evaluate(ScriptSourceCode(makeString(&quot;dispatch(&quot;, command-&gt;toJSONString(), &#39;)&#39;)));</span>
<span class="line-modified"> 791 }</span>
 792 
<span class="line-modified"> 793 void InspectorOverlay::evaluateInOverlay(const String&amp; method)</span>
<span class="line-removed"> 794 {</span>
<span class="line-removed"> 795     Ref&lt;JSON::Array&gt; command = JSON::Array::create();</span>
<span class="line-removed"> 796     command-&gt;pushString(method);</span>
 797 
<span class="line-modified"> 798     evaluateCommandInOverlay(overlayPage(), WTFMove(command));</span>
<span class="line-modified"> 799 }</span>



 800 
<span class="line-modified"> 801 void InspectorOverlay::evaluateInOverlay(const String&amp; method, const String&amp; argument)</span>
<span class="line-modified"> 802 {</span>
<span class="line-modified"> 803     Ref&lt;JSON::Array&gt; command = JSON::Array::create();</span>
<span class="line-removed"> 804     command-&gt;pushString(method);</span>
<span class="line-removed"> 805     command-&gt;pushString(argument);</span>
 806 
<span class="line-modified"> 807     evaluateCommandInOverlay(overlayPage(), WTFMove(command));</span>
<span class="line-modified"> 808 }</span>










 809 
<span class="line-modified"> 810 void InspectorOverlay::evaluateInOverlay(const String&amp; method, RefPtr&lt;JSON::Value&gt;&amp;&amp; argument)</span>
<span class="line-modified"> 811 {</span>
<span class="line-modified"> 812     Ref&lt;JSON::Array&gt; command = JSON::Array::create();</span>
<span class="line-removed"> 813     command-&gt;pushString(method);</span>
<span class="line-removed"> 814     command-&gt;pushValue(WTFMove(argument));</span>
 815 
<span class="line-modified"> 816     evaluateCommandInOverlay(overlayPage(), WTFMove(command));</span>
<span class="line-modified"> 817 }</span>


 818 
<span class="line-modified"> 819 void InspectorOverlay::freePage()</span>
<span class="line-removed"> 820 {</span>
<span class="line-removed"> 821     m_overlayPage = nullptr;</span>
 822 }
 823 
 824 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2011 Google Inc. All rights reserved.
<span class="line-added">   3  * Copyright (C) 2019 Apple Inc. All rights reserved.</span>
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;InspectorOverlay.h&quot;
  32 
<span class="line-modified">  33 #include &quot;AXObjectCache.h&quot;</span>
<span class="line-modified">  34 #include &quot;AccessibilityObject.h&quot;</span>
<span class="line-modified">  35 #include &quot;DOMCSSNamespace.h&quot;</span>
<span class="line-added">  36 #include &quot;DOMTokenList.h&quot;</span>
  37 #include &quot;Element.h&quot;
<span class="line-modified">  38 #include &quot;FloatPoint.h&quot;</span>
<span class="line-added">  39 #include &quot;FloatRoundedRect.h&quot;</span>
<span class="line-added">  40 #include &quot;FloatSize.h&quot;</span>
<span class="line-added">  41 #include &quot;FontCascade.h&quot;</span>
<span class="line-added">  42 #include &quot;FontCascadeDescription.h&quot;</span>
  43 #include &quot;Frame.h&quot;
  44 #include &quot;FrameView.h&quot;
  45 #include &quot;GraphicsContext.h&quot;
  46 #include &quot;InspectorClient.h&quot;
<span class="line-modified">  47 #include &quot;IntPoint.h&quot;</span>
<span class="line-modified">  48 #include &quot;IntRect.h&quot;</span>
<span class="line-added">  49 #include &quot;IntSize.h&quot;</span>
  50 #include &quot;Node.h&quot;
<span class="line-added">  51 #include &quot;NodeList.h&quot;</span>
  52 #include &quot;Page.h&quot;


  53 #include &quot;PseudoElement.h&quot;
<span class="line-modified">  54 #include &quot;RenderBox.h&quot;</span>

  55 #include &quot;RenderBoxModelObject.h&quot;

  56 #include &quot;RenderInline.h&quot;
<span class="line-modified">  57 #include &quot;RenderObject.h&quot;</span>


  58 #include &quot;Settings.h&quot;
<span class="line-modified">  59 #include &lt;wtf/MathExtras.h&gt;</span>
<span class="line-modified">  60 #include &lt;wtf/text/StringBuilder.h&gt;</span>






  61 
  62 namespace WebCore {
  63 
  64 using namespace Inspector;
  65 
<span class="line-added">  66 static constexpr float elementDataSpacing = 2;</span>
<span class="line-added">  67 static constexpr float elementDataArrowSize = 7;</span>
<span class="line-added">  68 static constexpr float elementDataBorderSize = 1;</span>
<span class="line-added">  69 </span>
<span class="line-added">  70 static constexpr float rulerSize = 15;</span>
<span class="line-added">  71 static constexpr float rulerLabelSize = 13;</span>
<span class="line-added">  72 static constexpr float rulerStepIncrement = 50;</span>
<span class="line-added">  73 static constexpr float rulerStepLength = 8;</span>
<span class="line-added">  74 static constexpr float rulerSubStepIncrement = 5;</span>
<span class="line-added">  75 static constexpr float rulerSubStepLength = 5;</span>
<span class="line-added">  76 </span>
<span class="line-added">  77 static constexpr UChar ellipsis = 0x2026;</span>
<span class="line-added">  78 static constexpr UChar multiplicationSign = 0x00D7;</span>
<span class="line-added">  79 </span>
<span class="line-added">  80 static void truncateWithEllipsis(String&amp; string, size_t length)</span>
<span class="line-added">  81 {</span>
<span class="line-added">  82     if (string.length() &gt; length) {</span>
<span class="line-added">  83         string.truncate(length);</span>
<span class="line-added">  84         string.append(ellipsis);</span>
<span class="line-added">  85     }</span>
<span class="line-added">  86 }</span>
<span class="line-added">  87 </span>
<span class="line-added">  88 static FloatPoint localPointToRootPoint(const FrameView* view, const FloatPoint&amp; point)</span>
<span class="line-added">  89 {</span>
<span class="line-added">  90     return view-&gt;contentsToRootView(roundedIntPoint(point));</span>
<span class="line-added">  91 }</span>
<span class="line-added">  92 </span>
  93 static void contentsQuadToCoordinateSystem(const FrameView* mainView, const FrameView* view, FloatQuad&amp; quad, InspectorOverlay::CoordinateSystem coordinateSystem)
  94 {
<span class="line-modified">  95     quad.setP1(localPointToRootPoint(view, quad.p1()));</span>
<span class="line-modified">  96     quad.setP2(localPointToRootPoint(view, quad.p2()));</span>
<span class="line-modified">  97     quad.setP3(localPointToRootPoint(view, quad.p3()));</span>
<span class="line-modified">  98     quad.setP4(localPointToRootPoint(view, quad.p4()));</span>
  99 
 100     if (coordinateSystem == InspectorOverlay::CoordinateSystem::View)
 101         quad += toIntSize(mainView-&gt;scrollPosition());
 102 }
 103 
<span class="line-modified"> 104 static Element* effectiveElementForNode(Node&amp; node)</span>
 105 {
<span class="line-modified"> 106     if (!is&lt;Element&gt;(node) || !node.document().frame())</span>
<span class="line-added"> 107         return nullptr;</span>
<span class="line-added"> 108 </span>
<span class="line-added"> 109     Element* element = nullptr;</span>
<span class="line-added"> 110     if (is&lt;PseudoElement&gt;(node)) {</span>
<span class="line-added"> 111         if (Element* hostElement = downcast&lt;PseudoElement&gt;(node).hostElement())</span>
<span class="line-added"> 112             element = hostElement;</span>
<span class="line-added"> 113     } else</span>
<span class="line-added"> 114         element = &amp;downcast&lt;Element&gt;(node);</span>
<span class="line-added"> 115 </span>
<span class="line-added"> 116     return element;</span>
 117 }
 118 
 119 static void buildRendererHighlight(RenderObject* renderer, const HighlightConfig&amp; highlightConfig, Highlight&amp; highlight, InspectorOverlay::CoordinateSystem coordinateSystem)
 120 {
 121     Frame* containingFrame = renderer-&gt;document().frame();
 122     if (!containingFrame)
 123         return;
 124 
 125     highlight.setDataFromConfig(highlightConfig);
 126     FrameView* containingView = containingFrame-&gt;view();
 127     FrameView* mainView = containingFrame-&gt;page()-&gt;mainFrame().view();
 128 
 129     // RenderSVGRoot should be highlighted through the isBox() code path, all other SVG elements should just dump their absoluteQuads().
 130     bool isSVGRenderer = renderer-&gt;node() &amp;&amp; renderer-&gt;node()-&gt;isSVGElement() &amp;&amp; !renderer-&gt;isSVGRoot();
 131 
 132     if (isSVGRenderer) {
 133         highlight.type = HighlightType::Rects;
 134         renderer-&gt;absoluteQuads(highlight.quads);
 135         for (auto&amp; quad : highlight.quads)
 136             contentsQuadToCoordinateSystem(mainView, containingView, quad, coordinateSystem);
</pre>
<hr />
<pre>
 182         highlight.quads.append(absContentQuad);
 183     }
 184 }
 185 
 186 static void buildNodeHighlight(Node&amp; node, const HighlightConfig&amp; highlightConfig, Highlight&amp; highlight, InspectorOverlay::CoordinateSystem coordinateSystem)
 187 {
 188     RenderObject* renderer = node.renderer();
 189     if (!renderer)
 190         return;
 191 
 192     buildRendererHighlight(renderer, highlightConfig, highlight, coordinateSystem);
 193 }
 194 
 195 static void buildQuadHighlight(const FloatQuad&amp; quad, const HighlightConfig&amp; highlightConfig, Highlight&amp; highlight)
 196 {
 197     highlight.setDataFromConfig(highlightConfig);
 198     highlight.type = HighlightType::Rects;
 199     highlight.quads.append(quad);
 200 }
 201 
<span class="line-added"> 202 static Path quadToPath(const FloatQuad&amp; quad, Highlight::Bounds&amp; bounds)</span>
<span class="line-added"> 203 {</span>
<span class="line-added"> 204     Path path;</span>
<span class="line-added"> 205     path.moveTo(quad.p1());</span>
<span class="line-added"> 206     path.addLineTo(quad.p2());</span>
<span class="line-added"> 207     path.addLineTo(quad.p3());</span>
<span class="line-added"> 208     path.addLineTo(quad.p4());</span>
<span class="line-added"> 209     path.closeSubpath();</span>
<span class="line-added"> 210 </span>
<span class="line-added"> 211     bounds.unite(path.boundingRect());</span>
<span class="line-added"> 212 </span>
<span class="line-added"> 213     return path;</span>
<span class="line-added"> 214 }</span>
<span class="line-added"> 215 </span>
<span class="line-added"> 216 static void drawOutlinedQuadWithClip(GraphicsContext&amp; context, const FloatQuad&amp; quad, const FloatQuad&amp; clipQuad, const Color&amp; fillColor, Highlight::Bounds&amp; bounds)</span>
<span class="line-added"> 217 {</span>
<span class="line-added"> 218     GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added"> 219 </span>
<span class="line-added"> 220     context.setFillColor(fillColor);</span>
<span class="line-added"> 221     context.setStrokeThickness(0);</span>
<span class="line-added"> 222     context.fillPath(quadToPath(quad, bounds));</span>
<span class="line-added"> 223 </span>
<span class="line-added"> 224     context.setCompositeOperation(CompositeDestinationOut);</span>
<span class="line-added"> 225     context.setFillColor(Color::createUnchecked(255, 0, 0));</span>
<span class="line-added"> 226     context.fillPath(quadToPath(clipQuad, bounds));</span>
<span class="line-added"> 227 }</span>
<span class="line-added"> 228 </span>
<span class="line-added"> 229 static void drawOutlinedQuad(GraphicsContext&amp; context, const FloatQuad&amp; quad, const Color&amp; fillColor, const Color&amp; outlineColor, Highlight::Bounds&amp; bounds)</span>
<span class="line-added"> 230 {</span>
<span class="line-added"> 231     Path path = quadToPath(quad, bounds);</span>
<span class="line-added"> 232 </span>
<span class="line-added"> 233     GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added"> 234 </span>
<span class="line-added"> 235     context.setStrokeThickness(2);</span>
<span class="line-added"> 236 </span>
<span class="line-added"> 237     context.clipPath(path);</span>
<span class="line-added"> 238 </span>
<span class="line-added"> 239     context.setFillColor(fillColor);</span>
<span class="line-added"> 240     context.fillPath(path);</span>
<span class="line-added"> 241 </span>
<span class="line-added"> 242     context.setStrokeColor(outlineColor);</span>
<span class="line-added"> 243     context.strokePath(path);</span>
<span class="line-added"> 244 }</span>
<span class="line-added"> 245 </span>
<span class="line-added"> 246 static void drawFragmentHighlight(GraphicsContext&amp; context, Node&amp; node, const HighlightConfig&amp; highlightConfig, Highlight::Bounds&amp; bounds)</span>
<span class="line-added"> 247 {</span>
<span class="line-added"> 248     Highlight highlight;</span>
<span class="line-added"> 249     buildNodeHighlight(node, highlightConfig, highlight, InspectorOverlay::CoordinateSystem::Document);</span>
<span class="line-added"> 250 </span>
<span class="line-added"> 251     FloatQuad marginQuad;</span>
<span class="line-added"> 252     FloatQuad borderQuad;</span>
<span class="line-added"> 253     FloatQuad paddingQuad;</span>
<span class="line-added"> 254     FloatQuad contentQuad;</span>
<span class="line-added"> 255 </span>
<span class="line-added"> 256     size_t size = highlight.quads.size();</span>
<span class="line-added"> 257     if (size &gt;= 1)</span>
<span class="line-added"> 258         marginQuad = highlight.quads[0];</span>
<span class="line-added"> 259     if (size &gt;= 2)</span>
<span class="line-added"> 260         borderQuad = highlight.quads[1];</span>
<span class="line-added"> 261     if (size &gt;= 3)</span>
<span class="line-added"> 262         paddingQuad = highlight.quads[2];</span>
<span class="line-added"> 263     if (size &gt;= 4)</span>
<span class="line-added"> 264         contentQuad = highlight.quads[3];</span>
<span class="line-added"> 265 </span>
<span class="line-added"> 266     if (!marginQuad.isEmpty() &amp;&amp; marginQuad != borderQuad &amp;&amp; highlight.marginColor.isVisible())</span>
<span class="line-added"> 267         drawOutlinedQuadWithClip(context, marginQuad, borderQuad, highlight.marginColor, bounds);</span>
<span class="line-added"> 268 </span>
<span class="line-added"> 269     if (!borderQuad.isEmpty() &amp;&amp; borderQuad != paddingQuad &amp;&amp; highlight.borderColor.isVisible())</span>
<span class="line-added"> 270         drawOutlinedQuadWithClip(context, borderQuad, paddingQuad, highlight.borderColor, bounds);</span>
<span class="line-added"> 271 </span>
<span class="line-added"> 272     if (!paddingQuad.isEmpty() &amp;&amp; paddingQuad != contentQuad &amp;&amp; highlight.paddingColor.isVisible())</span>
<span class="line-added"> 273         drawOutlinedQuadWithClip(context, paddingQuad, contentQuad, highlight.paddingColor, bounds);</span>
<span class="line-added"> 274 </span>
<span class="line-added"> 275     if (!contentQuad.isEmpty() &amp;&amp; (highlight.contentColor.isVisible() || highlight.contentOutlineColor.isVisible()))</span>
<span class="line-added"> 276         drawOutlinedQuad(context, contentQuad, highlight.contentColor, highlight.contentOutlineColor, bounds);</span>
<span class="line-added"> 277 }</span>
<span class="line-added"> 278 </span>
<span class="line-added"> 279 static void drawShapeHighlight(GraphicsContext&amp; context, Node&amp; node, Highlight::Bounds&amp; bounds)</span>
<span class="line-added"> 280 {</span>
<span class="line-added"> 281     RenderObject* renderer = node.renderer();</span>
<span class="line-added"> 282     if (!renderer || !is&lt;RenderBox&gt;(renderer))</span>
<span class="line-added"> 283         return;</span>
<span class="line-added"> 284 </span>
<span class="line-added"> 285     const ShapeOutsideInfo* shapeOutsideInfo = downcast&lt;RenderBox&gt;(renderer)-&gt;shapeOutsideInfo();</span>
<span class="line-added"> 286     if (!shapeOutsideInfo)</span>
<span class="line-added"> 287         return;</span>
<span class="line-added"> 288 </span>
<span class="line-added"> 289     Frame* containingFrame = node.document().frame();</span>
<span class="line-added"> 290     if (!containingFrame)</span>
<span class="line-added"> 291         return;</span>
<span class="line-added"> 292 </span>
<span class="line-added"> 293     FrameView* containingView = containingFrame-&gt;view();</span>
<span class="line-added"> 294     FrameView* mainView = containingFrame-&gt;page()-&gt;mainFrame().view();</span>
<span class="line-added"> 295 </span>
<span class="line-added"> 296     const Color shapeHighlightColor(96, 82, 127, 204);</span>
<span class="line-added"> 297 </span>
<span class="line-added"> 298     Shape::DisplayPaths paths;</span>
<span class="line-added"> 299     shapeOutsideInfo-&gt;computedShape().buildDisplayPaths(paths);</span>
<span class="line-added"> 300 </span>
<span class="line-added"> 301     if (paths.shape.isEmpty()) {</span>
<span class="line-added"> 302         LayoutRect shapeBounds = shapeOutsideInfo-&gt;computedShapePhysicalBoundingBox();</span>
<span class="line-added"> 303         FloatQuad shapeQuad = renderer-&gt;localToAbsoluteQuad(FloatRect(shapeBounds));</span>
<span class="line-added"> 304         contentsQuadToCoordinateSystem(mainView, containingView, shapeQuad, InspectorOverlay::CoordinateSystem::Document);</span>
<span class="line-added"> 305         drawOutlinedQuad(context, shapeQuad, shapeHighlightColor, Color::transparent, bounds);</span>
<span class="line-added"> 306         return;</span>
<span class="line-added"> 307     }</span>
<span class="line-added"> 308 </span>
<span class="line-added"> 309     const auto mapPoints = [&amp;] (const Path&amp; path) {</span>
<span class="line-added"> 310         Path newPath;</span>
<span class="line-added"> 311         path.apply([&amp;] (const PathElement&amp; pathElement) {</span>
<span class="line-added"> 312             const auto localToRoot = [&amp;] (size_t index) {</span>
<span class="line-added"> 313                 const FloatPoint&amp; point = pathElement.points[index];</span>
<span class="line-added"> 314                 return localPointToRootPoint(containingView, renderer-&gt;localToAbsolute(shapeOutsideInfo-&gt;shapeToRendererPoint(point)));</span>
<span class="line-added"> 315             };</span>
<span class="line-added"> 316 </span>
<span class="line-added"> 317             switch (pathElement.type) {</span>
<span class="line-added"> 318             case PathElementMoveToPoint:</span>
<span class="line-added"> 319                 newPath.moveTo(localToRoot(0));</span>
<span class="line-added"> 320                 break;</span>
<span class="line-added"> 321 </span>
<span class="line-added"> 322             case PathElementAddLineToPoint:</span>
<span class="line-added"> 323                 newPath.addLineTo(localToRoot(0));</span>
<span class="line-added"> 324                 break;</span>
<span class="line-added"> 325 </span>
<span class="line-added"> 326             case PathElementAddCurveToPoint:</span>
<span class="line-added"> 327                 newPath.addBezierCurveTo(localToRoot(0), localToRoot(1), localToRoot(2));</span>
<span class="line-added"> 328                 break;</span>
<span class="line-added"> 329 </span>
<span class="line-added"> 330             case PathElementAddQuadCurveToPoint:</span>
<span class="line-added"> 331                 newPath.addQuadCurveTo(localToRoot(0), localToRoot(1));</span>
<span class="line-added"> 332                 break;</span>
<span class="line-added"> 333 </span>
<span class="line-added"> 334             case PathElementCloseSubpath:</span>
<span class="line-added"> 335                 newPath.closeSubpath();</span>
<span class="line-added"> 336                 break;</span>
<span class="line-added"> 337             }</span>
<span class="line-added"> 338         });</span>
<span class="line-added"> 339         return newPath;</span>
<span class="line-added"> 340     };</span>
<span class="line-added"> 341 </span>
<span class="line-added"> 342     if (paths.marginShape.length()) {</span>
<span class="line-added"> 343         Path marginPath = mapPoints(paths.marginShape);</span>
<span class="line-added"> 344         bounds.unite(marginPath.boundingRect());</span>
<span class="line-added"> 345 </span>
<span class="line-added"> 346         GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added"> 347 </span>
<span class="line-added"> 348         const Color shapeMarginHighlightColor(96, 82, 127, 153);</span>
<span class="line-added"> 349         context.setFillColor(shapeMarginHighlightColor);</span>
<span class="line-added"> 350         context.fillPath(marginPath);</span>
<span class="line-added"> 351     }</span>
<span class="line-added"> 352 </span>
<span class="line-added"> 353     Path shapePath = mapPoints(paths.shape);</span>
<span class="line-added"> 354     bounds.unite(shapePath.boundingRect());</span>
<span class="line-added"> 355 </span>
<span class="line-added"> 356     GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added"> 357 </span>
<span class="line-added"> 358     context.setFillColor(shapeHighlightColor);</span>
<span class="line-added"> 359     context.fillPath(shapePath);</span>
<span class="line-added"> 360 }</span>
<span class="line-added"> 361 </span>
 362 InspectorOverlay::InspectorOverlay(Page&amp; page, InspectorClient* client)
 363     : m_page(page)
 364     , m_client(client)
 365     , m_paintRectUpdateTimer(*this, &amp;InspectorOverlay::updatePaintRectsTimerFired)
 366 {
 367 }
 368 
 369 InspectorOverlay::~InspectorOverlay() = default;
 370 
 371 void InspectorOverlay::paint(GraphicsContext&amp; context)
 372 {
 373     if (!shouldShowOverlay())
 374         return;
 375 
<span class="line-modified"> 376     FloatSize viewportSize = m_page.mainFrame().view()-&gt;sizeForVisibleContent();</span>
<span class="line-modified"> 377 </span>
<span class="line-modified"> 378     context.clearRect({ FloatPoint::zero(), viewportSize });</span>
 379 
 380     GraphicsContextStateSaver stateSaver(context);

 381 
<span class="line-modified"> 382     if (m_indicating) {</span>
<span class="line-modified"> 383         GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-modified"> 384 </span>
<span class="line-added"> 385         const Color indicatingColor(111, 168, 220, 168);</span>
<span class="line-added"> 386         context.setFillColor(indicatingColor);</span>
<span class="line-added"> 387         context.fillRect({ FloatPoint::zero(), viewportSize });</span>
<span class="line-added"> 388     }</span>
<span class="line-added"> 389 </span>
<span class="line-added"> 390     RulerExclusion rulerExclusion;</span>
<span class="line-added"> 391 </span>
<span class="line-added"> 392     if (m_highlightQuad) {</span>
<span class="line-added"> 393         auto quadRulerExclusion = drawQuadHighlight(context, *m_highlightQuad);</span>
<span class="line-added"> 394         rulerExclusion.bounds.unite(quadRulerExclusion.bounds);</span>
<span class="line-added"> 395     }</span>
<span class="line-added"> 396 </span>
<span class="line-added"> 397     if (m_highlightNodeList) {</span>
<span class="line-added"> 398         for (unsigned i = 0; i &lt; m_highlightNodeList-&gt;length(); ++i) {</span>
<span class="line-added"> 399             if (auto* node = m_highlightNodeList-&gt;item(i)) {</span>
<span class="line-added"> 400                 auto nodeRulerExclusion = drawNodeHighlight(context, *node);</span>
<span class="line-added"> 401                 rulerExclusion.bounds.unite(nodeRulerExclusion.bounds);</span>
<span class="line-added"> 402             }</span>
<span class="line-added"> 403         }</span>
<span class="line-added"> 404     }</span>
<span class="line-added"> 405 </span>
<span class="line-added"> 406     if (m_highlightNode) {</span>
<span class="line-added"> 407         auto nodeRulerExclusion = drawNodeHighlight(context, *m_highlightNode);</span>
<span class="line-added"> 408         rulerExclusion.bounds.unite(nodeRulerExclusion.bounds);</span>
<span class="line-added"> 409         rulerExclusion.titlePath = nodeRulerExclusion.titlePath;</span>
<span class="line-added"> 410     }</span>
<span class="line-added"> 411 </span>
<span class="line-added"> 412     if (!m_paintRects.isEmpty())</span>
<span class="line-added"> 413         drawPaintRects(context, m_paintRects);</span>
 414 
<span class="line-modified"> 415     if (m_showRulers || m_showRulersDuringElementSelection)</span>
<span class="line-modified"> 416         drawRulers(context, rulerExclusion);</span>
 417 }
 418 
 419 void InspectorOverlay::getHighlight(Highlight&amp; highlight, InspectorOverlay::CoordinateSystem coordinateSystem) const
 420 {
 421     if (!m_highlightNode &amp;&amp; !m_highlightQuad &amp;&amp; !m_highlightNodeList)
 422         return;
 423 
 424     highlight.type = HighlightType::Rects;
 425     if (m_highlightNode)
 426         buildNodeHighlight(*m_highlightNode, m_nodeHighlightConfig, highlight, coordinateSystem);
 427     else if (m_highlightNodeList) {
 428         highlight.setDataFromConfig(m_nodeHighlightConfig);
 429         for (unsigned i = 0; i &lt; m_highlightNodeList-&gt;length(); ++i) {
 430             Highlight nodeHighlight;
 431             buildNodeHighlight(*(m_highlightNodeList-&gt;item(i)), m_nodeHighlightConfig, nodeHighlight, coordinateSystem);
 432             if (nodeHighlight.type == HighlightType::Node)
 433                 highlight.quads.appendVector(nodeHighlight.quads);
 434         }
 435         highlight.type = HighlightType::NodeList;
 436     } else
 437         buildQuadHighlight(*m_highlightQuad, m_quadHighlightConfig, highlight);
 438 }
 439 






 440 void InspectorOverlay::hideHighlight()
 441 {
 442     m_highlightNode = nullptr;
 443     m_highlightNodeList = nullptr;
 444     m_highlightQuad = nullptr;
 445     update();
 446 }
 447 
 448 void InspectorOverlay::highlightNodeList(RefPtr&lt;NodeList&gt;&amp;&amp; nodes, const HighlightConfig&amp; highlightConfig)
 449 {
 450     m_nodeHighlightConfig = highlightConfig;
 451     m_highlightNodeList = WTFMove(nodes);
 452     m_highlightNode = nullptr;
 453     update();
 454 }
 455 
 456 void InspectorOverlay::highlightNode(Node* node, const HighlightConfig&amp; highlightConfig)
 457 {
 458     m_nodeHighlightConfig = highlightConfig;
 459     m_highlightNode = node;
</pre>
<hr />
<pre>
 466     if (highlightConfig.usePageCoordinates)
 467         *quad -= toIntSize(m_page.mainFrame().view()-&gt;scrollPosition());
 468 
 469     m_quadHighlightConfig = highlightConfig;
 470     m_highlightQuad = WTFMove(quad);
 471     update();
 472 }
 473 
 474 Node* InspectorOverlay::highlightedNode() const
 475 {
 476     return m_highlightNode.get();
 477 }
 478 
 479 void InspectorOverlay::didSetSearchingForNode(bool enabled)
 480 {
 481     m_client-&gt;didSetSearchingForNode(enabled);
 482 }
 483 
 484 void InspectorOverlay::setIndicating(bool indicating)
 485 {
<span class="line-modified"> 486     if (m_indicating == indicating)</span>
<span class="line-added"> 487         return;</span>
 488 
<span class="line-modified"> 489     m_indicating = indicating;</span>



 490 
 491     update();
 492 }
 493 
 494 bool InspectorOverlay::shouldShowOverlay() const
 495 {
<span class="line-modified"> 496     // Don&#39;t show the overlay when m_showRulersDuringElementSelection is true, as it&#39;s only supposed</span>
<span class="line-added"> 497     // to have an effect when element selection is active (e.g. a node is hovered).</span>
<span class="line-added"> 498     return m_highlightNode || m_highlightNodeList || m_highlightQuad || m_indicating || m_showPaintRects || m_showRulers;</span>
 499 }
 500 
 501 void InspectorOverlay::update()
 502 {
 503     if (!shouldShowOverlay()) {
 504         m_client-&gt;hideHighlight();
 505         return;
 506     }
 507 
 508     FrameView* view = m_page.mainFrame().view();
 509     if (!view)
 510         return;
 511 
<span class="line-modified"> 512     m_client-&gt;highlight();</span>

















































































 513 }
 514 
<span class="line-modified"> 515 void InspectorOverlay::setShowPaintRects(bool showPaintRects)</span>
 516 {
<span class="line-modified"> 517     if (m_showPaintRects == showPaintRects)</span>
 518         return;
 519 
<span class="line-modified"> 520     m_showPaintRects = showPaintRects;</span>
<span class="line-modified"> 521     if (!m_showPaintRects) {</span>
 522         m_paintRects.clear();
 523         m_paintRectUpdateTimer.stop();
<span class="line-modified"> 524         update();</span>

 525     }
 526 }
 527 
 528 void InspectorOverlay::showPaintRect(const FloatRect&amp; rect)
 529 {
<span class="line-modified"> 530     if (!m_showPaintRects)</span>
 531         return;
 532 
 533     IntRect rootRect = m_page.mainFrame().view()-&gt;contentsToRootView(enclosingIntRect(rect));
 534 
 535     const auto removeDelay = 250_ms;
 536 
 537     MonotonicTime removeTime = MonotonicTime::now() + removeDelay;
 538     m_paintRects.append(TimeRectPair(removeTime, rootRect));
 539 
 540     if (!m_paintRectUpdateTimer.isActive()) {
 541         const Seconds paintRectsUpdateInterval { 32_ms };
 542         m_paintRectUpdateTimer.startRepeating(paintRectsUpdateInterval);
 543     }
 544 
<span class="line-modified"> 545     update();</span>

 546 }
 547 
 548 void InspectorOverlay::setShowRulers(bool showRulers)
 549 {
 550     if (m_showRulers == showRulers)
 551         return;
 552 
 553     m_showRulers = showRulers;
 554 
 555     update();
 556 }
 557 
 558 void InspectorOverlay::updatePaintRectsTimerFired()
 559 {
 560     MonotonicTime now = MonotonicTime::now();
 561     bool rectsChanged = false;
 562     while (!m_paintRects.isEmpty() &amp;&amp; m_paintRects.first().first &lt; now) {
 563         m_paintRects.removeFirst();
 564         rectsChanged = true;
 565     }
 566 
 567     if (m_paintRects.isEmpty())
 568         m_paintRectUpdateTimer.stop();
 569 
<span class="line-modified"> 570     if (rectsChanged)</span>
<span class="line-modified"> 571         update();</span>


 572 }
 573 
<span class="line-modified"> 574 InspectorOverlay::RulerExclusion InspectorOverlay::drawNodeHighlight(GraphicsContext&amp; context, Node&amp; node)</span>
 575 {
<span class="line-modified"> 576     RulerExclusion rulerExclusion;</span>


 577 
<span class="line-modified"> 578     drawFragmentHighlight(context, node, m_nodeHighlightConfig, rulerExclusion.bounds);</span>

 579 
<span class="line-modified"> 580     if (m_nodeHighlightConfig.showInfo)</span>
<span class="line-modified"> 581         drawShapeHighlight(context, node, rulerExclusion.bounds);</span>
<span class="line-modified"> 582 </span>
<span class="line-added"> 583     if (m_showRulers || m_showRulersDuringElementSelection)</span>
<span class="line-added"> 584         drawBounds(context, rulerExclusion.bounds);</span>
<span class="line-added"> 585 </span>
<span class="line-added"> 586     // Ensure that the title information is drawn after the bounds.</span>
<span class="line-added"> 587     if (m_nodeHighlightConfig.showInfo)</span>
<span class="line-added"> 588         rulerExclusion.titlePath = drawElementTitle(context, node, rulerExclusion.bounds);</span>
<span class="line-added"> 589 </span>
<span class="line-added"> 590     return rulerExclusion;</span>
 591 }
 592 
<span class="line-modified"> 593 InspectorOverlay::RulerExclusion InspectorOverlay::drawQuadHighlight(GraphicsContext&amp; context, const FloatQuad&amp; quad)</span>
 594 {
<span class="line-modified"> 595     RulerExclusion rulerExclusion;</span>
 596 
 597     Highlight highlight;
<span class="line-modified"> 598     buildQuadHighlight(quad, m_quadHighlightConfig, highlight);</span>
<span class="line-modified"> 599 </span>
<span class="line-added"> 600     if (highlight.quads.size() &gt;= 1) {</span>
<span class="line-added"> 601         drawOutlinedQuad(context, highlight.quads[0], highlight.contentColor, highlight.contentOutlineColor, rulerExclusion.bounds);</span>
 602 
<span class="line-modified"> 603         if (m_showRulers || m_showRulersDuringElementSelection)</span>
<span class="line-added"> 604             drawBounds(context, rulerExclusion.bounds);</span>
<span class="line-added"> 605     }</span>
<span class="line-added"> 606 </span>
<span class="line-added"> 607     return rulerExclusion;</span>
 608 }
 609 
<span class="line-modified"> 610 void InspectorOverlay::drawPaintRects(GraphicsContext&amp; context, const Deque&lt;TimeRectPair&gt;&amp; paintRects)</span>
 611 {
<span class="line-modified"> 612     GraphicsContextStateSaver stateSaver(context);</span>




 613 
<span class="line-modified"> 614     const Color paintRectsColor(1.0f, 0.0f, 0.0f, 0.5f);</span>
<span class="line-modified"> 615     context.setFillColor(paintRectsColor);</span>





 616 
<span class="line-modified"> 617     for (const TimeRectPair&amp; pair : paintRects)</span>
<span class="line-added"> 618         context.fillRect(pair.second);</span>
<span class="line-added"> 619 }</span>
<span class="line-added"> 620 </span>
<span class="line-added"> 621 void InspectorOverlay::drawBounds(GraphicsContext&amp; context, const Highlight::Bounds&amp; bounds)</span>
 622 {
<span class="line-modified"> 623     FrameView* pageView = m_page.mainFrame().view();</span>
<span class="line-modified"> 624     FloatSize viewportSize = pageView-&gt;sizeForVisibleContent();</span>
<span class="line-modified"> 625     FloatSize contentInset(0, pageView-&gt;topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset));</span>
<span class="line-modified"> 626 </span>
<span class="line-modified"> 627     Path path;</span>
<span class="line-modified"> 628 </span>
<span class="line-modified"> 629     if (bounds.y() &gt; contentInset.height()) {</span>
<span class="line-added"> 630         path.moveTo({ bounds.x(), bounds.y() });</span>
<span class="line-added"> 631         path.addLineTo({ bounds.x(), contentInset.height() });</span>
<span class="line-added"> 632 </span>
<span class="line-added"> 633         path.moveTo({ bounds.maxX(), bounds.y() });</span>
<span class="line-added"> 634         path.addLineTo({ bounds.maxX(), contentInset.height() });</span>
<span class="line-added"> 635     }</span>
<span class="line-added"> 636 </span>
<span class="line-added"> 637     if (bounds.maxY() &lt; viewportSize.height()) {</span>
<span class="line-added"> 638         path.moveTo({ bounds.x(), viewportSize.height() });</span>
<span class="line-added"> 639         path.addLineTo({ bounds.x(), bounds.maxY() });</span>
<span class="line-added"> 640 </span>
<span class="line-added"> 641         path.moveTo({ bounds.maxX(), viewportSize.height() });</span>
<span class="line-added"> 642         path.addLineTo({ bounds.maxX(), bounds.maxY() });</span>
 643     }

 644 
<span class="line-modified"> 645     if (bounds.x() &gt; contentInset.width()) {</span>
<span class="line-modified"> 646         path.moveTo({ bounds.x(), bounds.y() });</span>
<span class="line-modified"> 647         path.addLineTo({ contentInset.width(), bounds.y() });</span>
<span class="line-modified"> 648 </span>
<span class="line-modified"> 649         path.moveTo({ bounds.x(), bounds.maxY() });</span>
<span class="line-modified"> 650         path.addLineTo({ contentInset.width(), bounds.maxY() });</span>
<span class="line-modified"> 651     }</span>
<span class="line-modified"> 652 </span>
<span class="line-modified"> 653     if (bounds.maxX() &lt; viewportSize.width()) {</span>
<span class="line-modified"> 654         path.moveTo({ bounds.maxX(), bounds.y() });</span>
<span class="line-modified"> 655         path.addLineTo({ viewportSize.width(), bounds.y() });</span>
<span class="line-modified"> 656 </span>
<span class="line-modified"> 657         path.moveTo({ bounds.maxX(), bounds.maxY() });</span>
<span class="line-modified"> 658         path.addLineTo({ viewportSize.width(), bounds.maxY() });</span>










 659     }
<span class="line-added"> 660 </span>
<span class="line-added"> 661     GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added"> 662 </span>
<span class="line-added"> 663     context.setStrokeThickness(1);</span>
<span class="line-added"> 664 </span>
<span class="line-added"> 665     const Color boundsColor(1.0f, 0.0f, 0.0f, 0.6f);</span>
<span class="line-added"> 666     context.setStrokeColor(boundsColor);</span>
<span class="line-added"> 667 </span>
<span class="line-added"> 668     context.strokePath(path);</span>
 669 }
 670 
<span class="line-modified"> 671 void InspectorOverlay::drawRulers(GraphicsContext&amp; context, const InspectorOverlay::RulerExclusion&amp; rulerExclusion)</span>
 672 {
<span class="line-modified"> 673     const Color rulerBackgroundColor(1.0f, 1.0f, 1.0f, 0.6f);</span>
<span class="line-modified"> 674     const Color lightRulerColor(0.0f, 0.0f, 0.0f, 0.2f);</span>
<span class="line-modified"> 675     const Color darkRulerColor(0.0f, 0.0f, 0.0f, 0.5f);</span>
<span class="line-added"> 676 </span>
<span class="line-added"> 677     IntPoint scrollOffset;</span>
<span class="line-added"> 678 </span>
<span class="line-added"> 679     FrameView* pageView = m_page.mainFrame().view();</span>
<span class="line-added"> 680     if (!pageView-&gt;delegatesScrolling())</span>
<span class="line-added"> 681         scrollOffset = pageView-&gt;visibleContentRect().location();</span>
<span class="line-added"> 682 </span>
<span class="line-added"> 683     FloatSize viewportSize = pageView-&gt;sizeForVisibleContent();</span>
<span class="line-added"> 684     FloatSize contentInset(0, pageView-&gt;topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset));</span>
<span class="line-added"> 685     float pageScaleFactor = m_page.pageScaleFactor();</span>
<span class="line-added"> 686     float pageZoomFactor = m_page.mainFrame().pageZoomFactor();</span>
<span class="line-added"> 687 </span>
<span class="line-added"> 688     float pageFactor = pageZoomFactor * pageScaleFactor;</span>
<span class="line-added"> 689     float scrollX = scrollOffset.x() * pageScaleFactor;</span>
<span class="line-added"> 690     float scrollY = scrollOffset.y() * pageScaleFactor;</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692     const auto zoom = [&amp;] (float value) -&gt; float {</span>
<span class="line-added"> 693         return value * pageFactor;</span>
<span class="line-added"> 694     };</span>
<span class="line-added"> 695 </span>
<span class="line-added"> 696     const auto unzoom = [&amp;] (float value) -&gt; float {</span>
<span class="line-added"> 697         return value / pageFactor;</span>
<span class="line-added"> 698     };</span>
<span class="line-added"> 699 </span>
<span class="line-added"> 700     const auto multipleBelow = [&amp;] (float value, float step) -&gt; float {</span>
<span class="line-added"> 701         return value - std::fmod(value, step);</span>
<span class="line-added"> 702     };</span>
<span class="line-added"> 703 </span>
<span class="line-added"> 704     float width = viewportSize.width() / pageFactor;</span>
<span class="line-added"> 705     float height = viewportSize.height() / pageFactor;</span>
<span class="line-added"> 706     float minX = unzoom(scrollX);</span>
<span class="line-added"> 707     float minY = unzoom(scrollY);</span>
<span class="line-added"> 708     float maxX = minX + width;</span>
<span class="line-added"> 709     float maxY = minY + height;</span>
<span class="line-added"> 710 </span>
<span class="line-added"> 711     bool drawTopEdge = true;</span>
<span class="line-added"> 712     bool drawLeftEdge = true;</span>
<span class="line-added"> 713 </span>
<span class="line-added"> 714     // Determine which side (top/bottom and left/right) to draw the rulers.</span>
<span class="line-added"> 715     {</span>
<span class="line-added"> 716         FloatRect topEdge(contentInset.width(), contentInset.height(), zoom(width) - contentInset.width(), rulerSize);</span>
<span class="line-added"> 717         FloatRect bottomEdge(contentInset.width(), zoom(height) - rulerSize, zoom(width) - contentInset.width(), rulerSize);</span>
<span class="line-added"> 718         drawTopEdge = !rulerExclusion.bounds.intersects(topEdge) || rulerExclusion.bounds.intersects(bottomEdge);</span>
<span class="line-added"> 719 </span>
<span class="line-added"> 720         FloatRect rightEdge(zoom(width) - rulerSize, contentInset.height(), rulerSize, zoom(height) - contentInset.height());</span>
<span class="line-added"> 721         FloatRect leftEdge(contentInset.width(), contentInset.height(), rulerSize, zoom(height) - contentInset.height());</span>
<span class="line-added"> 722         drawLeftEdge = !rulerExclusion.bounds.intersects(leftEdge) || rulerExclusion.bounds.intersects(rightEdge);</span>
<span class="line-added"> 723     }</span>
 724 
<span class="line-modified"> 725     float cornerX = drawLeftEdge ? contentInset.width() : zoom(width) - rulerSize;</span>
<span class="line-modified"> 726     float cornerY = drawTopEdge ? contentInset.height() : zoom(height) - rulerSize;</span>

 727 
<span class="line-modified"> 728     // Draw backgrounds.</span>
<span class="line-modified"> 729     {</span>
<span class="line-modified"> 730         GraphicsContextStateSaver backgroundStateSaver(context);</span>
 731 
<span class="line-modified"> 732         context.setFillColor(rulerBackgroundColor);</span>

 733 
<span class="line-modified"> 734         context.fillRect({ cornerX, cornerY, rulerSize, rulerSize });</span>
<span class="line-modified"> 735 </span>
<span class="line-modified"> 736         if (drawLeftEdge)</span>
<span class="line-modified"> 737             context.fillRect({ cornerX + rulerSize, cornerY, zoom(width) - cornerX - rulerSize, rulerSize });</span>
<span class="line-modified"> 738         else</span>
<span class="line-modified"> 739             context.fillRect({ contentInset.width(), cornerY, cornerX - contentInset.width(), rulerSize });</span>
<span class="line-modified"> 740 </span>
<span class="line-modified"> 741         if (drawTopEdge)</span>
<span class="line-modified"> 742             context.fillRect({ cornerX, cornerY + rulerSize, rulerSize, zoom(height) - cornerY - rulerSize });</span>
<span class="line-modified"> 743         else</span>
<span class="line-modified"> 744             context.fillRect({ cornerX, contentInset.height(), rulerSize, cornerY - contentInset.height() });</span>
<span class="line-modified"> 745     }</span>
<span class="line-added"> 746 </span>
<span class="line-added"> 747     // Draw lines.</span>
<span class="line-added"> 748     {</span>
<span class="line-added"> 749         FontCascadeDescription fontDescription;</span>
<span class="line-added"> 750         fontDescription.setOneFamily(m_page.settings().sansSerifFontFamily());</span>
<span class="line-added"> 751         fontDescription.setComputedSize(10);</span>
<span class="line-added"> 752 </span>
<span class="line-added"> 753         FontCascade font(WTFMove(fontDescription), 0, 0);</span>
<span class="line-added"> 754         font.update(nullptr);</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756         GraphicsContextStateSaver lineStateSaver(context);</span>
<span class="line-added"> 757 </span>
<span class="line-added"> 758         context.setFillColor(darkRulerColor);</span>
<span class="line-added"> 759         context.setStrokeThickness(1);</span>
<span class="line-added"> 760 </span>
<span class="line-added"> 761         // Draw horizontal ruler.</span>
<span class="line-added"> 762         {</span>
<span class="line-added"> 763             GraphicsContextStateSaver horizontalRulerStateSaver(context);</span>
<span class="line-added"> 764 </span>
<span class="line-added"> 765             context.translate(contentInset.width() - scrollX + 0.5f, cornerY - scrollY);</span>
<span class="line-added"> 766 </span>
<span class="line-added"> 767             for (float x = multipleBelow(minX, rulerSubStepIncrement); x &lt; maxX; x += rulerSubStepIncrement) {</span>
<span class="line-added"> 768                 if (!x &amp;&amp; !scrollX)</span>
<span class="line-added"> 769                     continue;</span>
<span class="line-added"> 770 </span>
<span class="line-added"> 771                 Path path;</span>
<span class="line-added"> 772                 path.moveTo({ zoom(x), drawTopEdge ? scrollY : scrollY + rulerSize });</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774                 float lineLength = 0.0f;</span>
<span class="line-added"> 775                 if (std::fmod(x, rulerStepIncrement)) {</span>
<span class="line-added"> 776                     lineLength = rulerSubStepLength;</span>
<span class="line-added"> 777                     context.setStrokeColor(lightRulerColor);</span>
<span class="line-added"> 778                 } else {</span>
<span class="line-added"> 779                     lineLength = std::fmod(x, rulerStepIncrement * 2) ? rulerSubStepLength : rulerStepLength;</span>
<span class="line-added"> 780                     context.setStrokeColor(darkRulerColor);</span>
<span class="line-added"> 781                 }</span>
<span class="line-added"> 782                 path.addLineTo({ zoom(x), scrollY + (drawTopEdge ? lineLength : rulerSize - lineLength) });</span>
 783 
<span class="line-modified"> 784                 context.strokePath(path);</span>
<span class="line-added"> 785             }</span>
 786 
<span class="line-modified"> 787             // Draw labels.</span>
<span class="line-modified"> 788             for (float x = multipleBelow(minX, rulerStepIncrement * 2); x &lt; maxX; x += rulerStepIncrement * 2) {</span>
<span class="line-modified"> 789                 if (!x &amp;&amp; !scrollX)</span>
<span class="line-added"> 790                     continue;</span>
 791 
<span class="line-modified"> 792                 GraphicsContextStateSaver verticalLabelStateSaver(context);</span>
<span class="line-modified"> 793                 context.translate(zoom(x) + 0.5f, scrollY);</span>
<span class="line-modified"> 794                 context.drawText(font, TextRun(String::numberToStringFixedPrecision(x)), { 2, drawTopEdge ? rulerLabelSize : rulerLabelSize - rulerSize + font.fontMetrics().height() - 1.0f });</span>
<span class="line-added"> 795             }</span>
<span class="line-added"> 796         }</span>
 797 
<span class="line-modified"> 798         // Draw vertical ruler.</span>
<span class="line-added"> 799         {</span>
<span class="line-added"> 800             GraphicsContextStateSaver veritcalRulerStateSaver(context);</span>
<span class="line-added"> 801 </span>
<span class="line-added"> 802             context.translate(cornerX - scrollX, contentInset.height() - scrollY + 0.5f);</span>
<span class="line-added"> 803 </span>
<span class="line-added"> 804             for (float y = multipleBelow(minY, rulerSubStepIncrement); y &lt; maxY; y += rulerSubStepIncrement) {</span>
<span class="line-added"> 805                 if (!y &amp;&amp; !scrollY)</span>
<span class="line-added"> 806                     continue;</span>
<span class="line-added"> 807 </span>
<span class="line-added"> 808                 Path path;</span>
<span class="line-added"> 809                 path.moveTo({ drawLeftEdge ? scrollX : scrollX + rulerSize, zoom(y) });</span>
<span class="line-added"> 810 </span>
<span class="line-added"> 811                 float lineLength = 0.0f;</span>
<span class="line-added"> 812                 if (std::fmod(y, rulerStepIncrement)) {</span>
<span class="line-added"> 813                     lineLength = rulerSubStepLength;</span>
<span class="line-added"> 814                     context.setStrokeColor(lightRulerColor);</span>
<span class="line-added"> 815                 } else {</span>
<span class="line-added"> 816                     lineLength = std::fmod(y, rulerStepIncrement * 2) ? rulerSubStepLength : rulerStepLength;</span>
<span class="line-added"> 817                     context.setStrokeColor(darkRulerColor);</span>
<span class="line-added"> 818                 }</span>
<span class="line-added"> 819                 path.addLineTo({ scrollX + (drawLeftEdge ? lineLength : rulerSize - lineLength), zoom(y) });</span>
<span class="line-added"> 820 </span>
<span class="line-added"> 821                 context.strokePath(path);</span>
<span class="line-added"> 822             }</span>
<span class="line-added"> 823 </span>
<span class="line-added"> 824             // Draw labels.</span>
<span class="line-added"> 825             for (float y = multipleBelow(minY, rulerStepIncrement * 2); y &lt; maxY; y += rulerStepIncrement * 2) {</span>
<span class="line-added"> 826                 if (!y &amp;&amp; !scrollY)</span>
<span class="line-added"> 827                     continue;</span>
<span class="line-added"> 828 </span>
<span class="line-added"> 829                 GraphicsContextStateSaver horizontalLabelStateSaver(context);</span>
<span class="line-added"> 830                 context.translate(scrollX, zoom(y) + 0.5f);</span>
<span class="line-added"> 831                 context.rotate(drawLeftEdge ? -piOverTwoFloat : piOverTwoFloat);</span>
<span class="line-added"> 832                 context.drawText(font, TextRun(String::numberToStringFixedPrecision(y)), { 2, drawLeftEdge ? rulerLabelSize : rulerLabelSize - rulerSize });</span>
<span class="line-added"> 833             }</span>
 834         }
 835     }
 836 
<span class="line-modified"> 837     // Draw viewport size.</span>
<span class="line-added"> 838     {</span>
<span class="line-added"> 839         FontCascadeDescription fontDescription;</span>
<span class="line-added"> 840         fontDescription.setOneFamily(m_page.settings().sansSerifFontFamily());</span>
<span class="line-added"> 841         fontDescription.setComputedSize(12);</span>
<span class="line-added"> 842 </span>
<span class="line-added"> 843         FontCascade font(WTFMove(fontDescription), 0, 0);</span>
<span class="line-added"> 844         font.update(nullptr);</span>
<span class="line-added"> 845 </span>
<span class="line-added"> 846         auto viewportRect = pageView-&gt;visualViewportRect();</span>
<span class="line-added"> 847         auto viewportWidthText = String::numberToStringFixedPrecision(viewportRect.width() / pageZoomFactor);</span>
<span class="line-added"> 848         auto viewportHeightText = String::numberToStringFixedPrecision(viewportRect.height() / pageZoomFactor);</span>
<span class="line-added"> 849         TextRun viewportTextRun(makeString(viewportWidthText, &quot;px&quot;, &#39; &#39;, multiplicationSign, &#39; &#39;, viewportHeightText, &quot;px&quot;));</span>
<span class="line-added"> 850 </span>
<span class="line-added"> 851         const float margin = 4;</span>
<span class="line-added"> 852         const float padding = 2;</span>
<span class="line-added"> 853         const float radius = 4;</span>
<span class="line-added"> 854         float fontWidth = font.width(viewportTextRun);</span>
<span class="line-added"> 855         float fontHeight = font.fontMetrics().floatHeight();</span>
<span class="line-added"> 856         FloatRect viewportTextRect(margin, margin, (padding * 2.0f) + fontWidth, (padding * 2.0f) + fontHeight);</span>
<span class="line-added"> 857         const auto viewportTextRectCenter = viewportTextRect.center();</span>
<span class="line-added"> 858 </span>
<span class="line-added"> 859         GraphicsContextStateSaver viewportSizeStateSaver(context);</span>
<span class="line-added"> 860 </span>
<span class="line-added"> 861         float leftTranslateX = rulerSize;</span>
<span class="line-added"> 862         float rightTranslateX = 0.0f - (margin * 2.0f) - (padding * 2.0f) - fontWidth;</span>
<span class="line-added"> 863         float translateX = cornerX + (drawLeftEdge ? leftTranslateX : rightTranslateX);</span>
<span class="line-added"> 864 </span>
<span class="line-added"> 865         float topTranslateY = rulerSize;</span>
<span class="line-added"> 866         float bottomTranslateY = 0.0f - (margin * 2.0f) - (padding * 2.0f) - fontHeight;</span>
<span class="line-added"> 867         float translateY = cornerY + (drawTopEdge ? topTranslateY : bottomTranslateY);</span>
<span class="line-added"> 868 </span>
<span class="line-added"> 869         FloatPoint translate(translateX, translateY);</span>
<span class="line-added"> 870         if (rulerExclusion.titlePath.contains(viewportTextRectCenter + translate)) {</span>
<span class="line-added"> 871             // Try the opposite horizontal side.</span>
<span class="line-added"> 872             float oppositeTranslateX = drawLeftEdge ? zoom(width) + rightTranslateX : contentInset.width() + leftTranslateX;</span>
<span class="line-added"> 873             translate.setX(oppositeTranslateX);</span>
<span class="line-added"> 874 </span>
<span class="line-added"> 875             if (rulerExclusion.titlePath.contains(viewportTextRectCenter + translate)) {</span>
<span class="line-added"> 876                 translate.setX(translateX);</span>
<span class="line-added"> 877 </span>
<span class="line-added"> 878                 // Try the opposite vertical side.</span>
<span class="line-added"> 879                 float oppositeTranslateY = drawTopEdge ? zoom(height) + bottomTranslateY : contentInset.height() + topTranslateY;</span>
<span class="line-added"> 880                 translate.setY(oppositeTranslateY);</span>
<span class="line-added"> 881 </span>
<span class="line-added"> 882                 if (rulerExclusion.titlePath.contains(viewportTextRectCenter + translate)) {</span>
<span class="line-added"> 883                     // Try the opposite corner.</span>
<span class="line-added"> 884                     translate.setX(oppositeTranslateX);</span>
<span class="line-added"> 885                 }</span>
<span class="line-added"> 886             }</span>
<span class="line-added"> 887         }</span>
<span class="line-added"> 888         context.translate(translate);</span>
<span class="line-added"> 889 </span>
<span class="line-added"> 890         context.fillRoundedRect(FloatRoundedRect(viewportTextRect, FloatRoundedRect::Radii(radius)), rulerBackgroundColor);</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892         context.setFillColor(Color::black);</span>
<span class="line-added"> 893         context.drawText(font, viewportTextRun, {margin +  padding, margin + padding + fontHeight - font.fontMetrics().descent() });</span>
<span class="line-added"> 894     }</span>
 895 }
 896 
<span class="line-modified"> 897 Path InspectorOverlay::drawElementTitle(GraphicsContext&amp; context, Node&amp; node, const Highlight::Bounds&amp; bounds)</span>
 898 {
<span class="line-modified"> 899     if (bounds.isEmpty())</span>
<span class="line-modified"> 900         return { };</span>
 901 
<span class="line-modified"> 902     Element* element = effectiveElementForNode(node);</span>
<span class="line-modified"> 903     if (!element)</span>
<span class="line-modified"> 904         return { };</span>




 905 
<span class="line-modified"> 906     RenderObject* renderer = node.renderer();</span>
<span class="line-modified"> 907     if (!renderer)</span>
<span class="line-modified"> 908         return { };</span>
<span class="line-modified"> 909 </span>
<span class="line-modified"> 910     String elementTagName = element-&gt;nodeName();</span>
<span class="line-modified"> 911     if (!element-&gt;document().isXHTMLDocument())</span>
<span class="line-modified"> 912         elementTagName = elementTagName.convertToASCIILowercase();</span>
<span class="line-modified"> 913 </span>
<span class="line-modified"> 914     String elementIDValue;</span>
<span class="line-modified"> 915     if (element-&gt;hasID())</span>
<span class="line-modified"> 916         elementIDValue = makeString(&#39;#&#39;, DOMCSSNamespace::escape(element-&gt;getIdAttribute()));</span>
<span class="line-modified"> 917 </span>
<span class="line-modified"> 918     String elementClassValue;</span>
<span class="line-modified"> 919     if (element-&gt;hasClass()) {</span>
<span class="line-modified"> 920         StringBuilder builder;</span>
<span class="line-modified"> 921         DOMTokenList&amp; classList = element-&gt;classList();</span>
<span class="line-modified"> 922         for (size_t i = 0; i &lt; classList.length(); ++i) {</span>
<span class="line-modified"> 923             builder.append(&#39;.&#39;);</span>
<span class="line-added"> 924             builder.append(DOMCSSNamespace::escape(classList.item(i)));</span>
 925         }


 926 
<span class="line-modified"> 927         elementClassValue = builder.toString();</span>
<span class="line-modified"> 928         truncateWithEllipsis(elementClassValue, 50);</span>



 929     }
 930 
<span class="line-modified"> 931     String elementPseudoType;</span>
<span class="line-modified"> 932     if (node.isBeforePseudoElement())</span>
<span class="line-modified"> 933         elementPseudoType = &quot;::before&quot;_s;</span>
<span class="line-modified"> 934     else if (node.isAfterPseudoElement())</span>
<span class="line-modified"> 935         elementPseudoType = &quot;::after&quot;_s;</span>
<span class="line-modified"> 936 </span>
<span class="line-modified"> 937     String elementWidth;</span>
<span class="line-modified"> 938     String elementHeight;</span>
<span class="line-modified"> 939     if (is&lt;RenderBoxModelObject&gt;(renderer)) {</span>
<span class="line-modified"> 940         RenderBoxModelObject* modelObject = downcast&lt;RenderBoxModelObject&gt;(renderer);</span>
<span class="line-modified"> 941         elementWidth = String::number(adjustForAbsoluteZoom(roundToInt(modelObject-&gt;offsetWidth()), *modelObject));</span>
<span class="line-modified"> 942         elementHeight = String::number(adjustForAbsoluteZoom(roundToInt(modelObject-&gt;offsetHeight()), *modelObject));</span>
<span class="line-modified"> 943     } else {</span>
<span class="line-modified"> 944         FrameView* containingView = node.document().frame()-&gt;view();</span>
<span class="line-modified"> 945         IntRect boundingBox = snappedIntRect(containingView-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect()));</span>
<span class="line-modified"> 946         elementWidth = String::number(boundingBox.width());</span>
<span class="line-modified"> 947         elementHeight = String::number(boundingBox.height());</span>

 948     }
 949 
 950     // Need to enable AX to get the computed role.
 951     if (!WebCore::AXObjectCache::accessibilityEnabled())
 952         WebCore::AXObjectCache::enableAccessibility();
 953 
<span class="line-modified"> 954     String elementRole;</span>
<span class="line-modified"> 955     if (AXObjectCache* axObjectCache = node.document().axObjectCache()) {</span>
<span class="line-modified"> 956         if (AccessibilityObject* axObject = axObjectCache-&gt;getOrCreate(&amp;node))</span>
<span class="line-added"> 957             elementRole = axObject-&gt;computedRoleString();</span>
 958     }
 959 
<span class="line-modified"> 960     FontCascadeDescription fontDescription;</span>
<span class="line-modified"> 961     fontDescription.setFamilies({ &quot;Menlo&quot;, m_page.settings().fixedFontFamily() });</span>
<span class="line-added"> 962     fontDescription.setComputedSize(11);</span>
 963 
<span class="line-modified"> 964     FontCascade font(WTFMove(fontDescription), 0, 0);</span>
<span class="line-modified"> 965     font.update(nullptr);</span>


 966 
<span class="line-modified"> 967     int fontHeight = font.fontMetrics().height();</span>


 968 
<span class="line-modified"> 969     float elementDataWidth;</span>
<span class="line-modified"> 970     float elementDataHeight = fontHeight;</span>
<span class="line-modified"> 971     bool hasSecondLine = !elementRole.isEmpty();</span>
 972 
<span class="line-modified"> 973     {</span>
<span class="line-modified"> 974         String firstLine = makeString(elementTagName, elementIDValue, elementClassValue, elementPseudoType, &#39; &#39;, elementWidth, &quot;px&quot;, &#39; &#39;, multiplicationSign, &#39; &#39;, elementHeight, &quot;px&quot;);</span>
<span class="line-added"> 975         String secondLine = makeString(&quot;Role &quot;, elementRole);</span>
 976 
<span class="line-modified"> 977         float firstLineWidth = font.width(TextRun(firstLine));</span>
<span class="line-modified"> 978         float secondLineWidth = font.width(TextRun(secondLine));</span>


 979 
<span class="line-modified"> 980         elementDataWidth = std::fmax(firstLineWidth, secondLineWidth);</span>
<span class="line-modified"> 981         if (hasSecondLine)</span>
<span class="line-modified"> 982             elementDataHeight += fontHeight;</span>
 983     }
 984 
<span class="line-modified"> 985     FrameView* pageView = m_page.mainFrame().view();</span>

 986 
<span class="line-modified"> 987     FloatSize viewportSize = pageView-&gt;sizeForVisibleContent();</span>
<span class="line-modified"> 988     viewportSize.expand(-elementDataSpacing, -elementDataSpacing);</span>

 989 
<span class="line-modified"> 990     FloatSize contentInset(0, pageView-&gt;topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset));</span>
<span class="line-modified"> 991     contentInset.expand(elementDataSpacing, elementDataSpacing);</span>
<span class="line-modified"> 992     if (m_showRulers || m_showRulersDuringElementSelection)</span>
<span class="line-modified"> 993         contentInset.expand(rulerSize, rulerSize);</span>
<span class="line-modified"> 994 </span>
<span class="line-modified"> 995     float anchorTop = bounds.y();</span>
<span class="line-modified"> 996     float anchorBottom = bounds.maxY();</span>
<span class="line-modified"> 997 </span>
<span class="line-added"> 998     bool renderArrowUp = false;</span>
<span class="line-added"> 999     bool renderArrowDown = false;</span>
<span class="line-added">1000 </span>
<span class="line-added">1001     float boxWidth = elementDataWidth + (elementDataSpacing * 2);</span>
<span class="line-added">1002     float boxHeight = elementDataArrowSize + elementDataHeight + (elementDataSpacing * 2);</span>
<span class="line-added">1003 </span>
<span class="line-added">1004     float boxX = bounds.x();</span>
<span class="line-added">1005     if (boxX &lt; contentInset.width())</span>
<span class="line-added">1006         boxX = contentInset.width();</span>
<span class="line-added">1007     else if (boxX &gt; viewportSize.width() - boxWidth)</span>
<span class="line-added">1008         boxX = viewportSize.width() - boxWidth;</span>
<span class="line-added">1009     else</span>
<span class="line-added">1010         boxX += elementDataSpacing;</span>
<span class="line-added">1011 </span>
<span class="line-added">1012     float boxY;</span>
<span class="line-added">1013     if (anchorTop &gt; viewportSize.height()) {</span>
<span class="line-added">1014         boxY = viewportSize.height() - boxHeight;</span>
<span class="line-added">1015         renderArrowDown = true;</span>
<span class="line-added">1016     } else if (anchorBottom &lt; contentInset.height()) {</span>
<span class="line-added">1017         boxY = contentInset.height() + elementDataArrowSize;</span>
<span class="line-added">1018         renderArrowUp = true;</span>
<span class="line-added">1019     } else if (anchorTop - boxHeight - elementDataSpacing &gt; contentInset.height()) {</span>
<span class="line-added">1020         boxY = anchorTop - boxHeight - elementDataSpacing;</span>
<span class="line-added">1021         renderArrowDown = true;</span>
<span class="line-added">1022     } else if (anchorBottom + boxHeight + elementDataSpacing &lt; viewportSize.height()) {</span>
<span class="line-added">1023         boxY = anchorBottom + elementDataArrowSize + elementDataSpacing;</span>
<span class="line-added">1024         renderArrowUp = true;</span>
<span class="line-added">1025     } else {</span>
<span class="line-added">1026         boxY = contentInset.height();</span>
<span class="line-added">1027         renderArrowDown = true;</span>
1028     }
1029 
<span class="line-modified">1030     Path path;</span>
<span class="line-modified">1031     path.moveTo({ boxX, boxY });</span>
<span class="line-added">1032     if (renderArrowUp) {</span>
<span class="line-added">1033         path.addLineTo({ boxX + (elementDataArrowSize * 2), boxY });</span>
<span class="line-added">1034         path.addLineTo({ boxX + (elementDataArrowSize * 3), boxY - elementDataArrowSize });</span>
<span class="line-added">1035         path.addLineTo({ boxX + (elementDataArrowSize * 4), boxY });</span>
<span class="line-added">1036     }</span>
<span class="line-added">1037     path.addLineTo({ boxX + elementDataWidth + (elementDataSpacing * 2), boxY });</span>
<span class="line-added">1038     path.addLineTo({ boxX + elementDataWidth + (elementDataSpacing * 2), boxY + elementDataHeight + (elementDataSpacing * 2) });</span>
<span class="line-added">1039     if (renderArrowDown) {</span>
<span class="line-added">1040         path.addLineTo({ boxX + (elementDataArrowSize * 4), boxY + elementDataHeight + (elementDataSpacing * 2) });</span>
<span class="line-added">1041         path.addLineTo({ boxX + (elementDataArrowSize * 3), boxY + elementDataHeight + (elementDataSpacing * 2) + elementDataArrowSize });</span>
<span class="line-added">1042         path.addLineTo({ boxX + (elementDataArrowSize * 2), boxY + elementDataHeight + (elementDataSpacing * 2) });</span>
<span class="line-added">1043     }</span>
<span class="line-added">1044     path.addLineTo({ boxX, boxY + elementDataHeight + (elementDataSpacing * 2) });</span>
<span class="line-added">1045     path.closeSubpath();</span>
1046 
<span class="line-modified">1047     GraphicsContextStateSaver stateSaver(context);</span>




1048 
<span class="line-modified">1049     context.translate(elementDataBorderSize / 2.0f, elementDataBorderSize / 2.0f);</span>



1050 
<span class="line-modified">1051     const Color elementTitleBackgroundColor(255, 255, 194);</span>
<span class="line-modified">1052     context.setFillColor(elementTitleBackgroundColor);</span>


































































1053 
<span class="line-modified">1054     context.fillPath(path);</span>












1055 
<span class="line-modified">1056     context.setStrokeThickness(elementDataBorderSize);</span>



1057 
<span class="line-modified">1058     const Color elementTitleBorderColor(128, 128, 128);</span>
<span class="line-modified">1059     context.setStrokeColor(elementTitleBorderColor);</span>
1060 
<span class="line-modified">1061     context.strokePath(path);</span>



1062 
<span class="line-modified">1063     float textPositionX = boxX + elementDataSpacing;</span>
<span class="line-modified">1064     float textPositionY = boxY - (elementDataSpacing / 2.0f) + fontHeight;</span>
<span class="line-added">1065     const auto drawText = [&amp;] (const String&amp; text, const Color&amp; color) {</span>
<span class="line-added">1066         if (text.isEmpty())</span>
<span class="line-added">1067             return;</span>
1068 
<span class="line-modified">1069         context.setFillColor(color);</span>
<span class="line-modified">1070         textPositionX += context.drawText(font, TextRun(text), { textPositionX, textPositionY });</span>
<span class="line-modified">1071     };</span>


1072 
<span class="line-modified">1073     drawText(elementTagName, Color(136, 18, 128)); // Keep this in sync with XMLViewer.css (.tag)</span>
<span class="line-modified">1074     drawText(elementIDValue, Color(26, 26, 166)); // Keep this in sync with XMLViewer.css (.attribute-value)</span>
<span class="line-added">1075     drawText(elementClassValue, Color(153, 69, 0)); // Keep this in sync with XMLViewer.css (.attribute-name)</span>
<span class="line-added">1076     drawText(elementPseudoType, Color(136, 18, 128)); // Keep this in sync with XMLViewer.css (.tag)</span>
<span class="line-added">1077     drawText(&quot; &quot;_s, Color::black);</span>
<span class="line-added">1078     drawText(elementWidth, Color::black);</span>
<span class="line-added">1079     drawText(&quot;px&quot;_s, Color::darkGray);</span>
<span class="line-added">1080     drawText(&quot; &quot;_s, Color::darkGray);</span>
<span class="line-added">1081     drawText(makeString(multiplicationSign), Color::darkGray);</span>
<span class="line-added">1082     drawText(&quot; &quot;_s, Color::darkGray);</span>
<span class="line-added">1083     drawText(elementHeight, Color::black);</span>
<span class="line-added">1084     drawText(&quot;px&quot;_s, Color::darkGray);</span>
1085 
<span class="line-modified">1086     if (hasSecondLine) {</span>
<span class="line-modified">1087         textPositionX = boxX + elementDataSpacing;</span>
<span class="line-modified">1088         textPositionY += fontHeight;</span>


1089 
<span class="line-modified">1090         drawText(&quot;Role&quot;_s, Color(170, 13, 145));</span>
<span class="line-modified">1091         drawText(&quot; &quot;_s, Color::black);</span>
<span class="line-added">1092         drawText(elementRole, Color::black);</span>
<span class="line-added">1093     }</span>
1094 
<span class="line-modified">1095     return path;</span>


1096 }
1097 
1098 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="InspectorNodeFinder.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorOverlay.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>