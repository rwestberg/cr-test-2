<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGAbstractInterpreter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGAbstractValue.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  26 #pragma once
  27 
  28 #if ENABLE(DFG_JIT)
  29 
  30 #include &quot;ArrayConstructor.h&quot;
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;DFGAbstractInterpreter.h&quot;
  33 #include &quot;DFGAbstractInterpreterClobberState.h&quot;
  34 #include &quot;DOMJITGetterSetter.h&quot;
  35 #include &quot;DOMJITSignature.h&quot;
  36 #include &quot;GetByIdStatus.h&quot;
  37 #include &quot;GetterSetter.h&quot;
  38 #include &quot;HashMapImpl.h&quot;
  39 #include &quot;JITOperations.h&quot;
  40 #include &quot;JSImmutableButterfly.h&quot;
  41 #include &quot;MathCommon.h&quot;
  42 #include &quot;NumberConstructor.h&quot;
  43 #include &quot;Operations.h&quot;
  44 #include &quot;PutByIdStatus.h&quot;
  45 #include &quot;StringObject.h&quot;

  46 #include &quot;StructureRareDataInlines.h&quot;
  47 #include &lt;wtf/BooleanLattice.h&gt;
  48 #include &lt;wtf/CheckedArithmetic.h&gt;
  49 
  50 namespace JSC { namespace DFG {
  51 
  52 template&lt;typename AbstractStateType&gt;
  53 AbstractInterpreter&lt;AbstractStateType&gt;::AbstractInterpreter(Graph&amp; graph, AbstractStateType&amp; state)
  54     : m_codeBlock(graph.m_codeBlock)
  55     , m_graph(graph)
  56     , m_vm(m_graph.m_vm)
  57     , m_state(state)
  58 {
  59     if (m_graph.m_form == SSA)
<span class="line-modified">  60         m_phiChildren = std::make_unique&lt;PhiChildren&gt;(m_graph);</span>
  61 }
  62 
  63 template&lt;typename AbstractStateType&gt;
  64 AbstractInterpreter&lt;AbstractStateType&gt;::~AbstractInterpreter()
  65 {
  66 }
  67 
  68 template&lt;typename AbstractStateType&gt;
  69 typename AbstractInterpreter&lt;AbstractStateType&gt;::BooleanResult
  70 AbstractInterpreter&lt;AbstractStateType&gt;::booleanResult(
  71     Node* node, AbstractValue&amp; value)
  72 {
  73     JSValue childConst = value.value();
  74     if (childConst) {
  75         if (childConst.toBoolean(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;globalExec()))
  76             return DefinitelyTrue;
  77         return DefinitelyFalse;
  78     }
  79 
  80     // Next check if we can fold because we know that the source is an object or string and does not equal undefined.
</pre>
<hr />
<pre>
 215             // 1) We are in strict mode and strings/symbols are not wrapped
 216             // 2) The AI has proven that the type of this is a subtype of object
 217             if (type.isObject() &amp;&amp; type.overridesToThis())
 218                 overridesToThis = true;
 219 
 220             // If all the structures are JSScope&#39;s ones, we know the details of JSScope::toThis() operation.
 221             allStructuresAreJSScope &amp;= structure-&gt;classInfo()-&gt;methodTable.toThis == JSScope::info()-&gt;methodTable.toThis;
 222         });
 223         if (!overridesToThis)
 224             return ToThisResult::Identity;
 225         if (allStructuresAreJSScope) {
 226             if (isStrictMode)
 227                 return ToThisResult::Undefined;
 228             return ToThisResult::GlobalThis;
 229         }
 230     }
 231 
 232     return ToThisResult::Dynamic;
 233 }
 234 
































































































 235 template&lt;typename AbstractStateType&gt;
 236 bool AbstractInterpreter&lt;AbstractStateType&gt;::executeEffects(unsigned clobberLimit, Node* node)
 237 {
 238     verifyEdges(node);
 239 
 240     m_state.createValueForNode(node);
 241 
 242     switch (node-&gt;op()) {
 243     case JSConstant:
 244     case DoubleConstant:
 245     case Int52Constant: {
 246         setBuiltInConstant(node, *node-&gt;constant());
 247         break;
 248     }
 249 
 250     case LazyJSConstant: {
 251         LazyJSValue value = node-&gt;lazyJSValue();
 252         switch (value.kind()) {
 253         case LazyJSValue::KnownValue:
 254             setConstant(node, value.value()-&gt;value());
</pre>
<hr />
<pre>
 304     }
 305 
 306     case PutStack: {
 307         m_state.operand(node-&gt;stackAccessData()-&gt;local) = forNode(node-&gt;child1());
 308         break;
 309     }
 310 
 311     case MovHint: {
 312         // Don&#39;t need to do anything. A MovHint only informs us about what would have happened
 313         // in bytecode, but this code is just concerned with what is actually happening during
 314         // DFG execution.
 315         break;
 316     }
 317 
 318     case KillStack: {
 319         // This is just a hint telling us that the OSR state of the local is no longer inside the
 320         // flushed data.
 321         break;
 322     }
 323 
<span class="line-modified"> 324     case SetArgument:</span>
<span class="line-modified"> 325         // Assert that the state of arguments has been set. SetArgument means that someone set</span>
<span class="line-modified"> 326         // the argument values out-of-band, and currently this always means setting to a</span>

 327         // non-clear value.
 328         ASSERT(!m_state.operand(node-&gt;local()).isClear());
 329         break;
 330 
 331     case InitializeEntrypointArguments: {
 332         unsigned entrypointIndex = node-&gt;entrypointIndex();
 333         const Vector&lt;FlushFormat&gt;&amp; argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
 334         for (unsigned argument = 0; argument &lt; argumentFormats.size(); ++argument) {
 335             AbstractValue&amp; value = m_state.argument(argument);
 336             switch (argumentFormats[argument]) {
 337             case FlushedInt32:
 338                 value.setNonCellType(SpecInt32Only);
 339                 break;
 340             case FlushedBoolean:
 341                 value.setNonCellType(SpecBoolean);
 342                 break;
 343             case FlushedCell:
 344                 value.setType(m_graph, SpecCellCheck);
 345                 break;
 346             case FlushedJSValue:
</pre>
<hr />
<pre>
 359         // FIXME: ForwardVarargs should check if the count becomes known, and if it does, it should turn
 360         // itself into a straight-line sequence of GetStack/PutStack.
 361         // https://bugs.webkit.org/show_bug.cgi?id=143071
 362         switch (node-&gt;op()) {
 363         case LoadVarargs:
 364             clobberWorld();
 365             break;
 366         case ForwardVarargs:
 367             break;
 368         default:
 369             DFG_CRASH(m_graph, node, &quot;Bad opcode&quot;);
 370             break;
 371         }
 372         LoadVarargsData* data = node-&gt;loadVarargsData();
 373         m_state.operand(data-&gt;count).setNonCellType(SpecInt32Only);
 374         for (unsigned i = data-&gt;limit - 1; i--;)
 375             m_state.operand(data-&gt;start.offset() + i).makeHeapTop();
 376         break;
 377     }
 378 
<span class="line-modified"> 379     case ArithBitNot: {</span>
<span class="line-modified"> 380         if (node-&gt;child1().useKind() == UntypedUse) {</span>
<span class="line-modified"> 381             clobberWorld();</span>
<span class="line-modified"> 382             setNonCellTypeForNode(node, SpecInt32Only);</span>


 383             break;
 384         }
 385 











 386         JSValue operand = forNode(node-&gt;child1()).value();
 387         if (operand &amp;&amp; operand.isInt32()) {
 388             int32_t a = operand.asInt32();
 389             setConstant(node, JSValue(~a));
 390             break;
 391         }
 392 
 393         setNonCellTypeForNode(node, SpecInt32Only);
 394         break;
 395     }
 396 
 397     case ValueBitXor:
 398     case ValueBitAnd:
 399     case ValueBitOr:




 400         if (node-&gt;binaryUseKind() == BigIntUse)
 401             setTypeForNode(node, SpecBigInt);
 402         else {
 403             clobberWorld();
<span class="line-modified"> 404             setTypeForNode(node, SpecBoolInt32 | SpecBigInt);</span>
 405         }
 406         break;

 407 
 408     case ArithBitAnd:
 409     case ArithBitOr:
 410     case ArithBitXor:
 411     case BitRShift:
<span class="line-modified"> 412     case BitLShift:</span>
 413     case BitURShift: {
 414         if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
 415             clobberWorld();
 416             setNonCellTypeForNode(node, SpecInt32Only);
 417             break;
 418         }
 419 
<span class="line-modified"> 420         JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="line-removed"> 421         JSValue right = forNode(node-&gt;child2()).value();</span>
<span class="line-removed"> 422         if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="line-removed"> 423             int32_t a = left.asInt32();</span>
<span class="line-removed"> 424             int32_t b = right.asInt32();</span>
<span class="line-removed"> 425             switch (node-&gt;op()) {</span>
<span class="line-removed"> 426             case ArithBitAnd:</span>
<span class="line-removed"> 427                 setConstant(node, JSValue(a &amp; b));</span>
<span class="line-removed"> 428                 break;</span>
<span class="line-removed"> 429             case ArithBitOr:</span>
<span class="line-removed"> 430                 setConstant(node, JSValue(a | b));</span>
<span class="line-removed"> 431                 break;</span>
<span class="line-removed"> 432             case ArithBitXor:</span>
<span class="line-removed"> 433                 setConstant(node, JSValue(a ^ b));</span>
<span class="line-removed"> 434                 break;</span>
<span class="line-removed"> 435             case BitRShift:</span>
<span class="line-removed"> 436                 setConstant(node, JSValue(a &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));</span>
<span class="line-removed"> 437                 break;</span>
<span class="line-removed"> 438             case BitLShift:</span>
<span class="line-removed"> 439                 setConstant(node, JSValue(a &lt;&lt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));</span>
<span class="line-removed"> 440                 break;</span>
<span class="line-removed"> 441             case BitURShift:</span>
<span class="line-removed"> 442                 setConstant(node, JSValue(static_cast&lt;int32_t&gt;(static_cast&lt;uint32_t&gt;(a) &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f))));</span>
<span class="line-removed"> 443                 break;</span>
<span class="line-removed"> 444             default:</span>
<span class="line-removed"> 445                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 446                 break;</span>
<span class="line-removed"> 447             }</span>
 448             break;
<span class="line-removed"> 449         }</span>
 450 
 451         if (node-&gt;op() == ArithBitAnd
 452             &amp;&amp; (isBoolInt32Speculation(forNode(node-&gt;child1()).m_type) ||
 453                 isBoolInt32Speculation(forNode(node-&gt;child2()).m_type))) {
 454             setNonCellTypeForNode(node, SpecBoolInt32);
 455             break;
 456         }
 457 
 458         setNonCellTypeForNode(node, SpecInt32Only);
 459         break;
 460     }
 461 
 462     case UInt32ToNumber: {
 463         JSValue child = forNode(node-&gt;child1()).value();
 464         if (doesOverflow(node-&gt;arithMode())) {
 465             if (enableInt52()) {
 466                 if (child &amp;&amp; child.isAnyInt()) {
 467                     int64_t machineInt = child.asAnyInt();
 468                     setConstant(node, jsNumber(static_cast&lt;uint32_t&gt;(machineInt)));
 469                     break;
 470                 }
<span class="line-modified"> 471                 setNonCellTypeForNode(node, SpecAnyInt);</span>
 472                 break;
 473             }
 474             if (child &amp;&amp; child.isInt32()) {
 475                 uint32_t value = child.asInt32();
 476                 setConstant(node, jsNumber(value));
 477                 break;
 478             }
 479             setNonCellTypeForNode(node, SpecAnyIntAsDouble);
 480             break;
 481         }
 482         if (child &amp;&amp; child.isInt32()) {
 483             int32_t value = child.asInt32();
 484             if (value &gt;= 0) {
 485                 setConstant(node, jsNumber(value));
 486                 break;
 487             }
 488         }
 489         setNonCellTypeForNode(node, SpecInt32Only);
 490         break;
 491     }
</pre>
<hr />
<pre>
 578         case Int52RepUse:
 579         case NumberUse:
 580         case RealNumberUse:
 581             break;
 582 
 583         default:
 584             RELEASE_ASSERT_NOT_REACHED();
 585         }
 586         setNonCellTypeForNode(node, type);
 587         forNode(node).fixTypeForRepresentation(m_graph, node);
 588         break;
 589     }
 590 
 591     case Int52Rep: {
 592         JSValue child = forNode(node-&gt;child1()).value();
 593         if (child &amp;&amp; child.isAnyInt()) {
 594             setConstant(node, child);
 595             break;
 596         }
 597 
<span class="line-modified"> 598         setNonCellTypeForNode(node, SpecAnyInt);</span>

 599         break;
 600     }
 601 
 602     case ValueRep: {
 603         JSValue value = forNode(node-&gt;child1()).value();
 604         if (value) {
 605             setConstant(node, value);
 606             break;
 607         }
 608 
 609         setTypeForNode(node, forNode(node-&gt;child1()).m_type &amp; ~SpecDoubleImpureNaN);
 610         forNode(node).fixTypeForRepresentation(m_graph, node);
 611         break;
 612     }
 613 
 614     case ValueSub:
 615     case ValueAdd: {
 616         DFG_ASSERT(m_graph, node, node-&gt;binaryUseKind() == UntypedUse || node-&gt;binaryUseKind() == BigIntUse);
 617         if (node-&gt;binaryUseKind() == BigIntUse)
 618             setTypeForNode(node, SpecBigInt);
</pre>
<hr />
<pre>
 637                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 638                     setConstant(node, jsNumber(left.asInt32() + right.asInt32()));
 639                     break;
 640                 }
 641                 JSValue result = jsNumber(left.asNumber() + right.asNumber());
 642                 if (result.isInt32()) {
 643                     setConstant(node, result);
 644                     break;
 645                 }
 646             }
 647             setNonCellTypeForNode(node, SpecInt32Only);
 648             break;
 649         case Int52RepUse:
 650             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
 651                 JSValue result = jsNumber(left.asAnyInt() + right.asAnyInt());
 652                 if (result.isAnyInt()) {
 653                     setConstant(node, result);
 654                     break;
 655                 }
 656             }
<span class="line-modified"> 657             setNonCellTypeForNode(node, SpecAnyInt);</span>
 658             break;
 659         case DoubleRepUse:
 660             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
 661                 setConstant(node, jsDoubleNumber(left.asNumber() + right.asNumber()));
 662                 break;
 663             }
 664             setNonCellTypeForNode(node,
 665                 typeOfDoubleSum(
 666                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
 667             break;
 668         default:
 669             RELEASE_ASSERT_NOT_REACHED();
 670             break;
 671         }
 672         break;
 673     }
 674 
 675     case AtomicsIsLockFree: {
 676         if (node-&gt;child1().useKind() != Int32Use)
 677             clobberWorld();
 678         setNonCellTypeForNode(node, SpecBoolInt32);
 679         break;
 680     }
 681 
 682     case ArithClz32: {
 683         JSValue operand = forNode(node-&gt;child1()).value();
 684         if (Optional&lt;double&gt; number = operand.toNumberFromPrimitive()) {
 685             switch (node-&gt;child1().useKind()) {
 686             case Int32Use:
 687             case KnownInt32Use:
 688                 break;
 689             default:
 690                 didFoldClobberWorld();
 691                 break;
 692             }
 693             uint32_t value = toUInt32(*number);
<span class="line-modified"> 694             setConstant(node, jsNumber(clz32(value)));</span>
 695             break;
 696         }
 697         switch (node-&gt;child1().useKind()) {
 698         case Int32Use:
 699         case KnownInt32Use:
 700             break;
 701         default:
 702             clobberWorld();
 703             break;
 704         }
 705         setNonCellTypeForNode(node, SpecInt32Only);
 706         break;
 707     }
 708 
 709     case MakeRope: {
<span class="line-removed"> 710         unsigned numberOfChildren = 0;</span>
 711         unsigned numberOfRemovedChildren = 0;
<span class="line-removed"> 712         Optional&lt;unsigned&gt; nonEmptyIndex;</span>
 713         for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i) {
 714             Edge&amp; edge = node-&gt;children.child(i);
 715             if (!edge)
 716                 break;
<span class="line-removed"> 717             ++numberOfChildren;</span>
<span class="line-removed"> 718 </span>
 719             JSValue childConstant = m_state.forNode(edge).value();
<span class="line-modified"> 720             if (!childConstant) {</span>
<span class="line-removed"> 721                 nonEmptyIndex = i;</span>
 722                 continue;
<span class="line-modified"> 723             }</span>
<span class="line-removed"> 724             if (!childConstant.isString()) {</span>
<span class="line-removed"> 725                 nonEmptyIndex = i;</span>
 726                 continue;
<span class="line-modified"> 727             }</span>
<span class="line-removed"> 728             if (asString(childConstant)-&gt;length()) {</span>
<span class="line-removed"> 729                 nonEmptyIndex = i;</span>
 730                 continue;
<span class="line-removed"> 731             }</span>
<span class="line-removed"> 732 </span>
 733             ++numberOfRemovedChildren;
 734         }
 735 
<span class="line-modified"> 736         if (numberOfRemovedChildren) {</span>
 737             m_state.setFoundConstants(true);
<span class="line-removed"> 738             if (numberOfRemovedChildren == numberOfChildren) {</span>
<span class="line-removed"> 739                 // Propagate the last child. This is the way taken in the constant folding phase.</span>
<span class="line-removed"> 740                 setForNode(node, forNode(node-&gt;children.child(numberOfChildren - 1)));</span>
<span class="line-removed"> 741                 break;</span>
<span class="line-removed"> 742             }</span>
<span class="line-removed"> 743             if ((numberOfRemovedChildren + 1) == numberOfChildren) {</span>
<span class="line-removed"> 744                 ASSERT(nonEmptyIndex);</span>
<span class="line-removed"> 745                 setForNode(node, forNode(node-&gt;children.child(nonEmptyIndex.value())));</span>
<span class="line-removed"> 746                 break;</span>
<span class="line-removed"> 747             }</span>
<span class="line-removed"> 748         }</span>
 749         setForNode(node, m_vm.stringStructure.get());
 750         break;
 751     }
 752 
 753     case ArithSub: {
 754         JSValue left = forNode(node-&gt;child1()).value();
 755         JSValue right = forNode(node-&gt;child2()).value();
 756         switch (node-&gt;binaryUseKind()) {
 757         case Int32Use:
 758             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 759                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 760                     setConstant(node, jsNumber(left.asInt32() - right.asInt32()));
 761                     break;
 762                 }
 763                 JSValue result = jsNumber(left.asNumber() - right.asNumber());
 764                 if (result.isInt32()) {
 765                     setConstant(node, result);
 766                     break;
 767                 }
 768             }
 769             setNonCellTypeForNode(node, SpecInt32Only);
 770             break;
 771         case Int52RepUse:
 772             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
 773                 JSValue result = jsNumber(left.asAnyInt() - right.asAnyInt());
<span class="line-modified"> 774                 if (result.isAnyInt() || !shouldCheckOverflow(node-&gt;arithMode())) {</span>
 775                     setConstant(node, result);
 776                     break;
 777                 }
 778             }
<span class="line-modified"> 779             setNonCellTypeForNode(node, SpecAnyInt);</span>
 780             break;
 781         case DoubleRepUse:
 782             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
 783                 setConstant(node, jsDoubleNumber(left.asNumber() - right.asNumber()));
 784                 break;
 785             }
 786             setNonCellTypeForNode(node,
 787                 typeOfDoubleDifference(
 788                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
 789             break;
 790         case UntypedUse:
 791             clobberWorld();
 792             setNonCellTypeForNode(node, SpecBytecodeNumber);
 793             break;
 794         default:
 795             RELEASE_ASSERT_NOT_REACHED();
 796             break;
 797         }
 798         break;
 799     }
</pre>
<hr />
<pre>
 822                 if (valueResult.isInt32()) {
 823                     setConstant(node, valueResult);
 824                     break;
 825                 }
 826             }
 827             setNonCellTypeForNode(node, SpecInt32Only);
 828             break;
 829         case Int52RepUse:
 830             if (child &amp;&amp; child.isAnyInt()) {
 831                 double doubleResult;
 832                 if (shouldCheckNegativeZero(node-&gt;arithMode()))
 833                     doubleResult = -child.asNumber();
 834                 else
 835                     doubleResult = 0 - child.asNumber();
 836                 JSValue valueResult = jsNumber(doubleResult);
 837                 if (valueResult.isAnyInt()) {
 838                     setConstant(node, valueResult);
 839                     break;
 840                 }
 841             }
<span class="line-modified"> 842             setNonCellTypeForNode(node, SpecAnyInt);</span>
 843             break;
 844         case DoubleRepUse:
 845             if (child &amp;&amp; child.isNumber()) {
 846                 setConstant(node, jsDoubleNumber(-child.asNumber()));
 847                 break;
 848             }
 849             setNonCellTypeForNode(node,
 850                 typeOfDoubleNegation(
 851                     forNode(node-&gt;child1()).m_type));
 852             break;
 853         default:
 854             RELEASE_ASSERT_NOT_REACHED();
 855             break;
 856         }
 857         break;
 858     }
 859 





















 860     case ValueMul: {
 861         if (node-&gt;binaryUseKind() == BigIntUse)
 862             setTypeForNode(node, SpecBigInt);
 863         else {
 864             clobberWorld();
 865             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
 866         }
 867         break;
 868     }
 869 
 870     case ArithMul: {
 871         JSValue left = forNode(node-&gt;child1()).value();
 872         JSValue right = forNode(node-&gt;child2()).value();
 873         switch (node-&gt;binaryUseKind()) {
 874         case Int32Use:
 875             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 876                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 877                     setConstant(node, jsNumber(left.asInt32() * right.asInt32()));
 878                     break;
 879                 }
</pre>
<hr />
<pre>
 882                     doubleResult += 0; // Sanitizes zero.
 883                 JSValue valueResult = jsNumber(doubleResult);
 884                 if (valueResult.isInt32()) {
 885                     setConstant(node, valueResult);
 886                     break;
 887                 }
 888             }
 889             setNonCellTypeForNode(node, SpecInt32Only);
 890             break;
 891         case Int52RepUse:
 892             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
 893                 double doubleResult = left.asNumber() * right.asNumber();
 894                 if (!shouldCheckNegativeZero(node-&gt;arithMode()))
 895                     doubleResult += 0;
 896                 JSValue valueResult = jsNumber(doubleResult);
 897                 if (valueResult.isAnyInt()) {
 898                     setConstant(node, valueResult);
 899                     break;
 900                 }
 901             }
<span class="line-modified"> 902             setNonCellTypeForNode(node, SpecAnyInt);</span>
 903             break;
 904         case DoubleRepUse:
 905             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
 906                 setConstant(node, jsDoubleNumber(left.asNumber() * right.asNumber()));
 907                 break;
 908             }
 909             setNonCellTypeForNode(node,
 910                 typeOfDoubleProduct(
 911                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
 912             break;
 913         default:
 914             RELEASE_ASSERT_NOT_REACHED();
 915             break;
 916         }
 917         break;
 918     }
 919 

 920     case ValueDiv: {



 921         if (node-&gt;binaryUseKind() == BigIntUse)
 922             setTypeForNode(node, SpecBigInt);
 923         else {
 924             clobberWorld();
 925             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
 926         }
 927         break;
 928     }
 929 

 930     case ArithDiv: {
<span class="line-modified"> 931         JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="line-removed"> 932         JSValue right = forNode(node-&gt;child2()).value();</span>
<span class="line-removed"> 933         switch (node-&gt;binaryUseKind()) {</span>
<span class="line-removed"> 934         case Int32Use:</span>
<span class="line-removed"> 935             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="line-removed"> 936                 double doubleResult = left.asNumber() / right.asNumber();</span>
<span class="line-removed"> 937                 if (!shouldCheckOverflow(node-&gt;arithMode()))</span>
<span class="line-removed"> 938                     doubleResult = toInt32(doubleResult);</span>
<span class="line-removed"> 939                 else if (!shouldCheckNegativeZero(node-&gt;arithMode()))</span>
<span class="line-removed"> 940                     doubleResult += 0; // Sanitizes zero.</span>
<span class="line-removed"> 941                 JSValue valueResult = jsNumber(doubleResult);</span>
<span class="line-removed"> 942                 if (valueResult.isInt32()) {</span>
<span class="line-removed"> 943                     setConstant(node, valueResult);</span>
<span class="line-removed"> 944                     break;</span>
<span class="line-removed"> 945                 }</span>
<span class="line-removed"> 946             }</span>
<span class="line-removed"> 947             setNonCellTypeForNode(node, SpecInt32Only);</span>
<span class="line-removed"> 948             break;</span>
<span class="line-removed"> 949         case DoubleRepUse:</span>
<span class="line-removed"> 950             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {</span>
<span class="line-removed"> 951                 setConstant(node, jsDoubleNumber(left.asNumber() / right.asNumber()));</span>
<span class="line-removed"> 952                 break;</span>
<span class="line-removed"> 953             }</span>
<span class="line-removed"> 954             setNonCellTypeForNode(node,</span>
<span class="line-removed"> 955                 typeOfDoubleQuotient(</span>
<span class="line-removed"> 956                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));</span>
<span class="line-removed"> 957             break;</span>
<span class="line-removed"> 958         default:</span>
<span class="line-removed"> 959             RELEASE_ASSERT_NOT_REACHED();</span>
 960             break;
<span class="line-removed"> 961         }</span>
<span class="line-removed"> 962         break;</span>
<span class="line-removed"> 963     }</span>
 964 
<span class="line-removed"> 965     case ArithMod: {</span>
<span class="line-removed"> 966         JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="line-removed"> 967         JSValue right = forNode(node-&gt;child2()).value();</span>
 968         switch (node-&gt;binaryUseKind()) {
 969         case Int32Use:
<span class="line-removed"> 970             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="line-removed"> 971                 double doubleResult = fmod(left.asNumber(), right.asNumber());</span>
<span class="line-removed"> 972                 if (!shouldCheckOverflow(node-&gt;arithMode()))</span>
<span class="line-removed"> 973                     doubleResult = toInt32(doubleResult);</span>
<span class="line-removed"> 974                 else if (!shouldCheckNegativeZero(node-&gt;arithMode()))</span>
<span class="line-removed"> 975                     doubleResult += 0; // Sanitizes zero.</span>
<span class="line-removed"> 976                 JSValue valueResult = jsNumber(doubleResult);</span>
<span class="line-removed"> 977                 if (valueResult.isInt32()) {</span>
<span class="line-removed"> 978                     setConstant(node, valueResult);</span>
<span class="line-removed"> 979                     break;</span>
<span class="line-removed"> 980                 }</span>
<span class="line-removed"> 981             }</span>
 982             setNonCellTypeForNode(node, SpecInt32Only);
 983             break;
 984         case DoubleRepUse:
<span class="line-modified"> 985             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {</span>
<span class="line-modified"> 986                 setConstant(node, jsDoubleNumber(fmod(left.asNumber(), right.asNumber())));</span>
<span class="line-modified"> 987                 break;</span>





 988             }
<span class="line-modified"> 989             setNonCellTypeForNode(node,</span>
<span class="line-removed"> 990                 typeOfDoubleBinaryOp(</span>
<span class="line-removed"> 991                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));</span>
 992             break;
 993         default:
 994             RELEASE_ASSERT_NOT_REACHED();
 995             break;
 996         }
 997         break;
 998     }
 999 
1000     case ArithMin: {
1001         JSValue left = forNode(node-&gt;child1()).value();
1002         JSValue right = forNode(node-&gt;child2()).value();
1003         switch (node-&gt;binaryUseKind()) {
1004         case Int32Use:
1005             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
1006                 setConstant(node, jsNumber(std::min(left.asInt32(), right.asInt32())));
1007                 break;
1008             }
1009             setNonCellTypeForNode(node, SpecInt32Only);
1010             break;
1011         case DoubleRepUse:
</pre>
<hr />
<pre>
2122             setNonCellTypeForNode(node, SpecInt32Only);
2123             break;
2124         case Array::Int16Array:
2125             setNonCellTypeForNode(node, SpecInt32Only);
2126             break;
2127         case Array::Int32Array:
2128             setNonCellTypeForNode(node, SpecInt32Only);
2129             break;
2130         case Array::Uint8Array:
2131             setNonCellTypeForNode(node, SpecInt32Only);
2132             break;
2133         case Array::Uint8ClampedArray:
2134             setNonCellTypeForNode(node, SpecInt32Only);
2135             break;
2136         case Array::Uint16Array:
2137             setNonCellTypeForNode(node, SpecInt32Only);
2138             break;
2139         case Array::Uint32Array:
2140             if (node-&gt;shouldSpeculateInt32())
2141                 setNonCellTypeForNode(node, SpecInt32Only);
<span class="line-modified">2142             else if (enableInt52() &amp;&amp; node-&gt;shouldSpeculateAnyInt())</span>
<span class="line-modified">2143                 setNonCellTypeForNode(node, SpecAnyInt);</span>
2144             else
2145                 setNonCellTypeForNode(node, SpecAnyIntAsDouble);
2146             break;
2147         case Array::Float32Array:
2148             setNonCellTypeForNode(node, SpecFullDouble);
2149             break;
2150         case Array::Float64Array:
2151             setNonCellTypeForNode(node, SpecFullDouble);
2152             break;
2153         default:
2154             RELEASE_ASSERT_NOT_REACHED();
2155             break;
2156         }
2157         break;
2158     }
2159 
2160     case PutByValDirect:
2161     case PutByVal:
2162     case PutByValAlias: {
2163         switch (node-&gt;arrayMode().modeForPut().type()) {
</pre>
<hr />
<pre>
2205         structureSet.add(m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous)));
2206         structureSet.add(m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithDouble)));
2207 
2208         setForNode(node, structureSet);
2209         break;
2210     }
2211 
2212     case ArrayIndexOf: {
2213         setNonCellTypeForNode(node, SpecInt32Only);
2214         break;
2215     }
2216 
2217     case ArrayPop:
2218         clobberWorld();
2219         makeHeapTopForNode(node);
2220         break;
2221 
2222     case GetMyArgumentByVal:
2223     case GetMyArgumentByValOutOfBounds: {
2224         JSValue index = forNode(node-&gt;child2()).m_value;
<span class="line-modified">2225         InlineCallFrame* inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
2226 
2227         if (index &amp;&amp; index.isUInt32()) {
2228             // This pretends to return TOP for accesses that are actually proven out-of-bounds because
2229             // that&#39;s the conservative thing to do. Otherwise we&#39;d need to write more code to mark such
2230             // paths as unreachable, or to return undefined. We could implement that eventually.
2231 
2232             Checked&lt;unsigned, RecordOverflow&gt; argumentIndexChecked = index.asUInt32();
2233             argumentIndexChecked += node-&gt;numberOfArgumentsToSkip();
2234             unsigned argumentIndex;
2235             if (argumentIndexChecked.safeGet(argumentIndex) != CheckedState::DidOverflow) {
2236                 if (inlineCallFrame) {
2237                     if (argumentIndex &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1) {
2238                         setForNode(node, m_state.operand(
2239                             virtualRegisterForArgument(argumentIndex + 1) + inlineCallFrame-&gt;stackOffset));
2240                         m_state.setFoundConstants(true);
2241                         break;
2242                     }
2243                 } else {
2244                     if (argumentIndex &lt; m_state.numberOfArguments() - 1) {
2245                         setForNode(node, m_state.argument(argumentIndex + 1));
</pre>
<hr />
<pre>
2523             break;
2524         case UntypedUse:
2525             clobberWorld();
2526             break;
2527         default:
2528             RELEASE_ASSERT_NOT_REACHED();
2529             break;
2530         }
2531         setForNode(node,
2532             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;typedArrayStructureConcurrently(
2533                 node-&gt;typedArrayType()));
2534         break;
2535 
2536     case NewRegexp:
2537         setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;regExpStructure());
2538         break;
2539 
2540     case ToThis: {
2541         AbstractValue&amp; source = forNode(node-&gt;child1());
2542         AbstractValue&amp; destination = forNode(node);
<span class="line-modified">2543         bool strictMode = m_graph.executableFor(node-&gt;origin.semantic)-&gt;isStrictMode();</span>
2544 
2545         ToThisResult result = isToThisAnIdentity(m_vm, strictMode, source);
2546         switch (result) {
2547         case ToThisResult::Identity:
2548             m_state.setFoundConstants(true);
2549             destination = source;
2550             break;
2551         case ToThisResult::Undefined:
2552             setConstant(node, jsUndefined());
2553             break;
2554         case ToThisResult::GlobalThis:
2555             m_state.setFoundConstants(true);
2556             destination.setType(m_graph, SpecObject);
2557             break;
2558         case ToThisResult::Dynamic:
2559             if (strictMode)
2560                 destination.makeHeapTop();
2561             else {
2562                 destination = source;
2563                 destination.merge(SpecObject);
</pre>
<hr />
<pre>
2577                         m_state.setFoundConstants(true);
2578                         didFoldClobberWorld();
2579                         setForNode(node, structure);
2580                         break;
2581                     }
2582                 }
2583             }
2584         }
2585         clobberWorld();
2586         setTypeForNode(node, SpecFinalObject);
2587         break;
2588     }
2589 
2590     case NewObject:
2591         ASSERT(!!node-&gt;structure().get());
2592         setForNode(node, node-&gt;structure());
2593         break;
2594 
2595     case ObjectCreate: {
2596         if (JSValue base = forNode(node-&gt;child1()).m_value) {
<span class="line-modified">2597             if (base.isNull()) {</span>
<span class="line-modified">2598                 JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>






2599                 m_state.setFoundConstants(true);
2600                 if (node-&gt;child1().useKind() == UntypedUse)
2601                     didFoldClobberWorld();
<span class="line-modified">2602                 setForNode(node, globalObject-&gt;nullPrototypeObjectStructure());</span>
2603                 break;
2604             }
<span class="line-removed">2605             // FIXME: We should get a structure for a constant prototype. We need to allow concurrent</span>
<span class="line-removed">2606             // access to StructureCache from compiler threads.</span>
<span class="line-removed">2607             // https://bugs.webkit.org/show_bug.cgi?id=186199</span>
2608         }
2609         if (node-&gt;child1().useKind() == UntypedUse)
2610             clobberWorld();
2611         setTypeForNode(node, SpecFinalObject);
2612         break;
2613     }
2614 
2615     case ObjectKeys: {
2616         if (node-&gt;child1().useKind() == ObjectUse) {
2617             auto&amp; structureSet = forNode(node-&gt;child1()).m_structure;
2618             if (structureSet.isFinite() &amp;&amp; structureSet.size() == 1) {
2619                 RegisteredStructure structure = structureSet.onlyStructure();
2620                 if (auto* rareData = structure-&gt;rareDataConcurrently()) {
2621                     if (!!rareData-&gt;cachedOwnKeysConcurrently()) {
2622                         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2623                             m_state.setFoundConstants(true);
2624                             didFoldClobberWorld();
2625                             setTypeForNode(node, SpecArray);
2626                             break;
2627                         }
</pre>
<hr />
<pre>
2714 
2715     case NewAsyncGeneratorFunction:
2716         setForNode(node,
2717             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;asyncGeneratorFunctionStructure());
2718         break;
2719 
2720     case NewAsyncFunction:
2721         setForNode(node,
2722             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;asyncFunctionStructure());
2723         break;
2724 
2725     case NewFunction: {
2726         JSGlobalObject* globalObject = m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic);
2727         Structure* structure = JSFunction::selectStructureForNewFuncExp(globalObject, node-&gt;castOperand&lt;FunctionExecutable*&gt;());
2728         setForNode(node, structure);
2729         break;
2730     }
2731 
2732     case GetCallee:
2733         if (FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(m_vm, m_codeBlock-&gt;ownerExecutable())) {
<span class="line-modified">2734             InferredValue* singleton = executable-&gt;singletonFunction();</span>
<span class="line-modified">2735             if (JSValue value = singleton-&gt;inferredValue()) {</span>
<span class="line-removed">2736                 m_graph.watchpoints().addLazily(singleton);</span>
<span class="line-removed">2737                 JSFunction* function = jsCast&lt;JSFunction*&gt;(value);</span>
2738                 setConstant(node, *m_graph.freeze(function));
2739                 break;
2740             }
2741         }
<span class="line-modified">2742         setTypeForNode(node, SpecFunction);</span>
2743         break;
2744 
2745     case GetArgumentCountIncludingThis:
2746         setTypeForNode(node, SpecInt32Only);
2747         break;
2748 
2749     case SetCallee:
2750     case SetArgumentCountIncludingThis:
2751         break;
2752 
2753     case GetRestLength:
2754         setNonCellTypeForNode(node, SpecInt32Only);
2755         break;
2756 
2757     case GetGetter: {
<span class="line-modified">2758         JSValue base = forNode(node-&gt;child1()).m_value;</span>
<span class="line-modified">2759         if (base) {</span>
<span class="line-modified">2760             GetterSetter* getterSetter = jsCast&lt;GetterSetter*&gt;(base);</span>
<span class="line-removed">2761             if (!getterSetter-&gt;isGetterNull()) {</span>
2762                 setConstant(node, *m_graph.freeze(getterSetter-&gt;getterConcurrently()));
2763                 break;
2764             }
2765         }
2766 
2767         setTypeForNode(node, SpecObject);
2768         break;
2769     }
2770 
2771     case GetSetter: {
<span class="line-modified">2772         JSValue base = forNode(node-&gt;child1()).m_value;</span>
<span class="line-modified">2773         if (base) {</span>
<span class="line-modified">2774             GetterSetter* getterSetter = jsCast&lt;GetterSetter*&gt;(base);</span>
<span class="line-removed">2775             if (!getterSetter-&gt;isSetterNull()) {</span>
2776                 setConstant(node, *m_graph.freeze(getterSetter-&gt;setterConcurrently()));
2777                 break;
2778             }
2779         }
2780 
2781         setTypeForNode(node, SpecObject);
2782         break;
2783     }
2784 
2785     case GetScope:
2786         if (JSValue base = forNode(node-&gt;child1()).m_value) {
2787             if (JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, base)) {
2788                 setConstant(node, *m_graph.freeze(function-&gt;scope()));
2789                 break;
2790             }
2791         }
2792         setTypeForNode(node, SpecObjectOther);
2793         break;
2794 
2795     case SkipScope: {
<span class="line-modified">2796         JSValue child = forNode(node-&gt;child1()).value();</span>
<span class="line-modified">2797         if (child) {</span>
<span class="line-modified">2798             setConstant(node, *m_graph.freeze(JSValue(jsCast&lt;JSScope*&gt;(child.asCell())-&gt;next())));</span>
<span class="line-modified">2799             break;</span>



2800         }
2801         setTypeForNode(node, SpecObjectOther);
2802         break;
2803     }
2804 
2805     case GetGlobalObject: {
2806         JSValue child = forNode(node-&gt;child1()).value();
2807         if (child) {
2808             setConstant(node, *m_graph.freeze(JSValue(asObject(child)-&gt;globalObject(m_vm))));
2809             break;
2810         }
2811 
2812         if (forNode(node-&gt;child1()).m_structure.isFinite()) {
2813             JSGlobalObject* globalObject = nullptr;
2814             bool ok = true;
2815             forNode(node-&gt;child1()).m_structure.forEach(
2816                 [&amp;] (RegisteredStructure structure) {
2817                     if (!globalObject)
2818                         globalObject = structure-&gt;globalObject();
2819                     else if (globalObject != structure-&gt;globalObject())
</pre>
<hr />
<pre>
3270         // right now. That&#39;s probably not optimal. In some cases, we may perform an optimization (usually
3271         // by something other than AI, maybe by CSE for example) that obscures AI&#39;s view of the structure
3272         // at the point where GetByOffset runs. Currently, when that happens, we&#39;ll have to rely entirely
3273         // on the type that ByteCodeParser was able to prove.
3274         AbstractValue value = m_graph.inferredValueForProperty(
3275             forNode(node-&gt;child2()), data.offset, m_state.structureClobberState());
3276 
3277         // If we decide that there does not exist any value that this can return, then it&#39;s probably
3278         // because the compilation was already invalidated.
3279         if (value.isClear())
3280             m_state.setIsValid(false);
3281 
3282         setForNode(node, value);
3283         if (value.m_value)
3284             m_state.setFoundConstants(true);
3285         break;
3286     }
3287 
3288     case GetGetterSetterByOffset: {
3289         StorageAccessData&amp; data = node-&gt;storageAccessData();
<span class="line-modified">3290         JSValue result = m_graph.tryGetConstantProperty(forNode(node-&gt;child2()), data.offset);</span>

3291         if (result &amp;&amp; jsDynamicCast&lt;GetterSetter*&gt;(m_vm, result)) {
3292             setConstant(node, *m_graph.freeze(result));
3293             break;
3294         }
3295 
<span class="line-modified">3296         setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;getterSetterStructure());</span>





3297         break;
3298     }
3299 
3300     case MultiGetByOffset: {
3301         // This code will filter the base value in a manner that is possibly different (either more
3302         // or less precise) than the way it would be filtered if this was strength-reduced to a
3303         // CheckStructure. This is fine. It&#39;s legal for different passes over the code to prove
3304         // different things about the code, so long as all of them are sound. That even includes
3305         // one guy proving that code should never execute (due to a contradiction) and another guy
3306         // not finding that contradiction. If someone ever proved that there would be a
3307         // contradiction then there must always be a contradiction even if subsequent passes don&#39;t
3308         // realize it. This is the case here.
3309 
3310         // Ordinarily you have to be careful with calling setFoundConstants()
3311         // because of the effect on compile times, but this node is FTL-only.
3312         m_state.setFoundConstants(true);
3313 
3314         AbstractValue base = forNode(node-&gt;child1());
3315         RegisteredStructureSet baseSet;
3316         AbstractValue result;
</pre>
<hr />
<pre>
3532     case DefineDataProperty:
3533     case DefineAccessorProperty:
3534         clobberWorld();
3535         break;
3536 
3537     case InById: {
3538         // FIXME: We can determine when the property definitely exists based on abstract
3539         // value information.
3540         clobberWorld();
3541         filter(node-&gt;child1(), SpecObject);
3542         setNonCellTypeForNode(node, SpecBoolean);
3543         break;
3544     }
3545 
3546     case InByVal: {
3547         AbstractValue&amp; property = forNode(node-&gt;child2());
3548         if (JSValue constant = property.value()) {
3549             if (constant.isString()) {
3550                 JSString* string = asString(constant);
3551                 const StringImpl* impl = string-&gt;tryGetValueImpl();
<span class="line-modified">3552                 if (impl &amp;&amp; impl-&gt;isAtomic())</span>
3553                     m_state.setFoundConstants(true);
3554             }
3555         }
3556 
3557         // FIXME: We can determine when the property definitely exists based on abstract
3558         // value information.
3559         clobberWorld();
3560         filter(node-&gt;child1(), SpecObject);
3561         setNonCellTypeForNode(node, SpecBoolean);
3562         break;
3563     }
3564 
3565     case HasOwnProperty: {
3566         clobberWorld();
3567         setNonCellTypeForNode(node, SpecBoolean);
3568         break;
3569     }
3570 
3571     case GetEnumerableLength: {
3572         setNonCellTypeForNode(node, SpecInt32Only);
</pre>
<hr />
<pre>
3867     case SetFunctionName: {
3868         clobberWorld();
3869         break;
3870     }
3871 
3872     case StoreBarrier:
3873     case FencedStoreBarrier: {
3874         filter(node-&gt;child1(), SpecCell);
3875         break;
3876     }
3877 
3878     case DataViewGetInt: {
3879         DataViewData data = node-&gt;dataViewData();
3880         if (data.byteSize &lt; 4)
3881             setNonCellTypeForNode(node, SpecInt32Only);
3882         else {
3883             ASSERT(data.byteSize == 4);
3884             if (data.isSigned)
3885                 setNonCellTypeForNode(node, SpecInt32Only);
3886             else
<span class="line-modified">3887                 setNonCellTypeForNode(node, SpecAnyInt);</span>
3888         }
3889         break;
3890     }
3891 
3892     case DataViewGetFloat: {
3893         setNonCellTypeForNode(node, SpecFullDouble);
3894         break;
3895     }
3896 
3897     case DataViewSet: {
3898         break;
3899     }
3900 
3901     case Unreachable:
3902         // It may be that during a previous run of AI we proved that something was unreachable, but
3903         // during this run of AI we forget that it&#39;s unreachable. AI&#39;s proofs don&#39;t have to get
3904         // monotonically stronger over time. So, we don&#39;t assert that AI doesn&#39;t reach the
3905         // Unreachable. We have no choice but to take our past proof at face value. Otherwise we&#39;ll
3906         // crash whenever AI fails to be as powerful on run K as it was on run K-1.
3907         m_state.setIsValid(false);
</pre>
<hr />
<pre>
4019 }
4020 
4021 template&lt;typename AbstractStateType&gt;
4022 void AbstractInterpreter&lt;AbstractStateType&gt;::clobberStructures()
4023 {
4024     m_state.clobberStructures();
4025     m_state.mergeClobberState(AbstractInterpreterClobberState::ClobberedStructures);
4026     m_state.setStructureClobberState(StructuresAreClobbered);
4027 }
4028 
4029 template&lt;typename AbstractStateType&gt;
4030 void AbstractInterpreter&lt;AbstractStateType&gt;::didFoldClobberStructures()
4031 {
4032     m_state.mergeClobberState(AbstractInterpreterClobberState::FoldedClobber);
4033 }
4034 
4035 template&lt;typename AbstractStateType&gt;
4036 void AbstractInterpreter&lt;AbstractStateType&gt;::observeTransition(
4037     unsigned clobberLimit, RegisteredStructure from, RegisteredStructure to)
4038 {








4039     AbstractValue::TransitionObserver transitionObserver(from, to);
4040     forAllValues(clobberLimit, transitionObserver);
4041 
4042     ASSERT(!from-&gt;dfgShouldWatch()); // We don&#39;t need to claim to be in a clobbered state because &#39;from&#39; was never watchable (during the time we were compiling), hence no constants ever introduced into the DFG IR that ever had a watchable structure would ever have the same structure as from.
4043 
4044     m_state.mergeClobberState(AbstractInterpreterClobberState::ObservedTransitions);
4045 }
4046 
4047 template&lt;typename AbstractStateType&gt;
4048 void AbstractInterpreter&lt;AbstractStateType&gt;::observeTransitions(
4049     unsigned clobberLimit, const TransitionVector&amp; vector)
4050 {
4051     if (vector.isEmpty())
4052         return;
4053 








4054     AbstractValue::TransitionsObserver transitionsObserver(vector);
4055     forAllValues(clobberLimit, transitionsObserver);
4056 
4057     if (!ASSERT_DISABLED) {
4058         // We don&#39;t need to claim to be in a clobbered state because none of the Transition::previous structures are watchable.
4059         for (unsigned i = vector.size(); i--;)
4060             ASSERT(!vector[i].previous-&gt;dfgShouldWatch());
4061     }
4062 
4063     m_state.mergeClobberState(AbstractInterpreterClobberState::ObservedTransitions);
4064 }
4065 
4066 template&lt;typename AbstractStateType&gt;
4067 void AbstractInterpreter&lt;AbstractStateType&gt;::dump(PrintStream&amp; out) const
4068 {
4069     const_cast&lt;AbstractInterpreter&lt;AbstractStateType&gt;*&gt;(this)-&gt;dump(out);
4070 }
4071 
4072 template&lt;typename AbstractStateType&gt;
4073 void AbstractInterpreter&lt;AbstractStateType&gt;::dump(PrintStream&amp; out)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  26 #pragma once
  27 
  28 #if ENABLE(DFG_JIT)
  29 
  30 #include &quot;ArrayConstructor.h&quot;
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;DFGAbstractInterpreter.h&quot;
  33 #include &quot;DFGAbstractInterpreterClobberState.h&quot;
  34 #include &quot;DOMJITGetterSetter.h&quot;
  35 #include &quot;DOMJITSignature.h&quot;
  36 #include &quot;GetByIdStatus.h&quot;
  37 #include &quot;GetterSetter.h&quot;
  38 #include &quot;HashMapImpl.h&quot;
  39 #include &quot;JITOperations.h&quot;
  40 #include &quot;JSImmutableButterfly.h&quot;
  41 #include &quot;MathCommon.h&quot;
  42 #include &quot;NumberConstructor.h&quot;
  43 #include &quot;Operations.h&quot;
  44 #include &quot;PutByIdStatus.h&quot;
  45 #include &quot;StringObject.h&quot;
<span class="line-added">  46 #include &quot;StructureCache.h&quot;</span>
  47 #include &quot;StructureRareDataInlines.h&quot;
  48 #include &lt;wtf/BooleanLattice.h&gt;
  49 #include &lt;wtf/CheckedArithmetic.h&gt;
  50 
  51 namespace JSC { namespace DFG {
  52 
  53 template&lt;typename AbstractStateType&gt;
  54 AbstractInterpreter&lt;AbstractStateType&gt;::AbstractInterpreter(Graph&amp; graph, AbstractStateType&amp; state)
  55     : m_codeBlock(graph.m_codeBlock)
  56     , m_graph(graph)
  57     , m_vm(m_graph.m_vm)
  58     , m_state(state)
  59 {
  60     if (m_graph.m_form == SSA)
<span class="line-modified">  61         m_phiChildren = makeUnique&lt;PhiChildren&gt;(m_graph);</span>
  62 }
  63 
  64 template&lt;typename AbstractStateType&gt;
  65 AbstractInterpreter&lt;AbstractStateType&gt;::~AbstractInterpreter()
  66 {
  67 }
  68 
  69 template&lt;typename AbstractStateType&gt;
  70 typename AbstractInterpreter&lt;AbstractStateType&gt;::BooleanResult
  71 AbstractInterpreter&lt;AbstractStateType&gt;::booleanResult(
  72     Node* node, AbstractValue&amp; value)
  73 {
  74     JSValue childConst = value.value();
  75     if (childConst) {
  76         if (childConst.toBoolean(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;globalExec()))
  77             return DefinitelyTrue;
  78         return DefinitelyFalse;
  79     }
  80 
  81     // Next check if we can fold because we know that the source is an object or string and does not equal undefined.
</pre>
<hr />
<pre>
 216             // 1) We are in strict mode and strings/symbols are not wrapped
 217             // 2) The AI has proven that the type of this is a subtype of object
 218             if (type.isObject() &amp;&amp; type.overridesToThis())
 219                 overridesToThis = true;
 220 
 221             // If all the structures are JSScope&#39;s ones, we know the details of JSScope::toThis() operation.
 222             allStructuresAreJSScope &amp;= structure-&gt;classInfo()-&gt;methodTable.toThis == JSScope::info()-&gt;methodTable.toThis;
 223         });
 224         if (!overridesToThis)
 225             return ToThisResult::Identity;
 226         if (allStructuresAreJSScope) {
 227             if (isStrictMode)
 228                 return ToThisResult::Undefined;
 229             return ToThisResult::GlobalThis;
 230         }
 231     }
 232 
 233     return ToThisResult::Dynamic;
 234 }
 235 
<span class="line-added"> 236 template&lt;typename AbstractStateType&gt;</span>
<span class="line-added"> 237 bool AbstractInterpreter&lt;AbstractStateType&gt;::handleConstantBinaryBitwiseOp(Node* node)</span>
<span class="line-added"> 238 {</span>
<span class="line-added"> 239     JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="line-added"> 240     JSValue right = forNode(node-&gt;child2()).value();</span>
<span class="line-added"> 241     if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="line-added"> 242         int32_t a = left.asInt32();</span>
<span class="line-added"> 243         int32_t b = right.asInt32();</span>
<span class="line-added"> 244         if (node-&gt;isBinaryUseKind(UntypedUse))</span>
<span class="line-added"> 245             didFoldClobberWorld();</span>
<span class="line-added"> 246         NodeType op = node-&gt;op();</span>
<span class="line-added"> 247         switch (op) {</span>
<span class="line-added"> 248         case ValueBitAnd:</span>
<span class="line-added"> 249         case ArithBitAnd:</span>
<span class="line-added"> 250             setConstant(node, JSValue(a &amp; b));</span>
<span class="line-added"> 251             break;</span>
<span class="line-added"> 252         case ValueBitOr:</span>
<span class="line-added"> 253         case ArithBitOr:</span>
<span class="line-added"> 254             setConstant(node, JSValue(a | b));</span>
<span class="line-added"> 255             break;</span>
<span class="line-added"> 256         case ValueBitXor:</span>
<span class="line-added"> 257         case ArithBitXor:</span>
<span class="line-added"> 258             setConstant(node, JSValue(a ^ b));</span>
<span class="line-added"> 259             break;</span>
<span class="line-added"> 260         case BitRShift:</span>
<span class="line-added"> 261             setConstant(node, JSValue(a &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));</span>
<span class="line-added"> 262             break;</span>
<span class="line-added"> 263         case ValueBitLShift:</span>
<span class="line-added"> 264         case ArithBitLShift:</span>
<span class="line-added"> 265             setConstant(node, JSValue(a &lt;&lt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));</span>
<span class="line-added"> 266             break;</span>
<span class="line-added"> 267         case BitURShift:</span>
<span class="line-added"> 268             setConstant(node, JSValue(static_cast&lt;int32_t&gt;(static_cast&lt;uint32_t&gt;(a) &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f))));</span>
<span class="line-added"> 269             break;</span>
<span class="line-added"> 270         default:</span>
<span class="line-added"> 271             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 272             break;</span>
<span class="line-added"> 273         }</span>
<span class="line-added"> 274 </span>
<span class="line-added"> 275         return true;</span>
<span class="line-added"> 276     }</span>
<span class="line-added"> 277 </span>
<span class="line-added"> 278     return false;</span>
<span class="line-added"> 279 }</span>
<span class="line-added"> 280 </span>
<span class="line-added"> 281 template&lt;typename AbstractStateType&gt;</span>
<span class="line-added"> 282 bool AbstractInterpreter&lt;AbstractStateType&gt;::handleConstantDivOp(Node* node)</span>
<span class="line-added"> 283 {</span>
<span class="line-added"> 284     JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="line-added"> 285     JSValue right = forNode(node-&gt;child2()).value();</span>
<span class="line-added"> 286 </span>
<span class="line-added"> 287     if (left &amp;&amp; right) {</span>
<span class="line-added"> 288         NodeType op = node-&gt;op();</span>
<span class="line-added"> 289         bool isDivOperation = op == ValueDiv || op == ArithDiv;</span>
<span class="line-added"> 290 </span>
<span class="line-added"> 291         // Only possible case of ValueOp below is UntypedUse,</span>
<span class="line-added"> 292         // so we need to reflect clobberize rules.</span>
<span class="line-added"> 293         bool isClobbering = op == ValueDiv || op == ValueMod;</span>
<span class="line-added"> 294 </span>
<span class="line-added"> 295         if (left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="line-added"> 296             double doubleResult;</span>
<span class="line-added"> 297             if (isDivOperation)</span>
<span class="line-added"> 298                 doubleResult = left.asNumber() / right.asNumber();</span>
<span class="line-added"> 299             else</span>
<span class="line-added"> 300                 doubleResult = fmod(left.asNumber(), right.asNumber());</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302             if (node-&gt;hasArithMode()) {</span>
<span class="line-added"> 303                 if (!shouldCheckOverflow(node-&gt;arithMode()))</span>
<span class="line-added"> 304                     doubleResult = toInt32(doubleResult);</span>
<span class="line-added"> 305                 else if (!shouldCheckNegativeZero(node-&gt;arithMode()))</span>
<span class="line-added"> 306                     doubleResult += 0; // Sanitizes zero.</span>
<span class="line-added"> 307             }</span>
<span class="line-added"> 308 </span>
<span class="line-added"> 309             JSValue valueResult = jsNumber(doubleResult);</span>
<span class="line-added"> 310             if (valueResult.isInt32()) {</span>
<span class="line-added"> 311                 if (isClobbering)</span>
<span class="line-added"> 312                     didFoldClobberWorld();</span>
<span class="line-added"> 313                 setConstant(node, valueResult);</span>
<span class="line-added"> 314                 return true;</span>
<span class="line-added"> 315             }</span>
<span class="line-added"> 316         } else if (left.isNumber() &amp;&amp; right.isNumber()) {</span>
<span class="line-added"> 317             if (isClobbering)</span>
<span class="line-added"> 318                 didFoldClobberWorld();</span>
<span class="line-added"> 319 </span>
<span class="line-added"> 320             if (isDivOperation)</span>
<span class="line-added"> 321                 setConstant(node, jsDoubleNumber(left.asNumber() / right.asNumber()));</span>
<span class="line-added"> 322             else</span>
<span class="line-added"> 323                 setConstant(node, jsDoubleNumber(fmod(left.asNumber(), right.asNumber())));</span>
<span class="line-added"> 324 </span>
<span class="line-added"> 325             return true;</span>
<span class="line-added"> 326         }</span>
<span class="line-added"> 327     }</span>
<span class="line-added"> 328 </span>
<span class="line-added"> 329     return false;</span>
<span class="line-added"> 330 }</span>
<span class="line-added"> 331 </span>
 332 template&lt;typename AbstractStateType&gt;
 333 bool AbstractInterpreter&lt;AbstractStateType&gt;::executeEffects(unsigned clobberLimit, Node* node)
 334 {
 335     verifyEdges(node);
 336 
 337     m_state.createValueForNode(node);
 338 
 339     switch (node-&gt;op()) {
 340     case JSConstant:
 341     case DoubleConstant:
 342     case Int52Constant: {
 343         setBuiltInConstant(node, *node-&gt;constant());
 344         break;
 345     }
 346 
 347     case LazyJSConstant: {
 348         LazyJSValue value = node-&gt;lazyJSValue();
 349         switch (value.kind()) {
 350         case LazyJSValue::KnownValue:
 351             setConstant(node, value.value()-&gt;value());
</pre>
<hr />
<pre>
 401     }
 402 
 403     case PutStack: {
 404         m_state.operand(node-&gt;stackAccessData()-&gt;local) = forNode(node-&gt;child1());
 405         break;
 406     }
 407 
 408     case MovHint: {
 409         // Don&#39;t need to do anything. A MovHint only informs us about what would have happened
 410         // in bytecode, but this code is just concerned with what is actually happening during
 411         // DFG execution.
 412         break;
 413     }
 414 
 415     case KillStack: {
 416         // This is just a hint telling us that the OSR state of the local is no longer inside the
 417         // flushed data.
 418         break;
 419     }
 420 
<span class="line-modified"> 421     case SetArgumentDefinitely:</span>
<span class="line-modified"> 422     case SetArgumentMaybe:</span>
<span class="line-modified"> 423         // Assert that the state of arguments has been set. SetArgumentDefinitely/SetArgumentMaybe means</span>
<span class="line-added"> 424         // that someone set the argument values out-of-band, and currently this always means setting to a</span>
 425         // non-clear value.
 426         ASSERT(!m_state.operand(node-&gt;local()).isClear());
 427         break;
 428 
 429     case InitializeEntrypointArguments: {
 430         unsigned entrypointIndex = node-&gt;entrypointIndex();
 431         const Vector&lt;FlushFormat&gt;&amp; argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
 432         for (unsigned argument = 0; argument &lt; argumentFormats.size(); ++argument) {
 433             AbstractValue&amp; value = m_state.argument(argument);
 434             switch (argumentFormats[argument]) {
 435             case FlushedInt32:
 436                 value.setNonCellType(SpecInt32Only);
 437                 break;
 438             case FlushedBoolean:
 439                 value.setNonCellType(SpecBoolean);
 440                 break;
 441             case FlushedCell:
 442                 value.setType(m_graph, SpecCellCheck);
 443                 break;
 444             case FlushedJSValue:
</pre>
<hr />
<pre>
 457         // FIXME: ForwardVarargs should check if the count becomes known, and if it does, it should turn
 458         // itself into a straight-line sequence of GetStack/PutStack.
 459         // https://bugs.webkit.org/show_bug.cgi?id=143071
 460         switch (node-&gt;op()) {
 461         case LoadVarargs:
 462             clobberWorld();
 463             break;
 464         case ForwardVarargs:
 465             break;
 466         default:
 467             DFG_CRASH(m_graph, node, &quot;Bad opcode&quot;);
 468             break;
 469         }
 470         LoadVarargsData* data = node-&gt;loadVarargsData();
 471         m_state.operand(data-&gt;count).setNonCellType(SpecInt32Only);
 472         for (unsigned i = data-&gt;limit - 1; i--;)
 473             m_state.operand(data-&gt;start.offset() + i).makeHeapTop();
 474         break;
 475     }
 476 
<span class="line-modified"> 477     case ValueBitNot: {</span>
<span class="line-modified"> 478         JSValue operand = forNode(node-&gt;child1()).value();</span>
<span class="line-modified"> 479         if (operand &amp;&amp; operand.isInt32()) {</span>
<span class="line-modified"> 480             didFoldClobberWorld();</span>
<span class="line-added"> 481             int32_t a = operand.asInt32();</span>
<span class="line-added"> 482             setConstant(node, JSValue(~a));</span>
 483             break;
 484         }
 485 
<span class="line-added"> 486         if (node-&gt;child1().useKind() == BigIntUse)</span>
<span class="line-added"> 487             setTypeForNode(node, SpecBigInt);</span>
<span class="line-added"> 488         else {</span>
<span class="line-added"> 489             clobberWorld();</span>
<span class="line-added"> 490             setTypeForNode(node, SpecInt32Only | SpecBigInt);</span>
<span class="line-added"> 491         }</span>
<span class="line-added"> 492 </span>
<span class="line-added"> 493         break;</span>
<span class="line-added"> 494     }</span>
<span class="line-added"> 495 </span>
<span class="line-added"> 496     case ArithBitNot: {</span>
 497         JSValue operand = forNode(node-&gt;child1()).value();
 498         if (operand &amp;&amp; operand.isInt32()) {
 499             int32_t a = operand.asInt32();
 500             setConstant(node, JSValue(~a));
 501             break;
 502         }
 503 
 504         setNonCellTypeForNode(node, SpecInt32Only);
 505         break;
 506     }
 507 
 508     case ValueBitXor:
 509     case ValueBitAnd:
 510     case ValueBitOr:
<span class="line-added"> 511     case ValueBitLShift: {</span>
<span class="line-added"> 512         if (handleConstantBinaryBitwiseOp(node))</span>
<span class="line-added"> 513             break;</span>
<span class="line-added"> 514 </span>
 515         if (node-&gt;binaryUseKind() == BigIntUse)
 516             setTypeForNode(node, SpecBigInt);
 517         else {
 518             clobberWorld();
<span class="line-modified"> 519             setTypeForNode(node, SpecInt32Only | SpecBigInt);</span>
 520         }
 521         break;
<span class="line-added"> 522     }</span>
 523 
 524     case ArithBitAnd:
 525     case ArithBitOr:
 526     case ArithBitXor:
 527     case BitRShift:
<span class="line-modified"> 528     case ArithBitLShift:</span>
 529     case BitURShift: {
 530         if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
 531             clobberWorld();
 532             setNonCellTypeForNode(node, SpecInt32Only);
 533             break;
 534         }
 535 
<span class="line-modified"> 536         if (handleConstantBinaryBitwiseOp(node))</span>



























 537             break;

 538 
 539         if (node-&gt;op() == ArithBitAnd
 540             &amp;&amp; (isBoolInt32Speculation(forNode(node-&gt;child1()).m_type) ||
 541                 isBoolInt32Speculation(forNode(node-&gt;child2()).m_type))) {
 542             setNonCellTypeForNode(node, SpecBoolInt32);
 543             break;
 544         }
 545 
 546         setNonCellTypeForNode(node, SpecInt32Only);
 547         break;
 548     }
 549 
 550     case UInt32ToNumber: {
 551         JSValue child = forNode(node-&gt;child1()).value();
 552         if (doesOverflow(node-&gt;arithMode())) {
 553             if (enableInt52()) {
 554                 if (child &amp;&amp; child.isAnyInt()) {
 555                     int64_t machineInt = child.asAnyInt();
 556                     setConstant(node, jsNumber(static_cast&lt;uint32_t&gt;(machineInt)));
 557                     break;
 558                 }
<span class="line-modified"> 559                 setNonCellTypeForNode(node, SpecInt52Any);</span>
 560                 break;
 561             }
 562             if (child &amp;&amp; child.isInt32()) {
 563                 uint32_t value = child.asInt32();
 564                 setConstant(node, jsNumber(value));
 565                 break;
 566             }
 567             setNonCellTypeForNode(node, SpecAnyIntAsDouble);
 568             break;
 569         }
 570         if (child &amp;&amp; child.isInt32()) {
 571             int32_t value = child.asInt32();
 572             if (value &gt;= 0) {
 573                 setConstant(node, jsNumber(value));
 574                 break;
 575             }
 576         }
 577         setNonCellTypeForNode(node, SpecInt32Only);
 578         break;
 579     }
</pre>
<hr />
<pre>
 666         case Int52RepUse:
 667         case NumberUse:
 668         case RealNumberUse:
 669             break;
 670 
 671         default:
 672             RELEASE_ASSERT_NOT_REACHED();
 673         }
 674         setNonCellTypeForNode(node, type);
 675         forNode(node).fixTypeForRepresentation(m_graph, node);
 676         break;
 677     }
 678 
 679     case Int52Rep: {
 680         JSValue child = forNode(node-&gt;child1()).value();
 681         if (child &amp;&amp; child.isAnyInt()) {
 682             setConstant(node, child);
 683             break;
 684         }
 685 
<span class="line-modified"> 686         setTypeForNode(node, forNode(node-&gt;child1()).m_type);</span>
<span class="line-added"> 687         forNode(node).fixTypeForRepresentation(m_graph, node);</span>
 688         break;
 689     }
 690 
 691     case ValueRep: {
 692         JSValue value = forNode(node-&gt;child1()).value();
 693         if (value) {
 694             setConstant(node, value);
 695             break;
 696         }
 697 
 698         setTypeForNode(node, forNode(node-&gt;child1()).m_type &amp; ~SpecDoubleImpureNaN);
 699         forNode(node).fixTypeForRepresentation(m_graph, node);
 700         break;
 701     }
 702 
 703     case ValueSub:
 704     case ValueAdd: {
 705         DFG_ASSERT(m_graph, node, node-&gt;binaryUseKind() == UntypedUse || node-&gt;binaryUseKind() == BigIntUse);
 706         if (node-&gt;binaryUseKind() == BigIntUse)
 707             setTypeForNode(node, SpecBigInt);
</pre>
<hr />
<pre>
 726                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 727                     setConstant(node, jsNumber(left.asInt32() + right.asInt32()));
 728                     break;
 729                 }
 730                 JSValue result = jsNumber(left.asNumber() + right.asNumber());
 731                 if (result.isInt32()) {
 732                     setConstant(node, result);
 733                     break;
 734                 }
 735             }
 736             setNonCellTypeForNode(node, SpecInt32Only);
 737             break;
 738         case Int52RepUse:
 739             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
 740                 JSValue result = jsNumber(left.asAnyInt() + right.asAnyInt());
 741                 if (result.isAnyInt()) {
 742                     setConstant(node, result);
 743                     break;
 744                 }
 745             }
<span class="line-modified"> 746             setNonCellTypeForNode(node, SpecInt52Any);</span>
 747             break;
 748         case DoubleRepUse:
 749             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
 750                 setConstant(node, jsDoubleNumber(left.asNumber() + right.asNumber()));
 751                 break;
 752             }
 753             setNonCellTypeForNode(node,
 754                 typeOfDoubleSum(
 755                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
 756             break;
 757         default:
 758             RELEASE_ASSERT_NOT_REACHED();
 759             break;
 760         }
 761         break;
 762     }
 763 
 764     case AtomicsIsLockFree: {
 765         if (node-&gt;child1().useKind() != Int32Use)
 766             clobberWorld();
 767         setNonCellTypeForNode(node, SpecBoolInt32);
 768         break;
 769     }
 770 
 771     case ArithClz32: {
 772         JSValue operand = forNode(node-&gt;child1()).value();
 773         if (Optional&lt;double&gt; number = operand.toNumberFromPrimitive()) {
 774             switch (node-&gt;child1().useKind()) {
 775             case Int32Use:
 776             case KnownInt32Use:
 777                 break;
 778             default:
 779                 didFoldClobberWorld();
 780                 break;
 781             }
 782             uint32_t value = toUInt32(*number);
<span class="line-modified"> 783             setConstant(node, jsNumber(clz(value)));</span>
 784             break;
 785         }
 786         switch (node-&gt;child1().useKind()) {
 787         case Int32Use:
 788         case KnownInt32Use:
 789             break;
 790         default:
 791             clobberWorld();
 792             break;
 793         }
 794         setNonCellTypeForNode(node, SpecInt32Only);
 795         break;
 796     }
 797 
 798     case MakeRope: {

 799         unsigned numberOfRemovedChildren = 0;

 800         for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i) {
 801             Edge&amp; edge = node-&gt;children.child(i);
 802             if (!edge)
 803                 break;


 804             JSValue childConstant = m_state.forNode(edge).value();
<span class="line-modified"> 805             if (!childConstant)</span>

 806                 continue;
<span class="line-modified"> 807             if (!childConstant.isString())</span>


 808                 continue;
<span class="line-modified"> 809             if (asString(childConstant)-&gt;length())</span>


 810                 continue;


 811             ++numberOfRemovedChildren;
 812         }
 813 
<span class="line-modified"> 814         if (numberOfRemovedChildren)</span>
 815             m_state.setFoundConstants(true);











 816         setForNode(node, m_vm.stringStructure.get());
 817         break;
 818     }
 819 
 820     case ArithSub: {
 821         JSValue left = forNode(node-&gt;child1()).value();
 822         JSValue right = forNode(node-&gt;child2()).value();
 823         switch (node-&gt;binaryUseKind()) {
 824         case Int32Use:
 825             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 826                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 827                     setConstant(node, jsNumber(left.asInt32() - right.asInt32()));
 828                     break;
 829                 }
 830                 JSValue result = jsNumber(left.asNumber() - right.asNumber());
 831                 if (result.isInt32()) {
 832                     setConstant(node, result);
 833                     break;
 834                 }
 835             }
 836             setNonCellTypeForNode(node, SpecInt32Only);
 837             break;
 838         case Int52RepUse:
 839             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
 840                 JSValue result = jsNumber(left.asAnyInt() - right.asAnyInt());
<span class="line-modified"> 841                 if (result.isAnyInt()) {</span>
 842                     setConstant(node, result);
 843                     break;
 844                 }
 845             }
<span class="line-modified"> 846             setNonCellTypeForNode(node, SpecInt52Any);</span>
 847             break;
 848         case DoubleRepUse:
 849             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
 850                 setConstant(node, jsDoubleNumber(left.asNumber() - right.asNumber()));
 851                 break;
 852             }
 853             setNonCellTypeForNode(node,
 854                 typeOfDoubleDifference(
 855                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
 856             break;
 857         case UntypedUse:
 858             clobberWorld();
 859             setNonCellTypeForNode(node, SpecBytecodeNumber);
 860             break;
 861         default:
 862             RELEASE_ASSERT_NOT_REACHED();
 863             break;
 864         }
 865         break;
 866     }
</pre>
<hr />
<pre>
 889                 if (valueResult.isInt32()) {
 890                     setConstant(node, valueResult);
 891                     break;
 892                 }
 893             }
 894             setNonCellTypeForNode(node, SpecInt32Only);
 895             break;
 896         case Int52RepUse:
 897             if (child &amp;&amp; child.isAnyInt()) {
 898                 double doubleResult;
 899                 if (shouldCheckNegativeZero(node-&gt;arithMode()))
 900                     doubleResult = -child.asNumber();
 901                 else
 902                     doubleResult = 0 - child.asNumber();
 903                 JSValue valueResult = jsNumber(doubleResult);
 904                 if (valueResult.isAnyInt()) {
 905                     setConstant(node, valueResult);
 906                     break;
 907                 }
 908             }
<span class="line-modified"> 909             setNonCellTypeForNode(node, SpecInt52Any);</span>
 910             break;
 911         case DoubleRepUse:
 912             if (child &amp;&amp; child.isNumber()) {
 913                 setConstant(node, jsDoubleNumber(-child.asNumber()));
 914                 break;
 915             }
 916             setNonCellTypeForNode(node,
 917                 typeOfDoubleNegation(
 918                     forNode(node-&gt;child1()).m_type));
 919             break;
 920         default:
 921             RELEASE_ASSERT_NOT_REACHED();
 922             break;
 923         }
 924         break;
 925     }
 926 
<span class="line-added"> 927     case ValuePow: {</span>
<span class="line-added"> 928         JSValue childX = forNode(node-&gt;child1()).value();</span>
<span class="line-added"> 929         JSValue childY = forNode(node-&gt;child2()).value();</span>
<span class="line-added"> 930         if (childX &amp;&amp; childY &amp;&amp; childX.isNumber() &amp;&amp; childY.isNumber()) {</span>
<span class="line-added"> 931             // We need to call `didFoldClobberWorld` here because this path is only possible</span>
<span class="line-added"> 932             // when node-&gt;useKind is UntypedUse. In the case of BigIntUse, children will be</span>
<span class="line-added"> 933             // cleared by `AbstractInterpreter::executeEffects`.</span>
<span class="line-added"> 934             didFoldClobberWorld();</span>
<span class="line-added"> 935             setConstant(node, jsDoubleNumber(operationMathPow(childX.asNumber(), childY.asNumber())));</span>
<span class="line-added"> 936             break;</span>
<span class="line-added"> 937         }</span>
<span class="line-added"> 938 </span>
<span class="line-added"> 939         if (node-&gt;binaryUseKind() == BigIntUse)</span>
<span class="line-added"> 940             setTypeForNode(node, SpecBigInt);</span>
<span class="line-added"> 941         else {</span>
<span class="line-added"> 942             clobberWorld();</span>
<span class="line-added"> 943             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);</span>
<span class="line-added"> 944         }</span>
<span class="line-added"> 945         break;</span>
<span class="line-added"> 946     }</span>
<span class="line-added"> 947 </span>
 948     case ValueMul: {
 949         if (node-&gt;binaryUseKind() == BigIntUse)
 950             setTypeForNode(node, SpecBigInt);
 951         else {
 952             clobberWorld();
 953             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
 954         }
 955         break;
 956     }
 957 
 958     case ArithMul: {
 959         JSValue left = forNode(node-&gt;child1()).value();
 960         JSValue right = forNode(node-&gt;child2()).value();
 961         switch (node-&gt;binaryUseKind()) {
 962         case Int32Use:
 963             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 964                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 965                     setConstant(node, jsNumber(left.asInt32() * right.asInt32()));
 966                     break;
 967                 }
</pre>
<hr />
<pre>
 970                     doubleResult += 0; // Sanitizes zero.
 971                 JSValue valueResult = jsNumber(doubleResult);
 972                 if (valueResult.isInt32()) {
 973                     setConstant(node, valueResult);
 974                     break;
 975                 }
 976             }
 977             setNonCellTypeForNode(node, SpecInt32Only);
 978             break;
 979         case Int52RepUse:
 980             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
 981                 double doubleResult = left.asNumber() * right.asNumber();
 982                 if (!shouldCheckNegativeZero(node-&gt;arithMode()))
 983                     doubleResult += 0;
 984                 JSValue valueResult = jsNumber(doubleResult);
 985                 if (valueResult.isAnyInt()) {
 986                     setConstant(node, valueResult);
 987                     break;
 988                 }
 989             }
<span class="line-modified"> 990             setNonCellTypeForNode(node, SpecInt52Any);</span>
 991             break;
 992         case DoubleRepUse:
 993             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
 994                 setConstant(node, jsDoubleNumber(left.asNumber() * right.asNumber()));
 995                 break;
 996             }
 997             setNonCellTypeForNode(node,
 998                 typeOfDoubleProduct(
 999                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
1000             break;
1001         default:
1002             RELEASE_ASSERT_NOT_REACHED();
1003             break;
1004         }
1005         break;
1006     }
1007 
<span class="line-added">1008     case ValueMod:</span>
1009     case ValueDiv: {
<span class="line-added">1010         if (handleConstantDivOp(node))</span>
<span class="line-added">1011             break;</span>
<span class="line-added">1012 </span>
1013         if (node-&gt;binaryUseKind() == BigIntUse)
1014             setTypeForNode(node, SpecBigInt);
1015         else {
1016             clobberWorld();
1017             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
1018         }
1019         break;
1020     }
1021 
<span class="line-added">1022     case ArithMod:</span>
1023     case ArithDiv: {
<span class="line-modified">1024         if (handleConstantDivOp(node))</span>




























1025             break;



1026 



1027         switch (node-&gt;binaryUseKind()) {
1028         case Int32Use:












1029             setNonCellTypeForNode(node, SpecInt32Only);
1030             break;
1031         case DoubleRepUse:
<span class="line-modified">1032             if (node-&gt;op() == ArithDiv) {</span>
<span class="line-modified">1033                 setNonCellTypeForNode(node,</span>
<span class="line-modified">1034                     typeOfDoubleQuotient(</span>
<span class="line-added">1035                         forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));</span>
<span class="line-added">1036             } else {</span>
<span class="line-added">1037                 setNonCellTypeForNode(node,</span>
<span class="line-added">1038                     typeOfDoubleBinaryOp(</span>
<span class="line-added">1039                         forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));</span>
1040             }
<span class="line-modified">1041 </span>


1042             break;
1043         default:
1044             RELEASE_ASSERT_NOT_REACHED();
1045             break;
1046         }
1047         break;
1048     }
1049 
1050     case ArithMin: {
1051         JSValue left = forNode(node-&gt;child1()).value();
1052         JSValue right = forNode(node-&gt;child2()).value();
1053         switch (node-&gt;binaryUseKind()) {
1054         case Int32Use:
1055             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
1056                 setConstant(node, jsNumber(std::min(left.asInt32(), right.asInt32())));
1057                 break;
1058             }
1059             setNonCellTypeForNode(node, SpecInt32Only);
1060             break;
1061         case DoubleRepUse:
</pre>
<hr />
<pre>
2172             setNonCellTypeForNode(node, SpecInt32Only);
2173             break;
2174         case Array::Int16Array:
2175             setNonCellTypeForNode(node, SpecInt32Only);
2176             break;
2177         case Array::Int32Array:
2178             setNonCellTypeForNode(node, SpecInt32Only);
2179             break;
2180         case Array::Uint8Array:
2181             setNonCellTypeForNode(node, SpecInt32Only);
2182             break;
2183         case Array::Uint8ClampedArray:
2184             setNonCellTypeForNode(node, SpecInt32Only);
2185             break;
2186         case Array::Uint16Array:
2187             setNonCellTypeForNode(node, SpecInt32Only);
2188             break;
2189         case Array::Uint32Array:
2190             if (node-&gt;shouldSpeculateInt32())
2191                 setNonCellTypeForNode(node, SpecInt32Only);
<span class="line-modified">2192             else if (node-&gt;shouldSpeculateInt52())</span>
<span class="line-modified">2193                 setNonCellTypeForNode(node, SpecInt52Any);</span>
2194             else
2195                 setNonCellTypeForNode(node, SpecAnyIntAsDouble);
2196             break;
2197         case Array::Float32Array:
2198             setNonCellTypeForNode(node, SpecFullDouble);
2199             break;
2200         case Array::Float64Array:
2201             setNonCellTypeForNode(node, SpecFullDouble);
2202             break;
2203         default:
2204             RELEASE_ASSERT_NOT_REACHED();
2205             break;
2206         }
2207         break;
2208     }
2209 
2210     case PutByValDirect:
2211     case PutByVal:
2212     case PutByValAlias: {
2213         switch (node-&gt;arrayMode().modeForPut().type()) {
</pre>
<hr />
<pre>
2255         structureSet.add(m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous)));
2256         structureSet.add(m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithDouble)));
2257 
2258         setForNode(node, structureSet);
2259         break;
2260     }
2261 
2262     case ArrayIndexOf: {
2263         setNonCellTypeForNode(node, SpecInt32Only);
2264         break;
2265     }
2266 
2267     case ArrayPop:
2268         clobberWorld();
2269         makeHeapTopForNode(node);
2270         break;
2271 
2272     case GetMyArgumentByVal:
2273     case GetMyArgumentByValOutOfBounds: {
2274         JSValue index = forNode(node-&gt;child2()).m_value;
<span class="line-modified">2275         InlineCallFrame* inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
2276 
2277         if (index &amp;&amp; index.isUInt32()) {
2278             // This pretends to return TOP for accesses that are actually proven out-of-bounds because
2279             // that&#39;s the conservative thing to do. Otherwise we&#39;d need to write more code to mark such
2280             // paths as unreachable, or to return undefined. We could implement that eventually.
2281 
2282             Checked&lt;unsigned, RecordOverflow&gt; argumentIndexChecked = index.asUInt32();
2283             argumentIndexChecked += node-&gt;numberOfArgumentsToSkip();
2284             unsigned argumentIndex;
2285             if (argumentIndexChecked.safeGet(argumentIndex) != CheckedState::DidOverflow) {
2286                 if (inlineCallFrame) {
2287                     if (argumentIndex &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1) {
2288                         setForNode(node, m_state.operand(
2289                             virtualRegisterForArgument(argumentIndex + 1) + inlineCallFrame-&gt;stackOffset));
2290                         m_state.setFoundConstants(true);
2291                         break;
2292                     }
2293                 } else {
2294                     if (argumentIndex &lt; m_state.numberOfArguments() - 1) {
2295                         setForNode(node, m_state.argument(argumentIndex + 1));
</pre>
<hr />
<pre>
2573             break;
2574         case UntypedUse:
2575             clobberWorld();
2576             break;
2577         default:
2578             RELEASE_ASSERT_NOT_REACHED();
2579             break;
2580         }
2581         setForNode(node,
2582             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;typedArrayStructureConcurrently(
2583                 node-&gt;typedArrayType()));
2584         break;
2585 
2586     case NewRegexp:
2587         setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;regExpStructure());
2588         break;
2589 
2590     case ToThis: {
2591         AbstractValue&amp; source = forNode(node-&gt;child1());
2592         AbstractValue&amp; destination = forNode(node);
<span class="line-modified">2593         bool strictMode = m_graph.isStrictModeFor(node-&gt;origin.semantic);</span>
2594 
2595         ToThisResult result = isToThisAnIdentity(m_vm, strictMode, source);
2596         switch (result) {
2597         case ToThisResult::Identity:
2598             m_state.setFoundConstants(true);
2599             destination = source;
2600             break;
2601         case ToThisResult::Undefined:
2602             setConstant(node, jsUndefined());
2603             break;
2604         case ToThisResult::GlobalThis:
2605             m_state.setFoundConstants(true);
2606             destination.setType(m_graph, SpecObject);
2607             break;
2608         case ToThisResult::Dynamic:
2609             if (strictMode)
2610                 destination.makeHeapTop();
2611             else {
2612                 destination = source;
2613                 destination.merge(SpecObject);
</pre>
<hr />
<pre>
2627                         m_state.setFoundConstants(true);
2628                         didFoldClobberWorld();
2629                         setForNode(node, structure);
2630                         break;
2631                     }
2632                 }
2633             }
2634         }
2635         clobberWorld();
2636         setTypeForNode(node, SpecFinalObject);
2637         break;
2638     }
2639 
2640     case NewObject:
2641         ASSERT(!!node-&gt;structure().get());
2642         setForNode(node, node-&gt;structure());
2643         break;
2644 
2645     case ObjectCreate: {
2646         if (JSValue base = forNode(node-&gt;child1()).m_value) {
<span class="line-modified">2647             JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-modified">2648             Structure* structure = nullptr;</span>
<span class="line-added">2649             if (base.isNull())</span>
<span class="line-added">2650                 structure = globalObject-&gt;nullPrototypeObjectStructure();</span>
<span class="line-added">2651             else if (base.isObject())</span>
<span class="line-added">2652                 structure = globalObject-&gt;vm().structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());</span>
<span class="line-added">2653 </span>
<span class="line-added">2654             if (structure) {</span>
2655                 m_state.setFoundConstants(true);
2656                 if (node-&gt;child1().useKind() == UntypedUse)
2657                     didFoldClobberWorld();
<span class="line-modified">2658                 setForNode(node, structure);</span>
2659                 break;
2660             }



2661         }
2662         if (node-&gt;child1().useKind() == UntypedUse)
2663             clobberWorld();
2664         setTypeForNode(node, SpecFinalObject);
2665         break;
2666     }
2667 
2668     case ObjectKeys: {
2669         if (node-&gt;child1().useKind() == ObjectUse) {
2670             auto&amp; structureSet = forNode(node-&gt;child1()).m_structure;
2671             if (structureSet.isFinite() &amp;&amp; structureSet.size() == 1) {
2672                 RegisteredStructure structure = structureSet.onlyStructure();
2673                 if (auto* rareData = structure-&gt;rareDataConcurrently()) {
2674                     if (!!rareData-&gt;cachedOwnKeysConcurrently()) {
2675                         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2676                             m_state.setFoundConstants(true);
2677                             didFoldClobberWorld();
2678                             setTypeForNode(node, SpecArray);
2679                             break;
2680                         }
</pre>
<hr />
<pre>
2767 
2768     case NewAsyncGeneratorFunction:
2769         setForNode(node,
2770             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;asyncGeneratorFunctionStructure());
2771         break;
2772 
2773     case NewAsyncFunction:
2774         setForNode(node,
2775             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;asyncFunctionStructure());
2776         break;
2777 
2778     case NewFunction: {
2779         JSGlobalObject* globalObject = m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic);
2780         Structure* structure = JSFunction::selectStructureForNewFuncExp(globalObject, node-&gt;castOperand&lt;FunctionExecutable*&gt;());
2781         setForNode(node, structure);
2782         break;
2783     }
2784 
2785     case GetCallee:
2786         if (FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(m_vm, m_codeBlock-&gt;ownerExecutable())) {
<span class="line-modified">2787             if (JSFunction* function = executable-&gt;singleton().inferredValue()) {</span>
<span class="line-modified">2788                 m_graph.watchpoints().addLazily(executable);</span>


2789                 setConstant(node, *m_graph.freeze(function));
2790                 break;
2791             }
2792         }
<span class="line-modified">2793         setTypeForNode(node, SpecFunction | SpecObjectOther);</span>
2794         break;
2795 
2796     case GetArgumentCountIncludingThis:
2797         setTypeForNode(node, SpecInt32Only);
2798         break;
2799 
2800     case SetCallee:
2801     case SetArgumentCountIncludingThis:
2802         break;
2803 
2804     case GetRestLength:
2805         setNonCellTypeForNode(node, SpecInt32Only);
2806         break;
2807 
2808     case GetGetter: {
<span class="line-modified">2809         if (JSValue base = forNode(node-&gt;child1()).m_value) {</span>
<span class="line-modified">2810             GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(m_vm, base);</span>
<span class="line-modified">2811             if (getterSetter &amp;&amp; !getterSetter-&gt;isGetterNull()) {</span>

2812                 setConstant(node, *m_graph.freeze(getterSetter-&gt;getterConcurrently()));
2813                 break;
2814             }
2815         }
2816 
2817         setTypeForNode(node, SpecObject);
2818         break;
2819     }
2820 
2821     case GetSetter: {
<span class="line-modified">2822         if (JSValue base = forNode(node-&gt;child1()).m_value) {</span>
<span class="line-modified">2823             GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(m_vm, base);</span>
<span class="line-modified">2824             if (getterSetter &amp;&amp; !getterSetter-&gt;isSetterNull()) {</span>

2825                 setConstant(node, *m_graph.freeze(getterSetter-&gt;setterConcurrently()));
2826                 break;
2827             }
2828         }
2829 
2830         setTypeForNode(node, SpecObject);
2831         break;
2832     }
2833 
2834     case GetScope:
2835         if (JSValue base = forNode(node-&gt;child1()).m_value) {
2836             if (JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, base)) {
2837                 setConstant(node, *m_graph.freeze(function-&gt;scope()));
2838                 break;
2839             }
2840         }
2841         setTypeForNode(node, SpecObjectOther);
2842         break;
2843 
2844     case SkipScope: {
<span class="line-modified">2845         if (JSValue child = forNode(node-&gt;child1()).value()) {</span>
<span class="line-modified">2846             if (JSScope* scope = jsDynamicCast&lt;JSScope*&gt;(m_vm, child)) {</span>
<span class="line-modified">2847                 if (JSScope* nextScope = scope-&gt;next()) {</span>
<span class="line-modified">2848                     setConstant(node, *m_graph.freeze(JSValue(nextScope)));</span>
<span class="line-added">2849                     break;</span>
<span class="line-added">2850                 }</span>
<span class="line-added">2851             }</span>
2852         }
2853         setTypeForNode(node, SpecObjectOther);
2854         break;
2855     }
2856 
2857     case GetGlobalObject: {
2858         JSValue child = forNode(node-&gt;child1()).value();
2859         if (child) {
2860             setConstant(node, *m_graph.freeze(JSValue(asObject(child)-&gt;globalObject(m_vm))));
2861             break;
2862         }
2863 
2864         if (forNode(node-&gt;child1()).m_structure.isFinite()) {
2865             JSGlobalObject* globalObject = nullptr;
2866             bool ok = true;
2867             forNode(node-&gt;child1()).m_structure.forEach(
2868                 [&amp;] (RegisteredStructure structure) {
2869                     if (!globalObject)
2870                         globalObject = structure-&gt;globalObject();
2871                     else if (globalObject != structure-&gt;globalObject())
</pre>
<hr />
<pre>
3322         // right now. That&#39;s probably not optimal. In some cases, we may perform an optimization (usually
3323         // by something other than AI, maybe by CSE for example) that obscures AI&#39;s view of the structure
3324         // at the point where GetByOffset runs. Currently, when that happens, we&#39;ll have to rely entirely
3325         // on the type that ByteCodeParser was able to prove.
3326         AbstractValue value = m_graph.inferredValueForProperty(
3327             forNode(node-&gt;child2()), data.offset, m_state.structureClobberState());
3328 
3329         // If we decide that there does not exist any value that this can return, then it&#39;s probably
3330         // because the compilation was already invalidated.
3331         if (value.isClear())
3332             m_state.setIsValid(false);
3333 
3334         setForNode(node, value);
3335         if (value.m_value)
3336             m_state.setFoundConstants(true);
3337         break;
3338     }
3339 
3340     case GetGetterSetterByOffset: {
3341         StorageAccessData&amp; data = node-&gt;storageAccessData();
<span class="line-modified">3342         AbstractValue base = forNode(node-&gt;child2());</span>
<span class="line-added">3343         JSValue result = m_graph.tryGetConstantProperty(base, data.offset);</span>
3344         if (result &amp;&amp; jsDynamicCast&lt;GetterSetter*&gt;(m_vm, result)) {
3345             setConstant(node, *m_graph.freeze(result));
3346             break;
3347         }
3348 
<span class="line-modified">3349         if (base.value() &amp;&amp; base.value().isObject()) {</span>
<span class="line-added">3350             setForNode(node, asObject(base.value())-&gt;globalObject()-&gt;getterSetterStructure());</span>
<span class="line-added">3351             break;</span>
<span class="line-added">3352         }</span>
<span class="line-added">3353 </span>
<span class="line-added">3354         setTypeForNode(node, SpecObjectOther);</span>
3355         break;
3356     }
3357 
3358     case MultiGetByOffset: {
3359         // This code will filter the base value in a manner that is possibly different (either more
3360         // or less precise) than the way it would be filtered if this was strength-reduced to a
3361         // CheckStructure. This is fine. It&#39;s legal for different passes over the code to prove
3362         // different things about the code, so long as all of them are sound. That even includes
3363         // one guy proving that code should never execute (due to a contradiction) and another guy
3364         // not finding that contradiction. If someone ever proved that there would be a
3365         // contradiction then there must always be a contradiction even if subsequent passes don&#39;t
3366         // realize it. This is the case here.
3367 
3368         // Ordinarily you have to be careful with calling setFoundConstants()
3369         // because of the effect on compile times, but this node is FTL-only.
3370         m_state.setFoundConstants(true);
3371 
3372         AbstractValue base = forNode(node-&gt;child1());
3373         RegisteredStructureSet baseSet;
3374         AbstractValue result;
</pre>
<hr />
<pre>
3590     case DefineDataProperty:
3591     case DefineAccessorProperty:
3592         clobberWorld();
3593         break;
3594 
3595     case InById: {
3596         // FIXME: We can determine when the property definitely exists based on abstract
3597         // value information.
3598         clobberWorld();
3599         filter(node-&gt;child1(), SpecObject);
3600         setNonCellTypeForNode(node, SpecBoolean);
3601         break;
3602     }
3603 
3604     case InByVal: {
3605         AbstractValue&amp; property = forNode(node-&gt;child2());
3606         if (JSValue constant = property.value()) {
3607             if (constant.isString()) {
3608                 JSString* string = asString(constant);
3609                 const StringImpl* impl = string-&gt;tryGetValueImpl();
<span class="line-modified">3610                 if (impl &amp;&amp; impl-&gt;isAtom())</span>
3611                     m_state.setFoundConstants(true);
3612             }
3613         }
3614 
3615         // FIXME: We can determine when the property definitely exists based on abstract
3616         // value information.
3617         clobberWorld();
3618         filter(node-&gt;child1(), SpecObject);
3619         setNonCellTypeForNode(node, SpecBoolean);
3620         break;
3621     }
3622 
3623     case HasOwnProperty: {
3624         clobberWorld();
3625         setNonCellTypeForNode(node, SpecBoolean);
3626         break;
3627     }
3628 
3629     case GetEnumerableLength: {
3630         setNonCellTypeForNode(node, SpecInt32Only);
</pre>
<hr />
<pre>
3925     case SetFunctionName: {
3926         clobberWorld();
3927         break;
3928     }
3929 
3930     case StoreBarrier:
3931     case FencedStoreBarrier: {
3932         filter(node-&gt;child1(), SpecCell);
3933         break;
3934     }
3935 
3936     case DataViewGetInt: {
3937         DataViewData data = node-&gt;dataViewData();
3938         if (data.byteSize &lt; 4)
3939             setNonCellTypeForNode(node, SpecInt32Only);
3940         else {
3941             ASSERT(data.byteSize == 4);
3942             if (data.isSigned)
3943                 setNonCellTypeForNode(node, SpecInt32Only);
3944             else
<span class="line-modified">3945                 setNonCellTypeForNode(node, SpecInt52Any);</span>
3946         }
3947         break;
3948     }
3949 
3950     case DataViewGetFloat: {
3951         setNonCellTypeForNode(node, SpecFullDouble);
3952         break;
3953     }
3954 
3955     case DataViewSet: {
3956         break;
3957     }
3958 
3959     case Unreachable:
3960         // It may be that during a previous run of AI we proved that something was unreachable, but
3961         // during this run of AI we forget that it&#39;s unreachable. AI&#39;s proofs don&#39;t have to get
3962         // monotonically stronger over time. So, we don&#39;t assert that AI doesn&#39;t reach the
3963         // Unreachable. We have no choice but to take our past proof at face value. Otherwise we&#39;ll
3964         // crash whenever AI fails to be as powerful on run K as it was on run K-1.
3965         m_state.setIsValid(false);
</pre>
<hr />
<pre>
4077 }
4078 
4079 template&lt;typename AbstractStateType&gt;
4080 void AbstractInterpreter&lt;AbstractStateType&gt;::clobberStructures()
4081 {
4082     m_state.clobberStructures();
4083     m_state.mergeClobberState(AbstractInterpreterClobberState::ClobberedStructures);
4084     m_state.setStructureClobberState(StructuresAreClobbered);
4085 }
4086 
4087 template&lt;typename AbstractStateType&gt;
4088 void AbstractInterpreter&lt;AbstractStateType&gt;::didFoldClobberStructures()
4089 {
4090     m_state.mergeClobberState(AbstractInterpreterClobberState::FoldedClobber);
4091 }
4092 
4093 template&lt;typename AbstractStateType&gt;
4094 void AbstractInterpreter&lt;AbstractStateType&gt;::observeTransition(
4095     unsigned clobberLimit, RegisteredStructure from, RegisteredStructure to)
4096 {
<span class="line-added">4097     // Stop performing precise structure transition tracking.</span>
<span class="line-added">4098     // Precise structure transition tracking shows quadratic complexity for # of nodes in a basic block.</span>
<span class="line-added">4099     // If it is too large, we conservatively clobber all the structures.</span>
<span class="line-added">4100     if (m_state.block()-&gt;size() &gt; Options::maxDFGNodesInBasicBlockForPreciseAnalysis()) {</span>
<span class="line-added">4101         clobberStructures();</span>
<span class="line-added">4102         return;</span>
<span class="line-added">4103     }</span>
<span class="line-added">4104 </span>
4105     AbstractValue::TransitionObserver transitionObserver(from, to);
4106     forAllValues(clobberLimit, transitionObserver);
4107 
4108     ASSERT(!from-&gt;dfgShouldWatch()); // We don&#39;t need to claim to be in a clobbered state because &#39;from&#39; was never watchable (during the time we were compiling), hence no constants ever introduced into the DFG IR that ever had a watchable structure would ever have the same structure as from.
4109 
4110     m_state.mergeClobberState(AbstractInterpreterClobberState::ObservedTransitions);
4111 }
4112 
4113 template&lt;typename AbstractStateType&gt;
4114 void AbstractInterpreter&lt;AbstractStateType&gt;::observeTransitions(
4115     unsigned clobberLimit, const TransitionVector&amp; vector)
4116 {
4117     if (vector.isEmpty())
4118         return;
4119 
<span class="line-added">4120     // Stop performing precise structure transition tracking.</span>
<span class="line-added">4121     // Precise structure transition tracking shows quadratic complexity for # of nodes in a basic block.</span>
<span class="line-added">4122     // If it is too large, we conservatively clobber all the structures.</span>
<span class="line-added">4123     if (m_state.block()-&gt;size() &gt; Options::maxDFGNodesInBasicBlockForPreciseAnalysis()) {</span>
<span class="line-added">4124         clobberStructures();</span>
<span class="line-added">4125         return;</span>
<span class="line-added">4126     }</span>
<span class="line-added">4127 </span>
4128     AbstractValue::TransitionsObserver transitionsObserver(vector);
4129     forAllValues(clobberLimit, transitionsObserver);
4130 
4131     if (!ASSERT_DISABLED) {
4132         // We don&#39;t need to claim to be in a clobbered state because none of the Transition::previous structures are watchable.
4133         for (unsigned i = vector.size(); i--;)
4134             ASSERT(!vector[i].previous-&gt;dfgShouldWatch());
4135     }
4136 
4137     m_state.mergeClobberState(AbstractInterpreterClobberState::ObservedTransitions);
4138 }
4139 
4140 template&lt;typename AbstractStateType&gt;
4141 void AbstractInterpreter&lt;AbstractStateType&gt;::dump(PrintStream&amp; out) const
4142 {
4143     const_cast&lt;AbstractInterpreter&lt;AbstractStateType&gt;*&gt;(this)-&gt;dump(out);
4144 }
4145 
4146 template&lt;typename AbstractStateType&gt;
4147 void AbstractInterpreter&lt;AbstractStateType&gt;::dump(PrintStream&amp; out)
</pre>
</td>
</tr>
</table>
<center><a href="DFGAbstractInterpreter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGAbstractValue.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>