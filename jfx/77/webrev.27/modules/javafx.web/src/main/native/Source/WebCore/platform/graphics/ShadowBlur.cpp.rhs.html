<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ShadowBlur.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 Apple Inc. All rights reserved.
  3  * Copyright (C) 2010 Sencha, Inc. All rights reserved.
  4  * Copyright (C) 2010 Igalia S.L. All rights reserved.
  5  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
  6  * Copyright (C) 2013 Digia Plc. and/or its subsidiary(-ies).
  7  *
  8  * Redistribution and use in source and binary forms, with or without
  9  * modification, are permitted provided that the following conditions
 10  * are met:
 11  * 1. Redistributions of source code must retain the above copyright
 12  *    notice, this list of conditions and the following disclaimer.
 13  * 2. Redistributions in binary form must reproduce the above copyright
 14  *    notice, this list of conditions and the following disclaimer in the
 15  *    documentation and/or other materials provided with the distribution.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 19  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 20  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 21  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 22  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 23  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 24  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 25  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 27  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;ShadowBlur.h&quot;
 32 
 33 #include &quot;AffineTransform.h&quot;
 34 #include &quot;FloatQuad.h&quot;
 35 #include &quot;GraphicsContext.h&quot;
 36 #include &quot;ImageBuffer.h&quot;
 37 #include &quot;Timer.h&quot;
 38 #include &lt;wtf/MathExtras.h&gt;
 39 #include &lt;wtf/NeverDestroyed.h&gt;
 40 #include &lt;wtf/Noncopyable.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 enum {
 45     LeftLobe = 0,
 46     RightLobe = 1
 47 };
 48 
 49 #if USE(CG)
 50 static inline int roundUpToMultipleOf32(int d)
 51 {
 52     return (1 + (d &gt;&gt; 5)) &lt;&lt; 5;
 53 }
 54 
 55 // ShadowBlur needs a scratch image as the buffer for the blur filter.
 56 // Instead of creating and destroying the buffer for every operation,
 57 // we create a buffer which will be automatically purged via a timer.
 58 class ScratchBuffer {
 59     WTF_MAKE_FAST_ALLOCATED;
 60 public:
 61     ScratchBuffer()
 62         : m_purgeTimer(*this, &amp;ScratchBuffer::clearScratchBuffer)
 63         , m_lastWasInset(false)
 64 #if !ASSERT_DISABLED
 65         , m_bufferInUse(false)
 66 #endif
 67     {
 68     }
 69 
 70     ImageBuffer* getScratchBuffer(const IntSize&amp; size)
 71     {
 72         ASSERT(!m_bufferInUse);
 73 #if !ASSERT_DISABLED
 74         m_bufferInUse = true;
 75 #endif
 76         // We do not need to recreate the buffer if the current buffer is large enough.
 77         if (m_imageBuffer &amp;&amp; m_imageBuffer-&gt;logicalSize().width() &gt;= size.width() &amp;&amp; m_imageBuffer-&gt;logicalSize().height() &gt;= size.height())
 78             return m_imageBuffer.get();
 79 
 80         // Round to the nearest 32 pixels so we do not grow the buffer for similar sized requests.
 81         IntSize roundedSize(roundUpToMultipleOf32(size.width()), roundUpToMultipleOf32(size.height()));
 82 
 83         clearScratchBuffer();
 84 
 85         // ShadowBlur is not used with accelerated drawing, so it&#39;s OK to make an unconditionally unaccelerated buffer.
 86         m_imageBuffer = ImageBuffer::create(roundedSize, Unaccelerated, 1);
 87         return m_imageBuffer.get();
 88     }
 89 
 90     bool setCachedShadowValues(const FloatSize&amp; radius, const Color&amp; color, const FloatRect&amp; shadowRect, const FloatRoundedRect::Radii&amp; radii, const FloatSize&amp; layerSize)
 91     {
 92         if (!m_lastWasInset &amp;&amp; m_lastRadius == radius &amp;&amp; m_lastColor == color &amp;&amp; m_lastShadowRect == shadowRect &amp;&amp;  m_lastRadii == radii &amp;&amp; m_lastLayerSize == layerSize)
 93             return false;
 94 
 95         m_lastWasInset = false;
 96         m_lastRadius = radius;
 97         m_lastColor = color;
 98         m_lastShadowRect = shadowRect;
 99         m_lastRadii = radii;
100         m_lastLayerSize = layerSize;
101 
102         return true;
103     }
104 
105     bool setCachedInsetShadowValues(const FloatSize&amp; radius, const Color&amp; color, const FloatRect&amp; bounds, const FloatRect&amp; shadowRect, const FloatRoundedRect::Radii&amp; radii)
106     {
107         if (m_lastWasInset &amp;&amp; m_lastRadius == radius &amp;&amp; m_lastColor == color &amp;&amp; m_lastInsetBounds == bounds &amp;&amp; shadowRect == m_lastShadowRect &amp;&amp; radii == m_lastRadii)
108             return false;
109 
110         m_lastWasInset = true;
111         m_lastInsetBounds = bounds;
112         m_lastRadius = radius;
113         m_lastColor = color;
114         m_lastShadowRect = shadowRect;
115         m_lastRadii = radii;
116 
117         return true;
118     }
119 
120     void scheduleScratchBufferPurge()
121     {
122 #if !ASSERT_DISABLED
123         m_bufferInUse = false;
124 #endif
125         if (m_purgeTimer.isActive())
126             m_purgeTimer.stop();
127 
128         const Seconds scratchBufferPurgeInterval { 2_s };
129         m_purgeTimer.startOneShot(scratchBufferPurgeInterval);
130     }
131 
132     static ScratchBuffer&amp; singleton();
133 
134 private:
135     void clearScratchBuffer()
136     {
137         m_imageBuffer = nullptr;
138         m_lastRadius = FloatSize();
139         m_lastLayerSize = FloatSize();
140     }
141 
142     std::unique_ptr&lt;ImageBuffer&gt; m_imageBuffer;
143     Timer m_purgeTimer;
144 
145     FloatRect m_lastInsetBounds;
146     FloatRect m_lastShadowRect;
147     FloatRoundedRect::Radii m_lastRadii;
148     Color m_lastColor;
149     FloatSize m_lastRadius;
150     bool m_lastWasInset;
151     FloatSize m_lastLayerSize;
152 
153 #if !ASSERT_DISABLED
154     bool m_bufferInUse;
155 #endif
156 };
157 
158 ScratchBuffer&amp; ScratchBuffer::singleton()
159 {
160     static NeverDestroyed&lt;ScratchBuffer&gt; scratchBuffer;
161     return scratchBuffer;
162 }
163 
164 static float radiusToLegacyRadius(float radius)
165 {
166     return radius &gt; 8 ? 8 + 4 * sqrt((radius - 8) / 2) : radius;
167 }
168 #endif
169 
170 static const int templateSideLength = 1;
171 
172 ShadowBlur::ShadowBlur() = default;
173 
174 ShadowBlur::ShadowBlur(const FloatSize&amp; radius, const FloatSize&amp; offset, const Color&amp; color, bool shadowsIgnoreTransforms)
175     : m_color(color)
176     , m_blurRadius(radius)
177     , m_offset(offset)
178     , m_shadowsIgnoreTransforms(shadowsIgnoreTransforms)
179 {
180     updateShadowBlurValues();
181 }
182 
183 ShadowBlur::ShadowBlur(const GraphicsContextState&amp; state)
184     : m_color(state.shadowColor)
185     , m_blurRadius(state.shadowBlur, state.shadowBlur)
186     , m_offset(state.shadowOffset)
<a name="1" id="anc1"></a>
187     , m_shadowsIgnoreTransforms(state.shadowsIgnoreTransforms)
188 {
189 #if USE(CG)
190     if (state.shadowsUseLegacyRadius) {
191         float shadowBlur = radiusToLegacyRadius(state.shadowBlur);
192         m_blurRadius = FloatSize(shadowBlur, shadowBlur);
193     }
194 #endif
195     updateShadowBlurValues();
196 }
197 
198 void ShadowBlur::setShadowValues(const FloatSize&amp; radius, const FloatSize&amp; offset, const Color&amp; color, bool ignoreTransforms)
199 {
200     m_blurRadius = radius;
201     m_offset = offset;
202     m_color = color;
203     m_shadowsIgnoreTransforms = ignoreTransforms;
204 
205     updateShadowBlurValues();
206 }
207 
208 void ShadowBlur::updateShadowBlurValues()
209 {
210     // Limit blur radius to 128 to avoid lots of very expensive blurring.
211     m_blurRadius = m_blurRadius.shrunkTo(FloatSize(128, 128));
212 
213     // The type of shadow is decided by the blur radius, shadow offset, and shadow color.
214     if (!m_color.isVisible()) {
215         // Can&#39;t paint the shadow with invalid or invisible color.
216         m_type = NoShadow;
217     } else if (m_blurRadius.width() &gt; 0 || m_blurRadius.height() &gt; 0) {
218         // Shadow is always blurred, even the offset is zero.
219         m_type = BlurShadow;
220     } else if (!m_offset.width() &amp;&amp; !m_offset.height()) {
221         // Without blur and zero offset means the shadow is fully hidden.
222         m_type = NoShadow;
223     } else
224         m_type = SolidShadow;
225 }
226 
227 // Instead of integer division, we use 17.15 for fixed-point division.
228 static const int blurSumShift = 15;
229 
230 // Takes a two dimensional array with three rows and two columns for the lobes.
231 static void calculateLobes(int lobes[][2], float blurRadius, bool shadowsIgnoreTransforms)
232 {
233     int diameter;
234     if (shadowsIgnoreTransforms)
235         diameter = std::max(2, static_cast&lt;int&gt;(floorf((2 / 3.f) * blurRadius))); // Canvas shadow. FIXME: we should adjust the blur radius higher up.
236     else {
237         // http://dev.w3.org/csswg/css3-background/#box-shadow
238         // Approximate a Gaussian blur with a standard deviation equal to half the blur radius,
239         // which http://www.w3.org/TR/SVG/filters.html#feGaussianBlurElement tell us how to do.
240         // However, shadows rendered according to that spec will extend a little further than m_blurRadius,
241         // so we apply a fudge factor to bring the radius down slightly.
242         float stdDev = blurRadius / 2;
243         const float gaussianKernelFactor = 3 / 4.f * sqrtf(2 * piFloat);
244         const float fudgeFactor = 0.88f;
245         diameter = std::max(2, static_cast&lt;int&gt;(floorf(stdDev * gaussianKernelFactor * fudgeFactor + 0.5f)));
246     }
247 
248     if (diameter &amp; 1) {
249         // if d is odd, use three box-blurs of size &#39;d&#39;, centered on the output pixel.
250         int lobeSize = (diameter - 1) / 2;
251         lobes[0][LeftLobe] = lobeSize;
252         lobes[0][RightLobe] = lobeSize;
253         lobes[1][LeftLobe] = lobeSize;
254         lobes[1][RightLobe] = lobeSize;
255         lobes[2][LeftLobe] = lobeSize;
256         lobes[2][RightLobe] = lobeSize;
257     } else {
258         // if d is even, two box-blurs of size &#39;d&#39; (the first one centered on the pixel boundary
259         // between the output pixel and the one to the left, the second one centered on the pixel
260         // boundary between the output pixel and the one to the right) and one box blur of size &#39;d+1&#39; centered on the output pixel
261         int lobeSize = diameter / 2;
262         lobes[0][LeftLobe] = lobeSize;
263         lobes[0][RightLobe] = lobeSize - 1;
264         lobes[1][LeftLobe] = lobeSize - 1;
265         lobes[1][RightLobe] = lobeSize;
266         lobes[2][LeftLobe] = lobeSize;
267         lobes[2][RightLobe] = lobeSize;
268     }
269 }
270 
271 void ShadowBlur::clear()
272 {
273     m_type = NoShadow;
274     m_color = Color();
275     m_blurRadius = FloatSize();
276     m_offset = FloatSize();
277 }
278 
279 void ShadowBlur::blurLayerImage(unsigned char* imageData, const IntSize&amp; size, int rowStride)
280 {
281     const int channels[4] = { 3, 0, 1, 3 };
282 
283     int lobes[3][2]; // indexed by pass, and left/right lobe
284     calculateLobes(lobes, m_blurRadius.width(), m_shadowsIgnoreTransforms);
285 
286     // First pass is horizontal.
287     int stride = 4;
288     int delta = rowStride;
289     int final = size.height();
290     int dim = size.width();
291 
292     // Two stages: horizontal and vertical
293     for (int pass = 0; pass &lt; 2; ++pass) {
294         unsigned char* pixels = imageData;
295 
296         if (!pass &amp;&amp; !m_blurRadius.width())
297             final = 0; // Do no work if horizonal blur is zero.
298 
299         for (int j = 0; j &lt; final; ++j, pixels += delta) {
300             // For each step, we blur the alpha in a channel and store the result
301             // in another channel for the subsequent step.
302             // We use sliding window algorithm to accumulate the alpha values.
303             // This is much more efficient than computing the sum of each pixels
304             // covered by the box kernel size for each x.
305             for (int step = 0; step &lt; 3; ++step) {
306                 int side1 = lobes[step][LeftLobe];
307                 int side2 = lobes[step][RightLobe];
308                 int pixelCount = side1 + 1 + side2;
309                 int invCount = ((1 &lt;&lt; blurSumShift) + pixelCount - 1) / pixelCount;
310                 int ofs = 1 + side2;
311                 int alpha1 = pixels[channels[step]];
312                 int alpha2 = pixels[(dim - 1) * stride + channels[step]];
313 
314                 unsigned char* ptr = pixels + channels[step + 1];
315                 unsigned char* prev = pixels + stride + channels[step];
316                 unsigned char* next = pixels + ofs * stride + channels[step];
317 
318                 int i;
319                 int sum = side1 * alpha1 + alpha1;
320                 int limit = (dim &lt; side2 + 1) ? dim : side2 + 1;
321 
322                 for (i = 1; i &lt; limit; ++i, prev += stride)
323                     sum += *prev;
324 
325                 if (limit &lt;= side2)
326                     sum += (side2 - limit + 1) * alpha2;
327 
328                 limit = (side1 &lt; dim) ? side1 : dim;
329                 for (i = 0; i &lt; limit; ptr += stride, next += stride, ++i, ++ofs) {
330                     *ptr = (sum * invCount) &gt;&gt; blurSumShift;
331                     sum += ((ofs &lt; dim) ? *next : alpha2) - alpha1;
332                 }
333 
334                 prev = pixels + channels[step];
335                 for (; ofs &lt; dim; ptr += stride, prev += stride, next += stride, ++i, ++ofs) {
336                     *ptr = (sum * invCount) &gt;&gt; blurSumShift;
337                     sum += (*next) - (*prev);
338                 }
339 
340                 for (; i &lt; dim; ptr += stride, prev += stride, ++i) {
341                     *ptr = (sum * invCount) &gt;&gt; blurSumShift;
342                     sum += alpha2 - (*prev);
343                 }
344             }
345         }
346 
347         // Last pass is vertical.
348         stride = rowStride;
349         delta = 4;
350         final = size.width();
351         dim = size.height();
352 
353         if (!m_blurRadius.height())
354             break;
355 
356         if (m_blurRadius.width() != m_blurRadius.height())
357             calculateLobes(lobes, m_blurRadius.height(), m_shadowsIgnoreTransforms);
358     }
359 }
360 
361 void ShadowBlur::adjustBlurRadius(const AffineTransform&amp; transform)
362 {
363     if (m_shadowsIgnoreTransforms)
364         m_blurRadius.scale(1 / static_cast&lt;float&gt;(transform.xScale()), 1 / static_cast&lt;float&gt;(transform.yScale()));
365 }
366 
367 IntSize ShadowBlur::blurredEdgeSize() const
368 {
369     IntSize edgeSize = expandedIntSize(m_blurRadius);
370 
371     // To avoid slowing down blurLayerImage() for radius == 1, we give it two empty pixels on each side.
372     if (edgeSize.width() == 1)
373         edgeSize.setWidth(2);
374 
375     if (edgeSize.height() == 1)
376         edgeSize.setHeight(2);
377 
378     return edgeSize;
379 }
380 
<a name="2" id="anc2"></a><span class="line-modified">381 Optional&lt;ShadowBlur::LayerImageProperties&gt; ShadowBlur::calculateLayerBoundingRect(const AffineTransform&amp; transform, const FloatRect&amp; shadowedRect, const IntRect&amp; clipRect)</span>
382 {
<a name="3" id="anc3"></a><span class="line-added">383     LayerImageProperties calculatedLayerImageProperties;</span>
<span class="line-added">384 </span>
385     IntSize edgeSize = blurredEdgeSize();
386 
387     // Calculate the destination of the blurred and/or transformed layer.
388     FloatRect layerRect;
389     IntSize inflation;
390 
391     if (m_shadowsIgnoreTransforms &amp;&amp; !transform.isIdentity()) {
392         FloatQuad transformedPolygon = transform.mapQuad(FloatQuad(shadowedRect));
393         transformedPolygon.move(m_offset);
394         layerRect = transform.inverse().valueOr(AffineTransform()).mapQuad(transformedPolygon).boundingBox();
395     } else {
396         layerRect = shadowedRect;
397         layerRect.move(m_offset);
398     }
399 
400     // We expand the area by the blur radius to give extra space for the blur transition.
401     if (m_type == BlurShadow) {
402         layerRect.inflateX(edgeSize.width());
403         layerRect.inflateY(edgeSize.height());
404         inflation = edgeSize;
405     }
406 
407     FloatRect unclippedLayerRect = layerRect;
408 
409     if (!clipRect.contains(enclosingIntRect(layerRect))) {
410         // If we are totally outside the clip region, we aren&#39;t painting at all.
411         if (intersection(layerRect, clipRect).isEmpty())
<a name="4" id="anc4"></a><span class="line-modified">412             return WTF::nullopt;</span>
413 
414         IntRect inflatedClip = clipRect;
415         // Pixels at the edges can be affected by pixels outside the buffer,
416         // so intersect with the clip inflated by the blur.
417         if (m_type == BlurShadow) {
418             inflatedClip.inflateX(edgeSize.width());
419             inflatedClip.inflateY(edgeSize.height());
420         } else {
421             // Enlarge the clipping area 1 pixel so that the fill does not
422             // bleed (due to antialiasing) even if the unaligned clip rect occurred
423             inflatedClip.inflateX(1);
424             inflatedClip.inflateY(1);
425         }
426 
427         layerRect.intersect(inflatedClip);
428     }
429 
430     IntSize frameSize = inflation;
431     frameSize.scale(2);
<a name="5" id="anc5"></a><span class="line-modified">432     calculatedLayerImageProperties.shadowedResultSize = FloatSize(shadowedRect.width() + frameSize.width(), shadowedRect.height() + frameSize.height());</span>
<span class="line-modified">433     calculatedLayerImageProperties.layerOrigin = FloatPoint(layerRect.x(), layerRect.y());</span>
<span class="line-modified">434     calculatedLayerImageProperties.layerSize = layerRect.size();</span>
435 
436     const FloatPoint unclippedLayerOrigin = FloatPoint(unclippedLayerRect.x(), unclippedLayerRect.y());
<a name="6" id="anc6"></a><span class="line-modified">437     const FloatSize clippedOut = unclippedLayerOrigin - calculatedLayerImageProperties.layerOrigin;</span>
438 
439     // Set the origin as the top left corner of the scratch image, or, in case there&#39;s a clipped
440     // out region, set the origin accordingly to the full bounding rect&#39;s top-left corner.
441     float translationX = -shadowedRect.x() + inflation.width() - fabsf(clippedOut.width());
442     float translationY = -shadowedRect.y() + inflation.height() - fabsf(clippedOut.height());
<a name="7" id="anc7"></a><span class="line-modified">443     calculatedLayerImageProperties.layerContextTranslation = FloatSize(translationX, translationY);</span>
444 
<a name="8" id="anc8"></a><span class="line-modified">445     return calculatedLayerImageProperties;</span>
446 }
447 
<a name="9" id="anc9"></a><span class="line-modified">448 void ShadowBlur::drawShadowBuffer(GraphicsContext&amp; graphicsContext, ImageBuffer&amp; layerImage, const FloatPoint&amp; layerOrigin, const FloatSize&amp; layerSize)</span>
449 {
<a name="10" id="anc10"></a>


450     GraphicsContextStateSaver stateSaver(graphicsContext);
451 
<a name="11" id="anc11"></a><span class="line-modified">452     IntSize bufferSize = layerImage.internalSize();</span>
<span class="line-modified">453     if (bufferSize != layerSize) {</span>
454         // The rect passed to clipToImageBuffer() has to be the size of the entire buffer,
455         // but we may not have cleared it all, so clip to the filled part first.
<a name="12" id="anc12"></a><span class="line-modified">456         graphicsContext.clip(FloatRect(layerOrigin, layerSize));</span>
457     }
<a name="13" id="anc13"></a><span class="line-modified">458     graphicsContext.clipToImageBuffer(layerImage, FloatRect(layerOrigin, bufferSize));</span>
459     graphicsContext.setFillColor(m_color);
460 
461     graphicsContext.clearShadow();
<a name="14" id="anc14"></a><span class="line-modified">462     graphicsContext.fillRect(FloatRect(layerOrigin, layerSize));</span>
463 }
464 
465 static void computeSliceSizesFromRadii(const IntSize&amp; twiceRadius, const FloatRoundedRect::Radii&amp; radii, int&amp; leftSlice, int&amp; rightSlice, int&amp; topSlice, int&amp; bottomSlice)
466 {
467     leftSlice = twiceRadius.width() + std::max(radii.topLeft().width(), radii.bottomLeft().width());
468     rightSlice = twiceRadius.width() + std::max(radii.topRight().width(), radii.bottomRight().width());
469 
470     topSlice = twiceRadius.height() + std::max(radii.topLeft().height(), radii.topRight().height());
471     bottomSlice = twiceRadius.height() + std::max(radii.bottomLeft().height(), radii.bottomRight().height());
472 }
473 
474 IntSize ShadowBlur::templateSize(const IntSize&amp; radiusPadding, const FloatRoundedRect::Radii&amp; radii) const
475 {
476     const int templateSideLength = 1;
477 
478     int leftSlice;
479     int rightSlice;
480     int topSlice;
481     int bottomSlice;
482 
483     IntSize blurExpansion = radiusPadding;
484     blurExpansion.scale(2);
485 
486     computeSliceSizesFromRadii(blurExpansion, radii, leftSlice, rightSlice, topSlice, bottomSlice);
487 
488     return IntSize(templateSideLength + leftSlice + rightSlice, templateSideLength + topSlice + bottomSlice);
489 }
490 
491 void ShadowBlur::drawRectShadow(GraphicsContext&amp; graphicsContext, const FloatRoundedRect&amp; shadowedRect)
492 {
493     drawRectShadow(graphicsContext.getCTM(), graphicsContext.clipBounds(), shadowedRect,
<a name="15" id="anc15"></a><span class="line-modified">494         [this, &amp;graphicsContext](ImageBuffer&amp; layerImage, const FloatPoint&amp; layerOrigin, const FloatSize&amp; layerSize) {</span>
<span class="line-modified">495             drawShadowBuffer(graphicsContext, layerImage, layerOrigin, layerSize);</span>

496         },
497         [&amp;graphicsContext](ImageBuffer&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; srcRect) {
498             GraphicsContextStateSaver stateSaver(graphicsContext);
499             graphicsContext.clearShadow();
500             graphicsContext.drawImageBuffer(image, destRect, srcRect);
501         },
502         [&amp;graphicsContext](const FloatRect&amp; rect, const Color&amp; color) {
503             GraphicsContextStateSaver stateSaver(graphicsContext);
504             graphicsContext.setFillColor(color);
505             graphicsContext.clearShadow();
506             graphicsContext.fillRect(rect);
507         });
508 }
509 
510 void ShadowBlur::drawInsetShadow(GraphicsContext&amp; graphicsContext, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect)
511 {
512     drawInsetShadow(graphicsContext.getCTM(), graphicsContext.clipBounds(), fullRect, holeRect,
<a name="16" id="anc16"></a><span class="line-modified">513         [this, &amp;graphicsContext](ImageBuffer&amp; layerImage, const FloatPoint&amp; layerOrigin, const FloatSize&amp; layerSize) {</span>
<span class="line-modified">514             drawShadowBuffer(graphicsContext, layerImage, layerOrigin, layerSize);</span>

515         },
516         [&amp;graphicsContext](ImageBuffer&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; srcRect) {
517             // Note that drawing the ImageBuffer is faster than creating a Image and drawing that,
518             // because ImageBuffer::draw() knows that it doesn&#39;t have to copy the image bits.
519             GraphicsContextStateSaver stateSaver(graphicsContext);
520             graphicsContext.clearShadow();
521             graphicsContext.drawImageBuffer(image, destRect, srcRect);
522         },
523         [&amp;graphicsContext](const FloatRect&amp; rect, const FloatRect&amp; holeRect, const Color&amp; color) {
524             Path exteriorPath;
525             exteriorPath.addRect(rect);
526             exteriorPath.addRect(holeRect);
527 
528             GraphicsContextStateSaver fillStateSaver(graphicsContext);
529             graphicsContext.setFillRule(WindRule::EvenOdd);
530             graphicsContext.setFillColor(color);
531             graphicsContext.clearShadow();
532             graphicsContext.fillPath(exteriorPath);
533         });
534 }
535 
536 void ShadowBlur::drawRectShadow(const AffineTransform&amp; transform, const IntRect&amp; clipBounds, const FloatRoundedRect&amp; shadowedRect, const DrawBufferCallback&amp; drawBuffer, const DrawImageCallback&amp; drawImage, const FillRectCallback&amp; fillRect)
537 {
<a name="17" id="anc17"></a><span class="line-modified">538     auto layerImageProperties = calculateLayerBoundingRect(transform, shadowedRect.rect(), clipBounds);</span>
<span class="line-modified">539     if (!layerImageProperties)</span>
540         return;
541 
542     adjustBlurRadius(transform);
543 
544     bool canUseTilingTechnique = true;
545 
546     // drawRectShadowWithTiling does not work with rotations.
547     // https://bugs.webkit.org/show_bug.cgi?id=45042
548     if (!transform.preservesAxisAlignment() || m_type != BlurShadow)
549         canUseTilingTechnique = false;
550 
551     IntSize edgeSize = blurredEdgeSize();
552     IntSize templateSize = this-&gt;templateSize(edgeSize, shadowedRect.radii());
553     const FloatRect&amp; rect = shadowedRect.rect();
554 
555     if (templateSize.width() &gt; rect.width() || templateSize.height() &gt; rect.height()
<a name="18" id="anc18"></a><span class="line-modified">556         || (templateSize.area() &gt; layerImageProperties-&gt;shadowedResultSize.area()))</span>
557         canUseTilingTechnique = false;
558 
559     if (canUseTilingTechnique)
<a name="19" id="anc19"></a><span class="line-modified">560         drawRectShadowWithTiling(transform, shadowedRect, templateSize, edgeSize, drawImage, fillRect, *layerImageProperties);</span>
561     else
<a name="20" id="anc20"></a><span class="line-modified">562         drawRectShadowWithoutTiling(transform, shadowedRect, *layerImageProperties, drawBuffer);</span>
563 }
564 
565 void ShadowBlur::drawInsetShadow(const AffineTransform&amp; transform, const IntRect&amp; clipBounds, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const DrawBufferCallback&amp; drawBuffer, const DrawImageCallback&amp; drawImage, const FillRectWithHoleCallback&amp; fillRectWithHole)
566 {
<a name="21" id="anc21"></a><span class="line-modified">567     auto layerImageProperties = calculateLayerBoundingRect(transform, fullRect, clipBounds);</span>
<span class="line-modified">568     if (!layerImageProperties)</span>
569         return;
570 
571     adjustBlurRadius(transform);
572 
573     bool canUseTilingTechnique = true;
574 
575     // drawRectShadowWithTiling does not work with rotations.
576     // https://bugs.webkit.org/show_bug.cgi?id=45042
577     if (!transform.preservesAxisAlignment() || m_type != BlurShadow)
578         canUseTilingTechnique = false;
579 
580     IntSize edgeSize = blurredEdgeSize();
581     IntSize templateSize = this-&gt;templateSize(edgeSize, holeRect.radii());
582     const FloatRect&amp; hRect = holeRect.rect();
583 
584     if (templateSize.width() &gt; hRect.width() || templateSize.height() &gt; hRect.height()
585         || (templateSize.width() * templateSize.height() &gt; hRect.width() * hRect.height()))
586         canUseTilingTechnique = false;
587 
588     if (canUseTilingTechnique)
589         drawInsetShadowWithTiling(transform, fullRect, holeRect, templateSize, edgeSize, drawImage, fillRectWithHole);
590     else
<a name="22" id="anc22"></a><span class="line-modified">591         drawInsetShadowWithoutTiling(transform, fullRect, holeRect, *layerImageProperties, drawBuffer);</span>
592 }
593 
<a name="23" id="anc23"></a><span class="line-modified">594 void ShadowBlur::drawRectShadowWithoutTiling(const AffineTransform&amp;, const FloatRoundedRect&amp; shadowedRect, const LayerImageProperties&amp; layerImageProperties, const DrawBufferCallback&amp; drawBuffer)</span>
595 {
<a name="24" id="anc24"></a><span class="line-modified">596     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), Unaccelerated, 1);</span>
597     if (!layerImage)
598         return;
<a name="25" id="anc25"></a>
599 
600     GraphicsContext&amp; shadowContext = layerImage-&gt;context();
601     GraphicsContextStateSaver stateSaver(shadowContext);
602     shadowContext.setFillColor(Color::black);
603 
604     {
605         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
606         GraphicsContextStateSaver stateSaver(shadowContext);
<a name="26" id="anc26"></a><span class="line-modified">607         shadowContext.translate(layerImageProperties.layerContextTranslation);</span>
608         shadowContext.setFillColor(Color::black);
609         if (shadowedRect.radii().isZero())
610             shadowContext.fillRect(shadowedRect.rect());
611         else {
612             Path path;
613             path.addRoundedRect(shadowedRect);
614             shadowContext.fillPath(path);
615         }
616 
<a name="27" id="anc27"></a><span class="line-modified">617         blurShadowBuffer(*layerImage, expandedIntSize(layerImageProperties.layerSize));</span>
618     }
<a name="28" id="anc28"></a><span class="line-modified">619     drawBuffer(*layerImage, layerImageProperties.layerOrigin, layerImageProperties.layerSize);</span>
620 }
621 
<a name="29" id="anc29"></a><span class="line-modified">622 void ShadowBlur::drawInsetShadowWithoutTiling(const AffineTransform&amp;, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const LayerImageProperties&amp; layerImageProperties, const DrawBufferCallback&amp; drawBuffer)</span>
623 {
<a name="30" id="anc30"></a><span class="line-modified">624     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), Unaccelerated, 1);</span>
625     if (!layerImage)
626         return;
<a name="31" id="anc31"></a>
627 
628     {
629         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
630         GraphicsContextStateSaver stateSaver(shadowContext);
<a name="32" id="anc32"></a><span class="line-modified">631         shadowContext.translate(layerImageProperties.layerContextTranslation);</span>
632 
633         Path path;
634         path.addRect(fullRect);
635         if (holeRect.radii().isZero())
636             path.addRect(holeRect.rect());
637         else
638             path.addRoundedRect(holeRect);
639 
640         shadowContext.setFillRule(WindRule::EvenOdd);
641         shadowContext.setFillColor(Color::black);
642         shadowContext.fillPath(path);
643 
<a name="33" id="anc33"></a><span class="line-modified">644         blurShadowBuffer(*layerImage, expandedIntSize(layerImageProperties.layerSize));</span>
645     }
646 
<a name="34" id="anc34"></a><span class="line-modified">647     drawBuffer(*layerImage, layerImageProperties.layerOrigin, layerImageProperties.layerSize);</span>
648 }
649 
650 /*
651   These functions use tiling to improve the performance of the shadow
652   drawing of rounded rectangles. The code basically does the following
653   steps:
654 
655      1. Calculate the size of the shadow template, a rectangle that
656      contains all the necessary tiles to draw the complete shadow.
657 
658      2. If that size is smaller than the real rectangle render the new
659      template rectangle and its shadow in a new surface, in other case
660      render the shadow of the real rectangle in the destination
661      surface.
662 
663      3. Calculate the sizes and positions of the tiles and their
664      destinations and use drawPattern to render the final shadow. The
665      code divides the rendering in 8 tiles:
666 
667         1 | 2 | 3
668        -----------
669         4 |   | 5
670        -----------
671         6 | 7 | 8
672 
673      The corners are directly copied from the template rectangle to the
674      real one and the side tiles are 1 pixel width, we use them as
675      tiles to cover the destination side. The corner tiles are bigger
676      than just the side of the rounded corner, we need to increase it
677      because the modifications caused by the corner over the blur
678      effect. We fill the central or outer part with solid color to complete
679      the shadow.
680  */
681 
<a name="35" id="anc35"></a><span class="line-modified">682 void ShadowBlur::drawRectShadowWithTiling(const AffineTransform&amp; transform, const FloatRoundedRect&amp; shadowedRect, const IntSize&amp; templateSize, const IntSize&amp; edgeSize, const DrawImageCallback&amp; drawImage, const FillRectCallback&amp; fillRect, const LayerImageProperties&amp; layerImageProperties)</span>
683 {
684 #if USE(CG)
<a name="36" id="anc36"></a><span class="line-modified">685     auto* layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);</span>
686 #else
<a name="37" id="anc37"></a><span class="line-modified">687     UNUSED_PARAM(layerImageProperties);</span>
<span class="line-modified">688     auto layerImageBuffer = ImageBuffer::create(templateSize, Unaccelerated, 1);</span>
<span class="line-added">689     auto* layerImage = layerImageBuffer.get();</span>
690 #endif
691 
<a name="38" id="anc38"></a><span class="line-modified">692     if (!layerImage)</span>
693         return;
694 
695     FloatRect templateShadow = FloatRect(edgeSize.width(), edgeSize.height(), templateSize.width() - 2 * edgeSize.width(), templateSize.height() - 2 * edgeSize.height());
696 
697     bool redrawNeeded = true;
698 #if USE(CG)
699     // Only redraw in the scratch buffer if its cached contents don&#39;t match our needs
<a name="39" id="anc39"></a><span class="line-modified">700     redrawNeeded = ScratchBuffer::singleton().setCachedShadowValues(m_blurRadius, m_color, templateShadow, shadowedRect.radii(), layerImageProperties.layerSize);</span>
701 #endif
702 
703     if (redrawNeeded) {
704         // Draw shadow into the ImageBuffer.
<a name="40" id="anc40"></a><span class="line-modified">705         GraphicsContext&amp; shadowContext = layerImage-&gt;context();</span>
706         GraphicsContextStateSaver shadowStateSaver(shadowContext);
707 
708         shadowContext.clearRect(FloatRect(0, 0, templateSize.width(), templateSize.height()));
709         shadowContext.setFillColor(Color::black);
710 
711         if (shadowedRect.radii().isZero())
712             shadowContext.fillRect(templateShadow);
713         else {
<a name="41" id="anc41"></a><span class="line-modified">714             Path path;</span>
715             path.addRoundedRect(FloatRoundedRect(templateShadow, shadowedRect.radii()));
<a name="42" id="anc42"></a><span class="line-modified">716             shadowContext.fillPath(path);</span>
717         }
<a name="43" id="anc43"></a><span class="line-modified">718         blurAndColorShadowBuffer(*layerImage, templateSize);</span>
719     }
720 
721     FloatSize offset = m_offset;
722     if (shadowsIgnoreTransforms())
723         offset.scale(1 / transform.xScale(), 1 / transform.yScale());
724 
725     FloatRect shadowBounds = shadowedRect.rect();
726     shadowBounds.move(offset);
727     shadowBounds.inflateX(edgeSize.width());
728     shadowBounds.inflateY(edgeSize.height());
729 
<a name="44" id="anc44"></a><span class="line-modified">730     drawLayerPiecesAndFillCenter(*layerImage, shadowBounds, shadowedRect.radii(), edgeSize, templateSize, drawImage, fillRect);</span>


731 
732 #if USE(CG)
733     ScratchBuffer::singleton().scheduleScratchBufferPurge();
734 #endif
735 }
736 
737 void ShadowBlur::drawInsetShadowWithTiling(const AffineTransform&amp; transform, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const IntSize&amp; templateSize, const IntSize&amp; edgeSize, const DrawImageCallback&amp; drawImage, const FillRectWithHoleCallback&amp; fillRectWithHole)
738 {
739 #if USE(CG)
<a name="45" id="anc45"></a><span class="line-modified">740     auto* layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);</span>
741 #else
<a name="46" id="anc46"></a><span class="line-modified">742     auto layerImageBuffer = ImageBuffer::create(templateSize, Unaccelerated, 1);</span>
<span class="line-modified">743     auto* layerImage = layerImageBuffer.get();</span>
744 #endif
745 
<a name="47" id="anc47"></a><span class="line-modified">746     if (!layerImage)</span>
747         return;
748 
749     // Draw the rectangle with hole.
750     FloatRect templateBounds(0, 0, templateSize.width(), templateSize.height());
751     FloatRect templateHole = FloatRect(edgeSize.width(), edgeSize.height(), templateSize.width() - 2 * edgeSize.width(), templateSize.height() - 2 * edgeSize.height());
752 
753     bool redrawNeeded = true;
754 #if USE(CG)
755     // Only redraw in the scratch buffer if its cached contents don&#39;t match our needs
756     redrawNeeded = ScratchBuffer::singleton().setCachedInsetShadowValues(m_blurRadius, m_color, templateBounds, templateHole, holeRect.radii());
757 #endif
758 
759     if (redrawNeeded) {
760         // Draw shadow into a new ImageBuffer.
<a name="48" id="anc48"></a><span class="line-modified">761         GraphicsContext&amp; shadowContext = layerImage-&gt;context();</span>
762         GraphicsContextStateSaver shadowStateSaver(shadowContext);
763         shadowContext.clearRect(templateBounds);
764         shadowContext.setFillRule(WindRule::EvenOdd);
765         shadowContext.setFillColor(Color::black);
766 
<a name="49" id="anc49"></a><span class="line-modified">767         Path path;</span>
768         path.addRect(templateBounds);
769         if (holeRect.radii().isZero())
770             path.addRect(templateHole);
771         else
772             path.addRoundedRect(FloatRoundedRect(templateHole, holeRect.radii()));
773 
<a name="50" id="anc50"></a><span class="line-modified">774         shadowContext.fillPath(path);</span>
775 
<a name="51" id="anc51"></a><span class="line-modified">776         blurAndColorShadowBuffer(*layerImage, templateSize);</span>
777     }
778     FloatSize offset = m_offset;
779     if (shadowsIgnoreTransforms())
780         offset.scale(1 / transform.xScale(), 1 / transform.yScale());
781 
782     FloatRect boundingRect = fullRect;
783     boundingRect.move(offset);
784 
785     FloatRect destHoleRect = holeRect.rect();
786     destHoleRect.move(offset);
787     FloatRect destHoleBounds = destHoleRect;
788     destHoleBounds.inflateX(edgeSize.width());
789     destHoleBounds.inflateY(edgeSize.height());
790 
791     // Fill the external part of the shadow (which may be visible because of offset).
792     fillRectWithHole(boundingRect, destHoleBounds, m_color);
793 
<a name="52" id="anc52"></a><span class="line-modified">794     drawLayerPieces(*layerImage, destHoleBounds, holeRect.radii(), edgeSize, templateSize, drawImage);</span>


795 
796 #if USE(CG)
797     ScratchBuffer::singleton().scheduleScratchBufferPurge();
798 #endif
799 }
800 
<a name="53" id="anc53"></a><span class="line-modified">801 void ShadowBlur::drawLayerPieces(ImageBuffer&amp; layerImage, const FloatRect&amp; shadowBounds, const FloatRoundedRect::Radii&amp; radii, const IntSize&amp; bufferPadding, const IntSize&amp; templateSize, const DrawImageCallback&amp; drawImage)</span>
802 {
803     const IntSize twiceRadius = IntSize(bufferPadding.width() * 2, bufferPadding.height() * 2);
804 
805     int leftSlice;
806     int rightSlice;
807     int topSlice;
808     int bottomSlice;
809     computeSliceSizesFromRadii(twiceRadius, radii, leftSlice, rightSlice, topSlice, bottomSlice);
810 
811     int centerWidth = shadowBounds.width() - leftSlice - rightSlice;
812     int centerHeight = shadowBounds.height() - topSlice - bottomSlice;
813     FloatRect centerRect(shadowBounds.x() + leftSlice, shadowBounds.y() + topSlice, centerWidth, centerHeight);
814 
815     // Top side.
816     FloatRect tileRect = FloatRect(leftSlice, 0, templateSideLength, topSlice);
817     FloatRect destRect = FloatRect(centerRect.x(), centerRect.y() - topSlice, centerRect.width(), topSlice);
<a name="54" id="anc54"></a><span class="line-modified">818     drawImage(layerImage, destRect, tileRect);</span>
819 
820     // Draw the bottom side.
821     tileRect.setY(templateSize.height() - bottomSlice);
822     tileRect.setHeight(bottomSlice);
823     destRect.setY(centerRect.maxY());
824     destRect.setHeight(bottomSlice);
<a name="55" id="anc55"></a><span class="line-modified">825     drawImage(layerImage, destRect, tileRect);</span>
826 
827     // Left side.
828     tileRect = FloatRect(0, topSlice, leftSlice, templateSideLength);
829     destRect = FloatRect(centerRect.x() - leftSlice, centerRect.y(), leftSlice, centerRect.height());
<a name="56" id="anc56"></a><span class="line-modified">830     drawImage(layerImage, destRect, tileRect);</span>
831 
832     // Right side.
833     tileRect.setX(templateSize.width() - rightSlice);
834     tileRect.setWidth(rightSlice);
835     destRect.setX(centerRect.maxX());
836     destRect.setWidth(rightSlice);
<a name="57" id="anc57"></a><span class="line-modified">837     drawImage(layerImage, destRect, tileRect);</span>
838 
839     // Top left corner.
840     tileRect = FloatRect(0, 0, leftSlice, topSlice);
841     destRect = FloatRect(centerRect.x() - leftSlice, centerRect.y() - topSlice, leftSlice, topSlice);
<a name="58" id="anc58"></a><span class="line-modified">842     drawImage(layerImage, destRect, tileRect);</span>
843 
844     // Top right corner.
845     tileRect = FloatRect(templateSize.width() - rightSlice, 0, rightSlice, topSlice);
846     destRect = FloatRect(centerRect.maxX(), centerRect.y() - topSlice, rightSlice, topSlice);
<a name="59" id="anc59"></a><span class="line-modified">847     drawImage(layerImage, destRect, tileRect);</span>
848 
849     // Bottom right corner.
850     tileRect = FloatRect(templateSize.width() - rightSlice, templateSize.height() - bottomSlice, rightSlice, bottomSlice);
851     destRect = FloatRect(centerRect.maxX(), centerRect.maxY(), rightSlice, bottomSlice);
<a name="60" id="anc60"></a><span class="line-modified">852     drawImage(layerImage, destRect, tileRect);</span>
853 
854     // Bottom left corner.
855     tileRect = FloatRect(0, templateSize.height() - bottomSlice, leftSlice, bottomSlice);
856     destRect = FloatRect(centerRect.x() - leftSlice, centerRect.maxY(), leftSlice, bottomSlice);
<a name="61" id="anc61"></a><span class="line-modified">857     drawImage(layerImage, destRect, tileRect);</span>
858 }
859 
<a name="62" id="anc62"></a><span class="line-modified">860 void ShadowBlur::drawLayerPiecesAndFillCenter(ImageBuffer&amp; layerImage, const FloatRect&amp; shadowBounds, const FloatRoundedRect::Radii&amp; radii, const IntSize&amp; bufferPadding, const IntSize&amp; templateSize, const DrawImageCallback&amp; drawImage, const FillRectCallback&amp; fillRect)</span>
861 {
862     const IntSize twiceRadius = IntSize(bufferPadding.width() * 2, bufferPadding.height() * 2);
863 
864     int leftSlice;
865     int rightSlice;
866     int topSlice;
867     int bottomSlice;
868     computeSliceSizesFromRadii(twiceRadius, radii, leftSlice, rightSlice, topSlice, bottomSlice);
869 
870     int centerWidth = shadowBounds.width() - leftSlice - rightSlice;
871     int centerHeight = shadowBounds.height() - topSlice - bottomSlice;
872     FloatRect centerRect(shadowBounds.x() + leftSlice, shadowBounds.y() + topSlice, centerWidth, centerHeight);
873 
874     // Fill center
875     if (!centerRect.isEmpty())
876         fillRect(centerRect, m_color);
877 
<a name="63" id="anc63"></a><span class="line-modified">878     drawLayerPieces(layerImage, shadowBounds, radii, bufferPadding, templateSize, drawImage);</span>
879 }
880 
<a name="64" id="anc64"></a><span class="line-modified">881 void ShadowBlur::blurShadowBuffer(ImageBuffer&amp; layerImage, const IntSize&amp; templateSize)</span>
882 {
883     if (m_type != BlurShadow)
884         return;
885 
886     IntRect blurRect(IntPoint(), templateSize);
<a name="65" id="anc65"></a><span class="line-modified">887     auto layerData = layerImage.getUnmultipliedImageData(blurRect);</span>
888     if (!layerData)
889         return;
890 
891     blurLayerImage(layerData-&gt;data(), blurRect.size(), blurRect.width() * 4);
<a name="66" id="anc66"></a><span class="line-modified">892     layerImage.putByteArray(*layerData, AlphaPremultiplication::Unpremultiplied, blurRect.size(), blurRect, { });</span>
893 }
894 
<a name="67" id="anc67"></a><span class="line-modified">895 void ShadowBlur::blurAndColorShadowBuffer(ImageBuffer&amp; layerImage, const IntSize&amp; templateSize)</span>
896 {
<a name="68" id="anc68"></a><span class="line-modified">897     blurShadowBuffer(layerImage, templateSize);</span>
898 
899     // Mask the image with the shadow color.
<a name="69" id="anc69"></a><span class="line-modified">900     GraphicsContext&amp; shadowContext = layerImage.context();</span>
901     GraphicsContextStateSaver stateSaver(shadowContext);
902     shadowContext.setCompositeOperation(CompositeSourceIn);
903     shadowContext.setFillColor(m_color);
904     shadowContext.fillRect(FloatRect(0, 0, templateSize.width(), templateSize.height()));
905 }
906 
907 void ShadowBlur::drawShadowLayer(const AffineTransform&amp; transform, const IntRect&amp; clipBounds, const FloatRect&amp; layerArea, const DrawShadowCallback&amp; drawShadow, const DrawBufferCallback&amp; drawBuffer)
908 {
<a name="70" id="anc70"></a><span class="line-modified">909     auto layerImageProperties = calculateLayerBoundingRect(transform, layerArea, clipBounds);</span>
<span class="line-modified">910     if (!layerImageProperties)</span>
911         return;
912 
913     adjustBlurRadius(transform);
914 
<a name="71" id="anc71"></a><span class="line-modified">915     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties-&gt;layerSize), Unaccelerated, 1);</span>
916     if (!layerImage)
917         return;
<a name="72" id="anc72"></a>
918 
919     {
920         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
921         GraphicsContextStateSaver stateSaver(shadowContext);
<a name="73" id="anc73"></a><span class="line-modified">922         shadowContext.translate(layerImageProperties-&gt;layerContextTranslation);</span>
923         drawShadow(shadowContext);
924     }
925 
<a name="74" id="anc74"></a><span class="line-modified">926     blurAndColorShadowBuffer(*layerImage, expandedIntSize(layerImageProperties-&gt;layerSize));</span>
<span class="line-modified">927     drawBuffer(*layerImage, layerImageProperties-&gt;layerOrigin, layerImageProperties-&gt;layerSize);</span>
928 }
929 
930 } // namespace WebCore
<a name="75" id="anc75"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="75" type="hidden" />
</body>
</html>