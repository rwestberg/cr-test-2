<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/geolocation/Geolocation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GeoNotifier.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Geolocation.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/geolocation/Geolocation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;Geolocation.h&quot;
 30 
 31 #if ENABLE(GEOLOCATION)
 32 
<span class="line-removed"> 33 #include &quot;Coordinates.h&quot;</span>
 34 #include &quot;Document.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;GeoNotifier.h&quot;
 37 #include &quot;GeolocationController.h&quot;

 38 #include &quot;GeolocationError.h&quot;
 39 #include &quot;GeolocationPosition.h&quot;
<span class="line-modified"> 40 #include &quot;Geoposition.h&quot;</span>

 41 #include &quot;Page.h&quot;
<span class="line-removed"> 42 #include &quot;PositionError.h&quot;</span>
 43 #include &quot;RuntimeApplicationChecks.h&quot;
 44 #include &quot;SecurityOrigin.h&quot;

 45 #include &lt;wtf/Ref.h&gt;
 46 #include &lt;wtf/text/StringBuilder.h&gt;
 47 
 48 namespace WebCore {
 49 
 50 static const ASCIILiteral permissionDeniedErrorMessage { &quot;User denied Geolocation&quot;_s };
 51 static const ASCIILiteral failedToStartServiceErrorMessage { &quot;Failed to start Geolocation service&quot;_s };
 52 static const ASCIILiteral framelessDocumentErrorMessage { &quot;Geolocation cannot be used in frameless documents&quot;_s };
 53 static const ASCIILiteral originCannotRequestGeolocationErrorMessage { &quot;Origin does not have permission to use Geolocation service&quot;_s };
 54 
<span class="line-modified"> 55 static RefPtr&lt;Geoposition&gt; createGeoposition(Optional&lt;GeolocationPosition&gt;&amp;&amp; position)</span>


 56 {
 57     if (!position)
 58         return nullptr;
 59 
 60     DOMTimeStamp timestamp = convertSecondsToDOMTimeStamp(position-&gt;timestamp);
<span class="line-modified"> 61     return Geoposition::create(Coordinates::create(WTFMove(position.value())), timestamp);</span>
 62 }
 63 
<span class="line-modified"> 64 static Ref&lt;PositionError&gt; createPositionError(GeolocationError&amp; error)</span>
 65 {
<span class="line-modified"> 66     PositionError::ErrorCode code = PositionError::POSITION_UNAVAILABLE;</span>
 67     switch (error.code()) {
 68     case GeolocationError::PermissionDenied:
<span class="line-modified"> 69         code = PositionError::PERMISSION_DENIED;</span>
 70         break;
 71     case GeolocationError::PositionUnavailable:
<span class="line-modified"> 72         code = PositionError::POSITION_UNAVAILABLE;</span>
 73         break;
 74     }
 75 
<span class="line-modified"> 76     return PositionError::create(code, error.message());</span>
 77 }
 78 
 79 bool Geolocation::Watchers::add(int id, RefPtr&lt;GeoNotifier&gt;&amp;&amp; notifier)
 80 {
 81     ASSERT(id &gt; 0);
 82 
 83     if (!m_idToNotifierMap.add(id, notifier.get()).isNewEntry)
 84         return false;
 85     m_notifierToIdMap.set(WTFMove(notifier), id);
 86     return true;
 87 }
 88 
 89 GeoNotifier* Geolocation::Watchers::find(int id)
 90 {
 91     ASSERT(id &gt; 0);
 92     return m_idToNotifierMap.get(id);
 93 }
 94 
 95 void Geolocation::Watchers::remove(int id)
 96 {
</pre>
<hr />
<pre>
109 {
110     return m_notifierToIdMap.contains(notifier);
111 }
112 
113 void Geolocation::Watchers::clear()
114 {
115     m_idToNotifierMap.clear();
116     m_notifierToIdMap.clear();
117 }
118 
119 bool Geolocation::Watchers::isEmpty() const
120 {
121     return m_idToNotifierMap.isEmpty();
122 }
123 
124 void Geolocation::Watchers::getNotifiersVector(GeoNotifierVector&amp; copy) const
125 {
126     copy = copyToVector(m_idToNotifierMap.values());
127 }
128 
<span class="line-modified">129 Ref&lt;Geolocation&gt; Geolocation::create(ScriptExecutionContext* context)</span>
130 {
<span class="line-modified">131     auto geolocation = adoptRef(*new Geolocation(context));</span>
132     geolocation.get().suspendIfNeeded();
133     return geolocation;
134 }
135 
<span class="line-modified">136 Geolocation::Geolocation(ScriptExecutionContext* context)</span>
<span class="line-modified">137     : ActiveDOMObject(context)</span>
<span class="line-modified">138     , m_allowGeolocation(Unknown)</span>
<span class="line-removed">139     , m_isSuspended(false)</span>
<span class="line-removed">140     , m_hasChangedPosition(false)</span>
141     , m_resumeTimer(*this, &amp;Geolocation::resumeTimerFired)
142 {
143 }
144 
145 Geolocation::~Geolocation()
146 {
147     ASSERT(m_allowGeolocation != InProgress);
148 }
149 
150 SecurityOrigin* Geolocation::securityOrigin() const
151 {
152     return scriptExecutionContext()-&gt;securityOrigin();
153 }
154 
155 Page* Geolocation::page() const
156 {
157     return document() ? document()-&gt;page() : nullptr;
158 }
159 
160 bool Geolocation::canSuspendForDocumentSuspension() const
</pre>
<hr />
<pre>
271 
272 void Geolocation::stop()
273 {
274     Page* page = this-&gt;page();
275     if (page &amp;&amp; m_allowGeolocation == InProgress)
276         GeolocationController::from(page)-&gt;cancelPermissionRequest(*this);
277     // The frame may be moving to a new page and we want to get the permissions from the new page&#39;s client.
278     m_allowGeolocation = Unknown;
279     cancelAllRequests();
280     stopUpdating();
281     m_hasChangedPosition = false;
282     m_errorWaitingForResume = nullptr;
283     m_pendingForPermissionNotifiers.clear();
284 }
285 
286 const char* Geolocation::activeDOMObjectName() const
287 {
288     return &quot;Geolocation&quot;;
289 }
290 
<span class="line-modified">291 Geoposition* Geolocation::lastPosition()</span>
292 {
293     Page* page = this-&gt;page();
294     if (!page)
295         return nullptr;
296 
<span class="line-modified">297     m_lastPosition = createGeoposition(GeolocationController::from(page)-&gt;lastPosition());</span>
298 
299     return m_lastPosition.get();
300 }
301 
302 void Geolocation::getCurrentPosition(Ref&lt;PositionCallback&gt;&amp;&amp; successCallback, RefPtr&lt;PositionErrorCallback&gt;&amp;&amp; errorCallback, PositionOptions&amp;&amp; options)
303 {
304     if (!frame())
305         return;
306 
307     auto notifier = GeoNotifier::create(*this, WTFMove(successCallback), WTFMove(errorCallback), WTFMove(options));
308     startRequest(notifier.ptr());
309 
310     m_oneShots.add(WTFMove(notifier));
311 }
312 
313 int Geolocation::watchPosition(Ref&lt;PositionCallback&gt;&amp;&amp; successCallback, RefPtr&lt;PositionErrorCallback&gt;&amp;&amp; errorCallback, PositionOptions&amp;&amp; options)
314 {
315     if (!frame())
316         return 0;
317 
</pre>
<hr />
<pre>
354     return false;
355 }
356 
357 bool Geolocation::shouldBlockGeolocationRequests()
358 {
359     bool isSecure = SecurityOrigin::isSecure(document()-&gt;url());
360     bool hasMixedContent = !document()-&gt;foundMixedContent().isEmpty();
361     bool isLocalOrigin = securityOrigin()-&gt;isLocal();
362     if (securityOrigin()-&gt;canRequestGeolocation()) {
363         if (isLocalOrigin || (isSecure &amp;&amp; !hasMixedContent) || isRequestFromIBooks())
364             return false;
365     }
366 
367     logError(securityOrigin()-&gt;toString(), isSecure, hasMixedContent, document());
368     return true;
369 }
370 
371 void Geolocation::startRequest(GeoNotifier* notifier)
372 {
373     if (shouldBlockGeolocationRequests()) {
<span class="line-modified">374         notifier-&gt;setFatalError(PositionError::create(PositionError::POSITION_UNAVAILABLE, originCannotRequestGeolocationErrorMessage));</span>
375         return;
376     }
377     document()-&gt;setGeolocationAccessed();
378 
379     // Check whether permissions have already been denied. Note that if this is the case,
380     // the permission state can not change again in the lifetime of this page.
381     if (isDenied())
<span class="line-modified">382         notifier-&gt;setFatalError(PositionError::create(PositionError::PERMISSION_DENIED, permissionDeniedErrorMessage));</span>
383     else if (haveSuitableCachedPosition(notifier-&gt;options()))
384         notifier-&gt;setUseCachedPosition();
385     else if (notifier-&gt;hasZeroTimeout())
386         notifier-&gt;startTimerIfNeeded();
387     else if (!isAllowed()) {
388         // if we don&#39;t yet have permission, request for permission before calling startUpdating()
389         m_pendingForPermissionNotifiers.add(notifier);
390         requestPermission();
391     } else if (startUpdating(notifier))
392         notifier-&gt;startTimerIfNeeded();
393     else
<span class="line-modified">394         notifier-&gt;setFatalError(PositionError::create(PositionError::POSITION_UNAVAILABLE, failedToStartServiceErrorMessage));</span>
395 }
396 
397 void Geolocation::fatalErrorOccurred(GeoNotifier* notifier)
398 {
399     // This request has failed fatally. Remove it from our lists.
400     m_oneShots.remove(notifier);
401     m_watchers.remove(notifier);
402 
403     if (!hasListeners())
404         stopUpdating();
405 }
406 
407 void Geolocation::requestUsesCachedPosition(GeoNotifier* notifier)
408 {
409     // This is called asynchronously, so the permissions could have been denied
410     // since we last checked in startRequest.
411     if (isDenied()) {
<span class="line-modified">412         notifier-&gt;setFatalError(PositionError::create(PositionError::PERMISSION_DENIED, permissionDeniedErrorMessage));</span>
413         return;
414     }
415 
416     m_requestsAwaitingCachedPosition.add(notifier);
417 
418     // If permissions are allowed, make the callback
419     if (isAllowed()) {
420         makeCachedPositionCallbacks();
421         return;
422     }
423 
424     // Request permissions, which may be synchronous or asynchronous.
425     requestPermission();
426 }
427 
428 void Geolocation::makeCachedPositionCallbacks()
429 {
430     // All modifications to m_requestsAwaitingCachedPosition are done
431     // asynchronously, so we don&#39;t need to worry about it being modified from
432     // the callbacks.
433     for (auto&amp; notifier : m_requestsAwaitingCachedPosition) {
434         // FIXME: This seems wrong, since makeCachedPositionCallbacks() is called in a branch where
435         // lastPosition() is known to be null in Geolocation::setIsAllowed().
436         notifier-&gt;runSuccessCallback(lastPosition());
437 
438         // If this is a one-shot request, stop it. Otherwise, if the watch still
439         // exists, start the service to get updates.
440         if (!m_oneShots.remove(notifier.get()) &amp;&amp; m_watchers.contains(notifier.get())) {
441             if (notifier-&gt;hasZeroTimeout() || startUpdating(notifier.get()))
442                 notifier-&gt;startTimerIfNeeded();
443             else
<span class="line-modified">444                 notifier-&gt;setFatalError(PositionError::create(PositionError::POSITION_UNAVAILABLE, failedToStartServiceErrorMessage));</span>
445         }
446     }
447 
448     m_requestsAwaitingCachedPosition.clear();
449 
450     if (!hasListeners())
451         stopUpdating();
452 }
453 
454 void Geolocation::requestTimedOut(GeoNotifier* notifier)
455 {
456     // If this is a one-shot request, stop it.
457     m_oneShots.remove(notifier);
458 
459     if (!hasListeners())
460         stopUpdating();
461 }
462 
463 bool Geolocation::haveSuitableCachedPosition(const PositionOptions&amp; options)
464 {
<span class="line-modified">465     Geoposition* cachedPosition = lastPosition();</span>
466     if (!cachedPosition)
467         return false;
468     if (!options.maximumAge)
469         return false;
470     DOMTimeStamp currentTimeMillis = convertSecondsToDOMTimeStamp(WallTime::now().secondsSinceEpoch());
471     return cachedPosition-&gt;timestamp() &gt; currentTimeMillis - options.maximumAge;
472 }
473 
474 void Geolocation::clearWatch(int watchID)
475 {
476     if (watchID &lt;= 0)
477         return;
478 
479     if (GeoNotifier* notifier = m_watchers.find(watchID))
480         m_pendingForPermissionNotifiers.remove(notifier);
481     m_watchers.remove(watchID);
482 
483     if (!hasListeners())
484         stopUpdating();
485 }
</pre>
<hr />
<pre>
487 void Geolocation::setIsAllowed(bool allowed)
488 {
489     // Protect the Geolocation object from garbage collection during a callback.
490     Ref&lt;Geolocation&gt; protectedThis(*this);
491 
492     // This may be due to either a new position from the service, or a cached
493     // position.
494     m_allowGeolocation = allowed ? Yes : No;
495 
496     if (m_isSuspended)
497         return;
498 
499     // Permission request was made during the startRequest process
500     if (!m_pendingForPermissionNotifiers.isEmpty()) {
501         handlePendingPermissionNotifiers();
502         m_pendingForPermissionNotifiers.clear();
503         return;
504     }
505 
506     if (!isAllowed()) {
<span class="line-modified">507         auto error = PositionError::create(PositionError::PERMISSION_DENIED, permissionDeniedErrorMessage);</span>
508         error-&gt;setIsFatal(true);
509         handleError(error);
510         m_requestsAwaitingCachedPosition.clear();
511         m_hasChangedPosition = false;
512         m_errorWaitingForResume = nullptr;
513         return;
514     }
515 
516     // If the service has a last position, use it to call back for all requests.
517     // If any of the requests are waiting for permission for a cached position,
518     // the position from the service will be at least as fresh.
<span class="line-modified">519     if (RefPtr&lt;Geoposition&gt; position = lastPosition())</span>
520         makeSuccessCallbacks(*position);
521     else
522         makeCachedPositionCallbacks();
523 }
524 
<span class="line-modified">525 void Geolocation::sendError(GeoNotifierVector&amp; notifiers, PositionError&amp; error)</span>
526 {
527     for (auto&amp; notifier : notifiers)
528         notifier-&gt;runErrorCallback(error);
529 }
530 
<span class="line-modified">531 void Geolocation::sendPosition(GeoNotifierVector&amp; notifiers, Geoposition&amp; position)</span>
532 {
533     for (auto&amp; notifier : notifiers)
534         notifier-&gt;runSuccessCallback(&amp;position);
535 }
536 
537 void Geolocation::stopTimer(GeoNotifierVector&amp; notifiers)
538 {
539     for (auto&amp; notifier : notifiers)
540         notifier-&gt;stopTimer();
541 }
542 
543 void Geolocation::stopTimersForOneShots()
544 {
545     auto copy = copyToVector(m_oneShots);
546     stopTimer(copy);
547 }
548 
549 void Geolocation::stopTimersForWatchers()
550 {
551     GeoNotifierVector copy;
552     m_watchers.getNotifiersVector(copy);
553 
554     stopTimer(copy);
555 }
556 
557 void Geolocation::stopTimers()
558 {
559     stopTimersForOneShots();
560     stopTimersForWatchers();
561 }
562 
563 void Geolocation::cancelRequests(GeoNotifierVector&amp; notifiers)
564 {
565     for (auto&amp; notifier : notifiers)
<span class="line-modified">566         notifier-&gt;setFatalError(PositionError::create(PositionError::POSITION_UNAVAILABLE, framelessDocumentErrorMessage));</span>
567 }
568 
569 void Geolocation::cancelAllRequests()
570 {
571     auto copy = copyToVector(m_oneShots);
572     cancelRequests(copy);
573     m_watchers.getNotifiersVector(copy);
574     cancelRequests(copy);
575 }
576 
577 void Geolocation::extractNotifiersWithCachedPosition(GeoNotifierVector&amp; notifiers, GeoNotifierVector* cached)
578 {
579     GeoNotifierVector nonCached;
580     for (auto&amp; notifier : notifiers) {
581         if (notifier-&gt;useCachedPosition()) {
582             if (cached)
583                 cached-&gt;append(notifier.get());
584         } else
585             nonCached.append(notifier.get());
586     }
587     notifiers.swap(nonCached);
588 }
589 
590 void Geolocation::copyToSet(const GeoNotifierVector&amp; src, GeoNotifierSet&amp; dest)
591 {
592     for (auto&amp; notifier : src)
593         dest.add(notifier.get());
594 }
595 
<span class="line-modified">596 void Geolocation::handleError(PositionError&amp; error)</span>
597 {
598     auto oneShotsCopy = copyToVector(m_oneShots);
599 
600     GeoNotifierVector watchersCopy;
601     m_watchers.getNotifiersVector(watchersCopy);
602 
603     // Clear the lists before we make the callbacks, to avoid clearing notifiers
604     // added by calls to Geolocation methods from the callbacks, and to prevent
605     // further callbacks to these notifiers.
606     GeoNotifierVector oneShotsWithCachedPosition;
607     m_oneShots.clear();
608     if (error.isFatal())
609         m_watchers.clear();
610     else {
611         // Don&#39;t send non-fatal errors to notifiers due to receive a cached position.
612         extractNotifiersWithCachedPosition(oneShotsCopy, &amp;oneShotsWithCachedPosition);
613         extractNotifiersWithCachedPosition(watchersCopy, 0);
614     }
615 
616     sendError(oneShotsCopy, error);
</pre>
<hr />
<pre>
624 
625     // Maintain a reference to the cached notifiers until their timer fires.
626     copyToSet(oneShotsWithCachedPosition, m_oneShots);
627 }
628 
629 void Geolocation::requestPermission()
630 {
631     if (m_allowGeolocation &gt; Unknown)
632         return;
633 
634     Page* page = this-&gt;page();
635     if (!page)
636         return;
637 
638     m_allowGeolocation = InProgress;
639 
640     // Ask the embedder: it maintains the geolocation challenge policy itself.
641     GeolocationController::from(page)-&gt;requestPermission(*this);
642 }
643 
<span class="line-modified">644 void Geolocation::makeSuccessCallbacks(Geoposition&amp; position)</span>
645 {
646     ASSERT(lastPosition());
647     ASSERT(isAllowed());
648 
649     auto oneShotsCopy = copyToVector(m_oneShots);
650 
651     GeoNotifierVector watchersCopy;
652     m_watchers.getNotifiersVector(watchersCopy);
653 
654     // Clear the lists before we make the callbacks, to avoid clearing notifiers
655     // added by calls to Geolocation methods from the callbacks, and to prevent
656     // further callbacks to these notifiers.
657     m_oneShots.clear();
658 
659     sendPosition(oneShotsCopy, position);
660     sendPosition(watchersCopy, position);
661 
662     if (!hasListeners())
663         stopUpdating();
664 }
665 
666 void Geolocation::positionChanged()
667 {
668     ASSERT(isAllowed());
669 
670     // Stop all currently running timers.
671     stopTimers();
672 
673     if (m_isSuspended) {
674         m_hasChangedPosition = true;
675         return;
676     }
677 
<span class="line-modified">678     RefPtr&lt;Geoposition&gt; position = lastPosition();</span>
679     ASSERT(position);
680 
681     makeSuccessCallbacks(*position);
682 }
683 
684 void Geolocation::setError(GeolocationError&amp; error)
685 {
686     if (m_isSuspended) {
<span class="line-modified">687         m_errorWaitingForResume = createPositionError(error);</span>
688         return;
689     }
690 
<span class="line-modified">691     auto positionError = createPositionError(error);</span>
692     handleError(positionError);
693 }
694 
695 bool Geolocation::startUpdating(GeoNotifier* notifier)
696 {
697     Page* page = this-&gt;page();
698     if (!page)
699         return false;
700 
701     GeolocationController::from(page)-&gt;addObserver(*this, notifier-&gt;options().enableHighAccuracy);
702     return true;
703 }
704 
705 void Geolocation::stopUpdating()
706 {
707     Page* page = this-&gt;page();
708     if (!page)
709         return;
710 
711     GeolocationController::from(page)-&gt;removeObserver(*this);
712 }
713 
714 void Geolocation::handlePendingPermissionNotifiers()
715 {
716     // While we iterate through the list, we need not worry about list being modified as the permission
717     // is already set to Yes/No and no new listeners will be added to the pending list
718     for (auto&amp; notifier : m_pendingForPermissionNotifiers) {
719         if (isAllowed()) {
720             // start all pending notification requests as permission granted.
721             // The notifier is always ref&#39;ed by m_oneShots or m_watchers.
722             if (startUpdating(notifier.get()))
723                 notifier-&gt;startTimerIfNeeded();
724             else
<span class="line-modified">725                 notifier-&gt;setFatalError(PositionError::create(PositionError::POSITION_UNAVAILABLE, failedToStartServiceErrorMessage));</span>
726         } else
<span class="line-modified">727             notifier-&gt;setFatalError(PositionError::create(PositionError::PERMISSION_DENIED, permissionDeniedErrorMessage));</span>
728     }
729 }
730 










731 } // namespace WebCore
732 
733 #endif // ENABLE(GEOLOCATION)
</pre>
</td>
<td>
<hr />
<pre>
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;Geolocation.h&quot;
 30 
 31 #if ENABLE(GEOLOCATION)
 32 

 33 #include &quot;Document.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;GeoNotifier.h&quot;
 36 #include &quot;GeolocationController.h&quot;
<span class="line-added"> 37 #include &quot;GeolocationCoordinates.h&quot;</span>
 38 #include &quot;GeolocationError.h&quot;
 39 #include &quot;GeolocationPosition.h&quot;
<span class="line-modified"> 40 #include &quot;GeolocationPositionData.h&quot;</span>
<span class="line-added"> 41 #include &quot;Navigator.h&quot;</span>
 42 #include &quot;Page.h&quot;

 43 #include &quot;RuntimeApplicationChecks.h&quot;
 44 #include &quot;SecurityOrigin.h&quot;
<span class="line-added"> 45 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
 46 #include &lt;wtf/Ref.h&gt;
 47 #include &lt;wtf/text/StringBuilder.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 static const ASCIILiteral permissionDeniedErrorMessage { &quot;User denied Geolocation&quot;_s };
 52 static const ASCIILiteral failedToStartServiceErrorMessage { &quot;Failed to start Geolocation service&quot;_s };
 53 static const ASCIILiteral framelessDocumentErrorMessage { &quot;Geolocation cannot be used in frameless documents&quot;_s };
 54 static const ASCIILiteral originCannotRequestGeolocationErrorMessage { &quot;Origin does not have permission to use Geolocation service&quot;_s };
 55 
<span class="line-modified"> 56 WTF_MAKE_ISO_ALLOCATED_IMPL(Geolocation);</span>
<span class="line-added"> 57 </span>
<span class="line-added"> 58 static RefPtr&lt;GeolocationPosition&gt; createGeolocationPosition(Optional&lt;GeolocationPositionData&gt;&amp;&amp; position)</span>
 59 {
 60     if (!position)
 61         return nullptr;
 62 
 63     DOMTimeStamp timestamp = convertSecondsToDOMTimeStamp(position-&gt;timestamp);
<span class="line-modified"> 64     return GeolocationPosition::create(GeolocationCoordinates::create(WTFMove(position.value())), timestamp);</span>
 65 }
 66 
<span class="line-modified"> 67 static Ref&lt;GeolocationPositionError&gt; createGeolocationPositionError(GeolocationError&amp; error)</span>
 68 {
<span class="line-modified"> 69     auto code = GeolocationPositionError::POSITION_UNAVAILABLE;</span>
 70     switch (error.code()) {
 71     case GeolocationError::PermissionDenied:
<span class="line-modified"> 72         code = GeolocationPositionError::PERMISSION_DENIED;</span>
 73         break;
 74     case GeolocationError::PositionUnavailable:
<span class="line-modified"> 75         code = GeolocationPositionError::POSITION_UNAVAILABLE;</span>
 76         break;
 77     }
 78 
<span class="line-modified"> 79     return GeolocationPositionError::create(code, error.message());</span>
 80 }
 81 
 82 bool Geolocation::Watchers::add(int id, RefPtr&lt;GeoNotifier&gt;&amp;&amp; notifier)
 83 {
 84     ASSERT(id &gt; 0);
 85 
 86     if (!m_idToNotifierMap.add(id, notifier.get()).isNewEntry)
 87         return false;
 88     m_notifierToIdMap.set(WTFMove(notifier), id);
 89     return true;
 90 }
 91 
 92 GeoNotifier* Geolocation::Watchers::find(int id)
 93 {
 94     ASSERT(id &gt; 0);
 95     return m_idToNotifierMap.get(id);
 96 }
 97 
 98 void Geolocation::Watchers::remove(int id)
 99 {
</pre>
<hr />
<pre>
112 {
113     return m_notifierToIdMap.contains(notifier);
114 }
115 
116 void Geolocation::Watchers::clear()
117 {
118     m_idToNotifierMap.clear();
119     m_notifierToIdMap.clear();
120 }
121 
122 bool Geolocation::Watchers::isEmpty() const
123 {
124     return m_idToNotifierMap.isEmpty();
125 }
126 
127 void Geolocation::Watchers::getNotifiersVector(GeoNotifierVector&amp; copy) const
128 {
129     copy = copyToVector(m_idToNotifierMap.values());
130 }
131 
<span class="line-modified">132 Ref&lt;Geolocation&gt; Geolocation::create(Navigator&amp; navigator)</span>
133 {
<span class="line-modified">134     auto geolocation = adoptRef(*new Geolocation(navigator));</span>
135     geolocation.get().suspendIfNeeded();
136     return geolocation;
137 }
138 
<span class="line-modified">139 Geolocation::Geolocation(Navigator&amp; navigator)</span>
<span class="line-modified">140     : ActiveDOMObject(navigator.scriptExecutionContext())</span>
<span class="line-modified">141     , m_navigator(makeWeakPtr(navigator))</span>


142     , m_resumeTimer(*this, &amp;Geolocation::resumeTimerFired)
143 {
144 }
145 
146 Geolocation::~Geolocation()
147 {
148     ASSERT(m_allowGeolocation != InProgress);
149 }
150 
151 SecurityOrigin* Geolocation::securityOrigin() const
152 {
153     return scriptExecutionContext()-&gt;securityOrigin();
154 }
155 
156 Page* Geolocation::page() const
157 {
158     return document() ? document()-&gt;page() : nullptr;
159 }
160 
161 bool Geolocation::canSuspendForDocumentSuspension() const
</pre>
<hr />
<pre>
272 
273 void Geolocation::stop()
274 {
275     Page* page = this-&gt;page();
276     if (page &amp;&amp; m_allowGeolocation == InProgress)
277         GeolocationController::from(page)-&gt;cancelPermissionRequest(*this);
278     // The frame may be moving to a new page and we want to get the permissions from the new page&#39;s client.
279     m_allowGeolocation = Unknown;
280     cancelAllRequests();
281     stopUpdating();
282     m_hasChangedPosition = false;
283     m_errorWaitingForResume = nullptr;
284     m_pendingForPermissionNotifiers.clear();
285 }
286 
287 const char* Geolocation::activeDOMObjectName() const
288 {
289     return &quot;Geolocation&quot;;
290 }
291 
<span class="line-modified">292 GeolocationPosition* Geolocation::lastPosition()</span>
293 {
294     Page* page = this-&gt;page();
295     if (!page)
296         return nullptr;
297 
<span class="line-modified">298     m_lastPosition = createGeolocationPosition(GeolocationController::from(page)-&gt;lastPosition());</span>
299 
300     return m_lastPosition.get();
301 }
302 
303 void Geolocation::getCurrentPosition(Ref&lt;PositionCallback&gt;&amp;&amp; successCallback, RefPtr&lt;PositionErrorCallback&gt;&amp;&amp; errorCallback, PositionOptions&amp;&amp; options)
304 {
305     if (!frame())
306         return;
307 
308     auto notifier = GeoNotifier::create(*this, WTFMove(successCallback), WTFMove(errorCallback), WTFMove(options));
309     startRequest(notifier.ptr());
310 
311     m_oneShots.add(WTFMove(notifier));
312 }
313 
314 int Geolocation::watchPosition(Ref&lt;PositionCallback&gt;&amp;&amp; successCallback, RefPtr&lt;PositionErrorCallback&gt;&amp;&amp; errorCallback, PositionOptions&amp;&amp; options)
315 {
316     if (!frame())
317         return 0;
318 
</pre>
<hr />
<pre>
355     return false;
356 }
357 
358 bool Geolocation::shouldBlockGeolocationRequests()
359 {
360     bool isSecure = SecurityOrigin::isSecure(document()-&gt;url());
361     bool hasMixedContent = !document()-&gt;foundMixedContent().isEmpty();
362     bool isLocalOrigin = securityOrigin()-&gt;isLocal();
363     if (securityOrigin()-&gt;canRequestGeolocation()) {
364         if (isLocalOrigin || (isSecure &amp;&amp; !hasMixedContent) || isRequestFromIBooks())
365             return false;
366     }
367 
368     logError(securityOrigin()-&gt;toString(), isSecure, hasMixedContent, document());
369     return true;
370 }
371 
372 void Geolocation::startRequest(GeoNotifier* notifier)
373 {
374     if (shouldBlockGeolocationRequests()) {
<span class="line-modified">375         notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::PERMISSION_DENIED, originCannotRequestGeolocationErrorMessage));</span>
376         return;
377     }
378     document()-&gt;setGeolocationAccessed();
379 
380     // Check whether permissions have already been denied. Note that if this is the case,
381     // the permission state can not change again in the lifetime of this page.
382     if (isDenied())
<span class="line-modified">383         notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::PERMISSION_DENIED, permissionDeniedErrorMessage));</span>
384     else if (haveSuitableCachedPosition(notifier-&gt;options()))
385         notifier-&gt;setUseCachedPosition();
386     else if (notifier-&gt;hasZeroTimeout())
387         notifier-&gt;startTimerIfNeeded();
388     else if (!isAllowed()) {
389         // if we don&#39;t yet have permission, request for permission before calling startUpdating()
390         m_pendingForPermissionNotifiers.add(notifier);
391         requestPermission();
392     } else if (startUpdating(notifier))
393         notifier-&gt;startTimerIfNeeded();
394     else
<span class="line-modified">395         notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::POSITION_UNAVAILABLE, failedToStartServiceErrorMessage));</span>
396 }
397 
398 void Geolocation::fatalErrorOccurred(GeoNotifier* notifier)
399 {
400     // This request has failed fatally. Remove it from our lists.
401     m_oneShots.remove(notifier);
402     m_watchers.remove(notifier);
403 
404     if (!hasListeners())
405         stopUpdating();
406 }
407 
408 void Geolocation::requestUsesCachedPosition(GeoNotifier* notifier)
409 {
410     // This is called asynchronously, so the permissions could have been denied
411     // since we last checked in startRequest.
412     if (isDenied()) {
<span class="line-modified">413         notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::PERMISSION_DENIED, permissionDeniedErrorMessage));</span>
414         return;
415     }
416 
417     m_requestsAwaitingCachedPosition.add(notifier);
418 
419     // If permissions are allowed, make the callback
420     if (isAllowed()) {
421         makeCachedPositionCallbacks();
422         return;
423     }
424 
425     // Request permissions, which may be synchronous or asynchronous.
426     requestPermission();
427 }
428 
429 void Geolocation::makeCachedPositionCallbacks()
430 {
431     // All modifications to m_requestsAwaitingCachedPosition are done
432     // asynchronously, so we don&#39;t need to worry about it being modified from
433     // the callbacks.
434     for (auto&amp; notifier : m_requestsAwaitingCachedPosition) {
435         // FIXME: This seems wrong, since makeCachedPositionCallbacks() is called in a branch where
436         // lastPosition() is known to be null in Geolocation::setIsAllowed().
437         notifier-&gt;runSuccessCallback(lastPosition());
438 
439         // If this is a one-shot request, stop it. Otherwise, if the watch still
440         // exists, start the service to get updates.
441         if (!m_oneShots.remove(notifier.get()) &amp;&amp; m_watchers.contains(notifier.get())) {
442             if (notifier-&gt;hasZeroTimeout() || startUpdating(notifier.get()))
443                 notifier-&gt;startTimerIfNeeded();
444             else
<span class="line-modified">445                 notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::POSITION_UNAVAILABLE, failedToStartServiceErrorMessage));</span>
446         }
447     }
448 
449     m_requestsAwaitingCachedPosition.clear();
450 
451     if (!hasListeners())
452         stopUpdating();
453 }
454 
455 void Geolocation::requestTimedOut(GeoNotifier* notifier)
456 {
457     // If this is a one-shot request, stop it.
458     m_oneShots.remove(notifier);
459 
460     if (!hasListeners())
461         stopUpdating();
462 }
463 
464 bool Geolocation::haveSuitableCachedPosition(const PositionOptions&amp; options)
465 {
<span class="line-modified">466     auto* cachedPosition = lastPosition();</span>
467     if (!cachedPosition)
468         return false;
469     if (!options.maximumAge)
470         return false;
471     DOMTimeStamp currentTimeMillis = convertSecondsToDOMTimeStamp(WallTime::now().secondsSinceEpoch());
472     return cachedPosition-&gt;timestamp() &gt; currentTimeMillis - options.maximumAge;
473 }
474 
475 void Geolocation::clearWatch(int watchID)
476 {
477     if (watchID &lt;= 0)
478         return;
479 
480     if (GeoNotifier* notifier = m_watchers.find(watchID))
481         m_pendingForPermissionNotifiers.remove(notifier);
482     m_watchers.remove(watchID);
483 
484     if (!hasListeners())
485         stopUpdating();
486 }
</pre>
<hr />
<pre>
488 void Geolocation::setIsAllowed(bool allowed)
489 {
490     // Protect the Geolocation object from garbage collection during a callback.
491     Ref&lt;Geolocation&gt; protectedThis(*this);
492 
493     // This may be due to either a new position from the service, or a cached
494     // position.
495     m_allowGeolocation = allowed ? Yes : No;
496 
497     if (m_isSuspended)
498         return;
499 
500     // Permission request was made during the startRequest process
501     if (!m_pendingForPermissionNotifiers.isEmpty()) {
502         handlePendingPermissionNotifiers();
503         m_pendingForPermissionNotifiers.clear();
504         return;
505     }
506 
507     if (!isAllowed()) {
<span class="line-modified">508         auto error = GeolocationPositionError::create(GeolocationPositionError::PERMISSION_DENIED, permissionDeniedErrorMessage);</span>
509         error-&gt;setIsFatal(true);
510         handleError(error);
511         m_requestsAwaitingCachedPosition.clear();
512         m_hasChangedPosition = false;
513         m_errorWaitingForResume = nullptr;
514         return;
515     }
516 
517     // If the service has a last position, use it to call back for all requests.
518     // If any of the requests are waiting for permission for a cached position,
519     // the position from the service will be at least as fresh.
<span class="line-modified">520     if (RefPtr&lt;GeolocationPosition&gt; position = lastPosition())</span>
521         makeSuccessCallbacks(*position);
522     else
523         makeCachedPositionCallbacks();
524 }
525 
<span class="line-modified">526 void Geolocation::sendError(GeoNotifierVector&amp; notifiers, GeolocationPositionError&amp; error)</span>
527 {
528     for (auto&amp; notifier : notifiers)
529         notifier-&gt;runErrorCallback(error);
530 }
531 
<span class="line-modified">532 void Geolocation::sendPosition(GeoNotifierVector&amp; notifiers, GeolocationPosition&amp; position)</span>
533 {
534     for (auto&amp; notifier : notifiers)
535         notifier-&gt;runSuccessCallback(&amp;position);
536 }
537 
538 void Geolocation::stopTimer(GeoNotifierVector&amp; notifiers)
539 {
540     for (auto&amp; notifier : notifiers)
541         notifier-&gt;stopTimer();
542 }
543 
544 void Geolocation::stopTimersForOneShots()
545 {
546     auto copy = copyToVector(m_oneShots);
547     stopTimer(copy);
548 }
549 
550 void Geolocation::stopTimersForWatchers()
551 {
552     GeoNotifierVector copy;
553     m_watchers.getNotifiersVector(copy);
554 
555     stopTimer(copy);
556 }
557 
558 void Geolocation::stopTimers()
559 {
560     stopTimersForOneShots();
561     stopTimersForWatchers();
562 }
563 
564 void Geolocation::cancelRequests(GeoNotifierVector&amp; notifiers)
565 {
566     for (auto&amp; notifier : notifiers)
<span class="line-modified">567         notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::POSITION_UNAVAILABLE, framelessDocumentErrorMessage));</span>
568 }
569 
570 void Geolocation::cancelAllRequests()
571 {
572     auto copy = copyToVector(m_oneShots);
573     cancelRequests(copy);
574     m_watchers.getNotifiersVector(copy);
575     cancelRequests(copy);
576 }
577 
578 void Geolocation::extractNotifiersWithCachedPosition(GeoNotifierVector&amp; notifiers, GeoNotifierVector* cached)
579 {
580     GeoNotifierVector nonCached;
581     for (auto&amp; notifier : notifiers) {
582         if (notifier-&gt;useCachedPosition()) {
583             if (cached)
584                 cached-&gt;append(notifier.get());
585         } else
586             nonCached.append(notifier.get());
587     }
588     notifiers.swap(nonCached);
589 }
590 
591 void Geolocation::copyToSet(const GeoNotifierVector&amp; src, GeoNotifierSet&amp; dest)
592 {
593     for (auto&amp; notifier : src)
594         dest.add(notifier.get());
595 }
596 
<span class="line-modified">597 void Geolocation::handleError(GeolocationPositionError&amp; error)</span>
598 {
599     auto oneShotsCopy = copyToVector(m_oneShots);
600 
601     GeoNotifierVector watchersCopy;
602     m_watchers.getNotifiersVector(watchersCopy);
603 
604     // Clear the lists before we make the callbacks, to avoid clearing notifiers
605     // added by calls to Geolocation methods from the callbacks, and to prevent
606     // further callbacks to these notifiers.
607     GeoNotifierVector oneShotsWithCachedPosition;
608     m_oneShots.clear();
609     if (error.isFatal())
610         m_watchers.clear();
611     else {
612         // Don&#39;t send non-fatal errors to notifiers due to receive a cached position.
613         extractNotifiersWithCachedPosition(oneShotsCopy, &amp;oneShotsWithCachedPosition);
614         extractNotifiersWithCachedPosition(watchersCopy, 0);
615     }
616 
617     sendError(oneShotsCopy, error);
</pre>
<hr />
<pre>
625 
626     // Maintain a reference to the cached notifiers until their timer fires.
627     copyToSet(oneShotsWithCachedPosition, m_oneShots);
628 }
629 
630 void Geolocation::requestPermission()
631 {
632     if (m_allowGeolocation &gt; Unknown)
633         return;
634 
635     Page* page = this-&gt;page();
636     if (!page)
637         return;
638 
639     m_allowGeolocation = InProgress;
640 
641     // Ask the embedder: it maintains the geolocation challenge policy itself.
642     GeolocationController::from(page)-&gt;requestPermission(*this);
643 }
644 
<span class="line-modified">645 void Geolocation::makeSuccessCallbacks(GeolocationPosition&amp; position)</span>
646 {
647     ASSERT(lastPosition());
648     ASSERT(isAllowed());
649 
650     auto oneShotsCopy = copyToVector(m_oneShots);
651 
652     GeoNotifierVector watchersCopy;
653     m_watchers.getNotifiersVector(watchersCopy);
654 
655     // Clear the lists before we make the callbacks, to avoid clearing notifiers
656     // added by calls to Geolocation methods from the callbacks, and to prevent
657     // further callbacks to these notifiers.
658     m_oneShots.clear();
659 
660     sendPosition(oneShotsCopy, position);
661     sendPosition(watchersCopy, position);
662 
663     if (!hasListeners())
664         stopUpdating();
665 }
666 
667 void Geolocation::positionChanged()
668 {
669     ASSERT(isAllowed());
670 
671     // Stop all currently running timers.
672     stopTimers();
673 
674     if (m_isSuspended) {
675         m_hasChangedPosition = true;
676         return;
677     }
678 
<span class="line-modified">679     RefPtr&lt;GeolocationPosition&gt; position = lastPosition();</span>
680     ASSERT(position);
681 
682     makeSuccessCallbacks(*position);
683 }
684 
685 void Geolocation::setError(GeolocationError&amp; error)
686 {
687     if (m_isSuspended) {
<span class="line-modified">688         m_errorWaitingForResume = createGeolocationPositionError(error);</span>
689         return;
690     }
691 
<span class="line-modified">692     auto positionError = createGeolocationPositionError(error);</span>
693     handleError(positionError);
694 }
695 
696 bool Geolocation::startUpdating(GeoNotifier* notifier)
697 {
698     Page* page = this-&gt;page();
699     if (!page)
700         return false;
701 
702     GeolocationController::from(page)-&gt;addObserver(*this, notifier-&gt;options().enableHighAccuracy);
703     return true;
704 }
705 
706 void Geolocation::stopUpdating()
707 {
708     Page* page = this-&gt;page();
709     if (!page)
710         return;
711 
712     GeolocationController::from(page)-&gt;removeObserver(*this);
713 }
714 
715 void Geolocation::handlePendingPermissionNotifiers()
716 {
717     // While we iterate through the list, we need not worry about list being modified as the permission
718     // is already set to Yes/No and no new listeners will be added to the pending list
719     for (auto&amp; notifier : m_pendingForPermissionNotifiers) {
720         if (isAllowed()) {
721             // start all pending notification requests as permission granted.
722             // The notifier is always ref&#39;ed by m_oneShots or m_watchers.
723             if (startUpdating(notifier.get()))
724                 notifier-&gt;startTimerIfNeeded();
725             else
<span class="line-modified">726                 notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::POSITION_UNAVAILABLE, failedToStartServiceErrorMessage));</span>
727         } else
<span class="line-modified">728             notifier-&gt;setFatalError(GeolocationPositionError::create(GeolocationPositionError::PERMISSION_DENIED, permissionDeniedErrorMessage));</span>
729     }
730 }
731 
<span class="line-added">732 Navigator* Geolocation::navigator()</span>
<span class="line-added">733 {</span>
<span class="line-added">734     return m_navigator.get();</span>
<span class="line-added">735 }</span>
<span class="line-added">736 </span>
<span class="line-added">737 Frame* Geolocation::frame() const</span>
<span class="line-added">738 {</span>
<span class="line-added">739     return m_navigator ? m_navigator-&gt;frame() : nullptr;</span>
<span class="line-added">740 }</span>
<span class="line-added">741 </span>
742 } // namespace WebCore
743 
744 #endif // ENABLE(GEOLOCATION)
</pre>
</td>
</tr>
</table>
<center><a href="GeoNotifier.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Geolocation.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>