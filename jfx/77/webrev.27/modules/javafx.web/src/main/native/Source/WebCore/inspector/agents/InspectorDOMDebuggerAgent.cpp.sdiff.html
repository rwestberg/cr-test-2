<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMDebuggerAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorDOMAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorDOMDebuggerAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMDebuggerAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;InspectorDOMDebuggerAgent.h&quot;
 34 
 35 #include &quot;Event.h&quot;
 36 #include &quot;Frame.h&quot;
 37 #include &quot;HTMLElement.h&quot;
 38 #include &quot;InspectorDOMAgent.h&quot;
 39 #include &quot;InstrumentingAgents.h&quot;

 40 #include &quot;RegisteredEventListener.h&quot;
 41 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;


 42 #include &lt;JavaScriptCore/InspectorFrontendDispatchers.h&gt;
 43 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 44 #include &lt;wtf/JSONValues.h&gt;
 45 
 46 namespace {
 47 
 48 enum DOMBreakpointType {
 49     SubtreeModified,
 50     AttributeModified,
 51     NodeRemoved,
 52     DOMBreakpointTypesCount
 53 };
 54 
 55 const uint32_t inheritableDOMBreakpointTypesMask = (1 &lt;&lt; SubtreeModified);
 56 const int domBreakpointDerivedTypeShift = 16;
 57 
 58 }
 59 
 60 
 61 namespace WebCore {
 62 
 63 using namespace Inspector;
 64 
<span class="line-modified"> 65 InspectorDOMDebuggerAgent::InspectorDOMDebuggerAgent(WebAgentContext&amp; context, InspectorDOMAgent* domAgent, InspectorDebuggerAgent* debuggerAgent)</span>
 66     : InspectorAgentBase(&quot;DOMDebugger&quot;_s, context)
 67     , m_backendDispatcher(Inspector::DOMDebuggerBackendDispatcher::create(context.backendDispatcher, this))
<span class="line-modified"> 68     , m_domAgent(domAgent)</span>
 69     , m_debuggerAgent(debuggerAgent)
 70 {
<span class="line-modified"> 71     m_debuggerAgent-&gt;setListener(this);</span>
 72 }
 73 
<span class="line-modified"> 74 InspectorDOMDebuggerAgent::~InspectorDOMDebuggerAgent()</span>
<span class="line-removed"> 75 {</span>
<span class="line-removed"> 76     ASSERT(!m_debuggerAgent);</span>
<span class="line-removed"> 77     ASSERT(!m_instrumentingAgents.inspectorDOMDebuggerAgent());</span>
<span class="line-removed"> 78 }</span>
 79 
 80 // Browser debugger agent enabled only when JS debugger is enabled.
 81 void InspectorDOMDebuggerAgent::debuggerWasEnabled()
 82 {
 83     m_instrumentingAgents.setInspectorDOMDebuggerAgent(this);
 84 }
 85 
 86 void InspectorDOMDebuggerAgent::debuggerWasDisabled()
 87 {
 88     disable();
 89 }
 90 
 91 void InspectorDOMDebuggerAgent::disable()
 92 {
 93     m_instrumentingAgents.setInspectorDOMDebuggerAgent(nullptr);
<span class="line-modified"> 94     discardBindings();</span>
<span class="line-modified"> 95     m_eventBreakpoints.clear();</span>
 96     m_urlBreakpoints.clear();




 97     m_pauseOnAllURLsEnabled = false;
 98 }
 99 
100 void InspectorDOMDebuggerAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
101 {
102 }
103 
104 void InspectorDOMDebuggerAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
105 {
106     disable();
107 }
108 
109 void InspectorDOMDebuggerAgent::discardAgent()
110 {
<span class="line-modified">111     m_debuggerAgent-&gt;setListener(nullptr);</span>
112     m_debuggerAgent = nullptr;
113 }
114 
115 void InspectorDOMDebuggerAgent::frameDocumentUpdated(Frame&amp; frame)
116 {
117     if (!frame.isMainFrame())
118         return;
119 
<span class="line-removed">120     discardBindings();</span>
<span class="line-removed">121 }</span>
<span class="line-removed">122 </span>
<span class="line-removed">123 void InspectorDOMDebuggerAgent::discardBindings()</span>
<span class="line-removed">124 {</span>
125     m_domBreakpoints.clear();
126 }
127 
<span class="line-modified">128 void InspectorDOMDebuggerAgent::setEventBreakpoint(ErrorString&amp; error, const String&amp; breakpointTypeString, const String&amp; eventName)</span>
129 {
130     if (breakpointTypeString.isEmpty()) {
<span class="line-modified">131         error = &quot;Event breakpoint type is empty&quot;_s;</span>
132         return;
133     }
134 
135     auto breakpointType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::DOMDebugger::EventBreakpointType&gt;(breakpointTypeString);
136     if (!breakpointType) {
<span class="line-modified">137         error = makeString(&quot;Unknown event breakpoint type: &quot;_s, breakpointTypeString);</span>
138         return;
139     }
140 
<span class="line-modified">141     if (eventName.isEmpty()) {</span>
<span class="line-modified">142         error = &quot;Event name is empty&quot;_s;</span>






143         return;
144     }
145 
<span class="line-modified">146     m_eventBreakpoints.add(std::make_pair(*breakpointType, eventName));</span>
























147 }
148 
<span class="line-modified">149 void InspectorDOMDebuggerAgent::removeEventBreakpoint(ErrorString&amp; error, const String&amp; breakpointTypeString, const String&amp; eventName)</span>
150 {
151     if (breakpointTypeString.isEmpty()) {
<span class="line-modified">152         error = &quot;Event breakpoint type is empty&quot;_s;</span>
153         return;
154     }
155 
156     auto breakpointType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::DOMDebugger::EventBreakpointType&gt;(breakpointTypeString);
157     if (!breakpointType) {
<span class="line-modified">158         error = makeString(&quot;Unknown event breakpoint type: &quot;_s, breakpointTypeString);</span>
159         return;
160     }
161 
<span class="line-modified">162     if (eventName.isEmpty()) {</span>
<span class="line-modified">163         error = &quot;Event name is empty&quot;_s;</span>






164         return;
165     }
166 
<span class="line-modified">167     m_eventBreakpoints.remove(std::make_pair(*breakpointType, eventName));</span>
























168 }
169 
<span class="line-modified">170 void InspectorDOMDebuggerAgent::didInvalidateStyleAttr(Node&amp; node)</span>
171 {
<span class="line-modified">172     if (hasBreakpoint(&amp;node, AttributeModified)) {</span>



173         Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
<span class="line-modified">174         descriptionForDOMEvent(node, AttributeModified, false, eventData.get());</span>
175         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));
176     }
177 }
178 
179 void InspectorDOMDebuggerAgent::didInsertDOMNode(Node&amp; node)
180 {
181     if (m_domBreakpoints.size()) {
182         uint32_t mask = m_domBreakpoints.get(InspectorDOMAgent::innerParentNode(&amp;node));
183         uint32_t inheritableTypesMask = (mask | (mask &gt;&gt; domBreakpointDerivedTypeShift)) &amp; inheritableDOMBreakpointTypesMask;
184         if (inheritableTypesMask)
185             updateSubtreeBreakpoints(&amp;node, inheritableTypesMask, true);
186     }
187 }
188 
189 void InspectorDOMDebuggerAgent::didRemoveDOMNode(Node&amp; node)
190 {
191     if (m_domBreakpoints.size()) {
192         // Remove subtree breakpoints.
193         m_domBreakpoints.remove(&amp;node);
194         Vector&lt;Node*&gt; stack(1, InspectorDOMAgent::innerFirstChild(&amp;node));
195         do {
196             Node* node = stack.last();
197             stack.removeLast();
198             if (!node)
199                 continue;
200             m_domBreakpoints.remove(node);
201             stack.append(InspectorDOMAgent::innerFirstChild(node));
202             stack.append(InspectorDOMAgent::innerNextSibling(node));
203         } while (!stack.isEmpty());
204     }
205 }
206 
207 static int domTypeForName(ErrorString&amp; errorString, const String&amp; typeString)
208 {
209     if (typeString == &quot;subtree-modified&quot;)
210         return SubtreeModified;
211     if (typeString == &quot;attribute-modified&quot;)
212         return AttributeModified;
213     if (typeString == &quot;node-removed&quot;)
214         return NodeRemoved;
<span class="line-modified">215     errorString = makeString(&quot;Unknown DOM breakpoint type: &quot;, typeString);</span>
216     return -1;
217 }
218 
219 static String domTypeName(int type)
220 {
221     switch (type) {
222     case SubtreeModified: return &quot;subtree-modified&quot;_s;
223     case AttributeModified: return &quot;attribute-modified&quot;_s;
224     case NodeRemoved: return &quot;node-removed&quot;_s;
225     default: break;
226     }
227     return emptyString();
228 }
229 
230 void InspectorDOMDebuggerAgent::setDOMBreakpoint(ErrorString&amp; errorString, int nodeId, const String&amp; typeString)
231 {
<span class="line-modified">232     Node* node = m_domAgent-&gt;assertNode(errorString, nodeId);</span>






233     if (!node)
234         return;
235 
236     int type = domTypeForName(errorString, typeString);
237     if (type == -1)
238         return;
239 
240     uint32_t rootBit = 1 &lt;&lt; type;
241     m_domBreakpoints.set(node, m_domBreakpoints.get(node) | rootBit);
242     if (rootBit &amp; inheritableDOMBreakpointTypesMask) {
243         for (Node* child = InspectorDOMAgent::innerFirstChild(node); child; child = InspectorDOMAgent::innerNextSibling(child))
244             updateSubtreeBreakpoints(child, rootBit, true);
245     }
246 }
247 
248 void InspectorDOMDebuggerAgent::removeDOMBreakpoint(ErrorString&amp; errorString, int nodeId, const String&amp; typeString)
249 {
<span class="line-modified">250     Node* node = m_domAgent-&gt;assertNode(errorString, nodeId);</span>






251     if (!node)
252         return;

253     int type = domTypeForName(errorString, typeString);
254     if (type == -1)
255         return;
256 
257     uint32_t rootBit = 1 &lt;&lt; type;
258     uint32_t mask = m_domBreakpoints.get(node) &amp; ~rootBit;
259     if (mask)
260         m_domBreakpoints.set(node, mask);
261     else
262         m_domBreakpoints.remove(node);
263 
264     if ((rootBit &amp; inheritableDOMBreakpointTypesMask) &amp;&amp; !(mask &amp; (rootBit &lt;&lt; domBreakpointDerivedTypeShift))) {
265         for (Node* child = InspectorDOMAgent::innerFirstChild(node); child; child = InspectorDOMAgent::innerNextSibling(child))
266             updateSubtreeBreakpoints(child, rootBit, false);
267     }
268 }
269 
270 void InspectorDOMDebuggerAgent::willInsertDOMNode(Node&amp; parent)
271 {
272     if (!m_debuggerAgent-&gt;breakpointsActive())
</pre>
<hr />
<pre>
293         Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
294         descriptionForDOMEvent(node, SubtreeModified, false, eventData.get());
295         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));
296     }
297 }
298 
299 void InspectorDOMDebuggerAgent::willModifyDOMAttr(Element&amp; element)
300 {
301     if (!m_debuggerAgent-&gt;breakpointsActive())
302         return;
303 
304     if (hasBreakpoint(&amp;element, AttributeModified)) {
305         Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
306         descriptionForDOMEvent(element, AttributeModified, false, eventData.get());
307         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));
308     }
309 }
310 
311 void InspectorDOMDebuggerAgent::descriptionForDOMEvent(Node&amp; target, int breakpointType, bool insertion, JSON::Object&amp; description)
312 {

313     ASSERT(hasBreakpoint(&amp;target, breakpointType));
314 


315     Node* breakpointOwner = &amp;target;
316     if ((1 &lt;&lt; breakpointType) &amp; inheritableDOMBreakpointTypesMask) {
<span class="line-modified">317         // For inheritable breakpoint types, target node isn&#39;t always the same as the node that owns a breakpoint.</span>
<span class="line-modified">318         // Target node may be unknown to frontend, so we need to push it first.</span>
<span class="line-modified">319         RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; targetNodeObject = m_domAgent-&gt;resolveNode(&amp;target, InspectorDebuggerAgent::backtraceObjectGroup);</span>
<span class="line-modified">320         description.setValue(&quot;targetNode&quot;, targetNodeObject);</span>


321 
322         // Find breakpoint owner node.
323         if (!insertion)
324             breakpointOwner = InspectorDOMAgent::innerParentNode(&amp;target);
325         ASSERT(breakpointOwner);
326         while (!(m_domBreakpoints.get(breakpointOwner) &amp; (1 &lt;&lt; breakpointType))) {
327             Node* parentNode = InspectorDOMAgent::innerParentNode(breakpointOwner);
328             if (!parentNode)
329                 break;
330             breakpointOwner = parentNode;
331         }
332 
333         if (breakpointType == SubtreeModified)
334             description.setBoolean(&quot;insertion&quot;, insertion);
335     }
336 
<span class="line-modified">337     int breakpointOwnerNodeId = m_domAgent-&gt;boundNodeId(breakpointOwner);</span>
<span class="line-modified">338     ASSERT(breakpointOwnerNodeId);</span>
<span class="line-modified">339     description.setInteger(&quot;nodeId&quot;, breakpointOwnerNodeId);</span>



340     description.setString(&quot;type&quot;, domTypeName(breakpointType));
341 }
342 
343 bool InspectorDOMDebuggerAgent::hasBreakpoint(Node* node, int type)
344 {
345     uint32_t rootBit = 1 &lt;&lt; type;
346     uint32_t derivedBit = rootBit &lt;&lt; domBreakpointDerivedTypeShift;
347     return m_domBreakpoints.get(node) &amp; (rootBit | derivedBit);
348 }
349 
350 void InspectorDOMDebuggerAgent::updateSubtreeBreakpoints(Node* node, uint32_t rootMask, bool set)
351 {
352     uint32_t oldMask = m_domBreakpoints.get(node);
353     uint32_t derivedMask = rootMask &lt;&lt; domBreakpointDerivedTypeShift;
354     uint32_t newMask = set ? oldMask | derivedMask : oldMask &amp; ~derivedMask;
355     if (newMask)
356         m_domBreakpoints.set(node, newMask);
357     else
358         m_domBreakpoints.remove(node);
359 
360     uint32_t newRootMask = rootMask &amp; ~newMask;
361     if (!newRootMask)
362         return;
363 
364     for (Node* child = InspectorDOMAgent::innerFirstChild(node); child; child = InspectorDOMAgent::innerNextSibling(child))
365         updateSubtreeBreakpoints(child, newRootMask, set);
366 }
367 
<span class="line-modified">368 void InspectorDOMDebuggerAgent::willHandleEvent(const Event&amp; event, const RegisteredEventListener&amp; registeredEventListener)</span>
369 {
<span class="line-modified">370     bool shouldPause = m_debuggerAgent-&gt;pauseOnNextStatementEnabled() || m_eventBreakpoints.contains(std::make_pair(Inspector::Protocol::DOMDebugger::EventBreakpointType::Listener, event.type()));</span>










371 
<span class="line-modified">372     if (!shouldPause &amp;&amp; m_domAgent)</span>
<span class="line-removed">373         shouldPause = m_domAgent-&gt;hasBreakpointForEventListener(*event.currentTarget(), event.type(), registeredEventListener.callback(), registeredEventListener.useCapture());</span>
374 



375     if (!shouldPause)
376         return;
377 
378     Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
379     eventData-&gt;setString(&quot;eventName&quot;_s, event.type());
<span class="line-modified">380     if (m_domAgent) {</span>
<span class="line-modified">381         int eventListenerId = m_domAgent-&gt;idForEventListener(*event.currentTarget(), event.type(), registeredEventListener.callback(), registeredEventListener.useCapture());</span>
382         if (eventListenerId)
383             eventData-&gt;setInteger(&quot;eventListenerId&quot;_s, eventListenerId);
384     }
385 
<span class="line-modified">386     m_debuggerAgent-&gt;schedulePauseOnNextStatement(Inspector::DebuggerFrontendDispatcher::Reason::EventListener, WTFMove(eventData));</span>





387 }
388 
389 void InspectorDOMDebuggerAgent::willFireTimer(bool oneShot)
390 {
<span class="line-modified">391     String eventName = oneShot ? &quot;setTimeout&quot;_s : &quot;setInterval&quot;_s;</span>
<span class="line-modified">392     bool shouldPause = m_debuggerAgent-&gt;pauseOnNextStatementEnabled() || m_eventBreakpoints.contains(std::make_pair(Inspector::Protocol::DOMDebugger::EventBreakpointType::Timer, eventName));</span>


393     if (!shouldPause)
394         return;
395 
<span class="line-modified">396     Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();</span>
<span class="line-modified">397     eventData-&gt;setString(&quot;eventName&quot;_s, eventName);</span>
<span class="line-removed">398     m_debuggerAgent-&gt;schedulePauseOnNextStatement(Inspector::DebuggerFrontendDispatcher::Reason::Timer, WTFMove(eventData));</span>
399 }
400 
401 void InspectorDOMDebuggerAgent::willFireAnimationFrame()
402 {
<span class="line-modified">403     String eventName = &quot;requestAnimationFrame&quot;_s;</span>
<span class="line-modified">404     bool shouldPause = m_debuggerAgent-&gt;pauseOnNextStatementEnabled() || m_eventBreakpoints.contains(std::make_pair(Inspector::Protocol::DOMDebugger::EventBreakpointType::AnimationFrame, eventName));</span>


405     if (!shouldPause)
406         return;
407 
<span class="line-modified">408     Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();</span>
<span class="line-removed">409     eventData-&gt;setString(&quot;eventName&quot;_s, eventName);</span>
<span class="line-removed">410     m_debuggerAgent-&gt;schedulePauseOnNextStatement(Inspector::DebuggerFrontendDispatcher::Reason::AnimationFrame, WTFMove(eventData));</span>
411 }
412 
<span class="line-modified">413 void InspectorDOMDebuggerAgent::setURLBreakpoint(ErrorString&amp;, const String&amp; url, const bool* optionalIsRegex)</span>
414 {
415     if (url.isEmpty()) {


416         m_pauseOnAllURLsEnabled = true;
417         return;
418     }
419 
420     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
<span class="line-modified">421     m_urlBreakpoints.set(url, isRegex ? URLBreakpointType::RegularExpression : URLBreakpointType::Text);</span>


422 }
423 
<span class="line-modified">424 void InspectorDOMDebuggerAgent::removeURLBreakpoint(ErrorString&amp;, const String&amp; url)</span>
425 {
426     if (url.isEmpty()) {


427         m_pauseOnAllURLsEnabled = false;
428         return;
429     }
430 
<span class="line-modified">431     m_urlBreakpoints.remove(url);</span>


432 }
433 
434 void InspectorDOMDebuggerAgent::breakOnURLIfNeeded(const String&amp; url, URLBreakpointSource source)
435 {
436     if (!m_debuggerAgent-&gt;breakpointsActive())
437         return;
438 
439     String breakpointURL;
440     if (m_pauseOnAllURLsEnabled)
441         breakpointURL = emptyString();
442     else {
443         for (auto&amp; entry : m_urlBreakpoints) {
444             const auto&amp; query = entry.key;
445             bool isRegex = entry.value == URLBreakpointType::RegularExpression;
446             auto regex = ContentSearchUtilities::createSearchRegex(query, false, isRegex);
447             if (regex.match(url) != -1) {
448                 breakpointURL = query;
449                 break;
450             }
451         }
</pre>
</td>
<td>
<hr />
<pre>
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;InspectorDOMDebuggerAgent.h&quot;
 34 
 35 #include &quot;Event.h&quot;
 36 #include &quot;Frame.h&quot;
 37 #include &quot;HTMLElement.h&quot;
 38 #include &quot;InspectorDOMAgent.h&quot;
 39 #include &quot;InstrumentingAgents.h&quot;
<span class="line-added"> 40 #include &quot;JSEvent.h&quot;</span>
 41 #include &quot;RegisteredEventListener.h&quot;
 42 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
<span class="line-added"> 43 #include &lt;JavaScriptCore/InjectedScript.h&gt;</span>
<span class="line-added"> 44 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;</span>
 45 #include &lt;JavaScriptCore/InspectorFrontendDispatchers.h&gt;
 46 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 47 #include &lt;wtf/JSONValues.h&gt;
 48 
 49 namespace {
 50 
 51 enum DOMBreakpointType {
 52     SubtreeModified,
 53     AttributeModified,
 54     NodeRemoved,
 55     DOMBreakpointTypesCount
 56 };
 57 
 58 const uint32_t inheritableDOMBreakpointTypesMask = (1 &lt;&lt; SubtreeModified);
 59 const int domBreakpointDerivedTypeShift = 16;
 60 
 61 }
 62 
 63 
 64 namespace WebCore {
 65 
 66 using namespace Inspector;
 67 
<span class="line-modified"> 68 InspectorDOMDebuggerAgent::InspectorDOMDebuggerAgent(WebAgentContext&amp; context, InspectorDebuggerAgent* debuggerAgent)</span>
 69     : InspectorAgentBase(&quot;DOMDebugger&quot;_s, context)
 70     , m_backendDispatcher(Inspector::DOMDebuggerBackendDispatcher::create(context.backendDispatcher, this))
<span class="line-modified"> 71     , m_injectedScriptManager(context.injectedScriptManager)</span>
 72     , m_debuggerAgent(debuggerAgent)
 73 {
<span class="line-modified"> 74     m_debuggerAgent-&gt;addListener(*this);</span>
 75 }
 76 
<span class="line-modified"> 77 InspectorDOMDebuggerAgent::~InspectorDOMDebuggerAgent() = default;</span>




 78 
 79 // Browser debugger agent enabled only when JS debugger is enabled.
 80 void InspectorDOMDebuggerAgent::debuggerWasEnabled()
 81 {
 82     m_instrumentingAgents.setInspectorDOMDebuggerAgent(this);
 83 }
 84 
 85 void InspectorDOMDebuggerAgent::debuggerWasDisabled()
 86 {
 87     disable();
 88 }
 89 
 90 void InspectorDOMDebuggerAgent::disable()
 91 {
 92     m_instrumentingAgents.setInspectorDOMDebuggerAgent(nullptr);
<span class="line-modified"> 93     m_domBreakpoints.clear();</span>
<span class="line-modified"> 94     m_listenerBreakpoints.clear();</span>
 95     m_urlBreakpoints.clear();
<span class="line-added"> 96     m_pauseOnAllAnimationFramesEnabled = false;</span>
<span class="line-added"> 97     m_pauseOnAllIntervalsEnabled = false;</span>
<span class="line-added"> 98     m_pauseOnAllListenersEnabled = false;</span>
<span class="line-added"> 99     m_pauseOnAllTimeoutsEnabled = false;</span>
100     m_pauseOnAllURLsEnabled = false;
101 }
102 
103 void InspectorDOMDebuggerAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
104 {
105 }
106 
107 void InspectorDOMDebuggerAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
108 {
109     disable();
110 }
111 
112 void InspectorDOMDebuggerAgent::discardAgent()
113 {
<span class="line-modified">114     m_debuggerAgent-&gt;removeListener(*this);</span>
115     m_debuggerAgent = nullptr;
116 }
117 
118 void InspectorDOMDebuggerAgent::frameDocumentUpdated(Frame&amp; frame)
119 {
120     if (!frame.isMainFrame())
121         return;
122 





123     m_domBreakpoints.clear();
124 }
125 
<span class="line-modified">126 void InspectorDOMDebuggerAgent::setEventBreakpoint(ErrorString&amp; errorString, const String&amp; breakpointTypeString, const String* eventName)</span>
127 {
128     if (breakpointTypeString.isEmpty()) {
<span class="line-modified">129         errorString = &quot;breakpointType is empty&quot;_s;</span>
130         return;
131     }
132 
133     auto breakpointType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::DOMDebugger::EventBreakpointType&gt;(breakpointTypeString);
134     if (!breakpointType) {
<span class="line-modified">135         errorString = makeString(&quot;Unknown breakpointType: &quot;_s, breakpointTypeString);</span>
136         return;
137     }
138 
<span class="line-modified">139     if (eventName &amp;&amp; !eventName-&gt;isEmpty()) {</span>
<span class="line-modified">140         if (breakpointType.value() == Inspector::Protocol::DOMDebugger::EventBreakpointType::Listener) {</span>
<span class="line-added">141             if (!m_listenerBreakpoints.add(*eventName))</span>
<span class="line-added">142                 errorString = &quot;Breakpoint with eventName already exists&quot;_s;</span>
<span class="line-added">143             return;</span>
<span class="line-added">144         }</span>
<span class="line-added">145 </span>
<span class="line-added">146         errorString = &quot;Unexpected eventName&quot;_s;</span>
147         return;
148     }
149 
<span class="line-modified">150     switch (breakpointType.value()) {</span>
<span class="line-added">151     case Inspector::Protocol::DOMDebugger::EventBreakpointType::AnimationFrame:</span>
<span class="line-added">152         if (m_pauseOnAllAnimationFramesEnabled)</span>
<span class="line-added">153             errorString = &quot;Breakpoint for AnimationFrame already exists&quot;_s;</span>
<span class="line-added">154         m_pauseOnAllAnimationFramesEnabled = true;</span>
<span class="line-added">155         break;</span>
<span class="line-added">156 </span>
<span class="line-added">157     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Interval:</span>
<span class="line-added">158         if (m_pauseOnAllIntervalsEnabled)</span>
<span class="line-added">159             errorString = &quot;Breakpoint for Interval already exists&quot;_s;</span>
<span class="line-added">160         m_pauseOnAllIntervalsEnabled = true;</span>
<span class="line-added">161         break;</span>
<span class="line-added">162 </span>
<span class="line-added">163     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Listener:</span>
<span class="line-added">164         if (m_pauseOnAllListenersEnabled)</span>
<span class="line-added">165             errorString = &quot;Breakpoint for Listener already exists&quot;_s;</span>
<span class="line-added">166         m_pauseOnAllListenersEnabled = true;</span>
<span class="line-added">167         break;</span>
<span class="line-added">168 </span>
<span class="line-added">169     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Timeout:</span>
<span class="line-added">170         if (m_pauseOnAllTimeoutsEnabled)</span>
<span class="line-added">171             errorString = &quot;Breakpoint for Timeout already exists&quot;_s;</span>
<span class="line-added">172         m_pauseOnAllTimeoutsEnabled = true;</span>
<span class="line-added">173         break;</span>
<span class="line-added">174     }</span>
175 }
176 
<span class="line-modified">177 void InspectorDOMDebuggerAgent::removeEventBreakpoint(ErrorString&amp; errorString, const String&amp; breakpointTypeString, const String* eventName)</span>
178 {
179     if (breakpointTypeString.isEmpty()) {
<span class="line-modified">180         errorString = &quot;breakpointType is empty&quot;_s;</span>
181         return;
182     }
183 
184     auto breakpointType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::DOMDebugger::EventBreakpointType&gt;(breakpointTypeString);
185     if (!breakpointType) {
<span class="line-modified">186         errorString = makeString(&quot;Unknown breakpointType: &quot;_s, breakpointTypeString);</span>
187         return;
188     }
189 
<span class="line-modified">190     if (eventName &amp;&amp; !eventName-&gt;isEmpty()) {</span>
<span class="line-modified">191         if (breakpointType.value() == Inspector::Protocol::DOMDebugger::EventBreakpointType::Listener) {</span>
<span class="line-added">192             if (!m_listenerBreakpoints.remove(*eventName))</span>
<span class="line-added">193                 errorString = &quot;Breakpoint for given eventName missing&quot;_s;</span>
<span class="line-added">194             return;</span>
<span class="line-added">195         }</span>
<span class="line-added">196 </span>
<span class="line-added">197         errorString = &quot;Unexpected eventName&quot;_s;</span>
198         return;
199     }
200 
<span class="line-modified">201     switch (breakpointType.value()) {</span>
<span class="line-added">202     case Inspector::Protocol::DOMDebugger::EventBreakpointType::AnimationFrame:</span>
<span class="line-added">203         if (!m_pauseOnAllAnimationFramesEnabled)</span>
<span class="line-added">204             errorString = &quot;Breakpoint for AnimationFrame missing&quot;_s;</span>
<span class="line-added">205         m_pauseOnAllAnimationFramesEnabled = false;</span>
<span class="line-added">206         break;</span>
<span class="line-added">207 </span>
<span class="line-added">208     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Interval:</span>
<span class="line-added">209         if (!m_pauseOnAllIntervalsEnabled)</span>
<span class="line-added">210             errorString = &quot;Breakpoint for Intervals missing&quot;_s;</span>
<span class="line-added">211         m_pauseOnAllIntervalsEnabled = false;</span>
<span class="line-added">212         break;</span>
<span class="line-added">213 </span>
<span class="line-added">214     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Listener:</span>
<span class="line-added">215         if (!m_pauseOnAllListenersEnabled)</span>
<span class="line-added">216             errorString = &quot;Breakpoint for Listeners missing&quot;_s;</span>
<span class="line-added">217         m_pauseOnAllListenersEnabled = false;</span>
<span class="line-added">218         break;</span>
<span class="line-added">219 </span>
<span class="line-added">220     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Timeout:</span>
<span class="line-added">221         if (!m_pauseOnAllTimeoutsEnabled)</span>
<span class="line-added">222             errorString = &quot;Breakpoint for Timeouts missing&quot;_s;</span>
<span class="line-added">223         m_pauseOnAllTimeoutsEnabled = false;</span>
<span class="line-added">224         break;</span>
<span class="line-added">225     }</span>
226 }
227 
<span class="line-modified">228 void InspectorDOMDebuggerAgent::willInvalidateStyleAttr(Element&amp; element)</span>
229 {
<span class="line-modified">230     if (!m_debuggerAgent-&gt;breakpointsActive())</span>
<span class="line-added">231         return;</span>
<span class="line-added">232 </span>
<span class="line-added">233     if (hasBreakpoint(&amp;element, AttributeModified)) {</span>
234         Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
<span class="line-modified">235         descriptionForDOMEvent(element, AttributeModified, false, eventData.get());</span>
236         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));
237     }
238 }
239 
240 void InspectorDOMDebuggerAgent::didInsertDOMNode(Node&amp; node)
241 {
242     if (m_domBreakpoints.size()) {
243         uint32_t mask = m_domBreakpoints.get(InspectorDOMAgent::innerParentNode(&amp;node));
244         uint32_t inheritableTypesMask = (mask | (mask &gt;&gt; domBreakpointDerivedTypeShift)) &amp; inheritableDOMBreakpointTypesMask;
245         if (inheritableTypesMask)
246             updateSubtreeBreakpoints(&amp;node, inheritableTypesMask, true);
247     }
248 }
249 
250 void InspectorDOMDebuggerAgent::didRemoveDOMNode(Node&amp; node)
251 {
252     if (m_domBreakpoints.size()) {
253         // Remove subtree breakpoints.
254         m_domBreakpoints.remove(&amp;node);
255         Vector&lt;Node*&gt; stack(1, InspectorDOMAgent::innerFirstChild(&amp;node));
256         do {
257             Node* node = stack.last();
258             stack.removeLast();
259             if (!node)
260                 continue;
261             m_domBreakpoints.remove(node);
262             stack.append(InspectorDOMAgent::innerFirstChild(node));
263             stack.append(InspectorDOMAgent::innerNextSibling(node));
264         } while (!stack.isEmpty());
265     }
266 }
267 
268 static int domTypeForName(ErrorString&amp; errorString, const String&amp; typeString)
269 {
270     if (typeString == &quot;subtree-modified&quot;)
271         return SubtreeModified;
272     if (typeString == &quot;attribute-modified&quot;)
273         return AttributeModified;
274     if (typeString == &quot;node-removed&quot;)
275         return NodeRemoved;
<span class="line-modified">276     errorString = makeString(&quot;Unknown type: &quot;, typeString);</span>
277     return -1;
278 }
279 
280 static String domTypeName(int type)
281 {
282     switch (type) {
283     case SubtreeModified: return &quot;subtree-modified&quot;_s;
284     case AttributeModified: return &quot;attribute-modified&quot;_s;
285     case NodeRemoved: return &quot;node-removed&quot;_s;
286     default: break;
287     }
288     return emptyString();
289 }
290 
291 void InspectorDOMDebuggerAgent::setDOMBreakpoint(ErrorString&amp; errorString, int nodeId, const String&amp; typeString)
292 {
<span class="line-modified">293     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();</span>
<span class="line-added">294     if (!domAgent) {</span>
<span class="line-added">295         errorString = &quot;DOM domain must be enabled&quot;_s;</span>
<span class="line-added">296         return;</span>
<span class="line-added">297     }</span>
<span class="line-added">298 </span>
<span class="line-added">299     Node* node = domAgent-&gt;assertNode(errorString, nodeId);</span>
300     if (!node)
301         return;
302 
303     int type = domTypeForName(errorString, typeString);
304     if (type == -1)
305         return;
306 
307     uint32_t rootBit = 1 &lt;&lt; type;
308     m_domBreakpoints.set(node, m_domBreakpoints.get(node) | rootBit);
309     if (rootBit &amp; inheritableDOMBreakpointTypesMask) {
310         for (Node* child = InspectorDOMAgent::innerFirstChild(node); child; child = InspectorDOMAgent::innerNextSibling(child))
311             updateSubtreeBreakpoints(child, rootBit, true);
312     }
313 }
314 
315 void InspectorDOMDebuggerAgent::removeDOMBreakpoint(ErrorString&amp; errorString, int nodeId, const String&amp; typeString)
316 {
<span class="line-modified">317     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();</span>
<span class="line-added">318     if (!domAgent) {</span>
<span class="line-added">319         errorString = &quot;DOM domain must be enabled&quot;_s;</span>
<span class="line-added">320         return;</span>
<span class="line-added">321     }</span>
<span class="line-added">322 </span>
<span class="line-added">323     Node* node = domAgent-&gt;assertNode(errorString, nodeId);</span>
324     if (!node)
325         return;
<span class="line-added">326 </span>
327     int type = domTypeForName(errorString, typeString);
328     if (type == -1)
329         return;
330 
331     uint32_t rootBit = 1 &lt;&lt; type;
332     uint32_t mask = m_domBreakpoints.get(node) &amp; ~rootBit;
333     if (mask)
334         m_domBreakpoints.set(node, mask);
335     else
336         m_domBreakpoints.remove(node);
337 
338     if ((rootBit &amp; inheritableDOMBreakpointTypesMask) &amp;&amp; !(mask &amp; (rootBit &lt;&lt; domBreakpointDerivedTypeShift))) {
339         for (Node* child = InspectorDOMAgent::innerFirstChild(node); child; child = InspectorDOMAgent::innerNextSibling(child))
340             updateSubtreeBreakpoints(child, rootBit, false);
341     }
342 }
343 
344 void InspectorDOMDebuggerAgent::willInsertDOMNode(Node&amp; parent)
345 {
346     if (!m_debuggerAgent-&gt;breakpointsActive())
</pre>
<hr />
<pre>
367         Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
368         descriptionForDOMEvent(node, SubtreeModified, false, eventData.get());
369         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));
370     }
371 }
372 
373 void InspectorDOMDebuggerAgent::willModifyDOMAttr(Element&amp; element)
374 {
375     if (!m_debuggerAgent-&gt;breakpointsActive())
376         return;
377 
378     if (hasBreakpoint(&amp;element, AttributeModified)) {
379         Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
380         descriptionForDOMEvent(element, AttributeModified, false, eventData.get());
381         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));
382     }
383 }
384 
385 void InspectorDOMDebuggerAgent::descriptionForDOMEvent(Node&amp; target, int breakpointType, bool insertion, JSON::Object&amp; description)
386 {
<span class="line-added">387     ASSERT(m_debuggerAgent-&gt;breakpointsActive());</span>
388     ASSERT(hasBreakpoint(&amp;target, breakpointType));
389 
<span class="line-added">390     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();</span>
<span class="line-added">391 </span>
392     Node* breakpointOwner = &amp;target;
393     if ((1 &lt;&lt; breakpointType) &amp; inheritableDOMBreakpointTypesMask) {
<span class="line-modified">394         if (domAgent) {</span>
<span class="line-modified">395             // For inheritable breakpoint types, target node isn&#39;t always the same as the node that owns a breakpoint.</span>
<span class="line-modified">396             // Target node may be unknown to frontend, so we need to push it first.</span>
<span class="line-modified">397             RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; targetNodeObject = domAgent-&gt;resolveNode(&amp;target, InspectorDebuggerAgent::backtraceObjectGroup);</span>
<span class="line-added">398             description.setValue(&quot;targetNode&quot;, targetNodeObject);</span>
<span class="line-added">399         }</span>
400 
401         // Find breakpoint owner node.
402         if (!insertion)
403             breakpointOwner = InspectorDOMAgent::innerParentNode(&amp;target);
404         ASSERT(breakpointOwner);
405         while (!(m_domBreakpoints.get(breakpointOwner) &amp; (1 &lt;&lt; breakpointType))) {
406             Node* parentNode = InspectorDOMAgent::innerParentNode(breakpointOwner);
407             if (!parentNode)
408                 break;
409             breakpointOwner = parentNode;
410         }
411 
412         if (breakpointType == SubtreeModified)
413             description.setBoolean(&quot;insertion&quot;, insertion);
414     }
415 
<span class="line-modified">416     if (domAgent) {</span>
<span class="line-modified">417         int breakpointOwnerNodeId = domAgent-&gt;boundNodeId(breakpointOwner);</span>
<span class="line-modified">418         ASSERT(breakpointOwnerNodeId);</span>
<span class="line-added">419         description.setInteger(&quot;nodeId&quot;, breakpointOwnerNodeId);</span>
<span class="line-added">420     }</span>
<span class="line-added">421 </span>
422     description.setString(&quot;type&quot;, domTypeName(breakpointType));
423 }
424 
425 bool InspectorDOMDebuggerAgent::hasBreakpoint(Node* node, int type)
426 {
427     uint32_t rootBit = 1 &lt;&lt; type;
428     uint32_t derivedBit = rootBit &lt;&lt; domBreakpointDerivedTypeShift;
429     return m_domBreakpoints.get(node) &amp; (rootBit | derivedBit);
430 }
431 
432 void InspectorDOMDebuggerAgent::updateSubtreeBreakpoints(Node* node, uint32_t rootMask, bool set)
433 {
434     uint32_t oldMask = m_domBreakpoints.get(node);
435     uint32_t derivedMask = rootMask &lt;&lt; domBreakpointDerivedTypeShift;
436     uint32_t newMask = set ? oldMask | derivedMask : oldMask &amp; ~derivedMask;
437     if (newMask)
438         m_domBreakpoints.set(node, newMask);
439     else
440         m_domBreakpoints.remove(node);
441 
442     uint32_t newRootMask = rootMask &amp; ~newMask;
443     if (!newRootMask)
444         return;
445 
446     for (Node* child = InspectorDOMAgent::innerFirstChild(node); child; child = InspectorDOMAgent::innerNextSibling(child))
447         updateSubtreeBreakpoints(child, newRootMask, set);
448 }
449 
<span class="line-modified">450 void InspectorDOMDebuggerAgent::willHandleEvent(Event&amp; event, const RegisteredEventListener&amp; registeredEventListener)</span>
451 {
<span class="line-modified">452     if (!m_debuggerAgent-&gt;breakpointsActive())</span>
<span class="line-added">453         return;</span>
<span class="line-added">454 </span>
<span class="line-added">455     auto state = event.target()-&gt;scriptExecutionContext()-&gt;execState();</span>
<span class="line-added">456     auto injectedScript = m_injectedScriptManager.injectedScriptFor(state);</span>
<span class="line-added">457     ASSERT(!injectedScript.hasNoValue());</span>
<span class="line-added">458     {</span>
<span class="line-added">459         JSC::JSLockHolder lock(state);</span>
<span class="line-added">460 </span>
<span class="line-added">461         injectedScript.setEventValue(toJS(state, deprecatedGlobalObjectForPrototype(state), event));</span>
<span class="line-added">462     }</span>
463 
<span class="line-modified">464     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();</span>

465 
<span class="line-added">466     bool shouldPause = m_debuggerAgent-&gt;pauseOnNextStatementEnabled() || m_pauseOnAllListenersEnabled || m_listenerBreakpoints.contains(event.type());</span>
<span class="line-added">467     if (!shouldPause &amp;&amp; domAgent)</span>
<span class="line-added">468         shouldPause = domAgent-&gt;hasBreakpointForEventListener(*event.currentTarget(), event.type(), registeredEventListener.callback(), registeredEventListener.useCapture());</span>
469     if (!shouldPause)
470         return;
471 
472     Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
473     eventData-&gt;setString(&quot;eventName&quot;_s, event.type());
<span class="line-modified">474     if (domAgent) {</span>
<span class="line-modified">475         int eventListenerId = domAgent-&gt;idForEventListener(*event.currentTarget(), event.type(), registeredEventListener.callback(), registeredEventListener.useCapture());</span>
476         if (eventListenerId)
477             eventData-&gt;setInteger(&quot;eventListenerId&quot;_s, eventListenerId);
478     }
479 
<span class="line-modified">480     m_debuggerAgent-&gt;schedulePauseOnNextStatement(Inspector::DebuggerFrontendDispatcher::Reason::Listener, WTFMove(eventData));</span>
<span class="line-added">481 }</span>
<span class="line-added">482 </span>
<span class="line-added">483 void InspectorDOMDebuggerAgent::didHandleEvent()</span>
<span class="line-added">484 {</span>
<span class="line-added">485     m_injectedScriptManager.clearEventValue();</span>
486 }
487 
488 void InspectorDOMDebuggerAgent::willFireTimer(bool oneShot)
489 {
<span class="line-modified">490     if (!m_debuggerAgent-&gt;breakpointsActive())</span>
<span class="line-modified">491         return;</span>
<span class="line-added">492 </span>
<span class="line-added">493     bool shouldPause = m_debuggerAgent-&gt;pauseOnNextStatementEnabled() || (oneShot ? m_pauseOnAllTimeoutsEnabled : m_pauseOnAllIntervalsEnabled);</span>
494     if (!shouldPause)
495         return;
496 
<span class="line-modified">497     auto breakReason = oneShot ? Inspector::DebuggerFrontendDispatcher::Reason::Timeout : Inspector::DebuggerFrontendDispatcher::Reason::Interval;</span>
<span class="line-modified">498     m_debuggerAgent-&gt;schedulePauseOnNextStatement(breakReason, nullptr);</span>

499 }
500 
501 void InspectorDOMDebuggerAgent::willFireAnimationFrame()
502 {
<span class="line-modified">503     if (!m_debuggerAgent-&gt;breakpointsActive())</span>
<span class="line-modified">504         return;</span>
<span class="line-added">505 </span>
<span class="line-added">506     bool shouldPause = m_debuggerAgent-&gt;pauseOnNextStatementEnabled() || m_pauseOnAllAnimationFramesEnabled;</span>
507     if (!shouldPause)
508         return;
509 
<span class="line-modified">510     m_debuggerAgent-&gt;schedulePauseOnNextStatement(Inspector::DebuggerFrontendDispatcher::Reason::AnimationFrame, nullptr);</span>


511 }
512 
<span class="line-modified">513 void InspectorDOMDebuggerAgent::setURLBreakpoint(ErrorString&amp; errorString, const String&amp; url, const bool* optionalIsRegex)</span>
514 {
515     if (url.isEmpty()) {
<span class="line-added">516         if (m_pauseOnAllURLsEnabled)</span>
<span class="line-added">517             errorString = &quot;Breakpoint for all URLs already exists&quot;_s;</span>
518         m_pauseOnAllURLsEnabled = true;
519         return;
520     }
521 
522     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
<span class="line-modified">523     auto result = m_urlBreakpoints.set(url, isRegex ? URLBreakpointType::RegularExpression : URLBreakpointType::Text);</span>
<span class="line-added">524     if (!result.isNewEntry)</span>
<span class="line-added">525         errorString = &quot;Breakpoint for given url already exists&quot;_s;</span>
526 }
527 
<span class="line-modified">528 void InspectorDOMDebuggerAgent::removeURLBreakpoint(ErrorString&amp; errorString, const String&amp; url)</span>
529 {
530     if (url.isEmpty()) {
<span class="line-added">531         if (!m_pauseOnAllURLsEnabled)</span>
<span class="line-added">532             errorString = &quot;Breakpoint for all URLs missing&quot;_s;</span>
533         m_pauseOnAllURLsEnabled = false;
534         return;
535     }
536 
<span class="line-modified">537     auto result = m_urlBreakpoints.remove(url);</span>
<span class="line-added">538     if (!result)</span>
<span class="line-added">539         errorString = &quot;Breakpoint for given url missing&quot;_s;</span>
540 }
541 
542 void InspectorDOMDebuggerAgent::breakOnURLIfNeeded(const String&amp; url, URLBreakpointSource source)
543 {
544     if (!m_debuggerAgent-&gt;breakpointsActive())
545         return;
546 
547     String breakpointURL;
548     if (m_pauseOnAllURLsEnabled)
549         breakpointURL = emptyString();
550     else {
551         for (auto&amp; entry : m_urlBreakpoints) {
552             const auto&amp; query = entry.key;
553             bool isRegex = entry.value == URLBreakpointType::RegularExpression;
554             auto regex = ContentSearchUtilities::createSearchRegex(query, false, isRegex);
555             if (regex.match(url) != -1) {
556                 breakpointURL = query;
557                 break;
558             }
559         }
</pre>
</td>
</tr>
</table>
<center><a href="InspectorDOMAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorDOMDebuggerAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>