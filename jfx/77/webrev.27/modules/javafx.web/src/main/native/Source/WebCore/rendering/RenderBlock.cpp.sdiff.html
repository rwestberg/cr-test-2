<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PaintPhase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBlock.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlock.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;RenderBlock.h&quot;
  26 
  27 #include &quot;AXObjectCache.h&quot;
  28 #include &quot;Document.h&quot;
  29 #include &quot;Editor.h&quot;
  30 #include &quot;Element.h&quot;

  31 #include &quot;FloatQuad.h&quot;
  32 #include &quot;Frame.h&quot;
  33 #include &quot;FrameSelection.h&quot;
  34 #include &quot;FrameView.h&quot;
  35 #include &quot;GraphicsContext.h&quot;
  36 #include &quot;HTMLNames.h&quot;
  37 #include &quot;HitTestLocation.h&quot;
  38 #include &quot;HitTestResult.h&quot;
  39 #include &quot;InlineElementBox.h&quot;
  40 #include &quot;InlineIterator.h&quot;
  41 #include &quot;InlineTextBox.h&quot;
  42 #include &quot;LayoutRepainter.h&quot;
  43 #include &quot;LogicalSelectionOffsetCaches.h&quot;
  44 #include &quot;OverflowEvent.h&quot;
  45 #include &quot;Page.h&quot;
  46 #include &quot;PaintInfo.h&quot;
  47 #include &quot;RenderBlockFlow.h&quot;
  48 #include &quot;RenderBoxFragmentInfo.h&quot;
  49 #include &quot;RenderButton.h&quot;
  50 #include &quot;RenderChildIterator.h&quot;
</pre>
<hr />
<pre>
  86 
  87 struct SameSizeAsRenderBlock : public RenderBox {
  88 };
  89 
  90 COMPILE_ASSERT(sizeof(RenderBlock) == sizeof(SameSizeAsRenderBlock), RenderBlock_should_stay_small);
  91 
  92 typedef HashMap&lt;const RenderBlock*, std::unique_ptr&lt;TrackedRendererListHashSet&gt;&gt; TrackedDescendantsMap;
  93 typedef HashMap&lt;const RenderBox*, std::unique_ptr&lt;HashSet&lt;const RenderBlock*&gt;&gt;&gt; TrackedContainerMap;
  94 
  95 static TrackedDescendantsMap* percentHeightDescendantsMap;
  96 static TrackedContainerMap* percentHeightContainerMap;
  97 
  98 static void insertIntoTrackedRendererMaps(const RenderBlock&amp; container, RenderBox&amp; descendant)
  99 {
 100     if (!percentHeightDescendantsMap) {
 101         percentHeightDescendantsMap = new TrackedDescendantsMap;
 102         percentHeightContainerMap = new TrackedContainerMap;
 103     }
 104 
 105     auto&amp; descendantSet = percentHeightDescendantsMap-&gt;ensure(&amp;container, [] {
<span class="line-modified"> 106         return std::make_unique&lt;TrackedRendererListHashSet&gt;();</span>
 107     }).iterator-&gt;value;
 108 
 109     bool added = descendantSet-&gt;add(&amp;descendant).isNewEntry;
 110     if (!added) {
 111         ASSERT(percentHeightContainerMap-&gt;get(&amp;descendant));
 112         ASSERT(percentHeightContainerMap-&gt;get(&amp;descendant)-&gt;contains(&amp;container));
 113         return;
 114     }
 115 
 116     auto&amp; containerSet = percentHeightContainerMap-&gt;ensure(&amp;descendant, [] {
<span class="line-modified"> 117         return std::make_unique&lt;HashSet&lt;const RenderBlock*&gt;&gt;();</span>
 118     }).iterator-&gt;value;
 119 
 120     ASSERT(!containerSet-&gt;contains(&amp;container));
 121     containerSet-&gt;add(&amp;container);
 122 }
 123 
 124 static void removeFromTrackedRendererMaps(RenderBox&amp; descendant)
 125 {
 126     if (!percentHeightDescendantsMap)
 127         return;
 128 
 129     std::unique_ptr&lt;HashSet&lt;const RenderBlock*&gt;&gt; containerSet = percentHeightContainerMap-&gt;take(&amp;descendant);
 130     if (!containerSet)
 131         return;
 132 
 133     for (auto* container : *containerSet) {
 134         // FIXME: Disabling this assert temporarily until we fix the layout
 135         // bugs associated with positioned objects not properly cleared from
 136         // their ancestor chain before being moved. See webkit bug 93766.
 137         // ASSERT(descendant-&gt;isDescendantOf(container));
</pre>
<hr />
<pre>
 143         ASSERT(descendantSet-&gt;contains(&amp;descendant));
 144         descendantSet-&gt;remove(&amp;descendant);
 145         if (descendantSet-&gt;isEmpty())
 146             percentHeightDescendantsMap-&gt;remove(descendantsMapIterator);
 147     }
 148 }
 149 
 150 class PositionedDescendantsMap {
 151 public:
 152     enum class MoveDescendantToEnd { No, Yes };
 153     void addDescendant(const RenderBlock&amp; containingBlock, RenderBox&amp; positionedDescendant, MoveDescendantToEnd moveDescendantToEnd)
 154     {
 155         // Protect against double insert where a descendant would end up with multiple containing blocks.
 156         auto* previousContainingBlock = m_containerMap.get(&amp;positionedDescendant);
 157         if (previousContainingBlock &amp;&amp; previousContainingBlock != &amp;containingBlock) {
 158             if (auto* descendants = m_descendantsMap.get(previousContainingBlock))
 159                 descendants-&gt;remove(&amp;positionedDescendant);
 160         }
 161 
 162         auto&amp; descendants = m_descendantsMap.ensure(&amp;containingBlock, [] {
<span class="line-modified"> 163             return std::make_unique&lt;TrackedRendererListHashSet&gt;();</span>
 164         }).iterator-&gt;value;
 165 
 166         bool isNewEntry = moveDescendantToEnd == MoveDescendantToEnd::Yes ? descendants-&gt;appendOrMoveToLast(&amp;positionedDescendant).isNewEntry
 167             : descendants-&gt;add(&amp;positionedDescendant).isNewEntry;
 168         if (!isNewEntry) {
 169             ASSERT(m_containerMap.contains(&amp;positionedDescendant));
 170             return;
 171         }
 172         m_containerMap.set(&amp;positionedDescendant, &amp;containingBlock);
 173     }
 174 
 175     void removeDescendant(const RenderBox&amp; positionedDescendant)
 176     {
 177         auto* containingBlock = m_containerMap.take(&amp;positionedDescendant);
 178         if (!containingBlock)
 179             return;
 180 
 181         auto descendantsIterator = m_descendantsMap.find(containingBlock);
 182         ASSERT(descendantsIterator != m_descendantsMap.end());
 183         if (descendantsIterator == m_descendantsMap.end())
</pre>
<hr />
<pre>
 510     }
 511 
 512     // If the height is 0 or auto, then whether or not we are a self-collapsing block depends
 513     // on whether we have content that is all self-collapsing or not.
 514     if (hasAutoHeight || ((logicalHeightLength.isFixed() || logicalHeightLength.isPercentOrCalculated()) &amp;&amp; logicalHeightLength.isZero()))
 515         return !childrenPreventSelfCollapsing();
 516 
 517     return false;
 518 }
 519 
 520 static inline UpdateScrollInfoAfterLayoutTransaction* currentUpdateScrollInfoAfterLayoutTransaction()
 521 {
 522     if (!updateScrollInfoAfterLayoutTransactionStack())
 523         return nullptr;
 524     return &amp;updateScrollInfoAfterLayoutTransactionStack()-&gt;last();
 525 }
 526 
 527 void RenderBlock::beginUpdateScrollInfoAfterLayoutTransaction()
 528 {
 529     if (!updateScrollInfoAfterLayoutTransactionStack())
<span class="line-modified"> 530         updateScrollInfoAfterLayoutTransactionStack() = std::make_unique&lt;DelayedUpdateScrollInfoStack&gt;();</span>
 531     if (updateScrollInfoAfterLayoutTransactionStack()-&gt;isEmpty() || currentUpdateScrollInfoAfterLayoutTransaction()-&gt;view != &amp;view())
 532         updateScrollInfoAfterLayoutTransactionStack()-&gt;append(UpdateScrollInfoAfterLayoutTransaction(view()));
 533     ++currentUpdateScrollInfoAfterLayoutTransaction()-&gt;nestedCount;
 534 }
 535 
 536 void RenderBlock::endAndCommitUpdateScrollInfoAfterLayoutTransaction()
 537 {
 538     UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 539     ASSERT(transaction);
 540     ASSERT(transaction-&gt;view == &amp;view());
 541     if (--transaction-&gt;nestedCount)
 542         return;
 543 
 544     // Calling RenderLayer::updateScrollInfoAfterLayout() may cause its associated block to layout again and
 545     // updates its scroll info (i.e. call RenderBlock::updateScrollInfoAfterLayout()). We remove |transaction|
 546     // from the transaction stack to ensure that all subsequent calls to RenderBlock::updateScrollInfoAfterLayout()
 547     // are dispatched immediately. That is, to ensure that such subsequent calls aren&#39;t added to |transaction|
 548     // while we are processing it.
 549     auto blocksToUpdate = copyToVector(transaction-&gt;blocks);
 550     updateScrollInfoAfterLayoutTransactionStack()-&gt;removeLast();
</pre>
<hr />
<pre>
 602     UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 603     bool isDelayingUpdateScrollInfoAfterLayoutInView = transaction &amp;&amp; transaction-&gt;view == &amp;view();
 604     if (hasControlClip() &amp;&amp; m_overflow &amp;&amp; !isDelayingUpdateScrollInfoAfterLayoutInView)
 605         clearLayoutOverflow();
 606 
 607     invalidateBackgroundObscurationStatus();
 608 }
 609 
 610 static RenderBlockRareData* getBlockRareData(const RenderBlock&amp; block)
 611 {
 612     return gRareDataMap ? gRareDataMap-&gt;get(&amp;block) : nullptr;
 613 }
 614 
 615 static RenderBlockRareData&amp; ensureBlockRareData(const RenderBlock&amp; block)
 616 {
 617     if (!gRareDataMap)
 618         gRareDataMap = new RenderBlockRareDataMap;
 619 
 620     auto&amp; rareData = gRareDataMap-&gt;add(&amp;block, nullptr).iterator-&gt;value;
 621     if (!rareData)
<span class="line-modified"> 622         rareData = std::make_unique&lt;RenderBlockRareData&gt;();</span>
 623     return *rareData.get();
 624 }
 625 
 626 void RenderBlock::preparePaginationBeforeBlockLayout(bool&amp; relayoutChildren)
 627 {
 628     // Fragments changing widths can force us to relayout our children.
 629     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 630     if (fragmentedFlow)
 631         fragmentedFlow-&gt;logicalWidthChangedInFragmentsForBlock(this, relayoutChildren);
 632 }
 633 
 634 bool RenderBlock::recomputeLogicalWidth()
 635 {
 636     LayoutUnit oldWidth = logicalWidth();
 637 
 638     updateLogicalWidth();
 639 
 640     bool hasBorderOrPaddingLogicalWidthChanged = this-&gt;hasBorderOrPaddingLogicalWidthChanged();
 641     setShouldForceRelayoutChildren(false);
 642 
</pre>
<hr />
<pre>
1223     }
1224 
1225     // Paint legends just above the border before we scroll or clip.
1226     if (paintPhase == PaintPhase::BlockBackground || paintPhase == PaintPhase::ChildBlockBackground || paintPhase == PaintPhase::Selection)
1227         paintExcludedChildrenInBorder(paintInfo, paintOffset);
1228 
1229     if (paintPhase == PaintPhase::Mask &amp;&amp; style().visibility() == Visibility::Visible) {
1230         paintMask(paintInfo, paintOffset);
1231         return;
1232     }
1233 
1234     if (paintPhase == PaintPhase::ClippingMask &amp;&amp; style().visibility() == Visibility::Visible) {
1235         paintClippingMask(paintInfo, paintOffset);
1236         return;
1237     }
1238 
1239     // If just painting the root background, then return.
1240     if (paintInfo.paintRootBackgroundOnly())
1241         return;
1242 

















1243     // Adjust our painting position if we&#39;re inside a scrolled layer (e.g., an overflow:auto div).
1244     LayoutPoint scrolledOffset = paintOffset;
1245     scrolledOffset.moveBy(-scrollPosition());
1246 
1247     // Column rules need to account for scrolling and clipping.
1248     // FIXME: Clipping of column rules does not work. We will need a separate paint phase for column rules I suspect in order to get
1249     // clipping correct (since it has to paint as background but is still considered &quot;contents&quot;).
1250     if ((paintPhase == PaintPhase::BlockBackground || paintPhase == PaintPhase::ChildBlockBackground) &amp;&amp; style().visibility() == Visibility::Visible)
1251         paintColumnRules(paintInfo, scrolledOffset);
1252 
1253     // Done with backgrounds, borders and column rules.
1254     if (paintPhase == PaintPhase::BlockBackground)
1255         return;
1256 
1257     // 2. paint contents
1258     if (paintPhase != PaintPhase::SelfOutline)
1259         paintContents(paintInfo, scrolledOffset);
1260 
1261     // 3. paint selection
1262     // FIXME: Make this work with multi column layouts.  For now don&#39;t fill gaps.
</pre>
<hr />
<pre>
2228 
2229     int scrollbarWidth = intrinsicScrollbarLogicalWidth();
2230     maxLogicalWidth += scrollbarWidth;
2231     minLogicalWidth += scrollbarWidth;
2232 }
2233 
2234 void RenderBlock::computePreferredLogicalWidths()
2235 {
2236     ASSERT(preferredLogicalWidthsDirty());
2237 
2238     m_minPreferredLogicalWidth = 0;
2239     m_maxPreferredLogicalWidth = 0;
2240 
2241     const RenderStyle&amp; styleToUse = style();
2242     if (!isTableCell() &amp;&amp; styleToUse.logicalWidth().isFixed() &amp;&amp; styleToUse.logicalWidth().value() &gt;= 0
2243         &amp;&amp; !(isDeprecatedFlexItem() &amp;&amp; !styleToUse.logicalWidth().intValue()))
2244         m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalWidth().value());
2245     else
2246         computeIntrinsicLogicalWidths(m_minPreferredLogicalWidth, m_maxPreferredLogicalWidth);
2247 
<span class="line-removed">2248     if (styleToUse.logicalMinWidth().isFixed() &amp;&amp; styleToUse.logicalMinWidth().value() &gt; 0) {</span>
<span class="line-removed">2249         m_maxPreferredLogicalWidth = std::max(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMinWidth().value()));</span>
<span class="line-removed">2250         m_minPreferredLogicalWidth = std::max(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMinWidth().value()));</span>
<span class="line-removed">2251     }</span>
<span class="line-removed">2252 </span>
2253     if (styleToUse.logicalMaxWidth().isFixed()) {
2254         m_maxPreferredLogicalWidth = std::min(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMaxWidth().value()));
2255         m_minPreferredLogicalWidth = std::min(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMaxWidth().value()));
2256     }
2257 





2258     LayoutUnit borderAndPadding = borderAndPaddingLogicalWidth();
2259     m_minPreferredLogicalWidth += borderAndPadding;
2260     m_maxPreferredLogicalWidth += borderAndPadding;
2261 
2262     setPreferredLogicalWidthsDirty(false);
2263 }
2264 
2265 void RenderBlock::computeBlockPreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
2266 {
2267     const RenderStyle&amp; styleToUse = style();
2268     bool nowrap = styleToUse.whiteSpace() == WhiteSpace::NoWrap;
2269 
2270     RenderObject* child = firstChild();
2271     RenderBlock* containingBlock = this-&gt;containingBlock();
2272     LayoutUnit floatLeftWidth, floatRightWidth;
2273 
2274     LayoutUnit childMinWidth;
2275     LayoutUnit childMaxWidth;
2276     bool hadExcludedChildren = computePreferredWidthsForExcludedChildren(childMinWidth, childMaxWidth);
2277     if (hadExcludedChildren) {
</pre>
<hr />
<pre>
2821     return caretRect;
2822 }
2823 
2824 void RenderBlock::addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp;, const LayoutPoint&amp;, const RenderLayerModelObject*)
2825 {
2826     ASSERT_NOT_REACHED();
2827 }
2828 
2829 void RenderBlock::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject* paintContainer)
2830 {
2831     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2832     // above and below us (thus getting merged with them to form a single irregular shape).
2833     auto* inlineContinuation = this-&gt;inlineContinuation();
2834     if (inlineContinuation) {
2835         // FIXME: This check really isn&#39;t accurate.
2836         bool nextInlineHasLineBox = inlineContinuation-&gt;firstLineBox();
2837         // FIXME: This is wrong. The principal renderer may not be the continuation preceding this block.
2838         // FIXME: This is wrong for block-flows that are horizontal.
2839         // https://bugs.webkit.org/show_bug.cgi?id=46781
2840         bool prevInlineHasLineBox = downcast&lt;RenderInline&gt;(*inlineContinuation-&gt;element()-&gt;renderer()).firstLineBox();
<span class="line-modified">2841         float topMargin = prevInlineHasLineBox ? collapsedMarginBefore() : 0_lu;</span>
<span class="line-modified">2842         float bottomMargin = nextInlineHasLineBox ? collapsedMarginAfter() : 0_lu;</span>
2843         LayoutRect rect(additionalOffset.x(), additionalOffset.y() - topMargin, width(), height() + topMargin + bottomMargin);
2844         if (!rect.isEmpty())
2845             rects.append(rect);
2846     } else if (width() &amp;&amp; height())
2847         rects.append(LayoutRect(additionalOffset, size()));
2848 
2849     if (!hasOverflowClip() &amp;&amp; !hasControlClip()) {
2850         if (childrenInline())
2851             addFocusRingRectsForInlineChildren(rects, additionalOffset, paintContainer);
2852 
2853         for (auto&amp; box : childrenOfType&lt;RenderBox&gt;(*this)) {
2854             if (is&lt;RenderListMarker&gt;(box))
2855                 continue;
2856 
2857             FloatPoint pos;
2858             // FIXME: This doesn&#39;t work correctly with transforms.
2859             if (box.layer())
2860                 pos = box.localToContainerPoint(FloatPoint(), paintContainer);
2861             else
2862                 pos = FloatPoint(additionalOffset.x() + box.x(), additionalOffset.y() + box.y());
</pre>
<hr />
<pre>
3094 }
3095 
3096 TextRun RenderBlock::constructTextRun(StringView stringView, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)
3097 {
3098     auto textDirection = TextDirection::LTR;
3099     bool directionalOverride = style.rtlOrdering() == Order::Visual;
3100     if (flags != DefaultTextRunFlags) {
3101         if (flags &amp; RespectDirection)
3102             textDirection = style.direction();
3103         if (flags &amp; RespectDirectionOverride)
3104             directionalOverride |= isOverride(style.unicodeBidi());
3105     }
3106     return TextRun(stringView, 0, 0, expansion, textDirection, directionalOverride);
3107 }
3108 
3109 TextRun RenderBlock::constructTextRun(const String&amp; string, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)
3110 {
3111     return constructTextRun(StringView(string), style, expansion, flags);
3112 }
3113 
<span class="line-modified">3114 TextRun RenderBlock::constructTextRun(const AtomicString&amp; atomicString, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)</span>
3115 {
<span class="line-modified">3116     return constructTextRun(StringView(atomicString), style, expansion, flags);</span>
3117 }
3118 
3119 TextRun RenderBlock::constructTextRun(const RenderText&amp; text, const RenderStyle&amp; style, ExpansionBehavior expansion)
3120 {
3121     return constructTextRun(text.stringView(), style, expansion);
3122 }
3123 
3124 TextRun RenderBlock::constructTextRun(const RenderText&amp; text, unsigned offset, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3125 {
3126     unsigned stop = offset + length;
3127     ASSERT(stop &lt;= text.text().length());
3128     return constructTextRun(text.stringView(offset, stop), style, expansion);
3129 }
3130 
3131 TextRun RenderBlock::constructTextRun(const LChar* characters, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3132 {
3133     return constructTextRun(StringView(characters, length), style, expansion);
3134 }
3135 
3136 TextRun RenderBlock::constructTextRun(const UChar* characters, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
</pre>
</td>
<td>
<hr />
<pre>
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;RenderBlock.h&quot;
  26 
  27 #include &quot;AXObjectCache.h&quot;
  28 #include &quot;Document.h&quot;
  29 #include &quot;Editor.h&quot;
  30 #include &quot;Element.h&quot;
<span class="line-added">  31 #include &quot;EventRegion.h&quot;</span>
  32 #include &quot;FloatQuad.h&quot;
  33 #include &quot;Frame.h&quot;
  34 #include &quot;FrameSelection.h&quot;
  35 #include &quot;FrameView.h&quot;
  36 #include &quot;GraphicsContext.h&quot;
  37 #include &quot;HTMLNames.h&quot;
  38 #include &quot;HitTestLocation.h&quot;
  39 #include &quot;HitTestResult.h&quot;
  40 #include &quot;InlineElementBox.h&quot;
  41 #include &quot;InlineIterator.h&quot;
  42 #include &quot;InlineTextBox.h&quot;
  43 #include &quot;LayoutRepainter.h&quot;
  44 #include &quot;LogicalSelectionOffsetCaches.h&quot;
  45 #include &quot;OverflowEvent.h&quot;
  46 #include &quot;Page.h&quot;
  47 #include &quot;PaintInfo.h&quot;
  48 #include &quot;RenderBlockFlow.h&quot;
  49 #include &quot;RenderBoxFragmentInfo.h&quot;
  50 #include &quot;RenderButton.h&quot;
  51 #include &quot;RenderChildIterator.h&quot;
</pre>
<hr />
<pre>
  87 
  88 struct SameSizeAsRenderBlock : public RenderBox {
  89 };
  90 
  91 COMPILE_ASSERT(sizeof(RenderBlock) == sizeof(SameSizeAsRenderBlock), RenderBlock_should_stay_small);
  92 
  93 typedef HashMap&lt;const RenderBlock*, std::unique_ptr&lt;TrackedRendererListHashSet&gt;&gt; TrackedDescendantsMap;
  94 typedef HashMap&lt;const RenderBox*, std::unique_ptr&lt;HashSet&lt;const RenderBlock*&gt;&gt;&gt; TrackedContainerMap;
  95 
  96 static TrackedDescendantsMap* percentHeightDescendantsMap;
  97 static TrackedContainerMap* percentHeightContainerMap;
  98 
  99 static void insertIntoTrackedRendererMaps(const RenderBlock&amp; container, RenderBox&amp; descendant)
 100 {
 101     if (!percentHeightDescendantsMap) {
 102         percentHeightDescendantsMap = new TrackedDescendantsMap;
 103         percentHeightContainerMap = new TrackedContainerMap;
 104     }
 105 
 106     auto&amp; descendantSet = percentHeightDescendantsMap-&gt;ensure(&amp;container, [] {
<span class="line-modified"> 107         return makeUnique&lt;TrackedRendererListHashSet&gt;();</span>
 108     }).iterator-&gt;value;
 109 
 110     bool added = descendantSet-&gt;add(&amp;descendant).isNewEntry;
 111     if (!added) {
 112         ASSERT(percentHeightContainerMap-&gt;get(&amp;descendant));
 113         ASSERT(percentHeightContainerMap-&gt;get(&amp;descendant)-&gt;contains(&amp;container));
 114         return;
 115     }
 116 
 117     auto&amp; containerSet = percentHeightContainerMap-&gt;ensure(&amp;descendant, [] {
<span class="line-modified"> 118         return makeUnique&lt;HashSet&lt;const RenderBlock*&gt;&gt;();</span>
 119     }).iterator-&gt;value;
 120 
 121     ASSERT(!containerSet-&gt;contains(&amp;container));
 122     containerSet-&gt;add(&amp;container);
 123 }
 124 
 125 static void removeFromTrackedRendererMaps(RenderBox&amp; descendant)
 126 {
 127     if (!percentHeightDescendantsMap)
 128         return;
 129 
 130     std::unique_ptr&lt;HashSet&lt;const RenderBlock*&gt;&gt; containerSet = percentHeightContainerMap-&gt;take(&amp;descendant);
 131     if (!containerSet)
 132         return;
 133 
 134     for (auto* container : *containerSet) {
 135         // FIXME: Disabling this assert temporarily until we fix the layout
 136         // bugs associated with positioned objects not properly cleared from
 137         // their ancestor chain before being moved. See webkit bug 93766.
 138         // ASSERT(descendant-&gt;isDescendantOf(container));
</pre>
<hr />
<pre>
 144         ASSERT(descendantSet-&gt;contains(&amp;descendant));
 145         descendantSet-&gt;remove(&amp;descendant);
 146         if (descendantSet-&gt;isEmpty())
 147             percentHeightDescendantsMap-&gt;remove(descendantsMapIterator);
 148     }
 149 }
 150 
 151 class PositionedDescendantsMap {
 152 public:
 153     enum class MoveDescendantToEnd { No, Yes };
 154     void addDescendant(const RenderBlock&amp; containingBlock, RenderBox&amp; positionedDescendant, MoveDescendantToEnd moveDescendantToEnd)
 155     {
 156         // Protect against double insert where a descendant would end up with multiple containing blocks.
 157         auto* previousContainingBlock = m_containerMap.get(&amp;positionedDescendant);
 158         if (previousContainingBlock &amp;&amp; previousContainingBlock != &amp;containingBlock) {
 159             if (auto* descendants = m_descendantsMap.get(previousContainingBlock))
 160                 descendants-&gt;remove(&amp;positionedDescendant);
 161         }
 162 
 163         auto&amp; descendants = m_descendantsMap.ensure(&amp;containingBlock, [] {
<span class="line-modified"> 164             return makeUnique&lt;TrackedRendererListHashSet&gt;();</span>
 165         }).iterator-&gt;value;
 166 
 167         bool isNewEntry = moveDescendantToEnd == MoveDescendantToEnd::Yes ? descendants-&gt;appendOrMoveToLast(&amp;positionedDescendant).isNewEntry
 168             : descendants-&gt;add(&amp;positionedDescendant).isNewEntry;
 169         if (!isNewEntry) {
 170             ASSERT(m_containerMap.contains(&amp;positionedDescendant));
 171             return;
 172         }
 173         m_containerMap.set(&amp;positionedDescendant, &amp;containingBlock);
 174     }
 175 
 176     void removeDescendant(const RenderBox&amp; positionedDescendant)
 177     {
 178         auto* containingBlock = m_containerMap.take(&amp;positionedDescendant);
 179         if (!containingBlock)
 180             return;
 181 
 182         auto descendantsIterator = m_descendantsMap.find(containingBlock);
 183         ASSERT(descendantsIterator != m_descendantsMap.end());
 184         if (descendantsIterator == m_descendantsMap.end())
</pre>
<hr />
<pre>
 511     }
 512 
 513     // If the height is 0 or auto, then whether or not we are a self-collapsing block depends
 514     // on whether we have content that is all self-collapsing or not.
 515     if (hasAutoHeight || ((logicalHeightLength.isFixed() || logicalHeightLength.isPercentOrCalculated()) &amp;&amp; logicalHeightLength.isZero()))
 516         return !childrenPreventSelfCollapsing();
 517 
 518     return false;
 519 }
 520 
 521 static inline UpdateScrollInfoAfterLayoutTransaction* currentUpdateScrollInfoAfterLayoutTransaction()
 522 {
 523     if (!updateScrollInfoAfterLayoutTransactionStack())
 524         return nullptr;
 525     return &amp;updateScrollInfoAfterLayoutTransactionStack()-&gt;last();
 526 }
 527 
 528 void RenderBlock::beginUpdateScrollInfoAfterLayoutTransaction()
 529 {
 530     if (!updateScrollInfoAfterLayoutTransactionStack())
<span class="line-modified"> 531         updateScrollInfoAfterLayoutTransactionStack() = makeUnique&lt;DelayedUpdateScrollInfoStack&gt;();</span>
 532     if (updateScrollInfoAfterLayoutTransactionStack()-&gt;isEmpty() || currentUpdateScrollInfoAfterLayoutTransaction()-&gt;view != &amp;view())
 533         updateScrollInfoAfterLayoutTransactionStack()-&gt;append(UpdateScrollInfoAfterLayoutTransaction(view()));
 534     ++currentUpdateScrollInfoAfterLayoutTransaction()-&gt;nestedCount;
 535 }
 536 
 537 void RenderBlock::endAndCommitUpdateScrollInfoAfterLayoutTransaction()
 538 {
 539     UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 540     ASSERT(transaction);
 541     ASSERT(transaction-&gt;view == &amp;view());
 542     if (--transaction-&gt;nestedCount)
 543         return;
 544 
 545     // Calling RenderLayer::updateScrollInfoAfterLayout() may cause its associated block to layout again and
 546     // updates its scroll info (i.e. call RenderBlock::updateScrollInfoAfterLayout()). We remove |transaction|
 547     // from the transaction stack to ensure that all subsequent calls to RenderBlock::updateScrollInfoAfterLayout()
 548     // are dispatched immediately. That is, to ensure that such subsequent calls aren&#39;t added to |transaction|
 549     // while we are processing it.
 550     auto blocksToUpdate = copyToVector(transaction-&gt;blocks);
 551     updateScrollInfoAfterLayoutTransactionStack()-&gt;removeLast();
</pre>
<hr />
<pre>
 603     UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 604     bool isDelayingUpdateScrollInfoAfterLayoutInView = transaction &amp;&amp; transaction-&gt;view == &amp;view();
 605     if (hasControlClip() &amp;&amp; m_overflow &amp;&amp; !isDelayingUpdateScrollInfoAfterLayoutInView)
 606         clearLayoutOverflow();
 607 
 608     invalidateBackgroundObscurationStatus();
 609 }
 610 
 611 static RenderBlockRareData* getBlockRareData(const RenderBlock&amp; block)
 612 {
 613     return gRareDataMap ? gRareDataMap-&gt;get(&amp;block) : nullptr;
 614 }
 615 
 616 static RenderBlockRareData&amp; ensureBlockRareData(const RenderBlock&amp; block)
 617 {
 618     if (!gRareDataMap)
 619         gRareDataMap = new RenderBlockRareDataMap;
 620 
 621     auto&amp; rareData = gRareDataMap-&gt;add(&amp;block, nullptr).iterator-&gt;value;
 622     if (!rareData)
<span class="line-modified"> 623         rareData = makeUnique&lt;RenderBlockRareData&gt;();</span>
 624     return *rareData.get();
 625 }
 626 
 627 void RenderBlock::preparePaginationBeforeBlockLayout(bool&amp; relayoutChildren)
 628 {
 629     // Fragments changing widths can force us to relayout our children.
 630     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 631     if (fragmentedFlow)
 632         fragmentedFlow-&gt;logicalWidthChangedInFragmentsForBlock(this, relayoutChildren);
 633 }
 634 
 635 bool RenderBlock::recomputeLogicalWidth()
 636 {
 637     LayoutUnit oldWidth = logicalWidth();
 638 
 639     updateLogicalWidth();
 640 
 641     bool hasBorderOrPaddingLogicalWidthChanged = this-&gt;hasBorderOrPaddingLogicalWidthChanged();
 642     setShouldForceRelayoutChildren(false);
 643 
</pre>
<hr />
<pre>
1224     }
1225 
1226     // Paint legends just above the border before we scroll or clip.
1227     if (paintPhase == PaintPhase::BlockBackground || paintPhase == PaintPhase::ChildBlockBackground || paintPhase == PaintPhase::Selection)
1228         paintExcludedChildrenInBorder(paintInfo, paintOffset);
1229 
1230     if (paintPhase == PaintPhase::Mask &amp;&amp; style().visibility() == Visibility::Visible) {
1231         paintMask(paintInfo, paintOffset);
1232         return;
1233     }
1234 
1235     if (paintPhase == PaintPhase::ClippingMask &amp;&amp; style().visibility() == Visibility::Visible) {
1236         paintClippingMask(paintInfo, paintOffset);
1237         return;
1238     }
1239 
1240     // If just painting the root background, then return.
1241     if (paintInfo.paintRootBackgroundOnly())
1242         return;
1243 
<span class="line-added">1244     if (paintPhase == PaintPhase::EventRegion) {</span>
<span class="line-added">1245         auto borderRect = LayoutRect(paintOffset, size());</span>
<span class="line-added">1246 </span>
<span class="line-added">1247         if (visibleToHitTesting()) {</span>
<span class="line-added">1248             auto borderRegion = approximateAsRegion(style().getRoundedBorderFor(borderRect));</span>
<span class="line-added">1249             paintInfo.eventRegionContext-&gt;unite(borderRegion, style());</span>
<span class="line-added">1250         }</span>
<span class="line-added">1251 </span>
<span class="line-added">1252         // No need to check descendants if we don&#39;t have overflow and the area is already covered.</span>
<span class="line-added">1253         bool needsTraverseDescendants = hasVisualOverflow() || !paintInfo.eventRegionContext-&gt;contains(enclosingIntRect(borderRect));</span>
<span class="line-added">1254 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)</span>
<span class="line-added">1255         needsTraverseDescendants = needsTraverseDescendants || document().mayHaveElementsWithNonAutoTouchAction();</span>
<span class="line-added">1256 #endif</span>
<span class="line-added">1257         if (!needsTraverseDescendants)</span>
<span class="line-added">1258             return;</span>
<span class="line-added">1259     }</span>
<span class="line-added">1260 </span>
1261     // Adjust our painting position if we&#39;re inside a scrolled layer (e.g., an overflow:auto div).
1262     LayoutPoint scrolledOffset = paintOffset;
1263     scrolledOffset.moveBy(-scrollPosition());
1264 
1265     // Column rules need to account for scrolling and clipping.
1266     // FIXME: Clipping of column rules does not work. We will need a separate paint phase for column rules I suspect in order to get
1267     // clipping correct (since it has to paint as background but is still considered &quot;contents&quot;).
1268     if ((paintPhase == PaintPhase::BlockBackground || paintPhase == PaintPhase::ChildBlockBackground) &amp;&amp; style().visibility() == Visibility::Visible)
1269         paintColumnRules(paintInfo, scrolledOffset);
1270 
1271     // Done with backgrounds, borders and column rules.
1272     if (paintPhase == PaintPhase::BlockBackground)
1273         return;
1274 
1275     // 2. paint contents
1276     if (paintPhase != PaintPhase::SelfOutline)
1277         paintContents(paintInfo, scrolledOffset);
1278 
1279     // 3. paint selection
1280     // FIXME: Make this work with multi column layouts.  For now don&#39;t fill gaps.
</pre>
<hr />
<pre>
2246 
2247     int scrollbarWidth = intrinsicScrollbarLogicalWidth();
2248     maxLogicalWidth += scrollbarWidth;
2249     minLogicalWidth += scrollbarWidth;
2250 }
2251 
2252 void RenderBlock::computePreferredLogicalWidths()
2253 {
2254     ASSERT(preferredLogicalWidthsDirty());
2255 
2256     m_minPreferredLogicalWidth = 0;
2257     m_maxPreferredLogicalWidth = 0;
2258 
2259     const RenderStyle&amp; styleToUse = style();
2260     if (!isTableCell() &amp;&amp; styleToUse.logicalWidth().isFixed() &amp;&amp; styleToUse.logicalWidth().value() &gt;= 0
2261         &amp;&amp; !(isDeprecatedFlexItem() &amp;&amp; !styleToUse.logicalWidth().intValue()))
2262         m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalWidth().value());
2263     else
2264         computeIntrinsicLogicalWidths(m_minPreferredLogicalWidth, m_maxPreferredLogicalWidth);
2265 





2266     if (styleToUse.logicalMaxWidth().isFixed()) {
2267         m_maxPreferredLogicalWidth = std::min(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMaxWidth().value()));
2268         m_minPreferredLogicalWidth = std::min(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMaxWidth().value()));
2269     }
2270 
<span class="line-added">2271     if (styleToUse.logicalMinWidth().isFixed() &amp;&amp; styleToUse.logicalMinWidth().value() &gt; 0) {</span>
<span class="line-added">2272         m_maxPreferredLogicalWidth = std::max(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMinWidth().value()));</span>
<span class="line-added">2273         m_minPreferredLogicalWidth = std::max(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMinWidth().value()));</span>
<span class="line-added">2274     }</span>
<span class="line-added">2275 </span>
2276     LayoutUnit borderAndPadding = borderAndPaddingLogicalWidth();
2277     m_minPreferredLogicalWidth += borderAndPadding;
2278     m_maxPreferredLogicalWidth += borderAndPadding;
2279 
2280     setPreferredLogicalWidthsDirty(false);
2281 }
2282 
2283 void RenderBlock::computeBlockPreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
2284 {
2285     const RenderStyle&amp; styleToUse = style();
2286     bool nowrap = styleToUse.whiteSpace() == WhiteSpace::NoWrap;
2287 
2288     RenderObject* child = firstChild();
2289     RenderBlock* containingBlock = this-&gt;containingBlock();
2290     LayoutUnit floatLeftWidth, floatRightWidth;
2291 
2292     LayoutUnit childMinWidth;
2293     LayoutUnit childMaxWidth;
2294     bool hadExcludedChildren = computePreferredWidthsForExcludedChildren(childMinWidth, childMaxWidth);
2295     if (hadExcludedChildren) {
</pre>
<hr />
<pre>
2839     return caretRect;
2840 }
2841 
2842 void RenderBlock::addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp;, const LayoutPoint&amp;, const RenderLayerModelObject*)
2843 {
2844     ASSERT_NOT_REACHED();
2845 }
2846 
2847 void RenderBlock::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject* paintContainer)
2848 {
2849     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2850     // above and below us (thus getting merged with them to form a single irregular shape).
2851     auto* inlineContinuation = this-&gt;inlineContinuation();
2852     if (inlineContinuation) {
2853         // FIXME: This check really isn&#39;t accurate.
2854         bool nextInlineHasLineBox = inlineContinuation-&gt;firstLineBox();
2855         // FIXME: This is wrong. The principal renderer may not be the continuation preceding this block.
2856         // FIXME: This is wrong for block-flows that are horizontal.
2857         // https://bugs.webkit.org/show_bug.cgi?id=46781
2858         bool prevInlineHasLineBox = downcast&lt;RenderInline&gt;(*inlineContinuation-&gt;element()-&gt;renderer()).firstLineBox();
<span class="line-modified">2859         auto topMargin = prevInlineHasLineBox ? collapsedMarginBefore() : 0_lu;</span>
<span class="line-modified">2860         auto bottomMargin = nextInlineHasLineBox ? collapsedMarginAfter() : 0_lu;</span>
2861         LayoutRect rect(additionalOffset.x(), additionalOffset.y() - topMargin, width(), height() + topMargin + bottomMargin);
2862         if (!rect.isEmpty())
2863             rects.append(rect);
2864     } else if (width() &amp;&amp; height())
2865         rects.append(LayoutRect(additionalOffset, size()));
2866 
2867     if (!hasOverflowClip() &amp;&amp; !hasControlClip()) {
2868         if (childrenInline())
2869             addFocusRingRectsForInlineChildren(rects, additionalOffset, paintContainer);
2870 
2871         for (auto&amp; box : childrenOfType&lt;RenderBox&gt;(*this)) {
2872             if (is&lt;RenderListMarker&gt;(box))
2873                 continue;
2874 
2875             FloatPoint pos;
2876             // FIXME: This doesn&#39;t work correctly with transforms.
2877             if (box.layer())
2878                 pos = box.localToContainerPoint(FloatPoint(), paintContainer);
2879             else
2880                 pos = FloatPoint(additionalOffset.x() + box.x(), additionalOffset.y() + box.y());
</pre>
<hr />
<pre>
3112 }
3113 
3114 TextRun RenderBlock::constructTextRun(StringView stringView, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)
3115 {
3116     auto textDirection = TextDirection::LTR;
3117     bool directionalOverride = style.rtlOrdering() == Order::Visual;
3118     if (flags != DefaultTextRunFlags) {
3119         if (flags &amp; RespectDirection)
3120             textDirection = style.direction();
3121         if (flags &amp; RespectDirectionOverride)
3122             directionalOverride |= isOverride(style.unicodeBidi());
3123     }
3124     return TextRun(stringView, 0, 0, expansion, textDirection, directionalOverride);
3125 }
3126 
3127 TextRun RenderBlock::constructTextRun(const String&amp; string, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)
3128 {
3129     return constructTextRun(StringView(string), style, expansion, flags);
3130 }
3131 
<span class="line-modified">3132 TextRun RenderBlock::constructTextRun(const AtomString&amp; atomString, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)</span>
3133 {
<span class="line-modified">3134     return constructTextRun(StringView(atomString), style, expansion, flags);</span>
3135 }
3136 
3137 TextRun RenderBlock::constructTextRun(const RenderText&amp; text, const RenderStyle&amp; style, ExpansionBehavior expansion)
3138 {
3139     return constructTextRun(text.stringView(), style, expansion);
3140 }
3141 
3142 TextRun RenderBlock::constructTextRun(const RenderText&amp; text, unsigned offset, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3143 {
3144     unsigned stop = offset + length;
3145     ASSERT(stop &lt;= text.text().length());
3146     return constructTextRun(text.stringView(offset, stop), style, expansion);
3147 }
3148 
3149 TextRun RenderBlock::constructTextRun(const LChar* characters, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3150 {
3151     return constructTextRun(StringView(characters, length), style, expansion);
3152 }
3153 
3154 TextRun RenderBlock::constructTextRun(const UChar* characters, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
</pre>
</td>
</tr>
</table>
<center><a href="PaintPhase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBlock.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>