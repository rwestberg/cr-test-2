<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/css/makeprop.pl</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 #! /usr/bin/env perl
   2 #
   3 #   This file is part of the WebKit project
   4 #
   5 #   Copyright (C) 1999 Waldo Bastian (bastian@kde.org)
   6 #   Copyright (C) 2007-2018 Apple Inc. All rights reserved.
   7 #   Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   8 #   Copyright (C) 2010 Andras Becsi (abecsi@inf.u-szeged.hu), University of Szeged
   9 #   Copyright (C) 2013 Google Inc. All rights reserved.
  10 #
  11 #   This library is free software; you can redistribute it and/or
  12 #   modify it under the terms of the GNU Library General Public
  13 #   License as published by the Free Software Foundation; either
  14 #   version 2 of the License, or (at your option) any later version.
  15 #
  16 #   This library is distributed in the hope that it will be useful,
  17 #   but WITHOUT ANY WARRANTY; without even the implied warranty of
  18 #   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19 #   Library General Public License for more details.
  20 #
  21 #   You should have received a copy of the GNU Library General Public License
  22 #   along with this library; see the file COPYING.LIB.  If not, write to
  23 #   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24 #   Boston, MA 02110-1301, USA.
  25 
  26 use strict;
  27 use warnings;
  28 
  29 use English;
  30 use File::Spec;
  31 use Getopt::Long;
  32 use JSON::PP;
  33 
  34 sub addProperty($$);
  35 sub isPropertyEnabled($$);
  36 sub removeInactiveCodegenProperties($$);
  37 
  38 my $inputFile = &quot;CSSProperties.json&quot;;
  39 
  40 my $defines = &quot;&quot;;
  41 my $gperf;
  42 GetOptions(&#39;defines=s&#39; =&gt; \$defines,
  43            &#39;gperf-executable=s&#39; =&gt; \$gperf);
  44 
  45 my $input;
  46 {
  47     local $INPUT_RECORD_SEPARATOR; # No separator; read through until end-of-file.
  48     open(JSON, &quot;&lt;&quot;, $inputFile) or die &quot;Cannot open $inputFile.\n&quot;;
  49     $input = &lt;JSON&gt;;
  50     close(JSON);
  51 }
  52 
  53 my $jsonDecoder = JSON::PP-&gt;new-&gt;utf8;
  54 my $jsonHashRef = $jsonDecoder-&gt;decode($input);
  55 my $propertiesHashRef = $jsonHashRef-&gt;{properties};
  56 my @allNames = keys(%$propertiesHashRef);
  57 die &quot;We&#39;ve reached more than 1024 CSS properties, please make sure to update CSSProperty/StylePropertyMetadata accordingly&quot; if @allNames &gt; 1024;
  58 
  59 my %defines = map { $_ =&gt; 1 } split(/ /, $defines);
  60 
  61 my @names;
  62 my @internalProprerties;
  63 my %runtimeFlags;
  64 my $numPredefinedProperties = 2;
  65 my %nameIsInherited;
  66 my %nameIsHighPriority;
  67 my %propertiesWithStyleBuilderOptions;
  68 my %styleBuilderOptions = (
  69     &quot;animatable&quot; =&gt; 1, # Defined in Source/WebCore/css/StyleBuilderConverter.h
  70     &quot;auto-functions&quot; =&gt; 1,
  71     &quot;conditional-converter&quot; =&gt; 1,
  72     &quot;converter&quot; =&gt; 1,
  73     &quot;custom&quot; =&gt; 1,
  74     &quot;fill-layer-property&quot; =&gt; 1,
  75     &quot;font-property&quot; =&gt; 1,
  76     &quot;getter&quot; =&gt; 1,
  77     &quot;initial&quot; =&gt; 1,
  78     &quot;longhands&quot; =&gt; 1,
  79     &quot;name-for-methods&quot; =&gt; 1,
  80     &quot;no-default-color&quot; =&gt; 1,
  81     &quot;svg&quot; =&gt; 1,
  82     &quot;skip-builder&quot; =&gt; 1,
  83     &quot;setter&quot; =&gt; 1,
  84     &quot;visited-link-color-support&quot; =&gt; 1,
  85 );
  86 my %nameToId;
  87 my %nameToAliases;
  88 
  89 for my $name (@allNames) {
  90     my $value = $propertiesHashRef-&gt;{$name};
  91     my $valueType = ref($value);
  92     
  93     if ($valueType eq &quot;HASH&quot;) {
  94         removeInactiveCodegenProperties($name, \%$value);
  95         if (isPropertyEnabled($name, $value)) {
  96             addProperty($name, $value);
  97         }
  98     } else {
  99         die &quot;$name does not have a supported value type. Only dictionary types are supported.&quot;;
 100     }
 101 }
 102 
 103 sub matchEnableFlags($)
 104 {
 105     my ($enable_flag) = @_;
 106     
 107     if (exists($defines{$enable_flag})) {
 108         return 1;
 109     }
 110 
 111     if (substr($enable_flag, 0, 1) eq &quot;!&quot; &amp;&amp; !exists($defines{substr($enable_flag, 1)})) {
 112         return 1;
 113     }
 114     
 115     return 0;
 116 }
 117 
 118 sub removeInactiveCodegenProperties($$)
 119 {
 120     my ($name, $propertyValue) = @_;
 121 
 122     if (!exists($propertyValue-&gt;{&quot;codegen-properties&quot;})) {
 123         return;
 124     }
 125     
 126     my $codegen_properties = $propertyValue-&gt;{&quot;codegen-properties&quot;};
 127     my $valueType = ref($codegen_properties);
 128 
 129     if ($valueType ne &quot;ARRAY&quot;) {
 130         return;
 131     }
 132 
 133     # Pick one based on &quot;enable-if&quot;
 134     my $matching_codegen_options;
 135     foreach my $entry (@{$codegen_properties}) {
 136         if (!exists($entry-&gt;{&quot;enable-if&quot;})) {
 137             print &quot;Found &#39;codegen-properties&#39; array with an unconditional entry under &#39;$name&#39;. This is probably unintentional.\n&quot;;
 138             $matching_codegen_options = $entry;
 139             last;
 140         }
 141 
 142         my $enable_flags = $entry-&gt;{&quot;enable-if&quot;};
 143         if (matchEnableFlags($enable_flags)) {
 144             $matching_codegen_options = $entry;
 145             last;
 146         }
 147 
 148         $matching_codegen_options = $entry;
 149     }
 150     
 151     $propertyValue-&gt;{&quot;codegen-properties&quot;} = $matching_codegen_options;
 152 }
 153 
 154 sub isPropertyEnabled($$)
 155 {
 156     my ($name, $propertyValue) = @_;
 157 
 158     if (!exists($propertyValue-&gt;{&quot;codegen-properties&quot;})) {
 159         return 1;
 160     }
 161     
 162     my $codegen_properties = $propertyValue-&gt;{&quot;codegen-properties&quot;};
 163     if ($codegen_properties-&gt;{&quot;skip-codegen&quot;}) {
 164         return 0;
 165     }
 166 
 167     if (!exists($codegen_properties-&gt;{&quot;enable-if&quot;})) {
 168         return 1;
 169     }
 170 
 171     return matchEnableFlags($codegen_properties-&gt;{&quot;enable-if&quot;});
 172 }
 173 
 174 sub addProperty($$)
 175 {
 176     my ($name, $optionsHashRef) = @_;
 177 
 178     push @names, $name;
 179 
 180     my $id = $name;
 181     $id =~ s/(^[^-])|-(.)/uc($1||$2)/ge;
 182     $nameToId{$name} = $id;
 183 
 184     for my $optionName (keys %{$optionsHashRef}) {
 185         if ($optionName eq &quot;codegen-properties&quot;) {
 186             my $codegenProperties = $optionsHashRef-&gt;{&quot;codegen-properties&quot;};
 187             for my $codegenOptionName (keys %$codegenProperties) {
 188                 if ($codegenOptionName eq &quot;enable-if&quot;) {
 189                     next;
 190                 } elsif ($codegenOptionName eq &quot;skip-codegen&quot;) {
 191                     next;
 192                 } elsif ($codegenOptionName eq &quot;comment&quot;) {
 193                     next;
 194                 } elsif ($codegenOptionName eq &quot;high-priority&quot;) {
 195                     $nameIsHighPriority{$name} = 1;
 196                 } elsif ($codegenOptionName eq &quot;aliases&quot;) {
 197                     $nameToAliases{$name} = $codegenProperties-&gt;{&quot;aliases&quot;};
 198                 } elsif ($styleBuilderOptions{$codegenOptionName}) {
 199                     $propertiesWithStyleBuilderOptions{$name}{$codegenOptionName} = $codegenProperties-&gt;{$codegenOptionName};
 200                 } elsif ($codegenOptionName eq &quot;internal-only&quot;) {
 201                     # internal-only properties exist to make it easier to parse compound properties (e.g. background-repeat) as if they were shorthands.
 202                     push @internalProprerties, $name
 203                 } elsif ($codegenOptionName eq &quot;runtime-flag&quot;) {
 204                     $runtimeFlags{$name} = $codegenProperties-&gt;{&quot;runtime-flag&quot;};
 205                 } else {
 206                     die &quot;Unrecognized codegen property \&quot;$codegenOptionName\&quot; for $name property.&quot;;
 207                 }
 208             }
 209         } elsif ($optionName eq &quot;animatable&quot;) {
 210              $propertiesWithStyleBuilderOptions{$name}{&quot;animatable&quot;} = $optionsHashRef-&gt;{&quot;animatable&quot;};
 211         } elsif ($optionName eq &quot;inherited&quot;) {
 212             $nameIsInherited{$name} = 1;
 213         } elsif ($optionName eq &quot;values&quot;) {
 214             # FIXME: Implement.
 215         }
 216         # We allow unrecognized options to pass through without error to support annotation.
 217     }
 218 }
 219 
 220 sub sortByDescendingPriorityAndName
 221 {
 222     # Sort names with high priority to the front
 223     if (!!$nameIsHighPriority{$a} &lt; !!$nameIsHighPriority{$b}) {
 224         return 1;
 225     }
 226     if (!!$nameIsHighPriority{$a} &gt; !!$nameIsHighPriority{$b}) {
 227         return -1;
 228     }
 229     # Sort names without leading &#39;-&#39; to the front
 230     if (substr($a, 0, 1) eq &quot;-&quot; &amp;&amp; substr($b, 0, 1) ne &quot;-&quot;) {
 231         return 1;
 232     }
 233     if (substr($a, 0, 1) ne &quot;-&quot; &amp;&amp; substr($b, 0, 1) eq &quot;-&quot;) {
 234         return -1;
 235     }
 236     return $a cmp $b;
 237 }
 238 
 239 @names = sort sortByDescendingPriorityAndName @names;
 240 
 241 open GPERF, &quot;&gt;CSSPropertyNames.gperf&quot; || die &quot;Could not open CSSPropertyNames.gperf for writing&quot;;
 242 print GPERF &lt;&lt; &quot;EOF&quot;;
 243 %{
 244 /* This file is automatically generated from $inputFile by makeprop, do not edit */
 245 #include &quot;config.h&quot;
 246 #include \&quot;CSSProperty.h\&quot;
 247 #include \&quot;CSSPropertyNames.h\&quot;
 248 #include \&quot;HashTools.h\&quot;
 249 #include &quot;RuntimeEnabledFeatures.h&quot;
 250 #include &lt;wtf/ASCIICType.h&gt;
 251 #include &lt;wtf/text/AtomicString.h&gt;
 252 #include &lt;wtf/text/WTFString.h&gt;
 253 #include &lt;string.h&gt;
 254 
 255 IGNORE_WARNINGS_BEGIN(\&quot;implicit-fallthrough\&quot;)
 256 
 257 // Older versions of gperf like to use the `register` keyword.
 258 #define register
 259 
 260 namespace WebCore {
 261 
 262 // Using std::numeric_limits&lt;uint16_t&gt;::max() here would be cleaner,
 263 // but is not possible due to missing constexpr support in MSVC 2013.
 264 static_assert(numCSSProperties + 1 &lt;= 65535, &quot;CSSPropertyID should fit into uint16_t.&quot;);
 265 
 266 EOF
 267 
 268 print GPERF &quot;const char* const propertyNameStrings[numCSSProperties] = {\n&quot;;
 269 foreach my $name (@names) {
 270   print GPERF &quot;    \&quot;$name\&quot;,\n&quot;;
 271 }
 272 print GPERF &quot;};\n\n&quot;;
 273 
 274 print GPERF &lt;&lt; &quot;EOF&quot;;
 275 %}
 276 %struct-type
 277 struct Property;
 278 %omit-struct-type
 279 %language=C++
 280 %readonly-tables
 281 %global-table
 282 %compare-strncmp
 283 %define class-name CSSPropertyNamesHash
 284 %define lookup-function-name findPropertyImpl
 285 %define hash-function-name propery_hash_function
 286 %define word-array-name property_wordlist
 287 %enum
 288 %%
 289 EOF
 290 
 291 foreach my $name (@names) {
 292   print GPERF $name . &quot;, CSSProperty&quot; . $nameToId{$name} . &quot;\n&quot;;
 293 }
 294 
 295 for my $name (@names) {
 296     if (!$nameToAliases{$name}) {
 297         next;
 298     }
 299     for my $alias (@{$nameToAliases{$name}}) {
 300         print GPERF $alias . &quot;, CSSProperty&quot; . $nameToId{$name} . &quot;\n&quot;;
 301     }
 302 }
 303 
 304 print GPERF &lt;&lt; &quot;EOF&quot;;
 305 %%
 306 const Property* findProperty(const char* str, unsigned int len)
 307 {
 308     return CSSPropertyNamesHash::findPropertyImpl(str, len);
 309 }
 310 
 311 bool isInternalCSSProperty(const CSSPropertyID id)
 312 {
 313     switch (id) {
 314 EOF
 315 
 316 foreach my $name (sort @internalProprerties) {
 317   print GPERF &quot;    case CSSPropertyID::CSSProperty&quot; . $nameToId{$name} . &quot;:\n&quot;;
 318 }
 319 
 320 print GPERF &lt;&lt; &quot;EOF&quot;;
 321         return true;
 322     default:
 323         return false;
 324     }
 325 }
 326 
 327 bool isEnabledCSSProperty(const CSSPropertyID id)
 328 {
 329     switch (id) {
 330 EOF
 331 
 332 foreach my $name (keys %runtimeFlags) {
 333   print GPERF &quot;    case CSSPropertyID::CSSProperty&quot; . $nameToId{$name} . &quot;:\n&quot;;
 334   print GPERF &quot;        return RuntimeEnabledFeatures::sharedFeatures().&quot; . $runtimeFlags{$name} . &quot;Enabled();\n&quot;;
 335 }
 336 
 337 print GPERF &lt;&lt; &quot;EOF&quot;;
 338     default:
 339         return true;
 340     }
 341 }
 342 
 343 const char* getPropertyName(CSSPropertyID id)
 344 {
 345     if (id &lt; firstCSSProperty)
 346         return 0;
 347     int index = id - firstCSSProperty;
 348     if (index &gt;= numCSSProperties)
 349         return 0;
 350     return propertyNameStrings[index];
 351 }
 352 
 353 const AtomicString&amp; getPropertyNameAtomicString(CSSPropertyID id)
 354 {
 355     if (id &lt; firstCSSProperty)
 356         return nullAtom();
 357     int index = id - firstCSSProperty;
 358     if (index &gt;= numCSSProperties)
 359         return nullAtom();
 360 
 361     static AtomicString* propertyStrings = new AtomicString[numCSSProperties]; // Intentionally never destroyed.
 362     AtomicString&amp; propertyString = propertyStrings[index];
 363     if (propertyString.isNull()) {
 364         const char* propertyName = propertyNameStrings[index];
 365         propertyString = AtomicString(propertyName, strlen(propertyName), AtomicString::ConstructFromLiteral);
 366     }
 367     return propertyString;
 368 }
 369 
 370 String getPropertyNameString(CSSPropertyID id)
 371 {
 372     // We share the StringImpl with the AtomicStrings.
 373     return getPropertyNameAtomicString(id).string();
 374 }
 375 
 376 String getJSPropertyName(CSSPropertyID id)
 377 {
 378     char result[maxCSSPropertyNameLength + 1];
 379     const char* cssPropertyName = getPropertyName(id);
 380     const char* propertyNamePointer = cssPropertyName;
 381     if (!propertyNamePointer)
 382         return emptyString();
 383 
 384     char* resultPointer = result;
 385     while (char character = *propertyNamePointer++) {
 386         if (character == &#39;-&#39;) {
 387             char nextCharacter = *propertyNamePointer++;
 388             if (!nextCharacter)
 389                 break;
 390             character = (propertyNamePointer - 2 != cssPropertyName) ? toASCIIUpper(nextCharacter) : nextCharacter;
 391         }
 392         *resultPointer++ = character;
 393     }
 394     *resultPointer = &#39;\\0&#39;;
 395     return WTF::String(result);
 396 }
 397 
 398 static const bool isInheritedPropertyTable[numCSSProperties + $numPredefinedProperties] = {
 399     false, // CSSPropertyInvalid
 400     true, // CSSPropertyCustom
 401 EOF
 402 
 403 foreach my $name (@names) {
 404   my $id = $nameToId{$name};
 405   my $value = $nameIsInherited{$name} ? &quot;true &quot; : &quot;false&quot;;
 406   print GPERF &quot;    $value, // CSSProperty$id\n&quot;;
 407 }
 408 
 409 print GPERF&lt;&lt; &quot;EOF&quot;;
 410 };
 411 
 412 bool CSSProperty::isInheritedProperty(CSSPropertyID id)
 413 {
 414     ASSERT(id &lt;= lastCSSProperty);
 415     ASSERT(id != CSSPropertyInvalid);
 416     return isInheritedPropertyTable[id];
 417 }
 418 
 419 Vector&lt;String&gt; CSSProperty::aliasesForProperty(CSSPropertyID id)
 420 {
 421     switch (id) {
 422 EOF
 423 
 424 for my $name (@names) {
 425     if (!$nameToAliases{$name}) {
 426         next;
 427     }
 428     print GPERF &quot;    case CSSPropertyID::CSSProperty&quot; . $nameToId{$name} . &quot;:\n&quot;;
 429     print GPERF &quot;        return { \&quot;&quot; . join(&quot;\&quot;_s, \&quot;&quot;, @{$nameToAliases{$name}}) . &quot;\&quot;_s };\n&quot;;
 430 }
 431 
 432 print GPERF &lt;&lt; &quot;EOF&quot;;
 433     default:
 434         return { };
 435     }
 436 }
 437 
 438 } // namespace WebCore
 439 
 440 IGNORE_WARNINGS_END
 441 EOF
 442 
 443 close GPERF;
 444 
 445 open HEADER, &quot;&gt;CSSPropertyNames.h&quot; || die &quot;Could not open CSSPropertyNames.h for writing&quot;;
 446 print HEADER &lt;&lt; &quot;EOF&quot;;
 447 /* This file is automatically generated from $inputFile by makeprop, do not edit */
 448 
 449 #pragma once
 450 
 451 #include &lt;string.h&gt;
 452 #include &lt;wtf/Forward.h&gt;
 453 #include &lt;wtf/HashFunctions.h&gt;
 454 #include &lt;wtf/HashTraits.h&gt;
 455 
 456 namespace WebCore {
 457 
 458 enum CSSPropertyID : uint16_t {
 459     CSSPropertyInvalid = 0,
 460     CSSPropertyCustom = 1,
 461 EOF
 462 
 463 my $first = $numPredefinedProperties;
 464 my $i = $numPredefinedProperties;
 465 my $maxLen = 0;
 466 my $lastHighPriorityPropertyName;
 467 foreach my $name (@names) {
 468   $lastHighPriorityPropertyName = $name if $nameIsHighPriority{$name}; # Assumes that @names is sorted by descending priorities.
 469   print HEADER &quot;    CSSProperty&quot; . $nameToId{$name} . &quot; = &quot; . $i . &quot;,\n&quot;;
 470   $i = $i + 1;
 471   if (length($name) &gt; $maxLen) {
 472     $maxLen = length($name);
 473   }
 474 }
 475 my $num = $i - $first;
 476 my $last = $i - 1;
 477 
 478 print HEADER &quot;};\n\n&quot;;
 479 print HEADER &quot;const int firstCSSProperty = $first;\n&quot;;
 480 print HEADER &quot;const int numCSSProperties = $num;\n&quot;;
 481 print HEADER &quot;const int lastCSSProperty = $last;\n&quot;;
 482 print HEADER &quot;const size_t maxCSSPropertyNameLength = $maxLen;\n&quot;;
 483 print HEADER &quot;const CSSPropertyID lastHighPriorityProperty = CSSProperty&quot; . $nameToId{$lastHighPriorityPropertyName} . &quot;;\n&quot;;
 484 
 485 print HEADER &lt;&lt; &quot;EOF&quot;;
 486 
 487 bool isInternalCSSProperty(const CSSPropertyID);
 488 bool isEnabledCSSProperty(const CSSPropertyID);
 489 const char* getPropertyName(CSSPropertyID);
 490 const WTF::AtomicString&amp; getPropertyNameAtomicString(CSSPropertyID id);
 491 WTF::String getPropertyNameString(CSSPropertyID id);
 492 WTF::String getJSPropertyName(CSSPropertyID);
 493 
 494 inline CSSPropertyID convertToCSSPropertyID(int value)
 495 {
 496     ASSERT((value &gt;= firstCSSProperty &amp;&amp; value &lt;= lastCSSProperty) || value == CSSPropertyInvalid || value == CSSPropertyCustom);
 497     return static_cast&lt;CSSPropertyID&gt;(value);
 498 }
 499 
 500 } // namespace WebCore
 501 
 502 namespace WTF {
 503 template&lt;&gt; struct DefaultHash&lt;WebCore::CSSPropertyID&gt; { typedef IntHash&lt;unsigned&gt; Hash; };
 504 template&lt;&gt; struct HashTraits&lt;WebCore::CSSPropertyID&gt; : GenericHashTraits&lt;WebCore::CSSPropertyID&gt; {
 505     static const bool emptyValueIsZero = true;
 506     static void constructDeletedValue(WebCore::CSSPropertyID&amp; slot) { slot = static_cast&lt;WebCore::CSSPropertyID&gt;(WebCore::lastCSSProperty + 1); }
 507     static bool isDeletedValue(WebCore::CSSPropertyID value) { return value == (WebCore::lastCSSProperty + 1); }
 508 };
 509 } // namespace WTF
 510 
 511 EOF
 512 
 513 close HEADER;
 514 
 515 #
 516 # StyleBuilder.cpp generator.
 517 #
 518 
 519 sub getScopeForFunction {
 520   my $name = shift;
 521   my $builderFunction = shift;
 522 
 523   return $propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;}{$builderFunction} ? &quot;StyleBuilderCustom&quot; : &quot;StyleBuilderFunctions&quot;;
 524 }
 525 
 526 sub getNameForMethods {
 527   my $name = shift;
 528 
 529   my $nameForMethods = $nameToId{$name};
 530   $nameForMethods =~ s/Webkit//g;
 531   if (exists($propertiesWithStyleBuilderOptions{$name}{&quot;name-for-methods&quot;})) {
 532     $nameForMethods = $propertiesWithStyleBuilderOptions{$name}{&quot;name-for-methods&quot;};
 533   }
 534   return $nameForMethods;
 535 }
 536 
 537 sub getAutoGetter {
 538   my $name = shift;
 539   my $renderStyle = shift;
 540 
 541   return $renderStyle . &quot;-&gt;hasAuto&quot; . getNameForMethods($name) . &quot;()&quot;;
 542 }
 543 
 544 sub getAutoSetter {
 545   my $name = shift;
 546   my $renderStyle = shift;
 547 
 548   return $renderStyle . &quot;-&gt;setHasAuto&quot; . getNameForMethods($name) . &quot;()&quot;;
 549 }
 550 
 551 sub getVisitedLinkSetter {
 552   my $name = shift;
 553   my $renderStyle = shift;
 554 
 555   return $renderStyle . &quot;-&gt;setVisitedLink&quot; . getNameForMethods($name);
 556 }
 557 
 558 sub getClearFunction {
 559   my $name = shift;
 560 
 561   return &quot;clear&quot; . getNameForMethods($name);
 562 }
 563 
 564 sub getEnsureAnimationsOrTransitionsMethod {
 565   my $name = shift;
 566 
 567   return &quot;ensureAnimations&quot; if $name =~ /animation-/;
 568   return &quot;ensureTransitions&quot; if $name =~ /transition-/;
 569   die &quot;Unrecognized animation property name.&quot;;
 570 }
 571 
 572 sub getAnimationsOrTransitionsMethod {
 573   my $name = shift;
 574 
 575   return &quot;animations&quot; if $name =~ /animation-/;
 576   return &quot;transitions&quot; if $name =~ /transition-/;
 577   die &quot;Unrecognized animation property name.&quot;;
 578 }
 579 
 580 sub getTestFunction {
 581   my $name = shift;
 582 
 583   return &quot;is&quot; . getNameForMethods($name) . &quot;Set&quot;;
 584 }
 585 
 586 sub getAnimationMapfunction {
 587   my $name = shift;
 588 
 589   return &quot;mapAnimation&quot; . getNameForMethods($name);
 590 }
 591 
 592 sub getLayersFunction {
 593   my $name = shift;
 594 
 595   return &quot;backgroundLayers&quot; if $name =~ /background-/;
 596   return &quot;maskLayers&quot; if $name =~ /mask-/;
 597   die &quot;Unrecognized FillLayer property name.&quot;;
 598 }
 599 
 600 sub getLayersAccessorFunction {
 601   my $name = shift;
 602 
 603   return &quot;ensureBackgroundLayers&quot; if $name =~ /background-/;
 604   return &quot;ensureMaskLayers&quot; if $name =~ /mask-/;
 605   die &quot;Unrecognized FillLayer property name.&quot;;
 606 }
 607 
 608 sub getFillLayerType {
 609 my $name = shift;
 610 
 611   return &quot;FillLayerType::Background&quot; if $name =~ /background-/;
 612   return &quot;FillLayerType::Mask&quot; if $name =~ /mask-/;
 613 }
 614 
 615 sub getFillLayerMapfunction {
 616   my $name = shift;
 617 
 618   return &quot;mapFill&quot; . getNameForMethods($name);
 619 }
 620 
 621 
 622 foreach my $name (@names) {
 623   my $nameForMethods = getNameForMethods($name);
 624   $nameForMethods =~ s/Webkit//g;
 625   if (exists($propertiesWithStyleBuilderOptions{$name}{&quot;name-for-methods&quot;})) {
 626     $nameForMethods = $propertiesWithStyleBuilderOptions{$name}{&quot;name-for-methods&quot;};
 627   }
 628 
 629   if (!exists($propertiesWithStyleBuilderOptions{$name}{&quot;getter&quot;})) {
 630     $propertiesWithStyleBuilderOptions{$name}{&quot;getter&quot;} = lcfirst($nameForMethods);
 631   }
 632   if (!exists($propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;})) {
 633     $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;} = &quot;set&quot; . $nameForMethods;
 634   }
 635   if (!exists($propertiesWithStyleBuilderOptions{$name}{&quot;initial&quot;})) {
 636     if (exists($propertiesWithStyleBuilderOptions{$name}{&quot;fill-layer-property&quot;})) {
 637       $propertiesWithStyleBuilderOptions{$name}{&quot;initial&quot;} = &quot;initialFill&quot; . $nameForMethods;
 638     } else {
 639       $propertiesWithStyleBuilderOptions{$name}{&quot;initial&quot;} = &quot;initial&quot; . $nameForMethods;
 640     }
 641   }
 642   # FIXME: Convert option custom from a string to an array.
 643   if (!exists($propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;})) {
 644     $propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;} = &quot;&quot;;
 645   } elsif ($propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;} eq &quot;All&quot;) {
 646     $propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;} = &quot;Initial|Inherit|Value&quot;;
 647   }
 648   my %customValues = map { $_ =&gt; 1 } split(/\|/, $propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;});
 649   $propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;} = \%customValues;
 650 }
 651 
 652 use constant {
 653   NOT_FOR_VISITED_LINK =&gt; 0,
 654   FOR_VISITED_LINK =&gt; 1,
 655 };
 656 
 657 sub colorFromPrimitiveValue {
 658   my $primitiveValue = shift;
 659   my $forVisitedLink = @_ ? shift : NOT_FOR_VISITED_LINK;
 660 
 661   return &quot;styleResolver.colorFromPrimitiveValue(&quot; . $primitiveValue . &quot;, /* forVisitedLink */ &quot; . ($forVisitedLink ? &quot;true&quot; : &quot;false&quot;) . &quot;)&quot;;
 662 }
 663 
 664 use constant {
 665   VALUE_IS_COLOR =&gt; 0,
 666   VALUE_IS_PRIMITIVE =&gt; 1,
 667 };
 668 
 669 sub generateColorValueSetter {
 670   my $name = shift;
 671   my $value = shift;
 672   my $indent = shift;
 673   my $valueIsPrimitive = @_ ? shift : VALUE_IS_COLOR;
 674 
 675   my $style = &quot;styleResolver.style()&quot;;
 676   my $setterContent .= $indent . &quot;if (styleResolver.applyPropertyToRegularStyle())\n&quot;;
 677   my $setValue = $style . &quot;-&gt;&quot; . $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 678   my $color = $valueIsPrimitive ? colorFromPrimitiveValue($value) : $value;
 679   $setterContent .= $indent . &quot;    &quot; . $setValue . &quot;(&quot; . $color . &quot;);\n&quot;;
 680   $setterContent .= $indent . &quot;if (styleResolver.applyPropertyToVisitedLinkStyle())\n&quot;;
 681   $color = $valueIsPrimitive ? colorFromPrimitiveValue($value, FOR_VISITED_LINK) : $value;
 682   $setterContent .= $indent . &quot;    &quot; . getVisitedLinkSetter($name, $style) . &quot;(&quot; . $color . &quot;);\n&quot;;
 683 
 684   return $setterContent;
 685 }
 686 
 687 sub handleCurrentColorValue {
 688   my $name = shift;
 689   my $primitiveValue = shift;
 690   my $indent = shift;
 691 
 692   my $code = $indent . &quot;if (&quot; . $primitiveValue . &quot;.valueID() == CSSValueCurrentcolor) {\n&quot;;
 693   $code .= $indent . &quot;    applyInherit&quot; . $nameToId{$name} . &quot;(styleResolver);\n&quot;;
 694   $code .= $indent . &quot;    return;\n&quot;;
 695   $code .= $indent . &quot;}\n&quot;;
 696   return $code;
 697 }
 698 
 699 sub generateAnimationPropertyInitialValueSetter {
 700   my $name = shift;
 701   my $indent = shift;
 702 
 703   my $setterContent = &quot;&quot;;
 704   $setterContent .= $indent . &quot;AnimationList&amp; list = styleResolver.style()-&gt;&quot; . getEnsureAnimationsOrTransitionsMethod($name) . &quot;();\n&quot;;
 705   $setterContent .= $indent . &quot;if (list.isEmpty())\n&quot;;
 706   $setterContent .= $indent . &quot;    list.append(Animation::create());\n&quot;;
 707   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 708   my $initial = $propertiesWithStyleBuilderOptions{$name}{&quot;initial&quot;};
 709   $setterContent .= $indent . &quot;list.animation(0).&quot; . $setter . &quot;(Animation::&quot; . $initial . &quot;());\n&quot;;
 710   if ($name eq &quot;-webkit-transition-property&quot;) {
 711     $setterContent .= $indent . &quot;list.animation(0).setAnimationMode(Animation::AnimateAll);\n&quot;;
 712   }
 713   $setterContent .= $indent . &quot;for (size_t i = 1; i &lt; list.size(); ++i)\n&quot;;
 714   $setterContent .= $indent . &quot;    list.animation(i).&quot; . getClearFunction($name) . &quot;();\n&quot;;
 715 
 716   return $setterContent;
 717 }
 718 
 719 sub generateAnimationPropertyInheritValueSetter {
 720   my $name = shift;
 721   my $indent = shift;
 722 
 723   my $setterContent = &quot;&quot;;
 724   $setterContent .= $indent . &quot;auto&amp; list = styleResolver.style()-&gt;&quot; . getEnsureAnimationsOrTransitionsMethod($name) . &quot;();\n&quot;;
 725   $setterContent .= $indent . &quot;auto* parentList = styleResolver.parentStyle()-&gt;&quot; . getAnimationsOrTransitionsMethod($name) . &quot;();\n&quot;;
 726   $setterContent .= $indent . &quot;size_t i = 0, parentSize = parentList ? parentList-&gt;size() : 0;\n&quot;;
 727   $setterContent .= $indent . &quot;for ( ; i &lt; parentSize &amp;&amp; parentList-&gt;animation(i).&quot; . getTestFunction($name) . &quot;(); ++i) {\n&quot;;
 728   $setterContent .= $indent . &quot;    if (list.size() &lt;= i)\n&quot;;
 729   $setterContent .= $indent . &quot;        list.append(Animation::create());\n&quot;;
 730   my $getter = $propertiesWithStyleBuilderOptions{$name}{&quot;getter&quot;};
 731   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 732   $setterContent .= $indent . &quot;    list.animation(i).&quot; . $setter . &quot;(parentList-&gt;animation(i).&quot; . $getter . &quot;());\n&quot;;
 733   $setterContent .= $indent . &quot;    list.animation(i).setAnimationMode(parentList-&gt;animation(i).animationMode());\n&quot;;
 734   $setterContent .= $indent . &quot;}\n&quot;;
 735   $setterContent .= &quot;\n&quot;;
 736   $setterContent .= $indent . &quot;// Reset any remaining animations to not have the property set.\n&quot;;
 737   $setterContent .= $indent . &quot;for ( ; i &lt; list.size(); ++i)\n&quot;;
 738   $setterContent .= $indent . &quot;    list.animation(i).&quot; . getClearFunction($name) . &quot;();\n&quot;;
 739 
 740   return $setterContent;
 741 }
 742 
 743 sub generateAnimationPropertyValueSetter {
 744   my $name = shift;
 745   my $indent = shift;
 746 
 747   my $setterContent = &quot;&quot;;
 748   $setterContent .= $indent . &quot;AnimationList&amp; list = styleResolver.style()-&gt;&quot; . getEnsureAnimationsOrTransitionsMethod($name) . &quot;();\n&quot;;
 749   $setterContent .= $indent . &quot;size_t childIndex = 0;\n&quot;;
 750   $setterContent .= $indent . &quot;if (is&lt;CSSValueList&gt;(value)) {\n&quot;;
 751   $setterContent .= $indent . &quot;    /* Walk each value and put it into an animation, creating new animations as needed. */\n&quot;;
 752   $setterContent .= $indent . &quot;    for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {\n&quot;;
 753   $setterContent .= $indent . &quot;        if (childIndex &lt;= list.size())\n&quot;;
 754   $setterContent .= $indent . &quot;            list.append(Animation::create());\n&quot;;
 755   $setterContent .= $indent . &quot;        styleResolver.styleMap()-&gt;&quot; . getAnimationMapfunction($name) . &quot;(list.animation(childIndex), currentValue);\n&quot;;
 756   $setterContent .= $indent . &quot;        ++childIndex;\n&quot;;
 757   $setterContent .= $indent . &quot;    }\n&quot;;
 758   $setterContent .= $indent . &quot;} else {\n&quot;;
 759   $setterContent .= $indent . &quot;    if (list.isEmpty())\n&quot;;
 760   $setterContent .= $indent . &quot;        list.append(Animation::create());\n&quot;;
 761   $setterContent .= $indent . &quot;    styleResolver.styleMap()-&gt;&quot; . getAnimationMapfunction($name) . &quot;(list.animation(childIndex), value);\n&quot;;
 762   $setterContent .= $indent . &quot;    childIndex = 1;\n&quot;;
 763   $setterContent .= $indent . &quot;}\n&quot;;
 764   $setterContent .= $indent . &quot;for ( ; childIndex &lt; list.size(); ++childIndex) {\n&quot;;
 765   $setterContent .= $indent . &quot;    /* Reset all remaining animations to not have the property set. */\n&quot;;
 766   $setterContent .= $indent . &quot;    list.animation(childIndex).&quot; . getClearFunction($name) . &quot;();\n&quot;;
 767   $setterContent .= $indent . &quot;}\n&quot;;
 768 
 769   return $setterContent;
 770 }
 771 
 772 sub generateFillLayerPropertyInitialValueSetter {
 773   my $name = shift;
 774   my $indent = shift;
 775 
 776   my $getter = $propertiesWithStyleBuilderOptions{$name}{&quot;getter&quot;};
 777   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 778   my $clearFunction = getClearFunction($name);
 779   my $testFunction = getTestFunction($name);
 780   my $initial = &quot;FillLayer::&quot; . $propertiesWithStyleBuilderOptions{$name}{&quot;initial&quot;} . &quot;(&quot; . getFillLayerType($name) . &quot;)&quot;;
 781 
 782   my $setterContent = &quot;&quot;;
 783   $setterContent .= $indent . &quot;// Check for (single-layer) no-op before clearing anything.\n&quot;;
 784   $setterContent .= $indent . &quot;auto&amp; layers = styleResolver.style()-&gt;&quot; . getLayersFunction($name) . &quot;();\n&quot;;
 785   $setterContent .= $indent . &quot;if (!layers.next() &amp;&amp; (!layers.&quot; . $testFunction . &quot;() || layers.&quot; . $getter . &quot;() == $initial))\n&quot;;
 786   $setterContent .= $indent . &quot;    return;\n&quot;;
 787   $setterContent .= &quot;\n&quot;;
 788   $setterContent .= $indent . &quot;auto* child = &amp;styleResolver.style()-&gt;&quot; . getLayersAccessorFunction($name) . &quot;();\n&quot;;
 789   $setterContent .= $indent . &quot;child-&gt;&quot; . $setter . &quot;(&quot; . $initial . &quot;);\n&quot;;
 790   $setterContent .= $indent . &quot;for (child = child-&gt;next(); child; child = child-&gt;next())\n&quot;;
 791   $setterContent .= $indent . &quot;    child-&gt;&quot; . $clearFunction . &quot;();\n&quot;;
 792 
 793   return $setterContent;
 794 }
 795 
 796 sub generateFillLayerPropertyInheritValueSetter {
 797   my $name = shift;
 798   my $indent = shift;
 799 
 800   my $getter = $propertiesWithStyleBuilderOptions{$name}{&quot;getter&quot;};
 801   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 802   my $clearFunction = getClearFunction($name);
 803   my $testFunction = getTestFunction($name);
 804 
 805   my $setterContent = &quot;&quot;;
 806   $setterContent .= $indent . &quot;// Check for no-op before copying anything.\n&quot;;
 807   $setterContent .= $indent . &quot;if (styleResolver.parentStyle()-&gt;&quot; . getLayersFunction($name) .&quot;() == styleResolver.style()-&gt;&quot; . getLayersFunction($name) . &quot;())\n&quot;;
 808   $setterContent .= $indent . &quot;    return;\n&quot;;
 809   $setterContent .= &quot;\n&quot;;
 810   $setterContent .= $indent . &quot;auto* child = &amp;styleResolver.style()-&gt;&quot; . getLayersAccessorFunction($name) . &quot;();\n&quot;;
 811   $setterContent .= $indent . &quot;FillLayer* previousChild = nullptr;\n&quot;;
 812   $setterContent .= $indent . &quot;for (auto* parent = &amp;styleResolver.parentStyle()-&gt;&quot; . getLayersFunction($name) . &quot;(); parent &amp;&amp; parent-&gt;&quot; . $testFunction . &quot;(); parent = parent-&gt;next()) {\n&quot;;
 813   $setterContent .= $indent . &quot;    if (!child) {\n&quot;;
 814   $setterContent .= $indent . &quot;        previousChild-&gt;setNext(std::make_unique&lt;FillLayer&gt;(&quot; . getFillLayerType($name) . &quot;));\n&quot;;
 815   $setterContent .= $indent . &quot;        child = previousChild-&gt;next();\n&quot;;
 816   $setterContent .= $indent . &quot;    }\n&quot;;
 817   $setterContent .= $indent . &quot;    child-&gt;&quot; . $setter . &quot;(parent-&gt;&quot; . $getter . &quot;());\n&quot;;
 818   $setterContent .= $indent . &quot;    previousChild = child;\n&quot;;
 819   $setterContent .= $indent . &quot;    child = previousChild-&gt;next();\n&quot;;
 820   $setterContent .= $indent . &quot;}\n&quot;;
 821   $setterContent .= $indent . &quot;for (; child; child = child-&gt;next())\n&quot;;
 822   $setterContent .= $indent . &quot;    child-&gt;&quot; . $clearFunction . &quot;();\n&quot;;
 823 
 824   return $setterContent;
 825 }
 826 
 827 sub generateFillLayerPropertyValueSetter {
 828   my $name = shift;
 829   my $indent = shift;
 830 
 831   my $CSSPropertyId = &quot;CSSProperty&quot; . $nameToId{$name};
 832 
 833   my $setterContent = &quot;&quot;;
 834   $setterContent .= $indent . &quot;auto* child = &amp;styleResolver.style()-&gt;&quot; . getLayersAccessorFunction($name) . &quot;();\n&quot;;
 835   $setterContent .= $indent . &quot;FillLayer* previousChild = nullptr;\n&quot;;
 836   $setterContent .= $indent . &quot;if (is&lt;CSSValueList&gt;(value) &amp;&amp; !is&lt;CSSImageSetValue&gt;(value)) {\n&quot;;
 837   $setterContent .= $indent . &quot;    // Walk each value and put it into a layer, creating new layers as needed.\n&quot;;
 838   $setterContent .= $indent . &quot;    for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {\n&quot;;
 839   $setterContent .= $indent . &quot;        if (!child) {\n&quot;;
 840   $setterContent .= $indent . &quot;            previousChild-&gt;setNext(std::make_unique&lt;FillLayer&gt;(&quot; . getFillLayerType($name) . &quot;));\n&quot;;
 841   $setterContent .= $indent . &quot;            child = previousChild-&gt;next();\n&quot;;
 842   $setterContent .= $indent . &quot;        }\n&quot;;
 843   $setterContent .= $indent . &quot;        styleResolver.styleMap()-&gt;&quot; . getFillLayerMapfunction($name) . &quot;(&quot; . $CSSPropertyId . &quot;, *child, item);\n&quot;;
 844   $setterContent .= $indent . &quot;        previousChild = child;\n&quot;;
 845   $setterContent .= $indent . &quot;        child = child-&gt;next();\n&quot;;
 846   $setterContent .= $indent . &quot;    }\n&quot;;
 847   $setterContent .= $indent . &quot;} else {\n&quot;;
 848   $setterContent .= $indent . &quot;    styleResolver.styleMap()-&gt;&quot; . getFillLayerMapfunction($name) . &quot;(&quot; . $CSSPropertyId . &quot;, *child, value);\n&quot;;
 849   $setterContent .= $indent . &quot;    child = child-&gt;next();\n&quot;;
 850   $setterContent .= $indent . &quot;}\n&quot;;
 851   $setterContent .= $indent . &quot;for (; child; child = child-&gt;next())\n&quot;;
 852   $setterContent .= $indent . &quot;    child-&gt;&quot; . getClearFunction($name) . &quot;();\n&quot;;
 853 
 854   return $setterContent;
 855 }
 856 
 857 sub generateSetValueStatement
 858 {
 859   my $name = shift;
 860   my $value = shift;
 861 
 862   my $isSVG = exists $propertiesWithStyleBuilderOptions{$name}{&quot;svg&quot;};
 863   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 864   return &quot;styleResolver.style()-&gt;&quot; .  ($isSVG ? &quot;accessSVGStyle().&quot; : &quot;&quot;) . $setter . &quot;(&quot; . $value . &quot;)&quot;;
 865 }
 866 
 867 sub generateInitialValueSetter {
 868   my $name = shift;
 869   my $indent = shift;
 870 
 871   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 872   my $initial = $propertiesWithStyleBuilderOptions{$name}{&quot;initial&quot;};
 873   my $isSVG = exists $propertiesWithStyleBuilderOptions{$name}{&quot;svg&quot;};
 874   my $setterContent = &quot;&quot;;
 875   $setterContent .= $indent . &quot;static void applyInitial&quot; . $nameToId{$name} . &quot;(StyleResolver&amp; styleResolver)\n&quot;;
 876   $setterContent .= $indent . &quot;{\n&quot;;
 877   my $style = &quot;styleResolver.style()&quot;;
 878   if (exists $propertiesWithStyleBuilderOptions{$name}{&quot;auto-functions&quot;}) {
 879     $setterContent .= $indent . &quot;    &quot; . getAutoSetter($name, $style) . &quot;;\n&quot;;
 880   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;visited-link-color-support&quot;}) {
 881       my $initialColor = &quot;RenderStyle::&quot; . $initial . &quot;()&quot;;
 882       $setterContent .= generateColorValueSetter($name, $initialColor, $indent . &quot;    &quot;);
 883   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;animatable&quot;}) {
 884     $setterContent .= generateAnimationPropertyInitialValueSetter($name, $indent . &quot;    &quot;);
 885   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;font-property&quot;}) {
 886     $setterContent .= $indent . &quot;    auto fontDescription = styleResolver.fontDescription();\n&quot;;
 887     $setterContent .= $indent . &quot;    fontDescription.&quot; . $setter . &quot;(FontCascadeDescription::&quot; . $initial . &quot;());\n&quot;;
 888     $setterContent .= $indent . &quot;    styleResolver.setFontDescription(WTFMove(fontDescription));\n&quot;;
 889   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;fill-layer-property&quot;}) {
 890     $setterContent .= generateFillLayerPropertyInitialValueSetter($name, $indent . &quot;    &quot;);
 891   } else {
 892     my $initialValue = ($isSVG ? &quot;SVGRenderStyle&quot; : &quot;RenderStyle&quot;) . &quot;::&quot; . $initial . &quot;()&quot;;
 893     $setterContent .= $indent . &quot;    &quot; . generateSetValueStatement($name, $initialValue) . &quot;;\n&quot;;
 894   }
 895   $setterContent .= $indent . &quot;}\n&quot;;
 896 
 897   return $setterContent;
 898 }
 899 
 900 sub generateInheritValueSetter {
 901   my $name = shift;
 902   my $indent = shift;
 903 
 904   my $setterContent = &quot;&quot;;
 905   $setterContent .= $indent . &quot;static void applyInherit&quot; . $nameToId{$name} . &quot;(StyleResolver&amp; styleResolver)\n&quot;;
 906   $setterContent .= $indent . &quot;{\n&quot;;
 907   my $isSVG = exists $propertiesWithStyleBuilderOptions{$name}{&quot;svg&quot;};
 908   my $parentStyle = &quot;styleResolver.parentStyle()&quot;;
 909   my $style = &quot;styleResolver.style()&quot;;
 910   my $getter = $propertiesWithStyleBuilderOptions{$name}{&quot;getter&quot;};
 911   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 912   my $didCallSetValue = 0;
 913   if (exists $propertiesWithStyleBuilderOptions{$name}{&quot;auto-functions&quot;}) {
 914     $setterContent .= $indent . &quot;    if (&quot; . getAutoGetter($name, $parentStyle) . &quot;) {\n&quot;;
 915     $setterContent .= $indent . &quot;        &quot; . getAutoSetter($name, $style) . &quot;;\n&quot;;
 916     $setterContent .= $indent . &quot;        return;\n&quot;;
 917     $setterContent .= $indent . &quot;    }\n&quot;;
 918   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;visited-link-color-support&quot;}) {
 919     $setterContent .= $indent . &quot;    Color color = &quot; . $parentStyle . &quot;-&gt;&quot; . $getter . &quot;();\n&quot;;
 920     if (!exists($propertiesWithStyleBuilderOptions{$name}{&quot;no-default-color&quot;})) {
 921       $setterContent .= $indent . &quot;    if (!color.isValid())\n&quot;;
 922       $setterContent .= $indent . &quot;        color = &quot; . $parentStyle . &quot;-&gt;color();\n&quot;;
 923     }
 924     $setterContent .= generateColorValueSetter($name, &quot;color&quot;, $indent . &quot;    &quot;);
 925     $didCallSetValue = 1;
 926   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;animatable&quot;}) {
 927     $setterContent .= generateAnimationPropertyInheritValueSetter($name, $indent . &quot;    &quot;);
 928     $didCallSetValue = 1;
 929   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;font-property&quot;}) {
 930     $setterContent .= $indent . &quot;    auto fontDescription = styleResolver.fontDescription();\n&quot;;
 931     $setterContent .= $indent . &quot;    fontDescription.&quot; . $setter . &quot;(styleResolver.parentFontDescription().&quot; . $getter . &quot;());\n&quot;;
 932     $setterContent .= $indent . &quot;    styleResolver.setFontDescription(WTFMove(fontDescription));\n&quot;;
 933     $didCallSetValue = 1;
 934   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;fill-layer-property&quot;}) {
 935     $setterContent .= generateFillLayerPropertyInheritValueSetter($name, $indent . &quot;    &quot;);
 936     $didCallSetValue = 1;
 937   }
 938   if (!$didCallSetValue) {
 939     my $inheritedValue = $parentStyle . &quot;-&gt;&quot; . ($isSVG ? &quot;svgStyle().&quot; : &quot;&quot;) .  $getter . &quot;()&quot;;
 940     $setterContent .= $indent . &quot;    &quot; . generateSetValueStatement($name, &quot;forwardInheritedValue(&quot; . $inheritedValue . &quot;)&quot;) . &quot;;\n&quot;;
 941   }
 942   $setterContent .= $indent . &quot;}\n&quot;;
 943 
 944   return $setterContent;
 945 }
 946 
 947 sub generateValueSetter {
 948   my $name = shift;
 949   my $indent = shift;
 950 
 951   my $setterContent = &quot;&quot;;
 952   $setterContent .= $indent . &quot;static void applyValue&quot; . $nameToId{$name} . &quot;(StyleResolver&amp; styleResolver, CSSValue&amp; value)\n&quot;;
 953   $setterContent .= $indent . &quot;{\n&quot;;
 954   my $convertedValue;
 955   if (exists($propertiesWithStyleBuilderOptions{$name}{&quot;converter&quot;})) {
 956     $convertedValue = &quot;StyleBuilderConverter::convert&quot; . $propertiesWithStyleBuilderOptions{$name}{&quot;converter&quot;} . &quot;(styleResolver, value)&quot;;
 957   } elsif (exists($propertiesWithStyleBuilderOptions{$name}{&quot;conditional-converter&quot;})) {
 958     $setterContent .= $indent . &quot;    auto convertedValue = StyleBuilderConverter::convert&quot; . $propertiesWithStyleBuilderOptions{$name}{&quot;conditional-converter&quot;} . &quot;(styleResolver, value);\n&quot;;
 959     $convertedValue = &quot;WTFMove(convertedValue.value())&quot;;
 960   } else {
 961     $convertedValue = &quot;downcast&lt;CSSPrimitiveValue&gt;(value)&quot;;
 962   }
 963 
 964   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 965   my $style = &quot;styleResolver.style()&quot;;
 966   my $didCallSetValue = 0;
 967   if (exists $propertiesWithStyleBuilderOptions{$name}{&quot;auto-functions&quot;}) {
 968     $setterContent .= $indent . &quot;    if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto) {\n&quot;;
 969     $setterContent .= $indent . &quot;        &quot;. getAutoSetter($name, $style) . &quot;;\n&quot;;
 970     $setterContent .= $indent . &quot;        return;\n&quot;;
 971     $setterContent .= $indent . &quot;    }\n&quot;;
 972   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;visited-link-color-support&quot;}) {
 973     $setterContent .= $indent . &quot;    auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);\n&quot;;
 974     if ($name eq &quot;color&quot;) {
 975       # The &quot;color&quot; property supports &quot;currentColor&quot; value. We should add a parameter.
 976       $setterContent .= handleCurrentColorValue($name, &quot;primitiveValue&quot;, $indent . &quot;    &quot;);
 977     }
 978     $setterContent .= generateColorValueSetter($name, &quot;primitiveValue&quot;, $indent . &quot;    &quot;, VALUE_IS_PRIMITIVE);
 979     $didCallSetValue = 1;
 980   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;animatable&quot;}) {
 981     $setterContent .= generateAnimationPropertyValueSetter($name, $indent . &quot;    &quot;);
 982     $didCallSetValue = 1;
 983   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;font-property&quot;}) {
 984     $setterContent .= $indent . &quot;    auto fontDescription = styleResolver.fontDescription();\n&quot;;
 985     $setterContent .= $indent . &quot;    fontDescription.&quot; . $setter . &quot;(&quot; . $convertedValue . &quot;);\n&quot;;
 986     $setterContent .= $indent . &quot;    styleResolver.setFontDescription(WTFMove(fontDescription));\n&quot;;
 987     $didCallSetValue = 1;
 988   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;fill-layer-property&quot;}) {
 989     $setterContent .= generateFillLayerPropertyValueSetter($name, $indent . &quot;    &quot;);
 990     $didCallSetValue = 1;
 991   }
 992   if (!$didCallSetValue) {
 993     if (exists($propertiesWithStyleBuilderOptions{$name}{&quot;conditional-converter&quot;})) {
 994       $setterContent .= $indent . &quot;    if (convertedValue)\n&quot;;
 995       $setterContent .= &quot;    &quot;;
 996     }
 997     $setterContent .= $indent . &quot;    &quot; . generateSetValueStatement($name, $convertedValue) . &quot;;\n&quot;;
 998   }
 999   $setterContent .= $indent . &quot;}\n&quot;;
1000 
1001   return $setterContent;
1002 }
1003 
1004 open STYLEBUILDER, &quot;&gt;StyleBuilder.cpp&quot; || die &quot;Could not open StyleBuilder.cpp for writing&quot;;
1005 print STYLEBUILDER &lt;&lt; &quot;EOF&quot;;
1006 /* This file is automatically generated from $inputFile by makeprop, do not edit */
1007 
1008 #include &quot;config.h&quot;
1009 #include &quot;StyleBuilder.h&quot;
1010 
1011 #include &quot;CSSPrimitiveValueMappings.h&quot;
1012 #include &quot;CSSProperty.h&quot;
1013 #include &quot;RenderStyle.h&quot;
1014 #include &quot;StyleBuilderConverter.h&quot;
1015 #include &quot;StyleBuilderCustom.h&quot;
1016 #include &quot;StylePropertyShorthand.h&quot;
1017 #include &quot;StyleResolver.h&quot;
1018 
1019 namespace WebCore {
1020 
1021 class StyleBuilderFunctions {
1022 public:
1023 EOF
1024 
1025 foreach my $name (@names) {
1026   # Skip Shorthand properties and properties that do not use the StyleBuilder.
1027   next if (exists $propertiesWithStyleBuilderOptions{$name}{&quot;longhands&quot;});
1028   next if (exists $propertiesWithStyleBuilderOptions{$name}{&quot;skip-builder&quot;});
1029 
1030   my $indent = &quot;    &quot;;
1031   if (!$propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;}{&quot;Initial&quot;}) {
1032     print STYLEBUILDER generateInitialValueSetter($name, $indent);
1033   }
1034   if (!$propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;}{&quot;Inherit&quot;}) {
1035     print STYLEBUILDER generateInheritValueSetter($name, $indent);
1036   }
1037   if (!$propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;}{&quot;Value&quot;}) {
1038     print STYLEBUILDER generateValueSetter($name, $indent);
1039   }
1040 }
1041 
1042 print STYLEBUILDER &lt;&lt; &quot;EOF&quot;;
1043 };
1044 
1045 void StyleBuilder::applyProperty(CSSPropertyID property, StyleResolver&amp; styleResolver, CSSValue&amp; value, bool isInitial, bool isInherit, const CSSRegisteredCustomProperty* registered)
1046 {
1047     switch (property) {
1048     case CSSPropertyInvalid:
1049         break;
1050     case CSSPropertyCustom: {
1051         auto&amp; customProperty = downcast&lt;CSSCustomPropertyValue&gt;(value);
1052         if (isInitial)
1053             StyleBuilderCustom::applyInitialCustomProperty(styleResolver, registered, customProperty.name());
1054         else if (isInherit)
1055             StyleBuilderCustom::applyInheritCustomProperty(styleResolver, registered, customProperty.name());
1056         else
1057             StyleBuilderCustom::applyValueCustomProperty(styleResolver, registered, customProperty);
1058         break;
1059     }
1060 EOF
1061 
1062 foreach my $name (@names) {
1063   print STYLEBUILDER &quot;    case CSSProperty&quot; . $nameToId{$name} . &quot;:\n&quot;;
1064   if (exists $propertiesWithStyleBuilderOptions{$name}{&quot;longhands&quot;}) {
1065     print STYLEBUILDER &quot;        ASSERT(isShorthandCSSProperty(property));\n&quot;;
1066     print STYLEBUILDER &quot;        ASSERT_NOT_REACHED();\n&quot;;
1067   } elsif (!exists $propertiesWithStyleBuilderOptions{$name}{&quot;skip-builder&quot;}) {
1068     print STYLEBUILDER &quot;        if (isInitial)\n&quot;;
1069     print STYLEBUILDER &quot;            &quot; . getScopeForFunction($name, &quot;Initial&quot;) . &quot;::applyInitial&quot; . $nameToId{$name} . &quot;(styleResolver);\n&quot;;
1070     print STYLEBUILDER &quot;        else if (isInherit)\n&quot;;
1071     print STYLEBUILDER &quot;            &quot; . getScopeForFunction($name, &quot;Inherit&quot;) . &quot;::applyInherit&quot; . $nameToId{$name} . &quot;(styleResolver);\n&quot;;
1072     print STYLEBUILDER &quot;        else\n&quot;;
1073     print STYLEBUILDER &quot;            &quot; . getScopeForFunction($name, &quot;Value&quot;) . &quot;::applyValue&quot; . $nameToId{$name} . &quot;(styleResolver, value);\n&quot;;
1074   }
1075   print STYLEBUILDER &quot;        break;\n&quot;;
1076 }
1077 
1078 print STYLEBUILDER &lt;&lt; &quot;EOF&quot;;
1079     };
1080 }
1081 
1082 } // namespace WebCore
1083 EOF
1084 
1085 close STYLEBUILDER;
1086 
1087 # Generate StylePropertyShorthandsFunctions.
1088 open SHORTHANDS_H, &quot;&gt;&quot;, &quot;StylePropertyShorthandFunctions.h&quot; or die &quot;Could not open StylePropertyShorthandFunctions.h for writing\n&quot;;
1089 print SHORTHANDS_H &lt;&lt; &quot;EOF&quot;;
1090 // This file is automatically generated from $inputFile by the makeprop.pl script. Do not edit it.
1091 
1092 #pragma once
1093 
1094 namespace WebCore {
1095 
1096 class StylePropertyShorthand;
1097 
1098 EOF
1099 
1100 foreach my $name (@names) {
1101   # Skip non-Shorthand properties.
1102   next if (!exists $propertiesWithStyleBuilderOptions{$name}{&quot;longhands&quot;});
1103 
1104   print SHORTHANDS_H &quot;StylePropertyShorthand &quot; . lcfirst($nameToId{$name}) . &quot;Shorthand();\n&quot;;
1105 }
1106 
1107 print SHORTHANDS_H &lt;&lt; &quot;EOF&quot;;
1108 
1109 } // namespace WebCore
1110 EOF
1111 
1112 close SHORTHANDS_H;
1113 
1114 open SHORTHANDS_CPP, &quot;&gt;&quot;, &quot;StylePropertyShorthandFunctions.cpp&quot; or die &quot;Could not open StylePropertyShorthandFunctions.cpp for writing\n&quot;;
1115 print SHORTHANDS_CPP &lt;&lt; &quot;EOF&quot;;
1116 // This file is automatically generated from $inputFile by the makeprop.pl script. Do not edit it.
1117 
1118 #include &quot;config.h&quot;
1119 #include &quot;StylePropertyShorthandFunctions.h&quot;
1120 
1121 #include &quot;StylePropertyShorthand.h&quot;
1122 
1123 namespace WebCore {
1124 
1125 EOF
1126 
1127 my %longhandToShorthands = ();
1128 
1129 foreach my $name (@names) {
1130   # Skip non-Shorthand properties.
1131   next if (!exists $propertiesWithStyleBuilderOptions{$name}{&quot;longhands&quot;});
1132 
1133   my $lowercaseId = lcfirst($nameToId{$name});
1134   my @longhands = @{$propertiesWithStyleBuilderOptions{$name}{&quot;longhands&quot;}};
1135 
1136   print SHORTHANDS_CPP &quot;StylePropertyShorthand &quot; . $lowercaseId . &quot;Shorthand()\n&quot;;
1137   print SHORTHANDS_CPP &quot;{\n&quot;;
1138   print SHORTHANDS_CPP &quot;    static const CSSPropertyID &quot; . $lowercaseId . &quot;Properties[] = {\n&quot;;
1139   foreach (@longhands) {
1140     if ($_ eq &quot;all&quot;) {
1141         foreach my $propname (@names) {
1142             next if (exists $propertiesWithStyleBuilderOptions{$propname}{&quot;longhands&quot;});
1143             next if ($propname eq &quot;direction&quot; || $propname eq &quot;unicode-bidi&quot;);
1144             die &quot;Unknown CSS property used in all shorthand: $propname&quot; if !exists($nameToId{$propname});
1145             push(@{$longhandToShorthands{$propname}}, $name);
1146             print SHORTHANDS_CPP &quot;        CSSProperty&quot; . $nameToId{$propname} . &quot;,\n&quot;;
1147         }
1148     } else {
1149         die &quot;Unknown CSS property used in longhands: $_&quot; if !exists($nameToId{$_});
1150         push(@{$longhandToShorthands{$_}}, $name);
1151         print SHORTHANDS_CPP &quot;        CSSProperty&quot; . $nameToId{$_} . &quot;,\n&quot;;
1152     }
1153   }
1154   print SHORTHANDS_CPP &quot;    };\n&quot;;
1155   print SHORTHANDS_CPP &quot;    return StylePropertyShorthand(CSSProperty&quot; . $nameToId{$name} . &quot;, &quot; . $lowercaseId . &quot;Properties);\n&quot;;
1156   print SHORTHANDS_CPP &quot;}\n\n&quot;;
1157 }
1158 
1159 print SHORTHANDS_CPP &lt;&lt; &quot;EOF&quot;;
1160 StylePropertyShorthand shorthandForProperty(CSSPropertyID propertyID)
1161 {
1162     switch (propertyID) {
1163 EOF
1164 
1165 foreach my $name (@names) {
1166   # Skip non-Shorthand properties.
1167   next if (!exists $propertiesWithStyleBuilderOptions{$name}{&quot;longhands&quot;});
1168 
1169   print SHORTHANDS_CPP &quot;    case CSSProperty&quot; . $nameToId{$name} . &quot;:\n&quot;;
1170   print SHORTHANDS_CPP &quot;        return &quot; . lcfirst($nameToId{$name}) . &quot;Shorthand();\n&quot;;
1171 }
1172 
1173 print SHORTHANDS_CPP &lt;&lt; &quot;EOF&quot;;
1174     default:
1175         return { };
1176     }
1177 }
1178 EOF
1179 
1180 print SHORTHANDS_CPP &lt;&lt; &quot;EOF&quot;;
1181 StylePropertyShorthandVector matchingShorthandsForLonghand(CSSPropertyID propertyID)
1182 {
1183     switch (propertyID) {
1184 EOF
1185 
1186 sub constructShorthandsVector {
1187   my $shorthands = shift;
1188 
1189   my $vector = &quot;StylePropertyShorthandVector{&quot;;
1190   foreach my $i (0 .. $#$shorthands) {
1191     $vector .= &quot;, &quot; unless $i == 0;
1192     $vector .= lcfirst($nameToId{$shorthands-&gt;[$i]}) . &quot;Shorthand()&quot;;
1193   }
1194   $vector .= &quot;}&quot;;
1195   return $vector;
1196 }
1197 
1198 my %vectorToLonghands = ();
1199 for my $longhand (sort keys %longhandToShorthands) {
1200   my @shorthands = sort(@{$longhandToShorthands{$longhand}});
1201   push(@{$vectorToLonghands{constructShorthandsVector(\@shorthands)}}, $longhand);
1202 }
1203 
1204 for my $vector (sort keys %vectorToLonghands) {
1205   foreach (@{$vectorToLonghands{$vector}}) {
1206     print SHORTHANDS_CPP &quot;    case CSSProperty&quot; . $nameToId{$_} . &quot;:\n&quot;;
1207   }
1208   print SHORTHANDS_CPP &quot;        return &quot; . $vector . &quot;;\n&quot;;
1209 }
1210 
1211 print SHORTHANDS_CPP &lt;&lt; &quot;EOF&quot;;
1212     default:
1213         return { };
1214     }
1215 }
1216 EOF
1217 
1218 print SHORTHANDS_CPP &lt;&lt; &quot;EOF&quot;;
1219 } // namespace WebCore
1220 EOF
1221 
1222 close SHORTHANDS_CPP;
1223 
1224 if (not $gperf) {
1225     $gperf = $ENV{GPERF} ? $ENV{GPERF} : &quot;gperf&quot;;
1226 }
1227 system(&quot;\&quot;$gperf\&quot; --key-positions=\&quot;*\&quot; -D -n -s 2 CSSPropertyNames.gperf --output-file=CSSPropertyNames.cpp&quot;) == 0 || die &quot;calling gperf failed: $?&quot;;
    </pre>
  </body>
</html>