<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLRenderingContext.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
 31 #include &quot;ANGLEInstancedArrays.h&quot;
 32 #include &quot;CachedImage.h&quot;
 33 #include &quot;EXTBlendMinMax.h&quot;
 34 #include &quot;EXTFragDepth.h&quot;
 35 #include &quot;EXTShaderTextureLOD.h&quot;
 36 #include &quot;EXTTextureFilterAnisotropic.h&quot;
 37 #include &quot;EXTsRGB.h&quot;
 38 #include &quot;Extensions3D.h&quot;
 39 #include &quot;HTMLCanvasElement.h&quot;
 40 #include &quot;HTMLImageElement.h&quot;
 41 #include &quot;HTMLVideoElement.h&quot;
 42 #include &quot;ImageData.h&quot;
 43 #include &quot;InspectorInstrumentation.h&quot;
 44 #include &quot;OESElementIndexUint.h&quot;
 45 #include &quot;OESStandardDerivatives.h&quot;
 46 #include &quot;OESTextureFloat.h&quot;
 47 #include &quot;OESTextureFloatLinear.h&quot;
 48 #include &quot;OESTextureHalfFloat.h&quot;
 49 #include &quot;OESTextureHalfFloatLinear.h&quot;
 50 #include &quot;OESVertexArrayObject.h&quot;
 51 #include &quot;RenderBox.h&quot;
 52 #include &quot;WebGLCompressedTextureASTC.h&quot;
 53 #include &quot;WebGLCompressedTextureATC.h&quot;
 54 #include &quot;WebGLCompressedTexturePVRTC.h&quot;
 55 #include &quot;WebGLCompressedTextureS3TC.h&quot;
 56 #include &quot;WebGLDebugRendererInfo.h&quot;
 57 #include &quot;WebGLDebugShaders.h&quot;
 58 #include &quot;WebGLDepthTexture.h&quot;
 59 #include &quot;WebGLDrawBuffers.h&quot;
 60 #include &quot;WebGLLoseContext.h&quot;
 61 #include &quot;WebGLVertexArrayObjectOES.h&quot;
 62 #include &lt;JavaScriptCore/GenericTypedArrayViewInlines.h&gt;
 63 #include &lt;JavaScriptCore/HeapInlines.h&gt;
 64 #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;
 65 #include &lt;JavaScriptCore/JSCellInlines.h&gt;
 66 #include &lt;JavaScriptCore/JSGenericTypedArrayViewInlines.h&gt;
 67 
 68 namespace WebCore {
 69 
 70 std::unique_ptr&lt;WebGLRenderingContext&gt; WebGLRenderingContext::create(CanvasBase&amp; canvas, GraphicsContext3DAttributes attributes)
 71 {
 72     auto renderingContext = std::unique_ptr&lt;WebGLRenderingContext&gt;(new WebGLRenderingContext(canvas, attributes));
 73 
 74     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
 75 
 76     return renderingContext;
 77 }
 78 
 79 std::unique_ptr&lt;WebGLRenderingContext&gt; WebGLRenderingContext::create(CanvasBase&amp; canvas, Ref&lt;GraphicsContext3D&gt;&amp;&amp; context, GraphicsContext3DAttributes attributes)
 80 {
 81     auto renderingContext = std::unique_ptr&lt;WebGLRenderingContext&gt;(new WebGLRenderingContext(canvas, WTFMove(context), attributes));
 82 
 83     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
 84 
 85     return renderingContext;
 86 }
 87 
 88 WebGLRenderingContext::WebGLRenderingContext(CanvasBase&amp; canvas, GraphicsContext3DAttributes attributes)
 89     : WebGLRenderingContextBase(canvas, attributes)
 90 {
 91 }
 92 
 93 WebGLRenderingContext::WebGLRenderingContext(CanvasBase&amp; canvas, Ref&lt;GraphicsContext3D&gt;&amp;&amp; context, GraphicsContext3DAttributes attributes)
 94     : WebGLRenderingContextBase(canvas, WTFMove(context), attributes)
 95 {
 96     initializeVertexArrayObjects();
 97 }
 98 
 99 void WebGLRenderingContext::initializeVertexArrayObjects()
100 {
101     m_defaultVertexArrayObject = WebGLVertexArrayObjectOES::create(*this, WebGLVertexArrayObjectOES::Type::Default);
102     addContextObject(*m_defaultVertexArrayObject);
103     m_boundVertexArrayObject = m_defaultVertexArrayObject;
104     if (!isGLES2Compliant())
105         initVertexAttrib0();
106 }
107 
108 WebGLExtension* WebGLRenderingContext::getExtension(const String&amp; name)
109 {
110     if (isContextLostOrPending())
111         return nullptr;
112 
113 #define ENABLE_IF_REQUESTED(type, variable, nameLiteral, canEnable) \
114     if (equalIgnoringASCIICase(name, nameLiteral)) { \
115         if (!variable) { \
116             variable = (canEnable) ? std::make_unique&lt;type&gt;(*this) : nullptr; \
117             if (variable != nullptr) \
118                 InspectorInstrumentation::didEnableExtension(*this, name); \
119         } \
120         return variable.get(); \
121     }
122 
123     ENABLE_IF_REQUESTED(EXTBlendMinMax, m_extBlendMinMax, &quot;EXT_blend_minmax&quot;, enableSupportedExtension(&quot;GL_EXT_blend_minmax&quot;_s));
124     ENABLE_IF_REQUESTED(EXTsRGB, m_extsRGB, &quot;EXT_sRGB&quot;, enableSupportedExtension(&quot;GL_EXT_sRGB&quot;_s));
125     ENABLE_IF_REQUESTED(EXTFragDepth, m_extFragDepth, &quot;EXT_frag_depth&quot;, enableSupportedExtension(&quot;GL_EXT_frag_depth&quot;_s));
126     if (equalIgnoringASCIICase(name, &quot;EXT_shader_texture_lod&quot;)) {
127         if (!m_extShaderTextureLOD) {
128             if (!(m_context-&gt;getExtensions().supports(&quot;GL_EXT_shader_texture_lod&quot;_s) || m_context-&gt;getExtensions().supports(&quot;GL_ARB_shader_texture_lod&quot;_s)))
129                 m_extShaderTextureLOD = nullptr;
130             else {
131                 m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_shader_texture_lod&quot;_s);
132                 m_extShaderTextureLOD = std::make_unique&lt;EXTShaderTextureLOD&gt;(*this);
133                 InspectorInstrumentation::didEnableExtension(*this, name);
134             }
135         }
136         return m_extShaderTextureLOD.get();
137     }
138     ENABLE_IF_REQUESTED(EXTTextureFilterAnisotropic, m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;, enableSupportedExtension(&quot;GL_EXT_texture_filter_anisotropic&quot;_s));
139     ENABLE_IF_REQUESTED(EXTTextureFilterAnisotropic, m_extTextureFilterAnisotropic, &quot;WEBKIT_EXT_texture_filter_anisotropic&quot;, enableSupportedExtension(&quot;GL_EXT_texture_filter_anisotropic&quot;_s));
140     ENABLE_IF_REQUESTED(OESStandardDerivatives, m_oesStandardDerivatives, &quot;OES_standard_derivatives&quot;, enableSupportedExtension(&quot;GL_OES_standard_derivatives&quot;_s));
141     ENABLE_IF_REQUESTED(OESTextureFloat, m_oesTextureFloat, &quot;OES_texture_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_float&quot;_s));
142     ENABLE_IF_REQUESTED(OESTextureFloatLinear, m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_float_linear&quot;_s));
143     ENABLE_IF_REQUESTED(OESTextureHalfFloat, m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float&quot;_s));
144     ENABLE_IF_REQUESTED(OESTextureHalfFloatLinear, m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float_linear&quot;_s));
145     ENABLE_IF_REQUESTED(OESVertexArrayObject, m_oesVertexArrayObject, &quot;OES_vertex_array_object&quot;, enableSupportedExtension(&quot;GL_OES_vertex_array_object&quot;_s));
146     ENABLE_IF_REQUESTED(OESElementIndexUint, m_oesElementIndexUint, &quot;OES_element_index_uint&quot;, enableSupportedExtension(&quot;GL_OES_element_index_uint&quot;_s));
147     ENABLE_IF_REQUESTED(WebGLLoseContext, m_webglLoseContext, &quot;WEBGL_lose_context&quot;, true);
148     ENABLE_IF_REQUESTED(WebGLCompressedTextureATC, m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;, WebGLCompressedTextureATC::supported(*this));
149     ENABLE_IF_REQUESTED(WebGLCompressedTexturePVRTC, m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;, WebGLCompressedTexturePVRTC::supported(*this));
150     ENABLE_IF_REQUESTED(WebGLCompressedTextureS3TC, m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;, WebGLCompressedTextureS3TC::supported(*this));
151     ENABLE_IF_REQUESTED(WebGLCompressedTextureASTC, m_webglCompressedTextureASTC, &quot;WEBGL_compressed_texture_astc&quot;, WebGLCompressedTextureASTC::supported(*this));
152     ENABLE_IF_REQUESTED(WebGLDepthTexture, m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;, WebGLDepthTexture::supported(*m_context));
153     if (equalIgnoringASCIICase(name, &quot;WEBGL_draw_buffers&quot;)) {
154         if (!m_webglDrawBuffers) {
155             if (!supportsDrawBuffers())
156                 m_webglDrawBuffers = nullptr;
157             else {
158                 m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_draw_buffers&quot;_s);
159                 m_webglDrawBuffers = std::make_unique&lt;WebGLDrawBuffers&gt;(*this);
160                 InspectorInstrumentation::didEnableExtension(*this, name);
161             }
162         }
163         return m_webglDrawBuffers.get();
164     }
165     if (equalIgnoringASCIICase(name, &quot;ANGLE_instanced_arrays&quot;)) {
166         if (!m_angleInstancedArrays) {
167             if (!ANGLEInstancedArrays::supported(*this))
168                 m_angleInstancedArrays = nullptr;
169             else {
170                 m_context-&gt;getExtensions().ensureEnabled(&quot;GL_ANGLE_instanced_arrays&quot;_s);
171                 m_angleInstancedArrays = std::make_unique&lt;ANGLEInstancedArrays&gt;(*this);
172                 InspectorInstrumentation::didEnableExtension(*this, name);
173             }
174         }
175         return m_angleInstancedArrays.get();
176     }
177     ENABLE_IF_REQUESTED(WebGLDebugRendererInfo, m_webglDebugRendererInfo, &quot;WEBGL_debug_renderer_info&quot;, true);
178     ENABLE_IF_REQUESTED(WebGLDebugShaders, m_webglDebugShaders, &quot;WEBGL_debug_shaders&quot;, m_context-&gt;getExtensions().supports(&quot;GL_ANGLE_translated_shader_source&quot;_s));
179     return nullptr;
180 }
181 
182 Optional&lt;Vector&lt;String&gt;&gt; WebGLRenderingContext::getSupportedExtensions()
183 {
184     if (isContextLost())
185         return WTF::nullopt;
186 
187     Vector&lt;String&gt; result;
188 
189     if (m_isPendingPolicyResolution)
190         return result;
191 
192     if (m_context-&gt;getExtensions().supports(&quot;GL_EXT_blend_minmax&quot;_s))
193         result.append(&quot;EXT_blend_minmax&quot;_s);
194     if (m_context-&gt;getExtensions().supports(&quot;GL_EXT_sRGB&quot;_s))
195         result.append(&quot;EXT_sRGB&quot;_s);
196     if (m_context-&gt;getExtensions().supports(&quot;GL_EXT_frag_depth&quot;_s))
197         result.append(&quot;EXT_frag_depth&quot;_s);
198     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_float&quot;_s))
199         result.append(&quot;OES_texture_float&quot;_s);
200     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_float_linear&quot;_s))
201         result.append(&quot;OES_texture_float_linear&quot;_s);
202     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_half_float&quot;_s))
203         result.append(&quot;OES_texture_half_float&quot;_s);
204     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_half_float_linear&quot;_s))
205         result.append(&quot;OES_texture_half_float_linear&quot;_s);
206     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_standard_derivatives&quot;_s))
207         result.append(&quot;OES_standard_derivatives&quot;_s);
208     if (m_context-&gt;getExtensions().supports(&quot;GL_EXT_shader_texture_lod&quot;_s) || m_context-&gt;getExtensions().supports(&quot;GL_ARB_shader_texture_lod&quot;_s))
209         result.append(&quot;EXT_shader_texture_lod&quot;_s);
210     if (m_context-&gt;getExtensions().supports(&quot;GL_EXT_texture_filter_anisotropic&quot;_s))
211         result.append(&quot;EXT_texture_filter_anisotropic&quot;_s);
212     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_vertex_array_object&quot;_s))
213         result.append(&quot;OES_vertex_array_object&quot;_s);
214     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_element_index_uint&quot;_s))
215         result.append(&quot;OES_element_index_uint&quot;_s);
216     result.append(&quot;WEBGL_lose_context&quot;_s);
217     if (WebGLCompressedTextureATC::supported(*this))
218         result.append(&quot;WEBKIT_WEBGL_compressed_texture_atc&quot;_s);
219     if (WebGLCompressedTexturePVRTC::supported(*this))
220         result.append(&quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;_s);
221     if (WebGLCompressedTextureS3TC::supported(*this))
222         result.append(&quot;WEBGL_compressed_texture_s3tc&quot;_s);
223     if (WebGLCompressedTextureASTC::supported(*this))
224         result.append(&quot;WEBGL_compressed_texture_astc&quot;_s);
225     if (WebGLDepthTexture::supported(*m_context))
226         result.append(&quot;WEBGL_depth_texture&quot;_s);
227     if (supportsDrawBuffers())
228         result.append(&quot;WEBGL_draw_buffers&quot;_s);
229     if (ANGLEInstancedArrays::supported(*this))
230         result.append(&quot;ANGLE_instanced_arrays&quot;_s);
231     if (m_context-&gt;getExtensions().supports(&quot;GL_ANGLE_translated_shader_source&quot;_s))
232         result.append(&quot;WEBGL_debug_shaders&quot;_s);
233     result.append(&quot;WEBGL_debug_renderer_info&quot;_s);
234 
235     return result;
236 }
237 
238 WebGLAny WebGLRenderingContext::getFramebufferAttachmentParameter(GC3Denum target, GC3Denum attachment, GC3Denum pname)
239 {
240     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;getFramebufferAttachmentParameter&quot;, target, attachment))
241         return nullptr;
242 
243     if (!m_framebufferBinding || !m_framebufferBinding-&gt;object()) {
244         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getFramebufferAttachmentParameter&quot;, &quot;no framebuffer bound&quot;);
245         return nullptr;
246     }
247 
248     auto object = makeRefPtr(m_framebufferBinding-&gt;getAttachmentObject(attachment));
249     if (!object) {
250         if (pname == GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)
251             return static_cast&lt;unsigned&gt;(GraphicsContext3D::NONE);
252         // OpenGL ES 2.0 specifies INVALID_ENUM in this case, while desktop GL
253         // specifies INVALID_OPERATION.
254         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name&quot;);
255         return nullptr;
256     }
257 
258     if (object-&gt;isTexture()) {
259         switch (pname) {
260         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
261             return static_cast&lt;unsigned&gt;(GraphicsContext3D::TEXTURE);
262         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
263             return makeRefPtr(reinterpret_cast&lt;WebGLTexture&amp;&gt;(*object));
264         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:
265         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:
266         case Extensions3D::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: {
267             GC3Dint value = 0;
268             m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
269             return value;
270         }
271         default:
272             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for texture attachment&quot;);
273             return nullptr;
274         }
275     } else {
276         ASSERT(object-&gt;isRenderbuffer());
277         switch (pname) {
278         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
279             return static_cast&lt;unsigned&gt;(GraphicsContext3D::RENDERBUFFER);
280         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
281             return makeRefPtr(reinterpret_cast&lt;WebGLRenderbuffer&amp;&gt;(*object));
282         case Extensions3D::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: {
283             if (!m_extsRGB) {
284                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for renderbuffer attachment&quot;);
285                 return nullptr;
286             }
287             RefPtr&lt;WebGLRenderbuffer&gt; renderBuffer = reinterpret_cast&lt;WebGLRenderbuffer*&gt;(object.get());
288             GC3Denum renderBufferFormat = renderBuffer-&gt;getInternalFormat();
289             ASSERT(renderBufferFormat != Extensions3D::SRGB_EXT &amp;&amp; renderBufferFormat != Extensions3D::SRGB_ALPHA_EXT);
290             if (renderBufferFormat == Extensions3D::SRGB8_ALPHA8_EXT)
291                 return static_cast&lt;unsigned&gt;(Extensions3D::SRGB_EXT);
292             return static_cast&lt;unsigned&gt;(GraphicsContext3D::LINEAR);
293         }
294         default:
295             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for renderbuffer attachment&quot;);
296             return nullptr;
297         }
298     }
299 }
300 
301 bool WebGLRenderingContext::validateFramebufferFuncParameters(const char* functionName, GC3Denum target, GC3Denum attachment)
302 {
303     if (target != GraphicsContext3D::FRAMEBUFFER) {
304         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid target&quot;);
305         return false;
306     }
307     // FIXME: Why does this return true unconditionally for COLOR_ATTACHMENT0,
308     // but false for other COLOR_ATTACHMENT values if m_webglDrawBuffers is false?
309     switch (attachment) {
310     case GraphicsContext3D::COLOR_ATTACHMENT0:
311     case GraphicsContext3D::DEPTH_ATTACHMENT:
312     case GraphicsContext3D::STENCIL_ATTACHMENT:
313     case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:
314         return true;
315     default:
316         if (m_webglDrawBuffers
317             &amp;&amp; attachment &gt;= GraphicsContext3D::COLOR_ATTACHMENT0
318             &amp;&amp; attachment &lt; static_cast&lt;GC3Denum&gt;(GraphicsContext3D::COLOR_ATTACHMENT0 + getMaxColorAttachments()))
319             return true;
320         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid attachment&quot;);
321         return false;
322     }
323 }
324 
325 void WebGLRenderingContext::renderbufferStorage(GC3Denum target, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height)
326 {
327     if (isContextLostOrPending())
328         return;
329     if (target != GraphicsContext3D::RENDERBUFFER) {
330         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid target&quot;);
331         return;
332     }
333     if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
334         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;renderbufferStorage&quot;, &quot;no bound renderbuffer&quot;);
335         return;
336     }
337     if (!validateSize(&quot;renderbufferStorage&quot;, width, height))
338         return;
339     switch (internalformat) {
340     case GraphicsContext3D::DEPTH_COMPONENT16:
341     case GraphicsContext3D::RGBA4:
342     case GraphicsContext3D::RGB5_A1:
343     case GraphicsContext3D::RGB565:
344     case GraphicsContext3D::STENCIL_INDEX8:
345     case Extensions3D::SRGB8_ALPHA8_EXT:
346         if (internalformat == Extensions3D::SRGB8_ALPHA8_EXT &amp;&amp; !m_extsRGB) {
347             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);
348             return;
349         }
350         m_context-&gt;renderbufferStorage(target, internalformat, width, height);
351         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
352         m_renderbufferBinding-&gt;setIsValid(true);
353         m_renderbufferBinding-&gt;setSize(width, height);
354         break;
355     case GraphicsContext3D::DEPTH_STENCIL:
356         if (isDepthStencilSupported())
357             m_context-&gt;renderbufferStorage(target, Extensions3D::DEPTH24_STENCIL8, width, height);
358         m_renderbufferBinding-&gt;setSize(width, height);
359         m_renderbufferBinding-&gt;setIsValid(isDepthStencilSupported());
360         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
361         break;
362     default:
363         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);
364         return;
365     }
366     applyStencilTest();
367 }
368 
369 void WebGLRenderingContext::hint(GC3Denum target, GC3Denum mode)
370 {
371     if (isContextLostOrPending())
372         return;
373     bool isValid = false;
374     switch (target) {
375     case GraphicsContext3D::GENERATE_MIPMAP_HINT:
376         isValid = true;
377         break;
378     case Extensions3D::FRAGMENT_SHADER_DERIVATIVE_HINT_OES: // OES_standard_derivatives
379         if (m_oesStandardDerivatives)
380             isValid = true;
381         break;
382     }
383     if (!isValid) {
384         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;hint&quot;, &quot;invalid target&quot;);
385         return;
386     }
387     m_context-&gt;hint(target, mode);
388 }
389 
390 void WebGLRenderingContext::clear(GC3Dbitfield mask)
391 {
392     if (isContextLostOrPending())
393         return;
394     if (mask &amp; ~(GraphicsContext3D::COLOR_BUFFER_BIT | GraphicsContext3D::DEPTH_BUFFER_BIT | GraphicsContext3D::STENCIL_BUFFER_BIT)) {
395         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;clear&quot;, &quot;invalid mask&quot;);
396         return;
397     }
398     const char* reason = &quot;framebuffer incomplete&quot;;
399     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(m_context.get(), &amp;reason)) {
400         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;clear&quot;, reason);
401         return;
402     }
403     if (!clearIfComposited(mask))
404         m_context-&gt;clear(mask);
405     markContextChangedAndNotifyCanvasObserver();
406 }
407 
408 WebGLAny WebGLRenderingContext::getParameter(GC3Denum pname)
409 {
410     if (isContextLostOrPending())
411         return nullptr;
412 
413     switch (pname) {
414     case GraphicsContext3D::ACTIVE_TEXTURE:
415         return getUnsignedIntParameter(pname);
416     case GraphicsContext3D::ALIASED_LINE_WIDTH_RANGE:
417         return getWebGLFloatArrayParameter(pname);
418     case GraphicsContext3D::ALIASED_POINT_SIZE_RANGE:
419         return getWebGLFloatArrayParameter(pname);
420     case GraphicsContext3D::ALPHA_BITS:
421         return getIntParameter(pname);
422     case GraphicsContext3D::ARRAY_BUFFER_BINDING:
423         return m_boundArrayBuffer;
424     case GraphicsContext3D::BLEND:
425         return getBooleanParameter(pname);
426     case GraphicsContext3D::BLEND_COLOR:
427         return getWebGLFloatArrayParameter(pname);
428     case GraphicsContext3D::BLEND_DST_ALPHA:
429         return getUnsignedIntParameter(pname);
430     case GraphicsContext3D::BLEND_DST_RGB:
431         return getUnsignedIntParameter(pname);
432     case GraphicsContext3D::BLEND_EQUATION_ALPHA:
433         return getUnsignedIntParameter(pname);
434     case GraphicsContext3D::BLEND_EQUATION_RGB:
435         return getUnsignedIntParameter(pname);
436     case GraphicsContext3D::BLEND_SRC_ALPHA:
437         return getUnsignedIntParameter(pname);
438     case GraphicsContext3D::BLEND_SRC_RGB:
439         return getUnsignedIntParameter(pname);
440     case GraphicsContext3D::BLUE_BITS:
441         return getIntParameter(pname);
442     case GraphicsContext3D::COLOR_CLEAR_VALUE:
443         return getWebGLFloatArrayParameter(pname);
444     case GraphicsContext3D::COLOR_WRITEMASK:
445         return getBooleanArrayParameter(pname);
446     case GraphicsContext3D::COMPRESSED_TEXTURE_FORMATS:
447         return Uint32Array::tryCreate(m_compressedTextureFormats.data(), m_compressedTextureFormats.size());
448     case GraphicsContext3D::CULL_FACE:
449         return getBooleanParameter(pname);
450     case GraphicsContext3D::CULL_FACE_MODE:
451         return getUnsignedIntParameter(pname);
452     case GraphicsContext3D::CURRENT_PROGRAM:
453         return m_currentProgram;
454     case GraphicsContext3D::DEPTH_BITS:
455         if (!m_framebufferBinding &amp;&amp; !m_attributes.depth)
456             return 0;
457         return getIntParameter(pname);
458     case GraphicsContext3D::DEPTH_CLEAR_VALUE:
459         return getFloatParameter(pname);
460     case GraphicsContext3D::DEPTH_FUNC:
461         return getUnsignedIntParameter(pname);
462     case GraphicsContext3D::DEPTH_RANGE:
463         return getWebGLFloatArrayParameter(pname);
464     case GraphicsContext3D::DEPTH_TEST:
465         return getBooleanParameter(pname);
466     case GraphicsContext3D::DEPTH_WRITEMASK:
467         return getBooleanParameter(pname);
468     case GraphicsContext3D::DITHER:
469         return getBooleanParameter(pname);
470     case GraphicsContext3D::ELEMENT_ARRAY_BUFFER_BINDING:
471         return makeRefPtr(m_boundVertexArrayObject-&gt;getElementArrayBuffer());
472     case GraphicsContext3D::FRAMEBUFFER_BINDING:
473         return m_framebufferBinding;
474     case GraphicsContext3D::FRONT_FACE:
475         return getUnsignedIntParameter(pname);
476     case GraphicsContext3D::GENERATE_MIPMAP_HINT:
477         return getUnsignedIntParameter(pname);
478     case GraphicsContext3D::GREEN_BITS:
479         return getIntParameter(pname);
480     case GraphicsContext3D::IMPLEMENTATION_COLOR_READ_FORMAT:
481         return getIntParameter(pname);
482     case GraphicsContext3D::IMPLEMENTATION_COLOR_READ_TYPE:
483         return getIntParameter(pname);
484     case GraphicsContext3D::LINE_WIDTH:
485         return getFloatParameter(pname);
486     case GraphicsContext3D::MAX_COMBINED_TEXTURE_IMAGE_UNITS:
487         return getIntParameter(pname);
488     case GraphicsContext3D::MAX_CUBE_MAP_TEXTURE_SIZE:
489         return getIntParameter(pname);
490     case GraphicsContext3D::MAX_FRAGMENT_UNIFORM_VECTORS:
491         return getIntParameter(pname);
492     case GraphicsContext3D::MAX_RENDERBUFFER_SIZE:
493         return getIntParameter(pname);
494     case GraphicsContext3D::MAX_TEXTURE_IMAGE_UNITS:
495         return getIntParameter(pname);
496     case GraphicsContext3D::MAX_TEXTURE_SIZE:
497         return getIntParameter(pname);
498     case GraphicsContext3D::MAX_VARYING_VECTORS:
499         return getIntParameter(pname);
500     case GraphicsContext3D::MAX_VERTEX_ATTRIBS:
501         return getIntParameter(pname);
502     case GraphicsContext3D::MAX_VERTEX_TEXTURE_IMAGE_UNITS:
503         return getIntParameter(pname);
504     case GraphicsContext3D::MAX_VERTEX_UNIFORM_VECTORS:
505         return getIntParameter(pname);
506     case GraphicsContext3D::MAX_VIEWPORT_DIMS:
507         return getWebGLIntArrayParameter(pname);
508     case GraphicsContext3D::NUM_SHADER_BINARY_FORMATS:
509         return getIntParameter(pname);
510     case GraphicsContext3D::PACK_ALIGNMENT:
511         return getIntParameter(pname);
512     case GraphicsContext3D::POLYGON_OFFSET_FACTOR:
513         return getFloatParameter(pname);
514     case GraphicsContext3D::POLYGON_OFFSET_FILL:
515         return getBooleanParameter(pname);
516     case GraphicsContext3D::POLYGON_OFFSET_UNITS:
517         return getFloatParameter(pname);
518     case GraphicsContext3D::RED_BITS:
519         return getIntParameter(pname);
520     case GraphicsContext3D::RENDERBUFFER_BINDING:
521         return m_renderbufferBinding;
522     case GraphicsContext3D::RENDERER:
523         return &quot;WebKit WebGL&quot;_str;
524     case GraphicsContext3D::SAMPLE_BUFFERS:
525         return getIntParameter(pname);
526     case GraphicsContext3D::SAMPLE_COVERAGE_INVERT:
527         return getBooleanParameter(pname);
528     case GraphicsContext3D::SAMPLE_COVERAGE_VALUE:
529         return getFloatParameter(pname);
530     case GraphicsContext3D::SAMPLES:
531         return getIntParameter(pname);
532     case GraphicsContext3D::SCISSOR_BOX:
533         return getWebGLIntArrayParameter(pname);
534     case GraphicsContext3D::SCISSOR_TEST:
535         return getBooleanParameter(pname);
536     case GraphicsContext3D::SHADING_LANGUAGE_VERSION:
537         return &quot;WebGL GLSL ES 1.0 (&quot; + m_context-&gt;getString(GraphicsContext3D::SHADING_LANGUAGE_VERSION) + &quot;)&quot;;
538     case GraphicsContext3D::STENCIL_BACK_FAIL:
539         return getUnsignedIntParameter(pname);
540     case GraphicsContext3D::STENCIL_BACK_FUNC:
541         return getUnsignedIntParameter(pname);
542     case GraphicsContext3D::STENCIL_BACK_PASS_DEPTH_FAIL:
543         return getUnsignedIntParameter(pname);
544     case GraphicsContext3D::STENCIL_BACK_PASS_DEPTH_PASS:
545         return getUnsignedIntParameter(pname);
546     case GraphicsContext3D::STENCIL_BACK_REF:
547         return getIntParameter(pname);
548     case GraphicsContext3D::STENCIL_BACK_VALUE_MASK:
549         return getUnsignedIntParameter(pname);
550     case GraphicsContext3D::STENCIL_BACK_WRITEMASK:
551         return getUnsignedIntParameter(pname);
552     case GraphicsContext3D::STENCIL_BITS:
553         if (!m_framebufferBinding &amp;&amp; !m_attributes.stencil)
554             return 0;
555         return getIntParameter(pname);
556     case GraphicsContext3D::STENCIL_CLEAR_VALUE:
557         return getIntParameter(pname);
558     case GraphicsContext3D::STENCIL_FAIL:
559         return getUnsignedIntParameter(pname);
560     case GraphicsContext3D::STENCIL_FUNC:
561         return getUnsignedIntParameter(pname);
562     case GraphicsContext3D::STENCIL_PASS_DEPTH_FAIL:
563         return getUnsignedIntParameter(pname);
564     case GraphicsContext3D::STENCIL_PASS_DEPTH_PASS:
565         return getUnsignedIntParameter(pname);
566     case GraphicsContext3D::STENCIL_REF:
567         return getIntParameter(pname);
568     case GraphicsContext3D::STENCIL_TEST:
569         return getBooleanParameter(pname);
570     case GraphicsContext3D::STENCIL_VALUE_MASK:
571         return getUnsignedIntParameter(pname);
572     case GraphicsContext3D::STENCIL_WRITEMASK:
573         return getUnsignedIntParameter(pname);
574     case GraphicsContext3D::SUBPIXEL_BITS:
575         return getIntParameter(pname);
576     case GraphicsContext3D::TEXTURE_BINDING_2D:
577         return m_textureUnits[m_activeTextureUnit].texture2DBinding;
578     case GraphicsContext3D::TEXTURE_BINDING_CUBE_MAP:
579         return m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
580     case GraphicsContext3D::UNPACK_ALIGNMENT:
581         return getIntParameter(pname);
582     case GraphicsContext3D::UNPACK_FLIP_Y_WEBGL:
583         return m_unpackFlipY;
584     case GraphicsContext3D::UNPACK_PREMULTIPLY_ALPHA_WEBGL:
585         return m_unpackPremultiplyAlpha;
586     case GraphicsContext3D::UNPACK_COLORSPACE_CONVERSION_WEBGL:
587         return m_unpackColorspaceConversion;
588     case GraphicsContext3D::VENDOR:
589         return &quot;WebKit&quot;_str;
590     case GraphicsContext3D::VERSION:
591         return &quot;WebGL 1.0&quot;_str;
592     case GraphicsContext3D::VIEWPORT:
593         return getWebGLIntArrayParameter(pname);
594     case Extensions3D::FRAGMENT_SHADER_DERIVATIVE_HINT_OES: // OES_standard_derivatives
595         if (m_oesStandardDerivatives)
596             return getUnsignedIntParameter(Extensions3D::FRAGMENT_SHADER_DERIVATIVE_HINT_OES);
597         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, OES_standard_derivatives not enabled&quot;);
598         return nullptr;
599     case WebGLDebugRendererInfo::UNMASKED_RENDERER_WEBGL:
600         if (m_webglDebugRendererInfo) {
601 #if PLATFORM(IOS_FAMILY)
602             return &quot;Apple GPU&quot;_str;
603 #else
604             return m_context-&gt;getString(GraphicsContext3D::RENDERER);
605 #endif
606         }
607         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);
608         return nullptr;
609     case WebGLDebugRendererInfo::UNMASKED_VENDOR_WEBGL:
610         if (m_webglDebugRendererInfo)
611             return m_context-&gt;getString(GraphicsContext3D::VENDOR);
612         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);
613         return nullptr;
614     case Extensions3D::VERTEX_ARRAY_BINDING_OES: // OES_vertex_array_object
615         if (m_oesVertexArrayObject) {
616             if (m_boundVertexArrayObject-&gt;isDefaultObject())
617                 return nullptr;
618             return makeRefPtr(static_cast&lt;WebGLVertexArrayObjectOES&amp;&gt;(*m_boundVertexArrayObject));
619         }
620         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, OES_vertex_array_object not enabled&quot;);
621         return nullptr;
622     case Extensions3D::MAX_TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic
623         if (m_extTextureFilterAnisotropic)
624             return getUnsignedIntParameter(Extensions3D::MAX_TEXTURE_MAX_ANISOTROPY_EXT);
625         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);
626         return nullptr;
627     case Extensions3D::MAX_COLOR_ATTACHMENTS_EXT: // EXT_draw_buffers BEGIN
628         if (m_webglDrawBuffers)
629             return getMaxColorAttachments();
630         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_draw_buffers not enabled&quot;);
631         return nullptr;
632     case Extensions3D::MAX_DRAW_BUFFERS_EXT:
633         if (m_webglDrawBuffers)
634             return getMaxDrawBuffers();
635         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_draw_buffers not enabled&quot;);
636         return nullptr;
637     default:
638         if (m_webglDrawBuffers
639             &amp;&amp; pname &gt;= Extensions3D::DRAW_BUFFER0_EXT
640             &amp;&amp; pname &lt; static_cast&lt;GC3Denum&gt;(Extensions3D::DRAW_BUFFER0_EXT + getMaxDrawBuffers())) {
641             GC3Dint value = GraphicsContext3D::NONE;
642             if (m_framebufferBinding)
643                 value = m_framebufferBinding-&gt;getDrawBuffer(pname);
644             else // emulated backbuffer
645                 value = m_backDrawBuffer;
646             return value;
647         }
648         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name&quot;);
649         return nullptr;
650     }
651 }
652 
653 GC3Dint WebGLRenderingContext::getMaxDrawBuffers()
654 {
655     if (!supportsDrawBuffers())
656         return 0;
657     if (!m_maxDrawBuffers)
658         m_context-&gt;getIntegerv(Extensions3D::MAX_DRAW_BUFFERS_EXT, &amp;m_maxDrawBuffers);
659     if (!m_maxColorAttachments)
660         m_context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);
661     // WEBGL_draw_buffers requires MAX_COLOR_ATTACHMENTS &gt;= MAX_DRAW_BUFFERS.
662     return std::min(m_maxDrawBuffers, m_maxColorAttachments);
663 }
664 
665 GC3Dint WebGLRenderingContext::getMaxColorAttachments()
666 {
667     if (!supportsDrawBuffers())
668         return 0;
669     if (!m_maxColorAttachments)
670         m_context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);
671     return m_maxColorAttachments;
672 }
673 
674 bool WebGLRenderingContext::validateIndexArrayConservative(GC3Denum type, unsigned&amp; numElementsRequired)
675 {
676     // Performs conservative validation by caching a maximum index of
677     // the given type per element array buffer. If all of the bound
678     // array buffers have enough elements to satisfy that maximum
679     // index, skips the expensive per-draw-call iteration in
680     // validateIndexArrayPrecise.
681 
682     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
683 
684     if (!elementArrayBuffer)
685         return false;
686 
687     GC3Dsizeiptr numElements = elementArrayBuffer-&gt;byteLength();
688     // The case count==0 is already dealt with in drawElements before validateIndexArrayConservative.
689     if (!numElements)
690         return false;
691     auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
692     ASSERT(buffer);
693 
694     Optional&lt;unsigned&gt; maxIndex = elementArrayBuffer-&gt;getCachedMaxIndex(type);
695     if (!maxIndex) {
696         // Compute the maximum index in the entire buffer for the given type of index.
697         switch (type) {
698         case GraphicsContext3D::UNSIGNED_BYTE: {
699             const GC3Dubyte* p = static_cast&lt;const GC3Dubyte*&gt;(buffer-&gt;data());
700             for (GC3Dsizeiptr i = 0; i &lt; numElements; i++)
701                 maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
702             break;
703         }
704         case GraphicsContext3D::UNSIGNED_SHORT: {
705             numElements /= sizeof(GC3Dushort);
706             const GC3Dushort* p = static_cast&lt;const GC3Dushort*&gt;(buffer-&gt;data());
707             for (GC3Dsizeiptr i = 0; i &lt; numElements; i++)
708                 maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
709             break;
710         }
711         case GraphicsContext3D::UNSIGNED_INT: {
712             if (!m_oesElementIndexUint)
713                 return false;
714             numElements /= sizeof(GC3Duint);
715             const GC3Duint* p = static_cast&lt;const GC3Duint*&gt;(buffer-&gt;data());
716             for (GC3Dsizeiptr i = 0; i &lt; numElements; i++)
717                 maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
718             break;
719         }
720         default:
721             return false;
722         }
723         if (maxIndex)
724             elementArrayBuffer-&gt;setCachedMaxIndex(type, maxIndex.value());
725     }
726 
727     if (!maxIndex)
728         return false;
729 
730     // The number of required elements is one more than the maximum index that will be accessed.
731     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex.value(), 1, 1);
732     if (!checkedNumElementsRequired)
733         return false;
734     numElementsRequired = checkedNumElementsRequired.value();
735 
736     return true;
737 }
738 
739 bool WebGLRenderingContext::validateBlendEquation(const char* functionName, GC3Denum mode)
740 {
741     switch (mode) {
742     case GraphicsContext3D::FUNC_ADD:
743     case GraphicsContext3D::FUNC_SUBTRACT:
744     case GraphicsContext3D::FUNC_REVERSE_SUBTRACT:
745     case Extensions3D::MIN_EXT:
746     case Extensions3D::MAX_EXT:
747         if ((mode == Extensions3D::MIN_EXT || mode == Extensions3D::MAX_EXT) &amp;&amp; !m_extBlendMinMax) {
748             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid mode&quot;);
749             return false;
750         }
751         return true;
752         break;
753     default:
754         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid mode&quot;);
755         return false;
756     }
757 }
758 
759 bool WebGLRenderingContext::validateCapability(const char* functionName, GC3Denum cap)
760 {
761     switch (cap) {
762     case GraphicsContext3D::BLEND:
763     case GraphicsContext3D::CULL_FACE:
764     case GraphicsContext3D::DEPTH_TEST:
765     case GraphicsContext3D::DITHER:
766     case GraphicsContext3D::POLYGON_OFFSET_FILL:
767     case GraphicsContext3D::SAMPLE_ALPHA_TO_COVERAGE:
768     case GraphicsContext3D::SAMPLE_COVERAGE:
769     case GraphicsContext3D::SCISSOR_TEST:
770     case GraphicsContext3D::STENCIL_TEST:
771         return true;
772     default:
773         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid capability&quot;);
774         return false;
775     }
776 }
777 
778 } // namespace WebCore
779 
780 #endif // ENABLE(WEBGL)
    </pre>
  </body>
</html>