<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorPageAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;InspectorPageAgent.h&quot;
 34 
 35 #include &quot;CachedResource.h&quot;
 36 #include &quot;CachedResourceLoader.h&quot;
 37 #include &quot;Cookie.h&quot;
 38 #include &quot;CookieJar.h&quot;
 39 #include &quot;CustomHeaderFields.h&quot;
 40 #include &quot;Document.h&quot;
 41 #include &quot;DocumentLoader.h&quot;
 42 #include &quot;Frame.h&quot;
 43 #include &quot;FrameLoadRequest.h&quot;
 44 #include &quot;FrameLoader.h&quot;
 45 #include &quot;FrameSnapshotting.h&quot;
 46 #include &quot;FrameView.h&quot;
 47 #include &quot;HTMLFrameOwnerElement.h&quot;
 48 #include &quot;HTMLNames.h&quot;
 49 #include &quot;ImageBuffer.h&quot;
 50 #include &quot;InspectorClient.h&quot;
 51 #include &quot;InspectorDOMAgent.h&quot;
 52 #include &quot;InspectorNetworkAgent.h&quot;
 53 #include &quot;InspectorOverlay.h&quot;
 54 #include &quot;InstrumentingAgents.h&quot;
 55 #include &quot;MIMETypeRegistry.h&quot;
 56 #include &quot;MemoryCache.h&quot;
 57 #include &quot;Page.h&quot;
 58 #include &quot;RenderObject.h&quot;
 59 #include &quot;RenderTheme.h&quot;
 60 #include &quot;ScriptController.h&quot;
 61 #include &quot;SecurityOrigin.h&quot;
 62 #include &quot;Settings.h&quot;
 63 #include &quot;StyleScope.h&quot;
 64 #include &quot;TextEncoding.h&quot;
 65 #include &quot;UserGestureIndicator.h&quot;
 66 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
 67 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 68 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 69 #include &lt;wtf/ListHashSet.h&gt;
 70 #include &lt;wtf/Stopwatch.h&gt;
 71 #include &lt;wtf/text/Base64.h&gt;
 72 #include &lt;wtf/text/StringBuilder.h&gt;
 73 
 74 #if ENABLE(APPLICATION_MANIFEST)
 75 #include &quot;CachedApplicationManifest.h&quot;
 76 #endif
 77 
 78 #if ENABLE(WEB_ARCHIVE) &amp;&amp; USE(CF)
 79 #include &quot;LegacyWebArchive.h&quot;
 80 #endif
 81 
 82 
 83 namespace WebCore {
 84 
 85 using namespace Inspector;
 86 
 87 // Keep this in sync with Page.Setting
 88 #define FOR_EACH_INSPECTOR_OVERRIDE_SETTING(macro) \
 89     macro(AuthorAndUserStylesEnabled) \
 90     macro(ICECandidateFilteringEnabled) \
 91     macro(ImagesEnabled) \
 92     macro(MediaCaptureRequiresSecureConnection) \
 93     macro(MockCaptureDevicesEnabled) \
 94     macro(NeedsSiteSpecificQuirks) \
 95     macro(ScriptEnabled) \
 96     macro(WebRTCEncryptionEnabled) \
 97     macro(WebSecurityEnabled)
 98 
 99 static bool decodeBuffer(const char* buffer, unsigned size, const String&amp; textEncodingName, String* result)
100 {
101     if (buffer) {
102         TextEncoding encoding(textEncodingName);
103         if (!encoding.isValid())
104             encoding = WindowsLatin1Encoding();
105         *result = encoding.decode(buffer, size);
106         return true;
107     }
108     return false;
109 }
110 
111 bool InspectorPageAgent::mainResourceContent(Frame* frame, bool withBase64Encode, String* result)
112 {
113     RefPtr&lt;SharedBuffer&gt; buffer = frame-&gt;loader().documentLoader()-&gt;mainResourceData();
114     if (!buffer)
115         return false;
116     return InspectorPageAgent::dataContent(buffer-&gt;data(), buffer-&gt;size(), frame-&gt;document()-&gt;encoding(), withBase64Encode, result);
117 }
118 
119 bool InspectorPageAgent::sharedBufferContent(RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, const String&amp; textEncodingName, bool withBase64Encode, String* result)
120 {
121     return dataContent(buffer ? buffer-&gt;data() : nullptr, buffer ? buffer-&gt;size() : 0, textEncodingName, withBase64Encode, result);
122 }
123 
124 bool InspectorPageAgent::dataContent(const char* data, unsigned size, const String&amp; textEncodingName, bool withBase64Encode, String* result)
125 {
126     if (withBase64Encode) {
127         *result = base64Encode(data, size);
128         return true;
129     }
130 
131     return decodeBuffer(data, size, textEncodingName, result);
132 }
133 
134 Vector&lt;CachedResource*&gt; InspectorPageAgent::cachedResourcesForFrame(Frame* frame)
135 {
136     Vector&lt;CachedResource*&gt; result;
137 
138     for (auto&amp; cachedResourceHandle : frame-&gt;document()-&gt;cachedResourceLoader().allCachedResources().values()) {
139         auto* cachedResource = cachedResourceHandle.get();
140         if (cachedResource-&gt;resourceRequest().hiddenFromInspector())
141             continue;
142 
143         switch (cachedResource-&gt;type()) {
144         case CachedResource::Type::ImageResource:
145             // Skip images that were not auto loaded (images disabled in the user agent).
146 #if ENABLE(SVG_FONTS)
147         case CachedResource::Type::SVGFontResource:
148 #endif
149         case CachedResource::Type::FontResource:
150             // Skip fonts that were referenced in CSS but never used/downloaded.
151             if (cachedResource-&gt;stillNeedsLoad())
152                 continue;
153             break;
154         default:
155             // All other CachedResource types download immediately.
156             break;
157         }
158 
159         result.append(cachedResource);
160     }
161 
162     return result;
163 }
164 
165 void InspectorPageAgent::resourceContent(ErrorString&amp; errorString, Frame* frame, const URL&amp; url, String* result, bool* base64Encoded)
166 {
167     DocumentLoader* loader = assertDocumentLoader(errorString, frame);
168     if (!loader)
169         return;
170 
171     RefPtr&lt;SharedBuffer&gt; buffer;
172     bool success = false;
173     if (equalIgnoringFragmentIdentifier(url, loader-&gt;url())) {
174         *base64Encoded = false;
175         success = mainResourceContent(frame, *base64Encoded, result);
176     }
177 
178     if (!success) {
179         if (auto* resource = cachedResource(frame, url))
180             success = InspectorNetworkAgent::cachedResourceContent(*resource, result, base64Encoded);
181     }
182 
183     if (!success)
184         errorString = &quot;Missing resource for given url&quot;_s;
185 }
186 
187 String InspectorPageAgent::sourceMapURLForResource(CachedResource* cachedResource)
188 {
189     if (!cachedResource)
190         return String();
191 
192     // Scripts are handled in a separate path.
193     if (cachedResource-&gt;type() != CachedResource::Type::CSSStyleSheet)
194         return String();
195 
196     String sourceMapHeader = cachedResource-&gt;response().httpHeaderField(HTTPHeaderName::SourceMap);
197     if (!sourceMapHeader.isEmpty())
198         return sourceMapHeader;
199 
200     sourceMapHeader = cachedResource-&gt;response().httpHeaderField(HTTPHeaderName::XSourceMap);
201     if (!sourceMapHeader.isEmpty())
202         return sourceMapHeader;
203 
204     String content;
205     bool base64Encoded;
206     if (InspectorNetworkAgent::cachedResourceContent(*cachedResource, &amp;content, &amp;base64Encoded) &amp;&amp; !base64Encoded)
207         return ContentSearchUtilities::findStylesheetSourceMapURL(content);
208 
209     return String();
210 }
211 
212 CachedResource* InspectorPageAgent::cachedResource(Frame* frame, const URL&amp; url)
213 {
214     if (url.isNull())
215         return nullptr;
216 
217     CachedResource* cachedResource = frame-&gt;document()-&gt;cachedResourceLoader().cachedResource(MemoryCache::removeFragmentIdentifierIfNeeded(url));
218     if (!cachedResource) {
219         ResourceRequest request(url);
220         request.setDomainForCachePartition(frame-&gt;document()-&gt;domainForCachePartition());
221         cachedResource = MemoryCache::singleton().resourceForRequest(request, frame-&gt;page()-&gt;sessionID());
222     }
223 
224     return cachedResource;
225 }
226 
227 Inspector::Protocol::Page::ResourceType InspectorPageAgent::resourceTypeJSON(InspectorPageAgent::ResourceType resourceType)
228 {
229     switch (resourceType) {
230     case DocumentResource:
231         return Inspector::Protocol::Page::ResourceType::Document;
232     case ImageResource:
233         return Inspector::Protocol::Page::ResourceType::Image;
234     case FontResource:
235         return Inspector::Protocol::Page::ResourceType::Font;
236     case StyleSheetResource:
237         return Inspector::Protocol::Page::ResourceType::StyleSheet;
238     case ScriptResource:
239         return Inspector::Protocol::Page::ResourceType::Script;
240     case XHRResource:
241         return Inspector::Protocol::Page::ResourceType::XHR;
242     case FetchResource:
243         return Inspector::Protocol::Page::ResourceType::Fetch;
244     case PingResource:
245         return Inspector::Protocol::Page::ResourceType::Ping;
246     case BeaconResource:
247         return Inspector::Protocol::Page::ResourceType::Beacon;
248     case WebSocketResource:
249         return Inspector::Protocol::Page::ResourceType::WebSocket;
250     case OtherResource:
251         return Inspector::Protocol::Page::ResourceType::Other;
252 #if ENABLE(APPLICATION_MANIFEST)
253     case ApplicationManifestResource:
254         break;
255 #endif
256     }
257     return Inspector::Protocol::Page::ResourceType::Other;
258 }
259 
260 InspectorPageAgent::ResourceType InspectorPageAgent::inspectorResourceType(CachedResource::Type type)
261 {
262     switch (type) {
263     case CachedResource::Type::ImageResource:
264         return InspectorPageAgent::ImageResource;
265 #if ENABLE(SVG_FONTS)
266     case CachedResource::Type::SVGFontResource:
267 #endif
268     case CachedResource::Type::FontResource:
269         return InspectorPageAgent::FontResource;
270 #if ENABLE(XSLT)
271     case CachedResource::Type::XSLStyleSheet:
272 #endif
273     case CachedResource::Type::CSSStyleSheet:
274         return InspectorPageAgent::StyleSheetResource;
275     case CachedResource::Type::Script:
276         return InspectorPageAgent::ScriptResource;
277     case CachedResource::Type::MainResource:
278         return InspectorPageAgent::DocumentResource;
279     case CachedResource::Type::Beacon:
280         return InspectorPageAgent::BeaconResource;
281 #if ENABLE(APPLICATION_MANIFEST)
282     case CachedResource::Type::ApplicationManifest:
283         return InspectorPageAgent::ApplicationManifestResource;
284 #endif
285     case CachedResource::Type::Ping:
286         return InspectorPageAgent::PingResource;
287     case CachedResource::Type::MediaResource:
288     case CachedResource::Type::Icon:
289     case CachedResource::Type::RawResource:
290     default:
291         return InspectorPageAgent::OtherResource;
292     }
293 }
294 
295 InspectorPageAgent::ResourceType InspectorPageAgent::inspectorResourceType(const CachedResource&amp; cachedResource)
296 {
297     if (cachedResource.type() == CachedResource::Type::RawResource) {
298         switch (cachedResource.resourceRequest().requester()) {
299         case ResourceRequest::Requester::Fetch:
300             return InspectorPageAgent::FetchResource;
301         case ResourceRequest::Requester::Main:
302             return InspectorPageAgent::DocumentResource;
303         default:
304             return InspectorPageAgent::XHRResource;
305         }
306     }
307 
308     return inspectorResourceType(cachedResource.type());
309 }
310 
311 Inspector::Protocol::Page::ResourceType InspectorPageAgent::cachedResourceTypeJSON(const CachedResource&amp; cachedResource)
312 {
313     return resourceTypeJSON(inspectorResourceType(cachedResource));
314 }
315 
316 Frame* InspectorPageAgent::findFrameWithSecurityOrigin(Page&amp; page, const String&amp; originRawString)
317 {
318     for (Frame* frame = &amp;page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
319         if (frame-&gt;document()-&gt;securityOrigin().toRawString() == originRawString)
320             return frame;
321     }
322     return nullptr;
323 }
324 
325 DocumentLoader* InspectorPageAgent::assertDocumentLoader(ErrorString&amp; errorString, Frame* frame)
326 {
327     FrameLoader&amp; frameLoader = frame-&gt;loader();
328     DocumentLoader* documentLoader = frameLoader.documentLoader();
329     if (!documentLoader)
330         errorString = &quot;Missing document loader for given frame&quot;_s;
331     return documentLoader;
332 }
333 
334 InspectorPageAgent::InspectorPageAgent(PageAgentContext&amp; context, InspectorClient* client, InspectorOverlay* overlay)
335     : InspectorAgentBase(&quot;Page&quot;_s, context)
336     , m_frontendDispatcher(makeUnique&lt;Inspector::PageFrontendDispatcher&gt;(context.frontendRouter))
337     , m_backendDispatcher(Inspector::PageBackendDispatcher::create(context.backendDispatcher, this))
338     , m_inspectedPage(context.inspectedPage)
339     , m_client(client)
340     , m_overlay(overlay)
341 {
342 }
343 
344 InspectorPageAgent::~InspectorPageAgent() = default;
345 
346 void InspectorPageAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
347 {
348 }
349 
350 void InspectorPageAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
351 {
352     ErrorString unused;
353     disable(unused);
354 }
355 
356 void InspectorPageAgent::enable(ErrorString&amp; errorString)
357 {
358     if (m_instrumentingAgents.inspectorPageAgent() == this) {
359         errorString = &quot;Page domain already enabled&quot;_s;
360         return;
361     }
362 
363     m_instrumentingAgents.setInspectorPageAgent(this);
364 
365     auto stopwatch = m_environment.executionStopwatch();
366     stopwatch-&gt;reset();
367     stopwatch-&gt;start();
368 
369 #if HAVE(OS_DARK_MODE_SUPPORT)
370     defaultAppearanceDidChange(m_inspectedPage.defaultUseDarkAppearance());
371 #endif
372 }
373 
374 void InspectorPageAgent::disable(ErrorString&amp;)
375 {
376     m_instrumentingAgents.setInspectorPageAgent(nullptr);
377 
378     ErrorString unused;
379     setShowPaintRects(unused, false);
380     setShowRulers(unused, false);
381     overrideUserAgent(unused, nullptr);
382     setEmulatedMedia(unused, emptyString());
383     setForcedAppearance(unused, emptyString());
384 
385 #define DISABLE_INSPECTOR_OVERRIDE_SETTING(name) \
386     m_inspectedPage.settings().set##name##InspectorOverride(WTF::nullopt);
387 
388     FOR_EACH_INSPECTOR_OVERRIDE_SETTING(DISABLE_INSPECTOR_OVERRIDE_SETTING)
389 
390 #undef DISABLE_INSPECTOR_OVERRIDE_SETTING
391 
392     m_client-&gt;setMockCaptureDevicesEnabledOverride(WTF::nullopt);
393 }
394 
395 double InspectorPageAgent::timestamp()
396 {
397     return m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
398 }
399 
400 void InspectorPageAgent::reload(ErrorString&amp;, const bool* optionalReloadFromOrigin, const bool* optionalRevalidateAllResources)
401 {
402     bool reloadFromOrigin = optionalReloadFromOrigin &amp;&amp; *optionalReloadFromOrigin;
403     bool revalidateAllResources = optionalRevalidateAllResources &amp;&amp; *optionalRevalidateAllResources;
404 
405     OptionSet&lt;ReloadOption&gt; reloadOptions;
406     if (reloadFromOrigin)
407         reloadOptions.add(ReloadOption::FromOrigin);
408     if (!revalidateAllResources)
409         reloadOptions.add(ReloadOption::ExpiredOnly);
410 
411     m_inspectedPage.mainFrame().loader().reload(reloadOptions);
412 }
413 
414 void InspectorPageAgent::navigate(ErrorString&amp;, const String&amp; url)
415 {
416     UserGestureIndicator indicator { ProcessingUserGesture };
417     Frame&amp; frame = m_inspectedPage.mainFrame();
418 
419     ResourceRequest resourceRequest { frame.document()-&gt;completeURL(url) };
420     FrameLoadRequest frameLoadRequest { *frame.document(), frame.document()-&gt;securityOrigin(), resourceRequest, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::No, NewFrameOpenerPolicy::Allow, ShouldOpenExternalURLsPolicy::ShouldNotAllow, InitiatedByMainFrame::Unknown };
421     frame.loader().changeLocation(WTFMove(frameLoadRequest));
422 }
423 
424 void InspectorPageAgent::overrideUserAgent(ErrorString&amp;, const String* value)
425 {
426     m_userAgentOverride = value ? *value : String();
427 }
428 
429 static inline Optional&lt;bool&gt; asOptionalBool(const bool* value)
430 {
431     if (!value)
432         return WTF::nullopt;
433     return *value;
434 }
435 
436 void InspectorPageAgent::overrideSetting(ErrorString&amp; errorString, const String&amp; settingString, const bool* value)
437 {
438     if (settingString.isEmpty()) {
439         errorString = &quot;settingString is empty&quot;_s;
440         return;
441     }
442 
443     auto setting = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Page::Setting&gt;(settingString);
444     if (!setting) {
445         errorString = makeString(&quot;Unknown settingString: &quot;_s, settingString);
446         return;
447     }
448 
449     auto overrideValue = asOptionalBool(value);
450     switch (setting.value()) {
451 #define CASE_INSPECTOR_OVERRIDE_SETTING(name) \
452     case Inspector::Protocol::Page::Setting::name:                              \
453         m_inspectedPage.settings().set##name##InspectorOverride(overrideValue); \
454         break;                                                                  \
455 
456     FOR_EACH_INSPECTOR_OVERRIDE_SETTING(CASE_INSPECTOR_OVERRIDE_SETTING)
457 
458 #undef CASE_INSPECTOR_OVERRIDE_SETTING
459     }
460 
461     // Update the UIProcess / client for particular overrides.
462     if (setting.value() == Inspector::Protocol::Page::Setting::MockCaptureDevicesEnabled)
463         m_client-&gt;setMockCaptureDevicesEnabledOverride(overrideValue);
464 }
465 
466 static Inspector::Protocol::Page::CookieSameSitePolicy cookieSameSitePolicyJSON(Cookie::SameSitePolicy policy)
467 {
468     switch (policy) {
469     case Cookie::SameSitePolicy::None:
470         return Inspector::Protocol::Page::CookieSameSitePolicy::None;
471     case Cookie::SameSitePolicy::Lax:
472         return Inspector::Protocol::Page::CookieSameSitePolicy::Lax;
473     case Cookie::SameSitePolicy::Strict:
474         return Inspector::Protocol::Page::CookieSameSitePolicy::Strict;
475     }
476     ASSERT_NOT_REACHED();
477     return Inspector::Protocol::Page::CookieSameSitePolicy::None;
478 }
479 
480 static Ref&lt;Inspector::Protocol::Page::Cookie&gt; buildObjectForCookie(const Cookie&amp; cookie)
481 {
482     return Inspector::Protocol::Page::Cookie::create()
483         .setName(cookie.name)
484         .setValue(cookie.value)
485         .setDomain(cookie.domain)
486         .setPath(cookie.path)
487         .setExpires(cookie.expires)
488         .setSize((cookie.name.length() + cookie.value.length()))
489         .setHttpOnly(cookie.httpOnly)
490         .setSecure(cookie.secure)
491         .setSession(cookie.session)
492         .setSameSite(cookieSameSitePolicyJSON(cookie.sameSite))
493         .release();
494 }
495 
496 static Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;&gt; buildArrayForCookies(ListHashSet&lt;Cookie&gt;&amp; cookiesList)
497 {
498     auto cookies = JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;::create();
499 
500     for (const auto&amp; cookie : cookiesList)
501         cookies-&gt;addItem(buildObjectForCookie(cookie));
502 
503     return cookies;
504 }
505 
506 static Vector&lt;URL&gt; allResourcesURLsForFrame(Frame* frame)
507 {
508     Vector&lt;URL&gt; result;
509 
510     result.append(frame-&gt;loader().documentLoader()-&gt;url());
511 
512     for (auto* cachedResource : InspectorPageAgent::cachedResourcesForFrame(frame))
513         result.append(cachedResource-&gt;url());
514 
515     return result;
516 }
517 
518 void InspectorPageAgent::getCookies(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;&gt;&amp; cookies)
519 {
520     // If we can get raw cookies.
521     ListHashSet&lt;Cookie&gt; rawCookiesList;
522 
523     // If we can&#39;t get raw cookies - fall back to String representation
524     StringBuilder stringCookiesList;
525 
526     // Return value to getRawCookies should be the same for every call because
527     // the return value is platform/network backend specific, and the call will
528     // always return the same true/false value.
529     bool rawCookiesImplemented = false;
530 
531     for (Frame* frame = &amp;m_inspectedPage.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
532         Document* document = frame-&gt;document();
533         if (!document || !document-&gt;page())
534             continue;
535 
536         for (auto&amp; url : allResourcesURLsForFrame(frame)) {
537             Vector&lt;Cookie&gt; docCookiesList;
538             rawCookiesImplemented = document-&gt;page()-&gt;cookieJar().getRawCookies(*document, URL({ }, url), docCookiesList);
539 
540             if (!rawCookiesImplemented) {
541                 // FIXME: We need duplication checking for the String representation of cookies.
542                 // Exceptions are thrown by cookie() in sandboxed frames. That won&#39;t happen here
543                 // because &quot;document&quot; is the document of the main frame of the page.
544                 stringCookiesList.append(document-&gt;cookie().releaseReturnValue());
545             } else {
546                 for (auto&amp; cookie : docCookiesList)
547                     rawCookiesList.add(cookie);
548             }
549         }
550     }
551 
552     // FIXME: Do not return empty string/empty array. Make returns optional instead. https://bugs.webkit.org/show_bug.cgi?id=80855
553     if (rawCookiesImplemented)
554         cookies = buildArrayForCookies(rawCookiesList);
555     else
556         cookies = JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;::create();
557 }
558 
559 void InspectorPageAgent::deleteCookie(ErrorString&amp;, const String&amp; cookieName, const String&amp; url)
560 {
561     URL parsedURL({ }, url);
562     for (Frame* frame = &amp;m_inspectedPage.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
563         if (auto* document = frame-&gt;document()) {
564             if (auto* page = document-&gt;page())
565                 page-&gt;cookieJar().deleteCookie(*document, parsedURL, cookieName);
566         }
567     }
568 }
569 
570 void InspectorPageAgent::getResourceTree(ErrorString&amp;, RefPtr&lt;Inspector::Protocol::Page::FrameResourceTree&gt;&amp; object)
571 {
572     object = buildObjectForFrameTree(&amp;m_inspectedPage.mainFrame());
573 }
574 
575 void InspectorPageAgent::getResourceContent(ErrorString&amp; errorString, const String&amp; frameId, const String&amp; url, String* content, bool* base64Encoded)
576 {
577     Frame* frame = assertFrame(errorString, frameId);
578     if (!frame)
579         return;
580 
581     resourceContent(errorString, frame, URL({ }, url), content, base64Encoded);
582 }
583 
584 void InspectorPageAgent::searchInResource(ErrorString&amp; errorString, const String&amp; frameId, const String&amp; url, const String&amp; query, const bool* optionalCaseSensitive, const bool* optionalIsRegex, const String* optionalRequestId, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;&gt;&amp; results)
585 {
586     results = JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;::create();
587 
588     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
589     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
590 
591     if (optionalRequestId) {
592         if (InspectorNetworkAgent* networkAgent = m_instrumentingAgents.inspectorNetworkAgent()) {
593             networkAgent-&gt;searchInRequest(errorString, *optionalRequestId, query, caseSensitive, isRegex, results);
594             return;
595         }
596     }
597 
598     Frame* frame = assertFrame(errorString, frameId);
599     if (!frame)
600         return;
601 
602     DocumentLoader* loader = assertDocumentLoader(errorString, frame);
603     if (!loader)
604         return;
605 
606     URL kurl({ }, url);
607 
608     String content;
609     bool success = false;
610     if (equalIgnoringFragmentIdentifier(kurl, loader-&gt;url()))
611         success = mainResourceContent(frame, false, &amp;content);
612 
613     if (!success) {
614         if (auto* resource = cachedResource(frame, kurl)) {
615             if (auto textContent = InspectorNetworkAgent::textContentForCachedResource(*resource)) {
616                 content = *textContent;
617                 success = true;
618             }
619         }
620     }
621 
622     if (!success)
623         return;
624 
625     results = ContentSearchUtilities::searchInTextByLines(content, query, caseSensitive, isRegex);
626 }
627 
628 static Ref&lt;Inspector::Protocol::Page::SearchResult&gt; buildObjectForSearchResult(const String&amp; frameId, const String&amp; url, int matchesCount)
629 {
630     return Inspector::Protocol::Page::SearchResult::create()
631         .setUrl(url)
632         .setFrameId(frameId)
633         .setMatchesCount(matchesCount)
634         .release();
635 }
636 
637 void InspectorPageAgent::searchInResources(ErrorString&amp;, const String&amp; text, const bool* optionalCaseSensitive, const bool* optionalIsRegex, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;&gt;&amp; result)
638 {
639     result = JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;::create();
640 
641     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
642     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
643     JSC::Yarr::RegularExpression regex = ContentSearchUtilities::createSearchRegex(text, caseSensitive, isRegex);
644 
645     for (Frame* frame = &amp;m_inspectedPage.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
646         for (auto* cachedResource : cachedResourcesForFrame(frame)) {
647             if (auto textContent = InspectorNetworkAgent::textContentForCachedResource(*cachedResource)) {
648                 int matchesCount = ContentSearchUtilities::countRegularExpressionMatches(regex, *textContent);
649                 if (matchesCount)
650                     result-&gt;addItem(buildObjectForSearchResult(frameId(frame), cachedResource-&gt;url(), matchesCount));
651             }
652         }
653     }
654 
655     if (InspectorNetworkAgent* networkAgent = m_instrumentingAgents.inspectorNetworkAgent())
656         networkAgent-&gt;searchOtherRequests(regex, result);
657 }
658 
659 void InspectorPageAgent::setShowRulers(ErrorString&amp;, bool showRulers)
660 {
661     m_overlay-&gt;setShowRulers(showRulers);
662 }
663 
664 void InspectorPageAgent::setShowPaintRects(ErrorString&amp;, bool show)
665 {
666     m_showPaintRects = show;
667     m_client-&gt;setShowPaintRects(show);
668 
669     if (m_client-&gt;overridesShowPaintRects())
670         return;
671 
672     m_overlay-&gt;setShowPaintRects(show);
673 }
674 
675 void InspectorPageAgent::domContentEventFired()
676 {
677     m_isFirstLayoutAfterOnLoad = true;
678     m_frontendDispatcher-&gt;domContentEventFired(timestamp());
679 }
680 
681 void InspectorPageAgent::loadEventFired()
682 {
683     m_frontendDispatcher-&gt;loadEventFired(timestamp());
684 }
685 
686 void InspectorPageAgent::frameNavigated(Frame&amp; frame)
687 {
688     m_frontendDispatcher-&gt;frameNavigated(buildObjectForFrame(&amp;frame));
689 }
690 
691 void InspectorPageAgent::frameDetached(Frame&amp; frame)
692 {
693     auto identifier = m_frameToIdentifier.take(&amp;frame);
694     if (identifier.isNull())
695         return;
696     m_frontendDispatcher-&gt;frameDetached(identifier);
697     m_identifierToFrame.remove(identifier);
698 }
699 
700 Frame* InspectorPageAgent::frameForId(const String&amp; frameId)
701 {
702     return frameId.isEmpty() ? nullptr : m_identifierToFrame.get(frameId);
703 }
704 
705 String InspectorPageAgent::frameId(Frame* frame)
706 {
707     if (!frame)
708         return emptyString();
709     return m_frameToIdentifier.ensure(frame, [this, frame] {
710         auto identifier = IdentifiersFactory::createIdentifier();
711         m_identifierToFrame.set(identifier, frame);
712         return identifier;
713     }).iterator-&gt;value;
714 }
715 
716 String InspectorPageAgent::loaderId(DocumentLoader* loader)
717 {
718     if (!loader)
719         return emptyString();
720     return m_loaderToIdentifier.ensure(loader, [] {
721         return IdentifiersFactory::createIdentifier();
722     }).iterator-&gt;value;
723 }
724 
725 Frame* InspectorPageAgent::assertFrame(ErrorString&amp; errorString, const String&amp; frameId)
726 {
727     Frame* frame = frameForId(frameId);
728     if (!frame)
729         errorString = &quot;Missing frame for given frameId&quot;_s;
730     return frame;
731 }
732 
733 void InspectorPageAgent::loaderDetachedFromFrame(DocumentLoader&amp; loader)
734 {
735     m_loaderToIdentifier.remove(&amp;loader);
736 }
737 
738 void InspectorPageAgent::frameStartedLoading(Frame&amp; frame)
739 {
740     m_frontendDispatcher-&gt;frameStartedLoading(frameId(&amp;frame));
741 }
742 
743 void InspectorPageAgent::frameStoppedLoading(Frame&amp; frame)
744 {
745     m_frontendDispatcher-&gt;frameStoppedLoading(frameId(&amp;frame));
746 }
747 
748 void InspectorPageAgent::frameScheduledNavigation(Frame&amp; frame, Seconds delay)
749 {
750     m_frontendDispatcher-&gt;frameScheduledNavigation(frameId(&amp;frame), delay.value());
751 }
752 
753 void InspectorPageAgent::frameClearedScheduledNavigation(Frame&amp; frame)
754 {
755     m_frontendDispatcher-&gt;frameClearedScheduledNavigation(frameId(&amp;frame));
756 }
757 
758 void InspectorPageAgent::defaultAppearanceDidChange(bool useDarkAppearance)
759 {
760     m_frontendDispatcher-&gt;defaultAppearanceDidChange(useDarkAppearance ? Inspector::Protocol::Page::Appearance::Dark : Inspector::Protocol::Page::Appearance::Light);
761 }
762 
763 void InspectorPageAgent::didPaint(RenderObject&amp; renderer, const LayoutRect&amp; rect)
764 {
765     if (!m_showPaintRects)
766         return;
767 
768     LayoutRect absoluteRect = LayoutRect(renderer.localToAbsoluteQuad(FloatRect(rect)).boundingBox());
769     FrameView* view = renderer.document().view();
770 
771     LayoutRect rootRect = absoluteRect;
772     if (!view-&gt;frame().isMainFrame()) {
773         IntRect rootViewRect = view-&gt;contentsToRootView(snappedIntRect(absoluteRect));
774         rootRect = view-&gt;frame().mainFrame().view()-&gt;rootViewToContents(rootViewRect);
775     }
776 
777     if (m_client-&gt;overridesShowPaintRects()) {
778         m_client-&gt;showPaintRect(rootRect);
779         return;
780     }
781 
782     m_overlay-&gt;showPaintRect(rootRect);
783 }
784 
785 void InspectorPageAgent::didLayout()
786 {
787     bool isFirstLayout = m_isFirstLayoutAfterOnLoad;
788     if (isFirstLayout)
789         m_isFirstLayoutAfterOnLoad = false;
790 
791     m_overlay-&gt;update();
792 }
793 
794 void InspectorPageAgent::didScroll()
795 {
796     m_overlay-&gt;update();
797 }
798 
799 void InspectorPageAgent::didRecalculateStyle()
800 {
801     m_overlay-&gt;update();
802 }
803 
804 Ref&lt;Inspector::Protocol::Page::Frame&gt; InspectorPageAgent::buildObjectForFrame(Frame* frame)
805 {
806     ASSERT_ARG(frame, frame);
807 
808     auto frameObject = Inspector::Protocol::Page::Frame::create()
809         .setId(frameId(frame))
810         .setLoaderId(loaderId(frame-&gt;loader().documentLoader()))
811         .setUrl(frame-&gt;document()-&gt;url().string())
812         .setMimeType(frame-&gt;loader().documentLoader()-&gt;responseMIMEType())
813         .setSecurityOrigin(frame-&gt;document()-&gt;securityOrigin().toRawString())
814         .release();
815     if (frame-&gt;tree().parent())
816         frameObject-&gt;setParentId(frameId(frame-&gt;tree().parent()));
817     if (frame-&gt;ownerElement()) {
818         String name = frame-&gt;ownerElement()-&gt;getNameAttribute();
819         if (name.isEmpty())
820             name = frame-&gt;ownerElement()-&gt;attributeWithoutSynchronization(HTMLNames::idAttr);
821         frameObject-&gt;setName(name);
822     }
823 
824     return frameObject;
825 }
826 
827 Ref&lt;Inspector::Protocol::Page::FrameResourceTree&gt; InspectorPageAgent::buildObjectForFrameTree(Frame* frame)
828 {
829     ASSERT_ARG(frame, frame);
830 
831     Ref&lt;Inspector::Protocol::Page::Frame&gt; frameObject = buildObjectForFrame(frame);
832     auto subresources = JSON::ArrayOf&lt;Inspector::Protocol::Page::FrameResource&gt;::create();
833     auto result = Inspector::Protocol::Page::FrameResourceTree::create()
834         .setFrame(WTFMove(frameObject))
835         .setResources(subresources.copyRef())
836         .release();
837 
838     for (auto* cachedResource : cachedResourcesForFrame(frame)) {
839         auto resourceObject = Inspector::Protocol::Page::FrameResource::create()
840             .setUrl(cachedResource-&gt;url())
841             .setType(cachedResourceTypeJSON(*cachedResource))
842             .setMimeType(cachedResource-&gt;response().mimeType())
843             .release();
844         if (cachedResource-&gt;wasCanceled())
845             resourceObject-&gt;setCanceled(true);
846         else if (cachedResource-&gt;status() == CachedResource::LoadError || cachedResource-&gt;status() == CachedResource::DecodeError)
847             resourceObject-&gt;setFailed(true);
848         String sourceMappingURL = InspectorPageAgent::sourceMapURLForResource(cachedResource);
849         if (!sourceMappingURL.isEmpty())
850             resourceObject-&gt;setSourceMapURL(sourceMappingURL);
851         String targetId = cachedResource-&gt;resourceRequest().initiatorIdentifier();
852         if (!targetId.isEmpty())
853             resourceObject-&gt;setTargetId(targetId);
854         subresources-&gt;addItem(WTFMove(resourceObject));
855     }
856 
857     RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::FrameResourceTree&gt;&gt; childrenArray;
858     for (Frame* child = frame-&gt;tree().firstChild(); child; child = child-&gt;tree().nextSibling()) {
859         if (!childrenArray) {
860             childrenArray = JSON::ArrayOf&lt;Inspector::Protocol::Page::FrameResourceTree&gt;::create();
861             result-&gt;setChildFrames(childrenArray);
862         }
863         childrenArray-&gt;addItem(buildObjectForFrameTree(child));
864     }
865     return result;
866 }
867 
868 void InspectorPageAgent::setEmulatedMedia(ErrorString&amp;, const String&amp; media)
869 {
870     if (media == m_emulatedMedia)
871         return;
872 
873     m_emulatedMedia = media;
874 
875     m_inspectedPage.updateStyleAfterChangeInEnvironment();
876 
877     if (auto* document = m_inspectedPage.mainFrame().document())
878         document-&gt;updateLayout();
879 }
880 
881 void InspectorPageAgent::setForcedAppearance(ErrorString&amp;, const String&amp; appearance)
882 {
883     if (appearance == m_forcedAppearance)
884         return;
885 
886     m_forcedAppearance = appearance;
887 
888     if (appearance == &quot;Light&quot;_s)
889         m_inspectedPage.setUseDarkAppearanceOverride(false);
890     else if (appearance == &quot;Dark&quot;_s)
891         m_inspectedPage.setUseDarkAppearanceOverride(true);
892     else
893         m_inspectedPage.setUseDarkAppearanceOverride(WTF::nullopt);
894 }
895 
896 void InspectorPageAgent::applyUserAgentOverride(String&amp; userAgent)
897 {
898     if (!m_userAgentOverride.isEmpty())
899         userAgent = m_userAgentOverride;
900 }
901 
902 void InspectorPageAgent::applyEmulatedMedia(String&amp; media)
903 {
904     if (!m_emulatedMedia.isEmpty())
905         media = m_emulatedMedia;
906 }
907 
908 void InspectorPageAgent::getCompositingBordersVisible(ErrorString&amp;, bool* outParam)
909 {
910     *outParam = m_inspectedPage.settings().showDebugBorders() || m_inspectedPage.settings().showRepaintCounter();
911 }
912 
913 void InspectorPageAgent::setCompositingBordersVisible(ErrorString&amp;, bool visible)
914 {
915     m_inspectedPage.settings().setShowDebugBorders(visible);
916     m_inspectedPage.settings().setShowRepaintCounter(visible);
917 }
918 
919 void InspectorPageAgent::snapshotNode(ErrorString&amp; errorString, int nodeId, String* outDataURL)
920 {
921     InspectorDOMAgent* domAgent = m_instrumentingAgents.inspectorDOMAgent();
922     ASSERT(domAgent);
923     Node* node = domAgent-&gt;assertNode(errorString, nodeId);
924     if (!node)
925         return;
926 
927     std::unique_ptr&lt;ImageBuffer&gt; snapshot = WebCore::snapshotNode(m_inspectedPage.mainFrame(), *node);
928     if (!snapshot) {
929         errorString = &quot;Could not capture snapshot&quot;_s;
930         return;
931     }
932 
933     *outDataURL = snapshot-&gt;toDataURL(&quot;image/png&quot;_s, WTF::nullopt, PreserveResolution::Yes);
934 }
935 
936 void InspectorPageAgent::snapshotRect(ErrorString&amp; errorString, int x, int y, int width, int height, const String&amp; coordinateSystem, String* outDataURL)
937 {
938     SnapshotOptions options = SnapshotOptionsNone;
939     if (coordinateSystem == &quot;Viewport&quot;)
940         options |= SnapshotOptionsInViewCoordinates;
941 
942     IntRect rectangle(x, y, width, height);
943     std::unique_ptr&lt;ImageBuffer&gt; snapshot = snapshotFrameRect(m_inspectedPage.mainFrame(), rectangle, options);
944 
945     if (!snapshot) {
946         errorString = &quot;Could not capture snapshot&quot;_s;
947         return;
948     }
949 
950     *outDataURL = snapshot-&gt;toDataURL(&quot;image/png&quot;_s, WTF::nullopt, PreserveResolution::Yes);
951 }
952 
953 void InspectorPageAgent::archive(ErrorString&amp; errorString, String* data)
954 {
955 #if ENABLE(WEB_ARCHIVE) &amp;&amp; USE(CF)
956     auto archive = LegacyWebArchive::create(m_inspectedPage.mainFrame());
957     if (!archive) {
958         errorString = &quot;Could not create web archive for main frame&quot;_s;
959         return;
960     }
961 
962     RetainPtr&lt;CFDataRef&gt; buffer = archive-&gt;rawDataRepresentation();
963     *data = base64Encode(CFDataGetBytePtr(buffer.get()), CFDataGetLength(buffer.get()));
964 #else
965     UNUSED_PARAM(data);
966     errorString = &quot;Not supported&quot;_s;
967 #endif
968 }
969 
970 } // namespace WebCore
    </pre>
  </body>
</html>