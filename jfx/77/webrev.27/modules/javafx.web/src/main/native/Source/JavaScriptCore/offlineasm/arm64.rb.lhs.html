<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/arm64.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 # Copyright (C) 2011-2018 Apple Inc. All rights reserved.</span>
   2 # Copyright (C) 2014 University of Szeged. All rights reserved.
   3 #
   4 # Redistribution and use in source and binary forms, with or without
   5 # modification, are permitted provided that the following conditions
   6 # are met:
   7 # 1. Redistributions of source code must retain the above copyright
   8 #    notice, this list of conditions and the following disclaimer.
   9 # 2. Redistributions in binary form must reproduce the above copyright
  10 #    notice, this list of conditions and the following disclaimer in the
  11 #    documentation and/or other materials provided with the distribution.
  12 #
  13 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23 # THE POSSIBILITY OF SUCH DAMAGE.
  24 
  25 require &quot;ast&quot;
  26 require &quot;opt&quot;
  27 require &quot;risc&quot;
  28 
  29 # Naming conventions:
  30 #
  31 # x&lt;number&gt;  =&gt; GPR. This is both the generic name of the register, and the name used
  32 #               to indicate that the register is used in 64-bit mode.
  33 # w&lt;number&gt;  =&gt; GPR in 32-bit mode. This is the low 32-bits of the GPR. If it is
  34 #               mutated then the high 32-bit part of the register is zero filled.
  35 # q&lt;number&gt;  =&gt; FPR. This is the generic name of the register.
  36 # d&lt;number&gt;  =&gt; FPR used as an IEEE 64-bit binary floating point number (i.e. double).
  37 #
  38 # GPR conventions, to match the baseline JIT:
  39 #
  40 #  x0  =&gt; t0, a0, r0
  41 #  x1  =&gt; t1, a1, r1
  42 #  x2  =&gt; t2, a2
  43 #  x3  =&gt; t3, a3
  44 #  x4  =&gt; t4
  45 #  x5  =&gt; t5
  46 # x13  =&gt;                  (scratch)
  47 # x16  =&gt;                  (scratch)
  48 # x17  =&gt;                  (scratch)
  49 # x26  =&gt;             csr0 (PB)
  50 # x27  =&gt;             csr1 (tagTypeNumber)
  51 # x28  =&gt;             csr2 (tagMask)
  52 # x29  =&gt; cfr
  53 #  sp  =&gt; sp
  54 #  lr  =&gt; lr
  55 #
  56 # FPR conventions, to match the baseline JIT:
  57 #
  58 #  q0  =&gt; ft0, fa0, fr
  59 #  q1  =&gt; ft1, fa1
  60 #  q2  =&gt; ft2, fa2
  61 #  q3  =&gt; ft3, fa3
  62 #  q4  =&gt; ft4          (unused in baseline)
  63 #  q5  =&gt; ft5          (unused in baseline)
  64 #  q8  =&gt; csfr0        (Only the lower 64 bits)
  65 #  q9  =&gt; csfr1        (Only the lower 64 bits)
  66 # q10  =&gt; csfr2        (Only the lower 64 bits)
  67 # q11  =&gt; csfr3        (Only the lower 64 bits)
  68 # q12  =&gt; csfr4        (Only the lower 64 bits)
  69 # q13  =&gt; csfr5        (Only the lower 64 bits)
  70 # q14  =&gt; csfr6        (Only the lower 64 bits)
  71 # q15  =&gt; csfr7        (Only the lower 64 bits)
  72 # q31  =&gt; scratch
  73 
  74 def arm64GPRName(name, kind)
  75     raise &quot;bad GPR name #{name}&quot; unless name =~ /^x/
  76     number = name[1..-1]
  77     case kind
  78     when :word
  79         &quot;w&quot; + number
  80     when :ptr
  81         prefix = $currentSettings[&quot;ADDRESS64&quot;] ? &quot;x&quot; : &quot;w&quot;
  82         prefix + number
  83     when :quad
  84         &quot;x&quot; + number
  85     else
  86         raise &quot;Wrong kind: #{kind}&quot;
  87     end
  88 end
  89 
  90 def arm64FPRName(name, kind)
  91     raise &quot;bad FPR kind #{kind}&quot; unless kind == :double
  92     raise &quot;bad FPR name #{name}&quot; unless name =~ /^q/
  93     &quot;d&quot; + name[1..-1]
  94 end
  95 
  96 class SpecialRegister
  97     def arm64Operand(kind)
  98         case @name
  99         when /^x/
 100             arm64GPRName(@name, kind)
 101         when /^q/
 102             arm64FPRName(@name, kind)
 103         else
 104             raise &quot;Bad name: #{@name}&quot;
 105         end
 106     end
 107 end
 108 
 109 ARM64_EXTRA_GPRS = [SpecialRegister.new(&quot;x16&quot;), SpecialRegister.new(&quot;x17&quot;), SpecialRegister.new(&quot;x13&quot;)]
 110 ARM64_EXTRA_FPRS = [SpecialRegister.new(&quot;q31&quot;)]
 111 
 112 class RegisterID
 113     def arm64Operand(kind)
 114         case @name
 115         when &#39;t0&#39;, &#39;a0&#39;, &#39;r0&#39;
 116             arm64GPRName(&#39;x0&#39;, kind)
 117         when &#39;t1&#39;, &#39;a1&#39;, &#39;r1&#39;
 118             arm64GPRName(&#39;x1&#39;, kind)
 119         when &#39;t2&#39;, &#39;a2&#39;
 120             arm64GPRName(&#39;x2&#39;, kind)
 121         when &#39;t3&#39;, &#39;a3&#39;
 122             arm64GPRName(&#39;x3&#39;, kind)
 123         when &#39;t4&#39;
 124             arm64GPRName(&#39;x4&#39;, kind)
 125         when &#39;t5&#39;
<a name="2" id="anc2"></a><span class="line-modified"> 126             arm64GPRName(&#39;x5&#39;, kind)</span>




 127         when &#39;cfr&#39;
 128             arm64GPRName(&#39;x29&#39;, kind)
 129         when &#39;csr0&#39;
 130             arm64GPRName(&#39;x19&#39;, kind)
 131         when &#39;csr1&#39;
 132             arm64GPRName(&#39;x20&#39;, kind)
 133         when &#39;csr2&#39;
 134             arm64GPRName(&#39;x21&#39;, kind)
 135         when &#39;csr3&#39;
 136             arm64GPRName(&#39;x22&#39;, kind)
 137         when &#39;csr4&#39;
 138             arm64GPRName(&#39;x23&#39;, kind)
 139         when &#39;csr5&#39;
 140             arm64GPRName(&#39;x24&#39;, kind)
 141         when &#39;csr6&#39;
 142             arm64GPRName(&#39;x25&#39;, kind)
 143         when &#39;csr7&#39;
 144             arm64GPRName(&#39;x26&#39;, kind)
 145         when &#39;csr8&#39;
 146             arm64GPRName(&#39;x27&#39;, kind)
 147         when &#39;csr9&#39;
 148             arm64GPRName(&#39;x28&#39;, kind)
 149         when &#39;sp&#39;
 150             &#39;sp&#39;
 151         when &#39;lr&#39;
 152             &#39;x30&#39;
 153         else
 154             raise &quot;Bad register name #{@name} at #{codeOriginString}&quot;
 155         end
 156     end
 157 end
 158 
 159 class FPRegisterID
 160     def arm64Operand(kind)
 161         case @name
 162         when &#39;ft0&#39;, &#39;fr&#39;, &#39;fa0&#39;
 163             arm64FPRName(&#39;q0&#39;, kind)
 164         when &#39;ft1&#39;, &#39;fa1&#39;
 165             arm64FPRName(&#39;q1&#39;, kind)
 166         when &#39;ft2&#39;, &#39;fa2&#39;
 167             arm64FPRName(&#39;q2&#39;, kind)
 168         when &#39;ft3&#39;, &#39;fa3&#39;
 169             arm64FPRName(&#39;q3&#39;, kind)
 170         when &#39;ft4&#39;
 171             arm64FPRName(&#39;q4&#39;, kind)
 172         when &#39;ft5&#39;
 173             arm64FPRName(&#39;q5&#39;, kind)
 174         when &#39;csfr0&#39;
 175             arm64FPRName(&#39;q8&#39;, kind)
 176         when &#39;csfr1&#39;
 177             arm64FPRName(&#39;q9&#39;, kind)
 178         when &#39;csfr2&#39;
 179             arm64FPRName(&#39;q10&#39;, kind)
 180         when &#39;csfr3&#39;
 181             arm64FPRName(&#39;q11&#39;, kind)
 182         when &#39;csfr4&#39;
 183             arm64FPRName(&#39;q12&#39;, kind)
 184         when &#39;csfr5&#39;
 185             arm64FPRName(&#39;q13&#39;, kind)
 186         when &#39;csfr6&#39;
 187             arm64FPRName(&#39;q14&#39;, kind)
 188         when &#39;csfr7&#39;
 189             arm64FPRName(&#39;q15&#39;, kind)
 190         else &quot;Bad register name #{@name} at #{codeOriginString}&quot;
 191         end
 192     end
 193 end
 194 
 195 class Immediate
 196     def arm64Operand(kind)
 197         raise &quot;Invalid immediate #{value} at #{codeOriginString}&quot; if value &lt; 0 or value &gt; 4095
 198         &quot;\##{value}&quot;
 199     end
 200 end
 201 
 202 class Address
 203     def arm64Operand(kind)
 204         raise &quot;Invalid offset #{offset.value} at #{codeOriginString}&quot; if offset.value &lt; -255 or offset.value &gt; 4095
 205         &quot;[#{base.arm64Operand(:quad)}, \##{offset.value}]&quot;
 206     end
 207     
 208     def arm64EmitLea(destination, kind)
 209         $asm.puts &quot;add #{destination.arm64Operand(kind)}, #{base.arm64Operand(kind)}, \##{offset.value}&quot;
 210     end
 211 end
 212 
 213 class BaseIndex
 214     def arm64Operand(kind)
 215         raise &quot;Invalid offset #{offset.value} at #{codeOriginString}&quot; if offset.value != 0
 216         &quot;[#{base.arm64Operand(:quad)}, #{index.arm64Operand(:quad)}, lsl \##{scaleShift}]&quot;
 217     end
 218 
 219     def arm64EmitLea(destination, kind)
 220         $asm.puts &quot;add #{destination.arm64Operand(kind)}, #{base.arm64Operand(kind)}, #{index.arm64Operand(kind)}, lsl \##{scaleShift}&quot;
 221     end
 222 end
 223 
 224 class AbsoluteAddress
 225     def arm64Operand(kind)
 226         raise &quot;Unconverted absolute address #{address.value} at #{codeOriginString}&quot;
 227     end
 228 end
 229 
 230 # FIXME: We could support AbsoluteAddress for lea, but we don&#39;t.
 231 
 232 #
 233 # Actual lowering code follows.
 234 #
 235 
 236 def arm64LowerMalformedLoadStoreAddresses(list)
 237     newList = []
 238 
 239     def isAddressMalformed(opcode, operand)
 240         malformed = false
 241         if operand.is_a? Address
 242             malformed ||= (not (-255..4095).include? operand.offset.value)
 243             if opcode =~ /q$/ and $currentSettings[&quot;ADDRESS64&quot;]
 244                 malformed ||= operand.offset.value % 8
 245             end
 246         end
 247         malformed
 248     end
 249 
 250     list.each {
 251         | node |
 252         if node.is_a? Instruction
 253             if node.opcode =~ /^store/ and isAddressMalformed(node.opcode, node.operands[1])
 254                 address = node.operands[1]
 255                 tmp = Tmp.new(codeOrigin, :gpr)
 256                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [address.offset, tmp])
 257                 newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [node.operands[0], BaseIndex.new(node.codeOrigin, address.base, tmp, Immediate.new(codeOrigin, 1), Immediate.new(codeOrigin, 0))], node.annotation)
 258             elsif node.opcode =~ /^load/ and isAddressMalformed(node.opcode, node.operands[0])
 259                 address = node.operands[0]
 260                 tmp = Tmp.new(codeOrigin, :gpr)
 261                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [address.offset, tmp])
 262                 newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [BaseIndex.new(node.codeOrigin, address.base, tmp, Immediate.new(codeOrigin, 1), Immediate.new(codeOrigin, 0)), node.operands[1]], node.annotation)
 263             else
 264                 newList &lt;&lt; node
 265             end
 266         else
 267             newList &lt;&lt; node
 268         end
 269     }
 270     newList
 271 end
 272 
 273 def arm64LowerLabelReferences(list)
 274     newList = []
 275     list.each {
 276         | node |
 277         if node.is_a? Instruction
 278             case node.opcode
<a name="3" id="anc3"></a><span class="line-modified"> 279             when &quot;loadi&quot;, &quot;loadis&quot;, &quot;loadp&quot;, &quot;loadq&quot;, &quot;loadb&quot;, &quot;loadbs&quot;, &quot;loadh&quot;, &quot;loadhs&quot;, &quot;leap&quot;</span>
 280                 labelRef = node.operands[0]
 281                 if labelRef.is_a? LabelReference
 282                     tmp = Tmp.new(node.codeOrigin, :gpr)
 283                     newList &lt;&lt; Instruction.new(codeOrigin, &quot;globaladdr&quot;, [LabelReference.new(node.codeOrigin, labelRef.label), tmp])
 284                     newList &lt;&lt; Instruction.new(codeOrigin, node.opcode, [Address.new(node.codeOrigin, tmp, Immediate.new(node.codeOrigin, labelRef.offset)), node.operands[1]])
 285                 else
 286                     newList &lt;&lt; node
 287                 end
 288             else
 289                 newList &lt;&lt; node
 290             end
 291         else
 292             newList &lt;&lt; node
 293         end
 294     }
 295     newList
 296 end
 297 
 298 def arm64FixSpecialRegisterArithmeticMode(list)
 299     newList = []
 300     def usesSpecialRegister(node)
 301         node.children.any? {
 302             |operand|
 303             if operand.is_a? RegisterID and operand.name =~ /sp/
 304                 true
 305             elsif operand.is_a? Address or operand.is_a? BaseIndex
 306                 usesSpecialRegister(operand)
 307             else
 308                 false
 309             end
 310         }
 311     end
 312 
 313 
 314     list.each {
 315         | node |
 316         if node.is_a? Instruction
 317             case node.opcode
 318             when &quot;addp&quot;, &quot;subp&quot;, &quot;mulp&quot;, &quot;divp&quot;, &quot;leap&quot;
 319                 if not $currentSettings[&quot;ADDRESS64&quot;] and usesSpecialRegister(node)
 320                     newOpcode = node.opcode.sub(/(.*)p/, &#39;\1q&#39;)
 321                     node = Instruction.new(node.codeOrigin, newOpcode, node.operands, node.annotation)
 322                 end
 323             when /^bp/
 324                 if not $currentSettings[&quot;ADDRESS64&quot;] and usesSpecialRegister(node)
 325                     newOpcode = node.opcode.sub(/^bp(.*)/, &#39;bq\1&#39;)
 326                     node = Instruction.new(node.codeOrigin, newOpcode, node.operands, node.annotation)
 327                 end
 328             end
 329         end
 330         newList &lt;&lt; node
 331     }
 332     newList
 333 end
 334 
 335 # Workaround for Cortex-A53 erratum (835769)
 336 def arm64CortexA53Fix835769(list)
 337     newList = []
 338     lastOpcodeUnsafe = false
 339 
 340     list.each {
 341         | node |
 342         if node.is_a? Instruction
 343             case node.opcode
 344             when /^store/, /^load/
 345                 # List all macro instructions that can be lowered to a load, store or prefetch ARM64 assembly instruction
 346                 lastOpcodeUnsafe = true
 347             when  &quot;muli&quot;, &quot;mulp&quot;, &quot;mulq&quot;, &quot;smulli&quot;
 348                 # List all macro instructions that can be lowered to a 64-bit multiply-accumulate ARM64 assembly instruction
 349                 # (defined as one of MADD, MSUB, SMADDL, SMSUBL, UMADDL or UMSUBL).
 350                 if lastOpcodeUnsafe
 351                     newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;nopCortexA53Fix835769&quot;, [])
 352                 end
 353                 lastOpcodeUnsafe = false
 354             else
 355                 lastOpcodeUnsafe = false
 356             end
 357         end
 358         newList &lt;&lt; node
 359     }
 360     newList
 361 end
 362 
 363 class Sequence
<a name="4" id="anc4"></a><span class="line-modified"> 364     def getModifiedListARM64</span>
<span class="line-removed"> 365         result = @list</span>
 366         result = riscLowerNot(result)
 367         result = riscLowerSimpleBranchOps(result)
 368 
 369         result = $currentSettings[&quot;ADDRESS64&quot;] ? riscLowerHardBranchOps64(result) : riscLowerHardBranchOps(result)
 370         result = riscLowerShiftOps(result)
 371         result = arm64LowerMalformedLoadStoreAddresses(result)
 372         result = arm64LowerLabelReferences(result)
 373         result = riscLowerMalformedAddresses(result) {
 374             | node, address |
 375             case node.opcode
<a name="5" id="anc5"></a><span class="line-modified"> 376             when &quot;loadb&quot;, &quot;loadbs&quot;, &quot;loadbsp&quot;, &quot;storeb&quot;, /^bb/, /^btb/, /^cb/, /^tb/</span>
 377                 size = 1
<a name="6" id="anc6"></a><span class="line-modified"> 378             when &quot;loadh&quot;, &quot;loadhs&quot;</span>
 379                 size = 2
 380             when &quot;loadi&quot;, &quot;loadis&quot;, &quot;storei&quot;, &quot;addi&quot;, &quot;andi&quot;, &quot;lshifti&quot;, &quot;muli&quot;, &quot;negi&quot;,
 381                 &quot;noti&quot;, &quot;ori&quot;, &quot;rshifti&quot;, &quot;urshifti&quot;, &quot;subi&quot;, &quot;xori&quot;, /^bi/, /^bti/,
 382                 /^ci/, /^ti/, &quot;addis&quot;, &quot;subis&quot;, &quot;mulis&quot;, &quot;smulli&quot;, &quot;leai&quot;
 383                 size = 4
 384             when &quot;loadp&quot;, &quot;storep&quot;, &quot;loadq&quot;, &quot;storeq&quot;, &quot;loadd&quot;, &quot;stored&quot;, &quot;lshiftp&quot;, &quot;lshiftq&quot;, &quot;negp&quot;, &quot;negq&quot;, &quot;rshiftp&quot;, &quot;rshiftq&quot;,
 385                 &quot;urshiftp&quot;, &quot;urshiftq&quot;, &quot;addp&quot;, &quot;addq&quot;, &quot;mulp&quot;, &quot;mulq&quot;, &quot;andp&quot;, &quot;andq&quot;, &quot;orp&quot;, &quot;orq&quot;, &quot;subp&quot;, &quot;subq&quot;, &quot;xorp&quot;, &quot;xorq&quot;, &quot;addd&quot;,
 386                 &quot;divd&quot;, &quot;subd&quot;, &quot;muld&quot;, &quot;sqrtd&quot;, /^bp/, /^bq/, /^btp/, /^btq/, /^cp/, /^cq/, /^tp/, /^tq/, /^bd/,
 387                 &quot;jmp&quot;, &quot;call&quot;, &quot;leap&quot;, &quot;leaq&quot;
 388                 size = $currentSettings[&quot;ADDRESS64&quot;] ? 8 : 4
 389             else
<a name="7" id="anc7"></a><span class="line-modified"> 390                 raise &quot;Bad instruction #{node.opcode} for heap access at #{node.codeOriginString}&quot;</span>
 391             end
 392             
 393             if address.is_a? BaseIndex
 394                 address.offset.value == 0 and
 395                     (node.opcode =~ /^lea/ or address.scale == 1 or address.scale == size)
 396             elsif address.is_a? Address
 397                 (-255..4095).include? address.offset.value
 398             else
 399                 false
 400             end
 401         }
 402         result = riscLowerMisplacedImmediates(result, [&quot;storeb&quot;, &quot;storei&quot;, &quot;storep&quot;, &quot;storeq&quot;])
 403         result = riscLowerMalformedImmediates(result, 0..4095)
 404         result = riscLowerMisplacedAddresses(result)
 405         result = riscLowerMalformedAddresses(result) {
 406             | node, address |
 407             case node.opcode
 408             when /^load/
 409                 true
 410             when /^store/
 411                 not (address.is_a? Address and address.offset.value &lt; 0)
 412             when /^lea/
 413                 true
 414             else
 415                 raise &quot;Bad instruction #{node.opcode} for heap access at #{node.codeOriginString}&quot;
 416             end
 417         }
 418         result = riscLowerTest(result)
 419         result = arm64FixSpecialRegisterArithmeticMode(result)
 420         result = assignRegistersToTemporaries(result, :gpr, ARM64_EXTRA_GPRS)
 421         result = assignRegistersToTemporaries(result, :fpr, ARM64_EXTRA_FPRS)
 422         result = arm64CortexA53Fix835769(result)
 423         return result
 424     end
 425 end
 426 
 427 def arm64Operands(operands, kinds)
 428     if kinds.is_a? Array
 429         raise &quot;Mismatched operand lists: #{operands.inspect} and #{kinds.inspect}&quot; if operands.size != kinds.size
 430     else
 431         kinds = operands.map{ kinds }
 432     end
 433     (0...operands.size).map {
 434         | index |
 435         operands[index].arm64Operand(kinds[index])
 436     }.join(&#39;, &#39;)
 437 end
 438 
 439 def arm64FlippedOperands(operands, kinds)
 440     if kinds.is_a? Array
 441         kinds = [kinds[-1]] + kinds[0..-2]
 442     end
 443     arm64Operands([operands[-1]] + operands[0..-2], kinds)
 444 end
 445 
 446 # TAC = three address code.
 447 def arm64TACOperands(operands, kind)
 448     if operands.size == 3
 449         return arm64FlippedOperands(operands, kind)
 450     end
 451     
 452     raise unless operands.size == 2
 453     
 454     return operands[1].arm64Operand(kind) + &quot;, &quot; + arm64FlippedOperands(operands, kind)
 455 end
 456 
 457 def emitARM64Add(opcode, operands, kind)
 458     if operands.size == 3
 459         raise unless operands[1].register?
 460         raise unless operands[2].register?
 461         
 462         if operands[0].immediate?
 463             if operands[0].value == 0 and opcode !~ /s$/
 464                 if operands[1] != operands[2]
 465                     $asm.puts &quot;mov #{arm64FlippedOperands(operands[1..2], kind)}&quot;
 466                 end
 467             else
 468                 $asm.puts &quot;#{opcode} #{arm64Operands(operands.reverse, kind)}&quot;
 469             end
 470             return
 471         end
 472         
 473         raise unless operands[0].register?
 474         $asm.puts &quot;#{opcode} #{arm64FlippedOperands(operands, kind)}&quot;
 475         return
 476     end
 477     
 478     raise unless operands.size == 2
 479     
 480     if operands[0].immediate? and operands[0].value == 0 and opcode !~ /s$/
 481         return
 482     end
 483     
 484     $asm.puts &quot;#{opcode} #{arm64TACOperands(operands, kind)}&quot;
 485 end
 486 
 487 def emitARM64Mul(opcode, operands, kind)
 488     if operands.size == 2 and operands[0].is_a? Immediate
 489         imm = operands[0].value
 490         if imm &gt; 0 and isPowerOfTwo(imm)
 491             emitARM64LShift([Immediate.new(nil, Math.log2(imm).to_i), operands[1]], kind)
 492             return
 493         end
 494     end
 495 
 496     $asm.puts &quot;madd #{arm64TACOperands(operands, kind)}, #{arm64GPRName(&#39;xzr&#39;, kind)}&quot;
 497 end
 498 
 499 def emitARM64Sub(opcode, operands, kind)
 500     if operands.size == 3
 501         raise unless operands[0].register?
 502         raise unless operands[2].register?
 503 
 504         if operands[1].immediate?
 505             if operands[1].value == 0 and opcode !~ /s$/
 506                 if operands[0] != operands[2]
 507                     $asm.puts &quot;mov #{arm64FlippedOperands([operands[0], operands[2]], kind)}&quot;
 508                 end
 509                 return
 510             end
 511         end
 512     end
 513 
 514     if operands.size == 2
 515         if operands[0].immediate? and operands[0].value == 0 and opcode !~ /s$/
 516             return
 517         end
 518     end
 519 
 520     emitARM64TAC(opcode, operands, kind)
 521 end
 522 
 523 def emitARM64Unflipped(opcode, operands, kind)
 524     $asm.puts &quot;#{opcode} #{arm64Operands(operands, kind)}&quot;
 525 end
 526 
 527 def emitARM64TAC(opcode, operands, kind)
 528     $asm.puts &quot;#{opcode} #{arm64TACOperands(operands, kind)}&quot;
 529 end
 530 
 531 def emitARM64(opcode, operands, kind)
 532     $asm.puts &quot;#{opcode} #{arm64FlippedOperands(operands, kind)}&quot;
 533 end
 534 
 535 def emitARM64Access(opcode, opcodeNegativeOffset, register, memory, kind)
 536     if memory.is_a? Address and memory.offset.value &lt; 0
 537         raise unless -256 &lt;= memory.offset.value
 538         $asm.puts &quot;#{opcodeNegativeOffset} #{register.arm64Operand(kind)}, #{memory.arm64Operand(kind)}&quot;
 539         return
 540     end
 541 
 542     $asm.puts &quot;#{opcode} #{register.arm64Operand(kind)}, #{memory.arm64Operand(kind)}&quot;
 543 end
 544 
 545 def emitARM64Shift(opcodeRegs, opcodeImmediate, operands, kind)
 546     if operands.size == 3 and operands[1].immediate?
 547         magicNumbers = yield operands[1].value
 548         $asm.puts &quot;#{opcodeImmediate} #{operands[2].arm64Operand(kind)}, #{operands[0].arm64Operand(kind)}, \##{magicNumbers[0]}, \##{magicNumbers[1]}&quot;
 549         return
 550     end
 551     
 552     if operands.size == 2 and operands[0].immediate?
 553         magicNumbers = yield operands[0].value
 554         $asm.puts &quot;#{opcodeImmediate} #{operands[1].arm64Operand(kind)}, #{operands[1].arm64Operand(kind)}, \##{magicNumbers[0]}, \##{magicNumbers[1]}&quot;
 555         return
 556     end
 557     
 558     emitARM64TAC(opcodeRegs, operands, kind)
 559 end
 560 
 561 def emitARM64LShift(operands, kind)
 562     emitARM64Shift(&quot;lslv&quot;, &quot;ubfm&quot;, operands, kind) {
 563         | value |
 564         case kind
 565         when :word
 566             [32 - value, 31 - value]
 567         when :ptr
 568             bitSize = $currentSettings[&quot;ADDRESS64&quot;] ? 64 : 32
 569             [bitSize - value, bitSize - 1 - value]
 570         when :quad
 571             [64 - value, 63 - value]
 572         end
 573     }
 574 end
 575 
 576 def emitARM64Branch(opcode, operands, kind, branchOpcode)
 577     emitARM64Unflipped(opcode, operands[0..-2], kind)
 578     $asm.puts &quot;#{branchOpcode} #{operands[-1].asmLabel}&quot;
 579 end
 580 
 581 def emitARM64Compare(operands, kind, compareCode)
 582     emitARM64Unflipped(&quot;subs #{arm64GPRName(&#39;xzr&#39;, kind)}, &quot;, operands[0..-2], kind)
 583     $asm.puts &quot;csinc #{operands[-1].arm64Operand(:word)}, wzr, wzr, #{compareCode}&quot;
 584 end
 585 
 586 def emitARM64MoveImmediate(value, target)
 587     first = true
 588     isNegative = value &lt; 0
 589     [48, 32, 16, 0].each {
 590         | shift |
 591         currentValue = (value &gt;&gt; shift) &amp; 0xffff
 592         next if currentValue == (isNegative ? 0xffff : 0) and (shift != 0 or !first)
 593         if first
 594             if isNegative
 595                 $asm.puts &quot;movn #{target.arm64Operand(:quad)}, \##{(~currentValue) &amp; 0xffff}, lsl \##{shift}&quot;
 596             else
 597                 $asm.puts &quot;movz #{target.arm64Operand(:quad)}, \##{currentValue}, lsl \##{shift}&quot;
 598             end
 599             first = false
 600         else
 601             $asm.puts &quot;movk #{target.arm64Operand(:quad)}, \##{currentValue}, lsl \##{shift}&quot;
 602         end
 603     }
 604 end
 605 
 606 class Instruction
 607     def lowerARM64
 608         case opcode
 609         when &#39;addi&#39;
 610             emitARM64Add(&quot;add&quot;, operands, :word)
 611         when &#39;addis&#39;
 612             emitARM64Add(&quot;adds&quot;, operands, :word)
 613         when &#39;addp&#39;
 614             emitARM64Add(&quot;add&quot;, operands, :ptr)
 615         when &#39;addps&#39;
 616             emitARM64Add(&quot;adds&quot;, operands, :ptr)
 617         when &#39;addq&#39;
 618             emitARM64Add(&quot;add&quot;, operands, :quad)
 619         when &quot;andi&quot;
 620             emitARM64TAC(&quot;and&quot;, operands, :word)
 621         when &quot;andp&quot;
 622             emitARM64TAC(&quot;and&quot;, operands, :ptr)
 623         when &quot;andq&quot;
 624             emitARM64TAC(&quot;and&quot;, operands, :quad)
 625         when &quot;ori&quot;
 626             emitARM64TAC(&quot;orr&quot;, operands, :word)
 627         when &quot;orp&quot;
 628             emitARM64TAC(&quot;orr&quot;, operands, :ptr)
 629         when &quot;orq&quot;
 630             emitARM64TAC(&quot;orr&quot;, operands, :quad)
 631         when &quot;xori&quot;
 632             emitARM64TAC(&quot;eor&quot;, operands, :word)
 633         when &quot;xorp&quot;
 634             emitARM64TAC(&quot;eor&quot;, operands, :ptr)
 635         when &quot;xorq&quot;
 636             emitARM64TAC(&quot;eor&quot;, operands, :quad)
 637         when &quot;lshifti&quot;
 638             emitARM64LShift(operands, :word)
 639         when &quot;lshiftp&quot;
 640             emitARM64LShift(operands, :ptr)
 641         when &quot;lshiftq&quot;
 642             emitARM64LShift(operands, :quad)
 643         when &quot;rshifti&quot;
 644             emitARM64Shift(&quot;asrv&quot;, &quot;sbfm&quot;, operands, :word) {
 645                 | value |
 646                 [value, 31]
 647             }
 648         when &quot;rshiftp&quot;
 649             emitARM64Shift(&quot;asrv&quot;, &quot;sbfm&quot;, operands, :ptr) {
 650                 | value |
 651                 bitSize = $currentSettings[&quot;ADDRESS64&quot;] ? 64 : 32
 652                 [value, bitSize - 1]
 653             }
 654         when &quot;rshiftq&quot;
 655             emitARM64Shift(&quot;asrv&quot;, &quot;sbfm&quot;, operands, :quad) {
 656                 | value |
 657                 [value, 63]
 658             }
 659         when &quot;urshifti&quot;
 660             emitARM64Shift(&quot;lsrv&quot;, &quot;ubfm&quot;, operands, :word) {
 661                 | value |
 662                 [value, 31]
 663             }
 664         when &quot;urshiftp&quot;
 665             emitARM64Shift(&quot;lsrv&quot;, &quot;ubfm&quot;, operands, :ptr) {
 666                 | value |
 667                 bitSize = $currentSettings[&quot;ADDRESS64&quot;] ? 64 : 32
 668                 [value, bitSize - 1]
 669             }
 670         when &quot;urshiftq&quot;
 671             emitARM64Shift(&quot;lsrv&quot;, &quot;ubfm&quot;, operands, :quad) {
 672                 | value |
 673                 [value, 63]
 674             }
 675         when &quot;muli&quot;
 676             emitARM64Mul(&#39;mul&#39;, operands, :word)
 677         when &quot;mulp&quot;
 678             emitARM64Mul(&#39;mul&#39;, operands, :ptr)
 679         when &quot;mulq&quot;
 680             emitARM64Mul(&#39;mul&#39;, operands, :quad)
 681         when &quot;subi&quot;
 682             emitARM64Sub(&quot;sub&quot;, operands, :word)
 683         when &quot;subp&quot;
 684             emitARM64Sub(&quot;sub&quot;, operands, :ptr)
 685         when &quot;subq&quot;
 686             emitARM64Sub(&quot;sub&quot;, operands, :quad)
 687         when &quot;subis&quot;
 688             emitARM64Sub(&quot;subs&quot;, operands, :word)
 689         when &quot;negi&quot;
 690             $asm.puts &quot;sub #{operands[0].arm64Operand(:word)}, wzr, #{operands[0].arm64Operand(:word)}&quot;
 691         when &quot;negp&quot;
 692             $asm.puts &quot;sub #{operands[0].arm64Operand(:ptr)}, #{arm64GPRName(&#39;xzr&#39;, :ptr)}, #{operands[0].arm64Operand(:ptr)}&quot;
 693         when &quot;negq&quot;
 694             $asm.puts &quot;sub #{operands[0].arm64Operand(:quad)}, xzr, #{operands[0].arm64Operand(:quad)}&quot;
 695         when &quot;loadi&quot;
 696             emitARM64Access(&quot;ldr&quot;, &quot;ldur&quot;, operands[1], operands[0], :word)
 697         when &quot;loadis&quot;
 698             emitARM64Access(&quot;ldrsw&quot;, &quot;ldursw&quot;, operands[1], operands[0], :quad)
 699         when &quot;loadp&quot;
 700             emitARM64Access(&quot;ldr&quot;, &quot;ldur&quot;, operands[1], operands[0], :ptr)
 701         when &quot;loadq&quot;
 702             emitARM64Access(&quot;ldr&quot;, &quot;ldur&quot;, operands[1], operands[0], :quad)
 703         when &quot;storei&quot;
 704             emitARM64Unflipped(&quot;str&quot;, operands, :word)
 705         when &quot;storep&quot;
 706             emitARM64Unflipped(&quot;str&quot;, operands, :ptr)
 707         when &quot;storeq&quot;
 708             emitARM64Unflipped(&quot;str&quot;, operands, :quad)
 709         when &quot;loadb&quot;
 710             emitARM64Access(&quot;ldrb&quot;, &quot;ldurb&quot;, operands[1], operands[0], :word)
<a name="8" id="anc8"></a><span class="line-modified"> 711         when &quot;loadbs&quot;</span>
 712             emitARM64Access(&quot;ldrsb&quot;, &quot;ldursb&quot;, operands[1], operands[0], :word)
<a name="9" id="anc9"></a><span class="line-modified"> 713         when &quot;loadbsp&quot;</span>
<span class="line-modified"> 714             emitARM64Access(&quot;ldrsb&quot;, &quot;ldursb&quot;, operands[1], operands[0], :ptr)</span>
 715         when &quot;storeb&quot;
 716             emitARM64Unflipped(&quot;strb&quot;, operands, :word)
 717         when &quot;loadh&quot;
 718             emitARM64Access(&quot;ldrh&quot;, &quot;ldurh&quot;, operands[1], operands[0], :word)
<a name="10" id="anc10"></a><span class="line-modified"> 719         when &quot;loadhs&quot;</span>
 720             emitARM64Access(&quot;ldrsh&quot;, &quot;ldursh&quot;, operands[1], operands[0], :word)
<a name="11" id="anc11"></a>

 721         when &quot;storeh&quot;
 722             emitARM64Unflipped(&quot;strh&quot;, operands, :word)
 723         when &quot;loadd&quot;
 724             emitARM64Access(&quot;ldr&quot;, &quot;ldur&quot;, operands[1], operands[0], :double)
 725         when &quot;stored&quot;
 726             emitARM64Unflipped(&quot;str&quot;, operands, :double)
 727         when &quot;addd&quot;
 728             emitARM64TAC(&quot;fadd&quot;, operands, :double)
 729         when &quot;divd&quot;
 730             emitARM64TAC(&quot;fdiv&quot;, operands, :double)
 731         when &quot;subd&quot;
 732             emitARM64TAC(&quot;fsub&quot;, operands, :double)
 733         when &quot;muld&quot;
 734             emitARM64TAC(&quot;fmul&quot;, operands, :double)
 735         when &quot;sqrtd&quot;
 736             emitARM64(&quot;fsqrt&quot;, operands, :double)
 737         when &quot;ci2d&quot;
 738             emitARM64(&quot;scvtf&quot;, operands, [:word, :double])
 739         when &quot;bdeq&quot;
 740             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.eq&quot;)
 741         when &quot;bdneq&quot;
 742             emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :double)
 743             isUnordered = LocalLabel.unique(&quot;bdneq&quot;)
 744             $asm.puts &quot;b.vs #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
 745             $asm.puts &quot;b.ne #{operands[2].asmLabel}&quot;
 746             isUnordered.lower(&quot;ARM64&quot;)
 747         when &quot;bdgt&quot;
 748             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.gt&quot;)
 749         when &quot;bdgteq&quot;
 750             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.ge&quot;)
 751         when &quot;bdlt&quot;
 752             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.mi&quot;)
 753         when &quot;bdlteq&quot;
 754             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.ls&quot;)
 755         when &quot;bdequn&quot;
 756             emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :double)
 757             $asm.puts &quot;b.vs #{operands[2].asmLabel}&quot;
 758             $asm.puts &quot;b.eq #{operands[2].asmLabel}&quot;
 759         when &quot;bdnequn&quot;
 760             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.ne&quot;)
 761         when &quot;bdgtun&quot;
 762             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.hi&quot;)
 763         when &quot;bdgtequn&quot;
 764             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.pl&quot;)
 765         when &quot;bdltun&quot;
 766             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.lt&quot;)
 767         when &quot;bdltequn&quot;
 768             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.le&quot;)
 769         when &quot;btd2i&quot;
 770             # FIXME: May be a good idea to just get rid of this instruction, since the interpreter
 771             # currently does not use it.
 772             raise &quot;ARM64 does not support this opcode yet, #{codeOriginString}&quot;
 773         when &quot;td2i&quot;
 774             emitARM64(&quot;fcvtzs&quot;, operands, [:double, :word])
 775         when &quot;bcd2i&quot;
 776             # FIXME: Remove this instruction, or use it and implement it. Currently it&#39;s not
 777             # used.
 778             raise &quot;ARM64 does not support this opcode yet, #{codeOriginString}&quot;
 779         when &quot;movdz&quot;
 780             # FIXME: Remove it or support it.
 781             raise &quot;ARM64 does not support this opcode yet, #{codeOriginString}&quot;
 782         when &quot;pop&quot;
 783             operands.each_slice(2) {
 784                 | ops |
 785                 # Note that the operands are in the reverse order of the case for push.
 786                 # This is due to the fact that order matters for pushing and popping, and 
 787                 # on platforms that only push/pop one slot at a time they pop their 
 788                 # arguments in the reverse order that they were pushed. In order to remain 
 789                 # compatible with those platforms we assume here that that&#39;s what has been done.
 790 
 791                 # So for example, if we did push(A, B, C, D), we would then pop(D, C, B, A).
 792                 # But since the ordering of arguments doesn&#39;t change on arm64 between the stp and ldp 
 793                 # instructions we need to flip flop the argument positions that were passed to us.
 794                 $asm.puts &quot;ldp #{ops[1].arm64Operand(:quad)}, #{ops[0].arm64Operand(:quad)}, [sp], #16&quot;
 795             }
 796         when &quot;push&quot;
 797             operands.each_slice(2) {
 798                 | ops |
 799                 $asm.puts &quot;stp #{ops[0].arm64Operand(:quad)}, #{ops[1].arm64Operand(:quad)}, [sp, #-16]!&quot;
 800             }
 801         when &quot;move&quot;
 802             if operands[0].immediate?
 803                 emitARM64MoveImmediate(operands[0].value, operands[1])
 804             else
 805                 emitARM64(&quot;mov&quot;, operands, :quad)
 806             end
 807         when &quot;sxi2p&quot;
 808             emitARM64(&quot;sxtw&quot;, operands, [:word, :ptr])
 809         when &quot;sxi2q&quot;
 810             emitARM64(&quot;sxtw&quot;, operands, [:word, :quad])
 811         when &quot;zxi2p&quot;
 812             emitARM64(&quot;uxtw&quot;, operands, [:word, :ptr])
 813         when &quot;zxi2q&quot;
 814             emitARM64(&quot;uxtw&quot;, operands, [:word, :quad])
 815         when &quot;nop&quot;
 816             $asm.puts &quot;nop&quot;
 817         when &quot;bieq&quot;, &quot;bbeq&quot;
 818             if operands[0].immediate? and operands[0].value == 0
 819                 $asm.puts &quot;cbz #{operands[1].arm64Operand(:word)}, #{operands[2].asmLabel}&quot;
 820             elsif operands[1].immediate? and operands[1].value == 0
 821                 $asm.puts &quot;cbz #{operands[0].arm64Operand(:word)}, #{operands[2].asmLabel}&quot;
 822             else
 823                 emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.eq&quot;)
 824             end
 825         when &quot;bpeq&quot;
 826             if operands[0].immediate? and operands[0].value == 0
 827                 $asm.puts &quot;cbz #{operands[1].arm64Operand(:ptr)}, #{operands[2].asmLabel}&quot;
 828             elsif operands[1].immediate? and operands[1].value == 0
 829                 $asm.puts &quot;cbz #{operands[0].arm64Operand(:ptr)}, #{operands[2].asmLabel}&quot;
 830             else
 831                 emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.eq&quot;)
 832             end
 833         when &quot;bqeq&quot;
 834             if operands[0].immediate? and operands[0].value == 0
 835                 $asm.puts &quot;cbz #{operands[1].arm64Operand(:quad)}, #{operands[2].asmLabel}&quot;
 836             elsif operands[1].immediate? and operands[1].value == 0
 837                 $asm.puts &quot;cbz #{operands[0].arm64Operand(:quad)}, #{operands[2].asmLabel}&quot;
 838             else
 839                 emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.eq&quot;)
 840             end
 841         when &quot;bineq&quot;, &quot;bbneq&quot;
 842             if operands[0].immediate? and operands[0].value == 0
 843                 $asm.puts &quot;cbnz #{operands[1].arm64Operand(:word)}, #{operands[2].asmLabel}&quot;
 844             elsif operands[1].immediate? and operands[1].value == 0
 845                 $asm.puts &quot;cbnz #{operands[0].arm64Operand(:word)}, #{operands[2].asmLabel}&quot;
 846             else
 847                 emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.ne&quot;)
 848             end
 849         when &quot;bpneq&quot;
 850             if operands[0].immediate? and operands[0].value == 0
 851                 $asm.puts &quot;cbnz #{operands[1].arm64Operand(:ptr)}, #{operands[2].asmLabel}&quot;
 852             elsif operands[1].immediate? and operands[1].value == 0
 853                 $asm.puts &quot;cbnz #{operands[0].arm64Operand(:ptr)}, #{operands[2].asmLabel}&quot;
 854             else
 855                 emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.ne&quot;)
 856             end
 857         when &quot;bqneq&quot;
 858             if operands[0].immediate? and operands[0].value == 0
 859                 $asm.puts &quot;cbnz #{operands[1].arm64Operand(:quad)}, #{operands[2].asmLabel}&quot;
 860             elsif operands[1].immediate? and operands[1].value == 0
 861                 $asm.puts &quot;cbnz #{operands[0].arm64Operand(:quad)}, #{operands[2].asmLabel}&quot;
 862             else
 863                 emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.ne&quot;)
 864             end
 865         when &quot;bia&quot;, &quot;bba&quot;
 866             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.hi&quot;)
 867         when &quot;bpa&quot;
 868             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.hi&quot;)
 869         when &quot;bqa&quot;
 870             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.hi&quot;)
 871         when &quot;biaeq&quot;, &quot;bbaeq&quot;
 872             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.hs&quot;)
 873         when &quot;bpaeq&quot;
 874             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.hs&quot;)
 875         when &quot;bqaeq&quot;
 876             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.hs&quot;)
 877         when &quot;bib&quot;, &quot;bbb&quot;
 878             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.lo&quot;)
 879         when &quot;bpb&quot;
 880             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.lo&quot;)
 881         when &quot;bqb&quot;
 882             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.lo&quot;)
 883         when &quot;bibeq&quot;, &quot;bbbeq&quot;
 884             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.ls&quot;)
 885         when &quot;bpbeq&quot;
 886             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.ls&quot;)
 887         when &quot;bqbeq&quot;
 888             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.ls&quot;)
 889         when &quot;bigt&quot;, &quot;bbgt&quot;
 890             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.gt&quot;)
 891         when &quot;bpgt&quot;
 892             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.gt&quot;)
 893         when &quot;bqgt&quot;
 894             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.gt&quot;)
 895         when &quot;bigteq&quot;, &quot;bbgteq&quot;
 896             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.ge&quot;)
 897         when &quot;bpgteq&quot;
 898             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.ge&quot;)
 899         when &quot;bqgteq&quot;
 900             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.ge&quot;)
 901         when &quot;bilt&quot;, &quot;bblt&quot;
 902             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.lt&quot;)
 903         when &quot;bplt&quot;
 904             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.lt&quot;)
 905         when &quot;bqlt&quot;
 906             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.lt&quot;)
 907         when &quot;bilteq&quot;, &quot;bblteq&quot;
 908             emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.le&quot;)
 909         when &quot;bplteq&quot;
 910             emitARM64Branch(&quot;subs #{arm64GPRName(&#39;xzr&#39;, :ptr)}, &quot;, operands, :ptr, &quot;b.le&quot;)
 911         when &quot;bqlteq&quot;
 912             emitARM64Branch(&quot;subs xzr, &quot;, operands, :quad, &quot;b.le&quot;)
 913         when &quot;jmp&quot;
 914             if operands[0].label?
 915                 $asm.puts &quot;b #{operands[0].asmLabel}&quot;
 916             else
 917                 emitARM64Unflipped(&quot;br&quot;, operands, :quad)
 918             end
 919         when &quot;call&quot;
 920             if operands[0].label?
 921                 $asm.puts &quot;bl #{operands[0].asmLabel}&quot;
 922             else
 923                 emitARM64Unflipped(&quot;blr&quot;, operands, :quad)
 924             end
 925         when &quot;break&quot;
 926             $asm.puts &quot;brk \#0&quot;
 927         when &quot;ret&quot;
 928             $asm.puts &quot;ret&quot;
 929         when &quot;cieq&quot;, &quot;cbeq&quot;
 930             emitARM64Compare(operands, :word, &quot;ne&quot;)
 931         when &quot;cpeq&quot;
 932             emitARM64Compare(operands, :ptr, &quot;ne&quot;)
 933         when &quot;cqeq&quot;
 934             emitARM64Compare(operands, :quad, &quot;ne&quot;)
 935         when &quot;cineq&quot;, &quot;cbneq&quot;
 936             emitARM64Compare(operands, :word, &quot;eq&quot;)
 937         when &quot;cpneq&quot;
 938             emitARM64Compare(operands, :ptr, &quot;eq&quot;)
 939         when &quot;cqneq&quot;
 940             emitARM64Compare(operands, :quad, &quot;eq&quot;)
 941         when &quot;cia&quot;, &quot;cba&quot;
 942             emitARM64Compare(operands, :word, &quot;ls&quot;)
 943         when &quot;cpa&quot;
 944             emitARM64Compare(operands, :ptr, &quot;ls&quot;)
 945         when &quot;cqa&quot;
 946             emitARM64Compare(operands, :quad, &quot;ls&quot;)
 947         when &quot;ciaeq&quot;, &quot;cbaeq&quot;
 948             emitARM64Compare(operands, :word, &quot;lo&quot;)
 949         when &quot;cpaeq&quot;
 950             emitARM64Compare(operands, :ptr, &quot;lo&quot;)
 951         when &quot;cqaeq&quot;
 952             emitARM64Compare(operands, :quad, &quot;lo&quot;)
 953         when &quot;cib&quot;, &quot;cbb&quot;
 954             emitARM64Compare(operands, :word, &quot;hs&quot;)
 955         when &quot;cpb&quot;
 956             emitARM64Compare(operands, :ptr, &quot;hs&quot;)
 957         when &quot;cqb&quot;
 958             emitARM64Compare(operands, :quad, &quot;hs&quot;)
 959         when &quot;cibeq&quot;, &quot;cbbeq&quot;
 960             emitARM64Compare(operands, :word, &quot;hi&quot;)
 961         when &quot;cpbeq&quot;
 962             emitARM64Compare(operands, :ptr, &quot;hi&quot;)
 963         when &quot;cqbeq&quot;
 964             emitARM64Compare(operands, :quad, &quot;hi&quot;)
 965         when &quot;cilt&quot;, &quot;cblt&quot;
 966             emitARM64Compare(operands, :word, &quot;ge&quot;)
 967         when &quot;cplt&quot;
 968             emitARM64Compare(operands, :ptr, &quot;ge&quot;)
 969         when &quot;cqlt&quot;
 970             emitARM64Compare(operands, :quad, &quot;ge&quot;)
 971         when &quot;cilteq&quot;, &quot;cblteq&quot;
 972             emitARM64Compare(operands, :word, &quot;gt&quot;)
 973         when &quot;cplteq&quot;
 974             emitARM64Compare(operands, :ptr, &quot;gt&quot;)
 975         when &quot;cqlteq&quot;
 976             emitARM64Compare(operands, :quad, &quot;gt&quot;)
 977         when &quot;cigt&quot;, &quot;cbgt&quot;
 978             emitARM64Compare(operands, :word, &quot;le&quot;)
 979         when &quot;cpgt&quot;
 980             emitARM64Compare(operands, :ptr, &quot;le&quot;)
 981         when &quot;cqgt&quot;
 982             emitARM64Compare(operands, :quad, &quot;le&quot;)
 983         when &quot;cigteq&quot;, &quot;cbgteq&quot;
 984             emitARM64Compare(operands, :word, &quot;lt&quot;)
 985         when &quot;cpgteq&quot;
 986             emitARM64Compare(operands, :ptr, &quot;lt&quot;)
 987         when &quot;cqgteq&quot;
 988             emitARM64Compare(operands, :quad, &quot;lt&quot;)
 989         when &quot;peek&quot;
 990             $asm.puts &quot;ldr #{operands[1].arm64Operand(:quad)}, [sp, \##{operands[0].value * 8}]&quot;
 991         when &quot;poke&quot;
 992             $asm.puts &quot;str #{operands[1].arm64Operand(:quad)}, [sp, \##{operands[0].value * 8}]&quot;
 993         when &quot;fp2d&quot;
 994             emitARM64(&quot;fmov&quot;, operands, [:ptr, :double])
 995         when &quot;fq2d&quot;
 996             emitARM64(&quot;fmov&quot;, operands, [:quad, :double])
 997         when &quot;fd2p&quot;
 998             emitARM64(&quot;fmov&quot;, operands, [:double, :ptr])
 999         when &quot;fd2q&quot;
1000             emitARM64(&quot;fmov&quot;, operands, [:double, :quad])
1001         when &quot;bo&quot;
1002             $asm.puts &quot;b.vs #{operands[0].asmLabel}&quot;
1003         when &quot;bs&quot;
1004             $asm.puts &quot;b.mi #{operands[0].asmLabel}&quot;
1005         when &quot;bz&quot;
1006             $asm.puts &quot;b.eq #{operands[0].asmLabel}&quot;
1007         when &quot;bnz&quot;
1008             $asm.puts &quot;b.ne #{operands[0].asmLabel}&quot;
1009         when &quot;leai&quot;
1010             operands[0].arm64EmitLea(operands[1], :word)
1011         when &quot;leap&quot;
1012             operands[0].arm64EmitLea(operands[1], :ptr)
1013         when &quot;leaq&quot;
1014             operands[0].arm64EmitLea(operands[1], :quad)
1015         when &quot;smulli&quot;
1016             $asm.puts &quot;smaddl #{operands[2].arm64Operand(:quad)}, #{operands[0].arm64Operand(:word)}, #{operands[1].arm64Operand(:word)}, xzr&quot;
1017         when &quot;memfence&quot;
1018             $asm.puts &quot;dmb sy&quot;
<a name="12" id="anc12"></a>

1019         when &quot;pcrtoaddr&quot;
1020             $asm.puts &quot;adr #{operands[1].arm64Operand(:quad)}, #{operands[0].value}&quot;
1021         when &quot;nopCortexA53Fix835769&quot;
1022             $asm.putStr(&quot;#if CPU(ARM64_CORTEXA53)&quot;)
1023             $asm.puts &quot;nop&quot;
1024             $asm.putStr(&quot;#endif&quot;)
1025         when &quot;globaladdr&quot;
1026             uid = $asm.newUID
1027 
1028             # On Darwin, use Macho-O GOT relocation specifiers, along with
1029             # the labels required for the .loh directive.
1030             $asm.putStr(&quot;#if OS(DARWIN)&quot;)
1031             $asm.puts &quot;L_offlineasm_loh_adrp_#{uid}:&quot;
1032             $asm.puts &quot;adrp #{operands[1].arm64Operand(:quad)}, #{operands[0].asmLabel}@GOTPAGE&quot;
1033             $asm.puts &quot;L_offlineasm_loh_ldr_#{uid}:&quot;
1034             $asm.puts &quot;ldr #{operands[1].arm64Operand(:quad)}, [#{operands[1].arm64Operand(:quad)}, #{operands[0].asmLabel}@GOTPAGEOFF]&quot;
1035 
1036             # On Linux, use ELF GOT relocation specifiers.
1037             $asm.putStr(&quot;#elif OS(LINUX)&quot;)
1038             $asm.puts &quot;adrp #{operands[1].arm64Operand(:quad)}, :got:#{operands[0].asmLabel}&quot;
1039             $asm.puts &quot;ldr #{operands[1].arm64Operand(:quad)}, [#{operands[1].arm64Operand(:quad)}, :got_lo12:#{operands[0].asmLabel}]&quot;
1040 
1041             # Throw a compiler error everywhere else.
1042             $asm.putStr(&quot;#else&quot;)
1043             $asm.putStr(&quot;#error Missing globaladdr implementation&quot;)
1044             $asm.putStr(&quot;#endif&quot;)
1045 
1046             $asm.deferAction {
1047                 # On Darwin, also include the .loh directive using the generated labels.
1048                 $asm.putStr(&quot;#if OS(DARWIN)&quot;)
1049                 $asm.puts &quot;.loh AdrpLdrGot L_offlineasm_loh_adrp_#{uid}, L_offlineasm_loh_ldr_#{uid}&quot;
1050                 $asm.putStr(&quot;#endif&quot;)
1051             }
1052         else
1053             lowerDefault
1054         end
1055     end
1056 end
1057 
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>