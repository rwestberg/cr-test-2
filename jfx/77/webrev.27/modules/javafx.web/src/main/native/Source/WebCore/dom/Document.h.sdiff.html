<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Document.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Document.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Document.idl.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Document.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   5  *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
<span class="line-modified">   6  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.</span>
   7  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   8  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
   9  * Copyright (C) 2011 Google Inc. All rights reserved.
  10  *
  11  * This library is free software; you can redistribute it and/or
  12  * modify it under the terms of the GNU Library General Public
  13  * License as published by the Free Software Foundation; either
  14  * version 2 of the License, or (at your option) any later version.
  15  *
  16  * This library is distributed in the hope that it will be useful,
  17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19  * Library General Public License for more details.
  20  *
  21  * You should have received a copy of the GNU Library General Public License
  22  * along with this library; see the file COPYING.LIB.  If not, write to
  23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24  * Boston, MA 02110-1301, USA.
  25  *
  26  */
  27 
  28 #pragma once
  29 
  30 #include &quot;CSSRegisteredCustomProperty.h&quot;
  31 #include &quot;Color.h&quot;
  32 #include &quot;ContainerNode.h&quot;
  33 #include &quot;DisabledAdaptations.h&quot;
  34 #include &quot;DocumentEventQueue.h&quot;
  35 #include &quot;DocumentIdentifier.h&quot;
  36 #include &quot;DocumentTiming.h&quot;

  37 #include &quot;FocusDirection.h&quot;
  38 #include &quot;FontSelectorClient.h&quot;
  39 #include &quot;FrameDestructionObserver.h&quot;
  40 #include &quot;GenericTaskQueue.h&quot;

  41 #include &quot;MediaProducer.h&quot;
  42 #include &quot;MutationObserver.h&quot;
  43 #include &quot;OrientationNotifier.h&quot;

  44 #include &quot;PlatformEvent.h&quot;
  45 #include &quot;ReferrerPolicy.h&quot;
  46 #include &quot;Region.h&quot;

  47 #include &quot;RenderPtr.h&quot;
  48 #include &quot;ScriptExecutionContext.h&quot;
  49 #include &quot;SecurityPolicyViolationEvent.h&quot;
  50 #include &quot;StringWithDirection.h&quot;
  51 #include &quot;StyleColor.h&quot;
  52 #include &quot;Supplementable.h&quot;
  53 #include &quot;TextResourceDecoder.h&quot;
  54 #include &quot;Timer.h&quot;
  55 #include &quot;TreeScope.h&quot;
  56 #include &quot;UserActionElementSet.h&quot;
  57 #include &quot;ViewportArguments.h&quot;
  58 #include &quot;VisibilityState.h&quot;
  59 #include &lt;pal/SessionID.h&gt;
  60 #include &lt;wtf/Deque.h&gt;
  61 #include &lt;wtf/Forward.h&gt;
  62 #include &lt;wtf/HashCountedSet.h&gt;
  63 #include &lt;wtf/HashSet.h&gt;
  64 #include &lt;wtf/Logger.h&gt;
  65 #include &lt;wtf/ObjectIdentifier.h&gt;
  66 #include &lt;wtf/UniqueRef.h&gt;

  67 #include &lt;wtf/WeakPtr.h&gt;
<span class="line-modified">  68 #include &lt;wtf/text/AtomicStringHash.h&gt;</span>
  69 
  70 #if PLATFORM(IOS_FAMILY)
  71 #include &quot;EventTrackingRegions.h&quot;
  72 #endif
  73 
  74 #if ENABLE(IOS_TOUCH_EVENTS)
  75 #include &lt;wtf/ThreadingPrimitives.h&gt;
  76 #endif
  77 
  78 namespace JSC {
  79 class ExecState;
  80 class InputCursor;
  81 }
  82 
  83 namespace WebCore {
  84 
  85 class ApplicationStateChangeListener;
  86 class AXObjectCache;
  87 class Attr;
  88 class CDATASection;
  89 class CSSCustomPropertyValue;
  90 class CSSFontSelector;
  91 class CSSStyleDeclaration;
  92 class CSSStyleSheet;
  93 class CachedCSSStyleSheet;
  94 class CachedFrameBase;
  95 class CachedResourceLoader;
  96 class CachedScript;
  97 class CanvasRenderingContext2D;
  98 class CharacterData;
  99 class Comment;
 100 class ConstantPropertyMap;

 101 class DOMImplementation;
 102 class DOMSelection;

 103 class DOMWindow;
 104 class DOMWrapperWorld;
 105 class Database;
 106 class DatabaseThread;
<span class="line-removed"> 107 class DeferredPromise;</span>
<span class="line-removed"> 108 class DocumentAnimationScheduler;</span>
 109 class DocumentFragment;
 110 class DocumentLoader;
 111 class DocumentMarkerController;
 112 class DocumentParser;
 113 class DocumentSharedObjectPool;
 114 class DocumentTimeline;
 115 class DocumentType;

 116 class ExtensionStyleSheets;
 117 class FloatQuad;
 118 class FloatRect;
 119 class FontFaceSet;
 120 class FormController;
 121 class Frame;
 122 class FrameView;

 123 class HTMLAllCollection;
 124 class HTMLBodyElement;
 125 class HTMLCanvasElement;
 126 class HTMLCollection;
 127 class HTMLDocument;
 128 class HTMLElement;
 129 class HTMLFrameOwnerElement;
 130 class HTMLHeadElement;
 131 class HTMLIFrameElement;
 132 class HTMLImageElement;
 133 class HTMLMapElement;
 134 class HTMLMediaElement;
 135 class HTMLPictureElement;
 136 class HTMLScriptElement;
 137 class HitTestLocation;
 138 class HitTestRequest;
 139 class HitTestResult;
 140 class ImageBitmapRenderingContext;
 141 class IntPoint;
 142 class JSNode;
 143 class LayoutPoint;
 144 class LayoutRect;
 145 class LiveNodeList;
 146 class Locale;
 147 class Location;
 148 class MediaCanStartListener;
 149 class MediaPlaybackTarget;
 150 class MediaPlaybackTargetClient;
 151 class MediaQueryList;
 152 class MediaQueryMatcher;
 153 class MouseEventWithHitTestResults;
 154 class NodeFilter;
 155 class NodeIterator;
 156 class Page;
 157 class PaintWorkletGlobalScope;
 158 class PlatformMouseEvent;
 159 class ProcessingInstruction;
 160 class QualifiedName;
 161 class Quirks;
 162 class Range;
<span class="line-removed"> 163 class RenderFullScreen;</span>
 164 class RenderTreeBuilder;
 165 class RenderView;
 166 class RequestAnimationFrameCallback;
 167 class SVGDocumentExtensions;
 168 class SVGSVGElement;
 169 class SVGUseElement;
 170 class SWClientConnection;
 171 class ScriptElementData;
 172 class ScriptModuleLoader;
 173 class ScriptRunner;
 174 class ScriptableDocumentParser;
 175 class ScriptedAnimationController;
 176 class SecurityOrigin;
 177 class SegmentedString;
 178 class SelectorQuery;
 179 class SelectorQueryCache;
 180 class SerializedScriptValue;
 181 class Settings;
 182 class StringCallback;
 183 class StyleResolver;
 184 class StyleSheet;
 185 class StyleSheetContents;
 186 class StyleSheetList;
 187 class Text;
 188 class TextResourceDecoder;
 189 class TreeWalker;
 190 class UndoManager;
 191 class VisibilityChangeClient;
 192 class VisitedLinkState;
 193 class WebAnimation;
 194 class WebGL2RenderingContext;
 195 class WebGLRenderingContext;
<span class="line-modified"> 196 class WebGPURenderingContext;</span>
<span class="line-removed"> 197 class WebMetalRenderingContext;</span>
 198 class WindowProxy;
 199 class Worklet;
 200 class XPathEvaluator;
 201 class XPathExpression;
 202 class XPathNSResolver;
 203 class XPathResult;
 204 
 205 template&lt;typename&gt; class ExceptionOr;
 206 
 207 enum CollectionType;
 208 enum class ShouldOpenExternalURLsPolicy : uint8_t;
 209 
 210 enum class RouteSharingPolicy : uint8_t;
 211 
 212 using PlatformDisplayID = uint32_t;
 213 
 214 #if ENABLE(XSLT)
 215 class TransformSource;
 216 #endif
 217 
<span class="line-removed"> 218 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 219 struct AnnotatedRegionValue;</span>
<span class="line-removed"> 220 #endif</span>
<span class="line-removed"> 221 </span>
 222 #if ENABLE(TOUCH_EVENTS) || ENABLE(IOS_TOUCH_EVENTS)
 223 class Touch;
 224 class TouchList;
 225 #endif
 226 

 227 #if PLATFORM(IOS_FAMILY)
 228 class DeviceMotionClient;
 229 class DeviceMotionController;
 230 class DeviceOrientationClient;
 231 class DeviceOrientationController;
 232 #endif


 233 
 234 #if ENABLE(TEXT_AUTOSIZING)
 235 class TextAutoSizing;
 236 #endif
 237 
 238 #if ENABLE(MEDIA_SESSION)
 239 class MediaSession;
 240 #endif
 241 
 242 #if ENABLE(ATTACHMENT_ELEMENT)
 243 class HTMLAttachmentElement;
 244 #endif
 245 
 246 #if ENABLE(INTERSECTION_OBSERVER)
 247 class IntersectionObserver;
 248 #endif
 249 




 250 namespace Style {
 251 class Scope;
 252 };
 253 
 254 const uint64_t HTMLMediaElementInvalidID = 0;
 255 
 256 enum PageshowEventPersistence { PageshowEventNotPersisted, PageshowEventPersisted };
 257 
 258 enum NodeListInvalidationType {
 259     DoNotInvalidateOnAttributeChanges,
 260     InvalidateOnClassAttrChange,
 261     InvalidateOnIdNameAttrChange,
 262     InvalidateOnNameAttrChange,
 263     InvalidateOnForTypeAttrChange,
 264     InvalidateForFormControls,
 265     InvalidateOnHRefAttrChange,
 266     InvalidateOnAnyAttrChange,
 267 };
 268 const int numNodeListInvalidationTypes = InvalidateOnAnyAttrChange + 1;
 269 
</pre>
<hr />
<pre>
 299     DisabledByContentDispositionAttachmentSandbox
 300 };
 301 
 302 enum class CustomElementNameValidationStatus {
 303     Valid,
 304     FirstCharacterIsNotLowercaseASCIILetter,
 305     ContainsNoHyphen,
 306     ContainsUppercaseASCIILetter,
 307     ContainsDisallowedCharacter,
 308     ConflictsWithStandardElementName
 309 };
 310 
 311 using RenderingContext = Variant&lt;
 312 #if ENABLE(WEBGL)
 313     RefPtr&lt;WebGLRenderingContext&gt;,
 314 #endif
 315 #if ENABLE(WEBGL2)
 316     RefPtr&lt;WebGL2RenderingContext&gt;,
 317 #endif
 318 #if ENABLE(WEBGPU)
<span class="line-modified"> 319     RefPtr&lt;WebGPURenderingContext&gt;,</span>
<span class="line-removed"> 320 #endif</span>
<span class="line-removed"> 321 #if ENABLE(WEBMETAL)</span>
<span class="line-removed"> 322     RefPtr&lt;WebMetalRenderingContext&gt;,</span>
 323 #endif
 324     RefPtr&lt;ImageBitmapRenderingContext&gt;,
 325     RefPtr&lt;CanvasRenderingContext2D&gt;
 326 &gt;;
 327 
 328 class DocumentParserYieldToken {
 329     WTF_MAKE_FAST_ALLOCATED;
 330 public:
 331     WEBCORE_EXPORT DocumentParserYieldToken(Document&amp;);
 332     WEBCORE_EXPORT ~DocumentParserYieldToken();
 333 
 334 private:
 335     WeakPtr&lt;Document&gt; m_document;
 336 };
 337 
 338 class Document
 339     : public ContainerNode
 340     , public TreeScope
 341     , public ScriptExecutionContext
 342     , public FontSelectorClient
<span class="line-removed"> 343     , public CanMakeWeakPtr&lt;Document&gt;</span>
 344     , public FrameDestructionObserver
 345     , public Supplementable&lt;Document&gt;
 346     , public Logger::Observer {
 347     WTF_MAKE_ISO_ALLOCATED(Document);
 348 public:
<span class="line-modified"> 349     static Ref&lt;Document&gt; create(const URL&amp;);</span>
 350     static Ref&lt;Document&gt; createNonRenderedPlaceholder(Frame&amp;, const URL&amp;);
 351     static Ref&lt;Document&gt; create(Document&amp;);
 352 
 353     virtual ~Document();
 354 
 355     // Nodes belonging to this document increase referencingNodeCount -
 356     // these are enough to keep the document from being destroyed, but
 357     // not enough to keep it from removing its children. This allows a
 358     // node that outlives its document to still have a valid document
 359     // pointer without introducing reference cycles.
 360     void incrementReferencingNodeCount()
 361     {
 362         ASSERT(!m_deletionHasBegun);
 363         ++m_referencingNodeCount;
 364     }
 365 
 366     void decrementReferencingNodeCount()
 367     {
 368         ASSERT(!m_deletionHasBegun || !m_referencingNodeCount);
 369         --m_referencingNodeCount;
 370         if (!m_referencingNodeCount &amp;&amp; !refCount()) {
 371 #if !ASSERT_DISABLED
 372             m_deletionHasBegun = true;
 373 #endif
<span class="line-modified"> 374             m_refCount = 1; // Avoid double destruction through use of RefPtr&lt;T&gt;. (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)</span>
 375             delete this;
 376         }
 377     }
 378 
 379     unsigned referencingNodeCount() const { return m_referencingNodeCount; }
 380 
 381     void removedLastRef();
 382 
 383     DocumentIdentifier identifier() const { return m_identifier; }
 384 
 385     using DocumentsMap = HashMap&lt;DocumentIdentifier, Document*&gt;;
 386     WEBCORE_EXPORT static DocumentsMap::ValuesIteratorRange allDocuments();
 387     WEBCORE_EXPORT static DocumentsMap&amp; allDocumentsMap();
 388 




 389     MediaQueryMatcher&amp; mediaQueryMatcher();
 390 
 391     using ContainerNode::ref;
 392     using ContainerNode::deref;
 393     using TreeScope::rootNode;
 394 
 395     bool canContainRangeEndPoint() const final { return true; }
 396 
 397     Element* elementForAccessKey(const String&amp; key);
 398     void invalidateAccessKeyCache();
 399 
 400     ExceptionOr&lt;SelectorQuery&amp;&gt; selectorQueryForString(const String&amp;);
 401     void clearSelectorQueryCache();
 402 
 403     void setViewportArguments(const ViewportArguments&amp; viewportArguments) { m_viewportArguments = viewportArguments; }
<span class="line-modified"> 404     ViewportArguments viewportArguments() const { return m_viewportArguments; }</span>
<span class="line-removed"> 405 </span>
<span class="line-removed"> 406     WEBCORE_EXPORT void setOverrideViewportArguments(const Optional&lt;ViewportArguments&gt;&amp;);</span>
 407 
 408     OptionSet&lt;DisabledAdaptations&gt; disabledAdaptations() const { return m_disabledAdaptations; }
 409 #ifndef NDEBUG
 410     bool didDispatchViewportPropertiesChanged() const { return m_didDispatchViewportPropertiesChanged; }
 411 #endif
 412 
 413     void setReferrerPolicy(ReferrerPolicy);
 414     ReferrerPolicy referrerPolicy() const { return m_referrerPolicy.valueOr(ReferrerPolicy::NoReferrerWhenDowngrade); }
 415 
 416     WEBCORE_EXPORT DocumentType* doctype() const;
 417 
 418     WEBCORE_EXPORT DOMImplementation&amp; implementation();
 419 
 420     Element* documentElement() const { return m_documentElement.get(); }
 421     static ptrdiff_t documentElementMemoryOffset() { return OBJECT_OFFSETOF(Document, m_documentElement); }
 422 
 423     WEBCORE_EXPORT Element* activeElement();
 424     WEBCORE_EXPORT bool hasFocus() const;
 425 
 426     bool hasManifest() const;
 427 
<span class="line-modified"> 428     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Element&gt;&gt; createElementForBindings(const AtomicString&amp; tagName);</span>
 429     WEBCORE_EXPORT Ref&lt;DocumentFragment&gt; createDocumentFragment();
 430     WEBCORE_EXPORT Ref&lt;Text&gt; createTextNode(const String&amp; data);
 431     WEBCORE_EXPORT Ref&lt;Comment&gt; createComment(const String&amp; data);
 432     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;CDATASection&gt;&gt; createCDATASection(const String&amp; data);
 433     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;ProcessingInstruction&gt;&gt; createProcessingInstruction(const String&amp; target, const String&amp; data);
 434     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; createAttribute(const String&amp; name);
<span class="line-modified"> 435     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; createAttributeNS(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks = false);</span>
 436     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Node&gt;&gt; importNode(Node&amp; nodeToImport, bool deep);
<span class="line-modified"> 437     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Element&gt;&gt; createElementNS(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName);</span>
 438     WEBCORE_EXPORT Ref&lt;Element&gt; createElement(const QualifiedName&amp;, bool createdByParser);
 439 
<span class="line-modified"> 440     static CustomElementNameValidationStatus validateCustomElementName(const AtomicString&amp;);</span>
 441 
 442     WEBCORE_EXPORT RefPtr&lt;Range&gt; caretRangeFromPoint(int x, int y);
 443     RefPtr&lt;Range&gt; caretRangeFromPoint(const LayoutPoint&amp; clientPoint);
 444 
 445     WEBCORE_EXPORT Element* scrollingElementForAPI();
 446     Element* scrollingElement();
 447 
 448     enum ReadyState { Loading, Interactive,  Complete };
 449     ReadyState readyState() const { return m_readyState; }
 450 
 451     WEBCORE_EXPORT String defaultCharsetForLegacyBindings() const;
 452 
 453     String charset() const { return Document::encoding(); }
 454     WEBCORE_EXPORT String characterSetWithUTF8Fallback() const;
 455     TextEncoding textEncoding() const;
 456 
<span class="line-modified"> 457     AtomicString encoding() const { return textEncoding().domName(); }</span>
 458 
 459     WEBCORE_EXPORT void setCharset(const String&amp;); // Used by ObjC / GOBject bindings only.
 460 
 461     void setContent(const String&amp;);
 462 
 463     String suggestedMIMEType() const;
 464 
 465     void overrideMIMEType(const String&amp;);
 466     WEBCORE_EXPORT String contentType() const;
 467 
 468     String contentLanguage() const { return m_contentLanguage; }
 469     void setContentLanguage(const String&amp;);
 470 
 471     String xmlEncoding() const { return m_xmlEncoding; }
 472     String xmlVersion() const { return m_xmlVersion; }
 473     enum class StandaloneStatus : uint8_t { Unspecified, Standalone, NotStandalone };
 474     bool xmlStandalone() const { return m_xmlStandalone == StandaloneStatus::Standalone; }
 475     StandaloneStatus xmlStandaloneStatus() const { return m_xmlStandalone; }
 476     bool hasXMLDeclaration() const { return m_hasXMLDeclaration; }
 477 
</pre>
<hr />
<pre>
 484     WEBCORE_EXPORT void setDocumentURI(const String&amp;);
 485 
 486     WEBCORE_EXPORT VisibilityState visibilityState() const;
 487     void visibilityStateChanged();
 488     WEBCORE_EXPORT bool hidden() const;
 489 
 490     void setTimerThrottlingEnabled(bool);
 491     bool isTimerThrottlingEnabled() const { return m_isTimerThrottlingEnabled; }
 492 
 493     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Node&gt;&gt; adoptNode(Node&amp; source);
 494 
 495     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; images();
 496     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; embeds();
 497     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; plugins(); // an alias for embeds() required for the JS DOM bindings.
 498     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; applets();
 499     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; links();
 500     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; forms();
 501     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; anchors();
 502     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; scripts();
 503     Ref&lt;HTMLCollection&gt; all();
<span class="line-modified"> 504     Ref&lt;HTMLCollection&gt; allFilteredByName(const AtomicString&amp;);</span>
 505 
<span class="line-modified"> 506     Ref&lt;HTMLCollection&gt; windowNamedItems(const AtomicString&amp;);</span>
<span class="line-modified"> 507     Ref&lt;HTMLCollection&gt; documentNamedItems(const AtomicString&amp;);</span>
 508 
 509     // Other methods (not part of DOM)
 510     bool isSynthesized() const { return m_isSynthesized; }
 511     bool isHTMLDocument() const { return m_documentClasses &amp; HTMLDocumentClass; }
 512     bool isXHTMLDocument() const { return m_documentClasses &amp; XHTMLDocumentClass; }
 513     bool isXMLDocument() const { return m_documentClasses &amp; XMLDocumentClass; }
 514     bool isImageDocument() const { return m_documentClasses &amp; ImageDocumentClass; }
 515     bool isSVGDocument() const { return m_documentClasses &amp; SVGDocumentClass; }
 516     bool isPluginDocument() const { return m_documentClasses &amp; PluginDocumentClass; }
 517     bool isMediaDocument() const { return m_documentClasses &amp; MediaDocumentClass; }
 518     bool isTextDocument() const { return m_documentClasses &amp; TextDocumentClass; }
 519     bool hasSVGRootNode() const;
 520     virtual bool isFrameSet() const { return false; }
 521 
 522     static ptrdiff_t documentClassesMemoryOffset() { return OBJECT_OFFSETOF(Document, m_documentClasses); }
 523     static uint32_t isHTMLDocumentClassFlag() { return HTMLDocumentClass; }
 524 
 525     bool isSrcdocDocument() const { return m_isSrcdocDocument; }
 526 
 527     bool sawElementsInKnownNamespaces() const { return m_sawElementsInKnownNamespaces; }
</pre>
<hr />
<pre>
 536     WEBCORE_EXPORT StyleSheetList&amp; styleSheets();
 537 
 538     Style::Scope&amp; styleScope() { return *m_styleScope; }
 539     const Style::Scope&amp; styleScope() const { return *m_styleScope; }
 540     ExtensionStyleSheets&amp; extensionStyleSheets() { return *m_extensionStyleSheets; }
 541     const ExtensionStyleSheets&amp; extensionStyleSheets() const { return *m_extensionStyleSheets; }
 542 
 543     bool gotoAnchorNeededAfterStylesheetsLoad() { return m_gotoAnchorNeededAfterStylesheetsLoad; }
 544     void setGotoAnchorNeededAfterStylesheetsLoad(bool b) { m_gotoAnchorNeededAfterStylesheetsLoad = b; }
 545 
 546     void evaluateMediaQueryList();
 547 
 548     FormController&amp; formController();
 549     Vector&lt;String&gt; formElementsState() const;
 550     void setStateForNewFormElements(const Vector&lt;String&gt;&amp;);
 551 
 552     WEBCORE_EXPORT FrameView* view() const; // Can be null.
 553     WEBCORE_EXPORT Page* page() const; // Can be null.
 554     const Settings&amp; settings() const { return m_settings.get(); }
 555     Settings&amp; mutableSettings() { return m_settings.get(); }

 556 
 557     const Quirks&amp; quirks() const { return m_quirks; }
 558 
 559     float deviceScaleFactor() const;
 560 
 561     WEBCORE_EXPORT bool useSystemAppearance() const;

 562     WEBCORE_EXPORT bool useDarkAppearance(const RenderStyle*) const;
 563 
 564     OptionSet&lt;StyleColor::Options&gt; styleColorOptions(const RenderStyle*) const;

 565 
 566     WEBCORE_EXPORT Ref&lt;Range&gt; createRange();
 567 
 568     // The last bool parameter is for ObjC bindings.
 569     WEBCORE_EXPORT Ref&lt;NodeIterator&gt; createNodeIterator(Node&amp; root, unsigned long whatToShow = 0xFFFFFFFF, RefPtr&lt;NodeFilter&gt;&amp;&amp; = nullptr, bool = false);
 570 
 571     // The last bool parameter is for ObjC bindings.
 572     WEBCORE_EXPORT Ref&lt;TreeWalker&gt; createTreeWalker(Node&amp; root, unsigned long whatToShow = 0xFFFFFFFF, RefPtr&lt;NodeFilter&gt;&amp;&amp; = nullptr, bool = false);
 573 
 574     // Special support for editing
 575     WEBCORE_EXPORT Ref&lt;CSSStyleDeclaration&gt; createCSSStyleDeclaration();
 576     Ref&lt;Text&gt; createEditingTextNode(const String&amp;);
 577 
 578     enum class ResolveStyleType { Normal, Rebuild };
 579     void resolveStyle(ResolveStyleType = ResolveStyleType::Normal);
 580     WEBCORE_EXPORT bool updateStyleIfNeeded();
 581     bool needsStyleRecalc() const;
 582     unsigned lastStyleUpdateSizeForTesting() const { return m_lastStyleUpdateSizeForTesting; }
 583 
 584     WEBCORE_EXPORT void updateLayout();
</pre>
<hr />
<pre>
 608     // Override ScriptExecutionContext methods to do additional work
 609     WEBCORE_EXPORT bool shouldBypassMainWorldContentSecurityPolicy() const final;
 610     void suspendActiveDOMObjects(ReasonForSuspension) final;
 611     void resumeActiveDOMObjects(ReasonForSuspension) final;
 612     void stopActiveDOMObjects() final;
 613 
 614     void suspendDeviceMotionAndOrientationUpdates();
 615     void resumeDeviceMotionAndOrientationUpdates();
 616 
 617     RenderView* renderView() const { return m_renderView.get(); }
 618 
 619     bool renderTreeBeingDestroyed() const { return m_renderTreeBeingDestroyed; }
 620     bool hasLivingRenderTree() const { return renderView() &amp;&amp; !renderTreeBeingDestroyed(); }
 621 
 622     bool updateLayoutIfDimensionsOutOfDate(Element&amp;, DimensionsCheck = AllDimensionsCheck);
 623 
 624     AXObjectCache* existingAXObjectCache() const;
 625     WEBCORE_EXPORT AXObjectCache* axObjectCache() const;
 626     void clearAXObjectCache();
 627 
<span class="line-modified"> 628     Optional&lt;uint64_t&gt; pageID() const;</span>
 629     // to get visually ordered hebrew and arabic pages right
 630     void setVisuallyOrdered();
 631     bool visuallyOrdered() const { return m_visuallyOrdered; }
 632 
 633     WEBCORE_EXPORT DocumentLoader* loader() const;
 634 
<span class="line-modified"> 635     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstDOMWindow, const String&amp; url, const AtomicString&amp; name, const String&amp; features);</span>
 636     WEBCORE_EXPORT ExceptionOr&lt;Document&amp;&gt; openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;);
 637 
 638     // FIXME: We should rename this at some point and give back the name &#39;open&#39; to the HTML specified ones.
 639     WEBCORE_EXPORT ExceptionOr&lt;void&gt; open(Document* responsibleDocument = nullptr);
 640     void implicitOpen();
 641 
 642     WEBCORE_EXPORT ExceptionOr&lt;void&gt; closeForBindings();
 643 
 644     // FIXME: We should rename this at some point and give back the name &#39;close&#39; to the HTML specified one.
 645     WEBCORE_EXPORT void close();
 646     // In some situations (see the code), we ignore document.close().
 647     // explicitClose() bypass these checks and actually tries to close the
 648     // input stream.
 649     void explicitClose();
 650     // implicitClose() actually does the work of closing the input stream.
 651     void implicitClose();
 652 
 653     void cancelParsing();
 654 
 655     ExceptionOr&lt;void&gt; write(Document* responsibleDocument, SegmentedString&amp;&amp;);
</pre>
<hr />
<pre>
 737 
 738     MouseEventWithHitTestResults prepareMouseEvent(const HitTestRequest&amp;, const LayoutPoint&amp;, const PlatformMouseEvent&amp;);
 739 
 740     enum class FocusRemovalEventsMode { Dispatch, DoNotDispatch };
 741     WEBCORE_EXPORT bool setFocusedElement(Element*, FocusDirection = FocusDirectionNone,
 742         FocusRemovalEventsMode = FocusRemovalEventsMode::Dispatch);
 743     Element* focusedElement() const { return m_focusedElement.get(); }
 744     UserActionElementSet&amp; userActionElements()  { return m_userActionElements; }
 745     const UserActionElementSet&amp; userActionElements() const { return m_userActionElements; }
 746 
 747     void setFocusNavigationStartingNode(Node*);
 748     Element* focusNavigationStartingNode(FocusDirection) const;
 749 
 750     enum class NodeRemoval { Node, ChildrenOfNode };
 751     void adjustFocusedNodeOnNodeRemoval(Node&amp;, NodeRemoval = NodeRemoval::Node);
 752     void adjustFocusNavigationNodeOnNodeRemoval(Node&amp;, NodeRemoval = NodeRemoval::Node);
 753 
 754     void hoveredElementDidDetach(Element&amp;);
 755     void elementInActiveChainDidDetach(Element&amp;);
 756 
<span class="line-modified"> 757     void updateHoverActiveState(const HitTestRequest&amp;, Element*);</span>

 758 
 759     // Updates for :target (CSS3 selector).
 760     void setCSSTarget(Element*);
 761     Element* cssTarget() const { return m_cssTarget; }
 762     static ptrdiff_t cssTargetMemoryOffset() { return OBJECT_OFFSETOF(Document, m_cssTarget); }
 763 
 764     WEBCORE_EXPORT void scheduleFullStyleRebuild();
 765     void scheduleStyleRecalc();
 766     void unscheduleStyleRecalc();
 767     bool hasPendingStyleRecalc() const;
 768     bool hasPendingFullStyleRebuild() const;
 769 
 770     void registerNodeListForInvalidation(LiveNodeList&amp;);
 771     void unregisterNodeListForInvalidation(LiveNodeList&amp;);
 772     WEBCORE_EXPORT void registerCollection(HTMLCollection&amp;);
 773     void unregisterCollection(HTMLCollection&amp;);
 774     void collectionCachedIdNameMap(const HTMLCollection&amp;);
 775     void collectionWillClearIdNameMap(const HTMLCollection&amp;);
 776     bool shouldInvalidateNodeListAndCollectionCaches() const;
 777     bool shouldInvalidateNodeListAndCollectionCachesForAttribute(const QualifiedName&amp; attrName) const;
</pre>
<hr />
<pre>
 800     bool canAcceptChild(const Node&amp; newChild, const Node* refChild, AcceptChildOperation) const;
 801 
 802     void textInserted(Node&amp;, unsigned offset, unsigned length);
 803     void textRemoved(Node&amp;, unsigned offset, unsigned length);
 804     void textNodesMerged(Text&amp; oldNode, unsigned offset);
 805     void textNodeSplit(Text&amp; oldNode);
 806 
 807     void createDOMWindow();
 808     void takeDOMWindowFrom(Document&amp;);
 809 
 810     DOMWindow* domWindow() const { return m_domWindow.get(); }
 811     // In DOM Level 2, the Document&#39;s DOMWindow is called the defaultView.
 812     WEBCORE_EXPORT WindowProxy* windowProxy() const;
 813 
 814     bool hasBrowsingContext() const { return !!frame(); }
 815 
 816     Document&amp; contextDocument() const;
 817     void setContextDocument(Document&amp; document) { m_contextDocument = makeWeakPtr(document); }
 818 
 819     // Helper functions for forwarding DOMWindow event related tasks to the DOMWindow if it exists.
<span class="line-modified"> 820     void setWindowAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; value, DOMWrapperWorld&amp;);</span>
<span class="line-modified"> 821     void setWindowAttributeEventListener(const AtomicString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp;, DOMWrapperWorld&amp;);</span>
<span class="line-modified"> 822     EventListener* getWindowAttributeEventListener(const AtomicString&amp; eventType, DOMWrapperWorld&amp;);</span>
 823     WEBCORE_EXPORT void dispatchWindowEvent(Event&amp;, EventTarget* = nullptr);
 824     void dispatchWindowLoadEvent();
 825 
 826     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Event&gt;&gt; createEvent(const String&amp; eventType);
 827 
 828     // keep track of what types of event listeners are registered, so we don&#39;t
 829     // dispatch events unnecessarily
 830     enum ListenerType {
 831         DOMSUBTREEMODIFIED_LISTENER          = 1,
 832         DOMNODEINSERTED_LISTENER             = 1 &lt;&lt; 1,
 833         DOMNODEREMOVED_LISTENER              = 1 &lt;&lt; 2,
 834         DOMNODEREMOVEDFROMDOCUMENT_LISTENER  = 1 &lt;&lt; 3,
 835         DOMNODEINSERTEDINTODOCUMENT_LISTENER = 1 &lt;&lt; 4,
 836         DOMCHARACTERDATAMODIFIED_LISTENER    = 1 &lt;&lt; 5,
 837         OVERFLOWCHANGED_LISTENER             = 1 &lt;&lt; 6,
 838         ANIMATIONEND_LISTENER                = 1 &lt;&lt; 7,
 839         ANIMATIONSTART_LISTENER              = 1 &lt;&lt; 8,
 840         ANIMATIONITERATION_LISTENER          = 1 &lt;&lt; 9,
 841         TRANSITIONEND_LISTENER               = 1 &lt;&lt; 10,
 842         BEFORELOAD_LISTENER                  = 1 &lt;&lt; 11,
 843         SCROLL_LISTENER                      = 1 &lt;&lt; 12,
 844         FORCEWILLBEGIN_LISTENER              = 1 &lt;&lt; 13,
 845         FORCECHANGED_LISTENER                = 1 &lt;&lt; 14,
 846         FORCEDOWN_LISTENER                   = 1 &lt;&lt; 15,
 847         FORCEUP_LISTENER                     = 1 &lt;&lt; 16,
 848         RESIZE_LISTENER                      = 1 &lt;&lt; 17
 849     };
 850 
 851     bool hasListenerType(ListenerType listenerType) const { return (m_listenerTypes &amp; listenerType); }
 852     bool hasListenerTypeForEventType(PlatformEvent::Type) const;
<span class="line-modified"> 853     void addListenerTypeIfNeeded(const AtomicString&amp; eventType);</span>
 854 
 855     bool hasMutationObserversOfType(MutationObserver::MutationType type) const
 856     {
 857         return m_mutationObserverTypes &amp; type;
 858     }
 859     bool hasMutationObservers() const { return m_mutationObserverTypes; }
 860     void addMutationObserverTypes(MutationObserverOptions types) { m_mutationObserverTypes |= types; }
 861 
 862     CSSStyleDeclaration* getOverrideStyle(Element*, const String&amp;) { return nullptr; }
 863 
 864     // Handles an HTTP header equivalent set by a meta tag using &lt;meta http-equiv=&quot;...&quot; content=&quot;...&quot;&gt;. This is called
 865     // when a meta tag is encountered during document parsing, and also when a script dynamically changes or adds a meta
 866     // tag. This enables scripts to use meta tags to perform refreshes and set expiry dates in addition to them being
 867     // specified in an HTML file.
 868     void processHttpEquiv(const String&amp; equiv, const String&amp; content, bool isInDocumentHead);
 869 
 870 #if PLATFORM(IOS_FAMILY)
 871     void processFormatDetection(const String&amp;);
 872 
 873     // Called when &lt;meta name=&quot;apple-mobile-web-app-orientations&quot;&gt; changes.
 874     void processWebAppOrientations();





 875 #endif
 876 
 877     void processViewport(const String&amp; features, ViewportArguments::Type origin);
 878     void processDisabledAdaptations(const String&amp; adaptations);
 879     void updateViewportArguments();
 880     void processReferrerPolicy(const String&amp; policy, ReferrerPolicySource);
 881 
 882 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified"> 883     void processSupportedColorSchemes(const String&amp; colorSchemes);</span>
 884 #endif
 885 
 886     // Returns the owning element in the parent document.
 887     // Returns nullptr if this is the top level document.
 888     HTMLFrameOwnerElement* ownerElement() const;
 889 
 890     // Used by DOM bindings; no direction known.
 891     const String&amp; title() const { return m_title.string; }
 892     WEBCORE_EXPORT void setTitle(const String&amp;);
 893 
<span class="line-modified"> 894     WEBCORE_EXPORT const AtomicString&amp; dir() const;</span>
<span class="line-modified"> 895     WEBCORE_EXPORT void setDir(const AtomicString&amp;);</span>
 896 
 897     void titleElementAdded(Element&amp; titleElement);
 898     void titleElementRemoved(Element&amp; titleElement);
 899     void titleElementTextChanged(Element&amp; titleElement);
 900 
 901     WEBCORE_EXPORT ExceptionOr&lt;String&gt; cookie();
 902     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setCookie(const String&amp;);
 903 
 904     WEBCORE_EXPORT String referrer() const;
 905 
 906     WEBCORE_EXPORT String origin() const final;
 907 
 908     WEBCORE_EXPORT String domain() const;
 909     ExceptionOr&lt;void&gt; setDomain(const String&amp; newDomain);
 910 
 911     void overrideLastModified(const Optional&lt;WallTime&gt;&amp;);
 912     WEBCORE_EXPORT String lastModified() const;
 913 
 914     // The cookieURL is used to query the cookie database for this document&#39;s
 915     // cookies. For example, if the cookie URL is http://example.com, we&#39;ll
</pre>
<hr />
<pre>
 937     const URL&amp; firstPartyForCookies() const { return m_firstPartyForCookies; }
 938     void setFirstPartyForCookies(const URL&amp; url) { m_firstPartyForCookies = url; }
 939 
 940     bool isFullyActive() const;
 941 
 942     // The full URL corresponding to the &quot;site for cookies&quot; in the Same-Site Cookies spec.,
 943     // &lt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&gt;. It is either
 944     // the URL of the top-level document or the null URL depending on whether the registrable
 945     // domain of this document&#39;s URL matches the registrable domain of its parent&#39;s/opener&#39;s
 946     // URL. For the top-level document, it is set to the document&#39;s URL.
 947     const URL&amp; siteForCookies() const { return m_siteForCookies; }
 948     void setSiteForCookies(const URL&amp; url) { m_siteForCookies = url; }
 949 
 950     // The following implements the rule from HTML 4 for what valid names are.
 951     // To get this right for all the XML cases, we probably have to improve this or move it
 952     // and make it sensitive to the type of document.
 953     static bool isValidName(const String&amp;);
 954 
 955     // The following breaks a qualified name into a prefix and a local name.
 956     // It also does a validity check, and returns an error if the qualified name is invalid.
<span class="line-modified"> 957     static ExceptionOr&lt;std::pair&lt;AtomicString, AtomicString&gt;&gt; parseQualifiedName(const String&amp; qualifiedName);</span>
<span class="line-modified"> 958     static ExceptionOr&lt;QualifiedName&gt; parseQualifiedName(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName);</span>
 959 
 960     // Checks to make sure prefix and namespace do not conflict (per DOM Core 3)
 961     static bool hasValidNamespaceForElements(const QualifiedName&amp;);
 962     static bool hasValidNamespaceForAttributes(const QualifiedName&amp;);
 963 
 964     // This is the &quot;HTML body element&quot; as defined by CSSOM View spec, the first body child of the
 965     // document element. See http://dev.w3.org/csswg/cssom-view/#the-html-body-element.
 966     WEBCORE_EXPORT HTMLBodyElement* body() const;
 967 
 968     // This is the &quot;body element&quot; as defined by HTML5, the first body or frameset child of the
 969     // document element. See https://html.spec.whatwg.org/multipage/dom.html#the-body-element-2.
 970     WEBCORE_EXPORT HTMLElement* bodyOrFrameset() const;
 971     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setBodyOrFrameset(RefPtr&lt;HTMLElement&gt;&amp;&amp;);
 972 
 973     Location* location() const;
 974 
 975     WEBCORE_EXPORT HTMLHeadElement* head();
 976 
 977     DocumentMarkerController&amp; markers() const { return *m_markers; }
 978 
</pre>
<hr />
<pre>
1001 
1002     HTMLScriptElement* currentScript() const { return !m_currentScriptStack.isEmpty() ? m_currentScriptStack.last().get() : nullptr; }
1003     void pushCurrentScript(HTMLScriptElement*);
1004     void popCurrentScript();
1005 
1006     bool shouldDeferAsynchronousScriptsUntilParsingFinishes() const;
1007 
1008 #if ENABLE(XSLT)
1009     void scheduleToApplyXSLTransforms();
1010     void applyPendingXSLTransformsNowIfScheduled();
1011     RefPtr&lt;Document&gt; transformSourceDocument() { return m_transformSourceDocument; }
1012     void setTransformSourceDocument(Document* document) { m_transformSourceDocument = document; }
1013 
1014     void setTransformSource(std::unique_ptr&lt;TransformSource&gt;);
1015     TransformSource* transformSource() const { return m_transformSource.get(); }
1016 #endif
1017 
1018     void incDOMTreeVersion() { m_domTreeVersion = ++s_globalTreeVersion; }
1019     uint64_t domTreeVersion() const { return m_domTreeVersion; }
1020 
<span class="line-modified">1021     WEBCORE_EXPORT String originIdentifierForPasteboard();</span>
1022 
1023     // XPathEvaluator methods
1024     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp;);
1025     WEBCORE_EXPORT Ref&lt;XPathNSResolver&gt; createNSResolver(Node* nodeResolver);
1026     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; evaluate(const String&amp; expression, Node* contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp;, unsigned short type, XPathResult*);
1027 
1028     bool hasNodesWithNonFinalStyle() const { return m_hasNodesWithNonFinalStyle; }
1029     void setHasNodesWithNonFinalStyle() { m_hasNodesWithNonFinalStyle = true; }
1030     bool hasNodesWithMissingStyle() const { return m_hasNodesWithMissingStyle; }
1031     void setHasNodesWithMissingStyle() { m_hasNodesWithMissingStyle = true; }
1032 
1033     // Extension for manipulating canvas drawing contexts for use in CSS
1034     Optional&lt;RenderingContext&gt; getCSSCanvasContext(const String&amp; type, const String&amp; name, int width, int height);
1035     HTMLCanvasElement* getCSSCanvasElement(const String&amp; name);
1036     String nameForCSSCanvasElement(const HTMLCanvasElement&amp;) const;
1037 
1038     bool isDNSPrefetchEnabled() const { return m_isDNSPrefetchEnabled; }
1039     void parseDNSPrefetchControlHeader(const String&amp;);
1040 
1041     WEBCORE_EXPORT void postTask(Task&amp;&amp;) final; // Executes the task on context&#39;s thread asynchronously.
1042 
1043     ScriptedAnimationController* scriptedAnimationController() { return m_scriptedAnimationController.get(); }
1044     void suspendScriptedAnimationControllerCallbacks();
1045     void resumeScriptedAnimationControllerCallbacks();
1046 



1047     void windowScreenDidChange(PlatformDisplayID);
1048 
1049     void finishedParsing();
1050 
1051     enum PageCacheState { NotInPageCache, AboutToEnterPageCache, InPageCache };
1052 
1053     PageCacheState pageCacheState() const { return m_pageCacheState; }
1054     void setPageCacheState(PageCacheState);
1055 
1056     void registerForDocumentSuspensionCallbacks(Element&amp;);
1057     void unregisterForDocumentSuspensionCallbacks(Element&amp;);
1058 
1059     void documentWillBecomeInactive();
1060     void suspend(ReasonForSuspension);
1061     void resume(ReasonForSuspension);
1062 
1063     void registerForMediaVolumeCallbacks(Element&amp;);
1064     void unregisterForMediaVolumeCallbacks(Element&amp;);
1065     void mediaVolumeDidChange();
1066 
1067     bool audioPlaybackRequiresUserGesture() const;
1068     bool videoPlaybackRequiresUserGesture() const;
1069 
1070 #if ENABLE(MEDIA_SESSION)
1071     MediaSession&amp; defaultMediaSession();
1072 #endif
1073 
1074     void registerForPrivateBrowsingStateChangedCallbacks(Element&amp;);
1075     void unregisterForPrivateBrowsingStateChangedCallbacks(Element&amp;);
1076     void storageBlockingStateDidChange();
<span class="line-modified">1077     void privateBrowsingStateDidChange();</span>
1078 
1079 #if ENABLE(VIDEO_TRACK)
1080     void registerForCaptionPreferencesChangedCallbacks(Element&amp;);
1081     void unregisterForCaptionPreferencesChangedCallbacks(Element&amp;);
1082     void captionPreferencesChanged();
1083 #endif
1084 
1085 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1086     void registerForPageScaleFactorChangedCallbacks(HTMLMediaElement&amp;);
1087     void unregisterForPageScaleFactorChangedCallbacks(HTMLMediaElement&amp;);
1088     void pageScaleFactorChangedAndStable();
1089     void registerForUserInterfaceLayoutDirectionChangedCallbacks(HTMLMediaElement&amp;);
1090     void unregisterForUserInterfaceLayoutDirectionChangedCallbacks(HTMLMediaElement&amp;);
1091     void userInterfaceLayoutDirectionChanged();
1092 #endif
1093 
1094     void registerForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp;);
1095     void unregisterForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp;);
1096 
1097 #if ENABLE(VIDEO)
1098     void registerForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp;);
1099     void unregisterForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp;);
1100     void allowsMediaDocumentInlinePlaybackChanged();
1101 
1102     void stopAllMediaPlayback();
1103     void suspendAllMediaPlayback();
1104     void resumeAllMediaPlayback();


1105 #endif
1106 
1107     WEBCORE_EXPORT void setShouldCreateRenderers(bool);
1108     bool shouldCreateRenderers();
1109 
1110     void setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp;);
1111     TextResourceDecoder* decoder() const { return m_decoder.get(); }
1112 
1113     WEBCORE_EXPORT String displayStringModifiedByEncoding(const String&amp;) const;
1114 
<span class="line-modified">1115 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">1116     void setHasAnnotatedRegions(bool f) { m_hasAnnotatedRegions = f; }</span>
<span class="line-removed">1117     WEBCORE_EXPORT const Vector&lt;AnnotatedRegionValue&gt;&amp; annotatedRegions() const;</span>
<span class="line-removed">1118 #endif</span>
<span class="line-removed">1119 </span>
<span class="line-removed">1120     enum class AnnotationsAction { Invalidate, Update };</span>
<span class="line-removed">1121     void invalidateRenderingDependentRegions(AnnotationsAction = AnnotationsAction::Invalidate);</span>
<span class="line-removed">1122     void invalidateScrollbarDependentRegions();</span>
<span class="line-removed">1123     void updateZOrderDependentRegions();</span>
1124 
1125     void removeAllEventListeners() final;
1126 
1127     WEBCORE_EXPORT const SVGDocumentExtensions* svgExtensions();
1128     WEBCORE_EXPORT SVGDocumentExtensions&amp; accessSVGExtensions();
1129 
1130     void addSVGUseElement(SVGUseElement&amp;);
1131     void removeSVGUseElement(SVGUseElement&amp;);
1132     HashSet&lt;SVGUseElement*&gt; const svgUseElements() const { return m_svgUseElements; }
1133 
1134     void initSecurityContext();
1135     void initContentSecurityPolicy(ContentSecurityPolicy* previousPolicy);
1136 
1137     void updateURLForPushOrReplaceState(const URL&amp;);
1138     void statePopped(Ref&lt;SerializedScriptValue&gt;&amp;&amp;);
1139 
1140     bool processingLoadEvent() const { return m_processingLoadEvent; }
1141     bool loadEventFinished() const { return m_loadEventFinished; }
1142 
1143     bool isContextThread() const final;
1144     bool isSecureContext() const final;
1145     bool isJSExecutionForbidden() const final { return false; }
1146 
1147     void enqueueWindowEvent(Ref&lt;Event&gt;&amp;&amp;);
1148     void enqueueDocumentEvent(Ref&lt;Event&gt;&amp;&amp;);
1149     void enqueueOverflowEvent(Ref&lt;Event&gt;&amp;&amp;);
1150     void dispatchPageshowEvent(PageshowEventPersistence);
1151     WEBCORE_EXPORT void enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp;);
1152     void enqueueHashchangeEvent(const String&amp; oldURL, const String&amp; newURL);
1153     void dispatchPopstateEvent(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject);
1154     DocumentEventQueue&amp; eventQueue() const final { return m_eventQueue; }
1155 
1156     WEBCORE_EXPORT void addMediaCanStartListener(MediaCanStartListener&amp;);
1157     WEBCORE_EXPORT void removeMediaCanStartListener(MediaCanStartListener&amp;);
1158     MediaCanStartListener* takeAnyMediaCanStartListener();
1159 
1160 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">1161     bool webkitIsFullScreen() const { return m_fullScreenElement.get(); }</span>
<span class="line-modified">1162     bool webkitFullScreenKeyboardInputAllowed() const { return m_fullScreenElement.get() &amp;&amp; m_areKeysEnabledInFullScreen; }</span>
<span class="line-removed">1163     Element* webkitCurrentFullScreenElement() const { return m_fullScreenElement.get(); }</span>
<span class="line-removed">1164     Element* webkitCurrentFullScreenElementForBindings() const { return ancestorElementInThisScope(webkitCurrentFullScreenElement()); }</span>
<span class="line-removed">1165 </span>
<span class="line-removed">1166     enum FullScreenCheckType {</span>
<span class="line-removed">1167         EnforceIFrameAllowFullScreenRequirement,</span>
<span class="line-removed">1168         ExemptIFrameAllowFullScreenRequirement,</span>
<span class="line-removed">1169     };</span>
<span class="line-removed">1170 </span>
<span class="line-removed">1171     void requestFullScreenForElement(Element*, FullScreenCheckType);</span>
<span class="line-removed">1172     WEBCORE_EXPORT void webkitCancelFullScreen();</span>
<span class="line-removed">1173 </span>
<span class="line-removed">1174     WEBCORE_EXPORT void webkitWillEnterFullScreen(Element&amp;);</span>
<span class="line-removed">1175     WEBCORE_EXPORT void webkitDidEnterFullScreen();</span>
<span class="line-removed">1176     WEBCORE_EXPORT void webkitWillExitFullScreen();</span>
<span class="line-removed">1177     WEBCORE_EXPORT void webkitDidExitFullScreen();</span>
<span class="line-removed">1178 </span>
<span class="line-removed">1179     void setFullScreenRenderer(RenderTreeBuilder&amp;, RenderFullScreen&amp;);</span>
<span class="line-removed">1180     RenderFullScreen* fullScreenRenderer() const { return m_fullScreenRenderer.get(); }</span>
<span class="line-removed">1181 </span>
<span class="line-removed">1182     void dispatchFullScreenChangeEvents();</span>
<span class="line-removed">1183     bool fullScreenIsAllowedForElement(Element&amp;) const;</span>
<span class="line-removed">1184     void fullScreenElementRemoved();</span>
<span class="line-removed">1185     void adjustFullScreenElementOnNodeRemoval(Node&amp;, NodeRemoval = NodeRemoval::Node);</span>
<span class="line-removed">1186 </span>
<span class="line-removed">1187     WEBCORE_EXPORT bool isAnimatingFullScreen() const;</span>
<span class="line-removed">1188     WEBCORE_EXPORT void setAnimatingFullScreen(bool);</span>
<span class="line-removed">1189 </span>
<span class="line-removed">1190     WEBCORE_EXPORT bool areFullscreenControlsHidden() const;</span>
<span class="line-removed">1191     WEBCORE_EXPORT void setFullscreenControlsHidden(bool);</span>
<span class="line-removed">1192 </span>
<span class="line-removed">1193     WEBCORE_EXPORT bool webkitFullscreenEnabled() const;</span>
<span class="line-removed">1194     Element* webkitFullscreenElement() const { return !m_fullScreenElementStack.isEmpty() ? m_fullScreenElementStack.last().get() : nullptr; }</span>
<span class="line-removed">1195     Element* webkitFullscreenElementForBindings() const { return ancestorElementInThisScope(webkitFullscreenElement()); }</span>
<span class="line-removed">1196     WEBCORE_EXPORT void webkitExitFullscreen();</span>
1197 #endif
1198 
1199 #if ENABLE(POINTER_LOCK)
1200     WEBCORE_EXPORT void exitPointerLock();
1201 #endif
1202 
1203     // Used to allow element that loads data without going through a FrameLoader to delay the &#39;load&#39; event.
1204     void incrementLoadEventDelayCount() { ++m_loadEventDelayCount; }
1205     void decrementLoadEventDelayCount();
1206     bool isDelayingLoadEvent() const { return m_loadEventDelayCount; }
1207     void checkCompleted();
1208 
1209 #if ENABLE(IOS_TOUCH_EVENTS)
1210 #include &lt;WebKitAdditions/DocumentIOS.h&gt;
1211 #endif
1212 
<span class="line-modified">1213 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)</span>

1214     DeviceMotionController&amp; deviceMotionController() const;
1215     DeviceOrientationController&amp; deviceOrientationController() const;
1216     WEBCORE_EXPORT void simulateDeviceOrientationChange(double alpha, double beta, double gamma);
1217 #endif
1218 



1219     const DocumentTiming&amp; timing() const { return m_documentTiming; }
1220 
1221     WEBCORE_EXPORT double monotonicTimestamp() const;
1222 
1223     int requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp;);
1224     void cancelAnimationFrame(int id);
1225 
1226     EventTarget* errorEventTarget() final;
1227     void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) final;
1228 
1229     void initDNSPrefetch();
1230 
1231     void didAddWheelEventHandler(Node&amp;);
1232     void didRemoveWheelEventHandler(Node&amp;, EventHandlerRemoval = EventHandlerRemoval::One);
1233 
1234     MonotonicTime lastHandledUserGestureTimestamp() const { return m_lastHandledUserGestureTimestamp; }
1235     bool hasHadUserInteraction() const { return static_cast&lt;bool&gt;(m_lastHandledUserGestureTimestamp); }
1236     void updateLastHandledUserGestureTimestamp(MonotonicTime);
1237     bool processingUserGestureForMedia() const;

1238 
1239     void setUserDidInteractWithPage(bool userDidInteractWithPage) { ASSERT(&amp;topDocument() == this); m_userDidInteractWithPage = userDidInteractWithPage; }
1240     bool userDidInteractWithPage() const { ASSERT(&amp;topDocument() == this); return m_userDidInteractWithPage; }
1241 
1242     // Used for testing. Count handlers in the main document, and one per frame which contains handlers.
1243     WEBCORE_EXPORT unsigned wheelEventHandlerCount() const;
1244     WEBCORE_EXPORT unsigned touchEventHandlerCount() const;
1245 
1246     WEBCORE_EXPORT void startTrackingStyleRecalcs();
1247     WEBCORE_EXPORT unsigned styleRecalcCount() const;
1248 
1249 #if ENABLE(TOUCH_EVENTS)
1250     bool hasTouchEventHandlers() const { return (m_touchEventTargets.get()) ? m_touchEventTargets-&gt;size() : false; }
1251     bool touchEventTargetsContain(Node&amp; node) const { return m_touchEventTargets ? m_touchEventTargets-&gt;contains(&amp;node) : false; }
1252 #else
1253     bool hasTouchEventHandlers() const { return false; }
1254     bool touchEventTargetsContain(Node&amp;) const { return false; }
1255 #endif
<span class="line-modified">1256 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-modified">1257     void updateTouchActionElements(Element&amp;, const RenderStyle&amp;);</span>
<span class="line-modified">1258     const HashSet&lt;RefPtr&lt;Element&gt;&gt;* touchActionElements() const { return m_touchActionElements.get(); }</span>
1259 #endif
1260 
1261     void didAddTouchEventHandler(Node&amp;);
1262     void didRemoveTouchEventHandler(Node&amp;, EventHandlerRemoval = EventHandlerRemoval::One);
1263 
1264     void didRemoveEventTargetNode(Node&amp;);
1265 
1266     const EventTargetSet* touchEventTargets() const
1267     {
1268 #if ENABLE(TOUCH_EVENTS)
1269         return m_touchEventTargets.get();
1270 #else
1271         return nullptr;
1272 #endif
1273     }
1274 
1275     const EventTargetSet* wheelEventTargets() const { return m_wheelEventTargets.get(); }
1276 
1277     typedef std::pair&lt;Region, bool&gt; RegionFixedPair;
1278     RegionFixedPair absoluteEventRegionForNode(Node&amp;);
</pre>
<hr />
<pre>
1284 
1285     bool isInDocumentWrite() { return m_writeRecursionDepth &gt; 0; }
1286 
1287     void suspendScheduledTasks(ReasonForSuspension);
1288     void resumeScheduledTasks(ReasonForSuspension);
1289 
1290 #if ENABLE(CSS_DEVICE_ADAPTATION)
1291     IntSize initialViewportSize() const;
1292 #endif
1293 
1294     void convertAbsoluteToClientQuads(Vector&lt;FloatQuad&gt;&amp;, const RenderStyle&amp;);
1295     void convertAbsoluteToClientRects(Vector&lt;FloatRect&gt;&amp;, const RenderStyle&amp;);
1296     void convertAbsoluteToClientRect(FloatRect&amp;, const RenderStyle&amp;);
1297 
1298     bool hasActiveParser();
1299     void incrementActiveParserCount() { ++m_activeParserCount; }
1300     void decrementActiveParserCount();
1301 
1302     std::unique_ptr&lt;DocumentParserYieldToken&gt; createParserYieldToken()
1303     {
<span class="line-modified">1304         return std::make_unique&lt;DocumentParserYieldToken&gt;(*this);</span>
1305     }
1306 
1307     bool hasActiveParserYieldToken() const { return m_parserYieldTokenCount; }
1308 
1309     DocumentSharedObjectPool* sharedObjectPool() { return m_sharedObjectPool.get(); }
1310 
1311     void invalidateMatchedPropertiesCacheAndForceStyleRecalc();
1312 
1313     void didRemoveAllPendingStylesheet();
1314     void didClearStyleResolver();
1315 
1316     bool inStyleRecalc() const { return m_inStyleRecalc; }
1317     bool inRenderTreeUpdate() const { return m_inRenderTreeUpdate; }
1318     bool isResolvingTreeStyle() const { return m_isResolvingTreeStyle; }
1319     void setIsResolvingTreeStyle(bool);
1320 
1321     void updateTextRenderer(Text&amp;, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText);
1322 
1323     // Return a Locale for the default locale if the argument is null or empty.
<span class="line-modified">1324     Locale&amp; getCachedLocale(const AtomicString&amp; locale = nullAtom());</span>
1325 
1326     const Document* templateDocument() const;
1327     Document&amp; ensureTemplateDocument();
<span class="line-modified">1328     void setTemplateDocumentHost(Document* templateDocumentHost) { m_templateDocumentHost = templateDocumentHost; }</span>
<span class="line-modified">1329     Document* templateDocumentHost() { return m_templateDocumentHost; }</span>
1330 
1331     void didAssociateFormControl(Element&amp;);
1332     bool hasDisabledFieldsetElement() const { return m_disabledFieldsetElementsCount; }
1333     void addDisabledFieldsetElement() { m_disabledFieldsetElementsCount++; }
1334     void removeDisabledFieldsetElement() { ASSERT(m_disabledFieldsetElementsCount); m_disabledFieldsetElementsCount--; }
1335 


1336     WEBCORE_EXPORT void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) final;
1337 
1338     // The following addConsoleMessage function is deprecated.
1339     // Callers should try to create the ConsoleMessage themselves.
1340     WEBCORE_EXPORT void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier = 0) final;
1341 
1342     // The following addMessage function is deprecated.
1343     // Callers should try to create the ConsoleMessage themselves.
1344     void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::ExecState* = nullptr, unsigned long requestIdentifier = 0) final;
1345 
1346     SecurityOrigin&amp; securityOrigin() const { return *SecurityContext::securityOrigin(); }
1347     SecurityOrigin&amp; topOrigin() const final { return topDocument().securityOrigin(); }
1348 
1349     Ref&lt;FontFaceSet&gt; fonts();
1350 
1351     void ensurePlugInsInjectedScript(DOMWrapperWorld&amp;);
1352 
1353     void setVisualUpdatesAllowedByClient(bool);
1354 
1355 #if ENABLE(WEB_CRYPTO)
</pre>
<hr />
<pre>
1373     void addPlaybackTargetPickerClient(MediaPlaybackTargetClient&amp;);
1374     void removePlaybackTargetPickerClient(MediaPlaybackTargetClient&amp;);
1375     void showPlaybackTargetPicker(MediaPlaybackTargetClient&amp;, bool, RouteSharingPolicy, const String&amp;);
1376     void playbackTargetPickerClientStateDidChange(MediaPlaybackTargetClient&amp;, MediaProducer::MediaStateFlags);
1377 
1378     void setPlaybackTarget(uint64_t, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;);
1379     void playbackTargetAvailabilityDidChange(uint64_t, bool);
1380     void setShouldPlayToPlaybackTarget(uint64_t, bool);
1381 #endif
1382 
1383     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToPropagate() const;
1384     bool shouldEnforceContentDispositionAttachmentSandbox() const;
1385     void applyContentDispositionAttachmentSandbox();
1386 
1387     void addViewportDependentPicture(HTMLPictureElement&amp;);
1388     void removeViewportDependentPicture(HTMLPictureElement&amp;);
1389 
1390     void addAppearanceDependentPicture(HTMLPictureElement&amp;);
1391     void removeAppearanceDependentPicture(HTMLPictureElement&amp;);
1392 


1393 #if ENABLE(INTERSECTION_OBSERVER)
1394     void addIntersectionObserver(IntersectionObserver&amp;);
1395     void removeIntersectionObserver(IntersectionObserver&amp;);
1396     unsigned numberOfIntersectionObservers() const { return m_intersectionObservers.size(); }
<span class="line-removed">1397     void scheduleForcedIntersectionObservationUpdate();</span>
1398     void updateIntersectionObservations();













1399 #endif
1400 
1401 #if ENABLE(MEDIA_STREAM)
1402     void setHasCaptureMediaStreamTrack() { m_hasHadCaptureMediaStreamTrack = true; }
1403     bool hasHadCaptureMediaStreamTrack() const { return m_hasHadCaptureMediaStreamTrack; }
1404     void setDeviceIDHashSalt(const String&amp;);
1405     String deviceIDHashSalt() const { return m_idHashSalt; }
1406     void stopMediaCapture();
1407     void registerForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp;);
1408     void unregisterForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp;);
1409     void mediaStreamCaptureStateChanged();
1410 #endif
1411 
1412 // FIXME: Find a better place for this functionality.
1413 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
1414     // These functions provide a two-level setting:
1415     //    - A user-settable wantsTelephoneNumberParsing (at the Page / WebView level)
1416     //    - A read-only telephoneNumberParsingAllowed which is set by the
1417     //      document if it has the appropriate meta tag.
1418     //    - isTelephoneNumberParsingEnabled() == isTelephoneNumberParsingAllowed() &amp;&amp; page()-&gt;settings()-&gt;isTelephoneNumberParsingEnabled()
1419     WEBCORE_EXPORT bool isTelephoneNumberParsingAllowed() const;
1420     WEBCORE_EXPORT bool isTelephoneNumberParsingEnabled() const;
1421 #endif
1422 
1423     using ContainerNode::setAttributeEventListener;
<span class="line-modified">1424     void setAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; value, DOMWrapperWorld&amp; isolatedWorld);</span>
1425 
1426     DOMSelection* getSelection();
1427 
1428     void didInsertInDocumentShadowRoot(ShadowRoot&amp;);
1429     void didRemoveInDocumentShadowRoot(ShadowRoot&amp;);
1430     const HashSet&lt;ShadowRoot*&gt;&amp; inDocumentShadowRoots() const { return m_inDocumentShadowRoots; }
1431 
1432     void attachToCachedFrame(CachedFrameBase&amp;);
1433     void detachFromCachedFrame(CachedFrameBase&amp;);
1434 
1435     ConstantPropertyMap&amp; constantProperties() const { return *m_constantPropertyMap; }
1436 
1437     void orientationChanged(int orientation);
1438     OrientationNotifier&amp; orientationNotifier() { return m_orientationNotifier; }
1439 
<span class="line-modified">1440     WEBCORE_EXPORT const AtomicString&amp; bgColor() const;</span>
1441     WEBCORE_EXPORT void setBgColor(const String&amp;);
<span class="line-modified">1442     WEBCORE_EXPORT const AtomicString&amp; fgColor() const;</span>
1443     WEBCORE_EXPORT void setFgColor(const String&amp;);
<span class="line-modified">1444     WEBCORE_EXPORT const AtomicString&amp; alinkColor() const;</span>
1445     WEBCORE_EXPORT void setAlinkColor(const String&amp;);
<span class="line-modified">1446     WEBCORE_EXPORT const AtomicString&amp; linkColorForBindings() const;</span>
1447     WEBCORE_EXPORT void setLinkColorForBindings(const String&amp;);
<span class="line-modified">1448     WEBCORE_EXPORT const AtomicString&amp; vlinkColor() const;</span>
1449     WEBCORE_EXPORT void setVlinkColor(const String&amp;);
1450 
1451     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-clear, this method does nothing.
1452     void clear() { }
1453     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-captureevents, this method does nothing.
1454     void captureEvents() { }
1455     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-releaseevents, this method does nothing.
1456     void releaseEvents() { }
1457 
1458 #if ENABLE(TEXT_AUTOSIZING)
1459     TextAutoSizing&amp; textAutoSizing();
1460 #endif
1461 
<span class="line-modified">1462     Logger&amp; logger();</span>

1463 
<span class="line-modified">1464     void hasStorageAccess(Ref&lt;DeferredPromise&gt;&amp;&amp; passedPromise);</span>
<span class="line-removed">1465     void requestStorageAccess(Ref&lt;DeferredPromise&gt;&amp;&amp; passedPromise);</span>
<span class="line-removed">1466     void setUserGrantsStorageAccessOverride(bool value) { m_grantStorageAccessOverride = value; }</span>
1467 
1468     WEBCORE_EXPORT void setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp;); // For testing.
1469 
<span class="line-removed">1470 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-removed">1471     DocumentAnimationScheduler&amp; animationScheduler();</span>
<span class="line-removed">1472 #endif</span>
<span class="line-removed">1473 </span>
1474     WEBCORE_EXPORT DocumentTimeline&amp; timeline();
1475     DocumentTimeline* existingTimeline() const { return m_timeline.get(); }
1476     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations();
1477 
1478 #if ENABLE(ATTACHMENT_ELEMENT)
1479     void registerAttachmentIdentifier(const String&amp;);
1480     void didInsertAttachmentElement(HTMLAttachmentElement&amp;);
1481     void didRemoveAttachmentElement(HTMLAttachmentElement&amp;);
1482     WEBCORE_EXPORT RefPtr&lt;HTMLAttachmentElement&gt; attachmentForIdentifier(const String&amp;) const;
1483     const HashMap&lt;String, Ref&lt;HTMLAttachmentElement&gt;&gt;&amp; attachmentElementsByIdentifier() const { return m_attachmentIdentifierToElementMap; }
1484 #endif
1485 
1486 #if ENABLE(SERVICE_WORKER)
1487     void setServiceWorkerConnection(SWClientConnection*);
1488 #endif
1489 
1490     void addApplicationStateChangeListener(ApplicationStateChangeListener&amp;);
1491     void removeApplicationStateChangeListener(ApplicationStateChangeListener&amp;);
1492     void forEachApplicationStateChangeListener(const Function&lt;void(ApplicationStateChangeListener&amp;)&gt;&amp;);
1493 
1494 #if ENABLE(IOS_TOUCH_EVENTS)
1495     bool handlingTouchEvent() const { return m_handlingTouchEvent; }
1496 #endif
1497 
1498 #if ENABLE(RESOURCE_LOAD_STATISTICS)
<span class="line-modified">1499     bool hasRequestedPageSpecificStorageAccessWithUserInteraction(const String&amp; primaryDomain);</span>
<span class="line-modified">1500     void setHasRequestedPageSpecificStorageAccessWithUserInteraction(const String&amp; primaryDomain);</span>


1501 #endif
1502 
1503     String signedPublicKeyAndChallengeString(unsigned keySizeIndex, const String&amp; challengeString, const URL&amp;);
1504 
<span class="line-removed">1505     void consumeTemporaryTimeUserGesture();</span>
<span class="line-removed">1506 </span>
1507     void registerArticleElement(Element&amp;);
1508     void unregisterArticleElement(Element&amp;);
1509     void updateMainArticleElementAfterLayout();
1510     bool hasMainArticleElement() const { return !!m_mainArticleElement; }
1511 
1512     const CSSRegisteredCustomPropertySet&amp; getCSSRegisteredCustomPropertySet() const { return m_CSSRegisteredPropertySet; }
1513     bool registerCSSProperty(CSSRegisteredCustomProperty&amp;&amp;);
1514 
1515 #if ENABLE(CSS_PAINTING_API)
1516     Worklet&amp; ensurePaintWorklet();
1517     PaintWorkletGlobalScope* paintWorkletGlobalScopeForName(const String&amp; name);
1518     void setPaintWorkletGlobalScopeForName(const String&amp; name, Ref&lt;PaintWorkletGlobalScope&gt;&amp;&amp;);
1519 #endif
1520 
<span class="line-modified">1521     void setAsRunningUserScripts() { m_isRunningUserScripts = true; }</span>
<span class="line-modified">1522     bool isRunningUserScripts() const { return m_isRunningUserScripts; }</span>






1523 
1524     void frameWasDisconnectedFromOwner();
1525 
1526     WEBCORE_EXPORT bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;);
1527     bool hitTest(const HitTestRequest&amp;, const HitTestLocation&amp;, HitTestResult&amp;);
1528 #if !ASSERT_DISABLED
1529     bool inHitTesting() const { return m_inHitTesting; }
1530 #endif
1531 
1532 protected:
1533     enum ConstructionFlags { Synthesized = 1, NonRenderedPlaceholder = 1 &lt;&lt; 1 };
<span class="line-modified">1534     Document(Frame*, const URL&amp;, unsigned = DefaultDocumentClass, unsigned constructionFlags = 0);</span>
1535 
1536     void clearXMLVersion() { m_xmlVersion = String(); }
1537 
1538     virtual Ref&lt;Document&gt; cloneDocumentWithoutChildren() const;
1539 
1540 private:
1541     friend class DocumentParserYieldToken;
1542     friend class Node;
1543     friend class ThrowOnDynamicMarkupInsertionCountIncrementer;
1544     friend class IgnoreOpensDuringUnloadCountIncrementer;
1545     friend class IgnoreDestructiveWriteCountIncrementer;
1546 
1547     bool shouldInheritContentSecurityPolicy() const;
1548 
1549     void updateTitleElement(Element&amp; changingTitleElement);
1550     void willDetachPage() final;
1551     void frameDestroyed() final;
1552 
1553     void commonTeardown();
1554 
</pre>
<hr />
<pre>
1579     Seconds domTimerAlignmentInterval(bool hasReachedMaxNestingLevel) const final;
1580 
1581     void updateTitleFromTitleElement();
1582     void updateTitle(const StringWithDirection&amp;);
1583     void updateBaseURL();
1584 
1585     void invalidateAccessKeyCacheSlowCase();
1586     void buildAccessKeyCache();
1587 
1588     void moveNodeIteratorsToNewDocumentSlowCase(Node&amp;, Document&amp;);
1589 
1590     void loadEventDelayTimerFired();
1591 
1592     void pendingTasksTimerFired();
1593     bool isCookieAverse() const;
1594 
1595     void detachFromFrame();
1596 
1597     template&lt;CollectionType&gt; Ref&lt;HTMLCollection&gt; ensureCachedCollection();
1598 
<span class="line-removed">1599 #if ENABLE(FULLSCREEN_API)</span>
<span class="line-removed">1600     void dispatchFullScreenChangeOrErrorEvent(Deque&lt;RefPtr&lt;Node&gt;&gt;&amp;, const AtomicString&amp; eventName, bool shouldNotifyMediaElement);</span>
<span class="line-removed">1601     void clearFullscreenElementStack();</span>
<span class="line-removed">1602     void popFullscreenElementStack();</span>
<span class="line-removed">1603     void pushFullscreenElementStack(Element&amp;);</span>
<span class="line-removed">1604     void addDocumentToFullScreenChangeEventQueue(Document&amp;);</span>
<span class="line-removed">1605 #endif</span>
<span class="line-removed">1606 </span>
1607     void dispatchDisabledAdaptationsDidChangeForMainFrame();
1608 
1609     void setVisualUpdatesAllowed(ReadyState);
1610     void setVisualUpdatesAllowed(bool);
1611     void visualUpdatesSuppressionTimerFired();
1612 
1613     void addListenerType(ListenerType listenerType) { m_listenerTypes |= listenerType; }
1614 
1615     void didAssociateFormControlsTimerFired();
1616 
1617     void wheelEventHandlersChanged();
1618 
<span class="line-removed">1619 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">1620     void setAnnotatedRegionsDirty(bool f = true) { m_annotatedRegionsDirty = f; }</span>
<span class="line-removed">1621     bool annotatedRegionsDirty() const { return m_annotatedRegionsDirty; }</span>
<span class="line-removed">1622     bool hasAnnotatedRegions () const { return m_hasAnnotatedRegions; }</span>
<span class="line-removed">1623     void setAnnotatedRegions(const Vector&lt;AnnotatedRegionValue&gt;&amp;);</span>
<span class="line-removed">1624     void updateAnnotatedRegions();</span>
<span class="line-removed">1625 #endif</span>
<span class="line-removed">1626 </span>
1627     HttpEquivPolicy httpEquivPolicy() const;
1628     AXObjectCache* existingAXObjectCacheSlow() const;
1629 
1630     // DOM Cookies caching.
1631     const String&amp; cachedDOMCookies() const { return m_cachedDOMCookies; }
1632     void setCachedDOMCookies(const String&amp;);
1633     bool isDOMCookieCacheValid() const { return m_cookieCacheExpiryTimer.isActive(); }
1634     void invalidateDOMCookieCache();
1635     void didLoadResourceSynchronously() final;
1636 
1637     void checkViewportDependentPictures();
1638     void checkAppearanceDependentPictures();
1639 
1640     bool canNavigateInternal(Frame&amp; targetFrame);
1641     bool isNavigationBlockedByThirdPartyIFrameRedirectBlocking(Frame&amp; targetFrame, const URL&amp; destinationURL);
1642 
1643 #if ENABLE(INTERSECTION_OBSERVER)
1644     void notifyIntersectionObserversTimerFired();
1645 #endif
1646 
1647 #if USE(QUICK_LOOK)
1648     bool shouldEnforceQuickLookSandbox() const;
1649     void applyQuickLookSandbox();
1650 #endif
1651 
1652     bool shouldEnforceHTTP09Sandbox() const;
1653 
1654     void platformSuspendOrStopActiveDOMObjects();
1655 
<span class="line-removed">1656     bool domainIsRegisterable(const String&amp;) const;</span>
<span class="line-removed">1657 </span>
<span class="line-removed">1658     void enableTemporaryTimeUserGesture();</span>
<span class="line-removed">1659 </span>
1660     bool isBodyPotentiallyScrollable(HTMLBodyElement&amp;);
1661 
1662     const Ref&lt;Settings&gt; m_settings;
1663 
1664     UniqueRef&lt;Quirks&gt; m_quirks;
1665 
1666     std::unique_ptr&lt;StyleResolver&gt; m_userAgentShadowTreeStyleResolver;
1667 
1668     RefPtr&lt;DOMWindow&gt; m_domWindow;
1669     WeakPtr&lt;Document&gt; m_contextDocument;
1670 
1671     Ref&lt;CachedResourceLoader&gt; m_cachedResourceLoader;
1672     RefPtr&lt;DocumentParser&gt; m_parser;
1673 
1674     unsigned m_parserYieldTokenCount { 0 };
1675 
1676     // Document URLs.
1677     URL m_url; // Document.URL: The URL from which this document was retrieved.
1678     URL m_baseURL; // Node.baseURI: The URL to use when resolving relative URLs.
1679     URL m_baseURLOverride; // An alternative base URL that takes precedence over m_baseURL (but not m_baseElementURL).
</pre>
<hr />
<pre>
1691     // This property is read-only from JavaScript, but writable from Objective C.
1692     String m_documentURI;
1693 
1694     String m_baseTarget;
1695 
1696     // MIME type of the document in case it was cloned or created by XHR.
1697     String m_overriddenMIMEType;
1698 
1699     std::unique_ptr&lt;DOMImplementation&gt; m_implementation;
1700 
1701     RefPtr&lt;Node&gt; m_focusNavigationStartingNode;
1702     RefPtr&lt;Element&gt; m_focusedElement;
1703     RefPtr&lt;Element&gt; m_hoveredElement;
1704     RefPtr&lt;Element&gt; m_activeElement;
1705     RefPtr&lt;Element&gt; m_documentElement;
1706     UserActionElementSet m_userActionElements;
1707 
1708     uint64_t m_domTreeVersion;
1709     static uint64_t s_globalTreeVersion;
1710 
<span class="line-modified">1711     String m_uniqueIdentifier;</span>
1712 
1713     HashSet&lt;NodeIterator*&gt; m_nodeIterators;
1714     HashSet&lt;Range*&gt; m_ranges;
1715 
1716     std::unique_ptr&lt;Style::Scope&gt; m_styleScope;
1717     std::unique_ptr&lt;ExtensionStyleSheets&gt; m_extensionStyleSheets;
1718     RefPtr&lt;StyleSheetList&gt; m_styleSheetList;
1719 
1720     std::unique_ptr&lt;FormController&gt; m_formController;
1721 
1722     Color m_textColor { Color::black };
1723     Color m_linkColor;
1724     Color m_visitedLinkColor;
1725     Color m_activeLinkColor;
1726     const std::unique_ptr&lt;VisitedLinkState&gt; m_visitedLinkState;
1727 
1728     StringWithDirection m_title;
1729     StringWithDirection m_rawTitle;
1730     RefPtr&lt;Element&gt; m_titleElement;
1731 
</pre>
<hr />
<pre>
1756 
1757     String m_xmlEncoding;
1758     String m_xmlVersion;
1759     StandaloneStatus m_xmlStandalone { StandaloneStatus::Unspecified };
1760     bool m_hasXMLDeclaration { false };
1761 
1762     String m_contentLanguage;
1763 
1764     RefPtr&lt;TextResourceDecoder&gt; m_decoder;
1765 
1766     HashSet&lt;LiveNodeList*&gt; m_listsInvalidatedAtDocument;
1767     HashSet&lt;HTMLCollection*&gt; m_collectionsInvalidatedAtDocument;
1768     unsigned m_nodeListAndCollectionCounts[numNodeListInvalidationTypes];
1769 
1770     RefPtr&lt;XPathEvaluator&gt; m_xpathEvaluator;
1771 
1772     std::unique_ptr&lt;SVGDocumentExtensions&gt; m_svgExtensions;
1773     HashSet&lt;SVGUseElement*&gt; m_svgUseElements;
1774 
1775 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">1776     OptionSet&lt;ColorSchemes&gt; m_supportedColorSchemes;</span>
1777     bool m_allowsColorSchemeTransformations { true };
1778 #endif
1779 
<span class="line-removed">1780 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">1781     Vector&lt;AnnotatedRegionValue&gt; m_annotatedRegions;</span>
<span class="line-removed">1782     bool m_hasAnnotatedRegions { false };</span>
<span class="line-removed">1783     bool m_annotatedRegionsDirty { false };</span>
<span class="line-removed">1784 #endif</span>
<span class="line-removed">1785 </span>
1786     HashMap&lt;String, RefPtr&lt;HTMLCanvasElement&gt;&gt; m_cssCanvasElements;
1787 
1788     HashSet&lt;Element*&gt; m_documentSuspensionCallbackElements;
1789     HashSet&lt;Element*&gt; m_mediaVolumeCallbackElements;
1790     HashSet&lt;Element*&gt; m_privateBrowsingStateChangedElements;
1791 #if ENABLE(VIDEO_TRACK)
1792     HashSet&lt;Element*&gt; m_captionPreferencesChangedElements;
1793 #endif
1794 
1795     Element* m_mainArticleElement { nullptr };
1796     HashSet&lt;Element*&gt; m_articleElements;
1797 
1798 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1799     HashSet&lt;HTMLMediaElement*&gt; m_pageScaleFactorChangedElements;
1800     HashSet&lt;HTMLMediaElement*&gt; m_userInterfaceLayoutDirectionChangedElements;
1801 #endif
1802 
1803     HashSet&lt;VisibilityChangeClient*&gt; m_visibilityStateCallbackClients;
1804 #if ENABLE(VIDEO)
1805     HashSet&lt;HTMLMediaElement*&gt; m_allowsMediaDocumentInlinePlaybackElements;
1806 #endif
1807 
1808     std::unique_ptr&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt; m_accessKeyCache;
1809 
1810     std::unique_ptr&lt;ConstantPropertyMap&gt; m_constantPropertyMap;
1811 
1812     std::unique_ptr&lt;SelectorQueryCache&gt; m_selectorQueryCache;
1813 
1814     DocumentClassFlags m_documentClasses;
1815 
1816     RenderPtr&lt;RenderView&gt; m_renderView;
1817     mutable DocumentEventQueue m_eventQueue;
1818 
1819     HashSet&lt;MediaCanStartListener*&gt; m_mediaCanStartListeners;
1820 
1821 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">1822     RefPtr&lt;Element&gt; m_fullScreenElement;</span>
<span class="line-removed">1823     Vector&lt;RefPtr&lt;Element&gt;&gt; m_fullScreenElementStack;</span>
<span class="line-removed">1824     WeakPtr&lt;RenderFullScreen&gt; m_fullScreenRenderer { nullptr };</span>
<span class="line-removed">1825     GenericTaskQueue&lt;Timer&gt; m_fullScreenTaskQueue;</span>
<span class="line-removed">1826     Deque&lt;RefPtr&lt;Node&gt;&gt; m_fullScreenChangeEventTargetQueue;</span>
<span class="line-removed">1827     Deque&lt;RefPtr&lt;Node&gt;&gt; m_fullScreenErrorEventTargetQueue;</span>
<span class="line-removed">1828     LayoutRect m_savedPlaceholderFrameRect;</span>
<span class="line-removed">1829     std::unique_ptr&lt;RenderStyle&gt; m_savedPlaceholderRenderStyle;</span>
<span class="line-removed">1830 </span>
<span class="line-removed">1831     bool m_areKeysEnabledInFullScreen { false };</span>
<span class="line-removed">1832     bool m_isAnimatingFullScreen { false };</span>
<span class="line-removed">1833     bool m_areFullscreenControlsHidden { false };</span>
1834 #endif
1835 
1836     HashSet&lt;HTMLPictureElement*&gt; m_viewportDependentPictures;
1837     HashSet&lt;HTMLPictureElement*&gt; m_appearanceDependentPictures;
1838 
1839 #if ENABLE(INTERSECTION_OBSERVER)
1840     Vector&lt;WeakPtr&lt;IntersectionObserver&gt;&gt; m_intersectionObservers;
1841     Vector&lt;WeakPtr&lt;IntersectionObserver&gt;&gt; m_intersectionObserversWithPendingNotifications;
1842     Timer m_intersectionObserversNotifyTimer;





1843 #endif
1844 
1845     Timer m_loadEventDelayTimer;
1846 
1847     ViewportArguments m_viewportArguments;
<span class="line-removed">1848     Optional&lt;ViewportArguments&gt; m_overrideViewportArguments;</span>
1849     OptionSet&lt;DisabledAdaptations&gt; m_disabledAdaptations;
1850 
1851     DocumentTiming m_documentTiming;
1852 
1853     RefPtr&lt;MediaQueryMatcher&gt; m_mediaQueryMatcher;
1854 
1855 #if ENABLE(TOUCH_EVENTS)
1856     std::unique_ptr&lt;EventTargetSet&gt; m_touchEventTargets;
1857 #endif
<span class="line-modified">1858 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-modified">1859     std::unique_ptr&lt;HashSet&lt;RefPtr&lt;Element&gt;&gt;&gt; m_touchActionElements;</span>
1860 #endif
1861     std::unique_ptr&lt;EventTargetSet&gt; m_wheelEventTargets;
1862 
1863     MonotonicTime m_lastHandledUserGestureTimestamp;

1864 
1865     void clearScriptedAnimationController();
1866     RefPtr&lt;ScriptedAnimationController&gt; m_scriptedAnimationController;
1867 
1868     void notifyMediaCaptureOfVisibilityChanged();
1869 
1870     void didLogMessage(const WTFLogChannel&amp;, WTFLogLevel, Vector&lt;JSONLogValue&gt;&amp;&amp;) final;
1871 
<span class="line-modified">1872 #if ENABLE(RESOURCE_LOAD_STATISTICS)</span>
<span class="line-modified">1873     bool hasFrameSpecificStorageAccess() const;</span>
<span class="line-removed">1874     void setHasFrameSpecificStorageAccess(bool);</span>
<span class="line-removed">1875 #endif</span>
<span class="line-removed">1876 </span>
<span class="line-removed">1877 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
1878     std::unique_ptr&lt;DeviceMotionClient&gt; m_deviceMotionClient;
1879     std::unique_ptr&lt;DeviceMotionController&gt; m_deviceMotionController;
1880     std::unique_ptr&lt;DeviceOrientationClient&gt; m_deviceOrientationClient;
1881     std::unique_ptr&lt;DeviceOrientationController&gt; m_deviceOrientationController;
1882 #endif


1883 
1884     GenericTaskQueue&lt;Timer&gt; m_logMessageTaskQueue;
1885 
1886     Timer m_pendingTasksTimer;
1887     Vector&lt;Task&gt; m_pendingTasks;
1888 
1889 #if ENABLE(TEXT_AUTOSIZING)
1890     std::unique_ptr&lt;TextAutoSizing&gt; m_textAutoSizing;
1891 #endif
1892 
1893     Timer m_visualUpdatesSuppressionTimer;
1894 
1895     void clearSharedObjectPool();
1896     Timer m_sharedObjectPoolClearTimer;
1897 
1898     std::unique_ptr&lt;DocumentSharedObjectPool&gt; m_sharedObjectPool;
1899 
<span class="line-modified">1900     typedef HashMap&lt;AtomicString, std::unique_ptr&lt;Locale&gt;&gt; LocaleIdentifierToLocaleMap;</span>
1901     LocaleIdentifierToLocaleMap m_localeCache;
1902 
1903     RefPtr&lt;Document&gt; m_templateDocument;
<span class="line-modified">1904     Document* m_templateDocumentHost { nullptr }; // Manually managed weakref (backpointer from m_templateDocument).</span>
1905 
1906     Ref&lt;CSSFontSelector&gt; m_fontSelector;
1907 
<span class="line-modified">1908     HashSet&lt;MediaProducer*&gt; m_audioProducers;</span>
1909 
1910     HashSet&lt;ShadowRoot*&gt; m_inDocumentShadowRoots;
1911 
1912 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1913     typedef HashMap&lt;uint64_t, WebCore::MediaPlaybackTargetClient*&gt; TargetIdToClientMap;
1914     TargetIdToClientMap m_idToClientMap;
1915     typedef HashMap&lt;WebCore::MediaPlaybackTargetClient*, uint64_t&gt; TargetClientToIdMap;
1916     TargetClientToIdMap m_clientToIDMap;
1917 #endif
1918 
1919 #if ENABLE(MEDIA_SESSION)
1920     RefPtr&lt;MediaSession&gt; m_defaultMediaSession;
1921 #endif
1922 
1923 #if ENABLE(INDEXED_DATABASE)
1924     RefPtr&lt;IDBClient::IDBConnectionProxy&gt; m_idbConnectionProxy;
1925 #endif
1926 
1927 #if ENABLE(ATTACHMENT_ELEMENT)
1928     HashMap&lt;String, Ref&lt;HTMLAttachmentElement&gt;&gt; m_attachmentIdentifierToElementMap;
</pre>
<hr />
<pre>
2017     bool m_renderTreeBeingDestroyed { false };
2018     bool m_hasPreparedForDestruction { false };
2019 
2020     bool m_hasStyleWithViewportUnits { false };
2021     bool m_isTimerThrottlingEnabled { false };
2022     bool m_isSuspended { false };
2023 
2024     bool m_scheduledTasksAreSuspended { false };
2025     bool m_visualUpdatesAllowed { true };
2026 
2027     bool m_areDeviceMotionAndOrientationUpdatesSuspended { false };
2028     bool m_userDidInteractWithPage { false };
2029 #if !ASSERT_DISABLED
2030     bool m_inHitTesting { false };
2031 #endif
2032 
2033 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
2034     bool m_isTelephoneNumberParsingAllowed { true };
2035 #endif
2036 
<span class="line-removed">2037 #if ENABLE(INTERSECTION_OBSERVER)</span>
<span class="line-removed">2038     bool m_needsForcedIntersectionObservationUpdate { false };</span>
<span class="line-removed">2039 #endif</span>
<span class="line-removed">2040 </span>
2041 #if ENABLE(MEDIA_STREAM)
2042     HashSet&lt;HTMLMediaElement*&gt; m_mediaStreamStateChangeElements;
2043     String m_idHashSalt;
2044     bool m_hasHadCaptureMediaStreamTrack { false };
2045 #endif
2046 
2047 #ifndef NDEBUG
2048     bool m_didDispatchViewportPropertiesChanged { false };
2049 #endif
2050 
2051     OrientationNotifier m_orientationNotifier;
2052     mutable PAL::SessionID m_sessionID;
2053     mutable RefPtr&lt;Logger&gt; m_logger;
2054     RefPtr&lt;StringCallback&gt; m_consoleMessageListener;
2055 
2056     static bool hasEverCreatedAnAXObjectCache;
2057 
<span class="line-removed">2058     bool m_grantStorageAccessOverride { false };</span>
<span class="line-removed">2059 </span>
<span class="line-removed">2060 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-removed">2061     RefPtr&lt;DocumentAnimationScheduler&gt; m_animationScheduler;</span>
<span class="line-removed">2062 #endif</span>
2063     RefPtr&lt;DocumentTimeline&gt; m_timeline;
2064     DocumentIdentifier m_identifier;
2065 
2066 #if ENABLE(SERVICE_WORKER)
2067     RefPtr&lt;SWClientConnection&gt; m_serviceWorkerConnection;
2068 #endif
2069 
2070     HashSet&lt;ApplicationStateChangeListener*&gt; m_applicationStateChangeListeners;
2071 
2072 #if ENABLE(RESOURCE_LOAD_STATISTICS)
<span class="line-modified">2073     String m_primaryDomainRequestedPageSpecificStorageAccessWithUserInteraction { };</span>

2074 #endif
2075 
<span class="line-removed">2076     std::unique_ptr&lt;UserGestureIndicator&gt; m_temporaryUserGesture;</span>
<span class="line-removed">2077 </span>
2078     CSSRegisteredCustomPropertySet m_CSSRegisteredPropertySet;
2079 
2080 #if ENABLE(CSS_PAINTING_API)
2081     RefPtr&lt;Worklet&gt; m_paintWorklet;
2082     HashMap&lt;String, Ref&lt;PaintWorkletGlobalScope&gt;&gt; m_paintWorkletGlobalScopes;
2083 #endif
2084 

2085     bool m_isRunningUserScripts { false };




2086 
2087     Ref&lt;UndoManager&gt; m_undoManager;






2088 };
2089 
2090 Element* eventTargetElementForDocument(Document*);
2091 
2092 inline TextEncoding Document::textEncoding() const
2093 {
2094     if (auto* decoder = this-&gt;decoder())
2095         return decoder-&gt;encoding();
2096     return TextEncoding();
2097 }
2098 
2099 inline const Document* Document::templateDocument() const
2100 {
2101     return m_templateDocumentHost ? this : m_templateDocument.get();
2102 }
2103 
2104 inline AXObjectCache* Document::existingAXObjectCache() const
2105 {
2106     if (!hasEverCreatedAnAXObjectCache)
2107         return nullptr;
2108     return existingAXObjectCacheSlow();
2109 }
2110 
<span class="line-modified">2111 inline Ref&lt;Document&gt; Document::create(const URL&amp; url)</span>
<span class="line-removed">2112 {</span>
<span class="line-removed">2113     return adoptRef(*new Document(nullptr, url));</span>
<span class="line-removed">2114 }</span>
<span class="line-removed">2115 </span>
<span class="line-removed">2116 inline Ref&lt;Document&gt; Document::createNonRenderedPlaceholder(Frame&amp; frame, const URL&amp; url)</span>
2117 {
<span class="line-modified">2118     return adoptRef(*new Document(&amp;frame, url, DefaultDocumentClass, NonRenderedPlaceholder));</span>
2119 }
2120 
2121 inline void Document::invalidateAccessKeyCache()
2122 {
2123     if (UNLIKELY(m_accessKeyCache))
2124         invalidateAccessKeyCacheSlowCase();
2125 }
2126 
2127 // These functions are here because they require the Document class definition and we want to inline them.
2128 
2129 inline ScriptExecutionContext* Node::scriptExecutionContext() const
2130 {
2131     return &amp;document().contextDocument();
2132 }
2133 
2134 inline ActiveDOMObject::ActiveDOMObject(Document&amp; document)
2135     : ActiveDOMObject(static_cast&lt;ScriptExecutionContext*&gt;(&amp;document.contextDocument()))
2136 {
2137 }
2138 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   5  *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
<span class="line-modified">   6  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
   7  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   8  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
   9  * Copyright (C) 2011 Google Inc. All rights reserved.
  10  *
  11  * This library is free software; you can redistribute it and/or
  12  * modify it under the terms of the GNU Library General Public
  13  * License as published by the Free Software Foundation; either
  14  * version 2 of the License, or (at your option) any later version.
  15  *
  16  * This library is distributed in the hope that it will be useful,
  17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19  * Library General Public License for more details.
  20  *
  21  * You should have received a copy of the GNU Library General Public License
  22  * along with this library; see the file COPYING.LIB.  If not, write to
  23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24  * Boston, MA 02110-1301, USA.
  25  *
  26  */
  27 
  28 #pragma once
  29 
  30 #include &quot;CSSRegisteredCustomProperty.h&quot;
  31 #include &quot;Color.h&quot;
  32 #include &quot;ContainerNode.h&quot;
  33 #include &quot;DisabledAdaptations.h&quot;
  34 #include &quot;DocumentEventQueue.h&quot;
  35 #include &quot;DocumentIdentifier.h&quot;
  36 #include &quot;DocumentTiming.h&quot;
<span class="line-added">  37 #include &quot;ElementIdentifier.h&quot;</span>
  38 #include &quot;FocusDirection.h&quot;
  39 #include &quot;FontSelectorClient.h&quot;
  40 #include &quot;FrameDestructionObserver.h&quot;
  41 #include &quot;GenericTaskQueue.h&quot;
<span class="line-added">  42 #include &quot;GraphicsTypes.h&quot;</span>
  43 #include &quot;MediaProducer.h&quot;
  44 #include &quot;MutationObserver.h&quot;
  45 #include &quot;OrientationNotifier.h&quot;
<span class="line-added">  46 #include &quot;PageIdentifier.h&quot;</span>
  47 #include &quot;PlatformEvent.h&quot;
  48 #include &quot;ReferrerPolicy.h&quot;
  49 #include &quot;Region.h&quot;
<span class="line-added">  50 #include &quot;RegistrableDomain.h&quot;</span>
  51 #include &quot;RenderPtr.h&quot;
  52 #include &quot;ScriptExecutionContext.h&quot;
  53 #include &quot;SecurityPolicyViolationEvent.h&quot;
  54 #include &quot;StringWithDirection.h&quot;
  55 #include &quot;StyleColor.h&quot;
  56 #include &quot;Supplementable.h&quot;
  57 #include &quot;TextResourceDecoder.h&quot;
  58 #include &quot;Timer.h&quot;
  59 #include &quot;TreeScope.h&quot;
  60 #include &quot;UserActionElementSet.h&quot;
  61 #include &quot;ViewportArguments.h&quot;
  62 #include &quot;VisibilityState.h&quot;
  63 #include &lt;pal/SessionID.h&gt;
  64 #include &lt;wtf/Deque.h&gt;
  65 #include &lt;wtf/Forward.h&gt;
  66 #include &lt;wtf/HashCountedSet.h&gt;
  67 #include &lt;wtf/HashSet.h&gt;
  68 #include &lt;wtf/Logger.h&gt;
  69 #include &lt;wtf/ObjectIdentifier.h&gt;
  70 #include &lt;wtf/UniqueRef.h&gt;
<span class="line-added">  71 #include &lt;wtf/WeakHashSet.h&gt;</span>
  72 #include &lt;wtf/WeakPtr.h&gt;
<span class="line-modified">  73 #include &lt;wtf/text/AtomStringHash.h&gt;</span>
  74 
  75 #if PLATFORM(IOS_FAMILY)
  76 #include &quot;EventTrackingRegions.h&quot;
  77 #endif
  78 
  79 #if ENABLE(IOS_TOUCH_EVENTS)
  80 #include &lt;wtf/ThreadingPrimitives.h&gt;
  81 #endif
  82 
  83 namespace JSC {
  84 class ExecState;
  85 class InputCursor;
  86 }
  87 
  88 namespace WebCore {
  89 
  90 class ApplicationStateChangeListener;
  91 class AXObjectCache;
  92 class Attr;
  93 class CDATASection;
  94 class CSSCustomPropertyValue;
  95 class CSSFontSelector;
  96 class CSSStyleDeclaration;
  97 class CSSStyleSheet;
  98 class CachedCSSStyleSheet;
  99 class CachedFrameBase;
 100 class CachedResourceLoader;
 101 class CachedScript;
 102 class CanvasRenderingContext2D;
 103 class CharacterData;
 104 class Comment;
 105 class ConstantPropertyMap;
<span class="line-added"> 106 class ContentChangeObserver;</span>
 107 class DOMImplementation;
 108 class DOMSelection;
<span class="line-added"> 109 class DOMTimerHoldingTank;</span>
 110 class DOMWindow;
 111 class DOMWrapperWorld;
 112 class Database;
 113 class DatabaseThread;


 114 class DocumentFragment;
 115 class DocumentLoader;
 116 class DocumentMarkerController;
 117 class DocumentParser;
 118 class DocumentSharedObjectPool;
 119 class DocumentTimeline;
 120 class DocumentType;
<span class="line-added"> 121 class EditingBehavior;</span>
 122 class ExtensionStyleSheets;
 123 class FloatQuad;
 124 class FloatRect;
 125 class FontFaceSet;
 126 class FormController;
 127 class Frame;
 128 class FrameView;
<span class="line-added"> 129 class FullscreenManager;</span>
 130 class HTMLAllCollection;
 131 class HTMLBodyElement;
 132 class HTMLCanvasElement;
 133 class HTMLCollection;
 134 class HTMLDocument;
 135 class HTMLElement;
 136 class HTMLFrameOwnerElement;
 137 class HTMLHeadElement;
 138 class HTMLIFrameElement;
 139 class HTMLImageElement;
 140 class HTMLMapElement;
 141 class HTMLMediaElement;
 142 class HTMLPictureElement;
 143 class HTMLScriptElement;
 144 class HitTestLocation;
 145 class HitTestRequest;
 146 class HitTestResult;
 147 class ImageBitmapRenderingContext;
 148 class IntPoint;
 149 class JSNode;
 150 class LayoutPoint;
 151 class LayoutRect;
 152 class LiveNodeList;
 153 class Locale;
 154 class Location;
 155 class MediaCanStartListener;
 156 class MediaPlaybackTarget;
 157 class MediaPlaybackTargetClient;
 158 class MediaQueryList;
 159 class MediaQueryMatcher;
 160 class MouseEventWithHitTestResults;
 161 class NodeFilter;
 162 class NodeIterator;
 163 class Page;
 164 class PaintWorkletGlobalScope;
 165 class PlatformMouseEvent;
 166 class ProcessingInstruction;
 167 class QualifiedName;
 168 class Quirks;
 169 class Range;

 170 class RenderTreeBuilder;
 171 class RenderView;
 172 class RequestAnimationFrameCallback;
 173 class SVGDocumentExtensions;
 174 class SVGSVGElement;
 175 class SVGUseElement;
 176 class SWClientConnection;
 177 class ScriptElementData;
 178 class ScriptModuleLoader;
 179 class ScriptRunner;
 180 class ScriptableDocumentParser;
 181 class ScriptedAnimationController;
 182 class SecurityOrigin;
 183 class SegmentedString;
 184 class SelectorQuery;
 185 class SelectorQueryCache;
 186 class SerializedScriptValue;
 187 class Settings;
 188 class StringCallback;
 189 class StyleResolver;
 190 class StyleSheet;
 191 class StyleSheetContents;
 192 class StyleSheetList;
 193 class Text;
 194 class TextResourceDecoder;
 195 class TreeWalker;
 196 class UndoManager;
 197 class VisibilityChangeClient;
 198 class VisitedLinkState;
 199 class WebAnimation;
 200 class WebGL2RenderingContext;
 201 class WebGLRenderingContext;
<span class="line-modified"> 202 class GPUCanvasContext;</span>

 203 class WindowProxy;
 204 class Worklet;
 205 class XPathEvaluator;
 206 class XPathExpression;
 207 class XPathNSResolver;
 208 class XPathResult;
 209 
 210 template&lt;typename&gt; class ExceptionOr;
 211 
 212 enum CollectionType;
 213 enum class ShouldOpenExternalURLsPolicy : uint8_t;
 214 
 215 enum class RouteSharingPolicy : uint8_t;
 216 
 217 using PlatformDisplayID = uint32_t;
 218 
 219 #if ENABLE(XSLT)
 220 class TransformSource;
 221 #endif
 222 




 223 #if ENABLE(TOUCH_EVENTS) || ENABLE(IOS_TOUCH_EVENTS)
 224 class Touch;
 225 class TouchList;
 226 #endif
 227 
<span class="line-added"> 228 #if ENABLE(DEVICE_ORIENTATION)</span>
 229 #if PLATFORM(IOS_FAMILY)
 230 class DeviceMotionClient;
 231 class DeviceMotionController;
 232 class DeviceOrientationClient;
 233 class DeviceOrientationController;
 234 #endif
<span class="line-added"> 235 class DeviceOrientationAndMotionAccessController;</span>
<span class="line-added"> 236 #endif</span>
 237 
 238 #if ENABLE(TEXT_AUTOSIZING)
 239 class TextAutoSizing;
 240 #endif
 241 
 242 #if ENABLE(MEDIA_SESSION)
 243 class MediaSession;
 244 #endif
 245 
 246 #if ENABLE(ATTACHMENT_ELEMENT)
 247 class HTMLAttachmentElement;
 248 #endif
 249 
 250 #if ENABLE(INTERSECTION_OBSERVER)
 251 class IntersectionObserver;
 252 #endif
 253 
<span class="line-added"> 254 #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added"> 255 class ResizeObserver;</span>
<span class="line-added"> 256 #endif</span>
<span class="line-added"> 257 </span>
 258 namespace Style {
 259 class Scope;
 260 };
 261 
 262 const uint64_t HTMLMediaElementInvalidID = 0;
 263 
 264 enum PageshowEventPersistence { PageshowEventNotPersisted, PageshowEventPersisted };
 265 
 266 enum NodeListInvalidationType {
 267     DoNotInvalidateOnAttributeChanges,
 268     InvalidateOnClassAttrChange,
 269     InvalidateOnIdNameAttrChange,
 270     InvalidateOnNameAttrChange,
 271     InvalidateOnForTypeAttrChange,
 272     InvalidateForFormControls,
 273     InvalidateOnHRefAttrChange,
 274     InvalidateOnAnyAttrChange,
 275 };
 276 const int numNodeListInvalidationTypes = InvalidateOnAnyAttrChange + 1;
 277 
</pre>
<hr />
<pre>
 307     DisabledByContentDispositionAttachmentSandbox
 308 };
 309 
 310 enum class CustomElementNameValidationStatus {
 311     Valid,
 312     FirstCharacterIsNotLowercaseASCIILetter,
 313     ContainsNoHyphen,
 314     ContainsUppercaseASCIILetter,
 315     ContainsDisallowedCharacter,
 316     ConflictsWithStandardElementName
 317 };
 318 
 319 using RenderingContext = Variant&lt;
 320 #if ENABLE(WEBGL)
 321     RefPtr&lt;WebGLRenderingContext&gt;,
 322 #endif
 323 #if ENABLE(WEBGL2)
 324     RefPtr&lt;WebGL2RenderingContext&gt;,
 325 #endif
 326 #if ENABLE(WEBGPU)
<span class="line-modified"> 327     RefPtr&lt;GPUCanvasContext&gt;,</span>



 328 #endif
 329     RefPtr&lt;ImageBitmapRenderingContext&gt;,
 330     RefPtr&lt;CanvasRenderingContext2D&gt;
 331 &gt;;
 332 
 333 class DocumentParserYieldToken {
 334     WTF_MAKE_FAST_ALLOCATED;
 335 public:
 336     WEBCORE_EXPORT DocumentParserYieldToken(Document&amp;);
 337     WEBCORE_EXPORT ~DocumentParserYieldToken();
 338 
 339 private:
 340     WeakPtr&lt;Document&gt; m_document;
 341 };
 342 
 343 class Document
 344     : public ContainerNode
 345     , public TreeScope
 346     , public ScriptExecutionContext
 347     , public FontSelectorClient

 348     , public FrameDestructionObserver
 349     , public Supplementable&lt;Document&gt;
 350     , public Logger::Observer {
 351     WTF_MAKE_ISO_ALLOCATED(Document);
 352 public:
<span class="line-modified"> 353     static Ref&lt;Document&gt; create(PAL::SessionID, const URL&amp;);</span>
 354     static Ref&lt;Document&gt; createNonRenderedPlaceholder(Frame&amp;, const URL&amp;);
 355     static Ref&lt;Document&gt; create(Document&amp;);
 356 
 357     virtual ~Document();
 358 
 359     // Nodes belonging to this document increase referencingNodeCount -
 360     // these are enough to keep the document from being destroyed, but
 361     // not enough to keep it from removing its children. This allows a
 362     // node that outlives its document to still have a valid document
 363     // pointer without introducing reference cycles.
 364     void incrementReferencingNodeCount()
 365     {
 366         ASSERT(!m_deletionHasBegun);
 367         ++m_referencingNodeCount;
 368     }
 369 
 370     void decrementReferencingNodeCount()
 371     {
 372         ASSERT(!m_deletionHasBegun || !m_referencingNodeCount);
 373         --m_referencingNodeCount;
 374         if (!m_referencingNodeCount &amp;&amp; !refCount()) {
 375 #if !ASSERT_DISABLED
 376             m_deletionHasBegun = true;
 377 #endif
<span class="line-modified"> 378             m_refCountAndParentBit = s_refCountIncrement; // Avoid double destruction through use of Ref&lt;T&gt;/RefPtr&lt;T&gt;. (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)</span>
 379             delete this;
 380         }
 381     }
 382 
 383     unsigned referencingNodeCount() const { return m_referencingNodeCount; }
 384 
 385     void removedLastRef();
 386 
 387     DocumentIdentifier identifier() const { return m_identifier; }
 388 
 389     using DocumentsMap = HashMap&lt;DocumentIdentifier, Document*&gt;;
 390     WEBCORE_EXPORT static DocumentsMap::ValuesIteratorRange allDocuments();
 391     WEBCORE_EXPORT static DocumentsMap&amp; allDocumentsMap();
 392 
<span class="line-added"> 393     WEBCORE_EXPORT ElementIdentifier identifierForElement(Element&amp;);</span>
<span class="line-added"> 394     WEBCORE_EXPORT Element* searchForElementByIdentifier(const ElementIdentifier&amp;);</span>
<span class="line-added"> 395     void identifiedElementWasRemovedFromDocument(Element&amp;);</span>
<span class="line-added"> 396 </span>
 397     MediaQueryMatcher&amp; mediaQueryMatcher();
 398 
 399     using ContainerNode::ref;
 400     using ContainerNode::deref;
 401     using TreeScope::rootNode;
 402 
 403     bool canContainRangeEndPoint() const final { return true; }
 404 
 405     Element* elementForAccessKey(const String&amp; key);
 406     void invalidateAccessKeyCache();
 407 
 408     ExceptionOr&lt;SelectorQuery&amp;&gt; selectorQueryForString(const String&amp;);
 409     void clearSelectorQueryCache();
 410 
 411     void setViewportArguments(const ViewportArguments&amp; viewportArguments) { m_viewportArguments = viewportArguments; }
<span class="line-modified"> 412     WEBCORE_EXPORT ViewportArguments viewportArguments() const;</span>


 413 
 414     OptionSet&lt;DisabledAdaptations&gt; disabledAdaptations() const { return m_disabledAdaptations; }
 415 #ifndef NDEBUG
 416     bool didDispatchViewportPropertiesChanged() const { return m_didDispatchViewportPropertiesChanged; }
 417 #endif
 418 
 419     void setReferrerPolicy(ReferrerPolicy);
 420     ReferrerPolicy referrerPolicy() const { return m_referrerPolicy.valueOr(ReferrerPolicy::NoReferrerWhenDowngrade); }
 421 
 422     WEBCORE_EXPORT DocumentType* doctype() const;
 423 
 424     WEBCORE_EXPORT DOMImplementation&amp; implementation();
 425 
 426     Element* documentElement() const { return m_documentElement.get(); }
 427     static ptrdiff_t documentElementMemoryOffset() { return OBJECT_OFFSETOF(Document, m_documentElement); }
 428 
 429     WEBCORE_EXPORT Element* activeElement();
 430     WEBCORE_EXPORT bool hasFocus() const;
 431 
 432     bool hasManifest() const;
 433 
<span class="line-modified"> 434     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Element&gt;&gt; createElementForBindings(const AtomString&amp; tagName);</span>
 435     WEBCORE_EXPORT Ref&lt;DocumentFragment&gt; createDocumentFragment();
 436     WEBCORE_EXPORT Ref&lt;Text&gt; createTextNode(const String&amp; data);
 437     WEBCORE_EXPORT Ref&lt;Comment&gt; createComment(const String&amp; data);
 438     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;CDATASection&gt;&gt; createCDATASection(const String&amp; data);
 439     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;ProcessingInstruction&gt;&gt; createProcessingInstruction(const String&amp; target, const String&amp; data);
 440     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; createAttribute(const String&amp; name);
<span class="line-modified"> 441     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; createAttributeNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks = false);</span>
 442     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Node&gt;&gt; importNode(Node&amp; nodeToImport, bool deep);
<span class="line-modified"> 443     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Element&gt;&gt; createElementNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName);</span>
 444     WEBCORE_EXPORT Ref&lt;Element&gt; createElement(const QualifiedName&amp;, bool createdByParser);
 445 
<span class="line-modified"> 446     static CustomElementNameValidationStatus validateCustomElementName(const AtomString&amp;);</span>
 447 
 448     WEBCORE_EXPORT RefPtr&lt;Range&gt; caretRangeFromPoint(int x, int y);
 449     RefPtr&lt;Range&gt; caretRangeFromPoint(const LayoutPoint&amp; clientPoint);
 450 
 451     WEBCORE_EXPORT Element* scrollingElementForAPI();
 452     Element* scrollingElement();
 453 
 454     enum ReadyState { Loading, Interactive,  Complete };
 455     ReadyState readyState() const { return m_readyState; }
 456 
 457     WEBCORE_EXPORT String defaultCharsetForLegacyBindings() const;
 458 
 459     String charset() const { return Document::encoding(); }
 460     WEBCORE_EXPORT String characterSetWithUTF8Fallback() const;
 461     TextEncoding textEncoding() const;
 462 
<span class="line-modified"> 463     AtomString encoding() const { return textEncoding().domName(); }</span>
 464 
 465     WEBCORE_EXPORT void setCharset(const String&amp;); // Used by ObjC / GOBject bindings only.
 466 
 467     void setContent(const String&amp;);
 468 
 469     String suggestedMIMEType() const;
 470 
 471     void overrideMIMEType(const String&amp;);
 472     WEBCORE_EXPORT String contentType() const;
 473 
 474     String contentLanguage() const { return m_contentLanguage; }
 475     void setContentLanguage(const String&amp;);
 476 
 477     String xmlEncoding() const { return m_xmlEncoding; }
 478     String xmlVersion() const { return m_xmlVersion; }
 479     enum class StandaloneStatus : uint8_t { Unspecified, Standalone, NotStandalone };
 480     bool xmlStandalone() const { return m_xmlStandalone == StandaloneStatus::Standalone; }
 481     StandaloneStatus xmlStandaloneStatus() const { return m_xmlStandalone; }
 482     bool hasXMLDeclaration() const { return m_hasXMLDeclaration; }
 483 
</pre>
<hr />
<pre>
 490     WEBCORE_EXPORT void setDocumentURI(const String&amp;);
 491 
 492     WEBCORE_EXPORT VisibilityState visibilityState() const;
 493     void visibilityStateChanged();
 494     WEBCORE_EXPORT bool hidden() const;
 495 
 496     void setTimerThrottlingEnabled(bool);
 497     bool isTimerThrottlingEnabled() const { return m_isTimerThrottlingEnabled; }
 498 
 499     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Node&gt;&gt; adoptNode(Node&amp; source);
 500 
 501     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; images();
 502     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; embeds();
 503     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; plugins(); // an alias for embeds() required for the JS DOM bindings.
 504     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; applets();
 505     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; links();
 506     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; forms();
 507     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; anchors();
 508     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; scripts();
 509     Ref&lt;HTMLCollection&gt; all();
<span class="line-modified"> 510     Ref&lt;HTMLCollection&gt; allFilteredByName(const AtomString&amp;);</span>
 511 
<span class="line-modified"> 512     Ref&lt;HTMLCollection&gt; windowNamedItems(const AtomString&amp;);</span>
<span class="line-modified"> 513     Ref&lt;HTMLCollection&gt; documentNamedItems(const AtomString&amp;);</span>
 514 
 515     // Other methods (not part of DOM)
 516     bool isSynthesized() const { return m_isSynthesized; }
 517     bool isHTMLDocument() const { return m_documentClasses &amp; HTMLDocumentClass; }
 518     bool isXHTMLDocument() const { return m_documentClasses &amp; XHTMLDocumentClass; }
 519     bool isXMLDocument() const { return m_documentClasses &amp; XMLDocumentClass; }
 520     bool isImageDocument() const { return m_documentClasses &amp; ImageDocumentClass; }
 521     bool isSVGDocument() const { return m_documentClasses &amp; SVGDocumentClass; }
 522     bool isPluginDocument() const { return m_documentClasses &amp; PluginDocumentClass; }
 523     bool isMediaDocument() const { return m_documentClasses &amp; MediaDocumentClass; }
 524     bool isTextDocument() const { return m_documentClasses &amp; TextDocumentClass; }
 525     bool hasSVGRootNode() const;
 526     virtual bool isFrameSet() const { return false; }
 527 
 528     static ptrdiff_t documentClassesMemoryOffset() { return OBJECT_OFFSETOF(Document, m_documentClasses); }
 529     static uint32_t isHTMLDocumentClassFlag() { return HTMLDocumentClass; }
 530 
 531     bool isSrcdocDocument() const { return m_isSrcdocDocument; }
 532 
 533     bool sawElementsInKnownNamespaces() const { return m_sawElementsInKnownNamespaces; }
</pre>
<hr />
<pre>
 542     WEBCORE_EXPORT StyleSheetList&amp; styleSheets();
 543 
 544     Style::Scope&amp; styleScope() { return *m_styleScope; }
 545     const Style::Scope&amp; styleScope() const { return *m_styleScope; }
 546     ExtensionStyleSheets&amp; extensionStyleSheets() { return *m_extensionStyleSheets; }
 547     const ExtensionStyleSheets&amp; extensionStyleSheets() const { return *m_extensionStyleSheets; }
 548 
 549     bool gotoAnchorNeededAfterStylesheetsLoad() { return m_gotoAnchorNeededAfterStylesheetsLoad; }
 550     void setGotoAnchorNeededAfterStylesheetsLoad(bool b) { m_gotoAnchorNeededAfterStylesheetsLoad = b; }
 551 
 552     void evaluateMediaQueryList();
 553 
 554     FormController&amp; formController();
 555     Vector&lt;String&gt; formElementsState() const;
 556     void setStateForNewFormElements(const Vector&lt;String&gt;&amp;);
 557 
 558     WEBCORE_EXPORT FrameView* view() const; // Can be null.
 559     WEBCORE_EXPORT Page* page() const; // Can be null.
 560     const Settings&amp; settings() const { return m_settings.get(); }
 561     Settings&amp; mutableSettings() { return m_settings.get(); }
<span class="line-added"> 562     EditingBehavior editingBehavior() const;</span>
 563 
 564     const Quirks&amp; quirks() const { return m_quirks; }
 565 
 566     float deviceScaleFactor() const;
 567 
 568     WEBCORE_EXPORT bool useSystemAppearance() const;
<span class="line-added"> 569     WEBCORE_EXPORT bool useElevatedUserInterfaceLevel() const;</span>
 570     WEBCORE_EXPORT bool useDarkAppearance(const RenderStyle*) const;
 571 
 572     OptionSet&lt;StyleColor::Options&gt; styleColorOptions(const RenderStyle*) const;
<span class="line-added"> 573     CompositeOperator compositeOperatorForBackgroundColor(const Color&amp;, const RenderObject&amp;) const;</span>
 574 
 575     WEBCORE_EXPORT Ref&lt;Range&gt; createRange();
 576 
 577     // The last bool parameter is for ObjC bindings.
 578     WEBCORE_EXPORT Ref&lt;NodeIterator&gt; createNodeIterator(Node&amp; root, unsigned long whatToShow = 0xFFFFFFFF, RefPtr&lt;NodeFilter&gt;&amp;&amp; = nullptr, bool = false);
 579 
 580     // The last bool parameter is for ObjC bindings.
 581     WEBCORE_EXPORT Ref&lt;TreeWalker&gt; createTreeWalker(Node&amp; root, unsigned long whatToShow = 0xFFFFFFFF, RefPtr&lt;NodeFilter&gt;&amp;&amp; = nullptr, bool = false);
 582 
 583     // Special support for editing
 584     WEBCORE_EXPORT Ref&lt;CSSStyleDeclaration&gt; createCSSStyleDeclaration();
 585     Ref&lt;Text&gt; createEditingTextNode(const String&amp;);
 586 
 587     enum class ResolveStyleType { Normal, Rebuild };
 588     void resolveStyle(ResolveStyleType = ResolveStyleType::Normal);
 589     WEBCORE_EXPORT bool updateStyleIfNeeded();
 590     bool needsStyleRecalc() const;
 591     unsigned lastStyleUpdateSizeForTesting() const { return m_lastStyleUpdateSizeForTesting; }
 592 
 593     WEBCORE_EXPORT void updateLayout();
</pre>
<hr />
<pre>
 617     // Override ScriptExecutionContext methods to do additional work
 618     WEBCORE_EXPORT bool shouldBypassMainWorldContentSecurityPolicy() const final;
 619     void suspendActiveDOMObjects(ReasonForSuspension) final;
 620     void resumeActiveDOMObjects(ReasonForSuspension) final;
 621     void stopActiveDOMObjects() final;
 622 
 623     void suspendDeviceMotionAndOrientationUpdates();
 624     void resumeDeviceMotionAndOrientationUpdates();
 625 
 626     RenderView* renderView() const { return m_renderView.get(); }
 627 
 628     bool renderTreeBeingDestroyed() const { return m_renderTreeBeingDestroyed; }
 629     bool hasLivingRenderTree() const { return renderView() &amp;&amp; !renderTreeBeingDestroyed(); }
 630 
 631     bool updateLayoutIfDimensionsOutOfDate(Element&amp;, DimensionsCheck = AllDimensionsCheck);
 632 
 633     AXObjectCache* existingAXObjectCache() const;
 634     WEBCORE_EXPORT AXObjectCache* axObjectCache() const;
 635     void clearAXObjectCache();
 636 
<span class="line-modified"> 637     Optional&lt;PageIdentifier&gt; pageID() const;</span>
 638     // to get visually ordered hebrew and arabic pages right
 639     void setVisuallyOrdered();
 640     bool visuallyOrdered() const { return m_visuallyOrdered; }
 641 
 642     WEBCORE_EXPORT DocumentLoader* loader() const;
 643 
<span class="line-modified"> 644     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstDOMWindow, const String&amp; url, const AtomString&amp; name, const String&amp; features);</span>
 645     WEBCORE_EXPORT ExceptionOr&lt;Document&amp;&gt; openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;);
 646 
 647     // FIXME: We should rename this at some point and give back the name &#39;open&#39; to the HTML specified ones.
 648     WEBCORE_EXPORT ExceptionOr&lt;void&gt; open(Document* responsibleDocument = nullptr);
 649     void implicitOpen();
 650 
 651     WEBCORE_EXPORT ExceptionOr&lt;void&gt; closeForBindings();
 652 
 653     // FIXME: We should rename this at some point and give back the name &#39;close&#39; to the HTML specified one.
 654     WEBCORE_EXPORT void close();
 655     // In some situations (see the code), we ignore document.close().
 656     // explicitClose() bypass these checks and actually tries to close the
 657     // input stream.
 658     void explicitClose();
 659     // implicitClose() actually does the work of closing the input stream.
 660     void implicitClose();
 661 
 662     void cancelParsing();
 663 
 664     ExceptionOr&lt;void&gt; write(Document* responsibleDocument, SegmentedString&amp;&amp;);
</pre>
<hr />
<pre>
 746 
 747     MouseEventWithHitTestResults prepareMouseEvent(const HitTestRequest&amp;, const LayoutPoint&amp;, const PlatformMouseEvent&amp;);
 748 
 749     enum class FocusRemovalEventsMode { Dispatch, DoNotDispatch };
 750     WEBCORE_EXPORT bool setFocusedElement(Element*, FocusDirection = FocusDirectionNone,
 751         FocusRemovalEventsMode = FocusRemovalEventsMode::Dispatch);
 752     Element* focusedElement() const { return m_focusedElement.get(); }
 753     UserActionElementSet&amp; userActionElements()  { return m_userActionElements; }
 754     const UserActionElementSet&amp; userActionElements() const { return m_userActionElements; }
 755 
 756     void setFocusNavigationStartingNode(Node*);
 757     Element* focusNavigationStartingNode(FocusDirection) const;
 758 
 759     enum class NodeRemoval { Node, ChildrenOfNode };
 760     void adjustFocusedNodeOnNodeRemoval(Node&amp;, NodeRemoval = NodeRemoval::Node);
 761     void adjustFocusNavigationNodeOnNodeRemoval(Node&amp;, NodeRemoval = NodeRemoval::Node);
 762 
 763     void hoveredElementDidDetach(Element&amp;);
 764     void elementInActiveChainDidDetach(Element&amp;);
 765 
<span class="line-modified"> 766     enum class CaptureChange : uint8_t { Yes, No };</span>
<span class="line-added"> 767     void updateHoverActiveState(const HitTestRequest&amp;, Element*, CaptureChange = CaptureChange::No);</span>
 768 
 769     // Updates for :target (CSS3 selector).
 770     void setCSSTarget(Element*);
 771     Element* cssTarget() const { return m_cssTarget; }
 772     static ptrdiff_t cssTargetMemoryOffset() { return OBJECT_OFFSETOF(Document, m_cssTarget); }
 773 
 774     WEBCORE_EXPORT void scheduleFullStyleRebuild();
 775     void scheduleStyleRecalc();
 776     void unscheduleStyleRecalc();
 777     bool hasPendingStyleRecalc() const;
 778     bool hasPendingFullStyleRebuild() const;
 779 
 780     void registerNodeListForInvalidation(LiveNodeList&amp;);
 781     void unregisterNodeListForInvalidation(LiveNodeList&amp;);
 782     WEBCORE_EXPORT void registerCollection(HTMLCollection&amp;);
 783     void unregisterCollection(HTMLCollection&amp;);
 784     void collectionCachedIdNameMap(const HTMLCollection&amp;);
 785     void collectionWillClearIdNameMap(const HTMLCollection&amp;);
 786     bool shouldInvalidateNodeListAndCollectionCaches() const;
 787     bool shouldInvalidateNodeListAndCollectionCachesForAttribute(const QualifiedName&amp; attrName) const;
</pre>
<hr />
<pre>
 810     bool canAcceptChild(const Node&amp; newChild, const Node* refChild, AcceptChildOperation) const;
 811 
 812     void textInserted(Node&amp;, unsigned offset, unsigned length);
 813     void textRemoved(Node&amp;, unsigned offset, unsigned length);
 814     void textNodesMerged(Text&amp; oldNode, unsigned offset);
 815     void textNodeSplit(Text&amp; oldNode);
 816 
 817     void createDOMWindow();
 818     void takeDOMWindowFrom(Document&amp;);
 819 
 820     DOMWindow* domWindow() const { return m_domWindow.get(); }
 821     // In DOM Level 2, the Document&#39;s DOMWindow is called the defaultView.
 822     WEBCORE_EXPORT WindowProxy* windowProxy() const;
 823 
 824     bool hasBrowsingContext() const { return !!frame(); }
 825 
 826     Document&amp; contextDocument() const;
 827     void setContextDocument(Document&amp; document) { m_contextDocument = makeWeakPtr(document); }
 828 
 829     // Helper functions for forwarding DOMWindow event related tasks to the DOMWindow if it exists.
<span class="line-modified"> 830     void setWindowAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; value, DOMWrapperWorld&amp;);</span>
<span class="line-modified"> 831     void setWindowAttributeEventListener(const AtomString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp;, DOMWrapperWorld&amp;);</span>
<span class="line-modified"> 832     EventListener* getWindowAttributeEventListener(const AtomString&amp; eventType, DOMWrapperWorld&amp;);</span>
 833     WEBCORE_EXPORT void dispatchWindowEvent(Event&amp;, EventTarget* = nullptr);
 834     void dispatchWindowLoadEvent();
 835 
 836     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Event&gt;&gt; createEvent(const String&amp; eventType);
 837 
 838     // keep track of what types of event listeners are registered, so we don&#39;t
 839     // dispatch events unnecessarily
 840     enum ListenerType {
 841         DOMSUBTREEMODIFIED_LISTENER          = 1,
 842         DOMNODEINSERTED_LISTENER             = 1 &lt;&lt; 1,
 843         DOMNODEREMOVED_LISTENER              = 1 &lt;&lt; 2,
 844         DOMNODEREMOVEDFROMDOCUMENT_LISTENER  = 1 &lt;&lt; 3,
 845         DOMNODEINSERTEDINTODOCUMENT_LISTENER = 1 &lt;&lt; 4,
 846         DOMCHARACTERDATAMODIFIED_LISTENER    = 1 &lt;&lt; 5,
 847         OVERFLOWCHANGED_LISTENER             = 1 &lt;&lt; 6,
 848         ANIMATIONEND_LISTENER                = 1 &lt;&lt; 7,
 849         ANIMATIONSTART_LISTENER              = 1 &lt;&lt; 8,
 850         ANIMATIONITERATION_LISTENER          = 1 &lt;&lt; 9,
 851         TRANSITIONEND_LISTENER               = 1 &lt;&lt; 10,
 852         BEFORELOAD_LISTENER                  = 1 &lt;&lt; 11,
 853         SCROLL_LISTENER                      = 1 &lt;&lt; 12,
 854         FORCEWILLBEGIN_LISTENER              = 1 &lt;&lt; 13,
 855         FORCECHANGED_LISTENER                = 1 &lt;&lt; 14,
 856         FORCEDOWN_LISTENER                   = 1 &lt;&lt; 15,
 857         FORCEUP_LISTENER                     = 1 &lt;&lt; 16,
 858         RESIZE_LISTENER                      = 1 &lt;&lt; 17
 859     };
 860 
 861     bool hasListenerType(ListenerType listenerType) const { return (m_listenerTypes &amp; listenerType); }
 862     bool hasListenerTypeForEventType(PlatformEvent::Type) const;
<span class="line-modified"> 863     void addListenerTypeIfNeeded(const AtomString&amp; eventType);</span>
 864 
 865     bool hasMutationObserversOfType(MutationObserver::MutationType type) const
 866     {
 867         return m_mutationObserverTypes &amp; type;
 868     }
 869     bool hasMutationObservers() const { return m_mutationObserverTypes; }
 870     void addMutationObserverTypes(MutationObserverOptions types) { m_mutationObserverTypes |= types; }
 871 
 872     CSSStyleDeclaration* getOverrideStyle(Element*, const String&amp;) { return nullptr; }
 873 
 874     // Handles an HTTP header equivalent set by a meta tag using &lt;meta http-equiv=&quot;...&quot; content=&quot;...&quot;&gt;. This is called
 875     // when a meta tag is encountered during document parsing, and also when a script dynamically changes or adds a meta
 876     // tag. This enables scripts to use meta tags to perform refreshes and set expiry dates in addition to them being
 877     // specified in an HTML file.
 878     void processHttpEquiv(const String&amp; equiv, const String&amp; content, bool isInDocumentHead);
 879 
 880 #if PLATFORM(IOS_FAMILY)
 881     void processFormatDetection(const String&amp;);
 882 
 883     // Called when &lt;meta name=&quot;apple-mobile-web-app-orientations&quot;&gt; changes.
 884     void processWebAppOrientations();
<span class="line-added"> 885 </span>
<span class="line-added"> 886     WEBCORE_EXPORT ContentChangeObserver&amp; contentChangeObserver();</span>
<span class="line-added"> 887 </span>
<span class="line-added"> 888     DOMTimerHoldingTank* domTimerHoldingTankIfExists() { return m_domTimerHoldingTank.get(); }</span>
<span class="line-added"> 889     DOMTimerHoldingTank&amp; domTimerHoldingTank();</span>
 890 #endif
 891 
 892     void processViewport(const String&amp; features, ViewportArguments::Type origin);
 893     void processDisabledAdaptations(const String&amp; adaptations);
 894     void updateViewportArguments();
 895     void processReferrerPolicy(const String&amp; policy, ReferrerPolicySource);
 896 
 897 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified"> 898     void processColorScheme(const String&amp; colorScheme);</span>
 899 #endif
 900 
 901     // Returns the owning element in the parent document.
 902     // Returns nullptr if this is the top level document.
 903     HTMLFrameOwnerElement* ownerElement() const;
 904 
 905     // Used by DOM bindings; no direction known.
 906     const String&amp; title() const { return m_title.string; }
 907     WEBCORE_EXPORT void setTitle(const String&amp;);
 908 
<span class="line-modified"> 909     WEBCORE_EXPORT const AtomString&amp; dir() const;</span>
<span class="line-modified"> 910     WEBCORE_EXPORT void setDir(const AtomString&amp;);</span>
 911 
 912     void titleElementAdded(Element&amp; titleElement);
 913     void titleElementRemoved(Element&amp; titleElement);
 914     void titleElementTextChanged(Element&amp; titleElement);
 915 
 916     WEBCORE_EXPORT ExceptionOr&lt;String&gt; cookie();
 917     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setCookie(const String&amp;);
 918 
 919     WEBCORE_EXPORT String referrer() const;
 920 
 921     WEBCORE_EXPORT String origin() const final;
 922 
 923     WEBCORE_EXPORT String domain() const;
 924     ExceptionOr&lt;void&gt; setDomain(const String&amp; newDomain);
 925 
 926     void overrideLastModified(const Optional&lt;WallTime&gt;&amp;);
 927     WEBCORE_EXPORT String lastModified() const;
 928 
 929     // The cookieURL is used to query the cookie database for this document&#39;s
 930     // cookies. For example, if the cookie URL is http://example.com, we&#39;ll
</pre>
<hr />
<pre>
 952     const URL&amp; firstPartyForCookies() const { return m_firstPartyForCookies; }
 953     void setFirstPartyForCookies(const URL&amp; url) { m_firstPartyForCookies = url; }
 954 
 955     bool isFullyActive() const;
 956 
 957     // The full URL corresponding to the &quot;site for cookies&quot; in the Same-Site Cookies spec.,
 958     // &lt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&gt;. It is either
 959     // the URL of the top-level document or the null URL depending on whether the registrable
 960     // domain of this document&#39;s URL matches the registrable domain of its parent&#39;s/opener&#39;s
 961     // URL. For the top-level document, it is set to the document&#39;s URL.
 962     const URL&amp; siteForCookies() const { return m_siteForCookies; }
 963     void setSiteForCookies(const URL&amp; url) { m_siteForCookies = url; }
 964 
 965     // The following implements the rule from HTML 4 for what valid names are.
 966     // To get this right for all the XML cases, we probably have to improve this or move it
 967     // and make it sensitive to the type of document.
 968     static bool isValidName(const String&amp;);
 969 
 970     // The following breaks a qualified name into a prefix and a local name.
 971     // It also does a validity check, and returns an error if the qualified name is invalid.
<span class="line-modified"> 972     static ExceptionOr&lt;std::pair&lt;AtomString, AtomString&gt;&gt; parseQualifiedName(const String&amp; qualifiedName);</span>
<span class="line-modified"> 973     static ExceptionOr&lt;QualifiedName&gt; parseQualifiedName(const AtomString&amp; namespaceURI, const String&amp; qualifiedName);</span>
 974 
 975     // Checks to make sure prefix and namespace do not conflict (per DOM Core 3)
 976     static bool hasValidNamespaceForElements(const QualifiedName&amp;);
 977     static bool hasValidNamespaceForAttributes(const QualifiedName&amp;);
 978 
 979     // This is the &quot;HTML body element&quot; as defined by CSSOM View spec, the first body child of the
 980     // document element. See http://dev.w3.org/csswg/cssom-view/#the-html-body-element.
 981     WEBCORE_EXPORT HTMLBodyElement* body() const;
 982 
 983     // This is the &quot;body element&quot; as defined by HTML5, the first body or frameset child of the
 984     // document element. See https://html.spec.whatwg.org/multipage/dom.html#the-body-element-2.
 985     WEBCORE_EXPORT HTMLElement* bodyOrFrameset() const;
 986     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setBodyOrFrameset(RefPtr&lt;HTMLElement&gt;&amp;&amp;);
 987 
 988     Location* location() const;
 989 
 990     WEBCORE_EXPORT HTMLHeadElement* head();
 991 
 992     DocumentMarkerController&amp; markers() const { return *m_markers; }
 993 
</pre>
<hr />
<pre>
1016 
1017     HTMLScriptElement* currentScript() const { return !m_currentScriptStack.isEmpty() ? m_currentScriptStack.last().get() : nullptr; }
1018     void pushCurrentScript(HTMLScriptElement*);
1019     void popCurrentScript();
1020 
1021     bool shouldDeferAsynchronousScriptsUntilParsingFinishes() const;
1022 
1023 #if ENABLE(XSLT)
1024     void scheduleToApplyXSLTransforms();
1025     void applyPendingXSLTransformsNowIfScheduled();
1026     RefPtr&lt;Document&gt; transformSourceDocument() { return m_transformSourceDocument; }
1027     void setTransformSourceDocument(Document* document) { m_transformSourceDocument = document; }
1028 
1029     void setTransformSource(std::unique_ptr&lt;TransformSource&gt;);
1030     TransformSource* transformSource() const { return m_transformSource.get(); }
1031 #endif
1032 
1033     void incDOMTreeVersion() { m_domTreeVersion = ++s_globalTreeVersion; }
1034     uint64_t domTreeVersion() const { return m_domTreeVersion; }
1035 
<span class="line-modified">1036     WEBCORE_EXPORT String originIdentifierForPasteboard() const;</span>
1037 
1038     // XPathEvaluator methods
1039     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp;);
1040     WEBCORE_EXPORT Ref&lt;XPathNSResolver&gt; createNSResolver(Node* nodeResolver);
1041     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; evaluate(const String&amp; expression, Node* contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp;, unsigned short type, XPathResult*);
1042 
1043     bool hasNodesWithNonFinalStyle() const { return m_hasNodesWithNonFinalStyle; }
1044     void setHasNodesWithNonFinalStyle() { m_hasNodesWithNonFinalStyle = true; }
1045     bool hasNodesWithMissingStyle() const { return m_hasNodesWithMissingStyle; }
1046     void setHasNodesWithMissingStyle() { m_hasNodesWithMissingStyle = true; }
1047 
1048     // Extension for manipulating canvas drawing contexts for use in CSS
1049     Optional&lt;RenderingContext&gt; getCSSCanvasContext(const String&amp; type, const String&amp; name, int width, int height);
1050     HTMLCanvasElement* getCSSCanvasElement(const String&amp; name);
1051     String nameForCSSCanvasElement(const HTMLCanvasElement&amp;) const;
1052 
1053     bool isDNSPrefetchEnabled() const { return m_isDNSPrefetchEnabled; }
1054     void parseDNSPrefetchControlHeader(const String&amp;);
1055 
1056     WEBCORE_EXPORT void postTask(Task&amp;&amp;) final; // Executes the task on context&#39;s thread asynchronously.
1057 
1058     ScriptedAnimationController* scriptedAnimationController() { return m_scriptedAnimationController.get(); }
1059     void suspendScriptedAnimationControllerCallbacks();
1060     void resumeScriptedAnimationControllerCallbacks();
1061 
<span class="line-added">1062     void updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp);</span>
<span class="line-added">1063     void serviceRequestAnimationFrameCallbacks(DOMHighResTimeStamp timestamp);</span>
<span class="line-added">1064 </span>
1065     void windowScreenDidChange(PlatformDisplayID);
1066 
1067     void finishedParsing();
1068 
1069     enum PageCacheState { NotInPageCache, AboutToEnterPageCache, InPageCache };
1070 
1071     PageCacheState pageCacheState() const { return m_pageCacheState; }
1072     void setPageCacheState(PageCacheState);
1073 
1074     void registerForDocumentSuspensionCallbacks(Element&amp;);
1075     void unregisterForDocumentSuspensionCallbacks(Element&amp;);
1076 
1077     void documentWillBecomeInactive();
1078     void suspend(ReasonForSuspension);
1079     void resume(ReasonForSuspension);
1080 
1081     void registerForMediaVolumeCallbacks(Element&amp;);
1082     void unregisterForMediaVolumeCallbacks(Element&amp;);
1083     void mediaVolumeDidChange();
1084 
1085     bool audioPlaybackRequiresUserGesture() const;
1086     bool videoPlaybackRequiresUserGesture() const;
1087 
1088 #if ENABLE(MEDIA_SESSION)
1089     MediaSession&amp; defaultMediaSession();
1090 #endif
1091 
1092     void registerForPrivateBrowsingStateChangedCallbacks(Element&amp;);
1093     void unregisterForPrivateBrowsingStateChangedCallbacks(Element&amp;);
1094     void storageBlockingStateDidChange();
<span class="line-modified">1095     void privateBrowsingStateDidChange(PAL::SessionID);</span>
1096 
1097 #if ENABLE(VIDEO_TRACK)
1098     void registerForCaptionPreferencesChangedCallbacks(Element&amp;);
1099     void unregisterForCaptionPreferencesChangedCallbacks(Element&amp;);
1100     void captionPreferencesChanged();
1101 #endif
1102 
1103 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1104     void registerForPageScaleFactorChangedCallbacks(HTMLMediaElement&amp;);
1105     void unregisterForPageScaleFactorChangedCallbacks(HTMLMediaElement&amp;);
1106     void pageScaleFactorChangedAndStable();
1107     void registerForUserInterfaceLayoutDirectionChangedCallbacks(HTMLMediaElement&amp;);
1108     void unregisterForUserInterfaceLayoutDirectionChangedCallbacks(HTMLMediaElement&amp;);
1109     void userInterfaceLayoutDirectionChanged();
1110 #endif
1111 
1112     void registerForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp;);
1113     void unregisterForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp;);
1114 
1115 #if ENABLE(VIDEO)
1116     void registerForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp;);
1117     void unregisterForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp;);
1118     void allowsMediaDocumentInlinePlaybackChanged();
1119 
1120     void stopAllMediaPlayback();
1121     void suspendAllMediaPlayback();
1122     void resumeAllMediaPlayback();
<span class="line-added">1123     void suspendAllMediaBuffering();</span>
<span class="line-added">1124     void resumeAllMediaBuffering();</span>
1125 #endif
1126 
1127     WEBCORE_EXPORT void setShouldCreateRenderers(bool);
1128     bool shouldCreateRenderers();
1129 
1130     void setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp;);
1131     TextResourceDecoder* decoder() const { return m_decoder.get(); }
1132 
1133     WEBCORE_EXPORT String displayStringModifiedByEncoding(const String&amp;) const;
1134 
<span class="line-modified">1135     void invalidateRenderingDependentRegions();</span>








1136 
1137     void removeAllEventListeners() final;
1138 
1139     WEBCORE_EXPORT const SVGDocumentExtensions* svgExtensions();
1140     WEBCORE_EXPORT SVGDocumentExtensions&amp; accessSVGExtensions();
1141 
1142     void addSVGUseElement(SVGUseElement&amp;);
1143     void removeSVGUseElement(SVGUseElement&amp;);
1144     HashSet&lt;SVGUseElement*&gt; const svgUseElements() const { return m_svgUseElements; }
1145 
1146     void initSecurityContext();
1147     void initContentSecurityPolicy(ContentSecurityPolicy* previousPolicy);
1148 
1149     void updateURLForPushOrReplaceState(const URL&amp;);
1150     void statePopped(Ref&lt;SerializedScriptValue&gt;&amp;&amp;);
1151 
1152     bool processingLoadEvent() const { return m_processingLoadEvent; }
1153     bool loadEventFinished() const { return m_loadEventFinished; }
1154 
1155     bool isContextThread() const final;
1156     bool isSecureContext() const final;
1157     bool isJSExecutionForbidden() const final { return false; }
1158 
1159     void enqueueWindowEvent(Ref&lt;Event&gt;&amp;&amp;);
1160     void enqueueDocumentEvent(Ref&lt;Event&gt;&amp;&amp;);
1161     void enqueueOverflowEvent(Ref&lt;Event&gt;&amp;&amp;);
1162     void dispatchPageshowEvent(PageshowEventPersistence);
1163     WEBCORE_EXPORT void enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp;);
1164     void enqueueHashchangeEvent(const String&amp; oldURL, const String&amp; newURL);
1165     void dispatchPopstateEvent(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject);
1166     DocumentEventQueue&amp; eventQueue() const final { return m_eventQueue; }
1167 
1168     WEBCORE_EXPORT void addMediaCanStartListener(MediaCanStartListener&amp;);
1169     WEBCORE_EXPORT void removeMediaCanStartListener(MediaCanStartListener&amp;);
1170     MediaCanStartListener* takeAnyMediaCanStartListener();
1171 
1172 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">1173     FullscreenManager&amp; fullscreenManager() { return m_fullscreenManager; }</span>
<span class="line-modified">1174     const FullscreenManager&amp; fullscreenManager() const { return m_fullscreenManager; }</span>


































1175 #endif
1176 
1177 #if ENABLE(POINTER_LOCK)
1178     WEBCORE_EXPORT void exitPointerLock();
1179 #endif
1180 
1181     // Used to allow element that loads data without going through a FrameLoader to delay the &#39;load&#39; event.
1182     void incrementLoadEventDelayCount() { ++m_loadEventDelayCount; }
1183     void decrementLoadEventDelayCount();
1184     bool isDelayingLoadEvent() const { return m_loadEventDelayCount; }
1185     void checkCompleted();
1186 
1187 #if ENABLE(IOS_TOUCH_EVENTS)
1188 #include &lt;WebKitAdditions/DocumentIOS.h&gt;
1189 #endif
1190 
<span class="line-modified">1191 #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-added">1192 #if PLATFORM(IOS_FAMILY)</span>
1193     DeviceMotionController&amp; deviceMotionController() const;
1194     DeviceOrientationController&amp; deviceOrientationController() const;
1195     WEBCORE_EXPORT void simulateDeviceOrientationChange(double alpha, double beta, double gamma);
1196 #endif
1197 
<span class="line-added">1198     DeviceOrientationAndMotionAccessController&amp; deviceOrientationAndMotionAccessController();</span>
<span class="line-added">1199 #endif // ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-added">1200 </span>
1201     const DocumentTiming&amp; timing() const { return m_documentTiming; }
1202 
1203     WEBCORE_EXPORT double monotonicTimestamp() const;
1204 
1205     int requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp;);
1206     void cancelAnimationFrame(int id);
1207 
1208     EventTarget* errorEventTarget() final;
1209     void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) final;
1210 
1211     void initDNSPrefetch();
1212 
1213     void didAddWheelEventHandler(Node&amp;);
1214     void didRemoveWheelEventHandler(Node&amp;, EventHandlerRemoval = EventHandlerRemoval::One);
1215 
1216     MonotonicTime lastHandledUserGestureTimestamp() const { return m_lastHandledUserGestureTimestamp; }
1217     bool hasHadUserInteraction() const { return static_cast&lt;bool&gt;(m_lastHandledUserGestureTimestamp); }
1218     void updateLastHandledUserGestureTimestamp(MonotonicTime);
1219     bool processingUserGestureForMedia() const;
<span class="line-added">1220     void userActivatedMediaFinishedPlaying() { m_userActivatedMediaFinishedPlayingTimestamp = MonotonicTime::now(); }</span>
1221 
1222     void setUserDidInteractWithPage(bool userDidInteractWithPage) { ASSERT(&amp;topDocument() == this); m_userDidInteractWithPage = userDidInteractWithPage; }
1223     bool userDidInteractWithPage() const { ASSERT(&amp;topDocument() == this); return m_userDidInteractWithPage; }
1224 
1225     // Used for testing. Count handlers in the main document, and one per frame which contains handlers.
1226     WEBCORE_EXPORT unsigned wheelEventHandlerCount() const;
1227     WEBCORE_EXPORT unsigned touchEventHandlerCount() const;
1228 
1229     WEBCORE_EXPORT void startTrackingStyleRecalcs();
1230     WEBCORE_EXPORT unsigned styleRecalcCount() const;
1231 
1232 #if ENABLE(TOUCH_EVENTS)
1233     bool hasTouchEventHandlers() const { return (m_touchEventTargets.get()) ? m_touchEventTargets-&gt;size() : false; }
1234     bool touchEventTargetsContain(Node&amp; node) const { return m_touchEventTargets ? m_touchEventTargets-&gt;contains(&amp;node) : false; }
1235 #else
1236     bool hasTouchEventHandlers() const { return false; }
1237     bool touchEventTargetsContain(Node&amp;) const { return false; }
1238 #endif
<span class="line-modified">1239 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)</span>
<span class="line-modified">1240     bool mayHaveElementsWithNonAutoTouchAction() const { return m_mayHaveElementsWithNonAutoTouchAction; }</span>
<span class="line-modified">1241     void setMayHaveElementsWithNonAutoTouchAction() { m_mayHaveElementsWithNonAutoTouchAction = true; }</span>
1242 #endif
1243 
1244     void didAddTouchEventHandler(Node&amp;);
1245     void didRemoveTouchEventHandler(Node&amp;, EventHandlerRemoval = EventHandlerRemoval::One);
1246 
1247     void didRemoveEventTargetNode(Node&amp;);
1248 
1249     const EventTargetSet* touchEventTargets() const
1250     {
1251 #if ENABLE(TOUCH_EVENTS)
1252         return m_touchEventTargets.get();
1253 #else
1254         return nullptr;
1255 #endif
1256     }
1257 
1258     const EventTargetSet* wheelEventTargets() const { return m_wheelEventTargets.get(); }
1259 
1260     typedef std::pair&lt;Region, bool&gt; RegionFixedPair;
1261     RegionFixedPair absoluteEventRegionForNode(Node&amp;);
</pre>
<hr />
<pre>
1267 
1268     bool isInDocumentWrite() { return m_writeRecursionDepth &gt; 0; }
1269 
1270     void suspendScheduledTasks(ReasonForSuspension);
1271     void resumeScheduledTasks(ReasonForSuspension);
1272 
1273 #if ENABLE(CSS_DEVICE_ADAPTATION)
1274     IntSize initialViewportSize() const;
1275 #endif
1276 
1277     void convertAbsoluteToClientQuads(Vector&lt;FloatQuad&gt;&amp;, const RenderStyle&amp;);
1278     void convertAbsoluteToClientRects(Vector&lt;FloatRect&gt;&amp;, const RenderStyle&amp;);
1279     void convertAbsoluteToClientRect(FloatRect&amp;, const RenderStyle&amp;);
1280 
1281     bool hasActiveParser();
1282     void incrementActiveParserCount() { ++m_activeParserCount; }
1283     void decrementActiveParserCount();
1284 
1285     std::unique_ptr&lt;DocumentParserYieldToken&gt; createParserYieldToken()
1286     {
<span class="line-modified">1287         return makeUnique&lt;DocumentParserYieldToken&gt;(*this);</span>
1288     }
1289 
1290     bool hasActiveParserYieldToken() const { return m_parserYieldTokenCount; }
1291 
1292     DocumentSharedObjectPool* sharedObjectPool() { return m_sharedObjectPool.get(); }
1293 
1294     void invalidateMatchedPropertiesCacheAndForceStyleRecalc();
1295 
1296     void didRemoveAllPendingStylesheet();
1297     void didClearStyleResolver();
1298 
1299     bool inStyleRecalc() const { return m_inStyleRecalc; }
1300     bool inRenderTreeUpdate() const { return m_inRenderTreeUpdate; }
1301     bool isResolvingTreeStyle() const { return m_isResolvingTreeStyle; }
1302     void setIsResolvingTreeStyle(bool);
1303 
1304     void updateTextRenderer(Text&amp;, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText);
1305 
1306     // Return a Locale for the default locale if the argument is null or empty.
<span class="line-modified">1307     Locale&amp; getCachedLocale(const AtomString&amp; locale = nullAtom());</span>
1308 
1309     const Document* templateDocument() const;
1310     Document&amp; ensureTemplateDocument();
<span class="line-modified">1311     void setTemplateDocumentHost(Document* templateDocumentHost) { m_templateDocumentHost = makeWeakPtr(templateDocumentHost); }</span>
<span class="line-modified">1312     Document* templateDocumentHost() { return m_templateDocumentHost.get(); }</span>
1313 
1314     void didAssociateFormControl(Element&amp;);
1315     bool hasDisabledFieldsetElement() const { return m_disabledFieldsetElementsCount; }
1316     void addDisabledFieldsetElement() { m_disabledFieldsetElementsCount++; }
1317     void removeDisabledFieldsetElement() { ASSERT(m_disabledFieldsetElementsCount); m_disabledFieldsetElementsCount--; }
1318 
<span class="line-added">1319     void getParserLocation(String&amp; url, unsigned&amp; line, unsigned&amp; column) const;</span>
<span class="line-added">1320 </span>
1321     WEBCORE_EXPORT void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) final;
1322 
1323     // The following addConsoleMessage function is deprecated.
1324     // Callers should try to create the ConsoleMessage themselves.
1325     WEBCORE_EXPORT void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier = 0) final;
1326 
1327     // The following addMessage function is deprecated.
1328     // Callers should try to create the ConsoleMessage themselves.
1329     void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::ExecState* = nullptr, unsigned long requestIdentifier = 0) final;
1330 
1331     SecurityOrigin&amp; securityOrigin() const { return *SecurityContext::securityOrigin(); }
1332     SecurityOrigin&amp; topOrigin() const final { return topDocument().securityOrigin(); }
1333 
1334     Ref&lt;FontFaceSet&gt; fonts();
1335 
1336     void ensurePlugInsInjectedScript(DOMWrapperWorld&amp;);
1337 
1338     void setVisualUpdatesAllowedByClient(bool);
1339 
1340 #if ENABLE(WEB_CRYPTO)
</pre>
<hr />
<pre>
1358     void addPlaybackTargetPickerClient(MediaPlaybackTargetClient&amp;);
1359     void removePlaybackTargetPickerClient(MediaPlaybackTargetClient&amp;);
1360     void showPlaybackTargetPicker(MediaPlaybackTargetClient&amp;, bool, RouteSharingPolicy, const String&amp;);
1361     void playbackTargetPickerClientStateDidChange(MediaPlaybackTargetClient&amp;, MediaProducer::MediaStateFlags);
1362 
1363     void setPlaybackTarget(uint64_t, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;);
1364     void playbackTargetAvailabilityDidChange(uint64_t, bool);
1365     void setShouldPlayToPlaybackTarget(uint64_t, bool);
1366 #endif
1367 
1368     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToPropagate() const;
1369     bool shouldEnforceContentDispositionAttachmentSandbox() const;
1370     void applyContentDispositionAttachmentSandbox();
1371 
1372     void addViewportDependentPicture(HTMLPictureElement&amp;);
1373     void removeViewportDependentPicture(HTMLPictureElement&amp;);
1374 
1375     void addAppearanceDependentPicture(HTMLPictureElement&amp;);
1376     void removeAppearanceDependentPicture(HTMLPictureElement&amp;);
1377 
<span class="line-added">1378     void scheduleTimedRenderingUpdate();</span>
<span class="line-added">1379 </span>
1380 #if ENABLE(INTERSECTION_OBSERVER)
1381     void addIntersectionObserver(IntersectionObserver&amp;);
1382     void removeIntersectionObserver(IntersectionObserver&amp;);
1383     unsigned numberOfIntersectionObservers() const { return m_intersectionObservers.size(); }

1384     void updateIntersectionObservations();
<span class="line-added">1385     void scheduleInitialIntersectionObservationUpdate();</span>
<span class="line-added">1386 #endif</span>
<span class="line-added">1387 </span>
<span class="line-added">1388 #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added">1389     void addResizeObserver(ResizeObserver&amp;);</span>
<span class="line-added">1390     void removeResizeObserver(ResizeObserver&amp;);</span>
<span class="line-added">1391     bool hasResizeObservers();</span>
<span class="line-added">1392     // Return the minDepth of the active observations.</span>
<span class="line-added">1393     size_t gatherResizeObservations(size_t deeperThan);</span>
<span class="line-added">1394     void deliverResizeObservations();</span>
<span class="line-added">1395     bool hasSkippedResizeObservations() const;</span>
<span class="line-added">1396     void setHasSkippedResizeObservations(bool);</span>
<span class="line-added">1397     void updateResizeObservations(Page&amp;);</span>
1398 #endif
1399 
1400 #if ENABLE(MEDIA_STREAM)
1401     void setHasCaptureMediaStreamTrack() { m_hasHadCaptureMediaStreamTrack = true; }
1402     bool hasHadCaptureMediaStreamTrack() const { return m_hasHadCaptureMediaStreamTrack; }
1403     void setDeviceIDHashSalt(const String&amp;);
1404     String deviceIDHashSalt() const { return m_idHashSalt; }
1405     void stopMediaCapture();
1406     void registerForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp;);
1407     void unregisterForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp;);
1408     void mediaStreamCaptureStateChanged();
1409 #endif
1410 
1411 // FIXME: Find a better place for this functionality.
1412 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
1413     // These functions provide a two-level setting:
1414     //    - A user-settable wantsTelephoneNumberParsing (at the Page / WebView level)
1415     //    - A read-only telephoneNumberParsingAllowed which is set by the
1416     //      document if it has the appropriate meta tag.
1417     //    - isTelephoneNumberParsingEnabled() == isTelephoneNumberParsingAllowed() &amp;&amp; page()-&gt;settings()-&gt;isTelephoneNumberParsingEnabled()
1418     WEBCORE_EXPORT bool isTelephoneNumberParsingAllowed() const;
1419     WEBCORE_EXPORT bool isTelephoneNumberParsingEnabled() const;
1420 #endif
1421 
1422     using ContainerNode::setAttributeEventListener;
<span class="line-modified">1423     void setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; value, DOMWrapperWorld&amp; isolatedWorld);</span>
1424 
1425     DOMSelection* getSelection();
1426 
1427     void didInsertInDocumentShadowRoot(ShadowRoot&amp;);
1428     void didRemoveInDocumentShadowRoot(ShadowRoot&amp;);
1429     const HashSet&lt;ShadowRoot*&gt;&amp; inDocumentShadowRoots() const { return m_inDocumentShadowRoots; }
1430 
1431     void attachToCachedFrame(CachedFrameBase&amp;);
1432     void detachFromCachedFrame(CachedFrameBase&amp;);
1433 
1434     ConstantPropertyMap&amp; constantProperties() const { return *m_constantPropertyMap; }
1435 
1436     void orientationChanged(int orientation);
1437     OrientationNotifier&amp; orientationNotifier() { return m_orientationNotifier; }
1438 
<span class="line-modified">1439     WEBCORE_EXPORT const AtomString&amp; bgColor() const;</span>
1440     WEBCORE_EXPORT void setBgColor(const String&amp;);
<span class="line-modified">1441     WEBCORE_EXPORT const AtomString&amp; fgColor() const;</span>
1442     WEBCORE_EXPORT void setFgColor(const String&amp;);
<span class="line-modified">1443     WEBCORE_EXPORT const AtomString&amp; alinkColor() const;</span>
1444     WEBCORE_EXPORT void setAlinkColor(const String&amp;);
<span class="line-modified">1445     WEBCORE_EXPORT const AtomString&amp; linkColorForBindings() const;</span>
1446     WEBCORE_EXPORT void setLinkColorForBindings(const String&amp;);
<span class="line-modified">1447     WEBCORE_EXPORT const AtomString&amp; vlinkColor() const;</span>
1448     WEBCORE_EXPORT void setVlinkColor(const String&amp;);
1449 
1450     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-clear, this method does nothing.
1451     void clear() { }
1452     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-captureevents, this method does nothing.
1453     void captureEvents() { }
1454     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-releaseevents, this method does nothing.
1455     void releaseEvents() { }
1456 
1457 #if ENABLE(TEXT_AUTOSIZING)
1458     TextAutoSizing&amp; textAutoSizing();
1459 #endif
1460 
<span class="line-modified">1461     // For debugging rdar://problem/49877867.</span>
<span class="line-added">1462     void setMayBeDetachedFromFrame(bool mayBeDetachedFromFrame) { m_mayBeDetachedFromFrame = mayBeDetachedFromFrame; }</span>
1463 
<span class="line-modified">1464     Logger&amp; logger();</span>


1465 
1466     WEBCORE_EXPORT void setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp;); // For testing.
1467 




1468     WEBCORE_EXPORT DocumentTimeline&amp; timeline();
1469     DocumentTimeline* existingTimeline() const { return m_timeline.get(); }
1470     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations();
1471 
1472 #if ENABLE(ATTACHMENT_ELEMENT)
1473     void registerAttachmentIdentifier(const String&amp;);
1474     void didInsertAttachmentElement(HTMLAttachmentElement&amp;);
1475     void didRemoveAttachmentElement(HTMLAttachmentElement&amp;);
1476     WEBCORE_EXPORT RefPtr&lt;HTMLAttachmentElement&gt; attachmentForIdentifier(const String&amp;) const;
1477     const HashMap&lt;String, Ref&lt;HTMLAttachmentElement&gt;&gt;&amp; attachmentElementsByIdentifier() const { return m_attachmentIdentifierToElementMap; }
1478 #endif
1479 
1480 #if ENABLE(SERVICE_WORKER)
1481     void setServiceWorkerConnection(SWClientConnection*);
1482 #endif
1483 
1484     void addApplicationStateChangeListener(ApplicationStateChangeListener&amp;);
1485     void removeApplicationStateChangeListener(ApplicationStateChangeListener&amp;);
1486     void forEachApplicationStateChangeListener(const Function&lt;void(ApplicationStateChangeListener&amp;)&gt;&amp;);
1487 
1488 #if ENABLE(IOS_TOUCH_EVENTS)
1489     bool handlingTouchEvent() const { return m_handlingTouchEvent; }
1490 #endif
1491 
1492 #if ENABLE(RESOURCE_LOAD_STATISTICS)
<span class="line-modified">1493     bool hasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp;);</span>
<span class="line-modified">1494     void setHasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp;);</span>
<span class="line-added">1495     WEBCORE_EXPORT void wasLoadedWithDataTransferFromPrevalentResource();</span>
<span class="line-added">1496     void downgradeReferrerToRegistrableDomain();</span>
1497 #endif
1498 
1499     String signedPublicKeyAndChallengeString(unsigned keySizeIndex, const String&amp; challengeString, const URL&amp;);
1500 


1501     void registerArticleElement(Element&amp;);
1502     void unregisterArticleElement(Element&amp;);
1503     void updateMainArticleElementAfterLayout();
1504     bool hasMainArticleElement() const { return !!m_mainArticleElement; }
1505 
1506     const CSSRegisteredCustomPropertySet&amp; getCSSRegisteredCustomPropertySet() const { return m_CSSRegisteredPropertySet; }
1507     bool registerCSSProperty(CSSRegisteredCustomProperty&amp;&amp;);
1508 
1509 #if ENABLE(CSS_PAINTING_API)
1510     Worklet&amp; ensurePaintWorklet();
1511     PaintWorkletGlobalScope* paintWorkletGlobalScopeForName(const String&amp; name);
1512     void setPaintWorkletGlobalScopeForName(const String&amp; name, Ref&lt;PaintWorkletGlobalScope&gt;&amp;&amp;);
1513 #endif
1514 
<span class="line-modified">1515     WEBCORE_EXPORT bool hasEvaluatedUserAgentScripts() const;</span>
<span class="line-modified">1516     WEBCORE_EXPORT bool isRunningUserScripts() const;</span>
<span class="line-added">1517     WEBCORE_EXPORT void setAsRunningUserScripts();</span>
<span class="line-added">1518     void setHasEvaluatedUserAgentScripts();</span>
<span class="line-added">1519 #if ENABLE(APPLE_PAY)</span>
<span class="line-added">1520     WEBCORE_EXPORT bool isApplePayActive() const;</span>
<span class="line-added">1521     WEBCORE_EXPORT void setApplePayIsActive();</span>
<span class="line-added">1522 #endif</span>
1523 
1524     void frameWasDisconnectedFromOwner();
1525 
1526     WEBCORE_EXPORT bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;);
1527     bool hitTest(const HitTestRequest&amp;, const HitTestLocation&amp;, HitTestResult&amp;);
1528 #if !ASSERT_DISABLED
1529     bool inHitTesting() const { return m_inHitTesting; }
1530 #endif
1531 
1532 protected:
1533     enum ConstructionFlags { Synthesized = 1, NonRenderedPlaceholder = 1 &lt;&lt; 1 };
<span class="line-modified">1534     Document(PAL::SessionID, Frame*, const URL&amp;, unsigned = DefaultDocumentClass, unsigned constructionFlags = 0);</span>
1535 
1536     void clearXMLVersion() { m_xmlVersion = String(); }
1537 
1538     virtual Ref&lt;Document&gt; cloneDocumentWithoutChildren() const;
1539 
1540 private:
1541     friend class DocumentParserYieldToken;
1542     friend class Node;
1543     friend class ThrowOnDynamicMarkupInsertionCountIncrementer;
1544     friend class IgnoreOpensDuringUnloadCountIncrementer;
1545     friend class IgnoreDestructiveWriteCountIncrementer;
1546 
1547     bool shouldInheritContentSecurityPolicy() const;
1548 
1549     void updateTitleElement(Element&amp; changingTitleElement);
1550     void willDetachPage() final;
1551     void frameDestroyed() final;
1552 
1553     void commonTeardown();
1554 
</pre>
<hr />
<pre>
1579     Seconds domTimerAlignmentInterval(bool hasReachedMaxNestingLevel) const final;
1580 
1581     void updateTitleFromTitleElement();
1582     void updateTitle(const StringWithDirection&amp;);
1583     void updateBaseURL();
1584 
1585     void invalidateAccessKeyCacheSlowCase();
1586     void buildAccessKeyCache();
1587 
1588     void moveNodeIteratorsToNewDocumentSlowCase(Node&amp;, Document&amp;);
1589 
1590     void loadEventDelayTimerFired();
1591 
1592     void pendingTasksTimerFired();
1593     bool isCookieAverse() const;
1594 
1595     void detachFromFrame();
1596 
1597     template&lt;CollectionType&gt; Ref&lt;HTMLCollection&gt; ensureCachedCollection();
1598 








1599     void dispatchDisabledAdaptationsDidChangeForMainFrame();
1600 
1601     void setVisualUpdatesAllowed(ReadyState);
1602     void setVisualUpdatesAllowed(bool);
1603     void visualUpdatesSuppressionTimerFired();
1604 
1605     void addListenerType(ListenerType listenerType) { m_listenerTypes |= listenerType; }
1606 
1607     void didAssociateFormControlsTimerFired();
1608 
1609     void wheelEventHandlersChanged();
1610 








1611     HttpEquivPolicy httpEquivPolicy() const;
1612     AXObjectCache* existingAXObjectCacheSlow() const;
1613 
1614     // DOM Cookies caching.
1615     const String&amp; cachedDOMCookies() const { return m_cachedDOMCookies; }
1616     void setCachedDOMCookies(const String&amp;);
1617     bool isDOMCookieCacheValid() const { return m_cookieCacheExpiryTimer.isActive(); }
1618     void invalidateDOMCookieCache();
1619     void didLoadResourceSynchronously() final;
1620 
1621     void checkViewportDependentPictures();
1622     void checkAppearanceDependentPictures();
1623 
1624     bool canNavigateInternal(Frame&amp; targetFrame);
1625     bool isNavigationBlockedByThirdPartyIFrameRedirectBlocking(Frame&amp; targetFrame, const URL&amp; destinationURL);
1626 
1627 #if ENABLE(INTERSECTION_OBSERVER)
1628     void notifyIntersectionObserversTimerFired();
1629 #endif
1630 
1631 #if USE(QUICK_LOOK)
1632     bool shouldEnforceQuickLookSandbox() const;
1633     void applyQuickLookSandbox();
1634 #endif
1635 
1636     bool shouldEnforceHTTP09Sandbox() const;
1637 
1638     void platformSuspendOrStopActiveDOMObjects();
1639 




1640     bool isBodyPotentiallyScrollable(HTMLBodyElement&amp;);
1641 
1642     const Ref&lt;Settings&gt; m_settings;
1643 
1644     UniqueRef&lt;Quirks&gt; m_quirks;
1645 
1646     std::unique_ptr&lt;StyleResolver&gt; m_userAgentShadowTreeStyleResolver;
1647 
1648     RefPtr&lt;DOMWindow&gt; m_domWindow;
1649     WeakPtr&lt;Document&gt; m_contextDocument;
1650 
1651     Ref&lt;CachedResourceLoader&gt; m_cachedResourceLoader;
1652     RefPtr&lt;DocumentParser&gt; m_parser;
1653 
1654     unsigned m_parserYieldTokenCount { 0 };
1655 
1656     // Document URLs.
1657     URL m_url; // Document.URL: The URL from which this document was retrieved.
1658     URL m_baseURL; // Node.baseURI: The URL to use when resolving relative URLs.
1659     URL m_baseURLOverride; // An alternative base URL that takes precedence over m_baseURL (but not m_baseElementURL).
</pre>
<hr />
<pre>
1671     // This property is read-only from JavaScript, but writable from Objective C.
1672     String m_documentURI;
1673 
1674     String m_baseTarget;
1675 
1676     // MIME type of the document in case it was cloned or created by XHR.
1677     String m_overriddenMIMEType;
1678 
1679     std::unique_ptr&lt;DOMImplementation&gt; m_implementation;
1680 
1681     RefPtr&lt;Node&gt; m_focusNavigationStartingNode;
1682     RefPtr&lt;Element&gt; m_focusedElement;
1683     RefPtr&lt;Element&gt; m_hoveredElement;
1684     RefPtr&lt;Element&gt; m_activeElement;
1685     RefPtr&lt;Element&gt; m_documentElement;
1686     UserActionElementSet m_userActionElements;
1687 
1688     uint64_t m_domTreeVersion;
1689     static uint64_t s_globalTreeVersion;
1690 
<span class="line-modified">1691     mutable String m_uniqueIdentifier;</span>
1692 
1693     HashSet&lt;NodeIterator*&gt; m_nodeIterators;
1694     HashSet&lt;Range*&gt; m_ranges;
1695 
1696     std::unique_ptr&lt;Style::Scope&gt; m_styleScope;
1697     std::unique_ptr&lt;ExtensionStyleSheets&gt; m_extensionStyleSheets;
1698     RefPtr&lt;StyleSheetList&gt; m_styleSheetList;
1699 
1700     std::unique_ptr&lt;FormController&gt; m_formController;
1701 
1702     Color m_textColor { Color::black };
1703     Color m_linkColor;
1704     Color m_visitedLinkColor;
1705     Color m_activeLinkColor;
1706     const std::unique_ptr&lt;VisitedLinkState&gt; m_visitedLinkState;
1707 
1708     StringWithDirection m_title;
1709     StringWithDirection m_rawTitle;
1710     RefPtr&lt;Element&gt; m_titleElement;
1711 
</pre>
<hr />
<pre>
1736 
1737     String m_xmlEncoding;
1738     String m_xmlVersion;
1739     StandaloneStatus m_xmlStandalone { StandaloneStatus::Unspecified };
1740     bool m_hasXMLDeclaration { false };
1741 
1742     String m_contentLanguage;
1743 
1744     RefPtr&lt;TextResourceDecoder&gt; m_decoder;
1745 
1746     HashSet&lt;LiveNodeList*&gt; m_listsInvalidatedAtDocument;
1747     HashSet&lt;HTMLCollection*&gt; m_collectionsInvalidatedAtDocument;
1748     unsigned m_nodeListAndCollectionCounts[numNodeListInvalidationTypes];
1749 
1750     RefPtr&lt;XPathEvaluator&gt; m_xpathEvaluator;
1751 
1752     std::unique_ptr&lt;SVGDocumentExtensions&gt; m_svgExtensions;
1753     HashSet&lt;SVGUseElement*&gt; m_svgUseElements;
1754 
1755 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">1756     OptionSet&lt;ColorScheme&gt; m_colorScheme;</span>
1757     bool m_allowsColorSchemeTransformations { true };
1758 #endif
1759 






1760     HashMap&lt;String, RefPtr&lt;HTMLCanvasElement&gt;&gt; m_cssCanvasElements;
1761 
1762     HashSet&lt;Element*&gt; m_documentSuspensionCallbackElements;
1763     HashSet&lt;Element*&gt; m_mediaVolumeCallbackElements;
1764     HashSet&lt;Element*&gt; m_privateBrowsingStateChangedElements;
1765 #if ENABLE(VIDEO_TRACK)
1766     HashSet&lt;Element*&gt; m_captionPreferencesChangedElements;
1767 #endif
1768 
1769     Element* m_mainArticleElement { nullptr };
1770     HashSet&lt;Element*&gt; m_articleElements;
1771 
1772 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1773     HashSet&lt;HTMLMediaElement*&gt; m_pageScaleFactorChangedElements;
1774     HashSet&lt;HTMLMediaElement*&gt; m_userInterfaceLayoutDirectionChangedElements;
1775 #endif
1776 
1777     HashSet&lt;VisibilityChangeClient*&gt; m_visibilityStateCallbackClients;
1778 #if ENABLE(VIDEO)
1779     HashSet&lt;HTMLMediaElement*&gt; m_allowsMediaDocumentInlinePlaybackElements;
1780 #endif
1781 
1782     std::unique_ptr&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt; m_accessKeyCache;
1783 
1784     std::unique_ptr&lt;ConstantPropertyMap&gt; m_constantPropertyMap;
1785 
1786     std::unique_ptr&lt;SelectorQueryCache&gt; m_selectorQueryCache;
1787 
1788     DocumentClassFlags m_documentClasses;
1789 
1790     RenderPtr&lt;RenderView&gt; m_renderView;
1791     mutable DocumentEventQueue m_eventQueue;
1792 
1793     HashSet&lt;MediaCanStartListener*&gt; m_mediaCanStartListeners;
1794 
1795 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">1796     UniqueRef&lt;FullscreenManager&gt; m_fullscreenManager;</span>











1797 #endif
1798 
1799     HashSet&lt;HTMLPictureElement*&gt; m_viewportDependentPictures;
1800     HashSet&lt;HTMLPictureElement*&gt; m_appearanceDependentPictures;
1801 
1802 #if ENABLE(INTERSECTION_OBSERVER)
1803     Vector&lt;WeakPtr&lt;IntersectionObserver&gt;&gt; m_intersectionObservers;
1804     Vector&lt;WeakPtr&lt;IntersectionObserver&gt;&gt; m_intersectionObserversWithPendingNotifications;
1805     Timer m_intersectionObserversNotifyTimer;
<span class="line-added">1806     Timer m_intersectionObserversInitialUpdateTimer;</span>
<span class="line-added">1807 #endif</span>
<span class="line-added">1808 </span>
<span class="line-added">1809 #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added">1810     Vector&lt;WeakPtr&lt;ResizeObserver&gt;&gt; m_resizeObservers;</span>
1811 #endif
1812 
1813     Timer m_loadEventDelayTimer;
1814 
1815     ViewportArguments m_viewportArguments;

1816     OptionSet&lt;DisabledAdaptations&gt; m_disabledAdaptations;
1817 
1818     DocumentTiming m_documentTiming;
1819 
1820     RefPtr&lt;MediaQueryMatcher&gt; m_mediaQueryMatcher;
1821 
1822 #if ENABLE(TOUCH_EVENTS)
1823     std::unique_ptr&lt;EventTargetSet&gt; m_touchEventTargets;
1824 #endif
<span class="line-modified">1825 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)</span>
<span class="line-modified">1826     bool m_mayHaveElementsWithNonAutoTouchAction { false };</span>
1827 #endif
1828     std::unique_ptr&lt;EventTargetSet&gt; m_wheelEventTargets;
1829 
1830     MonotonicTime m_lastHandledUserGestureTimestamp;
<span class="line-added">1831     MonotonicTime m_userActivatedMediaFinishedPlayingTimestamp;</span>
1832 
1833     void clearScriptedAnimationController();
1834     RefPtr&lt;ScriptedAnimationController&gt; m_scriptedAnimationController;
1835 
1836     void notifyMediaCaptureOfVisibilityChanged();
1837 
1838     void didLogMessage(const WTFLogChannel&amp;, WTFLogLevel, Vector&lt;JSONLogValue&gt;&amp;&amp;) final;
1839 
<span class="line-modified">1840 #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-modified">1841 #if PLATFORM(IOS_FAMILY)</span>




1842     std::unique_ptr&lt;DeviceMotionClient&gt; m_deviceMotionClient;
1843     std::unique_ptr&lt;DeviceMotionController&gt; m_deviceMotionController;
1844     std::unique_ptr&lt;DeviceOrientationClient&gt; m_deviceOrientationClient;
1845     std::unique_ptr&lt;DeviceOrientationController&gt; m_deviceOrientationController;
1846 #endif
<span class="line-added">1847     std::unique_ptr&lt;DeviceOrientationAndMotionAccessController&gt; m_deviceOrientationAndMotionAccessController;</span>
<span class="line-added">1848 #endif</span>
1849 
1850     GenericTaskQueue&lt;Timer&gt; m_logMessageTaskQueue;
1851 
1852     Timer m_pendingTasksTimer;
1853     Vector&lt;Task&gt; m_pendingTasks;
1854 
1855 #if ENABLE(TEXT_AUTOSIZING)
1856     std::unique_ptr&lt;TextAutoSizing&gt; m_textAutoSizing;
1857 #endif
1858 
1859     Timer m_visualUpdatesSuppressionTimer;
1860 
1861     void clearSharedObjectPool();
1862     Timer m_sharedObjectPoolClearTimer;
1863 
1864     std::unique_ptr&lt;DocumentSharedObjectPool&gt; m_sharedObjectPool;
1865 
<span class="line-modified">1866     typedef HashMap&lt;AtomString, std::unique_ptr&lt;Locale&gt;&gt; LocaleIdentifierToLocaleMap;</span>
1867     LocaleIdentifierToLocaleMap m_localeCache;
1868 
1869     RefPtr&lt;Document&gt; m_templateDocument;
<span class="line-modified">1870     WeakPtr&lt;Document&gt; m_templateDocumentHost; // Manually managed weakref (backpointer from m_templateDocument).</span>
1871 
1872     Ref&lt;CSSFontSelector&gt; m_fontSelector;
1873 
<span class="line-modified">1874     WeakHashSet&lt;MediaProducer&gt; m_audioProducers;</span>
1875 
1876     HashSet&lt;ShadowRoot*&gt; m_inDocumentShadowRoots;
1877 
1878 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1879     typedef HashMap&lt;uint64_t, WebCore::MediaPlaybackTargetClient*&gt; TargetIdToClientMap;
1880     TargetIdToClientMap m_idToClientMap;
1881     typedef HashMap&lt;WebCore::MediaPlaybackTargetClient*, uint64_t&gt; TargetClientToIdMap;
1882     TargetClientToIdMap m_clientToIDMap;
1883 #endif
1884 
1885 #if ENABLE(MEDIA_SESSION)
1886     RefPtr&lt;MediaSession&gt; m_defaultMediaSession;
1887 #endif
1888 
1889 #if ENABLE(INDEXED_DATABASE)
1890     RefPtr&lt;IDBClient::IDBConnectionProxy&gt; m_idbConnectionProxy;
1891 #endif
1892 
1893 #if ENABLE(ATTACHMENT_ELEMENT)
1894     HashMap&lt;String, Ref&lt;HTMLAttachmentElement&gt;&gt; m_attachmentIdentifierToElementMap;
</pre>
<hr />
<pre>
1983     bool m_renderTreeBeingDestroyed { false };
1984     bool m_hasPreparedForDestruction { false };
1985 
1986     bool m_hasStyleWithViewportUnits { false };
1987     bool m_isTimerThrottlingEnabled { false };
1988     bool m_isSuspended { false };
1989 
1990     bool m_scheduledTasksAreSuspended { false };
1991     bool m_visualUpdatesAllowed { true };
1992 
1993     bool m_areDeviceMotionAndOrientationUpdatesSuspended { false };
1994     bool m_userDidInteractWithPage { false };
1995 #if !ASSERT_DISABLED
1996     bool m_inHitTesting { false };
1997 #endif
1998 
1999 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
2000     bool m_isTelephoneNumberParsingAllowed { true };
2001 #endif
2002 




2003 #if ENABLE(MEDIA_STREAM)
2004     HashSet&lt;HTMLMediaElement*&gt; m_mediaStreamStateChangeElements;
2005     String m_idHashSalt;
2006     bool m_hasHadCaptureMediaStreamTrack { false };
2007 #endif
2008 
2009 #ifndef NDEBUG
2010     bool m_didDispatchViewportPropertiesChanged { false };
2011 #endif
2012 
2013     OrientationNotifier m_orientationNotifier;
2014     mutable PAL::SessionID m_sessionID;
2015     mutable RefPtr&lt;Logger&gt; m_logger;
2016     RefPtr&lt;StringCallback&gt; m_consoleMessageListener;
2017 
2018     static bool hasEverCreatedAnAXObjectCache;
2019 





2020     RefPtr&lt;DocumentTimeline&gt; m_timeline;
2021     DocumentIdentifier m_identifier;
2022 
2023 #if ENABLE(SERVICE_WORKER)
2024     RefPtr&lt;SWClientConnection&gt; m_serviceWorkerConnection;
2025 #endif
2026 
2027     HashSet&lt;ApplicationStateChangeListener*&gt; m_applicationStateChangeListeners;
2028 
2029 #if ENABLE(RESOURCE_LOAD_STATISTICS)
<span class="line-modified">2030     RegistrableDomain m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction { };</span>
<span class="line-added">2031     String m_referrerOverride;</span>
2032 #endif
2033 


2034     CSSRegisteredCustomPropertySet m_CSSRegisteredPropertySet;
2035 
2036 #if ENABLE(CSS_PAINTING_API)
2037     RefPtr&lt;Worklet&gt; m_paintWorklet;
2038     HashMap&lt;String, Ref&lt;PaintWorkletGlobalScope&gt;&gt; m_paintWorkletGlobalScopes;
2039 #endif
2040 
<span class="line-added">2041     bool m_hasEvaluatedUserAgentScripts { false };</span>
2042     bool m_isRunningUserScripts { false };
<span class="line-added">2043     bool m_mayBeDetachedFromFrame { true };</span>
<span class="line-added">2044 #if ENABLE(APPLE_PAY)</span>
<span class="line-added">2045     bool m_hasStartedApplePaySession { false };</span>
<span class="line-added">2046 #endif</span>
2047 
2048     Ref&lt;UndoManager&gt; m_undoManager;
<span class="line-added">2049 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">2050     std::unique_ptr&lt;ContentChangeObserver&gt; m_contentChangeObserver;</span>
<span class="line-added">2051     std::unique_ptr&lt;DOMTimerHoldingTank&gt; m_domTimerHoldingTank;</span>
<span class="line-added">2052 #endif</span>
<span class="line-added">2053 </span>
<span class="line-added">2054     HashMap&lt;Element*, ElementIdentifier&gt; m_identifiedElementsMap;</span>
2055 };
2056 
2057 Element* eventTargetElementForDocument(Document*);
2058 
2059 inline TextEncoding Document::textEncoding() const
2060 {
2061     if (auto* decoder = this-&gt;decoder())
2062         return decoder-&gt;encoding();
2063     return TextEncoding();
2064 }
2065 
2066 inline const Document* Document::templateDocument() const
2067 {
2068     return m_templateDocumentHost ? this : m_templateDocument.get();
2069 }
2070 
2071 inline AXObjectCache* Document::existingAXObjectCache() const
2072 {
2073     if (!hasEverCreatedAnAXObjectCache)
2074         return nullptr;
2075     return existingAXObjectCacheSlow();
2076 }
2077 
<span class="line-modified">2078 inline Ref&lt;Document&gt; Document::create(PAL::SessionID sessionID, const URL&amp; url)</span>





2079 {
<span class="line-modified">2080     return adoptRef(*new Document(sessionID, nullptr, url));</span>
2081 }
2082 
2083 inline void Document::invalidateAccessKeyCache()
2084 {
2085     if (UNLIKELY(m_accessKeyCache))
2086         invalidateAccessKeyCacheSlowCase();
2087 }
2088 
2089 // These functions are here because they require the Document class definition and we want to inline them.
2090 
2091 inline ScriptExecutionContext* Node::scriptExecutionContext() const
2092 {
2093     return &amp;document().contextDocument();
2094 }
2095 
2096 inline ActiveDOMObject::ActiveDOMObject(Document&amp; document)
2097     : ActiveDOMObject(static_cast&lt;ScriptExecutionContext*&gt;(&amp;document.contextDocument()))
2098 {
2099 }
2100 
</pre>
</td>
</tr>
</table>
<center><a href="Document.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Document.idl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>