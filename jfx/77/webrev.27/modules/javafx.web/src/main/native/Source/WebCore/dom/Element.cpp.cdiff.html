<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Element.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocumentParser.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Element.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Element.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 53,10 ***</span>
<span class="line-new-header">--- 53,11 ---</span>
  #include &quot;FocusController.h&quot;
  #include &quot;FocusEvent.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;FrameSelection.h&quot;
  #include &quot;FrameView.h&quot;
<span class="line-added">+ #include &quot;FullscreenManager.h&quot;</span>
  #include &quot;HTMLBodyElement.h&quot;
  #include &quot;HTMLCanvasElement.h&quot;
  #include &quot;HTMLCollection.h&quot;
  #include &quot;HTMLDocument.h&quot;
  #include &quot;HTMLHtmlElement.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,10 ***</span>
<span class="line-new-header">--- 78,11 ---</span>
  #include &quot;MutationObserverInterestGroup.h&quot;
  #include &quot;MutationRecord.h&quot;
  #include &quot;NodeRenderStyle.h&quot;
  #include &quot;PlatformWheelEvent.h&quot;
  #include &quot;PointerCaptureController.h&quot;
<span class="line-added">+ #include &quot;PointerEvent.h&quot;</span>
  #include &quot;PointerLockController.h&quot;
  #include &quot;RenderFragmentContainer.h&quot;
  #include &quot;RenderLayer.h&quot;
  #include &quot;RenderLayerBacking.h&quot;
  #include &quot;RenderLayerCompositor.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,13 ***</span>
              return node.get();
      }
      return nullptr;
  }
  
<span class="line-modified">! static Attr* findAttrNodeInList(Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList, const AtomicString&amp; localName, bool shouldIgnoreAttributeCase)</span>
  {
<span class="line-modified">!     const AtomicString&amp; caseAdjustedName = shouldIgnoreAttributeCase ? localName.convertToASCIILowercase() : localName;</span>
      for (auto&amp; node : attrNodeList) {
          if (node-&gt;qualifiedName().localName() == caseAdjustedName)
              return node.get();
      }
      return nullptr;
<span class="line-new-header">--- 167,13 ---</span>
              return node.get();
      }
      return nullptr;
  }
  
<span class="line-modified">! static Attr* findAttrNodeInList(Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList, const AtomString&amp; localName, bool shouldIgnoreAttributeCase)</span>
  {
<span class="line-modified">!     const AtomString&amp; caseAdjustedName = shouldIgnoreAttributeCase ? localName.convertToASCIILowercase() : localName;</span>
      for (auto&amp; node : attrNodeList) {
          if (node-&gt;qualifiedName().localName() == caseAdjustedName)
              return node.get();
      }
      return nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 195,15 ***</span>
<span class="line-new-header">--- 197,26 ---</span>
  
  #if ENABLE(INTERSECTION_OBSERVER)
      disconnectFromIntersectionObservers();
  #endif
  
<span class="line-added">+ #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added">+     disconnectFromResizeObservers();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      removeShadowRoot();
  
      if (hasSyntheticAttrChildNodes())
          detachAllAttrNodesFromElement();
  
<span class="line-added">+ #if ENABLE(CSS_TYPED_OM)</span>
<span class="line-added">+     if (hasRareData()) {</span>
<span class="line-added">+         if (auto* map = elementRareData()-&gt;attributeStyleMap())</span>
<span class="line-added">+             map-&gt;clearElement();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      if (hasPendingResources()) {
          document().accessSVGExtensions().removeElementFromPendingResources(*this);
          ASSERT(!hasPendingResources());
      }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,38 ***</span>
  void Element::setTabIndexExplicitly(int tabIndex)
  {
      ensureElementRareData().setTabIndexExplicitly(tabIndex);
  }
  
<span class="line-modified">! bool Element::tabIndexSetExplicitly() const</span>
  {
<span class="line-modified">!     return hasRareData() &amp;&amp; elementRareData()-&gt;tabIndexSetExplicitly();</span>
  }
  
  bool Element::supportsFocus() const
  {
<span class="line-modified">!     return tabIndexSetExplicitly();</span>
  }
  
  RefPtr&lt;Element&gt; Element::focusDelegate()
  {
      return this;
  }
  
<span class="line-modified">! int Element::tabIndex() const</span>
  {
<span class="line-modified">!     return hasRareData() ? elementRareData()-&gt;tabIndex() : 0;</span>
  }
  
<span class="line-modified">! void Element::setTabIndex(int value)</span>
  {
      setIntegralAttribute(tabindexAttr, value);
  }
  
  bool Element::isKeyboardFocusable(KeyboardEvent*) const
  {
<span class="line-modified">!     return isFocusable() &amp;&amp; tabIndex() &gt;= 0;</span>
  }
  
  bool Element::isMouseFocusable() const
  {
      return isFocusable();
<span class="line-new-header">--- 241,50 ---</span>
  void Element::setTabIndexExplicitly(int tabIndex)
  {
      ensureElementRareData().setTabIndexExplicitly(tabIndex);
  }
  
<span class="line-modified">! Optional&lt;int&gt; Element::tabIndexSetExplicitly() const</span>
  {
<span class="line-modified">!     if (!hasRareData())</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+     return elementRareData()-&gt;tabIndex();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int Element::defaultTabIndex() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return -1;</span>
  }
  
  bool Element::supportsFocus() const
  {
<span class="line-modified">!     return !!tabIndexSetExplicitly();</span>
  }
  
  RefPtr&lt;Element&gt; Element::focusDelegate()
  {
      return this;
  }
  
<span class="line-modified">! int Element::tabIndexForBindings() const</span>
  {
<span class="line-modified">!     auto defaultIndex = defaultTabIndex();</span>
<span class="line-added">+     ASSERT(!defaultIndex || defaultIndex == -1);</span>
<span class="line-added">+     // FIXME: supportsFocus() check shouldn&#39;t be here.</span>
<span class="line-added">+     if (!defaultIndex || supportsFocus())</span>
<span class="line-added">+         return tabIndexSetExplicitly().valueOr(0);</span>
<span class="line-added">+     return defaultIndex;</span>
  }
  
<span class="line-modified">! void Element::setTabIndexForBindings(int value)</span>
  {
      setIntegralAttribute(tabindexAttr, value);
  }
  
  bool Element::isKeyboardFocusable(KeyboardEvent*) const
  {
<span class="line-modified">!     return isFocusable() &amp;&amp; !shouldBeIgnoredInSequentialFocusNavigation() &amp;&amp; tabIndexSetExplicitly().valueOr(0) &gt;= 0;</span>
  }
  
  bool Element::isMouseFocusable() const
  {
      return isFocusable();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 273,11 ***</span>
  static bool isForceEvent(const PlatformMouseEvent&amp; platformEvent)
  {
      return platformEvent.type() == PlatformEvent::MouseForceChanged || platformEvent.type() == PlatformEvent::MouseForceDown || platformEvent.type() == PlatformEvent::MouseForceUp;
  }
  
<span class="line-modified">! bool Element::dispatchMouseEvent(const PlatformMouseEvent&amp; platformEvent, const AtomicString&amp; eventType, int detail, Element* relatedTarget)</span>
  {
      if (isDisabledFormControl())
          return false;
  
      if (isForceEvent(platformEvent) &amp;&amp; !document().hasListenerTypeForEventType(platformEvent.type()))
<span class="line-new-header">--- 298,20 ---</span>
  static bool isForceEvent(const PlatformMouseEvent&amp; platformEvent)
  {
      return platformEvent.type() == PlatformEvent::MouseForceChanged || platformEvent.type() == PlatformEvent::MouseForceDown || platformEvent.type() == PlatformEvent::MouseForceUp;
  }
  
<span class="line-modified">! #if ENABLE(POINTER_EVENTS) &amp;&amp; !ENABLE(TOUCH_EVENTS)</span>
<span class="line-added">+ static bool isCompatibilityMouseEvent(const MouseEvent&amp; mouseEvent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // https://www.w3.org/TR/pointerevents/#compatibility-mapping-with-mouse-events</span>
<span class="line-added">+     const auto&amp; type = mouseEvent.type();</span>
<span class="line-added">+     return type != eventNames().clickEvent &amp;&amp; type != eventNames().mouseoverEvent &amp;&amp; type != eventNames().mouseoutEvent &amp;&amp; type != eventNames().mouseenterEvent &amp;&amp; type != eventNames().mouseleaveEvent;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Element::dispatchMouseEvent(const PlatformMouseEvent&amp; platformEvent, const AtomString&amp; eventType, int detail, Element* relatedTarget)</span>
  {
      if (isDisabledFormControl())
          return false;
  
      if (isForceEvent(platformEvent) &amp;&amp; !document().hasListenerTypeForEventType(platformEvent.type()))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,13 ***</span>
      Ref&lt;MouseEvent&gt; mouseEvent = MouseEvent::create(eventType, document().windowProxy(), platformEvent, detail, relatedTarget);
  
      if (mouseEvent-&gt;type().isEmpty())
          return true; // Shouldn&#39;t happen.
  
      ASSERT(!mouseEvent-&gt;target() || mouseEvent-&gt;target() != relatedTarget);
      dispatchEvent(mouseEvent);
<span class="line-modified">!     bool didNotSwallowEvent = !mouseEvent-&gt;defaultPrevented() &amp;&amp; !mouseEvent-&gt;defaultHandled();</span>
  
      if (mouseEvent-&gt;type() == eventNames().clickEvent &amp;&amp; mouseEvent-&gt;detail() == 2) {
          // Special case: If it&#39;s a double click event, we also send the dblclick event. This is not part
          // of the DOM specs, but is used for compatibility with the ondblclick=&quot;&quot; attribute. This is treated
          // as a separate event in other DOM-compliant browsers like Firefox, and so we do the same.
<span class="line-new-header">--- 320,39 ---</span>
      Ref&lt;MouseEvent&gt; mouseEvent = MouseEvent::create(eventType, document().windowProxy(), platformEvent, detail, relatedTarget);
  
      if (mouseEvent-&gt;type().isEmpty())
          return true; // Shouldn&#39;t happen.
  
<span class="line-added">+     bool didNotSwallowEvent = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">+     if (RuntimeEnabledFeatures::sharedFeatures().pointerEventsEnabled()) {</span>
<span class="line-added">+         if (auto* page = document().page()) {</span>
<span class="line-added">+             auto&amp; pointerCaptureController = page-&gt;pointerCaptureController();</span>
<span class="line-added">+ #if ENABLE(TOUCH_EVENTS)</span>
<span class="line-added">+             if (mouseEvent-&gt;type() != eventNames().clickEvent &amp;&amp; pointerCaptureController.preventsCompatibilityMouseEventsForIdentifier(platformEvent.pointerId()))</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+ #else</span>
<span class="line-added">+             if (auto pointerEvent = pointerCaptureController.pointerEventForMouseEvent(mouseEvent)) {</span>
<span class="line-added">+                 pointerCaptureController.dispatchEvent(*pointerEvent, this);</span>
<span class="line-added">+                 if (isCompatibilityMouseEvent(mouseEvent) &amp;&amp; pointerCaptureController.preventsCompatibilityMouseEventsForIdentifier(pointerEvent-&gt;pointerId()))</span>
<span class="line-added">+                     return false;</span>
<span class="line-added">+                 if (pointerEvent-&gt;defaultPrevented() || pointerEvent-&gt;defaultHandled()) {</span>
<span class="line-added">+                     didNotSwallowEvent = false;</span>
<span class="line-added">+                     if (pointerEvent-&gt;type() == eventNames().pointerdownEvent)</span>
<span class="line-added">+                         return false;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      ASSERT(!mouseEvent-&gt;target() || mouseEvent-&gt;target() != relatedTarget);
      dispatchEvent(mouseEvent);
<span class="line-modified">!     if (mouseEvent-&gt;defaultPrevented() || mouseEvent-&gt;defaultHandled())</span>
<span class="line-added">+         didNotSwallowEvent = false;</span>
  
      if (mouseEvent-&gt;type() == eventNames().clickEvent &amp;&amp; mouseEvent-&gt;detail() == 2) {
          // Special case: If it&#39;s a double click event, we also send the dblclick event. This is not part
          // of the DOM specs, but is used for compatibility with the ondblclick=&quot;&quot; attribute. This is treated
          // as a separate event in other DOM-compliant browsers like Firefox, and so we do the same.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,11 ***</span>
  {
      ElementRareData&amp; rareData = const_cast&lt;Element*&gt;(this)-&gt;ensureElementRareData();
      if (NamedNodeMap* attributeMap = rareData.attributeMap())
          return *attributeMap;
  
<span class="line-modified">!     rareData.setAttributeMap(std::make_unique&lt;NamedNodeMap&gt;(const_cast&lt;Element&amp;&gt;(*this)));</span>
      return *rareData.attributeMap();
  }
  
  Node::NodeType Element::nodeType() const
  {
<span class="line-new-header">--- 487,11 ---</span>
  {
      ElementRareData&amp; rareData = const_cast&lt;Element*&gt;(this)-&gt;ensureElementRareData();
      if (NamedNodeMap* attributeMap = rareData.attributeMap())
          return *attributeMap;
  
<span class="line-modified">!     rareData.setAttributeMap(makeUnique&lt;NamedNodeMap&gt;(const_cast&lt;Element&amp;&gt;(*this)));</span>
      return *rareData.attributeMap();
  }
  
  Node::NodeType Element::nodeType() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,14 ***</span>
      if (elementData()-&gt;styleAttributeIsDirty()) {
          ASSERT(isStyledElement());
          static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
      }
  
<span class="line-modified">!     if (elementData()-&gt;animatedSVGAttributesAreDirty()) {</span>
<span class="line-modified">!         ASSERT(isSVGElement());</span>
<span class="line-removed">-         downcast&lt;SVGElement&gt;(*this).synchronizeAnimatedSVGAttribute(anyQName());</span>
<span class="line-removed">-     }</span>
  }
  
  ALWAYS_INLINE void Element::synchronizeAttribute(const QualifiedName&amp; name) const
  {
      if (!elementData())
<span class="line-new-header">--- 510,12 ---</span>
      if (elementData()-&gt;styleAttributeIsDirty()) {
          ASSERT(isStyledElement());
          static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
      }
  
<span class="line-modified">!     if (isSVGElement())</span>
<span class="line-modified">!         downcast&lt;SVGElement&gt;(const_cast&lt;Element&amp;&gt;(*this)).synchronizeAllAttributes();</span>
  }
  
  ALWAYS_INLINE void Element::synchronizeAttribute(const QualifiedName&amp; name) const
  {
      if (!elementData())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 466,42 ***</span>
          ASSERT_WITH_SECURITY_IMPLICATION(isStyledElement());
          static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
          return;
      }
  
<span class="line-modified">!     if (UNLIKELY(elementData()-&gt;animatedSVGAttributesAreDirty())) {</span>
<span class="line-modified">!         ASSERT(isSVGElement());</span>
<span class="line-removed">-         downcast&lt;SVGElement&gt;(*this).synchronizeAnimatedSVGAttribute(name);</span>
<span class="line-removed">-     }</span>
  }
  
<span class="line-modified">! static ALWAYS_INLINE bool isStyleAttribute(const Element&amp; element, const AtomicString&amp; attributeLocalName)</span>
  {
      if (shouldIgnoreAttributeCase(element))
          return equalLettersIgnoringASCIICase(attributeLocalName, &quot;style&quot;);
      return attributeLocalName == styleAttr-&gt;localName();
  }
  
<span class="line-modified">! ALWAYS_INLINE void Element::synchronizeAttribute(const AtomicString&amp; localName) const</span>
  {
      // This version of synchronizeAttribute() is streamlined for the case where you don&#39;t have a full QualifiedName,
      // e.g when called from DOM API.
      if (!elementData())
          return;
      if (elementData()-&gt;styleAttributeIsDirty() &amp;&amp; isStyleAttribute(*this, localName)) {
          ASSERT_WITH_SECURITY_IMPLICATION(isStyledElement());
          static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
          return;
      }
<span class="line-modified">!     if (elementData()-&gt;animatedSVGAttributesAreDirty()) {</span>
<span class="line-modified">!         // We&#39;re not passing a namespace argument on purpose. SVGNames::*Attr are defined w/o namespaces as well.</span>
<span class="line-modified">!         ASSERT_WITH_SECURITY_IMPLICATION(isSVGElement());</span>
<span class="line-removed">-         downcast&lt;SVGElement&gt;(*this).synchronizeAnimatedSVGAttribute(QualifiedName(nullAtom(), localName, nullAtom()));</span>
<span class="line-removed">-     }</span>
  }
  
<span class="line-modified">! const AtomicString&amp; Element::getAttribute(const QualifiedName&amp; name) const</span>
  {
      if (!elementData())
          return nullAtom();
      synchronizeAttribute(name);
      if (const Attribute* attribute = findAttributeByName(name))
<span class="line-new-header">--- 524,38 ---</span>
          ASSERT_WITH_SECURITY_IMPLICATION(isStyledElement());
          static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
          return;
      }
  
<span class="line-modified">!     if (isSVGElement())</span>
<span class="line-modified">!         downcast&lt;SVGElement&gt;(const_cast&lt;Element&amp;&gt;(*this)).synchronizeAttribute(name);</span>
  }
  
<span class="line-modified">! static ALWAYS_INLINE bool isStyleAttribute(const Element&amp; element, const AtomString&amp; attributeLocalName)</span>
  {
      if (shouldIgnoreAttributeCase(element))
          return equalLettersIgnoringASCIICase(attributeLocalName, &quot;style&quot;);
      return attributeLocalName == styleAttr-&gt;localName();
  }
  
<span class="line-modified">! ALWAYS_INLINE void Element::synchronizeAttribute(const AtomString&amp; localName) const</span>
  {
      // This version of synchronizeAttribute() is streamlined for the case where you don&#39;t have a full QualifiedName,
      // e.g when called from DOM API.
      if (!elementData())
          return;
      if (elementData()-&gt;styleAttributeIsDirty() &amp;&amp; isStyleAttribute(*this, localName)) {
          ASSERT_WITH_SECURITY_IMPLICATION(isStyledElement());
          static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
          return;
      }
<span class="line-modified">! </span>
<span class="line-modified">!     if (isSVGElement())</span>
<span class="line-modified">!         downcast&lt;SVGElement&gt;(const_cast&lt;Element&amp;&gt;(*this)).synchronizeAttribute(QualifiedName(nullAtom(), localName, nullAtom()));</span>
  }
  
<span class="line-modified">! const AtomString&amp; Element::getAttribute(const QualifiedName&amp; name) const</span>
  {
      if (!elementData())
          return nullAtom();
      synchronizeAttribute(name);
      if (const Attribute* attribute = findAttributeByName(name))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 528,11 ***</span>
          return false;
  
      if (!renderer()) {
          // If the node is in a display:none tree it might say it needs style recalc but
          // the whole document is actually up to date.
<span class="line-modified">!         ASSERT(!needsStyleRecalc() || !document().childNeedsStyleRecalc());</span>
  
          // Elements in canvas fallback content are not rendered, but they are allowed to be
          // focusable as long as their canvas is displayed and visible.
          if (auto* canvas = ancestorsOfType&lt;HTMLCanvasElement&gt;(*this).first())
              return canvas-&gt;renderer() &amp;&amp; canvas-&gt;renderer()-&gt;style().visibility() == Visibility::Visible;
<span class="line-new-header">--- 582,12 ---</span>
          return false;
  
      if (!renderer()) {
          // If the node is in a display:none tree it might say it needs style recalc but
          // the whole document is actually up to date.
<span class="line-modified">!         // FIXME: We should be able to assert !needsStyleRecalc() || !document().childNeedsStyleRecalc()</span>
<span class="line-added">+         // but it hits too frequently on websites like Gmail and Microsoft Exchange.</span>
  
          // Elements in canvas fallback content are not rendered, but they are allowed to be
          // focusable as long as their canvas is displayed and visible.
          if (auto* canvas = ancestorsOfType&lt;HTMLCanvasElement&gt;(*this).first())
              return canvas-&gt;renderer() &amp;&amp; canvas-&gt;renderer()-&gt;style().visibility() == Visibility::Visible;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 656,20 ***</span>
  
      if (style-&gt;hasAppearance())
          renderer()-&gt;theme().stateChanged(*renderer(), ControlStates::HoverState);
  }
  
<span class="line-modified">! // FIXME(webkit.org/b/161611): Take into account orientation/direction.</span>
<span class="line-removed">- inline ScrollAlignment toScrollAlignment(Optional&lt;ScrollLogicalPosition&gt; position, bool isVertical)</span>
  {
<span class="line-modified">!     switch (position.valueOr(isVertical ? ScrollLogicalPosition::Start : ScrollLogicalPosition::Nearest)) {</span>
<span class="line-modified">!     case ScrollLogicalPosition::Start:</span>
<span class="line-modified">!         return isVertical ? ScrollAlignment::alignTopAlways : ScrollAlignment::alignLeftAlways;</span>
      case ScrollLogicalPosition::Center:
          return ScrollAlignment::alignCenterAlways;
<span class="line-modified">!     case ScrollLogicalPosition::End:</span>
<span class="line-modified">!         return isVertical ? ScrollAlignment::alignBottomAlways : ScrollAlignment::alignRightAlways;</span>
      case ScrollLogicalPosition::Nearest:
          return ScrollAlignment::alignToEdgeIfNeeded;
      default:
          ASSERT_NOT_REACHED();
          return ScrollAlignment::alignToEdgeIfNeeded;
<span class="line-new-header">--- 711,88 ---</span>
  
      if (style-&gt;hasAppearance())
          renderer()-&gt;theme().stateChanged(*renderer(), ControlStates::HoverState);
  }
  
<span class="line-modified">! inline ScrollAlignment toScrollAlignmentForInlineDirection(Optional&lt;ScrollLogicalPosition&gt; position, WritingMode writingMode, bool isLTR)</span>
  {
<span class="line-modified">!     switch (position.valueOr(ScrollLogicalPosition::Nearest)) {</span>
<span class="line-modified">!     case ScrollLogicalPosition::Start: {</span>
<span class="line-modified">!         switch (writingMode) {</span>
<span class="line-added">+         case TopToBottomWritingMode:</span>
<span class="line-added">+         case BottomToTopWritingMode: {</span>
<span class="line-added">+             return isLTR ? ScrollAlignment::alignLeftAlways : ScrollAlignment::alignRightAlways;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case LeftToRightWritingMode:</span>
<span class="line-added">+         case RightToLeftWritingMode: {</span>
<span class="line-added">+             return isLTR ? ScrollAlignment::alignTopAlways : ScrollAlignment::alignBottomAlways;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             ASSERT_NOT_REACHED();</span>
<span class="line-added">+             return ScrollAlignment::alignLeftAlways;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
      case ScrollLogicalPosition::Center:
          return ScrollAlignment::alignCenterAlways;
<span class="line-modified">!     case ScrollLogicalPosition::End: {</span>
<span class="line-modified">!         switch (writingMode) {</span>
<span class="line-added">+         case TopToBottomWritingMode:</span>
<span class="line-added">+         case BottomToTopWritingMode: {</span>
<span class="line-added">+             return isLTR ? ScrollAlignment::alignRightAlways : ScrollAlignment::alignLeftAlways;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case LeftToRightWritingMode:</span>
<span class="line-added">+         case RightToLeftWritingMode: {</span>
<span class="line-added">+             return isLTR ? ScrollAlignment::alignBottomAlways : ScrollAlignment::alignTopAlways;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             ASSERT_NOT_REACHED();</span>
<span class="line-added">+             return ScrollAlignment::alignRightAlways;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case ScrollLogicalPosition::Nearest:</span>
<span class="line-added">+         return ScrollAlignment::alignToEdgeIfNeeded;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return ScrollAlignment::alignToEdgeIfNeeded;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline ScrollAlignment toScrollAlignmentForBlockDirection(Optional&lt;ScrollLogicalPosition&gt; position, WritingMode writingMode)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (position.valueOr(ScrollLogicalPosition::Start)) {</span>
<span class="line-added">+     case ScrollLogicalPosition::Start: {</span>
<span class="line-added">+         switch (writingMode) {</span>
<span class="line-added">+         case TopToBottomWritingMode:</span>
<span class="line-added">+             return ScrollAlignment::alignTopAlways;</span>
<span class="line-added">+         case BottomToTopWritingMode:</span>
<span class="line-added">+             return ScrollAlignment::alignBottomAlways;</span>
<span class="line-added">+         case LeftToRightWritingMode:</span>
<span class="line-added">+             return ScrollAlignment::alignLeftAlways;</span>
<span class="line-added">+         case RightToLeftWritingMode:</span>
<span class="line-added">+             return ScrollAlignment::alignRightAlways;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             ASSERT_NOT_REACHED();</span>
<span class="line-added">+             return ScrollAlignment::alignTopAlways;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case ScrollLogicalPosition::Center:</span>
<span class="line-added">+         return ScrollAlignment::alignCenterAlways;</span>
<span class="line-added">+     case ScrollLogicalPosition::End: {</span>
<span class="line-added">+         switch (writingMode) {</span>
<span class="line-added">+         case TopToBottomWritingMode:</span>
<span class="line-added">+             return ScrollAlignment::alignBottomAlways;</span>
<span class="line-added">+         case BottomToTopWritingMode:</span>
<span class="line-added">+             return ScrollAlignment::alignTopAlways;</span>
<span class="line-added">+         case LeftToRightWritingMode:</span>
<span class="line-added">+             return ScrollAlignment::alignRightAlways;</span>
<span class="line-added">+         case RightToLeftWritingMode:</span>
<span class="line-added">+             return ScrollAlignment::alignLeftAlways;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             ASSERT_NOT_REACHED();</span>
<span class="line-added">+             return ScrollAlignment::alignBottomAlways;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
      case ScrollLogicalPosition::Nearest:
          return ScrollAlignment::alignToEdgeIfNeeded;
      default:
          ASSERT_NOT_REACHED();
          return ScrollAlignment::alignToEdgeIfNeeded;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 694,13 ***</span>
              options = WTF::get&lt;ScrollIntoViewOptions&gt;(value);
          else if (!WTF::get&lt;bool&gt;(value))
              options.blockPosition = ScrollLogicalPosition::End;
      }
  
<span class="line-modified">!     ScrollAlignment alignX = toScrollAlignment(options.inlinePosition, false);</span>
<span class="line-modified">!     ScrollAlignment alignY = toScrollAlignment(options.blockPosition, true);</span>
<span class="line-modified">!     renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, alignX, alignY, ShouldAllowCrossOriginScrolling::No });</span>
  }
  
  void Element::scrollIntoView(bool alignToTop)
  {
      document().updateLayoutIgnorePendingStylesheets();
<span class="line-new-header">--- 817,22 ---</span>
              options = WTF::get&lt;ScrollIntoViewOptions&gt;(value);
          else if (!WTF::get&lt;bool&gt;(value))
              options.blockPosition = ScrollLogicalPosition::End;
      }
  
<span class="line-modified">!     auto writingMode = renderer()-&gt;style().writingMode();</span>
<span class="line-modified">!     ScrollAlignment alignX = toScrollAlignmentForInlineDirection(options.inlinePosition, writingMode, renderer()-&gt;style().isLeftToRightDirection());</span>
<span class="line-modified">!     ScrollAlignment alignY = toScrollAlignmentForBlockDirection(options.blockPosition, writingMode);</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool isHorizontal = renderer()-&gt;style().isHorizontalWritingMode();</span>
<span class="line-added">+     ScrollRectToVisibleOptions visibleOptions {</span>
<span class="line-added">+         SelectionRevealMode::Reveal,</span>
<span class="line-added">+         isHorizontal ? alignX : alignY,</span>
<span class="line-added">+         isHorizontal ? alignY : alignX,</span>
<span class="line-added">+         ShouldAllowCrossOriginScrolling::No</span>
<span class="line-added">+     };</span>
<span class="line-added">+     renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, visibleOptions);</span>
  }
  
  void Element::scrollIntoView(bool alignToTop)
  {
      document().updateLayoutIgnorePendingStylesheets();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 791,12 ***</span>
  
      ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options,
          adjustForAbsoluteZoom(renderer-&gt;scrollLeft(), *renderer),
          adjustForAbsoluteZoom(renderer-&gt;scrollTop(), *renderer)
      );
<span class="line-modified">!     renderer-&gt;setScrollLeft(clampToInteger(scrollToOptions.left.value() * renderer-&gt;style().effectiveZoom()), clamping);</span>
<span class="line-modified">!     renderer-&gt;setScrollTop(clampToInteger(scrollToOptions.top.value() * renderer-&gt;style().effectiveZoom()), clamping);</span>
  }
  
  void Element::scrollTo(double x, double y)
  {
      scrollTo({ x, y });
<span class="line-new-header">--- 923,12 ---</span>
  
      ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options,
          adjustForAbsoluteZoom(renderer-&gt;scrollLeft(), *renderer),
          adjustForAbsoluteZoom(renderer-&gt;scrollTop(), *renderer)
      );
<span class="line-modified">!     renderer-&gt;setScrollLeft(clampToInteger(scrollToOptions.left.value() * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic, clamping);</span>
<span class="line-modified">!     renderer-&gt;setScrollTop(clampToInteger(scrollToOptions.top.value() * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic, clamping);</span>
  }
  
  void Element::scrollTo(double x, double y)
  {
      scrollTo({ x, y });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1113,13 ***</span>
              frame-&gt;view()-&gt;setScrollPosition(IntPoint(static_cast&lt;int&gt;(newLeft * frame-&gt;pageZoomFactor() * frame-&gt;frameScaleFactor()), frame-&gt;view()-&gt;scrollY()));
          return;
      }
  
      if (auto* renderer = renderBox()) {
<span class="line-modified">!         renderer-&gt;setScrollLeft(static_cast&lt;int&gt;(newLeft * renderer-&gt;style().effectiveZoom()));</span>
          if (auto* scrollableArea = renderer-&gt;layer())
<span class="line-modified">!             scrollableArea-&gt;setScrolledProgrammatically(true);</span>
      }
  }
  
  void Element::setScrollTop(int newTop)
  {
<span class="line-new-header">--- 1245,13 ---</span>
              frame-&gt;view()-&gt;setScrollPosition(IntPoint(static_cast&lt;int&gt;(newLeft * frame-&gt;pageZoomFactor() * frame-&gt;frameScaleFactor()), frame-&gt;view()-&gt;scrollY()));
          return;
      }
  
      if (auto* renderer = renderBox()) {
<span class="line-modified">!         renderer-&gt;setScrollLeft(static_cast&lt;int&gt;(newLeft * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic);</span>
          if (auto* scrollableArea = renderer-&gt;layer())
<span class="line-modified">!             scrollableArea-&gt;setScrollShouldClearLatchedState(true);</span>
      }
  }
  
  void Element::setScrollTop(int newTop)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1130,13 ***</span>
              frame-&gt;view()-&gt;setScrollPosition(IntPoint(frame-&gt;view()-&gt;scrollX(), static_cast&lt;int&gt;(newTop * frame-&gt;pageZoomFactor() * frame-&gt;frameScaleFactor())));
          return;
      }
  
      if (auto* renderer = renderBox()) {
<span class="line-modified">!         renderer-&gt;setScrollTop(static_cast&lt;int&gt;(newTop * renderer-&gt;style().effectiveZoom()));</span>
          if (auto* scrollableArea = renderer-&gt;layer())
<span class="line-modified">!             scrollableArea-&gt;setScrolledProgrammatically(true);</span>
      }
  }
  
  int Element::scrollWidth()
  {
<span class="line-new-header">--- 1262,13 ---</span>
              frame-&gt;view()-&gt;setScrollPosition(IntPoint(frame-&gt;view()-&gt;scrollX(), static_cast&lt;int&gt;(newTop * frame-&gt;pageZoomFactor() * frame-&gt;frameScaleFactor())));
          return;
      }
  
      if (auto* renderer = renderBox()) {
<span class="line-modified">!         renderer-&gt;setScrollTop(static_cast&lt;int&gt;(newTop * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic);</span>
          if (auto* scrollableArea = renderer-&gt;layer())
<span class="line-modified">!             scrollableArea-&gt;setScrollShouldClearLatchedState(true);</span>
      }
  }
  
  int Element::scrollWidth()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1387,14 ***</span>
  
      document().convertAbsoluteToClientQuads(quads, renderer-&gt;style());
      return DOMRectList::create(quads);
  }
  
<span class="line-modified">! FloatRect Element::boundingClientRect()</span>
  {
<span class="line-removed">-     document().updateLayoutIgnorePendingStylesheets();</span>
<span class="line-removed">- </span>
      RenderObject* renderer = this-&gt;renderer();
      Vector&lt;FloatQuad&gt; quads;
      if (isSVGElement() &amp;&amp; renderer &amp;&amp; !renderer-&gt;isSVGRoot()) {
          // Get the bounding rectangle from the SVG model.
          SVGElement&amp; svgElement = downcast&lt;SVGElement&gt;(*this);
<span class="line-new-header">--- 1519,12 ---</span>
  
      document().convertAbsoluteToClientQuads(quads, renderer-&gt;style());
      return DOMRectList::create(quads);
  }
  
<span class="line-modified">! Optional&lt;std::pair&lt;RenderObject*, FloatRect&gt;&gt; Element::boundingAbsoluteRectWithoutLayout()</span>
  {
      RenderObject* renderer = this-&gt;renderer();
      Vector&lt;FloatQuad&gt; quads;
      if (isSVGElement() &amp;&amp; renderer &amp;&amp; !renderer-&gt;isSVGRoot()) {
          // Get the bounding rectangle from the SVG model.
          SVGElement&amp; svgElement = downcast&lt;SVGElement&gt;(*this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1406,16 ***</span>
          quads.append(renderer-&gt;localToAbsoluteQuad(FloatQuad { pair.value().second }));
      } else if (auto* renderBoxModelObject = this-&gt;renderBoxModelObject())
          renderBoxModelObject-&gt;absoluteQuads(quads);
  
      if (quads.isEmpty())
<span class="line-modified">!         return { };</span>
  
      FloatRect result = quads[0].boundingBox();
      for (size_t i = 1; i &lt; quads.size(); ++i)
          result.unite(quads[i].boundingBox());
  
      document().convertAbsoluteToClientRect(result, renderer-&gt;style());
      return result;
  }
  
  Ref&lt;DOMRect&gt; Element::getBoundingClientRect()
<span class="line-new-header">--- 1536,27 ---</span>
          quads.append(renderer-&gt;localToAbsoluteQuad(FloatQuad { pair.value().second }));
      } else if (auto* renderBoxModelObject = this-&gt;renderBoxModelObject())
          renderBoxModelObject-&gt;absoluteQuads(quads);
  
      if (quads.isEmpty())
<span class="line-modified">!         return WTF::nullopt;</span>
  
      FloatRect result = quads[0].boundingBox();
      for (size_t i = 1; i &lt; quads.size(); ++i)
          result.unite(quads[i].boundingBox());
  
<span class="line-added">+     return std::make_pair(renderer, result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ FloatRect Element::boundingClientRect()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     document().updateLayoutIgnorePendingStylesheets();</span>
<span class="line-added">+     auto pair = boundingAbsoluteRectWithoutLayout();</span>
<span class="line-added">+     if (!pair)</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+     RenderObject* renderer = pair-&gt;first;</span>
<span class="line-added">+     FloatRect result = pair-&gt;second;</span>
      document().convertAbsoluteToClientRect(result, renderer-&gt;style());
      return result;
  }
  
  Ref&lt;DOMRect&gt; Element::getBoundingClientRect()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1436,27 ***</span>
      if (RenderObject* renderer = this-&gt;renderer())
          return document().view()-&gt;contentsToScreen(renderer-&gt;absoluteBoundingBoxRect());
      return IntRect();
  }
  
<span class="line-modified">! const AtomicString&amp; Element::getAttribute(const AtomicString&amp; qualifiedName) const</span>
  {
      if (!elementData())
          return nullAtom();
      synchronizeAttribute(qualifiedName);
      if (const Attribute* attribute = elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this)))
          return attribute-&gt;value();
      return nullAtom();
  }
  
<span class="line-modified">! const AtomicString&amp; Element::getAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName) const</span>
  {
      return getAttribute(QualifiedName(nullAtom(), localName, namespaceURI));
  }
  
  // https://dom.spec.whatwg.org/#dom-element-toggleattribute
<span class="line-modified">! ExceptionOr&lt;bool&gt; Element::toggleAttribute(const AtomicString&amp; qualifiedName, Optional&lt;bool&gt; force)</span>
  {
      if (!Document::isValidName(qualifiedName))
          return Exception { InvalidCharacterError };
  
      synchronizeAttribute(qualifiedName);
<span class="line-new-header">--- 1577,27 ---</span>
      if (RenderObject* renderer = this-&gt;renderer())
          return document().view()-&gt;contentsToScreen(renderer-&gt;absoluteBoundingBoxRect());
      return IntRect();
  }
  
<span class="line-modified">! const AtomString&amp; Element::getAttribute(const AtomString&amp; qualifiedName) const</span>
  {
      if (!elementData())
          return nullAtom();
      synchronizeAttribute(qualifiedName);
      if (const Attribute* attribute = elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this)))
          return attribute-&gt;value();
      return nullAtom();
  }
  
<span class="line-modified">! const AtomString&amp; Element::getAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const</span>
  {
      return getAttribute(QualifiedName(nullAtom(), localName, namespaceURI));
  }
  
  // https://dom.spec.whatwg.org/#dom-element-toggleattribute
<span class="line-modified">! ExceptionOr&lt;bool&gt; Element::toggleAttribute(const AtomString&amp; qualifiedName, Optional&lt;bool&gt; force)</span>
  {
      if (!Document::isValidName(qualifiedName))
          return Exception { InvalidCharacterError };
  
      synchronizeAttribute(qualifiedName);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1476,11 ***</span>
          return false;
      }
      return true;
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; Element::setAttribute(const AtomicString&amp; qualifiedName, const AtomicString&amp; value)</span>
  {
      if (!Document::isValidName(qualifiedName))
          return Exception { InvalidCharacterError };
  
      synchronizeAttribute(qualifiedName);
<span class="line-new-header">--- 1617,11 ---</span>
          return false;
      }
      return true;
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; Element::setAttribute(const AtomString&amp; qualifiedName, const AtomString&amp; value)</span>
  {
      if (!Document::isValidName(qualifiedName))
          return Exception { InvalidCharacterError };
  
      synchronizeAttribute(qualifiedName);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1490,30 ***</span>
      setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
  
      return { };
  }
  
<span class="line-modified">! void Element::setAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
  {
      synchronizeAttribute(name);
      unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
      setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
  }
  
<span class="line-modified">! void Element::setAttributeWithoutSynchronization(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
  {
      unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
      setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
  }
  
<span class="line-modified">! void Element::setSynchronizedLazyAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
  {
      unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
      setAttributeInternal(index, name, value, InSynchronizationOfLazyAttribute);
  }
  
<span class="line-modified">! inline void Element::setAttributeInternal(unsigned index, const QualifiedName&amp; name, const AtomicString&amp; newValue, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)</span>
  {
      if (newValue.isNull()) {
          if (index != ElementData::attributeNotFound)
              removeAttributeInternal(index, inSynchronizationOfLazyAttribute);
          return;
<span class="line-new-header">--- 1631,30 ---</span>
      setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
  
      return { };
  }
  
<span class="line-modified">! void Element::setAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
  {
      synchronizeAttribute(name);
      unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
      setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
  }
  
<span class="line-modified">! void Element::setAttributeWithoutSynchronization(const QualifiedName&amp; name, const AtomString&amp; value)</span>
  {
      unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
      setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
  }
  
<span class="line-modified">! void Element::setSynchronizedLazyAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
  {
      unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
      setAttributeInternal(index, name, value, InSynchronizationOfLazyAttribute);
  }
  
<span class="line-modified">! inline void Element::setAttributeInternal(unsigned index, const QualifiedName&amp; name, const AtomString&amp; newValue, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)</span>
  {
      if (newValue.isNull()) {
          if (index != ElementData::attributeNotFound)
              removeAttributeInternal(index, inSynchronizationOfLazyAttribute);
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1529,11 ***</span>
          return;
      }
  
      const Attribute&amp; attribute = attributeAt(index);
      QualifiedName attributeName = attribute.name();
<span class="line-modified">!     AtomicString oldValue = attribute.value();</span>
  
      willModifyAttribute(attributeName, oldValue, newValue);
  
      if (newValue != oldValue) {
          Style::AttributeChangeInvalidation styleInvalidation(*this, name, oldValue, newValue);
<span class="line-new-header">--- 1670,11 ---</span>
          return;
      }
  
      const Attribute&amp; attribute = attributeAt(index);
      QualifiedName attributeName = attribute.name();
<span class="line-modified">!     AtomString oldValue = attribute.value();</span>
  
      willModifyAttribute(attributeName, oldValue, newValue);
  
      if (newValue != oldValue) {
          Style::AttributeChangeInvalidation styleInvalidation(*this, name, oldValue, newValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1541,29 ***</span>
      }
  
      didModifyAttribute(attributeName, oldValue, newValue);
  }
  
<span class="line-modified">! static inline AtomicString makeIdForStyleResolution(const AtomicString&amp; value, bool inQuirksMode)</span>
  {
      if (inQuirksMode)
          return value.convertToASCIILowercase();
      return value;
  }
  
<span class="line-modified">! void Element::attributeChanged(const QualifiedName&amp; name, const AtomicString&amp; oldValue, const AtomicString&amp; newValue, AttributeModificationReason)</span>
  {
      bool valueIsSameAsBefore = oldValue == newValue;
  
      if (!valueIsSameAsBefore) {
          if (name == HTMLNames::accesskeyAttr)
              document().invalidateAccessKeyCache();
          else if (name == HTMLNames::classAttr)
              classAttributeChanged(newValue);
          else if (name == HTMLNames::idAttr) {
<span class="line-modified">!             AtomicString oldId = elementData()-&gt;idForStyleResolution();</span>
<span class="line-modified">!             AtomicString newId = makeIdForStyleResolution(newValue, document().inQuirksMode());</span>
              if (newId != oldId) {
                  Style::IdChangeInvalidation styleInvalidation(*this, oldId, newId);
                  elementData()-&gt;setIdForStyleResolution(newId);
              }
  
<span class="line-new-header">--- 1682,29 ---</span>
      }
  
      didModifyAttribute(attributeName, oldValue, newValue);
  }
  
<span class="line-modified">! static inline AtomString makeIdForStyleResolution(const AtomString&amp; value, bool inQuirksMode)</span>
  {
      if (inQuirksMode)
          return value.convertToASCIILowercase();
      return value;
  }
  
<span class="line-modified">! void Element::attributeChanged(const QualifiedName&amp; name, const AtomString&amp; oldValue, const AtomString&amp; newValue, AttributeModificationReason)</span>
  {
      bool valueIsSameAsBefore = oldValue == newValue;
  
      if (!valueIsSameAsBefore) {
          if (name == HTMLNames::accesskeyAttr)
              document().invalidateAccessKeyCache();
          else if (name == HTMLNames::classAttr)
              classAttributeChanged(newValue);
          else if (name == HTMLNames::idAttr) {
<span class="line-modified">!             AtomString oldId = elementData()-&gt;idForStyleResolution();</span>
<span class="line-modified">!             AtomString newId = makeIdForStyleResolution(newValue, document().inQuirksMode());</span>
              if (newId != oldId) {
                  Style::IdChangeInvalidation styleInvalidation(*this, oldId, newId);
                  elementData()-&gt;setIdForStyleResolution(newId);
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1613,11 ***</span>
      } while (i &lt; length);
  
      return i &lt; length;
  }
  
<span class="line-modified">! static inline bool classStringHasClassName(const AtomicString&amp; newClassString)</span>
  {
      unsigned length = newClassString.length();
  
      if (!length)
          return false;
<span class="line-new-header">--- 1754,11 ---</span>
      } while (i &lt; length);
  
      return i &lt; length;
  }
  
<span class="line-modified">! static inline bool classStringHasClassName(const AtomString&amp; newClassString)</span>
  {
      unsigned length = newClassString.length();
  
      if (!length)
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1625,11 ***</span>
      if (newClassString.is8Bit())
          return classStringHasClassName(newClassString.characters8(), length);
      return classStringHasClassName(newClassString.characters16(), length);
  }
  
<span class="line-modified">! void Element::classAttributeChanged(const AtomicString&amp; newClassString)</span>
  {
      // Note: We&#39;ll need ElementData, but it doesn&#39;t have to be UniqueElementData.
      if (!elementData())
          ensureUniqueElementData();
  
<span class="line-new-header">--- 1766,11 ---</span>
      if (newClassString.is8Bit())
          return classStringHasClassName(newClassString.characters8(), length);
      return classStringHasClassName(newClassString.characters16(), length);
  }
  
<span class="line-modified">! void Element::classAttributeChanged(const AtomString&amp; newClassString)</span>
  {
      // Note: We&#39;ll need ElementData, but it doesn&#39;t have to be UniqueElementData.
      if (!elementData())
          ensureUniqueElementData();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1652,11 ***</span>
  URL Element::absoluteLinkURL() const
  {
      if (!isLink())
          return URL();
  
<span class="line-modified">!     AtomicString linkAttribute;</span>
      if (hasTagName(SVGNames::aTag))
          linkAttribute = getAttribute(SVGNames::hrefAttr, XLinkNames::hrefAttr);
      else
          linkAttribute = getAttribute(HTMLNames::hrefAttr);
  
<span class="line-new-header">--- 1793,11 ---</span>
  URL Element::absoluteLinkURL() const
  {
      if (!isLink())
          return URL();
  
<span class="line-modified">!     AtomString linkAttribute;</span>
      if (hasTagName(SVGNames::aTag))
          linkAttribute = getAttribute(SVGNames::hrefAttr, XLinkNames::hrefAttr);
      else
          linkAttribute = getAttribute(HTMLNames::hrefAttr);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1870,21 ***</span>
  String Element::nodeNamePreservingCase() const
  {
      return m_tagName.toString();
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; Element::setPrefix(const AtomicString&amp; prefix)</span>
  {
      auto result = checkSetPrefix(prefix);
      if (result.hasException())
          return result.releaseException();
  
      m_tagName.setPrefix(prefix.isEmpty() ? nullAtom() : prefix);
      return { };
  }
  
<span class="line-modified">! const AtomicString&amp; Element::imageSourceURL() const</span>
  {
      return attributeWithoutSynchronization(srcAttr);
  }
  
  bool Element::rendererIsNeeded(const RenderStyle&amp; style)
<span class="line-new-header">--- 2011,21 ---</span>
  String Element::nodeNamePreservingCase() const
  {
      return m_tagName.toString();
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; Element::setPrefix(const AtomString&amp; prefix)</span>
  {
      auto result = checkSetPrefix(prefix);
      if (result.hasException())
          return result.releaseException();
  
      m_tagName.setPrefix(prefix.isEmpty() ? nullAtom() : prefix);
      return { };
  }
  
<span class="line-modified">! const AtomString&amp; Element::imageSourceURL() const</span>
  {
      return attributeWithoutSynchronization(srcAttr);
  }
  
  bool Element::rendererIsNeeded(const RenderStyle&amp; style)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1918,19 ***</span>
      TreeScope* newScope = &amp;parentOfInsertedTree.treeScope();
      HTMLDocument* newDocument = becomeConnected &amp;&amp; is&lt;HTMLDocument&gt;(newScope-&gt;documentScope()) ? &amp;downcast&lt;HTMLDocument&gt;(newScope-&gt;documentScope()) : nullptr;
      if (!insertionType.treeScopeChanged)
          newScope = nullptr;
  
<span class="line-modified">!     const AtomicString&amp; idValue = getIdAttribute();</span>
      if (!idValue.isNull()) {
          if (newScope)
              updateIdForTreeScope(*newScope, nullAtom(), idValue);
          if (newDocument)
              updateIdForDocument(*newDocument, nullAtom(), idValue, AlwaysUpdateHTMLDocumentNamedItemMaps);
      }
  
<span class="line-modified">!     const AtomicString&amp; nameValue = getNameAttribute();</span>
      if (!nameValue.isNull()) {
          if (newScope)
              updateNameForTreeScope(*newScope, nullAtom(), nameValue);
          if (newDocument)
              updateNameForDocument(*newDocument, nullAtom(), nameValue);
<span class="line-new-header">--- 2059,19 ---</span>
      TreeScope* newScope = &amp;parentOfInsertedTree.treeScope();
      HTMLDocument* newDocument = becomeConnected &amp;&amp; is&lt;HTMLDocument&gt;(newScope-&gt;documentScope()) ? &amp;downcast&lt;HTMLDocument&gt;(newScope-&gt;documentScope()) : nullptr;
      if (!insertionType.treeScopeChanged)
          newScope = nullptr;
  
<span class="line-modified">!     const AtomString&amp; idValue = getIdAttribute();</span>
      if (!idValue.isNull()) {
          if (newScope)
              updateIdForTreeScope(*newScope, nullAtom(), idValue);
          if (newDocument)
              updateIdForDocument(*newDocument, nullAtom(), idValue, AlwaysUpdateHTMLDocumentNamedItemMaps);
      }
  
<span class="line-modified">!     const AtomString&amp; nameValue = getNameAttribute();</span>
      if (!nameValue.isNull()) {
          if (newScope)
              updateNameForTreeScope(*newScope, nullAtom(), nameValue);
          if (newDocument)
              updateNameForDocument(*newDocument, nullAtom(), nameValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1964,29 ***</span>
  #endif
  #if ENABLE(POINTER_LOCK)
      if (document().page())
          document().page()-&gt;pointerLockController().elementRemoved(*this);
  #endif
  
      setSavedLayerScrollPosition(ScrollPosition());
  
      if (oldParentOfRemovedTree.isInTreeScope()) {
          TreeScope* oldScope = &amp;oldParentOfRemovedTree.treeScope();
          Document* oldDocument = removalType.disconnectedFromDocument ? &amp;oldScope-&gt;documentScope() : nullptr;
          HTMLDocument* oldHTMLDocument = oldDocument &amp;&amp; is&lt;HTMLDocument&gt;(*oldDocument) ? &amp;downcast&lt;HTMLDocument&gt;(*oldDocument) : nullptr;
          if (!removalType.treeScopeChanged)
              oldScope = nullptr;
  
<span class="line-modified">!         const AtomicString&amp; idValue = getIdAttribute();</span>
          if (!idValue.isNull()) {
              if (oldScope)
                  updateIdForTreeScope(*oldScope, idValue, nullAtom());
              if (oldHTMLDocument)
                  updateIdForDocument(*oldHTMLDocument, idValue, nullAtom(), AlwaysUpdateHTMLDocumentNamedItemMaps);
          }
  
<span class="line-modified">!         const AtomicString&amp; nameValue = getNameAttribute();</span>
          if (!nameValue.isNull()) {
              if (oldScope)
                  updateNameForTreeScope(*oldScope, nameValue, nullAtom());
              if (oldHTMLDocument)
                  updateNameForDocument(*oldHTMLDocument, nameValue, nullAtom());
<span class="line-new-header">--- 2105,33 ---</span>
  #endif
  #if ENABLE(POINTER_LOCK)
      if (document().page())
          document().page()-&gt;pointerLockController().elementRemoved(*this);
  #endif
<span class="line-added">+ #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">+     if (document().page() &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().pointerEventsEnabled())</span>
<span class="line-added">+         document().page()-&gt;pointerCaptureController().elementWasRemoved(*this);</span>
<span class="line-added">+ #endif</span>
  
      setSavedLayerScrollPosition(ScrollPosition());
  
      if (oldParentOfRemovedTree.isInTreeScope()) {
          TreeScope* oldScope = &amp;oldParentOfRemovedTree.treeScope();
          Document* oldDocument = removalType.disconnectedFromDocument ? &amp;oldScope-&gt;documentScope() : nullptr;
          HTMLDocument* oldHTMLDocument = oldDocument &amp;&amp; is&lt;HTMLDocument&gt;(*oldDocument) ? &amp;downcast&lt;HTMLDocument&gt;(*oldDocument) : nullptr;
          if (!removalType.treeScopeChanged)
              oldScope = nullptr;
  
<span class="line-modified">!         const AtomString&amp; idValue = getIdAttribute();</span>
          if (!idValue.isNull()) {
              if (oldScope)
                  updateIdForTreeScope(*oldScope, idValue, nullAtom());
              if (oldHTMLDocument)
                  updateIdForDocument(*oldHTMLDocument, idValue, nullAtom(), AlwaysUpdateHTMLDocumentNamedItemMaps);
          }
  
<span class="line-modified">!         const AtomString&amp; nameValue = getNameAttribute();</span>
          if (!nameValue.isNull()) {
              if (oldScope)
                  updateNameForTreeScope(*oldScope, nameValue, nullAtom());
              if (oldHTMLDocument)
                  updateNameForDocument(*oldHTMLDocument, nameValue, nullAtom());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2029,10 ***</span>
<span class="line-new-header">--- 2174,15 ---</span>
  
  #if PLATFORM(MAC)
      if (frame &amp;&amp; frame-&gt;page())
          frame-&gt;page()-&gt;removeLatchingStateForTarget(*this);
  #endif
<span class="line-added">+ </span>
<span class="line-added">+     if (hasRareData() &amp;&amp; elementRareData()-&gt;hasElementIdentifier()) {</span>
<span class="line-added">+         document().identifiedElementWasRemovedFromDocument(*this);</span>
<span class="line-added">+         elementRareData()-&gt;setHasElementIdentifier(false);</span>
<span class="line-added">+     }</span>
  }
  
  ShadowRoot* Element::shadowRoot() const
  {
      return hasRareData() ? elementRareData()-&gt;shadowRoot() : nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2086,11 ***</span>
      oldRoot-&gt;setParentTreeScope(document());
  }
  
  static bool canAttachAuthorShadowRoot(const Element&amp; element)
  {
<span class="line-modified">!     static NeverDestroyed&lt;HashSet&lt;AtomicString&gt;&gt; tagNames = [] {</span>
          static const HTMLQualifiedName* const tagList[] = {
              &amp;articleTag.get(),
              &amp;asideTag.get(),
              &amp;blockquoteTag.get(),
              &amp;bodyTag.get(),
<span class="line-new-header">--- 2236,11 ---</span>
      oldRoot-&gt;setParentTreeScope(document());
  }
  
  static bool canAttachAuthorShadowRoot(const Element&amp; element)
  {
<span class="line-modified">!     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; tagNames = [] {</span>
          static const HTMLQualifiedName* const tagList[] = {
              &amp;articleTag.get(),
              &amp;asideTag.get(),
              &amp;blockquoteTag.get(),
              &amp;bodyTag.get(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2106,11 ***</span>
              &amp;navTag.get(),
              &amp;pTag.get(),
              &amp;sectionTag.get(),
              &amp;spanTag.get()
          };
<span class="line-modified">!         HashSet&lt;AtomicString&gt; set;</span>
          for (auto&amp; name : tagList)
              set.add(name-&gt;localName());
          return set;
      }();
  
<span class="line-new-header">--- 2256,11 ---</span>
              &amp;navTag.get(),
              &amp;pTag.get(),
              &amp;sectionTag.get(),
              &amp;spanTag.get()
          };
<span class="line-modified">!         HashSet&lt;AtomString&gt; set;</span>
          for (auto&amp; name : tagList)
              set.add(name-&gt;localName());
          return set;
      }();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2167,11 ***</span>
  {
      clearFlag(IsEditingTextOrUndefinedCustomElementFlag);
      setFlag(IsCustomElement);
      auto&amp; data = ensureElementRareData();
      if (!data.customElementReactionQueue())
<span class="line-modified">!         data.setCustomElementReactionQueue(std::make_unique&lt;CustomElementReactionQueue&gt;(elementInterface));</span>
      invalidateStyleForSubtree();
      InspectorInstrumentation::didChangeCustomElementState(*this);
  }
  
  void Element::setIsFailedCustomElement(JSCustomElementInterface&amp;)
<span class="line-new-header">--- 2317,11 ---</span>
  {
      clearFlag(IsEditingTextOrUndefinedCustomElementFlag);
      setFlag(IsCustomElement);
      auto&amp; data = ensureElementRareData();
      if (!data.customElementReactionQueue())
<span class="line-modified">!         data.setCustomElementReactionQueue(makeUnique&lt;CustomElementReactionQueue&gt;(elementInterface));</span>
      invalidateStyleForSubtree();
      InspectorInstrumentation::didChangeCustomElementState(*this);
  }
  
  void Element::setIsFailedCustomElement(JSCustomElementInterface&amp;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2204,11 ***</span>
      InspectorInstrumentation::didChangeCustomElementState(*this);
  
      auto&amp; data = ensureElementRareData();
      bool alreadyScheduledToUpgrade = data.customElementReactionQueue();
      if (!alreadyScheduledToUpgrade)
<span class="line-modified">!         data.setCustomElementReactionQueue(std::make_unique&lt;CustomElementReactionQueue&gt;(elementInterface));</span>
      data.customElementReactionQueue()-&gt;enqueueElementUpgrade(*this, alreadyScheduledToUpgrade);
  }
  
  CustomElementReactionQueue* Element::reactionQueue() const
  {
<span class="line-new-header">--- 2354,11 ---</span>
      InspectorInstrumentation::didChangeCustomElementState(*this);
  
      auto&amp; data = ensureElementRareData();
      bool alreadyScheduledToUpgrade = data.customElementReactionQueue();
      if (!alreadyScheduledToUpgrade)
<span class="line-modified">!         data.setCustomElementReactionQueue(makeUnique&lt;CustomElementReactionQueue&gt;(elementInterface));</span>
      data.customElementReactionQueue()-&gt;enqueueElementUpgrade(*this, alreadyScheduledToUpgrade);
  }
  
  CustomElementReactionQueue* Element::reactionQueue() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2216,11 ***</span>
      if (!hasRareData())
          return nullptr;
      return elementRareData()-&gt;customElementReactionQueue();
  }
  
<span class="line-modified">! const AtomicString&amp; Element::shadowPseudoId() const</span>
  {
      return pseudo();
  }
  
  bool Element::childTypeAllowed(NodeType type) const
<span class="line-new-header">--- 2366,11 ---</span>
      if (!hasRareData())
          return nullptr;
      return elementRareData()-&gt;customElementReactionQueue();
  }
  
<span class="line-modified">! const AtomString&amp; Element::shadowPseudoId() const</span>
  {
      return pseudo();
  }
  
  bool Element::childTypeAllowed(NodeType type) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2374,11 ***</span>
              break;
          }
      }
  }
  
<span class="line-modified">! void Element::setAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; attributeValue)</span>
  {
      setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), mainThreadNormalWorld());
  }
  
  void Element::removeAllEventListeners()
<span class="line-new-header">--- 2524,11 ---</span>
              break;
          }
      }
  }
  
<span class="line-modified">! void Element::setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue)</span>
  {
      setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), mainThreadNormalWorld());
  }
  
  void Element::removeAllEventListeners()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2448,11 ***</span>
  
  ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; Element::setAttributeNode(Attr&amp; attrNode)
  {
      RefPtr&lt;Attr&gt; oldAttrNode = attrIfExists(attrNode.localName(), shouldIgnoreAttributeCase(*this));
      if (oldAttrNode.get() == &amp;attrNode)
<span class="line-modified">!         return WTFMove(oldAttrNode);</span>
  
      // InUseAttributeError: Raised if node is an Attr that is already an attribute of another Element object.
      // The DOM user must explicitly clone Attr nodes to re-use them in other elements.
      if (attrNode.ownerElement() &amp;&amp; attrNode.ownerElement() != this)
          return Exception { InUseAttributeError };
<span class="line-new-header">--- 2598,11 ---</span>
  
  ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; Element::setAttributeNode(Attr&amp; attrNode)
  {
      RefPtr&lt;Attr&gt; oldAttrNode = attrIfExists(attrNode.localName(), shouldIgnoreAttributeCase(*this));
      if (oldAttrNode.get() == &amp;attrNode)
<span class="line-modified">!         return oldAttrNode;</span>
  
      // InUseAttributeError: Raised if node is an Attr that is already an attribute of another Element object.
      // The DOM user must explicitly clone Attr nodes to re-use them in other elements.
      if (attrNode.ownerElement() &amp;&amp; attrNode.ownerElement() != this)
          return Exception { InUseAttributeError };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2488,18 ***</span>
              removeAttributeInternal(existingAttributeIndex, NotInSynchronizationOfLazyAttribute);
              setAttributeInternal(ensureUniqueElementData().findAttributeIndexByName(attrNode.qualifiedName()), attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
          }
      }
  
<span class="line-modified">!     return WTFMove(oldAttrNode);</span>
  }
  
  ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; Element::setAttributeNodeNS(Attr&amp; attrNode)
  {
      RefPtr&lt;Attr&gt; oldAttrNode = attrIfExists(attrNode.qualifiedName());
      if (oldAttrNode.get() == &amp;attrNode)
<span class="line-modified">!         return WTFMove(oldAttrNode);</span>
  
      // InUseAttributeError: Raised if node is an Attr that is already an attribute of another Element object.
      // The DOM user must explicitly clone Attr nodes to re-use them in other elements.
      if (attrNode.ownerElement() &amp;&amp; attrNode.ownerElement() != this)
          return Exception { InUseAttributeError };
<span class="line-new-header">--- 2638,18 ---</span>
              removeAttributeInternal(existingAttributeIndex, NotInSynchronizationOfLazyAttribute);
              setAttributeInternal(ensureUniqueElementData().findAttributeIndexByName(attrNode.qualifiedName()), attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
          }
      }
  
<span class="line-modified">!     return oldAttrNode;</span>
  }
  
  ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; Element::setAttributeNodeNS(Attr&amp; attrNode)
  {
      RefPtr&lt;Attr&gt; oldAttrNode = attrIfExists(attrNode.qualifiedName());
      if (oldAttrNode.get() == &amp;attrNode)
<span class="line-modified">!         return oldAttrNode;</span>
  
      // InUseAttributeError: Raised if node is an Attr that is already an attribute of another Element object.
      // The DOM user must explicitly clone Attr nodes to re-use them in other elements.
      if (attrNode.ownerElement() &amp;&amp; attrNode.ownerElement() != this)
          return Exception { InUseAttributeError };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2524,11 ***</span>
      }
  
      attachAttributeNodeIfNeeded(attrNode);
      setAttributeInternal(index, attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
  
<span class="line-modified">!     return WTFMove(oldAttrNode);</span>
  }
  
  ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Element::removeAttributeNode(Attr&amp; attr)
  {
      if (attr.ownerElement() != this)
<span class="line-new-header">--- 2674,11 ---</span>
      }
  
      attachAttributeNodeIfNeeded(attrNode);
      setAttributeInternal(index, attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
  
<span class="line-modified">!     return oldAttrNode;</span>
  }
  
  ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Element::removeAttributeNode(Attr&amp; attr)
  {
      if (attr.ownerElement() != this)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2548,25 ***</span>
      Ref&lt;Attr&gt; oldAttrNode { attr };
  
      detachAttrNodeFromElementWithValue(&amp;attr, m_elementData-&gt;attributeAt(existingAttributeIndex).value());
      removeAttributeInternal(existingAttributeIndex, NotInSynchronizationOfLazyAttribute);
  
<span class="line-modified">!     return WTFMove(oldAttrNode);</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;QualifiedName&gt; Element::parseAttributeName(const AtomicString&amp; namespaceURI, const AtomicString&amp; qualifiedName)</span>
  {
      auto parseResult = Document::parseQualifiedName(namespaceURI, qualifiedName);
      if (parseResult.hasException())
          return parseResult.releaseException();
      QualifiedName parsedAttributeName { parseResult.releaseReturnValue() };
      if (!Document::hasValidNamespaceForAttributes(parsedAttributeName))
          return Exception { NamespaceError };
<span class="line-modified">!     return WTFMove(parsedAttributeName);</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; Element::setAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; qualifiedName, const AtomicString&amp; value)</span>
  {
      auto result = parseAttributeName(namespaceURI, qualifiedName);
      if (result.hasException())
          return result.releaseException();
      setAttribute(result.releaseReturnValue(), value);
<span class="line-new-header">--- 2698,25 ---</span>
      Ref&lt;Attr&gt; oldAttrNode { attr };
  
      detachAttrNodeFromElementWithValue(&amp;attr, m_elementData-&gt;attributeAt(existingAttributeIndex).value());
      removeAttributeInternal(existingAttributeIndex, NotInSynchronizationOfLazyAttribute);
  
<span class="line-modified">!     return oldAttrNode;</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;QualifiedName&gt; Element::parseAttributeName(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName)</span>
  {
      auto parseResult = Document::parseQualifiedName(namespaceURI, qualifiedName);
      if (parseResult.hasException())
          return parseResult.releaseException();
      QualifiedName parsedAttributeName { parseResult.releaseReturnValue() };
      if (!Document::hasValidNamespaceForAttributes(parsedAttributeName))
          return Exception { NamespaceError };
<span class="line-modified">!     return parsedAttributeName;</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; Element::setAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName, const AtomString&amp; value)</span>
  {
      auto result = parseAttributeName(namespaceURI, qualifiedName);
      if (result.hasException())
          return result.releaseException();
      setAttribute(result.releaseReturnValue(), value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2578,11 ***</span>
      ASSERT_WITH_SECURITY_IMPLICATION(index &lt; attributeCount());
  
      UniqueElementData&amp; elementData = ensureUniqueElementData();
  
      QualifiedName name = elementData.attributeAt(index).name();
<span class="line-modified">!     AtomicString valueBeingRemoved = elementData.attributeAt(index).value();</span>
  
      if (RefPtr&lt;Attr&gt; attrNode = attrIfExists(name))
          detachAttrNodeFromElementWithValue(attrNode.get(), elementData.attributeAt(index).value());
  
      if (inSynchronizationOfLazyAttribute) {
<span class="line-new-header">--- 2728,11 ---</span>
      ASSERT_WITH_SECURITY_IMPLICATION(index &lt; attributeCount());
  
      UniqueElementData&amp; elementData = ensureUniqueElementData();
  
      QualifiedName name = elementData.attributeAt(index).name();
<span class="line-modified">!     AtomString valueBeingRemoved = elementData.attributeAt(index).value();</span>
  
      if (RefPtr&lt;Attr&gt; attrNode = attrIfExists(name))
          detachAttrNodeFromElementWithValue(attrNode.get(), elementData.attributeAt(index).value());
  
      if (inSynchronizationOfLazyAttribute) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2598,11 ***</span>
      }
  
      didRemoveAttribute(name, valueBeingRemoved);
  }
  
<span class="line-modified">! void Element::addAttributeInternal(const QualifiedName&amp; name, const AtomicString&amp; value, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)</span>
  {
      if (inSynchronizationOfLazyAttribute) {
          ensureUniqueElementData().addAttribute(name, value);
          return;
      }
<span class="line-new-header">--- 2748,11 ---</span>
      }
  
      didRemoveAttribute(name, valueBeingRemoved);
  }
  
<span class="line-modified">! void Element::addAttributeInternal(const QualifiedName&amp; name, const AtomString&amp; value, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)</span>
  {
      if (inSynchronizationOfLazyAttribute) {
          ensureUniqueElementData().addAttribute(name, value);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2613,16 ***</span>
          ensureUniqueElementData().addAttribute(name, value);
      }
      didAddAttribute(name, value);
  }
  
<span class="line-modified">! bool Element::removeAttribute(const AtomicString&amp; qualifiedName)</span>
  {
      if (!elementData())
          return false;
  
<span class="line-modified">!     AtomicString caseAdjustedQualifiedName = shouldIgnoreAttributeCase(*this) ? qualifiedName.convertToASCIILowercase() : qualifiedName;</span>
      unsigned index = elementData()-&gt;findAttributeIndexByName(caseAdjustedQualifiedName, false);
      if (index == ElementData::attributeNotFound) {
          if (UNLIKELY(caseAdjustedQualifiedName == styleAttr) &amp;&amp; elementData()-&gt;styleAttributeIsDirty() &amp;&amp; is&lt;StyledElement&gt;(*this))
              downcast&lt;StyledElement&gt;(*this).removeAllInlineStyleProperties();
          return false;
<span class="line-new-header">--- 2763,16 ---</span>
          ensureUniqueElementData().addAttribute(name, value);
      }
      didAddAttribute(name, value);
  }
  
<span class="line-modified">! bool Element::removeAttribute(const AtomString&amp; qualifiedName)</span>
  {
      if (!elementData())
          return false;
  
<span class="line-modified">!     AtomString caseAdjustedQualifiedName = shouldIgnoreAttributeCase(*this) ? qualifiedName.convertToASCIILowercase() : qualifiedName;</span>
      unsigned index = elementData()-&gt;findAttributeIndexByName(caseAdjustedQualifiedName, false);
      if (index == ElementData::attributeNotFound) {
          if (UNLIKELY(caseAdjustedQualifiedName == styleAttr) &amp;&amp; elementData()-&gt;styleAttributeIsDirty() &amp;&amp; is&lt;StyledElement&gt;(*this))
              downcast&lt;StyledElement&gt;(*this).removeAllInlineStyleProperties();
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2630,27 ***</span>
  
      removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
      return true;
  }
  
<span class="line-modified">! bool Element::removeAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName)</span>
  {
      return removeAttribute(QualifiedName(nullAtom(), localName, namespaceURI));
  }
  
<span class="line-modified">! RefPtr&lt;Attr&gt; Element::getAttributeNode(const AtomicString&amp; qualifiedName)</span>
  {
      if (!elementData())
          return nullptr;
      synchronizeAttribute(qualifiedName);
      const Attribute* attribute = elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this));
      if (!attribute)
          return nullptr;
      return ensureAttr(attribute-&gt;name());
  }
  
<span class="line-modified">! RefPtr&lt;Attr&gt; Element::getAttributeNodeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName)</span>
  {
      if (!elementData())
          return 0;
      QualifiedName qName(nullAtom(), localName, namespaceURI);
      synchronizeAttribute(qName);
<span class="line-new-header">--- 2780,27 ---</span>
  
      removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
      return true;
  }
  
<span class="line-modified">! bool Element::removeAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName)</span>
  {
      return removeAttribute(QualifiedName(nullAtom(), localName, namespaceURI));
  }
  
<span class="line-modified">! RefPtr&lt;Attr&gt; Element::getAttributeNode(const AtomString&amp; qualifiedName)</span>
  {
      if (!elementData())
          return nullptr;
      synchronizeAttribute(qualifiedName);
      const Attribute* attribute = elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this));
      if (!attribute)
          return nullptr;
      return ensureAttr(attribute-&gt;name());
  }
  
<span class="line-modified">! RefPtr&lt;Attr&gt; Element::getAttributeNodeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName)</span>
  {
      if (!elementData())
          return 0;
      QualifiedName qName(nullAtom(), localName, namespaceURI);
      synchronizeAttribute(qName);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2658,19 ***</span>
      if (!attribute)
          return 0;
      return ensureAttr(attribute-&gt;name());
  }
  
<span class="line-modified">! bool Element::hasAttribute(const AtomicString&amp; qualifiedName) const</span>
  {
      if (!elementData())
          return false;
      synchronizeAttribute(qualifiedName);
      return elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this));
  }
  
<span class="line-modified">! bool Element::hasAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName) const</span>
  {
      if (!elementData())
          return false;
      QualifiedName qName(nullAtom(), localName, namespaceURI);
      synchronizeAttribute(qName);
<span class="line-new-header">--- 2808,19 ---</span>
      if (!attribute)
          return 0;
      return ensureAttr(attribute-&gt;name());
  }
  
<span class="line-modified">! bool Element::hasAttribute(const AtomString&amp; qualifiedName) const</span>
  {
      if (!elementData())
          return false;
      synchronizeAttribute(qualifiedName);
      return elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this));
  }
  
<span class="line-modified">! bool Element::hasAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const</span>
  {
      if (!elementData())
          return false;
      QualifiedName qName(nullAtom(), localName, namespaceURI);
      synchronizeAttribute(qName);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2701,10 ***</span>
<span class="line-new-header">--- 2851,14 ---</span>
      if (!supportsFocus())
          return;
  
      RefPtr&lt;Node&gt; protect;
      if (Page* page = document().page()) {
<span class="line-added">+         auto&amp; frame = *document().frame();</span>
<span class="line-added">+         if (!frame.hasHadUserInteraction() &amp;&amp; !frame.isMainFrame() &amp;&amp; !document().topDocument().securityOrigin().canAccess(document().securityOrigin()))</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
          // Focus and change event handlers can cause us to lose our last ref.
          // If a focus event handler changes the focus to a different node it
          // does not make sense to continue and update appearence.
          protect = this;
          if (!page-&gt;focusController().setFocusedElement(this, *document().frame(), direction))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2749,10 ***</span>
<span class="line-new-header">--- 2903,11 ---</span>
          VisibleSelection newSelection = VisibleSelection(firstPositionInOrBeforeNode(this), DOWNSTREAM);
  
          if (frame-&gt;selection().shouldChangeSelection(newSelection)) {
              frame-&gt;selection().setSelection(newSelection, FrameSelection::defaultSetSelectionOptions(), Element::defaultFocusTextStateChangeIntent());
              frame-&gt;selection().revealSelection(revealMode);
<span class="line-added">+             return;</span>
          }
      }
  
      if (RefPtr&lt;FrameView&gt; view = document().view())
          view-&gt;scheduleScrollToFocusedElement(revealMode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2766,18 ***</span>
          else
              document().setFocusedElement(nullptr);
      }
  }
  
<span class="line-modified">! void Element::dispatchFocusInEvent(const AtomicString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
      ASSERT(eventType == eventNames().focusinEvent || eventType == eventNames().DOMFocusInEvent);
      dispatchScopedEvent(FocusEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(oldFocusedElement)));
  }
  
<span class="line-modified">! void Element::dispatchFocusOutEvent(const AtomicString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
      ASSERT(eventType == eventNames().focusoutEvent || eventType == eventNames().DOMFocusOutEvent);
      dispatchScopedEvent(FocusEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(newFocusedElement)));
  }
<span class="line-new-header">--- 2921,18 ---</span>
          else
              document().setFocusedElement(nullptr);
      }
  }
  
<span class="line-modified">! void Element::dispatchFocusInEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
      ASSERT(eventType == eventNames().focusinEvent || eventType == eventNames().DOMFocusInEvent);
      dispatchScopedEvent(FocusEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(oldFocusedElement)));
  }
  
<span class="line-modified">! void Element::dispatchFocusOutEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
      ASSERT(eventType == eventNames().focusoutEvent || eventType == eventNames().DOMFocusOutEvent);
      dispatchScopedEvent(FocusEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(newFocusedElement)));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2916,16 ***</span>
  String Element::title() const
  {
      return String();
  }
  
<span class="line-modified">! const AtomicString&amp; Element::pseudo() const</span>
  {
      return attributeWithoutSynchronization(pseudoAttr);
  }
  
<span class="line-modified">! void Element::setPseudo(const AtomicString&amp; value)</span>
  {
      setAttributeWithoutSynchronization(pseudoAttr, value);
  }
  
  LayoutSize Element::minimumSizeForResizing() const
<span class="line-new-header">--- 3071,16 ---</span>
  String Element::title() const
  {
      return String();
  }
  
<span class="line-modified">! const AtomString&amp; Element::pseudo() const</span>
  {
      return attributeWithoutSynchronization(pseudoAttr);
  }
  
<span class="line-modified">! void Element::setPseudo(const AtomString&amp; value)</span>
  {
      setAttributeWithoutSynchronization(pseudoAttr, value);
  }
  
  LayoutSize Element::minimumSizeForResizing() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3062,138 ***</span>
          return false;
  
      return true;
  }
  
<span class="line-removed">- void Element::setStyleAffectedByEmpty()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ensureElementRareData().setStyleAffectedByEmpty(true);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Element::setStyleAffectedByFocusWithin()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ensureElementRareData().setStyleAffectedByFocusWithin(true);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Element::setStyleAffectedByActive()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ensureElementRareData().setStyleAffectedByActive(true);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Element::setChildrenAffectedByDrag()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ensureElementRareData().setChildrenAffectedByDrag(true);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Element::setChildrenAffectedByForwardPositionalRules()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ensureElementRareData().setChildrenAffectedByForwardPositionalRules(true);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Element::setDescendantsAffectedByForwardPositionalRules()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ensureElementRareData().setDescendantsAffectedByForwardPositionalRules(true);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Element::setChildrenAffectedByBackwardPositionalRules()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ensureElementRareData().setChildrenAffectedByBackwardPositionalRules(true);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Element::setDescendantsAffectedByBackwardPositionalRules()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ensureElementRareData().setDescendantsAffectedByBackwardPositionalRules(true);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Element::setChildrenAffectedByPropertyBasedBackwardPositionalRules()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ensureElementRareData().setChildrenAffectedByPropertyBasedBackwardPositionalRules(true);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void Element::setChildIndex(unsigned index)
  {
      ElementRareData&amp; rareData = ensureElementRareData();
      rareData.setChildIndex(index);
  }
  
  bool Element::hasFlagsSetDuringStylingOfChildren() const
  {
<span class="line-modified">!     if (childrenAffectedByHover() || childrenAffectedByFirstChildRules() || childrenAffectedByLastChildRules())</span>
<span class="line-modified">!         return true;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (!hasRareData())</span>
<span class="line-modified">!         return false;</span>
<span class="line-modified">!     return rareDataStyleAffectedByActive()</span>
<span class="line-modified">!         || rareDataChildrenAffectedByDrag()</span>
<span class="line-modified">!         || rareDataChildrenAffectedByForwardPositionalRules()</span>
<span class="line-modified">!         || rareDataDescendantsAffectedByForwardPositionalRules()</span>
<span class="line-modified">!         || rareDataChildrenAffectedByBackwardPositionalRules()</span>
<span class="line-removed">-         || rareDataDescendantsAffectedByBackwardPositionalRules()</span>
<span class="line-removed">-         || rareDataChildrenAffectedByPropertyBasedBackwardPositionalRules();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Element::rareDataStyleAffectedByEmpty() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(hasRareData());</span>
<span class="line-removed">-     return elementRareData()-&gt;styleAffectedByEmpty();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Element::rareDataStyleAffectedByFocusWithin() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(hasRareData());</span>
<span class="line-removed">-     return elementRareData()-&gt;styleAffectedByFocusWithin();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Element::rareDataStyleAffectedByActive() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(hasRareData());</span>
<span class="line-removed">-     return elementRareData()-&gt;styleAffectedByActive();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Element::rareDataChildrenAffectedByDrag() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(hasRareData());</span>
<span class="line-removed">-     return elementRareData()-&gt;childrenAffectedByDrag();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Element::rareDataChildrenAffectedByForwardPositionalRules() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(hasRareData());</span>
<span class="line-removed">-     return elementRareData()-&gt;childrenAffectedByForwardPositionalRules();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Element::rareDataDescendantsAffectedByForwardPositionalRules() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(hasRareData());</span>
<span class="line-removed">-     return elementRareData()-&gt;descendantsAffectedByForwardPositionalRules();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Element::rareDataChildrenAffectedByBackwardPositionalRules() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(hasRareData());</span>
<span class="line-removed">-     return elementRareData()-&gt;childrenAffectedByBackwardPositionalRules();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Element::rareDataDescendantsAffectedByBackwardPositionalRules() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(hasRareData());</span>
<span class="line-removed">-     return elementRareData()-&gt;descendantsAffectedByBackwardPositionalRules();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Element::rareDataChildrenAffectedByPropertyBasedBackwardPositionalRules() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(hasRareData());</span>
<span class="line-removed">-     return elementRareData()-&gt;childrenAffectedByPropertyBasedBackwardPositionalRules();</span>
  }
  
  unsigned Element::rareDataChildIndex() const
  {
      ASSERT(hasRareData());
      return elementRareData()-&gt;childIndex();
  }
  
<span class="line-modified">! AtomicString Element::computeInheritedLanguage() const</span>
  {
      if (const ElementData* elementData = this-&gt;elementData()) {
          if (const Attribute* attribute = elementData-&gt;findLanguageAttribute())
              return attribute-&gt;value();
      }
<span class="line-new-header">--- 3217,37 ---</span>
          return false;
  
      return true;
  }
  
  void Element::setChildIndex(unsigned index)
  {
      ElementRareData&amp; rareData = ensureElementRareData();
      rareData.setChildIndex(index);
  }
  
  bool Element::hasFlagsSetDuringStylingOfChildren() const
  {
<span class="line-modified">!     return styleAffectedByActive()</span>
<span class="line-modified">!         || childrenAffectedByHover()</span>
<span class="line-modified">!         || childrenAffectedByFirstChildRules()</span>
<span class="line-modified">!         || childrenAffectedByLastChildRules()</span>
<span class="line-modified">!         || childrenAffectedByDrag()</span>
<span class="line-modified">!         || childrenAffectedByForwardPositionalRules()</span>
<span class="line-modified">!         || descendantsAffectedByForwardPositionalRules()</span>
<span class="line-modified">!         || childrenAffectedByBackwardPositionalRules()</span>
<span class="line-modified">!         || descendantsAffectedByBackwardPositionalRules()</span>
<span class="line-modified">!         || childrenAffectedByPropertyBasedBackwardPositionalRules();</span>
  }
  
  unsigned Element::rareDataChildIndex() const
  {
      ASSERT(hasRareData());
      return elementRareData()-&gt;childIndex();
  }
  
<span class="line-modified">! AtomString Element::computeInheritedLanguage() const</span>
  {
      if (const ElementData* elementData = this-&gt;elementData()) {
          if (const Attribute* attribute = elementData-&gt;findLanguageAttribute())
              return attribute-&gt;value();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3335,19 ***</span>
  
  DOMTokenList&amp; Element::classList()
  {
      ElementRareData&amp; data = ensureElementRareData();
      if (!data.classList())
<span class="line-modified">!         data.setClassList(std::make_unique&lt;DOMTokenList&gt;(*this, HTMLNames::classAttr));</span>
      return *data.classList();
  }
  
  DatasetDOMStringMap&amp; Element::dataset()
  {
      ElementRareData&amp; data = ensureElementRareData();
      if (!data.dataset())
<span class="line-modified">!         data.setDataset(std::make_unique&lt;DatasetDOMStringMap&gt;(*this));</span>
      return *data.dataset();
  }
  
  URL Element::getURLAttribute(const QualifiedName&amp; name) const
  {
<span class="line-new-header">--- 3389,19 ---</span>
  
  DOMTokenList&amp; Element::classList()
  {
      ElementRareData&amp; data = ensureElementRareData();
      if (!data.classList())
<span class="line-modified">!         data.setClassList(makeUnique&lt;DOMTokenList&gt;(*this, HTMLNames::classAttr));</span>
      return *data.classList();
  }
  
  DatasetDOMStringMap&amp; Element::dataset()
  {
      ElementRareData&amp; data = ensureElementRareData();
      if (!data.dataset())
<span class="line-modified">!         data.setDataset(makeUnique&lt;DatasetDOMStringMap&gt;(*this));</span>
      return *data.dataset();
  }
  
  URL Element::getURLAttribute(const QualifiedName&amp; name) const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3379,21 ***</span>
      return parseHTMLInteger(getAttribute(attributeName)).value_or(0);
  }
  
  void Element::setIntegralAttribute(const QualifiedName&amp; attributeName, int value)
  {
<span class="line-modified">!     setAttribute(attributeName, AtomicString::number(value));</span>
  }
  
  unsigned Element::getUnsignedIntegralAttribute(const QualifiedName&amp; attributeName) const
  {
      return parseHTMLNonNegativeInteger(getAttribute(attributeName)).value_or(0);
  }
  
  void Element::setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value)
  {
<span class="line-modified">!     setAttribute(attributeName, AtomicString::number(limitToOnlyHTMLNonNegative(value)));</span>
  }
  
  bool Element::childShouldCreateRenderer(const Node&amp; child) const
  {
      // Only create renderers for SVG elements whose parents are SVG elements, or for proper &lt;svg xmlns=&quot;svgNS&quot;&gt; subdocuments.
<span class="line-new-header">--- 3433,21 ---</span>
      return parseHTMLInteger(getAttribute(attributeName)).value_or(0);
  }
  
  void Element::setIntegralAttribute(const QualifiedName&amp; attributeName, int value)
  {
<span class="line-modified">!     setAttribute(attributeName, AtomString::number(value));</span>
  }
  
  unsigned Element::getUnsignedIntegralAttribute(const QualifiedName&amp; attributeName) const
  {
      return parseHTMLNonNegativeInteger(getAttribute(attributeName)).value_or(0);
  }
  
  void Element::setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value)
  {
<span class="line-modified">!     setAttribute(attributeName, AtomString::number(limitToOnlyHTMLNonNegative(value)));</span>
  }
  
  bool Element::childShouldCreateRenderer(const Node&amp; child) const
  {
      // Only create renderers for SVG elements whose parents are SVG elements, or for proper &lt;svg xmlns=&quot;svgNS&quot;&gt; subdocuments.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3403,24 ***</span>
          return is&lt;SVGSVGElement&gt;(childElement) &amp;&amp; childElement.isValid();
      }
      return true;
  }
  
<span class="line-modified">! #if ENABLE(FULLSCREEN_API) || ENABLE(POINTER_EVENTS)</span>
  static Element* parentCrossingFrameBoundaries(const Element* element)
  {
      ASSERT(element);
      if (auto* parent = element-&gt;parentElementInComposedTree())
          return parent;
      return element-&gt;document().ownerElement();
  }
<span class="line-removed">- #endif</span>
  
<span class="line-removed">- #if ENABLE(FULLSCREEN_API)</span>
  void Element::webkitRequestFullscreen()
  {
<span class="line-modified">!     document().requestFullScreenForElement(this, Document::EnforceIFrameAllowFullScreenRequirement);</span>
  }
  
  bool Element::containsFullScreenElement() const
  {
      return hasRareData() &amp;&amp; elementRareData()-&gt;containsFullScreenElement();
<span class="line-new-header">--- 3457,22 ---</span>
          return is&lt;SVGSVGElement&gt;(childElement) &amp;&amp; childElement.isValid();
      }
      return true;
  }
  
<span class="line-modified">! #if ENABLE(FULLSCREEN_API)</span>
  static Element* parentCrossingFrameBoundaries(const Element* element)
  {
      ASSERT(element);
      if (auto* parent = element-&gt;parentElementInComposedTree())
          return parent;
      return element-&gt;document().ownerElement();
  }
  
  void Element::webkitRequestFullscreen()
  {
<span class="line-modified">!     document().fullscreenManager().requestFullscreenForElement(this, FullscreenManager::EnforceIFrameAllowFullscreenRequirement);</span>
  }
  
  bool Element::containsFullScreenElement() const
  {
      return hasRareData() &amp;&amp; elementRareData()-&gt;containsFullScreenElement();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3489,23 ***</span>
  
  IntersectionObserverData&amp; Element::ensureIntersectionObserverData()
  {
      auto&amp; rareData = ensureElementRareData();
      if (!rareData.intersectionObserverData())
<span class="line-modified">!         rareData.setIntersectionObserverData(std::make_unique&lt;IntersectionObserverData&gt;());</span>
      return *rareData.intersectionObserverData();
  }
  
  IntersectionObserverData* Element::intersectionObserverData()
  {
      return hasRareData() ? elementRareData()-&gt;intersectionObserverData() : nullptr;
  }
  #endif
  
  SpellcheckAttributeState Element::spellcheckAttributeState() const
  {
<span class="line-modified">!     const AtomicString&amp; value = attributeWithoutSynchronization(HTMLNames::spellcheckAttr);</span>
      if (value.isNull())
          return SpellcheckAttributeDefault;
      if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))
          return SpellcheckAttributeTrue;
      if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
<span class="line-new-header">--- 3541,49 ---</span>
  
  IntersectionObserverData&amp; Element::ensureIntersectionObserverData()
  {
      auto&amp; rareData = ensureElementRareData();
      if (!rareData.intersectionObserverData())
<span class="line-modified">!         rareData.setIntersectionObserverData(makeUnique&lt;IntersectionObserverData&gt;());</span>
      return *rareData.intersectionObserverData();
  }
  
  IntersectionObserverData* Element::intersectionObserverData()
  {
      return hasRareData() ? elementRareData()-&gt;intersectionObserverData() : nullptr;
  }
  #endif
  
<span class="line-added">+ #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added">+ void Element::disconnectFromResizeObservers()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* observerData = resizeObserverData();</span>
<span class="line-added">+     if (!observerData)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (const auto&amp; observer : observerData-&gt;observers)</span>
<span class="line-added">+         observer-&gt;targetDestroyed(*this);</span>
<span class="line-added">+     observerData-&gt;observers.clear();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ResizeObserverData&amp; Element::ensureResizeObserverData()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto&amp; rareData = ensureElementRareData();</span>
<span class="line-added">+     if (!rareData.resizeObserverData())</span>
<span class="line-added">+         rareData.setResizeObserverData(makeUnique&lt;ResizeObserverData&gt;());</span>
<span class="line-added">+     return *rareData.resizeObserverData();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ResizeObserverData* Element::resizeObserverData()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return hasRareData() ? elementRareData()-&gt;resizeObserverData() : nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  SpellcheckAttributeState Element::spellcheckAttributeState() const
  {
<span class="line-modified">!     const AtomString&amp; value = attributeWithoutSynchronization(HTMLNames::spellcheckAttr);</span>
      if (value.isNull())
          return SpellcheckAttributeDefault;
      if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))
          return SpellcheckAttributeTrue;
      if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3534,11 ***</span>
  {
      if (name == HTMLNames::styleAttr)
          return false;
  
      if (isSVGElement())
<span class="line-modified">!         return !downcast&lt;SVGElement&gt;(*this).isAnimatableAttribute(name);</span>
  
      return true;
  }
  #endif
  
<span class="line-new-header">--- 3612,11 ---</span>
  {
      if (name == HTMLNames::styleAttr)
          return false;
  
      if (isSVGElement())
<span class="line-modified">!         return !downcast&lt;SVGElement&gt;(*this).isAnimatedPropertyAttribute(name);</span>
  
      return true;
  }
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3547,11 ***</span>
  {
      return hasRareData() &amp;&amp; elementRareData()-&gt;attributeMap();
  }
  #endif
  
<span class="line-modified">! inline void Element::updateName(const AtomicString&amp; oldName, const AtomicString&amp; newName)</span>
  {
      if (!isInTreeScope())
          return;
  
      if (oldName == newName)
<span class="line-new-header">--- 3625,11 ---</span>
  {
      return hasRareData() &amp;&amp; elementRareData()-&gt;attributeMap();
  }
  #endif
  
<span class="line-modified">! inline void Element::updateName(const AtomString&amp; oldName, const AtomString&amp; newName)</span>
  {
      if (!isInTreeScope())
          return;
  
      if (oldName == newName)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3564,45 ***</span>
      if (!is&lt;HTMLDocument&gt;(document()))
          return;
      updateNameForDocument(downcast&lt;HTMLDocument&gt;(document()), oldName, newName);
  }
  
<span class="line-modified">! void Element::updateNameForTreeScope(TreeScope&amp; scope, const AtomicString&amp; oldName, const AtomicString&amp; newName)</span>
  {
      ASSERT(oldName != newName);
  
      if (!oldName.isEmpty())
          scope.removeElementByName(*oldName.impl(), *this);
      if (!newName.isEmpty())
          scope.addElementByName(*newName.impl(), *this);
  }
  
<span class="line-modified">! void Element::updateNameForDocument(HTMLDocument&amp; document, const AtomicString&amp; oldName, const AtomicString&amp; newName)</span>
  {
      ASSERT(oldName != newName);
  
      if (isInShadowTree())
          return;
  
      if (WindowNameCollection::elementMatchesIfNameAttributeMatch(*this)) {
<span class="line-modified">!         const AtomicString&amp; id = WindowNameCollection::elementMatchesIfIdAttributeMatch(*this) ? getIdAttribute() : nullAtom();</span>
          if (!oldName.isEmpty() &amp;&amp; oldName != id)
              document.removeWindowNamedItem(*oldName.impl(), *this);
          if (!newName.isEmpty() &amp;&amp; newName != id)
              document.addWindowNamedItem(*newName.impl(), *this);
      }
  
      if (DocumentNameCollection::elementMatchesIfNameAttributeMatch(*this)) {
<span class="line-modified">!         const AtomicString&amp; id = DocumentNameCollection::elementMatchesIfIdAttributeMatch(*this) ? getIdAttribute() : nullAtom();</span>
          if (!oldName.isEmpty() &amp;&amp; oldName != id)
              document.removeDocumentNamedItem(*oldName.impl(), *this);
          if (!newName.isEmpty() &amp;&amp; newName != id)
              document.addDocumentNamedItem(*newName.impl(), *this);
      }
  }
  
<span class="line-modified">! inline void Element::updateId(const AtomicString&amp; oldId, const AtomicString&amp; newId, NotifyObservers notifyObservers)</span>
  {
      if (!isInTreeScope())
          return;
  
      if (oldId == newId)
<span class="line-new-header">--- 3642,45 ---</span>
      if (!is&lt;HTMLDocument&gt;(document()))
          return;
      updateNameForDocument(downcast&lt;HTMLDocument&gt;(document()), oldName, newName);
  }
  
<span class="line-modified">! void Element::updateNameForTreeScope(TreeScope&amp; scope, const AtomString&amp; oldName, const AtomString&amp; newName)</span>
  {
      ASSERT(oldName != newName);
  
      if (!oldName.isEmpty())
          scope.removeElementByName(*oldName.impl(), *this);
      if (!newName.isEmpty())
          scope.addElementByName(*newName.impl(), *this);
  }
  
<span class="line-modified">! void Element::updateNameForDocument(HTMLDocument&amp; document, const AtomString&amp; oldName, const AtomString&amp; newName)</span>
  {
      ASSERT(oldName != newName);
  
      if (isInShadowTree())
          return;
  
      if (WindowNameCollection::elementMatchesIfNameAttributeMatch(*this)) {
<span class="line-modified">!         const AtomString&amp; id = WindowNameCollection::elementMatchesIfIdAttributeMatch(*this) ? getIdAttribute() : nullAtom();</span>
          if (!oldName.isEmpty() &amp;&amp; oldName != id)
              document.removeWindowNamedItem(*oldName.impl(), *this);
          if (!newName.isEmpty() &amp;&amp; newName != id)
              document.addWindowNamedItem(*newName.impl(), *this);
      }
  
      if (DocumentNameCollection::elementMatchesIfNameAttributeMatch(*this)) {
<span class="line-modified">!         const AtomString&amp; id = DocumentNameCollection::elementMatchesIfIdAttributeMatch(*this) ? getIdAttribute() : nullAtom();</span>
          if (!oldName.isEmpty() &amp;&amp; oldName != id)
              document.removeDocumentNamedItem(*oldName.impl(), *this);
          if (!newName.isEmpty() &amp;&amp; newName != id)
              document.addDocumentNamedItem(*newName.impl(), *this);
      }
  }
  
<span class="line-modified">! inline void Element::updateId(const AtomString&amp; oldId, const AtomString&amp; newId, NotifyObservers notifyObservers)</span>
  {
      if (!isInTreeScope())
          return;
  
      if (oldId == newId)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3615,47 ***</span>
      if (!is&lt;HTMLDocument&gt;(document()))
          return;
      updateIdForDocument(downcast&lt;HTMLDocument&gt;(document()), oldId, newId, UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute);
  }
  
<span class="line-modified">! void Element::updateIdForTreeScope(TreeScope&amp; scope, const AtomicString&amp; oldId, const AtomicString&amp; newId, NotifyObservers notifyObservers)</span>
  {
      ASSERT(isInTreeScope());
      ASSERT(oldId != newId);
  
      if (!oldId.isEmpty())
          scope.removeElementById(*oldId.impl(), *this, notifyObservers == NotifyObservers::Yes);
      if (!newId.isEmpty())
          scope.addElementById(*newId.impl(), *this, notifyObservers == NotifyObservers::Yes);
  }
  
<span class="line-modified">! void Element::updateIdForDocument(HTMLDocument&amp; document, const AtomicString&amp; oldId, const AtomicString&amp; newId, HTMLDocumentNamedItemMapsUpdatingCondition condition)</span>
  {
      ASSERT(isConnected());
      ASSERT(oldId != newId);
  
      if (isInShadowTree())
          return;
  
      if (WindowNameCollection::elementMatchesIfIdAttributeMatch(*this)) {
<span class="line-modified">!         const AtomicString&amp; name = condition == UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute &amp;&amp; WindowNameCollection::elementMatchesIfNameAttributeMatch(*this) ? getNameAttribute() : nullAtom();</span>
          if (!oldId.isEmpty() &amp;&amp; oldId != name)
              document.removeWindowNamedItem(*oldId.impl(), *this);
          if (!newId.isEmpty() &amp;&amp; newId != name)
              document.addWindowNamedItem(*newId.impl(), *this);
      }
  
      if (DocumentNameCollection::elementMatchesIfIdAttributeMatch(*this)) {
<span class="line-modified">!         const AtomicString&amp; name = condition == UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute &amp;&amp; DocumentNameCollection::elementMatchesIfNameAttributeMatch(*this) ? getNameAttribute() : nullAtom();</span>
          if (!oldId.isEmpty() &amp;&amp; oldId != name)
              document.removeDocumentNamedItem(*oldId.impl(), *this);
          if (!newId.isEmpty() &amp;&amp; newId != name)
              document.addDocumentNamedItem(*newId.impl(), *this);
      }
  }
  
<span class="line-modified">! void Element::updateLabel(TreeScope&amp; scope, const AtomicString&amp; oldForAttributeValue, const AtomicString&amp; newForAttributeValue)</span>
  {
      ASSERT(hasTagName(labelTag));
  
      if (!isConnected())
          return;
<span class="line-new-header">--- 3693,47 ---</span>
      if (!is&lt;HTMLDocument&gt;(document()))
          return;
      updateIdForDocument(downcast&lt;HTMLDocument&gt;(document()), oldId, newId, UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute);
  }
  
<span class="line-modified">! void Element::updateIdForTreeScope(TreeScope&amp; scope, const AtomString&amp; oldId, const AtomString&amp; newId, NotifyObservers notifyObservers)</span>
  {
      ASSERT(isInTreeScope());
      ASSERT(oldId != newId);
  
      if (!oldId.isEmpty())
          scope.removeElementById(*oldId.impl(), *this, notifyObservers == NotifyObservers::Yes);
      if (!newId.isEmpty())
          scope.addElementById(*newId.impl(), *this, notifyObservers == NotifyObservers::Yes);
  }
  
<span class="line-modified">! void Element::updateIdForDocument(HTMLDocument&amp; document, const AtomString&amp; oldId, const AtomString&amp; newId, HTMLDocumentNamedItemMapsUpdatingCondition condition)</span>
  {
      ASSERT(isConnected());
      ASSERT(oldId != newId);
  
      if (isInShadowTree())
          return;
  
      if (WindowNameCollection::elementMatchesIfIdAttributeMatch(*this)) {
<span class="line-modified">!         const AtomString&amp; name = condition == UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute &amp;&amp; WindowNameCollection::elementMatchesIfNameAttributeMatch(*this) ? getNameAttribute() : nullAtom();</span>
          if (!oldId.isEmpty() &amp;&amp; oldId != name)
              document.removeWindowNamedItem(*oldId.impl(), *this);
          if (!newId.isEmpty() &amp;&amp; newId != name)
              document.addWindowNamedItem(*newId.impl(), *this);
      }
  
      if (DocumentNameCollection::elementMatchesIfIdAttributeMatch(*this)) {
<span class="line-modified">!         const AtomString&amp; name = condition == UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute &amp;&amp; DocumentNameCollection::elementMatchesIfNameAttributeMatch(*this) ? getNameAttribute() : nullAtom();</span>
          if (!oldId.isEmpty() &amp;&amp; oldId != name)
              document.removeDocumentNamedItem(*oldId.impl(), *this);
          if (!newId.isEmpty() &amp;&amp; newId != name)
              document.addDocumentNamedItem(*newId.impl(), *this);
      }
  }
  
<span class="line-modified">! void Element::updateLabel(TreeScope&amp; scope, const AtomString&amp; oldForAttributeValue, const AtomString&amp; newForAttributeValue)</span>
  {
      ASSERT(hasTagName(labelTag));
  
      if (!isConnected())
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3667,11 ***</span>
          scope.removeLabel(*oldForAttributeValue.impl(), downcast&lt;HTMLLabelElement&gt;(*this));
      if (!newForAttributeValue.isEmpty())
          scope.addLabel(*newForAttributeValue.impl(), downcast&lt;HTMLLabelElement&gt;(*this));
  }
  
<span class="line-modified">! void Element::willModifyAttribute(const QualifiedName&amp; name, const AtomicString&amp; oldValue, const AtomicString&amp; newValue)</span>
  {
      if (name == HTMLNames::idAttr)
          updateId(oldValue, newValue, NotifyObservers::No); // Will notify observers after the attribute is actually changed.
      else if (name == HTMLNames::nameAttr)
          updateName(oldValue, newValue);
<span class="line-new-header">--- 3745,11 ---</span>
          scope.removeLabel(*oldForAttributeValue.impl(), downcast&lt;HTMLLabelElement&gt;(*this));
      if (!newForAttributeValue.isEmpty())
          scope.addLabel(*newForAttributeValue.impl(), downcast&lt;HTMLLabelElement&gt;(*this));
  }
  
<span class="line-modified">! void Element::willModifyAttribute(const QualifiedName&amp; name, const AtomString&amp; oldValue, const AtomString&amp; newValue)</span>
  {
      if (name == HTMLNames::idAttr)
          updateId(oldValue, newValue, NotifyObservers::No); // Will notify observers after the attribute is actually changed.
      else if (name == HTMLNames::nameAttr)
          updateName(oldValue, newValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3684,28 ***</span>
          recipients-&gt;enqueueMutationRecord(MutationRecord::createAttributes(*this, name, oldValue));
  
      InspectorInstrumentation::willModifyDOMAttr(document(), *this, oldValue, newValue);
  }
  
<span class="line-modified">! void Element::didAddAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
  {
      attributeChanged(name, nullAtom(), value);
<span class="line-modified">!     InspectorInstrumentation::didModifyDOMAttr(document(), *this, name.localName(), value);</span>
      dispatchSubtreeModifiedEvent();
  }
  
<span class="line-modified">! void Element::didModifyAttribute(const QualifiedName&amp; name, const AtomicString&amp; oldValue, const AtomicString&amp; newValue)</span>
  {
      attributeChanged(name, oldValue, newValue);
<span class="line-modified">!     InspectorInstrumentation::didModifyDOMAttr(document(), *this, name.localName(), newValue);</span>
      // Do not dispatch a DOMSubtreeModified event here; see bug 81141.
  }
  
<span class="line-modified">! void Element::didRemoveAttribute(const QualifiedName&amp; name, const AtomicString&amp; oldValue)</span>
  {
      attributeChanged(name, oldValue, nullAtom());
<span class="line-modified">!     InspectorInstrumentation::didRemoveDOMAttr(document(), *this, name.localName());</span>
      dispatchSubtreeModifiedEvent();
  }
  
  IntPoint Element::savedLayerScrollPosition() const
  {
<span class="line-new-header">--- 3762,28 ---</span>
          recipients-&gt;enqueueMutationRecord(MutationRecord::createAttributes(*this, name, oldValue));
  
      InspectorInstrumentation::willModifyDOMAttr(document(), *this, oldValue, newValue);
  }
  
<span class="line-modified">! void Element::didAddAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
  {
      attributeChanged(name, nullAtom(), value);
<span class="line-modified">!     InspectorInstrumentation::didModifyDOMAttr(document(), *this, name.toString(), value);</span>
      dispatchSubtreeModifiedEvent();
  }
  
<span class="line-modified">! void Element::didModifyAttribute(const QualifiedName&amp; name, const AtomString&amp; oldValue, const AtomString&amp; newValue)</span>
  {
      attributeChanged(name, oldValue, newValue);
<span class="line-modified">!     InspectorInstrumentation::didModifyDOMAttr(document(), *this, name.toString(), newValue);</span>
      // Do not dispatch a DOMSubtreeModified event here; see bug 81141.
  }
  
<span class="line-modified">! void Element::didRemoveAttribute(const QualifiedName&amp; name, const AtomString&amp; oldValue)</span>
  {
      attributeChanged(name, oldValue, nullAtom());
<span class="line-modified">!     InspectorInstrumentation::didRemoveDOMAttr(document(), *this, name.toString());</span>
      dispatchSubtreeModifiedEvent();
  }
  
  IntPoint Element::savedLayerScrollPosition() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3717,11 ***</span>
      if (position.isZero() &amp;&amp; !hasRareData())
          return;
      ensureElementRareData().setSavedLayerScrollPosition(position);
  }
  
<span class="line-modified">! RefPtr&lt;Attr&gt; Element::attrIfExists(const AtomicString&amp; localName, bool shouldIgnoreAttributeCase)</span>
  {
      if (auto* attrNodeList = attrNodeListForElement(*this))
          return findAttrNodeInList(*attrNodeList, localName, shouldIgnoreAttributeCase);
      return nullptr;
  }
<span class="line-new-header">--- 3795,11 ---</span>
      if (position.isZero() &amp;&amp; !hasRareData())
          return;
      ensureElementRareData().setSavedLayerScrollPosition(position);
  }
  
<span class="line-modified">! RefPtr&lt;Attr&gt; Element::attrIfExists(const AtomString&amp; localName, bool shouldIgnoreAttributeCase)</span>
  {
      if (auto* attrNodeList = attrNodeListForElement(*this))
          return findAttrNodeInList(*attrNodeList, localName, shouldIgnoreAttributeCase);
      return nullptr;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3743,11 ***</span>
          attrNodeList.append(attrNode);
      }
      return attrNode.releaseNonNull();
  }
  
<span class="line-modified">! void Element::detachAttrNodeFromElementWithValue(Attr* attrNode, const AtomicString&amp; value)</span>
  {
      ASSERT(hasSyntheticAttrChildNodes());
      attrNode-&gt;detachFromElementWithValue(value);
  
      auto&amp; attrNodeList = *attrNodeListForElement(*this);
<span class="line-new-header">--- 3821,11 ---</span>
          attrNodeList.append(attrNode);
      }
      return attrNode.releaseNonNull();
  }
  
<span class="line-modified">! void Element::detachAttrNodeFromElementWithValue(Attr* attrNode, const AtomString&amp; value)</span>
  {
      ASSERT(hasSyntheticAttrChildNodes());
      attrNode-&gt;detachFromElementWithValue(value);
  
      auto&amp; attrNodeList = *attrNodeListForElement(*this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3789,10 ***</span>
<span class="line-new-header">--- 3867,13 ---</span>
          reset(child);
  }
  
  void Element::resetStyleRelations()
  {
<span class="line-added">+     // FIXME: Make this code more consistent.</span>
<span class="line-added">+     clearFlag(StyleAffectedByFocusWithinFlag);</span>
<span class="line-added">+     clearStyleFlags();</span>
      if (!hasRareData())
          return;
      elementRareData()-&gt;resetStyleRelations();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3861,18 ***</span>
  
      // We can&#39;t update window and document&#39;s named item maps since the presence of image and object elements depend on other attributes and children.
      // Fortunately, those named item maps are only updated when this element is in the document, which should never be the case.
      ASSERT(!isConnected());
  
<span class="line-modified">!     const AtomicString&amp; oldID = getIdAttribute();</span>
<span class="line-modified">!     const AtomicString&amp; newID = other.getIdAttribute();</span>
  
      if (!oldID.isNull() || !newID.isNull())
          updateId(oldID, newID, NotifyObservers::No); // Will notify observers after the attribute is actually changed.
  
<span class="line-modified">!     const AtomicString&amp; oldName = getNameAttribute();</span>
<span class="line-modified">!     const AtomicString&amp; newName = other.getNameAttribute();</span>
  
      if (!oldName.isNull() || !newName.isNull())
          updateName(oldName, newName);
  
      // If &#39;other&#39; has a mutable ElementData, convert it to an immutable one so we can share it between both elements.
<span class="line-new-header">--- 3942,18 ---</span>
  
      // We can&#39;t update window and document&#39;s named item maps since the presence of image and object elements depend on other attributes and children.
      // Fortunately, those named item maps are only updated when this element is in the document, which should never be the case.
      ASSERT(!isConnected());
  
<span class="line-modified">!     const AtomString&amp; oldID = getIdAttribute();</span>
<span class="line-modified">!     const AtomString&amp; newID = other.getIdAttribute();</span>
  
      if (!oldID.isNull() || !newID.isNull())
          updateId(oldID, newID, NotifyObservers::No); // Will notify observers after the attribute is actually changed.
  
<span class="line-modified">!     const AtomString&amp; oldName = getNameAttribute();</span>
<span class="line-modified">!     const AtomString&amp; newName = other.getNameAttribute();</span>
  
      if (!oldName.isNull() || !newName.isNull())
          updateName(oldName, newName);
  
      // If &#39;other&#39; has a mutable ElementData, convert it to an immutable one so we can share it between both elements.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4070,11 ***</span>
  Element* Element::findAnchorElementForLink(String&amp; outAnchorName)
  {
      if (!isLink())
          return nullptr;
  
<span class="line-modified">!     const AtomicString&amp; href = attributeWithoutSynchronization(HTMLNames::hrefAttr);</span>
      if (href.isNull())
          return nullptr;
  
      Document&amp; document = this-&gt;document();
      URL url = document.completeURL(href);
<span class="line-new-header">--- 4151,11 ---</span>
  Element* Element::findAnchorElementForLink(String&amp; outAnchorName)
  {
      if (!isLink())
          return nullptr;
  
<span class="line-modified">!     const AtomString&amp; href = attributeWithoutSynchronization(HTMLNames::hrefAttr);</span>
      if (href.isNull())
          return nullptr;
  
      Document&amp; document = this-&gt;document();
      URL url = document.completeURL(href);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4115,11 ***</span>
  
      auto animationPlayResult = animation-&gt;play();
      if (animationPlayResult.hasException())
          return animationPlayResult.releaseException();
  
<span class="line-modified">!     return WTFMove(animation);</span>
  }
  
  Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Element::getAnimations()
  {
      // FIXME: Filter and order the list as specified (webkit.org/b/179535).
<span class="line-new-header">--- 4196,11 ---</span>
  
      auto animationPlayResult = animation-&gt;play();
      if (animationPlayResult.hasException())
          return animationPlayResult.releaseException();
  
<span class="line-modified">!     return animation;</span>
  }
  
  Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Element::getAnimations()
  {
      // FIXME: Filter and order the list as specified (webkit.org/b/179535).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4137,10 ***</span>
<span class="line-new-header">--- 4218,19 ---</span>
          }
      }
      return animations;
  }
  
<span class="line-added">+ ElementIdentifier Element::createElementIdentifier()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto&amp; rareData = ensureElementRareData();</span>
<span class="line-added">+     ASSERT(!rareData.hasElementIdentifier());</span>
<span class="line-added">+ </span>
<span class="line-added">+     rareData.setHasElementIdentifier(true);</span>
<span class="line-added">+     return ElementIdentifier::generate();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #if ENABLE(CSS_TYPED_OM)
  StylePropertyMap* Element::attributeStyleMap()
  {
      if (!hasRareData())
          return nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4151,68 ***</span>
  {
      ensureElementRareData().setAttributeStyleMap(WTFMove(map));
  }
  #endif
  
<span class="line-removed">- #if ENABLE(POINTER_EVENTS)</span>
<span class="line-removed">- OptionSet&lt;TouchAction&gt; Element::computedTouchActions() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     OptionSet&lt;TouchAction&gt; computedTouchActions = TouchAction::Auto;</span>
<span class="line-removed">-     for (auto* element = this; element; element = parentCrossingFrameBoundaries(element)) {</span>
<span class="line-removed">-         auto* renderer = element-&gt;renderer();</span>
<span class="line-removed">-         if (!renderer)</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto touchActions = renderer-&gt;style().touchActions();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Once we&#39;ve encountered touch-action: none, we know that this will be the computed value.</span>
<span class="line-removed">-         if (touchActions == TouchAction::None)</span>
<span class="line-removed">-             return touchActions;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // If the computed touch-action so far was &quot;auto&quot;, we can just use the current element&#39;s touch-action.</span>
<span class="line-removed">-         if (computedTouchActions == TouchAction::Auto) {</span>
<span class="line-removed">-             computedTouchActions = touchActions;</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // If the current element has touch-action: auto or the same touch-action as the computed touch-action,</span>
<span class="line-removed">-         // we need to keep going up the ancestry chain.</span>
<span class="line-removed">-         if (touchActions == TouchAction::Auto || touchActions == computedTouchActions)</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Now, the element&#39;s touch-action and the computed touch-action are different and are neither &quot;auto&quot; nor &quot;none&quot;.</span>
<span class="line-removed">-         if (computedTouchActions == TouchAction::Manipulation) {</span>
<span class="line-removed">-             // If the computed touch-action is &quot;manipulation&quot;, we can take the current element&#39;s touch-action as the newly</span>
<span class="line-removed">-             // computed touch-action.</span>
<span class="line-removed">-             computedTouchActions = touchActions;</span>
<span class="line-removed">-         } else if (touchActions == TouchAction::Manipulation) {</span>
<span class="line-removed">-             // Otherwise, we have a restricted computed touch-action so far. If the current element&#39;s touch-action is &quot;manipulation&quot;</span>
<span class="line-removed">-             // then we can just keep going and leave the computed touch-action untouched.</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // In any other case, we have competing restrictive touch-action values that can only yield &quot;none&quot;.</span>
<span class="line-removed">-         return TouchAction::None;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return computedTouchActions;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
<span class="line-removed">- ScrollingNodeID Element::nearestScrollingNodeIDUsingTouchOverflowScrolling() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!renderer())</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // We are not interested in the root, so check that we also have a valid parent.</span>
<span class="line-removed">-     for (auto* layer = renderer()-&gt;enclosingLayer(); layer &amp;&amp; layer-&gt;parent(); layer = layer-&gt;parent()) {</span>
<span class="line-removed">-         if (layer-&gt;isComposited()) {</span>
<span class="line-removed">-             if (auto scrollingNodeID = layer-&gt;backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling))</span>
<span class="line-removed">-                 return scrollingNodeID;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  } // namespace WebCore
<span class="line-new-header">--- 4241,6 ---</span>
</pre>
<center><a href="DocumentParser.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Element.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>