<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/URLParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &lt;wtf/URLParser.h&gt;
  28 
  29 #include &lt;array&gt;
  30 #include &lt;mutex&gt;
  31 #include &lt;unicode/uidna.h&gt;
  32 #include &lt;unicode/utf8.h&gt;
  33 #include &lt;unicode/utypes.h&gt;
  34 
  35 namespace WTF {
  36 
  37 #define URL_PARSER_DEBUGGING 0
  38 
  39 #if URL_PARSER_DEBUGGING
  40 #define URL_PARSER_LOG(...) WTFLogAlways(__VA_ARGS__)
  41 #else
  42 #define URL_PARSER_LOG(...)
  43 #endif
  44 
  45 template&lt;typename CharacterType&gt;
  46 class CodePointIterator {
  47     WTF_MAKE_FAST_ALLOCATED;
  48 public:
  49     ALWAYS_INLINE CodePointIterator() { }
  50     ALWAYS_INLINE CodePointIterator(const CharacterType* begin, const CharacterType* end)
  51         : m_begin(begin)
  52         , m_end(end)
  53     {
  54     }
  55 
  56     ALWAYS_INLINE CodePointIterator(const CodePointIterator&amp; begin, const CodePointIterator&amp; end)
  57         : CodePointIterator(begin.m_begin, end.m_begin)
  58     {
  59         ASSERT(end.m_begin &gt;= begin.m_begin);
  60     }
  61 
  62     ALWAYS_INLINE UChar32 operator*() const;
  63     ALWAYS_INLINE CodePointIterator&amp; operator++();
  64 
  65     ALWAYS_INLINE bool operator==(const CodePointIterator&amp; other) const
  66     {
  67         return m_begin == other.m_begin
  68             &amp;&amp; m_end == other.m_end;
  69     }
  70     ALWAYS_INLINE bool operator!=(const CodePointIterator&amp; other) const { return !(*this == other); }
  71 
  72     ALWAYS_INLINE bool atEnd() const
  73     {
  74         ASSERT(m_begin &lt;= m_end);
  75         return m_begin &gt;= m_end;
  76     }
  77 
  78     ALWAYS_INLINE size_t codeUnitsSince(const CharacterType* reference) const
  79     {
  80         ASSERT(m_begin &gt;= reference);
  81         return m_begin - reference;
  82     }
  83 
  84     ALWAYS_INLINE size_t codeUnitsSince(const CodePointIterator&amp; other) const
  85     {
  86         return codeUnitsSince(other.m_begin);
  87     }
  88 
  89 private:
  90     const CharacterType* m_begin { nullptr };
  91     const CharacterType* m_end { nullptr };
  92 };
  93 
  94 template&lt;&gt;
  95 ALWAYS_INLINE UChar32 CodePointIterator&lt;LChar&gt;::operator*() const
  96 {
  97     ASSERT(!atEnd());
  98     return *m_begin;
  99 }
 100 
 101 template&lt;&gt;
 102 ALWAYS_INLINE auto CodePointIterator&lt;LChar&gt;::operator++() -&gt; CodePointIterator&amp;
 103 {
 104     m_begin++;
 105     return *this;
 106 }
 107 
 108 template&lt;&gt;
 109 ALWAYS_INLINE UChar32 CodePointIterator&lt;UChar&gt;::operator*() const
 110 {
 111     ASSERT(!atEnd());
 112     UChar32 c;
 113     U16_GET(m_begin, 0, 0, m_end - m_begin, c);
 114     return c;
 115 }
 116 
 117 template&lt;&gt;
 118 ALWAYS_INLINE auto CodePointIterator&lt;UChar&gt;::operator++() -&gt; CodePointIterator&amp;
 119 {
 120     unsigned i = 0;
 121     size_t length = m_end - m_begin;
 122     U16_FWD_1(m_begin, i, length);
 123     m_begin += i;
 124     return *this;
 125 }
 126 
 127 ALWAYS_INLINE static void appendCodePoint(Vector&lt;UChar&gt;&amp; destination, UChar32 codePoint)
 128 {
 129     if (U_IS_BMP(codePoint)) {
 130         destination.append(static_cast&lt;UChar&gt;(codePoint));
 131         return;
 132     }
 133     destination.reserveCapacity(destination.size() + 2);
 134     destination.uncheckedAppend(U16_LEAD(codePoint));
 135     destination.uncheckedAppend(U16_TRAIL(codePoint));
 136 }
 137 
 138 enum URLCharacterClass {
 139     UserInfo = 0x1,
 140     Default = 0x2,
 141     ForbiddenHost = 0x4,
 142     QueryPercent = 0x8,
 143     SlashQuestionOrHash = 0x10,
 144     ValidScheme = 0x20,
 145 };
 146 
 147 static const uint8_t characterClassTable[256] = {
 148     UserInfo | Default | QueryPercent | ForbiddenHost, // 0x0
 149     UserInfo | Default | QueryPercent, // 0x1
 150     UserInfo | Default | QueryPercent, // 0x2
 151     UserInfo | Default | QueryPercent, // 0x3
 152     UserInfo | Default | QueryPercent, // 0x4
 153     UserInfo | Default | QueryPercent, // 0x5
 154     UserInfo | Default | QueryPercent, // 0x6
 155     UserInfo | Default | QueryPercent, // 0x7
 156     UserInfo | Default | QueryPercent, // 0x8
 157     UserInfo | Default | QueryPercent | ForbiddenHost, // 0x9
 158     UserInfo | Default | QueryPercent | ForbiddenHost, // 0xA
 159     UserInfo | Default | QueryPercent, // 0xB
 160     UserInfo | Default | QueryPercent, // 0xC
 161     UserInfo | Default | QueryPercent | ForbiddenHost, // 0xD
 162     UserInfo | Default | QueryPercent, // 0xE
 163     UserInfo | Default | QueryPercent, // 0xF
 164     UserInfo | Default | QueryPercent, // 0x10
 165     UserInfo | Default | QueryPercent, // 0x11
 166     UserInfo | Default | QueryPercent, // 0x12
 167     UserInfo | Default | QueryPercent, // 0x13
 168     UserInfo | Default | QueryPercent, // 0x14
 169     UserInfo | Default | QueryPercent, // 0x15
 170     UserInfo | Default | QueryPercent, // 0x16
 171     UserInfo | Default | QueryPercent, // 0x17
 172     UserInfo | Default | QueryPercent, // 0x18
 173     UserInfo | Default | QueryPercent, // 0x19
 174     UserInfo | Default | QueryPercent, // 0x1A
 175     UserInfo | Default | QueryPercent, // 0x1B
 176     UserInfo | Default | QueryPercent, // 0x1C
 177     UserInfo | Default | QueryPercent, // 0x1D
 178     UserInfo | Default | QueryPercent, // 0x1E
 179     UserInfo | Default | QueryPercent, // 0x1F
 180     UserInfo | Default | QueryPercent | ForbiddenHost, // &#39; &#39;
 181     0, // &#39;!&#39;
 182     UserInfo | Default | QueryPercent, // &#39;&quot;&#39;
 183     UserInfo | Default | QueryPercent | SlashQuestionOrHash | ForbiddenHost, // &#39;#&#39;
 184     0, // &#39;$&#39;
 185     ForbiddenHost, // &#39;%&#39;
 186     0, // &#39;&amp;&#39;
 187     0, // &#39;\&#39;&#39;
 188     0, // &#39;(&#39;
 189     0, // &#39;)&#39;
 190     0, // &#39;*&#39;
 191     ValidScheme, // &#39;+&#39;
 192     0, // &#39;,&#39;
 193     ValidScheme, // &#39;-&#39;
 194     ValidScheme, // &#39;.&#39;
 195     UserInfo | SlashQuestionOrHash | ForbiddenHost, // &#39;/&#39;
 196     ValidScheme, // &#39;0&#39;
 197     ValidScheme, // &#39;1&#39;
 198     ValidScheme, // &#39;2&#39;
 199     ValidScheme, // &#39;3&#39;
 200     ValidScheme, // &#39;4&#39;
 201     ValidScheme, // &#39;5&#39;
 202     ValidScheme, // &#39;6&#39;
 203     ValidScheme, // &#39;7&#39;
 204     ValidScheme, // &#39;8&#39;
 205     ValidScheme, // &#39;9&#39;
 206     UserInfo | ForbiddenHost, // &#39;:&#39;
 207     UserInfo, // &#39;;&#39;
 208     UserInfo | Default | QueryPercent | ForbiddenHost, // &#39;&lt;&#39;
 209     UserInfo, // &#39;=&#39;
 210     UserInfo | Default | QueryPercent | ForbiddenHost, // &#39;&gt;&#39;
 211     UserInfo | Default | SlashQuestionOrHash | ForbiddenHost, // &#39;?&#39;
 212     UserInfo | ForbiddenHost, // &#39;@&#39;
 213     ValidScheme, // &#39;A&#39;
 214     ValidScheme, // &#39;B&#39;
 215     ValidScheme, // &#39;C&#39;
 216     ValidScheme, // &#39;D&#39;
 217     ValidScheme, // &#39;E&#39;
 218     ValidScheme, // &#39;F&#39;
 219     ValidScheme, // &#39;G&#39;
 220     ValidScheme, // &#39;H&#39;
 221     ValidScheme, // &#39;I&#39;
 222     ValidScheme, // &#39;J&#39;
 223     ValidScheme, // &#39;K&#39;
 224     ValidScheme, // &#39;L&#39;
 225     ValidScheme, // &#39;M&#39;
 226     ValidScheme, // &#39;N&#39;
 227     ValidScheme, // &#39;O&#39;
 228     ValidScheme, // &#39;P&#39;
 229     ValidScheme, // &#39;Q&#39;
 230     ValidScheme, // &#39;R&#39;
 231     ValidScheme, // &#39;S&#39;
 232     ValidScheme, // &#39;T&#39;
 233     ValidScheme, // &#39;U&#39;
 234     ValidScheme, // &#39;V&#39;
 235     ValidScheme, // &#39;W&#39;
 236     ValidScheme, // &#39;X&#39;
 237     ValidScheme, // &#39;Y&#39;
 238     ValidScheme, // &#39;Z&#39;
 239     UserInfo | ForbiddenHost, // &#39;[&#39;
 240     UserInfo | SlashQuestionOrHash | ForbiddenHost, // &#39;\\&#39;
 241     UserInfo | ForbiddenHost, // &#39;]&#39;
 242     UserInfo, // &#39;^&#39;
 243     0, // &#39;_&#39;
 244     UserInfo | Default, // &#39;`&#39;
 245     ValidScheme, // &#39;a&#39;
 246     ValidScheme, // &#39;b&#39;
 247     ValidScheme, // &#39;c&#39;
 248     ValidScheme, // &#39;d&#39;
 249     ValidScheme, // &#39;e&#39;
 250     ValidScheme, // &#39;f&#39;
 251     ValidScheme, // &#39;g&#39;
 252     ValidScheme, // &#39;h&#39;
 253     ValidScheme, // &#39;i&#39;
 254     ValidScheme, // &#39;j&#39;
 255     ValidScheme, // &#39;k&#39;
 256     ValidScheme, // &#39;l&#39;
 257     ValidScheme, // &#39;m&#39;
 258     ValidScheme, // &#39;n&#39;
 259     ValidScheme, // &#39;o&#39;
 260     ValidScheme, // &#39;p&#39;
 261     ValidScheme, // &#39;q&#39;
 262     ValidScheme, // &#39;r&#39;
 263     ValidScheme, // &#39;s&#39;
 264     ValidScheme, // &#39;t&#39;
 265     ValidScheme, // &#39;u&#39;
 266     ValidScheme, // &#39;v&#39;
 267     ValidScheme, // &#39;w&#39;
 268     ValidScheme, // &#39;x&#39;
 269     ValidScheme, // &#39;y&#39;
 270     ValidScheme, // &#39;z&#39;
 271     UserInfo | Default, // &#39;{&#39;
 272     UserInfo, // &#39;|&#39;
 273     UserInfo | Default, // &#39;}&#39;
 274     0, // &#39;~&#39;
 275     QueryPercent, // 0x7F
 276     QueryPercent, // 0x80
 277     QueryPercent, // 0x81
 278     QueryPercent, // 0x82
 279     QueryPercent, // 0x83
 280     QueryPercent, // 0x84
 281     QueryPercent, // 0x85
 282     QueryPercent, // 0x86
 283     QueryPercent, // 0x87
 284     QueryPercent, // 0x88
 285     QueryPercent, // 0x89
 286     QueryPercent, // 0x8A
 287     QueryPercent, // 0x8B
 288     QueryPercent, // 0x8C
 289     QueryPercent, // 0x8D
 290     QueryPercent, // 0x8E
 291     QueryPercent, // 0x8F
 292     QueryPercent, // 0x90
 293     QueryPercent, // 0x91
 294     QueryPercent, // 0x92
 295     QueryPercent, // 0x93
 296     QueryPercent, // 0x94
 297     QueryPercent, // 0x95
 298     QueryPercent, // 0x96
 299     QueryPercent, // 0x97
 300     QueryPercent, // 0x98
 301     QueryPercent, // 0x99
 302     QueryPercent, // 0x9A
 303     QueryPercent, // 0x9B
 304     QueryPercent, // 0x9C
 305     QueryPercent, // 0x9D
 306     QueryPercent, // 0x9E
 307     QueryPercent, // 0x9F
 308     QueryPercent, // 0xA0
 309     QueryPercent, // 0xA1
 310     QueryPercent, // 0xA2
 311     QueryPercent, // 0xA3
 312     QueryPercent, // 0xA4
 313     QueryPercent, // 0xA5
 314     QueryPercent, // 0xA6
 315     QueryPercent, // 0xA7
 316     QueryPercent, // 0xA8
 317     QueryPercent, // 0xA9
 318     QueryPercent, // 0xAA
 319     QueryPercent, // 0xAB
 320     QueryPercent, // 0xAC
 321     QueryPercent, // 0xAD
 322     QueryPercent, // 0xAE
 323     QueryPercent, // 0xAF
 324     QueryPercent, // 0xB0
 325     QueryPercent, // 0xB1
 326     QueryPercent, // 0xB2
 327     QueryPercent, // 0xB3
 328     QueryPercent, // 0xB4
 329     QueryPercent, // 0xB5
 330     QueryPercent, // 0xB6
 331     QueryPercent, // 0xB7
 332     QueryPercent, // 0xB8
 333     QueryPercent, // 0xB9
 334     QueryPercent, // 0xBA
 335     QueryPercent, // 0xBB
 336     QueryPercent, // 0xBC
 337     QueryPercent, // 0xBD
 338     QueryPercent, // 0xBE
 339     QueryPercent, // 0xBF
 340     QueryPercent, // 0xC0
 341     QueryPercent, // 0xC1
 342     QueryPercent, // 0xC2
 343     QueryPercent, // 0xC3
 344     QueryPercent, // 0xC4
 345     QueryPercent, // 0xC5
 346     QueryPercent, // 0xC6
 347     QueryPercent, // 0xC7
 348     QueryPercent, // 0xC8
 349     QueryPercent, // 0xC9
 350     QueryPercent, // 0xCA
 351     QueryPercent, // 0xCB
 352     QueryPercent, // 0xCC
 353     QueryPercent, // 0xCD
 354     QueryPercent, // 0xCE
 355     QueryPercent, // 0xCF
 356     QueryPercent, // 0xD0
 357     QueryPercent, // 0xD1
 358     QueryPercent, // 0xD2
 359     QueryPercent, // 0xD3
 360     QueryPercent, // 0xD4
 361     QueryPercent, // 0xD5
 362     QueryPercent, // 0xD6
 363     QueryPercent, // 0xD7
 364     QueryPercent, // 0xD8
 365     QueryPercent, // 0xD9
 366     QueryPercent, // 0xDA
 367     QueryPercent, // 0xDB
 368     QueryPercent, // 0xDC
 369     QueryPercent, // 0xDD
 370     QueryPercent, // 0xDE
 371     QueryPercent, // 0xDF
 372     QueryPercent, // 0xE0
 373     QueryPercent, // 0xE1
 374     QueryPercent, // 0xE2
 375     QueryPercent, // 0xE3
 376     QueryPercent, // 0xE4
 377     QueryPercent, // 0xE5
 378     QueryPercent, // 0xE6
 379     QueryPercent, // 0xE7
 380     QueryPercent, // 0xE8
 381     QueryPercent, // 0xE9
 382     QueryPercent, // 0xEA
 383     QueryPercent, // 0xEB
 384     QueryPercent, // 0xEC
 385     QueryPercent, // 0xED
 386     QueryPercent, // 0xEE
 387     QueryPercent, // 0xEF
 388     QueryPercent, // 0xF0
 389     QueryPercent, // 0xF1
 390     QueryPercent, // 0xF2
 391     QueryPercent, // 0xF3
 392     QueryPercent, // 0xF4
 393     QueryPercent, // 0xF5
 394     QueryPercent, // 0xF6
 395     QueryPercent, // 0xF7
 396     QueryPercent, // 0xF8
 397     QueryPercent, // 0xF9
 398     QueryPercent, // 0xFA
 399     QueryPercent, // 0xFB
 400     QueryPercent, // 0xFC
 401     QueryPercent, // 0xFD
 402     QueryPercent, // 0xFE
 403     QueryPercent, // 0xFF
 404 };
 405 
 406 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isC0Control(CharacterType character) { return character &lt;= 0x1F; }
 407 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isC0ControlOrSpace(CharacterType character) { return character &lt;= 0x20; }
 408 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isTabOrNewline(CharacterType character) { return character &lt;= 0xD &amp;&amp; character &gt;= 0x9 &amp;&amp; character != 0xB &amp;&amp; character != 0xC; }
 409 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isInSimpleEncodeSet(CharacterType character) { return character &gt; 0x7E || isC0Control(character); }
 410 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isInDefaultEncodeSet(CharacterType character) { return character &gt; 0x7E || characterClassTable[character] &amp; Default; }
 411 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isInUserInfoEncodeSet(CharacterType character) { return character &gt; 0x7E || characterClassTable[character] &amp; UserInfo; }
 412 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isPercentOrNonASCII(CharacterType character) { return !isASCII(character) || character == &#39;%&#39;; }
 413 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isSlashQuestionOrHash(CharacterType character) { return character &lt;= &#39;\\&#39; &amp;&amp; characterClassTable[character] &amp; SlashQuestionOrHash; }
 414 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isValidSchemeCharacter(CharacterType character) { return character &lt;= &#39;z&#39; &amp;&amp; characterClassTable[character] &amp; ValidScheme; }
 415 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isForbiddenHostCodePoint(CharacterType character) { return character &lt;= &#39;]&#39; &amp;&amp; characterClassTable[character] &amp; ForbiddenHost; }
 416 ALWAYS_INLINE static bool shouldPercentEncodeQueryByte(uint8_t byte, const bool&amp; urlIsSpecial)
 417 {
 418     if (characterClassTable[byte] &amp; QueryPercent)
 419         return true;
 420     if (byte == &#39;\&#39;&#39; &amp;&amp; urlIsSpecial)
 421         return true;
 422     return false;
 423 }
 424 
 425 bool URLParser::isInUserInfoEncodeSet(UChar c)
 426 {
 427     return WTF::isInUserInfoEncodeSet(c);
 428 }
 429 
 430 template&lt;typename CharacterType, URLParser::ReportSyntaxViolation reportSyntaxViolation&gt;
 431 ALWAYS_INLINE void URLParser::advance(CodePointIterator&lt;CharacterType&gt;&amp; iterator, const CodePointIterator&lt;CharacterType&gt;&amp; iteratorForSyntaxViolationPosition)
 432 {
 433     ++iterator;
 434     while (UNLIKELY(!iterator.atEnd() &amp;&amp; isTabOrNewline(*iterator))) {
 435         if (reportSyntaxViolation == ReportSyntaxViolation::Yes)
 436             syntaxViolation(iteratorForSyntaxViolationPosition);
 437         ++iterator;
 438     }
 439 }
 440 
 441 template&lt;typename CharacterType&gt;
 442 bool URLParser::takesTwoAdvancesUntilEnd(CodePointIterator&lt;CharacterType&gt; iterator)
 443 {
 444     if (iterator.atEnd())
 445         return false;
 446     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
 447     if (iterator.atEnd())
 448         return false;
 449     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
 450     return iterator.atEnd();
 451 }
 452 
 453 template&lt;typename CharacterType&gt;
 454 ALWAYS_INLINE bool URLParser::isWindowsDriveLetter(CodePointIterator&lt;CharacterType&gt; iterator)
 455 {
 456     if (iterator.atEnd() || !isASCIIAlpha(*iterator))
 457         return false;
 458     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
 459     if (iterator.atEnd())
 460         return false;
 461     if (*iterator == &#39;:&#39;)
 462         return true;
 463     if (UNLIKELY(*iterator == &#39;|&#39;))
 464         return true;
 465     return false;
 466 }
 467 
 468 ALWAYS_INLINE void URLParser::appendToASCIIBuffer(UChar32 codePoint)
 469 {
 470     ASSERT(isASCII(codePoint));
 471     if (UNLIKELY(m_didSeeSyntaxViolation))
 472         m_asciiBuffer.append(codePoint);
 473 }
 474 
 475 ALWAYS_INLINE void URLParser::appendToASCIIBuffer(const char* characters, size_t length)
 476 {
 477     if (UNLIKELY(m_didSeeSyntaxViolation))
 478         m_asciiBuffer.append(characters, length);
 479 }
 480 
 481 template&lt;typename CharacterType&gt;
 482 void URLParser::appendWindowsDriveLetter(CodePointIterator&lt;CharacterType&gt;&amp; iterator)
 483 {
 484     ASSERT(isWindowsDriveLetter(iterator));
 485     appendToASCIIBuffer(*iterator);
 486     advance(iterator);
 487     ASSERT(!iterator.atEnd());
 488     ASSERT(*iterator == &#39;:&#39; || *iterator == &#39;|&#39;);
 489     if (*iterator == &#39;|&#39;)
 490         syntaxViolation(iterator);
 491     appendToASCIIBuffer(&#39;:&#39;);
 492     advance(iterator);
 493 }
 494 
 495 bool URLParser::copyBaseWindowsDriveLetter(const URL&amp; base)
 496 {
 497     if (base.protocolIs(&quot;file&quot;)) {
 498         RELEASE_ASSERT(base.m_hostEnd + base.m_portLength &lt; base.m_string.length());
 499         if (base.m_string.is8Bit()) {
 500             const LChar* begin = base.m_string.characters8();
 501             CodePointIterator&lt;LChar&gt; c(begin + base.m_hostEnd + base.m_portLength + 1, begin + base.m_string.length());
 502             if (isWindowsDriveLetter(c)) {
 503                 appendWindowsDriveLetter(c);
 504                 return true;
 505             }
 506         } else {
 507             const UChar* begin = base.m_string.characters16();
 508             CodePointIterator&lt;UChar&gt; c(begin + base.m_hostEnd + base.m_portLength + 1, begin + base.m_string.length());
 509             if (isWindowsDriveLetter(c)) {
 510                 appendWindowsDriveLetter(c);
 511                 return true;
 512             }
 513         }
 514     }
 515     return false;
 516 }
 517 
 518 template&lt;typename CharacterType&gt;
 519 bool URLParser::shouldCopyFileURL(CodePointIterator&lt;CharacterType&gt; iterator)
 520 {
 521     if (!isWindowsDriveLetter(iterator))
 522         return true;
 523     if (iterator.atEnd())
 524         return false;
 525     advance(iterator);
 526     if (iterator.atEnd())
 527         return true;
 528     advance(iterator);
 529     if (iterator.atEnd())
 530         return true;
 531     return !isSlashQuestionOrHash(*iterator);
 532 }
 533 
 534 static void percentEncodeByte(uint8_t byte, Vector&lt;LChar&gt;&amp; buffer)
 535 {
 536     buffer.append(&#39;%&#39;);
 537     buffer.append(upperNibbleToASCIIHexDigit(byte));
 538     buffer.append(lowerNibbleToASCIIHexDigit(byte));
 539 }
 540 
 541 void URLParser::percentEncodeByte(uint8_t byte)
 542 {
 543     ASSERT(m_didSeeSyntaxViolation);
 544     appendToASCIIBuffer(&#39;%&#39;);
 545     appendToASCIIBuffer(upperNibbleToASCIIHexDigit(byte));
 546     appendToASCIIBuffer(lowerNibbleToASCIIHexDigit(byte));
 547 }
 548 
 549 const char replacementCharacterUTF8PercentEncoded[10] = &quot;%EF%BF%BD&quot;;
 550 const size_t replacementCharacterUTF8PercentEncodedLength = sizeof(replacementCharacterUTF8PercentEncoded) - 1;
 551 
 552 template&lt;bool(*isInCodeSet)(UChar32), typename CharacterType&gt;
 553 ALWAYS_INLINE void URLParser::utf8PercentEncode(const CodePointIterator&lt;CharacterType&gt;&amp; iterator)
 554 {
 555     ASSERT(!iterator.atEnd());
 556     UChar32 codePoint = *iterator;
 557     if (LIKELY(isASCII(codePoint))) {
 558         if (UNLIKELY(isInCodeSet(codePoint))) {
 559             syntaxViolation(iterator);
 560             percentEncodeByte(codePoint);
 561         } else
 562             appendToASCIIBuffer(codePoint);
 563         return;
 564     }
 565     ASSERT_WITH_MESSAGE(isInCodeSet(codePoint), &quot;isInCodeSet should always return true for non-ASCII characters&quot;);
 566     syntaxViolation(iterator);
 567 
 568     if (!U_IS_UNICODE_CHAR(codePoint)) {
 569         appendToASCIIBuffer(replacementCharacterUTF8PercentEncoded, replacementCharacterUTF8PercentEncodedLength);
 570         return;
 571     }
 572 
 573     uint8_t buffer[U8_MAX_LENGTH];
 574     int32_t offset = 0;
 575     U8_APPEND_UNSAFE(buffer, offset, codePoint);
 576     for (int32_t i = 0; i &lt; offset; ++i)
 577         percentEncodeByte(buffer[i]);
 578 }
 579 
 580 template&lt;typename CharacterType&gt;
 581 ALWAYS_INLINE void URLParser::utf8QueryEncode(const CodePointIterator&lt;CharacterType&gt;&amp; iterator)
 582 {
 583     ASSERT(!iterator.atEnd());
 584     UChar32 codePoint = *iterator;
 585     if (LIKELY(isASCII(codePoint))) {
 586         if (UNLIKELY(shouldPercentEncodeQueryByte(codePoint, m_urlIsSpecial))) {
 587             syntaxViolation(iterator);
 588             percentEncodeByte(codePoint);
 589         } else
 590             appendToASCIIBuffer(codePoint);
 591         return;
 592     }
 593 
 594     syntaxViolation(iterator);
 595 
 596     if (!U_IS_UNICODE_CHAR(codePoint)) {
 597         appendToASCIIBuffer(replacementCharacterUTF8PercentEncoded, replacementCharacterUTF8PercentEncodedLength);
 598         return;
 599     }
 600 
 601     uint8_t buffer[U8_MAX_LENGTH];
 602     int32_t offset = 0;
 603     U8_APPEND_UNSAFE(buffer, offset, codePoint);
 604     for (int32_t i = 0; i &lt; offset; ++i) {
 605         auto byte = buffer[i];
 606         if (shouldPercentEncodeQueryByte(byte, m_urlIsSpecial))
 607             percentEncodeByte(byte);
 608         else
 609             appendToASCIIBuffer(byte);
 610     }
 611 }
 612 
 613 template&lt;typename CharacterType&gt;
 614 void URLParser::encodeNonUTF8Query(const Vector&lt;UChar&gt;&amp; source, const URLTextEncoding&amp; encoding, CodePointIterator&lt;CharacterType&gt; iterator)
 615 {
 616     auto encoded = encoding.encodeForURLParsing(StringView(source.data(), source.size()));
 617     auto* data = encoded.data();
 618     size_t length = encoded.size();
 619 
 620     if (!length == !iterator.atEnd()) {
 621         syntaxViolation(iterator);
 622         return;
 623     }
 624 
 625     size_t i = 0;
 626     for (; i &lt; length; ++i) {
 627         ASSERT(!iterator.atEnd());
 628         uint8_t byte = data[i];
 629         if (UNLIKELY(byte != *iterator)) {
 630             syntaxViolation(iterator);
 631             break;
 632         }
 633         if (UNLIKELY(shouldPercentEncodeQueryByte(byte, m_urlIsSpecial))) {
 634             syntaxViolation(iterator);
 635             break;
 636         }
 637         appendToASCIIBuffer(byte);
 638         ++iterator;
 639     }
 640     while (!iterator.atEnd() &amp;&amp; isTabOrNewline(*iterator))
 641         ++iterator;
 642     ASSERT((i == length) == iterator.atEnd());
 643     for (; i &lt; length; ++i) {
 644         ASSERT(m_didSeeSyntaxViolation);
 645         uint8_t byte = data[i];
 646         if (shouldPercentEncodeQueryByte(byte, m_urlIsSpecial))
 647             percentEncodeByte(byte);
 648         else
 649             appendToASCIIBuffer(byte);
 650     }
 651 }
 652 
 653 Optional&lt;uint16_t&gt; URLParser::defaultPortForProtocol(StringView scheme)
 654 {
 655     static const uint16_t ftpPort = 21;
 656     static const uint16_t gopherPort = 70;
 657     static const uint16_t httpPort = 80;
 658     static const uint16_t httpsPort = 443;
 659     static const uint16_t wsPort = 80;
 660     static const uint16_t wssPort = 443;
 661 
 662     auto length = scheme.length();
 663     if (!length)
 664         return WTF::nullopt;
 665     switch (scheme[0]) {
 666     case &#39;w&#39;:
 667         switch (length) {
 668         case 2:
 669             if (scheme[1] == &#39;s&#39;)
 670                 return wsPort;
 671             return WTF::nullopt;
 672         case 3:
 673             if (scheme[1] == &#39;s&#39;
 674                 &amp;&amp; scheme[2] == &#39;s&#39;)
 675                 return wssPort;
 676             return WTF::nullopt;
 677         default:
 678             return false;
 679         }
 680     case &#39;h&#39;:
 681         switch (length) {
 682         case 4:
 683             if (scheme[1] == &#39;t&#39;
 684                 &amp;&amp; scheme[2] == &#39;t&#39;
 685                 &amp;&amp; scheme[3] == &#39;p&#39;)
 686                 return httpPort;
 687             return WTF::nullopt;
 688         case 5:
 689             if (scheme[1] == &#39;t&#39;
 690                 &amp;&amp; scheme[2] == &#39;t&#39;
 691                 &amp;&amp; scheme[3] == &#39;p&#39;
 692                 &amp;&amp; scheme[4] == &#39;s&#39;)
 693                 return httpsPort;
 694             return WTF::nullopt;
 695         default:
 696             return WTF::nullopt;
 697         }
 698     case &#39;g&#39;:
 699         if (length == 6
 700             &amp;&amp; scheme[1] == &#39;o&#39;
 701             &amp;&amp; scheme[2] == &#39;p&#39;
 702             &amp;&amp; scheme[3] == &#39;h&#39;
 703             &amp;&amp; scheme[4] == &#39;e&#39;
 704             &amp;&amp; scheme[5] == &#39;r&#39;)
 705             return gopherPort;
 706         return WTF::nullopt;
 707     case &#39;f&#39;:
 708         if (length == 3
 709             &amp;&amp; scheme[1] == &#39;t&#39;
 710             &amp;&amp; scheme[2] == &#39;p&#39;)
 711             return ftpPort;
 712         return WTF::nullopt;
 713     default:
 714         return WTF::nullopt;
 715     }
 716 }
 717 
 718 enum class Scheme {
 719 #if PLATFORM(JAVA)
 720     JAR,
 721 #endif
 722     WS,
 723     WSS,
 724     File,
 725     FTP,
 726     Gopher,
 727     HTTP,
 728     HTTPS,
 729     NonSpecial
 730 };
 731 
 732 ALWAYS_INLINE static Scheme scheme(StringView scheme)
 733 {
 734     auto length = scheme.length();
 735     if (!length)
 736         return Scheme::NonSpecial;
 737     switch (scheme[0]) {
 738     case &#39;f&#39;:
 739         switch (length) {
 740         case 3:
 741             if (scheme[1] == &#39;t&#39;
 742                 &amp;&amp; scheme[2] == &#39;p&#39;)
 743                 return Scheme::FTP;
 744             return Scheme::NonSpecial;
 745         case 4:
 746             if (scheme[1] == &#39;i&#39;
 747                 &amp;&amp; scheme[2] == &#39;l&#39;
 748                 &amp;&amp; scheme[3] == &#39;e&#39;)
 749                 return Scheme::File;
 750             return Scheme::NonSpecial;
 751         default:
 752             return Scheme::NonSpecial;
 753         }
 754     case &#39;g&#39;:
 755         if (length == 6
 756             &amp;&amp; scheme[1] == &#39;o&#39;
 757             &amp;&amp; scheme[2] == &#39;p&#39;
 758             &amp;&amp; scheme[3] == &#39;h&#39;
 759             &amp;&amp; scheme[4] == &#39;e&#39;
 760             &amp;&amp; scheme[5] == &#39;r&#39;)
 761             return Scheme::Gopher;
 762         return Scheme::NonSpecial;
 763     case &#39;h&#39;:
 764         switch (length) {
 765         case 4:
 766             if (scheme[1] == &#39;t&#39;
 767                 &amp;&amp; scheme[2] == &#39;t&#39;
 768                 &amp;&amp; scheme[3] == &#39;p&#39;)
 769                 return Scheme::HTTP;
 770             return Scheme::NonSpecial;
 771         case 5:
 772             if (scheme[1] == &#39;t&#39;
 773                 &amp;&amp; scheme[2] == &#39;t&#39;
 774                 &amp;&amp; scheme[3] == &#39;p&#39;
 775                 &amp;&amp; scheme[4] == &#39;s&#39;)
 776                 return Scheme::HTTPS;
 777             return Scheme::NonSpecial;
 778         default:
 779             return Scheme::NonSpecial;
 780         }
 781     case &#39;w&#39;:
 782         switch (length) {
 783         case 2:
 784             if (scheme[1] == &#39;s&#39;)
 785                 return Scheme::WS;
 786             return Scheme::NonSpecial;
 787         case 3:
 788             if (scheme[1] == &#39;s&#39;
 789                 &amp;&amp; scheme[2] == &#39;s&#39;)
 790                 return Scheme::WSS;
 791             return Scheme::NonSpecial;
 792         default:
 793             return Scheme::NonSpecial;
 794         }
 795 #if PLATFORM(JAVA)
 796      case &#39;j&#39;:
 797         if (length == 3 &amp;&amp; scheme[1] == &#39;a&#39; &amp;&amp; scheme[2] == &#39;r&#39;)
 798             return Scheme::JAR;
 799         return Scheme::NonSpecial;
 800 #endif
 801     default:
 802         return Scheme::NonSpecial;
 803     }
 804 }
 805 
 806 Optional&lt;String&gt; URLParser::maybeCanonicalizeScheme(const String&amp; scheme)
 807 {
 808     if (scheme.isEmpty())
 809         return WTF::nullopt;
 810 
 811     if (!isASCIIAlpha(scheme[0]))
 812         return WTF::nullopt;
 813 
 814     for (size_t i = 1; i &lt; scheme.length(); ++i) {
 815         if (isASCIIAlphanumeric(scheme[i]) || scheme[i] == &#39;+&#39; || scheme[i] == &#39;-&#39; || scheme[i] == &#39;.&#39;)
 816             continue;
 817         return WTF::nullopt;
 818     }
 819 
 820     return scheme.convertToASCIILowercase();
 821 }
 822 
 823 bool URLParser::isSpecialScheme(const String&amp; schemeArg)
 824 {
 825     return scheme(schemeArg) != Scheme::NonSpecial;
 826 }
 827 
 828 enum class URLParser::URLPart {
 829     SchemeEnd,
 830     UserStart,
 831     UserEnd,
 832     PasswordEnd,
 833     HostEnd,
 834     PortEnd,
 835     PathAfterLastSlash,
 836     PathEnd,
 837     QueryEnd,
 838 };
 839 
 840 size_t URLParser::urlLengthUntilPart(const URL&amp; url, URLPart part)
 841 {
 842     switch (part) {
 843     case URLPart::QueryEnd:
 844         return url.m_queryEnd;
 845     case URLPart::PathEnd:
 846         return url.m_pathEnd;
 847     case URLPart::PathAfterLastSlash:
 848         return url.m_pathAfterLastSlash;
 849     case URLPart::PortEnd:
 850         return url.m_hostEnd + url.m_portLength;
 851     case URLPart::HostEnd:
 852         return url.m_hostEnd;
 853     case URLPart::PasswordEnd:
 854         return url.m_passwordEnd;
 855     case URLPart::UserEnd:
 856         return url.m_userEnd;
 857     case URLPart::UserStart:
 858         return url.m_userStart;
 859     case URLPart::SchemeEnd:
 860         return url.m_schemeEnd;
 861     }
 862     ASSERT_NOT_REACHED();
 863     return 0;
 864 }
 865 
 866 void URLParser::copyASCIIStringUntil(const String&amp; string, size_t length)
 867 {
 868     RELEASE_ASSERT(length &lt;= string.length());
 869     if (string.isNull())
 870         return;
 871     ASSERT(m_asciiBuffer.isEmpty());
 872     if (string.is8Bit())
 873         appendToASCIIBuffer(string.characters8(), length);
 874     else {
 875         const UChar* characters = string.characters16();
 876         for (size_t i = 0; i &lt; length; ++i) {
 877             UChar c = characters[i];
 878             ASSERT_WITH_SECURITY_IMPLICATION(isASCII(c));
 879             appendToASCIIBuffer(c);
 880         }
 881     }
 882 }
 883 
 884 template&lt;typename CharacterType&gt;
 885 void URLParser::copyURLPartsUntil(const URL&amp; base, URLPart part, const CodePointIterator&lt;CharacterType&gt;&amp; iterator, const URLTextEncoding*&amp; nonUTF8QueryEncoding)
 886 {
 887     syntaxViolation(iterator);
 888 
 889     m_asciiBuffer.clear();
 890     copyASCIIStringUntil(base.m_string, urlLengthUntilPart(base, part));
 891     switch (part) {
 892     case URLPart::QueryEnd:
 893         m_url.m_queryEnd = base.m_queryEnd;
 894         FALLTHROUGH;
 895     case URLPart::PathEnd:
 896         m_url.m_pathEnd = base.m_pathEnd;
 897         FALLTHROUGH;
 898     case URLPart::PathAfterLastSlash:
 899         m_url.m_pathAfterLastSlash = base.m_pathAfterLastSlash;
 900         FALLTHROUGH;
 901     case URLPart::PortEnd:
 902         m_url.m_portLength = base.m_portLength;
 903         FALLTHROUGH;
 904     case URLPart::HostEnd:
 905         m_url.m_hostEnd = base.m_hostEnd;
 906         FALLTHROUGH;
 907     case URLPart::PasswordEnd:
 908         m_url.m_passwordEnd = base.m_passwordEnd;
 909         FALLTHROUGH;
 910     case URLPart::UserEnd:
 911         m_url.m_userEnd = base.m_userEnd;
 912         FALLTHROUGH;
 913     case URLPart::UserStart:
 914         m_url.m_userStart = base.m_userStart;
 915         FALLTHROUGH;
 916     case URLPart::SchemeEnd:
 917         m_url.m_isValid = base.m_isValid;
 918         m_url.m_protocolIsInHTTPFamily = base.m_protocolIsInHTTPFamily;
 919         m_url.m_schemeEnd = base.m_schemeEnd;
 920     }
 921     switch (scheme(StringView(m_asciiBuffer.data(), m_url.m_schemeEnd))) {
 922 #if PLATFORM(JAVA)
 923     case Scheme::JAR:
 924         break;
 925 #endif
 926     case Scheme::WS:
 927     case Scheme::WSS:
 928         nonUTF8QueryEncoding = nullptr;
 929         m_urlIsSpecial = true;
 930         return;
 931     case Scheme::File:
 932         m_urlIsFile = true;
 933         FALLTHROUGH;
 934     case Scheme::FTP:
 935     case Scheme::Gopher:
 936     case Scheme::HTTP:
 937     case Scheme::HTTPS:
 938         m_urlIsSpecial = true;
 939         return;
 940     case Scheme::NonSpecial:
 941         m_urlIsSpecial = false;
 942         nonUTF8QueryEncoding = nullptr;
 943         return;
 944     }
 945     ASSERT_NOT_REACHED();
 946 }
 947 
 948 static const char dotASCIICode[2] = {&#39;2&#39;, &#39;e&#39;};
 949 
 950 template&lt;typename CharacterType&gt;
 951 ALWAYS_INLINE bool URLParser::isSingleDotPathSegment(CodePointIterator&lt;CharacterType&gt; c)
 952 {
 953     if (c.atEnd())
 954         return false;
 955     if (*c == &#39;.&#39;) {
 956         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 957         return c.atEnd() || isSlashQuestionOrHash(*c);
 958     }
 959     if (*c != &#39;%&#39;)
 960         return false;
 961     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 962     if (c.atEnd() || *c != dotASCIICode[0])
 963         return false;
 964     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 965     if (c.atEnd())
 966         return false;
 967     if (toASCIILower(*c) == dotASCIICode[1]) {
 968         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 969         return c.atEnd() || isSlashQuestionOrHash(*c);
 970     }
 971     return false;
 972 }
 973 
 974 template&lt;typename CharacterType&gt;
 975 ALWAYS_INLINE bool URLParser::isDoubleDotPathSegment(CodePointIterator&lt;CharacterType&gt; c)
 976 {
 977     if (c.atEnd())
 978         return false;
 979     if (*c == &#39;.&#39;) {
 980         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 981         return isSingleDotPathSegment(c);
 982     }
 983     if (*c != &#39;%&#39;)
 984         return false;
 985     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 986     if (c.atEnd() || *c != dotASCIICode[0])
 987         return false;
 988     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 989     if (c.atEnd())
 990         return false;
 991     if (toASCIILower(*c) == dotASCIICode[1]) {
 992         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 993         return isSingleDotPathSegment(c);
 994     }
 995     return false;
 996 }
 997 
 998 template&lt;typename CharacterType&gt;
 999 void URLParser::consumeSingleDotPathSegment(CodePointIterator&lt;CharacterType&gt;&amp; c)
1000 {
1001     ASSERT(isSingleDotPathSegment(c));
1002     if (*c == &#39;.&#39;) {
1003         advance(c);
1004         if (!c.atEnd()) {
1005             if (*c == &#39;/&#39; || *c == &#39;\\&#39;)
1006                 advance(c);
1007             else
1008                 ASSERT(*c == &#39;?&#39; || *c == &#39;#&#39;);
1009         }
1010     } else {
1011         ASSERT(*c == &#39;%&#39;);
1012         advance(c);
1013         ASSERT(*c == dotASCIICode[0]);
1014         advance(c);
1015         ASSERT(toASCIILower(*c) == dotASCIICode[1]);
1016         advance(c);
1017         if (!c.atEnd()) {
1018             if (*c == &#39;/&#39; || *c == &#39;\\&#39;)
1019                 advance(c);
1020             else
1021                 ASSERT(*c == &#39;?&#39; || *c == &#39;#&#39;);
1022         }
1023     }
1024 }
1025 
1026 template&lt;typename CharacterType&gt;
1027 void URLParser::consumeDoubleDotPathSegment(CodePointIterator&lt;CharacterType&gt;&amp; c)
1028 {
1029     ASSERT(isDoubleDotPathSegment(c));
1030     if (*c == &#39;.&#39;)
1031         advance(c);
1032     else {
1033         ASSERT(*c == &#39;%&#39;);
1034         advance(c);
1035         ASSERT(*c == dotASCIICode[0]);
1036         advance(c);
1037         ASSERT(toASCIILower(*c) == dotASCIICode[1]);
1038         advance(c);
1039     }
1040     consumeSingleDotPathSegment(c);
1041 }
1042 
1043 bool URLParser::shouldPopPath(unsigned newPathAfterLastSlash)
1044 {
1045     ASSERT(m_didSeeSyntaxViolation);
1046     if (!m_urlIsFile)
1047         return true;
1048 
1049     ASSERT(m_url.m_pathAfterLastSlash &lt;= m_asciiBuffer.size());
1050     CodePointIterator&lt;LChar&gt; componentToPop(&amp;m_asciiBuffer[newPathAfterLastSlash], &amp;m_asciiBuffer[0] + m_url.m_pathAfterLastSlash);
1051     if (newPathAfterLastSlash == m_url.m_hostEnd + m_url.m_portLength + 1 &amp;&amp; isWindowsDriveLetter(componentToPop))
1052         return false;
1053     return true;
1054 }
1055 
1056 void URLParser::popPath()
1057 {
1058     ASSERT(m_didSeeSyntaxViolation);
1059     if (m_url.m_pathAfterLastSlash &gt; m_url.m_hostEnd + m_url.m_portLength + 1) {
1060         auto newPathAfterLastSlash = m_url.m_pathAfterLastSlash - 1;
1061         if (m_asciiBuffer[newPathAfterLastSlash] == &#39;/&#39;)
1062             newPathAfterLastSlash--;
1063         while (newPathAfterLastSlash &gt; m_url.m_hostEnd + m_url.m_portLength &amp;&amp; m_asciiBuffer[newPathAfterLastSlash] != &#39;/&#39;)
1064             newPathAfterLastSlash--;
1065         newPathAfterLastSlash++;
1066         if (shouldPopPath(newPathAfterLastSlash))
1067             m_url.m_pathAfterLastSlash = newPathAfterLastSlash;
1068     }
1069     m_asciiBuffer.resize(m_url.m_pathAfterLastSlash);
1070 }
1071 
1072 template&lt;typename CharacterType&gt;
1073 void URLParser::syntaxViolation(const CodePointIterator&lt;CharacterType&gt;&amp; iterator)
1074 {
1075     if (m_didSeeSyntaxViolation)
1076         return;
1077     m_didSeeSyntaxViolation = true;
1078 
1079     ASSERT(m_asciiBuffer.isEmpty());
1080     size_t codeUnitsToCopy = iterator.codeUnitsSince(reinterpret_cast&lt;const CharacterType*&gt;(m_inputBegin));
1081     RELEASE_ASSERT(codeUnitsToCopy &lt;= m_inputString.length());
1082     m_asciiBuffer.reserveCapacity(m_inputString.length());
1083     for (size_t i = 0; i &lt; codeUnitsToCopy; ++i) {
1084         ASSERT(isASCII(m_inputString[i]));
1085         m_asciiBuffer.uncheckedAppend(m_inputString[i]);
1086     }
1087 }
1088 
1089 void URLParser::failure()
1090 {
1091     m_url.invalidate();
1092     m_url.m_string = m_inputString;
1093 }
1094 
1095 template&lt;typename CharacterType&gt;
1096 bool URLParser::checkLocalhostCodePoint(CodePointIterator&lt;CharacterType&gt;&amp; iterator, UChar32 codePoint)
1097 {
1098     if (iterator.atEnd() || toASCIILower(*iterator) != codePoint)
1099         return false;
1100     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
1101     return true;
1102 }
1103 
1104 template&lt;typename CharacterType&gt;
1105 bool URLParser::isAtLocalhost(CodePointIterator&lt;CharacterType&gt; iterator)
1106 {
1107     if (!checkLocalhostCodePoint(iterator, &#39;l&#39;))
1108         return false;
1109     if (!checkLocalhostCodePoint(iterator, &#39;o&#39;))
1110         return false;
1111     if (!checkLocalhostCodePoint(iterator, &#39;c&#39;))
1112         return false;
1113     if (!checkLocalhostCodePoint(iterator, &#39;a&#39;))
1114         return false;
1115     if (!checkLocalhostCodePoint(iterator, &#39;l&#39;))
1116         return false;
1117     if (!checkLocalhostCodePoint(iterator, &#39;h&#39;))
1118         return false;
1119     if (!checkLocalhostCodePoint(iterator, &#39;o&#39;))
1120         return false;
1121     if (!checkLocalhostCodePoint(iterator, &#39;s&#39;))
1122         return false;
1123     if (!checkLocalhostCodePoint(iterator, &#39;t&#39;))
1124         return false;
1125     return iterator.atEnd();
1126 }
1127 
1128 bool URLParser::isLocalhost(StringView view)
1129 {
1130     if (view.is8Bit())
1131         return isAtLocalhost(CodePointIterator&lt;LChar&gt;(view.characters8(), view.characters8() + view.length()));
1132     return isAtLocalhost(CodePointIterator&lt;UChar&gt;(view.characters16(), view.characters16() + view.length()));
1133 }
1134 
1135 ALWAYS_INLINE StringView URLParser::parsedDataView(size_t start, size_t length)
1136 {
1137     if (UNLIKELY(m_didSeeSyntaxViolation)) {
1138         ASSERT(start + length &lt;= m_asciiBuffer.size());
1139         return StringView(m_asciiBuffer.data() + start, length);
1140     }
1141     ASSERT(start + length &lt;= m_inputString.length());
1142     return StringView(m_inputString).substring(start, length);
1143 }
1144 
1145 ALWAYS_INLINE UChar URLParser::parsedDataView(size_t position)
1146 {
1147     if (UNLIKELY(m_didSeeSyntaxViolation))
1148         return m_asciiBuffer[position];
1149     return m_inputString[position];
1150 }
1151 
1152 template&lt;typename CharacterType&gt;
1153 ALWAYS_INLINE size_t URLParser::currentPosition(const CodePointIterator&lt;CharacterType&gt;&amp; iterator)
1154 {
1155     if (UNLIKELY(m_didSeeSyntaxViolation))
1156         return m_asciiBuffer.size();
1157 
1158     return iterator.codeUnitsSince(reinterpret_cast&lt;const CharacterType*&gt;(m_inputBegin));
1159 }
1160 
1161 URLParser::URLParser(const String&amp; input, const URL&amp; base, const URLTextEncoding* nonUTF8QueryEncoding)
1162     : m_inputString(input)
1163 {
1164     if (input.isNull()) {
1165         if (base.isValid() &amp;&amp; !base.m_cannotBeABaseURL) {
1166             m_url = base;
1167             m_url.removeFragmentIdentifier();
1168         }
1169         return;
1170     }
1171 
1172     if (input.is8Bit()) {
1173         m_inputBegin = input.characters8();
1174         parse(input.characters8(), input.length(), base, nonUTF8QueryEncoding);
1175     } else {
1176         m_inputBegin = input.characters16();
1177         parse(input.characters16(), input.length(), base, nonUTF8QueryEncoding);
1178     }
1179 
1180     ASSERT(!m_url.m_isValid
1181         || m_didSeeSyntaxViolation == (m_url.string() != input)
1182         || (input.isAllSpecialCharacters&lt;isC0ControlOrSpace&gt;()
1183             &amp;&amp; m_url.m_string == base.m_string.left(base.m_queryEnd)));
1184     ASSERT(internalValuesConsistent(m_url));
1185 #if !ASSERT_DISABLED
1186     if (!m_didSeeSyntaxViolation) {
1187         // Force a syntax violation at the beginning to make sure we get the same result.
1188         URLParser parser(makeString(&quot; &quot;, input), base, nonUTF8QueryEncoding);
1189         URL parsed = parser.result();
1190         if (parsed.isValid())
1191             ASSERT(allValuesEqual(parser.result(), m_url));
1192     }
1193 #endif
1194 }
1195 
1196 template&lt;typename CharacterType&gt;
1197 void URLParser::parse(const CharacterType* input, const unsigned length, const URL&amp; base, const URLTextEncoding* nonUTF8QueryEncoding)
1198 {
1199     URL_PARSER_LOG(&quot;Parsing URL &lt;%s&gt; base &lt;%s&gt;&quot;, String(input, length).utf8().data(), base.string().utf8().data());
1200     m_url = { };
1201     ASSERT(m_asciiBuffer.isEmpty());
1202 
1203     Vector&lt;UChar&gt; queryBuffer;
1204 
1205     unsigned endIndex = length;
1206     while (UNLIKELY(endIndex &amp;&amp; isC0ControlOrSpace(input[endIndex - 1]))) {
1207         syntaxViolation(CodePointIterator&lt;CharacterType&gt;(input, input));
1208         endIndex--;
1209     }
1210     CodePointIterator&lt;CharacterType&gt; c(input, input + endIndex);
1211     CodePointIterator&lt;CharacterType&gt; authorityOrHostBegin;
1212     CodePointIterator&lt;CharacterType&gt; queryBegin;
1213     while (UNLIKELY(!c.atEnd() &amp;&amp; isC0ControlOrSpace(*c))) {
1214         syntaxViolation(c);
1215         ++c;
1216     }
1217     auto beginAfterControlAndSpace = c;
1218 
1219     enum class State : uint8_t {
1220         SchemeStart,
1221         Scheme,
1222         NoScheme,
1223         SpecialRelativeOrAuthority,
1224         PathOrAuthority,
1225         Relative,
1226         RelativeSlash,
1227         SpecialAuthoritySlashes,
1228         SpecialAuthorityIgnoreSlashes,
1229         AuthorityOrHost,
1230         Host,
1231         File,
1232         FileSlash,
1233         FileHost,
1234         PathStart,
1235         Path,
1236         CannotBeABaseURLPath,
1237         UTF8Query,
1238         NonUTF8Query,
1239         Fragment,
1240     };
1241 
1242 #define LOG_STATE(x) URL_PARSER_LOG(&quot;State %s, code point %c, parsed data &lt;%s&gt; size %zu&quot;, x, *c, parsedDataView(0, currentPosition(c)).utf8().data(), currentPosition(c))
1243 #define LOG_FINAL_STATE(x) URL_PARSER_LOG(&quot;Final State: %s&quot;, x)
1244 
1245     State state = State::SchemeStart;
1246     while (!c.atEnd()) {
1247         if (UNLIKELY(isTabOrNewline(*c))) {
1248             syntaxViolation(c);
1249             ++c;
1250             continue;
1251         }
1252 
1253         switch (state) {
1254         case State::SchemeStart:
1255             LOG_STATE(&quot;SchemeStart&quot;);
1256             if (isASCIIAlpha(*c)) {
1257                 if (UNLIKELY(isASCIIUpper(*c)))
1258                     syntaxViolation(c);
1259                 appendToASCIIBuffer(toASCIILower(*c));
1260                 advance(c);
1261                 if (c.atEnd()) {
1262                     m_asciiBuffer.clear();
1263                     state = State::NoScheme;
1264                     c = beginAfterControlAndSpace;
1265                     break;
1266                 }
1267                 state = State::Scheme;
1268             } else
1269                 state = State::NoScheme;
1270             break;
1271         case State::Scheme:
1272             LOG_STATE(&quot;Scheme&quot;);
1273             if (isValidSchemeCharacter(*c)) {
1274                 if (UNLIKELY(isASCIIUpper(*c)))
1275                     syntaxViolation(c);
1276                 appendToASCIIBuffer(toASCIILower(*c));
1277             } else if (*c == &#39;:&#39;) {
1278                 unsigned schemeEnd = currentPosition(c);
1279                 if (schemeEnd &gt; URL::maxSchemeLength) {
1280                     failure();
1281                     return;
1282                 }
1283                 m_url.m_schemeEnd = schemeEnd;
1284                 StringView urlScheme = parsedDataView(0, m_url.m_schemeEnd);
1285                 appendToASCIIBuffer(&#39;:&#39;);
1286                 switch (scheme(urlScheme)) {
1287 #if PLATFORM(JAVA)
1288                 // JAR can have complex protocols like &quot;jar:file&quot; or &quot;jar:http://&quot;
1289                 // Just skip the jar: part, rest will be parsed like other
1290                 // scheme.
1291                 case Scheme::JAR:
1292                     ++c;
1293                     break;
1294 #endif
1295                 case Scheme::File:
1296                     m_urlIsSpecial = true;
1297                     m_urlIsFile = true;
1298                     state = State::File;
1299                     ++c;
1300                     break;
1301                 case Scheme::WS:
1302                 case Scheme::WSS:
1303                     nonUTF8QueryEncoding = nullptr;
1304                     m_urlIsSpecial = true;
1305                     if (base.protocolIs(urlScheme))
1306                         state = State::SpecialRelativeOrAuthority;
1307                     else
1308                         state = State::SpecialAuthoritySlashes;
1309                     ++c;
1310                     break;
1311                 case Scheme::HTTP:
1312                 case Scheme::HTTPS:
1313                     m_url.m_protocolIsInHTTPFamily = true;
1314                     FALLTHROUGH;
1315                 case Scheme::FTP:
1316                 case Scheme::Gopher:
1317                     m_urlIsSpecial = true;
1318                     if (base.protocolIs(urlScheme))
1319                         state = State::SpecialRelativeOrAuthority;
1320                     else
1321                         state = State::SpecialAuthoritySlashes;
1322                     ++c;
1323                     break;
1324                 case Scheme::NonSpecial:
1325                     nonUTF8QueryEncoding = nullptr;
1326                     auto maybeSlash = c;
1327                     advance(maybeSlash);
1328                     if (!maybeSlash.atEnd() &amp;&amp; *maybeSlash == &#39;/&#39;) {
1329                         appendToASCIIBuffer(&#39;/&#39;);
1330                         c = maybeSlash;
1331                         state = State::PathOrAuthority;
1332                         ASSERT(*c == &#39;/&#39;);
1333                         ++c;
1334                         m_url.m_userStart = currentPosition(c);
1335                     } else {
1336                         ++c;
1337                         m_url.m_userStart = currentPosition(c);
1338                         m_url.m_userEnd = m_url.m_userStart;
1339                         m_url.m_passwordEnd = m_url.m_userStart;
1340                         m_url.m_hostEnd = m_url.m_userStart;
1341                         m_url.m_portLength = 0;
1342                         m_url.m_pathAfterLastSlash = m_url.m_userStart;
1343                         m_url.m_cannotBeABaseURL = true;
1344                         state = State::CannotBeABaseURLPath;
1345                     }
1346                     break;
1347                 }
1348                 break;
1349             } else {
1350                 m_asciiBuffer.clear();
1351                 state = State::NoScheme;
1352                 c = beginAfterControlAndSpace;
1353                 break;
1354             }
1355             advance(c);
1356             if (c.atEnd()) {
1357                 m_asciiBuffer.clear();
1358                 state = State::NoScheme;
1359                 c = beginAfterControlAndSpace;
1360             }
1361             break;
1362         case State::NoScheme:
1363             LOG_STATE(&quot;NoScheme&quot;);
1364             if (!base.isValid() || (base.m_cannotBeABaseURL &amp;&amp; *c != &#39;#&#39;)) {
1365                 failure();
1366                 return;
1367             }
1368             if (base.m_cannotBeABaseURL &amp;&amp; *c == &#39;#&#39;) {
1369                 copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1370                 state = State::Fragment;
1371                 appendToASCIIBuffer(&#39;#&#39;);
1372                 ++c;
1373                 break;
1374             }
1375             if (!base.protocolIs(&quot;file&quot;)) {
1376                 state = State::Relative;
1377                 break;
1378             }
1379             copyURLPartsUntil(base, URLPart::SchemeEnd, c, nonUTF8QueryEncoding);
1380             appendToASCIIBuffer(&#39;:&#39;);
1381             state = State::File;
1382             break;
1383         case State::SpecialRelativeOrAuthority:
1384             LOG_STATE(&quot;SpecialRelativeOrAuthority&quot;);
1385             if (*c == &#39;/&#39;) {
1386                 appendToASCIIBuffer(&#39;/&#39;);
1387                 advance(c);
1388                 if (c.atEnd()) {
1389                     failure();
1390                     return;
1391                 }
1392                 if (*c == &#39;/&#39;) {
1393                     appendToASCIIBuffer(&#39;/&#39;);
1394                     state = State::SpecialAuthorityIgnoreSlashes;
1395                     ++c;
1396                 } else
1397                     state = State::RelativeSlash;
1398             } else
1399                 state = State::Relative;
1400             break;
1401         case State::PathOrAuthority:
1402             LOG_STATE(&quot;PathOrAuthority&quot;);
1403             if (*c == &#39;/&#39;) {
1404                 appendToASCIIBuffer(&#39;/&#39;);
1405                 state = State::AuthorityOrHost;
1406                 advance(c);
1407                 m_url.m_userStart = currentPosition(c);
1408                 authorityOrHostBegin = c;
1409             } else {
1410                 ASSERT(parsedDataView(currentPosition(c) - 1) == &#39;/&#39;);
1411                 m_url.m_userStart = currentPosition(c) - 1;
1412                 m_url.m_userEnd = m_url.m_userStart;
1413                 m_url.m_passwordEnd = m_url.m_userStart;
1414                 m_url.m_hostEnd = m_url.m_userStart;
1415                 m_url.m_portLength = 0;
1416                 m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1417                 state = State::Path;
1418             }
1419             break;
1420         case State::Relative:
1421             LOG_STATE(&quot;Relative&quot;);
1422             switch (*c) {
1423             case &#39;/&#39;:
1424             case &#39;\\&#39;:
1425                 state = State::RelativeSlash;
1426                 ++c;
1427                 break;
1428             case &#39;?&#39;:
1429                 copyURLPartsUntil(base, URLPart::PathEnd, c, nonUTF8QueryEncoding);
1430                 appendToASCIIBuffer(&#39;?&#39;);
1431                 ++c;
1432                 if (nonUTF8QueryEncoding) {
1433                     queryBegin = c;
1434                     state = State::NonUTF8Query;
1435                 } else
1436                     state = State::UTF8Query;
1437                 break;
1438             case &#39;#&#39;:
1439                 copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1440                 appendToASCIIBuffer(&#39;#&#39;);
1441                 state = State::Fragment;
1442                 ++c;
1443                 break;
1444             default:
1445                 copyURLPartsUntil(base, URLPart::PathAfterLastSlash, c, nonUTF8QueryEncoding);
1446                 if (currentPosition(c) &amp;&amp; parsedDataView(currentPosition(c) - 1) != &#39;/&#39;) {
1447                     appendToASCIIBuffer(&#39;/&#39;);
1448                     m_url.m_pathAfterLastSlash = currentPosition(c);
1449                 }
1450                 state = State::Path;
1451                 break;
1452             }
1453             break;
1454         case State::RelativeSlash:
1455             LOG_STATE(&quot;RelativeSlash&quot;);
1456             if (*c == &#39;/&#39; || *c == &#39;\\&#39;) {
1457                 ++c;
1458                 copyURLPartsUntil(base, URLPart::SchemeEnd, c, nonUTF8QueryEncoding);
1459                 appendToASCIIBuffer(&quot;://&quot;, 3);
1460                 if (m_urlIsSpecial)
1461                     state = State::SpecialAuthorityIgnoreSlashes;
1462                 else {
1463                     m_url.m_userStart = currentPosition(c);
1464                     state = State::AuthorityOrHost;
1465                     authorityOrHostBegin = c;
1466                 }
1467             } else {
1468                 copyURLPartsUntil(base, URLPart::PortEnd, c, nonUTF8QueryEncoding);
1469                 appendToASCIIBuffer(&#39;/&#39;);
1470                 m_url.m_pathAfterLastSlash = base.m_hostEnd + base.m_portLength + 1;
1471                 state = State::Path;
1472             }
1473             break;
1474         case State::SpecialAuthoritySlashes:
1475             LOG_STATE(&quot;SpecialAuthoritySlashes&quot;);
1476             if (LIKELY(*c == &#39;/&#39; || *c == &#39;\\&#39;)) {
1477                 if (UNLIKELY(*c == &#39;\\&#39;))
1478                     syntaxViolation(c);
1479                 appendToASCIIBuffer(&#39;/&#39;);
1480                 advance(c);
1481                 if (LIKELY(!c.atEnd() &amp;&amp; (*c == &#39;/&#39; || *c == &#39;\\&#39;))) {
1482                     if (UNLIKELY(*c == &#39;\\&#39;))
1483                         syntaxViolation(c);
1484                     ++c;
1485                     appendToASCIIBuffer(&#39;/&#39;);
1486                 } else {
1487                     syntaxViolation(c);
1488                     appendToASCIIBuffer(&#39;/&#39;);
1489                 }
1490             } else {
1491                 syntaxViolation(c);
1492                 appendToASCIIBuffer(&quot;//&quot;, 2);
1493             }
1494             state = State::SpecialAuthorityIgnoreSlashes;
1495             break;
1496         case State::SpecialAuthorityIgnoreSlashes:
1497             LOG_STATE(&quot;SpecialAuthorityIgnoreSlashes&quot;);
1498             if (*c == &#39;/&#39; || *c == &#39;\\&#39;) {
1499                 syntaxViolation(c);
1500                 ++c;
1501             } else {
1502                 m_url.m_userStart = currentPosition(c);
1503                 state = State::AuthorityOrHost;
1504                 authorityOrHostBegin = c;
1505             }
1506             break;
1507         case State::AuthorityOrHost:
1508             do {
1509                 LOG_STATE(&quot;AuthorityOrHost&quot;);
1510                 if (*c == &#39;@&#39;) {
1511                     auto lastAt = c;
1512                     auto findLastAt = c;
1513                     while (!findLastAt.atEnd()) {
1514                         URL_PARSER_LOG(&quot;Finding last @: %c&quot;, *findLastAt);
1515                         if (*findLastAt == &#39;@&#39;)
1516                             lastAt = findLastAt;
1517                         bool isSlash = *findLastAt == &#39;/&#39; || (m_urlIsSpecial &amp;&amp; *findLastAt == &#39;\\&#39;);
1518                         if (isSlash || *findLastAt == &#39;?&#39; || *findLastAt == &#39;#&#39;)
1519                             break;
1520                         ++findLastAt;
1521                     }
1522                     parseAuthority(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, lastAt));
1523                     c = lastAt;
1524                     advance(c);
1525                     authorityOrHostBegin = c;
1526                     state = State::Host;
1527                     m_hostHasPercentOrNonASCII = false;
1528                     break;
1529                 }
1530                 bool isSlash = *c == &#39;/&#39; || (m_urlIsSpecial &amp;&amp; *c == &#39;\\&#39;);
1531                 if (isSlash || *c == &#39;?&#39; || *c == &#39;#&#39;) {
1532                     auto iterator = CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c);
1533                     if (iterator.atEnd()) {
1534                         if (m_urlIsSpecial)
1535                             return failure();
1536                         m_url.m_userEnd = currentPosition(c);
1537                         m_url.m_passwordEnd = m_url.m_userEnd;
1538                         m_url.m_hostEnd = m_url.m_userEnd;
1539                         m_url.m_portLength = 0;
1540                         m_url.m_pathAfterLastSlash = m_url.m_userEnd;
1541                     } else {
1542                         m_url.m_userEnd = currentPosition(authorityOrHostBegin);
1543                         m_url.m_passwordEnd = m_url.m_userEnd;
1544                         if (!parseHostAndPort(iterator)) {
1545                             failure();
1546                             return;
1547                         }
1548                         if (UNLIKELY(!isSlash)) {
1549                             if (m_urlIsSpecial) {
1550                                 syntaxViolation(c);
1551                                 appendToASCIIBuffer(&#39;/&#39;);
1552                             }
1553                             m_url.m_pathAfterLastSlash = currentPosition(c);
1554                         }
1555                     }
1556                     state = State::Path;
1557                     break;
1558                 }
1559                 if (isPercentOrNonASCII(*c))
1560                     m_hostHasPercentOrNonASCII = true;
1561                 ++c;
1562             } while (!c.atEnd());
1563             break;
1564         case State::Host:
1565             do {
1566                 LOG_STATE(&quot;Host&quot;);
1567                 if (*c == &#39;/&#39; || *c == &#39;?&#39; || *c == &#39;#&#39;) {
1568                     if (!parseHostAndPort(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))) {
1569                         failure();
1570                         return;
1571                     }
1572                     if (*c == &#39;?&#39; || *c == &#39;#&#39;) {
1573                         syntaxViolation(c);
1574                         appendToASCIIBuffer(&#39;/&#39;);
1575                         m_url.m_pathAfterLastSlash = currentPosition(c);
1576                     }
1577                     state = State::Path;
1578                     break;
1579                 }
1580                 if (isPercentOrNonASCII(*c))
1581                     m_hostHasPercentOrNonASCII = true;
1582                 ++c;
1583             } while (!c.atEnd());
1584             break;
1585         case State::File:
1586             LOG_STATE(&quot;File&quot;);
1587             switch (*c) {
1588             case &#39;\\&#39;:
1589                 syntaxViolation(c);
1590                 FALLTHROUGH;
1591             case &#39;/&#39;:
1592                 appendToASCIIBuffer(&#39;/&#39;);
1593                 state = State::FileSlash;
1594                 ++c;
1595                 break;
1596             case &#39;?&#39;:
1597                 syntaxViolation(c);
1598                 if (base.isValid() &amp;&amp; base.protocolIs(&quot;file&quot;)) {
1599                     copyURLPartsUntil(base, URLPart::PathEnd, c, nonUTF8QueryEncoding);
1600                     appendToASCIIBuffer(&#39;?&#39;);
1601                     ++c;
1602                 } else {
1603                     appendToASCIIBuffer(&quot;///?&quot;, 4);
1604                     ++c;
1605                     m_url.m_userStart = currentPosition(c) - 2;
1606                     m_url.m_userEnd = m_url.m_userStart;
1607                     m_url.m_passwordEnd = m_url.m_userStart;
1608                     m_url.m_hostEnd = m_url.m_userStart;
1609                     m_url.m_portLength = 0;
1610                     m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1611                     m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1612                 }
1613                 if (nonUTF8QueryEncoding) {
1614                     queryBegin = c;
1615                     state = State::NonUTF8Query;
1616                 } else
1617                     state = State::UTF8Query;
1618                 break;
1619             case &#39;#&#39;:
1620                 syntaxViolation(c);
1621                 if (base.isValid() &amp;&amp; base.protocolIs(&quot;file&quot;)) {
1622                     copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1623                     appendToASCIIBuffer(&#39;#&#39;);
1624                 } else {
1625                     appendToASCIIBuffer(&quot;///#&quot;, 4);
1626                     m_url.m_userStart = currentPosition(c) - 2;
1627                     m_url.m_userEnd = m_url.m_userStart;
1628                     m_url.m_passwordEnd = m_url.m_userStart;
1629                     m_url.m_hostEnd = m_url.m_userStart;
1630                     m_url.m_portLength = 0;
1631                     m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1632                     m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1633                     m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1634                 }
1635                 state = State::Fragment;
1636                 ++c;
1637                 break;
1638             default:
1639                 syntaxViolation(c);
1640                 if (base.isValid() &amp;&amp; base.protocolIs(&quot;file&quot;) &amp;&amp; shouldCopyFileURL(c))
1641                     copyURLPartsUntil(base, URLPart::PathAfterLastSlash, c, nonUTF8QueryEncoding);
1642                 else {
1643                     appendToASCIIBuffer(&quot;///&quot;, 3);
1644                     m_url.m_userStart = currentPosition(c) - 1;
1645                     m_url.m_userEnd = m_url.m_userStart;
1646                     m_url.m_passwordEnd = m_url.m_userStart;
1647                     m_url.m_hostEnd = m_url.m_userStart;
1648                     m_url.m_portLength = 0;
1649                     m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1650                     if (isWindowsDriveLetter(c))
1651                         appendWindowsDriveLetter(c);
1652                 }
1653                 state = State::Path;
1654                 break;
1655             }
1656             break;
1657         case State::FileSlash:
1658             LOG_STATE(&quot;FileSlash&quot;);
1659             if (LIKELY(*c == &#39;/&#39; || *c == &#39;\\&#39;)) {
1660                 if (UNLIKELY(*c == &#39;\\&#39;))
1661                     syntaxViolation(c);
1662                 appendToASCIIBuffer(&#39;/&#39;);
1663                 advance(c);
1664                 m_url.m_userStart = currentPosition(c);
1665                 m_url.m_userEnd = m_url.m_userStart;
1666                 m_url.m_passwordEnd = m_url.m_userStart;
1667                 m_url.m_hostEnd = m_url.m_userStart;
1668                 m_url.m_portLength = 0;
1669                 authorityOrHostBegin = c;
1670                 state = State::FileHost;
1671                 break;
1672             }
1673             syntaxViolation(c);
1674             appendToASCIIBuffer(&quot;//&quot;, 2);
1675             m_url.m_userStart = currentPosition(c) - 1;
1676             m_url.m_userEnd = m_url.m_userStart;
1677             m_url.m_passwordEnd = m_url.m_userStart;
1678             m_url.m_hostEnd = m_url.m_userStart;
1679             m_url.m_portLength = 0;
1680             if (isWindowsDriveLetter(c)) {
1681                 appendWindowsDriveLetter(c);
1682                 m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1683             } else if (copyBaseWindowsDriveLetter(base)) {
1684                 appendToASCIIBuffer(&#39;/&#39;);
1685                 m_url.m_pathAfterLastSlash = m_url.m_userStart + 4;
1686             } else
1687                 m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1688             state = State::Path;
1689             break;
1690         case State::FileHost:
1691             do {
1692                 LOG_STATE(&quot;FileHost&quot;);
1693                 if (isSlashQuestionOrHash(*c)) {
1694                     bool windowsQuirk = takesTwoAdvancesUntilEnd(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))
1695                         &amp;&amp; isWindowsDriveLetter(authorityOrHostBegin);
1696                     if (windowsQuirk) {
1697                         syntaxViolation(authorityOrHostBegin);
1698                         appendToASCIIBuffer(&#39;/&#39;);
1699                         appendWindowsDriveLetter(authorityOrHostBegin);
1700                     }
1701                     if (windowsQuirk || authorityOrHostBegin == c) {
1702                         ASSERT(windowsQuirk || parsedDataView(currentPosition(c) - 1) == &#39;/&#39;);
1703                         if (UNLIKELY(*c == &#39;?&#39;)) {
1704                             syntaxViolation(c);
1705                             appendToASCIIBuffer(&quot;/?&quot;, 2);
1706                             ++c;
1707                             if (nonUTF8QueryEncoding) {
1708                                 queryBegin = c;
1709                                 state = State::NonUTF8Query;
1710                             } else
1711                                 state = State::UTF8Query;
1712                             m_url.m_pathAfterLastSlash = currentPosition(c) - 1;
1713                             m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1714                             break;
1715                         }
1716                         if (UNLIKELY(*c == &#39;#&#39;)) {
1717                             syntaxViolation(c);
1718                             appendToASCIIBuffer(&quot;/#&quot;, 2);
1719                             ++c;
1720                             m_url.m_pathAfterLastSlash = currentPosition(c) - 1;
1721                             m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1722                             m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1723                             state = State::Fragment;
1724                             break;
1725                         }
1726                         state = State::Path;
1727                         break;
1728                     }
1729                     if (!parseHostAndPort(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))) {
1730                         failure();
1731                         return;
1732                     }
1733                     if (UNLIKELY(isLocalhost(parsedDataView(m_url.m_passwordEnd, currentPosition(c) - m_url.m_passwordEnd)))) {
1734                         syntaxViolation(c);
1735                         m_asciiBuffer.shrink(m_url.m_passwordEnd);
1736                         m_url.m_hostEnd = currentPosition(c);
1737                         m_url.m_portLength = 0;
1738                     }
1739 
1740                     state = State::PathStart;
1741                     break;
1742                 }
1743                 if (isPercentOrNonASCII(*c))
1744                     m_hostHasPercentOrNonASCII = true;
1745                 ++c;
1746             } while (!c.atEnd());
1747             break;
1748         case State::PathStart:
1749             LOG_STATE(&quot;PathStart&quot;);
1750             if (*c != &#39;/&#39; &amp;&amp; *c != &#39;\\&#39;) {
1751                 syntaxViolation(c);
1752                 appendToASCIIBuffer(&#39;/&#39;);
1753             }
1754             m_url.m_pathAfterLastSlash = currentPosition(c);
1755             state = State::Path;
1756             break;
1757         case State::Path:
1758             LOG_STATE(&quot;Path&quot;);
1759             if (*c == &#39;/&#39; || (m_urlIsSpecial &amp;&amp; *c == &#39;\\&#39;)) {
1760                 if (UNLIKELY(m_urlIsSpecial &amp;&amp; *c == &#39;\\&#39;))
1761                     syntaxViolation(c);
1762                 appendToASCIIBuffer(&#39;/&#39;);
1763                 ++c;
1764                 m_url.m_pathAfterLastSlash = currentPosition(c);
1765                 break;
1766             }
1767             if (UNLIKELY(currentPosition(c) &amp;&amp; parsedDataView(currentPosition(c) - 1) == &#39;/&#39;)) {
1768                 if (UNLIKELY(isDoubleDotPathSegment(c))) {
1769                     syntaxViolation(c);
1770                     consumeDoubleDotPathSegment(c);
1771                     popPath();
1772                     break;
1773                 }
1774                 if (UNLIKELY(isSingleDotPathSegment(c))) {
1775                     syntaxViolation(c);
1776                     consumeSingleDotPathSegment(c);
1777                     break;
1778                 }
1779             }
1780             if (*c == &#39;?&#39;) {
1781                 m_url.m_pathEnd = currentPosition(c);
1782                 appendToASCIIBuffer(&#39;?&#39;);
1783                 ++c;
1784                 if (nonUTF8QueryEncoding) {
1785                     queryBegin = c;
1786                     state = State::NonUTF8Query;
1787                 } else
1788                     state = State::UTF8Query;
1789                 break;
1790             }
1791             if (*c == &#39;#&#39;) {
1792                 m_url.m_pathEnd = currentPosition(c);
1793                 m_url.m_queryEnd = m_url.m_pathEnd;
1794                 state = State::Fragment;
1795                 break;
1796             }
1797             utf8PercentEncode&lt;isInDefaultEncodeSet&gt;(c);
1798             ++c;
1799             break;
1800         case State::CannotBeABaseURLPath:
1801             LOG_STATE(&quot;CannotBeABaseURLPath&quot;);
1802             if (*c == &#39;?&#39;) {
1803                 m_url.m_pathEnd = currentPosition(c);
1804                 appendToASCIIBuffer(&#39;?&#39;);
1805                 ++c;
1806                 if (nonUTF8QueryEncoding) {
1807                     queryBegin = c;
1808                     state = State::NonUTF8Query;
1809                 } else
1810                     state = State::UTF8Query;
1811             } else if (*c == &#39;#&#39;) {
1812                 m_url.m_pathEnd = currentPosition(c);
1813                 m_url.m_queryEnd = m_url.m_pathEnd;
1814                 state = State::Fragment;
1815             } else if (*c == &#39;/&#39;) {
1816                 appendToASCIIBuffer(&#39;/&#39;);
1817                 ++c;
1818                 m_url.m_pathAfterLastSlash = currentPosition(c);
1819             } else {
1820                 utf8PercentEncode&lt;isInSimpleEncodeSet&gt;(c);
1821                 ++c;
1822             }
1823             break;
1824         case State::UTF8Query:
1825             LOG_STATE(&quot;UTF8Query&quot;);
1826             ASSERT(queryBegin == CodePointIterator&lt;CharacterType&gt;());
1827             if (*c == &#39;#&#39;) {
1828                 m_url.m_queryEnd = currentPosition(c);
1829                 state = State::Fragment;
1830                 break;
1831             }
1832             ASSERT(!nonUTF8QueryEncoding);
1833             utf8QueryEncode(c);
1834             ++c;
1835             break;
1836         case State::NonUTF8Query:
1837             do {
1838                 LOG_STATE(&quot;NonUTF8Query&quot;);
1839                 ASSERT(queryBegin != CodePointIterator&lt;CharacterType&gt;());
1840                 if (*c == &#39;#&#39;) {
1841                     encodeNonUTF8Query(queryBuffer, *nonUTF8QueryEncoding, CodePointIterator&lt;CharacterType&gt;(queryBegin, c));
1842                     m_url.m_queryEnd = currentPosition(c);
1843                     state = State::Fragment;
1844                     break;
1845                 }
1846                 appendCodePoint(queryBuffer, *c);
1847                 advance(c, queryBegin);
1848             } while (!c.atEnd());
1849             break;
1850         case State::Fragment:
1851             URL_PARSER_LOG(&quot;State Fragment&quot;);
1852             utf8PercentEncode&lt;isInSimpleEncodeSet&gt;(c);
1853             ++c;
1854             break;
1855         }
1856     }
1857 
1858     switch (state) {
1859     case State::SchemeStart:
1860         LOG_FINAL_STATE(&quot;SchemeStart&quot;);
1861         if (!currentPosition(c) &amp;&amp; base.isValid() &amp;&amp; !base.m_cannotBeABaseURL) {
1862             m_url = base;
1863             m_url.removeFragmentIdentifier();
1864             return;
1865         }
1866         failure();
1867         return;
1868     case State::Scheme:
1869         LOG_FINAL_STATE(&quot;Scheme&quot;);
1870         failure();
1871         return;
1872     case State::NoScheme:
1873         LOG_FINAL_STATE(&quot;NoScheme&quot;);
1874         RELEASE_ASSERT_NOT_REACHED();
1875     case State::SpecialRelativeOrAuthority:
1876         LOG_FINAL_STATE(&quot;SpecialRelativeOrAuthority&quot;);
1877         copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1878         break;
1879     case State::PathOrAuthority:
1880         LOG_FINAL_STATE(&quot;PathOrAuthority&quot;);
1881         ASSERT(m_url.m_userStart);
1882         ASSERT(m_url.m_userStart == currentPosition(c));
1883         ASSERT(parsedDataView(currentPosition(c) - 1) == &#39;/&#39;);
1884         m_url.m_userStart--;
1885         m_url.m_userEnd = m_url.m_userStart;
1886         m_url.m_passwordEnd = m_url.m_userStart;
1887         m_url.m_hostEnd = m_url.m_userStart;
1888         m_url.m_portLength = 0;
1889         m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1890         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1891         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1892         break;
1893     case State::Relative:
1894         LOG_FINAL_STATE(&quot;Relative&quot;);
1895         RELEASE_ASSERT_NOT_REACHED();
1896     case State::RelativeSlash:
1897         LOG_FINAL_STATE(&quot;RelativeSlash&quot;);
1898         copyURLPartsUntil(base, URLPart::PortEnd, c, nonUTF8QueryEncoding);
1899         appendToASCIIBuffer(&#39;/&#39;);
1900         m_url.m_pathAfterLastSlash = m_url.m_hostEnd + m_url.m_portLength + 1;
1901         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1902         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1903         break;
1904     case State::SpecialAuthoritySlashes:
1905         LOG_FINAL_STATE(&quot;SpecialAuthoritySlashes&quot;);
1906         m_url.m_userStart = currentPosition(c);
1907         m_url.m_userEnd = m_url.m_userStart;
1908         m_url.m_passwordEnd = m_url.m_userStart;
1909         m_url.m_hostEnd = m_url.m_userStart;
1910         m_url.m_portLength = 0;
1911         m_url.m_pathAfterLastSlash = m_url.m_userStart;
1912         m_url.m_pathEnd = m_url.m_userStart;
1913         m_url.m_queryEnd = m_url.m_userStart;
1914         break;
1915     case State::SpecialAuthorityIgnoreSlashes:
1916         LOG_FINAL_STATE(&quot;SpecialAuthorityIgnoreSlashes&quot;);
1917         failure();
1918         return;
1919     case State::AuthorityOrHost:
1920         LOG_FINAL_STATE(&quot;AuthorityOrHost&quot;);
1921         m_url.m_userEnd = currentPosition(authorityOrHostBegin);
1922         m_url.m_passwordEnd = m_url.m_userEnd;
1923         if (authorityOrHostBegin.atEnd()) {
1924             m_url.m_userEnd = m_url.m_userStart;
1925             m_url.m_passwordEnd = m_url.m_userStart;
1926             m_url.m_hostEnd = m_url.m_userStart;
1927             m_url.m_portLength = 0;
1928             m_url.m_pathEnd = m_url.m_userStart;
1929         } else if (!parseHostAndPort(authorityOrHostBegin)) {
1930             failure();
1931             return;
1932         } else {
1933             if (m_urlIsSpecial) {
1934                 syntaxViolation(c);
1935                 appendToASCIIBuffer(&#39;/&#39;);
1936                 m_url.m_pathEnd = m_url.m_hostEnd + m_url.m_portLength + 1;
1937             } else
1938                 m_url.m_pathEnd = m_url.m_hostEnd + m_url.m_portLength;
1939         }
1940         m_url.m_pathAfterLastSlash = m_url.m_pathEnd;
1941         m_url.m_queryEnd = m_url.m_pathEnd;
1942         break;
1943     case State::Host:
1944         LOG_FINAL_STATE(&quot;Host&quot;);
1945         if (!parseHostAndPort(authorityOrHostBegin)) {
1946             failure();
1947             return;
1948         }
1949         if (m_urlIsSpecial) {
1950             syntaxViolation(c);
1951             appendToASCIIBuffer(&#39;/&#39;);
1952             m_url.m_pathEnd = m_url.m_hostEnd + m_url.m_portLength + 1;
1953         } else
1954             m_url.m_pathEnd = m_url.m_hostEnd + m_url.m_portLength;
1955         m_url.m_pathAfterLastSlash = m_url.m_pathEnd;
1956         m_url.m_queryEnd = m_url.m_pathEnd;
1957         break;
1958     case State::File:
1959         LOG_FINAL_STATE(&quot;File&quot;);
1960         if (base.isValid() &amp;&amp; base.protocolIs(&quot;file&quot;)) {
1961             copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1962             break;
1963         }
1964         syntaxViolation(c);
1965         appendToASCIIBuffer(&quot;///&quot;, 3);
1966         m_url.m_userStart = currentPosition(c) - 1;
1967         m_url.m_userEnd = m_url.m_userStart;
1968         m_url.m_passwordEnd = m_url.m_userStart;
1969         m_url.m_hostEnd = m_url.m_userStart;
1970         m_url.m_portLength = 0;
1971         m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1972         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1973         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1974         break;
1975     case State::FileSlash:
1976         LOG_FINAL_STATE(&quot;FileSlash&quot;);
1977         syntaxViolation(c);
1978         m_url.m_userStart = currentPosition(c) + 1;
1979         appendToASCIIBuffer(&quot;//&quot;, 2);
1980         m_url.m_userEnd = m_url.m_userStart;
1981         m_url.m_passwordEnd = m_url.m_userStart;
1982         m_url.m_hostEnd = m_url.m_userStart;
1983         m_url.m_portLength = 0;
1984         if (copyBaseWindowsDriveLetter(base)) {
1985             appendToASCIIBuffer(&#39;/&#39;);
1986             m_url.m_pathAfterLastSlash = m_url.m_userStart + 4;
1987         } else
1988             m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1989         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1990         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1991         break;
1992     case State::FileHost:
1993         LOG_FINAL_STATE(&quot;FileHost&quot;);
1994         if (takesTwoAdvancesUntilEnd(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))
1995             &amp;&amp; isWindowsDriveLetter(authorityOrHostBegin)) {
1996             syntaxViolation(authorityOrHostBegin);
1997             appendToASCIIBuffer(&#39;/&#39;);
1998             appendWindowsDriveLetter(authorityOrHostBegin);
1999             m_url.m_pathAfterLastSlash = currentPosition(c);
2000             m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
2001             m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
2002             break;
2003         }
2004 
2005         if (authorityOrHostBegin == c) {
2006             syntaxViolation(c);
2007             appendToASCIIBuffer(&#39;/&#39;);
2008             m_url.m_userStart = currentPosition(c) - 1;
2009             m_url.m_userEnd = m_url.m_userStart;
2010             m_url.m_passwordEnd = m_url.m_userStart;
2011             m_url.m_hostEnd = m_url.m_userStart;
2012             m_url.m_portLength = 0;
2013             m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
2014             m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
2015             m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
2016             break;
2017         }
2018 
2019         if (!parseHostAndPort(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))) {
2020             failure();
2021             return;
2022         }
2023 
2024         syntaxViolation(c);
2025         if (isLocalhost(parsedDataView(m_url.m_passwordEnd, currentPosition(c) - m_url.m_passwordEnd))) {
2026             m_asciiBuffer.shrink(m_url.m_passwordEnd);
2027             m_url.m_hostEnd = currentPosition(c);
2028             m_url.m_portLength = 0;
2029         }
2030         appendToASCIIBuffer(&#39;/&#39;);
2031         m_url.m_pathAfterLastSlash = m_url.m_hostEnd + m_url.m_portLength + 1;
2032         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
2033         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
2034         break;
2035     case State::PathStart:
2036         LOG_FINAL_STATE(&quot;PathStart&quot;);
2037         RELEASE_ASSERT_NOT_REACHED();
2038     case State::Path:
2039         LOG_FINAL_STATE(&quot;Path&quot;);
2040         m_url.m_pathEnd = currentPosition(c);
2041         m_url.m_queryEnd = m_url.m_pathEnd;
2042         break;
2043     case State::CannotBeABaseURLPath:
2044         LOG_FINAL_STATE(&quot;CannotBeABaseURLPath&quot;);
2045         m_url.m_pathEnd = currentPosition(c);
2046         m_url.m_queryEnd = m_url.m_pathEnd;
2047         break;
2048     case State::UTF8Query:
2049         LOG_FINAL_STATE(&quot;UTF8Query&quot;);
2050         ASSERT(queryBegin == CodePointIterator&lt;CharacterType&gt;());
2051         m_url.m_queryEnd = currentPosition(c);
2052         break;
2053     case State::NonUTF8Query:
2054         LOG_FINAL_STATE(&quot;NonUTF8Query&quot;);
2055         ASSERT(queryBegin != CodePointIterator&lt;CharacterType&gt;());
2056         encodeNonUTF8Query(queryBuffer, *nonUTF8QueryEncoding, CodePointIterator&lt;CharacterType&gt;(queryBegin, c));
2057         m_url.m_queryEnd = currentPosition(c);
2058         break;
2059     case State::Fragment:
2060         LOG_FINAL_STATE(&quot;Fragment&quot;);
2061         break;
2062     }
2063 
2064     if (LIKELY(!m_didSeeSyntaxViolation)) {
2065         m_url.m_string = m_inputString;
2066         ASSERT(m_asciiBuffer.isEmpty());
2067     } else
2068         m_url.m_string = String::adopt(WTFMove(m_asciiBuffer));
2069     m_url.m_isValid = true;
2070     URL_PARSER_LOG(&quot;Parsed URL &lt;%s&gt;&quot;, m_url.m_string.utf8().data());
2071 }
2072 
2073 template&lt;typename CharacterType&gt;
2074 void URLParser::parseAuthority(CodePointIterator&lt;CharacterType&gt; iterator)
2075 {
2076     if (UNLIKELY(iterator.atEnd())) {
2077         syntaxViolation(iterator);
2078         m_url.m_userEnd = currentPosition(iterator);
2079         m_url.m_passwordEnd = m_url.m_userEnd;
2080         return;
2081     }
2082     for (; !iterator.atEnd(); advance(iterator)) {
2083         if (*iterator == &#39;:&#39;) {
2084             m_url.m_userEnd = currentPosition(iterator);
2085             auto iteratorAtColon = iterator;
2086             ++iterator;
2087             bool tabOrNewlineAfterColon = false;
2088             while (UNLIKELY(!iterator.atEnd() &amp;&amp; isTabOrNewline(*iterator))) {
2089                 tabOrNewlineAfterColon = true;
2090                 ++iterator;
2091             }
2092             if (UNLIKELY(iterator.atEnd())) {
2093                 syntaxViolation(iteratorAtColon);
2094                 m_url.m_passwordEnd = m_url.m_userEnd;
2095                 if (m_url.m_userEnd &gt; m_url.m_userStart)
2096                     appendToASCIIBuffer(&#39;@&#39;);
2097                 return;
2098             }
2099             if (tabOrNewlineAfterColon)
2100                 syntaxViolation(iteratorAtColon);
2101             appendToASCIIBuffer(&#39;:&#39;);
2102             break;
2103         }
2104         utf8PercentEncode&lt;WTF::isInUserInfoEncodeSet&gt;(iterator);
2105     }
2106     for (; !iterator.atEnd(); advance(iterator))
2107         utf8PercentEncode&lt;WTF::isInUserInfoEncodeSet&gt;(iterator);
2108     m_url.m_passwordEnd = currentPosition(iterator);
2109     if (!m_url.m_userEnd)
2110         m_url.m_userEnd = m_url.m_passwordEnd;
2111     appendToASCIIBuffer(&#39;@&#39;);
2112 }
2113 
2114 template&lt;typename UnsignedIntegerType&gt;
2115 void URLParser::appendNumberToASCIIBuffer(UnsignedIntegerType number)
2116 {
2117     LChar buf[sizeof(UnsignedIntegerType) * 3 + 1];
2118     LChar* end = std::end(buf);
2119     LChar* p = end;
2120     do {
2121         *--p = (number % 10) + &#39;0&#39;;
2122         number /= 10;
2123     } while (number);
2124     appendToASCIIBuffer(p, end - p);
2125 }
2126 
2127 void URLParser::serializeIPv4(IPv4Address address)
2128 {
2129     appendNumberToASCIIBuffer&lt;uint8_t&gt;(address &gt;&gt; 24);
2130     appendToASCIIBuffer(&#39;.&#39;);
2131     appendNumberToASCIIBuffer&lt;uint8_t&gt;(address &gt;&gt; 16);
2132     appendToASCIIBuffer(&#39;.&#39;);
2133     appendNumberToASCIIBuffer&lt;uint8_t&gt;(address &gt;&gt; 8);
2134     appendToASCIIBuffer(&#39;.&#39;);
2135     appendNumberToASCIIBuffer&lt;uint8_t&gt;(address);
2136 }
2137 
2138 static size_t zeroSequenceLength(const std::array&lt;uint16_t, 8&gt;&amp; address, size_t begin)
2139 {
2140     size_t end = begin;
2141     for (; end &lt; 8; end++) {
2142         if (address[end])
2143             break;
2144     }
2145     return end - begin;
2146 }
2147 
2148 static Optional&lt;size_t&gt; findLongestZeroSequence(const std::array&lt;uint16_t, 8&gt;&amp; address)
2149 {
2150     Optional&lt;size_t&gt; longest;
2151     size_t longestLength = 0;
2152     for (size_t i = 0; i &lt; 8; i++) {
2153         size_t length = zeroSequenceLength(address, i);
2154         if (length) {
2155             if (length &gt; 1 &amp;&amp; (!longest || longestLength &lt; length)) {
2156                 longest = i;
2157                 longestLength = length;
2158             }
2159             i += length;
2160         }
2161     }
2162     return longest;
2163 }
2164 
2165 void URLParser::serializeIPv6Piece(uint16_t piece)
2166 {
2167     bool printed = false;
2168     if (auto nibble0 = piece &gt;&gt; 12) {
2169         appendToASCIIBuffer(lowerNibbleToLowercaseASCIIHexDigit(nibble0));
2170         printed = true;
2171     }
2172     auto nibble1 = piece &gt;&gt; 8 &amp; 0xF;
2173     if (printed || nibble1) {
2174         appendToASCIIBuffer(lowerNibbleToLowercaseASCIIHexDigit(nibble1));
2175         printed = true;
2176     }
2177     auto nibble2 = piece &gt;&gt; 4 &amp; 0xF;
2178     if (printed || nibble2)
2179         appendToASCIIBuffer(lowerNibbleToLowercaseASCIIHexDigit(nibble2));
2180     appendToASCIIBuffer(lowerNibbleToLowercaseASCIIHexDigit(piece &amp; 0xF));
2181 }
2182 
2183 void URLParser::serializeIPv6(URLParser::IPv6Address address)
2184 {
2185     appendToASCIIBuffer(&#39;[&#39;);
2186     auto compressPointer = findLongestZeroSequence(address);
2187     for (size_t piece = 0; piece &lt; 8; piece++) {
2188         if (compressPointer &amp;&amp; compressPointer.value() == piece) {
2189             ASSERT(!address[piece]);
2190             if (piece)
2191                 appendToASCIIBuffer(&#39;:&#39;);
2192             else
2193                 appendToASCIIBuffer(&quot;::&quot;, 2);
2194             while (piece &lt; 8 &amp;&amp; !address[piece])
2195                 piece++;
2196             if (piece == 8)
2197                 break;
2198         }
2199         serializeIPv6Piece(address[piece]);
2200         if (piece &lt; 7)
2201             appendToASCIIBuffer(&#39;:&#39;);
2202     }
2203     appendToASCIIBuffer(&#39;]&#39;);
2204 }
2205 
2206 enum class URLParser::IPv4PieceParsingError {
2207     Failure,
2208     Overflow,
2209 };
2210 
2211 template&lt;typename CharacterType&gt;
2212 Expected&lt;uint32_t, URLParser::IPv4PieceParsingError&gt; URLParser::parseIPv4Piece(CodePointIterator&lt;CharacterType&gt;&amp; iterator, bool&amp; didSeeSyntaxViolation)
2213 {
2214     enum class State : uint8_t {
2215         UnknownBase,
2216         Decimal,
2217         OctalOrHex,
2218         Octal,
2219         Hex,
2220     };
2221     State state = State::UnknownBase;
2222     Checked&lt;uint32_t, RecordOverflow&gt; value = 0;
2223     if (!iterator.atEnd() &amp;&amp; *iterator == &#39;.&#39;)
2224         return makeUnexpected(IPv4PieceParsingError::Failure);
2225     while (!iterator.atEnd()) {
2226         if (isTabOrNewline(*iterator)) {
2227             didSeeSyntaxViolation = true;
2228             ++iterator;
2229             continue;
2230         }
2231         if (*iterator == &#39;.&#39;) {
2232             ASSERT(!value.hasOverflowed());
2233             return value.unsafeGet();
2234         }
2235         switch (state) {
2236         case State::UnknownBase:
2237             if (UNLIKELY(*iterator == &#39;0&#39;)) {
2238                 ++iterator;
2239                 state = State::OctalOrHex;
2240                 break;
2241             }
2242             state = State::Decimal;
2243             break;
2244         case State::OctalOrHex:
2245             didSeeSyntaxViolation = true;
2246             if (*iterator == &#39;x&#39; || *iterator == &#39;X&#39;) {
2247                 ++iterator;
2248                 state = State::Hex;
2249                 break;
2250             }
2251             state = State::Octal;
2252             break;
2253         case State::Decimal:
2254             if (!isASCIIDigit(*iterator))
2255                 return makeUnexpected(IPv4PieceParsingError::Failure);
2256             value *= 10;
2257             value += *iterator - &#39;0&#39;;
2258             if (UNLIKELY(value.hasOverflowed()))
2259                 return makeUnexpected(IPv4PieceParsingError::Overflow);
2260             ++iterator;
2261             break;
2262         case State::Octal:
2263             ASSERT(didSeeSyntaxViolation);
2264             if (*iterator &lt; &#39;0&#39; || *iterator &gt; &#39;7&#39;)
2265                 return makeUnexpected(IPv4PieceParsingError::Failure);
2266             value *= 8;
2267             value += *iterator - &#39;0&#39;;
2268             if (UNLIKELY(value.hasOverflowed()))
2269                 return makeUnexpected(IPv4PieceParsingError::Overflow);
2270             ++iterator;
2271             break;
2272         case State::Hex:
2273             ASSERT(didSeeSyntaxViolation);
2274             if (!isASCIIHexDigit(*iterator))
2275                 return makeUnexpected(IPv4PieceParsingError::Failure);
2276             value *= 16;
2277             value += toASCIIHexValue(*iterator);
2278             if (UNLIKELY(value.hasOverflowed()))
2279                 return makeUnexpected(IPv4PieceParsingError::Overflow);
2280             ++iterator;
2281             break;
2282         }
2283     }
2284     ASSERT(!value.hasOverflowed());
2285     return value.unsafeGet();
2286 }
2287 
2288 ALWAYS_INLINE static uint64_t pow256(size_t exponent)
2289 {
2290     RELEASE_ASSERT(exponent &lt;= 4);
2291     uint64_t values[5] = {1, 256, 256 * 256, 256 * 256 * 256, 256ull * 256 * 256 * 256 };
2292     return values[exponent];
2293 }
2294 
2295 enum class URLParser::IPv4ParsingError {
2296     Failure,
2297     NotIPv4,
2298 };
2299 
2300 template&lt;typename CharacterTypeForSyntaxViolation, typename CharacterType&gt;
2301 Expected&lt;URLParser::IPv4Address, URLParser::IPv4ParsingError&gt; URLParser::parseIPv4Host(const CodePointIterator&lt;CharacterTypeForSyntaxViolation&gt;&amp; iteratorForSyntaxViolationPosition, CodePointIterator&lt;CharacterType&gt; iterator)
2302 {
2303     Vector&lt;Expected&lt;uint32_t, URLParser::IPv4PieceParsingError&gt;, 4&gt; items;
2304     bool didSeeSyntaxViolation = false;
2305     if (!iterator.atEnd() &amp;&amp; *iterator == &#39;.&#39;)
2306         return makeUnexpected(IPv4ParsingError::NotIPv4);
2307     while (!iterator.atEnd()) {
2308         if (isTabOrNewline(*iterator)) {
2309             didSeeSyntaxViolation = true;
2310             ++iterator;
2311             continue;
2312         }
2313         if (items.size() &gt;= 4)
2314             return makeUnexpected(IPv4ParsingError::NotIPv4);
2315         items.append(parseIPv4Piece(iterator, didSeeSyntaxViolation));
2316         if (!iterator.atEnd() &amp;&amp; *iterator == &#39;.&#39;) {
2317             ++iterator;
2318             if (iterator.atEnd())
2319                 didSeeSyntaxViolation = true;
2320             else if (*iterator == &#39;.&#39;)
2321                 return makeUnexpected(IPv4ParsingError::NotIPv4);
2322         }
2323     }
2324     if (!iterator.atEnd() || !items.size() || items.size() &gt; 4)
2325         return makeUnexpected(IPv4ParsingError::NotIPv4);
2326     for (const auto&amp; item : items) {
2327         if (!item.has_value() &amp;&amp; item.error() == IPv4PieceParsingError::Failure)
2328             return makeUnexpected(IPv4ParsingError::NotIPv4);
2329     }
2330     for (const auto&amp; item : items) {
2331         if (!item.has_value() &amp;&amp; item.error() == IPv4PieceParsingError::Overflow)
2332             return makeUnexpected(IPv4ParsingError::Failure);
2333     }
2334     if (items.size() &gt; 1) {
2335         for (size_t i = 0; i &lt; items.size() - 1; i++) {
2336             if (items[i].value() &gt; 255)
2337                 return makeUnexpected(IPv4ParsingError::Failure);
2338         }
2339     }
2340     if (items[items.size() - 1].value() &gt;= pow256(5 - items.size()))
2341         return makeUnexpected(IPv4ParsingError::Failure);
2342 
2343     if (didSeeSyntaxViolation)
2344         syntaxViolation(iteratorForSyntaxViolationPosition);
2345     for (const auto&amp; item : items) {
2346         if (item.value() &gt; 255)
2347             syntaxViolation(iteratorForSyntaxViolationPosition);
2348     }
2349 
2350     if (UNLIKELY(items.size() != 4))
2351         syntaxViolation(iteratorForSyntaxViolationPosition);
2352 
2353     IPv4Address ipv4 = items.takeLast().value();
2354     for (size_t counter = 0; counter &lt; items.size(); ++counter)
2355         ipv4 += items[counter].value() * pow256(3 - counter);
2356     return ipv4;
2357 }
2358 
2359 template&lt;typename CharacterType&gt;
2360 Optional&lt;uint32_t&gt; URLParser::parseIPv4PieceInsideIPv6(CodePointIterator&lt;CharacterType&gt;&amp; iterator)
2361 {
2362     if (iterator.atEnd())
2363         return WTF::nullopt;
2364     uint32_t piece = 0;
2365     bool leadingZeros = false;
2366     size_t digitCount = 0;
2367     while (!iterator.atEnd()) {
2368         if (!isASCIIDigit(*iterator))
2369             return WTF::nullopt;
2370         ++digitCount;
2371         if (!piece &amp;&amp; *iterator == &#39;0&#39;) {
2372             if (leadingZeros)
2373                 return WTF::nullopt;
2374             leadingZeros = true;
2375         }
2376         if (!piece &amp;&amp; *iterator == &#39;0&#39;)
2377             leadingZeros = true;
2378         piece = piece * 10 + *iterator - &#39;0&#39;;
2379         if (piece &gt; 255)
2380             return WTF::nullopt;
2381         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
2382         if (iterator.atEnd())
2383             break;
2384         if (*iterator == &#39;.&#39;)
2385             break;
2386     }
2387     if (piece &amp;&amp; leadingZeros)
2388         return WTF::nullopt;
2389     return piece;
2390 }
2391 
2392 template&lt;typename CharacterType&gt;
2393 Optional&lt;URLParser::IPv4Address&gt; URLParser::parseIPv4AddressInsideIPv6(CodePointIterator&lt;CharacterType&gt; iterator)
2394 {
2395     IPv4Address address = 0;
2396     for (size_t i = 0; i &lt; 4; ++i) {
2397         if (Optional&lt;uint32_t&gt; piece = parseIPv4PieceInsideIPv6(iterator))
2398             address = (address &lt;&lt; 8) + piece.value();
2399         else
2400             return WTF::nullopt;
2401         if (i &lt; 3) {
2402             if (iterator.atEnd())
2403                 return WTF::nullopt;
2404             if (*iterator != &#39;.&#39;)
2405                 return WTF::nullopt;
2406             advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
2407         } else if (!iterator.atEnd())
2408             return WTF::nullopt;
2409     }
2410     ASSERT(iterator.atEnd());
2411     return address;
2412 }
2413 
2414 template&lt;typename CharacterType&gt;
2415 Optional&lt;URLParser::IPv6Address&gt; URLParser::parseIPv6Host(CodePointIterator&lt;CharacterType&gt; c)
2416 {
2417     ASSERT(*c == &#39;[&#39;);
2418     const auto hostBegin = c;
2419     advance(c, hostBegin);
2420     if (c.atEnd())
2421         return WTF::nullopt;
2422 
2423     IPv6Address address = {{0, 0, 0, 0, 0, 0, 0, 0}};
2424     size_t piecePointer = 0;
2425     Optional&lt;size_t&gt; compressPointer;
2426     bool previousValueWasZero = false;
2427     bool immediatelyAfterCompress = false;
2428 
2429     if (*c == &#39;:&#39;) {
2430         advance(c, hostBegin);
2431         if (c.atEnd())
2432             return WTF::nullopt;
2433         if (*c != &#39;:&#39;)
2434             return WTF::nullopt;
2435         advance(c, hostBegin);
2436         ++piecePointer;
2437         compressPointer = piecePointer;
2438         immediatelyAfterCompress = true;
2439     }
2440 
2441     while (!c.atEnd()) {
2442         if (piecePointer == 8)
2443             return WTF::nullopt;
2444         if (*c == &#39;:&#39;) {
2445             if (compressPointer)
2446                 return WTF::nullopt;
2447             advance(c, hostBegin);
2448             ++piecePointer;
2449             compressPointer = piecePointer;
2450             immediatelyAfterCompress = true;
2451             if (previousValueWasZero)
2452                 syntaxViolation(hostBegin);
2453             continue;
2454         }
2455         if (piecePointer == 6 || (compressPointer &amp;&amp; piecePointer &lt; 6)) {
2456             if (Optional&lt;IPv4Address&gt; ipv4Address = parseIPv4AddressInsideIPv6(c)) {
2457                 if (compressPointer &amp;&amp; piecePointer == 5)
2458                     return WTF::nullopt;
2459                 syntaxViolation(hostBegin);
2460                 address[piecePointer++] = ipv4Address.value() &gt;&gt; 16;
2461                 address[piecePointer++] = ipv4Address.value() &amp; 0xFFFF;
2462                 c = { };
2463                 break;
2464             }
2465         }
2466         uint16_t value = 0;
2467         size_t length = 0;
2468         bool leadingZeros = false;
2469         for (; length &lt; 4; length++) {
2470             if (c.atEnd())
2471                 break;
2472             if (!isASCIIHexDigit(*c))
2473                 break;
2474             if (isASCIIUpper(*c))
2475                 syntaxViolation(hostBegin);
2476             if (*c == &#39;0&#39; &amp;&amp; !length)
2477                 leadingZeros = true;
2478             value = value * 0x10 + toASCIIHexValue(*c);
2479             advance(c, hostBegin);
2480         }
2481 
2482         previousValueWasZero = !value;
2483         if (UNLIKELY((value &amp;&amp; leadingZeros) || (previousValueWasZero &amp;&amp; (length &gt; 1 || immediatelyAfterCompress))))
2484             syntaxViolation(hostBegin);
2485 
2486         address[piecePointer++] = value;
2487         if (c.atEnd())
2488             break;
2489         if (piecePointer == 8 || *c != &#39;:&#39;)
2490             return WTF::nullopt;
2491         advance(c, hostBegin);
2492         if (c.atEnd())
2493             syntaxViolation(hostBegin);
2494 
2495         immediatelyAfterCompress = false;
2496     }
2497 
2498     if (!c.atEnd())
2499         return WTF::nullopt;
2500 
2501     if (compressPointer) {
2502         size_t swaps = piecePointer - compressPointer.value();
2503         piecePointer = 7;
2504         while (swaps)
2505             std::swap(address[piecePointer--], address[compressPointer.value() + swaps-- - 1]);
2506     } else if (piecePointer != 8)
2507         return WTF::nullopt;
2508 
2509     Optional&lt;size_t&gt; possibleCompressPointer = findLongestZeroSequence(address);
2510     if (possibleCompressPointer)
2511         possibleCompressPointer.value()++;
2512     if (UNLIKELY(compressPointer != possibleCompressPointer))
2513         syntaxViolation(hostBegin);
2514 
2515     return address;
2516 }
2517 
2518 template&lt;typename CharacterType&gt;
2519 URLParser::LCharBuffer URLParser::percentDecode(const LChar* input, size_t length, const CodePointIterator&lt;CharacterType&gt;&amp; iteratorForSyntaxViolationPosition)
2520 {
2521     LCharBuffer output;
2522     output.reserveInitialCapacity(length);
2523 
2524     for (size_t i = 0; i &lt; length; ++i) {
2525         uint8_t byte = input[i];
2526         if (byte != &#39;%&#39;)
2527             output.uncheckedAppend(byte);
2528         else if (length &gt; 2 &amp;&amp; i &lt; length - 2) {
2529             if (isASCIIHexDigit(input[i + 1]) &amp;&amp; isASCIIHexDigit(input[i + 2])) {
2530                 syntaxViolation(iteratorForSyntaxViolationPosition);
2531                 output.uncheckedAppend(toASCIIHexValue(input[i + 1], input[i + 2]));
2532                 i += 2;
2533             } else
2534                 output.uncheckedAppend(byte);
2535         } else
2536             output.uncheckedAppend(byte);
2537     }
2538     return output;
2539 }
2540 
2541 URLParser::LCharBuffer URLParser::percentDecode(const LChar* input, size_t length)
2542 {
2543     LCharBuffer output;
2544     output.reserveInitialCapacity(length);
2545 
2546     for (size_t i = 0; i &lt; length; ++i) {
2547         uint8_t byte = input[i];
2548         if (byte != &#39;%&#39;)
2549             output.uncheckedAppend(byte);
2550         else if (length &gt; 2 &amp;&amp; i &lt; length - 2) {
2551             if (isASCIIHexDigit(input[i + 1]) &amp;&amp; isASCIIHexDigit(input[i + 2])) {
2552                 output.uncheckedAppend(toASCIIHexValue(input[i + 1], input[i + 2]));
2553                 i += 2;
2554             } else
2555                 output.uncheckedAppend(byte);
2556         } else
2557             output.uncheckedAppend(byte);
2558     }
2559     return output;
2560 }
2561 
2562 template&lt;typename CharacterType&gt; Optional&lt;URLParser::LCharBuffer&gt; URLParser::domainToASCII(StringImpl&amp; domain, const CodePointIterator&lt;CharacterType&gt;&amp; iteratorForSyntaxViolationPosition)
2563 {
2564     LCharBuffer ascii;
2565     if (domain.isAllASCII()) {
2566         size_t length = domain.length();
2567         if (domain.is8Bit()) {
2568             const LChar* characters = domain.characters8();
2569             ascii.reserveInitialCapacity(length);
2570             for (size_t i = 0; i &lt; length; ++i) {
2571                 if (UNLIKELY(isASCIIUpper(characters[i])))
2572                     syntaxViolation(iteratorForSyntaxViolationPosition);
2573                 ascii.uncheckedAppend(toASCIILower(characters[i]));
2574             }
2575         } else {
2576             const UChar* characters = domain.characters16();
2577             ascii.reserveInitialCapacity(length);
2578             for (size_t i = 0; i &lt; length; ++i) {
2579                 if (UNLIKELY(isASCIIUpper(characters[i])))
2580                     syntaxViolation(iteratorForSyntaxViolationPosition);
2581                 ascii.uncheckedAppend(toASCIILower(characters[i]));
2582             }
2583         }
2584         return ascii;
2585     }
2586 
2587     const size_t maxDomainLength = 64;
2588     UChar hostnameBuffer[maxDomainLength];
2589     UErrorCode error = U_ZERO_ERROR;
2590     UIDNAInfo processingDetails = UIDNA_INFO_INITIALIZER;
2591     int32_t numCharactersConverted = uidna_nameToASCII(&amp;internationalDomainNameTranscoder(), StringView(domain).upconvertedCharacters(), domain.length(), hostnameBuffer, maxDomainLength, &amp;processingDetails, &amp;error);
2592 
2593     if (U_SUCCESS(error) &amp;&amp; !processingDetails.errors) {
2594 #if ASSERT_DISABLED
2595         UNUSED_PARAM(numCharactersConverted);
2596 #else
2597         for (int32_t i = 0; i &lt; numCharactersConverted; ++i) {
2598             ASSERT(isASCII(hostnameBuffer[i]));
2599             ASSERT(!isASCIIUpper(hostnameBuffer[i]));
2600         }
2601 #endif
2602         ascii.append(hostnameBuffer, numCharactersConverted);
2603         if (domain != StringView(ascii.data(), ascii.size()))
2604             syntaxViolation(iteratorForSyntaxViolationPosition);
2605         return ascii;
2606     }
2607     return WTF::nullopt;
2608 }
2609 
2610 bool URLParser::hasForbiddenHostCodePoint(const URLParser::LCharBuffer&amp; asciiDomain)
2611 {
2612     for (size_t i = 0; i &lt; asciiDomain.size(); ++i) {
2613         if (isForbiddenHostCodePoint(asciiDomain[i]))
2614             return true;
2615     }
2616     return false;
2617 }
2618 
2619 template&lt;typename CharacterType&gt;
2620 bool URLParser::parsePort(CodePointIterator&lt;CharacterType&gt;&amp; iterator)
2621 {
2622     ASSERT(*iterator == &#39;:&#39;);
2623     auto colonIterator = iterator;
2624     advance(iterator, colonIterator);
2625     uint32_t port = 0;
2626     if (UNLIKELY(iterator.atEnd())) {
2627         unsigned portLength = currentPosition(colonIterator) - m_url.m_hostEnd;
2628         RELEASE_ASSERT(portLength &lt;= URL::maxPortLength);
2629         m_url.m_portLength = portLength;
2630         syntaxViolation(colonIterator);
2631         return true;
2632     }
2633     size_t digitCount = 0;
2634     bool leadingZeros = false;
2635     for (; !iterator.atEnd(); ++iterator) {
2636         if (UNLIKELY(isTabOrNewline(*iterator))) {
2637             syntaxViolation(colonIterator);
2638             continue;
2639         }
2640         if (isASCIIDigit(*iterator)) {
2641             if (*iterator == &#39;0&#39; &amp;&amp; !digitCount)
2642                 leadingZeros = true;
2643             ++digitCount;
2644             port = port * 10 + *iterator - &#39;0&#39;;
2645             if (port &gt; std::numeric_limits&lt;uint16_t&gt;::max())
2646                 return false;
2647         } else
2648             return false;
2649     }
2650 
2651     if (port &amp;&amp; leadingZeros)
2652         syntaxViolation(colonIterator);
2653 
2654     if (!port &amp;&amp; digitCount &gt; 1)
2655         syntaxViolation(colonIterator);
2656 
2657     ASSERT(port == static_cast&lt;uint16_t&gt;(port));
2658     if (UNLIKELY(defaultPortForProtocol(parsedDataView(0, m_url.m_schemeEnd)) == static_cast&lt;uint16_t&gt;(port)))
2659         syntaxViolation(colonIterator);
2660     else {
2661         appendToASCIIBuffer(&#39;:&#39;);
2662         ASSERT(port &lt;= std::numeric_limits&lt;uint16_t&gt;::max());
2663         appendNumberToASCIIBuffer&lt;uint16_t&gt;(static_cast&lt;uint16_t&gt;(port));
2664     }
2665 
2666     unsigned portLength = currentPosition(iterator) - m_url.m_hostEnd;
2667     RELEASE_ASSERT(portLength &lt;= URL::maxPortLength);
2668     m_url.m_portLength = portLength;
2669     return true;
2670 }
2671 
2672 template&lt;typename CharacterType&gt;
2673 bool URLParser::parseHostAndPort(CodePointIterator&lt;CharacterType&gt; iterator)
2674 {
2675     if (iterator.atEnd())
2676         return false;
2677     if (*iterator == &#39;:&#39;)
2678         return false;
2679     if (*iterator == &#39;[&#39;) {
2680         auto ipv6End = iterator;
2681         while (!ipv6End.atEnd() &amp;&amp; *ipv6End != &#39;]&#39;)
2682             ++ipv6End;
2683         if (ipv6End.atEnd())
2684             return false;
2685         if (auto address = parseIPv6Host(CodePointIterator&lt;CharacterType&gt;(iterator, ipv6End))) {
2686             serializeIPv6(address.value());
2687             if (!ipv6End.atEnd()) {
2688                 advance(ipv6End);
2689                 m_url.m_hostEnd = currentPosition(ipv6End);
2690                 if (!ipv6End.atEnd() &amp;&amp; *ipv6End == &#39;:&#39;)
2691                     return parsePort(ipv6End);
2692                 m_url.m_portLength = 0;
2693                 return ipv6End.atEnd();
2694             }
2695             m_url.m_hostEnd = currentPosition(ipv6End);
2696             return true;
2697         }
2698         return false;
2699     }
2700 
2701     if (!m_urlIsSpecial) {
2702         for (; !iterator.atEnd(); ++iterator) {
2703             if (UNLIKELY(isTabOrNewline(*iterator))) {
2704                 syntaxViolation(iterator);
2705                 continue;
2706             }
2707             if (*iterator == &#39;:&#39;)
2708                 break;
2709             if (UNLIKELY(isForbiddenHostCodePoint(*iterator) &amp;&amp; *iterator != &#39;%&#39;))
2710                 return false;
2711             utf8PercentEncode&lt;isInSimpleEncodeSet&gt;(iterator);
2712         }
2713         m_url.m_hostEnd = currentPosition(iterator);
2714         if (iterator.atEnd()) {
2715             m_url.m_portLength = 0;
2716             return true;
2717         }
2718         return parsePort(iterator);
2719     }
2720 
2721     if (LIKELY(!m_hostHasPercentOrNonASCII)) {
2722         auto hostIterator = iterator;
2723         for (; !iterator.atEnd(); ++iterator) {
2724             if (isTabOrNewline(*iterator))
2725                 continue;
2726             if (*iterator == &#39;:&#39;)
2727                 break;
2728             if (isForbiddenHostCodePoint(*iterator))
2729                 return false;
2730         }
2731         auto address = parseIPv4Host(hostIterator, CodePointIterator&lt;CharacterType&gt;(hostIterator, iterator));
2732         if (address) {
2733             serializeIPv4(address.value());
2734             m_url.m_hostEnd = currentPosition(iterator);
2735             if (iterator.atEnd()) {
2736                 m_url.m_portLength = 0;
2737                 return true;
2738             }
2739             return parsePort(iterator);
2740         }
2741         if (address.error() == IPv4ParsingError::Failure)
2742             return false;
2743         for (; hostIterator != iterator; ++hostIterator) {
2744             if (UNLIKELY(isTabOrNewline(*hostIterator))) {
2745                 syntaxViolation(hostIterator);
2746                 continue;
2747             }
2748             if (UNLIKELY(isASCIIUpper(*hostIterator)))
2749                 syntaxViolation(hostIterator);
2750             appendToASCIIBuffer(toASCIILower(*hostIterator));
2751         }
2752         m_url.m_hostEnd = currentPosition(iterator);
2753         if (!hostIterator.atEnd())
2754             return parsePort(hostIterator);
2755         unsigned portLength = currentPosition(iterator) - m_url.m_hostEnd;
2756         RELEASE_ASSERT(portLength &lt;= URL::maxPortLength);
2757         m_url.m_portLength = portLength;
2758         return true;
2759     }
2760 
2761     const auto hostBegin = iterator;
2762 
2763     LCharBuffer utf8Encoded;
2764     for (; !iterator.atEnd(); ++iterator) {
2765         if (UNLIKELY(isTabOrNewline(*iterator))) {
2766             syntaxViolation(hostBegin);
2767             continue;
2768         }
2769         if (*iterator == &#39;:&#39;)
2770             break;
2771         if (UNLIKELY(!isASCII(*iterator)))
2772             syntaxViolation(hostBegin);
2773 
2774         if (!U_IS_UNICODE_CHAR(*iterator))
2775             return false;
2776         uint8_t buffer[U8_MAX_LENGTH];
2777         int32_t offset = 0;
2778         U8_APPEND_UNSAFE(buffer, offset, *iterator);
2779         utf8Encoded.append(buffer, offset);
2780     }
2781     LCharBuffer percentDecoded = percentDecode(utf8Encoded.data(), utf8Encoded.size(), hostBegin);
2782     String domain = String::fromUTF8(percentDecoded.data(), percentDecoded.size());
2783     if (domain.isNull())
2784         return false;
2785     if (domain != StringView(percentDecoded.data(), percentDecoded.size()))
2786         syntaxViolation(hostBegin);
2787     auto asciiDomain = domainToASCII(*domain.impl(), hostBegin);
2788     if (!asciiDomain || hasForbiddenHostCodePoint(asciiDomain.value()))
2789         return false;
2790     LCharBuffer&amp; asciiDomainValue = asciiDomain.value();
2791     const LChar* asciiDomainCharacters = asciiDomainValue.data();
2792 
2793     auto address = parseIPv4Host(hostBegin, CodePointIterator&lt;LChar&gt;(asciiDomainValue.begin(), asciiDomainValue.end()));
2794     if (address) {
2795         serializeIPv4(address.value());
2796         m_url.m_hostEnd = currentPosition(iterator);
2797         if (iterator.atEnd()) {
2798             m_url.m_portLength = 0;
2799             return true;
2800         }
2801         return parsePort(iterator);
2802     }
2803     if (address.error() == IPv4ParsingError::Failure)
2804         return false;
2805 
2806     appendToASCIIBuffer(asciiDomainCharacters, asciiDomainValue.size());
2807     m_url.m_hostEnd = currentPosition(iterator);
2808     if (!iterator.atEnd())
2809         return parsePort(iterator);
2810     m_url.m_portLength = 0;
2811     return true;
2812 }
2813 
2814 Optional&lt;String&gt; URLParser::formURLDecode(StringView input)
2815 {
2816     auto utf8 = input.utf8(StrictConversion);
2817     if (utf8.isNull())
2818         return WTF::nullopt;
2819     auto percentDecoded = percentDecode(reinterpret_cast&lt;const LChar*&gt;(utf8.data()), utf8.length());
2820     return String::fromUTF8(percentDecoded.data(), percentDecoded.size());
2821 }
2822 
2823 // https://url.spec.whatwg.org/#concept-urlencoded-parser
2824 auto URLParser::parseURLEncodedForm(StringView input) -&gt; URLEncodedForm
2825 {
2826     URLEncodedForm output;
2827     for (StringView bytes : input.split(&#39;&amp;&#39;)) {
2828         auto equalIndex = bytes.find(&#39;=&#39;);
2829         if (equalIndex == notFound) {
2830             auto name = formURLDecode(bytes.toString().replace(&#39;+&#39;, 0x20));
2831             if (name)
2832                 output.append({ name.value(), emptyString() });
2833         } else {
2834             auto name = formURLDecode(bytes.substring(0, equalIndex).toString().replace(&#39;+&#39;, 0x20));
2835             auto value = formURLDecode(bytes.substring(equalIndex + 1).toString().replace(&#39;+&#39;, 0x20));
2836             if (name &amp;&amp; value)
2837                 output.append({ name.value(), value.value() });
2838         }
2839     }
2840     return output;
2841 }
2842 
2843 static void serializeURLEncodedForm(const String&amp; input, Vector&lt;LChar&gt;&amp; output)
2844 {
2845     auto utf8 = input.utf8(StrictConversion);
2846     const char* data = utf8.data();
2847     for (size_t i = 0; i &lt; utf8.length(); ++i) {
2848         const char byte = data[i];
2849         if (byte == 0x20)
2850             output.append(0x2B);
2851         else if (byte == 0x2A
2852             || byte == 0x2D
2853             || byte == 0x2E
2854             || (byte &gt;= 0x30 &amp;&amp; byte &lt;= 0x39)
2855             || (byte &gt;= 0x41 &amp;&amp; byte &lt;= 0x5A)
2856             || byte == 0x5F
2857             || (byte &gt;= 0x61 &amp;&amp; byte &lt;= 0x7A)) // FIXME: Put these in the characterClassTable to avoid branches.
2858             output.append(byte);
2859         else
2860             percentEncodeByte(byte, output);
2861     }
2862 }
2863 
2864 String URLParser::serialize(const URLEncodedForm&amp; tuples)
2865 {
2866     if (tuples.isEmpty())
2867         return { };
2868 
2869     Vector&lt;LChar&gt; output;
2870     for (auto&amp; tuple : tuples) {
2871         if (!output.isEmpty())
2872             output.append(&#39;&amp;&#39;);
2873         serializeURLEncodedForm(tuple.key, output);
2874         output.append(&#39;=&#39;);
2875         serializeURLEncodedForm(tuple.value, output);
2876     }
2877     return String::adopt(WTFMove(output));
2878 }
2879 
2880 const UIDNA&amp; URLParser::internationalDomainNameTranscoder()
2881 {
2882     static UIDNA* encoder;
2883     static std::once_flag onceFlag;
2884     std::call_once(onceFlag, [] {
2885         UErrorCode error = U_ZERO_ERROR;
2886         encoder = uidna_openUTS46(UIDNA_CHECK_BIDI | UIDNA_CHECK_CONTEXTJ | UIDNA_NONTRANSITIONAL_TO_UNICODE | UIDNA_NONTRANSITIONAL_TO_ASCII, &amp;error);
2887         RELEASE_ASSERT(U_SUCCESS(error));
2888         RELEASE_ASSERT(encoder);
2889     });
2890     return *encoder;
2891 }
2892 
2893 bool URLParser::allValuesEqual(const URL&amp; a, const URL&amp; b)
2894 {
2895     URL_PARSER_LOG(&quot;%d %d %d %d %d %d %d %d %d %d %d %d %s\n%d %d %d %d %d %d %d %d %d %d %d %d %s&quot;,
2896         a.m_isValid,
2897         a.m_cannotBeABaseURL,
2898         a.m_protocolIsInHTTPFamily,
2899         a.m_schemeEnd,
2900         a.m_userStart,
2901         a.m_userEnd,
2902         a.m_passwordEnd,
2903         a.m_hostEnd,
2904         a.m_hostEnd + a.m_portLength,
2905         a.m_pathAfterLastSlash,
2906         a.m_pathEnd,
2907         a.m_queryEnd,
2908         a.m_string.utf8().data(),
2909         b.m_isValid,
2910         b.m_cannotBeABaseURL,
2911         b.m_protocolIsInHTTPFamily,
2912         b.m_schemeEnd,
2913         b.m_userStart,
2914         b.m_userEnd,
2915         b.m_passwordEnd,
2916         b.m_hostEnd,
2917         b.m_hostEnd + b.m_portLength,
2918         b.m_pathAfterLastSlash,
2919         b.m_pathEnd,
2920         b.m_queryEnd,
2921         b.m_string.utf8().data());
2922 
2923     return a.m_string == b.m_string
2924         &amp;&amp; a.m_isValid == b.m_isValid
2925         &amp;&amp; a.m_cannotBeABaseURL == b.m_cannotBeABaseURL
2926         &amp;&amp; a.m_protocolIsInHTTPFamily == b.m_protocolIsInHTTPFamily
2927         &amp;&amp; a.m_schemeEnd == b.m_schemeEnd
2928         &amp;&amp; a.m_userStart == b.m_userStart
2929         &amp;&amp; a.m_userEnd == b.m_userEnd
2930         &amp;&amp; a.m_passwordEnd == b.m_passwordEnd
2931         &amp;&amp; a.m_hostEnd == b.m_hostEnd
2932         &amp;&amp; a.m_portLength == b.m_portLength
2933         &amp;&amp; a.m_pathAfterLastSlash == b.m_pathAfterLastSlash
2934         &amp;&amp; a.m_pathEnd == b.m_pathEnd
2935         &amp;&amp; a.m_queryEnd == b.m_queryEnd;
2936 }
2937 
2938 bool URLParser::internalValuesConsistent(const URL&amp; url)
2939 {
2940     return url.m_schemeEnd &lt;= url.m_userStart
2941         &amp;&amp; url.m_userStart &lt;= url.m_userEnd
2942         &amp;&amp; url.m_userEnd &lt;= url.m_passwordEnd
2943         &amp;&amp; url.m_passwordEnd &lt;= url.m_hostEnd
2944         &amp;&amp; url.m_hostEnd + url.m_portLength &lt;= url.m_pathAfterLastSlash
2945         &amp;&amp; url.m_pathAfterLastSlash &lt;= url.m_pathEnd
2946         &amp;&amp; url.m_pathEnd &lt;= url.m_queryEnd
2947         &amp;&amp; url.m_queryEnd &lt;= url.m_string.length();
2948 }
2949 
2950 } // namespace WTF
    </pre>
  </body>
</html>