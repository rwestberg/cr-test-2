<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/Editor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2006-2016 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Editor.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;AlternativeTextController.h&quot;
  32 #include &quot;ApplyStyleCommand.h&quot;
  33 #include &quot;CSSComputedStyleDeclaration.h&quot;
  34 #include &quot;CSSPropertyNames.h&quot;
  35 #include &quot;CSSValueList.h&quot;
  36 #include &quot;CSSValuePool.h&quot;
  37 #include &quot;CachedResourceLoader.h&quot;
  38 #include &quot;ChangeListTypeCommand.h&quot;
  39 #include &quot;ClipboardEvent.h&quot;
  40 #include &quot;CompositionEvent.h&quot;
  41 #include &quot;CreateLinkCommand.h&quot;
  42 #include &quot;CustomUndoStep.h&quot;
  43 #include &quot;DataTransfer.h&quot;
  44 #include &quot;DeleteSelectionCommand.h&quot;
  45 #include &quot;DictationAlternative.h&quot;
  46 #include &quot;DictationCommand.h&quot;
  47 #include &quot;DocumentFragment.h&quot;
  48 #include &quot;DocumentMarkerController.h&quot;
  49 #include &quot;Editing.h&quot;
  50 #include &quot;EditorClient.h&quot;
  51 #include &quot;EventHandler.h&quot;
  52 #include &quot;EventNames.h&quot;
  53 #include &quot;File.h&quot;
  54 #include &quot;FocusController.h&quot;
  55 #include &quot;FontAttributes.h&quot;
  56 #include &quot;Frame.h&quot;
  57 #include &quot;FrameLoader.h&quot;
  58 #include &quot;FrameTree.h&quot;
  59 #include &quot;FrameView.h&quot;
  60 #include &quot;GraphicsContext.h&quot;
  61 #include &quot;HTMLAttachmentElement.h&quot;
  62 #include &quot;HTMLBRElement.h&quot;
  63 #include &quot;HTMLCollection.h&quot;
  64 #include &quot;HTMLFormControlElement.h&quot;
  65 #include &quot;HTMLFrameOwnerElement.h&quot;
  66 #include &quot;HTMLImageElement.h&quot;
  67 #include &quot;HTMLInputElement.h&quot;
  68 #include &quot;HTMLNames.h&quot;
  69 #include &quot;HTMLOListElement.h&quot;
  70 #include &quot;HTMLQuoteElement.h&quot;
  71 #include &quot;HTMLSpanElement.h&quot;
  72 #include &quot;HTMLUListElement.h&quot;
  73 #include &quot;HitTestResult.h&quot;
  74 #include &quot;IndentOutdentCommand.h&quot;
  75 #include &quot;InputEvent.h&quot;
  76 #include &quot;InsertEditableImageCommand.h&quot;
  77 #include &quot;InsertListCommand.h&quot;
  78 #include &quot;InsertTextCommand.h&quot;
  79 #include &quot;KeyboardEvent.h&quot;
  80 #include &quot;Logging.h&quot;
  81 #include &quot;ModifySelectionListLevel.h&quot;
  82 #include &quot;NodeList.h&quot;
  83 #include &quot;NodeTraversal.h&quot;
  84 #include &quot;Page.h&quot;
  85 #include &quot;Pasteboard.h&quot;
  86 #include &quot;Range.h&quot;
  87 #include &quot;RemoveFormatCommand.h&quot;
  88 #include &quot;RenderBlock.h&quot;
  89 #include &quot;RenderTextControl.h&quot;
  90 #include &quot;RenderedDocumentMarker.h&quot;
  91 #include &quot;RenderedPosition.h&quot;
  92 #include &quot;ReplaceRangeWithTextCommand.h&quot;
  93 #include &quot;ReplaceSelectionCommand.h&quot;
  94 #include &quot;RuntimeEnabledFeatures.h&quot;
  95 #include &quot;SerializedAttachmentData.h&quot;
  96 #include &quot;Settings.h&quot;
  97 #include &quot;ShadowRoot.h&quot;
  98 #include &quot;SharedBuffer.h&quot;
  99 #include &quot;SimplifyMarkupCommand.h&quot;
 100 #include &quot;SpellChecker.h&quot;
 101 #include &quot;SpellingCorrectionCommand.h&quot;
 102 #include &quot;StaticPasteboard.h&quot;
 103 #include &quot;StyleProperties.h&quot;
 104 #include &quot;TelephoneNumberDetector.h&quot;
 105 #include &quot;Text.h&quot;
 106 #include &quot;TextCheckerClient.h&quot;
 107 #include &quot;TextCheckingHelper.h&quot;
 108 #include &quot;TextEvent.h&quot;
 109 #include &quot;TextIterator.h&quot;
 110 #include &quot;TypingCommand.h&quot;
 111 #include &quot;UserTypingGestureIndicator.h&quot;
 112 #include &quot;VisibleUnits.h&quot;
 113 #include &quot;markup.h&quot;
 114 #include &lt;pal/FileSizeFormatter.h&gt;
 115 #include &lt;pal/system/Sound.h&gt;
 116 #include &lt;pal/text/KillRing.h&gt;
 117 #include &lt;wtf/unicode/CharacterNames.h&gt;
 118 
 119 #if PLATFORM(MAC)
 120 #include &quot;ServicesOverlayController.h&quot;
 121 #endif
 122 
 123 namespace WebCore {
 124 
<a name="1" id="anc1"></a><span class="line-modified"> 125 static bool dispatchBeforeInputEvent(Element&amp; element, const AtomicString&amp; inputType, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { }, Event::IsCancelable cancelable = Event::IsCancelable::Yes)</span>
 126 {
 127     if (!element.document().settings().inputEventsEnabled())
 128         return true;
 129 
 130     auto event = InputEvent::create(eventNames().beforeinputEvent, inputType, cancelable, element.document().windowProxy(), data, WTFMove(dataTransfer), targetRanges, 0);
 131     element.dispatchEvent(event);
 132     return !event-&gt;defaultPrevented();
 133 }
 134 
<a name="2" id="anc2"></a><span class="line-modified"> 135 static void dispatchInputEvent(Element&amp; element, const AtomicString&amp; inputType, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { })</span>
 136 {
 137     if (element.document().settings().inputEventsEnabled()) {
 138         // FIXME: We should not be dispatching to the scoped queue here. Normally, input events are dispatched in CompositeEditCommand::apply after the end of the scope,
 139         // but TypingCommands are special in that existing TypingCommands that are applied again fire input events *from within* the scope by calling typingAddedToOpenCommand.
 140         // Instead, TypingCommands should always dispatch events synchronously after the end of the scoped queue in CompositeEditCommand::apply. To work around this for the
 141         // time being, just revert back to calling dispatchScopedEvent.
 142         element.dispatchScopedEvent(InputEvent::create(eventNames().inputEvent, inputType, Event::IsCancelable::No,
 143             element.document().windowProxy(), data, WTFMove(dataTransfer), targetRanges, 0));
 144     } else
 145         element.dispatchInputEvent();
 146 }
 147 
 148 static String inputEventDataForEditingStyleAndAction(const StyleProperties* style, EditAction action)
 149 {
 150     if (!style)
 151         return { };
 152 
 153     switch (action) {
 154     case EditAction::SetColor:
 155         return style-&gt;getPropertyValue(CSSPropertyColor);
<a name="3" id="anc3"></a><span class="line-modified"> 156     case EditAction::SetWritingDirection:</span>

 157         return style-&gt;getPropertyValue(CSSPropertyDirection);
 158     default:
 159         return { };
 160     }
 161 }
 162 
 163 static String inputEventDataForEditingStyleAndAction(EditingStyle&amp; style, EditAction action)
 164 {
 165     return inputEventDataForEditingStyleAndAction(style.style(), action);
 166 }
 167 
 168 class ClearTextCommand : public DeleteSelectionCommand {
 169 public:
 170     ClearTextCommand(Document&amp; document);
 171     static void CreateAndApply(const RefPtr&lt;Frame&gt; frame);
 172 
 173 private:
 174     EditAction editingAction() const override;
 175 };
 176 
 177 ClearTextCommand::ClearTextCommand(Document&amp; document)
 178     : DeleteSelectionCommand(document, false, true, false, false, true)
 179 {
 180 }
 181 
 182 EditAction ClearTextCommand::editingAction() const
 183 {
 184     return EditAction::Delete;
 185 }
 186 
 187 void ClearTextCommand::CreateAndApply(const RefPtr&lt;Frame&gt; frame)
 188 {
 189     if (frame-&gt;selection().isNone())
 190         return;
 191 
 192     // Don&#39;t leave around stale composition state.
 193     frame-&gt;editor().clear();
 194 
 195     const VisibleSelection oldSelection = frame-&gt;selection().selection();
 196     frame-&gt;selection().selectAll();
 197     auto clearCommand = adoptRef(*new ClearTextCommand(*frame-&gt;document()));
 198     clearCommand-&gt;setStartingSelection(oldSelection);
 199     clearCommand-&gt;apply();
 200 }
 201 
 202 using namespace HTMLNames;
 203 using namespace WTF::Unicode;
 204 
 205 TemporarySelectionChange::TemporarySelectionChange(Frame&amp; frame, Optional&lt;VisibleSelection&gt; temporarySelection, OptionSet&lt;TemporarySelectionOption&gt; options)
 206     : m_frame(frame)
 207     , m_options(options)
 208     , m_wasIgnoringSelectionChanges(frame.editor().ignoreSelectionChanges())
 209 #if PLATFORM(IOS_FAMILY)
 210     , m_appearanceUpdatesWereEnabled(frame.selection().isUpdateAppearanceEnabled())
 211 #endif
 212 {
 213 #if PLATFORM(IOS_FAMILY)
 214     if (options &amp; TemporarySelectionOption::EnableAppearanceUpdates)
 215         frame.selection().setUpdateAppearanceEnabled(true);
 216 #endif
 217 
 218     if (options &amp; TemporarySelectionOption::IgnoreSelectionChanges)
 219         frame.editor().setIgnoreSelectionChanges(true);
 220 
 221     if (temporarySelection) {
 222         m_selectionToRestore = frame.selection().selection();
 223         setSelection(temporarySelection.value());
 224     }
 225 }
 226 
 227 TemporarySelectionChange::~TemporarySelectionChange()
 228 {
 229     if (m_selectionToRestore)
 230         setSelection(m_selectionToRestore.value());
 231 
 232     if (m_options &amp; TemporarySelectionOption::IgnoreSelectionChanges) {
 233         auto revealSelection = m_options &amp; TemporarySelectionOption::RevealSelection ? Editor::RevealSelection::Yes : Editor::RevealSelection::No;
 234         m_frame-&gt;editor().setIgnoreSelectionChanges(m_wasIgnoringSelectionChanges, revealSelection);
 235     }
 236 
 237 #if PLATFORM(IOS_FAMILY)
 238     if (m_options &amp; TemporarySelectionOption::EnableAppearanceUpdates)
 239         m_frame-&gt;selection().setUpdateAppearanceEnabled(m_appearanceUpdatesWereEnabled);
 240 #endif
 241 }
 242 
 243 void TemporarySelectionChange::setSelection(const VisibleSelection&amp; selection)
 244 {
 245     auto options = FrameSelection::defaultSetSelectionOptions();
 246     if (m_options &amp; TemporarySelectionOption::DoNotSetFocus)
 247         options.add(FrameSelection::DoNotSetFocus);
 248     m_frame-&gt;selection().setSelection(selection, options);
 249 }
 250 
 251 // When an event handler has moved the selection outside of a text control
 252 // we should use the target control&#39;s selection for this editing operation.
 253 VisibleSelection Editor::selectionForCommand(Event* event)
 254 {
 255     auto selection = m_frame.selection().selection();
 256     if (!event)
 257         return selection;
 258     // If the target is a text control, and the current selection is outside of its shadow tree,
 259     // then use the saved selection for that text control.
 260     if (is&lt;Element&gt;(event-&gt;target()) &amp;&amp; downcast&lt;Element&gt;(*event-&gt;target()).isTextField()) {
 261         auto&amp; target = downcast&lt;HTMLTextFormControlElement&gt;(*event-&gt;target());
 262         auto start = selection.start();
 263         if (start.isNull() || &amp;target != enclosingTextFormControl(start)) {
 264             if (auto range = target.selection())
 265                 return { *range, DOWNSTREAM, selection.isDirectional() };
 266         }
 267     }
 268     return selection;
 269 }
 270 
 271 // Function considers Mac editing behavior a fallback when Page or Settings is not available.
 272 EditingBehavior Editor::behavior() const
 273 {
 274     return EditingBehavior(m_frame.settings().editingBehaviorType());
 275 }
 276 
 277 EditorClient* Editor::client() const
 278 {
 279     if (Page* page = m_frame.page())
 280         return &amp;page-&gt;editorClient();
 281     return nullptr;
 282 }
 283 
 284 TextCheckerClient* Editor::textChecker() const
 285 {
 286     if (EditorClient* owner = client())
 287         return owner-&gt;textChecker();
 288     return 0;
 289 }
 290 
 291 void Editor::handleKeyboardEvent(KeyboardEvent&amp; event)
 292 {
<a name="4" id="anc4"></a><span class="line-modified"> 293     if (EditorClient* c = client())</span>
<span class="line-modified"> 294         c-&gt;handleKeyboardEvent(&amp;event);</span>
 295 }
 296 
 297 void Editor::handleInputMethodKeydown(KeyboardEvent&amp; event)
 298 {
<a name="5" id="anc5"></a><span class="line-modified"> 299     if (EditorClient* c = client())</span>
<span class="line-modified"> 300         c-&gt;handleInputMethodKeydown(&amp;event);</span>
 301 }
 302 
 303 bool Editor::handleTextEvent(TextEvent&amp; event)
 304 {
 305     LOG(Editing, &quot;Editor %p handleTextEvent (data %s)&quot;, this, event.data().utf8().data());
 306 
 307     // Default event handling for Drag and Drop will be handled by DragController
 308     // so we leave the event for it.
 309     if (event.isDrop())
 310         return false;
 311 
 312     if (event.isPaste()) {
 313         if (event.pastingFragment()) {
 314 #if PLATFORM(IOS_FAMILY)
 315             if (client()-&gt;performsTwoStepPaste(event.pastingFragment()))
 316                 return true;
 317 #endif
 318             replaceSelectionWithFragment(*event.pastingFragment(), SelectReplacement::No, event.shouldSmartReplace() ? SmartReplace::Yes : SmartReplace::No, event.shouldMatchStyle() ? MatchStyle::Yes : MatchStyle::No, EditAction::Paste, event.mailBlockquoteHandling());
 319         } else
 320             replaceSelectionWithText(event.data(), SelectReplacement::No, event.shouldSmartReplace() ? SmartReplace::Yes : SmartReplace::No, EditAction::Paste);
 321         return true;
 322     }
 323 
 324     String data = event.data();
 325     if (data == &quot;\n&quot;) {
 326         if (event.isLineBreak())
 327             return insertLineBreak();
 328         return insertParagraphSeparator();
 329     }
 330 
 331     return insertTextWithoutSendingTextEvent(data, false, &amp;event);
 332 }
 333 
 334 bool Editor::canEdit() const
 335 {
 336     return m_frame.selection().selection().rootEditableElement();
 337 }
 338 
 339 bool Editor::canEditRichly() const
 340 {
 341     return m_frame.selection().selection().isContentRichlyEditable();
 342 }
 343 
 344 enum class ClipboardEventKind {
 345     Copy,
 346     Cut,
 347     Paste,
 348     PasteAsPlainText,
 349     PasteAsQuotation,
 350     BeforeCopy,
 351     BeforeCut,
 352     BeforePaste,
 353 };
 354 
<a name="6" id="anc6"></a><span class="line-modified"> 355 static AtomicString eventNameForClipboardEvent(ClipboardEventKind kind)</span>
 356 {
 357     switch (kind) {
 358     case ClipboardEventKind::Copy:
 359         return eventNames().copyEvent;
 360     case ClipboardEventKind::Cut:
 361         return eventNames().cutEvent;
 362     case ClipboardEventKind::Paste:
 363     case ClipboardEventKind::PasteAsPlainText:
 364     case ClipboardEventKind::PasteAsQuotation:
 365         return eventNames().pasteEvent;
 366     case ClipboardEventKind::BeforeCopy:
 367         return eventNames().beforecopyEvent;
 368     case ClipboardEventKind::BeforeCut:
 369         return eventNames().beforecutEvent;
 370     case ClipboardEventKind::BeforePaste:
 371         return eventNames().beforepasteEvent;
 372     }
 373     ASSERT_NOT_REACHED();
 374     return { };
 375 }
 376 
 377 static Ref&lt;DataTransfer&gt; createDataTransferForClipboardEvent(Document&amp; document, ClipboardEventKind kind)
 378 {
 379     switch (kind) {
 380     case ClipboardEventKind::Copy:
 381     case ClipboardEventKind::Cut:
<a name="7" id="anc7"></a><span class="line-modified"> 382         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::ReadWrite, std::make_unique&lt;StaticPasteboard&gt;());</span>
 383     case ClipboardEventKind::PasteAsPlainText:
 384         if (RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled()) {
 385             auto plainTextType = &quot;text/plain&quot;_s;
 386             auto plainText = Pasteboard::createForCopyAndPaste()-&gt;readString(plainTextType);
<a name="8" id="anc8"></a><span class="line-modified"> 387             auto pasteboard = std::make_unique&lt;StaticPasteboard&gt;();</span>
 388             pasteboard-&gt;writeString(plainTextType, plainText);
 389             return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Readonly, WTFMove(pasteboard));
 390         }
 391         FALLTHROUGH;
 392     case ClipboardEventKind::Paste:
 393     case ClipboardEventKind::PasteAsQuotation:
 394         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Readonly, Pasteboard::createForCopyAndPaste());
 395     case ClipboardEventKind::BeforeCopy:
 396     case ClipboardEventKind::BeforeCut:
 397     case ClipboardEventKind::BeforePaste:
<a name="9" id="anc9"></a><span class="line-modified"> 398         return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Invalid, std::make_unique&lt;StaticPasteboard&gt;());</span>
 399     }
 400     ASSERT_NOT_REACHED();
<a name="10" id="anc10"></a><span class="line-modified"> 401     return DataTransfer::createForCopyAndPaste(document, DataTransfer::StoreMode::Invalid, std::make_unique&lt;StaticPasteboard&gt;());</span>
 402 }
 403 
 404 // Returns whether caller should continue with &quot;the default processing&quot;, which is the same as
 405 // the event handler NOT setting the return value to false
 406 // https://w3c.github.io/clipboard-apis/#fire-a-clipboard-event
 407 static bool dispatchClipboardEvent(RefPtr&lt;Element&gt;&amp;&amp; target, ClipboardEventKind kind)
 408 {
 409     // FIXME: Move the target selection code here.
 410     if (!target)
 411         return true;
 412 
 413     auto dataTransfer = createDataTransferForClipboardEvent(target-&gt;document(), kind);
 414 
 415     auto event = ClipboardEvent::create(eventNameForClipboardEvent(kind), dataTransfer.copyRef());
 416 
 417     target-&gt;dispatchEvent(event);
 418     bool noDefaultProcessing = event-&gt;defaultPrevented();
 419     if (noDefaultProcessing &amp;&amp; (kind == ClipboardEventKind::Copy || kind == ClipboardEventKind::Cut)) {
 420         auto pasteboard = Pasteboard::createForCopyAndPaste();
 421         pasteboard-&gt;clear();
 422         dataTransfer-&gt;commitToPasteboard(*pasteboard);
 423     }
 424 
 425     dataTransfer-&gt;makeInvalidForSecurity();
 426 
 427     return !noDefaultProcessing;
 428 }
 429 
 430 // WinIE uses onbeforecut and onbeforepaste to enables the cut and paste menu items.  They
 431 // also send onbeforecopy, apparently for symmetry, but it doesn&#39;t affect the menu items.
 432 // We need to use onbeforecopy as a real menu enabler because we allow elements that are not
 433 // normally selectable to implement copy/paste (like divs, or a document body).
 434 
 435 bool Editor::canDHTMLCut()
 436 {
 437     if (m_frame.selection().selection().isInPasswordField())
 438         return false;
 439 
 440     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::BeforeCut);
 441 }
 442 
 443 bool Editor::canDHTMLCopy()
 444 {
 445     if (m_frame.selection().selection().isInPasswordField())
 446         return false;
 447     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::BeforeCopy);
 448 }
 449 
 450 bool Editor::canDHTMLPaste()
 451 {
 452     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::BeforePaste);
 453 }
 454 
 455 bool Editor::canCut() const
 456 {
 457     return canCopy() &amp;&amp; canDelete();
 458 }
 459 
 460 static HTMLImageElement* imageElementFromImageDocument(Document&amp; document)
 461 {
 462     if (!document.isImageDocument())
 463         return nullptr;
 464 
 465     HTMLElement* body = document.bodyOrFrameset();
 466     if (!body)
 467         return nullptr;
 468 
 469     Node* node = body-&gt;firstChild();
 470     if (!is&lt;HTMLImageElement&gt;(node))
 471         return nullptr;
 472     return downcast&lt;HTMLImageElement&gt;(node);
 473 }
 474 
 475 bool Editor::canCopy() const
 476 {
 477     if (imageElementFromImageDocument(document()))
 478         return true;
 479     const VisibleSelection&amp; selection = m_frame.selection().selection();
 480     return selection.isRange() &amp;&amp; !selection.isInPasswordField();
 481 }
 482 
 483 bool Editor::canPaste() const
 484 {
 485     if (m_frame.mainFrame().loader().shouldSuppressTextInputFromEditing())
 486         return false;
 487 
 488     return canEdit();
 489 }
 490 
 491 bool Editor::canDelete() const
 492 {
 493     const VisibleSelection&amp; selection = m_frame.selection().selection();
 494     return selection.isRange() &amp;&amp; selection.rootEditableElement();
 495 }
 496 
 497 bool Editor::canDeleteRange(Range* range) const
 498 {
 499     Node&amp; startContainer = range-&gt;startContainer();
 500     Node&amp; endContainer = range-&gt;endContainer();
 501 
 502     if (!startContainer.hasEditableStyle() || !endContainer.hasEditableStyle())
 503         return false;
 504 
 505     if (range-&gt;collapsed()) {
 506         VisiblePosition start(range-&gt;startPosition(), DOWNSTREAM);
 507         VisiblePosition previous = start.previous();
 508         // FIXME: We sometimes allow deletions at the start of editable roots, like when the caret is in an empty list item.
 509         if (previous.isNull() || previous.deepEquivalent().deprecatedNode()-&gt;rootEditableElement() != startContainer.rootEditableElement())
 510             return false;
 511     }
 512     return true;
 513 }
 514 
<a name="11" id="anc11"></a>






 515 bool Editor::smartInsertDeleteEnabled()
 516 {
 517     return client() &amp;&amp; client()-&gt;smartInsertDeleteEnabled();
 518 }
 519 
 520 bool Editor::canSmartCopyOrDelete()
 521 {
<a name="12" id="anc12"></a><span class="line-modified"> 522     return client() &amp;&amp; client()-&gt;smartInsertDeleteEnabled() &amp;&amp; m_frame.selection().granularity() == WordGranularity;</span>
 523 }
 524 
 525 bool Editor::isSelectTrailingWhitespaceEnabled() const
 526 {
 527     return client() &amp;&amp; client()-&gt;isSelectTrailingWhitespaceEnabled();
 528 }
 529 
 530 bool Editor::deleteWithDirection(SelectionDirection direction, TextGranularity granularity, bool shouldAddToKillRing, bool isTypingAction)
 531 {
 532     if (!canEdit())
 533         return false;
 534 
 535     if (m_frame.selection().isRange()) {
 536         if (isTypingAction) {
 537             TypingCommand::deleteKeyPressed(document(), canSmartCopyOrDelete() ? TypingCommand::SmartDelete : 0, granularity);
 538             revealSelectionAfterEditingOperation();
 539         } else {
 540             if (shouldAddToKillRing)
 541                 addRangeToKillRing(*selectedRange().get(), KillRingInsertionMode::AppendText);
 542             deleteSelectionWithSmartDelete(canSmartCopyOrDelete());
 543             // Implicitly calls revealSelectionAfterEditingOperation().
 544         }
 545     } else {
 546         TypingCommand::Options options = 0;
 547         if (canSmartCopyOrDelete())
 548             options |= TypingCommand::SmartDelete;
 549         if (shouldAddToKillRing)
 550             options |= TypingCommand::AddsToKillRing;
 551         switch (direction) {
 552         case DirectionForward:
 553         case DirectionRight:
 554             TypingCommand::forwardDeleteKeyPressed(document(), options, granularity);
 555             break;
 556         case DirectionBackward:
 557         case DirectionLeft:
 558             TypingCommand::deleteKeyPressed(document(), options, granularity);
 559             break;
 560         }
 561         revealSelectionAfterEditingOperation();
 562     }
 563 
 564     // FIXME: We should to move this down into deleteKeyPressed.
 565     // clear the &quot;start new kill ring sequence&quot; setting, because it was set to true
 566     // when the selection was updated by deleting the range
 567     if (shouldAddToKillRing)
 568         setStartNewKillRingSequence(false);
 569 
 570     return true;
 571 }
 572 
 573 void Editor::deleteSelectionWithSmartDelete(bool smartDelete, EditAction editingAction)
 574 {
 575     if (m_frame.selection().isNone())
 576         return;
 577 
 578     DeleteSelectionCommand::create(document(), smartDelete, true, false, false, true, editingAction)-&gt;apply();
 579 }
 580 
 581 void Editor::clearText()
 582 {
 583     ClearTextCommand::CreateAndApply(&amp;m_frame);
 584 }
 585 
 586 void Editor::pasteAsPlainText(const String&amp; pastingText, bool smartReplace)
 587 {
 588     Element* target = findEventTargetFromSelection();
 589     if (!target)
 590         return;
 591     target-&gt;dispatchEvent(TextEvent::createForPlainTextPaste(document().windowProxy(), pastingText, smartReplace));
 592 }
 593 
 594 void Editor::pasteAsFragment(Ref&lt;DocumentFragment&gt;&amp;&amp; pastingFragment, bool smartReplace, bool matchStyle, MailBlockquoteHandling respectsMailBlockquote)
 595 {
 596     Element* target = findEventTargetFromSelection();
 597     if (!target)
 598         return;
 599     target-&gt;dispatchEvent(TextEvent::createForFragmentPaste(document().windowProxy(), WTFMove(pastingFragment), smartReplace, matchStyle, respectsMailBlockquote));
 600 }
 601 
 602 void Editor::pasteAsPlainTextBypassingDHTML()
 603 {
 604     pasteAsPlainTextWithPasteboard(*Pasteboard::createForCopyAndPaste());
 605 }
 606 
 607 void Editor::pasteAsPlainTextWithPasteboard(Pasteboard&amp; pasteboard)
 608 {
 609     String text = readPlainTextFromPasteboard(pasteboard);
 610     if (client() &amp;&amp; client()-&gt;shouldInsertText(text, selectedRange().get(), EditorInsertAction::Pasted))
 611         pasteAsPlainText(text, canSmartReplaceWithPasteboard(pasteboard));
 612 }
 613 
 614 String Editor::readPlainTextFromPasteboard(Pasteboard&amp; pasteboard)
 615 {
 616     PasteboardPlainText text;
 617     pasteboard.read(text);
 618     return plainTextFromPasteboard(text);
 619 }
 620 
 621 #if !PLATFORM(MAC)
 622 
 623 String Editor::plainTextFromPasteboard(const PasteboardPlainText&amp; text)
 624 {
 625     return text.text;
 626 }
 627 
 628 #endif
 629 
 630 bool Editor::canSmartReplaceWithPasteboard(Pasteboard&amp; pasteboard)
 631 {
 632     return client() &amp;&amp; client()-&gt;smartInsertDeleteEnabled() &amp;&amp; pasteboard.canSmartReplace();
 633 }
 634 
 635 bool Editor::shouldInsertFragment(DocumentFragment&amp; fragment, Range* replacingDOMRange, EditorInsertAction givenAction)
 636 {
 637     if (!client())
 638         return false;
 639 
 640     auto* child = fragment.firstChild();
 641     if (is&lt;CharacterData&gt;(child) &amp;&amp; fragment.lastChild() == child)
 642         return client()-&gt;shouldInsertText(downcast&lt;CharacterData&gt;(*child).data(), replacingDOMRange, givenAction);
 643 
 644     return client()-&gt;shouldInsertNode(&amp;fragment, replacingDOMRange, givenAction);
 645 }
 646 
 647 void Editor::replaceSelectionWithFragment(DocumentFragment&amp; fragment, SelectReplacement selectReplacement, SmartReplace smartReplace, MatchStyle matchStyle, EditAction editingAction, MailBlockquoteHandling mailBlockquoteHandling)
 648 {
 649     VisibleSelection selection = m_frame.selection().selection();
 650     if (selection.isNone() || !selection.isContentEditable())
 651         return;
 652 
 653     AccessibilityReplacedText replacedText;
 654     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction == EditAction::Paste)
 655         replacedText = AccessibilityReplacedText(selection);
 656 
 657     OptionSet&lt;ReplaceSelectionCommand::CommandOption&gt; options { ReplaceSelectionCommand::PreventNesting, ReplaceSelectionCommand::SanitizeFragment };
 658     if (selectReplacement == SelectReplacement::Yes)
 659         options.add(ReplaceSelectionCommand::SelectReplacement);
 660     if (smartReplace == SmartReplace::Yes)
 661         options.add(ReplaceSelectionCommand::SmartReplace);
 662     if (matchStyle == MatchStyle::Yes)
 663         options.add(ReplaceSelectionCommand::MatchStyle);
 664     if (mailBlockquoteHandling == MailBlockquoteHandling::IgnoreBlockquote)
 665         options.add(ReplaceSelectionCommand::IgnoreMailBlockquote);
 666 
 667     auto command = ReplaceSelectionCommand::create(document(), &amp;fragment, options, editingAction);
 668     command-&gt;apply();
 669     revealSelectionAfterEditingOperation();
 670 
 671     selection = m_frame.selection().selection();
 672     if (selection.isInPasswordField())
 673         return;
 674 
 675     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction == EditAction::Paste) {
 676         String text = AccessibilityObject::stringForVisiblePositionRange(command-&gt;visibleSelectionForInsertedText());
 677         replacedText.postTextStateChangeNotification(document().existingAXObjectCache(), AXTextEditTypePaste, text, m_frame.selection().selection());
 678         command-&gt;composition()-&gt;setRangeDeletedByUnapply(replacedText.replacedRange());
 679     }
 680 
 681     if (!isContinuousSpellCheckingEnabled())
 682         return;
 683 
 684     Node* nodeToCheck = selection.rootEditableElement();
 685     if (!nodeToCheck)
 686         return;
 687 
 688     auto rangeToCheck = Range::create(document(), firstPositionInNode(nodeToCheck), lastPositionInNode(nodeToCheck));
 689     if (auto request = SpellCheckRequest::create(resolveTextCheckingTypeMask(*nodeToCheck, { TextCheckingType::Spelling, TextCheckingType::Grammar }), TextCheckingProcessBatch, rangeToCheck.copyRef(), rangeToCheck.copyRef(), rangeToCheck.copyRef()))
 690         m_spellChecker-&gt;requestCheckingFor(request.releaseNonNull());
 691 }
 692 
 693 void Editor::replaceSelectionWithText(const String&amp; text, SelectReplacement selectReplacement, SmartReplace smartReplace, EditAction editingAction)
 694 {
 695     RefPtr&lt;Range&gt; range = selectedRange();
 696     if (!range)
 697         return;
 698 
 699     replaceSelectionWithFragment(createFragmentFromText(*range, text), selectReplacement, smartReplace, MatchStyle::Yes, editingAction);
 700 }
 701 
 702 RefPtr&lt;Range&gt; Editor::selectedRange()
 703 {
 704     return m_frame.selection().toNormalizedRange();
 705 }
 706 
 707 bool Editor::shouldDeleteRange(Range* range) const
 708 {
 709     if (!range || range-&gt;collapsed())
 710         return false;
 711 
 712     if (!canDeleteRange(range))
 713         return false;
 714 
 715     return client() &amp;&amp; client()-&gt;shouldDeleteRange(range);
 716 }
 717 
 718 bool Editor::tryDHTMLCopy()
 719 {
 720     if (m_frame.selection().selection().isInPasswordField())
 721         return false;
 722 
 723     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::Copy);
 724 }
 725 
 726 bool Editor::tryDHTMLCut()
 727 {
 728     if (m_frame.selection().selection().isInPasswordField())
 729         return false;
 730 
 731     return !dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::Cut);
 732 }
 733 
 734 bool Editor::shouldInsertText(const String&amp; text, Range* range, EditorInsertAction action) const
 735 {
 736     if (m_frame.mainFrame().loader().shouldSuppressTextInputFromEditing() &amp;&amp; action == EditorInsertAction::Typed)
 737         return false;
 738 
 739     return client() &amp;&amp; client()-&gt;shouldInsertText(text, range, action);
 740 }
 741 
 742 void Editor::respondToChangedContents(const VisibleSelection&amp; endingSelection)
 743 {
 744     if (AXObjectCache::accessibilityEnabled()) {
 745         Node* node = endingSelection.start().deprecatedNode();
 746         if (AXObjectCache* cache = document().existingAXObjectCache())
 747             cache-&gt;postNotification(node, AXObjectCache::AXValueChanged, TargetObservableParent);
 748     }
 749 
 750     updateMarkersForWordsAffectedByEditing(true);
 751 
 752     if (client())
 753         client()-&gt;respondToChangedContents();
 754 }
 755 
 756 bool Editor::hasBidiSelection() const
 757 {
 758     if (m_frame.selection().isNone())
 759         return false;
 760 
 761     Node* startNode;
 762     if (m_frame.selection().isRange()) {
 763         startNode = m_frame.selection().selection().start().downstream().deprecatedNode();
 764         Node* endNode = m_frame.selection().selection().end().upstream().deprecatedNode();
 765         if (enclosingBlock(startNode) != enclosingBlock(endNode))
 766             return false;
 767     } else
 768         startNode = m_frame.selection().selection().visibleStart().deepEquivalent().deprecatedNode();
 769 
 770     if (!startNode)
 771         return false;
 772 
 773     auto renderer = startNode-&gt;renderer();
 774     while (renderer &amp;&amp; !is&lt;RenderBlockFlow&gt;(*renderer))
 775         renderer = renderer-&gt;parent();
 776 
 777     if (!renderer)
 778         return false;
 779 
 780     if (!renderer-&gt;style().isLeftToRightDirection())
 781         return true;
 782 
 783     return downcast&lt;RenderBlockFlow&gt;(*renderer).containsNonZeroBidiLevel();
 784 }
 785 
 786 TriState Editor::selectionUnorderedListState() const
 787 {
 788     if (m_frame.selection().isCaret()) {
 789         if (enclosingElementWithTag(m_frame.selection().selection().start(), ulTag))
 790             return TrueTriState;
 791     } else if (m_frame.selection().isRange()) {
 792         auto* startNode = enclosingElementWithTag(m_frame.selection().selection().start(), ulTag);
 793         auto* endNode = enclosingElementWithTag(m_frame.selection().selection().end(), ulTag);
 794         if (startNode &amp;&amp; endNode &amp;&amp; startNode == endNode)
 795             return TrueTriState;
 796     }
 797 
 798     return FalseTriState;
 799 }
 800 
 801 TriState Editor::selectionOrderedListState() const
 802 {
 803     if (m_frame.selection().isCaret()) {
 804         if (enclosingElementWithTag(m_frame.selection().selection().start(), olTag))
 805             return TrueTriState;
 806     } else if (m_frame.selection().isRange()) {
 807         auto* startNode = enclosingElementWithTag(m_frame.selection().selection().start(), olTag);
 808         auto* endNode = enclosingElementWithTag(m_frame.selection().selection().end(), olTag);
 809         if (startNode &amp;&amp; endNode &amp;&amp; startNode == endNode)
 810             return TrueTriState;
 811     }
 812 
 813     return FalseTriState;
 814 }
 815 
 816 RefPtr&lt;Node&gt; Editor::insertOrderedList()
 817 {
 818     if (!canEditRichly())
 819         return nullptr;
 820 
 821     auto newList = InsertListCommand::insertList(document(), InsertListCommand::Type::OrderedList);
 822     revealSelectionAfterEditingOperation();
 823     return newList;
 824 }
 825 
 826 RefPtr&lt;Node&gt; Editor::insertUnorderedList()
 827 {
 828     if (!canEditRichly())
 829         return nullptr;
 830 
 831     auto newList = InsertListCommand::insertList(document(), InsertListCommand::Type::UnorderedList);
 832     revealSelectionAfterEditingOperation();
 833     return newList;
 834 }
 835 
 836 bool Editor::canIncreaseSelectionListLevel()
 837 {
 838     return canEditRichly() &amp;&amp; IncreaseSelectionListLevelCommand::canIncreaseSelectionListLevel(&amp;document());
 839 }
 840 
 841 bool Editor::canDecreaseSelectionListLevel()
 842 {
 843     return canEditRichly() &amp;&amp; DecreaseSelectionListLevelCommand::canDecreaseSelectionListLevel(&amp;document());
 844 }
 845 
 846 RefPtr&lt;Node&gt; Editor::increaseSelectionListLevel()
 847 {
 848     if (!canEditRichly() || m_frame.selection().isNone())
 849         return nullptr;
 850 
 851     RefPtr&lt;Node&gt; newList = IncreaseSelectionListLevelCommand::increaseSelectionListLevel(&amp;document());
 852     revealSelectionAfterEditingOperation();
 853     return newList;
 854 }
 855 
 856 RefPtr&lt;Node&gt; Editor::increaseSelectionListLevelOrdered()
 857 {
 858     if (!canEditRichly() || m_frame.selection().isNone())
 859         return nullptr;
 860 
 861     RefPtr&lt;Node&gt; newList = IncreaseSelectionListLevelCommand::increaseSelectionListLevelOrdered(&amp;document());
 862     revealSelectionAfterEditingOperation();
 863     return newList;
 864 }
 865 
 866 RefPtr&lt;Node&gt; Editor::increaseSelectionListLevelUnordered()
 867 {
 868     if (!canEditRichly() || m_frame.selection().isNone())
 869         return nullptr;
 870 
 871     RefPtr&lt;Node&gt; newList = IncreaseSelectionListLevelCommand::increaseSelectionListLevelUnordered(&amp;document());
 872     revealSelectionAfterEditingOperation();
 873     return newList;
 874 }
 875 
 876 void Editor::decreaseSelectionListLevel()
 877 {
 878     if (!canEditRichly() || m_frame.selection().isNone())
 879         return;
 880 
 881     DecreaseSelectionListLevelCommand::decreaseSelectionListLevel(&amp;document());
 882     revealSelectionAfterEditingOperation();
 883 }
 884 
 885 void Editor::removeFormattingAndStyle()
 886 {
 887     RemoveFormatCommand::create(document())-&gt;apply();
 888 }
 889 
 890 void Editor::clearLastEditCommand()
 891 {
 892     m_lastEditCommand = nullptr;
 893 }
 894 
 895 Element* Editor::findEventTargetFrom(const VisibleSelection&amp; selection) const
 896 {
 897     Element* target = selection.start().element();
 898     if (!target)
 899         target = document().bodyOrFrameset();
 900     if (!target)
 901         return nullptr;
 902 
 903     return target;
 904 }
 905 
 906 Element* Editor::findEventTargetFromSelection() const
 907 {
 908     return findEventTargetFrom(m_frame.selection().selection());
 909 }
 910 
 911 void Editor::applyStyle(StyleProperties* style, EditAction editingAction)
 912 {
 913     if (style)
 914         applyStyle(EditingStyle::create(style), editingAction, ColorFilterMode::UseOriginalColor);
 915 }
 916 
 917 void Editor::applyStyle(RefPtr&lt;EditingStyle&gt;&amp;&amp; style, EditAction editingAction, ColorFilterMode colorFilterMode)
 918 {
 919     if (!style)
 920         return;
 921 
 922     auto selectionType = m_frame.selection().selection().selectionType();
 923     if (selectionType == VisibleSelection::NoSelection)
 924         return;
 925 
 926     String inputTypeName = inputTypeNameForEditingAction(editingAction);
 927     String inputEventData = inputEventDataForEditingStyleAndAction(*style, editingAction);
 928     RefPtr&lt;Element&gt; element = m_frame.selection().selection().rootEditableElement();
 929     if (element &amp;&amp; !dispatchBeforeInputEvent(*element, inputTypeName, inputEventData))
 930         return;
 931 
 932     Ref&lt;EditingStyle&gt; styleToApply = colorFilterMode == ColorFilterMode::InvertColor ? style-&gt;inverseTransformColorIfNeeded(*element) : style.releaseNonNull();
 933 
 934     switch (selectionType) {
 935     case VisibleSelection::CaretSelection:
 936         computeAndSetTypingStyle(styleToApply.get(), editingAction);
 937         break;
 938     case VisibleSelection::RangeSelection:
 939         ApplyStyleCommand::create(document(), styleToApply.ptr(), editingAction)-&gt;apply();
 940         break;
 941     default:
 942         break;
 943     }
 944 
 945     client()-&gt;didApplyStyle();
 946     if (element)
 947         dispatchInputEvent(*element, inputTypeName, inputEventData);
 948 }
 949 
 950 bool Editor::shouldApplyStyle(StyleProperties* style, Range* range)
 951 {
 952     return client()-&gt;shouldApplyStyle(style, range);
 953 }
 954 
 955 void Editor::applyParagraphStyle(StyleProperties* style, EditAction editingAction)
 956 {
 957     if (!style)
 958         return;
 959 
 960     auto selectionType = m_frame.selection().selection().selectionType();
 961     if (selectionType == VisibleSelection::NoSelection)
 962         return;
 963 
 964     String inputTypeName = inputTypeNameForEditingAction(editingAction);
 965     String inputEventData = inputEventDataForEditingStyleAndAction(style, editingAction);
 966     RefPtr&lt;Element&gt; element = m_frame.selection().selection().rootEditableElement();
 967     if (element &amp;&amp; !dispatchBeforeInputEvent(*element, inputTypeName, inputEventData))
 968         return;
 969 
 970     ApplyStyleCommand::create(document(), EditingStyle::create(style).ptr(), editingAction, ApplyStyleCommand::ForceBlockProperties)-&gt;apply();
 971     client()-&gt;didApplyStyle();
 972     if (element)
 973         dispatchInputEvent(*element, inputTypeName, inputEventData);
 974 }
 975 
 976 void Editor::applyStyleToSelection(StyleProperties* style, EditAction editingAction)
 977 {
 978     if (!style || style-&gt;isEmpty() || !canEditRichly())
 979         return;
 980 
 981     if (!client() || !client()-&gt;shouldApplyStyle(style, m_frame.selection().toNormalizedRange().get()))
 982         return;
 983     applyStyle(style, editingAction);
 984 }
 985 
 986 void Editor::applyStyleToSelection(Ref&lt;EditingStyle&gt;&amp;&amp; style, EditAction editingAction, ColorFilterMode colorFilterMode)
 987 {
 988     if (style-&gt;isEmpty() || !canEditRichly())
 989         return;
 990 
 991     // FIXME: This is wrong for text decorations since m_mutableStyle is empty.
 992     if (!client() || !client()-&gt;shouldApplyStyle(style-&gt;styleWithResolvedTextDecorations().ptr(), m_frame.selection().toNormalizedRange().get()))
 993         return;
 994 
 995     applyStyle(WTFMove(style), editingAction, colorFilterMode);
 996 }
 997 
 998 void Editor::applyParagraphStyleToSelection(StyleProperties* style, EditAction editingAction)
 999 {
1000     if (!style || style-&gt;isEmpty() || !canEditRichly())
1001         return;
1002 
1003     if (client() &amp;&amp; client()-&gt;shouldApplyStyle(style, m_frame.selection().toNormalizedRange().get()))
1004         applyParagraphStyle(style, editingAction);
1005 }
1006 
1007 bool Editor::selectionStartHasStyle(CSSPropertyID propertyID, const String&amp; value) const
1008 {
1009     if (auto editingStyle = EditingStyle::styleAtSelectionStart(m_frame.selection().selection(), propertyID == CSSPropertyBackgroundColor))
1010         return editingStyle-&gt;hasStyle(propertyID, value);
1011     return false;
1012 }
1013 
1014 TriState Editor::selectionHasStyle(CSSPropertyID propertyID, const String&amp; value) const
1015 {
1016     return EditingStyle::create(propertyID, value)-&gt;triStateOfStyle(m_frame.selection().selection());
1017 }
1018 
1019 String Editor::selectionStartCSSPropertyValue(CSSPropertyID propertyID)
1020 {
1021     RefPtr&lt;EditingStyle&gt; selectionStyle = EditingStyle::styleAtSelectionStart(m_frame.selection().selection(),
1022         propertyID == CSSPropertyBackgroundColor);
1023     if (!selectionStyle || !selectionStyle-&gt;style())
1024         return String();
1025 
1026     if (propertyID == CSSPropertyFontSize)
1027         return String::number(selectionStyle-&gt;legacyFontSize(document()));
1028     return selectionStyle-&gt;style()-&gt;getPropertyValue(propertyID);
1029 }
1030 
1031 void Editor::indent()
1032 {
1033     IndentOutdentCommand::create(document(), IndentOutdentCommand::Indent)-&gt;apply();
1034 }
1035 
1036 void Editor::outdent()
1037 {
1038     IndentOutdentCommand::create(document(), IndentOutdentCommand::Outdent)-&gt;apply();
1039 }
1040 
1041 static void notifyTextFromControls(Element* startRoot, Element* endRoot)
1042 {
1043     HTMLTextFormControlElement* startingTextControl = enclosingTextFormControl(firstPositionInOrBeforeNode(startRoot));
1044     HTMLTextFormControlElement* endingTextControl = enclosingTextFormControl(firstPositionInOrBeforeNode(endRoot));
1045     if (startingTextControl)
1046         startingTextControl-&gt;didEditInnerTextValue();
1047     if (endingTextControl &amp;&amp; startingTextControl != endingTextControl)
1048         endingTextControl-&gt;didEditInnerTextValue();
1049 }
1050 
<a name="13" id="anc13"></a><span class="line-modified">1051 static bool dispatchBeforeInputEvents(RefPtr&lt;Element&gt; startRoot, RefPtr&lt;Element&gt; endRoot, const AtomicString&amp; inputTypeName, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { }, Event::IsCancelable cancelable = Event::IsCancelable::Yes)</span>
1052 {
1053     bool continueWithDefaultBehavior = true;
1054     if (startRoot)
1055         continueWithDefaultBehavior &amp;= dispatchBeforeInputEvent(*startRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges, cancelable);
1056     if (endRoot &amp;&amp; endRoot != startRoot)
1057         continueWithDefaultBehavior &amp;= dispatchBeforeInputEvent(*endRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges, cancelable);
1058     return continueWithDefaultBehavior;
1059 }
1060 
<a name="14" id="anc14"></a><span class="line-modified">1061 static void dispatchInputEvents(RefPtr&lt;Element&gt; startRoot, RefPtr&lt;Element&gt; endRoot, const AtomicString&amp; inputTypeName, const String&amp; data = { }, RefPtr&lt;DataTransfer&gt;&amp;&amp; dataTransfer = nullptr, const Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp; targetRanges = { })</span>
1062 {
1063     if (startRoot)
1064         dispatchInputEvent(*startRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges);
1065     if (endRoot &amp;&amp; endRoot != startRoot)
1066         dispatchInputEvent(*endRoot, inputTypeName, data, WTFMove(dataTransfer), targetRanges);
1067 }
1068 
1069 bool Editor::willApplyEditing(CompositeEditCommand&amp; command, Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp;&amp; targetRanges) const
1070 {
1071     if (!command.shouldDispatchInputEvents())
1072         return true;
1073 
1074     auto* composition = command.composition();
1075     if (!composition)
1076         return true;
1077 
1078     return dispatchBeforeInputEvents(composition-&gt;startingRootEditableElement(), composition-&gt;endingRootEditableElement(), command.inputEventTypeName(),
1079         command.inputEventData(), command.inputEventDataTransfer(), targetRanges, command.isBeforeInputEventCancelable() ? Event::IsCancelable::Yes : Event::IsCancelable::No);
1080 }
1081 
1082 void Editor::appliedEditing(CompositeEditCommand&amp; command)
1083 {
1084     LOG(Editing, &quot;Editor %p appliedEditing&quot;, this);
1085 
1086     document().updateLayout();
1087 
1088     ASSERT(command.composition());
1089     auto&amp; composition = *command.composition();
1090     VisibleSelection newSelection(command.endingSelection());
1091 
1092     notifyTextFromControls(composition.startingRootEditableElement(), composition.endingRootEditableElement());
1093 
1094     if (command.isTopLevelCommand()) {
1095         // Don&#39;t clear the typing style with this selection change. We do those things elsewhere if necessary.
1096         OptionSet&lt;FrameSelection::SetSelectionOption&gt; options;
1097         if (command.isDictationCommand())
1098             options.add(FrameSelection::DictationTriggered);
1099 
1100         changeSelectionAfterCommand(newSelection, options);
1101     }
1102 
1103     if (command.shouldDispatchInputEvents())
1104         dispatchInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), command.inputEventTypeName(), command.inputEventData(), command.inputEventDataTransfer());
1105 
1106     if (command.isTopLevelCommand()) {
1107         updateEditorUINowIfScheduled();
1108 
1109         m_alternativeTextController-&gt;respondToAppliedEditing(&amp;command);
1110 
1111         if (!command.preservesTypingStyle())
1112             m_frame.selection().clearTypingStyle();
1113 
1114         // Command will be equal to last edit command only in the case of typing
1115         if (m_lastEditCommand.get() == &amp;command)
1116             ASSERT(command.isTypingCommand());
1117         else {
1118             // Only register a new undo command if the command passed in is
1119             // different from the last command
1120             m_lastEditCommand = &amp;command;
1121             if (client())
1122                 client()-&gt;registerUndoStep(m_lastEditCommand-&gt;ensureComposition());
1123         }
1124         respondToChangedContents(newSelection);
1125     }
1126 }
1127 
1128 bool Editor::willUnapplyEditing(const EditCommandComposition&amp; composition) const
1129 {
1130     return dispatchBeforeInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), &quot;historyUndo&quot;);
1131 }
1132 
1133 void Editor::unappliedEditing(EditCommandComposition&amp; composition)
1134 {
1135     document().updateLayout();
1136 
1137     notifyTextFromControls(composition.startingRootEditableElement(), composition.endingRootEditableElement());
1138 
1139     VisibleSelection newSelection(composition.startingSelection());
1140     changeSelectionAfterCommand(newSelection, FrameSelection::defaultSetSelectionOptions());
1141     dispatchInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), &quot;historyUndo&quot;);
1142 
1143     updateEditorUINowIfScheduled();
1144 
1145     m_alternativeTextController-&gt;respondToUnappliedEditing(&amp;composition);
1146 
1147     m_lastEditCommand = nullptr;
1148     if (auto* client = this-&gt;client())
1149         client-&gt;registerRedoStep(composition);
1150     respondToChangedContents(newSelection);
1151 }
1152 
1153 bool Editor::willReapplyEditing(const EditCommandComposition&amp; composition) const
1154 {
1155     return dispatchBeforeInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), &quot;historyRedo&quot;);
1156 }
1157 
1158 void Editor::reappliedEditing(EditCommandComposition&amp; composition)
1159 {
1160     document().updateLayout();
1161 
1162     notifyTextFromControls(composition.startingRootEditableElement(), composition.endingRootEditableElement());
1163 
1164     VisibleSelection newSelection(composition.endingSelection());
1165     changeSelectionAfterCommand(newSelection, FrameSelection::defaultSetSelectionOptions());
1166     dispatchInputEvents(composition.startingRootEditableElement(), composition.endingRootEditableElement(), &quot;historyRedo&quot;);
1167 
1168     updateEditorUINowIfScheduled();
1169 
1170     m_lastEditCommand = nullptr;
1171     if (auto* client = this-&gt;client())
1172         client-&gt;registerUndoStep(composition);
1173     respondToChangedContents(newSelection);
1174 }
1175 
1176 Editor::Editor(Frame&amp; frame)
1177     : m_frame(frame)
<a name="15" id="anc15"></a><span class="line-modified">1178     , m_killRing(std::make_unique&lt;PAL::KillRing&gt;())</span>
<span class="line-modified">1179     , m_spellChecker(std::make_unique&lt;SpellChecker&gt;(frame))</span>
<span class="line-modified">1180     , m_alternativeTextController(std::make_unique&lt;AlternativeTextController&gt;(frame))</span>
1181     , m_editorUIUpdateTimer(*this, &amp;Editor::editorUIUpdateTimerFired)
1182 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
1183     , m_telephoneNumberDetectionUpdateTimer(*this, &amp;Editor::scanSelectionForTelephoneNumbers)
1184 #endif
1185 {
1186 }
1187 
1188 Editor::~Editor() = default;
1189 
1190 void Editor::clear()
1191 {
1192     m_lastEditCommand = nullptr;
1193     if (m_compositionNode) {
1194         m_compositionNode = nullptr;
1195         if (EditorClient* client = this-&gt;client())
1196             client-&gt;discardedComposition(&amp;m_frame);
1197     }
1198     m_customCompositionUnderlines.clear();
1199     m_shouldStyleWithCSS = false;
1200     m_defaultParagraphSeparator = EditorParagraphSeparatorIsDiv;
1201     m_mark = { };
1202     m_oldSelectionForEditorUIUpdate = { };
1203     m_editorUIUpdateTimer.stop();
1204 
1205 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
1206     m_telephoneNumberDetectionUpdateTimer.stop();
1207     m_detectedTelephoneNumberRanges.clear();
1208 #endif
1209 }
1210 
1211 bool Editor::insertText(const String&amp; text, Event* triggeringEvent, TextEventInputType inputType)
1212 {
1213     return m_frame.eventHandler().handleTextInputEvent(text, triggeringEvent, inputType);
1214 }
1215 
1216 bool Editor::insertTextForConfirmedComposition(const String&amp; text)
1217 {
1218     return m_frame.eventHandler().handleTextInputEvent(text, 0, TextEventInputComposition);
1219 }
1220 
1221 bool Editor::insertDictatedText(const String&amp; text, const Vector&lt;DictationAlternative&gt;&amp; dictationAlternatives, Event* triggeringEvent)
1222 {
1223     return m_alternativeTextController-&gt;insertDictatedText(text, dictationAlternatives, triggeringEvent);
1224 }
1225 
1226 bool Editor::insertTextWithoutSendingTextEvent(const String&amp; text, bool selectInsertedText, TextEvent* triggeringEvent)
1227 {
1228     if (text.isEmpty())
1229         return false;
1230 
1231     VisibleSelection selection = selectionForCommand(triggeringEvent);
1232     if (!selection.isContentEditable())
1233         return false;
1234     RefPtr&lt;Range&gt; range = selection.toNormalizedRange();
1235 
1236     if (!shouldInsertText(text, range.get(), EditorInsertAction::Typed))
1237         return true;
1238 
1239     updateMarkersForWordsAffectedByEditing(isSpaceOrNewline(text[0]));
1240 
1241     bool shouldConsiderApplyingAutocorrection = false;
1242     if (text == &quot; &quot; || text == &quot;\t&quot;)
1243         shouldConsiderApplyingAutocorrection = true;
1244 
1245     if (text.length() == 1 &amp;&amp; u_ispunct(text[0]) &amp;&amp; !isAmbiguousBoundaryCharacter(text[0]))
1246         shouldConsiderApplyingAutocorrection = true;
1247 
1248     bool autocorrectionWasApplied = shouldConsiderApplyingAutocorrection &amp;&amp; m_alternativeTextController-&gt;applyAutocorrectionBeforeTypingIfAppropriate();
1249 
1250     // Get the selection to use for the event that triggered this insertText.
1251     // If the event handler changed the selection, we may want to use a different selection
1252     // that is contained in the event target.
1253     selection = selectionForCommand(triggeringEvent);
1254     if (selection.isContentEditable()) {
1255         if (Node* selectionStart = selection.start().deprecatedNode()) {
1256             Ref&lt;Document&gt; document(selectionStart-&gt;document());
1257 
1258             // Insert the text
1259             if (triggeringEvent &amp;&amp; triggeringEvent-&gt;isDictation())
1260                 DictationCommand::insertText(document, text, triggeringEvent-&gt;dictationAlternatives(), selection);
1261             else {
1262                 TypingCommand::Options options = 0;
1263                 if (selectInsertedText)
1264                     options |= TypingCommand::SelectInsertedText;
1265                 if (autocorrectionWasApplied)
1266                     options |= TypingCommand::RetainAutocorrectionIndicator;
1267                 if (triggeringEvent &amp;&amp; triggeringEvent-&gt;isAutocompletion())
1268                     options |= TypingCommand::IsAutocompletion;
1269                 TypingCommand::insertText(document, text, selection, options, triggeringEvent &amp;&amp; triggeringEvent-&gt;isComposition() ? TypingCommand::TextCompositionFinal : TypingCommand::TextCompositionNone);
1270             }
1271 
1272             // Reveal the current selection
1273             if (Frame* editedFrame = document-&gt;frame())
1274                 if (Page* page = editedFrame-&gt;page()) {
<a name="16" id="anc16"></a><span class="line-removed">1275 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">1276                     SelectionRevealMode revealMode = SelectionRevealMode::RevealUpToMainFrame;</span>
<span class="line-removed">1277 #else</span>
1278                     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;
<a name="17" id="anc17"></a><span class="line-removed">1279 #endif</span>
1280                     page-&gt;focusController().focusedOrMainFrame().selection().revealSelection(revealMode, ScrollAlignment::alignCenterIfNeeded);
1281                 }
1282         }
1283     }
1284 
1285     return true;
1286 }
1287 
1288 bool Editor::insertLineBreak()
1289 {
1290     if (!canEdit())
1291         return false;
1292 
1293     if (!shouldInsertText(&quot;\n&quot;, m_frame.selection().toNormalizedRange().get(), EditorInsertAction::Typed))
1294         return true;
1295 
1296     VisiblePosition caret = m_frame.selection().selection().visibleStart();
1297     bool alignToEdge = isEndOfEditableOrNonEditableContent(caret);
1298     bool autocorrectionIsApplied = m_alternativeTextController-&gt;applyAutocorrectionBeforeTypingIfAppropriate();
1299     TypingCommand::insertLineBreak(document(), autocorrectionIsApplied ? TypingCommand::RetainAutocorrectionIndicator : 0);
1300     revealSelectionAfterEditingOperation(alignToEdge ? ScrollAlignment::alignToEdgeIfNeeded : ScrollAlignment::alignCenterIfNeeded);
1301 
1302     return true;
1303 }
1304 
1305 bool Editor::insertParagraphSeparator()
1306 {
1307     if (!canEdit())
1308         return false;
1309 
1310     if (!canEditRichly())
1311         return insertLineBreak();
1312 
1313     if (!shouldInsertText(&quot;\n&quot;, m_frame.selection().toNormalizedRange().get(), EditorInsertAction::Typed))
1314         return true;
1315 
1316     VisiblePosition caret = m_frame.selection().selection().visibleStart();
1317     bool alignToEdge = isEndOfEditableOrNonEditableContent(caret);
1318     bool autocorrectionIsApplied = m_alternativeTextController-&gt;applyAutocorrectionBeforeTypingIfAppropriate();
1319     TypingCommand::insertParagraphSeparator(document(), autocorrectionIsApplied ? TypingCommand::RetainAutocorrectionIndicator : 0);
1320     revealSelectionAfterEditingOperation(alignToEdge ? ScrollAlignment::alignToEdgeIfNeeded : ScrollAlignment::alignCenterIfNeeded);
1321 
1322     return true;
1323 }
1324 
1325 bool Editor::insertParagraphSeparatorInQuotedContent()
1326 {
1327     // FIXME: Why is this missing calls to canEdit, canEditRichly, etc.?
1328     TypingCommand::insertParagraphSeparatorInQuotedContent(document());
1329     revealSelectionAfterEditingOperation();
1330     return true;
1331 }
1332 
1333 void Editor::cut()
1334 {
1335     if (tryDHTMLCut())
1336         return; // DHTML did the whole operation
1337     if (!canCut()) {
1338         PAL::systemBeep();
1339         return;
1340     }
1341 
1342     performCutOrCopy(CutAction);
1343 }
1344 
1345 void Editor::copy()
1346 {
1347     if (tryDHTMLCopy())
1348         return; // DHTML did the whole operation
1349     if (!canCopy()) {
1350         PAL::systemBeep();
1351         return;
1352     }
1353 
1354     performCutOrCopy(CopyAction);
1355 }
1356 
1357 void Editor::postTextStateChangeNotificationForCut(const String&amp; text, const VisibleSelection&amp; selection)
1358 {
1359     if (!AXObjectCache::accessibilityEnabled())
1360         return;
1361     if (!text.length())
1362         return;
1363     AXObjectCache* cache = document().existingAXObjectCache();
1364     if (!cache)
1365         return;
1366     cache-&gt;postTextStateChangeNotification(selection.start().anchorNode(), AXTextEditTypeCut, text, selection.start());
1367 }
1368 
1369 void Editor::performCutOrCopy(EditorActionSpecifier action)
1370 {
1371     RefPtr&lt;Range&gt; selection = selectedRange();
1372     willWriteSelectionToPasteboard(selection.get());
1373     if (action == CutAction) {
1374         if (!shouldDeleteRange(selection.get()))
1375             return;
1376 
1377         updateMarkersForWordsAffectedByEditing(true);
1378     }
1379 
1380     if (enclosingTextFormControl(m_frame.selection().selection().start()))
1381         Pasteboard::createForCopyAndPaste()-&gt;writePlainText(selectedTextForDataTransfer(), canSmartCopyOrDelete() ? Pasteboard::CanSmartReplace : Pasteboard::CannotSmartReplace);
1382     else {
1383         HTMLImageElement* imageElement = nullptr;
1384         if (action == CopyAction)
1385             imageElement = imageElementFromImageDocument(document());
1386 
1387         if (imageElement) {
1388 #if !PLATFORM(WIN)
1389             writeImageToPasteboard(*Pasteboard::createForCopyAndPaste(), *imageElement, document().url(), document().title());
1390 #else
1391             // FIXME: Delete after &lt;http://webkit.org/b/177618&gt; lands.
1392             Pasteboard::createForCopyAndPaste()-&gt;writeImage(*imageElement, document().url(), document().title());
1393 #endif
1394         } else {
1395 #if !PLATFORM(WIN)
1396             writeSelectionToPasteboard(*Pasteboard::createForCopyAndPaste());
1397 #else
1398             // FIXME: Delete after &lt;http://webkit.org/b/177618&gt; lands.
1399             Pasteboard::createForCopyAndPaste()-&gt;writeSelection(*selection, canSmartCopyOrDelete(), m_frame, IncludeImageAltTextForDataTransfer);
1400 #endif
1401         }
1402     }
1403 
1404     didWriteSelectionToPasteboard();
1405     if (action == CutAction) {
1406         String text;
1407         if (AXObjectCache::accessibilityEnabled())
1408             text = AccessibilityObject::stringForVisiblePositionRange(m_frame.selection().selection());
1409         deleteSelectionWithSmartDelete(canSmartCopyOrDelete(), EditAction::Cut);
1410         if (AXObjectCache::accessibilityEnabled())
1411             postTextStateChangeNotificationForCut(text, m_frame.selection().selection());
1412     }
1413 }
1414 
1415 void Editor::paste()
1416 {
1417     paste(*Pasteboard::createForCopyAndPaste());
1418 }
1419 
1420 void Editor::paste(Pasteboard&amp; pasteboard)
1421 {
1422     if (!dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::Paste))
1423         return; // DHTML did the whole operation
1424     if (!canPaste())
1425         return;
1426     updateMarkersForWordsAffectedByEditing(false);
1427     ResourceCacheValidationSuppressor validationSuppressor(document().cachedResourceLoader());
1428     if (m_frame.selection().selection().isContentRichlyEditable())
1429         pasteWithPasteboard(&amp;pasteboard, { PasteOption::AllowPlainText });
1430     else
1431         pasteAsPlainTextWithPasteboard(pasteboard);
1432 }
1433 
1434 void Editor::pasteAsPlainText()
1435 {
1436     if (!dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::PasteAsPlainText))
1437         return;
1438     if (!canPaste())
1439         return;
1440     updateMarkersForWordsAffectedByEditing(false);
1441     pasteAsPlainTextWithPasteboard(*Pasteboard::createForCopyAndPaste());
1442 }
1443 
1444 void Editor::pasteAsQuotation()
1445 {
1446     if (!dispatchClipboardEvent(findEventTargetFromSelection(), ClipboardEventKind::PasteAsQuotation))
1447         return;
1448     if (!canPaste())
1449         return;
1450     updateMarkersForWordsAffectedByEditing(false);
1451     ResourceCacheValidationSuppressor validationSuppressor(document().cachedResourceLoader());
1452     auto pasteboard = Pasteboard::createForCopyAndPaste();
1453     if (m_frame.selection().selection().isContentRichlyEditable())
1454         pasteWithPasteboard(pasteboard.get(), { PasteOption::AllowPlainText, PasteOption::AsQuotation });
1455     else
1456         pasteAsPlainTextWithPasteboard(*pasteboard);
1457 }
1458 
1459 void Editor::quoteFragmentForPasting(DocumentFragment&amp; fragment)
1460 {
1461     auto blockQuote = HTMLQuoteElement::create(blockquoteTag, document());
<a name="18" id="anc18"></a><span class="line-modified">1462     blockQuote-&gt;setAttributeWithoutSynchronization(typeAttr, AtomicString(&quot;cite&quot;));</span>
<span class="line-modified">1463     blockQuote-&gt;setAttributeWithoutSynchronization(classAttr, AtomicString(ApplePasteAsQuotation));</span>
1464 
1465     auto childNode = fragment.firstChild();
1466 
1467     if (childNode) {
1468         while (childNode) {
1469             blockQuote-&gt;appendChild(*childNode);
1470             childNode = fragment.firstChild();
1471         }
1472     } else
1473         blockQuote-&gt;appendChild(HTMLBRElement::create(document()));
1474 
1475     fragment.appendChild(blockQuote);
1476 }
1477 
1478 void Editor::performDelete()
1479 {
1480     if (!canDelete()) {
1481         PAL::systemBeep();
1482         return;
1483     }
1484 
1485     addRangeToKillRing(*selectedRange().get(), KillRingInsertionMode::AppendText);
1486     deleteSelectionWithSmartDelete(canSmartCopyOrDelete());
1487 
1488     // clear the &quot;start new kill ring sequence&quot; setting, because it was set to true
1489     // when the selection was updated by deleting the range
1490     setStartNewKillRingSequence(false);
1491 }
1492 
1493 void Editor::changeSelectionListType()
1494 {
1495     if (auto type = ChangeListTypeCommand::listConversionType(document()))
1496         ChangeListTypeCommand::create(document(), *type)-&gt;apply();
1497 }
1498 
1499 void Editor::simplifyMarkup(Node* startNode, Node* endNode)
1500 {
1501     if (!startNode)
1502         return;
1503     if (endNode) {
1504         if (&amp;startNode-&gt;document() != &amp;endNode-&gt;document())
1505             return;
1506         // check if start node is before endNode
1507         Node* node = startNode;
1508         while (node &amp;&amp; node != endNode)
1509             node = NodeTraversal::next(*node);
1510         if (!node)
1511             return;
1512     }
1513 
1514     SimplifyMarkupCommand::create(document(), startNode, endNode ? NodeTraversal::next(*endNode) : nullptr)-&gt;apply();
1515 }
1516 
1517 void Editor::copyURL(const URL&amp; url, const String&amp; title)
1518 {
1519     copyURL(url, title, *Pasteboard::createForCopyAndPaste());
1520 }
1521 
1522 void Editor::copyURL(const URL&amp; url, const String&amp; title, Pasteboard&amp; pasteboard)
1523 {
1524     PasteboardURL pasteboardURL;
1525     pasteboardURL.url = url;
1526     pasteboardURL.title = title;
1527 
1528 #if PLATFORM(MAC)
1529     pasteboardURL.userVisibleForm = userVisibleString(url);
1530 #endif
1531 
1532     pasteboard.write(pasteboardURL);
1533 }
1534 
1535 PasteboardWriterData::URLData Editor::pasteboardWriterURL(const URL&amp; url, const String&amp; title)
1536 {
1537     PasteboardWriterData::URLData result;
1538 
1539     result.url = url;
1540     result.title = title;
1541 #if PLATFORM(MAC)
1542     result.userVisibleForm = userVisibleString(url);
1543 #endif
1544 
1545     return result;
1546 }
1547 
1548 #if !PLATFORM(IOS_FAMILY)
1549 
1550 void Editor::copyImage(const HitTestResult&amp; result)
1551 {
1552     Element* element = result.innerNonSharedElement();
1553     if (!element)
1554         return;
1555 
1556     URL url = result.absoluteLinkURL();
1557     if (url.isEmpty())
1558         url = result.absoluteImageURL();
1559 
1560 #if !PLATFORM(WIN)
1561     writeImageToPasteboard(*Pasteboard::createForCopyAndPaste(), *element, url, result.altDisplayString());
1562 #else
1563     // FIXME: Delete after &lt;http://webkit.org/b/177618&gt; lands.
1564     Pasteboard::createForCopyAndPaste()-&gt;writeImage(*element, url, result.altDisplayString());
1565 #endif
1566 }
1567 
1568 #endif
1569 
1570 bool Editor::isContinuousSpellCheckingEnabled() const
1571 {
1572     return client() &amp;&amp; client()-&gt;isContinuousSpellCheckingEnabled();
1573 }
1574 
1575 void Editor::toggleContinuousSpellChecking()
1576 {
1577     if (client())
1578         client()-&gt;toggleContinuousSpellChecking();
1579 }
1580 
1581 bool Editor::isGrammarCheckingEnabled()
1582 {
1583     return client() &amp;&amp; client()-&gt;isGrammarCheckingEnabled();
1584 }
1585 
1586 void Editor::toggleGrammarChecking()
1587 {
1588     if (client())
1589         client()-&gt;toggleGrammarChecking();
1590 }
1591 
1592 int Editor::spellCheckerDocumentTag()
1593 {
1594     return client() ? client()-&gt;spellCheckerDocumentTag() : 0;
1595 }
1596 
1597 #if USE(APPKIT)
1598 
1599 void Editor::uppercaseWord()
1600 {
1601     if (client())
1602         client()-&gt;uppercaseWord();
1603 }
1604 
1605 void Editor::lowercaseWord()
1606 {
1607     if (client())
1608         client()-&gt;lowercaseWord();
1609 }
1610 
1611 void Editor::capitalizeWord()
1612 {
1613     if (client())
1614         client()-&gt;capitalizeWord();
1615 }
1616 
1617 #endif
1618 
1619 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
1620 
1621 void Editor::showSubstitutionsPanel()
1622 {
1623     if (!client()) {
1624         LOG_ERROR(&quot;No NSSpellChecker&quot;);
1625         return;
1626     }
1627 
1628     if (client()-&gt;substitutionsPanelIsShowing()) {
1629         client()-&gt;showSubstitutionsPanel(false);
1630         return;
1631     }
1632     client()-&gt;showSubstitutionsPanel(true);
1633 }
1634 
1635 bool Editor::substitutionsPanelIsShowing()
1636 {
1637     if (!client())
1638         return false;
1639     return client()-&gt;substitutionsPanelIsShowing();
1640 }
1641 
1642 void Editor::toggleSmartInsertDelete()
1643 {
1644     if (client())
1645         client()-&gt;toggleSmartInsertDelete();
1646 }
1647 
1648 bool Editor::isAutomaticQuoteSubstitutionEnabled()
1649 {
1650     return client() &amp;&amp; client()-&gt;isAutomaticQuoteSubstitutionEnabled();
1651 }
1652 
1653 void Editor::toggleAutomaticQuoteSubstitution()
1654 {
1655     if (client())
1656         client()-&gt;toggleAutomaticQuoteSubstitution();
1657 }
1658 
1659 bool Editor::isAutomaticLinkDetectionEnabled()
1660 {
1661     return client() &amp;&amp; client()-&gt;isAutomaticLinkDetectionEnabled();
1662 }
1663 
1664 void Editor::toggleAutomaticLinkDetection()
1665 {
1666     if (client())
1667         client()-&gt;toggleAutomaticLinkDetection();
1668 }
1669 
1670 bool Editor::isAutomaticDashSubstitutionEnabled()
1671 {
1672     return client() &amp;&amp; client()-&gt;isAutomaticDashSubstitutionEnabled();
1673 }
1674 
1675 void Editor::toggleAutomaticDashSubstitution()
1676 {
1677     if (client())
1678         client()-&gt;toggleAutomaticDashSubstitution();
1679 }
1680 
1681 bool Editor::isAutomaticTextReplacementEnabled()
1682 {
1683     return client() &amp;&amp; client()-&gt;isAutomaticTextReplacementEnabled();
1684 }
1685 
1686 void Editor::toggleAutomaticTextReplacement()
1687 {
1688     if (client())
1689         client()-&gt;toggleAutomaticTextReplacement();
1690 }
1691 
1692 bool Editor::isAutomaticSpellingCorrectionEnabled()
1693 {
1694     return m_alternativeTextController-&gt;isAutomaticSpellingCorrectionEnabled();
1695 }
1696 
1697 void Editor::toggleAutomaticSpellingCorrection()
1698 {
1699     if (client())
1700         client()-&gt;toggleAutomaticSpellingCorrection();
1701 }
1702 
1703 #endif
1704 
1705 bool Editor::shouldEndEditing(Range* range)
1706 {
1707     return client() &amp;&amp; client()-&gt;shouldEndEditing(range);
1708 }
1709 
1710 bool Editor::shouldBeginEditing(Range* range)
1711 {
1712     return client() &amp;&amp; client()-&gt;shouldBeginEditing(range);
1713 }
1714 
1715 void Editor::clearUndoRedoOperations()
1716 {
1717     if (client())
1718         client()-&gt;clearUndoRedoOperations();
1719 }
1720 
1721 bool Editor::canUndo() const
1722 {
1723     return client() &amp;&amp; client()-&gt;canUndo();
1724 }
1725 
1726 void Editor::undo()
1727 {
1728     if (client())
1729         client()-&gt;undo();
1730 }
1731 
1732 bool Editor::canRedo() const
1733 {
1734     return client() &amp;&amp; client()-&gt;canRedo();
1735 }
1736 
1737 void Editor::redo()
1738 {
1739     if (client())
1740         client()-&gt;redo();
1741 }
1742 
1743 void Editor::registerCustomUndoStep(Ref&lt;CustomUndoStep&gt;&amp;&amp; undoStep)
1744 {
1745     ASSERT(RuntimeEnabledFeatures::sharedFeatures().undoManagerAPIEnabled());
1746     if (auto* client = this-&gt;client())
1747         client-&gt;registerUndoStep(WTFMove(undoStep));
1748 }
1749 
1750 void Editor::didBeginEditing()
1751 {
1752     if (client())
1753         client()-&gt;didBeginEditing();
1754 }
1755 
1756 void Editor::didEndEditing()
1757 {
1758     if (client())
1759         client()-&gt;didEndEditing();
1760 }
1761 
1762 void Editor::willWriteSelectionToPasteboard(Range* range)
1763 {
1764     if (client())
1765         client()-&gt;willWriteSelectionToPasteboard(range);
1766 }
1767 
1768 void Editor::didWriteSelectionToPasteboard()
1769 {
1770     if (client())
1771         client()-&gt;didWriteSelectionToPasteboard();
1772 }
1773 
1774 void Editor::toggleBold()
1775 {
1776     command(&quot;ToggleBold&quot;).execute();
1777 }
1778 
1779 void Editor::toggleUnderline()
1780 {
1781     command(&quot;ToggleUnderline&quot;).execute();
1782 }
1783 
1784 void Editor::setBaseWritingDirection(WritingDirection direction)
1785 {
1786 #if PLATFORM(IOS_FAMILY)
1787     if (inSameParagraph(m_frame.selection().selection().visibleStart(), m_frame.selection().selection().visibleEnd()) &amp;&amp;
1788         baseWritingDirectionForSelectionStart() == direction)
1789         return;
1790 #endif
1791 
1792     Element* focusedElement = document().focusedElement();
1793     if (focusedElement &amp;&amp; focusedElement-&gt;isTextField()) {
1794         if (direction == WritingDirection::Natural)
1795             return;
1796 
1797         auto&amp; focusedFormElement = downcast&lt;HTMLTextFormControlElement&gt;(*focusedElement);
1798         auto directionValue = direction == WritingDirection::LeftToRight ? &quot;ltr&quot; : &quot;rtl&quot;;
<a name="19" id="anc19"></a><span class="line-modified">1799         auto writingDirectionInputTypeName = inputTypeNameForEditingAction(EditAction::SetWritingDirection);</span>
1800         if (!dispatchBeforeInputEvent(focusedFormElement, writingDirectionInputTypeName, directionValue))
1801             return;
1802 
1803         focusedFormElement.setAttributeWithoutSynchronization(dirAttr, directionValue);
1804         dispatchInputEvent(focusedFormElement, writingDirectionInputTypeName, directionValue);
1805         document().updateStyleIfNeeded();
1806         return;
1807     }
1808 
1809     auto style = MutableStyleProperties::create();
1810     style-&gt;setProperty(CSSPropertyDirection, direction == WritingDirection::LeftToRight ? &quot;ltr&quot; : direction == WritingDirection::RightToLeft ? &quot;rtl&quot; : &quot;inherit&quot;, false);
<a name="20" id="anc20"></a><span class="line-modified">1811     applyParagraphStyleToSelection(style.ptr(), EditAction::SetWritingDirection);</span>
1812 }
1813 
1814 WritingDirection Editor::baseWritingDirectionForSelectionStart() const
1815 {
1816     auto result = WritingDirection::LeftToRight;
1817 
1818     Position pos = m_frame.selection().selection().visibleStart().deepEquivalent();
1819     Node* node = pos.deprecatedNode();
1820     if (!node)
1821         return result;
1822 
1823     auto renderer = node-&gt;renderer();
1824     if (!renderer)
1825         return result;
1826 
1827     if (!renderer-&gt;isRenderBlockFlow()) {
1828         renderer = renderer-&gt;containingBlock();
1829         if (!renderer)
1830             return result;
1831     }
1832 
1833     switch (renderer-&gt;style().direction()) {
1834     case TextDirection::LTR:
1835         return WritingDirection::LeftToRight;
1836     case TextDirection::RTL:
1837         return WritingDirection::RightToLeft;
1838     }
1839 
1840     return result;
1841 }
1842 
1843 void Editor::selectComposition()
1844 {
1845     RefPtr&lt;Range&gt; range = compositionRange();
1846     if (!range)
1847         return;
1848 
1849     // The composition can start inside a composed character sequence, so we have to override checks.
1850     // See &lt;http://bugs.webkit.org/show_bug.cgi?id=15781&gt;
1851     VisibleSelection selection;
1852     selection.setWithoutValidation(range-&gt;startPosition(), range-&gt;endPosition());
1853     m_frame.selection().setSelection(selection, { });
1854 }
1855 
1856 void Editor::confirmComposition()
1857 {
1858     if (!m_compositionNode)
1859         return;
1860     setComposition(m_compositionNode-&gt;data().substring(m_compositionStart, m_compositionEnd - m_compositionStart), ConfirmComposition);
1861 }
1862 
1863 void Editor::cancelComposition()
1864 {
1865     if (!m_compositionNode)
1866         return;
1867     setComposition(emptyString(), CancelComposition);
1868 }
1869 
1870 bool Editor::cancelCompositionIfSelectionIsInvalid()
1871 {
1872     unsigned start;
1873     unsigned end;
1874     if (!hasComposition() || ignoreSelectionChanges() || getCompositionSelection(start, end))
1875         return false;
1876 
1877     cancelComposition();
1878     return true;
1879 }
1880 
1881 void Editor::confirmComposition(const String&amp; text)
1882 {
1883     setComposition(text, ConfirmComposition);
1884 }
1885 
1886 class SetCompositionScope {
1887 public:
1888     SetCompositionScope(Frame&amp; frame)
1889         : m_frame(frame)
1890         , m_typingGestureIndicator(frame)
1891     {
1892         m_frame-&gt;editor().setIgnoreSelectionChanges(true);
1893     }
1894 
1895     ~SetCompositionScope()
1896     {
1897         m_frame-&gt;editor().setIgnoreSelectionChanges(false);
1898         if (auto* editorClient = m_frame-&gt;editor().client())
1899             editorClient-&gt;didUpdateComposition();
1900     }
1901 
1902     Ref&lt;Frame&gt; m_frame;
1903     UserTypingGestureIndicator m_typingGestureIndicator;
1904 };
1905 
1906 void Editor::setComposition(const String&amp; text, SetCompositionMode mode)
1907 {
1908     ASSERT(mode == ConfirmComposition || mode == CancelComposition);
1909     SetCompositionScope setCompositionScope(m_frame);
1910 
1911     if (mode == CancelComposition)
1912         ASSERT(text == emptyString());
1913     else
1914         selectComposition();
1915 
1916     m_compositionNode = nullptr;
1917     m_customCompositionUnderlines.clear();
1918 
1919     if (m_frame.selection().isNone())
1920         return;
1921 
1922     // Always delete the current composition before inserting the finalized composition text if we&#39;re confirming our composition.
1923     // Our default behavior (if the beforeinput event is not prevented) is to insert the finalized composition text back in.
1924     // We pass TypingCommand::TextCompositionPending here to indicate that we are deleting the pending composition.
1925     if (mode != CancelComposition)
1926         TypingCommand::deleteSelection(document(), 0, TypingCommand::TextCompositionPending);
1927 
1928     insertTextForConfirmedComposition(text);
1929 
1930     if (auto* target = document().focusedElement())
1931         target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionendEvent, document().windowProxy(), text));
1932 
1933     if (mode == CancelComposition) {
1934         // An open typing command that disagrees about current selection would cause issues with typing later on.
1935         TypingCommand::closeTyping(&amp;m_frame);
1936     }
1937 }
1938 
1939 void Editor::setComposition(const String&amp; text, const Vector&lt;CompositionUnderline&gt;&amp; underlines, unsigned selectionStart, unsigned selectionEnd)
1940 {
1941     SetCompositionScope setCompositionScope(m_frame);
1942 
1943     // Updates styles before setting selection for composition to prevent
1944     // inserting the previous composition text into text nodes oddly.
1945     // See https://bugs.webkit.org/show_bug.cgi?id=46868
1946     document().updateStyleIfNeeded();
1947 
1948     selectComposition();
1949 
1950     if (m_frame.selection().isNone())
1951         return;
1952 
1953     String originalText = selectedText();
1954     bool isStartingToRecomposeExistingRange = !text.isEmpty() &amp;&amp; selectionStart &lt; selectionEnd &amp;&amp; !hasComposition();
1955     if (isStartingToRecomposeExistingRange) {
1956         // We pass TypingCommand::TextCompositionFinal here to indicate that we are removing composition text that has been finalized.
1957         TypingCommand::deleteSelection(document(), 0, TypingCommand::TextCompositionFinal);
1958         const VisibleSelection&amp; currentSelection = m_frame.selection().selection();
1959         if (currentSelection.isRange()) {
1960             // If deletion was prevented, then we need to collapse the selection to the end so that the original text will not be recomposed.
1961             m_frame.selection().setSelection({ currentSelection.end(), currentSelection.end() });
1962         }
1963     }
1964 
1965 #if PLATFORM(IOS_FAMILY)
1966     client()-&gt;startDelayingAndCoalescingContentChangeNotifications();
1967 #endif
1968 
1969     Element* target = document().focusedElement();
1970     if (target) {
1971         // Dispatch an appropriate composition event to the focused node.
1972         // We check the composition status and choose an appropriate composition event since this
1973         // function is used for three purposes:
1974         // 1. Starting a new composition.
1975         //    Send a compositionstart and a compositionupdate event when this function creates
1976         //    a new composition node, i.e.
1977         //    m_compositionNode == 0 &amp;&amp; !text.isEmpty().
1978         //    Sending a compositionupdate event at this time ensures that at least one
1979         //    compositionupdate event is dispatched.
1980         // 2. Updating the existing composition node.
1981         //    Send a compositionupdate event when this function updates the existing composition
1982         //    node, i.e. m_compositionNode != 0 &amp;&amp; !text.isEmpty().
1983         // 3. Canceling the ongoing composition.
1984         //    Send a compositionend event when function deletes the existing composition node, i.e.
1985         //    m_compositionNode != 0 &amp;&amp; test.isEmpty().
1986         RefPtr&lt;CompositionEvent&gt; event;
1987         if (!m_compositionNode) {
1988             // We should send a compositionstart event only when the given text is not empty because this
1989             // function doesn&#39;t create a composition node when the text is empty.
1990             if (!text.isEmpty()) {
1991                 target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionstartEvent, document().windowProxy(), originalText));
1992                 event = CompositionEvent::create(eventNames().compositionupdateEvent, document().windowProxy(), text);
1993             }
1994         } else if (!text.isEmpty())
1995             event = CompositionEvent::create(eventNames().compositionupdateEvent, document().windowProxy(), text);
1996 
1997         if (event)
1998             target-&gt;dispatchEvent(*event);
1999     }
2000 
2001     // If text is empty, then delete the old composition here.  If text is non-empty, InsertTextCommand::input
2002     // will delete the old composition with an optimized replace operation.
2003     if (text.isEmpty()) {
2004         TypingCommand::deleteSelection(document(), TypingCommand::PreventSpellChecking, TypingCommand::TextCompositionPending);
2005         if (target)
2006             target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionendEvent, document().windowProxy(), text));
2007     }
2008 
2009     m_compositionNode = nullptr;
2010     m_customCompositionUnderlines.clear();
2011 
2012     if (!text.isEmpty()) {
2013         TypingCommand::insertText(document(), text, TypingCommand::SelectInsertedText | TypingCommand::PreventSpellChecking, TypingCommand::TextCompositionPending);
2014 
2015         // Find out what node has the composition now.
2016         Position base = m_frame.selection().selection().base().downstream();
2017         Position extent = m_frame.selection().selection().extent();
2018         Node* baseNode = base.deprecatedNode();
2019         unsigned baseOffset = base.deprecatedEditingOffset();
2020         Node* extentNode = extent.deprecatedNode();
2021         unsigned extentOffset = extent.deprecatedEditingOffset();
2022 
2023         if (is&lt;Text&gt;(baseNode) &amp;&amp; baseNode == extentNode &amp;&amp; baseOffset + text.length() == extentOffset) {
2024             m_compositionNode = downcast&lt;Text&gt;(baseNode);
2025             m_compositionStart = baseOffset;
2026             m_compositionEnd = extentOffset;
2027             m_customCompositionUnderlines = underlines;
2028             for (auto&amp; underline : m_customCompositionUnderlines) {
2029                 underline.startOffset += baseOffset;
2030                 underline.endOffset += baseOffset;
2031             }
2032             if (baseNode-&gt;renderer())
2033                 baseNode-&gt;renderer()-&gt;repaint();
2034 
2035             unsigned start = std::min(baseOffset + selectionStart, extentOffset);
2036             unsigned end = std::min(std::max(start, baseOffset + selectionEnd), extentOffset);
2037             auto selectedRange = Range::create(baseNode-&gt;document(), baseNode, start, baseNode, end);
2038             m_frame.selection().setSelectedRange(selectedRange.ptr(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::No);
2039         }
2040     }
2041 
2042 #if PLATFORM(IOS_FAMILY)
2043     client()-&gt;stopDelayingAndCoalescingContentChangeNotifications();
2044 #endif
2045 }
2046 
2047 void Editor::ignoreSpelling()
2048 {
2049     if (!client())
2050         return;
2051 
2052     RefPtr&lt;Range&gt; selectedRange = m_frame.selection().toNormalizedRange();
2053     if (selectedRange)
2054         document().markers().removeMarkers(*selectedRange, DocumentMarker::Spelling);
2055 
2056     String text = selectedText();
2057     ASSERT(text.length());
2058     textChecker()-&gt;ignoreWordInSpellDocument(text);
2059 }
2060 
2061 void Editor::learnSpelling()
2062 {
2063     if (!client())
2064         return;
2065 
2066     // FIXME: On Mac OS X, when use &quot;learn&quot; button on &quot;Spelling and Grammar&quot; panel, we don&#39;t call this function. It should remove misspelling markers around the learned word, see &lt;rdar://problem/5396072&gt;.
2067 
2068     RefPtr&lt;Range&gt; selectedRange = m_frame.selection().toNormalizedRange();
2069     if (selectedRange)
2070         document().markers().removeMarkers(*selectedRange, DocumentMarker::Spelling);
2071 
2072     String text = selectedText();
2073     ASSERT(text.length());
2074     textChecker()-&gt;learnWord(text);
2075 }
2076 
2077 #if !PLATFORM(IOS_FAMILY)
2078 
2079 void Editor::advanceToNextMisspelling(bool startBeforeSelection)
2080 {
2081     Ref&lt;Frame&gt; protection(m_frame);
2082 
2083     // The basic approach is to search in two phases - from the selection end to the end of the doc, and
2084     // then we wrap and search from the doc start to (approximately) where we started.
2085 
2086     // Start at the end of the selection, search to edge of document.  Starting at the selection end makes
2087     // repeated &quot;check spelling&quot; commands work.
2088     VisibleSelection selection(m_frame.selection().selection());
2089     Ref&lt;Range&gt; spellingSearchRange = rangeOfContents(document());
2090 
2091     bool startedWithSelection = false;
2092     if (selection.start().deprecatedNode()) {
2093         startedWithSelection = true;
2094         if (startBeforeSelection) {
2095             VisiblePosition start(selection.visibleStart());
2096             // We match AppKit&#39;s rule: Start 1 character before the selection.
2097             VisiblePosition oneBeforeStart = start.previous();
2098             setStart(spellingSearchRange.ptr(), oneBeforeStart.isNotNull() ? oneBeforeStart : start);
2099         } else
2100             setStart(spellingSearchRange.ptr(), selection.visibleEnd());
2101     }
2102 
2103     Position position = spellingSearchRange-&gt;startPosition();
2104     if (!isEditablePosition(position)) {
2105         // This shouldn&#39;t happen in very often because the Spelling menu items aren&#39;t enabled unless the
2106         // selection is editable.
2107         // This can happen in Mail for a mix of non-editable and editable content (like Stationary),
2108         // when spell checking the whole document before sending the message.
2109         // In that case the document might not be editable, but there are editable pockets that need to be spell checked.
2110 
2111         position = VisiblePosition(firstEditablePositionAfterPositionInRoot(position, document().documentElement())).deepEquivalent();
2112         if (position.isNull())
2113             return;
2114 
2115         Position rangeCompliantPosition = position.parentAnchoredEquivalent();
2116         if (rangeCompliantPosition.deprecatedNode())
2117             spellingSearchRange-&gt;setStart(*rangeCompliantPosition.deprecatedNode(), rangeCompliantPosition.deprecatedEditingOffset());
2118         startedWithSelection = false; // won&#39;t need to wrap
2119     }
2120 
2121     // topNode defines the whole range we want to operate on
2122     auto* topNode = highestEditableRoot(position);
2123     // FIXME: lastOffsetForEditing() is wrong here if editingIgnoresContent(highestEditableRoot()) returns true (e.g. a &lt;table&gt;)
2124     if (topNode)
2125         spellingSearchRange-&gt;setEnd(*topNode, lastOffsetForEditing(*topNode));
2126 
2127     // If spellingSearchRange starts in the middle of a word, advance to the next word so we start checking
2128     // at a word boundary. Going back by one char and then forward by a word does the trick.
2129     if (startedWithSelection) {
2130         VisiblePosition oneBeforeStart = startVisiblePosition(spellingSearchRange.ptr(), DOWNSTREAM).previous();
2131         if (oneBeforeStart.isNotNull())
2132             setStart(spellingSearchRange.ptr(), endOfWord(oneBeforeStart));
2133         // else we were already at the start of the editable node
2134     }
2135 
2136     if (spellingSearchRange-&gt;collapsed())
2137         return; // nothing to search in
2138 
2139     // Get the spell checker if it is available
2140     if (!client())
2141         return;
2142 
2143     // We go to the end of our first range instead of the start of it, just to be sure
2144     // we don&#39;t get foiled by any word boundary problems at the start.  It means we might
2145     // do a tiny bit more searching.
2146     Node&amp; searchEndNodeAfterWrap = spellingSearchRange-&gt;endContainer();
2147     int searchEndOffsetAfterWrap = spellingSearchRange-&gt;endOffset();
2148 
2149     int misspellingOffset = 0;
2150     GrammarDetail grammarDetail;
2151     int grammarPhraseOffset = 0;
2152     RefPtr&lt;Range&gt; grammarSearchRange;
2153     String badGrammarPhrase;
2154     String misspelledWord;
2155 
2156     bool isSpelling = true;
2157     int foundOffset = 0;
2158     String foundItem;
2159     RefPtr&lt;Range&gt; firstMisspellingRange;
2160     if (unifiedTextCheckerEnabled()) {
2161         grammarSearchRange = spellingSearchRange-&gt;cloneRange();
2162         foundItem = TextCheckingHelper(*client(), spellingSearchRange).findFirstMisspellingOrBadGrammar(isGrammarCheckingEnabled(), isSpelling, foundOffset, grammarDetail);
2163         if (isSpelling) {
2164             misspelledWord = foundItem;
2165             misspellingOffset = foundOffset;
2166         } else {
2167             badGrammarPhrase = foundItem;
2168             grammarPhraseOffset = foundOffset;
2169         }
2170     } else {
2171         misspelledWord = TextCheckingHelper(*client(), spellingSearchRange).findFirstMisspelling(misspellingOffset, false, firstMisspellingRange);
2172 
2173 #if USE(GRAMMAR_CHECKING)
2174         grammarSearchRange = spellingSearchRange-&gt;cloneRange();
2175         if (!misspelledWord.isEmpty()) {
2176             // Stop looking at start of next misspelled word
2177             CharacterIterator chars(*grammarSearchRange);
2178             chars.advance(misspellingOffset);
2179             grammarSearchRange-&gt;setEnd(chars.range()-&gt;startContainer(), chars.range()-&gt;startOffset());
2180         }
2181 
2182         if (isGrammarCheckingEnabled())
2183             badGrammarPhrase = TextCheckingHelper(*client(), *grammarSearchRange).findFirstBadGrammar(grammarDetail, grammarPhraseOffset, false);
2184 #endif
2185     }
2186 
2187     // If we found neither bad grammar nor a misspelled word, wrap and try again (but don&#39;t bother if we started at the beginning of the
2188     // block rather than at a selection).
2189     if (startedWithSelection &amp;&amp; !misspelledWord &amp;&amp; !badGrammarPhrase) {
2190         if (topNode)
2191             spellingSearchRange-&gt;setStart(*topNode, 0);
2192         // going until the end of the very first chunk we tested is far enough
2193         spellingSearchRange-&gt;setEnd(searchEndNodeAfterWrap, searchEndOffsetAfterWrap);
2194 
2195         if (unifiedTextCheckerEnabled()) {
2196             grammarSearchRange = spellingSearchRange-&gt;cloneRange();
2197             foundItem = TextCheckingHelper(*client(), spellingSearchRange).findFirstMisspellingOrBadGrammar(isGrammarCheckingEnabled(), isSpelling, foundOffset, grammarDetail);
2198             if (isSpelling) {
2199                 misspelledWord = foundItem;
2200                 misspellingOffset = foundOffset;
2201             } else {
2202                 badGrammarPhrase = foundItem;
2203                 grammarPhraseOffset = foundOffset;
2204             }
2205         } else {
2206             misspelledWord = TextCheckingHelper(*client(), spellingSearchRange).findFirstMisspelling(misspellingOffset, false, firstMisspellingRange);
2207 
2208 #if USE(GRAMMAR_CHECKING)
2209             grammarSearchRange = spellingSearchRange-&gt;cloneRange();
2210             if (!misspelledWord.isEmpty()) {
2211                 // Stop looking at start of next misspelled word
2212                 CharacterIterator chars(*grammarSearchRange);
2213                 chars.advance(misspellingOffset);
2214                 grammarSearchRange-&gt;setEnd(chars.range()-&gt;startContainer(), chars.range()-&gt;startOffset());
2215             }
2216 
2217             if (isGrammarCheckingEnabled())
2218                 badGrammarPhrase = TextCheckingHelper(*client(), *grammarSearchRange).findFirstBadGrammar(grammarDetail, grammarPhraseOffset, false);
2219 #endif
2220         }
2221     }
2222 
2223 #if !USE(GRAMMAR_CHECKING)
2224     ASSERT(badGrammarPhrase.isEmpty());
2225     UNUSED_PARAM(grammarPhraseOffset);
2226 #else
2227     if (!badGrammarPhrase.isEmpty()) {
2228         // We found bad grammar. Since we only searched for bad grammar up to the first misspelled word, the bad grammar
2229         // takes precedence and we ignore any potential misspelled word. Select the grammar detail, update the spelling
2230         // panel, and store a marker so we draw the green squiggle later.
2231 
2232         ASSERT(badGrammarPhrase.length() &gt; 0);
2233         ASSERT(grammarDetail.location != -1 &amp;&amp; grammarDetail.length &gt; 0);
2234 
2235         // FIXME 4859190: This gets confused with doubled punctuation at the end of a paragraph
2236         auto badGrammarRange = TextIterator::subrange(*grammarSearchRange, grammarPhraseOffset + grammarDetail.location, grammarDetail.length);
2237         m_frame.selection().setSelection(VisibleSelection(badGrammarRange, SEL_DEFAULT_AFFINITY));
2238         m_frame.selection().revealSelection();
2239 
2240         client()-&gt;updateSpellingUIWithGrammarString(badGrammarPhrase, grammarDetail);
2241         document().markers().addMarker(badGrammarRange, DocumentMarker::Grammar, grammarDetail.userDescription);
2242     } else
2243 #endif
2244     if (!misspelledWord.isEmpty()) {
2245         // We found a misspelling, but not any earlier bad grammar. Select the misspelling, update the spelling panel, and store
2246         // a marker so we draw the red squiggle later.
2247 
2248         auto misspellingRange = TextIterator::subrange(spellingSearchRange, misspellingOffset, misspelledWord.length());
2249         m_frame.selection().setSelection(VisibleSelection(misspellingRange, DOWNSTREAM));
2250         m_frame.selection().revealSelection();
2251 
2252         client()-&gt;updateSpellingUIWithMisspelledWord(misspelledWord);
2253         document().markers().addMarker(misspellingRange, DocumentMarker::Spelling);
2254     }
2255 }
2256 
2257 #endif // !PLATFORM(IOS_FAMILY)
2258 
2259 String Editor::misspelledWordAtCaretOrRange(Node* clickedNode) const
2260 {
2261     if (!isContinuousSpellCheckingEnabled() || !clickedNode || !isSpellCheckingEnabledFor(clickedNode))
2262         return String();
2263 
2264     VisibleSelection selection = m_frame.selection().selection();
2265     if (!selection.isContentEditable() || selection.isNone())
2266         return String();
2267 
2268     VisibleSelection wordSelection(selection.base());
2269     wordSelection.expandUsingGranularity(WordGranularity);
2270     RefPtr&lt;Range&gt; wordRange = wordSelection.toNormalizedRange();
2271     if (!wordRange)
2272         return String();
2273 
2274     // In compliance with GTK+ applications, additionally allow to provide suggestions when the current
2275     // selection exactly match the word selection.
2276     if (selection.isRange() &amp;&amp; !areRangesEqual(wordRange.get(), selection.toNormalizedRange().get()))
2277         return String();
2278 
2279     String word = wordRange-&gt;text();
2280     if (word.isEmpty() || !client())
2281         return String();
2282 
2283     int wordLength = word.length();
2284     int misspellingLocation = -1;
2285     int misspellingLength = 0;
2286     textChecker()-&gt;checkSpellingOfString(word, &amp;misspellingLocation, &amp;misspellingLength);
2287 
2288     return misspellingLength == wordLength ? word : String();
2289 }
2290 
2291 String Editor::misspelledSelectionString() const
2292 {
2293     String selectedString = selectedText();
2294     int length = selectedString.length();
2295     if (!length || !client())
2296         return String();
2297 
2298     int misspellingLocation = -1;
2299     int misspellingLength = 0;
2300     textChecker()-&gt;checkSpellingOfString(selectedString, &amp;misspellingLocation, &amp;misspellingLength);
2301 
2302     // The selection only counts as misspelled if the selected text is exactly one misspelled word
2303     if (misspellingLength != length)
2304         return String();
2305 
2306     // Update the spelling panel to be displaying this error (whether or not the spelling panel is on screen).
2307     // This is necessary to make a subsequent call to [NSSpellChecker ignoreWord:inSpellDocumentWithTag:] work
2308     // correctly; that call behaves differently based on whether the spelling panel is displaying a misspelling
2309     // or a grammar error.
2310     client()-&gt;updateSpellingUIWithMisspelledWord(selectedString);
2311 
2312     return selectedString;
2313 }
2314 
2315 bool Editor::isSelectionUngrammatical()
2316 {
2317 #if USE(GRAMMAR_CHECKING)
2318     RefPtr&lt;Range&gt; range = m_frame.selection().toNormalizedRange();
2319     if (!range || !client())
2320         return false;
2321     return TextCheckingHelper(*client(), *range).isUngrammatical();
2322 #else
2323     return false;
2324 #endif
2325 }
2326 
2327 Vector&lt;String&gt; Editor::guessesForMisspelledWord(const String&amp; word) const
2328 {
2329     ASSERT(word.length());
2330 
2331     Vector&lt;String&gt; guesses;
2332     if (client())
2333         textChecker()-&gt;getGuessesForWord(word, String(), m_frame.selection().selection(), guesses);
2334     return guesses;
2335 }
2336 
2337 Vector&lt;String&gt; Editor::guessesForMisspelledOrUngrammatical(bool&amp; misspelled, bool&amp; ungrammatical)
2338 {
2339     if (unifiedTextCheckerEnabled()) {
2340         RefPtr&lt;Range&gt; range;
2341         VisibleSelection selection = m_frame.selection().selection();
2342         if (selection.isCaret() &amp;&amp; behavior().shouldAllowSpellingSuggestionsWithoutSelection()) {
2343             VisibleSelection wordSelection = VisibleSelection(selection.base());
2344             wordSelection.expandUsingGranularity(WordGranularity);
2345             range = wordSelection.toNormalizedRange();
2346         } else
2347             range = selection.toNormalizedRange();
2348         if (!range || !client())
2349             return Vector&lt;String&gt;();
2350         return TextCheckingHelper(*client(), *range).guessesForMisspelledOrUngrammaticalRange(isGrammarCheckingEnabled(), misspelled, ungrammatical);
2351     }
2352 
2353     String misspelledWord = behavior().shouldAllowSpellingSuggestionsWithoutSelection() ? misspelledWordAtCaretOrRange(document().focusedElement()) : misspelledSelectionString();
2354     misspelled = !misspelledWord.isEmpty();
2355     // Only unified text checker supports guesses for ungrammatical phrases.
2356     ungrammatical = false;
2357 
2358     if (misspelled)
2359         return guessesForMisspelledWord(misspelledWord);
2360     return Vector&lt;String&gt;();
2361 }
2362 
2363 void Editor::showSpellingGuessPanel()
2364 {
2365     if (!client()) {
2366         LOG_ERROR(&quot;No NSSpellChecker&quot;);
2367         return;
2368     }
2369 
2370     if (client()-&gt;spellingUIIsShowing()) {
2371         client()-&gt;showSpellingUI(false);
2372         return;
2373     }
2374 
2375 #if !PLATFORM(IOS_FAMILY)
2376     advanceToNextMisspelling(true);
2377 #endif
2378     client()-&gt;showSpellingUI(true);
2379 }
2380 
2381 bool Editor::spellingPanelIsShowing()
2382 {
2383     if (!client())
2384         return false;
2385     return client()-&gt;spellingUIIsShowing();
2386 }
2387 
2388 void Editor::clearMisspellingsAndBadGrammar(const VisibleSelection&amp; movingSelection)
2389 {
2390     if (auto selectedRange = movingSelection.toNormalizedRange())
2391         document().markers().removeMarkers(*selectedRange, { DocumentMarker::Spelling, DocumentMarker::Grammar });
2392 }
2393 
2394 void Editor::markMisspellingsAndBadGrammar(const VisibleSelection &amp;movingSelection)
2395 {
2396     markMisspellingsAndBadGrammar(movingSelection, isContinuousSpellCheckingEnabled() &amp;&amp; isGrammarCheckingEnabled(), movingSelection);
2397 }
2398 
2399 void Editor::markMisspellingsAfterTypingToWord(const VisiblePosition &amp;wordStart, const VisibleSelection&amp; selectionAfterTyping, bool doReplacement)
2400 {
2401     Ref&lt;Frame&gt; protection(m_frame);
2402 
<a name="21" id="anc21"></a>


2403 #if PLATFORM(IOS_FAMILY)
2404     UNUSED_PARAM(selectionAfterTyping);
2405     UNUSED_PARAM(doReplacement);
2406     OptionSet&lt;TextCheckingType&gt; textCheckingOptions;
2407     if (isContinuousSpellCheckingEnabled())
2408         textCheckingOptions.add(TextCheckingType::Spelling);
2409     if (!textCheckingOptions.contains(TextCheckingType::Spelling))
2410         return;
2411 
2412     VisibleSelection adjacentWords = VisibleSelection(startOfWord(wordStart, LeftWordIfOnBoundary), endOfWord(wordStart, RightWordIfOnBoundary));
2413     auto adjacentWordRange = adjacentWords.toNormalizedRange();
2414     markAllMisspellingsAndBadGrammarInRanges(textCheckingOptions, adjacentWordRange.copyRef(), adjacentWordRange.copyRef(), adjacentWordRange.copyRef());
2415 #else
2416 #if !USE(AUTOMATIC_TEXT_REPLACEMENT)
2417     UNUSED_PARAM(doReplacement);
2418 #endif
2419 
2420     if (unifiedTextCheckerEnabled()) {
2421         m_alternativeTextController-&gt;applyPendingCorrection(selectionAfterTyping);
2422 
2423         OptionSet&lt;TextCheckingType&gt; textCheckingOptions;
2424 
2425         if (isContinuousSpellCheckingEnabled())
2426             textCheckingOptions.add(TextCheckingType::Spelling);
2427 
2428 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2429         if (doReplacement
2430             &amp;&amp; (isAutomaticQuoteSubstitutionEnabled()
2431                 || isAutomaticLinkDetectionEnabled()
2432                 || isAutomaticDashSubstitutionEnabled()
2433                 || isAutomaticTextReplacementEnabled()
2434                 || (textCheckingOptions.contains(TextCheckingType::Spelling) &amp;&amp; isAutomaticSpellingCorrectionEnabled())))
2435             textCheckingOptions.add(TextCheckingType::Replacement);
2436 #endif
2437         if (!textCheckingOptions.contains(TextCheckingType::Spelling) &amp;&amp; !textCheckingOptions.contains(TextCheckingType::Replacement))
2438             return;
2439 
2440         if (isGrammarCheckingEnabled())
2441             textCheckingOptions.add(TextCheckingType::Grammar);
2442 
2443         auto sentenceStart = startOfSentence(wordStart);
2444         auto sentenceEnd = endOfSentence(wordStart);
2445         VisibleSelection fullSentence(sentenceStart, sentenceEnd);
2446         auto fullSentenceRange = fullSentence.toNormalizedRange();
2447         if (!fullSentenceRange)
2448             return;
2449 
2450         auto spellCheckingStart = wordStart;
2451         auto spellCheckingEnd = wordStart;
2452 
2453         // FIXME: The following logic doesn&#39;t handle adding spelling markers due to retro sentence corrections when an
2454         // incorrectly spelled range is separated from the start of the current word by a text node inside an element
2455         // with spellcheck disabled. To fix this, we need to refactor markAllMisspellingsAndBadGrammarInRanges so that
2456         // it can handle a list of spelling ranges, alongside the grammar range.
2457         while (sentenceStart &lt; spellCheckingStart) {
2458             auto previousPosition = spellCheckingStart.previous(CannotCrossEditingBoundary);
2459             if (previousPosition.isNull() || previousPosition == spellCheckingStart)
2460                 break;
2461 
2462             auto* container = previousPosition.deepEquivalent().downstream().containerNode();
2463             if (auto* containerElement = is&lt;Element&gt;(container) ? downcast&lt;Element&gt;(container) : container-&gt;parentElement()) {
2464                 if (!containerElement-&gt;isSpellCheckingEnabled())
2465                     break;
2466             }
2467 
2468             spellCheckingStart = previousPosition;
2469         }
2470 
2471         while (spellCheckingEnd &lt; sentenceEnd) {
2472             auto nextPosition = spellCheckingEnd.next(CannotCrossEditingBoundary);
2473             if (nextPosition.isNull() || nextPosition == spellCheckingEnd)
2474                 break;
2475 
2476             auto* container = nextPosition.deepEquivalent().upstream().containerNode();
2477             if (auto* containerElement = is&lt;Element&gt;(container) ? downcast&lt;Element&gt;(container) : container-&gt;parentElement()) {
2478                 if (!containerElement-&gt;isSpellCheckingEnabled())
2479                     break;
2480             }
2481 
2482             spellCheckingEnd = nextPosition;
2483         }
2484 
2485         auto spellCheckingRange = VisibleSelection(spellCheckingStart, spellCheckingEnd).toNormalizedRange();
2486         if (!spellCheckingRange)
2487             return;
2488 
2489         auto adjacentWordRange = VisibleSelection(startOfWord(wordStart, LeftWordIfOnBoundary), endOfWord(wordStart, RightWordIfOnBoundary)).toNormalizedRange();
2490         if (!adjacentWordRange)
2491             return;
2492 
2493         // The spelling and grammar markers in these ranges are recomputed. This is because typing a word may
2494         // cause any other part of the current sentence to lose or gain spelling correction markers, due to
2495         // sentence retro correction. As such, we expand the spell checking range to encompass as much of the
2496         // full sentence as we can, respecting boundaries where spellchecking is disabled.
2497         fullSentenceRange-&gt;ownerDocument().markers().removeMarkers(*fullSentenceRange, DocumentMarker::Grammar);
2498         spellCheckingRange-&gt;ownerDocument().markers().removeMarkers(*spellCheckingRange, DocumentMarker::Spelling);
2499         markAllMisspellingsAndBadGrammarInRanges(textCheckingOptions, WTFMove(spellCheckingRange), WTFMove(adjacentWordRange), WTFMove(fullSentenceRange));
2500         return;
2501     }
2502 
2503     if (!isContinuousSpellCheckingEnabled())
2504         return;
2505 
2506     // Check spelling of one word
2507     RefPtr&lt;Range&gt; misspellingRange;
2508     markMisspellings(VisibleSelection(startOfWord(wordStart, LeftWordIfOnBoundary), endOfWord(wordStart, RightWordIfOnBoundary)), misspellingRange);
2509 
2510     // Autocorrect the misspelled word.
2511     if (!misspellingRange)
2512         return;
2513 
2514     // Get the misspelled word.
2515     const String misspelledWord = plainText(misspellingRange.get());
2516     String autocorrectedString = textChecker()-&gt;getAutoCorrectSuggestionForMisspelledWord(misspelledWord);
2517 
2518     // If autocorrected word is non empty, replace the misspelled word by this word.
2519     if (!autocorrectedString.isEmpty()) {
2520         VisibleSelection newSelection(*misspellingRange, DOWNSTREAM);
2521         if (newSelection != m_frame.selection().selection()) {
2522             if (!m_frame.selection().shouldChangeSelection(newSelection))
2523                 return;
2524             m_frame.selection().setSelection(newSelection);
2525         }
2526 
2527         if (!m_frame.editor().shouldInsertText(autocorrectedString, misspellingRange.get(), EditorInsertAction::Typed))
2528             return;
2529         m_frame.editor().replaceSelectionWithText(autocorrectedString, SelectReplacement::No, SmartReplace::No, EditAction::Insert);
2530 
2531         // Reset the charet one character further.
2532         m_frame.selection().moveTo(m_frame.selection().selection().end());
2533         m_frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, CharacterGranularity);
2534     }
2535 
2536     if (!isGrammarCheckingEnabled())
2537         return;
2538 
2539     // Check grammar of entire sentence
2540     markBadGrammar(VisibleSelection(startOfSentence(wordStart), endOfSentence(wordStart)));
2541 #endif
2542 }
2543 
2544 void Editor::markMisspellingsOrBadGrammar(const VisibleSelection&amp; selection, bool checkSpelling, RefPtr&lt;Range&gt;&amp; firstMisspellingRange)
2545 {
2546 #if !PLATFORM(IOS_FAMILY)
2547     // This function is called with a selection already expanded to word boundaries.
2548     // Might be nice to assert that here.
2549 
2550     // This function is used only for as-you-type checking, so if that&#39;s off we do nothing. Note that
2551     // grammar checking can only be on if spell checking is also on.
2552     if (!isContinuousSpellCheckingEnabled())
2553         return;
2554 
2555     RefPtr&lt;Range&gt; searchRange(selection.toNormalizedRange());
2556     if (!searchRange)
2557         return;
2558 
2559     // If we&#39;re not in an editable node, bail.
2560     Node&amp; editableNode = searchRange-&gt;startContainer();
2561     if (!editableNode.hasEditableStyle())
2562         return;
2563 
2564     if (!isSpellCheckingEnabledFor(&amp;editableNode))
2565         return;
2566 
2567     // Get the spell checker if it is available
2568     if (!client())
2569         return;
2570 
2571     TextCheckingHelper checker(*client(), *searchRange);
2572     if (checkSpelling)
2573         checker.markAllMisspellings(firstMisspellingRange);
2574     else {
2575 #if USE(GRAMMAR_CHECKING)
2576         if (isGrammarCheckingEnabled())
2577             checker.markAllBadGrammar();
2578 #else
2579         ASSERT_NOT_REACHED();
2580 #endif
2581     }
2582 #else
2583         UNUSED_PARAM(selection);
2584         UNUSED_PARAM(checkSpelling);
2585         UNUSED_PARAM(firstMisspellingRange);
2586 #endif // !PLATFORM(IOS_FAMILY)
2587 }
2588 
2589 bool Editor::isSpellCheckingEnabledFor(Node* node) const
2590 {
2591     if (!node)
2592         return false;
2593     Element* element = is&lt;Element&gt;(*node) ? downcast&lt;Element&gt;(node) : node-&gt;parentElement();
2594     if (!element)
2595         return false;
2596     if (element-&gt;isInUserAgentShadowTree()) {
2597         if (HTMLTextFormControlElement* textControl = enclosingTextFormControl(firstPositionInOrBeforeNode(element)))
2598             return textControl-&gt;isSpellCheckingEnabled();
2599     }
2600     return element-&gt;isSpellCheckingEnabled();
2601 }
2602 
2603 bool Editor::isSpellCheckingEnabledInFocusedNode() const
2604 {
2605     return isSpellCheckingEnabledFor(m_frame.selection().selection().start().deprecatedNode());
2606 }
2607 
2608 void Editor::markMisspellings(const VisibleSelection&amp; selection, RefPtr&lt;Range&gt;&amp; firstMisspellingRange)
2609 {
2610     markMisspellingsOrBadGrammar(selection, true, firstMisspellingRange);
2611 }
2612 
2613 void Editor::markBadGrammar(const VisibleSelection&amp; selection)
2614 {
2615 #if USE(GRAMMAR_CHECKING)
2616     RefPtr&lt;Range&gt; firstMisspellingRange;
2617     markMisspellingsOrBadGrammar(selection, false, firstMisspellingRange);
2618 #else
2619     ASSERT_NOT_REACHED();
2620 #endif
2621 }
2622 
2623 void Editor::markAllMisspellingsAndBadGrammarInRanges(OptionSet&lt;TextCheckingType&gt; textCheckingOptions, RefPtr&lt;Range&gt;&amp;&amp; spellingRange, RefPtr&lt;Range&gt;&amp;&amp; automaticReplacementRange, RefPtr&lt;Range&gt;&amp;&amp; grammarRange)
2624 {
<a name="22" id="anc22"></a>


2625     ASSERT(unifiedTextCheckerEnabled());
2626 
2627     // There shouldn&#39;t be pending autocorrection at this moment.
2628     ASSERT(!m_alternativeTextController-&gt;hasPendingCorrection());
2629 
2630     bool shouldMarkGrammar = textCheckingOptions.contains(TextCheckingType::Grammar);
2631     bool shouldShowCorrectionPanel = textCheckingOptions.contains(TextCheckingType::ShowCorrectionPanel);
2632 
2633     // This function is called with selections already expanded to word boundaries.
2634     if (!client() || !spellingRange || (shouldMarkGrammar &amp;&amp; !grammarRange))
2635         return;
2636 
2637     // If we&#39;re not in an editable node, bail.
2638     Node&amp; editableNode = spellingRange-&gt;startContainer();
2639     if (!editableNode.hasEditableStyle())
2640         return;
2641 
2642     if (!isSpellCheckingEnabledFor(&amp;editableNode))
2643         return;
2644 
2645     auto rangeToCheck = shouldMarkGrammar ? grammarRange.releaseNonNull() : spellingRange.releaseNonNull();
2646     TextCheckingParagraph paragraphToCheck(rangeToCheck.get());
2647     if (paragraphToCheck.isEmpty())
2648         return;
2649 
2650     bool asynchronous = m_frame.settings().asynchronousSpellCheckingEnabled() &amp;&amp; !shouldShowCorrectionPanel;
2651 
2652     // In asynchronous mode, we intentionally check paragraph-wide sentence.
2653     const auto resolvedOptions = resolveTextCheckingTypeMask(editableNode, textCheckingOptions);
2654     auto textReplacementRange = automaticReplacementRange ? makeRef(*automaticReplacementRange) : rangeToCheck.copyRef();
2655     auto request = SpellCheckRequest::create(resolvedOptions, TextCheckingProcessIncremental, asynchronous ? makeRef(paragraphToCheck.paragraphRange()) : WTFMove(rangeToCheck), WTFMove(textReplacementRange), paragraphToCheck.paragraphRange());
2656     if (!request)
2657         return;
2658 
2659     if (asynchronous) {
2660         m_spellChecker-&gt;requestCheckingFor(request.releaseNonNull());
2661         return;
2662     }
2663 
2664     Vector&lt;TextCheckingResult&gt; results;
2665     checkTextOfParagraph(*textChecker(), paragraphToCheck.text(), resolvedOptions, results, m_frame.selection().selection());
2666     markAndReplaceFor(request.releaseNonNull(), results);
2667 }
2668 
2669 static bool isAutomaticTextReplacementType(TextCheckingType type)
2670 {
2671     switch (type) {
2672     case TextCheckingType::None:
2673     case TextCheckingType::Spelling:
2674     case TextCheckingType::Grammar:
2675         return false;
2676     case TextCheckingType::Link:
2677     case TextCheckingType::Quote:
2678     case TextCheckingType::Dash:
2679     case TextCheckingType::Replacement:
2680     case TextCheckingType::Correction:
2681     case TextCheckingType::ShowCorrectionPanel:
2682         return true;
2683     }
2684     ASSERT_NOT_REACHED();
2685     return false;
2686 }
2687 
<a name="23" id="anc23"></a>




2688 static void correctSpellcheckingPreservingTextCheckingParagraph(TextCheckingParagraph&amp; paragraph, Range&amp; rangeToReplace, const String&amp; replacement, int resultLocation, int resultLength)
2689 {
2690     auto&amp; scope = downcast&lt;ContainerNode&gt;(paragraph.paragraphRange().startContainer().rootNode());
2691 
2692     size_t paragraphLocation;
2693     size_t paragraphLength;
2694     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;paragraph.paragraphRange(), paragraphLocation, paragraphLength);
2695 
2696     SpellingCorrectionCommand::create(rangeToReplace, replacement)-&gt;apply();
2697 
2698     // TextCheckingParagraph may be orphaned after SpellingCorrectionCommand mutated DOM.
2699     // See &lt;rdar://10305315&gt;, http://webkit.org/b/89526.
2700 
2701     RefPtr&lt;Range&gt; newParagraphRange = TextIterator::rangeFromLocationAndLength(&amp;scope, paragraphLocation, paragraphLength + replacement.length() - resultLength);
2702 
2703     auto spellCheckingRange = TextIterator::subrange(*newParagraphRange, resultLocation, replacement.length());
2704     paragraph = TextCheckingParagraph(spellCheckingRange.copyRef(), spellCheckingRange.copyRef(), newParagraphRange.get());
2705 }
2706 
2707 void Editor::markAndReplaceFor(const SpellCheckRequest&amp; request, const Vector&lt;TextCheckingResult&gt;&amp; results)
2708 {
2709     Ref&lt;Frame&gt; protection(m_frame);
2710 
2711     auto textCheckingOptions = request.data().checkingTypes();
2712     TextCheckingParagraph paragraph(request.checkingRange(), request.automaticReplacementRange(), &amp;request.paragraphRange());
2713 
2714     // FIXME: Mark this const once MSVC bug is fixed: &lt;https://developercommunity.visualstudio.com/content/problem/316713/msvc-cant-compile-webkits-optionsetcontainsany.html&gt;.
2715     bool shouldPerformReplacement = textCheckingOptions.containsAny({ TextCheckingType::Quote, TextCheckingType::Dash, TextCheckingType::Replacement });
2716     const bool shouldMarkSpelling = textCheckingOptions.contains(TextCheckingType::Spelling);
2717     const bool shouldMarkGrammar = textCheckingOptions.contains(TextCheckingType::Grammar);
2718     const bool shouldMarkLink = textCheckingOptions.contains(TextCheckingType::Link);
2719     const bool shouldShowCorrectionPanel = textCheckingOptions.contains(TextCheckingType::ShowCorrectionPanel);
2720     const bool shouldCheckForCorrection = shouldShowCorrectionPanel || textCheckingOptions.contains(TextCheckingType::Correction);
2721 #if !USE(AUTOCORRECTION_PANEL)
2722     ASSERT(!shouldShowCorrectionPanel);
2723 #endif
2724 
2725     // Expand the range to encompass entire paragraphs, since text checking needs that much context.
2726     int selectionOffset = 0;
2727     bool useAmbiguousBoundaryOffset = false;
2728     bool selectionChanged = false;
2729     bool restoreSelectionAfterChange = false;
2730     bool adjustSelectionForParagraphBoundaries = false;
2731 
2732     if (shouldPerformReplacement || shouldMarkSpelling || shouldCheckForCorrection) {
2733         if (m_frame.selection().selection().selectionType() == VisibleSelection::CaretSelection) {
2734             // Attempt to save the caret position so we can restore it later if needed
2735             Position caretPosition = m_frame.selection().selection().end();
2736             selectionOffset = paragraph.offsetTo(caretPosition).releaseReturnValue();
2737             restoreSelectionAfterChange = true;
2738             if (selectionOffset &gt; 0 &amp;&amp; (selectionOffset &gt; paragraph.textLength() || paragraph.textCharAt(selectionOffset - 1) == newlineCharacter))
2739                 adjustSelectionForParagraphBoundaries = true;
2740             if (selectionOffset &gt; 0 &amp;&amp; selectionOffset &lt;= paragraph.textLength() &amp;&amp; isAmbiguousBoundaryCharacter(paragraph.textCharAt(selectionOffset - 1)))
2741                 useAmbiguousBoundaryOffset = true;
2742         }
2743     }
2744 
2745     int offsetDueToReplacement = 0;
2746 
2747     for (unsigned i = 0; i &lt; results.size(); i++) {
2748         const int spellingRangeEndOffset = paragraph.checkingEnd() + offsetDueToReplacement;
2749         const TextCheckingType resultType = results[i].type;
2750         const int resultLocation = results[i].location + offsetDueToReplacement;
2751         const int resultLength = results[i].length;
2752         const int resultEndLocation = resultLocation + resultLength;
2753         const int automaticReplacementEndLocation = paragraph.automaticReplacementStart() + paragraph.automaticReplacementLength() + offsetDueToReplacement;
2754         const String&amp; replacement = results[i].replacement;
2755         const bool resultEndsAtAmbiguousBoundary = useAmbiguousBoundaryOffset &amp;&amp; selectionOffset - 1 &lt;= resultEndLocation;
2756 
2757         // Only mark misspelling if:
2758         // 1. Current text checking isn&#39;t done for autocorrection, in which case shouldMarkSpelling is false.
2759         // 2. Result falls within spellingRange.
2760         // 3. The word in question doesn&#39;t end at an ambiguous boundary. For instance, we would not mark
2761         //    &quot;wouldn&#39;&quot; as misspelled right after apostrophe is typed.
2762         if (shouldMarkSpelling &amp;&amp; !shouldShowCorrectionPanel &amp;&amp; resultType == TextCheckingType::Spelling
2763             &amp;&amp; resultLocation &gt;= paragraph.checkingStart() &amp;&amp; resultEndLocation &lt;= spellingRangeEndOffset &amp;&amp; !resultEndsAtAmbiguousBoundary) {
2764             ASSERT(resultLength &gt; 0 &amp;&amp; resultLocation &gt;= 0);
2765             auto misspellingRange = paragraph.subrange(resultLocation, resultLength);
2766             if (!m_alternativeTextController-&gt;isSpellingMarkerAllowed(misspellingRange))
2767                 continue;
2768             misspellingRange-&gt;startContainer().document().markers().addMarker(misspellingRange, DocumentMarker::Spelling, replacement);
2769         } else if (shouldMarkGrammar &amp;&amp; resultType == TextCheckingType::Grammar &amp;&amp; paragraph.checkingRangeCovers(resultLocation, resultLength)) {
2770             ASSERT(resultLength &gt; 0 &amp;&amp; resultLocation &gt;= 0);
2771             for (auto&amp; detail : results[i].details) {
2772                 ASSERT(detail.length &gt; 0 &amp;&amp; detail.location &gt;= 0);
2773                 if (paragraph.checkingRangeCovers(resultLocation + detail.location, detail.length)) {
2774                     auto badGrammarRange = paragraph.subrange(resultLocation + detail.location, detail.length);
2775                     badGrammarRange-&gt;startContainer().document().markers().addMarker(badGrammarRange, DocumentMarker::Grammar, detail.userDescription);
2776                 }
2777             }
2778         } else if (resultEndLocation &lt;= automaticReplacementEndLocation &amp;&amp; resultEndLocation &gt;= paragraph.automaticReplacementStart()
2779             &amp;&amp; isAutomaticTextReplacementType(resultType)) {
2780             // In this case the result range just has to touch the automatic replacement range, so we can handle replacing non-word text such as punctuation.
2781             ASSERT(resultLength &gt; 0 &amp;&amp; resultLocation &gt;= 0);
2782 
2783             if (shouldShowCorrectionPanel &amp;&amp; (resultEndLocation &lt; automaticReplacementEndLocation
2784                 || (resultType != TextCheckingType::Replacement &amp;&amp; resultType != TextCheckingType::Correction)))
2785                 continue;
2786 
2787             // Apply replacement if:
2788             // 1. The replacement length is non-zero.
2789             // 2. The result doesn&#39;t end at an ambiguous boundary.
2790             //    (FIXME: this is required until 6853027 is fixed and text checking can do this for us
2791             bool doReplacement = replacement.length() &gt; 0 &amp;&amp; !resultEndsAtAmbiguousBoundary;
2792             auto rangeToReplace = paragraph.subrange(resultLocation, resultLength);
2793 
2794             // Adding links should be done only immediately after they are typed.
2795             if (resultType == TextCheckingType::Link &amp;&amp; selectionOffset != resultEndLocation + 1)
2796                 continue;
2797 
2798             if (!(shouldPerformReplacement || shouldCheckForCorrection || shouldMarkLink) || !doReplacement)
2799                 continue;
2800 
2801             String replacedString = plainText(rangeToReplace.ptr());
2802             const bool existingMarkersPermitReplacement = m_alternativeTextController-&gt;processMarkersOnTextToBeReplacedByResult(results[i], rangeToReplace, replacedString);
2803             if (!existingMarkersPermitReplacement)
2804                 continue;
2805 
2806             if (shouldShowCorrectionPanel) {
2807                 if (resultEndLocation == automaticReplacementEndLocation) {
2808                     // We only show the correction panel on the last word.
2809                     m_alternativeTextController-&gt;show(rangeToReplace, replacement);
2810                     break;
2811                 }
2812                 // If this function is called for showing correction panel, we ignore other correction or replacement.
2813                 continue;
2814             }
2815 
2816             VisibleSelection selectionToReplace(rangeToReplace, DOWNSTREAM);
2817             if (selectionToReplace != m_frame.selection().selection()) {
2818                 if (!m_frame.selection().shouldChangeSelection(selectionToReplace))
2819                     continue;
2820             }
2821 
2822             if (resultType == TextCheckingType::Link) {
2823                 m_frame.selection().setSelection(selectionToReplace);
2824                 selectionChanged = true;
2825                 restoreSelectionAfterChange = false;
2826                 if (canEditRichly())
2827                     CreateLinkCommand::create(document(), replacement)-&gt;apply();
2828             } else if (canEdit() &amp;&amp; shouldInsertText(replacement, rangeToReplace.ptr(), EditorInsertAction::Typed)) {
2829                 correctSpellcheckingPreservingTextCheckingParagraph(paragraph, rangeToReplace, replacement, resultLocation, resultLength);
2830 
2831                 if (AXObjectCache* cache = document().existingAXObjectCache()) {
2832                     if (Element* root = m_frame.selection().selection().rootEditableElement())
2833                         cache-&gt;postNotification(root, AXObjectCache::AXAutocorrectionOccured);
2834                 }
2835 
2836                 // Skip all other results for the replaced text.
2837                 while (i + 1 &lt; results.size() &amp;&amp; results[i + 1].location + offsetDueToReplacement &lt;= resultLocation)
2838                     i++;
2839 
2840                 selectionChanged = true;
2841                 offsetDueToReplacement += replacement.length() - resultLength;
2842                 if (resultLocation &lt; selectionOffset)
2843                     selectionOffset += replacement.length() - resultLength;
2844 
2845                 if (resultType == TextCheckingType::Correction) {
2846                     auto replacementRange = paragraph.subrange(resultLocation, replacement.length());
2847                     m_alternativeTextController-&gt;recordAutocorrectionResponse(AutocorrectionResponse::Accepted, replacedString, replacementRange.ptr());
2848 
2849                     // Add a marker so that corrections can easily be undone and won&#39;t be re-corrected.
2850                     m_alternativeTextController-&gt;markCorrection(replacementRange, replacedString);
2851                 }
2852             }
2853         }
2854     }
2855 
2856     if (selectionChanged) {
2857         TextCheckingParagraph extendedParagraph(WTFMove(paragraph));
2858         // Restore the caret position if we have made any replacements
2859         extendedParagraph.expandRangeToNextEnd();
2860         if (restoreSelectionAfterChange &amp;&amp; selectionOffset &gt;= 0 &amp;&amp; selectionOffset &lt;= extendedParagraph.rangeLength()) {
2861             auto selectionRange = extendedParagraph.subrange(0, selectionOffset);
2862             m_frame.selection().moveTo(selectionRange-&gt;endPosition(), DOWNSTREAM);
2863             if (adjustSelectionForParagraphBoundaries)
2864                 m_frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, CharacterGranularity);
2865         } else {
2866             // If this fails for any reason, the fallback is to go one position beyond the last replacement
2867             m_frame.selection().moveTo(m_frame.selection().selection().end());
2868             m_frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, CharacterGranularity);
2869         }
2870     }
2871 }
2872 
2873 void Editor::changeBackToReplacedString(const String&amp; replacedString)
2874 {
2875 #if !PLATFORM(IOS_FAMILY)
2876     ASSERT(unifiedTextCheckerEnabled());
2877 
2878     if (replacedString.isEmpty())
2879         return;
2880 
2881     RefPtr&lt;Range&gt; selection = selectedRange();
2882     if (!shouldInsertText(replacedString, selection.get(), EditorInsertAction::Pasted))
2883         return;
2884 
2885     m_alternativeTextController-&gt;recordAutocorrectionResponse(AutocorrectionResponse::Reverted, replacedString, selection.get());
2886     TextCheckingParagraph paragraph(*selection);
2887     replaceSelectionWithText(replacedString, SelectReplacement::No, SmartReplace::No, EditAction::Insert);
2888     auto changedRange = paragraph.subrange(paragraph.checkingStart(), replacedString.length());
2889     changedRange-&gt;startContainer().document().markers().addMarker(changedRange, DocumentMarker::Replacement, String());
2890     m_alternativeTextController-&gt;markReversed(changedRange);
2891 #else
2892     ASSERT_NOT_REACHED();
2893     UNUSED_PARAM(replacedString);
2894 #endif // !PLATFORM(IOS_FAMILY)
2895 }
2896 
2897 
2898 void Editor::markMisspellingsAndBadGrammar(const VisibleSelection&amp; spellingSelection, bool markGrammar, const VisibleSelection&amp; grammarSelection)
2899 {
<a name="24" id="anc24"></a>


2900     if (unifiedTextCheckerEnabled()) {
2901         if (!isContinuousSpellCheckingEnabled())
2902             return;
2903 
2904         // markMisspellingsAndBadGrammar() is triggered by selection change, in which case we check spelling and grammar, but don&#39;t autocorrect misspellings.
2905         OptionSet&lt;TextCheckingType&gt; textCheckingOptions { TextCheckingType::Spelling };
2906         if (markGrammar &amp;&amp; isGrammarCheckingEnabled())
2907             textCheckingOptions.add(TextCheckingType::Grammar);
2908         auto spellCheckingRange = spellingSelection.toNormalizedRange();
2909         markAllMisspellingsAndBadGrammarInRanges(textCheckingOptions, spellCheckingRange.copyRef(), spellCheckingRange.copyRef(), grammarSelection.toNormalizedRange());
2910         return;
2911     }
2912 
2913     RefPtr&lt;Range&gt; firstMisspellingRange;
2914     markMisspellings(spellingSelection, firstMisspellingRange);
2915     if (markGrammar)
2916         markBadGrammar(grammarSelection);
2917 }
2918 
2919 void Editor::unappliedSpellCorrection(const VisibleSelection&amp; selectionOfCorrected, const String&amp; corrected, const String&amp; correction)
2920 {
2921     m_alternativeTextController-&gt;respondToUnappliedSpellCorrection(selectionOfCorrected, corrected, correction);
2922 }
2923 
2924 void Editor::updateMarkersForWordsAffectedByEditing(bool doNotRemoveIfSelectionAtWordBoundary)
2925 {
2926     if (!document().markers().hasMarkers())
2927         return;
2928 
2929     if (!m_alternativeTextController-&gt;shouldRemoveMarkersUponEditing() &amp;&amp; (!textChecker() || textChecker()-&gt;shouldEraseMarkersAfterChangeSelection(TextCheckingType::Spelling)))
2930         return;
2931 
2932     // We want to remove the markers from a word if an editing command will change the word. This can happen in one of
2933     // several scenarios:
2934     // 1. Insert in the middle of a word.
2935     // 2. Appending non whitespace at the beginning of word.
2936     // 3. Appending non whitespace at the end of word.
2937     // Note that, appending only whitespaces at the beginning or end of word won&#39;t change the word, so we don&#39;t need to
2938     // remove the markers on that word.
2939     // Of course, if current selection is a range, we potentially will edit two words that fall on the boundaries of
2940     // selection, and remove words between the selection boundaries.
2941     //
2942     VisiblePosition startOfSelection = m_frame.selection().selection().start();
2943     VisiblePosition endOfSelection = m_frame.selection().selection().end();
2944     if (startOfSelection.isNull())
2945         return;
2946     // First word is the word that ends after or on the start of selection.
2947     VisiblePosition startOfFirstWord = startOfWord(startOfSelection, LeftWordIfOnBoundary);
2948     VisiblePosition endOfFirstWord = endOfWord(startOfSelection, LeftWordIfOnBoundary);
2949     // Last word is the word that begins before or on the end of selection
2950     VisiblePosition startOfLastWord = startOfWord(endOfSelection, RightWordIfOnBoundary);
2951     VisiblePosition endOfLastWord = endOfWord(endOfSelection, RightWordIfOnBoundary);
2952 
2953     if (startOfFirstWord.isNull()) {
2954         startOfFirstWord = startOfWord(startOfSelection, RightWordIfOnBoundary);
2955         endOfFirstWord = endOfWord(startOfSelection, RightWordIfOnBoundary);
2956     }
2957 
2958     if (endOfLastWord.isNull()) {
2959         startOfLastWord = startOfWord(endOfSelection, LeftWordIfOnBoundary);
2960         endOfLastWord = endOfWord(endOfSelection, LeftWordIfOnBoundary);
2961     }
2962 
2963     // If doNotRemoveIfSelectionAtWordBoundary is true, and first word ends at the start of selection,
2964     // we choose next word as the first word.
2965     if (doNotRemoveIfSelectionAtWordBoundary &amp;&amp; endOfFirstWord == startOfSelection) {
2966         startOfFirstWord = nextWordPosition(startOfFirstWord);
2967         endOfFirstWord = endOfWord(startOfFirstWord, RightWordIfOnBoundary);
2968         if (startOfFirstWord == endOfSelection)
2969             return;
2970     }
2971 
2972     // If doNotRemoveIfSelectionAtWordBoundary is true, and last word begins at the end of selection,
2973     // we choose previous word as the last word.
2974     if (doNotRemoveIfSelectionAtWordBoundary &amp;&amp; startOfLastWord == endOfSelection) {
2975         startOfLastWord = previousWordPosition(startOfLastWord);
2976         endOfLastWord = endOfWord(startOfLastWord, RightWordIfOnBoundary);
2977         if (endOfLastWord == startOfSelection)
2978             return;
2979     }
2980 
2981     if (startOfFirstWord.isNull() || endOfFirstWord.isNull() || startOfLastWord.isNull() || endOfLastWord.isNull())
2982         return;
2983 
2984     // Now we remove markers on everything between startOfFirstWord and endOfLastWord.
2985     // However, if an autocorrection change a single word to multiple words, we want to remove correction mark from all the
2986     // resulted words even we only edit one of them. For example, assuming autocorrection changes &quot;avantgarde&quot; to &quot;avant
2987     // garde&quot;, we will have CorrectionIndicator marker on both words and on the whitespace between them. If we then edit garde,
2988     // we would like to remove the marker from word &quot;avant&quot; and whitespace as well. So we need to get the continous range of
2989     // of marker that contains the word in question, and remove marker on that whole range.
2990     auto wordRange = Range::create(document(), startOfFirstWord.deepEquivalent(), endOfLastWord.deepEquivalent());
2991 
2992     Vector&lt;RenderedDocumentMarker*&gt; markers = document().markers().markersInRange(wordRange, DocumentMarker::DictationAlternatives);
2993     for (auto* marker : markers)
2994         m_alternativeTextController-&gt;removeDictationAlternativesForMarker(*marker);
2995 
2996     OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypesToRemove {
2997         DocumentMarker::CorrectionIndicator,
2998         DocumentMarker::DictationAlternatives,
2999         DocumentMarker::SpellCheckingExemption,
3000         DocumentMarker::Spelling,
3001 #if !PLATFORM(IOS_FAMILY)
3002         DocumentMarker::Grammar,
3003 #endif
3004     };
3005     document().markers().removeMarkers(wordRange, markerTypesToRemove, DocumentMarkerController::RemovePartiallyOverlappingMarker);
3006     document().markers().clearDescriptionOnMarkersIntersectingRange(wordRange, DocumentMarker::Replacement);
3007 }
3008 
3009 void Editor::deletedAutocorrectionAtPosition(const Position&amp; position, const String&amp; originalString)
3010 {
3011     m_alternativeTextController-&gt;deletedAutocorrectionAtPosition(position, originalString);
3012 }
3013 
3014 RefPtr&lt;Range&gt; Editor::rangeForPoint(const IntPoint&amp; windowPoint)
3015 {
3016     Document* document = m_frame.documentAtPoint(windowPoint);
3017     if (!document)
3018         return nullptr;
3019 
3020     Frame* frame = document-&gt;frame();
3021     ASSERT(frame);
3022     FrameView* frameView = frame-&gt;view();
3023     if (!frameView)
3024         return nullptr;
3025     IntPoint framePoint = frameView-&gt;windowToContents(windowPoint);
3026     VisibleSelection selection(frame-&gt;visiblePositionForPoint(framePoint));
3027 
3028     return selection.toNormalizedRange();
3029 }
3030 
3031 void Editor::revealSelectionAfterEditingOperation(const ScrollAlignment&amp; alignment, RevealExtentOption revealExtentOption)
3032 {
3033     if (m_ignoreSelectionChanges)
3034         return;
3035 
<a name="25" id="anc25"></a><span class="line-removed">3036 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">3037     SelectionRevealMode revealMode = SelectionRevealMode::RevealUpToMainFrame;</span>
<span class="line-removed">3038 #else</span>
3039     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;
<a name="26" id="anc26"></a><span class="line-removed">3040 #endif</span>
<span class="line-removed">3041 </span>
3042     m_frame.selection().revealSelection(revealMode, alignment, revealExtentOption);
3043 }
3044 
3045 void Editor::setIgnoreSelectionChanges(bool ignore, RevealSelection shouldRevealExistingSelection)
3046 {
3047     if (m_ignoreSelectionChanges == ignore)
3048         return;
3049 
3050     m_ignoreSelectionChanges = ignore;
3051 #if PLATFORM(IOS_FAMILY)
3052     // FIXME: Should suppress selection change notifications during a composition change &lt;https://webkit.org/b/38830&gt;
3053     if (!ignore)
3054         respondToChangedSelection(m_frame.selection().selection(), { });
3055 #endif
3056     if (!ignore &amp;&amp; shouldRevealExistingSelection == RevealSelection::Yes)
3057         revealSelectionAfterEditingOperation(ScrollAlignment::alignToEdgeIfNeeded, RevealExtent);
3058 }
3059 
3060 RefPtr&lt;Range&gt; Editor::compositionRange() const
3061 {
3062     if (!m_compositionNode)
3063         return nullptr;
3064     unsigned length = m_compositionNode-&gt;length();
3065     unsigned start = std::min(m_compositionStart, length);
3066     unsigned end = std::min(std::max(start, m_compositionEnd), length);
<a name="27" id="anc27"></a>
3067     if (start &gt;= end)
3068         return nullptr;
3069     return Range::create(m_compositionNode-&gt;document(), m_compositionNode.get(), start, m_compositionNode.get(), end);
3070 }
3071 
3072 bool Editor::getCompositionSelection(unsigned&amp; selectionStart, unsigned&amp; selectionEnd) const
3073 {
3074     if (!m_compositionNode)
3075         return false;
3076     const VisibleSelection&amp; selection = m_frame.selection().selection();
3077     Position start = selection.start();
3078     if (start.deprecatedNode() != m_compositionNode)
3079         return false;
3080     Position end = selection.end();
3081     if (end.deprecatedNode() != m_compositionNode)
3082         return false;
3083 
3084     if (static_cast&lt;unsigned&gt;(start.deprecatedEditingOffset()) &lt; m_compositionStart)
3085         return false;
3086     if (static_cast&lt;unsigned&gt;(end.deprecatedEditingOffset()) &gt; m_compositionEnd)
3087         return false;
3088 
3089     selectionStart = start.deprecatedEditingOffset() - m_compositionStart;
3090     selectionEnd = start.deprecatedEditingOffset() - m_compositionEnd;
3091     return true;
3092 }
3093 
3094 void Editor::transpose()
3095 {
3096     if (!canEdit())
3097         return;
3098 
3099     VisibleSelection selection = m_frame.selection().selection();
3100     if (!selection.isCaret())
3101         return;
3102 
3103     // Make a selection that goes back one character and forward two characters.
3104     VisiblePosition caret = selection.visibleStart();
3105     VisiblePosition next = isEndOfParagraph(caret) ? caret : caret.next();
3106     VisiblePosition previous = next.previous();
3107     if (next == previous)
3108         return;
3109     previous = previous.previous();
3110     if (!inSameParagraph(next, previous))
3111         return;
3112     RefPtr&lt;Range&gt; range = makeRange(previous, next);
3113     if (!range)
3114         return;
3115     VisibleSelection newSelection(*range, DOWNSTREAM);
3116 
3117     // Transpose the two characters.
3118     String text = plainText(range.get());
3119     if (text.length() != 2)
3120         return;
3121     String transposed = text.right(1) + text.left(1);
3122 
3123     // Select the two characters.
3124     if (newSelection != m_frame.selection().selection()) {
3125         if (!m_frame.selection().shouldChangeSelection(newSelection))
3126             return;
3127         m_frame.selection().setSelection(newSelection);
3128     }
3129 
3130     // Insert the transposed characters.
3131     if (!shouldInsertText(transposed, range.get(), EditorInsertAction::Typed))
3132         return;
3133     replaceSelectionWithText(transposed, SelectReplacement::No, SmartReplace::No, EditAction::Insert);
3134 }
3135 
3136 void Editor::addRangeToKillRing(const Range&amp; range, KillRingInsertionMode mode)
3137 {
3138     addTextToKillRing(plainText(&amp;range), mode);
3139 }
3140 
3141 void Editor::addTextToKillRing(const String&amp; text, KillRingInsertionMode mode)
3142 {
3143     if (m_shouldStartNewKillRingSequence)
3144         killRing().startNewSequence();
3145 
3146     m_shouldStartNewKillRingSequence = false;
3147 
3148     // If the kill was from a backwards motion, prepend to the kill ring.
3149     // This will ensure that alternating forward and backward kills will
3150     // build up the original string in the kill ring without permuting it.
3151     switch (mode) {
3152     case KillRingInsertionMode::PrependText:
3153         killRing().prepend(text);
3154         break;
3155     case KillRingInsertionMode::AppendText:
3156         killRing().append(text);
3157         break;
3158     }
3159 }
3160 
3161 void Editor::startAlternativeTextUITimer()
3162 {
3163     m_alternativeTextController-&gt;startAlternativeTextUITimer(AlternativeTextTypeCorrection);
3164 }
3165 
3166 void Editor::handleAlternativeTextUIResult(const String&amp; correction)
3167 {
3168     m_alternativeTextController-&gt;handleAlternativeTextUIResult(correction);
3169 }
3170 
3171 
3172 void Editor::dismissCorrectionPanelAsIgnored()
3173 {
3174     m_alternativeTextController-&gt;dismiss(ReasonForDismissingAlternativeTextIgnored);
3175 }
3176 
3177 void Editor::changeSelectionAfterCommand(const VisibleSelection&amp; newSelection, OptionSet&lt;FrameSelection::SetSelectionOption&gt; options)
3178 {
3179     Ref&lt;Frame&gt; protection(m_frame);
3180 
3181     // If the new selection is orphaned, then don&#39;t update the selection.
3182     if (newSelection.start().isOrphan() || newSelection.end().isOrphan())
3183         return;
3184 
3185     // If there is no selection change, don&#39;t bother sending shouldChangeSelection, but still call setSelection,
3186     // because there is work that it must do in this situation.
3187     // The old selection can be invalid here and calling shouldChangeSelection can produce some strange calls.
3188     // See &lt;rdar://problem/5729315&gt; Some shouldChangeSelectedDOMRange contain Ranges for selections that are no longer valid
3189     bool selectionDidNotChangeDOMPosition = newSelection == m_frame.selection().selection();
3190     if (selectionDidNotChangeDOMPosition || m_frame.selection().shouldChangeSelection(newSelection))
3191         m_frame.selection().setSelection(newSelection, options);
3192 
3193     // Some editing operations change the selection visually without affecting its position within the DOM.
3194     // For example when you press return in the following (the caret is marked by ^):
3195     // &lt;div contentEditable=&quot;true&quot;&gt;&lt;div&gt;^Hello&lt;/div&gt;&lt;/div&gt;
3196     // WebCore inserts &lt;div&gt;&lt;br&gt;&lt;/div&gt; *before* the current block, which correctly moves the paragraph down but which doesn&#39;t
3197     // change the caret&#39;s DOM position ([&quot;hello&quot;, 0]). In these situations the above FrameSelection::setSelection call
3198     // does not call EditorClient::respondToChangedSelection(), which, on the Mac, sends selection change notifications and
3199     // starts a new kill ring sequence, but we want to do these things (matches AppKit).
3200 #if PLATFORM(IOS_FAMILY)
3201     // FIXME: Should suppress selection change notifications during a composition change &lt;https://webkit.org/b/38830&gt;
3202     if (m_ignoreSelectionChanges)
3203         return;
3204 #endif
3205     if (selectionDidNotChangeDOMPosition &amp;&amp; client())
3206         client()-&gt;respondToChangedSelection(&amp;m_frame);
3207 }
3208 
3209 String Editor::selectedText() const
3210 {
3211     TextIteratorBehavior behavior = TextIteratorDefaultBehavior;
3212     if (m_frame.settings().selectionAcrossShadowBoundariesEnabled())
3213         behavior |= TextIteratorTraversesFlatTree;
3214     return selectedText(behavior);
3215 }
3216 
3217 String Editor::selectedTextForDataTransfer() const
3218 {
3219     TextIteratorBehavior behavior = TextIteratorEmitsImageAltText;
3220     if (m_frame.settings().selectionAcrossShadowBoundariesEnabled())
3221         behavior |= TextIteratorTraversesFlatTree;
3222     return selectedText(behavior);
3223 }
3224 
3225 String Editor::selectedText(TextIteratorBehavior behavior) const
3226 {
3227     // We remove &#39;\0&#39; characters because they are not visibly rendered to the user.
3228     auto&amp; selection = m_frame.selection().selection();
3229     return plainText(selection.start(), selection.end(), behavior).replaceWithLiteral(&#39;\0&#39;, &quot;&quot;);
3230 }
3231 
3232 static inline void collapseCaretWidth(IntRect&amp; rect)
3233 {
3234     // FIXME: Width adjustment doesn&#39;t work for rotated text.
3235     if (rect.width() == caretWidth)
3236         rect.setWidth(0);
3237     else if (rect.height() == caretWidth)
3238         rect.setHeight(0);
3239 }
3240 
3241 IntRect Editor::firstRectForRange(Range* range) const
3242 {
3243     VisiblePosition startVisiblePosition(range-&gt;startPosition(), DOWNSTREAM);
3244 
3245     if (range-&gt;collapsed()) {
3246         // FIXME: Getting caret rect and removing caret width is a very roundabout way to get collapsed range location.
3247         // In particular, width adjustment doesn&#39;t work for rotated text.
3248         IntRect startCaretRect = RenderedPosition(startVisiblePosition).absoluteRect();
3249         collapseCaretWidth(startCaretRect);
3250         return startCaretRect;
3251     }
3252 
3253     VisiblePosition endVisiblePosition(range-&gt;endPosition(), UPSTREAM);
3254 
3255     if (inSameLine(startVisiblePosition, endVisiblePosition))
3256         return enclosingIntRect(RenderObject::absoluteBoundingBoxRectForRange(range));
3257 
3258     LayoutUnit extraWidthToEndOfLine;
3259     IntRect startCaretRect = RenderedPosition(startVisiblePosition).absoluteRect(&amp;extraWidthToEndOfLine);
3260     if (startCaretRect == IntRect())
3261         return IntRect();
3262 
3263     // When start and end aren&#39;t on the same line, we want to go from start to the end of its line.
3264     bool textIsHorizontal = startCaretRect.width() == caretWidth;
3265     return textIsHorizontal ?
3266         IntRect(startCaretRect.x(),
3267             startCaretRect.y(),
3268             startCaretRect.width() + extraWidthToEndOfLine,
3269             startCaretRect.height()) :
3270         IntRect(startCaretRect.x(),
3271             startCaretRect.y(),
3272             startCaretRect.width(),
3273             startCaretRect.height() + extraWidthToEndOfLine);
3274 }
3275 
3276 bool Editor::shouldChangeSelection(const VisibleSelection&amp; oldSelection, const VisibleSelection&amp; newSelection, EAffinity affinity, bool stillSelecting) const
3277 {
3278 #if PLATFORM(IOS_FAMILY)
3279     if (m_frame.selectionChangeCallbacksDisabled())
3280         return true;
3281 #endif
3282     return client() &amp;&amp; client()-&gt;shouldChangeSelectedRange(oldSelection.toNormalizedRange().get(), newSelection.toNormalizedRange().get(), affinity, stillSelecting);
3283 }
3284 
3285 void Editor::computeAndSetTypingStyle(EditingStyle&amp; style, EditAction editingAction)
3286 {
3287     if (style.isEmpty()) {
3288         m_frame.selection().clearTypingStyle();
3289         return;
3290     }
3291 
3292     // Calculate the current typing style.
3293     RefPtr&lt;EditingStyle&gt; typingStyle;
3294     if (auto existingTypingStyle = m_frame.selection().typingStyle())
3295         typingStyle = existingTypingStyle-&gt;copy();
3296     else
3297         typingStyle = EditingStyle::create();
3298     typingStyle-&gt;overrideTypingStyleAt(style, m_frame.selection().selection().visibleStart().deepEquivalent());
3299 
3300     // Handle block styles, substracting these from the typing style.
3301     RefPtr&lt;EditingStyle&gt; blockStyle = typingStyle-&gt;extractAndRemoveBlockProperties();
3302     if (!blockStyle-&gt;isEmpty())
3303         ApplyStyleCommand::create(document(), blockStyle.get(), editingAction)-&gt;apply();
3304 
3305     // Set the remaining style as the typing style.
3306     m_frame.selection().setTypingStyle(WTFMove(typingStyle));
3307 }
3308 
3309 void Editor::computeAndSetTypingStyle(StyleProperties&amp; properties, EditAction editingAction)
3310 {
3311     return computeAndSetTypingStyle(EditingStyle::create(&amp;properties), editingAction);
3312 }
3313 
3314 void Editor::textFieldDidBeginEditing(Element* e)
3315 {
3316     if (client())
3317         client()-&gt;textFieldDidBeginEditing(e);
3318 }
3319 
3320 void Editor::textFieldDidEndEditing(Element* e)
3321 {
3322     dismissCorrectionPanelAsIgnored();
3323     if (client())
3324         client()-&gt;textFieldDidEndEditing(e);
3325 }
3326 
3327 void Editor::textDidChangeInTextField(Element* e)
3328 {
3329     if (client())
3330         client()-&gt;textDidChangeInTextField(e);
3331 }
3332 
3333 bool Editor::doTextFieldCommandFromEvent(Element* e, KeyboardEvent* ke)
3334 {
3335     if (client())
3336         return client()-&gt;doTextFieldCommandFromEvent(e, ke);
3337 
3338     return false;
3339 }
3340 
3341 void Editor::textWillBeDeletedInTextField(Element* input)
3342 {
3343     if (client())
3344         client()-&gt;textWillBeDeletedInTextField(input);
3345 }
3346 
3347 void Editor::textDidChangeInTextArea(Element* e)
3348 {
3349     if (client())
3350         client()-&gt;textDidChangeInTextArea(e);
3351 }
3352 
3353 void Editor::applyEditingStyleToBodyElement() const
3354 {
3355     auto collection = document().getElementsByTagName(HTMLNames::bodyTag-&gt;localName());
3356     unsigned length = collection-&gt;length();
3357     for (unsigned i = 0; i &lt; length; ++i)
3358         applyEditingStyleToElement(collection-&gt;item(i));
3359 }
3360 
3361 void Editor::applyEditingStyleToElement(Element* element) const
3362 {
3363     ASSERT(!element || is&lt;StyledElement&gt;(*element));
3364     if (!is&lt;StyledElement&gt;(element))
3365         return;
3366 
3367     // Mutate using the CSSOM wrapper so we get the same event behavior as a script.
3368     auto&amp; style = downcast&lt;StyledElement&gt;(*element).cssomStyle();
3369     style.setPropertyInternal(CSSPropertyWordWrap, &quot;break-word&quot;, false);
3370     style.setPropertyInternal(CSSPropertyWebkitNbspMode, &quot;space&quot;, false);
3371     style.setPropertyInternal(CSSPropertyLineBreak, &quot;after-white-space&quot;, false);
3372 }
3373 
3374 bool Editor::findString(const String&amp; target, FindOptions options)
3375 {
3376     Ref&lt;Frame&gt; protection(m_frame);
3377 
3378     VisibleSelection selection = m_frame.selection().selection();
3379 
3380     RefPtr&lt;Range&gt; resultRange = rangeOfString(target, selection.firstRange().get(), options);
3381 
3382     if (!resultRange)
3383         return false;
3384 
3385     m_frame.selection().setSelection(VisibleSelection(*resultRange, DOWNSTREAM));
3386 
3387     if (!(options.contains(DoNotRevealSelection)))
3388         m_frame.selection().revealSelection();
3389 
3390     return true;
3391 }
3392 
3393 RefPtr&lt;Range&gt; Editor::rangeOfString(const String&amp; target, Range* referenceRange, FindOptions options)
3394 {
3395     if (target.isEmpty())
3396         return nullptr;
3397 
3398     // Start from an edge of the reference range, if there&#39;s a reference range that&#39;s not in shadow content. Which edge
3399     // is used depends on whether we&#39;re searching forward or backward, and whether startInSelection is set.
3400     RefPtr&lt;Range&gt; searchRange(rangeOfContents(document()));
3401 
3402     bool forward = !options.contains(Backwards);
3403     bool startInReferenceRange = referenceRange &amp;&amp; options.contains(StartInSelection);
3404     if (referenceRange) {
3405         if (forward)
3406             searchRange-&gt;setStart(startInReferenceRange ? referenceRange-&gt;startPosition() : referenceRange-&gt;endPosition());
3407         else
3408             searchRange-&gt;setEnd(startInReferenceRange ? referenceRange-&gt;endPosition() : referenceRange-&gt;startPosition());
3409     }
3410 
3411     RefPtr&lt;ShadowRoot&gt; shadowTreeRoot = referenceRange ? referenceRange-&gt;startContainer().containingShadowRoot() : nullptr;
3412     if (shadowTreeRoot) {
3413         if (forward)
3414             searchRange-&gt;setEnd(*shadowTreeRoot, shadowTreeRoot-&gt;countChildNodes());
3415         else
3416             searchRange-&gt;setStart(*shadowTreeRoot, 0);
3417     }
3418 
3419     RefPtr&lt;Range&gt; resultRange = findPlainText(*searchRange, target, options);
3420     // If we started in the reference range and the found range exactly matches the reference range, find again.
3421     // Build a selection with the found range to remove collapsed whitespace.
3422     // Compare ranges instead of selection objects to ignore the way that the current selection was made.
3423     if (startInReferenceRange &amp;&amp; areRangesEqual(VisibleSelection(*resultRange).toNormalizedRange().get(), referenceRange)) {
3424         searchRange = rangeOfContents(document());
3425         if (forward)
3426             searchRange-&gt;setStart(referenceRange-&gt;endPosition());
3427         else
3428             searchRange-&gt;setEnd(referenceRange-&gt;startPosition());
3429 
3430         if (shadowTreeRoot) {
3431             if (forward)
3432                 searchRange-&gt;setEnd(*shadowTreeRoot, shadowTreeRoot-&gt;countChildNodes());
3433             else
3434                 searchRange-&gt;setStart(*shadowTreeRoot, 0);
3435         }
3436 
3437         resultRange = findPlainText(*searchRange, target, options);
3438     }
3439 
3440     // If nothing was found in the shadow tree, search in main content following the shadow tree.
3441     if (resultRange-&gt;collapsed() &amp;&amp; shadowTreeRoot) {
3442         searchRange = rangeOfContents(document());
3443         if (shadowTreeRoot-&gt;shadowHost()) {
3444             if (forward)
3445                 searchRange-&gt;setStartAfter(*shadowTreeRoot-&gt;shadowHost());
3446             else
3447                 searchRange-&gt;setEndBefore(*shadowTreeRoot-&gt;shadowHost());
3448         }
3449 
3450         resultRange = findPlainText(*searchRange, target, options);
3451     }
3452 
3453     // If we didn&#39;t find anything and we&#39;re wrapping, search again in the entire document (this will
3454     // redundantly re-search the area already searched in some cases).
3455     if (resultRange-&gt;collapsed() &amp;&amp; options.contains(WrapAround)) {
3456         searchRange = rangeOfContents(document());
3457         resultRange = findPlainText(*searchRange, target, options);
3458         // We used to return false here if we ended up with the same range that we started with
3459         // (e.g., the reference range was already the only instance of this text). But we decided that
3460         // this should be a success case instead, so we&#39;ll just fall through in that case.
3461     }
3462 
3463     return resultRange-&gt;collapsed() ? nullptr : resultRange;
3464 }
3465 
3466 static bool isFrameInRange(Frame&amp; frame, Range&amp; range)
3467 {
3468     for (auto* ownerElement = frame.ownerElement(); ownerElement; ownerElement = ownerElement-&gt;document().ownerElement()) {
3469         if (&amp;ownerElement-&gt;document() == &amp;range.ownerDocument()) {
3470             auto result = range.intersectsNode(*ownerElement);
3471             return !result.hasException() &amp;&amp; result.releaseReturnValue();
3472         }
3473     }
3474     return false;
3475 }
3476 
3477 unsigned Editor::countMatchesForText(const String&amp; target, Range* range, FindOptions options, unsigned limit, bool markMatches, Vector&lt;RefPtr&lt;Range&gt;&gt;* matches)
3478 {
3479     if (target.isEmpty())
3480         return 0;
3481 
3482     RefPtr&lt;Range&gt; searchRange;
3483     if (range) {
3484         if (&amp;range-&gt;ownerDocument() == &amp;document())
3485             searchRange = range;
3486         else if (!isFrameInRange(m_frame, *range))
3487             return 0;
3488     }
3489     if (!searchRange)
3490         searchRange = rangeOfContents(document());
3491 
3492     Node&amp; originalEndContainer = searchRange-&gt;endContainer();
3493     int originalEndOffset = searchRange-&gt;endOffset();
3494 
3495     unsigned matchCount = 0;
3496     do {
3497         auto resultRange = findPlainText(*searchRange, target, options - Backwards);
3498         if (resultRange-&gt;collapsed()) {
3499             if (!resultRange-&gt;startContainer().isInShadowTree())
3500                 break;
3501 
3502             searchRange-&gt;setStartAfter(*resultRange-&gt;startContainer().shadowHost());
3503             searchRange-&gt;setEnd(originalEndContainer, originalEndOffset);
3504             continue;
3505         }
3506 
3507         ++matchCount;
3508         if (matches)
3509             matches-&gt;append(resultRange.ptr());
3510 
3511         if (markMatches)
3512             document().markers().addMarker(resultRange, DocumentMarker::TextMatch);
3513 
3514         // Stop looking if we hit the specified limit. A limit of 0 means no limit.
3515         if (limit &gt; 0 &amp;&amp; matchCount &gt;= limit)
3516             break;
3517 
3518         // Set the new start for the search range to be the end of the previous
3519         // result range. There is no need to use a VisiblePosition here,
3520         // since findPlainText will use a TextIterator to go over the visible
3521         // text nodes.
3522         searchRange-&gt;setStart(resultRange-&gt;endContainer(), resultRange-&gt;endOffset());
3523 
3524         Node* shadowTreeRoot = searchRange-&gt;shadowRoot();
3525         if (searchRange-&gt;collapsed() &amp;&amp; shadowTreeRoot)
3526             searchRange-&gt;setEnd(*shadowTreeRoot, shadowTreeRoot-&gt;countChildNodes());
3527     } while (true);
3528 
3529     return matchCount;
3530 }
3531 
3532 void Editor::setMarkedTextMatchesAreHighlighted(bool flag)
3533 {
3534     if (flag == m_areMarkedTextMatchesHighlighted)
3535         return;
3536 
3537     m_areMarkedTextMatchesHighlighted = flag;
3538     document().markers().repaintMarkers(DocumentMarker::TextMatch);
3539 }
3540 
3541 #if !PLATFORM(MAC)
3542 void Editor::selectionWillChange()
3543 {
3544 }
3545 #endif
3546 
3547 void Editor::respondToChangedSelection(const VisibleSelection&amp;, OptionSet&lt;FrameSelection::SetSelectionOption&gt; options)
3548 {
3549 #if PLATFORM(IOS_FAMILY)
3550     // FIXME: Should suppress selection change notifications during a composition change &lt;https://webkit.org/b/38830&gt;
3551     if (m_ignoreSelectionChanges)
3552         return;
3553 #endif
3554 
3555     if (client())
3556         client()-&gt;respondToChangedSelection(&amp;m_frame);
3557 
3558 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
3559     if (shouldDetectTelephoneNumbers())
3560         m_telephoneNumberDetectionUpdateTimer.startOneShot(0_s);
3561 #endif
3562 
3563     setStartNewKillRingSequence(true);
3564 
3565     if (m_editorUIUpdateTimer.isActive())
3566         return;
3567 
3568     // Don&#39;t check spelling and grammar if the change of selection is triggered by spelling correction itself.
3569     m_editorUIUpdateTimerShouldCheckSpellingAndGrammar = options.contains(FrameSelection::CloseTyping) &amp;&amp; !options.contains(FrameSelection::SpellCorrectionTriggered);
3570     m_editorUIUpdateTimerWasTriggeredByDictation = options.contains(FrameSelection::DictationTriggered);
3571     scheduleEditorUIUpdate();
3572 }
3573 
3574 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
3575 
3576 bool Editor::shouldDetectTelephoneNumbers()
3577 {
3578     if (!m_frame.document())
3579         return false;
3580     return document().isTelephoneNumberParsingEnabled() &amp;&amp; TelephoneNumberDetector::isSupported();
3581 }
3582 
3583 void Editor::scanSelectionForTelephoneNumbers()
3584 {
3585     if (!shouldDetectTelephoneNumbers() || !client())
3586         return;
3587 
3588     m_detectedTelephoneNumberRanges.clear();
3589 
3590     Vector&lt;RefPtr&lt;Range&gt;&gt; markedRanges;
3591 
3592     FrameSelection&amp; frameSelection = m_frame.selection();
3593     if (!frameSelection.isRange()) {
3594         if (auto* page = m_frame.page())
3595             page-&gt;servicesOverlayController().selectedTelephoneNumberRangesChanged();
3596         return;
3597     }
3598     RefPtr&lt;Range&gt; selectedRange = frameSelection.toNormalizedRange();
3599 
3600     // Extend the range a few characters in each direction to detect incompletely selected phone numbers.
3601     static const int charactersToExtend = 15;
3602     const VisibleSelection&amp; visibleSelection = frameSelection.selection();
3603     Position start = visibleSelection.start();
3604     Position end = visibleSelection.end();
3605     for (int i = 0; i &lt; charactersToExtend; ++i) {
3606         start = start.previous(Character);
3607         end = end.next(Character);
3608     }
3609 
3610     FrameSelection extendedSelection;
3611     extendedSelection.setStart(start);
3612     extendedSelection.setEnd(end);
3613     RefPtr&lt;Range&gt; extendedRange = extendedSelection.toNormalizedRange();
3614 
3615     if (!extendedRange) {
3616         if (auto* page = m_frame.page())
3617             page-&gt;servicesOverlayController().selectedTelephoneNumberRangesChanged();
3618         return;
3619     }
3620 
3621     scanRangeForTelephoneNumbers(*extendedRange, extendedRange-&gt;text(), markedRanges);
3622 
3623     // Only consider ranges with a detected telephone number if they overlap with the actual selection range.
3624     for (auto&amp; range : markedRanges) {
3625         if (rangesOverlap(range.get(), selectedRange.get()))
3626             m_detectedTelephoneNumberRanges.append(range);
3627     }
3628 
3629     if (auto* page = m_frame.page())
3630         page-&gt;servicesOverlayController().selectedTelephoneNumberRangesChanged();
3631 }
3632 
3633 void Editor::scanRangeForTelephoneNumbers(Range&amp; range, const StringView&amp; stringView, Vector&lt;RefPtr&lt;Range&gt;&gt;&amp; markedRanges)
3634 {
3635     // Don&#39;t scan for phone numbers inside editable regions.
3636     Node&amp; startNode = range.startContainer();
3637     if (startNode.hasEditableStyle())
3638         return;
3639 
3640     // relativeStartPosition and relativeEndPosition are the endpoints of the phone number range,
3641     // relative to the scannerPosition
3642     unsigned length = stringView.length();
3643     unsigned scannerPosition = 0;
3644     int relativeStartPosition = 0;
3645     int relativeEndPosition = 0;
3646 
3647     auto characters = stringView.upconvertedCharacters();
3648 
3649     while (scannerPosition &lt; length &amp;&amp; TelephoneNumberDetector::find(&amp;characters[scannerPosition], length - scannerPosition, &amp;relativeStartPosition, &amp;relativeEndPosition)) {
3650         // The convention in the Data Detectors framework is that the end position is the first character NOT in the phone number
3651         // (that is, the length of the range is relativeEndPosition - relativeStartPosition). So subtract 1 to get the same
3652         // convention as the old WebCore phone number parser (so that the rest of the code is still valid if we want to go back
3653         // to the old parser).
3654         --relativeEndPosition;
3655 
3656         ASSERT(scannerPosition + relativeEndPosition &lt; length);
3657 
3658         unsigned subrangeOffset = scannerPosition + relativeStartPosition;
3659         unsigned subrangeLength = relativeEndPosition - relativeStartPosition + 1;
3660 
3661         auto subrange = TextIterator::subrange(range, subrangeOffset, subrangeLength);
3662 
3663         markedRanges.append(subrange.ptr());
3664         range.ownerDocument().markers().addMarker(subrange, DocumentMarker::TelephoneNumber);
3665 
3666         scannerPosition += relativeEndPosition + 1;
3667     }
3668 }
3669 
3670 #endif // ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
3671 
3672 void Editor::updateEditorUINowIfScheduled()
3673 {
3674     if (!m_editorUIUpdateTimer.isActive())
3675         return;
3676     m_editorUIUpdateTimer.stop();
3677     editorUIUpdateTimerFired();
3678 }
3679 
3680 void Editor::editorUIUpdateTimerFired()
3681 {
3682     VisibleSelection oldSelection = m_oldSelectionForEditorUIUpdate;
3683 
3684     m_alternativeTextController-&gt;stopPendingCorrection(oldSelection);
3685 
3686     bool isContinuousSpellCheckingEnabled = this-&gt;isContinuousSpellCheckingEnabled();
3687     bool isContinuousGrammarCheckingEnabled = isContinuousSpellCheckingEnabled &amp;&amp; isGrammarCheckingEnabled();
3688     if (isContinuousSpellCheckingEnabled) {
3689         VisibleSelection newAdjacentWords;
3690         VisibleSelection newSelectedSentence;
3691         bool caretBrowsing = m_frame.settings().caretBrowsingEnabled();
3692         if (m_frame.selection().selection().isContentEditable() || caretBrowsing) {
3693             VisiblePosition newStart(m_frame.selection().selection().visibleStart());
3694 #if !PLATFORM(IOS_FAMILY)
3695             newAdjacentWords = VisibleSelection(startOfWord(newStart, LeftWordIfOnBoundary), endOfWord(newStart, RightWordIfOnBoundary));
3696 #else
3697             // If this bug gets fixed, this PLATFORM(IOS_FAMILY) code could be removed:
3698             // &lt;rdar://problem/7259611&gt; Word boundary code on iPhone gives different results than desktop
3699             EWordSide startWordSide = LeftWordIfOnBoundary;
3700             UChar32 c = newStart.characterBefore();
3701             // FIXME: VisiblePosition::characterAfter() and characterBefore() do not emit newlines the same
3702             // way as TextIterator, so we do an isStartOfParagraph check here.
3703             if (isSpaceOrNewline(c) || c == noBreakSpace || isStartOfParagraph(newStart)) {
3704                 startWordSide = RightWordIfOnBoundary;
3705             }
3706             newAdjacentWords = VisibleSelection(startOfWord(newStart, startWordSide), endOfWord(newStart, RightWordIfOnBoundary));
3707 #endif // !PLATFORM(IOS_FAMILY)
3708             if (isContinuousGrammarCheckingEnabled)
3709                 newSelectedSentence = VisibleSelection(startOfSentence(newStart), endOfSentence(newStart));
3710         }
3711 
3712         // When typing we check spelling elsewhere, so don&#39;t redo it here.
3713         // If this is a change in selection resulting from a delete operation,
3714         // oldSelection may no longer be in the document.
3715         if (m_editorUIUpdateTimerShouldCheckSpellingAndGrammar &amp;&amp; oldSelection.isContentEditable() &amp;&amp; oldSelection.start().deprecatedNode() &amp;&amp; oldSelection.start().anchorNode()-&gt;isConnected()) {
3716             VisiblePosition oldStart(oldSelection.visibleStart());
3717             VisibleSelection oldAdjacentWords = VisibleSelection(startOfWord(oldStart, LeftWordIfOnBoundary), endOfWord(oldStart, RightWordIfOnBoundary));
3718             if (oldAdjacentWords != newAdjacentWords) {
3719                 if (isContinuousGrammarCheckingEnabled) {
3720                     VisibleSelection oldSelectedSentence = VisibleSelection(startOfSentence(oldStart), endOfSentence(oldStart));
3721                     markMisspellingsAndBadGrammar(oldAdjacentWords, oldSelectedSentence != newSelectedSentence, oldSelectedSentence);
3722                 } else
3723                     markMisspellingsAndBadGrammar(oldAdjacentWords, false, oldAdjacentWords);
3724             }
3725         }
3726 
3727         if (!textChecker() || textChecker()-&gt;shouldEraseMarkersAfterChangeSelection(TextCheckingType::Spelling)) {
3728             if (RefPtr&lt;Range&gt; wordRange = newAdjacentWords.toNormalizedRange())
3729                 document().markers().removeMarkers(*wordRange, DocumentMarker::Spelling);
3730         }
3731         if (!textChecker() || textChecker()-&gt;shouldEraseMarkersAfterChangeSelection(TextCheckingType::Grammar)) {
3732             if (RefPtr&lt;Range&gt; sentenceRange = newSelectedSentence.toNormalizedRange())
3733                 document().markers().removeMarkers(*sentenceRange, DocumentMarker::Grammar);
3734         }
3735     }
3736 
3737     // When continuous spell checking is off, existing markers disappear after the selection changes.
3738     if (!isContinuousSpellCheckingEnabled)
3739         document().markers().removeMarkers(DocumentMarker::Spelling);
3740     if (!isContinuousGrammarCheckingEnabled)
3741         document().markers().removeMarkers(DocumentMarker::Grammar);
3742 
3743     if (!m_editorUIUpdateTimerWasTriggeredByDictation)
3744         m_alternativeTextController-&gt;respondToChangedSelection(oldSelection);
3745 
3746     m_oldSelectionForEditorUIUpdate = m_frame.selection().selection();
3747 
3748 #if ENABLE(ATTACHMENT_ELEMENT)
3749     notifyClientOfAttachmentUpdates();
3750 #endif
3751 }
3752 
3753 static Node* findFirstMarkable(Node* node)
3754 {
3755     while (node) {
3756         if (!node-&gt;renderer())
3757             return nullptr;
3758         if (node-&gt;renderer()-&gt;isTextOrLineBreak())
3759             return node;
3760         if (is&lt;Element&gt;(*node) &amp;&amp; downcast&lt;Element&gt;(*node).isTextField())
3761             node = downcast&lt;HTMLTextFormControlElement&gt;(*node).visiblePositionForIndex(1).deepEquivalent().deprecatedNode();
3762         else if (node-&gt;firstChild())
3763             node = node-&gt;firstChild();
3764         else
3765             node = node-&gt;nextSibling();
3766     }
3767 
3768     return nullptr;
3769 }
3770 
3771 bool Editor::selectionStartHasMarkerFor(DocumentMarker::MarkerType markerType, int from, int length) const
3772 {
3773     Node* node = findFirstMarkable(m_frame.selection().selection().start().deprecatedNode());
3774     if (!node)
3775         return false;
3776 
3777     unsigned int startOffset = static_cast&lt;unsigned int&gt;(from);
3778     unsigned int endOffset = static_cast&lt;unsigned int&gt;(from + length);
3779     Vector&lt;RenderedDocumentMarker*&gt; markers = document().markers().markersFor(*node);
3780     for (auto* marker : markers) {
3781         if (marker-&gt;startOffset() &lt;= startOffset &amp;&amp; endOffset &lt;= marker-&gt;endOffset() &amp;&amp; marker-&gt;type() == markerType)
3782             return true;
3783     }
3784 
3785     return false;
3786 }
3787 
3788 OptionSet&lt;TextCheckingType&gt; Editor::resolveTextCheckingTypeMask(const Node&amp; rootEditableElement, OptionSet&lt;TextCheckingType&gt; textCheckingOptions)
3789 {
3790 #if USE(AUTOMATIC_TEXT_REPLACEMENT) &amp;&amp; !PLATFORM(IOS_FAMILY)
3791     bool onlyAllowsTextReplacement = false;
3792     if (auto* host = rootEditableElement.shadowHost())
3793         onlyAllowsTextReplacement = is&lt;HTMLInputElement&gt;(host) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*host).isSpellcheckDisabledExceptTextReplacement();
3794     if (onlyAllowsTextReplacement)
3795         textCheckingOptions = textCheckingOptions &amp; TextCheckingType::Replacement;
3796 #else
3797     UNUSED_PARAM(rootEditableElement);
3798 #endif
3799 
3800     bool shouldMarkSpelling = textCheckingOptions.contains(TextCheckingType::Spelling);
3801     bool shouldMarkGrammar = textCheckingOptions.contains(TextCheckingType::Grammar);
3802 #if !PLATFORM(IOS_FAMILY)
3803     bool shouldShowCorrectionPanel = textCheckingOptions.contains(TextCheckingType::ShowCorrectionPanel);
3804     bool shouldCheckForCorrection = shouldShowCorrectionPanel || textCheckingOptions.contains(TextCheckingType::Correction);
3805 #endif
3806 
3807     OptionSet&lt;TextCheckingType&gt; checkingTypes;
3808     if (shouldMarkSpelling)
3809         checkingTypes.add(TextCheckingType::Spelling);
3810     if (shouldMarkGrammar)
3811         checkingTypes.add(TextCheckingType::Grammar);
3812 #if !PLATFORM(IOS_FAMILY)
3813     if (shouldCheckForCorrection)
3814         checkingTypes.add(TextCheckingType::Correction);
3815     if (shouldShowCorrectionPanel)
3816         checkingTypes.add(TextCheckingType::ShowCorrectionPanel);
3817 
3818 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
3819     bool shouldPerformReplacement = textCheckingOptions.contains(TextCheckingType::Replacement);
3820     if (shouldPerformReplacement) {
3821         if (!onlyAllowsTextReplacement) {
3822             if (isAutomaticLinkDetectionEnabled())
3823                 checkingTypes.add(TextCheckingType::Link);
3824             if (isAutomaticQuoteSubstitutionEnabled())
3825                 checkingTypes.add(TextCheckingType::Quote);
3826             if (isAutomaticDashSubstitutionEnabled())
3827                 checkingTypes.add(TextCheckingType::Dash);
3828             if (shouldMarkSpelling &amp;&amp; isAutomaticSpellingCorrectionEnabled())
3829                 checkingTypes.add(TextCheckingType::Correction);
3830         }
3831         if (isAutomaticTextReplacementEnabled())
3832             checkingTypes.add(TextCheckingType::Replacement);
3833     }
3834 #endif
3835 #endif // !PLATFORM(IOS_FAMILY)
3836 
3837     return checkingTypes;
3838 }
3839 
3840 static RefPtr&lt;Range&gt; candidateRangeForSelection(Frame&amp; frame)
3841 {
3842     const VisibleSelection&amp; selection = frame.selection().selection();
3843     return selection.isCaret() ? wordRangeFromPosition(selection.start()) : frame.selection().toNormalizedRange();
3844 }
3845 
3846 static bool candidateWouldReplaceText(const VisibleSelection&amp; selection)
3847 {
3848     // If the character behind the caret in the current selection is anything but a space or a newline then we should
3849     // replace the whole current word with the candidate.
3850     UChar32 characterAfterSelection, characterBeforeSelection, twoCharacterBeforeSelection = 0;
3851     charactersAroundPosition(selection.visibleStart(), characterAfterSelection, characterBeforeSelection, twoCharacterBeforeSelection);
3852     return !(characterBeforeSelection == &#39;\0&#39; || characterBeforeSelection == &#39;\n&#39; || characterBeforeSelection == &#39; &#39;);
3853 }
3854 
3855 String Editor::stringForCandidateRequest() const
3856 {
3857     const VisibleSelection&amp; selection = m_frame.selection().selection();
3858     RefPtr&lt;Range&gt; rangeForCurrentlyTypedString = candidateRangeForSelection(m_frame);
3859     if (rangeForCurrentlyTypedString &amp;&amp; candidateWouldReplaceText(selection))
3860         return plainText(rangeForCurrentlyTypedString.get());
3861 
3862     return String();
3863 }
3864 
3865 RefPtr&lt;Range&gt; Editor::contextRangeForCandidateRequest() const
3866 {
3867     const VisibleSelection&amp; selection = m_frame.selection().selection();
3868     return makeRange(startOfParagraph(selection.visibleStart()), endOfParagraph(selection.visibleEnd()));
3869 }
3870 
3871 RefPtr&lt;Range&gt; Editor::rangeForTextCheckingResult(const TextCheckingResult&amp; result) const
3872 {
3873     if (!result.length)
3874         return nullptr;
3875 
3876     RefPtr&lt;Range&gt; contextRange = contextRangeForCandidateRequest();
3877     if (!contextRange)
3878         return nullptr;
3879 
3880     return TextIterator::subrange(*contextRange, result.location, result.length);
3881 }
3882 
3883 void Editor::scheduleEditorUIUpdate()
3884 {
3885     m_editorUIUpdateTimer.startOneShot(0_s);
3886 }
3887 
3888 #if !PLATFORM(COCOA)
3889 
3890 void Editor::platformFontAttributesAtSelectionStart(FontAttributes&amp;, const RenderStyle&amp;) const
3891 {
3892 }
3893 
3894 #endif
3895 
3896 static Vector&lt;TextList&gt; editableTextListsAtPositionInDescendingOrder(const Position&amp; position)
3897 {
3898     auto startContainer = makeRefPtr(position.containerNode());
3899     if (!startContainer)
3900         return { };
3901 
3902     auto* editableRoot = highestEditableRoot(firstPositionInOrBeforeNode(startContainer.get()));
3903     if (!editableRoot)
3904         return { };
3905 
3906     Vector&lt;Ref&lt;HTMLElement&gt;&gt; enclosingLists;
3907     for (auto&amp; ancestor : ancestorsOfType&lt;HTMLElement&gt;(*startContainer)) {
3908         if (&amp;ancestor == editableRoot)
3909             break;
3910 
3911         auto* renderer = ancestor.renderer();
3912         if (!renderer)
3913             continue;
3914 
3915         if (is&lt;HTMLUListElement&gt;(ancestor) || is&lt;HTMLOListElement&gt;(ancestor))
3916             enclosingLists.append(ancestor);
3917     }
3918 
3919     Vector&lt;TextList&gt; textLists;
3920     textLists.reserveCapacity(enclosingLists.size());
3921     for (auto iterator = enclosingLists.rbegin(); iterator != enclosingLists.rend(); ++iterator) {
3922         auto&amp; list = iterator-&gt;get();
3923         bool ordered = is&lt;HTMLOListElement&gt;(list);
3924         textLists.uncheckedAppend({ list.renderer()-&gt;style().listStyleType(), ordered ? downcast&lt;HTMLOListElement&gt;(list).start() : 1, ordered });
3925     }
3926 
3927     return textLists;
3928 }
3929 
3930 FontAttributes Editor::fontAttributesAtSelectionStart() const
3931 {
3932     FontAttributes attributes;
3933     Node* nodeToRemove = nullptr;
3934     auto* style = styleForSelectionStart(&amp;m_frame, nodeToRemove);
3935     if (!style) {
3936         if (nodeToRemove)
3937             nodeToRemove-&gt;remove();
3938         return attributes;
3939     }
3940 
3941     platformFontAttributesAtSelectionStart(attributes, *style);
3942 
3943     // FIXME: for now, always report the colors after applying -apple-color-filter. In future not all clients
3944     // may want this, so we may have to add a setting to control it. See also editingAttributedStringFromRange().
3945     auto backgroundColor = style-&gt;visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
3946     if (backgroundColor.isVisible())
3947         attributes.backgroundColor = backgroundColor;
3948 
3949     auto foregroundColor = style-&gt;visitedDependentColorWithColorFilter(CSSPropertyColor);
3950     // FIXME: isBlackColor not suitable for dark mode.
3951     if (foregroundColor.isValid() &amp;&amp; !Color::isBlackColor(foregroundColor))
3952         attributes.foregroundColor = foregroundColor;
3953 
3954     if (auto* shadowData = style-&gt;textShadow())
3955         attributes.fontShadow = { shadowData-&gt;color(), { static_cast&lt;float&gt;(shadowData-&gt;x()), static_cast&lt;float&gt;(shadowData-&gt;y()) }, static_cast&lt;double&gt;(shadowData-&gt;radius()) };
3956 
3957     switch (style-&gt;verticalAlign()) {
3958     case VerticalAlign::Baseline:
3959     case VerticalAlign::Bottom:
3960     case VerticalAlign::BaselineMiddle:
3961     case VerticalAlign::Length:
3962     case VerticalAlign::Middle:
3963     case VerticalAlign::TextBottom:
3964     case VerticalAlign::TextTop:
3965     case VerticalAlign::Top:
3966         break;
3967     case VerticalAlign::Sub:
3968         attributes.subscriptOrSuperscript = FontAttributes::SubscriptOrSuperscript::Subscript;
3969         break;
3970     case VerticalAlign::Super:
3971         attributes.subscriptOrSuperscript = FontAttributes::SubscriptOrSuperscript::Superscript;
3972         break;
3973     }
3974 
3975     attributes.textLists = editableTextListsAtPositionInDescendingOrder(m_frame.selection().selection().start());
3976 
3977     switch (style-&gt;textAlign()) {
3978     case TextAlignMode::Right:
3979     case TextAlignMode::WebKitRight:
3980         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Right;
3981         break;
3982     case TextAlignMode::Left:
3983     case TextAlignMode::WebKitLeft:
3984         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Left;
3985         break;
3986     case TextAlignMode::Center:
3987     case TextAlignMode::WebKitCenter:
3988         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Center;
3989         break;
3990     case TextAlignMode::Justify:
3991         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Justify;
3992         break;
3993     case TextAlignMode::Start:
3994         attributes.horizontalAlignment = FontAttributes::HorizontalAlignment::Natural;
3995         break;
3996     case TextAlignMode::End:
3997         attributes.horizontalAlignment = style-&gt;isLeftToRightDirection() ? FontAttributes::HorizontalAlignment::Right : FontAttributes::HorizontalAlignment::Left;
3998         break;
3999     }
4000 
4001     auto typingStyle = makeRefPtr(m_frame.selection().typingStyle());
4002     if (typingStyle &amp;&amp; typingStyle-&gt;style()) {
4003         auto value = typingStyle-&gt;style()-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
4004         if (value &amp;&amp; value-&gt;isValueList()) {
4005             CSSValueList&amp; valueList = downcast&lt;CSSValueList&gt;(*value);
4006             if (valueList.hasValue(CSSValuePool::singleton().createIdentifierValue(CSSValueLineThrough).ptr()))
4007                 attributes.hasStrikeThrough = true;
4008             if (valueList.hasValue(CSSValuePool::singleton().createIdentifierValue(CSSValueUnderline).ptr()))
4009                 attributes.hasUnderline = true;
4010         }
4011     } else {
4012         auto decoration = style-&gt;textDecorationsInEffect();
4013         if (decoration &amp; TextDecoration::LineThrough)
4014             attributes.hasStrikeThrough = true;
4015         if (decoration &amp; TextDecoration::Underline)
4016             attributes.hasUnderline = true;
4017     }
4018 
4019     if (nodeToRemove)
4020         nodeToRemove-&gt;remove();
4021 
4022     return attributes;
4023 }
4024 
4025 #if ENABLE(ATTACHMENT_ELEMENT)
4026 
4027 void Editor::registerAttachmentIdentifier(const String&amp; identifier, const String&amp; contentType, const String&amp; preferredFileName, Ref&lt;SharedBuffer&gt;&amp;&amp; data)
4028 {
4029     if (auto* client = this-&gt;client())
4030         client-&gt;registerAttachmentIdentifier(identifier, contentType, preferredFileName, WTFMove(data));
4031 }
4032 
4033 void Editor::registerAttachmentIdentifier(const String&amp; identifier, const String&amp; contentType, const String&amp; filePath)
4034 {
4035     if (auto* client = this-&gt;client())
4036         client-&gt;registerAttachmentIdentifier(identifier, contentType, filePath);
4037 }
4038 
4039 void Editor::registerAttachments(Vector&lt;SerializedAttachmentData&gt;&amp;&amp; data)
4040 {
4041     if (auto* client = this-&gt;client())
4042         client-&gt;registerAttachments(WTFMove(data));
4043 }
4044 
4045 void Editor::registerAttachmentIdentifier(const String&amp; identifier)
4046 {
4047     if (auto* client = this-&gt;client())
4048         client-&gt;registerAttachmentIdentifier(identifier);
4049 }
4050 
4051 void Editor::cloneAttachmentData(const String&amp; fromIdentifier, const String&amp; toIdentifier)
4052 {
4053     if (auto* client = this-&gt;client())
4054         client-&gt;cloneAttachmentData(fromIdentifier, toIdentifier);
4055 }
4056 
4057 void Editor::didInsertAttachmentElement(HTMLAttachmentElement&amp; attachment)
4058 {
4059     auto identifier = attachment.uniqueIdentifier();
4060     if (identifier.isEmpty())
4061         return;
4062 
4063     if (!m_removedAttachmentIdentifiers.take(identifier))
4064         m_insertedAttachmentIdentifiers.add(identifier);
4065     scheduleEditorUIUpdate();
4066 }
4067 
4068 void Editor::didRemoveAttachmentElement(HTMLAttachmentElement&amp; attachment)
4069 {
4070     auto identifier = attachment.uniqueIdentifier();
4071     if (identifier.isEmpty())
4072         return;
4073 
4074     if (!m_insertedAttachmentIdentifiers.take(identifier))
4075         m_removedAttachmentIdentifiers.add(identifier);
4076     scheduleEditorUIUpdate();
4077 }
4078 
4079 void Editor::notifyClientOfAttachmentUpdates()
4080 {
4081     auto removedAttachmentIdentifiers = WTFMove(m_removedAttachmentIdentifiers);
4082     auto insertedAttachmentIdentifiers = WTFMove(m_insertedAttachmentIdentifiers);
4083     if (!client())
4084         return;
4085 
4086     for (auto&amp; identifier : removedAttachmentIdentifiers)
4087         client()-&gt;didRemoveAttachmentWithIdentifier(identifier);
4088 
4089     auto* document = m_frame.document();
4090     if (!document)
4091         return;
4092 
4093     for (auto&amp; identifier : insertedAttachmentIdentifiers) {
4094         if (auto attachment = document-&gt;attachmentForIdentifier(identifier))
4095             client()-&gt;didInsertAttachmentWithIdentifier(identifier, attachment-&gt;attributeWithoutSynchronization(HTMLNames::srcAttr), attachment-&gt;hasEnclosingImage());
4096         else
4097             ASSERT_NOT_REACHED();
4098     }
4099 }
4100 
4101 void Editor::insertAttachment(const String&amp; identifier, Optional&lt;uint64_t&gt;&amp;&amp; fileSize, const String&amp; fileName, const String&amp; contentType)
4102 {
4103     auto attachment = HTMLAttachmentElement::create(HTMLNames::attachmentTag, document());
4104     attachment-&gt;setUniqueIdentifier(identifier);
4105     attachment-&gt;updateAttributes(WTFMove(fileSize), contentType, fileName);
4106 
4107     auto fragmentToInsert = document().createDocumentFragment();
4108     fragmentToInsert-&gt;appendChild(attachment.get());
4109 
4110     replaceSelectionWithFragment(fragmentToInsert.get(), SelectReplacement::No, SmartReplace::No, MatchStyle::Yes);
4111 }
4112 
4113 #endif // ENABLE(ATTACHMENT_ELEMENT)
4114 
4115 void Editor::handleAcceptedCandidate(TextCheckingResult acceptedCandidate)
4116 {
4117     const VisibleSelection&amp; selection = m_frame.selection().selection();
4118 
4119     m_isHandlingAcceptedCandidate = true;
4120 
4121     if (auto range = rangeForTextCheckingResult(acceptedCandidate)) {
4122         if (shouldInsertText(acceptedCandidate.replacement, range.get(), EditorInsertAction::Typed))
4123             ReplaceRangeWithTextCommand::create(range.get(), acceptedCandidate.replacement)-&gt;apply();
4124     } else
4125         insertText(acceptedCandidate.replacement, nullptr);
4126 
4127     RefPtr&lt;Range&gt; insertedCandidateRange = rangeExpandedByCharactersInDirectionAtWordBoundary(selection.visibleStart(), acceptedCandidate.replacement.length(), DirectionBackward);
4128     if (insertedCandidateRange)
4129         insertedCandidateRange-&gt;startContainer().document().markers().addMarker(*insertedCandidateRange, DocumentMarker::AcceptedCandidate, acceptedCandidate.replacement);
4130 
4131     m_isHandlingAcceptedCandidate = false;
4132 }
4133 
4134 bool Editor::unifiedTextCheckerEnabled() const
4135 {
4136     return WebCore::unifiedTextCheckerEnabled(&amp;m_frame);
4137 }
4138 
4139 Vector&lt;String&gt; Editor::dictationAlternativesForMarker(const DocumentMarker&amp; marker)
4140 {
4141     return m_alternativeTextController-&gt;dictationAlternativesForMarker(marker);
4142 }
4143 
4144 void Editor::applyDictationAlternativelternative(const String&amp; alternativeString)
4145 {
4146     m_alternativeTextController-&gt;applyDictationAlternative(alternativeString);
4147 }
4148 
4149 void Editor::toggleOverwriteModeEnabled()
4150 {
4151     m_overwriteModeEnabled = !m_overwriteModeEnabled;
4152     m_frame.selection().setShouldShowBlockCursor(m_overwriteModeEnabled);
4153 }
4154 
4155 Document&amp; Editor::document() const
4156 {
4157     ASSERT(m_frame.document());
4158     return *m_frame.document();
4159 }
4160 
4161 RefPtr&lt;Range&gt; Editor::adjustedSelectionRange()
4162 {
4163     // FIXME: Why do we need to adjust the selection to include the anchor tag it&#39;s in?
4164     // Whoever wrote this code originally forgot to leave us a comment explaining the rationale.
4165     RefPtr&lt;Range&gt; range = selectedRange();
4166     Node* commonAncestor = range-&gt;commonAncestorContainer();
4167     ASSERT(commonAncestor);
4168     auto* enclosingAnchor = enclosingElementWithTag(firstPositionInNode(commonAncestor), HTMLNames::aTag);
4169     if (enclosingAnchor &amp;&amp; comparePositions(firstPositionInOrBeforeNode(range-&gt;startPosition().anchorNode()), range-&gt;startPosition()) &gt;= 0)
4170         range-&gt;setStart(*enclosingAnchor, 0);
4171     return range;
4172 }
4173 
4174 // FIXME: This figures out the current style by inserting a &lt;span&gt;!
4175 const RenderStyle* Editor::styleForSelectionStart(Frame* frame, Node*&amp; nodeToRemove)
4176 {
4177     nodeToRemove = nullptr;
4178 
4179     if (frame-&gt;selection().isNone())
4180         return nullptr;
4181 
4182     Position position = adjustedSelectionStartForStyleComputation(frame-&gt;selection().selection());
4183     if (!position.isCandidate() || position.isNull())
4184         return nullptr;
4185 
4186     RefPtr&lt;EditingStyle&gt; typingStyle = frame-&gt;selection().typingStyle();
4187     if (!typingStyle || !typingStyle-&gt;style())
4188         return &amp;position.deprecatedNode()-&gt;renderer()-&gt;style();
4189 
4190     auto styleElement = HTMLSpanElement::create(*frame-&gt;document());
4191 
4192     String styleText = typingStyle-&gt;style()-&gt;asText() + &quot; display: inline&quot;;
4193     styleElement-&gt;setAttribute(HTMLNames::styleAttr, styleText);
4194 
4195     styleElement-&gt;appendChild(frame-&gt;document()-&gt;createEditingTextNode(emptyString()));
4196 
4197     auto positionNode = position.deprecatedNode();
4198     if (!positionNode || !positionNode-&gt;parentNode() || positionNode-&gt;parentNode()-&gt;appendChild(styleElement).hasException())
4199         return nullptr;
4200 
4201     nodeToRemove = styleElement.ptr();
4202 
4203     frame-&gt;document()-&gt;updateStyleIfNeeded();
4204     return styleElement-&gt;renderer() ? &amp;styleElement-&gt;renderer()-&gt;style() : nullptr;
4205 }
4206 
4207 const Font* Editor::fontForSelection(bool&amp; hasMultipleFonts) const
4208 {
4209     hasMultipleFonts = false;
4210 
4211     if (!m_frame.selection().isRange()) {
4212         Node* nodeToRemove;
4213         auto* style = styleForSelectionStart(&amp;m_frame, nodeToRemove); // sets nodeToRemove
4214 
4215         const Font* font = nullptr;
4216         if (style) {
4217             font = &amp;style-&gt;fontCascade().primaryFont();
4218             if (nodeToRemove)
4219                 nodeToRemove-&gt;remove();
4220         }
4221 
4222         return font;
4223     }
4224 
4225     RefPtr&lt;Range&gt; range = m_frame.selection().toNormalizedRange();
4226     if (!range)
4227         return nullptr;
4228 
4229     Node* startNode = adjustedSelectionStartForStyleComputation(m_frame.selection().selection()).deprecatedNode();
4230     if (!startNode)
4231         return nullptr;
4232 
4233     const Font* font = nullptr;
4234     Node* pastEnd = range-&gt;pastLastNode();
4235     // In the loop below, node should eventually match pastEnd and not become null, but we&#39;ve seen at least one
4236     // unreproducible case where this didn&#39;t happen, so check for null also.
4237     for (Node* node = startNode; node &amp;&amp; node != pastEnd; node = NodeTraversal::next(*node)) {
4238         auto renderer = node-&gt;renderer();
4239         if (!renderer)
4240             continue;
4241         // FIXME: Are there any node types that have renderers, but that we should be skipping?
4242         const Font&amp; primaryFont = renderer-&gt;style().fontCascade().primaryFont();
4243         if (!font)
4244             font = &amp;primaryFont;
4245         else if (font != &amp;primaryFont) {
4246             hasMultipleFonts = true;
4247             break;
4248         }
4249     }
4250 
4251     return font;
4252 }
4253 
<a name="28" id="anc28"></a><span class="line-removed">4254 String Editor::clientReplacementURLForResource(Ref&lt;SharedBuffer&gt;&amp;&amp; resourceData, const String&amp; mimeType)</span>
<span class="line-removed">4255 {</span>
<span class="line-removed">4256     if (auto* editorClient = client())</span>
<span class="line-removed">4257         return editorClient-&gt;replacementURLForResource(WTFMove(resourceData), mimeType);</span>
<span class="line-removed">4258 </span>
<span class="line-removed">4259     return { };</span>
<span class="line-removed">4260 }</span>
<span class="line-removed">4261 </span>
4262 RefPtr&lt;HTMLImageElement&gt; Editor::insertEditableImage()
4263 {
4264     return InsertEditableImageCommand::insertEditableImage(document());
4265 }
4266 
4267 bool Editor::canCopyExcludingStandaloneImages() const
4268 {
4269     auto&amp; selection = m_frame.selection().selection();
4270     return selection.isRange() &amp;&amp; !selection.isInPasswordField();
4271 }
4272 
4273 } // namespace WebCore
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>