<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderInline.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public License
  17  * along with this library; see the file COPYING.LIB.  If not, write to
  18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;RenderInline.h&quot;
  25 
  26 #include &quot;Chrome.h&quot;
  27 #include &quot;FloatQuad.h&quot;
  28 #include &quot;FrameSelection.h&quot;
  29 #include &quot;GraphicsContext.h&quot;
  30 #include &quot;HitTestResult.h&quot;
  31 #include &quot;InlineElementBox.h&quot;
  32 #include &quot;InlineTextBox.h&quot;
  33 #include &quot;RenderBlock.h&quot;
  34 #include &quot;RenderChildIterator.h&quot;
  35 #include &quot;RenderFragmentedFlow.h&quot;
  36 #include &quot;RenderFullScreen.h&quot;
  37 #include &quot;RenderGeometryMap.h&quot;
  38 #include &quot;RenderIterator.h&quot;
  39 #include &quot;RenderLayer.h&quot;
  40 #include &quot;RenderLayoutState.h&quot;
  41 #include &quot;RenderLineBreak.h&quot;
  42 #include &quot;RenderListMarker.h&quot;
  43 #include &quot;RenderTable.h&quot;
  44 #include &quot;RenderTheme.h&quot;
  45 #include &quot;RenderTreeBuilder.h&quot;
  46 #include &quot;RenderView.h&quot;
  47 #include &quot;Settings.h&quot;
  48 #include &quot;StyleInheritedData.h&quot;
  49 #include &quot;TransformState.h&quot;
  50 #include &quot;VisiblePosition.h&quot;
  51 #include &lt;wtf/IsoMallocInlines.h&gt;
  52 #include &lt;wtf/SetForScope.h&gt;
  53 
<a name="1" id="anc1"></a>



  54 namespace WebCore {
  55 
  56 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderInline);
  57 
  58 RenderInline::RenderInline(Element&amp; element, RenderStyle&amp;&amp; style)
  59     : RenderBoxModelObject(element, WTFMove(style), RenderInlineFlag)
  60 {
  61     setChildrenInline(true);
  62 }
  63 
  64 RenderInline::RenderInline(Document&amp; document, RenderStyle&amp;&amp; style)
  65     : RenderBoxModelObject(document, WTFMove(style), RenderInlineFlag)
  66 {
  67     setChildrenInline(true);
  68 }
  69 
  70 void RenderInline::willBeDestroyed()
  71 {
  72 #if !ASSERT_DISABLED
  73     // Make sure we do not retain &quot;this&quot; in the continuation outline table map of our containing blocks.
  74     if (parent() &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; hasOutline()) {
  75         bool containingBlockPaintsContinuationOutline = continuation() || isContinuation();
  76         if (containingBlockPaintsContinuationOutline) {
  77             if (RenderBlock* cb = containingBlock()) {
  78                 if (RenderBlock* cbCb = cb-&gt;containingBlock())
  79                     ASSERT(!cbCb-&gt;paintsContinuationOutline(this));
  80             }
  81         }
  82     }
  83 #endif
  84 
  85     if (!renderTreeBeingDestroyed()) {
  86         if (firstLineBox()) {
  87             // We can&#39;t wait for RenderBoxModelObject::destroy to clear the selection,
  88             // because by then we will have nuked the line boxes.
  89             if (isSelectionBorder())
  90                 frame().selection().setNeedsSelectionUpdate();
  91 
  92             // If line boxes are contained inside a root, that means we&#39;re an inline.
  93             // In that case, we need to remove all the line boxes so that the parent
  94             // lines aren&#39;t pointing to deleted children. If the first line box does
  95             // not have a parent that means they are either already disconnected or
  96             // root lines that can just be destroyed without disconnecting.
  97             if (firstLineBox()-&gt;parent()) {
  98                 for (auto* box = firstLineBox(); box; box = box-&gt;nextLineBox())
  99                     box-&gt;removeFromParent();
 100             }
 101         } else if (parent())
 102             parent()-&gt;dirtyLinesFromChangedChild(*this);
 103     }
 104 
 105     m_lineBoxes.deleteLineBoxes();
 106 
 107     RenderBoxModelObject::willBeDestroyed();
 108 }
 109 
 110 void RenderInline::updateFromStyle()
 111 {
 112     RenderBoxModelObject::updateFromStyle();
 113 
 114     // FIXME: Support transforms and reflections on inline flows someday.
 115     setHasTransformRelatedProperty(false);
 116     setHasReflection(false);
 117 }
 118 
 119 static RenderElement* inFlowPositionedInlineAncestor(RenderElement* p)
 120 {
 121     while (p &amp;&amp; p-&gt;isRenderInline()) {
 122         if (p-&gt;isInFlowPositioned())
 123             return p;
 124         p = p-&gt;parent();
 125     }
 126     return nullptr;
 127 }
 128 
 129 static void updateStyleOfAnonymousBlockContinuations(const RenderBlock&amp; block, const RenderStyle* newStyle, const RenderStyle* oldStyle)
 130 {
 131     // If any descendant blocks exist then they will be in the next anonymous block and its siblings.
 132     for (RenderBox* box = block.nextSiblingBox(); box &amp;&amp; box-&gt;isAnonymousBlock(); box = box-&gt;nextSiblingBox()) {
 133         if (box-&gt;style().position() == newStyle-&gt;position())
 134             continue;
 135 
 136         if (!is&lt;RenderBlock&gt;(*box))
 137             continue;
 138 
 139         RenderBlock&amp; block = downcast&lt;RenderBlock&gt;(*box);
 140         if (!block.isContinuation())
 141             continue;
 142 
 143         // If we are no longer in-flow positioned but our descendant block(s) still have an in-flow positioned ancestor then
 144         // their containing anonymous block should keep its in-flow positioning.
 145         RenderInline* continuation = block.inlineContinuation();
 146         if (oldStyle-&gt;hasInFlowPosition() &amp;&amp; inFlowPositionedInlineAncestor(continuation))
 147             continue;
 148         auto blockStyle = RenderStyle::createAnonymousStyleWithDisplay(block.style(), DisplayType::Block);
 149         blockStyle.setPosition(newStyle-&gt;position());
 150         block.setStyle(WTFMove(blockStyle));
 151     }
 152 }
 153 
 154 void RenderInline::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
 155 {
 156     RenderBoxModelObject::styleWillChange(diff, newStyle);
 157     // RenderInlines forward their absolute positioned descendants to their (non-anonymous) containing block.
 158     // Check if this non-anonymous containing block can hold the absolute positioned elements when the inline is no longer positioned.
 159     if (canContainAbsolutelyPositionedObjects() &amp;&amp; newStyle.position() == PositionType::Static) {
 160         auto* container = containingBlockForAbsolutePosition();
 161         if (container &amp;&amp; !container-&gt;canContainAbsolutelyPositionedObjects())
 162             container-&gt;removePositionedObjects(nullptr, NewContainingBlock);
 163     }
 164 }
 165 
 166 void RenderInline::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
 167 {
 168     RenderBoxModelObject::styleDidChange(diff, oldStyle);
 169 
 170     // Ensure that all of the split inlines pick up the new style. We
 171     // only do this if we&#39;re an inline, since we don&#39;t want to propagate
 172     // a block&#39;s style to the other inlines.
 173     // e.g., &lt;font&gt;foo &lt;h4&gt;goo&lt;/h4&gt; moo&lt;/font&gt;.  The &lt;font&gt; inlines before
 174     // and after the block share the same style, but the block doesn&#39;t
 175     // need to pass its style on to anyone else.
 176     auto&amp; newStyle = style();
 177     RenderInline* continuation = inlineContinuation();
 178     if (continuation &amp;&amp; !isContinuation()) {
 179         for (RenderInline* currCont = continuation; currCont; currCont = currCont-&gt;inlineContinuation())
 180             currCont-&gt;setStyle(RenderStyle::clone(newStyle));
 181         // If an inline&#39;s in-flow positioning has changed and it is part of an active continuation as a descendant of an anonymous containing block,
 182         // then any descendant blocks will need to change their in-flow positioning accordingly.
 183         // Do this by updating the position of the descendant blocks&#39; containing anonymous blocks - there may be more than one.
 184         if (containingBlock()-&gt;isAnonymousBlock() &amp;&amp; oldStyle &amp;&amp; newStyle.position() != oldStyle-&gt;position() &amp;&amp; (newStyle.hasInFlowPosition() || oldStyle-&gt;hasInFlowPosition()))
 185             updateStyleOfAnonymousBlockContinuations(*containingBlock(), &amp;newStyle, oldStyle);
 186     }
 187 
 188     if (!alwaysCreateLineBoxes()) {
 189         bool alwaysCreateLineBoxes = hasSelfPaintingLayer() || hasVisibleBoxDecorations() || newStyle.hasBorder() || newStyle.hasPadding() || newStyle.hasMargin() || hasOutline();
 190         if (oldStyle &amp;&amp; alwaysCreateLineBoxes) {
 191             dirtyLineBoxes(false);
 192             setNeedsLayout();
 193         }
 194         setRenderInlineAlwaysCreatesLineBoxes(alwaysCreateLineBoxes);
 195     }
 196 }
 197 
 198 void RenderInline::updateAlwaysCreateLineBoxes(bool fullLayout)
 199 {
 200     // Once we have been tainted once, just assume it will happen again. This way effects like hover highlighting that change the
 201     // background color will only cause a layout on the first rollover.
 202     if (alwaysCreateLineBoxes())
 203         return;
 204 
 205     auto* parentStyle = &amp;parent()-&gt;style();
 206     RenderInline* parentRenderInline = is&lt;RenderInline&gt;(*parent()) ? downcast&lt;RenderInline&gt;(parent()) : nullptr;
 207     bool checkFonts = document().inNoQuirksMode();
 208     bool alwaysCreateLineBoxes = (parentRenderInline &amp;&amp; parentRenderInline-&gt;alwaysCreateLineBoxes())
 209         || (parentRenderInline &amp;&amp; parentStyle-&gt;verticalAlign() != VerticalAlign::Baseline)
 210         || style().verticalAlign() != VerticalAlign::Baseline
 211         || style().textEmphasisMark() != TextEmphasisMark::None
 212         || (checkFonts &amp;&amp; (!parentStyle-&gt;fontCascade().fontMetrics().hasIdenticalAscentDescentAndLineGap(style().fontCascade().fontMetrics())
 213         || parentStyle-&gt;lineHeight() != style().lineHeight()));
 214 
 215     if (!alwaysCreateLineBoxes &amp;&amp; checkFonts &amp;&amp; view().usesFirstLineRules()) {
 216         // Have to check the first line style as well.
 217         parentStyle = &amp;parent()-&gt;firstLineStyle();
 218         auto&amp; childStyle = firstLineStyle();
 219         alwaysCreateLineBoxes = !parentStyle-&gt;fontCascade().fontMetrics().hasIdenticalAscentDescentAndLineGap(childStyle.fontCascade().fontMetrics())
 220             || childStyle.verticalAlign() != VerticalAlign::Baseline
 221             || parentStyle-&gt;lineHeight() != childStyle.lineHeight();
 222     }
 223 
 224     if (alwaysCreateLineBoxes) {
 225         if (!fullLayout)
 226             dirtyLineBoxes(false);
 227         setAlwaysCreateLineBoxes();
 228     }
 229 }
 230 
 231 LayoutRect RenderInline::localCaretRect(InlineBox* inlineBox, unsigned, LayoutUnit* extraWidthToEndOfLine)
 232 {
 233     if (firstChild()) {
 234         // This condition is possible if the RenderInline is at an editing boundary,
 235         // i.e. the VisiblePosition is:
 236         //   &lt;RenderInline editingBoundary=true&gt;|&lt;RenderText&gt; &lt;/RenderText&gt;&lt;/RenderInline&gt;
 237         // FIXME: need to figure out how to make this return a valid rect, note that
 238         // there are no line boxes created in the above case.
 239         return LayoutRect();
 240     }
 241 
 242     ASSERT_UNUSED(inlineBox, !inlineBox);
 243 
 244     if (extraWidthToEndOfLine)
 245         *extraWidthToEndOfLine = 0;
 246 
 247     LayoutRect caretRect = localCaretRectForEmptyElement(horizontalBorderAndPaddingExtent(), 0);
 248 
 249     if (InlineBox* firstBox = firstLineBox())
 250         caretRect.moveBy(LayoutPoint(firstBox-&gt;topLeft()));
 251 
 252     return caretRect;
 253 }
 254 
 255 void RenderInline::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
 256 {
 257     m_lineBoxes.paint(this, paintInfo, paintOffset);
 258 }
 259 
 260 template&lt;typename GeneratorContext&gt;
 261 void RenderInline::generateLineBoxRects(GeneratorContext&amp; context) const
 262 {
 263     if (!alwaysCreateLineBoxes())
 264         generateCulledLineBoxRects(context, this);
 265     else if (InlineFlowBox* curr = firstLineBox()) {
 266         for (; curr; curr = curr-&gt;nextLineBox())
 267             context.addRect(FloatRect(curr-&gt;topLeft(), curr-&gt;size()));
 268     } else
 269         context.addRect(FloatRect());
 270 }
 271 
 272 template&lt;typename GeneratorContext&gt;
 273 void RenderInline::generateCulledLineBoxRects(GeneratorContext&amp; context, const RenderInline* container) const
 274 {
 275     if (!culledInlineFirstLineBox()) {
 276         context.addRect(FloatRect());
 277         return;
 278     }
 279 
 280     bool isHorizontal = style().isHorizontalWritingMode();
 281 
 282     for (auto&amp; current : childrenOfType&lt;RenderObject&gt;(*this)) {
 283         if (current.isFloatingOrOutOfFlowPositioned())
 284             continue;
 285 
 286         // We want to get the margin box in the inline direction, and then use our font ascent/descent in the block
 287         // direction (aligned to the root box&#39;s baseline).
 288         if (is&lt;RenderBox&gt;(current)) {
 289             auto&amp; renderBox = downcast&lt;RenderBox&gt;(current);
 290             if (renderBox.inlineBoxWrapper()) {
 291                 const RootInlineBox&amp; rootBox = renderBox.inlineBoxWrapper()-&gt;root();
 292                 const RenderStyle&amp; containerStyle = rootBox.isFirstLine() ? container-&gt;firstLineStyle() : container-&gt;style();
 293                 int logicalTop = rootBox.logicalTop() + (rootBox.lineStyle().fontCascade().fontMetrics().ascent() - containerStyle.fontCascade().fontMetrics().ascent());
 294                 int logicalHeight = containerStyle.fontCascade().fontMetrics().height();
 295                 if (isHorizontal)
 296                     context.addRect(FloatRect(renderBox.inlineBoxWrapper()-&gt;x() - renderBox.marginLeft(), logicalTop, renderBox.width() + renderBox.horizontalMarginExtent(), logicalHeight));
 297                 else
 298                     context.addRect(FloatRect(logicalTop, renderBox.inlineBoxWrapper()-&gt;y() - renderBox.marginTop(), logicalHeight, renderBox.height() + renderBox.verticalMarginExtent()));
 299             }
 300         } else if (is&lt;RenderInline&gt;(current)) {
 301             // If the child doesn&#39;t need line boxes either, then we can recur.
 302             auto&amp; renderInline = downcast&lt;RenderInline&gt;(current);
 303             if (!renderInline.alwaysCreateLineBoxes())
 304                 renderInline.generateCulledLineBoxRects(context, container);
 305             else {
 306                 for (InlineFlowBox* childLine = renderInline.firstLineBox(); childLine; childLine = childLine-&gt;nextLineBox()) {
 307                     const RootInlineBox&amp; rootBox = childLine-&gt;root();
 308                     const RenderStyle&amp; containerStyle = rootBox.isFirstLine() ? container-&gt;firstLineStyle() : container-&gt;style();
 309                     int logicalTop = rootBox.logicalTop() + (rootBox.lineStyle().fontCascade().fontMetrics().ascent() - containerStyle.fontCascade().fontMetrics().ascent());
 310                     int logicalHeight = containerStyle.fontMetrics().height();
 311                     if (isHorizontal) {
 312                         context.addRect(FloatRect(childLine-&gt;x() - childLine-&gt;marginLogicalLeft(),
 313                             logicalTop,
 314                             childLine-&gt;logicalWidth() + childLine-&gt;marginLogicalLeft() + childLine-&gt;marginLogicalRight(),
 315                             logicalHeight));
 316                     } else {
 317                         context.addRect(FloatRect(logicalTop,
 318                             childLine-&gt;y() - childLine-&gt;marginLogicalLeft(),
 319                             logicalHeight,
 320                             childLine-&gt;logicalWidth() + childLine-&gt;marginLogicalLeft() + childLine-&gt;marginLogicalRight()));
 321                     }
 322                 }
 323             }
 324         } else if (is&lt;RenderText&gt;(current)) {
 325             auto&amp; currText = downcast&lt;RenderText&gt;(current);
 326             for (InlineTextBox* childText = currText.firstTextBox(); childText; childText = childText-&gt;nextTextBox()) {
 327                 const RootInlineBox&amp; rootBox = childText-&gt;root();
 328                 const RenderStyle&amp; containerStyle = rootBox.isFirstLine() ? container-&gt;firstLineStyle() : container-&gt;style();
 329                 int logicalTop = rootBox.logicalTop() + (rootBox.lineStyle().fontCascade().fontMetrics().ascent() - containerStyle.fontCascade().fontMetrics().ascent());
 330                 int logicalHeight = containerStyle.fontCascade().fontMetrics().height();
 331                 if (isHorizontal)
 332                     context.addRect(FloatRect(childText-&gt;x(), logicalTop, childText-&gt;logicalWidth(), logicalHeight));
 333                 else
 334                     context.addRect(FloatRect(logicalTop, childText-&gt;y(), logicalHeight, childText-&gt;logicalWidth()));
 335             }
 336         } else if (is&lt;RenderLineBreak&gt;(current)) {
 337             if (auto* inlineBox = downcast&lt;RenderLineBreak&gt;(current).inlineBoxWrapper()) {
 338                 // FIXME: This could use a helper to share these with text path.
 339                 const RootInlineBox&amp; rootBox = inlineBox-&gt;root();
 340                 const RenderStyle&amp; containerStyle = rootBox.isFirstLine() ? container-&gt;firstLineStyle() : container-&gt;style();
 341                 int logicalTop = rootBox.logicalTop() + (rootBox.lineStyle().fontCascade().fontMetrics().ascent() - containerStyle.fontCascade().fontMetrics().ascent());
 342                 int logicalHeight = containerStyle.fontMetrics().height();
 343                 if (isHorizontal)
 344                     context.addRect(FloatRect(inlineBox-&gt;x(), logicalTop, inlineBox-&gt;logicalWidth(), logicalHeight));
 345                 else
 346                     context.addRect(FloatRect(logicalTop, inlineBox-&gt;y(), logicalHeight, inlineBox-&gt;logicalWidth()));
 347             }
 348         }
 349     }
 350 }
 351 
 352 namespace {
 353 
 354 class AbsoluteRectsGeneratorContext {
 355 public:
 356     AbsoluteRectsGeneratorContext(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset)
 357         : m_rects(rects)
 358         , m_accumulatedOffset(accumulatedOffset) { }
 359 
 360     void addRect(const FloatRect&amp; rect)
 361     {
 362         LayoutRect adjustedRect = LayoutRect(rect);
 363         adjustedRect.moveBy(m_accumulatedOffset);
 364         m_rects.append(adjustedRect);
 365     }
 366 private:
 367     Vector&lt;LayoutRect&gt;&amp; m_rects;
 368     const LayoutPoint&amp; m_accumulatedOffset;
 369 };
 370 
 371 } // unnamed namespace
 372 
 373 void RenderInline::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
 374 {
 375     Vector&lt;LayoutRect&gt; lineboxRects;
 376     AbsoluteRectsGeneratorContext context(lineboxRects, accumulatedOffset);
 377     generateLineBoxRects(context);
 378     for (const auto&amp; rect : lineboxRects)
 379         rects.append(snappedIntRect(rect));
 380 
 381     if (RenderBoxModelObject* continuation = this-&gt;continuation()) {
 382         if (is&lt;RenderBox&gt;(*continuation)) {
 383             auto&amp; box = downcast&lt;RenderBox&gt;(*continuation);
 384             continuation-&gt;absoluteRects(rects, toLayoutPoint(accumulatedOffset - containingBlock()-&gt;location() + box.locationOffset()));
 385         } else
 386             continuation-&gt;absoluteRects(rects, toLayoutPoint(accumulatedOffset - containingBlock()-&gt;location()));
 387     }
 388 }
 389 
 390 
 391 namespace {
 392 
 393 class AbsoluteQuadsGeneratorContext {
 394 public:
 395     AbsoluteQuadsGeneratorContext(const RenderInline* renderer, Vector&lt;FloatQuad&gt;&amp; quads)
 396         : m_quads(quads)
 397         , m_geometryMap()
 398     {
 399         m_geometryMap.pushMappingsToAncestor(renderer, nullptr);
 400     }
 401 
 402     void addRect(const FloatRect&amp; rect)
 403     {
 404         m_quads.append(m_geometryMap.absoluteRect(rect));
 405     }
 406 private:
 407     Vector&lt;FloatQuad&gt;&amp; m_quads;
 408     RenderGeometryMap m_geometryMap;
 409 };
 410 
 411 } // unnamed namespace
 412 
 413 void RenderInline::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
 414 {
 415     AbsoluteQuadsGeneratorContext context(this, quads);
 416     generateLineBoxRects(context);
 417 
 418     if (RenderBoxModelObject* continuation = this-&gt;continuation())
 419         continuation-&gt;absoluteQuads(quads, wasFixed);
 420 }
 421 
 422 #if PLATFORM(IOS_FAMILY)
 423 void RenderInline::absoluteQuadsForSelection(Vector&lt;FloatQuad&gt;&amp; quads) const
 424 {
 425     AbsoluteQuadsGeneratorContext context(this, quads);
 426     generateLineBoxRects(context);
 427 }
 428 #endif
 429 
 430 LayoutUnit RenderInline::offsetLeft() const
 431 {
 432     LayoutPoint topLeft;
 433     if (InlineBox* firstBox = firstLineBoxIncludingCulling())
 434         topLeft = flooredLayoutPoint(firstBox-&gt;topLeft());
 435     return adjustedPositionRelativeToOffsetParent(topLeft).x();
 436 }
 437 
 438 LayoutUnit RenderInline::offsetTop() const
 439 {
 440     LayoutPoint topLeft;
 441     if (InlineBox* firstBox = firstLineBoxIncludingCulling())
 442         topLeft = flooredLayoutPoint(firstBox-&gt;topLeft());
 443     return adjustedPositionRelativeToOffsetParent(topLeft).y();
 444 }
 445 
 446 static LayoutUnit computeMargin(const RenderInline* renderer, const Length&amp; margin)
 447 {
 448     if (margin.isAuto())
 449         return 0;
 450     if (margin.isFixed())
<a name="2" id="anc2"></a><span class="line-modified"> 451         return LayoutUnit(margin.value());</span>
 452     if (margin.isPercentOrCalculated())
 453         return minimumValueForLength(margin, std::max&lt;LayoutUnit&gt;(0, renderer-&gt;containingBlock()-&gt;availableLogicalWidth()));
 454     return 0;
 455 }
 456 
 457 LayoutUnit RenderInline::marginLeft() const
 458 {
 459     return computeMargin(this, style().marginLeft());
 460 }
 461 
 462 LayoutUnit RenderInline::marginRight() const
 463 {
 464     return computeMargin(this, style().marginRight());
 465 }
 466 
 467 LayoutUnit RenderInline::marginTop() const
 468 {
 469     return computeMargin(this, style().marginTop());
 470 }
 471 
 472 LayoutUnit RenderInline::marginBottom() const
 473 {
 474     return computeMargin(this, style().marginBottom());
 475 }
 476 
 477 LayoutUnit RenderInline::marginStart(const RenderStyle* otherStyle) const
 478 {
 479     return computeMargin(this, style().marginStartUsing(otherStyle ? otherStyle : &amp;style()));
 480 }
 481 
 482 LayoutUnit RenderInline::marginEnd(const RenderStyle* otherStyle) const
 483 {
 484     return computeMargin(this, style().marginEndUsing(otherStyle ? otherStyle : &amp;style()));
 485 }
 486 
 487 LayoutUnit RenderInline::marginBefore(const RenderStyle* otherStyle) const
 488 {
 489     return computeMargin(this, style().marginBeforeUsing(otherStyle ? otherStyle : &amp;style()));
 490 }
 491 
 492 LayoutUnit RenderInline::marginAfter(const RenderStyle* otherStyle) const
 493 {
 494     return computeMargin(this, style().marginAfterUsing(otherStyle ? otherStyle : &amp;style()));
 495 }
 496 
 497 const char* RenderInline::renderName() const
 498 {
 499     if (isRelativelyPositioned())
 500         return &quot;RenderInline (relative positioned)&quot;;
 501     if (isStickilyPositioned())
 502         return &quot;RenderInline (sticky positioned)&quot;;
 503     // FIXME: Temporary hack while the new generated content system is being implemented.
 504     if (isPseudoElement())
 505         return &quot;RenderInline (generated)&quot;;
 506     if (isAnonymous())
 507         return &quot;RenderInline (generated)&quot;;
 508     return &quot;RenderInline&quot;;
 509 }
 510 
 511 bool RenderInline::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result,
 512                                 const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
 513 {
 514     return m_lineBoxes.hitTest(this, request, result, locationInContainer, accumulatedOffset, hitTestAction);
 515 }
 516 
 517 namespace {
 518 
 519 class HitTestCulledInlinesGeneratorContext {
 520 public:
 521     HitTestCulledInlinesGeneratorContext(Region&amp; region, const HitTestLocation&amp; location)
 522         : m_intersected(false)
 523         , m_region(region)
 524         , m_location(location)
 525     { }
 526 
 527     void addRect(const FloatRect&amp; rect)
 528     {
 529         m_intersected = m_intersected || m_location.intersects(rect);
 530         m_region.unite(enclosingIntRect(rect));
 531     }
 532 
 533     bool intersected() const { return m_intersected; }
 534 
 535 private:
 536     bool m_intersected;
 537     Region&amp; m_region;
 538     const HitTestLocation&amp; m_location;
 539 };
 540 
 541 } // unnamed namespace
 542 
 543 bool RenderInline::hitTestCulledInline(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset)
 544 {
 545     ASSERT(result.isRectBasedTest() &amp;&amp; !alwaysCreateLineBoxes());
 546     if (!visibleToHitTesting())
 547         return false;
 548 
 549     HitTestLocation tmpLocation(locationInContainer, -toLayoutSize(accumulatedOffset));
 550 
 551     Region regionResult;
 552     HitTestCulledInlinesGeneratorContext context(regionResult, tmpLocation);
 553     generateCulledLineBoxRects(context, this);
 554 
 555     if (context.intersected()) {
 556         updateHitTestResult(result, tmpLocation.point());
 557         // We cannot use addNodeToListBasedTestResult to determine if we fully enclose the hit-test area
 558         // because it can only handle rectangular targets.
 559         result.addNodeToListBasedTestResult(element(), request, locationInContainer);
 560         return regionResult.contains(tmpLocation.boundingBox());
 561     }
 562     return false;
 563 }
 564 
 565 VisiblePosition RenderInline::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer* fragment)
 566 {
 567     // FIXME: Does not deal with relative or sticky positioned inlines (should it?)
 568     RenderBlock&amp; containingBlock = *this-&gt;containingBlock();
 569     if (firstLineBox()) {
 570         // This inline actually has a line box.  We must have clicked in the border/padding of one of these boxes.  We
 571         // should try to find a result by asking our containing block.
 572         return containingBlock.positionForPoint(point, fragment);
 573     }
 574 
 575     // Translate the coords from the pre-anonymous block to the post-anonymous block.
 576     LayoutPoint parentBlockPoint = containingBlock.location() + point;
 577     RenderBoxModelObject* continuation = this-&gt;continuation();
 578     while (continuation) {
 579         RenderBlock* currentBlock = continuation-&gt;isInline() ? continuation-&gt;containingBlock() : downcast&lt;RenderBlock&gt;(continuation);
 580         if (continuation-&gt;isInline() || continuation-&gt;firstChild())
 581             return continuation-&gt;positionForPoint(parentBlockPoint - currentBlock-&gt;locationOffset(), fragment);
 582         continuation = continuation-&gt;inlineContinuation();
 583     }
 584 
 585     return RenderBoxModelObject::positionForPoint(point, fragment);
 586 }
 587 
 588 namespace {
 589 
 590 class LinesBoundingBoxGeneratorContext {
 591 public:
 592     LinesBoundingBoxGeneratorContext(FloatRect&amp; rect) : m_rect(rect) { }
 593 
 594     void addRect(const FloatRect&amp; rect)
 595     {
 596         m_rect.uniteIfNonZero(rect);
 597     }
 598 private:
 599     FloatRect&amp; m_rect;
 600 };
 601 
 602 } // unnamed namespace
 603 
 604 IntRect RenderInline::linesBoundingBox() const
 605 {
 606     if (!alwaysCreateLineBoxes()) {
 607         ASSERT(!firstLineBox());
 608         FloatRect floatResult;
 609         LinesBoundingBoxGeneratorContext context(floatResult);
 610         generateCulledLineBoxRects(context, this);
 611         return enclosingIntRect(floatResult);
 612     }
 613 
 614     IntRect result;
 615 
 616     // See &lt;rdar://problem/5289721&gt;, for an unknown reason the linked list here is sometimes inconsistent, first is non-zero and last is zero.  We have been
 617     // unable to reproduce this at all (and consequently unable to figure ot why this is happening).  The assert will hopefully catch the problem in debug
 618     // builds and help us someday figure out why.  We also put in a redundant check of lastLineBox() to avoid the crash for now.
 619     ASSERT(!firstLineBox() == !lastLineBox());  // Either both are null or both exist.
 620     if (firstLineBox() &amp;&amp; lastLineBox()) {
 621         // Return the width of the minimal left side and the maximal right side.
 622         float logicalLeftSide = 0;
 623         float logicalRightSide = 0;
 624         for (InlineFlowBox* curr = firstLineBox(); curr; curr = curr-&gt;nextLineBox()) {
 625             if (curr == firstLineBox() || curr-&gt;logicalLeft() &lt; logicalLeftSide)
 626                 logicalLeftSide = curr-&gt;logicalLeft();
 627             if (curr == firstLineBox() || curr-&gt;logicalRight() &gt; logicalRightSide)
 628                 logicalRightSide = curr-&gt;logicalRight();
 629         }
 630 
 631         bool isHorizontal = style().isHorizontalWritingMode();
 632 
 633         float x = isHorizontal ? logicalLeftSide : firstLineBox()-&gt;x();
 634         float y = isHorizontal ? firstLineBox()-&gt;y() : logicalLeftSide;
 635         float width = isHorizontal ? logicalRightSide - logicalLeftSide : lastLineBox()-&gt;logicalBottom() - x;
 636         float height = isHorizontal ? lastLineBox()-&gt;logicalBottom() - y : logicalRightSide - logicalLeftSide;
 637         result = enclosingIntRect(FloatRect(x, y, width, height));
 638     }
 639 
 640     return result;
 641 }
 642 
 643 InlineBox* RenderInline::culledInlineFirstLineBox() const
 644 {
 645     for (auto&amp; current : childrenOfType&lt;RenderObject&gt;(*this)) {
 646         if (current.isFloatingOrOutOfFlowPositioned())
 647             continue;
 648 
 649         // We want to get the margin box in the inline direction, and then use our font ascent/descent in the block
 650         // direction (aligned to the root box&#39;s baseline).
 651         if (is&lt;RenderBox&gt;(current)) {
 652             auto&amp; renderBox = downcast&lt;RenderBox&gt;(current);
 653             if (renderBox.inlineBoxWrapper())
 654                 return renderBox.inlineBoxWrapper();
 655         } else if (is&lt;RenderLineBreak&gt;(current)) {
 656             auto&amp; renderBR = downcast&lt;RenderLineBreak&gt;(current);
 657             if (renderBR.inlineBoxWrapper())
 658                 return renderBR.inlineBoxWrapper();
 659         } else if (is&lt;RenderInline&gt;(current)) {
 660             auto&amp; renderInline = downcast&lt;RenderInline&gt;(current);
 661             if (InlineBox* result = renderInline.firstLineBoxIncludingCulling())
 662                 return result;
 663         } else if (is&lt;RenderText&gt;(current)) {
 664             auto&amp; renderText = downcast&lt;RenderText&gt;(current);
 665             if (renderText.firstTextBox())
 666                 return renderText.firstTextBox();
 667         }
 668     }
 669     return nullptr;
 670 }
 671 
 672 InlineBox* RenderInline::culledInlineLastLineBox() const
 673 {
 674     for (RenderObject* current = lastChild(); current; current = current-&gt;previousSibling()) {
 675         if (current-&gt;isFloatingOrOutOfFlowPositioned())
 676             continue;
 677 
 678         // We want to get the margin box in the inline direction, and then use our font ascent/descent in the block
 679         // direction (aligned to the root box&#39;s baseline).
 680         if (is&lt;RenderBox&gt;(*current)) {
 681             const auto&amp; renderBox = downcast&lt;RenderBox&gt;(*current);
 682             if (renderBox.inlineBoxWrapper())
 683                 return renderBox.inlineBoxWrapper();
 684         } else if (is&lt;RenderLineBreak&gt;(*current)) {
 685             RenderLineBreak&amp; renderBR = downcast&lt;RenderLineBreak&gt;(*current);
 686             if (renderBR.inlineBoxWrapper())
 687                 return renderBR.inlineBoxWrapper();
 688         } else if (is&lt;RenderInline&gt;(*current)) {
 689             RenderInline&amp; renderInline = downcast&lt;RenderInline&gt;(*current);
 690             if (InlineBox* result = renderInline.lastLineBoxIncludingCulling())
 691                 return result;
 692         } else if (is&lt;RenderText&gt;(*current)) {
 693             RenderText&amp; renderText = downcast&lt;RenderText&gt;(*current);
 694             if (renderText.lastTextBox())
 695                 return renderText.lastTextBox();
 696         }
 697     }
 698     return nullptr;
 699 }
 700 
 701 LayoutRect RenderInline::culledInlineVisualOverflowBoundingBox() const
 702 {
 703     FloatRect floatResult;
 704     LinesBoundingBoxGeneratorContext context(floatResult);
 705     generateCulledLineBoxRects(context, this);
 706     LayoutRect result(enclosingLayoutRect(floatResult));
 707     bool isHorizontal = style().isHorizontalWritingMode();
 708     for (auto&amp; current : childrenOfType&lt;RenderObject&gt;(*this)) {
 709         if (current.isFloatingOrOutOfFlowPositioned())
 710             continue;
 711 
 712         // For overflow we just have to propagate by hand and recompute it all.
 713         if (is&lt;RenderBox&gt;(current)) {
 714             auto&amp; renderBox = downcast&lt;RenderBox&gt;(current);
 715             if (!renderBox.hasSelfPaintingLayer() &amp;&amp; renderBox.inlineBoxWrapper()) {
 716                 LayoutRect logicalRect = renderBox.logicalVisualOverflowRectForPropagation(&amp;style());
 717                 if (isHorizontal) {
 718                     logicalRect.moveBy(renderBox.location());
 719                     result.uniteIfNonZero(logicalRect);
 720                 } else {
 721                     logicalRect.moveBy(renderBox.location());
 722                     result.uniteIfNonZero(logicalRect.transposedRect());
 723                 }
 724             }
 725         } else if (is&lt;RenderInline&gt;(current)) {
 726             // If the child doesn&#39;t need line boxes either, then we can recur.
 727             auto&amp; renderInline = downcast&lt;RenderInline&gt;(current);
 728             if (!renderInline.alwaysCreateLineBoxes())
 729                 result.uniteIfNonZero(renderInline.culledInlineVisualOverflowBoundingBox());
 730             else if (!renderInline.hasSelfPaintingLayer())
 731                 result.uniteIfNonZero(renderInline.linesVisualOverflowBoundingBox());
 732         } else if (is&lt;RenderText&gt;(current)) {
 733             // FIXME; Overflow from text boxes is lost. We will need to cache this information in
 734             // InlineTextBoxes.
 735             auto&amp; renderText = downcast&lt;RenderText&gt;(current);
 736             result.uniteIfNonZero(renderText.linesVisualOverflowBoundingBox());
 737         }
 738     }
 739     return result;
 740 }
 741 
 742 LayoutRect RenderInline::linesVisualOverflowBoundingBox() const
 743 {
 744     if (!alwaysCreateLineBoxes())
 745         return culledInlineVisualOverflowBoundingBox();
 746 
 747     if (!firstLineBox() || !lastLineBox())
 748         return LayoutRect();
 749 
 750     // Return the width of the minimal left side and the maximal right side.
 751     LayoutUnit logicalLeftSide = LayoutUnit::max();
 752     LayoutUnit logicalRightSide = LayoutUnit::min();
 753     for (InlineFlowBox* curr = firstLineBox(); curr; curr = curr-&gt;nextLineBox()) {
 754         logicalLeftSide = std::min(logicalLeftSide, curr-&gt;logicalLeftVisualOverflow());
 755         logicalRightSide = std::max(logicalRightSide, curr-&gt;logicalRightVisualOverflow());
 756     }
 757 
 758     const RootInlineBox&amp; firstRootBox = firstLineBox()-&gt;root();
 759     const RootInlineBox&amp; lastRootBox = lastLineBox()-&gt;root();
 760 
 761     LayoutUnit logicalTop = firstLineBox()-&gt;logicalTopVisualOverflow(firstRootBox.lineTop());
 762     LayoutUnit logicalWidth = logicalRightSide - logicalLeftSide;
 763     LayoutUnit logicalHeight = lastLineBox()-&gt;logicalBottomVisualOverflow(lastRootBox.lineBottom()) - logicalTop;
 764 
 765     LayoutRect rect(logicalLeftSide, logicalTop, logicalWidth, logicalHeight);
 766     if (!style().isHorizontalWritingMode())
 767         rect = rect.transposedRect();
 768     return rect;
 769 }
 770 
 771 LayoutRect RenderInline::linesVisualOverflowBoundingBoxInFragment(const RenderFragmentContainer* fragment) const
 772 {
 773     ASSERT(alwaysCreateLineBoxes());
 774     ASSERT(fragment);
 775 
 776     if (!firstLineBox() || !lastLineBox())
 777         return LayoutRect();
 778 
 779     // Return the width of the minimal left side and the maximal right side.
 780     LayoutUnit logicalLeftSide = LayoutUnit::max();
 781     LayoutUnit logicalRightSide = LayoutUnit::min();
 782     LayoutUnit logicalTop;
 783     LayoutUnit logicalHeight;
 784     InlineFlowBox* lastInlineInFragment = 0;
 785     for (InlineFlowBox* curr = firstLineBox(); curr; curr = curr-&gt;nextLineBox()) {
 786         const RootInlineBox&amp; root = curr-&gt;root();
 787         if (root.containingFragment() != fragment) {
 788             if (lastInlineInFragment)
 789                 break;
 790             continue;
 791         }
 792 
 793         if (!lastInlineInFragment)
 794             logicalTop = curr-&gt;logicalTopVisualOverflow(root.lineTop());
 795 
 796         lastInlineInFragment = curr;
 797 
 798         logicalLeftSide = std::min(logicalLeftSide, curr-&gt;logicalLeftVisualOverflow());
 799         logicalRightSide = std::max(logicalRightSide, curr-&gt;logicalRightVisualOverflow());
 800     }
 801 
 802     if (!lastInlineInFragment)
 803         return LayoutRect();
 804 
 805     logicalHeight = lastInlineInFragment-&gt;logicalBottomVisualOverflow(lastInlineInFragment-&gt;root().lineBottom()) - logicalTop;
 806 
 807     LayoutUnit logicalWidth = logicalRightSide - logicalLeftSide;
 808 
 809     LayoutRect rect(logicalLeftSide, logicalTop, logicalWidth, logicalHeight);
 810     if (!style().isHorizontalWritingMode())
 811         rect = rect.transposedRect();
 812     return rect;
 813 }
 814 
 815 LayoutRect RenderInline::clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const
 816 {
 817     // Only first-letter renderers are allowed in here during layout. They mutate the tree triggering repaints.
 818     ASSERT(!view().frameView().layoutContext().isPaintOffsetCacheEnabled() || style().styleType() == PseudoId::FirstLetter || hasSelfPaintingLayer());
 819 
 820     if (!firstLineBoxIncludingCulling() &amp;&amp; !continuation())
 821         return LayoutRect();
 822 
 823     LayoutRect repaintRect(linesVisualOverflowBoundingBox());
 824     bool hitRepaintContainer = false;
 825 
 826     // We need to add in the in-flow position offsets of any inlines (including us) up to our
 827     // containing block.
 828     RenderBlock* containingBlock = this-&gt;containingBlock();
 829     for (const RenderElement* inlineFlow = this; is&lt;RenderInline&gt;(inlineFlow) &amp;&amp; inlineFlow != containingBlock;
 830          inlineFlow = inlineFlow-&gt;parent()) {
 831          if (inlineFlow == repaintContainer) {
 832             hitRepaintContainer = true;
 833             break;
 834         }
 835         if (inlineFlow-&gt;style().hasInFlowPosition() &amp;&amp; inlineFlow-&gt;hasLayer())
 836             repaintRect.move(downcast&lt;RenderInline&gt;(*inlineFlow).layer()-&gt;offsetForInFlowPosition());
 837     }
 838 
<a name="3" id="anc3"></a><span class="line-modified"> 839     LayoutUnit outlineSize { style().outlineSize() };</span>
 840     repaintRect.inflate(outlineSize);
 841 
 842     if (hitRepaintContainer || !containingBlock)
 843         return repaintRect;
 844 
 845     if (containingBlock-&gt;hasOverflowClip())
 846         containingBlock-&gt;applyCachedClipAndScrollPosition(repaintRect, repaintContainer, visibleRectContextForRepaint());
 847 
 848     repaintRect = containingBlock-&gt;computeRectForRepaint(repaintRect, repaintContainer);
 849 
 850     if (outlineSize) {
 851         for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(*this))
 852             repaintRect.unite(child.rectWithOutlineForRepaint(repaintContainer, outlineSize));
 853 
 854         if (RenderBoxModelObject* continuation = this-&gt;continuation()) {
 855             if (!continuation-&gt;isInline() &amp;&amp; continuation-&gt;parent())
 856                 repaintRect.unite(continuation-&gt;rectWithOutlineForRepaint(repaintContainer, outlineSize));
 857         }
 858     }
 859 
 860     return repaintRect;
 861 }
 862 
 863 LayoutRect RenderInline::rectWithOutlineForRepaint(const RenderLayerModelObject* repaintContainer, LayoutUnit outlineWidth) const
 864 {
 865     LayoutRect r(RenderBoxModelObject::rectWithOutlineForRepaint(repaintContainer, outlineWidth));
 866     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(*this))
 867         r.unite(child.rectWithOutlineForRepaint(repaintContainer, outlineWidth));
 868     return r;
 869 }
 870 
 871 LayoutRect RenderInline::computeVisibleRectUsingPaintOffset(const LayoutRect&amp; rect) const
 872 {
 873     LayoutRect adjustedRect = rect;
 874     auto* layoutState = view().frameView().layoutContext().layoutState();
 875     if (style().hasInFlowPosition() &amp;&amp; layer())
 876         adjustedRect.move(layer()-&gt;offsetForInFlowPosition());
 877     adjustedRect.move(layoutState-&gt;paintOffset());
 878     if (layoutState-&gt;isClipped())
 879         adjustedRect.intersect(layoutState-&gt;clipRect());
 880     return adjustedRect;
 881 }
 882 
 883 Optional&lt;LayoutRect&gt; RenderInline::computeVisibleRectInContainer(const LayoutRect&amp; rect, const RenderLayerModelObject* container, VisibleRectContext context) const
 884 {
 885     // Repaint offset cache is only valid for root-relative repainting
 886     if (view().frameView().layoutContext().isPaintOffsetCacheEnabled() &amp;&amp; !container &amp;&amp; !context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
 887         return computeVisibleRectUsingPaintOffset(rect);
 888 
 889     if (container == this)
 890         return rect;
 891 
 892     bool containerSkipped;
 893     RenderElement* localContainer = this-&gt;container(container, containerSkipped);
 894     if (!localContainer)
 895         return rect;
 896 
 897     LayoutRect adjustedRect = rect;
 898     LayoutPoint topLeft = adjustedRect.location();
 899 
 900     if (style().hasInFlowPosition() &amp;&amp; layer()) {
 901         // Apply the in-flow position offset when invalidating a rectangle. The layer
 902         // is translated, but the render box isn&#39;t, so we need to do this to get the
 903         // right dirty rect. Since this is called from RenderObject::setStyle, the relative or sticky position
 904         // flag on the RenderObject has been cleared, so use the one on the style().
 905         topLeft += layer()-&gt;offsetForInFlowPosition();
 906     }
 907 
 908     // FIXME: We ignore the lightweight clipping rect that controls use, since if |o| is in mid-layout,
 909     // its controlClipRect will be wrong. For overflow clip we use the values cached by the layer.
 910     adjustedRect.setLocation(topLeft);
 911     if (localContainer-&gt;hasOverflowClip()) {
 912         // FIXME: Respect the value of context.m_options.
 913         SetForScope&lt;OptionSet&lt;VisibleRectContextOption&gt;&gt; change(context.m_options, context.m_options | VisibleRectContextOption::ApplyCompositedContainerScrolls);
 914         bool isEmpty = !downcast&lt;RenderBox&gt;(*localContainer).applyCachedClipAndScrollPosition(adjustedRect, container, context);
 915         if (isEmpty) {
 916             if (context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
 917                 return WTF::nullopt;
 918             return adjustedRect;
 919         }
 920     }
 921 
 922     if (containerSkipped) {
 923         // If the repaintContainer is below o, then we need to map the rect into repaintContainer&#39;s coordinates.
 924         LayoutSize containerOffset = container-&gt;offsetFromAncestorContainer(*localContainer);
 925         adjustedRect.move(-containerOffset);
 926         return adjustedRect;
 927     }
 928     return localContainer-&gt;computeVisibleRectInContainer(adjustedRect, container, context);
 929 }
 930 
 931 LayoutSize RenderInline::offsetFromContainer(RenderElement&amp; container, const LayoutPoint&amp;, bool* offsetDependsOnPoint) const
 932 {
 933     ASSERT(&amp;container == this-&gt;container());
 934 
 935     LayoutSize offset;
 936     if (isInFlowPositioned())
 937         offset += offsetForInFlowPosition();
 938 
 939     if (is&lt;RenderBox&gt;(container))
 940         offset -= toLayoutSize(downcast&lt;RenderBox&gt;(container).scrollPosition());
 941 
 942     if (offsetDependsOnPoint)
 943         *offsetDependsOnPoint = (is&lt;RenderBox&gt;(container) &amp;&amp; container.style().isFlippedBlocksWritingMode()) || is&lt;RenderFragmentedFlow&gt;(container);
 944 
 945     return offset;
 946 }
 947 
 948 void RenderInline::mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp; transformState, MapCoordinatesFlags mode, bool* wasFixed) const
 949 {
 950     if (repaintContainer == this)
 951         return;
 952 
 953     if (view().frameView().layoutContext().isPaintOffsetCacheEnabled() &amp;&amp; !repaintContainer) {
 954         auto* layoutState = view().frameView().layoutContext().layoutState();
 955         LayoutSize offset = layoutState-&gt;paintOffset();
 956         if (style().hasInFlowPosition() &amp;&amp; layer())
 957             offset += layer()-&gt;offsetForInFlowPosition();
 958         transformState.move(offset);
 959         return;
 960     }
 961 
 962     bool containerSkipped;
 963     RenderElement* container = this-&gt;container(repaintContainer, containerSkipped);
 964     if (!container)
 965         return;
 966 
 967     if (mode &amp; ApplyContainerFlip &amp;&amp; is&lt;RenderBox&gt;(*container)) {
 968         if (container-&gt;style().isFlippedBlocksWritingMode()) {
 969             LayoutPoint centerPoint(transformState.mappedPoint());
 970             transformState.move(downcast&lt;RenderBox&gt;(*container).flipForWritingMode(centerPoint) - centerPoint);
 971         }
 972         mode &amp;= ~ApplyContainerFlip;
 973     }
 974 
 975     LayoutSize containerOffset = offsetFromContainer(*container, LayoutPoint(transformState.mappedPoint()));
 976 
 977     bool preserve3D = mode &amp; UseTransforms &amp;&amp; (container-&gt;style().preserves3D() || style().preserves3D());
 978     if (mode &amp; UseTransforms &amp;&amp; shouldUseTransformFromContainer(container)) {
 979         TransformationMatrix t;
 980         getTransformFromContainer(container, containerOffset, t);
 981         transformState.applyTransform(t, preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
 982     } else
 983         transformState.move(containerOffset.width(), containerOffset.height(), preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
 984 
 985     if (containerSkipped) {
 986         // There can&#39;t be a transform between repaintContainer and o, because transforms create containers, so it should be safe
 987         // to just subtract the delta between the repaintContainer and o.
 988         LayoutSize containerOffset = repaintContainer-&gt;offsetFromAncestorContainer(*container);
 989         transformState.move(-containerOffset.width(), -containerOffset.height(), preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
 990         return;
 991     }
 992 
 993     container-&gt;mapLocalToContainer(repaintContainer, transformState, mode, wasFixed);
 994 }
 995 
 996 const RenderObject* RenderInline::pushMappingToContainer(const RenderLayerModelObject* ancestorToStopAt, RenderGeometryMap&amp; geometryMap) const
 997 {
 998     ASSERT(ancestorToStopAt != this);
 999 
1000     bool ancestorSkipped;
1001     RenderElement* container = this-&gt;container(ancestorToStopAt, ancestorSkipped);
1002     if (!container)
1003         return nullptr;
1004 
1005     LayoutSize adjustmentForSkippedAncestor;
1006     if (ancestorSkipped) {
1007         // There can&#39;t be a transform between repaintContainer and o, because transforms create containers, so it should be safe
1008         // to just subtract the delta between the ancestor and o.
1009         adjustmentForSkippedAncestor = -ancestorToStopAt-&gt;offsetFromAncestorContainer(*container);
1010     }
1011 
1012     bool offsetDependsOnPoint = false;
1013     LayoutSize containerOffset = offsetFromContainer(*container, LayoutPoint(), &amp;offsetDependsOnPoint);
1014 
1015     bool preserve3D = container-&gt;style().preserves3D() || style().preserves3D();
1016     if (shouldUseTransformFromContainer(container)) {
1017         TransformationMatrix t;
1018         getTransformFromContainer(container, containerOffset, t);
1019         t.translateRight(adjustmentForSkippedAncestor.width(), adjustmentForSkippedAncestor.height()); // FIXME: right?
1020         geometryMap.push(this, t, preserve3D, offsetDependsOnPoint);
1021     } else {
1022         containerOffset += adjustmentForSkippedAncestor;
1023         geometryMap.push(this, containerOffset, preserve3D, offsetDependsOnPoint);
1024     }
1025 
1026     return ancestorSkipped ? ancestorToStopAt : container;
1027 }
1028 
1029 void RenderInline::updateDragState(bool dragOn)
1030 {
1031     RenderBoxModelObject::updateDragState(dragOn);
1032     if (RenderBoxModelObject* continuation = this-&gt;continuation())
1033         continuation-&gt;updateDragState(dragOn);
1034 }
1035 
1036 void RenderInline::updateHitTestResult(HitTestResult&amp; result, const LayoutPoint&amp; point)
1037 {
1038     if (result.innerNode())
1039         return;
1040 
1041     LayoutPoint localPoint(point);
1042     if (Element* element = this-&gt;element()) {
1043         if (isContinuation()) {
1044             // We&#39;re in the continuation of a split inline.  Adjust our local point to be in the coordinate space
1045             // of the principal renderer&#39;s containing block.  This will end up being the innerNonSharedNode.
1046             RenderBlock* firstBlock = element-&gt;renderer()-&gt;containingBlock();
1047 
1048             // Get our containing block.
1049             RenderBox* block = containingBlock();
1050             localPoint.moveBy(block-&gt;location() - firstBlock-&gt;locationOffset());
1051         }
1052 
1053         result.setInnerNode(element);
1054         if (!result.innerNonSharedNode())
1055             result.setInnerNonSharedNode(element);
1056         result.setLocalPoint(localPoint);
1057     }
1058 }
1059 
1060 void RenderInline::dirtyLineBoxes(bool fullLayout)
1061 {
1062     if (fullLayout) {
1063         m_lineBoxes.deleteLineBoxes();
1064         return;
1065     }
1066 
1067     if (!alwaysCreateLineBoxes()) {
1068         // We have to grovel into our children in order to dirty the appropriate lines.
1069         for (auto&amp; current : childrenOfType&lt;RenderObject&gt;(*this)) {
1070             if (current.isFloatingOrOutOfFlowPositioned())
1071                 continue;
1072             if (is&lt;RenderBox&gt;(current) &amp;&amp; !current.needsLayout()) {
1073                 auto&amp; renderBox = downcast&lt;RenderBox&gt;(current);
1074                 if (renderBox.inlineBoxWrapper())
1075                     renderBox.inlineBoxWrapper()-&gt;root().markDirty();
1076             } else if (!current.selfNeedsLayout()) {
1077                 if (is&lt;RenderInline&gt;(current)) {
1078                     auto&amp; renderInline = downcast&lt;RenderInline&gt;(current);
1079                     for (InlineFlowBox* childLine = renderInline.firstLineBox(); childLine; childLine = childLine-&gt;nextLineBox())
1080                         childLine-&gt;root().markDirty();
1081                 } else if (is&lt;RenderText&gt;(current)) {
1082                     auto&amp; renderText = downcast&lt;RenderText&gt;(current);
1083                     for (InlineTextBox* childText = renderText.firstTextBox(); childText; childText = childText-&gt;nextTextBox())
1084                         childText-&gt;root().markDirty();
1085                 } else if (is&lt;RenderLineBreak&gt;(current)) {
1086                     auto&amp; renderBR = downcast&lt;RenderLineBreak&gt;(current);
1087                     if (renderBR.inlineBoxWrapper())
1088                         renderBR.inlineBoxWrapper()-&gt;root().markDirty();
1089                 }
1090             }
1091         }
1092     } else
1093         m_lineBoxes.dirtyLineBoxes();
1094 }
1095 
1096 void RenderInline::deleteLines()
1097 {
1098     m_lineBoxes.deleteLineBoxTree();
1099 }
1100 
1101 std::unique_ptr&lt;InlineFlowBox&gt; RenderInline::createInlineFlowBox()
1102 {
<a name="4" id="anc4"></a><span class="line-modified">1103     return makeUnique&lt;InlineFlowBox&gt;(*this);</span>
1104 }
1105 
1106 InlineFlowBox* RenderInline::createAndAppendInlineFlowBox()
1107 {
1108     setAlwaysCreateLineBoxes();
1109     auto newFlowBox = createInlineFlowBox();
1110     auto flowBox = newFlowBox.get();
1111     m_lineBoxes.appendLineBox(WTFMove(newFlowBox));
1112     return flowBox;
1113 }
1114 
1115 LayoutUnit RenderInline::lineHeight(bool firstLine, LineDirectionMode /*direction*/, LinePositionMode /*linePositionMode*/) const
1116 {
1117     if (firstLine &amp;&amp; view().usesFirstLineRules()) {
1118         const RenderStyle&amp; firstLineStyle = this-&gt;firstLineStyle();
1119         if (&amp;firstLineStyle != &amp;style())
1120             return firstLineStyle.computedLineHeight();
1121     }
1122 
1123     return style().computedLineHeight();
1124 }
1125 
1126 int RenderInline::baselinePosition(FontBaseline baselineType, bool firstLine, LineDirectionMode direction, LinePositionMode linePositionMode) const
1127 {
1128     const RenderStyle&amp; style = firstLine ? firstLineStyle() : this-&gt;style();
1129     const FontMetrics&amp; fontMetrics = style.fontMetrics();
1130     return fontMetrics.ascent(baselineType) + (lineHeight(firstLine, direction, linePositionMode) - fontMetrics.height()) / 2;
1131 }
1132 
1133 LayoutSize RenderInline::offsetForInFlowPositionedInline(const RenderBox* child) const
1134 {
1135     // FIXME: This function isn&#39;t right with mixed writing modes.
1136 
1137     ASSERT(isInFlowPositioned());
1138     if (!isInFlowPositioned())
1139         return LayoutSize();
1140 
1141     // When we have an enclosing relpositioned inline, we need to add in the offset of the first line
1142     // box from the rest of the content, but only in the cases where we know we&#39;re positioned
1143     // relative to the inline itself.
1144 
1145     LayoutSize logicalOffset;
1146     LayoutUnit inlinePosition;
1147     LayoutUnit blockPosition;
1148     if (firstLineBox()) {
1149         inlinePosition = LayoutUnit::fromFloatRound(firstLineBox()-&gt;logicalLeft());
1150         blockPosition = firstLineBox()-&gt;logicalTop();
1151     } else {
1152         inlinePosition = layer()-&gt;staticInlinePosition();
1153         blockPosition = layer()-&gt;staticBlockPosition();
1154     }
1155 
1156     if (!child-&gt;style().hasStaticInlinePosition(style().isHorizontalWritingMode()))
1157         logicalOffset.setWidth(inlinePosition);
1158 
1159     // This is not terribly intuitive, but we have to match other browsers.  Despite being a block display type inside
1160     // an inline, we still keep our x locked to the left of the relative positioned inline.  Arguably the correct
1161     // behavior would be to go flush left to the block that contains the inline, but that isn&#39;t what other browsers
1162     // do.
1163     else if (!child-&gt;style().isOriginalDisplayInlineType())
1164         // Avoid adding in the left border/padding of the containing block twice.  Subtract it out.
1165         logicalOffset.setWidth(inlinePosition - child-&gt;containingBlock()-&gt;borderAndPaddingLogicalLeft());
1166 
1167     if (!child-&gt;style().hasStaticBlockPosition(style().isHorizontalWritingMode()))
1168         logicalOffset.setHeight(blockPosition);
1169 
1170     return style().isHorizontalWritingMode() ? logicalOffset : logicalOffset.transposedSize();
1171 }
1172 
1173 void RenderInline::imageChanged(WrappedImagePtr, const IntRect*)
1174 {
1175     if (!parent())
1176         return;
1177 
1178     // FIXME: We can do better.
1179     repaint();
1180 }
1181 
1182 void RenderInline::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject* paintContainer)
1183 {
1184     AbsoluteRectsGeneratorContext context(rects, additionalOffset);
1185     generateLineBoxRects(context);
1186 
1187     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(*this)) {
1188         if (is&lt;RenderListMarker&gt;(child))
1189             continue;
1190         FloatPoint pos(additionalOffset);
1191         // FIXME: This doesn&#39;t work correctly with transforms.
1192         if (child.hasLayer())
1193             pos = child.localToContainerPoint(FloatPoint(), paintContainer);
1194         else if (is&lt;RenderBox&gt;(child))
1195             pos.move(downcast&lt;RenderBox&gt;(child).locationOffset());
1196         child.addFocusRingRects(rects, flooredIntPoint(pos), paintContainer);
1197     }
1198 
1199     if (RenderBoxModelObject* continuation = this-&gt;continuation()) {
1200         if (continuation-&gt;isInline())
1201             continuation-&gt;addFocusRingRects(rects, flooredLayoutPoint(LayoutPoint(additionalOffset + continuation-&gt;containingBlock()-&gt;location() - containingBlock()-&gt;location())), paintContainer);
1202         else
1203             continuation-&gt;addFocusRingRects(rects, flooredLayoutPoint(LayoutPoint(additionalOffset + downcast&lt;RenderBox&gt;(*continuation).location() - containingBlock()-&gt;location())), paintContainer);
1204     }
1205 }
1206 
1207 void RenderInline::paintOutline(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1208 {
1209     if (!hasOutline())
1210         return;
1211 
1212     auto&amp; styleToUse = style();
1213     // Only paint the focus ring by hand if the theme isn&#39;t able to draw it.
1214     if (styleToUse.outlineStyleIsAuto() == OutlineIsAuto::On &amp;&amp; !theme().supportsFocusRing(styleToUse)) {
1215         Vector&lt;LayoutRect&gt; focusRingRects;
1216         addFocusRingRects(focusRingRects, paintOffset, paintInfo.paintContainer);
1217         paintFocusRing(paintInfo, styleToUse, focusRingRects);
1218     }
1219 
1220     if (hasOutlineAnnotation() &amp;&amp; styleToUse.outlineStyleIsAuto() == OutlineIsAuto::Off &amp;&amp; !theme().supportsFocusRing(styleToUse))
1221         addPDFURLRect(paintInfo, paintOffset);
1222 
1223     GraphicsContext&amp; graphicsContext = paintInfo.context();
1224     if (graphicsContext.paintingDisabled())
1225         return;
1226 
1227     if (styleToUse.outlineStyleIsAuto() == OutlineIsAuto::On || !styleToUse.hasOutline())
1228         return;
1229 
1230     Vector&lt;LayoutRect&gt; rects;
1231     rects.append(LayoutRect());
1232     for (InlineFlowBox* curr = firstLineBox(); curr; curr = curr-&gt;nextLineBox()) {
1233         const RootInlineBox&amp; rootBox = curr-&gt;root();
<a name="5" id="anc5"></a><span class="line-modified">1234         LayoutUnit top = std::max(rootBox.lineTop(), LayoutUnit(curr-&gt;logicalTop()));</span>
<span class="line-modified">1235         LayoutUnit bottom = std::min(rootBox.lineBottom(), LayoutUnit(curr-&gt;logicalBottom()));</span>
<span class="line-modified">1236         rects.append({ LayoutUnit(curr-&gt;x()), top, LayoutUnit(curr-&gt;logicalWidth()), bottom - top });</span>
1237     }
1238     rects.append(LayoutRect());
1239 
1240     Color outlineColor = styleToUse.visitedDependentColorWithColorFilter(CSSPropertyOutlineColor);
1241     bool useTransparencyLayer = !outlineColor.isOpaque();
1242     if (useTransparencyLayer) {
1243         graphicsContext.beginTransparencyLayer(outlineColor.alphaAsFloat());
1244         outlineColor = outlineColor.opaqueColor();
1245     }
1246 
1247     for (unsigned i = 1; i &lt; rects.size() - 1; i++)
1248         paintOutlineForLine(graphicsContext, paintOffset, rects.at(i - 1), rects.at(i), rects.at(i + 1), outlineColor);
1249 
1250     if (useTransparencyLayer)
1251         graphicsContext.endTransparencyLayer();
1252 }
1253 
1254 void RenderInline::paintOutlineForLine(GraphicsContext&amp; graphicsContext, const LayoutPoint&amp; paintOffset,
1255     const LayoutRect&amp; previousLine, const LayoutRect&amp; thisLine, const LayoutRect&amp; nextLine, const Color&amp; outlineColor)
1256 {
1257     const auto&amp; styleToUse = style();
1258     float outlineOffset = styleToUse.outlineOffset();
1259     LayoutRect outlineBoxRect = thisLine;
1260     outlineBoxRect.inflate(outlineOffset);
1261     outlineBoxRect.moveBy(paintOffset);
1262     if (outlineBoxRect.isEmpty())
1263         return;
1264 
1265     float outlineWidth = styleToUse.outlineWidth();
1266     BorderStyle outlineStyle = styleToUse.outlineStyle();
1267     bool antialias = shouldAntialiasLines(graphicsContext);
1268 
1269     auto adjustedPreviousLine = previousLine;
1270     adjustedPreviousLine.moveBy(paintOffset);
1271     auto adjustedNextLine = nextLine;
1272     adjustedNextLine.moveBy(paintOffset);
1273 
1274     float adjacentWidth1 = 0;
1275     float adjacentWidth2 = 0;
1276     // left edge
1277     auto topLeft = outlineBoxRect.minXMinYCorner();
1278     if (previousLine.isEmpty() || thisLine.x() &lt; previousLine.x() || (previousLine.maxX()) &lt;= thisLine.x()) {
1279         topLeft.move(-outlineWidth, -outlineWidth);
1280         adjacentWidth1 = outlineWidth;
1281     } else {
1282         topLeft.move(-outlineWidth, 2 * outlineOffset);
1283         adjacentWidth1 = -outlineWidth;
1284     }
1285     auto bottomRight = outlineBoxRect.minXMaxYCorner();
1286     if (nextLine.isEmpty() || thisLine.x() &lt;= nextLine.x() || (nextLine.maxX()) &lt;= thisLine.x()) {
1287         bottomRight.move(0, outlineWidth);
1288         adjacentWidth2 = outlineWidth;
1289     } else {
1290         bottomRight.move(0, -2 * outlineOffset);
1291         adjacentWidth2 = -outlineWidth;
1292     }
1293     drawLineForBoxSide(graphicsContext, FloatRect(topLeft, bottomRight), BSLeft, outlineColor, outlineStyle, adjacentWidth1, adjacentWidth2, antialias);
1294 
1295     // right edge
1296     topLeft = outlineBoxRect.maxXMinYCorner();
1297     if (previousLine.isEmpty() || previousLine.maxX() &lt; thisLine.maxX() || thisLine.maxX() &lt;= previousLine.x()) {
1298         topLeft.move(0, -outlineWidth);
1299         adjacentWidth1 = outlineWidth;
1300     } else {
1301         topLeft.move(0, 2 * outlineOffset);
1302         adjacentWidth1 = -outlineWidth;
1303     }
1304     bottomRight = outlineBoxRect.maxXMaxYCorner();
1305     if (nextLine.isEmpty() || nextLine.maxX() &lt;= thisLine.maxX() || thisLine.maxX() &lt;= nextLine.x()) {
1306         bottomRight.move(outlineWidth, outlineWidth);
1307         adjacentWidth2 = outlineWidth;
1308     } else {
1309         bottomRight.move(outlineWidth, -2 * outlineOffset);
1310         adjacentWidth2 = -outlineWidth;
1311     }
1312     drawLineForBoxSide(graphicsContext, FloatRect(topLeft, bottomRight), BSRight, outlineColor, outlineStyle, adjacentWidth1, adjacentWidth2, antialias);
1313 
1314     // upper edge
1315     if (thisLine.x() &lt; previousLine.x()) {
1316         topLeft = outlineBoxRect.minXMinYCorner();
1317         topLeft.move(-outlineWidth, -outlineWidth);
1318         adjacentWidth1 = outlineWidth;
1319         bottomRight = outlineBoxRect.maxXMinYCorner();
1320         bottomRight.move(outlineWidth, 0);
1321         if (!previousLine.isEmpty() &amp;&amp; adjustedPreviousLine.x() &lt; bottomRight.x()) {
1322             bottomRight.setX(adjustedPreviousLine.x() - outlineOffset);
1323             adjacentWidth2 = -outlineWidth;
1324         } else
1325             adjacentWidth2 = outlineWidth;
1326         drawLineForBoxSide(graphicsContext, FloatRect(topLeft, bottomRight), BSTop, outlineColor, outlineStyle, adjacentWidth1, adjacentWidth2, antialias);
1327     }
1328 
1329     if (previousLine.maxX() &lt; thisLine.maxX()) {
1330         topLeft = outlineBoxRect.minXMinYCorner();
1331         topLeft.move(-outlineWidth, -outlineWidth);
1332         if (!previousLine.isEmpty() &amp;&amp; adjustedPreviousLine.maxX() &gt; topLeft.x()) {
1333             topLeft.setX(adjustedPreviousLine.maxX() + outlineOffset);
1334             adjacentWidth1 = -outlineWidth;
1335         } else
1336             adjacentWidth1 = outlineWidth;
1337         bottomRight = outlineBoxRect.maxXMinYCorner();
1338         bottomRight.move(outlineWidth, 0);
1339         adjacentWidth2 = outlineWidth;
1340         drawLineForBoxSide(graphicsContext, FloatRect(topLeft, bottomRight), BSTop, outlineColor, outlineStyle, adjacentWidth1, adjacentWidth2, antialias);
1341     }
1342 
1343     if (thisLine.x() == thisLine.maxX()) {
1344         topLeft = outlineBoxRect.minXMinYCorner();
1345         topLeft.move(-outlineWidth, -outlineWidth);
1346         adjacentWidth1 = outlineWidth;
1347         bottomRight = outlineBoxRect.maxXMinYCorner();
1348         bottomRight.move(outlineWidth, 0);
1349         adjacentWidth2 = outlineWidth;
1350         drawLineForBoxSide(graphicsContext, FloatRect(topLeft, bottomRight), BSTop, outlineColor, outlineStyle, adjacentWidth1, adjacentWidth2, antialias);
1351     }
1352 
1353     // lower edge
1354     if (thisLine.x() &lt; nextLine.x()) {
1355         topLeft = outlineBoxRect.minXMaxYCorner();
1356         topLeft.move(-outlineWidth, 0);
1357         adjacentWidth1 = outlineWidth;
1358         bottomRight = outlineBoxRect.maxXMaxYCorner();
1359         bottomRight.move(outlineWidth, outlineWidth);
1360         if (!nextLine.isEmpty() &amp;&amp; (adjustedNextLine.x() &lt; bottomRight.x())) {
1361             bottomRight.setX(adjustedNextLine.x() - outlineOffset);
1362             adjacentWidth2 = -outlineWidth;
1363         } else
1364             adjacentWidth2 = outlineWidth;
1365         drawLineForBoxSide(graphicsContext, FloatRect(topLeft, bottomRight), BSBottom, outlineColor, outlineStyle, adjacentWidth1, adjacentWidth2, antialias);
1366     }
1367 
1368     if (nextLine.maxX() &lt; thisLine.maxX()) {
1369         topLeft = outlineBoxRect.minXMaxYCorner();
1370         topLeft.move(-outlineWidth, 0);
1371         if (!nextLine.isEmpty() &amp;&amp; adjustedNextLine.maxX() &gt; topLeft.x()) {
1372             topLeft.setX(adjustedNextLine.maxX() + outlineOffset);
1373             adjacentWidth1 = -outlineWidth;
1374         } else
1375             adjacentWidth1 = outlineWidth;
1376         bottomRight = outlineBoxRect.maxXMaxYCorner();
1377         bottomRight.move(outlineWidth, outlineWidth);
1378         adjacentWidth2 = outlineWidth;
1379         drawLineForBoxSide(graphicsContext, FloatRect(topLeft, bottomRight), BSBottom, outlineColor, outlineStyle, adjacentWidth1, adjacentWidth2, antialias);
1380     }
1381 
1382     if (thisLine.x() == thisLine.maxX()) {
1383         topLeft = outlineBoxRect.minXMaxYCorner();
1384         topLeft.move(-outlineWidth, 0);
1385         adjacentWidth1 = outlineWidth;
1386         bottomRight = outlineBoxRect.maxXMaxYCorner();
1387         bottomRight.move(outlineWidth, outlineWidth);
1388         adjacentWidth2 = outlineWidth;
1389         drawLineForBoxSide(graphicsContext, FloatRect(topLeft, bottomRight), BSBottom, outlineColor, outlineStyle, adjacentWidth1, adjacentWidth2, antialias);
1390     }
1391 }
1392 
<a name="6" id="anc6"></a>










































1393 } // namespace WebCore
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>