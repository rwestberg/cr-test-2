<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/HTMLInputElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   5  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.
   6  *           (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   7  * Copyright (C) 2007 Samuel Weinig (sam@webkit.org)
   8  * Copyright (C) 2010 Google Inc. All rights reserved.
   9  * Copyright (C) 2008 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  10  * Copyright (C) 2012 Samsung Electronics. All rights reserved.
  11  *
  12  * This library is free software; you can redistribute it and/or
  13  * modify it under the terms of the GNU Library General Public
  14  * License as published by the Free Software Foundation; either
  15  * version 2 of the License, or (at your option) any later version.
  16  *
  17  * This library is distributed in the hope that it will be useful,
  18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  20  * Library General Public License for more details.
  21  *
  22  * You should have received a copy of the GNU Library General Public License
  23  * along with this library; see the file COPYING.LIB.  If not, write to
  24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  25  * Boston, MA 02110-1301, USA.
  26  *
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;HTMLInputElement.h&quot;
  31 
  32 #include &quot;AXObjectCache.h&quot;
  33 #include &quot;BeforeTextInsertedEvent.h&quot;
  34 #include &quot;CSSGradientValue.h&quot;
  35 #include &quot;CSSPropertyNames.h&quot;
  36 #include &quot;CSSValuePool.h&quot;
  37 #include &quot;Chrome.h&quot;
  38 #include &quot;ChromeClient.h&quot;
  39 #include &quot;DateTimeChooser.h&quot;
  40 #include &quot;Document.h&quot;
  41 #include &quot;Editor.h&quot;
  42 #include &quot;EventNames.h&quot;
  43 #include &quot;FileInputType.h&quot;
  44 #include &quot;FileList.h&quot;
  45 #include &quot;FormController.h&quot;
  46 #include &quot;Frame.h&quot;
  47 #include &quot;FrameSelection.h&quot;
  48 #include &quot;FrameView.h&quot;
  49 #include &quot;HTMLDataListElement.h&quot;
  50 #include &quot;HTMLFormElement.h&quot;
  51 #include &quot;HTMLImageLoader.h&quot;
  52 #include &quot;HTMLOptionElement.h&quot;
  53 #include &quot;HTMLParserIdioms.h&quot;
  54 #include &quot;IdTargetObserver.h&quot;
  55 #include &quot;KeyboardEvent.h&quot;
  56 #include &quot;LocalizedStrings.h&quot;
  57 #include &quot;MouseEvent.h&quot;
  58 #include &quot;Page.h&quot;
  59 #include &quot;PlatformMouseEvent.h&quot;
  60 #include &quot;RenderTextControlSingleLine.h&quot;
  61 #include &quot;RenderTheme.h&quot;
  62 #include &quot;ScopedEventQueue.h&quot;
  63 #include &quot;SearchInputType.h&quot;
  64 #include &quot;Settings.h&quot;
  65 #include &quot;StyleResolver.h&quot;
  66 #include &quot;TextControlInnerElements.h&quot;
  67 #include &lt;wtf/IsoMallocInlines.h&gt;
  68 #include &lt;wtf/Language.h&gt;
  69 #include &lt;wtf/MathExtras.h&gt;
  70 #include &lt;wtf/Ref.h&gt;
  71 
  72 #if ENABLE(TOUCH_EVENTS)
  73 #include &quot;TouchEvent.h&quot;
  74 #endif
  75 
  76 namespace WebCore {
  77 
  78 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLInputElement);
  79 
  80 using namespace HTMLNames;
  81 
  82 #if ENABLE(DATALIST_ELEMENT)
  83 class ListAttributeTargetObserver : IdTargetObserver {
  84     WTF_MAKE_FAST_ALLOCATED;
  85 public:
  86     ListAttributeTargetObserver(const AtomString&amp; id, HTMLInputElement*);
  87 
  88     void idTargetChanged() override;
  89 
  90 private:
  91     HTMLInputElement* m_element;
  92 };
  93 #endif
  94 
  95 // FIXME: According to HTML4, the length attribute&#39;s value can be arbitrarily
  96 // large. However, due to https://bugs.webkit.org/show_bug.cgi?id=14536 things
  97 // get rather sluggish when a text field has a larger number of characters than
  98 // this, even when just clicking in the text field.
  99 const unsigned HTMLInputElement::maxEffectiveLength = 524288;
 100 const int defaultSize = 20;
 101 const int maxSavedResults = 256;
 102 
 103 HTMLInputElement::HTMLInputElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form, bool createdByParser)
 104     : HTMLTextFormControlElement(tagName, document, form)
 105     , m_size(defaultSize)
 106     , m_isChecked(false)
 107     , m_dirtyCheckednessFlag(false)
 108     , m_isIndeterminate(false)
 109     , m_hasType(false)
 110     , m_isActivatedSubmit(false)
 111     , m_autocomplete(Uninitialized)
 112     , m_isAutoFilled(false)
 113     , m_isAutoFilledAndViewable(false)
 114     , m_autoFillButtonType(static_cast&lt;uint8_t&gt;(AutoFillButtonType::None))
 115     , m_lastAutoFillButtonType(static_cast&lt;uint8_t&gt;(AutoFillButtonType::None))
 116     , m_isAutoFillAvailable(false)
 117 #if ENABLE(DATALIST_ELEMENT)
 118     , m_hasNonEmptyList(false)
 119 #endif
 120     , m_stateRestored(false)
 121     , m_parsingInProgress(createdByParser)
 122     , m_valueAttributeWasUpdatedAfterParsing(false)
 123     , m_wasModifiedByUser(false)
 124     , m_canReceiveDroppedFiles(false)
 125 #if ENABLE(TOUCH_EVENTS)
 126     , m_hasTouchEventHandler(false)
 127 #endif
 128     , m_isSpellcheckDisabledExceptTextReplacement(false)
 129 {
 130     // m_inputType is lazily created when constructed by the parser to avoid constructing unnecessarily a text inputType and
 131     // its shadow subtree, just to destroy them when the |type| attribute gets set by the parser to something else than &#39;text&#39;.
 132     if (!createdByParser)
 133         m_inputType = InputType::createText(*this);
 134 
 135     ASSERT(hasTagName(inputTag));
 136     setHasCustomStyleResolveCallbacks();
 137 }
 138 
 139 Ref&lt;HTMLInputElement&gt; HTMLInputElement::create(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form, bool createdByParser)
 140 {
 141     bool shouldCreateShadowRootLazily = createdByParser;
 142     Ref&lt;HTMLInputElement&gt; inputElement = adoptRef(*new HTMLInputElement(tagName, document, form, createdByParser));
 143     if (!shouldCreateShadowRootLazily)
 144         inputElement-&gt;ensureUserAgentShadowRoot();
 145     return inputElement;
 146 }
 147 
 148 HTMLImageLoader&amp; HTMLInputElement::ensureImageLoader()
 149 {
 150     if (!m_imageLoader)
 151         m_imageLoader = makeUnique&lt;HTMLImageLoader&gt;(*this);
 152     return *m_imageLoader;
 153 }
 154 
 155 void HTMLInputElement::didAddUserAgentShadowRoot(ShadowRoot&amp;)
 156 {
 157     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 158     protectedInputType-&gt;createShadowSubtree();
 159     updateInnerTextElementEditability();
 160 }
 161 
 162 HTMLInputElement::~HTMLInputElement()
 163 {
 164     if (needsSuspensionCallback())
 165         document().unregisterForDocumentSuspensionCallbacks(*this);
 166 
 167     // Need to remove form association while this is still an HTMLInputElement
 168     // so that virtual functions are called correctly.
 169     setForm(nullptr);
 170 
 171     // This is needed for a radio button that was not in a form, and also for
 172     // a radio button that was in a form. The call to setForm(nullptr) above
 173     // actually adds the button to the document groups in the latter case.
 174     // That is inelegant, but harmless since we remove it here.
 175     if (isRadioButton())
 176         document().formController().radioButtonGroups().removeButton(*this);
 177 
 178 #if ENABLE(TOUCH_EVENTS)
 179     if (m_hasTouchEventHandler)
 180         document().didRemoveEventTargetNode(*this);
 181 #endif
 182 }
 183 
 184 const AtomString&amp; HTMLInputElement::name() const
 185 {
 186     return m_name.isNull() ? emptyAtom() : m_name;
 187 }
 188 
 189 Vector&lt;FileChooserFileInfo&gt; HTMLInputElement::filesFromFileInputFormControlState(const FormControlState&amp; state)
 190 {
 191     return FileInputType::filesFromFormControlState(state);
 192 }
 193 
 194 HTMLElement* HTMLInputElement::containerElement() const
 195 {
 196     return m_inputType-&gt;containerElement();
 197 }
 198 
 199 RefPtr&lt;TextControlInnerTextElement&gt; HTMLInputElement::innerTextElement() const
 200 {
 201     return m_inputType-&gt;innerTextElement();
 202 }
 203 
 204 HTMLElement* HTMLInputElement::innerBlockElement() const
 205 {
 206     return m_inputType-&gt;innerBlockElement();
 207 }
 208 
 209 HTMLElement* HTMLInputElement::innerSpinButtonElement() const
 210 {
 211     return m_inputType-&gt;innerSpinButtonElement();
 212 }
 213 
 214 HTMLElement* HTMLInputElement::capsLockIndicatorElement() const
 215 {
 216     return m_inputType-&gt;capsLockIndicatorElement();
 217 }
 218 
 219 HTMLElement* HTMLInputElement::autoFillButtonElement() const
 220 {
 221     return m_inputType-&gt;autoFillButtonElement();
 222 }
 223 
 224 HTMLElement* HTMLInputElement::resultsButtonElement() const
 225 {
 226     return m_inputType-&gt;resultsButtonElement();
 227 }
 228 
 229 HTMLElement* HTMLInputElement::cancelButtonElement() const
 230 {
 231     return m_inputType-&gt;cancelButtonElement();
 232 }
 233 
 234 HTMLElement* HTMLInputElement::sliderThumbElement() const
 235 {
 236     return m_inputType-&gt;sliderThumbElement();
 237 }
 238 
 239 HTMLElement* HTMLInputElement::sliderTrackElement() const
 240 {
 241     return m_inputType-&gt;sliderTrackElement();
 242 }
 243 
 244 HTMLElement* HTMLInputElement::placeholderElement() const
 245 {
 246     return m_inputType-&gt;placeholderElement();
 247 }
 248 
 249 #if ENABLE(DATALIST_ELEMENT)
 250 HTMLElement* HTMLInputElement::dataListButtonElement() const
 251 {
 252     return m_inputType-&gt;dataListButtonElement();
 253 }
 254 #endif
 255 
 256 bool HTMLInputElement::shouldAutocomplete() const
 257 {
 258     if (m_autocomplete != Uninitialized)
 259         return m_autocomplete == On;
 260     return HTMLTextFormControlElement::shouldAutocomplete();
 261 }
 262 
 263 bool HTMLInputElement::isValidValue(const String&amp; value) const
 264 {
 265     if (!m_inputType-&gt;canSetStringValue()) {
 266         ASSERT_NOT_REACHED();
 267         return false;
 268     }
 269     return !m_inputType-&gt;typeMismatchFor(value)
 270         &amp;&amp; !m_inputType-&gt;stepMismatch(value)
 271         &amp;&amp; !m_inputType-&gt;rangeUnderflow(value)
 272         &amp;&amp; !m_inputType-&gt;rangeOverflow(value)
 273         &amp;&amp; !tooShort(value, IgnoreDirtyFlag)
 274         &amp;&amp; !tooLong(value, IgnoreDirtyFlag)
 275         &amp;&amp; !m_inputType-&gt;patternMismatch(value)
 276         &amp;&amp; !m_inputType-&gt;valueMissing(value);
 277 }
 278 
 279 bool HTMLInputElement::tooShort() const
 280 {
 281     return willValidate() &amp;&amp; tooShort(value(), CheckDirtyFlag);
 282 }
 283 
 284 bool HTMLInputElement::tooLong() const
 285 {
 286     return willValidate() &amp;&amp; tooLong(value(), CheckDirtyFlag);
 287 }
 288 
 289 bool HTMLInputElement::typeMismatch() const
 290 {
 291     return willValidate() &amp;&amp; m_inputType-&gt;typeMismatch();
 292 }
 293 
 294 bool HTMLInputElement::valueMissing() const
 295 {
 296     return willValidate() &amp;&amp; m_inputType-&gt;valueMissing(value());
 297 }
 298 
 299 bool HTMLInputElement::hasBadInput() const
 300 {
 301     return willValidate() &amp;&amp; m_inputType-&gt;hasBadInput();
 302 }
 303 
 304 bool HTMLInputElement::patternMismatch() const
 305 {
 306     return willValidate() &amp;&amp; m_inputType-&gt;patternMismatch(value());
 307 }
 308 
 309 bool HTMLInputElement::tooShort(StringView value, NeedsToCheckDirtyFlag check) const
 310 {
 311     if (!supportsMinLength())
 312         return false;
 313 
 314     int min = minLength();
 315     if (min &lt;= 0)
 316         return false;
 317 
 318     if (check == CheckDirtyFlag) {
 319         // Return false for the default value or a value set by a script even if
 320         // it is shorter than minLength.
 321         if (!hasDirtyValue() || !m_wasModifiedByUser)
 322             return false;
 323     }
 324 
 325     // The empty string is excluded from tooShort validation.
 326     if (value.isEmpty())
 327         return false;
 328 
 329     // FIXME: The HTML specification says that the &quot;number of characters&quot; is measured using code-unit length.
 330     return numGraphemeClusters(value) &lt; static_cast&lt;unsigned&gt;(min);
 331 }
 332 
 333 bool HTMLInputElement::tooLong(StringView value, NeedsToCheckDirtyFlag check) const
 334 {
 335     if (!supportsMaxLength())
 336         return false;
 337     unsigned max = effectiveMaxLength();
 338     if (check == CheckDirtyFlag) {
 339         // Return false for the default value or a value set by a script even if
 340         // it is longer than maxLength.
 341         if (!hasDirtyValue() || !m_wasModifiedByUser)
 342             return false;
 343     }
 344     // FIXME: The HTML specification says that the &quot;number of characters&quot; is measured using code-unit length.
 345     return numGraphemeClusters(value) &gt; max;
 346 }
 347 
 348 bool HTMLInputElement::rangeUnderflow() const
 349 {
 350     return willValidate() &amp;&amp; m_inputType-&gt;rangeUnderflow(value());
 351 }
 352 
 353 bool HTMLInputElement::rangeOverflow() const
 354 {
 355     return willValidate() &amp;&amp; m_inputType-&gt;rangeOverflow(value());
 356 }
 357 
 358 String HTMLInputElement::validationMessage() const
 359 {
 360     if (!willValidate())
 361         return String();
 362 
 363     if (customError())
 364         return customValidationMessage();
 365 
 366     return m_inputType-&gt;validationMessage();
 367 }
 368 
 369 double HTMLInputElement::minimum() const
 370 {
 371     return m_inputType-&gt;minimum();
 372 }
 373 
 374 double HTMLInputElement::maximum() const
 375 {
 376     return m_inputType-&gt;maximum();
 377 }
 378 
 379 bool HTMLInputElement::stepMismatch() const
 380 {
 381     return willValidate() &amp;&amp; m_inputType-&gt;stepMismatch(value());
 382 }
 383 
 384 bool HTMLInputElement::isValid() const
 385 {
 386     if (!willValidate())
 387         return true;
 388 
 389     String value = this-&gt;value();
 390     bool someError = m_inputType-&gt;typeMismatch() || m_inputType-&gt;stepMismatch(value) || m_inputType-&gt;rangeUnderflow(value) || m_inputType-&gt;rangeOverflow(value)
 391         || tooShort(value, CheckDirtyFlag) || tooLong(value, CheckDirtyFlag) || m_inputType-&gt;patternMismatch(value) || m_inputType-&gt;valueMissing(value)
 392         || m_inputType-&gt;hasBadInput() || customError();
 393     return !someError;
 394 }
 395 
 396 bool HTMLInputElement::getAllowedValueStep(Decimal* step) const
 397 {
 398     return m_inputType-&gt;getAllowedValueStep(step);
 399 }
 400 
 401 StepRange HTMLInputElement::createStepRange(AnyStepHandling anyStepHandling) const
 402 {
 403     return m_inputType-&gt;createStepRange(anyStepHandling);
 404 }
 405 
 406 #if ENABLE(DATALIST_ELEMENT)
 407 Optional&lt;Decimal&gt; HTMLInputElement::findClosestTickMarkValue(const Decimal&amp; value)
 408 {
 409     return m_inputType-&gt;findClosestTickMarkValue(value);
 410 }
 411 #endif
 412 
 413 ExceptionOr&lt;void&gt; HTMLInputElement::stepUp(int n)
 414 {
 415     return m_inputType-&gt;stepUp(n);
 416 }
 417 
 418 ExceptionOr&lt;void&gt; HTMLInputElement::stepDown(int n)
 419 {
 420     return m_inputType-&gt;stepUp(-n);
 421 }
 422 
 423 void HTMLInputElement::blur()
 424 {
 425     m_inputType-&gt;blur();
 426 }
 427 
 428 void HTMLInputElement::defaultBlur()
 429 {
 430     HTMLTextFormControlElement::blur();
 431 }
 432 
 433 bool HTMLInputElement::hasCustomFocusLogic() const
 434 {
 435     return m_inputType-&gt;hasCustomFocusLogic();
 436 }
 437 
 438 int HTMLInputElement::defaultTabIndex() const
 439 {
 440     return 0;
 441 }
 442 
 443 bool HTMLInputElement::isKeyboardFocusable(KeyboardEvent* event) const
 444 {
 445     return m_inputType-&gt;isKeyboardFocusable(event);
 446 }
 447 
 448 bool HTMLInputElement::isMouseFocusable() const
 449 {
 450     return m_inputType-&gt;isMouseFocusable();
 451 }
 452 
 453 bool HTMLInputElement::isInteractiveContent() const
 454 {
 455     return m_inputType-&gt;isInteractiveContent();
 456 }
 457 
 458 bool HTMLInputElement::isTextFormControlFocusable() const
 459 {
 460     return HTMLTextFormControlElement::isFocusable();
 461 }
 462 
 463 bool HTMLInputElement::isTextFormControlKeyboardFocusable(KeyboardEvent* event) const
 464 {
 465     return HTMLTextFormControlElement::isKeyboardFocusable(event);
 466 }
 467 
 468 bool HTMLInputElement::isTextFormControlMouseFocusable() const
 469 {
 470     return HTMLTextFormControlElement::isMouseFocusable();
 471 }
 472 
 473 void HTMLInputElement::updateFocusAppearance(SelectionRestorationMode restorationMode, SelectionRevealMode revealMode)
 474 {
 475     if (isTextField()) {
 476         if (restorationMode == SelectionRestorationMode::SetDefault || !hasCachedSelection())
 477             setDefaultSelectionAfterFocus(revealMode);
 478         else
 479             restoreCachedSelection(revealMode);
 480     } else
 481         HTMLTextFormControlElement::updateFocusAppearance(restorationMode, revealMode);
 482 }
 483 
 484 void HTMLInputElement::setDefaultSelectionAfterFocus(SelectionRevealMode revealMode)
 485 {
 486     ASSERT(isTextField());
 487     int start = 0;
 488     auto direction = SelectionHasNoDirection;
 489     auto* frame = document().frame();
 490     if (frame &amp;&amp; frame-&gt;editor().behavior().shouldMoveSelectionToEndWhenFocusingTextInput()) {
 491         start = std::numeric_limits&lt;int&gt;::max();
 492         direction = SelectionHasForwardDirection;
 493     }
 494     setSelectionRange(start, std::numeric_limits&lt;int&gt;::max(), direction, revealMode, Element::defaultFocusTextStateChangeIntent());
 495 }
 496 
 497 void HTMLInputElement::endEditing()
 498 {
 499     if (!isTextField())
 500         return;
 501 
 502     if (RefPtr&lt;Frame&gt; frame = document().frame())
 503         frame-&gt;editor().textFieldDidEndEditing(this);
 504 }
 505 
 506 bool HTMLInputElement::shouldUseInputMethod()
 507 {
 508     return m_inputType-&gt;shouldUseInputMethod();
 509 }
 510 
 511 void HTMLInputElement::handleFocusEvent(Node* oldFocusedNode, FocusDirection direction)
 512 {
 513     m_inputType-&gt;handleFocusEvent(oldFocusedNode, direction);
 514 }
 515 
 516 void HTMLInputElement::handleBlurEvent()
 517 {
 518     m_inputType-&gt;handleBlurEvent();
 519 }
 520 
 521 void HTMLInputElement::setType(const AtomString&amp; type)
 522 {
 523     setAttributeWithoutSynchronization(typeAttr, type);
 524 }
 525 
 526 void HTMLInputElement::resignStrongPasswordAppearance()
 527 {
 528     if (!hasAutoFillStrongPasswordButton())
 529         return;
 530     setAutoFilled(false);
 531     setAutoFilledAndViewable(false);
 532     setShowAutoFillButton(AutoFillButtonType::None);
 533     if (auto* page = document().page())
 534         page-&gt;chrome().client().inputElementDidResignStrongPasswordAppearance(*this);
 535 }
 536 
 537 void HTMLInputElement::updateType()
 538 {
 539     ASSERT(m_inputType);
 540     auto newType = InputType::create(*this, attributeWithoutSynchronization(typeAttr));
 541     m_hasType = true;
 542     if (m_inputType-&gt;formControlType() == newType-&gt;formControlType())
 543         return;
 544 
 545     removeFromRadioButtonGroup();
 546     resignStrongPasswordAppearance();
 547 
 548     bool didStoreValue = m_inputType-&gt;storesValueSeparateFromAttribute();
 549     bool willStoreValue = newType-&gt;storesValueSeparateFromAttribute();
 550     bool neededSuspensionCallback = needsSuspensionCallback();
 551     bool didRespectHeightAndWidth = m_inputType-&gt;shouldRespectHeightAndWidthAttributes();
 552     bool wasSuccessfulSubmitButtonCandidate = m_inputType-&gt;canBeSuccessfulSubmitButton();
 553 
 554     if (didStoreValue &amp;&amp; !willStoreValue &amp;&amp; hasDirtyValue()) {
 555         setAttributeWithoutSynchronization(valueAttr, m_valueIfDirty);
 556         m_valueIfDirty = String();
 557     }
 558 
 559     m_inputType-&gt;destroyShadowSubtree();
 560     m_inputType-&gt;detachFromElement();
 561 
 562     m_inputType = WTFMove(newType);
 563     m_inputType-&gt;createShadowSubtree();
 564     updateInnerTextElementEditability();
 565 
 566     setNeedsWillValidateCheck();
 567 
 568     if (!didStoreValue &amp;&amp; willStoreValue)
 569         m_valueIfDirty = sanitizeValue(attributeWithoutSynchronization(valueAttr));
 570     else
 571         updateValueIfNeeded();
 572 
 573     setFormControlValueMatchesRenderer(false);
 574     m_inputType-&gt;updateInnerTextValue();
 575 
 576     m_wasModifiedByUser = false;
 577 
 578     if (neededSuspensionCallback)
 579         unregisterForSuspensionCallbackIfNeeded();
 580     else
 581         registerForSuspensionCallbackIfNeeded();
 582 
 583     if (didRespectHeightAndWidth != m_inputType-&gt;shouldRespectHeightAndWidthAttributes()) {
 584         ASSERT(elementData());
 585         // FIXME: We don&#39;t have the old attribute values so we pretend that we didn&#39;t have the old values.
 586         if (const Attribute* height = findAttributeByName(heightAttr))
 587             attributeChanged(heightAttr, nullAtom(), height-&gt;value());
 588         if (const Attribute* width = findAttributeByName(widthAttr))
 589             attributeChanged(widthAttr, nullAtom(), width-&gt;value());
 590         if (const Attribute* align = findAttributeByName(alignAttr))
 591             attributeChanged(alignAttr, nullAtom(), align-&gt;value());
 592     }
 593 
 594     if (form() &amp;&amp; wasSuccessfulSubmitButtonCandidate != m_inputType-&gt;canBeSuccessfulSubmitButton())
 595         form()-&gt;resetDefaultButton();
 596 
 597     runPostTypeUpdateTasks();
 598 }
 599 
 600 inline void HTMLInputElement::runPostTypeUpdateTasks()
 601 {
 602     ASSERT(m_inputType);
 603 #if ENABLE(TOUCH_EVENTS)
 604     bool hasTouchEventHandler = m_inputType-&gt;hasTouchEventHandler();
 605     if (hasTouchEventHandler != m_hasTouchEventHandler) {
 606         if (hasTouchEventHandler)
 607             document().didAddTouchEventHandler(*this);
 608         else
 609             document().didRemoveTouchEventHandler(*this);
 610         m_hasTouchEventHandler = hasTouchEventHandler;
 611     }
 612 #endif
 613 
 614     if (renderer())
 615         invalidateStyleAndRenderersForSubtree();
 616 
 617     if (document().focusedElement() == this)
 618         updateFocusAppearance(SelectionRestorationMode::Restore, SelectionRevealMode::Reveal);
 619 
 620     setChangedSinceLastFormControlChangeEvent(false);
 621 
 622     addToRadioButtonGroup();
 623 
 624     updateValidity();
 625 }
 626 
 627 void HTMLInputElement::subtreeHasChanged()
 628 {
 629     m_inputType-&gt;subtreeHasChanged();
 630     // When typing in an input field, childrenChanged is not called, so we need to force the directionality check.
 631     calculateAndAdjustDirectionality();
 632 }
 633 
 634 const AtomString&amp; HTMLInputElement::formControlType() const
 635 {
 636     return m_inputType-&gt;formControlType();
 637 }
 638 
 639 bool HTMLInputElement::shouldSaveAndRestoreFormControlState() const
 640 {
 641     if (!m_inputType-&gt;shouldSaveAndRestoreFormControlState())
 642         return false;
 643     return HTMLTextFormControlElement::shouldSaveAndRestoreFormControlState();
 644 }
 645 
 646 FormControlState HTMLInputElement::saveFormControlState() const
 647 {
 648     return m_inputType-&gt;saveFormControlState();
 649 }
 650 
 651 void HTMLInputElement::restoreFormControlState(const FormControlState&amp; state)
 652 {
 653     m_inputType-&gt;restoreFormControlState(state);
 654     m_stateRestored = true;
 655 }
 656 
 657 bool HTMLInputElement::canStartSelection() const
 658 {
 659     if (!isTextField())
 660         return false;
 661     return HTMLTextFormControlElement::canStartSelection();
 662 }
 663 
 664 bool HTMLInputElement::canHaveSelection() const
 665 {
 666     return isTextField();
 667 }
 668 
 669 void HTMLInputElement::accessKeyAction(bool sendMouseEvents)
 670 {
 671     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 672     protectedInputType-&gt;accessKeyAction(sendMouseEvents);
 673 }
 674 
 675 bool HTMLInputElement::isPresentationAttribute(const QualifiedName&amp; name) const
 676 {
 677     if (name == vspaceAttr || name == hspaceAttr || name == widthAttr || name == heightAttr || (name == borderAttr &amp;&amp; isImageButton()))
 678         return true;
 679     return HTMLTextFormControlElement::isPresentationAttribute(name);
 680 }
 681 
 682 void HTMLInputElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
 683 {
 684     if (name == vspaceAttr) {
 685         addHTMLLengthToStyle(style, CSSPropertyMarginTop, value);
 686         addHTMLLengthToStyle(style, CSSPropertyMarginBottom, value);
 687     } else if (name == hspaceAttr) {
 688         addHTMLLengthToStyle(style, CSSPropertyMarginLeft, value);
 689         addHTMLLengthToStyle(style, CSSPropertyMarginRight, value);
 690     } else if (name == alignAttr) {
 691         if (m_inputType-&gt;shouldRespectAlignAttribute())
 692             applyAlignmentAttributeToStyle(value, style);
 693     } else if (name == widthAttr) {
 694         if (m_inputType-&gt;shouldRespectHeightAndWidthAttributes())
 695             addHTMLLengthToStyle(style, CSSPropertyWidth, value);
 696     } else if (name == heightAttr) {
 697         if (m_inputType-&gt;shouldRespectHeightAndWidthAttributes())
 698             addHTMLLengthToStyle(style, CSSPropertyHeight, value);
 699     } else if (name == borderAttr &amp;&amp; isImageButton())
 700         applyBorderAttributeToStyle(value, style);
 701     else
 702         HTMLTextFormControlElement::collectStyleForPresentationAttribute(name, value, style);
 703 }
 704 
 705 inline void HTMLInputElement::initializeInputType()
 706 {
 707     ASSERT(m_parsingInProgress);
 708     ASSERT(!m_inputType);
 709 
 710     const AtomString&amp; type = attributeWithoutSynchronization(typeAttr);
 711     if (type.isNull()) {
 712         m_inputType = InputType::createText(*this);
 713         ensureUserAgentShadowRoot();
 714         setNeedsWillValidateCheck();
 715         return;
 716     }
 717 
 718     m_hasType = true;
 719     m_inputType = InputType::create(*this, type);
 720     ensureUserAgentShadowRoot();
 721     setNeedsWillValidateCheck();
 722     registerForSuspensionCallbackIfNeeded();
 723     runPostTypeUpdateTasks();
 724 }
 725 
 726 void HTMLInputElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 727 {
 728     ASSERT(m_inputType);
 729     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 730 
 731     if (name == nameAttr) {
 732         removeFromRadioButtonGroup();
 733         m_name = value;
 734         addToRadioButtonGroup();
 735         HTMLTextFormControlElement::parseAttribute(name, value);
 736     } else if (name == autocompleteAttr) {
 737         if (equalLettersIgnoringASCIICase(value, &quot;off&quot;)) {
 738             m_autocomplete = Off;
 739             registerForSuspensionCallbackIfNeeded();
 740         } else {
 741             bool needsToUnregister = m_autocomplete == Off;
 742 
 743             if (value.isEmpty())
 744                 m_autocomplete = Uninitialized;
 745             else
 746                 m_autocomplete = On;
 747 
 748             if (needsToUnregister)
 749                 unregisterForSuspensionCallbackIfNeeded();
 750         }
 751     } else if (name == typeAttr)
 752         updateType();
 753     else if (name == valueAttr) {
 754         // Changes to the value attribute may change whether or not this element has a default value.
 755         // If this field is autocomplete=off that might affect the return value of needsSuspensionCallback.
 756         if (m_autocomplete == Off) {
 757             unregisterForSuspensionCallbackIfNeeded();
 758             registerForSuspensionCallbackIfNeeded();
 759         }
 760         // We only need to setChanged if the form is looking at the default value right now.
 761         if (!hasDirtyValue()) {
 762             updatePlaceholderVisibility();
 763             invalidateStyleForSubtree();
 764         }
 765         setFormControlValueMatchesRenderer(false);
 766         updateValidity();
 767         m_valueAttributeWasUpdatedAfterParsing = !m_parsingInProgress;
 768     } else if (name == checkedAttr) {
 769         if (m_inputType-&gt;isCheckable())
 770             invalidateStyleForSubtree();
 771 
 772         // Another radio button in the same group might be checked by state
 773         // restore. We shouldn&#39;t call setChecked() even if this has the checked
 774         // attribute. So, delay the setChecked() call until
 775         // finishParsingChildren() is called if parsing is in progress.
 776         if ((!m_parsingInProgress || !document().formController().hasFormStateToRestore()) &amp;&amp; !m_dirtyCheckednessFlag) {
 777             setChecked(!value.isNull());
 778             // setChecked() above sets the dirty checkedness flag so we need to reset it.
 779             m_dirtyCheckednessFlag = false;
 780         }
 781     } else if (name == maxlengthAttr)
 782         maxLengthAttributeChanged(value);
 783     else if (name == minlengthAttr)
 784         minLengthAttributeChanged(value);
 785     else if (name == sizeAttr) {
 786         unsigned oldSize = m_size;
 787         m_size = limitToOnlyHTMLNonNegativeNumbersGreaterThanZero(value, defaultSize);
 788         if (m_size != oldSize &amp;&amp; renderer())
 789             renderer()-&gt;setNeedsLayoutAndPrefWidthsRecalc();
 790     } else if (name == resultsAttr)
 791         m_maxResults = !value.isNull() ? std::min(value.toInt(), maxSavedResults) : -1;
 792     else if (name == autosaveAttr || name == incrementalAttr)
 793         invalidateStyleForSubtree();
 794     else if (name == maxAttr || name == minAttr || name == multipleAttr || name == patternAttr || name == precisionAttr || name == stepAttr)
 795         updateValidity();
 796 #if ENABLE(DATALIST_ELEMENT)
 797     else if (name == listAttr) {
 798         m_hasNonEmptyList = !value.isEmpty();
 799         if (m_hasNonEmptyList) {
 800             resetListAttributeTargetObserver();
 801             listAttributeTargetChanged();
 802         }
 803     }
 804 #endif
 805     else
 806         HTMLTextFormControlElement::parseAttribute(name, value);
 807 
 808     m_inputType-&gt;attributeChanged(name);
 809 }
 810 
 811 void HTMLInputElement::disabledStateChanged()
 812 {
 813     HTMLTextFormControlElement::disabledStateChanged();
 814     m_inputType-&gt;disabledStateChanged();
 815 }
 816 
 817 void HTMLInputElement::readOnlyStateChanged()
 818 {
 819     HTMLTextFormControlElement::readOnlyStateChanged();
 820     m_inputType-&gt;readOnlyStateChanged();
 821 }
 822 
 823 void HTMLInputElement::parserDidSetAttributes()
 824 {
 825     ASSERT(m_parsingInProgress);
 826     initializeInputType();
 827 }
 828 
 829 void HTMLInputElement::finishParsingChildren()
 830 {
 831     m_parsingInProgress = false;
 832     ASSERT(m_inputType);
 833     HTMLTextFormControlElement::finishParsingChildren();
 834     if (!m_stateRestored) {
 835         bool checked = hasAttributeWithoutSynchronization(checkedAttr);
 836         if (checked)
 837             setChecked(checked);
 838         m_dirtyCheckednessFlag = false;
 839     }
 840 }
 841 
 842 bool HTMLInputElement::rendererIsNeeded(const RenderStyle&amp; style)
 843 {
 844     return m_inputType-&gt;rendererIsNeeded() &amp;&amp; HTMLTextFormControlElement::rendererIsNeeded(style);
 845 }
 846 
 847 RenderPtr&lt;RenderElement&gt; HTMLInputElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 848 {
 849     return m_inputType-&gt;createInputRenderer(WTFMove(style));
 850 }
 851 
 852 void HTMLInputElement::willAttachRenderers()
 853 {
 854     if (!m_hasType)
 855         updateType();
 856 }
 857 
 858 void HTMLInputElement::didAttachRenderers()
 859 {
 860     HTMLTextFormControlElement::didAttachRenderers();
 861 
 862     m_inputType-&gt;attach();
 863 
 864     if (document().focusedElement() == this) {
 865         document().view()-&gt;queuePostLayoutCallback([protectedThis = makeRef(*this)] {
 866             protectedThis-&gt;updateFocusAppearance(SelectionRestorationMode::Restore, SelectionRevealMode::Reveal);
 867         });
 868     }
 869 }
 870 
 871 void HTMLInputElement::didDetachRenderers()
 872 {
 873     setFormControlValueMatchesRenderer(false);
 874     m_inputType-&gt;detach();
 875 }
 876 
 877 String HTMLInputElement::altText() const
 878 {
 879     // http://www.w3.org/TR/1998/REC-html40-19980424/appendix/notes.html#altgen
 880     // also heavily discussed by Hixie on bugzilla
 881     // note this is intentionally different to HTMLImageElement::altText()
 882     String alt = attributeWithoutSynchronization(altAttr);
 883     // fall back to title attribute
 884     if (alt.isNull())
 885         alt = attributeWithoutSynchronization(titleAttr);
 886     if (alt.isNull())
 887         alt = attributeWithoutSynchronization(valueAttr);
 888     if (alt.isEmpty())
 889         alt = inputElementAltText();
 890     return alt;
 891 }
 892 
 893 bool HTMLInputElement::isSuccessfulSubmitButton() const
 894 {
 895     // HTML spec says that buttons must have names to be considered successful.
 896     // However, other browsers do not impose this constraint. So we do not.
 897     return !isDisabledFormControl() &amp;&amp; m_inputType-&gt;canBeSuccessfulSubmitButton();
 898 }
 899 
 900 bool HTMLInputElement::matchesDefaultPseudoClass() const
 901 {
 902     ASSERT(m_inputType);
 903     if (m_inputType-&gt;canBeSuccessfulSubmitButton())
 904         return !isDisabledFormControl() &amp;&amp; form() &amp;&amp; form()-&gt;defaultButton() == this;
 905     return m_inputType-&gt;isCheckable() &amp;&amp; hasAttributeWithoutSynchronization(checkedAttr);
 906 }
 907 
 908 bool HTMLInputElement::isActivatedSubmit() const
 909 {
 910     return m_isActivatedSubmit;
 911 }
 912 
 913 void HTMLInputElement::setActivatedSubmit(bool flag)
 914 {
 915     m_isActivatedSubmit = flag;
 916 }
 917 
 918 bool HTMLInputElement::appendFormData(DOMFormData&amp; formData, bool multipart)
 919 {
 920     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 921     return m_inputType-&gt;isFormDataAppendable() &amp;&amp; m_inputType-&gt;appendFormData(formData, multipart);
 922 }
 923 
 924 void HTMLInputElement::reset()
 925 {
 926     if (m_inputType-&gt;storesValueSeparateFromAttribute())
 927         setValue(String());
 928 
 929     setAutoFilled(false);
 930     setAutoFilledAndViewable(false);
 931     setShowAutoFillButton(AutoFillButtonType::None);
 932     setChecked(hasAttributeWithoutSynchronization(checkedAttr));
 933     m_dirtyCheckednessFlag = false;
 934 }
 935 
 936 bool HTMLInputElement::isTextField() const
 937 {
 938     return m_inputType-&gt;isTextField();
 939 }
 940 
 941 bool HTMLInputElement::isTextType() const
 942 {
 943     return m_inputType-&gt;isTextType();
 944 }
 945 
 946 void HTMLInputElement::setChecked(bool nowChecked)
 947 {
 948     if (checked() == nowChecked)
 949         return;
 950 
 951     m_dirtyCheckednessFlag = true;
 952     m_isChecked = nowChecked;
 953     invalidateStyleForSubtree();
 954 
 955     if (RadioButtonGroups* buttons = radioButtonGroups())
 956         buttons-&gt;updateCheckedState(*this);
 957     if (renderer() &amp;&amp; renderer()-&gt;style().hasAppearance())
 958         renderer()-&gt;theme().stateChanged(*renderer(), ControlStates::CheckedState);
 959     updateValidity();
 960 
 961     // Ideally we&#39;d do this from the render tree (matching
 962     // RenderTextView), but it&#39;s not possible to do it at the moment
 963     // because of the way the code is structured.
 964     if (renderer()) {
 965         if (AXObjectCache* cache = renderer()-&gt;document().existingAXObjectCache())
 966             cache-&gt;checkedStateChanged(this);
 967     }
 968 
 969     invalidateStyleForSubtree();
 970 }
 971 
 972 void HTMLInputElement::setIndeterminate(bool newValue)
 973 {
 974     if (indeterminate() == newValue)
 975         return;
 976 
 977     m_isIndeterminate = newValue;
 978 
 979     invalidateStyleForSubtree();
 980 
 981     if (renderer() &amp;&amp; renderer()-&gt;style().hasAppearance())
 982         renderer()-&gt;theme().stateChanged(*renderer(), ControlStates::CheckedState);
 983 }
 984 
 985 unsigned HTMLInputElement::size() const
 986 {
 987     return m_size;
 988 }
 989 
 990 bool HTMLInputElement::sizeShouldIncludeDecoration(int&amp; preferredSize) const
 991 {
 992     return m_inputType-&gt;sizeShouldIncludeDecoration(defaultSize, preferredSize);
 993 }
 994 
 995 float HTMLInputElement::decorationWidth() const
 996 {
 997     return m_inputType-&gt;decorationWidth();
 998 }
 999 
1000 void HTMLInputElement::copyNonAttributePropertiesFromElement(const Element&amp; source)
1001 {
1002     auto&amp; sourceElement = downcast&lt;HTMLInputElement&gt;(source);
1003 
1004     m_valueIfDirty = sourceElement.m_valueIfDirty;
1005     m_wasModifiedByUser = false;
1006     setChecked(sourceElement.m_isChecked);
1007     m_dirtyCheckednessFlag = sourceElement.m_dirtyCheckednessFlag;
1008     m_isIndeterminate = sourceElement.m_isIndeterminate;
1009 
1010     HTMLTextFormControlElement::copyNonAttributePropertiesFromElement(source);
1011 
1012     updateValidity();
1013     setFormControlValueMatchesRenderer(false);
1014     m_inputType-&gt;updateInnerTextValue();
1015 }
1016 
1017 String HTMLInputElement::value() const
1018 {
1019     String value;
1020     if (m_inputType-&gt;getTypeSpecificValue(value))
1021         return value;
1022 
1023     value = m_valueIfDirty;
1024     if (!value.isNull())
1025         return value;
1026 
1027     auto&amp; valueString = attributeWithoutSynchronization(valueAttr);
1028     value = sanitizeValue(valueString);
1029     if (!value.isNull())
1030         return value;
1031 
1032     return m_inputType-&gt;fallbackValue();
1033 }
1034 
1035 String HTMLInputElement::valueWithDefault() const
1036 {
1037     String value = this-&gt;value();
1038     if (!value.isNull())
1039         return value;
1040 
1041     return m_inputType-&gt;defaultValue();
1042 }
1043 
1044 void HTMLInputElement::setValueForUser(const String&amp; value)
1045 {
1046     // Call setValue and make it send a change event.
1047     setValue(value, DispatchChangeEvent);
1048 }
1049 
1050 ExceptionOr&lt;void&gt; HTMLInputElement::setValue(const String&amp; value, TextFieldEventBehavior eventBehavior)
1051 {
1052     if (isFileUpload() &amp;&amp; !value.isEmpty())
1053         return Exception { InvalidStateError };
1054 
1055     if (!m_inputType-&gt;canSetValue(value))
1056         return { };
1057 
1058     Ref&lt;HTMLInputElement&gt; protectedThis(*this);
1059     EventQueueScope scope;
1060     String sanitizedValue = sanitizeValue(value);
1061     bool valueChanged = sanitizedValue != this-&gt;value();
1062 
1063     setLastChangeWasNotUserEdit();
1064     setFormControlValueMatchesRenderer(false);
1065     m_inputType-&gt;setValue(sanitizedValue, valueChanged, eventBehavior);
1066 
1067     bool wasModifiedProgrammatically = eventBehavior == DispatchNoEvent;
1068     if (wasModifiedProgrammatically)
1069         resignStrongPasswordAppearance();
1070     return { };
1071 }
1072 
1073 void HTMLInputElement::setValueInternal(const String&amp; sanitizedValue, TextFieldEventBehavior eventBehavior)
1074 {
1075     m_valueIfDirty = sanitizedValue;
1076     m_wasModifiedByUser = eventBehavior != DispatchNoEvent;
1077     updateValidity();
1078 }
1079 
1080 double HTMLInputElement::valueAsDate() const
1081 {
1082     return m_inputType-&gt;valueAsDate();
1083 }
1084 
1085 ExceptionOr&lt;void&gt; HTMLInputElement::setValueAsDate(double value)
1086 {
1087     return m_inputType-&gt;setValueAsDate(value);
1088 }
1089 
1090 double HTMLInputElement::valueAsNumber() const
1091 {
1092     return m_inputType-&gt;valueAsDouble();
1093 }
1094 
1095 ExceptionOr&lt;void&gt; HTMLInputElement::setValueAsNumber(double newValue, TextFieldEventBehavior eventBehavior)
1096 {
1097     if (!std::isfinite(newValue))
1098         return Exception { NotSupportedError };
1099     return m_inputType-&gt;setValueAsDouble(newValue, eventBehavior);
1100 }
1101 
1102 void HTMLInputElement::setValueFromRenderer(const String&amp; value)
1103 {
1104     // File upload controls will never use this.
1105     ASSERT(!isFileUpload());
1106 
1107     // Renderer and our event handler are responsible for sanitizing values.
1108     // Input types that support the selection API do *not* sanitize their
1109     // user input in order to retain parity between what&#39;s in the model and
1110     // what&#39;s on the screen.
1111     ASSERT(m_inputType-&gt;supportsSelectionAPI() || value == sanitizeValue(value) || sanitizeValue(value).isEmpty());
1112 
1113     // Workaround for bug where trailing \n is included in the result of textContent.
1114     // The assert macro above may also be simplified by removing the expression
1115     // that calls isEmpty.
1116     // http://bugs.webkit.org/show_bug.cgi?id=9661
1117     m_valueIfDirty = value == &quot;\n&quot; ? emptyString() : value;
1118 
1119     setFormControlValueMatchesRenderer(true);
1120     m_wasModifiedByUser = true;
1121 
1122     // Input event is fired by the Node::defaultEventHandler for editable controls.
1123     if (!isTextField())
1124         dispatchInputEvent();
1125 
1126     updateValidity();
1127 
1128     // Clear auto fill flag (and yellow background) on user edit.
1129     setAutoFilled(false);
1130 }
1131 
1132 void HTMLInputElement::willDispatchEvent(Event&amp; event, InputElementClickState&amp; state)
1133 {
1134     if (event.type() == eventNames().textInputEvent &amp;&amp; m_inputType-&gt;shouldSubmitImplicitly(event))
1135         event.stopPropagation();
1136     if (event.type() == eventNames().clickEvent &amp;&amp; is&lt;MouseEvent&gt;(event) &amp;&amp; downcast&lt;MouseEvent&gt;(event).button() == LeftButton) {
1137         m_inputType-&gt;willDispatchClick(state);
1138         state.stateful = true;
1139     }
1140 }
1141 
1142 void HTMLInputElement::didDispatchClickEvent(Event&amp; event, const InputElementClickState&amp; state)
1143 {
1144     m_inputType-&gt;didDispatchClick(event, state);
1145 }
1146 
1147 void HTMLInputElement::didBlur()
1148 {
1149     m_inputType-&gt;elementDidBlur();
1150 }
1151 
1152 void HTMLInputElement::defaultEventHandler(Event&amp; event)
1153 {
1154     if (is&lt;MouseEvent&gt;(event) &amp;&amp; event.type() == eventNames().clickEvent &amp;&amp; downcast&lt;MouseEvent&gt;(event).button() == LeftButton) {
1155         m_inputType-&gt;handleClickEvent(downcast&lt;MouseEvent&gt;(event));
1156         if (event.defaultHandled())
1157             return;
1158     }
1159 
1160 #if ENABLE(TOUCH_EVENTS)
1161     if (is&lt;TouchEvent&gt;(event)) {
1162         m_inputType-&gt;handleTouchEvent(downcast&lt;TouchEvent&gt;(event));
1163         if (event.defaultHandled())
1164             return;
1165     }
1166 #endif
1167 
1168     if (is&lt;KeyboardEvent&gt;(event) &amp;&amp; event.type() == eventNames().keydownEvent) {
1169         auto shouldCallBaseEventHandler = m_inputType-&gt;handleKeydownEvent(downcast&lt;KeyboardEvent&gt;(event));
1170         if (event.defaultHandled() || shouldCallBaseEventHandler == InputType::ShouldCallBaseEventHandler::No)
1171             return;
1172     }
1173 
1174     // Call the base event handler before any of our own event handling for almost all events in text fields.
1175     // Makes editing keyboard handling take precedence over the keydown and keypress handling in this function.
1176     bool callBaseClassEarly = isTextField() &amp;&amp; (event.type() == eventNames().keydownEvent || event.type() == eventNames().keypressEvent);
1177     if (callBaseClassEarly) {
1178         HTMLTextFormControlElement::defaultEventHandler(event);
1179         if (event.defaultHandled())
1180             return;
1181     }
1182 
1183     // DOMActivate events cause the input to be &quot;activated&quot; - in the case of image and submit inputs, this means
1184     // actually submitting the form. For reset inputs, the form is reset. These events are sent when the user clicks
1185     // on the element, or presses enter while it is the active element. JavaScript code wishing to activate the element
1186     // must dispatch a DOMActivate event - a click event will not do the job.
1187     if (event.type() == eventNames().DOMActivateEvent) {
1188         m_inputType-&gt;handleDOMActivateEvent(event);
1189         if (event.defaultHandled())
1190             return;
1191     }
1192 
1193     // Use key press event here since sending simulated mouse events
1194     // on key down blocks the proper sending of the key press event.
1195     if (is&lt;KeyboardEvent&gt;(event)) {
1196         KeyboardEvent&amp; keyboardEvent = downcast&lt;KeyboardEvent&gt;(event);
1197         if (keyboardEvent.type() == eventNames().keypressEvent) {
1198             m_inputType-&gt;handleKeypressEvent(keyboardEvent);
1199             if (keyboardEvent.defaultHandled())
1200                 return;
1201         } else if (keyboardEvent.type() == eventNames().keyupEvent) {
1202             m_inputType-&gt;handleKeyupEvent(keyboardEvent);
1203             if (keyboardEvent.defaultHandled())
1204                 return;
1205         }
1206     }
1207 
1208     if (m_inputType-&gt;shouldSubmitImplicitly(event)) {
1209         if (isSearchField()) {
1210             addSearchResult();
1211             onSearch();
1212         }
1213         // Form submission finishes editing, just as loss of focus does.
1214         // If there was a change, send the event now.
1215         if (wasChangedSinceLastFormControlChangeEvent())
1216             dispatchFormControlChangeEvent();
1217 
1218         // Form may never have been present, or may have been destroyed by code responding to the change event.
1219         if (auto formElement = makeRefPtr(form()))
1220             formElement-&gt;submitImplicitly(event, canTriggerImplicitSubmission());
1221 
1222         event.setDefaultHandled();
1223         return;
1224     }
1225 
1226     if (is&lt;BeforeTextInsertedEvent&gt;(event))
1227         m_inputType-&gt;handleBeforeTextInsertedEvent(downcast&lt;BeforeTextInsertedEvent&gt;(event));
1228 
1229     if (is&lt;MouseEvent&gt;(event) &amp;&amp; event.type() == eventNames().mousedownEvent) {
1230         m_inputType-&gt;handleMouseDownEvent(downcast&lt;MouseEvent&gt;(event));
1231         if (event.defaultHandled())
1232             return;
1233     }
1234 
1235     m_inputType-&gt;forwardEvent(event);
1236 
1237     if (!callBaseClassEarly &amp;&amp; !event.defaultHandled())
1238         HTMLTextFormControlElement::defaultEventHandler(event);
1239 }
1240 
1241 bool HTMLInputElement::willRespondToMouseClickEvents()
1242 {
1243     if (!isDisabledFormControl())
1244         return true;
1245 
1246     return HTMLTextFormControlElement::willRespondToMouseClickEvents();
1247 }
1248 
1249 bool HTMLInputElement::isURLAttribute(const Attribute&amp; attribute) const
1250 {
1251     return attribute.name() == srcAttr || attribute.name() == formactionAttr || HTMLTextFormControlElement::isURLAttribute(attribute);
1252 }
1253 
1254 String HTMLInputElement::defaultValue() const
1255 {
1256     return attributeWithoutSynchronization(valueAttr);
1257 }
1258 
1259 void HTMLInputElement::setDefaultValue(const String &amp;value)
1260 {
1261     setAttributeWithoutSynchronization(valueAttr, value);
1262 }
1263 
1264 static inline bool isRFC2616TokenCharacter(UChar ch)
1265 {
1266     return isASCII(ch) &amp;&amp; ch &gt; &#39; &#39; &amp;&amp; ch != &#39;&quot;&#39; &amp;&amp; ch != &#39;(&#39; &amp;&amp; ch != &#39;)&#39; &amp;&amp; ch != &#39;,&#39; &amp;&amp; ch != &#39;/&#39; &amp;&amp; (ch &lt; &#39;:&#39; || ch &gt; &#39;@&#39;) &amp;&amp; (ch &lt; &#39;[&#39; || ch &gt; &#39;]&#39;) &amp;&amp; ch != &#39;{&#39; &amp;&amp; ch != &#39;}&#39; &amp;&amp; ch != 0x7f;
1267 }
1268 
1269 static bool isValidMIMEType(const String&amp; type)
1270 {
1271     size_t slashPosition = type.find(&#39;/&#39;);
1272     if (slashPosition == notFound || !slashPosition || slashPosition == type.length() - 1)
1273         return false;
1274     for (size_t i = 0; i &lt; type.length(); ++i) {
1275         if (!isRFC2616TokenCharacter(type[i]) &amp;&amp; i != slashPosition)
1276             return false;
1277     }
1278     return true;
1279 }
1280 
1281 static bool isValidFileExtension(const String&amp; type)
1282 {
1283     if (type.length() &lt; 2)
1284         return false;
1285     return type[0] == &#39;.&#39;;
1286 }
1287 
1288 static Vector&lt;String&gt; parseAcceptAttribute(const String&amp; acceptString, bool (*predicate)(const String&amp;))
1289 {
1290     Vector&lt;String&gt; types;
1291     if (acceptString.isEmpty())
1292         return types;
1293 
1294     for (auto&amp; splitType : acceptString.split(&#39;,&#39;)) {
1295         String trimmedType = stripLeadingAndTrailingHTMLSpaces(splitType);
1296         if (trimmedType.isEmpty())
1297             continue;
1298         if (!predicate(trimmedType))
1299             continue;
1300         types.append(trimmedType.convertToASCIILowercase());
1301     }
1302 
1303     return types;
1304 }
1305 
1306 Vector&lt;String&gt; HTMLInputElement::acceptMIMETypes()
1307 {
1308     return parseAcceptAttribute(attributeWithoutSynchronization(acceptAttr), isValidMIMEType);
1309 }
1310 
1311 Vector&lt;String&gt; HTMLInputElement::acceptFileExtensions()
1312 {
1313     return parseAcceptAttribute(attributeWithoutSynchronization(acceptAttr), isValidFileExtension);
1314 }
1315 
1316 String HTMLInputElement::accept() const
1317 {
1318     return attributeWithoutSynchronization(acceptAttr);
1319 }
1320 
1321 String HTMLInputElement::alt() const
1322 {
1323     return attributeWithoutSynchronization(altAttr);
1324 }
1325 
1326 unsigned HTMLInputElement::effectiveMaxLength() const
1327 {
1328     // The number -1 represents no maximum at all; conveniently it becomes a super-large value when converted to unsigned.
1329     return std::min&lt;unsigned&gt;(maxLength(), maxEffectiveLength);
1330 }
1331 
1332 bool HTMLInputElement::multiple() const
1333 {
1334     return hasAttributeWithoutSynchronization(multipleAttr);
1335 }
1336 
1337 ExceptionOr&lt;void&gt; HTMLInputElement::setSize(unsigned size)
1338 {
1339     if (!size)
1340         return Exception { IndexSizeError };
1341     setUnsignedIntegralAttribute(sizeAttr, limitToOnlyHTMLNonNegativeNumbersGreaterThanZero(size, defaultSize));
1342     return { };
1343 }
1344 
1345 URL HTMLInputElement::src() const
1346 {
1347     return document().completeURL(attributeWithoutSynchronization(srcAttr));
1348 }
1349 
1350 void HTMLInputElement::setAutoFilled(bool autoFilled)
1351 {
1352     if (autoFilled == m_isAutoFilled)
1353         return;
1354 
1355     m_isAutoFilled = autoFilled;
1356     invalidateStyleForSubtree();
1357 }
1358 
1359 void HTMLInputElement::setAutoFilledAndViewable(bool autoFilledAndViewable)
1360 {
1361     if (autoFilledAndViewable == m_isAutoFilledAndViewable)
1362         return;
1363 
1364     m_isAutoFilledAndViewable = autoFilledAndViewable;
1365     invalidateStyleForSubtree();
1366 }
1367 
1368 void HTMLInputElement::setShowAutoFillButton(AutoFillButtonType autoFillButtonType)
1369 {
1370     if (static_cast&lt;uint8_t&gt;(autoFillButtonType) == m_autoFillButtonType)
1371         return;
1372 
1373     m_lastAutoFillButtonType = m_autoFillButtonType;
1374     m_autoFillButtonType = static_cast&lt;uint8_t&gt;(autoFillButtonType);
1375     m_inputType-&gt;updateAutoFillButton();
1376     updateInnerTextElementEditability();
1377     invalidateStyleForSubtree();
1378 }
1379 
1380 FileList* HTMLInputElement::files()
1381 {
1382     return m_inputType-&gt;files();
1383 }
1384 
1385 void HTMLInputElement::setFiles(RefPtr&lt;FileList&gt;&amp;&amp; files)
1386 {
1387     m_inputType-&gt;setFiles(WTFMove(files));
1388 }
1389 
1390 #if ENABLE(DRAG_SUPPORT)
1391 bool HTMLInputElement::receiveDroppedFiles(const DragData&amp; dragData)
1392 {
1393     return m_inputType-&gt;receiveDroppedFiles(dragData);
1394 }
1395 #endif
1396 
1397 Icon* HTMLInputElement::icon() const
1398 {
1399     return m_inputType-&gt;icon();
1400 }
1401 
1402 String HTMLInputElement::displayString() const
1403 {
1404     return m_inputType-&gt;displayString();
1405 }
1406 
1407 bool HTMLInputElement::canReceiveDroppedFiles() const
1408 {
1409     return m_canReceiveDroppedFiles;
1410 }
1411 
1412 void HTMLInputElement::setCanReceiveDroppedFiles(bool canReceiveDroppedFiles)
1413 {
1414     if (m_canReceiveDroppedFiles == canReceiveDroppedFiles)
1415         return;
1416     m_canReceiveDroppedFiles = canReceiveDroppedFiles;
1417     if (renderer())
1418         renderer()-&gt;updateFromElement();
1419 }
1420 
1421 String HTMLInputElement::visibleValue() const
1422 {
1423     return m_inputType-&gt;visibleValue();
1424 }
1425 
1426 String HTMLInputElement::sanitizeValue(const String&amp; proposedValue) const
1427 {
1428     if (proposedValue.isNull())
1429         return proposedValue;
1430     return m_inputType-&gt;sanitizeValue(proposedValue);
1431 }
1432 
1433 String HTMLInputElement::localizeValue(const String&amp; proposedValue) const
1434 {
1435     if (proposedValue.isNull())
1436         return proposedValue;
1437     return m_inputType-&gt;localizeValue(proposedValue);
1438 }
1439 
1440 bool HTMLInputElement::isInRange() const
1441 {
1442     return willValidate() &amp;&amp; m_inputType-&gt;isInRange(value());
1443 }
1444 
1445 bool HTMLInputElement::isOutOfRange() const
1446 {
1447     return willValidate() &amp;&amp; m_inputType-&gt;isOutOfRange(value());
1448 }
1449 
1450 bool HTMLInputElement::needsSuspensionCallback()
1451 {
1452     if (m_inputType-&gt;shouldResetOnDocumentActivation())
1453         return true;
1454 
1455     // Sensitive input elements are marked with autocomplete=off, and we want to wipe them out
1456     // when going back; returning true here arranges for us to call reset at the time
1457     // the page is restored. Non-empty textual default values indicate that the field
1458     // is not really sensitive -- there&#39;s no default value for an account number --
1459     // and we would see unexpected results if we reset to something other than blank.
1460     bool isSensitive = m_autocomplete == Off &amp;&amp; !(m_inputType-&gt;isTextType() &amp;&amp; !defaultValue().isEmpty());
1461 
1462     return isSensitive;
1463 }
1464 
1465 void HTMLInputElement::registerForSuspensionCallbackIfNeeded()
1466 {
1467     if (needsSuspensionCallback())
1468         document().registerForDocumentSuspensionCallbacks(*this);
1469 }
1470 
1471 void HTMLInputElement::unregisterForSuspensionCallbackIfNeeded()
1472 {
1473     if (!needsSuspensionCallback())
1474         document().unregisterForDocumentSuspensionCallbacks(*this);
1475 }
1476 
1477 bool HTMLInputElement::isRequiredFormControl() const
1478 {
1479     return m_inputType-&gt;supportsRequired() &amp;&amp; isRequired();
1480 }
1481 
1482 bool HTMLInputElement::matchesReadWritePseudoClass() const
1483 {
1484     return m_inputType-&gt;supportsReadOnly() &amp;&amp; !isDisabledOrReadOnly();
1485 }
1486 
1487 void HTMLInputElement::addSearchResult()
1488 {
1489     m_inputType-&gt;addSearchResult();
1490 }
1491 
1492 void HTMLInputElement::onSearch()
1493 {
1494     // The type of the input element could have changed during event handling. If we are no longer
1495     // a search field, don&#39;t try to do search things.
1496     if (!isSearchField())
1497         return;
1498 
1499     if (m_inputType)
1500         downcast&lt;SearchInputType&gt;(*m_inputType.get()).stopSearchEventTimer();
1501     dispatchEvent(Event::create(eventNames().searchEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
1502 }
1503 
1504 void HTMLInputElement::resumeFromDocumentSuspension()
1505 {
1506     ASSERT(needsSuspensionCallback());
1507 
1508 #if ENABLE(INPUT_TYPE_COLOR)
1509     // &lt;input type=color&gt; uses prepareForDocumentSuspension to detach the color picker UI,
1510     // so it should not be reset when being loaded from page cache.
1511     if (isColorControl())
1512         return;
1513 #endif // ENABLE(INPUT_TYPE_COLOR)
1514     document().postTask([inputElement = makeRef(*this)] (ScriptExecutionContext&amp;) {
1515         inputElement-&gt;reset();
1516     });
1517 }
1518 
1519 #if ENABLE(INPUT_TYPE_COLOR)
1520 void HTMLInputElement::prepareForDocumentSuspension()
1521 {
1522     if (!isColorControl())
1523         return;
1524     m_inputType-&gt;detach();
1525 }
1526 #endif // ENABLE(INPUT_TYPE_COLOR)
1527 
1528 
1529 void HTMLInputElement::willChangeForm()
1530 {
1531     removeFromRadioButtonGroup();
1532     HTMLTextFormControlElement::willChangeForm();
1533 }
1534 
1535 void HTMLInputElement::didChangeForm()
1536 {
1537     HTMLTextFormControlElement::didChangeForm();
1538     addToRadioButtonGroup();
1539 }
1540 
1541 Node::InsertedIntoAncestorResult HTMLInputElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
1542 {
1543     HTMLTextFormControlElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
1544 #if ENABLE(DATALIST_ELEMENT)
1545     resetListAttributeTargetObserver();
1546 #endif
1547     return InsertedIntoAncestorResult::NeedsPostInsertionCallback;
1548 }
1549 
1550 void HTMLInputElement::didFinishInsertingNode()
1551 {
1552     HTMLTextFormControlElement::didFinishInsertingNode();
1553     if (isConnected() &amp;&amp; !form())
1554         addToRadioButtonGroup();
1555 }
1556 
1557 void HTMLInputElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
1558 {
1559     if (removalType.disconnectedFromDocument &amp;&amp; !form())
1560         removeFromRadioButtonGroup();
1561     HTMLTextFormControlElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
1562     ASSERT(!isConnected());
1563 #if ENABLE(DATALIST_ELEMENT)
1564     resetListAttributeTargetObserver();
1565 #endif
1566 }
1567 
1568 void HTMLInputElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
1569 {
1570     if (imageLoader())
1571         imageLoader()-&gt;elementDidMoveToNewDocument();
1572 
1573     // Always unregister for cache callbacks when leaving a document, even if we would otherwise like to be registered
1574     if (needsSuspensionCallback()) {
1575         oldDocument.unregisterForDocumentSuspensionCallbacks(*this);
1576         newDocument.registerForDocumentSuspensionCallbacks(*this);
1577     }
1578 
1579     // We call this even for radio buttons in forms; it&#39;s harmless because the
1580     // removeButton function is written to be safe for buttons not in any group.
1581     if (isRadioButton())
1582         oldDocument.formController().radioButtonGroups().removeButton(*this);
1583 
1584 #if ENABLE(TOUCH_EVENTS)
1585     if (m_hasTouchEventHandler) {
1586         oldDocument.didRemoveEventTargetNode(*this);
1587         newDocument.didAddTouchEventHandler(*this);
1588     }
1589 #endif
1590 
1591     HTMLTextFormControlElement::didMoveToNewDocument(oldDocument, newDocument);
1592 }
1593 
1594 void HTMLInputElement::addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp; urls) const
1595 {
1596     HTMLTextFormControlElement::addSubresourceAttributeURLs(urls);
1597 
1598     addSubresourceURL(urls, src());
1599 }
1600 
1601 bool HTMLInputElement::computeWillValidate() const
1602 {
1603     return m_inputType-&gt;supportsValidation() &amp;&amp; HTMLTextFormControlElement::computeWillValidate();
1604 }
1605 
1606 void HTMLInputElement::requiredStateChanged()
1607 {
1608     HTMLTextFormControlElement::requiredStateChanged();
1609     if (auto* buttons = radioButtonGroups())
1610         buttons-&gt;requiredStateChanged(*this);
1611     m_inputType-&gt;requiredStateChanged();
1612 }
1613 
1614 Color HTMLInputElement::valueAsColor() const
1615 {
1616     return m_inputType-&gt;valueAsColor();
1617 }
1618 
1619 void HTMLInputElement::selectColor(StringView color)
1620 {
1621     m_inputType-&gt;selectColor(color);
1622 }
1623 
1624 Vector&lt;Color&gt; HTMLInputElement::suggestedColors() const
1625 {
1626     return m_inputType-&gt;suggestedColors();
1627 }
1628 
1629 #if ENABLE(DATALIST_ELEMENT)
1630 
1631 RefPtr&lt;HTMLElement&gt; HTMLInputElement::list() const
1632 {
1633     return dataList();
1634 }
1635 
1636 RefPtr&lt;HTMLDataListElement&gt; HTMLInputElement::dataList() const
1637 {
1638     if (!m_hasNonEmptyList)
1639         return nullptr;
1640 
1641     if (!m_inputType-&gt;shouldRespectListAttribute())
1642         return nullptr;
1643 
1644     RefPtr&lt;Element&gt; element = treeScope().getElementById(attributeWithoutSynchronization(listAttr));
1645     if (!is&lt;HTMLDataListElement&gt;(element))
1646         return nullptr;
1647 
1648     return downcast&lt;HTMLDataListElement&gt;(element.get());
1649 }
1650 
1651 void HTMLInputElement::resetListAttributeTargetObserver()
1652 {
1653     if (isConnected())
1654         m_listAttributeTargetObserver = makeUnique&lt;ListAttributeTargetObserver&gt;(attributeWithoutSynchronization(listAttr), this);
1655     else
1656         m_listAttributeTargetObserver = nullptr;
1657 }
1658 
1659 void HTMLInputElement::listAttributeTargetChanged()
1660 {
1661     m_inputType-&gt;listAttributeTargetChanged();
1662 }
1663 
1664 #endif // ENABLE(DATALIST_ELEMENT)
1665 
1666 bool HTMLInputElement::isPresentingAttachedView() const
1667 {
1668     return m_inputType-&gt;isPresentingAttachedView();
1669 }
1670 
1671 bool HTMLInputElement::isSteppable() const
1672 {
1673     return m_inputType-&gt;isSteppable();
1674 }
1675 
1676 #if PLATFORM(IOS_FAMILY)
1677 DateComponents::Type HTMLInputElement::dateType() const
1678 {
1679     return m_inputType-&gt;dateType();
1680 }
1681 #endif
1682 
1683 bool HTMLInputElement::isTextButton() const
1684 {
1685     return m_inputType-&gt;isTextButton();
1686 }
1687 
1688 bool HTMLInputElement::isRadioButton() const
1689 {
1690     return m_inputType-&gt;isRadioButton();
1691 }
1692 
1693 bool HTMLInputElement::isSearchField() const
1694 {
1695     return m_inputType-&gt;isSearchField();
1696 }
1697 
1698 bool HTMLInputElement::isInputTypeHidden() const
1699 {
1700     return m_inputType-&gt;isHiddenType();
1701 }
1702 
1703 bool HTMLInputElement::isPasswordField() const
1704 {
1705     return m_inputType-&gt;isPasswordField();
1706 }
1707 
1708 bool HTMLInputElement::isCheckbox() const
1709 {
1710     return m_inputType-&gt;isCheckbox();
1711 }
1712 
1713 bool HTMLInputElement::isRangeControl() const
1714 {
1715     return m_inputType-&gt;isRangeControl();
1716 }
1717 
1718 #if ENABLE(INPUT_TYPE_COLOR)
1719 bool HTMLInputElement::isColorControl() const
1720 {
1721     return m_inputType-&gt;isColorControl();
1722 }
1723 #endif
1724 
1725 bool HTMLInputElement::isText() const
1726 {
1727     return m_inputType-&gt;isTextType();
1728 }
1729 
1730 bool HTMLInputElement::isEmailField() const
1731 {
1732     return m_inputType-&gt;isEmailField();
1733 }
1734 
1735 bool HTMLInputElement::isFileUpload() const
1736 {
1737     return m_inputType-&gt;isFileUpload();
1738 }
1739 
1740 bool HTMLInputElement::isImageButton() const
1741 {
1742     return m_inputType-&gt;isImageButton();
1743 }
1744 
1745 bool HTMLInputElement::isNumberField() const
1746 {
1747     return m_inputType-&gt;isNumberField();
1748 }
1749 
1750 bool HTMLInputElement::isSubmitButton() const
1751 {
1752     return m_inputType-&gt;isSubmitButton();
1753 }
1754 
1755 bool HTMLInputElement::isTelephoneField() const
1756 {
1757     return m_inputType-&gt;isTelephoneField();
1758 }
1759 
1760 bool HTMLInputElement::isURLField() const
1761 {
1762     return m_inputType-&gt;isURLField();
1763 }
1764 
1765 bool HTMLInputElement::isDateField() const
1766 {
1767     return m_inputType-&gt;isDateField();
1768 }
1769 
1770 bool HTMLInputElement::isDateTimeField() const
1771 {
1772     return m_inputType-&gt;isDateTimeField();
1773 }
1774 
1775 bool HTMLInputElement::isDateTimeLocalField() const
1776 {
1777     return m_inputType-&gt;isDateTimeLocalField();
1778 }
1779 
1780 bool HTMLInputElement::isMonthField() const
1781 {
1782     return m_inputType-&gt;isMonthField();
1783 }
1784 
1785 bool HTMLInputElement::isTimeField() const
1786 {
1787     return m_inputType-&gt;isTimeField();
1788 }
1789 
1790 bool HTMLInputElement::isWeekField() const
1791 {
1792     return m_inputType-&gt;isWeekField();
1793 }
1794 
1795 bool HTMLInputElement::isEnumeratable() const
1796 {
1797     return m_inputType-&gt;isEnumeratable();
1798 }
1799 
1800 bool HTMLInputElement::supportLabels() const
1801 {
1802     return m_inputType-&gt;supportLabels();
1803 }
1804 
1805 bool HTMLInputElement::shouldAppearChecked() const
1806 {
1807     return checked() &amp;&amp; m_inputType-&gt;isCheckable();
1808 }
1809 
1810 bool HTMLInputElement::supportsPlaceholder() const
1811 {
1812     return m_inputType-&gt;supportsPlaceholder();
1813 }
1814 
1815 void HTMLInputElement::updatePlaceholderText()
1816 {
1817     return m_inputType-&gt;updatePlaceholderText();
1818 }
1819 
1820 bool HTMLInputElement::isEmptyValue() const
1821 {
1822     return m_inputType-&gt;isEmptyValue();
1823 }
1824 
1825 void HTMLInputElement::maxLengthAttributeChanged(const AtomString&amp; newValue)
1826 {
1827     unsigned oldEffectiveMaxLength = effectiveMaxLength();
1828     internalSetMaxLength(parseHTMLNonNegativeInteger(newValue).value_or(-1));
1829     if (oldEffectiveMaxLength != effectiveMaxLength())
1830         updateValueIfNeeded();
1831 
1832     // FIXME: Do we really need to do this if the effective maxLength has not changed?
1833     invalidateStyleForSubtree();
1834     updateValidity();
1835 }
1836 
1837 void HTMLInputElement::minLengthAttributeChanged(const AtomString&amp; newValue)
1838 {
1839     int oldMinLength = minLength();
1840     internalSetMinLength(parseHTMLNonNegativeInteger(newValue).value_or(-1));
1841     if (oldMinLength != minLength())
1842         updateValueIfNeeded();
1843 
1844     // FIXME: Do we really need to do this if the effective minLength has not changed?
1845     invalidateStyleForSubtree();
1846     updateValidity();
1847 }
1848 
1849 void HTMLInputElement::updateValueIfNeeded()
1850 {
1851     String newValue = sanitizeValue(m_valueIfDirty);
1852     ASSERT(!m_valueIfDirty.isNull() || newValue.isNull());
1853     if (newValue != m_valueIfDirty)
1854         setValue(newValue);
1855 }
1856 
1857 String HTMLInputElement::defaultToolTip() const
1858 {
1859     return m_inputType-&gt;defaultToolTip();
1860 }
1861 
1862 bool HTMLInputElement::matchesIndeterminatePseudoClass() const
1863 {
1864     // For input elements, matchesIndeterminatePseudoClass()
1865     // is not equivalent to shouldAppearIndeterminate() because of radio button.
1866     //
1867     // A group of radio button without any checked button is indeterminate
1868     // for the :indeterminate selector. On the other hand, RenderTheme
1869     // currently only supports single element being indeterminate.
1870     // Because of this, radio is indetermindate for CSS but not for render theme.
1871     return m_inputType-&gt;matchesIndeterminatePseudoClass();
1872 }
1873 
1874 bool HTMLInputElement::shouldAppearIndeterminate() const
1875 {
1876     return m_inputType-&gt;shouldAppearIndeterminate();
1877 }
1878 
1879 #if ENABLE(MEDIA_CAPTURE)
1880 MediaCaptureType HTMLInputElement::mediaCaptureType() const
1881 {
1882     if (!isFileUpload())
1883         return MediaCaptureTypeNone;
1884 
1885     auto&amp; captureAttribute = attributeWithoutSynchronization(captureAttr);
1886     if (captureAttribute.isNull())
1887         return MediaCaptureTypeNone;
1888 
1889     if (equalLettersIgnoringASCIICase(captureAttribute, &quot;user&quot;))
1890         return MediaCaptureTypeUser;
1891 
1892     return MediaCaptureTypeEnvironment;
1893 }
1894 #endif
1895 
1896 bool HTMLInputElement::isInRequiredRadioButtonGroup()
1897 {
1898     ASSERT(isRadioButton());
1899     if (RadioButtonGroups* buttons = radioButtonGroups())
1900         return buttons-&gt;isInRequiredGroup(*this);
1901     return false;
1902 }
1903 
1904 Vector&lt;HTMLInputElement*&gt; HTMLInputElement::radioButtonGroup() const
1905 {
1906     RadioButtonGroups* buttons = radioButtonGroups();
1907     if (!buttons)
1908         return { };
1909     return buttons-&gt;groupMembers(*this);
1910 }
1911 
1912 HTMLInputElement* HTMLInputElement::checkedRadioButtonForGroup() const
1913 {
1914     if (RadioButtonGroups* buttons = radioButtonGroups())
1915         return buttons-&gt;checkedButtonForGroup(name());
1916     return nullptr;
1917 }
1918 
1919 RadioButtonGroups* HTMLInputElement::radioButtonGroups() const
1920 {
1921     if (!isRadioButton())
1922         return nullptr;
1923     if (auto* formElement = form())
1924         return &amp;formElement-&gt;radioButtonGroups();
1925     if (isConnected())
1926         return &amp;document().formController().radioButtonGroups();
1927     return nullptr;
1928 }
1929 
1930 inline void HTMLInputElement::addToRadioButtonGroup()
1931 {
1932     if (auto* buttons = radioButtonGroups())
1933         buttons-&gt;addButton(*this);
1934 }
1935 
1936 inline void HTMLInputElement::removeFromRadioButtonGroup()
1937 {
1938     if (auto* buttons = radioButtonGroups())
1939         buttons-&gt;removeButton(*this);
1940 }
1941 
1942 unsigned HTMLInputElement::height() const
1943 {
1944     return m_inputType-&gt;height();
1945 }
1946 
1947 unsigned HTMLInputElement::width() const
1948 {
1949     return m_inputType-&gt;width();
1950 }
1951 
1952 void HTMLInputElement::setHeight(unsigned height)
1953 {
1954     setUnsignedIntegralAttribute(heightAttr, height);
1955 }
1956 
1957 void HTMLInputElement::setWidth(unsigned width)
1958 {
1959     setUnsignedIntegralAttribute(widthAttr, width);
1960 }
1961 
1962 #if ENABLE(DATALIST_ELEMENT)
1963 ListAttributeTargetObserver::ListAttributeTargetObserver(const AtomString&amp; id, HTMLInputElement* element)
1964     : IdTargetObserver(element-&gt;treeScope().idTargetObserverRegistry(), id)
1965     , m_element(element)
1966 {
1967 }
1968 
1969 void ListAttributeTargetObserver::idTargetChanged()
1970 {
1971     m_element-&gt;listAttributeTargetChanged();
1972 }
1973 #endif
1974 
1975 ExceptionOr&lt;void&gt; HTMLInputElement::setRangeText(const String&amp; replacement)
1976 {
1977     if (!m_inputType-&gt;supportsSelectionAPI())
1978         return Exception { InvalidStateError };
1979 
1980     return HTMLTextFormControlElement::setRangeText(replacement);
1981 }
1982 
1983 ExceptionOr&lt;void&gt; HTMLInputElement::setRangeText(const String&amp; replacement, unsigned start, unsigned end, const String&amp; selectionMode)
1984 {
1985     if (!m_inputType-&gt;supportsSelectionAPI())
1986         return Exception { InvalidStateError };
1987 
1988     return HTMLTextFormControlElement::setRangeText(replacement, start, end, selectionMode);
1989 }
1990 
1991 bool HTMLInputElement::shouldTruncateText(const RenderStyle&amp; style) const
1992 {
1993     if (!isTextField())
1994         return false;
1995     return document().focusedElement() != this &amp;&amp; style.textOverflow() == TextOverflow::Ellipsis;
1996 }
1997 
1998 ExceptionOr&lt;int&gt; HTMLInputElement::selectionStartForBindings() const
1999 {
2000     if (!canHaveSelection())
2001         return Exception { TypeError };
2002 
2003     return selectionStart();
2004 }
2005 
2006 ExceptionOr&lt;void&gt; HTMLInputElement::setSelectionStartForBindings(int start)
2007 {
2008     if (!canHaveSelection())
2009         return Exception { TypeError };
2010 
2011     setSelectionStart(start);
2012     return { };
2013 }
2014 
2015 ExceptionOr&lt;int&gt; HTMLInputElement::selectionEndForBindings() const
2016 {
2017     if (!canHaveSelection())
2018         return Exception { TypeError };
2019 
2020     return selectionEnd();
2021 }
2022 
2023 ExceptionOr&lt;void&gt; HTMLInputElement::setSelectionEndForBindings(int end)
2024 {
2025     if (!canHaveSelection())
2026         return Exception { TypeError };
2027 
2028     setSelectionEnd(end);
2029     return { };
2030 }
2031 
2032 ExceptionOr&lt;String&gt; HTMLInputElement::selectionDirectionForBindings() const
2033 {
2034     if (!canHaveSelection())
2035         return Exception { TypeError };
2036 
2037     return String { selectionDirection() };
2038 }
2039 
2040 ExceptionOr&lt;void&gt; HTMLInputElement::setSelectionDirectionForBindings(const String&amp; direction)
2041 {
2042     if (!canHaveSelection())
2043         return Exception { TypeError };
2044 
2045     setSelectionDirection(direction);
2046     return { };
2047 }
2048 
2049 ExceptionOr&lt;void&gt; HTMLInputElement::setSelectionRangeForBindings(int start, int end, const String&amp; direction)
2050 {
2051     if (!canHaveSelection())
2052         return Exception { TypeError };
2053 
2054     setSelectionRange(start, end, direction);
2055     return { };
2056 }
2057 
2058 static Ref&lt;CSSLinearGradientValue&gt; autoFillStrongPasswordMaskImage()
2059 {
2060     CSSGradientColorStop firstStop;
2061     firstStop.m_color = CSSValuePool::singleton().createColorValue(Color::black);
2062     firstStop.m_position = CSSValuePool::singleton().createValue(50, CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);
2063 
2064     CSSGradientColorStop secondStop;
2065     secondStop.m_color = CSSValuePool::singleton().createColorValue(Color::transparent);
2066     secondStop.m_position = CSSValuePool::singleton().createValue(100, CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);
2067 
2068     auto gradient = CSSLinearGradientValue::create(CSSGradientRepeat::NonRepeating, CSSGradientType::CSSLinearGradient);
2069     gradient-&gt;setAngle(CSSValuePool::singleton().createValue(90, CSSPrimitiveValue::UnitType::CSS_DEG));
2070     gradient-&gt;addStop(firstStop);
2071     gradient-&gt;addStop(secondStop);
2072     return gradient;
2073 }
2074 
2075 RenderStyle HTMLInputElement::createInnerTextStyle(const RenderStyle&amp; style)
2076 {
2077     auto textBlockStyle = RenderStyle::create();
2078     textBlockStyle.inheritFrom(style);
2079     adjustInnerTextStyle(style, textBlockStyle);
2080 
2081     textBlockStyle.setWhiteSpace(WhiteSpace::Pre);
2082     textBlockStyle.setOverflowWrap(OverflowWrap::Normal);
2083     textBlockStyle.setOverflowX(Overflow::Hidden);
2084     textBlockStyle.setOverflowY(Overflow::Hidden);
2085     textBlockStyle.setTextOverflow(shouldTruncateText(style) ? TextOverflow::Ellipsis : TextOverflow::Clip);
2086 
2087     textBlockStyle.setDisplay(DisplayType::Block);
2088 
2089     if (hasAutoFillStrongPasswordButton() &amp;&amp; !isDisabledOrReadOnly()) {
2090         textBlockStyle.setDisplay(DisplayType::InlineBlock);
2091         textBlockStyle.setMaxWidth(Length { 100, Percent });
2092         textBlockStyle.setColor({ 0.0f, 0.0f, 0.0f, 0.6f });
2093         textBlockStyle.setTextOverflow(TextOverflow::Clip);
2094         textBlockStyle.setMaskImage(styleResolver().styleImage(autoFillStrongPasswordMaskImage()));
2095         // A stacking context is needed for the mask.
2096         if (textBlockStyle.hasAutoZIndex())
2097             textBlockStyle.setZIndex(0);
2098     }
2099 
2100     // Do not allow line-height to be smaller than our default.
2101     if (textBlockStyle.fontMetrics().lineSpacing() &gt; style.computedLineHeight())
2102         textBlockStyle.setLineHeight(RenderStyle::initialLineHeight());
2103 
2104     return textBlockStyle;
2105 }
2106 
2107 #if ENABLE(DATE_AND_TIME_INPUT_TYPES)
2108 bool HTMLInputElement::setupDateTimeChooserParameters(DateTimeChooserParameters&amp; parameters)
2109 {
2110     if (!document().view())
2111         return false;
2112 
2113     parameters.type = type();
2114     parameters.minimum = minimum();
2115     parameters.maximum = maximum();
2116     parameters.required = isRequired();
2117 
2118     if (!document().settings().langAttributeAwareFormControlUIEnabled())
2119         parameters.locale = defaultLanguage();
2120     else {
2121         AtomString computedLocale = computeInheritedLanguage();
2122         parameters.locale = computedLocale.isEmpty() ? AtomString(defaultLanguage()) : computedLocale;
2123     }
2124 
2125     StepRange stepRange = createStepRange(RejectAny);
2126     if (stepRange.hasStep()) {
2127         parameters.step = stepRange.step().toDouble();
2128         parameters.stepBase = stepRange.stepBase().toDouble();
2129     } else {
2130         parameters.step = 1.0;
2131         parameters.stepBase = 0;
2132     }
2133 
2134     if (RenderElement* renderer = this-&gt;renderer())
2135         parameters.anchorRectInRootView = document().view()-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect());
2136     else
2137         parameters.anchorRectInRootView = IntRect();
2138     parameters.currentValue = value();
2139     parameters.isAnchorElementRTL = computedStyle()-&gt;direction() == TextDirection::RTL;
2140 #if ENABLE(DATALIST_ELEMENT)
2141     if (auto dataList = this-&gt;dataList()) {
2142         Ref&lt;HTMLCollection&gt; options = dataList-&gt;options();
2143         for (unsigned i = 0; RefPtr&lt;HTMLOptionElement&gt; option = downcast&lt;HTMLOptionElement&gt;(options-&gt;item(i)); ++i) {
2144             if (!isValidValue(option-&gt;value()))
2145                 continue;
2146             parameters.suggestionValues.append(sanitizeValue(option-&gt;value()));
2147             parameters.localizedSuggestionValues.append(localizeValue(option-&gt;value()));
2148             parameters.suggestionLabels.append(option-&gt;value() == option-&gt;label() ? String() : option-&gt;label());
2149         }
2150     }
2151 #endif
2152     return true;
2153 }
2154 #endif
2155 
2156 void HTMLInputElement::capsLockStateMayHaveChanged()
2157 {
2158     m_inputType-&gt;capsLockStateMayHaveChanged();
2159 }
2160 
2161 } // namespace
    </pre>
  </body>
</html>