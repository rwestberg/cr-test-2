<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/testing/Internals.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2012 Google Inc. All rights reserved.
   3  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  18  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  19  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  22  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  24  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Internals.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;ActiveDOMCallbackMicrotask.h&quot;
  32 #include &quot;ActivityState.h&quot;
  33 #include &quot;AnimationTimeline.h&quot;
  34 #include &quot;ApplicationCacheStorage.h&quot;
  35 #include &quot;AudioSession.h&quot;
  36 #include &quot;Autofill.h&quot;
  37 #include &quot;BackForwardController.h&quot;
  38 #include &quot;BitmapImage.h&quot;
  39 #include &quot;CSSAnimationController.h&quot;
  40 #include &quot;CSSKeyframesRule.h&quot;
  41 #include &quot;CSSMediaRule.h&quot;
  42 #include &quot;CSSStyleRule.h&quot;
  43 #include &quot;CSSSupportsRule.h&quot;
  44 #include &quot;CacheStorageConnection.h&quot;
  45 #include &quot;CacheStorageProvider.h&quot;
  46 #include &quot;CachedImage.h&quot;
  47 #include &quot;CachedResourceLoader.h&quot;
  48 #include &quot;CertificateInfo.h&quot;
  49 #include &quot;Chrome.h&quot;
  50 #include &quot;ChromeClient.h&quot;
  51 #include &quot;ClientOrigin.h&quot;
  52 #include &quot;ComposedTreeIterator.h&quot;
  53 #include &quot;CookieJar.h&quot;
  54 #include &quot;Cursor.h&quot;
  55 #include &quot;CustomHeaderFields.h&quot;
  56 #include &quot;DOMRect.h&quot;
  57 #include &quot;DOMRectList.h&quot;
  58 #include &quot;DOMStringList.h&quot;
  59 #include &quot;DOMWindow.h&quot;
  60 #include &quot;DeprecatedGlobalSettings.h&quot;
  61 #include &quot;DiagnosticLoggingClient.h&quot;
  62 #include &quot;DisabledAdaptations.h&quot;
  63 #include &quot;DisplayList.h&quot;
  64 #include &quot;Document.h&quot;
  65 #include &quot;DocumentLoader.h&quot;
  66 #include &quot;DocumentMarkerController.h&quot;
  67 #include &quot;DocumentTimeline.h&quot;
  68 #include &quot;Editor.h&quot;
  69 #include &quot;Element.h&quot;
  70 #include &quot;EventHandler.h&quot;
  71 #include &quot;EventListener.h&quot;
  72 #include &quot;EventNames.h&quot;
  73 #include &quot;ExtendableEvent.h&quot;
  74 #include &quot;ExtensionStyleSheets.h&quot;
  75 #include &quot;FetchResponse.h&quot;
  76 #include &quot;File.h&quot;
  77 #include &quot;FontCache.h&quot;
  78 #include &quot;FormController.h&quot;
  79 #include &quot;Frame.h&quot;
  80 #include &quot;FrameLoader.h&quot;
  81 #include &quot;FrameView.h&quot;
  82 #include &quot;FullscreenManager.h&quot;
  83 #include &quot;GCObservation.h&quot;
  84 #include &quot;GridPosition.h&quot;
  85 #include &quot;HEVCUtilities.h&quot;
  86 #include &quot;HTMLAnchorElement.h&quot;
  87 #include &quot;HTMLCanvasElement.h&quot;
  88 #include &quot;HTMLIFrameElement.h&quot;
  89 #include &quot;HTMLImageElement.h&quot;
  90 #include &quot;HTMLInputElement.h&quot;
  91 #include &quot;HTMLLinkElement.h&quot;
  92 #include &quot;HTMLNames.h&quot;
  93 #include &quot;HTMLPictureElement.h&quot;
  94 #include &quot;HTMLPlugInElement.h&quot;
  95 #include &quot;HTMLPreloadScanner.h&quot;
  96 #include &quot;HTMLSelectElement.h&quot;
  97 #include &quot;HTMLTextAreaElement.h&quot;
  98 #include &quot;HTMLVideoElement.h&quot;
  99 #include &quot;HistoryController.h&quot;
 100 #include &quot;HistoryItem.h&quot;
 101 #include &quot;HitTestResult.h&quot;
 102 #include &quot;InspectorClient.h&quot;
 103 #include &quot;InspectorController.h&quot;
 104 #include &quot;InspectorFrontendClientLocal.h&quot;
 105 #include &quot;InspectorOverlay.h&quot;
 106 #include &quot;InstrumentingAgents.h&quot;
 107 #include &quot;IntRect.h&quot;
 108 #include &quot;InternalSettings.h&quot;
 109 #include &quot;JSImageData.h&quot;
 110 #include &quot;LibWebRTCProvider.h&quot;
 111 #include &quot;LoaderStrategy.h&quot;
 112 #include &quot;MallocStatistics.h&quot;
 113 #include &quot;MediaDevices.h&quot;
 114 #include &quot;MediaEngineConfigurationFactory.h&quot;
 115 #include &quot;MediaPlayer.h&quot;
 116 #include &quot;MediaProducer.h&quot;
 117 #include &quot;MediaResourceLoader.h&quot;
 118 #include &quot;MediaStreamTrack.h&quot;
 119 #include &quot;MemoryCache.h&quot;
 120 #include &quot;MemoryInfo.h&quot;
 121 #include &quot;MockLibWebRTCPeerConnection.h&quot;
 122 #include &quot;MockPageOverlay.h&quot;
 123 #include &quot;MockPageOverlayClient.h&quot;
 124 #include &quot;NavigatorMediaDevices.h&quot;
 125 #include &quot;NetworkLoadInformation.h&quot;
 126 #include &quot;Page.h&quot;
 127 #include &quot;PageCache.h&quot;
 128 #include &quot;PageOverlay.h&quot;
 129 #include &quot;PathUtilities.h&quot;
 130 #include &quot;PlatformKeyboardEvent.h&quot;
 131 #include &quot;PlatformMediaSessionManager.h&quot;
 132 #include &quot;PlatformScreen.h&quot;
 133 #include &quot;PlatformStrategies.h&quot;
 134 #include &quot;PluginData.h&quot;
 135 #include &quot;PrintContext.h&quot;
 136 #include &quot;PseudoElement.h&quot;
 137 #include &quot;Range.h&quot;
 138 #include &quot;ReadableStream.h&quot;
 139 #include &quot;RenderEmbeddedObject.h&quot;
 140 #include &quot;RenderLayerBacking.h&quot;
 141 #include &quot;RenderLayerCompositor.h&quot;
 142 #include &quot;RenderMenuList.h&quot;
 143 #include &quot;RenderTreeAsText.h&quot;
 144 #include &quot;RenderView.h&quot;
 145 #include &quot;RenderedDocumentMarker.h&quot;
 146 #include &quot;ResourceLoadObserver.h&quot;
 147 #include &quot;RuntimeEnabledFeatures.h&quot;
 148 #include &quot;SMILTimeContainer.h&quot;
 149 #include &quot;SVGDocumentExtensions.h&quot;
 150 #include &quot;SVGPathStringBuilder.h&quot;
 151 #include &quot;SVGSVGElement.h&quot;
 152 #include &quot;SWClientConnection.h&quot;
 153 #include &quot;SchemeRegistry.h&quot;
 154 #include &quot;ScriptedAnimationController.h&quot;
 155 #include &quot;ScrollingCoordinator.h&quot;
 156 #include &quot;ScrollingMomentumCalculator.h&quot;
 157 #include &quot;SecurityOrigin.h&quot;
 158 #include &quot;SerializedScriptValue.h&quot;
 159 #include &quot;ServiceWorker.h&quot;
 160 #include &quot;ServiceWorkerProvider.h&quot;
 161 #include &quot;ServiceWorkerRegistrationData.h&quot;
 162 #include &quot;Settings.h&quot;
 163 #include &quot;ShadowRoot.h&quot;
 164 #include &quot;SourceBuffer.h&quot;
 165 #include &quot;SpellChecker.h&quot;
 166 #include &quot;StaticNodeList.h&quot;
 167 #include &quot;StringCallback.h&quot;
 168 #include &quot;StyleRule.h&quot;
 169 #include &quot;StyleScope.h&quot;
 170 #include &quot;StyleSheetContents.h&quot;
 171 #include &quot;TextIterator.h&quot;
 172 #include &quot;TreeScope.h&quot;
 173 #include &quot;TypeConversions.h&quot;
 174 #include &quot;UserGestureIndicator.h&quot;
 175 #include &quot;UserMediaController.h&quot;
 176 #include &quot;ViewportArguments.h&quot;
 177 #include &quot;VoidCallback.h&quot;
 178 #include &quot;WebCoreJSClientData.h&quot;
 179 #include &quot;WindowProxy.h&quot;
 180 #include &quot;WorkerThread.h&quot;
 181 #include &quot;WorkletGlobalScope.h&quot;
 182 #include &quot;WritingDirection.h&quot;
 183 #include &quot;XMLHttpRequest.h&quot;
 184 #include &lt;JavaScriptCore/CodeBlock.h&gt;
 185 #include &lt;JavaScriptCore/InspectorAgentBase.h&gt;
 186 #include &lt;JavaScriptCore/InspectorFrontendChannel.h&gt;
 187 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 188 #include &lt;JavaScriptCore/JSCJSValue.h&gt;
 189 #include &lt;wtf/HexNumber.h&gt;
 190 #include &lt;wtf/JSONValues.h&gt;
 191 #include &lt;wtf/Language.h&gt;
 192 #include &lt;wtf/MemoryPressureHandler.h&gt;
 193 #include &lt;wtf/MonotonicTime.h&gt;
 194 #include &lt;wtf/URLHelpers.h&gt;
 195 #include &lt;wtf/text/StringBuilder.h&gt;
 196 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 197 
 198 #if USE(CG)
 199 #include &quot;PDFDocumentImage.h&quot;
 200 #endif
 201 
 202 #if ENABLE(INPUT_TYPE_COLOR)
 203 #include &quot;ColorChooser.h&quot;
 204 #endif
 205 
 206 #if ENABLE(MOUSE_CURSOR_SCALE)
 207 #include &lt;wtf/dtoa.h&gt;
 208 #endif
 209 
 210 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 211 #include &quot;LegacyCDM.h&quot;
 212 #include &quot;LegacyMockCDM.h&quot;
 213 #endif
 214 
 215 #if ENABLE(ENCRYPTED_MEDIA)
 216 #include &quot;MockCDMFactory.h&quot;
 217 #endif
 218 
 219 #if ENABLE(VIDEO_TRACK)
 220 #include &quot;CaptionUserPreferences.h&quot;
 221 #include &quot;PageGroup.h&quot;
 222 #include &quot;TextTrackCueGeneric.h&quot;
 223 #endif
 224 
 225 #if ENABLE(VIDEO)
 226 #include &quot;HTMLMediaElement.h&quot;
 227 #include &quot;TimeRanges.h&quot;
 228 #endif
 229 
 230 #if ENABLE(WEBGL)
 231 #include &quot;WebGLRenderingContext.h&quot;
 232 #endif
 233 
 234 #if ENABLE(SPEECH_SYNTHESIS)
 235 #include &quot;DOMWindowSpeechSynthesis.h&quot;
 236 #include &quot;PlatformSpeechSynthesizerMock.h&quot;
 237 #include &quot;SpeechSynthesis.h&quot;
 238 #endif
 239 
 240 #if ENABLE(MEDIA_STREAM)
 241 #include &quot;MediaRecorder.h&quot;
 242 #include &quot;MediaRecorderPrivateMock.h&quot;
 243 #include &quot;MediaStream.h&quot;
 244 #include &quot;MockRealtimeMediaSourceCenter.h&quot;
 245 #endif
 246 
 247 #if ENABLE(WEB_RTC)
 248 #include &quot;RTCPeerConnection.h&quot;
 249 #endif
 250 
 251 #if ENABLE(MEDIA_SOURCE)
 252 #include &quot;MockMediaPlayerMediaSource.h&quot;
 253 #endif
 254 
 255 #if ENABLE(CONTENT_FILTERING)
 256 #include &quot;MockContentFilterSettings.h&quot;
 257 #endif
 258 
 259 #if ENABLE(WEB_AUDIO)
 260 #include &quot;AudioContext.h&quot;
 261 #endif
 262 
 263 #if ENABLE(MEDIA_SESSION)
 264 #include &quot;MediaSession.h&quot;
 265 #include &quot;MediaSessionManager.h&quot;
 266 #endif
 267 
 268 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 269 #include &quot;MediaPlaybackTargetContext.h&quot;
 270 #endif
 271 
 272 #if ENABLE(POINTER_LOCK)
 273 #include &quot;PointerLockController.h&quot;
 274 #endif
 275 
 276 #if ENABLE(INDEXED_DATABASE)
 277 #include &quot;IDBRequest.h&quot;
 278 #include &quot;IDBTransaction.h&quot;
 279 #endif
 280 
 281 #if USE(QUICK_LOOK)
 282 #include &quot;MockPreviewLoaderClient.h&quot;
 283 #include &quot;PreviewLoader.h&quot;
 284 #endif
 285 
 286 #if ENABLE(APPLE_PAY)
 287 #include &quot;MockPaymentCoordinator.h&quot;
 288 #include &quot;PaymentCoordinator.h&quot;
 289 #endif
 290 
 291 #if PLATFORM(MAC) &amp;&amp; USE(LIBWEBRTC)
 292 #include &lt;webrtc/sdk/WebKit/VideoProcessingSoftLink.h&gt;
 293 #endif
 294 
 295 #if PLATFORM(MAC)
 296 #include &quot;GraphicsContext3DManager.h&quot;
 297 #endif
 298 
 299 using JSC::CallData;
 300 using JSC::CallType;
 301 using JSC::CodeBlock;
 302 using JSC::FunctionExecutable;
 303 using JSC::Identifier;
 304 using JSC::JSFunction;
 305 using JSC::JSGlobalObject;
 306 using JSC::JSObject;
 307 using JSC::JSValue;
 308 using JSC::MarkedArgumentBuffer;
 309 using JSC::PropertySlot;
 310 using JSC::ScriptExecutable;
 311 using JSC::StackVisitor;
 312 
 313 
 314 namespace WebCore {
 315 using namespace Inspector;
 316 
 317 using namespace HTMLNames;
 318 
 319 class InspectorStubFrontend final : public InspectorFrontendClientLocal, public FrontendChannel {
 320 public:
 321     InspectorStubFrontend(Page&amp; inspectedPage, RefPtr&lt;DOMWindow&gt;&amp;&amp; frontendWindow);
 322     virtual ~InspectorStubFrontend();
 323 
 324 private:
 325     void attachWindow(DockSide) final { }
 326     void detachWindow() final { }
 327     void closeWindow() final;
 328     void reopen() final { }
 329     void bringToFront() final { }
 330     String localizedStringsURL() final { return String(); }
 331     void inspectedURLChanged(const String&amp;) final { }
 332     void showCertificate(const CertificateInfo&amp;) final { }
 333     void setAttachedWindowHeight(unsigned) final { }
 334     void setAttachedWindowWidth(unsigned) final { }
 335     void setSheetRect(const FloatRect&amp;) final { }
 336 
 337     void sendMessageToFrontend(const String&amp; message) final;
 338     ConnectionType connectionType() const final { return ConnectionType::Local; }
 339 
 340     RefPtr&lt;DOMWindow&gt; m_frontendWindow;
 341 };
 342 
 343 InspectorStubFrontend::InspectorStubFrontend(Page&amp; inspectedPage, RefPtr&lt;DOMWindow&gt;&amp;&amp; frontendWindow)
 344     : InspectorFrontendClientLocal(&amp;inspectedPage.inspectorController(), frontendWindow-&gt;document()-&gt;page(), makeUnique&lt;InspectorFrontendClientLocal::Settings&gt;())
 345     , m_frontendWindow(frontendWindow.copyRef())
 346 {
 347     ASSERT_ARG(frontendWindow, frontendWindow);
 348 
 349     frontendPage()-&gt;inspectorController().setInspectorFrontendClient(this);
 350     inspectedPage.inspectorController().connectFrontend(*this);
 351 }
 352 
 353 InspectorStubFrontend::~InspectorStubFrontend()
 354 {
 355     closeWindow();
 356 }
 357 
 358 void InspectorStubFrontend::closeWindow()
 359 {
 360     if (!m_frontendWindow)
 361         return;
 362 
 363     frontendPage()-&gt;inspectorController().setInspectorFrontendClient(nullptr);
 364     inspectedPage()-&gt;inspectorController().disconnectFrontend(*this);
 365 
 366     m_frontendWindow-&gt;close();
 367     m_frontendWindow = nullptr;
 368 }
 369 
 370 void InspectorStubFrontend::sendMessageToFrontend(const String&amp; message)
 371 {
 372     dispatchMessageAsync(message);
 373 }
 374 
 375 static bool markerTypeFrom(const String&amp; markerType, DocumentMarker::MarkerType&amp; result)
 376 {
 377     if (equalLettersIgnoringASCIICase(markerType, &quot;spelling&quot;))
 378         result = DocumentMarker::Spelling;
 379     else if (equalLettersIgnoringASCIICase(markerType, &quot;grammar&quot;))
 380         result = DocumentMarker::Grammar;
 381     else if (equalLettersIgnoringASCIICase(markerType, &quot;textmatch&quot;))
 382         result = DocumentMarker::TextMatch;
 383     else if (equalLettersIgnoringASCIICase(markerType, &quot;replacement&quot;))
 384         result = DocumentMarker::Replacement;
 385     else if (equalLettersIgnoringASCIICase(markerType, &quot;correctionindicator&quot;))
 386         result = DocumentMarker::CorrectionIndicator;
 387     else if (equalLettersIgnoringASCIICase(markerType, &quot;rejectedcorrection&quot;))
 388         result = DocumentMarker::RejectedCorrection;
 389     else if (equalLettersIgnoringASCIICase(markerType, &quot;autocorrected&quot;))
 390         result = DocumentMarker::Autocorrected;
 391     else if (equalLettersIgnoringASCIICase(markerType, &quot;spellcheckingexemption&quot;))
 392         result = DocumentMarker::SpellCheckingExemption;
 393     else if (equalLettersIgnoringASCIICase(markerType, &quot;deletedautocorrection&quot;))
 394         result = DocumentMarker::DeletedAutocorrection;
 395     else if (equalLettersIgnoringASCIICase(markerType, &quot;dictationalternatives&quot;))
 396         result = DocumentMarker::DictationAlternatives;
 397 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
 398     else if (equalLettersIgnoringASCIICase(markerType, &quot;telephonenumber&quot;))
 399         result = DocumentMarker::TelephoneNumber;
 400 #endif
 401     else
 402         return false;
 403 
 404     return true;
 405 }
 406 
 407 static bool markerTypesFrom(const String&amp; markerType, OptionSet&lt;DocumentMarker::MarkerType&gt;&amp; result)
 408 {
 409     DocumentMarker::MarkerType singularResult;
 410 
 411     if (markerType.isEmpty() || equalLettersIgnoringASCIICase(markerType, &quot;all&quot;))
 412         result = DocumentMarker::allMarkers();
 413     else if (markerTypeFrom(markerType, singularResult))
 414         result = singularResult;
 415     else
 416         return false;
 417 
 418     return true;
 419 }
 420 
 421 static std::unique_ptr&lt;PrintContext&gt;&amp; printContextForTesting()
 422 {
 423     static NeverDestroyed&lt;std::unique_ptr&lt;PrintContext&gt;&gt; context;
 424     return context;
 425 }
 426 
 427 const char* Internals::internalsId = &quot;internals&quot;;
 428 
 429 Ref&lt;Internals&gt; Internals::create(Document&amp; document)
 430 {
 431     return adoptRef(*new Internals(document));
 432 }
 433 
 434 Internals::~Internals()
 435 {
 436 #if ENABLE(MEDIA_STREAM)
 437     if (m_track)
 438         m_track-&gt;source().removeObserver(*this);
 439 #endif
 440 }
 441 
 442 void Internals::resetToConsistentState(Page&amp; page)
 443 {
 444     page.setPageScaleFactor(1, IntPoint(0, 0));
 445     page.setPagination(Pagination());
 446     page.setPaginationLineGridEnabled(false);
 447 
 448     page.setDefersLoading(false);
 449 
 450     page.mainFrame().setTextZoomFactor(1.0f);
 451 
 452     page.setCompositingPolicyOverride(WebCore::CompositingPolicy::Normal);
 453 
 454     FrameView* mainFrameView = page.mainFrame().view();
 455     if (mainFrameView) {
 456         page.setHeaderHeight(0);
 457         page.setFooterHeight(0);
 458         page.setTopContentInset(0);
 459         mainFrameView-&gt;setUseFixedLayout(false);
 460         mainFrameView-&gt;setFixedLayoutSize(IntSize());
 461         mainFrameView-&gt;enableAutoSizeMode(false, { });
 462 #if USE(COORDINATED_GRAPHICS)
 463         mainFrameView-&gt;setFixedVisibleContentRect(IntRect());
 464 #endif
 465         if (auto* backing = mainFrameView-&gt;tiledBacking())
 466             backing-&gt;setTileSizeUpdateDelayDisabledForTesting(false);
 467     }
 468 
 469     WTF::clearDefaultPortForProtocolMapForTesting();
 470     overrideUserPreferredLanguages(Vector&lt;String&gt;());
 471     WebCore::DeprecatedGlobalSettings::setUsesOverlayScrollbars(false);
 472     WebCore::DeprecatedGlobalSettings::setUsesMockScrollAnimator(false);
 473 #if ENABLE(VIDEO_TRACK)
 474     page.group().captionPreferences().setTestingMode(true);
 475     page.group().captionPreferences().setCaptionsStyleSheetOverride(emptyString());
 476     page.group().captionPreferences().setTestingMode(false);
 477 #endif
 478     if (!page.mainFrame().editor().isContinuousSpellCheckingEnabled())
 479         page.mainFrame().editor().toggleContinuousSpellChecking();
 480     if (page.mainFrame().editor().isOverwriteModeEnabled())
 481         page.mainFrame().editor().toggleOverwriteModeEnabled();
 482     page.mainFrame().loader().clearTestingOverrides();
 483     page.applicationCacheStorage().setDefaultOriginQuota(ApplicationCacheStorage::noQuota());
 484 #if ENABLE(VIDEO)
 485     PlatformMediaSessionManager::sharedManager().resetRestrictions();
 486     PlatformMediaSessionManager::sharedManager().setWillIgnoreSystemInterruptions(true);
 487 #endif
 488     PlatformMediaSessionManager::sharedManager().setIsPlayingToAutomotiveHeadUnit(false);
 489 #if ENABLE(ACCESSIBILITY)
 490     AXObjectCache::setEnhancedUserInterfaceAccessibility(false);
 491     AXObjectCache::disableAccessibility();
 492 #endif
 493 
 494     MockPageOverlayClient::singleton().uninstallAllOverlays();
 495 
 496 #if ENABLE(CONTENT_FILTERING)
 497     MockContentFilterSettings::reset();
 498 #endif
 499 
 500 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 501     page.setMockMediaPlaybackTargetPickerEnabled(true);
 502     page.setMockMediaPlaybackTargetPickerState(emptyString(), MediaPlaybackTargetContext::Unknown);
 503 #endif
 504 
 505     page.setShowAllPlugins(false);
 506     page.setLowPowerModeEnabledOverrideForTesting(WTF::nullopt);
 507 
 508 #if USE(QUICK_LOOK)
 509     MockPreviewLoaderClient::singleton().setPassword(&quot;&quot;);
 510     PreviewLoader::setClientForTesting(nullptr);
 511 #endif
 512 
 513     printContextForTesting() = nullptr;
 514 
 515 #if USE(LIBWEBRTC)
 516     auto&amp; rtcProvider = page.libWebRTCProvider();
 517     WebCore::useRealRTCPeerConnectionFactory(rtcProvider);
 518     rtcProvider.disableNonLocalhostConnections();
 519     RuntimeEnabledFeatures::sharedFeatures().setWebRTCVP8CodecEnabled(true);
 520     page.settings().setWebRTCEncryptionEnabled(true);
 521 #endif
 522 
 523     page.settings().setStorageAccessAPIEnabled(false);
 524     page.setFullscreenAutoHideDuration(0_s);
 525     page.setFullscreenInsets({ });
 526     page.setFullscreenControlsHidden(false);
 527 
 528     MediaEngineConfigurationFactory::disableMock();
 529 
 530 #if ENABLE(MEDIA_STREAM)
 531     RuntimeEnabledFeatures::sharedFeatures().setInterruptAudioOnPageVisibilityChangeEnabled(false);
 532 #endif
 533 }
 534 
 535 Internals::Internals(Document&amp; document)
 536     : ContextDestructionObserver(&amp;document)
 537 #if ENABLE(MEDIA_STREAM)
 538     , m_orientationNotifier(0)
 539 #endif
 540 {
 541 #if ENABLE(VIDEO_TRACK)
 542     if (document.page())
 543         document.page()-&gt;group().captionPreferences().setTestingMode(true);
 544 #endif
 545 
 546 #if ENABLE(MEDIA_STREAM)
 547     setMockMediaCaptureDevicesEnabled(true);
 548     setMediaCaptureRequiresSecureConnection(false);
 549 #endif
 550 
 551 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 552     if (document.page())
 553         document.page()-&gt;setMockMediaPlaybackTargetPickerEnabled(true);
 554 #endif
 555 
 556     if (contextDocument() &amp;&amp; contextDocument()-&gt;frame()) {
 557         setAutomaticSpellingCorrectionEnabled(true);
 558         setAutomaticQuoteSubstitutionEnabled(false);
 559         setAutomaticDashSubstitutionEnabled(false);
 560         setAutomaticLinkDetectionEnabled(false);
 561         setAutomaticTextReplacementEnabled(true);
 562     }
 563 
 564     setConsoleMessageListener(nullptr);
 565 
 566 #if ENABLE(APPLE_PAY)
 567     auto* frame = document.frame();
 568     if (frame &amp;&amp; frame-&gt;page() &amp;&amp; frame-&gt;isMainFrame()) {
 569         auto mockPaymentCoordinator = new MockPaymentCoordinator(*frame-&gt;page());
 570         frame-&gt;page()-&gt;setPaymentCoordinator(makeUnique&lt;PaymentCoordinator&gt;(*mockPaymentCoordinator));
 571     }
 572 #endif
 573 }
 574 
 575 Document* Internals::contextDocument() const
 576 {
 577     return downcast&lt;Document&gt;(scriptExecutionContext());
 578 }
 579 
 580 Frame* Internals::frame() const
 581 {
 582     if (!contextDocument())
 583         return nullptr;
 584     return contextDocument()-&gt;frame();
 585 }
 586 
 587 InternalSettings* Internals::settings() const
 588 {
 589     Document* document = contextDocument();
 590     if (!document)
 591         return nullptr;
 592     Page* page = document-&gt;page();
 593     if (!page)
 594         return nullptr;
 595     return InternalSettings::from(page);
 596 }
 597 
 598 unsigned Internals::workerThreadCount() const
 599 {
 600     return WorkerThread::workerThreadCount();
 601 }
 602 
 603 ExceptionOr&lt;bool&gt; Internals::areSVGAnimationsPaused() const
 604 {
 605     auto* document = contextDocument();
 606     if (!document)
 607         return Exception { InvalidAccessError, &quot;No context document&quot;_s };
 608 
 609     if (!document-&gt;svgExtensions())
 610         return Exception { NotFoundError, &quot;No SVG animations&quot;_s };
 611 
 612     return document-&gt;accessSVGExtensions().areAnimationsPaused();
 613 }
 614 
 615 ExceptionOr&lt;double&gt; Internals::svgAnimationsInterval(SVGSVGElement&amp; element) const
 616 {
 617     auto* document = contextDocument();
 618     if (!document)
 619         return 0;
 620 
 621     if (!document-&gt;svgExtensions())
 622         return 0;
 623 
 624     if (document-&gt;accessSVGExtensions().areAnimationsPaused())
 625         return 0;
 626 
 627     return element.timeContainer().animationFrameDelay().value();
 628 }
 629 
 630 String Internals::address(Node&amp; node)
 631 {
 632     return makeString(&quot;0x&quot;, hex(reinterpret_cast&lt;uintptr_t&gt;(&amp;node)));
 633 }
 634 
 635 bool Internals::nodeNeedsStyleRecalc(Node&amp; node)
 636 {
 637     return node.needsStyleRecalc();
 638 }
 639 
 640 static String styleValidityToToString(Style::Validity validity)
 641 {
 642     switch (validity) {
 643     case Style::Validity::Valid:
 644         return &quot;NoStyleChange&quot;;
 645     case Style::Validity::ElementInvalid:
 646         return &quot;InlineStyleChange&quot;;
 647     case Style::Validity::SubtreeInvalid:
 648         return &quot;FullStyleChange&quot;;
 649     case Style::Validity::SubtreeAndRenderersInvalid:
 650         return &quot;ReconstructRenderTree&quot;;
 651     }
 652     ASSERT_NOT_REACHED();
 653     return &quot;&quot;;
 654 }
 655 
 656 String Internals::styleChangeType(Node&amp; node)
 657 {
 658     node.document().styleScope().flushPendingUpdate();
 659 
 660     return styleValidityToToString(node.styleValidity());
 661 }
 662 
 663 String Internals::description(JSC::JSValue value)
 664 {
 665     return toString(value);
 666 }
 667 
 668 bool Internals::isPreloaded(const String&amp; url)
 669 {
 670     Document* document = contextDocument();
 671     return document-&gt;cachedResourceLoader().isPreloaded(url);
 672 }
 673 
 674 bool Internals::isLoadingFromMemoryCache(const String&amp; url)
 675 {
 676     if (!contextDocument() || !contextDocument()-&gt;page())
 677         return false;
 678 
 679     ResourceRequest request(contextDocument()-&gt;completeURL(url));
 680     request.setDomainForCachePartition(contextDocument()-&gt;domainForCachePartition());
 681 
 682     CachedResource* resource = MemoryCache::singleton().resourceForRequest(request, contextDocument()-&gt;page()-&gt;sessionID());
 683     return resource &amp;&amp; resource-&gt;status() == CachedResource::Cached;
 684 }
 685 
 686 static String responseSourceToString(const ResourceResponse&amp; response)
 687 {
 688     if (response.isNull())
 689         return &quot;Null response&quot;;
 690     switch (response.source()) {
 691     case ResourceResponse::Source::Unknown:
 692         return &quot;Unknown&quot;;
 693     case ResourceResponse::Source::Network:
 694         return &quot;Network&quot;;
 695     case ResourceResponse::Source::ServiceWorker:
 696         return &quot;Service worker&quot;;
 697     case ResourceResponse::Source::DiskCache:
 698         return &quot;Disk cache&quot;;
 699     case ResourceResponse::Source::DiskCacheAfterValidation:
 700         return &quot;Disk cache after validation&quot;;
 701     case ResourceResponse::Source::MemoryCache:
 702         return &quot;Memory cache&quot;;
 703     case ResourceResponse::Source::MemoryCacheAfterValidation:
 704         return &quot;Memory cache after validation&quot;;
 705     case ResourceResponse::Source::ApplicationCache:
 706         return &quot;Application cache&quot;;
 707     }
 708     ASSERT_NOT_REACHED();
 709     return &quot;Error&quot;;
 710 }
 711 
 712 String Internals::xhrResponseSource(XMLHttpRequest&amp; request)
 713 {
 714     return responseSourceToString(request.resourceResponse());
 715 }
 716 
 717 String Internals::fetchResponseSource(FetchResponse&amp; response)
 718 {
 719     return responseSourceToString(response.resourceResponse());
 720 }
 721 
 722 bool Internals::isSharingStyleSheetContents(HTMLLinkElement&amp; a, HTMLLinkElement&amp; b)
 723 {
 724     if (!a.sheet() || !b.sheet())
 725         return false;
 726     return &amp;a.sheet()-&gt;contents() == &amp;b.sheet()-&gt;contents();
 727 }
 728 
 729 bool Internals::isStyleSheetLoadingSubresources(HTMLLinkElement&amp; link)
 730 {
 731     return link.sheet() &amp;&amp; link.sheet()-&gt;contents().isLoadingSubresources();
 732 }
 733 
 734 static ResourceRequestCachePolicy toResourceRequestCachePolicy(Internals::CachePolicy policy)
 735 {
 736     switch (policy) {
 737     case Internals::CachePolicy::UseProtocolCachePolicy:
 738         return ResourceRequestCachePolicy::UseProtocolCachePolicy;
 739     case Internals::CachePolicy::ReloadIgnoringCacheData:
 740         return ResourceRequestCachePolicy::ReloadIgnoringCacheData;
 741     case Internals::CachePolicy::ReturnCacheDataElseLoad:
 742         return ResourceRequestCachePolicy::ReturnCacheDataElseLoad;
 743     case Internals::CachePolicy::ReturnCacheDataDontLoad:
 744         return ResourceRequestCachePolicy::ReturnCacheDataDontLoad;
 745     }
 746     ASSERT_NOT_REACHED();
 747     return ResourceRequestCachePolicy::UseProtocolCachePolicy;
 748 }
 749 
 750 void Internals::setOverrideCachePolicy(CachePolicy policy)
 751 {
 752     frame()-&gt;loader().setOverrideCachePolicyForTesting(toResourceRequestCachePolicy(policy));
 753 }
 754 
 755 ExceptionOr&lt;void&gt; Internals::setCanShowModalDialogOverride(bool allow)
 756 {
 757     if (!contextDocument() || !contextDocument()-&gt;domWindow())
 758         return Exception { InvalidAccessError };
 759 
 760     contextDocument()-&gt;domWindow()-&gt;setCanShowModalDialogOverride(allow);
 761     return { };
 762 }
 763 
 764 static ResourceLoadPriority toResourceLoadPriority(Internals::ResourceLoadPriority priority)
 765 {
 766     switch (priority) {
 767     case Internals::ResourceLoadPriority::ResourceLoadPriorityVeryLow:
 768         return ResourceLoadPriority::VeryLow;
 769     case Internals::ResourceLoadPriority::ResourceLoadPriorityLow:
 770         return ResourceLoadPriority::Low;
 771     case Internals::ResourceLoadPriority::ResourceLoadPriorityMedium:
 772         return ResourceLoadPriority::Medium;
 773     case Internals::ResourceLoadPriority::ResourceLoadPriorityHigh:
 774         return ResourceLoadPriority::High;
 775     case Internals::ResourceLoadPriority::ResourceLoadPriorityVeryHigh:
 776         return ResourceLoadPriority::VeryHigh;
 777     }
 778     ASSERT_NOT_REACHED();
 779     return ResourceLoadPriority::Low;
 780 }
 781 
 782 void Internals::setOverrideResourceLoadPriority(ResourceLoadPriority priority)
 783 {
 784     frame()-&gt;loader().setOverrideResourceLoadPriorityForTesting(toResourceLoadPriority(priority));
 785 }
 786 
 787 void Internals::setStrictRawResourceValidationPolicyDisabled(bool disabled)
 788 {
 789     frame()-&gt;loader().setStrictRawResourceValidationPolicyDisabledForTesting(disabled);
 790 }
 791 
 792 void Internals::clearMemoryCache()
 793 {
 794     MemoryCache::singleton().evictResources();
 795 }
 796 
 797 void Internals::pruneMemoryCacheToSize(unsigned size)
 798 {
 799     MemoryCache::singleton().pruneDeadResourcesToSize(size);
 800     MemoryCache::singleton().pruneLiveResourcesToSize(size, true);
 801 }
 802 
 803 void Internals::destroyDecodedDataForAllImages()
 804 {
 805     MemoryCache::singleton().destroyDecodedDataForAllImages();
 806 }
 807 
 808 unsigned Internals::memoryCacheSize() const
 809 {
 810     return MemoryCache::singleton().size();
 811 }
 812 
 813 static Image* imageFromImageElement(HTMLImageElement&amp; element)
 814 {
 815     auto* cachedImage = element.cachedImage();
 816     return cachedImage ? cachedImage-&gt;image() : nullptr;
 817 }
 818 
 819 static BitmapImage* bitmapImageFromImageElement(HTMLImageElement&amp; element)
 820 {
 821     auto* image = imageFromImageElement(element);
 822     return image &amp;&amp; is&lt;BitmapImage&gt;(image) ? &amp;downcast&lt;BitmapImage&gt;(*image) : nullptr;
 823 }
 824 
 825 #if USE(CG)
 826 static PDFDocumentImage* pdfDocumentImageFromImageElement(HTMLImageElement&amp; element)
 827 {
 828     auto* image = imageFromImageElement(element);
 829     return image &amp;&amp; is&lt;PDFDocumentImage&gt;(image) ? &amp;downcast&lt;PDFDocumentImage&gt;(*image) : nullptr;
 830 }
 831 #endif
 832 
 833 unsigned Internals::imageFrameIndex(HTMLImageElement&amp; element)
 834 {
 835     auto* bitmapImage = bitmapImageFromImageElement(element);
 836     return bitmapImage ? bitmapImage-&gt;currentFrame() : 0;
 837 }
 838 
 839 unsigned Internals::imageFrameCount(HTMLImageElement&amp; element)
 840 {
 841     auto* bitmapImage = bitmapImageFromImageElement(element);
 842     return bitmapImage ? bitmapImage-&gt;frameCount() : 0;
 843 }
 844 
 845 float Internals::imageFrameDurationAtIndex(HTMLImageElement&amp; element, unsigned index)
 846 {
 847     auto* bitmapImage = bitmapImageFromImageElement(element);
 848     return bitmapImage ? bitmapImage-&gt;frameDurationAtIndex(index).value() : 0;
 849 }
 850 
 851 void Internals::setImageFrameDecodingDuration(HTMLImageElement&amp; element, float duration)
 852 {
 853     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 854         bitmapImage-&gt;setFrameDecodingDurationForTesting(Seconds { duration });
 855 }
 856 
 857 void Internals::resetImageAnimation(HTMLImageElement&amp; element)
 858 {
 859     if (auto* image = imageFromImageElement(element))
 860         image-&gt;resetAnimation();
 861 }
 862 
 863 bool Internals::isImageAnimating(HTMLImageElement&amp; element)
 864 {
 865     auto* image = imageFromImageElement(element);
 866     return image &amp;&amp; (image-&gt;isAnimating() || image-&gt;animationPending());
 867 }
 868 
 869 unsigned Internals::imagePendingDecodePromisesCountForTesting(HTMLImageElement&amp; element)
 870 {
 871     return element.pendingDecodePromisesCountForTesting();
 872 }
 873 
 874 void Internals::setClearDecoderAfterAsyncFrameRequestForTesting(HTMLImageElement&amp; element, bool enabled)
 875 {
 876     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 877         bitmapImage-&gt;setClearDecoderAfterAsyncFrameRequestForTesting(enabled);
 878 }
 879 
 880 unsigned Internals::imageDecodeCount(HTMLImageElement&amp; element)
 881 {
 882     auto* bitmapImage = bitmapImageFromImageElement(element);
 883     return bitmapImage ? bitmapImage-&gt;decodeCountForTesting() : 0;
 884 }
 885 
 886 unsigned Internals::pdfDocumentCachingCount(HTMLImageElement&amp; element)
 887 {
 888 #if USE(CG)
 889     auto* pdfDocumentImage = pdfDocumentImageFromImageElement(element);
 890     return pdfDocumentImage ? pdfDocumentImage-&gt;cachingCountForTesting() : 0;
 891 #else
 892     UNUSED_PARAM(element);
 893     return 0;
 894 #endif
 895 }
 896 
 897 void Internals::setLargeImageAsyncDecodingEnabledForTesting(HTMLImageElement&amp; element, bool enabled)
 898 {
 899     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 900         bitmapImage-&gt;setLargeImageAsyncDecodingEnabledForTesting(enabled);
 901 }
 902 
 903 void Internals::setForceUpdateImageDataEnabledForTesting(HTMLImageElement&amp; element, bool enabled)
 904 {
 905     if (auto* cachedImage = element.cachedImage())
 906         cachedImage-&gt;setForceUpdateImageDataEnabledForTesting(enabled);
 907 }
 908 
 909 void Internals::setGridMaxTracksLimit(unsigned maxTrackLimit)
 910 {
 911     GridPosition::setMaxPositionForTesting(maxTrackLimit);
 912 }
 913 
 914 void Internals::clearPageCache()
 915 {
 916     PageCache::singleton().pruneToSizeNow(0, PruningReason::None);
 917 }
 918 
 919 unsigned Internals::pageCacheSize() const
 920 {
 921     return PageCache::singleton().pageCount();
 922 }
 923 
 924 void Internals::disableTileSizeUpdateDelay()
 925 {
 926     Document* document = contextDocument();
 927     if (!document || !document-&gt;frame())
 928         return;
 929 
 930     auto* view = document-&gt;frame()-&gt;view();
 931     if (!view)
 932         return;
 933 
 934     if (auto* backing = view-&gt;tiledBacking())
 935         backing-&gt;setTileSizeUpdateDelayDisabledForTesting(true);
 936 }
 937 
 938 void Internals::setSpeculativeTilingDelayDisabledForTesting(bool disabled)
 939 {
 940     Document* document = contextDocument();
 941     if (!document || !document-&gt;frame())
 942         return;
 943 
 944     if (auto* frameView = document-&gt;frame()-&gt;view())
 945         frameView-&gt;setSpeculativeTilingDelayDisabledForTesting(disabled);
 946 }
 947 
 948 
 949 Node* Internals::treeScopeRootNode(Node&amp; node)
 950 {
 951     return &amp;node.treeScope().rootNode();
 952 }
 953 
 954 Node* Internals::parentTreeScope(Node&amp; node)
 955 {
 956     const TreeScope* parentTreeScope = node.treeScope().parentTreeScope();
 957     return parentTreeScope ? &amp;parentTreeScope-&gt;rootNode() : nullptr;
 958 }
 959 
 960 ExceptionOr&lt;unsigned&gt; Internals::lastSpatialNavigationCandidateCount() const
 961 {
 962     if (!contextDocument() || !contextDocument()-&gt;page())
 963         return Exception { InvalidAccessError };
 964 
 965     return contextDocument()-&gt;page()-&gt;lastSpatialNavigationCandidateCount();
 966 }
 967 
 968 unsigned Internals::numberOfActiveAnimations() const
 969 {
 970     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
 971         return frame()-&gt;document()-&gt;timeline().numberOfActiveAnimationsForTesting();
 972     return frame()-&gt;animation().numberOfActiveAnimations(frame()-&gt;document());
 973 }
 974 
 975 ExceptionOr&lt;bool&gt; Internals::animationsAreSuspended() const
 976 {
 977     Document* document = contextDocument();
 978     if (!document || !document-&gt;frame())
 979         return Exception { InvalidAccessError };
 980 
 981     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
 982         return document-&gt;timeline().animationsAreSuspended();
 983     return document-&gt;frame()-&gt;animation().animationsAreSuspendedForDocument(document);
 984 }
 985 
 986 double Internals::animationsInterval() const
 987 {
 988     Document* document = contextDocument();
 989     if (!document)
 990         return INFINITY;
 991 
 992     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
 993         if (auto timeline = document-&gt;existingTimeline())
 994             return timeline-&gt;animationInterval().seconds();
 995         return INFINITY;
 996     }
 997 
 998     if (!document-&gt;frame())
 999         return INFINITY;
1000     return document-&gt;frame()-&gt;animation().animationInterval().value();
1001 }
1002 
1003 ExceptionOr&lt;void&gt; Internals::suspendAnimations() const
1004 {
1005     Document* document = contextDocument();
1006     if (!document || !document-&gt;frame())
1007         return Exception { InvalidAccessError };
1008 
1009     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1010         document-&gt;timeline().suspendAnimations();
1011         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
1012             if (Document* document = frame-&gt;document())
1013                 document-&gt;timeline().suspendAnimations();
1014         }
1015     } else {
1016         document-&gt;frame()-&gt;animation().suspendAnimationsForDocument(document);
1017 
1018         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
1019             if (Document* document = frame-&gt;document())
1020                 frame-&gt;animation().suspendAnimationsForDocument(document);
1021         }
1022     }
1023 
1024     return { };
1025 }
1026 
1027 ExceptionOr&lt;void&gt; Internals::resumeAnimations() const
1028 {
1029     Document* document = contextDocument();
1030     if (!document || !document-&gt;frame())
1031         return Exception { InvalidAccessError };
1032 
1033     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1034         document-&gt;timeline().resumeAnimations();
1035         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
1036             if (Document* document = frame-&gt;document())
1037                 document-&gt;timeline().resumeAnimations();
1038         }
1039     } else {
1040         document-&gt;frame()-&gt;animation().resumeAnimationsForDocument(document);
1041 
1042         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
1043             if (Document* document = frame-&gt;document())
1044                 frame-&gt;animation().resumeAnimationsForDocument(document);
1045         }
1046     }
1047 
1048     return { };
1049 }
1050 
1051 ExceptionOr&lt;bool&gt; Internals::pauseAnimationAtTimeOnElement(const String&amp; animationName, double pauseTime, Element&amp; element)
1052 {
1053     if (pauseTime &lt; 0)
1054         return Exception { InvalidAccessError };
1055     return frame()-&gt;animation().pauseAnimationAtTime(element, AtomString(animationName), pauseTime);
1056 }
1057 
1058 ExceptionOr&lt;bool&gt; Internals::pauseAnimationAtTimeOnPseudoElement(const String&amp; animationName, double pauseTime, Element&amp; element, const String&amp; pseudoId)
1059 {
1060     if (pauseTime &lt; 0)
1061         return Exception { InvalidAccessError };
1062 
1063     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1064         return Exception { InvalidAccessError };
1065 
1066     PseudoElement* pseudoElement = pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1067     if (!pseudoElement)
1068         return Exception { InvalidAccessError };
1069 
1070     return frame()-&gt;animation().pauseAnimationAtTime(*pseudoElement, AtomString(animationName), pauseTime);
1071 }
1072 
1073 ExceptionOr&lt;bool&gt; Internals::pauseTransitionAtTimeOnElement(const String&amp; propertyName, double pauseTime, Element&amp; element)
1074 {
1075     if (pauseTime &lt; 0)
1076         return Exception { InvalidAccessError };
1077     return frame()-&gt;animation().pauseTransitionAtTime(element, propertyName, pauseTime);
1078 }
1079 
1080 ExceptionOr&lt;bool&gt; Internals::pauseTransitionAtTimeOnPseudoElement(const String&amp; property, double pauseTime, Element&amp; element, const String&amp; pseudoId)
1081 {
1082     if (pauseTime &lt; 0)
1083         return Exception { InvalidAccessError };
1084 
1085     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1086         return Exception { InvalidAccessError };
1087 
1088     PseudoElement* pseudoElement = pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1089     if (!pseudoElement)
1090         return Exception { InvalidAccessError };
1091 
1092     return frame()-&gt;animation().pauseTransitionAtTime(*pseudoElement, property, pauseTime);
1093 }
1094 
1095 Vector&lt;Internals::AcceleratedAnimation&gt; Internals::acceleratedAnimationsForElement(Element&amp; element)
1096 {
1097     if (!RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
1098         return { };
1099 
1100     Vector&lt;Internals::AcceleratedAnimation&gt; animations;
1101     for (const auto&amp; animationAsPair : element.document().timeline().acceleratedAnimationsForElement(element))
1102         animations.append({ animationAsPair.first, animationAsPair.second });
1103     return animations;
1104 }
1105 
1106 unsigned Internals::numberOfAnimationTimelineInvalidations() const
1107 {
1108     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
1109         return frame()-&gt;document()-&gt;timeline().numberOfAnimationTimelineInvalidationsForTesting();
1110     return 0;
1111 }
1112 
1113 ExceptionOr&lt;RefPtr&lt;Element&gt;&gt; Internals::pseudoElement(Element&amp; element, const String&amp; pseudoId)
1114 {
1115     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1116         return Exception { InvalidAccessError };
1117 
1118     return pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1119 }
1120 
1121 ExceptionOr&lt;String&gt; Internals::elementRenderTreeAsText(Element&amp; element)
1122 {
1123     element.document().updateStyleIfNeeded();
1124 
1125     String representation = externalRepresentation(&amp;element);
1126     if (representation.isEmpty())
1127         return Exception { InvalidAccessError };
1128 
1129     return representation;
1130 }
1131 
1132 bool Internals::hasPausedImageAnimations(Element&amp; element)
1133 {
1134     return element.renderer() &amp;&amp; element.renderer()-&gt;hasPausedImageAnimations();
1135 }
1136 
1137 bool Internals::isPaintingFrequently(Element&amp; element)
1138 {
1139     return element.renderer() &amp;&amp; element.renderer()-&gt;enclosingLayer() &amp;&amp; element.renderer()-&gt;enclosingLayer()-&gt;paintingFrequently();
1140 }
1141 
1142 void Internals::incrementFrequentPaintCounter(Element&amp; element)
1143 {
1144     if (element.renderer() &amp;&amp; element.renderer()-&gt;enclosingLayer())
1145         element.renderer()-&gt;enclosingLayer()-&gt;simulateFrequentPaint();
1146 }
1147 
1148 Ref&lt;CSSComputedStyleDeclaration&gt; Internals::computedStyleIncludingVisitedInfo(Element&amp; element) const
1149 {
1150     bool allowVisitedStyle = true;
1151     return CSSComputedStyleDeclaration::create(element, allowVisitedStyle);
1152 }
1153 
1154 Node* Internals::ensureUserAgentShadowRoot(Element&amp; host)
1155 {
1156     return &amp;host.ensureUserAgentShadowRoot();
1157 }
1158 
1159 Node* Internals::shadowRoot(Element&amp; host)
1160 {
1161     return host.shadowRoot();
1162 }
1163 
1164 ExceptionOr&lt;String&gt; Internals::shadowRootType(const Node&amp; root) const
1165 {
1166     if (!is&lt;ShadowRoot&gt;(root))
1167         return Exception { InvalidAccessError };
1168 
1169     switch (downcast&lt;ShadowRoot&gt;(root).mode()) {
1170     case ShadowRootMode::UserAgent:
1171         return &quot;UserAgentShadowRoot&quot;_str;
1172     case ShadowRootMode::Closed:
1173         return &quot;ClosedShadowRoot&quot;_str;
1174     case ShadowRootMode::Open:
1175         return &quot;OpenShadowRoot&quot;_str;
1176     default:
1177         ASSERT_NOT_REACHED();
1178         return &quot;Unknown&quot;_str;
1179     }
1180 }
1181 
1182 String Internals::shadowPseudoId(Element&amp; element)
1183 {
1184     return element.shadowPseudoId().string();
1185 }
1186 
1187 void Internals::setShadowPseudoId(Element&amp; element, const String&amp; id)
1188 {
1189     return element.setPseudo(id);
1190 }
1191 
1192 static unsigned deferredStyleRulesCountForList(const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules)
1193 {
1194     unsigned count = 0;
1195     for (auto rule : childRules) {
1196         if (is&lt;StyleRule&gt;(rule)) {
1197             auto* cssRule = downcast&lt;StyleRule&gt;(rule.get());
1198             if (!cssRule-&gt;propertiesWithoutDeferredParsing())
1199                 count++;
1200             continue;
1201         }
1202 
1203         StyleRuleGroup* groupRule = nullptr;
1204         if (is&lt;StyleRuleMedia&gt;(rule))
1205             groupRule = downcast&lt;StyleRuleMedia&gt;(rule.get());
1206         else if (is&lt;StyleRuleSupports&gt;(rule))
1207             groupRule = downcast&lt;StyleRuleSupports&gt;(rule.get());
1208         if (!groupRule)
1209             continue;
1210 
1211         auto* groupChildRules = groupRule-&gt;childRulesWithoutDeferredParsing();
1212         if (!groupChildRules)
1213             continue;
1214 
1215         count += deferredStyleRulesCountForList(*groupChildRules);
1216     }
1217 
1218     return count;
1219 }
1220 
1221 unsigned Internals::deferredStyleRulesCount(StyleSheet&amp; styleSheet)
1222 {
1223     return deferredStyleRulesCountForList(downcast&lt;CSSStyleSheet&gt;(styleSheet).contents().childRules());
1224 }
1225 
1226 static unsigned deferredGroupRulesCountForList(const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules)
1227 {
1228     unsigned count = 0;
1229     for (auto rule : childRules) {
1230         StyleRuleGroup* groupRule = nullptr;
1231         if (is&lt;StyleRuleMedia&gt;(rule))
1232             groupRule = downcast&lt;StyleRuleMedia&gt;(rule.get());
1233         else if (is&lt;StyleRuleSupports&gt;(rule))
1234             groupRule = downcast&lt;StyleRuleSupports&gt;(rule.get());
1235         if (!groupRule)
1236             continue;
1237 
1238         auto* groupChildRules = groupRule-&gt;childRulesWithoutDeferredParsing();
1239         if (!groupChildRules)
1240             count++;
1241         else
1242             count += deferredGroupRulesCountForList(*groupChildRules);
1243     }
1244     return count;
1245 }
1246 
1247 unsigned Internals::deferredGroupRulesCount(StyleSheet&amp; styleSheet)
1248 {
1249     return deferredGroupRulesCountForList(downcast&lt;CSSStyleSheet&gt;(styleSheet).contents().childRules());
1250 }
1251 
1252 static unsigned deferredKeyframesRulesCountForList(const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules)
1253 {
1254     unsigned count = 0;
1255     for (auto rule : childRules) {
1256         if (is&lt;StyleRuleKeyframes&gt;(rule)) {
1257             auto* cssRule = downcast&lt;StyleRuleKeyframes&gt;(rule.get());
1258             if (!cssRule-&gt;keyframesWithoutDeferredParsing())
1259                 count++;
1260             continue;
1261         }
1262 
1263         StyleRuleGroup* groupRule = nullptr;
1264         if (is&lt;StyleRuleMedia&gt;(rule))
1265             groupRule = downcast&lt;StyleRuleMedia&gt;(rule.get());
1266         else if (is&lt;StyleRuleSupports&gt;(rule))
1267             groupRule = downcast&lt;StyleRuleSupports&gt;(rule.get());
1268         if (!groupRule)
1269             continue;
1270 
1271         auto* groupChildRules = groupRule-&gt;childRulesWithoutDeferredParsing();
1272         if (!groupChildRules)
1273             continue;
1274 
1275         count += deferredKeyframesRulesCountForList(*groupChildRules);
1276     }
1277 
1278     return count;
1279 }
1280 
1281 unsigned Internals::deferredKeyframesRulesCount(StyleSheet&amp; styleSheet)
1282 {
1283     StyleSheetContents&amp; contents = downcast&lt;CSSStyleSheet&gt;(styleSheet).contents();
1284     return deferredKeyframesRulesCountForList(contents.childRules());
1285 }
1286 
1287 ExceptionOr&lt;bool&gt; Internals::isTimerThrottled(int timeoutId)
1288 {
1289     auto* timer = scriptExecutionContext()-&gt;findTimeout(timeoutId);
1290     if (!timer)
1291         return Exception { NotFoundError };
1292 
1293     if (timer-&gt;intervalClampedToMinimum() &gt; timer-&gt;m_originalInterval)
1294         return true;
1295 
1296     return !!timer-&gt;alignedFireTime(MonotonicTime { });
1297 }
1298 
1299 bool Internals::isRequestAnimationFrameThrottled() const
1300 {
1301     auto* scriptedAnimationController = contextDocument()-&gt;scriptedAnimationController();
1302     if (!scriptedAnimationController)
1303         return false;
1304     return scriptedAnimationController-&gt;isThrottled();
1305 }
1306 
1307 double Internals::requestAnimationFrameInterval() const
1308 {
1309     auto* scriptedAnimationController = contextDocument()-&gt;scriptedAnimationController();
1310     if (!scriptedAnimationController)
1311         return INFINITY;
1312     return scriptedAnimationController-&gt;interval().value();
1313 }
1314 
1315 bool Internals::scriptedAnimationsAreSuspended() const
1316 {
1317     Document* document = contextDocument();
1318     if (!document || !document-&gt;page())
1319         return true;
1320 
1321     return document-&gt;page()-&gt;scriptedAnimationsSuspended();
1322 }
1323 
1324 bool Internals::areTimersThrottled() const
1325 {
1326     return contextDocument()-&gt;isTimerThrottlingEnabled();
1327 }
1328 
1329 void Internals::setEventThrottlingBehaviorOverride(Optional&lt;EventThrottlingBehavior&gt; value)
1330 {
1331     Document* document = contextDocument();
1332     if (!document || !document-&gt;page())
1333         return;
1334 
1335     if (!value) {
1336         document-&gt;page()-&gt;setEventThrottlingBehaviorOverride(WTF::nullopt);
1337         return;
1338     }
1339 
1340     switch (value.value()) {
1341     case Internals::EventThrottlingBehavior::Responsive:
1342         document-&gt;page()-&gt;setEventThrottlingBehaviorOverride(WebCore::EventThrottlingBehavior::Responsive);
1343         break;
1344     case Internals::EventThrottlingBehavior::Unresponsive:
1345         document-&gt;page()-&gt;setEventThrottlingBehaviorOverride(WebCore::EventThrottlingBehavior::Unresponsive);
1346         break;
1347     }
1348 }
1349 
1350 Optional&lt;Internals::EventThrottlingBehavior&gt; Internals::eventThrottlingBehaviorOverride() const
1351 {
1352     Document* document = contextDocument();
1353     if (!document || !document-&gt;page())
1354         return WTF::nullopt;
1355 
1356     auto behavior = document-&gt;page()-&gt;eventThrottlingBehaviorOverride();
1357     if (!behavior)
1358         return WTF::nullopt;
1359 
1360     switch (behavior.value()) {
1361     case WebCore::EventThrottlingBehavior::Responsive:
1362         return Internals::EventThrottlingBehavior::Responsive;
1363     case WebCore::EventThrottlingBehavior::Unresponsive:
1364         return Internals::EventThrottlingBehavior::Unresponsive;
1365     }
1366 
1367     return WTF::nullopt;
1368 }
1369 
1370 String Internals::visiblePlaceholder(Element&amp; element)
1371 {
1372     if (is&lt;HTMLTextFormControlElement&gt;(element)) {
1373         const HTMLTextFormControlElement&amp; textFormControlElement = downcast&lt;HTMLTextFormControlElement&gt;(element);
1374         if (!textFormControlElement.isPlaceholderVisible())
1375             return String();
1376         if (HTMLElement* placeholderElement = textFormControlElement.placeholderElement())
1377             return placeholderElement-&gt;textContent();
1378     }
1379 
1380     return String();
1381 }
1382 
1383 void Internals::selectColorInColorChooser(HTMLInputElement&amp; element, const String&amp; colorValue)
1384 {
1385     element.selectColor(colorValue);
1386 }
1387 
1388 ExceptionOr&lt;Vector&lt;String&gt;&gt; Internals::formControlStateOfPreviousHistoryItem()
1389 {
1390     HistoryItem* mainItem = frame()-&gt;loader().history().previousItem();
1391     if (!mainItem)
1392         return Exception { InvalidAccessError };
1393     String uniqueName = frame()-&gt;tree().uniqueName();
1394     if (mainItem-&gt;target() != uniqueName &amp;&amp; !mainItem-&gt;childItemWithTarget(uniqueName))
1395         return Exception { InvalidAccessError };
1396     return Vector&lt;String&gt; { mainItem-&gt;target() == uniqueName ? mainItem-&gt;documentState() : mainItem-&gt;childItemWithTarget(uniqueName)-&gt;documentState() };
1397 }
1398 
1399 ExceptionOr&lt;void&gt; Internals::setFormControlStateOfPreviousHistoryItem(const Vector&lt;String&gt;&amp; state)
1400 {
1401     HistoryItem* mainItem = frame()-&gt;loader().history().previousItem();
1402     if (!mainItem)
1403         return Exception { InvalidAccessError };
1404     String uniqueName = frame()-&gt;tree().uniqueName();
1405     if (mainItem-&gt;target() == uniqueName)
1406         mainItem-&gt;setDocumentState(state);
1407     else if (HistoryItem* subItem = mainItem-&gt;childItemWithTarget(uniqueName))
1408         subItem-&gt;setDocumentState(state);
1409     else
1410         return Exception { InvalidAccessError };
1411     return { };
1412 }
1413 
1414 #if ENABLE(SPEECH_SYNTHESIS)
1415 
1416 void Internals::enableMockSpeechSynthesizer()
1417 {
1418     Document* document = contextDocument();
1419     if (!document || !document-&gt;domWindow())
1420         return;
1421     SpeechSynthesis* synthesis = DOMWindowSpeechSynthesis::speechSynthesis(*document-&gt;domWindow());
1422     if (!synthesis)
1423         return;
1424 
1425     synthesis-&gt;setPlatformSynthesizer(makeUnique&lt;PlatformSpeechSynthesizerMock&gt;(synthesis));
1426 }
1427 
1428 #endif
1429 
1430 #if ENABLE(WEB_RTC)
1431 
1432 void Internals::emulateRTCPeerConnectionPlatformEvent(RTCPeerConnection&amp; connection, const String&amp; action)
1433 {
1434     if (!LibWebRTCProvider::webRTCAvailable())
1435         return;
1436 
1437     connection.emulatePlatformEvent(action);
1438 }
1439 
1440 void Internals::useMockRTCPeerConnectionFactory(const String&amp; testCase)
1441 {
1442     ASSERT(RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled());
1443     if (!LibWebRTCProvider::webRTCAvailable())
1444         return;
1445 
1446 #if USE(LIBWEBRTC)
1447     Document* document = contextDocument();
1448     LibWebRTCProvider* provider = (document &amp;&amp; document-&gt;page()) ? &amp;document-&gt;page()-&gt;libWebRTCProvider() : nullptr;
1449     WebCore::useMockRTCPeerConnectionFactory(provider, testCase);
1450 #else
1451     UNUSED_PARAM(testCase);
1452 #endif
1453 }
1454 
1455 void Internals::setICECandidateFiltering(bool enabled)
1456 {
1457     auto* page = contextDocument()-&gt;page();
1458     if (!page)
1459         return;
1460 
1461     auto&amp; rtcController = page-&gt;rtcController();
1462     if (enabled)
1463         rtcController.enableICECandidateFiltering();
1464     else
1465         rtcController.disableICECandidateFilteringForAllOrigins();
1466 }
1467 
1468 void Internals::setEnumeratingAllNetworkInterfacesEnabled(bool enabled)
1469 {
1470 #if USE(LIBWEBRTC)
1471     Document* document = contextDocument();
1472     auto* page = document-&gt;page();
1473     if (!page)
1474         return;
1475     auto&amp; rtcProvider = page-&gt;libWebRTCProvider();
1476     if (enabled)
1477         rtcProvider.enableEnumeratingAllNetworkInterfaces();
1478     else
1479         rtcProvider.disableEnumeratingAllNetworkInterfaces();
1480 #else
1481     UNUSED_PARAM(enabled);
1482 #endif
1483 }
1484 
1485 void Internals::stopPeerConnection(RTCPeerConnection&amp; connection)
1486 {
1487     ActiveDOMObject&amp; object = connection;
1488     object.stop();
1489 }
1490 
1491 void Internals::clearPeerConnectionFactory()
1492 {
1493 #if USE(LIBWEBRTC)
1494     if (auto* page = contextDocument()-&gt;page())
1495         page-&gt;libWebRTCProvider().clearFactory();
1496 #endif
1497 }
1498 
1499 void Internals::applyRotationForOutgoingVideoSources(RTCPeerConnection&amp; connection)
1500 {
1501     connection.applyRotationForOutgoingVideoSources();
1502 }
1503 
1504 void Internals::setEnableWebRTCEncryption(bool value)
1505 {
1506 #if USE(LIBWEBRTC)
1507     if (auto* page = contextDocument()-&gt;page())
1508         page-&gt;settings().setWebRTCEncryptionEnabled(value);
1509 #endif
1510 }
1511 #endif
1512 
1513 #if ENABLE(MEDIA_STREAM)
1514 void Internals::setShouldInterruptAudioOnPageVisibilityChange(bool shouldInterrupt)
1515 {
1516     RuntimeEnabledFeatures::sharedFeatures().setInterruptAudioOnPageVisibilityChangeEnabled(shouldInterrupt);
1517 }
1518 
1519 void Internals::setMockMediaCaptureDevicesEnabled(bool enabled)
1520 {
1521     Document* document = contextDocument();
1522     if (auto* page = document-&gt;page())
1523         page-&gt;settings().setMockCaptureDevicesEnabled(enabled);
1524 }
1525 
1526 void Internals::setMediaCaptureRequiresSecureConnection(bool enabled)
1527 {
1528     Document* document = contextDocument();
1529     if (auto* page = document-&gt;page())
1530         page-&gt;settings().setMediaCaptureRequiresSecureConnection(enabled);
1531 }
1532 
1533 static std::unique_ptr&lt;MediaRecorderPrivate&gt; createRecorderMockSource()
1534 {
1535     return std::unique_ptr&lt;MediaRecorderPrivateMock&gt;(new MediaRecorderPrivateMock);
1536 }
1537 
1538 void Internals::setCustomPrivateRecorderCreator()
1539 {
1540     WebCore::MediaRecorder::setCustomPrivateRecorderCreator(createRecorderMockSource);
1541 }
1542 
1543 #endif
1544 
1545 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::absoluteCaretBounds()
1546 {
1547     Document* document = contextDocument();
1548     if (!document || !document-&gt;frame())
1549         return Exception { InvalidAccessError };
1550 
1551     return DOMRect::create(document-&gt;frame()-&gt;selection().absoluteCaretBounds());
1552 }
1553 
1554 ExceptionOr&lt;bool&gt; Internals::isCaretBlinkingSuspended()
1555 {
1556     Document* document = contextDocument();
1557     if (!document || !document-&gt;frame())
1558         return Exception { InvalidAccessError };
1559 
1560     return document-&gt;frame()-&gt;selection().isCaretBlinkingSuspended();
1561 }
1562 
1563 Ref&lt;DOMRect&gt; Internals::boundingBox(Element&amp; element)
1564 {
1565     element.document().updateLayoutIgnorePendingStylesheets();
1566     auto renderer = element.renderer();
1567     if (!renderer)
1568         return DOMRect::create();
1569     return DOMRect::create(renderer-&gt;absoluteBoundingBoxRectIgnoringTransforms());
1570 }
1571 
1572 ExceptionOr&lt;Ref&lt;DOMRectList&gt;&gt; Internals::inspectorHighlightRects()
1573 {
1574     Document* document = contextDocument();
1575     if (!document || !document-&gt;page())
1576         return Exception { InvalidAccessError };
1577 
1578     Highlight highlight;
1579     document-&gt;page()-&gt;inspectorController().getHighlight(highlight, InspectorOverlay::CoordinateSystem::View);
1580     return DOMRectList::create(highlight.quads);
1581 }
1582 
1583 ExceptionOr&lt;unsigned&gt; Internals::markerCountForNode(Node&amp; node, const String&amp; markerType)
1584 {
1585     OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes;
1586     if (!markerTypesFrom(markerType, markerTypes))
1587         return Exception { SyntaxError };
1588 
1589     node.document().frame()-&gt;editor().updateEditorUINowIfScheduled();
1590     return node.document().markers().markersFor(node, markerTypes).size();
1591 }
1592 
1593 ExceptionOr&lt;RenderedDocumentMarker*&gt; Internals::markerAt(Node&amp; node, const String&amp; markerType, unsigned index)
1594 {
1595     node.document().updateLayoutIgnorePendingStylesheets();
1596 
1597     OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes;
1598     if (!markerTypesFrom(markerType, markerTypes))
1599         return Exception { SyntaxError };
1600 
1601     node.document().frame()-&gt;editor().updateEditorUINowIfScheduled();
1602 
1603     Vector&lt;RenderedDocumentMarker*&gt; markers = node.document().markers().markersFor(node, markerTypes);
1604     if (markers.size() &lt;= index)
1605         return nullptr;
1606     return markers[index];
1607 }
1608 
1609 ExceptionOr&lt;RefPtr&lt;Range&gt;&gt; Internals::markerRangeForNode(Node&amp; node, const String&amp; markerType, unsigned index)
1610 {
1611     auto result = markerAt(node, markerType, index);
1612     if (result.hasException())
1613         return result.releaseException();
1614     auto marker = result.releaseReturnValue();
1615     if (!marker)
1616         return nullptr;
1617     return RefPtr&lt;Range&gt; { Range::create(node.document(), &amp;node, marker-&gt;startOffset(), &amp;node, marker-&gt;endOffset()) };
1618 }
1619 
1620 ExceptionOr&lt;String&gt; Internals::markerDescriptionForNode(Node&amp; node, const String&amp; markerType, unsigned index)
1621 {
1622     auto result = markerAt(node, markerType, index);
1623     if (result.hasException())
1624         return result.releaseException();
1625     auto marker = result.releaseReturnValue();
1626     if (!marker)
1627         return String();
1628     return String { marker-&gt;description() };
1629 }
1630 
1631 ExceptionOr&lt;String&gt; Internals::dumpMarkerRects(const String&amp; markerTypeString)
1632 {
1633     DocumentMarker::MarkerType markerType;
1634     if (!markerTypeFrom(markerTypeString, markerType))
1635         return Exception { SyntaxError };
1636 
1637     contextDocument()-&gt;markers().updateRectsForInvalidatedMarkersOfType(markerType);
1638     auto rects = contextDocument()-&gt;markers().renderedRectsForMarkers(markerType);
1639 
1640     StringBuilder rectString;
1641     rectString.appendLiteral(&quot;marker rects: &quot;);
1642     for (const auto&amp; rect : rects) {
1643         rectString.append(&#39;(&#39;);
1644         rectString.appendFixedPrecisionNumber(rect.x());
1645         rectString.appendLiteral(&quot;, &quot;);
1646         rectString.appendFixedPrecisionNumber(rect.y());
1647         rectString.appendLiteral(&quot;, &quot;);
1648         rectString.appendFixedPrecisionNumber(rect.width());
1649         rectString.appendLiteral(&quot;, &quot;);
1650         rectString.appendFixedPrecisionNumber(rect.height());
1651         rectString.appendLiteral(&quot;) &quot;);
1652     }
1653     return rectString.toString();
1654 }
1655 
1656 void Internals::addTextMatchMarker(const Range&amp; range, bool isActive)
1657 {
1658     range.ownerDocument().updateLayoutIgnorePendingStylesheets();
1659     range.ownerDocument().markers().addTextMatchMarker(range, isActive);
1660 }
1661 
1662 ExceptionOr&lt;void&gt; Internals::setMarkedTextMatchesAreHighlighted(bool flag)
1663 {
1664     Document* document = contextDocument();
1665     if (!document || !document-&gt;frame())
1666         return Exception { InvalidAccessError };
1667     document-&gt;frame()-&gt;editor().setMarkedTextMatchesAreHighlighted(flag);
1668     return { };
1669 }
1670 
1671 void Internals::invalidateFontCache()
1672 {
1673     FontCache::singleton().invalidate();
1674 }
1675 
1676 void Internals::setFontSmoothingEnabled(bool enabled)
1677 {
1678     FontCascade::setShouldUseSmoothing(enabled);
1679 }
1680 
1681 ExceptionOr&lt;void&gt; Internals::setLowPowerModeEnabled(bool isEnabled)
1682 {
1683     auto* document = contextDocument();
1684     if (!document)
1685         return Exception { InvalidAccessError };
1686     auto* page = document-&gt;page();
1687     if (!page)
1688         return Exception { InvalidAccessError };
1689 
1690     page-&gt;setLowPowerModeEnabledOverrideForTesting(isEnabled);
1691     return { };
1692 }
1693 
1694 ExceptionOr&lt;void&gt; Internals::setScrollViewPosition(int x, int y)
1695 {
1696     Document* document = contextDocument();
1697     if (!document || !document-&gt;view())
1698         return Exception { InvalidAccessError };
1699 
1700     auto&amp; frameView = *document-&gt;view();
1701     bool constrainsScrollingToContentEdgeOldValue = frameView.constrainsScrollingToContentEdge();
1702     bool scrollbarsSuppressedOldValue = frameView.scrollbarsSuppressed();
1703 
1704     frameView.setConstrainsScrollingToContentEdge(false);
1705     frameView.setScrollbarsSuppressed(false);
1706     frameView.setScrollOffsetFromInternals({ x, y });
1707     frameView.setScrollbarsSuppressed(scrollbarsSuppressedOldValue);
1708     frameView.setConstrainsScrollingToContentEdge(constrainsScrollingToContentEdgeOldValue);
1709 
1710     return { };
1711 }
1712 
1713 ExceptionOr&lt;void&gt; Internals::unconstrainedScrollTo(Element&amp; element, double x, double y)
1714 {
1715     Document* document = contextDocument();
1716     if (!document || !document-&gt;view())
1717         return Exception { InvalidAccessError };
1718 
1719     element.scrollTo({ x, y }, ScrollClamping::Unclamped);
1720     return { };
1721 }
1722 
1723 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::layoutViewportRect()
1724 {
1725     Document* document = contextDocument();
1726     if (!document || !document-&gt;frame())
1727         return Exception { InvalidAccessError };
1728 
1729     document-&gt;updateLayoutIgnorePendingStylesheets();
1730 
1731     auto&amp; frameView = *document-&gt;view();
1732     return DOMRect::create(frameView.layoutViewportRect());
1733 }
1734 
1735 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::visualViewportRect()
1736 {
1737     Document* document = contextDocument();
1738     if (!document || !document-&gt;frame())
1739         return Exception { InvalidAccessError };
1740 
1741     document-&gt;updateLayoutIgnorePendingStylesheets();
1742 
1743     auto&amp; frameView = *document-&gt;view();
1744     return DOMRect::create(frameView.visualViewportRect());
1745 }
1746 
1747 ExceptionOr&lt;void&gt; Internals::setViewIsTransparent(bool transparent)
1748 {
1749     Document* document = contextDocument();
1750     if (!document || !document-&gt;view())
1751         return Exception { InvalidAccessError };
1752     Optional&lt;Color&gt; backgroundColor;
1753     if (transparent)
1754         backgroundColor = Color(Color::transparent);
1755     document-&gt;view()-&gt;updateBackgroundRecursively(backgroundColor);
1756     return { };
1757 }
1758 
1759 ExceptionOr&lt;String&gt; Internals::viewBaseBackgroundColor()
1760 {
1761     Document* document = contextDocument();
1762     if (!document || !document-&gt;view())
1763         return Exception { InvalidAccessError };
1764     return document-&gt;view()-&gt;baseBackgroundColor().cssText();
1765 }
1766 
1767 ExceptionOr&lt;void&gt; Internals::setViewBaseBackgroundColor(const String&amp; colorValue)
1768 {
1769     Document* document = contextDocument();
1770     if (!document || !document-&gt;view())
1771         return Exception { InvalidAccessError };
1772 
1773     if (colorValue == &quot;transparent&quot;) {
1774         document-&gt;view()-&gt;setBaseBackgroundColor(Color::transparent);
1775         return { };
1776     }
1777     if (colorValue == &quot;white&quot;) {
1778         document-&gt;view()-&gt;setBaseBackgroundColor(Color::white);
1779         return { };
1780     }
1781     return Exception { SyntaxError };
1782 }
1783 
1784 ExceptionOr&lt;void&gt; Internals::setPagination(const String&amp; mode, int gap, int pageLength)
1785 {
1786     Document* document = contextDocument();
1787     if (!document || !document-&gt;page())
1788         return Exception { InvalidAccessError };
1789 
1790     Pagination pagination;
1791     if (mode == &quot;Unpaginated&quot;)
1792         pagination.mode = Pagination::Unpaginated;
1793     else if (mode == &quot;LeftToRightPaginated&quot;)
1794         pagination.mode = Pagination::LeftToRightPaginated;
1795     else if (mode == &quot;RightToLeftPaginated&quot;)
1796         pagination.mode = Pagination::RightToLeftPaginated;
1797     else if (mode == &quot;TopToBottomPaginated&quot;)
1798         pagination.mode = Pagination::TopToBottomPaginated;
1799     else if (mode == &quot;BottomToTopPaginated&quot;)
1800         pagination.mode = Pagination::BottomToTopPaginated;
1801     else
1802         return Exception { SyntaxError };
1803 
1804     pagination.gap = gap;
1805     pagination.pageLength = pageLength;
1806     document-&gt;page()-&gt;setPagination(pagination);
1807 
1808     return { };
1809 }
1810 
1811 ExceptionOr&lt;void&gt; Internals::setPaginationLineGridEnabled(bool enabled)
1812 {
1813     Document* document = contextDocument();
1814     if (!document || !document-&gt;page())
1815         return Exception { InvalidAccessError };
1816     document-&gt;page()-&gt;setPaginationLineGridEnabled(enabled);
1817     return { };
1818 }
1819 
1820 ExceptionOr&lt;String&gt; Internals::configurationForViewport(float devicePixelRatio, int deviceWidth, int deviceHeight, int availableWidth, int availableHeight)
1821 {
1822     Document* document = contextDocument();
1823     if (!document || !document-&gt;page())
1824         return Exception { InvalidAccessError };
1825 
1826     const int defaultLayoutWidthForNonMobilePages = 980;
1827 
1828     ViewportArguments arguments = document-&gt;page()-&gt;viewportArguments();
1829     ViewportAttributes attributes = computeViewportAttributes(arguments, defaultLayoutWidthForNonMobilePages, deviceWidth, deviceHeight, devicePixelRatio, IntSize(availableWidth, availableHeight));
1830     restrictMinimumScaleFactorToViewportSize(attributes, IntSize(availableWidth, availableHeight), devicePixelRatio);
1831     restrictScaleFactorToInitialScaleIfNotUserScalable(attributes);
1832 
1833     return makeString(&quot;viewport size &quot;, FormattedNumber::fixedPrecision(attributes.layoutSize.width()), &#39;x&#39;, FormattedNumber::fixedPrecision(attributes.layoutSize.height()), &quot; scale &quot;, FormattedNumber::fixedPrecision(attributes.initialScale), &quot; with limits [&quot;, FormattedNumber::fixedPrecision(attributes.minimumScale), &quot;, &quot;, FormattedNumber::fixedPrecision(attributes.maximumScale), &quot;] and userScalable &quot;, (attributes.userScalable ? &quot;true&quot; : &quot;false&quot;));
1834 }
1835 
1836 ExceptionOr&lt;bool&gt; Internals::wasLastChangeUserEdit(Element&amp; textField)
1837 {
1838     if (is&lt;HTMLInputElement&gt;(textField))
1839         return downcast&lt;HTMLInputElement&gt;(textField).lastChangeWasUserEdit();
1840 
1841     if (is&lt;HTMLTextAreaElement&gt;(textField))
1842         return downcast&lt;HTMLTextAreaElement&gt;(textField).lastChangeWasUserEdit();
1843 
1844     return Exception { InvalidNodeTypeError };
1845 }
1846 
1847 bool Internals::elementShouldAutoComplete(HTMLInputElement&amp; element)
1848 {
1849     return element.shouldAutocomplete();
1850 }
1851 
1852 void Internals::setAutofilled(HTMLInputElement&amp; element, bool enabled)
1853 {
1854     element.setAutoFilled(enabled);
1855 }
1856 
1857 void Internals::setAutoFilledAndViewable(HTMLInputElement&amp; element, bool enabled)
1858 {
1859     element.setAutoFilledAndViewable(enabled);
1860 }
1861 
1862 static AutoFillButtonType toAutoFillButtonType(Internals::AutoFillButtonType type)
1863 {
1864     switch (type) {
1865     case Internals::AutoFillButtonType::None:
1866         return AutoFillButtonType::None;
1867     case Internals::AutoFillButtonType::Credentials:
1868         return AutoFillButtonType::Credentials;
1869     case Internals::AutoFillButtonType::Contacts:
1870         return AutoFillButtonType::Contacts;
1871     case Internals::AutoFillButtonType::StrongPassword:
1872         return AutoFillButtonType::StrongPassword;
1873     case Internals::AutoFillButtonType::CreditCard:
1874         return AutoFillButtonType::CreditCard;
1875     }
1876     ASSERT_NOT_REACHED();
1877     return AutoFillButtonType::None;
1878 }
1879 
1880 static Internals::AutoFillButtonType toInternalsAutoFillButtonType(AutoFillButtonType type)
1881 {
1882     switch (type) {
1883     case AutoFillButtonType::None:
1884         return Internals::AutoFillButtonType::None;
1885     case AutoFillButtonType::Credentials:
1886         return Internals::AutoFillButtonType::Credentials;
1887     case AutoFillButtonType::Contacts:
1888         return Internals::AutoFillButtonType::Contacts;
1889     case AutoFillButtonType::StrongPassword:
1890         return Internals::AutoFillButtonType::StrongPassword;
1891     case AutoFillButtonType::CreditCard:
1892         return Internals::AutoFillButtonType::CreditCard;
1893     }
1894     ASSERT_NOT_REACHED();
1895     return Internals::AutoFillButtonType::None;
1896 }
1897 
1898 void Internals::setShowAutoFillButton(HTMLInputElement&amp; element, AutoFillButtonType type)
1899 {
1900     element.setShowAutoFillButton(toAutoFillButtonType(type));
1901 }
1902 
1903 auto Internals::autoFillButtonType(const HTMLInputElement&amp; element) -&gt; AutoFillButtonType
1904 {
1905     return toInternalsAutoFillButtonType(element.autoFillButtonType());
1906 }
1907 
1908 auto Internals::lastAutoFillButtonType(const HTMLInputElement&amp; element) -&gt; AutoFillButtonType
1909 {
1910     return toInternalsAutoFillButtonType(element.lastAutoFillButtonType());
1911 }
1912 
1913 ExceptionOr&lt;void&gt; Internals::scrollElementToRect(Element&amp; element, int x, int y, int w, int h)
1914 {
1915     FrameView* frameView = element.document().view();
1916     if (!frameView)
1917         return Exception { InvalidAccessError };
1918     frameView-&gt;scrollElementToRect(element, { x, y, w, h });
1919     return { };
1920 }
1921 
1922 ExceptionOr&lt;String&gt; Internals::autofillFieldName(Element&amp; element)
1923 {
1924     if (!is&lt;HTMLFormControlElement&gt;(element))
1925         return Exception { InvalidNodeTypeError };
1926 
1927     return String { downcast&lt;HTMLFormControlElement&gt;(element).autofillData().fieldName };
1928 }
1929 
1930 ExceptionOr&lt;void&gt; Internals::invalidateControlTints()
1931 {
1932     Document* document = contextDocument();
1933     if (!document || !document-&gt;view())
1934         return Exception { InvalidAccessError };
1935 
1936     document-&gt;view()-&gt;invalidateControlTints();
1937     return { };
1938 }
1939 
1940 RefPtr&lt;Range&gt; Internals::rangeFromLocationAndLength(Element&amp; scope, int rangeLocation, int rangeLength)
1941 {
1942     return TextIterator::rangeFromLocationAndLength(&amp;scope, rangeLocation, rangeLength);
1943 }
1944 
1945 unsigned Internals::locationFromRange(Element&amp; scope, const Range&amp; range)
1946 {
1947     size_t location = 0;
1948     size_t unusedLength = 0;
1949     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;range, location, unusedLength);
1950     return location;
1951 }
1952 
1953 unsigned Internals::lengthFromRange(Element&amp; scope, const Range&amp; range)
1954 {
1955     size_t unusedLocation = 0;
1956     size_t length = 0;
1957     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;range, unusedLocation, length);
1958     return length;
1959 }
1960 
1961 String Internals::rangeAsText(const Range&amp; range)
1962 {
1963     return range.text();
1964 }
1965 
1966 String Internals::rangeAsTextUsingBackwardsTextIterator(const Range&amp; range)
1967 {
1968     return plainTextUsingBackwardsTextIteratorForTesting(range);
1969 }
1970 
1971 Ref&lt;Range&gt; Internals::subrange(Range&amp; range, int rangeLocation, int rangeLength)
1972 {
1973     return TextIterator::subrange(range, rangeLocation, rangeLength);
1974 }
1975 
1976 RefPtr&lt;Range&gt; Internals::rangeOfStringNearLocation(const Range&amp; searchRange, const String&amp; text, unsigned targetOffset)
1977 {
1978     return findClosestPlainText(searchRange, text, { }, targetOffset);
1979 }
1980 
1981 #if !PLATFORM(MAC)
1982 ExceptionOr&lt;RefPtr&lt;Range&gt;&gt; Internals::rangeForDictionaryLookupAtLocation(int, int)
1983 {
1984     return Exception { InvalidAccessError };
1985 }
1986 #endif
1987 
1988 ExceptionOr&lt;void&gt; Internals::setDelegatesScrolling(bool enabled)
1989 {
1990     Document* document = contextDocument();
1991     // Delegate scrolling is valid only on mainframe&#39;s view.
1992     if (!document || !document-&gt;view() || !document-&gt;page() || &amp;document-&gt;page()-&gt;mainFrame() != document-&gt;frame())
1993         return Exception { InvalidAccessError };
1994 
1995     document-&gt;view()-&gt;setDelegatesScrolling(enabled);
1996     return { };
1997 }
1998 
1999 ExceptionOr&lt;int&gt; Internals::lastSpellCheckRequestSequence()
2000 {
2001     Document* document = contextDocument();
2002     if (!document || !document-&gt;frame())
2003         return Exception { InvalidAccessError };
2004 
2005     return document-&gt;frame()-&gt;editor().spellChecker().lastRequestSequence();
2006 }
2007 
2008 ExceptionOr&lt;int&gt; Internals::lastSpellCheckProcessedSequence()
2009 {
2010     Document* document = contextDocument();
2011     if (!document || !document-&gt;frame())
2012         return Exception { InvalidAccessError };
2013 
2014     return document-&gt;frame()-&gt;editor().spellChecker().lastProcessedSequence();
2015 }
2016 
2017 Vector&lt;String&gt; Internals::userPreferredLanguages() const
2018 {
2019     return WTF::userPreferredLanguages();
2020 }
2021 
2022 void Internals::setUserPreferredLanguages(const Vector&lt;String&gt;&amp; languages)
2023 {
2024     overrideUserPreferredLanguages(languages);
2025 }
2026 
2027 Vector&lt;String&gt; Internals::userPreferredAudioCharacteristics() const
2028 {
2029     Document* document = contextDocument();
2030     if (!document || !document-&gt;page())
2031         return Vector&lt;String&gt;();
2032 #if ENABLE(VIDEO_TRACK)
2033     return document-&gt;page()-&gt;group().captionPreferences().preferredAudioCharacteristics();
2034 #else
2035     return Vector&lt;String&gt;();
2036 #endif
2037 }
2038 
2039 void Internals::setUserPreferredAudioCharacteristic(const String&amp; characteristic)
2040 {
2041     Document* document = contextDocument();
2042     if (!document || !document-&gt;page())
2043         return;
2044 #if ENABLE(VIDEO_TRACK)
2045     document-&gt;page()-&gt;group().captionPreferences().setPreferredAudioCharacteristic(characteristic);
2046 #else
2047     UNUSED_PARAM(characteristic);
2048 #endif
2049 }
2050 
2051 ExceptionOr&lt;unsigned&gt; Internals::wheelEventHandlerCount()
2052 {
2053     Document* document = contextDocument();
2054     if (!document)
2055         return Exception { InvalidAccessError };
2056 
2057     return document-&gt;wheelEventHandlerCount();
2058 }
2059 
2060 ExceptionOr&lt;unsigned&gt; Internals::touchEventHandlerCount()
2061 {
2062     Document* document = contextDocument();
2063     if (!document)
2064         return Exception { InvalidAccessError };
2065 
2066     return document-&gt;touchEventHandlerCount();
2067 }
2068 
2069 ExceptionOr&lt;Ref&lt;DOMRectList&gt;&gt; Internals::touchEventRectsForEvent(const String&amp; eventName)
2070 {
2071     Document* document = contextDocument();
2072     if (!document || !document-&gt;page())
2073         return Exception { InvalidAccessError };
2074 
2075     return document-&gt;page()-&gt;touchEventRectsForEvent(eventName);
2076 }
2077 
2078 ExceptionOr&lt;Ref&lt;DOMRectList&gt;&gt; Internals::passiveTouchEventListenerRects()
2079 {
2080     Document* document = contextDocument();
2081     if (!document || !document-&gt;page())
2082         return Exception { InvalidAccessError };
2083 
2084     return document-&gt;page()-&gt;passiveTouchEventListenerRects();
2085 }
2086 
2087 // FIXME: Remove the document argument. It is almost always the same as
2088 // contextDocument(), with the exception of a few tests that pass a
2089 // different document, and could just make the call through another Internals
2090 // instance instead.
2091 ExceptionOr&lt;RefPtr&lt;NodeList&gt;&gt; Internals::nodesFromRect(Document&amp; document, int centerX, int centerY, unsigned topPadding, unsigned rightPadding, unsigned bottomPadding, unsigned leftPadding, bool ignoreClipping, bool allowUserAgentShadowContent, bool allowChildFrameContent) const
2092 {
2093     if (!document.frame() || !document.frame()-&gt;view())
2094         return Exception { InvalidAccessError };
2095 
2096     Frame* frame = document.frame();
2097     FrameView* frameView = document.view();
2098     RenderView* renderView = document.renderView();
2099     if (!renderView)
2100         return nullptr;
2101 
2102     document.updateLayoutIgnorePendingStylesheets();
2103 
2104     float zoomFactor = frame-&gt;pageZoomFactor();
2105     LayoutPoint point(centerX * zoomFactor + frameView-&gt;scrollX(), centerY * zoomFactor + frameView-&gt;scrollY());
2106 
2107     HitTestRequest::HitTestRequestType hitType = HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::CollectMultipleElements;
2108     if (ignoreClipping)
2109         hitType |= HitTestRequest::IgnoreClipping;
2110     if (!allowUserAgentShadowContent)
2111         hitType |= HitTestRequest::DisallowUserAgentShadowContent;
2112     if (allowChildFrameContent)
2113         hitType |= HitTestRequest::AllowChildFrameContent;
2114 
2115     HitTestRequest request(hitType);
2116 
2117     // When ignoreClipping is false, this method returns null for coordinates outside of the viewport.
2118     if (!request.ignoreClipping() &amp;&amp; !frameView-&gt;visibleContentRect().intersects(HitTestLocation::rectForPoint(point, topPadding, rightPadding, bottomPadding, leftPadding)))
2119         return nullptr;
2120 
2121     HitTestResult result(point, topPadding, rightPadding, bottomPadding, leftPadding);
2122     document.hitTest(request, result);
2123     const HitTestResult::NodeSet&amp; nodeSet = result.listBasedTestResult();
2124     Vector&lt;Ref&lt;Node&gt;&gt; matches;
2125     matches.reserveInitialCapacity(nodeSet.size());
2126     for (auto&amp; node : nodeSet)
2127         matches.uncheckedAppend(*node);
2128 
2129     return RefPtr&lt;NodeList&gt; { StaticNodeList::create(WTFMove(matches)) };
2130 }
2131 
2132 class GetCallerCodeBlockFunctor {
2133 public:
2134     GetCallerCodeBlockFunctor()
2135         : m_iterations(0)
2136         , m_codeBlock(0)
2137     {
2138     }
2139 
2140     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
2141     {
2142         ++m_iterations;
2143         if (m_iterations &lt; 2)
2144             return StackVisitor::Continue;
2145 
2146         m_codeBlock = visitor-&gt;codeBlock();
2147         return StackVisitor::Done;
2148     }
2149 
2150     CodeBlock* codeBlock() const { return m_codeBlock; }
2151 
2152 private:
2153     mutable int m_iterations;
2154     mutable CodeBlock* m_codeBlock;
2155 };
2156 
2157 String Internals::parserMetaData(JSC::JSValue code)
2158 {
2159     JSC::VM&amp; vm = contextDocument()-&gt;vm();
2160     JSC::ExecState* exec = vm.topCallFrame;
2161     ScriptExecutable* executable;
2162 
2163     if (!code || code.isNull() || code.isUndefined()) {
2164         GetCallerCodeBlockFunctor iter;
2165         exec-&gt;iterate(iter);
2166         CodeBlock* codeBlock = iter.codeBlock();
2167         executable = codeBlock-&gt;ownerExecutable();
2168     } else if (code.isFunction(vm)) {
2169         JSFunction* funcObj = JSC::jsCast&lt;JSFunction*&gt;(code.toObject(exec));
2170         executable = funcObj-&gt;jsExecutable();
2171     } else
2172         return String();
2173 
2174     unsigned startLine = executable-&gt;firstLine();
2175     unsigned startColumn = executable-&gt;startColumn();
2176     unsigned endLine = executable-&gt;lastLine();
2177     unsigned endColumn = executable-&gt;endColumn();
2178 
2179     StringBuilder result;
2180 
2181     if (executable-&gt;isFunctionExecutable()) {
2182         FunctionExecutable* funcExecutable = reinterpret_cast&lt;FunctionExecutable*&gt;(executable);
2183         String inferredName = funcExecutable-&gt;ecmaName().string();
2184         result.appendLiteral(&quot;function \&quot;&quot;);
2185         result.append(inferredName);
2186         result.append(&#39;&quot;&#39;);
2187     } else if (executable-&gt;isEvalExecutable())
2188         result.appendLiteral(&quot;eval&quot;);
2189     else if (executable-&gt;isModuleProgramExecutable())
2190         result.appendLiteral(&quot;module&quot;);
2191     else if (executable-&gt;isProgramExecutable())
2192         result.appendLiteral(&quot;program&quot;);
2193     else
2194         ASSERT_NOT_REACHED();
2195 
2196     result.appendLiteral(&quot; { &quot;);
2197     result.appendNumber(startLine);
2198     result.append(&#39;:&#39;);
2199     result.appendNumber(startColumn);
2200     result.appendLiteral(&quot; - &quot;);
2201     result.appendNumber(endLine);
2202     result.append(&#39;:&#39;);
2203     result.appendNumber(endColumn);
2204     result.appendLiteral(&quot; }&quot;);
2205 
2206     return result.toString();
2207 }
2208 
2209 void Internals::updateEditorUINowIfScheduled()
2210 {
2211     if (Document* document = contextDocument()) {
2212         if (Frame* frame = document-&gt;frame())
2213             frame-&gt;editor().updateEditorUINowIfScheduled();
2214     }
2215 }
2216 
2217 bool Internals::hasSpellingMarker(int from, int length)
2218 {
2219     Document* document = contextDocument();
2220     if (!document || !document-&gt;frame())
2221         return false;
2222 
2223     updateEditorUINowIfScheduled();
2224 
2225     return document-&gt;frame()-&gt;editor().selectionStartHasMarkerFor(DocumentMarker::Spelling, from, length);
2226 }
2227 
2228 bool Internals::hasAutocorrectedMarker(int from, int length)
2229 {
2230     Document* document = contextDocument();
2231     if (!document || !document-&gt;frame())
2232         return false;
2233 
2234     updateEditorUINowIfScheduled();
2235 
2236     return document-&gt;frame()-&gt;editor().selectionStartHasMarkerFor(DocumentMarker::Autocorrected, from, length);
2237 }
2238 
2239 void Internals::setContinuousSpellCheckingEnabled(bool enabled)
2240 {
2241     if (!contextDocument() || !contextDocument()-&gt;frame())
2242         return;
2243 
2244     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isContinuousSpellCheckingEnabled())
2245         contextDocument()-&gt;frame()-&gt;editor().toggleContinuousSpellChecking();
2246 }
2247 
2248 void Internals::setAutomaticQuoteSubstitutionEnabled(bool enabled)
2249 {
2250     if (!contextDocument() || !contextDocument()-&gt;frame())
2251         return;
2252 
2253 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2254     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticQuoteSubstitutionEnabled())
2255         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticQuoteSubstitution();
2256 #else
2257     UNUSED_PARAM(enabled);
2258 #endif
2259 }
2260 
2261 void Internals::setAutomaticLinkDetectionEnabled(bool enabled)
2262 {
2263     if (!contextDocument() || !contextDocument()-&gt;frame())
2264         return;
2265 
2266 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2267     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticLinkDetectionEnabled())
2268         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticLinkDetection();
2269 #else
2270     UNUSED_PARAM(enabled);
2271 #endif
2272 }
2273 
2274 bool Internals::testProcessIncomingSyncMessagesWhenWaitingForSyncReply()
2275 {
2276     ASSERT(contextDocument());
2277     ASSERT(contextDocument()-&gt;page());
2278     return contextDocument()-&gt;page()-&gt;chrome().client().testProcessIncomingSyncMessagesWhenWaitingForSyncReply();
2279 }
2280 
2281 void Internals::setAutomaticDashSubstitutionEnabled(bool enabled)
2282 {
2283     if (!contextDocument() || !contextDocument()-&gt;frame())
2284         return;
2285 
2286 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2287     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticDashSubstitutionEnabled())
2288         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticDashSubstitution();
2289 #else
2290     UNUSED_PARAM(enabled);
2291 #endif
2292 }
2293 
2294 void Internals::setAutomaticTextReplacementEnabled(bool enabled)
2295 {
2296     if (!contextDocument() || !contextDocument()-&gt;frame())
2297         return;
2298 
2299 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2300     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticTextReplacementEnabled())
2301         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticTextReplacement();
2302 #else
2303     UNUSED_PARAM(enabled);
2304 #endif
2305 }
2306 
2307 void Internals::setAutomaticSpellingCorrectionEnabled(bool enabled)
2308 {
2309     if (!contextDocument() || !contextDocument()-&gt;frame())
2310         return;
2311 
2312 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2313     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticSpellingCorrectionEnabled())
2314         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticSpellingCorrection();
2315 #else
2316     UNUSED_PARAM(enabled);
2317 #endif
2318 }
2319 
2320 void Internals::handleAcceptedCandidate(const String&amp; candidate, unsigned location, unsigned length)
2321 {
2322     if (!contextDocument() || !contextDocument()-&gt;frame())
2323         return;
2324 
2325     TextCheckingResult result;
2326     result.type = TextCheckingType::None;
2327     result.location = location;
2328     result.length = length;
2329     result.replacement = candidate;
2330     contextDocument()-&gt;frame()-&gt;editor().handleAcceptedCandidate(result);
2331 }
2332 
2333 void Internals::changeSelectionListType()
2334 {
2335     if (auto frame = makeRefPtr(this-&gt;frame()))
2336         frame-&gt;editor().changeSelectionListType();
2337 }
2338 
2339 bool Internals::isOverwriteModeEnabled()
2340 {
2341     Document* document = contextDocument();
2342     if (!document || !document-&gt;frame())
2343         return false;
2344 
2345     return document-&gt;frame()-&gt;editor().isOverwriteModeEnabled();
2346 }
2347 
2348 void Internals::toggleOverwriteModeEnabled()
2349 {
2350     Document* document = contextDocument();
2351     if (!document || !document-&gt;frame())
2352         return;
2353 
2354     document-&gt;frame()-&gt;editor().toggleOverwriteModeEnabled();
2355 }
2356 
2357 static ExceptionOr&lt;FindOptions&gt; parseFindOptions(const Vector&lt;String&gt;&amp; optionList)
2358 {
2359     const struct {
2360         const char* name;
2361         FindOptionFlag value;
2362     } flagList[] = {
2363         {&quot;CaseInsensitive&quot;, CaseInsensitive},
2364         {&quot;AtWordStarts&quot;, AtWordStarts},
2365         {&quot;TreatMedialCapitalAsWordStart&quot;, TreatMedialCapitalAsWordStart},
2366         {&quot;Backwards&quot;, Backwards},
2367         {&quot;WrapAround&quot;, WrapAround},
2368         {&quot;StartInSelection&quot;, StartInSelection},
2369         {&quot;DoNotRevealSelection&quot;, DoNotRevealSelection},
2370         {&quot;AtWordEnds&quot;, AtWordEnds},
2371         {&quot;DoNotTraverseFlatTree&quot;, DoNotTraverseFlatTree},
2372     };
2373     FindOptions result;
2374     for (auto&amp; option : optionList) {
2375         bool found = false;
2376         for (auto&amp; flag : flagList) {
2377             if (flag.name == option) {
2378                 result.add(flag.value);
2379                 found = true;
2380                 break;
2381             }
2382         }
2383         if (!found)
2384             return Exception { SyntaxError };
2385     }
2386     return result;
2387 }
2388 
2389 ExceptionOr&lt;RefPtr&lt;Range&gt;&gt; Internals::rangeOfString(const String&amp; text, RefPtr&lt;Range&gt;&amp;&amp; referenceRange, const Vector&lt;String&gt;&amp; findOptions)
2390 {
2391     Document* document = contextDocument();
2392     if (!document || !document-&gt;frame())
2393         return Exception { InvalidAccessError };
2394 
2395     auto parsedOptions = parseFindOptions(findOptions);
2396     if (parsedOptions.hasException())
2397         return parsedOptions.releaseException();
2398 
2399     return document-&gt;frame()-&gt;editor().rangeOfString(text, referenceRange.get(), parsedOptions.releaseReturnValue());
2400 }
2401 
2402 ExceptionOr&lt;unsigned&gt; Internals::countMatchesForText(const String&amp; text, const Vector&lt;String&gt;&amp; findOptions, const String&amp; markMatches)
2403 {
2404     Document* document = contextDocument();
2405     if (!document || !document-&gt;frame())
2406         return Exception { InvalidAccessError };
2407 
2408     auto parsedOptions = parseFindOptions(findOptions);
2409     if (parsedOptions.hasException())
2410         return parsedOptions.releaseException();
2411 
2412     bool mark = markMatches == &quot;mark&quot;;
2413     return document-&gt;frame()-&gt;editor().countMatchesForText(text, nullptr, parsedOptions.releaseReturnValue(), 1000, mark, nullptr);
2414 }
2415 
2416 ExceptionOr&lt;unsigned&gt; Internals::countFindMatches(const String&amp; text, const Vector&lt;String&gt;&amp; findOptions)
2417 {
2418     Document* document = contextDocument();
2419     if (!document || !document-&gt;page())
2420         return Exception { InvalidAccessError };
2421 
2422     auto parsedOptions = parseFindOptions(findOptions);
2423     if (parsedOptions.hasException())
2424         return parsedOptions.releaseException();
2425 
2426     return document-&gt;page()-&gt;countFindMatches(text, parsedOptions.releaseReturnValue(), 1000);
2427 }
2428 
2429 #if ENABLE(INDEXED_DATABASE)
2430 unsigned Internals::numberOfIDBTransactions() const
2431 {
2432     return IDBTransaction::numberOfIDBTransactions;
2433 }
2434 #endif
2435 
2436 unsigned Internals::numberOfLiveNodes() const
2437 {
2438     unsigned nodeCount = 0;
2439     for (auto* document : Document::allDocuments())
2440         nodeCount += document-&gt;referencingNodeCount();
2441     return nodeCount;
2442 }
2443 
2444 unsigned Internals::numberOfLiveDocuments() const
2445 {
2446     return Document::allDocuments().size();
2447 }
2448 
2449 unsigned Internals::referencingNodeCount(const Document&amp; document) const
2450 {
2451     return document.referencingNodeCount();
2452 }
2453 
2454 #if ENABLE(INTERSECTION_OBSERVER)
2455 unsigned Internals::numberOfIntersectionObservers(const Document&amp; document) const
2456 {
2457     return document.numberOfIntersectionObservers();
2458 }
2459 #endif
2460 
2461 uint64_t Internals::documentIdentifier(const Document&amp; document) const
2462 {
2463     return document.identifier().toUInt64();
2464 }
2465 
2466 bool Internals::isDocumentAlive(uint64_t documentIdentifier) const
2467 {
2468     return Document::allDocumentsMap().contains(makeObjectIdentifier&lt;DocumentIdentifierType&gt;(documentIdentifier));
2469 }
2470 
2471 bool Internals::isAnyWorkletGlobalScopeAlive() const
2472 {
2473 #if ENABLE(CSS_PAINTING_API)
2474     return !WorkletGlobalScope::allWorkletGlobalScopesSet().isEmpty();
2475 #else
2476     return false;
2477 #endif
2478 }
2479 
2480 String Internals::serviceWorkerClientIdentifier(const Document&amp; document) const
2481 {
2482 #if ENABLE(SERVICE_WORKER)
2483     return ServiceWorkerClientIdentifier { ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(document.sessionID()).serverConnectionIdentifier(), document.identifier() }.toString();
2484 #else
2485     UNUSED_PARAM(document);
2486     return String();
2487 #endif
2488 }
2489 
2490 RefPtr&lt;WindowProxy&gt; Internals::openDummyInspectorFrontend(const String&amp; url)
2491 {
2492     auto* inspectedPage = contextDocument()-&gt;frame()-&gt;page();
2493     auto* window = inspectedPage-&gt;mainFrame().document()-&gt;domWindow();
2494     auto frontendWindowProxy = window-&gt;open(*window, *window, url, &quot;&quot;, &quot;&quot;).releaseReturnValue();
2495     m_inspectorFrontend = makeUnique&lt;InspectorStubFrontend&gt;(*inspectedPage, downcast&lt;DOMWindow&gt;(frontendWindowProxy-&gt;window()));
2496     return frontendWindowProxy;
2497 }
2498 
2499 void Internals::closeDummyInspectorFrontend()
2500 {
2501     m_inspectorFrontend = nullptr;
2502 }
2503 
2504 ExceptionOr&lt;void&gt; Internals::setInspectorIsUnderTest(bool isUnderTest)
2505 {
2506     Page* page = contextDocument()-&gt;frame()-&gt;page();
2507     if (!page)
2508         return Exception { InvalidAccessError };
2509 
2510     page-&gt;inspectorController().setIsUnderTest(isUnderTest);
2511     return { };
2512 }
2513 
2514 bool Internals::hasGrammarMarker(int from, int length)
2515 {
2516     Document* document = contextDocument();
2517     if (!document || !document-&gt;frame())
2518         return false;
2519 
2520     return document-&gt;frame()-&gt;editor().selectionStartHasMarkerFor(DocumentMarker::Grammar, from, length);
2521 }
2522 
2523 unsigned Internals::numberOfScrollableAreas()
2524 {
2525     Document* document = contextDocument();
2526     if (!document || !document-&gt;frame())
2527         return 0;
2528 
2529     unsigned count = 0;
2530     Frame* frame = document-&gt;frame();
2531     if (frame-&gt;view()-&gt;scrollableAreas())
2532         count += frame-&gt;view()-&gt;scrollableAreas()-&gt;size();
2533 
2534     for (Frame* child = frame-&gt;tree().firstChild(); child; child = child-&gt;tree().nextSibling()) {
2535         if (child-&gt;view() &amp;&amp; child-&gt;view()-&gt;scrollableAreas())
2536             count += child-&gt;view()-&gt;scrollableAreas()-&gt;size();
2537     }
2538 
2539     return count;
2540 }
2541 
2542 ExceptionOr&lt;bool&gt; Internals::isPageBoxVisible(int pageNumber)
2543 {
2544     Document* document = contextDocument();
2545     if (!document)
2546         return Exception { InvalidAccessError };
2547 
2548     return document-&gt;isPageBoxVisible(pageNumber);
2549 }
2550 
2551 static LayerTreeFlags toLayerTreeFlags(unsigned short flags)
2552 {
2553     LayerTreeFlags layerTreeFlags = 0;
2554     if (flags &amp; Internals::LAYER_TREE_INCLUDES_VISIBLE_RECTS)
2555         layerTreeFlags |= LayerTreeFlagsIncludeVisibleRects;
2556     if (flags &amp; Internals::LAYER_TREE_INCLUDES_TILE_CACHES)
2557         layerTreeFlags |= LayerTreeFlagsIncludeTileCaches;
2558     if (flags &amp; Internals::LAYER_TREE_INCLUDES_REPAINT_RECTS)
2559         layerTreeFlags |= LayerTreeFlagsIncludeRepaintRects;
2560     if (flags &amp; Internals::LAYER_TREE_INCLUDES_PAINTING_PHASES)
2561         layerTreeFlags |= LayerTreeFlagsIncludePaintingPhases;
2562     if (flags &amp; Internals::LAYER_TREE_INCLUDES_CONTENT_LAYERS)
2563         layerTreeFlags |= LayerTreeFlagsIncludeContentLayers;
2564     if (flags &amp; Internals::LAYER_TREE_INCLUDES_ACCELERATES_DRAWING)
2565         layerTreeFlags |= LayerTreeFlagsIncludeAcceleratesDrawing;
2566     if (flags &amp; Internals::LAYER_TREE_INCLUDES_CLIPPING)
2567         layerTreeFlags |= LayerTreeFlagsIncludeClipping;
2568     if (flags &amp; Internals::LAYER_TREE_INCLUDES_BACKING_STORE_ATTACHED)
2569         layerTreeFlags |= LayerTreeFlagsIncludeBackingStoreAttached;
2570     if (flags &amp; Internals::LAYER_TREE_INCLUDES_ROOT_LAYER_PROPERTIES)
2571         layerTreeFlags |= LayerTreeFlagsIncludeRootLayerProperties;
2572     if (flags &amp; Internals::LAYER_TREE_INCLUDES_EVENT_REGION)
2573         layerTreeFlags |= LayerTreeFlagsIncludeEventRegion;
2574 
2575     return layerTreeFlags;
2576 }
2577 
2578 // FIXME: Remove the document argument. It is almost always the same as
2579 // contextDocument(), with the exception of a few tests that pass a
2580 // different document, and could just make the call through another Internals
2581 // instance instead.
2582 ExceptionOr&lt;String&gt; Internals::layerTreeAsText(Document&amp; document, unsigned short flags) const
2583 {
2584     if (!document.frame())
2585         return Exception { InvalidAccessError };
2586 
2587     document.updateLayoutIgnorePendingStylesheets();
2588     return document.frame()-&gt;layerTreeAsText(toLayerTreeFlags(flags));
2589 }
2590 
2591 ExceptionOr&lt;uint64_t&gt; Internals::layerIDForElement(Element&amp; element)
2592 {
2593     Document* document = contextDocument();
2594     if (!document || !document-&gt;frame())
2595         return Exception { InvalidAccessError };
2596 
2597     element.document().updateLayoutIgnorePendingStylesheets();
2598 
2599     if (!element.renderer() || !element.renderer()-&gt;hasLayer())
2600         return Exception { NotFoundError };
2601 
2602     auto&amp; layerModelObject = downcast&lt;RenderLayerModelObject&gt;(*element.renderer());
2603     if (!layerModelObject.layer()-&gt;isComposited())
2604         return Exception { NotFoundError };
2605 
2606     auto* backing = layerModelObject.layer()-&gt;backing();
2607     return backing-&gt;graphicsLayer()-&gt;primaryLayerID();
2608 }
2609 
2610 ExceptionOr&lt;String&gt; Internals::repaintRectsAsText() const
2611 {
2612     Document* document = contextDocument();
2613     if (!document || !document-&gt;frame())
2614         return Exception { InvalidAccessError };
2615 
2616     return document-&gt;frame()-&gt;trackedRepaintRectsAsText();
2617 }
2618 
2619 ExceptionOr&lt;String&gt; Internals::scrollbarOverlayStyle(Node* node) const
2620 {
2621     if (!node)
2622         node = contextDocument();
2623 
2624     if (!node)
2625         return Exception { InvalidAccessError };
2626 
2627     node-&gt;document().updateLayoutIgnorePendingStylesheets();
2628 
2629     ScrollableArea* scrollableArea = nullptr;
2630     if (is&lt;Document&gt;(*node)) {
2631         auto* frameView = downcast&lt;Document&gt;(node)-&gt;view();
2632         if (!frameView)
2633             return Exception { InvalidAccessError };
2634 
2635         scrollableArea = frameView;
2636     } else if (is&lt;Element&gt;(*node)) {
2637         auto&amp; element = *downcast&lt;Element&gt;(node);
2638         if (!element.renderBox())
2639             return Exception { InvalidAccessError };
2640 
2641         scrollableArea = element.renderBox()-&gt;layer();
2642     } else
2643         return Exception { InvalidNodeTypeError };
2644 
2645     if (!scrollableArea)
2646         return Exception { InvalidNodeTypeError };
2647 
2648     switch (scrollableArea-&gt;scrollbarOverlayStyle()) {
2649     case ScrollbarOverlayStyleDefault:
2650         return &quot;default&quot;_str;
2651     case ScrollbarOverlayStyleDark:
2652         return &quot;dark&quot;_str;
2653     case ScrollbarOverlayStyleLight:
2654         return &quot;light&quot;_str;
2655     }
2656 
2657     ASSERT_NOT_REACHED();
2658     return &quot;unknown&quot;_str;
2659 }
2660 
2661 ExceptionOr&lt;bool&gt; Internals::scrollbarUsingDarkAppearance(Node* node) const
2662 {
2663     if (!node)
2664         node = contextDocument();
2665 
2666     if (!node)
2667         return Exception { InvalidAccessError };
2668 
2669     node-&gt;document().updateLayoutIgnorePendingStylesheets();
2670 
2671     ScrollableArea* scrollableArea = nullptr;
2672     if (is&lt;Document&gt;(*node)) {
2673         auto* frameView = downcast&lt;Document&gt;(node)-&gt;view();
2674         if (!frameView)
2675             return Exception { InvalidAccessError };
2676 
2677         scrollableArea = frameView;
2678     } else if (is&lt;Element&gt;(*node)) {
2679         auto&amp; element = *downcast&lt;Element&gt;(node);
2680         if (!element.renderBox())
2681             return Exception { InvalidAccessError };
2682 
2683         scrollableArea = element.renderBox()-&gt;layer();
2684     } else
2685         return Exception { InvalidNodeTypeError };
2686 
2687     if (!scrollableArea)
2688         return Exception { InvalidNodeTypeError };
2689 
2690     return scrollableArea-&gt;useDarkAppearance();
2691 }
2692 
2693 ExceptionOr&lt;String&gt; Internals::scrollingStateTreeAsText() const
2694 {
2695     Document* document = contextDocument();
2696     if (!document || !document-&gt;frame())
2697         return Exception { InvalidAccessError };
2698 
2699     document-&gt;updateLayoutIgnorePendingStylesheets();
2700 
2701     Page* page = document-&gt;page();
2702     if (!page)
2703         return String();
2704 
2705     return page-&gt;scrollingStateTreeAsText();
2706 }
2707 
2708 ExceptionOr&lt;String&gt; Internals::mainThreadScrollingReasons() const
2709 {
2710     Document* document = contextDocument();
2711     if (!document || !document-&gt;frame())
2712         return Exception { InvalidAccessError };
2713 
2714     Page* page = document-&gt;page();
2715     if (!page)
2716         return String();
2717 
2718     return page-&gt;synchronousScrollingReasonsAsText();
2719 }
2720 
2721 ExceptionOr&lt;Ref&lt;DOMRectList&gt;&gt; Internals::nonFastScrollableRects() const
2722 {
2723     Document* document = contextDocument();
2724     if (!document || !document-&gt;frame())
2725         return Exception { InvalidAccessError };
2726 
2727     Page* page = document-&gt;page();
2728     if (!page)
2729         return DOMRectList::create();
2730 
2731     return page-&gt;nonFastScrollableRects();
2732 }
2733 
2734 ExceptionOr&lt;void&gt; Internals::setElementUsesDisplayListDrawing(Element&amp; element, bool usesDisplayListDrawing)
2735 {
2736     Document* document = contextDocument();
2737     if (!document || !document-&gt;renderView())
2738         return Exception { InvalidAccessError };
2739 
2740     element.document().updateLayoutIgnorePendingStylesheets();
2741 
2742     if (!element.renderer())
2743         return Exception { InvalidAccessError };
2744 
2745     if (is&lt;HTMLCanvasElement&gt;(element)) {
2746         downcast&lt;HTMLCanvasElement&gt;(element).setUsesDisplayListDrawing(usesDisplayListDrawing);
2747         return { };
2748     }
2749 
2750     if (!element.renderer()-&gt;hasLayer())
2751         return Exception { InvalidAccessError };
2752 
2753     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(element.renderer())-&gt;layer();
2754     if (!layer-&gt;isComposited())
2755         return Exception { InvalidAccessError };
2756 
2757     layer-&gt;backing()-&gt;setUsesDisplayListDrawing(usesDisplayListDrawing);
2758     return { };
2759 }
2760 
2761 ExceptionOr&lt;void&gt; Internals::setElementTracksDisplayListReplay(Element&amp; element, bool isTrackingReplay)
2762 {
2763     Document* document = contextDocument();
2764     if (!document || !document-&gt;renderView())
2765         return Exception { InvalidAccessError };
2766 
2767     element.document().updateLayoutIgnorePendingStylesheets();
2768 
2769     if (!element.renderer())
2770         return Exception { InvalidAccessError };
2771 
2772     if (is&lt;HTMLCanvasElement&gt;(element)) {
2773         downcast&lt;HTMLCanvasElement&gt;(element).setTracksDisplayListReplay(isTrackingReplay);
2774         return { };
2775     }
2776 
2777     if (!element.renderer()-&gt;hasLayer())
2778         return Exception { InvalidAccessError };
2779 
2780     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(element.renderer())-&gt;layer();
2781     if (!layer-&gt;isComposited())
2782         return Exception { InvalidAccessError };
2783 
2784     layer-&gt;backing()-&gt;setIsTrackingDisplayListReplay(isTrackingReplay);
2785     return { };
2786 }
2787 
2788 ExceptionOr&lt;String&gt; Internals::displayListForElement(Element&amp; element, unsigned short flags)
2789 {
2790     Document* document = contextDocument();
2791     if (!document || !document-&gt;renderView())
2792         return Exception { InvalidAccessError };
2793 
2794     element.document().updateLayoutIgnorePendingStylesheets();
2795 
2796     if (!element.renderer())
2797         return Exception { InvalidAccessError };
2798 
2799     DisplayList::AsTextFlags displayListFlags = 0;
2800     if (flags &amp; DISPLAY_LIST_INCLUDES_PLATFORM_OPERATIONS)
2801         displayListFlags |= DisplayList::AsTextFlag::IncludesPlatformOperations;
2802 
2803     if (is&lt;HTMLCanvasElement&gt;(element))
2804         return downcast&lt;HTMLCanvasElement&gt;(element).displayListAsText(displayListFlags);
2805 
2806     if (!element.renderer()-&gt;hasLayer())
2807         return Exception { InvalidAccessError };
2808 
2809     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(element.renderer())-&gt;layer();
2810     if (!layer-&gt;isComposited())
2811         return Exception { InvalidAccessError };
2812 
2813     return layer-&gt;backing()-&gt;displayListAsText(displayListFlags);
2814 }
2815 
2816 ExceptionOr&lt;String&gt; Internals::replayDisplayListForElement(Element&amp; element, unsigned short flags)
2817 {
2818     Document* document = contextDocument();
2819     if (!document || !document-&gt;renderView())
2820         return Exception { InvalidAccessError };
2821 
2822     element.document().updateLayoutIgnorePendingStylesheets();
2823 
2824     if (!element.renderer())
2825         return Exception { InvalidAccessError };
2826 
2827     DisplayList::AsTextFlags displayListFlags = 0;
2828     if (flags &amp; DISPLAY_LIST_INCLUDES_PLATFORM_OPERATIONS)
2829         displayListFlags |= DisplayList::AsTextFlag::IncludesPlatformOperations;
2830 
2831     if (is&lt;HTMLCanvasElement&gt;(element))
2832         return downcast&lt;HTMLCanvasElement&gt;(element).replayDisplayListAsText(displayListFlags);
2833 
2834     if (!element.renderer()-&gt;hasLayer())
2835         return Exception { InvalidAccessError };
2836 
2837     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(element.renderer())-&gt;layer();
2838     if (!layer-&gt;isComposited())
2839         return Exception { InvalidAccessError };
2840 
2841     return layer-&gt;backing()-&gt;replayDisplayListAsText(displayListFlags);
2842 }
2843 
2844 ExceptionOr&lt;void&gt; Internals::garbageCollectDocumentResources() const
2845 {
2846     Document* document = contextDocument();
2847     if (!document)
2848         return Exception { InvalidAccessError };
2849     document-&gt;cachedResourceLoader().garbageCollectDocumentResources();
2850     return { };
2851 }
2852 
2853 bool Internals::isUnderMemoryPressure()
2854 {
2855     return MemoryPressureHandler::singleton().isUnderMemoryPressure();
2856 }
2857 
2858 void Internals::beginSimulatedMemoryPressure()
2859 {
2860     MemoryPressureHandler::singleton().beginSimulatedMemoryPressure();
2861 }
2862 
2863 void Internals::endSimulatedMemoryPressure()
2864 {
2865     MemoryPressureHandler::singleton().endSimulatedMemoryPressure();
2866 }
2867 
2868 ExceptionOr&lt;void&gt; Internals::insertAuthorCSS(const String&amp; css) const
2869 {
2870     Document* document = contextDocument();
2871     if (!document)
2872         return Exception { InvalidAccessError };
2873 
2874     auto parsedSheet = StyleSheetContents::create(*document);
2875     parsedSheet.get().setIsUserStyleSheet(false);
2876     parsedSheet.get().parseString(css);
2877     document-&gt;extensionStyleSheets().addAuthorStyleSheetForTesting(WTFMove(parsedSheet));
2878     return { };
2879 }
2880 
2881 ExceptionOr&lt;void&gt; Internals::insertUserCSS(const String&amp; css) const
2882 {
2883     Document* document = contextDocument();
2884     if (!document)
2885         return Exception { InvalidAccessError };
2886 
2887     auto parsedSheet = StyleSheetContents::create(*document);
2888     parsedSheet.get().setIsUserStyleSheet(true);
2889     parsedSheet.get().parseString(css);
2890     document-&gt;extensionStyleSheets().addUserStyleSheet(WTFMove(parsedSheet));
2891     return { };
2892 }
2893 
2894 String Internals::counterValue(Element&amp; element)
2895 {
2896     return counterValueForElement(&amp;element);
2897 }
2898 
2899 int Internals::pageNumber(Element&amp; element, float pageWidth, float pageHeight)
2900 {
2901     return PrintContext::pageNumberForElement(&amp;element, { pageWidth, pageHeight });
2902 }
2903 
2904 Vector&lt;String&gt; Internals::shortcutIconURLs() const
2905 {
2906     if (!frame())
2907         return { };
2908 
2909     auto* documentLoader = frame()-&gt;loader().documentLoader();
2910     if (!documentLoader)
2911         return { };
2912 
2913     Vector&lt;String&gt; result;
2914     for (auto&amp; linkIcon : documentLoader-&gt;linkIcons())
2915         result.append(linkIcon.url.string());
2916 
2917     return result;
2918 }
2919 
2920 int Internals::numberOfPages(float pageWidth, float pageHeight)
2921 {
2922     if (!frame())
2923         return -1;
2924 
2925     return PrintContext::numberOfPages(*frame(), FloatSize(pageWidth, pageHeight));
2926 }
2927 
2928 ExceptionOr&lt;String&gt; Internals::pageProperty(const String&amp; propertyName, int pageNumber) const
2929 {
2930     if (!frame())
2931         return Exception { InvalidAccessError };
2932 
2933     return PrintContext::pageProperty(frame(), propertyName.utf8().data(), pageNumber);
2934 }
2935 
2936 ExceptionOr&lt;String&gt; Internals::pageSizeAndMarginsInPixels(int pageNumber, int width, int height, int marginTop, int marginRight, int marginBottom, int marginLeft) const
2937 {
2938     if (!frame())
2939         return Exception { InvalidAccessError };
2940 
2941     return PrintContext::pageSizeAndMarginsInPixels(frame(), pageNumber, width, height, marginTop, marginRight, marginBottom, marginLeft);
2942 }
2943 
2944 ExceptionOr&lt;float&gt; Internals::pageScaleFactor() const
2945 {
2946     Document* document = contextDocument();
2947     if (!document || !document-&gt;page())
2948         return Exception { InvalidAccessError };
2949 
2950     return document-&gt;page()-&gt;pageScaleFactor();
2951 }
2952 
2953 ExceptionOr&lt;void&gt; Internals::setPageScaleFactor(float scaleFactor, int x, int y)
2954 {
2955     Document* document = contextDocument();
2956     if (!document || !document-&gt;page())
2957         return Exception { InvalidAccessError };
2958 
2959     document-&gt;page()-&gt;setPageScaleFactor(scaleFactor, IntPoint(x, y));
2960     return { };
2961 }
2962 
2963 ExceptionOr&lt;void&gt; Internals::setPageZoomFactor(float zoomFactor)
2964 {
2965     Document* document = contextDocument();
2966     if (!document || !document-&gt;frame())
2967         return Exception { InvalidAccessError };
2968 
2969     document-&gt;frame()-&gt;setPageZoomFactor(zoomFactor);
2970     return { };
2971 }
2972 
2973 ExceptionOr&lt;void&gt; Internals::setTextZoomFactor(float zoomFactor)
2974 {
2975     Document* document = contextDocument();
2976     if (!document || !document-&gt;frame())
2977         return Exception { InvalidAccessError };
2978 
2979     document-&gt;frame()-&gt;setTextZoomFactor(zoomFactor);
2980     return { };
2981 }
2982 
2983 ExceptionOr&lt;void&gt; Internals::setUseFixedLayout(bool useFixedLayout)
2984 {
2985     Document* document = contextDocument();
2986     if (!document || !document-&gt;view())
2987         return Exception { InvalidAccessError };
2988 
2989     document-&gt;view()-&gt;setUseFixedLayout(useFixedLayout);
2990     return { };
2991 }
2992 
2993 ExceptionOr&lt;void&gt; Internals::setFixedLayoutSize(int width, int height)
2994 {
2995     Document* document = contextDocument();
2996     if (!document || !document-&gt;view())
2997         return Exception { InvalidAccessError };
2998 
2999     document-&gt;view()-&gt;setFixedLayoutSize(IntSize(width, height));
3000     return { };
3001 }
3002 
3003 ExceptionOr&lt;void&gt; Internals::setViewExposedRect(float x, float y, float width, float height)
3004 {
3005     Document* document = contextDocument();
3006     if (!document || !document-&gt;view())
3007         return Exception { InvalidAccessError };
3008 
3009     document-&gt;view()-&gt;setViewExposedRect(FloatRect(x, y, width, height));
3010     return { };
3011 }
3012 
3013 void Internals::setPrinting(int width, int height)
3014 {
3015     printContextForTesting() = makeUnique&lt;PrintContext&gt;(frame());
3016     printContextForTesting()-&gt;begin(width, height);
3017 }
3018 
3019 void Internals::setHeaderHeight(float height)
3020 {
3021     Document* document = contextDocument();
3022     if (!document || !document-&gt;view())
3023         return;
3024 
3025     document-&gt;page()-&gt;setHeaderHeight(height);
3026 }
3027 
3028 void Internals::setFooterHeight(float height)
3029 {
3030     Document* document = contextDocument();
3031     if (!document || !document-&gt;view())
3032         return;
3033 
3034     document-&gt;page()-&gt;setFooterHeight(height);
3035 }
3036 
3037 void Internals::setTopContentInset(float contentInset)
3038 {
3039     Document* document = contextDocument();
3040     if (!document || !document-&gt;page())
3041         return;
3042 
3043     document-&gt;page()-&gt;setTopContentInset(contentInset);
3044 }
3045 
3046 #if ENABLE(FULLSCREEN_API)
3047 
3048 void Internals::webkitWillEnterFullScreenForElement(Element&amp; element)
3049 {
3050     Document* document = contextDocument();
3051     if (!document)
3052         return;
3053     document-&gt;fullscreenManager().willEnterFullscreen(element);
3054 }
3055 
3056 void Internals::webkitDidEnterFullScreenForElement(Element&amp;)
3057 {
3058     Document* document = contextDocument();
3059     if (!document)
3060         return;
3061     document-&gt;fullscreenManager().didEnterFullscreen();
3062 }
3063 
3064 void Internals::webkitWillExitFullScreenForElement(Element&amp;)
3065 {
3066     Document* document = contextDocument();
3067     if (!document)
3068         return;
3069     document-&gt;fullscreenManager().willExitFullscreen();
3070 }
3071 
3072 void Internals::webkitDidExitFullScreenForElement(Element&amp;)
3073 {
3074     Document* document = contextDocument();
3075     if (!document)
3076         return;
3077     document-&gt;fullscreenManager().didExitFullscreen();
3078 }
3079 
3080 bool Internals::isAnimatingFullScreen() const
3081 {
3082     Document* document = contextDocument();
3083     if (!document)
3084         return false;
3085     return document-&gt;fullscreenManager().isAnimatingFullscreen();
3086 }
3087 
3088 #endif
3089 
3090 void Internals::setFullscreenInsets(FullscreenInsets insets)
3091 {
3092     Page* page = contextDocument()-&gt;frame()-&gt;page();
3093     ASSERT(page);
3094 
3095     page-&gt;setFullscreenInsets(FloatBoxExtent(insets.top, insets.right, insets.bottom, insets.left));
3096 }
3097 
3098 void Internals::setFullscreenAutoHideDuration(double duration)
3099 {
3100     Page* page = contextDocument()-&gt;frame()-&gt;page();
3101     ASSERT(page);
3102 
3103     page-&gt;setFullscreenAutoHideDuration(Seconds(duration));
3104 }
3105 
3106 void Internals::setFullscreenControlsHidden(bool hidden)
3107 {
3108     Page* page = contextDocument()-&gt;frame()-&gt;page();
3109     ASSERT(page);
3110 
3111     page-&gt;setFullscreenControlsHidden(hidden);
3112 }
3113 
3114 void Internals::setApplicationCacheOriginQuota(unsigned long long quota)
3115 {
3116     Document* document = contextDocument();
3117     if (!document || !document-&gt;page())
3118         return;
3119     document-&gt;page()-&gt;applicationCacheStorage().storeUpdatedQuotaForOrigin(&amp;document-&gt;securityOrigin(), quota);
3120 }
3121 
3122 void Internals::registerURLSchemeAsBypassingContentSecurityPolicy(const String&amp; scheme)
3123 {
3124     SchemeRegistry::registerURLSchemeAsBypassingContentSecurityPolicy(scheme);
3125 }
3126 
3127 void Internals::removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(const String&amp; scheme)
3128 {
3129     SchemeRegistry::removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(scheme);
3130 }
3131 
3132 void Internals::registerDefaultPortForProtocol(unsigned short port, const String&amp; protocol)
3133 {
3134     registerDefaultPortForProtocolForTesting(port, protocol);
3135 }
3136 
3137 Ref&lt;MallocStatistics&gt; Internals::mallocStatistics() const
3138 {
3139     return MallocStatistics::create();
3140 }
3141 
3142 Ref&lt;TypeConversions&gt; Internals::typeConversions() const
3143 {
3144     return TypeConversions::create();
3145 }
3146 
3147 Ref&lt;MemoryInfo&gt; Internals::memoryInfo() const
3148 {
3149     return MemoryInfo::create();
3150 }
3151 
3152 Vector&lt;String&gt; Internals::getReferencedFilePaths() const
3153 {
3154     frame()-&gt;loader().history().saveDocumentAndScrollState();
3155     return FormController::referencedFilePaths(frame()-&gt;loader().history().currentItem()-&gt;documentState());
3156 }
3157 
3158 ExceptionOr&lt;void&gt; Internals::startTrackingRepaints()
3159 {
3160     Document* document = contextDocument();
3161     if (!document || !document-&gt;view())
3162         return Exception { InvalidAccessError };
3163 
3164     document-&gt;view()-&gt;setTracksRepaints(true);
3165     return { };
3166 }
3167 
3168 ExceptionOr&lt;void&gt; Internals::stopTrackingRepaints()
3169 {
3170     Document* document = contextDocument();
3171     if (!document || !document-&gt;view())
3172         return Exception { InvalidAccessError };
3173 
3174     document-&gt;view()-&gt;setTracksRepaints(false);
3175     return { };
3176 }
3177 
3178 ExceptionOr&lt;void&gt; Internals::startTrackingLayerFlushes()
3179 {
3180     Document* document = contextDocument();
3181     if (!document || !document-&gt;renderView())
3182         return Exception { InvalidAccessError };
3183 
3184     document-&gt;renderView()-&gt;compositor().startTrackingLayerFlushes();
3185     return { };
3186 }
3187 
3188 ExceptionOr&lt;unsigned&gt; Internals::layerFlushCount()
3189 {
3190     Document* document = contextDocument();
3191     if (!document || !document-&gt;renderView())
3192         return Exception { InvalidAccessError };
3193 
3194     return document-&gt;renderView()-&gt;compositor().layerFlushCount();
3195 }
3196 
3197 ExceptionOr&lt;void&gt; Internals::startTrackingStyleRecalcs()
3198 {
3199     Document* document = contextDocument();
3200     if (!document)
3201         return Exception { InvalidAccessError };
3202 
3203     document-&gt;startTrackingStyleRecalcs();
3204     return { };
3205 }
3206 
3207 ExceptionOr&lt;unsigned&gt; Internals::styleRecalcCount()
3208 {
3209     Document* document = contextDocument();
3210     if (!document)
3211         return Exception { InvalidAccessError };
3212 
3213     return document-&gt;styleRecalcCount();
3214 }
3215 
3216 unsigned Internals::lastStyleUpdateSize() const
3217 {
3218     Document* document = contextDocument();
3219     if (!document)
3220         return 0;
3221     return document-&gt;lastStyleUpdateSizeForTesting();
3222 }
3223 
3224 ExceptionOr&lt;void&gt; Internals::startTrackingCompositingUpdates()
3225 {
3226     Document* document = contextDocument();
3227     if (!document || !document-&gt;renderView())
3228         return Exception { InvalidAccessError };
3229 
3230     document-&gt;renderView()-&gt;compositor().startTrackingCompositingUpdates();
3231     return { };
3232 }
3233 
3234 ExceptionOr&lt;unsigned&gt; Internals::compositingUpdateCount()
3235 {
3236     Document* document = contextDocument();
3237     if (!document || !document-&gt;renderView())
3238         return Exception { InvalidAccessError };
3239 
3240     return document-&gt;renderView()-&gt;compositor().compositingUpdateCount();
3241 }
3242 
3243 ExceptionOr&lt;void&gt; Internals::setCompositingPolicyOverride(Optional&lt;CompositingPolicy&gt; policyOverride)
3244 {
3245     Document* document = contextDocument();
3246     if (!document)
3247         return Exception { InvalidAccessError };
3248 
3249     if (!policyOverride) {
3250         document-&gt;page()-&gt;setCompositingPolicyOverride(WTF::nullopt);
3251         return { };
3252     }
3253 
3254     switch (policyOverride.value()) {
3255     case Internals::CompositingPolicy::Normal:
3256         document-&gt;page()-&gt;setCompositingPolicyOverride(WebCore::CompositingPolicy::Normal);
3257         break;
3258     case Internals::CompositingPolicy::Conservative:
3259         document-&gt;page()-&gt;setCompositingPolicyOverride(WebCore::CompositingPolicy::Conservative);
3260         break;
3261     }
3262 
3263     return { };
3264 }
3265 
3266 ExceptionOr&lt;Optional&lt;Internals::CompositingPolicy&gt;&gt; Internals::compositingPolicyOverride() const
3267 {
3268     Document* document = contextDocument();
3269     if (!document)
3270         return Exception { InvalidAccessError };
3271 
3272     auto policyOverride = document-&gt;page()-&gt;compositingPolicyOverride();
3273     if (!policyOverride)
3274         return { WTF::nullopt };
3275 
3276     switch (policyOverride.value()) {
3277     case WebCore::CompositingPolicy::Normal:
3278         return { Internals::CompositingPolicy::Normal };
3279     case WebCore::CompositingPolicy::Conservative:
3280         return { Internals::CompositingPolicy::Conservative };
3281     }
3282 
3283     return { Internals::CompositingPolicy::Normal };
3284 }
3285 
3286 ExceptionOr&lt;void&gt; Internals::updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks(Node* node)
3287 {
3288     Document* document;
3289     if (!node)
3290         document = contextDocument();
3291     else if (is&lt;Document&gt;(*node))
3292         document = downcast&lt;Document&gt;(node);
3293     else if (is&lt;HTMLIFrameElement&gt;(*node))
3294         document = downcast&lt;HTMLIFrameElement&gt;(*node).contentDocument();
3295     else
3296         return Exception { TypeError };
3297 
3298     document-&gt;updateLayoutIgnorePendingStylesheets(Document::RunPostLayoutTasks::Synchronously);
3299     return { };
3300 }
3301 
3302 unsigned Internals::layoutCount() const
3303 {
3304     Document* document = contextDocument();
3305     if (!document || !document-&gt;view())
3306         return 0;
3307     return document-&gt;view()-&gt;layoutContext().layoutCount();
3308 }
3309 
3310 #if !PLATFORM(IOS_FAMILY)
3311 static const char* cursorTypeToString(Cursor::Type cursorType)
3312 {
3313     switch (cursorType) {
3314     case Cursor::Pointer: return &quot;Pointer&quot;;
3315     case Cursor::Cross: return &quot;Cross&quot;;
3316     case Cursor::Hand: return &quot;Hand&quot;;
3317     case Cursor::IBeam: return &quot;IBeam&quot;;
3318     case Cursor::Wait: return &quot;Wait&quot;;
3319     case Cursor::Help: return &quot;Help&quot;;
3320     case Cursor::EastResize: return &quot;EastResize&quot;;
3321     case Cursor::NorthResize: return &quot;NorthResize&quot;;
3322     case Cursor::NorthEastResize: return &quot;NorthEastResize&quot;;
3323     case Cursor::NorthWestResize: return &quot;NorthWestResize&quot;;
3324     case Cursor::SouthResize: return &quot;SouthResize&quot;;
3325     case Cursor::SouthEastResize: return &quot;SouthEastResize&quot;;
3326     case Cursor::SouthWestResize: return &quot;SouthWestResize&quot;;
3327     case Cursor::WestResize: return &quot;WestResize&quot;;
3328     case Cursor::NorthSouthResize: return &quot;NorthSouthResize&quot;;
3329     case Cursor::EastWestResize: return &quot;EastWestResize&quot;;
3330     case Cursor::NorthEastSouthWestResize: return &quot;NorthEastSouthWestResize&quot;;
3331     case Cursor::NorthWestSouthEastResize: return &quot;NorthWestSouthEastResize&quot;;
3332     case Cursor::ColumnResize: return &quot;ColumnResize&quot;;
3333     case Cursor::RowResize: return &quot;RowResize&quot;;
3334     case Cursor::MiddlePanning: return &quot;MiddlePanning&quot;;
3335     case Cursor::EastPanning: return &quot;EastPanning&quot;;
3336     case Cursor::NorthPanning: return &quot;NorthPanning&quot;;
3337     case Cursor::NorthEastPanning: return &quot;NorthEastPanning&quot;;
3338     case Cursor::NorthWestPanning: return &quot;NorthWestPanning&quot;;
3339     case Cursor::SouthPanning: return &quot;SouthPanning&quot;;
3340     case Cursor::SouthEastPanning: return &quot;SouthEastPanning&quot;;
3341     case Cursor::SouthWestPanning: return &quot;SouthWestPanning&quot;;
3342     case Cursor::WestPanning: return &quot;WestPanning&quot;;
3343     case Cursor::Move: return &quot;Move&quot;;
3344     case Cursor::VerticalText: return &quot;VerticalText&quot;;
3345     case Cursor::Cell: return &quot;Cell&quot;;
3346     case Cursor::ContextMenu: return &quot;ContextMenu&quot;;
3347     case Cursor::Alias: return &quot;Alias&quot;;
3348     case Cursor::Progress: return &quot;Progress&quot;;
3349     case Cursor::NoDrop: return &quot;NoDrop&quot;;
3350     case Cursor::Copy: return &quot;Copy&quot;;
3351     case Cursor::None: return &quot;None&quot;;
3352     case Cursor::NotAllowed: return &quot;NotAllowed&quot;;
3353     case Cursor::ZoomIn: return &quot;ZoomIn&quot;;
3354     case Cursor::ZoomOut: return &quot;ZoomOut&quot;;
3355     case Cursor::Grab: return &quot;Grab&quot;;
3356     case Cursor::Grabbing: return &quot;Grabbing&quot;;
3357     case Cursor::Custom: return &quot;Custom&quot;;
3358     }
3359 
3360     ASSERT_NOT_REACHED();
3361     return &quot;UNKNOWN&quot;;
3362 }
3363 #endif
3364 
3365 ExceptionOr&lt;String&gt; Internals::getCurrentCursorInfo()
3366 {
3367     Document* document = contextDocument();
3368     if (!document || !document-&gt;frame())
3369         return Exception { InvalidAccessError };
3370 
3371 #if !PLATFORM(IOS_FAMILY)
3372     Cursor cursor = document-&gt;frame()-&gt;eventHandler().currentMouseCursor();
3373 
3374     StringBuilder result;
3375     result.appendLiteral(&quot;type=&quot;);
3376     result.append(cursorTypeToString(cursor.type()));
3377     result.appendLiteral(&quot; hotSpot=&quot;);
3378     result.appendNumber(cursor.hotSpot().x());
3379     result.append(&#39;,&#39;);
3380     result.appendNumber(cursor.hotSpot().y());
3381     if (cursor.image()) {
3382         FloatSize size = cursor.image()-&gt;size();
3383         result.appendLiteral(&quot; image=&quot;);
3384         result.appendFixedPrecisionNumber(size.width());
3385         result.append(&#39;x&#39;);
3386         result.appendFixedPrecisionNumber(size.height());
3387     }
3388 #if ENABLE(MOUSE_CURSOR_SCALE)
3389     if (cursor.imageScaleFactor() != 1) {
3390         result.appendLiteral(&quot; scale=&quot;);
3391         result.appendFixedPrecisionNumber(cursor.imageScaleFactor(), 8);
3392     }
3393 #endif
3394     return result.toString();
3395 #else
3396     return &quot;FAIL: Cursor details not available on this platform.&quot;_str;
3397 #endif
3398 }
3399 
3400 Ref&lt;ArrayBuffer&gt; Internals::serializeObject(const RefPtr&lt;SerializedScriptValue&gt;&amp; value) const
3401 {
3402     auto&amp; bytes = value-&gt;data();
3403     return ArrayBuffer::create(bytes.data(), bytes.size());
3404 }
3405 
3406 Ref&lt;SerializedScriptValue&gt; Internals::deserializeBuffer(ArrayBuffer&amp; buffer) const
3407 {
3408     Vector&lt;uint8_t&gt; bytes;
3409     bytes.append(static_cast&lt;const uint8_t*&gt;(buffer.data()), buffer.byteLength());
3410     return SerializedScriptValue::adopt(WTFMove(bytes));
3411 }
3412 
3413 bool Internals::isFromCurrentWorld(JSC::JSValue value) const
3414 {
3415     return isWorldCompatible(*contextDocument()-&gt;vm().topCallFrame, value);
3416 }
3417 
3418 void Internals::setUsesOverlayScrollbars(bool enabled)
3419 {
3420     WebCore::DeprecatedGlobalSettings::setUsesOverlayScrollbars(enabled);
3421 }
3422 
3423 void Internals::setUsesMockScrollAnimator(bool enabled)
3424 {
3425     WebCore::DeprecatedGlobalSettings::setUsesMockScrollAnimator(enabled);
3426 }
3427 
3428 void Internals::forceReload(bool endToEnd)
3429 {
3430     OptionSet&lt;ReloadOption&gt; reloadOptions;
3431     if (endToEnd)
3432         reloadOptions.add(ReloadOption::FromOrigin);
3433 
3434     frame()-&gt;loader().reload(reloadOptions);
3435 }
3436 
3437 void Internals::reloadExpiredOnly()
3438 {
3439     frame()-&gt;loader().reload(ReloadOption::ExpiredOnly);
3440 }
3441 
3442 void Internals::enableAutoSizeMode(bool enabled, int width, int height)
3443 {
3444     auto* document = contextDocument();
3445     if (!document || !document-&gt;view())
3446         return;
3447     document-&gt;view()-&gt;enableAutoSizeMode(enabled, { width, height });
3448 }
3449 
3450 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
3451 
3452 void Internals::initializeMockCDM()
3453 {
3454     LegacyCDM::registerCDMFactory([] (LegacyCDM* cdm) { return makeUnique&lt;LegacyMockCDM&gt;(cdm); },
3455         LegacyMockCDM::supportsKeySystem, LegacyMockCDM::supportsKeySystemAndMimeType);
3456 }
3457 
3458 #endif
3459 
3460 #if ENABLE(ENCRYPTED_MEDIA)
3461 
3462 Ref&lt;MockCDMFactory&gt; Internals::registerMockCDM()
3463 {
3464     return MockCDMFactory::create();
3465 }
3466 
3467 #endif
3468 
3469 String Internals::markerTextForListItem(Element&amp; element)
3470 {
3471     return WebCore::markerTextForListItem(&amp;element);
3472 }
3473 
3474 String Internals::toolTipFromElement(Element&amp; element) const
3475 {
3476     HitTestResult result;
3477     result.setInnerNode(&amp;element);
3478     TextDirection direction;
3479     return result.title(direction);
3480 }
3481 
3482 String Internals::getImageSourceURL(Element&amp; element)
3483 {
3484     return element.imageSourceURL();
3485 }
3486 
3487 #if ENABLE(VIDEO)
3488 
3489 Vector&lt;String&gt; Internals::mediaResponseSources(HTMLMediaElement&amp; media)
3490 {
3491     auto* resourceLoader = media.lastMediaResourceLoaderForTesting();
3492     if (!resourceLoader)
3493         return { };
3494     Vector&lt;String&gt; result;
3495     auto responses = resourceLoader-&gt;responsesForTesting();
3496     for (auto&amp; response : responses)
3497         result.append(responseSourceToString(response));
3498     return result;
3499 }
3500 
3501 Vector&lt;String&gt; Internals::mediaResponseContentRanges(HTMLMediaElement&amp; media)
3502 {
3503     auto* resourceLoader = media.lastMediaResourceLoaderForTesting();
3504     if (!resourceLoader)
3505         return { };
3506     Vector&lt;String&gt; result;
3507     auto responses = resourceLoader-&gt;responsesForTesting();
3508     for (auto&amp; response : responses)
3509         result.append(response.httpHeaderField(HTTPHeaderName::ContentRange));
3510     return result;
3511 }
3512 
3513 void Internals::simulateAudioInterruption(HTMLMediaElement&amp; element)
3514 {
3515 #if USE(GSTREAMER)
3516     element.player()-&gt;simulateAudioInterruption();
3517 #else
3518     UNUSED_PARAM(element);
3519 #endif
3520 }
3521 
3522 ExceptionOr&lt;bool&gt; Internals::mediaElementHasCharacteristic(HTMLMediaElement&amp; element, const String&amp; characteristic)
3523 {
3524     if (equalLettersIgnoringASCIICase(characteristic, &quot;audible&quot;))
3525         return element.hasAudio();
3526     if (equalLettersIgnoringASCIICase(characteristic, &quot;visual&quot;))
3527         return element.hasVideo();
3528     if (equalLettersIgnoringASCIICase(characteristic, &quot;legible&quot;))
3529         return element.hasClosedCaptions();
3530 
3531     return Exception { SyntaxError };
3532 }
3533 
3534 void Internals::beginSimulatedHDCPError(HTMLMediaElement&amp; element)
3535 {
3536     if (auto player = element.player())
3537         player-&gt;beginSimulatedHDCPError();
3538 }
3539 
3540 void Internals::endSimulatedHDCPError(HTMLMediaElement&amp; element)
3541 {
3542     if (auto player = element.player())
3543         player-&gt;endSimulatedHDCPError();
3544 }
3545 
3546 bool Internals::elementShouldBufferData(HTMLMediaElement&amp; element)
3547 {
3548     return element.bufferingPolicy() &lt; MediaPlayer::BufferingPolicy::LimitReadAhead;
3549 }
3550 
3551 String Internals::elementBufferingPolicy(HTMLMediaElement&amp; element)
3552 {
3553     switch (element.bufferingPolicy()) {
3554     case MediaPlayer::BufferingPolicy::Default:
3555         return &quot;Default&quot;;
3556     case MediaPlayer::BufferingPolicy::LimitReadAhead:
3557         return &quot;LimitReadAhead&quot;;
3558     case MediaPlayer::BufferingPolicy::MakeResourcesPurgeable:
3559         return &quot;MakeResourcesPurgeable&quot;;
3560     case MediaPlayer::BufferingPolicy::PurgeResources:
3561         return &quot;PurgeResources&quot;;
3562     }
3563 
3564     ASSERT_NOT_REACHED();
3565     return &quot;UNKNOWN&quot;;
3566 }
3567 #endif
3568 
3569 bool Internals::isSelectPopupVisible(HTMLSelectElement&amp; element)
3570 {
3571     element.document().updateLayoutIgnorePendingStylesheets();
3572 
3573     auto* renderer = element.renderer();
3574     if (!is&lt;RenderMenuList&gt;(renderer))
3575         return false;
3576 
3577 #if !PLATFORM(IOS_FAMILY)
3578     return downcast&lt;RenderMenuList&gt;(*renderer).popupIsVisible();
3579 #else
3580     return false;
3581 #endif
3582 }
3583 
3584 ExceptionOr&lt;String&gt; Internals::captionsStyleSheetOverride()
3585 {
3586     Document* document = contextDocument();
3587     if (!document || !document-&gt;page())
3588         return Exception { InvalidAccessError };
3589 
3590 #if ENABLE(VIDEO_TRACK)
3591     return document-&gt;page()-&gt;group().captionPreferences().captionsStyleSheetOverride();
3592 #else
3593     return String { emptyString() };
3594 #endif
3595 }
3596 
3597 ExceptionOr&lt;void&gt; Internals::setCaptionsStyleSheetOverride(const String&amp; override)
3598 {
3599     Document* document = contextDocument();
3600     if (!document || !document-&gt;page())
3601         return Exception { InvalidAccessError };
3602 
3603 #if ENABLE(VIDEO_TRACK)
3604     document-&gt;page()-&gt;group().captionPreferences().setCaptionsStyleSheetOverride(override);
3605 #else
3606     UNUSED_PARAM(override);
3607 #endif
3608     return { };
3609 }
3610 
3611 ExceptionOr&lt;void&gt; Internals::setPrimaryAudioTrackLanguageOverride(const String&amp; language)
3612 {
3613     Document* document = contextDocument();
3614     if (!document || !document-&gt;page())
3615         return Exception { InvalidAccessError };
3616 
3617 #if ENABLE(VIDEO_TRACK)
3618     document-&gt;page()-&gt;group().captionPreferences().setPrimaryAudioTrackLanguageOverride(language);
3619 #else
3620     UNUSED_PARAM(language);
3621 #endif
3622     return { };
3623 }
3624 
3625 ExceptionOr&lt;void&gt; Internals::setCaptionDisplayMode(const String&amp; mode)
3626 {
3627     Document* document = contextDocument();
3628     if (!document || !document-&gt;page())
3629         return Exception { InvalidAccessError };
3630 
3631 #if ENABLE(VIDEO_TRACK)
3632     auto&amp; captionPreferences = document-&gt;page()-&gt;group().captionPreferences();
3633 
3634     if (equalLettersIgnoringASCIICase(mode, &quot;automatic&quot;))
3635         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::Automatic);
3636     else if (equalLettersIgnoringASCIICase(mode, &quot;forcedonly&quot;))
3637         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::ForcedOnly);
3638     else if (equalLettersIgnoringASCIICase(mode, &quot;alwayson&quot;))
3639         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::AlwaysOn);
3640     else if (equalLettersIgnoringASCIICase(mode, &quot;manual&quot;))
3641         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::Manual);
3642     else
3643         return Exception { SyntaxError };
3644 #else
3645     UNUSED_PARAM(mode);
3646 #endif
3647     return { };
3648 }
3649 
3650 #if ENABLE(VIDEO_TRACK)
3651 RefPtr&lt;TextTrackCueGeneric&gt; Internals::createGenericCue(double startTime, double endTime, String text)
3652 {
3653     Document* document = contextDocument();
3654     if (!document || !document-&gt;page())
3655         return nullptr;
3656     return TextTrackCueGeneric::create(*document, MediaTime::createWithDouble(startTime), MediaTime::createWithDouble(endTime), text);
3657 }
3658 #endif
3659 
3660 #if ENABLE(VIDEO)
3661 
3662 Ref&lt;TimeRanges&gt; Internals::createTimeRanges(Float32Array&amp; startTimes, Float32Array&amp; endTimes)
3663 {
3664     ASSERT(startTimes.length() == endTimes.length());
3665     Ref&lt;TimeRanges&gt; ranges = TimeRanges::create();
3666 
3667     unsigned count = std::min(startTimes.length(), endTimes.length());
3668     for (unsigned i = 0; i &lt; count; ++i)
3669         ranges-&gt;add(startTimes.item(i), endTimes.item(i));
3670     return ranges;
3671 }
3672 
3673 double Internals::closestTimeToTimeRanges(double time, TimeRanges&amp; ranges)
3674 {
3675     return ranges.nearest(time);
3676 }
3677 
3678 #endif
3679 
3680 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::selectionBounds()
3681 {
3682     Document* document = contextDocument();
3683     if (!document || !document-&gt;frame())
3684         return Exception { InvalidAccessError };
3685 
3686     return DOMRect::create(document-&gt;frame()-&gt;selection().selectionBounds());
3687 }
3688 
3689 void Internals::setSelectionWithoutValidation(Ref&lt;Node&gt; baseNode, unsigned baseOffset, RefPtr&lt;Node&gt; extentNode, unsigned extentOffset)
3690 {
3691     contextDocument()-&gt;frame()-&gt;selection().moveTo(
3692         VisiblePosition { createLegacyEditingPosition(baseNode.ptr(), baseOffset) },
3693         VisiblePosition { createLegacyEditingPosition(extentNode.get(), extentOffset) });
3694 }
3695 
3696 ExceptionOr&lt;bool&gt; Internals::isPluginUnavailabilityIndicatorObscured(Element&amp; element)
3697 {
3698     if (!is&lt;HTMLPlugInElement&gt;(element))
3699         return Exception { InvalidAccessError };
3700 
3701     return downcast&lt;HTMLPlugInElement&gt;(element).isReplacementObscured();
3702 }
3703 
3704 ExceptionOr&lt;String&gt; Internals::unavailablePluginReplacementText(Element&amp; element)
3705 {
3706     if (!is&lt;HTMLPlugInElement&gt;(element))
3707         return Exception { InvalidAccessError };
3708 
3709     auto* renderer = element.renderer();
3710     if (!is&lt;RenderEmbeddedObject&gt;(renderer))
3711         return String { };
3712 
3713     return String { downcast&lt;RenderEmbeddedObject&gt;(*renderer).pluginReplacementTextIfUnavailable() };
3714 }
3715 
3716 bool Internals::isPluginSnapshotted(Element&amp; element)
3717 {
3718     return is&lt;HTMLPlugInElement&gt;(element) &amp;&amp; downcast&lt;HTMLPlugInElement&gt;(element).displayState() &lt;= HTMLPlugInElement::DisplayingSnapshot;
3719 }
3720 
3721 bool Internals::pluginIsBelowSizeThreshold(Element&amp; element)
3722 {
3723     return is&lt;HTMLPlugInElement&gt;(element) &amp;&amp; downcast&lt;HTMLPlugInElement&gt;(element).isBelowSizeThreshold();
3724 }
3725 
3726 #if ENABLE(MEDIA_SOURCE)
3727 
3728 void Internals::initializeMockMediaSource()
3729 {
3730 #if USE(AVFOUNDATION)
3731     WebCore::DeprecatedGlobalSettings::setAVFoundationEnabled(false);
3732 #endif
3733 #if USE(GSTREAMER)
3734     WebCore::DeprecatedGlobalSettings::setGStreamerEnabled(false);
3735 #endif
3736     MediaPlayerFactorySupport::callRegisterMediaEngine(MockMediaPlayerMediaSource::registerMediaEngine);
3737 }
3738 
3739 Vector&lt;String&gt; Internals::bufferedSamplesForTrackID(SourceBuffer&amp; buffer, const AtomString&amp; trackID)
3740 {
3741     return buffer.bufferedSamplesForTrackID(trackID);
3742 }
3743 
3744 Vector&lt;String&gt; Internals::enqueuedSamplesForTrackID(SourceBuffer&amp; buffer, const AtomString&amp; trackID)
3745 {
3746     return buffer.enqueuedSamplesForTrackID(trackID);
3747 }
3748 
3749 double Internals::minimumUpcomingPresentationTimeForTrackID(SourceBuffer&amp; buffer, const AtomString&amp; trackID)
3750 {
3751     return buffer.minimumUpcomingPresentationTimeForTrackID(trackID).toDouble();
3752 }
3753 
3754 void Internals::setShouldGenerateTimestamps(SourceBuffer&amp; buffer, bool flag)
3755 {
3756     buffer.setShouldGenerateTimestamps(flag);
3757 }
3758 
3759 void Internals::setMaximumQueueDepthForTrackID(SourceBuffer&amp; buffer, const AtomString&amp; trackID, size_t maxQueueDepth)
3760 {
3761     buffer.setMaximumQueueDepthForTrackID(trackID, maxQueueDepth);
3762 }
3763 
3764 #endif
3765 
3766 void Internals::enableMockMediaCapabilities()
3767 {
3768     MediaEngineConfigurationFactory::enableMock();
3769 }
3770 
3771 #if ENABLE(VIDEO)
3772 
3773 ExceptionOr&lt;void&gt; Internals::beginMediaSessionInterruption(const String&amp; interruptionString)
3774 {
3775     PlatformMediaSession::InterruptionType interruption = PlatformMediaSession::SystemInterruption;
3776 
3777     if (equalLettersIgnoringASCIICase(interruptionString, &quot;system&quot;))
3778         interruption = PlatformMediaSession::SystemInterruption;
3779     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;systemsleep&quot;))
3780         interruption = PlatformMediaSession::SystemSleep;
3781     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;enteringbackground&quot;))
3782         interruption = PlatformMediaSession::EnteringBackground;
3783     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;suspendedunderlock&quot;))
3784         interruption = PlatformMediaSession::SuspendedUnderLock;
3785     else
3786         return Exception { InvalidAccessError };
3787 
3788     PlatformMediaSessionManager::sharedManager().beginInterruption(interruption);
3789     return { };
3790 }
3791 
3792 void Internals::endMediaSessionInterruption(const String&amp; flagsString)
3793 {
3794     PlatformMediaSession::EndInterruptionFlags flags = PlatformMediaSession::NoFlags;
3795 
3796     if (equalLettersIgnoringASCIICase(flagsString, &quot;mayresumeplaying&quot;))
3797         flags = PlatformMediaSession::MayResumePlaying;
3798 
3799     PlatformMediaSessionManager::sharedManager().endInterruption(flags);
3800 }
3801 
3802 void Internals::applicationWillBecomeInactive()
3803 {
3804     PlatformMediaSessionManager::sharedManager().applicationWillBecomeInactive();
3805 }
3806 
3807 void Internals::applicationDidBecomeActive()
3808 {
3809     PlatformMediaSessionManager::sharedManager().applicationDidBecomeActive();
3810 }
3811 
3812 void Internals::applicationWillEnterForeground(bool suspendedUnderLock) const
3813 {
3814     PlatformMediaSessionManager::sharedManager().applicationWillEnterForeground(suspendedUnderLock);
3815 }
3816 
3817 void Internals::applicationDidEnterBackground(bool suspendedUnderLock) const
3818 {
3819     PlatformMediaSessionManager::sharedManager().applicationDidEnterBackground(suspendedUnderLock);
3820 }
3821 
3822 static PlatformMediaSession::MediaType mediaTypeFromString(const String&amp; mediaTypeString)
3823 {
3824     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;video&quot;))
3825         return PlatformMediaSession::Video;
3826     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;audio&quot;))
3827         return PlatformMediaSession::Audio;
3828     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;videoaudio&quot;))
3829         return PlatformMediaSession::VideoAudio;
3830     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;webaudio&quot;))
3831         return PlatformMediaSession::WebAudio;
3832     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;mediastreamcapturingaudio&quot;))
3833         return PlatformMediaSession::MediaStreamCapturingAudio;
3834 
3835     return PlatformMediaSession::None;
3836 }
3837 
3838 ExceptionOr&lt;void&gt; Internals::setMediaSessionRestrictions(const String&amp; mediaTypeString, StringView restrictionsString)
3839 {
3840     PlatformMediaSession::MediaType mediaType = mediaTypeFromString(mediaTypeString);
3841     if (mediaType == PlatformMediaSession::None)
3842         return Exception { InvalidAccessError };
3843 
3844     PlatformMediaSessionManager::SessionRestrictions restrictions = PlatformMediaSessionManager::sharedManager().restrictions(mediaType);
3845     PlatformMediaSessionManager::sharedManager().removeRestriction(mediaType, restrictions);
3846 
3847     restrictions = PlatformMediaSessionManager::NoRestrictions;
3848 
3849     for (StringView restrictionString : restrictionsString.split(&#39;,&#39;)) {
3850         if (equalLettersIgnoringASCIICase(restrictionString, &quot;concurrentplaybacknotpermitted&quot;))
3851             restrictions |= PlatformMediaSessionManager::ConcurrentPlaybackNotPermitted;
3852         if (equalLettersIgnoringASCIICase(restrictionString, &quot;backgroundprocessplaybackrestricted&quot;))
3853             restrictions |= PlatformMediaSessionManager::BackgroundProcessPlaybackRestricted;
3854         if (equalLettersIgnoringASCIICase(restrictionString, &quot;backgroundtabplaybackrestricted&quot;))
3855             restrictions |= PlatformMediaSessionManager::BackgroundTabPlaybackRestricted;
3856         if (equalLettersIgnoringASCIICase(restrictionString, &quot;interruptedplaybacknotpermitted&quot;))
3857             restrictions |= PlatformMediaSessionManager::InterruptedPlaybackNotPermitted;
3858         if (equalLettersIgnoringASCIICase(restrictionString, &quot;inactiveprocessplaybackrestricted&quot;))
3859             restrictions |= PlatformMediaSessionManager::InactiveProcessPlaybackRestricted;
3860         if (equalLettersIgnoringASCIICase(restrictionString, &quot;suspendedunderlockplaybackrestricted&quot;))
3861             restrictions |= PlatformMediaSessionManager::SuspendedUnderLockPlaybackRestricted;
3862     }
3863     PlatformMediaSessionManager::sharedManager().addRestriction(mediaType, restrictions);
3864     return { };
3865 }
3866 
3867 ExceptionOr&lt;String&gt; Internals::mediaSessionRestrictions(const String&amp; mediaTypeString) const
3868 {
3869     PlatformMediaSession::MediaType mediaType = mediaTypeFromString(mediaTypeString);
3870     if (mediaType == PlatformMediaSession::None)
3871         return Exception { InvalidAccessError };
3872 
3873     PlatformMediaSessionManager::SessionRestrictions restrictions = PlatformMediaSessionManager::sharedManager().restrictions(mediaType);
3874     if (restrictions == PlatformMediaSessionManager::NoRestrictions)
3875         return String();
3876 
3877     StringBuilder builder;
3878     if (restrictions &amp; PlatformMediaSessionManager::ConcurrentPlaybackNotPermitted)
3879         builder.append(&quot;concurrentplaybacknotpermitted&quot;);
3880     if (restrictions &amp; PlatformMediaSessionManager::BackgroundProcessPlaybackRestricted) {
3881         if (!builder.isEmpty())
3882             builder.append(&#39;,&#39;);
3883         builder.append(&quot;backgroundprocessplaybackrestricted&quot;);
3884     }
3885     if (restrictions &amp; PlatformMediaSessionManager::BackgroundTabPlaybackRestricted) {
3886         if (!builder.isEmpty())
3887             builder.append(&#39;,&#39;);
3888         builder.append(&quot;backgroundtabplaybackrestricted&quot;);
3889     }
3890     if (restrictions &amp; PlatformMediaSessionManager::InterruptedPlaybackNotPermitted) {
3891         if (!builder.isEmpty())
3892             builder.append(&#39;,&#39;);
3893         builder.append(&quot;interruptedplaybacknotpermitted&quot;);
3894     }
3895     return builder.toString();
3896 }
3897 
3898 void Internals::setMediaElementRestrictions(HTMLMediaElement&amp; element, StringView restrictionsString)
3899 {
3900     MediaElementSession::BehaviorRestrictions restrictions = element.mediaSession().behaviorRestrictions();
3901     element.mediaSession().removeBehaviorRestriction(restrictions);
3902 
3903     restrictions = MediaElementSession::NoRestrictions;
3904 
3905     for (StringView restrictionString : restrictionsString.split(&#39;,&#39;)) {
3906         if (equalLettersIgnoringASCIICase(restrictionString, &quot;norestrictions&quot;))
3907             restrictions |= MediaElementSession::NoRestrictions;
3908         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforload&quot;))
3909             restrictions |= MediaElementSession::RequireUserGestureForLoad;
3910         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforvideoratechange&quot;))
3911             restrictions |= MediaElementSession::RequireUserGestureForVideoRateChange;
3912         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforfullscreen&quot;))
3913             restrictions |= MediaElementSession::RequireUserGestureForFullscreen;
3914         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsenttoloadmedia&quot;))
3915             restrictions |= MediaElementSession::RequirePageConsentToLoadMedia;
3916         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsenttoresumemedia&quot;))
3917             restrictions |= MediaElementSession::RequirePageConsentToResumeMedia;
3918 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
3919         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergesturetoshowplaybacktargetpicker&quot;))
3920             restrictions |= MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker;
3921         if (equalLettersIgnoringASCIICase(restrictionString, &quot;wirelessvideoplaybackdisabled&quot;))
3922             restrictions |= MediaElementSession::WirelessVideoPlaybackDisabled;
3923 #endif
3924         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforaudioratechange&quot;))
3925             restrictions |= MediaElementSession::RequireUserGestureForAudioRateChange;
3926         if (equalLettersIgnoringASCIICase(restrictionString, &quot;autopreloadingnotpermitted&quot;))
3927             restrictions |= MediaElementSession::AutoPreloadingNotPermitted;
3928         if (equalLettersIgnoringASCIICase(restrictionString, &quot;invisibleautoplaynotpermitted&quot;))
3929             restrictions |= MediaElementSession::InvisibleAutoplayNotPermitted;
3930         if (equalLettersIgnoringASCIICase(restrictionString, &quot;overrideusergesturerequirementformaincontent&quot;))
3931             restrictions |= MediaElementSession::OverrideUserGestureRequirementForMainContent;
3932     }
3933     element.mediaSession().addBehaviorRestriction(restrictions);
3934 }
3935 
3936 ExceptionOr&lt;void&gt; Internals::postRemoteControlCommand(const String&amp; commandString, float argument)
3937 {
3938     PlatformMediaSession::RemoteControlCommandType command;
3939     PlatformMediaSession::RemoteCommandArgument parameter { argument };
3940 
3941     if (equalLettersIgnoringASCIICase(commandString, &quot;play&quot;))
3942         command = PlatformMediaSession::PlayCommand;
3943     else if (equalLettersIgnoringASCIICase(commandString, &quot;pause&quot;))
3944         command = PlatformMediaSession::PauseCommand;
3945     else if (equalLettersIgnoringASCIICase(commandString, &quot;stop&quot;))
3946         command = PlatformMediaSession::StopCommand;
3947     else if (equalLettersIgnoringASCIICase(commandString, &quot;toggleplaypause&quot;))
3948         command = PlatformMediaSession::TogglePlayPauseCommand;
3949     else if (equalLettersIgnoringASCIICase(commandString, &quot;beginseekingbackward&quot;))
3950         command = PlatformMediaSession::BeginSeekingBackwardCommand;
3951     else if (equalLettersIgnoringASCIICase(commandString, &quot;endseekingbackward&quot;))
3952         command = PlatformMediaSession::EndSeekingBackwardCommand;
3953     else if (equalLettersIgnoringASCIICase(commandString, &quot;beginseekingforward&quot;))
3954         command = PlatformMediaSession::BeginSeekingForwardCommand;
3955     else if (equalLettersIgnoringASCIICase(commandString, &quot;endseekingforward&quot;))
3956         command = PlatformMediaSession::EndSeekingForwardCommand;
3957     else if (equalLettersIgnoringASCIICase(commandString, &quot;seektoplaybackposition&quot;))
3958         command = PlatformMediaSession::SeekToPlaybackPositionCommand;
3959     else
3960         return Exception { InvalidAccessError };
3961 
3962     PlatformMediaSessionManager::sharedManager().didReceiveRemoteControlCommand(command, &amp;parameter);
3963     return { };
3964 }
3965 
3966 bool Internals::elementIsBlockingDisplaySleep(HTMLMediaElement&amp; element) const
3967 {
3968     return element.isDisablingSleep();
3969 }
3970 
3971 #endif // ENABLE(VIDEO)
3972 
3973 #if ENABLE(MEDIA_SESSION)
3974 
3975 void Internals::sendMediaSessionStartOfInterruptionNotification(MediaSessionInterruptingCategory category)
3976 {
3977     MediaSessionManager::singleton().didReceiveStartOfInterruptionNotification(category);
3978 }
3979 
3980 void Internals::sendMediaSessionEndOfInterruptionNotification(MediaSessionInterruptingCategory category)
3981 {
3982     MediaSessionManager::singleton().didReceiveEndOfInterruptionNotification(category);
3983 }
3984 
3985 String Internals::mediaSessionCurrentState(MediaSession* session) const
3986 {
3987     switch (session-&gt;currentState()) {
3988     case MediaSession::State::Active:
3989         return &quot;active&quot;;
3990     case MediaSession::State::Interrupted:
3991         return &quot;interrupted&quot;;
3992     case MediaSession::State::Idle:
3993         return &quot;idle&quot;;
3994     }
3995 }
3996 
3997 double Internals::mediaElementPlayerVolume(HTMLMediaElement* element) const
3998 {
3999     ASSERT_ARG(element, element);
4000     return element-&gt;playerVolume();
4001 }
4002 
4003 void Internals::sendMediaControlEvent(MediaControlEvent event)
4004 {
4005     // FIXME: No good reason to use a single function with an argument instead of three functions.
4006     switch (event) {
4007     case MediControlEvent::PlayPause:
4008         MediaSessionManager::singleton().togglePlayback();
4009         break;
4010     case MediControlEvent::NextTrack:
4011         MediaSessionManager::singleton().skipToNextTrack();
4012         break;
4013     case MediControlEvent::PreviousTrack:
4014         MediaSessionManager::singleton().skipToPreviousTrack();
4015         break;
4016     }
4017 }
4018 
4019 #endif // ENABLE(MEDIA_SESSION)
4020 
4021 #if ENABLE(WEB_AUDIO)
4022 
4023 void Internals::setAudioContextRestrictions(AudioContext&amp; context, StringView restrictionsString)
4024 {
4025     AudioContext::BehaviorRestrictions restrictions = context.behaviorRestrictions();
4026     context.removeBehaviorRestriction(restrictions);
4027 
4028     restrictions = AudioContext::NoRestrictions;
4029 
4030     for (StringView restrictionString : restrictionsString.split(&#39;,&#39;)) {
4031         if (equalLettersIgnoringASCIICase(restrictionString, &quot;norestrictions&quot;))
4032             restrictions |= AudioContext::NoRestrictions;
4033         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforaudiostart&quot;))
4034             restrictions |= AudioContext::RequireUserGestureForAudioStartRestriction;
4035         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsentforaudiostart&quot;))
4036             restrictions |= AudioContext::RequirePageConsentForAudioStartRestriction;
4037     }
4038     context.addBehaviorRestriction(restrictions);
4039 }
4040 
4041 #endif
4042 
4043 void Internals::simulateSystemSleep() const
4044 {
4045 #if ENABLE(VIDEO)
4046     PlatformMediaSessionManager::sharedManager().systemWillSleep();
4047 #endif
4048 }
4049 
4050 void Internals::simulateSystemWake() const
4051 {
4052 #if ENABLE(VIDEO)
4053     PlatformMediaSessionManager::sharedManager().systemDidWake();
4054 #endif
4055 }
4056 
4057 ExceptionOr&lt;Internals::NowPlayingState&gt; Internals::nowPlayingState() const
4058 {
4059 #if ENABLE(VIDEO)
4060     return { { PlatformMediaSessionManager::sharedManager().lastUpdatedNowPlayingTitle(),
4061         PlatformMediaSessionManager::sharedManager().lastUpdatedNowPlayingDuration(),
4062         PlatformMediaSessionManager::sharedManager().lastUpdatedNowPlayingElapsedTime(),
4063         PlatformMediaSessionManager::sharedManager().lastUpdatedNowPlayingInfoUniqueIdentifier(),
4064         PlatformMediaSessionManager::sharedManager().hasActiveNowPlayingSession(),
4065         PlatformMediaSessionManager::sharedManager().registeredAsNowPlayingApplication()
4066     } };
4067 #else
4068     return Exception { InvalidAccessError };
4069 #endif
4070 }
4071 
4072 #if ENABLE(VIDEO)
4073 RefPtr&lt;HTMLMediaElement&gt; Internals::bestMediaElementForShowingPlaybackControlsManager(Internals::PlaybackControlsPurpose purpose)
4074 {
4075     return HTMLMediaElement::bestMediaElementForShowingPlaybackControlsManager(purpose);
4076 }
4077 
4078 Internals::MediaSessionState Internals::mediaSessionState(HTMLMediaElement&amp; element)
4079 {
4080     return element.mediaSession().state();
4081 }
4082 #endif
4083 
4084 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
4085 
4086 void Internals::setMockMediaPlaybackTargetPickerEnabled(bool enabled)
4087 {
4088     Page* page = contextDocument()-&gt;frame()-&gt;page();
4089     ASSERT(page);
4090 
4091     page-&gt;setMockMediaPlaybackTargetPickerEnabled(enabled);
4092 }
4093 
4094 ExceptionOr&lt;void&gt; Internals::setMockMediaPlaybackTargetPickerState(const String&amp; deviceName, const String&amp; deviceState)
4095 {
4096     Page* page = contextDocument()-&gt;frame()-&gt;page();
4097     ASSERT(page);
4098 
4099     MediaPlaybackTargetContext::State state = MediaPlaybackTargetContext::Unknown;
4100 
4101     if (equalLettersIgnoringASCIICase(deviceState, &quot;deviceavailable&quot;))
4102         state = MediaPlaybackTargetContext::OutputDeviceAvailable;
4103     else if (equalLettersIgnoringASCIICase(deviceState, &quot;deviceunavailable&quot;))
4104         state = MediaPlaybackTargetContext::OutputDeviceUnavailable;
4105     else if (equalLettersIgnoringASCIICase(deviceState, &quot;unknown&quot;))
4106         state = MediaPlaybackTargetContext::Unknown;
4107     else
4108         return Exception { InvalidAccessError };
4109 
4110     page-&gt;setMockMediaPlaybackTargetPickerState(deviceName, state);
4111     return { };
4112 }
4113 
4114 #endif
4115 
4116 ExceptionOr&lt;Ref&lt;MockPageOverlay&gt;&gt; Internals::installMockPageOverlay(PageOverlayType type)
4117 {
4118     Document* document = contextDocument();
4119     if (!document || !document-&gt;page())
4120         return Exception { InvalidAccessError };
4121 
4122     return MockPageOverlayClient::singleton().installOverlay(*document-&gt;page(), type == PageOverlayType::View ? PageOverlay::OverlayType::View : PageOverlay::OverlayType::Document);
4123 }
4124 
4125 ExceptionOr&lt;String&gt; Internals::pageOverlayLayerTreeAsText(unsigned short flags) const
4126 {
4127     Document* document = contextDocument();
4128     if (!document || !document-&gt;page())
4129         return Exception { InvalidAccessError };
4130 
4131     document-&gt;updateLayoutIgnorePendingStylesheets();
4132 
4133     return MockPageOverlayClient::singleton().layerTreeAsText(*document-&gt;page(), toLayerTreeFlags(flags));
4134 }
4135 
4136 void Internals::setPageMuted(StringView statesString)
4137 {
4138     Document* document = contextDocument();
4139     if (!document)
4140         return;
4141 
4142     WebCore::MediaProducer::MutedStateFlags state = MediaProducer::NoneMuted;
4143     for (StringView stateString : statesString.split(&#39;,&#39;)) {
4144         if (equalLettersIgnoringASCIICase(stateString, &quot;audio&quot;))
4145             state |= MediaProducer::AudioIsMuted;
4146         if (equalLettersIgnoringASCIICase(stateString, &quot;capturedevices&quot;))
4147             state |= MediaProducer::AudioAndVideoCaptureIsMuted;
4148         if (equalLettersIgnoringASCIICase(stateString, &quot;screencapture&quot;))
4149             state |= MediaProducer::ScreenCaptureIsMuted;
4150     }
4151 
4152     if (Page* page = document-&gt;page())
4153         page-&gt;setMuted(state);
4154 }
4155 
4156 String Internals::pageMediaState()
4157 {
4158     Document* document = contextDocument();
4159     if (!document || !document-&gt;page())
4160         return emptyString();
4161 
4162     WebCore::MediaProducer::MediaStateFlags state = document-&gt;page()-&gt;mediaState();
4163     StringBuilder string;
4164     if (state &amp; MediaProducer::IsPlayingAudio)
4165         string.append(&quot;IsPlayingAudio,&quot;);
4166     if (state &amp; MediaProducer::IsPlayingVideo)
4167         string.append(&quot;IsPlayingVideo,&quot;);
4168     if (state &amp; MediaProducer::IsPlayingToExternalDevice)
4169         string.append(&quot;IsPlayingToExternalDevice,&quot;);
4170     if (state &amp; MediaProducer::RequiresPlaybackTargetMonitoring)
4171         string.append(&quot;RequiresPlaybackTargetMonitoring,&quot;);
4172     if (state &amp; MediaProducer::ExternalDeviceAutoPlayCandidate)
4173         string.append(&quot;ExternalDeviceAutoPlayCandidate,&quot;);
4174     if (state &amp; MediaProducer::DidPlayToEnd)
4175         string.append(&quot;DidPlayToEnd,&quot;);
4176     if (state &amp; MediaProducer::IsSourceElementPlaying)
4177         string.append(&quot;IsSourceElementPlaying,&quot;);
4178 
4179     if (state &amp; MediaProducer::IsNextTrackControlEnabled)
4180         string.append(&quot;IsNextTrackControlEnabled,&quot;);
4181     if (state &amp; MediaProducer::IsPreviousTrackControlEnabled)
4182         string.append(&quot;IsPreviousTrackControlEnabled,&quot;);
4183 
4184     if (state &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
4185         string.append(&quot;HasPlaybackTargetAvailabilityListener,&quot;);
4186     if (state &amp; MediaProducer::HasAudioOrVideo)
4187         string.append(&quot;HasAudioOrVideo,&quot;);
4188     if (state &amp; MediaProducer::HasActiveAudioCaptureDevice)
4189         string.append(&quot;HasActiveAudioCaptureDevice,&quot;);
4190     if (state &amp; MediaProducer::HasActiveVideoCaptureDevice)
4191         string.append(&quot;HasActiveVideoCaptureDevice,&quot;);
4192     if (state &amp; MediaProducer::HasMutedAudioCaptureDevice)
4193         string.append(&quot;HasMutedAudioCaptureDevice,&quot;);
4194     if (state &amp; MediaProducer::HasMutedVideoCaptureDevice)
4195         string.append(&quot;HasMutedVideoCaptureDevice,&quot;);
4196     if (state &amp; MediaProducer::HasUserInteractedWithMediaElement)
4197         string.append(&quot;HasUserInteractedWithMediaElement,&quot;);
4198     if (state &amp; MediaProducer::HasActiveDisplayCaptureDevice)
4199         string.append(&quot;HasActiveDisplayCaptureDevice,&quot;);
4200     if (state &amp; MediaProducer::HasMutedDisplayCaptureDevice)
4201         string.append(&quot;HasMutedDisplayCaptureDevice,&quot;);
4202 
4203     if (string.isEmpty())
4204         string.append(&quot;IsNotPlaying&quot;);
4205     else
4206         string.resize(string.length() - 1);
4207 
4208     return string.toString();
4209 }
4210 
4211 void Internals::setPageDefersLoading(bool defersLoading)
4212 {
4213     Document* document = contextDocument();
4214     if (!document)
4215         return;
4216     if (Page* page = document-&gt;page())
4217         page-&gt;setDefersLoading(defersLoading);
4218 }
4219 
4220 ExceptionOr&lt;bool&gt; Internals::pageDefersLoading()
4221 {
4222     Document* document = contextDocument();
4223     if (!document || !document-&gt;page())
4224         return Exception { InvalidAccessError };
4225     return document-&gt;page()-&gt;defersLoading();
4226 }
4227 
4228 RefPtr&lt;File&gt; Internals::createFile(const String&amp; path)
4229 {
4230     Document* document = contextDocument();
4231     if (!document)
4232         return nullptr;
4233 
4234     URL url = document-&gt;completeURL(path);
4235     if (!url.isLocalFile())
4236         return nullptr;
4237 
4238     return File::create(document-&gt;sessionID(), url.fileSystemPath());
4239 }
4240 
4241 void Internals::queueMicroTask(int testNumber)
4242 {
4243     Document* document = contextDocument();
4244     if (!document)
4245         return;
4246 
4247     auto microtask = makeUnique&lt;ActiveDOMCallbackMicrotask&gt;(MicrotaskQueue::mainThreadQueue(), *document, [document, testNumber]() {
4248         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Debug, makeString(&quot;MicroTask #&quot;, testNumber, &quot; has run.&quot;));
4249     });
4250 
4251     MicrotaskQueue::mainThreadQueue().append(WTFMove(microtask));
4252 }
4253 
4254 #if ENABLE(CONTENT_FILTERING)
4255 
4256 MockContentFilterSettings&amp; Internals::mockContentFilterSettings()
4257 {
4258     return MockContentFilterSettings::singleton();
4259 }
4260 
4261 #endif
4262 
4263 #if ENABLE(CSS_SCROLL_SNAP)
4264 
4265 static void appendOffsets(StringBuilder&amp; builder, const Vector&lt;LayoutUnit&gt;&amp; snapOffsets)
4266 {
4267     bool justStarting = true;
4268 
4269     builder.appendLiteral(&quot;{ &quot;);
4270     for (auto&amp; coordinate : snapOffsets) {
4271         if (!justStarting)
4272             builder.appendLiteral(&quot;, &quot;);
4273         else
4274             justStarting = false;
4275 
4276         builder.appendNumber(coordinate.toUnsigned());
4277     }
4278     builder.appendLiteral(&quot; }&quot;);
4279 }
4280 
4281 void Internals::setPlatformMomentumScrollingPredictionEnabled(bool enabled)
4282 {
4283     ScrollingMomentumCalculator::setPlatformMomentumScrollingPredictionEnabled(enabled);
4284 }
4285 
4286 ExceptionOr&lt;String&gt; Internals::scrollSnapOffsets(Element&amp; element)
4287 {
4288     element.document().updateLayoutIgnorePendingStylesheets();
4289 
4290     if (!element.renderBox())
4291         return String();
4292 
4293     RenderBox&amp; box = *element.renderBox();
4294     ScrollableArea* scrollableArea;
4295 
4296     if (box.isBody()) {
4297         FrameView* frameView = box.frame().mainFrame().view();
4298         if (!frameView || !frameView-&gt;isScrollable())
4299             return Exception { InvalidAccessError };
4300         scrollableArea = frameView;
4301 
4302     } else {
4303         if (!box.canBeScrolledAndHasScrollableArea())
4304             return Exception { InvalidAccessError };
4305         scrollableArea = box.layer();
4306     }
4307 
4308     if (!scrollableArea)
4309         return String();
4310 
4311     StringBuilder result;
4312 
4313     if (auto* offsets = scrollableArea-&gt;horizontalSnapOffsets()) {
4314         if (offsets-&gt;size()) {
4315             result.appendLiteral(&quot;horizontal = &quot;);
4316             appendOffsets(result, *offsets);
4317         }
4318     }
4319 
4320     if (auto* offsets = scrollableArea-&gt;verticalSnapOffsets()) {
4321         if (offsets-&gt;size()) {
4322             if (result.length())
4323                 result.appendLiteral(&quot;, &quot;);
4324 
4325             result.appendLiteral(&quot;vertical = &quot;);
4326             appendOffsets(result, *offsets);
4327         }
4328     }
4329 
4330     return result.toString();
4331 }
4332 
4333 #endif
4334 
4335 bool Internals::testPreloaderSettingViewport()
4336 {
4337     return testPreloadScannerViewportSupport(contextDocument());
4338 }
4339 
4340 ExceptionOr&lt;String&gt; Internals::pathStringWithShrinkWrappedRects(const Vector&lt;double&gt;&amp; rectComponents, double radius)
4341 {
4342     if (rectComponents.size() % 4)
4343         return Exception { InvalidAccessError };
4344 
4345     Vector&lt;FloatRect&gt; rects;
4346     for (unsigned i = 0; i &lt; rectComponents.size(); i += 4)
4347         rects.append(FloatRect(rectComponents[i], rectComponents[i + 1], rectComponents[i + 2], rectComponents[i + 3]));
4348 
4349     SVGPathStringBuilder builder;
4350     PathUtilities::pathWithShrinkWrappedRects(rects, radius).apply([&amp;builder](const PathElement&amp; element) {
4351         switch (element.type) {
4352         case PathElementMoveToPoint:
4353             builder.moveTo(element.points[0], false, AbsoluteCoordinates);
4354             return;
4355         case PathElementAddLineToPoint:
4356             builder.lineTo(element.points[0], AbsoluteCoordinates);
4357             return;
4358         case PathElementAddQuadCurveToPoint:
4359             builder.curveToQuadratic(element.points[0], element.points[1], AbsoluteCoordinates);
4360             return;
4361         case PathElementAddCurveToPoint:
4362             builder.curveToCubic(element.points[0], element.points[1], element.points[2], AbsoluteCoordinates);
4363             return;
4364         case PathElementCloseSubpath:
4365             builder.closePath();
4366             return;
4367         }
4368         ASSERT_NOT_REACHED();
4369     });
4370     return builder.result();
4371 }
4372 
4373 
4374 String Internals::getCurrentMediaControlsStatusForElement(HTMLMediaElement&amp; mediaElement)
4375 {
4376 #if !ENABLE(MEDIA_CONTROLS_SCRIPT)
4377     UNUSED_PARAM(mediaElement);
4378     return String();
4379 #else
4380     return mediaElement.getCurrentMediaControlsStatus();
4381 #endif
4382 }
4383 
4384 #if !PLATFORM(COCOA)
4385 
4386 String Internals::userVisibleString(const DOMURL&amp; url)
4387 {
4388     return WTF::URLHelpers::userVisibleURL(url.href().string().utf8());
4389 }
4390 
4391 #endif
4392 
4393 void Internals::setShowAllPlugins(bool show)
4394 {
4395     Document* document = contextDocument();
4396     if (!document)
4397         return;
4398 
4399     Page* page = document-&gt;page();
4400     if (!page)
4401         return;
4402 
4403     page-&gt;setShowAllPlugins(show);
4404 }
4405 
4406 #if ENABLE(STREAMS_API)
4407 
4408 bool Internals::isReadableStreamDisturbed(JSC::ExecState&amp; state, JSValue stream)
4409 {
4410     return ReadableStream::isDisturbed(state, stream);
4411 }
4412 
4413 JSValue Internals::cloneArrayBuffer(JSC::ExecState&amp; state, JSValue buffer, JSValue srcByteOffset, JSValue srcLength)
4414 {
4415     JSC::VM&amp; vm = state.vm();
4416     JSGlobalObject* globalObject = vm.vmEntryGlobalObject(&amp;state);
4417     JSVMClientData* clientData = static_cast&lt;JSVMClientData*&gt;(vm.clientData);
4418     const Identifier&amp; privateName = clientData-&gt;builtinNames().cloneArrayBufferPrivateName();
4419     JSValue value;
4420     PropertySlot propertySlot(value, PropertySlot::InternalMethodType::Get);
4421     globalObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(globalObject, &amp;state, privateName, propertySlot);
4422     value = propertySlot.getValue(&amp;state, privateName);
4423     ASSERT(value.isFunction(vm));
4424 
4425     JSObject* function = value.getObject();
4426     CallData callData;
4427     CallType callType = JSC::getCallData(vm, function, callData);
4428     ASSERT(callType != JSC::CallType::None);
4429     MarkedArgumentBuffer arguments;
4430     arguments.append(buffer);
4431     arguments.append(srcByteOffset);
4432     arguments.append(srcLength);
4433     ASSERT(!arguments.hasOverflowed());
4434 
4435     return JSC::call(&amp;state, function, callType, callData, JSC::jsUndefined(), arguments);
4436 }
4437 
4438 #endif
4439 
4440 String Internals::resourceLoadStatisticsForURL(const DOMURL&amp; url)
4441 {
4442     auto* document = contextDocument();
4443     if (!document)
4444         return emptyString();
4445 
4446     return ResourceLoadObserver::shared().statisticsForURL(document-&gt;sessionID(), url.href());
4447 }
4448 
4449 void Internals::setResourceLoadStatisticsEnabled(bool enable)
4450 {
4451     DeprecatedGlobalSettings::setResourceLoadStatisticsEnabled(enable);
4452 }
4453 
4454 String Internals::composedTreeAsText(Node&amp; node)
4455 {
4456     if (!is&lt;ContainerNode&gt;(node))
4457         return emptyString();
4458     return WebCore::composedTreeAsText(downcast&lt;ContainerNode&gt;(node));
4459 }
4460 
4461 bool Internals::isProcessingUserGesture()
4462 {
4463     return UserGestureIndicator::processingUserGesture();
4464 }
4465 
4466 void Internals::withUserGesture(RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)
4467 {
4468     UserGestureIndicator gestureIndicator(ProcessingUserGesture, contextDocument());
4469     callback-&gt;handleEvent();
4470 }
4471 
4472 bool Internals::userIsInteracting()
4473 {
4474     if (auto* document = contextDocument()) {
4475         if (auto* page = document-&gt;page())
4476             return page-&gt;chrome().client().userIsInteracting();
4477     }
4478     return false;
4479 }
4480 
4481 double Internals::lastHandledUserGestureTimestamp()
4482 {
4483     Document* document = contextDocument();
4484     if (!document)
4485         return 0;
4486 
4487     return document-&gt;lastHandledUserGestureTimestamp().secondsSinceEpoch().value();
4488 }
4489 
4490 RefPtr&lt;GCObservation&gt; Internals::observeGC(JSC::JSValue value)
4491 {
4492     if (!value.isObject())
4493         return nullptr;
4494     return GCObservation::create(asObject(value));
4495 }
4496 
4497 void Internals::setUserInterfaceLayoutDirection(UserInterfaceLayoutDirection userInterfaceLayoutDirection)
4498 {
4499     Document* document = contextDocument();
4500     if (!document)
4501         return;
4502 
4503     Page* page = document-&gt;page();
4504     if (!page)
4505         return;
4506 
4507     page-&gt;setUserInterfaceLayoutDirection(userInterfaceLayoutDirection == UserInterfaceLayoutDirection::LTR ? WebCore::UserInterfaceLayoutDirection::LTR : WebCore::UserInterfaceLayoutDirection::RTL);
4508 }
4509 
4510 #if !PLATFORM(COCOA)
4511 
4512 bool Internals::userPrefersReducedMotion() const
4513 {
4514     return false;
4515 }
4516 
4517 #if ENABLE(VIDEO)
4518 double Internals::privatePlayerVolume(const HTMLMediaElement&amp;)
4519 {
4520     return 0;
4521 }
4522 #endif
4523 
4524 #endif
4525 
4526 void Internals::reportBacktrace()
4527 {
4528     WTFReportBacktrace();
4529 }
4530 
4531 void Internals::setBaseWritingDirection(BaseWritingDirection direction)
4532 {
4533     if (auto* document = contextDocument()) {
4534         if (auto* frame = document-&gt;frame()) {
4535             switch (direction) {
4536             case BaseWritingDirection::Ltr:
4537                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::LeftToRight);
4538                 break;
4539             case BaseWritingDirection::Rtl:
4540                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::RightToLeft);
4541                 break;
4542             case BaseWritingDirection::Natural:
4543                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::Natural);
4544                 break;
4545             }
4546         }
4547     }
4548 }
4549 
4550 #if ENABLE(POINTER_LOCK)
4551 bool Internals::pageHasPendingPointerLock() const
4552 {
4553     Document* document = contextDocument();
4554     if (!document)
4555         return false;
4556 
4557     Page* page = document-&gt;page();
4558     if (!page)
4559         return false;
4560 
4561     return page-&gt;pointerLockController().lockPending();
4562 }
4563 
4564 bool Internals::pageHasPointerLock() const
4565 {
4566     Document* document = contextDocument();
4567     if (!document)
4568         return false;
4569 
4570     Page* page = document-&gt;page();
4571     if (!page)
4572         return false;
4573 
4574     auto&amp; controller = page-&gt;pointerLockController();
4575     return controller.element() &amp;&amp; !controller.lockPending();
4576 }
4577 #endif
4578 
4579 void Internals::markContextAsInsecure()
4580 {
4581     auto* document = contextDocument();
4582     if (!document)
4583         return;
4584 
4585     document-&gt;securityOrigin().setIsPotentiallyTrustworthy(false);
4586 }
4587 
4588 void Internals::postTask(RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)
4589 {
4590     auto* document = contextDocument();
4591     if (!document) {
4592         callback-&gt;handleEvent();
4593         return;
4594     }
4595 
4596     document-&gt;postTask([callback = WTFMove(callback)](ScriptExecutionContext&amp;) {
4597         callback-&gt;handleEvent();
4598     });
4599 }
4600 
4601 Vector&lt;String&gt; Internals::accessKeyModifiers() const
4602 {
4603     Vector&lt;String&gt; accessKeyModifierStrings;
4604 
4605     for (auto modifier : EventHandler::accessKeyModifiers()) {
4606         switch (modifier) {
4607         case PlatformEvent::Modifier::AltKey:
4608             accessKeyModifierStrings.append(&quot;altKey&quot;_s);
4609             break;
4610         case PlatformEvent::Modifier::ControlKey:
4611             accessKeyModifierStrings.append(&quot;ctrlKey&quot;_s);
4612             break;
4613         case PlatformEvent::Modifier::MetaKey:
4614             accessKeyModifierStrings.append(&quot;metaKey&quot;_s);
4615             break;
4616         case PlatformEvent::Modifier::ShiftKey:
4617             accessKeyModifierStrings.append(&quot;shiftKey&quot;_s);
4618             break;
4619         case PlatformEvent::Modifier::CapsLockKey:
4620             accessKeyModifierStrings.append(&quot;capsLockKey&quot;_s);
4621             break;
4622         case PlatformEvent::Modifier::AltGraphKey:
4623             ASSERT_NOT_REACHED(); // AltGraph is only for DOM API.
4624             break;
4625         }
4626     }
4627 
4628     return accessKeyModifierStrings;
4629 }
4630 
4631 void Internals::setQuickLookPassword(const String&amp; password)
4632 {
4633 #if PLATFORM(IOS_FAMILY) &amp;&amp; USE(QUICK_LOOK)
4634     auto&amp; quickLookHandleClient = MockPreviewLoaderClient::singleton();
4635     PreviewLoader::setClientForTesting(&amp;quickLookHandleClient);
4636     quickLookHandleClient.setPassword(password);
4637 #else
4638     UNUSED_PARAM(password);
4639 #endif
4640 }
4641 
4642 void Internals::setAsRunningUserScripts(Document&amp; document)
4643 {
4644     document.setAsRunningUserScripts();
4645 }
4646 
4647 #if ENABLE(APPLE_PAY)
4648 void Internals::setApplePayIsActive(Document&amp; document)
4649 {
4650     document.setApplePayIsActive();
4651 }
4652 #endif
4653 
4654 #if ENABLE(WEBGL)
4655 void Internals::simulateWebGLContextChanged(WebGLRenderingContext&amp; context)
4656 {
4657     context.simulateContextChanged();
4658 }
4659 
4660 void Internals::failNextGPUStatusCheck(WebGLRenderingContext&amp; context)
4661 {
4662     context.setFailNextGPUStatusCheck();
4663 }
4664 
4665 bool Internals::hasLowAndHighPowerGPUs()
4666 {
4667 #if PLATFORM(MAC)
4668     return WebCore::hasLowAndHighPowerGPUs();
4669 #else
4670     return false;
4671 #endif
4672 }
4673 #endif
4674 
4675 void Internals::setPageVisibility(bool isVisible)
4676 {
4677     auto* document = contextDocument();
4678     if (!document || !document-&gt;page())
4679         return;
4680     auto&amp; page = *document-&gt;page();
4681     auto state = page.activityState();
4682 
4683     if (!isVisible)
4684         state.remove(ActivityState::IsVisible);
4685     else
4686         state.add(ActivityState::IsVisible);
4687 
4688     page.setActivityState(state);
4689 }
4690 
4691 void Internals::setPageIsFocusedAndActive(bool isFocusedAndActive)
4692 {
4693     auto* document = contextDocument();
4694     if (!document || !document-&gt;page())
4695         return;
4696     auto&amp; page = *document-&gt;page();
4697     auto state = page.activityState();
4698 
4699     if (!isFocusedAndActive)
4700         state.remove({ ActivityState::IsFocused, ActivityState::WindowIsActive });
4701     else
4702         state.add({ ActivityState::IsFocused, ActivityState::WindowIsActive });
4703 
4704     page.setActivityState(state);
4705 }
4706 
4707 #if ENABLE(WEB_RTC)
4708 void Internals::setH264HardwareEncoderAllowed(bool allowed)
4709 {
4710     auto* document = contextDocument();
4711     if (!document || !document-&gt;page())
4712         return;
4713     document-&gt;page()-&gt;libWebRTCProvider().setH264HardwareEncoderAllowed(allowed);
4714 }
4715 #endif
4716 
4717 #if ENABLE(MEDIA_STREAM)
4718 void Internals::setMockAudioTrackChannelNumber(MediaStreamTrack&amp; track, unsigned short channelNumber)
4719 {
4720     auto&amp; source = track.source();
4721     if (!is&lt;MockRealtimeAudioSource&gt;(source))
4722         return;
4723     downcast&lt;MockRealtimeAudioSource&gt;(source).setChannelCount(channelNumber);
4724 }
4725 
4726 void Internals::setCameraMediaStreamTrackOrientation(MediaStreamTrack&amp; track, int orientation)
4727 {
4728     auto&amp; source = track.source();
4729     if (!source.isCaptureSource())
4730         return;
4731     m_orientationNotifier.orientationChanged(orientation);
4732     source.monitorOrientation(m_orientationNotifier);
4733 }
4734 
4735 void Internals::observeMediaStreamTrack(MediaStreamTrack&amp; track)
4736 {
4737     m_track = &amp;track;
4738     m_track-&gt;source().addObserver(*this);
4739 }
4740 
4741 void Internals::grabNextMediaStreamTrackFrame(TrackFramePromise&amp;&amp; promise)
4742 {
4743     m_nextTrackFramePromise = WTFMove(promise);
4744 }
4745 
4746 void Internals::videoSampleAvailable(MediaSample&amp; sample)
4747 {
4748     m_trackVideoSampleCount++;
4749     if (!m_nextTrackFramePromise)
4750         return;
4751 
4752     auto&amp; videoSettings = m_track-&gt;source().settings();
4753     if (!videoSettings.width() || !videoSettings.height())
4754         return;
4755 
4756     auto rgba = sample.getRGBAImageData();
4757     if (!rgba)
4758         return;
4759 
4760     auto imageData = ImageData::create(rgba.releaseNonNull(), videoSettings.width(), videoSettings.height());
4761     if (!imageData.hasException())
4762         m_nextTrackFramePromise-&gt;resolve(imageData.releaseReturnValue().releaseNonNull());
4763     else
4764         m_nextTrackFramePromise-&gt;reject(imageData.exception().code());
4765     m_nextTrackFramePromise = WTF::nullopt;
4766 }
4767 
4768 void Internals::delayMediaStreamTrackSamples(MediaStreamTrack&amp; track, float delay)
4769 {
4770     track.source().delaySamples(Seconds { delay });
4771 }
4772 
4773 void Internals::setMediaStreamTrackMuted(MediaStreamTrack&amp; track, bool muted)
4774 {
4775     track.source().setMuted(muted);
4776 }
4777 
4778 void Internals::removeMediaStreamTrack(MediaStream&amp; stream, MediaStreamTrack&amp; track)
4779 {
4780     stream.internalRemoveTrack(track.id(), MediaStream::StreamModifier::Platform);
4781 }
4782 
4783 void Internals::simulateMediaStreamTrackCaptureSourceFailure(MediaStreamTrack&amp; track)
4784 {
4785     track.source().captureFailed();
4786 }
4787 
4788 void Internals::setMediaStreamTrackIdentifier(MediaStreamTrack&amp; track, String&amp;&amp; id)
4789 {
4790     track.setIdForTesting(WTFMove(id));
4791 }
4792 
4793 void Internals::setMediaStreamSourceInterrupted(MediaStreamTrack&amp; track, bool interrupted)
4794 {
4795     track.source().setInterruptedForTesting(interrupted);
4796 }
4797 
4798 void Internals::setDisableGetDisplayMediaUserGestureConstraint(bool value)
4799 {
4800     Document* document = contextDocument();
4801     if (!document || !document-&gt;domWindow())
4802         return;
4803 
4804     if (auto* mediaDevices = NavigatorMediaDevices::mediaDevices(document-&gt;domWindow()-&gt;navigator()))
4805         mediaDevices-&gt;setDisableGetDisplayMediaUserGestureConstraint(value);
4806 }
4807 #endif
4808 
4809 String Internals::audioSessionCategory() const
4810 {
4811 #if USE(AUDIO_SESSION)
4812     switch (AudioSession::sharedSession().category()) {
4813     case AudioSession::AmbientSound:
4814         return &quot;AmbientSound&quot;_s;
4815     case AudioSession::SoloAmbientSound:
4816         return &quot;SoloAmbientSound&quot;_s;
4817     case AudioSession::MediaPlayback:
4818         return &quot;MediaPlayback&quot;_s;
4819     case AudioSession::RecordAudio:
4820         return &quot;RecordAudio&quot;_s;
4821     case AudioSession::PlayAndRecord:
4822         return &quot;PlayAndRecord&quot;_s;
4823     case AudioSession::AudioProcessing:
4824         return &quot;AudioProcessing&quot;_s;
4825     case AudioSession::None:
4826         return &quot;None&quot;_s;
4827     }
4828 #endif
4829     return emptyString();
4830 }
4831 
4832 double Internals::preferredAudioBufferSize() const
4833 {
4834 #if USE(AUDIO_SESSION)
4835     return AudioSession::sharedSession().preferredBufferSize();
4836 #endif
4837     return 0;
4838 }
4839 
4840 bool Internals::audioSessionActive() const
4841 {
4842 #if USE(AUDIO_SESSION)
4843     return AudioSession::sharedSession().isActive();
4844 #endif
4845     return false;
4846 }
4847 
4848 void Internals::storeRegistrationsOnDisk(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
4849 {
4850 #if ENABLE(SERVICE_WORKER)
4851     if (!contextDocument())
4852         return;
4853 
4854     auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(contextDocument()-&gt;sessionID());
4855     connection.storeRegistrationsOnDiskForTesting([promise = WTFMove(promise)]() mutable {
4856         promise.resolve();
4857     });
4858 #else
4859     promise.resolve();
4860 #endif
4861 }
4862 
4863 void Internals::clearCacheStorageMemoryRepresentation(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
4864 {
4865     auto* document = contextDocument();
4866     if (!document)
4867         return;
4868 
4869     if (!m_cacheStorageConnection) {
4870         if (auto* page = contextDocument()-&gt;page())
4871             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection(page-&gt;sessionID());
4872         if (!m_cacheStorageConnection)
4873             return;
4874     }
4875     m_cacheStorageConnection-&gt;clearMemoryRepresentation(ClientOrigin { document-&gt;topOrigin().data(), document-&gt;securityOrigin().data() }, [promise = WTFMove(promise)] (auto &amp;&amp; result) mutable {
4876         ASSERT_UNUSED(result, !result);
4877         promise.resolve();
4878     });
4879 }
4880 
4881 void Internals::cacheStorageEngineRepresentation(DOMPromiseDeferred&lt;IDLDOMString&gt;&amp;&amp; promise)
4882 {
4883     auto* document = contextDocument();
4884     if (!document)
4885         return;
4886 
4887     if (!m_cacheStorageConnection) {
4888         if (auto* page = contextDocument()-&gt;page())
4889             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection(page-&gt;sessionID());
4890         if (!m_cacheStorageConnection)
4891             return;
4892     }
4893     m_cacheStorageConnection-&gt;engineRepresentation([promise = WTFMove(promise)](const String&amp; result) mutable {
4894         promise.resolve(result);
4895     });
4896 }
4897 
4898 void Internals::updateQuotaBasedOnSpaceUsage()
4899 {
4900     auto* document = contextDocument();
4901     if (!document)
4902         return;
4903 
4904     if (!m_cacheStorageConnection) {
4905         if (auto* page = contextDocument()-&gt;page())
4906             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection(page-&gt;sessionID());
4907         if (!m_cacheStorageConnection)
4908             return;
4909     }
4910 
4911     m_cacheStorageConnection-&gt;updateQuotaBasedOnSpaceUsage(ClientOrigin { document-&gt;topOrigin().data(), document-&gt;securityOrigin().data() });
4912 }
4913 
4914 void Internals::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
4915 {
4916     if (!contextDocument())
4917         return;
4918 
4919     contextDocument()-&gt;setConsoleMessageListener(WTFMove(listener));
4920 }
4921 
4922 void Internals::setResponseSizeWithPadding(FetchResponse&amp; response, uint64_t size)
4923 {
4924     response.setBodySizeWithPadding(size);
4925 }
4926 
4927 uint64_t Internals::responseSizeWithPadding(FetchResponse&amp; response) const
4928 {
4929     return response.bodySizeWithPadding();
4930 }
4931 
4932 #if ENABLE(SERVICE_WORKER)
4933 void Internals::hasServiceWorkerRegistration(const String&amp; clientURL, HasRegistrationPromise&amp;&amp; promise)
4934 {
4935     if (!contextDocument())
4936         return;
4937 
4938     URL parsedURL = contextDocument()-&gt;completeURL(clientURL);
4939 
4940     return ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(contextDocument()-&gt;sessionID()).matchRegistration(SecurityOriginData { contextDocument()-&gt;topOrigin().data() }, parsedURL, [promise = WTFMove(promise)] (auto&amp;&amp; result) mutable {
4941         promise.resolve(!!result);
4942     });
4943 }
4944 
4945 void Internals::terminateServiceWorker(ServiceWorker&amp; worker)
4946 {
4947     if (!contextDocument())
4948         return;
4949 
4950     ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(contextDocument()-&gt;sessionID()).syncTerminateWorker(worker.identifier());
4951 }
4952 
4953 bool Internals::hasServiceWorkerConnection()
4954 {
4955     if (!contextDocument())
4956         return false;
4957 
4958     return ServiceWorkerProvider::singleton().existingServiceWorkerConnectionForSession(contextDocument()-&gt;sessionID());
4959 }
4960 #endif
4961 
4962 #if ENABLE(APPLE_PAY)
4963 MockPaymentCoordinator&amp; Internals::mockPaymentCoordinator(Document&amp; document)
4964 {
4965     return downcast&lt;MockPaymentCoordinator&gt;(document.frame()-&gt;page()-&gt;paymentCoordinator().client());
4966 }
4967 #endif
4968 
4969 bool Internals::isSystemPreviewLink(Element&amp; element) const
4970 {
4971 #if USE(SYSTEM_PREVIEW)
4972     return is&lt;HTMLAnchorElement&gt;(element) &amp;&amp; downcast&lt;HTMLAnchorElement&gt;(element).isSystemPreviewLink();
4973 #else
4974     UNUSED_PARAM(element);
4975     return false;
4976 #endif
4977 }
4978 
4979 bool Internals::isSystemPreviewImage(Element&amp; element) const
4980 {
4981 #if USE(SYSTEM_PREVIEW)
4982     if (is&lt;HTMLImageElement&gt;(element))
4983         return downcast&lt;HTMLImageElement&gt;(element).isSystemPreviewImage();
4984     if (is&lt;HTMLPictureElement&gt;(element))
4985         return downcast&lt;HTMLPictureElement&gt;(element).isSystemPreviewImage();
4986     return false;
4987 #else
4988     UNUSED_PARAM(element);
4989     return false;
4990 #endif
4991 }
4992 
4993 bool Internals::usingAppleInternalSDK() const
4994 {
4995 #if USE(APPLE_INTERNAL_SDK)
4996     return true;
4997 #else
4998     return false;
4999 #endif
5000 }
5001 
5002 void Internals::setCaptureExtraNetworkLoadMetricsEnabled(bool value)
5003 {
5004     platformStrategies()-&gt;loaderStrategy()-&gt;setCaptureExtraNetworkLoadMetricsEnabled(value);
5005 }
5006 
5007 String Internals::ongoingLoadsDescriptions() const
5008 {
5009     StringBuilder builder;
5010     builder.append(&#39;[&#39;);
5011     bool isStarting = true;
5012     for (auto&amp; identifier : platformStrategies()-&gt;loaderStrategy()-&gt;ongoingLoads()) {
5013         if (isStarting)
5014             isStarting = false;
5015         else
5016             builder.append(&#39;,&#39;);
5017 
5018         builder.append(&#39;[&#39;);
5019 
5020         for (auto&amp; info : platformStrategies()-&gt;loaderStrategy()-&gt;intermediateLoadInformationFromResourceLoadIdentifier(identifier))
5021             builder.append(&#39;[&#39;, (int)info.type, &quot;,\&quot;&quot;, info.request.url().string(), &quot;\&quot;,\&quot;&quot;, info.request.httpMethod(), &quot;\&quot;,&quot;, info.response.httpStatusCode(), &#39;]&#39;);
5022 
5023         builder.append(&#39;]&#39;);
5024     }
5025     builder.append(&#39;]&#39;);
5026     return builder.toString();
5027 }
5028 
5029 void Internals::reloadWithoutContentExtensions()
5030 {
5031     if (auto* frame = this-&gt;frame())
5032         frame-&gt;loader().reload(ReloadOption::DisableContentBlockers);
5033 }
5034 
5035 void Internals::setUseSystemAppearance(bool value)
5036 {
5037     if (!contextDocument() || !contextDocument()-&gt;page())
5038         return;
5039     contextDocument()-&gt;page()-&gt;setUseSystemAppearance(value);
5040 }
5041 
5042 size_t Internals::pluginCount()
5043 {
5044     if (!contextDocument() || !contextDocument()-&gt;page())
5045         return 0;
5046 
5047     return contextDocument()-&gt;page()-&gt;pluginData().webVisiblePlugins().size();
5048 }
5049 
5050 void Internals::notifyResourceLoadObserver()
5051 {
5052     ResourceLoadObserver::shared().updateCentralStatisticsStore();
5053 }
5054 
5055 unsigned Internals::primaryScreenDisplayID()
5056 {
5057 #if PLATFORM(MAC)
5058     return WebCore::primaryScreenDisplayID();
5059 #else
5060     return 0;
5061 #endif
5062 }
5063 
5064 bool Internals::capsLockIsOn()
5065 {
5066     return WebCore::PlatformKeyboardEvent::currentCapsLockState();
5067 }
5068 
5069 bool Internals::supportsVCPEncoder()
5070 {
5071 #if defined(ENABLE_VCP_ENCODER)
5072     return ENABLE_VCP_ENCODER || ENABLE_VCP_VTB_ENCODER;
5073 #else
5074     return false;
5075 #endif
5076 }
5077 
5078 Optional&lt;HEVCParameterSet&gt; Internals::parseHEVCCodecParameters(const String&amp; codecString)
5079 {
5080     return WebCore::parseHEVCCodecParameters(codecString);
5081 }
5082 
5083 auto Internals::getCookies() const -&gt; Vector&lt;CookieData&gt;
5084 {
5085     auto* document = contextDocument();
5086     if (!document)
5087         return { };
5088 
5089     auto* page = document-&gt;page();
5090     if (!page)
5091         return { };
5092 
5093     Vector&lt;Cookie&gt; cookies;
5094     page-&gt;cookieJar().getRawCookies(*document, document-&gt;cookieURL(), cookies);
5095     return WTF::map(cookies, [](auto&amp; cookie) {
5096         return CookieData { cookie };
5097     });
5098 }
5099 
5100 void Internals::setAlwaysAllowLocalWebarchive(bool alwaysAllowLocalWebarchive)
5101 {
5102     auto* localFrame = frame();
5103     if (!localFrame)
5104         return;
5105     localFrame-&gt;loader().setAlwaysAllowLocalWebarchive(alwaysAllowLocalWebarchive);
5106 }
5107 
5108 void Internals::processWillSuspend()
5109 {
5110     PlatformMediaSessionManager::sharedManager().processWillSuspend();
5111 }
5112 
5113 void Internals::processDidResume()
5114 {
5115     PlatformMediaSessionManager::sharedManager().processDidResume();
5116 }
5117 
5118 void Internals::testDictionaryLogging()
5119 {
5120     auto* document = contextDocument();
5121     if (!document)
5122         return;
5123 
5124     auto* page = document-&gt;page();
5125     if (!page)
5126         return;
5127 
5128     DiagnosticLoggingClient::ValueDictionary dictionary;
5129     dictionary.set(&quot;stringKey&quot;_s, String(&quot;stringValue&quot;));
5130     dictionary.set(&quot;uint64Key&quot;_s, std::numeric_limits&lt;uint64_t&gt;::max());
5131     dictionary.set(&quot;int64Key&quot;_s, std::numeric_limits&lt;int64_t&gt;::min());
5132     dictionary.set(&quot;boolKey&quot;_s, true);
5133     dictionary.set(&quot;doubleKey&quot;_s, 2.7182818284590452353602874);
5134 
5135     page-&gt;diagnosticLoggingClient().logDiagnosticMessageWithValueDictionary(&quot;testMessage&quot;_s, &quot;testDescription&quot;_s, dictionary, ShouldSample::No);
5136 }
5137 
5138 void Internals::setXHRMaximumIntervalForUserGestureForwarding(XMLHttpRequest&amp; request, double interval)
5139 {
5140     request.setMaximumIntervalForUserGestureForwarding(interval);
5141 }
5142 
5143 void Internals::setIsPlayingToAutomotiveHeadUnit(bool isPlaying)
5144 {
5145     PlatformMediaSessionManager::sharedManager().setIsPlayingToAutomotiveHeadUnit(isPlaying);
5146 }
5147 
5148 Internals::TextIndicatorInfo::TextIndicatorInfo()
5149 {
5150 }
5151 
5152 Internals::TextIndicatorInfo::TextIndicatorInfo(const WebCore::TextIndicatorData&amp; data)
5153     : textBoundingRectInRootViewCoordinates(DOMRect::create(data.textBoundingRectInRootViewCoordinates))
5154     , textRectsInBoundingRectCoordinates(DOMRectList::create(data.textRectsInBoundingRectCoordinates))
5155 {
5156 }
5157 
5158 Internals::TextIndicatorInfo::~TextIndicatorInfo() = default;
5159 
5160 Internals::TextIndicatorInfo Internals::textIndicatorForRange(const Range&amp; range, TextIndicatorOptions options)
5161 {
5162     auto indicator = TextIndicator::createWithRange(range, options.core(), TextIndicatorPresentationTransition::None);
5163     return indicator-&gt;data();
5164 }
5165 
5166 void Internals::addPrefetchLoadEventListener(HTMLLinkElement&amp; link, RefPtr&lt;EventListener&gt;&amp;&amp; listener)
5167 {
5168     if (RuntimeEnabledFeatures::sharedFeatures().linkPrefetchEnabled() &amp;&amp; equalLettersIgnoringASCIICase(link.rel(), &quot;prefetch&quot;))
5169         link.addEventListener(eventNames().loadEvent, listener.releaseNonNull(), false);
5170 }
5171 
5172 } // namespace WebCore
    </pre>
  </body>
</html>