<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/Modules/websockets/WebSocketChannel.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011, 2012 Google Inc.  All rights reserved.
  3  * Copyright (C) 2018 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;WebSocketChannel.h&quot;
 34 
 35 #include &quot;Blob.h&quot;
 36 #include &quot;CookieJar.h&quot;
 37 #include &quot;Document.h&quot;
 38 #include &quot;FileError.h&quot;
 39 #include &quot;FileReaderLoader.h&quot;
 40 #include &quot;Frame.h&quot;
 41 #include &quot;FrameLoader.h&quot;
 42 #include &quot;InspectorInstrumentation.h&quot;
 43 #include &quot;Logging.h&quot;
 44 #include &quot;NetworkingContext.h&quot;
 45 #include &quot;Page.h&quot;
 46 #include &quot;ProgressTracker.h&quot;
 47 #include &quot;ResourceRequest.h&quot;
 48 #include &quot;ScriptExecutionContext.h&quot;
 49 #include &quot;SocketProvider.h&quot;
 50 #include &quot;SocketStreamError.h&quot;
 51 #include &quot;SocketStreamHandle.h&quot;
 52 #include &quot;UserContentProvider.h&quot;
 53 #include &quot;WebSocketChannelClient.h&quot;
 54 #include &quot;WebSocketHandshake.h&quot;
 55 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
 56 #include &lt;wtf/FastMalloc.h&gt;
 57 #include &lt;wtf/HashMap.h&gt;
 58 #include &lt;wtf/text/CString.h&gt;
 59 #include &lt;wtf/text/StringHash.h&gt;
 60 
 61 namespace WebCore {
 62 
 63 const Seconds TCPMaximumSegmentLifetime { 2_min };
 64 
 65 WebSocketChannel::WebSocketChannel(Document&amp; document, WebSocketChannelClient&amp; client, SocketProvider&amp; provider)
 66     : m_document(&amp;document)
 67     , m_client(&amp;client)
 68     , m_resumeTimer(*this, &amp;WebSocketChannel::resumeTimerFired)
 69     , m_closingTimer(*this, &amp;WebSocketChannel::closingTimerFired)
 70     , m_socketProvider(provider)
 71 {
 72     if (Page* page = document.page())
 73         m_identifier = page-&gt;progress().createUniqueIdentifier();
 74 
 75     LOG(Network, &quot;WebSocketChannel %p ctor, identifier %u&quot;, this, m_identifier);
 76 }
 77 
 78 WebSocketChannel::~WebSocketChannel()
 79 {
 80     LOG(Network, &quot;WebSocketChannel %p dtor&quot;, this);
 81 }
 82 
 83 void WebSocketChannel::connect(const URL&amp; requestedURL, const String&amp; protocol)
 84 {
 85     LOG(Network, &quot;WebSocketChannel %p connect()&quot;, this);
 86 
 87     URL url = requestedURL;
 88     bool allowCookies = true;
 89 #if ENABLE(CONTENT_EXTENSIONS)
 90     if (auto* page = m_document-&gt;page()) {
 91         if (auto* documentLoader = m_document-&gt;loader()) {
 92             auto blockedStatus = page-&gt;userContentProvider().processContentExtensionRulesForLoad(url, ResourceType::Raw, *documentLoader);
 93             if (blockedStatus.blockedLoad) {
 94                 Ref&lt;WebSocketChannel&gt; protectedThis(*this);
 95                 callOnMainThread([protectedThis = WTFMove(protectedThis)] {
 96                     if (protectedThis-&gt;m_client)
 97                         protectedThis-&gt;m_client-&gt;didReceiveMessageError();
 98                 });
 99                 return;
100             }
101             if (blockedStatus.madeHTTPS) {
102                 ASSERT(url.protocolIs(&quot;ws&quot;));
103                 url.setProtocol(&quot;wss&quot;);
104                 if (m_client)
105                     m_client-&gt;didUpgradeURL();
106             }
107             if (blockedStatus.blockedCookies)
108                 allowCookies = false;
109         }
110     }
111 #endif
112 
113     ASSERT(!m_handle);
114     ASSERT(!m_suspended);
115     m_handshake = std::make_unique&lt;WebSocketHandshake&gt;(url, protocol, m_document, allowCookies);
116     m_handshake-&gt;reset();
117     if (m_deflateFramer.canDeflate())
118         m_handshake-&gt;addExtensionProcessor(m_deflateFramer.createExtensionProcessor());
119     if (m_identifier)
120         InspectorInstrumentation::didCreateWebSocket(m_document, m_identifier, url);
121 
122     if (Frame* frame = m_document-&gt;frame()) {
123         ref();
124         Page* page = frame-&gt;page();
125         PAL::SessionID sessionID = page ? page-&gt;sessionID() : PAL::SessionID::defaultSessionID();
126         String partition = m_document-&gt;domainForCachePartition();
127         // JDK-8094172: JavaFX needs Page instance
128         m_handle = m_socketProvider-&gt;createSocketStreamHandle(m_handshake-&gt;url(), *this, sessionID, page, partition, frame-&gt;loader().networkingContext());
129     }
130 }
131 
132 String WebSocketChannel::subprotocol()
133 {
134     LOG(Network, &quot;WebSocketChannel %p subprotocol()&quot;, this);
135     if (!m_handshake || m_handshake-&gt;mode() != WebSocketHandshake::Connected)
136         return emptyString();
137     String serverProtocol = m_handshake-&gt;serverWebSocketProtocol();
138     if (serverProtocol.isNull())
139         return emptyString();
140     return serverProtocol;
141 }
142 
143 String WebSocketChannel::extensions()
144 {
145     LOG(Network, &quot;WebSocketChannel %p extensions()&quot;, this);
146     if (!m_handshake || m_handshake-&gt;mode() != WebSocketHandshake::Connected)
147         return emptyString();
148     String extensions = m_handshake-&gt;acceptedExtensions();
149     if (extensions.isNull())
150         return emptyString();
151     return extensions;
152 }
153 
154 ThreadableWebSocketChannel::SendResult WebSocketChannel::send(const String&amp; message)
155 {
156     LOG(Network, &quot;WebSocketChannel %p send() Sending String &#39;%s&#39;&quot;, this, message.utf8().data());
157     CString utf8 = message.utf8(StrictConversionReplacingUnpairedSurrogatesWithFFFD);
158     enqueueTextFrame(utf8);
159     processOutgoingFrameQueue();
160     // According to WebSocket API specification, WebSocket.send() should return void instead
161     // of boolean. However, our implementation still returns boolean due to compatibility
162     // concern (see bug 65850).
163     // m_channel-&gt;send() may happen later, thus it&#39;s not always possible to know whether
164     // the message has been sent to the socket successfully. In this case, we have no choice
165     // but to return true.
166     return ThreadableWebSocketChannel::SendSuccess;
167 }
168 
169 ThreadableWebSocketChannel::SendResult WebSocketChannel::send(const ArrayBuffer&amp; binaryData, unsigned byteOffset, unsigned byteLength)
170 {
171     LOG(Network, &quot;WebSocketChannel %p send() Sending ArrayBuffer %p byteOffset=%u byteLength=%u&quot;, this, &amp;binaryData, byteOffset, byteLength);
172     enqueueRawFrame(WebSocketFrame::OpCodeBinary, static_cast&lt;const char*&gt;(binaryData.data()) + byteOffset, byteLength);
173     processOutgoingFrameQueue();
174     return ThreadableWebSocketChannel::SendSuccess;
175 }
176 
177 ThreadableWebSocketChannel::SendResult WebSocketChannel::send(Blob&amp; binaryData)
178 {
179     LOG(Network, &quot;WebSocketChannel %p send() Sending Blob &#39;%s&#39;&quot;, this, binaryData.url().string().utf8().data());
180     enqueueBlobFrame(WebSocketFrame::OpCodeBinary, binaryData);
181     processOutgoingFrameQueue();
182     return ThreadableWebSocketChannel::SendSuccess;
183 }
184 
185 bool WebSocketChannel::send(const char* data, int length)
186 {
187     LOG(Network, &quot;WebSocketChannel %p send() Sending char* data=%p length=%d&quot;, this, data, length);
188     enqueueRawFrame(WebSocketFrame::OpCodeBinary, data, length);
189     processOutgoingFrameQueue();
190     return true;
191 }
192 
193 unsigned WebSocketChannel::bufferedAmount() const
194 {
195     LOG(Network, &quot;WebSocketChannel %p bufferedAmount()&quot;, this);
196     ASSERT(m_handle);
197     ASSERT(!m_suspended);
198     return m_handle-&gt;bufferedAmount();
199 }
200 
201 void WebSocketChannel::close(int code, const String&amp; reason)
202 {
203     LOG(Network, &quot;WebSocketChannel %p close() code=%d reason=&#39;%s&#39;&quot;, this, code, reason.utf8().data());
204     ASSERT(!m_suspended);
205     if (!m_handle)
206         return;
207     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // An attempt to send closing handshake may fail, which will get the channel closed and dereferenced.
208     startClosingHandshake(code, reason);
209     if (m_closing &amp;&amp; !m_closingTimer.isActive())
210         m_closingTimer.startOneShot(TCPMaximumSegmentLifetime * 2);
211 }
212 
213 void WebSocketChannel::fail(const String&amp; reason)
214 {
215     LOG(Network, &quot;WebSocketChannel %p fail() reason=&#39;%s&#39;&quot;, this, reason.utf8().data());
216     ASSERT(!m_suspended);
217     if (m_document) {
218         InspectorInstrumentation::didReceiveWebSocketFrameError(m_document, m_identifier, reason);
219 
220         String consoleMessage;
221         if (m_handshake)
222             consoleMessage = makeString(&quot;WebSocket connection to &#39;&quot;, m_handshake-&gt;url().stringCenterEllipsizedToLength(), &quot;&#39; failed: &quot;, reason);
223         else
224             consoleMessage = makeString(&quot;WebSocket connection failed: &quot;, reason);
225 
226         m_document-&gt;addConsoleMessage(MessageSource::Network, MessageLevel::Error, consoleMessage);
227     }
228 
229     // Hybi-10 specification explicitly states we must not continue to handle incoming data
230     // once the WebSocket connection is failed (section 7.1.7).
231     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // The client can close the channel, potentially removing the last reference.
232     m_shouldDiscardReceivedData = true;
233     if (!m_buffer.isEmpty())
234         skipBuffer(m_buffer.size()); // Save memory.
235     m_deflateFramer.didFail();
236     m_hasContinuousFrame = false;
237     m_continuousFrameData.clear();
238     if (m_client)
239         m_client-&gt;didReceiveMessageError();
240 
241     if (m_handle &amp;&amp; !m_closed)
242         m_handle-&gt;disconnect(); // Will call didCloseSocketStream() but maybe not synchronously.
243 }
244 
245 void WebSocketChannel::disconnect()
246 {
247     LOG(Network, &quot;WebSocketChannel %p disconnect()&quot;, this);
248     if (m_identifier &amp;&amp; m_document)
249         InspectorInstrumentation::didCloseWebSocket(m_document, m_identifier);
250     if (m_handshake)
251         m_handshake-&gt;clearDocument();
252     m_client = nullptr;
253     m_document = nullptr;
254     if (m_handle)
255         m_handle-&gt;disconnect();
256 }
257 
258 void WebSocketChannel::suspend()
259 {
260     m_suspended = true;
261 }
262 
263 void WebSocketChannel::resume()
264 {
265     m_suspended = false;
266     if ((!m_buffer.isEmpty() || m_closed) &amp;&amp; m_client &amp;&amp; !m_resumeTimer.isActive())
267         m_resumeTimer.startOneShot(0_s);
268 }
269 
270 void WebSocketChannel::didOpenSocketStream(SocketStreamHandle&amp; handle)
271 {
272     LOG(Network, &quot;WebSocketChannel %p didOpenSocketStream()&quot;, this);
273     ASSERT(&amp;handle == m_handle);
274     if (!m_document)
275         return;
276     if (m_identifier &amp;&amp; UNLIKELY(InspectorInstrumentation::hasFrontends()))
277         InspectorInstrumentation::willSendWebSocketHandshakeRequest(m_document, m_identifier, m_handshake-&gt;clientHandshakeRequest());
278     auto handshakeMessage = m_handshake-&gt;clientHandshakeMessage();
279     auto cookieRequestHeaderFieldProxy = m_handshake-&gt;clientHandshakeCookieRequestHeaderFieldProxy();
280     handle.sendHandshake(WTFMove(handshakeMessage), WTFMove(cookieRequestHeaderFieldProxy), [this, protectedThis = makeRef(*this)] (bool success, bool didAccessSecureCookies) {
281         if (!success)
282             fail(&quot;Failed to send WebSocket handshake.&quot;);
283 
284         if (didAccessSecureCookies &amp;&amp; m_document)
285             m_document-&gt;setSecureCookiesAccessed();
286     });
287 }
288 
289 void WebSocketChannel::didCloseSocketStream(SocketStreamHandle&amp; handle)
290 {
291     LOG(Network, &quot;WebSocketChannel %p didCloseSocketStream()&quot;, this);
292     if (m_identifier &amp;&amp; m_document)
293         InspectorInstrumentation::didCloseWebSocket(m_document, m_identifier);
294     ASSERT_UNUSED(handle, &amp;handle == m_handle || !m_handle);
295     m_closed = true;
296     if (m_closingTimer.isActive())
297         m_closingTimer.stop();
298     if (m_outgoingFrameQueueStatus != OutgoingFrameQueueClosed)
299         abortOutgoingFrameQueue();
300     if (m_handle) {
301         m_unhandledBufferedAmount = m_handle-&gt;bufferedAmount();
302         if (m_suspended)
303             return;
304         WebSocketChannelClient* client = m_client;
305         m_client = nullptr;
306         m_document = nullptr;
307         m_handle = nullptr;
308         if (client)
309             client-&gt;didClose(m_unhandledBufferedAmount, m_receivedClosingHandshake ? WebSocketChannelClient::ClosingHandshakeComplete : WebSocketChannelClient::ClosingHandshakeIncomplete, m_closeEventCode, m_closeEventReason);
310     }
311     deref();
312 }
313 
314 void WebSocketChannel::didReceiveSocketStreamData(SocketStreamHandle&amp; handle, const char* data, size_t length)
315 {
316     LOG(Network, &quot;WebSocketChannel %p didReceiveSocketStreamData() Received %zu bytes&quot;, this, length);
317     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // The client can close the channel, potentially removing the last reference.
318     ASSERT(&amp;handle == m_handle);
319     if (!m_document) {
320         return;
321     }
322     if (!length) {
323         handle.disconnect();
324         return;
325     }
326     if (!m_client) {
327         m_shouldDiscardReceivedData = true;
328         handle.disconnect();
329         return;
330     }
331     if (m_shouldDiscardReceivedData)
332         return;
333     if (!appendToBuffer(data, length)) {
334         m_shouldDiscardReceivedData = true;
335         fail(&quot;Ran out of memory while receiving WebSocket data.&quot;);
336         return;
337     }
338     while (!m_suspended &amp;&amp; m_client &amp;&amp; !m_buffer.isEmpty()) {
339         if (!processBuffer())
340             break;
341     }
342 }
343 
344 void WebSocketChannel::didFailToReceiveSocketStreamData(SocketStreamHandle&amp; handle)
345 {
346     handle.disconnect();
347 }
348 
349 void WebSocketChannel::didUpdateBufferedAmount(SocketStreamHandle&amp;, size_t bufferedAmount)
350 {
351     if (m_client)
352         m_client-&gt;didUpdateBufferedAmount(bufferedAmount);
353 }
354 
355 void WebSocketChannel::didFailSocketStream(SocketStreamHandle&amp; handle, const SocketStreamError&amp; error)
356 {
357     LOG(Network, &quot;WebSocketChannel %p didFailSocketStream()&quot;, this);
358     ASSERT(&amp;handle == m_handle || !m_handle);
359     if (m_document) {
360         String message;
361         if (error.isNull())
362             message = &quot;WebSocket network error&quot;_s;
363         else if (error.localizedDescription().isNull())
364             message = makeString(&quot;WebSocket network error: error code &quot;, error.errorCode());
365         else
366             message = &quot;WebSocket network error: &quot; + error.localizedDescription();
367         InspectorInstrumentation::didReceiveWebSocketFrameError(m_document, m_identifier, message);
368         m_document-&gt;addConsoleMessage(MessageSource::Network, MessageLevel::Error, message);
369     }
370     m_shouldDiscardReceivedData = true;
371     if (m_client)
372         m_client-&gt;didReceiveMessageError();
373     handle.disconnect();
374 }
375 
376 void WebSocketChannel::didStartLoading()
377 {
378     LOG(Network, &quot;WebSocketChannel %p didStartLoading()&quot;, this);
379     ASSERT(m_blobLoader);
380     ASSERT(m_blobLoaderStatus == BlobLoaderStarted);
381 }
382 
383 void WebSocketChannel::didReceiveData()
384 {
385     LOG(Network, &quot;WebSocketChannel %p didReceiveData()&quot;, this);
386     ASSERT(m_blobLoader);
387     ASSERT(m_blobLoaderStatus == BlobLoaderStarted);
388 }
389 
390 void WebSocketChannel::didFinishLoading()
391 {
392     LOG(Network, &quot;WebSocketChannel %p didFinishLoading()&quot;, this);
393     ASSERT(m_blobLoader);
394     ASSERT(m_blobLoaderStatus == BlobLoaderStarted);
395     m_blobLoaderStatus = BlobLoaderFinished;
396     processOutgoingFrameQueue();
397     deref();
398 }
399 
400 void WebSocketChannel::didFail(int errorCode)
401 {
402     LOG(Network, &quot;WebSocketChannel %p didFail() errorCode=%d&quot;, this, errorCode);
403     ASSERT(m_blobLoader);
404     ASSERT(m_blobLoaderStatus == BlobLoaderStarted);
405     m_blobLoader = nullptr;
406     m_blobLoaderStatus = BlobLoaderFailed;
407     fail(makeString(&quot;Failed to load Blob: error code = &quot;, errorCode)); // FIXME: Generate human-friendly reason message.
408     deref();
409 }
410 
411 bool WebSocketChannel::appendToBuffer(const char* data, size_t len)
412 {
413     size_t newBufferSize = m_buffer.size() + len;
414     if (newBufferSize &lt; m_buffer.size()) {
415         LOG(Network, &quot;WebSocketChannel %p appendToBuffer() Buffer overflow (%u bytes already in receive buffer and appending %u bytes)&quot;, this, static_cast&lt;unsigned&gt;(m_buffer.size()), static_cast&lt;unsigned&gt;(len));
416         return false;
417     }
418     m_buffer.append(data, len);
419     return true;
420 }
421 
422 void WebSocketChannel::skipBuffer(size_t len)
423 {
424     ASSERT_WITH_SECURITY_IMPLICATION(len &lt;= m_buffer.size());
425     memmove(m_buffer.data(), m_buffer.data() + len, m_buffer.size() - len);
426     m_buffer.shrink(m_buffer.size() - len);
427 }
428 
429 bool WebSocketChannel::processBuffer()
430 {
431     ASSERT(!m_suspended);
432     ASSERT(m_client);
433     ASSERT(!m_buffer.isEmpty());
434     LOG(Network, &quot;WebSocketChannel %p processBuffer() Receive buffer has %u bytes&quot;, this, static_cast&lt;unsigned&gt;(m_buffer.size()));
435 
436     if (m_shouldDiscardReceivedData)
437         return false;
438 
439     if (m_receivedClosingHandshake) {
440         skipBuffer(m_buffer.size());
441         return false;
442     }
443 
444     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // The client can close the channel, potentially removing the last reference.
445 
446     if (m_handshake-&gt;mode() == WebSocketHandshake::Incomplete) {
447         int headerLength = m_handshake-&gt;readServerHandshake(m_buffer.data(), m_buffer.size());
448         if (headerLength &lt;= 0)
449             return false;
450         if (m_handshake-&gt;mode() == WebSocketHandshake::Connected) {
451             if (m_identifier)
452                 InspectorInstrumentation::didReceiveWebSocketHandshakeResponse(m_document, m_identifier, m_handshake-&gt;serverHandshakeResponse());
453             String serverSetCookie = m_handshake-&gt;serverSetCookie();
454             if (!serverSetCookie.isEmpty()) {
455                 if (m_document &amp;&amp; m_document-&gt;page() &amp;&amp; m_document-&gt;page()-&gt;cookieJar().cookiesEnabled(*m_document))
456                     m_document-&gt;page()-&gt;cookieJar().setCookies(*m_document, m_handshake-&gt;httpURLForAuthenticationAndCookies(), serverSetCookie);
457             }
458             LOG(Network, &quot;WebSocketChannel %p Connected&quot;, this);
459             skipBuffer(headerLength);
460             m_client-&gt;didConnect();
461             LOG(Network, &quot;WebSocketChannel %p %u bytes remaining in m_buffer&quot;, this, static_cast&lt;unsigned&gt;(m_buffer.size()));
462             return !m_buffer.isEmpty();
463         }
464         ASSERT(m_handshake-&gt;mode() == WebSocketHandshake::Failed);
465         LOG(Network, &quot;WebSocketChannel %p Connection failed&quot;, this);
466         skipBuffer(headerLength);
467         m_shouldDiscardReceivedData = true;
468         fail(m_handshake-&gt;failureReason());
469         return false;
470     }
471     if (m_handshake-&gt;mode() != WebSocketHandshake::Connected)
472         return false;
473 
474     return processFrame();
475 }
476 
477 void WebSocketChannel::resumeTimerFired()
478 {
479     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // The client can close the channel, potentially removing the last reference.
480     while (!m_suspended &amp;&amp; m_client &amp;&amp; !m_buffer.isEmpty())
481         if (!processBuffer())
482             break;
483     if (!m_suspended &amp;&amp; m_client &amp;&amp; m_closed &amp;&amp; m_handle)
484         didCloseSocketStream(*m_handle);
485 }
486 
487 void WebSocketChannel::startClosingHandshake(int code, const String&amp; reason)
488 {
489     LOG(Network, &quot;WebSocketChannel %p startClosingHandshake() code=%d m_receivedClosingHandshake=%d&quot;, this, m_closing, m_receivedClosingHandshake);
490     ASSERT(!m_closed);
491     if (m_closing)
492         return;
493     ASSERT(m_handle);
494 
495     Vector&lt;char&gt; buf;
496     if (!m_receivedClosingHandshake &amp;&amp; code != CloseEventCodeNotSpecified) {
497         unsigned char highByte = code &gt;&gt; 8;
498         unsigned char lowByte = code;
499         buf.append(static_cast&lt;char&gt;(highByte));
500         buf.append(static_cast&lt;char&gt;(lowByte));
501         auto reasonUTF8 = reason.utf8();
502         buf.append(reasonUTF8.data(), reasonUTF8.length());
503     }
504     enqueueRawFrame(WebSocketFrame::OpCodeClose, buf.data(), buf.size());
505     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // An attempt to send closing handshake may fail, which will get the channel closed and dereferenced.
506     processOutgoingFrameQueue();
507 
508     if (m_closed) {
509         // The channel got closed because processOutgoingFrameQueue() failed.
510         return;
511     }
512 
513     m_closing = true;
514     if (m_client)
515         m_client-&gt;didStartClosingHandshake();
516 }
517 
518 void WebSocketChannel::closingTimerFired()
519 {
520     LOG(Network, &quot;WebSocketChannel %p closingTimerFired()&quot;, this);
521     if (m_handle)
522         m_handle-&gt;disconnect();
523 }
524 
525 
526 bool WebSocketChannel::processFrame()
527 {
528     ASSERT(!m_buffer.isEmpty());
529 
530     WebSocketFrame frame;
531     const char* frameEnd;
532     String errorString;
533     WebSocketFrame::ParseFrameResult result = WebSocketFrame::parseFrame(m_buffer.data(), m_buffer.size(), frame, frameEnd, errorString);
534     if (result == WebSocketFrame::FrameIncomplete)
535         return false;
536     if (result == WebSocketFrame::FrameError) {
537         fail(errorString);
538         return false;
539     }
540 
541     ASSERT(m_buffer.data() &lt; frameEnd);
542     ASSERT(frameEnd &lt;= m_buffer.data() + m_buffer.size());
543 
544     auto inflateResult = m_deflateFramer.inflate(frame);
545     if (!inflateResult-&gt;succeeded()) {
546         fail(inflateResult-&gt;failureReason());
547         return false;
548     }
549 
550     // Validate the frame data.
551     if (WebSocketFrame::isReservedOpCode(frame.opCode)) {
552         fail(makeString(&quot;Unrecognized frame opcode: &quot;, static_cast&lt;unsigned&gt;(frame.opCode)));
553         return false;
554     }
555 
556     if (frame.reserved2 || frame.reserved3) {
557         fail(makeString(&quot;One or more reserved bits are on: reserved2 = &quot;, static_cast&lt;unsigned&gt;(frame.reserved2), &quot;, reserved3 = &quot;, static_cast&lt;unsigned&gt;(frame.reserved3)));
558         return false;
559     }
560 
561     if (frame.masked) {
562         fail(&quot;A server must not mask any frames that it sends to the client.&quot;);
563         return false;
564     }
565 
566     // All control frames must not be fragmented.
567     if (WebSocketFrame::isControlOpCode(frame.opCode) &amp;&amp; !frame.final) {
568         fail(makeString(&quot;Received fragmented control frame: opcode = &quot;, static_cast&lt;unsigned&gt;(frame.opCode)));
569         return false;
570     }
571 
572     // All control frames must have a payload of 125 bytes or less, which means the frame must not contain
573     // the &quot;extended payload length&quot; field.
574     if (WebSocketFrame::isControlOpCode(frame.opCode) &amp;&amp; WebSocketFrame::needsExtendedLengthField(frame.payloadLength)) {
575         fail(makeString(&quot;Received control frame having too long payload: &quot;, frame.payloadLength, &quot; bytes&quot;));
576         return false;
577     }
578 
579     // A new data frame is received before the previous continuous frame finishes.
580     // Note that control frames are allowed to come in the middle of continuous frames.
581     if (m_hasContinuousFrame &amp;&amp; frame.opCode != WebSocketFrame::OpCodeContinuation &amp;&amp; !WebSocketFrame::isControlOpCode(frame.opCode)) {
582         fail(&quot;Received new data frame but previous continuous frame is unfinished.&quot;);
583         return false;
584     }
585 
586     InspectorInstrumentation::didReceiveWebSocketFrame(m_document, m_identifier, frame);
587 
588     switch (frame.opCode) {
589     case WebSocketFrame::OpCodeContinuation:
590         // An unexpected continuation frame is received without any leading frame.
591         if (!m_hasContinuousFrame) {
592             fail(&quot;Received unexpected continuation frame.&quot;);
593             return false;
594         }
595         m_continuousFrameData.append(frame.payload, frame.payloadLength);
596         skipBuffer(frameEnd - m_buffer.data());
597         if (frame.final) {
598             // onmessage handler may eventually call the other methods of this channel,
599             // so we should pretend that we have finished to read this frame and
600             // make sure that the member variables are in a consistent state before
601             // the handler is invoked.
602             Vector&lt;uint8_t&gt; continuousFrameData = WTFMove(m_continuousFrameData);
603             m_hasContinuousFrame = false;
604             if (m_continuousFrameOpCode == WebSocketFrame::OpCodeText) {
605                 String message;
606                 if (continuousFrameData.size())
607                     message = String::fromUTF8(continuousFrameData.data(), continuousFrameData.size());
608                 else
609                     message = emptyString();
610                 if (message.isNull())
611                     fail(&quot;Could not decode a text frame as UTF-8.&quot;);
612                 else
613                     m_client-&gt;didReceiveMessage(message);
614             } else if (m_continuousFrameOpCode == WebSocketFrame::OpCodeBinary)
615                 m_client-&gt;didReceiveBinaryData(WTFMove(continuousFrameData));
616         }
617         break;
618 
619     case WebSocketFrame::OpCodeText:
620         if (frame.final) {
621             String message;
622             if (frame.payloadLength)
623                 message = String::fromUTF8(frame.payload, frame.payloadLength);
624             else
625                 message = emptyString();
626             skipBuffer(frameEnd - m_buffer.data());
627             if (message.isNull())
628                 fail(&quot;Could not decode a text frame as UTF-8.&quot;);
629             else
630                 m_client-&gt;didReceiveMessage(message);
631         } else {
632             m_hasContinuousFrame = true;
633             m_continuousFrameOpCode = WebSocketFrame::OpCodeText;
634             ASSERT(m_continuousFrameData.isEmpty());
635             m_continuousFrameData.append(frame.payload, frame.payloadLength);
636             skipBuffer(frameEnd - m_buffer.data());
637         }
638         break;
639 
640     case WebSocketFrame::OpCodeBinary:
641         if (frame.final) {
642             Vector&lt;uint8_t&gt; binaryData(frame.payloadLength);
643             memcpy(binaryData.data(), frame.payload, frame.payloadLength);
644             skipBuffer(frameEnd - m_buffer.data());
645             m_client-&gt;didReceiveBinaryData(WTFMove(binaryData));
646         } else {
647             m_hasContinuousFrame = true;
648             m_continuousFrameOpCode = WebSocketFrame::OpCodeBinary;
649             ASSERT(m_continuousFrameData.isEmpty());
650             m_continuousFrameData.append(frame.payload, frame.payloadLength);
651             skipBuffer(frameEnd - m_buffer.data());
652         }
653         break;
654 
655     case WebSocketFrame::OpCodeClose:
656         if (!frame.payloadLength)
657             m_closeEventCode = CloseEventCodeNoStatusRcvd;
658         else if (frame.payloadLength == 1) {
659             m_closeEventCode = CloseEventCodeAbnormalClosure;
660             fail(&quot;Received a broken close frame containing an invalid size body.&quot;);
661             return false;
662         } else {
663             unsigned char highByte = static_cast&lt;unsigned char&gt;(frame.payload[0]);
664             unsigned char lowByte = static_cast&lt;unsigned char&gt;(frame.payload[1]);
665             m_closeEventCode = highByte &lt;&lt; 8 | lowByte;
666             if (m_closeEventCode == CloseEventCodeNoStatusRcvd || m_closeEventCode == CloseEventCodeAbnormalClosure || m_closeEventCode == CloseEventCodeTLSHandshake) {
667                 m_closeEventCode = CloseEventCodeAbnormalClosure;
668                 fail(&quot;Received a broken close frame containing a reserved status code.&quot;);
669                 return false;
670             }
671         }
672         if (frame.payloadLength &gt;= 3)
673             m_closeEventReason = String::fromUTF8(&amp;frame.payload[2], frame.payloadLength - 2);
674         else
675             m_closeEventReason = emptyString();
676         skipBuffer(frameEnd - m_buffer.data());
677         m_receivedClosingHandshake = true;
678         startClosingHandshake(m_closeEventCode, m_closeEventReason);
679         if (m_closing) {
680             if (m_outgoingFrameQueueStatus == OutgoingFrameQueueOpen)
681                 m_outgoingFrameQueueStatus = OutgoingFrameQueueClosing;
682             processOutgoingFrameQueue();
683         }
684         break;
685 
686     case WebSocketFrame::OpCodePing:
687         enqueueRawFrame(WebSocketFrame::OpCodePong, frame.payload, frame.payloadLength);
688         skipBuffer(frameEnd - m_buffer.data());
689         processOutgoingFrameQueue();
690         break;
691 
692     case WebSocketFrame::OpCodePong:
693         // A server may send a pong in response to our ping, or an unsolicited pong which is not associated with
694         // any specific ping. Either way, there&#39;s nothing to do on receipt of pong.
695         skipBuffer(frameEnd - m_buffer.data());
696         break;
697 
698     default:
699         ASSERT_NOT_REACHED();
700         skipBuffer(frameEnd - m_buffer.data());
701         break;
702     }
703 
704     return !m_buffer.isEmpty();
705 }
706 
707 void WebSocketChannel::enqueueTextFrame(const CString&amp; string)
708 {
709     ASSERT(m_outgoingFrameQueueStatus == OutgoingFrameQueueOpen);
710     auto frame = std::make_unique&lt;QueuedFrame&gt;();
711     frame-&gt;opCode = WebSocketFrame::OpCodeText;
712     frame-&gt;frameType = QueuedFrameTypeString;
713     frame-&gt;stringData = string;
714     m_outgoingFrameQueue.append(WTFMove(frame));
715 }
716 
717 void WebSocketChannel::enqueueRawFrame(WebSocketFrame::OpCode opCode, const char* data, size_t dataLength)
718 {
719     ASSERT(m_outgoingFrameQueueStatus == OutgoingFrameQueueOpen);
720     auto frame = std::make_unique&lt;QueuedFrame&gt;();
721     frame-&gt;opCode = opCode;
722     frame-&gt;frameType = QueuedFrameTypeVector;
723     frame-&gt;vectorData.resize(dataLength);
724     if (dataLength)
725         memcpy(frame-&gt;vectorData.data(), data, dataLength);
726     m_outgoingFrameQueue.append(WTFMove(frame));
727 }
728 
729 void WebSocketChannel::enqueueBlobFrame(WebSocketFrame::OpCode opCode, Blob&amp; blob)
730 {
731     ASSERT(m_outgoingFrameQueueStatus == OutgoingFrameQueueOpen);
732     auto frame = std::make_unique&lt;QueuedFrame&gt;();
733     frame-&gt;opCode = opCode;
734     frame-&gt;frameType = QueuedFrameTypeBlob;
735     frame-&gt;blobData = &amp;blob;
736     m_outgoingFrameQueue.append(WTFMove(frame));
737 }
738 
739 void WebSocketChannel::processOutgoingFrameQueue()
740 {
741     if (m_outgoingFrameQueueStatus == OutgoingFrameQueueClosed)
742         return;
743 
744     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // Any call to fail() will get the channel closed and dereferenced.
745 
746     while (!m_outgoingFrameQueue.isEmpty()) {
747         auto frame = m_outgoingFrameQueue.takeFirst();
748         switch (frame-&gt;frameType) {
749         case QueuedFrameTypeString: {
750             sendFrame(frame-&gt;opCode, frame-&gt;stringData.data(), frame-&gt;stringData.length(), [this, protectedThis = makeRef(*this)] (bool success) {
751                 if (!success)
752                     fail(&quot;Failed to send WebSocket frame.&quot;);
753             });
754             break;
755         }
756 
757         case QueuedFrameTypeVector:
758             sendFrame(frame-&gt;opCode, frame-&gt;vectorData.data(), frame-&gt;vectorData.size(), [this, protectedThis = makeRef(*this)] (bool success) {
759                 if (!success)
760                     fail(&quot;Failed to send WebSocket frame.&quot;);
761             });
762             break;
763 
764         case QueuedFrameTypeBlob: {
765             switch (m_blobLoaderStatus) {
766             case BlobLoaderNotStarted:
767                 ref(); // Will be derefed after didFinishLoading() or didFail().
768                 ASSERT(!m_blobLoader);
769                 ASSERT(frame-&gt;blobData);
770                 m_blobLoader = std::make_unique&lt;FileReaderLoader&gt;(FileReaderLoader::ReadAsArrayBuffer, this);
771                 m_blobLoaderStatus = BlobLoaderStarted;
772                 m_blobLoader-&gt;start(m_document, *frame-&gt;blobData);
773                 m_outgoingFrameQueue.prepend(WTFMove(frame));
774                 return;
775 
776             case BlobLoaderStarted:
777             case BlobLoaderFailed:
778                 m_outgoingFrameQueue.prepend(WTFMove(frame));
779                 return;
780 
781             case BlobLoaderFinished: {
782                 RefPtr&lt;ArrayBuffer&gt; result = m_blobLoader-&gt;arrayBufferResult();
783                 m_blobLoader = nullptr;
784                 m_blobLoaderStatus = BlobLoaderNotStarted;
785                 sendFrame(frame-&gt;opCode, static_cast&lt;const char*&gt;(result-&gt;data()), result-&gt;byteLength(), [this, protectedThis = makeRef(*this)] (bool success) {
786                     if (!success)
787                         fail(&quot;Failed to send WebSocket frame.&quot;);
788                 });
789                 break;
790             }
791             }
792             break;
793         }
794 
795         default:
796             ASSERT_NOT_REACHED();
797             break;
798         }
799     }
800 
801     ASSERT(m_outgoingFrameQueue.isEmpty());
802     if (m_outgoingFrameQueueStatus == OutgoingFrameQueueClosing) {
803         m_outgoingFrameQueueStatus = OutgoingFrameQueueClosed;
804         m_handle-&gt;close();
805     }
806 }
807 
808 void WebSocketChannel::abortOutgoingFrameQueue()
809 {
810     m_outgoingFrameQueue.clear();
811     m_outgoingFrameQueueStatus = OutgoingFrameQueueClosed;
812     if (m_blobLoaderStatus == BlobLoaderStarted) {
813         m_blobLoader-&gt;cancel();
814         didFail(FileError::ABORT_ERR);
815     }
816 }
817 
818 void WebSocketChannel::sendFrame(WebSocketFrame::OpCode opCode, const char* data, size_t dataLength, WTF::Function&lt;void(bool)&gt; completionHandler)
819 {
820     ASSERT(m_handle);
821     ASSERT(!m_suspended);
822 
823     WebSocketFrame frame(opCode, true, false, true, data, dataLength);
824     InspectorInstrumentation::didSendWebSocketFrame(m_document, m_identifier, frame);
825 
826     auto deflateResult = m_deflateFramer.deflate(frame);
827     if (!deflateResult-&gt;succeeded()) {
828         fail(deflateResult-&gt;failureReason());
829         return completionHandler(false);
830     }
831 
832     Vector&lt;char&gt; frameData;
833     frame.makeFrameData(frameData);
834 
835     m_handle-&gt;sendData(frameData.data(), frameData.size(), WTFMove(completionHandler));
836 }
837 
838 ResourceRequest WebSocketChannel::clientHandshakeRequest()
839 {
840     return m_handshake-&gt;clientHandshakeRequest();
841 }
842 
843 const ResourceResponse&amp; WebSocketChannel::serverHandshakeResponse() const
844 {
845     return m_handshake-&gt;serverHandshakeResponse();
846 }
847 
848 WebSocketHandshake::Mode WebSocketChannel::handshakeMode() const
849 {
850     return m_handshake-&gt;mode();
851 }
852 
853 } // namespace WebCore
    </pre>
  </body>
</html>