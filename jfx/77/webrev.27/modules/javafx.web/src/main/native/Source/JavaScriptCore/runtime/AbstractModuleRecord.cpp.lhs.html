<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AbstractModuleRecord.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AbstractModuleRecord.h&quot;
 28 
 29 #include &quot;Error.h&quot;
 30 #include &quot;Interpreter.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &quot;JSMap.h&quot;
 33 #include &quot;JSModuleEnvironment.h&quot;
 34 #include &quot;JSModuleNamespaceObject.h&quot;
 35 #include &quot;JSModuleRecord.h&quot;
 36 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
 37 #include &quot;WebAssemblyModuleRecord.h&quot;
<a name="2" id="anc2"></a>
 38 
 39 namespace JSC {
 40 namespace AbstractModuleRecordInternal {
 41 static const bool verbose = false;
 42 } // namespace AbstractModuleRecordInternal
 43 
 44 const ClassInfo AbstractModuleRecord::s_info = { &quot;AbstractModuleRecord&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(AbstractModuleRecord) };
 45 
 46 AbstractModuleRecord::AbstractModuleRecord(VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey)
 47     : Base(vm, structure)
 48     , m_moduleKey(moduleKey)
 49 {
 50 }
 51 
 52 void AbstractModuleRecord::destroy(JSCell* cell)
 53 {
 54     AbstractModuleRecord* thisObject = static_cast&lt;AbstractModuleRecord*&gt;(cell);
 55     thisObject-&gt;AbstractModuleRecord::~AbstractModuleRecord();
 56 }
 57 
 58 void AbstractModuleRecord::finishCreation(ExecState* exec, VM&amp; vm)
 59 {
 60     Base::finishCreation(vm);
 61     ASSERT(inherits(vm, info()));
 62 
 63     auto scope = DECLARE_THROW_SCOPE(vm);
 64     JSMap* map = JSMap::create(exec, vm, globalObject(vm)-&gt;mapStructure());
 65     scope.releaseAssertNoException();
 66     m_dependenciesMap.set(vm, this, map);
<a name="3" id="anc3"></a><span class="line-modified"> 67     putDirect(vm, Identifier::fromString(&amp;vm, &quot;dependenciesMap&quot;_s), m_dependenciesMap.get());</span>
 68 }
 69 
 70 void AbstractModuleRecord::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 71 {
 72     AbstractModuleRecord* thisObject = jsCast&lt;AbstractModuleRecord*&gt;(cell);
<a name="4" id="anc4"></a>
 73     Base::visitChildren(thisObject, visitor);
 74     visitor.append(thisObject-&gt;m_moduleEnvironment);
 75     visitor.append(thisObject-&gt;m_moduleNamespaceObject);
 76     visitor.append(thisObject-&gt;m_dependenciesMap);
 77 }
 78 
 79 void AbstractModuleRecord::appendRequestedModule(const Identifier&amp; moduleName)
 80 {
 81     m_requestedModules.add(moduleName.impl());
 82 }
 83 
 84 void AbstractModuleRecord::addStarExportEntry(const Identifier&amp; moduleName)
 85 {
 86     m_starExportEntries.add(moduleName.impl());
 87 }
 88 
 89 void AbstractModuleRecord::addImportEntry(const ImportEntry&amp; entry)
 90 {
 91     bool isNewEntry = m_importEntries.add(entry.localName.impl(), entry).isNewEntry;
 92     ASSERT_UNUSED(isNewEntry, isNewEntry); // This is guaranteed by the parser.
 93 }
 94 
 95 void AbstractModuleRecord::addExportEntry(const ExportEntry&amp; entry)
 96 {
 97     bool isNewEntry = m_exportEntries.add(entry.exportName.impl(), entry).isNewEntry;
 98     ASSERT_UNUSED(isNewEntry, isNewEntry); // This is guaranteed by the parser.
 99 }
100 
101 auto AbstractModuleRecord::tryGetImportEntry(UniquedStringImpl* localName) -&gt; Optional&lt;ImportEntry&gt;
102 {
103     const auto iterator = m_importEntries.find(localName);
104     if (iterator == m_importEntries.end())
105         return WTF::nullopt;
106     return Optional&lt;ImportEntry&gt;(iterator-&gt;value);
107 }
108 
109 auto AbstractModuleRecord::tryGetExportEntry(UniquedStringImpl* exportName) -&gt; Optional&lt;ExportEntry&gt;
110 {
111     const auto iterator = m_exportEntries.find(exportName);
112     if (iterator == m_exportEntries.end())
113         return WTF::nullopt;
114     return Optional&lt;ExportEntry&gt;(iterator-&gt;value);
115 }
116 
117 auto AbstractModuleRecord::ExportEntry::createLocal(const Identifier&amp; exportName, const Identifier&amp; localName) -&gt; ExportEntry
118 {
119     return ExportEntry { Type::Local, exportName, Identifier(), Identifier(), localName };
120 }
121 
122 auto AbstractModuleRecord::ExportEntry::createIndirect(const Identifier&amp; exportName, const Identifier&amp; importName, const Identifier&amp; moduleName) -&gt; ExportEntry
123 {
124     return ExportEntry { Type::Indirect, exportName, moduleName, importName, Identifier() };
125 }
126 
127 auto AbstractModuleRecord::Resolution::notFound() -&gt; Resolution
128 {
129     return Resolution { Type::NotFound, nullptr, Identifier() };
130 }
131 
132 auto AbstractModuleRecord::Resolution::error() -&gt; Resolution
133 {
134     return Resolution { Type::Error, nullptr, Identifier() };
135 }
136 
137 auto AbstractModuleRecord::Resolution::ambiguous() -&gt; Resolution
138 {
139     return Resolution { Type::Ambiguous, nullptr, Identifier() };
140 }
141 
142 AbstractModuleRecord* AbstractModuleRecord::hostResolveImportedModule(ExecState* exec, const Identifier&amp; moduleName)
143 {
144     VM&amp; vm = exec-&gt;vm();
145     auto scope = DECLARE_THROW_SCOPE(vm);
146     JSValue moduleNameValue = identifierToJSValue(vm, moduleName);
147     JSValue entry = m_dependenciesMap-&gt;JSMap::get(exec, moduleNameValue);
148     RETURN_IF_EXCEPTION(scope, nullptr);
<a name="5" id="anc5"></a><span class="line-modified">149     RELEASE_AND_RETURN(scope, jsCast&lt;AbstractModuleRecord*&gt;(entry.get(exec, Identifier::fromString(exec, &quot;module&quot;))));</span>
150 }
151 
152 auto AbstractModuleRecord::resolveImport(ExecState* exec, const Identifier&amp; localName) -&gt; Resolution
153 {
154     VM&amp; vm = exec-&gt;vm();
155     auto scope = DECLARE_THROW_SCOPE(vm);
156 
157     Optional&lt;ImportEntry&gt; optionalImportEntry = tryGetImportEntry(localName.impl());
158     if (!optionalImportEntry)
159         return Resolution::notFound();
160 
161     const ImportEntry&amp; importEntry = *optionalImportEntry;
162     if (importEntry.type == AbstractModuleRecord::ImportEntryType::Namespace)
163         return Resolution::notFound();
164 
165     AbstractModuleRecord* importedModule = hostResolveImportedModule(exec, importEntry.moduleRequest);
166     RETURN_IF_EXCEPTION(scope, Resolution::error());
167     return importedModule-&gt;resolveExport(exec, importEntry.importName);
168 }
169 
170 struct AbstractModuleRecord::ResolveQuery {
171     struct Hash {
172         static unsigned hash(const ResolveQuery&amp;);
173         static bool equal(const ResolveQuery&amp;, const ResolveQuery&amp;);
174         static const bool safeToCompareToEmptyOrDeleted = true;
175     };
176     using HashTraits = WTF::CustomHashTraits&lt;ResolveQuery&gt;;
177 
178     ResolveQuery(AbstractModuleRecord* moduleRecord, UniquedStringImpl* exportName)
179         : moduleRecord(moduleRecord)
180         , exportName(exportName)
181     {
182     }
183 
184     ResolveQuery(AbstractModuleRecord* moduleRecord, const Identifier&amp; exportName)
185         : ResolveQuery(moduleRecord, exportName.impl())
186     {
187     }
188 
189     enum EmptyValueTag { EmptyValue };
190     ResolveQuery(EmptyValueTag)
191     {
192     }
193 
194     enum DeletedValueTag { DeletedValue };
195     ResolveQuery(DeletedValueTag)
196         : moduleRecord(nullptr)
197         , exportName(WTF::HashTableDeletedValue)
198     {
199     }
200 
201     bool isEmptyValue() const
202     {
203         return !exportName;
204     }
205 
206     bool isDeletedValue() const
207     {
208         return exportName.isHashTableDeletedValue();
209     }
210 
211     void dump(PrintStream&amp; out) const
212     {
213         if (!moduleRecord) {
214             out.print(&quot;&lt;empty&gt;&quot;);
215             return;
216         }
217         out.print(moduleRecord-&gt;moduleKey(), &quot; \&quot;&quot;, exportName.get(), &quot;\&quot;&quot;);
218     }
219 
220     // The module record is not marked from the GC. But these records are reachable from the JSGlobalObject.
221     // So we don&#39;t care the reachability to this record.
222     AbstractModuleRecord* moduleRecord;
223     RefPtr&lt;UniquedStringImpl&gt; exportName;
224 };
225 
226 inline unsigned AbstractModuleRecord::ResolveQuery::Hash::hash(const ResolveQuery&amp; query)
227 {
228     return WTF::PtrHash&lt;AbstractModuleRecord*&gt;::hash(query.moduleRecord) + IdentifierRepHash::hash(query.exportName);
229 }
230 
231 inline bool AbstractModuleRecord::ResolveQuery::Hash::equal(const ResolveQuery&amp; lhs, const ResolveQuery&amp; rhs)
232 {
233     return lhs.moduleRecord == rhs.moduleRecord &amp;&amp; lhs.exportName == rhs.exportName;
234 }
235 
236 auto AbstractModuleRecord::tryGetCachedResolution(UniquedStringImpl* exportName) -&gt; Optional&lt;Resolution&gt;
237 {
238     const auto iterator = m_resolutionCache.find(exportName);
239     if (iterator == m_resolutionCache.end())
240         return WTF::nullopt;
241     return Optional&lt;Resolution&gt;(iterator-&gt;value);
242 }
243 
244 void AbstractModuleRecord::cacheResolution(UniquedStringImpl* exportName, const Resolution&amp; resolution)
245 {
246     m_resolutionCache.add(exportName, resolution);
247 }
248 
249 auto AbstractModuleRecord::resolveExportImpl(ExecState* exec, const ResolveQuery&amp; root) -&gt; Resolution
250 {
251     VM&amp; vm = exec-&gt;vm();
252     auto scope = DECLARE_THROW_SCOPE(vm);
253 
254     if (AbstractModuleRecordInternal::verbose)
255         dataLog(&quot;Resolving &quot;, root, &quot;\n&quot;);
256 
257     // https://tc39.github.io/ecma262/#sec-resolveexport
258 
259     // How to avoid C++ recursion in this function:
260     // This function avoids C++ recursion of the naive ResolveExport implementation.
261     // Flatten the recursion to the loop with the task queue and frames.
262     //
263     // 1. pendingTasks
264     //     We enqueue the recursive resolveExport call to this queue to avoid recursive calls in C++.
265     //     The task has 3 types. (1) Query, (2) IndirectFallback and (3) GatherStars.
266     //     (1) Query
267     //         Querying the resolution to the current module.
268     //     (2) IndirectFallback
269     //         Examine the result of the indirect export resolution. Only when the indirect export resolution fails,
270     //         we look into the star exports. (step 5-a-vi).
271     //     (3) GatherStars
272     //         Examine the result of the star export resolutions.
273     //
274     // 2. frames
275     //     When the spec calls the resolveExport recursively, instead we append the frame
276     //     (that holds the result resolution) to the frames and enqueue the task to the pendingTasks.
277     //     The entry in the frames means the *local* resolution result of the specific recursive resolveExport.
278     //
279     // We should maintain the local resolution result instead of holding the global resolution result only.
280     // For example,
281     //
282     //     star
283     // (1) ---&gt; (2) &quot;Resolve&quot;
284     //      |
285     //      |
286     //      +-&gt; (3) &quot;NotFound&quot;
287     //      |
288     //      |       star
289     //      +-&gt; (4) ---&gt; (5) &quot;Resolve&quot; [here]
290     //               |
291     //               |
292     //               +-&gt; (6) &quot;Error&quot;
293     //
294     // Consider the above graph. The numbers represents the modules. Now we are [here].
295     // If we only hold the global resolution result during the resolveExport operation, [here],
296     // we decide the entire result of resolveExport is &quot;Ambiguous&quot;, because there are multiple
297     // &quot;Resolve&quot; (in module (2) and (5)). However, this should become &quot;Error&quot; because (6) will
298     // propagate &quot;Error&quot; state to the (4), (4) will become &quot;Error&quot; and then, (1) will become
299     // &quot;Error&quot;. We should aggregate the results at the star exports point ((4) and (1)).
300     //
301     // Usually, both &quot;Error&quot; and &quot;Ambiguous&quot; states will throw the syntax error. So except for the content of the
302     // error message, there are no difference. (And if we fix the (6) that raises &quot;Error&quot;, next, it will produce
303     // the &quot;Ambiguous&quot; error due to (5). Anyway, user need to fix the both. So which error should be raised at first
304     // doesn&#39;t matter so much.
305     //
306     // However, this may become the problem under the module namespace creation.
307     // http://www.ecma-international.org/ecma-262/6.0/#sec-getmodulenamespace
308     // section 15.2.1.18, step 3-d-ii
309     // Here, we distinguish &quot;Ambiguous&quot; and &quot;Error&quot;. When &quot;Error&quot; state is produced, we need to throw the propagated error.
310     // But if &quot;Ambiguous&quot; state comes, we just ignore the result.
311     // To follow the requirement strictly, in this implementation, we keep the local resolution result to produce the
312     // correct result under the above complex cases.
313 
314     // Caching strategy:
315     // The resolveExport operation is frequently called. So caching results is important.
316     // We observe the following aspects and based on them construct the caching strategy.
317     // Here, we attempt to cache the resolution by constructing the map in module records.
318     // That means  Module -&gt; ExportName -&gt; Maybe&lt;Resolution&gt;.
319     // Technically, all the AbstractModuleRecords have the Map&lt;ExportName, Resolution&gt; for caching.
320     //
321     // The important observations are that,
322     //
323     //  - *cacheable* means that traversing to this node from a path will produce the same results as starting from this node.
324     //
325     //    Here, we define the resovling route. We represent [?] as the module that has the local binding.
326     //    And (?) as the module without the local binding.
327     //
328     //      @ -&gt; (A) -&gt; (B) -&gt; [C]
329     //
330     //    We list the resolving route for each node.
331     //
332     //    (A): (A) -&gt; (B) -&gt; [C]
333     //    (B): (B) -&gt; [C]
334     //    [C]: [C]
335     //
336     //    In this case, if we start the tracing from (B), the resolving route becomes (B) -&gt; [C].
337     //    So this is the same. At that time, we can say (B) is cacheable in the first tracing.
338     //
339     //  - The cache ability of a node depends on the resolving route from this node.
340     //
341     // 1. The starting point is always cacheable.
342     //
343     // 2. A module that has resolved a local binding is always cacheable.
344     //
345     //  @ -&gt; (A) -&gt; [B]
346     //
347     //  In the above case, we can see the [B] as cacheable.
348     //  This is because when starting from [B] node, we immediately resolve with the local binding.
349     //  So the resolving route from [B] does not depend on the starting point.
350     //
351     // 3. If we don&#39;t follow any star links during the resolution, we can see all the traced nodes are cacheable.
352     //
353     //  If there are non star links, it means that there is *no branch* in the module dependency graph.
354     //  This *no branch* feature makes all the modules cachable.
355     //
356     //  I.e, if we traverse one star link (even if we successfully resolve that star link),
357     //  we must still traverse all other star links. I would also explain we don&#39;t run into
358     //  this when resolving a local/indirect link. When resolving a local/indirect link,
359     //  we won&#39;t traverse any star links.
360     //  And since the module can hold only one local/indirect link for the specific export name (if there
361     //  are multiple local/indirect links that has the same export name, it should be syntax error in the
362     //  parsing phase.), there is no multiple outgoing links from a module.
363     //
364     //  @ -&gt; (A) --&gt; (B) -&gt; [C] -&gt; (D) -&gt; (E) -+
365     //                ^                        |
366     //                |                        |
367     //                +------------------------+
368     //
369     //  When starting from @, [C] will be found as the module resolving the given binding.
370     //  In this case, (B) can cache this resolution. Since the resolving route is the same to the one when
371     //  starting from (B). After caching the above result, we attempt to resolve the same binding from (D).
372     //
373     //                              @
374     //                              |
375     //                              v
376     //  @ -&gt; (A) --&gt; (B) -&gt; [C] -&gt; (D) -&gt; (E) -+
377     //                ^                        |
378     //                |                        |
379     //                +------------------------+
380     //
381     //  In this case, we can use the (B)&#39;s cached result. And (E) can be cached.
382     //
383     //    (E): The resolving route is now (E) -&gt; (B) -&gt; [C]. That is the same when starting from (E).
384     //
385     //  No branching makes that the problematic *once-visited* node cannot be seen.
386     //  The *once-visited* node makes the resolving route changed since when we see the *once-visited* node,
387     //  we stop tracing this.
388     //
389     //  If there is no star links and if we look *once-visited* node under no branching graph, *once-visited*
390     //  node cannot resolve the requested binding. If the *once-visited* node can resolve the binding, we
391     //  should have already finished the resolution before reaching this *once-visited* node.
392     //
393     // 4. Once we follow star links, we should not retrieve the result from the cache and should not cache.
394     //
395     //  Star links are only the way to introduce branch.
396     //  Once we follow the star links during the resolution, we cannot cache naively.
397     //  This is because the cacheability depends on the resolving route. And branching produces the problematic *once-visited*
398     //  nodes. Since we don&#39;t follow the *once-visited* node, the resolving route from the node becomes different from
399     //  the resolving route when starting from this node.
400     //
401     //  The following example explains when we should not retrieve the cache and cache the result.
402     //
403     //               +----&gt; (D) ------+
404     //               |                |
405     //               |                v
406     //      (A) *----+----&gt; (B) ---&gt; [C]
407     //                       ^
408     //                       |
409     //                       @
410     //
411     //  When starting from (B), we find [C]. In this resolving route, we don&#39;t find any star link.
412     //  And by definition, (B) and [C] are cachable. (B) is the starting point. And [C] has the local binding.
413     //
414     //               +----&gt; (D) ------+
415     //               |                |
416     //               |                v
417     //  @-&gt; (A) *----+----&gt; (B) ---&gt; [C]
418     //
419     //  But when starting from (A), we should not get the value from the cache. Because,
420     //
421     //    1. When looking (D), we reach [C] and make both resolved.
422     //    2. When looking (B), if we retrieved the last cache from (B), (B) becomes resolved.
423     //    3. But actually, (B) is not-found in this trial because (C) is already *once-visited*.
424     //    4. If we accidentally make (B) resolved, (A) becomes ambiguous. But the correct answer is resolved.
425     //
426     //  Why is this problem caused? This is because the *once-visited* node makes the result not-found.
427     //  In the second trial, (B) -&gt; [C] result is changed from resolved to not-found.
428     //
429     //  When does this become a problem? If the status of the *once-visited* node group is resolved,
430     //  changing the result to not-found makes the result changed.
431     //
432     //  This problem does not happen when we don&#39;t see any star link yet. Now, consider the minimum case.
433     //
434     //  @-&gt; (A) -&gt; [ some graph ]
435     //       ^            |
436     //       |            |
437     //       +------------+
438     //
439     //  In (A), we don&#39;t see any star link yet. So we can say that all the visited nodes does not have any local
440     //  resolution. Because if they had a local/indirect resolution, we should have already finished the tracing.
441     //
442     //  And even if the some graph will see the *once-visited* node (in this case, (A)), that does not affect the
443     //  result of the resolution. Because even if we follow the link to (A) or not follow the link to (A), the status
444     //  of the link is always not-found since (A) does not have any local resolution.
445     //  In the above case, we can use the result of the [some graph].
446     //
447     // 5. Once we see star links, even if we have not yet traversed that star link path, we should disable caching.
448     //
449     //  Here is the reason why:
450     //
451     //       +-------------+
452     //       |             |
453     //       v             |
454     //      (A) -&gt; (B) -&gt; (C) *-&gt; [E]
455     //       *             ^
456     //       |             |
457     //       v             @
458     //      [D]
459     //
460     //  In the above case, (C) will be resolved with [D].
461     //  (C) will see (A) and (A) gives up in (A) -&gt; (B) -&gt; (C) route. So, (A) will fallback to [D].
462     //
463     //       +-------------+
464     //       |             |
465     //       v             |
466     //  @-&gt; (A) -&gt; (B) -&gt; (C) *-&gt; [E]
467     //       *
468     //       |
469     //       v
470     //      [D]
471     //
472     //  But in this case, (A) will be resolved with [E] (not [D]).
473     //  (C) will attempt to follow the link to (A), but it fails.
474     //  So (C) will fallback to the star link and found [E]. In this senario,
475     //  (C) is now resolved with [E]&#39;s result.
476     //
477     //  The cause of this problem is also the same to 4.
478     //  In the latter case, when looking (C), we cannot use the cached result in (C).
479     //  Because the cached result of (C) depends on the *once-visited* node (A) and
480     //  (A) has the fallback system with the star link.
481     //  In the latter trial, we now assume that (A)&#39;s status is not-found.
482     //  But, actually, in the former trial, (A)&#39;s status becomes resolved due to the fallback to the [D].
483     //
484     // To summarize the observations.
485     //
486     //  1. The starting point is always cacheable.
487     //  2. A module that has resolved a local binding is always cacheable.
488     //  3. If we don&#39;t follow any star links during the resolution, we can see all the traced nodes are cacheable.
489     //  4. Once we follow star links, we should not retrieve the result from the cache and should not cache the result.
490     //  5. Once we see star links, even if we have not yet traversed that star link path, we should disable caching.
491 
492     using ResolveSet = WTF::HashSet&lt;ResolveQuery, ResolveQuery::Hash, ResolveQuery::HashTraits&gt;;
493     enum class Type { Query, IndirectFallback, GatherStars };
494     struct Task {
495         ResolveQuery query;
496         Type type;
497     };
498 
499     auto typeString = [] (Type type) -&gt; const char* {
500         switch (type) {
501         case Type::Query:
502             return &quot;Query&quot;;
503         case Type::IndirectFallback:
504             return &quot;IndirectFallback&quot;;
505         case Type::GatherStars:
506             return &quot;GatherStars&quot;;
507         }
508         RELEASE_ASSERT_NOT_REACHED();
509         return nullptr;
510     };
511 
512     Vector&lt;Task, 8&gt; pendingTasks;
513     ResolveSet resolveSet;
514 
515     Vector&lt;Resolution, 8&gt; frames;
516 
517     bool foundStarLinks = false;
518 
519     frames.append(Resolution::notFound());
520 
521     // Call when the query is not resolved in the current module.
522     // It will enqueue the star resolution requests. Return &quot;false&quot; if the error occurs.
523     auto resolveNonLocal = [&amp;](const ResolveQuery&amp; query) -&gt; bool {
524         // https://tc39.github.io/ecma262/#sec-resolveexport
525         // section 15.2.1.16.3, step 6
526         // If the &quot;default&quot; name is not resolved in the current module, we need to throw an error and stop resolution immediately,
527         // Rationale to this error: A default export cannot be provided by an export *.
528         VM&amp; vm = exec-&gt;vm();
529         auto scope = DECLARE_THROW_SCOPE(vm);
530         if (query.exportName == vm.propertyNames-&gt;defaultKeyword.impl())
531             return false;
532 
533         // Enqueue the task to gather the results of the stars.
534         // And append the new Resolution frame to gather the local result of the stars.
535         pendingTasks.append(Task { query, Type::GatherStars });
536         foundStarLinks = true;
537         frames.append(Resolution::notFound());
538 
539         // Enqueue the tasks in reverse order.
540         for (auto iterator = query.moduleRecord-&gt;starExportEntries().rbegin(), end = query.moduleRecord-&gt;starExportEntries().rend(); iterator != end; ++iterator) {
541             const RefPtr&lt;UniquedStringImpl&gt;&amp; starModuleName = *iterator;
<a name="6" id="anc6"></a><span class="line-modified">542             AbstractModuleRecord* importedModuleRecord = query.moduleRecord-&gt;hostResolveImportedModule(exec, Identifier::fromUid(exec, starModuleName.get()));</span>
543             RETURN_IF_EXCEPTION(scope, false);
544             pendingTasks.append(Task { ResolveQuery(importedModuleRecord, query.exportName.get()), Type::Query });
545         }
546         return true;
547     };
548 
549     // Return the current resolution value of the top frame.
550     auto currentTop = [&amp;] () -&gt; Resolution&amp; {
551         ASSERT(!frames.isEmpty());
552         return frames.last();
553     };
554 
555     // Merge the given resolution to the current resolution value of the top frame.
556     // If there is ambiguity, return &quot;false&quot;. When the &quot;false&quot; is returned, we should make the result &quot;ambiguous&quot;.
557     auto mergeToCurrentTop = [&amp;] (const Resolution&amp; resolution) -&gt; bool {
558         if (resolution.type == Resolution::Type::NotFound)
559             return true;
560 
561         if (currentTop().type == Resolution::Type::NotFound) {
562             currentTop() = resolution;
563             return true;
564         }
565 
566         if (currentTop().moduleRecord != resolution.moduleRecord || currentTop().localName != resolution.localName)
567             return false;
568 
569         return true;
570     };
571 
572     auto cacheResolutionForQuery = [] (const ResolveQuery&amp; query, const Resolution&amp; resolution) {
573         ASSERT(resolution.type == Resolution::Type::Resolved);
574         query.moduleRecord-&gt;cacheResolution(query.exportName.get(), resolution);
575     };
576 
577     pendingTasks.append(Task { root, Type::Query });
578     while (!pendingTasks.isEmpty()) {
579         const Task task = pendingTasks.takeLast();
580         const ResolveQuery&amp; query = task.query;
581 
582         if (AbstractModuleRecordInternal::verbose)
583             dataLog(&quot;    &quot;, typeString(task.type), &quot; &quot;, task.query, &quot;\n&quot;);
584 
585         switch (task.type) {
586         case Type::Query: {
587             AbstractModuleRecord* moduleRecord = query.moduleRecord;
588 
589             if (!resolveSet.add(task.query).isNewEntry)
590                 continue;
591 
592             //  5. Once we see star links, even if we have not yet traversed that star link path, we should disable caching.
593             if (!moduleRecord-&gt;starExportEntries().isEmpty())
594                 foundStarLinks = true;
595 
596             //  4. Once we follow star links, we should not retrieve the result from the cache and should not cache the result.
597             if (!foundStarLinks) {
598                 if (Optional&lt;Resolution&gt; cachedResolution = moduleRecord-&gt;tryGetCachedResolution(query.exportName.get())) {
599                     if (!mergeToCurrentTop(*cachedResolution))
600                         return Resolution::ambiguous();
601                     continue;
602                 }
603             }
604 
605             const Optional&lt;ExportEntry&gt; optionalExportEntry = moduleRecord-&gt;tryGetExportEntry(query.exportName.get());
606             if (!optionalExportEntry) {
607                 // If there is no matched exported binding in the current module,
608                 // we need to look into the stars.
609                 bool success = resolveNonLocal(task.query);
610                 EXCEPTION_ASSERT(!scope.exception() || !success);
611                 if (!success)
612                     return Resolution::error();
613                 continue;
614             }
615 
616             const ExportEntry&amp; exportEntry = *optionalExportEntry;
617             switch (exportEntry.type) {
618             case ExportEntry::Type::Local: {
619                 ASSERT(!exportEntry.localName.isNull());
620                 Resolution resolution { Resolution::Type::Resolved, moduleRecord, exportEntry.localName };
621                 //  2. A module that has resolved a local binding is always cacheable.
622                 cacheResolutionForQuery(query, resolution);
623                 if (!mergeToCurrentTop(resolution))
624                     return Resolution::ambiguous();
625                 continue;
626             }
627 
628             case ExportEntry::Type::Indirect: {
629                 AbstractModuleRecord* importedModuleRecord = moduleRecord-&gt;hostResolveImportedModule(exec, exportEntry.moduleName);
630                 RETURN_IF_EXCEPTION(scope, Resolution::error());
631 
632                 // When the imported module does not produce any resolved binding, we need to look into the stars in the *current*
633                 // module. To do this, we append the `IndirectFallback` task to the task queue.
634                 pendingTasks.append(Task { query, Type::IndirectFallback });
635                 // And append the new Resolution frame to check the indirect export will be resolved or not.
636                 frames.append(Resolution::notFound());
637                 pendingTasks.append(Task { ResolveQuery(importedModuleRecord, exportEntry.importName), Type::Query });
638                 continue;
639             }
640             }
641             break;
642         }
643 
644         case Type::IndirectFallback: {
645             Resolution resolution = frames.takeLast();
646 
647             if (resolution.type == Resolution::Type::NotFound) {
648                 // Indirect export entry does not produce any resolved binding.
649                 // So we will investigate the stars.
650                 bool success = resolveNonLocal(task.query);
651                 EXCEPTION_ASSERT(!scope.exception() || !success);
652                 if (!success)
653                     return Resolution::error();
654                 continue;
655             }
656 
657             ASSERT_WITH_MESSAGE(resolution.type == Resolution::Type::Resolved, &quot;When we see Error and Ambiguous, we immediately return from this loop. So here, only Resolved comes.&quot;);
658 
659             //  3. If we don&#39;t follow any star links during the resolution, we can see all the traced nodes are cacheable.
660             //  4. Once we follow star links, we should not retrieve the result from the cache and should not cache the result.
661             if (!foundStarLinks)
662                 cacheResolutionForQuery(query, resolution);
663 
664             // If indirect export entry produces Resolved, we should merge it to the upper frame.
665             // And do not investigate the stars of the current module.
666             if (!mergeToCurrentTop(resolution))
667                 return Resolution::ambiguous();
668             break;
669         }
670 
671         case Type::GatherStars: {
672             Resolution resolution = frames.takeLast();
673             ASSERT_WITH_MESSAGE(resolution.type == Resolution::Type::Resolved || resolution.type == Resolution::Type::NotFound, &quot;When we see Error and Ambiguous, we immediately return from this loop. So here, only Resolved and NotFound comes.&quot;);
674 
675             // Merge the star resolution to the upper frame.
676             if (!mergeToCurrentTop(resolution))
677                 return Resolution::ambiguous();
678             break;
679         }
680         }
681     }
682 
683     ASSERT(frames.size() == 1);
684     //  1. The starting point is always cacheable.
685     if (frames[0].type == Resolution::Type::Resolved)
686         cacheResolutionForQuery(root, frames[0]);
687     return frames[0];
688 }
689 
690 auto AbstractModuleRecord::resolveExport(ExecState* exec, const Identifier&amp; exportName) -&gt; Resolution
691 {
692     // Look up the cached resolution first before entering the resolving loop, since the loop setup takes some cost.
693     if (Optional&lt;Resolution&gt; cachedResolution = tryGetCachedResolution(exportName.impl()))
694         return *cachedResolution;
695     return resolveExportImpl(exec, ResolveQuery(this, exportName.impl()));
696 }
697 
698 static void getExportedNames(ExecState* exec, AbstractModuleRecord* root, IdentifierSet&amp; exportedNames)
699 {
700     VM&amp; vm = exec-&gt;vm();
701     auto scope = DECLARE_THROW_SCOPE(vm);
702 
703     HashSet&lt;AbstractModuleRecord*&gt; exportStarSet;
704     Vector&lt;AbstractModuleRecord*, 8&gt; pendingModules;
705 
706     pendingModules.append(root);
707 
708     while (!pendingModules.isEmpty()) {
709         AbstractModuleRecord* moduleRecord = pendingModules.takeLast();
710         if (exportStarSet.contains(moduleRecord))
711             continue;
712         exportStarSet.add(moduleRecord);
713 
714         for (const auto&amp; pair : moduleRecord-&gt;exportEntries()) {
715             const AbstractModuleRecord::ExportEntry&amp; exportEntry = pair.value;
716             if (moduleRecord == root || vm.propertyNames-&gt;defaultKeyword != exportEntry.exportName)
717                 exportedNames.add(exportEntry.exportName.impl());
718         }
719 
720         for (const auto&amp; starModuleName : moduleRecord-&gt;starExportEntries()) {
<a name="7" id="anc7"></a><span class="line-modified">721             AbstractModuleRecord* requestedModuleRecord = moduleRecord-&gt;hostResolveImportedModule(exec, Identifier::fromUid(exec, starModuleName.get()));</span>
722             RETURN_IF_EXCEPTION(scope, void());
723             pendingModules.append(requestedModuleRecord);
724         }
725     }
726 }
727 
728 JSModuleNamespaceObject* AbstractModuleRecord::getModuleNamespace(ExecState* exec)
729 {
730     VM&amp; vm = exec-&gt;vm();
731     auto scope = DECLARE_THROW_SCOPE(vm);
732 
733     // http://www.ecma-international.org/ecma-262/6.0/#sec-getmodulenamespace
734     if (m_moduleNamespaceObject)
735         return m_moduleNamespaceObject.get();
736 
737     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
738     IdentifierSet exportedNames;
739     getExportedNames(exec, this, exportedNames);
740     RETURN_IF_EXCEPTION(scope, nullptr);
741 
742     Vector&lt;std::pair&lt;Identifier, Resolution&gt;&gt; resolutions;
743     for (auto&amp; name : exportedNames) {
<a name="8" id="anc8"></a><span class="line-modified">744         Identifier ident = Identifier::fromUid(exec, name.get());</span>
745         const Resolution resolution = resolveExport(exec, ident);
746         RETURN_IF_EXCEPTION(scope, nullptr);
747         switch (resolution.type) {
748         case Resolution::Type::NotFound:
749             throwSyntaxError(exec, scope, makeString(&quot;Exported binding name &#39;&quot;, String(name.get()), &quot;&#39; is not found.&quot;));
750             return nullptr;
751 
752         case Resolution::Type::Error:
753             throwSyntaxError(exec, scope, makeString(&quot;Exported binding name &#39;default&#39; cannot be resolved by star export entries.&quot;));
754             return nullptr;
755 
756         case Resolution::Type::Ambiguous:
757             break;
758 
759         case Resolution::Type::Resolved:
760             resolutions.append({ WTFMove(ident), resolution });
761             break;
762         }
763     }
764 
765     auto* moduleNamespaceObject = JSModuleNamespaceObject::create(exec, globalObject, globalObject-&gt;moduleNamespaceObjectStructure(), this, WTFMove(resolutions));
766     RETURN_IF_EXCEPTION(scope, nullptr);
767     m_moduleNamespaceObject.set(vm, this, moduleNamespaceObject);
768     return moduleNamespaceObject;
769 }
770 
771 void AbstractModuleRecord::link(ExecState* exec, JSValue scriptFetcher)
772 {
773     VM&amp; vm = exec-&gt;vm();
774     if (auto* jsModuleRecord = jsDynamicCast&lt;JSModuleRecord*&gt;(vm, this))
775         return jsModuleRecord-&gt;link(exec, scriptFetcher);
776 #if ENABLE(WEBASSEMBLY)
777     if (auto* wasmModuleRecord = jsDynamicCast&lt;WebAssemblyModuleRecord*&gt;(vm, this))
778         return wasmModuleRecord-&gt;link(exec, scriptFetcher, nullptr, Wasm::CreationMode::FromModuleLoader);
779 #endif
780     RELEASE_ASSERT_NOT_REACHED();
781 }
782 
783 JS_EXPORT_PRIVATE JSValue AbstractModuleRecord::evaluate(ExecState* exec)
784 {
785     VM&amp; vm = exec-&gt;vm();
786     if (auto* jsModuleRecord = jsDynamicCast&lt;JSModuleRecord*&gt;(vm, this))
787         return jsModuleRecord-&gt;evaluate(exec);
788 #if ENABLE(WEBASSEMBLY)
789     if (auto* wasmModuleRecord = jsDynamicCast&lt;WebAssemblyModuleRecord*&gt;(vm, this))
790         return wasmModuleRecord-&gt;evaluate(exec);
791 #endif
792     RELEASE_ASSERT_NOT_REACHED();
793     return jsUndefined();
794 }
795 
796 static String printableName(const RefPtr&lt;UniquedStringImpl&gt;&amp; uid)
797 {
798     if (uid-&gt;isSymbol())
799         return uid.get();
800     return WTF::makeString(&quot;&#39;&quot;, String(uid.get()), &quot;&#39;&quot;);
801 }
802 
803 static String printableName(const Identifier&amp; ident)
804 {
805     return printableName(ident.impl());
806 }
807 
808 void AbstractModuleRecord::dump()
809 {
810     dataLog(&quot;\nAnalyzing ModuleRecord key(&quot;, printableName(m_moduleKey), &quot;)\n&quot;);
811 
812     dataLog(&quot;    Dependencies: &quot;, m_requestedModules.size(), &quot; modules\n&quot;);
813     for (const auto&amp; moduleName : m_requestedModules)
814         dataLog(&quot;      module(&quot;, printableName(moduleName), &quot;)\n&quot;);
815 
816     dataLog(&quot;    Import: &quot;, m_importEntries.size(), &quot; entries\n&quot;);
817     for (const auto&amp; pair : m_importEntries) {
818         const ImportEntry&amp; importEntry = pair.value;
819         dataLog(&quot;      import(&quot;, printableName(importEntry.importName), &quot;), local(&quot;, printableName(importEntry.localName), &quot;), module(&quot;, printableName(importEntry.moduleRequest), &quot;)\n&quot;);
820     }
821 
822     dataLog(&quot;    Export: &quot;, m_exportEntries.size(), &quot; entries\n&quot;);
823     for (const auto&amp; pair : m_exportEntries) {
824         const ExportEntry&amp; exportEntry = pair.value;
825         switch (exportEntry.type) {
826         case ExportEntry::Type::Local:
827             dataLog(&quot;      [Local] &quot;, &quot;export(&quot;, printableName(exportEntry.exportName), &quot;), local(&quot;, printableName(exportEntry.localName), &quot;)\n&quot;);
828             break;
829 
830         case ExportEntry::Type::Indirect:
831             dataLog(&quot;      [Indirect] &quot;, &quot;export(&quot;, printableName(exportEntry.exportName), &quot;), import(&quot;, printableName(exportEntry.importName), &quot;), module(&quot;, printableName(exportEntry.moduleName), &quot;)\n&quot;);
832             break;
833         }
834     }
835     for (const auto&amp; moduleName : m_starExportEntries)
836         dataLog(&quot;      [Star] module(&quot;, printableName(moduleName.get()), &quot;)\n&quot;);
837 }
838 
839 } // namespace JSC
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>