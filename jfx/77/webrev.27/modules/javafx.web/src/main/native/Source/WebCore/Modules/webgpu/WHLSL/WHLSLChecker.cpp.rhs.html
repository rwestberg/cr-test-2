<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WHLSLChecker.h&quot;
  28 
  29 #if ENABLE(WEBGPU)
  30 
  31 #include &quot;WHLSLArrayReferenceType.h&quot;
  32 #include &quot;WHLSLArrayType.h&quot;
  33 #include &quot;WHLSLAssignmentExpression.h&quot;
  34 #include &quot;WHLSLCallExpression.h&quot;
  35 #include &quot;WHLSLCommaExpression.h&quot;
  36 #include &quot;WHLSLDereferenceExpression.h&quot;
  37 #include &quot;WHLSLDoWhileLoop.h&quot;
  38 #include &quot;WHLSLDotExpression.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  39 #include &quot;WHLSLEntryPointType.h&quot;</span>
  40 #include &quot;WHLSLForLoop.h&quot;
  41 #include &quot;WHLSLGatherEntryPointItems.h&quot;
  42 #include &quot;WHLSLIfStatement.h&quot;
  43 #include &quot;WHLSLIndexExpression.h&quot;
  44 #include &quot;WHLSLInferTypes.h&quot;
  45 #include &quot;WHLSLLogicalExpression.h&quot;
  46 #include &quot;WHLSLLogicalNotExpression.h&quot;
  47 #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;
  48 #include &quot;WHLSLMakePointerExpression.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  49 #include &quot;WHLSLNameContext.h&quot;</span>
  50 #include &quot;WHLSLPointerType.h&quot;
  51 #include &quot;WHLSLProgram.h&quot;
  52 #include &quot;WHLSLReadModifyWriteExpression.h&quot;
  53 #include &quot;WHLSLResolvableType.h&quot;
  54 #include &quot;WHLSLResolveOverloadImpl.h&quot;
  55 #include &quot;WHLSLResolvingType.h&quot;
  56 #include &quot;WHLSLReturn.h&quot;
  57 #include &quot;WHLSLSwitchStatement.h&quot;
  58 #include &quot;WHLSLTernaryExpression.h&quot;
  59 #include &quot;WHLSLVisitor.h&quot;
  60 #include &quot;WHLSLWhileLoop.h&quot;
  61 #include &lt;wtf/HashMap.h&gt;
  62 #include &lt;wtf/HashSet.h&gt;
  63 #include &lt;wtf/Ref.h&gt;
  64 #include &lt;wtf/Vector.h&gt;
  65 #include &lt;wtf/text/WTFString.h&gt;
  66 
  67 namespace WebCore {
  68 
  69 namespace WHLSL {
  70 
  71 class PODChecker : public Visitor {
  72 public:
  73     PODChecker() = default;
  74 
  75     virtual ~PODChecker() = default;
  76 
  77     void visit(AST::EnumerationDefinition&amp; enumerationDefinition) override
  78     {
  79         Visitor::visit(enumerationDefinition);
  80     }
  81 
  82     void visit(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration) override
  83     {
  84         if (!nativeTypeDeclaration.isNumber()
  85             &amp;&amp; !nativeTypeDeclaration.isVector()
  86             &amp;&amp; !nativeTypeDeclaration.isMatrix())
<a name="3" id="anc3"></a><span class="line-modified">  87             setError(Error(&quot;Use of native type is not a POD in entrypoint semantic.&quot;, nativeTypeDeclaration.codeLocation()));</span>
  88     }
  89 
  90     void visit(AST::StructureDefinition&amp; structureDefinition) override
  91     {
  92         Visitor::visit(structureDefinition);
  93     }
  94 
  95     void visit(AST::TypeDefinition&amp; typeDefinition) override
  96     {
  97         Visitor::visit(typeDefinition);
  98     }
  99 
 100     void visit(AST::ArrayType&amp; arrayType) override
 101     {
 102         Visitor::visit(arrayType);
 103     }
 104 
<a name="4" id="anc4"></a><span class="line-modified"> 105     void visit(AST::PointerType&amp; pointerType) override</span>
 106     {
<a name="5" id="anc5"></a><span class="line-modified"> 107         setError(Error(&quot;Illegal use of pointer in entrypoint semantic.&quot;, pointerType.codeLocation()));</span>
 108     }
 109 
<a name="6" id="anc6"></a><span class="line-modified"> 110     void visit(AST::ArrayReferenceType&amp; arrayReferenceType) override</span>
 111     {
<a name="7" id="anc7"></a><span class="line-modified"> 112         setError(Error(&quot;Illegal use of array reference in entrypoint semantic.&quot;, arrayReferenceType.codeLocation()));</span>
 113     }
 114 
 115     void visit(AST::TypeReference&amp; typeReference) override
 116     {
<a name="8" id="anc8"></a><span class="line-modified"> 117         checkErrorAndVisit(typeReference.resolvedType());</span>

 118     }
 119 };
 120 
<a name="9" id="anc9"></a><span class="line-modified"> 121 class FunctionKey {</span>
<span class="line-added"> 122 public:</span>
<span class="line-added"> 123     FunctionKey() = default;</span>
<span class="line-added"> 124     FunctionKey(WTF::HashTableDeletedValueType)</span>
<span class="line-added"> 125     {</span>
<span class="line-added"> 126         m_castReturnType = bitwise_cast&lt;AST::NamedType*&gt;(static_cast&lt;uintptr_t&gt;(1));</span>
<span class="line-added"> 127     }</span>
<span class="line-added"> 128 </span>
<span class="line-added"> 129     FunctionKey(String name, Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; types, AST::NamedType* castReturnType = nullptr)</span>
<span class="line-added"> 130         : m_name(WTFMove(name))</span>
<span class="line-added"> 131         , m_types(WTFMove(types))</span>
<span class="line-added"> 132         , m_castReturnType(castReturnType)</span>
<span class="line-added"> 133     { }</span>
<span class="line-added"> 134 </span>
<span class="line-added"> 135     bool isEmptyValue() const { return m_name.isNull(); }</span>
<span class="line-added"> 136     bool isHashTableDeletedValue() const { return m_castReturnType == bitwise_cast&lt;AST::NamedType*&gt;(static_cast&lt;uintptr_t&gt;(1)); }</span>
<span class="line-added"> 137 </span>
<span class="line-added"> 138     unsigned hash() const</span>
<span class="line-added"> 139     {</span>
<span class="line-added"> 140         unsigned hash = IntHash&lt;size_t&gt;::hash(m_types.size());</span>
<span class="line-added"> 141         hash ^= m_name.hash();</span>
<span class="line-added"> 142         for (size_t i = 0; i &lt; m_types.size(); ++i)</span>
<span class="line-added"> 143             hash ^= m_types[i].get().hash() + i;</span>
<span class="line-added"> 144 </span>
<span class="line-added"> 145         if (m_castReturnType)</span>
<span class="line-added"> 146             hash ^= WTF::PtrHash&lt;AST::Type*&gt;::hash(&amp;m_castReturnType-&gt;unifyNode());</span>
<span class="line-added"> 147 </span>
<span class="line-added"> 148         return hash;</span>
<span class="line-added"> 149     }</span>
<span class="line-added"> 150 </span>
<span class="line-added"> 151     bool operator==(const FunctionKey&amp; other) const</span>
<span class="line-added"> 152     {</span>
<span class="line-added"> 153         if (m_types.size() != other.m_types.size())</span>
<span class="line-added"> 154             return false;</span>
<span class="line-added"> 155 </span>
<span class="line-added"> 156         if (m_name != other.m_name)</span>
<span class="line-added"> 157             return false;</span>
<span class="line-added"> 158 </span>
<span class="line-added"> 159         for (size_t i = 0; i &lt; m_types.size(); ++i) {</span>
<span class="line-added"> 160             if (!matches(m_types[i].get(), other.m_types[i].get()))</span>
<span class="line-added"> 161                 return false;</span>
<span class="line-added"> 162         }</span>
<span class="line-added"> 163 </span>
<span class="line-added"> 164         if (static_cast&lt;bool&gt;(m_castReturnType) != static_cast&lt;bool&gt;(other.m_castReturnType))</span>
<span class="line-added"> 165             return false;</span>
<span class="line-added"> 166 </span>
<span class="line-added"> 167         if (!m_castReturnType)</span>
<span class="line-added"> 168             return true;</span>
<span class="line-added"> 169 </span>
<span class="line-added"> 170         if (&amp;m_castReturnType-&gt;unifyNode() == &amp;other.m_castReturnType-&gt;unifyNode())</span>
<span class="line-added"> 171             return true;</span>
<span class="line-added"> 172 </span>
<span class="line-added"> 173         return false;</span>
<span class="line-added"> 174     }</span>
<span class="line-added"> 175 </span>
<span class="line-added"> 176     struct Hash {</span>
<span class="line-added"> 177         static unsigned hash(const FunctionKey&amp; key)</span>
<span class="line-added"> 178         {</span>
<span class="line-added"> 179             return key.hash();</span>
<span class="line-added"> 180         }</span>
<span class="line-added"> 181 </span>
<span class="line-added"> 182         static bool equal(const FunctionKey&amp; a, const FunctionKey&amp; b)</span>
<span class="line-added"> 183         {</span>
<span class="line-added"> 184             return a == b;</span>
<span class="line-added"> 185         }</span>
<span class="line-added"> 186 </span>
<span class="line-added"> 187         static const bool safeToCompareToEmptyOrDeleted = false;</span>
<span class="line-added"> 188         static const bool emptyValueIsZero = false;</span>
<span class="line-added"> 189     };</span>
<span class="line-added"> 190 </span>
<span class="line-added"> 191     struct Traits : public WTF::SimpleClassHashTraits&lt;FunctionKey&gt; {</span>
<span class="line-added"> 192         static const bool hasIsEmptyValueFunction = true;</span>
<span class="line-added"> 193         static bool isEmptyValue(const FunctionKey&amp; key) { return key.isEmptyValue(); }</span>
<span class="line-added"> 194     };</span>
<span class="line-added"> 195 </span>
<span class="line-added"> 196 private:</span>
<span class="line-added"> 197     String m_name;</span>
<span class="line-added"> 198     Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; m_types;</span>
<span class="line-added"> 199     AST::NamedType* m_castReturnType;</span>
<span class="line-added"> 200 };</span>
<span class="line-added"> 201 </span>
<span class="line-added"> 202 class AndOverloadTypeKey {</span>
<span class="line-added"> 203 public:</span>
<span class="line-added"> 204     AndOverloadTypeKey() = default;</span>
<span class="line-added"> 205     AndOverloadTypeKey(WTF::HashTableDeletedValueType)</span>
<span class="line-added"> 206     {</span>
<span class="line-added"> 207         m_type = bitwise_cast&lt;AST::UnnamedType*&gt;(static_cast&lt;uintptr_t&gt;(1));</span>
<span class="line-added"> 208     }</span>
<span class="line-added"> 209 </span>
<span class="line-added"> 210     AndOverloadTypeKey(AST::UnnamedType&amp; type, AST::AddressSpace addressSpace)</span>
<span class="line-added"> 211         : m_type(&amp;type)</span>
<span class="line-added"> 212         , m_addressSpace(addressSpace)</span>
<span class="line-added"> 213     { }</span>
<span class="line-added"> 214 </span>
<span class="line-added"> 215     bool isEmptyValue() const { return !m_type; }</span>
<span class="line-added"> 216     bool isHashTableDeletedValue() const { return m_type == bitwise_cast&lt;AST::UnnamedType*&gt;(static_cast&lt;uintptr_t&gt;(1)); }</span>
<span class="line-added"> 217 </span>
<span class="line-added"> 218     unsigned hash() const</span>
<span class="line-added"> 219     {</span>
<span class="line-added"> 220         return IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(m_addressSpace)) ^ m_type-&gt;hash();</span>
<span class="line-added"> 221     }</span>
<span class="line-added"> 222 </span>
<span class="line-added"> 223     bool operator==(const AndOverloadTypeKey&amp; other) const</span>
<span class="line-added"> 224     {</span>
<span class="line-added"> 225         return m_addressSpace == other.m_addressSpace</span>
<span class="line-added"> 226             &amp;&amp; *m_type == *other.m_type;</span>
<span class="line-added"> 227     }</span>
<span class="line-added"> 228 </span>
<span class="line-added"> 229     struct Hash {</span>
<span class="line-added"> 230         static unsigned hash(const AndOverloadTypeKey&amp; key)</span>
<span class="line-added"> 231         {</span>
<span class="line-added"> 232             return key.hash();</span>
<span class="line-added"> 233         }</span>
<span class="line-added"> 234 </span>
<span class="line-added"> 235         static bool equal(const AndOverloadTypeKey&amp; a, const AndOverloadTypeKey&amp; b)</span>
<span class="line-added"> 236         {</span>
<span class="line-added"> 237             return a == b;</span>
<span class="line-added"> 238         }</span>
<span class="line-added"> 239 </span>
<span class="line-added"> 240         static const bool safeToCompareToEmptyOrDeleted = false;</span>
<span class="line-added"> 241     };</span>
<span class="line-added"> 242 </span>
<span class="line-added"> 243     struct Traits : public WTF::SimpleClassHashTraits&lt;AndOverloadTypeKey&gt; {</span>
<span class="line-added"> 244         static const bool hasIsEmptyValueFunction = true;</span>
<span class="line-added"> 245         static bool isEmptyValue(const AndOverloadTypeKey&amp; key) { return key.isEmptyValue(); }</span>
<span class="line-added"> 246     };</span>
<span class="line-added"> 247 </span>
<span class="line-added"> 248 private:</span>
<span class="line-added"> 249     AST::UnnamedType* m_type { nullptr };</span>
<span class="line-added"> 250     AST::AddressSpace m_addressSpace;</span>
<span class="line-added"> 251 };</span>
<span class="line-added"> 252 </span>
<span class="line-added"> 253 static AST::NativeFunctionDeclaration resolveWithOperatorAnderIndexer(CodeLocation location, AST::ArrayReferenceType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
 254 {
 255     const bool isOperator = true;
<a name="10" id="anc10"></a><span class="line-modified"> 256     auto returnType = AST::PointerType::create(location, firstArgument.addressSpace(), firstArgument.elementType());</span>
 257     AST::VariableDeclarations parameters;
<a name="11" id="anc11"></a><span class="line-modified"> 258     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), &amp;firstArgument, String(), nullptr, nullptr));</span>
<span class="line-modified"> 259     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), AST::TypeReference::wrap(location, intrinsics.uintType()), String(), nullptr, nullptr));</span>
<span class="line-modified"> 260     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator&amp;[]&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
 261 }
 262 
<a name="12" id="anc12"></a><span class="line-modified"> 263 static AST::NativeFunctionDeclaration resolveWithOperatorLength(CodeLocation location, AST::UnnamedType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
 264 {
 265     const bool isOperator = true;
<a name="13" id="anc13"></a><span class="line-modified"> 266     auto returnType = AST::TypeReference::wrap(location, intrinsics.uintType());</span>
 267     AST::VariableDeclarations parameters;
<a name="14" id="anc14"></a><span class="line-modified"> 268     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), &amp;firstArgument, String(), nullptr, nullptr));</span>
<span class="line-modified"> 269     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator.length&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
 270 }
 271 
<a name="15" id="anc15"></a><span class="line-modified"> 272 static AST::NativeFunctionDeclaration resolveWithReferenceComparator(CodeLocation location, ResolvingType&amp; firstArgument, ResolvingType&amp; secondArgument, const Intrinsics&amp; intrinsics)</span>
 273 {
 274     const bool isOperator = true;
<a name="16" id="anc16"></a><span class="line-modified"> 275     auto returnType = AST::TypeReference::wrap(location, intrinsics.boolType());</span>
<span class="line-modified"> 276     auto argumentType = firstArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 277         return unnamedType.copyRef();</span>
<span class="line-modified"> 278     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 279         return secondArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 280             return unnamedType.copyRef();</span>
<span class="line-modified"> 281         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
 282             // We encountered &quot;null == null&quot;.
<a name="17" id="anc17"></a><span class="line-modified"> 283             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198162 This can probably be generalized, using the &quot;preferred type&quot; infrastructure used by generic literals</span>
<span class="line-modified"> 284             ASSERT_NOT_REACHED();</span>
<span class="line-modified"> 285             return AST::TypeReference::wrap(location, intrinsics.intType());</span>
<span class="line-modified"> 286         }));</span>
<span class="line-modified"> 287     }));</span>
 288     AST::VariableDeclarations parameters;
<a name="18" id="anc18"></a><span class="line-modified"> 289     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), argumentType.copyRef(), String(), nullptr, nullptr));</span>
<span class="line-modified"> 290     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), WTFMove(argumentType), String(), nullptr, nullptr));</span>
<span class="line-modified"> 291     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator==&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
 292 }
 293 
<a name="19" id="anc19"></a><span class="line-modified"> 294 enum class Acceptability {</span>
<span class="line-added"> 295     Yes,</span>
<span class="line-added"> 296     Maybe,</span>
<span class="line-added"> 297     No</span>
<span class="line-added"> 298 };</span>
<span class="line-added"> 299 </span>
<span class="line-added"> 300 static Optional&lt;AST::NativeFunctionDeclaration&gt; resolveByInstantiation(const String&amp; name, CodeLocation location, const Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const Intrinsics&amp; intrinsics)</span>
 301 {
<a name="20" id="anc20"></a><span class="line-modified"> 302     if (name == &quot;operator&amp;[]&quot; &amp;&amp; types.size() == 2) {</span>
<span class="line-modified"> 303         auto* firstArgumentArrayRef = types[0].get().visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::ArrayReferenceType* {</span>
 304             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))
 305                 return &amp;downcast&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType));
 306             return nullptr;
<a name="21" id="anc21"></a><span class="line-modified"> 307         }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::ArrayReferenceType* {</span>
 308             return nullptr;
<a name="22" id="anc22"></a><span class="line-modified"> 309         }));</span>
<span class="line-modified"> 310         bool secondArgumentIsUint = types[1].get().visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
 311             return matches(unnamedType, intrinsics.uintType());
<a name="23" id="anc23"></a><span class="line-modified"> 312         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
 313             return resolvableTypeReference-&gt;resolvableType().canResolve(intrinsics.uintType());
<a name="24" id="anc24"></a><span class="line-modified"> 314         }));</span>
 315         if (firstArgumentArrayRef &amp;&amp; secondArgumentIsUint)
<a name="25" id="anc25"></a><span class="line-modified"> 316             return resolveWithOperatorAnderIndexer(location, *firstArgumentArrayRef, intrinsics);</span>
<span class="line-modified"> 317     } else if (name == &quot;operator.length&quot; &amp;&amp; types.size() == 1) {</span>
<span class="line-modified"> 318         auto* firstArgumentReference = types[0].get().visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
 319             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)) || is&lt;AST::ArrayType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))
<a name="26" id="anc26"></a><span class="line-modified"> 320                 return unnamedType.ptr();</span>
 321             return nullptr;
<a name="27" id="anc27"></a><span class="line-modified"> 322         }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::UnnamedType* {</span>
 323             return nullptr;
<a name="28" id="anc28"></a><span class="line-modified"> 324         }));</span>
 325         if (firstArgumentReference)
<a name="29" id="anc29"></a><span class="line-modified"> 326             return resolveWithOperatorLength(location, *firstArgumentReference, intrinsics);</span>
<span class="line-modified"> 327     } else if (name == &quot;operator==&quot; &amp;&amp; types.size() == 2) {</span>
<span class="line-modified"> 328         auto acceptability = [](ResolvingType&amp; resolvingType) -&gt; Acceptability {</span>
<span class="line-modified"> 329             return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Acceptability {</span>
<span class="line-modified"> 330                 auto&amp; unifyNode = unnamedType-&gt;unifyNode();</span>
<span class="line-modified"> 331                 return is&lt;AST::UnnamedType&gt;(unifyNode) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(unifyNode)) ? Acceptability::Yes : Acceptability::No;</span>
<span class="line-modified"> 332             }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; Acceptability {</span>
<span class="line-modified"> 333                 return is&lt;AST::NullLiteralType&gt;(resolvableTypeReference-&gt;resolvableType()) ? Acceptability::Maybe : Acceptability::No;</span>
<span class="line-added"> 334             }));</span>
 335         };
<a name="30" id="anc30"></a><span class="line-modified"> 336         auto leftAcceptability = acceptability(types[0].get());</span>
<span class="line-modified"> 337         auto rightAcceptability = acceptability(types[1].get());</span>
<span class="line-added"> 338         bool success = false;</span>
<span class="line-added"> 339         if (leftAcceptability == Acceptability::Yes &amp;&amp; rightAcceptability == Acceptability::Yes) {</span>
<span class="line-added"> 340             auto&amp; unnamedType1 = *types[0].get().getUnnamedType();</span>
<span class="line-added"> 341             auto&amp; unnamedType2 = *types[1].get().getUnnamedType();</span>
<span class="line-added"> 342             success = matches(unnamedType1, unnamedType2);</span>
<span class="line-added"> 343         } else if ((leftAcceptability == Acceptability::Maybe &amp;&amp; rightAcceptability == Acceptability::Yes)</span>
<span class="line-added"> 344             || (leftAcceptability == Acceptability::Yes &amp;&amp; rightAcceptability == Acceptability::Maybe))</span>
<span class="line-added"> 345             success = true;</span>
<span class="line-added"> 346         if (success)</span>
<span class="line-added"> 347             return resolveWithReferenceComparator(location, types[0].get(), types[1].get(), intrinsics);</span>
 348     }
 349     return WTF::nullopt;
 350 }
 351 
 352 static bool checkSemantics(Vector&lt;EntryPointItem&gt;&amp; inputItems, Vector&lt;EntryPointItem&gt;&amp; outputItems, const Optional&lt;AST::EntryPointType&gt;&amp; entryPointType, const Intrinsics&amp; intrinsics)
 353 {
 354     {
 355         auto checkDuplicateSemantics = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 356             for (size_t i = 0; i &lt; items.size(); ++i) {
 357                 for (size_t j = i + 1; j &lt; items.size(); ++j) {
 358                     if (items[i].semantic == items[j].semantic)
 359                         return false;
 360                 }
 361             }
 362             return true;
 363         };
 364         if (!checkDuplicateSemantics(inputItems))
 365             return false;
 366         if (!checkDuplicateSemantics(outputItems))
 367             return false;
 368     }
 369 
 370     {
 371         auto checkSemanticTypes = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 372             for (auto&amp; item : items) {
 373                 auto acceptable = WTF::visit(WTF::makeVisitor([&amp;](const AST::BaseSemantic&amp; semantic) -&gt; bool {
 374                     return semantic.isAcceptableType(*item.unnamedType, intrinsics);
 375                 }), *item.semantic);
 376                 if (!acceptable)
 377                     return false;
 378             }
 379             return true;
 380         };
 381         if (!checkSemanticTypes(inputItems))
 382             return false;
 383         if (!checkSemanticTypes(outputItems))
 384             return false;
 385     }
 386 
 387     {
 388         auto checkSemanticForShaderType = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items, AST::BaseSemantic::ShaderItemDirection direction) -&gt; bool {
 389             for (auto&amp; item : items) {
 390                 auto acceptable = WTF::visit(WTF::makeVisitor([&amp;](const AST::BaseSemantic&amp; semantic) -&gt; bool {
 391                     return semantic.isAcceptableForShaderItemDirection(direction, entryPointType);
 392                 }), *item.semantic);
 393                 if (!acceptable)
 394                     return false;
 395             }
 396             return true;
 397         };
 398         if (!checkSemanticForShaderType(inputItems, AST::BaseSemantic::ShaderItemDirection::Input))
 399             return false;
 400         if (!checkSemanticForShaderType(outputItems, AST::BaseSemantic::ShaderItemDirection::Output))
 401             return false;
 402     }
 403 
 404     {
 405         auto checkPODData = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 406             for (auto&amp; item : items) {
 407                 PODChecker podChecker;
 408                 if (is&lt;AST::PointerType&gt;(item.unnamedType))
 409                     podChecker.checkErrorAndVisit(downcast&lt;AST::PointerType&gt;(*item.unnamedType).elementType());
 410                 else if (is&lt;AST::ArrayReferenceType&gt;(item.unnamedType))
 411                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayReferenceType&gt;(*item.unnamedType).elementType());
 412                 else if (is&lt;AST::ArrayType&gt;(item.unnamedType))
 413                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayType&gt;(*item.unnamedType).type());
 414                 else
 415                     continue;
<a name="31" id="anc31"></a><span class="line-modified"> 416                 if (podChecker.hasError())</span>
 417                     return false;
 418             }
 419             return true;
 420         };
 421         if (!checkPODData(inputItems))
 422             return false;
 423         if (!checkPODData(outputItems))
 424             return false;
 425     }
 426 
 427     return true;
 428 }
 429 
<a name="32" id="anc32"></a><span class="line-modified"> 430 static bool checkOperatorOverload(const AST::FunctionDefinition&amp; functionDefinition, NameContext&amp; nameContext, AST::NameSpace currentNameSpace)</span>
 431 {
 432     enum class CheckKind {
 433         Index,
 434         Dot
 435     };
 436 
 437     auto checkGetter = [&amp;](CheckKind kind) -&gt; bool {
 438         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;
 439         if (functionDefinition.parameters().size() != numExpectedParameters)
 440             return false;
<a name="33" id="anc33"></a><span class="line-modified"> 441         auto&amp; firstParameterUnifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
 442         if (is&lt;AST::UnnamedType&gt;(firstParameterUnifyNode)) {
 443             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstParameterUnifyNode);
 444             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))
 445                 return false;
 446         }
 447         if (kind == CheckKind::Index) {
<a name="34" id="anc34"></a><span class="line-modified"> 448             auto&amp; secondParameterUnifyNode = functionDefinition.parameters()[1]-&gt;type()-&gt;unifyNode();</span>
 449             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))
 450                 return false;
 451             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);
 452             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 453                 return false;
 454             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 455             if (!nativeTypeDeclaration.isInt())
 456                 return false;
 457         }
 458         return true;
 459     };
 460 
 461     auto checkSetter = [&amp;](CheckKind kind) -&gt; bool {
 462         size_t numExpectedParameters = kind == CheckKind::Index ? 3 : 2;
 463         if (functionDefinition.parameters().size() != numExpectedParameters)
 464             return false;
<a name="35" id="anc35"></a><span class="line-modified"> 465         auto&amp; firstArgumentUnifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
 466         if (is&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode)) {
 467             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode);
 468             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))
 469                 return false;
 470         }
 471         if (kind == CheckKind::Index) {
<a name="36" id="anc36"></a><span class="line-modified"> 472             auto&amp; secondParameterUnifyNode = functionDefinition.parameters()[1]-&gt;type()-&gt;unifyNode();</span>
 473             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))
 474                 return false;
 475             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);
 476             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 477                 return false;
 478             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 479             if (!nativeTypeDeclaration.isInt())
 480                 return false;
 481         }
<a name="37" id="anc37"></a><span class="line-modified"> 482         if (!matches(functionDefinition.type(), *functionDefinition.parameters()[0]-&gt;type()))</span>
 483             return false;
<a name="38" id="anc38"></a><span class="line-modified"> 484         auto&amp; valueType = *functionDefinition.parameters()[numExpectedParameters - 1]-&gt;type();</span>
 485         auto getterName = functionDefinition.name().substring(0, functionDefinition.name().length() - 1);
<a name="39" id="anc39"></a><span class="line-modified"> 486         auto getterFuncs = nameContext.getFunctions(getterName, currentNameSpace);</span>


 487         Vector&lt;ResolvingType&gt; argumentTypes;
 488         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; argumentTypeReferences;
 489         for (size_t i = 0; i &lt; numExpectedParameters - 1; ++i)
<a name="40" id="anc40"></a><span class="line-modified"> 490             argumentTypes.append(*functionDefinition.parameters()[i]-&gt;type());</span>
 491         for (auto&amp; argumentType : argumentTypes)
 492             argumentTypeReferences.append(argumentType);
<a name="41" id="anc41"></a><span class="line-modified"> 493         auto* overload = resolveFunctionOverload(getterFuncs, argumentTypeReferences, currentNameSpace);</span>

 494         if (!overload)
 495             return false;
 496         auto&amp; resultType = overload-&gt;type();
 497         return matches(resultType, valueType);
 498     };
 499 
 500     auto checkAnder = [&amp;](CheckKind kind) -&gt; bool {
 501         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;
 502         if (functionDefinition.parameters().size() != numExpectedParameters)
 503             return false;
 504         {
 505             auto&amp; unifyNode = functionDefinition.type().unifyNode();
 506             if (!is&lt;AST::UnnamedType&gt;(unifyNode))
 507                 return false;
 508             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 509             if (!is&lt;AST::PointerType&gt;(unnamedType))
 510                 return false;
 511         }
 512         {
<a name="42" id="anc42"></a><span class="line-modified"> 513             auto&amp; unifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
 514             if (!is&lt;AST::UnnamedType&gt;(unifyNode))
 515                 return false;
 516             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 517             return is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType);
 518         }
 519     };
 520 
 521     if (!functionDefinition.isOperator())
 522         return true;
 523     if (functionDefinition.isCast())
 524         return true;
 525     if (functionDefinition.name() == &quot;operator++&quot; || functionDefinition.name() == &quot;operator--&quot;) {
 526         return functionDefinition.parameters().size() == 1
<a name="43" id="anc43"></a><span class="line-modified"> 527             &amp;&amp; matches(*functionDefinition.parameters()[0]-&gt;type(), functionDefinition.type());</span>
 528     }
 529     if (functionDefinition.name() == &quot;operator+&quot; || functionDefinition.name() == &quot;operator-&quot;)
 530         return functionDefinition.parameters().size() == 1 || functionDefinition.parameters().size() == 2;
 531     if (functionDefinition.name() == &quot;operator*&quot;
 532         || functionDefinition.name() == &quot;operator/&quot;
 533         || functionDefinition.name() == &quot;operator%&quot;
 534         || functionDefinition.name() == &quot;operator&amp;&quot;
 535         || functionDefinition.name() == &quot;operator|&quot;
 536         || functionDefinition.name() == &quot;operator^&quot;
 537         || functionDefinition.name() == &quot;operator&lt;&lt;&quot;
<a name="44" id="anc44"></a><span class="line-modified"> 538         || functionDefinition.name() == &quot;operator&gt;&gt;&quot;)</span>
 539         return functionDefinition.parameters().size() == 2;
 540     if (functionDefinition.name() == &quot;operator~&quot;)
 541         return functionDefinition.parameters().size() == 1;
<a name="45" id="anc45"></a>







 542     if (functionDefinition.name() == &quot;operator[]&quot;)
 543         return checkGetter(CheckKind::Index);
 544     if (functionDefinition.name() == &quot;operator[]=&quot;)
 545         return checkSetter(CheckKind::Index);
 546     if (functionDefinition.name() == &quot;operator&amp;[]&quot;)
 547         return checkAnder(CheckKind::Index);
 548     if (functionDefinition.name().startsWith(&quot;operator.&quot;)) {
 549         if (functionDefinition.name().endsWith(&quot;=&quot;))
 550             return checkSetter(CheckKind::Dot);
 551         return checkGetter(CheckKind::Dot);
 552     }
 553     if (functionDefinition.name().startsWith(&quot;operator&amp;.&quot;))
 554         return checkAnder(CheckKind::Dot);
 555     return false;
 556 }
 557 
 558 class Checker : public Visitor {
 559 public:
 560     Checker(const Intrinsics&amp; intrinsics, Program&amp; program)
 561         : m_intrinsics(intrinsics)
 562         , m_program(program)
 563     {
<a name="46" id="anc46"></a><span class="line-added"> 564         auto addFunction = [&amp;] (AST::FunctionDeclaration&amp; function) {</span>
<span class="line-added"> 565             AST::NamedType* castReturnType = nullptr;</span>
<span class="line-added"> 566             if (function.isCast() &amp;&amp; is&lt;AST::NamedType&gt;(function.type().unifyNode()))</span>
<span class="line-added"> 567                 castReturnType = &amp;downcast&lt;AST::NamedType&gt;(function.type().unifyNode());</span>
<span class="line-added"> 568 </span>
<span class="line-added"> 569             Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; types;</span>
<span class="line-added"> 570             types.reserveInitialCapacity(function.parameters().size());</span>
<span class="line-added"> 571 </span>
<span class="line-added"> 572             for (auto&amp; param : function.parameters())</span>
<span class="line-added"> 573                 types.uncheckedAppend(normalizedTypeForFunctionKey(*param-&gt;type()));</span>
<span class="line-added"> 574 </span>
<span class="line-added"> 575             auto addResult = m_functions.add(FunctionKey { function.name(), WTFMove(types), castReturnType }, Vector&lt;std::reference_wrapper&lt;AST::FunctionDeclaration&gt;, 1&gt;());</span>
<span class="line-added"> 576             addResult.iterator-&gt;value.append(function);</span>
<span class="line-added"> 577         };</span>
<span class="line-added"> 578 </span>
<span class="line-added"> 579         for (auto&amp; function : m_program.functionDefinitions())</span>
<span class="line-added"> 580             addFunction(function.get());</span>
<span class="line-added"> 581         for (auto&amp; function : m_program.nativeFunctionDeclarations())</span>
<span class="line-added"> 582             addFunction(function.get());</span>
 583     }
 584 
<a name="47" id="anc47"></a><span class="line-modified"> 585     virtual ~Checker() = default;</span>
 586 
 587     void visit(Program&amp;) override;
 588 
<a name="48" id="anc48"></a><span class="line-modified"> 589     Expected&lt;void, Error&gt; assignTypes();</span>
 590 
 591 private:
 592     bool checkShaderType(const AST::FunctionDefinition&amp;);
<a name="49" id="anc49"></a>
 593     bool isBoolType(ResolvingType&amp;);
 594     struct RecurseInfo {
 595         ResolvingType&amp; resolvingType;
<a name="50" id="anc50"></a><span class="line-modified"> 596         const AST::TypeAnnotation typeAnnotation;</span>
 597     };
<a name="51" id="anc51"></a><span class="line-modified"> 598     Optional&lt;RecurseInfo&gt; recurseAndGetInfo(AST::Expression&amp;, bool requiresLeftValue = false);</span>
<span class="line-modified"> 599     Optional&lt;RecurseInfo&gt; getInfo(AST::Expression&amp;, bool requiresLeftValue = false);</span>
<span class="line-modified"> 600     RefPtr&lt;AST::UnnamedType&gt; recurseAndWrapBaseType(AST::PropertyAccessExpression&amp;);</span>
 601     bool recurseAndRequireBoolType(AST::Expression&amp;);
<a name="52" id="anc52"></a><span class="line-modified"> 602     void assignConcreteType(AST::Expression&amp;, Ref&lt;AST::UnnamedType&gt;, AST::TypeAnnotation);</span>
<span class="line-modified"> 603     void assignType(AST::Expression&amp;, RefPtr&lt;ResolvableTypeReference&gt;, AST::TypeAnnotation);</span>
<span class="line-modified"> 604     void forwardType(AST::Expression&amp;, ResolvingType&amp;, AST::TypeAnnotation);</span>
 605 
 606     void visit(AST::FunctionDefinition&amp;) override;
 607     void visit(AST::EnumerationDefinition&amp;) override;
 608     void visit(AST::TypeReference&amp;) override;
 609     void visit(AST::VariableDeclaration&amp;) override;
 610     void visit(AST::AssignmentExpression&amp;) override;
 611     void visit(AST::ReadModifyWriteExpression&amp;) override;
 612     void visit(AST::DereferenceExpression&amp;) override;
 613     void visit(AST::MakePointerExpression&amp;) override;
 614     void visit(AST::MakeArrayReferenceExpression&amp;) override;
 615     void visit(AST::DotExpression&amp;) override;
 616     void visit(AST::IndexExpression&amp;) override;
 617     void visit(AST::VariableReference&amp;) override;
 618     void visit(AST::Return&amp;) override;
 619     void visit(AST::PointerType&amp;) override;
 620     void visit(AST::ArrayReferenceType&amp;) override;
 621     void visit(AST::IntegerLiteral&amp;) override;
 622     void visit(AST::UnsignedIntegerLiteral&amp;) override;
 623     void visit(AST::FloatLiteral&amp;) override;
 624     void visit(AST::NullLiteral&amp;) override;
 625     void visit(AST::BooleanLiteral&amp;) override;
 626     void visit(AST::EnumerationMemberLiteral&amp;) override;
 627     void visit(AST::LogicalNotExpression&amp;) override;
 628     void visit(AST::LogicalExpression&amp;) override;
 629     void visit(AST::IfStatement&amp;) override;
 630     void visit(AST::WhileLoop&amp;) override;
 631     void visit(AST::DoWhileLoop&amp;) override;
 632     void visit(AST::ForLoop&amp;) override;
 633     void visit(AST::SwitchStatement&amp;) override;
 634     void visit(AST::CommaExpression&amp;) override;
 635     void visit(AST::TernaryExpression&amp;) override;
 636     void visit(AST::CallExpression&amp;) override;
 637 
<a name="53" id="anc53"></a><span class="line-modified"> 638     void finishVisiting(AST::PropertyAccessExpression&amp;, ResolvingType* additionalArgumentType = nullptr);</span>
<span class="line-modified"> 639 </span>
<span class="line-modified"> 640     AST::FunctionDeclaration* resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation, AST::NamedType* castReturnType = nullptr);</span>
<span class="line-modified"> 641 </span>
<span class="line-modified"> 642     RefPtr&lt;AST::UnnamedType&gt; argumentTypeForAndOverload(AST::UnnamedType&amp; baseType, AST::AddressSpace);</span>
<span class="line-added"> 643 </span>
<span class="line-added"> 644     AST::UnnamedType&amp; wrappedFloatType()</span>
<span class="line-added"> 645     {</span>
<span class="line-added"> 646         if (!m_wrappedFloatType)</span>
<span class="line-added"> 647             m_wrappedFloatType = AST::TypeReference::wrap({ }, m_intrinsics.floatType());</span>
<span class="line-added"> 648         return *m_wrappedFloatType;</span>
<span class="line-added"> 649     }</span>
<span class="line-added"> 650 </span>
<span class="line-added"> 651     AST::UnnamedType&amp; genericPointerType()</span>
<span class="line-added"> 652     {</span>
<span class="line-added"> 653         if (!m_genericPointerType)</span>
<span class="line-added"> 654             m_genericPointerType = AST::PointerType::create({ }, AST::AddressSpace::Thread, AST::TypeReference::wrap({ }, m_intrinsics.floatType()));</span>
<span class="line-added"> 655         return *m_genericPointerType;</span>
<span class="line-added"> 656     }</span>
<span class="line-added"> 657 </span>
<span class="line-added"> 658     AST::UnnamedType&amp; normalizedTypeForFunctionKey(AST::UnnamedType&amp; type)</span>
<span class="line-added"> 659     {</span>
<span class="line-added"> 660         auto* unifyNode = &amp;type.unifyNode();</span>
<span class="line-added"> 661         if (unifyNode == &amp;m_intrinsics.uintType() || unifyNode == &amp;m_intrinsics.intType())</span>
<span class="line-added"> 662             return wrappedFloatType();</span>
<span class="line-added"> 663 </span>
<span class="line-added"> 664         if (is&lt;AST::ReferenceType&gt;(type))</span>
<span class="line-added"> 665             return genericPointerType();</span>
<span class="line-added"> 666 </span>
<span class="line-added"> 667         return type;</span>
<span class="line-added"> 668     }</span>
<span class="line-added"> 669 </span>
<span class="line-added"> 670     RefPtr&lt;AST::TypeReference&gt; m_wrappedFloatType;</span>
<span class="line-added"> 671     RefPtr&lt;AST::UnnamedType&gt; m_genericPointerType;</span>
<span class="line-added"> 672     HashMap&lt;AST::Expression*, std::unique_ptr&lt;ResolvingType&gt;&gt; m_typeMap;</span>
<span class="line-added"> 673     HashSet&lt;String&gt; m_vertexEntryPoints[AST::nameSpaceCount];</span>
<span class="line-added"> 674     HashSet&lt;String&gt; m_fragmentEntryPoints[AST::nameSpaceCount];</span>
<span class="line-added"> 675     HashSet&lt;String&gt; m_computeEntryPoints[AST::nameSpaceCount];</span>
 676     const Intrinsics&amp; m_intrinsics;
 677     Program&amp; m_program;
<a name="54" id="anc54"></a><span class="line-added"> 678     AST::FunctionDefinition* m_currentFunction { nullptr };</span>
<span class="line-added"> 679     HashMap&lt;FunctionKey, Vector&lt;std::reference_wrapper&lt;AST::FunctionDeclaration&gt;, 1&gt;, FunctionKey::Hash, FunctionKey::Traits&gt; m_functions;</span>
<span class="line-added"> 680     HashMap&lt;AndOverloadTypeKey, RefPtr&lt;AST::UnnamedType&gt;, AndOverloadTypeKey::Hash, AndOverloadTypeKey::Traits&gt; m_andOverloadTypeMap;</span>
<span class="line-added"> 681     AST::NameSpace m_currentNameSpace { AST::NameSpace::StandardLibrary };</span>
 682 };
 683 
 684 void Checker::visit(Program&amp; program)
 685 {
 686     // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
 687     for (size_t i = 0; i &lt; program.typeDefinitions().size(); ++i)
 688         checkErrorAndVisit(program.typeDefinitions()[i]);
 689     for (size_t i = 0; i &lt; program.structureDefinitions().size(); ++i)
 690         checkErrorAndVisit(program.structureDefinitions()[i]);
 691     for (size_t i = 0; i &lt; program.enumerationDefinitions().size(); ++i)
 692         checkErrorAndVisit(program.enumerationDefinitions()[i]);
 693     for (size_t i = 0; i &lt; program.nativeTypeDeclarations().size(); ++i)
 694         checkErrorAndVisit(program.nativeTypeDeclarations()[i]);
 695 
 696     for (size_t i = 0; i &lt; program.functionDefinitions().size(); ++i)
 697         checkErrorAndVisit(program.functionDefinitions()[i]);
 698     for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
 699         checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
 700 }
 701 
<a name="55" id="anc55"></a><span class="line-modified"> 702 Expected&lt;void, Error&gt; Checker::assignTypes()</span>
 703 {
 704     for (auto&amp; keyValuePair : m_typeMap) {
<a name="56" id="anc56"></a><span class="line-modified"> 705         auto success = keyValuePair.value-&gt;visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
<span class="line-modified"> 706             keyValuePair.key-&gt;setType(unnamedType.copyRef());</span>
 707             return true;
<a name="57" id="anc57"></a><span class="line-modified"> 708         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
<span class="line-modified"> 709             if (!resolvableTypeReference-&gt;resolvableType().maybeResolvedType()) {</span>

 710                 if (!static_cast&lt;bool&gt;(commit(resolvableTypeReference-&gt;resolvableType())))
 711                     return false;
 712             }
<a name="58" id="anc58"></a><span class="line-modified"> 713             keyValuePair.key-&gt;setType(resolvableTypeReference-&gt;resolvableType().resolvedType());</span>
 714             return true;
<a name="59" id="anc59"></a><span class="line-modified"> 715         }));</span>
 716         if (!success)
<a name="60" id="anc60"></a><span class="line-modified"> 717             return makeUnexpected(Error(&quot;Could not resolve the type of a constant.&quot;));</span>
 718     }
 719 
<a name="61" id="anc61"></a><span class="line-modified"> 720     return { };</span>


 721 }
 722 
 723 bool Checker::checkShaderType(const AST::FunctionDefinition&amp; functionDefinition)
 724 {
<a name="62" id="anc62"></a><span class="line-added"> 725     auto index = static_cast&lt;unsigned&gt;(m_currentNameSpace);</span>
 726     switch (*functionDefinition.entryPointType()) {
 727     case AST::EntryPointType::Vertex:
<a name="63" id="anc63"></a><span class="line-modified"> 728         return static_cast&lt;bool&gt;(m_vertexEntryPoints[index].add(functionDefinition.name()));</span>
 729     case AST::EntryPointType::Fragment:
<a name="64" id="anc64"></a><span class="line-modified"> 730         return static_cast&lt;bool&gt;(m_fragmentEntryPoints[index].add(functionDefinition.name()));</span>
 731     case AST::EntryPointType::Compute:
<a name="65" id="anc65"></a><span class="line-modified"> 732         return static_cast&lt;bool&gt;(m_computeEntryPoints[index].add(functionDefinition.name()));</span>
 733     }
 734 }
 735 
 736 void Checker::visit(AST::FunctionDefinition&amp; functionDefinition)
 737 {
<a name="66" id="anc66"></a><span class="line-added"> 738     m_currentNameSpace = functionDefinition.nameSpace();</span>
<span class="line-added"> 739     m_currentFunction = &amp;functionDefinition;</span>
 740     if (functionDefinition.entryPointType()) {
 741         if (!checkShaderType(functionDefinition)) {
<a name="67" id="anc67"></a><span class="line-modified"> 742             setError(Error(&quot;Duplicate entrypoint function.&quot;, functionDefinition.codeLocation()));</span>
 743             return;
 744         }
 745         auto entryPointItems = gatherEntryPointItems(m_intrinsics, functionDefinition);
 746         if (!entryPointItems) {
<a name="68" id="anc68"></a><span class="line-modified"> 747             setError(entryPointItems.error());</span>
 748             return;
 749         }
 750         if (!checkSemantics(entryPointItems-&gt;inputs, entryPointItems-&gt;outputs, functionDefinition.entryPointType(), m_intrinsics)) {
<a name="69" id="anc69"></a><span class="line-modified"> 751             setError(Error(&quot;Bad semantics for entrypoint.&quot;, functionDefinition.codeLocation()));</span>
 752             return;
 753         }
 754     }
<a name="70" id="anc70"></a><span class="line-modified"> 755     if (!checkOperatorOverload(functionDefinition, m_program.nameContext(), m_currentNameSpace)) {</span>
<span class="line-modified"> 756         setError(Error(&quot;Operator does not match expected signature.&quot;, functionDefinition.codeLocation()));</span>
 757         return;
 758     }
 759 
<a name="71" id="anc71"></a><span class="line-modified"> 760     Visitor::visit(functionDefinition);</span>
 761 }
 762 
<a name="72" id="anc72"></a><span class="line-modified"> 763 static RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(ResolvingType&amp; left, ResolvingType&amp; right)</span>
 764 {
<a name="73" id="anc73"></a><span class="line-modified"> 765     return left.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; left) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 766         return right.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
 767             if (matches(left, right))
<a name="74" id="anc74"></a><span class="line-modified"> 768                 return left.copyRef();</span>
<span class="line-modified"> 769             return nullptr;</span>
<span class="line-modified"> 770         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
 771             return matchAndCommit(left, right-&gt;resolvableType());
<a name="75" id="anc75"></a><span class="line-modified"> 772         }));</span>
<span class="line-modified"> 773     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; left) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 774         return right.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
 775             return matchAndCommit(right, left-&gt;resolvableType());
<a name="76" id="anc76"></a><span class="line-modified"> 776         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
 777             return matchAndCommit(left-&gt;resolvableType(), right-&gt;resolvableType());
<a name="77" id="anc77"></a><span class="line-modified"> 778         }));</span>
<span class="line-modified"> 779     }));</span>
 780 }
 781 
<a name="78" id="anc78"></a><span class="line-modified"> 782 static RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::UnnamedType&amp; unnamedType)</span>
 783 {
<a name="79" id="anc79"></a><span class="line-modified"> 784     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
 785         if (matches(unnamedType, resolvingType))
<a name="80" id="anc80"></a><span class="line-modified"> 786             return &amp;unnamedType;</span>
<span class="line-modified"> 787         return nullptr;</span>
<span class="line-modified"> 788     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
 789         return matchAndCommit(unnamedType, resolvingType-&gt;resolvableType());
<a name="81" id="anc81"></a><span class="line-modified"> 790     }));</span>
 791 }
 792 
<a name="82" id="anc82"></a><span class="line-modified"> 793 static RefPtr&lt;AST::UnnamedType&gt; commit(ResolvingType&amp; resolvingType)</span>
 794 {
<a name="83" id="anc83"></a><span class="line-modified"> 795     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 796         return unnamedType.copyRef();</span>
<span class="line-modified"> 797     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 798         if (!resolvableTypeReference-&gt;resolvableType().maybeResolvedType())</span>
<span class="line-modified"> 799             return commit(resolvableTypeReference-&gt;resolvableType());</span>
<span class="line-modified"> 800         return &amp;resolvableTypeReference-&gt;resolvableType().resolvedType();</span>
<span class="line-modified"> 801     }));</span>
<span class="line-added"> 802 }</span>
<span class="line-added"> 803 </span>
<span class="line-added"> 804 AST::FunctionDeclaration* Checker::resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation location, AST::NamedType* castReturnType)</span>
<span class="line-added"> 805 {</span>
<span class="line-added"> 806     Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; unnamedTypes;</span>
<span class="line-added"> 807     unnamedTypes.reserveInitialCapacity(types.size());</span>
<span class="line-added"> 808 </span>
<span class="line-added"> 809     for (auto resolvingType : types) {</span>
<span class="line-added"> 810         AST::UnnamedType* type = resolvingType.get().visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
<span class="line-added"> 811             return unnamedType.ptr();</span>
<span class="line-added"> 812         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; AST::UnnamedType* {</span>
<span class="line-added"> 813             if (resolvableTypeReference-&gt;resolvableType().maybeResolvedType())</span>
<span class="line-added"> 814                 return &amp;resolvableTypeReference-&gt;resolvableType().resolvedType();</span>
<span class="line-added"> 815 </span>
<span class="line-added"> 816             if (resolvableTypeReference-&gt;resolvableType().isFloatLiteralType()</span>
<span class="line-added"> 817                 || resolvableTypeReference-&gt;resolvableType().isIntegerLiteralType()</span>
<span class="line-added"> 818                 || resolvableTypeReference-&gt;resolvableType().isUnsignedIntegerLiteralType())</span>
<span class="line-added"> 819                 return &amp;wrappedFloatType();</span>
<span class="line-added"> 820 </span>
<span class="line-added"> 821             if (resolvableTypeReference-&gt;resolvableType().isNullLiteralType())</span>
<span class="line-added"> 822                 return &amp;genericPointerType();</span>
<span class="line-added"> 823 </span>
<span class="line-added"> 824             return commit(resolvableTypeReference-&gt;resolvableType()).get();</span>
<span class="line-added"> 825         }));</span>
<span class="line-added"> 826 </span>
<span class="line-added"> 827         if (!type) {</span>
<span class="line-added"> 828             setError(Error(&quot;Could not resolve the type of a constant.&quot;));</span>
<span class="line-added"> 829             return nullptr;</span>
<span class="line-added"> 830         }</span>
<span class="line-added"> 831 </span>
<span class="line-added"> 832         unnamedTypes.uncheckedAppend(normalizedTypeForFunctionKey(*type));</span>
<span class="line-added"> 833     }</span>
<span class="line-added"> 834 </span>
<span class="line-added"> 835     {</span>
<span class="line-added"> 836         auto iter = m_functions.find(FunctionKey { name, WTFMove(unnamedTypes), castReturnType });</span>
<span class="line-added"> 837         if (iter != m_functions.end()) {</span>
<span class="line-added"> 838             if (AST::FunctionDeclaration* function = resolveFunctionOverload(iter-&gt;value, types, castReturnType, m_currentNameSpace))</span>
<span class="line-added"> 839                 return function;</span>
<span class="line-added"> 840         }</span>
<span class="line-added"> 841     }</span>
<span class="line-added"> 842 </span>
<span class="line-added"> 843     if (auto newFunction = resolveByInstantiation(name, location, types, m_intrinsics)) {</span>
<span class="line-added"> 844         m_program.append(WTFMove(*newFunction));</span>
<span class="line-added"> 845         return &amp;m_program.nativeFunctionDeclarations().last();</span>
<span class="line-added"> 846     }</span>
<span class="line-added"> 847 </span>
<span class="line-added"> 848     return nullptr;</span>
 849 }
 850 
 851 void Checker::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
 852 {
<a name="84" id="anc84"></a><span class="line-added"> 853     bool isSigned;</span>
 854     auto* baseType = ([&amp;]() -&gt; AST::NativeTypeDeclaration* {
 855         checkErrorAndVisit(enumerationDefinition.type());
 856         auto&amp; baseType = enumerationDefinition.type().unifyNode();
 857         if (!is&lt;AST::NamedType&gt;(baseType))
 858             return nullptr;
 859         auto&amp; namedType = downcast&lt;AST::NamedType&gt;(baseType);
 860         if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 861             return nullptr;
 862         auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 863         if (!nativeTypeDeclaration.isInt())
 864             return nullptr;
<a name="85" id="anc85"></a><span class="line-added"> 865         isSigned = nativeTypeDeclaration.isSigned();</span>
 866         return &amp;nativeTypeDeclaration;
 867     })();
 868     if (!baseType) {
<a name="86" id="anc86"></a><span class="line-modified"> 869         setError(Error(&quot;Invalid base type for enum.&quot;, enumerationDefinition.codeLocation()));</span>
 870         return;
 871     }
 872 
 873     auto enumerationMembers = enumerationDefinition.enumerationMembers();
 874 
 875     for (auto&amp; member : enumerationMembers) {
<a name="87" id="anc87"></a><span class="line-modified"> 876         int64_t value = member.get().value();</span>
<span class="line-modified"> 877         if (isSigned) {</span>
<span class="line-modified"> 878             if (static_cast&lt;int64_t&gt;(static_cast&lt;int32_t&gt;(value)) != value) {</span>
<span class="line-modified"> 879                 setError(Error(&quot;Invalid enumeration value.&quot;, member.get().codeLocation()));</span>



 880                 return;
<a name="88" id="anc88"></a><span class="line-modified"> 881             }</span>



















 882         } else {
<a name="89" id="anc89"></a><span class="line-modified"> 883             if (static_cast&lt;int64_t&gt;(static_cast&lt;uint32_t&gt;(value)) != value) {</span>
<span class="line-modified"> 884                 setError(Error(&quot;Invalid enumeration value.&quot;, member.get().codeLocation()));</span>
<span class="line-modified"> 885                 return;</span>
 886             }
<a name="90" id="anc90"></a>


 887         }
 888     }
 889 
<a name="91" id="anc91"></a>












 890     for (size_t i = 0; i &lt; enumerationMembers.size(); ++i) {
<a name="92" id="anc92"></a><span class="line-modified"> 891         auto value = enumerationMembers[i].get().value();</span>
 892         for (size_t j = i + 1; j &lt; enumerationMembers.size(); ++j) {
<a name="93" id="anc93"></a><span class="line-modified"> 893             auto otherValue = enumerationMembers[j].get().value();</span>
 894             if (value == otherValue) {
<a name="94" id="anc94"></a><span class="line-modified"> 895                 setError(Error(&quot;Cannot declare duplicate enumeration values.&quot;, enumerationMembers[j].get().codeLocation()));</span>
 896                 return;
 897             }
 898         }
 899     }
 900 
 901     bool foundZero = false;
 902     for (auto&amp; member : enumerationMembers) {
<a name="95" id="anc95"></a><span class="line-modified"> 903         if (!member.get().value()) {</span>
 904             foundZero = true;
 905             break;
 906         }
 907     }
 908     if (!foundZero) {
<a name="96" id="anc96"></a><span class="line-modified"> 909         setError(Error(&quot;enum definition must contain a zero value.&quot;, enumerationDefinition.codeLocation()));</span>
 910         return;
 911     }
 912 }
 913 
 914 void Checker::visit(AST::TypeReference&amp; typeReference)
 915 {
<a name="97" id="anc97"></a><span class="line-modified"> 916     ASSERT(typeReference.maybeResolvedType());</span>
 917 
<a name="98" id="anc98"></a><span class="line-modified"> 918     for (auto&amp; typeArgument : typeReference.typeArguments())</span>
<span class="line-added"> 919         checkErrorAndVisit(typeArgument);</span>
 920 }
 921 
<a name="99" id="anc99"></a><span class="line-modified"> 922 auto Checker::recurseAndGetInfo(AST::Expression&amp; expression, bool requiresLeftValue) -&gt; Optional&lt;RecurseInfo&gt;</span>
 923 {
<a name="100" id="anc100"></a><span class="line-modified"> 924     Visitor::visit(expression);</span>
<span class="line-modified"> 925     if (hasError())</span>
 926         return WTF::nullopt;
<a name="101" id="anc101"></a><span class="line-modified"> 927     return getInfo(expression, requiresLeftValue);</span>
 928 }
 929 
<a name="102" id="anc102"></a><span class="line-modified"> 930 auto Checker::getInfo(AST::Expression&amp; expression, bool requiresLeftValue) -&gt; Optional&lt;RecurseInfo&gt;</span>
 931 {
 932     auto typeIterator = m_typeMap.find(&amp;expression);
 933     ASSERT(typeIterator != m_typeMap.end());
 934 
<a name="103" id="anc103"></a><span class="line-modified"> 935     const auto&amp; typeAnnotation = expression.typeAnnotation();</span>
<span class="line-modified"> 936     if (requiresLeftValue &amp;&amp; typeAnnotation.isRightValue()) {</span>
<span class="line-modified"> 937         setError(Error(&quot;Unexpected rvalue.&quot;, expression.codeLocation()));</span>

 938         return WTF::nullopt;
 939     }
<a name="104" id="anc104"></a><span class="line-modified"> 940     return {{ *typeIterator-&gt;value, typeAnnotation }};</span>
 941 }
 942 
 943 void Checker::visit(AST::VariableDeclaration&amp; variableDeclaration)
 944 {
 945     // ReadModifyWriteExpressions are the only place where anonymous variables exist,
 946     // and that doesn&#39;t recurse on the anonymous variables, so we can assume the variable has a type.
 947     checkErrorAndVisit(*variableDeclaration.type());
<a name="105" id="anc105"></a><span class="line-added"> 948     if (matches(*variableDeclaration.type(), m_intrinsics.voidType())) {</span>
<span class="line-added"> 949         setError(Error(&quot;Variables can&#39;t have void type.&quot;, variableDeclaration.codeLocation()));</span>
<span class="line-added"> 950         return;</span>
<span class="line-added"> 951     }</span>
 952     if (variableDeclaration.initializer()) {
 953         auto&amp; lhsType = *variableDeclaration.type();
 954         auto initializerInfo = recurseAndGetInfo(*variableDeclaration.initializer());
 955         if (!initializerInfo)
 956             return;
 957         if (!matchAndCommit(initializerInfo-&gt;resolvingType, lhsType)) {
<a name="106" id="anc106"></a><span class="line-modified"> 958             setError(Error(&quot;Declared variable type does not match its initializer&#39;s type.&quot;, variableDeclaration.codeLocation()));</span>
 959             return;
 960         }
 961     }
 962 }
 963 
<a name="107" id="anc107"></a><span class="line-modified"> 964 void Checker::assignConcreteType(AST::Expression&amp; expression, Ref&lt;AST::UnnamedType&gt; unnamedType, AST::TypeAnnotation typeAnnotation = AST::RightValue())</span>
 965 {
<a name="108" id="anc108"></a><span class="line-modified"> 966     auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(unnamedType)));</span>
 967     ASSERT_UNUSED(addResult, addResult.isNewEntry);
<a name="109" id="anc109"></a><span class="line-modified"> 968     expression.setTypeAnnotation(WTFMove(typeAnnotation));</span>

 969 }
 970 
<a name="110" id="anc110"></a><span class="line-modified"> 971 void Checker::assignType(AST::Expression&amp; expression, RefPtr&lt;ResolvableTypeReference&gt; resolvableTypeReference, AST::TypeAnnotation typeAnnotation = AST::RightValue())</span>
 972 {
<a name="111" id="anc111"></a><span class="line-modified"> 973     auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(resolvableTypeReference)));</span>
 974     ASSERT_UNUSED(addResult, addResult.isNewEntry);
<a name="112" id="anc112"></a><span class="line-modified"> 975     expression.setTypeAnnotation(WTFMove(typeAnnotation));</span>
<span class="line-modified"> 976 }</span>
<span class="line-added"> 977 </span>
<span class="line-added"> 978 void Checker::forwardType(AST::Expression&amp; expression, ResolvingType&amp; resolvingType, AST::TypeAnnotation typeAnnotation = AST::RightValue())</span>
<span class="line-added"> 979 {</span>
<span class="line-added"> 980     resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; result) {</span>
<span class="line-added"> 981         auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(result.copyRef()));</span>
<span class="line-added"> 982         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added"> 983     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; result) {</span>
<span class="line-added"> 984         auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(result.copyRef()));</span>
<span class="line-added"> 985         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added"> 986     }));</span>
<span class="line-added"> 987     expression.setTypeAnnotation(WTFMove(typeAnnotation));</span>
 988 }
 989 
 990 void Checker::visit(AST::AssignmentExpression&amp; assignmentExpression)
 991 {
 992     auto leftInfo = recurseAndGetInfo(assignmentExpression.left(), true);
 993     if (!leftInfo)
 994         return;
 995 
 996     auto rightInfo = recurseAndGetInfo(assignmentExpression.right());
 997     if (!rightInfo)
 998         return;
 999 
1000     auto resultType = matchAndCommit(leftInfo-&gt;resolvingType, rightInfo-&gt;resolvingType);
1001     if (!resultType) {
<a name="113" id="anc113"></a><span class="line-modified">1002         setError(Error(&quot;Left hand side of assignment does not match the type of the right hand side.&quot;, assignmentExpression.codeLocation()));</span>
1003         return;
1004     }
1005 
<a name="114" id="anc114"></a><span class="line-modified">1006     assignConcreteType(assignmentExpression, *resultType);</span>













1007 }
1008 
1009 void Checker::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)
1010 {
<a name="115" id="anc115"></a><span class="line-modified">1011     auto leftValueInfo = recurseAndGetInfo(readModifyWriteExpression.leftValue(), true);</span>
<span class="line-modified">1012     if (!leftValueInfo)</span>
1013         return;
1014 
<a name="116" id="anc116"></a><span class="line-modified">1015     readModifyWriteExpression.oldValue().setType(*leftValueInfo-&gt;resolvingType.getUnnamedType());</span>
1016 
<a name="117" id="anc117"></a><span class="line-modified">1017     auto newValueInfo = recurseAndGetInfo(readModifyWriteExpression.newValueExpression());</span>
1018     if (!newValueInfo)
1019         return;
1020 
<a name="118" id="anc118"></a><span class="line-modified">1021     if (RefPtr&lt;AST::UnnamedType&gt; matchedType = matchAndCommit(leftValueInfo-&gt;resolvingType, newValueInfo-&gt;resolvingType))</span>
<span class="line-modified">1022         readModifyWriteExpression.newValue().setType(*matchedType);</span>
<span class="line-added">1023     else {</span>
<span class="line-added">1024         setError(Error(&quot;Base of the read-modify-write expression does not match the type of the new value.&quot;, readModifyWriteExpression.codeLocation()));</span>
1025         return;
1026     }
1027 
<a name="119" id="anc119"></a><span class="line-modified">1028     auto resultInfo = recurseAndGetInfo(readModifyWriteExpression.resultExpression());</span>
1029     if (!resultInfo)
1030         return;
1031 
1032     forwardType(readModifyWriteExpression, resultInfo-&gt;resolvingType);
1033 }
1034 
1035 static AST::UnnamedType* getUnnamedType(ResolvingType&amp; resolvingType)
1036 {
<a name="120" id="anc120"></a><span class="line-modified">1037     return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; type) -&gt; AST::UnnamedType* {</span>
<span class="line-modified">1038         return type.ptr();</span>
<span class="line-modified">1039     }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp; type) -&gt; AST::UnnamedType* {</span>
1040         // FIXME: If the type isn&#39;t committed, should we just commit() it now?
<a name="121" id="anc121"></a><span class="line-modified">1041         return type-&gt;resolvableType().maybeResolvedType();</span>
<span class="line-modified">1042     }));</span>
1043 }
1044 
1045 void Checker::visit(AST::DereferenceExpression&amp; dereferenceExpression)
1046 {
1047     auto pointerInfo = recurseAndGetInfo(dereferenceExpression.pointer());
1048     if (!pointerInfo)
1049         return;
1050 
1051     auto* unnamedType = getUnnamedType(pointerInfo-&gt;resolvingType);
1052 
1053     auto* pointerType = ([&amp;](AST::UnnamedType* unnamedType) -&gt; AST::PointerType* {
1054         if (!unnamedType)
1055             return nullptr;
1056         auto&amp; unifyNode = unnamedType-&gt;unifyNode();
1057         if (!is&lt;AST::UnnamedType&gt;(unifyNode))
1058             return nullptr;
1059         auto&amp; unnamedUnifyType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
1060         if (!is&lt;AST::PointerType&gt;(unnamedUnifyType))
1061             return nullptr;
1062         return &amp;downcast&lt;AST::PointerType&gt;(unnamedUnifyType);
1063     })(unnamedType);
1064     if (!pointerType) {
<a name="122" id="anc122"></a><span class="line-modified">1065         setError(Error(&quot;Cannot dereference a non-pointer type.&quot;, dereferenceExpression.codeLocation()));</span>
1066         return;
1067     }
1068 
<a name="123" id="anc123"></a><span class="line-modified">1069     assignConcreteType(dereferenceExpression, pointerType-&gt;elementType(), AST::LeftValue { pointerType-&gt;addressSpace() });</span>
1070 }
1071 
1072 void Checker::visit(AST::MakePointerExpression&amp; makePointerExpression)
1073 {
<a name="124" id="anc124"></a><span class="line-modified">1074     auto leftValueInfo = recurseAndGetInfo(makePointerExpression.leftValue(), true);</span>
<span class="line-modified">1075     if (!leftValueInfo)</span>
1076         return;
1077 
<a name="125" id="anc125"></a><span class="line-modified">1078     auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="line-modified">1079     if (!leftAddressSpace) {</span>
<span class="line-modified">1080         setError(Error(&quot;Cannot take the address of a non lvalue.&quot;, makePointerExpression.codeLocation()));</span>
1081         return;
1082     }
1083 
<a name="126" id="anc126"></a><span class="line-modified">1084     auto* leftValueType = getUnnamedType(leftValueInfo-&gt;resolvingType);</span>
<span class="line-added">1085     if (!leftValueType) {</span>
<span class="line-added">1086         setError(Error(&quot;Cannot take the address of a value without a type.&quot;, makePointerExpression.codeLocation()));</span>
<span class="line-added">1087         return;</span>
<span class="line-added">1088     }</span>
<span class="line-added">1089 </span>
<span class="line-added">1090     assignConcreteType(makePointerExpression, AST::PointerType::create(makePointerExpression.codeLocation(), *leftAddressSpace, *leftValueType));</span>
1091 }
1092 
1093 void Checker::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
1094 {
<a name="127" id="anc127"></a><span class="line-modified">1095     auto leftValueInfo = recurseAndGetInfo(makeArrayReferenceExpression.leftValue());</span>
<span class="line-modified">1096     if (!leftValueInfo)</span>
1097         return;
1098 
<a name="128" id="anc128"></a><span class="line-modified">1099     auto* leftValueType = getUnnamedType(leftValueInfo-&gt;resolvingType);</span>
<span class="line-modified">1100     if (!leftValueType) {</span>
<span class="line-modified">1101         setError(Error(&quot;Cannot make an array reference of a value without a type.&quot;, makeArrayReferenceExpression.codeLocation()));</span>
1102         return;
1103     }
1104 
<a name="129" id="anc129"></a><span class="line-modified">1105     auto&amp; unifyNode = leftValueType-&gt;unifyNode();</span>
1106     if (is&lt;AST::UnnamedType&gt;(unifyNode)) {
1107         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
1108         if (is&lt;AST::PointerType&gt;(unnamedType)) {
1109             auto&amp; pointerType = downcast&lt;AST::PointerType&gt;(unnamedType);
<a name="130" id="anc130"></a><span class="line-modified">1110             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the fact that we&#39;re not targetting the item; we&#39;re targetting the item&#39;s inner element.</span>
<span class="line-modified">1111             assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), pointerType.addressSpace(), pointerType.elementType()));</span>
1112             return;
1113         }
1114 
<a name="131" id="anc131"></a><span class="line-modified">1115         auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="line-modified">1116         if (!leftAddressSpace) {</span>
<span class="line-added">1117             setError(Error(&quot;Cannot make an array reference from a non-left-value.&quot;, makeArrayReferenceExpression.codeLocation()));</span>
1118             return;
1119         }
1120 
1121         if (is&lt;AST::ArrayType&gt;(unnamedType)) {
1122             auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(unnamedType);
<a name="132" id="anc132"></a><span class="line-modified">1123             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the number of elements.</span>
<span class="line-modified">1124             assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, arrayType.type()));</span>
1125             return;
1126         }
1127     }
1128 
<a name="133" id="anc133"></a><span class="line-modified">1129     auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="line-modified">1130     if (!leftAddressSpace) {</span>
<span class="line-added">1131         setError(Error(&quot;Cannot make an array reference from a non-left-value.&quot;, makeArrayReferenceExpression.codeLocation()));</span>
1132         return;
1133     }
1134 
<a name="134" id="anc134"></a><span class="line-modified">1135     assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, *leftValueType));</span>
1136 }
1137 
<a name="135" id="anc135"></a><span class="line-modified">1138 RefPtr&lt;AST::UnnamedType&gt; Checker::argumentTypeForAndOverload(AST::UnnamedType&amp; baseType, AST::AddressSpace addressSpace)</span>
1139 {
<a name="136" id="anc136"></a><span class="line-modified">1140     AndOverloadTypeKey key { baseType, addressSpace };</span>
<span class="line-modified">1141     {</span>
<span class="line-modified">1142         auto iter = m_andOverloadTypeMap.find(key);</span>
<span class="line-modified">1143         if (iter != m_andOverloadTypeMap.end())</span>
<span class="line-modified">1144             return iter-&gt;value;</span>
<span class="line-modified">1145     }</span>















1146 
<a name="137" id="anc137"></a><span class="line-modified">1147     auto createArgumentType = [&amp;] () -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified">1148         auto&amp; unifyNode = baseType.unifyNode();</span>
<span class="line-modified">1149         if (is&lt;AST::NamedType&gt;(unifyNode)) {</span>
<span class="line-modified">1150             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-modified">1151             return { AST::PointerType::create(namedType.codeLocation(), addressSpace, AST::TypeReference::wrap(namedType.codeLocation(), namedType)) };</span>
<span class="line-modified">1152         }</span>
<span class="line-modified">1153 </span>
<span class="line-modified">1154         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-modified">1155 </span>
<span class="line-modified">1156         if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))</span>
<span class="line-modified">1157             return &amp;unnamedType;</span>
<span class="line-modified">1158 </span>
<span class="line-modified">1159         if (is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="line-modified">1160             return { AST::ArrayReferenceType::create(unnamedType.codeLocation(), addressSpace, downcast&lt;AST::ArrayType&gt;(unnamedType).type()) };</span>
<span class="line-modified">1161 </span>
<span class="line-added">1162         if (is&lt;AST::PointerType&gt;(unnamedType))</span>
1163             return nullptr;
<a name="138" id="anc138"></a>
1164 
<a name="139" id="anc139"></a><span class="line-modified">1165         return { AST::PointerType::create(unnamedType.codeLocation(), addressSpace, unnamedType) };</span>
<span class="line-modified">1166     };</span>















1167 
<a name="140" id="anc140"></a><span class="line-modified">1168     auto result = createArgumentType();</span>
<span class="line-modified">1169     m_andOverloadTypeMap.add(key, result);</span>
<span class="line-modified">1170     return result;</span>
<span class="line-modified">1171 }</span>
1172 
<a name="141" id="anc141"></a><span class="line-modified">1173 void Checker::finishVisiting(AST::PropertyAccessExpression&amp; propertyAccessExpression, ResolvingType* additionalArgumentType)</span>
<span class="line-modified">1174 {</span>
<span class="line-added">1175     auto baseInfo = recurseAndGetInfo(propertyAccessExpression.base());</span>
<span class="line-added">1176     if (!baseInfo)</span>
<span class="line-added">1177         return;</span>
<span class="line-added">1178     auto baseUnnamedType = commit(baseInfo-&gt;resolvingType);</span>
<span class="line-added">1179     if (!baseUnnamedType) {</span>
<span class="line-added">1180         setError(Error(&quot;Cannot resolve the type of the base of a property access expression.&quot;, propertyAccessExpression.codeLocation()));</span>
1181         return;
1182     }
1183 
<a name="142" id="anc142"></a><span class="line-modified">1184     AST::FunctionDeclaration* getterFunction = nullptr;</span>
<span class="line-modified">1185     RefPtr&lt;AST::UnnamedType&gt; getterReturnType = nullptr;</span>
<span class="line-modified">1186     {</span>
<span class="line-modified">1187         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; getterArgumentTypes { baseInfo-&gt;resolvingType };</span>
<span class="line-modified">1188         if (additionalArgumentType)</span>
<span class="line-modified">1189             getterArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-modified">1190         auto getterName = propertyAccessExpression.getterFunctionName();</span>
<span class="line-modified">1191         getterFunction = resolveFunction(getterArgumentTypes, getterName, propertyAccessExpression.codeLocation());</span>
<span class="line-modified">1192         if (hasError())</span>















1193             return;
<a name="143" id="anc143"></a><span class="line-modified">1194         if (getterFunction)</span>
<span class="line-added">1195             getterReturnType = &amp;getterFunction-&gt;type();</span>
1196     }
1197 
<a name="144" id="anc144"></a><span class="line-modified">1198     AST::FunctionDeclaration* anderFunction = nullptr;</span>
<span class="line-modified">1199     RefPtr&lt;AST::UnnamedType&gt; anderReturnType = nullptr;</span>
<span class="line-modified">1200     auto leftAddressSpace = baseInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="line-modified">1201     if (leftAddressSpace) {</span>
<span class="line-modified">1202         if (auto argumentTypeForAndOverload = this-&gt;argumentTypeForAndOverload(*baseUnnamedType, *leftAddressSpace)) {</span>
<span class="line-modified">1203             ResolvingType argumentType = { Ref&lt;AST::UnnamedType&gt;(*argumentTypeForAndOverload) };</span>
<span class="line-modified">1204             Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; anderArgumentTypes { argumentType };</span>
<span class="line-modified">1205             if (additionalArgumentType)</span>
<span class="line-modified">1206                 anderArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-modified">1207             auto anderName = propertyAccessExpression.anderFunctionName();</span>
<span class="line-modified">1208             anderFunction = resolveFunction(anderArgumentTypes, anderName, propertyAccessExpression.codeLocation());</span>
<span class="line-modified">1209             if (hasError())</span>


1210                 return;
<a name="145" id="anc145"></a><span class="line-modified">1211             if (anderFunction)</span>
<span class="line-added">1212                 anderReturnType = &amp;downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).elementType(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198164 Enforce the return of anders will always be a pointer</span>
1213         }
1214     }
1215 
<a name="146" id="anc146"></a><span class="line-modified">1216     AST::FunctionDeclaration* threadAnderFunction = nullptr;</span>
<span class="line-modified">1217     RefPtr&lt;AST::UnnamedType&gt; threadAnderReturnType = nullptr;</span>
<span class="line-modified">1218     if (auto argumentTypeForAndOverload = this-&gt;argumentTypeForAndOverload(*baseUnnamedType, AST::AddressSpace::Thread)) {</span>
<span class="line-modified">1219         ResolvingType argumentType = { Ref&lt;AST::UnnamedType&gt;(AST::PointerType::create(propertyAccessExpression.codeLocation(), AST::AddressSpace::Thread, *baseUnnamedType)) };</span>
<span class="line-added">1220         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; threadAnderArgumentTypes { argumentType };</span>
<span class="line-added">1221         if (additionalArgumentType)</span>
<span class="line-added">1222             threadAnderArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-added">1223         auto anderName = propertyAccessExpression.anderFunctionName();</span>
<span class="line-added">1224         threadAnderFunction = resolveFunction(threadAnderArgumentTypes, anderName, propertyAccessExpression.codeLocation());</span>
<span class="line-added">1225         if (hasError())</span>
<span class="line-added">1226             return;</span>
<span class="line-added">1227         if (threadAnderFunction)</span>
<span class="line-added">1228             threadAnderReturnType = &amp;downcast&lt;AST::PointerType&gt;(threadAnderFunction-&gt;type()).elementType(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198164 Enforce the return of anders will always be a pointer</span>
<span class="line-added">1229     }</span>
1230 
<a name="147" id="anc147"></a><span class="line-modified">1231     if (leftAddressSpace &amp;&amp; !anderFunction &amp;&amp; !getterFunction) {</span>
<span class="line-modified">1232         setError(Error(&quot;Property access instruction must either have an ander or a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-modified">1233         return;</span>
<span class="line-modified">1234     }</span>

1235 
<a name="148" id="anc148"></a><span class="line-modified">1236     if (!leftAddressSpace &amp;&amp; !threadAnderFunction &amp;&amp; !getterFunction) {</span>
<span class="line-modified">1237         setError(Error(&quot;Property access instruction must either have a thread ander or a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-modified">1238         return;</span>

1239     }
<a name="149" id="anc149"></a>





1240 
<a name="150" id="anc150"></a><span class="line-modified">1241     if (threadAnderFunction &amp;&amp; getterFunction) {</span>
<span class="line-modified">1242         setError(Error(&quot;Cannot have both a thread ander and a getter.&quot;, propertyAccessExpression.codeLocation()));</span>


1243         return;
<a name="151" id="anc151"></a><span class="line-added">1244     }</span>
1245 
<a name="152" id="anc152"></a><span class="line-modified">1246     if (anderFunction &amp;&amp; threadAnderFunction &amp;&amp; !matches(*anderReturnType, *threadAnderReturnType)) {</span>
<span class="line-modified">1247         setError(Error(&quot;Return type of ander must match the return type of the thread ander.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-added">1248         return;</span>
<span class="line-added">1249     }</span>
1250 
<a name="153" id="anc153"></a><span class="line-modified">1251     if (getterFunction &amp;&amp; anderFunction &amp;&amp; !matches(*getterReturnType, *anderReturnType)) {</span>
<span class="line-modified">1252         setError(Error(&quot;Return type of ander must match the return type of the getter.&quot;, propertyAccessExpression.codeLocation()));</span>


1253         return;
<a name="154" id="anc154"></a><span class="line-added">1254     }</span>
1255 
<a name="155" id="anc155"></a><span class="line-modified">1256     if (getterFunction &amp;&amp; threadAnderFunction &amp;&amp; !matches(*getterReturnType, *threadAnderReturnType)) {</span>
<span class="line-modified">1257         setError(Error(&quot;Return type of the thread ander must match the return type of the getter.&quot;, propertyAccessExpression.codeLocation()));</span>
1258         return;
<a name="156" id="anc156"></a><span class="line-modified">1259     }</span>
<span class="line-modified">1260 </span>
<span class="line-modified">1261     Ref&lt;AST::UnnamedType&gt; fieldType = getterReturnType ? *getterReturnType : anderReturnType ? *anderReturnType : *threadAnderReturnType;</span>
<span class="line-added">1262 </span>
<span class="line-added">1263     AST::FunctionDeclaration* setterFunction = nullptr;</span>
<span class="line-added">1264     AST::UnnamedType* setterReturnType = nullptr;</span>
<span class="line-added">1265     {</span>
<span class="line-added">1266         ResolvingType fieldResolvingType(fieldType.copyRef());</span>
<span class="line-added">1267         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; setterArgumentTypes { baseInfo-&gt;resolvingType };</span>
<span class="line-added">1268         if (additionalArgumentType)</span>
<span class="line-added">1269             setterArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-added">1270         setterArgumentTypes.append(fieldResolvingType);</span>
<span class="line-added">1271         auto setterName = propertyAccessExpression.setterFunctionName();</span>
<span class="line-added">1272         setterFunction = resolveFunction(setterArgumentTypes, setterName, propertyAccessExpression.codeLocation());</span>
<span class="line-added">1273         if (hasError())</span>
<span class="line-added">1274             return;</span>
<span class="line-added">1275         if (setterFunction)</span>
<span class="line-added">1276             setterReturnType = &amp;setterFunction-&gt;type();</span>
<span class="line-added">1277     }</span>
<span class="line-added">1278 </span>
<span class="line-added">1279     if (setterFunction &amp;&amp; !getterFunction) {</span>
<span class="line-added">1280         setError(Error(&quot;Cannot define a setter function without a corresponding getter.&quot;, propertyAccessExpression.codeLocation()));</span>
1281         return;
1282     }
1283 
<a name="157" id="anc157"></a><span class="line-modified">1284     propertyAccessExpression.setGetterFunction(getterFunction);</span>
<span class="line-added">1285     propertyAccessExpression.setAnderFunction(anderFunction);</span>
<span class="line-added">1286     propertyAccessExpression.setThreadAnderFunction(threadAnderFunction);</span>
<span class="line-added">1287     propertyAccessExpression.setSetterFunction(setterFunction);</span>
<span class="line-added">1288 </span>
<span class="line-added">1289     AST::TypeAnnotation typeAnnotation = AST::RightValue();</span>
<span class="line-added">1290     if (auto leftAddressSpace = baseInfo-&gt;typeAnnotation.leftAddressSpace()) {</span>
<span class="line-added">1291         if (anderFunction)</span>
<span class="line-added">1292             typeAnnotation = AST::LeftValue { downcast&lt;AST::ReferenceType&gt;(anderFunction-&gt;type()).addressSpace() };</span>
<span class="line-added">1293         else if (setterFunction)</span>
<span class="line-added">1294             typeAnnotation = AST::AbstractLeftValue();</span>
<span class="line-added">1295     } else if (!baseInfo-&gt;typeAnnotation.isRightValue() &amp;&amp; (setterFunction || threadAnderFunction))</span>
<span class="line-added">1296         typeAnnotation = AST::AbstractLeftValue();</span>
<span class="line-added">1297     assignConcreteType(propertyAccessExpression, WTFMove(fieldType), WTFMove(typeAnnotation));</span>
<span class="line-added">1298 }</span>
<span class="line-added">1299 </span>
<span class="line-added">1300 void Checker::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-added">1301 {</span>
<span class="line-added">1302     finishVisiting(dotExpression);</span>
<span class="line-added">1303 }</span>
<span class="line-added">1304 </span>
<span class="line-added">1305 void Checker::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-added">1306 {</span>
<span class="line-added">1307     auto baseInfo = recurseAndGetInfo(indexExpression.indexExpression());</span>
<span class="line-added">1308     if (!baseInfo)</span>
<span class="line-added">1309         return;</span>
<span class="line-added">1310     finishVisiting(indexExpression, &amp;baseInfo-&gt;resolvingType);</span>
1311 }
1312 
1313 void Checker::visit(AST::VariableReference&amp; variableReference)
1314 {
1315     ASSERT(variableReference.variable());
1316     ASSERT(variableReference.variable()-&gt;type());
1317 
<a name="158" id="anc158"></a><span class="line-modified">1318     assignConcreteType(variableReference, *variableReference.variable()-&gt;type(), AST::LeftValue { AST::AddressSpace::Thread });</span>



1319 }
1320 
1321 void Checker::visit(AST::Return&amp; returnStatement)
1322 {
<a name="159" id="anc159"></a>
1323     if (returnStatement.value()) {
1324         auto valueInfo = recurseAndGetInfo(*returnStatement.value());
1325         if (!valueInfo)
1326             return;
<a name="160" id="anc160"></a><span class="line-modified">1327         if (!matchAndCommit(valueInfo-&gt;resolvingType, m_currentFunction-&gt;type()))</span>
<span class="line-modified">1328             setError(Error(&quot;Type of the return value must match the return type of the function.&quot;, returnStatement.codeLocation()));</span>
1329         return;
1330     }
1331 
<a name="161" id="anc161"></a><span class="line-modified">1332     if (!matches(m_currentFunction-&gt;type(), m_intrinsics.voidType()))</span>
<span class="line-modified">1333         setError(Error(&quot;Cannot return a value from a void function.&quot;, returnStatement.codeLocation()));</span>
1334 }
1335 
1336 void Checker::visit(AST::PointerType&amp;)
1337 {
1338     // Following pointer types can cause infinite loops because of data structures
1339     // like linked lists.
1340     // FIXME: Make sure this function should be empty
1341 }
1342 
1343 void Checker::visit(AST::ArrayReferenceType&amp;)
1344 {
1345     // Following array reference types can cause infinite loops because of data
1346     // structures like linked lists.
1347     // FIXME: Make sure this function should be empty
1348 }
1349 
1350 void Checker::visit(AST::IntegerLiteral&amp; integerLiteral)
1351 {
1352     assignType(integerLiteral, adoptRef(*new ResolvableTypeReference(integerLiteral.type())));
1353 }
1354 
1355 void Checker::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
1356 {
1357     assignType(unsignedIntegerLiteral, adoptRef(*new ResolvableTypeReference(unsignedIntegerLiteral.type())));
1358 }
1359 
1360 void Checker::visit(AST::FloatLiteral&amp; floatLiteral)
1361 {
1362     assignType(floatLiteral, adoptRef(*new ResolvableTypeReference(floatLiteral.type())));
1363 }
1364 
1365 void Checker::visit(AST::NullLiteral&amp; nullLiteral)
1366 {
1367     assignType(nullLiteral, adoptRef(*new ResolvableTypeReference(nullLiteral.type())));
1368 }
1369 
1370 void Checker::visit(AST::BooleanLiteral&amp; booleanLiteral)
1371 {
<a name="162" id="anc162"></a><span class="line-modified">1372     assignConcreteType(booleanLiteral, AST::TypeReference::wrap(booleanLiteral.codeLocation(), m_intrinsics.boolType()));</span>
1373 }
1374 
1375 void Checker::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
1376 {
1377     ASSERT(enumerationMemberLiteral.enumerationDefinition());
1378     auto&amp; enumerationDefinition = *enumerationMemberLiteral.enumerationDefinition();
<a name="163" id="anc163"></a><span class="line-modified">1379     assignConcreteType(enumerationMemberLiteral, AST::TypeReference::wrap(enumerationMemberLiteral.codeLocation(), enumerationDefinition));</span>
1380 }
1381 
1382 bool Checker::isBoolType(ResolvingType&amp; resolvingType)
1383 {
<a name="164" id="anc164"></a><span class="line-modified">1384     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; left) -&gt; bool {</span>
1385         return matches(left, m_intrinsics.boolType());
<a name="165" id="anc165"></a><span class="line-modified">1386     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; left) -&gt; bool {</span>
1387         return static_cast&lt;bool&gt;(matchAndCommit(m_intrinsics.boolType(), left-&gt;resolvableType()));
<a name="166" id="anc166"></a><span class="line-modified">1388     }));</span>
1389 }
1390 
1391 bool Checker::recurseAndRequireBoolType(AST::Expression&amp; expression)
1392 {
1393     auto expressionInfo = recurseAndGetInfo(expression);
1394     if (!expressionInfo)
1395         return false;
1396     if (!isBoolType(expressionInfo-&gt;resolvingType)) {
<a name="167" id="anc167"></a><span class="line-modified">1397         setError(Error(&quot;Expected bool type from expression.&quot;, expression.codeLocation()));</span>
1398         return false;
1399     }
1400     return true;
1401 }
1402 
1403 void Checker::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
1404 {
1405     if (!recurseAndRequireBoolType(logicalNotExpression.operand()))
1406         return;
<a name="168" id="anc168"></a><span class="line-modified">1407     assignConcreteType(logicalNotExpression, AST::TypeReference::wrap(logicalNotExpression.codeLocation(), m_intrinsics.boolType()));</span>
1408 }
1409 
1410 void Checker::visit(AST::LogicalExpression&amp; logicalExpression)
1411 {
1412     if (!recurseAndRequireBoolType(logicalExpression.left()))
1413         return;
1414     if (!recurseAndRequireBoolType(logicalExpression.right()))
1415         return;
<a name="169" id="anc169"></a><span class="line-modified">1416     assignConcreteType(logicalExpression, AST::TypeReference::wrap(logicalExpression.codeLocation(), m_intrinsics.boolType()));</span>
1417 }
1418 
1419 void Checker::visit(AST::IfStatement&amp; ifStatement)
1420 {
1421     if (!recurseAndRequireBoolType(ifStatement.conditional()))
1422         return;
1423     checkErrorAndVisit(ifStatement.body());
1424     if (ifStatement.elseBody())
1425         checkErrorAndVisit(*ifStatement.elseBody());
1426 }
1427 
1428 void Checker::visit(AST::WhileLoop&amp; whileLoop)
1429 {
1430     if (!recurseAndRequireBoolType(whileLoop.conditional()))
1431         return;
1432     checkErrorAndVisit(whileLoop.body());
1433 }
1434 
1435 void Checker::visit(AST::DoWhileLoop&amp; doWhileLoop)
1436 {
1437     checkErrorAndVisit(doWhileLoop.body());
1438     recurseAndRequireBoolType(doWhileLoop.conditional());
1439 }
1440 
1441 void Checker::visit(AST::ForLoop&amp; forLoop)
1442 {
<a name="170" id="anc170"></a><span class="line-modified">1443     checkErrorAndVisit(forLoop.initialization());</span>
<span class="line-modified">1444     if (hasError())</span>




1445         return;
1446     if (forLoop.condition()) {
1447         if (!recurseAndRequireBoolType(*forLoop.condition()))
1448             return;
1449     }
1450     if (forLoop.increment())
1451         checkErrorAndVisit(*forLoop.increment());
1452     checkErrorAndVisit(forLoop.body());
1453 }
1454 
1455 void Checker::visit(AST::SwitchStatement&amp; switchStatement)
1456 {
1457     auto* valueType = ([&amp;]() -&gt; AST::NamedType* {
1458         auto valueInfo = recurseAndGetInfo(switchStatement.value());
1459         if (!valueInfo)
1460             return nullptr;
1461         auto* valueType = getUnnamedType(valueInfo-&gt;resolvingType);
1462         if (!valueType)
1463             return nullptr;
1464         auto&amp; valueUnifyNode = valueType-&gt;unifyNode();
1465         if (!is&lt;AST::NamedType&gt;(valueUnifyNode))
1466             return nullptr;
1467         auto&amp; valueNamedUnifyNode = downcast&lt;AST::NamedType&gt;(valueUnifyNode);
1468         if (!(is&lt;AST::NativeTypeDeclaration&gt;(valueNamedUnifyNode) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(valueNamedUnifyNode).isInt())
1469             &amp;&amp; !is&lt;AST::EnumerationDefinition&gt;(valueNamedUnifyNode))
1470             return nullptr;
1471         return &amp;valueNamedUnifyNode;
1472     })();
1473     if (!valueType) {
<a name="171" id="anc171"></a><span class="line-modified">1474         setError(Error(&quot;Invalid type for the expression condition of the switch statement.&quot;, switchStatement.codeLocation()));</span>
1475         return;
1476     }
1477 
1478     bool hasDefault = false;
1479     for (auto&amp; switchCase : switchStatement.switchCases()) {
1480         checkErrorAndVisit(switchCase.block());
1481         if (!switchCase.value()) {
1482             hasDefault = true;
1483             continue;
1484         }
<a name="172" id="anc172"></a><span class="line-modified">1485         auto success = switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) -&gt; bool {</span>
<span class="line-modified">1486             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, integerLiteral.type()));</span>
<span class="line-modified">1487         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">1488             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, unsignedIntegerLiteral.type()));</span>
<span class="line-modified">1489         }, [&amp;](AST::FloatLiteral&amp; floatLiteral) -&gt; bool {</span>
<span class="line-modified">1490             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, floatLiteral.type()));</span>
<span class="line-modified">1491         }, [&amp;](AST::NullLiteral&amp; nullLiteral) -&gt; bool {</span>
<span class="line-modified">1492             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, nullLiteral.type()));</span>
<span class="line-modified">1493         }, [&amp;](AST::BooleanLiteral&amp;) -&gt; bool {</span>
<span class="line-modified">1494             return matches(*valueType, m_intrinsics.boolType());</span>
<span class="line-modified">1495         }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) -&gt; bool {</span>

1496             ASSERT(enumerationMemberLiteral.enumerationDefinition());
<a name="173" id="anc173"></a><span class="line-modified">1497             return matches(*valueType, *enumerationMemberLiteral.enumerationDefinition());</span>
1498         }));
1499         if (!success) {
<a name="174" id="anc174"></a><span class="line-modified">1500             setError(Error(&quot;Invalid type for switch case.&quot;, switchCase.codeLocation()));</span>
1501             return;
1502         }
1503     }
1504 
1505     for (size_t i = 0; i &lt; switchStatement.switchCases().size(); ++i) {
1506         auto&amp; firstCase = switchStatement.switchCases()[i];
1507         for (size_t j = i + 1; j &lt; switchStatement.switchCases().size(); ++j) {
1508             auto&amp; secondCase = switchStatement.switchCases()[j];
1509 
1510             if (static_cast&lt;bool&gt;(firstCase.value()) != static_cast&lt;bool&gt;(secondCase.value()))
1511                 continue;
1512 
1513             if (!static_cast&lt;bool&gt;(firstCase.value())) {
<a name="175" id="anc175"></a><span class="line-modified">1514                 setError(Error(&quot;Cannot define multiple default cases in switch statement.&quot;, secondCase.codeLocation()));</span>
1515                 return;
1516             }
1517 
<a name="176" id="anc176"></a><span class="line-modified">1518             auto success = firstCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; firstIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">1519                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">1520                     return firstIntegerLiteral.value() != secondIntegerLiteral.value();</span>
<span class="line-modified">1521                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">1522                     return static_cast&lt;int64_t&gt;(firstIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondUnsignedIntegerLiteral.value());</span>
<span class="line-modified">1523                 }, [](auto&amp;) -&gt; bool {</span>
<span class="line-modified">1524                     return true;</span>
1525                 }));
<a name="177" id="anc177"></a><span class="line-modified">1526             }, [&amp;](AST::UnsignedIntegerLiteral&amp; firstUnsignedIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">1527                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">1528                     return static_cast&lt;int64_t&gt;(firstUnsignedIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondIntegerLiteral.value());</span>
<span class="line-modified">1529                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">1530                     return firstUnsignedIntegerLiteral.value() != secondUnsignedIntegerLiteral.value();</span>
<span class="line-modified">1531                 }, [](auto&amp;) -&gt; bool {</span>
<span class="line-added">1532                     return true;</span>
1533                 }));
<a name="178" id="anc178"></a><span class="line-modified">1534             }, [&amp;](AST::EnumerationMemberLiteral&amp; firstEnumerationMemberLiteral) -&gt; bool {</span>
<span class="line-modified">1535                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::EnumerationMemberLiteral&amp; secondEnumerationMemberLiteral) -&gt; bool {</span>

1536                     ASSERT(firstEnumerationMemberLiteral.enumerationMember());
1537                     ASSERT(secondEnumerationMemberLiteral.enumerationMember());
<a name="179" id="anc179"></a><span class="line-modified">1538                     return firstEnumerationMemberLiteral.enumerationMember() != secondEnumerationMemberLiteral.enumerationMember();</span>
<span class="line-modified">1539                 }, [](auto&amp;) -&gt; bool {</span>
<span class="line-added">1540                     return true;</span>
1541                 }));
<a name="180" id="anc180"></a><span class="line-modified">1542             }, [](auto&amp;) -&gt; bool {</span>
<span class="line-added">1543                 return true;</span>
1544             }));
<a name="181" id="anc181"></a><span class="line-added">1545             if (!success) {</span>
<span class="line-added">1546                 setError(Error(&quot;Cannot define duplicate case statements in a switch.&quot;, secondCase.codeLocation()));</span>
<span class="line-added">1547                 return;</span>
<span class="line-added">1548             }</span>
1549         }
1550     }
1551 
1552     if (!hasDefault) {
1553         if (is&lt;AST::NativeTypeDeclaration&gt;(*valueType)) {
1554             HashSet&lt;int64_t&gt; values;
1555             bool zeroValueExists;
1556             for (auto&amp; switchCase : switchStatement.switchCases()) {
<a name="182" id="anc182"></a><span class="line-modified">1557                 auto value = switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) -&gt; int64_t {</span>
<span class="line-modified">1558                     return integerLiteral.valueForSelectedType();</span>
<span class="line-modified">1559                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) -&gt; int64_t {</span>
<span class="line-modified">1560                     return unsignedIntegerLiteral.valueForSelectedType();</span>
<span class="line-modified">1561                 }, [](auto&amp;) -&gt; int64_t {</span>

1562                     ASSERT_NOT_REACHED();
<a name="183" id="anc183"></a><span class="line-added">1563                     return 0;</span>
1564                 }));
1565                 if (!value)
1566                     zeroValueExists = true;
1567                 else
1568                     values.add(value);
1569             }
1570             bool success = true;
1571             downcast&lt;AST::NativeTypeDeclaration&gt;(*valueType).iterateAllValues([&amp;](int64_t value) -&gt; bool {
1572                 if (!value) {
1573                     if (!zeroValueExists) {
1574                         success = false;
1575                         return true;
1576                     }
1577                     return false;
1578                 }
1579                 if (!values.contains(value)) {
1580                     success = false;
1581                     return true;
1582                 }
1583                 return false;
1584             });
1585             if (!success) {
<a name="184" id="anc184"></a><span class="line-modified">1586                 setError(Error(&quot;Switch cases must be exhaustive or you must define a default case.&quot;, switchStatement.codeLocation()));</span>
1587                 return;
1588             }
1589         } else {
<a name="185" id="anc185"></a>
1590             HashSet&lt;AST::EnumerationMember*&gt; values;
1591             for (auto&amp; switchCase : switchStatement.switchCases()) {
1592                 switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
1593                     ASSERT(enumerationMemberLiteral.enumerationMember());
1594                     values.add(enumerationMemberLiteral.enumerationMember());
1595                 }, [](auto&amp;) {
1596                     ASSERT_NOT_REACHED();
1597                 }));
1598             }
1599             for (auto&amp; enumerationMember : downcast&lt;AST::EnumerationDefinition&gt;(*valueType).enumerationMembers()) {
1600                 if (!values.contains(&amp;enumerationMember.get())) {
<a name="186" id="anc186"></a><span class="line-modified">1601                     setError(Error(&quot;Switch cases over an enum must be exhaustive or you must define a default case.&quot;, switchStatement.codeLocation()));</span>
1602                     return;
1603                 }
1604             }
1605         }
1606     }
1607 }
1608 
1609 void Checker::visit(AST::CommaExpression&amp; commaExpression)
1610 {
1611     ASSERT(commaExpression.list().size() &gt; 0);
1612     Visitor::visit(commaExpression);
<a name="187" id="anc187"></a><span class="line-modified">1613     if (hasError())</span>
1614         return;
1615     auto lastInfo = getInfo(commaExpression.list().last());
1616     forwardType(commaExpression, lastInfo-&gt;resolvingType);
1617 }
1618 
1619 void Checker::visit(AST::TernaryExpression&amp; ternaryExpression)
1620 {
1621     auto predicateInfo = recurseAndRequireBoolType(ternaryExpression.predicate());
1622     if (!predicateInfo)
1623         return;
1624 
1625     auto bodyInfo = recurseAndGetInfo(ternaryExpression.bodyExpression());
1626     auto elseInfo = recurseAndGetInfo(ternaryExpression.elseExpression());
1627 
1628     auto resultType = matchAndCommit(bodyInfo-&gt;resolvingType, elseInfo-&gt;resolvingType);
1629     if (!resultType) {
<a name="188" id="anc188"></a><span class="line-modified">1630         setError(Error(&quot;lhs and rhs of a ternary expression must match.&quot;, ternaryExpression.codeLocation()));</span>
1631         return;
1632     }
1633 
<a name="189" id="anc189"></a><span class="line-modified">1634     assignConcreteType(ternaryExpression, *resultType);</span>
1635 }
1636 
1637 void Checker::visit(AST::CallExpression&amp; callExpression)
1638 {
1639     Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; types;
1640     types.reserveInitialCapacity(callExpression.arguments().size());
1641     for (auto&amp; argument : callExpression.arguments()) {
1642         auto argumentInfo = recurseAndGetInfo(argument);
1643         if (!argumentInfo)
1644             return;
1645         types.uncheckedAppend(argumentInfo-&gt;resolvingType);
1646     }
<a name="190" id="anc190"></a><span class="line-modified">1647     // Don&#39;t recurse on the castReturnType, because it&#39;s guaranteed to be a NamedType, which will get visited later.</span>
<span class="line-modified">1648     // We don&#39;t want to recurse to the same node twice.</span>
<span class="line-modified">1649 </span>
<span class="line-modified">1650     auto* function = resolveFunction(types, callExpression.name(), callExpression.codeLocation());</span>
<span class="line-modified">1651     if (hasError())</span>
<span class="line-added">1652         return;</span>
1653 
<a name="191" id="anc191"></a>

1654     if (!function) {
<a name="192" id="anc192"></a><span class="line-modified">1655         NameContext&amp; nameContext = m_program.nameContext();</span>
<span class="line-modified">1656         auto castTypes = nameContext.getTypes(callExpression.name(), m_currentNameSpace);</span>
<span class="line-modified">1657         if (castTypes.size() == 1) {</span>
<span class="line-added">1658             AST::NamedType&amp; castType = castTypes[0].get();</span>
<span class="line-added">1659             function = resolveFunction(types, &quot;operator cast&quot;_str, callExpression.codeLocation(), &amp;castType);</span>
<span class="line-added">1660             if (hasError())</span>
<span class="line-added">1661                 return;</span>
<span class="line-added">1662             if (function)</span>
<span class="line-added">1663                 callExpression.setCastData(castType);</span>
1664         }
1665     }
1666 
1667     if (!function) {
<a name="193" id="anc193"></a><span class="line-modified">1668         // FIXME: Add better error messages for why we can&#39;t resolve to one of the overrides.</span>
<span class="line-added">1669         // https://bugs.webkit.org/show_bug.cgi?id=200133</span>
<span class="line-added">1670         setError(Error(&quot;Cannot resolve function call to a concrete callee. Make sure you are using compatible types.&quot;, callExpression.codeLocation()));</span>
1671         return;
1672     }
1673 
1674     for (size_t i = 0; i &lt; function-&gt;parameters().size(); ++i) {
<a name="194" id="anc194"></a><span class="line-modified">1675         if (!matchAndCommit(types[i].get(), *function-&gt;parameters()[i]-&gt;type())) {</span>
<span class="line-modified">1676             setError(Error(makeString(&quot;Invalid type for parameter number &quot;, i + 1, &quot; in function call.&quot;), callExpression.codeLocation()));</span>
1677             return;
1678         }
1679     }
1680 
1681     callExpression.setFunction(*function);
1682 
<a name="195" id="anc195"></a><span class="line-modified">1683     assignConcreteType(callExpression, function-&gt;type());</span>
1684 }
1685 
<a name="196" id="anc196"></a><span class="line-modified">1686 Expected&lt;void, Error&gt; check(Program&amp; program)</span>
1687 {
1688     Checker checker(program.intrinsics(), program);
1689     checker.checkErrorAndVisit(program);
<a name="197" id="anc197"></a><span class="line-modified">1690     if (checker.hasError())</span>
<span class="line-modified">1691         return checker.result();</span>
1692     return checker.assignTypes();
1693 }
1694 
1695 } // namespace WHLSL
1696 
1697 } // namespace WebCore
1698 
1699 #endif // ENABLE(WEBGPU)
<a name="198" id="anc198"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="198" type="hidden" />
</body>
</html>