<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2007 David Smith (catfish.man@gmail.com)
   5  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.
   6  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;RenderBlock.h&quot;
  26 
  27 #include &quot;AXObjectCache.h&quot;
  28 #include &quot;Document.h&quot;
  29 #include &quot;Editor.h&quot;
  30 #include &quot;Element.h&quot;
  31 #include &quot;FloatQuad.h&quot;
  32 #include &quot;Frame.h&quot;
  33 #include &quot;FrameSelection.h&quot;
  34 #include &quot;FrameView.h&quot;
  35 #include &quot;GraphicsContext.h&quot;
  36 #include &quot;HTMLNames.h&quot;
  37 #include &quot;HitTestLocation.h&quot;
  38 #include &quot;HitTestResult.h&quot;
  39 #include &quot;InlineElementBox.h&quot;
  40 #include &quot;InlineIterator.h&quot;
  41 #include &quot;InlineTextBox.h&quot;
  42 #include &quot;LayoutRepainter.h&quot;
  43 #include &quot;LogicalSelectionOffsetCaches.h&quot;
  44 #include &quot;OverflowEvent.h&quot;
  45 #include &quot;Page.h&quot;
  46 #include &quot;PaintInfo.h&quot;
  47 #include &quot;RenderBlockFlow.h&quot;
  48 #include &quot;RenderBoxFragmentInfo.h&quot;
  49 #include &quot;RenderButton.h&quot;
  50 #include &quot;RenderChildIterator.h&quot;
  51 #include &quot;RenderCombineText.h&quot;
  52 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  53 #include &quot;RenderFlexibleBox.h&quot;
  54 #include &quot;RenderFragmentContainer.h&quot;
  55 #include &quot;RenderInline.h&quot;
  56 #include &quot;RenderIterator.h&quot;
  57 #include &quot;RenderLayer.h&quot;
  58 #include &quot;RenderLayoutState.h&quot;
  59 #include &quot;RenderListMarker.h&quot;
  60 #include &quot;RenderMenuList.h&quot;
  61 #include &quot;RenderSVGResourceClipper.h&quot;
  62 #include &quot;RenderSVGRoot.h&quot;
  63 #include &quot;RenderTableCell.h&quot;
  64 #include &quot;RenderTextFragment.h&quot;
  65 #include &quot;RenderTheme.h&quot;
  66 #include &quot;RenderTreeBuilder.h&quot;
  67 #include &quot;RenderTreePosition.h&quot;
  68 #include &quot;RenderView.h&quot;
  69 #include &quot;SVGSVGElement.h&quot;
  70 #include &quot;Settings.h&quot;
  71 #include &quot;ShadowRoot.h&quot;
  72 #include &quot;ShapeOutsideInfo.h&quot;
  73 #include &quot;TransformState.h&quot;
  74 #include &lt;wtf/IsoMallocInlines.h&gt;
  75 #include &lt;wtf/NeverDestroyed.h&gt;
  76 #include &lt;wtf/Optional.h&gt;
  77 #include &lt;wtf/SetForScope.h&gt;
  78 #include &lt;wtf/StackStats.h&gt;
  79 
  80 namespace WebCore {
  81 
  82 using namespace HTMLNames;
  83 using namespace WTF::Unicode;
  84 
  85 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderBlock);
  86 
  87 struct SameSizeAsRenderBlock : public RenderBox {
  88 };
  89 
  90 COMPILE_ASSERT(sizeof(RenderBlock) == sizeof(SameSizeAsRenderBlock), RenderBlock_should_stay_small);
  91 
  92 typedef HashMap&lt;const RenderBlock*, std::unique_ptr&lt;TrackedRendererListHashSet&gt;&gt; TrackedDescendantsMap;
  93 typedef HashMap&lt;const RenderBox*, std::unique_ptr&lt;HashSet&lt;const RenderBlock*&gt;&gt;&gt; TrackedContainerMap;
  94 
  95 static TrackedDescendantsMap* percentHeightDescendantsMap;
  96 static TrackedContainerMap* percentHeightContainerMap;
  97 
  98 static void insertIntoTrackedRendererMaps(const RenderBlock&amp; container, RenderBox&amp; descendant)
  99 {
 100     if (!percentHeightDescendantsMap) {
 101         percentHeightDescendantsMap = new TrackedDescendantsMap;
 102         percentHeightContainerMap = new TrackedContainerMap;
 103     }
 104 
 105     auto&amp; descendantSet = percentHeightDescendantsMap-&gt;ensure(&amp;container, [] {
 106         return std::make_unique&lt;TrackedRendererListHashSet&gt;();
 107     }).iterator-&gt;value;
 108 
 109     bool added = descendantSet-&gt;add(&amp;descendant).isNewEntry;
 110     if (!added) {
 111         ASSERT(percentHeightContainerMap-&gt;get(&amp;descendant));
 112         ASSERT(percentHeightContainerMap-&gt;get(&amp;descendant)-&gt;contains(&amp;container));
 113         return;
 114     }
 115 
 116     auto&amp; containerSet = percentHeightContainerMap-&gt;ensure(&amp;descendant, [] {
 117         return std::make_unique&lt;HashSet&lt;const RenderBlock*&gt;&gt;();
 118     }).iterator-&gt;value;
 119 
 120     ASSERT(!containerSet-&gt;contains(&amp;container));
 121     containerSet-&gt;add(&amp;container);
 122 }
 123 
 124 static void removeFromTrackedRendererMaps(RenderBox&amp; descendant)
 125 {
 126     if (!percentHeightDescendantsMap)
 127         return;
 128 
 129     std::unique_ptr&lt;HashSet&lt;const RenderBlock*&gt;&gt; containerSet = percentHeightContainerMap-&gt;take(&amp;descendant);
 130     if (!containerSet)
 131         return;
 132 
 133     for (auto* container : *containerSet) {
 134         // FIXME: Disabling this assert temporarily until we fix the layout
 135         // bugs associated with positioned objects not properly cleared from
 136         // their ancestor chain before being moved. See webkit bug 93766.
 137         // ASSERT(descendant-&gt;isDescendantOf(container));
 138         auto descendantsMapIterator = percentHeightDescendantsMap-&gt;find(container);
 139         ASSERT(descendantsMapIterator != percentHeightDescendantsMap-&gt;end());
 140         if (descendantsMapIterator == percentHeightDescendantsMap-&gt;end())
 141             continue;
 142         auto&amp; descendantSet = descendantsMapIterator-&gt;value;
 143         ASSERT(descendantSet-&gt;contains(&amp;descendant));
 144         descendantSet-&gt;remove(&amp;descendant);
 145         if (descendantSet-&gt;isEmpty())
 146             percentHeightDescendantsMap-&gt;remove(descendantsMapIterator);
 147     }
 148 }
 149 
 150 class PositionedDescendantsMap {
 151 public:
 152     enum class MoveDescendantToEnd { No, Yes };
 153     void addDescendant(const RenderBlock&amp; containingBlock, RenderBox&amp; positionedDescendant, MoveDescendantToEnd moveDescendantToEnd)
 154     {
 155         // Protect against double insert where a descendant would end up with multiple containing blocks.
 156         auto* previousContainingBlock = m_containerMap.get(&amp;positionedDescendant);
 157         if (previousContainingBlock &amp;&amp; previousContainingBlock != &amp;containingBlock) {
 158             if (auto* descendants = m_descendantsMap.get(previousContainingBlock))
 159                 descendants-&gt;remove(&amp;positionedDescendant);
 160         }
 161 
 162         auto&amp; descendants = m_descendantsMap.ensure(&amp;containingBlock, [] {
 163             return std::make_unique&lt;TrackedRendererListHashSet&gt;();
 164         }).iterator-&gt;value;
 165 
 166         bool isNewEntry = moveDescendantToEnd == MoveDescendantToEnd::Yes ? descendants-&gt;appendOrMoveToLast(&amp;positionedDescendant).isNewEntry
 167             : descendants-&gt;add(&amp;positionedDescendant).isNewEntry;
 168         if (!isNewEntry) {
 169             ASSERT(m_containerMap.contains(&amp;positionedDescendant));
 170             return;
 171         }
 172         m_containerMap.set(&amp;positionedDescendant, &amp;containingBlock);
 173     }
 174 
 175     void removeDescendant(const RenderBox&amp; positionedDescendant)
 176     {
 177         auto* containingBlock = m_containerMap.take(&amp;positionedDescendant);
 178         if (!containingBlock)
 179             return;
 180 
 181         auto descendantsIterator = m_descendantsMap.find(containingBlock);
 182         ASSERT(descendantsIterator != m_descendantsMap.end());
 183         if (descendantsIterator == m_descendantsMap.end())
 184             return;
 185 
 186         auto&amp; descendants = descendantsIterator-&gt;value;
 187         ASSERT(descendants-&gt;contains(const_cast&lt;RenderBox*&gt;(&amp;positionedDescendant)));
 188 
 189         descendants-&gt;remove(const_cast&lt;RenderBox*&gt;(&amp;positionedDescendant));
 190         if (descendants-&gt;isEmpty())
 191             m_descendantsMap.remove(descendantsIterator);
 192     }
 193 
 194     void removeContainingBlock(const RenderBlock&amp; containingBlock)
 195     {
 196         auto descendants = m_descendantsMap.take(&amp;containingBlock);
 197         if (!descendants)
 198             return;
 199 
 200         for (auto* renderer : *descendants)
 201             m_containerMap.remove(renderer);
 202     }
 203 
 204     TrackedRendererListHashSet* positionedRenderers(const RenderBlock&amp; containingBlock) const
 205     {
 206         return m_descendantsMap.get(&amp;containingBlock);
 207     }
 208 
 209 private:
 210     using DescendantsMap = HashMap&lt;const RenderBlock*, std::unique_ptr&lt;TrackedRendererListHashSet&gt;&gt;;
 211     using ContainerMap = HashMap&lt;const RenderBox*, const RenderBlock*&gt;;
 212 
 213     DescendantsMap m_descendantsMap;
 214     ContainerMap m_containerMap;
 215 };
 216 
 217 static PositionedDescendantsMap&amp; positionedDescendantsMap()
 218 {
 219     static NeverDestroyed&lt;PositionedDescendantsMap&gt; mapForPositionedDescendants;
 220     return mapForPositionedDescendants;
 221 }
 222 
 223 typedef HashMap&lt;RenderBlock*, std::unique_ptr&lt;ListHashSet&lt;RenderInline*&gt;&gt;&gt; ContinuationOutlineTableMap;
 224 
 225 struct UpdateScrollInfoAfterLayoutTransaction {
 226     UpdateScrollInfoAfterLayoutTransaction(const RenderView&amp; view)
 227         : nestedCount(0)
 228         , view(&amp;view)
 229     {
 230     }
 231 
 232     int nestedCount;
 233     const RenderView* view;
 234     HashSet&lt;RenderBlock*&gt; blocks;
 235 };
 236 
 237 typedef Vector&lt;UpdateScrollInfoAfterLayoutTransaction&gt; DelayedUpdateScrollInfoStack;
 238 static std::unique_ptr&lt;DelayedUpdateScrollInfoStack&gt;&amp; updateScrollInfoAfterLayoutTransactionStack()
 239 {
 240     static NeverDestroyed&lt;std::unique_ptr&lt;DelayedUpdateScrollInfoStack&gt;&gt; delayedUpdatedScrollInfoStack;
 241     return delayedUpdatedScrollInfoStack;
 242 }
 243 
 244 // Allocated only when some of these fields have non-default values
 245 
 246 struct RenderBlockRareData {
 247     WTF_MAKE_NONCOPYABLE(RenderBlockRareData); WTF_MAKE_FAST_ALLOCATED;
 248 public:
 249     RenderBlockRareData()
 250     {
 251     }
 252 
 253     LayoutUnit m_paginationStrut;
 254     LayoutUnit m_pageLogicalOffset;
 255     LayoutUnit m_intrinsicBorderForFieldset;
 256 
 257     Optional&lt;WeakPtr&lt;RenderFragmentedFlow&gt;&gt; m_enclosingFragmentedFlow;
 258 };
 259 
 260 typedef HashMap&lt;const RenderBlock*, std::unique_ptr&lt;RenderBlockRareData&gt;&gt; RenderBlockRareDataMap;
 261 static RenderBlockRareDataMap* gRareDataMap;
 262 
 263 // This class helps dispatching the &#39;overflow&#39; event on layout change. overflow can be set on RenderBoxes, yet the existing code
 264 // only works on RenderBlocks. If this change, this class should be shared with other RenderBoxes.
 265 class OverflowEventDispatcher {
 266     WTF_MAKE_NONCOPYABLE(OverflowEventDispatcher);
 267 public:
 268     OverflowEventDispatcher(const RenderBlock* block)
 269         : m_block(block)
 270         , m_hadHorizontalLayoutOverflow(false)
 271         , m_hadVerticalLayoutOverflow(false)
 272     {
 273         m_shouldDispatchEvent = !m_block-&gt;isAnonymous() &amp;&amp; m_block-&gt;hasOverflowClip() &amp;&amp; m_block-&gt;document().hasListenerType(Document::OVERFLOWCHANGED_LISTENER);
 274         if (m_shouldDispatchEvent) {
 275             m_hadHorizontalLayoutOverflow = m_block-&gt;hasHorizontalLayoutOverflow();
 276             m_hadVerticalLayoutOverflow = m_block-&gt;hasVerticalLayoutOverflow();
 277         }
 278     }
 279 
 280     ~OverflowEventDispatcher()
 281     {
 282         if (!m_shouldDispatchEvent)
 283             return;
 284 
 285         bool hasHorizontalLayoutOverflow = m_block-&gt;hasHorizontalLayoutOverflow();
 286         bool hasVerticalLayoutOverflow = m_block-&gt;hasVerticalLayoutOverflow();
 287 
 288         bool horizontalLayoutOverflowChanged = hasHorizontalLayoutOverflow != m_hadHorizontalLayoutOverflow;
 289         bool verticalLayoutOverflowChanged = hasVerticalLayoutOverflow != m_hadVerticalLayoutOverflow;
 290         if (!horizontalLayoutOverflowChanged &amp;&amp; !verticalLayoutOverflowChanged)
 291             return;
 292 
 293         Ref&lt;OverflowEvent&gt; overflowEvent = OverflowEvent::create(horizontalLayoutOverflowChanged, hasHorizontalLayoutOverflow, verticalLayoutOverflowChanged, hasVerticalLayoutOverflow);
 294         overflowEvent-&gt;setTarget(m_block-&gt;element());
 295         m_block-&gt;document().enqueueOverflowEvent(WTFMove(overflowEvent));
 296     }
 297 
 298 private:
 299     const RenderBlock* m_block;
 300     bool m_shouldDispatchEvent;
 301     bool m_hadHorizontalLayoutOverflow;
 302     bool m_hadVerticalLayoutOverflow;
 303 };
 304 
 305 RenderBlock::RenderBlock(Element&amp; element, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 306     : RenderBox(element, WTFMove(style), baseTypeFlags | RenderBlockFlag)
 307 {
 308 }
 309 
 310 RenderBlock::RenderBlock(Document&amp; document, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 311     : RenderBox(document, WTFMove(style), baseTypeFlags | RenderBlockFlag)
 312 {
 313 }
 314 
 315 static void removeBlockFromPercentageDescendantAndContainerMaps(RenderBlock* block)
 316 {
 317     if (!percentHeightDescendantsMap)
 318         return;
 319     std::unique_ptr&lt;TrackedRendererListHashSet&gt; descendantSet = percentHeightDescendantsMap-&gt;take(block);
 320     if (!descendantSet)
 321         return;
 322 
 323     for (auto* descendant : *descendantSet) {
 324         auto it = percentHeightContainerMap-&gt;find(descendant);
 325         ASSERT(it != percentHeightContainerMap-&gt;end());
 326         if (it == percentHeightContainerMap-&gt;end())
 327             continue;
 328         auto* containerSet = it-&gt;value.get();
 329         ASSERT(containerSet-&gt;contains(block));
 330         containerSet-&gt;remove(block);
 331         if (containerSet-&gt;isEmpty())
 332             percentHeightContainerMap-&gt;remove(it);
 333     }
 334 }
 335 
 336 RenderBlock::~RenderBlock()
 337 {
 338     // Blocks can be added to gRareDataMap during willBeDestroyed(), so this code can&#39;t move there.
 339     if (gRareDataMap)
 340         gRareDataMap-&gt;remove(this);
 341 
 342     // Do not add any more code here. Add it to willBeDestroyed() instead.
 343 }
 344 
 345 // Note that this is not called for RenderBlockFlows.
 346 void RenderBlock::willBeDestroyed()
 347 {
 348     if (!renderTreeBeingDestroyed()) {
 349         if (parent())
 350             parent()-&gt;dirtyLinesFromChangedChild(*this);
 351     }
 352 
 353     blockWillBeDestroyed();
 354 
 355     RenderBox::willBeDestroyed();
 356 }
 357 
 358 void RenderBlock::blockWillBeDestroyed()
 359 {
 360     removeFromUpdateScrollInfoAfterLayoutTransaction();
 361 
 362     removeBlockFromPercentageDescendantAndContainerMaps(this);
 363     positionedDescendantsMap().removeContainingBlock(*this);
 364 }
 365 
 366 bool RenderBlock::hasRareData() const
 367 {
 368     return gRareDataMap ? gRareDataMap-&gt;contains(this) : false;
 369 }
 370 
 371 void RenderBlock::removePositionedObjectsIfNeeded(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
 372 {
 373     bool hadTransform = oldStyle.hasTransformRelatedProperty();
 374     bool willHaveTransform = newStyle.hasTransformRelatedProperty();
 375     if (oldStyle.position() == newStyle.position() &amp;&amp; hadTransform == willHaveTransform)
 376         return;
 377 
 378     // We are no longer the containing block for fixed descendants.
 379     if (hadTransform &amp;&amp; !willHaveTransform) {
 380         // Our positioned descendants will be inserted into a new containing block&#39;s positioned objects list during the next layout.
 381         removePositionedObjects(nullptr, NewContainingBlock);
 382         return;
 383     }
 384 
 385     // We are no longer the containing block for absolute positioned descendants.
 386     if (newStyle.position() == PositionType::Static &amp;&amp; !willHaveTransform) {
 387         // Our positioned descendants will be inserted into a new containing block&#39;s positioned objects list during the next layout.
 388         removePositionedObjects(nullptr, NewContainingBlock);
 389         return;
 390     }
 391 
 392     // We are a new containing block.
 393     if (oldStyle.position() == PositionType::Static &amp;&amp; !hadTransform) {
 394         // Remove our absolutely positioned descendants from their current containing block.
 395         // They will be inserted into our positioned objects list during layout.
 396         auto* containingBlock = parent();
 397         while (containingBlock &amp;&amp; !is&lt;RenderView&gt;(*containingBlock)
 398             &amp;&amp; (containingBlock-&gt;style().position() == PositionType::Static || (containingBlock-&gt;isInline() &amp;&amp; !containingBlock-&gt;isReplaced()))) {
 399             if (containingBlock-&gt;style().position() == PositionType::Relative &amp;&amp; containingBlock-&gt;isInline() &amp;&amp; !containingBlock-&gt;isReplaced()) {
 400                 containingBlock = containingBlock-&gt;containingBlock();
 401                 break;
 402             }
 403             containingBlock = containingBlock-&gt;parent();
 404         }
 405         if (containingBlock &amp;&amp; is&lt;RenderBlock&gt;(*containingBlock))
 406             downcast&lt;RenderBlock&gt;(*containingBlock).removePositionedObjects(this, NewContainingBlock);
 407     }
 408 }
 409 
 410 void RenderBlock::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
 411 {
 412     const RenderStyle* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
 413     setReplaced(newStyle.isDisplayInlineType());
 414     if (oldStyle)
 415         removePositionedObjectsIfNeeded(*oldStyle, newStyle);
 416     RenderBox::styleWillChange(diff, newStyle);
 417 }
 418 
 419 static bool borderOrPaddingLogicalWidthChanged(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
 420 {
 421     if (newStyle.isHorizontalWritingMode()) {
 422         return oldStyle.borderLeftWidth() != newStyle.borderLeftWidth()
 423             || oldStyle.borderRightWidth() != newStyle.borderRightWidth()
 424             || oldStyle.paddingLeft() != newStyle.paddingLeft()
 425             || oldStyle.paddingRight() != newStyle.paddingRight();
 426     }
 427 
 428     return oldStyle.borderTopWidth() != newStyle.borderTopWidth()
 429         || oldStyle.borderBottomWidth() != newStyle.borderBottomWidth()
 430         || oldStyle.paddingTop() != newStyle.paddingTop()
 431         || oldStyle.paddingBottom() != newStyle.paddingBottom();
 432 }
 433 
 434 void RenderBlock::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
 435 {
 436     bool hadTransform = hasTransform();
 437     RenderBox::styleDidChange(diff, oldStyle);
 438 
 439     if (hadTransform != hasTransform())
 440         adjustFragmentedFlowStateOnContainingBlockChangeIfNeeded();
 441 
 442     propagateStyleToAnonymousChildren(PropagateToBlockChildrenOnly);
 443 
 444     // It&#39;s possible for our border/padding to change, but for the overall logical width of the block to
 445     // end up being the same. We keep track of this change so in layoutBlock, we can know to set relayoutChildren=true.
 446     setShouldForceRelayoutChildren(oldStyle &amp;&amp; diff == StyleDifference::Layout &amp;&amp; needsLayout() &amp;&amp; borderOrPaddingLogicalWidthChanged(*oldStyle, style()));
 447 }
 448 
 449 RenderPtr&lt;RenderBlock&gt; RenderBlock::clone() const
 450 {
 451     RenderPtr&lt;RenderBlock&gt; cloneBlock;
 452     if (isAnonymousBlock()) {
 453         cloneBlock = RenderPtr&lt;RenderBlock&gt;(createAnonymousBlock());
 454         cloneBlock-&gt;setChildrenInline(childrenInline());
 455     } else {
 456         RenderTreePosition insertionPosition(*parent());
 457         cloneBlock = static_pointer_cast&lt;RenderBlock&gt;(element()-&gt;createElementRenderer(RenderStyle::clone(style()), insertionPosition));
 458         cloneBlock-&gt;initializeStyle();
 459 
 460         // This takes care of setting the right value of childrenInline in case
 461         // generated content is added to cloneBlock and &#39;this&#39; does not have
 462         // generated content added yet.
 463         cloneBlock-&gt;setChildrenInline(cloneBlock-&gt;firstChild() ? cloneBlock-&gt;firstChild()-&gt;isInline() : childrenInline());
 464     }
 465     cloneBlock-&gt;setFragmentedFlowState(fragmentedFlowState());
 466     return cloneBlock;
 467 }
 468 
 469 void RenderBlock::deleteLines()
 470 {
 471     if (AXObjectCache* cache = document().existingAXObjectCache())
 472         cache-&gt;deferRecomputeIsIgnored(element());
 473 }
 474 
 475 bool RenderBlock::childrenPreventSelfCollapsing() const
 476 {
 477     // Whether or not we collapse is dependent on whether all our normal flow children
 478     // are also self-collapsing.
 479     for (RenderBox* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 480         if (child-&gt;isFloatingOrOutOfFlowPositioned())
 481             continue;
 482         if (!child-&gt;isSelfCollapsingBlock())
 483             return true;
 484     }
 485     return false;
 486 }
 487 
 488 bool RenderBlock::isSelfCollapsingBlock() const
 489 {
 490     // We are not self-collapsing if we
 491     // (a) have a non-zero height according to layout (an optimization to avoid wasting time)
 492     // (b) are a table,
 493     // (c) have border/padding,
 494     // (d) have a min-height
 495     // (e) have specified that one of our margins can&#39;t collapse using a CSS extension
 496     if (logicalHeight() &gt; 0
 497         || isTable() || borderAndPaddingLogicalHeight()
 498         || style().logicalMinHeight().isPositive()
 499         || style().marginBeforeCollapse() == MarginCollapse::Separate || style().marginAfterCollapse() == MarginCollapse::Separate)
 500         return false;
 501 
 502     Length logicalHeightLength = style().logicalHeight();
 503     bool hasAutoHeight = logicalHeightLength.isAuto();
 504     if (logicalHeightLength.isPercentOrCalculated() &amp;&amp; !document().inQuirksMode()) {
 505         hasAutoHeight = true;
 506         for (RenderBlock* cb = containingBlock(); cb &amp;&amp; !is&lt;RenderView&gt;(*cb); cb = cb-&gt;containingBlock()) {
 507             if (cb-&gt;style().logicalHeight().isFixed() || cb-&gt;isTableCell())
 508                 hasAutoHeight = false;
 509         }
 510     }
 511 
 512     // If the height is 0 or auto, then whether or not we are a self-collapsing block depends
 513     // on whether we have content that is all self-collapsing or not.
 514     if (hasAutoHeight || ((logicalHeightLength.isFixed() || logicalHeightLength.isPercentOrCalculated()) &amp;&amp; logicalHeightLength.isZero()))
 515         return !childrenPreventSelfCollapsing();
 516 
 517     return false;
 518 }
 519 
 520 static inline UpdateScrollInfoAfterLayoutTransaction* currentUpdateScrollInfoAfterLayoutTransaction()
 521 {
 522     if (!updateScrollInfoAfterLayoutTransactionStack())
 523         return nullptr;
 524     return &amp;updateScrollInfoAfterLayoutTransactionStack()-&gt;last();
 525 }
 526 
 527 void RenderBlock::beginUpdateScrollInfoAfterLayoutTransaction()
 528 {
 529     if (!updateScrollInfoAfterLayoutTransactionStack())
 530         updateScrollInfoAfterLayoutTransactionStack() = std::make_unique&lt;DelayedUpdateScrollInfoStack&gt;();
 531     if (updateScrollInfoAfterLayoutTransactionStack()-&gt;isEmpty() || currentUpdateScrollInfoAfterLayoutTransaction()-&gt;view != &amp;view())
 532         updateScrollInfoAfterLayoutTransactionStack()-&gt;append(UpdateScrollInfoAfterLayoutTransaction(view()));
 533     ++currentUpdateScrollInfoAfterLayoutTransaction()-&gt;nestedCount;
 534 }
 535 
 536 void RenderBlock::endAndCommitUpdateScrollInfoAfterLayoutTransaction()
 537 {
 538     UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 539     ASSERT(transaction);
 540     ASSERT(transaction-&gt;view == &amp;view());
 541     if (--transaction-&gt;nestedCount)
 542         return;
 543 
 544     // Calling RenderLayer::updateScrollInfoAfterLayout() may cause its associated block to layout again and
 545     // updates its scroll info (i.e. call RenderBlock::updateScrollInfoAfterLayout()). We remove |transaction|
 546     // from the transaction stack to ensure that all subsequent calls to RenderBlock::updateScrollInfoAfterLayout()
 547     // are dispatched immediately. That is, to ensure that such subsequent calls aren&#39;t added to |transaction|
 548     // while we are processing it.
 549     auto blocksToUpdate = copyToVector(transaction-&gt;blocks);
 550     updateScrollInfoAfterLayoutTransactionStack()-&gt;removeLast();
 551     if (updateScrollInfoAfterLayoutTransactionStack()-&gt;isEmpty())
 552         updateScrollInfoAfterLayoutTransactionStack() = nullptr;
 553 
 554     for (auto* block : blocksToUpdate) {
 555         ASSERT(block-&gt;hasOverflowClip());
 556         block-&gt;layer()-&gt;updateScrollInfoAfterLayout();
 557         block-&gt;clearLayoutOverflow();
 558     }
 559 }
 560 
 561 void RenderBlock::removeFromUpdateScrollInfoAfterLayoutTransaction()
 562 {
 563     if (UNLIKELY(updateScrollInfoAfterLayoutTransactionStack().get() != 0)) {
 564         UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 565         ASSERT(transaction);
 566         if (transaction-&gt;view == &amp;view())
 567             transaction-&gt;blocks.remove(this);
 568     }
 569 }
 570 
 571 void RenderBlock::updateScrollInfoAfterLayout()
 572 {
 573     if (!hasOverflowClip())
 574         return;
 575 
 576     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=97937
 577     // Workaround for now. We cannot delay the scroll info for overflow
 578     // for items with opposite writing directions, as the contents needs
 579     // to overflow in that direction
 580     if (!style().isFlippedBlocksWritingMode()) {
 581         UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 582         if (transaction &amp;&amp; transaction-&gt;view == &amp;view()) {
 583             transaction-&gt;blocks.add(this);
 584             return;
 585         }
 586     }
 587     if (layer())
 588         layer()-&gt;updateScrollInfoAfterLayout();
 589 }
 590 
 591 void RenderBlock::layout()
 592 {
 593     StackStats::LayoutCheckPoint layoutCheckPoint;
 594     OverflowEventDispatcher dispatcher(this);
 595 
 596     // Table cells call layoutBlock directly, so don&#39;t add any logic here.  Put code into
 597     // layoutBlock().
 598     layoutBlock(false);
 599 
 600     // It&#39;s safe to check for control clip here, since controls can never be table cells.
 601     // If we have a lightweight clip, there can never be any overflow from children.
 602     UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 603     bool isDelayingUpdateScrollInfoAfterLayoutInView = transaction &amp;&amp; transaction-&gt;view == &amp;view();
 604     if (hasControlClip() &amp;&amp; m_overflow &amp;&amp; !isDelayingUpdateScrollInfoAfterLayoutInView)
 605         clearLayoutOverflow();
 606 
 607     invalidateBackgroundObscurationStatus();
 608 }
 609 
 610 static RenderBlockRareData* getBlockRareData(const RenderBlock&amp; block)
 611 {
 612     return gRareDataMap ? gRareDataMap-&gt;get(&amp;block) : nullptr;
 613 }
 614 
 615 static RenderBlockRareData&amp; ensureBlockRareData(const RenderBlock&amp; block)
 616 {
 617     if (!gRareDataMap)
 618         gRareDataMap = new RenderBlockRareDataMap;
 619 
 620     auto&amp; rareData = gRareDataMap-&gt;add(&amp;block, nullptr).iterator-&gt;value;
 621     if (!rareData)
 622         rareData = std::make_unique&lt;RenderBlockRareData&gt;();
 623     return *rareData.get();
 624 }
 625 
 626 void RenderBlock::preparePaginationBeforeBlockLayout(bool&amp; relayoutChildren)
 627 {
 628     // Fragments changing widths can force us to relayout our children.
 629     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 630     if (fragmentedFlow)
 631         fragmentedFlow-&gt;logicalWidthChangedInFragmentsForBlock(this, relayoutChildren);
 632 }
 633 
 634 bool RenderBlock::recomputeLogicalWidth()
 635 {
 636     LayoutUnit oldWidth = logicalWidth();
 637 
 638     updateLogicalWidth();
 639 
 640     bool hasBorderOrPaddingLogicalWidthChanged = this-&gt;hasBorderOrPaddingLogicalWidthChanged();
 641     setShouldForceRelayoutChildren(false);
 642 
 643     return oldWidth != logicalWidth() || hasBorderOrPaddingLogicalWidthChanged;
 644 }
 645 
 646 void RenderBlock::layoutBlock(bool, LayoutUnit)
 647 {
 648     ASSERT_NOT_REACHED();
 649     clearNeedsLayout();
 650 }
 651 
 652 void RenderBlock::addOverflowFromChildren()
 653 {
 654     if (childrenInline())
 655         addOverflowFromInlineChildren();
 656     else
 657         addOverflowFromBlockChildren();
 658 
 659     // If this block is flowed inside a flow thread, make sure its overflow is propagated to the containing fragments.
 660     if (m_overflow) {
 661         if (RenderFragmentedFlow* containingFragmentedFlow = enclosingFragmentedFlow())
 662             containingFragmentedFlow-&gt;addFragmentsVisualOverflow(this, m_overflow-&gt;visualOverflowRect());
 663     }
 664 }
 665 
 666 // Overflow is always relative to the border-box of the element in question.
 667 // Therefore, if the element has a vertical scrollbar placed on the left, an overflow rect at x=2px would conceptually intersect the scrollbar.
 668 void RenderBlock::computeOverflow(LayoutUnit oldClientAfterEdge, bool)
 669 {
 670     clearOverflow();
 671     addOverflowFromChildren();
 672 
 673     addOverflowFromPositionedObjects();
 674 
 675     if (hasOverflowClip()) {
 676         // When we have overflow clip, propagate the original spillout since it will include collapsed bottom margins
 677         // and bottom padding.  Set the axis we don&#39;t care about to be 1, since we want this overflow to always
 678         // be considered reachable.
 679         LayoutRect clientRect(flippedClientBoxRect());
 680         LayoutRect rectToApply;
 681         if (isHorizontalWritingMode())
 682             rectToApply = LayoutRect(clientRect.x(), clientRect.y(), 1_lu, std::max(0_lu, oldClientAfterEdge - clientRect.y()));
 683         else
 684             rectToApply = LayoutRect(clientRect.x(), clientRect.y(), std::max(0_lu, oldClientAfterEdge - clientRect.x()), 1_lu);
 685         addLayoutOverflow(rectToApply);
 686         if (hasRenderOverflow())
 687             m_overflow-&gt;setLayoutClientAfterEdge(oldClientAfterEdge);
 688     }
 689 
 690     // Add visual overflow from box-shadow, border-image-outset and outline.
 691     addVisualEffectOverflow();
 692 
 693     // Add visual overflow from theme.
 694     addVisualOverflowFromTheme();
 695 }
 696 
 697 void RenderBlock::clearLayoutOverflow()
 698 {
 699     if (!m_overflow)
 700         return;
 701 
 702     if (visualOverflowRect() == borderBoxRect()) {
 703         // FIXME: Implement complete solution for fragments overflow.
 704         clearOverflow();
 705         return;
 706     }
 707 
 708     m_overflow-&gt;setLayoutOverflow(borderBoxRect());
 709 }
 710 
 711 void RenderBlock::addOverflowFromBlockChildren()
 712 {
 713     for (auto* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 714         if (!child-&gt;isFloatingOrOutOfFlowPositioned())
 715             addOverflowFromChild(child);
 716     }
 717 }
 718 
 719 void RenderBlock::addOverflowFromPositionedObjects()
 720 {
 721     TrackedRendererListHashSet* positionedDescendants = positionedObjects();
 722     if (!positionedDescendants)
 723         return;
 724 
 725     for (auto it = positionedDescendants-&gt;begin(), end = positionedDescendants-&gt;end(); it != end; ++it) {
 726         RenderBox* positionedObject = *it;
 727 
 728         // Fixed positioned elements don&#39;t contribute to layout overflow, since they don&#39;t scroll with the content.
 729         if (positionedObject-&gt;style().position() != PositionType::Fixed)
 730             addOverflowFromChild(positionedObject, { positionedObject-&gt;x(), positionedObject-&gt;y() });
 731     }
 732 }
 733 
 734 void RenderBlock::addVisualOverflowFromTheme()
 735 {
 736     if (!style().hasAppearance())
 737         return;
 738 
 739     FloatRect inflatedRect = borderBoxRect();
 740     theme().adjustRepaintRect(*this, inflatedRect);
 741     addVisualOverflow(snappedIntRect(LayoutRect(inflatedRect)));
 742 
 743     if (RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow())
 744         fragmentedFlow-&gt;addFragmentsVisualOverflowFromTheme(this);
 745 }
 746 
 747 LayoutUnit RenderBlock::computeStartPositionDeltaForChildAvoidingFloats(const RenderBox&amp; child, LayoutUnit childMarginStart, RenderFragmentContainer* fragment)
 748 {
 749     LayoutUnit startPosition = startOffsetForContent(fragment);
 750 
 751     // Add in our start margin.
 752     LayoutUnit oldPosition = startPosition + childMarginStart;
 753     LayoutUnit newPosition = oldPosition;
 754 
 755     LayoutUnit blockOffset = logicalTopForChild(child);
 756     if (fragment)
 757         blockOffset = std::max(blockOffset, blockOffset + (fragment-&gt;logicalTopForFragmentedFlowContent() - offsetFromLogicalTopOfFirstPage()));
 758 
 759     LayoutUnit startOff = startOffsetForLineInFragment(blockOffset, DoNotIndentText, fragment, logicalHeightForChild(child));
 760 
 761     if (style().textAlign() != TextAlignMode::WebKitCenter &amp;&amp; !child.style().marginStartUsing(&amp;style()).isAuto()) {
 762         if (childMarginStart &lt; 0)
 763             startOff += childMarginStart;
 764         newPosition = std::max(newPosition, startOff); // Let the float sit in the child&#39;s margin if it can fit.
 765     } else if (startOff != startPosition)
 766         newPosition = startOff + childMarginStart;
 767 
 768     return newPosition - oldPosition;
 769 }
 770 
 771 void RenderBlock::setLogicalLeftForChild(RenderBox&amp; child, LayoutUnit logicalLeft, ApplyLayoutDeltaMode applyDelta)
 772 {
 773     if (isHorizontalWritingMode()) {
 774         if (applyDelta == ApplyLayoutDelta)
 775             view().frameView().layoutContext().addLayoutDelta(LayoutSize(child.x() - logicalLeft, 0_lu));
 776         child.setX(logicalLeft);
 777     } else {
 778         if (applyDelta == ApplyLayoutDelta)
 779             view().frameView().layoutContext().addLayoutDelta(LayoutSize(0_lu, child.y() - logicalLeft));
 780         child.setY(logicalLeft);
 781     }
 782 }
 783 
 784 void RenderBlock::setLogicalTopForChild(RenderBox&amp; child, LayoutUnit logicalTop, ApplyLayoutDeltaMode applyDelta)
 785 {
 786     if (isHorizontalWritingMode()) {
 787         if (applyDelta == ApplyLayoutDelta)
 788             view().frameView().layoutContext().addLayoutDelta(LayoutSize(0_lu, child.y() - logicalTop));
 789         child.setY(logicalTop);
 790     } else {
 791         if (applyDelta == ApplyLayoutDelta)
 792             view().frameView().layoutContext().addLayoutDelta(LayoutSize(child.x() - logicalTop, 0_lu));
 793         child.setX(logicalTop);
 794     }
 795 }
 796 
 797 void RenderBlock::updateBlockChildDirtyBitsBeforeLayout(bool relayoutChildren, RenderBox&amp; child)
 798 {
 799     if (child.isOutOfFlowPositioned())
 800         return;
 801 
 802     // FIXME: Technically percentage height objects only need a relayout if their percentage isn&#39;t going to be turned into
 803     // an auto value. Add a method to determine this, so that we can avoid the relayout.
 804     if (relayoutChildren || (child.hasRelativeLogicalHeight() &amp;&amp; !isRenderView()))
 805         child.setChildNeedsLayout(MarkOnlyThis);
 806 
 807     // If relayoutChildren is set and the child has percentage padding or an embedded content box, we also need to invalidate the childs pref widths.
 808     if (relayoutChildren &amp;&amp; child.needsPreferredWidthsRecalculation())
 809         child.setPreferredLogicalWidthsDirty(true, MarkOnlyThis);
 810 }
 811 
 812 void RenderBlock::dirtyForLayoutFromPercentageHeightDescendants()
 813 {
 814     if (!percentHeightDescendantsMap)
 815         return;
 816 
 817     TrackedRendererListHashSet* descendants = percentHeightDescendantsMap-&gt;get(this);
 818     if (!descendants)
 819         return;
 820 
 821     for (auto it = descendants-&gt;begin(), end = descendants-&gt;end(); it != end; ++it) {
 822         auto* box = *it;
 823         while (box != this) {
 824             if (box-&gt;normalChildNeedsLayout())
 825                 break;
 826             box-&gt;setChildNeedsLayout(MarkOnlyThis);
 827 
 828             // If the width of an image is affected by the height of a child (e.g., an image with an aspect ratio),
 829             // then we have to dirty preferred widths, since even enclosing blocks can become dirty as a result.
 830             // (A horizontal flexbox that contains an inline image wrapped in an anonymous block for example.)
 831             if (box-&gt;hasAspectRatio())
 832                 box-&gt;setPreferredLogicalWidthsDirty(true);
 833             auto* containingBlock = box-&gt;containingBlock();
 834             // Mark the svg ancestor chain dirty as we walk to the containing block. containingBlock() just skips them. See webkit.org/b/183874.
 835             if (is&lt;SVGElement&gt;(box-&gt;element()) &amp;&amp; containingBlock != box-&gt;parent()) {
 836                 auto* ancestor = box-&gt;parent();
 837                 ASSERT(ancestor-&gt;isDescendantOf(containingBlock));
 838                 while (ancestor != containingBlock) {
 839                     ancestor-&gt;setChildNeedsLayout(MarkOnlyThis);
 840                     // This is the topmost SVG root, no need to go any further.
 841                     if (is&lt;SVGSVGElement&gt;(ancestor-&gt;element()) &amp;&amp; !downcast&lt;SVGSVGElement&gt;(*ancestor-&gt;element()).ownerSVGElement())
 842                         break;
 843                     ancestor = ancestor-&gt;parent();
 844                 }
 845             }
 846             box = containingBlock;
 847             ASSERT(box);
 848             if (!box)
 849                 break;
 850         }
 851     }
 852 }
 853 
 854 void RenderBlock::simplifiedNormalFlowLayout()
 855 {
 856     if (childrenInline()) {
 857         ListHashSet&lt;RootInlineBox*&gt; lineBoxes;
 858         for (InlineWalker walker(*this); !walker.atEnd(); walker.advance()) {
 859             RenderObject&amp; renderer = *walker.current();
 860             if (!renderer.isOutOfFlowPositioned() &amp;&amp; (renderer.isReplaced() || renderer.isFloating())) {
 861                 RenderBox&amp; box = downcast&lt;RenderBox&gt;(renderer);
 862                 box.layoutIfNeeded();
 863                 if (box.inlineBoxWrapper())
 864                     lineBoxes.add(&amp;box.inlineBoxWrapper()-&gt;root());
 865             } else if (is&lt;RenderText&gt;(renderer) || (is&lt;RenderInline&gt;(renderer) &amp;&amp; !walker.atEndOfInline()))
 866                 renderer.clearNeedsLayout();
 867         }
 868 
 869         // FIXME: Glyph overflow will get lost in this case, but not really a big deal.
 870         // FIXME: Find a way to invalidate the knownToHaveNoOverflow flag on the InlineBoxes.
 871         GlyphOverflowAndFallbackFontsMap textBoxDataMap;
 872         for (auto it = lineBoxes.begin(), end = lineBoxes.end(); it != end; ++it) {
 873             RootInlineBox* box = *it;
 874             box-&gt;computeOverflow(box-&gt;lineTop(), box-&gt;lineBottom(), textBoxDataMap);
 875         }
 876     } else {
 877         for (auto* box = firstChildBox(); box; box = box-&gt;nextSiblingBox()) {
 878             if (!box-&gt;isOutOfFlowPositioned())
 879                 box-&gt;layoutIfNeeded();
 880         }
 881     }
 882 }
 883 
 884 bool RenderBlock::canPerformSimplifiedLayout() const
 885 {
 886     return (posChildNeedsLayout() || needsSimplifiedNormalFlowLayout()) &amp;&amp; !normalChildNeedsLayout() &amp;&amp; !selfNeedsLayout();
 887 }
 888 
 889 bool RenderBlock::simplifiedLayout()
 890 {
 891     if (!canPerformSimplifiedLayout())
 892         return false;
 893 
 894     LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
 895     if (needsPositionedMovementLayout() &amp;&amp; !tryLayoutDoingPositionedMovementOnly())
 896         return false;
 897 
 898     // Lay out positioned descendants or objects that just need to recompute overflow.
 899     if (needsSimplifiedNormalFlowLayout())
 900         simplifiedNormalFlowLayout();
 901 
 902     // Make sure a forced break is applied after the content if we are a flow thread in a simplified layout.
 903     // This ensures the size information is correctly computed for the last auto-height fragment receiving content.
 904     if (is&lt;RenderFragmentedFlow&gt;(*this))
 905         downcast&lt;RenderFragmentedFlow&gt;(*this).applyBreakAfterContent(clientLogicalBottom());
 906 
 907     // Lay out our positioned objects if our positioned child bit is set.
 908     // Also, if an absolute position element inside a relative positioned container moves, and the absolute element has a fixed position
 909     // child, neither the fixed element nor its container learn of the movement since posChildNeedsLayout() is only marked as far as the
 910     // relative positioned container. So if we can have fixed pos objects in our positioned objects list check if any of them
 911     // are statically positioned and thus need to move with their absolute ancestors.
 912     bool canContainFixedPosObjects = canContainFixedPositionObjects();
 913     if (posChildNeedsLayout() || canContainFixedPosObjects)
 914         layoutPositionedObjects(false, !posChildNeedsLayout() &amp;&amp; canContainFixedPosObjects);
 915 
 916     // Recompute our overflow information.
 917     // FIXME: We could do better here by computing a temporary overflow object from layoutPositionedObjects and only
 918     // updating our overflow if we either used to have overflow or if the new temporary object has overflow.
 919     // For now just always recompute overflow.  This is no worse performance-wise than the old code that called rightmostPosition and
 920     // lowestPosition on every relayout so it&#39;s not a regression.
 921     // computeOverflow expects the bottom edge before we clamp our height. Since this information isn&#39;t available during
 922     // simplifiedLayout, we cache the value in m_overflow.
 923     LayoutUnit oldClientAfterEdge = hasRenderOverflow() ? m_overflow-&gt;layoutClientAfterEdge() : clientLogicalBottom();
 924     computeOverflow(oldClientAfterEdge, true);
 925 
 926     updateLayerTransform();
 927 
 928     updateScrollInfoAfterLayout();
 929 
 930     clearNeedsLayout();
 931     return true;
 932 }
 933 
 934 void RenderBlock::markFixedPositionObjectForLayoutIfNeeded(RenderBox&amp; positionedChild)
 935 {
 936     if (positionedChild.style().position() != PositionType::Fixed)
 937         return;
 938 
 939     bool hasStaticBlockPosition = positionedChild.style().hasStaticBlockPosition(isHorizontalWritingMode());
 940     bool hasStaticInlinePosition = positionedChild.style().hasStaticInlinePosition(isHorizontalWritingMode());
 941     if (!hasStaticBlockPosition &amp;&amp; !hasStaticInlinePosition)
 942         return;
 943 
 944     auto* parent = positionedChild.parent();
 945     while (parent &amp;&amp; !is&lt;RenderView&gt;(*parent) &amp;&amp; parent-&gt;style().position() != PositionType::Absolute)
 946         parent = parent-&gt;parent();
 947     if (!parent || parent-&gt;style().position() != PositionType::Absolute)
 948         return;
 949 
 950     if (hasStaticInlinePosition) {
 951         LogicalExtentComputedValues computedValues;
 952         positionedChild.computeLogicalWidthInFragment(computedValues);
 953         LayoutUnit newLeft = computedValues.m_position;
 954         if (newLeft != positionedChild.logicalLeft())
 955             positionedChild.setChildNeedsLayout(MarkOnlyThis);
 956     } else if (hasStaticBlockPosition) {
 957         LayoutUnit oldTop = positionedChild.logicalTop();
 958         positionedChild.updateLogicalHeight();
 959         if (positionedChild.logicalTop() != oldTop)
 960             positionedChild.setChildNeedsLayout(MarkOnlyThis);
 961     }
 962 }
 963 
 964 LayoutUnit RenderBlock::marginIntrinsicLogicalWidthForChild(RenderBox&amp; child) const
 965 {
 966     // A margin has three types: fixed, percentage, and auto (variable).
 967     // Auto and percentage margins become 0 when computing min/max width.
 968     // Fixed margins can be added in as is.
 969     Length marginLeft = child.style().marginStartUsing(&amp;style());
 970     Length marginRight = child.style().marginEndUsing(&amp;style());
 971     LayoutUnit margin;
 972     if (marginLeft.isFixed())
 973         margin += marginLeft.value();
 974     if (marginRight.isFixed())
 975         margin += marginRight.value();
 976     return margin;
 977 }
 978 
 979 void RenderBlock::layoutPositionedObject(RenderBox&amp; r, bool relayoutChildren, bool fixedPositionObjectsOnly)
 980 {
 981     estimateFragmentRangeForBoxChild(r);
 982 
 983     // A fixed position element with an absolute positioned ancestor has no way of knowing if the latter has changed position. So
 984     // if this is a fixed position element, mark it for layout if it has an abspos ancestor and needs to move with that ancestor, i.e.
 985     // it has static position.
 986     markFixedPositionObjectForLayoutIfNeeded(r);
 987     if (fixedPositionObjectsOnly) {
 988         r.layoutIfNeeded();
 989         return;
 990     }
 991 
 992     // When a non-positioned block element moves, it may have positioned children that are implicitly positioned relative to the
 993     // non-positioned block.  Rather than trying to detect all of these movement cases, we just always lay out positioned
 994     // objects that are positioned implicitly like this.  Such objects are rare, and so in typical DHTML menu usage (where everything is
 995     // positioned explicitly) this should not incur a performance penalty.
 996     if (relayoutChildren || (r.style().hasStaticBlockPosition(isHorizontalWritingMode()) &amp;&amp; r.parent() != this))
 997         r.setChildNeedsLayout(MarkOnlyThis);
 998 
 999     // If relayoutChildren is set and the child has percentage padding or an embedded content box, we also need to invalidate the childs pref widths.
1000     if (relayoutChildren &amp;&amp; r.needsPreferredWidthsRecalculation())
1001         r.setPreferredLogicalWidthsDirty(true, MarkOnlyThis);
1002 
1003     r.markForPaginationRelayoutIfNeeded();
1004 
1005     // We don&#39;t have to do a full layout.  We just have to update our position. Try that first. If we have shrink-to-fit width
1006     // and we hit the available width constraint, the layoutIfNeeded() will catch it and do a full layout.
1007     if (r.needsPositionedMovementLayoutOnly() &amp;&amp; r.tryLayoutDoingPositionedMovementOnly())
1008         r.clearNeedsLayout();
1009 
1010     // If we are paginated or in a line grid, compute a vertical position for our object now.
1011     // If it&#39;s wrong we&#39;ll lay out again.
1012     LayoutUnit oldLogicalTop;
1013     bool needsBlockDirectionLocationSetBeforeLayout = r.needsLayout() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;needsBlockDirectionLocationSetBeforeLayout();
1014     if (needsBlockDirectionLocationSetBeforeLayout) {
1015         if (isHorizontalWritingMode() == r.isHorizontalWritingMode())
1016             r.updateLogicalHeight();
1017         else
1018             r.updateLogicalWidth();
1019         oldLogicalTop = logicalTopForChild(r);
1020     }
1021 
1022     r.layoutIfNeeded();
1023 
1024     auto* parent = r.parent();
1025     bool layoutChanged = false;
1026     if (parent-&gt;isFlexibleBox() &amp;&amp; downcast&lt;RenderFlexibleBox&gt;(parent)-&gt;setStaticPositionForPositionedLayout(r)) {
1027         // The static position of an abspos child of a flexbox depends on its size
1028         // (for example, they can be centered). So we may have to reposition the
1029         // item after layout.
1030         // FIXME: We could probably avoid a layout here and just reposition?
1031         layoutChanged = true;
1032     }
1033 
1034     // Lay out again if our estimate was wrong.
1035     if (layoutChanged || (needsBlockDirectionLocationSetBeforeLayout &amp;&amp; logicalTopForChild(r) != oldLogicalTop)) {
1036         r.setChildNeedsLayout(MarkOnlyThis);
1037         r.layoutIfNeeded();
1038     }
1039 
1040     if (updateFragmentRangeForBoxChild(r)) {
1041         r.setNeedsLayout(MarkOnlyThis);
1042         r.layoutIfNeeded();
1043     }
1044 }
1045 
1046 void RenderBlock::layoutPositionedObjects(bool relayoutChildren, bool fixedPositionObjectsOnly)
1047 {
1048     TrackedRendererListHashSet* positionedDescendants = positionedObjects();
1049     if (!positionedDescendants)
1050         return;
1051 
1052     // Do not cache positionedDescendants-&gt;end() in a local variable, since |positionedDescendants| can be mutated
1053     // as it is walked. We always need to fetch the new end() value dynamically.
1054     for (auto it = positionedDescendants-&gt;begin(); it != positionedDescendants-&gt;end(); ++it)
1055         layoutPositionedObject(**it, relayoutChildren, fixedPositionObjectsOnly);
1056 }
1057 
1058 void RenderBlock::markPositionedObjectsForLayout()
1059 {
1060     TrackedRendererListHashSet* positionedDescendants = positionedObjects();
1061     if (!positionedDescendants)
1062         return;
1063 
1064     for (auto it = positionedDescendants-&gt;begin(), end = positionedDescendants-&gt;end(); it != end; ++it) {
1065         RenderBox* r = *it;
1066         r-&gt;setChildNeedsLayout();
1067     }
1068 }
1069 
1070 void RenderBlock::markForPaginationRelayoutIfNeeded()
1071 {
1072     auto* layoutState = view().frameView().layoutContext().layoutState();
1073     if (needsLayout() || !layoutState-&gt;isPaginated())
1074         return;
1075 
1076     if (layoutState-&gt;pageLogicalHeightChanged() || (layoutState-&gt;pageLogicalHeight() &amp;&amp; layoutState-&gt;pageLogicalOffset(this, logicalTop()) != pageLogicalOffset()))
1077         setChildNeedsLayout(MarkOnlyThis);
1078 }
1079 
1080 void RenderBlock::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1081 {
1082     LayoutPoint adjustedPaintOffset = paintOffset + location();
1083     PaintPhase phase = paintInfo.phase;
1084 
1085     // Check if we need to do anything at all.
1086     // FIXME: Could eliminate the isDocumentElementRenderer() check if we fix background painting so that the RenderView
1087     // paints the root&#39;s background.
1088     if (!isDocumentElementRenderer()) {
1089         LayoutRect overflowBox = overflowRectForPaintRejection();
1090         flipForWritingMode(overflowBox);
1091         overflowBox.moveBy(adjustedPaintOffset);
1092         if (!overflowBox.intersects(paintInfo.rect)
1093 #if PLATFORM(IOS_FAMILY)
1094             // FIXME: This may be applicable to non-iOS ports.
1095             &amp;&amp; (!hasLayer() || !layer()-&gt;isComposited())
1096 #endif
1097         )
1098             return;
1099     }
1100 
1101     bool pushedClip = pushContentsClip(paintInfo, adjustedPaintOffset);
1102     paintObject(paintInfo, adjustedPaintOffset);
1103     if (pushedClip)
1104         popContentsClip(paintInfo, phase, adjustedPaintOffset);
1105 
1106     // Our scrollbar widgets paint exactly when we tell them to, so that they work properly with
1107     // z-index. We paint after we painted the background/border, so that the scrollbars will
1108     // sit above the background/border.
1109     if ((phase == PaintPhase::BlockBackground || phase == PaintPhase::ChildBlockBackground) &amp;&amp; hasOverflowClip() &amp;&amp; layer()
1110         &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; paintInfo.shouldPaintWithinRoot(*this) &amp;&amp; !paintInfo.paintRootBackgroundOnly())
1111         layer()-&gt;paintOverflowControls(paintInfo.context(), roundedIntPoint(adjustedPaintOffset), snappedIntRect(paintInfo.rect));
1112 }
1113 
1114 void RenderBlock::paintContents(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1115 {
1116     // Style is non-final if the element has a pending stylesheet before it. We end up with renderers with such styles if a script
1117     // forces renderer construction by querying something layout dependent.
1118     // Avoid FOUC by not painting. Switching to final style triggers repaint.
1119     if (style().isNotFinal())
1120         return;
1121 
1122     if (childrenInline())
1123         paintInlineChildren(paintInfo, paintOffset);
1124     else {
1125         PaintPhase newPhase = (paintInfo.phase == PaintPhase::ChildOutlines) ? PaintPhase::Outline : paintInfo.phase;
1126         newPhase = (newPhase == PaintPhase::ChildBlockBackgrounds) ? PaintPhase::ChildBlockBackground : newPhase;
1127 
1128         // We don&#39;t paint our own background, but we do let the kids paint their backgrounds.
1129         PaintInfo paintInfoForChild(paintInfo);
1130         paintInfoForChild.phase = newPhase;
1131         paintInfoForChild.updateSubtreePaintRootForChildren(this);
1132 
1133         // FIXME: Paint-time pagination is obsolete and is now only used by embedded WebViews inside AppKit
1134         // NSViews. Do not add any more code for this.
1135         bool usePrintRect = !view().printRect().isEmpty();
1136         paintChildren(paintInfo, paintOffset, paintInfoForChild, usePrintRect);
1137     }
1138 }
1139 
1140 void RenderBlock::paintChildren(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, PaintInfo&amp; paintInfoForChild, bool usePrintRect)
1141 {
1142     for (auto* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
1143         if (!paintChild(*child, paintInfo, paintOffset, paintInfoForChild, usePrintRect))
1144             return;
1145     }
1146 }
1147 
1148 bool RenderBlock::paintChild(RenderBox&amp; child, PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, PaintInfo&amp; paintInfoForChild, bool usePrintRect, PaintBlockType paintType)
1149 {
1150     if (child.isExcludedAndPlacedInBorder())
1151         return true;
1152 
1153     // Check for page-break-before: always, and if it&#39;s set, break and bail.
1154     bool checkBeforeAlways = !childrenInline() &amp;&amp; (usePrintRect &amp;&amp; alwaysPageBreak(child.style().breakBefore()));
1155     LayoutUnit absoluteChildY = paintOffset.y() + child.y();
1156     if (checkBeforeAlways
1157         &amp;&amp; absoluteChildY &gt; paintInfo.rect.y()
1158         &amp;&amp; absoluteChildY &lt; paintInfo.rect.maxY()) {
1159         view().setBestTruncatedAt(absoluteChildY, this, true);
1160         return false;
1161     }
1162 
1163     if (!child.isFloating() &amp;&amp; child.isReplaced() &amp;&amp; usePrintRect &amp;&amp; child.height() &lt;= view().printRect().height()) {
1164         // Paginate block-level replaced elements.
1165         if (absoluteChildY + child.height() &gt; view().printRect().maxY()) {
1166             if (absoluteChildY &lt; view().truncatedAt())
1167                 view().setBestTruncatedAt(absoluteChildY, &amp;child);
1168             // If we were able to truncate, don&#39;t paint.
1169             if (absoluteChildY &gt;= view().truncatedAt())
1170                 return false;
1171         }
1172     }
1173 
1174     LayoutPoint childPoint = flipForWritingModeForChild(&amp;child, paintOffset);
1175     if (!child.hasSelfPaintingLayer() &amp;&amp; !child.isFloating()) {
1176         if (paintType == PaintAsInlineBlock)
1177             child.paintAsInlineBlock(paintInfoForChild, childPoint);
1178         else
1179             child.paint(paintInfoForChild, childPoint);
1180     }
1181 
1182     // Check for page-break-after: always, and if it&#39;s set, break and bail.
1183     bool checkAfterAlways = !childrenInline() &amp;&amp; (usePrintRect &amp;&amp; alwaysPageBreak(child.style().breakAfter()));
1184     if (checkAfterAlways
1185         &amp;&amp; (absoluteChildY + child.height()) &gt; paintInfo.rect.y()
1186         &amp;&amp; (absoluteChildY + child.height()) &lt; paintInfo.rect.maxY()) {
1187         view().setBestTruncatedAt(absoluteChildY + child.height() + std::max&lt;LayoutUnit&gt;(0, child.collapsedMarginAfter()), this, true);
1188         return false;
1189     }
1190 
1191     return true;
1192 }
1193 
1194 void RenderBlock::paintCaret(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, CaretType type)
1195 {
1196     // Paint the caret if the FrameSelection says so or if caret browsing is enabled
1197     RenderBlock* caretPainter;
1198     bool isContentEditable;
1199     if (type == CursorCaret) {
1200         caretPainter = frame().selection().caretRendererWithoutUpdatingLayout();
1201         isContentEditable = frame().selection().selection().hasEditableStyle();
1202     } else {
1203         caretPainter = page().dragCaretController().caretRenderer();
1204         isContentEditable = page().dragCaretController().isContentEditable();
1205     }
1206 
1207     if (caretPainter == this &amp;&amp; (isContentEditable || settings().caretBrowsingEnabled())) {
1208         if (type == CursorCaret)
1209             frame().selection().paintCaret(paintInfo.context(), paintOffset, paintInfo.rect);
1210         else
1211             page().dragCaretController().paintDragCaret(&amp;frame(), paintInfo.context(), paintOffset, paintInfo.rect);
1212     }
1213 }
1214 
1215 void RenderBlock::paintObject(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1216 {
1217     PaintPhase paintPhase = paintInfo.phase;
1218 
1219     // 1. paint background, borders etc
1220     if ((paintPhase == PaintPhase::BlockBackground || paintPhase == PaintPhase::ChildBlockBackground) &amp;&amp; style().visibility() == Visibility::Visible) {
1221         if (hasVisibleBoxDecorations())
1222             paintBoxDecorations(paintInfo, paintOffset);
1223     }
1224 
1225     // Paint legends just above the border before we scroll or clip.
1226     if (paintPhase == PaintPhase::BlockBackground || paintPhase == PaintPhase::ChildBlockBackground || paintPhase == PaintPhase::Selection)
1227         paintExcludedChildrenInBorder(paintInfo, paintOffset);
1228 
1229     if (paintPhase == PaintPhase::Mask &amp;&amp; style().visibility() == Visibility::Visible) {
1230         paintMask(paintInfo, paintOffset);
1231         return;
1232     }
1233 
1234     if (paintPhase == PaintPhase::ClippingMask &amp;&amp; style().visibility() == Visibility::Visible) {
1235         paintClippingMask(paintInfo, paintOffset);
1236         return;
1237     }
1238 
1239     // If just painting the root background, then return.
1240     if (paintInfo.paintRootBackgroundOnly())
1241         return;
1242 
1243     // Adjust our painting position if we&#39;re inside a scrolled layer (e.g., an overflow:auto div).
1244     LayoutPoint scrolledOffset = paintOffset;
1245     scrolledOffset.moveBy(-scrollPosition());
1246 
1247     // Column rules need to account for scrolling and clipping.
1248     // FIXME: Clipping of column rules does not work. We will need a separate paint phase for column rules I suspect in order to get
1249     // clipping correct (since it has to paint as background but is still considered &quot;contents&quot;).
1250     if ((paintPhase == PaintPhase::BlockBackground || paintPhase == PaintPhase::ChildBlockBackground) &amp;&amp; style().visibility() == Visibility::Visible)
1251         paintColumnRules(paintInfo, scrolledOffset);
1252 
1253     // Done with backgrounds, borders and column rules.
1254     if (paintPhase == PaintPhase::BlockBackground)
1255         return;
1256 
1257     // 2. paint contents
1258     if (paintPhase != PaintPhase::SelfOutline)
1259         paintContents(paintInfo, scrolledOffset);
1260 
1261     // 3. paint selection
1262     // FIXME: Make this work with multi column layouts.  For now don&#39;t fill gaps.
1263     bool isPrinting = document().printing();
1264     if (!isPrinting)
1265         paintSelection(paintInfo, scrolledOffset); // Fill in gaps in selection on lines and between blocks.
1266 
1267     // 4. paint floats.
1268     if (paintPhase == PaintPhase::Float || paintPhase == PaintPhase::Selection || paintPhase == PaintPhase::TextClip)
1269         paintFloats(paintInfo, scrolledOffset, paintPhase == PaintPhase::Selection || paintPhase == PaintPhase::TextClip);
1270 
1271     // 5. paint outline.
1272     if ((paintPhase == PaintPhase::Outline || paintPhase == PaintPhase::SelfOutline) &amp;&amp; hasOutline() &amp;&amp; style().visibility() == Visibility::Visible)
1273         paintOutline(paintInfo, LayoutRect(paintOffset, size()));
1274 
1275     // 6. paint continuation outlines.
1276     if ((paintPhase == PaintPhase::Outline || paintPhase == PaintPhase::ChildOutlines)) {
1277         RenderInline* inlineCont = inlineContinuation();
1278         if (inlineCont &amp;&amp; inlineCont-&gt;hasOutline() &amp;&amp; inlineCont-&gt;style().visibility() == Visibility::Visible) {
1279             RenderInline* inlineRenderer = downcast&lt;RenderInline&gt;(inlineCont-&gt;element()-&gt;renderer());
1280             RenderBlock* containingBlock = this-&gt;containingBlock();
1281 
1282             bool inlineEnclosedInSelfPaintingLayer = false;
1283             for (RenderBoxModelObject* box = inlineRenderer; box != containingBlock; box = &amp;box-&gt;parent()-&gt;enclosingBoxModelObject()) {
1284                 if (box-&gt;hasSelfPaintingLayer()) {
1285                     inlineEnclosedInSelfPaintingLayer = true;
1286                     break;
1287                 }
1288             }
1289 
1290             // Do not add continuations for outline painting by our containing block if we are a relative positioned
1291             // anonymous block (i.e. have our own layer), paint them straightaway instead. This is because a block depends on renderers in its continuation table being
1292             // in the same layer.
1293             if (!inlineEnclosedInSelfPaintingLayer &amp;&amp; !hasLayer())
1294                 containingBlock-&gt;addContinuationWithOutline(inlineRenderer);
1295             else if (!inlineRenderer-&gt;firstLineBox() || (!inlineEnclosedInSelfPaintingLayer &amp;&amp; hasLayer()))
1296                 inlineRenderer-&gt;paintOutline(paintInfo, paintOffset - locationOffset() + inlineRenderer-&gt;containingBlock()-&gt;location());
1297         }
1298         paintContinuationOutlines(paintInfo, paintOffset);
1299     }
1300 
1301     // 7. paint caret.
1302     // If the caret&#39;s node&#39;s render object&#39;s containing block is this block, and the paint action is PaintPhase::Foreground,
1303     // then paint the caret.
1304     if (paintPhase == PaintPhase::Foreground) {
1305         paintCaret(paintInfo, paintOffset, CursorCaret);
1306         paintCaret(paintInfo, paintOffset, DragCaret);
1307     }
1308 }
1309 
1310 static ContinuationOutlineTableMap* continuationOutlineTable()
1311 {
1312     static NeverDestroyed&lt;ContinuationOutlineTableMap&gt; table;
1313     return &amp;table.get();
1314 }
1315 
1316 void RenderBlock::addContinuationWithOutline(RenderInline* flow)
1317 {
1318     // We can&#39;t make this work if the inline is in a layer.  We&#39;ll just rely on the broken
1319     // way of painting.
1320     ASSERT(!flow-&gt;layer() &amp;&amp; !flow-&gt;isContinuation());
1321 
1322     ContinuationOutlineTableMap* table = continuationOutlineTable();
1323     ListHashSet&lt;RenderInline*&gt;* continuations = table-&gt;get(this);
1324     if (!continuations) {
1325         continuations = new ListHashSet&lt;RenderInline*&gt;;
1326         table-&gt;set(this, std::unique_ptr&lt;ListHashSet&lt;RenderInline*&gt;&gt;(continuations));
1327     }
1328 
1329     continuations-&gt;add(flow);
1330 }
1331 
1332 bool RenderBlock::paintsContinuationOutline(RenderInline* flow)
1333 {
1334     ContinuationOutlineTableMap* table = continuationOutlineTable();
1335     if (table-&gt;isEmpty())
1336         return false;
1337 
1338     ListHashSet&lt;RenderInline*&gt;* continuations = table-&gt;get(this);
1339     if (!continuations)
1340         return false;
1341 
1342     return continuations-&gt;contains(flow);
1343 }
1344 
1345 void RenderBlock::paintContinuationOutlines(PaintInfo&amp; info, const LayoutPoint&amp; paintOffset)
1346 {
1347     ContinuationOutlineTableMap* table = continuationOutlineTable();
1348     if (table-&gt;isEmpty())
1349         return;
1350 
1351     std::unique_ptr&lt;ListHashSet&lt;RenderInline*&gt;&gt; continuations = table-&gt;take(this);
1352     if (!continuations)
1353         return;
1354 
1355     LayoutPoint accumulatedPaintOffset = paintOffset;
1356     // Paint each continuation outline.
1357     ListHashSet&lt;RenderInline*&gt;::iterator end = continuations-&gt;end();
1358     for (ListHashSet&lt;RenderInline*&gt;::iterator it = continuations-&gt;begin(); it != end; ++it) {
1359         // Need to add in the coordinates of the intervening blocks.
1360         RenderInline* flow = *it;
1361         RenderBlock* block = flow-&gt;containingBlock();
1362         for ( ; block &amp;&amp; block != this; block = block-&gt;containingBlock())
1363             accumulatedPaintOffset.moveBy(block-&gt;location());
1364         ASSERT(block);
1365         flow-&gt;paintOutline(info, accumulatedPaintOffset);
1366     }
1367 }
1368 
1369 bool RenderBlock::shouldPaintSelectionGaps() const
1370 {
1371     if (settings().selectionPaintingWithoutSelectionGapsEnabled())
1372         return false;
1373 
1374     return selectionState() != SelectionNone &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; isSelectionRoot();
1375 }
1376 
1377 bool RenderBlock::isSelectionRoot() const
1378 {
1379     if (isPseudoElement())
1380         return false;
1381     ASSERT(element() || isAnonymous());
1382 
1383     // FIXME: Eventually tables should have to learn how to fill gaps between cells, at least in simple non-spanning cases.
1384     if (isTable())
1385         return false;
1386 
1387     if (isBody() || isDocumentElementRenderer() || hasOverflowClip()
1388         || isPositioned() || isFloating()
1389         || isTableCell() || isInlineBlockOrInlineTable()
1390         || hasTransform() || hasReflection() || hasMask() || isWritingModeRoot()
1391         || isRenderFragmentedFlow() || style().columnSpan() == ColumnSpan::All)
1392         return true;
1393 
1394     if (view().selection().start()) {
1395         Node* startElement = view().selection().start()-&gt;node();
1396         if (startElement &amp;&amp; startElement-&gt;rootEditableElement() == element())
1397             return true;
1398     }
1399 
1400     return false;
1401 }
1402 
1403 GapRects RenderBlock::selectionGapRectsForRepaint(const RenderLayerModelObject* repaintContainer)
1404 {
1405     ASSERT(!needsLayout());
1406 
1407     if (!shouldPaintSelectionGaps())
1408         return GapRects();
1409 
1410     FloatPoint containerPoint = localToContainerPoint(FloatPoint(), repaintContainer, UseTransforms);
1411     LayoutPoint offsetFromRepaintContainer(containerPoint - toFloatSize(scrollPosition()));
1412 
1413     LogicalSelectionOffsetCaches cache(*this);
1414     LayoutUnit lastTop;
1415     LayoutUnit lastLeft = logicalLeftSelectionOffset(*this, lastTop, cache);
1416     LayoutUnit lastRight = logicalRightSelectionOffset(*this, lastTop, cache);
1417 
1418     return selectionGaps(*this, offsetFromRepaintContainer, IntSize(), lastTop, lastLeft, lastRight, cache);
1419 }
1420 
1421 void RenderBlock::paintSelection(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1422 {
1423 #if ENABLE(TEXT_SELECTION)
1424     if (shouldPaintSelectionGaps() &amp;&amp; paintInfo.phase == PaintPhase::Foreground) {
1425         LogicalSelectionOffsetCaches cache(*this);
1426         LayoutUnit lastTop;
1427         LayoutUnit lastLeft = logicalLeftSelectionOffset(*this, lastTop, cache);
1428         LayoutUnit lastRight = logicalRightSelectionOffset(*this, lastTop, cache);
1429         GraphicsContextStateSaver stateSaver(paintInfo.context());
1430 
1431         LayoutRect gapRectsBounds = selectionGaps(*this, paintOffset, LayoutSize(), lastTop, lastLeft, lastRight, cache, &amp;paintInfo);
1432         if (!gapRectsBounds.isEmpty()) {
1433             if (RenderLayer* layer = enclosingLayer()) {
1434                 gapRectsBounds.moveBy(-paintOffset);
1435                 if (!hasLayer()) {
1436                     LayoutRect localBounds(gapRectsBounds);
1437                     flipForWritingMode(localBounds);
1438                     gapRectsBounds = localToContainerQuad(FloatRect(localBounds), &amp;layer-&gt;renderer()).enclosingBoundingBox();
1439                     if (layer-&gt;renderer().isBox())
1440                         gapRectsBounds.moveBy(layer-&gt;renderBox()-&gt;scrollPosition());
1441                 }
1442                 layer-&gt;addBlockSelectionGapsBounds(gapRectsBounds);
1443             }
1444         }
1445     }
1446 #else
1447     UNUSED_PARAM(paintInfo);
1448     UNUSED_PARAM(paintOffset);
1449 #endif
1450 }
1451 
1452 static void clipOutPositionedObjects(const PaintInfo* paintInfo, const LayoutPoint&amp; offset, TrackedRendererListHashSet* positionedObjects)
1453 {
1454     if (!positionedObjects)
1455         return;
1456 
1457     TrackedRendererListHashSet::const_iterator end = positionedObjects-&gt;end();
1458     for (TrackedRendererListHashSet::const_iterator it = positionedObjects-&gt;begin(); it != end; ++it) {
1459         RenderBox* r = *it;
1460         paintInfo-&gt;context().clipOut(IntRect(offset.x() + r-&gt;x(), offset.y() + r-&gt;y(), r-&gt;width(), r-&gt;height()));
1461     }
1462 }
1463 
1464 LayoutUnit blockDirectionOffset(RenderBlock&amp; rootBlock, const LayoutSize&amp; offsetFromRootBlock)
1465 {
1466     return rootBlock.isHorizontalWritingMode() ? offsetFromRootBlock.height() : offsetFromRootBlock.width();
1467 }
1468 
1469 LayoutUnit inlineDirectionOffset(RenderBlock&amp; rootBlock, const LayoutSize&amp; offsetFromRootBlock)
1470 {
1471     return rootBlock.isHorizontalWritingMode() ? offsetFromRootBlock.width() : offsetFromRootBlock.height();
1472 }
1473 
1474 LayoutRect RenderBlock::logicalRectToPhysicalRect(const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutRect&amp; logicalRect)
1475 {
1476     LayoutRect result;
1477     if (isHorizontalWritingMode())
1478         result = logicalRect;
1479     else
1480         result = LayoutRect(logicalRect.y(), logicalRect.x(), logicalRect.height(), logicalRect.width());
1481     flipForWritingMode(result);
1482     result.moveBy(rootBlockPhysicalPosition);
1483     return result;
1484 }
1485 
1486 GapRects RenderBlock::selectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1487     LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1488 {
1489     // IMPORTANT: Callers of this method that intend for painting to happen need to do a save/restore.
1490     // Clip out floating and positioned objects when painting selection gaps.
1491     if (paintInfo) {
1492         // Note that we don&#39;t clip out overflow for positioned objects.  We just stick to the border box.
1493         LayoutRect flippedBlockRect(offsetFromRootBlock.width(), offsetFromRootBlock.height(), width(), height());
1494         rootBlock.flipForWritingMode(flippedBlockRect);
1495         flippedBlockRect.moveBy(rootBlockPhysicalPosition);
1496         clipOutPositionedObjects(paintInfo, flippedBlockRect.location(), positionedObjects());
1497         if (isBody() || isDocumentElementRenderer()) { // The &lt;body&gt; must make sure to examine its containingBlock&#39;s positioned objects.
1498             for (RenderBlock* cb = containingBlock(); cb &amp;&amp; !is&lt;RenderView&gt;(*cb); cb = cb-&gt;containingBlock())
1499                 clipOutPositionedObjects(paintInfo, LayoutPoint(cb-&gt;x(), cb-&gt;y()), cb-&gt;positionedObjects()); // FIXME: Not right for flipped writing modes.
1500         }
1501         clipOutFloatingObjects(rootBlock, paintInfo, rootBlockPhysicalPosition, offsetFromRootBlock);
1502     }
1503 
1504     // FIXME: overflow: auto/scroll fragments need more math here, since painting in the border box is different from painting in the padding box (one is scrolled, the other is
1505     // fixed).
1506     GapRects result;
1507     if (!isRenderBlockFlow()) // FIXME: Make multi-column selection gap filling work someday.
1508         return result;
1509 
1510     if (hasTransform() || style().columnSpan() == ColumnSpan::All || isInFlowRenderFragmentedFlow()) {
1511         // FIXME: We should learn how to gap fill multiple columns and transforms eventually.
1512         lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalHeight();
1513         lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, logicalHeight(), cache);
1514         lastLogicalRight = logicalRightSelectionOffset(rootBlock, logicalHeight(), cache);
1515         return result;
1516     }
1517 
1518     if (childrenInline())
1519         result = inlineSelectionGaps(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, lastLogicalTop, lastLogicalLeft, lastLogicalRight, cache, paintInfo);
1520     else
1521         result = blockSelectionGaps(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, lastLogicalTop, lastLogicalLeft, lastLogicalRight, cache, paintInfo);
1522 
1523     // Fill the vertical gap all the way to the bottom of our block if the selection extends past our block.
1524     if (&amp;rootBlock == this &amp;&amp; (selectionState() != SelectionBoth &amp;&amp; selectionState() != SelectionEnd) &amp;&amp; !isRubyBase() &amp;&amp; !isRubyText()) {
1525         result.uniteCenter(blockSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock,
1526             lastLogicalTop, lastLogicalLeft, lastLogicalRight, logicalHeight(), cache, paintInfo));
1527     }
1528 
1529     return result;
1530 }
1531 
1532 GapRects RenderBlock::inlineSelectionGaps(RenderBlock&amp;, const LayoutPoint&amp;, const LayoutSize&amp;, LayoutUnit&amp;, LayoutUnit&amp;, LayoutUnit&amp;, const LogicalSelectionOffsetCaches&amp;, const PaintInfo*)
1533 {
1534     ASSERT_NOT_REACHED();
1535     return GapRects();
1536 }
1537 
1538 GapRects RenderBlock::blockSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1539     LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1540 {
1541     GapRects result;
1542 
1543     // Jump right to the first block child that contains some selected objects.
1544     RenderBox* curr;
1545     for (curr = firstChildBox(); curr &amp;&amp; curr-&gt;selectionState() == SelectionNone; curr = curr-&gt;nextSiblingBox()) { }
1546 
1547     if (!curr)
1548         return result;
1549 
1550     LogicalSelectionOffsetCaches childCache(*this, cache);
1551 
1552     for (bool sawSelectionEnd = false; curr &amp;&amp; !sawSelectionEnd; curr = curr-&gt;nextSiblingBox()) {
1553         SelectionState childState = curr-&gt;selectionState();
1554         if (childState == SelectionBoth || childState == SelectionEnd)
1555             sawSelectionEnd = true;
1556 
1557         if (curr-&gt;isFloatingOrOutOfFlowPositioned())
1558             continue; // We must be a normal flow object in order to even be considered.
1559 
1560         if (curr-&gt;isInFlowPositioned() &amp;&amp; curr-&gt;hasLayer()) {
1561             // If the relposition offset is anything other than 0, then treat this just like an absolute positioned element.
1562             // Just disregard it completely.
1563             LayoutSize relOffset = curr-&gt;layer()-&gt;offsetForInFlowPosition();
1564             if (relOffset.width() || relOffset.height())
1565                 continue;
1566         }
1567 
1568         bool paintsOwnSelection = curr-&gt;shouldPaintSelectionGaps() || curr-&gt;isTable(); // FIXME: Eventually we won&#39;t special-case table like this.
1569         bool fillBlockGaps = (paintsOwnSelection || (curr-&gt;canBeSelectionLeaf() &amp;&amp; childState != SelectionNone)) &amp;&amp; !isRubyBase() &amp;&amp; !isRubyText();
1570         if (fillBlockGaps) {
1571             // We need to fill the vertical gap above this object.
1572             if (childState == SelectionEnd || childState == SelectionInside) {
1573                 // Fill the gap above the object.
1574                 result.uniteCenter(blockSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock,
1575                     lastLogicalTop, lastLogicalLeft, lastLogicalRight, curr-&gt;logicalTop(), cache, paintInfo));
1576             }
1577 
1578             // Only fill side gaps for objects that paint their own selection if we know for sure the selection is going to extend all the way *past*
1579             // our object.  We know this if the selection did not end inside our object.
1580             if (paintsOwnSelection &amp;&amp; (childState == SelectionStart || sawSelectionEnd))
1581                 childState = SelectionNone;
1582 
1583             // Fill side gaps on this object based off its state.
1584             bool leftGap, rightGap;
1585             getSelectionGapInfo(childState, leftGap, rightGap);
1586 
1587             if (leftGap)
1588                 result.uniteLeft(logicalLeftSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, this, curr-&gt;logicalLeft(), curr-&gt;logicalTop(), curr-&gt;logicalHeight(), cache, paintInfo));
1589             if (rightGap)
1590                 result.uniteRight(logicalRightSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, this, curr-&gt;logicalRight(), curr-&gt;logicalTop(), curr-&gt;logicalHeight(), cache, paintInfo));
1591 
1592             // Update lastLogicalTop to be just underneath the object.  lastLogicalLeft and lastLogicalRight extend as far as
1593             // they can without bumping into floating or positioned objects.  Ideally they will go right up
1594             // to the border of the root selection block.
1595             lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + curr-&gt;logicalBottom();
1596             lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, curr-&gt;logicalBottom(), cache);
1597             lastLogicalRight = logicalRightSelectionOffset(rootBlock, curr-&gt;logicalBottom(), cache);
1598         } else if (childState != SelectionNone &amp;&amp; is&lt;RenderBlock&gt;(*curr)) {
1599             // We must be a block that has some selected object inside it, so recur.
1600             result.unite(downcast&lt;RenderBlock&gt;(*curr).selectionGaps(rootBlock, rootBlockPhysicalPosition, LayoutSize(offsetFromRootBlock.width() + curr-&gt;x(), offsetFromRootBlock.height() + curr-&gt;y()),
1601                 lastLogicalTop, lastLogicalLeft, lastLogicalRight, childCache, paintInfo));
1602         }
1603     }
1604     return result;
1605 }
1606 
1607 LayoutRect RenderBlock::blockSelectionGap(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1608     LayoutUnit lastLogicalTop, LayoutUnit lastLogicalLeft, LayoutUnit lastLogicalRight, LayoutUnit logicalBottom, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1609 {
1610     LayoutUnit logicalTop = lastLogicalTop;
1611     LayoutUnit logicalHeight = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalBottom - logicalTop;
1612     if (logicalHeight &lt;= 0)
1613         return LayoutRect();
1614 
1615     // Get the selection offsets for the bottom of the gap
1616     LayoutUnit logicalLeft = std::max(lastLogicalLeft, logicalLeftSelectionOffset(rootBlock, logicalBottom, cache));
1617     LayoutUnit logicalRight = std::min(lastLogicalRight, logicalRightSelectionOffset(rootBlock, logicalBottom, cache));
1618     LayoutUnit logicalWidth = logicalRight - logicalLeft;
1619     if (logicalWidth &lt;= 0)
1620         return LayoutRect();
1621 
1622     LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, LayoutRect(logicalLeft, logicalTop, logicalWidth, logicalHeight));
1623     if (paintInfo)
1624         paintInfo-&gt;context().fillRect(snapRectToDevicePixels(gapRect, document().deviceScaleFactor()), selectionBackgroundColor());
1625     return gapRect;
1626 }
1627 
1628 LayoutRect RenderBlock::logicalLeftSelectionGap(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1629     RenderBoxModelObject* selObj, LayoutUnit logicalLeft, LayoutUnit logicalTop, LayoutUnit logicalHeight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1630 {
1631     LayoutUnit rootBlockLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalTop;
1632     LayoutUnit rootBlockLogicalLeft = std::max(logicalLeftSelectionOffset(rootBlock, logicalTop, cache), logicalLeftSelectionOffset(rootBlock, logicalTop + logicalHeight, cache));
1633     LayoutUnit rootBlockLogicalRight = std::min(inlineDirectionOffset(rootBlock, offsetFromRootBlock) + logicalLeft,
1634         std::min(logicalRightSelectionOffset(rootBlock, logicalTop, cache), logicalRightSelectionOffset(rootBlock, logicalTop + logicalHeight, cache)));
1635     LayoutUnit rootBlockLogicalWidth = rootBlockLogicalRight - rootBlockLogicalLeft;
1636     if (rootBlockLogicalWidth &lt;= 0)
1637         return LayoutRect();
1638 
1639     LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, LayoutRect(rootBlockLogicalLeft, rootBlockLogicalTop, rootBlockLogicalWidth, logicalHeight));
1640     if (paintInfo)
1641         paintInfo-&gt;context().fillRect(snapRectToDevicePixels(gapRect, document().deviceScaleFactor()), selObj-&gt;selectionBackgroundColor());
1642     return gapRect;
1643 }
1644 
1645 LayoutRect RenderBlock::logicalRightSelectionGap(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1646     RenderBoxModelObject* selObj, LayoutUnit logicalRight, LayoutUnit logicalTop, LayoutUnit logicalHeight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1647 {
1648     LayoutUnit rootBlockLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalTop;
1649     LayoutUnit rootBlockLogicalLeft = std::max(inlineDirectionOffset(rootBlock, offsetFromRootBlock) + logicalRight,
1650         std::max(logicalLeftSelectionOffset(rootBlock, logicalTop, cache), logicalLeftSelectionOffset(rootBlock, logicalTop + logicalHeight, cache)));
1651     LayoutUnit rootBlockLogicalRight = std::min(logicalRightSelectionOffset(rootBlock, logicalTop, cache), logicalRightSelectionOffset(rootBlock, logicalTop + logicalHeight, cache));
1652     LayoutUnit rootBlockLogicalWidth = rootBlockLogicalRight - rootBlockLogicalLeft;
1653     if (rootBlockLogicalWidth &lt;= 0)
1654         return LayoutRect();
1655 
1656     LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, LayoutRect(rootBlockLogicalLeft, rootBlockLogicalTop, rootBlockLogicalWidth, logicalHeight));
1657     if (paintInfo)
1658         paintInfo-&gt;context().fillRect(snapRectToDevicePixels(gapRect, document().deviceScaleFactor()), selObj-&gt;selectionBackgroundColor());
1659     return gapRect;
1660 }
1661 
1662 void RenderBlock::getSelectionGapInfo(SelectionState state, bool&amp; leftGap, bool&amp; rightGap)
1663 {
1664     bool ltr = style().isLeftToRightDirection();
1665     leftGap = (state == RenderObject::SelectionInside) ||
1666               (state == RenderObject::SelectionEnd &amp;&amp; ltr) ||
1667               (state == RenderObject::SelectionStart &amp;&amp; !ltr);
1668     rightGap = (state == RenderObject::SelectionInside) ||
1669                (state == RenderObject::SelectionStart &amp;&amp; ltr) ||
1670                (state == RenderObject::SelectionEnd &amp;&amp; !ltr);
1671 }
1672 
1673 LayoutUnit RenderBlock::logicalLeftSelectionOffset(RenderBlock&amp; rootBlock, LayoutUnit position, const LogicalSelectionOffsetCaches&amp; cache)
1674 {
1675     LayoutUnit logicalLeft = logicalLeftOffsetForLine(position, DoNotIndentText);
1676     if (logicalLeft == logicalLeftOffsetForContent()) {
1677         if (&amp;rootBlock != this) // The border can potentially be further extended by our containingBlock().
1678             return cache.containingBlockInfo(*this).logicalLeftSelectionOffset(rootBlock, position + logicalTop());
1679         return logicalLeft;
1680     }
1681 
1682     RenderBlock* cb = this;
1683     const LogicalSelectionOffsetCaches* currentCache = &amp;cache;
1684     while (cb != &amp;rootBlock) {
1685         logicalLeft += cb-&gt;logicalLeft();
1686 
1687         ASSERT(currentCache);
1688         auto info = currentCache-&gt;containingBlockInfo(*cb);
1689         cb = info.block();
1690         if (!cb)
1691             break;
1692         currentCache = info.cache();
1693     }
1694     return logicalLeft;
1695 }
1696 
1697 LayoutUnit RenderBlock::logicalRightSelectionOffset(RenderBlock&amp; rootBlock, LayoutUnit position, const LogicalSelectionOffsetCaches&amp; cache)
1698 {
1699     LayoutUnit logicalRight = logicalRightOffsetForLine(position, DoNotIndentText);
1700     if (logicalRight == logicalRightOffsetForContent()) {
1701         if (&amp;rootBlock != this) // The border can potentially be further extended by our containingBlock().
1702             return cache.containingBlockInfo(*this).logicalRightSelectionOffset(rootBlock, position + logicalTop());
1703         return logicalRight;
1704     }
1705 
1706     RenderBlock* cb = this;
1707     const LogicalSelectionOffsetCaches* currentCache = &amp;cache;
1708     while (cb != &amp;rootBlock) {
1709         logicalRight += cb-&gt;logicalLeft();
1710 
1711         ASSERT(currentCache);
1712         auto info = currentCache-&gt;containingBlockInfo(*cb);
1713         cb = info.block();
1714         if (!cb)
1715             break;
1716         currentCache = info.cache();
1717     }
1718     return logicalRight;
1719 }
1720 
1721 TrackedRendererListHashSet* RenderBlock::positionedObjects() const
1722 {
1723     return positionedDescendantsMap().positionedRenderers(*this);
1724 }
1725 
1726 void RenderBlock::insertPositionedObject(RenderBox&amp; positioned)
1727 {
1728     ASSERT(!isAnonymousBlock());
1729     if (positioned.isRenderFragmentedFlow())
1730         return;
1731     // FIXME: Find out if we can do this as part of positioned.setChildNeedsLayout(MarkOnlyThis)
1732     if (positioned.needsLayout()) {
1733         // We should turn this bit on only while in layout.
1734         ASSERT(posChildNeedsLayout() || view().frameView().layoutContext().isInLayout());
1735         setPosChildNeedsLayoutBit(true);
1736     }
1737     positionedDescendantsMap().addDescendant(*this, positioned, isRenderView() ? PositionedDescendantsMap::MoveDescendantToEnd::Yes
1738         : PositionedDescendantsMap::MoveDescendantToEnd::No);
1739 }
1740 
1741 void RenderBlock::removePositionedObject(const RenderBox&amp; rendererToRemove)
1742 {
1743     positionedDescendantsMap().removeDescendant(rendererToRemove);
1744 }
1745 
1746 void RenderBlock::removePositionedObjects(const RenderBlock* newContainingBlockCandidate, ContainingBlockState containingBlockState)
1747 {
1748     auto* positionedDescendants = positionedObjects();
1749     if (!positionedDescendants)
1750         return;
1751 
1752     Vector&lt;RenderBox*, 16&gt; renderersToRemove;
1753     for (auto* renderer : *positionedDescendants) {
1754         if (newContainingBlockCandidate &amp;&amp; !renderer-&gt;isDescendantOf(newContainingBlockCandidate))
1755             continue;
1756         renderersToRemove.append(renderer);
1757         if (containingBlockState == NewContainingBlock)
1758             renderer-&gt;setChildNeedsLayout(MarkOnlyThis);
1759         // It is the parent block&#39;s job to add positioned children to positioned objects list of its containing block.
1760         // Dirty the parent to ensure this happens.
1761         auto* parent = renderer-&gt;parent();
1762         while (parent &amp;&amp; !parent-&gt;isRenderBlock())
1763             parent = parent-&gt;parent();
1764         if (parent)
1765             parent-&gt;setChildNeedsLayout();
1766     }
1767     for (auto* renderer : renderersToRemove)
1768         removePositionedObject(*renderer);
1769 }
1770 
1771 void RenderBlock::addPercentHeightDescendant(RenderBox&amp; descendant)
1772 {
1773     insertIntoTrackedRendererMaps(*this, descendant);
1774 }
1775 
1776 void RenderBlock::removePercentHeightDescendant(RenderBox&amp; descendant)
1777 {
1778     removeFromTrackedRendererMaps(descendant);
1779 }
1780 
1781 TrackedRendererListHashSet* RenderBlock::percentHeightDescendants() const
1782 {
1783     return percentHeightDescendantsMap ? percentHeightDescendantsMap-&gt;get(this) : nullptr;
1784 }
1785 
1786 bool RenderBlock::hasPercentHeightContainerMap()
1787 {
1788     return percentHeightContainerMap;
1789 }
1790 
1791 bool RenderBlock::hasPercentHeightDescendant(RenderBox&amp; descendant)
1792 {
1793     // We don&#39;t null check percentHeightContainerMap since the caller
1794     // already ensures this and we need to call this function on every
1795     // descendant in clearPercentHeightDescendantsFrom().
1796     ASSERT(percentHeightContainerMap);
1797     return percentHeightContainerMap-&gt;contains(&amp;descendant);
1798 }
1799 
1800 void RenderBlock::removePercentHeightDescendantIfNeeded(RenderBox&amp; descendant)
1801 {
1802     // We query the map directly, rather than looking at style&#39;s
1803     // logicalHeight()/logicalMinHeight()/logicalMaxHeight() since those
1804     // can change with writing mode/directional changes.
1805     if (!hasPercentHeightContainerMap())
1806         return;
1807 
1808     if (!hasPercentHeightDescendant(descendant))
1809         return;
1810 
1811     removePercentHeightDescendant(descendant);
1812 }
1813 
1814 void RenderBlock::clearPercentHeightDescendantsFrom(RenderBox&amp; parent)
1815 {
1816     ASSERT(percentHeightContainerMap);
1817     for (RenderObject* child = parent.firstChild(); child; child = child-&gt;nextInPreOrder(&amp;parent)) {
1818         if (!is&lt;RenderBox&gt;(*child))
1819             continue;
1820 
1821         auto&amp; box = downcast&lt;RenderBox&gt;(*child);
1822         if (!hasPercentHeightDescendant(box))
1823             continue;
1824 
1825         removePercentHeightDescendant(box);
1826     }
1827 }
1828 
1829 bool RenderBlock::isContainingBlockAncestorFor(RenderObject&amp; renderer) const
1830 {
1831     for (const auto* ancestor = renderer.containingBlock(); ancestor; ancestor = ancestor-&gt;containingBlock()) {
1832         if (ancestor == this)
1833             return true;
1834     }
1835     return false;
1836 }
1837 
1838 LayoutUnit RenderBlock::textIndentOffset() const
1839 {
1840     LayoutUnit cw;
1841     if (style().textIndent().isPercentOrCalculated())
1842         cw = containingBlock()-&gt;availableLogicalWidth();
1843     return minimumValueForLength(style().textIndent(), cw);
1844 }
1845 
1846 LayoutUnit RenderBlock::logicalLeftOffsetForContent(RenderFragmentContainer* fragment) const
1847 {
1848     LayoutUnit logicalLeftOffset = style().isHorizontalWritingMode() ? borderLeft() + paddingLeft() : borderTop() + paddingTop();
1849     if (shouldPlaceBlockDirectionScrollbarOnLeft())
1850         logicalLeftOffset += verticalScrollbarWidth();
1851     if (!fragment)
1852         return logicalLeftOffset;
1853     LayoutRect boxRect = borderBoxRectInFragment(fragment);
1854     return logicalLeftOffset + (isHorizontalWritingMode() ? boxRect.x() : boxRect.y());
1855 }
1856 
1857 LayoutUnit RenderBlock::logicalRightOffsetForContent(RenderFragmentContainer* fragment) const
1858 {
1859     LayoutUnit logicalRightOffset = style().isHorizontalWritingMode() ? borderLeft() + paddingLeft() : borderTop() + paddingTop();
1860     if (shouldPlaceBlockDirectionScrollbarOnLeft())
1861         logicalRightOffset += verticalScrollbarWidth();
1862     logicalRightOffset += availableLogicalWidth();
1863     if (!fragment)
1864         return logicalRightOffset;
1865     LayoutRect boxRect = borderBoxRectInFragment(fragment);
1866     return logicalRightOffset - (logicalWidth() - (isHorizontalWritingMode() ? boxRect.maxX() : boxRect.maxY()));
1867 }
1868 
1869 LayoutUnit RenderBlock::adjustLogicalLeftOffsetForLine(LayoutUnit offsetFromFloats, bool applyTextIndent) const
1870 {
1871     LayoutUnit left = offsetFromFloats;
1872 
1873     if (applyTextIndent &amp;&amp; style().isLeftToRightDirection())
1874         left += textIndentOffset();
1875 
1876     if (style().lineAlign() == LineAlign::None)
1877         return left;
1878 
1879     // Push in our left offset so that it is aligned with the character grid.
1880     auto* layoutState = view().frameView().layoutContext().layoutState();
1881     if (!layoutState)
1882         return left;
1883 
1884     RenderBlock* lineGrid = layoutState-&gt;lineGrid();
1885     if (!lineGrid || lineGrid-&gt;style().writingMode() != style().writingMode())
1886         return left;
1887 
1888     // FIXME: Should letter-spacing apply? This is complicated since it doesn&#39;t apply at the edge?
1889     float maxCharWidth = lineGrid-&gt;style().fontCascade().primaryFont().maxCharWidth();
1890     if (!maxCharWidth)
1891         return left;
1892 
1893     LayoutUnit lineGridOffset = lineGrid-&gt;isHorizontalWritingMode() ? layoutState-&gt;lineGridOffset().width(): layoutState-&gt;lineGridOffset().height();
1894     LayoutUnit layoutOffset = lineGrid-&gt;isHorizontalWritingMode() ? layoutState-&gt;layoutOffset().width() : layoutState-&gt;layoutOffset().height();
1895 
1896     // Push in to the nearest character width (truncated so that we pixel snap left).
1897     // FIXME: Should be patched when subpixel layout lands, since this calculation doesn&#39;t have to pixel snap
1898     // any more (https://bugs.webkit.org/show_bug.cgi?id=79946).
1899     // FIXME: This is wrong for RTL (https://bugs.webkit.org/show_bug.cgi?id=79945).
1900     // FIXME: This doesn&#39;t work with columns or fragments (https://bugs.webkit.org/show_bug.cgi?id=79942).
1901     // FIXME: This doesn&#39;t work when the inline position of the object isn&#39;t set ahead of time.
1902     // FIXME: Dynamic changes to the font or to the inline position need to result in a deep relayout.
1903     // (https://bugs.webkit.org/show_bug.cgi?id=79944)
1904     float remainder = fmodf(maxCharWidth - fmodf(left + layoutOffset - lineGridOffset, maxCharWidth), maxCharWidth);
1905     left += remainder;
1906     return left;
1907 }
1908 
1909 LayoutUnit RenderBlock::adjustLogicalRightOffsetForLine(LayoutUnit offsetFromFloats, bool applyTextIndent) const
1910 {
1911     LayoutUnit right = offsetFromFloats;
1912 
1913     if (applyTextIndent &amp;&amp; !style().isLeftToRightDirection())
1914         right -= textIndentOffset();
1915 
1916     if (style().lineAlign() == LineAlign::None)
1917         return right;
1918 
1919     // Push in our right offset so that it is aligned with the character grid.
1920     auto* layoutState = view().frameView().layoutContext().layoutState();
1921     if (!layoutState)
1922         return right;
1923 
1924     RenderBlock* lineGrid = layoutState-&gt;lineGrid();
1925     if (!lineGrid || lineGrid-&gt;style().writingMode() != style().writingMode())
1926         return right;
1927 
1928     // FIXME: Should letter-spacing apply? This is complicated since it doesn&#39;t apply at the edge?
1929     float maxCharWidth = lineGrid-&gt;style().fontCascade().primaryFont().maxCharWidth();
1930     if (!maxCharWidth)
1931         return right;
1932 
1933     LayoutUnit lineGridOffset = lineGrid-&gt;isHorizontalWritingMode() ? layoutState-&gt;lineGridOffset().width(): layoutState-&gt;lineGridOffset().height();
1934     LayoutUnit layoutOffset = lineGrid-&gt;isHorizontalWritingMode() ? layoutState-&gt;layoutOffset().width() : layoutState-&gt;layoutOffset().height();
1935 
1936     // Push in to the nearest character width (truncated so that we pixel snap right).
1937     // FIXME: Should be patched when subpixel layout lands, since this calculation doesn&#39;t have to pixel snap
1938     // any more (https://bugs.webkit.org/show_bug.cgi?id=79946).
1939     // FIXME: This is wrong for RTL (https://bugs.webkit.org/show_bug.cgi?id=79945).
1940     // FIXME: This doesn&#39;t work with columns or fragments (https://bugs.webkit.org/show_bug.cgi?id=79942).
1941     // FIXME: This doesn&#39;t work when the inline position of the object isn&#39;t set ahead of time.
1942     // FIXME: Dynamic changes to the font or to the inline position need to result in a deep relayout.
1943     // (https://bugs.webkit.org/show_bug.cgi?id=79944)
1944     float remainder = fmodf(fmodf(right + layoutOffset - lineGridOffset, maxCharWidth), maxCharWidth);
1945     right -= ceilf(remainder);
1946     return right;
1947 }
1948 
1949 bool RenderBlock::isPointInOverflowControl(HitTestResult&amp; result, const LayoutPoint&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset)
1950 {
1951     if (!scrollsOverflow())
1952         return false;
1953 
1954     return layer()-&gt;hitTestOverflowControls(result, roundedIntPoint(locationInContainer - toLayoutSize(accumulatedOffset)));
1955 }
1956 
1957 Node* RenderBlock::nodeForHitTest() const
1958 {
1959     // If we are in the margins of block elements that are part of a
1960     // continuation we&#39;re actually still inside the enclosing element
1961     // that was split. Use the appropriate inner node.
1962     if (isRenderView())
1963         return &amp;document();
1964     return continuation() ? continuation()-&gt;element() : element();
1965 }
1966 
1967 bool RenderBlock::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
1968 {
1969     LayoutPoint adjustedLocation(accumulatedOffset + location());
1970     LayoutSize localOffset = toLayoutSize(adjustedLocation);
1971 
1972     if (!isRenderView()) {
1973         // Check if we need to do anything at all.
1974         LayoutRect overflowBox = visualOverflowRect();
1975         flipForWritingMode(overflowBox);
1976         overflowBox.moveBy(adjustedLocation);
1977         if (!locationInContainer.intersects(overflowBox))
1978             return false;
1979     }
1980 
1981     if ((hitTestAction == HitTestBlockBackground || hitTestAction == HitTestChildBlockBackground) &amp;&amp; isPointInOverflowControl(result, locationInContainer.point(), adjustedLocation)) {
1982         updateHitTestResult(result, locationInContainer.point() - localOffset);
1983         // FIXME: isPointInOverflowControl() doesn&#39;t handle rect-based tests yet.
1984         if (result.addNodeToListBasedTestResult(nodeForHitTest(), request, locationInContainer) == HitTestProgress::Stop)
1985            return true;
1986     }
1987 
1988     if (style().clipPath()) {
1989         switch (style().clipPath()-&gt;type()) {
1990         case ClipPathOperation::Shape: {
1991             auto&amp; clipPath = downcast&lt;ShapeClipPathOperation&gt;(*style().clipPath());
1992 
1993             LayoutRect referenceBoxRect;
1994             switch (clipPath.referenceBox()) {
1995             case CSSBoxType::MarginBox:
1996                 referenceBoxRect = marginBoxRect();
1997                 break;
1998             case CSSBoxType::BorderBox:
1999                 referenceBoxRect = borderBoxRect();
2000                 break;
2001             case CSSBoxType::PaddingBox:
2002                 referenceBoxRect = paddingBoxRect();
2003                 break;
2004             case CSSBoxType::ContentBox:
2005                 referenceBoxRect = contentBoxRect();
2006                 break;
2007             case CSSBoxType::BoxMissing:
2008             case CSSBoxType::FillBox:
2009             case CSSBoxType::StrokeBox:
2010             case CSSBoxType::ViewBox:
2011                 referenceBoxRect = borderBoxRect();
2012             }
2013             if (!clipPath.pathForReferenceRect(referenceBoxRect).contains(locationInContainer.point() - localOffset, clipPath.windRule()))
2014                 return false;
2015             break;
2016         }
2017         case ClipPathOperation::Reference: {
2018             const auto&amp; referenceClipPathOperation = downcast&lt;ReferenceClipPathOperation&gt;(*style().clipPath());
2019             auto* element = document().getElementById(referenceClipPathOperation.fragment());
2020             if (!element || !element-&gt;renderer())
2021                 break;
2022             if (!is&lt;SVGClipPathElement&gt;(*element))
2023                 break;
2024             auto&amp; clipper = downcast&lt;RenderSVGResourceClipper&gt;(*element-&gt;renderer());
2025             if (!clipper.hitTestClipContent(FloatRect(borderBoxRect()), FloatPoint(locationInContainer.point() - localOffset)))
2026                 return false;
2027             break;
2028         }
2029         case ClipPathOperation::Box:
2030             break;
2031         }
2032     }
2033 
2034     // If we have clipping, then we can&#39;t have any spillout.
2035     bool useOverflowClip = hasOverflowClip() &amp;&amp; !hasSelfPaintingLayer();
2036     bool useClip = (hasControlClip() || useOverflowClip);
2037     bool checkChildren = !useClip || (hasControlClip() ? locationInContainer.intersects(controlClipRect(adjustedLocation)) : locationInContainer.intersects(overflowClipRect(adjustedLocation, nullptr, IncludeOverlayScrollbarSize)));
2038     if (checkChildren) {
2039         // Hit test descendants first.
2040         LayoutSize scrolledOffset(localOffset - toLayoutSize(scrollPosition()));
2041 
2042         if (hitTestAction == HitTestFloat &amp;&amp; hitTestFloats(request, result, locationInContainer, toLayoutPoint(scrolledOffset)))
2043             return true;
2044         if (hitTestContents(request, result, locationInContainer, toLayoutPoint(scrolledOffset), hitTestAction)) {
2045             updateHitTestResult(result, flipForWritingMode(locationInContainer.point() - localOffset));
2046             return true;
2047         }
2048     }
2049 
2050     if (!checkChildren &amp;&amp; hitTestExcludedChildrenInBorder(request, result, locationInContainer, adjustedLocation, hitTestAction))
2051         return true;
2052 
2053     // Check if the point is outside radii.
2054     if (!isRenderView() &amp;&amp; style().hasBorderRadius()) {
2055         LayoutRect borderRect = borderBoxRect();
2056         borderRect.moveBy(adjustedLocation);
2057         RoundedRect border = style().getRoundedBorderFor(borderRect);
2058         if (!locationInContainer.intersects(border))
2059             return false;
2060     }
2061 
2062     // Now hit test our background
2063     if (hitTestAction == HitTestBlockBackground || hitTestAction == HitTestChildBlockBackground) {
2064         LayoutRect boundsRect(adjustedLocation, size());
2065         if (visibleToHitTesting() &amp;&amp; locationInContainer.intersects(boundsRect)) {
2066             updateHitTestResult(result, flipForWritingMode(locationInContainer.point() - localOffset));
2067             if (result.addNodeToListBasedTestResult(nodeForHitTest(), request, locationInContainer, boundsRect) == HitTestProgress::Stop)
2068                 return true;
2069         }
2070     }
2071 
2072     return false;
2073 }
2074 
2075 bool RenderBlock::hitTestContents(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
2076 {
2077     if (childrenInline() &amp;&amp; !isTable())
2078         return hitTestInlineChildren(request, result, locationInContainer, accumulatedOffset, hitTestAction);
2079 
2080     // Hit test our children.
2081     HitTestAction childHitTest = hitTestAction;
2082     if (hitTestAction == HitTestChildBlockBackgrounds)
2083         childHitTest = HitTestChildBlockBackground;
2084     for (auto* child = lastChildBox(); child; child = child-&gt;previousSiblingBox()) {
2085         LayoutPoint childPoint = flipForWritingModeForChild(child, accumulatedOffset);
2086         if (!child-&gt;hasSelfPaintingLayer() &amp;&amp; !child-&gt;isFloating() &amp;&amp; child-&gt;nodeAtPoint(request, result, locationInContainer, childPoint, childHitTest))
2087             return true;
2088     }
2089 
2090     return false;
2091 }
2092 
2093 static inline bool isEditingBoundary(RenderElement* ancestor, RenderObject&amp; child)
2094 {
2095     ASSERT(!ancestor || ancestor-&gt;nonPseudoElement());
2096     ASSERT(child.nonPseudoNode());
2097     return !ancestor || !ancestor-&gt;parent() || (ancestor-&gt;hasLayer() &amp;&amp; ancestor-&gt;parent()-&gt;isRenderView())
2098         || ancestor-&gt;nonPseudoElement()-&gt;hasEditableStyle() == child.nonPseudoNode()-&gt;hasEditableStyle();
2099 }
2100 
2101 // FIXME: This function should go on RenderObject as an instance method. Then
2102 // all cases in which positionForPoint recurs could call this instead to
2103 // prevent crossing editable boundaries. This would require many tests.
2104 VisiblePosition positionForPointRespectingEditingBoundaries(RenderBlock&amp; parent, RenderBox&amp; child, const LayoutPoint&amp; pointInParentCoordinates)
2105 {
2106     LayoutPoint childLocation = child.location();
2107     if (child.isInFlowPositioned())
2108         childLocation += child.offsetForInFlowPosition();
2109 
2110     // FIXME: This is wrong if the child&#39;s writing-mode is different from the parent&#39;s.
2111     LayoutPoint pointInChildCoordinates(toLayoutPoint(pointInParentCoordinates - childLocation));
2112 
2113     // If this is an anonymous renderer, we just recur normally
2114     Element* childElement= child.nonPseudoElement();
2115     if (!childElement)
2116         return child.positionForPoint(pointInChildCoordinates, nullptr);
2117 
2118     // Otherwise, first make sure that the editability of the parent and child agree.
2119     // If they don&#39;t agree, then we return a visible position just before or after the child
2120     RenderElement* ancestor = &amp;parent;
2121     while (ancestor &amp;&amp; !ancestor-&gt;nonPseudoElement())
2122         ancestor = ancestor-&gt;parent();
2123 
2124     // If we can&#39;t find an ancestor to check editability on, or editability is unchanged, we recur like normal
2125     if (isEditingBoundary(ancestor, child))
2126         return child.positionForPoint(pointInChildCoordinates, nullptr);
2127 
2128     // Otherwise return before or after the child, depending on if the click was to the logical left or logical right of the child
2129     LayoutUnit childMiddle = parent.logicalWidthForChild(child) / 2;
2130     LayoutUnit logicalLeft = parent.isHorizontalWritingMode() ? pointInChildCoordinates.x() : pointInChildCoordinates.y();
2131     if (logicalLeft &lt; childMiddle)
2132         return ancestor-&gt;createVisiblePosition(childElement-&gt;computeNodeIndex(), DOWNSTREAM);
2133     return ancestor-&gt;createVisiblePosition(childElement-&gt;computeNodeIndex() + 1, UPSTREAM);
2134 }
2135 
2136 VisiblePosition RenderBlock::positionForPointWithInlineChildren(const LayoutPoint&amp;, const RenderFragmentContainer*)
2137 {
2138     ASSERT_NOT_REACHED();
2139     return VisiblePosition();
2140 }
2141 
2142 static inline bool isChildHitTestCandidate(const RenderBox&amp; box)
2143 {
2144     return box.height() &amp;&amp; box.style().visibility() == Visibility::Visible &amp;&amp; !box.isOutOfFlowPositioned() &amp;&amp; !box.isInFlowRenderFragmentedFlow();
2145 }
2146 
2147 // Valid candidates in a FragmentedFlow must be rendered by the fragment.
2148 static inline bool isChildHitTestCandidate(const RenderBox&amp; box, const RenderFragmentContainer* fragment, const LayoutPoint&amp; point)
2149 {
2150     if (!isChildHitTestCandidate(box))
2151         return false;
2152     if (!fragment)
2153         return true;
2154     const RenderBlock&amp; block = is&lt;RenderBlock&gt;(box) ? downcast&lt;RenderBlock&gt;(box) : *box.containingBlock();
2155     return block.fragmentAtBlockOffset(point.y()) == fragment;
2156 }
2157 
2158 VisiblePosition RenderBlock::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer* fragment)
2159 {
2160     if (isTable())
2161         return RenderBox::positionForPoint(point, fragment);
2162 
2163     if (isReplaced()) {
2164         // FIXME: This seems wrong when the object&#39;s writing-mode doesn&#39;t match the line&#39;s writing-mode.
2165         LayoutUnit pointLogicalLeft = isHorizontalWritingMode() ? point.x() : point.y();
2166         LayoutUnit pointLogicalTop = isHorizontalWritingMode() ? point.y() : point.x();
2167 
2168         if (pointLogicalTop &lt; 0 || (pointLogicalTop &lt; logicalHeight() &amp;&amp; pointLogicalLeft &lt; 0))
2169             return createVisiblePosition(caretMinOffset(), DOWNSTREAM);
2170         if (pointLogicalTop &gt;= logicalHeight() || (pointLogicalTop &gt;= 0 &amp;&amp; pointLogicalLeft &gt;= logicalWidth()))
2171             return createVisiblePosition(caretMaxOffset(), DOWNSTREAM);
2172     }
2173 
2174     LayoutPoint pointInContents = point;
2175     offsetForContents(pointInContents);
2176     LayoutPoint pointInLogicalContents(pointInContents);
2177     if (!isHorizontalWritingMode())
2178         pointInLogicalContents = pointInLogicalContents.transposedPoint();
2179 
2180     if (childrenInline())
2181         return positionForPointWithInlineChildren(pointInLogicalContents, fragment);
2182 
2183     RenderBox* lastCandidateBox = lastChildBox();
2184 
2185     if (!fragment)
2186         fragment = fragmentAtBlockOffset(pointInLogicalContents.y());
2187 
2188     while (lastCandidateBox &amp;&amp; !isChildHitTestCandidate(*lastCandidateBox, fragment, pointInLogicalContents))
2189         lastCandidateBox = lastCandidateBox-&gt;previousSiblingBox();
2190 
2191     bool blocksAreFlipped = style().isFlippedBlocksWritingMode();
2192     if (lastCandidateBox) {
2193         if (pointInLogicalContents.y() &gt; logicalTopForChild(*lastCandidateBox)
2194             || (!blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == logicalTopForChild(*lastCandidateBox)))
2195             return positionForPointRespectingEditingBoundaries(*this, *lastCandidateBox, pointInContents);
2196 
2197         for (auto* childBox = firstChildBox(); childBox; childBox = childBox-&gt;nextSiblingBox()) {
2198             if (!isChildHitTestCandidate(*childBox, fragment, pointInLogicalContents))
2199                 continue;
2200             LayoutUnit childLogicalBottom = logicalTopForChild(*childBox) + logicalHeightForChild(*childBox);
2201             if (is&lt;RenderBlockFlow&gt;(childBox))
2202                 childLogicalBottom += downcast&lt;RenderBlockFlow&gt;(childBox)-&gt;lowestFloatLogicalBottom();
2203             // We hit child if our click is above the bottom of its padding box (like IE6/7 and FF3).
2204             if (isChildHitTestCandidate(*childBox, fragment, pointInLogicalContents) &amp;&amp; (pointInLogicalContents.y() &lt; childLogicalBottom
2205                 || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == childLogicalBottom)))
2206                 return positionForPointRespectingEditingBoundaries(*this, *childBox, pointInContents);
2207         }
2208     }
2209 
2210     // We only get here if there are no hit test candidate children below the click.
2211     return RenderBox::positionForPoint(point, fragment);
2212 }
2213 
2214 void RenderBlock::offsetForContents(LayoutPoint&amp; offset) const
2215 {
2216     offset = flipForWritingMode(offset);
2217     offset += toLayoutSize(scrollPosition());
2218     offset = flipForWritingMode(offset);
2219 }
2220 
2221 void RenderBlock::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
2222 {
2223     ASSERT(!childrenInline());
2224 
2225     computeBlockPreferredLogicalWidths(minLogicalWidth, maxLogicalWidth);
2226 
2227     maxLogicalWidth = std::max(minLogicalWidth, maxLogicalWidth);
2228 
2229     int scrollbarWidth = intrinsicScrollbarLogicalWidth();
2230     maxLogicalWidth += scrollbarWidth;
2231     minLogicalWidth += scrollbarWidth;
2232 }
2233 
2234 void RenderBlock::computePreferredLogicalWidths()
2235 {
2236     ASSERT(preferredLogicalWidthsDirty());
2237 
2238     m_minPreferredLogicalWidth = 0;
2239     m_maxPreferredLogicalWidth = 0;
2240 
2241     const RenderStyle&amp; styleToUse = style();
2242     if (!isTableCell() &amp;&amp; styleToUse.logicalWidth().isFixed() &amp;&amp; styleToUse.logicalWidth().value() &gt;= 0
2243         &amp;&amp; !(isDeprecatedFlexItem() &amp;&amp; !styleToUse.logicalWidth().intValue()))
2244         m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalWidth().value());
2245     else
2246         computeIntrinsicLogicalWidths(m_minPreferredLogicalWidth, m_maxPreferredLogicalWidth);
2247 
2248     if (styleToUse.logicalMinWidth().isFixed() &amp;&amp; styleToUse.logicalMinWidth().value() &gt; 0) {
2249         m_maxPreferredLogicalWidth = std::max(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMinWidth().value()));
2250         m_minPreferredLogicalWidth = std::max(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMinWidth().value()));
2251     }
2252 
2253     if (styleToUse.logicalMaxWidth().isFixed()) {
2254         m_maxPreferredLogicalWidth = std::min(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMaxWidth().value()));
2255         m_minPreferredLogicalWidth = std::min(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMaxWidth().value()));
2256     }
2257 
2258     LayoutUnit borderAndPadding = borderAndPaddingLogicalWidth();
2259     m_minPreferredLogicalWidth += borderAndPadding;
2260     m_maxPreferredLogicalWidth += borderAndPadding;
2261 
2262     setPreferredLogicalWidthsDirty(false);
2263 }
2264 
2265 void RenderBlock::computeBlockPreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
2266 {
2267     const RenderStyle&amp; styleToUse = style();
2268     bool nowrap = styleToUse.whiteSpace() == WhiteSpace::NoWrap;
2269 
2270     RenderObject* child = firstChild();
2271     RenderBlock* containingBlock = this-&gt;containingBlock();
2272     LayoutUnit floatLeftWidth, floatRightWidth;
2273 
2274     LayoutUnit childMinWidth;
2275     LayoutUnit childMaxWidth;
2276     bool hadExcludedChildren = computePreferredWidthsForExcludedChildren(childMinWidth, childMaxWidth);
2277     if (hadExcludedChildren) {
2278         minLogicalWidth = std::max(childMinWidth, minLogicalWidth);
2279         maxLogicalWidth = std::max(childMaxWidth, maxLogicalWidth);
2280     }
2281 
2282     while (child) {
2283         // Positioned children don&#39;t affect the min/max width. Legends in fieldsets are skipped here
2284         // since they compute outside of any one layout system. Other children excluded from
2285         // normal layout are only used with block flows, so it&#39;s ok to calculate them here.
2286         if (child-&gt;isOutOfFlowPositioned() || child-&gt;isExcludedAndPlacedInBorder()) {
2287             child = child-&gt;nextSibling();
2288             continue;
2289         }
2290 
2291         const RenderStyle&amp; childStyle = child-&gt;style();
2292         if (child-&gt;isFloating() || (is&lt;RenderBox&gt;(*child) &amp;&amp; downcast&lt;RenderBox&gt;(*child).avoidsFloats())) {
2293             LayoutUnit floatTotalWidth = floatLeftWidth + floatRightWidth;
2294             if (childStyle.clear() == Clear::Left || childStyle.clear() == Clear::Both) {
2295                 maxLogicalWidth = std::max(floatTotalWidth, maxLogicalWidth);
2296                 floatLeftWidth = 0;
2297             }
2298             if (childStyle.clear() == Clear::Right || childStyle.clear() == Clear::Both) {
2299                 maxLogicalWidth = std::max(floatTotalWidth, maxLogicalWidth);
2300                 floatRightWidth = 0;
2301             }
2302         }
2303 
2304         // A margin basically has three types: fixed, percentage, and auto (variable).
2305         // Auto and percentage margins simply become 0 when computing min/max width.
2306         // Fixed margins can be added in as is.
2307         Length startMarginLength = childStyle.marginStartUsing(&amp;styleToUse);
2308         Length endMarginLength = childStyle.marginEndUsing(&amp;styleToUse);
2309         LayoutUnit margin;
2310         LayoutUnit marginStart;
2311         LayoutUnit marginEnd;
2312         if (startMarginLength.isFixed())
2313             marginStart += startMarginLength.value();
2314         if (endMarginLength.isFixed())
2315             marginEnd += endMarginLength.value();
2316         margin = marginStart + marginEnd;
2317 
2318         LayoutUnit childMinPreferredLogicalWidth, childMaxPreferredLogicalWidth;
2319         computeChildPreferredLogicalWidths(*child, childMinPreferredLogicalWidth, childMaxPreferredLogicalWidth);
2320 
2321         LayoutUnit w = childMinPreferredLogicalWidth + margin;
2322         minLogicalWidth = std::max(w, minLogicalWidth);
2323 
2324         // IE ignores tables for calculation of nowrap. Makes some sense.
2325         if (nowrap &amp;&amp; !child-&gt;isTable())
2326             maxLogicalWidth = std::max(w, maxLogicalWidth);
2327 
2328         w = childMaxPreferredLogicalWidth + margin;
2329 
2330         if (!child-&gt;isFloating()) {
2331             if (is&lt;RenderBox&gt;(*child) &amp;&amp; downcast&lt;RenderBox&gt;(*child).avoidsFloats()) {
2332                 // Determine a left and right max value based off whether or not the floats can fit in the
2333                 // margins of the object.  For negative margins, we will attempt to overlap the float if the negative margin
2334                 // is smaller than the float width.
2335                 bool ltr = containingBlock ? containingBlock-&gt;style().isLeftToRightDirection() : styleToUse.isLeftToRightDirection();
2336                 LayoutUnit marginLogicalLeft = ltr ? marginStart : marginEnd;
2337                 LayoutUnit marginLogicalRight = ltr ? marginEnd : marginStart;
2338                 LayoutUnit maxLeft = marginLogicalLeft &gt; 0 ? std::max(floatLeftWidth, marginLogicalLeft) : floatLeftWidth + marginLogicalLeft;
2339                 LayoutUnit maxRight = marginLogicalRight &gt; 0 ? std::max(floatRightWidth, marginLogicalRight) : floatRightWidth + marginLogicalRight;
2340                 w = childMaxPreferredLogicalWidth + maxLeft + maxRight;
2341                 w = std::max(w, floatLeftWidth + floatRightWidth);
2342             }
2343             else
2344                 maxLogicalWidth = std::max(floatLeftWidth + floatRightWidth, maxLogicalWidth);
2345             floatLeftWidth = floatRightWidth = 0;
2346         }
2347 
2348         if (child-&gt;isFloating()) {
2349             if (childStyle.floating() == Float::Left)
2350                 floatLeftWidth += w;
2351             else
2352                 floatRightWidth += w;
2353         } else
2354             maxLogicalWidth = std::max(w, maxLogicalWidth);
2355 
2356         child = child-&gt;nextSibling();
2357     }
2358 
2359     // Always make sure these values are non-negative.
2360     minLogicalWidth = std::max&lt;LayoutUnit&gt;(0, minLogicalWidth);
2361     maxLogicalWidth = std::max&lt;LayoutUnit&gt;(0, maxLogicalWidth);
2362 
2363     maxLogicalWidth = std::max(floatLeftWidth + floatRightWidth, maxLogicalWidth);
2364 }
2365 
2366 void RenderBlock::computeChildPreferredLogicalWidths(RenderObject&amp; child, LayoutUnit&amp; minPreferredLogicalWidth, LayoutUnit&amp; maxPreferredLogicalWidth) const
2367 {
2368     if (child.isBox() &amp;&amp; child.isHorizontalWritingMode() != isHorizontalWritingMode()) {
2369         // If the child is an orthogonal flow, child&#39;s height determines the width,
2370         // but the height is not available until layout.
2371         // http://dev.w3.org/csswg/css-writing-modes-3/#orthogonal-shrink-to-fit
2372         if (!child.needsLayout()) {
2373             minPreferredLogicalWidth = maxPreferredLogicalWidth = downcast&lt;RenderBox&gt;(child).logicalHeight();
2374             return;
2375         }
2376         minPreferredLogicalWidth = maxPreferredLogicalWidth = downcast&lt;RenderBox&gt;(child).computeLogicalHeightWithoutLayout();
2377         return;
2378     }
2379 
2380     // The preferred widths of flexbox children should never depend on override sizes. They should
2381     // always be computed without regard for any overrides that are present.
2382     Optional&lt;LayoutUnit&gt; overrideHeight;
2383     Optional&lt;LayoutUnit&gt; overrideWidth;
2384 
2385     if (child.isBox()) {
2386         auto&amp; box = downcast&lt;RenderBox&gt;(child);
2387         if (box.isFlexItem()) {
2388             if (box.hasOverrideContentLogicalHeight())
2389                 overrideHeight = Optional&lt;LayoutUnit&gt;(box.overrideContentLogicalHeight());
2390             if (box.hasOverrideContentLogicalWidth())
2391                 overrideWidth = Optional&lt;LayoutUnit&gt;(box.overrideContentLogicalWidth());
2392             box.clearOverrideContentSize();
2393         }
2394     }
2395 
2396     minPreferredLogicalWidth = child.minPreferredLogicalWidth();
2397     maxPreferredLogicalWidth = child.maxPreferredLogicalWidth();
2398 
2399     if (child.isBox()) {
2400         auto&amp; box = downcast&lt;RenderBox&gt;(child);
2401         if (overrideHeight)
2402             box.setOverrideContentLogicalHeight(overrideHeight.value());
2403         if (overrideWidth)
2404             box.setOverrideContentLogicalWidth(overrideWidth.value());
2405     }
2406 
2407     // For non-replaced blocks if the inline size is min|max-content or a definite
2408     // size the min|max-content contribution is that size plus border, padding and
2409     // margin https://drafts.csswg.org/css-sizing/#block-intrinsic
2410     if (child.isRenderBlock()) {
2411         const Length&amp; computedInlineSize = child.style().logicalWidth();
2412         if (computedInlineSize.isMaxContent())
2413             minPreferredLogicalWidth = maxPreferredLogicalWidth;
2414         else if (computedInlineSize.isMinContent())
2415             maxPreferredLogicalWidth = minPreferredLogicalWidth;
2416     }
2417 }
2418 
2419 bool RenderBlock::hasLineIfEmpty() const
2420 {
2421     if (!element())
2422         return false;
2423 
2424     if (element()-&gt;isRootEditableElement())
2425         return true;
2426 
2427     return false;
2428 }
2429 
2430 LayoutUnit RenderBlock::lineHeight(bool firstLine, LineDirectionMode direction, LinePositionMode linePositionMode) const
2431 {
2432     // Inline blocks are replaced elements. Otherwise, just pass off to
2433     // the base class.  If we&#39;re being queried as though we&#39;re the root line
2434     // box, then the fact that we&#39;re an inline-block is irrelevant, and we behave
2435     // just like a block.
2436     if (isReplaced() &amp;&amp; linePositionMode == PositionOnContainingLine)
2437         return RenderBox::lineHeight(firstLine, direction, linePositionMode);
2438 
2439     if (firstLine &amp;&amp; view().usesFirstLineRules()) {
2440         auto&amp; s = firstLineStyle();
2441         if (&amp;s != &amp;style())
2442             return s.computedLineHeight();
2443     }
2444 
2445     return style().computedLineHeight();
2446 }
2447 
2448 int RenderBlock::baselinePosition(FontBaseline baselineType, bool firstLine, LineDirectionMode direction, LinePositionMode linePositionMode) const
2449 {
2450     // Inline blocks are replaced elements. Otherwise, just pass off to
2451     // the base class.  If we&#39;re being queried as though we&#39;re the root line
2452     // box, then the fact that we&#39;re an inline-block is irrelevant, and we behave
2453     // just like a block.
2454     if (isReplaced() &amp;&amp; linePositionMode == PositionOnContainingLine) {
2455         // For &quot;leaf&quot; theme objects, let the theme decide what the baseline position is.
2456         // FIXME: Might be better to have a custom CSS property instead, so that if the theme
2457         // is turned off, checkboxes/radios will still have decent baselines.
2458         // FIXME: Need to patch form controls to deal with vertical lines.
2459         if (style().hasAppearance() &amp;&amp; !theme().isControlContainer(style().appearance()))
2460             return theme().baselinePosition(*this);
2461 
2462         // CSS2.1 states that the baseline of an inline block is the baseline of the last line box in
2463         // the normal flow.  We make an exception for marquees, since their baselines are meaningless
2464         // (the content inside them moves).  This matches WinIE as well, which just bottom-aligns them.
2465         // We also give up on finding a baseline if we have a vertical scrollbar, or if we are scrolled
2466         // vertically (e.g., an overflow:hidden block that has had scrollTop moved).
2467         bool ignoreBaseline = (layer() &amp;&amp; (layer()-&gt;marquee() || (direction == HorizontalLine ? (layer()-&gt;verticalScrollbar() || layer()-&gt;scrollOffset().y() != 0)
2468             : (layer()-&gt;horizontalScrollbar() || layer()-&gt;scrollOffset().x() != 0)))) || (isWritingModeRoot() &amp;&amp; !isRubyRun());
2469 
2470         Optional&lt;int&gt; baselinePos = ignoreBaseline ? Optional&lt;int&gt;() : inlineBlockBaseline(direction);
2471 
2472         if (isDeprecatedFlexibleBox()) {
2473             // Historically, we did this check for all baselines. But we can&#39;t
2474             // remove this code from deprecated flexbox, because it effectively
2475             // breaks -webkit-line-clamp, which is used in the wild -- we would
2476             // calculate the baseline as if -webkit-line-clamp wasn&#39;t used.
2477             // For simplicity, we use this for all uses of deprecated flexbox.
2478             LayoutUnit bottomOfContent = direction == HorizontalLine ? borderTop() + paddingTop() + contentHeight() : borderRight() + paddingRight() + contentWidth();
2479             if (baselinePos &amp;&amp; baselinePos.value() &gt; bottomOfContent)
2480                 baselinePos = Optional&lt;int&gt;();
2481         }
2482         if (baselinePos)
2483             return direction == HorizontalLine ? marginTop() + baselinePos.value() : marginRight() + baselinePos.value();
2484 
2485         return RenderBox::baselinePosition(baselineType, firstLine, direction, linePositionMode);
2486     }
2487 
2488     const RenderStyle&amp; style = firstLine ? firstLineStyle() : this-&gt;style();
2489     const FontMetrics&amp; fontMetrics = style.fontMetrics();
2490     return fontMetrics.ascent(baselineType) + (lineHeight(firstLine, direction, linePositionMode) - fontMetrics.height()) / 2;
2491 }
2492 
2493 LayoutUnit RenderBlock::minLineHeightForReplacedRenderer(bool isFirstLine, LayoutUnit replacedHeight) const
2494 {
2495     if (!document().inNoQuirksMode() &amp;&amp; replacedHeight)
2496         return replacedHeight;
2497 
2498     const RenderStyle&amp; style = isFirstLine ? firstLineStyle() : this-&gt;style();
2499     if (!(style.lineBoxContain() &amp; LineBoxContainBlock))
2500         return 0;
2501 
2502     return std::max&lt;LayoutUnit&gt;(replacedHeight, lineHeight(isFirstLine, isHorizontalWritingMode() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes));
2503 }
2504 
2505 Optional&lt;int&gt; RenderBlock::firstLineBaseline() const
2506 {
2507     if (isWritingModeRoot() &amp;&amp; !isRubyRun())
2508         return Optional&lt;int&gt;();
2509 
2510     for (RenderBox* curr = firstChildBox(); curr; curr = curr-&gt;nextSiblingBox()) {
2511         if (!curr-&gt;isFloatingOrOutOfFlowPositioned()) {
2512             if (Optional&lt;int&gt; result = curr-&gt;firstLineBaseline())
2513                 return Optional&lt;int&gt;(curr-&gt;logicalTop() + result.value()); // Translate to our coordinate space.
2514         }
2515     }
2516 
2517     return Optional&lt;int&gt;();
2518 }
2519 
2520 Optional&lt;int&gt; RenderBlock::inlineBlockBaseline(LineDirectionMode lineDirection) const
2521 {
2522     if (isWritingModeRoot() &amp;&amp; !isRubyRun())
2523         return Optional&lt;int&gt;();
2524 
2525     bool haveNormalFlowChild = false;
2526     for (auto* box = lastChildBox(); box; box = box-&gt;previousSiblingBox()) {
2527         if (box-&gt;isFloatingOrOutOfFlowPositioned())
2528             continue;
2529         haveNormalFlowChild = true;
2530         if (Optional&lt;int&gt; result = box-&gt;inlineBlockBaseline(lineDirection))
2531             return Optional&lt;int&gt;(box-&gt;logicalTop() + result.value()); // Translate to our coordinate space.
2532     }
2533 
2534     if (!haveNormalFlowChild &amp;&amp; hasLineIfEmpty()) {
2535         auto&amp; fontMetrics = firstLineStyle().fontMetrics();
2536         return Optional&lt;int&gt;(fontMetrics.ascent()
2537             + (lineHeight(true, lineDirection, PositionOfInteriorLineBoxes) - fontMetrics.height()) / 2
2538             + (lineDirection == HorizontalLine ? borderTop() + paddingTop() : borderRight() + paddingRight()));
2539     }
2540 
2541     return Optional&lt;int&gt;();
2542 }
2543 
2544 static inline bool isRenderBlockFlowOrRenderButton(RenderElement&amp; renderElement)
2545 {
2546     // We include isRenderButton in this check because buttons are implemented
2547     // using flex box but should still support first-line|first-letter.
2548     // The flex box and specs require that flex box and grid do not support
2549     // first-line|first-letter, though.
2550     // FIXME: Remove when buttons are implemented with align-items instead of
2551     // flex box.
2552     return renderElement.isRenderBlockFlow() || renderElement.isRenderButton();
2553 }
2554 
2555 RenderBlock* RenderBlock::firstLineBlock() const
2556 {
2557     RenderBlock* firstLineBlock = const_cast&lt;RenderBlock*&gt;(this);
2558     bool hasPseudo = false;
2559     while (true) {
2560         hasPseudo = firstLineBlock-&gt;style().hasPseudoStyle(PseudoId::FirstLine);
2561         if (hasPseudo)
2562             break;
2563         RenderElement* parentBlock = firstLineBlock-&gt;parent();
2564         if (firstLineBlock-&gt;isReplaced() || firstLineBlock-&gt;isFloating()
2565             || !parentBlock || parentBlock-&gt;firstChild() != firstLineBlock || !isRenderBlockFlowOrRenderButton(*parentBlock))
2566             break;
2567         firstLineBlock = downcast&lt;RenderBlock&gt;(parentBlock);
2568     }
2569 
2570     if (!hasPseudo)
2571         return nullptr;
2572 
2573     return firstLineBlock;
2574 }
2575 
2576 static inline RenderBlock* findFirstLetterBlock(RenderBlock* start)
2577 {
2578     RenderBlock* firstLetterBlock = start;
2579     while (true) {
2580         bool canHaveFirstLetterRenderer = firstLetterBlock-&gt;style().hasPseudoStyle(PseudoId::FirstLetter)
2581             &amp;&amp; firstLetterBlock-&gt;canHaveGeneratedChildren()
2582             &amp;&amp; isRenderBlockFlowOrRenderButton(*firstLetterBlock);
2583         if (canHaveFirstLetterRenderer)
2584             return firstLetterBlock;
2585 
2586         RenderElement* parentBlock = firstLetterBlock-&gt;parent();
2587         if (firstLetterBlock-&gt;isReplaced() || !parentBlock || parentBlock-&gt;firstChild() != firstLetterBlock
2588             || !isRenderBlockFlowOrRenderButton(*parentBlock))
2589             return nullptr;
2590         firstLetterBlock = downcast&lt;RenderBlock&gt;(parentBlock);
2591     }
2592 
2593     return nullptr;
2594 }
2595 
2596 void RenderBlock::getFirstLetter(RenderObject*&amp; firstLetter, RenderElement*&amp; firstLetterContainer, RenderObject* skipObject)
2597 {
2598     firstLetter = nullptr;
2599     firstLetterContainer = nullptr;
2600 
2601     if (!view().usesFirstLetterRules())
2602         return;
2603 
2604     // Don&#39;t recur
2605     if (style().styleType() == PseudoId::FirstLetter)
2606         return;
2607 
2608     // FIXME: We need to destroy the first-letter object if it is no longer the first child. Need to find
2609     // an efficient way to check for that situation though before implementing anything.
2610     firstLetterContainer = findFirstLetterBlock(this);
2611     if (!firstLetterContainer)
2612         return;
2613 
2614     // Drill into inlines looking for our first text descendant.
2615     firstLetter = firstLetterContainer-&gt;firstChild();
2616     while (firstLetter) {
2617         if (is&lt;RenderText&gt;(*firstLetter)) {
2618             if (firstLetter == skipObject) {
2619                 firstLetter = firstLetter-&gt;nextSibling();
2620                 continue;
2621             }
2622 
2623             break;
2624         }
2625 
2626         RenderElement&amp; current = downcast&lt;RenderElement&gt;(*firstLetter);
2627         if (is&lt;RenderListMarker&gt;(current))
2628             firstLetter = current.nextSibling();
2629         else if (current.isFloatingOrOutOfFlowPositioned()) {
2630             if (current.style().styleType() == PseudoId::FirstLetter) {
2631                 firstLetter = current.firstChild();
2632                 break;
2633             }
2634             firstLetter = current.nextSibling();
2635         } else if (current.isReplaced() || is&lt;RenderButton&gt;(current) || is&lt;RenderMenuList&gt;(current))
2636             break;
2637         else if (current.isFlexibleBoxIncludingDeprecated() || current.isRenderGrid())
2638             firstLetter = current.nextSibling();
2639         else if (current.style().hasPseudoStyle(PseudoId::FirstLetter) &amp;&amp; current.canHaveGeneratedChildren())  {
2640             // We found a lower-level node with first-letter, which supersedes the higher-level style
2641             firstLetterContainer = &amp;current;
2642             firstLetter = current.firstChild();
2643         } else
2644             firstLetter = current.firstChild();
2645     }
2646 
2647     if (!firstLetter)
2648         firstLetterContainer = nullptr;
2649 }
2650 
2651 RenderFragmentedFlow* RenderBlock::cachedEnclosingFragmentedFlow() const
2652 {
2653     RenderBlockRareData* rareData = getBlockRareData(*this);
2654 
2655     if (!rareData || !rareData-&gt;m_enclosingFragmentedFlow)
2656         return nullptr;
2657 
2658     return rareData-&gt;m_enclosingFragmentedFlow.value().get();
2659 }
2660 
2661 bool RenderBlock::cachedEnclosingFragmentedFlowNeedsUpdate() const
2662 {
2663     RenderBlockRareData* rareData = getBlockRareData(*this);
2664 
2665     if (!rareData || !rareData-&gt;m_enclosingFragmentedFlow)
2666         return true;
2667 
2668     return false;
2669 }
2670 
2671 void RenderBlock::setCachedEnclosingFragmentedFlowNeedsUpdate()
2672 {
2673     RenderBlockRareData&amp; rareData = ensureBlockRareData(*this);
2674     rareData.m_enclosingFragmentedFlow = WTF::nullopt;
2675 }
2676 
2677 RenderFragmentedFlow* RenderBlock::updateCachedEnclosingFragmentedFlow(RenderFragmentedFlow* fragmentedFlow) const
2678 {
2679     RenderBlockRareData&amp; rareData = ensureBlockRareData(*this);
2680     rareData.m_enclosingFragmentedFlow = makeWeakPtr(fragmentedFlow);
2681 
2682     return fragmentedFlow;
2683 }
2684 
2685 RenderFragmentedFlow* RenderBlock::locateEnclosingFragmentedFlow() const
2686 {
2687     RenderBlockRareData* rareData = getBlockRareData(*this);
2688     if (!rareData || !rareData-&gt;m_enclosingFragmentedFlow)
2689         return updateCachedEnclosingFragmentedFlow(RenderBox::locateEnclosingFragmentedFlow());
2690 
2691     ASSERT(rareData-&gt;m_enclosingFragmentedFlow.value() == RenderBox::locateEnclosingFragmentedFlow());
2692     return rareData-&gt;m_enclosingFragmentedFlow.value().get();
2693 }
2694 
2695 void RenderBlock::resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants(RenderFragmentedFlow*)
2696 {
2697     if (fragmentedFlowState() == NotInsideFragmentedFlow)
2698         return;
2699 
2700     if (cachedEnclosingFragmentedFlowNeedsUpdate())
2701         return;
2702 
2703     auto* fragmentedFlow = cachedEnclosingFragmentedFlow();
2704     setCachedEnclosingFragmentedFlowNeedsUpdate();
2705     RenderElement::resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants(fragmentedFlow);
2706 }
2707 
2708 LayoutUnit RenderBlock::paginationStrut() const
2709 {
2710     RenderBlockRareData* rareData = getBlockRareData(*this);
2711     return rareData ? rareData-&gt;m_paginationStrut : 0_lu;
2712 }
2713 
2714 LayoutUnit RenderBlock::pageLogicalOffset() const
2715 {
2716     RenderBlockRareData* rareData = getBlockRareData(*this);
2717     return rareData ? rareData-&gt;m_pageLogicalOffset : 0_lu;
2718 }
2719 
2720 void RenderBlock::setPaginationStrut(LayoutUnit strut)
2721 {
2722     RenderBlockRareData* rareData = getBlockRareData(*this);
2723     if (!rareData) {
2724         if (!strut)
2725             return;
2726         rareData = &amp;ensureBlockRareData(*this);
2727     }
2728     rareData-&gt;m_paginationStrut = strut;
2729 }
2730 
2731 void RenderBlock::setPageLogicalOffset(LayoutUnit logicalOffset)
2732 {
2733     RenderBlockRareData* rareData = getBlockRareData(*this);
2734     if (!rareData) {
2735         if (!logicalOffset)
2736             return;
2737         rareData = &amp;ensureBlockRareData(*this);
2738     }
2739     rareData-&gt;m_pageLogicalOffset = logicalOffset;
2740 }
2741 
2742 void RenderBlock::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
2743 {
2744     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2745     // above and below us (thus getting merged with them to form a single irregular shape).
2746     if (auto* continuation = this-&gt;continuation()) {
2747         // FIXME: This is wrong for block-flows that are horizontal.
2748         // https://bugs.webkit.org/show_bug.cgi?id=46781
2749         rects.append(snappedIntRect(accumulatedOffset.x(), accumulatedOffset.y() - collapsedMarginBefore(), width(), height() + collapsedMarginBefore() + collapsedMarginAfter()));
2750         continuation-&gt;absoluteRects(rects, accumulatedOffset - toLayoutSize(location() + inlineContinuation()-&gt;containingBlock()-&gt;location()));
2751     } else
2752         rects.append(snappedIntRect(accumulatedOffset, size()));
2753 }
2754 
2755 void RenderBlock::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
2756 {
2757     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2758     // above and below us (thus getting merged with them to form a single irregular shape).
2759     auto* continuation = this-&gt;continuation();
2760     FloatRect localRect = continuation
2761         ? FloatRect(0, -collapsedMarginBefore(), width(), height() + collapsedMarginBefore() + collapsedMarginAfter())
2762         : FloatRect(0, 0, width(), height());
2763 
2764     // FIXME: This is wrong for block-flows that are horizontal.
2765     // https://bugs.webkit.org/show_bug.cgi?id=46781
2766     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2767     if (!fragmentedFlow || !fragmentedFlow-&gt;absoluteQuadsForBox(quads, wasFixed, this, localRect.y(), localRect.maxY()))
2768         quads.append(localToAbsoluteQuad(localRect, UseTransforms, wasFixed));
2769 
2770     if (continuation)
2771         continuation-&gt;absoluteQuads(quads, wasFixed);
2772 }
2773 
2774 LayoutRect RenderBlock::rectWithOutlineForRepaint(const RenderLayerModelObject* repaintContainer, LayoutUnit outlineWidth) const
2775 {
2776     LayoutRect r(RenderBox::rectWithOutlineForRepaint(repaintContainer, outlineWidth));
2777     if (isContinuation())
2778         r.inflateY(collapsedMarginBefore()); // FIXME: This is wrong for block-flows that are horizontal.
2779     return r;
2780 }
2781 
2782 void RenderBlock::updateDragState(bool dragOn)
2783 {
2784     RenderBox::updateDragState(dragOn);
2785     if (RenderBoxModelObject* continuation = this-&gt;continuation())
2786         continuation-&gt;updateDragState(dragOn);
2787 }
2788 
2789 const RenderStyle&amp; RenderBlock::outlineStyleForRepaint() const
2790 {
2791     if (auto* continuation = this-&gt;continuation())
2792         return continuation-&gt;style();
2793     return RenderElement::outlineStyleForRepaint();
2794 }
2795 
2796 void RenderBlock::updateHitTestResult(HitTestResult&amp; result, const LayoutPoint&amp; point)
2797 {
2798     if (result.innerNode())
2799         return;
2800 
2801     if (Node* n = nodeForHitTest()) {
2802         result.setInnerNode(n);
2803         if (!result.innerNonSharedNode())
2804             result.setInnerNonSharedNode(n);
2805         result.setLocalPoint(point);
2806     }
2807 }
2808 
2809 LayoutRect RenderBlock::localCaretRect(InlineBox* inlineBox, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine)
2810 {
2811     // Do the normal calculation in most cases.
2812     if (firstChild())
2813         return RenderBox::localCaretRect(inlineBox, caretOffset, extraWidthToEndOfLine);
2814 
2815     LayoutRect caretRect = localCaretRectForEmptyElement(width(), textIndentOffset());
2816 
2817     // FIXME: Does this need to adjust for vertical orientation?
2818     if (extraWidthToEndOfLine)
2819         *extraWidthToEndOfLine = width() - caretRect.maxX();
2820 
2821     return caretRect;
2822 }
2823 
2824 void RenderBlock::addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp;, const LayoutPoint&amp;, const RenderLayerModelObject*)
2825 {
2826     ASSERT_NOT_REACHED();
2827 }
2828 
2829 void RenderBlock::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject* paintContainer)
2830 {
2831     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2832     // above and below us (thus getting merged with them to form a single irregular shape).
2833     auto* inlineContinuation = this-&gt;inlineContinuation();
2834     if (inlineContinuation) {
2835         // FIXME: This check really isn&#39;t accurate.
2836         bool nextInlineHasLineBox = inlineContinuation-&gt;firstLineBox();
2837         // FIXME: This is wrong. The principal renderer may not be the continuation preceding this block.
2838         // FIXME: This is wrong for block-flows that are horizontal.
2839         // https://bugs.webkit.org/show_bug.cgi?id=46781
2840         bool prevInlineHasLineBox = downcast&lt;RenderInline&gt;(*inlineContinuation-&gt;element()-&gt;renderer()).firstLineBox();
2841         float topMargin = prevInlineHasLineBox ? collapsedMarginBefore() : 0_lu;
2842         float bottomMargin = nextInlineHasLineBox ? collapsedMarginAfter() : 0_lu;
2843         LayoutRect rect(additionalOffset.x(), additionalOffset.y() - topMargin, width(), height() + topMargin + bottomMargin);
2844         if (!rect.isEmpty())
2845             rects.append(rect);
2846     } else if (width() &amp;&amp; height())
2847         rects.append(LayoutRect(additionalOffset, size()));
2848 
2849     if (!hasOverflowClip() &amp;&amp; !hasControlClip()) {
2850         if (childrenInline())
2851             addFocusRingRectsForInlineChildren(rects, additionalOffset, paintContainer);
2852 
2853         for (auto&amp; box : childrenOfType&lt;RenderBox&gt;(*this)) {
2854             if (is&lt;RenderListMarker&gt;(box))
2855                 continue;
2856 
2857             FloatPoint pos;
2858             // FIXME: This doesn&#39;t work correctly with transforms.
2859             if (box.layer())
2860                 pos = box.localToContainerPoint(FloatPoint(), paintContainer);
2861             else
2862                 pos = FloatPoint(additionalOffset.x() + box.x(), additionalOffset.y() + box.y());
2863             box.addFocusRingRects(rects, flooredLayoutPoint(pos), paintContainer);
2864         }
2865     }
2866 
2867     if (inlineContinuation)
2868         inlineContinuation-&gt;addFocusRingRects(rects, flooredLayoutPoint(LayoutPoint(additionalOffset + inlineContinuation-&gt;containingBlock()-&gt;location() - location())), paintContainer);
2869 }
2870 
2871 RenderPtr&lt;RenderBlock&gt; RenderBlock::createAnonymousBlockWithStyleAndDisplay(Document&amp; document, const RenderStyle&amp; style, DisplayType display)
2872 {
2873     // FIXME: Do we need to convert all our inline displays to block-type in the anonymous logic ?
2874     RenderPtr&lt;RenderBlock&gt; newBox;
2875     if (display == DisplayType::Flex || display == DisplayType::InlineFlex)
2876         newBox = createRenderer&lt;RenderFlexibleBox&gt;(document, RenderStyle::createAnonymousStyleWithDisplay(style, DisplayType::Flex));
2877     else
2878         newBox = createRenderer&lt;RenderBlockFlow&gt;(document, RenderStyle::createAnonymousStyleWithDisplay(style, DisplayType::Block));
2879 
2880     newBox-&gt;initializeStyle();
2881     return newBox;
2882 }
2883 
2884 LayoutUnit RenderBlock::offsetFromLogicalTopOfFirstPage() const
2885 {
2886     auto* layoutState = view().frameView().layoutContext().layoutState();
2887     if (layoutState &amp;&amp; !layoutState-&gt;isPaginated())
2888         return 0;
2889 
2890     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2891     if (fragmentedFlow)
2892         return fragmentedFlow-&gt;offsetFromLogicalTopOfFirstFragment(this);
2893 
2894     if (layoutState) {
2895         ASSERT(layoutState-&gt;renderer() == this);
2896 
2897         LayoutSize offsetDelta = layoutState-&gt;layoutOffset() - layoutState-&gt;pageOffset();
2898         return isHorizontalWritingMode() ? offsetDelta.height() : offsetDelta.width();
2899     }
2900 
2901     ASSERT_NOT_REACHED();
2902     return 0;
2903 }
2904 
2905 RenderFragmentContainer* RenderBlock::fragmentAtBlockOffset(LayoutUnit blockOffset) const
2906 {
2907     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2908     if (!fragmentedFlow || !fragmentedFlow-&gt;hasValidFragmentInfo())
2909         return 0;
2910 
2911     return fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstPage() + blockOffset, true);
2912 }
2913 
2914 static bool canComputeFragmentRangeForBox(const RenderBlock&amp; parentBlock, const RenderBox&amp; childBox, const RenderFragmentedFlow* enclosingFragmentedFlow)
2915 {
2916     if (!enclosingFragmentedFlow)
2917         return false;
2918 
2919     if (!enclosingFragmentedFlow-&gt;hasFragments())
2920         return false;
2921 
2922     if (!childBox.canHaveOutsideFragmentRange())
2923         return false;
2924 
2925     return enclosingFragmentedFlow-&gt;hasCachedFragmentRangeForBox(parentBlock);
2926 }
2927 
2928 bool RenderBlock::childBoxIsUnsplittableForFragmentation(const RenderBox&amp; child) const
2929 {
2930     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2931     bool checkColumnBreaks = fragmentedFlow &amp;&amp; fragmentedFlow-&gt;shouldCheckColumnBreaks();
2932     bool checkPageBreaks = !checkColumnBreaks &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;pageLogicalHeight();
2933     return child.isUnsplittableForPagination() || child.style().breakInside() == BreakInside::Avoid
2934         || (checkColumnBreaks &amp;&amp; child.style().breakInside() == BreakInside::AvoidColumn)
2935         || (checkPageBreaks &amp;&amp; child.style().breakInside() == BreakInside::AvoidPage);
2936 }
2937 
2938 void RenderBlock::computeFragmentRangeForBoxChild(const RenderBox&amp; box) const
2939 {
2940     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2941     ASSERT(canComputeFragmentRangeForBox(*this, box, fragmentedFlow));
2942 
2943     RenderFragmentContainer* startFragment;
2944     RenderFragmentContainer* endFragment;
2945     LayoutUnit offsetFromLogicalTopOfFirstFragment = box.offsetFromLogicalTopOfFirstPage();
2946     if (childBoxIsUnsplittableForFragmentation(box))
2947         startFragment = endFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment, true);
2948     else {
2949         startFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment, true);
2950         endFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment + logicalHeightForChild(box), true);
2951     }
2952 
2953     fragmentedFlow-&gt;setFragmentRangeForBox(box, startFragment, endFragment);
2954 }
2955 
2956 void RenderBlock::estimateFragmentRangeForBoxChild(const RenderBox&amp; box) const
2957 {
2958     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2959     if (!canComputeFragmentRangeForBox(*this, box, fragmentedFlow))
2960         return;
2961 
2962     if (childBoxIsUnsplittableForFragmentation(box)) {
2963         computeFragmentRangeForBoxChild(box);
2964         return;
2965     }
2966 
2967     auto estimatedValues = box.computeLogicalHeight(RenderFragmentedFlow::maxLogicalHeight(), logicalTopForChild(box));
2968     LayoutUnit offsetFromLogicalTopOfFirstFragment = box.offsetFromLogicalTopOfFirstPage();
2969     RenderFragmentContainer* startFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment, true);
2970     RenderFragmentContainer* endFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment + estimatedValues.m_extent, true);
2971 
2972     fragmentedFlow-&gt;setFragmentRangeForBox(box, startFragment, endFragment);
2973 }
2974 
2975 bool RenderBlock::updateFragmentRangeForBoxChild(const RenderBox&amp; box) const
2976 {
2977     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2978     if (!canComputeFragmentRangeForBox(*this, box, fragmentedFlow))
2979         return false;
2980 
2981     RenderFragmentContainer* startFragment = nullptr;
2982     RenderFragmentContainer* endFragment = nullptr;
2983     fragmentedFlow-&gt;getFragmentRangeForBox(&amp;box, startFragment, endFragment);
2984 
2985     computeFragmentRangeForBoxChild(box);
2986 
2987     RenderFragmentContainer* newStartFragment = nullptr;
2988     RenderFragmentContainer* newEndFragment = nullptr;
2989     fragmentedFlow-&gt;getFragmentRangeForBox(&amp;box, newStartFragment, newEndFragment);
2990 
2991 
2992     // Changing the start fragment means we shift everything and a relayout is needed.
2993     if (newStartFragment != startFragment)
2994         return true;
2995 
2996     // The fragment range of the box has changed. Some boxes (e.g floats) may have been positioned assuming
2997     // a different range.
2998     if (box.needsLayoutAfterFragmentRangeChange() &amp;&amp; newEndFragment != endFragment)
2999         return true;
3000 
3001     return false;
3002 }
3003 
3004 LayoutUnit RenderBlock::collapsedMarginBeforeForChild(const RenderBox&amp; child) const
3005 {
3006     // If the child has the same directionality as we do, then we can just return its
3007     // collapsed margin.
3008     if (!child.isWritingModeRoot())
3009         return child.collapsedMarginBefore();
3010 
3011     // The child has a different directionality.  If the child is parallel, then it&#39;s just
3012     // flipped relative to us.  We can use the collapsed margin for the opposite edge.
3013     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
3014         return child.collapsedMarginAfter();
3015 
3016     // The child is perpendicular to us, which means its margins don&#39;t collapse but are on the
3017     // &quot;logical left/right&quot; sides of the child box.  We can just return the raw margin in this case.
3018     return marginBeforeForChild(child);
3019 }
3020 
3021 LayoutUnit RenderBlock::collapsedMarginAfterForChild(const RenderBox&amp; child) const
3022 {
3023     // If the child has the same directionality as we do, then we can just return its
3024     // collapsed margin.
3025     if (!child.isWritingModeRoot())
3026         return child.collapsedMarginAfter();
3027 
3028     // The child has a different directionality.  If the child is parallel, then it&#39;s just
3029     // flipped relative to us.  We can use the collapsed margin for the opposite edge.
3030     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
3031         return child.collapsedMarginBefore();
3032 
3033     // The child is perpendicular to us, which means its margins don&#39;t collapse but are on the
3034     // &quot;logical left/right&quot; side of the child box.  We can just return the raw margin in this case.
3035     return marginAfterForChild(child);
3036 }
3037 
3038 bool RenderBlock::hasMarginBeforeQuirk(const RenderBox&amp; child) const
3039 {
3040     // If the child has the same directionality as we do, then we can just return its
3041     // margin quirk.
3042     if (!child.isWritingModeRoot())
3043         return is&lt;RenderBlock&gt;(child) ? downcast&lt;RenderBlock&gt;(child).hasMarginBeforeQuirk() : child.style().hasMarginBeforeQuirk();
3044 
3045     // The child has a different directionality. If the child is parallel, then it&#39;s just
3046     // flipped relative to us. We can use the opposite edge.
3047     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
3048         return is&lt;RenderBlock&gt;(child) ? downcast&lt;RenderBlock&gt;(child).hasMarginAfterQuirk() : child.style().hasMarginAfterQuirk();
3049 
3050     // The child is perpendicular to us and box sides are never quirky in html.css, and we don&#39;t really care about
3051     // whether or not authors specified quirky ems, since they&#39;re an implementation detail.
3052     return false;
3053 }
3054 
3055 bool RenderBlock::hasMarginAfterQuirk(const RenderBox&amp; child) const
3056 {
3057     // If the child has the same directionality as we do, then we can just return its
3058     // margin quirk.
3059     if (!child.isWritingModeRoot())
3060         return is&lt;RenderBlock&gt;(child) ? downcast&lt;RenderBlock&gt;(child).hasMarginAfterQuirk() : child.style().hasMarginAfterQuirk();
3061 
3062     // The child has a different directionality. If the child is parallel, then it&#39;s just
3063     // flipped relative to us. We can use the opposite edge.
3064     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
3065         return is&lt;RenderBlock&gt;(child) ? downcast&lt;RenderBlock&gt;(child).hasMarginBeforeQuirk() : child.style().hasMarginBeforeQuirk();
3066 
3067     // The child is perpendicular to us and box sides are never quirky in html.css, and we don&#39;t really care about
3068     // whether or not authors specified quirky ems, since they&#39;re an implementation detail.
3069     return false;
3070 }
3071 
3072 const char* RenderBlock::renderName() const
3073 {
3074     if (isBody())
3075         return &quot;RenderBody&quot;; // FIXME: Temporary hack until we know that the regression tests pass.
3076     if (isFieldset())
3077         return &quot;RenderFieldSet&quot;; // FIXME: Remove eventually, but done to keep tests from breaking.
3078     if (isFloating())
3079         return &quot;RenderBlock (floating)&quot;;
3080     if (isOutOfFlowPositioned())
3081         return &quot;RenderBlock (positioned)&quot;;
3082     if (isAnonymousBlock())
3083         return &quot;RenderBlock (anonymous)&quot;;
3084     // FIXME: Temporary hack while the new generated content system is being implemented.
3085     if (isPseudoElement())
3086         return &quot;RenderBlock (generated)&quot;;
3087     if (isAnonymous())
3088         return &quot;RenderBlock (generated)&quot;;
3089     if (isRelativelyPositioned())
3090         return &quot;RenderBlock (relative positioned)&quot;;
3091     if (isStickilyPositioned())
3092         return &quot;RenderBlock (sticky positioned)&quot;;
3093     return &quot;RenderBlock&quot;;
3094 }
3095 
3096 TextRun RenderBlock::constructTextRun(StringView stringView, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)
3097 {
3098     auto textDirection = TextDirection::LTR;
3099     bool directionalOverride = style.rtlOrdering() == Order::Visual;
3100     if (flags != DefaultTextRunFlags) {
3101         if (flags &amp; RespectDirection)
3102             textDirection = style.direction();
3103         if (flags &amp; RespectDirectionOverride)
3104             directionalOverride |= isOverride(style.unicodeBidi());
3105     }
3106     return TextRun(stringView, 0, 0, expansion, textDirection, directionalOverride);
3107 }
3108 
3109 TextRun RenderBlock::constructTextRun(const String&amp; string, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)
3110 {
3111     return constructTextRun(StringView(string), style, expansion, flags);
3112 }
3113 
3114 TextRun RenderBlock::constructTextRun(const AtomicString&amp; atomicString, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)
3115 {
3116     return constructTextRun(StringView(atomicString), style, expansion, flags);
3117 }
3118 
3119 TextRun RenderBlock::constructTextRun(const RenderText&amp; text, const RenderStyle&amp; style, ExpansionBehavior expansion)
3120 {
3121     return constructTextRun(text.stringView(), style, expansion);
3122 }
3123 
3124 TextRun RenderBlock::constructTextRun(const RenderText&amp; text, unsigned offset, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3125 {
3126     unsigned stop = offset + length;
3127     ASSERT(stop &lt;= text.text().length());
3128     return constructTextRun(text.stringView(offset, stop), style, expansion);
3129 }
3130 
3131 TextRun RenderBlock::constructTextRun(const LChar* characters, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3132 {
3133     return constructTextRun(StringView(characters, length), style, expansion);
3134 }
3135 
3136 TextRun RenderBlock::constructTextRun(const UChar* characters, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3137 {
3138     return constructTextRun(StringView(characters, length), style, expansion);
3139 }
3140 
3141 #ifndef NDEBUG
3142 void RenderBlock::checkPositionedObjectsNeedLayout()
3143 {
3144     auto* positionedDescendants = positionedObjects();
3145     if (!positionedDescendants)
3146         return;
3147 
3148     for (auto* renderer : *positionedDescendants)
3149         ASSERT(!renderer-&gt;needsLayout());
3150 }
3151 
3152 #endif
3153 
3154 bool RenderBlock::hasDefiniteLogicalHeight() const
3155 {
3156     return (bool)availableLogicalHeightForPercentageComputation();
3157 }
3158 
3159 Optional&lt;LayoutUnit&gt; RenderBlock::availableLogicalHeightForPercentageComputation() const
3160 {
3161     Optional&lt;LayoutUnit&gt; availableHeight;
3162 
3163     // For anonymous blocks that are skipped during percentage height calculation,
3164     // we consider them to have an indefinite height.
3165     if (skipContainingBlockForPercentHeightCalculation(*this, false))
3166         return availableHeight;
3167 
3168     const auto&amp; styleToUse = style();
3169 
3170     // A positioned element that specified both top/bottom or that specifies
3171     // height should be treated as though it has a height explicitly specified
3172     // that can be used for any percentage computations.
3173     bool isOutOfFlowPositionedWithSpecifiedHeight = isOutOfFlowPositioned() &amp;&amp; (!styleToUse.logicalHeight().isAuto() || (!styleToUse.logicalTop().isAuto() &amp;&amp; !styleToUse.logicalBottom().isAuto()));
3174 
3175     Optional&lt;LayoutUnit&gt; stretchedFlexHeight;
3176     if (isFlexItem())
3177         stretchedFlexHeight = downcast&lt;RenderFlexibleBox&gt;(parent())-&gt;childLogicalHeightForPercentageResolution(*this);
3178 
3179     if (stretchedFlexHeight)
3180         availableHeight = stretchedFlexHeight;
3181     else if (isGridItem() &amp;&amp; hasOverrideContentLogicalHeight())
3182         availableHeight = overrideContentLogicalHeight();
3183     else if (styleToUse.logicalHeight().isFixed()) {
3184         LayoutUnit contentBoxHeight = adjustContentBoxLogicalHeightForBoxSizing((LayoutUnit)styleToUse.logicalHeight().value());
3185         availableHeight = std::max(0_lu, constrainContentBoxLogicalHeightByMinMax(contentBoxHeight - scrollbarLogicalHeight(), WTF::nullopt));
3186     } else if (styleToUse.logicalHeight().isPercentOrCalculated() &amp;&amp; !isOutOfFlowPositionedWithSpecifiedHeight) {
3187         Optional&lt;LayoutUnit&gt; heightWithScrollbar = computePercentageLogicalHeight(styleToUse.logicalHeight());
3188         if (heightWithScrollbar) {
3189             LayoutUnit contentBoxHeightWithScrollbar = adjustContentBoxLogicalHeightForBoxSizing(heightWithScrollbar.value());
3190             // We need to adjust for min/max height because this method does not
3191             // handle the min/max of the current block, its caller does. So the
3192             // return value from the recursive call will not have been adjusted
3193             // yet.
3194             LayoutUnit contentBoxHeight = constrainContentBoxLogicalHeightByMinMax(contentBoxHeightWithScrollbar - scrollbarLogicalHeight(), WTF::nullopt);
3195             availableHeight = std::max(0_lu, contentBoxHeight);
3196         }
3197     } else if (isOutOfFlowPositionedWithSpecifiedHeight) {
3198         // Don&#39;t allow this to affect the block&#39; size() member variable, since this
3199         // can get called while the block is still laying out its kids.
3200         LogicalExtentComputedValues computedValues = computeLogicalHeight(logicalHeight(), 0_lu);
3201         availableHeight = computedValues.m_extent - borderAndPaddingLogicalHeight() - scrollbarLogicalHeight();
3202     } else if (isRenderView())
3203         availableHeight = view().pageOrViewLogicalHeight();
3204 
3205     return availableHeight;
3206 }
3207 
3208 void RenderBlock::layoutExcludedChildren(bool relayoutChildren)
3209 {
3210     if (!isFieldset())
3211         return;
3212 
3213     setIntrinsicBorderForFieldset(0);
3214 
3215     RenderBox* box = findFieldsetLegend();
3216     if (!box)
3217         return;
3218 
3219     box-&gt;setIsExcludedFromNormalLayout(true);
3220     for (auto&amp; child : childrenOfType&lt;RenderBox&gt;(*this)) {
3221         if (&amp;child == box || !child.isLegend())
3222             continue;
3223         child.setIsExcludedFromNormalLayout(false);
3224     }
3225 
3226     RenderBox&amp; legend = *box;
3227     if (relayoutChildren)
3228         legend.setChildNeedsLayout(MarkOnlyThis);
3229     legend.layoutIfNeeded();
3230 
3231     LayoutUnit logicalLeft;
3232     if (style().isLeftToRightDirection()) {
3233         switch (legend.style().textAlign()) {
3234         case TextAlignMode::Center:
3235             logicalLeft = (logicalWidth() - logicalWidthForChild(legend)) / 2;
3236             break;
3237         case TextAlignMode::Right:
3238             logicalLeft = logicalWidth() - borderEnd() - paddingEnd() - logicalWidthForChild(legend);
3239             break;
3240         default:
3241             logicalLeft = borderStart() + paddingStart() + marginStartForChild(legend);
3242             break;
3243         }
3244     } else {
3245         switch (legend.style().textAlign()) {
3246         case TextAlignMode::Left:
3247             logicalLeft = borderStart() + paddingStart();
3248             break;
3249         case TextAlignMode::Center: {
3250             // Make sure that the extra pixel goes to the end side in RTL (since it went to the end side
3251             // in LTR).
3252             LayoutUnit centeredWidth = logicalWidth() - logicalWidthForChild(legend);
3253             logicalLeft = centeredWidth - centeredWidth / 2;
3254             break;
3255         }
3256         default:
3257             logicalLeft = logicalWidth() - borderStart() - paddingStart() - marginStartForChild(legend) - logicalWidthForChild(legend);
3258             break;
3259         }
3260     }
3261 
3262     setLogicalLeftForChild(legend, logicalLeft);
3263 
3264     LayoutUnit fieldsetBorderBefore = borderBefore();
3265     LayoutUnit legendLogicalHeight = logicalHeightForChild(legend);
3266     LayoutUnit legendAfterMargin = marginAfterForChild(legend);
3267     LayoutUnit topPositionForLegend = std::max(0_lu, (fieldsetBorderBefore - legendLogicalHeight) / 2);
3268     LayoutUnit bottomPositionForLegend = topPositionForLegend + legendLogicalHeight + legendAfterMargin;
3269 
3270     // Place the legend now.
3271     setLogicalTopForChild(legend, topPositionForLegend);
3272 
3273     // If the bottom of the legend (including its after margin) is below the fieldset border,
3274     // then we need to add in sufficient intrinsic border to account for this gap.
3275     // FIXME: Should we support the before margin of the legend? Not entirely clear.
3276     // FIXME: Consider dropping support for the after margin of the legend. Not sure other
3277     // browsers support that anyway.
3278     if (bottomPositionForLegend &gt; fieldsetBorderBefore)
3279         setIntrinsicBorderForFieldset(bottomPositionForLegend - fieldsetBorderBefore);
3280 
3281     // Now that the legend is included in the border extent, we can set our logical height
3282     // to the borderBefore (which includes the legend and its after margin if they were bigger
3283     // than the actual fieldset border) and then add in our padding before.
3284     setLogicalHeight(borderBefore() + paddingBefore());
3285 }
3286 
3287 RenderBox* RenderBlock::findFieldsetLegend(FieldsetFindLegendOption option) const
3288 {
3289     for (auto&amp; legend : childrenOfType&lt;RenderBox&gt;(*this)) {
3290         if (option == FieldsetIgnoreFloatingOrOutOfFlow &amp;&amp; legend.isFloatingOrOutOfFlowPositioned())
3291             continue;
3292         if (legend.isLegend())
3293             return const_cast&lt;RenderBox*&gt;(&amp;legend);
3294     }
3295     return nullptr;
3296 }
3297 
3298 void RenderBlock::adjustBorderBoxRectForPainting(LayoutRect&amp; paintRect)
3299 {
3300     if (!isFieldset() || !intrinsicBorderForFieldset())
3301         return;
3302 
3303     auto* legend = findFieldsetLegend();
3304     if (!legend)
3305         return;
3306 
3307     if (style().isHorizontalWritingMode()) {
3308         LayoutUnit yOff = std::max(0_lu, (legend-&gt;height() - RenderBox::borderBefore()) / 2);
3309         paintRect.setHeight(paintRect.height() - yOff);
3310         if (style().writingMode() == TopToBottomWritingMode)
3311             paintRect.setY(paintRect.y() + yOff);
3312     } else {
3313         LayoutUnit xOff = std::max(0_lu, (legend-&gt;width() - RenderBox::borderBefore()) / 2);
3314         paintRect.setWidth(paintRect.width() - xOff);
3315         if (style().writingMode() == LeftToRightWritingMode)
3316             paintRect.setX(paintRect.x() + xOff);
3317     }
3318 }
3319 
3320 LayoutRect RenderBlock::paintRectToClipOutFromBorder(const LayoutRect&amp; paintRect)
3321 {
3322     LayoutRect clipRect;
3323     if (!isFieldset())
3324         return clipRect;
3325     auto* legend = findFieldsetLegend();
3326     if (!legend)
3327         return clipRect;
3328 
3329     LayoutUnit borderExtent = RenderBox::borderBefore();
3330     if (style().isHorizontalWritingMode()) {
3331         clipRect.setX(paintRect.x() + legend-&gt;x());
3332         clipRect.setY(style().writingMode() == TopToBottomWritingMode ? paintRect.y() : paintRect.y() + paintRect.height() - borderExtent);
3333         clipRect.setWidth(legend-&gt;width());
3334         clipRect.setHeight(borderExtent);
3335     } else {
3336         clipRect.setX(style().writingMode() == LeftToRightWritingMode ? paintRect.x() : paintRect.x() + paintRect.width() - borderExtent);
3337         clipRect.setY(paintRect.y() + legend-&gt;y());
3338         clipRect.setWidth(borderExtent);
3339         clipRect.setHeight(legend-&gt;height());
3340     }
3341     return clipRect;
3342 }
3343 
3344 LayoutUnit RenderBlock::intrinsicBorderForFieldset() const
3345 {
3346     auto* rareData = getBlockRareData(*this);
3347     return rareData ? rareData-&gt;m_intrinsicBorderForFieldset : 0_lu;
3348 }
3349 
3350 void RenderBlock::setIntrinsicBorderForFieldset(LayoutUnit padding)
3351 {
3352     auto* rareData = getBlockRareData(*this);
3353     if (!rareData) {
3354         if (!padding)
3355             return;
3356         rareData = &amp;ensureBlockRareData(*this);
3357     }
3358     rareData-&gt;m_intrinsicBorderForFieldset = padding;
3359 }
3360 
3361 LayoutUnit RenderBlock::borderTop() const
3362 {
3363     if (style().writingMode() != TopToBottomWritingMode || !intrinsicBorderForFieldset())
3364         return RenderBox::borderTop();
3365     return RenderBox::borderTop() + intrinsicBorderForFieldset();
3366 }
3367 
3368 LayoutUnit RenderBlock::borderLeft() const
3369 {
3370     if (style().writingMode() != LeftToRightWritingMode || !intrinsicBorderForFieldset())
3371         return RenderBox::borderLeft();
3372     return RenderBox::borderLeft() + intrinsicBorderForFieldset();
3373 }
3374 
3375 LayoutUnit RenderBlock::borderBottom() const
3376 {
3377     if (style().writingMode() != BottomToTopWritingMode || !intrinsicBorderForFieldset())
3378         return RenderBox::borderBottom();
3379     return RenderBox::borderBottom() + intrinsicBorderForFieldset();
3380 }
3381 
3382 LayoutUnit RenderBlock::borderRight() const
3383 {
3384     if (style().writingMode() != RightToLeftWritingMode || !intrinsicBorderForFieldset())
3385         return RenderBox::borderRight();
3386     return RenderBox::borderRight() + intrinsicBorderForFieldset();
3387 }
3388 
3389 LayoutUnit RenderBlock::borderBefore() const
3390 {
3391     return RenderBox::borderBefore() + intrinsicBorderForFieldset();
3392 }
3393 
3394 bool RenderBlock::computePreferredWidthsForExcludedChildren(LayoutUnit&amp; minWidth, LayoutUnit&amp; maxWidth) const
3395 {
3396     if (!isFieldset())
3397         return false;
3398 
3399     auto* legend = findFieldsetLegend();
3400     if (!legend)
3401         return false;
3402 
3403     legend-&gt;setIsExcludedFromNormalLayout(true);
3404 
3405     computeChildPreferredLogicalWidths(*legend, minWidth, maxWidth);
3406 
3407     // These are going to be added in later, so we subtract them out to reflect the
3408     // fact that the legend is outside the scrollable area.
3409     auto scrollbarWidth = intrinsicScrollbarLogicalWidth();
3410     minWidth -= scrollbarWidth;
3411     maxWidth -= scrollbarWidth;
3412 
3413     const auto&amp; childStyle = legend-&gt;style();
3414     auto startMarginLength = childStyle.marginStartUsing(&amp;style());
3415     auto endMarginLength = childStyle.marginEndUsing(&amp;style());
3416     LayoutUnit margin;
3417     LayoutUnit marginStart;
3418     LayoutUnit marginEnd;
3419     if (startMarginLength.isFixed())
3420         marginStart += startMarginLength.value();
3421     if (endMarginLength.isFixed())
3422         marginEnd += endMarginLength.value();
3423     margin = marginStart + marginEnd;
3424 
3425     minWidth += margin;
3426     maxWidth += margin;
3427 
3428     return true;
3429 }
3430 
3431 LayoutUnit RenderBlock::adjustBorderBoxLogicalHeightForBoxSizing(LayoutUnit height) const
3432 {
3433     // FIXME: We&#39;re doing this to match other browsers even though it&#39;s questionable.
3434     // Shouldn&#39;t height:100px mean the fieldset content gets 100px of height even if the
3435     // resulting fieldset becomes much taller because of the legend?
3436     LayoutUnit bordersPlusPadding = borderAndPaddingLogicalHeight();
3437     if (style().boxSizing() == BoxSizing::ContentBox)
3438         return height + bordersPlusPadding - intrinsicBorderForFieldset();
3439     return std::max(height, bordersPlusPadding);
3440 }
3441 
3442 LayoutUnit RenderBlock::adjustContentBoxLogicalHeightForBoxSizing(Optional&lt;LayoutUnit&gt; height) const
3443 {
3444     // FIXME: We&#39;re doing this to match other browsers even though it&#39;s questionable.
3445     // Shouldn&#39;t height:100px mean the fieldset content gets 100px of height even if the
3446     // resulting fieldset becomes much taller because of the legend?
3447     if (!height)
3448         return 0;
3449     LayoutUnit result = height.value();
3450     if (style().boxSizing() == BoxSizing::BorderBox)
3451         result -= borderAndPaddingLogicalHeight();
3452     else
3453         result -= intrinsicBorderForFieldset();
3454     return std::max(0_lu, result);
3455 }
3456 
3457 void RenderBlock::paintExcludedChildrenInBorder(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
3458 {
3459     if (!isFieldset())
3460         return;
3461 
3462     RenderBox* box = findFieldsetLegend();
3463     if (!box || !box-&gt;isExcludedFromNormalLayout() || box-&gt;hasSelfPaintingLayer())
3464         return;
3465 
3466     LayoutPoint childPoint = flipForWritingModeForChild(box, paintOffset);
3467     box-&gt;paintAsInlineBlock(paintInfo, childPoint);
3468 }
3469 
3470 bool RenderBlock::hitTestExcludedChildrenInBorder(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
3471 {
3472     if (!isFieldset())
3473         return false;
3474 
3475     auto* legend = findFieldsetLegend();
3476     if (!legend || !legend-&gt;isExcludedFromNormalLayout() || legend-&gt;hasSelfPaintingLayer())
3477         return false;
3478 
3479     HitTestAction childHitTest = hitTestAction;
3480     if (hitTestAction == HitTestChildBlockBackgrounds)
3481         childHitTest = HitTestChildBlockBackground;
3482     LayoutPoint childPoint = flipForWritingModeForChild(legend, accumulatedOffset);
3483     return legend-&gt;nodeAtPoint(request, result, locationInContainer, childPoint, childHitTest);
3484 }
3485 
3486 } // namespace WebCore
    </pre>
  </body>
</html>