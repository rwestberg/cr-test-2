<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/bindings/js/SerializedScriptValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  *
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;SerializedScriptValue.h&quot;
  29 
  30 #include &quot;BlobRegistry.h&quot;
  31 #include &quot;CryptoKeyAES.h&quot;
  32 #include &quot;CryptoKeyEC.h&quot;
  33 #include &quot;CryptoKeyHMAC.h&quot;
  34 #include &quot;CryptoKeyRSA.h&quot;
  35 #include &quot;CryptoKeyRSAComponents.h&quot;
  36 #include &quot;CryptoKeyRaw.h&quot;
  37 #include &quot;IDBValue.h&quot;
  38 #include &quot;JSBlob.h&quot;
  39 #if PLATFORM(JAVA) &amp;&amp; ENABLE(SUBTLE_CRYPTO) // todo tav
  40 #include &quot;JSCryptoKey.h&quot;
  41 #endif
  42 #include &quot;JSDOMBinding.h&quot;
  43 #include &quot;JSDOMConvertBufferSource.h&quot;
  44 #include &quot;JSDOMGlobalObject.h&quot;
  45 #include &quot;JSDOMMatrix.h&quot;
  46 #include &quot;JSDOMPoint.h&quot;
  47 #include &quot;JSDOMQuad.h&quot;
  48 #include &quot;JSDOMRect.h&quot;
  49 #include &quot;JSFile.h&quot;
  50 #include &quot;JSFileList.h&quot;
  51 #include &quot;JSImageBitmap.h&quot;
  52 #include &quot;JSImageData.h&quot;
  53 #include &quot;JSMessagePort.h&quot;
  54 #include &quot;JSNavigator.h&quot;
  55 #include &quot;JSRTCCertificate.h&quot;
  56 #include &quot;ScriptExecutionContext.h&quot;
  57 #include &quot;ScriptState.h&quot;
  58 #include &quot;SharedBuffer.h&quot;
  59 #include &quot;WebCoreJSClientData.h&quot;
  60 #include &lt;JavaScriptCore/APICast.h&gt;
<a name="2" id="anc2"></a><span class="line-removed">  61 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;</span>
  62 #include &lt;JavaScriptCore/BooleanObject.h&gt;
  63 #include &lt;JavaScriptCore/CatchScope.h&gt;
  64 #include &lt;JavaScriptCore/DateInstance.h&gt;
  65 #include &lt;JavaScriptCore/Error.h&gt;
  66 #include &lt;JavaScriptCore/Exception.h&gt;
  67 #include &lt;JavaScriptCore/ExceptionHelpers.h&gt;
  68 #include &lt;JavaScriptCore/IterationKind.h&gt;
  69 #include &lt;JavaScriptCore/JSArrayBuffer.h&gt;
  70 #include &lt;JavaScriptCore/JSArrayBufferView.h&gt;
  71 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  72 #include &lt;JavaScriptCore/JSDataView.h&gt;
  73 #include &lt;JavaScriptCore/JSMap.h&gt;
  74 #include &lt;JavaScriptCore/JSMapIterator.h&gt;
  75 #include &lt;JavaScriptCore/JSSet.h&gt;
  76 #include &lt;JavaScriptCore/JSSetIterator.h&gt;
  77 #include &lt;JavaScriptCore/JSTypedArrays.h&gt;
  78 #include &lt;JavaScriptCore/JSWebAssemblyModule.h&gt;
  79 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
  80 #include &lt;JavaScriptCore/PropertyNameArray.h&gt;
  81 #include &lt;JavaScriptCore/RegExp.h&gt;
  82 #include &lt;JavaScriptCore/RegExpObject.h&gt;
  83 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
  84 #include &lt;JavaScriptCore/TypedArrays.h&gt;
  85 #include &lt;JavaScriptCore/WasmModule.h&gt;
<a name="3" id="anc3"></a>
  86 #include &lt;limits&gt;
<a name="4" id="anc4"></a>
  87 #include &lt;wtf/MainThread.h&gt;
  88 #include &lt;wtf/RunLoop.h&gt;
  89 #include &lt;wtf/Vector.h&gt;
  90 
  91 #if CPU(BIG_ENDIAN) || CPU(MIDDLE_ENDIAN) || CPU(NEEDS_ALIGNED_ACCESS)
  92 #define ASSUME_LITTLE_ENDIAN 0
  93 #else
  94 #define ASSUME_LITTLE_ENDIAN 1
  95 #endif
  96 
  97 namespace WebCore {
  98 using namespace JSC;
  99 
 100 static const unsigned maximumFilterRecursion = 40000;
 101 
 102 enum class SerializationReturnCode {
 103     SuccessfullyCompleted,
 104     StackOverflowError,
 105     InterruptedExecutionError,
 106     ValidationError,
 107     ExistingExceptionError,
 108     DataCloneError,
 109     UnspecifiedError
 110 };
 111 
 112 enum WalkerState { StateUnknown, ArrayStartState, ArrayStartVisitMember, ArrayEndVisitMember,
 113     ObjectStartState, ObjectStartVisitMember, ObjectEndVisitMember,
 114     MapDataStartVisitEntry, MapDataEndVisitKey, MapDataEndVisitValue,
 115     SetDataStartVisitEntry, SetDataEndVisitKey };
 116 
 117 // These can&#39;t be reordered, and any new types must be added to the end of the list
 118 // When making changes to these lists please cover your new type(s) in the API test &quot;IndexedDB.StructuredCloneBackwardCompatibility&quot;
 119 enum SerializationTag {
 120     ArrayTag = 1,
 121     ObjectTag = 2,
 122     UndefinedTag = 3,
 123     NullTag = 4,
 124     IntTag = 5,
 125     ZeroTag = 6,
 126     OneTag = 7,
 127     FalseTag = 8,
 128     TrueTag = 9,
 129     DoubleTag = 10,
 130     DateTag = 11,
 131     FileTag = 12,
 132     FileListTag = 13,
 133     ImageDataTag = 14,
 134     BlobTag = 15,
 135     StringTag = 16,
 136     EmptyStringTag = 17,
 137     RegExpTag = 18,
 138     ObjectReferenceTag = 19,
 139     MessagePortReferenceTag = 20,
 140     ArrayBufferTag = 21,
 141     ArrayBufferViewTag = 22,
 142     ArrayBufferTransferTag = 23,
 143     TrueObjectTag = 24,
 144     FalseObjectTag = 25,
 145     StringObjectTag = 26,
 146     EmptyStringObjectTag = 27,
 147     NumberObjectTag = 28,
 148     SetObjectTag = 29,
 149     MapObjectTag = 30,
 150     NonMapPropertiesTag = 31,
 151     NonSetPropertiesTag = 32,
 152 #if ENABLE(WEB_CRYPTO)
 153     CryptoKeyTag = 33,
 154 #endif
 155     SharedArrayBufferTag = 34,
 156 #if ENABLE(WEBASSEMBLY)
 157     WasmModuleTag = 35,
 158 #endif
 159     DOMPointReadOnlyTag = 36,
 160     DOMPointTag = 37,
 161     DOMRectReadOnlyTag = 38,
 162     DOMRectTag = 39,
 163     DOMMatrixReadOnlyTag = 40,
 164     DOMMatrixTag = 41,
 165     DOMQuadTag = 42,
 166     ImageBitmapTransferTag = 43,
 167 #if ENABLE(WEB_RTC)
 168     RTCCertificateTag = 44,
 169 #endif
 170     ErrorTag = 255
 171 };
 172 
 173 enum ArrayBufferViewSubtag {
 174     DataViewTag = 0,
 175     Int8ArrayTag = 1,
 176     Uint8ArrayTag = 2,
 177     Uint8ClampedArrayTag = 3,
 178     Int16ArrayTag = 4,
 179     Uint16ArrayTag = 5,
 180     Int32ArrayTag = 6,
 181     Uint32ArrayTag = 7,
 182     Float32ArrayTag = 8,
 183     Float64ArrayTag = 9
 184 };
 185 
 186 static unsigned typedArrayElementSize(ArrayBufferViewSubtag tag)
 187 {
 188     switch (tag) {
 189     case DataViewTag:
 190     case Int8ArrayTag:
 191     case Uint8ArrayTag:
 192     case Uint8ClampedArrayTag:
 193         return 1;
 194     case Int16ArrayTag:
 195     case Uint16ArrayTag:
 196         return 2;
 197     case Int32ArrayTag:
 198     case Uint32ArrayTag:
 199     case Float32ArrayTag:
 200         return 4;
 201     case Float64ArrayTag:
 202         return 8;
 203     default:
 204         return 0;
 205     }
 206 
 207 }
 208 
 209 #if ENABLE(WEB_CRYPTO)
 210 
 211 const uint32_t currentKeyFormatVersion = 1;
 212 
 213 enum class CryptoKeyClassSubtag {
 214     HMAC = 0,
 215     AES = 1,
 216     RSA = 2,
 217     EC = 3,
 218     Raw = 4,
 219 };
 220 const uint8_t cryptoKeyClassSubtagMaximumValue = 4;
 221 
 222 enum class CryptoKeyAsymmetricTypeSubtag {
 223     Public = 0,
 224     Private = 1
 225 };
 226 const uint8_t cryptoKeyAsymmetricTypeSubtagMaximumValue = 1;
 227 
 228 enum class CryptoKeyUsageTag {
 229     Encrypt = 0,
 230     Decrypt = 1,
 231     Sign = 2,
 232     Verify = 3,
 233     DeriveKey = 4,
 234     DeriveBits = 5,
 235     WrapKey = 6,
 236     UnwrapKey = 7
 237 };
 238 const uint8_t cryptoKeyUsageTagMaximumValue = 7;
 239 
 240 enum class CryptoAlgorithmIdentifierTag {
 241     RSAES_PKCS1_v1_5 = 0,
 242     RSASSA_PKCS1_v1_5 = 1,
 243     RSA_PSS = 2,
 244     RSA_OAEP = 3,
 245     ECDSA = 4,
 246     ECDH = 5,
 247     AES_CTR = 6,
 248     AES_CBC = 7,
 249     AES_GCM = 9,
 250     AES_CFB = 10,
 251     AES_KW = 11,
 252     HMAC = 12,
 253     SHA_1 = 14,
 254     SHA_224 = 15,
 255     SHA_256 = 16,
 256     SHA_384 = 17,
 257     SHA_512 = 18,
 258     HKDF = 20,
 259     PBKDF2 = 21,
 260 };
 261 const uint8_t cryptoAlgorithmIdentifierTagMaximumValue = 21;
 262 
 263 static unsigned countUsages(CryptoKeyUsageBitmap usages)
 264 {
 265     // Fast bit count algorithm for sparse bit maps.
 266     unsigned count = 0;
 267     while (usages) {
 268         usages = usages &amp; (usages - 1);
 269         ++count;
 270     }
 271     return count;
 272 }
 273 
 274 #endif
 275 
 276 /* CurrentVersion tracks the serialization version so that persistent stores
 277  * are able to correctly bail out in the case of encountering newer formats.
 278  *
 279  * Initial version was 1.
 280  * Version 2. added the ObjectReferenceTag and support for serialization of cyclic graphs.
 281  * Version 3. added the FalseObjectTag, TrueObjectTag, NumberObjectTag, StringObjectTag
 282  * and EmptyStringObjectTag for serialization of Boolean, Number and String objects.
 283  * Version 4. added support for serializing non-index properties of arrays.
 284  * Version 5. added support for Map and Set types.
 285  * Version 6. added support for 8-bit strings.
 286  * Version 7. added support for File&#39;s lastModified attribute.
 287  */
 288 static const unsigned CurrentVersion = 7;
 289 static const unsigned TerminatorTag = 0xFFFFFFFF;
 290 static const unsigned StringPoolTag = 0xFFFFFFFE;
 291 static const unsigned NonIndexPropertiesTag = 0xFFFFFFFD;
 292 
 293 // The high bit of a StringData&#39;s length determines the character size.
 294 static const unsigned StringDataIs8BitFlag = 0x80000000;
 295 
 296 /*
 297  * Object serialization is performed according to the following grammar, all tags
 298  * are recorded as a single uint8_t.
 299  *
 300  * IndexType (used for the object pool and StringData&#39;s constant pool) is the
 301  * minimum sized unsigned integer type required to represent the maximum index
 302  * in the constant pool.
 303  *
 304  * SerializedValue :- &lt;CurrentVersion:uint32_t&gt; Value
 305  * Value :- Array | Object | Map | Set | Terminal
 306  *
 307  * Array :-
 308  *     ArrayTag &lt;length:uint32_t&gt;(&lt;index:uint32_t&gt;&lt;value:Value&gt;)* TerminatorTag
 309  *
 310  * Object :-
 311  *     ObjectTag (&lt;name:StringData&gt;&lt;value:Value&gt;)* TerminatorTag
 312  *
 313  * Map :- MapObjectTag MapData
 314  *
 315  * Set :- SetObjectTag SetData
 316  *
 317  * MapData :- (&lt;key:Value&gt;&lt;value:Value&gt;)* NonMapPropertiesTag (&lt;name:StringData&gt;&lt;value:Value&gt;)* TerminatorTag
 318  * SetData :- (&lt;key:Value&gt;)* NonSetPropertiesTag (&lt;name:StringData&gt;&lt;value:Value&gt;)* TerminatorTag
 319  *
 320  * Terminal :-
 321  *      UndefinedTag
 322  *    | NullTag
 323  *    | IntTag &lt;value:int32_t&gt;
 324  *    | ZeroTag
 325  *    | OneTag
 326  *    | FalseTag
 327  *    | TrueTag
 328  *    | FalseObjectTag
 329  *    | TrueObjectTag
 330  *    | DoubleTag &lt;value:double&gt;
 331  *    | NumberObjectTag &lt;value:double&gt;
 332  *    | DateTag &lt;value:double&gt;
 333  *    | String
 334  *    | EmptyStringTag
 335  *    | EmptyStringObjectTag
 336  *    | File
 337  *    | FileList
 338  *    | ImageData
 339  *    | Blob
 340  *    | ObjectReference
 341  *    | MessagePortReferenceTag &lt;value:uint32_t&gt;
 342  *    | ArrayBuffer
 343  *    | ArrayBufferViewTag ArrayBufferViewSubtag &lt;byteOffset:uint32_t&gt; &lt;byteLength:uint32_t&gt; (ArrayBuffer | ObjectReference)
 344  *    | ArrayBufferTransferTag &lt;value:uint32_t&gt;
 345  *    | CryptoKeyTag &lt;wrappedKeyLength:uint32_t&gt; &lt;factor:byte{wrappedKeyLength}&gt;
 346  *    | DOMPoint
 347  *    | DOMRect
 348  *    | DOMMatrix
 349  *    | DOMQuad
 350  *    | ImageBitmapTransferTag &lt;value:uint32_t&gt;
 351  *    | RTCCertificateTag
 352  *
 353  * Inside certificate, data is serialized in this format as per spec:
 354  *
 355  * &lt;expires:double&gt; &lt;certificate:StringData&gt; &lt;origin:StringData&gt; &lt;keyingMaterial:StringData&gt;
 356  * We also add fingerprints to make sure we expose to JavaScript the same information.
 357  *
 358  * Inside wrapped crypto key, data is serialized in this format:
 359  *
 360  * &lt;keyFormatVersion:uint32_t&gt; &lt;extractable:int32_t&gt; &lt;usagesCount:uint32_t&gt; &lt;usages:byte{usagesCount}&gt; CryptoKeyClassSubtag (CryptoKeyHMAC | CryptoKeyAES | CryptoKeyRSA)
 361  *
 362  * String :-
 363  *      EmptyStringTag
 364  *      StringTag StringData
 365  *
 366  * StringObject:
 367  *      EmptyStringObjectTag
 368  *      StringObjectTag StringData
 369  *
 370  * StringData :-
 371  *      StringPoolTag &lt;cpIndex:IndexType&gt;
 372  *      (not (TerminatorTag | StringPoolTag))&lt;is8Bit:uint32_t:1&gt;&lt;length:uint32_t:31&gt;&lt;characters:CharType{length}&gt; // Added to constant pool when seen, string length 0xFFFFFFFF is disallowed
 373  *
 374  * File :-
 375  *    FileTag FileData
 376  *
 377  * FileData :-
 378  *    &lt;path:StringData&gt; &lt;url:StringData&gt; &lt;type:StringData&gt; &lt;name:StringData&gt; &lt;lastModified:double&gt;
 379  *
 380  * FileList :-
 381  *    FileListTag &lt;length:uint32_t&gt;(&lt;file:FileData&gt;){length}
 382  *
 383  * ImageData :-
 384  *    ImageDataTag &lt;width:int32_t&gt;&lt;height:int32_t&gt;&lt;length:uint32_t&gt;&lt;data:uint8_t{length}&gt;
 385  *
 386  * Blob :-
 387  *    BlobTag &lt;url:StringData&gt;&lt;type:StringData&gt;&lt;size:long long&gt;
 388  *
 389  * RegExp :-
 390  *    RegExpTag &lt;pattern:StringData&gt;&lt;flags:StringData&gt;
 391  *
 392  * ObjectReference :-
 393  *    ObjectReferenceTag &lt;opIndex:IndexType&gt;
 394  *
 395  * ArrayBuffer :-
 396  *    ArrayBufferTag &lt;length:uint32_t&gt; &lt;contents:byte{length}&gt;
 397  *
 398  * CryptoKeyHMAC :-
 399  *    &lt;keySize:uint32_t&gt; &lt;keyData:byte{keySize}&gt; CryptoAlgorithmIdentifierTag // Algorithm tag inner hash function.
 400  *
 401  * CryptoKeyAES :-
 402  *    CryptoAlgorithmIdentifierTag &lt;keySize:uint32_t&gt; &lt;keyData:byte{keySize}&gt;
 403  *
 404  * CryptoKeyRSA :-
 405  *    CryptoAlgorithmIdentifierTag &lt;isRestrictedToHash:int32_t&gt; CryptoAlgorithmIdentifierTag? CryptoKeyAsymmetricTypeSubtag CryptoKeyRSAPublicComponents CryptoKeyRSAPrivateComponents?
 406  *
 407  * CryptoKeyRSAPublicComponents :-
 408  *    &lt;modulusSize:uint32_t&gt; &lt;modulus:byte{modulusSize}&gt; &lt;exponentSize:uint32_t&gt; &lt;exponent:byte{exponentSize}&gt;
 409  *
 410  * CryptoKeyRSAPrivateComponents :-
 411  *    &lt;privateExponentSize:uint32_t&gt; &lt;privateExponent:byte{privateExponentSize}&gt; &lt;primeCount:uint32_t&gt; FirstPrimeInfo? PrimeInfo{primeCount - 1}
 412  *
 413  * // CRT data could be computed from prime factors. It is only serialized to reuse a code path that&#39;s needed for JWK.
 414  * FirstPrimeInfo :-
 415  *    &lt;factorSize:uint32_t&gt; &lt;factor:byte{factorSize}&gt; &lt;crtExponentSize:uint32_t&gt; &lt;crtExponent:byte{crtExponentSize}&gt;
 416  *
 417  * PrimeInfo :-
 418  *    &lt;factorSize:uint32_t&gt; &lt;factor:byte{factorSize}&gt; &lt;crtExponentSize:uint32_t&gt; &lt;crtExponent:byte{crtExponentSize}&gt; &lt;crtCoefficientSize:uint32_t&gt; &lt;crtCoefficient:byte{crtCoefficientSize}&gt;
 419  *
 420  * CryptoKeyEC :-
 421  *    CryptoAlgorithmIdentifierTag &lt;namedCurve:StringData&gt; CryptoKeyAsymmetricTypeSubtag &lt;keySize:uint32_t&gt; &lt;keyData:byte{keySize}&gt;
 422  *
 423  * CryptoKeyRaw :-
 424  *    CryptoAlgorithmIdentifierTag &lt;keySize:uint32_t&gt; &lt;keyData:byte{keySize}&gt;
 425  *
 426  * DOMPoint :-
 427  *        DOMPointReadOnlyTag DOMPointData
 428  *      | DOMPointTag DOMPointData
 429  *
 430  * DOMPointData :-
 431  *      &lt;x:double&gt; &lt;y:double&gt; &lt;z:double&gt; &lt;w:double&gt;
 432  *
 433  * DOMRect :-
 434  *        DOMRectReadOnlyTag DOMRectData
 435  *      | DOMRectTag DOMRectData
 436  *
 437  * DOMRectData :-
 438  *      &lt;x:double&gt; &lt;y:double&gt; &lt;width:double&gt; &lt;height:double&gt;
 439  *
 440  * DOMMatrix :-
 441  *        DOMMatrixReadOnlyTag DOMMatrixData
 442  *      | DOMMatrixTag DOMMatrixData
 443  *
 444  * DOMMatrixData :-
 445  *        &lt;is2D:uint8_t:true&gt; &lt;m11:double&gt; &lt;m12:double&gt; &lt;m21:double&gt; &lt;m22:double&gt; &lt;m41:double&gt; &lt;m42:double&gt;
 446  *      | &lt;is2D:uint8_t:false&gt; &lt;m11:double&gt; &lt;m12:double&gt; &lt;m13:double&gt; &lt;m14:double&gt; &lt;m21:double&gt; &lt;m22:double&gt; &lt;m23:double&gt; &lt;m24:double&gt; &lt;m31:double&gt; &lt;m32:double&gt; &lt;m33:double&gt; &lt;m34:double&gt; &lt;m41:double&gt; &lt;m42:double&gt; &lt;m43:double&gt; &lt;m44:double&gt;
 447  *
 448  * DOMQuad :-
 449  *      DOMQuadTag DOMQuadData
 450  *
 451  * DOMQuadData :-
 452  *      &lt;p1:DOMPointData&gt; &lt;p2:DOMPointData&gt; &lt;p3:DOMPointData&gt; &lt;p4:DOMPointData&gt;
 453  *
 454  */
 455 
 456 using DeserializationResult = std::pair&lt;JSC::JSValue, SerializationReturnCode&gt;;
 457 
 458 class CloneBase {
 459 protected:
 460     CloneBase(ExecState* exec)
 461         : m_exec(exec)
 462         , m_failed(false)
 463     {
 464     }
 465 
 466     bool shouldTerminate()
 467     {
 468         VM&amp; vm = m_exec-&gt;vm();
 469         auto scope = DECLARE_THROW_SCOPE(vm);
 470         return scope.exception();
 471     }
 472 
 473     void fail()
 474     {
 475         m_failed = true;
 476     }
 477 
 478     ExecState* m_exec;
 479     bool m_failed;
 480     MarkedArgumentBuffer m_gcBuffer;
 481 };
 482 
 483 #if ENABLE(WEB_CRYPTO)
 484 static bool wrapCryptoKey(ExecState* exec, const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
 485 {
 486     ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(exec);
 487     if (!scriptExecutionContext)
 488         return false;
 489     return scriptExecutionContext-&gt;wrapCryptoKey(key, wrappedKey);
 490 }
 491 
 492 static bool unwrapCryptoKey(ExecState* exec, const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
 493 {
 494     ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(exec);
 495     if (!scriptExecutionContext)
 496         return false;
 497     return scriptExecutionContext-&gt;unwrapCryptoKey(wrappedKey, key);
 498 }
 499 #endif
 500 
 501 #if ASSUME_LITTLE_ENDIAN
 502 template &lt;typename T&gt; static void writeLittleEndian(Vector&lt;uint8_t&gt;&amp; buffer, T value)
 503 {
 504     buffer.append(reinterpret_cast&lt;uint8_t*&gt;(&amp;value), sizeof(value));
 505 }
 506 #else
 507 template &lt;typename T&gt; static void writeLittleEndian(Vector&lt;uint8_t&gt;&amp; buffer, T value)
 508 {
 509     for (unsigned i = 0; i &lt; sizeof(T); i++) {
 510         buffer.append(value &amp; 0xFF);
 511         value &gt;&gt;= 8;
 512     }
 513 }
 514 #endif
 515 
 516 template &lt;&gt; void writeLittleEndian&lt;uint8_t&gt;(Vector&lt;uint8_t&gt;&amp; buffer, uint8_t value)
 517 {
 518     buffer.append(value);
 519 }
 520 
 521 template &lt;typename T&gt; static bool writeLittleEndian(Vector&lt;uint8_t&gt;&amp; buffer, const T* values, uint32_t length)
 522 {
 523     if (length &gt; std::numeric_limits&lt;uint32_t&gt;::max() / sizeof(T))
 524         return false;
 525 
 526 #if ASSUME_LITTLE_ENDIAN
 527     buffer.append(reinterpret_cast&lt;const uint8_t*&gt;(values), length * sizeof(T));
 528 #else
 529     for (unsigned i = 0; i &lt; length; i++) {
 530         T value = values[i];
 531         for (unsigned j = 0; j &lt; sizeof(T); j++) {
 532             buffer.append(static_cast&lt;uint8_t&gt;(value &amp; 0xFF));
 533             value &gt;&gt;= 8;
 534         }
 535     }
 536 #endif
 537     return true;
 538 }
 539 
 540 template &lt;&gt; bool writeLittleEndian&lt;uint8_t&gt;(Vector&lt;uint8_t&gt;&amp; buffer, const uint8_t* values, uint32_t length)
 541 {
 542     buffer.append(values, length);
 543     return true;
 544 }
 545 
 546 class CloneSerializer : CloneBase {
 547 public:
 548     static SerializationReturnCode serialize(ExecState* exec, JSValue value, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,
 549 #if ENABLE(WEBASSEMBLY)
 550             WasmModuleArray&amp; wasmModules,
 551 #endif
<a name="5" id="anc5"></a><span class="line-modified"> 552         Vector&lt;String&gt;&amp; blobURLs, const PAL::SessionID&amp; sessionID, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)</span>
 553     {
 554         CloneSerializer serializer(exec, messagePorts, arrayBuffers, imageBitmaps,
 555 #if ENABLE(WEBASSEMBLY)
 556             wasmModules,
 557 #endif
<a name="6" id="anc6"></a><span class="line-modified"> 558             blobURLs, sessionID, out, context, sharedBuffers);</span>
 559         return serializer.serialize(value);
 560     }
 561 
 562     static bool serialize(StringView string, Vector&lt;uint8_t&gt;&amp; out)
 563     {
 564         writeLittleEndian(out, CurrentVersion);
 565         if (string.isEmpty()) {
 566             writeLittleEndian&lt;uint8_t&gt;(out, EmptyStringTag);
 567             return true;
 568         }
 569         writeLittleEndian&lt;uint8_t&gt;(out, StringTag);
 570         if (string.is8Bit()) {
 571             writeLittleEndian(out, string.length() | StringDataIs8BitFlag);
 572             return writeLittleEndian(out, string.characters8(), string.length());
 573         }
 574         writeLittleEndian(out, string.length());
 575         return writeLittleEndian(out, string.characters16(), string.length());
 576     }
 577 
 578 private:
 579     typedef HashMap&lt;JSObject*, uint32_t&gt; ObjectPool;
 580 
 581     CloneSerializer(ExecState* exec, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,
 582 #if ENABLE(WEBASSEMBLY)
 583             WasmModuleArray&amp; wasmModules,
 584 #endif
<a name="7" id="anc7"></a><span class="line-modified"> 585         Vector&lt;String&gt;&amp; blobURLs, const PAL::SessionID&amp; sessionID, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)</span>
 586         : CloneBase(exec)
 587         , m_buffer(out)
 588         , m_blobURLs(blobURLs)
<a name="8" id="anc8"></a><span class="line-modified"> 589         , m_sessionID(sessionID)</span>
<span class="line-removed"> 590         , m_emptyIdentifier(Identifier::fromString(exec, emptyString()))</span>
 591         , m_context(context)
 592         , m_sharedBuffers(sharedBuffers)
 593 #if ENABLE(WEBASSEMBLY)
 594         , m_wasmModules(wasmModules)
 595 #endif
 596     {
 597         write(CurrentVersion);
 598         fillTransferMap(messagePorts, m_transferredMessagePorts);
 599         fillTransferMap(arrayBuffers, m_transferredArrayBuffers);
 600         fillTransferMap(imageBitmaps, m_transferredImageBitmaps);
 601     }
 602 
 603     template &lt;class T&gt;
 604     void fillTransferMap(const Vector&lt;RefPtr&lt;T&gt;&gt;&amp; input, ObjectPool&amp; result)
 605     {
 606         if (input.isEmpty())
 607             return;
 608         JSDOMGlobalObject* globalObject = jsCast&lt;JSDOMGlobalObject*&gt;(m_exec-&gt;lexicalGlobalObject());
 609         for (size_t i = 0; i &lt; input.size(); i++) {
 610             JSC::JSValue value = toJS(m_exec, globalObject, input[i].get());
 611             JSC::JSObject* obj = value.getObject();
 612             if (obj &amp;&amp; !result.contains(obj))
 613                 result.add(obj, i);
 614         }
 615     }
 616 
 617     SerializationReturnCode serialize(JSValue in);
 618 
 619     bool isArray(VM&amp; vm, JSValue value)
 620     {
 621         if (!value.isObject())
 622             return false;
 623         JSObject* object = asObject(value);
 624         return object-&gt;inherits&lt;JSArray&gt;(vm);
 625     }
 626 
 627     bool isMap(VM&amp; vm, JSValue value)
 628     {
 629         if (!value.isObject())
 630             return false;
 631         JSObject* object = asObject(value);
 632         return object-&gt;inherits&lt;JSMap&gt;(vm);
 633     }
 634     bool isSet(VM&amp; vm, JSValue value)
 635     {
 636         if (!value.isObject())
 637             return false;
 638         JSObject* object = asObject(value);
 639         return object-&gt;inherits&lt;JSSet&gt;(vm);
 640     }
 641 
 642     bool checkForDuplicate(JSObject* object)
 643     {
 644         // Record object for graph reconstruction
 645         ObjectPool::const_iterator found = m_objectPool.find(object);
 646 
 647         // Handle duplicate references
 648         if (found != m_objectPool.end()) {
 649             write(ObjectReferenceTag);
 650             ASSERT(found-&gt;value &lt; m_objectPool.size());
 651             writeObjectIndex(found-&gt;value);
 652             return true;
 653         }
 654 
 655         return false;
 656     }
 657 
 658     void recordObject(JSObject* object)
 659     {
 660         m_objectPool.add(object, m_objectPool.size());
 661         m_gcBuffer.appendWithCrashOnOverflow(object);
 662     }
 663 
 664     bool startObjectInternal(JSObject* object)
 665     {
 666         if (checkForDuplicate(object))
 667             return false;
 668         recordObject(object);
 669         return true;
 670     }
 671 
 672     bool startObject(JSObject* object)
 673     {
 674         if (!startObjectInternal(object))
 675             return false;
 676         write(ObjectTag);
 677         return true;
 678     }
 679 
 680     bool startArray(JSArray* array)
 681     {
 682         if (!startObjectInternal(array))
 683             return false;
 684 
 685         unsigned length = array-&gt;length();
 686         write(ArrayTag);
 687         write(length);
 688         return true;
 689     }
 690 
 691     bool startSet(JSSet* set)
 692     {
 693         if (!startObjectInternal(set))
 694             return false;
 695 
 696         write(SetObjectTag);
 697         return true;
 698     }
 699 
 700     bool startMap(JSMap* map)
 701     {
 702         if (!startObjectInternal(map))
 703             return false;
 704 
 705         write(MapObjectTag);
 706         return true;
 707     }
 708 
 709     void endObject()
 710     {
 711         write(TerminatorTag);
 712     }
 713 
 714     JSValue getProperty(VM&amp; vm, JSObject* object, const Identifier&amp; propertyName)
 715     {
 716         PropertySlot slot(object, PropertySlot::InternalMethodType::Get);
 717         if (object-&gt;methodTable(vm)-&gt;getOwnPropertySlot(object, m_exec, propertyName, slot))
 718             return slot.getValue(m_exec, propertyName);
 719         return JSValue();
 720     }
 721 
 722     void dumpImmediate(JSValue value)
 723     {
 724         if (value.isNull())
 725             write(NullTag);
 726         else if (value.isUndefined())
 727             write(UndefinedTag);
 728         else if (value.isNumber()) {
 729             if (value.isInt32()) {
 730                 if (!value.asInt32())
 731                     write(ZeroTag);
 732                 else if (value.asInt32() == 1)
 733                     write(OneTag);
 734                 else {
 735                     write(IntTag);
 736                     write(static_cast&lt;uint32_t&gt;(value.asInt32()));
 737                 }
 738             } else {
 739                 write(DoubleTag);
 740                 write(value.asDouble());
 741             }
 742         } else if (value.isBoolean()) {
 743             if (value.isTrue())
 744                 write(TrueTag);
 745             else
 746                 write(FalseTag);
 747         }
 748     }
 749 
 750     void dumpString(const String&amp; string)
 751     {
 752         if (string.isEmpty())
 753             write(EmptyStringTag);
 754         else {
 755             write(StringTag);
 756             write(string);
 757         }
 758     }
 759 
 760     void dumpStringObject(const String&amp; string)
 761     {
 762         if (string.isEmpty())
 763             write(EmptyStringObjectTag);
 764         else {
 765             write(StringObjectTag);
 766             write(string);
 767         }
 768     }
 769 
 770     JSC::JSValue toJSArrayBuffer(ArrayBuffer&amp; arrayBuffer)
 771     {
 772         auto&amp; vm = m_exec-&gt;vm();
 773         auto* globalObject = m_exec-&gt;lexicalGlobalObject();
 774         if (globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(vm))
 775             return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(globalObject), &amp;arrayBuffer);
 776 
 777         if (auto* buffer = arrayBuffer.m_wrapper.get())
 778             return buffer;
 779 
 780         return JSC::JSArrayBuffer::create(vm, globalObject-&gt;arrayBufferStructure(arrayBuffer.sharingMode()), &amp;arrayBuffer);
 781     }
 782 
 783     bool dumpArrayBufferView(JSObject* obj, SerializationReturnCode&amp; code)
 784     {
 785         VM&amp; vm = m_exec-&gt;vm();
 786         write(ArrayBufferViewTag);
 787         if (obj-&gt;inherits&lt;JSDataView&gt;(vm))
 788             write(DataViewTag);
 789         else if (obj-&gt;inherits&lt;JSUint8ClampedArray&gt;(vm))
 790             write(Uint8ClampedArrayTag);
 791         else if (obj-&gt;inherits&lt;JSInt8Array&gt;(vm))
 792             write(Int8ArrayTag);
 793         else if (obj-&gt;inherits&lt;JSUint8Array&gt;(vm))
 794             write(Uint8ArrayTag);
 795         else if (obj-&gt;inherits&lt;JSInt16Array&gt;(vm))
 796             write(Int16ArrayTag);
 797         else if (obj-&gt;inherits&lt;JSUint16Array&gt;(vm))
 798             write(Uint16ArrayTag);
 799         else if (obj-&gt;inherits&lt;JSInt32Array&gt;(vm))
 800             write(Int32ArrayTag);
 801         else if (obj-&gt;inherits&lt;JSUint32Array&gt;(vm))
 802             write(Uint32ArrayTag);
 803         else if (obj-&gt;inherits&lt;JSFloat32Array&gt;(vm))
 804             write(Float32ArrayTag);
 805         else if (obj-&gt;inherits&lt;JSFloat64Array&gt;(vm))
 806             write(Float64ArrayTag);
 807         else
 808             return false;
 809 
 810         RefPtr&lt;ArrayBufferView&gt; arrayBufferView = toPossiblySharedArrayBufferView(vm, obj);
 811         write(static_cast&lt;uint32_t&gt;(arrayBufferView-&gt;byteOffset()));
 812         write(static_cast&lt;uint32_t&gt;(arrayBufferView-&gt;byteLength()));
 813         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = arrayBufferView-&gt;possiblySharedBuffer();
 814         if (!arrayBuffer) {
 815             code = SerializationReturnCode::ValidationError;
 816             return true;
 817         }
 818 
 819         return dumpIfTerminal(toJSArrayBuffer(*arrayBuffer), code);
 820     }
 821 
 822     void dumpDOMPoint(const DOMPointReadOnly&amp; point)
 823     {
 824         write(point.x());
 825         write(point.y());
 826         write(point.z());
 827         write(point.w());
 828     }
 829 
 830     void dumpDOMPoint(JSObject* obj)
 831     {
 832         VM&amp; vm = m_exec-&gt;vm();
 833         if (obj-&gt;inherits&lt;JSDOMPoint&gt;(vm))
 834             write(DOMPointTag);
 835         else
 836             write(DOMPointReadOnlyTag);
 837 
 838         dumpDOMPoint(jsCast&lt;JSDOMPointReadOnly*&gt;(obj)-&gt;wrapped());
 839     }
 840 
 841     void dumpDOMRect(JSObject* obj)
 842     {
 843         VM&amp; vm = m_exec-&gt;vm();
 844         if (obj-&gt;inherits&lt;JSDOMRect&gt;(vm))
 845             write(DOMRectTag);
 846         else
 847             write(DOMRectReadOnlyTag);
 848 
 849         auto&amp; rect = jsCast&lt;JSDOMRectReadOnly*&gt;(obj)-&gt;wrapped();
 850         write(rect.x());
 851         write(rect.y());
 852         write(rect.width());
 853         write(rect.height());
 854     }
 855 
 856     void dumpDOMMatrix(JSObject* obj)
 857     {
 858         VM&amp; vm = m_exec-&gt;vm();
 859         if (obj-&gt;inherits&lt;JSDOMMatrix&gt;(vm))
 860             write(DOMMatrixTag);
 861         else
 862             write(DOMMatrixReadOnlyTag);
 863 
 864         auto&amp; matrix = jsCast&lt;JSDOMMatrixReadOnly*&gt;(obj)-&gt;wrapped();
 865         bool is2D = matrix.is2D();
 866         write(static_cast&lt;uint8_t&gt;(is2D));
 867         if (is2D) {
 868             write(matrix.m11());
 869             write(matrix.m12());
 870             write(matrix.m21());
 871             write(matrix.m22());
 872             write(matrix.m41());
 873             write(matrix.m42());
 874         } else {
 875             write(matrix.m11());
 876             write(matrix.m12());
 877             write(matrix.m13());
 878             write(matrix.m14());
 879             write(matrix.m21());
 880             write(matrix.m22());
 881             write(matrix.m23());
 882             write(matrix.m24());
 883             write(matrix.m31());
 884             write(matrix.m32());
 885             write(matrix.m33());
 886             write(matrix.m34());
 887             write(matrix.m41());
 888             write(matrix.m42());
 889             write(matrix.m43());
 890             write(matrix.m44());
 891         }
 892     }
 893 
 894     void dumpDOMQuad(JSObject* obj)
 895     {
 896         write(DOMQuadTag);
 897 
 898         auto&amp; quad = jsCast&lt;JSDOMQuad*&gt;(obj)-&gt;wrapped();
 899         dumpDOMPoint(quad.p1());
 900         dumpDOMPoint(quad.p2());
 901         dumpDOMPoint(quad.p3());
 902         dumpDOMPoint(quad.p4());
 903     }
 904 
 905     void dumpImageBitmap(JSObject* obj, SerializationReturnCode&amp; code)
 906     {
 907         auto index = m_transferredImageBitmaps.find(obj);
 908         if (index != m_transferredImageBitmaps.end()) {
 909             write(ImageBitmapTransferTag);
 910             write(index-&gt;value);
 911             return;
 912         }
 913 
 914         // Copying ImageBitmaps is not yet supported.
 915         code = SerializationReturnCode::ValidationError;
 916     }
 917 
 918     bool dumpIfTerminal(JSValue value, SerializationReturnCode&amp; code)
 919     {
 920         if (!value.isCell()) {
 921             dumpImmediate(value);
 922             return true;
 923         }
 924         ASSERT(value.isCell());
 925 
 926         if (value.isString()) {
 927             dumpString(asString(value)-&gt;value(m_exec));
 928             return true;
 929         }
 930 
 931         if (value.isSymbol()) {
 932             code = SerializationReturnCode::DataCloneError;
 933             return true;
 934         }
 935 
 936         VM&amp; vm = m_exec-&gt;vm();
 937         if (isArray(vm, value))
 938             return false;
 939 
 940         if (value.isObject()) {
 941             auto* obj = asObject(value);
 942             if (auto* dateObject = jsDynamicCast&lt;DateInstance*&gt;(vm, obj)) {
 943                 write(DateTag);
 944                 write(dateObject-&gt;internalNumber());
 945                 return true;
 946             }
 947             if (auto* booleanObject = jsDynamicCast&lt;BooleanObject*&gt;(vm, obj)) {
 948                 if (!startObjectInternal(booleanObject)) // handle duplicates
 949                     return true;
 950                 write(booleanObject-&gt;internalValue().toBoolean(m_exec) ? TrueObjectTag : FalseObjectTag);
 951                 return true;
 952             }
 953             if (auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, obj)) {
 954                 if (!startObjectInternal(stringObject)) // handle duplicates
 955                     return true;
 956                 String str = asString(stringObject-&gt;internalValue())-&gt;value(m_exec);
 957                 dumpStringObject(str);
 958                 return true;
 959             }
 960             if (auto* numberObject = jsDynamicCast&lt;NumberObject*&gt;(vm, obj)) {
 961                 if (!startObjectInternal(numberObject)) // handle duplicates
 962                     return true;
 963                 write(NumberObjectTag);
 964                 write(numberObject-&gt;internalValue().asNumber());
 965                 return true;
 966             }
 967             if (auto* file = JSFile::toWrapped(vm, obj)) {
 968                 write(FileTag);
 969                 write(*file);
 970                 return true;
 971             }
 972             if (auto* list = JSFileList::toWrapped(vm, obj)) {
 973                 write(FileListTag);
 974                 write(list-&gt;length());
 975                 for (auto&amp; file : list-&gt;files())
 976                     write(file.get());
 977                 return true;
 978             }
 979             if (auto* blob = JSBlob::toWrapped(vm, obj)) {
 980                 write(BlobTag);
 981                 m_blobURLs.append(blob-&gt;url());
 982                 write(blob-&gt;url());
 983                 write(blob-&gt;type());
 984                 write(blob-&gt;size());
 985                 return true;
 986             }
 987             if (auto* data = JSImageData::toWrapped(vm, obj)) {
 988                 write(ImageDataTag);
 989                 write(data-&gt;width());
 990                 write(data-&gt;height());
 991                 write(data-&gt;data()-&gt;length());
 992                 write(data-&gt;data()-&gt;data(), data-&gt;data()-&gt;length());
 993                 return true;
 994             }
 995             if (auto* regExp = jsDynamicCast&lt;RegExpObject*&gt;(vm, obj)) {
 996                 char flags[3];
 997                 int flagCount = 0;
 998                 if (regExp-&gt;regExp()-&gt;global())
 999                     flags[flagCount++] = &#39;g&#39;;
1000                 if (regExp-&gt;regExp()-&gt;ignoreCase())
1001                     flags[flagCount++] = &#39;i&#39;;
1002                 if (regExp-&gt;regExp()-&gt;multiline())
1003                     flags[flagCount++] = &#39;m&#39;;
1004                 write(RegExpTag);
1005                 write(regExp-&gt;regExp()-&gt;pattern());
1006                 write(String(flags, flagCount));
1007                 return true;
1008             }
1009             if (obj-&gt;inherits&lt;JSMessagePort&gt;(vm)) {
1010                 auto index = m_transferredMessagePorts.find(obj);
1011                 if (index != m_transferredMessagePorts.end()) {
1012                     write(MessagePortReferenceTag);
1013                     write(index-&gt;value);
1014                     return true;
1015                 }
1016                 // MessagePort object could not be found in transferred message ports
1017                 code = SerializationReturnCode::ValidationError;
1018                 return true;
1019             }
1020             if (auto* arrayBuffer = toPossiblySharedArrayBuffer(vm, obj)) {
1021                 if (arrayBuffer-&gt;isNeutered()) {
1022                     code = SerializationReturnCode::ValidationError;
1023                     return true;
1024                 }
1025                 auto index = m_transferredArrayBuffers.find(obj);
1026                 if (index != m_transferredArrayBuffers.end()) {
1027                     write(ArrayBufferTransferTag);
1028                     write(index-&gt;value);
1029                     return true;
1030                 }
1031                 if (!startObjectInternal(obj)) // handle duplicates
1032                     return true;
1033 
1034                 if (arrayBuffer-&gt;isShared() &amp;&amp; m_context == SerializationContext::WorkerPostMessage) {
1035                     uint32_t index = m_sharedBuffers.size();
1036                     ArrayBufferContents contents;
1037                     if (arrayBuffer-&gt;shareWith(contents)) {
1038                         write(SharedArrayBufferTag);
1039                         m_sharedBuffers.append(WTFMove(contents));
1040                         write(index);
1041                         return true;
1042                     }
1043                 }
1044 
1045                 write(ArrayBufferTag);
1046                 write(arrayBuffer-&gt;byteLength());
1047                 write(static_cast&lt;const uint8_t*&gt;(arrayBuffer-&gt;data()), arrayBuffer-&gt;byteLength());
1048                 return true;
1049             }
1050             if (obj-&gt;inherits&lt;JSArrayBufferView&gt;(vm)) {
1051                 if (checkForDuplicate(obj))
1052                     return true;
1053                 bool success = dumpArrayBufferView(obj, code);
1054                 recordObject(obj);
1055                 return success;
1056             }
1057 #if ENABLE(WEB_CRYPTO)
1058             if (auto* key = JSCryptoKey::toWrapped(vm, obj)) {
1059                 write(CryptoKeyTag);
1060                 Vector&lt;uint8_t&gt; serializedKey;
1061                 Vector&lt;String&gt; dummyBlobURLs;
<a name="9" id="anc9"></a><span class="line-removed">1062                 PAL::SessionID dummySessionID;</span>
1063                 Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
1064                 Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
1065 #if ENABLE(WEBASSEMBLY)
1066                 WasmModuleArray dummyModules;
1067 #endif
1068                 ArrayBufferContentsArray dummySharedBuffers;
1069                 CloneSerializer rawKeySerializer(m_exec, dummyMessagePorts, dummyArrayBuffers, { },
1070 #if ENABLE(WEBASSEMBLY)
1071                     dummyModules,
1072 #endif
<a name="10" id="anc10"></a><span class="line-modified">1073                     dummyBlobURLs, dummySessionID, serializedKey, SerializationContext::Default, dummySharedBuffers);</span>
1074                 rawKeySerializer.write(key);
1075                 Vector&lt;uint8_t&gt; wrappedKey;
1076                 if (!wrapCryptoKey(m_exec, serializedKey, wrappedKey))
1077                     return false;
1078                 write(wrappedKey);
1079                 return true;
1080             }
1081 #endif
1082 #if ENABLE(WEB_RTC)
1083             if (auto* rtcCertificate = JSRTCCertificate::toWrapped(vm, obj)) {
1084                 write(RTCCertificateTag);
1085                 write(rtcCertificate-&gt;expires());
1086                 write(rtcCertificate-&gt;pemCertificate());
1087                 write(rtcCertificate-&gt;origin().toString());
1088                 write(rtcCertificate-&gt;pemPrivateKey());
1089                 write(static_cast&lt;unsigned&gt;(rtcCertificate-&gt;getFingerprints().size()));
1090                 for (const auto&amp; fingerprint : rtcCertificate-&gt;getFingerprints()) {
1091                     write(fingerprint.algorithm);
1092                     write(fingerprint.value);
1093                 }
1094                 return true;
1095             }
1096 #endif
1097 #if ENABLE(WEBASSEMBLY)
1098             if (JSWebAssemblyModule* module = jsDynamicCast&lt;JSWebAssemblyModule*&gt;(vm, obj)) {
1099                 if (m_context != SerializationContext::WorkerPostMessage &amp;&amp; m_context != SerializationContext::WindowPostMessage)
1100                     return false;
1101 
1102                 uint32_t index = m_wasmModules.size();
1103                 m_wasmModules.append(makeRef(module-&gt;module()));
1104                 write(WasmModuleTag);
1105                 write(index);
1106                 return true;
1107             }
1108 #endif
1109             if (obj-&gt;inherits&lt;JSDOMPointReadOnly&gt;(vm)) {
1110                 dumpDOMPoint(obj);
1111                 return true;
1112             }
1113             if (obj-&gt;inherits&lt;JSDOMRectReadOnly&gt;(vm)) {
1114                 dumpDOMRect(obj);
1115                 return true;
1116             }
1117             if (obj-&gt;inherits&lt;JSDOMMatrixReadOnly&gt;(vm)) {
1118                 dumpDOMMatrix(obj);
1119                 return true;
1120             }
1121             if (obj-&gt;inherits&lt;JSDOMQuad&gt;(vm)) {
1122                 dumpDOMQuad(obj);
1123                 return true;
1124             }
1125             if (obj-&gt;inherits(vm, JSImageBitmap::info())) {
1126                 dumpImageBitmap(obj, code);
1127                 return true;
1128             }
1129             return false;
1130         }
1131         // Any other types are expected to serialize as null.
1132         write(NullTag);
1133         return true;
1134     }
1135 
1136     void write(SerializationTag tag)
1137     {
1138         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1139     }
1140 
1141     void write(ArrayBufferViewSubtag tag)
1142     {
1143         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1144     }
1145 
1146 #if ENABLE(WEB_CRYPTO)
1147     void write(CryptoKeyClassSubtag tag)
1148     {
1149         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1150     }
1151 
1152     void write(CryptoKeyAsymmetricTypeSubtag tag)
1153     {
1154         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1155     }
1156 
1157     void write(CryptoKeyUsageTag tag)
1158     {
1159         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1160     }
1161 
1162     void write(CryptoAlgorithmIdentifierTag tag)
1163     {
1164         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1165     }
1166 #endif
1167 
1168     void write(uint8_t c)
1169     {
1170         writeLittleEndian(m_buffer, c);
1171     }
1172 
1173     void write(uint32_t i)
1174     {
1175         writeLittleEndian(m_buffer, i);
1176     }
1177 
1178     void write(double d)
1179     {
1180         union {
1181             double d;
1182             int64_t i;
1183         } u;
1184         u.d = d;
1185         writeLittleEndian(m_buffer, u.i);
1186     }
1187 
1188     void write(int32_t i)
1189     {
1190         writeLittleEndian(m_buffer, i);
1191     }
1192 
1193     void write(unsigned long long i)
1194     {
1195         writeLittleEndian(m_buffer, i);
1196     }
1197 
1198     void write(uint16_t ch)
1199     {
1200         writeLittleEndian(m_buffer, ch);
1201     }
1202 
1203     void writeStringIndex(unsigned i)
1204     {
1205         writeConstantPoolIndex(m_constantPool, i);
1206     }
1207 
1208     void writeObjectIndex(unsigned i)
1209     {
1210         writeConstantPoolIndex(m_objectPool, i);
1211     }
1212 
1213     template &lt;class T&gt; void writeConstantPoolIndex(const T&amp; constantPool, unsigned i)
1214     {
1215         ASSERT(i &lt; constantPool.size());
1216         if (constantPool.size() &lt;= 0xFF)
1217             write(static_cast&lt;uint8_t&gt;(i));
1218         else if (constantPool.size() &lt;= 0xFFFF)
1219             write(static_cast&lt;uint16_t&gt;(i));
1220         else
1221             write(static_cast&lt;uint32_t&gt;(i));
1222     }
1223 
1224     void write(const Identifier&amp; ident)
1225     {
1226         const String&amp; str = ident.string();
1227         StringConstantPool::AddResult addResult = m_constantPool.add(ident.impl(), m_constantPool.size());
1228         if (!addResult.isNewEntry) {
1229             write(StringPoolTag);
1230             writeStringIndex(addResult.iterator-&gt;value);
1231             return;
1232         }
1233 
1234         unsigned length = str.length();
1235 
1236         // Guard against overflow
1237         if (length &gt; (std::numeric_limits&lt;uint32_t&gt;::max() - sizeof(uint32_t)) / sizeof(UChar)) {
1238             fail();
1239             return;
1240         }
1241 
1242         if (str.is8Bit())
1243             writeLittleEndian&lt;uint32_t&gt;(m_buffer, length | StringDataIs8BitFlag);
1244         else
1245             writeLittleEndian&lt;uint32_t&gt;(m_buffer, length);
1246 
1247         if (!length)
1248             return;
1249         if (str.is8Bit()) {
1250             if (!writeLittleEndian(m_buffer, str.characters8(), length))
1251                 fail();
1252             return;
1253         }
1254         if (!writeLittleEndian(m_buffer, str.characters16(), length))
1255             fail();
1256     }
1257 
1258     void write(const String&amp; str)
1259     {
1260         if (str.isNull())
1261             write(m_emptyIdentifier);
1262         else
<a name="11" id="anc11"></a><span class="line-modified">1263             write(Identifier::fromString(m_exec, str));</span>
1264     }
1265 
1266     void write(const Vector&lt;uint8_t&gt;&amp; vector)
1267     {
1268         uint32_t size = vector.size();
1269         write(size);
1270         writeLittleEndian(m_buffer, vector.data(), size);
1271     }
1272 
1273     void write(const File&amp; file)
1274     {
1275         m_blobURLs.append(file.url());
1276         write(file.path());
1277         write(file.url());
1278         write(file.type());
1279         write(file.name());
1280         write(static_cast&lt;double&gt;(file.lastModifiedOverride().valueOr(-1)));
1281     }
1282 
1283 #if ENABLE(WEB_CRYPTO)
1284     void write(CryptoAlgorithmIdentifier algorithm)
1285     {
1286         switch (algorithm) {
1287         case CryptoAlgorithmIdentifier::RSAES_PKCS1_v1_5:
1288             write(CryptoAlgorithmIdentifierTag::RSAES_PKCS1_v1_5);
1289             break;
1290         case CryptoAlgorithmIdentifier::RSASSA_PKCS1_v1_5:
1291             write(CryptoAlgorithmIdentifierTag::RSASSA_PKCS1_v1_5);
1292             break;
1293         case CryptoAlgorithmIdentifier::RSA_PSS:
1294             write(CryptoAlgorithmIdentifierTag::RSA_PSS);
1295             break;
1296         case CryptoAlgorithmIdentifier::RSA_OAEP:
1297             write(CryptoAlgorithmIdentifierTag::RSA_OAEP);
1298             break;
1299         case CryptoAlgorithmIdentifier::ECDSA:
1300             write(CryptoAlgorithmIdentifierTag::ECDSA);
1301             break;
1302         case CryptoAlgorithmIdentifier::ECDH:
1303             write(CryptoAlgorithmIdentifierTag::ECDH);
1304             break;
1305         case CryptoAlgorithmIdentifier::AES_CTR:
1306             write(CryptoAlgorithmIdentifierTag::AES_CTR);
1307             break;
1308         case CryptoAlgorithmIdentifier::AES_CBC:
1309             write(CryptoAlgorithmIdentifierTag::AES_CBC);
1310             break;
1311         case CryptoAlgorithmIdentifier::AES_GCM:
1312             write(CryptoAlgorithmIdentifierTag::AES_GCM);
1313             break;
1314         case CryptoAlgorithmIdentifier::AES_CFB:
1315             write(CryptoAlgorithmIdentifierTag::AES_CFB);
1316             break;
1317         case CryptoAlgorithmIdentifier::AES_KW:
1318             write(CryptoAlgorithmIdentifierTag::AES_KW);
1319             break;
1320         case CryptoAlgorithmIdentifier::HMAC:
1321             write(CryptoAlgorithmIdentifierTag::HMAC);
1322             break;
1323         case CryptoAlgorithmIdentifier::SHA_1:
1324             write(CryptoAlgorithmIdentifierTag::SHA_1);
1325             break;
1326         case CryptoAlgorithmIdentifier::SHA_224:
1327             write(CryptoAlgorithmIdentifierTag::SHA_224);
1328             break;
1329         case CryptoAlgorithmIdentifier::SHA_256:
1330             write(CryptoAlgorithmIdentifierTag::SHA_256);
1331             break;
1332         case CryptoAlgorithmIdentifier::SHA_384:
1333             write(CryptoAlgorithmIdentifierTag::SHA_384);
1334             break;
1335         case CryptoAlgorithmIdentifier::SHA_512:
1336             write(CryptoAlgorithmIdentifierTag::SHA_512);
1337             break;
1338         case CryptoAlgorithmIdentifier::HKDF:
1339             write(CryptoAlgorithmIdentifierTag::HKDF);
1340             break;
1341         case CryptoAlgorithmIdentifier::PBKDF2:
1342             write(CryptoAlgorithmIdentifierTag::PBKDF2);
1343             break;
1344         }
1345     }
1346 
1347     void write(CryptoKeyRSAComponents::Type type)
1348     {
1349         switch (type) {
1350         case CryptoKeyRSAComponents::Type::Public:
1351             write(CryptoKeyAsymmetricTypeSubtag::Public);
1352             return;
1353         case CryptoKeyRSAComponents::Type::Private:
1354             write(CryptoKeyAsymmetricTypeSubtag::Private);
1355             return;
1356         }
1357     }
1358 
1359     void write(const CryptoKeyRSAComponents&amp; key)
1360     {
1361         write(key.type());
1362         write(key.modulus());
1363         write(key.exponent());
1364         if (key.type() == CryptoKeyRSAComponents::Type::Public)
1365             return;
1366 
1367         write(key.privateExponent());
1368 
1369         unsigned primeCount = key.hasAdditionalPrivateKeyParameters() ? key.otherPrimeInfos().size() + 2 : 0;
1370         write(primeCount);
1371         if (!primeCount)
1372             return;
1373 
1374         write(key.firstPrimeInfo().primeFactor);
1375         write(key.firstPrimeInfo().factorCRTExponent);
1376         write(key.secondPrimeInfo().primeFactor);
1377         write(key.secondPrimeInfo().factorCRTExponent);
1378         write(key.secondPrimeInfo().factorCRTCoefficient);
1379         for (unsigned i = 2; i &lt; primeCount; ++i) {
1380             write(key.otherPrimeInfos()[i].primeFactor);
1381             write(key.otherPrimeInfos()[i].factorCRTExponent);
1382             write(key.otherPrimeInfos()[i].factorCRTCoefficient);
1383         }
1384     }
1385 
1386     void write(const CryptoKey* key)
1387     {
1388         write(currentKeyFormatVersion);
1389 
1390         write(key-&gt;extractable());
1391 
1392         CryptoKeyUsageBitmap usages = key-&gt;usagesBitmap();
1393         write(countUsages(usages));
1394         if (usages &amp; CryptoKeyUsageEncrypt)
1395             write(CryptoKeyUsageTag::Encrypt);
1396         if (usages &amp; CryptoKeyUsageDecrypt)
1397             write(CryptoKeyUsageTag::Decrypt);
1398         if (usages &amp; CryptoKeyUsageSign)
1399             write(CryptoKeyUsageTag::Sign);
1400         if (usages &amp; CryptoKeyUsageVerify)
1401             write(CryptoKeyUsageTag::Verify);
1402         if (usages &amp; CryptoKeyUsageDeriveKey)
1403             write(CryptoKeyUsageTag::DeriveKey);
1404         if (usages &amp; CryptoKeyUsageDeriveBits)
1405             write(CryptoKeyUsageTag::DeriveBits);
1406         if (usages &amp; CryptoKeyUsageWrapKey)
1407             write(CryptoKeyUsageTag::WrapKey);
1408         if (usages &amp; CryptoKeyUsageUnwrapKey)
1409             write(CryptoKeyUsageTag::UnwrapKey);
1410 
1411         switch (key-&gt;keyClass()) {
1412         case CryptoKeyClass::HMAC:
1413             write(CryptoKeyClassSubtag::HMAC);
1414             write(downcast&lt;CryptoKeyHMAC&gt;(*key).key());
1415             write(downcast&lt;CryptoKeyHMAC&gt;(*key).hashAlgorithmIdentifier());
1416             break;
1417         case CryptoKeyClass::AES:
1418             write(CryptoKeyClassSubtag::AES);
1419             write(key-&gt;algorithmIdentifier());
1420             write(downcast&lt;CryptoKeyAES&gt;(*key).key());
1421             break;
1422         case CryptoKeyClass::EC:
1423             write(CryptoKeyClassSubtag::EC);
1424             write(key-&gt;algorithmIdentifier());
1425             write(downcast&lt;CryptoKeyEC&gt;(*key).namedCurveString());
1426             switch (key-&gt;type()) {
1427             case CryptoKey::Type::Public: {
1428                 write(CryptoKeyAsymmetricTypeSubtag::Public);
1429                 auto result = downcast&lt;CryptoKeyEC&gt;(*key).exportRaw();
1430                 ASSERT(!result.hasException());
1431                 write(result.releaseReturnValue());
1432                 break;
1433             }
1434             case CryptoKey::Type::Private: {
1435                 write(CryptoKeyAsymmetricTypeSubtag::Private);
1436                 // Use the standard complied method is not very efficient, but simple/reliable.
1437                 auto result = downcast&lt;CryptoKeyEC&gt;(*key).exportPkcs8();
1438                 ASSERT(!result.hasException());
1439                 write(result.releaseReturnValue());
1440                 break;
1441             }
1442             default:
1443                 ASSERT_NOT_REACHED();
1444             }
1445             break;
1446         case CryptoKeyClass::Raw:
1447             write(CryptoKeyClassSubtag::Raw);
1448             write(key-&gt;algorithmIdentifier());
1449             write(downcast&lt;CryptoKeyRaw&gt;(*key).key());
1450             break;
1451         case CryptoKeyClass::RSA:
1452             write(CryptoKeyClassSubtag::RSA);
1453             write(key-&gt;algorithmIdentifier());
1454             CryptoAlgorithmIdentifier hash;
1455             bool isRestrictedToHash = downcast&lt;CryptoKeyRSA&gt;(*key).isRestrictedToHash(hash);
1456             write(isRestrictedToHash);
1457             if (isRestrictedToHash)
1458                 write(hash);
1459             write(*downcast&lt;CryptoKeyRSA&gt;(*key).exportData());
1460             break;
1461         }
1462     }
1463 #endif
1464 
1465     void write(const uint8_t* data, unsigned length)
1466     {
1467         m_buffer.append(data, length);
1468     }
1469 
1470     Vector&lt;uint8_t&gt;&amp; m_buffer;
1471     Vector&lt;String&gt;&amp; m_blobURLs;
<a name="12" id="anc12"></a><span class="line-removed">1472     PAL::SessionID m_sessionID;</span>
1473     ObjectPool m_objectPool;
1474     ObjectPool m_transferredMessagePorts;
1475     ObjectPool m_transferredArrayBuffers;
1476     ObjectPool m_transferredImageBitmaps;
1477     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, uint32_t, IdentifierRepHash&gt; StringConstantPool;
1478     StringConstantPool m_constantPool;
1479     Identifier m_emptyIdentifier;
1480     SerializationContext m_context;
1481     ArrayBufferContentsArray&amp; m_sharedBuffers;
1482 #if ENABLE(WEBASSEMBLY)
1483     WasmModuleArray&amp; m_wasmModules;
1484 #endif
1485 };
1486 
1487 SerializationReturnCode CloneSerializer::serialize(JSValue in)
1488 {
1489     VM&amp; vm = m_exec-&gt;vm();
1490     Vector&lt;uint32_t, 16&gt; indexStack;
1491     Vector&lt;uint32_t, 16&gt; lengthStack;
1492     Vector&lt;PropertyNameArray, 16&gt; propertyStack;
1493     Vector&lt;JSObject*, 32&gt; inputObjectStack;
1494     Vector&lt;JSMapIterator*, 4&gt; mapIteratorStack;
1495     Vector&lt;JSSetIterator*, 4&gt; setIteratorStack;
1496     Vector&lt;JSValue, 4&gt; mapIteratorValueStack;
1497     Vector&lt;WalkerState, 16&gt; stateStack;
1498     WalkerState state = StateUnknown;
1499     JSValue inValue = in;
1500     while (1) {
1501         switch (state) {
1502             arrayStartState:
1503             case ArrayStartState: {
1504                 ASSERT(isArray(vm, inValue));
1505                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1506                     return SerializationReturnCode::StackOverflowError;
1507 
1508                 JSArray* inArray = asArray(inValue);
1509                 unsigned length = inArray-&gt;length();
1510                 if (!startArray(inArray))
1511                     break;
1512                 inputObjectStack.append(inArray);
1513                 indexStack.append(0);
1514                 lengthStack.append(length);
1515             }
1516             arrayStartVisitMember:
1517             FALLTHROUGH;
1518             case ArrayStartVisitMember: {
1519                 JSObject* array = inputObjectStack.last();
1520                 uint32_t index = indexStack.last();
1521                 if (index == lengthStack.last()) {
1522                     indexStack.removeLast();
1523                     lengthStack.removeLast();
1524 
<a name="13" id="anc13"></a><span class="line-modified">1525                     propertyStack.append(PropertyNameArray(&amp;vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));</span>
1526                     array-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(array, m_exec, propertyStack.last(), EnumerationMode());
1527                     if (propertyStack.last().size()) {
1528                         write(NonIndexPropertiesTag);
1529                         indexStack.append(0);
1530                         goto objectStartVisitMember;
1531                     }
1532                     propertyStack.removeLast();
1533 
1534                     endObject();
1535                     inputObjectStack.removeLast();
1536                     break;
1537                 }
1538                 inValue = array-&gt;getDirectIndex(m_exec, index);
1539                 if (!inValue) {
1540                     indexStack.last()++;
1541                     goto arrayStartVisitMember;
1542                 }
1543 
1544                 write(index);
1545                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1546                 if (dumpIfTerminal(inValue, terminalCode)) {
1547                     if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1548                         return terminalCode;
1549                     indexStack.last()++;
1550                     goto arrayStartVisitMember;
1551                 }
1552                 stateStack.append(ArrayEndVisitMember);
1553                 goto stateUnknown;
1554             }
1555             case ArrayEndVisitMember: {
1556                 indexStack.last()++;
1557                 goto arrayStartVisitMember;
1558             }
1559             objectStartState:
1560             case ObjectStartState: {
1561                 ASSERT(inValue.isObject());
1562                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1563                     return SerializationReturnCode::StackOverflowError;
1564                 JSObject* inObject = asObject(inValue);
1565                 if (!startObject(inObject))
1566                     break;
1567                 // At this point, all supported objects other than Object
1568                 // objects have been handled. If we reach this point and
1569                 // the input is not an Object object then we should throw
1570                 // a DataCloneError.
1571                 if (inObject-&gt;classInfo(vm) != JSFinalObject::info())
1572                     return SerializationReturnCode::DataCloneError;
1573                 inputObjectStack.append(inObject);
1574                 indexStack.append(0);
<a name="14" id="anc14"></a><span class="line-modified">1575                 propertyStack.append(PropertyNameArray(&amp;vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));</span>
1576                 inObject-&gt;methodTable(vm)-&gt;getOwnPropertyNames(inObject, m_exec, propertyStack.last(), EnumerationMode());
1577             }
1578             objectStartVisitMember:
1579             FALLTHROUGH;
1580             case ObjectStartVisitMember: {
1581                 JSObject* object = inputObjectStack.last();
1582                 uint32_t index = indexStack.last();
1583                 PropertyNameArray&amp; properties = propertyStack.last();
1584                 if (index == properties.size()) {
1585                     endObject();
1586                     inputObjectStack.removeLast();
1587                     indexStack.removeLast();
1588                     propertyStack.removeLast();
1589                     break;
1590                 }
1591                 inValue = getProperty(vm, object, properties[index]);
1592                 if (shouldTerminate())
1593                     return SerializationReturnCode::ExistingExceptionError;
1594 
1595                 if (!inValue) {
1596                     // Property was removed during serialisation
1597                     indexStack.last()++;
1598                     goto objectStartVisitMember;
1599                 }
1600                 write(properties[index]);
1601 
1602                 if (shouldTerminate())
1603                     return SerializationReturnCode::ExistingExceptionError;
1604 
1605                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1606                 if (!dumpIfTerminal(inValue, terminalCode)) {
1607                     stateStack.append(ObjectEndVisitMember);
1608                     goto stateUnknown;
1609                 }
1610                 if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1611                     return terminalCode;
1612                 FALLTHROUGH;
1613             }
1614             case ObjectEndVisitMember: {
1615                 if (shouldTerminate())
1616                     return SerializationReturnCode::ExistingExceptionError;
1617 
1618                 indexStack.last()++;
1619                 goto objectStartVisitMember;
1620             }
1621             mapStartState: {
1622                 ASSERT(inValue.isObject());
1623                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1624                     return SerializationReturnCode::StackOverflowError;
1625                 JSMap* inMap = jsCast&lt;JSMap*&gt;(inValue);
1626                 if (!startMap(inMap))
1627                     break;
<a name="15" id="anc15"></a><span class="line-modified">1628                 JSMapIterator* iterator = JSMapIterator::create(vm, vm.mapIteratorStructure.get(), inMap, IterateKeyValue);</span>
1629                 m_gcBuffer.appendWithCrashOnOverflow(inMap);
1630                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
1631                 mapIteratorStack.append(iterator);
1632                 inputObjectStack.append(inMap);
1633                 goto mapDataStartVisitEntry;
1634             }
1635             mapDataStartVisitEntry:
1636             case MapDataStartVisitEntry: {
1637                 JSMapIterator* iterator = mapIteratorStack.last();
1638                 JSValue key, value;
1639                 if (!iterator-&gt;nextKeyValue(m_exec, key, value)) {
1640                     mapIteratorStack.removeLast();
1641                     JSObject* object = inputObjectStack.last();
1642                     ASSERT(jsDynamicCast&lt;JSMap*&gt;(vm, object));
<a name="16" id="anc16"></a><span class="line-modified">1643                     propertyStack.append(PropertyNameArray(&amp;vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));</span>
1644                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());
1645                     write(NonMapPropertiesTag);
1646                     indexStack.append(0);
1647                     goto objectStartVisitMember;
1648                 }
1649                 inValue = key;
1650                 m_gcBuffer.appendWithCrashOnOverflow(value);
1651                 mapIteratorValueStack.append(value);
1652                 stateStack.append(MapDataEndVisitKey);
1653                 goto stateUnknown;
1654             }
1655             case MapDataEndVisitKey: {
1656                 inValue = mapIteratorValueStack.last();
1657                 mapIteratorValueStack.removeLast();
1658                 stateStack.append(MapDataEndVisitValue);
1659                 goto stateUnknown;
1660             }
1661             case MapDataEndVisitValue: {
1662                 goto mapDataStartVisitEntry;
1663             }
1664 
1665             setStartState: {
1666                 ASSERT(inValue.isObject());
1667                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1668                     return SerializationReturnCode::StackOverflowError;
1669                 JSSet* inSet = jsCast&lt;JSSet*&gt;(inValue);
1670                 if (!startSet(inSet))
1671                     break;
<a name="17" id="anc17"></a><span class="line-modified">1672                 JSSetIterator* iterator = JSSetIterator::create(vm, vm.setIteratorStructure.get(), inSet, IterateKey);</span>
1673                 m_gcBuffer.appendWithCrashOnOverflow(inSet);
1674                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
1675                 setIteratorStack.append(iterator);
1676                 inputObjectStack.append(inSet);
1677                 goto setDataStartVisitEntry;
1678             }
1679             setDataStartVisitEntry:
1680             case SetDataStartVisitEntry: {
1681                 JSSetIterator* iterator = setIteratorStack.last();
1682                 JSValue key;
1683                 if (!iterator-&gt;next(m_exec, key)) {
1684                     setIteratorStack.removeLast();
1685                     JSObject* object = inputObjectStack.last();
1686                     ASSERT(jsDynamicCast&lt;JSSet*&gt;(vm, object));
<a name="18" id="anc18"></a><span class="line-modified">1687                     propertyStack.append(PropertyNameArray(&amp;vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));</span>
1688                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());
1689                     write(NonSetPropertiesTag);
1690                     indexStack.append(0);
1691                     goto objectStartVisitMember;
1692                 }
1693                 inValue = key;
1694                 stateStack.append(SetDataEndVisitKey);
1695                 goto stateUnknown;
1696             }
1697             case SetDataEndVisitKey: {
1698                 goto setDataStartVisitEntry;
1699             }
1700 
1701             stateUnknown:
1702             case StateUnknown: {
1703                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1704                 if (dumpIfTerminal(inValue, terminalCode)) {
1705                     if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1706                         return terminalCode;
1707                     break;
1708                 }
1709 
1710                 if (isArray(vm, inValue))
1711                     goto arrayStartState;
1712                 if (isMap(vm, inValue))
1713                     goto mapStartState;
1714                 if (isSet(vm, inValue))
1715                     goto setStartState;
1716                 goto objectStartState;
1717             }
1718         }
1719         if (stateStack.isEmpty())
1720             break;
1721 
1722         state = stateStack.last();
1723         stateStack.removeLast();
1724     }
1725     if (m_failed)
1726         return SerializationReturnCode::UnspecifiedError;
1727 
1728     return SerializationReturnCode::SuccessfullyCompleted;
1729 }
1730 
1731 class CloneDeserializer : CloneBase {
1732 public:
1733     static String deserializeString(const Vector&lt;uint8_t&gt;&amp; buffer)
1734     {
1735         if (buffer.isEmpty())
1736             return String();
1737         const uint8_t* ptr = buffer.begin();
1738         const uint8_t* end = buffer.end();
1739         uint32_t version;
1740         if (!readLittleEndian(ptr, end, version) || version &gt; CurrentVersion)
1741             return String();
1742         uint8_t tag;
1743         if (!readLittleEndian(ptr, end, tag) || tag != StringTag)
1744             return String();
1745         uint32_t length;
1746         if (!readLittleEndian(ptr, end, length))
1747             return String();
1748         bool is8Bit = length &amp; StringDataIs8BitFlag;
1749         length &amp;= ~StringDataIs8BitFlag;
1750         String str;
1751         if (!readString(ptr, end, str, length, is8Bit))
1752             return String();
1753         return str;
1754     }
1755 
<a name="19" id="anc19"></a><span class="line-modified">1756     static DeserializationResult deserialize(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers, ArrayBufferContentsArray* arrayBufferContentsArray, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const PAL::SessionID&amp; sessionID, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers</span>
1757 #if ENABLE(WEBASSEMBLY)
1758         , WasmModuleArray* wasmModules
1759 #endif
1760         )
1761     {
1762         if (!buffer.size())
1763             return std::make_pair(jsNull(), SerializationReturnCode::UnspecifiedError);
<a name="20" id="anc20"></a><span class="line-modified">1764         CloneDeserializer deserializer(exec, globalObject, messagePorts, arrayBufferContentsArray, buffer, blobURLs, sessionID, blobFilePaths, sharedBuffers, WTFMove(imageBuffers)</span>
1765 #if ENABLE(WEBASSEMBLY)
1766             , wasmModules
1767 #endif
1768             );
1769         if (!deserializer.isValid())
1770             return std::make_pair(JSValue(), SerializationReturnCode::ValidationError);
1771         return deserializer.deserialize();
1772     }
1773 
1774 private:
1775     struct CachedString {
1776         CachedString(const String&amp; string)
1777             : m_string(string)
1778         {
1779         }
1780 
1781         JSValue jsString(ExecState* exec)
1782         {
1783             if (!m_jsString)
<a name="21" id="anc21"></a><span class="line-modified">1784                 m_jsString = JSC::jsString(exec, m_string);</span>
1785             return m_jsString;
1786         }
1787         const String&amp; string() { return m_string; }
1788         String takeString() { return WTFMove(m_string); }
1789 
1790     private:
1791         String m_string;
1792         JSValue m_jsString;
1793     };
1794 
1795     struct CachedStringRef {
1796         CachedStringRef()
1797             : m_base(0)
1798             , m_index(0)
1799         {
1800         }
1801         CachedStringRef(Vector&lt;CachedString&gt;* base, size_t index)
1802             : m_base(base)
1803             , m_index(index)
1804         {
1805         }
1806 
1807         CachedString* operator-&gt;() { ASSERT(m_base); return &amp;m_base-&gt;at(m_index); }
1808 
1809     private:
1810         Vector&lt;CachedString&gt;* m_base;
1811         size_t m_index;
1812     };
1813 
1814     CloneDeserializer(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers,
1815 #if ENABLE(WEBASSEMBLY)
1816         WasmModuleArray* wasmModules,
1817 #endif
1818         const Vector&lt;uint8_t&gt;&amp; buffer)
1819         : CloneBase(exec)
1820         , m_globalObject(globalObject)
1821         , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
1822         , m_ptr(buffer.data())
1823         , m_end(buffer.data() + buffer.size())
1824         , m_version(0xFFFFFFFF)
1825         , m_messagePorts(messagePorts)
1826         , m_arrayBufferContents(arrayBufferContents)
1827         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
1828         , m_imageBuffers(WTFMove(imageBuffers))
1829         , m_imageBitmaps(m_imageBuffers.size())
1830 #if ENABLE(WEBASSEMBLY)
1831         , m_wasmModules(wasmModules)
1832 #endif
1833     {
1834         if (!read(m_version))
1835             m_version = 0xFFFFFFFF;
1836     }
1837 
<a name="22" id="anc22"></a><span class="line-modified">1838     CloneDeserializer(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const PAL::SessionID&amp; sessionID, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers</span>
1839 #if ENABLE(WEBASSEMBLY)
1840         , WasmModuleArray* wasmModules
1841 #endif
1842         )
1843         : CloneBase(exec)
1844         , m_globalObject(globalObject)
1845         , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
1846         , m_ptr(buffer.data())
1847         , m_end(buffer.data() + buffer.size())
1848         , m_version(0xFFFFFFFF)
1849         , m_messagePorts(messagePorts)
1850         , m_arrayBufferContents(arrayBufferContents)
1851         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
1852         , m_blobURLs(blobURLs)
<a name="23" id="anc23"></a><span class="line-removed">1853         , m_sessionID(sessionID)</span>
1854         , m_blobFilePaths(blobFilePaths)
1855         , m_sharedBuffers(sharedBuffers)
1856         , m_imageBuffers(WTFMove(imageBuffers))
1857         , m_imageBitmaps(m_imageBuffers.size())
1858 #if ENABLE(WEBASSEMBLY)
1859         , m_wasmModules(wasmModules)
1860 #endif
1861     {
1862         if (!read(m_version))
1863             m_version = 0xFFFFFFFF;
1864     }
1865 
1866     DeserializationResult deserialize();
1867 
1868     bool isValid() const { return m_version &lt;= CurrentVersion; }
1869 
1870     template &lt;typename T&gt; bool readLittleEndian(T&amp; value)
1871     {
1872         if (m_failed || !readLittleEndian(m_ptr, m_end, value)) {
1873             fail();
1874             return false;
1875         }
1876         return true;
1877     }
1878 #if ASSUME_LITTLE_ENDIAN
1879     template &lt;typename T&gt; static bool readLittleEndian(const uint8_t*&amp; ptr, const uint8_t* end, T&amp; value)
1880     {
1881         if (ptr &gt; end - sizeof(value))
1882             return false;
1883 
1884         if (sizeof(T) == 1)
1885             value = *ptr++;
1886         else {
1887             value = *reinterpret_cast&lt;const T*&gt;(ptr);
1888             ptr += sizeof(T);
1889         }
1890         return true;
1891     }
1892 #else
1893     template &lt;typename T&gt; static bool readLittleEndian(const uint8_t*&amp; ptr, const uint8_t* end, T&amp; value)
1894     {
1895         if (ptr &gt; end - sizeof(value))
1896             return false;
1897 
1898         if (sizeof(T) == 1)
1899             value = *ptr++;
1900         else {
1901             value = 0;
1902             for (unsigned i = 0; i &lt; sizeof(T); i++)
1903                 value += ((T)*ptr++) &lt;&lt; (i * 8);
1904         }
1905         return true;
1906     }
1907 #endif
1908 
1909     bool read(uint32_t&amp; i)
1910     {
1911         return readLittleEndian(i);
1912     }
1913 
1914     bool read(int32_t&amp; i)
1915     {
1916         return readLittleEndian(*reinterpret_cast&lt;uint32_t*&gt;(&amp;i));
1917     }
1918 
1919     bool read(uint16_t&amp; i)
1920     {
1921         return readLittleEndian(i);
1922     }
1923 
1924     bool read(uint8_t&amp; i)
1925     {
1926         return readLittleEndian(i);
1927     }
1928 
1929     bool read(double&amp; d)
1930     {
1931         union {
1932             double d;
1933             uint64_t i64;
1934         } u;
1935         if (!readLittleEndian(u.i64))
1936             return false;
1937         d = u.d;
1938         return true;
1939     }
1940 
1941     bool read(unsigned long long&amp; i)
1942     {
1943         return readLittleEndian(i);
1944     }
1945 
1946     bool readStringIndex(uint32_t&amp; i)
1947     {
1948         return readConstantPoolIndex(m_constantPool, i);
1949     }
1950 
1951     template &lt;class T&gt; bool readConstantPoolIndex(const T&amp; constantPool, uint32_t&amp; i)
1952     {
1953         if (constantPool.size() &lt;= 0xFF) {
1954             uint8_t i8;
1955             if (!read(i8))
1956                 return false;
1957             i = i8;
1958             return true;
1959         }
1960         if (constantPool.size() &lt;= 0xFFFF) {
1961             uint16_t i16;
1962             if (!read(i16))
1963                 return false;
1964             i = i16;
1965             return true;
1966         }
1967         return read(i);
1968     }
1969 
1970     static bool readString(const uint8_t*&amp; ptr, const uint8_t* end, String&amp; str, unsigned length, bool is8Bit)
1971     {
1972         if (length &gt;= std::numeric_limits&lt;int32_t&gt;::max() / sizeof(UChar))
1973             return false;
1974 
1975         if (is8Bit) {
1976             if ((end - ptr) &lt; static_cast&lt;int&gt;(length))
1977                 return false;
1978             str = String(reinterpret_cast&lt;const LChar*&gt;(ptr), length);
1979             ptr += length;
1980             return true;
1981         }
1982 
1983         unsigned size = length * sizeof(UChar);
1984         if ((end - ptr) &lt; static_cast&lt;int&gt;(size))
1985             return false;
1986 
1987 #if ASSUME_LITTLE_ENDIAN
1988         str = String(reinterpret_cast&lt;const UChar*&gt;(ptr), length);
1989         ptr += length * sizeof(UChar);
1990 #else
1991         Vector&lt;UChar&gt; buffer;
1992         buffer.reserveCapacity(length);
1993         for (unsigned i = 0; i &lt; length; i++) {
1994             uint16_t ch;
1995             readLittleEndian(ptr, end, ch);
1996             buffer.append(ch);
1997         }
1998         str = String::adopt(WTFMove(buffer));
1999 #endif
2000         return true;
2001     }
2002 
2003     bool readStringData(CachedStringRef&amp; cachedString)
2004     {
2005         bool scratch;
2006         return readStringData(cachedString, scratch);
2007     }
2008 
2009     bool readStringData(CachedStringRef&amp; cachedString, bool&amp; wasTerminator)
2010     {
2011         if (m_failed)
2012             return false;
2013         uint32_t length = 0;
2014         if (!read(length))
2015             return false;
2016         if (length == TerminatorTag) {
2017             wasTerminator = true;
2018             return false;
2019         }
2020         if (length == StringPoolTag) {
2021             unsigned index = 0;
2022             if (!readStringIndex(index)) {
2023                 fail();
2024                 return false;
2025             }
2026             if (index &gt;= m_constantPool.size()) {
2027                 fail();
2028                 return false;
2029             }
2030             cachedString = CachedStringRef(&amp;m_constantPool, index);
2031             return true;
2032         }
2033         bool is8Bit = length &amp; StringDataIs8BitFlag;
2034         length &amp;= ~StringDataIs8BitFlag;
2035         String str;
2036         if (!readString(m_ptr, m_end, str, length, is8Bit)) {
2037             fail();
2038             return false;
2039         }
2040         m_constantPool.append(str);
2041         cachedString = CachedStringRef(&amp;m_constantPool, m_constantPool.size() - 1);
2042         return true;
2043     }
2044 
2045     SerializationTag readTag()
2046     {
2047         if (m_ptr &gt;= m_end)
2048             return ErrorTag;
2049         return static_cast&lt;SerializationTag&gt;(*m_ptr++);
2050     }
2051 
2052     bool readArrayBufferViewSubtag(ArrayBufferViewSubtag&amp; tag)
2053     {
2054         if (m_ptr &gt;= m_end)
2055             return false;
2056         tag = static_cast&lt;ArrayBufferViewSubtag&gt;(*m_ptr++);
2057         return true;
2058     }
2059 
2060     void putProperty(JSObject* object, unsigned index, JSValue value)
2061     {
2062         object-&gt;putDirectIndex(m_exec, index, value);
2063     }
2064 
2065     void putProperty(JSObject* object, const Identifier&amp; property, JSValue value)
2066     {
2067         object-&gt;putDirectMayBeIndex(m_exec, property, value);
2068     }
2069 
2070     bool readFile(RefPtr&lt;File&gt;&amp; file)
2071     {
2072         CachedStringRef path;
2073         if (!readStringData(path))
2074             return false;
2075         CachedStringRef url;
2076         if (!readStringData(url))
2077             return false;
2078         CachedStringRef type;
2079         if (!readStringData(type))
2080             return false;
2081         CachedStringRef name;
2082         if (!readStringData(name))
2083             return false;
2084         Optional&lt;int64_t&gt; optionalLastModified;
2085         if (m_version &gt; 6) {
2086             double lastModified;
2087             if (!read(lastModified))
2088                 return false;
2089             if (lastModified &gt;= 0)
2090                 optionalLastModified = lastModified;
2091         }
2092 
2093         // If the blob URL for this file has an associated blob file path, prefer that one over the &quot;built-in&quot; path.
2094         String filePath = blobFilePathForBlobURL(url-&gt;string());
2095         if (filePath.isEmpty())
2096             filePath = path-&gt;string();
2097 
2098         if (m_isDOMGlobalObject)
<a name="24" id="anc24"></a><span class="line-modified">2099             file = File::deserialize(filePath, URL(URL(), url-&gt;string()), type-&gt;string(), name-&gt;string(), optionalLastModified);</span>
2100         return true;
2101     }
2102 
2103     bool readArrayBuffer(RefPtr&lt;ArrayBuffer&gt;&amp; arrayBuffer)
2104     {
2105         uint32_t length;
2106         if (!read(length))
2107             return false;
2108         if (m_ptr + length &gt; m_end)
2109             return false;
2110         arrayBuffer = ArrayBuffer::create(m_ptr, length);
2111         m_ptr += length;
2112         return true;
2113     }
2114 
2115     bool readArrayBufferView(VM&amp; vm, JSValue&amp; arrayBufferView)
2116     {
2117         ArrayBufferViewSubtag arrayBufferViewSubtag;
2118         if (!readArrayBufferViewSubtag(arrayBufferViewSubtag))
2119             return false;
2120         uint32_t byteOffset;
2121         if (!read(byteOffset))
2122             return false;
2123         uint32_t byteLength;
2124         if (!read(byteLength))
2125             return false;
2126         JSObject* arrayBufferObj = asObject(readTerminal());
2127         if (!arrayBufferObj || !arrayBufferObj-&gt;inherits&lt;JSArrayBuffer&gt;(vm))
2128             return false;
2129 
2130         unsigned elementSize = typedArrayElementSize(arrayBufferViewSubtag);
2131         if (!elementSize)
2132             return false;
2133         unsigned length = byteLength / elementSize;
2134         if (length * elementSize != byteLength)
2135             return false;
2136 
2137         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = toPossiblySharedArrayBuffer(vm, arrayBufferObj);
2138         switch (arrayBufferViewSubtag) {
2139         case DataViewTag:
<a name="25" id="anc25"></a><span class="line-modified">2140             arrayBufferView = getJSValue(DataView::create(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2141             return true;
2142         case Int8ArrayTag:
2143             arrayBufferView = toJS(m_exec, m_globalObject, Int8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2144             return true;
2145         case Uint8ArrayTag:
2146             arrayBufferView = toJS(m_exec, m_globalObject, Uint8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2147             return true;
2148         case Uint8ClampedArrayTag:
2149             arrayBufferView = toJS(m_exec, m_globalObject, Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2150             return true;
2151         case Int16ArrayTag:
2152             arrayBufferView = toJS(m_exec, m_globalObject, Int16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2153             return true;
2154         case Uint16ArrayTag:
2155             arrayBufferView = toJS(m_exec, m_globalObject, Uint16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2156             return true;
2157         case Int32ArrayTag:
2158             arrayBufferView = toJS(m_exec, m_globalObject, Int32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2159             return true;
2160         case Uint32ArrayTag:
2161             arrayBufferView = toJS(m_exec, m_globalObject, Uint32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2162             return true;
2163         case Float32ArrayTag:
2164             arrayBufferView = toJS(m_exec, m_globalObject, Float32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2165             return true;
2166         case Float64ArrayTag:
2167             arrayBufferView = toJS(m_exec, m_globalObject, Float64Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2168             return true;
2169         default:
2170             return false;
2171         }
2172     }
2173 
2174     bool read(Vector&lt;uint8_t&gt;&amp; result)
2175     {
2176         ASSERT(result.isEmpty());
2177         uint32_t size;
2178         if (!read(size))
2179             return false;
2180         if (m_ptr + size &gt; m_end)
2181             return false;
2182         result.append(m_ptr, size);
2183         m_ptr += size;
2184         return true;
2185     }
2186 
2187 #if ENABLE(WEB_CRYPTO)
2188     bool read(CryptoAlgorithmIdentifier&amp; result)
2189     {
2190         uint8_t algorithmTag;
2191         if (!read(algorithmTag))
2192             return false;
2193         if (algorithmTag &gt; cryptoAlgorithmIdentifierTagMaximumValue)
2194             return false;
2195         switch (static_cast&lt;CryptoAlgorithmIdentifierTag&gt;(algorithmTag)) {
2196         case CryptoAlgorithmIdentifierTag::RSAES_PKCS1_v1_5:
2197             result = CryptoAlgorithmIdentifier::RSAES_PKCS1_v1_5;
2198             break;
2199         case CryptoAlgorithmIdentifierTag::RSASSA_PKCS1_v1_5:
2200             result = CryptoAlgorithmIdentifier::RSASSA_PKCS1_v1_5;
2201             break;
2202         case CryptoAlgorithmIdentifierTag::RSA_PSS:
2203             result = CryptoAlgorithmIdentifier::RSA_PSS;
2204             break;
2205         case CryptoAlgorithmIdentifierTag::RSA_OAEP:
2206             result = CryptoAlgorithmIdentifier::RSA_OAEP;
2207             break;
2208         case CryptoAlgorithmIdentifierTag::ECDSA:
2209             result = CryptoAlgorithmIdentifier::ECDSA;
2210             break;
2211         case CryptoAlgorithmIdentifierTag::ECDH:
2212             result = CryptoAlgorithmIdentifier::ECDH;
2213             break;
2214         case CryptoAlgorithmIdentifierTag::AES_CTR:
2215             result = CryptoAlgorithmIdentifier::AES_CTR;
2216             break;
2217         case CryptoAlgorithmIdentifierTag::AES_CBC:
2218             result = CryptoAlgorithmIdentifier::AES_CBC;
2219             break;
2220         case CryptoAlgorithmIdentifierTag::AES_GCM:
2221             result = CryptoAlgorithmIdentifier::AES_GCM;
2222             break;
2223         case CryptoAlgorithmIdentifierTag::AES_CFB:
2224             result = CryptoAlgorithmIdentifier::AES_CFB;
2225             break;
2226         case CryptoAlgorithmIdentifierTag::AES_KW:
2227             result = CryptoAlgorithmIdentifier::AES_KW;
2228             break;
2229         case CryptoAlgorithmIdentifierTag::HMAC:
2230             result = CryptoAlgorithmIdentifier::HMAC;
2231             break;
2232         case CryptoAlgorithmIdentifierTag::SHA_1:
2233             result = CryptoAlgorithmIdentifier::SHA_1;
2234             break;
2235         case CryptoAlgorithmIdentifierTag::SHA_224:
2236             result = CryptoAlgorithmIdentifier::SHA_224;
2237             break;
2238         case CryptoAlgorithmIdentifierTag::SHA_256:
2239             result = CryptoAlgorithmIdentifier::SHA_256;
2240             break;
2241         case CryptoAlgorithmIdentifierTag::SHA_384:
2242             result = CryptoAlgorithmIdentifier::SHA_384;
2243             break;
2244         case CryptoAlgorithmIdentifierTag::SHA_512:
2245             result = CryptoAlgorithmIdentifier::SHA_512;
2246             break;
2247         case CryptoAlgorithmIdentifierTag::HKDF:
2248             result = CryptoAlgorithmIdentifier::HKDF;
2249             break;
2250         case CryptoAlgorithmIdentifierTag::PBKDF2:
2251             result = CryptoAlgorithmIdentifier::PBKDF2;
2252             break;
2253         }
2254         return true;
2255     }
2256 
2257     bool read(CryptoKeyClassSubtag&amp; result)
2258     {
2259         uint8_t tag;
2260         if (!read(tag))
2261             return false;
2262         if (tag &gt; cryptoKeyClassSubtagMaximumValue)
2263             return false;
2264         result = static_cast&lt;CryptoKeyClassSubtag&gt;(tag);
2265         return true;
2266     }
2267 
2268     bool read(CryptoKeyUsageTag&amp; result)
2269     {
2270         uint8_t tag;
2271         if (!read(tag))
2272             return false;
2273         if (tag &gt; cryptoKeyUsageTagMaximumValue)
2274             return false;
2275         result = static_cast&lt;CryptoKeyUsageTag&gt;(tag);
2276         return true;
2277     }
2278 
2279     bool read(CryptoKeyAsymmetricTypeSubtag&amp; result)
2280     {
2281         uint8_t tag;
2282         if (!read(tag))
2283             return false;
2284         if (tag &gt; cryptoKeyAsymmetricTypeSubtagMaximumValue)
2285             return false;
2286         result = static_cast&lt;CryptoKeyAsymmetricTypeSubtag&gt;(tag);
2287         return true;
2288     }
2289 
2290     bool readHMACKey(bool extractable, CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2291     {
2292         Vector&lt;uint8_t&gt; keyData;
2293         if (!read(keyData))
2294             return false;
2295         CryptoAlgorithmIdentifier hash;
2296         if (!read(hash))
2297             return false;
2298         result = CryptoKeyHMAC::importRaw(0, hash, WTFMove(keyData), extractable, usages);
2299         return true;
2300     }
2301 
2302     bool readAESKey(bool extractable, CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2303     {
2304         CryptoAlgorithmIdentifier algorithm;
2305         if (!read(algorithm))
2306             return false;
2307         if (!CryptoKeyAES::isValidAESAlgorithm(algorithm))
2308             return false;
2309         Vector&lt;uint8_t&gt; keyData;
2310         if (!read(keyData))
2311             return false;
2312         result = CryptoKeyAES::importRaw(algorithm, WTFMove(keyData), extractable, usages);
2313         return true;
2314     }
2315 
2316     bool readRSAKey(bool extractable, CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2317     {
2318         CryptoAlgorithmIdentifier algorithm;
2319         if (!read(algorithm))
2320             return false;
2321 
2322         int32_t isRestrictedToHash;
2323         CryptoAlgorithmIdentifier hash;
2324         if (!read(isRestrictedToHash))
2325             return false;
2326         if (isRestrictedToHash &amp;&amp; !read(hash))
2327             return false;
2328 
2329         CryptoKeyAsymmetricTypeSubtag type;
2330         if (!read(type))
2331             return false;
2332 
2333         Vector&lt;uint8_t&gt; modulus;
2334         if (!read(modulus))
2335             return false;
2336         Vector&lt;uint8_t&gt; exponent;
2337         if (!read(exponent))
2338             return false;
2339 
2340         if (type == CryptoKeyAsymmetricTypeSubtag::Public) {
2341             auto keyData = CryptoKeyRSAComponents::createPublic(modulus, exponent);
2342             auto key = CryptoKeyRSA::create(algorithm, hash, isRestrictedToHash, *keyData, extractable, usages);
2343             result = WTFMove(key);
2344             return true;
2345         }
2346 
2347         Vector&lt;uint8_t&gt; privateExponent;
2348         if (!read(privateExponent))
2349             return false;
2350 
2351         uint32_t primeCount;
2352         if (!read(primeCount))
2353             return false;
2354 
2355         if (!primeCount) {
2356             auto keyData = CryptoKeyRSAComponents::createPrivate(modulus, exponent, privateExponent);
2357             auto key = CryptoKeyRSA::create(algorithm, hash, isRestrictedToHash, *keyData, extractable, usages);
2358             result = WTFMove(key);
2359             return true;
2360         }
2361 
2362         if (primeCount &lt; 2)
2363             return false;
2364 
2365         CryptoKeyRSAComponents::PrimeInfo firstPrimeInfo;
2366         CryptoKeyRSAComponents::PrimeInfo secondPrimeInfo;
2367         Vector&lt;CryptoKeyRSAComponents::PrimeInfo&gt; otherPrimeInfos(primeCount - 2);
2368 
2369         if (!read(firstPrimeInfo.primeFactor))
2370             return false;
2371         if (!read(firstPrimeInfo.factorCRTExponent))
2372             return false;
2373         if (!read(secondPrimeInfo.primeFactor))
2374             return false;
2375         if (!read(secondPrimeInfo.factorCRTExponent))
2376             return false;
2377         if (!read(secondPrimeInfo.factorCRTCoefficient))
2378             return false;
2379         for (unsigned i = 2; i &lt; primeCount; ++i) {
2380             if (!read(otherPrimeInfos[i].primeFactor))
2381                 return false;
2382             if (!read(otherPrimeInfos[i].factorCRTExponent))
2383                 return false;
2384             if (!read(otherPrimeInfos[i].factorCRTCoefficient))
2385                 return false;
2386         }
2387 
2388         auto keyData = CryptoKeyRSAComponents::createPrivateWithAdditionalData(modulus, exponent, privateExponent, firstPrimeInfo, secondPrimeInfo, otherPrimeInfos);
2389         auto key = CryptoKeyRSA::create(algorithm, hash, isRestrictedToHash, *keyData, extractable, usages);
2390         result = WTFMove(key);
2391         return true;
2392     }
2393 
2394     bool readECKey(bool extractable, CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2395     {
2396         CryptoAlgorithmIdentifier algorithm;
2397         if (!read(algorithm))
2398             return false;
2399         if (!CryptoKeyEC::isValidECAlgorithm(algorithm))
2400             return false;
2401         CachedStringRef curve;
2402         if (!readStringData(curve))
2403             return false;
2404         CryptoKeyAsymmetricTypeSubtag type;
2405         if (!read(type))
2406             return false;
2407         Vector&lt;uint8_t&gt; keyData;
2408         if (!read(keyData))
2409             return false;
2410 
2411         switch (type) {
2412         case CryptoKeyAsymmetricTypeSubtag::Public:
2413             result = CryptoKeyEC::importRaw(algorithm, curve-&gt;string(), WTFMove(keyData), extractable, usages);
2414             break;
2415         case CryptoKeyAsymmetricTypeSubtag::Private:
2416             result = CryptoKeyEC::importPkcs8(algorithm, curve-&gt;string(), WTFMove(keyData), extractable, usages);
2417             break;
2418         }
2419 
2420         return true;
2421     }
2422 
2423     bool readRawKey(CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2424     {
2425         CryptoAlgorithmIdentifier algorithm;
2426         if (!read(algorithm))
2427             return false;
2428         Vector&lt;uint8_t&gt; keyData;
2429         if (!read(keyData))
2430             return false;
2431         result = CryptoKeyRaw::create(algorithm, WTFMove(keyData), usages);
2432         return true;
2433     }
2434 
2435     bool readCryptoKey(JSValue&amp; cryptoKey)
2436     {
2437         uint32_t keyFormatVersion;
2438         if (!read(keyFormatVersion) || keyFormatVersion &gt; currentKeyFormatVersion)
2439             return false;
2440 
2441         int32_t extractable;
2442         if (!read(extractable))
2443             return false;
2444 
2445         uint32_t usagesCount;
2446         if (!read(usagesCount))
2447             return false;
2448 
2449         CryptoKeyUsageBitmap usages = 0;
2450         for (uint32_t i = 0; i &lt; usagesCount; ++i) {
2451             CryptoKeyUsageTag usage;
2452             if (!read(usage))
2453                 return false;
2454             switch (usage) {
2455             case CryptoKeyUsageTag::Encrypt:
2456                 usages |= CryptoKeyUsageEncrypt;
2457                 break;
2458             case CryptoKeyUsageTag::Decrypt:
2459                 usages |= CryptoKeyUsageDecrypt;
2460                 break;
2461             case CryptoKeyUsageTag::Sign:
2462                 usages |= CryptoKeyUsageSign;
2463                 break;
2464             case CryptoKeyUsageTag::Verify:
2465                 usages |= CryptoKeyUsageVerify;
2466                 break;
2467             case CryptoKeyUsageTag::DeriveKey:
2468                 usages |= CryptoKeyUsageDeriveKey;
2469                 break;
2470             case CryptoKeyUsageTag::DeriveBits:
2471                 usages |= CryptoKeyUsageDeriveBits;
2472                 break;
2473             case CryptoKeyUsageTag::WrapKey:
2474                 usages |= CryptoKeyUsageWrapKey;
2475                 break;
2476             case CryptoKeyUsageTag::UnwrapKey:
2477                 usages |= CryptoKeyUsageUnwrapKey;
2478                 break;
2479             }
2480         }
2481 
2482         CryptoKeyClassSubtag cryptoKeyClass;
2483         if (!read(cryptoKeyClass))
2484             return false;
2485         RefPtr&lt;CryptoKey&gt; result;
2486         switch (cryptoKeyClass) {
2487         case CryptoKeyClassSubtag::HMAC:
2488             if (!readHMACKey(extractable, usages, result))
2489                 return false;
2490             break;
2491         case CryptoKeyClassSubtag::AES:
2492             if (!readAESKey(extractable, usages, result))
2493                 return false;
2494             break;
2495         case CryptoKeyClassSubtag::RSA:
2496             if (!readRSAKey(extractable, usages, result))
2497                 return false;
2498             break;
2499         case CryptoKeyClassSubtag::EC:
2500             if (!readECKey(extractable, usages, result))
2501                 return false;
2502             break;
2503         case CryptoKeyClassSubtag::Raw:
2504             if (!readRawKey(usages, result))
2505                 return false;
2506             break;
2507         }
2508         cryptoKey = getJSValue(result.get());
2509         return true;
2510     }
2511 #endif
2512 
2513     template&lt;class T&gt;
2514     JSValue getJSValue(T* nativeObj)
2515     {
2516         return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), nativeObj);
2517     }
2518 
2519     template&lt;class T&gt;
2520     JSValue getJSValue(T&amp; nativeObj)
2521     {
2522         return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), nativeObj);
2523     }
2524 
2525     template&lt;class T&gt;
2526     JSValue readDOMPoint()
2527     {
2528         double x;
2529         if (!read(x))
2530             return { };
2531         double y;
2532         if (!read(y))
2533             return { };
2534         double z;
2535         if (!read(z))
2536             return { };
2537         double w;
2538         if (!read(w))
2539             return { };
2540 
2541         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, z, w));
2542     }
2543 
2544     template&lt;class T&gt;
2545     JSValue readDOMMatrix()
2546     {
2547         uint8_t is2D;
2548         if (!read(is2D))
2549             return { };
2550 
2551         if (is2D) {
2552             double m11;
2553             if (!read(m11))
2554                 return { };
2555             double m12;
2556             if (!read(m12))
2557                 return { };
2558             double m21;
2559             if (!read(m21))
2560                 return { };
2561             double m22;
2562             if (!read(m22))
2563                 return { };
2564             double m41;
2565             if (!read(m41))
2566                 return { };
2567             double m42;
2568             if (!read(m42))
2569                 return { };
2570 
2571             TransformationMatrix matrix(m11, m12, m21, m22, m41, m42);
2572             return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::Yes));
2573         } else {
2574             double m11;
2575             if (!read(m11))
2576                 return { };
2577             double m12;
2578             if (!read(m12))
2579                 return { };
2580             double m13;
2581             if (!read(m13))
2582                 return { };
2583             double m14;
2584             if (!read(m14))
2585                 return { };
2586             double m21;
2587             if (!read(m21))
2588                 return { };
2589             double m22;
2590             if (!read(m22))
2591                 return { };
2592             double m23;
2593             if (!read(m23))
2594                 return { };
2595             double m24;
2596             if (!read(m24))
2597                 return { };
2598             double m31;
2599             if (!read(m31))
2600                 return { };
2601             double m32;
2602             if (!read(m32))
2603                 return { };
2604             double m33;
2605             if (!read(m33))
2606                 return { };
2607             double m34;
2608             if (!read(m34))
2609                 return { };
2610             double m41;
2611             if (!read(m41))
2612                 return { };
2613             double m42;
2614             if (!read(m42))
2615                 return { };
2616             double m43;
2617             if (!read(m43))
2618                 return { };
2619             double m44;
2620             if (!read(m44))
2621                 return { };
2622 
2623             TransformationMatrix matrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44);
2624             return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::No));
2625         }
2626     }
2627 
2628     template&lt;class T&gt;
2629     JSValue readDOMRect()
2630     {
2631         double x;
2632         if (!read(x))
2633             return { };
2634         double y;
2635         if (!read(y))
2636             return { };
2637         double width;
2638         if (!read(width))
2639             return { };
2640         double height;
2641         if (!read(height))
2642             return { };
2643 
2644         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, width, height));
2645     }
2646 
2647     Optional&lt;DOMPointInit&gt; readDOMPointInit()
2648     {
2649         DOMPointInit point;
2650         if (!read(point.x))
2651             return WTF::nullopt;
2652         if (!read(point.y))
2653             return WTF::nullopt;
2654         if (!read(point.z))
2655             return WTF::nullopt;
2656         if (!read(point.w))
2657             return WTF::nullopt;
2658 
<a name="26" id="anc26"></a><span class="line-modified">2659         return WTFMove(point);</span>
2660     }
2661 
2662     JSValue readDOMQuad()
2663     {
2664         auto p1 = readDOMPointInit();
2665         if (!p1)
2666             return JSValue();
2667         auto p2 = readDOMPointInit();
2668         if (!p2)
2669             return JSValue();
2670         auto p3 = readDOMPointInit();
2671         if (!p3)
2672             return JSValue();
2673         auto p4 = readDOMPointInit();
2674         if (!p4)
2675             return JSValue();
2676 
2677         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), DOMQuad::create(p1.value(), p2.value(), p3.value(), p4.value()));
2678     }
2679 
2680     JSValue readImageBitmap()
2681     {
2682         uint32_t index;
2683         bool indexSuccessfullyRead = read(index);
2684         if (!indexSuccessfullyRead || index &gt;= m_imageBuffers.size()) {
2685             fail();
2686             return JSValue();
2687         }
2688 
2689         if (!m_imageBitmaps[index])
2690             m_imageBitmaps[index] = ImageBitmap::create(WTFMove(m_imageBuffers.at(index)));
2691 
2692         auto bitmap = m_imageBitmaps[index].get();
2693         return getJSValue(bitmap);
2694     }
2695 
2696 #if ENABLE(WEB_RTC)
2697     JSValue readRTCCertificate()
2698     {
2699         double expires;
2700         if (!read(expires)) {
2701             fail();
2702             return JSValue();
2703         }
2704         CachedStringRef certificate;
2705         if (!readStringData(certificate)) {
2706             fail();
2707             return JSValue();
2708         }
2709         CachedStringRef origin;
2710         if (!readStringData(origin)) {
2711             fail();
2712             return JSValue();
2713         }
2714         CachedStringRef keyedMaterial;
2715         if (!readStringData(keyedMaterial)) {
2716             fail();
2717             return JSValue();
2718         }
2719         unsigned size = 0;
2720         if (!read(size))
2721             return JSValue();
2722 
2723         Vector&lt;RTCCertificate::DtlsFingerprint&gt; fingerprints;
2724         fingerprints.reserveInitialCapacity(size);
2725         for (unsigned i = 0; i &lt; size; i++) {
2726             CachedStringRef algorithm;
2727             if (!readStringData(algorithm))
2728                 return JSValue();
2729             CachedStringRef value;
2730             if (!readStringData(value))
2731                 return JSValue();
2732             fingerprints.uncheckedAppend(RTCCertificate::DtlsFingerprint { algorithm-&gt;string(), value-&gt;string() });
2733         }
2734 
2735         if (!m_isDOMGlobalObject)
2736             return constructEmptyObject(m_exec, m_globalObject-&gt;objectPrototype());
2737 
2738         auto rtcCertificate = RTCCertificate::create(SecurityOrigin::createFromString(origin-&gt;string()), expires, WTFMove(fingerprints), certificate-&gt;takeString(), keyedMaterial-&gt;takeString());
2739         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), WTFMove(rtcCertificate));
2740     }
2741 #endif
2742 
2743     JSValue readTerminal()
2744     {
2745         SerializationTag tag = readTag();
2746         switch (tag) {
2747         case UndefinedTag:
2748             return jsUndefined();
2749         case NullTag:
2750             return jsNull();
2751         case IntTag: {
2752             int32_t i;
2753             if (!read(i))
2754                 return JSValue();
2755             return jsNumber(i);
2756         }
2757         case ZeroTag:
2758             return jsNumber(0);
2759         case OneTag:
2760             return jsNumber(1);
2761         case FalseTag:
2762             return jsBoolean(false);
2763         case TrueTag:
2764             return jsBoolean(true);
2765         case FalseObjectTag: {
2766             BooleanObject* obj = BooleanObject::create(m_exec-&gt;vm(), m_globalObject-&gt;booleanObjectStructure());
2767             obj-&gt;setInternalValue(m_exec-&gt;vm(), jsBoolean(false));
2768             m_gcBuffer.appendWithCrashOnOverflow(obj);
2769             return obj;
2770         }
2771         case TrueObjectTag: {
2772             BooleanObject* obj = BooleanObject::create(m_exec-&gt;vm(), m_globalObject-&gt;booleanObjectStructure());
2773             obj-&gt;setInternalValue(m_exec-&gt;vm(), jsBoolean(true));
2774             m_gcBuffer.appendWithCrashOnOverflow(obj);
2775             return obj;
2776         }
2777         case DoubleTag: {
2778             double d;
2779             if (!read(d))
2780                 return JSValue();
2781             return jsNumber(d);
2782         }
2783         case NumberObjectTag: {
2784             double d;
2785             if (!read(d))
2786                 return JSValue();
2787             NumberObject* obj = constructNumber(m_exec, m_globalObject, jsNumber(d));
2788             m_gcBuffer.appendWithCrashOnOverflow(obj);
2789             return obj;
2790         }
2791         case DateTag: {
2792             double d;
2793             if (!read(d))
2794                 return JSValue();
2795             return DateInstance::create(m_exec-&gt;vm(), m_globalObject-&gt;dateStructure(), d);
2796         }
2797         case FileTag: {
2798             RefPtr&lt;File&gt; file;
2799             if (!readFile(file))
2800                 return JSValue();
2801             if (!m_isDOMGlobalObject)
2802                 return jsNull();
2803             return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), file.get());
2804         }
2805         case FileListTag: {
2806             unsigned length = 0;
2807             if (!read(length))
2808                 return JSValue();
2809             Vector&lt;Ref&lt;File&gt;&gt; files;
2810             for (unsigned i = 0; i &lt; length; i++) {
2811                 RefPtr&lt;File&gt; file;
2812                 if (!readFile(file))
2813                     return JSValue();
2814                 if (m_isDOMGlobalObject)
2815                     files.append(file.releaseNonNull());
2816             }
2817             if (!m_isDOMGlobalObject)
2818                 return jsNull();
2819             return getJSValue(FileList::create(WTFMove(files)).get());
2820         }
2821         case ImageDataTag: {
2822             uint32_t width;
2823             if (!read(width))
2824                 return JSValue();
2825             uint32_t height;
2826             if (!read(height))
2827                 return JSValue();
2828             uint32_t length;
2829             if (!read(length))
2830                 return JSValue();
2831             if (static_cast&lt;uint32_t&gt;(m_end - m_ptr) &lt; length) {
2832                 fail();
2833                 return JSValue();
2834             }
2835             if (!m_isDOMGlobalObject) {
2836                 m_ptr += length;
2837                 return jsNull();
2838             }
2839             IntSize imageSize(width, height);
2840             RELEASE_ASSERT(!length || (imageSize.area() * 4).unsafeGet() &lt;= length);
2841             auto result = ImageData::create(imageSize);
2842             if (!result) {
2843                 fail();
2844                 return JSValue();
2845             }
2846             if (length)
2847                 memcpy(result-&gt;data()-&gt;data(), m_ptr, length);
2848             else
2849                 result-&gt;data()-&gt;zeroFill();
2850             m_ptr += length;
2851             return getJSValue(result.get());
2852         }
2853         case BlobTag: {
2854             CachedStringRef url;
2855             if (!readStringData(url))
2856                 return JSValue();
2857             CachedStringRef type;
2858             if (!readStringData(type))
2859                 return JSValue();
2860             unsigned long long size = 0;
2861             if (!read(size))
2862                 return JSValue();
2863             if (!m_isDOMGlobalObject)
2864                 return jsNull();
<a name="27" id="anc27"></a><span class="line-modified">2865             return getJSValue(Blob::deserialize(URL(URL(), url-&gt;string()), type-&gt;string(), size, blobFilePathForBlobURL(url-&gt;string())).get());</span>
2866         }
2867         case StringTag: {
2868             CachedStringRef cachedString;
2869             if (!readStringData(cachedString))
2870                 return JSValue();
2871             return cachedString-&gt;jsString(m_exec);
2872         }
2873         case EmptyStringTag:
<a name="28" id="anc28"></a><span class="line-modified">2874             return jsEmptyString(&amp;m_exec-&gt;vm());</span>
2875         case StringObjectTag: {
2876             CachedStringRef cachedString;
2877             if (!readStringData(cachedString))
2878                 return JSValue();
2879             StringObject* obj = constructString(m_exec-&gt;vm(), m_globalObject, cachedString-&gt;jsString(m_exec));
2880             m_gcBuffer.appendWithCrashOnOverflow(obj);
2881             return obj;
2882         }
2883         case EmptyStringObjectTag: {
2884             VM&amp; vm = m_exec-&gt;vm();
<a name="29" id="anc29"></a><span class="line-modified">2885             StringObject* obj = constructString(vm, m_globalObject, jsEmptyString(&amp;vm));</span>
2886             m_gcBuffer.appendWithCrashOnOverflow(obj);
2887             return obj;
2888         }
2889         case RegExpTag: {
2890             CachedStringRef pattern;
2891             if (!readStringData(pattern))
2892                 return JSValue();
2893             CachedStringRef flags;
2894             if (!readStringData(flags))
2895                 return JSValue();
<a name="30" id="anc30"></a><span class="line-modified">2896             RegExpFlags reFlags = regExpFlags(flags-&gt;string());</span>
<span class="line-modified">2897             ASSERT(reFlags != InvalidFlags);</span>
2898             VM&amp; vm = m_exec-&gt;vm();
<a name="31" id="anc31"></a><span class="line-modified">2899             RegExp* regExp = RegExp::create(vm, pattern-&gt;string(), reFlags);</span>
2900             return RegExpObject::create(vm, m_globalObject-&gt;regExpStructure(), regExp);
2901         }
2902         case ObjectReferenceTag: {
2903             unsigned index = 0;
2904             if (!readConstantPoolIndex(m_gcBuffer, index)) {
2905                 fail();
2906                 return JSValue();
2907             }
2908             return m_gcBuffer.at(index);
2909         }
2910         case MessagePortReferenceTag: {
2911             uint32_t index;
2912             bool indexSuccessfullyRead = read(index);
2913             if (!indexSuccessfullyRead || index &gt;= m_messagePorts.size()) {
2914                 fail();
2915                 return JSValue();
2916             }
2917             return getJSValue(m_messagePorts[index].get());
2918         }
2919 #if ENABLE(WEBASSEMBLY)
2920         case WasmModuleTag: {
2921             uint32_t index;
2922             bool indexSuccessfullyRead = read(index);
2923             if (!indexSuccessfullyRead || !m_wasmModules || index &gt;= m_wasmModules-&gt;size()) {
2924                 fail();
2925                 return JSValue();
2926             }
2927             auto scope = DECLARE_THROW_SCOPE(m_exec-&gt;vm());
<a name="32" id="anc32"></a><span class="line-modified">2928             JSValue result = JSC::JSWebAssemblyModule::createStub(m_exec-&gt;vm(), m_exec, m_globalObject-&gt;WebAssemblyModuleStructure(), m_wasmModules-&gt;at(index));</span>
2929             // Since we are cloning a JSWebAssemblyModule, it&#39;s impossible for that
2930             // module to not have been a valid module. Therefore, createStub should
2931             // not trow.
2932             scope.releaseAssertNoException();
2933             m_gcBuffer.appendWithCrashOnOverflow(result);
2934             return result;
2935         }
2936 #endif
2937         case ArrayBufferTag: {
2938             RefPtr&lt;ArrayBuffer&gt; arrayBuffer;
2939             if (!readArrayBuffer(arrayBuffer)) {
2940                 fail();
2941                 return JSValue();
2942             }
2943             Structure* structure = m_globalObject-&gt;arrayBufferStructure(arrayBuffer-&gt;sharingMode());
2944             // A crazy RuntimeFlags mismatch could mean that we are not equipped to handle shared
2945             // array buffers while the sender is. In that case, we would see a null structure here.
2946             if (!structure) {
2947                 fail();
2948                 return JSValue();
2949             }
2950             JSValue result = JSArrayBuffer::create(m_exec-&gt;vm(), structure, WTFMove(arrayBuffer));
2951             m_gcBuffer.appendWithCrashOnOverflow(result);
2952             return result;
2953         }
2954         case ArrayBufferTransferTag: {
2955             uint32_t index;
2956             bool indexSuccessfullyRead = read(index);
2957             if (!indexSuccessfullyRead || index &gt;= m_arrayBuffers.size()) {
2958                 fail();
2959                 return JSValue();
2960             }
2961 
2962             if (!m_arrayBuffers[index])
2963                 m_arrayBuffers[index] = ArrayBuffer::create(WTFMove(m_arrayBufferContents-&gt;at(index)));
2964 
2965             return getJSValue(m_arrayBuffers[index].get());
2966         }
2967         case SharedArrayBufferTag: {
2968             uint32_t index = UINT_MAX;
2969             bool indexSuccessfullyRead = read(index);
2970             if (!indexSuccessfullyRead || !m_sharedBuffers || index &gt;= m_sharedBuffers-&gt;size()) {
2971                 fail();
2972                 return JSValue();
2973             }
2974 
2975             RELEASE_ASSERT(m_sharedBuffers-&gt;at(index));
2976             auto buffer = ArrayBuffer::create(WTFMove(m_sharedBuffers-&gt;at(index)));
2977             JSValue result = getJSValue(buffer.get());
2978             m_gcBuffer.appendWithCrashOnOverflow(result);
2979             return result;
2980         }
2981         case ArrayBufferViewTag: {
2982             JSValue arrayBufferView;
2983             if (!readArrayBufferView(m_exec-&gt;vm(), arrayBufferView)) {
2984                 fail();
2985                 return JSValue();
2986             }
2987             m_gcBuffer.appendWithCrashOnOverflow(arrayBufferView);
2988             return arrayBufferView;
2989         }
2990 #if ENABLE(WEB_CRYPTO)
2991         case CryptoKeyTag: {
2992             Vector&lt;uint8_t&gt; wrappedKey;
2993             if (!read(wrappedKey)) {
2994                 fail();
2995                 return JSValue();
2996             }
2997             Vector&lt;uint8_t&gt; serializedKey;
2998             if (!unwrapCryptoKey(m_exec, wrappedKey, serializedKey)) {
2999                 fail();
3000                 return JSValue();
3001             }
3002             JSValue cryptoKey;
3003             Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
3004             CloneDeserializer rawKeyDeserializer(m_exec, m_globalObject, dummyMessagePorts, nullptr, { },
3005 #if ENABLE(WEBASSEMBLY)
3006                 nullptr,
3007 #endif
3008                 serializedKey);
3009             if (!rawKeyDeserializer.readCryptoKey(cryptoKey)) {
3010                 fail();
3011                 return JSValue();
3012             }
3013             m_gcBuffer.appendWithCrashOnOverflow(cryptoKey);
3014             return cryptoKey;
3015         }
3016 #endif
3017         case DOMPointReadOnlyTag:
3018             return readDOMPoint&lt;DOMPointReadOnly&gt;();
3019         case DOMPointTag:
3020             return readDOMPoint&lt;DOMPoint&gt;();
3021         case DOMRectReadOnlyTag:
3022             return readDOMRect&lt;DOMRectReadOnly&gt;();
3023         case DOMRectTag:
3024             return readDOMRect&lt;DOMRect&gt;();
3025         case DOMMatrixReadOnlyTag:
3026             return readDOMMatrix&lt;DOMMatrixReadOnly&gt;();
3027         case DOMMatrixTag:
3028             return readDOMMatrix&lt;DOMMatrix&gt;();
3029         case DOMQuadTag:
3030             return readDOMQuad();
3031         case ImageBitmapTransferTag:
3032             return readImageBitmap();
3033 #if ENABLE(WEB_RTC)
3034         case RTCCertificateTag:
3035             return readRTCCertificate();
3036 
3037 #endif
3038         default:
3039             m_ptr--; // Push the tag back
3040             return JSValue();
3041         }
3042     }
3043 
3044     template&lt;SerializationTag Tag&gt;
3045     bool consumeCollectionDataTerminationIfPossible()
3046     {
3047         if (readTag() == Tag)
3048             return true;
3049         m_ptr--;
3050         return false;
3051     }
3052 
3053     JSGlobalObject* m_globalObject;
3054     bool m_isDOMGlobalObject;
3055     const uint8_t* m_ptr;
3056     const uint8_t* m_end;
3057     unsigned m_version;
3058     Vector&lt;CachedString&gt; m_constantPool;
3059     const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; m_messagePorts;
3060     ArrayBufferContentsArray* m_arrayBufferContents;
3061     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; m_arrayBuffers;
3062     Vector&lt;String&gt; m_blobURLs;
<a name="33" id="anc33"></a><span class="line-removed">3063     PAL::SessionID m_sessionID;</span>
3064     Vector&lt;String&gt; m_blobFilePaths;
3065     ArrayBufferContentsArray* m_sharedBuffers;
3066     Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt; m_imageBuffers;
3067     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; m_imageBitmaps;
3068 #if ENABLE(WEBASSEMBLY)
3069     WasmModuleArray* m_wasmModules;
3070 #endif
3071 
3072     String blobFilePathForBlobURL(const String&amp; blobURL)
3073     {
3074         size_t i = 0;
3075         for (; i &lt; m_blobURLs.size(); ++i) {
3076             if (m_blobURLs[i] == blobURL)
3077                 break;
3078         }
3079 
3080         return i &lt; m_blobURLs.size() ? m_blobFilePaths[i] : String();
3081     }
3082 };
3083 
3084 DeserializationResult CloneDeserializer::deserialize()
3085 {
3086     VM&amp; vm = m_exec-&gt;vm();
3087     auto scope = DECLARE_THROW_SCOPE(vm);
3088 
3089     Vector&lt;uint32_t, 16&gt; indexStack;
3090     Vector&lt;Identifier, 16&gt; propertyNameStack;
3091     Vector&lt;JSObject*, 32&gt; outputObjectStack;
3092     Vector&lt;JSValue, 4&gt; mapKeyStack;
3093     Vector&lt;JSMap*, 4&gt; mapStack;
3094     Vector&lt;JSSet*, 4&gt; setStack;
3095     Vector&lt;WalkerState, 16&gt; stateStack;
3096     WalkerState state = StateUnknown;
3097     JSValue outValue;
3098 
3099     while (1) {
3100         switch (state) {
3101         arrayStartState:
3102         case ArrayStartState: {
3103             uint32_t length;
3104             if (!read(length)) {
3105                 fail();
3106                 goto error;
3107             }
3108             JSArray* outArray = constructEmptyArray(m_exec, 0, m_globalObject, length);
3109             if (UNLIKELY(scope.exception()))
3110                 goto error;
3111             m_gcBuffer.appendWithCrashOnOverflow(outArray);
3112             outputObjectStack.append(outArray);
3113         }
3114         arrayStartVisitMember:
3115         FALLTHROUGH;
3116         case ArrayStartVisitMember: {
3117             uint32_t index;
3118             if (!read(index)) {
3119                 fail();
3120                 goto error;
3121             }
3122             if (index == TerminatorTag) {
3123                 JSObject* outArray = outputObjectStack.last();
3124                 outValue = outArray;
3125                 outputObjectStack.removeLast();
3126                 break;
3127             } else if (index == NonIndexPropertiesTag) {
3128                 goto objectStartVisitMember;
3129             }
3130 
3131             if (JSValue terminal = readTerminal()) {
3132                 putProperty(outputObjectStack.last(), index, terminal);
3133                 goto arrayStartVisitMember;
3134             }
3135             if (m_failed)
3136                 goto error;
3137             indexStack.append(index);
3138             stateStack.append(ArrayEndVisitMember);
3139             goto stateUnknown;
3140         }
3141         case ArrayEndVisitMember: {
3142             JSObject* outArray = outputObjectStack.last();
3143             putProperty(outArray, indexStack.last(), outValue);
3144             indexStack.removeLast();
3145             goto arrayStartVisitMember;
3146         }
3147         objectStartState:
3148         case ObjectStartState: {
3149             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3150                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
3151             JSObject* outObject = constructEmptyObject(m_exec, m_globalObject-&gt;objectPrototype());
3152             m_gcBuffer.appendWithCrashOnOverflow(outObject);
3153             outputObjectStack.append(outObject);
3154         }
3155         objectStartVisitMember:
3156         FALLTHROUGH;
3157         case ObjectStartVisitMember: {
3158             CachedStringRef cachedString;
3159             bool wasTerminator = false;
3160             if (!readStringData(cachedString, wasTerminator)) {
3161                 if (!wasTerminator)
3162                     goto error;
3163 
3164                 JSObject* outObject = outputObjectStack.last();
3165                 outValue = outObject;
3166                 outputObjectStack.removeLast();
3167                 break;
3168             }
3169 
3170             if (JSValue terminal = readTerminal()) {
<a name="34" id="anc34"></a><span class="line-modified">3171                 putProperty(outputObjectStack.last(), Identifier::fromString(m_exec, cachedString-&gt;string()), terminal);</span>
3172                 goto objectStartVisitMember;
3173             }
3174             stateStack.append(ObjectEndVisitMember);
<a name="35" id="anc35"></a><span class="line-modified">3175             propertyNameStack.append(Identifier::fromString(m_exec, cachedString-&gt;string()));</span>
3176             goto stateUnknown;
3177         }
3178         case ObjectEndVisitMember: {
3179             putProperty(outputObjectStack.last(), propertyNameStack.last(), outValue);
3180             propertyNameStack.removeLast();
3181             goto objectStartVisitMember;
3182         }
3183         mapObjectStartState: {
3184             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3185                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
3186             JSMap* map = JSMap::create(m_exec, m_exec-&gt;vm(), m_globalObject-&gt;mapStructure());
3187             if (UNLIKELY(scope.exception()))
3188                 goto error;
3189             m_gcBuffer.appendWithCrashOnOverflow(map);
3190             outputObjectStack.append(map);
3191             mapStack.append(map);
3192             goto mapDataStartVisitEntry;
3193         }
3194         mapDataStartVisitEntry:
3195         case MapDataStartVisitEntry: {
3196             if (consumeCollectionDataTerminationIfPossible&lt;NonMapPropertiesTag&gt;()) {
3197                 mapStack.removeLast();
3198                 goto objectStartVisitMember;
3199             }
3200             stateStack.append(MapDataEndVisitKey);
3201             goto stateUnknown;
3202         }
3203         case MapDataEndVisitKey: {
3204             mapKeyStack.append(outValue);
3205             stateStack.append(MapDataEndVisitValue);
3206             goto stateUnknown;
3207         }
3208         case MapDataEndVisitValue: {
3209             mapStack.last()-&gt;set(m_exec, mapKeyStack.last(), outValue);
3210             mapKeyStack.removeLast();
3211             goto mapDataStartVisitEntry;
3212         }
3213 
3214         setObjectStartState: {
3215             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3216                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
3217             JSSet* set = JSSet::create(m_exec, m_exec-&gt;vm(), m_globalObject-&gt;setStructure());
3218             if (UNLIKELY(scope.exception()))
3219                 goto error;
3220             m_gcBuffer.appendWithCrashOnOverflow(set);
3221             outputObjectStack.append(set);
3222             setStack.append(set);
3223             goto setDataStartVisitEntry;
3224         }
3225         setDataStartVisitEntry:
3226         case SetDataStartVisitEntry: {
3227             if (consumeCollectionDataTerminationIfPossible&lt;NonSetPropertiesTag&gt;()) {
3228                 setStack.removeLast();
3229                 goto objectStartVisitMember;
3230             }
3231             stateStack.append(SetDataEndVisitKey);
3232             goto stateUnknown;
3233         }
3234         case SetDataEndVisitKey: {
3235             JSSet* set = setStack.last();
3236             set-&gt;add(m_exec, outValue);
3237             goto setDataStartVisitEntry;
3238         }
3239 
3240         stateUnknown:
3241         case StateUnknown:
3242             if (JSValue terminal = readTerminal()) {
3243                 outValue = terminal;
3244                 break;
3245             }
3246             SerializationTag tag = readTag();
3247             if (tag == ArrayTag)
3248                 goto arrayStartState;
3249             if (tag == ObjectTag)
3250                 goto objectStartState;
3251             if (tag == MapObjectTag)
3252                 goto mapObjectStartState;
3253             if (tag == SetObjectTag)
3254                 goto setObjectStartState;
3255             goto error;
3256         }
3257         if (stateStack.isEmpty())
3258             break;
3259 
3260         state = stateStack.last();
3261         stateStack.removeLast();
3262     }
3263     ASSERT(outValue);
3264     ASSERT(!m_failed);
3265     return std::make_pair(outValue, SerializationReturnCode::SuccessfullyCompleted);
3266 error:
3267     fail();
3268     return std::make_pair(JSValue(), SerializationReturnCode::ValidationError);
3269 }
3270 
3271 SerializedScriptValue::~SerializedScriptValue() = default;
3272 
3273 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer)
3274     : m_data(WTFMove(buffer))
3275 {
3276 }
3277 
3278 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray)
3279     : m_data(WTFMove(buffer))
3280     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
3281 {
3282 }
3283 
<a name="36" id="anc36"></a><span class="line-modified">3284 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const PAL::SessionID&amp; sessionID,  std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray, std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBufferContentsArray, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers</span>
3285 #if ENABLE(WEBASSEMBLY)
3286         , std::unique_ptr&lt;WasmModuleArray&gt; wasmModulesArray
3287 #endif
3288         )
3289     : m_data(WTFMove(buffer))
3290     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
3291     , m_sharedBufferContentsArray(WTFMove(sharedBufferContentsArray))
3292     , m_imageBuffers(WTFMove(imageBuffers))
3293 #if ENABLE(WEBASSEMBLY)
3294     , m_wasmModulesArray(WTFMove(wasmModulesArray))
3295 #endif
<a name="37" id="anc37"></a><span class="line-removed">3296     , m_sessionID(sessionID)</span>
3297 {
3298     // Since this SerializedScriptValue is meant to be passed between threads, its String data members
3299     // need to be isolatedCopies so we don&#39;t run into thread safety issues for the StringImpls.
3300     m_blobURLs.reserveInitialCapacity(blobURLs.size());
3301     for (auto&amp; url : blobURLs)
3302         m_blobURLs.uncheckedAppend(url.isolatedCopy());
3303 }
3304 
3305 static ExceptionOr&lt;std::unique_ptr&lt;ArrayBufferContentsArray&gt;&gt; transferArrayBuffers(VM&amp; vm, const Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers)
3306 {
3307     if (arrayBuffers.isEmpty())
3308         return nullptr;
3309 
<a name="38" id="anc38"></a><span class="line-modified">3310     auto contents = std::make_unique&lt;ArrayBufferContentsArray&gt;(arrayBuffers.size());</span>
3311 
3312     HashSet&lt;JSC::ArrayBuffer*&gt; visited;
3313     for (size_t arrayBufferIndex = 0; arrayBufferIndex &lt; arrayBuffers.size(); arrayBufferIndex++) {
3314         if (visited.contains(arrayBuffers[arrayBufferIndex].get()))
3315             continue;
3316         visited.add(arrayBuffers[arrayBufferIndex].get());
3317 
3318         bool result = arrayBuffers[arrayBufferIndex]-&gt;transferTo(vm, contents-&gt;at(arrayBufferIndex));
3319         if (!result)
3320             return Exception { TypeError };
3321     }
3322 
<a name="39" id="anc39"></a><span class="line-modified">3323     return WTFMove(contents);</span>
3324 }
3325 
3326 static void maybeThrowExceptionIfSerializationFailed(ExecState&amp; state, SerializationReturnCode code)
3327 {
3328     auto&amp; vm = state.vm();
3329     auto scope = DECLARE_THROW_SCOPE(vm);
3330 
3331     switch (code) {
3332     case SerializationReturnCode::SuccessfullyCompleted:
3333         break;
3334     case SerializationReturnCode::StackOverflowError:
3335         throwException(&amp;state, scope, createStackOverflowError(&amp;state));
3336         break;
3337     case SerializationReturnCode::ValidationError:
3338         throwTypeError(&amp;state, scope, &quot;Unable to deserialize data.&quot;_s);
3339         break;
3340     case SerializationReturnCode::DataCloneError:
3341         throwDataCloneError(state, scope);
3342         break;
3343     case SerializationReturnCode::ExistingExceptionError:
3344     case SerializationReturnCode::UnspecifiedError:
3345         break;
3346     case SerializationReturnCode::InterruptedExecutionError:
3347         ASSERT_NOT_REACHED();
3348     }
3349 }
3350 
3351 static Exception exceptionForSerializationFailure(SerializationReturnCode code)
3352 {
3353     ASSERT(code != SerializationReturnCode::SuccessfullyCompleted);
3354 
3355     switch (code) {
3356     case SerializationReturnCode::StackOverflowError:
3357         return Exception { StackOverflowError };
3358     case SerializationReturnCode::ValidationError:
3359         return Exception { TypeError };
3360     case SerializationReturnCode::DataCloneError:
3361         return Exception { DataCloneError };
3362     case SerializationReturnCode::ExistingExceptionError:
3363         return Exception { ExistingExceptionError };
3364     case SerializationReturnCode::UnspecifiedError:
3365         return Exception { TypeError };
3366     case SerializationReturnCode::SuccessfullyCompleted:
3367     case SerializationReturnCode::InterruptedExecutionError:
3368         ASSERT_NOT_REACHED();
3369         return Exception { TypeError };
3370     }
3371     ASSERT_NOT_REACHED();
3372     return Exception { TypeError };
3373 }
3374 
3375 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(ExecState&amp; exec, JSValue value, SerializationErrorMode throwExceptions)
3376 {
3377     Vector&lt;uint8_t&gt; buffer;
3378     Vector&lt;String&gt; blobURLs;
<a name="40" id="anc40"></a><span class="line-removed">3379     PAL::SessionID sessionID;</span>
3380     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
3381     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; dummyImageBitmaps;
3382     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
3383 #if ENABLE(WEBASSEMBLY)
3384     WasmModuleArray dummyModules;
3385 #endif
3386     ArrayBufferContentsArray dummySharedBuffers;
3387     auto code = CloneSerializer::serialize(&amp;exec, value, dummyMessagePorts, dummyArrayBuffers, dummyImageBitmaps,
3388 #if ENABLE(WEBASSEMBLY)
3389         dummyModules,
3390 #endif
<a name="41" id="anc41"></a><span class="line-modified">3391         blobURLs, sessionID, buffer, SerializationContext::Default, dummySharedBuffers);</span>
3392 
3393 #if ENABLE(WEBASSEMBLY)
3394     ASSERT_WITH_MESSAGE(dummyModules.isEmpty(), &quot;Wasm::Module serialization is only allowed in the postMessage context&quot;);
3395 #endif
3396 
3397     if (throwExceptions == SerializationErrorMode::Throwing)
3398         maybeThrowExceptionIfSerializationFailed(exec, code);
3399 
3400     if (code != SerializationReturnCode::SuccessfullyCompleted)
3401         return nullptr;
3402 
<a name="42" id="anc42"></a><span class="line-modified">3403     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, sessionID, nullptr, nullptr, { }</span>
3404 #if ENABLE(WEBASSEMBLY)
3405         , nullptr
3406 #endif
3407             ));
3408 }
3409 
3410 static bool containsDuplicates(const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps)
3411 {
3412     HashSet&lt;ImageBitmap*&gt; visited;
3413     for (auto&amp; imageBitmap : imageBitmaps) {
3414         if (!visited.add(imageBitmap.get()))
3415             return true;
3416     }
3417     return false;
3418 }
3419 
3420 ExceptionOr&lt;Ref&lt;SerializedScriptValue&gt;&gt; SerializedScriptValue::create(ExecState&amp; state, JSValue value, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transferList, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationContext context)
3421 {
3422     VM&amp; vm = state.vm();
3423     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; arrayBuffers;
3424     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; imageBitmaps;
3425     for (auto&amp; transferable : transferList) {
3426         if (auto arrayBuffer = toPossiblySharedArrayBuffer(vm, transferable.get())) {
3427             if (arrayBuffer-&gt;isNeutered())
3428                 return Exception { DataCloneError };
3429             if (arrayBuffer-&gt;isLocked()) {
3430                 auto scope = DECLARE_THROW_SCOPE(vm);
3431                 throwVMTypeError(&amp;state, scope, errorMesasgeForTransfer(arrayBuffer));
3432                 return Exception { ExistingExceptionError };
3433             }
3434             arrayBuffers.append(WTFMove(arrayBuffer));
3435             continue;
3436         }
3437         if (auto port = JSMessagePort::toWrapped(vm, transferable.get())) {
3438             // FIXME: This should check if the port is detached as per https://html.spec.whatwg.org/multipage/infrastructure.html#istransferable.
3439             messagePorts.append(WTFMove(port));
3440             continue;
3441         }
3442 
3443         if (auto imageBitmap = JSImageBitmap::toWrapped(vm, transferable.get())) {
3444             if (imageBitmap-&gt;isDetached())
3445                 return Exception { DataCloneError };
3446 
3447             imageBitmaps.append(WTFMove(imageBitmap));
3448             continue;
3449         }
3450 
3451         return Exception { DataCloneError };
3452     }
3453 
3454     if (containsDuplicates(imageBitmaps))
3455         return Exception { DataCloneError };
3456 
3457     Vector&lt;uint8_t&gt; buffer;
3458     Vector&lt;String&gt; blobURLs;
<a name="43" id="anc43"></a><span class="line-removed">3459     PAL::SessionID sessionID;</span>
3460 #if ENABLE(WEBASSEMBLY)
3461     WasmModuleArray wasmModules;
3462 #endif
<a name="44" id="anc44"></a><span class="line-modified">3463     std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBuffers = std::make_unique&lt;ArrayBufferContentsArray&gt;();</span>
3464     auto code = CloneSerializer::serialize(&amp;state, value, messagePorts, arrayBuffers, imageBitmaps,
3465 #if ENABLE(WEBASSEMBLY)
3466         wasmModules,
3467 #endif
<a name="45" id="anc45"></a><span class="line-modified">3468         blobURLs, sessionID, buffer, context, *sharedBuffers);</span>
3469 
3470     if (code != SerializationReturnCode::SuccessfullyCompleted)
3471         return exceptionForSerializationFailure(code);
3472 
3473     auto arrayBufferContentsArray = transferArrayBuffers(vm, arrayBuffers);
3474     if (arrayBufferContentsArray.hasException())
3475         return arrayBufferContentsArray.releaseException();
3476 
3477     auto imageBuffers = ImageBitmap::detachBitmaps(WTFMove(imageBitmaps));
3478 
<a name="46" id="anc46"></a><span class="line-modified">3479     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, sessionID, arrayBufferContentsArray.releaseReturnValue(), context == SerializationContext::WorkerPostMessage ? WTFMove(sharedBuffers) : nullptr, WTFMove(imageBuffers)</span>
3480 #if ENABLE(WEBASSEMBLY)
<a name="47" id="anc47"></a><span class="line-modified">3481                 , std::make_unique&lt;WasmModuleArray&gt;(wasmModules)</span>
3482 #endif
3483                 ));
3484 }
3485 
3486 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(StringView string)
3487 {
3488     Vector&lt;uint8_t&gt; buffer;
3489     if (!CloneSerializer::serialize(string, buffer))
3490         return nullptr;
3491     return adoptRef(*new SerializedScriptValue(WTFMove(buffer)));
3492 }
3493 
3494 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(JSContextRef originContext, JSValueRef apiValue, JSValueRef* exception)
3495 {
3496     ExecState* exec = toJS(originContext);
3497     VM&amp; vm = exec-&gt;vm();
3498     JSLockHolder locker(vm);
3499     auto scope = DECLARE_CATCH_SCOPE(vm);
3500 
3501     JSValue value = toJS(exec, apiValue);
3502     auto serializedValue = SerializedScriptValue::create(*exec, value);
3503     if (UNLIKELY(scope.exception())) {
3504         if (exception)
3505             *exception = toRef(exec, scope.exception()-&gt;value());
3506         scope.clearException();
3507         return nullptr;
3508     }
3509     ASSERT(serializedValue);
3510     return serializedValue;
3511 }
3512 
3513 String SerializedScriptValue::toString()
3514 {
3515     return CloneDeserializer::deserializeString(m_data);
3516 }
3517 
3518 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, SerializationErrorMode throwExceptions)
3519 {
3520     return deserialize(exec, globalObject, { }, throwExceptions);
3521 }
3522 
3523 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationErrorMode throwExceptions)
3524 {
3525     Vector&lt;String&gt; dummyBlobs;
3526     Vector&lt;String&gt; dummyPaths;
<a name="48" id="anc48"></a><span class="line-modified">3527     PAL::SessionID dummySessionID;</span>
<span class="line-removed">3528     return deserialize(exec, globalObject, messagePorts, dummyBlobs, dummySessionID, dummyPaths, throwExceptions);</span>
3529 }
3530 
<a name="49" id="anc49"></a><span class="line-modified">3531 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, const Vector&lt;String&gt;&amp; blobURLs, const PAL::SessionID&amp; sessionID, const Vector&lt;String&gt;&amp; blobFilePaths, SerializationErrorMode throwExceptions)</span>
3532 {
<a name="50" id="anc50"></a><span class="line-modified">3533     DeserializationResult result = CloneDeserializer::deserialize(&amp;exec, globalObject, messagePorts, WTFMove(m_imageBuffers), m_arrayBufferContentsArray.get(), m_data, blobURLs, sessionID, blobFilePaths, m_sharedBufferContentsArray.get()</span>
3534 #if ENABLE(WEBASSEMBLY)
3535         , m_wasmModulesArray.get()
3536 #endif
3537         );
3538     if (throwExceptions == SerializationErrorMode::Throwing)
3539         maybeThrowExceptionIfSerializationFailed(exec, result.second);
3540     return result.first ? result.first : jsNull();
3541 }
3542 
3543 JSValueRef SerializedScriptValue::deserialize(JSContextRef destinationContext, JSValueRef* exception)
3544 {
3545     ExecState* exec = toJS(destinationContext);
3546     VM&amp; vm = exec-&gt;vm();
3547     JSLockHolder locker(vm);
3548     auto scope = DECLARE_CATCH_SCOPE(vm);
3549 
3550     JSValue value = deserialize(*exec, exec-&gt;lexicalGlobalObject());
3551     if (UNLIKELY(scope.exception())) {
3552         if (exception)
3553             *exception = toRef(exec, scope.exception()-&gt;value());
3554         scope.clearException();
3555         return nullptr;
3556     }
3557     ASSERT(value);
3558     return toRef(exec, value);
3559 }
3560 
3561 Ref&lt;SerializedScriptValue&gt; SerializedScriptValue::nullValue()
3562 {
3563     return adoptRef(*new SerializedScriptValue(Vector&lt;uint8_t&gt;()));
3564 }
3565 
3566 uint32_t SerializedScriptValue::wireFormatVersion()
3567 {
3568     return CurrentVersion;
3569 }
3570 
3571 #if ENABLE(INDEXED_DATABASE)
3572 Vector&lt;String&gt; SerializedScriptValue::blobURLsIsolatedCopy() const
3573 {
3574     Vector&lt;String&gt; result;
3575     result.reserveInitialCapacity(m_blobURLs.size());
3576     for (auto&amp; url : m_blobURLs)
3577         result.uncheckedAppend(url.isolatedCopy());
3578 
3579     return result;
3580 }
3581 
<a name="51" id="anc51"></a><span class="line-modified">3582 void SerializedScriptValue::writeBlobsToDiskForIndexedDB(CompletionHandler&lt;void(IDBValue&amp;&amp;)&gt;&amp;&amp; completionHandler)</span>
3583 {
3584     ASSERT(isMainThread());
3585     ASSERT(hasBlobURLs());
3586 
<a name="52" id="anc52"></a><span class="line-modified">3587     // FIXME: Add m_sessionID as a parameter here.</span>
<span class="line-removed">3588     blobRegistry().writeBlobsToTemporaryFiles(m_blobURLs, [completionHandler = WTFMove(completionHandler), this, protectedThis = makeRef(*this)] (auto&amp;&amp; blobFilePaths) mutable {</span>
3589         ASSERT(isMainThread());
3590 
3591         if (blobFilePaths.isEmpty()) {
3592             // We should have successfully written blobs to temporary files.
3593             // If we failed, then we can&#39;t successfully store this record.
3594             completionHandler({ });
3595             return;
3596         }
3597 
3598         ASSERT(m_blobURLs.size() == blobFilePaths.size());
3599 
<a name="53" id="anc53"></a><span class="line-modified">3600         completionHandler({ *this, m_blobURLs, m_sessionID, blobFilePaths });</span>
3601     });
3602 }
3603 
<a name="54" id="anc54"></a><span class="line-modified">3604 IDBValue SerializedScriptValue::writeBlobsToDiskForIndexedDBSynchronously()</span>
3605 {
3606     ASSERT(!isMainThread());
3607 
3608     IDBValue value;
3609     Lock lock;
3610     Condition condition;
3611     lock.lock();
3612 
<a name="55" id="anc55"></a><span class="line-modified">3613     RunLoop::main().dispatch([this, conditionPtr = &amp;condition, valuePtr = &amp;value] {</span>
<span class="line-modified">3614         writeBlobsToDiskForIndexedDB([conditionPtr, valuePtr](IDBValue&amp;&amp; result) {</span>
3615             ASSERT(isMainThread());
3616             valuePtr-&gt;setAsIsolatedCopy(result);
3617 
3618             conditionPtr-&gt;notifyAll();
3619         });
3620     });
3621 
3622     condition.wait(lock);
3623 
3624     return value;
3625 }
3626 
3627 #endif // ENABLE(INDEXED_DATABASE)
3628 
3629 } // namespace WebCore
<a name="56" id="anc56"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="56" type="hidden" />
</body>
</html>