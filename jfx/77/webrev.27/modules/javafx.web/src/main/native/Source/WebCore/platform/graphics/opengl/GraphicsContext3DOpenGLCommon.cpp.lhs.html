<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/opengl/GraphicsContext3DOpenGLCommon.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2010, 2014 Apple Inc. All rights reserved.
   3  * Copyright (C) 2011 Google Inc. All rights reserved.
   4  * Copyright (C) 2012 ChangSeok Oh &lt;shivamidow@gmail.com&gt;
   5  * Copyright (C) 2012 Research In Motion Limited. All rights reserved.
   6  *
   7  * Redistribution and use in source and binary forms, with or without
   8  * modification, are permitted provided that the following conditions
   9  * are met:
  10  * 1. Redistributions of source code must retain the above copyright
  11  *    notice, this list of conditions and the following disclaimer.
  12  * 2. Redistributions in binary form must reproduce the above copyright
  13  *    notice, this list of conditions and the following disclaimer in the
  14  *    documentation and/or other materials provided with the distribution.
  15  *
  16  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  19  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  20  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  21  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  24  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
<a name="1" id="anc1"></a><span class="line-modified">  31 #if ENABLE(GRAPHICS_CONTEXT_3D)</span>
  32 
  33 #include &quot;GraphicsContext3D.h&quot;
  34 #if PLATFORM(IOS_FAMILY)
  35 #include &quot;GraphicsContext3DIOS.h&quot;
  36 #endif
  37 
  38 #if !PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
  39 #include &quot;Extensions3DOpenGLES.h&quot;
  40 #else
  41 #include &quot;Extensions3DOpenGL.h&quot;
  42 #endif
  43 #include &quot;ANGLEWebKitBridge.h&quot;
  44 #include &quot;GraphicsContext.h&quot;
  45 #include &quot;ImageBuffer.h&quot;
  46 #include &quot;ImageData.h&quot;
  47 #include &quot;IntRect.h&quot;
  48 #include &quot;IntSize.h&quot;
  49 #include &quot;Logging.h&quot;
  50 #include &quot;TemporaryOpenGLSetting.h&quot;
  51 #include &quot;WebGLRenderingContextBase.h&quot;
  52 #include &lt;JavaScriptCore/RegularExpression.h&gt;
  53 #include &lt;cstring&gt;
  54 #include &lt;wtf/HexNumber.h&gt;
  55 #include &lt;wtf/MainThread.h&gt;
  56 #include &lt;wtf/ThreadSpecific.h&gt;
  57 #include &lt;wtf/UniqueArray.h&gt;
<a name="2" id="anc2"></a>
  58 #include &lt;wtf/text/CString.h&gt;
  59 #include &lt;wtf/text/StringBuilder.h&gt;
  60 
  61 #if PLATFORM(COCOA)
  62 
  63 #if USE(OPENGL_ES)
  64 #import &lt;OpenGLES/ES2/glext.h&gt;
  65 #import &lt;OpenGLES/ES3/gl.h&gt;
  66 // From &lt;OpenGLES/glext.h&gt;
  67 #define GL_RGBA32F_ARB                      0x8814
  68 #define GL_RGB32F_ARB                       0x8815
  69 #else
  70 #define GL_DO_NOT_WARN_IF_MULTI_GL_VERSION_HEADERS_INCLUDED
  71 #include &lt;OpenGL/gl.h&gt;
  72 #include &lt;OpenGL/gl3.h&gt;
  73 #include &lt;OpenGL/gl3ext.h&gt;
  74 #undef GL_DO_NOT_WARN_IF_MULTI_GL_VERSION_HEADERS_INCLUDED
  75 #endif
  76 
  77 #else
  78 
  79 #if USE(LIBEPOXY)
  80 #include &quot;EpoxyShims.h&quot;
  81 #elif USE(OPENGL_ES)
  82 #include &quot;OpenGLESShims.h&quot;
  83 #elif PLATFORM(GTK) || PLATFORM(WIN)
  84 #include &quot;OpenGLShims.h&quot;
  85 #endif
  86 
  87 #endif
  88 
  89 
  90 namespace WebCore {
  91 
  92 static ThreadSpecific&lt;ShaderNameHash*&gt;&amp; getCurrentNameHashMapForShader()
  93 {
  94     static std::once_flag onceFlag;
  95     static ThreadSpecific&lt;ShaderNameHash*&gt;* sharedNameHash;
  96     std::call_once(onceFlag, [] {
  97         sharedNameHash = new ThreadSpecific&lt;ShaderNameHash*&gt;;
  98     });
  99 
 100     return *sharedNameHash;
 101 }
 102 
 103 static void setCurrentNameHashMapForShader(ShaderNameHash* shaderNameHash)
 104 {
 105     *getCurrentNameHashMapForShader() = shaderNameHash;
 106 }
 107 
 108 // Hash function used by the ANGLE translator/compiler to do
 109 // symbol name mangling. Since this is a static method, before
 110 // calling compileShader we set currentNameHashMapForShader
 111 // to point to the map kept by the current instance of GraphicsContext3D.
 112 
 113 static uint64_t nameHashForShader(const char* name, size_t length)
 114 {
 115     if (!length)
 116         return 0;
 117 
 118     CString nameAsCString = CString(name);
 119 
 120     // Look up name in our local map.
 121     ShaderNameHash*&amp; currentNameHashMapForShader = *getCurrentNameHashMapForShader();
 122     ShaderNameHash::iterator findResult = currentNameHashMapForShader-&gt;find(nameAsCString);
 123     if (findResult != currentNameHashMapForShader-&gt;end())
 124         return findResult-&gt;value;
 125 
 126     unsigned hashValue = nameAsCString.hash();
 127 
 128     // Convert the 32-bit hash from CString::hash into a 64-bit result
 129     // by shifting then adding the size of our table. Overflow would
 130     // only be a problem if we&#39;re already hashing to the same value (and
 131     // we&#39;re hoping that over the lifetime of the context we
 132     // don&#39;t have that many symbols).
 133 
 134     uint64_t result = hashValue;
 135     result = (result &lt;&lt; 32) + (currentNameHashMapForShader-&gt;size() + 1);
 136 
 137     currentNameHashMapForShader-&gt;set(nameAsCString, result);
 138     return result;
 139 }
 140 
 141 void GraphicsContext3D::validateDepthStencil(const char* packedDepthStencilExtension)
 142 {
 143     Extensions3D&amp; extensions = getExtensions();
 144     if (m_attrs.stencil) {
 145         if (extensions.supports(packedDepthStencilExtension)) {
 146             extensions.ensureEnabled(packedDepthStencilExtension);
 147             // Force depth if stencil is true.
 148             m_attrs.depth = true;
 149         } else
 150             m_attrs.stencil = false;
 151     }
 152     if (m_attrs.antialias) {
 153         if (!extensions.supports(&quot;GL_ANGLE_framebuffer_multisample&quot;) || isGLES2Compliant())
 154             m_attrs.antialias = false;
 155         else
 156             extensions.ensureEnabled(&quot;GL_ANGLE_framebuffer_multisample&quot;);
 157     }
 158 }
 159 
 160 void GraphicsContext3D::paintRenderingResultsToCanvas(ImageBuffer* imageBuffer)
 161 {
 162     Checked&lt;int, RecordOverflow&gt; rowBytes = Checked&lt;int, RecordOverflow&gt;(m_currentWidth) * 4;
 163     if (rowBytes.hasOverflowed())
 164         return;
 165 
 166     Checked&lt;int, RecordOverflow&gt; totalBytesChecked = rowBytes * m_currentHeight;
 167     if (totalBytesChecked.hasOverflowed())
 168         return;
 169     int totalBytes = totalBytesChecked.unsafeGet();
 170 
 171     auto pixels = makeUniqueArray&lt;unsigned char&gt;(totalBytes);
 172     if (!pixels)
 173         return;
 174 
 175     readRenderingResults(pixels.get(), totalBytes);
 176 
 177     if (!m_attrs.premultipliedAlpha) {
 178         for (int i = 0; i &lt; totalBytes; i += 4) {
 179             // Premultiply alpha.
 180             pixels[i + 0] = std::min(255, pixels[i + 0] * pixels[i + 3] / 255);
 181             pixels[i + 1] = std::min(255, pixels[i + 1] * pixels[i + 3] / 255);
 182             pixels[i + 2] = std::min(255, pixels[i + 2] * pixels[i + 3] / 255);
 183         }
 184     }
 185 
 186     paintToCanvas(pixels.get(), IntSize(m_currentWidth, m_currentHeight), imageBuffer-&gt;internalSize(), imageBuffer-&gt;context());
 187 
 188 #if PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
 189     presentRenderbuffer();
 190 #endif
 191 }
 192 
 193 bool GraphicsContext3D::paintCompositedResultsToCanvas(ImageBuffer*)
 194 {
 195     // Not needed at the moment, so return that nothing was done.
 196     return false;
 197 }
 198 
 199 RefPtr&lt;ImageData&gt; GraphicsContext3D::paintRenderingResultsToImageData()
 200 {
 201     // Reading premultiplied alpha would involve unpremultiplying, which is
 202     // lossy.
 203     if (m_attrs.premultipliedAlpha)
 204         return nullptr;
 205 
 206     auto imageData = ImageData::create(IntSize(m_currentWidth, m_currentHeight));
 207     unsigned char* pixels = imageData-&gt;data()-&gt;data();
 208     Checked&lt;int, RecordOverflow&gt; totalBytesChecked = 4 * Checked&lt;int, RecordOverflow&gt;(m_currentWidth) * Checked&lt;int, RecordOverflow&gt;(m_currentHeight);
 209     if (totalBytesChecked.hasOverflowed())
 210         return imageData;
 211     int totalBytes = totalBytesChecked.unsafeGet();
 212 
 213     readRenderingResults(pixels, totalBytes);
 214 
 215     // Convert to RGBA.
 216     for (int i = 0; i &lt; totalBytes; i += 4)
 217         std::swap(pixels[i], pixels[i + 2]);
 218 
 219     return imageData;
 220 }
 221 
 222 void GraphicsContext3D::prepareTexture()
 223 {
 224     if (m_layerComposited)
 225         return;
 226 
 227     makeContextCurrent();
 228 
 229 #if !USE(COORDINATED_GRAPHICS)
 230     TemporaryOpenGLSetting scopedScissor(GL_SCISSOR_TEST, GL_FALSE);
 231     TemporaryOpenGLSetting scopedDither(GL_DITHER, GL_FALSE);
 232 #endif
 233 
 234     if (m_attrs.antialias)
 235         resolveMultisamplingIfNecessary();
 236 
 237 #if USE(COORDINATED_GRAPHICS)
 238     std::swap(m_texture, m_compositorTexture);
 239     std::swap(m_texture, m_intermediateTexture);
 240     ::glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);
 241     ::glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, m_texture, 0);
 242     glFlush();
 243 
 244     if (m_state.boundFBO != m_fbo)
 245         ::glBindFramebufferEXT(GraphicsContext3D::FRAMEBUFFER, m_state.boundFBO);
 246     else
 247         ::glBindFramebufferEXT(GraphicsContext3D::FRAMEBUFFER, m_fbo);
 248     return;
 249 #endif
 250 
 251     ::glActiveTexture(GL_TEXTURE0);
 252     ::glBindTexture(GL_TEXTURE_2D, m_state.boundTarget(GL_TEXTURE0) == GL_TEXTURE_2D ? m_state.boundTexture(GL_TEXTURE0) : 0);
 253     ::glActiveTexture(m_state.activeTextureUnit);
 254     if (m_state.boundFBO != m_fbo)
 255         ::glBindFramebufferEXT(GraphicsContext3D::FRAMEBUFFER, m_state.boundFBO);
 256     ::glFlush();
 257 }
 258 
 259 void GraphicsContext3D::readRenderingResults(unsigned char *pixels, int pixelsSize)
 260 {
 261     if (pixelsSize &lt; m_currentWidth * m_currentHeight * 4)
 262         return;
 263 
 264     makeContextCurrent();
 265 
 266     bool mustRestoreFBO = false;
 267     if (m_attrs.antialias) {
 268         resolveMultisamplingIfNecessary();
 269         ::glBindFramebufferEXT(GraphicsContext3D::FRAMEBUFFER, m_fbo);
 270         mustRestoreFBO = true;
 271     } else {
 272         if (m_state.boundFBO != m_fbo) {
 273             mustRestoreFBO = true;
 274             ::glBindFramebufferEXT(GraphicsContext3D::FRAMEBUFFER, m_fbo);
 275         }
 276     }
 277 
 278     GLint packAlignment = 4;
 279     bool mustRestorePackAlignment = false;
 280     ::glGetIntegerv(GL_PACK_ALIGNMENT, &amp;packAlignment);
 281     if (packAlignment &gt; 4) {
 282         ::glPixelStorei(GL_PACK_ALIGNMENT, 4);
 283         mustRestorePackAlignment = true;
 284     }
 285 
 286     readPixelsAndConvertToBGRAIfNecessary(0, 0, m_currentWidth, m_currentHeight, pixels);
 287 
 288     if (mustRestorePackAlignment)
 289         ::glPixelStorei(GL_PACK_ALIGNMENT, packAlignment);
 290 
 291     if (mustRestoreFBO)
 292         ::glBindFramebufferEXT(GraphicsContext3D::FRAMEBUFFER, m_state.boundFBO);
 293 }
 294 
 295 void GraphicsContext3D::reshape(int width, int height)
 296 {
 297     if (!platformGraphicsContext3D())
 298         return;
 299 
 300     if (width == m_currentWidth &amp;&amp; height == m_currentHeight)
 301         return;
 302 
 303     ASSERT(width &gt;= 0 &amp;&amp; height &gt;= 0);
 304     if (width &lt; 0 || height &lt; 0)
 305         return;
 306 
 307     markContextChanged();
 308 
 309     m_currentWidth = width;
 310     m_currentHeight = height;
 311 
 312     makeContextCurrent();
 313     validateAttributes();
 314 
 315     TemporaryOpenGLSetting scopedScissor(GL_SCISSOR_TEST, GL_FALSE);
 316     TemporaryOpenGLSetting scopedDither(GL_DITHER, GL_FALSE);
 317 
 318     bool mustRestoreFBO = reshapeFBOs(IntSize(width, height));
 319 
 320     // Initialize renderbuffers to 0.
 321     GLfloat clearColor[] = {0, 0, 0, 0}, clearDepth = 0;
 322     GLint clearStencil = 0;
 323     GLboolean colorMask[] = {GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE}, depthMask = GL_TRUE;
 324     GLuint stencilMask = 0xffffffff, stencilMaskBack = 0xffffffff;
 325     GLbitfield clearMask = GL_COLOR_BUFFER_BIT;
 326     ::glGetFloatv(GL_COLOR_CLEAR_VALUE, clearColor);
 327     ::glClearColor(0, 0, 0, 0);
 328     ::glGetBooleanv(GL_COLOR_WRITEMASK, colorMask);
 329     ::glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
 330     if (m_attrs.depth) {
 331         ::glGetFloatv(GL_DEPTH_CLEAR_VALUE, &amp;clearDepth);
 332         GraphicsContext3D::clearDepth(1);
 333         ::glGetBooleanv(GL_DEPTH_WRITEMASK, &amp;depthMask);
 334         ::glDepthMask(GL_TRUE);
 335         clearMask |= GL_DEPTH_BUFFER_BIT;
 336     }
 337     if (m_attrs.stencil) {
 338         ::glGetIntegerv(GL_STENCIL_CLEAR_VALUE, &amp;clearStencil);
 339         ::glClearStencil(0);
 340         ::glGetIntegerv(GL_STENCIL_WRITEMASK, reinterpret_cast&lt;GLint*&gt;(&amp;stencilMask));
 341         ::glGetIntegerv(GL_STENCIL_BACK_WRITEMASK, reinterpret_cast&lt;GLint*&gt;(&amp;stencilMaskBack));
 342         ::glStencilMaskSeparate(GL_FRONT, 0xffffffff);
 343         ::glStencilMaskSeparate(GL_BACK, 0xffffffff);
 344         clearMask |= GL_STENCIL_BUFFER_BIT;
 345     }
 346 
 347     ::glClear(clearMask);
 348 
 349     ::glClearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
 350     ::glColorMask(colorMask[0], colorMask[1], colorMask[2], colorMask[3]);
 351     if (m_attrs.depth) {
 352         GraphicsContext3D::clearDepth(clearDepth);
 353         ::glDepthMask(depthMask);
 354     }
 355     if (m_attrs.stencil) {
 356         ::glClearStencil(clearStencil);
 357         ::glStencilMaskSeparate(GL_FRONT, stencilMask);
 358         ::glStencilMaskSeparate(GL_BACK, stencilMaskBack);
 359     }
 360 
 361     if (mustRestoreFBO)
 362         ::glBindFramebufferEXT(GraphicsContext3D::FRAMEBUFFER, m_state.boundFBO);
 363 
 364     ::glFlush();
 365 }
 366 
 367 bool GraphicsContext3D::checkVaryingsPacking(Platform3DObject vertexShader, Platform3DObject fragmentShader) const
 368 {
 369     ASSERT(m_shaderSourceMap.contains(vertexShader));
 370     ASSERT(m_shaderSourceMap.contains(fragmentShader));
 371     const auto&amp; vertexEntry = m_shaderSourceMap.find(vertexShader)-&gt;value;
 372     const auto&amp; fragmentEntry = m_shaderSourceMap.find(fragmentShader)-&gt;value;
 373 
 374     HashMap&lt;String, sh::ShaderVariable&gt; combinedVaryings;
 375     for (const auto&amp; vertexSymbol : vertexEntry.varyingMap) {
 376         const String&amp; symbolName = vertexSymbol.key;
 377         // The varying map includes variables for each index of an array variable.
 378         // We only want a single variable to represent the array.
 379         if (symbolName.endsWith(&quot;]&quot;))
 380             continue;
 381 
 382         // Don&#39;t count built in varyings.
 383         if (symbolName == &quot;gl_FragCoord&quot; || symbolName == &quot;gl_FrontFacing&quot; || symbolName == &quot;gl_PointCoord&quot;)
 384             continue;
 385 
 386         const auto&amp; fragmentSymbol = fragmentEntry.varyingMap.find(symbolName);
 387         if (fragmentSymbol != fragmentEntry.varyingMap.end())
 388             combinedVaryings.add(symbolName, fragmentSymbol-&gt;value);
 389     }
 390 
 391     size_t numVaryings = combinedVaryings.size();
 392     if (!numVaryings)
 393         return true;
 394 
 395     std::vector&lt;sh::ShaderVariable&gt; variables;
 396     variables.reserve(combinedVaryings.size());
 397     for (const auto&amp; varyingSymbol : combinedVaryings.values())
 398         variables.push_back(varyingSymbol);
 399 
 400     GC3Dint maxVaryingVectors = 0;
 401 #if USE(OPENGL_ES)
 402     ::glGetIntegerv(MAX_VARYING_VECTORS, &amp;maxVaryingVectors);
 403 #else
 404     if (m_isForWebGL2)
 405         ::glGetIntegerv(GL_MAX_VARYING_VECTORS, &amp;maxVaryingVectors);
 406     else {
 407         GC3Dint maxVaryingFloats = 0;
 408         ::glGetIntegerv(GL_MAX_VARYING_FLOATS, &amp;maxVaryingFloats);
 409         maxVaryingVectors = maxVaryingFloats / 4;
 410     }
 411 #endif
 412     return sh::CheckVariablesWithinPackingLimits(maxVaryingVectors, variables);
 413 }
 414 
 415 bool GraphicsContext3D::precisionsMatch(Platform3DObject vertexShader, Platform3DObject fragmentShader) const
 416 {
 417     ASSERT(m_shaderSourceMap.contains(vertexShader));
 418     ASSERT(m_shaderSourceMap.contains(fragmentShader));
 419     const auto&amp; vertexEntry = m_shaderSourceMap.find(vertexShader)-&gt;value;
 420     const auto&amp; fragmentEntry = m_shaderSourceMap.find(fragmentShader)-&gt;value;
 421 
 422     HashMap&lt;String, sh::GLenum&gt; vertexSymbolPrecisionMap;
 423 
 424     for (const auto&amp; entry : vertexEntry.uniformMap) {
 425         const std::string&amp; mappedName = entry.value.mappedName;
 426         vertexSymbolPrecisionMap.add(String(mappedName.c_str(), mappedName.length()), entry.value.precision);
 427     }
 428 
 429     for (const auto&amp; entry : fragmentEntry.uniformMap) {
 430         const std::string&amp; mappedName = entry.value.mappedName;
 431         const auto&amp; vertexSymbol = vertexSymbolPrecisionMap.find(String(mappedName.c_str(), mappedName.length()));
 432         if (vertexSymbol != vertexSymbolPrecisionMap.end() &amp;&amp; vertexSymbol-&gt;value != entry.value.precision)
 433             return false;
 434     }
 435 
 436     return true;
 437 }
 438 
 439 IntSize GraphicsContext3D::getInternalFramebufferSize() const
 440 {
 441     return IntSize(m_currentWidth, m_currentHeight);
 442 }
 443 
 444 void GraphicsContext3D::activeTexture(GC3Denum texture)
 445 {
 446     makeContextCurrent();
 447     m_state.activeTextureUnit = texture;
 448     ::glActiveTexture(texture);
 449 }
 450 
 451 void GraphicsContext3D::attachShader(Platform3DObject program, Platform3DObject shader)
 452 {
 453     ASSERT(program);
 454     ASSERT(shader);
 455     makeContextCurrent();
 456     m_shaderProgramSymbolCountMap.remove(program);
 457     ::glAttachShader(program, shader);
 458 }
 459 
 460 void GraphicsContext3D::bindAttribLocation(Platform3DObject program, GC3Duint index, const String&amp; name)
 461 {
 462     ASSERT(program);
 463     makeContextCurrent();
 464 
 465     String mappedName = mappedSymbolName(program, SHADER_SYMBOL_TYPE_ATTRIBUTE, name);
 466     LOG(WebGL, &quot;::bindAttribLocation is mapping %s to %s&quot;, name.utf8().data(), mappedName.utf8().data());
 467     ::glBindAttribLocation(program, index, mappedName.utf8().data());
 468 }
 469 
 470 void GraphicsContext3D::bindBuffer(GC3Denum target, Platform3DObject buffer)
 471 {
 472     makeContextCurrent();
 473     ::glBindBuffer(target, buffer);
 474 }
 475 
 476 void GraphicsContext3D::bindFramebuffer(GC3Denum target, Platform3DObject buffer)
 477 {
 478     makeContextCurrent();
 479     GLuint fbo;
 480     if (buffer)
 481         fbo = buffer;
 482     else
 483         fbo = (m_attrs.antialias ? m_multisampleFBO : m_fbo);
 484     if (fbo != m_state.boundFBO) {
 485         ::glBindFramebufferEXT(target, fbo);
 486         m_state.boundFBO = fbo;
 487     }
 488 }
 489 
 490 void GraphicsContext3D::bindRenderbuffer(GC3Denum target, Platform3DObject renderbuffer)
 491 {
 492     makeContextCurrent();
 493     ::glBindRenderbufferEXT(target, renderbuffer);
 494 }
 495 
 496 
 497 void GraphicsContext3D::bindTexture(GC3Denum target, Platform3DObject texture)
 498 {
 499     makeContextCurrent();
 500     m_state.setBoundTexture(m_state.activeTextureUnit, texture, target);
 501     ::glBindTexture(target, texture);
 502 }
 503 
 504 void GraphicsContext3D::blendColor(GC3Dclampf red, GC3Dclampf green, GC3Dclampf blue, GC3Dclampf alpha)
 505 {
 506     makeContextCurrent();
 507     ::glBlendColor(red, green, blue, alpha);
 508 }
 509 
 510 void GraphicsContext3D::blendEquation(GC3Denum mode)
 511 {
 512     makeContextCurrent();
 513     ::glBlendEquation(mode);
 514 }
 515 
 516 void GraphicsContext3D::blendEquationSeparate(GC3Denum modeRGB, GC3Denum modeAlpha)
 517 {
 518     makeContextCurrent();
 519     ::glBlendEquationSeparate(modeRGB, modeAlpha);
 520 }
 521 
 522 
 523 void GraphicsContext3D::blendFunc(GC3Denum sfactor, GC3Denum dfactor)
 524 {
 525     makeContextCurrent();
 526     ::glBlendFunc(sfactor, dfactor);
 527 }
 528 
 529 void GraphicsContext3D::blendFuncSeparate(GC3Denum srcRGB, GC3Denum dstRGB, GC3Denum srcAlpha, GC3Denum dstAlpha)
 530 {
 531     makeContextCurrent();
 532     ::glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
 533 }
 534 
 535 void GraphicsContext3D::bufferData(GC3Denum target, GC3Dsizeiptr size, GC3Denum usage)
 536 {
 537     makeContextCurrent();
 538     ::glBufferData(target, size, 0, usage);
 539 }
 540 
 541 void GraphicsContext3D::bufferData(GC3Denum target, GC3Dsizeiptr size, const void* data, GC3Denum usage)
 542 {
 543     makeContextCurrent();
 544     ::glBufferData(target, size, data, usage);
 545 }
 546 
 547 void GraphicsContext3D::bufferSubData(GC3Denum target, GC3Dintptr offset, GC3Dsizeiptr size, const void* data)
 548 {
 549     makeContextCurrent();
 550     ::glBufferSubData(target, offset, size, data);
 551 }
 552 
 553 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY) || PLATFORM(WPE)
 554 void* GraphicsContext3D::mapBufferRange(GC3Denum target, GC3Dintptr offset, GC3Dsizeiptr length, GC3Dbitfield access)
 555 {
 556     makeContextCurrent();
 557     return ::glMapBufferRange(target, offset, length, access);
 558 }
 559 
 560 GC3Dboolean GraphicsContext3D::unmapBuffer(GC3Denum target)
 561 {
 562     makeContextCurrent();
 563     return ::glUnmapBuffer(target);
 564 }
 565 
 566 void GraphicsContext3D::copyBufferSubData(GC3Denum readTarget, GC3Denum writeTarget, GC3Dintptr readOffset, GC3Dintptr writeOffset, GC3Dsizeiptr size)
 567 {
 568     makeContextCurrent();
 569     ::glCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
 570 }
 571 
 572 void GraphicsContext3D::getInternalformativ(GC3Denum target, GC3Denum internalformat, GC3Denum pname, GC3Dsizei bufSize, GC3Dint* params)
 573 {
 574 #if USE(OPENGL_ES)
 575     makeContextCurrent();
 576     ::glGetInternalformativ(target, internalformat, pname, bufSize, params);
 577 #else
 578     UNUSED_PARAM(target);
 579     UNUSED_PARAM(internalformat);
 580     UNUSED_PARAM(pname);
 581     UNUSED_PARAM(bufSize);
 582     UNUSED_PARAM(params);
 583 #endif
 584 }
 585 
 586 void GraphicsContext3D::renderbufferStorageMultisample(GC3Denum target, GC3Dsizei samples, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height)
 587 {
 588     makeContextCurrent();
 589     ::glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
 590 }
 591 
 592 void GraphicsContext3D::texStorage2D(GC3Denum target, GC3Dsizei levels, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height)
 593 {
 594     makeContextCurrent();
 595     ::glTexStorage2D(target, levels, internalformat, width, height);
 596     m_state.textureSeedCount.add(m_state.currentBoundTexture());
 597 }
 598 
 599 void GraphicsContext3D::texStorage3D(GC3Denum target, GC3Dsizei levels, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth)
 600 {
 601     makeContextCurrent();
 602     ::glTexStorage3D(target, levels, internalformat, width, height, depth);
 603     m_state.textureSeedCount.add(m_state.currentBoundTexture());
 604 }
 605 
 606 void GraphicsContext3D::getActiveUniforms(Platform3DObject program, const Vector&lt;GC3Duint&gt;&amp; uniformIndices, GC3Denum pname, Vector&lt;GC3Dint&gt;&amp; params)
 607 {
 608     ASSERT(program);
 609     makeContextCurrent();
 610 
 611     ::glGetActiveUniformsiv(program, uniformIndices.size(), uniformIndices.data(), pname, params.data());
 612 }
 613 #endif
 614 
 615 GC3Denum GraphicsContext3D::checkFramebufferStatus(GC3Denum target)
 616 {
 617     makeContextCurrent();
 618     return ::glCheckFramebufferStatusEXT(target);
 619 }
 620 
 621 void GraphicsContext3D::clearColor(GC3Dclampf r, GC3Dclampf g, GC3Dclampf b, GC3Dclampf a)
 622 {
 623     makeContextCurrent();
 624     ::glClearColor(r, g, b, a);
 625 }
 626 
 627 void GraphicsContext3D::clear(GC3Dbitfield mask)
 628 {
 629     makeContextCurrent();
 630     ::glClear(mask);
 631     checkGPUStatus();
 632 }
 633 
 634 void GraphicsContext3D::clearStencil(GC3Dint s)
 635 {
 636     makeContextCurrent();
 637     ::glClearStencil(s);
 638 }
 639 
 640 void GraphicsContext3D::colorMask(GC3Dboolean red, GC3Dboolean green, GC3Dboolean blue, GC3Dboolean alpha)
 641 {
 642     makeContextCurrent();
 643     ::glColorMask(red, green, blue, alpha);
 644 }
 645 
 646 void GraphicsContext3D::compileShader(Platform3DObject shader)
 647 {
 648     ASSERT(shader);
 649     makeContextCurrent();
 650 
 651     // Turn on name mapping. Due to the way ANGLE name hashing works, we
 652     // point a global hashmap to the map owned by this context.
 653     ShBuiltInResources ANGLEResources = m_compiler.getResources();
 654     ShHashFunction64 previousHashFunction = ANGLEResources.HashFunction;
 655     ANGLEResources.HashFunction = nameHashForShader;
 656 
 657     if (!nameHashMapForShaders)
<a name="3" id="anc3"></a><span class="line-modified"> 658         nameHashMapForShaders = std::make_unique&lt;ShaderNameHash&gt;();</span>
 659     setCurrentNameHashMapForShader(nameHashMapForShaders.get());
 660     m_compiler.setResources(ANGLEResources);
 661 
 662     String translatedShaderSource = m_extensions-&gt;getTranslatedShaderSourceANGLE(shader);
 663 
 664     ANGLEResources.HashFunction = previousHashFunction;
 665     m_compiler.setResources(ANGLEResources);
 666     setCurrentNameHashMapForShader(nullptr);
 667 
 668     if (!translatedShaderSource.length())
 669         return;
 670 
 671     const CString&amp; translatedShaderCString = translatedShaderSource.utf8();
 672     const char* translatedShaderPtr = translatedShaderCString.data();
 673     int translatedShaderLength = translatedShaderCString.length();
 674 
 675     LOG(WebGL, &quot;--- begin original shader source ---\n%s\n--- end original shader source ---\n&quot;, getShaderSource(shader).utf8().data());
 676     LOG(WebGL, &quot;--- begin translated shader source ---\n%s\n--- end translated shader source ---&quot;, translatedShaderPtr);
 677 
 678     ::glShaderSource(shader, 1, &amp;translatedShaderPtr, &amp;translatedShaderLength);
 679 
 680     ::glCompileShader(shader);
 681 
 682     int compileStatus;
 683 
 684     ::glGetShaderiv(shader, COMPILE_STATUS, &amp;compileStatus);
 685 
 686     ShaderSourceMap::iterator result = m_shaderSourceMap.find(shader);
 687     GraphicsContext3D::ShaderSourceEntry&amp; entry = result-&gt;value;
 688 
 689     // Populate the shader log
 690     GLint length = 0;
 691     ::glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;length);
 692 
 693     if (length) {
 694         GLsizei size = 0;
 695         Vector&lt;GLchar&gt; info(length);
 696         ::glGetShaderInfoLog(shader, length, &amp;size, info.data());
 697 
 698         Platform3DObject shaders[2] = { shader, 0 };
 699         entry.log = getUnmangledInfoLog(shaders, 1, String(info.data(), size));
 700     }
 701 
 702     if (compileStatus != GL_TRUE) {
 703         entry.isValid = false;
 704         LOG(WebGL, &quot;Error: shader translator produced a shader that OpenGL would not compile.&quot;);
 705     }
 706 }
 707 
 708 void GraphicsContext3D::compileShaderDirect(Platform3DObject shader)
 709 {
 710     ASSERT(shader);
 711     makeContextCurrent();
 712 
 713     HashMap&lt;Platform3DObject, ShaderSourceEntry&gt;::iterator result = m_shaderSourceMap.find(shader);
 714 
 715     if (result == m_shaderSourceMap.end())
 716         return;
 717 
 718     ShaderSourceEntry&amp; entry = result-&gt;value;
 719 
 720     const CString&amp; shaderSourceCString = entry.source.utf8();
 721     const char* shaderSourcePtr = shaderSourceCString.data();
 722     int shaderSourceLength = shaderSourceCString.length();
 723 
 724     LOG(WebGL, &quot;--- begin direct shader source ---\n%s\n--- end direct shader source ---\n&quot;, shaderSourcePtr);
 725 
 726     ::glShaderSource(shader, 1, &amp;shaderSourcePtr, &amp;shaderSourceLength);
 727 
 728     ::glCompileShader(shader);
 729 
 730     int compileStatus;
 731 
 732     ::glGetShaderiv(shader, COMPILE_STATUS, &amp;compileStatus);
 733 
 734     if (compileStatus == GL_TRUE) {
 735         entry.isValid = true;
 736         LOG(WebGL, &quot;Direct compilation of shader succeeded.&quot;);
 737     } else {
 738         entry.isValid = false;
 739         LOG(WebGL, &quot;Error: direct compilation of shader failed.&quot;);
 740     }
 741 }
 742 
 743 void GraphicsContext3D::copyTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Dint border)
 744 {
 745     makeContextCurrent();
 746     if (m_attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO) {
 747         resolveMultisamplingIfNecessary(IntRect(x, y, width, height));
 748         ::glBindFramebufferEXT(GraphicsContext3D::FRAMEBUFFER, m_fbo);
 749     }
 750     ::glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
 751     if (m_attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO)
 752         ::glBindFramebufferEXT(GraphicsContext3D::FRAMEBUFFER, m_multisampleFBO);
 753 }
 754 
 755 void GraphicsContext3D::copyTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
 756 {
 757     makeContextCurrent();
 758     if (m_attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO) {
 759         resolveMultisamplingIfNecessary(IntRect(x, y, width, height));
 760         ::glBindFramebufferEXT(GraphicsContext3D::FRAMEBUFFER, m_fbo);
 761     }
 762     ::glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
 763     if (m_attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO)
 764         ::glBindFramebufferEXT(GraphicsContext3D::FRAMEBUFFER, m_multisampleFBO);
 765 }
 766 
 767 void GraphicsContext3D::cullFace(GC3Denum mode)
 768 {
 769     makeContextCurrent();
 770     ::glCullFace(mode);
 771 }
 772 
 773 void GraphicsContext3D::depthFunc(GC3Denum func)
 774 {
 775     makeContextCurrent();
 776     ::glDepthFunc(func);
 777 }
 778 
 779 void GraphicsContext3D::depthMask(GC3Dboolean flag)
 780 {
 781     makeContextCurrent();
 782     ::glDepthMask(flag);
 783 }
 784 
 785 void GraphicsContext3D::detachShader(Platform3DObject program, Platform3DObject shader)
 786 {
 787     ASSERT(program);
 788     ASSERT(shader);
 789     makeContextCurrent();
 790     m_shaderProgramSymbolCountMap.remove(program);
 791     ::glDetachShader(program, shader);
 792 }
 793 
 794 void GraphicsContext3D::disable(GC3Denum cap)
 795 {
 796     makeContextCurrent();
 797     ::glDisable(cap);
 798 }
 799 
 800 void GraphicsContext3D::disableVertexAttribArray(GC3Duint index)
 801 {
 802     makeContextCurrent();
 803     ::glDisableVertexAttribArray(index);
 804 }
 805 
 806 void GraphicsContext3D::drawArrays(GC3Denum mode, GC3Dint first, GC3Dsizei count)
 807 {
 808     makeContextCurrent();
 809     ::glDrawArrays(mode, first, count);
 810     checkGPUStatus();
 811 }
 812 
 813 void GraphicsContext3D::drawElements(GC3Denum mode, GC3Dsizei count, GC3Denum type, GC3Dintptr offset)
 814 {
 815     makeContextCurrent();
 816     ::glDrawElements(mode, count, type, reinterpret_cast&lt;GLvoid*&gt;(static_cast&lt;intptr_t&gt;(offset)));
 817     checkGPUStatus();
 818 }
 819 
 820 void GraphicsContext3D::enable(GC3Denum cap)
 821 {
 822     makeContextCurrent();
 823     ::glEnable(cap);
 824 }
 825 
 826 void GraphicsContext3D::enableVertexAttribArray(GC3Duint index)
 827 {
 828     makeContextCurrent();
 829     ::glEnableVertexAttribArray(index);
 830 }
 831 
 832 void GraphicsContext3D::finish()
 833 {
 834     makeContextCurrent();
 835     ::glFinish();
 836 }
 837 
 838 void GraphicsContext3D::flush()
 839 {
 840     makeContextCurrent();
 841     ::glFlush();
 842 }
 843 
 844 void GraphicsContext3D::framebufferRenderbuffer(GC3Denum target, GC3Denum attachment, GC3Denum renderbuffertarget, Platform3DObject buffer)
 845 {
 846     makeContextCurrent();
 847     ::glFramebufferRenderbufferEXT(target, attachment, renderbuffertarget, buffer);
 848 }
 849 
 850 void GraphicsContext3D::framebufferTexture2D(GC3Denum target, GC3Denum attachment, GC3Denum textarget, Platform3DObject texture, GC3Dint level)
 851 {
 852     makeContextCurrent();
 853     ::glFramebufferTexture2DEXT(target, attachment, textarget, texture, level);
 854     m_state.textureSeedCount.add(m_state.currentBoundTexture());
 855 }
 856 
 857 void GraphicsContext3D::frontFace(GC3Denum mode)
 858 {
 859     makeContextCurrent();
 860     ::glFrontFace(mode);
 861 }
 862 
 863 void GraphicsContext3D::generateMipmap(GC3Denum target)
 864 {
 865     makeContextCurrent();
 866     ::glGenerateMipmap(target);
 867 }
 868 
 869 bool GraphicsContext3D::getActiveAttribImpl(Platform3DObject program, GC3Duint index, ActiveInfo&amp; info)
 870 {
 871     if (!program) {
 872         synthesizeGLError(INVALID_VALUE);
 873         return false;
 874     }
 875     makeContextCurrent();
 876     GLint maxAttributeSize = 0;
 877     ::glGetProgramiv(program, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &amp;maxAttributeSize);
 878     Vector&lt;GLchar&gt; name(maxAttributeSize); // GL_ACTIVE_ATTRIBUTE_MAX_LENGTH includes null termination.
 879     GLsizei nameLength = 0;
 880     GLint size = 0;
 881     GLenum type = 0;
 882     ::glGetActiveAttrib(program, index, maxAttributeSize, &amp;nameLength, &amp;size, &amp;type, name.data());
 883     if (!nameLength)
 884         return false;
 885 
 886     String originalName = originalSymbolName(program, SHADER_SYMBOL_TYPE_ATTRIBUTE, String(name.data(), nameLength));
 887 
 888 #ifndef NDEBUG
 889     String uniformName(name.data(), nameLength);
 890     LOG(WebGL, &quot;Program %d is mapping active attribute %d from &#39;%s&#39; to &#39;%s&#39;&quot;, program, index, uniformName.utf8().data(), originalName.utf8().data());
 891 #endif
 892 
 893     info.name = originalName;
 894     info.type = type;
 895     info.size = size;
 896     return true;
 897 }
 898 
 899 bool GraphicsContext3D::getActiveAttrib(Platform3DObject program, GC3Duint index, ActiveInfo&amp; info)
 900 {
 901     GC3Dint symbolCount;
 902     auto result = m_shaderProgramSymbolCountMap.find(program);
 903     if (result == m_shaderProgramSymbolCountMap.end()) {
 904         getNonBuiltInActiveSymbolCount(program, GraphicsContext3D::ACTIVE_ATTRIBUTES, &amp;symbolCount);
 905         result = m_shaderProgramSymbolCountMap.find(program);
 906     }
 907 
 908     ActiveShaderSymbolCounts&amp; symbolCounts = result-&gt;value;
 909     GC3Duint rawIndex = (index &lt; symbolCounts.filteredToActualAttributeIndexMap.size()) ? symbolCounts.filteredToActualAttributeIndexMap[index] : -1;
 910 
 911     return getActiveAttribImpl(program, rawIndex, info);
 912 }
 913 
 914 bool GraphicsContext3D::getActiveUniformImpl(Platform3DObject program, GC3Duint index, ActiveInfo&amp; info)
 915 {
 916     if (!program) {
 917         synthesizeGLError(INVALID_VALUE);
 918         return false;
 919     }
 920 
 921     makeContextCurrent();
 922     GLint maxUniformSize = 0;
 923     ::glGetProgramiv(program, GL_ACTIVE_UNIFORM_MAX_LENGTH, &amp;maxUniformSize);
 924 
 925     Vector&lt;GLchar&gt; name(maxUniformSize); // GL_ACTIVE_UNIFORM_MAX_LENGTH includes null termination.
 926     GLsizei nameLength = 0;
 927     GLint size = 0;
 928     GLenum type = 0;
 929     ::glGetActiveUniform(program, index, maxUniformSize, &amp;nameLength, &amp;size, &amp;type, name.data());
 930     if (!nameLength)
 931         return false;
 932 
 933     String originalName = originalSymbolName(program, SHADER_SYMBOL_TYPE_UNIFORM, String(name.data(), nameLength));
 934 
 935 #ifndef NDEBUG
 936     String uniformName(name.data(), nameLength);
 937     LOG(WebGL, &quot;Program %d is mapping active uniform %d from &#39;%s&#39; to &#39;%s&#39;&quot;, program, index, uniformName.utf8().data(), originalName.utf8().data());
 938 #endif
 939 
 940     info.name = originalName;
 941     info.type = type;
 942     info.size = size;
 943     return true;
 944 }
 945 
 946 bool GraphicsContext3D::getActiveUniform(Platform3DObject program, GC3Duint index, ActiveInfo&amp; info)
 947 {
 948     GC3Dint symbolCount;
 949     auto result = m_shaderProgramSymbolCountMap.find(program);
 950     if (result == m_shaderProgramSymbolCountMap.end()) {
 951         getNonBuiltInActiveSymbolCount(program, GraphicsContext3D::ACTIVE_UNIFORMS, &amp;symbolCount);
 952         result = m_shaderProgramSymbolCountMap.find(program);
 953     }
 954 
 955     ActiveShaderSymbolCounts&amp; symbolCounts = result-&gt;value;
 956     GC3Duint rawIndex = (index &lt; symbolCounts.filteredToActualUniformIndexMap.size()) ? symbolCounts.filteredToActualUniformIndexMap[index] : -1;
 957 
 958     return getActiveUniformImpl(program, rawIndex, info);
 959 }
 960 
 961 void GraphicsContext3D::getAttachedShaders(Platform3DObject program, GC3Dsizei maxCount, GC3Dsizei* count, Platform3DObject* shaders)
 962 {
 963     if (!program) {
 964         synthesizeGLError(INVALID_VALUE);
 965         return;
 966     }
 967     makeContextCurrent();
 968     ::glGetAttachedShaders(program, maxCount, count, shaders);
 969 }
 970 
 971 static String generateHashedName(const String&amp; name)
 972 {
 973     if (name.isEmpty())
 974         return name;
 975     uint64_t number = nameHashForShader(name.utf8().data(), name.length());
 976     StringBuilder builder;
 977     builder.appendLiteral(&quot;webgl_&quot;);
 978     appendUnsignedAsHex(number, builder, Lowercase);
 979     return builder.toString();
 980 }
 981 
 982 Optional&lt;String&gt; GraphicsContext3D::mappedSymbolInShaderSourceMap(Platform3DObject shader, ANGLEShaderSymbolType symbolType, const String&amp; name)
 983 {
 984     auto result = m_shaderSourceMap.find(shader);
 985     if (result == m_shaderSourceMap.end())
 986         return WTF::nullopt;
 987 
 988     const auto&amp; symbolMap = result-&gt;value.symbolMap(symbolType);
 989     auto symbolEntry = symbolMap.find(name);
 990     if (symbolEntry == symbolMap.end())
 991         return WTF::nullopt;
 992 
 993     auto&amp; mappedName = symbolEntry-&gt;value.mappedName;
 994     return String(mappedName.c_str(), mappedName.length());
 995 }
 996 
 997 String GraphicsContext3D::mappedSymbolName(Platform3DObject program, ANGLEShaderSymbolType symbolType, const String&amp; name)
 998 {
 999     GC3Dsizei count = 0;
1000     Platform3DObject shaders[2] = { };
1001     getAttachedShaders(program, 2, &amp;count, shaders);
1002 
1003     for (GC3Dsizei i = 0; i &lt; count; ++i) {
1004         auto mappedName = mappedSymbolInShaderSourceMap(shaders[i], symbolType, name);
1005         if (mappedName)
1006             return mappedName.value();
1007     }
1008 
1009     // We might have detached or deleted the shaders after linking.
1010     auto result = m_linkedShaderMap.find(program);
1011     if (result != m_linkedShaderMap.end()) {
1012         auto linkedShaders = result-&gt;value;
1013         auto mappedName = mappedSymbolInShaderSourceMap(linkedShaders.first, symbolType, name);
1014         if (mappedName)
1015             return mappedName.value();
1016         mappedName = mappedSymbolInShaderSourceMap(linkedShaders.second, symbolType, name);
1017         if (mappedName)
1018             return mappedName.value();
1019     }
1020 
1021     if (symbolType == SHADER_SYMBOL_TYPE_ATTRIBUTE &amp;&amp; !name.isEmpty()) {
1022         // Attributes are a special case: they may be requested before any shaders have been compiled,
1023         // and aren&#39;t even required to be used in any shader program.
1024         if (!nameHashMapForShaders)
<a name="4" id="anc4"></a><span class="line-modified">1025             nameHashMapForShaders = std::make_unique&lt;ShaderNameHash&gt;();</span>
1026         setCurrentNameHashMapForShader(nameHashMapForShaders.get());
1027 
1028         auto generatedName = generateHashedName(name);
1029 
1030         setCurrentNameHashMapForShader(nullptr);
1031 
1032         m_possiblyUnusedAttributeMap.set(generatedName, name);
1033 
1034         return generatedName;
1035     }
1036 
1037     return name;
1038 }
1039 
1040 Optional&lt;String&gt; GraphicsContext3D::originalSymbolInShaderSourceMap(Platform3DObject shader, ANGLEShaderSymbolType symbolType, const String&amp; name)
1041 {
1042     auto result = m_shaderSourceMap.find(shader);
1043     if (result == m_shaderSourceMap.end())
1044         return WTF::nullopt;
1045 
1046     const auto&amp; symbolMap = result-&gt;value.symbolMap(symbolType);
1047     for (const auto&amp; symbolEntry : symbolMap) {
1048         if (name == symbolEntry.value.mappedName.c_str())
1049             return symbolEntry.key;
1050     }
1051     return WTF::nullopt;
1052 }
1053 
1054 String GraphicsContext3D::originalSymbolName(Platform3DObject program, ANGLEShaderSymbolType symbolType, const String&amp; name)
1055 {
1056     GC3Dsizei count;
1057     Platform3DObject shaders[2];
1058     getAttachedShaders(program, 2, &amp;count, shaders);
1059 
1060     for (GC3Dsizei i = 0; i &lt; count; ++i) {
1061         auto originalName = originalSymbolInShaderSourceMap(shaders[i], symbolType, name);
1062         if (originalName)
1063             return originalName.value();
1064     }
1065 
1066     // We might have detached or deleted the shaders after linking.
1067     auto result = m_linkedShaderMap.find(program);
1068     if (result != m_linkedShaderMap.end()) {
1069         auto linkedShaders = result-&gt;value;
1070         auto originalName = originalSymbolInShaderSourceMap(linkedShaders.first, symbolType, name);
1071         if (originalName)
1072             return originalName.value();
1073         originalName = originalSymbolInShaderSourceMap(linkedShaders.second, symbolType, name);
1074         if (originalName)
1075             return originalName.value();
1076     }
1077 
1078     if (symbolType == SHADER_SYMBOL_TYPE_ATTRIBUTE &amp;&amp; !name.isEmpty()) {
1079         // Attributes are a special case: they may be requested before any shaders have been compiled,
1080         // and aren&#39;t even required to be used in any shader program.
1081 
1082         const auto&amp; cached = m_possiblyUnusedAttributeMap.find(name);
1083         if (cached != m_possiblyUnusedAttributeMap.end())
1084             return cached-&gt;value;
1085     }
1086 
1087     return name;
1088 }
1089 
1090 String GraphicsContext3D::mappedSymbolName(Platform3DObject shaders[2], size_t count, const String&amp; name)
1091 {
1092     for (size_t symbolType = 0; symbolType &lt;= static_cast&lt;size_t&gt;(SHADER_SYMBOL_TYPE_VARYING); ++symbolType) {
1093         for (size_t i = 0; i &lt; count; ++i) {
1094             ShaderSourceMap::iterator result = m_shaderSourceMap.find(shaders[i]);
1095             if (result == m_shaderSourceMap.end())
1096                 continue;
1097 
1098             const ShaderSymbolMap&amp; symbolMap = result-&gt;value.symbolMap(static_cast&lt;enum ANGLEShaderSymbolType&gt;(symbolType));
1099             for (const auto&amp; symbolEntry : symbolMap) {
1100                 if (name == symbolEntry.value.mappedName.c_str())
1101                     return symbolEntry.key;
1102             }
1103         }
1104     }
1105     return name;
1106 }
1107 
1108 int GraphicsContext3D::getAttribLocation(Platform3DObject program, const String&amp; name)
1109 {
1110     if (!program)
1111         return -1;
1112 
1113     makeContextCurrent();
1114 
1115     String mappedName = mappedSymbolName(program, SHADER_SYMBOL_TYPE_ATTRIBUTE, name);
1116     LOG(WebGL, &quot;::glGetAttribLocation is mapping %s to %s&quot;, name.utf8().data(), mappedName.utf8().data());
1117     return ::glGetAttribLocation(program, mappedName.utf8().data());
1118 }
1119 
1120 int GraphicsContext3D::getAttribLocationDirect(Platform3DObject program, const String&amp; name)
1121 {
1122     if (!program)
1123         return -1;
1124 
1125     makeContextCurrent();
1126 
1127     return ::glGetAttribLocation(program, name.utf8().data());
1128 }
1129 
1130 GraphicsContext3DAttributes GraphicsContext3D::getContextAttributes()
1131 {
1132     return m_attrs;
1133 }
1134 
1135 bool GraphicsContext3D::moveErrorsToSyntheticErrorList()
1136 {
1137     makeContextCurrent();
1138     bool movedAnError = false;
1139 
1140     // Set an arbitrary limit of 100 here to avoid creating a hang if
1141     // a problem driver has a bug that causes it to never clear the error.
1142     // Otherwise, we would just loop until we got NO_ERROR.
1143     for (unsigned i = 0; i &lt; 100; ++i) {
1144         GC3Denum error = glGetError();
1145         if (error == NO_ERROR)
1146             break;
1147         m_syntheticErrors.add(error);
1148         movedAnError = true;
1149     }
1150 
1151     return movedAnError;
1152 }
1153 
1154 GC3Denum GraphicsContext3D::getError()
1155 {
1156     if (!m_syntheticErrors.isEmpty()) {
1157         // Need to move the current errors to the synthetic error list in case
1158         // that error is already there, since the expected behavior of both
1159         // glGetError and getError is to only report each error code once.
1160         moveErrorsToSyntheticErrorList();
1161         return m_syntheticErrors.takeFirst();
1162     }
1163 
1164     makeContextCurrent();
1165     return ::glGetError();
1166 }
1167 
1168 String GraphicsContext3D::getString(GC3Denum name)
1169 {
1170     makeContextCurrent();
1171     return String(reinterpret_cast&lt;const char*&gt;(::glGetString(name)));
1172 }
1173 
1174 void GraphicsContext3D::hint(GC3Denum target, GC3Denum mode)
1175 {
1176     makeContextCurrent();
1177     ::glHint(target, mode);
1178 }
1179 
1180 GC3Dboolean GraphicsContext3D::isBuffer(Platform3DObject buffer)
1181 {
1182     if (!buffer)
1183         return GL_FALSE;
1184 
1185     makeContextCurrent();
1186     return ::glIsBuffer(buffer);
1187 }
1188 
1189 GC3Dboolean GraphicsContext3D::isEnabled(GC3Denum cap)
1190 {
1191     makeContextCurrent();
1192     return ::glIsEnabled(cap);
1193 }
1194 
1195 GC3Dboolean GraphicsContext3D::isFramebuffer(Platform3DObject framebuffer)
1196 {
1197     if (!framebuffer)
1198         return GL_FALSE;
1199 
1200     makeContextCurrent();
1201     return ::glIsFramebufferEXT(framebuffer);
1202 }
1203 
1204 GC3Dboolean GraphicsContext3D::isProgram(Platform3DObject program)
1205 {
1206     if (!program)
1207         return GL_FALSE;
1208 
1209     makeContextCurrent();
1210     return ::glIsProgram(program);
1211 }
1212 
1213 GC3Dboolean GraphicsContext3D::isRenderbuffer(Platform3DObject renderbuffer)
1214 {
1215     if (!renderbuffer)
1216         return GL_FALSE;
1217 
1218     makeContextCurrent();
1219     return ::glIsRenderbufferEXT(renderbuffer);
1220 }
1221 
1222 GC3Dboolean GraphicsContext3D::isShader(Platform3DObject shader)
1223 {
1224     if (!shader)
1225         return GL_FALSE;
1226 
1227     makeContextCurrent();
1228     return ::glIsShader(shader);
1229 }
1230 
1231 GC3Dboolean GraphicsContext3D::isTexture(Platform3DObject texture)
1232 {
1233     if (!texture)
1234         return GL_FALSE;
1235 
1236     makeContextCurrent();
1237     return ::glIsTexture(texture);
1238 }
1239 
1240 void GraphicsContext3D::lineWidth(GC3Dfloat width)
1241 {
1242     makeContextCurrent();
1243     ::glLineWidth(width);
1244 }
1245 
1246 void GraphicsContext3D::linkProgram(Platform3DObject program)
1247 {
1248     ASSERT(program);
1249     makeContextCurrent();
1250 
1251     GC3Dsizei count = 0;
1252     Platform3DObject shaders[2] = { };
1253     getAttachedShaders(program, 2, &amp;count, shaders);
1254 
1255     if (count == 2)
1256         m_linkedShaderMap.set(program, std::make_pair(shaders[0], shaders[1]));
1257 
1258     ::glLinkProgram(program);
1259 }
1260 
1261 void GraphicsContext3D::pixelStorei(GC3Denum pname, GC3Dint param)
1262 {
1263     makeContextCurrent();
1264     ::glPixelStorei(pname, param);
1265 }
1266 
1267 void GraphicsContext3D::polygonOffset(GC3Dfloat factor, GC3Dfloat units)
1268 {
1269     makeContextCurrent();
1270     ::glPolygonOffset(factor, units);
1271 }
1272 
1273 void GraphicsContext3D::sampleCoverage(GC3Dclampf value, GC3Dboolean invert)
1274 {
1275     makeContextCurrent();
1276     ::glSampleCoverage(value, invert);
1277 }
1278 
1279 void GraphicsContext3D::scissor(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
1280 {
1281     makeContextCurrent();
1282     ::glScissor(x, y, width, height);
1283 }
1284 
1285 void GraphicsContext3D::shaderSource(Platform3DObject shader, const String&amp; string)
1286 {
1287     ASSERT(shader);
1288 
1289     makeContextCurrent();
1290 
1291     ShaderSourceEntry entry;
1292 
1293     entry.source = string;
1294 
1295     m_shaderSourceMap.set(shader, entry);
1296 }
1297 
1298 void GraphicsContext3D::stencilFunc(GC3Denum func, GC3Dint ref, GC3Duint mask)
1299 {
1300     makeContextCurrent();
1301     ::glStencilFunc(func, ref, mask);
1302 }
1303 
1304 void GraphicsContext3D::stencilFuncSeparate(GC3Denum face, GC3Denum func, GC3Dint ref, GC3Duint mask)
1305 {
1306     makeContextCurrent();
1307     ::glStencilFuncSeparate(face, func, ref, mask);
1308 }
1309 
1310 void GraphicsContext3D::stencilMask(GC3Duint mask)
1311 {
1312     makeContextCurrent();
1313     ::glStencilMask(mask);
1314 }
1315 
1316 void GraphicsContext3D::stencilMaskSeparate(GC3Denum face, GC3Duint mask)
1317 {
1318     makeContextCurrent();
1319     ::glStencilMaskSeparate(face, mask);
1320 }
1321 
1322 void GraphicsContext3D::stencilOp(GC3Denum fail, GC3Denum zfail, GC3Denum zpass)
1323 {
1324     makeContextCurrent();
1325     ::glStencilOp(fail, zfail, zpass);
1326 }
1327 
1328 void GraphicsContext3D::stencilOpSeparate(GC3Denum face, GC3Denum fail, GC3Denum zfail, GC3Denum zpass)
1329 {
1330     makeContextCurrent();
1331     ::glStencilOpSeparate(face, fail, zfail, zpass);
1332 }
1333 
1334 void GraphicsContext3D::texParameterf(GC3Denum target, GC3Denum pname, GC3Dfloat value)
1335 {
1336     makeContextCurrent();
1337     ::glTexParameterf(target, pname, value);
1338 }
1339 
1340 void GraphicsContext3D::texParameteri(GC3Denum target, GC3Denum pname, GC3Dint value)
1341 {
1342     makeContextCurrent();
1343     ::glTexParameteri(target, pname, value);
1344 }
1345 
1346 void GraphicsContext3D::uniform1f(GC3Dint location, GC3Dfloat v0)
1347 {
1348     makeContextCurrent();
1349     ::glUniform1f(location, v0);
1350 }
1351 
1352 void GraphicsContext3D::uniform1fv(GC3Dint location, GC3Dsizei size, const GC3Dfloat* array)
1353 {
1354     makeContextCurrent();
1355     ::glUniform1fv(location, size, array);
1356 }
1357 
1358 void GraphicsContext3D::uniform2f(GC3Dint location, GC3Dfloat v0, GC3Dfloat v1)
1359 {
1360     makeContextCurrent();
1361     ::glUniform2f(location, v0, v1);
1362 }
1363 
1364 void GraphicsContext3D::uniform2fv(GC3Dint location, GC3Dsizei size, const GC3Dfloat* array)
1365 {
1366     // FIXME: length needs to be a multiple of 2.
1367     makeContextCurrent();
1368     ::glUniform2fv(location, size, array);
1369 }
1370 
1371 void GraphicsContext3D::uniform3f(GC3Dint location, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2)
1372 {
1373     makeContextCurrent();
1374     ::glUniform3f(location, v0, v1, v2);
1375 }
1376 
1377 void GraphicsContext3D::uniform3fv(GC3Dint location, GC3Dsizei size, const GC3Dfloat* array)
1378 {
1379     // FIXME: length needs to be a multiple of 3.
1380     makeContextCurrent();
1381     ::glUniform3fv(location, size, array);
1382 }
1383 
1384 void GraphicsContext3D::uniform4f(GC3Dint location, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2, GC3Dfloat v3)
1385 {
1386     makeContextCurrent();
1387     ::glUniform4f(location, v0, v1, v2, v3);
1388 }
1389 
1390 void GraphicsContext3D::uniform4fv(GC3Dint location, GC3Dsizei size, const GC3Dfloat* array)
1391 {
1392     // FIXME: length needs to be a multiple of 4.
1393     makeContextCurrent();
1394     ::glUniform4fv(location, size, array);
1395 }
1396 
1397 void GraphicsContext3D::uniform1i(GC3Dint location, GC3Dint v0)
1398 {
1399     makeContextCurrent();
1400     ::glUniform1i(location, v0);
1401 }
1402 
1403 void GraphicsContext3D::uniform1iv(GC3Dint location, GC3Dsizei size, const GC3Dint* array)
1404 {
1405     makeContextCurrent();
1406     ::glUniform1iv(location, size, array);
1407 }
1408 
1409 void GraphicsContext3D::uniform2i(GC3Dint location, GC3Dint v0, GC3Dint v1)
1410 {
1411     makeContextCurrent();
1412     ::glUniform2i(location, v0, v1);
1413 }
1414 
1415 void GraphicsContext3D::uniform2iv(GC3Dint location, GC3Dsizei size, const GC3Dint* array)
1416 {
1417     // FIXME: length needs to be a multiple of 2.
1418     makeContextCurrent();
1419     ::glUniform2iv(location, size, array);
1420 }
1421 
1422 void GraphicsContext3D::uniform3i(GC3Dint location, GC3Dint v0, GC3Dint v1, GC3Dint v2)
1423 {
1424     makeContextCurrent();
1425     ::glUniform3i(location, v0, v1, v2);
1426 }
1427 
1428 void GraphicsContext3D::uniform3iv(GC3Dint location, GC3Dsizei size, const GC3Dint* array)
1429 {
1430     // FIXME: length needs to be a multiple of 3.
1431     makeContextCurrent();
1432     ::glUniform3iv(location, size, array);
1433 }
1434 
1435 void GraphicsContext3D::uniform4i(GC3Dint location, GC3Dint v0, GC3Dint v1, GC3Dint v2, GC3Dint v3)
1436 {
1437     makeContextCurrent();
1438     ::glUniform4i(location, v0, v1, v2, v3);
1439 }
1440 
1441 void GraphicsContext3D::uniform4iv(GC3Dint location, GC3Dsizei size, const GC3Dint* array)
1442 {
1443     // FIXME: length needs to be a multiple of 4.
1444     makeContextCurrent();
1445     ::glUniform4iv(location, size, array);
1446 }
1447 
1448 void GraphicsContext3D::uniformMatrix2fv(GC3Dint location, GC3Dsizei size, GC3Dboolean transpose, const GC3Dfloat* array)
1449 {
1450     // FIXME: length needs to be a multiple of 4.
1451     makeContextCurrent();
1452     ::glUniformMatrix2fv(location, size, transpose, array);
1453 }
1454 
1455 void GraphicsContext3D::uniformMatrix3fv(GC3Dint location, GC3Dsizei size, GC3Dboolean transpose, const GC3Dfloat* array)
1456 {
1457     // FIXME: length needs to be a multiple of 9.
1458     makeContextCurrent();
1459     ::glUniformMatrix3fv(location, size, transpose, array);
1460 }
1461 
1462 void GraphicsContext3D::uniformMatrix4fv(GC3Dint location, GC3Dsizei size, GC3Dboolean transpose, const GC3Dfloat* array)
1463 {
1464     // FIXME: length needs to be a multiple of 16.
1465     makeContextCurrent();
1466     ::glUniformMatrix4fv(location, size, transpose, array);
1467 }
1468 
1469 void GraphicsContext3D::useProgram(Platform3DObject program)
1470 {
1471     makeContextCurrent();
1472     ::glUseProgram(program);
1473 }
1474 
1475 void GraphicsContext3D::validateProgram(Platform3DObject program)
1476 {
1477     ASSERT(program);
1478 
1479     makeContextCurrent();
1480     ::glValidateProgram(program);
1481 }
1482 
1483 void GraphicsContext3D::vertexAttrib1f(GC3Duint index, GC3Dfloat v0)
1484 {
1485     makeContextCurrent();
1486     ::glVertexAttrib1f(index, v0);
1487 }
1488 
1489 void GraphicsContext3D::vertexAttrib1fv(GC3Duint index, const GC3Dfloat* array)
1490 {
1491     makeContextCurrent();
1492     ::glVertexAttrib1fv(index, array);
1493 }
1494 
1495 void GraphicsContext3D::vertexAttrib2f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1)
1496 {
1497     makeContextCurrent();
1498     ::glVertexAttrib2f(index, v0, v1);
1499 }
1500 
1501 void GraphicsContext3D::vertexAttrib2fv(GC3Duint index, const GC3Dfloat* array)
1502 {
1503     makeContextCurrent();
1504     ::glVertexAttrib2fv(index, array);
1505 }
1506 
1507 void GraphicsContext3D::vertexAttrib3f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2)
1508 {
1509     makeContextCurrent();
1510     ::glVertexAttrib3f(index, v0, v1, v2);
1511 }
1512 
1513 void GraphicsContext3D::vertexAttrib3fv(GC3Duint index, const GC3Dfloat* array)
1514 {
1515     makeContextCurrent();
1516     ::glVertexAttrib3fv(index, array);
1517 }
1518 
1519 void GraphicsContext3D::vertexAttrib4f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2, GC3Dfloat v3)
1520 {
1521     makeContextCurrent();
1522     ::glVertexAttrib4f(index, v0, v1, v2, v3);
1523 }
1524 
1525 void GraphicsContext3D::vertexAttrib4fv(GC3Duint index, const GC3Dfloat* array)
1526 {
1527     makeContextCurrent();
1528     ::glVertexAttrib4fv(index, array);
1529 }
1530 
1531 void GraphicsContext3D::vertexAttribPointer(GC3Duint index, GC3Dint size, GC3Denum type, GC3Dboolean normalized, GC3Dsizei stride, GC3Dintptr offset)
1532 {
1533     makeContextCurrent();
1534     ::glVertexAttribPointer(index, size, type, normalized, stride, reinterpret_cast&lt;GLvoid*&gt;(static_cast&lt;intptr_t&gt;(offset)));
1535 }
1536 
1537 void GraphicsContext3D::viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
1538 {
1539     makeContextCurrent();
1540     ::glViewport(x, y, width, height);
1541 }
1542 
1543 Platform3DObject GraphicsContext3D::createVertexArray()
1544 {
1545     makeContextCurrent();
1546     GLuint array = 0;
1547 #if (!USE(OPENGL_ES) &amp;&amp; (PLATFORM(GTK) || PLATFORM(WIN))) || PLATFORM(COCOA)
1548     ::glGenVertexArrays(1, &amp;array);
1549 #endif
1550     return array;
1551 }
1552 
1553 void GraphicsContext3D::deleteVertexArray(Platform3DObject array)
1554 {
1555     if (!array)
1556         return;
1557 
1558     makeContextCurrent();
1559 #if (!USE(OPENGL_ES) &amp;&amp; (PLATFORM(GTK) || PLATFORM(WIN))) || PLATFORM(COCOA)
1560     ::glDeleteVertexArrays(1, &amp;array);
1561 #endif
1562 }
1563 
1564 GC3Dboolean GraphicsContext3D::isVertexArray(Platform3DObject array)
1565 {
1566     if (!array)
1567         return GL_FALSE;
1568 
1569     makeContextCurrent();
1570 #if (!USE(OPENGL_ES) &amp;&amp; (PLATFORM(GTK) || PLATFORM(WIN))) || PLATFORM(COCOA)
1571     return ::glIsVertexArray(array);
1572 #endif
1573     return GL_FALSE;
1574 }
1575 
1576 void GraphicsContext3D::bindVertexArray(Platform3DObject array)
1577 {
1578     makeContextCurrent();
1579 #if (!USE(OPENGL_ES) &amp;&amp; (PLATFORM(GTK) || PLATFORM(WIN))) || PLATFORM(COCOA)
1580     ::glBindVertexArray(array);
1581 #else
1582     UNUSED_PARAM(array);
1583 #endif
1584 }
1585 
1586 void GraphicsContext3D::getBooleanv(GC3Denum pname, GC3Dboolean* value)
1587 {
1588     makeContextCurrent();
1589     ::glGetBooleanv(pname, value);
1590 }
1591 
1592 void GraphicsContext3D::getBufferParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value)
1593 {
1594     makeContextCurrent();
1595     ::glGetBufferParameteriv(target, pname, value);
1596 }
1597 
1598 void GraphicsContext3D::getFloatv(GC3Denum pname, GC3Dfloat* value)
1599 {
1600     makeContextCurrent();
1601     ::glGetFloatv(pname, value);
1602 }
1603 
1604 void GraphicsContext3D::getInteger64v(GC3Denum pname, GC3Dint64* value)
1605 {
1606     UNUSED_PARAM(pname);
1607     makeContextCurrent();
1608     *value = 0;
1609     // FIXME 141178: Before enabling this we must first switch over to using gl3.h and creating and initialing the WebGL2 context using OpenGL ES 3.0.
1610     // ::glGetInteger64v(pname, value);
1611 }
1612 
1613 void GraphicsContext3D::getFramebufferAttachmentParameteriv(GC3Denum target, GC3Denum attachment, GC3Denum pname, GC3Dint* value)
1614 {
1615     makeContextCurrent();
1616     if (attachment == DEPTH_STENCIL_ATTACHMENT)
1617         attachment = DEPTH_ATTACHMENT; // Or STENCIL_ATTACHMENT, either works.
1618     ::glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, value);
1619 }
1620 
1621 void GraphicsContext3D::getProgramiv(Platform3DObject program, GC3Denum pname, GC3Dint* value)
1622 {
1623     makeContextCurrent();
1624     ::glGetProgramiv(program, pname, value);
1625 }
1626 
1627 void GraphicsContext3D::getNonBuiltInActiveSymbolCount(Platform3DObject program, GC3Denum pname, GC3Dint* value)
1628 {
1629     ASSERT(ACTIVE_ATTRIBUTES == pname || ACTIVE_UNIFORMS == pname);
1630     if (!value)
1631         return;
1632 
1633     makeContextCurrent();
1634     const auto&amp; result = m_shaderProgramSymbolCountMap.find(program);
1635     if (result != m_shaderProgramSymbolCountMap.end()) {
1636         *value = result-&gt;value.countForType(pname);
1637         return;
1638     }
1639 
1640     m_shaderProgramSymbolCountMap.set(program, ActiveShaderSymbolCounts());
1641     ActiveShaderSymbolCounts&amp; symbolCounts = m_shaderProgramSymbolCountMap.find(program)-&gt;value;
1642 
1643     // Retrieve the active attributes, build a filtered count, and a mapping of
1644     // our internal attributes indexes to the real unfiltered indexes inside OpenGL.
1645     GC3Dint attributeCount = 0;
1646     ::glGetProgramiv(program, ACTIVE_ATTRIBUTES, &amp;attributeCount);
1647     for (GC3Dint i = 0; i &lt; attributeCount; ++i) {
1648         ActiveInfo info;
1649         getActiveAttribImpl(program, i, info);
1650         if (info.name.startsWith(&quot;gl_&quot;))
1651             continue;
1652 
1653         symbolCounts.filteredToActualAttributeIndexMap.append(i);
1654     }
1655 
1656     // Do the same for uniforms.
1657     GC3Dint uniformCount = 0;
1658     ::glGetProgramiv(program, ACTIVE_UNIFORMS, &amp;uniformCount);
1659     for (GC3Dint i = 0; i &lt; uniformCount; ++i) {
1660         ActiveInfo info;
1661         getActiveUniformImpl(program, i, info);
1662         if (info.name.startsWith(&quot;gl_&quot;))
1663             continue;
1664 
1665         symbolCounts.filteredToActualUniformIndexMap.append(i);
1666     }
1667 
1668     *value = symbolCounts.countForType(pname);
1669 }
1670 
1671 String GraphicsContext3D::getUnmangledInfoLog(Platform3DObject shaders[2], GC3Dsizei count, const String&amp; log)
1672 {
1673     LOG(WebGL, &quot;Original ShaderInfoLog:\n%s&quot;, log.utf8().data());
1674 
1675     JSC::Yarr::RegularExpression regExp(&quot;webgl_[0123456789abcdefABCDEF]+&quot;);
1676 
1677     StringBuilder processedLog;
1678 
1679     // ANGLE inserts a &quot;#extension&quot; line into the shader source that
1680     // causes a warning in some compilers. There is no point showing
1681     // this warning to the user since they didn&#39;t write the code that
1682     // is causing it.
1683     static const NeverDestroyed&lt;String&gt; angleWarning { &quot;WARNING: 0:1: extension &#39;GL_ARB_gpu_shader5&#39; is not supported\n&quot;_s };
1684     int startFrom = log.startsWith(angleWarning) ? angleWarning.get().length() : 0;
1685     int matchedLength = 0;
1686 
1687     do {
1688         int start = regExp.match(log, startFrom, &amp;matchedLength);
1689         if (start == -1)
1690             break;
1691 
1692         processedLog.append(log.substring(startFrom, start - startFrom));
1693         startFrom = start + matchedLength;
1694 
1695         const String&amp; mangledSymbol = log.substring(start, matchedLength);
1696         const String&amp; mappedSymbol = mappedSymbolName(shaders, count, mangledSymbol);
1697         LOG(WebGL, &quot;Demangling: %s to %s&quot;, mangledSymbol.utf8().data(), mappedSymbol.utf8().data());
1698         processedLog.append(mappedSymbol);
1699     } while (startFrom &lt; static_cast&lt;int&gt;(log.length()));
1700 
1701     processedLog.append(log.substring(startFrom, log.length() - startFrom));
1702 
1703     LOG(WebGL, &quot;Unmangled ShaderInfoLog:\n%s&quot;, processedLog.toString().utf8().data());
1704     return processedLog.toString();
1705 }
1706 
1707 String GraphicsContext3D::getProgramInfoLog(Platform3DObject program)
1708 {
1709     ASSERT(program);
1710 
1711     makeContextCurrent();
1712     GLint length = 0;
1713     ::glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;length);
1714     if (!length)
1715         return String();
1716 
1717     GLsizei size = 0;
1718     Vector&lt;GLchar&gt; info(length);
1719     ::glGetProgramInfoLog(program, length, &amp;size, info.data());
1720 
1721     GC3Dsizei count;
1722     Platform3DObject shaders[2];
1723     getAttachedShaders(program, 2, &amp;count, shaders);
1724 
1725     return getUnmangledInfoLog(shaders, count, String(info.data(), size));
1726 }
1727 
1728 void GraphicsContext3D::getRenderbufferParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value)
1729 {
1730     makeContextCurrent();
1731     ::glGetRenderbufferParameterivEXT(target, pname, value);
1732 }
1733 
1734 void GraphicsContext3D::getShaderiv(Platform3DObject shader, GC3Denum pname, GC3Dint* value)
1735 {
1736     ASSERT(shader);
1737 
1738     makeContextCurrent();
1739 
1740     const auto&amp; result = m_shaderSourceMap.find(shader);
1741 
1742     switch (pname) {
1743     case DELETE_STATUS:
1744     case SHADER_TYPE:
1745         ::glGetShaderiv(shader, pname, value);
1746         break;
1747     case COMPILE_STATUS:
1748         if (result == m_shaderSourceMap.end()) {
1749             *value = static_cast&lt;int&gt;(false);
1750             return;
1751         }
1752         *value = static_cast&lt;int&gt;(result-&gt;value.isValid);
1753         break;
1754     case INFO_LOG_LENGTH:
1755         if (result == m_shaderSourceMap.end()) {
1756             *value = 0;
1757             return;
1758         }
1759         *value = getShaderInfoLog(shader).length();
1760         break;
1761     case SHADER_SOURCE_LENGTH:
1762         *value = getShaderSource(shader).length();
1763         break;
1764     default:
1765         synthesizeGLError(INVALID_ENUM);
1766     }
1767 }
1768 
1769 String GraphicsContext3D::getShaderInfoLog(Platform3DObject shader)
1770 {
1771     ASSERT(shader);
1772 
1773     makeContextCurrent();
1774 
1775     const auto&amp; result = m_shaderSourceMap.find(shader);
1776     if (result == m_shaderSourceMap.end())
1777         return String();
1778 
1779     const ShaderSourceEntry&amp; entry = result-&gt;value;
1780     if (!entry.isValid)
1781         return entry.log;
1782 
1783     GLint length = 0;
1784     ::glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;length);
1785     if (!length)
1786         return String();
1787 
1788     GLsizei size = 0;
1789     Vector&lt;GLchar&gt; info(length);
1790     ::glGetShaderInfoLog(shader, length, &amp;size, info.data());
1791 
1792     Platform3DObject shaders[2] = { shader, 0 };
1793     return getUnmangledInfoLog(shaders, 1, String(info.data(), size));
1794 }
1795 
1796 String GraphicsContext3D::getShaderSource(Platform3DObject shader)
1797 {
1798     ASSERT(shader);
1799 
1800     makeContextCurrent();
1801 
1802     const auto&amp; result = m_shaderSourceMap.find(shader);
1803     if (result == m_shaderSourceMap.end())
1804         return String();
1805 
1806     return result-&gt;value.source;
1807 }
1808 
1809 
1810 void GraphicsContext3D::getTexParameterfv(GC3Denum target, GC3Denum pname, GC3Dfloat* value)
1811 {
1812     makeContextCurrent();
1813     ::glGetTexParameterfv(target, pname, value);
1814 }
1815 
1816 void GraphicsContext3D::getTexParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value)
1817 {
1818     makeContextCurrent();
1819     ::glGetTexParameteriv(target, pname, value);
1820 }
1821 
1822 void GraphicsContext3D::getUniformfv(Platform3DObject program, GC3Dint location, GC3Dfloat* value)
1823 {
1824     makeContextCurrent();
1825     ::glGetUniformfv(program, location, value);
1826 }
1827 
1828 void GraphicsContext3D::getUniformiv(Platform3DObject program, GC3Dint location, GC3Dint* value)
1829 {
1830     makeContextCurrent();
1831     ::glGetUniformiv(program, location, value);
1832 }
1833 
1834 GC3Dint GraphicsContext3D::getUniformLocation(Platform3DObject program, const String&amp; name)
1835 {
1836     ASSERT(program);
1837 
1838     makeContextCurrent();
1839 
1840     String mappedName = mappedSymbolName(program, SHADER_SYMBOL_TYPE_UNIFORM, name);
1841     LOG(WebGL, &quot;::getUniformLocation is mapping %s to %s&quot;, name.utf8().data(), mappedName.utf8().data());
1842     return ::glGetUniformLocation(program, mappedName.utf8().data());
1843 }
1844 
1845 void GraphicsContext3D::getVertexAttribfv(GC3Duint index, GC3Denum pname, GC3Dfloat* value)
1846 {
1847     makeContextCurrent();
1848     ::glGetVertexAttribfv(index, pname, value);
1849 }
1850 
1851 void GraphicsContext3D::getVertexAttribiv(GC3Duint index, GC3Denum pname, GC3Dint* value)
1852 {
1853     makeContextCurrent();
1854     ::glGetVertexAttribiv(index, pname, value);
1855 }
1856 
1857 GC3Dsizeiptr GraphicsContext3D::getVertexAttribOffset(GC3Duint index, GC3Denum pname)
1858 {
1859     makeContextCurrent();
1860 
1861     GLvoid* pointer = 0;
1862     ::glGetVertexAttribPointerv(index, pname, &amp;pointer);
1863     return static_cast&lt;GC3Dsizeiptr&gt;(reinterpret_cast&lt;intptr_t&gt;(pointer));
1864 }
1865 
1866 void GraphicsContext3D::texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoff, GC3Dint yoff, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, const void* pixels)
1867 {
1868     makeContextCurrent();
1869 
1870 #if !USE(OPENGL_ES)
1871     if (type == HALF_FLOAT_OES)
1872         type = GL_HALF_FLOAT_ARB;
1873 #endif
1874 
1875     if (m_usingCoreProfile)  {
1876         // There are some format values used in WebGL that are deprecated when using a core profile, so we need
1877         // to adapt them, as we do in GraphicsContext3D::texImage2D().
1878         switch (format) {
1879         case ALPHA:
1880             // We are using GL_RED to back GL_ALPHA, so do it here as well.
1881             format = RED;
1882             break;
1883         case LUMINANCE_ALPHA:
1884             // We are using GL_RG to back GL_LUMINANCE_ALPHA, so do it here as well.
1885             format = RG;
1886             break;
1887         default:
1888             break;
1889         }
1890     }
1891 
1892     // FIXME: we will need to deal with PixelStore params when dealing with image buffers that differ from the subimage size.
1893     ::glTexSubImage2D(target, level, xoff, yoff, width, height, format, type, pixels);
1894     m_state.textureSeedCount.add(m_state.currentBoundTexture());
1895 }
1896 
1897 void GraphicsContext3D::compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Dsizei imageSize, const void* data)
1898 {
1899     makeContextCurrent();
1900     ::glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
1901     m_state.textureSeedCount.add(m_state.currentBoundTexture());
1902 }
1903 
1904 void GraphicsContext3D::compressedTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Dsizei imageSize, const void* data)
1905 {
1906     makeContextCurrent();
1907     ::glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
1908     m_state.textureSeedCount.add(m_state.currentBoundTexture());
1909 }
1910 
1911 Platform3DObject GraphicsContext3D::createBuffer()
1912 {
1913     makeContextCurrent();
1914     GLuint o = 0;
1915     glGenBuffers(1, &amp;o);
1916     return o;
1917 }
1918 
1919 Platform3DObject GraphicsContext3D::createFramebuffer()
1920 {
1921     makeContextCurrent();
1922     GLuint o = 0;
1923     glGenFramebuffersEXT(1, &amp;o);
1924     return o;
1925 }
1926 
1927 Platform3DObject GraphicsContext3D::createProgram()
1928 {
1929     makeContextCurrent();
1930     return glCreateProgram();
1931 }
1932 
1933 Platform3DObject GraphicsContext3D::createRenderbuffer()
1934 {
1935     makeContextCurrent();
1936     GLuint o = 0;
1937     glGenRenderbuffersEXT(1, &amp;o);
1938     return o;
1939 }
1940 
1941 Platform3DObject GraphicsContext3D::createShader(GC3Denum type)
1942 {
1943     makeContextCurrent();
1944     return glCreateShader((type == FRAGMENT_SHADER) ? GL_FRAGMENT_SHADER : GL_VERTEX_SHADER);
1945 }
1946 
1947 Platform3DObject GraphicsContext3D::createTexture()
1948 {
1949     makeContextCurrent();
1950     GLuint o = 0;
1951     glGenTextures(1, &amp;o);
1952     m_state.textureSeedCount.add(o);
1953     return o;
1954 }
1955 
1956 void GraphicsContext3D::deleteBuffer(Platform3DObject buffer)
1957 {
1958     makeContextCurrent();
1959     glDeleteBuffers(1, &amp;buffer);
1960 }
1961 
1962 void GraphicsContext3D::deleteFramebuffer(Platform3DObject framebuffer)
1963 {
1964     makeContextCurrent();
1965     if (framebuffer == m_state.boundFBO) {
1966         // Make sure the framebuffer is not going to be used for drawing
1967         // operations after it gets deleted.
1968         bindFramebuffer(FRAMEBUFFER, 0);
1969     }
1970     glDeleteFramebuffersEXT(1, &amp;framebuffer);
1971 }
1972 
1973 void GraphicsContext3D::deleteProgram(Platform3DObject program)
1974 {
1975     makeContextCurrent();
1976     m_shaderProgramSymbolCountMap.remove(program);
1977     glDeleteProgram(program);
1978 }
1979 
1980 void GraphicsContext3D::deleteRenderbuffer(Platform3DObject renderbuffer)
1981 {
1982     makeContextCurrent();
1983     glDeleteRenderbuffersEXT(1, &amp;renderbuffer);
1984 }
1985 
1986 void GraphicsContext3D::deleteShader(Platform3DObject shader)
1987 {
1988     makeContextCurrent();
1989     glDeleteShader(shader);
1990 }
1991 
1992 void GraphicsContext3D::deleteTexture(Platform3DObject texture)
1993 {
1994     makeContextCurrent();
1995     m_state.boundTextureMap.removeIf([texture] (auto&amp; keyValue) {
1996         return keyValue.value.first == texture;
1997     });
1998     glDeleteTextures(1, &amp;texture);
1999     m_state.textureSeedCount.removeAll(texture);
2000 }
2001 
2002 void GraphicsContext3D::synthesizeGLError(GC3Denum error)
2003 {
2004     // Need to move the current errors to the synthetic error list to
2005     // preserve the order of errors, so a caller to getError will get
2006     // any errors from glError before the error we are synthesizing.
2007     moveErrorsToSyntheticErrorList();
2008     m_syntheticErrors.add(error);
2009 }
2010 
2011 void GraphicsContext3D::markContextChanged()
2012 {
2013     m_layerComposited = false;
2014 }
2015 
2016 void GraphicsContext3D::markLayerComposited()
2017 {
2018     m_layerComposited = true;
<a name="5" id="anc5"></a>


2019 }
2020 
2021 bool GraphicsContext3D::layerComposited() const
2022 {
2023     return m_layerComposited;
2024 }
2025 
2026 void GraphicsContext3D::forceContextLost()
2027 {
<a name="6" id="anc6"></a><span class="line-modified">2028 #if ENABLE(WEBGL)</span>
<span class="line-modified">2029     if (m_webglContext)</span>
<span class="line-removed">2030         m_webglContext-&gt;forceLostContext(WebGLRenderingContextBase::RealLostContext);</span>
<span class="line-removed">2031 #endif</span>
2032 }
2033 
2034 void GraphicsContext3D::recycleContext()
2035 {
<a name="7" id="anc7"></a><span class="line-modified">2036 #if ENABLE(WEBGL)</span>
<span class="line-modified">2037     if (m_webglContext)</span>
<span class="line-removed">2038         m_webglContext-&gt;recycleContext();</span>
<span class="line-removed">2039 #endif</span>
2040 }
2041 
2042 void GraphicsContext3D::dispatchContextChangedNotification()
2043 {
<a name="8" id="anc8"></a><span class="line-modified">2044 #if ENABLE(WEBGL)</span>
<span class="line-modified">2045     if (m_webglContext)</span>
<span class="line-removed">2046         m_webglContext-&gt;dispatchContextChangedEvent();</span>
<span class="line-removed">2047 #endif</span>
2048 }
2049 
2050 void GraphicsContext3D::texImage2DDirect(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels)
2051 {
2052     makeContextCurrent();
2053     ::glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
2054     m_state.textureSeedCount.add(m_state.currentBoundTexture());
2055 }
2056 
2057 void GraphicsContext3D::drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount)
2058 {
2059     getExtensions().drawArraysInstanced(mode, first, count, primcount);
2060     checkGPUStatus();
2061 }
2062 
2063 void GraphicsContext3D::drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, GC3Dintptr offset, GC3Dsizei primcount)
2064 {
2065     getExtensions().drawElementsInstanced(mode, count, type, offset, primcount);
2066     checkGPUStatus();
2067 }
2068 
2069 void GraphicsContext3D::vertexAttribDivisor(GC3Duint index, GC3Duint divisor)
2070 {
2071     getExtensions().vertexAttribDivisor(index, divisor);
2072 }
2073 
2074 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
2075 void GraphicsContext3D::primitiveRestartIndex(GC3Duint index)
2076 {
2077     makeContextCurrent();
2078     ::glPrimitiveRestartIndex(index);
2079 }
2080 #endif
2081 
2082 }
2083 
<a name="9" id="anc9"></a><span class="line-modified">2084 #endif // ENABLE(GRAPHICS_CONTEXT_3D)</span>
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>