<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayerBacking.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerCompositor.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,25 ***</span>
<span class="line-new-header">--- 33,29 ---</span>
  #include &quot;Chrome.h&quot;
  #include &quot;ChromeClient.h&quot;
  #include &quot;DocumentTimeline.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;FrameView.h&quot;
<span class="line-added">+ #include &quot;FullscreenManager.h&quot;</span>
  #include &quot;GraphicsLayer.h&quot;
  #include &quot;HTMLCanvasElement.h&quot;
  #include &quot;HTMLIFrameElement.h&quot;
  #include &quot;HTMLNames.h&quot;
  #include &quot;HitTestResult.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
<span class="line-added">+ #include &quot;LayerAncestorClippingStack.h&quot;</span>
<span class="line-added">+ #include &quot;LayerOverlapMap.h&quot;</span>
  #include &quot;Logging.h&quot;
  #include &quot;NodeList.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;PageOverlayController.h&quot;
  #include &quot;RenderEmbeddedObject.h&quot;
  #include &quot;RenderFragmentedFlow.h&quot;
  #include &quot;RenderFullScreen.h&quot;
  #include &quot;RenderGeometryMap.h&quot;
  #include &quot;RenderIFrame.h&quot;
<span class="line-added">+ #include &quot;RenderImage.h&quot;</span>
  #include &quot;RenderLayerBacking.h&quot;
  #include &quot;RenderReplica.h&quot;
  #include &quot;RenderVideo.h&quot;
  #include &quot;RenderView.h&quot;
  #include &quot;RuntimeEnabledFeatures.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,192 ***</span>
  struct ScrollingTreeState {
      Optional&lt;ScrollingNodeID&gt; parentNodeID;
      size_t nextChildIndex { 0 };
  };
  
<span class="line-modified">! class OverlapMapContainer {</span>
<span class="line-modified">! public:</span>
<span class="line-modified">!     void add(const LayoutRect&amp; bounds)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         m_layerRects.append(bounds);</span>
<span class="line-removed">-         m_boundingBox.unite(bounds);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bool overlapsLayers(const LayoutRect&amp; bounds) const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         // Checking with the bounding box will quickly reject cases when</span>
<span class="line-removed">-         // layers are created for lists of items going in one direction and</span>
<span class="line-removed">-         // never overlap with each other.</span>
<span class="line-removed">-         if (!bounds.intersects(m_boundingBox))</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         for (const auto&amp; layerRect : m_layerRects) {</span>
<span class="line-removed">-             if (layerRect.intersects(bounds))</span>
<span class="line-removed">-                 return true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void unite(const OverlapMapContainer&amp; otherContainer)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         m_layerRects.appendVector(otherContainer.m_layerRects);</span>
<span class="line-removed">-         m_boundingBox.unite(otherContainer.m_boundingBox);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-     Vector&lt;LayoutRect&gt; m_layerRects;</span>
<span class="line-removed">-     LayoutRect m_boundingBox;</span>
  };
  
<span class="line-modified">! class RenderLayerCompositor::OverlapMap {</span>
<span class="line-modified">!     WTF_MAKE_NONCOPYABLE(OverlapMap);</span>
<span class="line-modified">! public:</span>
<span class="line-modified">!     OverlapMap()</span>
<span class="line-removed">-         : m_geometryMap(UseTransforms)</span>
      {
<span class="line-removed">-         // Begin assuming the root layer will be composited so that there is</span>
<span class="line-removed">-         // something on the stack. The root layer should also never get an</span>
<span class="line-removed">-         // popCompositingContainer call.</span>
<span class="line-removed">-         pushCompositingContainer();</span>
      }
  
<span class="line-modified">!     void add(const LayoutRect&amp; bounds)</span>
      {
<span class="line-modified">!         // Layers do not contribute to overlap immediately--instead, they will</span>
<span class="line-modified">!         // contribute to overlap as soon as their composited ancestor has been</span>
<span class="line-modified">!         // recursively processed and popped off the stack.</span>
<span class="line-modified">!         ASSERT(m_overlapStack.size() &gt;= 2);</span>
<span class="line-modified">!         m_overlapStack[m_overlapStack.size() - 2].add(bounds);</span>
<span class="line-modified">!         m_isEmpty = false;</span>
      }
  
<span class="line-modified">!     bool overlapsLayers(const LayoutRect&amp; bounds) const</span>
      {
<span class="line-modified">!         return m_overlapStack.last().overlapsLayers(bounds);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     bool isEmpty() const</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         return m_isEmpty;</span>
      }
  
<span class="line-modified">!     void pushCompositingContainer()</span>
      {
<span class="line-modified">!         m_overlapStack.append(OverlapMapContainer());</span>
      }
  
<span class="line-modified">!     void popCompositingContainer()</span>
      {
<span class="line-modified">!         m_overlapStack[m_overlapStack.size() - 2].unite(m_overlapStack.last());</span>
<span class="line-modified">!         m_overlapStack.removeLast();</span>
      }
  
<span class="line-modified">!     const RenderGeometryMap&amp; geometryMap() const { return m_geometryMap; }</span>
<span class="line-modified">!     RenderGeometryMap&amp; geometryMap() { return m_geometryMap; }</span>
  
  private:
<span class="line-modified">!     struct RectList {</span>
<span class="line-removed">-         Vector&lt;LayoutRect&gt; rects;</span>
<span class="line-removed">-         LayoutRect boundingRect;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         void append(const LayoutRect&amp; rect)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             rects.append(rect);</span>
<span class="line-removed">-             boundingRect.unite(rect);</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         void append(const RectList&amp; rectList)</span>
<span class="line-modified">!         {</span>
<span class="line-removed">-             rects.appendVector(rectList.rects);</span>
<span class="line-removed">-             boundingRect.unite(rectList.boundingRect);</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         bool intersects(const LayoutRect&amp; rect) const</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             if (!rects.size() || !boundingRect.intersects(rect))</span>
<span class="line-modified">!                 return false;</span>
  
<span class="line-modified">!             for (const auto&amp; currentRect : rects) {</span>
<span class="line-modified">!                 if (currentRect.intersects(rect))</span>
<span class="line-modified">!                     return true;</span>
<span class="line-modified">!             }</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     };</span>
  
<span class="line-modified">!     Vector&lt;OverlapMapContainer&gt; m_overlapStack;</span>
<span class="line-modified">!     RenderGeometryMap m_geometryMap;</span>
<span class="line-modified">!     bool m_isEmpty { true };</span>
<span class="line-removed">- };</span>
  
<span class="line-modified">! struct RenderLayerCompositor::CompositingState {</span>
<span class="line-modified">!     CompositingState(RenderLayer* compAncestor, bool testOverlap = true)</span>
<span class="line-modified">!         : compositingAncestor(compAncestor)</span>
<span class="line-modified">!         , testingOverlap(testOverlap)</span>
<span class="line-modified">!     {</span>
      }
  
<span class="line-modified">!     CompositingState(const CompositingState&amp; other)</span>
<span class="line-modified">!         : compositingAncestor(other.compositingAncestor)</span>
<span class="line-modified">!         , subtreeIsCompositing(other.subtreeIsCompositing)</span>
<span class="line-modified">!         , testingOverlap(other.testingOverlap)</span>
<span class="line-modified">!         , fullPaintOrderTraversalRequired(other.fullPaintOrderTraversalRequired)</span>
<span class="line-modified">!         , descendantsRequireCompositingUpdate(other.descendantsRequireCompositingUpdate)</span>
<span class="line-modified">!         , ancestorHasTransformAnimation(other.ancestorHasTransformAnimation)</span>
<span class="line-modified">! #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-modified">!         , hasNotIsolatedCompositedBlendingDescendants(other.hasNotIsolatedCompositedBlendingDescendants)</span>
<span class="line-modified">! #endif</span>
<span class="line-modified">! #if ENABLE(TREE_DEBUGGING)</span>
<span class="line-removed">-         , depth(other.depth + 1)</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     {</span>
      }
  
<span class="line-modified">!     RenderLayer* compositingAncestor;</span>
<span class="line-modified">!     bool subtreeIsCompositing { false };</span>
<span class="line-modified">!     bool testingOverlap { true };</span>
<span class="line-modified">!     bool fullPaintOrderTraversalRequired { false };</span>
<span class="line-modified">!     bool descendantsRequireCompositingUpdate { false };</span>
<span class="line-modified">!     bool ancestorHasTransformAnimation { false };</span>
<span class="line-modified">! #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-removed">-     bool hasNotIsolatedCompositedBlendingDescendants { false };</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- #if ENABLE(TREE_DEBUGGING)</span>
<span class="line-removed">-     int depth { 0 };</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- };</span>
  
<span class="line-modified">! struct RenderLayerCompositor::OverlapExtent {</span>
<span class="line-modified">!     LayoutRect bounds;</span>
<span class="line-modified">!     bool extentComputed { false };</span>
<span class="line-modified">!     bool hasTransformAnimation { false };</span>
<span class="line-modified">!     bool animationCausesExtentUncertainty { false };</span>
  
<span class="line-modified">!     bool knownToBeHaveExtentUncertainty() const { return extentComputed &amp;&amp; animationCausesExtentUncertainty; }</span>
<span class="line-modified">! };</span>
  
<span class="line-modified">! #if !LOG_DISABLED</span>
  static inline bool compositingLogEnabled()
  {
<span class="line-modified">!     return LogCompositing.state == WTFLogChannelOn;</span>
  }
  #endif
  
  RenderLayerCompositor::RenderLayerCompositor(RenderView&amp; renderView)
      : m_renderView(renderView)
      , m_updateCompositingLayersTimer(*this, &amp;RenderLayerCompositor::updateCompositingLayersTimerFired)
      , m_layerFlushTimer(*this, &amp;RenderLayerCompositor::layerFlushTimerFired)
  {
  #if PLATFORM(IOS_FAMILY)
      if (m_renderView.frameView().platformWidget())
<span class="line-modified">!         m_legacyScrollingLayerCoordinator = std::make_unique&lt;LegacyWebKitScrollingLayerCoordinator&gt;(page().chrome().client(), isMainFrameCompositor());</span>
  #endif
  }
  
  RenderLayerCompositor::~RenderLayerCompositor()
  {
      // Take care that the owned GraphicsLayers are deleted first as their destructors may call back here.
<span class="line-modified">!     m_clipLayer = nullptr;</span>
<span class="line-modified">!     m_scrolledContentsLayer = nullptr;</span>
      ASSERT(m_rootLayerAttachment == RootLayerUnattached);
  }
  
  void RenderLayerCompositor::enableCompositingMode(bool enable /* = true */)
  {
<span class="line-new-header">--- 113,218 ---</span>
  struct ScrollingTreeState {
      Optional&lt;ScrollingNodeID&gt; parentNodeID;
      size_t nextChildIndex { 0 };
  };
  
<span class="line-modified">! struct RenderLayerCompositor::OverlapExtent {</span>
<span class="line-modified">!     LayoutRect bounds;</span>
<span class="line-modified">!     bool extentComputed { false };</span>
<span class="line-modified">!     bool hasTransformAnimation { false };</span>
<span class="line-modified">!     bool animationCausesExtentUncertainty { false };</span>
  
<span class="line-modified">!     bool knownToBeHaveExtentUncertainty() const { return extentComputed &amp;&amp; animationCausesExtentUncertainty; }</span>
  };
  
<span class="line-modified">! struct RenderLayerCompositor::CompositingState {</span>
<span class="line-modified">!     CompositingState(RenderLayer* compAncestor, bool testOverlap = true)</span>
<span class="line-modified">!         : compositingAncestor(compAncestor)</span>
<span class="line-modified">!         , testingOverlap(testOverlap)</span>
      {
      }
  
<span class="line-modified">!     CompositingState stateForPaintOrderChildren(RenderLayer&amp; layer) const</span>
      {
<span class="line-modified">!         UNUSED_PARAM(layer);</span>
<span class="line-modified">!         CompositingState childState(compositingAncestor);</span>
<span class="line-modified">!         if (layer.isStackingContext())</span>
<span class="line-modified">!             childState.stackingContextAncestor = &amp;layer;</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!             childState.stackingContextAncestor = stackingContextAncestor;</span>
<span class="line-added">+ </span>
<span class="line-added">+         childState.backingSharingAncestor = backingSharingAncestor;</span>
<span class="line-added">+         childState.subtreeIsCompositing = false;</span>
<span class="line-added">+         childState.testingOverlap = testingOverlap;</span>
<span class="line-added">+         childState.fullPaintOrderTraversalRequired = fullPaintOrderTraversalRequired;</span>
<span class="line-added">+         childState.descendantsRequireCompositingUpdate = descendantsRequireCompositingUpdate;</span>
<span class="line-added">+         childState.ancestorHasTransformAnimation = ancestorHasTransformAnimation;</span>
<span class="line-added">+ #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-added">+         childState.hasNotIsolatedCompositedBlendingDescendants = false; // FIXME: should this only be reset for stacking contexts?</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ #if !LOG_DISABLED</span>
<span class="line-added">+         childState.depth = depth + 1;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         return childState;</span>
      }
  
<span class="line-modified">!     void updateWithDescendantStateAndLayer(const CompositingState&amp; childState, const RenderLayer&amp; layer, const OverlapExtent&amp; layerExtent, bool isUnchangedSubtree = false)</span>
      {
<span class="line-modified">!         // Subsequent layers in the parent stacking context also need to composite.</span>
<span class="line-modified">!         subtreeIsCompositing |= childState.subtreeIsCompositing | layer.isComposited();</span>
<span class="line-added">+         if (!isUnchangedSubtree)</span>
<span class="line-added">+             fullPaintOrderTraversalRequired |= childState.fullPaintOrderTraversalRequired;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Turn overlap testing off for later layers if it&#39;s already off, or if we have an animating transform.</span>
<span class="line-added">+         // Note that if the layer clips its descendants, there&#39;s no reason to propagate the child animation to the parent layers. That&#39;s because</span>
<span class="line-added">+         // we know for sure the animation is contained inside the clipping rectangle, which is already added to the overlap map.</span>
<span class="line-added">+         auto canReenableOverlapTesting = [&amp;layer]() {</span>
<span class="line-added">+             return layer.isComposited() &amp;&amp; RenderLayerCompositor::clipsCompositingDescendants(layer);</span>
<span class="line-added">+         };</span>
<span class="line-added">+         if ((!childState.testingOverlap &amp;&amp; !canReenableOverlapTesting()) || layerExtent.knownToBeHaveExtentUncertainty())</span>
<span class="line-added">+             testingOverlap = false;</span>
  
<span class="line-modified">! #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-modified">!         if ((layer.isComposited() &amp;&amp; layer.hasBlendMode()) || (layer.hasNotIsolatedCompositedBlendingDescendants() &amp;&amp; !layer.isolatesCompositedBlending()))</span>
<span class="line-modified">!             hasNotIsolatedCompositedBlendingDescendants = true;</span>
<span class="line-added">+ #endif</span>
      }
  
<span class="line-modified">!     bool hasNonRootCompositedAncestor() const</span>
      {
<span class="line-modified">!         return compositingAncestor &amp;&amp; !compositingAncestor-&gt;isRenderViewLayer();</span>
      }
  
<span class="line-modified">!     RenderLayer* compositingAncestor;</span>
<span class="line-added">+     RenderLayer* backingSharingAncestor { nullptr };</span>
<span class="line-added">+     RenderLayer* stackingContextAncestor { nullptr };</span>
<span class="line-added">+     bool subtreeIsCompositing { false };</span>
<span class="line-added">+     bool testingOverlap { true };</span>
<span class="line-added">+     bool fullPaintOrderTraversalRequired { false };</span>
<span class="line-added">+     bool descendantsRequireCompositingUpdate { false };</span>
<span class="line-added">+     bool ancestorHasTransformAnimation { false };</span>
<span class="line-added">+ #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-added">+     bool hasNotIsolatedCompositedBlendingDescendants { false };</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ #if !LOG_DISABLED</span>
<span class="line-added">+     unsigned depth { 0 };</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class RenderLayerCompositor::BackingSharingState {</span>
<span class="line-added">+     WTF_MAKE_NONCOPYABLE(BackingSharingState);</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     BackingSharingState() = default;</span>
<span class="line-added">+ </span>
<span class="line-added">+     RenderLayer* backingProviderCandidate() const { return m_backingProviderCandidate; };</span>
<span class="line-added">+ </span>
<span class="line-added">+     void appendSharingLayer(RenderLayer&amp; layer)</span>
      {
<span class="line-modified">!         ASSERT(m_backingProviderCandidate);</span>
<span class="line-modified">!         m_backingSharingLayers.append(makeWeakPtr(layer));</span>
      }
  
<span class="line-modified">!     void updateBeforeDescendantTraversal(RenderLayer&amp;, bool willBeComposited);</span>
<span class="line-modified">!     void updateAfterDescendantTraversal(RenderLayer&amp;, RenderLayer* stackingContextAncestor);</span>
  
  private:
<span class="line-modified">!     void layerWillBeComposited(RenderLayer&amp;);</span>
  
<span class="line-modified">!     void startBackingSharingSequence(RenderLayer&amp; candidateLayer, RenderLayer* candidateStackingContext);</span>
<span class="line-modified">!     void endBackingSharingSequence();</span>
  
<span class="line-modified">!     RenderLayer* m_backingProviderCandidate { nullptr };</span>
<span class="line-modified">!     RenderLayer* m_backingProviderStackingContext { nullptr };</span>
<span class="line-modified">!     Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt; m_backingSharingLayers;</span>
<span class="line-modified">! };</span>
  
<span class="line-modified">! void RenderLayerCompositor::BackingSharingState::startBackingSharingSequence(RenderLayer&amp; candidateLayer, RenderLayer* candidateStackingContext)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     ASSERT(!m_backingProviderCandidate);</span>
<span class="line-modified">!     ASSERT(m_backingSharingLayers.isEmpty());</span>
  
<span class="line-modified">!     m_backingProviderCandidate = &amp;candidateLayer;</span>
<span class="line-modified">!     m_backingProviderStackingContext = candidateStackingContext;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void RenderLayerCompositor::BackingSharingState::endBackingSharingSequence()</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (m_backingProviderCandidate) {</span>
<span class="line-modified">!         m_backingProviderCandidate-&gt;backing()-&gt;setBackingSharingLayers(WTFMove(m_backingSharingLayers));</span>
<span class="line-modified">!         m_backingSharingLayers.clear();</span>
      }
  
<span class="line-modified">!     m_backingProviderCandidate = nullptr;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void RenderLayerCompositor::BackingSharingState::updateBeforeDescendantTraversal(RenderLayer&amp; layer, bool willBeComposited)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     layer.setBackingProviderLayer(nullptr);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // A layer that composites resets backing-sharing, since subsequent layers need to composite to overlap it.</span>
<span class="line-modified">!     if (willBeComposited) {</span>
<span class="line-modified">!         m_backingSharingLayers.removeAll(&amp;layer);</span>
<span class="line-modified">!         endBackingSharingSequence();</span>
      }
<span class="line-added">+ }</span>
  
<span class="line-modified">! void RenderLayerCompositor::BackingSharingState::updateAfterDescendantTraversal(RenderLayer&amp; layer, RenderLayer* stackingContextAncestor)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (layer.isComposited()) {</span>
<span class="line-modified">!         // If this layer is being composited, clean up sharing-related state.</span>
<span class="line-modified">!         layer.disconnectFromBackingProviderLayer();</span>
<span class="line-modified">!         m_backingSharingLayers.removeAll(&amp;layer);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     if (m_backingProviderCandidate &amp;&amp; &amp;layer == m_backingProviderStackingContext) {</span>
<span class="line-modified">!         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;End of stacking context for backing provider &quot; &lt;&lt; m_backingProviderCandidate &lt;&lt; &quot;, ending sharing sequence with &quot; &lt;&lt; m_backingSharingLayers.size() &lt;&lt; &quot; sharing layers&quot;);</span>
<span class="line-modified">!         endBackingSharingSequence();</span>
<span class="line-modified">!     } else if (!m_backingProviderCandidate &amp;&amp; layer.isComposited()) {</span>
<span class="line-modified">!         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Post-descendant compositing of &quot; &lt;&lt; &amp;layer &lt;&lt; &quot;, ending sharing sequence for &quot; &lt;&lt; m_backingProviderCandidate &lt;&lt; &quot; with &quot; &lt;&lt; m_backingSharingLayers.size() &lt;&lt; &quot; sharing layers&quot;);</span>
<span class="line-added">+         endBackingSharingSequence();</span>
<span class="line-added">+         startBackingSharingSequence(layer, stackingContextAncestor);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (&amp;layer != m_backingProviderCandidate &amp;&amp; layer.isComposited())</span>
<span class="line-modified">!         layer.backing()-&gt;clearBackingSharingLayers();</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! #if !LOG_DISABLED || ENABLE(TREE_DEBUGGING)</span>
  static inline bool compositingLogEnabled()
  {
<span class="line-modified">!     return LogCompositing.state == WTFLogChannelState::On;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline bool layersLogEnabled()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return LogLayers.state == WTFLogChannelState::On;</span>
  }
  #endif
  
  RenderLayerCompositor::RenderLayerCompositor(RenderView&amp; renderView)
      : m_renderView(renderView)
      , m_updateCompositingLayersTimer(*this, &amp;RenderLayerCompositor::updateCompositingLayersTimerFired)
      , m_layerFlushTimer(*this, &amp;RenderLayerCompositor::layerFlushTimerFired)
  {
  #if PLATFORM(IOS_FAMILY)
      if (m_renderView.frameView().platformWidget())
<span class="line-modified">!         m_legacyScrollingLayerCoordinator = makeUnique&lt;LegacyWebKitScrollingLayerCoordinator&gt;(page().chrome().client(), isMainFrameCompositor());</span>
  #endif
  }
  
  RenderLayerCompositor::~RenderLayerCompositor()
  {
      // Take care that the owned GraphicsLayers are deleted first as their destructors may call back here.
<span class="line-modified">!     GraphicsLayer::unparentAndClear(m_rootContentsLayer);</span>
<span class="line-modified">! </span>
<span class="line-added">+     GraphicsLayer::unparentAndClear(m_clipLayer);</span>
<span class="line-added">+     GraphicsLayer::unparentAndClear(m_scrollContainerLayer);</span>
<span class="line-added">+     GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);</span>
<span class="line-added">+ </span>
<span class="line-added">+     GraphicsLayer::unparentAndClear(m_overflowControlsHostLayer);</span>
<span class="line-added">+ </span>
<span class="line-added">+     GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);</span>
<span class="line-added">+     GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);</span>
<span class="line-added">+     GraphicsLayer::unparentAndClear(m_layerForScrollCorner);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(RUBBER_BANDING)</span>
<span class="line-added">+     GraphicsLayer::unparentAndClear(m_layerForOverhangAreas);</span>
<span class="line-added">+     GraphicsLayer::unparentAndClear(m_contentShadowLayer);</span>
<span class="line-added">+     GraphicsLayer::unparentAndClear(m_layerForTopOverhangArea);</span>
<span class="line-added">+     GraphicsLayer::unparentAndClear(m_layerForBottomOverhangArea);</span>
<span class="line-added">+     GraphicsLayer::unparentAndClear(m_layerForHeader);</span>
<span class="line-added">+     GraphicsLayer::unparentAndClear(m_layerForFooter);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      ASSERT(m_rootLayerAttachment == RootLayerUnattached);
  }
  
  void RenderLayerCompositor::enableCompositingMode(bool enable /* = true */)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,28 ***</span>
  void RenderLayerCompositor::notifyFlushRequired(const GraphicsLayer* layer)
  {
      scheduleLayerFlush(layer-&gt;canThrottleLayerFlush());
  }
  
<span class="line-removed">- void RenderLayerCompositor::scheduleLayerFlushNow()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_hasPendingLayerFlush = false;</span>
<span class="line-removed">-     page().chrome().client().scheduleCompositingLayerFlush();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void RenderLayerCompositor::scheduleLayerFlush(bool canThrottle)
  {
      ASSERT(!m_flushingLayers);
  
      if (canThrottle)
          startInitialLayerFlushTimerIfNeeded();
  
<span class="line-modified">!     if (canThrottle &amp;&amp; isThrottlingLayerFlushes()) {</span>
          m_hasPendingLayerFlush = true;
<span class="line-modified">!         return;</span>
      }
<span class="line-removed">-     scheduleLayerFlushNow();</span>
  }
  
  FloatRect RenderLayerCompositor::visibleRectForLayerFlushing() const
  {
      const FrameView&amp; frameView = m_renderView.frameView();
<span class="line-new-header">--- 456,23 ---</span>
  void RenderLayerCompositor::notifyFlushRequired(const GraphicsLayer* layer)
  {
      scheduleLayerFlush(layer-&gt;canThrottleLayerFlush());
  }
  
  void RenderLayerCompositor::scheduleLayerFlush(bool canThrottle)
  {
      ASSERT(!m_flushingLayers);
  
      if (canThrottle)
          startInitialLayerFlushTimerIfNeeded();
  
<span class="line-modified">!     if (canThrottle &amp;&amp; isThrottlingLayerFlushes())</span>
          m_hasPendingLayerFlush = true;
<span class="line-modified">!     else {</span>
<span class="line-added">+         m_hasPendingLayerFlush = false;</span>
<span class="line-added">+         page().renderingUpdateScheduler().scheduleRenderingUpdate();</span>
      }
  }
  
  FloatRect RenderLayerCompositor::visibleRectForLayerFlushing() const
  {
      const FrameView&amp; frameView = m_renderView.frameView();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 493,10 ***</span>
<span class="line-new-header">--- 518,17 ---</span>
              LOG_WITH_STREAM(Compositing,  stream &lt;&lt; &quot;\nRenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; flushPendingLayerChanges (is root &quot; &lt;&lt; isFlushRoot &lt;&lt; &quot;) visible rect &quot; &lt;&lt; visibleRect);
              rootLayer-&gt;flushCompositingState(visibleRect);
          }
  
          ASSERT(m_flushingLayers);
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(TREE_DEBUGGING)</span>
<span class="line-added">+         if (layersLogEnabled()) {</span>
<span class="line-added">+             LOG(Layers, &quot;RenderLayerCompositor::flushPendingLayerChanges&quot;);</span>
<span class="line-added">+             showGraphicsLayerTree(rootGraphicsLayer());</span>
<span class="line-added">+         }</span>
<span class="line-added">+ #endif</span>
      }
  
  #if PLATFORM(IOS_FAMILY)
      updateScrollCoordinatedLayersAfterFlushIncludingSubframes();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 525,43 ***</span>
  
  void RenderLayerCompositor::updateScrollCoordinatedLayersAfterFlush()
  {
      if (m_legacyScrollingLayerCoordinator) {
          m_legacyScrollingLayerCoordinator-&gt;registerAllViewportConstrainedLayers(*this);
<span class="line-modified">!         m_legacyScrollingLayerCoordinator-&gt;registerScrollingLayersNeedingUpdate();</span>
      }
  }
  #endif
  
  void RenderLayerCompositor::didChangePlatformLayerForLayer(RenderLayer&amp; layer, const GraphicsLayer*)
  {
<span class="line-removed">- #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">-     if (m_legacyScrollingLayerCoordinator)</span>
<span class="line-removed">-         m_legacyScrollingLayerCoordinator-&gt;didChangePlatformLayerForLayer(layer);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
      if (!scrollingCoordinator)
          return;
  
      auto* backing = layer.backing();
<span class="line-modified">!     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::ViewportConstrained))</span>
<span class="line-modified">!         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });</span>
  
<span class="line-modified">!     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling)) {</span>
<span class="line-modified">!         // FIXME: would be nice to not have to special-case the root.</span>
<span class="line-removed">-         ScrollingCoordinator::NodeLayers nodeLayers;</span>
<span class="line-removed">-         if (layer.isRenderViewLayer())</span>
<span class="line-removed">-             nodeLayers = { nullptr, scrollContainerLayer(), scrolledContentsLayer(), fixedRootBackgroundLayer(), clipLayer(), rootContentsLayer() };</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             nodeLayers = { layer.backing()-&gt;graphicsLayer(), backing-&gt;scrollContainerLayer(), backing-&gt;scrolledContentsLayer() };</span>
  
<span class="line-modified">!         scrollingCoordinator-&gt;setNodeLayers(nodeID, nodeLayers);</span>
<span class="line-modified">!     }</span>
  
      if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
          scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });
  }
  
  void RenderLayerCompositor::didPaintBacking(RenderLayerBacking*)
  {
      auto&amp; frameView = m_renderView.frameView();
<span class="line-new-header">--- 557,36 ---</span>
  
  void RenderLayerCompositor::updateScrollCoordinatedLayersAfterFlush()
  {
      if (m_legacyScrollingLayerCoordinator) {
          m_legacyScrollingLayerCoordinator-&gt;registerAllViewportConstrainedLayers(*this);
<span class="line-modified">!         m_legacyScrollingLayerCoordinator-&gt;registerAllScrollingLayers();</span>
      }
  }
  #endif
  
  void RenderLayerCompositor::didChangePlatformLayerForLayer(RenderLayer&amp; layer, const GraphicsLayer*)
  {
      auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
      if (!scrollingCoordinator)
          return;
  
      auto* backing = layer.backing();
<span class="line-modified">!     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling))</span>
<span class="line-modified">!         updateScrollingNodeLayers(nodeID, layer, *scrollingCoordinator);</span>
  
<span class="line-modified">!     if (auto* clippingStack = layer.backing()-&gt;ancestorClippingStack())</span>
<span class="line-modified">!         clippingStack-&gt;updateScrollingNodeLayers(*scrollingCoordinator);</span>
  
<span class="line-modified">!     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::ViewportConstrained))</span>
<span class="line-modified">!         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });</span>
  
      if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
          scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });
<span class="line-added">+ </span>
<span class="line-added">+     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Positioning))</span>
<span class="line-added">+         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });</span>
  }
  
  void RenderLayerCompositor::didPaintBacking(RenderLayerBacking*)
  {
      auto&amp; frameView = m_renderView.frameView();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 578,18 ***</span>
  
      FloatRect visibleRect = visibleRectForLayerFlushing();
      bool requiresFlush = rootLayer-&gt;visibleRectChangeRequiresFlush(visibleRect);
      LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor::didChangeVisibleRect &quot; &lt;&lt; visibleRect &lt;&lt; &quot; requiresFlush &quot; &lt;&lt; requiresFlush);
      if (requiresFlush)
<span class="line-modified">!         scheduleLayerFlushNow();</span>
  }
  
  void RenderLayerCompositor::notifyFlushBeforeDisplayRefresh(const GraphicsLayer*)
  {
      if (!m_layerUpdater) {
          PlatformDisplayID displayID = page().chrome().displayID();
<span class="line-modified">!         m_layerUpdater = std::make_unique&lt;GraphicsLayerUpdater&gt;(*this, displayID);</span>
      }
  
      m_layerUpdater-&gt;scheduleUpdate();
  }
  
<span class="line-new-header">--- 603,18 ---</span>
  
      FloatRect visibleRect = visibleRectForLayerFlushing();
      bool requiresFlush = rootLayer-&gt;visibleRectChangeRequiresFlush(visibleRect);
      LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor::didChangeVisibleRect &quot; &lt;&lt; visibleRect &lt;&lt; &quot; requiresFlush &quot; &lt;&lt; requiresFlush);
      if (requiresFlush)
<span class="line-modified">!         scheduleLayerFlush();</span>
  }
  
  void RenderLayerCompositor::notifyFlushBeforeDisplayRefresh(const GraphicsLayer*)
  {
      if (!m_layerUpdater) {
          PlatformDisplayID displayID = page().chrome().displayID();
<span class="line-modified">!         m_layerUpdater = makeUnique&lt;GraphicsLayerUpdater&gt;(*this, displayID);</span>
      }
  
      m_layerUpdater-&gt;scheduleUpdate();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 664,11 ***</span>
      if (updateType == CompositingUpdateType::AfterStyleChange || updateType == CompositingUpdateType::AfterLayout)
          cacheAcceleratedCompositingFlagsAfterLayout(); // Some flags (e.g. forceCompositingMode) depend on layout.
  
      m_updateCompositingLayersTimer.stop();
  
<span class="line-modified">!     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);</span>
  
      // Compositing layers will be updated in Document::setVisualUpdatesAllowed(bool) if suppressed here.
      if (!m_renderView.document().visualUpdatesAllowed())
          return false;
  
<span class="line-new-header">--- 689,12 ---</span>
      if (updateType == CompositingUpdateType::AfterStyleChange || updateType == CompositingUpdateType::AfterLayout)
          cacheAcceleratedCompositingFlagsAfterLayout(); // Some flags (e.g. forceCompositingMode) depend on layout.
  
      m_updateCompositingLayersTimer.stop();
  
<span class="line-modified">!     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache</span>
<span class="line-added">+         || m_renderView.document().pageCacheState() == Document::AboutToEnterPageCache);</span>
  
      // Compositing layers will be updated in Document::setVisualUpdatesAllowed(bool) if suppressed here.
      if (!m_renderView.document().visualUpdatesAllowed())
          return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 698,10 ***</span>
<span class="line-new-header">--- 724,15 ---</span>
  
          // Scrolling can affect overlap. FIXME: avoid for page scrolling.
          updateRoot-&gt;setDescendantsNeedCompositingRequirementsTraversal();
      }
  
<span class="line-added">+     if (updateType == CompositingUpdateType::AfterLayout) {</span>
<span class="line-added">+         // Ensure that post-layout updates push new scroll position and viewport rects onto the root node.</span>
<span class="line-added">+         rootRenderLayer().setNeedsScrollingTreeUpdate();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (!updateRoot-&gt;hasDescendantNeedingCompositingRequirementsTraversal() &amp;&amp; !m_compositing) {
          LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot; no compositing work to do&quot;);
          return true;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 735,15 ***</span>
      }
  #endif
  
      // FIXME: optimize root-only update.
      if (updateRoot-&gt;hasDescendantNeedingCompositingRequirementsTraversal() || updateRoot-&gt;needsCompositingRequirementsTraversal()) {
          CompositingState compositingState(updateRoot);
<span class="line-modified">!         OverlapMap overlapMap;</span>
  
          bool descendantHas3DTransform = false;
<span class="line-modified">!         computeCompositingRequirements(nullptr, rootRenderLayer(), overlapMap, compositingState, descendantHas3DTransform);</span>
      }
  
      LOG(Compositing, &quot;\nRenderLayerCompositor::updateCompositingLayers - mid&quot;);
  #if ENABLE(TREE_DEBUGGING)
      if (compositingLogEnabled())
<span class="line-new-header">--- 766,17 ---</span>
      }
  #endif
  
      // FIXME: optimize root-only update.
      if (updateRoot-&gt;hasDescendantNeedingCompositingRequirementsTraversal() || updateRoot-&gt;needsCompositingRequirementsTraversal()) {
<span class="line-added">+         auto&amp; rootLayer = rootRenderLayer();</span>
          CompositingState compositingState(updateRoot);
<span class="line-modified">!         BackingSharingState backingSharingState;</span>
<span class="line-added">+         LayerOverlapMap overlapMap(rootLayer);</span>
  
          bool descendantHas3DTransform = false;
<span class="line-modified">!         computeCompositingRequirements(nullptr, rootLayer, overlapMap, compositingState, backingSharingState, descendantHas3DTransform);</span>
      }
  
      LOG(Compositing, &quot;\nRenderLayerCompositor::updateCompositingLayers - mid&quot;);
  #if ENABLE(TREE_DEBUGGING)
      if (compositingLogEnabled())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 784,30 ***</span>
  
  #if ENABLE(TREE_DEBUGGING)
      if (compositingLogEnabled()) {
          LOG(Compositing, &quot;RenderLayerCompositor::updateCompositingLayers - post&quot;);
          showPaintOrderTree(m_renderView.layer());
<span class="line-removed">-         LOG(Compositing, &quot;RenderLayerCompositor::updateCompositingLayers - GraphicsLayers post, contentLayersCount %d&quot;, m_contentLayersCount);</span>
<span class="line-removed">-         showGraphicsLayerTree(m_rootContentsLayer.get());</span>
      }
  #endif
  
      InspectorInstrumentation::layerTreeDidChange(&amp;page());
  
      return true;
  }
  
<span class="line-modified">! void RenderLayerCompositor::computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer&amp; layer, OverlapMap&amp; overlapMap, CompositingState&amp; compositingState, bool&amp; descendantHas3DTransform)</span>
  {
<span class="line-modified">!     if (!layer.hasDescendantNeedingCompositingRequirementsTraversal() &amp;&amp; !layer.needsCompositingRequirementsTraversal() &amp;&amp; !compositingState.fullPaintOrderTraversalRequired &amp;&amp; !compositingState.descendantsRequireCompositingUpdate) {</span>
<span class="line-modified">!         traverseUnchangedSubtree(ancestorLayer, layer, overlapMap, compositingState, descendantHas3DTransform);</span>
          return;
      }
  
<span class="line-modified">! #if ENABLE(TREE_DEBUGGING)</span>
<span class="line-removed">-     LOG(Compositing, &quot;%*p computeCompositingRequirements&quot;, 12 + compositingState.depth * 2, &amp;layer);</span>
<span class="line-removed">- #endif</span>
  
      // FIXME: maybe we can avoid updating all remaining layers in paint order.
      compositingState.fullPaintOrderTraversalRequired |= layer.needsCompositingRequirementsTraversal();
      compositingState.descendantsRequireCompositingUpdate |= layer.descendantsNeedCompositingRequirementsTraversal();
  
<span class="line-new-header">--- 817,38 ---</span>
  
  #if ENABLE(TREE_DEBUGGING)
      if (compositingLogEnabled()) {
          LOG(Compositing, &quot;RenderLayerCompositor::updateCompositingLayers - post&quot;);
          showPaintOrderTree(m_renderView.layer());
      }
  #endif
  
      InspectorInstrumentation::layerTreeDidChange(&amp;page());
  
      return true;
  }
  
<span class="line-modified">! static bool backingProviderLayerCanIncludeLayer(const RenderLayer&amp; sharedLayer, const RenderLayer&amp; layer)</span>
  {
<span class="line-modified">!     // Disable sharing when painting shared layers doesn&#39;t work correctly.</span>
<span class="line-modified">!     if (layer.hasReflection())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return layer.ancestorLayerIsInContainingBlockChain(sharedLayer);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RenderLayerCompositor::computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer&amp; layer, LayerOverlapMap&amp; overlapMap, CompositingState&amp; compositingState, BackingSharingState&amp; backingSharingState, bool&amp; descendantHas3DTransform)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!layer.hasDescendantNeedingCompositingRequirementsTraversal()</span>
<span class="line-added">+         &amp;&amp; !layer.needsCompositingRequirementsTraversal()</span>
<span class="line-added">+         &amp;&amp; !compositingState.fullPaintOrderTraversalRequired</span>
<span class="line-added">+         &amp;&amp; !compositingState.descendantsRequireCompositingUpdate) {</span>
<span class="line-added">+         traverseUnchangedSubtree(ancestorLayer, layer, overlapMap, compositingState, backingSharingState, descendantHas3DTransform);</span>
          return;
      }
  
<span class="line-modified">!     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; (layer.isNormalFlowOnly() ? &quot; n&quot; : &quot; s&quot;) &lt;&lt; &quot; computeCompositingRequirements (backing provider candidate &quot; &lt;&lt; backingSharingState.backingProviderCandidate() &lt;&lt; &quot;)&quot;);</span>
  
      // FIXME: maybe we can avoid updating all remaining layers in paint order.
      compositingState.fullPaintOrderTraversalRequired |= layer.needsCompositingRequirementsTraversal();
      compositingState.descendantsRequireCompositingUpdate |= layer.descendantsNeedCompositingRequirementsTraversal();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 817,15 ***</span>
      layer.setHasCompositingDescendant(false);
  
      // We updated compositing for direct reasons in layerStyleChanged(). Here, check for compositing that can only be evaluated after layout.
      RequiresCompositingData queryData;
      bool willBeComposited = layer.isComposited();
      if (layer.needsPostLayoutCompositingUpdate() || compositingState.fullPaintOrderTraversalRequired || compositingState.descendantsRequireCompositingUpdate) {
<span class="line-modified">!         layer.setIndirectCompositingReason(RenderLayer::IndirectCompositingReason::None);</span>
          willBeComposited = needsToBeComposited(layer, queryData);
      }
  
      compositingState.fullPaintOrderTraversalRequired |= layer.subsequentLayersNeedCompositingRequirementsTraversal();
  
      OverlapExtent layerExtent;
      // Use the fact that we&#39;re composited as a hint to check for an animating transform.
      // FIXME: Maybe needsToBeComposited() should return a bitmask of reasons, to avoid the need to recompute things.
<span class="line-new-header">--- 858,26 ---</span>
      layer.setHasCompositingDescendant(false);
  
      // We updated compositing for direct reasons in layerStyleChanged(). Here, check for compositing that can only be evaluated after layout.
      RequiresCompositingData queryData;
      bool willBeComposited = layer.isComposited();
<span class="line-added">+     bool becameCompositedAfterDescendantTraversal = false;</span>
<span class="line-added">+     IndirectCompositingReason compositingReason = compositingState.subtreeIsCompositing ? IndirectCompositingReason::Stacking : IndirectCompositingReason::None;</span>
<span class="line-added">+ </span>
      if (layer.needsPostLayoutCompositingUpdate() || compositingState.fullPaintOrderTraversalRequired || compositingState.descendantsRequireCompositingUpdate) {
<span class="line-modified">!         layer.setIndirectCompositingReason(IndirectCompositingReason::None);</span>
          willBeComposited = needsToBeComposited(layer, queryData);
      }
  
<span class="line-added">+     bool layerPaintsIntoProvidedBacking = false;</span>
<span class="line-added">+     if (!willBeComposited &amp;&amp; compositingState.subtreeIsCompositing &amp;&amp; backingSharingState.backingProviderCandidate() &amp;&amp; canBeComposited(layer) &amp;&amp; backingProviderLayerCanIncludeLayer(*backingSharingState.backingProviderCandidate(), layer)) {</span>
<span class="line-added">+         backingSharingState.appendSharingLayer(layer);</span>
<span class="line-added">+         LOG(Compositing, &quot; layer %p can share with %p&quot;, &amp;layer, backingSharingState.backingProviderCandidate());</span>
<span class="line-added">+         compositingReason = IndirectCompositingReason::None;</span>
<span class="line-added">+         layerPaintsIntoProvidedBacking = true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      compositingState.fullPaintOrderTraversalRequired |= layer.subsequentLayersNeedCompositingRequirementsTraversal();
  
      OverlapExtent layerExtent;
      // Use the fact that we&#39;re composited as a hint to check for an animating transform.
      // FIXME: Maybe needsToBeComposited() should return a bitmask of reasons, to avoid the need to recompute things.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 833,163 ***</span>
          layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
  
      bool respectTransforms = !layerExtent.hasTransformAnimation;
      overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer, respectTransforms);
  
<span class="line-removed">-     RenderLayer::IndirectCompositingReason compositingReason = compositingState.subtreeIsCompositing ? RenderLayer::IndirectCompositingReason::Stacking : RenderLayer::IndirectCompositingReason::None;</span>
<span class="line-removed">- </span>
      // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
<span class="line-modified">!     if (!willBeComposited &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap) {</span>
<span class="line-removed">-         computeExtent(overlapMap, layer, layerExtent);</span>
          // If we&#39;re testing for overlap, we only need to composite if we overlap something that is already composited.
<span class="line-modified">!         compositingReason = overlapMap.overlapsLayers(layerExtent.bounds) ? RenderLayer::IndirectCompositingReason::Overlap : RenderLayer::IndirectCompositingReason::None;</span>
      }
  
  #if ENABLE(VIDEO)
      // Video is special. It&#39;s the only RenderLayer type that can both have
      // RenderLayer children and whose children can&#39;t use its backing to render
      // into. These children (the controls) always need to be promoted into their
      // own layers to draw on top of the accelerated video.
      if (compositingState.compositingAncestor &amp;&amp; compositingState.compositingAncestor-&gt;renderer().isVideo())
<span class="line-modified">!         compositingReason = RenderLayer::IndirectCompositingReason::Overlap;</span>
  #endif
  
<span class="line-modified">!     if (compositingReason != RenderLayer::IndirectCompositingReason::None)</span>
          layer.setIndirectCompositingReason(compositingReason);
  
      // Check if the computed indirect reason will force the layer to become composited.
<span class="line-modified">!     if (!willBeComposited &amp;&amp; layer.mustCompositeForIndirectReasons() &amp;&amp; canBeComposited(layer))</span>
          willBeComposited = true;
  
      // The children of this layer don&#39;t need to composite, unless there is
      // a compositing layer among them, so start by inheriting the compositing
      // ancestor with subtreeIsCompositing set to false.
<span class="line-modified">!     CompositingState childState(compositingState);</span>
<span class="line-modified">!     childState.subtreeIsCompositing = false;</span>
<span class="line-removed">- #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-removed">-     childState.hasNotIsolatedCompositedBlendingDescendants = false;</span>
<span class="line-removed">- #endif</span>
  
<span class="line-modified">!     if (willBeComposited) {</span>
<span class="line-removed">-         // Tell the parent it has compositing descendants.</span>
<span class="line-removed">-         compositingState.subtreeIsCompositing = true;</span>
<span class="line-removed">-         // This layer now acts as the ancestor for kids.</span>
<span class="line-removed">-         childState.compositingAncestor = &amp;layer;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         overlapMap.pushCompositingContainer();</span>
          // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
          // animation running behind this layer, meaning they can rely on the overlap map testing again.
<span class="line-modified">!         childState.testingOverlap = true;</span>
  
          computeExtent(overlapMap, layer, layerExtent);
<span class="line-modified">!         childState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;</span>
          // Too hard to compute animated bounds if both us and some ancestor is animating transform.
          layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
      }
  
  #if !ASSERT_DISABLED
      LayerListMutationDetector mutationChecker(layer);
  #endif
  
      bool anyDescendantHas3DTransform = false;
  
      for (auto* childLayer : layer.negativeZOrderLayers()) {
<span class="line-modified">!         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);</span>
  
          // If we have to make a layer for this child, make one now so we can have a contents layer
          // (since we need to ensure that the -ve z-order child renders underneath our contents).
<span class="line-modified">!         if (!willBeComposited &amp;&amp; childState.subtreeIsCompositing) {</span>
<span class="line-modified">!             // make layer compositing</span>
<span class="line-modified">!             layer.setIndirectCompositingReason(RenderLayer::IndirectCompositingReason::BackgroundLayer);</span>
<span class="line-removed">-             childState.compositingAncestor = &amp;layer;</span>
<span class="line-removed">-             overlapMap.pushCompositingContainer();</span>
<span class="line-removed">-             // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an</span>
<span class="line-removed">-             // animation running behind this layer, meaning they can rely on the overlap map testing again</span>
<span class="line-removed">-             childState.testingOverlap = true;</span>
<span class="line-removed">-             willBeComposited = true;</span>
          }
      }
  
      for (auto* childLayer : layer.normalFlowLayers())
<span class="line-modified">!         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);</span>
  
      for (auto* childLayer : layer.positiveZOrderLayers())
<span class="line-modified">!         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);</span>
  
      // If we just entered compositing mode, the root will have become composited (as long as accelerated compositing is enabled).
      if (layer.isRenderViewLayer()) {
          if (usesCompositing() &amp;&amp; m_hasAcceleratedCompositing)
              willBeComposited = true;
      }
  
<span class="line-removed">-     // All layers (even ones that aren&#39;t being composited) need to get added to</span>
<span class="line-removed">-     // the overlap map. Layers that do not composite will draw into their</span>
<span class="line-removed">-     // compositing ancestor&#39;s backing, and so are still considered for overlap.</span>
<span class="line-removed">-     // FIXME: When layerExtent has taken animation bounds into account, we also know that the bounds</span>
<span class="line-removed">-     // include descendants, so we don&#39;t need to add them all to the overlap map.</span>
<span class="line-removed">-     if (childState.compositingAncestor &amp;&amp; !childState.compositingAncestor-&gt;isRenderViewLayer())</span>
<span class="line-removed">-         addToOverlapMap(overlapMap, layer, layerExtent);</span>
<span class="line-removed">- </span>
  #if ENABLE(CSS_COMPOSITING)
<span class="line-modified">!     layer.setHasNotIsolatedCompositedBlendingDescendants(childState.hasNotIsolatedCompositedBlendingDescendants);</span>
      ASSERT(!layer.hasNotIsolatedCompositedBlendingDescendants() || layer.hasNotIsolatedBlendingDescendants());
  #endif
      // Now check for reasons to become composited that depend on the state of descendant layers.
<span class="line-modified">!     RenderLayer::IndirectCompositingReason indirectCompositingReason;</span>
      if (!willBeComposited &amp;&amp; canBeComposited(layer)
<span class="line-modified">!         &amp;&amp; requiresCompositingForIndirectReason(layer.renderer(), childState.subtreeIsCompositing, anyDescendantHas3DTransform, indirectCompositingReason)) {</span>
          layer.setIndirectCompositingReason(indirectCompositingReason);
<span class="line-modified">!         childState.compositingAncestor = &amp;layer;</span>
<span class="line-removed">-         overlapMap.pushCompositingContainer();</span>
<span class="line-removed">-         addToOverlapMapRecursive(overlapMap, layer);</span>
<span class="line-removed">-         willBeComposited = true;</span>
      }
  
      if (layer.reflectionLayer()) {
          // FIXME: Shouldn&#39;t we call computeCompositingRequirements to handle a reflection overlapping with another renderer?
<span class="line-modified">!         layer.reflectionLayer()-&gt;setIndirectCompositingReason(willBeComposited ? RenderLayer::IndirectCompositingReason::Stacking : RenderLayer::IndirectCompositingReason::None);</span>
      }
  
<span class="line-modified">!     // Subsequent layers in the parent stacking context also need to composite.</span>
<span class="line-removed">-     compositingState.subtreeIsCompositing |= childState.subtreeIsCompositing;</span>
<span class="line-removed">-     compositingState.fullPaintOrderTraversalRequired |= childState.fullPaintOrderTraversalRequired;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Set the flag to say that this layer has compositing children.</span>
<span class="line-removed">-     layer.setHasCompositingDescendant(childState.subtreeIsCompositing);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // setHasCompositingDescendant() may have changed the answer to needsToBeComposited() when clipping, so test that again.</span>
      bool isCompositedClippingLayer = canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer);
<span class="line-modified">! </span>
<span class="line-modified">!     // Turn overlap testing off for later layers if it&#39;s already off, or if we have an animating transform.</span>
<span class="line-removed">-     // Note that if the layer clips its descendants, there&#39;s no reason to propagate the child animation to the parent layers. That&#39;s because</span>
<span class="line-removed">-     // we know for sure the animation is contained inside the clipping rectangle, which is already added to the overlap map.</span>
<span class="line-removed">-     if ((!childState.testingOverlap &amp;&amp; !isCompositedClippingLayer) || layerExtent.knownToBeHaveExtentUncertainty())</span>
<span class="line-removed">-         compositingState.testingOverlap = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (isCompositedClippingLayer) {</span>
<span class="line-removed">-         if (!willBeComposited) {</span>
<span class="line-removed">-             childState.compositingAncestor = &amp;layer;</span>
<span class="line-removed">-             overlapMap.pushCompositingContainer();</span>
<span class="line-removed">-             addToOverlapMapRecursive(overlapMap, layer);</span>
<span class="line-removed">-             willBeComposited = true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-removed">-     if ((willBeComposited &amp;&amp; layer.hasBlendMode())</span>
<span class="line-removed">-         || (layer.hasNotIsolatedCompositedBlendingDescendants() &amp;&amp; !layer.isolatesCompositedBlending()))</span>
<span class="line-removed">-         compositingState.hasNotIsolatedCompositedBlendingDescendants = true;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (childState.compositingAncestor == &amp;layer &amp;&amp; !layer.isRenderViewLayer())</span>
<span class="line-removed">-         overlapMap.popCompositingContainer();</span>
  
      // If we&#39;re back at the root, and no other layers need to be composited, and the root layer itself doesn&#39;t need
      // to be composited, then we can drop out of compositing mode altogether. However, don&#39;t drop out of compositing mode
      // if there are composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
      RequiresCompositingData rootLayerQueryData;
<span class="line-modified">!     if (layer.isRenderViewLayer() &amp;&amp; !childState.subtreeIsCompositing &amp;&amp; !requiresCompositingLayer(layer, rootLayerQueryData) &amp;&amp; !m_forceCompositingMode &amp;&amp; !needsCompositingForContentOrOverlays()) {</span>
          // Don&#39;t drop out of compositing on iOS, because we may flash. See &lt;rdar://problem/8348337&gt;.
  #if !PLATFORM(IOS_FAMILY)
          enableCompositingMode(false);
          willBeComposited = false;
  #endif
<span class="line-new-header">--- 885,156 ---</span>
          layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
  
      bool respectTransforms = !layerExtent.hasTransformAnimation;
      overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer, respectTransforms);
  
      // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
<span class="line-modified">!     if (!willBeComposited &amp;&amp; !layerPaintsIntoProvidedBacking &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap) {</span>
          // If we&#39;re testing for overlap, we only need to composite if we overlap something that is already composited.
<span class="line-modified">!         if (layerOverlaps(overlapMap, layer, layerExtent))</span>
<span class="line-added">+             compositingReason = IndirectCompositingReason::Overlap;</span>
<span class="line-added">+         else</span>
<span class="line-added">+             compositingReason = IndirectCompositingReason::None;</span>
      }
  
  #if ENABLE(VIDEO)
      // Video is special. It&#39;s the only RenderLayer type that can both have
      // RenderLayer children and whose children can&#39;t use its backing to render
      // into. These children (the controls) always need to be promoted into their
      // own layers to draw on top of the accelerated video.
      if (compositingState.compositingAncestor &amp;&amp; compositingState.compositingAncestor-&gt;renderer().isVideo())
<span class="line-modified">!         compositingReason = IndirectCompositingReason::Overlap;</span>
  #endif
  
<span class="line-modified">!     if (compositingReason != IndirectCompositingReason::None)</span>
          layer.setIndirectCompositingReason(compositingReason);
  
      // Check if the computed indirect reason will force the layer to become composited.
<span class="line-modified">!     if (!willBeComposited &amp;&amp; layer.mustCompositeForIndirectReasons() &amp;&amp; canBeComposited(layer)) {</span>
<span class="line-added">+         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; compositing for indirect reason &quot; &lt;&lt; layer.indirectCompositingReason() &lt;&lt; &quot; (was sharing: &quot; &lt;&lt; layerPaintsIntoProvidedBacking &lt;&lt; &quot;)&quot;);</span>
          willBeComposited = true;
<span class="line-added">+         layerPaintsIntoProvidedBacking = false;</span>
<span class="line-added">+     }</span>
  
      // The children of this layer don&#39;t need to composite, unless there is
      // a compositing layer among them, so start by inheriting the compositing
      // ancestor with subtreeIsCompositing set to false.
<span class="line-modified">!     CompositingState currentState = compositingState.stateForPaintOrderChildren(layer);</span>
<span class="line-modified">!     bool didPushOverlapContainer = false;</span>
  
<span class="line-modified">!     auto layerWillComposite = [&amp;] {</span>
          // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
          // animation running behind this layer, meaning they can rely on the overlap map testing again.
<span class="line-modified">!         currentState.testingOverlap = true;</span>
<span class="line-added">+         // This layer now acts as the ancestor for kids.</span>
<span class="line-added">+         currentState.compositingAncestor = &amp;layer;</span>
<span class="line-added">+         // Compositing turns off backing sharing.</span>
<span class="line-added">+         currentState.backingSharingAncestor = nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (layerPaintsIntoProvidedBacking) {</span>
<span class="line-added">+             layerPaintsIntoProvidedBacking = false;</span>
<span class="line-added">+             // layerPaintsIntoProvidedBacking was only true for layers that would otherwise composite because of overlap. If we can</span>
<span class="line-added">+             // no longer share, put this this indirect reason back on the layer so that requiresOwnBackingStore() sees it.</span>
<span class="line-added">+             layer.setIndirectCompositingReason(IndirectCompositingReason::Overlap);</span>
<span class="line-added">+             LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; was sharing now will composite&quot;);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             overlapMap.pushCompositingContainer();</span>
<span class="line-added">+             didPushOverlapContainer = true;</span>
<span class="line-added">+             LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will composite, pushed container &quot; &lt;&lt; overlapMap);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         willBeComposited = true;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto layerWillCompositePostDescendants = [&amp;] {</span>
<span class="line-added">+         layerWillComposite();</span>
<span class="line-added">+         currentState.subtreeIsCompositing = true;</span>
<span class="line-added">+         becameCompositedAfterDescendantTraversal = true;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (willBeComposited) {</span>
<span class="line-added">+         layerWillComposite();</span>
  
          computeExtent(overlapMap, layer, layerExtent);
<span class="line-modified">!         currentState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;</span>
          // Too hard to compute animated bounds if both us and some ancestor is animating transform.
          layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
<span class="line-added">+     } else if (layerPaintsIntoProvidedBacking) {</span>
<span class="line-added">+         currentState.backingSharingAncestor = &amp;layer;</span>
<span class="line-added">+         overlapMap.pushCompositingContainer();</span>
<span class="line-added">+         didPushOverlapContainer = true;</span>
<span class="line-added">+         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will share, pushed container &quot; &lt;&lt; overlapMap);</span>
      }
  
<span class="line-added">+     backingSharingState.updateBeforeDescendantTraversal(layer, willBeComposited);</span>
<span class="line-added">+ </span>
  #if !ASSERT_DISABLED
      LayerListMutationDetector mutationChecker(layer);
  #endif
  
      bool anyDescendantHas3DTransform = false;
<span class="line-added">+     bool descendantsAddedToOverlap = currentState.hasNonRootCompositedAncestor();</span>
  
      for (auto* childLayer : layer.negativeZOrderLayers()) {
<span class="line-modified">!         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);</span>
  
          // If we have to make a layer for this child, make one now so we can have a contents layer
          // (since we need to ensure that the -ve z-order child renders underneath our contents).
<span class="line-modified">!         if (!willBeComposited &amp;&amp; currentState.subtreeIsCompositing) {</span>
<span class="line-modified">!             layer.setIndirectCompositingReason(IndirectCompositingReason::BackgroundLayer);</span>
<span class="line-modified">!             layerWillComposite();</span>
          }
      }
  
      for (auto* childLayer : layer.normalFlowLayers())
<span class="line-modified">!         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);</span>
  
      for (auto* childLayer : layer.positiveZOrderLayers())
<span class="line-modified">!         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Set the flag to say that this layer has compositing children.</span>
<span class="line-added">+     layer.setHasCompositingDescendant(currentState.subtreeIsCompositing);</span>
  
      // If we just entered compositing mode, the root will have become composited (as long as accelerated compositing is enabled).
      if (layer.isRenderViewLayer()) {
          if (usesCompositing() &amp;&amp; m_hasAcceleratedCompositing)
              willBeComposited = true;
      }
  
  #if ENABLE(CSS_COMPOSITING)
<span class="line-modified">!     bool isolatedCompositedBlending = layer.isolatesCompositedBlending();</span>
<span class="line-added">+     layer.setHasNotIsolatedCompositedBlendingDescendants(currentState.hasNotIsolatedCompositedBlendingDescendants);</span>
<span class="line-added">+     if (layer.isolatesCompositedBlending() != isolatedCompositedBlending) {</span>
<span class="line-added">+         // isolatedCompositedBlending affects the result of clippedByAncestor().</span>
<span class="line-added">+         layer.setChildrenNeedCompositingGeometryUpdate();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      ASSERT(!layer.hasNotIsolatedCompositedBlendingDescendants() || layer.hasNotIsolatedBlendingDescendants());
  #endif
      // Now check for reasons to become composited that depend on the state of descendant layers.
<span class="line-modified">!     IndirectCompositingReason indirectCompositingReason;</span>
      if (!willBeComposited &amp;&amp; canBeComposited(layer)
<span class="line-modified">!         &amp;&amp; requiresCompositingForIndirectReason(layer, currentState.subtreeIsCompositing, anyDescendantHas3DTransform, layerPaintsIntoProvidedBacking, indirectCompositingReason)) {</span>
          layer.setIndirectCompositingReason(indirectCompositingReason);
<span class="line-modified">!         layerWillCompositePostDescendants();</span>
      }
  
      if (layer.reflectionLayer()) {
          // FIXME: Shouldn&#39;t we call computeCompositingRequirements to handle a reflection overlapping with another renderer?
<span class="line-modified">!         layer.reflectionLayer()-&gt;setIndirectCompositingReason(willBeComposited ? IndirectCompositingReason::Stacking : IndirectCompositingReason::None);</span>
      }
  
<span class="line-modified">!     // setHasCompositingDescendant() may have changed the answer to needsToBeComposited() when clipping, so test that now.</span>
      bool isCompositedClippingLayer = canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer);
<span class="line-modified">!     if (isCompositedClippingLayer &amp; !willBeComposited)</span>
<span class="line-modified">!         layerWillCompositePostDescendants();</span>
  
      // If we&#39;re back at the root, and no other layers need to be composited, and the root layer itself doesn&#39;t need
      // to be composited, then we can drop out of compositing mode altogether. However, don&#39;t drop out of compositing mode
      // if there are composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
      RequiresCompositingData rootLayerQueryData;
<span class="line-modified">!     if (layer.isRenderViewLayer() &amp;&amp; !currentState.subtreeIsCompositing &amp;&amp; !requiresCompositingLayer(layer, rootLayerQueryData) &amp;&amp; !m_forceCompositingMode &amp;&amp; !needsCompositingForContentOrOverlays()) {</span>
          // Don&#39;t drop out of compositing on iOS, because we may flash. See &lt;rdar://problem/8348337&gt;.
  #if !PLATFORM(IOS_FAMILY)
          enableCompositingMode(false);
          willBeComposited = false;
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1005,45 ***</span>
          layer.setChildrenNeedCompositingGeometryUpdate();
          // The composited bounds of enclosing layers depends on which descendants are composited, so they need a geometry update.
          layer.setNeedsCompositingGeometryUpdateOnAncestors();
      }
  
      if (layer.reflectionLayer() &amp;&amp; updateLayerCompositingState(*layer.reflectionLayer(), queryData, CompositingChangeRepaintNow))
          layer.setNeedsCompositingLayerConnection();
  
<span class="line-removed">-     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();</span>
<span class="line-removed">- </span>
      // FIXME: clarify needsCompositingPaintOrderChildrenUpdate. If a composited layer gets a new ancestor, it needs geometry computations.
      if (layer.needsCompositingPaintOrderChildrenUpdate()) {
          layer.setChildrenNeedCompositingGeometryUpdate();
          layer.setNeedsCompositingLayerConnection();
      }
  
<span class="line-removed">- #if ENABLE(TREE_DEBUGGING)</span>
<span class="line-removed">-     LOG(Compositing, &quot;%*p computeCompositingRequirements - willBeComposited %d&quot;, 12 + compositingState.depth * 2, &amp;layer, willBeComposited);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      layer.clearCompositingRequirementsTraversalState();
  
      overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
  }
  
  // We have to traverse unchanged layers to fill in the overlap map.
<span class="line-modified">! void RenderLayerCompositor::traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer&amp; layer, OverlapMap&amp; overlapMap, CompositingState&amp; compositingState, bool&amp; descendantHas3DTransform)</span>
  {
      ASSERT(!compositingState.fullPaintOrderTraversalRequired);
      ASSERT(!layer.hasDescendantNeedingCompositingRequirementsTraversal());
      ASSERT(!layer.needsCompositingRequirementsTraversal());
  
<span class="line-modified">! #if ENABLE(TREE_DEBUGGING)</span>
<span class="line-removed">-     LOG(Compositing, &quot;%*p traverseUnchangedSubtree&quot;, 12 + compositingState.depth * 2, &amp;layer);</span>
<span class="line-removed">- #endif</span>
  
      layer.updateDescendantDependentFlags();
      layer.updateLayerListsIfNeeded();
  
      bool layerIsComposited = layer.isComposited();
  
      OverlapExtent layerExtent;
      if (layerIsComposited &amp;&amp; !layer.isRenderViewLayer())
          layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
  
<span class="line-new-header">--- 1050,53 ---</span>
          layer.setChildrenNeedCompositingGeometryUpdate();
          // The composited bounds of enclosing layers depends on which descendants are composited, so they need a geometry update.
          layer.setNeedsCompositingGeometryUpdateOnAncestors();
      }
  
<span class="line-added">+     // Update layer state bits.</span>
      if (layer.reflectionLayer() &amp;&amp; updateLayerCompositingState(*layer.reflectionLayer(), queryData, CompositingChangeRepaintNow))
          layer.setNeedsCompositingLayerConnection();
  
      // FIXME: clarify needsCompositingPaintOrderChildrenUpdate. If a composited layer gets a new ancestor, it needs geometry computations.
      if (layer.needsCompositingPaintOrderChildrenUpdate()) {
          layer.setChildrenNeedCompositingGeometryUpdate();
          layer.setNeedsCompositingLayerConnection();
      }
  
      layer.clearCompositingRequirementsTraversalState();
  
<span class="line-added">+     // Compute state passed to the caller.</span>
<span class="line-added">+     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();</span>
<span class="line-added">+     compositingState.updateWithDescendantStateAndLayer(currentState, layer, layerExtent);</span>
<span class="line-added">+     backingSharingState.updateAfterDescendantTraversal(layer, compositingState.stackingContextAncestor);</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool layerContributesToOverlap = (currentState.compositingAncestor &amp;&amp; !currentState.compositingAncestor-&gt;isRenderViewLayer()) || currentState.backingSharingAncestor;</span>
<span class="line-added">+     updateOverlapMap(overlapMap, layer, layerExtent, didPushOverlapContainer, layerContributesToOverlap, becameCompositedAfterDescendantTraversal &amp;&amp; !descendantsAddedToOverlap);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (layer.isComposited())</span>
<span class="line-added">+         layer.backing()-&gt;updateAllowsBackingStoreDetaching(layerExtent.bounds);</span>
<span class="line-added">+ </span>
      overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
<span class="line-added">+ </span>
<span class="line-added">+     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; &quot; computeCompositingRequirements - willBeComposited &quot; &lt;&lt; willBeComposited &lt;&lt; &quot; (backing provider candidate &quot; &lt;&lt; backingSharingState.backingProviderCandidate() &lt;&lt; &quot;)&quot;);</span>
  }
  
  // We have to traverse unchanged layers to fill in the overlap map.
<span class="line-modified">! void RenderLayerCompositor::traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer&amp; layer, LayerOverlapMap&amp; overlapMap, CompositingState&amp; compositingState, BackingSharingState&amp; backingSharingState, bool&amp; descendantHas3DTransform)</span>
  {
      ASSERT(!compositingState.fullPaintOrderTraversalRequired);
      ASSERT(!layer.hasDescendantNeedingCompositingRequirementsTraversal());
      ASSERT(!layer.needsCompositingRequirementsTraversal());
  
<span class="line-modified">!     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; (layer.isNormalFlowOnly() ? &quot; n&quot; : &quot; s&quot;) &lt;&lt; &quot; traverseUnchangedSubtree&quot;);</span>
  
      layer.updateDescendantDependentFlags();
      layer.updateLayerListsIfNeeded();
  
      bool layerIsComposited = layer.isComposited();
<span class="line-added">+     bool layerPaintsIntoProvidedBacking = false;</span>
<span class="line-added">+     bool didPushOverlapContainer = false;</span>
  
      OverlapExtent layerExtent;
      if (layerIsComposited &amp;&amp; !layer.isRenderViewLayer())
          layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1052,92 ***</span>
  
      // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
      if (!layerIsComposited &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap)
          computeExtent(overlapMap, layer, layerExtent);
  
<span class="line-modified">!     CompositingState childState(compositingState);</span>
<span class="line-modified">!     childState.subtreeIsCompositing = false;</span>
<span class="line-modified">! #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-modified">!     childState.hasNotIsolatedCompositedBlendingDescendants = false;</span>
<span class="line-modified">! #endif</span>
  
<span class="line-modified">!     if (layerIsComposited) {</span>
<span class="line-removed">-         // Tell the parent it has compositing descendants.</span>
<span class="line-removed">-         compositingState.subtreeIsCompositing = true;</span>
<span class="line-removed">-         // This layer now acts as the ancestor for kids.</span>
<span class="line-removed">-         childState.compositingAncestor = &amp;layer;</span>
  
<span class="line-modified">!         overlapMap.pushCompositingContainer();</span>
          // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
          // animation running behind this layer, meaning they can rely on the overlap map testing again.
<span class="line-modified">!         childState.testingOverlap = true;</span>
  
          computeExtent(overlapMap, layer, layerExtent);
<span class="line-modified">!         childState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;</span>
          // Too hard to compute animated bounds if both us and some ancestor is animating transform.
          layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
      }
  
  #if !ASSERT_DISABLED
      LayerListMutationDetector mutationChecker(layer);
  #endif
  
      bool anyDescendantHas3DTransform = false;
  
      for (auto* childLayer : layer.negativeZOrderLayers()) {
<span class="line-modified">!         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);</span>
<span class="line-modified">!         if (childState.subtreeIsCompositing)</span>
              ASSERT(layerIsComposited);
      }
  
      for (auto* childLayer : layer.normalFlowLayers())
<span class="line-modified">!         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);</span>
  
      for (auto* childLayer : layer.positiveZOrderLayers())
<span class="line-modified">!         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // All layers (even ones that aren&#39;t being composited) need to get added to</span>
<span class="line-removed">-     // the overlap map. Layers that do not composite will draw into their</span>
<span class="line-removed">-     // compositing ancestor&#39;s backing, and so are still considered for overlap.</span>
<span class="line-removed">-     // FIXME: When layerExtent has taken animation bounds into account, we also know that the bounds</span>
<span class="line-removed">-     // include descendants, so we don&#39;t need to add them all to the overlap map.</span>
<span class="line-removed">-     if (childState.compositingAncestor &amp;&amp; !childState.compositingAncestor-&gt;isRenderViewLayer())</span>
<span class="line-removed">-         addToOverlapMap(overlapMap, layer, layerExtent);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Subsequent layers in the parent stacking context also need to composite.</span>
<span class="line-removed">-     if (childState.subtreeIsCompositing)</span>
<span class="line-removed">-         compositingState.subtreeIsCompositing = true;</span>
  
      // Set the flag to say that this layer has compositing children.
<span class="line-modified">!     ASSERT(layer.hasCompositingDescendant() == childState.subtreeIsCompositing);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     // setHasCompositingDescendant() may have changed the answer to needsToBeComposited() when clipping, so test that again.</span>
<span class="line-removed">-     bool isCompositedClippingLayer = canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer);</span>
  
<span class="line-modified">!     // Turn overlap testing off for later layers if it&#39;s already off, or if we have an animating transform.</span>
<span class="line-removed">-     // Note that if the layer clips its descendants, there&#39;s no reason to propagate the child animation to the parent layers. That&#39;s because</span>
<span class="line-removed">-     // we know for sure the animation is contained inside the clipping rectangle, which is already added to the overlap map.</span>
<span class="line-removed">-     if ((!childState.testingOverlap &amp;&amp; !isCompositedClippingLayer) || layerExtent.knownToBeHaveExtentUncertainty())</span>
<span class="line-removed">-         compositingState.testingOverlap = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (isCompositedClippingLayer)</span>
<span class="line-removed">-         ASSERT(layerIsComposited);</span>
  
<span class="line-modified">! #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-modified">!     if ((layerIsComposited &amp;&amp; layer.hasBlendMode())</span>
<span class="line-modified">!         || (layer.hasNotIsolatedCompositedBlendingDescendants() &amp;&amp; !layer.isolatesCompositedBlending()))</span>
<span class="line-removed">-         compositingState.hasNotIsolatedCompositedBlendingDescendants = true;</span>
<span class="line-removed">- #endif</span>
  
<span class="line-modified">!     if (childState.compositingAncestor == &amp;layer &amp;&amp; !layer.isRenderViewLayer())</span>
<span class="line-modified">!         overlapMap.popCompositingContainer();</span>
  
<span class="line-modified">!     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();</span>
  
      ASSERT(!layer.needsCompositingRequirementsTraversal());
<span class="line-removed">- </span>
<span class="line-removed">-     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);</span>
  }
  
  void RenderLayerCompositor::updateBackingAndHierarchy(RenderLayer&amp; layer, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childLayersOfEnclosingLayer, ScrollingTreeState&amp; scrollingTreeState, OptionSet&lt;UpdateLevel&gt; updateLevel, int depth)
  {
      layer.updateDescendantDependentFlags();
<span class="line-new-header">--- 1105,77 ---</span>
  
      // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
      if (!layerIsComposited &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap)
          computeExtent(overlapMap, layer, layerExtent);
  
<span class="line-modified">!     if (layer.paintsIntoProvidedBacking()) {</span>
<span class="line-modified">!         ASSERT(backingSharingState.backingProviderCandidate());</span>
<span class="line-modified">!         ASSERT(backingProviderLayerCanIncludeLayer(*backingSharingState.backingProviderCandidate(), layer));</span>
<span class="line-modified">!         backingSharingState.appendSharingLayer(layer);</span>
<span class="line-modified">!         layerPaintsIntoProvidedBacking = true;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     CompositingState currentState = compositingState.stateForPaintOrderChildren(layer);</span>
  
<span class="line-modified">!     if (layerIsComposited) {</span>
          // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
          // animation running behind this layer, meaning they can rely on the overlap map testing again.
<span class="line-modified">!         currentState.testingOverlap = true;</span>
<span class="line-added">+         // This layer now acts as the ancestor for kids.</span>
<span class="line-added">+         currentState.compositingAncestor = &amp;layer;</span>
<span class="line-added">+         currentState.backingSharingAncestor = nullptr;</span>
<span class="line-added">+         overlapMap.pushCompositingContainer();</span>
<span class="line-added">+         didPushOverlapContainer = true;</span>
<span class="line-added">+         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;unchangedSubtree: layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will composite, pushed container &quot; &lt;&lt; overlapMap);</span>
  
          computeExtent(overlapMap, layer, layerExtent);
<span class="line-modified">!         currentState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;</span>
          // Too hard to compute animated bounds if both us and some ancestor is animating transform.
          layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
<span class="line-added">+     } else if (layerPaintsIntoProvidedBacking) {</span>
<span class="line-added">+         overlapMap.pushCompositingContainer();</span>
<span class="line-added">+         currentState.backingSharingAncestor = &amp;layer;</span>
<span class="line-added">+         didPushOverlapContainer = true;</span>
<span class="line-added">+         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;unchangedSubtree: layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will share, pushed container &quot; &lt;&lt; overlapMap);</span>
      }
  
<span class="line-added">+     backingSharingState.updateBeforeDescendantTraversal(layer, layerIsComposited);</span>
<span class="line-added">+ </span>
  #if !ASSERT_DISABLED
      LayerListMutationDetector mutationChecker(layer);
  #endif
  
      bool anyDescendantHas3DTransform = false;
  
      for (auto* childLayer : layer.negativeZOrderLayers()) {
<span class="line-modified">!         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);</span>
<span class="line-modified">!         if (currentState.subtreeIsCompositing)</span>
              ASSERT(layerIsComposited);
      }
  
      for (auto* childLayer : layer.normalFlowLayers())
<span class="line-modified">!         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);</span>
  
      for (auto* childLayer : layer.positiveZOrderLayers())
<span class="line-modified">!         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);</span>
  
      // Set the flag to say that this layer has compositing children.
<span class="line-modified">!     ASSERT(layer.hasCompositingDescendant() == currentState.subtreeIsCompositing);</span>
<span class="line-modified">!     ASSERT_IMPLIES(canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer), layerIsComposited);</span>
  
<span class="line-modified">!     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();</span>
  
<span class="line-modified">!     ASSERT(!currentState.fullPaintOrderTraversalRequired);</span>
<span class="line-modified">!     compositingState.updateWithDescendantStateAndLayer(currentState, layer, layerExtent, true);</span>
<span class="line-modified">!     backingSharingState.updateAfterDescendantTraversal(layer, compositingState.stackingContextAncestor);</span>
  
<span class="line-modified">!     bool layerContributesToOverlap = (currentState.compositingAncestor &amp;&amp; !currentState.compositingAncestor-&gt;isRenderViewLayer()) || currentState.backingSharingAncestor;</span>
<span class="line-modified">!     updateOverlapMap(overlapMap, layer, layerExtent, didPushOverlapContainer, layerContributesToOverlap);</span>
  
<span class="line-modified">!     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);</span>
  
      ASSERT(!layer.needsCompositingRequirementsTraversal());
  }
  
  void RenderLayerCompositor::updateBackingAndHierarchy(RenderLayer&amp; layer, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childLayersOfEnclosingLayer, ScrollingTreeState&amp; scrollingTreeState, OptionSet&lt;UpdateLevel&gt; updateLevel, int depth)
  {
      layer.updateDescendantDependentFlags();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1169,14 ***</span>
  
              layerBacking-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
          }
  
          OptionSet&lt;ScrollingNodeChangeFlags&gt; scrollingNodeChanges = { ScrollingNodeChangeFlags::Layer };
<span class="line-modified">!         if (layerNeedsUpdate || layer.needsCompositingGeometryUpdate() || layer.needsScrollingTreeUpdate()) {</span>
              layerBacking-&gt;updateGeometry();
              scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
<span class="line-modified">!         }</span>
  
          if (auto* reflection = layer.reflectionLayer()) {
              if (auto* reflectionBacking = reflection-&gt;backing()) {
                  reflectionBacking-&gt;updateCompositedBounds();
                  reflectionBacking-&gt;updateGeometry();
<span class="line-new-header">--- 1207,20 ---</span>
  
              layerBacking-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
          }
  
          OptionSet&lt;ScrollingNodeChangeFlags&gt; scrollingNodeChanges = { ScrollingNodeChangeFlags::Layer };
<span class="line-modified">!         if (layerNeedsUpdate || layer.needsCompositingGeometryUpdate()) {</span>
              layerBacking-&gt;updateGeometry();
              scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
<span class="line-modified">!         } else if (layer.needsScrollingTreeUpdate())</span>
<span class="line-added">+             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // This needs to happen after any geometry update.</span>
<span class="line-added">+         // FIXME: Use separate bit for event region invalidation.</span>
<span class="line-added">+         if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate())</span>
<span class="line-added">+             layerBacking-&gt;updateEventRegion();</span>
  
          if (auto* reflection = layer.reflectionLayer()) {
              if (auto* reflectionBacking = reflection-&gt;backing()) {
                  reflectionBacking-&gt;updateCompositedBounds();
                  reflectionBacking-&gt;updateGeometry();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1187,11 ***</span>
          if (!layer.parent())
              updateRootLayerPosition();
  
          // FIXME: do based on dirty flags. Need to do this for changes of geometry, configuration and hierarchy.
          // Need to be careful to do the right thing when a scroll-coordinated layer loses a scroll-coordinated ancestor.
<span class="line-modified">!         stateForDescendants.parentNodeID = updateScrollCoordinationForLayer(layer, scrollingTreeState, layerBacking-&gt;coordinatedScrollingRoles(), scrollingNodeChanges);</span>
          stateForDescendants.nextChildIndex = 0;
  
  #if !LOG_DISABLED
          logLayerInfo(layer, &quot;updateBackingAndHierarchy&quot;, depth);
  #else
<span class="line-new-header">--- 1231,11 ---</span>
          if (!layer.parent())
              updateRootLayerPosition();
  
          // FIXME: do based on dirty flags. Need to do this for changes of geometry, configuration and hierarchy.
          // Need to be careful to do the right thing when a scroll-coordinated layer loses a scroll-coordinated ancestor.
<span class="line-modified">!         stateForDescendants.parentNodeID = updateScrollCoordinationForLayer(layer, scrollingTreeState, scrollingNodeChanges);</span>
          stateForDescendants.nextChildIndex = 0;
  
  #if !LOG_DISABLED
          logLayerInfo(layer, &quot;updateBackingAndHierarchy&quot;, depth);
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1214,11 ***</span>
  
  #if !ASSERT_DISABLED
      LayerListMutationDetector mutationChecker(layer);
  #endif
  
<span class="line-modified">!     auto appendForegroundLayerIfNecessary = [&amp;] () {</span>
          // If a negative z-order child is compositing, we get a foreground layer which needs to get parented.
          if (layer.negativeZOrderLayers().size()) {
              if (layerBacking &amp;&amp; layerBacking-&gt;foregroundLayer())
                  childList.append(*layerBacking-&gt;foregroundLayer());
          }
<span class="line-new-header">--- 1258,11 ---</span>
  
  #if !ASSERT_DISABLED
      LayerListMutationDetector mutationChecker(layer);
  #endif
  
<span class="line-modified">!     auto appendForegroundLayerIfNecessary = [&amp;] {</span>
          // If a negative z-order child is compositing, we get a foreground layer which needs to get parented.
          if (layer.negativeZOrderLayers().size()) {
              if (layerBacking &amp;&amp; layerBacking-&gt;foregroundLayer())
                  childList.append(*layerBacking-&gt;foregroundLayer());
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1322,18 ***</span>
  
      LayoutRect absoluteBounds = backing-&gt;compositedBounds();
      absoluteBounds.move(layer.offsetFromAncestor(m_renderView.layer()));
  
      StringBuilder logString;
<span class="line-modified">!     logString.append(makeString(pad(&#39; &#39;, 12 + depth * 2, hex(reinterpret_cast&lt;uintptr_t&gt;(&amp;layer))), &quot; id &quot;, backing-&gt;graphicsLayer()-&gt;primaryLayerID(), &quot; (&quot;, FormattedNumber::fixedWidth(absoluteBounds.x().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.y().toFloat(), 3), &#39;-&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxX().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxY().toFloat(), 3), &quot;) &quot;, FormattedNumber::fixedWidth(backing-&gt;backingStoreMemoryEstimate() / 1024, 2), &quot;KB&quot;));</span>
  
      if (!layer.renderer().style().hasAutoZIndex())
<span class="line-modified">!         logString.append(makeString(&quot; z-index: &quot;, layer.renderer().style().zIndex()));</span>
  
<span class="line-modified">!     logString.appendLiteral(&quot; (&quot;);</span>
<span class="line-removed">-     logString.append(logReasonsForCompositing(layer));</span>
<span class="line-removed">-     logString.appendLiteral(&quot;) &quot;);</span>
  
      if (backing-&gt;graphicsLayer()-&gt;contentsOpaque() || backing-&gt;paintsIntoCompositedAncestor() || backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
          logString.append(&#39;[&#39;);
          bool prependSpace = false;
          if (backing-&gt;graphicsLayer()-&gt;contentsOpaque()) {
<span class="line-new-header">--- 1366,16 ---</span>
  
      LayoutRect absoluteBounds = backing-&gt;compositedBounds();
      absoluteBounds.move(layer.offsetFromAncestor(m_renderView.layer()));
  
      StringBuilder logString;
<span class="line-modified">!     logString.append(pad(&#39; &#39;, 12 + depth * 2, hex(reinterpret_cast&lt;uintptr_t&gt;(&amp;layer))), &quot; id &quot;, backing-&gt;graphicsLayer()-&gt;primaryLayerID(), &quot; (&quot;, FormattedNumber::fixedWidth(absoluteBounds.x().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.y().toFloat(), 3), &#39;-&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxX().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxY().toFloat(), 3), &quot;) &quot;, FormattedNumber::fixedWidth(backing-&gt;backingStoreMemoryEstimate() / 1024, 2), &quot;KB&quot;);</span>
  
      if (!layer.renderer().style().hasAutoZIndex())
<span class="line-modified">!         logString.append(&quot; z-index: &quot;, layer.renderer().style().zIndex());</span>
  
<span class="line-modified">!     logString.append(&quot; (&quot;, logReasonsForCompositing(layer), &quot;) &quot;);</span>
  
      if (backing-&gt;graphicsLayer()-&gt;contentsOpaque() || backing-&gt;paintsIntoCompositedAncestor() || backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
          logString.append(&#39;[&#39;);
          bool prependSpace = false;
          if (backing-&gt;graphicsLayer()-&gt;contentsOpaque()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1390,10 ***</span>
<span class="line-new-header">--- 1432,24 ---</span>
  static bool styleAffectsLayerGeometry(const RenderStyle&amp; style)
  {
      return style.hasClip() || style.clipPath() || style.hasBorderRadius();
  }
  
<span class="line-added">+ static bool recompositeChangeRequiresGeometryUpdate(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return oldStyle.transform() != newStyle.transform()</span>
<span class="line-added">+         || oldStyle.transformOriginX() != newStyle.transformOriginX()</span>
<span class="line-added">+         || oldStyle.transformOriginY() != newStyle.transformOriginY()</span>
<span class="line-added">+         || oldStyle.transformOriginZ() != newStyle.transformOriginZ()</span>
<span class="line-added">+         || oldStyle.transformStyle3D() != newStyle.transformStyle3D()</span>
<span class="line-added">+         || oldStyle.perspective() != newStyle.perspective()</span>
<span class="line-added">+         || oldStyle.perspectiveOriginX() != newStyle.perspectiveOriginX()</span>
<span class="line-added">+         || oldStyle.perspectiveOriginY() != newStyle.perspectiveOriginY()</span>
<span class="line-added">+         || oldStyle.backfaceVisibility() != newStyle.backfaceVisibility()</span>
<span class="line-added">+         || !arePointingToEqualData(oldStyle.clipPath(), newStyle.clipPath());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void RenderLayerCompositor::layerStyleChanged(StyleDifference diff, RenderLayer&amp; layer, const RenderStyle* oldStyle)
  {
      if (diff == StyleDifference::Equal)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1414,23 ***</span>
      }
  
      if (queryData.reevaluateAfterLayout)
          layer.setNeedsPostLayoutCompositingUpdate();
  
<span class="line-modified">!     if (diff &gt;= StyleDifference::LayoutPositionedMovementOnly &amp;&amp; hasContentCompositingLayers()) {</span>
<span class="line-modified">!         layer.setNeedsPostLayoutCompositingUpdate();</span>
<span class="line-modified">!         layer.setNeedsCompositingGeometryUpdate();</span>
      }
  
      auto* backing = layer.backing();
      if (!backing)
          return;
  
      backing-&gt;updateConfigurationAfterStyleChange();
  
<span class="line-removed">-     const auto&amp; newStyle = layer.renderer().style();</span>
<span class="line-removed">- </span>
      if (diff &gt;= StyleDifference::Repaint) {
          // Visibility change may affect geometry of the enclosing composited layer.
          if (oldStyle &amp;&amp; oldStyle-&gt;visibility() != newStyle.visibility())
              layer.setNeedsCompositingGeometryUpdate();
  
<span class="line-new-header">--- 1470,46 ---</span>
      }
  
      if (queryData.reevaluateAfterLayout)
          layer.setNeedsPostLayoutCompositingUpdate();
  
<span class="line-modified">!     const auto&amp; newStyle = layer.renderer().style();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (hasContentCompositingLayers()) {</span>
<span class="line-added">+         if (diff &gt;= StyleDifference::LayoutPositionedMovementOnly) {</span>
<span class="line-added">+             layer.setNeedsPostLayoutCompositingUpdate();</span>
<span class="line-added">+             layer.setNeedsCompositingGeometryUpdate();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (diff &gt;= StyleDifference::Layout) {</span>
<span class="line-added">+             // FIXME: only set flags here if we know we have a composited descendant, but we might not know at this point.</span>
<span class="line-added">+             if (oldStyle &amp;&amp; clippingChanged(*oldStyle, newStyle)) {</span>
<span class="line-added">+                 if (layer.isStackingContext()) {</span>
<span class="line-added">+                     layer.setNeedsPostLayoutCompositingUpdate(); // Layer needs to become composited if it has composited descendants.</span>
<span class="line-added">+                     layer.setNeedsCompositingConfigurationUpdate(); // If already composited, layer needs to create/destroy clipping layer.</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // Descendant (in containing block order) compositing layers need to re-evaluate their clipping,</span>
<span class="line-added">+                     // but they might be siblings in z-order so go up to our stacking context.</span>
<span class="line-added">+                     if (auto* stackingContext = layer.stackingContext())</span>
<span class="line-added">+                         stackingContext-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             // These properties trigger compositing if some descendant is composited.</span>
<span class="line-added">+             if (oldStyle &amp;&amp; styleChangeMayAffectIndirectCompositingReasons(*oldStyle, newStyle))</span>
<span class="line-added">+                 layer.setNeedsPostLayoutCompositingUpdate();</span>
<span class="line-added">+ </span>
<span class="line-added">+             layer.setNeedsCompositingGeometryUpdate();</span>
<span class="line-added">+         }</span>
      }
  
      auto* backing = layer.backing();
      if (!backing)
          return;
  
      backing-&gt;updateConfigurationAfterStyleChange();
  
      if (diff &gt;= StyleDifference::Repaint) {
          // Visibility change may affect geometry of the enclosing composited layer.
          if (oldStyle &amp;&amp; oldStyle-&gt;visibility() != newStyle.visibility())
              layer.setNeedsCompositingGeometryUpdate();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1443,36 ***</span>
  
      // This is necessary to get iframe layers hooked up in response to scheduleInvalidateStyleAndLayerComposition().
      if (diff == StyleDifference::RecompositeLayer &amp;&amp; layer.isComposited() &amp;&amp; is&lt;RenderWidget&gt;(layer.renderer()))
          layer.setNeedsCompositingConfigurationUpdate();
  
<span class="line-modified">!     if (diff &gt;= StyleDifference::RecompositeLayer &amp;&amp; oldStyle) {</span>
<span class="line-modified">!         if (oldStyle-&gt;transform() != newStyle.transform()) {</span>
<span class="line-modified">!             // FIXME: transform changes really need to trigger layout. See RenderElement::adjustStyleDifference().</span>
<span class="line-removed">-             layer.setNeedsPostLayoutCompositingUpdate();</span>
<span class="line-removed">-             layer.setNeedsCompositingGeometryUpdate();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (diff &gt;= StyleDifference::Layout) {</span>
<span class="line-removed">-         // FIXME: only set flags here if we know we have a composited descendant, but we might not know at this point.</span>
<span class="line-removed">-         if (oldStyle &amp;&amp; clippingChanged(*oldStyle, newStyle)) {</span>
<span class="line-removed">-             if (layer.isStackingContext()) {</span>
<span class="line-removed">-                 layer.setNeedsPostLayoutCompositingUpdate(); // Layer needs to become composited if it has composited descendants.</span>
<span class="line-removed">-                 layer.setNeedsCompositingConfigurationUpdate(); // If already composited, layer needs to create/destroy clipping layer.</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 // Descendant (in containing block order) compositing layers need to re-evaluate their clipping,</span>
<span class="line-removed">-                 // but they might be siblings in z-order so go up to our stacking context.</span>
<span class="line-removed">-                 if (auto* stackingContext = layer.stackingContext())</span>
<span class="line-removed">-                     stackingContext-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // These properties trigger compositing if some descendant is composited.</span>
<span class="line-removed">-         if (oldStyle &amp;&amp; styleChangeMayAffectIndirectCompositingReasons(*oldStyle, newStyle))</span>
<span class="line-removed">-             layer.setNeedsPostLayoutCompositingUpdate();</span>
<span class="line-removed">- </span>
          layer.setNeedsCompositingGeometryUpdate();
      }
  }
  
  bool RenderLayerCompositor::needsCompositingUpdateForStyleChangeOnNonCompositedLayer(RenderLayer&amp; layer, const RenderStyle* oldStyle) const
<span class="line-new-header">--- 1522,13 ---</span>
  
      // This is necessary to get iframe layers hooked up in response to scheduleInvalidateStyleAndLayerComposition().
      if (diff == StyleDifference::RecompositeLayer &amp;&amp; layer.isComposited() &amp;&amp; is&lt;RenderWidget&gt;(layer.renderer()))
          layer.setNeedsCompositingConfigurationUpdate();
  
<span class="line-modified">!     if (diff &gt;= StyleDifference::RecompositeLayer &amp;&amp; oldStyle &amp;&amp; recompositeChangeRequiresGeometryUpdate(*oldStyle, newStyle)) {</span>
<span class="line-modified">!         // FIXME: transform changes really need to trigger layout. See RenderElement::adjustStyleDifference().</span>
<span class="line-modified">!         layer.setNeedsPostLayoutCompositingUpdate();</span>
          layer.setNeedsCompositingGeometryUpdate();
      }
  }
  
  bool RenderLayerCompositor::needsCompositingUpdateForStyleChangeOnNonCompositedLayer(RenderLayer&amp; layer, const RenderStyle* oldStyle) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1534,16 ***</span>
          // Need to fetch viewportConstrainedNotCompositedReason, but without doing all the work that needsToBeComposited does.
          requiresCompositingForPosition(rendererForCompositingTests(layer), layer, queryData);
      }
  
      if (backingRequired == BackingRequired::Yes) {
          enableCompositingMode();
  
          if (!layer.backing()) {
              // If we need to repaint, do so before making backing
              if (shouldRepaint == CompositingChangeRepaintNow)
<span class="line-modified">!                 repaintOnCompositingChange(layer);</span>
  
              layer.ensureBacking();
  
              if (layer.isRenderViewLayer() &amp;&amp; useCoordinatedScrollingForLayer(layer)) {
                  auto&amp; frameView = m_renderView.frameView();
<span class="line-new-header">--- 1590,18 ---</span>
          // Need to fetch viewportConstrainedNotCompositedReason, but without doing all the work that needsToBeComposited does.
          requiresCompositingForPosition(rendererForCompositingTests(layer), layer, queryData);
      }
  
      if (backingRequired == BackingRequired::Yes) {
<span class="line-added">+         layer.disconnectFromBackingProviderLayer();</span>
<span class="line-added">+ </span>
          enableCompositingMode();
  
          if (!layer.backing()) {
              // If we need to repaint, do so before making backing
              if (shouldRepaint == CompositingChangeRepaintNow)
<span class="line-modified">!                 repaintOnCompositingChange(layer); // wrong backing</span>
  
              layer.ensureBacking();
  
              if (layer.isRenderViewLayer() &amp;&amp; useCoordinatedScrollingForLayer(layer)) {
                  auto&amp; frameView = m_renderView.frameView();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1686,14 ***</span>
  {
  }
  
  void RenderLayerCompositor::layerWillBeRemoved(RenderLayer&amp; parent, RenderLayer&amp; child)
  {
<span class="line-modified">!     if (!child.isComposited() || parent.renderer().renderTreeBeingDestroyed())</span>
          return;
  
<span class="line-modified">!     repaintInCompositedAncestor(child, child.backing()-&gt;compositedBounds()); // FIXME: do via dirty bits?</span>
  
      child.setNeedsCompositingLayerConnection();
  }
  
  RenderLayer* RenderLayerCompositor::enclosingNonStackingClippingLayer(const RenderLayer&amp; layer) const
<span class="line-new-header">--- 1744,22 ---</span>
  {
  }
  
  void RenderLayerCompositor::layerWillBeRemoved(RenderLayer&amp; parent, RenderLayer&amp; child)
  {
<span class="line-modified">!     if (parent.renderer().renderTreeBeingDestroyed())</span>
          return;
  
<span class="line-modified">!     if (child.isComposited())</span>
<span class="line-added">+         repaintInCompositedAncestor(child, child.backing()-&gt;compositedBounds()); // FIXME: do via dirty bits?</span>
<span class="line-added">+     else if (child.paintsIntoProvidedBacking()) {</span>
<span class="line-added">+         auto* backingProviderLayer = child.backingProviderLayer();</span>
<span class="line-added">+         // FIXME: Optimize this repaint.</span>
<span class="line-added">+         backingProviderLayer-&gt;setBackingNeedsRepaint();</span>
<span class="line-added">+         backingProviderLayer-&gt;backing()-&gt;removeBackingSharingLayer(child);</span>
<span class="line-added">+     } else</span>
<span class="line-added">+         return;</span>
  
      child.setNeedsCompositingLayerConnection();
  }
  
  RenderLayer* RenderLayerCompositor::enclosingNonStackingClippingLayer(const RenderLayer&amp; layer) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1705,11 ***</span>
              return parent;
      }
      return nullptr;
  }
  
<span class="line-modified">! void RenderLayerCompositor::computeExtent(const OverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; extent) const</span>
  {
      if (extent.extentComputed)
          return;
  
      LayoutRect layerBounds;
<span class="line-new-header">--- 1771,11 ---</span>
              return parent;
      }
      return nullptr;
  }
  
<span class="line-modified">! void RenderLayerCompositor::computeExtent(const LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; extent) const</span>
  {
      if (extent.extentComputed)
          return;
  
      LayoutRect layerBounds;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1724,11 ***</span>
  
      // Empty rects never intersect, but we need them to for the purposes of overlap testing.
      if (extent.bounds.isEmpty())
          extent.bounds.setSize(LayoutSize(1, 1));
  
<span class="line-removed">- </span>
      RenderLayerModelObject&amp; renderer = layer.renderer();
      if (renderer.isFixedPositioned() &amp;&amp; renderer.container() == &amp;m_renderView) {
          // Because fixed elements get moved around without re-computing overlap, we have to compute an overlap
          // rect that covers all the locations that the fixed element could move to.
          // FIXME: need to handle sticky too.
<span class="line-new-header">--- 1790,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1736,53 ***</span>
      }
  
      extent.extentComputed = true;
  }
  
<span class="line-modified">! void RenderLayerCompositor::addToOverlapMap(OverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; extent)</span>
  {
      if (layer.isRenderViewLayer())
          return;
  
      computeExtent(overlapMap, layer, extent);
  
<span class="line-modified">!     LayoutRect clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;rootRenderLayer(), AbsoluteClipRects)).rect(); // FIXME: Incorrect for CSS regions.</span>
  
<span class="line-modified">!     // On iOS, pageScaleFactor() is not applied by RenderView, so we should not scale here.</span>
<span class="line-modified">!     if (!m_renderView.settings().delegatesPageScaling())</span>
<span class="line-modified">!         clipRect.scale(pageScaleFactor());</span>
<span class="line-modified">!     clipRect.intersect(extent.bounds);</span>
<span class="line-removed">-     overlapMap.add(clipRect);</span>
  }
  
<span class="line-modified">! void RenderLayerCompositor::addToOverlapMapRecursive(OverlapMap&amp; overlapMap, const RenderLayer&amp; layer, const RenderLayer* ancestorLayer)</span>
  {
      if (!canBeComposited(layer))
          return;
  
      // A null ancestorLayer is an indication that &#39;layer&#39; has already been pushed.
<span class="line-modified">!     if (ancestorLayer)</span>
          overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer);
  
<span class="line-modified">!     OverlapExtent layerExtent;</span>
<span class="line-modified">!     addToOverlapMap(overlapMap, layer, layerExtent);</span>
  
  #if !ASSERT_DISABLED
      LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
  #endif
  
<span class="line-modified">!     for (auto* renderLayer : layer.negativeZOrderLayers())</span>
<span class="line-modified">!         addToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);</span>
  
<span class="line-modified">!     for (auto* renderLayer : layer.normalFlowLayers())</span>
<span class="line-modified">!         addToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);</span>
  
<span class="line-modified">!     for (auto* renderLayer : layer.positiveZOrderLayers())</span>
<span class="line-modified">!         addToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);</span>
  
<span class="line-modified">!     if (ancestorLayer)</span>
<span class="line-modified">!         overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);</span>
  }
  
  #if ENABLE(VIDEO)
  bool RenderLayerCompositor::canAccelerateVideoRendering(RenderVideo&amp; video) const
  {
<span class="line-new-header">--- 1801,156 ---</span>
      }
  
      extent.extentComputed = true;
  }
  
<span class="line-modified">! enum class AncestorTraversal { Continue, Stop };</span>
<span class="line-added">+ </span>
<span class="line-added">+ // This is a simplified version of containing block walking that only handles absolute position.</span>
<span class="line-added">+ template &lt;typename Function&gt;</span>
<span class="line-added">+ static AncestorTraversal traverseAncestorLayers(const RenderLayer&amp; layer, Function&amp;&amp; function)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     bool containingBlockCanSkipLayers = layer.renderer().isAbsolutelyPositioned();</span>
<span class="line-added">+     RenderLayer* nextPaintOrderParent = layer.paintOrderParent();</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (const auto* ancestorLayer = layer.parent(); ancestorLayer; ancestorLayer = ancestorLayer-&gt;parent()) {</span>
<span class="line-added">+         bool inContainingBlockChain = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (containingBlockCanSkipLayers)</span>
<span class="line-added">+             inContainingBlockChain = ancestorLayer-&gt;renderer().canContainAbsolutelyPositionedObjects();</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (function(*ancestorLayer, inContainingBlockChain, ancestorLayer == nextPaintOrderParent) == AncestorTraversal::Stop)</span>
<span class="line-added">+             return AncestorTraversal::Stop;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (inContainingBlockChain)</span>
<span class="line-added">+             containingBlockCanSkipLayers = ancestorLayer-&gt;renderer().isAbsolutelyPositioned();</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (ancestorLayer == nextPaintOrderParent)</span>
<span class="line-added">+             nextPaintOrderParent = ancestorLayer-&gt;paintOrderParent();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return AncestorTraversal::Continue;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static bool createsClippingScope(const RenderLayer&amp; layer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return layer.hasCompositedScrollableOverflow();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static Vector&lt;LayerOverlapMap::LayerAndBounds&gt; enclosingClippingScopes(const RenderLayer&amp; layer, const RenderLayer&amp; rootLayer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Vector&lt;LayerOverlapMap::LayerAndBounds&gt; clippingScopes;</span>
<span class="line-added">+     clippingScopes.append({ const_cast&lt;RenderLayer&amp;&gt;(rootLayer), { } });</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!layer.hasCompositedScrollingAncestor())</span>
<span class="line-added">+         return clippingScopes;</span>
<span class="line-added">+ </span>
<span class="line-added">+     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool inContainingBlockChain, bool) {</span>
<span class="line-added">+         if (inContainingBlockChain &amp;&amp; createsClippingScope(ancestorLayer)) {</span>
<span class="line-added">+             LayoutRect clipRect;</span>
<span class="line-added">+             if (is&lt;RenderBox&gt;(ancestorLayer.renderer())) {</span>
<span class="line-added">+                 // FIXME: This is expensive. Broken with transforms.</span>
<span class="line-added">+                 LayoutPoint offsetFromRoot = ancestorLayer.convertToLayerCoords(&amp;rootLayer, { });</span>
<span class="line-added">+                 clipRect = downcast&lt;RenderBox&gt;(ancestorLayer.renderer()).overflowClipRect(offsetFromRoot);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             LayerOverlapMap::LayerAndBounds layerAndBounds { const_cast&lt;RenderLayer&amp;&gt;(ancestorLayer), clipRect };</span>
<span class="line-added">+             clippingScopes.insert(1, layerAndBounds); // Order is roots to leaves.</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return AncestorTraversal::Continue;</span>
<span class="line-added">+     });</span>
<span class="line-added">+ </span>
<span class="line-added">+     return clippingScopes;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RenderLayerCompositor::addToOverlapMap(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; extent) const</span>
  {
      if (layer.isRenderViewLayer())
          return;
  
      computeExtent(overlapMap, layer, extent);
  
<span class="line-modified">!     // FIXME: constrain the scopes (by composited stacking context ancestor I think).</span>
<span class="line-added">+     auto clippingScopes = enclosingClippingScopes(layer, rootRenderLayer());</span>
<span class="line-added">+ </span>
<span class="line-added">+     LayoutRect clipRect;</span>
<span class="line-added">+     if (layer.hasCompositedScrollingAncestor()) {</span>
<span class="line-added">+         // Compute a clip up to the composited scrolling ancestor, then convert it to absolute coordinates.</span>
<span class="line-added">+         auto&amp; scrollingScope = clippingScopes.last();</span>
<span class="line-added">+         clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;scrollingScope.layer, TemporaryClipRects, IgnoreOverlayScrollbarSize, IgnoreOverflowClip)).rect();</span>
<span class="line-added">+         if (!clipRect.isInfinite())</span>
<span class="line-added">+             clipRect.setLocation(layer.convertToLayerCoords(&amp;rootRenderLayer(), clipRect.location()));</span>
<span class="line-added">+     } else</span>
<span class="line-added">+         clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;rootRenderLayer(), AbsoluteClipRects)).rect(); // FIXME: Incorrect for CSS regions.</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto clippedBounds = extent.bounds;</span>
<span class="line-added">+     if (!clipRect.isInfinite()) {</span>
<span class="line-added">+         // On iOS, pageScaleFactor() is not applied by RenderView, so we should not scale here.</span>
<span class="line-added">+         if (!m_renderView.settings().delegatesPageScaling())</span>
<span class="line-added">+             clipRect.scale(pageScaleFactor());</span>
  
<span class="line-modified">!         clippedBounds.intersect(clipRect);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     overlapMap.add(layer, clippedBounds, clippingScopes);</span>
  }
  
<span class="line-modified">! void RenderLayerCompositor::addDescendantsToOverlapMapRecursive(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, const RenderLayer* ancestorLayer) const</span>
  {
      if (!canBeComposited(layer))
          return;
  
      // A null ancestorLayer is an indication that &#39;layer&#39; has already been pushed.
<span class="line-modified">!     if (ancestorLayer) {</span>
          overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer);
  
<span class="line-modified">!         OverlapExtent layerExtent;</span>
<span class="line-modified">!         addToOverlapMap(overlapMap, layer, layerExtent);</span>
<span class="line-added">+     }</span>
  
  #if !ASSERT_DISABLED
      LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
  #endif
  
<span class="line-modified">!     for (auto* renderLayer : layer.negativeZOrderLayers())</span>
<span class="line-modified">!         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto* renderLayer : layer.normalFlowLayers())</span>
<span class="line-added">+         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto* renderLayer : layer.positiveZOrderLayers())</span>
<span class="line-added">+         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (ancestorLayer)</span>
<span class="line-added">+         overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void RenderLayerCompositor::updateOverlapMap(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; layerExtent, bool didPushContainer, bool addLayerToOverlap, bool addDescendantsToOverlap) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (addLayerToOverlap) {</span>
<span class="line-added">+         addToOverlapMap(overlapMap, layer, layerExtent);</span>
<span class="line-added">+         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; contributes to overlap, added to map &quot; &lt;&lt; overlapMap);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (addDescendantsToOverlap) {</span>
<span class="line-added">+         // If this is the first non-root layer to composite, we need to add all the descendants we already traversed to the overlap map.</span>
<span class="line-added">+         addDescendantsToOverlapMapRecursive(overlapMap, layer);</span>
<span class="line-added">+         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; composited post descendant traversal, added recursive &quot; &lt;&lt; overlapMap);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (didPushContainer) {</span>
<span class="line-modified">!         overlapMap.popCompositingContainer();</span>
<span class="line-added">+         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; is composited or shared, popped container &quot; &lt;&lt; overlapMap);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! bool RenderLayerCompositor::layerOverlaps(const LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; layerExtent) const</span>
<span class="line-modified">! {</span>
<span class="line-added">+     computeExtent(overlapMap, layer, layerExtent);</span>
  
<span class="line-modified">!     auto clippingScopes = enclosingClippingScopes(layer, rootRenderLayer());</span>
<span class="line-modified">!     return overlapMap.overlapsLayers(layer, layerExtent.bounds, clippingScopes);</span>
  }
  
  #if ENABLE(VIDEO)
  bool RenderLayerCompositor::canAccelerateVideoRendering(RenderVideo&amp; video) const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1817,10 ***</span>
<span class="line-new-header">--- 1985,28 ---</span>
          }
  #endif
      }
  }
  
<span class="line-added">+ void RenderLayerCompositor::widgetDidChangeSize(RenderWidget&amp; widget)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!widget.hasLayer())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; layer = *widget.layer();</span>
<span class="line-added">+ </span>
<span class="line-added">+     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; widgetDidChangeSize (layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot;)&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Widget size affects answer to requiresCompositingForFrame() so we need to trigger</span>
<span class="line-added">+     // a compositing update.</span>
<span class="line-added">+     layer.setNeedsPostLayoutCompositingUpdate();</span>
<span class="line-added">+     scheduleCompositingLayerUpdate();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (layer.isComposited())</span>
<span class="line-added">+         layer.backing()-&gt;updateAfterWidgetResize();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool RenderLayerCompositor::hasCoordinatedScrolling() const
  {
      auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
      return scrollingCoordinator &amp;&amp; scrollingCoordinator-&gt;coordinatesScrollingForFrameView(m_renderView.frameView());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1831,10 ***</span>
<span class="line-new-header">--- 2017,11 ---</span>
      ASSERT(m_scrolledContentsLayer);
  
      auto&amp; frameView = m_renderView.frameView();
      IntPoint scrollPosition = frameView.scrollPosition();
  
<span class="line-added">+     // We use scroll position here because the root content layer is offset to account for scrollOrigin (see FrameView::positionForRootContentLayer).</span>
      m_scrolledContentsLayer-&gt;setPosition(FloatPoint(-scrollPosition.x(), -scrollPosition.y()));
  
      if (auto* fixedBackgroundLayer = fixedRootBackgroundLayer())
          fixedBackgroundLayer-&gt;setPosition(frameView.scrollPositionForFixedPosition());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1865,11 ***</span>
  
      // If there&#39;s a scrolling coordinator that manages scrolling for this frame view,
      // it will also manage updating the scroll layer position.
      if (hasCoordinatedScrolling()) {
          // We have to schedule a flush in order for the main TiledBacking to update its tile coverage.
<span class="line-modified">!         scheduleLayerFlushNow();</span>
          return;
      }
  
      updateScrollLayerPosition();
  }
<span class="line-new-header">--- 2052,11 ---</span>
  
      // If there&#39;s a scrolling coordinator that manages scrolling for this frame view,
      // it will also manage updating the scroll layer position.
      if (hasCoordinatedScrolling()) {
          // We have to schedule a flush in order for the main TiledBacking to update its tile coverage.
<span class="line-modified">!         scheduleLayerFlush();</span>
          return;
      }
  
      updateScrollLayerPosition();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1900,10 ***</span>
<span class="line-new-header">--- 2087,11 ---</span>
  
      if (!m_rootContentsLayer)
          return String();
  
      flushPendingLayerChanges(true);
<span class="line-added">+     page().renderingUpdateScheduler().scheduleImmediateRenderingUpdate();</span>
  
      LayerTreeAsTextBehavior layerTreeBehavior = LayerTreeAsTextBehaviorNormal;
      if (flags &amp; LayerTreeFlagsIncludeDebugInfo)
          layerTreeBehavior |= LayerTreeAsTextDebug;
      if (flags &amp; LayerTreeFlagsIncludeVisibleRects)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1916,14 ***</span>
<span class="line-new-header">--- 2104,18 ---</span>
          layerTreeBehavior |= LayerTreeAsTextIncludePaintingPhases;
      if (flags &amp; LayerTreeFlagsIncludeContentLayers)
          layerTreeBehavior |= LayerTreeAsTextIncludeContentLayers;
      if (flags &amp; LayerTreeFlagsIncludeAcceleratesDrawing)
          layerTreeBehavior |= LayerTreeAsTextIncludeAcceleratesDrawing;
<span class="line-added">+     if (flags &amp; LayerTreeFlagsIncludeClipping)</span>
<span class="line-added">+         layerTreeBehavior |= LayerTreeAsTextIncludeClipping;</span>
      if (flags &amp; LayerTreeFlagsIncludeBackingStoreAttached)
          layerTreeBehavior |= LayerTreeAsTextIncludeBackingStoreAttached;
      if (flags &amp; LayerTreeFlagsIncludeRootLayerProperties)
          layerTreeBehavior |= LayerTreeAsTextIncludeRootLayerProperties;
<span class="line-added">+     if (flags &amp; LayerTreeFlagsIncludeEventRegion)</span>
<span class="line-added">+         layerTreeBehavior |= LayerTreeAsTextIncludeEventRegion;</span>
  
      // We skip dumping the scroll and clip layers to keep layerTreeAsText output
      // similar between platforms.
      String layerTreeText = m_rootContentsLayer-&gt;layerTreeAsText(layerTreeBehavior);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2159,14 ***</span>
  enum class FullScreenDescendant { Yes, No, NotApplicable };
  static FullScreenDescendant isDescendantOfFullScreenLayer(const RenderLayer&amp; layer)
  {
      auto&amp; document = layer.renderer().document();
  
<span class="line-modified">!     if (!document.webkitIsFullScreen() || !document.fullScreenRenderer())</span>
          return FullScreenDescendant::NotApplicable;
  
<span class="line-modified">!     auto* fullScreenLayer = document.fullScreenRenderer()-&gt;layer();</span>
      if (!fullScreenLayer) {
          ASSERT_NOT_REACHED();
          return FullScreenDescendant::NotApplicable;
      }
  
<span class="line-new-header">--- 2351,14 ---</span>
  enum class FullScreenDescendant { Yes, No, NotApplicable };
  static FullScreenDescendant isDescendantOfFullScreenLayer(const RenderLayer&amp; layer)
  {
      auto&amp; document = layer.renderer().document();
  
<span class="line-modified">!     if (!document.fullscreenManager().isFullscreen() || !document.fullscreenManager().fullscreenRenderer())</span>
          return FullScreenDescendant::NotApplicable;
  
<span class="line-modified">!     auto* fullScreenLayer = document.fullscreenManager().fullscreenRenderer()-&gt;layer();</span>
      if (!fullScreenLayer) {
          ASSERT_NOT_REACHED();
          return FullScreenDescendant::NotApplicable;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2205,21 ***</span>
          || renderer.hasFilter()
          || renderer.hasBackdropFilter())
          return true;
  
      if (layer.mustCompositeForIndirectReasons()) {
<span class="line-modified">!         RenderLayer::IndirectCompositingReason reason = layer.indirectCompositingReason();</span>
<span class="line-modified">!         return reason == RenderLayer::IndirectCompositingReason::Overlap</span>
<span class="line-modified">!             || reason == RenderLayer::IndirectCompositingReason::Stacking</span>
<span class="line-modified">!             || reason == RenderLayer::IndirectCompositingReason::BackgroundLayer</span>
<span class="line-modified">!             || reason == RenderLayer::IndirectCompositingReason::GraphicalEffect</span>
<span class="line-modified">!             || reason == RenderLayer::IndirectCompositingReason::Preserve3D; // preserve-3d has to create backing store to ensure that 3d-transformed elements intersect.</span>
      }
  
      if (!ancestorCompositedBounds.contains(layerCompositedBoundsInAncestor))
          return true;
  
      return false;
  }
  
  OptionSet&lt;CompositingReason&gt; RenderLayerCompositor::reasonsForCompositing(const RenderLayer&amp; layer) const
  {
<span class="line-new-header">--- 2397,25 ---</span>
          || renderer.hasFilter()
          || renderer.hasBackdropFilter())
          return true;
  
      if (layer.mustCompositeForIndirectReasons()) {
<span class="line-modified">!         IndirectCompositingReason reason = layer.indirectCompositingReason();</span>
<span class="line-modified">!         return reason == IndirectCompositingReason::Overlap</span>
<span class="line-modified">!             || reason == IndirectCompositingReason::OverflowScrollPositioning</span>
<span class="line-modified">!             || reason == IndirectCompositingReason::Stacking</span>
<span class="line-modified">!             || reason == IndirectCompositingReason::BackgroundLayer</span>
<span class="line-modified">!             || reason == IndirectCompositingReason::GraphicalEffect</span>
<span class="line-added">+             || reason == IndirectCompositingReason::Preserve3D; // preserve-3d has to create backing store to ensure that 3d-transformed elements intersect.</span>
      }
  
      if (!ancestorCompositedBounds.contains(layerCompositedBoundsInAncestor))
          return true;
  
<span class="line-added">+     if (layer.isComposited() &amp;&amp; layer.backing()-&gt;hasBackingSharingLayers())</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+ </span>
      return false;
  }
  
  OptionSet&lt;CompositingReason&gt; RenderLayerCompositor::reasonsForCompositing(const RenderLayer&amp; layer) const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2263,25 ***</span>
  
      if (requiresCompositingForPosition(renderer, *renderer.layer(), queryData))
          reasons.add(renderer.isFixedPositioned() ? CompositingReason::PositionFixed : CompositingReason::PositionSticky);
  
      if (requiresCompositingForOverflowScrolling(*renderer.layer(), queryData))
<span class="line-modified">!         reasons.add(CompositingReason::OverflowScrollingTouch);</span>
  
      switch (renderer.layer()-&gt;indirectCompositingReason()) {
<span class="line-modified">!     case RenderLayer::IndirectCompositingReason::None:</span>
          break;
<span class="line-modified">!     case RenderLayer::IndirectCompositingReason::Stacking:</span>
          reasons.add(CompositingReason::Stacking);
          break;
<span class="line-modified">!     case RenderLayer::IndirectCompositingReason::Overlap:</span>
          reasons.add(CompositingReason::Overlap);
          break;
<span class="line-modified">!     case RenderLayer::IndirectCompositingReason::BackgroundLayer:</span>
          reasons.add(CompositingReason::NegativeZIndexChildren);
          break;
<span class="line-modified">!     case RenderLayer::IndirectCompositingReason::GraphicalEffect:</span>
          if (renderer.hasTransform())
              reasons.add(CompositingReason::TransformWithCompositedDescendants);
  
          if (renderer.isTransparent())
              reasons.add(CompositingReason::OpacityWithCompositedDescendants);
<span class="line-new-header">--- 2459,28 ---</span>
  
      if (requiresCompositingForPosition(renderer, *renderer.layer(), queryData))
          reasons.add(renderer.isFixedPositioned() ? CompositingReason::PositionFixed : CompositingReason::PositionSticky);
  
      if (requiresCompositingForOverflowScrolling(*renderer.layer(), queryData))
<span class="line-modified">!         reasons.add(CompositingReason::OverflowScrolling);</span>
  
      switch (renderer.layer()-&gt;indirectCompositingReason()) {
<span class="line-modified">!     case IndirectCompositingReason::None:</span>
          break;
<span class="line-modified">!     case IndirectCompositingReason::Stacking:</span>
          reasons.add(CompositingReason::Stacking);
          break;
<span class="line-modified">!     case IndirectCompositingReason::OverflowScrollPositioning:</span>
<span class="line-added">+         reasons.add(CompositingReason::OverflowScrollPositioning);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case IndirectCompositingReason::Overlap:</span>
          reasons.add(CompositingReason::Overlap);
          break;
<span class="line-modified">!     case IndirectCompositingReason::BackgroundLayer:</span>
          reasons.add(CompositingReason::NegativeZIndexChildren);
          break;
<span class="line-modified">!     case IndirectCompositingReason::GraphicalEffect:</span>
          if (renderer.hasTransform())
              reasons.add(CompositingReason::TransformWithCompositedDescendants);
  
          if (renderer.isTransparent())
              reasons.add(CompositingReason::OpacityWithCompositedDescendants);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2301,14 ***</span>
  
          if (layer.hasBlendMode())
              reasons.add(CompositingReason::BlendingWithCompositedDescendants);
  #endif
          break;
<span class="line-modified">!     case RenderLayer::IndirectCompositingReason::Perspective:</span>
          reasons.add(CompositingReason::Perspective);
          break;
<span class="line-modified">!     case RenderLayer::IndirectCompositingReason::Preserve3D:</span>
          reasons.add(CompositingReason::Preserve3D);
          break;
      }
  
      if (usesCompositing() &amp;&amp; renderer.layer()-&gt;isRenderViewLayer())
<span class="line-new-header">--- 2500,14 ---</span>
  
          if (layer.hasBlendMode())
              reasons.add(CompositingReason::BlendingWithCompositedDescendants);
  #endif
          break;
<span class="line-modified">!     case IndirectCompositingReason::Perspective:</span>
          reasons.add(CompositingReason::Perspective);
          break;
<span class="line-modified">!     case IndirectCompositingReason::Preserve3D:</span>
          reasons.add(CompositingReason::Preserve3D);
          break;
      }
  
      if (usesCompositing() &amp;&amp; renderer.layer()-&gt;isRenderViewLayer())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2353,12 ***</span>
          return &quot;position: fixed&quot;;
  
      if (reasons &amp; CompositingReason::PositionSticky)
          return &quot;position: sticky&quot;;
  
<span class="line-modified">!     if (reasons &amp; CompositingReason::OverflowScrollingTouch)</span>
<span class="line-modified">!         return &quot;-webkit-overflow-scrolling: touch&quot;;</span>
  
      if (reasons &amp; CompositingReason::Stacking)
          return &quot;stacking&quot;;
  
      if (reasons &amp; CompositingReason::Overlap)
<span class="line-new-header">--- 2552,12 ---</span>
          return &quot;position: fixed&quot;;
  
      if (reasons &amp; CompositingReason::PositionSticky)
          return &quot;position: sticky&quot;;
  
<span class="line-modified">!     if (reasons &amp; CompositingReason::OverflowScrolling)</span>
<span class="line-modified">!         return &quot;async overflow scrolling&quot;;</span>
  
      if (reasons &amp; CompositingReason::Stacking)
          return &quot;stacking&quot;;
  
      if (reasons &amp; CompositingReason::Overlap)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2407,18 ***</span>
  // up to the enclosing compositing ancestor. This is required because compositing layers are parented
  // according to the z-order hierarchy, yet clipping goes down the renderer hierarchy.
  // Thus, a RenderLayer can be clipped by a RenderLayer that is an ancestor in the renderer hierarchy,
  // but a sibling in the z-order hierarchy.
  // FIXME: can we do this without a tree walk?
<span class="line-modified">! bool RenderLayerCompositor::clippedByAncestor(RenderLayer&amp; layer) const</span>
  {
      ASSERT(layer.isComposited());
<span class="line-removed">-     if (!layer.parent())</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // On first pass in WK1, the root may not have become composited yet.</span>
<span class="line-removed">-     auto* compositingAncestor = layer.ancestorCompositingLayer();</span>
      if (!compositingAncestor)
          return false;
  
      // If the compositingAncestor clips, that will be taken care of by clipsCompositingDescendants(),
      // so we only care about clipping between its first child that is our ancestor (the computeClipRoot),
<span class="line-new-header">--- 2606,13 ---</span>
  // up to the enclosing compositing ancestor. This is required because compositing layers are parented
  // according to the z-order hierarchy, yet clipping goes down the renderer hierarchy.
  // Thus, a RenderLayer can be clipped by a RenderLayer that is an ancestor in the renderer hierarchy,
  // but a sibling in the z-order hierarchy.
  // FIXME: can we do this without a tree walk?
<span class="line-modified">! bool RenderLayerCompositor::clippedByAncestor(RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const</span>
  {
      ASSERT(layer.isComposited());
      if (!compositingAncestor)
          return false;
  
      // If the compositingAncestor clips, that will be taken care of by clipsCompositingDescendants(),
      // so we only care about clipping between its first child that is our ancestor (the computeClipRoot),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2443,14 ***</span>
      }
  
      return !layer.backgroundClipRect(RenderLayer::ClipRectsContext(computeClipRoot, TemporaryClipRects)).isInfinite(); // FIXME: Incorrect for CSS regions.
  }
  
  // Return true if the given layer is a stacking context and has compositing child
  // layers that it needs to clip. In this case we insert a clipping GraphicsLayer
  // into the hierarchy between this layer and its children in the z-order hierarchy.
<span class="line-modified">! bool RenderLayerCompositor::clipsCompositingDescendants(const RenderLayer&amp; layer) const</span>
  {
      return layer.hasCompositingDescendant() &amp;&amp; layer.renderer().hasClipOrOverflowClip() &amp;&amp; !layer.isolatesCompositedBlending();
  }
  
  bool RenderLayerCompositor::requiresCompositingForAnimation(RenderLayerModelObject&amp; renderer) const
<span class="line-new-header">--- 2637,113 ---</span>
      }
  
      return !layer.backgroundClipRect(RenderLayer::ClipRectsContext(computeClipRoot, TemporaryClipRects)).isInfinite(); // FIXME: Incorrect for CSS regions.
  }
  
<span class="line-added">+ bool RenderLayerCompositor::updateAncestorClippingStack(const RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(layer.isComposited());</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto clippingStack = computeAncestorClippingStack(layer, compositingAncestor);</span>
<span class="line-added">+     return layer.backing()-&gt;updateAncestorClippingStack(WTFMove(clippingStack));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Vector&lt;CompositedClipData&gt; RenderLayerCompositor::computeAncestorClippingStack(const RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // On first pass in WK1, the root may not have become composited yet.</span>
<span class="line-added">+     if (!compositingAncestor)</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+ </span>
<span class="line-added">+     // We&#39;ll start by building a child-to-ancestors stack.</span>
<span class="line-added">+     Vector&lt;CompositedClipData&gt; newStack;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Walk up the containing block chain to composited ancestor, prepending an entry to the clip stack for:</span>
<span class="line-added">+     // * each composited scrolling layer</span>
<span class="line-added">+     // * each set of RenderLayers which contribute a clip.</span>
<span class="line-added">+     bool haveNonScrollableClippingIntermediateLayer = false;</span>
<span class="line-added">+     const RenderLayer* currentClippedLayer = &amp;layer;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto pushNonScrollableClip = [&amp;](const RenderLayer&amp; clippedLayer, const RenderLayer&amp; clippingRoot, ShouldRespectOverflowClip respectClip = IgnoreOverflowClip) {</span>
<span class="line-added">+         // Pass IgnoreOverflowClip to ignore overflow contributed by clippingRoot (which may be a scroller).</span>
<span class="line-added">+         auto clipRect = clippedLayer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;clippingRoot, TemporaryClipRects, IgnoreOverlayScrollbarSize, respectClip)).rect();</span>
<span class="line-added">+         auto offset = layer.convertToLayerCoords(&amp;clippingRoot, { }, RenderLayer::AdjustForColumns);</span>
<span class="line-added">+         clipRect.moveBy(-offset);</span>
<span class="line-added">+ </span>
<span class="line-added">+         CompositedClipData clipData { const_cast&lt;RenderLayer*&gt;(&amp;clippedLayer), clipRect, false };</span>
<span class="line-added">+         newStack.insert(0, WTFMove(clipData));</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool isContainingBlockChain, bool /*isPaintOrderAncestor*/) {</span>
<span class="line-added">+         if (&amp;ancestorLayer == compositingAncestor) {</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (haveNonScrollableClippingIntermediateLayer)</span>
<span class="line-added">+                 pushNonScrollableClip(*currentClippedLayer, ancestorLayer, ancestorLayer.isolatesCompositedBlending() ? RespectOverflowClip : IgnoreOverflowClip);</span>
<span class="line-added">+             else if (ancestorLayer.isolatesCompositedBlending() &amp;&amp; newStack.isEmpty())</span>
<span class="line-added">+                 pushNonScrollableClip(*currentClippedLayer, ancestorLayer, RespectOverflowClip);</span>
<span class="line-added">+ </span>
<span class="line-added">+             return AncestorTraversal::Stop;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (isContainingBlockChain &amp;&amp; ancestorLayer.renderer().hasClipOrOverflowClip()) {</span>
<span class="line-added">+             if (ancestorLayer.hasCompositedScrollableOverflow()) {</span>
<span class="line-added">+                 if (haveNonScrollableClippingIntermediateLayer) {</span>
<span class="line-added">+                     pushNonScrollableClip(*currentClippedLayer, ancestorLayer);</span>
<span class="line-added">+                     haveNonScrollableClippingIntermediateLayer = false;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 auto clipRect = parentRelativeScrollableRect(ancestorLayer, &amp;ancestorLayer);</span>
<span class="line-added">+                 auto offset = layer.convertToLayerCoords(&amp;ancestorLayer, { }, RenderLayer::AdjustForColumns);</span>
<span class="line-added">+                 clipRect.moveBy(-offset);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 CompositedClipData clipData { const_cast&lt;RenderLayer*&gt;(&amp;ancestorLayer), clipRect, true };</span>
<span class="line-added">+                 newStack.insert(0, WTFMove(clipData));</span>
<span class="line-added">+                 currentClippedLayer = &amp;ancestorLayer;</span>
<span class="line-added">+             } else</span>
<span class="line-added">+                 haveNonScrollableClippingIntermediateLayer = true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return AncestorTraversal::Continue;</span>
<span class="line-added">+     });</span>
<span class="line-added">+ </span>
<span class="line-added">+     return newStack;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Note that this returns the ScrollingNodeID of the scroller this layer is embedded in, not the layer&#39;s own ScrollingNodeID if it has one.</span>
<span class="line-added">+ ScrollingNodeID RenderLayerCompositor::asyncScrollableContainerNodeID(const RenderObject&amp; renderer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* enclosingLayer = renderer.enclosingLayer();</span>
<span class="line-added">+     if (!enclosingLayer)</span>
<span class="line-added">+         return 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto layerScrollingNodeID = [](const RenderLayer&amp; layer) -&gt; ScrollingNodeID {</span>
<span class="line-added">+         if (layer.isComposited())</span>
<span class="line-added">+             return layer.backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);</span>
<span class="line-added">+         return 0;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     // If the renderer is inside the layer, we care about the layer&#39;s scrollability. Otherwise, we let traverseAncestorLayers look at ancestors.</span>
<span class="line-added">+     if (!renderer.hasLayer()) {</span>
<span class="line-added">+         if (auto scrollingNodeID = layerScrollingNodeID(*enclosingLayer))</span>
<span class="line-added">+             return scrollingNodeID;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ScrollingNodeID containerScrollingNodeID = 0;</span>
<span class="line-added">+     traverseAncestorLayers(*enclosingLayer, [&amp;](const RenderLayer&amp; ancestorLayer, bool isContainingBlockChain, bool /*isPaintOrderAncestor*/) {</span>
<span class="line-added">+         if (isContainingBlockChain &amp;&amp; ancestorLayer.hasCompositedScrollableOverflow()) {</span>
<span class="line-added">+             containerScrollingNodeID = layerScrollingNodeID(ancestorLayer);</span>
<span class="line-added">+             return AncestorTraversal::Stop;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return AncestorTraversal::Continue;</span>
<span class="line-added">+     });</span>
<span class="line-added">+ </span>
<span class="line-added">+     return containerScrollingNodeID;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Return true if the given layer is a stacking context and has compositing child
  // layers that it needs to clip. In this case we insert a clipping GraphicsLayer
  // into the hierarchy between this layer and its children in the z-order hierarchy.
<span class="line-modified">! bool RenderLayerCompositor::clipsCompositingDescendants(const RenderLayer&amp; layer)</span>
  {
      return layer.hasCompositingDescendant() &amp;&amp; layer.renderer().hasClipOrOverflowClip() &amp;&amp; !layer.isolatesCompositedBlending();
  }
  
  bool RenderLayerCompositor::requiresCompositingForAnimation(RenderLayerModelObject&amp; renderer) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2685,11 ***</span>
      if (isDescendantOfFullScreenLayer(layer) == FullScreenDescendant::No)
          return false;
  #endif
  
      auto position = renderer.style().position();
<span class="line-modified">!     bool isFixed = renderer.isOutOfFlowPositioned() &amp;&amp; position == PositionType::Fixed;</span>
      if (isFixed &amp;&amp; !layer.isStackingContext())
          return false;
  
      bool isSticky = renderer.isInFlowPositioned() &amp;&amp; position == PositionType::Sticky;
      if (!isFixed &amp;&amp; !isSticky)
<span class="line-new-header">--- 2978,11 ---</span>
      if (isDescendantOfFullScreenLayer(layer) == FullScreenDescendant::No)
          return false;
  #endif
  
      auto position = renderer.style().position();
<span class="line-modified">!     bool isFixed = renderer.isFixedPositioned();</span>
      if (isFixed &amp;&amp; !layer.isStackingContext())
          return false;
  
      bool isSticky = renderer.isInFlowPositioned() &amp;&amp; position == PositionType::Sticky;
      if (!isFixed &amp;&amp; !isSticky)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2709,11 ***</span>
  
      auto container = renderer.container();
      ASSERT(container);
  
      // Don&#39;t promote fixed position elements that are descendants of a non-view container, e.g. transformed elements.
<span class="line-modified">!     // They will stay fixed wrt the container rather than the enclosing frame.j</span>
      if (container != &amp;m_renderView) {
          queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForNonViewContainer;
          return false;
      }
  
<span class="line-new-header">--- 3002,11 ---</span>
  
      auto container = renderer.container();
      ASSERT(container);
  
      // Don&#39;t promote fixed position elements that are descendants of a non-view container, e.g. transformed elements.
<span class="line-modified">!     // They will stay fixed wrt the container rather than the enclosing frame.</span>
      if (container != &amp;m_renderView) {
          queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForNonViewContainer;
          return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2745,36 ***</span>
  
      return layer.hasCompositedScrollableOverflow();
  }
  
  // FIXME: why doesn&#39;t this handle the clipping cases?
<span class="line-modified">! bool RenderLayerCompositor::requiresCompositingForIndirectReason(RenderLayerModelObject&amp; renderer, bool hasCompositedDescendants, bool has3DTransformedDescendants, RenderLayer::IndirectCompositingReason&amp; reason) const</span>
  {
<span class="line-removed">-     auto&amp; layer = *downcast&lt;RenderBoxModelObject&gt;(renderer).layer();</span>
<span class="line-removed">- </span>
      // When a layer has composited descendants, some effects, like 2d transforms, filters, masks etc must be implemented
      // via compositing so that they also apply to those composited descendants.
      if (hasCompositedDescendants &amp;&amp; (layer.isolatesCompositedBlending() || layer.transform() || renderer.createsGroup() || renderer.hasReflection())) {
<span class="line-modified">!         reason = RenderLayer::IndirectCompositingReason::GraphicalEffect;</span>
          return true;
      }
  
      // A layer with preserve-3d or perspective only needs to be composited if there are descendant layers that
      // will be affected by the preserve-3d or perspective.
      if (has3DTransformedDescendants) {
          if (renderer.style().transformStyle3D() == TransformStyle3D::Preserve3D) {
<span class="line-modified">!             reason = RenderLayer::IndirectCompositingReason::Preserve3D;</span>
              return true;
          }
  
          if (renderer.style().hasPerspective()) {
<span class="line-modified">!             reason = RenderLayer::IndirectCompositingReason::Perspective;</span>
              return true;
          }
      }
  
<span class="line-modified">!     reason = RenderLayer::IndirectCompositingReason::None;</span>
      return false;
  }
  
  bool RenderLayerCompositor::styleChangeMayAffectIndirectCompositingReasons(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
  {
<span class="line-new-header">--- 3038,44 ---</span>
  
      return layer.hasCompositedScrollableOverflow();
  }
  
  // FIXME: why doesn&#39;t this handle the clipping cases?
<span class="line-modified">! bool RenderLayerCompositor::requiresCompositingForIndirectReason(const RenderLayer&amp; layer, bool hasCompositedDescendants, bool has3DTransformedDescendants, bool paintsIntoProvidedBacking, IndirectCompositingReason&amp; reason) const</span>
  {
      // When a layer has composited descendants, some effects, like 2d transforms, filters, masks etc must be implemented
      // via compositing so that they also apply to those composited descendants.
<span class="line-added">+     auto&amp; renderer = layer.renderer();</span>
      if (hasCompositedDescendants &amp;&amp; (layer.isolatesCompositedBlending() || layer.transform() || renderer.createsGroup() || renderer.hasReflection())) {
<span class="line-modified">!         reason = IndirectCompositingReason::GraphicalEffect;</span>
          return true;
      }
  
      // A layer with preserve-3d or perspective only needs to be composited if there are descendant layers that
      // will be affected by the preserve-3d or perspective.
      if (has3DTransformedDescendants) {
          if (renderer.style().transformStyle3D() == TransformStyle3D::Preserve3D) {
<span class="line-modified">!             reason = IndirectCompositingReason::Preserve3D;</span>
              return true;
          }
  
          if (renderer.style().hasPerspective()) {
<span class="line-modified">!             reason = IndirectCompositingReason::Perspective;</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // If this layer scrolls independently from the layer that it would paint into, it needs to get composited.</span>
<span class="line-added">+     if (!paintsIntoProvidedBacking &amp;&amp; layer.hasCompositedScrollingAncestor()) {</span>
<span class="line-added">+         auto* paintDestination = layer.paintOrderParent();</span>
<span class="line-added">+         if (paintDestination &amp;&amp; layerScrollBehahaviorRelativeToCompositedAncestor(layer, *paintDestination) != ScrollPositioningBehavior::None) {</span>
<span class="line-added">+             reason = IndirectCompositingReason::OverflowScrollPositioning;</span>
              return true;
          }
      }
  
<span class="line-modified">!     reason = IndirectCompositingReason::None;</span>
      return false;
  }
  
  bool RenderLayerCompositor::styleChangeMayAffectIndirectCompositingReasons(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2798,19 ***</span>
  {
      ASSERT(layer.renderer().isStickilyPositioned());
  
      auto* enclosingOverflowLayer = layer.enclosingOverflowClipLayer(ExcludeSelf);
  
<span class="line-removed">- #if PLATFORM(IOS_FAMILY)</span>
      if (enclosingOverflowLayer &amp;&amp; enclosingOverflowLayer-&gt;hasCompositedScrollableOverflow()) {
          if (enclosingAcceleratedOverflowLayer)
              *enclosingAcceleratedOverflowLayer = enclosingOverflowLayer;
          return true;
      }
<span class="line-modified">! #else</span>
<span class="line-removed">-     UNUSED_PARAM(enclosingAcceleratedOverflowLayer);</span>
<span class="line-removed">- #endif</span>
      // If the layer is inside normal overflow, it&#39;s not async-scrollable.
      if (enclosingOverflowLayer)
          return false;
  
      // No overflow ancestor, so see if the frame supports async scrolling.
<span class="line-new-header">--- 3099,16 ---</span>
  {
      ASSERT(layer.renderer().isStickilyPositioned());
  
      auto* enclosingOverflowLayer = layer.enclosingOverflowClipLayer(ExcludeSelf);
  
      if (enclosingOverflowLayer &amp;&amp; enclosingOverflowLayer-&gt;hasCompositedScrollableOverflow()) {
          if (enclosingAcceleratedOverflowLayer)
              *enclosingAcceleratedOverflowLayer = enclosingOverflowLayer;
          return true;
      }
<span class="line-modified">! </span>
      // If the layer is inside normal overflow, it&#39;s not async-scrollable.
      if (enclosingOverflowLayer)
          return false;
  
      // No overflow ancestor, so see if the frame supports async scrolling.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2828,25 ***</span>
  bool RenderLayerCompositor::isViewportConstrainedFixedOrStickyLayer(const RenderLayer&amp; layer) const
  {
      if (layer.renderer().isStickilyPositioned())
          return isAsyncScrollableStickyLayer(layer);
  
<span class="line-modified">!     if (layer.renderer().style().position() != PositionType::Fixed)</span>
          return false;
  
      // FIXME: Handle fixed inside of a transform, which should not behave as fixed.
<span class="line-modified">!     for (auto* stackingContext = layer.stackingContext(); stackingContext; stackingContext = stackingContext-&gt;stackingContext()) {</span>
<span class="line-modified">!         if (stackingContext-&gt;isComposited() &amp;&amp; stackingContext-&gt;renderer().isFixedPositioned())</span>
              return false;
      }
  
      return true;
  }
  
  bool RenderLayerCompositor::fixedLayerIntersectsViewport(const RenderLayer&amp; layer) const
  {
<span class="line-modified">!     ASSERT(layer.renderer().style().position() == PositionType::Fixed);</span>
  
      // Fixed position elements that are invisible in the current view don&#39;t get their own layer.
      // FIXME: We shouldn&#39;t have to check useFixedLayout() here; one of the viewport rects needs to give the correct answer.
      LayoutRect viewBounds;
      if (m_renderView.frameView().useFixedLayout())
<span class="line-new-header">--- 3126,27 ---</span>
  bool RenderLayerCompositor::isViewportConstrainedFixedOrStickyLayer(const RenderLayer&amp; layer) const
  {
      if (layer.renderer().isStickilyPositioned())
          return isAsyncScrollableStickyLayer(layer);
  
<span class="line-modified">!     if (!layer.renderer().isFixedPositioned())</span>
          return false;
  
      // FIXME: Handle fixed inside of a transform, which should not behave as fixed.
<span class="line-modified">!     for (auto* ancestor = layer.parent(); ancestor; ancestor = ancestor-&gt;parent()) {</span>
<span class="line-modified">!         if (ancestor-&gt;hasCompositedScrollableOverflow())</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         if (ancestor-&gt;isStackingContext() &amp;&amp; ancestor-&gt;isComposited() &amp;&amp; ancestor-&gt;renderer().isFixedPositioned())</span>
              return false;
      }
  
      return true;
  }
  
  bool RenderLayerCompositor::fixedLayerIntersectsViewport(const RenderLayer&amp; layer) const
  {
<span class="line-modified">!     ASSERT(layer.renderer().isFixedPositioned());</span>
  
      // Fixed position elements that are invisible in the current view don&#39;t get their own layer.
      // FIXME: We shouldn&#39;t have to check useFixedLayout() here; one of the viewport rects needs to give the correct answer.
      LayoutRect viewBounds;
      if (m_renderView.frameView().useFixedLayout())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2870,10 ***</span>
<span class="line-new-header">--- 3170,132 ---</span>
          return scrollingCoordinator-&gt;coordinatesScrollingForOverflowLayer(layer);
  
      return false;
  }
  
<span class="line-added">+ static bool isScrolledByOverflowScrollLayer(const RenderLayer&amp; layer, const RenderLayer&amp; overflowScrollLayer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     bool scrolledByOverflowScroll = false;</span>
<span class="line-added">+     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool inContainingBlockChain, bool) {</span>
<span class="line-added">+         if (&amp;ancestorLayer == &amp;overflowScrollLayer) {</span>
<span class="line-added">+             scrolledByOverflowScroll = inContainingBlockChain;</span>
<span class="line-added">+             return AncestorTraversal::Stop;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return AncestorTraversal::Continue;</span>
<span class="line-added">+     });</span>
<span class="line-added">+     return scrolledByOverflowScroll;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static RenderLayer* enclosingCompositedScrollingLayer(const RenderLayer&amp; layer, const RenderLayer&amp; intermediateLayer, bool&amp; sawIntermediateLayer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     const auto* ancestorLayer = layer.parent();</span>
<span class="line-added">+     while (ancestorLayer) {</span>
<span class="line-added">+         if (ancestorLayer == &amp;intermediateLayer)</span>
<span class="line-added">+             sawIntermediateLayer = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (ancestorLayer-&gt;hasCompositedScrollableOverflow())</span>
<span class="line-added">+             return const_cast&lt;RenderLayer*&gt;(ancestorLayer);</span>
<span class="line-added">+ </span>
<span class="line-added">+         ancestorLayer = ancestorLayer-&gt;parent();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ScrollPositioningBehavior RenderLayerCompositor::layerScrollBehahaviorRelativeToCompositedAncestor(const RenderLayer&amp; layer, const RenderLayer&amp; compositedAncestor)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!layer.hasCompositedScrollingAncestor())</span>
<span class="line-added">+         return ScrollPositioningBehavior::None;</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool compositedAncestorIsInsideScroller = false;</span>
<span class="line-added">+     auto* scrollingAncestor = enclosingCompositedScrollingLayer(layer, compositedAncestor, compositedAncestorIsInsideScroller);</span>
<span class="line-added">+     if (!scrollingAncestor) {</span>
<span class="line-added">+         ASSERT_NOT_REACHED(); // layer.hasCompositedScrollingAncestor() should guarantee we have one.</span>
<span class="line-added">+         return ScrollPositioningBehavior::None;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool ancestorMovedByScroller = &amp;compositedAncestor == scrollingAncestor || (compositedAncestorIsInsideScroller &amp;&amp; isScrolledByOverflowScrollLayer(compositedAncestor, *scrollingAncestor));</span>
<span class="line-added">+     bool layerMovedByScroller = isScrolledByOverflowScrollLayer(layer, *scrollingAncestor);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (ancestorMovedByScroller == layerMovedByScroller)</span>
<span class="line-added">+         return ScrollPositioningBehavior::None;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return layerMovedByScroller ? ScrollPositioningBehavior::Moves : ScrollPositioningBehavior::Stationary;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void collectStationaryLayerRelatedOverflowNodes(const RenderLayer&amp; layer, const RenderLayer&amp;, Vector&lt;ScrollingNodeID&gt;&amp; scrollingNodes)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(layer.isComposited());</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto appendOverflowLayerNodeID = [&amp;scrollingNodes] (const RenderLayer&amp; overflowLayer) {</span>
<span class="line-added">+         ASSERT(overflowLayer.isComposited());</span>
<span class="line-added">+         auto scrollingNodeID = overflowLayer.backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);</span>
<span class="line-added">+         if (scrollingNodeID)</span>
<span class="line-added">+             scrollingNodes.append(scrollingNodeID);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             LOG(Scrolling, &quot;Layer %p doesn&#39;t have scrolling node ID yet&quot;, &amp;overflowLayer);</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Collect all the composited scrollers which affect the position of this layer relative to its compositing ancestor (which might be inside the scroller or the scroller itself).</span>
<span class="line-added">+     bool seenPaintOrderAncestor = false;</span>
<span class="line-added">+     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool isContainingBlockChain, bool isPaintOrderAncestor) {</span>
<span class="line-added">+         seenPaintOrderAncestor |= isPaintOrderAncestor;</span>
<span class="line-added">+         if (isContainingBlockChain &amp;&amp; isPaintOrderAncestor)</span>
<span class="line-added">+             return AncestorTraversal::Stop;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (seenPaintOrderAncestor &amp;&amp; !isContainingBlockChain &amp;&amp; ancestorLayer.hasCompositedScrollableOverflow())</span>
<span class="line-added">+             appendOverflowLayerNodeID(ancestorLayer);</span>
<span class="line-added">+ </span>
<span class="line-added">+         return AncestorTraversal::Continue;</span>
<span class="line-added">+     });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ScrollPositioningBehavior RenderLayerCompositor::computeCoordinatedPositioningForLayer(const RenderLayer&amp; layer) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (layer.isRenderViewLayer())</span>
<span class="line-added">+         return ScrollPositioningBehavior::None;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (layer.renderer().isFixedPositioned())</span>
<span class="line-added">+         return ScrollPositioningBehavior::None;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!layer.hasCompositedScrollingAncestor())</span>
<span class="line-added">+         return ScrollPositioningBehavior::None;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();</span>
<span class="line-added">+     if (!scrollingCoordinator)</span>
<span class="line-added">+         return ScrollPositioningBehavior::None;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* compositedAncestor = layer.ancestorCompositingLayer();</span>
<span class="line-added">+     if (!compositedAncestor) {</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return ScrollPositioningBehavior::None;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return layerScrollBehahaviorRelativeToCompositedAncestor(layer, *compositedAncestor);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static Vector&lt;ScrollingNodeID&gt; collectRelatedCoordinatedScrollingNodes(const RenderLayer&amp; layer, ScrollPositioningBehavior positioningBehavior)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Vector&lt;ScrollingNodeID&gt; overflowNodeIDs;</span>
<span class="line-added">+ </span>
<span class="line-added">+     switch (positioningBehavior) {</span>
<span class="line-added">+     case ScrollPositioningBehavior::Stationary: {</span>
<span class="line-added">+         auto* compositedAncestor = layer.ancestorCompositingLayer();</span>
<span class="line-added">+         if (!compositedAncestor)</span>
<span class="line-added">+             return overflowNodeIDs;</span>
<span class="line-added">+         collectStationaryLayerRelatedOverflowNodes(layer, *compositedAncestor, overflowNodeIDs);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case ScrollPositioningBehavior::Moves:</span>
<span class="line-added">+     case ScrollPositioningBehavior::None:</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return overflowNodeIDs;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool RenderLayerCompositor::isLayerForIFrameWithScrollCoordinatedContents(const RenderLayer&amp; layer) const
  {
      if (!is&lt;RenderWidget&gt;(layer.renderer()))
          return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2904,15 ***</span>
          return false;
      }
      return renderer.animation().isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
  }
  
<span class="line-modified">! // If an element has negative z-index children, those children render in front of the</span>
  // layer background, so we need an extra &#39;contents&#39; layer for the foreground of the layer object.
  bool RenderLayerCompositor::needsContentsCompositingLayer(const RenderLayer&amp; layer) const
  {
<span class="line-modified">!     return layer.hasNegativeZOrderLayers();</span>
  }
  
  bool RenderLayerCompositor::requiresScrollLayer(RootLayerAttachment attachment) const
  {
      auto&amp; frameView = m_renderView.frameView();
<span class="line-new-header">--- 3326,20 ---</span>
          return false;
      }
      return renderer.animation().isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
  }
  
<span class="line-modified">! // If an element has composited negative z-index children, those children render in front of the</span>
  // layer background, so we need an extra &#39;contents&#39; layer for the foreground of the layer object.
  bool RenderLayerCompositor::needsContentsCompositingLayer(const RenderLayer&amp; layer) const
  {
<span class="line-modified">!     for (auto* layer : layer.negativeZOrderLayers()) {</span>
<span class="line-added">+         if (layer-&gt;isComposited() || layer-&gt;hasCompositingDescendant())</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return false;</span>
  }
  
  bool RenderLayerCompositor::requiresScrollLayer(RootLayerAttachment attachment) const
  {
      auto&amp; frameView = m_renderView.frameView();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2938,11 ***</span>
      transformedClip.moveBy(scrollbarRect.location());
      scrollbar-&gt;paint(context, transformedClip);
      context.restore();
  }
  
<span class="line-modified">! void RenderLayerCompositor::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, GraphicsLayerPaintingPhase, const FloatRect&amp; clip, GraphicsLayerPaintBehavior)</span>
  {
  #if PLATFORM(MAC)
      LocalDefaultSystemAppearance localAppearance(m_renderView.useDarkAppearance());
  #endif
  
<span class="line-new-header">--- 3365,11 ---</span>
      transformedClip.moveBy(scrollbarRect.location());
      scrollbar-&gt;paint(context, transformedClip);
      context.restore();
  }
  
<span class="line-modified">! void RenderLayerCompositor::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, OptionSet&lt;GraphicsLayerPaintingPhase&gt;, const FloatRect&amp; clip, GraphicsLayerPaintBehavior)</span>
  {
  #if PLATFORM(MAC)
      LocalDefaultSystemAppearance localAppearance(m_renderView.useDarkAppearance());
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3363,11 ***</span>
  #endif
  
      if (requiresHorizontalScrollbarLayer()) {
          if (!m_layerForHorizontalScrollbar) {
              m_layerForHorizontalScrollbar = GraphicsLayer::create(graphicsLayerFactory(), *this);
<span class="line-modified">!             m_layerForHorizontalScrollbar-&gt;setCanDetachBackingStore(false);</span>
              m_layerForHorizontalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
              m_layerForHorizontalScrollbar-&gt;setName(&quot;horizontal scrollbar container&quot;);
  #if PLATFORM(COCOA) &amp;&amp; USE(CA)
              m_layerForHorizontalScrollbar-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
  #endif
<span class="line-new-header">--- 3790,11 ---</span>
  #endif
  
      if (requiresHorizontalScrollbarLayer()) {
          if (!m_layerForHorizontalScrollbar) {
              m_layerForHorizontalScrollbar = GraphicsLayer::create(graphicsLayerFactory(), *this);
<span class="line-modified">!             m_layerForHorizontalScrollbar-&gt;setAllowsBackingStoreDetaching(false);</span>
              m_layerForHorizontalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
              m_layerForHorizontalScrollbar-&gt;setName(&quot;horizontal scrollbar container&quot;);
  #if PLATFORM(COCOA) &amp;&amp; USE(CA)
              m_layerForHorizontalScrollbar-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3384,11 ***</span>
      }
  
      if (requiresVerticalScrollbarLayer()) {
          if (!m_layerForVerticalScrollbar) {
              m_layerForVerticalScrollbar = GraphicsLayer::create(graphicsLayerFactory(), *this);
<span class="line-modified">!             m_layerForVerticalScrollbar-&gt;setCanDetachBackingStore(false);</span>
              m_layerForVerticalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
              m_layerForVerticalScrollbar-&gt;setName(&quot;vertical scrollbar container&quot;);
  #if PLATFORM(COCOA) &amp;&amp; USE(CA)
              m_layerForVerticalScrollbar-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
  #endif
<span class="line-new-header">--- 3811,11 ---</span>
      }
  
      if (requiresVerticalScrollbarLayer()) {
          if (!m_layerForVerticalScrollbar) {
              m_layerForVerticalScrollbar = GraphicsLayer::create(graphicsLayerFactory(), *this);
<span class="line-modified">!             m_layerForVerticalScrollbar-&gt;setAllowsBackingStoreDetaching(false);</span>
              m_layerForVerticalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
              m_layerForVerticalScrollbar-&gt;setName(&quot;vertical scrollbar container&quot;);
  #if PLATFORM(COCOA) &amp;&amp; USE(CA)
              m_layerForVerticalScrollbar-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3405,11 ***</span>
      }
  
      if (requiresScrollCornerLayer()) {
          if (!m_layerForScrollCorner) {
              m_layerForScrollCorner = GraphicsLayer::create(graphicsLayerFactory(), *this);
<span class="line-modified">!             m_layerForScrollCorner-&gt;setCanDetachBackingStore(false);</span>
              m_layerForScrollCorner-&gt;setShowDebugBorder(m_showDebugBorders);
              m_layerForScrollCorner-&gt;setName(&quot;scroll corner&quot;);
  #if PLATFORM(COCOA) &amp;&amp; USE(CA)
              m_layerForScrollCorner-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
  #endif
<span class="line-new-header">--- 3832,11 ---</span>
      }
  
      if (requiresScrollCornerLayer()) {
          if (!m_layerForScrollCorner) {
              m_layerForScrollCorner = GraphicsLayer::create(graphicsLayerFactory(), *this);
<span class="line-modified">!             m_layerForScrollCorner-&gt;setAllowsBackingStoreDetaching(false);</span>
              m_layerForScrollCorner-&gt;setShowDebugBorder(m_showDebugBorders);
              m_layerForScrollCorner-&gt;setName(&quot;scroll corner&quot;);
  #if PLATFORM(COCOA) &amp;&amp; USE(CA)
              m_layerForScrollCorner-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3452,11 ***</span>
  
              // Create a layer to host the clipping layer and the overflow controls layers.
              m_overflowControlsHostLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
              m_overflowControlsHostLayer-&gt;setName(&quot;overflow controls host&quot;);
  
<span class="line-modified">!             m_scrolledContentsLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);</span>
              m_scrolledContentsLayer-&gt;setName(&quot;scrolled contents&quot;);
              m_scrolledContentsLayer-&gt;setAnchorPoint({ });
  
  #if PLATFORM(IOS_FAMILY)
              if (m_renderView.settings().asyncFrameScrollingEnabled()) {
<span class="line-new-header">--- 3879,11 ---</span>
  
              // Create a layer to host the clipping layer and the overflow controls layers.
              m_overflowControlsHostLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
              m_overflowControlsHostLayer-&gt;setName(&quot;overflow controls host&quot;);
  
<span class="line-modified">!             m_scrolledContentsLayer = GraphicsLayer::create(graphicsLayerFactory(), *this, GraphicsLayer::Type::ScrolledContents);</span>
              m_scrolledContentsLayer-&gt;setName(&quot;scrolled contents&quot;);
              m_scrolledContentsLayer-&gt;setAnchorPoint({ });
  
  #if PLATFORM(IOS_FAMILY)
              if (m_renderView.settings().asyncFrameScrollingEnabled()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3468,10 ***</span>
<span class="line-new-header">--- 3895,12 ---</span>
  
                  m_scrollContainerLayer-&gt;addChild(*m_scrolledContentsLayer);
                  m_overflowControlsHostLayer-&gt;addChild(*m_scrollContainerLayer);
              }
  #endif
<span class="line-added">+             // FIXME: m_scrollContainerLayer and m_clipLayer have similar roles here, but m_clipLayer has some special positioning to</span>
<span class="line-added">+             // account for clipping and top content inset (see FrameView::yPositionForInsetClipLayer()).</span>
              if (!m_scrollContainerLayer) {
                  m_clipLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
                  m_clipLayer-&gt;setName(&quot;frame clipping&quot;);
                  m_clipLayer-&gt;setMasksToBounds(true);
                  m_clipLayer-&gt;setAnchorPoint({ });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3577,11 ***</span>
  
      m_rootLayerAttachment = attachment;
      rootLayerAttachmentChanged();
  
      if (m_shouldFlushOnReattach) {
<span class="line-modified">!         scheduleLayerFlushNow();</span>
          m_shouldFlushOnReattach = false;
      }
  }
  
  void RenderLayerCompositor::detachRootLayer()
<span class="line-new-header">--- 4006,11 ---</span>
  
      m_rootLayerAttachment = attachment;
      rootLayerAttachmentChanged();
  
      if (m_shouldFlushOnReattach) {
<span class="line-modified">!         scheduleLayerFlush();</span>
          m_shouldFlushOnReattach = false;
      }
  }
  
  void RenderLayerCompositor::detachRootLayer()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3700,11 ***</span>
  #if PLATFORM(IOS_FAMILY)
      if (m_legacyScrollingLayerCoordinator)
          m_legacyScrollingLayerCoordinator-&gt;removeLayer(layer);
  #endif
  
<span class="line-modified">!     detachScrollCoordinatedLayer(layer, { ScrollCoordinationRole::Scrolling, ScrollCoordinationRole::ViewportConstrained, ScrollCoordinationRole::FrameHosting });</span>
  }
  
  FixedPositionViewportConstraints RenderLayerCompositor::computeFixedViewportConstraints(RenderLayer&amp; layer) const
  {
      ASSERT(layer.isComposited());
<span class="line-new-header">--- 4129,11 ---</span>
  #if PLATFORM(IOS_FAMILY)
      if (m_legacyScrollingLayerCoordinator)
          m_legacyScrollingLayerCoordinator-&gt;removeLayer(layer);
  #endif
  
<span class="line-modified">!     detachScrollCoordinatedLayer(layer, allScrollCoordinationRoles());</span>
  }
  
  FixedPositionViewportConstraints RenderLayerCompositor::computeFixedViewportConstraints(RenderLayer&amp; layer) const
  {
      ASSERT(layer.isComposited());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3741,15 ***</span>
  }
  
  StickyPositionViewportConstraints RenderLayerCompositor::computeStickyViewportConstraints(RenderLayer&amp; layer) const
  {
      ASSERT(layer.isComposited());
<span class="line-removed">- #if !PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">-     // We should never get here for stickies constrained by an enclosing clipping layer.</span>
<span class="line-removed">-     // FIXME: Why does this assertion fail on iOS?</span>
<span class="line-removed">-     ASSERT(!layer.enclosingOverflowClipLayer(ExcludeSelf));</span>
<span class="line-removed">- #endif</span>
  
      auto&amp; renderer = downcast&lt;RenderBoxModelObject&gt;(layer.renderer());
  
      StickyPositionViewportConstraints constraints;
      renderer.computeStickyPositionConstraints(constraints, renderer.constrainingRectForStickyPosition());
<span class="line-new-header">--- 4170,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3767,15 ***</span>
<span class="line-new-header">--- 4191,19 ---</span>
      switch (nodeType) {
      case ScrollingNodeType::MainFrame:
      case ScrollingNodeType::Subframe:
      case ScrollingNodeType::Overflow:
          return ScrollCoordinationRole::Scrolling;
<span class="line-added">+     case ScrollingNodeType::OverflowProxy:</span>
<span class="line-added">+         return ScrollCoordinationRole::ScrollingProxy;</span>
      case ScrollingNodeType::FrameHosting:
          return ScrollCoordinationRole::FrameHosting;
      case ScrollingNodeType::Fixed:
      case ScrollingNodeType::Sticky:
          return ScrollCoordinationRole::ViewportConstrained;
<span class="line-added">+     case ScrollingNodeType::Positioned:</span>
<span class="line-added">+         return ScrollCoordinationRole::Positioning;</span>
      }
      ASSERT_NOT_REACHED();
      return ScrollCoordinationRole::Scrolling;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3791,52 ***</span>
      ASSERT(treeState.parentNodeID || nodeType == ScrollingNodeType::Subframe);
      ASSERT_IMPLIES(nodeType == ScrollingNodeType::MainFrame, !treeState.parentNodeID.value());
  
      ScrollCoordinationRole role = scrollCoordinationRoleForNodeType(nodeType);
      ScrollingNodeID nodeID = backing-&gt;scrollingNodeIDForRole(role);
<span class="line-modified">!     if (!nodeID)</span>
<span class="line-modified">!         nodeID = scrollingCoordinator-&gt;uniqueScrollingNodeID();</span>
  
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; attachScrollingNode &quot; &lt;&lt; nodeID &lt;&lt; &quot; (layer &quot; &lt;&lt; backing-&gt;graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;) type &quot; &lt;&lt; nodeType &lt;&lt; &quot; parent &quot; &lt;&lt; treeState.parentNodeID.valueOr(0));
  
      if (nodeType == ScrollingNodeType::Subframe &amp;&amp; !treeState.parentNodeID)
<span class="line-modified">!         nodeID = scrollingCoordinator-&gt;createNode(nodeType, nodeID);</span>
      else {
<span class="line-modified">!         auto newNodeID = scrollingCoordinator-&gt;insertNode(nodeType, nodeID, treeState.parentNodeID.valueOr(0), treeState.nextChildIndex);</span>
          if (newNodeID != nodeID) {
              // We&#39;ll get a new nodeID if the type changed (and not if the node is new).
<span class="line-modified">!             scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(nodeID);</span>
              m_scrollingNodeToLayerMap.remove(nodeID);
          }
          nodeID = newNodeID;
      }
  
      ASSERT(nodeID);
      if (!nodeID)
          return 0;
  
<span class="line-removed">-     backing-&gt;setScrollingNodeIDForRole(nodeID, role);</span>
<span class="line-removed">-     m_scrollingNodeToLayerMap.add(nodeID, &amp;layer);</span>
<span class="line-removed">- </span>
      ++treeState.nextChildIndex;
      return nodeID;
  }
  
  void RenderLayerCompositor::detachScrollCoordinatedLayerWithRole(RenderLayer&amp; layer, ScrollingCoordinator&amp; scrollingCoordinator, ScrollCoordinationRole role)
  {
      auto nodeID = layer.backing()-&gt;scrollingNodeIDForRole(role);
      if (!nodeID)
          return;
  
<span class="line-modified">!     auto childNodes = scrollingCoordinator.childrenOfNode(nodeID);</span>
<span class="line-removed">-     for (auto childNodeID : childNodes) {</span>
<span class="line-removed">-         // FIXME: The child might be in a child frame. Need to do something that crosses frame boundaries.</span>
<span class="line-removed">-         if (auto* layer = m_scrollingNodeToLayerMap.get(childNodeID))</span>
<span class="line-removed">-             layer-&gt;setNeedsScrollingTreeUpdate();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_scrollingNodeToLayerMap.remove(nodeID);</span>
  }
  
  void RenderLayerCompositor::detachScrollCoordinatedLayer(RenderLayer&amp; layer, OptionSet&lt;ScrollCoordinationRole&gt; roles)
  {
      auto* backing = layer.backing();
<span class="line-new-header">--- 4219,80 ---</span>
      ASSERT(treeState.parentNodeID || nodeType == ScrollingNodeType::Subframe);
      ASSERT_IMPLIES(nodeType == ScrollingNodeType::MainFrame, !treeState.parentNodeID.value());
  
      ScrollCoordinationRole role = scrollCoordinationRoleForNodeType(nodeType);
      ScrollingNodeID nodeID = backing-&gt;scrollingNodeIDForRole(role);
<span class="line-modified">! </span>
<span class="line-modified">!     nodeID = registerScrollingNodeID(*scrollingCoordinator, nodeID, nodeType, treeState);</span>
  
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; attachScrollingNode &quot; &lt;&lt; nodeID &lt;&lt; &quot; (layer &quot; &lt;&lt; backing-&gt;graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;) type &quot; &lt;&lt; nodeType &lt;&lt; &quot; parent &quot; &lt;&lt; treeState.parentNodeID.valueOr(0));
  
<span class="line-added">+     if (!nodeID)</span>
<span class="line-added">+         return 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     backing-&gt;setScrollingNodeIDForRole(nodeID, role);</span>
<span class="line-added">+     m_scrollingNodeToLayerMap.add(nodeID, &amp;layer);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return nodeID;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ScrollingNodeID RenderLayerCompositor::registerScrollingNodeID(ScrollingCoordinator&amp; scrollingCoordinator, ScrollingNodeID nodeID, ScrollingNodeType nodeType, struct ScrollingTreeState&amp; treeState)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!nodeID)</span>
<span class="line-added">+         nodeID = scrollingCoordinator.uniqueScrollingNodeID();</span>
<span class="line-added">+ </span>
      if (nodeType == ScrollingNodeType::Subframe &amp;&amp; !treeState.parentNodeID)
<span class="line-modified">!         nodeID = scrollingCoordinator.createNode(nodeType, nodeID);</span>
      else {
<span class="line-modified">!         auto newNodeID = scrollingCoordinator.insertNode(nodeType, nodeID, treeState.parentNodeID.valueOr(0), treeState.nextChildIndex);</span>
          if (newNodeID != nodeID) {
              // We&#39;ll get a new nodeID if the type changed (and not if the node is new).
<span class="line-modified">!             scrollingCoordinator.unparentChildrenAndDestroyNode(nodeID);</span>
              m_scrollingNodeToLayerMap.remove(nodeID);
          }
          nodeID = newNodeID;
      }
  
      ASSERT(nodeID);
      if (!nodeID)
          return 0;
  
      ++treeState.nextChildIndex;
      return nodeID;
  }
  
  void RenderLayerCompositor::detachScrollCoordinatedLayerWithRole(RenderLayer&amp; layer, ScrollingCoordinator&amp; scrollingCoordinator, ScrollCoordinationRole role)
  {
<span class="line-added">+     auto unregisterNode = [&amp;](ScrollingNodeID nodeID) {</span>
<span class="line-added">+         auto childNodes = scrollingCoordinator.childrenOfNode(nodeID);</span>
<span class="line-added">+         for (auto childNodeID : childNodes) {</span>
<span class="line-added">+             if (auto* layer = m_scrollingNodeToLayerMap.get(childNodeID))</span>
<span class="line-added">+                 layer-&gt;setNeedsScrollingTreeUpdate();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_scrollingNodeToLayerMap.remove(nodeID);</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (role == ScrollCoordinationRole::ScrollingProxy) {</span>
<span class="line-added">+         ASSERT(layer.isComposited());</span>
<span class="line-added">+         auto* clippingStack = layer.backing()-&gt;ancestorClippingStack();</span>
<span class="line-added">+         if (!clippingStack)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto&amp; stack = clippingStack-&gt;stack();</span>
<span class="line-added">+         for (auto&amp; entry : stack) {</span>
<span class="line-added">+             if (entry.overflowScrollProxyNodeID)</span>
<span class="line-added">+                 unregisterNode(entry.overflowScrollProxyNodeID);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      auto nodeID = layer.backing()-&gt;scrollingNodeIDForRole(role);
      if (!nodeID)
          return;
  
<span class="line-modified">!     unregisterNode(nodeID);</span>
  }
  
  void RenderLayerCompositor::detachScrollCoordinatedLayer(RenderLayer&amp; layer, OptionSet&lt;ScrollCoordinationRole&gt; roles)
  {
      auto* backing = layer.backing();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3846,50 ***</span>
      auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
  
      if (roles.contains(ScrollCoordinationRole::Scrolling))
          detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Scrolling);
  
      if (roles.contains(ScrollCoordinationRole::FrameHosting))
          detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::FrameHosting);
  
      if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
          detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ViewportConstrained);
  
      backing-&gt;detachFromScrollingCoordinator(roles);
  }
  
<span class="line-modified">! ScrollingNodeID RenderLayerCompositor::updateScrollCoordinationForLayer(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollCoordinationRole&gt; roles, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
  {
<span class="line-modified">!     bool isViewportConstrained = roles.contains(ScrollCoordinationRole::ViewportConstrained);</span>
  #if PLATFORM(IOS_FAMILY)
      if (m_legacyScrollingLayerCoordinator) {
<span class="line-modified">!         if (isViewportConstrained)</span>
              m_legacyScrollingLayerCoordinator-&gt;addViewportConstrainedLayer(layer);
          else
              m_legacyScrollingLayerCoordinator-&gt;removeViewportConstrainedLayer(layer);
      }
  #endif
  
<span class="line-removed">-     // GraphicsLayers need to know whether they are viewport-constrained.</span>
<span class="line-removed">-     layer.backing()-&gt;setIsScrollCoordinatedWithViewportConstrainedRole(isViewportConstrained);</span>
<span class="line-removed">- </span>
      if (!hasCoordinatedScrolling()) {
          // If this frame isn&#39;t coordinated, it cannot contain any scrolling tree nodes.
          return 0;
      }
  
      auto newNodeID = treeState.parentNodeID.valueOr(0);
  
<span class="line-modified">!     ScrollingTreeState viewportConstrainedChildTreeState;</span>
      ScrollingTreeState* currentTreeState = &amp;treeState;
  
<span class="line-modified">!     // If a node plays both roles, fixed/sticky is always the ancestor node of scrolling/frame hosting.</span>
      if (roles.contains(ScrollCoordinationRole::ViewportConstrained)) {
          newNodeID = updateScrollingNodeForViewportConstrainedRole(layer, *currentTreeState, changes);
          // ViewportConstrained nodes are the parent of same-layer scrolling nodes, so adjust the ScrollingTreeState.
<span class="line-modified">!         viewportConstrainedChildTreeState.parentNodeID = newNodeID;</span>
<span class="line-modified">!         currentTreeState = &amp;viewportConstrainedChildTreeState;</span>
      } else
          detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::ViewportConstrained);
  
      if (roles.contains(ScrollCoordinationRole::Scrolling))
          newNodeID = updateScrollingNodeForScrollingRole(layer, *currentTreeState, changes);
<span class="line-new-header">--- 4302,97 ---</span>
      auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
  
      if (roles.contains(ScrollCoordinationRole::Scrolling))
          detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Scrolling);
  
<span class="line-added">+     if (roles.contains(ScrollCoordinationRole::ScrollingProxy))</span>
<span class="line-added">+         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ScrollingProxy);</span>
<span class="line-added">+ </span>
      if (roles.contains(ScrollCoordinationRole::FrameHosting))
          detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::FrameHosting);
  
      if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
          detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ViewportConstrained);
  
<span class="line-added">+     if (roles.contains(ScrollCoordinationRole::Positioning))</span>
<span class="line-added">+         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Positioning);</span>
<span class="line-added">+ </span>
      backing-&gt;detachFromScrollingCoordinator(roles);
  }
  
<span class="line-modified">! OptionSet&lt;ScrollCoordinationRole&gt; RenderLayerCompositor::coordinatedScrollingRolesForLayer(const RenderLayer&amp; layer) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     OptionSet&lt;ScrollCoordinationRole&gt; coordinationRoles;</span>
<span class="line-added">+     if (isViewportConstrainedFixedOrStickyLayer(layer))</span>
<span class="line-added">+         coordinationRoles.add(ScrollCoordinationRole::ViewportConstrained);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (useCoordinatedScrollingForLayer(layer))</span>
<span class="line-added">+         coordinationRoles.add(ScrollCoordinationRole::Scrolling);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto coordinatedPositioning = computeCoordinatedPositioningForLayer(layer);</span>
<span class="line-added">+     switch (coordinatedPositioning) {</span>
<span class="line-added">+     case ScrollPositioningBehavior::Moves:</span>
<span class="line-added">+         coordinationRoles.add(ScrollCoordinationRole::ScrollingProxy);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ScrollPositioningBehavior::Stationary:</span>
<span class="line-added">+         coordinationRoles.add(ScrollCoordinationRole::Positioning);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ScrollPositioningBehavior::None:</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (isLayerForIFrameWithScrollCoordinatedContents(layer))</span>
<span class="line-added">+         coordinationRoles.add(ScrollCoordinationRole::FrameHosting);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return coordinationRoles;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ScrollingNodeID RenderLayerCompositor::updateScrollCoordinationForLayer(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
  {
<span class="line-modified">!     auto roles = coordinatedScrollingRolesForLayer(layer);</span>
<span class="line-added">+ </span>
  #if PLATFORM(IOS_FAMILY)
      if (m_legacyScrollingLayerCoordinator) {
<span class="line-modified">!         if (roles.contains(ScrollCoordinationRole::ViewportConstrained))</span>
              m_legacyScrollingLayerCoordinator-&gt;addViewportConstrainedLayer(layer);
          else
              m_legacyScrollingLayerCoordinator-&gt;removeViewportConstrainedLayer(layer);
      }
  #endif
  
      if (!hasCoordinatedScrolling()) {
          // If this frame isn&#39;t coordinated, it cannot contain any scrolling tree nodes.
          return 0;
      }
  
      auto newNodeID = treeState.parentNodeID.valueOr(0);
  
<span class="line-modified">!     ScrollingTreeState childTreeState;</span>
      ScrollingTreeState* currentTreeState = &amp;treeState;
  
<span class="line-modified">!     // If there&#39;s a positioning node, it&#39;s the parent scrolling node for fixed/sticky/scrolling/frame hosting.</span>
<span class="line-added">+     if (roles.contains(ScrollCoordinationRole::Positioning)) {</span>
<span class="line-added">+         newNodeID = updateScrollingNodeForPositioningRole(layer, *currentTreeState, changes);</span>
<span class="line-added">+         childTreeState.parentNodeID = newNodeID;</span>
<span class="line-added">+         currentTreeState = &amp;childTreeState;</span>
<span class="line-added">+     } else</span>
<span class="line-added">+         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::Positioning);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // If there&#39;s a scrolling proxy node, it&#39;s the parent scrolling node for fixed/sticky/scrolling/frame hosting.</span>
<span class="line-added">+     if (roles.contains(ScrollCoordinationRole::ScrollingProxy)) {</span>
<span class="line-added">+         newNodeID = updateScrollingNodeForScrollingProxyRole(layer, *currentTreeState, changes);</span>
<span class="line-added">+         childTreeState.parentNodeID = newNodeID;</span>
<span class="line-added">+         currentTreeState = &amp;childTreeState;</span>
<span class="line-added">+     } else</span>
<span class="line-added">+         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::ScrollingProxy);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // If is fixed or sticky, it&#39;s the parent scrolling node for scrolling/frame hosting.</span>
      if (roles.contains(ScrollCoordinationRole::ViewportConstrained)) {
          newNodeID = updateScrollingNodeForViewportConstrainedRole(layer, *currentTreeState, changes);
          // ViewportConstrained nodes are the parent of same-layer scrolling nodes, so adjust the ScrollingTreeState.
<span class="line-modified">!         childTreeState.parentNodeID = newNodeID;</span>
<span class="line-modified">!         currentTreeState = &amp;childTreeState;</span>
      } else
          detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::ViewportConstrained);
  
      if (roles.contains(ScrollCoordinationRole::Scrolling))
          newNodeID = updateScrollingNodeForScrollingRole(layer, *currentTreeState, changes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3926,89 ***</span>
          scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
  
      if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
          switch (nodeType) {
          case ScrollingNodeType::Fixed:
<span class="line-modified">!             scrollingCoordinator-&gt;setViewportConstraintedNodeGeometry(newNodeID, computeFixedViewportConstraints(layer));</span>
              break;
          case ScrollingNodeType::Sticky:
<span class="line-modified">!             scrollingCoordinator-&gt;setViewportConstraintedNodeGeometry(newNodeID, computeStickyViewportConstraints(layer));</span>
              break;
<span class="line-modified">!         case ScrollingNodeType::MainFrame:</span>
<span class="line-removed">-         case ScrollingNodeType::Subframe:</span>
<span class="line-removed">-         case ScrollingNodeType::FrameHosting:</span>
<span class="line-removed">-         case ScrollingNodeType::Overflow:</span>
              break;
          }
      }
  
      return newNodeID;
  }
  
<span class="line-modified">! void RenderLayerCompositor::computeFrameScrollingGeometry(ScrollingCoordinator::ScrollingGeometry&amp; scrollingGeometry) const</span>
  {
      auto&amp; frameView = m_renderView.frameView();
  
      if (m_renderView.frame().isMainFrame())
<span class="line-modified">!         scrollingGeometry.parentRelativeScrollableRect = frameView.frameRect();</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         scrollingGeometry.parentRelativeScrollableRect = LayoutRect({ }, LayoutSize(frameView.size()));</span>
  
<span class="line-modified">!     scrollingGeometry.scrollOrigin = frameView.scrollOrigin();</span>
<span class="line-removed">-     scrollingGeometry.scrollableAreaSize = frameView.visibleContentRect().size();</span>
<span class="line-removed">-     scrollingGeometry.contentSize = frameView.totalContentsSize();</span>
<span class="line-removed">-     scrollingGeometry.reachableContentSize = frameView.totalContentsSize();</span>
<span class="line-removed">- #if ENABLE(CSS_SCROLL_SNAP)</span>
<span class="line-removed">-     frameView.updateSnapOffsets();</span>
<span class="line-removed">-     updateScrollSnapPropertiesWithFrameView(frameView);</span>
<span class="line-removed">- #endif</span>
  }
  
<span class="line-modified">! void RenderLayerCompositor::computeFrameHostingGeometry(const RenderLayer&amp; layer, const RenderLayer* ancestorLayer, ScrollingCoordinator::ScrollingGeometry&amp; scrollingGeometry) const</span>
  {
      // FIXME: ancestorLayer needs to be always non-null, so should become a reference.
<span class="line-modified">!     if (ancestorLayer) {</span>
<span class="line-modified">!         LayoutRect scrollableRect;</span>
<span class="line-removed">-         if (is&lt;RenderBox&gt;(layer.renderer()))</span>
<span class="line-removed">-             scrollableRect = downcast&lt;RenderBox&gt;(layer.renderer()).paddingBoxRect();</span>
  
<span class="line-modified">!         auto offset = layer.convertToLayerCoords(ancestorLayer, scrollableRect.location()); // FIXME: broken for columns.</span>
<span class="line-modified">!         scrollableRect.setLocation(offset);</span>
<span class="line-modified">!         scrollingGeometry.parentRelativeScrollableRect = scrollableRect;</span>
<span class="line-modified">!     }</span>
  }
  
<span class="line-modified">! void RenderLayerCompositor::computeOverflowScrollingGeometry(const RenderLayer&amp; layer, const RenderLayer* ancestorLayer, ScrollingCoordinator::ScrollingGeometry&amp; scrollingGeometry) const</span>
  {
<span class="line-modified">!     // FIXME: ancestorLayer needs to be always non-null, so should become a reference.</span>
<span class="line-modified">!     if (ancestorLayer) {</span>
<span class="line-modified">!         LayoutRect scrollableRect;</span>
<span class="line-modified">!         if (is&lt;RenderBox&gt;(layer.renderer()))</span>
<span class="line-modified">!             scrollableRect = downcast&lt;RenderBox&gt;(layer.renderer()).paddingBoxRect();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         auto offset = layer.convertToLayerCoords(ancestorLayer, scrollableRect.location()); // FIXME: broken for columns.</span>
<span class="line-modified">!         scrollableRect.setLocation(offset);</span>
<span class="line-modified">!         scrollingGeometry.parentRelativeScrollableRect = scrollableRect;</span>
      }
<span class="line-removed">- </span>
<span class="line-removed">-     scrollingGeometry.scrollOrigin = layer.scrollOrigin();</span>
<span class="line-removed">-     scrollingGeometry.scrollPosition = layer.scrollPosition();</span>
<span class="line-removed">-     scrollingGeometry.scrollableAreaSize = layer.visibleSize();</span>
<span class="line-removed">-     scrollingGeometry.contentSize = layer.contentsSize();</span>
<span class="line-removed">-     scrollingGeometry.reachableContentSize = layer.scrollableContentsSize();</span>
<span class="line-removed">- #if ENABLE(CSS_SCROLL_SNAP)</span>
<span class="line-removed">-     if (auto* offsets = layer.horizontalSnapOffsets())</span>
<span class="line-removed">-         scrollingGeometry.horizontalSnapOffsets = *offsets;</span>
<span class="line-removed">-     if (auto* offsets = layer.verticalSnapOffsets())</span>
<span class="line-removed">-         scrollingGeometry.verticalSnapOffsets = *offsets;</span>
<span class="line-removed">-     if (auto* ranges = layer.horizontalSnapOffsetRanges())</span>
<span class="line-removed">-         scrollingGeometry.horizontalSnapOffsetRanges = *ranges;</span>
<span class="line-removed">-     if (auto* ranges = layer.verticalSnapOffsetRanges())</span>
<span class="line-removed">-         scrollingGeometry.verticalSnapOffsetRanges = *ranges;</span>
<span class="line-removed">-     scrollingGeometry.currentHorizontalSnapPointIndex = layer.currentHorizontalSnapPointIndex();</span>
<span class="line-removed">-     scrollingGeometry.currentVerticalSnapPointIndex = layer.currentVerticalSnapPointIndex();</span>
<span class="line-removed">- #endif</span>
  }
  
  ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForScrollingRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
  {
      auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
<span class="line-new-header">--- 4429,63 ---</span>
          scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
  
      if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
          switch (nodeType) {
          case ScrollingNodeType::Fixed:
<span class="line-modified">!             scrollingCoordinator-&gt;setViewportConstraintedNodeConstraints(newNodeID, computeFixedViewportConstraints(layer));</span>
              break;
          case ScrollingNodeType::Sticky:
<span class="line-modified">!             scrollingCoordinator-&gt;setViewportConstraintedNodeConstraints(newNodeID, computeStickyViewportConstraints(layer));</span>
              break;
<span class="line-modified">!         default:</span>
              break;
          }
      }
  
      return newNodeID;
  }
  
<span class="line-modified">! LayoutRect RenderLayerCompositor::rootParentRelativeScrollableRect() const</span>
  {
      auto&amp; frameView = m_renderView.frameView();
  
      if (m_renderView.frame().isMainFrame())
<span class="line-modified">!         return frameView.frameRect();</span>
  
<span class="line-modified">!     return LayoutRect({ }, LayoutSize(frameView.size()));</span>
  }
  
<span class="line-modified">! LayoutRect RenderLayerCompositor::parentRelativeScrollableRect(const RenderLayer&amp; layer, const RenderLayer* ancestorLayer) const</span>
  {
      // FIXME: ancestorLayer needs to be always non-null, so should become a reference.
<span class="line-modified">!     if (!ancestorLayer)</span>
<span class="line-modified">!         return LayoutRect({ }, LayoutSize(layer.visibleSize()));</span>
  
<span class="line-modified">!     LayoutRect scrollableRect;</span>
<span class="line-modified">!     if (is&lt;RenderBox&gt;(layer.renderer()))</span>
<span class="line-modified">!         scrollableRect = downcast&lt;RenderBox&gt;(layer.renderer()).paddingBoxRect();</span>
<span class="line-modified">! </span>
<span class="line-added">+     auto offset = layer.convertToLayerCoords(ancestorLayer, scrollableRect.location()); // FIXME: broken for columns.</span>
<span class="line-added">+     scrollableRect.setLocation(offset);</span>
<span class="line-added">+     return scrollableRect;</span>
  }
  
<span class="line-modified">! void RenderLayerCompositor::updateScrollingNodeLayers(ScrollingNodeID nodeID, RenderLayer&amp; layer, ScrollingCoordinator&amp; scrollingCoordinator)</span>
  {
<span class="line-modified">!     if (layer.isRenderViewLayer()) {</span>
<span class="line-modified">!         FrameView&amp; frameView = m_renderView.frameView();</span>
<span class="line-modified">!         scrollingCoordinator.setNodeLayers(nodeID, { nullptr,</span>
<span class="line-modified">!             scrollContainerLayer(), scrolledContentsLayer(),</span>
<span class="line-modified">!             fixedRootBackgroundLayer(), clipLayer(), rootContentsLayer(),</span>
<span class="line-modified">!             frameView.layerForHorizontalScrollbar(), frameView.layerForVerticalScrollbar() });</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         auto&amp; backing = *layer.backing();</span>
<span class="line-modified">!         scrollingCoordinator.setNodeLayers(nodeID, { backing.graphicsLayer(),</span>
<span class="line-added">+             backing.scrollContainerLayer(), backing.scrolledContentsLayer(),</span>
<span class="line-added">+             nullptr, nullptr, nullptr,</span>
<span class="line-added">+             layer.layerForHorizontalScrollbar(), layer.layerForVerticalScrollbar() });</span>
      }
  }
  
  ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForScrollingRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
  {
      auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4025,38 ***</span>
              ASSERT_NOT_REACHED();
              return treeState.parentNodeID.valueOr(0);
          }
  
          if (changes &amp; ScrollingNodeChangeFlags::Layer)
<span class="line-modified">!             scrollingCoordinator-&gt;setNodeLayers(newNodeID, { nullptr, scrollContainerLayer(), scrolledContentsLayer(), fixedRootBackgroundLayer(), clipLayer(), rootContentsLayer() });</span>
  
          if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
<span class="line-modified">!             ScrollingCoordinator::ScrollingGeometry scrollingGeometry;</span>
<span class="line-modified">!             computeFrameScrollingGeometry(scrollingGeometry);</span>
<span class="line-modified">!             scrollingCoordinator-&gt;setScrollingNodeGeometry(newNodeID, scrollingGeometry);</span>
          }
      } else {
          newNodeID = attachScrollingNode(layer, ScrollingNodeType::Overflow, treeState);
          if (!newNodeID) {
              ASSERT_NOT_REACHED();
              return treeState.parentNodeID.valueOr(0);
          }
  
          if (changes &amp; ScrollingNodeChangeFlags::Layer)
<span class="line-modified">!             scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer(), layer.backing()-&gt;scrollContainerLayer(), layer.backing()-&gt;scrolledContentsLayer() });</span>
  
          if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
              RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
<span class="line-modified">!             ScrollingCoordinator::ScrollingGeometry scrollingGeometry;</span>
<span class="line-modified">!             computeOverflowScrollingGeometry(layer, scrollingAncestorLayer, scrollingGeometry);</span>
<span class="line-removed">-             scrollingCoordinator-&gt;setScrollingNodeGeometry(newNodeID, scrollingGeometry);</span>
          }
      }
  
      return newNodeID;
  }
  
  ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForFrameHostingRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
  {
      auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
  
      auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::FrameHosting, treeState);
<span class="line-new-header">--- 4502,82 ---</span>
              ASSERT_NOT_REACHED();
              return treeState.parentNodeID.valueOr(0);
          }
  
          if (changes &amp; ScrollingNodeChangeFlags::Layer)
<span class="line-modified">!             updateScrollingNodeLayers(newNodeID, layer, *scrollingCoordinator);</span>
  
          if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
<span class="line-modified">!             scrollingCoordinator-&gt;setRectRelativeToParentNode(newNodeID, rootParentRelativeScrollableRect());</span>
<span class="line-modified">!             scrollingCoordinator-&gt;setScrollingNodeScrollableAreaGeometry(newNodeID, frameView);</span>
<span class="line-modified">!             scrollingCoordinator-&gt;setFrameScrollingNodeState(newNodeID, frameView);</span>
          }
      } else {
          newNodeID = attachScrollingNode(layer, ScrollingNodeType::Overflow, treeState);
          if (!newNodeID) {
              ASSERT_NOT_REACHED();
              return treeState.parentNodeID.valueOr(0);
          }
  
          if (changes &amp; ScrollingNodeChangeFlags::Layer)
<span class="line-modified">!             updateScrollingNodeLayers(newNodeID, layer, *scrollingCoordinator);</span>
  
          if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
              RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
<span class="line-modified">!             scrollingCoordinator-&gt;setRectRelativeToParentNode(newNodeID, parentRelativeScrollableRect(layer, scrollingAncestorLayer));</span>
<span class="line-modified">!             scrollingCoordinator-&gt;setScrollingNodeScrollableAreaGeometry(newNodeID, layer);</span>
          }
      }
  
      return newNodeID;
  }
  
<span class="line-added">+ ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForScrollingProxyRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();</span>
<span class="line-added">+     auto* clippingStack = layer.backing()-&gt;ancestorClippingStack();</span>
<span class="line-added">+     if (!clippingStack) {</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return treeState.parentNodeID.valueOr(0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ScrollingNodeID nodeID = 0;</span>
<span class="line-added">+     for (auto&amp; entry : clippingStack-&gt;stack()) {</span>
<span class="line-added">+         if (!entry.clipData.isOverflowScroll)</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+         nodeID = registerScrollingNodeID(*scrollingCoordinator, entry.overflowScrollProxyNodeID, ScrollingNodeType::OverflowProxy, treeState);</span>
<span class="line-added">+         if (!nodeID) {</span>
<span class="line-added">+             ASSERT_NOT_REACHED();</span>
<span class="line-added">+             return treeState.parentNodeID.valueOr(0);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         entry.overflowScrollProxyNodeID = nodeID;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (changes &amp; ScrollingNodeChangeFlags::Layer)</span>
<span class="line-added">+             scrollingCoordinator-&gt;setNodeLayers(entry.overflowScrollProxyNodeID, { entry.clippingLayer.get() });</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {</span>
<span class="line-added">+             ASSERT(entry.clipData.clippingLayer);</span>
<span class="line-added">+             ASSERT(entry.clipData.clippingLayer-&gt;isComposited());</span>
<span class="line-added">+ </span>
<span class="line-added">+             ScrollingNodeID overflowScrollNodeID = 0;</span>
<span class="line-added">+             if (auto* backing = entry.clipData.clippingLayer-&gt;backing())</span>
<span class="line-added">+                 overflowScrollNodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);</span>
<span class="line-added">+ </span>
<span class="line-added">+             Vector&lt;ScrollingNodeID&gt; scrollingNodeIDs;</span>
<span class="line-added">+             if (overflowScrollNodeID)</span>
<span class="line-added">+                 scrollingNodeIDs.append(overflowScrollNodeID);</span>
<span class="line-added">+             scrollingCoordinator-&gt;setRelatedOverflowScrollingNodes(entry.overflowScrollProxyNodeID, WTFMove(scrollingNodeIDs));</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!nodeID)</span>
<span class="line-added">+         return treeState.parentNodeID.valueOr(0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return nodeID;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForFrameHostingRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
  {
      auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
  
      auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::FrameHosting, treeState);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4068,13 ***</span>
      if (changes &amp; ScrollingNodeChangeFlags::Layer)
          scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
  
      if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
          RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
<span class="line-modified">!         ScrollingCoordinator::ScrollingGeometry scrollingGeometry;</span>
<span class="line-modified">!         computeFrameHostingGeometry(layer, scrollingAncestorLayer, scrollingGeometry);</span>
<span class="line-modified">!         scrollingCoordinator-&gt;setScrollingNodeGeometry(newNodeID, scrollingGeometry);</span>
      }
  
      return newNodeID;
  }
  
<span class="line-new-header">--- 4589,42 ---</span>
      if (changes &amp; ScrollingNodeChangeFlags::Layer)
          scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
  
      if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
          RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
<span class="line-modified">!         scrollingCoordinator-&gt;setRectRelativeToParentNode(newNodeID, parentRelativeScrollableRect(layer, scrollingAncestorLayer));</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-added">+     return newNodeID;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForPositioningRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::Positioned, treeState);</span>
<span class="line-added">+     if (!newNodeID) {</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return treeState.parentNodeID.valueOr(0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changes &amp; ScrollingNodeChangeFlags::Layer) {</span>
<span class="line-added">+         auto&amp; backing = *layer.backing();</span>
<span class="line-added">+         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { backing.graphicsLayer() });</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {</span>
<span class="line-added">+         // Would be nice to avoid calling computeCoordinatedPositioningForLayer() again.</span>
<span class="line-added">+         auto positioningBehavior = computeCoordinatedPositioningForLayer(layer);</span>
<span class="line-added">+         auto relatedNodeIDs = collectRelatedCoordinatedScrollingNodes(layer, positioningBehavior);</span>
<span class="line-added">+         scrollingCoordinator-&gt;setRelatedOverflowScrollingNodes(newNodeID, WTFMove(relatedNodeIDs));</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();</span>
<span class="line-added">+         AbsolutePositionConstraints constraints;</span>
<span class="line-added">+         constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());</span>
<span class="line-added">+         constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());</span>
<span class="line-added">+         scrollingCoordinator-&gt;setPositionedNodeConstraints(newNodeID, constraints);</span>
      }
  
      return newNodeID;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4138,11 ***</span>
      if (m_layerFlushThrottlingEnabled)
          return;
      m_layerFlushTimer.stop();
      if (!m_hasPendingLayerFlush)
          return;
<span class="line-modified">!     scheduleLayerFlushNow();</span>
  }
  
  void RenderLayerCompositor::disableLayerFlushThrottlingTemporarilyForInteraction()
  {
      if (m_layerFlushThrottlingTemporarilyDisabledForInteraction)
<span class="line-new-header">--- 4688,11 ---</span>
      if (m_layerFlushThrottlingEnabled)
          return;
      m_layerFlushTimer.stop();
      if (!m_hasPendingLayerFlush)
          return;
<span class="line-modified">!     scheduleLayerFlush();</span>
  }
  
  void RenderLayerCompositor::disableLayerFlushThrottlingTemporarilyForInteraction()
  {
      if (m_layerFlushThrottlingTemporarilyDisabledForInteraction)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4181,11 ***</span>
  
  void RenderLayerCompositor::layerFlushTimerFired()
  {
      if (!m_hasPendingLayerFlush)
          return;
<span class="line-modified">!     scheduleLayerFlushNow();</span>
  }
  
  #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
  RefPtr&lt;DisplayRefreshMonitor&gt; RenderLayerCompositor::createDisplayRefreshMonitor(PlatformDisplayID displayID) const
  {
<span class="line-new-header">--- 4731,11 ---</span>
  
  void RenderLayerCompositor::layerFlushTimerFired()
  {
      if (!m_hasPendingLayerFlush)
          return;
<span class="line-modified">!     scheduleLayerFlush();</span>
  }
  
  #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
  RefPtr&lt;DisplayRefreshMonitor&gt; RenderLayerCompositor::createDisplayRefreshMonitor(PlatformDisplayID displayID) const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4244,19 ***</span>
      for (auto* layer : m_viewportConstrainedLayers) {
          ASSERT(layer-&gt;isComposited());
  
          std::unique_ptr&lt;ViewportConstraints&gt; constraints;
          if (layer-&gt;renderer().isStickilyPositioned()) {
<span class="line-modified">!             constraints = std::make_unique&lt;StickyPositionViewportConstraints&gt;(compositor.computeStickyViewportConstraints(*layer));</span>
              const RenderLayer* enclosingTouchScrollableLayer = nullptr;
              if (compositor.isAsyncScrollableStickyLayer(*layer, &amp;enclosingTouchScrollableLayer) &amp;&amp; enclosingTouchScrollableLayer) {
                  ASSERT(enclosingTouchScrollableLayer-&gt;isComposited());
                  // what
                  stickyContainerMap.add(layer-&gt;backing()-&gt;graphicsLayer()-&gt;platformLayer(), enclosingTouchScrollableLayer-&gt;backing()-&gt;scrollContainerLayer()-&gt;platformLayer());
              }
          } else if (layer-&gt;renderer().isFixedPositioned())
<span class="line-modified">!             constraints = std::make_unique&lt;FixedPositionViewportConstraints&gt;(compositor.computeFixedViewportConstraints(*layer));</span>
          else
              continue;
  
          layerMap.add(layer-&gt;backing()-&gt;graphicsLayer()-&gt;platformLayer(), WTFMove(constraints));
      }
<span class="line-new-header">--- 4794,19 ---</span>
      for (auto* layer : m_viewportConstrainedLayers) {
          ASSERT(layer-&gt;isComposited());
  
          std::unique_ptr&lt;ViewportConstraints&gt; constraints;
          if (layer-&gt;renderer().isStickilyPositioned()) {
<span class="line-modified">!             constraints = makeUnique&lt;StickyPositionViewportConstraints&gt;(compositor.computeStickyViewportConstraints(*layer));</span>
              const RenderLayer* enclosingTouchScrollableLayer = nullptr;
              if (compositor.isAsyncScrollableStickyLayer(*layer, &amp;enclosingTouchScrollableLayer) &amp;&amp; enclosingTouchScrollableLayer) {
                  ASSERT(enclosingTouchScrollableLayer-&gt;isComposited());
                  // what
                  stickyContainerMap.add(layer-&gt;backing()-&gt;graphicsLayer()-&gt;platformLayer(), enclosingTouchScrollableLayer-&gt;backing()-&gt;scrollContainerLayer()-&gt;platformLayer());
              }
          } else if (layer-&gt;renderer().isFixedPositioned())
<span class="line-modified">!             constraints = makeUnique&lt;FixedPositionViewportConstraints&gt;(compositor.computeFixedViewportConstraints(*layer));</span>
          else
              continue;
  
          layerMap.add(layer-&gt;backing()-&gt;graphicsLayer()-&gt;platformLayer(), WTFMove(constraints));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4271,44 ***</span>
  
      LayerMap layerMap;
      m_chromeClient.updateViewportConstrainedLayers(layerMap, { });
  }
  
<span class="line-removed">- static bool scrollbarHasDisplayNone(Scrollbar* scrollbar)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!scrollbar || !scrollbar-&gt;isCustomScrollbar())</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     std::unique_ptr&lt;RenderStyle&gt; scrollbarStyle = static_cast&lt;RenderScrollbar*&gt;(scrollbar)-&gt;getScrollbarPseudoStyle(ScrollbarBGPart, PseudoId::Scrollbar);</span>
<span class="line-removed">-     return scrollbarStyle &amp;&amp; scrollbarStyle-&gt;display() == DisplayType::None;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void LegacyWebKitScrollingLayerCoordinator::updateScrollingLayer(RenderLayer&amp; layer)
  {
      auto* backing = layer.backing();
      ASSERT(backing);
  
<span class="line-modified">!     bool allowHorizontalScrollbar = !scrollbarHasDisplayNone(layer.horizontalScrollbar());</span>
<span class="line-modified">!     bool allowVerticalScrollbar = !scrollbarHasDisplayNone(layer.verticalScrollbar());</span>
      m_chromeClient.addOrUpdateScrollingLayer(layer.renderer().element(), backing-&gt;scrollContainerLayer()-&gt;platformLayer(), backing-&gt;scrolledContentsLayer()-&gt;platformLayer(),
<span class="line-modified">!         layer.scrollableContentsSize(), allowHorizontalScrollbar, allowVerticalScrollbar);</span>
  }
  
  void LegacyWebKitScrollingLayerCoordinator::registerAllScrollingLayers()
  {
      for (auto* layer : m_scrollingLayers)
          updateScrollingLayer(*layer);
  }
  
<span class="line-removed">- void LegacyWebKitScrollingLayerCoordinator::registerScrollingLayersNeedingUpdate()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     for (auto* layer : m_scrollingLayersNeedingUpdate)</span>
<span class="line-removed">-         updateScrollingLayer(*layer);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_scrollingLayersNeedingUpdate.clear();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void LegacyWebKitScrollingLayerCoordinator::unregisterAllScrollingLayers()
  {
      for (auto* layer : m_scrollingLayers) {
          auto* backing = layer-&gt;backing();
          ASSERT(backing);
<span class="line-new-header">--- 4821,28 ---</span>
  
      LayerMap layerMap;
      m_chromeClient.updateViewportConstrainedLayers(layerMap, { });
  }
  
  void LegacyWebKitScrollingLayerCoordinator::updateScrollingLayer(RenderLayer&amp; layer)
  {
      auto* backing = layer.backing();
      ASSERT(backing);
  
<span class="line-modified">!     bool allowHorizontalScrollbar = !layer.horizontalScrollbarHiddenByStyle();</span>
<span class="line-modified">!     bool allowVerticalScrollbar = !layer.verticalScrollbarHiddenByStyle();</span>
<span class="line-added">+ </span>
      m_chromeClient.addOrUpdateScrollingLayer(layer.renderer().element(), backing-&gt;scrollContainerLayer()-&gt;platformLayer(), backing-&gt;scrolledContentsLayer()-&gt;platformLayer(),
<span class="line-modified">!         layer.reachableTotalContentsSize(), allowHorizontalScrollbar, allowVerticalScrollbar);</span>
  }
  
  void LegacyWebKitScrollingLayerCoordinator::registerAllScrollingLayers()
  {
      for (auto* layer : m_scrollingLayers)
          updateScrollingLayer(*layer);
  }
  
  void LegacyWebKitScrollingLayerCoordinator::unregisterAllScrollingLayers()
  {
      for (auto* layer : m_scrollingLayers) {
          auto* backing = layer-&gt;backing();
          ASSERT(backing);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4317,16 ***</span>
  }
  
  void LegacyWebKitScrollingLayerCoordinator::addScrollingLayer(RenderLayer&amp; layer)
  {
      m_scrollingLayers.add(&amp;layer);
<span class="line-removed">-     m_scrollingLayersNeedingUpdate.add(&amp;layer);</span>
  }
  
  void LegacyWebKitScrollingLayerCoordinator::removeScrollingLayer(RenderLayer&amp; layer, RenderLayerBacking&amp; backing)
  {
<span class="line-removed">-     m_scrollingLayersNeedingUpdate.remove(&amp;layer);</span>
      if (m_scrollingLayers.remove(&amp;layer)) {
          auto* scrollContainerLayer = backing.scrollContainerLayer()-&gt;platformLayer();
          auto* scrolledContentsLayer = backing.scrolledContentsLayer()-&gt;platformLayer();
          m_chromeClient.removeScrollingLayer(layer.renderer().element(), scrollContainerLayer, scrolledContentsLayer);
      }
<span class="line-new-header">--- 4851,14 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4348,16 ***</span>
  void LegacyWebKitScrollingLayerCoordinator::removeViewportConstrainedLayer(RenderLayer&amp; layer)
  {
      m_viewportConstrainedLayers.remove(&amp;layer);
  }
  
<span class="line-removed">- void LegacyWebKitScrollingLayerCoordinator::didChangePlatformLayerForLayer(RenderLayer&amp; layer)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_scrollingLayers.contains(&amp;layer))</span>
<span class="line-removed">-         m_scrollingLayersNeedingUpdate.add(&amp;layer);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  #endif
  
  } // namespace WebCore
  
  #if ENABLE(TREE_DEBUGGING)
<span class="line-new-header">--- 4880,10 ---</span>
</pre>
<center><a href="RenderLayerBacking.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerCompositor.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>