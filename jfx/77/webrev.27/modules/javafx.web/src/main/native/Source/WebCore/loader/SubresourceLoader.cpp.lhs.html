<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/SubresourceLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2006-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;SubresourceLoader.h&quot;
 31 
 32 #include &quot;CachedRawResource.h&quot;
 33 #include &quot;CachedResourceLoader.h&quot;
 34 #include &quot;CrossOriginAccessControl.h&quot;
<a name="2" id="anc2"></a>
 35 #include &quot;DiagnosticLoggingClient.h&quot;
 36 #include &quot;DiagnosticLoggingKeys.h&quot;
 37 #include &quot;Document.h&quot;
 38 #include &quot;DocumentLoader.h&quot;
 39 #include &quot;Frame.h&quot;
 40 #include &quot;FrameLoader.h&quot;
 41 #include &quot;HTTPParsers.h&quot;
 42 #include &quot;LinkLoader.h&quot;
 43 #include &quot;Logging.h&quot;
 44 #include &quot;MemoryCache.h&quot;
 45 #include &quot;Page.h&quot;
 46 #include &quot;ResourceLoadObserver.h&quot;
 47 #include &quot;ResourceTiming.h&quot;
 48 #include &quot;RuntimeEnabledFeatures.h&quot;
 49 #include &quot;Settings.h&quot;
 50 #include &lt;wtf/CompletionHandler.h&gt;
 51 #include &lt;wtf/Ref.h&gt;
 52 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 53 #include &lt;wtf/StdLibExtras.h&gt;
 54 #include &lt;wtf/SystemTracing.h&gt;
 55 #include &lt;wtf/text/CString.h&gt;
 56 
 57 #if PLATFORM(IOS_FAMILY)
 58 #include &lt;RuntimeApplicationChecks.h&gt;
 59 #endif
 60 
 61 #if ENABLE(CONTENT_EXTENSIONS)
 62 #include &quot;ResourceLoadInfo.h&quot;
 63 #endif
 64 
 65 #if USE(QUICK_LOOK)
<a name="3" id="anc3"></a>
 66 #include &quot;PreviewLoader.h&quot;
 67 #endif
 68 
 69 #undef RELEASE_LOG_IF_ALLOWED
 70 #undef RELEASE_LOG_ERROR_IF_ALLOWED
 71 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), ResourceLoading, &quot;%p - SubresourceLoader::&quot; fmt, this, ##__VA_ARGS__)
 72 #define RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(isAlwaysOnLoggingAllowed(), ResourceLoading, &quot;%p - SubresourceLoader::&quot; fmt, this, ##__VA_ARGS__)
 73 
 74 namespace WebCore {
 75 
 76 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, subresourceLoaderCounter, (&quot;SubresourceLoader&quot;));
 77 
 78 SubresourceLoader::RequestCountTracker::RequestCountTracker(CachedResourceLoader&amp; cachedResourceLoader, const CachedResource&amp; resource)
 79     : m_cachedResourceLoader(cachedResourceLoader)
 80     , m_resource(resource)
 81 {
 82     m_cachedResourceLoader.incrementRequestCount(m_resource);
 83 }
 84 
 85 SubresourceLoader::RequestCountTracker::~RequestCountTracker()
 86 {
 87     m_cachedResourceLoader.decrementRequestCount(m_resource);
 88 }
 89 
<a name="4" id="anc4"></a><span class="line-modified"> 90 SubresourceLoader::SubresourceLoader(DocumentLoader&amp; documentLoader, CachedResource&amp; resource, const ResourceLoaderOptions&amp; options)</span>
<span class="line-modified"> 91     : ResourceLoader(documentLoader, options)</span>
 92     , m_resource(&amp;resource)
 93     , m_state(Uninitialized)
<a name="5" id="anc5"></a><span class="line-modified"> 94     , m_requestCountTracker(std::in_place, documentLoader.cachedResourceLoader(), resource)</span>
 95 {
 96 #ifndef NDEBUG
 97     subresourceLoaderCounter.increment();
 98 #endif
 99 #if ENABLE(CONTENT_EXTENSIONS)
<a name="6" id="anc6"></a><span class="line-modified">100     m_resourceType = toResourceType(resource.type());</span>
101 #endif
<a name="7" id="anc7"></a><span class="line-modified">102     m_canCrossOriginRequestsAskUserForCredentials = resource.type() == CachedResource::Type::MainResource || (documentLoader.frame() &amp;&amp; documentLoader.frame()-&gt;settings().allowCrossOriginSubresourcesToAskForCredentials());</span>
103 }
104 
105 SubresourceLoader::~SubresourceLoader()
106 {
107     ASSERT(m_state != Initialized);
108     ASSERT(reachedTerminalState());
109 #ifndef NDEBUG
110     subresourceLoaderCounter.decrement();
111 #endif
112 }
113 
<a name="8" id="anc8"></a><span class="line-modified">114 void SubresourceLoader::create(DocumentLoader&amp; documentLoader, CachedResource&amp; resource, ResourceRequest&amp;&amp; request, const ResourceLoaderOptions&amp; options, CompletionHandler&lt;void(RefPtr&lt;SubresourceLoader&gt;&amp;&amp;)&gt;&amp;&amp; completionHandler)</span>
115 {
<a name="9" id="anc9"></a><span class="line-modified">116     auto subloader(adoptRef(*new SubresourceLoader(documentLoader, resource, options)));</span>
117 #if PLATFORM(IOS_FAMILY)
118     if (!IOSApplication::isWebProcess()) {
119         // On iOS, do not invoke synchronous resource load delegates while resource load scheduling
120         // is disabled to avoid re-entering style selection from a different thread (see &lt;rdar://problem/9121719&gt;).
121         // FIXME: This should be fixed for all ports in &lt;https://bugs.webkit.org/show_bug.cgi?id=56647&gt;.
122         subloader-&gt;m_iOSOriginalRequest = request;
123         return completionHandler(WTFMove(subloader));
124     }
125 #endif
126     subloader-&gt;init(WTFMove(request), [subloader = subloader.copyRef(), completionHandler = WTFMove(completionHandler)] (bool initialized) mutable {
127         if (!initialized)
128             return completionHandler(nullptr);
129         completionHandler(WTFMove(subloader));
130     });
131 }
132 
133 #if PLATFORM(IOS_FAMILY)
134 void SubresourceLoader::startLoading()
135 {
136     // FIXME: this should probably be removed.
137     ASSERT(!IOSApplication::isWebProcess());
138     init(ResourceRequest(m_iOSOriginalRequest), [this, protectedThis = makeRef(*this)] (bool success) {
139         if (!success)
140             return;
141         m_iOSOriginalRequest = ResourceRequest();
142         start();
143     });
144 }
145 #endif
146 
147 CachedResource* SubresourceLoader::cachedResource()
148 {
149     return m_resource;
150 }
151 
152 void SubresourceLoader::cancelIfNotFinishing()
153 {
154     if (m_state != Initialized)
155         return;
156 
157     ResourceLoader::cancel();
158 }
159 
160 void SubresourceLoader::init(ResourceRequest&amp;&amp; request, CompletionHandler&lt;void(bool)&gt;&amp;&amp; completionHandler)
161 {
162     ResourceLoader::init(WTFMove(request), [this, protectedThis = makeRef(*this), completionHandler = WTFMove(completionHandler)] (bool initialized) mutable {
163         if (!initialized)
164             return completionHandler(false);
<a name="10" id="anc10"></a>




165         ASSERT(!reachedTerminalState());
166         m_state = Initialized;
167         m_documentLoader-&gt;addSubresourceLoader(this);
168         m_origin = m_resource-&gt;origin();
169         completionHandler(true);
170     });
171 }
172 
173 bool SubresourceLoader::isSubresourceLoader() const
174 {
175     return true;
176 }
177 
178 void SubresourceLoader::willSendRequestInternal(ResourceRequest&amp;&amp; newRequest, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
179 {
180     // Store the previous URL because the call to ResourceLoader::willSendRequest will modify it.
181     URL previousURL = request().url();
182     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
183 
184     if (!newRequest.url().isValid()) {
185         cancel(cannotShowURLError());
186         return completionHandler(WTFMove(newRequest));
187     }
188 
189     if (newRequest.requester() != ResourceRequestBase::Requester::Main) {
190         tracePoint(SubresourceLoadWillStart);
191         ResourceLoadObserver::shared().logSubresourceLoading(m_frame.get(), newRequest, redirectResponse);
192     }
193 
194     auto continueWillSendRequest = [this, protectedThis = makeRef(*this), redirectResponse] (CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler, ResourceRequest&amp;&amp; newRequest) mutable {
195         if (newRequest.isNull() || reachedTerminalState())
196             return completionHandler(WTFMove(newRequest));
197 
198         ResourceLoader::willSendRequestInternal(WTFMove(newRequest), redirectResponse, [this, protectedThis = WTFMove(protectedThis), completionHandler = WTFMove(completionHandler), redirectResponse] (ResourceRequest&amp;&amp; request) mutable {
199             if (reachedTerminalState())
200                 return completionHandler(WTFMove(request));
201 
202             if (request.isNull()) {
203                 cancel();
204                 return completionHandler(WTFMove(request));
205             }
206 
207             if (m_resource-&gt;type() == CachedResource::Type::MainResource &amp;&amp; !redirectResponse.isNull())
208                 m_documentLoader-&gt;willContinueMainResourceLoadAfterRedirect(request);
209             completionHandler(WTFMove(request));
210         });
211     };
212 
213     ASSERT(!newRequest.isNull());
214     if (!redirectResponse.isNull()) {
215         if (options().redirect != FetchOptions::Redirect::Follow) {
216             if (options().redirect == FetchOptions::Redirect::Error) {
217                 ResourceError error { errorDomainWebKitInternal, 0, request().url(), makeString(&quot;Not allowed to follow a redirection while loading &quot;, request().url().string()), ResourceError::Type::AccessControl };
218 
219                 if (m_frame &amp;&amp; m_frame-&gt;document())
220                     m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, error.localizedDescription());
221 
222                 RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because not allowed to follow a redirect (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
223 
224                 cancel(error);
225                 return completionHandler(WTFMove(newRequest));
226             }
227 
228             ResourceResponse opaqueRedirectedResponse = redirectResponse;
229             opaqueRedirectedResponse.setType(ResourceResponse::Type::Opaqueredirect);
230             opaqueRedirectedResponse.setTainting(ResourceResponse::Tainting::Opaqueredirect);
231             m_resource-&gt;responseReceived(opaqueRedirectedResponse);
232             if (reachedTerminalState()) {
233                 RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: reached terminal state (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
234                 return;
235             }
236 
237             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load completed (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
238 
239             NetworkLoadMetrics emptyMetrics;
240             didFinishLoading(emptyMetrics);
241             return completionHandler(WTFMove(newRequest));
242         } else if (m_redirectCount++ &gt;= options().maxRedirectCount) {
243             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because too many redirects (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
244             cancel(ResourceError(String(), 0, request().url(), &quot;Too many redirections&quot;_s, ResourceError::Type::General));
245             return completionHandler(WTFMove(newRequest));
246         }
247 
248         // CachedResources are keyed off their original request URL.
249         // Requesting the same original URL a second time can redirect to a unique second resource.
250         // Therefore, if a redirect to a different destination URL occurs, we should no longer consider this a revalidation of the first resource.
251         // Doing so would have us reusing the resource from the first request if the second request&#39;s revalidation succeeds.
252         if (newRequest.isConditional() &amp;&amp; m_resource-&gt;resourceToRevalidate() &amp;&amp; newRequest.url() != m_resource-&gt;resourceToRevalidate()-&gt;response().url()) {
253             newRequest.makeUnconditional();
254             MemoryCache::singleton().revalidationFailed(*m_resource);
255             if (m_frame &amp;&amp; m_frame-&gt;page())
256                 m_frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::cachedResourceRevalidationKey(), emptyString(), DiagnosticLoggingResultFail, ShouldSample::Yes);
257         }
258 
259         if (!m_documentLoader-&gt;cachedResourceLoader().updateRequestAfterRedirection(m_resource-&gt;type(), newRequest, options())) {
260             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because something about updateRequestAfterRedirection (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
261             cancel();
262             return completionHandler(WTFMove(newRequest));
263         }
264 
265         String errorDescription;
266         if (!checkRedirectionCrossOriginAccessControl(request(), redirectResponse, newRequest, errorDescription)) {
267             String errorMessage = &quot;Cross-origin redirection to &quot; + newRequest.url().string() + &quot; denied by Cross-Origin Resource Sharing policy: &quot; + errorDescription;
268             if (m_frame &amp;&amp; m_frame-&gt;document())
269                 m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, errorMessage);
270             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because crosss-origin redirection denied by CORS policy (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
271             cancel(ResourceError(String(), 0, request().url(), errorMessage, ResourceError::Type::AccessControl));
272             return completionHandler(WTFMove(newRequest));
273         }
274 
275         if (m_resource-&gt;isImage() &amp;&amp; m_documentLoader-&gt;cachedResourceLoader().shouldDeferImageLoad(newRequest.url())) {
276             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because it&#39;s an image that should be defered (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
277             cancel();
278             return completionHandler(WTFMove(newRequest));
279         }
280         m_loadTiming.addRedirect(redirectResponse.url(), newRequest.url());
281         m_resource-&gt;redirectReceived(WTFMove(newRequest), redirectResponse, [completionHandler = WTFMove(completionHandler), continueWillSendRequest = WTFMove(continueWillSendRequest)] (ResourceRequest&amp;&amp; request) mutable {
282             continueWillSendRequest(WTFMove(completionHandler), WTFMove(request));
283         });
284         return;
285     }
286 
287     continueWillSendRequest(WTFMove(completionHandler), WTFMove(newRequest));
288 }
289 
290 void SubresourceLoader::didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent)
291 {
292     ASSERT(m_state == Initialized);
293     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
294     m_resource-&gt;didSendData(bytesSent, totalBytesToBeSent);
295 }
296 
297 #if USE(QUICK_LOOK)
298 
299 bool SubresourceLoader::shouldCreatePreviewLoaderForResponse(const ResourceResponse&amp; response) const
300 {
301     if (m_resource-&gt;type() != CachedResource::Type::MainResource)
302         return false;
303 
304     if (m_previewLoader)
305         return false;
306 
<a name="11" id="anc11"></a><span class="line-modified">307     return PreviewLoader::shouldCreateForMIMEType(response.mimeType());</span>
308 }
309 
310 #endif
311 
312 void SubresourceLoader::didReceiveResponse(const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; policyCompletionHandler)
313 {
314     ASSERT(!response.isNull());
315     ASSERT(m_state == Initialized);
316 
317     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(policyCompletionHandler));
318 
319 #if USE(QUICK_LOOK)
320     if (shouldCreatePreviewLoaderForResponse(response)) {
321         m_previewLoader = PreviewLoader::create(*this, response);
<a name="12" id="anc12"></a><span class="line-modified">322         return;</span>

323     }
324 #endif
325 #if ENABLE(SERVICE_WORKER)
326     // Implementing step 10 of https://fetch.spec.whatwg.org/#main-fetch for service worker responses.
327     if (response.source() == ResourceResponse::Source::ServiceWorker &amp;&amp; response.url() != request().url()) {
328         auto&amp; loader = m_documentLoader-&gt;cachedResourceLoader();
329         if (!loader.allowedByContentSecurityPolicy(m_resource-&gt;type(), response.url(), options(), ContentSecurityPolicy::RedirectResponseReceived::Yes)) {
330             RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because not allowed by content policy (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
331             cancel(ResourceError({ }, 0, response.url(), { }, ResourceError::Type::General));
332             return;
333         }
334     }
335 #endif
336 
337     // We want redirect responses to be processed through willSendRequestInternal. Exceptions are
338     // redirection with no Location headers and fetch in manual redirect mode. Or in rare circumstances,
339     // cases of too many redirects from CFNetwork (&lt;rdar://problem/30610988&gt;).
340 #if !PLATFORM(COCOA)
341     ASSERT(response.httpStatusCode() &lt; 300 || response.httpStatusCode() &gt;= 400 || response.httpStatusCode() == 304 || !response.httpHeaderField(HTTPHeaderName::Location) || response.type() == ResourceResponse::Type::Opaqueredirect);
342 #endif
343 
344     // Reference the object in this method since the additional processing can do
345     // anything including removing the last reference to this object; one example of this is 3266216.
346     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
347 
348     if (shouldIncludeCertificateInfo())
349         response.includeCertificateInfo();
350 
351     if (m_resource-&gt;resourceToRevalidate()) {
352         if (response.httpStatusCode() == 304) {
353             // 304 Not modified / Use local copy
354             // Existing resource is ok, just use it updating the expiration time.
355             ResourceResponse revalidationResponse = response;
356             revalidationResponse.setSource(ResourceResponse::Source::MemoryCacheAfterValidation);
357             m_resource-&gt;setResponse(revalidationResponse);
358             MemoryCache::singleton().revalidationSucceeded(*m_resource, revalidationResponse);
359             if (m_frame &amp;&amp; m_frame-&gt;page())
360                 m_frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::cachedResourceRevalidationKey(), emptyString(), DiagnosticLoggingResultPass, ShouldSample::Yes);
361             if (!reachedTerminalState())
362                 ResourceLoader::didReceiveResponse(revalidationResponse, [completionHandlerCaller = WTFMove(completionHandlerCaller)] { });
363             return;
364         }
365         // Did not get 304 response, continue as a regular resource load.
366         MemoryCache::singleton().revalidationFailed(*m_resource);
367         if (m_frame &amp;&amp; m_frame-&gt;page())
368             m_frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::cachedResourceRevalidationKey(), emptyString(), DiagnosticLoggingResultFail, ShouldSample::Yes);
369     }
370 
371     String errorDescription;
372     if (!checkResponseCrossOriginAccessControl(response, errorDescription)) {
373         if (m_frame &amp;&amp; m_frame-&gt;document())
374             m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, errorDescription);
375         RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because of cross origin access control (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
376         cancel(ResourceError(String(), 0, request().url(), errorDescription, ResourceError::Type::AccessControl));
377         return;
378     }
379 
380     m_resource-&gt;responseReceived(response);
381     if (reachedTerminalState())
382         return;
383 
384     bool isResponseMultipart = response.isMultipart();
385     if (options().mode != FetchOptions::Mode::Navigate)
386         LinkLoader::loadLinksFromHeader(response.httpHeaderField(HTTPHeaderName::Link), m_documentLoader-&gt;url(), *m_frame-&gt;document(), LinkLoader::MediaAttributeCheck::SkipMediaAttributeCheck);
387     ResourceLoader::didReceiveResponse(response, [this, protectedThis = WTFMove(protectedThis), isResponseMultipart, completionHandlerCaller = WTFMove(completionHandlerCaller)]() mutable {
388         if (reachedTerminalState())
389             return;
390 
391         // FIXME: Main resources have a different set of rules for multipart than images do.
392         // Hopefully we can merge those 2 paths.
393         if (isResponseMultipart &amp;&amp; m_resource-&gt;type() != CachedResource::Type::MainResource) {
394             m_loadingMultipartContent = true;
395 
396             // We don&#39;t count multiParts in a CachedResourceLoader&#39;s request count
397             m_requestCountTracker = WTF::nullopt;
398             if (!m_resource-&gt;isImage()) {
399                 RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because something about a multi-part non-image (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
400                 cancel();
401                 return;
402             }
403         }
404 
405         auto* buffer = resourceData();
406         if (m_loadingMultipartContent &amp;&amp; buffer &amp;&amp; buffer-&gt;size()) {
407             // The resource data will change as the next part is loaded, so we need to make a copy.
408             m_resource-&gt;finishLoading(buffer-&gt;copy().ptr());
409             clearResourceData();
410             // Since a subresource loader does not load multipart sections progressively, data was delivered to the loader all at once.
411             // After the first multipart section is complete, signal to delegates that this load is &quot;finished&quot;
412             NetworkLoadMetrics emptyMetrics;
413             m_documentLoader-&gt;subresourceLoaderFinishedLoadingOnePart(this);
414             didFinishLoadingOnePart(emptyMetrics);
415         }
416 
417         checkForHTTPStatusCodeError();
418 
419         if (m_inAsyncResponsePolicyCheck)
420             m_policyForResponseCompletionHandler = completionHandlerCaller.release();
421     });
422 }
423 
424 void SubresourceLoader::didReceiveResponsePolicy()
425 {
426     ASSERT(m_inAsyncResponsePolicyCheck);
427     m_inAsyncResponsePolicyCheck = false;
428     if (auto completionHandler = WTFMove(m_policyForResponseCompletionHandler))
429         completionHandler();
430 }
431 
432 void SubresourceLoader::didReceiveData(const char* data, unsigned length, long long encodedDataLength, DataPayloadType dataPayloadType)
433 {
434 #if USE(QUICK_LOOK)
435     if (auto previewLoader = m_previewLoader.get()) {
436         if (previewLoader-&gt;didReceiveData(data, length))
437             return;
438     }
439 #endif
440 
441     didReceiveDataOrBuffer(data, length, nullptr, encodedDataLength, dataPayloadType);
442 }
443 
444 void SubresourceLoader::didReceiveBuffer(Ref&lt;SharedBuffer&gt;&amp;&amp; buffer, long long encodedDataLength, DataPayloadType dataPayloadType)
445 {
446 #if USE(QUICK_LOOK)
447     if (auto previewLoader = m_previewLoader.get()) {
448         if (previewLoader-&gt;didReceiveBuffer(buffer.get()))
449             return;
450     }
451 #endif
452 
453     didReceiveDataOrBuffer(nullptr, 0, WTFMove(buffer), encodedDataLength, dataPayloadType);
454 }
455 
456 void SubresourceLoader::didReceiveDataOrBuffer(const char* data, int length, RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, long long encodedDataLength, DataPayloadType dataPayloadType)
457 {
458     ASSERT(m_resource);
459 
460     if (m_resource-&gt;response().httpStatusCode() &gt;= 400 &amp;&amp; !m_resource-&gt;shouldIgnoreHTTPStatusCodeErrors())
461         return;
462     ASSERT(!m_resource-&gt;resourceToRevalidate());
463     ASSERT(!m_resource-&gt;errorOccurred());
464     ASSERT(m_state == Initialized);
465     // Reference the object in this method since the additional processing can do
466     // anything including removing the last reference to this object; one example of this is 3266216.
467     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
468 
469     ResourceLoader::didReceiveDataOrBuffer(data, length, buffer.copyRef(), encodedDataLength, dataPayloadType);
470 
471     if (!m_loadingMultipartContent) {
472         if (auto* resourceData = this-&gt;resourceData())
473             m_resource-&gt;updateBuffer(*resourceData);
474         else
475             m_resource-&gt;updateData(buffer ? buffer-&gt;data() : data, buffer ? buffer-&gt;size() : length);
476     }
477 }
478 
479 bool SubresourceLoader::checkForHTTPStatusCodeError()
480 {
481     if (m_resource-&gt;response().httpStatusCode() &lt; 400 || m_resource-&gt;shouldIgnoreHTTPStatusCodeErrors())
482         return false;
483 
484     m_state = Finishing;
485     m_resource-&gt;error(CachedResource::LoadError);
486     cancel();
487     return true;
488 }
489 
490 static void logResourceLoaded(Frame* frame, CachedResource::Type type)
491 {
492     if (!frame || !frame-&gt;page())
493         return;
494 
495     String resourceType;
496     switch (type) {
497     case CachedResource::Type::MainResource:
498         resourceType = DiagnosticLoggingKeys::mainResourceKey();
499         break;
500     case CachedResource::Type::ImageResource:
501         resourceType = DiagnosticLoggingKeys::imageKey();
502         break;
503 #if ENABLE(XSLT)
504     case CachedResource::Type::XSLStyleSheet:
505 #endif
506     case CachedResource::Type::CSSStyleSheet:
507         resourceType = DiagnosticLoggingKeys::styleSheetKey();
508         break;
509     case CachedResource::Type::Script:
510         resourceType = DiagnosticLoggingKeys::scriptKey();
511         break;
512     case CachedResource::Type::FontResource:
513 #if ENABLE(SVG_FONTS)
514     case CachedResource::Type::SVGFontResource:
515 #endif
516         resourceType = DiagnosticLoggingKeys::fontKey();
517         break;
518     case CachedResource::Type::Beacon:
<a name="13" id="anc13"></a><span class="line-modified">519         ASSERT_NOT_REACHED();</span>
<span class="line-removed">520         break;</span>
521     case CachedResource::Type::MediaResource:
522     case CachedResource::Type::Icon:
523     case CachedResource::Type::RawResource:
524         resourceType = DiagnosticLoggingKeys::rawKey();
525         break;
526     case CachedResource::Type::SVGDocumentResource:
527         resourceType = DiagnosticLoggingKeys::svgDocumentKey();
528         break;
529 #if ENABLE(APPLICATION_MANIFEST)
530     case CachedResource::Type::ApplicationManifest:
531         resourceType = DiagnosticLoggingKeys::applicationManifestKey();
532         break;
533 #endif
534     case CachedResource::Type::LinkPrefetch:
535 #if ENABLE(VIDEO_TRACK)
536     case CachedResource::Type::TextTrackResource:
537 #endif
538         resourceType = DiagnosticLoggingKeys::otherKey();
539         break;
540     }
541 
542     frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessage(DiagnosticLoggingKeys::resourceLoadedKey(), resourceType, ShouldSample::Yes);
543 }
544 
545 bool SubresourceLoader::checkResponseCrossOriginAccessControl(const ResourceResponse&amp; response, String&amp; errorDescription)
546 {
547     if (!m_resource-&gt;isCrossOrigin() || options().mode != FetchOptions::Mode::Cors)
548         return true;
549 
550 #if ENABLE(SERVICE_WORKER)
551     if (response.source() == ResourceResponse::Source::ServiceWorker)
552         return response.tainting() != ResourceResponse::Tainting::Opaque;
553 #endif
554 
555     ASSERT(m_origin);
556 
557     return passesAccessControlCheck(response, options().credentials == FetchOptions::Credentials::Include ? StoredCredentialsPolicy::Use : StoredCredentialsPolicy::DoNotUse, *m_origin, errorDescription);
558 }
559 
560 bool SubresourceLoader::checkRedirectionCrossOriginAccessControl(const ResourceRequest&amp; previousRequest, const ResourceResponse&amp; redirectResponse, ResourceRequest&amp; newRequest, String&amp; errorMessage)
561 {
562     bool crossOriginFlag = m_resource-&gt;isCrossOrigin();
563     bool isNextRequestCrossOrigin = m_origin &amp;&amp; !m_origin-&gt;canRequest(newRequest.url());
564 
565     if (isNextRequestCrossOrigin)
566         m_resource-&gt;setCrossOrigin();
567 
568     ASSERT(options().mode != FetchOptions::Mode::SameOrigin || !m_resource-&gt;isCrossOrigin());
569 
570     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 7 &amp; 8.
571     if (options().mode == FetchOptions::Mode::Cors) {
572         if (m_resource-&gt;isCrossOrigin() &amp;&amp; !isValidCrossOriginRedirectionURL(newRequest.url())) {
573             errorMessage = &quot;URL is either a non-HTTP URL or contains credentials.&quot;_s;
574             return false;
575         }
576 
577         ASSERT(m_origin);
578         if (crossOriginFlag &amp;&amp; !passesAccessControlCheck(redirectResponse, options().storedCredentialsPolicy, *m_origin, errorMessage))
579             return false;
580     }
581 
582     bool redirectingToNewOrigin = false;
583     if (m_resource-&gt;isCrossOrigin()) {
584         if (!crossOriginFlag &amp;&amp; isNextRequestCrossOrigin)
585             redirectingToNewOrigin = true;
586         else
587             redirectingToNewOrigin = !protocolHostAndPortAreEqual(previousRequest.url(), newRequest.url());
588     }
589 
590     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 10.
591     if (crossOriginFlag &amp;&amp; redirectingToNewOrigin)
592         m_origin = SecurityOrigin::createUnique();
593 
594     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 14.
595     updateReferrerPolicy(redirectResponse.httpHeaderField(HTTPHeaderName::ReferrerPolicy));
596 
597     if (options().mode == FetchOptions::Mode::Cors &amp;&amp; redirectingToNewOrigin) {
598         cleanHTTPRequestHeadersForAccessControl(newRequest, options().httpHeadersToKeep);
599         updateRequestForAccessControl(newRequest, *m_origin, options().storedCredentialsPolicy);
600     }
601 
602     updateRequestReferrer(newRequest, referrerPolicy(), previousRequest.httpReferrer());
603 
604     return true;
605 }
606 
607 void SubresourceLoader::updateReferrerPolicy(const String&amp; referrerPolicyValue)
608 {
609     if (auto referrerPolicy = parseReferrerPolicy(referrerPolicyValue, ReferrerPolicySource::HTTPHeader)) {
610         ASSERT(*referrerPolicy != ReferrerPolicy::EmptyString);
611         setReferrerPolicy(*referrerPolicy);
612     }
613 }
614 
615 void SubresourceLoader::didFinishLoading(const NetworkLoadMetrics&amp; networkLoadMetrics)
616 {
617     RELEASE_LOG_IF_ALLOWED(&quot;didFinishLoading: (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
618 
619 #if USE(QUICK_LOOK)
620     if (auto previewLoader = m_previewLoader.get()) {
621         if (previewLoader-&gt;didFinishLoading())
622             return;
623     }
624 #endif
625 
626     if (m_state != Initialized)
627         return;
628     ASSERT(!reachedTerminalState());
629     ASSERT(!m_resource-&gt;resourceToRevalidate());
630     // FIXME (129394): We should cancel the load when a decode error occurs instead of continuing the load to completion.
631     ASSERT(!m_resource-&gt;errorOccurred() || m_resource-&gt;status() == CachedResource::DecodeError || !m_resource-&gt;isLoading());
632     LOG(ResourceLoading, &quot;Received &#39;%s&#39;.&quot;, m_resource-&gt;url().string().latin1().data());
633     logResourceLoaded(m_frame.get(), m_resource-&gt;type());
634 
635     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
636     CachedResourceHandle&lt;CachedResource&gt; protectResource(m_resource);
637 
638     // FIXME: Remove this with deprecatedNetworkLoadMetrics.
639     m_loadTiming.setResponseEnd(MonotonicTime::now());
640 
641     if (networkLoadMetrics.isComplete())
642         reportResourceTiming(networkLoadMetrics);
643     else {
644         // This is the legacy path for platforms (and ResourceHandle paths) that do not provide
645         // complete load metrics in didFinishLoad. In those cases, fall back to the possibility
646         // that they populated partial load timing information on the ResourceResponse.
647         reportResourceTiming(m_resource-&gt;response().deprecatedNetworkLoadMetrics());
648     }
649 
650     if (m_resource-&gt;type() != CachedResource::Type::MainResource)
651         tracePoint(SubresourceLoadDidEnd);
652 
653     m_state = Finishing;
654     m_resource-&gt;finishLoading(resourceData());
655 
656     if (wasCancelled()) {
657         RELEASE_LOG_IF_ALLOWED(&quot;didFinishLoading: was canceled (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
658         return;
659     }
660 
661     m_resource-&gt;finish();
662     ASSERT(!reachedTerminalState());
663     didFinishLoadingOnePart(networkLoadMetrics);
664     notifyDone(LoadCompletionType::Finish);
665 
666     if (reachedTerminalState()) {
667         RELEASE_LOG_IF_ALLOWED(&quot;didFinishLoading: reached terminal state (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
668         return;
669     }
670     releaseResources();
671 }
672 
673 void SubresourceLoader::didFail(const ResourceError&amp; error)
674 {
675     RELEASE_LOG_IF_ALLOWED(&quot;didFail: (frame = %p, frameLoader = %p, resourceID = %lu, type = %d, code = %d)&quot;, frame(), frameLoader(), identifier(), static_cast&lt;int&gt;(error.type()), error.errorCode());
676 
677 #if USE(QUICK_LOOK)
678     if (auto previewLoader = m_previewLoader.get())
679         previewLoader-&gt;didFail();
680 #endif
681 
682     if (m_state != Initialized)
683         return;
684 
685     ASSERT(!reachedTerminalState());
686     LOG(ResourceLoading, &quot;Failed to load &#39;%s&#39;.\n&quot;, m_resource-&gt;url().string().latin1().data());
687 
<a name="14" id="anc14"></a><span class="line-modified">688     if (m_frame-&gt;document() &amp;&amp; error.isAccessControl())</span>
689         m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, error.localizedDescription());
690 
<a name="15" id="anc15"></a><span class="line-removed">691 </span>
692     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
693     CachedResourceHandle&lt;CachedResource&gt; protectResource(m_resource);
694     m_state = Finishing;
695 
696     if (m_resource-&gt;type() != CachedResource::Type::MainResource)
697         tracePoint(SubresourceLoadDidEnd);
698 
699     if (m_resource-&gt;resourceToRevalidate())
700         MemoryCache::singleton().revalidationFailed(*m_resource);
701     m_resource-&gt;setResourceError(error);
702     if (!m_resource-&gt;isPreloaded())
703         MemoryCache::singleton().remove(*m_resource);
704     m_resource-&gt;error(CachedResource::LoadError);
705     cleanupForError(error);
706     notifyDone(LoadCompletionType::Cancel);
707     if (reachedTerminalState())
708         return;
709     releaseResources();
710 }
711 
712 void SubresourceLoader::willCancel(const ResourceError&amp; error)
713 {
714     RELEASE_LOG_IF_ALLOWED(&quot;willCancel: (frame = %p, frameLoader = %p, resourceID = %lu, type = %d, code = %d)&quot;, frame(), frameLoader(), identifier(), static_cast&lt;int&gt;(error.type()), error.errorCode());
715 
716 #if PLATFORM(IOS_FAMILY)
717     // Since we defer initialization to scheduling time on iOS but
718     // CachedResourceLoader stores resources in the memory cache immediately,
719     // m_resource might be cached despite its loader not being initialized.
720     if (m_state != Initialized &amp;&amp; m_state != Uninitialized)
721 #else
722     if (m_state != Initialized)
723 #endif
724         return;
725 
726     ASSERT(!reachedTerminalState());
727     LOG(ResourceLoading, &quot;Cancelled load of &#39;%s&#39;.\n&quot;, m_resource-&gt;url().string().latin1().data());
728 
729     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
730 #if PLATFORM(IOS_FAMILY)
731     m_state = m_state == Uninitialized ? CancelledWhileInitializing : Finishing;
732 #else
733     m_state = Finishing;
734 #endif
735     auto&amp; memoryCache = MemoryCache::singleton();
736     if (m_resource-&gt;resourceToRevalidate())
737         memoryCache.revalidationFailed(*m_resource);
738     m_resource-&gt;setResourceError(error);
739     memoryCache.remove(*m_resource);
740 }
741 
742 void SubresourceLoader::didCancel(const ResourceError&amp;)
743 {
744     if (m_state == Uninitialized)
745         return;
746 
747     if (m_resource-&gt;type() != CachedResource::Type::MainResource)
748         tracePoint(SubresourceLoadDidEnd);
749 
750     m_resource-&gt;cancelLoad();
751     notifyDone(LoadCompletionType::Cancel);
752 }
753 
754 void SubresourceLoader::notifyDone(LoadCompletionType type)
755 {
756     if (reachedTerminalState())
757         return;
758 
759     m_requestCountTracker = WTF::nullopt;
760     bool shouldPerformPostLoadActions = true;
761 #if PLATFORM(IOS_FAMILY)
762     if (m_state == CancelledWhileInitializing)
763         shouldPerformPostLoadActions = false;
764 #endif
765     m_documentLoader-&gt;cachedResourceLoader().loadDone(type, shouldPerformPostLoadActions);
766     if (reachedTerminalState())
767         return;
768     m_documentLoader-&gt;removeSubresourceLoader(type, this);
769 }
770 
771 void SubresourceLoader::releaseResources()
772 {
773     ASSERT(!reachedTerminalState());
774 #if PLATFORM(IOS_FAMILY)
775     if (m_state != Uninitialized &amp;&amp; m_state != CancelledWhileInitializing)
776 #else
777     if (m_state != Uninitialized)
778 #endif
779         m_resource-&gt;clearLoader();
780     m_resource = nullptr;
781     ResourceLoader::releaseResources();
782 }
783 
784 void SubresourceLoader::reportResourceTiming(const NetworkLoadMetrics&amp; networkLoadMetrics)
785 {
786     if (!RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
787         return;
788 
789     if (!ResourceTimingInformation::shouldAddResourceTiming(*m_resource))
790         return;
791 
792     Document* document = m_documentLoader-&gt;cachedResourceLoader().document();
793     if (!document)
794         return;
795 
796     SecurityOrigin&amp; origin = m_origin ? *m_origin : document-&gt;securityOrigin();
797     auto resourceTiming = ResourceTiming::fromLoad(*m_resource, m_resource-&gt;initiatorName(), m_loadTiming, networkLoadMetrics, origin);
798 
799     // Worker resources loaded here are all CachedRawResources loaded through WorkerThreadableLoader.
800     // Pass the ResourceTiming information on so that WorkerThreadableLoader may add them to the
801     // Worker&#39;s Performance object.
802     if (options().initiatorContext == InitiatorContext::Worker) {
803         ASSERT(m_origin);
804         ASSERT(is&lt;CachedRawResource&gt;(m_resource));
805         downcast&lt;CachedRawResource&gt;(*m_resource).finishedTimingForWorkerLoad(WTFMove(resourceTiming));
806         return;
807     }
808 
809     ASSERT(options().initiatorContext == InitiatorContext::Document);
810     m_documentLoader-&gt;cachedResourceLoader().resourceTimingInformation().addResourceTiming(*m_resource, *document, WTFMove(resourceTiming));
811 }
812 
813 const HTTPHeaderMap* SubresourceLoader::originalHeaders() const
814 {
815     return (m_resource  &amp;&amp; m_resource-&gt;originalRequest()) ? &amp;m_resource-&gt;originalRequest()-&gt;httpHeaderFields() : nullptr;
816 }
817 
818 }
819 
820 #undef RELEASE_LOG_IF_ALLOWED
821 #undef RELEASE_LOG_ERROR_IF_ALLOWED
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>