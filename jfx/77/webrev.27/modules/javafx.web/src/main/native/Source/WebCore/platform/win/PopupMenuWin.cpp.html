<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/win/PopupMenuWin.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2008, 2011, 2015 Apple Inc. All rights reserved.
   3  * Copyright (C) 2007-2009 Torch Mobile Inc.
   4  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public License
  17  * along with this library; see the file COPYING.LIB.  If not, write to
  18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;PopupMenuWin.h&quot;
  25 
  26 #include &quot;BString.h&quot;
  27 #include &quot;BitmapInfo.h&quot;
  28 #include &quot;Document.h&quot;
  29 #include &quot;FloatRect.h&quot;
  30 #include &quot;Font.h&quot;
  31 #include &quot;FontSelector.h&quot;
  32 #include &quot;Frame.h&quot;
  33 #include &quot;FrameView.h&quot;
  34 #include &quot;GDIUtilities.h&quot;
  35 #include &quot;GraphicsContext.h&quot;
  36 #include &quot;HTMLNames.h&quot;
  37 #include &quot;HWndDC.h&quot;
  38 #include &quot;HostWindow.h&quot;
  39 #include &quot;LengthFunctions.h&quot;
  40 #include &quot;NotImplemented.h&quot;
  41 #include &quot;Page.h&quot;
  42 #include &quot;PlatformMouseEvent.h&quot;
  43 #include &quot;PlatformScreen.h&quot;
  44 #include &quot;RenderMenuList.h&quot;
  45 #include &quot;RenderTheme.h&quot;
  46 #include &quot;RenderView.h&quot;
  47 #include &quot;Scrollbar.h&quot;
  48 #include &quot;ScrollbarTheme.h&quot;
  49 #include &quot;ScrollbarThemeWin.h&quot;
  50 #include &quot;TextRun.h&quot;
  51 #include &quot;WebCoreInstanceHandle.h&quot;
  52 #include &lt;wtf/WindowsExtras.h&gt;
  53 
  54 #include &lt;windows.h&gt;
  55 #include &lt;windowsx.h&gt;
  56 
  57 #define HIGH_BIT_MASK_SHORT 0x8000
  58 
  59 using std::min;
  60 
  61 namespace WebCore {
  62 
  63 using namespace HTMLNames;
  64 
  65 // Default Window animation duration in milliseconds
  66 static const int defaultAnimationDuration = 200;
  67 // Maximum height of a popup window
  68 static const int maxPopupHeight = 320;
  69 
  70 const int optionSpacingMiddle = 1;
  71 const int popupWindowBorderWidth = 1;
  72 
  73 static LPCWSTR kPopupWindowClassName = L&quot;PopupWindowClass&quot;;
  74 
  75 // This is used from within our custom message pump when we want to send a
  76 // message to the web view and not have our message stolen and sent to
  77 // the popup window.
  78 static const UINT WM_HOST_WINDOW_FIRST = WM_USER;
  79 static const UINT WM_HOST_WINDOW_CHAR = WM_USER + WM_CHAR;
  80 static const UINT WM_HOST_WINDOW_MOUSEMOVE = WM_USER + WM_MOUSEMOVE;
  81 
  82 // FIXME: Remove this as soon as practical.
  83 static inline bool isASCIIPrintable(unsigned c)
  84 {
  85     return c &gt;= 0x20 &amp;&amp; c &lt;= 0x7E;
  86 }
  87 
  88 static void translatePoint(LPARAM&amp; lParam, HWND from, HWND to)
  89 {
  90     POINT pt;
  91     pt.x = (short)GET_X_LPARAM(lParam);
  92     pt.y = (short)GET_Y_LPARAM(lParam);
  93     ::MapWindowPoints(from, to, &amp;pt, 1);
  94     lParam = MAKELPARAM(pt.x, pt.y);
  95 }
  96 
  97 static FloatRect monitorFromHwnd(HWND hwnd)
  98 {
  99     HMONITOR monitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTOPRIMARY);
 100     MONITORINFOEX monitorInfo;
 101     monitorInfo.cbSize = sizeof(MONITORINFOEX);
 102     GetMonitorInfo(monitor, &amp;monitorInfo);
 103     return monitorInfo.rcWork;
 104 }
 105 
 106 PopupMenuWin::PopupMenuWin(PopupMenuClient* client)
 107     : m_popupClient(client)
 108 {
 109 }
 110 
 111 PopupMenuWin::~PopupMenuWin()
 112 {
 113     if (m_popup)
 114         ::DestroyWindow(m_popup);
 115     if (m_scrollbar)
 116         m_scrollbar-&gt;setParent(0);
 117 }
 118 
 119 void PopupMenuWin::disconnectClient()
 120 {
 121     m_popupClient = 0;
 122 }
 123 
 124 LPCWSTR PopupMenuWin::popupClassName()
 125 {
 126     return kPopupWindowClassName;
 127 }
 128 
 129 void PopupMenuWin::show(const IntRect&amp; r, FrameView* view, int index)
 130 {
 131     if (view &amp;&amp; view-&gt;frame().page())
 132         m_scaleFactor = view-&gt;frame().page()-&gt;deviceScaleFactor();
 133 
 134     calculatePositionAndSize(r, view);
 135     if (clientRect().isEmpty())
 136         return;
 137 
 138     HWND hostWindow = view-&gt;hostWindow()-&gt;platformPageClient();
 139 
 140     if (!m_scrollbar &amp;&amp; visibleItems() &lt; client()-&gt;listSize()) {
 141         // We need a scroll bar
 142         m_scrollbar = client()-&gt;createScrollbar(*this, VerticalScrollbar, SmallScrollbar);
 143         m_scrollbar-&gt;styleChanged();
 144     }
 145 
 146     // We need to reposition the popup window to its final coordinates.
 147     // Before calling this, the popup hwnd is currently the size of and at the location of the menu list client so it needs to be updated.
 148     ::MoveWindow(m_popup, m_windowRect.x(), m_windowRect.y(), m_windowRect.width(), m_windowRect.height(), false);
 149 
 150     // Determine whether we should animate our popups
 151     // Note: Must use &#39;BOOL&#39; and &#39;FALSE&#39; instead of &#39;bool&#39; and &#39;false&#39; to avoid stack corruption with SystemParametersInfo
 152     BOOL shouldAnimate = FALSE;
 153 
 154     if (client()) {
 155         int index = client()-&gt;selectedIndex();
 156         if (index &gt;= 0)
 157             setFocusedIndex(index);
 158     }
 159 
 160     if (!::SystemParametersInfo(SPI_GETCOMBOBOXANIMATION, 0, &amp;shouldAnimate, 0))
 161         shouldAnimate = FALSE;
 162 
 163     if (shouldAnimate) {
 164         RECT viewRect { };
 165         ::GetWindowRect(hostWindow, &amp;viewRect);
 166         if (!::IsRectEmpty(&amp;viewRect))
 167             ::AnimateWindow(m_popup, defaultAnimationDuration, AW_BLEND);
 168     } else
 169         ::ShowWindow(m_popup, SW_SHOWNOACTIVATE);
 170 
 171     m_showPopup = true;
 172 
 173     // Protect the popup menu in case its owner is destroyed while we&#39;re running the message pump.
 174     RefPtr&lt;PopupMenu&gt; protectedThis(this);
 175 
 176     ::SetCapture(hostWindow);
 177 
 178     MSG msg;
 179     HWND activeWindow;
 180 
 181     while (::GetMessage(&amp;msg, 0, 0, 0)) {
 182         switch (msg.message) {
 183             case WM_HOST_WINDOW_MOUSEMOVE:
 184             case WM_HOST_WINDOW_CHAR:
 185                 if (msg.hwnd == m_popup) {
 186                     // This message should be sent to the host window.
 187                     msg.hwnd = hostWindow;
 188                     msg.message -= WM_HOST_WINDOW_FIRST;
 189                 }
 190                 break;
 191 
 192             // Steal mouse messages.
 193             case WM_NCMOUSEMOVE:
 194             case WM_NCLBUTTONDOWN:
 195             case WM_NCLBUTTONUP:
 196             case WM_NCLBUTTONDBLCLK:
 197             case WM_NCRBUTTONDOWN:
 198             case WM_NCRBUTTONUP:
 199             case WM_NCRBUTTONDBLCLK:
 200             case WM_NCMBUTTONDOWN:
 201             case WM_NCMBUTTONUP:
 202             case WM_NCMBUTTONDBLCLK:
 203             case WM_MOUSEWHEEL:
 204                 msg.hwnd = m_popup;
 205                 break;
 206 
 207             // These mouse messages use client coordinates so we need to convert them.
 208             case WM_MOUSEMOVE:
 209             case WM_LBUTTONDOWN:
 210             case WM_LBUTTONUP:
 211             case WM_LBUTTONDBLCLK:
 212             case WM_RBUTTONDOWN:
 213             case WM_RBUTTONUP:
 214             case WM_RBUTTONDBLCLK:
 215             case WM_MBUTTONDOWN:
 216             case WM_MBUTTONUP:
 217             case WM_MBUTTONDBLCLK: {
 218                 // Translate the coordinate.
 219                 translatePoint(msg.lParam, msg.hwnd, m_popup);
 220 
 221                 msg.hwnd = m_popup;
 222                 break;
 223             }
 224 
 225             // Steal all keyboard messages.
 226             case WM_KEYDOWN:
 227             case WM_KEYUP:
 228             case WM_CHAR:
 229             case WM_DEADCHAR:
 230             case WM_SYSKEYDOWN:
 231             case WM_SYSKEYUP:
 232             case WM_SYSCHAR:
 233             case WM_SYSDEADCHAR:
 234                 msg.hwnd = m_popup;
 235                 break;
 236         }
 237 
 238         ::TranslateMessage(&amp;msg);
 239         ::DispatchMessage(&amp;msg);
 240 
 241         if (!m_popupClient)
 242             break;
 243 
 244         if (!m_showPopup)
 245             break;
 246         activeWindow = ::GetActiveWindow();
 247         if (activeWindow != hostWindow &amp;&amp; !::IsChild(activeWindow, hostWindow))
 248             break;
 249         if (::GetCapture() != hostWindow)
 250             break;
 251     }
 252 
 253     if (::GetCapture() == hostWindow)
 254         ::ReleaseCapture();
 255 
 256     // We&#39;re done, hide the popup if necessary.
 257     hide();
 258 }
 259 
 260 void PopupMenuWin::hide()
 261 {
 262     if (!m_showPopup)
 263         return;
 264 
 265     m_showPopup = false;
 266 
 267     ::ShowWindow(m_popup, SW_HIDE);
 268 
 269     if (client())
 270         client()-&gt;popupDidHide();
 271 
 272     // Post a WM_NULL message to wake up the message pump if necessary.
 273     ::PostMessage(m_popup, WM_NULL, 0, 0);
 274 }
 275 
 276 // The screen that the popup is placed on should be whichever one the popup menu button lies on.
 277 // We fake an hwnd (here we use the popup&#39;s hwnd) on top of the button which we can then use to determine the screen.
 278 // We can then proceed with our final position/size calculations.
 279 void PopupMenuWin::calculatePositionAndSize(const IntRect&amp; r, FrameView* v)
 280 {
 281     // First get the screen coordinates of the popup menu client.
 282     HWND hostWindow = v-&gt;hostWindow()-&gt;platformPageClient();
 283     IntRect absoluteBounds = ((RenderMenuList*)m_popupClient)-&gt;absoluteBoundingBoxRect();
 284     IntRect absoluteScreenCoords(v-&gt;contentsToWindow(absoluteBounds.location()), absoluteBounds.size());
 285     POINT absoluteLocation(absoluteScreenCoords.location());
 286     if (!::ClientToScreen(hostWindow, &amp;absoluteLocation))
 287         return;
 288     absoluteScreenCoords.setLocation(absoluteLocation);
 289 
 290     // Now set the popup menu&#39;s location temporarily to these coordinates so we can determine which screen the popup should lie on.
 291     // We create or move m_popup as necessary.
 292     if (!m_popup) {
 293         registerClass();
 294         DWORD exStyle = WS_EX_LTRREADING;
 295         m_popup = ::CreateWindowExW(exStyle, kPopupWindowClassName, L&quot;PopupMenu&quot;,
 296             WS_POPUP | WS_BORDER,
 297             absoluteScreenCoords.x(), absoluteScreenCoords.y(), absoluteScreenCoords.width(), absoluteScreenCoords.height(),
 298             hostWindow, 0, WebCore::instanceHandle(), this);
 299 
 300         if (!m_popup)
 301             return;
 302     } else
 303         ::MoveWindow(m_popup, absoluteScreenCoords.x(), absoluteScreenCoords.y(), absoluteScreenCoords.width(), absoluteScreenCoords.height(), false);
 304 
 305     FloatRect screen = monitorFromHwnd(m_popup);
 306 
 307     // Now we determine the actual location and measurements of the popup itself.
 308     // r is in absolute document coordinates, but we want to be in screen coordinates.
 309 
 310     // First, move to WebView coordinates
 311     IntRect rScreenCoords(v-&gt;contentsToWindow(r.location()), r.size());
 312     if (Page* page = v-&gt;frame().page())
 313         rScreenCoords.scale(page-&gt;deviceScaleFactor());
 314 
 315     // Then, translate to screen coordinates
 316     POINT location(rScreenCoords.location());
 317     if (!::ClientToScreen(hostWindow, &amp;location))
 318         return;
 319 
 320     rScreenCoords.setLocation(location);
 321 
 322     m_font = client()-&gt;menuStyle().font();
 323     auto d = m_font.fontDescription();
 324     d.setComputedSize(d.computedSize() * m_scaleFactor);
 325     m_font = FontCascade(WTFMove(d), m_font.letterSpacing(), m_font.wordSpacing());
 326     m_font.update(m_popupClient-&gt;fontSelector());
 327 
 328     // First, determine the popup&#39;s height
 329     int itemCount = client()-&gt;listSize();
 330     m_itemHeight = m_font.fontMetrics().height() + optionSpacingMiddle;
 331 
 332     int naturalHeight = m_itemHeight * itemCount;
 333     int popupHeight = std::min(maxPopupHeight, naturalHeight);
 334     // The popup should show an integral number of items (i.e. no partial items should be visible)
 335     popupHeight -= popupHeight % m_itemHeight;
 336 
 337     // Next determine its width
 338     int popupWidth = 0;
 339     for (int i = 0; i &lt; itemCount; ++i) {
 340         String text = client()-&gt;itemText(i);
 341         if (text.isEmpty())
 342             continue;
 343 
 344         FontCascade itemFont = m_font;
 345         if (client()-&gt;itemIsLabel(i)) {
 346             auto d = itemFont.fontDescription();
 347             d.setWeight(d.bolderWeight());
 348             itemFont = FontCascade(WTFMove(d), itemFont.letterSpacing(), itemFont.wordSpacing());
 349             itemFont.update(m_popupClient-&gt;fontSelector());
 350         }
 351 
 352         popupWidth = std::max(popupWidth, static_cast&lt;int&gt;(ceilf(itemFont.width(TextRun(text)))));
 353     }
 354 
 355     if (naturalHeight &gt; maxPopupHeight)
 356         // We need room for a scrollbar
 357         popupWidth += ScrollbarTheme::theme().scrollbarThickness(SmallScrollbar);
 358 
 359     // Add padding to align the popup text with the &lt;select&gt; text
 360     popupWidth += std::max&lt;int&gt;(0, client()-&gt;clientPaddingRight() - client()-&gt;clientInsetRight()) + std::max&lt;int&gt;(0, client()-&gt;clientPaddingLeft() - client()-&gt;clientInsetLeft());
 361 
 362     // Leave room for the border
 363     popupWidth += 2 * popupWindowBorderWidth;
 364     popupHeight += 2 * popupWindowBorderWidth;
 365 
 366     // The popup should be at least as wide as the control on the page
 367     popupWidth = std::max(rScreenCoords.width() - client()-&gt;clientInsetLeft() - client()-&gt;clientInsetRight(), popupWidth);
 368 
 369     // Always left-align items in the popup.  This matches popup menus on the mac.
 370     int popupX = rScreenCoords.x() + client()-&gt;clientInsetLeft();
 371 
 372     IntRect popupRect(popupX, rScreenCoords.maxY(), popupWidth, popupHeight);
 373 
 374     // Check that we don&#39;t go off the screen vertically
 375     if (popupRect.maxY() &gt; screen.height()) {
 376         // The popup will go off the screen, so try placing it above the client
 377         if (rScreenCoords.y() - popupRect.height() &lt; 0) {
 378             // The popup won&#39;t fit above, either, so place it whereever&#39;s bigger and resize it to fit
 379             if ((rScreenCoords.y() + rScreenCoords.height() / 2) &lt; (screen.height() / 2)) {
 380                 // Below is bigger
 381                 popupRect.setHeight(screen.height() - popupRect.y());
 382             } else {
 383                 // Above is bigger
 384                 popupRect.setY(0);
 385                 popupRect.setHeight(rScreenCoords.y());
 386             }
 387         } else {
 388             // The popup fits above, so reposition it
 389             popupRect.setY(rScreenCoords.y() - popupRect.height());
 390         }
 391     }
 392 
 393     // Check that we don&#39;t go off the screen horizontally
 394     if (popupRect.x() + popupRect.width() &gt; screen.width() + screen.x())
 395         popupRect.setX(screen.x() + screen.width() - popupRect.width());
 396     if (popupRect.x() &lt; screen.x())
 397         popupRect.setX(screen.x());
 398 
 399     m_windowRect = popupRect;
 400     return;
 401 }
 402 
 403 bool PopupMenuWin::setFocusedIndex(int i, bool hotTracking)
 404 {
 405     if (i &lt; 0 || i &gt;= client()-&gt;listSize() || i == focusedIndex())
 406         return false;
 407 
 408     if (!client()-&gt;itemIsEnabled(i))
 409         return false;
 410 
 411     invalidateItem(focusedIndex());
 412     invalidateItem(i);
 413 
 414     m_focusedIndex = i;
 415 
 416     if (!hotTracking)
 417         client()-&gt;setTextFromItem(i);
 418 
 419     if (!scrollToRevealSelection())
 420         ::UpdateWindow(m_popup);
 421 
 422     return true;
 423 }
 424 
 425 int PopupMenuWin::visibleItems() const
 426 {
 427     return clientRect().height() / m_itemHeight;
 428 }
 429 
 430 int PopupMenuWin::listIndexAtPoint(const IntPoint&amp; point) const
 431 {
 432     return m_scrollOffset + point.y() / m_itemHeight;
 433 }
 434 
 435 int PopupMenuWin::focusedIndex() const
 436 {
 437     return m_focusedIndex;
 438 }
 439 
 440 void PopupMenuWin::focusFirst()
 441 {
 442     if (!client())
 443         return;
 444 
 445     int size = client()-&gt;listSize();
 446 
 447     for (int i = 0; i &lt; size; ++i)
 448         if (client()-&gt;itemIsEnabled(i)) {
 449             setFocusedIndex(i);
 450             break;
 451         }
 452 }
 453 
 454 void PopupMenuWin::focusLast()
 455 {
 456     if (!client())
 457         return;
 458 
 459     int size = client()-&gt;listSize();
 460 
 461     for (int i = size - 1; i &gt; 0; --i)
 462         if (client()-&gt;itemIsEnabled(i)) {
 463             setFocusedIndex(i);
 464             break;
 465         }
 466 }
 467 
 468 bool PopupMenuWin::down(unsigned lines)
 469 {
 470     if (!client())
 471         return false;
 472 
 473     int size = client()-&gt;listSize();
 474 
 475     int lastSelectableIndex, selectedListIndex;
 476     lastSelectableIndex = selectedListIndex = focusedIndex();
 477     for (int i = selectedListIndex + 1; i &gt;= 0 &amp;&amp; i &lt; size; ++i)
 478         if (client()-&gt;itemIsEnabled(i)) {
 479             lastSelectableIndex = i;
 480             if (i &gt;= selectedListIndex + (int)lines)
 481                 break;
 482         }
 483 
 484     return setFocusedIndex(lastSelectableIndex);
 485 }
 486 
 487 bool PopupMenuWin::up(unsigned lines)
 488 {
 489     if (!client())
 490         return false;
 491 
 492     int size = client()-&gt;listSize();
 493 
 494     int lastSelectableIndex, selectedListIndex;
 495     lastSelectableIndex = selectedListIndex = focusedIndex();
 496     for (int i = selectedListIndex - 1; i &gt;= 0 &amp;&amp; i &lt; size; --i)
 497         if (client()-&gt;itemIsEnabled(i)) {
 498             lastSelectableIndex = i;
 499             if (i &lt;= selectedListIndex - (int)lines)
 500                 break;
 501         }
 502 
 503     return setFocusedIndex(lastSelectableIndex);
 504 }
 505 
 506 void PopupMenuWin::invalidateItem(int index)
 507 {
 508     if (!m_popup)
 509         return;
 510 
 511     IntRect damageRect(clientRect());
 512     damageRect.setY(m_itemHeight * (index - m_scrollOffset));
 513     damageRect.setHeight(m_itemHeight);
 514     if (m_scrollbar)
 515         damageRect.setWidth(damageRect.width() - m_scrollbar-&gt;frameRect().width());
 516 
 517     RECT r = damageRect;
 518     ::InvalidateRect(m_popup, &amp;r, TRUE);
 519 }
 520 
 521 IntRect PopupMenuWin::clientRect() const
 522 {
 523     IntRect clientRect = m_windowRect;
 524     clientRect.inflate(-popupWindowBorderWidth);
 525     clientRect.setLocation(IntPoint(0, 0));
 526     return clientRect;
 527 }
 528 
 529 void PopupMenuWin::incrementWheelDelta(int delta)
 530 {
 531     m_wheelDelta += delta;
 532 }
 533 
 534 void PopupMenuWin::reduceWheelDelta(int delta)
 535 {
 536     ASSERT(delta &gt;= 0);
 537     ASSERT(delta &lt;= abs(m_wheelDelta));
 538 
 539     if (m_wheelDelta &gt; 0)
 540         m_wheelDelta -= delta;
 541     else if (m_wheelDelta &lt; 0)
 542         m_wheelDelta += delta;
 543     else
 544         return;
 545 }
 546 
 547 bool PopupMenuWin::scrollToRevealSelection()
 548 {
 549     if (!m_scrollbar)
 550         return false;
 551 
 552     int index = focusedIndex();
 553 
 554     if (index &lt; m_scrollOffset) {
 555         ScrollableArea::scrollToOffsetWithoutAnimation(VerticalScrollbar, index);
 556         return true;
 557     }
 558 
 559     if (index &gt;= m_scrollOffset + visibleItems()) {
 560         ScrollableArea::scrollToOffsetWithoutAnimation(VerticalScrollbar, index - visibleItems() + 1);
 561         return true;
 562     }
 563 
 564     return false;
 565 }
 566 
 567 void PopupMenuWin::updateFromElement()
 568 {
 569     if (!m_popup)
 570         return;
 571 
 572     m_focusedIndex = client()-&gt;selectedIndex();
 573 
 574     ::InvalidateRect(m_popup, 0, TRUE);
 575     scrollToRevealSelection();
 576 }
 577 
 578 const int separatorPadding = 4;
 579 const int separatorHeight = 1;
 580 void PopupMenuWin::paint(const IntRect&amp; damageRect, HDC hdc)
 581 {
 582     if (!m_popup)
 583         return;
 584 
 585     if (!m_DC) {
 586         m_DC = adoptGDIObject(::CreateCompatibleDC(HWndDC(m_popup)));
 587         if (!m_DC)
 588             return;
 589     }
 590 
 591     if (m_bmp) {
 592         bool keepBitmap = false;
 593         BITMAP bitmap;
 594         if (::GetObject(m_bmp.get(), sizeof(bitmap), &amp;bitmap))
 595             keepBitmap = bitmap.bmWidth == clientRect().width()
 596                 &amp;&amp; bitmap.bmHeight == clientRect().height();
 597         if (!keepBitmap)
 598             m_bmp.clear();
 599     }
 600     if (!m_bmp) {
 601         BitmapInfo bitmapInfo = BitmapInfo::createBottomUp(clientRect().size());
 602         void* pixels = 0;
 603         m_bmp = adoptGDIObject(::CreateDIBSection(m_DC.get(), &amp;bitmapInfo, DIB_RGB_COLORS, &amp;pixels, 0, 0));
 604         if (!m_bmp)
 605             return;
 606 
 607         ::SelectObject(m_DC.get(), m_bmp.get());
 608     }
 609 
 610     GraphicsContext context(m_DC.get());
 611 
 612     // listRect is the damageRect translated into the coordinates of the entire menu list (which is listSize * m_itemHeight pixels tall)
 613     IntRect listRect = damageRect;
 614     listRect.move(IntSize(0, m_scrollOffset * m_itemHeight));
 615 
 616     for (int y = listRect.y(); y &lt; listRect.maxY(); y += m_itemHeight) {
 617         int index = y / m_itemHeight;
 618 
 619         Color optionBackgroundColor, optionTextColor;
 620         PopupMenuStyle itemStyle = client()-&gt;itemStyle(index);
 621         if (index == focusedIndex()) {
 622             optionBackgroundColor = RenderTheme::singleton().activeListBoxSelectionBackgroundColor({ });
 623             optionTextColor = RenderTheme::singleton().activeListBoxSelectionForegroundColor({ });
 624         } else {
 625             optionBackgroundColor = itemStyle.backgroundColor();
 626             optionTextColor = itemStyle.foregroundColor();
 627         }
 628 
 629         // itemRect is in client coordinates
 630         IntRect itemRect(0, (index - m_scrollOffset) * m_itemHeight, damageRect.width(), m_itemHeight);
 631 
 632         // Draw the background for this menu item
 633         if (itemStyle.isVisible())
 634             context.fillRect(itemRect, optionBackgroundColor);
 635 
 636         if (client()-&gt;itemIsSeparator(index)) {
 637             IntRect separatorRect(itemRect.x() + separatorPadding, itemRect.y() + (itemRect.height() - separatorHeight) / 2, itemRect.width() - 2 * separatorPadding, separatorHeight);
 638             context.fillRect(separatorRect, optionTextColor);
 639             continue;
 640         }
 641 
 642         String itemText = client()-&gt;itemText(index);
 643 
 644         TextRun textRun(itemText, 0, 0, AllowTrailingExpansion, itemStyle.textDirection(), itemStyle.hasTextDirectionOverride());
 645         context.setFillColor(optionTextColor);
 646 
 647         FontCascade itemFont = m_font;
 648         if (client()-&gt;itemIsLabel(index)) {
 649             auto d = itemFont.fontDescription();
 650             d.setWeight(d.bolderWeight());
 651             itemFont = FontCascade(WTFMove(d), itemFont.letterSpacing(), itemFont.wordSpacing());
 652             itemFont.update(m_popupClient-&gt;fontSelector());
 653         }
 654 
 655         // Draw the item text
 656         if (itemStyle.isVisible()) {
 657             int textX = 0;
 658             if (client()-&gt;menuStyle().textDirection() == TextDirection::LTR) {
 659                 textX = std::max&lt;int&gt;(0, client()-&gt;clientPaddingLeft() - client()-&gt;clientInsetLeft());
 660                 if (RenderTheme::singleton().popupOptionSupportsTextIndent())
 661                     textX += minimumIntValueForLength(itemStyle.textIndent(), itemRect.width());
 662             } else {
 663                 textX = itemRect.width() - client()-&gt;menuStyle().font().width(textRun);
 664                 textX = std::min&lt;int&gt;(textX, textX - client()-&gt;clientPaddingRight() + client()-&gt;clientInsetRight());
 665                 if (RenderTheme::singleton().popupOptionSupportsTextIndent())
 666                     textX -= minimumIntValueForLength(itemStyle.textIndent(), itemRect.width());
 667             }
 668             int textY = itemRect.y() + itemFont.fontMetrics().ascent() + (itemRect.height() - itemFont.fontMetrics().height()) / 2;
 669             context.drawBidiText(itemFont, textRun, IntPoint(textX, textY));
 670         }
 671     }
 672 
 673     if (m_scrollbar)
 674         m_scrollbar-&gt;paint(context, damageRect);
 675 
 676     HWndDC hWndDC;
 677     HDC localDC = hdc ? hdc : hWndDC.setHWnd(m_popup);
 678 
 679     ::BitBlt(localDC, damageRect.x(), damageRect.y(), damageRect.width(), damageRect.height(), m_DC.get(), damageRect.x(), damageRect.y(), SRCCOPY);
 680 }
 681 
 682 ScrollPosition PopupMenuWin::scrollPosition() const
 683 {
 684     return { 0, m_scrollOffset };
 685 }
 686 
 687 void PopupMenuWin::setScrollOffset(const IntPoint&amp; offset)
 688 {
 689     scrollTo(offset.y());
 690 }
 691 
 692 void PopupMenuWin::scrollTo(int offset)
 693 {
 694     ASSERT(m_scrollbar);
 695 
 696     if (!m_popup)
 697         return;
 698 
 699     if (m_scrollOffset == offset)
 700         return;
 701 
 702     int scrolledLines = m_scrollOffset - offset;
 703     m_scrollOffset = offset;
 704 
 705     UINT flags = SW_INVALIDATE;
 706 
 707 #ifdef CAN_SET_SMOOTH_SCROLLING_DURATION
 708     BOOL shouldSmoothScroll = FALSE;
 709     ::SystemParametersInfo(SPI_GETLISTBOXSMOOTHSCROLLING, 0, &amp;shouldSmoothScroll, 0);
 710     if (shouldSmoothScroll)
 711         flags |= MAKEWORD(SW_SMOOTHSCROLL, smoothScrollAnimationDuration);
 712 #endif
 713 
 714     IntRect listRect = clientRect();
 715     if (m_scrollbar)
 716         listRect.setWidth(listRect.width() - m_scrollbar-&gt;frameRect().width());
 717     RECT r = listRect;
 718     ::ScrollWindowEx(m_popup, 0, scrolledLines * m_itemHeight, &amp;r, 0, 0, 0, flags);
 719     if (m_scrollbar) {
 720         r = m_scrollbar-&gt;frameRect();
 721         ::InvalidateRect(m_popup, &amp;r, TRUE);
 722     }
 723     ::UpdateWindow(m_popup);
 724 }
 725 
 726 void PopupMenuWin::invalidateScrollbarRect(Scrollbar&amp; scrollbar, const IntRect&amp; rect)
 727 {
 728     IntRect scrollRect = rect;
 729     scrollRect.move(scrollbar.x(), scrollbar.y());
 730     RECT r = scrollRect;
 731     ::InvalidateRect(m_popup, &amp;r, false);
 732 }
 733 
 734 IntSize PopupMenuWin::visibleSize() const
 735 {
 736     return IntSize(m_windowRect.width(), m_scrollbar ? m_scrollbar-&gt;visibleSize() : m_windowRect.height());
 737 }
 738 
 739 IntSize PopupMenuWin::contentsSize() const
 740 {
 741     return IntSize(m_windowRect.width(), m_scrollbar ? m_scrollbar-&gt;totalSize() : m_windowRect.height());
 742 }
 743 
 744 IntRect PopupMenuWin::scrollableAreaBoundingBox(bool*) const
 745 {
 746     return m_windowRect;
 747 }
 748 
 749 bool PopupMenuWin::onGetObject(WPARAM wParam, LPARAM lParam, LRESULT&amp; lResult)
 750 {
 751     lResult = 0;
 752 
 753     if (static_cast&lt;LONG&gt;(lParam) != OBJID_CLIENT)
 754         return false;
 755 
 756     if (!m_accessiblePopupMenu)
 757         m_accessiblePopupMenu = new AccessiblePopupMenu(*this);
 758 
 759     static HMODULE accessibilityLib = nullptr;
 760     if (!accessibilityLib) {
 761         if (!(accessibilityLib = ::LoadLibraryW(L&quot;oleacc.dll&quot;)))
 762             return false;
 763     }
 764 
 765     static LPFNLRESULTFROMOBJECT procPtr = reinterpret_cast&lt;LPFNLRESULTFROMOBJECT&gt;(::GetProcAddress(accessibilityLib, &quot;LresultFromObject&quot;));
 766     if (!procPtr)
 767         return false;
 768 
 769     // LresultFromObject returns a reference to the accessible object, stored
 770     // in an LRESULT. If this call is not successful, Windows will handle the
 771     // request through DefWindowProc.
 772     return SUCCEEDED(lResult = procPtr(__uuidof(IAccessible), wParam, m_accessiblePopupMenu.get()));
 773 }
 774 
 775 void PopupMenuWin::registerClass()
 776 {
 777     static bool haveRegisteredWindowClass = false;
 778 
 779     if (haveRegisteredWindowClass)
 780         return;
 781 
 782     WNDCLASSEX wcex;
 783     wcex.cbSize = sizeof(WNDCLASSEX);
 784     wcex.hIconSm        = 0;
 785     wcex.style          = CS_DROPSHADOW;
 786 
 787     wcex.lpfnWndProc    = PopupMenuWndProc;
 788     wcex.cbClsExtra     = 0;
 789     wcex.cbWndExtra     = sizeof(PopupMenu*); // For the PopupMenu pointer
 790     wcex.hInstance      = WebCore::instanceHandle();
 791     wcex.hIcon          = 0;
 792     wcex.hCursor        = LoadCursor(0, IDC_ARROW);
 793     wcex.hbrBackground  = 0;
 794     wcex.lpszMenuName   = 0;
 795     wcex.lpszClassName  = kPopupWindowClassName;
 796 
 797     haveRegisteredWindowClass = true;
 798 
 799     RegisterClassEx(&amp;wcex);
 800 }
 801 
 802 
 803 LRESULT CALLBACK PopupMenuWin::PopupMenuWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
 804 {
 805     if (PopupMenuWin* popup = static_cast&lt;PopupMenuWin*&gt;(getWindowPointer(hWnd, 0)))
 806         return popup-&gt;wndProc(hWnd, message, wParam, lParam);
 807 
 808     if (message == WM_CREATE) {
 809         LPCREATESTRUCT createStruct = reinterpret_cast&lt;LPCREATESTRUCT&gt;(lParam);
 810 
 811         // Associate the PopupMenu with the window.
 812         setWindowPointer(hWnd, 0, createStruct-&gt;lpCreateParams);
 813         return 0;
 814     }
 815 
 816     return ::DefWindowProc(hWnd, message, wParam, lParam);
 817 }
 818 
 819 LRESULT PopupMenuWin::wndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
 820 {
 821     LRESULT lResult = 0;
 822 
 823     switch (message) {
 824         case WM_MOUSEACTIVATE:
 825             return MA_NOACTIVATE;
 826         case WM_SIZE: {
 827             if (!scrollbar())
 828                 break;
 829 
 830             IntSize size(LOWORD(lParam), HIWORD(lParam));
 831             scrollbar()-&gt;setFrameRect(IntRect(size.width() - scrollbar()-&gt;width(), 0, scrollbar()-&gt;width(), size.height()));
 832 
 833             int visibleItems = this-&gt;visibleItems();
 834             scrollbar()-&gt;setEnabled(visibleItems &lt; client()-&gt;listSize());
 835             scrollbar()-&gt;setSteps(1, std::max(1, visibleItems - 1));
 836             scrollbar()-&gt;setProportion(visibleItems, client()-&gt;listSize());
 837 
 838             break;
 839         }
 840         case WM_SYSKEYDOWN:
 841         case WM_KEYDOWN: {
 842             if (!client())
 843                 break;
 844 
 845             bool altKeyPressed = GetKeyState(VK_MENU) &amp; HIGH_BIT_MASK_SHORT;
 846             bool ctrlKeyPressed = GetKeyState(VK_CONTROL) &amp; HIGH_BIT_MASK_SHORT;
 847 
 848             lResult = 0;
 849             switch (LOWORD(wParam)) {
 850                 case VK_F4: {
 851                     if (!altKeyPressed &amp;&amp; !ctrlKeyPressed) {
 852                         int index = focusedIndex();
 853                         ASSERT(index &gt;= 0);
 854                         client()-&gt;valueChanged(index);
 855                         hide();
 856                     }
 857                     break;
 858                 }
 859                 case VK_DOWN:
 860                     if (altKeyPressed) {
 861                         int index = focusedIndex();
 862                         ASSERT(index &gt;= 0);
 863                         client()-&gt;valueChanged(index);
 864                         hide();
 865                     } else
 866                         down();
 867                     break;
 868                 case VK_RIGHT:
 869                     down();
 870                     break;
 871                 case VK_UP:
 872                     if (altKeyPressed) {
 873                         int index = focusedIndex();
 874                         ASSERT(index &gt;= 0);
 875                         client()-&gt;valueChanged(index);
 876                         hide();
 877                     } else
 878                         up();
 879                     break;
 880                 case VK_LEFT:
 881                     up();
 882                     break;
 883                 case VK_HOME:
 884                     focusFirst();
 885                     break;
 886                 case VK_END:
 887                     focusLast();
 888                     break;
 889                 case VK_PRIOR:
 890                     if (focusedIndex() != m_scrollOffset) {
 891                         // Set the selection to the first visible item
 892                         int firstVisibleItem = m_scrollOffset;
 893                         up(focusedIndex() - firstVisibleItem);
 894                     } else {
 895                         // The first visible item is selected, so move the selection back one page
 896                         up(visibleItems());
 897                     }
 898                     break;
 899                 case VK_NEXT: {
 900                     int lastVisibleItem = m_scrollOffset + visibleItems() - 1;
 901                     if (focusedIndex() != lastVisibleItem) {
 902                         // Set the selection to the last visible item
 903                         down(lastVisibleItem - focusedIndex());
 904                     } else {
 905                         // The last visible item is selected, so move the selection forward one page
 906                         down(visibleItems());
 907                     }
 908                     break;
 909                 }
 910                 case VK_TAB:
 911                     ::SendMessage(client()-&gt;hostWindow()-&gt;platformPageClient(), message, wParam, lParam);
 912                     hide();
 913                     break;
 914                 case VK_ESCAPE:
 915                     hide();
 916                     break;
 917                 default:
 918                     if (isASCIIPrintable(wParam))
 919                         // Send the keydown to the WebView so it can be used for type-to-select.
 920                         // Since we know that the virtual key is ASCII printable, it&#39;s OK to convert this to
 921                         // a WM_CHAR message. (We don&#39;t want to call TranslateMessage because that will post a
 922                         // WM_CHAR message that will be stolen and redirected to the popup HWND.
 923                         ::PostMessage(m_popup, WM_HOST_WINDOW_CHAR, wParam, lParam);
 924                     else
 925                         lResult = 1;
 926                     break;
 927             }
 928             break;
 929         }
 930         case WM_CHAR: {
 931             if (!client())
 932                 break;
 933 
 934             lResult = 0;
 935             int index;
 936             switch (wParam) {
 937                 case 0x0D:   // Enter/Return
 938                     hide();
 939                     index = focusedIndex();
 940                     ASSERT(index &gt;= 0);
 941                     client()-&gt;valueChanged(index);
 942                     break;
 943                 case 0x1B:   // Escape
 944                     hide();
 945                     break;
 946                 case 0x09:   // TAB
 947                 case 0x08:   // Backspace
 948                 case 0x0A:   // Linefeed
 949                 default:     // Character
 950                     lResult = 1;
 951                     break;
 952             }
 953             break;
 954         }
 955         case WM_MOUSEMOVE: {
 956             IntPoint mousePoint(MAKEPOINTS(lParam));
 957             if (scrollbar()) {
 958                 IntRect scrollBarRect = scrollbar()-&gt;frameRect();
 959                 if (scrollbarCapturingMouse() || scrollBarRect.contains(mousePoint)) {
 960                     // Put the point into coordinates relative to the scroll bar
 961                     mousePoint.move(-scrollBarRect.x(), -scrollBarRect.y());
 962                     PlatformMouseEvent event(hWnd, message, wParam, makeScaledPoint(mousePoint, m_scaleFactor));
 963                     scrollbar()-&gt;mouseMoved(event);
 964                     break;
 965                 }
 966             }
 967 
 968             BOOL shouldHotTrack = FALSE;
 969             if (!::SystemParametersInfo(SPI_GETHOTTRACKING, 0, &amp;shouldHotTrack, 0))
 970                 shouldHotTrack = FALSE;
 971 
 972             RECT bounds;
 973             GetClientRect(popupHandle(), &amp;bounds);
 974             if (!::PtInRect(&amp;bounds, mousePoint) &amp;&amp; !(wParam &amp; MK_LBUTTON) &amp;&amp; client()) {
 975                 // When the mouse is not inside the popup menu and the left button isn&#39;t down, just
 976                 // repost the message to the web view.
 977 
 978                 // Translate the coordinate.
 979                 translatePoint(lParam, m_popup, client()-&gt;hostWindow()-&gt;platformPageClient());
 980 
 981                 ::PostMessage(m_popup, WM_HOST_WINDOW_MOUSEMOVE, wParam, lParam);
 982                 break;
 983             }
 984 
 985             if ((shouldHotTrack || wParam &amp; MK_LBUTTON) &amp;&amp; ::PtInRect(&amp;bounds, mousePoint)) {
 986                 setFocusedIndex(listIndexAtPoint(mousePoint), true);
 987                 m_hoveredIndex = listIndexAtPoint(mousePoint);
 988             }
 989 
 990             break;
 991         }
 992         case WM_LBUTTONDOWN: {
 993             IntPoint mousePoint(MAKEPOINTS(lParam));
 994             if (scrollbar()) {
 995                 IntRect scrollBarRect = scrollbar()-&gt;frameRect();
 996                 if (scrollBarRect.contains(mousePoint)) {
 997                     // Put the point into coordinates relative to the scroll bar
 998                     mousePoint.move(-scrollBarRect.x(), -scrollBarRect.y());
 999                     PlatformMouseEvent event(hWnd, message, wParam, makeScaledPoint(mousePoint, m_scaleFactor));
1000                     scrollbar()-&gt;mouseDown(event);
1001                     setScrollbarCapturingMouse(true);
1002                     break;
1003                 }
1004             }
1005 
1006             // If the mouse is inside the window, update the focused index. Otherwise,
1007             // hide the popup.
1008             RECT bounds;
1009             GetClientRect(m_popup, &amp;bounds);
1010             if (::PtInRect(&amp;bounds, mousePoint)) {
1011                 setFocusedIndex(listIndexAtPoint(mousePoint), true);
1012                 m_hoveredIndex = listIndexAtPoint(mousePoint);
1013             }
1014             else
1015                 hide();
1016             break;
1017         }
1018         case WM_LBUTTONUP: {
1019             IntPoint mousePoint(MAKEPOINTS(lParam));
1020             if (scrollbar()) {
1021                 IntRect scrollBarRect = scrollbar()-&gt;frameRect();
1022                 if (scrollbarCapturingMouse() || scrollBarRect.contains(mousePoint)) {
1023                     setScrollbarCapturingMouse(false);
1024                     // Put the point into coordinates relative to the scroll bar
1025                     mousePoint.move(-scrollBarRect.x(), -scrollBarRect.y());
1026                     PlatformMouseEvent event(hWnd, message, wParam, makeScaledPoint(mousePoint, m_scaleFactor));
1027                     scrollbar()-&gt;mouseUp(event);
1028                     // FIXME: This is a hack to work around Scrollbar not invalidating correctly when it doesn&#39;t have a parent widget
1029                     RECT r = scrollBarRect;
1030                     ::InvalidateRect(popupHandle(), &amp;r, TRUE);
1031                     break;
1032                 }
1033             }
1034             // Only hide the popup if the mouse is inside the popup window.
1035             RECT bounds;
1036             GetClientRect(popupHandle(), &amp;bounds);
1037             if (client() &amp;&amp; ::PtInRect(&amp;bounds, mousePoint)) {
1038                 hide();
1039                 int index = m_hoveredIndex;
1040                 if (!client()-&gt;itemIsEnabled(index))
1041                     index = client()-&gt;selectedIndex();
1042                 if (index &gt;= 0)
1043                     client()-&gt;valueChanged(index);
1044             }
1045             break;
1046         }
1047 
1048         case WM_MOUSEWHEEL: {
1049             if (!scrollbar())
1050                 break;
1051 
1052             int i = 0;
1053             for (incrementWheelDelta(GET_WHEEL_DELTA_WPARAM(wParam)); abs(wheelDelta()) &gt;= WHEEL_DELTA; reduceWheelDelta(WHEEL_DELTA)) {
1054                 if (wheelDelta() &gt; 0)
1055                     ++i;
1056                 else
1057                     --i;
1058             }
1059 
1060             ScrollableArea::scroll(i &gt; 0 ? ScrollUp : ScrollDown, ScrollByLine, abs(i));
1061             break;
1062         }
1063 
1064         case WM_PAINT: {
1065             PAINTSTRUCT paintInfo;
1066             ::BeginPaint(popupHandle(), &amp;paintInfo);
1067             paint(paintInfo.rcPaint, paintInfo.hdc);
1068             ::EndPaint(popupHandle(), &amp;paintInfo);
1069             lResult = 0;
1070             break;
1071         }
1072         case WM_PRINTCLIENT:
1073             paint(clientRect(), (HDC)wParam);
1074             break;
1075         case WM_GETOBJECT:
1076             onGetObject(wParam, lParam, lResult);
1077             break;
1078         default:
1079             lResult = DefWindowProc(hWnd, message, wParam, lParam);
1080     }
1081 
1082     return lResult;
1083 }
1084 
1085 AccessiblePopupMenu::AccessiblePopupMenu(const PopupMenuWin&amp; popupMenu)
1086     : m_popupMenu(popupMenu)
1087 {
1088 }
1089 
1090 AccessiblePopupMenu::~AccessiblePopupMenu() = default;
1091 
1092 HRESULT AccessiblePopupMenu::QueryInterface(_In_ REFIID riid, _COM_Outptr_ void** ppvObject)
1093 {
1094     if (!ppvObject)
1095         return E_POINTER;
1096     if (IsEqualGUID(riid, __uuidof(IAccessible)))
1097         *ppvObject = static_cast&lt;IAccessible*&gt;(this);
1098     else if (IsEqualGUID(riid, __uuidof(IDispatch)))
1099         *ppvObject = static_cast&lt;IAccessible*&gt;(this);
1100     else if (IsEqualGUID(riid, __uuidof(IUnknown)))
1101         *ppvObject = static_cast&lt;IAccessible*&gt;(this);
1102     else {
1103         *ppvObject = nullptr;
1104         return E_NOINTERFACE;
1105     }
1106     AddRef();
1107     return S_OK;
1108 }
1109 
1110 ULONG AccessiblePopupMenu::AddRef()
1111 {
1112     return ++m_refCount;
1113 }
1114 
1115 ULONG AccessiblePopupMenu::Release()
1116 {
1117     int refCount = --m_refCount;
1118     if (!refCount)
1119         delete this;
1120     return refCount;
1121 }
1122 
1123 HRESULT AccessiblePopupMenu::GetTypeInfoCount(_Out_ UINT* count)
1124 {
1125     if (!count)
1126         return E_POINTER;
1127     *count = 0;
1128     notImplemented();
1129     return E_NOTIMPL;
1130 }
1131 
1132 HRESULT AccessiblePopupMenu::GetTypeInfo(UINT, LCID, _COM_Outptr_opt_ ITypeInfo** ppTInfo)
1133 {
1134     if (!ppTInfo)
1135         return E_POINTER;
1136     *ppTInfo = nullptr;
1137     notImplemented();
1138     return E_NOTIMPL;
1139 }
1140 
1141 HRESULT AccessiblePopupMenu::GetIDsOfNames(_In_ REFIID, __in_ecount(cNames) LPOLESTR*, UINT cNames, LCID, __out_ecount_full(cNames) DISPID*)
1142 {
1143     notImplemented();
1144     return E_NOTIMPL;
1145 }
1146 
1147 HRESULT AccessiblePopupMenu::Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS*, VARIANT*, EXCEPINFO*, UINT*)
1148 {
1149     notImplemented();
1150     return E_NOTIMPL;
1151 }
1152 
1153 HRESULT AccessiblePopupMenu::get_accParent(_COM_Outptr_opt_ IDispatch** parent)
1154 {
1155     if (!parent)
1156         return E_POINTER;
1157     *parent = nullptr;
1158     notImplemented();
1159     return E_NOTIMPL;
1160 }
1161 
1162 HRESULT AccessiblePopupMenu::get_accChildCount(_Out_ long* count)
1163 {
1164     if (!count)
1165         return E_POINTER;
1166 
1167     *count = m_popupMenu.visibleItems();
1168     return S_OK;
1169 }
1170 
1171 HRESULT AccessiblePopupMenu::get_accChild(VARIANT vChild, _COM_Outptr_opt_ IDispatch** ppChild)
1172 {
1173     if (!ppChild)
1174         return E_POINTER;
1175 
1176     *ppChild = nullptr;
1177 
1178     if (vChild.vt != VT_I4)
1179         return E_INVALIDARG;
1180 
1181     notImplemented();
1182     return S_FALSE;
1183 }
1184 
1185 HRESULT AccessiblePopupMenu::get_accName(VARIANT vChild, __deref_out_opt BSTR* name)
1186 {
1187     return get_accValue(vChild, name);
1188 }
1189 
1190 HRESULT AccessiblePopupMenu::get_accValue(VARIANT vChild, __deref_out_opt BSTR* value)
1191 {
1192     if (!value)
1193         return E_POINTER;
1194 
1195     *value = nullptr;
1196 
1197     if (vChild.vt != VT_I4)
1198         return E_INVALIDARG;
1199 
1200     int index = vChild.lVal - 1;
1201 
1202     if (index &lt; 0)
1203         return E_INVALIDARG;
1204 
1205     BString itemText(m_popupMenu.client()-&gt;itemText(index));
1206     *value = itemText.release();
1207 
1208     return S_OK;
1209 }
1210 
1211 HRESULT AccessiblePopupMenu::get_accDescription(VARIANT, __deref_out_opt BSTR*)
1212 {
1213     notImplemented();
1214     return E_NOTIMPL;
1215 }
1216 
1217 HRESULT AccessiblePopupMenu::get_accRole(VARIANT vChild, _Out_ VARIANT* pvRole)
1218 {
1219     if (!pvRole)
1220         return E_POINTER;
1221     if (vChild.vt != VT_I4)
1222         return E_INVALIDARG;
1223 
1224     // Scrollbar parts are encoded as negative values.
1225     if (vChild.lVal &lt; 0) {
1226         V_VT(pvRole) = VT_I4;
1227         V_I4(pvRole) = ROLE_SYSTEM_SCROLLBAR;
1228     } else {
1229         V_VT(pvRole) = VT_I4;
1230         V_I4(pvRole) = ROLE_SYSTEM_LISTITEM;
1231     }
1232 
1233     return S_OK;
1234 }
1235 
1236 HRESULT AccessiblePopupMenu::get_accState(VARIANT vChild, _Out_ VARIANT* pvState)
1237 {
1238     if (!pvState)
1239         return E_POINTER;
1240 
1241     if (vChild.vt != VT_I4)
1242         return E_INVALIDARG;
1243 
1244     V_VT(pvState) = VT_I4;
1245     V_I4(pvState) = 0; // STATE_SYSTEM_NORMAL
1246 
1247     return S_OK;
1248 }
1249 
1250 HRESULT AccessiblePopupMenu::get_accHelp(VARIANT vChild, __deref_out_opt BSTR* helpText)
1251 {
1252     notImplemented();
1253     return E_NOTIMPL;
1254 }
1255 
1256 HRESULT AccessiblePopupMenu::get_accKeyboardShortcut(VARIANT vChild, __deref_out_opt BSTR*)
1257 {
1258     notImplemented();
1259     return E_NOTIMPL;
1260 }
1261 
1262 HRESULT AccessiblePopupMenu::get_accFocus(_Out_ VARIANT* pvFocusedChild)
1263 {
1264     notImplemented();
1265     return E_NOTIMPL;
1266 }
1267 
1268 HRESULT AccessiblePopupMenu::get_accSelection(_Out_ VARIANT* pvSelectedChild)
1269 {
1270     notImplemented();
1271     return E_NOTIMPL;
1272 }
1273 
1274 HRESULT AccessiblePopupMenu::get_accDefaultAction(VARIANT vChild, __deref_out_opt BSTR* actionDescription)
1275 {
1276     notImplemented();
1277     return E_NOTIMPL;
1278 }
1279 
1280 HRESULT AccessiblePopupMenu::accSelect(long selectionFlags, VARIANT vChild)
1281 {
1282     notImplemented();
1283     return E_NOTIMPL;
1284 }
1285 
1286 HRESULT AccessiblePopupMenu::accLocation(_Out_ long* left, _Out_ long* top, _Out_ long* width, _Out_ long* height, VARIANT vChild)
1287 {
1288     if (!left || !top || !width || !height)
1289         return E_POINTER;
1290 
1291     if (vChild.vt != VT_I4)
1292         return E_INVALIDARG;
1293 
1294     const IntRect&amp; windowRect = m_popupMenu.windowRect();
1295 
1296     // Scrollbar parts are encoded as negative values.
1297     if (vChild.lVal &lt; 0) {
1298         if (!m_popupMenu.scrollbar())
1299             return E_FAIL;
1300 
1301         Scrollbar&amp; scrollbar = *m_popupMenu.scrollbar();
1302         WebCore::ScrollbarPart part = static_cast&lt;WebCore::ScrollbarPart&gt;(-vChild.lVal);
1303 
1304         ScrollbarThemeWin&amp; theme = static_cast&lt;ScrollbarThemeWin&amp;&gt;(scrollbar.theme());
1305 
1306         IntRect partRect;
1307 
1308         switch (part) {
1309         case BackTrackPart:
1310         case BackButtonStartPart:
1311             partRect = theme.backButtonRect(scrollbar, WebCore::BackTrackPart);
1312             break;
1313         case ThumbPart:
1314             partRect = theme.thumbRect(scrollbar);
1315             break;
1316         case ForwardTrackPart:
1317         case ForwardButtonEndPart:
1318             partRect = theme.forwardButtonRect(scrollbar, WebCore::ForwardTrackPart);
1319             break;
1320         case ScrollbarBGPart:
1321             partRect = theme.trackRect(scrollbar);
1322             break;
1323         default:
1324             return E_FAIL;
1325         }
1326 
1327         partRect.move(windowRect.x(), windowRect.y());
1328 
1329         *left = partRect.x();
1330         *top = partRect.y();
1331         *width = partRect.width();
1332         *height = partRect.height();
1333 
1334         return S_OK;
1335     }
1336 
1337     int index = vChild.lVal - 1;
1338 
1339     if (index &lt; 0)
1340         return E_INVALIDARG;
1341 
1342     *left = windowRect.x();
1343     *top = windowRect.y() + (index - m_popupMenu.m_scrollOffset) * m_popupMenu.itemHeight();
1344     *width = windowRect.width();
1345     *height = m_popupMenu.itemHeight();
1346 
1347     return S_OK;
1348 }
1349 
1350 HRESULT AccessiblePopupMenu::accNavigate(long direction, VARIANT vFromChild, _Out_ VARIANT* pvNavigatedTo)
1351 {
1352     notImplemented();
1353     return E_NOTIMPL;
1354 }
1355 
1356 HRESULT AccessiblePopupMenu::accHitTest(long x, long y, _Out_ VARIANT* pvChildAtPoint)
1357 {
1358     if (!pvChildAtPoint)
1359         return E_POINTER;
1360 
1361     ::VariantInit(pvChildAtPoint);
1362 
1363     IntRect windowRect = m_popupMenu.windowRect();
1364 
1365     IntPoint pt(x - windowRect.x(), y - windowRect.y());
1366 
1367     IntRect scrollRect;
1368 
1369     if (m_popupMenu.scrollbar())
1370         scrollRect = m_popupMenu.scrollbar()-&gt;frameRect();
1371 
1372     if (m_popupMenu.scrollbar() &amp;&amp; scrollRect.contains(pt)) {
1373         Scrollbar&amp; scrollbar = *m_popupMenu.scrollbar();
1374 
1375         pt.move(-scrollRect.x(), -scrollRect.y());
1376 
1377         WebCore::ScrollbarPart part = scrollbar.theme().hitTest(scrollbar, pt);
1378 
1379         V_VT(pvChildAtPoint) = VT_I4;
1380         V_I4(pvChildAtPoint) = -part; // Scrollbar parts are encoded as negative, to avoid mixup with item indexes.
1381         return S_OK;
1382     }
1383 
1384     int index = m_popupMenu.listIndexAtPoint(pt);
1385 
1386     if (index &lt; 0) {
1387         V_VT(pvChildAtPoint) = VT_EMPTY;
1388         return S_OK;
1389     }
1390 
1391     V_VT(pvChildAtPoint) = VT_I4;
1392     V_I4(pvChildAtPoint) = index + 1; // CHILDID_SELF is 0, need to add 1.
1393 
1394     return S_OK;
1395 }
1396 
1397 HRESULT AccessiblePopupMenu::accDoDefaultAction(VARIANT vChild)
1398 {
1399     notImplemented();
1400     return E_NOTIMPL;
1401 }
1402 
1403 HRESULT AccessiblePopupMenu::put_accName(VARIANT, BSTR)
1404 {
1405     notImplemented();
1406     return E_NOTIMPL;
1407 }
1408 
1409 HRESULT AccessiblePopupMenu::put_accValue(VARIANT, BSTR)
1410 {
1411     notImplemented();
1412     return E_NOTIMPL;
1413 }
1414 
1415 HRESULT AccessiblePopupMenu::get_accHelpTopic(BSTR* helpFile, VARIANT, _Out_ long* topicID)
1416 {
1417     notImplemented();
1418     return E_NOTIMPL;
1419 }
1420 
1421 }
    </pre>
  </body>
</html>