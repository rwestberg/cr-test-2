<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGFixupPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGFixupPhase.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;DFGGraph.h&quot;
  33 #include &quot;DFGInsertionSet.h&quot;
  34 #include &quot;DFGPhase.h&quot;
  35 #include &quot;DFGPredictionPropagationPhase.h&quot;
  36 #include &quot;DFGVariableAccessDataDump.h&quot;
  37 #include &quot;JSCInlines.h&quot;
  38 #include &quot;TypeLocation.h&quot;
  39 
  40 namespace JSC { namespace DFG {
  41 
  42 class FixupPhase : public Phase {
  43 public:
  44     FixupPhase(Graph&amp; graph)
  45         : Phase(graph, &quot;fixup&quot;)
  46         , m_insertionSet(graph)
  47     {
  48     }
  49 
  50     bool run()
  51     {
  52         ASSERT(m_graph.m_fixpointState == BeforeFixpoint);
  53         ASSERT(m_graph.m_form == ThreadedCPS);
  54 
  55         m_profitabilityChanged = false;
  56         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
  57             fixupBlock(m_graph.block(blockIndex));
  58 
  59         while (m_profitabilityChanged) {
  60             m_profitabilityChanged = false;
  61 
  62             for (unsigned i = m_graph.m_argumentPositions.size(); i--;)
  63                 m_graph.m_argumentPositions[i].mergeArgumentUnboxingAwareness();
  64 
  65             for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
  66                 fixupGetAndSetLocalsInBlock(m_graph.block(blockIndex));
  67         }
  68 
  69         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
  70             fixupChecksInBlock(m_graph.block(blockIndex));
  71 
  72         m_graph.m_planStage = PlanStage::AfterFixup;
  73 
  74         return true;
  75     }
  76 
  77 private:
  78 
  79     void fixupArithDivInt32(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)
  80     {
  81         if (optimizeForX86() || optimizeForARM64() || optimizeForARMv7IDIVSupported()) {
  82             fixIntOrBooleanEdge(leftChild);
  83             fixIntOrBooleanEdge(rightChild);
  84             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
  85                 node-&gt;setArithMode(Arith::Unchecked);
  86             else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
  87                 node-&gt;setArithMode(Arith::CheckOverflow);
  88             else
  89                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
  90             return;
  91         }
  92 
  93         // This will cause conversion nodes to be inserted later.
  94         fixDoubleOrBooleanEdge(leftChild);
  95         fixDoubleOrBooleanEdge(rightChild);
  96 
  97         // We don&#39;t need to do ref&#39;ing on the children because we&#39;re stealing them from
  98         // the original division.
  99         Node* newDivision = m_insertionSet.insertNode(m_indexInBlock, SpecBytecodeDouble, *node);
 100         newDivision-&gt;setResult(NodeResultDouble);
 101 
 102         node-&gt;setOp(DoubleAsInt32);
 103         node-&gt;children.initialize(Edge(newDivision, DoubleRepUse), Edge(), Edge());
 104         if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 105             node-&gt;setArithMode(Arith::CheckOverflow);
 106         else
 107             node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 108 
 109     }
 110 
 111     void fixupArithPow(Node* node)
 112     {
 113         if (node-&gt;child2()-&gt;shouldSpeculateInt32OrBooleanForArithmetic()) {
 114             fixDoubleOrBooleanEdge(node-&gt;child1());
 115             fixIntOrBooleanEdge(node-&gt;child2());
 116             return;
 117         }
 118 
 119         fixDoubleOrBooleanEdge(node-&gt;child1());
 120         fixDoubleOrBooleanEdge(node-&gt;child2());
 121     }
 122 
 123     void fixupArithDiv(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)
 124     {
 125         if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {
 126             fixupArithDivInt32(node, leftChild, rightChild);
 127             return;
 128         }
 129 
 130         fixDoubleOrBooleanEdge(leftChild);
 131         fixDoubleOrBooleanEdge(rightChild);
 132         node-&gt;setResult(NodeResultDouble);
 133     }
 134 
 135     void fixupArithMul(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)
 136     {
 137         if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {
 138             fixIntOrBooleanEdge(leftChild);
 139             fixIntOrBooleanEdge(rightChild);
 140             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 141                 node-&gt;setArithMode(Arith::Unchecked);
 142             else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()) || leftChild.node() == rightChild.node())
 143                 node-&gt;setArithMode(Arith::CheckOverflow);
 144             else
 145                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 146             return;
 147         }
 148         if (m_graph.binaryArithShouldSpeculateInt52(node, FixupPass)) {
 149             fixEdge&lt;Int52RepUse&gt;(leftChild);
 150             fixEdge&lt;Int52RepUse&gt;(rightChild);
 151             if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()) || leftChild.node() == rightChild.node())
 152                 node-&gt;setArithMode(Arith::CheckOverflow);
 153             else
 154                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 155             node-&gt;setResult(NodeResultInt52);
 156             return;
 157         }
 158 
 159         fixDoubleOrBooleanEdge(leftChild);
 160         fixDoubleOrBooleanEdge(rightChild);
 161         node-&gt;setResult(NodeResultDouble);
 162     }
 163 
 164     void fixupBlock(BasicBlock* block)
 165     {
 166         if (!block)
 167             return;
 168         ASSERT(block-&gt;isReachable);
 169         m_block = block;
 170         for (m_indexInBlock = 0; m_indexInBlock &lt; block-&gt;size(); ++m_indexInBlock) {
 171             m_currentNode = block-&gt;at(m_indexInBlock);
 172             fixupNode(m_currentNode);
 173         }
 174         m_insertionSet.execute(block);
 175     }
 176 
 177     void fixupNode(Node* node)
 178     {
 179         NodeType op = node-&gt;op();
 180 
 181         switch (op) {
 182         case SetLocal: {
 183             // This gets handled by fixupGetAndSetLocalsInBlock().
 184             return;
 185         }
 186 
 187         case ValueSub: {
 188             Edge&amp; child1 = node-&gt;child1();
 189             Edge&amp; child2 = node-&gt;child2();
 190 
 191             if (Node::shouldSpeculateBigInt(child1.node(), child2.node())) {
 192                 fixEdge&lt;BigIntUse&gt;(child1);
 193                 fixEdge&lt;BigIntUse&gt;(child2);
 194                 break;
 195             }
 196 
 197             if (Node::shouldSpeculateUntypedForArithmetic(node-&gt;child1().node(), node-&gt;child2().node())) {
 198                 fixEdge&lt;UntypedUse&gt;(child1);
 199                 fixEdge&lt;UntypedUse&gt;(child2);
 200                 break;
 201             }
 202 
 203             if (attemptToMakeIntegerAdd(node)) {
 204                 // FIXME: Clear ArithSub&#39;s NodeMustGenerate when ArithMode is unchecked
 205                 // https://bugs.webkit.org/show_bug.cgi?id=190607
 206                 node-&gt;setOp(ArithSub);
 207                 break;
 208             }
 209 
 210             fixDoubleOrBooleanEdge(node-&gt;child1());
 211             fixDoubleOrBooleanEdge(node-&gt;child2());
 212             node-&gt;setOp(ArithSub);
 213             node-&gt;setResult(NodeResultDouble);
 214 
 215             break;
 216         }
 217 
 218         case ValueBitLShift:
 219         case ValueBitXor:
 220         case ValueBitOr:
 221         case ValueBitAnd: {
 222             if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
 223                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
 224                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
 225                 node-&gt;clearFlags(NodeMustGenerate);
 226                 break;
 227             }
 228 
 229             if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
 230                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 231                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 232                 break;
 233             }
 234 
 235             switch (op) {
 236             case ValueBitXor:
 237                 node-&gt;setOp(ArithBitXor);
 238                 break;
 239             case ValueBitOr:
 240                 node-&gt;setOp(ArithBitOr);
 241                 break;
 242             case ValueBitAnd:
 243                 node-&gt;setOp(ArithBitAnd);
 244                 break;
 245             case ValueBitLShift:
 246                 node-&gt;setOp(ArithBitLShift);
 247                 break;
 248             default:
 249                 DFG_CRASH(m_graph, node, &quot;Unexpected node during ValueBit operation fixup&quot;);
 250                 break;
 251             }
 252 
 253             node-&gt;clearFlags(NodeMustGenerate);
 254             node-&gt;setResult(NodeResultInt32);
 255             fixIntConvertingEdge(node-&gt;child1());
 256             fixIntConvertingEdge(node-&gt;child2());
 257             break;
 258         }
 259 
 260         case ValueBitNot: {
 261             Edge&amp; operandEdge = node-&gt;child1();
 262 
 263             if (operandEdge.node()-&gt;shouldSpeculateBigInt()) {
 264                 node-&gt;clearFlags(NodeMustGenerate);
 265                 fixEdge&lt;BigIntUse&gt;(operandEdge);
 266             } else if (operandEdge.node()-&gt;shouldSpeculateUntypedForBitOps())
 267                 fixEdge&lt;UntypedUse&gt;(operandEdge);
 268             else {
 269                 node-&gt;setOp(ArithBitNot);
 270                 node-&gt;setResult(NodeResultInt32);
 271                 node-&gt;clearFlags(NodeMustGenerate);
 272                 fixIntConvertingEdge(operandEdge);
 273             }
 274             break;
 275         }
 276 
 277         case ArithBitNot: {
 278             Edge&amp; operandEdge = node-&gt;child1();
 279 
 280             fixIntConvertingEdge(operandEdge);
 281             break;
 282         }
 283 
 284         case ArithBitLShift:
 285         case ArithBitXor:
 286         case ArithBitOr:
 287         case ArithBitAnd: {
 288             fixIntConvertingEdge(node-&gt;child1());
 289             fixIntConvertingEdge(node-&gt;child2());
 290             break;
 291         }
 292 
 293         case BitRShift:
 294         case BitURShift: {
 295             if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
 296                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 297                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 298                 break;
 299             }
 300             fixIntConvertingEdge(node-&gt;child1());
 301             fixIntConvertingEdge(node-&gt;child2());
 302             break;
 303         }
 304 
 305         case ArithIMul: {
 306             fixIntConvertingEdge(node-&gt;child1());
 307             fixIntConvertingEdge(node-&gt;child2());
 308             node-&gt;setOp(ArithMul);
 309             node-&gt;setArithMode(Arith::Unchecked);
 310             node-&gt;child1().setUseKind(Int32Use);
 311             node-&gt;child2().setUseKind(Int32Use);
 312             break;
 313         }
 314 
 315         case ArithClz32: {
 316             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 317                 fixIntConvertingEdge(node-&gt;child1());
 318                 node-&gt;clearFlags(NodeMustGenerate);
 319             } else
 320                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 321             break;
 322         }
 323 
 324         case UInt32ToNumber: {
 325             fixIntConvertingEdge(node-&gt;child1());
 326             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 327                 node-&gt;convertToIdentity();
 328             else if (node-&gt;canSpeculateInt32(FixupPass))
 329                 node-&gt;setArithMode(Arith::CheckOverflow);
 330             else {
 331                 node-&gt;setArithMode(Arith::DoOverflow);
 332                 node-&gt;setResult(enableInt52() ? NodeResultInt52 : NodeResultDouble);
 333             }
 334             break;
 335         }
 336 
 337         case ValueNegate: {
 338             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 339                 node-&gt;setOp(ArithNegate);
 340                 fixIntOrBooleanEdge(node-&gt;child1());
 341                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 342                     node-&gt;setArithMode(Arith::Unchecked);
 343                 else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 344                     node-&gt;setArithMode(Arith::CheckOverflow);
 345                 else
 346                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 347                 node-&gt;setResult(NodeResultInt32);
 348                 node-&gt;clearFlags(NodeMustGenerate);
 349                 break;
 350             }
 351 
 352             if (m_graph.unaryArithShouldSpeculateInt52(node, FixupPass)) {
 353                 node-&gt;setOp(ArithNegate);
 354                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 355                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 356                     node-&gt;setArithMode(Arith::CheckOverflow);
 357                 else
 358                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 359                 node-&gt;setResult(NodeResultInt52);
 360                 node-&gt;clearFlags(NodeMustGenerate);
 361                 break;
 362             }
 363             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 364                 node-&gt;setOp(ArithNegate);
 365                 fixDoubleOrBooleanEdge(node-&gt;child1());
 366                 node-&gt;setResult(NodeResultDouble);
 367                 node-&gt;clearFlags(NodeMustGenerate);
 368             } else {
 369                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 370                 node-&gt;setResult(NodeResultJS);
 371             }
 372             break;
 373         }
 374 
 375         case ValueAdd: {
 376             if (attemptToMakeIntegerAdd(node)) {
 377                 node-&gt;setOp(ArithAdd);
 378                 break;
 379             }
 380             if (Node::shouldSpeculateNumberOrBooleanExpectingDefined(node-&gt;child1().node(), node-&gt;child2().node())) {
 381                 fixDoubleOrBooleanEdge(node-&gt;child1());
 382                 fixDoubleOrBooleanEdge(node-&gt;child2());
 383                 node-&gt;setOp(ArithAdd);
 384                 node-&gt;setResult(NodeResultDouble);
 385                 break;
 386             }
 387 
 388             if (attemptToMakeFastStringAdd(node))
 389                 break;
 390 
 391             Edge&amp; child1 = node-&gt;child1();
 392             Edge&amp; child2 = node-&gt;child2();
 393             if (child1-&gt;shouldSpeculateString() || child2-&gt;shouldSpeculateString()) {
 394                 if (child1-&gt;shouldSpeculateInt32() || child2-&gt;shouldSpeculateInt32()) {
 395                     auto convertString = [&amp;](Node* node, Edge&amp; edge) {
 396                         if (edge-&gt;shouldSpeculateInt32())
 397                             convertStringAddUse&lt;Int32Use&gt;(node, edge);
 398                         else {
 399                             ASSERT(edge-&gt;shouldSpeculateString());
 400                             convertStringAddUse&lt;StringUse&gt;(node, edge);
 401                         }
 402                     };
 403                     convertString(node, child1);
 404                     convertString(node, child2);
 405                     convertToMakeRope(node);
 406                     break;
 407                 }
 408             }
 409 
 410             if (Node::shouldSpeculateBigInt(child1.node(), child2.node())) {
 411                 fixEdge&lt;BigIntUse&gt;(child1);
 412                 fixEdge&lt;BigIntUse&gt;(child2);
 413             } else {
 414                 fixEdge&lt;UntypedUse&gt;(child1);
 415                 fixEdge&lt;UntypedUse&gt;(child2);
 416             }
 417 
 418             node-&gt;setResult(NodeResultJS);
 419             break;
 420         }
 421 
 422         case StrCat: {
 423             if (attemptToMakeFastStringAdd(node))
 424                 break;
 425 
 426             // FIXME: Remove empty string arguments and possibly turn this into a ToString operation. That
 427             // would require a form of ToString that takes a KnownPrimitiveUse. This is necessary because
 428             // the implementation of StrCat doesn&#39;t dynamically optimize for empty strings.
 429             // https://bugs.webkit.org/show_bug.cgi?id=148540
 430             m_graph.doToChildren(
 431                 node,
 432                 [&amp;] (Edge&amp; edge) {
 433                     fixEdge&lt;KnownPrimitiveUse&gt;(edge);
 434                     // StrCat automatically coerces the values into strings before concatenating them.
 435                     // The ECMA spec says that we&#39;re not allowed to automatically coerce a Symbol into
 436                     // a string. If a Symbol is encountered, a TypeError will be thrown. As a result,
 437                     // our runtime functions for this slow path expect that they will never be passed
 438                     // Symbols.
 439                     m_insertionSet.insertNode(
 440                         m_indexInBlock, SpecNone, Check, node-&gt;origin,
 441                         Edge(edge.node(), NotSymbolUse));
 442                 });
 443             break;
 444         }
 445 
 446         case MakeRope: {
 447             fixupMakeRope(node);
 448             break;
 449         }
 450 
 451         case ArithAdd:
 452         case ArithSub: {
 453             // FIXME: Clear ArithSub&#39;s NodeMustGenerate when ArithMode is unchecked
 454             // https://bugs.webkit.org/show_bug.cgi?id=190607
 455             if (attemptToMakeIntegerAdd(node))
 456                 break;
 457             fixDoubleOrBooleanEdge(node-&gt;child1());
 458             fixDoubleOrBooleanEdge(node-&gt;child2());
 459             node-&gt;setResult(NodeResultDouble);
 460             break;
 461         }
 462 
 463         case ArithNegate: {
 464             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 465                 fixIntOrBooleanEdge(node-&gt;child1());
 466                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 467                     node-&gt;setArithMode(Arith::Unchecked);
 468                 else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 469                     node-&gt;setArithMode(Arith::CheckOverflow);
 470                 else
 471                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 472                 node-&gt;setResult(NodeResultInt32);
 473                 node-&gt;clearFlags(NodeMustGenerate);
 474                 break;
 475             }
 476             if (m_graph.unaryArithShouldSpeculateInt52(node, FixupPass)) {
 477                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 478                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 479                     node-&gt;setArithMode(Arith::CheckOverflow);
 480                 else
 481                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 482                 node-&gt;setResult(NodeResultInt52);
 483                 node-&gt;clearFlags(NodeMustGenerate);
 484                 break;
 485             }
 486 
 487             fixDoubleOrBooleanEdge(node-&gt;child1());
 488             node-&gt;setResult(NodeResultDouble);
 489             node-&gt;clearFlags(NodeMustGenerate);
 490             break;
 491         }
 492 
 493         case ValueMul: {
 494             Edge&amp; leftChild = node-&gt;child1();
 495             Edge&amp; rightChild = node-&gt;child2();
 496 
 497             if (Node::shouldSpeculateBigInt(leftChild.node(), rightChild.node())) {
 498                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
 499                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
 500                 node-&gt;clearFlags(NodeMustGenerate);
 501                 break;
 502             }
 503 
 504             // There are cases where we can have BigInt + Int32 operands reaching ValueMul.
 505             // Imagine the scenario where ValueMul was never executed, but we can predict types
 506             // reaching the node:
 507             //
 508             // 63: GetLocal(Check:Untyped:@72, JS|MustGen, NonBoolInt32, ...)  predicting NonBoolInt32
 509             // 64: GetLocal(Check:Untyped:@71, JS|MustGen, BigInt, ...)  predicting BigInt
 510             // 65: ValueMul(Check:Untyped:@63, Check:Untyped:@64, BigInt|BoolInt32|NonBoolInt32, ...)
 511             //
 512             // In such scenario, we need to emit ValueMul(Untyped, Untyped), so the runtime can throw
 513             // an exception whenever it gets excuted.
 514             if (Node::shouldSpeculateUntypedForArithmetic(leftChild.node(), rightChild.node())) {
 515                 fixEdge&lt;UntypedUse&gt;(leftChild);
 516                 fixEdge&lt;UntypedUse&gt;(rightChild);
 517                 break;
 518             }
 519 
 520             // At this point, all other possible specializations are only handled by ArithMul.
 521             node-&gt;setOp(ArithMul);
 522             node-&gt;setResult(NodeResultNumber);
 523             fixupArithMul(node, leftChild, rightChild);
 524             break;
 525         }
 526 
 527         case ArithMul: {
 528             Edge&amp; leftChild = node-&gt;child1();
 529             Edge&amp; rightChild = node-&gt;child2();
 530 
 531             fixupArithMul(node, leftChild, rightChild);
 532             break;
 533         }
 534 
 535         case ValueMod:
 536         case ValueDiv: {
 537             Edge&amp; leftChild = node-&gt;child1();
 538             Edge&amp; rightChild = node-&gt;child2();
 539 
 540             if (Node::shouldSpeculateBigInt(leftChild.node(), rightChild.node())) {
 541                 fixEdge&lt;BigIntUse&gt;(leftChild);
 542                 fixEdge&lt;BigIntUse&gt;(rightChild);
 543                 node-&gt;clearFlags(NodeMustGenerate);
 544                 break;
 545             }
 546 
 547             if (Node::shouldSpeculateUntypedForArithmetic(leftChild.node(), rightChild.node())) {
 548                 fixEdge&lt;UntypedUse&gt;(leftChild);
 549                 fixEdge&lt;UntypedUse&gt;(rightChild);
 550                 break;
 551             }
 552 
 553             if (op == ValueDiv)
 554                 node-&gt;setOp(ArithDiv);
 555             else
 556                 node-&gt;setOp(ArithMod);
 557 
 558             node-&gt;setResult(NodeResultNumber);
 559             fixupArithDiv(node, leftChild, rightChild);
 560             break;
 561 
 562         }
 563 
 564         case ArithDiv:
 565         case ArithMod: {
 566             Edge&amp; leftChild = node-&gt;child1();
 567             Edge&amp; rightChild = node-&gt;child2();
 568 
 569             fixupArithDiv(node, leftChild, rightChild);
 570             break;
 571         }
 572 
 573         case ArithMin:
 574         case ArithMax: {
 575             if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {
 576                 fixIntOrBooleanEdge(node-&gt;child1());
 577                 fixIntOrBooleanEdge(node-&gt;child2());
 578                 break;
 579             }
 580             fixDoubleOrBooleanEdge(node-&gt;child1());
 581             fixDoubleOrBooleanEdge(node-&gt;child2());
 582             node-&gt;setResult(NodeResultDouble);
 583             break;
 584         }
 585 
 586         case ArithAbs: {
 587             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean()
 588                 &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 589                 fixIntOrBooleanEdge(node-&gt;child1());
 590                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 591                     node-&gt;setArithMode(Arith::Unchecked);
 592                 else
 593                     node-&gt;setArithMode(Arith::CheckOverflow);
 594                 node-&gt;clearFlags(NodeMustGenerate);
 595                 node-&gt;setResult(NodeResultInt32);
 596                 break;
 597             }
 598 
 599             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 600                 fixDoubleOrBooleanEdge(node-&gt;child1());
 601                 node-&gt;clearFlags(NodeMustGenerate);
 602             } else
 603                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 604             node-&gt;setResult(NodeResultDouble);
 605             break;
 606         }
 607 
 608         case ValuePow: {
 609             if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
 610                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
 611                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
 612                 node-&gt;clearFlags(NodeMustGenerate);
 613                 break;
 614             }
 615 
 616             if (Node::shouldSpeculateUntypedForArithmetic(node-&gt;child1().node(), node-&gt;child2().node())) {
 617                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 618                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 619                 break;
 620             }
 621 
 622             node-&gt;setOp(ArithPow);
 623             node-&gt;clearFlags(NodeMustGenerate);
 624             node-&gt;setResult(NodeResultDouble);
 625 
 626             fixupArithPow(node);
 627             break;
 628         }
 629 
 630         case ArithPow: {
 631             fixupArithPow(node);
 632             break;
 633         }
 634 
 635         case ArithRandom: {
 636             node-&gt;setResult(NodeResultDouble);
 637             break;
 638         }
 639 
 640         case ArithRound:
 641         case ArithFloor:
 642         case ArithCeil:
 643         case ArithTrunc: {
 644             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; m_graph.roundShouldSpeculateInt32(node, FixupPass)) {
 645                 fixIntOrBooleanEdge(node-&gt;child1());
 646                 insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
 647                 node-&gt;convertToIdentity();
 648                 break;
 649             }
 650             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 651                 fixDoubleOrBooleanEdge(node-&gt;child1());
 652 
 653                 if (isInt32OrBooleanSpeculation(node-&gt;getHeapPrediction()) &amp;&amp; m_graph.roundShouldSpeculateInt32(node, FixupPass)) {
 654                     node-&gt;setResult(NodeResultInt32);
 655                     if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 656                         node-&gt;setArithRoundingMode(Arith::RoundingMode::Int32);
 657                     else
 658                         node-&gt;setArithRoundingMode(Arith::RoundingMode::Int32WithNegativeZeroCheck);
 659                 } else {
 660                     node-&gt;setResult(NodeResultDouble);
 661                     node-&gt;setArithRoundingMode(Arith::RoundingMode::Double);
 662                 }
 663                 node-&gt;clearFlags(NodeMustGenerate);
 664             } else
 665                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 666             break;
 667         }
 668 
 669         case ArithFRound:
 670         case ArithSqrt:
 671         case ArithUnary: {
 672             Edge&amp; child1 = node-&gt;child1();
 673             if (child1-&gt;shouldSpeculateNotCell()) {
 674                 fixDoubleOrBooleanEdge(child1);
 675                 node-&gt;clearFlags(NodeMustGenerate);
 676             } else
 677                 fixEdge&lt;UntypedUse&gt;(child1);
 678             break;
 679         }
 680 
 681         case LogicalNot: {
 682             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
 683                 if (node-&gt;child1()-&gt;result() == NodeResultBoolean) {
 684                     // This is necessary in case we have a bytecode instruction implemented by:
 685                     //
 686                     // a: CompareEq(...)
 687                     // b: LogicalNot(@a)
 688                     //
 689                     // In that case, CompareEq might have a side-effect. Then, we need to make
 690                     // sure that we know that Branch does not exit.
 691                     fixEdge&lt;KnownBooleanUse&gt;(node-&gt;child1());
 692                 } else
 693                     fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
 694             } else if (node-&gt;child1()-&gt;shouldSpeculateObjectOrOther())
 695                 fixEdge&lt;ObjectOrOtherUse&gt;(node-&gt;child1());
 696             else if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean())
 697                 fixIntOrBooleanEdge(node-&gt;child1());
 698             else if (node-&gt;child1()-&gt;shouldSpeculateNumber())
 699                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
 700             else if (node-&gt;child1()-&gt;shouldSpeculateString())
 701                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
 702             else if (node-&gt;child1()-&gt;shouldSpeculateStringOrOther())
 703                 fixEdge&lt;StringOrOtherUse&gt;(node-&gt;child1());
 704             else {
 705                 WatchpointSet* masqueradesAsUndefinedWatchpoint = m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;masqueradesAsUndefinedWatchpoint();
 706                 if (masqueradesAsUndefinedWatchpoint-&gt;isStillValid())
 707                     m_graph.watchpoints().addLazily(masqueradesAsUndefinedWatchpoint);
 708             }
 709             break;
 710         }
 711 
 712         case CompareEq:
 713         case CompareLess:
 714         case CompareLessEq:
 715         case CompareGreater:
 716         case CompareGreaterEq: {
 717             if (node-&gt;op() == CompareEq
 718                 &amp;&amp; Node::shouldSpeculateBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 719                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
 720                 fixEdge&lt;BooleanUse&gt;(node-&gt;child2());
 721                 node-&gt;clearFlags(NodeMustGenerate);
 722                 break;
 723             }
 724             if (Node::shouldSpeculateInt32OrBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 725                 fixIntOrBooleanEdge(node-&gt;child1());
 726                 fixIntOrBooleanEdge(node-&gt;child2());
 727                 node-&gt;clearFlags(NodeMustGenerate);
 728                 break;
 729             }
 730             if (Node::shouldSpeculateInt52(node-&gt;child1().node(), node-&gt;child2().node())) {
 731                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 732                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
 733                 node-&gt;clearFlags(NodeMustGenerate);
 734                 break;
 735             }
 736             if (Node::shouldSpeculateNumberOrBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 737                 fixDoubleOrBooleanEdge(node-&gt;child1());
 738                 fixDoubleOrBooleanEdge(node-&gt;child2());
 739             }
 740             if (node-&gt;op() != CompareEq
 741                 &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateNotCell()
 742                 &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateNotCell()) {
 743                 if (node-&gt;child1()-&gt;shouldSpeculateNumberOrBoolean())
 744                     fixDoubleOrBooleanEdge(node-&gt;child1());
 745                 else
 746                     fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
 747                 if (node-&gt;child2()-&gt;shouldSpeculateNumberOrBoolean())
 748                     fixDoubleOrBooleanEdge(node-&gt;child2());
 749                 else
 750                     fixEdge&lt;DoubleRepUse&gt;(node-&gt;child2());
 751                 node-&gt;clearFlags(NodeMustGenerate);
 752                 break;
 753             }
 754             if (node-&gt;child1()-&gt;shouldSpeculateStringIdent() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateStringIdent()) {
 755                 fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
 756                 fixEdge&lt;StringIdentUse&gt;(node-&gt;child2());
 757                 node-&gt;clearFlags(NodeMustGenerate);
 758                 break;
 759             }
 760             if (node-&gt;child1()-&gt;shouldSpeculateString() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateString() &amp;&amp; GPRInfo::numberOfRegisters &gt;= 7) {
 761                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
 762                 fixEdge&lt;StringUse&gt;(node-&gt;child2());
 763                 node-&gt;clearFlags(NodeMustGenerate);
 764                 break;
 765             }
 766 
 767             if (node-&gt;op() != CompareEq)
 768                 break;
 769             if (Node::shouldSpeculateSymbol(node-&gt;child1().node(), node-&gt;child2().node())) {
 770                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
 771                 fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
 772                 node-&gt;clearFlags(NodeMustGenerate);
 773                 break;
 774             }
 775             if (node-&gt;child1()-&gt;shouldSpeculateObject() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateObject()) {
 776                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
 777                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
 778                 node-&gt;clearFlags(NodeMustGenerate);
 779                 break;
 780             }
 781 
 782             // If either child can be proved to be Null or Undefined, comparing them is greatly simplified.
 783             bool oneArgumentIsUsedAsSpecOther = false;
 784             if (node-&gt;child1()-&gt;isUndefinedOrNullConstant()) {
 785                 fixEdge&lt;KnownOtherUse&gt;(node-&gt;child1());
 786                 oneArgumentIsUsedAsSpecOther = true;
 787             } else if (node-&gt;child1()-&gt;shouldSpeculateOther()) {
 788                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin,
 789                     Edge(node-&gt;child1().node(), OtherUse));
 790                 fixEdge&lt;KnownOtherUse&gt;(node-&gt;child1());
 791                 oneArgumentIsUsedAsSpecOther = true;
 792             }
 793             if (node-&gt;child2()-&gt;isUndefinedOrNullConstant()) {
 794                 fixEdge&lt;KnownOtherUse&gt;(node-&gt;child2());
 795                 oneArgumentIsUsedAsSpecOther = true;
 796             } else if (node-&gt;child2()-&gt;shouldSpeculateOther()) {
 797                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin,
 798                     Edge(node-&gt;child2().node(), OtherUse));
 799                 fixEdge&lt;KnownOtherUse&gt;(node-&gt;child2());
 800                 oneArgumentIsUsedAsSpecOther = true;
 801             }
 802             if (oneArgumentIsUsedAsSpecOther) {
 803                 node-&gt;clearFlags(NodeMustGenerate);
 804                 break;
 805             }
 806 
 807             if (node-&gt;child1()-&gt;shouldSpeculateObject() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateObjectOrOther()) {
 808                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
 809                 fixEdge&lt;ObjectOrOtherUse&gt;(node-&gt;child2());
 810                 node-&gt;clearFlags(NodeMustGenerate);
 811                 break;
 812             }
 813             if (node-&gt;child1()-&gt;shouldSpeculateObjectOrOther() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateObject()) {
 814                 fixEdge&lt;ObjectOrOtherUse&gt;(node-&gt;child1());
 815                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
 816                 node-&gt;clearFlags(NodeMustGenerate);
 817                 break;
 818             }
 819 
 820             break;
 821         }
 822 
 823         case CompareStrictEq:
 824         case SameValue: {
 825             fixupCompareStrictEqAndSameValue(node);
 826             break;
 827         }
 828 
 829         case StringFromCharCode:
 830             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
 831                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
 832                 node-&gt;clearFlags(NodeMustGenerate);
 833             } else
 834                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 835             break;
 836 
 837         case StringCharAt:
 838         case StringCharCodeAt: {
 839             // Currently we have no good way of refining these.
 840             ASSERT(node-&gt;arrayMode() == ArrayMode(Array::String, Array::Read));
 841             blessArrayOperation(node-&gt;child1(), node-&gt;child2(), node-&gt;child3());
 842             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
 843             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
 844             break;
 845         }
 846 
 847         case GetByVal: {
 848             if (!node-&gt;prediction()) {
 849                 m_insertionSet.insertNode(
 850                     m_indexInBlock, SpecNone, ForceOSRExit, node-&gt;origin);
 851             }
 852 
 853             node-&gt;setArrayMode(
 854                 node-&gt;arrayMode().refine(
 855                     m_graph, node,
 856                     m_graph.varArgChild(node, 0)-&gt;prediction(),
 857                     m_graph.varArgChild(node, 1)-&gt;prediction(),
 858                     SpecNone));
 859 
 860             blessArrayOperation(m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1), m_graph.varArgChild(node, 2));
 861 
 862             ArrayMode arrayMode = node-&gt;arrayMode();
 863             switch (arrayMode.type()) {
 864             case Array::Contiguous:
 865             case Array::Double:
 866                 if (arrayMode.isJSArrayWithOriginalStructure() &amp;&amp; arrayMode.speculation() == Array::InBounds) {
 867                     // Check if SaneChain will work on a per-type basis. Note that:
 868                     //
 869                     // 1) We don&#39;t want double arrays to sometimes return undefined, since
 870                     // that would require a change to the return type and it would pessimise
 871                     // things a lot. So, we&#39;d only want to do that if we actually had
 872                     // evidence that we could read from a hole. That&#39;s pretty annoying.
 873                     // Likely the best way to handle that case is with an equivalent of
 874                     // SaneChain for OutOfBounds. For now we just detect when Undefined and
 875                     // NaN are indistinguishable according to backwards propagation, and just
 876                     // use SaneChain in that case. This happens to catch a lot of cases.
 877                     //
 878                     // 2) We don&#39;t want int32 array loads to have to do a hole check just to
 879                     // coerce to Undefined, since that would mean twice the checks.
 880                     //
 881                     // This has two implications. First, we have to do more checks than we&#39;d
 882                     // like. It&#39;s unfortunate that we have to do the hole check. Second,
 883                     // some accesses that hit a hole will now need to take the full-blown
 884                     // out-of-bounds slow path. We can fix that with:
 885                     // https://bugs.webkit.org/show_bug.cgi?id=144668
 886 
 887                     bool canDoSaneChain = false;
 888                     switch (arrayMode.type()) {
 889                     case Array::Contiguous:
 890                         // This is happens to be entirely natural. We already would have
 891                         // returned any JSValue, and now we&#39;ll return Undefined. We still do
 892                         // the check but it doesn&#39;t require taking any kind of slow path.
 893                         canDoSaneChain = true;
 894                         break;
 895 
 896                     case Array::Double:
 897                         if (!(node-&gt;flags() &amp; NodeBytecodeUsesAsOther)) {
 898                             // Holes look like NaN already, so if the user doesn&#39;t care
 899                             // about the difference between Undefined and NaN then we can
 900                             // do this.
 901                             canDoSaneChain = true;
 902                         }
 903                         break;
 904 
 905                     default:
 906                         break;
 907                     }
 908 
 909                     if (canDoSaneChain) {
 910                         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
 911                         Structure* arrayPrototypeStructure = globalObject-&gt;arrayPrototype()-&gt;structure(vm());
 912                         Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm());
 913                         if (arrayPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
 914                             &amp;&amp; objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
 915                             &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane()) {
 916                             m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
 917                             m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
 918                             node-&gt;setArrayMode(arrayMode.withSpeculation(Array::SaneChain));
 919                         }
 920                     }
 921                 }
 922                 break;
 923 
 924             case Array::String:
 925                 if ((node-&gt;prediction() &amp; ~SpecString)
 926                     || m_graph.hasExitSite(node-&gt;origin.semantic, OutOfBounds))
 927                     node-&gt;setArrayMode(arrayMode.withSpeculation(Array::OutOfBounds));
 928                 break;
 929 
 930             default:
 931                 break;
 932             }
 933 
 934             arrayMode = node-&gt;arrayMode();
 935             switch (arrayMode.type()) {
 936             case Array::SelectUsingPredictions:
 937             case Array::Unprofiled:
 938                 RELEASE_ASSERT_NOT_REACHED();
 939                 break;
 940             case Array::Generic:
 941                 if (m_graph.varArgChild(node, 0)-&gt;shouldSpeculateObject()) {
 942                     if (m_graph.varArgChild(node, 1)-&gt;shouldSpeculateString()) {
 943                         fixEdge&lt;ObjectUse&gt;(m_graph.varArgChild(node, 0));
 944                         fixEdge&lt;StringUse&gt;(m_graph.varArgChild(node, 1));
 945                         break;
 946                     }
 947 
 948                     if (m_graph.varArgChild(node, 1)-&gt;shouldSpeculateSymbol()) {
 949                         fixEdge&lt;ObjectUse&gt;(m_graph.varArgChild(node, 0));
 950                         fixEdge&lt;SymbolUse&gt;(m_graph.varArgChild(node, 1));
 951                         break;
 952                     }
 953                 }
 954 #if USE(JSVALUE32_64)
 955                 fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0)); // Speculating cell due to register pressure on 32-bit.
 956 #endif
 957                 break;
 958             case Array::ForceExit:
 959                 break;
 960             case Array::String:
 961                 fixEdge&lt;KnownStringUse&gt;(m_graph.varArgChild(node, 0));
 962                 fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
 963                 break;
 964             default:
 965                 fixEdge&lt;KnownCellUse&gt;(m_graph.varArgChild(node, 0));
 966                 fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
 967                 break;
 968             }
 969 
 970             switch (arrayMode.type()) {
 971             case Array::Double:
 972                 if (!arrayMode.isOutOfBounds())
 973                     node-&gt;setResult(NodeResultDouble);
 974                 break;
 975 
 976             case Array::Float32Array:
 977             case Array::Float64Array:
 978                 node-&gt;setResult(NodeResultDouble);
 979                 break;
 980 
 981             case Array::Uint32Array:
 982                 if (node-&gt;shouldSpeculateInt32())
 983                     break;
 984                 if (node-&gt;shouldSpeculateInt52())
 985                     node-&gt;setResult(NodeResultInt52);
 986                 else
 987                     node-&gt;setResult(NodeResultDouble);
 988                 break;
 989 
 990             default:
 991                 break;
 992             }
 993 
 994             break;
 995         }
 996 
 997         case PutByValDirect:
 998         case PutByVal:
 999         case PutByValAlias: {
1000             Edge&amp; child1 = m_graph.varArgChild(node, 0);
1001             Edge&amp; child2 = m_graph.varArgChild(node, 1);
1002             Edge&amp; child3 = m_graph.varArgChild(node, 2);
1003 
1004             node-&gt;setArrayMode(
1005                 node-&gt;arrayMode().refine(
1006                     m_graph, node,
1007                     child1-&gt;prediction(),
1008                     child2-&gt;prediction(),
1009                     child3-&gt;prediction()));
1010 
1011             blessArrayOperation(child1, child2, m_graph.varArgChild(node, 3));
1012 
1013             switch (node-&gt;arrayMode().modeForPut().type()) {
1014             case Array::SelectUsingPredictions:
1015             case Array::SelectUsingArguments:
1016             case Array::Unprofiled:
1017             case Array::Undecided:
1018                 RELEASE_ASSERT_NOT_REACHED();
1019                 break;
1020             case Array::ForceExit:
1021             case Array::Generic:
1022                 if (child1-&gt;shouldSpeculateCell()) {
1023                     if (child2-&gt;shouldSpeculateString()) {
1024                         fixEdge&lt;CellUse&gt;(child1);
1025                         fixEdge&lt;StringUse&gt;(child2);
1026                         break;
1027                     }
1028 
1029                     if (child2-&gt;shouldSpeculateSymbol()) {
1030                         fixEdge&lt;CellUse&gt;(child1);
1031                         fixEdge&lt;SymbolUse&gt;(child2);
1032                         break;
1033                     }
1034                 }
1035 #if USE(JSVALUE32_64)
1036                 // Due to register pressure on 32-bit, we speculate cell and
1037                 // ignore the base-is-not-cell case entirely by letting the
1038                 // baseline JIT handle it.
1039                 fixEdge&lt;CellUse&gt;(child1);
1040 #endif
1041                 break;
1042             case Array::Int32:
1043                 fixEdge&lt;KnownCellUse&gt;(child1);
1044                 fixEdge&lt;Int32Use&gt;(child2);
1045                 fixEdge&lt;Int32Use&gt;(child3);
1046                 break;
1047             case Array::Double:
1048                 fixEdge&lt;KnownCellUse&gt;(child1);
1049                 fixEdge&lt;Int32Use&gt;(child2);
1050                 fixEdge&lt;DoubleRepRealUse&gt;(child3);
1051                 break;
1052             case Array::Int8Array:
1053             case Array::Int16Array:
1054             case Array::Int32Array:
1055             case Array::Uint8Array:
1056             case Array::Uint8ClampedArray:
1057             case Array::Uint16Array:
1058             case Array::Uint32Array:
1059                 fixEdge&lt;KnownCellUse&gt;(child1);
1060                 fixEdge&lt;Int32Use&gt;(child2);
1061                 if (child3-&gt;shouldSpeculateInt32())
1062                     fixIntOrBooleanEdge(child3);
1063                 else if (child3-&gt;shouldSpeculateInt52())
1064                     fixEdge&lt;Int52RepUse&gt;(child3);
1065                 else
1066                     fixDoubleOrBooleanEdge(child3);
1067                 break;
1068             case Array::Float32Array:
1069             case Array::Float64Array:
1070                 fixEdge&lt;KnownCellUse&gt;(child1);
1071                 fixEdge&lt;Int32Use&gt;(child2);
1072                 fixDoubleOrBooleanEdge(child3);
1073                 break;
1074             case Array::Contiguous:
1075             case Array::ArrayStorage:
1076             case Array::SlowPutArrayStorage:
1077                 fixEdge&lt;KnownCellUse&gt;(child1);
1078                 fixEdge&lt;Int32Use&gt;(child2);
1079                 speculateForBarrier(child3);
1080                 break;
1081             default:
1082                 fixEdge&lt;KnownCellUse&gt;(child1);
1083                 fixEdge&lt;Int32Use&gt;(child2);
1084                 break;
1085             }
1086             break;
1087         }
1088 
1089         case AtomicsAdd:
1090         case AtomicsAnd:
1091         case AtomicsCompareExchange:
1092         case AtomicsExchange:
1093         case AtomicsLoad:
1094         case AtomicsOr:
1095         case AtomicsStore:
1096         case AtomicsSub:
1097         case AtomicsXor: {
1098             Edge&amp; base = m_graph.child(node, 0);
1099             Edge&amp; index = m_graph.child(node, 1);
1100 
1101             bool badNews = false;
1102             for (unsigned i = numExtraAtomicsArgs(node-&gt;op()); i--;) {
1103                 Edge&amp; child = m_graph.child(node, 2 + i);
1104                 // NOTE: DFG is not smart enough to handle double-&gt;int conversions in atomics. So, we
1105                 // just call the function when that happens. But the FTL is totally cool with those
1106                 // conversions.
1107                 if (!child-&gt;shouldSpeculateInt32()
1108                     &amp;&amp; !child-&gt;shouldSpeculateInt52()
1109                     &amp;&amp; !(child-&gt;shouldSpeculateNumberOrBoolean() &amp;&amp; m_graph.m_plan.isFTL()))
1110                     badNews = true;
1111             }
1112 
1113             if (badNews) {
1114                 node-&gt;setArrayMode(ArrayMode(Array::Generic, node-&gt;arrayMode().action()));
1115                 break;
1116             }
1117 
1118             node-&gt;setArrayMode(
1119                 node-&gt;arrayMode().refine(
1120                     m_graph, node, base-&gt;prediction(), index-&gt;prediction()));
1121 
1122             if (node-&gt;arrayMode().type() == Array::Generic)
1123                 break;
1124 
1125             for (unsigned i = numExtraAtomicsArgs(node-&gt;op()); i--;) {
1126                 Edge&amp; child = m_graph.child(node, 2 + i);
1127                 if (child-&gt;shouldSpeculateInt32())
1128                     fixIntOrBooleanEdge(child);
1129                 else if (child-&gt;shouldSpeculateInt52())
1130                     fixEdge&lt;Int52RepUse&gt;(child);
1131                 else {
1132                     RELEASE_ASSERT(child-&gt;shouldSpeculateNumberOrBoolean() &amp;&amp; m_graph.m_plan.isFTL());
1133                     fixDoubleOrBooleanEdge(child);
1134                 }
1135             }
1136 
1137             blessArrayOperation(base, index, m_graph.child(node, 2 + numExtraAtomicsArgs(node-&gt;op())));
1138             fixEdge&lt;CellUse&gt;(base);
1139             fixEdge&lt;Int32Use&gt;(index);
1140 
1141             if (node-&gt;arrayMode().type() == Array::Uint32Array) {
1142                 // NOTE: This means basically always doing Int52.
1143                 if (node-&gt;shouldSpeculateInt52())
1144                     node-&gt;setResult(NodeResultInt52);
1145                 else
1146                     node-&gt;setResult(NodeResultDouble);
1147             }
1148             break;
1149         }
1150 
1151         case AtomicsIsLockFree:
1152             if (node-&gt;child1()-&gt;shouldSpeculateInt32())
1153                 fixIntOrBooleanEdge(node-&gt;child1());
1154             break;
1155 
1156         case ArrayPush: {
1157             // May need to refine the array mode in case the value prediction contravenes
1158             // the array prediction. For example, we may have evidence showing that the
1159             // array is in Int32 mode, but the value we&#39;re storing is likely to be a double.
1160             // Then we should turn this into a conversion to Double array followed by the
1161             // push. On the other hand, we absolutely don&#39;t want to refine based on the
1162             // base prediction. If it has non-cell garbage in it, then we want that to be
1163             // ignored. That&#39;s because ArrayPush can&#39;t handle any array modes that aren&#39;t
1164             // array-related - so if refine() turned this into a &quot;Generic&quot; ArrayPush then
1165             // that would break things.
1166             Edge&amp; storageEdge = m_graph.varArgChild(node, 0);
1167             Edge&amp; arrayEdge = m_graph.varArgChild(node, 1);
1168             unsigned elementOffset = 2;
1169             unsigned elementCount = node-&gt;numChildren() - elementOffset;
1170             for (unsigned i = 0; i &lt; elementCount; ++i) {
1171                 Edge&amp; element = m_graph.varArgChild(node, i + elementOffset);
1172                 node-&gt;setArrayMode(
1173                     node-&gt;arrayMode().refine(
1174                         m_graph, node,
1175                         arrayEdge-&gt;prediction() &amp; SpecCell,
1176                         SpecInt32Only,
1177                         element-&gt;prediction()));
1178             }
1179             blessArrayOperation(arrayEdge, Edge(), storageEdge);
1180             fixEdge&lt;KnownCellUse&gt;(arrayEdge);
1181 
1182             // Convert `array.push()` to GetArrayLength.
1183             if (!elementCount &amp;&amp; node-&gt;arrayMode().supportsSelfLength()) {
1184                 node-&gt;setOpAndDefaultFlags(GetArrayLength);
1185                 node-&gt;child1() = arrayEdge;
1186                 node-&gt;child2() = storageEdge;
1187                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1188                 break;
1189             }
1190 
1191             // We do not want to perform osr exit and retry for ArrayPush. We insert Check with appropriate type,
1192             // and ArrayPush uses the edge as known typed edge. Therefore, ArrayPush do not need to perform type checks.
1193             for (unsigned i = 0; i &lt; elementCount; ++i) {
1194                 Edge&amp; element = m_graph.varArgChild(node, i + elementOffset);
1195                 switch (node-&gt;arrayMode().type()) {
1196                 case Array::Int32:
1197                     fixEdge&lt;Int32Use&gt;(element);
1198                     break;
1199                 case Array::Double:
1200                     fixEdge&lt;DoubleRepRealUse&gt;(element);
1201                     break;
1202                 case Array::Contiguous:
1203                 case Array::ArrayStorage:
1204                     speculateForBarrier(element);
1205                     break;
1206                 default:
1207                     break;
1208                 }
1209             }
1210             break;
1211         }
1212 
1213         case ArrayPop: {
1214             blessArrayOperation(node-&gt;child1(), Edge(), node-&gt;child2());
1215             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1216             break;
1217         }
1218 
1219         case ArraySlice: {
1220             fixEdge&lt;KnownCellUse&gt;(m_graph.varArgChild(node, 0));
1221             if (node-&gt;numChildren() &gt;= 3) {
1222                 fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
1223                 if (node-&gt;numChildren() == 4)
1224                     fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 2));
1225             }
1226             break;
1227         }
1228 
1229         case ArrayIndexOf:
1230             fixupArrayIndexOf(node);
1231             break;
1232 
1233         case RegExpExec:
1234         case RegExpTest: {
1235             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1236 
1237             if (node-&gt;child2()-&gt;shouldSpeculateRegExpObject()) {
1238                 fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child2());
1239 
1240                 if (node-&gt;child3()-&gt;shouldSpeculateString())
1241                     fixEdge&lt;StringUse&gt;(node-&gt;child3());
1242             }
1243             break;
1244         }
1245 
1246         case RegExpMatchFast: {
1247             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1248             fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child2());
1249             fixEdge&lt;StringUse&gt;(node-&gt;child3());
1250             break;
1251         }
1252 
1253         case StringReplace:
1254         case StringReplaceRegExp: {
1255             if (node-&gt;child2()-&gt;shouldSpeculateString()) {
1256                 m_insertionSet.insertNode(
1257                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
1258                     Edge(node-&gt;child2().node(), StringUse));
1259                 fixEdge&lt;StringUse&gt;(node-&gt;child2());
1260             } else if (op == StringReplace) {
1261                 if (node-&gt;child2()-&gt;shouldSpeculateRegExpObject())
1262                     addStringReplacePrimordialChecks(node-&gt;child2().node());
1263                 else
1264                     m_insertionSet.insertNode(
1265                         m_indexInBlock, SpecNone, ForceOSRExit, node-&gt;origin);
1266             }
1267 
1268             if (node-&gt;child1()-&gt;shouldSpeculateString()
1269                 &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateRegExpObject()
1270                 &amp;&amp; node-&gt;child3()-&gt;shouldSpeculateString()) {
1271 
1272                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
1273                 fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child2());
1274                 fixEdge&lt;StringUse&gt;(node-&gt;child3());
1275                 break;
1276             }
1277             break;
1278         }
1279 
1280         case Branch: {
1281             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
1282                 if (node-&gt;child1()-&gt;result() == NodeResultBoolean) {
1283                     // This is necessary in case we have a bytecode instruction implemented by:
1284                     //
1285                     // a: CompareEq(...)
1286                     // b: Branch(@a)
1287                     //
1288                     // In that case, CompareEq might have a side-effect. Then, we need to make
1289                     // sure that we know that Branch does not exit.
1290                     fixEdge&lt;KnownBooleanUse&gt;(node-&gt;child1());
1291                 } else
1292                     fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
1293             } else if (node-&gt;child1()-&gt;shouldSpeculateObjectOrOther())
1294                 fixEdge&lt;ObjectOrOtherUse&gt;(node-&gt;child1());
1295             else if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean())
1296                 fixIntOrBooleanEdge(node-&gt;child1());
1297             else if (node-&gt;child1()-&gt;shouldSpeculateNumber())
1298                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
1299             else if (node-&gt;child1()-&gt;shouldSpeculateString())
1300                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
1301             else if (node-&gt;child1()-&gt;shouldSpeculateStringOrOther())
1302                 fixEdge&lt;StringOrOtherUse&gt;(node-&gt;child1());
1303             else {
1304                 WatchpointSet* masqueradesAsUndefinedWatchpoint = m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;masqueradesAsUndefinedWatchpoint();
1305                 if (masqueradesAsUndefinedWatchpoint-&gt;isStillValid())
1306                     m_graph.watchpoints().addLazily(masqueradesAsUndefinedWatchpoint);
1307             }
1308             break;
1309         }
1310 
1311         case Switch: {
1312             SwitchData* data = node-&gt;switchData();
1313             switch (data-&gt;kind) {
1314             case SwitchImm:
1315                 if (node-&gt;child1()-&gt;shouldSpeculateInt32())
1316                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1317                 break;
1318             case SwitchChar:
1319                 if (node-&gt;child1()-&gt;shouldSpeculateString())
1320                     fixEdge&lt;StringUse&gt;(node-&gt;child1());
1321                 break;
1322             case SwitchString:
1323                 if (node-&gt;child1()-&gt;shouldSpeculateStringIdent())
1324                     fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
1325                 else if (node-&gt;child1()-&gt;shouldSpeculateString())
1326                     fixEdge&lt;StringUse&gt;(node-&gt;child1());
1327                 break;
1328             case SwitchCell:
1329                 if (node-&gt;child1()-&gt;shouldSpeculateCell())
1330                     fixEdge&lt;CellUse&gt;(node-&gt;child1());
1331                 // else it&#39;s fine for this to have UntypedUse; we will handle this by just making
1332                 // non-cells take the default case.
1333                 break;
1334             }
1335             break;
1336         }
1337 
1338         case ToPrimitive: {
1339             fixupToPrimitive(node);
1340             break;
1341         }
1342 
1343         case ToNumber: {
1344             fixupToNumber(node);
1345             break;
1346         }
1347 
1348         case ToString:
1349         case CallStringConstructor: {
1350             fixupToStringOrCallStringConstructor(node);
1351             break;
1352         }
1353 
1354         case NewStringObject: {
1355             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
1356             break;
1357         }
1358 
1359         case NewSymbol: {
1360             if (node-&gt;child1())
1361                 fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
1362             break;
1363         }
1364 
1365         case NewArrayWithSpread: {
1366             watchHavingABadTime(node);
1367 
1368             BitVector* bitVector = node-&gt;bitVector();
1369             for (unsigned i = node-&gt;numChildren(); i--;) {
1370                 if (bitVector-&gt;get(i))
1371                     fixEdge&lt;KnownCellUse&gt;(m_graph.m_varArgChildren[node-&gt;firstChild() + i]);
1372                 else
1373                     fixEdge&lt;UntypedUse&gt;(m_graph.m_varArgChildren[node-&gt;firstChild() + i]);
1374             }
1375 
1376             break;
1377         }
1378 
1379         case Spread: {
1380             // Note: We care about performing the protocol on our child&#39;s global object, not necessarily ours.
1381 
1382             watchHavingABadTime(node-&gt;child1().node());
1383 
1384             JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;child1()-&gt;origin.semantic);
1385             // When we go down the fast path, we don&#39;t consult the prototype chain, so we must prove
1386             // that it doesn&#39;t contain any indexed properties, and that any holes will result in
1387             // jsUndefined().
1388             Structure* arrayPrototypeStructure = globalObject-&gt;arrayPrototype()-&gt;structure(vm());
1389             Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm());
1390             if (node-&gt;child1()-&gt;shouldSpeculateArray()
1391                 &amp;&amp; arrayPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
1392                 &amp;&amp; objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
1393                 &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane()
1394                 &amp;&amp; m_graph.isWatchingArrayIteratorProtocolWatchpoint(node-&gt;child1().node())
1395                 &amp;&amp; m_graph.isWatchingHavingABadTimeWatchpoint(node-&gt;child1().node())) {
1396                 m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
1397                 m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
1398                 fixEdge&lt;ArrayUse&gt;(node-&gt;child1());
1399             } else
1400                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1401             break;
1402         }
1403 
1404         case NewArray: {
1405             watchHavingABadTime(node);
1406 
1407             for (unsigned i = m_graph.varArgNumChildren(node); i--;) {
1408                 node-&gt;setIndexingType(
1409                     leastUpperBoundOfIndexingTypeAndType(
1410                         node-&gt;indexingType(), m_graph.varArgChild(node, i)-&gt;prediction()));
1411             }
1412             switch (node-&gt;indexingType()) {
1413             case ALL_BLANK_INDEXING_TYPES:
1414                 CRASH();
1415                 break;
1416             case ALL_UNDECIDED_INDEXING_TYPES:
1417                 if (node-&gt;numChildren()) {
1418                     // This will only happen if the children have no type predictions. We
1419                     // would have already exited by now, but insert a forced exit just to
1420                     // be safe.
1421                     m_insertionSet.insertNode(
1422                         m_indexInBlock, SpecNone, ForceOSRExit, node-&gt;origin);
1423                 }
1424                 break;
1425             case ALL_INT32_INDEXING_TYPES:
1426                 for (unsigned operandIndex = 0; operandIndex &lt; node-&gt;numChildren(); ++operandIndex)
1427                     fixEdge&lt;Int32Use&gt;(m_graph.m_varArgChildren[node-&gt;firstChild() + operandIndex]);
1428                 break;
1429             case ALL_DOUBLE_INDEXING_TYPES:
1430                 for (unsigned operandIndex = 0; operandIndex &lt; node-&gt;numChildren(); ++operandIndex)
1431                     fixEdge&lt;DoubleRepRealUse&gt;(m_graph.m_varArgChildren[node-&gt;firstChild() + operandIndex]);
1432                 break;
1433             case ALL_CONTIGUOUS_INDEXING_TYPES:
1434             case ALL_ARRAY_STORAGE_INDEXING_TYPES:
1435                 break;
1436             default:
1437                 CRASH();
1438                 break;
1439             }
1440             break;
1441         }
1442 
1443         case NewTypedArray: {
1444             watchHavingABadTime(node);
1445 
1446             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
1447                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1448                 node-&gt;clearFlags(NodeMustGenerate);
1449                 break;
1450             }
1451             break;
1452         }
1453 
1454         case NewArrayWithSize: {
1455             watchHavingABadTime(node);
1456             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1457             break;
1458         }
1459 
1460         case NewArrayBuffer: {
1461             watchHavingABadTime(node);
1462             break;
1463         }
1464 
1465         case ToObject: {
1466             fixupToObject(node);
1467             break;
1468         }
1469 
1470         case CallObjectConstructor: {
1471             fixupCallObjectConstructor(node);
1472             break;
1473         }
1474 
1475         case ToThis: {
1476             fixupToThis(node);
1477             break;
1478         }
1479 
1480         case PutStructure: {
1481             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1482             break;
1483         }
1484 
1485         case GetClosureVar:
1486         case GetFromArguments: {
1487             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1488             break;
1489         }
1490 
1491         case PutClosureVar:
1492         case PutToArguments: {
1493             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1494             speculateForBarrier(node-&gt;child2());
1495             break;
1496         }
1497 
1498         case SkipScope:
1499         case GetScope:
1500         case GetGetter:
1501         case GetSetter:
1502         case GetGlobalObject: {
1503             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1504             break;
1505         }
1506 
1507         case AllocatePropertyStorage:
1508         case ReallocatePropertyStorage: {
1509             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1510             break;
1511         }
1512 
1513         case NukeStructureAndSetButterfly: {
1514             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1515             break;
1516         }
1517 
1518         case TryGetById: {
1519             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1520                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1521             break;
1522         }
1523 
1524         case GetByIdDirect:
1525         case GetByIdDirectFlush: {
1526             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1527                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1528             break;
1529         }
1530 
1531         case GetById:
1532         case GetByIdFlush: {
1533             // FIXME: This should be done in the ByteCodeParser based on reading the
1534             // PolymorphicAccess, which will surely tell us that this is a AccessCase::ArrayLength.
1535             // https://bugs.webkit.org/show_bug.cgi?id=154990
1536             auto uid = m_graph.identifiers()[node-&gt;identifierNumber()];
1537             if (node-&gt;child1()-&gt;shouldSpeculateCellOrOther()
1538                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadType)
1539                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadCache)
1540                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadIndexingType)
1541                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, ExoticObjectMode)) {
1542 
1543                 if (uid == vm().propertyNames-&gt;length.impl()) {
1544                     attemptToMakeGetArrayLength(node);
1545                     break;
1546                 }
1547 
1548                 if (uid == vm().propertyNames-&gt;lastIndex.impl()
1549                     &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {
1550                     node-&gt;setOp(GetRegExpObjectLastIndex);
1551                     node-&gt;clearFlags(NodeMustGenerate);
1552                     fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child1());
1553                     break;
1554                 }
1555             }
1556 
1557             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
1558                 if (uid == vm().propertyNames-&gt;toString.impl()) {
1559                     if (m_graph.isWatchingNumberToStringWatchpoint(node)) {
1560                         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
1561                         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
1562                             insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
1563                             m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1564                             break;
1565                         }
1566 
1567                         if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {
1568                             insertCheck&lt;Int52RepUse&gt;(node-&gt;child1().node());
1569                             m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1570                             break;
1571                         }
1572 
1573                         ASSERT(node-&gt;child1()-&gt;shouldSpeculateNumber());
1574                         insertCheck&lt;DoubleRepUse&gt;(node-&gt;child1().node());
1575                         m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1576                         break;
1577                     }
1578                 }
1579             }
1580 
1581             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1582                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1583             break;
1584         }
1585 
1586         case GetByIdWithThis: {
1587             if (node-&gt;child1()-&gt;shouldSpeculateCell() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateCell()) {
1588                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1589                 fixEdge&lt;CellUse&gt;(node-&gt;child2());
1590             }
1591             break;
1592         }
1593 
1594         case PutById:
1595         case PutByIdFlush:
1596         case PutByIdDirect: {
1597             if (node-&gt;child1()-&gt;shouldSpeculateCellOrOther()
1598                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadType)
1599                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadCache)
1600                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadIndexingType)
1601                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, ExoticObjectMode)) {
1602 
1603                 auto uid = m_graph.identifiers()[node-&gt;identifierNumber()];
1604 
1605                 if (uid == vm().propertyNames-&gt;lastIndex.impl()
1606                     &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {
1607                     node-&gt;convertToSetRegExpObjectLastIndex();
1608                     fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child1());
1609                     speculateForBarrier(node-&gt;child2());
1610                     break;
1611                 }
1612             }
1613 
1614             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1615             break;
1616         }
1617 
1618         case PutGetterById:
1619         case PutSetterById: {
1620             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1621             fixEdge&lt;KnownCellUse&gt;(node-&gt;child2());
1622             break;
1623         }
1624 
1625         case PutGetterSetterById: {
1626             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1627             break;
1628         }
1629 
1630         case PutGetterByVal:
1631         case PutSetterByVal: {
1632             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1633             fixEdge&lt;KnownCellUse&gt;(node-&gt;child3());
1634             break;
1635         }
1636 
1637         case GetExecutable: {
1638             fixEdge&lt;FunctionUse&gt;(node-&gt;child1());
1639             break;
1640         }
1641 
1642         case OverridesHasInstance:
1643         case CheckStructure:
1644         case CheckCell:
1645         case CreateThis:
1646         case GetButterfly: {
1647             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1648             break;
1649         }
1650 
1651         case ObjectCreate: {
1652             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
1653                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
1654                 node-&gt;clearFlags(NodeMustGenerate);
1655                 break;
1656             }
1657             break;
1658         }
1659 
1660         case ObjectKeys: {
1661             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
1662                 watchHavingABadTime(node);
1663                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
1664             }
1665             break;
1666         }
1667 
1668         case CheckStringIdent: {
1669             fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
1670             break;
1671         }
1672 
1673         case Arrayify:
1674         case ArrayifyToStructure: {
1675             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1676             if (node-&gt;child2())
1677                 fixEdge&lt;Int32Use&gt;(node-&gt;child2());
1678             break;
1679         }
1680 
1681         case GetByOffset:
1682         case GetGetterSetterByOffset: {
1683             if (!node-&gt;child1()-&gt;hasStorageResult())
1684                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1685             fixEdge&lt;KnownCellUse&gt;(node-&gt;child2());
1686             break;
1687         }
1688 
1689         case MultiGetByOffset: {
1690             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1691             break;
1692         }
1693 
1694         case PutByOffset: {
1695             if (!node-&gt;child1()-&gt;hasStorageResult())
1696                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1697             fixEdge&lt;KnownCellUse&gt;(node-&gt;child2());
1698             speculateForBarrier(node-&gt;child3());
1699             break;
1700         }
1701 
1702         case MultiPutByOffset: {
1703             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1704             break;
1705         }
1706 
1707         case MatchStructure: {
1708             // FIXME: Introduce a variant of MatchStructure that doesn&#39;t do a cell check.
1709             // https://bugs.webkit.org/show_bug.cgi?id=185784
1710             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1711             break;
1712         }
1713 
1714         case InstanceOf: {
1715             if (node-&gt;child1()-&gt;shouldSpeculateCell()
1716                 &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateCell()
1717                 &amp;&amp; is64Bit()) {
1718                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1719                 fixEdge&lt;CellUse&gt;(node-&gt;child2());
1720                 break;
1721             }
1722             break;
1723         }
1724 
1725         case InstanceOfCustom:
1726             fixEdge&lt;CellUse&gt;(node-&gt;child2());
1727             break;
1728 
1729         case InById: {
1730             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1731             break;
1732         }
1733 
1734         case InByVal: {
1735             if (node-&gt;child2()-&gt;shouldSpeculateInt32()) {
1736                 convertToHasIndexedProperty(node);
1737                 break;
1738             }
1739 
1740             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1741             break;
1742         }
1743 
1744         case HasOwnProperty: {
1745             fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
1746 #if CPU(X86)
1747             // We don&#39;t have enough registers to do anything interesting on x86 and mips.
1748             fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
1749 #else
1750             if (node-&gt;child2()-&gt;shouldSpeculateString())
1751                 fixEdge&lt;StringUse&gt;(node-&gt;child2());
1752             else if (node-&gt;child2()-&gt;shouldSpeculateSymbol())
1753                 fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
1754             else
1755                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
1756 #endif
1757             break;
1758         }
1759 
1760         case CheckVarargs:
1761         case Check: {
1762             m_graph.doToChildren(
1763                 node,
1764                 [&amp;] (Edge&amp; edge) {
1765                     switch (edge.useKind()) {
1766                     case NumberUse:
1767                         if (edge-&gt;shouldSpeculateInt32ForArithmetic())
1768                             edge.setUseKind(Int32Use);
1769                         break;
1770                     default:
1771                         break;
1772                     }
1773                     observeUseKindOnEdge(edge);
1774                 });
1775             break;
1776         }
1777 
1778         case Phantom:
1779             // Phantoms are meaningless past Fixup. We recreate them on-demand in the backend.
1780             node-&gt;remove(m_graph);
1781             break;
1782 
1783         case FiatInt52: {
1784             RELEASE_ASSERT(enableInt52());
1785             node-&gt;convertToIdentity();
1786             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
1787             node-&gt;setResult(NodeResultInt52);
1788             break;
1789         }
1790 
1791         case GetArrayLength: {
1792             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1793             break;
1794         }
1795 
1796         case GetTypedArrayByteOffset: {
1797             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1798             break;
1799         }
1800 
1801         case CompareBelow:
1802         case CompareBelowEq: {
1803             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1804             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
1805             break;
1806         }
1807 
1808         case GetPrototypeOf: {
1809             fixupGetPrototypeOf(node);
1810             break;
1811         }
1812 
1813         case Phi:
1814         case Upsilon:
1815         case EntrySwitch:
1816         case GetIndexedPropertyStorage:
1817         case LastNodeType:
1818         case CheckTierUpInLoop:
1819         case CheckTierUpAtReturn:
1820         case CheckTierUpAndOSREnter:
1821         case CheckArray:
1822         case CheckInBounds:
1823         case ConstantStoragePointer:
1824         case DoubleAsInt32:
1825         case ValueToInt32:
1826         case DoubleRep:
1827         case ValueRep:
1828         case Int52Rep:
1829         case Int52Constant:
1830         case Identity: // This should have been cleaned up.
1831         case BooleanToNumber:
1832         case PhantomNewObject:
1833         case PhantomNewFunction:
1834         case PhantomNewGeneratorFunction:
1835         case PhantomNewAsyncGeneratorFunction:
1836         case PhantomNewAsyncFunction:
1837         case PhantomCreateActivation:
1838         case PhantomDirectArguments:
1839         case PhantomCreateRest:
1840         case PhantomSpread:
1841         case PhantomNewArrayWithSpread:
1842         case PhantomNewArrayBuffer:
1843         case PhantomClonedArguments:
1844         case PhantomNewRegexp:
1845         case GetMyArgumentByVal:
1846         case GetMyArgumentByValOutOfBounds:
1847         case GetVectorLength:
1848         case PutHint:
1849         case CheckStructureImmediate:
1850         case CheckStructureOrEmpty:
1851         case MaterializeNewObject:
1852         case MaterializeCreateActivation:
1853         case PutStack:
1854         case KillStack:
1855         case GetStack:
1856         case StoreBarrier:
1857         case FencedStoreBarrier:
1858         case GetRegExpObjectLastIndex:
1859         case SetRegExpObjectLastIndex:
1860         case RecordRegExpCachedResult:
1861         case RegExpExecNonGlobalOrSticky:
1862         case RegExpMatchFastGlobal:
1863             // These are just nodes that we don&#39;t currently expect to see during fixup.
1864             // If we ever wanted to insert them prior to fixup, then we just have to create
1865             // fixup rules for them.
1866             DFG_CRASH(m_graph, node, &quot;Unexpected node during fixup&quot;);
1867             break;
1868 
1869         case PutGlobalVariable: {
1870             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1871             speculateForBarrier(node-&gt;child2());
1872             break;
1873         }
1874 
1875         case IsObject:
1876             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
1877                 m_insertionSet.insertNode(
1878                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
1879                     Edge(node-&gt;child1().node(), ObjectUse));
1880                 m_graph.convertToConstant(node, jsBoolean(true));
1881                 observeUseKindOnNode&lt;ObjectUse&gt;(node);
1882             }
1883             break;
1884 
1885         case IsCellWithType: {
1886             fixupIsCellWithType(node);
1887             break;
1888         }
1889 
1890         case GetEnumerableLength: {
1891             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1892             break;
1893         }
1894         case HasGenericProperty: {
1895             fixEdge&lt;CellUse&gt;(node-&gt;child2());
1896             break;
1897         }
1898         case HasStructureProperty: {
1899             fixEdge&lt;StringUse&gt;(node-&gt;child2());
1900             fixEdge&lt;KnownCellUse&gt;(node-&gt;child3());
1901             break;
1902         }
1903         case HasIndexedProperty: {
1904             node-&gt;setArrayMode(
1905                 node-&gt;arrayMode().refine(
1906                     m_graph, node,
1907                     m_graph.varArgChild(node, 0)-&gt;prediction(),
1908                     m_graph.varArgChild(node, 1)-&gt;prediction(),
1909                     SpecNone));
1910 
1911             blessArrayOperation(m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1), m_graph.varArgChild(node, 2));
1912             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
1913             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
1914             break;
1915         }
1916         case GetDirectPname: {
1917             Edge&amp; base = m_graph.varArgChild(node, 0);
1918             Edge&amp; property = m_graph.varArgChild(node, 1);
1919             Edge&amp; index = m_graph.varArgChild(node, 2);
1920             Edge&amp; enumerator = m_graph.varArgChild(node, 3);
1921             fixEdge&lt;CellUse&gt;(base);
1922             fixEdge&lt;KnownCellUse&gt;(property);
1923             fixEdge&lt;Int32Use&gt;(index);
1924             fixEdge&lt;KnownCellUse&gt;(enumerator);
1925             break;
1926         }
1927         case GetPropertyEnumerator: {
1928             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1929                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1930             break;
1931         }
1932         case GetEnumeratorStructurePname: {
1933             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1934             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
1935             break;
1936         }
1937         case GetEnumeratorGenericPname: {
1938             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1939             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
1940             break;
1941         }
1942         case ToIndexString: {
1943             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1944             break;
1945         }
1946         case ProfileType: {
1947             // We want to insert type checks based on the instructionTypeSet of the TypeLocation, not the globalTypeSet.
1948             // Because the instructionTypeSet is contained in globalTypeSet, if we produce a type check for
1949             // type T for the instructionTypeSet, the global type set must also have information for type T.
1950             // So if it the type check succeeds for type T in the instructionTypeSet, a type check for type T
1951             // in the globalTypeSet would&#39;ve also succeeded.
1952             // (The other direction does not hold in general).
1953 
1954             RefPtr&lt;TypeSet&gt; typeSet = node-&gt;typeLocation()-&gt;m_instructionTypeSet;
1955             RuntimeTypeMask seenTypes = typeSet-&gt;seenTypes();
1956             if (typeSet-&gt;doesTypeConformTo(TypeAnyInt)) {
1957                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
1958                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1959                     node-&gt;remove(m_graph);
1960                     break;
1961                 }
1962 
1963                 if (enableInt52()) {
1964                     fixEdge&lt;AnyIntUse&gt;(node-&gt;child1());
1965                     node-&gt;remove(m_graph);
1966                     break;
1967                 }
1968 
1969                 // Must not perform fixEdge&lt;NumberUse&gt; here since the type set only includes TypeAnyInt. Double values should be logged.
1970             }
1971 
1972             if (typeSet-&gt;doesTypeConformTo(TypeNumber | TypeAnyInt)) {
1973                 fixEdge&lt;NumberUse&gt;(node-&gt;child1());
1974                 node-&gt;remove(m_graph);
1975             } else if (typeSet-&gt;doesTypeConformTo(TypeString)) {
1976                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
1977                 node-&gt;remove(m_graph);
1978             } else if (typeSet-&gt;doesTypeConformTo(TypeBoolean)) {
1979                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
1980                 node-&gt;remove(m_graph);
1981             } else if (typeSet-&gt;doesTypeConformTo(TypeUndefined | TypeNull) &amp;&amp; (seenTypes &amp; TypeUndefined) &amp;&amp; (seenTypes &amp; TypeNull)) {
1982                 fixEdge&lt;OtherUse&gt;(node-&gt;child1());
1983                 node-&gt;remove(m_graph);
1984             } else if (typeSet-&gt;doesTypeConformTo(TypeObject)) {
1985                 StructureSet set;
1986                 {
1987                     ConcurrentJSLocker locker(typeSet-&gt;m_lock);
1988                     set = typeSet-&gt;structureSet(locker);
1989                 }
1990                 if (!set.isEmpty()) {
1991                     fixEdge&lt;CellUse&gt;(node-&gt;child1());
1992                     node-&gt;convertToCheckStructureOrEmpty(m_graph.addStructureSet(set));
1993                 }
1994             }
1995 
1996             break;
1997         }
1998 
1999         case CreateClonedArguments: {
2000             watchHavingABadTime(node);
2001             break;
2002         }
2003 
2004         case CreateScopedArguments:
2005         case CreateActivation:
2006         case NewFunction:
2007         case NewGeneratorFunction:
2008         case NewAsyncGeneratorFunction:
2009         case NewAsyncFunction: {
2010             // Child 1 is always the current scope, which is guaranteed to be an object
2011             // FIXME: should be KnownObjectUse once that exists (https://bugs.webkit.org/show_bug.cgi?id=175689)
2012             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2013             break;
2014         }
2015 
2016         case PushWithScope: {
2017             // Child 1 is always the current scope, which is guaranteed to be an object
2018             // FIXME: should be KnownObjectUse once that exists (https://bugs.webkit.org/show_bug.cgi?id=175689)
2019             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2020             if (node-&gt;child2()-&gt;shouldSpeculateObject())
2021                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
2022             break;
2023         }
2024 
2025         case SetFunctionName: {
2026             // The first child is guaranteed to be a cell because op_set_function_name is only used
2027             // on a newly instantiated function object (the first child).
2028             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2029             fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
2030             break;
2031         }
2032 
2033         case CreateRest: {
2034             watchHavingABadTime(node);
2035             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2036             break;
2037         }
2038 
2039         case ResolveScopeForHoistingFuncDeclInEval: {
2040             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2041             break;
2042         }
2043         case ResolveScope:
2044         case GetDynamicVar:
2045         case PutDynamicVar: {
2046             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2047             break;
2048         }
2049 
2050         case LogShadowChickenPrologue: {
2051             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2052             break;
2053         }
2054         case LogShadowChickenTail: {
2055             fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2056             fixEdge&lt;KnownCellUse&gt;(node-&gt;child2());
2057             break;
2058         }
2059 
2060         case GetMapBucket:
2061             if (node-&gt;child1().useKind() == MapObjectUse)
2062                 fixEdge&lt;MapObjectUse&gt;(node-&gt;child1());
2063             else if (node-&gt;child1().useKind() == SetObjectUse)
2064                 fixEdge&lt;SetObjectUse&gt;(node-&gt;child1());
2065             else
2066                 RELEASE_ASSERT_NOT_REACHED();
2067 
2068 #if USE(JSVALUE64)
2069             if (node-&gt;child2()-&gt;shouldSpeculateBoolean())
2070                 fixEdge&lt;BooleanUse&gt;(node-&gt;child2());
2071             else if (node-&gt;child2()-&gt;shouldSpeculateInt32())
2072                 fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2073             else if (node-&gt;child2()-&gt;shouldSpeculateSymbol())
2074                 fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
2075             else if (node-&gt;child2()-&gt;shouldSpeculateObject())
2076                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
2077             else if (node-&gt;child2()-&gt;shouldSpeculateString())
2078                 fixEdge&lt;StringUse&gt;(node-&gt;child2());
2079             else if (node-&gt;child2()-&gt;shouldSpeculateCell())
2080                 fixEdge&lt;CellUse&gt;(node-&gt;child2());
2081             else
2082                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
2083 #else
2084             fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
2085 #endif // USE(JSVALUE64)
2086 
2087             fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2088             break;
2089 
2090         case GetMapBucketHead:
2091             if (node-&gt;child1().useKind() == MapObjectUse)
2092                 fixEdge&lt;MapObjectUse&gt;(node-&gt;child1());
2093             else if (node-&gt;child1().useKind() == SetObjectUse)
2094                 fixEdge&lt;SetObjectUse&gt;(node-&gt;child1());
2095             else
2096                 RELEASE_ASSERT_NOT_REACHED();
2097             break;
2098 
2099         case GetMapBucketNext:
2100         case LoadKeyFromMapBucket:
2101         case LoadValueFromMapBucket:
2102             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2103             break;
2104 
2105         case MapHash: {
2106 #if USE(JSVALUE64)
2107             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2108                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
2109                 break;
2110             }
2111 
2112             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2113                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2114                 break;
2115             }
2116 
2117             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2118                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
2119                 break;
2120             }
2121 
2122             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
2123                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
2124                 break;
2125             }
2126 
2127             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2128                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
2129                 break;
2130             }
2131 
2132             if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
2133                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
2134                 break;
2135             }
2136 
2137             fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2138 #else
2139             fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2140 #endif // USE(JSVALUE64)
2141             break;
2142         }
2143 
2144         case NormalizeMapKey: {
2145             fixupNormalizeMapKey(node);
2146             break;
2147         }
2148 
2149         case WeakMapGet: {
2150             if (node-&gt;child1().useKind() == WeakMapObjectUse)
2151                 fixEdge&lt;WeakMapObjectUse&gt;(node-&gt;child1());
2152             else if (node-&gt;child1().useKind() == WeakSetObjectUse)
2153                 fixEdge&lt;WeakSetObjectUse&gt;(node-&gt;child1());
2154             else
2155                 RELEASE_ASSERT_NOT_REACHED();
2156             fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
2157             fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2158             break;
2159         }
2160 
2161         case SetAdd: {
2162             fixEdge&lt;SetObjectUse&gt;(node-&gt;child1());
2163             fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2164             break;
2165         }
2166 
2167         case MapSet: {
2168             fixEdge&lt;MapObjectUse&gt;(m_graph.varArgChild(node, 0));
2169             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 3));
2170             break;
2171         }
2172 
2173         case WeakSetAdd: {
2174             fixEdge&lt;WeakSetObjectUse&gt;(node-&gt;child1());
2175             fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
2176             fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2177             break;
2178         }
2179 
2180         case WeakMapSet: {
2181             fixEdge&lt;WeakMapObjectUse&gt;(m_graph.varArgChild(node, 0));
2182             fixEdge&lt;ObjectUse&gt;(m_graph.varArgChild(node, 1));
2183             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 3));
2184             break;
2185         }
2186 
2187         case DefineDataProperty: {
2188             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
2189             Edge&amp; propertyEdge = m_graph.varArgChild(node, 1);
2190             if (propertyEdge-&gt;shouldSpeculateSymbol())
2191                 fixEdge&lt;SymbolUse&gt;(propertyEdge);
2192             else if (propertyEdge-&gt;shouldSpeculateStringIdent())
2193                 fixEdge&lt;StringIdentUse&gt;(propertyEdge);
2194             else if (propertyEdge-&gt;shouldSpeculateString())
2195                 fixEdge&lt;StringUse&gt;(propertyEdge);
2196             else
2197                 fixEdge&lt;UntypedUse&gt;(propertyEdge);
2198             fixEdge&lt;UntypedUse&gt;(m_graph.varArgChild(node, 2));
2199             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 3));
2200             break;
2201         }
2202 
2203         case StringValueOf: {
2204             fixupStringValueOf(node);
2205             break;
2206         }
2207 
2208         case StringSlice: {
2209             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2210             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2211             if (node-&gt;child3())
2212                 fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2213             break;
2214         }
2215 
2216         case ToLowerCase: {
2217             // We currently only support StringUse since that will ensure that
2218             // ToLowerCase is a pure operation. If we decide to update this with
2219             // more types in the future, we need to ensure that the clobberize rules
2220             // are correct.
2221             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2222             break;
2223         }
2224 
2225         case NumberToStringWithRadix: {
2226             if (node-&gt;child1()-&gt;shouldSpeculateInt32())
2227                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2228             else if (node-&gt;child1()-&gt;shouldSpeculateInt52())
2229                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
2230             else
2231                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2232             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2233             break;
2234         }
2235 
2236         case DefineAccessorProperty: {
2237             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
2238             Edge&amp; propertyEdge = m_graph.varArgChild(node, 1);
2239             if (propertyEdge-&gt;shouldSpeculateSymbol())
2240                 fixEdge&lt;SymbolUse&gt;(propertyEdge);
2241             else if (propertyEdge-&gt;shouldSpeculateStringIdent())
2242                 fixEdge&lt;StringIdentUse&gt;(propertyEdge);
2243             else if (propertyEdge-&gt;shouldSpeculateString())
2244                 fixEdge&lt;StringUse&gt;(propertyEdge);
2245             else
2246                 fixEdge&lt;UntypedUse&gt;(propertyEdge);
2247             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 2));
2248             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 3));
2249             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 4));
2250             break;
2251         }
2252 
2253         case CheckSubClass: {
2254             fixupCheckSubClass(node);
2255             break;
2256         }
2257 
2258         case CallDOMGetter: {
2259             DOMJIT::CallDOMGetterSnippet* snippet = node-&gt;callDOMGetterData()-&gt;snippet;
2260             fixEdge&lt;CellUse&gt;(node-&gt;child1()); // DOM.
2261             if (snippet &amp;&amp; snippet-&gt;requireGlobalObject)
2262                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child2()); // GlobalObject.
2263             break;
2264         }
2265 
2266         case CallDOM: {
2267             fixupCallDOM(node);
2268             break;
2269         }
2270 
2271         case Call: {
2272             attemptToMakeCallDOM(node);
2273             break;
2274         }
2275 
2276         case ParseInt: {
2277             if (node-&gt;child1()-&gt;shouldSpeculateInt32() &amp;&amp; !node-&gt;child2()) {
2278                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2279                 node-&gt;convertToIdentity();
2280                 break;
2281             }
2282 
2283             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2284                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
2285                 node-&gt;clearFlags(NodeMustGenerate);
2286             }
2287 
2288             if (node-&gt;child2())
2289                 fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2290 
2291             break;
2292         }
2293 
2294         case IdentityWithProfile: {
2295             node-&gt;clearFlags(NodeMustGenerate);
2296             break;
2297         }
2298 
2299         case ThrowStaticError:
2300             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2301             break;
2302 
2303         case NumberIsInteger:
2304             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2305                 m_insertionSet.insertNode(
2306                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2307                     Edge(node-&gt;child1().node(), Int32Use));
2308                 m_graph.convertToConstant(node, jsBoolean(true));
2309                 break;
2310             }
2311             break;
2312 
2313         case SetCallee:
2314             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2315             break;
2316 
2317         case DataViewGetInt:
2318         case DataViewGetFloat: {
2319             fixEdge&lt;DataViewObjectUse&gt;(node-&gt;child1());
2320             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2321             if (node-&gt;child3())
2322                 fixEdge&lt;BooleanUse&gt;(node-&gt;child3());
2323 
2324             if (node-&gt;op() == DataViewGetInt) {
2325                 DataViewData data = node-&gt;dataViewData();
2326                 switch (data.byteSize) {
2327                 case 1:
2328                 case 2:
2329                     node-&gt;setResult(NodeResultInt32);
2330                     break;
2331                 case 4:
2332                     if (data.isSigned)
2333                         node-&gt;setResult(NodeResultInt32);
2334                     else
2335                         node-&gt;setResult(NodeResultInt52);
2336                     break;
2337                 default:
2338                     RELEASE_ASSERT_NOT_REACHED();
2339                 }
2340             }
2341             break;
2342         }
2343 
2344         case DataViewSet: {
2345             fixEdge&lt;DataViewObjectUse&gt;(m_graph.varArgChild(node, 0));
2346             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
2347             if (m_graph.varArgChild(node, 3))
2348                 fixEdge&lt;BooleanUse&gt;(m_graph.varArgChild(node, 3));
2349 
2350             DataViewData data = node-&gt;dataViewData();
2351             Edge&amp; valueToStore = m_graph.varArgChild(node, 2);
2352             if (data.isFloatingPoint)
2353                 fixEdge&lt;DoubleRepUse&gt;(valueToStore);
2354             else {
2355                 switch (data.byteSize) {
2356                 case 1:
2357                 case 2:
2358                     fixEdge&lt;Int32Use&gt;(valueToStore);
2359                     break;
2360                 case 4:
2361                     if (data.isSigned)
2362                         fixEdge&lt;Int32Use&gt;(valueToStore);
2363                     else
2364                         fixEdge&lt;Int52RepUse&gt;(valueToStore);
2365                     break;
2366                 }
2367             }
2368             break;
2369         }
2370 
2371 #if !ASSERT_DISABLED
2372         // Have these no-op cases here to ensure that nobody forgets to add handlers for new opcodes.
2373         case SetArgumentDefinitely:
2374         case SetArgumentMaybe:
2375         case JSConstant:
2376         case LazyJSConstant:
2377         case DoubleConstant:
2378         case GetLocal:
2379         case GetCallee:
2380         case GetArgumentCountIncludingThis:
2381         case SetArgumentCountIncludingThis:
2382         case GetRestLength:
2383         case GetArgument:
2384         case Flush:
2385         case PhantomLocal:
2386         case GetGlobalVar:
2387         case GetGlobalLexicalVariable:
2388         case NotifyWrite:
2389         case DirectCall:
2390         case CheckTypeInfoFlags:
2391         case TailCallInlinedCaller:
2392         case DirectTailCallInlinedCaller:
2393         case Construct:
2394         case DirectConstruct:
2395         case CallVarargs:
2396         case CallEval:
2397         case TailCallVarargsInlinedCaller:
2398         case ConstructVarargs:
2399         case CallForwardVarargs:
2400         case ConstructForwardVarargs:
2401         case TailCallForwardVarargs:
2402         case TailCallForwardVarargsInlinedCaller:
2403         case LoadVarargs:
2404         case ForwardVarargs:
2405         case ProfileControlFlow:
2406         case NewObject:
2407         case NewRegexp:
2408         case DeleteById:
2409         case DeleteByVal:
2410         case IsTypedArrayView:
2411         case IsEmpty:
2412         case IsUndefined:
2413         case IsUndefinedOrNull:
2414         case IsBoolean:
2415         case IsNumber:
2416         case IsObjectOrNull:
2417         case IsFunction:
2418         case CreateDirectArguments:
2419         case Jump:
2420         case Return:
2421         case TailCall:
2422         case DirectTailCall:
2423         case TailCallVarargs:
2424         case Throw:
2425         case CountExecution:
2426         case SuperSamplerBegin:
2427         case SuperSamplerEnd:
2428         case ForceOSRExit:
2429         case CheckBadCell:
2430         case CheckNotEmpty:
2431         case AssertNotEmpty:
2432         case CheckTraps:
2433         case Unreachable:
2434         case ExtractOSREntryLocal:
2435         case ExtractCatchLocal:
2436         case ClearCatchLocals:
2437         case LoopHint:
2438         case MovHint:
2439         case InitializeEntrypointArguments:
2440         case ZombieHint:
2441         case ExitOK:
2442         case BottomValue:
2443         case TypeOf:
2444         case PutByIdWithThis:
2445         case PutByValWithThis:
2446         case GetByValWithThis:
2447         case CompareEqPtr:
2448         case NumberToStringWithValidRadixConstant:
2449         case GetGlobalThis:
2450         case ExtractValueFromWeakMapGet:
2451         case CPUIntrinsic:
2452         case FilterCallLinkStatus:
2453         case FilterGetByIdStatus:
2454         case FilterPutByIdStatus:
2455         case FilterInByIdStatus:
2456         case InvalidationPoint:
2457             break;
2458 #else
2459         default:
2460             break;
2461 #endif
2462         }
2463     }
2464 
2465     void watchHavingABadTime(Node* node)
2466     {
2467         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2468 
2469         // If this global object is not having a bad time, watch it. We go down this path anytime the code
2470         // does an array allocation. The types of array allocations may change if we start to have a bad
2471         // time. It&#39;s easier to reason about this if we know that whenever the types change after we start
2472         // optimizing, the code just gets thrown out. Doing this at FixupPhase is just early enough, since
2473         // prior to this point nobody should have been doing optimizations based on the indexing type of
2474         // the allocation.
2475         if (!globalObject-&gt;isHavingABadTime()) {
2476             m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
2477             m_graph.freeze(globalObject);
2478         }
2479     }
2480 
2481     template&lt;UseKind useKind&gt;
2482     void createToString(Node* node, Edge&amp; edge)
2483     {
2484         Node* toString = m_insertionSet.insertNode(
2485             m_indexInBlock, SpecString, ToString, node-&gt;origin,
2486             Edge(edge.node(), useKind));
2487         switch (useKind) {
2488         case Int32Use:
2489         case Int52RepUse:
2490         case DoubleRepUse:
2491         case NotCellUse:
2492             toString-&gt;clearFlags(NodeMustGenerate);
2493             break;
2494         default:
2495             break;
2496         }
2497         edge.setNode(toString);
2498     }
2499 
2500     template&lt;UseKind useKind&gt;
2501     void attemptToForceStringArrayModeByToStringConversion(ArrayMode&amp; arrayMode, Node* node)
2502     {
2503         ASSERT(arrayMode == ArrayMode(Array::Generic, Array::Read) || arrayMode == ArrayMode(Array::Generic, Array::OriginalNonArray, Array::Read));
2504 
2505         if (!m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic))
2506             return;
2507 
2508         addCheckStructureForOriginalStringObjectUse(useKind, node-&gt;origin, node-&gt;child1().node());
2509         createToString&lt;useKind&gt;(node, node-&gt;child1());
2510         arrayMode = ArrayMode(Array::String, Array::Read);
2511     }
2512 
2513     void addCheckStructureForOriginalStringObjectUse(UseKind useKind, const NodeOrigin&amp; origin, Node* node)
2514     {
2515         RELEASE_ASSERT(useKind == StringObjectUse || useKind == StringOrStringObjectUse);
2516 
2517         StructureSet set;
2518         set.add(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;stringObjectStructure());
2519         if (useKind == StringOrStringObjectUse)
2520             set.add(vm().stringStructure.get());
2521 
2522         m_insertionSet.insertNode(
2523             m_indexInBlock, SpecNone, CheckStructure, origin,
2524             OpInfo(m_graph.addStructureSet(set)), Edge(node, CellUse));
2525     }
2526 
2527     template&lt;UseKind useKind&gt;
2528     void convertStringAddUse(Node* node, Edge&amp; edge)
2529     {
2530         if (useKind == StringUse) {
2531             observeUseKindOnNode&lt;StringUse&gt;(edge.node());
2532             m_insertionSet.insertNode(
2533                 m_indexInBlock, SpecNone, Check, node-&gt;origin,
2534                 Edge(edge.node(), StringUse));
2535             edge.setUseKind(KnownStringUse);
2536             return;
2537         }
2538 
2539         observeUseKindOnNode&lt;useKind&gt;(edge.node());
2540         createToString&lt;useKind&gt;(node, edge);
2541     }
2542 
2543     void convertToMakeRope(Node* node)
2544     {
2545         node-&gt;setOpAndDefaultFlags(MakeRope);
2546         fixupMakeRope(node);
2547     }
2548 
2549     void fixupMakeRope(Node* node)
2550     {
2551         for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i) {
2552             Edge&amp; edge = node-&gt;children.child(i);
2553             if (!edge)
2554                 break;
2555             edge.setUseKind(KnownStringUse);
2556             JSString* string = edge-&gt;dynamicCastConstant&lt;JSString*&gt;(vm());
2557             if (!string)
2558                 continue;
2559             if (string-&gt;length())
2560                 continue;
2561 
2562             // Don&#39;t allow the MakeRope to have zero children.
2563             if (!i &amp;&amp; !node-&gt;child2())
2564                 break;
2565 
2566             node-&gt;children.removeEdge(i--);
2567         }
2568 
2569         if (!node-&gt;child2()) {
2570             ASSERT(!node-&gt;child3());
2571             node-&gt;convertToIdentity();
2572         }
2573     }
2574 
2575     void fixupIsCellWithType(Node* node)
2576     {
2577         switch (node-&gt;speculatedTypeForQuery()) {
2578         case SpecString:
2579             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2580                 m_insertionSet.insertNode(
2581                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2582                     Edge(node-&gt;child1().node(), StringUse));
2583                 m_graph.convertToConstant(node, jsBoolean(true));
2584                 observeUseKindOnNode&lt;StringUse&gt;(node);
2585                 return;
2586             }
2587             break;
2588 
2589         case SpecProxyObject:
2590             if (node-&gt;child1()-&gt;shouldSpeculateProxyObject()) {
2591                 m_insertionSet.insertNode(
2592                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2593                     Edge(node-&gt;child1().node(), ProxyObjectUse));
2594                 m_graph.convertToConstant(node, jsBoolean(true));
2595                 observeUseKindOnNode&lt;ProxyObjectUse&gt;(node);
2596                 return;
2597             }
2598             break;
2599 
2600         case SpecRegExpObject:
2601             if (node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {
2602                 m_insertionSet.insertNode(
2603                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2604                     Edge(node-&gt;child1().node(), RegExpObjectUse));
2605                 m_graph.convertToConstant(node, jsBoolean(true));
2606                 observeUseKindOnNode&lt;RegExpObjectUse&gt;(node);
2607                 return;
2608             }
2609             break;
2610 
2611         case SpecArray:
2612             if (node-&gt;child1()-&gt;shouldSpeculateArray()) {
2613                 m_insertionSet.insertNode(
2614                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2615                     Edge(node-&gt;child1().node(), ArrayUse));
2616                 m_graph.convertToConstant(node, jsBoolean(true));
2617                 observeUseKindOnNode&lt;ArrayUse&gt;(node);
2618                 return;
2619             }
2620             break;
2621 
2622         case SpecDerivedArray:
2623             if (node-&gt;child1()-&gt;shouldSpeculateDerivedArray()) {
2624                 m_insertionSet.insertNode(
2625                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2626                     Edge(node-&gt;child1().node(), DerivedArrayUse));
2627                 m_graph.convertToConstant(node, jsBoolean(true));
2628                 observeUseKindOnNode&lt;DerivedArrayUse&gt;(node);
2629                 return;
2630             }
2631             break;
2632         }
2633 
2634         if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
2635             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2636             return;
2637         }
2638 
2639         if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
2640             m_insertionSet.insertNode(
2641                 m_indexInBlock, SpecNone, Check, node-&gt;origin,
2642                 Edge(node-&gt;child1().node(), NotCellUse));
2643             m_graph.convertToConstant(node, jsBoolean(false));
2644             observeUseKindOnNode&lt;NotCellUse&gt;(node);
2645             return;
2646         }
2647     }
2648 
2649     void fixupGetPrototypeOf(Node* node)
2650     {
2651         // Reflect.getPrototypeOf only accepts Objects. For Reflect.getPrototypeOf, ByteCodeParser attaches ObjectUse edge filter before fixup phase.
2652         if (node-&gt;child1().useKind() != ObjectUse) {
2653             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2654                 insertCheck&lt;StringUse&gt;(node-&gt;child1().node());
2655                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;stringPrototype()));
2656                 return;
2657             }
2658             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2659                 insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
2660                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2661                 return;
2662             }
2663             if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {
2664                 insertCheck&lt;Int52RepUse&gt;(node-&gt;child1().node());
2665                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2666                 return;
2667             }
2668             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2669                 insertCheck&lt;NumberUse&gt;(node-&gt;child1().node());
2670                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2671                 return;
2672             }
2673             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2674                 insertCheck&lt;SymbolUse&gt;(node-&gt;child1().node());
2675                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;symbolPrototype()));
2676                 return;
2677             }
2678             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2679                 insertCheck&lt;BooleanUse&gt;(node-&gt;child1().node());
2680                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;booleanPrototype()));
2681                 return;
2682             }
2683         }
2684 
2685         if (node-&gt;child1()-&gt;shouldSpeculateFinalObject()) {
2686             fixEdge&lt;FinalObjectUse&gt;(node-&gt;child1());
2687             node-&gt;clearFlags(NodeMustGenerate);
2688             return;
2689         }
2690         if (node-&gt;child1()-&gt;shouldSpeculateArray()) {
2691             fixEdge&lt;ArrayUse&gt;(node-&gt;child1());
2692             node-&gt;clearFlags(NodeMustGenerate);
2693             return;
2694         }
2695         if (node-&gt;child1()-&gt;shouldSpeculateFunction()) {
2696             fixEdge&lt;FunctionUse&gt;(node-&gt;child1());
2697             node-&gt;clearFlags(NodeMustGenerate);
2698             return;
2699         }
2700     }
2701 
2702     void fixupToThis(Node* node)
2703     {
2704         bool isStrictMode = m_graph.isStrictModeFor(node-&gt;origin.semantic);
2705 
2706         if (isStrictMode) {
2707             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2708                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
2709                 node-&gt;convertToIdentity();
2710                 return;
2711             }
2712 
2713             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2714                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2715                 node-&gt;convertToIdentity();
2716                 return;
2717             }
2718 
2719             if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {
2720                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
2721                 node-&gt;convertToIdentity();
2722                 node-&gt;setResult(NodeResultInt52);
2723                 return;
2724             }
2725 
2726             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2727                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2728                 node-&gt;convertToIdentity();
2729                 node-&gt;setResult(NodeResultDouble);
2730                 return;
2731             }
2732 
2733             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2734                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
2735                 node-&gt;convertToIdentity();
2736                 return;
2737             }
2738 
2739             if (node-&gt;child1()-&gt;shouldSpeculateStringIdent()) {
2740                 fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
2741                 node-&gt;convertToIdentity();
2742                 return;
2743             }
2744 
2745             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2746                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
2747                 node-&gt;convertToIdentity();
2748                 return;
2749             }
2750 
2751             if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {
2752                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
2753                 node-&gt;convertToIdentity();
2754                 return;
2755             }
2756         }
2757 
2758         if (node-&gt;child1()-&gt;shouldSpeculateOther()) {
2759             if (isStrictMode) {
2760                 fixEdge&lt;OtherUse&gt;(node-&gt;child1());
2761                 node-&gt;convertToIdentity();
2762                 return;
2763             }
2764 
2765             m_insertionSet.insertNode(
2766                 m_indexInBlock, SpecNone, Check, node-&gt;origin,
2767                 Edge(node-&gt;child1().node(), OtherUse));
2768             observeUseKindOnNode&lt;OtherUse&gt;(node-&gt;child1().node());
2769             m_graph.convertToConstant(
2770                 node, m_graph.globalThisObjectFor(node-&gt;origin.semantic));
2771             return;
2772         }
2773 
2774         // FIXME: This should cover other use cases but we don&#39;t have use kinds for them. It&#39;s not critical,
2775         // however, since we cover all the missing cases in constant folding.
2776         // https://bugs.webkit.org/show_bug.cgi?id=157213
2777         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()) {
2778             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2779             node-&gt;convertToIdentity();
2780             return;
2781         }
2782 
2783         if (isFinalObjectSpeculation(node-&gt;child1()-&gt;prediction())) {
2784             fixEdge&lt;FinalObjectUse&gt;(node-&gt;child1());
2785             node-&gt;convertToIdentity();
2786             return;
2787         }
2788     }
2789 
2790     void fixupToPrimitive(Node* node)
2791     {
2792         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2793             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2794             node-&gt;convertToIdentity();
2795             return;
2796         }
2797 
2798         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2799             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2800             node-&gt;convertToIdentity();
2801             return;
2802         }
2803 
2804         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()
2805             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2806             addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, node-&gt;child1().node());
2807             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2808             node-&gt;convertToToString();
2809             return;
2810         }
2811 
2812         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()
2813             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2814             addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());
2815             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
2816             node-&gt;convertToToString();
2817             return;
2818         }
2819     }
2820 
2821     void fixupToNumber(Node* node)
2822     {
2823         // At first, attempt to fold Boolean or Int32 to Int32.
2824         if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean()) {
2825             if (isInt32Speculation(node-&gt;getHeapPrediction())) {
2826                 fixIntOrBooleanEdge(node-&gt;child1());
2827                 node-&gt;convertToIdentity();
2828                 return;
2829             }
2830         }
2831 
2832         // If the prediction of the child is Number, we attempt to convert ToNumber to Identity.
2833         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2834             if (isInt32Speculation(node-&gt;getHeapPrediction())) {
2835                 // If the both predictions of this node and the child is Int32, we just convert ToNumber to Identity, that&#39;s simple.
2836                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2837                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2838                     node-&gt;convertToIdentity();
2839                     return;
2840                 }
2841 
2842                 // The another case is that the predicted type of the child is Int32, but the heap prediction tell the users that this will produce non Int32 values.
2843                 // In that case, let&#39;s receive the child value as a Double value and convert it to Int32. This case happens in misc-bugs-847389-jpeg2000.
2844                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2845                 node-&gt;setOp(DoubleAsInt32);
2846                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
2847                     node-&gt;setArithMode(Arith::CheckOverflow);
2848                 else
2849                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
2850                 return;
2851             }
2852 
2853             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2854             node-&gt;convertToIdentity();
2855             node-&gt;setResult(NodeResultDouble);
2856             return;
2857         }
2858 
2859         fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2860         node-&gt;setResult(NodeResultJS);
2861     }
2862 
2863     void fixupToObject(Node* node)
2864     {
2865         if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
2866             fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
2867             node-&gt;convertToIdentity();
2868             return;
2869         }
2870 
2871         // ToObject(Null/Undefined) can throw an error. We can emit filters to convert ToObject to CallObjectConstructor.
2872 
2873         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2874 
2875         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2876             insertCheck&lt;StringUse&gt;(node-&gt;child1().node());
2877             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
2878             node-&gt;convertToNewStringObject(m_graph.registerStructure(globalObject-&gt;stringObjectStructure()));
2879             return;
2880         }
2881 
2882         if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2883             insertCheck&lt;SymbolUse&gt;(node-&gt;child1().node());
2884             node-&gt;convertToCallObjectConstructor(m_graph.freeze(globalObject));
2885             return;
2886         }
2887 
2888         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2889             insertCheck&lt;NumberUse&gt;(node-&gt;child1().node());
2890             node-&gt;convertToCallObjectConstructor(m_graph.freeze(globalObject));
2891             return;
2892         }
2893 
2894         if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2895             insertCheck&lt;BooleanUse&gt;(node-&gt;child1().node());
2896             node-&gt;convertToCallObjectConstructor(m_graph.freeze(globalObject));
2897             return;
2898         }
2899 
2900         fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2901     }
2902 
2903     void fixupCallObjectConstructor(Node* node)
2904     {
2905         if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
2906             fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
2907             node-&gt;convertToIdentity();
2908             return;
2909         }
2910 
2911         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2912             auto* globalObject = jsCast&lt;JSGlobalObject*&gt;(node-&gt;cellOperand()-&gt;cell());
2913             insertCheck&lt;StringUse&gt;(node-&gt;child1().node());
2914             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
2915             node-&gt;convertToNewStringObject(m_graph.registerStructure(globalObject-&gt;stringObjectStructure()));
2916             return;
2917         }
2918 
2919         // While ToObject(Null/Undefined) throws an error, CallObjectConstructor(Null/Undefined) generates a new empty object.
2920         if (node-&gt;child1()-&gt;shouldSpeculateOther()) {
2921             insertCheck&lt;OtherUse&gt;(node-&gt;child1().node());
2922             node-&gt;convertToNewObject(m_graph.registerStructure(jsCast&lt;JSGlobalObject*&gt;(node-&gt;cellOperand()-&gt;cell())-&gt;objectStructureForObjectConstructor()));
2923             return;
2924         }
2925 
2926         fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2927     }
2928 
2929     void fixupToStringOrCallStringConstructor(Node* node)
2930     {
2931         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2932             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2933             node-&gt;convertToIdentity();
2934             return;
2935         }
2936 
2937         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()
2938             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2939             addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, node-&gt;child1().node());
2940             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2941             return;
2942         }
2943 
2944         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()
2945             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2946             addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());
2947             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
2948             return;
2949         }
2950 
2951         if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
2952             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2953             return;
2954         }
2955 
2956         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2957             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2958             node-&gt;clearFlags(NodeMustGenerate);
2959             return;
2960         }
2961 
2962         if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {
2963             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
2964             node-&gt;clearFlags(NodeMustGenerate);
2965             return;
2966         }
2967 
2968         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2969             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2970             node-&gt;clearFlags(NodeMustGenerate);
2971             return;
2972         }
2973 
2974         // ToString(Symbol) throws an error. So if the child1 can include Symbols,
2975         // we need to care about it in the clobberize. In the following case,
2976         // since NotCellUse edge filter is used and this edge filters Symbols,
2977         // we can say that ToString never throws an error!
2978         if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
2979             fixEdge&lt;NotCellUse&gt;(node-&gt;child1());
2980             node-&gt;clearFlags(NodeMustGenerate);
2981             return;
2982         }
2983     }
2984 
2985     void fixupStringValueOf(Node* node)
2986     {
2987         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2988             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2989             node-&gt;convertToIdentity();
2990             return;
2991         }
2992 
2993         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()) {
2994             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2995             node-&gt;convertToToString();
2996             // It does not need to look up a toString property for the StringObject case. So we can clear NodeMustGenerate.
2997             node-&gt;clearFlags(NodeMustGenerate);
2998             return;
2999         }
3000 
3001         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()) {
3002             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
3003             node-&gt;convertToToString();
3004             // It does not need to look up a toString property for the StringObject case. So we can clear NodeMustGenerate.
3005             node-&gt;clearFlags(NodeMustGenerate);
3006             return;
3007         }
3008     }
3009 
3010     bool attemptToMakeFastStringAdd(Node* node)
3011     {
3012         bool goodToGo = true;
3013         m_graph.doToChildren(
3014             node,
3015             [&amp;] (Edge&amp; edge) {
3016                 if (edge-&gt;shouldSpeculateString())
3017                     return;
3018                 if (m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
3019                     if (edge-&gt;shouldSpeculateStringObject())
3020                         return;
3021                     if (edge-&gt;shouldSpeculateStringOrStringObject())
3022                         return;
3023                 }
3024                 goodToGo = false;
3025             });
3026         if (!goodToGo)
3027             return false;
3028 
3029         m_graph.doToChildren(
3030             node,
3031             [&amp;] (Edge&amp; edge) {
3032                 if (edge-&gt;shouldSpeculateString()) {
3033                     convertStringAddUse&lt;StringUse&gt;(node, edge);
3034                     return;
3035                 }
3036                 if (!Options::useConcurrentJIT())
3037                     ASSERT(m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic));
3038                 if (edge-&gt;shouldSpeculateStringObject()) {
3039                     addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, edge.node());
3040                     convertStringAddUse&lt;StringObjectUse&gt;(node, edge);
3041                     return;
3042                 }
3043                 if (edge-&gt;shouldSpeculateStringOrStringObject()) {
3044                     addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, edge.node());
3045                     convertStringAddUse&lt;StringOrStringObjectUse&gt;(node, edge);
3046                     return;
3047                 }
3048                 RELEASE_ASSERT_NOT_REACHED();
3049             });
3050 
3051         convertToMakeRope(node);
3052         return true;
3053     }
3054 
3055     void fixupGetAndSetLocalsInBlock(BasicBlock* block)
3056     {
3057         if (!block)
3058             return;
3059         ASSERT(block-&gt;isReachable);
3060         m_block = block;
3061         for (m_indexInBlock = 0; m_indexInBlock &lt; block-&gt;size(); ++m_indexInBlock) {
3062             Node* node = m_currentNode = block-&gt;at(m_indexInBlock);
3063             if (node-&gt;op() != SetLocal &amp;&amp; node-&gt;op() != GetLocal)
3064                 continue;
3065 
3066             VariableAccessData* variable = node-&gt;variableAccessData();
3067             switch (node-&gt;op()) {
3068             case GetLocal:
3069                 switch (variable-&gt;flushFormat()) {
3070                 case FlushedDouble:
3071                     node-&gt;setResult(NodeResultDouble);
3072                     break;
3073                 case FlushedInt52:
3074                     node-&gt;setResult(NodeResultInt52);
3075                     break;
3076                 default:
3077                     break;
3078                 }
3079                 break;
3080 
3081             case SetLocal:
3082                 // NOTE: Any type checks we put here may get hoisted by fixupChecksInBlock(). So, if we
3083                 // add new type checking use kind for SetLocals, we need to modify that code as well.
3084 
3085                 switch (variable-&gt;flushFormat()) {
3086                 case FlushedJSValue:
3087                     break;
3088                 case FlushedDouble:
3089                     fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
3090                     break;
3091                 case FlushedInt32:
3092                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
3093                     break;
3094                 case FlushedInt52:
3095                     fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
3096                     break;
3097                 case FlushedCell:
3098                     fixEdge&lt;CellUse&gt;(node-&gt;child1());
3099                     break;
3100                 case FlushedBoolean:
3101                     fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
3102                     break;
3103                 default:
3104                     RELEASE_ASSERT_NOT_REACHED();
3105                     break;
3106                 }
3107                 break;
3108 
3109             default:
3110                 RELEASE_ASSERT_NOT_REACHED();
3111                 break;
3112             }
3113         }
3114         m_insertionSet.execute(block);
3115     }
3116 
3117     void addStringReplacePrimordialChecks(Node* searchRegExp)
3118     {
3119         Node* node = m_currentNode;
3120 
3121         // Check that structure of searchRegExp is RegExp object
3122         m_insertionSet.insertNode(
3123             m_indexInBlock, SpecNone, Check, node-&gt;origin,
3124             Edge(searchRegExp, RegExpObjectUse));
3125 
3126         auto emitPrimordialCheckFor = [&amp;] (JSValue primordialProperty, UniquedStringImpl* propertyUID) {
3127             unsigned index = m_graph.identifiers().ensure(propertyUID);
3128 
3129             Node* actualProperty = m_insertionSet.insertNode(
3130                 m_indexInBlock, SpecNone, TryGetById, node-&gt;origin,
3131                 OpInfo(index), OpInfo(SpecFunction), Edge(searchRegExp, CellUse));
3132 
3133             m_insertionSet.insertNode(
3134                 m_indexInBlock, SpecNone, CheckCell, node-&gt;origin,
3135                 OpInfo(m_graph.freeze(primordialProperty)), Edge(actualProperty, CellUse));
3136         };
3137 
3138         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
3139 
3140         // Check that searchRegExp.exec is the primordial RegExp.prototype.exec
3141         emitPrimordialCheckFor(globalObject-&gt;regExpProtoExecFunction(), vm().propertyNames-&gt;exec.impl());
3142         // Check that searchRegExp.global is the primordial RegExp.prototype.global
3143         emitPrimordialCheckFor(globalObject-&gt;regExpProtoGlobalGetter(), vm().propertyNames-&gt;global.impl());
3144         // Check that searchRegExp.unicode is the primordial RegExp.prototype.unicode
3145         emitPrimordialCheckFor(globalObject-&gt;regExpProtoUnicodeGetter(), vm().propertyNames-&gt;unicode.impl());
3146         // Check that searchRegExp[Symbol.match] is the primordial RegExp.prototype[Symbol.replace]
3147         emitPrimordialCheckFor(globalObject-&gt;regExpProtoSymbolReplaceFunction(), vm().propertyNames-&gt;replaceSymbol.impl());
3148     }
3149 
3150     Node* checkArray(ArrayMode arrayMode, const NodeOrigin&amp; origin, Node* array, Node* index, bool (*storageCheck)(const ArrayMode&amp;) = canCSEStorage)
3151     {
3152         ASSERT(arrayMode.isSpecific());
3153 
3154         if (arrayMode.type() == Array::String) {
3155             m_insertionSet.insertNode(
3156                 m_indexInBlock, SpecNone, Check, origin, Edge(array, StringUse));
3157         } else {
3158             // Note that we only need to be using a structure check if we opt for SaneChain, since
3159             // that needs to protect against JSArray&#39;s __proto__ being changed.
3160             Structure* structure = arrayMode.originalArrayStructure(m_graph, origin.semantic);
3161 
3162             Edge indexEdge = index ? Edge(index, Int32Use) : Edge();
3163 
3164             if (arrayMode.doesConversion()) {
3165                 if (structure) {
3166                     m_insertionSet.insertNode(
3167                         m_indexInBlock, SpecNone, ArrayifyToStructure, origin,
3168                         OpInfo(m_graph.registerStructure(structure)), OpInfo(arrayMode.asWord()), Edge(array, CellUse), indexEdge);
3169                 } else {
3170                     m_insertionSet.insertNode(
3171                         m_indexInBlock, SpecNone, Arrayify, origin,
3172                         OpInfo(arrayMode.asWord()), Edge(array, CellUse), indexEdge);
3173                 }
3174             } else {
3175                 if (structure) {
3176                     m_insertionSet.insertNode(
3177                         m_indexInBlock, SpecNone, CheckStructure, origin,
3178                         OpInfo(m_graph.addStructureSet(structure)), Edge(array, CellUse));
3179                 } else {
3180                     m_insertionSet.insertNode(
3181                         m_indexInBlock, SpecNone, CheckArray, origin,
3182                         OpInfo(arrayMode.asWord()), Edge(array, CellUse));
3183                 }
3184             }
3185         }
3186 
3187         if (!storageCheck(arrayMode))
3188             return nullptr;
3189 
3190         if (arrayMode.usesButterfly()) {
3191             return m_insertionSet.insertNode(
3192                 m_indexInBlock, SpecNone, GetButterfly, origin, Edge(array, CellUse));
3193         }
3194 
3195         return m_insertionSet.insertNode(
3196             m_indexInBlock, SpecNone, GetIndexedPropertyStorage, origin,
3197             OpInfo(arrayMode.asWord()), Edge(array, KnownCellUse));
3198     }
3199 
3200     void blessArrayOperation(Edge base, Edge index, Edge&amp; storageChild)
3201     {
3202         Node* node = m_currentNode;
3203 
3204         switch (node-&gt;arrayMode().type()) {
3205         case Array::ForceExit: {
3206             m_insertionSet.insertNode(
3207                 m_indexInBlock, SpecNone, ForceOSRExit, node-&gt;origin);
3208             return;
3209         }
3210 
3211         case Array::SelectUsingPredictions:
3212         case Array::Unprofiled:
3213             RELEASE_ASSERT_NOT_REACHED();
3214             return;
3215 
3216         case Array::Generic:
3217             return;
3218 
3219         default: {
3220             Node* storage = checkArray(node-&gt;arrayMode(), node-&gt;origin, base.node(), index.node());
3221             if (!storage)
3222                 return;
3223 
3224             storageChild = Edge(storage);
3225             return;
3226         } }
3227     }
3228 
3229     bool alwaysUnboxSimplePrimitives()
3230     {
3231 #if USE(JSVALUE64)
3232         return false;
3233 #else
3234         // Any boolean, int, or cell value is profitable to unbox on 32-bit because it
3235         // reduces traffic.
3236         return true;
3237 #endif
3238     }
3239 
3240     template&lt;UseKind useKind&gt;
3241     void observeUseKindOnNode(Node* node)
3242     {
3243         if (useKind == UntypedUse)
3244             return;
3245         observeUseKindOnNode(node, useKind);
3246     }
3247 
3248     void observeUseKindOnEdge(Edge edge)
3249     {
3250         observeUseKindOnNode(edge.node(), edge.useKind());
3251     }
3252 
3253     void observeUseKindOnNode(Node* node, UseKind useKind)
3254     {
3255         if (node-&gt;op() != GetLocal)
3256             return;
3257 
3258         // FIXME: The way this uses alwaysUnboxSimplePrimitives() is suspicious.
3259         // https://bugs.webkit.org/show_bug.cgi?id=121518
3260 
3261         VariableAccessData* variable = node-&gt;variableAccessData();
3262         switch (useKind) {
3263         case Int32Use:
3264         case KnownInt32Use:
3265             if (alwaysUnboxSimplePrimitives()
3266                 || isInt32Speculation(variable-&gt;prediction()))
3267                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3268             break;
3269         case NumberUse:
3270         case RealNumberUse:
3271         case DoubleRepUse:
3272         case DoubleRepRealUse:
3273             if (variable-&gt;doubleFormatState() == UsingDoubleFormat)
3274                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3275             break;
3276         case BooleanUse:
3277         case KnownBooleanUse:
3278             if (alwaysUnboxSimplePrimitives()
3279                 || isBooleanSpeculation(variable-&gt;prediction()))
3280                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3281             break;
3282         case Int52RepUse:
3283             if (!isInt32Speculation(variable-&gt;prediction()) &amp;&amp; isInt32OrInt52Speculation(variable-&gt;prediction()))
3284                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3285             break;
3286         case CellUse:
3287         case KnownCellUse:
3288         case ObjectUse:
3289         case FunctionUse:
3290         case StringUse:
3291         case KnownStringUse:
3292         case SymbolUse:
3293         case BigIntUse:
3294         case StringObjectUse:
3295         case StringOrStringObjectUse:
3296             if (alwaysUnboxSimplePrimitives()
3297                 || isCellSpeculation(variable-&gt;prediction()))
3298                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3299             break;
3300         default:
3301             break;
3302         }
3303     }
3304 
3305     template&lt;UseKind useKind&gt;
3306     void fixEdge(Edge&amp; edge)
3307     {
3308         observeUseKindOnNode&lt;useKind&gt;(edge.node());
3309         edge.setUseKind(useKind);
3310     }
3311 
3312     unsigned indexForChecks()
3313     {
3314         unsigned index = m_indexInBlock;
3315         while (!m_block-&gt;at(index)-&gt;origin.exitOK)
3316             index--;
3317         return index;
3318     }
3319 
3320     NodeOrigin originForCheck(unsigned index)
3321     {
3322         return m_block-&gt;at(index)-&gt;origin.withSemantic(m_currentNode-&gt;origin.semantic);
3323     }
3324 
3325     void speculateForBarrier(Edge value)
3326     {
3327         // Currently, the DFG won&#39;t take advantage of this speculation. But, we want to do it in
3328         // the DFG anyway because if such a speculation would be wrong, we want to know before
3329         // we do an expensive compile.
3330 
3331         if (value-&gt;shouldSpeculateInt32()) {
3332             insertCheck&lt;Int32Use&gt;(value.node());
3333             return;
3334         }
3335 
3336         if (value-&gt;shouldSpeculateBoolean()) {
3337             insertCheck&lt;BooleanUse&gt;(value.node());
3338             return;
3339         }
3340 
3341         if (value-&gt;shouldSpeculateOther()) {
3342             insertCheck&lt;OtherUse&gt;(value.node());
3343             return;
3344         }
3345 
3346         if (value-&gt;shouldSpeculateNumber()) {
3347             insertCheck&lt;NumberUse&gt;(value.node());
3348             return;
3349         }
3350 
3351         if (value-&gt;shouldSpeculateNotCell()) {
3352             insertCheck&lt;NotCellUse&gt;(value.node());
3353             return;
3354         }
3355     }
3356 
3357     template&lt;UseKind useKind&gt;
3358     void insertCheck(Node* node)
3359     {
3360         observeUseKindOnNode&lt;useKind&gt;(node);
3361         unsigned index = indexForChecks();
3362         m_insertionSet.insertNode(index, SpecNone, Check, originForCheck(index), Edge(node, useKind));
3363     }
3364 
3365     void fixIntConvertingEdge(Edge&amp; edge)
3366     {
3367         Node* node = edge.node();
3368         if (node-&gt;shouldSpeculateInt32OrBoolean()) {
3369             fixIntOrBooleanEdge(edge);
3370             return;
3371         }
3372 
3373         UseKind useKind;
3374         if (node-&gt;shouldSpeculateInt52())
3375             useKind = Int52RepUse;
3376         else if (node-&gt;shouldSpeculateNumber())
3377             useKind = DoubleRepUse;
3378         else
3379             useKind = NotCellUse;
3380         Node* newNode = m_insertionSet.insertNode(
3381             m_indexInBlock, SpecInt32Only, ValueToInt32, m_currentNode-&gt;origin,
3382             Edge(node, useKind));
3383         observeUseKindOnNode(node, useKind);
3384 
3385         edge = Edge(newNode, KnownInt32Use);
3386     }
3387 
3388     void fixIntOrBooleanEdge(Edge&amp; edge)
3389     {
3390         Node* node = edge.node();
3391         if (!node-&gt;sawBooleans()) {
3392             fixEdge&lt;Int32Use&gt;(edge);
3393             return;
3394         }
3395 
3396         UseKind useKind;
3397         if (node-&gt;shouldSpeculateBoolean())
3398             useKind = BooleanUse;
3399         else
3400             useKind = UntypedUse;
3401         Node* newNode = m_insertionSet.insertNode(
3402             m_indexInBlock, SpecInt32Only, BooleanToNumber, m_currentNode-&gt;origin,
3403             Edge(node, useKind));
3404         observeUseKindOnNode(node, useKind);
3405 
3406         edge = Edge(newNode, Int32Use);
3407     }
3408 
3409     void fixDoubleOrBooleanEdge(Edge&amp; edge)
3410     {
3411         Node* node = edge.node();
3412         if (!node-&gt;sawBooleans()) {
3413             fixEdge&lt;DoubleRepUse&gt;(edge);
3414             return;
3415         }
3416 
3417         UseKind useKind;
3418         if (node-&gt;shouldSpeculateBoolean())
3419             useKind = BooleanUse;
3420         else
3421             useKind = UntypedUse;
3422         Node* newNode = m_insertionSet.insertNode(
3423             m_indexInBlock, SpecInt32Only, BooleanToNumber, m_currentNode-&gt;origin,
3424             Edge(node, useKind));
3425         observeUseKindOnNode(node, useKind);
3426 
3427         edge = Edge(newNode, DoubleRepUse);
3428     }
3429 
3430     void truncateConstantToInt32(Edge&amp; edge)
3431     {
3432         Node* oldNode = edge.node();
3433 
3434         JSValue value = oldNode-&gt;asJSValue();
3435         if (value.isInt32())
3436             return;
3437 
3438         value = jsNumber(JSC::toInt32(value.asNumber()));
3439         ASSERT(value.isInt32());
3440         edge.setNode(m_insertionSet.insertNode(
3441             m_indexInBlock, SpecInt32Only, JSConstant, m_currentNode-&gt;origin,
3442             OpInfo(m_graph.freeze(value))));
3443     }
3444 
3445     void truncateConstantsIfNecessary(Node* node, AddSpeculationMode mode)
3446     {
3447         if (mode != SpeculateInt32AndTruncateConstants)
3448             return;
3449 
3450         ASSERT(node-&gt;child1()-&gt;hasConstant() || node-&gt;child2()-&gt;hasConstant());
3451         if (node-&gt;child1()-&gt;hasConstant())
3452             truncateConstantToInt32(node-&gt;child1());
3453         else
3454             truncateConstantToInt32(node-&gt;child2());
3455     }
3456 
3457     bool attemptToMakeIntegerAdd(Node* node)
3458     {
3459         AddSpeculationMode mode = m_graph.addSpeculationMode(node, FixupPass);
3460         if (mode != DontSpeculateInt32) {
3461             truncateConstantsIfNecessary(node, mode);
3462             fixIntOrBooleanEdge(node-&gt;child1());
3463             fixIntOrBooleanEdge(node-&gt;child2());
3464             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
3465                 node-&gt;setArithMode(Arith::Unchecked);
3466             else
3467                 node-&gt;setArithMode(Arith::CheckOverflow);
3468             return true;
3469         }
3470 
3471         if (m_graph.addShouldSpeculateInt52(node)) {
3472             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
3473             fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
3474             node-&gt;setArithMode(Arith::CheckOverflow);
3475             node-&gt;setResult(NodeResultInt52);
3476             return true;
3477         }
3478 
3479         return false;
3480     }
3481 
3482     bool attemptToMakeGetArrayLength(Node* node)
3483     {
3484         if (!isInt32Speculation(node-&gt;prediction()))
3485             return false;
3486         CodeBlock* profiledBlock = m_graph.baselineCodeBlockFor(node-&gt;origin.semantic);
3487         ArrayProfile* arrayProfile =
3488             profiledBlock-&gt;getArrayProfile(node-&gt;origin.semantic.bytecodeIndex());
3489         ArrayMode arrayMode = ArrayMode(Array::SelectUsingPredictions, Array::Read);
3490         if (arrayProfile) {
3491             ConcurrentJSLocker locker(profiledBlock-&gt;m_lock);
3492             arrayProfile-&gt;computeUpdatedPrediction(locker, profiledBlock);
3493             arrayMode = ArrayMode::fromObserved(locker, arrayProfile, Array::Read, false);
3494             if (arrayMode.type() == Array::Unprofiled) {
3495                 // For normal array operations, it makes sense to treat Unprofiled
3496                 // accesses as ForceExit and get more data rather than using
3497                 // predictions and then possibly ending up with a Generic. But here,
3498                 // we treat anything that is Unprofiled as Generic and keep the
3499                 // GetById. I.e. ForceExit = Generic. So, there is no harm - and only
3500                 // profit - from treating the Unprofiled case as
3501                 // SelectUsingPredictions.
3502                 arrayMode = ArrayMode(Array::SelectUsingPredictions, Array::Read);
3503             }
3504         }
3505 
3506         arrayMode = arrayMode.refine(
3507             m_graph, node, node-&gt;child1()-&gt;prediction(), node-&gt;prediction());
3508 
3509         if (arrayMode.type() == Array::Generic) {
3510             // Check if the input is something that we can&#39;t get array length for, but for which we
3511             // could insert some conversions in order to transform it into something that we can do it
3512             // for.
3513             if (node-&gt;child1()-&gt;shouldSpeculateStringObject())
3514                 attemptToForceStringArrayModeByToStringConversion&lt;StringObjectUse&gt;(arrayMode, node);
3515             else if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject())
3516                 attemptToForceStringArrayModeByToStringConversion&lt;StringOrStringObjectUse&gt;(arrayMode, node);
3517         }
3518 
3519         if (!arrayMode.supportsSelfLength())
3520             return false;
3521 
3522         convertToGetArrayLength(node, arrayMode);
3523         return true;
3524     }
3525 
3526     void convertToGetArrayLength(Node* node, ArrayMode arrayMode)
3527     {
3528         node-&gt;setOp(GetArrayLength);
3529         node-&gt;clearFlags(NodeMustGenerate);
3530         fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
3531         node-&gt;setArrayMode(arrayMode);
3532 
3533         Node* storage = checkArray(arrayMode, node-&gt;origin, node-&gt;child1().node(), 0, lengthNeedsStorage);
3534         if (!storage)
3535             return;
3536 
3537         node-&gt;child2() = Edge(storage);
3538     }
3539 
3540     Node* prependGetArrayLength(NodeOrigin origin, Node* child, ArrayMode arrayMode)
3541     {
3542         Node* storage = checkArray(arrayMode, origin, child, 0, lengthNeedsStorage);
3543         return m_insertionSet.insertNode(
3544             m_indexInBlock, SpecInt32Only, GetArrayLength, origin,
3545             OpInfo(arrayMode.asWord()), Edge(child, KnownCellUse), Edge(storage));
3546     }
3547 
3548     void convertToHasIndexedProperty(Node* node)
3549     {
3550         node-&gt;setOp(HasIndexedProperty);
3551         node-&gt;clearFlags(NodeMustGenerate);
3552 
3553         {
3554             unsigned firstChild = m_graph.m_varArgChildren.size();
3555             unsigned numChildren = 3;
3556             m_graph.m_varArgChildren.append(node-&gt;child1());
3557             m_graph.m_varArgChildren.append(node-&gt;child2());
3558             m_graph.m_varArgChildren.append(Edge());
3559             node-&gt;mergeFlags(NodeHasVarArgs);
3560             node-&gt;children = AdjacencyList(AdjacencyList::Variable, firstChild, numChildren);
3561         }
3562 
3563         node-&gt;setArrayMode(
3564             node-&gt;arrayMode().refine(
3565                 m_graph, node,
3566                 m_graph.varArgChild(node, 0)-&gt;prediction(),
3567                 m_graph.varArgChild(node, 1)-&gt;prediction(),
3568                 SpecNone));
3569         node-&gt;setInternalMethodType(PropertySlot::InternalMethodType::HasProperty);
3570 
3571         blessArrayOperation(m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1), m_graph.varArgChild(node, 2));
3572 
3573         fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
3574         fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
3575     }
3576 
3577     void fixupNormalizeMapKey(Node* node)
3578     {
3579         if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
3580             fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
3581             node-&gt;convertToIdentity();
3582             return;
3583         }
3584 
3585         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
3586             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
3587             node-&gt;convertToIdentity();
3588             return;
3589         }
3590 
3591         if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
3592             fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
3593             node-&gt;convertToIdentity();
3594             return;
3595         }
3596 
3597         if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
3598             fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
3599             node-&gt;convertToIdentity();
3600             return;
3601         }
3602 
3603         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
3604             fixEdge&lt;StringUse&gt;(node-&gt;child1());
3605             node-&gt;convertToIdentity();
3606             return;
3607         }
3608 
3609         if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
3610             fixEdge&lt;CellUse&gt;(node-&gt;child1());
3611             node-&gt;convertToIdentity();
3612             return;
3613         }
3614 
3615         fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
3616     }
3617 
3618     bool attemptToMakeCallDOM(Node* node)
3619     {
3620         if (m_graph.hasExitSite(node-&gt;origin.semantic, BadType))
3621             return false;
3622 
3623         const DOMJIT::Signature* signature = node-&gt;signature();
3624         if (!signature)
3625             return false;
3626 
3627         {
3628             unsigned index = 0;
3629             bool shouldConvertToCallDOM = true;
3630             m_graph.doToChildren(node, [&amp;](Edge&amp; edge) {
3631                 // Callee. Ignore this. DFGByteCodeParser already emit appropriate checks.
3632                 if (!index)
3633                     return;
3634 
3635                 if (index == 1) {
3636                     // DOM node case.
3637                     if (edge-&gt;shouldSpeculateNotCell())
3638                         shouldConvertToCallDOM = false;
3639                 } else {
3640                     switch (signature-&gt;arguments[index - 2]) {
3641                     case SpecString:
3642                         if (edge-&gt;shouldSpeculateNotString())
3643                             shouldConvertToCallDOM = false;
3644                         break;
3645                     case SpecInt32Only:
3646                         if (edge-&gt;shouldSpeculateNotInt32())
3647                             shouldConvertToCallDOM = false;
3648                         break;
3649                     case SpecBoolean:
3650                         if (edge-&gt;shouldSpeculateNotBoolean())
3651                             shouldConvertToCallDOM = false;
3652                         break;
3653                     default:
3654                         RELEASE_ASSERT_NOT_REACHED();
3655                         break;
3656                     }
3657                 }
3658                 ++index;
3659             });
3660             if (!shouldConvertToCallDOM)
3661                 return false;
3662         }
3663 
3664         Node* thisNode = m_graph.varArgChild(node, 1).node();
3665         Node* checkSubClass = m_insertionSet.insertNode(m_indexInBlock, SpecNone, CheckSubClass, node-&gt;origin, OpInfo(signature-&gt;classInfo), Edge(thisNode));
3666         node-&gt;convertToCallDOM(m_graph);
3667         fixupCheckSubClass(checkSubClass);
3668         fixupCallDOM(node);
3669         return true;
3670     }
3671 
3672     void fixupCheckSubClass(Node* node)
3673     {
3674         fixEdge&lt;CellUse&gt;(node-&gt;child1());
3675     }
3676 
3677     void fixupCallDOM(Node* node)
3678     {
3679         const DOMJIT::Signature* signature = node-&gt;signature();
3680         auto fixup = [&amp;](Edge&amp; edge, unsigned argumentIndex) {
3681             if (!edge)
3682                 return;
3683             switch (signature-&gt;arguments[argumentIndex]) {
3684             case SpecString:
3685                 fixEdge&lt;StringUse&gt;(edge);
3686                 break;
3687             case SpecInt32Only:
3688                 fixEdge&lt;Int32Use&gt;(edge);
3689                 break;
3690             case SpecBoolean:
3691                 fixEdge&lt;BooleanUse&gt;(edge);
3692                 break;
3693             default:
3694                 RELEASE_ASSERT_NOT_REACHED();
3695                 break;
3696             }
3697         };
3698         fixEdge&lt;CellUse&gt;(node-&gt;child1()); // DOM.
3699         fixup(node-&gt;child2(), 0);
3700         fixup(node-&gt;child3(), 1);
3701     }
3702 
3703     void fixupArrayIndexOf(Node* node)
3704     {
3705         Edge&amp; array = m_graph.varArgChild(node, 0);
3706         Edge&amp; storage = m_graph.varArgChild(node, node-&gt;numChildren() == 3 ? 2 : 3);
3707         blessArrayOperation(array, Edge(), storage);
3708         ASSERT_WITH_MESSAGE(storage.node(), &quot;blessArrayOperation for ArrayIndexOf must set Butterfly for storage edge.&quot;);
3709 
3710         Edge&amp; searchElement = m_graph.varArgChild(node, 1);
3711 
3712         // Constant folding.
3713         switch (node-&gt;arrayMode().type()) {
3714         case Array::Double:
3715         case Array::Int32: {
3716             if (searchElement-&gt;shouldSpeculateCell()) {
3717                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin, Edge(searchElement.node(), CellUse));
3718                 m_graph.convertToConstant(node, jsNumber(-1));
3719                 observeUseKindOnNode&lt;CellUse&gt;(searchElement.node());
3720                 return;
3721             }
3722 
3723             if (searchElement-&gt;shouldSpeculateOther()) {
3724                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin, Edge(searchElement.node(), OtherUse));
3725                 m_graph.convertToConstant(node, jsNumber(-1));
3726                 observeUseKindOnNode&lt;OtherUse&gt;(searchElement.node());
3727                 return;
3728             }
3729 
3730             if (searchElement-&gt;shouldSpeculateBoolean()) {
3731                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin, Edge(searchElement.node(), BooleanUse));
3732                 m_graph.convertToConstant(node, jsNumber(-1));
3733                 observeUseKindOnNode&lt;BooleanUse&gt;(searchElement.node());
3734                 return;
3735             }
3736             break;
3737         }
3738         default:
3739             break;
3740         }
3741 
3742         fixEdge&lt;KnownCellUse&gt;(array);
3743         if (node-&gt;numChildren() == 4)
3744             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 2));
3745 
3746         switch (node-&gt;arrayMode().type()) {
3747         case Array::Double: {
3748             if (searchElement-&gt;shouldSpeculateNumber())
3749                 fixEdge&lt;DoubleRepUse&gt;(searchElement);
3750             return;
3751         }
3752         case Array::Int32: {
3753             if (searchElement-&gt;shouldSpeculateInt32())
3754                 fixEdge&lt;Int32Use&gt;(searchElement);
3755             return;
3756         }
3757         case Array::Contiguous: {
3758             if (searchElement-&gt;shouldSpeculateString())
3759                 fixEdge&lt;StringUse&gt;(searchElement);
3760             else if (searchElement-&gt;shouldSpeculateSymbol())
3761                 fixEdge&lt;SymbolUse&gt;(searchElement);
3762             else if (searchElement-&gt;shouldSpeculateOther())
3763                 fixEdge&lt;OtherUse&gt;(searchElement);
3764             else if (searchElement-&gt;shouldSpeculateObject())
3765                 fixEdge&lt;ObjectUse&gt;(searchElement);
3766             return;
3767         }
3768         default:
3769             RELEASE_ASSERT_NOT_REACHED();
3770             return;
3771         }
3772     }
3773 
3774     void fixupCompareStrictEqAndSameValue(Node* node)
3775     {
3776         ASSERT(node-&gt;op() == SameValue || node-&gt;op() == CompareStrictEq);
3777 
3778         if (Node::shouldSpeculateBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
3779             fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
3780             fixEdge&lt;BooleanUse&gt;(node-&gt;child2());
3781             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3782             return;
3783         }
3784         if (Node::shouldSpeculateInt32(node-&gt;child1().node(), node-&gt;child2().node())) {
3785             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
3786             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
3787             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3788             return;
3789         }
3790         if (Node::shouldSpeculateInt52(node-&gt;child1().node(), node-&gt;child2().node())) {
3791             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
3792             fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
3793             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3794             return;
3795         }
3796         if (Node::shouldSpeculateNumber(node-&gt;child1().node(), node-&gt;child2().node())) {
3797             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
3798             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child2());
3799             // Do not convert SameValue to CompareStrictEq in this case since SameValue(NaN, NaN) and SameValue(-0, +0)
3800             // are not the same to CompareStrictEq(NaN, NaN) and CompareStrictEq(-0, +0).
3801             return;
3802         }
3803         if (Node::shouldSpeculateSymbol(node-&gt;child1().node(), node-&gt;child2().node())) {
3804             fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
3805             fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
3806             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3807             return;
3808         }
3809         if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
3810             fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
3811             fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
3812             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3813             return;
3814         }
3815         if (node-&gt;child1()-&gt;shouldSpeculateStringIdent() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateStringIdent()) {
3816             fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
3817             fixEdge&lt;StringIdentUse&gt;(node-&gt;child2());
3818             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3819             return;
3820         }
3821         if (node-&gt;child1()-&gt;shouldSpeculateString() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateString() &amp;&amp; ((GPRInfo::numberOfRegisters &gt;= 7) || m_graph.m_plan.isFTL())) {
3822             fixEdge&lt;StringUse&gt;(node-&gt;child1());
3823             fixEdge&lt;StringUse&gt;(node-&gt;child2());
3824             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3825             return;
3826         }
3827 
3828         if (node-&gt;op() == SameValue) {
3829             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
3830                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
3831                 node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3832                 return;
3833             }
3834             if (node-&gt;child2()-&gt;shouldSpeculateObject()) {
3835                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
3836                 node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3837                 return;
3838             }
3839         } else {
3840             WatchpointSet* masqueradesAsUndefinedWatchpoint = m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;masqueradesAsUndefinedWatchpoint();
3841             if (masqueradesAsUndefinedWatchpoint-&gt;isStillValid()) {
3842                 if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
3843                     m_graph.watchpoints().addLazily(masqueradesAsUndefinedWatchpoint);
3844                     fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
3845                     return;
3846                 }
3847                 if (node-&gt;child2()-&gt;shouldSpeculateObject()) {
3848                     m_graph.watchpoints().addLazily(masqueradesAsUndefinedWatchpoint);
3849                     fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
3850                     return;
3851                 }
3852             } else if (node-&gt;child1()-&gt;shouldSpeculateObject() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateObject()) {
3853                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
3854                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
3855                 return;
3856             }
3857         }
3858 
3859         if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
3860             fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
3861             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3862             return;
3863         }
3864         if (node-&gt;child2()-&gt;shouldSpeculateSymbol()) {
3865             fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
3866             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3867             return;
3868         }
3869         if (node-&gt;child1()-&gt;shouldSpeculateMisc()) {
3870             fixEdge&lt;MiscUse&gt;(node-&gt;child1());
3871             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3872             return;
3873         }
3874         if (node-&gt;child2()-&gt;shouldSpeculateMisc()) {
3875             fixEdge&lt;MiscUse&gt;(node-&gt;child2());
3876             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3877             return;
3878         }
3879         if (node-&gt;child1()-&gt;shouldSpeculateStringIdent()
3880             &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateNotStringVar()) {
3881             fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
3882             fixEdge&lt;NotStringVarUse&gt;(node-&gt;child2());
3883             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3884             return;
3885         }
3886         if (node-&gt;child2()-&gt;shouldSpeculateStringIdent()
3887             &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateNotStringVar()) {
3888             fixEdge&lt;StringIdentUse&gt;(node-&gt;child2());
3889             fixEdge&lt;NotStringVarUse&gt;(node-&gt;child1());
3890             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3891             return;
3892         }
3893         if (node-&gt;child1()-&gt;shouldSpeculateString() &amp;&amp; ((GPRInfo::numberOfRegisters &gt;= 8) || m_graph.m_plan.isFTL())) {
3894             fixEdge&lt;StringUse&gt;(node-&gt;child1());
3895             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3896             return;
3897         }
3898         if (node-&gt;child2()-&gt;shouldSpeculateString() &amp;&amp; ((GPRInfo::numberOfRegisters &gt;= 8) || m_graph.m_plan.isFTL())) {
3899             fixEdge&lt;StringUse&gt;(node-&gt;child2());
3900             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3901             return;
3902         }
3903     }
3904 
3905     void fixupChecksInBlock(BasicBlock* block)
3906     {
3907         if (!block)
3908             return;
3909         ASSERT(block-&gt;isReachable);
3910         m_block = block;
3911         unsigned indexForChecks = UINT_MAX;
3912         NodeOrigin originForChecks;
3913         for (unsigned indexInBlock = 0; indexInBlock &lt; block-&gt;size(); ++indexInBlock) {
3914             Node* node = block-&gt;at(indexInBlock);
3915 
3916             // If this is a node at which we could exit, then save its index. If nodes after this one
3917             // cannot exit, then we will hoist checks to here.
3918             if (node-&gt;origin.exitOK) {
3919                 indexForChecks = indexInBlock;
3920                 originForChecks = node-&gt;origin;
3921             }
3922 
3923             originForChecks = originForChecks.withSemantic(node-&gt;origin.semantic);
3924 
3925             // First, try to relax the representational demands of each node, in order to have
3926             // fewer conversions.
3927             switch (node-&gt;op()) {
3928             case MovHint:
3929             case Check:
3930             case CheckVarargs:
3931                 m_graph.doToChildren(
3932                     node,
3933                     [&amp;] (Edge&amp; edge) {
3934                         switch (edge.useKind()) {
3935                         case DoubleRepUse:
3936                         case DoubleRepRealUse:
3937                             if (edge-&gt;hasDoubleResult())
3938                                 break;
3939 
3940                             if (edge-&gt;hasInt52Result())
3941                                 edge.setUseKind(Int52RepUse);
3942                             else if (edge.useKind() == DoubleRepUse)
3943                                 edge.setUseKind(NumberUse);
3944                             break;
3945 
3946                         case Int52RepUse:
3947                             // Nothing we can really do.
3948                             break;
3949 
3950                         case UntypedUse:
3951                         case NumberUse:
3952                             if (edge-&gt;hasDoubleResult())
3953                                 edge.setUseKind(DoubleRepUse);
3954                             else if (edge-&gt;hasInt52Result())
3955                                 edge.setUseKind(Int52RepUse);
3956                             break;
3957 
3958                         case RealNumberUse:
3959                             if (edge-&gt;hasDoubleResult())
3960                                 edge.setUseKind(DoubleRepRealUse);
3961                             else if (edge-&gt;hasInt52Result())
3962                                 edge.setUseKind(Int52RepUse);
3963                             break;
3964 
3965                         default:
3966                             break;
3967                         }
3968                     });
3969                 break;
3970 
3971             case ValueToInt32:
3972                 if (node-&gt;child1().useKind() == DoubleRepUse
3973                     &amp;&amp; !node-&gt;child1()-&gt;hasDoubleResult()) {
3974                     node-&gt;child1().setUseKind(NumberUse);
3975                     break;
3976                 }
3977                 break;
3978 
3979             default:
3980                 break;
3981             }
3982 
3983             // Now, insert type conversions if necessary.
3984             m_graph.doToChildren(
3985                 node,
3986                 [&amp;] (Edge&amp; edge) {
3987                     Node* result = nullptr;
3988 
3989                     switch (edge.useKind()) {
3990                     case DoubleRepUse:
3991                     case DoubleRepRealUse:
3992                     case DoubleRepAnyIntUse: {
3993                         if (edge-&gt;hasDoubleResult())
3994                             break;
3995 
3996                         ASSERT(indexForChecks != UINT_MAX);
3997                         if (edge-&gt;isNumberConstant()) {
3998                             result = m_insertionSet.insertNode(
3999                                 indexForChecks, SpecBytecodeDouble, DoubleConstant, originForChecks,
4000                                 OpInfo(m_graph.freeze(jsDoubleNumber(edge-&gt;asNumber()))));
4001                         } else if (edge-&gt;hasInt52Result()) {
4002                             result = m_insertionSet.insertNode(
4003                                 indexForChecks, SpecAnyIntAsDouble, DoubleRep, originForChecks,
4004                                 Edge(edge.node(), Int52RepUse));
4005                         } else {
4006                             UseKind useKind;
4007                             if (edge-&gt;shouldSpeculateDoubleReal())
4008                                 useKind = RealNumberUse;
4009                             else if (edge-&gt;shouldSpeculateNumber())
4010                                 useKind = NumberUse;
4011                             else
4012                                 useKind = NotCellUse;
4013 
4014                             result = m_insertionSet.insertNode(
4015                                 indexForChecks, SpecBytecodeDouble, DoubleRep, originForChecks,
4016                                 Edge(edge.node(), useKind));
4017                         }
4018 
4019                         edge.setNode(result);
4020                         break;
4021                     }
4022 
4023                     case Int52RepUse: {
4024                         if (edge-&gt;hasInt52Result())
4025                             break;
4026 
4027                         ASSERT(indexForChecks != UINT_MAX);
4028                         if (edge-&gt;isAnyIntConstant()) {
4029                             result = m_insertionSet.insertNode(
4030                                 indexForChecks, SpecInt52Any, Int52Constant, originForChecks,
4031                                 OpInfo(edge-&gt;constant()));
4032                         } else if (edge-&gt;hasDoubleResult()) {
4033                             result = m_insertionSet.insertNode(
4034                                 indexForChecks, SpecInt52Any, Int52Rep, originForChecks,
4035                                 Edge(edge.node(), DoubleRepAnyIntUse));
4036                         } else if (edge-&gt;shouldSpeculateInt32ForArithmetic()) {
4037                             result = m_insertionSet.insertNode(
4038                                 indexForChecks, SpecInt32Only, Int52Rep, originForChecks,
4039                                 Edge(edge.node(), Int32Use));
4040                         } else {
4041                             result = m_insertionSet.insertNode(
4042                                 indexForChecks, SpecInt52Any, Int52Rep, originForChecks,
4043                                 Edge(edge.node(), AnyIntUse));
4044                         }
4045 
4046                         edge.setNode(result);
4047                         break;
4048                     }
4049 
4050                     default: {
4051                         if (!edge-&gt;hasDoubleResult() &amp;&amp; !edge-&gt;hasInt52Result())
4052                             break;
4053 
4054                         ASSERT(indexForChecks != UINT_MAX);
4055                         if (edge-&gt;hasDoubleResult()) {
4056                             result = m_insertionSet.insertNode(
4057                                 indexForChecks, SpecBytecodeDouble, ValueRep, originForChecks,
4058                                 Edge(edge.node(), DoubleRepUse));
4059                         } else {
4060                             result = m_insertionSet.insertNode(
4061                                 indexForChecks, SpecInt32Only | SpecAnyIntAsDouble, ValueRep,
4062                                 originForChecks, Edge(edge.node(), Int52RepUse));
4063                         }
4064 
4065                         edge.setNode(result);
4066                         break;
4067                     } }
4068 
4069                     // It&#39;s remotely possible that this node cannot do type checks, but we now have a
4070                     // type check on this node. We don&#39;t have to handle the general form of this
4071                     // problem. It only arises when ByteCodeParser emits an immediate SetLocal, rather
4072                     // than a delayed one. So, we only worry about those checks that we may have put on
4073                     // a SetLocal. Note that &quot;indexForChecks != indexInBlock&quot; is just another way of
4074                     // saying &quot;!node-&gt;origin.exitOK&quot;.
4075                     if (indexForChecks != indexInBlock &amp;&amp; mayHaveTypeCheck(edge.useKind())) {
4076                         UseKind knownUseKind;
4077 
4078                         switch (edge.useKind()) {
4079                         case Int32Use:
4080                             knownUseKind = KnownInt32Use;
4081                             break;
4082                         case CellUse:
4083                             knownUseKind = KnownCellUse;
4084                             break;
4085                         case BooleanUse:
4086                             knownUseKind = KnownBooleanUse;
4087                             break;
4088                         default:
4089                             // This can only arise if we have a Check node, and in that case, we can
4090                             // just remove the original check.
4091                             DFG_ASSERT(m_graph, node, node-&gt;op() == Check, node-&gt;op(), edge.useKind());
4092                             knownUseKind = UntypedUse;
4093                             break;
4094                         }
4095 
4096                         ASSERT(indexForChecks != UINT_MAX);
4097                         m_insertionSet.insertNode(
4098                             indexForChecks, SpecNone, Check, originForChecks, edge);
4099 
4100                         edge.setUseKind(knownUseKind);
4101                     }
4102                 });
4103         }
4104 
4105         m_insertionSet.execute(block);
4106     }
4107 
4108     BasicBlock* m_block;
4109     unsigned m_indexInBlock;
4110     Node* m_currentNode;
4111     InsertionSet m_insertionSet;
4112     bool m_profitabilityChanged;
4113 };
4114 
4115 bool performFixup(Graph&amp; graph)
4116 {
4117     return runPhase&lt;FixupPhase&gt;(graph);
4118 }
4119 
4120 } } // namespace JSC::DFG
4121 
4122 #endif // ENABLE(DFG_JIT)
4123 
    </pre>
  </body>
</html>