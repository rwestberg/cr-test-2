<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/Page.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NavigatorBase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Page.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/Page.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18  */
  19 
  20 #include &quot;config.h&quot;
  21 #include &quot;Page.h&quot;
  22 
  23 #include &quot;ActivityStateChangeObserver.h&quot;
  24 #include &quot;AlternativeTextClient.h&quot;
  25 #include &quot;ApplicationCacheStorage.h&quot;
  26 #include &quot;ApplicationStateChangeListener.h&quot;
  27 #include &quot;AuthenticatorCoordinator.h&quot;
  28 #include &quot;BackForwardClient.h&quot;
  29 #include &quot;BackForwardController.h&quot;
  30 #include &quot;CSSAnimationController.h&quot;
  31 #include &quot;CacheStorageProvider.h&quot;
  32 #include &quot;Chrome.h&quot;
  33 #include &quot;ChromeClient.h&quot;
  34 #include &quot;ConstantPropertyMap.h&quot;
  35 #include &quot;ContextMenuClient.h&quot;
  36 #include &quot;ContextMenuController.h&quot;
  37 #include &quot;CookieJar.h&quot;

  38 #include &quot;DOMRect.h&quot;
  39 #include &quot;DOMRectList.h&quot;
  40 #include &quot;DatabaseProvider.h&quot;
  41 #include &quot;DiagnosticLoggingClient.h&quot;
  42 #include &quot;DiagnosticLoggingKeys.h&quot;
  43 #include &quot;DocumentLoader.h&quot;
  44 #include &quot;DocumentMarkerController.h&quot;
  45 #include &quot;DocumentTimeline.h&quot;
  46 #include &quot;DragController.h&quot;
  47 #include &quot;Editing.h&quot;
  48 #include &quot;Editor.h&quot;
  49 #include &quot;EditorClient.h&quot;
  50 #include &quot;EmptyClients.h&quot;
  51 #include &quot;Event.h&quot;
  52 #include &quot;EventNames.h&quot;
  53 #include &quot;ExtensionStyleSheets.h&quot;
  54 #include &quot;FocusController.h&quot;
  55 #include &quot;FrameLoader.h&quot;
  56 #include &quot;FrameLoaderClient.h&quot;
  57 #include &quot;FrameSelection.h&quot;
  58 #include &quot;FrameTree.h&quot;
  59 #include &quot;FrameView.h&quot;

  60 #include &quot;HTMLElement.h&quot;
  61 #include &quot;HTMLMediaElement.h&quot;
  62 #include &quot;HistoryController.h&quot;
  63 #include &quot;HistoryItem.h&quot;
  64 #include &quot;InspectorClient.h&quot;
  65 #include &quot;InspectorController.h&quot;
  66 #include &quot;InspectorInstrumentation.h&quot;
  67 #include &quot;LibWebRTCProvider.h&quot;
  68 #include &quot;LoaderStrategy.h&quot;
  69 #include &quot;Logging.h&quot;
  70 #include &quot;LowPowerModeNotifier.h&quot;
  71 #include &quot;MediaCanStartListener.h&quot;
  72 #include &quot;Navigator.h&quot;
  73 #include &quot;PageCache.h&quot;
  74 #include &quot;PageConfiguration.h&quot;
  75 #include &quot;PageConsoleClient.h&quot;
  76 #include &quot;PageDebuggable.h&quot;
  77 #include &quot;PageGroup.h&quot;
  78 #include &quot;PageOverlayController.h&quot;
  79 #include &quot;PaymentCoordinator.h&quot;
  80 #include &quot;PerformanceLogging.h&quot;
  81 #include &quot;PerformanceLoggingClient.h&quot;
  82 #include &quot;PerformanceMonitor.h&quot;
  83 #include &quot;PlatformMediaSessionManager.h&quot;
  84 #include &quot;PlatformStrategies.h&quot;
  85 #include &quot;PlugInClient.h&quot;
  86 #include &quot;PluginData.h&quot;
  87 #include &quot;PluginInfoProvider.h&quot;
  88 #include &quot;PluginViewBase.h&quot;
  89 #include &quot;PointerCaptureController.h&quot;
  90 #include &quot;PointerLockController.h&quot;
  91 #include &quot;ProgressTracker.h&quot;
<span class="line-modified">  92 #include &quot;PublicSuffix.h&quot;</span>
  93 #include &quot;RenderLayerCompositor.h&quot;
  94 #include &quot;RenderTheme.h&quot;
  95 #include &quot;RenderView.h&quot;
  96 #include &quot;RenderWidget.h&quot;

  97 #include &quot;ResourceUsageOverlay.h&quot;
  98 #include &quot;RuntimeEnabledFeatures.h&quot;
  99 #include &quot;SVGDocumentExtensions.h&quot;
 100 #include &quot;SchemeRegistry.h&quot;
 101 #include &quot;ScriptController.h&quot;
 102 #include &quot;ScriptedAnimationController.h&quot;
 103 #include &quot;ScrollLatchingState.h&quot;
 104 #include &quot;ScrollingCoordinator.h&quot;
 105 #include &quot;Settings.h&quot;
 106 #include &quot;SharedBuffer.h&quot;
 107 #include &quot;SocketProvider.h&quot;
 108 #include &quot;StorageArea.h&quot;
 109 #include &quot;StorageNamespace.h&quot;
 110 #include &quot;StorageNamespaceProvider.h&quot;
 111 #include &quot;StyleResolver.h&quot;
 112 #include &quot;StyleScope.h&quot;
 113 #include &quot;SubframeLoader.h&quot;
 114 #include &quot;TextIterator.h&quot;
 115 #include &quot;TextResourceDecoder.h&quot;
 116 #include &quot;UserContentProvider.h&quot;
 117 #include &quot;UserInputBridge.h&quot;
 118 #include &quot;ValidationMessageClient.h&quot;
 119 #include &quot;VisitedLinkState.h&quot;
 120 #include &quot;VisitedLinkStore.h&quot;
 121 #include &quot;VoidCallback.h&quot;
<span class="line-removed"> 122 #include &quot;WebGLStateTracker.h&quot;</span>
 123 #include &quot;WheelEventDeltaFilter.h&quot;
 124 #include &quot;Widget.h&quot;
 125 #include &lt;wtf/FileSystem.h&gt;
 126 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 127 #include &lt;wtf/StdLibExtras.h&gt;

 128 #include &lt;wtf/text/Base64.h&gt;
 129 #include &lt;wtf/text/StringHash.h&gt;
 130 
 131 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 132 #include &quot;HTMLVideoElement.h&quot;
 133 #include &quot;MediaPlaybackTarget.h&quot;
 134 #endif
 135 
 136 #if PLATFORM(MAC)
 137 #include &quot;ServicesOverlayController.h&quot;
 138 #endif
 139 
 140 #if ENABLE(MEDIA_SESSION)
 141 #include &quot;MediaSessionManager.h&quot;
 142 #endif
 143 
 144 #if ENABLE(INDEXED_DATABASE)
 145 #include &quot;IDBConnectionToServer.h&quot;
 146 #include &quot;InProcessIDBServer.h&quot;
 147 #endif
 148 
 149 #if ENABLE(DATA_INTERACTION)
 150 #include &quot;SelectionRect.h&quot;
 151 #endif
 152 




 153 namespace WebCore {
 154 
 155 static HashSet&lt;Page*&gt;&amp; allPages()
 156 {
 157     static NeverDestroyed&lt;HashSet&lt;Page*&gt;&gt; set;
 158     return set;
 159 }
 160 
 161 static unsigned nonUtilityPageCount { 0 };
 162 
 163 static inline bool isUtilityPageChromeClient(ChromeClient&amp; chromeClient)
 164 {
 165     return chromeClient.isEmptyChromeClient() || chromeClient.isSVGImageChromeClient();
 166 }
 167 
 168 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, pageCounter, (&quot;Page&quot;));
 169 
 170 void Page::forEachPage(const WTF::Function&lt;void(Page&amp;)&gt;&amp; function)
 171 {
 172     for (auto* page : allPages())
</pre>
<hr />
<pre>
 187     for (auto* page : allPages()) {
 188         for (Frame* frame = &amp;page-&gt;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
 189             frames.append(*frame);
 190         InspectorInstrumentation::networkStateChanged(*page);
 191     }
 192 
 193     auto&amp; eventName = isOnLine ? eventNames().onlineEvent : eventNames().offlineEvent;
 194     for (auto&amp; frame : frames) {
 195         if (!frame-&gt;document())
 196             continue;
 197         frame-&gt;document()-&gt;dispatchWindowEvent(Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::No));
 198     }
 199 }
 200 
 201 static constexpr OptionSet&lt;ActivityState::Flag&gt; pageInitialActivityState()
 202 {
 203     return { ActivityState::IsVisible, ActivityState::IsInWindow };
 204 }
 205 
 206 Page::Page(PageConfiguration&amp;&amp; pageConfiguration)
<span class="line-modified"> 207     : m_chrome(std::make_unique&lt;Chrome&gt;(*this, *pageConfiguration.chromeClient))</span>
<span class="line-modified"> 208     , m_dragCaretController(std::make_unique&lt;DragCaretController&gt;())</span>
 209 #if ENABLE(DRAG_SUPPORT)
<span class="line-modified"> 210     , m_dragController(std::make_unique&lt;DragController&gt;(*this, *pageConfiguration.dragClient))</span>
 211 #endif
<span class="line-modified"> 212     , m_focusController(std::make_unique&lt;FocusController&gt;(*this, pageInitialActivityState()))</span>
 213 #if ENABLE(CONTEXT_MENUS)
<span class="line-modified"> 214     , m_contextMenuController(std::make_unique&lt;ContextMenuController&gt;(*this, *pageConfiguration.contextMenuClient))</span>
 215 #endif
<span class="line-modified"> 216     , m_userInputBridge(std::make_unique&lt;UserInputBridge&gt;(*this))</span>
<span class="line-modified"> 217     , m_inspectorController(std::make_unique&lt;InspectorController&gt;(*this, pageConfiguration.inspectorClient))</span>
 218 #if ENABLE(POINTER_EVENTS)
<span class="line-modified"> 219     , m_pointerCaptureController(std::make_unique&lt;PointerCaptureController&gt;(*this))</span>
 220 #endif
 221 #if ENABLE(POINTER_LOCK)
<span class="line-modified"> 222     , m_pointerLockController(std::make_unique&lt;PointerLockController&gt;(*this))</span>
 223 #endif
 224     , m_settings(Settings::create(this))
<span class="line-modified"> 225     , m_progress(std::make_unique&lt;ProgressTracker&gt;(*pageConfiguration.progressTrackerClient))</span>
<span class="line-modified"> 226     , m_backForwardController(std::make_unique&lt;BackForwardController&gt;(*this, WTFMove(pageConfiguration.backForwardClient)))</span>
 227     , m_mainFrame(Frame::create(this, nullptr, pageConfiguration.loaderClientForMainFrame))
 228     , m_editorClient(WTFMove(pageConfiguration.editorClient))
 229     , m_plugInClient(pageConfiguration.plugInClient)
 230     , m_validationMessageClient(WTFMove(pageConfiguration.validationMessageClient))
 231     , m_diagnosticLoggingClient(WTFMove(pageConfiguration.diagnosticLoggingClient))
 232     , m_performanceLoggingClient(WTFMove(pageConfiguration.performanceLoggingClient))

 233     , m_webGLStateTracker(WTFMove(pageConfiguration.webGLStateTracker))




 234     , m_libWebRTCProvider(WTFMove(pageConfiguration.libWebRTCProvider))
 235     , m_verticalScrollElasticity(ScrollElasticityAllowed)
 236     , m_horizontalScrollElasticity(ScrollElasticityAllowed)
 237     , m_domTimerAlignmentInterval(DOMTimer::defaultAlignmentInterval())
 238     , m_domTimerAlignmentIntervalIncreaseTimer(*this, &amp;Page::domTimerAlignmentIntervalIncreaseTimerFired)
 239     , m_activityState(pageInitialActivityState())
 240     , m_alternativeTextClient(pageConfiguration.alternativeTextClient)
<span class="line-modified"> 241     , m_consoleClient(std::make_unique&lt;PageConsoleClient&gt;(*this))</span>
 242 #if ENABLE(REMOTE_INSPECTOR)
<span class="line-modified"> 243     , m_inspectorDebuggable(std::make_unique&lt;PageDebuggable&gt;(*this))</span>
 244 #endif
 245     , m_socketProvider(WTFMove(pageConfiguration.socketProvider))
 246     , m_cookieJar(WTFMove(pageConfiguration.cookieJar))
 247     , m_applicationCacheStorage(*WTFMove(pageConfiguration.applicationCacheStorage))
 248     , m_cacheStorageProvider(WTFMove(pageConfiguration.cacheStorageProvider))
 249     , m_databaseProvider(*WTFMove(pageConfiguration.databaseProvider))
 250     , m_pluginInfoProvider(*WTFMove(pageConfiguration.pluginInfoProvider))
 251     , m_storageNamespaceProvider(*WTFMove(pageConfiguration.storageNamespaceProvider))
 252     , m_userContentProvider(*WTFMove(pageConfiguration.userContentProvider))
 253     , m_visitedLinkStore(*WTFMove(pageConfiguration.visitedLinkStore))
<span class="line-removed"> 254 #if ENABLE(INTERSECTION_OBSERVER)</span>
<span class="line-removed"> 255     , m_intersectionObservationUpdateTimer(*this, &amp;Page::updateIntersectionObservations)</span>
<span class="line-removed"> 256 #endif</span>
 257     , m_sessionID(PAL::SessionID::defaultSessionID())
 258 #if ENABLE(VIDEO)
 259     , m_playbackControlsManagerUpdateTimer(*this, &amp;Page::playbackControlsManagerUpdateTimerFired)
 260 #endif
 261     , m_isUtilityPage(isUtilityPageChromeClient(chrome().client()))
<span class="line-modified"> 262     , m_performanceMonitor(isUtilityPage() ? nullptr : std::make_unique&lt;PerformanceMonitor&gt;(*this))</span>
<span class="line-modified"> 263     , m_lowPowerModeNotifier(std::make_unique&lt;LowPowerModeNotifier&gt;([this](bool isLowPowerModeEnabled) { handleLowModePowerChange(isLowPowerModeEnabled); }))</span>
<span class="line-modified"> 264     , m_performanceLogging(std::make_unique&lt;PerformanceLogging&gt;(*this))</span>
 265 #if PLATFORM(MAC) &amp;&amp; (ENABLE(SERVICE_CONTROLS) || ENABLE(TELEPHONE_NUMBER_DETECTION))
<span class="line-modified"> 266     , m_servicesOverlayController(std::make_unique&lt;ServicesOverlayController&gt;(*this))</span>
 267 #endif
 268     , m_recentWheelEventDeltaFilter(WheelEventDeltaFilter::create())
<span class="line-modified"> 269     , m_pageOverlayController(std::make_unique&lt;PageOverlayController&gt;(*this))</span>
 270 #if ENABLE(APPLE_PAY)
<span class="line-modified"> 271     , m_paymentCoordinator(std::make_unique&lt;PaymentCoordinator&gt;(*pageConfiguration.paymentCoordinatorClient))</span>
 272 #endif
 273 #if ENABLE(WEB_AUTHN)
 274     , m_authenticatorCoordinator(makeUniqueRef&lt;AuthenticatorCoordinator&gt;(WTFMove(pageConfiguration.authenticatorCoordinatorClient)))
 275 #endif
 276 #if ENABLE(APPLICATION_MANIFEST)
 277     , m_applicationManifest(pageConfiguration.applicationManifest)
 278 #endif
 279 {
 280     updateTimerThrottlingState();
 281 
 282     m_pluginInfoProvider-&gt;addPage(*this);
<span class="line-removed"> 283     m_storageNamespaceProvider-&gt;addPage(*this);</span>
 284     m_userContentProvider-&gt;addPage(*this);
 285     m_visitedLinkStore-&gt;addPage(*this);
 286 
 287     static bool addedListener;
 288     if (!addedListener) {
 289         platformStrategies()-&gt;loaderStrategy()-&gt;addOnlineStateChangeListener(&amp;networkStateChanged);
 290         addedListener = true;
 291     }
 292 
 293     ASSERT(!allPages().contains(this));
 294     allPages().add(this);
 295 
 296     if (!isUtilityPage()) {
 297         ++nonUtilityPageCount;
 298         MemoryPressureHandler::setPageCount(nonUtilityPageCount);
 299     }
 300 
 301 #ifndef NDEBUG
 302     pageCounter.increment();
 303 #endif
</pre>
<hr />
<pre>
 341         frame-&gt;detachFromPage();
 342     }
 343 
 344     if (m_plugInClient)
 345         m_plugInClient-&gt;pageDestroyed();
 346     if (m_alternativeTextClient)
 347         m_alternativeTextClient-&gt;pageDestroyed();
 348 
 349     if (m_scrollingCoordinator)
 350         m_scrollingCoordinator-&gt;pageDestroyed();
 351 
 352     backForward().close();
 353     if (!isUtilityPage())
 354         PageCache::singleton().removeAllItemsForPage(*this);
 355 
 356 #ifndef NDEBUG
 357     pageCounter.decrement();
 358 #endif
 359 
 360     m_pluginInfoProvider-&gt;removePage(*this);
<span class="line-removed"> 361     m_storageNamespaceProvider-&gt;removePage(*this);</span>
 362     m_userContentProvider-&gt;removePage(*this);
 363     m_visitedLinkStore-&gt;removePage(*this);
 364 }
 365 
 366 void Page::clearPreviousItemFromAllPages(HistoryItem* item)
 367 {
 368     for (auto* page : allPages()) {
 369         auto&amp; controller = page-&gt;mainFrame().loader().history();
 370         if (item == controller.previousItem()) {
 371             controller.clearPreviousItem();
 372             return;
 373         }
 374     }
 375 }
 376 
 377 uint64_t Page::renderTreeSize() const
 378 {
 379     uint64_t total = 0;
 380     for (const Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
 381         if (!frame-&gt;document() || !frame-&gt;document()-&gt;renderView())
 382             continue;
 383         total += frame-&gt;document()-&gt;renderView()-&gt;rendererCount();
 384     }
 385     return total;
 386 }
 387 
 388 OptionSet&lt;DisabledAdaptations&gt; Page::disabledAdaptations() const
 389 {
 390     if (mainFrame().document())
 391         return mainFrame().document()-&gt;disabledAdaptations();
 392 
 393     return { };
 394 }
 395 
 396 ViewportArguments Page::viewportArguments() const
 397 {
 398     return mainFrame().document() ? mainFrame().document()-&gt;viewportArguments() : ViewportArguments();
 399 }
 400 










 401 ScrollingCoordinator* Page::scrollingCoordinator()
 402 {
 403     if (!m_scrollingCoordinator &amp;&amp; m_settings-&gt;scrollingCoordinatorEnabled()) {
 404         m_scrollingCoordinator = chrome().client().createScrollingCoordinator(*this);
 405         if (!m_scrollingCoordinator)
 406             m_scrollingCoordinator = ScrollingCoordinator::create(this);
 407     }
 408 
 409     return m_scrollingCoordinator.get();
 410 }
 411 
 412 String Page::scrollingStateTreeAsText()
 413 {
 414     if (Document* document = m_mainFrame-&gt;document())
 415         document-&gt;updateLayout();
 416 
 417     if (ScrollingCoordinator* scrollingCoordinator = this-&gt;scrollingCoordinator())
 418         return scrollingCoordinator-&gt;scrollingStateTreeAsText();
 419 
 420     return String();
</pre>
<hr />
<pre>
 525     }
 526 
 527     if (name.isEmpty())
 528         m_group = m_singlePageGroup.get();
 529     else {
 530         m_singlePageGroup = nullptr;
 531         m_group = PageGroup::pageGroup(name);
 532         m_group-&gt;addPage(*this);
 533     }
 534 }
 535 
 536 const String&amp; Page::groupName() const
 537 {
 538     return m_group ? m_group-&gt;name() : nullAtom().string();
 539 }
 540 
 541 void Page::initGroup()
 542 {
 543     ASSERT(!m_singlePageGroup);
 544     ASSERT(!m_group);
<span class="line-modified"> 545     m_singlePageGroup = std::make_unique&lt;PageGroup&gt;(*this);</span>
 546     m_group = m_singlePageGroup.get();
 547 }
 548 
 549 void Page::updateStyleAfterChangeInEnvironment()
 550 {
 551     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
 552         // If a change in the global environment has occurred, we need to
 553         // make sure all the properties a recomputed, therefore we invalidate
 554         // the properties cache.
 555         auto* document = frame-&gt;document();
 556         if (!document)
 557             continue;
 558 
 559         if (StyleResolver* styleResolver = document-&gt;styleScope().resolverIfExists())
 560             styleResolver-&gt;invalidateMatchedPropertiesCache();
 561         document-&gt;scheduleFullStyleRebuild();
 562         document-&gt;styleScope().didChangeStyleSheetEnvironment();
 563     }
 564 }
 565 
</pre>
<hr />
<pre>
1058 }
1059 
1060 void Page::setDeviceScaleFactor(float scaleFactor)
1061 {
1062     ASSERT(scaleFactor &gt; 0);
1063     if (scaleFactor &lt;= 0)
1064         return;
1065 
1066     if (m_deviceScaleFactor == scaleFactor)
1067         return;
1068 
1069     m_deviceScaleFactor = scaleFactor;
1070     setNeedsRecalcStyleInAllFrames();
1071 
1072     mainFrame().deviceOrPageScaleFactorChanged();
1073     PageCache::singleton().markPagesForDeviceOrPageScaleChanged(*this);
1074 
1075     pageOverlayController().didChangeDeviceScaleFactor();
1076 }
1077 





1078 void Page::setUserInterfaceLayoutDirection(UserInterfaceLayoutDirection userInterfaceLayoutDirection)
1079 {
1080     if (m_userInterfaceLayoutDirection == userInterfaceLayoutDirection)
1081         return;
1082 
1083     m_userInterfaceLayoutDirection = userInterfaceLayoutDirection;
1084 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1085     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1086         if (!frame-&gt;document())
1087             continue;
1088         frame-&gt;document()-&gt;userInterfaceLayoutDirectionChanged();
1089     }
1090 #endif
1091 }
1092 
1093 #if ENABLE(VIDEO)
1094 void Page::updateMediaElementRateChangeRestrictions()
1095 {
1096     for (auto* mediaElement : HTMLMediaElement::allMediaElements())
1097         mediaElement-&gt;updateRateChangeRestrictions();
1098 }
1099 #endif
1100 
1101 void Page::didStartProvisionalLoad()
1102 {
1103     if (m_performanceMonitor)
1104         m_performanceMonitor-&gt;didStartProvisionalLoad();
1105 }
1106 
1107 void Page::didFinishLoad()
1108 {
1109     resetRelevantPaintedObjectCounter();
1110 
1111     if (m_performanceMonitor)
1112         m_performanceMonitor-&gt;didFinishLoad();
1113 }
1114 
<span class="line-removed">1115 void Page::willDisplayPage()</span>
<span class="line-removed">1116 {</span>
<span class="line-removed">1117 #if ENABLE(INTERSECTION_OBSERVER)</span>
<span class="line-removed">1118     updateIntersectionObservations();</span>
<span class="line-removed">1119 #endif</span>
<span class="line-removed">1120 }</span>
<span class="line-removed">1121 </span>
1122 bool Page::isOnlyNonUtilityPage() const
1123 {
1124     return !isUtilityPage() &amp;&amp; nonUtilityPageCount == 1;
1125 }
1126 
1127 bool Page::isLowPowerModeEnabled() const
1128 {
1129     if (m_lowPowerModeEnabledOverrideForTesting)
1130         return m_lowPowerModeEnabledOverrideForTesting.value();
1131 
1132     return m_lowPowerModeNotifier-&gt;isLowPowerModeEnabled();
1133 }
1134 
1135 void Page::setLowPowerModeEnabledOverrideForTesting(Optional&lt;bool&gt; isEnabled)
1136 {
1137     m_lowPowerModeEnabledOverrideForTesting = isEnabled;
1138     handleLowModePowerChange(m_lowPowerModeEnabledOverrideForTesting.valueOr(false));
1139 }
1140 
1141 void Page::setTopContentInset(float contentInset)
</pre>
<hr />
<pre>
1243 {
1244     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1245         if (FrameView* frameView = frame-&gt;view())
1246             frameView-&gt;setIsInWindow(isInWindow);
1247     }
1248 
1249     if (isInWindow)
1250         resumeAnimatingImages();
1251 }
1252 
1253 void Page::addActivityStateChangeObserver(ActivityStateChangeObserver&amp; observer)
1254 {
1255     m_activityStateChangeObservers.add(&amp;observer);
1256 }
1257 
1258 void Page::removeActivityStateChangeObserver(ActivityStateChangeObserver&amp; observer)
1259 {
1260     m_activityStateChangeObservers.remove(&amp;observer);
1261 }
1262 
<span class="line-modified">1263 #if ENABLE(INTERSECTION_OBSERVER)</span>
<span class="line-removed">1264 void Page::addDocumentNeedingIntersectionObservationUpdate(Document&amp; document)</span>
1265 {
<span class="line-modified">1266     if (m_documentsNeedingIntersectionObservationUpdate.find(&amp;document) == notFound)</span>
<span class="line-modified">1267         m_documentsNeedingIntersectionObservationUpdate.append(makeWeakPtr(document));</span>
1268 }
1269 
<span class="line-modified">1270 void Page::updateIntersectionObservations()</span>
1271 {
<span class="line-modified">1272     m_intersectionObservationUpdateTimer.stop();</span>
<span class="line-modified">1273     for (const auto&amp; document : m_documentsNeedingIntersectionObservationUpdate) {</span>
<span class="line-modified">1274         if (document)</span>
<span class="line-modified">1275             document-&gt;updateIntersectionObservations();</span>
1276     }
<span class="line-removed">1277     m_documentsNeedingIntersectionObservationUpdate.clear();</span>
<span class="line-removed">1278 }</span>
1279 
<span class="line-modified">1280 void Page::scheduleForcedIntersectionObservationUpdate(Document&amp; document)</span>
<span class="line-modified">1281 {</span>
<span class="line-modified">1282     addDocumentNeedingIntersectionObservationUpdate(document);</span>
<span class="line-modified">1283     if (m_intersectionObservationUpdateTimer.isActive())</span>
<span class="line-modified">1284         return;</span>
<span class="line-modified">1285     m_intersectionObservationUpdateTimer.startOneShot(0_s);</span>
<span class="line-modified">1286 }</span>















1287 #endif







1288 
1289 void Page::suspendScriptedAnimations()
1290 {
1291     m_scriptedAnimationsSuspended = true;
1292     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1293         if (frame-&gt;document())
1294             frame-&gt;document()-&gt;suspendScriptedAnimationControllerCallbacks();
1295     }
1296 }
1297 
1298 void Page::resumeScriptedAnimations()
1299 {
1300     m_scriptedAnimationsSuspended = false;
1301     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1302         if (frame-&gt;document())
1303             frame-&gt;document()-&gt;resumeScriptedAnimationControllerCallbacks();
1304     }
1305 }
1306 
1307 enum class ThrottlingReasonOperation { Add, Remove };
</pre>
<hr />
<pre>
1457 
1458     m_debugger = debugger;
1459 
1460     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext())
1461         frame-&gt;windowProxy().attachDebugger(m_debugger);
1462 }
1463 
1464 StorageNamespace* Page::sessionStorage(bool optionalCreate)
1465 {
1466     if (!m_sessionStorage &amp;&amp; optionalCreate)
1467         m_sessionStorage = m_storageNamespaceProvider-&gt;createSessionStorageNamespace(*this, m_settings-&gt;sessionStorageQuota());
1468 
1469     return m_sessionStorage.get();
1470 }
1471 
1472 void Page::setSessionStorage(RefPtr&lt;StorageNamespace&gt;&amp;&amp; newStorage)
1473 {
1474     m_sessionStorage = WTFMove(newStorage);
1475 }
1476 
<span class="line-removed">1477 StorageNamespace* Page::ephemeralLocalStorage(bool optionalCreate)</span>
<span class="line-removed">1478 {</span>
<span class="line-removed">1479     if (!m_ephemeralLocalStorage &amp;&amp; optionalCreate)</span>
<span class="line-removed">1480         m_ephemeralLocalStorage = m_storageNamespaceProvider-&gt;createEphemeralLocalStorageNamespace(*this, m_settings-&gt;sessionStorageQuota());</span>
<span class="line-removed">1481 </span>
<span class="line-removed">1482     return m_ephemeralLocalStorage.get();</span>
<span class="line-removed">1483 }</span>
<span class="line-removed">1484 </span>
<span class="line-removed">1485 void Page::setEphemeralLocalStorage(RefPtr&lt;StorageNamespace&gt;&amp;&amp; newStorage)</span>
<span class="line-removed">1486 {</span>
<span class="line-removed">1487     m_ephemeralLocalStorage = WTFMove(newStorage);</span>
<span class="line-removed">1488 }</span>
<span class="line-removed">1489 </span>
1490 bool Page::hasCustomHTMLTokenizerTimeDelay() const
1491 {
1492     return m_settings-&gt;maxParseDuration() != -1;
1493 }
1494 
1495 double Page::customHTMLTokenizerTimeDelay() const
1496 {
1497     ASSERT(m_settings-&gt;maxParseDuration() != -1);
1498     return m_settings-&gt;maxParseDuration();
1499 }
1500 
1501 void Page::setMemoryCacheClientCallsEnabled(bool enabled)
1502 {
1503     if (m_areMemoryCacheClientCallsEnabled == enabled)
1504         return;
1505 
1506     m_areMemoryCacheClientCallsEnabled = enabled;
1507     if (!enabled)
1508         return;
1509 
</pre>
<hr />
<pre>
1747 
1748     m_mediaPlaybackIsSuspended = true;
1749 #endif
1750 }
1751 
1752 void Page::resumeAllMediaPlayback()
1753 {
1754 #if ENABLE(VIDEO)
1755     ASSERT(m_mediaPlaybackIsSuspended);
1756     if (!m_mediaPlaybackIsSuspended)
1757         return;
1758     m_mediaPlaybackIsSuspended = false;
1759 
1760     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1761         if (auto* document = frame-&gt;document())
1762             document-&gt;resumeAllMediaPlayback();
1763     }
1764 #endif
1765 }
1766 





























1767 #if ENABLE(MEDIA_SESSION)
1768 void Page::handleMediaEvent(MediaEventType eventType)
1769 {
1770     switch (eventType) {
1771     case MediaEventType::PlayPause:
1772         MediaSessionManager::singleton().togglePlayback();
1773         break;
1774     case MediaEventType::TrackNext:
1775         MediaSessionManager::singleton().skipToNextTrack();
1776         break;
1777     case MediaEventType::TrackPrevious:
1778         MediaSessionManager::singleton().skipToPreviousTrack();
1779         break;
1780     }
1781 }
1782 
1783 void Page::setVolumeOfMediaElement(double volume, uint64_t elementID)
1784 {
1785     if (HTMLMediaElement* element = HTMLMediaElement::elementWithID(elementID))
1786         element-&gt;setVolume(volume, ASSERT_NO_EXCEPTION);
</pre>
<hr />
<pre>
2116     m_topRelevantPaintedRegion = Region();
2117     m_bottomRelevantPaintedRegion = Region();
2118     m_relevantUnpaintedRegion = Region();
2119 }
2120 
2121 static LayoutRect relevantViewRect(RenderView* view)
2122 {
2123     LayoutRect viewRect = view-&gt;viewRect();
2124 
2125     float relevantViewRectWidth = 980;
2126 #if PLATFORM(WATCHOS)
2127     // FIXME(186051): Consider limiting the relevant rect width to the view width everywhere.
2128     relevantViewRectWidth = std::min&lt;float&gt;(viewRect.width().toFloat(), relevantViewRectWidth);
2129 #endif
2130 
2131     // DidHitRelevantRepaintedObjectsAreaThreshold is a LayoutMilestone intended to indicate that
2132     // a certain relevant amount of content has been drawn to the screen. This is the rect that
2133     // has been determined to be relevant in the context of this goal. We may choose to tweak
2134     // the rect over time, much like we may choose to tweak gMinimumPaintedAreaRatio and
2135     // gMaximumUnpaintedAreaRatio. But this seems to work well right now.
<span class="line-modified">2136     LayoutRect relevantViewRect { 0, 0, relevantViewRectWidth, 1300 };</span>
2137     // If the viewRect is wider than the relevantViewRect, center the relevantViewRect.
2138     if (viewRect.width() &gt; relevantViewRect.width())
2139         relevantViewRect.setX((viewRect.width() - relevantViewRect.width()) / 2);
2140 
2141     return relevantViewRect;
2142 }
2143 
2144 void Page::addRelevantRepaintedObject(RenderObject* object, const LayoutRect&amp; objectPaintRect)
2145 {
2146     if (!isCountingRelevantRepaintedObjects())
2147         return;
2148 
2149     // Objects inside sub-frames are not considered to be relevant.
2150     if (&amp;object-&gt;frame() != &amp;mainFrame())
2151         return;
2152 
2153     LayoutRect relevantRect = relevantViewRect(&amp;object-&gt;view());
2154 
2155     // The objects are only relevant if they are being painted within the viewRect().
2156     if (!objectPaintRect.intersects(snappedIntRect(relevantRect)))
</pre>
<hr />
<pre>
2352     case FrameLoadType::Reload:
2353         navigationDescription = &quot;reload&quot;_s;
2354         break;
2355     case FrameLoadType::Same:
2356         navigationDescription = &quot;same&quot;_s;
2357         break;
2358     case FrameLoadType::ReloadFromOrigin:
2359         navigationDescription = &quot;reloadFromOrigin&quot;_s;
2360         break;
2361     case FrameLoadType::ReloadExpiredOnly:
2362         navigationDescription = &quot;reloadRevalidatingExpired&quot;_s;
2363         break;
2364     case FrameLoadType::Replace:
2365     case FrameLoadType::RedirectWithLockedBackForwardList:
2366         // Not logging those for now.
2367         return;
2368     }
2369     diagnosticLoggingClient().logDiagnosticMessage(DiagnosticLoggingKeys::navigationKey(), navigationDescription, ShouldSample::No);
2370 
2371     if (!navigation.domain.isEmpty())
<span class="line-modified">2372         diagnosticLoggingClient().logDiagnosticMessageWithEnhancedPrivacy(DiagnosticLoggingKeys::domainVisitedKey(), navigation.domain, ShouldSample::Yes);</span>
2373 }
2374 
2375 void Page::mainFrameLoadStarted(const URL&amp; destinationURL, FrameLoadType type)
2376 {
<span class="line-modified">2377     String domain;</span>
<span class="line-removed">2378 #if ENABLE(PUBLIC_SUFFIX_LIST)</span>
<span class="line-removed">2379     domain = topPrivatelyControlledDomain(destinationURL.host().toString());</span>
<span class="line-removed">2380 #else</span>
<span class="line-removed">2381     UNUSED_PARAM(destinationURL);</span>
<span class="line-removed">2382 #endif</span>
<span class="line-removed">2383 </span>
<span class="line-removed">2384     Navigation navigation = { domain, type };</span>
2385 
2386     // To avoid being too verbose, we only log navigations if the page is or becomes visible. This avoids logging non-user observable loads.
2387     if (!isVisible()) {
2388         m_navigationToLogWhenVisible = navigation;
2389         return;
2390     }
2391 
2392     m_navigationToLogWhenVisible = WTF::nullopt;
2393     logNavigation(navigation);
2394 }
2395 
2396 PluginInfoProvider&amp; Page::pluginInfoProvider()
2397 {
2398     return m_pluginInfoProvider;
2399 }
2400 
2401 UserContentProvider&amp; Page::userContentProvider()
2402 {
2403     return m_userContentProvider;
2404 }
2405 
2406 void Page::setUserContentProvider(Ref&lt;UserContentProvider&gt;&amp;&amp; userContentProvider)
2407 {
2408     m_userContentProvider-&gt;removePage(*this);
2409     m_userContentProvider = WTFMove(userContentProvider);
2410     m_userContentProvider-&gt;addPage(*this);
2411 
2412     invalidateInjectedStyleSheetCacheInAllFrames();
2413 }
2414 
<span class="line-removed">2415 void Page::setStorageNamespaceProvider(Ref&lt;StorageNamespaceProvider&gt;&amp;&amp; storageNamespaceProvider)</span>
<span class="line-removed">2416 {</span>
<span class="line-removed">2417     m_storageNamespaceProvider-&gt;removePage(*this);</span>
<span class="line-removed">2418     m_storageNamespaceProvider = WTFMove(storageNamespaceProvider);</span>
<span class="line-removed">2419     m_storageNamespaceProvider-&gt;addPage(*this);</span>
<span class="line-removed">2420 </span>
<span class="line-removed">2421     // This needs to reset all the local storage namespaces of all the pages.</span>
<span class="line-removed">2422 }</span>
<span class="line-removed">2423 </span>
2424 VisitedLinkStore&amp; Page::visitedLinkStore()
2425 {
2426     return m_visitedLinkStore;
2427 }
2428 
2429 void Page::setVisitedLinkStore(Ref&lt;VisitedLinkStore&gt;&amp;&amp; visitedLinkStore)
2430 {
2431     m_visitedLinkStore-&gt;removePage(*this);
2432     m_visitedLinkStore = WTFMove(visitedLinkStore);
2433     m_visitedLinkStore-&gt;addPage(*this);
2434 
2435     invalidateStylesForAllLinks();
2436 }
2437 
2438 PAL::SessionID Page::sessionID() const
2439 {
2440     return m_sessionID;
2441 }
2442 
2443 void Page::setSessionID(PAL::SessionID sessionID)
2444 {
2445     ASSERT(sessionID.isValid());
2446 
2447 #if ENABLE(INDEXED_DATABASE)
2448     if (sessionID != m_sessionID)
2449         m_idbConnectionToServer = nullptr;
2450 #endif
2451 



2452     bool privateBrowsingStateChanged = (sessionID.isEphemeral() != m_sessionID.isEphemeral());
2453 
2454     m_sessionID = sessionID;
2455 
2456     if (!privateBrowsingStateChanged)
2457         return;
2458 
2459     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2460         if (!frame-&gt;document())
2461             continue;
<span class="line-modified">2462         frame-&gt;document()-&gt;privateBrowsingStateDidChange();</span>
2463     }
2464 
2465     // Collect the PluginViews in to a vector to ensure that action the plug-in takes
2466     // from below privateBrowsingStateChanged does not affect their lifetime.
2467 
2468     for (auto&amp; view : pluginViews())
2469         view-&gt;privateBrowsingStateChanged(sessionID.isEphemeral());
2470 }
2471 
2472 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2473 void Page::addPlaybackTargetPickerClient(uint64_t contextId)
2474 {
2475     chrome().client().addPlaybackTargetPickerClient(contextId);
2476 }
2477 
2478 void Page::removePlaybackTargetPickerClient(uint64_t contextId)
2479 {
2480     chrome().client().removePlaybackTargetPickerClient(contextId);
2481 }
2482 
</pre>
<hr />
<pre>
2579 IDBClient::IDBConnectionToServer* Page::optionalIDBConnection()
2580 {
2581     return m_idbConnectionToServer.get();
2582 }
2583 
2584 void Page::clearIDBConnection()
2585 {
2586     m_idbConnectionToServer = nullptr;
2587 }
2588 #endif
2589 
2590 #if ENABLE(RESOURCE_USAGE)
2591 void Page::setResourceUsageOverlayVisible(bool visible)
2592 {
2593     if (!visible) {
2594         m_resourceUsageOverlay = nullptr;
2595         return;
2596     }
2597 
2598     if (!m_resourceUsageOverlay &amp;&amp; m_settings-&gt;acceleratedCompositingEnabled())
<span class="line-modified">2599         m_resourceUsageOverlay = std::make_unique&lt;ResourceUsageOverlay&gt;(*this);</span>
2600 }
2601 #endif
2602 
2603 bool Page::isAlwaysOnLoggingAllowed() const
2604 {
2605     return m_sessionID.isAlwaysOnLoggingAllowed();
2606 }
2607 
2608 String Page::captionUserPreferencesStyleSheet()
2609 {
2610     return m_captionUserPreferencesStyleSheet;
2611 }
2612 
2613 void Page::setCaptionUserPreferencesStyleSheet(const String&amp; styleSheet)
2614 {
2615     if (m_captionUserPreferencesStyleSheet == styleSheet)
2616         return;
2617 
2618     m_captionUserPreferencesStyleSheet = styleSheet;
2619 }
</pre>
<hr />
<pre>
2624         if (auto* document = frame-&gt;document()) {
2625             document-&gt;styleScope().evaluateMediaQueriesForAccessibilitySettingsChange();
2626             document-&gt;evaluateMediaQueryList();
2627         }
2628     }
2629 }
2630 
2631 void Page::appearanceDidChange()
2632 {
2633     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2634         auto* document = frame-&gt;document();
2635         if (!document)
2636             continue;
2637 
2638         document-&gt;styleScope().didChangeStyleSheetEnvironment();
2639         document-&gt;styleScope().evaluateMediaQueriesForAppearanceChange();
2640         document-&gt;evaluateMediaQueryList();
2641     }
2642 }
2643 
<span class="line-removed">2644 void Page::installedPageOverlaysChanged()</span>
<span class="line-removed">2645 {</span>
<span class="line-removed">2646     if (isInWindow()) {</span>
<span class="line-removed">2647         if (pageOverlayController().hasViewOverlays())</span>
<span class="line-removed">2648             chrome().client().attachViewOverlayGraphicsLayer(&amp;pageOverlayController().layerWithViewOverlays());</span>
<span class="line-removed">2649         else</span>
<span class="line-removed">2650             chrome().client().attachViewOverlayGraphicsLayer(nullptr);</span>
<span class="line-removed">2651     }</span>
<span class="line-removed">2652 </span>
<span class="line-removed">2653     if (auto* frameView = mainFrame().view())</span>
<span class="line-removed">2654         frameView-&gt;setNeedsCompositingConfigurationUpdate();</span>
<span class="line-removed">2655 }</span>
<span class="line-removed">2656 </span>
2657 void Page::setUnobscuredSafeAreaInsets(const FloatBoxExtent&amp; insets)
2658 {
2659     if (m_unobscuredSafeAreaInsets == insets)
2660         return;
2661 
2662     m_unobscuredSafeAreaInsets = insets;
2663 
2664     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2665         if (!frame-&gt;document())
2666             continue;
2667         frame-&gt;document()-&gt;constantProperties().didChangeSafeAreaInsets();
2668     }
2669 }
2670 
2671 void Page::setUseSystemAppearance(bool value)
2672 {
2673     if (m_useSystemAppearance == value)
2674         return;
2675 
2676     m_useSystemAppearance = value;
2677 
2678     appearanceDidChange();
2679 
2680     for (auto* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2681         auto* document = frame-&gt;document();
2682         if (!document)
2683             continue;
2684 
2685         // System apperance change may affect stylesheet parsing. We need to reparse.
2686         document-&gt;extensionStyleSheets().clearPageUserSheet();
2687         document-&gt;extensionStyleSheets().invalidateInjectedStyleSheetCache();
2688     }
2689 }
2690 
<span class="line-modified">2691 void Page::setUseDarkAppearance(bool value)</span>
2692 {
<span class="line-modified">2693 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
<span class="line-modified">2694     if (m_useDarkAppearance == value)</span>
2695         return;
2696 
<span class="line-modified">2697     m_useDarkAppearance = value;</span>

2698 
<span class="line-modified">2699     InspectorInstrumentation::defaultAppearanceDidChange(*this, value);</span>
2700 
2701     appearanceDidChange();
2702 #else
<span class="line-modified">2703     UNUSED_PARAM(value);</span>







2704 #endif
2705 }
2706 
2707 bool Page::useDarkAppearance() const
2708 {
<span class="line-modified">2709 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
2710     FrameView* view = mainFrame().view();
2711     if (!view || !equalLettersIgnoringASCIICase(view-&gt;mediaType(), &quot;screen&quot;))
2712         return false;
2713     if (m_useDarkAppearanceOverride)
2714         return m_useDarkAppearanceOverride.value();
2715     return m_useDarkAppearance;
2716 #else
2717     return false;
2718 #endif
2719 }
2720 
2721 void Page::setUseDarkAppearanceOverride(Optional&lt;bool&gt; valueOverride)
2722 {
2723 #if HAVE(OS_DARK_MODE_SUPPORT)
2724     if (valueOverride == m_useDarkAppearanceOverride)
2725         return;
2726 
2727     m_useDarkAppearanceOverride = valueOverride;
2728 
2729     appearanceDidChange();
</pre>
<hr />
<pre>
2746 }
2747 
2748 void Page::setFullscreenAutoHideDuration(Seconds duration)
2749 {
2750     if (duration == m_fullscreenAutoHideDuration)
2751         return;
2752     m_fullscreenAutoHideDuration = duration;
2753     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2754         if (!frame-&gt;document())
2755             continue;
2756         frame-&gt;document()-&gt;constantProperties().setFullscreenAutoHideDuration(duration);
2757     }
2758 }
2759 
2760 void Page::setFullscreenControlsHidden(bool hidden)
2761 {
2762 #if ENABLE(FULLSCREEN_API)
2763     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2764         if (!frame-&gt;document())
2765             continue;
<span class="line-modified">2766         frame-&gt;document()-&gt;setFullscreenControlsHidden(hidden);</span>
2767     }
2768 #else
2769     UNUSED_PARAM(hidden);
2770 #endif
2771 }
2772 
2773 #if ENABLE(DATA_INTERACTION)
2774 
2775 bool Page::hasSelectionAtPosition(const FloatPoint&amp; position) const
2776 {
2777     auto currentSelection = m_mainFrame-&gt;selection().selection();
2778     if (!currentSelection.isRange())
2779         return false;
2780 
2781     if (auto selectedRange = currentSelection.toNormalizedRange()) {
2782         Vector&lt;SelectionRect&gt; selectionRects;
2783         selectedRange-&gt;collectSelectionRects(selectionRects);
2784         for (auto selectionRect : selectionRects) {
2785             if (FloatRect(selectionRect.rect()).contains(position))
2786                 return true;
</pre>
<hr />
<pre>
2796 {
2797     m_shouldEnableICECandidateFilteringByDefault = false;
2798 #if ENABLE(WEB_RTC)
2799     m_rtcController.disableICECandidateFilteringForAllOrigins();
2800 #endif
2801 }
2802 
2803 void Page::enableICECandidateFiltering()
2804 {
2805     m_shouldEnableICECandidateFilteringByDefault = true;
2806 #if ENABLE(WEB_RTC)
2807     m_rtcController.enableICECandidateFiltering();
2808 #endif
2809 }
2810 
2811 void Page::didChangeMainDocument()
2812 {
2813 #if ENABLE(WEB_RTC)
2814     m_rtcController.reset(m_shouldEnableICECandidateFilteringByDefault);
2815 #endif










2816 }
2817 
2818 void Page::forEachDocument(const Function&lt;void(Document&amp;)&gt;&amp; functor)
2819 {
2820     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2821         if (!frame-&gt;document())
2822             continue;
2823 
2824         functor(*frame-&gt;document());
2825     }
2826 }
2827 
2828 void Page::applicationWillResignActive()
2829 {
2830     forEachDocument([&amp;] (Document&amp; document) {
2831         document.forEachApplicationStateChangeListener([&amp;] (ApplicationStateChangeListener&amp; listener) {
2832             listener.applicationWillResignActive();
2833         });
2834     });
2835 }
</pre>
<hr />
<pre>
2875 void Page::popLatchingState()
2876 {
2877     m_latchingState.removeLast();
2878 }
2879 
2880 void Page::removeLatchingStateForTarget(Element&amp; targetNode)
2881 {
2882     if (m_latchingState.isEmpty())
2883         return;
2884 
2885     m_latchingState.removeAllMatching([&amp;targetNode] (ScrollLatchingState&amp; state) {
2886         auto* wheelElement = state.wheelEventElement();
2887         if (!wheelElement)
2888             return false;
2889 
2890         return targetNode.isEqualNode(wheelElement);
2891     });
2892 }
2893 #endif // PLATFORM(MAC)
2894 






















2895 #if ENABLE(APPLE_PAY)
2896 void Page::setPaymentCoordinator(std::unique_ptr&lt;PaymentCoordinator&gt;&amp;&amp; paymentCoordinator)
2897 {
2898     m_paymentCoordinator = WTFMove(paymentCoordinator);
2899 }
2900 #endif
2901 

















































2902 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  18  */
  19 
  20 #include &quot;config.h&quot;
  21 #include &quot;Page.h&quot;
  22 
  23 #include &quot;ActivityStateChangeObserver.h&quot;
  24 #include &quot;AlternativeTextClient.h&quot;
  25 #include &quot;ApplicationCacheStorage.h&quot;
  26 #include &quot;ApplicationStateChangeListener.h&quot;
  27 #include &quot;AuthenticatorCoordinator.h&quot;
  28 #include &quot;BackForwardClient.h&quot;
  29 #include &quot;BackForwardController.h&quot;
  30 #include &quot;CSSAnimationController.h&quot;
  31 #include &quot;CacheStorageProvider.h&quot;
  32 #include &quot;Chrome.h&quot;
  33 #include &quot;ChromeClient.h&quot;
  34 #include &quot;ConstantPropertyMap.h&quot;
  35 #include &quot;ContextMenuClient.h&quot;
  36 #include &quot;ContextMenuController.h&quot;
  37 #include &quot;CookieJar.h&quot;
<span class="line-added">  38 #include &quot;CustomHeaderFields.h&quot;</span>
  39 #include &quot;DOMRect.h&quot;
  40 #include &quot;DOMRectList.h&quot;
  41 #include &quot;DatabaseProvider.h&quot;
  42 #include &quot;DiagnosticLoggingClient.h&quot;
  43 #include &quot;DiagnosticLoggingKeys.h&quot;
  44 #include &quot;DocumentLoader.h&quot;
  45 #include &quot;DocumentMarkerController.h&quot;
  46 #include &quot;DocumentTimeline.h&quot;
  47 #include &quot;DragController.h&quot;
  48 #include &quot;Editing.h&quot;
  49 #include &quot;Editor.h&quot;
  50 #include &quot;EditorClient.h&quot;
  51 #include &quot;EmptyClients.h&quot;
  52 #include &quot;Event.h&quot;
  53 #include &quot;EventNames.h&quot;
  54 #include &quot;ExtensionStyleSheets.h&quot;
  55 #include &quot;FocusController.h&quot;
  56 #include &quot;FrameLoader.h&quot;
  57 #include &quot;FrameLoaderClient.h&quot;
  58 #include &quot;FrameSelection.h&quot;
  59 #include &quot;FrameTree.h&quot;
  60 #include &quot;FrameView.h&quot;
<span class="line-added">  61 #include &quot;FullscreenManager.h&quot;</span>
  62 #include &quot;HTMLElement.h&quot;
  63 #include &quot;HTMLMediaElement.h&quot;
  64 #include &quot;HistoryController.h&quot;
  65 #include &quot;HistoryItem.h&quot;
  66 #include &quot;InspectorClient.h&quot;
  67 #include &quot;InspectorController.h&quot;
  68 #include &quot;InspectorInstrumentation.h&quot;
  69 #include &quot;LibWebRTCProvider.h&quot;
  70 #include &quot;LoaderStrategy.h&quot;
  71 #include &quot;Logging.h&quot;
  72 #include &quot;LowPowerModeNotifier.h&quot;
  73 #include &quot;MediaCanStartListener.h&quot;
  74 #include &quot;Navigator.h&quot;
  75 #include &quot;PageCache.h&quot;
  76 #include &quot;PageConfiguration.h&quot;
  77 #include &quot;PageConsoleClient.h&quot;
  78 #include &quot;PageDebuggable.h&quot;
  79 #include &quot;PageGroup.h&quot;
  80 #include &quot;PageOverlayController.h&quot;
  81 #include &quot;PaymentCoordinator.h&quot;
  82 #include &quot;PerformanceLogging.h&quot;
  83 #include &quot;PerformanceLoggingClient.h&quot;
  84 #include &quot;PerformanceMonitor.h&quot;
  85 #include &quot;PlatformMediaSessionManager.h&quot;
  86 #include &quot;PlatformStrategies.h&quot;
  87 #include &quot;PlugInClient.h&quot;
  88 #include &quot;PluginData.h&quot;
  89 #include &quot;PluginInfoProvider.h&quot;
  90 #include &quot;PluginViewBase.h&quot;
  91 #include &quot;PointerCaptureController.h&quot;
  92 #include &quot;PointerLockController.h&quot;
  93 #include &quot;ProgressTracker.h&quot;
<span class="line-modified">  94 #include &quot;RenderDescendantIterator.h&quot;</span>
  95 #include &quot;RenderLayerCompositor.h&quot;
  96 #include &quot;RenderTheme.h&quot;
  97 #include &quot;RenderView.h&quot;
  98 #include &quot;RenderWidget.h&quot;
<span class="line-added">  99 #include &quot;ResizeObserver.h&quot;</span>
 100 #include &quot;ResourceUsageOverlay.h&quot;
 101 #include &quot;RuntimeEnabledFeatures.h&quot;
 102 #include &quot;SVGDocumentExtensions.h&quot;
 103 #include &quot;SchemeRegistry.h&quot;
 104 #include &quot;ScriptController.h&quot;
 105 #include &quot;ScriptedAnimationController.h&quot;
 106 #include &quot;ScrollLatchingState.h&quot;
 107 #include &quot;ScrollingCoordinator.h&quot;
 108 #include &quot;Settings.h&quot;
 109 #include &quot;SharedBuffer.h&quot;
 110 #include &quot;SocketProvider.h&quot;
 111 #include &quot;StorageArea.h&quot;
 112 #include &quot;StorageNamespace.h&quot;
 113 #include &quot;StorageNamespaceProvider.h&quot;
 114 #include &quot;StyleResolver.h&quot;
 115 #include &quot;StyleScope.h&quot;
 116 #include &quot;SubframeLoader.h&quot;
 117 #include &quot;TextIterator.h&quot;
 118 #include &quot;TextResourceDecoder.h&quot;
 119 #include &quot;UserContentProvider.h&quot;
 120 #include &quot;UserInputBridge.h&quot;
 121 #include &quot;ValidationMessageClient.h&quot;
 122 #include &quot;VisitedLinkState.h&quot;
 123 #include &quot;VisitedLinkStore.h&quot;
 124 #include &quot;VoidCallback.h&quot;

 125 #include &quot;WheelEventDeltaFilter.h&quot;
 126 #include &quot;Widget.h&quot;
 127 #include &lt;wtf/FileSystem.h&gt;
 128 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 129 #include &lt;wtf/StdLibExtras.h&gt;
<span class="line-added"> 130 #include &lt;wtf/SystemTracing.h&gt;</span>
 131 #include &lt;wtf/text/Base64.h&gt;
 132 #include &lt;wtf/text/StringHash.h&gt;
 133 
 134 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 135 #include &quot;HTMLVideoElement.h&quot;
 136 #include &quot;MediaPlaybackTarget.h&quot;
 137 #endif
 138 
 139 #if PLATFORM(MAC)
 140 #include &quot;ServicesOverlayController.h&quot;
 141 #endif
 142 
 143 #if ENABLE(MEDIA_SESSION)
 144 #include &quot;MediaSessionManager.h&quot;
 145 #endif
 146 
 147 #if ENABLE(INDEXED_DATABASE)
 148 #include &quot;IDBConnectionToServer.h&quot;
 149 #include &quot;InProcessIDBServer.h&quot;
 150 #endif
 151 
 152 #if ENABLE(DATA_INTERACTION)
 153 #include &quot;SelectionRect.h&quot;
 154 #endif
 155 
<span class="line-added"> 156 #if ENABLE(WEBGL)</span>
<span class="line-added"> 157 #include &quot;WebGLStateTracker.h&quot;</span>
<span class="line-added"> 158 #endif</span>
<span class="line-added"> 159 </span>
 160 namespace WebCore {
 161 
 162 static HashSet&lt;Page*&gt;&amp; allPages()
 163 {
 164     static NeverDestroyed&lt;HashSet&lt;Page*&gt;&gt; set;
 165     return set;
 166 }
 167 
 168 static unsigned nonUtilityPageCount { 0 };
 169 
 170 static inline bool isUtilityPageChromeClient(ChromeClient&amp; chromeClient)
 171 {
 172     return chromeClient.isEmptyChromeClient() || chromeClient.isSVGImageChromeClient();
 173 }
 174 
 175 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, pageCounter, (&quot;Page&quot;));
 176 
 177 void Page::forEachPage(const WTF::Function&lt;void(Page&amp;)&gt;&amp; function)
 178 {
 179     for (auto* page : allPages())
</pre>
<hr />
<pre>
 194     for (auto* page : allPages()) {
 195         for (Frame* frame = &amp;page-&gt;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
 196             frames.append(*frame);
 197         InspectorInstrumentation::networkStateChanged(*page);
 198     }
 199 
 200     auto&amp; eventName = isOnLine ? eventNames().onlineEvent : eventNames().offlineEvent;
 201     for (auto&amp; frame : frames) {
 202         if (!frame-&gt;document())
 203             continue;
 204         frame-&gt;document()-&gt;dispatchWindowEvent(Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::No));
 205     }
 206 }
 207 
 208 static constexpr OptionSet&lt;ActivityState::Flag&gt; pageInitialActivityState()
 209 {
 210     return { ActivityState::IsVisible, ActivityState::IsInWindow };
 211 }
 212 
 213 Page::Page(PageConfiguration&amp;&amp; pageConfiguration)
<span class="line-modified"> 214     : m_chrome(makeUnique&lt;Chrome&gt;(*this, *pageConfiguration.chromeClient))</span>
<span class="line-modified"> 215     , m_dragCaretController(makeUnique&lt;DragCaretController&gt;())</span>
 216 #if ENABLE(DRAG_SUPPORT)
<span class="line-modified"> 217     , m_dragController(makeUnique&lt;DragController&gt;(*this, *pageConfiguration.dragClient))</span>
 218 #endif
<span class="line-modified"> 219     , m_focusController(makeUnique&lt;FocusController&gt;(*this, pageInitialActivityState()))</span>
 220 #if ENABLE(CONTEXT_MENUS)
<span class="line-modified"> 221     , m_contextMenuController(makeUnique&lt;ContextMenuController&gt;(*this, *pageConfiguration.contextMenuClient))</span>
 222 #endif
<span class="line-modified"> 223     , m_userInputBridge(makeUnique&lt;UserInputBridge&gt;(*this))</span>
<span class="line-modified"> 224     , m_inspectorController(makeUnique&lt;InspectorController&gt;(*this, pageConfiguration.inspectorClient))</span>
 225 #if ENABLE(POINTER_EVENTS)
<span class="line-modified"> 226     , m_pointerCaptureController(makeUnique&lt;PointerCaptureController&gt;(*this))</span>
 227 #endif
 228 #if ENABLE(POINTER_LOCK)
<span class="line-modified"> 229     , m_pointerLockController(makeUnique&lt;PointerLockController&gt;(*this))</span>
 230 #endif
 231     , m_settings(Settings::create(this))
<span class="line-modified"> 232     , m_progress(makeUnique&lt;ProgressTracker&gt;(*pageConfiguration.progressTrackerClient))</span>
<span class="line-modified"> 233     , m_backForwardController(makeUnique&lt;BackForwardController&gt;(*this, WTFMove(pageConfiguration.backForwardClient)))</span>
 234     , m_mainFrame(Frame::create(this, nullptr, pageConfiguration.loaderClientForMainFrame))
 235     , m_editorClient(WTFMove(pageConfiguration.editorClient))
 236     , m_plugInClient(pageConfiguration.plugInClient)
 237     , m_validationMessageClient(WTFMove(pageConfiguration.validationMessageClient))
 238     , m_diagnosticLoggingClient(WTFMove(pageConfiguration.diagnosticLoggingClient))
 239     , m_performanceLoggingClient(WTFMove(pageConfiguration.performanceLoggingClient))
<span class="line-added"> 240 #if ENABLE(WEBGL)</span>
 241     , m_webGLStateTracker(WTFMove(pageConfiguration.webGLStateTracker))
<span class="line-added"> 242 #endif</span>
<span class="line-added"> 243 #if ENABLE(SPEECH_SYNTHESIS)</span>
<span class="line-added"> 244     , m_speechSynthesisClient(WTFMove(pageConfiguration.speechSynthesisClient))</span>
<span class="line-added"> 245 #endif</span>
 246     , m_libWebRTCProvider(WTFMove(pageConfiguration.libWebRTCProvider))
 247     , m_verticalScrollElasticity(ScrollElasticityAllowed)
 248     , m_horizontalScrollElasticity(ScrollElasticityAllowed)
 249     , m_domTimerAlignmentInterval(DOMTimer::defaultAlignmentInterval())
 250     , m_domTimerAlignmentIntervalIncreaseTimer(*this, &amp;Page::domTimerAlignmentIntervalIncreaseTimerFired)
 251     , m_activityState(pageInitialActivityState())
 252     , m_alternativeTextClient(pageConfiguration.alternativeTextClient)
<span class="line-modified"> 253     , m_consoleClient(makeUnique&lt;PageConsoleClient&gt;(*this))</span>
 254 #if ENABLE(REMOTE_INSPECTOR)
<span class="line-modified"> 255     , m_inspectorDebuggable(makeUnique&lt;PageDebuggable&gt;(*this))</span>
 256 #endif
 257     , m_socketProvider(WTFMove(pageConfiguration.socketProvider))
 258     , m_cookieJar(WTFMove(pageConfiguration.cookieJar))
 259     , m_applicationCacheStorage(*WTFMove(pageConfiguration.applicationCacheStorage))
 260     , m_cacheStorageProvider(WTFMove(pageConfiguration.cacheStorageProvider))
 261     , m_databaseProvider(*WTFMove(pageConfiguration.databaseProvider))
 262     , m_pluginInfoProvider(*WTFMove(pageConfiguration.pluginInfoProvider))
 263     , m_storageNamespaceProvider(*WTFMove(pageConfiguration.storageNamespaceProvider))
 264     , m_userContentProvider(*WTFMove(pageConfiguration.userContentProvider))
 265     , m_visitedLinkStore(*WTFMove(pageConfiguration.visitedLinkStore))



 266     , m_sessionID(PAL::SessionID::defaultSessionID())
 267 #if ENABLE(VIDEO)
 268     , m_playbackControlsManagerUpdateTimer(*this, &amp;Page::playbackControlsManagerUpdateTimerFired)
 269 #endif
 270     , m_isUtilityPage(isUtilityPageChromeClient(chrome().client()))
<span class="line-modified"> 271     , m_performanceMonitor(isUtilityPage() ? nullptr : makeUnique&lt;PerformanceMonitor&gt;(*this))</span>
<span class="line-modified"> 272     , m_lowPowerModeNotifier(makeUnique&lt;LowPowerModeNotifier&gt;([this](bool isLowPowerModeEnabled) { handleLowModePowerChange(isLowPowerModeEnabled); }))</span>
<span class="line-modified"> 273     , m_performanceLogging(makeUnique&lt;PerformanceLogging&gt;(*this))</span>
 274 #if PLATFORM(MAC) &amp;&amp; (ENABLE(SERVICE_CONTROLS) || ENABLE(TELEPHONE_NUMBER_DETECTION))
<span class="line-modified"> 275     , m_servicesOverlayController(makeUnique&lt;ServicesOverlayController&gt;(*this))</span>
 276 #endif
 277     , m_recentWheelEventDeltaFilter(WheelEventDeltaFilter::create())
<span class="line-modified"> 278     , m_pageOverlayController(makeUnique&lt;PageOverlayController&gt;(*this))</span>
 279 #if ENABLE(APPLE_PAY)
<span class="line-modified"> 280     , m_paymentCoordinator(makeUnique&lt;PaymentCoordinator&gt;(*pageConfiguration.paymentCoordinatorClient))</span>
 281 #endif
 282 #if ENABLE(WEB_AUTHN)
 283     , m_authenticatorCoordinator(makeUniqueRef&lt;AuthenticatorCoordinator&gt;(WTFMove(pageConfiguration.authenticatorCoordinatorClient)))
 284 #endif
 285 #if ENABLE(APPLICATION_MANIFEST)
 286     , m_applicationManifest(pageConfiguration.applicationManifest)
 287 #endif
 288 {
 289     updateTimerThrottlingState();
 290 
 291     m_pluginInfoProvider-&gt;addPage(*this);

 292     m_userContentProvider-&gt;addPage(*this);
 293     m_visitedLinkStore-&gt;addPage(*this);
 294 
 295     static bool addedListener;
 296     if (!addedListener) {
 297         platformStrategies()-&gt;loaderStrategy()-&gt;addOnlineStateChangeListener(&amp;networkStateChanged);
 298         addedListener = true;
 299     }
 300 
 301     ASSERT(!allPages().contains(this));
 302     allPages().add(this);
 303 
 304     if (!isUtilityPage()) {
 305         ++nonUtilityPageCount;
 306         MemoryPressureHandler::setPageCount(nonUtilityPageCount);
 307     }
 308 
 309 #ifndef NDEBUG
 310     pageCounter.increment();
 311 #endif
</pre>
<hr />
<pre>
 349         frame-&gt;detachFromPage();
 350     }
 351 
 352     if (m_plugInClient)
 353         m_plugInClient-&gt;pageDestroyed();
 354     if (m_alternativeTextClient)
 355         m_alternativeTextClient-&gt;pageDestroyed();
 356 
 357     if (m_scrollingCoordinator)
 358         m_scrollingCoordinator-&gt;pageDestroyed();
 359 
 360     backForward().close();
 361     if (!isUtilityPage())
 362         PageCache::singleton().removeAllItemsForPage(*this);
 363 
 364 #ifndef NDEBUG
 365     pageCounter.decrement();
 366 #endif
 367 
 368     m_pluginInfoProvider-&gt;removePage(*this);

 369     m_userContentProvider-&gt;removePage(*this);
 370     m_visitedLinkStore-&gt;removePage(*this);
 371 }
 372 
 373 void Page::clearPreviousItemFromAllPages(HistoryItem* item)
 374 {
 375     for (auto* page : allPages()) {
 376         auto&amp; controller = page-&gt;mainFrame().loader().history();
 377         if (item == controller.previousItem()) {
 378             controller.clearPreviousItem();
 379             return;
 380         }
 381     }
 382 }
 383 
 384 uint64_t Page::renderTreeSize() const
 385 {
 386     uint64_t total = 0;
 387     for (const Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
 388         if (!frame-&gt;document() || !frame-&gt;document()-&gt;renderView())
 389             continue;
 390         total += frame-&gt;document()-&gt;renderView()-&gt;rendererCount();
 391     }
 392     return total;
 393 }
 394 
 395 OptionSet&lt;DisabledAdaptations&gt; Page::disabledAdaptations() const
 396 {
 397     if (mainFrame().document())
 398         return mainFrame().document()-&gt;disabledAdaptations();
 399 
 400     return { };
 401 }
 402 
 403 ViewportArguments Page::viewportArguments() const
 404 {
 405     return mainFrame().document() ? mainFrame().document()-&gt;viewportArguments() : ViewportArguments();
 406 }
 407 
<span class="line-added"> 408 void Page::setOverrideViewportArguments(const Optional&lt;ViewportArguments&gt;&amp; viewportArguments)</span>
<span class="line-added"> 409 {</span>
<span class="line-added"> 410     if (viewportArguments == m_overrideViewportArguments)</span>
<span class="line-added"> 411         return;</span>
<span class="line-added"> 412 </span>
<span class="line-added"> 413     m_overrideViewportArguments = viewportArguments;</span>
<span class="line-added"> 414     if (auto* document = mainFrame().document())</span>
<span class="line-added"> 415         document-&gt;updateViewportArguments();</span>
<span class="line-added"> 416 }</span>
<span class="line-added"> 417 </span>
 418 ScrollingCoordinator* Page::scrollingCoordinator()
 419 {
 420     if (!m_scrollingCoordinator &amp;&amp; m_settings-&gt;scrollingCoordinatorEnabled()) {
 421         m_scrollingCoordinator = chrome().client().createScrollingCoordinator(*this);
 422         if (!m_scrollingCoordinator)
 423             m_scrollingCoordinator = ScrollingCoordinator::create(this);
 424     }
 425 
 426     return m_scrollingCoordinator.get();
 427 }
 428 
 429 String Page::scrollingStateTreeAsText()
 430 {
 431     if (Document* document = m_mainFrame-&gt;document())
 432         document-&gt;updateLayout();
 433 
 434     if (ScrollingCoordinator* scrollingCoordinator = this-&gt;scrollingCoordinator())
 435         return scrollingCoordinator-&gt;scrollingStateTreeAsText();
 436 
 437     return String();
</pre>
<hr />
<pre>
 542     }
 543 
 544     if (name.isEmpty())
 545         m_group = m_singlePageGroup.get();
 546     else {
 547         m_singlePageGroup = nullptr;
 548         m_group = PageGroup::pageGroup(name);
 549         m_group-&gt;addPage(*this);
 550     }
 551 }
 552 
 553 const String&amp; Page::groupName() const
 554 {
 555     return m_group ? m_group-&gt;name() : nullAtom().string();
 556 }
 557 
 558 void Page::initGroup()
 559 {
 560     ASSERT(!m_singlePageGroup);
 561     ASSERT(!m_group);
<span class="line-modified"> 562     m_singlePageGroup = makeUnique&lt;PageGroup&gt;(*this);</span>
 563     m_group = m_singlePageGroup.get();
 564 }
 565 
 566 void Page::updateStyleAfterChangeInEnvironment()
 567 {
 568     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
 569         // If a change in the global environment has occurred, we need to
 570         // make sure all the properties a recomputed, therefore we invalidate
 571         // the properties cache.
 572         auto* document = frame-&gt;document();
 573         if (!document)
 574             continue;
 575 
 576         if (StyleResolver* styleResolver = document-&gt;styleScope().resolverIfExists())
 577             styleResolver-&gt;invalidateMatchedPropertiesCache();
 578         document-&gt;scheduleFullStyleRebuild();
 579         document-&gt;styleScope().didChangeStyleSheetEnvironment();
 580     }
 581 }
 582 
</pre>
<hr />
<pre>
1075 }
1076 
1077 void Page::setDeviceScaleFactor(float scaleFactor)
1078 {
1079     ASSERT(scaleFactor &gt; 0);
1080     if (scaleFactor &lt;= 0)
1081         return;
1082 
1083     if (m_deviceScaleFactor == scaleFactor)
1084         return;
1085 
1086     m_deviceScaleFactor = scaleFactor;
1087     setNeedsRecalcStyleInAllFrames();
1088 
1089     mainFrame().deviceOrPageScaleFactorChanged();
1090     PageCache::singleton().markPagesForDeviceOrPageScaleChanged(*this);
1091 
1092     pageOverlayController().didChangeDeviceScaleFactor();
1093 }
1094 
<span class="line-added">1095 void Page::setInitialScale(float initialScale)</span>
<span class="line-added">1096 {</span>
<span class="line-added">1097     m_initialScale = initialScale;</span>
<span class="line-added">1098 }</span>
<span class="line-added">1099 </span>
1100 void Page::setUserInterfaceLayoutDirection(UserInterfaceLayoutDirection userInterfaceLayoutDirection)
1101 {
1102     if (m_userInterfaceLayoutDirection == userInterfaceLayoutDirection)
1103         return;
1104 
1105     m_userInterfaceLayoutDirection = userInterfaceLayoutDirection;
1106 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1107     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1108         if (!frame-&gt;document())
1109             continue;
1110         frame-&gt;document()-&gt;userInterfaceLayoutDirectionChanged();
1111     }
1112 #endif
1113 }
1114 
1115 #if ENABLE(VIDEO)
1116 void Page::updateMediaElementRateChangeRestrictions()
1117 {
1118     for (auto* mediaElement : HTMLMediaElement::allMediaElements())
1119         mediaElement-&gt;updateRateChangeRestrictions();
1120 }
1121 #endif
1122 
1123 void Page::didStartProvisionalLoad()
1124 {
1125     if (m_performanceMonitor)
1126         m_performanceMonitor-&gt;didStartProvisionalLoad();
1127 }
1128 
1129 void Page::didFinishLoad()
1130 {
1131     resetRelevantPaintedObjectCounter();
1132 
1133     if (m_performanceMonitor)
1134         m_performanceMonitor-&gt;didFinishLoad();
1135 }
1136 







1137 bool Page::isOnlyNonUtilityPage() const
1138 {
1139     return !isUtilityPage() &amp;&amp; nonUtilityPageCount == 1;
1140 }
1141 
1142 bool Page::isLowPowerModeEnabled() const
1143 {
1144     if (m_lowPowerModeEnabledOverrideForTesting)
1145         return m_lowPowerModeEnabledOverrideForTesting.value();
1146 
1147     return m_lowPowerModeNotifier-&gt;isLowPowerModeEnabled();
1148 }
1149 
1150 void Page::setLowPowerModeEnabledOverrideForTesting(Optional&lt;bool&gt; isEnabled)
1151 {
1152     m_lowPowerModeEnabledOverrideForTesting = isEnabled;
1153     handleLowModePowerChange(m_lowPowerModeEnabledOverrideForTesting.valueOr(false));
1154 }
1155 
1156 void Page::setTopContentInset(float contentInset)
</pre>
<hr />
<pre>
1258 {
1259     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1260         if (FrameView* frameView = frame-&gt;view())
1261             frameView-&gt;setIsInWindow(isInWindow);
1262     }
1263 
1264     if (isInWindow)
1265         resumeAnimatingImages();
1266 }
1267 
1268 void Page::addActivityStateChangeObserver(ActivityStateChangeObserver&amp; observer)
1269 {
1270     m_activityStateChangeObservers.add(&amp;observer);
1271 }
1272 
1273 void Page::removeActivityStateChangeObserver(ActivityStateChangeObserver&amp; observer)
1274 {
1275     m_activityStateChangeObservers.remove(&amp;observer);
1276 }
1277 
<span class="line-modified">1278 void Page::layoutIfNeeded()</span>

1279 {
<span class="line-modified">1280     if (FrameView* view = m_mainFrame-&gt;view())</span>
<span class="line-modified">1281         view-&gt;updateLayoutAndStyleIfNeededRecursive();</span>
1282 }
1283 
<span class="line-modified">1284 void Page::updateRendering()</span>
1285 {
<span class="line-modified">1286     // This function is not reentrant, e.g. a rAF callback may force repaint.</span>
<span class="line-modified">1287     if (m_inUpdateRendering) {</span>
<span class="line-modified">1288         layoutIfNeeded();</span>
<span class="line-modified">1289         return;</span>
1290     }


1291 
<span class="line-modified">1292     TraceScope traceScope(RenderingUpdateStart, RenderingUpdateEnd);</span>
<span class="line-modified">1293 </span>
<span class="line-modified">1294     SetForScope&lt;bool&gt; change(m_inUpdateRendering, true);</span>
<span class="line-modified">1295 </span>
<span class="line-modified">1296     Vector&lt;RefPtr&lt;Document&gt;&gt; documents;</span>
<span class="line-modified">1297 </span>
<span class="line-modified">1298     // The requestAnimationFrame callbacks may change the frame hierarchy of the page</span>
<span class="line-added">1299     forEachDocument([&amp;documents] (Document&amp; document) {</span>
<span class="line-added">1300         documents.append(&amp;document);</span>
<span class="line-added">1301     });</span>
<span class="line-added">1302 </span>
<span class="line-added">1303     for (auto&amp; document : documents) {</span>
<span class="line-added">1304         DOMHighResTimeStamp timestamp = document-&gt;domWindow()-&gt;nowTimestamp();</span>
<span class="line-added">1305         document-&gt;updateAnimationsAndSendEvents(timestamp);</span>
<span class="line-added">1306         document-&gt;serviceRequestAnimationFrameCallbacks(timestamp);</span>
<span class="line-added">1307     }</span>
<span class="line-added">1308 </span>
<span class="line-added">1309     layoutIfNeeded();</span>
<span class="line-added">1310 </span>
<span class="line-added">1311 #if ENABLE(INTERSECTION_OBSERVER)</span>
<span class="line-added">1312     for (auto&amp; document : documents)</span>
<span class="line-added">1313         document-&gt;updateIntersectionObservations();</span>
1314 #endif
<span class="line-added">1315 #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added">1316     for (auto&amp; document : documents)</span>
<span class="line-added">1317         document-&gt;updateResizeObservations(*this);</span>
<span class="line-added">1318 #endif</span>
<span class="line-added">1319 </span>
<span class="line-added">1320     layoutIfNeeded();</span>
<span class="line-added">1321 }</span>
1322 
1323 void Page::suspendScriptedAnimations()
1324 {
1325     m_scriptedAnimationsSuspended = true;
1326     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1327         if (frame-&gt;document())
1328             frame-&gt;document()-&gt;suspendScriptedAnimationControllerCallbacks();
1329     }
1330 }
1331 
1332 void Page::resumeScriptedAnimations()
1333 {
1334     m_scriptedAnimationsSuspended = false;
1335     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1336         if (frame-&gt;document())
1337             frame-&gt;document()-&gt;resumeScriptedAnimationControllerCallbacks();
1338     }
1339 }
1340 
1341 enum class ThrottlingReasonOperation { Add, Remove };
</pre>
<hr />
<pre>
1491 
1492     m_debugger = debugger;
1493 
1494     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext())
1495         frame-&gt;windowProxy().attachDebugger(m_debugger);
1496 }
1497 
1498 StorageNamespace* Page::sessionStorage(bool optionalCreate)
1499 {
1500     if (!m_sessionStorage &amp;&amp; optionalCreate)
1501         m_sessionStorage = m_storageNamespaceProvider-&gt;createSessionStorageNamespace(*this, m_settings-&gt;sessionStorageQuota());
1502 
1503     return m_sessionStorage.get();
1504 }
1505 
1506 void Page::setSessionStorage(RefPtr&lt;StorageNamespace&gt;&amp;&amp; newStorage)
1507 {
1508     m_sessionStorage = WTFMove(newStorage);
1509 }
1510 













1511 bool Page::hasCustomHTMLTokenizerTimeDelay() const
1512 {
1513     return m_settings-&gt;maxParseDuration() != -1;
1514 }
1515 
1516 double Page::customHTMLTokenizerTimeDelay() const
1517 {
1518     ASSERT(m_settings-&gt;maxParseDuration() != -1);
1519     return m_settings-&gt;maxParseDuration();
1520 }
1521 
1522 void Page::setMemoryCacheClientCallsEnabled(bool enabled)
1523 {
1524     if (m_areMemoryCacheClientCallsEnabled == enabled)
1525         return;
1526 
1527     m_areMemoryCacheClientCallsEnabled = enabled;
1528     if (!enabled)
1529         return;
1530 
</pre>
<hr />
<pre>
1768 
1769     m_mediaPlaybackIsSuspended = true;
1770 #endif
1771 }
1772 
1773 void Page::resumeAllMediaPlayback()
1774 {
1775 #if ENABLE(VIDEO)
1776     ASSERT(m_mediaPlaybackIsSuspended);
1777     if (!m_mediaPlaybackIsSuspended)
1778         return;
1779     m_mediaPlaybackIsSuspended = false;
1780 
1781     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1782         if (auto* document = frame-&gt;document())
1783             document-&gt;resumeAllMediaPlayback();
1784     }
1785 #endif
1786 }
1787 
<span class="line-added">1788 void Page::suspendAllMediaBuffering()</span>
<span class="line-added">1789 {</span>
<span class="line-added">1790 #if ENABLE(VIDEO)</span>
<span class="line-added">1791     ASSERT(!m_mediaBufferingIsSuspended);</span>
<span class="line-added">1792     if (m_mediaBufferingIsSuspended)</span>
<span class="line-added">1793         return;</span>
<span class="line-added">1794     m_mediaBufferingIsSuspended = true;</span>
<span class="line-added">1795 </span>
<span class="line-added">1796     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-added">1797         if (auto* document = frame-&gt;document())</span>
<span class="line-added">1798             document-&gt;suspendAllMediaBuffering();</span>
<span class="line-added">1799     }</span>
<span class="line-added">1800 #endif</span>
<span class="line-added">1801 }</span>
<span class="line-added">1802 </span>
<span class="line-added">1803 void Page::resumeAllMediaBuffering()</span>
<span class="line-added">1804 {</span>
<span class="line-added">1805 #if ENABLE(VIDEO)</span>
<span class="line-added">1806     if (!m_mediaBufferingIsSuspended)</span>
<span class="line-added">1807         return;</span>
<span class="line-added">1808     m_mediaBufferingIsSuspended = false;</span>
<span class="line-added">1809 </span>
<span class="line-added">1810     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-added">1811         if (auto* document = frame-&gt;document())</span>
<span class="line-added">1812             document-&gt;resumeAllMediaBuffering();</span>
<span class="line-added">1813     }</span>
<span class="line-added">1814 #endif</span>
<span class="line-added">1815 }</span>
<span class="line-added">1816 </span>
1817 #if ENABLE(MEDIA_SESSION)
1818 void Page::handleMediaEvent(MediaEventType eventType)
1819 {
1820     switch (eventType) {
1821     case MediaEventType::PlayPause:
1822         MediaSessionManager::singleton().togglePlayback();
1823         break;
1824     case MediaEventType::TrackNext:
1825         MediaSessionManager::singleton().skipToNextTrack();
1826         break;
1827     case MediaEventType::TrackPrevious:
1828         MediaSessionManager::singleton().skipToPreviousTrack();
1829         break;
1830     }
1831 }
1832 
1833 void Page::setVolumeOfMediaElement(double volume, uint64_t elementID)
1834 {
1835     if (HTMLMediaElement* element = HTMLMediaElement::elementWithID(elementID))
1836         element-&gt;setVolume(volume, ASSERT_NO_EXCEPTION);
</pre>
<hr />
<pre>
2166     m_topRelevantPaintedRegion = Region();
2167     m_bottomRelevantPaintedRegion = Region();
2168     m_relevantUnpaintedRegion = Region();
2169 }
2170 
2171 static LayoutRect relevantViewRect(RenderView* view)
2172 {
2173     LayoutRect viewRect = view-&gt;viewRect();
2174 
2175     float relevantViewRectWidth = 980;
2176 #if PLATFORM(WATCHOS)
2177     // FIXME(186051): Consider limiting the relevant rect width to the view width everywhere.
2178     relevantViewRectWidth = std::min&lt;float&gt;(viewRect.width().toFloat(), relevantViewRectWidth);
2179 #endif
2180 
2181     // DidHitRelevantRepaintedObjectsAreaThreshold is a LayoutMilestone intended to indicate that
2182     // a certain relevant amount of content has been drawn to the screen. This is the rect that
2183     // has been determined to be relevant in the context of this goal. We may choose to tweak
2184     // the rect over time, much like we may choose to tweak gMinimumPaintedAreaRatio and
2185     // gMaximumUnpaintedAreaRatio. But this seems to work well right now.
<span class="line-modified">2186     LayoutRect relevantViewRect { 0, 0, LayoutUnit(relevantViewRectWidth), 1300 };</span>
2187     // If the viewRect is wider than the relevantViewRect, center the relevantViewRect.
2188     if (viewRect.width() &gt; relevantViewRect.width())
2189         relevantViewRect.setX((viewRect.width() - relevantViewRect.width()) / 2);
2190 
2191     return relevantViewRect;
2192 }
2193 
2194 void Page::addRelevantRepaintedObject(RenderObject* object, const LayoutRect&amp; objectPaintRect)
2195 {
2196     if (!isCountingRelevantRepaintedObjects())
2197         return;
2198 
2199     // Objects inside sub-frames are not considered to be relevant.
2200     if (&amp;object-&gt;frame() != &amp;mainFrame())
2201         return;
2202 
2203     LayoutRect relevantRect = relevantViewRect(&amp;object-&gt;view());
2204 
2205     // The objects are only relevant if they are being painted within the viewRect().
2206     if (!objectPaintRect.intersects(snappedIntRect(relevantRect)))
</pre>
<hr />
<pre>
2402     case FrameLoadType::Reload:
2403         navigationDescription = &quot;reload&quot;_s;
2404         break;
2405     case FrameLoadType::Same:
2406         navigationDescription = &quot;same&quot;_s;
2407         break;
2408     case FrameLoadType::ReloadFromOrigin:
2409         navigationDescription = &quot;reloadFromOrigin&quot;_s;
2410         break;
2411     case FrameLoadType::ReloadExpiredOnly:
2412         navigationDescription = &quot;reloadRevalidatingExpired&quot;_s;
2413         break;
2414     case FrameLoadType::Replace:
2415     case FrameLoadType::RedirectWithLockedBackForwardList:
2416         // Not logging those for now.
2417         return;
2418     }
2419     diagnosticLoggingClient().logDiagnosticMessage(DiagnosticLoggingKeys::navigationKey(), navigationDescription, ShouldSample::No);
2420 
2421     if (!navigation.domain.isEmpty())
<span class="line-modified">2422         diagnosticLoggingClient().logDiagnosticMessageWithEnhancedPrivacy(DiagnosticLoggingKeys::domainVisitedKey(), navigation.domain.string(), ShouldSample::Yes);</span>
2423 }
2424 
2425 void Page::mainFrameLoadStarted(const URL&amp; destinationURL, FrameLoadType type)
2426 {
<span class="line-modified">2427     Navigation navigation = { RegistrableDomain { destinationURL }, type };</span>







2428 
2429     // To avoid being too verbose, we only log navigations if the page is or becomes visible. This avoids logging non-user observable loads.
2430     if (!isVisible()) {
2431         m_navigationToLogWhenVisible = navigation;
2432         return;
2433     }
2434 
2435     m_navigationToLogWhenVisible = WTF::nullopt;
2436     logNavigation(navigation);
2437 }
2438 
2439 PluginInfoProvider&amp; Page::pluginInfoProvider()
2440 {
2441     return m_pluginInfoProvider;
2442 }
2443 
2444 UserContentProvider&amp; Page::userContentProvider()
2445 {
2446     return m_userContentProvider;
2447 }
2448 
2449 void Page::setUserContentProvider(Ref&lt;UserContentProvider&gt;&amp;&amp; userContentProvider)
2450 {
2451     m_userContentProvider-&gt;removePage(*this);
2452     m_userContentProvider = WTFMove(userContentProvider);
2453     m_userContentProvider-&gt;addPage(*this);
2454 
2455     invalidateInjectedStyleSheetCacheInAllFrames();
2456 }
2457 









2458 VisitedLinkStore&amp; Page::visitedLinkStore()
2459 {
2460     return m_visitedLinkStore;
2461 }
2462 
2463 void Page::setVisitedLinkStore(Ref&lt;VisitedLinkStore&gt;&amp;&amp; visitedLinkStore)
2464 {
2465     m_visitedLinkStore-&gt;removePage(*this);
2466     m_visitedLinkStore = WTFMove(visitedLinkStore);
2467     m_visitedLinkStore-&gt;addPage(*this);
2468 
2469     invalidateStylesForAllLinks();
2470 }
2471 
2472 PAL::SessionID Page::sessionID() const
2473 {
2474     return m_sessionID;
2475 }
2476 
2477 void Page::setSessionID(PAL::SessionID sessionID)
2478 {
2479     ASSERT(sessionID.isValid());
2480 
2481 #if ENABLE(INDEXED_DATABASE)
2482     if (sessionID != m_sessionID)
2483         m_idbConnectionToServer = nullptr;
2484 #endif
2485 
<span class="line-added">2486     if (sessionID != m_sessionID &amp;&amp; m_sessionStorage)</span>
<span class="line-added">2487         m_sessionStorage-&gt;setSessionIDForTesting(sessionID);</span>
<span class="line-added">2488 </span>
2489     bool privateBrowsingStateChanged = (sessionID.isEphemeral() != m_sessionID.isEphemeral());
2490 
2491     m_sessionID = sessionID;
2492 
2493     if (!privateBrowsingStateChanged)
2494         return;
2495 
2496     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2497         if (!frame-&gt;document())
2498             continue;
<span class="line-modified">2499         frame-&gt;document()-&gt;privateBrowsingStateDidChange(m_sessionID);</span>
2500     }
2501 
2502     // Collect the PluginViews in to a vector to ensure that action the plug-in takes
2503     // from below privateBrowsingStateChanged does not affect their lifetime.
2504 
2505     for (auto&amp; view : pluginViews())
2506         view-&gt;privateBrowsingStateChanged(sessionID.isEphemeral());
2507 }
2508 
2509 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2510 void Page::addPlaybackTargetPickerClient(uint64_t contextId)
2511 {
2512     chrome().client().addPlaybackTargetPickerClient(contextId);
2513 }
2514 
2515 void Page::removePlaybackTargetPickerClient(uint64_t contextId)
2516 {
2517     chrome().client().removePlaybackTargetPickerClient(contextId);
2518 }
2519 
</pre>
<hr />
<pre>
2616 IDBClient::IDBConnectionToServer* Page::optionalIDBConnection()
2617 {
2618     return m_idbConnectionToServer.get();
2619 }
2620 
2621 void Page::clearIDBConnection()
2622 {
2623     m_idbConnectionToServer = nullptr;
2624 }
2625 #endif
2626 
2627 #if ENABLE(RESOURCE_USAGE)
2628 void Page::setResourceUsageOverlayVisible(bool visible)
2629 {
2630     if (!visible) {
2631         m_resourceUsageOverlay = nullptr;
2632         return;
2633     }
2634 
2635     if (!m_resourceUsageOverlay &amp;&amp; m_settings-&gt;acceleratedCompositingEnabled())
<span class="line-modified">2636         m_resourceUsageOverlay = makeUnique&lt;ResourceUsageOverlay&gt;(*this);</span>
2637 }
2638 #endif
2639 
2640 bool Page::isAlwaysOnLoggingAllowed() const
2641 {
2642     return m_sessionID.isAlwaysOnLoggingAllowed();
2643 }
2644 
2645 String Page::captionUserPreferencesStyleSheet()
2646 {
2647     return m_captionUserPreferencesStyleSheet;
2648 }
2649 
2650 void Page::setCaptionUserPreferencesStyleSheet(const String&amp; styleSheet)
2651 {
2652     if (m_captionUserPreferencesStyleSheet == styleSheet)
2653         return;
2654 
2655     m_captionUserPreferencesStyleSheet = styleSheet;
2656 }
</pre>
<hr />
<pre>
2661         if (auto* document = frame-&gt;document()) {
2662             document-&gt;styleScope().evaluateMediaQueriesForAccessibilitySettingsChange();
2663             document-&gt;evaluateMediaQueryList();
2664         }
2665     }
2666 }
2667 
2668 void Page::appearanceDidChange()
2669 {
2670     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2671         auto* document = frame-&gt;document();
2672         if (!document)
2673             continue;
2674 
2675         document-&gt;styleScope().didChangeStyleSheetEnvironment();
2676         document-&gt;styleScope().evaluateMediaQueriesForAppearanceChange();
2677         document-&gt;evaluateMediaQueryList();
2678     }
2679 }
2680 













2681 void Page::setUnobscuredSafeAreaInsets(const FloatBoxExtent&amp; insets)
2682 {
2683     if (m_unobscuredSafeAreaInsets == insets)
2684         return;
2685 
2686     m_unobscuredSafeAreaInsets = insets;
2687 
2688     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2689         if (!frame-&gt;document())
2690             continue;
2691         frame-&gt;document()-&gt;constantProperties().didChangeSafeAreaInsets();
2692     }
2693 }
2694 
2695 void Page::setUseSystemAppearance(bool value)
2696 {
2697     if (m_useSystemAppearance == value)
2698         return;
2699 
2700     m_useSystemAppearance = value;
2701 
2702     appearanceDidChange();
2703 
2704     for (auto* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2705         auto* document = frame-&gt;document();
2706         if (!document)
2707             continue;
2708 
2709         // System apperance change may affect stylesheet parsing. We need to reparse.
2710         document-&gt;extensionStyleSheets().clearPageUserSheet();
2711         document-&gt;extensionStyleSheets().invalidateInjectedStyleSheetCache();
2712     }
2713 }
2714 
<span class="line-modified">2715 void Page::effectiveAppearanceDidChange(bool useDarkAppearance, bool useElevatedUserInterfaceLevel)</span>
2716 {
<span class="line-modified">2717 #if ENABLE(DARK_MODE_CSS)</span>
<span class="line-modified">2718     if (m_useDarkAppearance == useDarkAppearance &amp;&amp; m_useElevatedUserInterfaceLevel == useElevatedUserInterfaceLevel)</span>
2719         return;
2720 
<span class="line-modified">2721     m_useDarkAppearance = useDarkAppearance;</span>
<span class="line-added">2722     m_useElevatedUserInterfaceLevel = useElevatedUserInterfaceLevel;</span>
2723 
<span class="line-modified">2724     InspectorInstrumentation::defaultAppearanceDidChange(*this, useDarkAppearance);</span>
2725 
2726     appearanceDidChange();
2727 #else
<span class="line-modified">2728     UNUSED_PARAM(useDarkAppearance);</span>
<span class="line-added">2729 </span>
<span class="line-added">2730     if (m_useElevatedUserInterfaceLevel == useElevatedUserInterfaceLevel)</span>
<span class="line-added">2731         return;</span>
<span class="line-added">2732 </span>
<span class="line-added">2733     m_useElevatedUserInterfaceLevel = useElevatedUserInterfaceLevel;</span>
<span class="line-added">2734 </span>
<span class="line-added">2735     appearanceDidChange();</span>
2736 #endif
2737 }
2738 
2739 bool Page::useDarkAppearance() const
2740 {
<span class="line-modified">2741 #if ENABLE(DARK_MODE_CSS)</span>
2742     FrameView* view = mainFrame().view();
2743     if (!view || !equalLettersIgnoringASCIICase(view-&gt;mediaType(), &quot;screen&quot;))
2744         return false;
2745     if (m_useDarkAppearanceOverride)
2746         return m_useDarkAppearanceOverride.value();
2747     return m_useDarkAppearance;
2748 #else
2749     return false;
2750 #endif
2751 }
2752 
2753 void Page::setUseDarkAppearanceOverride(Optional&lt;bool&gt; valueOverride)
2754 {
2755 #if HAVE(OS_DARK_MODE_SUPPORT)
2756     if (valueOverride == m_useDarkAppearanceOverride)
2757         return;
2758 
2759     m_useDarkAppearanceOverride = valueOverride;
2760 
2761     appearanceDidChange();
</pre>
<hr />
<pre>
2778 }
2779 
2780 void Page::setFullscreenAutoHideDuration(Seconds duration)
2781 {
2782     if (duration == m_fullscreenAutoHideDuration)
2783         return;
2784     m_fullscreenAutoHideDuration = duration;
2785     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2786         if (!frame-&gt;document())
2787             continue;
2788         frame-&gt;document()-&gt;constantProperties().setFullscreenAutoHideDuration(duration);
2789     }
2790 }
2791 
2792 void Page::setFullscreenControlsHidden(bool hidden)
2793 {
2794 #if ENABLE(FULLSCREEN_API)
2795     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2796         if (!frame-&gt;document())
2797             continue;
<span class="line-modified">2798         frame-&gt;document()-&gt;fullscreenManager().setFullscreenControlsHidden(hidden);</span>
2799     }
2800 #else
2801     UNUSED_PARAM(hidden);
2802 #endif
2803 }
2804 
2805 #if ENABLE(DATA_INTERACTION)
2806 
2807 bool Page::hasSelectionAtPosition(const FloatPoint&amp; position) const
2808 {
2809     auto currentSelection = m_mainFrame-&gt;selection().selection();
2810     if (!currentSelection.isRange())
2811         return false;
2812 
2813     if (auto selectedRange = currentSelection.toNormalizedRange()) {
2814         Vector&lt;SelectionRect&gt; selectionRects;
2815         selectedRange-&gt;collectSelectionRects(selectionRects);
2816         for (auto selectionRect : selectionRects) {
2817             if (FloatRect(selectionRect.rect()).contains(position))
2818                 return true;
</pre>
<hr />
<pre>
2828 {
2829     m_shouldEnableICECandidateFilteringByDefault = false;
2830 #if ENABLE(WEB_RTC)
2831     m_rtcController.disableICECandidateFilteringForAllOrigins();
2832 #endif
2833 }
2834 
2835 void Page::enableICECandidateFiltering()
2836 {
2837     m_shouldEnableICECandidateFilteringByDefault = true;
2838 #if ENABLE(WEB_RTC)
2839     m_rtcController.enableICECandidateFiltering();
2840 #endif
2841 }
2842 
2843 void Page::didChangeMainDocument()
2844 {
2845 #if ENABLE(WEB_RTC)
2846     m_rtcController.reset(m_shouldEnableICECandidateFilteringByDefault);
2847 #endif
<span class="line-added">2848 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">2849     m_pointerCaptureController-&gt;reset();</span>
<span class="line-added">2850 #endif</span>
<span class="line-added">2851 }</span>
<span class="line-added">2852 </span>
<span class="line-added">2853 RenderingUpdateScheduler&amp; Page::renderingUpdateScheduler()</span>
<span class="line-added">2854 {</span>
<span class="line-added">2855     if (!m_renderingUpdateScheduler)</span>
<span class="line-added">2856         m_renderingUpdateScheduler = RenderingUpdateScheduler::create(*this);</span>
<span class="line-added">2857     return *m_renderingUpdateScheduler;</span>
2858 }
2859 
2860 void Page::forEachDocument(const Function&lt;void(Document&amp;)&gt;&amp; functor)
2861 {
2862     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2863         if (!frame-&gt;document())
2864             continue;
2865 
2866         functor(*frame-&gt;document());
2867     }
2868 }
2869 
2870 void Page::applicationWillResignActive()
2871 {
2872     forEachDocument([&amp;] (Document&amp; document) {
2873         document.forEachApplicationStateChangeListener([&amp;] (ApplicationStateChangeListener&amp; listener) {
2874             listener.applicationWillResignActive();
2875         });
2876     });
2877 }
</pre>
<hr />
<pre>
2917 void Page::popLatchingState()
2918 {
2919     m_latchingState.removeLast();
2920 }
2921 
2922 void Page::removeLatchingStateForTarget(Element&amp; targetNode)
2923 {
2924     if (m_latchingState.isEmpty())
2925         return;
2926 
2927     m_latchingState.removeAllMatching([&amp;targetNode] (ScrollLatchingState&amp; state) {
2928         auto* wheelElement = state.wheelEventElement();
2929         if (!wheelElement)
2930             return false;
2931 
2932         return targetNode.isEqualNode(wheelElement);
2933     });
2934 }
2935 #endif // PLATFORM(MAC)
2936 
<span class="line-added">2937 static void dispatchPrintEvent(Frame&amp; mainFrame, const AtomString&amp; eventType)</span>
<span class="line-added">2938 {</span>
<span class="line-added">2939     Vector&lt;Ref&lt;Frame&gt;&gt; frames;</span>
<span class="line-added">2940     for (auto* frame = &amp;mainFrame; frame; frame = frame-&gt;tree().traverseNext())</span>
<span class="line-added">2941         frames.append(*frame);</span>
<span class="line-added">2942 </span>
<span class="line-added">2943     for (auto&amp; frame : frames) {</span>
<span class="line-added">2944         if (auto* window = frame-&gt;window())</span>
<span class="line-added">2945             window-&gt;dispatchEvent(Event::create(eventType, Event::CanBubble::No, Event::IsCancelable::No), window-&gt;document());</span>
<span class="line-added">2946     }</span>
<span class="line-added">2947 }</span>
<span class="line-added">2948 </span>
<span class="line-added">2949 void Page::dispatchBeforePrintEvent()</span>
<span class="line-added">2950 {</span>
<span class="line-added">2951     dispatchPrintEvent(m_mainFrame, eventNames().beforeprintEvent);</span>
<span class="line-added">2952 }</span>
<span class="line-added">2953 </span>
<span class="line-added">2954 void Page::dispatchAfterPrintEvent()</span>
<span class="line-added">2955 {</span>
<span class="line-added">2956     dispatchPrintEvent(m_mainFrame, eventNames().afterprintEvent);</span>
<span class="line-added">2957 }</span>
<span class="line-added">2958 </span>
2959 #if ENABLE(APPLE_PAY)
2960 void Page::setPaymentCoordinator(std::unique_ptr&lt;PaymentCoordinator&gt;&amp;&amp; paymentCoordinator)
2961 {
2962     m_paymentCoordinator = WTFMove(paymentCoordinator);
2963 }
2964 #endif
2965 
<span class="line-added">2966 void Page::configureLoggingChannel(const String&amp; channelName, WTFLogChannelState state, WTFLogLevel level)</span>
<span class="line-added">2967 {</span>
<span class="line-added">2968 #if !RELEASE_LOG_DISABLED</span>
<span class="line-added">2969     if (auto* channel = getLogChannel(channelName)) {</span>
<span class="line-added">2970         channel-&gt;state = state;</span>
<span class="line-added">2971         channel-&gt;level = level;</span>
<span class="line-added">2972 </span>
<span class="line-added">2973 #if USE(LIBWEBRTC)</span>
<span class="line-added">2974         if (channel == &amp;LogWebRTC &amp;&amp; m_mainFrame-&gt;document())</span>
<span class="line-added">2975             libWebRTCProvider().setEnableLogging(!m_mainFrame-&gt;document()-&gt;sessionID().isEphemeral());</span>
<span class="line-added">2976 #endif</span>
<span class="line-added">2977     }</span>
<span class="line-added">2978 </span>
<span class="line-added">2979     chrome().client().configureLoggingChannel(channelName, state, level);</span>
<span class="line-added">2980 #else</span>
<span class="line-added">2981     UNUSED_PARAM(channelName);</span>
<span class="line-added">2982     UNUSED_PARAM(state);</span>
<span class="line-added">2983     UNUSED_PARAM(level);</span>
<span class="line-added">2984 #endif</span>
<span class="line-added">2985 }</span>
<span class="line-added">2986 </span>
<span class="line-added">2987 void Page::didFinishLoadingImageForElement(HTMLImageElement&amp; element)</span>
<span class="line-added">2988 {</span>
<span class="line-added">2989     chrome().client().didFinishLoadingImageForElement(element);</span>
<span class="line-added">2990 }</span>
<span class="line-added">2991 </span>
<span class="line-added">2992 #if ENABLE(TEXT_AUTOSIZING)</span>
<span class="line-added">2993 void Page::recomputeTextAutoSizingInAllFrames()</span>
<span class="line-added">2994 {</span>
<span class="line-added">2995     ASSERT(settings().textAutosizingEnabled() &amp;&amp; settings().textAutosizingUsesIdempotentMode());</span>
<span class="line-added">2996     for (auto* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-added">2997         if (!frame-&gt;document())</span>
<span class="line-added">2998             continue;</span>
<span class="line-added">2999         auto&amp; document = *frame-&gt;document();</span>
<span class="line-added">3000         if (!document.renderView() || !document.styleScope().resolverIfExists())</span>
<span class="line-added">3001             continue;</span>
<span class="line-added">3002 </span>
<span class="line-added">3003         auto&amp; styleResolver = document.styleScope().resolver();</span>
<span class="line-added">3004         for (auto&amp; renderer : descendantsOfType&lt;RenderElement&gt;(*document.renderView())) {</span>
<span class="line-added">3005             if (auto* element = renderer.element()) {</span>
<span class="line-added">3006                 auto needsLayout = styleResolver.adjustRenderStyleForTextAutosizing(renderer.mutableStyle(), *element);</span>
<span class="line-added">3007                 if (needsLayout)</span>
<span class="line-added">3008                     renderer.setNeedsLayout();</span>
<span class="line-added">3009             }</span>
<span class="line-added">3010         }</span>
<span class="line-added">3011     }</span>
<span class="line-added">3012 }</span>
<span class="line-added">3013 #endif</span>
<span class="line-added">3014 </span>
3015 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="NavigatorBase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Page.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>