<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorCanvasAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorCSSAgent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorCanvasAgent.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorCanvasAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2017 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,29 ***</span>
<span class="line-new-header">--- 24,34 ---</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;InspectorCanvasAgent.h&quot;
  
<span class="line-added">+ #include &quot;ActiveDOMCallbackMicrotask.h&quot;</span>
  #include &quot;CanvasRenderingContext.h&quot;
  #include &quot;CanvasRenderingContext2D.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;Element.h&quot;
  #include &quot;Frame.h&quot;
<span class="line-added">+ #include &quot;HTMLCanvasElement.h&quot;</span>
  #include &quot;ImageBitmapRenderingContext.h&quot;
  #include &quot;InspectorDOMAgent.h&quot;
  #include &quot;InstrumentingAgents.h&quot;
  #include &quot;JSCanvasRenderingContext2D.h&quot;
  #include &quot;JSExecState.h&quot;
  #include &quot;JSImageBitmapRenderingContext.h&quot;
<span class="line-added">+ #include &quot;Microtasks.h&quot;</span>
  #include &quot;OffscreenCanvas.h&quot;
  #include &quot;ScriptState.h&quot;
  #include &quot;StringAdaptors.h&quot;
  #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
  #include &lt;JavaScriptCore/InjectedScript.h&gt;
  #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
  #include &lt;JavaScriptCore/InspectorProtocolObjects.h&gt;
  #include &lt;JavaScriptCore/JSCInlines.h&gt;
<span class="line-added">+ #include &lt;wtf/HashSet.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/Lock.h&gt;</span>
  
  #if ENABLE(WEBGL)
  #include &quot;JSWebGLRenderingContext.h&quot;
  #include &quot;WebGLProgram.h&quot;
  #include &quot;WebGLShader.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,29 ***</span>
  
  #if ENABLE(WEBGL2)
  #include &quot;JSWebGL2RenderingContext.h&quot;
  #endif
  
<span class="line-modified">! #if ENABLE(WEBMETAL)</span>
<span class="line-modified">! #include &quot;JSWebMetalRenderingContext.h&quot;</span>
  #endif
  
<span class="line-removed">- </span>
  namespace WebCore {
  
  using namespace Inspector;
  
<span class="line-modified">! InspectorCanvasAgent::InspectorCanvasAgent(WebAgentContext&amp; context)</span>
      : InspectorAgentBase(&quot;Canvas&quot;_s, context)
<span class="line-modified">!     , m_frontendDispatcher(std::make_unique&lt;Inspector::CanvasFrontendDispatcher&gt;(context.frontendRouter))</span>
      , m_backendDispatcher(Inspector::CanvasBackendDispatcher::create(context.backendDispatcher, this))
      , m_injectedScriptManager(context.injectedScriptManager)
      , m_canvasDestroyedTimer(*this, &amp;InspectorCanvasAgent::canvasDestroyedTimerFired)
<span class="line-removed">-     , m_canvasRecordingTimer(*this, &amp;InspectorCanvasAgent::canvasRecordingTimerFired)</span>
  {
  }
  
  void InspectorCanvasAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
  {
  }
  
  void InspectorCanvasAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
<span class="line-new-header">--- 59,30 ---</span>
  
  #if ENABLE(WEBGL2)
  #include &quot;JSWebGL2RenderingContext.h&quot;
  #endif
  
<span class="line-modified">! #if ENABLE(WEBGPU)</span>
<span class="line-modified">! #include &quot;JSGPUCanvasContext.h&quot;</span>
  #endif
  
  namespace WebCore {
  
  using namespace Inspector;
  
<span class="line-modified">! InspectorCanvasAgent::InspectorCanvasAgent(PageAgentContext&amp; context)</span>
      : InspectorAgentBase(&quot;Canvas&quot;_s, context)
<span class="line-modified">!     , m_frontendDispatcher(makeUnique&lt;Inspector::CanvasFrontendDispatcher&gt;(context.frontendRouter))</span>
      , m_backendDispatcher(Inspector::CanvasBackendDispatcher::create(context.backendDispatcher, this))
      , m_injectedScriptManager(context.injectedScriptManager)
<span class="line-added">+     , m_inspectedPage(context.inspectedPage)</span>
      , m_canvasDestroyedTimer(*this, &amp;InspectorCanvasAgent::canvasDestroyedTimerFired)
  {
  }
  
<span class="line-added">+ InspectorCanvasAgent::~InspectorCanvasAgent() = default;</span>
<span class="line-added">+ </span>
  void InspectorCanvasAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
  {
  }
  
  void InspectorCanvasAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,128 ***</span>
      clearCanvasData();
  }
  
  void InspectorCanvasAgent::enable(ErrorString&amp;)
  {
<span class="line-modified">!     if (m_enabled)</span>
          return;
  
<span class="line-modified">!     m_recordingAutoCaptureFrameCount = WTF::nullopt;</span>
  
<span class="line-modified">!     m_enabled = true;</span>
  
<span class="line-modified">!     const bool captureBacktrace = false;</span>
<span class="line-modified">!     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {</span>
<span class="line-modified">!         m_frontendDispatcher-&gt;canvasAdded(inspectorCanvas-&gt;buildObjectForCanvas(captureBacktrace));</span>
  
<span class="line-modified">! #if ENABLE(WEBGL)</span>
<span class="line-modified">!         if (is&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context())) {</span>
<span class="line-modified">!             WebGLRenderingContextBase&amp; contextWebGL = downcast&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context());</span>
<span class="line-modified">!             if (Optional&lt;Vector&lt;String&gt;&gt; extensions = contextWebGL.getSupportedExtensions()) {</span>
<span class="line-modified">!                 for (const String&amp; extension : *extensions) {</span>
<span class="line-modified">!                     if (contextWebGL.extensionIsEnabled(extension))</span>
<span class="line-modified">!                         m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
          }
<span class="line-removed">- #endif</span>
      }
  
  #if ENABLE(WEBGL)
<span class="line-modified">!     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {</span>
<span class="line-modified">!         auto&amp; inspectorCanvas = inspectorProgram-&gt;canvas();</span>
<span class="line-modified">!         m_frontendDispatcher-&gt;programCreated(inspectorCanvas.identifier(), inspectorProgram-&gt;identifier());</span>
      }
  #endif
  }
  
  void InspectorCanvasAgent::disable(ErrorString&amp;)
  {
<span class="line-modified">!     if (!m_enabled)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_canvasDestroyedTimer.isActive())</span>
<span class="line-removed">-         m_canvasDestroyedTimer.stop();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_removedCanvasIdentifiers.clear();</span>
  
<span class="line-modified">!     if (m_canvasRecordingTimer.isActive())</span>
<span class="line-removed">-         m_canvasRecordingTimer.stop();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values())</span>
<span class="line-removed">-         inspectorCanvas-&gt;resetRecordingData();</span>
  
      m_recordingAutoCaptureFrameCount = WTF::nullopt;
<span class="line-removed">- </span>
<span class="line-removed">-     m_enabled = false;</span>
  }
  
  void InspectorCanvasAgent::requestNode(ErrorString&amp; errorString, const String&amp; canvasId, int* nodeId)
  {
<span class="line-modified">!     auto* inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
      if (!inspectorCanvas)
          return;
  
      auto* node = inspectorCanvas-&gt;canvasElement();
      if (!node) {
<span class="line-modified">!         errorString = &quot;No node for canvas&quot;_s;</span>
          return;
      }
  
      int documentNodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;boundNodeId(&amp;node-&gt;document());
      if (!documentNodeId) {
<span class="line-modified">!         errorString = &quot;Document has not been requested&quot;_s;</span>
          return;
      }
  
      *nodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;pushNodeToFrontend(errorString, documentNodeId, node);
  }
  
  void InspectorCanvasAgent::requestContent(ErrorString&amp; errorString, const String&amp; canvasId, String* content)
  {
<span class="line-modified">!     auto* inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (auto* node = inspectorCanvas-&gt;canvasElement()) {</span>
<span class="line-removed">-         if (is&lt;CanvasRenderingContext2D&gt;(inspectorCanvas-&gt;context()) || is&lt;ImageBitmapRenderingContext&gt;(inspectorCanvas-&gt;context())) {</span>
<span class="line-removed">-             auto result = node-&gt;toDataURL(&quot;image/png&quot;_s);</span>
<span class="line-removed">-             if (result.hasException()) {</span>
<span class="line-removed">-                 errorString = result.releaseException().releaseMessage();</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             *content = result.releaseReturnValue().string;</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(WEBGL)</span>
<span class="line-removed">-         if (is&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context())) {</span>
<span class="line-removed">-             WebGLRenderingContextBase&amp; contextWebGLBase = downcast&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             contextWebGLBase.setPreventBufferClearForInspector(true);</span>
<span class="line-removed">-             auto result = node-&gt;toDataURL(&quot;image/png&quot;_s);</span>
<span class="line-removed">-             contextWebGLBase.setPreventBufferClearForInspector(false);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (result.hasException()) {</span>
<span class="line-removed">-                 errorString = result.releaseException().releaseMessage();</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             *content = result.releaseReturnValue().string;</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // FIXME: &lt;https://webkit.org/b/173621&gt; Web Inspector: Support getting the content of WebMetal context;</span>
<span class="line-removed">-     errorString = &quot;Unsupported canvas context type&quot;_s;</span>
  }
  
  void InspectorCanvasAgent::requestCSSCanvasClientNodes(ErrorString&amp; errorString, const String&amp; canvasId, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result)
  {
<span class="line-modified">!     auto* inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
      if (!inspectorCanvas)
          return;
  
      result = JSON::ArrayOf&lt;int&gt;::create();
      for (auto* client : inspectorCanvas-&gt;context().canvasBase().cssCanvasClients()) {
<span class="line-new-header">--- 96,89 ---</span>
      clearCanvasData();
  }
  
  void InspectorCanvasAgent::enable(ErrorString&amp;)
  {
<span class="line-modified">!     if (m_instrumentingAgents.inspectorCanvasAgent() == this)</span>
          return;
  
<span class="line-modified">!     m_instrumentingAgents.setInspectorCanvasAgent(this);</span>
  
<span class="line-modified">!     const auto canvasExistsInCurrentPage = [&amp;] (CanvasRenderingContext* canvasRenderingContext) {</span>
<span class="line-added">+         if (!canvasRenderingContext)</span>
<span class="line-added">+             return false;</span>
  
<span class="line-modified">!         auto* scriptExecutionContext = canvasRenderingContext-&gt;canvasBase().scriptExecutionContext();</span>
<span class="line-modified">!         if (!is&lt;Document&gt;(scriptExecutionContext))</span>
<span class="line-modified">!             return false;</span>
  
<span class="line-modified">!         // FIXME: &lt;https://webkit.org/b/168475&gt; Web Inspector: Correctly display iframe&#39;s WebSockets</span>
<span class="line-modified">!         auto* document = downcast&lt;Document&gt;(scriptExecutionContext);</span>
<span class="line-modified">!         return document-&gt;page() == &amp;m_inspectedPage;</span>
<span class="line-modified">!     };</span>
<span class="line-modified">! </span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         LockHolder lock(CanvasRenderingContext::instancesMutex());</span>
<span class="line-modified">!         for (auto* canvasRenderingContext : CanvasRenderingContext::instances(lock)) {</span>
<span class="line-modified">!             if (canvasExistsInCurrentPage(canvasRenderingContext))</span>
<span class="line-added">+                 bindCanvas(*canvasRenderingContext, false);</span>
          }
      }
  
  #if ENABLE(WEBGL)
<span class="line-modified">!     {</span>
<span class="line-modified">!         LockHolder lock(WebGLProgram::instancesMutex());</span>
<span class="line-modified">!         for (auto&amp; entry : WebGLProgram::instances(lock)) {</span>
<span class="line-added">+             if (canvasExistsInCurrentPage(entry.value))</span>
<span class="line-added">+                 didCreateProgram(*entry.value, *entry.key);</span>
<span class="line-added">+         }</span>
      }
  #endif
  }
  
  void InspectorCanvasAgent::disable(ErrorString&amp;)
  {
<span class="line-modified">!     m_instrumentingAgents.setInspectorCanvasAgent(nullptr);</span>
  
<span class="line-modified">!     clearCanvasData();</span>
  
      m_recordingAutoCaptureFrameCount = WTF::nullopt;
  }
  
  void InspectorCanvasAgent::requestNode(ErrorString&amp; errorString, const String&amp; canvasId, int* nodeId)
  {
<span class="line-modified">!     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
      if (!inspectorCanvas)
          return;
  
      auto* node = inspectorCanvas-&gt;canvasElement();
      if (!node) {
<span class="line-modified">!         errorString = &quot;Missing element of canvas for given canvasId&quot;_s;</span>
          return;
      }
  
      int documentNodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;boundNodeId(&amp;node-&gt;document());
      if (!documentNodeId) {
<span class="line-modified">!         errorString = &quot;Document must have been requested&quot;_s;</span>
          return;
      }
  
      *nodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;pushNodeToFrontend(errorString, documentNodeId, node);
  }
  
  void InspectorCanvasAgent::requestContent(ErrorString&amp; errorString, const String&amp; canvasId, String* content)
  {
<span class="line-modified">!     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     *content = inspectorCanvas-&gt;getCanvasContentAsDataURL(errorString);</span>
  }
  
  void InspectorCanvasAgent::requestCSSCanvasClientNodes(ErrorString&amp; errorString, const String&amp; canvasId, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result)
  {
<span class="line-modified">!     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
      if (!inspectorCanvas)
          return;
  
      result = JSON::ArrayOf&lt;int&gt;::create();
      for (auto* client : inspectorCanvas-&gt;context().canvasBase().cssCanvasClients()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,34 ***</span>
  #endif
  #if ENABLE(WEBGL2)
      if (is&lt;WebGL2RenderingContext&gt;(context))
          return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;WebGL2RenderingContext&gt;(context));
  #endif
<span class="line-modified">! #if ENABLE(WEBMETAL)</span>
<span class="line-modified">!     if (is&lt;WebMetalRenderingContext&gt;(context))</span>
<span class="line-modified">!         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;WebMetalRenderingContext&gt;(context));</span>
  #endif
      if (is&lt;ImageBitmapRenderingContext&gt;(context))
          return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;ImageBitmapRenderingContext&gt;(context));
  
      return { };
  }
  
  void InspectorCanvasAgent::resolveCanvasContext(ErrorString&amp; errorString, const String&amp; canvasId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
  {
<span class="line-modified">!     auto* inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
      if (!inspectorCanvas)
          return;
  
      auto&amp; state = *inspectorCanvas-&gt;context().canvasBase().scriptExecutionContext()-&gt;execState();
      auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
      ASSERT(!injectedScript.hasNoValue());
  
      JSC::JSValue value = contextAsScriptValue(state, inspectorCanvas-&gt;context());
      if (!value) {
          ASSERT_NOT_REACHED();
<span class="line-modified">!         errorString = &quot;Unknown context type&quot;_s;</span>
          return;
      }
  
      String objectGroupName = objectGroup ? *objectGroup : String();
      result = injectedScript.wrapObject(value, objectGroupName);
<span class="line-new-header">--- 199,34 ---</span>
  #endif
  #if ENABLE(WEBGL2)
      if (is&lt;WebGL2RenderingContext&gt;(context))
          return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;WebGL2RenderingContext&gt;(context));
  #endif
<span class="line-modified">! #if ENABLE(WEBGPU)</span>
<span class="line-modified">!     if (is&lt;GPUCanvasContext&gt;(context))</span>
<span class="line-modified">!         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;GPUCanvasContext&gt;(context));</span>
  #endif
      if (is&lt;ImageBitmapRenderingContext&gt;(context))
          return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;ImageBitmapRenderingContext&gt;(context));
  
      return { };
  }
  
  void InspectorCanvasAgent::resolveCanvasContext(ErrorString&amp; errorString, const String&amp; canvasId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
  {
<span class="line-modified">!     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
      if (!inspectorCanvas)
          return;
  
      auto&amp; state = *inspectorCanvas-&gt;context().canvasBase().scriptExecutionContext()-&gt;execState();
      auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
      ASSERT(!injectedScript.hasNoValue());
  
      JSC::JSValue value = contextAsScriptValue(state, inspectorCanvas-&gt;context());
      if (!value) {
          ASSERT_NOT_REACHED();
<span class="line-modified">!         errorString = &quot;Internal error: unknown context of canvas for given canvasId&quot;_s;</span>
          return;
      }
  
      String objectGroupName = objectGroup ? *objectGroup : String();
      result = injectedScript.wrapObject(value, objectGroupName);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 273,11 ***</span>
          m_recordingAutoCaptureFrameCount = WTF::nullopt;
  }
  
  void InspectorCanvasAgent::startRecording(ErrorString&amp; errorString, const String&amp; canvasId, const int* frameCount, const int* memoryLimit)
  {
<span class="line-modified">!     auto* inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
      if (!inspectorCanvas)
          return;
  
      if (inspectorCanvas-&gt;context().callTracingActive()) {
          errorString = &quot;Already recording canvas&quot;_s;
<span class="line-new-header">--- 240,11 ---</span>
          m_recordingAutoCaptureFrameCount = WTF::nullopt;
  }
  
  void InspectorCanvasAgent::startRecording(ErrorString&amp; errorString, const String&amp; canvasId, const int* frameCount, const int* memoryLimit)
  {
<span class="line-modified">!     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
      if (!inspectorCanvas)
          return;
  
      if (inspectorCanvas-&gt;context().callTracingActive()) {
          errorString = &quot;Already recording canvas&quot;_s;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 292,102 ***</span>
      startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Frontend, WTFMove(recordingOptions));
  }
  
  void InspectorCanvasAgent::stopRecording(ErrorString&amp; errorString, const String&amp; canvasId)
  {
<span class="line-modified">!     auto* inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
      if (!inspectorCanvas)
          return;
  
      if (!inspectorCanvas-&gt;context().callTracingActive()) {
<span class="line-modified">!         errorString = &quot;No active recording for canvas&quot;_s;</span>
          return;
      }
  
      didFinishRecordingCanvasFrame(inspectorCanvas-&gt;context(), true);
  }
  
  void InspectorCanvasAgent::requestShaderSource(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderType, String* content)
  {
  #if ENABLE(WEBGL)
<span class="line-modified">!     auto* inspectorProgram = assertInspectorProgram(errorString, programId);</span>
      if (!inspectorProgram)
          return;
  
      auto* shader = inspectorProgram-&gt;shaderForType(shaderType);
      if (!shader) {
<span class="line-modified">!         errorString = &quot;No shader for given type.&quot;_s;</span>
          return;
      }
  
      *content = shader-&gt;getSource();
  #else
      UNUSED_PARAM(programId);
      UNUSED_PARAM(shaderType);
      UNUSED_PARAM(content);
<span class="line-modified">!     errorString = &quot;WebGL is not supported.&quot;_s;</span>
  #endif
  }
  
  void InspectorCanvasAgent::updateShader(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderType, const String&amp; source)
  {
  #if ENABLE(WEBGL)
<span class="line-modified">!     auto* inspectorProgram = assertInspectorProgram(errorString, programId);</span>
      if (!inspectorProgram)
          return;
  
      auto* shader = inspectorProgram-&gt;shaderForType(shaderType);
      if (!shader) {
<span class="line-modified">!         errorString = &quot;No shader for given type.&quot;_s;</span>
          return;
      }
  
      WebGLRenderingContextBase&amp; contextWebGL = inspectorProgram-&gt;context();
      contextWebGL.shaderSource(shader, source);
      contextWebGL.compileShader(shader);
  
      if (!shader-&gt;isValid()) {
<span class="line-modified">!         errorString = &quot;Shader compilation failed.&quot;_s;</span>
          return;
      }
  
      contextWebGL.linkProgramWithoutInvalidatingAttribLocations(&amp;inspectorProgram-&gt;program());
  #else
      UNUSED_PARAM(programId);
      UNUSED_PARAM(shaderType);
      UNUSED_PARAM(source);
<span class="line-modified">!     errorString = &quot;WebGL is not supported.&quot;_s;</span>
  #endif
  }
  
  void InspectorCanvasAgent::setShaderProgramDisabled(ErrorString&amp; errorString, const String&amp; programId, bool disabled)
  {
  #if ENABLE(WEBGL)
<span class="line-modified">!     auto* inspectorProgram = assertInspectorProgram(errorString, programId);</span>
      if (!inspectorProgram)
          return;
  
      inspectorProgram-&gt;setDisabled(disabled);
  #else
      UNUSED_PARAM(programId);
      UNUSED_PARAM(disabled);
<span class="line-modified">!     errorString = &quot;WebGL is not supported.&quot;_s;</span>
  #endif
  }
  
  void InspectorCanvasAgent::setShaderProgramHighlighted(ErrorString&amp; errorString, const String&amp; programId, bool highlighted)
  {
  #if ENABLE(WEBGL)
<span class="line-modified">!     auto* inspectorProgram = assertInspectorProgram(errorString, programId);</span>
      if (!inspectorProgram)
          return;
  
      inspectorProgram-&gt;setHighlighted(highlighted);
  #else
      UNUSED_PARAM(programId);
      UNUSED_PARAM(highlighted);
<span class="line-modified">!     errorString = &quot;WebGL is not supported.&quot;_s;</span>
  #endif
  }
  
  void InspectorCanvasAgent::frameNavigated(Frame&amp; frame)
  {
<span class="line-new-header">--- 259,102 ---</span>
      startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Frontend, WTFMove(recordingOptions));
  }
  
  void InspectorCanvasAgent::stopRecording(ErrorString&amp; errorString, const String&amp; canvasId)
  {
<span class="line-modified">!     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);</span>
      if (!inspectorCanvas)
          return;
  
      if (!inspectorCanvas-&gt;context().callTracingActive()) {
<span class="line-modified">!         errorString = &quot;Not recording canvas&quot;_s;</span>
          return;
      }
  
      didFinishRecordingCanvasFrame(inspectorCanvas-&gt;context(), true);
  }
  
  void InspectorCanvasAgent::requestShaderSource(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderType, String* content)
  {
  #if ENABLE(WEBGL)
<span class="line-modified">!     auto inspectorProgram = assertInspectorProgram(errorString, programId);</span>
      if (!inspectorProgram)
          return;
  
      auto* shader = inspectorProgram-&gt;shaderForType(shaderType);
      if (!shader) {
<span class="line-modified">!         errorString = &quot;Missing shader for given shaderType&quot;_s;</span>
          return;
      }
  
      *content = shader-&gt;getSource();
  #else
      UNUSED_PARAM(programId);
      UNUSED_PARAM(shaderType);
      UNUSED_PARAM(content);
<span class="line-modified">!     errorString = &quot;Not supported&quot;_s;</span>
  #endif
  }
  
  void InspectorCanvasAgent::updateShader(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderType, const String&amp; source)
  {
  #if ENABLE(WEBGL)
<span class="line-modified">!     auto inspectorProgram = assertInspectorProgram(errorString, programId);</span>
      if (!inspectorProgram)
          return;
  
      auto* shader = inspectorProgram-&gt;shaderForType(shaderType);
      if (!shader) {
<span class="line-modified">!         errorString = &quot;Missing shader for given shaderType&quot;_s;</span>
          return;
      }
  
      WebGLRenderingContextBase&amp; contextWebGL = inspectorProgram-&gt;context();
      contextWebGL.shaderSource(shader, source);
      contextWebGL.compileShader(shader);
  
      if (!shader-&gt;isValid()) {
<span class="line-modified">!         errorString = &quot;Failed to update shader&quot;_s;</span>
          return;
      }
  
      contextWebGL.linkProgramWithoutInvalidatingAttribLocations(&amp;inspectorProgram-&gt;program());
  #else
      UNUSED_PARAM(programId);
      UNUSED_PARAM(shaderType);
      UNUSED_PARAM(source);
<span class="line-modified">!     errorString = &quot;Not supported&quot;_s;</span>
  #endif
  }
  
  void InspectorCanvasAgent::setShaderProgramDisabled(ErrorString&amp; errorString, const String&amp; programId, bool disabled)
  {
  #if ENABLE(WEBGL)
<span class="line-modified">!     auto inspectorProgram = assertInspectorProgram(errorString, programId);</span>
      if (!inspectorProgram)
          return;
  
      inspectorProgram-&gt;setDisabled(disabled);
  #else
      UNUSED_PARAM(programId);
      UNUSED_PARAM(disabled);
<span class="line-modified">!     errorString = &quot;Not supported&quot;_s;</span>
  #endif
  }
  
  void InspectorCanvasAgent::setShaderProgramHighlighted(ErrorString&amp; errorString, const String&amp; programId, bool highlighted)
  {
  #if ENABLE(WEBGL)
<span class="line-modified">!     auto inspectorProgram = assertInspectorProgram(errorString, programId);</span>
      if (!inspectorProgram)
          return;
  
      inspectorProgram-&gt;setHighlighted(highlighted);
  #else
      UNUSED_PARAM(programId);
      UNUSED_PARAM(highlighted);
<span class="line-modified">!     errorString = &quot;Not supported&quot;_s;</span>
  #endif
  }
  
  void InspectorCanvasAgent::frameNavigated(Frame&amp; frame)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 403,15 ***</span>
                  inspectorCanvases.append(inspectorCanvas.get());
          }
      }
  
      for (auto* inspectorCanvas : inspectorCanvases) {
<span class="line-removed">-         inspectorCanvas-&gt;context().canvasBase().removeObserver(*this);</span>
<span class="line-removed">- </span>
          String identifier = unbindCanvas(*inspectorCanvas);
<span class="line-modified">!         if (m_enabled)</span>
<span class="line-removed">-             m_frontendDispatcher-&gt;canvasRemoved(identifier);</span>
      }
  }
  
  void InspectorCanvasAgent::didChangeCSSCanvasClientNodes(CanvasBase&amp; canvasBase)
  {
<span class="line-new-header">--- 370,12 ---</span>
                  inspectorCanvases.append(inspectorCanvas.get());
          }
      }
  
      for (auto* inspectorCanvas : inspectorCanvases) {
          String identifier = unbindCanvas(*inspectorCanvas);
<span class="line-modified">!         m_frontendDispatcher-&gt;canvasRemoved(identifier);</span>
      }
  }
  
  void InspectorCanvasAgent::didChangeCSSCanvasClientNodes(CanvasBase&amp; canvasBase)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 419,11 ***</span>
      if (!context) {
          ASSERT_NOT_REACHED();
          return;
      }
  
<span class="line-modified">!     auto* inspectorCanvas = findInspectorCanvas(*context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      m_frontendDispatcher-&gt;cssCanvasClientNodesChanged(inspectorCanvas-&gt;identifier());
<span class="line-new-header">--- 383,11 ---</span>
      if (!context) {
          ASSERT_NOT_REACHED();
          return;
      }
  
<span class="line-modified">!     auto inspectorCanvas = findInspectorCanvas(*context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      m_frontendDispatcher-&gt;cssCanvasClientNodesChanged(inspectorCanvas-&gt;identifier());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 434,76 ***</span>
      if (findInspectorCanvas(context)) {
          ASSERT_NOT_REACHED();
          return;
      }
  
<span class="line-modified">!     context.canvasBase().addObserver(*this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto inspectorCanvas = InspectorCanvas::create(context);</span>
<span class="line-removed">-     m_identifierToInspectorCanvas.set(inspectorCanvas-&gt;identifier(), inspectorCanvas.copyRef());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!m_enabled)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     const bool captureBacktrace = true;</span>
<span class="line-removed">-     m_frontendDispatcher-&gt;canvasAdded(inspectorCanvas-&gt;buildObjectForCanvas(captureBacktrace));</span>
  
      if (m_recordingAutoCaptureFrameCount) {
          RecordingOptions recordingOptions;
          recordingOptions.frameCount = m_recordingAutoCaptureFrameCount.value();
<span class="line-modified">!         startRecording(inspectorCanvas.get(), Inspector::Protocol::Recording::Initiator::AutoCapture, WTFMove(recordingOptions));</span>
      }
  }
  
  void InspectorCanvasAgent::didChangeCanvasMemory(CanvasRenderingContext&amp; context)
  {
<span class="line-modified">!     auto* inspectorCanvas = findInspectorCanvas(context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
  
      if (auto* node = inspectorCanvas-&gt;canvasElement())
          m_frontendDispatcher-&gt;canvasMemoryChanged(inspectorCanvas-&gt;identifier(), node-&gt;memoryCost());
  }
  
<span class="line-modified">! void InspectorCanvasAgent::recordCanvasAction(CanvasRenderingContext&amp; canvasRenderingContext, const String&amp; name, Vector&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)</span>
  {
<span class="line-modified">!     auto* inspectorCanvas = findInspectorCanvas(canvasRenderingContext);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      ASSERT(canvasRenderingContext.callTracingActive());
      if (!canvasRenderingContext.callTracingActive())
          return;
  
<span class="line-modified">!     inspectorCanvas-&gt;recordAction(name, WTFMove(parameters));</span>
  
<span class="line-modified">!     if (!m_canvasRecordingTimer.isActive())</span>
<span class="line-modified">!         m_canvasRecordingTimer.startOneShot(0_s);</span>
  
      if (!inspectorCanvas-&gt;hasBufferSpace())
          didFinishRecordingCanvasFrame(inspectorCanvas-&gt;context(), true);
  }
  
  void InspectorCanvasAgent::canvasDestroyed(CanvasBase&amp; canvasBase)
  {
      auto* context = canvasBase.renderingContext();
<span class="line-removed">-     ASSERT(context);</span>
      if (!context)
          return;
  
<span class="line-modified">!     auto* inspectorCanvas = findInspectorCanvas(*context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      String identifier = unbindCanvas(*inspectorCanvas);
<span class="line-removed">-     if (!m_enabled)</span>
<span class="line-removed">-         return;</span>
  
      // WebCore::CanvasObserver::canvasDestroyed is called in response to the GC destroying the CanvasBase.
      // Due to the single-process model used in WebKit1, the event must be dispatched from a timer to prevent
      // the frontend from making JS allocations while the GC is still active.
      m_removedCanvasIdentifiers.append(identifier);
<span class="line-new-header">--- 398,92 ---</span>
      if (findInspectorCanvas(context)) {
          ASSERT_NOT_REACHED();
          return;
      }
  
<span class="line-modified">!     auto&amp; inspectorCanvas = bindCanvas(context, true);</span>
  
      if (m_recordingAutoCaptureFrameCount) {
          RecordingOptions recordingOptions;
          recordingOptions.frameCount = m_recordingAutoCaptureFrameCount.value();
<span class="line-modified">!         startRecording(inspectorCanvas, Inspector::Protocol::Recording::Initiator::AutoCapture, WTFMove(recordingOptions));</span>
      }
  }
  
  void InspectorCanvasAgent::didChangeCanvasMemory(CanvasRenderingContext&amp; context)
  {
<span class="line-modified">!     auto inspectorCanvas = findInspectorCanvas(context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
  
      if (auto* node = inspectorCanvas-&gt;canvasElement())
          m_frontendDispatcher-&gt;canvasMemoryChanged(inspectorCanvas-&gt;identifier(), node-&gt;memoryCost());
  }
  
<span class="line-modified">! void InspectorCanvasAgent::recordCanvasAction(CanvasRenderingContext&amp; canvasRenderingContext, const String&amp; name, std::initializer_list&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)</span>
  {
<span class="line-modified">!     auto inspectorCanvas = findInspectorCanvas(canvasRenderingContext);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      ASSERT(canvasRenderingContext.callTracingActive());
      if (!canvasRenderingContext.callTracingActive())
          return;
  
<span class="line-modified">!     // Only enqueue a microtask for the first action of each frame. Any subsequent actions will be</span>
<span class="line-added">+     // covered by the initial microtask until the next frame.</span>
<span class="line-added">+     if (!inspectorCanvas-&gt;currentFrameHasData()) {</span>
<span class="line-added">+         if (auto* scriptExecutionContext = inspectorCanvas-&gt;context().canvasBase().scriptExecutionContext()) {</span>
<span class="line-added">+             auto&amp; queue = MicrotaskQueue::mainThreadQueue();</span>
<span class="line-added">+             queue.append(makeUnique&lt;ActiveDOMCallbackMicrotask&gt;(queue, *scriptExecutionContext, [&amp;, protectedInspectorCanvas = inspectorCanvas.copyRef()] {</span>
<span class="line-added">+                 if (auto* canvasElement = protectedInspectorCanvas-&gt;canvasElement()) {</span>
<span class="line-added">+                     if (canvasElement-&gt;isDescendantOf(canvasElement-&gt;document()))</span>
<span class="line-added">+                         return;</span>
<span class="line-added">+                 }</span>
  
<span class="line-modified">!                 if (protectedInspectorCanvas-&gt;context().callTracingActive())</span>
<span class="line-modified">!                     didFinishRecordingCanvasFrame(protectedInspectorCanvas-&gt;context());</span>
<span class="line-added">+             }));</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     inspectorCanvas-&gt;recordAction(name, WTFMove(parameters));</span>
  
      if (!inspectorCanvas-&gt;hasBufferSpace())
          didFinishRecordingCanvasFrame(inspectorCanvas-&gt;context(), true);
  }
  
<span class="line-added">+ void InspectorCanvasAgent::canvasChanged(CanvasBase&amp; canvasBase, const FloatRect&amp;)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* context = canvasBase.renderingContext();</span>
<span class="line-added">+     if (!context)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto inspectorCanvas = findInspectorCanvas(*context);</span>
<span class="line-added">+     ASSERT(inspectorCanvas);</span>
<span class="line-added">+     if (!inspectorCanvas)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     inspectorCanvas-&gt;canvasChanged();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void InspectorCanvasAgent::canvasDestroyed(CanvasBase&amp; canvasBase)
  {
      auto* context = canvasBase.renderingContext();
      if (!context)
          return;
  
<span class="line-modified">!     auto inspectorCanvas = findInspectorCanvas(*context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      String identifier = unbindCanvas(*inspectorCanvas);
  
      // WebCore::CanvasObserver::canvasDestroyed is called in response to the GC destroying the CanvasBase.
      // Due to the single-process model used in WebKit1, the event must be dispatched from a timer to prevent
      // the frontend from making JS allocations while the GC is still active.
      m_removedCanvasIdentifiers.append(identifier);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 512,22 ***</span>
          m_canvasDestroyedTimer.startOneShot(0_s);
  }
  
  void InspectorCanvasAgent::didFinishRecordingCanvasFrame(CanvasRenderingContext&amp; context, bool forceDispatch)
  {
<span class="line-modified">!     auto* inspectorCanvas = findInspectorCanvas(context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      if (!inspectorCanvas-&gt;context().callTracingActive())
          return;
  
      if (!inspectorCanvas-&gt;hasRecordingData()) {
          if (forceDispatch) {
              m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), nullptr);
<span class="line-removed">- </span>
              inspectorCanvas-&gt;resetRecordingData();
          }
          return;
      }
  
<span class="line-new-header">--- 492,21 ---</span>
          m_canvasDestroyedTimer.startOneShot(0_s);
  }
  
  void InspectorCanvasAgent::didFinishRecordingCanvasFrame(CanvasRenderingContext&amp; context, bool forceDispatch)
  {
<span class="line-modified">!     auto inspectorCanvas = findInspectorCanvas(context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      if (!inspectorCanvas-&gt;context().callTracingActive())
          return;
  
      if (!inspectorCanvas-&gt;hasRecordingData()) {
          if (forceDispatch) {
              m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), nullptr);
              inspectorCanvas-&gt;resetRecordingData();
          }
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 539,112 ***</span>
          m_frontendDispatcher-&gt;recordingProgress(inspectorCanvas-&gt;identifier(), inspectorCanvas-&gt;releaseFrames(), inspectorCanvas-&gt;bufferUsed());
  
      if (!forceDispatch &amp;&amp; !inspectorCanvas-&gt;overFrameCount())
          return;
  
<span class="line-modified">!     // FIXME: &lt;https://webkit.org/b/176008&gt; Web Inspector: Record actions performed on WebGL2RenderingContext</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Inspector::Protocol::Recording::Type type;</span>
<span class="line-removed">-     if (is&lt;CanvasRenderingContext2D&gt;(inspectorCanvas-&gt;context()))</span>
<span class="line-removed">-         type = Inspector::Protocol::Recording::Type::Canvas2D;</span>
<span class="line-removed">-     else if (is&lt;ImageBitmapRenderingContext&gt;(inspectorCanvas-&gt;context()))</span>
<span class="line-removed">-         type = Inspector::Protocol::Recording::Type::CanvasBitmapRenderer;</span>
<span class="line-removed">- #if ENABLE(WEBGL)</span>
<span class="line-removed">-     else if (is&lt;WebGLRenderingContext&gt;(inspectorCanvas-&gt;context()))</span>
<span class="line-removed">-         type = Inspector::Protocol::Recording::Type::CanvasWebGL;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     else {</span>
<span class="line-removed">-         ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         type = Inspector::Protocol::Recording::Type::Canvas2D;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto recording = Inspector::Protocol::Recording::Recording::create()</span>
<span class="line-removed">-         .setVersion(Inspector::Protocol::Recording::VERSION)</span>
<span class="line-removed">-         .setType(type)</span>
<span class="line-removed">-         .setInitialState(inspectorCanvas-&gt;releaseInitialState())</span>
<span class="line-removed">-         .setData(inspectorCanvas-&gt;releaseData())</span>
<span class="line-removed">-         .release();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     const String&amp; name = inspectorCanvas-&gt;recordingName();</span>
<span class="line-removed">-     if (!name.isEmpty())</span>
<span class="line-removed">-         recording-&gt;setName(name);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), WTFMove(recording));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     inspectorCanvas-&gt;resetRecordingData();</span>
  }
  
  void InspectorCanvasAgent::consoleStartRecordingCanvas(CanvasRenderingContext&amp; context, JSC::ExecState&amp; exec, JSC::JSObject* options)
  {
<span class="line-modified">!     auto* inspectorCanvas = findInspectorCanvas(context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      RecordingOptions recordingOptions;
      if (options) {
<span class="line-modified">!         if (JSC::JSValue optionSingleFrame = options-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;singleFrame&quot;)))</span>
              recordingOptions.frameCount = optionSingleFrame.toBoolean(&amp;exec) ? 1 : 0;
<span class="line-modified">!         if (JSC::JSValue optionFrameCount = options-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;frameCount&quot;)))</span>
              recordingOptions.frameCount = optionFrameCount.toNumber(&amp;exec);
<span class="line-modified">!         if (JSC::JSValue optionMemoryLimit = options-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;memoryLimit&quot;)))</span>
              recordingOptions.memoryLimit = optionMemoryLimit.toNumber(&amp;exec);
<span class="line-modified">!         if (JSC::JSValue optionName = options-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;name&quot;)))</span>
              recordingOptions.name = optionName.toWTFString(&amp;exec);
      }
      startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Console, WTFMove(recordingOptions));
  }
  
  #if ENABLE(WEBGL)
  void InspectorCanvasAgent::didEnableExtension(WebGLRenderingContextBase&amp; context, const String&amp; extension)
  {
<span class="line-modified">!     auto* inspectorCanvas = findInspectorCanvas(context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);
  }
  
  void InspectorCanvasAgent::didCreateProgram(WebGLRenderingContextBase&amp; context, WebGLProgram&amp; program)
  {
<span class="line-modified">!     auto* inspectorCanvas = findInspectorCanvas(context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      auto inspectorProgram = InspectorShaderProgram::create(program, *inspectorCanvas);
      String programIdentifier = inspectorProgram-&gt;identifier();
      m_identifierToInspectorProgram.set(programIdentifier, WTFMove(inspectorProgram));
<span class="line-modified">! </span>
<span class="line-removed">-     if (m_enabled)</span>
<span class="line-removed">-         m_frontendDispatcher-&gt;programCreated(inspectorCanvas-&gt;identifier(), programIdentifier);</span>
  }
  
  void InspectorCanvasAgent::willDeleteProgram(WebGLProgram&amp; program)
  {
<span class="line-modified">!     auto* inspectorProgram = findInspectorProgram(program);</span>
      if (!inspectorProgram)
          return;
  
      String identifier = unbindProgram(*inspectorProgram);
<span class="line-modified">!     if (m_enabled)</span>
<span class="line-removed">-         m_frontendDispatcher-&gt;programDeleted(identifier);</span>
  }
  
  bool InspectorCanvasAgent::isShaderProgramDisabled(WebGLProgram&amp; program)
  {
<span class="line-modified">!     auto* inspectorProgram = findInspectorProgram(program);</span>
      if (!inspectorProgram)
          return false;
  
      return inspectorProgram-&gt;disabled();
  }
  
  bool InspectorCanvasAgent::isShaderProgramHighlighted(WebGLProgram&amp; program)
  {
<span class="line-modified">!     auto* inspectorProgram = findInspectorProgram(program);</span>
      if (!inspectorProgram)
          return false;
  
      return inspectorProgram-&gt;highlighted();
  }
<span class="line-new-header">--- 518,83 ---</span>
          m_frontendDispatcher-&gt;recordingProgress(inspectorCanvas-&gt;identifier(), inspectorCanvas-&gt;releaseFrames(), inspectorCanvas-&gt;bufferUsed());
  
      if (!forceDispatch &amp;&amp; !inspectorCanvas-&gt;overFrameCount())
          return;
  
<span class="line-modified">!     m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), inspectorCanvas-&gt;releaseObjectForRecording());</span>
  }
  
  void InspectorCanvasAgent::consoleStartRecordingCanvas(CanvasRenderingContext&amp; context, JSC::ExecState&amp; exec, JSC::JSObject* options)
  {
<span class="line-modified">!     auto inspectorCanvas = findInspectorCanvas(context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      RecordingOptions recordingOptions;
      if (options) {
<span class="line-modified">!         JSC::VM&amp; vm = exec.vm();</span>
<span class="line-added">+         if (JSC::JSValue optionSingleFrame = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;singleFrame&quot;)))</span>
              recordingOptions.frameCount = optionSingleFrame.toBoolean(&amp;exec) ? 1 : 0;
<span class="line-modified">!         if (JSC::JSValue optionFrameCount = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;frameCount&quot;)))</span>
              recordingOptions.frameCount = optionFrameCount.toNumber(&amp;exec);
<span class="line-modified">!         if (JSC::JSValue optionMemoryLimit = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;memoryLimit&quot;)))</span>
              recordingOptions.memoryLimit = optionMemoryLimit.toNumber(&amp;exec);
<span class="line-modified">!         if (JSC::JSValue optionName = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;name&quot;)))</span>
              recordingOptions.name = optionName.toWTFString(&amp;exec);
      }
      startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Console, WTFMove(recordingOptions));
  }
  
  #if ENABLE(WEBGL)
  void InspectorCanvasAgent::didEnableExtension(WebGLRenderingContextBase&amp; context, const String&amp; extension)
  {
<span class="line-modified">!     auto inspectorCanvas = findInspectorCanvas(context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);
  }
  
  void InspectorCanvasAgent::didCreateProgram(WebGLRenderingContextBase&amp; context, WebGLProgram&amp; program)
  {
<span class="line-modified">!     auto inspectorCanvas = findInspectorCanvas(context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      auto inspectorProgram = InspectorShaderProgram::create(program, *inspectorCanvas);
      String programIdentifier = inspectorProgram-&gt;identifier();
      m_identifierToInspectorProgram.set(programIdentifier, WTFMove(inspectorProgram));
<span class="line-modified">!     m_frontendDispatcher-&gt;programCreated(inspectorCanvas-&gt;identifier(), programIdentifier);</span>
  }
  
  void InspectorCanvasAgent::willDeleteProgram(WebGLProgram&amp; program)
  {
<span class="line-modified">!     auto inspectorProgram = findInspectorProgram(program);</span>
      if (!inspectorProgram)
          return;
  
      String identifier = unbindProgram(*inspectorProgram);
<span class="line-modified">!     m_frontendDispatcher-&gt;programDeleted(identifier);</span>
  }
  
  bool InspectorCanvasAgent::isShaderProgramDisabled(WebGLProgram&amp; program)
  {
<span class="line-modified">!     auto inspectorProgram = findInspectorProgram(program);</span>
<span class="line-added">+     ASSERT(inspectorProgram);</span>
      if (!inspectorProgram)
          return false;
  
      return inspectorProgram-&gt;disabled();
  }
  
  bool InspectorCanvasAgent::isShaderProgramHighlighted(WebGLProgram&amp; program)
  {
<span class="line-modified">!     auto inspectorProgram = findInspectorProgram(program);</span>
<span class="line-added">+     ASSERT(inspectorProgram);</span>
      if (!inspectorProgram)
          return false;
  
      return inspectorProgram-&gt;highlighted();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 655,10 ***</span>
<span class="line-new-header">--- 605,13 ---</span>
      auto&amp; canvasRenderingContext = inspectorCanvas.context();
  
      if (!is&lt;CanvasRenderingContext2D&gt;(canvasRenderingContext)
  #if ENABLE(WEBGL)
          &amp;&amp; !is&lt;WebGLRenderingContext&gt;(canvasRenderingContext)
<span class="line-added">+ #endif</span>
<span class="line-added">+ #if ENABLE(WEBGL2)</span>
<span class="line-added">+         &amp;&amp; !is&lt;WebGL2RenderingContext&gt;(canvasRenderingContext)</span>
  #endif
          &amp;&amp; !is&lt;ImageBitmapRenderingContext&gt;(canvasRenderingContext))
          return;
  
      if (canvasRenderingContext.callTracingActive())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 679,46 ***</span>
  void InspectorCanvasAgent::canvasDestroyedTimerFired()
  {
      if (!m_removedCanvasIdentifiers.size())
          return;
  
<span class="line-modified">!     if (m_enabled) {</span>
<span class="line-modified">!         for (auto&amp; identifier : m_removedCanvasIdentifiers)</span>
<span class="line-removed">-             m_frontendDispatcher-&gt;canvasRemoved(identifier);</span>
<span class="line-removed">-     }</span>
  
      m_removedCanvasIdentifiers.clear();
  }
  
<span class="line-removed">- void InspectorCanvasAgent::canvasRecordingTimerFired()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {</span>
<span class="line-removed">-         if (!inspectorCanvas-&gt;context().callTracingActive())</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         didFinishRecordingCanvasFrame(inspectorCanvas-&gt;context());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void InspectorCanvasAgent::clearCanvasData()
  {
      for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values())
          inspectorCanvas-&gt;context().canvasBase().removeObserver(*this);
  
      m_identifierToInspectorCanvas.clear();
<span class="line-removed">-     m_removedCanvasIdentifiers.clear();</span>
  #if ENABLE(WEBGL)
      m_identifierToInspectorProgram.clear();
  #endif
  
<span class="line-removed">-     if (m_canvasRecordingTimer.isActive())</span>
<span class="line-removed">-         m_canvasRecordingTimer.stop();</span>
<span class="line-removed">- </span>
      if (m_canvasDestroyedTimer.isActive())
          m_canvasDestroyedTimer.stop();
  }
  
  String InspectorCanvasAgent::unbindCanvas(InspectorCanvas&amp; inspectorCanvas)
  {
  #if ENABLE(WEBGL)
      Vector&lt;InspectorShaderProgram*&gt; programsToRemove;
      for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
<span class="line-new-header">--- 632,55 ---</span>
  void InspectorCanvasAgent::canvasDestroyedTimerFired()
  {
      if (!m_removedCanvasIdentifiers.size())
          return;
  
<span class="line-modified">!     for (auto&amp; identifier : m_removedCanvasIdentifiers)</span>
<span class="line-modified">!         m_frontendDispatcher-&gt;canvasRemoved(identifier);</span>
  
      m_removedCanvasIdentifiers.clear();
  }
  
  void InspectorCanvasAgent::clearCanvasData()
  {
      for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values())
          inspectorCanvas-&gt;context().canvasBase().removeObserver(*this);
  
      m_identifierToInspectorCanvas.clear();
  #if ENABLE(WEBGL)
      m_identifierToInspectorProgram.clear();
<span class="line-added">+     m_removedCanvasIdentifiers.clear();</span>
  #endif
  
      if (m_canvasDestroyedTimer.isActive())
          m_canvasDestroyedTimer.stop();
  }
  
<span class="line-added">+ InspectorCanvas&amp; InspectorCanvasAgent::bindCanvas(CanvasRenderingContext&amp; context, bool captureBacktrace)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto inspectorCanvas = InspectorCanvas::create(context);</span>
<span class="line-added">+     m_identifierToInspectorCanvas.set(inspectorCanvas-&gt;identifier(), inspectorCanvas.copyRef());</span>
<span class="line-added">+ </span>
<span class="line-added">+     inspectorCanvas-&gt;context().canvasBase().addObserver(*this);</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_frontendDispatcher-&gt;canvasAdded(inspectorCanvas-&gt;buildObjectForCanvas(captureBacktrace));</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(WEBGL)</span>
<span class="line-added">+     if (is&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context())) {</span>
<span class="line-added">+         WebGLRenderingContextBase&amp; contextWebGL = downcast&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context());</span>
<span class="line-added">+         if (Optional&lt;Vector&lt;String&gt;&gt; extensions = contextWebGL.getSupportedExtensions()) {</span>
<span class="line-added">+             for (const String&amp; extension : *extensions) {</span>
<span class="line-added">+                 if (contextWebGL.extensionIsEnabled(extension))</span>
<span class="line-added">+                     m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     return inspectorCanvas;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  String InspectorCanvasAgent::unbindCanvas(InspectorCanvas&amp; inspectorCanvas)
  {
  #if ENABLE(WEBGL)
      Vector&lt;InspectorShaderProgram*&gt; programsToRemove;
      for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 728,34 ***</span>
  
      for (auto* inspectorProgram : programsToRemove)
          unbindProgram(*inspectorProgram);
  #endif
  
      String identifier = inspectorCanvas.identifier();
      m_identifierToInspectorCanvas.remove(identifier);
  
      return identifier;
  }
  
<span class="line-modified">! InspectorCanvas* InspectorCanvasAgent::assertInspectorCanvas(ErrorString&amp; errorString, const String&amp; identifier)</span>
  {
<span class="line-modified">!     RefPtr&lt;InspectorCanvas&gt; inspectorCanvas = m_identifierToInspectorCanvas.get(identifier);</span>
      if (!inspectorCanvas) {
<span class="line-modified">!         errorString = &quot;No canvas for given identifier.&quot;_s;</span>
          return nullptr;
      }
<span class="line-modified">! </span>
<span class="line-removed">-     return inspectorCanvas.get();</span>
  }
  
<span class="line-modified">! InspectorCanvas* InspectorCanvasAgent::findInspectorCanvas(CanvasRenderingContext&amp; context)</span>
  {
      for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
          if (&amp;inspectorCanvas-&gt;context() == &amp;context)
<span class="line-modified">!             return inspectorCanvas.get();</span>
      }
<span class="line-removed">- </span>
      return nullptr;
  }
  
  #if ENABLE(WEBGL)
  String InspectorCanvasAgent::unbindProgram(InspectorShaderProgram&amp; inspectorProgram)
<span class="line-new-header">--- 690,34 ---</span>
  
      for (auto* inspectorProgram : programsToRemove)
          unbindProgram(*inspectorProgram);
  #endif
  
<span class="line-added">+     inspectorCanvas.context().canvasBase().removeObserver(*this);</span>
<span class="line-added">+ </span>
      String identifier = inspectorCanvas.identifier();
      m_identifierToInspectorCanvas.remove(identifier);
  
      return identifier;
  }
  
<span class="line-modified">! RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::assertInspectorCanvas(ErrorString&amp; errorString, const String&amp; canvasId)</span>
  {
<span class="line-modified">!     auto inspectorCanvas = m_identifierToInspectorCanvas.get(canvasId);</span>
      if (!inspectorCanvas) {
<span class="line-modified">!         errorString = &quot;Missing canvas for given canvasId&quot;_s;</span>
          return nullptr;
      }
<span class="line-modified">!     return inspectorCanvas;</span>
  }
  
<span class="line-modified">! RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::findInspectorCanvas(CanvasRenderingContext&amp; context)</span>
  {
      for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
          if (&amp;inspectorCanvas-&gt;context() == &amp;context)
<span class="line-modified">!             return inspectorCanvas;</span>
      }
      return nullptr;
  }
  
  #if ENABLE(WEBGL)
  String InspectorCanvasAgent::unbindProgram(InspectorShaderProgram&amp; inspectorProgram)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 764,28 ***</span>
      m_identifierToInspectorProgram.remove(identifier);
  
      return identifier;
  }
  
<span class="line-modified">! InspectorShaderProgram* InspectorCanvasAgent::assertInspectorProgram(ErrorString&amp; errorString, const String&amp; identifier)</span>
  {
<span class="line-modified">!     RefPtr&lt;InspectorShaderProgram&gt; inspectorProgram = m_identifierToInspectorProgram.get(identifier);</span>
      if (!inspectorProgram) {
<span class="line-modified">!         errorString = &quot;No shader program for given identifier.&quot;_s;</span>
          return nullptr;
      }
<span class="line-modified">! </span>
<span class="line-removed">-     return inspectorProgram.get();</span>
  }
  
<span class="line-modified">! InspectorShaderProgram* InspectorCanvasAgent::findInspectorProgram(WebGLProgram&amp; program)</span>
  {
      for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
          if (&amp;inspectorProgram-&gt;program() == &amp;program)
<span class="line-modified">!             return inspectorProgram.get();</span>
      }
<span class="line-removed">- </span>
      return nullptr;
  }
  #endif
  
  } // namespace WebCore
<span class="line-new-header">--- 726,26 ---</span>
      m_identifierToInspectorProgram.remove(identifier);
  
      return identifier;
  }
  
<span class="line-modified">! RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::assertInspectorProgram(ErrorString&amp; errorString, const String&amp; programId)</span>
  {
<span class="line-modified">!     auto inspectorProgram = m_identifierToInspectorProgram.get(programId);</span>
      if (!inspectorProgram) {
<span class="line-modified">!         errorString = &quot;Missing program for given programId&quot;_s;</span>
          return nullptr;
      }
<span class="line-modified">!     return inspectorProgram;</span>
  }
  
<span class="line-modified">! RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::findInspectorProgram(WebGLProgram&amp; program)</span>
  {
      for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
          if (&amp;inspectorProgram-&gt;program() == &amp;program)
<span class="line-modified">!             return inspectorProgram;</span>
      }
      return nullptr;
  }
  #endif
  
  } // namespace WebCore
</pre>
<center><a href="InspectorCSSAgent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorCanvasAgent.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>