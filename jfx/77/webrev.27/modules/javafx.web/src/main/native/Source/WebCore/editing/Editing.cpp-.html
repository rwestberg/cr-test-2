<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/editing/Editing.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2004-2007, 2016 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Editing.h&quot;
  28 
  29 #include &quot;AXObjectCache.h&quot;
  30 #include &quot;Document.h&quot;
  31 #include &quot;Editor.h&quot;
  32 #include &quot;Frame.h&quot;
  33 #include &quot;HTMLBodyElement.h&quot;
  34 #include &quot;HTMLDListElement.h&quot;
  35 #include &quot;HTMLDivElement.h&quot;
  36 #include &quot;HTMLElementFactory.h&quot;
  37 #include &quot;HTMLInterchange.h&quot;
  38 #include &quot;HTMLLIElement.h&quot;
  39 #include &quot;HTMLNames.h&quot;
  40 #include &quot;HTMLOListElement.h&quot;
  41 #include &quot;HTMLParagraphElement.h&quot;
  42 #include &quot;HTMLSpanElement.h&quot;
  43 #include &quot;HTMLTableElement.h&quot;
  44 #include &quot;HTMLTextFormControlElement.h&quot;
  45 #include &quot;HTMLUListElement.h&quot;
  46 #include &quot;NodeTraversal.h&quot;
  47 #include &quot;PositionIterator.h&quot;
  48 #include &quot;RenderBlock.h&quot;
  49 #include &quot;RenderElement.h&quot;
  50 #include &quot;RenderTableCell.h&quot;
  51 #include &quot;ShadowRoot.h&quot;
  52 #include &quot;Text.h&quot;
  53 #include &quot;TextIterator.h&quot;
  54 #include &quot;VisibleUnits.h&quot;
  55 #include &lt;wtf/Assertions.h&gt;
  56 #include &lt;wtf/StdLibExtras.h&gt;
  57 #include &lt;wtf/text/StringBuilder.h&gt;
  58 #include &lt;wtf/unicode/CharacterNames.h&gt;
  59 
  60 namespace WebCore {
  61 
  62 using namespace HTMLNames;
  63 
  64 static bool isVisiblyAdjacent(const Position&amp;, const Position&amp;);
  65 
  66 bool canHaveChildrenForEditing(const Node&amp; node)
  67 {
  68     return !is&lt;Text&gt;(node) &amp;&amp; node.canContainRangeEndPoint();
  69 }
  70 
  71 // Atomic means that the node has no children, or has children which are ignored for the purposes of editing.
  72 bool isAtomicNode(const Node* node)
  73 {
  74     return node &amp;&amp; (!node-&gt;hasChildNodes() || editingIgnoresContent(*node));
  75 }
  76 
  77 // Compare two positions, taking into account the possibility that one or both
  78 // could be inside a shadow tree. Only works for non-null values.
  79 int comparePositions(const Position&amp; a, const Position&amp; b)
  80 {
  81     TreeScope* commonScope = commonTreeScope(a.containerNode(), b.containerNode());
  82 
  83     if (!commonScope)
  84         return 0;
  85 
  86     Node* nodeA = commonScope-&gt;ancestorNodeInThisScope(a.containerNode());
  87     ASSERT(nodeA);
  88     bool hasDescendentA = nodeA != a.containerNode();
  89     int offsetA = hasDescendentA ? 0 : a.computeOffsetInContainerNode();
  90 
  91     Node* nodeB = commonScope-&gt;ancestorNodeInThisScope(b.containerNode());
  92     ASSERT(nodeB);
  93     bool hasDescendentB = nodeB != b.containerNode();
  94     int offsetB = hasDescendentB ? 0 : b.computeOffsetInContainerNode();
  95 
  96     int bias = 0;
  97     if (nodeA == nodeB) {
  98         if (hasDescendentA)
  99             bias = -1;
 100         else if (hasDescendentB)
 101             bias = 1;
 102     }
 103 
 104     auto comparisonResult = Range::compareBoundaryPoints(nodeA, offsetA, nodeB, offsetB);
 105     if (comparisonResult.hasException())
 106         return bias;
 107     auto result = comparisonResult.releaseReturnValue();
 108     return result ? result : bias;
 109 }
 110 
 111 int comparePositions(const VisiblePosition&amp; a, const VisiblePosition&amp; b)
 112 {
 113     return comparePositions(a.deepEquivalent(), b.deepEquivalent());
 114 }
 115 
 116 ContainerNode* highestEditableRoot(const Position&amp; position, EditableType editableType)
 117 {
 118     ContainerNode* highestEditableRoot = editableRootForPosition(position, editableType);
 119     if (!highestEditableRoot)
 120         return nullptr;
 121 
 122     for (ContainerNode* node = highestEditableRoot; !is&lt;HTMLBodyElement&gt;(*node); ) {
 123         node = node-&gt;parentNode();
 124         if (!node)
 125             break;
 126         // FIXME: Can this ever be a Document or DocumentFragment? If not, this should return Element* instead.
 127         if (hasEditableStyle(*node, editableType))
 128             highestEditableRoot = node;
 129     }
 130 
 131     return highestEditableRoot;
 132 }
 133 
 134 Element* lowestEditableAncestor(Node* node)
 135 {
 136     for (; node; node = node-&gt;parentNode()) {
 137         if (node-&gt;hasEditableStyle())
 138             return node-&gt;rootEditableElement();
 139         if (is&lt;HTMLBodyElement&gt;(*node))
 140             break;
 141     }
 142     return nullptr;
 143 }
 144 
 145 static bool isEditableToAccessibility(const Node&amp; node)
 146 {
 147     ASSERT(AXObjectCache::accessibilityEnabled());
 148     ASSERT(node.document().existingAXObjectCache());
 149 
 150     if (auto* cache = node.document().existingAXObjectCache())
 151         return cache-&gt;rootAXEditableElement(&amp;node);
 152 
 153     return false;
 154 }
 155 
 156 static bool computeEditability(const Node&amp; node, EditableType editableType, Node::ShouldUpdateStyle shouldUpdateStyle)
 157 {
 158     if (node.computeEditability(Node::UserSelectAllIsAlwaysNonEditable, shouldUpdateStyle) != Node::Editability::ReadOnly)
 159         return true;
 160 
 161     switch (editableType) {
 162     case ContentIsEditable:
 163         return false;
 164     case HasEditableAXRole:
 165         return isEditableToAccessibility(node);
 166     }
 167     ASSERT_NOT_REACHED();
 168     return false;
 169 }
 170 
 171 bool hasEditableStyle(const Node&amp; node, EditableType editableType)
 172 {
 173     return computeEditability(node, editableType, Node::ShouldUpdateStyle::DoNotUpdate);
 174 }
 175 
 176 bool isEditableNode(const Node&amp; node)
 177 {
 178     return computeEditability(node, ContentIsEditable, Node::ShouldUpdateStyle::Update);
 179 }
 180 
 181 bool isEditablePosition(const Position&amp; position, EditableType editableType)
 182 {
 183     Node* node = position.containerNode();
 184     return node &amp;&amp; computeEditability(*node, editableType, Node::ShouldUpdateStyle::Update);
 185 }
 186 
 187 bool isAtUnsplittableElement(const Position&amp; position)
 188 {
 189     Node* node = position.containerNode();
 190     return node == editableRootForPosition(position) || node == enclosingNodeOfType(position, isTableCell);
 191 }
 192 
 193 bool isRichlyEditablePosition(const Position&amp; position)
 194 {
 195     auto* node = position.containerNode();
 196     return node &amp;&amp; node-&gt;hasRichlyEditableStyle();
 197 }
 198 
 199 Element* editableRootForPosition(const Position&amp; position, EditableType editableType)
 200 {
 201     Node* node = position.containerNode();
 202     if (!node)
 203         return nullptr;
 204 
 205     switch (editableType) {
 206     case HasEditableAXRole:
 207         if (auto* cache = node-&gt;document().existingAXObjectCache())
 208             return const_cast&lt;Element*&gt;(cache-&gt;rootAXEditableElement(node));
 209         FALLTHROUGH;
 210     case ContentIsEditable:
 211         return node-&gt;rootEditableElement();
 212     }
 213     return nullptr;
 214 }
 215 
 216 // Finds the enclosing element until which the tree can be split.
 217 // When a user hits ENTER, he/she won&#39;t expect this element to be split into two.
 218 // You may pass it as the second argument of splitTreeToNode.
 219 Element* unsplittableElementForPosition(const Position&amp; position)
 220 {
 221     // Since enclosingNodeOfType won&#39;t search beyond the highest root editable node,
 222     // this code works even if the closest table cell was outside of the root editable node.
 223     if (auto* enclosingCell = downcast&lt;Element&gt;(enclosingNodeOfType(position, &amp;isTableCell)))
 224         return enclosingCell;
 225     return editableRootForPosition(position);
 226 }
 227 
 228 Position nextCandidate(const Position&amp; position)
 229 {
 230     for (PositionIterator nextPosition = position; !nextPosition.atEnd(); ) {
 231         nextPosition.increment();
 232         if (nextPosition.isCandidate())
 233             return nextPosition;
 234     }
 235     return { };
 236 }
 237 
 238 Position nextVisuallyDistinctCandidate(const Position&amp; position)
 239 {
 240     // FIXME: Use PositionIterator instead.
 241     Position nextPosition = position;
 242     Position downstreamStart = nextPosition.downstream();
 243     while (!nextPosition.atEndOfTree()) {
 244         nextPosition = nextPosition.next(Character);
 245         if (nextPosition.isCandidate() &amp;&amp; nextPosition.downstream() != downstreamStart)
 246             return nextPosition;
 247         if (auto* node = nextPosition.containerNode()) {
 248             if (!node-&gt;renderer())
 249                 nextPosition = lastPositionInOrAfterNode(node);
 250         }
 251     }
 252     return { };
 253 }
 254 
 255 Position previousCandidate(const Position&amp; position)
 256 {
 257     PositionIterator previousPosition = position;
 258     while (!previousPosition.atStart()) {
 259         previousPosition.decrement();
 260         if (previousPosition.isCandidate())
 261             return previousPosition;
 262     }
 263     return { };
 264 }
 265 
 266 Position previousVisuallyDistinctCandidate(const Position&amp; position)
 267 {
 268     // FIXME: Use PositionIterator instead.
 269     Position previousPosition = position;
 270     Position downstreamStart = previousPosition.downstream();
 271     while (!previousPosition.atStartOfTree()) {
 272         previousPosition = previousPosition.previous(Character);
 273         if (previousPosition.isCandidate() &amp;&amp; previousPosition.downstream() != downstreamStart)
 274             return previousPosition;
 275         if (auto* node = previousPosition.containerNode()) {
 276             if (!node-&gt;renderer())
 277                 previousPosition = firstPositionInOrBeforeNode(node);
 278         }
 279     }
 280     return { };
 281 }
 282 
 283 Position firstEditablePositionAfterPositionInRoot(const Position&amp; position, ContainerNode* highestRoot)
 284 {
 285     if (!highestRoot)
 286         return { };
 287 
 288     // position falls before highestRoot.
 289     if (comparePositions(position, firstPositionInNode(highestRoot)) == -1 &amp;&amp; highestRoot-&gt;hasEditableStyle())
 290         return firstPositionInNode(highestRoot);
 291 
 292     Position candidate = position;
 293 
 294     if (&amp;position.deprecatedNode()-&gt;treeScope() != &amp;highestRoot-&gt;treeScope()) {
 295         auto* shadowAncestor = highestRoot-&gt;treeScope().ancestorNodeInThisScope(position.deprecatedNode());
 296         if (!shadowAncestor)
 297             return { };
 298 
 299         candidate = positionAfterNode(shadowAncestor);
 300     }
 301 
 302     while (candidate.deprecatedNode() &amp;&amp; !isEditablePosition(candidate) &amp;&amp; candidate.deprecatedNode()-&gt;isDescendantOf(*highestRoot))
 303         candidate = isAtomicNode(candidate.deprecatedNode()) ? positionInParentAfterNode(candidate.deprecatedNode()) : nextVisuallyDistinctCandidate(candidate);
 304 
 305     if (candidate.deprecatedNode() &amp;&amp; candidate.deprecatedNode() != highestRoot &amp;&amp; !candidate.deprecatedNode()-&gt;isDescendantOf(*highestRoot))
 306         return { };
 307 
 308     return candidate;
 309 }
 310 
 311 Position lastEditablePositionBeforePositionInRoot(const Position&amp; position, ContainerNode* highestRoot)
 312 {
 313     if (!highestRoot)
 314         return { };
 315 
 316     // When position falls after highestRoot, the result is easy to compute.
 317     if (comparePositions(position, lastPositionInNode(highestRoot)) == 1)
 318         return lastPositionInNode(highestRoot);
 319 
 320     Position candidate = position;
 321 
 322     if (&amp;position.deprecatedNode()-&gt;treeScope() != &amp;highestRoot-&gt;treeScope()) {
 323         auto* shadowAncestor = highestRoot-&gt;treeScope().ancestorNodeInThisScope(position.deprecatedNode());
 324         if (!shadowAncestor)
 325             return { };
 326 
 327         candidate = firstPositionInOrBeforeNode(shadowAncestor);
 328     }
 329 
 330     while (candidate.deprecatedNode() &amp;&amp; !isEditablePosition(candidate) &amp;&amp; candidate.deprecatedNode()-&gt;isDescendantOf(*highestRoot))
 331         candidate = isAtomicNode(candidate.deprecatedNode()) ? positionInParentBeforeNode(candidate.deprecatedNode()) : previousVisuallyDistinctCandidate(candidate);
 332 
 333     if (candidate.deprecatedNode() &amp;&amp; candidate.deprecatedNode() != highestRoot &amp;&amp; !candidate.deprecatedNode()-&gt;isDescendantOf(*highestRoot))
 334         return { };
 335 
 336     return candidate;
 337 }
 338 
 339 // FIXME: The function name, comment, and code say three different things here!
 340 // Whether or not content before and after this node will collapse onto the same line as it.
 341 bool isBlock(const Node* node)
 342 {
 343     return node &amp;&amp; node-&gt;renderer() &amp;&amp; !node-&gt;renderer()-&gt;isInline() &amp;&amp; !node-&gt;renderer()-&gt;isRubyText();
 344 }
 345 
 346 bool isInline(const Node* node)
 347 {
 348     return node &amp;&amp; node-&gt;renderer() &amp;&amp; node-&gt;renderer()-&gt;isInline();
 349 }
 350 
 351 // FIXME: Deploy this in all of the places where enclosingBlockFlow/enclosingBlockFlowOrTableElement are used.
 352 // FIXME: Pass a position to this function. The enclosing block of [table, x] for example, should be the
 353 // block that contains the table and not the table, and this function should be the only one responsible for
 354 // knowing about these kinds of special cases.
 355 Element* enclosingBlock(Node* node, EditingBoundaryCrossingRule rule)
 356 {
 357     Node* enclosingNode = enclosingNodeOfType(firstPositionInOrBeforeNode(node), isBlock, rule);
 358     return is&lt;Element&gt;(enclosingNode) ? downcast&lt;Element&gt;(enclosingNode) : nullptr;
 359 }
 360 
 361 TextDirection directionOfEnclosingBlock(const Position&amp; position)
 362 {
 363     auto block = enclosingBlock(position.containerNode());
 364     if (!block)
 365         return TextDirection::LTR;
 366     auto renderer = block-&gt;renderer();
 367     if (!renderer)
 368         return TextDirection::LTR;
 369     return renderer-&gt;style().direction();
 370 }
 371 
 372 // This method is used to create positions in the DOM. It returns the maximum valid offset
 373 // in a node. It returns 1 for some elements even though they do not have children, which
 374 // creates technically invalid DOM Positions. Be sure to call parentAnchoredEquivalent
 375 // on a Position before using it to create a DOM Range, or an exception will be thrown.
 376 int lastOffsetForEditing(const Node&amp; node)
 377 {
 378     if (node.isCharacterDataNode())
 379         return node.maxCharacterOffset();
 380 
 381     if (node.hasChildNodes())
 382         return node.countChildNodes();
 383 
 384     // NOTE: This should preempt the countChildNodes() for, e.g., select nodes.
 385     // FIXME: What does the comment above mean?
 386     if (editingIgnoresContent(node))
 387         return 1;
 388 
 389     return 0;
 390 }
 391 
 392 bool isAmbiguousBoundaryCharacter(UChar character)
 393 {
 394     // These are characters that can behave as word boundaries, but can appear within words.
 395     // If they are just typed, i.e. if they are immediately followed by a caret, we want to delay text checking until the next character has been typed.
 396     // FIXME: this is required until &lt;rdar://problem/6853027&gt; is fixed and text checking can do this for us.
 397     return character == &#39;\&#39;&#39; || character == &#39;@&#39; || character == rightSingleQuotationMark || character == hebrewPunctuationGershayim;
 398 }
 399 
 400 String stringWithRebalancedWhitespace(const String&amp; string, bool startIsStartOfParagraph, bool endIsEndOfParagraph)
 401 {
 402     StringBuilder rebalancedString;
 403 
 404     bool previousCharacterWasSpace = false;
 405     unsigned length = string.length();
 406     for (unsigned i = 0; i &lt; length; ++i) {
 407         auto character = string[i];
 408         if (!deprecatedIsEditingWhitespace(character)) {
 409             previousCharacterWasSpace = false;
 410             continue;
 411         }
 412         LChar selectedWhitespaceCharacter;
 413         if (previousCharacterWasSpace || (!i &amp;&amp; startIsStartOfParagraph) || (i == length - 1 &amp;&amp; endIsEndOfParagraph)) {
 414             selectedWhitespaceCharacter = noBreakSpace;
 415             previousCharacterWasSpace = false;
 416         } else {
 417             selectedWhitespaceCharacter = &#39; &#39;;
 418             previousCharacterWasSpace = true;
 419         }
 420         if (character == selectedWhitespaceCharacter)
 421             continue;
 422         rebalancedString.reserveCapacity(length);
 423         rebalancedString.append(string, rebalancedString.length(), i - rebalancedString.length());
 424         rebalancedString.append(selectedWhitespaceCharacter);
 425     }
 426 
 427     if (rebalancedString.isEmpty())
 428         return string;
 429 
 430     rebalancedString.reserveCapacity(length);
 431     rebalancedString.append(string, rebalancedString.length(), length - rebalancedString.length());
 432     return rebalancedString.toString();
 433 }
 434 
 435 bool isTableStructureNode(const Node* node)
 436 {
 437     auto* renderer = node-&gt;renderer();
 438     return renderer &amp;&amp; (renderer-&gt;isTableCell() || renderer-&gt;isTableRow() || renderer-&gt;isTableSection() || renderer-&gt;isRenderTableCol());
 439 }
 440 
 441 const String&amp; nonBreakingSpaceString()
 442 {
 443     static NeverDestroyed&lt;String&gt; nonBreakingSpaceString(&amp;noBreakSpace, 1);
 444     return nonBreakingSpaceString;
 445 }
 446 
 447 static bool isSpecialHTMLElement(const Node* node)
 448 {
 449     if (!is&lt;HTMLElement&gt;(node))
 450         return false;
 451 
 452     if (downcast&lt;HTMLElement&gt;(*node).isLink())
 453         return true;
 454 
 455     auto* renderer = downcast&lt;HTMLElement&gt;(*node).renderer();
 456     if (!renderer)
 457         return false;
 458 
 459     if (renderer-&gt;style().display() == DisplayType::Table || renderer-&gt;style().display() == DisplayType::InlineTable)
 460         return true;
 461 
 462     if (renderer-&gt;style().isFloating())
 463         return true;
 464 
 465     if (renderer-&gt;style().position() != PositionType::Static)
 466         return true;
 467 
 468     return false;
 469 }
 470 
 471 static HTMLElement* firstInSpecialElement(const Position&amp; position)
 472 {
 473     auto* rootEditableElement = position.containerNode()-&gt;rootEditableElement();
 474     for (Node* node = position.deprecatedNode(); node &amp;&amp; node-&gt;rootEditableElement() == rootEditableElement; node = node-&gt;parentNode()) {
 475         if (!isSpecialHTMLElement(node))
 476             continue;
 477         VisiblePosition vPos(position, DOWNSTREAM);
 478         VisiblePosition firstInElement(firstPositionInOrBeforeNode(node), DOWNSTREAM);
 479         if ((isRenderedTable(node) &amp;&amp; vPos == firstInElement.next()) || vPos == firstInElement)
 480             return &amp;downcast&lt;HTMLElement&gt;(*node);
 481     }
 482     return nullptr;
 483 }
 484 
 485 static HTMLElement* lastInSpecialElement(const Position&amp; position)
 486 {
 487     auto* rootEditableElement = position.containerNode()-&gt;rootEditableElement();
 488     for (Node* node = position.deprecatedNode(); node &amp;&amp; node-&gt;rootEditableElement() == rootEditableElement; node = node-&gt;parentNode()) {
 489         if (!isSpecialHTMLElement(node))
 490             continue;
 491         VisiblePosition vPos(position, DOWNSTREAM);
 492         VisiblePosition lastInElement(lastPositionInOrAfterNode(node), DOWNSTREAM);
 493         if ((isRenderedTable(node) &amp;&amp; vPos == lastInElement.previous()) || vPos == lastInElement)
 494             return &amp;downcast&lt;HTMLElement&gt;(*node);
 495     }
 496     return nullptr;
 497 }
 498 
 499 Position positionBeforeContainingSpecialElement(const Position&amp; position, HTMLElement** containingSpecialElement)
 500 {
 501     auto* element = firstInSpecialElement(position);
 502     if (!element)
 503         return position;
 504     Position result = positionInParentBeforeNode(element);
 505     if (result.isNull() || result.deprecatedNode()-&gt;rootEditableElement() != position.deprecatedNode()-&gt;rootEditableElement())
 506         return position;
 507     if (containingSpecialElement)
 508         *containingSpecialElement = element;
 509     return result;
 510 }
 511 
 512 Position positionAfterContainingSpecialElement(const Position&amp; position, HTMLElement** containingSpecialElement)
 513 {
 514     auto* element = lastInSpecialElement(position);
 515     if (!element)
 516         return position;
 517     Position result = positionInParentAfterNode(element);
 518     if (result.isNull() || result.deprecatedNode()-&gt;rootEditableElement() != position.deprecatedNode()-&gt;rootEditableElement())
 519         return position;
 520     if (containingSpecialElement)
 521         *containingSpecialElement = element;
 522     return result;
 523 }
 524 
 525 Element* isFirstPositionAfterTable(const VisiblePosition&amp; position)
 526 {
 527     Position upstream(position.deepEquivalent().upstream());
 528     auto* node = upstream.deprecatedNode();
 529     if (!node)
 530         return nullptr;
 531     auto* renderer = node-&gt;renderer();
 532     if (!renderer || !renderer-&gt;isTable() || !upstream.atLastEditingPositionForNode())
 533         return nullptr;
 534     return &amp;downcast&lt;Element&gt;(*node);
 535 }
 536 
 537 Element* isLastPositionBeforeTable(const VisiblePosition&amp; position)
 538 {
 539     Position downstream(position.deepEquivalent().downstream());
 540     auto* node = downstream.deprecatedNode();
 541     if (!node)
 542         return nullptr;
 543     auto* renderer = node-&gt;renderer();
 544     if (!renderer || !renderer-&gt;isTable() || !downstream.atFirstEditingPositionForNode())
 545         return nullptr;
 546     return &amp;downcast&lt;Element&gt;(*node);
 547 }
 548 
 549 // Returns the visible position at the beginning of a node
 550 VisiblePosition visiblePositionBeforeNode(Node&amp; node)
 551 {
 552     if (node.hasChildNodes())
 553         return VisiblePosition(firstPositionInOrBeforeNode(&amp;node), DOWNSTREAM);
 554     ASSERT(node.parentNode());
 555     ASSERT(!node.parentNode()-&gt;isShadowRoot());
 556     return positionInParentBeforeNode(&amp;node);
 557 }
 558 
 559 // Returns the visible position at the ending of a node
 560 VisiblePosition visiblePositionAfterNode(Node&amp; node)
 561 {
 562     if (node.hasChildNodes())
 563         return VisiblePosition(lastPositionInOrAfterNode(&amp;node), DOWNSTREAM);
 564     ASSERT(node.parentNode());
 565     ASSERT(!node.parentNode()-&gt;isShadowRoot());
 566     return positionInParentAfterNode(&amp;node);
 567 }
 568 
 569 bool isListHTMLElement(Node* node)
 570 {
 571     return node &amp;&amp; (is&lt;HTMLUListElement&gt;(*node) || is&lt;HTMLOListElement&gt;(*node) || is&lt;HTMLDListElement&gt;(*node));
 572 }
 573 
 574 bool isListItem(const Node* node)
 575 {
 576     return node &amp;&amp; (isListHTMLElement(node-&gt;parentNode()) || (node-&gt;renderer() &amp;&amp; node-&gt;renderer()-&gt;isListItem()));
 577 }
 578 
 579 Element* enclosingElementWithTag(const Position&amp; position, const QualifiedName&amp; tagName)
 580 {
 581     auto* root = highestEditableRoot(position);
 582     for (Node* node = position.deprecatedNode(); node; node = node-&gt;parentNode()) {
 583         if (root &amp;&amp; !node-&gt;hasEditableStyle())
 584             continue;
 585         if (!is&lt;Element&gt;(*node))
 586             continue;
 587         if (downcast&lt;Element&gt;(*node).hasTagName(tagName))
 588             return &amp;downcast&lt;Element&gt;(*node);
 589         if (node == root)
 590             return nullptr;
 591     }
 592     return nullptr;
 593 }
 594 
 595 Node* enclosingNodeOfType(const Position&amp; position, bool (*nodeIsOfType)(const Node*), EditingBoundaryCrossingRule rule)
 596 {
 597     // FIXME: support CanSkipCrossEditingBoundary
 598     ASSERT(rule == CanCrossEditingBoundary || rule == CannotCrossEditingBoundary);
 599     auto* root = rule == CannotCrossEditingBoundary ? highestEditableRoot(position) : nullptr;
 600     for (Node* n = position.deprecatedNode(); n; n = n-&gt;parentNode()) {
 601         // Don&#39;t return a non-editable node if the input position was editable, since
 602         // the callers from editing will no doubt want to perform editing inside the returned node.
 603         if (root &amp;&amp; !n-&gt;hasEditableStyle())
 604             continue;
 605         if (nodeIsOfType(n))
 606             return n;
 607         if (n == root)
 608             return nullptr;
 609     }
 610     return nullptr;
 611 }
 612 
 613 Node* highestEnclosingNodeOfType(const Position&amp; position, bool (*nodeIsOfType)(const Node*), EditingBoundaryCrossingRule rule, Node* stayWithin)
 614 {
 615     Node* highest = nullptr;
 616     auto* root = rule == CannotCrossEditingBoundary ? highestEditableRoot(position) : nullptr;
 617     for (Node* n = position.containerNode(); n &amp;&amp; n != stayWithin; n = n-&gt;parentNode()) {
 618         if (root &amp;&amp; !n-&gt;hasEditableStyle())
 619             continue;
 620         if (nodeIsOfType(n))
 621             highest = n;
 622         if (n == root)
 623             break;
 624     }
 625     return highest;
 626 }
 627 
 628 static bool hasARenderedDescendant(Node* node, Node* excludedNode)
 629 {
 630     for (Node* n = node-&gt;firstChild(); n;) {
 631         if (n == excludedNode) {
 632             n = NodeTraversal::nextSkippingChildren(*n, node);
 633             continue;
 634         }
 635         if (n-&gt;renderer())
 636             return true;
 637         n = NodeTraversal::next(*n, node);
 638     }
 639     return false;
 640 }
 641 
 642 Node* highestNodeToRemoveInPruning(Node* node)
 643 {
 644     Node* previousNode = nullptr;
 645     auto* rootEditableElement = node ? node-&gt;rootEditableElement() : nullptr;
 646     for (; node; node = node-&gt;parentNode()) {
 647         if (auto* renderer = node-&gt;renderer()) {
 648             if (!renderer-&gt;canHaveChildren() || hasARenderedDescendant(node, previousNode) || rootEditableElement == node)
 649                 return previousNode;
 650         }
 651         previousNode = node;
 652     }
 653     return nullptr;
 654 }
 655 
 656 Element* enclosingTableCell(const Position&amp; position)
 657 {
 658     return downcast&lt;Element&gt;(enclosingNodeOfType(position, isTableCell));
 659 }
 660 
 661 Element* enclosingAnchorElement(const Position&amp; p)
 662 {
 663     for (Node* node = p.deprecatedNode(); node; node = node-&gt;parentNode()) {
 664         if (is&lt;Element&gt;(*node) &amp;&amp; node-&gt;isLink())
 665             return downcast&lt;Element&gt;(node);
 666     }
 667     return nullptr;
 668 }
 669 
 670 HTMLElement* enclosingList(Node* node)
 671 {
 672     if (!node)
 673         return nullptr;
 674 
 675     auto* root = highestEditableRoot(firstPositionInOrBeforeNode(node));
 676 
 677     for (ContainerNode* ancestor = node-&gt;parentNode(); ancestor; ancestor = ancestor-&gt;parentNode()) {
 678         if (is&lt;HTMLUListElement&gt;(*ancestor) || is&lt;HTMLOListElement&gt;(*ancestor))
 679             return downcast&lt;HTMLElement&gt;(ancestor);
 680         if (ancestor == root)
 681             return nullptr;
 682     }
 683 
 684     return nullptr;
 685 }
 686 
 687 Node* enclosingListChild(Node *node)
 688 {
 689     if (!node)
 690         return nullptr;
 691 
 692     // Check for a list item element, or for a node whose parent is a list element. Such a node
 693     // will appear visually as a list item (but without a list marker)
 694     auto* root = highestEditableRoot(firstPositionInOrBeforeNode(node));
 695 
 696     // FIXME: This function is inappropriately named since it starts with node instead of node-&gt;parentNode()
 697     for (Node* n = node; n &amp;&amp; n-&gt;parentNode(); n = n-&gt;parentNode()) {
 698         if (is&lt;HTMLLIElement&gt;(*n) || (isListHTMLElement(n-&gt;parentNode()) &amp;&amp; n != root))
 699             return n;
 700         if (n == root || isTableCell(n))
 701             return nullptr;
 702     }
 703 
 704     return nullptr;
 705 }
 706 
 707 static HTMLElement* embeddedSublist(Node* listItem)
 708 {
 709     // Check the DOM so that we&#39;ll find collapsed sublists without renderers.
 710     for (Node* n = listItem-&gt;firstChild(); n; n = n-&gt;nextSibling()) {
 711         if (isListHTMLElement(n))
 712             return downcast&lt;HTMLElement&gt;(n);
 713     }
 714     return nullptr;
 715 }
 716 
 717 static Node* appendedSublist(Node* listItem)
 718 {
 719     // Check the DOM so that we&#39;ll find collapsed sublists without renderers.
 720     for (Node* n = listItem-&gt;nextSibling(); n; n = n-&gt;nextSibling()) {
 721         if (isListHTMLElement(n))
 722             return downcast&lt;HTMLElement&gt;(n);
 723         if (isListItem(listItem))
 724             return nullptr;
 725     }
 726 
 727     return nullptr;
 728 }
 729 
 730 // FIXME: This function should not need to call isStartOfParagraph/isEndOfParagraph.
 731 Node* enclosingEmptyListItem(const VisiblePosition&amp; position)
 732 {
 733     // Check that position is on a line by itself inside a list item
 734     auto* listChildNode = enclosingListChild(position.deepEquivalent().deprecatedNode());
 735     if (!listChildNode || !isStartOfParagraph(position) || !isEndOfParagraph(position))
 736         return nullptr;
 737 
 738     VisiblePosition firstInListChild(firstPositionInOrBeforeNode(listChildNode));
 739     VisiblePosition lastInListChild(lastPositionInOrAfterNode(listChildNode));
 740 
 741     if (firstInListChild != position || lastInListChild != position)
 742         return nullptr;
 743 
 744     if (embeddedSublist(listChildNode) || appendedSublist(listChildNode))
 745         return nullptr;
 746 
 747     return listChildNode;
 748 }
 749 
 750 HTMLElement* outermostEnclosingList(Node* node, Node* rootList)
 751 {
 752     auto* list = enclosingList(node);
 753     if (!list)
 754         return nullptr;
 755 
 756     while (auto* nextList = enclosingList(list)) {
 757         if (nextList == rootList)
 758             break;
 759         list = nextList;
 760     }
 761 
 762     return list;
 763 }
 764 
 765 bool canMergeLists(Element* firstList, Element* secondList)
 766 {
 767     if (!is&lt;HTMLElement&gt;(firstList) || !is&lt;HTMLElement&gt;(secondList))
 768         return false;
 769 
 770     auto&amp; first = downcast&lt;HTMLElement&gt;(*firstList);
 771     auto&amp; second = downcast&lt;HTMLElement&gt;(*secondList);
 772 
 773     return first.localName() == second.localName() // make sure the list types match (ol vs. ul)
 774         &amp;&amp; first.hasEditableStyle() &amp;&amp; second.hasEditableStyle() // both lists are editable
 775         &amp;&amp; first.rootEditableElement() == second.rootEditableElement() // don&#39;t cross editing boundaries
 776         // Make sure there is no visible content between this li and the previous list.
 777         &amp;&amp; isVisiblyAdjacent(positionInParentAfterNode(&amp;first), positionInParentBeforeNode(&amp;second));
 778 }
 779 
 780 static Node* previousNodeConsideringAtomicNodes(const Node* node)
 781 {
 782     if (node-&gt;previousSibling()) {
 783         Node* n = node-&gt;previousSibling();
 784         while (!isAtomicNode(n) &amp;&amp; n-&gt;lastChild())
 785             n = n-&gt;lastChild();
 786         return n;
 787     }
 788     if (node-&gt;parentNode())
 789         return node-&gt;parentNode();
 790     return nullptr;
 791 }
 792 
 793 static Node* nextNodeConsideringAtomicNodes(const Node* node)
 794 {
 795     if (!isAtomicNode(node) &amp;&amp; node-&gt;firstChild())
 796         return node-&gt;firstChild();
 797     if (node-&gt;nextSibling())
 798         return node-&gt;nextSibling();
 799     const Node* n = node;
 800     while (n &amp;&amp; !n-&gt;nextSibling())
 801         n = n-&gt;parentNode();
 802     if (n)
 803         return n-&gt;nextSibling();
 804     return nullptr;
 805 }
 806 
 807 Node* previousLeafNode(const Node* node)
 808 {
 809     while ((node = previousNodeConsideringAtomicNodes(node))) {
 810         if (isAtomicNode(node))
 811             return const_cast&lt;Node*&gt;(node);
 812     }
 813     return nullptr;
 814 }
 815 
 816 Node* nextLeafNode(const Node* node)
 817 {
 818     while ((node = nextNodeConsideringAtomicNodes(node))) {
 819         if (isAtomicNode(node))
 820             return const_cast&lt;Node*&gt;(node);
 821     }
 822     return nullptr;
 823 }
 824 
 825 // FIXME: Do not require renderer, so that this can be used within fragments.
 826 bool isRenderedTable(const Node* node)
 827 {
 828     if (!is&lt;Element&gt;(node))
 829         return false;
 830     auto* renderer = downcast&lt;Element&gt;(*node).renderer();
 831     return renderer &amp;&amp; renderer-&gt;isTable();
 832 }
 833 
 834 bool isTableCell(const Node* node)
 835 {
 836     auto* renderer = node-&gt;renderer();
 837     if (!renderer)
 838         return node-&gt;hasTagName(tdTag) || node-&gt;hasTagName(thTag);
 839     return renderer-&gt;isTableCell();
 840 }
 841 
 842 bool isEmptyTableCell(const Node* node)
 843 {
 844     // Returns true IFF the passed in node is one of:
 845     //   .) a table cell with no children,
 846     //   .) a table cell with a single BR child, and which has no other child renderers, including :before and :after renderers
 847     //   .) the BR child of such a table cell
 848 
 849     // Find rendered node
 850     while (node &amp;&amp; !node-&gt;renderer())
 851         node = node-&gt;parentNode();
 852     if (!node)
 853         return false;
 854 
 855     // Make sure the rendered node is a table cell or &lt;br&gt;.
 856     // If it&#39;s a &lt;br&gt;, then the parent node has to be a table cell.
 857     auto* renderer = node-&gt;renderer();
 858     if (renderer-&gt;isBR()) {
 859         renderer = renderer-&gt;parent();
 860         if (!renderer)
 861             return false;
 862     }
 863     if (!is&lt;RenderTableCell&gt;(*renderer))
 864         return false;
 865 
 866     // Check that the table cell contains no child renderers except for perhaps a single &lt;br&gt;.
 867     auto* childRenderer = downcast&lt;RenderTableCell&gt;(*renderer).firstChild();
 868     if (!childRenderer)
 869         return true;
 870     if (!childRenderer-&gt;isBR())
 871         return false;
 872     return !childRenderer-&gt;nextSibling();
 873 }
 874 
 875 Ref&lt;HTMLElement&gt; createDefaultParagraphElement(Document&amp; document)
 876 {
 877     switch (document.frame()-&gt;editor().defaultParagraphSeparator()) {
 878     case EditorParagraphSeparatorIsDiv:
 879         return HTMLDivElement::create(document);
 880     case EditorParagraphSeparatorIsP:
 881         break;
 882     }
 883     return HTMLParagraphElement::create(document);
 884 }
 885 
 886 Ref&lt;HTMLElement&gt; createHTMLElement(Document&amp; document, const QualifiedName&amp; name)
 887 {
 888     return HTMLElementFactory::createElement(name, document);
 889 }
 890 
 891 Ref&lt;HTMLElement&gt; createHTMLElement(Document&amp; document, const AtomicString&amp; tagName)
 892 {
 893     return createHTMLElement(document, QualifiedName(nullAtom(), tagName, xhtmlNamespaceURI));
 894 }
 895 
 896 bool isTabSpanNode(const Node* node)
 897 {
 898     return is&lt;HTMLSpanElement&gt;(node) &amp;&amp; downcast&lt;HTMLSpanElement&gt;(*node).attributeWithoutSynchronization(classAttr) == AppleTabSpanClass;
 899 }
 900 
 901 bool isTabSpanTextNode(const Node* node)
 902 {
 903     return is&lt;Text&gt;(node) &amp;&amp; isTabSpanNode(node-&gt;parentNode());
 904 }
 905 
 906 HTMLSpanElement* tabSpanNode(const Node* node)
 907 {
 908     return isTabSpanTextNode(node) ? downcast&lt;HTMLSpanElement&gt;(node-&gt;parentNode()) : nullptr;
 909 }
 910 
 911 static Ref&lt;Element&gt; createTabSpanElement(Document&amp; document, Text&amp; tabTextNode)
 912 {
 913     auto spanElement = HTMLSpanElement::create(document);
 914 
 915     spanElement-&gt;setAttributeWithoutSynchronization(classAttr, AppleTabSpanClass);
 916     spanElement-&gt;setAttribute(styleAttr, &quot;white-space:pre&quot;);
 917 
 918     spanElement-&gt;appendChild(tabTextNode);
 919 
 920     return WTFMove(spanElement);
 921 }
 922 
 923 Ref&lt;Element&gt; createTabSpanElement(Document&amp; document, const String&amp; tabText)
 924 {
 925     return createTabSpanElement(document, document.createTextNode(tabText));
 926 }
 927 
 928 Ref&lt;Element&gt; createTabSpanElement(Document&amp; document)
 929 {
 930     return createTabSpanElement(document, document.createEditingTextNode(&quot;\t&quot;_s));
 931 }
 932 
 933 bool isNodeRendered(const Node&amp; node)
 934 {
 935     auto* renderer = node.renderer();
 936     return renderer &amp;&amp; renderer-&gt;style().visibility() == Visibility::Visible;
 937 }
 938 
 939 unsigned numEnclosingMailBlockquotes(const Position&amp; position)
 940 {
 941     unsigned count = 0;
 942     for (Node* node = position.deprecatedNode(); node; node = node-&gt;parentNode()) {
 943         if (isMailBlockquote(node))
 944             ++count;
 945     }
 946     return count;
 947 }
 948 
 949 void updatePositionForNodeRemoval(Position&amp; position, Node&amp; node)
 950 {
 951     if (position.isNull())
 952         return;
 953     switch (position.anchorType()) {
 954     case Position::PositionIsBeforeChildren:
 955         if (node.containsIncludingShadowDOM(position.containerNode()))
 956             position = positionInParentBeforeNode(&amp;node);
 957         break;
 958     case Position::PositionIsAfterChildren:
 959         if (node.containsIncludingShadowDOM(position.containerNode()))
 960             position = positionInParentBeforeNode(&amp;node);
 961         break;
 962     case Position::PositionIsOffsetInAnchor:
 963         if (position.containerNode() == node.parentNode() &amp;&amp; static_cast&lt;unsigned&gt;(position.offsetInContainerNode()) &gt; node.computeNodeIndex())
 964             position.moveToOffset(position.offsetInContainerNode() - 1);
 965         else if (node.containsIncludingShadowDOM(position.containerNode()))
 966             position = positionInParentBeforeNode(&amp;node);
 967         break;
 968     case Position::PositionIsAfterAnchor:
 969         if (node.containsIncludingShadowDOM(position.anchorNode()))
 970             position = positionInParentAfterNode(&amp;node);
 971         break;
 972     case Position::PositionIsBeforeAnchor:
 973         if (node.containsIncludingShadowDOM(position.anchorNode()))
 974             position = positionInParentBeforeNode(&amp;node);
 975         break;
 976     }
 977 }
 978 
 979 bool isMailBlockquote(const Node* node)
 980 {
 981     ASSERT(node);
 982     if (!node-&gt;hasTagName(blockquoteTag))
 983         return false;
 984     return downcast&lt;HTMLElement&gt;(*node).attributeWithoutSynchronization(typeAttr) == &quot;cite&quot;;
 985 }
 986 
 987 int caretMinOffset(const Node&amp; node)
 988 {
 989     auto* renderer = node.renderer();
 990     ASSERT(!node.isCharacterDataNode() || !renderer || renderer-&gt;isText());
 991     return renderer ? renderer-&gt;caretMinOffset() : 0;
 992 }
 993 
 994 // If a node can contain candidates for VisiblePositions, return the offset of the last candidate, otherwise
 995 // return the number of children for container nodes and the length for unrendered text nodes.
 996 int caretMaxOffset(const Node&amp; node)
 997 {
 998     // For rendered text nodes, return the last position that a caret could occupy.
 999     if (is&lt;Text&gt;(node)) {
1000         if (auto* renderer = downcast&lt;Text&gt;(node).renderer())
1001             return renderer-&gt;caretMaxOffset();
1002     }
1003     return lastOffsetForEditing(node);
1004 }
1005 
1006 bool lineBreakExistsAtVisiblePosition(const VisiblePosition&amp; position)
1007 {
1008     return lineBreakExistsAtPosition(position.deepEquivalent().downstream());
1009 }
1010 
1011 bool lineBreakExistsAtPosition(const Position&amp; position)
1012 {
1013     if (position.isNull())
1014         return false;
1015 
1016     if (position.anchorNode()-&gt;hasTagName(brTag) &amp;&amp; position.atFirstEditingPositionForNode())
1017         return true;
1018 
1019     if (!position.anchorNode()-&gt;renderer())
1020         return false;
1021 
1022     if (!is&lt;Text&gt;(*position.anchorNode()) || !position.anchorNode()-&gt;renderer()-&gt;style().preserveNewline())
1023         return false;
1024 
1025     Text&amp; textNode = downcast&lt;Text&gt;(*position.anchorNode());
1026     unsigned offset = position.offsetInContainerNode();
1027     return offset &lt; textNode.length() &amp;&amp; textNode.data()[offset] == &#39;\n&#39;;
1028 }
1029 
1030 // Modifies selections that have an end point at the edge of a table
1031 // that contains the other endpoint so that they don&#39;t confuse
1032 // code that iterates over selected paragraphs.
1033 VisibleSelection selectionForParagraphIteration(const VisibleSelection&amp; original)
1034 {
1035     VisibleSelection newSelection(original);
1036     VisiblePosition startOfSelection(newSelection.visibleStart());
1037     VisiblePosition endOfSelection(newSelection.visibleEnd());
1038 
1039     // If the end of the selection to modify is just after a table, and
1040     // if the start of the selection is inside that table, then the last paragraph
1041     // that we&#39;ll want modify is the last one inside the table, not the table itself
1042     // (a table is itself a paragraph).
1043     if (auto* table = isFirstPositionAfterTable(endOfSelection)) {
1044         if (startOfSelection.deepEquivalent().deprecatedNode()-&gt;isDescendantOf(*table))
1045             newSelection = VisibleSelection(startOfSelection, endOfSelection.previous(CannotCrossEditingBoundary));
1046     }
1047 
1048     // If the start of the selection to modify is just before a table,
1049     // and if the end of the selection is inside that table, then the first paragraph
1050     // we&#39;ll want to modify is the first one inside the table, not the paragraph
1051     // containing the table itself.
1052     if (auto* table = isLastPositionBeforeTable(startOfSelection)) {
1053         if (endOfSelection.deepEquivalent().deprecatedNode()-&gt;isDescendantOf(*table))
1054             newSelection = VisibleSelection(startOfSelection.next(CannotCrossEditingBoundary), endOfSelection);
1055     }
1056 
1057     return newSelection;
1058 }
1059 
1060 // FIXME: indexForVisiblePosition and visiblePositionForIndex use TextIterators to convert between
1061 // VisiblePositions and indices. But TextIterator iteration using TextIteratorEmitsCharactersBetweenAllVisiblePositions
1062 // does not exactly match VisiblePosition iteration, so using them to preserve a selection during an editing
1063 // opertion is unreliable. TextIterator&#39;s TextIteratorEmitsCharactersBetweenAllVisiblePositions mode needs to be fixed,
1064 // or these functions need to be changed to iterate using actual VisiblePositions.
1065 // FIXME: Deploy these functions everywhere that TextIterators are used to convert between VisiblePositions and indices.
1066 int indexForVisiblePosition(const VisiblePosition&amp; visiblePosition, RefPtr&lt;ContainerNode&gt;&amp; scope)
1067 {
1068     if (visiblePosition.isNull())
1069         return 0;
1070 
1071     auto position = visiblePosition.deepEquivalent();
1072     auto&amp; document = *position.document();
1073 
1074     auto* editableRoot = highestEditableRoot(position, AXObjectCache::accessibilityEnabled() ? HasEditableAXRole : ContentIsEditable);
1075     if (editableRoot &amp;&amp; !document.inDesignMode())
1076         scope = editableRoot;
1077     else {
1078         if (position.containerNode()-&gt;isInShadowTree())
1079             scope = position.containerNode()-&gt;containingShadowRoot();
1080         else
1081             scope = &amp;document;
1082     }
1083 
1084     auto range = Range::create(document, firstPositionInNode(scope.get()), position.parentAnchoredEquivalent());
1085     return TextIterator::rangeLength(range.ptr(), true);
1086 }
1087 
1088 // FIXME: Merge this function with the one above.
1089 int indexForVisiblePosition(Node&amp; node, const VisiblePosition&amp; visiblePosition, bool forSelectionPreservation)
1090 {
1091     auto range = Range::create(node.document(), firstPositionInNode(&amp;node), visiblePosition.deepEquivalent().parentAnchoredEquivalent());
1092     return TextIterator::rangeLength(range.ptr(), forSelectionPreservation);
1093 }
1094 
1095 VisiblePosition visiblePositionForPositionWithOffset(const VisiblePosition&amp; position, int offset)
1096 {
1097     RefPtr&lt;ContainerNode&gt; root;
1098     unsigned startIndex = indexForVisiblePosition(position, root);
1099     if (!root)
1100         return { };
1101 
1102     return visiblePositionForIndex(startIndex + offset, root.get());
1103 }
1104 
1105 VisiblePosition visiblePositionForIndex(int index, ContainerNode* scope)
1106 {
1107     auto range = TextIterator::rangeFromLocationAndLength(scope, index, 0, true);
1108     // Check for an invalid index. Certain editing operations invalidate indices because
1109     // of problems with TextIteratorEmitsCharactersBetweenAllVisiblePositions.
1110     if (!range)
1111         return { };
1112     return { range-&gt;startPosition() };
1113 }
1114 
1115 VisiblePosition visiblePositionForIndexUsingCharacterIterator(Node&amp; node, int index)
1116 {
1117     if (index &lt;= 0)
1118         return { firstPositionInOrBeforeNode(&amp;node), DOWNSTREAM };
1119 
1120     auto range = Range::create(node.document());
1121     range-&gt;selectNodeContents(node);
1122     CharacterIterator it(range.get());
1123     it.advance(index - 1);
1124 
1125     if (!it.atEnd() &amp;&amp; it.text()[0] == &#39;\n&#39;) {
1126         // FIXME: workaround for collapsed range (where only start position is correct) emitted for some emitted newlines (see rdar://5192593)
1127         auto range = it.range();
1128         if (range-&gt;startPosition() == range-&gt;endPosition()) {
1129             it.advance(1);
1130             if (!it.atEnd())
1131                 return VisiblePosition(it.range()-&gt;startPosition());
1132         }
1133     }
1134 
1135     return { it.atEnd() ? range-&gt;endPosition() : it.range()-&gt;endPosition(), UPSTREAM };
1136 }
1137 
1138 // Determines whether two positions are visibly next to each other (first then second)
1139 // while ignoring whitespaces and unrendered nodes
1140 static bool isVisiblyAdjacent(const Position&amp; first, const Position&amp; second)
1141 {
1142     return VisiblePosition(first) == VisiblePosition(second.upstream());
1143 }
1144 
1145 // Determines whether a node is inside a range or visibly starts and ends at the boundaries of the range.
1146 // Call this function to determine whether a node is visibly fit inside selectedRange
1147 bool isNodeVisiblyContainedWithin(Node&amp; node, const Range&amp; range)
1148 {
1149     // If the node is inside the range, then it surely is contained within.
1150     auto comparisonResult = range.compareNode(node);
1151     if (!comparisonResult.hasException() &amp;&amp; comparisonResult.releaseReturnValue() == Range::NODE_INSIDE)
1152         return true;
1153 
1154     bool startIsVisuallySame = visiblePositionBeforeNode(node) == range.startPosition();
1155     if (startIsVisuallySame &amp;&amp; comparePositions(positionInParentAfterNode(&amp;node), range.endPosition()) &lt; 0)
1156         return true;
1157 
1158     bool endIsVisuallySame = visiblePositionAfterNode(node) == range.endPosition();
1159     if (endIsVisuallySame &amp;&amp; comparePositions(range.startPosition(), positionInParentBeforeNode(&amp;node)) &lt; 0)
1160         return true;
1161 
1162     return startIsVisuallySame &amp;&amp; endIsVisuallySame;
1163 }
1164 
1165 bool isRenderedAsNonInlineTableImageOrHR(const Node* node)
1166 {
1167     if (!node)
1168         return false;
1169     RenderObject* renderer = node-&gt;renderer();
1170     return renderer &amp;&amp; ((renderer-&gt;isTable() &amp;&amp; !renderer-&gt;isInline()) || (renderer-&gt;isImage() &amp;&amp; !renderer-&gt;isInline()) || renderer-&gt;isHR());
1171 }
1172 
1173 bool areIdenticalElements(const Node&amp; first, const Node&amp; second)
1174 {
1175     if (!is&lt;Element&gt;(first) || !is&lt;Element&gt;(second))
1176         return false;
1177     auto&amp; firstElement = downcast&lt;Element&gt;(first);
1178     auto&amp; secondElement = downcast&lt;Element&gt;(second);
1179     return firstElement.hasTagName(secondElement.tagQName()) &amp;&amp; firstElement.hasEquivalentAttributes(secondElement);
1180 }
1181 
1182 bool isNonTableCellHTMLBlockElement(const Node* node)
1183 {
1184     return node-&gt;hasTagName(listingTag)
1185         || node-&gt;hasTagName(olTag)
1186         || node-&gt;hasTagName(preTag)
1187         || is&lt;HTMLTableElement&gt;(*node)
1188         || node-&gt;hasTagName(ulTag)
1189         || node-&gt;hasTagName(xmpTag)
1190         || node-&gt;hasTagName(h1Tag)
1191         || node-&gt;hasTagName(h2Tag)
1192         || node-&gt;hasTagName(h3Tag)
1193         || node-&gt;hasTagName(h4Tag)
1194         || node-&gt;hasTagName(h5Tag);
1195 }
1196 
1197 Position adjustedSelectionStartForStyleComputation(const VisibleSelection&amp; selection)
1198 {
1199     // This function is used by range style computations to avoid bugs like:
1200     // &lt;rdar://problem/4017641&gt; REGRESSION (Mail): you can only bold/unbold a selection starting from end of line once
1201     // It is important to skip certain irrelevant content at the start of the selection, so we do not wind up
1202     // with a spurious &quot;mixed&quot; style.
1203 
1204     auto visiblePosition = selection.visibleStart();
1205     if (visiblePosition.isNull())
1206         return { };
1207 
1208     // if the selection is a caret, just return the position, since the style
1209     // behind us is relevant
1210     if (selection.isCaret())
1211         return visiblePosition.deepEquivalent();
1212 
1213     // if the selection starts just before a paragraph break, skip over it
1214     if (isEndOfParagraph(visiblePosition))
1215         return visiblePosition.next().deepEquivalent().downstream();
1216 
1217     // otherwise, make sure to be at the start of the first selected node,
1218     // instead of possibly at the end of the last node before the selection
1219     return visiblePosition.deepEquivalent().downstream();
1220 }
1221 
1222 // FIXME: Should this be deprecated like deprecatedEnclosingBlockFlowElement is?
1223 bool isBlockFlowElement(const Node&amp; node)
1224 {
1225     if (!node.isElementNode())
1226         return false;
1227     auto* renderer = downcast&lt;Element&gt;(node).renderer();
1228     return renderer &amp;&amp; renderer-&gt;isRenderBlockFlow();
1229 }
1230 
1231 Element* deprecatedEnclosingBlockFlowElement(Node* node)
1232 {
1233     if (!node)
1234         return nullptr;
1235     if (isBlockFlowElement(*node))
1236         return downcast&lt;Element&gt;(node);
1237     while ((node = node-&gt;parentNode())) {
1238         if (isBlockFlowElement(*node) || is&lt;HTMLBodyElement&gt;(*node))
1239             return downcast&lt;Element&gt;(node);
1240     }
1241     return nullptr;
1242 }
1243 
1244 static inline bool caretRendersInsideNode(Node&amp; node)
1245 {
1246     return !isRenderedTable(&amp;node) &amp;&amp; !editingIgnoresContent(node);
1247 }
1248 
1249 RenderBlock* rendererForCaretPainting(Node* node)
1250 {
1251     if (!node)
1252         return nullptr;
1253 
1254     auto* renderer = node-&gt;renderer();
1255     if (!renderer)
1256         return nullptr;
1257 
1258     // If caretNode is a block and caret is inside it, then caret should be painted by that block.
1259     bool paintedByBlock = is&lt;RenderBlockFlow&gt;(*renderer) &amp;&amp; caretRendersInsideNode(*node);
1260     return paintedByBlock ? downcast&lt;RenderBlock&gt;(renderer) : renderer-&gt;containingBlock();
1261 }
1262 
1263 LayoutRect localCaretRectInRendererForCaretPainting(const VisiblePosition&amp; caretPosition, RenderBlock*&amp; caretPainter)
1264 {
1265     if (caretPosition.isNull())
1266         return LayoutRect();
1267 
1268     ASSERT(caretPosition.deepEquivalent().deprecatedNode()-&gt;renderer());
1269 
1270     // First compute a rect local to the renderer at the selection start.
1271     RenderObject* renderer;
1272     LayoutRect localRect = caretPosition.localCaretRect(renderer);
1273 
1274     return localCaretRectInRendererForRect(localRect, caretPosition.deepEquivalent().deprecatedNode(), renderer, caretPainter);
1275 }
1276 
1277 LayoutRect localCaretRectInRendererForRect(LayoutRect&amp; localRect, Node* node, RenderObject* renderer, RenderBlock*&amp; caretPainter)
1278 {
1279     // Get the renderer that will be responsible for painting the caret
1280     // (which is either the renderer we just found, or one of its containers).
1281     caretPainter = rendererForCaretPainting(node);
1282 
1283     // Compute an offset between the renderer and the caretPainter.
1284     while (renderer != caretPainter) {
1285         RenderElement* containerObject = renderer-&gt;container();
1286         if (!containerObject)
1287             return LayoutRect();
1288         localRect.move(renderer-&gt;offsetFromContainer(*containerObject, localRect.location()));
1289         renderer = containerObject;
1290     }
1291 
1292     return localRect;
1293 }
1294 
1295 IntRect absoluteBoundsForLocalCaretRect(RenderBlock* rendererForCaretPainting, const LayoutRect&amp; rect, bool* insideFixed)
1296 {
1297     if (insideFixed)
1298         *insideFixed = false;
1299 
1300     if (!rendererForCaretPainting || rect.isEmpty())
1301         return IntRect();
1302 
1303     LayoutRect localRect(rect);
1304     rendererForCaretPainting-&gt;flipForWritingMode(localRect);
1305     return rendererForCaretPainting-&gt;localToAbsoluteQuad(FloatRect(localRect), UseTransforms, insideFixed).enclosingBoundingBox();
1306 }
1307 
1308 } // namespace WebCore
    </pre>
  </body>
</html>