<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Tools/Scripts/webkitdirs.pm</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 # Copyright (C) 2005-2007, 2010-2016 Apple Inc. All rights reserved.
   2 # Copyright (C) 2009 Google Inc. All rights reserved.
   3 # Copyright (C) 2011 Research In Motion Limited. All rights reserved.
   4 # Copyright (C) 2013 Nokia Corporation and/or its subsidiary(-ies).
   5 #
   6 # Redistribution and use in source and binary forms, with or without
   7 # modification, are permitted provided that the following conditions
   8 # are met:
   9 #
  10 # 1.  Redistributions of source code must retain the above copyright
  11 #     notice, this list of conditions and the following disclaimer. 
  12 # 2.  Redistributions in binary form must reproduce the above copyright
  13 #     notice, this list of conditions and the following disclaimer in the
  14 #     documentation and/or other materials provided with the distribution. 
  15 # 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16 #     its contributors may be used to endorse or promote products derived
  17 #     from this software without specific prior written permission. 
  18 #
  19 # THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21 # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22 # DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23 # DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24 # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25 # LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26 # ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29 
  30 # Module to share code to get to WebKit directories.
  31 
  32 use strict;
  33 #use version; #the module is not used by the Java port
  34 use warnings;
  35 use Config;
  36 use Cwd qw(realpath);
  37 use Digest::MD5 qw(md5_hex);
  38 use FindBin;
  39 use File::Basename;
  40 use File::Find;
  41 use File::Path qw(make_path mkpath rmtree);
  42 use File::Spec;
  43 use File::Temp qw(tempdir);
  44 use File::stat;
  45 use List::Util;
  46 use POSIX;
  47 use Time::HiRes qw(usleep);
  48 use VCSUtils;
  49 
  50 BEGIN {
  51    use Exporter   ();
  52    our ($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);
  53    $VERSION     = 1.00;
  54    @ISA         = qw(Exporter);
  55    @EXPORT      = qw(
  56        &amp;XcodeCoverageSupportOptions
  57        &amp;XcodeOptionString
  58        &amp;XcodeOptionStringNoConfig
  59        &amp;XcodeOptions
  60        &amp;XcodeStaticAnalyzerOption
  61        &amp;appDisplayNameFromBundle
  62        &amp;appendToEnvironmentVariableList
  63        &amp;archCommandLineArgumentsForRestrictedEnvironmentVariables
  64        &amp;availableXcodeSDKs
  65        &amp;baseProductDir
  66        &amp;chdirWebKit
  67        &amp;checkFrameworks
  68        &amp;cmakeArgsFromFeatures
  69        &amp;currentSVNRevision
  70        &amp;debugSafari
  71        &amp;executableProductDir
  72        &amp;extractNonHostConfiguration
  73        &amp;findOrCreateSimulatorForIOSDevice
  74        &amp;iosSimulatorDeviceByName
  75        &amp;iosVersion
  76        &amp;nmPath
  77        &amp;passedConfiguration
  78        &amp;prependToEnvironmentVariableList
  79        &amp;printHelpAndExitForRunAndDebugWebKitAppIfNeeded
  80        &amp;productDir
  81        &amp;quitIOSSimulator
  82        &amp;relaunchIOSSimulator
  83        &amp;restartIOSSimulatorDevice
  84        &amp;runIOSWebKitApp
  85        &amp;runMacWebKitApp
  86        &amp;safariPath
  87        &amp;sdkDirectory
  88        &amp;sdkPlatformDirectory
  89        &amp;setConfiguration
  90        &amp;setupMacWebKitEnvironment
  91        &amp;setupUnixWebKitEnvironment
  92        &amp;sharedCommandLineOptions
  93        &amp;sharedCommandLineOptionsUsage
  94        &amp;shutDownIOSSimulatorDevice
  95        &amp;willUseIOSDeviceSDK
  96        &amp;willUseIOSSimulatorSDK
  97        DO_NOT_USE_OPEN_COMMAND
  98        SIMULATOR_DEVICE_SUFFIX_FOR_WEBKIT_DEVELOPMENT
  99        USE_OPEN_COMMAND
 100    );
 101    %EXPORT_TAGS = ( );
 102    @EXPORT_OK   = ();
 103 }
 104 
 105 # Ports
 106 use constant {
 107     AppleWin    =&gt; &quot;AppleWin&quot;,
 108     GTK         =&gt; &quot;GTK&quot;,
 109     iOS         =&gt; &quot;iOS&quot;,
 110     tvOS        =&gt; &quot;tvOS&quot;,
 111     watchOS     =&gt; &quot;watchOS&quot;,
 112     Mac         =&gt; &quot;Mac&quot;,
 113     MacCatalyst =&gt; &quot;MacCatalyst&quot;,
 114     JSCOnly     =&gt; &quot;JSCOnly&quot;,
 115     PlayStation =&gt; &quot;PlayStation&quot;,
 116     WinCairo    =&gt; &quot;WinCairo&quot;,
 117     Java     =&gt; &quot;Java&quot;,
 118     WPE         =&gt; &quot;WPE&quot;,
 119     Unknown     =&gt; &quot;Unknown&quot;
 120 };
 121 
 122 use constant USE_OPEN_COMMAND =&gt; 1; # Used in runMacWebKitApp().
 123 use constant DO_NOT_USE_OPEN_COMMAND =&gt; 2;
 124 use constant SIMULATOR_DEVICE_STATE_SHUTDOWN =&gt; &quot;1&quot;;
 125 use constant SIMULATOR_DEVICE_STATE_BOOTED =&gt; &quot;3&quot;;
 126 use constant SIMULATOR_DEVICE_SUFFIX_FOR_WEBKIT_DEVELOPMENT  =&gt; &quot;For WebKit Development&quot;;
 127 
 128 # See table &quot;Certificate types and names&quot; on &lt;https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/MaintainingCertificates/MaintainingCertificates.html#//apple_ref/doc/uid/TP40012582-CH31-SW41&gt;.
 129 use constant IOS_DEVELOPMENT_CERTIFICATE_NAME_PREFIX =&gt; &quot;iPhone Developer: &quot;;
 130 
 131 our @EXPORT_OK;
 132 
 133 my $architecture;
 134 my $asanIsEnabled;
 135 my $ltoMode;
 136 my $numberOfCPUs;
 137 my $maxCPULoad;
 138 my $baseProductDir;
 139 my @baseProductDirOption;
 140 my $configuration;
 141 my $xcodeSDK;
 142 my $configurationForVisualStudio;
 143 my $configurationProductDir;
 144 my $sourceDir;
 145 my $currentSVNRevision;
 146 my $didLoadIPhoneSimulatorNotification;
 147 my $nmPath;
 148 my $osXVersion;
 149 my $iosVersion;
 150 my $generateDsym;
 151 my $isCMakeBuild;
 152 my $isGenerateProjectOnly;
 153 my $shouldBuild32Bit;
 154 my $isWin64;
 155 my $isInspectorFrontend;
 156 my $portName;
 157 my $shouldUseGuardMalloc;
 158 my $shouldNotUseNinja;
 159 my $xcodeVersion;
 160 my $isJava;
 161 my $is32bit;
 162 
 163 my $unknownPortProhibited = 0;
 164 
 165 # Variables for Win32 support
 166 my $programFilesPath;
 167 my $msBuildPath;
 168 my $vsInstallDir;
 169 my $vsVersion;
 170 my $windowsSourceDir;
 171 my $winVersion;
 172 
 173 # Defined in VCSUtils.
 174 sub exitStatus($);
 175 
 176 sub findMatchingArguments($$);
 177 sub hasArgument($$);
 178 
 179 sub sdkDirectory($)
 180 {
 181     my ($sdkName) = @_;
 182     chomp(my $sdkDirectory = `xcrun --sdk &#39;$sdkName&#39; --show-sdk-path`);
 183     die &quot;Failed to get SDK path from xcrun: $!&quot; if exitStatus($?);
 184     return $sdkDirectory;
 185 }
 186 
 187 sub sdkPlatformDirectory($)
 188 {
 189     my ($sdkName) = @_;
 190     chomp(my $sdkPlatformDirectory = `xcrun --sdk &#39;$sdkName&#39; --show-sdk-platform-path`);
 191     die &quot;Failed to get SDK platform path from xcrun: $!&quot; if exitStatus($?);
 192     return $sdkPlatformDirectory;
 193 }
 194 
 195 sub determineSourceDir
 196 {
 197     return if $sourceDir;
 198     $sourceDir = $FindBin::Bin;
 199     $sourceDir =~ s|/+$||; # Remove trailing &#39;/&#39; as we would die later
 200 
 201     # walks up path checking each directory to see if it is the main WebKit project dir, 
 202     # defined by containing Sources, WebCore, and JavaScriptCore.
 203     until ((-d File::Spec-&gt;catdir($sourceDir, &quot;Source&quot;) &amp;&amp; -d File::Spec-&gt;catdir($sourceDir, &quot;Source&quot;, &quot;WebCore&quot;) &amp;&amp; -d File::Spec-&gt;catdir($sourceDir, &quot;Source&quot;, &quot;JavaScriptCore&quot;)) || (-d File::Spec-&gt;catdir($sourceDir, &quot;Internal&quot;) &amp;&amp; -d File::Spec-&gt;catdir($sourceDir, &quot;OpenSource&quot;)))
 204     {
 205         if ($sourceDir !~ s|/[^/]+$||) {
 206             die &quot;Could not find top level webkit directory above source directory using FindBin.\n&quot;;
 207         }
 208     }
 209 
 210     $sourceDir = File::Spec-&gt;catdir($sourceDir, &quot;OpenSource&quot;) if -d File::Spec-&gt;catdir($sourceDir, &quot;OpenSource&quot;);
 211 }
 212 
 213 sub currentPerlPath()
 214 {
 215     my $thisPerl = $^X;
 216     if ($^O ne &#39;VMS&#39;) {
 217         $thisPerl .= $Config{_exe} unless $thisPerl =~ m/$Config{_exe}$/i;
 218     }
 219     return $thisPerl;
 220 }
 221 
 222 # used for scripts which are stored in a non-standard location
 223 sub setSourceDir($)
 224 {
 225     ($sourceDir) = @_;
 226 }
 227 
 228 sub determineNinjaVersion
 229 {
 230     chomp(my $ninjaVersion = `ninja --version`);
 231     return $ninjaVersion;
 232 }
 233 
 234 sub determineXcodeVersion
 235 {
 236     return if defined $xcodeVersion;
 237     my $xcodebuildVersionOutput = `xcodebuild -version`;
 238     $xcodeVersion = ($xcodebuildVersionOutput =~ /Xcode ([0-9]+(\.[0-9]+)*)/) ? $1 : &quot;3.0&quot;;
 239 }
 240 
 241 sub readXcodeUserDefault($)
 242 {
 243     my ($key) = @_;
 244 
 245     my $devnull = File::Spec-&gt;devnull();
 246 
 247     my $value = `defaults read com.apple.dt.Xcode ${key} 2&gt; ${devnull}`;
 248     return if $?;
 249 
 250     chomp $value;
 251     return $value;
 252 }
 253 
 254 sub determineBaseProductDir
 255 {
 256     return if defined $baseProductDir;
 257     determineSourceDir();
 258 
 259     my $setSharedPrecompsDir;
 260     my $indexDataStoreDir;
 261     $baseProductDir = $ENV{&quot;WEBKIT_OUTPUTDIR&quot;};
 262 
 263     if (!defined($baseProductDir) and isAppleCocoaWebKit()) {
 264         # Silently remove ~/Library/Preferences/xcodebuild.plist which can
 265         # cause build failure. The presence of
 266         # ~/Library/Preferences/xcodebuild.plist can prevent xcodebuild from
 267         # respecting global settings such as a custom build products directory
 268         # (&lt;rdar://problem/5585899&gt;).
 269         my $personalPlistFile = $ENV{HOME} . &quot;/Library/Preferences/xcodebuild.plist&quot;;
 270         if (-e $personalPlistFile) {
 271             unlink($personalPlistFile) || die &quot;Could not delete $personalPlistFile: $!&quot;;
 272         }
 273 
 274         my $buildLocationStyle = join &#39;&#39;, readXcodeUserDefault(&quot;IDEBuildLocationStyle&quot;);
 275         if ($buildLocationStyle eq &quot;Custom&quot;) {
 276             my $buildLocationType = join &#39;&#39;, readXcodeUserDefault(&quot;IDECustomBuildLocationType&quot;);
 277             # FIXME: Read CustomBuildIntermediatesPath and set OBJROOT accordingly.
 278             if ($buildLocationType eq &quot;Absolute&quot;) {
 279                 $baseProductDir = readXcodeUserDefault(&quot;IDECustomBuildProductsPath&quot;);
 280                 $indexDataStoreDir = readXcodeUserDefault(&quot;IDECustomIndexStorePath&quot;);
 281             }
 282         }
 283 
 284         # DeterminedByTargets corresponds to a setting of &quot;Legacy&quot; in Xcode.
 285         # It is the only build location style for which SHARED_PRECOMPS_DIR is not
 286         # overridden when building from within Xcode.
 287         $setSharedPrecompsDir = 1 if $buildLocationStyle ne &quot;DeterminedByTargets&quot;;
 288 
 289         if (!defined($baseProductDir)) {
 290             $baseProductDir = join &#39;&#39;, readXcodeUserDefault(&quot;IDEApplicationwideBuildSettings&quot;);
 291             $baseProductDir = $1 if $baseProductDir =~ /SYMROOT\s*=\s*\&quot;(.*?)\&quot;;/s;
 292         }
 293 
 294         undef $baseProductDir unless $baseProductDir =~ /^\//;
 295     }
 296 
 297     if (!defined($baseProductDir)) { # Port-specific checks failed, use default
 298         $baseProductDir = File::Spec-&gt;catdir($sourceDir, &quot;WebKitBuild&quot;);
 299     }
 300 
 301     if (isGit() &amp;&amp; isGitBranchBuild()) {
 302         my $branch = gitBranch();
 303         $baseProductDir = &quot;$baseProductDir/$branch&quot;;
 304     }
 305 
 306     if (isAppleCocoaWebKit()) {
 307         $baseProductDir =~ s|^\Q$(SRCROOT)/..\E$|$sourceDir|;
 308         $baseProductDir =~ s|^\Q$(SRCROOT)/../|$sourceDir/|;
 309         $baseProductDir =~ s|^~/|$ENV{HOME}/|;
 310         die &quot;Can&#39;t handle Xcode product directory with a ~ in it.\n&quot; if $baseProductDir =~ /~/;
 311         die &quot;Can&#39;t handle Xcode product directory with a variable in it.\n&quot; if $baseProductDir =~ /\$/;
 312         @baseProductDirOption = (&quot;SYMROOT=$baseProductDir&quot;, &quot;OBJROOT=$baseProductDir&quot;);
 313         push(@baseProductDirOption, &quot;SHARED_PRECOMPS_DIR=${baseProductDir}/PrecompiledHeaders&quot;) if $setSharedPrecompsDir;
 314         push(@baseProductDirOption, &quot;INDEX_ENABLE_DATA_STORE=YES&quot;, &quot;INDEX_DATA_STORE_DIR=${indexDataStoreDir}&quot;) if $indexDataStoreDir;
 315     }
 316 
 317     if (isCygwin()) {
 318         my $dosBuildPath = `cygpath --windows \&quot;$baseProductDir\&quot;`;
 319         chomp $dosBuildPath;
 320         $ENV{&quot;WEBKIT_OUTPUTDIR&quot;} = $dosBuildPath;
 321         my $unixBuildPath = `cygpath --unix \&quot;$baseProductDir\&quot;`;
 322         chomp $unixBuildPath;
 323         $baseProductDir = $dosBuildPath;
 324     }
 325 }
 326 
 327 sub systemVerbose {
 328     print &quot;+ @_\n&quot;;
 329     return system(@_);
 330 }
 331 
 332 sub setBaseProductDir($)
 333 {
 334     ($baseProductDir) = @_;
 335 }
 336 
 337 sub determineConfiguration
 338 {
 339     return if defined $configuration;
 340     determineBaseProductDir();
 341     if (open CONFIGURATION, &quot;$baseProductDir/Configuration&quot;) {
 342         $configuration = &lt;CONFIGURATION&gt;;
 343         close CONFIGURATION;
 344     }
 345     if ($configuration) {
 346         chomp $configuration;
 347         # compatibility for people who have old Configuration files
 348         $configuration = &quot;Release&quot; if $configuration eq &quot;Deployment&quot;;
 349         $configuration = &quot;Debug&quot; if $configuration eq &quot;Development&quot;;
 350     } else {
 351         $configuration = &quot;Release&quot;;
 352     }
 353 }
 354 
 355 sub determineArchitecture
 356 {
 357     return if defined $architecture;
 358     # make sure $architecture is defined in all cases
 359     $architecture = &quot;&quot;;
 360 
 361     determineBaseProductDir();
 362     determineXcodeSDK();
 363 
 364     if (isAppleCocoaWebKit()) {
 365         if (open ARCHITECTURE, &quot;$baseProductDir/Architecture&quot;) {
 366             $architecture = &lt;ARCHITECTURE&gt;;
 367             close ARCHITECTURE;
 368         }
 369         if ($architecture) {
 370             chomp $architecture;
 371         } else {
 372             if (not defined $xcodeSDK or $xcodeSDK =~ /^(\/$|macosx)/) {
 373                 my $supports64Bit = `sysctl -n hw.optional.x86_64`;
 374                 chomp $supports64Bit;
 375                 $architecture = &#39;x86_64&#39; if $supports64Bit;
 376             } elsif ($xcodeSDK =~ /^iphonesimulator/) {
 377                 $architecture = &#39;x86_64&#39;;
 378             } elsif ($xcodeSDK =~ /^iphoneos/) {
 379                 $architecture = &#39;arm64&#39;;
 380             }
 381         }
 382     } elsif (isCMakeBuild()) {
 383         if (isCrossCompilation()) {
 384             my $compiler = &quot;gcc&quot;;
 385             $compiler = $ENV{&#39;CC&#39;} if (defined($ENV{&#39;CC&#39;}));
 386             my @compiler_machine = split(&#39;-&#39;, `$compiler -dumpmachine`);
 387             $architecture = $compiler_machine[0];
 388         } elsif (open my $cmake_sysinfo, &quot;cmake --system-information |&quot;) {
 389             while (&lt;$cmake_sysinfo&gt;) {
 390                 next unless index($_, &#39;CMAKE_SYSTEM_PROCESSOR&#39;) == 0;
 391                 if (/^CMAKE_SYSTEM_PROCESSOR \&quot;([^&quot;]+)\&quot;/) {
 392                     $architecture = $1;
 393                     last;
 394                 }
 395             }
 396             close $cmake_sysinfo;
 397         }
 398     }
 399 
 400     if (!isAnyWindows()) {
 401         if (!$architecture) {
 402             # Fall back to output of `uname -m&#39;, if it is present.
 403             $architecture = `uname -m`;
 404             chomp $architecture;
 405         }
 406     }
 407 
 408     $architecture = &#39;x86_64&#39; if $architecture =~ /amd64/i;
 409     $architecture = &#39;arm64&#39; if $architecture =~ /aarch64/i;
 410 }
 411 
 412 sub determineASanIsEnabled
 413 {
 414     return if defined $asanIsEnabled;
 415     determineBaseProductDir();
 416 
 417     $asanIsEnabled = 0;
 418     my $asanConfigurationValue;
 419 
 420     if (open ASAN, &quot;$baseProductDir/ASan&quot;) {
 421         $asanConfigurationValue = &lt;ASAN&gt;;
 422         close ASAN;
 423         chomp $asanConfigurationValue;
 424         $asanIsEnabled = 1 if $asanConfigurationValue eq &quot;YES&quot;;
 425     }
 426 }
 427 
 428 sub determineLTOMode
 429 {
 430     return if defined $ltoMode;
 431     determineBaseProductDir();
 432 
 433     if (open LTO, &quot;$baseProductDir/LTO&quot;) {
 434         $ltoMode = &lt;LTO&gt;;
 435         close LTO;
 436         chomp $ltoMode;
 437     }
 438 }
 439 
 440 sub determineNumberOfCPUs
 441 {
 442     return if defined $numberOfCPUs;
 443     if (defined($ENV{NUMBER_OF_PROCESSORS})) {
 444         $numberOfCPUs = $ENV{NUMBER_OF_PROCESSORS};
 445     } elsif (isLinux()) {
 446         # First try the nproc utility, if it exists. If we get no
 447         # results fall back to just interpretting /proc directly.
 448         chomp($numberOfCPUs = `nproc --all 2&gt; /dev/null`);
 449         if ($numberOfCPUs eq &quot;&quot;) {
 450             $numberOfCPUs = (grep /processor/, `cat /proc/cpuinfo`);
 451         }
 452     } elsif (isAnyWindows()) {
 453         # Assumes cygwin
 454         $numberOfCPUs = `ls /proc/registry/HKEY_LOCAL_MACHINE/HARDWARE/DESCRIPTION/System/CentralProcessor | wc -w`;
 455     } elsif (isDarwin() || isBSD()) {
 456         chomp($numberOfCPUs = `sysctl -n hw.ncpu`);
 457     } else {
 458         $numberOfCPUs = 1;
 459     }
 460 }
 461 
 462 sub determineMaxCPULoad
 463 {
 464     return if defined $maxCPULoad;
 465     if (defined($ENV{MAX_CPU_LOAD})) {
 466         $maxCPULoad = $ENV{MAX_CPU_LOAD};
 467     }
 468 }
 469 
 470 sub jscPath($)
 471 {
 472     my ($productDir) = @_;
 473     my $jscName = &quot;jsc&quot;;
 474     $jscName .= &quot;_debug&quot;  if configuration() eq &quot;Debug_All&quot;;
 475     if (isPlayStation()) {
 476         $jscName .= &quot;.elf&quot;;
 477     } elsif (isAnyWindows()) {
 478         $jscName .= &quot;.exe&quot;;
 479     }
 480     return &quot;$productDir/$jscName&quot; if -e &quot;$productDir/$jscName&quot;;
 481     return &quot;$productDir/JavaScriptCore.framework/Resources/$jscName&quot;;
 482 }
 483 
 484 sub argumentsForConfiguration()
 485 {
 486     determineConfiguration();
 487     determineArchitecture();
 488     determineXcodeSDK();
 489 
 490     my @args = ();
 491     # FIXME: Is it necessary to pass --debug, --release, --32-bit or --64-bit?
 492     # These are determined automatically from stored configuration.
 493     push(@args, &#39;--debug&#39;) if ($configuration =~ &quot;^Debug&quot;);
 494     push(@args, &#39;--release&#39;) if ($configuration =~ &quot;^Release&quot;);
 495     push(@args, &#39;--ios-device&#39;) if (defined $xcodeSDK &amp;&amp; $xcodeSDK =~ /^iphoneos/);
 496     push(@args, &#39;--ios-simulator&#39;) if (defined $xcodeSDK &amp;&amp; $xcodeSDK =~ /^iphonesimulator/);
 497     push(@args, &#39;--maccatalyst&#39;) if (defined $xcodeSDK &amp;&amp; $xcodeSDK =~ /^maccatalyst/);
 498     push(@args, &#39;--32-bit&#39;) if ($architecture eq &quot;x86&quot; and !isWin64());
 499     push(@args, &#39;--64-bit&#39;) if (isWin64());
 500     push(@args, &#39;--gtk&#39;) if isGtk();
 501     push(@args, &#39;--java&#39;) if isJava();
 502     push(@args, &#39;--wpe&#39;) if isWPE();
 503     push(@args, &#39;--jsc-only&#39;) if isJSCOnly();
 504     push(@args, &#39;--wincairo&#39;) if isWinCairo();
 505     push(@args, &#39;--playstation&#39;) if isPlayStation();
 506     return @args;
 507 }
 508 
 509 sub extractNonMacOSHostConfiguration
 510 {
 511     my @args = ();
 512     my @extract = (&#39;--device&#39;, &#39;--gtk&#39;, &#39;--ios&#39;, &#39;--platform&#39;, &#39;--sdk&#39;, &#39;--simulator&#39;, &#39;--wincairo&#39;, &#39;SDKROOT&#39;, &#39;ARCHS&#39;);
 513     foreach (@{$_[0]}) {
 514         my $line = $_;
 515         my $flag = 0;
 516         foreach (@extract) {
 517             if (length($line) &gt;= length($_) &amp;&amp; substr($line, 0, length($_)) eq $_
 518                 &amp;&amp; index($line, &#39;i386&#39;) == -1 &amp;&amp; index($line, &#39;x86_64&#39;) == -1) {
 519                 $flag = 1;
 520             }
 521         }
 522         if (!$flag) {
 523             push @args, $_;
 524         }
 525     }
 526     return @args;
 527 }
 528 
 529 # FIXME: Convert to json &lt;rdar://problem/21594308&gt;
 530 sub parseAvailableXcodeSDKs($)
 531 {
 532     my @outputToParse = @{$_[0]};
 533     my @result = ();
 534     foreach my $line (@outputToParse) {
 535         # Examples:
 536         #    iOS 12.0 -sdk iphoneos12.0
 537         #    Simulator - iOS 12.0 -sdk iphonesimulator12.0
 538         #    macOS 10.14 -sdk macosx10.14
 539         if ($line =~ /-sdk (\D+)([\d\.]+)(\D*)\n/) {
 540             if ($3) {
 541                 push @result, &quot;$1.$3&quot;;
 542             } else {
 543                 push @result, &quot;$1&quot;;
 544             }
 545         }
 546     }
 547     return @result;
 548 }
 549 
 550 sub availableXcodeSDKs
 551 {
 552     my @output = `xcodebuild -showsdks`;
 553     return parseAvailableXcodeSDKs(\@output);
 554 }
 555 
 556 sub determineXcodeSDK
 557 {
 558     return if defined $xcodeSDK;
 559     my $sdk;
 560     
 561     # The user explicitly specified the sdk, don&#39;t assume anything
 562     if (checkForArgumentAndRemoveFromARGVGettingValue(&quot;--sdk&quot;, \$sdk)) {
 563         $xcodeSDK = $sdk;
 564         return;
 565     }
 566     if (checkForArgumentAndRemoveFromARGV(&quot;--device&quot;) || checkForArgumentAndRemoveFromARGV(&quot;--ios-device&quot;)) {
 567         $xcodeSDK ||= &quot;iphoneos&quot;;
 568     }
 569     if (checkForArgumentAndRemoveFromARGV(&quot;--simulator&quot;) || checkForArgumentAndRemoveFromARGV(&quot;--ios-simulator&quot;)) {
 570         $xcodeSDK ||= &#39;iphonesimulator&#39;;
 571     }
 572     if (checkForArgumentAndRemoveFromARGV(&quot;--tvos-device&quot;)) {
 573         $xcodeSDK ||=  &quot;appletvos&quot;;
 574     }
 575     if (checkForArgumentAndRemoveFromARGV(&quot;--tvos-simulator&quot;)) {
 576         $xcodeSDK ||= &quot;appletvsimulator&quot;;
 577     }
 578     if (checkForArgumentAndRemoveFromARGV(&quot;--watchos-device&quot;)) {
 579         $xcodeSDK ||=  &quot;watchos&quot;;
 580     }
 581     if (checkForArgumentAndRemoveFromARGV(&quot;--watchos-simulator&quot;)) {
 582         $xcodeSDK ||= &quot;watchsimulator&quot;;
 583     }
 584     if (checkForArgumentAndRemoveFromARGV(&quot;--maccatalyst&quot;)) {
 585         $xcodeSDK ||= &quot;maccatalyst&quot;;
 586     }
 587     return if !defined $xcodeSDK;
 588     
 589     # Prefer the internal version of an sdk, if it exists.
 590     my @availableSDKs = availableXcodeSDKs();
 591 
 592     foreach my $sdk (@availableSDKs) {
 593         next if $sdk ne &quot;$xcodeSDK.internal&quot;;
 594         $xcodeSDK = $sdk;
 595         last;
 596     }
 597 }
 598 
 599 sub xcodeSDK
 600 {
 601     determineXcodeSDK();
 602     return $xcodeSDK;
 603 }
 604 
 605 sub setXcodeSDK($)
 606 {
 607     ($xcodeSDK) = @_;
 608 }
 609 
 610 
 611 sub xcodeSDKPlatformName()
 612 {
 613     determineXcodeSDK();
 614     return &quot;&quot; if !defined $xcodeSDK;
 615     return &quot;appletvos&quot; if $xcodeSDK =~ /appletvos/i;
 616     return &quot;appletvsimulator&quot; if $xcodeSDK =~ /appletvsimulator/i;
 617     return &quot;iphoneos&quot; if $xcodeSDK =~ /iphoneos/i;
 618     return &quot;iphonesimulator&quot; if $xcodeSDK =~ /iphonesimulator/i;
 619     return &quot;macosx&quot; if $xcodeSDK =~ /macosx/i;
 620     return &quot;watchos&quot; if $xcodeSDK =~ /watchos/i;
 621     return &quot;watchsimulator&quot; if $xcodeSDK =~ /watchsimulator/i;
 622     return &quot;maccatalyst&quot; if $xcodeSDK =~ /maccatalyst/i;
 623     die &quot;Couldn&#39;t determine platform name from Xcode SDK&quot;;
 624 }
 625 
 626 sub XcodeSDKPath
 627 {
 628     determineXcodeSDK();
 629 
 630     die &quot;Can&#39;t find the SDK path because no Xcode SDK was specified&quot; if not $xcodeSDK;
 631     return sdkDirectory($xcodeSDK);
 632 }
 633 
 634 sub xcodeSDKVersion
 635 {
 636     determineXcodeSDK();
 637 
 638     die &quot;Can&#39;t find the SDK version because no Xcode SDK was specified&quot; if !$xcodeSDK;
 639 
 640     chomp(my $sdkVersion = `xcrun --sdk $xcodeSDK --show-sdk-version`);
 641     die &quot;Failed to get SDK version from xcrun&quot; if exitStatus($?);
 642 
 643     return $sdkVersion;
 644 }
 645 
 646 sub programFilesPath
 647 {
 648     return $programFilesPath if defined $programFilesPath;
 649 
 650     $programFilesPath = $ENV{&#39;PROGRAMFILES(X86)&#39;} || $ENV{&#39;PROGRAMFILES&#39;} || &quot;C:\\Program Files&quot;;
 651 
 652     return $programFilesPath;
 653 }
 654 
 655 sub programFilesPathX86
 656 {
 657     my $programFilesPathX86 = $ENV{&#39;PROGRAMFILES(X86)&#39;} || &quot;C:\\Program Files (x86)&quot;;
 658 
 659     return $programFilesPathX86;
 660 }
 661 
 662 sub visualStudioInstallDirVSWhere
 663 {
 664     my $vswhere = File::Spec-&gt;catdir(programFilesPathX86(), &quot;Microsoft Visual Studio&quot;, &quot;Installer&quot;, &quot;vswhere.exe&quot;);
 665     return unless -e $vswhere;
 666     open(my $handle, &quot;-|&quot;, $vswhere, qw(-nologo -latest -requires Microsoft.Component.MSBuild -property installationPath)) || return;
 667     my $vsWhereOut = &lt;$handle&gt;;
 668     $vsWhereOut =~ s/\r?\n//;
 669     return $vsWhereOut;
 670 }
 671 
 672 sub visualStudioInstallDir
 673 {
 674     return $vsInstallDir if defined $vsInstallDir;
 675 
 676     if ($ENV{&#39;VSINSTALLDIR&#39;}) {
 677         $vsInstallDir = $ENV{&#39;VSINSTALLDIR&#39;};
 678         $vsInstallDir =~ s|[\\/]$||;
 679     } else {
 680         $vsInstallDir = visualStudioInstallDirVSWhere();
 681         return unless defined $vsInstallDir;
 682     }
 683     chomp($vsInstallDir = `cygpath &quot;$vsInstallDir&quot;`) if isCygwin();
 684 
 685     print &quot;Using Visual Studio: $vsInstallDir\n&quot;;
 686     return $vsInstallDir;
 687 }
 688 
 689 sub msBuildPath
 690 {
 691     my $installDir = visualStudioInstallDir();
 692 
 693     # FIXME: vswhere.exe should be used to find msbuild.exe after AppleWin will get vswhere with -find switch.
 694     # &lt;https://github.com/Microsoft/vswhere/wiki/Find-MSBuild&gt;
 695     # &lt;https://github.com/Microsoft/vswhere/releases/tag/2.6.6%2Bd9dbe79db3&gt;
 696     my $path = File::Spec-&gt;catdir($installDir, &quot;MSBuild&quot;, &quot;Current&quot;, &quot;bin&quot;, &quot;MSBuild.exe&quot;);
 697     $path = File::Spec-&gt;catdir($installDir, &quot;MSBuild&quot;, &quot;15.0&quot;, &quot;bin&quot;, &quot;MSBuild.exe&quot;) unless -e $path;
 698 
 699     chomp($path = `cygpath &quot;$path&quot;`) if isCygwin();
 700 
 701     print &quot;Using MSBuild: $path\n&quot;;
 702     return $path;
 703 }
 704 
 705 sub determineConfigurationForVisualStudio
 706 {
 707     return if defined $configurationForVisualStudio;
 708     determineConfiguration();
 709     # FIXME: We should detect when Debug_All or Production has been chosen.
 710     $configurationForVisualStudio = &quot;/p:Configuration=&quot; . $configuration;
 711 }
 712 
 713 sub usesPerConfigurationBuildDirectory
 714 {
 715     # [Gtk] We don&#39;t have Release/Debug configurations in straight
 716     # autotool builds (non build-webkit). In this case and if
 717     # WEBKIT_OUTPUTDIR exist, use that as our configuration dir. This will
 718     # allows us to run run-webkit-tests without using build-webkit.
 719     return ($ENV{&quot;WEBKIT_OUTPUTDIR&quot;} &amp;&amp; isGtk()) || isAppleWinWebKit() || isJava();
 720 }
 721 
 722 sub determineConfigurationProductDir
 723 {
 724     return if defined $configurationProductDir;
 725     determineBaseProductDir();
 726     determineConfiguration();
 727     if (isAppleWinWebKit() || isWinCairo() || isPlayStation()) {
 728         $configurationProductDir = File::Spec-&gt;catdir($baseProductDir, $configuration);
 729     } else {
 730         if (usesPerConfigurationBuildDirectory()) {
 731             $configurationProductDir = &quot;$baseProductDir&quot;;
 732         } else {
 733             $configurationProductDir = &quot;$baseProductDir/$configuration&quot;;
 734             $configurationProductDir .= &quot;-&quot; . xcodeSDKPlatformName() if isEmbeddedWebKit() || isMacCatalystWebKit();
 735         }
 736     }
 737 }
 738 
 739 sub setConfigurationProductDir($)
 740 {
 741     ($configurationProductDir) = @_;
 742 }
 743 
 744 sub determineCurrentSVNRevision
 745 {
 746     # We always update the current SVN revision here, and leave the caching
 747     # to currentSVNRevision(), so that changes to the SVN revision while the
 748     # script is running can be picked up by calling this function again.
 749     determineSourceDir();
 750     $currentSVNRevision = svnRevisionForDirectory($sourceDir);
 751     return $currentSVNRevision;
 752 }
 753 
 754 
 755 sub chdirWebKit
 756 {
 757     determineSourceDir();
 758     chdir $sourceDir or die;
 759 }
 760 
 761 sub baseProductDir
 762 {
 763     determineBaseProductDir();
 764     return $baseProductDir;
 765 }
 766 
 767 sub sourceDir
 768 {
 769     determineSourceDir();
 770     return $sourceDir;
 771 }
 772 
 773 sub productDir
 774 {
 775     determineConfigurationProductDir();
 776     return $configurationProductDir;
 777 }
 778 
 779 sub executableProductDir
 780 {
 781     my $productDirectory = productDir();
 782 
 783     my $binaryDirectory;
 784     if (isAnyWindows() &amp;&amp; !isPlayStation()) {
 785         $binaryDirectory = isWin64() ? &quot;bin64&quot; : &quot;bin32&quot;;
 786     } elsif (isGtk() || isJSCOnly() || isWPE() || isPlayStation()) {
 787         $binaryDirectory = &quot;bin&quot;;
 788     } else {
 789         return $productDirectory;
 790     }
 791 
 792     return File::Spec-&gt;catdir($productDirectory, $binaryDirectory);
 793 }
 794 
 795 sub jscProductDir
 796 {
 797     return executableProductDir();
 798 }
 799 
 800 sub configuration()
 801 {
 802     determineConfiguration();
 803     return $configuration;
 804 }
 805 
 806 sub asanIsEnabled()
 807 {
 808     determineASanIsEnabled();
 809     return $asanIsEnabled;
 810 }
 811 
 812 sub ltoMode()
 813 {
 814     determineLTOMode();
 815     return $ltoMode;
 816 }
 817 
 818 sub configurationForVisualStudio()
 819 {
 820     determineConfigurationForVisualStudio();
 821     return $configurationForVisualStudio;
 822 }
 823 
 824 sub currentSVNRevision
 825 {
 826     determineCurrentSVNRevision() if not defined $currentSVNRevision;
 827     return $currentSVNRevision;
 828 }
 829 
 830 sub generateDsym()
 831 {
 832     determineGenerateDsym();
 833     return $generateDsym;
 834 }
 835 
 836 sub determineGenerateDsym()
 837 {
 838     return if defined($generateDsym);
 839     $generateDsym = checkForArgumentAndRemoveFromARGV(&quot;--dsym&quot;);
 840 }
 841 
 842 sub hasIOSDevelopmentCertificate()
 843 {
 844     return !exitStatus(system(&quot;security find-identity -p codesigning | grep &#39;&quot; . IOS_DEVELOPMENT_CERTIFICATE_NAME_PREFIX . &quot;&#39; &gt; /dev/null 2&gt;&amp;1&quot;));
 845 }
 846 
 847 sub argumentsForXcode()
 848 {
 849     my @args = ();
 850     push @args, &quot;DEBUG_INFORMATION_FORMAT=dwarf-with-dsym&quot; if generateDsym();
 851     return @args;
 852 }
 853 
 854 sub XcodeOptions
 855 {
 856     determineBaseProductDir();
 857     determineConfiguration();
 858     determineArchitecture();
 859     determineASanIsEnabled();
 860     determineLTOMode();
 861     determineXcodeSDK();
 862 
 863     my @options;
 864     push @options, &quot;-UseSanitizedBuildSystemEnvironment=YES&quot;;
 865     push @options, &quot;-ShowBuildOperationDuration=YES&quot;;
 866     push @options, (&quot;-configuration&quot;, $configuration);
 867     push @options, (&quot;-xcconfig&quot;, sourceDir() . &quot;/Tools/asan/asan.xcconfig&quot;, &quot;ASAN_IGNORE=&quot; . sourceDir() . &quot;/Tools/asan/webkit-asan-ignore.txt&quot;) if $asanIsEnabled;
 868     push @options, &quot;WK_LTO_MODE=$ltoMode&quot; if $ltoMode;
 869     push @options, @baseProductDirOption;
 870     push @options, &quot;ARCHS=$architecture&quot; if $architecture;
 871     push @options, &quot;SDKROOT=$xcodeSDK&quot; if $xcodeSDK;
 872     if (willUseIOSDeviceSDK()) {
 873         push @options, &quot;ENABLE_BITCODE=NO&quot;;
 874         if (hasIOSDevelopmentCertificate()) {
 875             # FIXME: May match more than one installed development certificate.
 876             push @options, &quot;CODE_SIGN_IDENTITY=&quot; . IOS_DEVELOPMENT_CERTIFICATE_NAME_PREFIX;
 877         } else {
 878             push @options, &quot;CODE_SIGN_IDENTITY=&quot;; # No identity
 879             push @options, &quot;CODE_SIGNING_REQUIRED=NO&quot;;
 880         }
 881     }
 882     push @options, argumentsForXcode();
 883     return @options;
 884 }
 885 
 886 sub XcodeOptionString
 887 {
 888     return join &quot; &quot;, XcodeOptions();
 889 }
 890 
 891 sub XcodeOptionStringNoConfig
 892 {
 893     return join &quot; &quot;, @baseProductDirOption;
 894 }
 895 
 896 sub XcodeCoverageSupportOptions()
 897 {
 898     my @coverageSupportOptions = ();
 899     push @coverageSupportOptions, &quot;GCC_GENERATE_TEST_COVERAGE_FILES=YES&quot;;
 900     push @coverageSupportOptions, &quot;GCC_INSTRUMENT_PROGRAM_FLOW_ARCS=YES&quot;;
 901     return @coverageSupportOptions;
 902 }
 903 
 904 sub XcodeStaticAnalyzerOption()
 905 {
 906     return &quot;RUN_CLANG_STATIC_ANALYZER=YES&quot;;
 907 }
 908 
 909 sub canUseXCBuild()
 910 {
 911     # if (`xcodebuild -version | grep &quot;Build version&quot;` =~ /Build version (\d+)([a-zA-Z])(\d+)([a-zA-Z]?)/) {
 912     #     return $1 &gt;= 11;
 913     # }
 914 
 915     return 0;
 916 }
 917 
 918 my $passedConfiguration;
 919 my $searchedForPassedConfiguration;
 920 sub determinePassedConfiguration
 921 {
 922     return if $searchedForPassedConfiguration;
 923     $searchedForPassedConfiguration = 1;
 924     $passedConfiguration = undef;
 925 
 926     if (checkForArgumentAndRemoveFromARGV(&quot;--debug&quot;)) {
 927         $passedConfiguration = &quot;Debug&quot;;
 928     } elsif(checkForArgumentAndRemoveFromARGV(&quot;--release&quot;)) {
 929         $passedConfiguration = &quot;Release&quot;;
 930     } elsif (checkForArgumentAndRemoveFromARGV(&quot;--profile&quot;) || checkForArgumentAndRemoveFromARGV(&quot;--profiling&quot;)) {
 931         $passedConfiguration = &quot;Profiling&quot;;
 932     }
 933 }
 934 
 935 sub passedConfiguration
 936 {
 937     determinePassedConfiguration();
 938     return $passedConfiguration;
 939 }
 940 
 941 sub setConfiguration
 942 {
 943     setArchitecture();
 944 
 945     if (my $config = shift @_) {
 946         $configuration = $config;
 947         return;
 948     }
 949 
 950     determinePassedConfiguration();
 951     $configuration = $passedConfiguration if $passedConfiguration;
 952 }
 953 
 954 
 955 my $passedArchitecture;
 956 my $searchedForPassedArchitecture;
 957 sub determinePassedArchitecture
 958 {
 959     return if $searchedForPassedArchitecture;
 960     $searchedForPassedArchitecture = 1;
 961 
 962     $passedArchitecture = undef;
 963     if (shouldBuild32Bit()) {
 964         if (isAppleCocoaWebKit()) {
 965             # PLATFORM_IOS: Don&#39;t run `arch` command inside Simulator environment
 966             local %ENV = %ENV;
 967             delete $ENV{DYLD_ROOT_PATH};
 968             delete $ENV{DYLD_FRAMEWORK_PATH};
 969 
 970             $passedArchitecture = `arch`;
 971             chomp $passedArchitecture;
 972         }
 973     }
 974 }
 975 
 976 sub passedArchitecture
 977 {
 978     determinePassedArchitecture();
 979     return $passedArchitecture;
 980 }
 981 
 982 sub architecture()
 983 {
 984     determineArchitecture();
 985     return $architecture;
 986 }
 987 
 988 sub numberOfCPUs()
 989 {
 990     determineNumberOfCPUs();
 991     return $numberOfCPUs;
 992 }
 993 
 994 sub maxCPULoad()
 995 {
 996     determineMaxCPULoad();
 997     return $maxCPULoad;
 998 }
 999 
1000 sub setArchitecture
1001 {
1002     if (my $arch = shift @_) {
1003         $architecture = $arch;
1004         return;
1005     }
1006 
1007     determinePassedArchitecture();
1008     $architecture = $passedArchitecture if $passedArchitecture;
1009 }
1010 
1011 # Locate Safari.
1012 sub safariPath
1013 {
1014     die &quot;Safari path is only relevant on Apple Mac platform\n&quot; unless isAppleMacWebKit();
1015 
1016     my $safariPath;
1017 
1018     # Use WEBKIT_SAFARI environment variable if present.
1019     my $safariBundle = $ENV{WEBKIT_SAFARI};
1020     if (!$safariBundle) {
1021         determineConfigurationProductDir();
1022         # Use Safari.app in product directory if present (good for Safari development team).
1023         if (-d &quot;$configurationProductDir/Safari.app&quot;) {
1024             $safariBundle = &quot;$configurationProductDir/Safari.app&quot;;
1025         }
1026     }
1027 
1028     if ($safariBundle) {
1029         $safariPath = &quot;$safariBundle/Contents/MacOS/Safari&quot;;
1030     } else {
1031         $safariPath = &quot;/Applications/Safari.app/Contents/MacOS/SafariForWebKitDevelopment&quot;;
1032     }
1033 
1034     die &quot;Can&#39;t find executable at $safariPath.\n&quot; if !-x $safariPath;
1035     return $safariPath;
1036 }
1037 
1038 sub builtDylibPathForName
1039 {
1040     my $libraryName = shift;
1041     determineConfigurationProductDir();
1042 
1043     if (isGtk()) {
1044         my $extension = isDarwin() ? &quot;.dylib&quot; : &quot;.so&quot;;
1045         return &quot;$configurationProductDir/lib/libwebkit2gtk-4.0&quot; . $extension;
1046     }
1047     if (isIOSWebKit()) {
1048         return &quot;$configurationProductDir/$libraryName.framework/$libraryName&quot;;
1049     }
1050     if (isAppleCocoaWebKit()) {
1051         return &quot;$configurationProductDir/$libraryName.framework/Versions/A/$libraryName&quot;;
1052     }
1053     if (isAppleWinWebKit()) {
1054         if ($libraryName eq &quot;JavaScriptCore&quot;) {
1055             return &quot;$baseProductDir/lib/$libraryName.lib&quot;;
1056         } else {
1057             return &quot;$baseProductDir/$libraryName.intermediate/$configuration/$libraryName.intermediate/$libraryName.lib&quot;;
1058         }
1059     }
1060     if (isJava()) {
1061         my $extension = isDarwin() ? &quot;.dylib&quot; : &quot;.so&quot;;
1062         return &quot;$configurationProductDir/lib/libjfxwebkit&quot; . $extension;
1063     }
1064     if (isWPE()) {
1065         return &quot;$configurationProductDir/lib/libWPEWebKit-1.0.so&quot;;
1066     }
1067 
1068     die &quot;Unsupported platform, can&#39;t determine built library locations.\nTry `build-webkit --help` for more information.\n&quot;;
1069 }
1070 
1071 # Check to see that all the frameworks are built.
1072 sub checkFrameworks # FIXME: This is a poor name since only the Mac calls built WebCore a Framework.
1073 {
1074     return if isAnyWindows() || isJava();
1075     my @frameworks = (&quot;JavaScriptCore&quot;, &quot;WebCore&quot;);
1076     push(@frameworks, &quot;WebKit&quot;) if isAppleCocoaWebKit(); # FIXME: This seems wrong, all ports should have a WebKit these days.
1077     for my $framework (@frameworks) {
1078         my $path = builtDylibPathForName($framework);
1079         die &quot;Can&#39;t find built framework at \&quot;$path\&quot;.\n&quot; unless -e $path;
1080     }
1081 }
1082 
1083 sub isInspectorFrontend()
1084 {
1085     determineIsInspectorFrontend();
1086     return $isInspectorFrontend;
1087 }
1088 
1089 sub determineIsInspectorFrontend()
1090 {
1091     return if defined($isInspectorFrontend);
1092     $isInspectorFrontend = checkForArgumentAndRemoveFromARGV(&quot;--inspector-frontend&quot;);
1093 }
1094 
1095 sub commandExists($)
1096 {
1097     my $command = shift;
1098     my $devnull = File::Spec-&gt;devnull();
1099 
1100     if (isAnyWindows()) {
1101         return exitStatus(system(&quot;where /q $command &gt;$devnull 2&gt;&amp;1&quot;)) == 0;
1102     }
1103     return exitStatus(system(&quot;which $command &gt;$devnull 2&gt;&amp;1&quot;)) == 0;
1104 }
1105 
1106 sub checkForArgumentAndRemoveFromARGV($)
1107 {
1108     my $argToCheck = shift;
1109     return checkForArgumentAndRemoveFromArrayRef($argToCheck, \@ARGV);
1110 }
1111 
1112 sub checkForArgumentAndRemoveFromArrayRefGettingValue($$$)
1113 {
1114     my ($argToCheck, $valueRef, $arrayRef) = @_;
1115     my $argumentStartRegEx = qr#^$argToCheck(?:=\S|$)#;
1116     my $i = 0;
1117     for (; $i &lt; @$arrayRef; ++$i) {
1118         last if $arrayRef-&gt;[$i] =~ $argumentStartRegEx;
1119     }
1120     if ($i &gt;= @$arrayRef) {
1121         return $$valueRef = undef;
1122     }
1123     my ($key, $value) = split(&quot;=&quot;, $arrayRef-&gt;[$i]);
1124     splice(@$arrayRef, $i, 1);
1125     if (defined($value)) {
1126         # e.g. --sdk=iphonesimulator
1127         return $$valueRef = $value;
1128     }
1129     return $$valueRef = splice(@$arrayRef, $i, 1); # e.g. --sdk iphonesimulator
1130 }
1131 
1132 sub checkForArgumentAndRemoveFromARGVGettingValue($$)
1133 {
1134     my ($argToCheck, $valueRef) = @_;
1135     return checkForArgumentAndRemoveFromArrayRefGettingValue($argToCheck, $valueRef, \@ARGV);
1136 }
1137 
1138 sub findMatchingArguments($$)
1139 {
1140     my ($argToCheck, $arrayRef) = @_;
1141     my @matchingIndices;
1142     foreach my $index (0 .. $#$arrayRef) {
1143         my $opt = $$arrayRef[$index];
1144         if ($opt =~ /^$argToCheck$/i ) {
1145             push(@matchingIndices, $index);
1146         }
1147     }
1148     return @matchingIndices; 
1149 }
1150 
1151 sub hasArgument($$)
1152 {
1153     my ($argToCheck, $arrayRef) = @_;
1154     my @matchingIndices = findMatchingArguments($argToCheck, $arrayRef);
1155     return scalar @matchingIndices &gt; 0;
1156 }
1157 
1158 sub checkForArgumentAndRemoveFromArrayRef
1159 {
1160     my ($argToCheck, $arrayRef) = @_;
1161     my @indicesToRemove = findMatchingArguments($argToCheck, $arrayRef);
1162     my $removeOffset = 0;
1163     foreach my $index (@indicesToRemove) {
1164         splice(@$arrayRef, $index - $removeOffset++, 1);
1165     }
1166     return scalar @indicesToRemove &gt; 0;
1167 }
1168 
1169 sub prohibitUnknownPort()
1170 {
1171     $unknownPortProhibited = 1;
1172 }
1173 
1174 sub determinePortName()
1175 {
1176     return if defined $portName;
1177 
1178     my %argToPortName = (
1179         gtk =&gt; GTK,
1180         &#39;jsc-only&#39; =&gt; JSCOnly,
1181         playstation =&gt; PlayStation,
1182         wincairo =&gt; WinCairo,
1183         java =&gt; Java,
1184         wpe =&gt; WPE
1185     );
1186 
1187     for my $arg (sort keys %argToPortName) {
1188         if (checkForArgumentAndRemoveFromARGV(&quot;--$arg&quot;)) {
1189             die &quot;Argument &#39;--$arg&#39; conflicts with selected port &#39;$portName&#39;\n&quot;
1190                 if defined $portName;
1191 
1192             $portName = $argToPortName{$arg};
1193         }
1194     }
1195 
1196     return if defined $portName;
1197 
1198     # Port was not selected via command line, use appropriate default value
1199 
1200     if (isAnyWindows()) {
1201         $portName = AppleWin;
1202     } elsif (isDarwin()) {
1203         determineXcodeSDK();
1204         if (willUseIOSDeviceSDK() || willUseIOSSimulatorSDK()) {
1205             $portName = iOS;
1206         } elsif (willUseAppleTVDeviceSDK() || willUseAppleTVSimulatorSDK()) {
1207             $portName = tvOS;
1208         } elsif (willUseWatchDeviceSDK() || willUseWatchSimulatorSDK()) {
1209             $portName = watchOS;
1210         } elsif (willUseMacCatalystSDK()) {
1211             $portName = MacCatalyst;
1212         } else {
1213             $portName = Mac;
1214         }
1215     } else {
1216         if ($unknownPortProhibited) {
1217             my $portsChoice = join &quot;\n\t&quot;, qw(
1218                 --gtk
1219                 --jsc-only
1220                 --wpe
1221             );
1222             die &quot;Please specify which WebKit port to build using one of the following options:&quot;
1223                 . &quot;\n\t$portsChoice\n&quot;;
1224         }
1225 
1226         # If script is run without arguments we cannot determine port
1227         # TODO: This state should be outlawed
1228         $portName = Unknown;
1229     }
1230 }
1231 
1232 sub portName()
1233 {
1234     determinePortName();
1235     return $portName;
1236 }
1237 
1238 sub isGtk()
1239 {
1240     return portName() eq GTK;
1241 }
1242 
1243 sub determineIsJava()
1244 {
1245     return if defined($isJava);
1246     $isJava = checkForArgumentAndRemoveFromARGV(&quot;--java&quot;);
1247 }
1248 
1249 sub isJava()
1250 {
1251     return portName() eq Java;
1252 }
1253 
1254 sub isJSCOnly()
1255 {
1256     return portName() eq JSCOnly;
1257 }
1258 
1259 sub isWPE()
1260 {
1261     return portName() eq WPE;
1262 }
1263 
1264 sub isPlayStation()
1265 {
1266     return portName() eq PlayStation;
1267 }
1268 
1269 # Determine if this is debian, ubuntu, linspire, or something similar.
1270 sub isDebianBased()
1271 {
1272     return -e &quot;/etc/debian_version&quot;;
1273 }
1274 
1275 sub isFedoraBased()
1276 {
1277     return -e &quot;/etc/fedora-release&quot;;
1278 }
1279 
1280 sub isWinCairo()
1281 {
1282     return portName() eq WinCairo;
1283 }
1284 
1285 sub shouldBuild32Bit()
1286 {
1287     determineShouldBuild32Bit();
1288     return $shouldBuild32Bit;
1289 }
1290 
1291 sub determineShouldBuild32Bit()
1292 {
1293     return if defined($shouldBuild32Bit);
1294     $shouldBuild32Bit = checkForArgumentAndRemoveFromARGV(&quot;--32-bit&quot;);
1295 }
1296 
1297 sub isWin64()
1298 {
1299     determineIsWin64();
1300     return $isWin64;
1301 }
1302 
1303 sub determineIsWin64()
1304 {
1305     return if defined($isWin64);
1306     $isWin64 = checkForArgumentAndRemoveFromARGV(&quot;--64-bit&quot;) || ((isWinCairo() || isJSCOnly()) &amp;&amp; !shouldBuild32Bit());
1307 }
1308 
1309 sub determineIsWin64FromArchitecture($)
1310 {
1311     my $arch = shift;
1312     $isWin64 = ($arch eq &quot;x86_64&quot;);
1313     return $isWin64;
1314 }
1315 
1316 sub isCygwin()
1317 {
1318     return ($^O eq &quot;cygwin&quot;) || 0;
1319 }
1320 
1321 sub isAnyWindows()
1322 {
1323     return isWindows() || isCygwin();
1324 }
1325 
1326 sub determineWinVersion()
1327 {
1328     return if $winVersion;
1329 
1330     if (!isAnyWindows()) {
1331         $winVersion = -1;
1332         return;
1333     }
1334 
1335     my $versionString = `cmd /c ver`;
1336     $versionString =~ /(\d)\.(\d)\.(\d+)/;
1337 
1338     $winVersion = {
1339         major =&gt; $1,
1340         minor =&gt; $2,
1341         build =&gt; $3,
1342     };
1343 }
1344 
1345 sub winVersion()
1346 {
1347     determineWinVersion();
1348     return $winVersion;
1349 }
1350 
1351 sub isWindows7SP0()
1352 {
1353     return isAnyWindows() &amp;&amp; winVersion()-&gt;{major} == 6 &amp;&amp; winVersion()-&gt;{minor} == 1 &amp;&amp; winVersion()-&gt;{build} == 7600;
1354 }
1355 
1356 sub isWindowsVista()
1357 {
1358     return isAnyWindows() &amp;&amp; winVersion()-&gt;{major} == 6 &amp;&amp; winVersion()-&gt;{minor} == 0;
1359 }
1360 
1361 sub isWindowsXP()
1362 {
1363     return isAnyWindows() &amp;&amp; winVersion()-&gt;{major} == 5 &amp;&amp; winVersion()-&gt;{minor} == 1;
1364 }
1365 
1366 sub isDarwin()
1367 {
1368     return ($^O eq &quot;darwin&quot;) || 0;
1369 }
1370 
1371 sub isWindows()
1372 {
1373     return ($^O eq &quot;MSWin32&quot;) || 0;
1374 }
1375 
1376 sub isLinux()
1377 {
1378     return ($^O eq &quot;linux&quot;) || 0;
1379 }
1380 
1381 sub isBSD()
1382 {
1383     return ($^O eq &quot;freebsd&quot;) || ($^O eq &quot;openbsd&quot;) || ($^O eq &quot;netbsd&quot;) || 0;
1384 }
1385 
1386 sub isX86_64()
1387 {
1388     return (architecture() eq &quot;x86_64&quot;) || 0;
1389 }
1390 
1391 sub isARM64()
1392 {
1393     return (architecture() eq &quot;arm64&quot;) || 0;
1394 }
1395 
1396 sub isCrossCompilation()
1397 {
1398     my $compiler = &quot;&quot;;
1399     $compiler = $ENV{&#39;CC&#39;} if (defined($ENV{&#39;CC&#39;}));
1400     if ($compiler =~ /gcc/) {
1401         my $compilerOptions = `$compiler -v 2&gt;&amp;1`;
1402         my @host = $compilerOptions =~ m/--host=(.*?)\s/;
1403         my @target = $compilerOptions =~ m/--target=(.*?)\s/;
1404         if ($target[0] ne &quot;&quot; &amp;&amp; $host[0] ne &quot;&quot;) {
1405                 return ($host[0] ne $target[0]);
1406         } else {
1407                 # $tempDir gets automatically deleted when goes out of scope
1408                 my $tempDir = File::Temp-&gt;newdir();
1409                 my $testProgramSourcePath = File::Spec-&gt;catfile($tempDir, &quot;testcross.c&quot;);
1410                 my $testProgramBinaryPath = File::Spec-&gt;catfile($tempDir, &quot;testcross&quot;);
1411                 open(my $testProgramSourceHandler, &quot;&gt;&quot;, $testProgramSourcePath);
1412                 print $testProgramSourceHandler &quot;int main() { return 0; }\n&quot;;
1413                 system(&quot;$compiler $testProgramSourcePath -o $testProgramBinaryPath &gt; /dev/null 2&gt;&amp;1&quot;) == 0 or return 0;
1414                 # Crosscompiling if the program fails to run (because it was built for other arch)
1415                 system(&quot;$testProgramBinaryPath &gt; /dev/null 2&gt;&amp;1&quot;) == 0 or return 1;
1416                 return 0;
1417         }
1418     }
1419     return 0;
1420 }
1421 
1422 sub isIOSWebKit()
1423 {
1424     return portName() eq iOS;
1425 }
1426 
1427 sub isTVOSWebKit()
1428 {
1429     return portName() eq tvOS;
1430 }
1431 
1432 sub isWatchOSWebKit()
1433 {
1434     return portName() eq watchOS;
1435 }
1436 
1437 sub isEmbeddedWebKit()
1438 {
1439     return isIOSWebKit() || isTVOSWebKit() || isWatchOSWebKit();
1440 }
1441 
1442 sub isAppleWebKit()
1443 {
1444     return !isJava() &amp;&amp; (isAppleCocoaWebKit() || isAppleWinWebKit());
1445 }
1446 
1447 sub isAppleMacWebKit()
1448 {
1449     return portName() eq Mac;
1450 }
1451 
1452 sub isMacCatalystWebKit()
1453 {
1454     return portName() eq MacCatalyst;
1455 }
1456 
1457 sub isAppleCocoaWebKit()
1458 {
1459     return isAppleMacWebKit() || isEmbeddedWebKit() || isMacCatalystWebKit();
1460 }
1461 
1462 sub isAppleWinWebKit()
1463 {
1464     return portName() eq AppleWin;
1465 }
1466 
1467 sub iOSSimulatorDevicesPath
1468 {
1469     return &quot;$ENV{HOME}/Library/Developer/CoreSimulator/Devices&quot;;
1470 }
1471 
1472 sub iOSSimulatorDevices
1473 {
1474     eval &quot;require Foundation&quot;;
1475     my $devicesPath = iOSSimulatorDevicesPath();
1476     opendir(DEVICES, $devicesPath);
1477     my @udids = grep {
1478         $_ =~ m/^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}$/;
1479     } readdir(DEVICES);
1480     close(DEVICES);
1481 
1482     # FIXME: We should parse the device.plist file ourself and map the dictionary keys in it to known
1483     #        dictionary keys so as to decouple our representation of the plist from the actual structure
1484     #        of the plist, which may change.
1485     my @devices = map {
1486         Foundation::perlRefFromObjectRef(NSDictionary-&gt;dictionaryWithContentsOfFile_(&quot;$devicesPath/$_/device.plist&quot;));
1487     } @udids;
1488 
1489     return @devices;
1490 }
1491 
1492 sub createiOSSimulatorDevice
1493 {
1494     my $name = shift;
1495     my $deviceTypeId = shift;
1496     my $runtimeId = shift;
1497 
1498     my $created = system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;create&quot;, $name, $deviceTypeId, $runtimeId) == 0;
1499     die &quot;Couldn&#39;t create simulator device: $name $deviceTypeId $runtimeId&quot; if not $created;
1500 
1501     system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;list&quot;);
1502 
1503     print &quot;Waiting for device to be created ...\n&quot;;
1504     sleep 5;
1505     for (my $tries = 0; $tries &lt; 5; $tries++){
1506         my @devices = iOSSimulatorDevices();
1507         foreach my $device (@devices) {
1508             return $device if $device-&gt;{name} eq $name and $device-&gt;{deviceType} eq $deviceTypeId and $device-&gt;{runtime} eq $runtimeId;
1509         }
1510         sleep 5;
1511     }
1512     die &quot;Device $name $deviceTypeId $runtimeId wasn&#39;t found in &quot; . iOSSimulatorDevicesPath();
1513 }
1514 
1515 sub willUseIOSDeviceSDK()
1516 {
1517     return xcodeSDKPlatformName() eq &quot;iphoneos&quot;;
1518 }
1519 
1520 sub willUseIOSSimulatorSDK()
1521 {
1522     return xcodeSDKPlatformName() eq &quot;iphonesimulator&quot;;
1523 }
1524 
1525 sub willUseAppleTVDeviceSDK()
1526 {
1527     return xcodeSDKPlatformName() eq &quot;appletvos&quot;;
1528 }
1529 
1530 sub willUseAppleTVSimulatorSDK()
1531 {
1532     return xcodeSDKPlatformName() eq &quot;appletvsimulator&quot;;
1533 }
1534 
1535 sub willUseWatchDeviceSDK()
1536 {
1537     return xcodeSDKPlatformName() eq &quot;watchos&quot;;
1538 }
1539 
1540 sub willUseWatchSimulatorSDK()
1541 {
1542     return xcodeSDKPlatformName() eq &quot;watchsimulator&quot;;
1543 }
1544 
1545 sub willUseMacCatalystSDK()
1546 {
1547     return xcodeSDKPlatformName() eq &quot;maccatalyst&quot;;
1548 }
1549 
1550 sub determineNmPath()
1551 {
1552     return if $nmPath;
1553 
1554     if (isAppleCocoaWebKit()) {
1555         $nmPath = `xcrun -find nm`;
1556         chomp $nmPath;
1557     }
1558     $nmPath = &quot;nm&quot; if !$nmPath;
1559 }
1560 
1561 sub nmPath()
1562 {
1563     determineNmPath();
1564     return $nmPath;
1565 }
1566 
1567 sub splitVersionString
1568 {
1569     my $versionString = shift;
1570     my @splitVersion = split(/\./, $versionString);
1571     @splitVersion &gt;= 2 or die &quot;Invalid version $versionString&quot;;
1572     $osXVersion = {
1573             &quot;major&quot; =&gt; $splitVersion[0],
1574             &quot;minor&quot; =&gt; $splitVersion[1],
1575             &quot;subminor&quot; =&gt; (defined($splitVersion[2]) ? $splitVersion[2] : 0),
1576     };
1577 }
1578 
1579 sub determineOSXVersion()
1580 {
1581     return if $osXVersion;
1582 
1583     if (!isDarwin()) {
1584         $osXVersion = -1;
1585         return;
1586     }
1587 
1588     my $versionString = `sw_vers -productVersion`;
1589     $osXVersion = splitVersionString($versionString);
1590 }
1591 
1592 sub osXVersion()
1593 {
1594     determineOSXVersion();
1595     return $osXVersion;
1596 }
1597 
1598 sub determineIOSVersion()
1599 {
1600     return if $iosVersion;
1601 
1602     if (!isIOSWebKit()) {
1603         $iosVersion = -1;
1604         return;
1605     }
1606 
1607     my $versionString = xcodeSDKVersion();
1608     $iosVersion = splitVersionString($versionString);
1609 }
1610 
1611 sub iosVersion()
1612 {
1613     determineIOSVersion();
1614     return $iosVersion;
1615 }
1616 
1617 sub isWindowsNT()
1618 {
1619     return $ENV{&#39;OS&#39;} eq &#39;Windows_NT&#39;;
1620 }
1621 
1622 sub appendToEnvironmentVariableList($$)
1623 {
1624     my ($name, $value) = @_;
1625 
1626     if (defined($ENV{$name})) {
1627         $ENV{$name} .= $Config{path_sep} . $value;
1628     } else {
1629         $ENV{$name} = $value;
1630     }
1631 }
1632 
1633 sub prependToEnvironmentVariableList($$)
1634 {
1635     my ($name, $value) = @_;
1636 
1637     if (defined($ENV{$name})) {
1638         $ENV{$name} = $value . $Config{path_sep} . $ENV{$name};
1639     } else {
1640         $ENV{$name} = $value;
1641     }
1642 }
1643 
1644 sub sharedCommandLineOptions()
1645 {
1646     return (
1647         &quot;g|guard-malloc&quot; =&gt; \$shouldUseGuardMalloc,
1648     );
1649 }
1650 
1651 sub sharedCommandLineOptionsUsage
1652 {
1653     my %opts = @_;
1654 
1655     my %switches = (
1656         &#39;-g|--guard-malloc&#39; =&gt; &#39;Use guardmalloc when running executable&#39;,
1657     );
1658 
1659     my $indent = &quot; &quot; x ($opts{indent} || 2);
1660     my $switchWidth = List::Util::max(int($opts{switchWidth}), List::Util::max(map { length($_) } keys %switches) + ($opts{brackets} ? 2 : 0));
1661 
1662     my $result = &quot;Common switches:\n&quot;;
1663 
1664     for my $switch (keys %switches) {
1665         my $switchName = $opts{brackets} ? &quot;[&quot; . $switch . &quot;]&quot; : $switch;
1666         $result .= sprintf(&quot;%s%-&quot; . $switchWidth . &quot;s %s\n&quot;, $indent, $switchName, $switches{$switch});
1667     }
1668 
1669     return $result;
1670 }
1671 
1672 sub setUpGuardMallocIfNeeded
1673 {
1674     if (!isDarwin()) {
1675         return;
1676     }
1677 
1678     if (!defined($shouldUseGuardMalloc)) {
1679         $shouldUseGuardMalloc = checkForArgumentAndRemoveFromARGV(&quot;-g&quot;) || checkForArgumentAndRemoveFromARGV(&quot;--guard-malloc&quot;);
1680     }
1681 
1682     if ($shouldUseGuardMalloc) {
1683         appendToEnvironmentVariableList(&quot;DYLD_INSERT_LIBRARIES&quot;, &quot;/usr/lib/libgmalloc.dylib&quot;);
1684         appendToEnvironmentVariableList(&quot;__XPC_DYLD_INSERT_LIBRARIES&quot;, &quot;/usr/lib/libgmalloc.dylib&quot;);
1685     }
1686 }
1687 
1688 sub relativeScriptsDir()
1689 {
1690     my $scriptDir = File::Spec-&gt;catpath(&quot;&quot;, File::Spec-&gt;abs2rel($FindBin::Bin, getcwd()), &quot;&quot;);
1691     if ($scriptDir eq &quot;&quot;) {
1692         $scriptDir = &quot;.&quot;;
1693     }
1694     return $scriptDir;
1695 }
1696 
1697 sub launcherPath()
1698 {
1699     my $relativeScriptsPath = relativeScriptsDir();
1700     if (isGtk() || isWPE()) {
1701         if (inFlatpakSandbox()) {
1702             return &quot;Tools/Scripts/run-minibrowser&quot;;
1703         }
1704         return &quot;$relativeScriptsPath/run-minibrowser&quot;;
1705     } elsif (isAppleWebKit()) {
1706         return &quot;$relativeScriptsPath/run-safari&quot;;
1707     }
1708 }
1709 
1710 sub launcherName()
1711 {
1712     if (isGtk() || isWPE()) {
1713         return &quot;MiniBrowser&quot;;
1714     } elsif (isAppleMacWebKit()) {
1715         return &quot;Safari&quot;;
1716     } elsif (isAppleWinWebKit()) {
1717         return &quot;MiniBrowser&quot;;
1718     }
1719 }
1720 
1721 sub checkRequiredSystemConfig
1722 {
1723     if (isDarwin()) {
1724         chomp(my $productVersion = `sw_vers -productVersion`);
1725         if (eval &quot;v$productVersion&quot; lt v10.10.5) {
1726             print &quot;*************************************************************\n&quot;;
1727             print &quot;OS X Yosemite v10.10.5 or later is required to build WebKit.\n&quot;;
1728             print &quot;You have &quot; . $productVersion . &quot;, thus the build will most likely fail.\n&quot;;
1729             print &quot;*************************************************************\n&quot;;
1730         }
1731         determineXcodeVersion();
1732         if (eval &quot;v$xcodeVersion&quot; lt v7.0) {
1733             print &quot;*************************************************************\n&quot;;
1734             print &quot;Xcode 7.0 or later is required to build WebKit.\n&quot;;
1735             print &quot;You have an earlier version of Xcode, thus the build will\n&quot;;
1736             print &quot;most likely fail. The latest Xcode is available from the App Store.\n&quot;;
1737             print &quot;*************************************************************\n&quot;;
1738         }
1739     }
1740 }
1741 
1742 sub determineWindowsSourceDir()
1743 {
1744     return if $windowsSourceDir;
1745     $windowsSourceDir = sourceDir();
1746     chomp($windowsSourceDir = `cygpath -w &#39;$windowsSourceDir&#39;`) if isCygwin();
1747 }
1748 
1749 sub windowsSourceDir()
1750 {
1751     determineWindowsSourceDir();
1752     return $windowsSourceDir;
1753 }
1754 
1755 sub windowsSourceSourceDir()
1756 {
1757     return File::Spec-&gt;catdir(windowsSourceDir(), &quot;Source&quot;);
1758 }
1759 
1760 sub windowsLibrariesDir()
1761 {
1762     return File::Spec-&gt;catdir(windowsSourceDir(), &quot;WebKitLibraries&quot;, &quot;win&quot;);
1763 }
1764 
1765 sub windowsOutputDir()
1766 {
1767     return File::Spec-&gt;catdir(windowsSourceDir(), &quot;WebKitBuild&quot;);
1768 }
1769 
1770 sub fontExists($)
1771 {
1772     my $font = shift;
1773     my $cmd = &quot;reg query \&quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts\&quot; /v \&quot;$font\&quot; 2&gt;&amp;1&quot;;
1774     my $val = `$cmd`;
1775     return $? == 0;
1776 }
1777 
1778 sub checkInstalledTools()
1779 {
1780     # environment variables. Avoid until this is corrected.
1781     my $pythonVer = `python --version 2&gt;&amp;1`;
1782     die &quot;You must have Python installed to build WebKit.\n&quot; if ($?);
1783 
1784     # cURL 7.34.0 has a bug that prevents authentication with opensource.apple.com (and other things using SSL3).
1785     my $curlVer = `curl --version 2&gt; NUL`;
1786     if (!$? and $curlVer =~ &quot;(.*curl.*)&quot;) {
1787         $curlVer = $1;
1788         if ($curlVer =~ /libcurl\/7\.34\.0/) {
1789             print &quot;cURL version 7.34.0 has a bug that prevents authentication with SSL v2 or v3.\n&quot;;
1790             print &quot;cURL 7.33.0 is known to work. The cURL projects is preparing an update to\n&quot;;
1791             print &quot;correct this problem.\n\n&quot;;
1792             die &quot;Please install a working cURL and try again.\n&quot;;
1793         }
1794     }
1795 
1796     # MathML requires fonts that may not ship with Windows.
1797     # Warn the user if they are missing.
1798     my @fonts = (&#39;Cambria &amp; Cambria Math (TrueType)&#39;, &#39;LatinModernMath-Regular (TrueType)&#39;, &#39;STIXMath-Regular (TrueType)&#39;);
1799     my @missing = ();
1800     foreach my $font (@fonts) {
1801         push @missing, $font if not fontExists($font);
1802     }
1803 
1804     if (scalar @missing &gt; 0) {
1805         print &quot;*************************************************************\n&quot;;
1806         print &quot;Mathematical fonts, such as Latin Modern Math are needed to\n&quot;;
1807         print &quot;use the MathML feature.  You do not appear to have these fonts\n&quot;;
1808         print &quot;on your system.\n\n&quot;;
1809         print &quot;You can download a suitable set of fonts from the following URL:\n&quot;;
1810         print &quot;https://trac.webkit.org/wiki/MathML/Fonts\n&quot;;
1811         print &quot;*************************************************************\n&quot;;
1812     }
1813 
1814     print &quot;Installed tools are correct for the WebKit build.\n&quot;;
1815 }
1816 
1817 sub setupAppleWinEnv()
1818 {
1819     return unless isAppleWinWebKit();
1820 
1821     checkInstalledTools();
1822 
1823     if (isWindowsNT()) {
1824         my $restartNeeded = 0;
1825         my %variablesToSet = ();
1826 
1827         # FIXME: We should remove this explicit version check for cygwin once we stop supporting Cygwin 1.7.9 or older versions. 
1828         # https://bugs.webkit.org/show_bug.cgi?id=85791
1829         my $uname_version = (POSIX::uname())[2];
1830         $uname_version =~ s/\(.*\)//;  # Remove the trailing cygwin version, if any.
1831         $uname_version =~ s/\-.*$//; # Remove trailing dash-version content, if any
1832         if (version-&gt;parse($uname_version) &lt; version-&gt;parse(&quot;1.7.10&quot;)) {
1833             # Setting the environment variable &#39;CYGWIN&#39; to &#39;tty&#39; makes cygwin enable extra support (i.e., termios)
1834             # for UNIX-like ttys in the Windows console
1835             $variablesToSet{CYGWIN} = &quot;tty&quot; unless $ENV{CYGWIN};
1836         }
1837         
1838         # Those environment variables must be set to be able to build inside Visual Studio.
1839         $variablesToSet{WEBKIT_LIBRARIES} = windowsLibrariesDir() unless $ENV{WEBKIT_LIBRARIES};
1840         $variablesToSet{WEBKIT_OUTPUTDIR} = windowsOutputDir() unless $ENV{WEBKIT_OUTPUTDIR};
1841         $variablesToSet{MSBUILDDISABLENODEREUSE} = &quot;1&quot; unless $ENV{MSBUILDDISABLENODEREUSE};
1842         $variablesToSet{_IsNativeEnvironment} = &quot;true&quot; unless $ENV{_IsNativeEnvironment};
1843         $variablesToSet{PreferredToolArchitecture} = &quot;x64&quot; unless $ENV{PreferredToolArchitecture};
1844 
1845         foreach my $variable (keys %variablesToSet) {
1846             print &quot;Setting the Environment Variable &#39;&quot; . $variable . &quot;&#39; to &#39;&quot; . $variablesToSet{$variable} . &quot;&#39;\n\n&quot;;
1847             my $ret = system &quot;setx&quot;, $variable, $variablesToSet{$variable};
1848             if ($ret != 0) {
1849                 system qw(regtool -s set), &#39;\\HKEY_CURRENT_USER\\Environment\\&#39; . $variable, $variablesToSet{$variable};
1850             }
1851             $restartNeeded ||=  $variable eq &quot;WEBKIT_LIBRARIES&quot; || $variable eq &quot;WEBKIT_OUTPUTDIR&quot;;
1852         }
1853 
1854         if ($restartNeeded) {
1855             print &quot;Please restart your computer before attempting to build inside Visual Studio.\n\n&quot;;
1856         }
1857     } else {
1858         if (!defined $ENV{&#39;WEBKIT_LIBRARIES&#39;} || !$ENV{&#39;WEBKIT_LIBRARIES&#39;}) {
1859             print &quot;Warning: You must set the &#39;WebKit_Libraries&#39; environment variable\n&quot;;
1860             print &quot;         to be able build WebKit from within Visual Studio 2017 and newer.\n&quot;;
1861             print &quot;         Make sure that &#39;WebKit_Libraries&#39; points to the\n&quot;;
1862             print &quot;         &#39;WebKitLibraries/win&#39; directory, not the &#39;WebKitLibraries/&#39; directory.\n\n&quot;;
1863         }
1864         if (!defined $ENV{&#39;WEBKIT_OUTPUTDIR&#39;} || !$ENV{&#39;WEBKIT_OUTPUTDIR&#39;}) {
1865             print &quot;Warning: You must set the &#39;WebKit_OutputDir&#39; environment variable\n&quot;;
1866             print &quot;         to be able build WebKit from within Visual Studio 2017 and newer.\n\n&quot;;
1867         }
1868         if (!defined $ENV{&#39;MSBUILDDISABLENODEREUSE&#39;} || !$ENV{&#39;MSBUILDDISABLENODEREUSE&#39;}) {
1869             print &quot;Warning: You should set the &#39;MSBUILDDISABLENODEREUSE&#39; environment variable to &#39;1&#39;\n&quot;;
1870             print &quot;         to avoid periodic locked log files when building.\n\n&quot;;
1871         }
1872     }
1873     # FIXME (125180): Remove the following temporary 64-bit support once official support is available.
1874     if (isWin64() and !$ENV{&#39;WEBKIT_64_SUPPORT&#39;}) {
1875         print &quot;Warning: You must set the &#39;WEBKIT_64_SUPPORT&#39; environment variable\n&quot;;
1876         print &quot;         to be able run WebKit or JavaScriptCore tests.\n\n&quot;;
1877     }
1878 }
1879 
1880 sub setupCygwinEnv()
1881 {
1882     return if !isAnyWindows();
1883     return if $msBuildPath;
1884 
1885     my $programFilesPath = programFilesPath();
1886 
1887     print &quot;Building results into: &quot;, baseProductDir(), &quot;\n&quot;;
1888     print &quot;WEBKIT_OUTPUTDIR is set to: &quot;, $ENV{&quot;WEBKIT_OUTPUTDIR&quot;}, &quot;\n&quot;;
1889     print &quot;WEBKIT_LIBRARIES is set to: &quot;, $ENV{&quot;WEBKIT_LIBRARIES&quot;}, &quot;\n&quot;;
1890     # FIXME (125180): Remove the following temporary 64-bit support once official support is available.
1891     print &quot;WEBKIT_64_SUPPORT is set to: &quot;, $ENV{&quot;WEBKIT_64_SUPPORT&quot;}, &quot;\n&quot; if isWin64();
1892 
1893     # We will actually use MSBuild to build WebKit, but we need to find the Visual Studio install (above) to make
1894     # sure we use the right options.
1895     $msBuildPath = msBuildPath();
1896     if (! -e $msBuildPath) {
1897         print &quot;*************************************************************\n&quot;;
1898         print &quot;Cannot find &#39;$msBuildPath&#39;\n&quot;;
1899         print &quot;Please make sure execute that the Microsoft .NET Framework SDK\n&quot;;
1900         print &quot;is installed on this machine.\n&quot;;
1901         print &quot;*************************************************************\n&quot;;
1902         die;
1903     }
1904 }
1905 
1906 sub buildXCodeProject($$@)
1907 {
1908     my ($project, $clean, @extraOptions) = @_;
1909 
1910     if ($clean) {
1911         push(@extraOptions, &quot;-alltargets&quot;);
1912         push(@extraOptions, &quot;clean&quot;);
1913     }
1914 
1915     chomp($ENV{DSYMUTIL_NUM_THREADS} = `sysctl -n hw.activecpu`);
1916     return system &quot;xcodebuild&quot;, &quot;-project&quot;, &quot;$project.xcodeproj&quot;, @extraOptions;
1917 }
1918 
1919 sub getVisualStudioToolset()
1920 {
1921     if (isPlayStation()) {
1922         return &quot;&quot;;
1923     } elsif (isWin64()) {
1924         return &quot;x64&quot;;
1925     } else {
1926         return &quot;Win32&quot;;
1927     }
1928 }
1929 
1930 sub getMSBuildPlatformArgument()
1931 {
1932     my $toolset = getVisualStudioToolset();
1933     if (defined($toolset) &amp;&amp; length($toolset)) {
1934         return &quot;/p:Platform=$toolset&quot;;
1935     }
1936     return &quot;&quot;;
1937 }
1938 
1939 sub getCMakeWindowsToolsetArgument()
1940 {
1941     my $toolset = getVisualStudioToolset();
1942     if (defined($toolset) &amp;&amp; length($toolset)) {
1943         return &quot;-A $toolset&quot;;
1944     }
1945     return &quot;&quot;;
1946 }
1947 
1948 sub buildVisualStudioProject
1949 {
1950     my ($project, $clean) = @_;
1951     setupCygwinEnv();
1952 
1953     my $config = configurationForVisualStudio();
1954 
1955     chomp($project = `cygpath -w &quot;$project&quot;`) if isCygwin();
1956 
1957     my $action = &quot;/t:build&quot;;
1958     if ($clean) {
1959         $action = &quot;/t:clean&quot;;
1960     }
1961 
1962     my $platform = getMSBuildPlatformArgument();
1963     my $logPath = File::Spec-&gt;catdir($baseProductDir, $configuration);
1964     make_path($logPath) unless -d $logPath or $logPath eq &quot;.&quot;;
1965 
1966     my $errorLogFile = File::Spec-&gt;catfile($logPath, &quot;webkit_errors.log&quot;);
1967     chomp($errorLogFile = `cygpath -w &quot;$errorLogFile&quot;`) if isCygwin();
1968     my $errorLogging = &quot;/flp:LogFile=&quot; . $errorLogFile . &quot;;ErrorsOnly&quot;;
1969 
1970     my $warningLogFile = File::Spec-&gt;catfile($logPath, &quot;webkit_warnings.log&quot;);
1971     chomp($warningLogFile = `cygpath -w &quot;$warningLogFile&quot;`) if isCygwin();
1972     my $warningLogging = &quot;/flp1:LogFile=&quot; . $warningLogFile . &quot;;WarningsOnly&quot;;
1973 
1974     my $maxCPUCount = &#39;/maxcpucount:&#39; . numberOfCPUs();
1975 
1976     my @command = ($msBuildPath, &quot;/verbosity:minimal&quot;, $project, $action, $config, $platform, &quot;/fl&quot;, $errorLogging, &quot;/fl1&quot;, $warningLogging, $maxCPUCount);
1977     print join(&quot; &quot;, @command), &quot;\n&quot;;
1978     return system @command;
1979 }
1980 
1981 sub getJhbuildPath()
1982 {
1983     my @jhbuildPath = File::Spec-&gt;splitdir(baseProductDir());
1984     if (isGit() &amp;&amp; isGitBranchBuild() &amp;&amp; gitBranch()) {
1985         pop(@jhbuildPath);
1986     }
1987     if (isGtk()) {
1988         push(@jhbuildPath, &quot;DependenciesGTK&quot;);
1989     } elsif (isJava()) {
1990         push(@jhbuildPath, &quot;DependenciesJava&quot;);
1991     } elsif (isWPE()) {
1992         push(@jhbuildPath, &quot;DependenciesWPE&quot;);
1993     } else {
1994         die &quot;Cannot get JHBuild path for platform that isn&#39;t GTK+ or WPE.\n&quot;;
1995     }
1996     return File::Spec-&gt;catdir(@jhbuildPath);
1997 }
1998 
1999 sub getFlatpakPath()
2000 {
2001     my @flatpakBuildPath = File::Spec-&gt;splitdir(baseProductDir());
2002     if (isGtk()) {
2003         push(@flatpakBuildPath, &quot;GTK&quot;);
2004     } elsif (isWPE()) {
2005         push(@flatpakBuildPath, &quot;WPE&quot;);
2006     } else {
2007         die &quot;Cannot get Flatpak path for platform that isn&#39;t GTK+ or WPE.\n&quot;;
2008     }
2009     my @configuration = configuration();
2010     push(@flatpakBuildPath, &quot;FlatpakTree$configuration&quot;);
2011 
2012     return File::Spec-&gt;catdir(@flatpakBuildPath);
2013 }
2014 
2015 sub isCachedArgumentfileOutOfDate($@)
2016 {
2017     my ($filename, $currentContents) = @_;
2018 
2019     if (! -e $filename) {
2020         return 1;
2021     }
2022 
2023     open(CONTENTS_FILE, $filename);
2024     chomp(my $previousContents = &lt;CONTENTS_FILE&gt; || &quot;&quot;);
2025     close(CONTENTS_FILE);
2026 
2027     if ($previousContents ne $currentContents) {
2028         print &quot;Contents for file $filename have changed.\n&quot;;
2029         print &quot;Previous contents were: $previousContents\n\n&quot;;
2030         print &quot;New contents are: $currentContents\n&quot;;
2031         return 1;
2032     }
2033 
2034     return 0;
2035 }
2036 
2037 sub inFlatpakSandbox()
2038 {
2039     if (-f &quot;/.flatpak-info&quot;) {
2040         return 1;
2041     }
2042 
2043     return 0;
2044 }
2045 
2046 sub runInFlatpak(@)
2047 {
2048     my @arg = @_;
2049     my @command = (File::Spec-&gt;catfile(sourceDir(), &quot;Tools&quot;, &quot;Scripts&quot;, &quot;webkit-flatpak&quot;));
2050     exec @command, argumentsForConfiguration(), &quot;--command&quot;, @_, argumentsForConfiguration(), @ARGV or die;
2051 }
2052 
2053 sub runInFlatpakIfAvailable(@)
2054 {
2055     if (inFlatpakSandbox()) {
2056         return 0;
2057     }
2058 
2059     my @command = (File::Spec-&gt;catfile(sourceDir(), &quot;Tools&quot;, &quot;Scripts&quot;, &quot;webkit-flatpak&quot;));
2060     if (system(@command, &quot;--available&quot;) != 0) {
2061         return 0;
2062     }
2063 
2064     if (! -e getFlatpakPath()) {
2065         return 0;
2066     }
2067 
2068     runInFlatpak(@_)
2069 }
2070 
2071 sub wrapperPrefixIfNeeded()
2072 {
2073     if (isJava()) {
2074         return ();
2075     }
2076 
2077     if (isAnyWindows() || isJSCOnly() || isPlayStation()) {
2078         return ();
2079     }
2080     if (isAppleCocoaWebKit()) {
2081         return (&quot;xcrun&quot;);
2082     }
2083     if (shouldUseJhbuild() and ! shouldUseFlatpak()) {
2084         my @prefix = (File::Spec-&gt;catfile(sourceDir(), &quot;Tools&quot;, &quot;jhbuild&quot;, &quot;jhbuild-wrapper&quot;));
2085         if (isGtk()) {
2086             push(@prefix, &quot;--gtk&quot;);
2087         } elsif (isWPE()) {
2088             push(@prefix, &quot;--wpe&quot;);
2089         }
2090         push(@prefix, &quot;run&quot;);
2091 
2092         return @prefix;
2093     }
2094 
2095     return ();
2096 }
2097 
2098 sub shouldUseJhbuild()
2099 {
2100     return ((isGtk() or isWPE()) and -e getJhbuildPath());
2101 }
2102 
2103 sub shouldUseFlatpak()
2104 {
2105     return ((isGtk() or isWPE()) and ! inFlatpakSandbox() and -e getFlatpakPath());
2106 }
2107 
2108 sub cmakeCachePath()
2109 {
2110     return File::Spec-&gt;catdir(baseProductDir(), configuration(), &quot;CMakeCache.txt&quot;);
2111 }
2112 
2113 sub cmakeFilesPath()
2114 {
2115     return File::Spec-&gt;catdir(baseProductDir(), configuration(), &quot;CMakeFiles&quot;);
2116 }
2117 
2118 sub shouldRemoveCMakeCache(@)
2119 {
2120     my ($cacheFilePath, @buildArgs) = @_;
2121 
2122     # We check this first, because we always want to create this file for a fresh build.
2123     my $productDir = File::Spec-&gt;catdir(baseProductDir(), configuration());
2124     my $optionsCache = File::Spec-&gt;catdir($productDir, &quot;build-webkit-options.txt&quot;);
2125     my $joinedBuildArgs = join(&quot; &quot;, @buildArgs);
2126     if (isCachedArgumentfileOutOfDate($optionsCache, $joinedBuildArgs)) {
2127         File::Path::mkpath($productDir) unless -d $productDir;
2128         open(CACHED_ARGUMENTS, &quot;&gt;&quot;, $optionsCache);
2129         print CACHED_ARGUMENTS $joinedBuildArgs;
2130         close(CACHED_ARGUMENTS);
2131 
2132         return 1;
2133     }
2134 
2135     my $cmakeCache = cmakeCachePath();
2136     unless (-e $cmakeCache) {
2137         return 0;
2138     }
2139 
2140     my $cacheFileModifiedTime = stat($cmakeCache)-&gt;mtime;
2141     my $platformConfiguration = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;cmake&quot;, &quot;Options&quot; . cmakeBasedPortName() . &quot;.cmake&quot;);
2142     if ($cacheFileModifiedTime &lt; stat($platformConfiguration)-&gt;mtime) {
2143         return 1;
2144     }
2145 
2146     my $globalConfiguration = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;cmake&quot;, &quot;OptionsCommon.cmake&quot;);
2147     if ($cacheFileModifiedTime &lt; stat($globalConfiguration)-&gt;mtime) {
2148         return 1;
2149     }
2150 
2151     unless (isJava()) {
2152     # FIXME: This probably does not work as expected, or the next block to
2153     # delete the images subdirectory would not be here. Directory mtime does not
2154     # percolate upwards when files are added or removed from subdirectories.
2155     my $inspectorUserInterfaceDirectory = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;WebInspectorUI&quot;, &quot;UserInterface&quot;);
2156     if ($cacheFileModifiedTime &lt; stat($inspectorUserInterfaceDirectory)-&gt;mtime) {
2157         return 1;
2158     }
2159 
2160     my $inspectorImageDirectory = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;WebInspectorUI&quot;, &quot;UserInterface&quot;, &quot;Images&quot;);
2161     if ($cacheFileModifiedTime &lt; stat($inspectorImageDirectory)-&gt;mtime) {
2162         return 1;
2163     }
2164     }
2165 
2166     if(isAnyWindows()) {
2167         my $winConfiguration = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;cmake&quot;, &quot;OptionsWin.cmake&quot;);
2168         if ($cacheFileModifiedTime &lt; stat($winConfiguration)-&gt;mtime) {
2169             return 1;
2170         }
2171     }
2172 
2173     # If a change on the JHBuild moduleset has been done, we need to clean the cache as well.
2174     if (isGtk() || isWPE()) {
2175         my $jhbuildRootDirectory = File::Spec-&gt;catdir(getJhbuildPath(), &quot;Root&quot;);
2176         # The script update-webkit-libs-jhbuild shall re-generate $jhbuildRootDirectory if the moduleset changed.
2177         if (-d $jhbuildRootDirectory &amp;&amp; $cacheFileModifiedTime &lt; stat($jhbuildRootDirectory)-&gt;mtime) {
2178             return 1;
2179         }
2180     }
2181 
2182     return 0;
2183 }
2184 
2185 sub removeCMakeCache(@)
2186 {
2187     my (@buildArgs) = @_;
2188     if (shouldRemoveCMakeCache(@buildArgs)) {
2189         my $cmakeCache = cmakeCachePath();
2190         my $cmakeFiles = cmakeFilesPath();
2191         unlink($cmakeCache) if -e $cmakeCache;
2192         rmtree($cmakeFiles) if -d $cmakeFiles;
2193     }
2194 }
2195 
2196 sub canUseNinja(@)
2197 {
2198     if (!defined($shouldNotUseNinja)) {
2199         $shouldNotUseNinja = checkForArgumentAndRemoveFromARGV(&quot;--no-ninja&quot;);
2200     }
2201 
2202     if ($shouldNotUseNinja) {
2203         return 0;
2204     }
2205 
2206     if (isAppleCocoaWebKit()) {
2207         my $devnull = File::Spec-&gt;devnull();
2208         if (exitStatus(system(&quot;xcrun -find ninja &gt;$devnull 2&gt;&amp;1&quot;)) == 0) {
2209             return 1;
2210         }
2211     }
2212 
2213     # Test both ninja and ninja-build. Fedora uses ninja-build and has patched CMake to also call ninja-build.
2214     return commandExists(&quot;ninja&quot;) || commandExists(&quot;ninja-build&quot;);
2215 }
2216 
2217 sub canUseEclipseNinjaGenerator(@)
2218 {
2219     # Check that eclipse and eclipse Ninja generator is installed
2220     my $devnull = File::Spec-&gt;devnull();
2221     return commandExists(&quot;eclipse&quot;) &amp;&amp; exitStatus(system(&quot;cmake -N -G &#39;Eclipse CDT4 - Ninja&#39; &gt;$devnull 2&gt;&amp;1&quot;)) == 0;
2222 }
2223 
2224 sub cmakeGeneratedBuildfile(@)
2225 {
2226     my ($willUseNinja) = @_;
2227     if ($willUseNinja) {
2228         return File::Spec-&gt;catfile(baseProductDir(), configuration(), &quot;build.ninja&quot;)
2229     } elsif (isAnyWindows()) {
2230         return File::Spec-&gt;catfile(baseProductDir(), configuration(), &quot;WebKit.sln&quot;)
2231     } else {
2232         return File::Spec-&gt;catfile(baseProductDir(), configuration(), &quot;Makefile&quot;)
2233     }
2234 }
2235 
2236 sub generateBuildSystemFromCMakeProject
2237 {
2238     my ($prefixPath, @cmakeArgs) = @_;
2239     my $config = configuration();
2240     my $port = cmakeBasedPortName();
2241     my $buildPath = File::Spec-&gt;catdir(baseProductDir(), $config);
2242     File::Path::mkpath($buildPath) unless -d $buildPath;
2243     my $originalWorkingDirectory = getcwd();
2244     chdir($buildPath) or die;
2245 
2246     # We try to be smart about when to rerun cmake, so that we can have faster incremental builds.
2247     my $willUseNinja = canUseNinja();
2248     if (-e cmakeCachePath() &amp;&amp; -e cmakeGeneratedBuildfile($willUseNinja)) {
2249         return 0;
2250     }
2251 
2252     my @args;
2253     push @args, &quot;-DPORT=\&quot;$port\&quot;&quot;;
2254     push @args, &quot;-DCMAKE_INSTALL_PREFIX=\&quot;$prefixPath\&quot;&quot; if $prefixPath;
2255     push @args, &quot;-DCMAKE_EXPORT_COMPILE_COMMANDS=ON&quot;;
2256     if ($config =~ /release/i) {
2257         push @args, &quot;-DCMAKE_BUILD_TYPE=Release&quot;;
2258     } elsif ($config =~ /debug/i) {
2259         push @args, &quot;-DCMAKE_BUILD_TYPE=Debug&quot;;
2260     }
2261 
2262     push @args, &quot;-DENABLE_SANITIZERS=address&quot; if asanIsEnabled();
2263 
2264     push @args, &quot;-DLTO_MODE=$ltoMode&quot; if ltoMode();
2265 
2266     push @args, &#39;-DCMAKE_TOOLCHAIN_FILE=Platform/PlayStation&#39; if isPlayStation();
2267 
2268     if ($willUseNinja) {
2269         push @args, &quot;-G&quot;;
2270         if (canUseEclipseNinjaGenerator()) {
2271             push @args, &quot;&#39;Eclipse CDT4 - Ninja&#39;&quot;;
2272         } else {
2273             push @args, &quot;Ninja&quot;;
2274         }
2275         push @args, &quot;-DUSE_THIN_ARCHIVES=OFF&quot; if isPlayStation();
2276     } elsif (isJava() &amp;&amp; isAnyWindows()) {
2277         push @args, &quot;-G&quot;;
2278         if (isWin64()) {
2279             push @args, &#39;&quot;Visual Studio 15 2017 Win64&quot;&#39;;
2280             push @args, &#39;-DCMAKE_GENERATOR_TOOLSET=&quot;host=x64&quot;&#39;;
2281         } else {
2282             push @args, &#39;&quot;Visual Studio 15 2017&quot;&#39;;
2283         }
2284     } else {
2285         if (isAnyWindows()) {
2286             push @args, getCMakeWindowsToolsetArgument();
2287         }
2288         if ((isAnyWindows() || isPlayStation()) &amp;&amp; defined $ENV{VisualStudioVersion}) {
2289             my $var = int($ENV{VisualStudioVersion});
2290             push @args, qq(-G &quot;Visual Studio $var&quot;);
2291         }
2292     }
2293 
2294     # Do not show progress of generating bindings in interactive Ninja build not to leave noisy lines on tty
2295     push @args, &#39;-DSHOW_BINDINGS_GENERATION_PROGRESS=1&#39; unless ($willUseNinja &amp;&amp; -t STDOUT);
2296 
2297     # Some ports have production mode, but build-webkit should always use developer mode.
2298     push @args, &quot;-DDEVELOPER_MODE=ON&quot; if isGtk() || isJSCOnly() || isWPE() || isWinCairo();
2299 
2300     if (architecture() eq &quot;x86_64&quot; &amp;&amp; shouldBuild32Bit() &amp;&amp; !(isJava() &amp;&amp; isCygwin())) {
2301         # CMAKE_LIBRARY_ARCHITECTURE is needed to get the right .pc
2302         # files in Debian-based systems, for the others
2303         # CMAKE_PREFIX_PATH will get us /usr/lib, which should be the
2304         # right path for 32bit. See FindPkgConfig.cmake.
2305         push @cmakeArgs, &#39;-DFORCE_32BIT=ON -DCMAKE_PREFIX_PATH=&quot;/usr&quot; -DCMAKE_LIBRARY_ARCHITECTURE=x86&#39;;
2306         $ENV{&quot;CFLAGS&quot;} =  &quot;-m32&quot; . ($ENV{&quot;CFLAGS&quot;} || &quot;&quot;);
2307         $ENV{&quot;CXXFLAGS&quot;} = &quot;-m32&quot; . ($ENV{&quot;CXXFLAGS&quot;} || &quot;&quot;);
2308         $ENV{&quot;LDFLAGS&quot;} = &quot;-m32&quot; . ($ENV{&quot;LDFLAGS&quot;} || &quot;&quot;);
2309     }
2310     push @args, @cmakeArgs if @cmakeArgs;
2311 
2312     my $cmakeSourceDir = isCygwin() ? windowsSourceDir() : sourceDir();
2313     push @args, &#39;&quot;&#39; . $cmakeSourceDir . &#39;&quot;&#39;;
2314 
2315     # We call system(&quot;cmake @args&quot;) instead of system(&quot;cmake&quot;, @args) so that @args is
2316     # parsed for shell metacharacters.
2317     my $wrapper = join(&quot; &quot;, wrapperPrefixIfNeeded()) . &quot; &quot;;
2318     my $returnCode = systemVerbose($wrapper . &quot;cmake @args&quot;);
2319 
2320     chdir($originalWorkingDirectory);
2321     return $returnCode;
2322 }
2323 
2324 sub buildCMakeGeneratedProject($)
2325 {
2326     my (@makeArgs) = @_;
2327     my $config = configuration();
2328     my $buildPath = File::Spec-&gt;catdir(baseProductDir(), $config);
2329     if (! -d $buildPath) {
2330         die &quot;Must call generateBuildSystemFromCMakeProject() before building CMake project.&quot;;
2331     }
2332 
2333     if ($ENV{VERBOSE} &amp;&amp; canUseNinja()) {
2334         push @makeArgs, &quot;-v&quot;;
2335         push @makeArgs, &quot;-d keeprsp&quot; if (version-&gt;parse(determineNinjaVersion()) &gt;= version-&gt;parse(&quot;1.4.0&quot;));
2336     }
2337 
2338     my $command = &quot;cmake&quot;;
2339     my @args = (&quot;--build&quot;, $buildPath, &quot;--config&quot;, $config);
2340     push @args, (&quot;--&quot;, @makeArgs) if @makeArgs;
2341 
2342     # GTK and JSCOnly can use a build script to preserve colors and pretty-printing.
2343     if ((isGtk() || isJSCOnly()) &amp;&amp; -e &quot;$buildPath/build.sh&quot;) {
2344         chdir &quot;$buildPath&quot; or die;
2345         $command = &quot;$buildPath/build.sh&quot;;
2346         @args = (@makeArgs);
2347     }
2348 
2349     # We call system(&quot;cmake @args&quot;) instead of system(&quot;cmake&quot;, @args) so that @args is
2350     # parsed for shell metacharacters. In particular, @makeArgs may contain such metacharacters.
2351     my $wrapper = join(&quot; &quot;, wrapperPrefixIfNeeded()) . &quot; &quot;;
2352     return systemVerbose($wrapper . &quot;$command @args&quot;);
2353 }
2354 
2355 sub cleanCMakeGeneratedProject()
2356 {
2357     my $config = configuration();
2358     my $buildPath = File::Spec-&gt;catdir(baseProductDir(), $config);
2359     if (-d $buildPath) {
2360         return systemVerbose(&quot;cmake&quot;, &quot;--build&quot;, $buildPath, &quot;--config&quot;, $config, &quot;--target&quot;, &quot;clean&quot;);
2361     }
2362     return 0;
2363 }
2364 
2365 sub buildCMakeProjectOrExit($$$@)
2366 {
2367     my ($clean, $prefixPath, $makeArgs, @cmakeArgs) = @_;
2368     my $returnCode;
2369 
2370     exit(exitStatus(cleanCMakeGeneratedProject())) if $clean;
2371 
2372     if (isGtk() &amp;&amp; checkForArgumentAndRemoveFromARGV(&quot;--update-gtk&quot;)) {
2373         system(&quot;perl&quot;, &quot;$sourceDir/Tools/Scripts/update-webkitgtk-libs&quot;) == 0 or die $!;
2374     }
2375 
2376     if (isWPE() &amp;&amp; checkForArgumentAndRemoveFromARGV(&quot;--update-wpe&quot;)) {
2377         system(&quot;perl&quot;, &quot;$sourceDir/Tools/Scripts/update-webkitwpe-libs&quot;) == 0 or die $!;
2378     }
2379 
2380     $returnCode = exitStatus(generateBuildSystemFromCMakeProject($prefixPath, @cmakeArgs));
2381     exit($returnCode) if $returnCode;
2382     exit 0 if isGenerateProjectOnly();
2383 
2384     $returnCode = exitStatus(buildCMakeGeneratedProject($makeArgs));
2385     exit($returnCode) if $returnCode;
2386     return 0;
2387 }
2388 
2389 sub cmakeArgsFromFeatures(\@;$)
2390 {
2391     my ($featuresArrayRef, $enableExperimentalFeatures) = @_;
2392 
2393     my @args;
2394     push @args, &quot;-DENABLE_EXPERIMENTAL_FEATURES=ON&quot; if $enableExperimentalFeatures;
2395     foreach (@$featuresArrayRef) {
2396         my $featureName = $_-&gt;{define};
2397         if ($featureName) {
2398             my $featureValue = ${$_-&gt;{value}}; # Undef to let the build system use its default.
2399             if (defined($featureValue)) {
2400                 my $featureEnabled = $featureValue ? &quot;ON&quot; : &quot;OFF&quot;;
2401                 push @args, &quot;-D$featureName=$featureEnabled&quot;;
2402             }
2403         }
2404     }
2405     return @args;
2406 }
2407 
2408 sub cmakeBasedPortName()
2409 {
2410     return ucfirst portName();
2411 }
2412 
2413 sub determineIsCMakeBuild()
2414 {
2415     return if defined($isCMakeBuild);
2416     $isCMakeBuild = checkForArgumentAndRemoveFromARGV(&quot;--cmake&quot;);
2417 }
2418 
2419 sub isCMakeBuild()
2420 {
2421     return 1 unless isAppleCocoaWebKit();
2422     determineIsCMakeBuild();
2423     return $isCMakeBuild;
2424 }
2425 
2426 sub determineIsGenerateProjectOnly()
2427 {
2428     return if defined($isGenerateProjectOnly);
2429     $isGenerateProjectOnly = checkForArgumentAndRemoveFromARGV(&quot;--generate-project-only&quot;);
2430 }
2431 
2432 sub isGenerateProjectOnly()
2433 {
2434     determineIsGenerateProjectOnly();
2435     return $isGenerateProjectOnly;
2436 }
2437 
2438 sub promptUser
2439 {
2440     my ($prompt, $default) = @_;
2441     my $defaultValue = $default ? &quot;[$default]&quot; : &quot;&quot;;
2442     print &quot;$prompt $defaultValue: &quot;;
2443     chomp(my $input = &lt;STDIN&gt;);
2444     return $input ? $input : $default;
2445 }
2446 
2447 sub appleApplicationSupportPath
2448 {
2449     open INSTALL_DIR, &quot;&lt;/proc/registry/HKEY_LOCAL_MACHINE/SOFTWARE/Apple\ Inc./Apple\ Application\ Support/InstallDir&quot;;
2450     my $path = &lt;INSTALL_DIR&gt;;
2451     $path =~ s/[\r\n\x00].*//;
2452     close INSTALL_DIR;
2453 
2454     my $unixPath = `cygpath -u &#39;$path&#39;`;
2455     chomp $unixPath;
2456     return $unixPath;
2457 }
2458 
2459 sub setPathForRunningWebKitApp
2460 {
2461     my ($env) = @_;
2462 
2463     if (isAnyWindows()) {
2464         my $productBinaryDir = executableProductDir();
2465         if (isAppleWinWebKit()) {
2466             $env-&gt;{PATH} = join(&#39;:&#39;, $productBinaryDir, appleApplicationSupportPath(), $env-&gt;{PATH} || &quot;&quot;);
2467         } elsif (isWinCairo()) {
2468             my $winCairoBin = sourceDir() . &quot;/WebKitLibraries/win/&quot; . (isWin64() ? &quot;bin64/&quot; : &quot;bin32/&quot;);
2469             my $gstreamerBin = isWin64() ? $ENV{&quot;GSTREAMER_1_0_ROOT_X86_64&quot;} . &quot;bin&quot; : $ENV{&quot;GSTREAMER_1_0_ROOT_X86&quot;} . &quot;bin&quot;;
2470             $env-&gt;{PATH} = join(&#39;:&#39;, $productBinaryDir, $winCairoBin, $gstreamerBin, $env-&gt;{PATH} || &quot;&quot;);
2471         }
2472     }
2473 }
2474 
2475 sub printHelpAndExitForRunAndDebugWebKitAppIfNeeded
2476 {
2477     return unless checkForArgumentAndRemoveFromARGV(&quot;--help&quot;);
2478 
2479     print STDERR &lt;&lt;EOF;
2480 Usage: @{[basename($0)]} [options] [args ...]
2481   --help                            Show this help message
2482   --no-saved-state                  Launch the application without state restoration
2483 
2484 Options specific to macOS:
2485   -g|--guard-malloc                 Enable Guard Malloc
2486   --lang=LANGUAGE                   Use a specific language instead of system language.
2487                                     This accepts a language name (German) or a language code (de, ar, pt_BR, etc).
2488   --locale=LOCALE                   Use a specific locale instead of the system region.
2489 EOF
2490 
2491     exit(1);
2492 }
2493 
2494 sub argumentsForRunAndDebugMacWebKitApp()
2495 {
2496     my @args = ();
2497     if (checkForArgumentAndRemoveFromARGV(&quot;--no-saved-state&quot;)) {
2498         push @args, (&quot;-ApplePersistenceIgnoreStateQuietly&quot;, &quot;YES&quot;);
2499         # FIXME: Don&#39;t set ApplePersistenceIgnoreState once all supported OS versions respect ApplePersistenceIgnoreStateQuietly (rdar://15032886).
2500         push @args, (&quot;-ApplePersistenceIgnoreState&quot;, &quot;YES&quot;);
2501     }
2502 
2503     my $lang;
2504     if (checkForArgumentAndRemoveFromARGVGettingValue(&quot;--lang&quot;, \$lang)) {
2505         push @args, (&quot;-AppleLanguages&quot;, &quot;(&quot; . $lang . &quot;)&quot;);
2506     }
2507 
2508     my $locale;
2509     if (checkForArgumentAndRemoveFromARGVGettingValue(&quot;--locale&quot;, \$locale)) {
2510         push @args, (&quot;-AppleLocale&quot;, $locale);
2511     }
2512 
2513     unshift @args, @ARGV;
2514 
2515     return @args;
2516 }
2517 
2518 sub setupMacWebKitEnvironment($)
2519 {
2520     my ($dyldFrameworkPath) = @_;
2521 
2522     $dyldFrameworkPath = File::Spec-&gt;rel2abs($dyldFrameworkPath);
2523 
2524     prependToEnvironmentVariableList(&quot;DYLD_FRAMEWORK_PATH&quot;, $dyldFrameworkPath);
2525     prependToEnvironmentVariableList(&quot;__XPC_DYLD_FRAMEWORK_PATH&quot;, $dyldFrameworkPath);
2526     prependToEnvironmentVariableList(&quot;DYLD_LIBRARY_PATH&quot;, $dyldFrameworkPath);
2527     prependToEnvironmentVariableList(&quot;__XPC_DYLD_LIBRARY_PATH&quot;, $dyldFrameworkPath);
2528     $ENV{WEBKIT_UNSET_DYLD_FRAMEWORK_PATH} = &quot;YES&quot;;
2529 
2530     setUpGuardMallocIfNeeded();
2531 }
2532 
2533 sub setupUnixWebKitEnvironment($)
2534 {
2535     my ($productDir) = @_;
2536 
2537     $ENV{TEST_RUNNER_INJECTED_BUNDLE_FILENAME} = File::Spec-&gt;catfile($productDir, &quot;lib&quot;, &quot;libTestRunnerInjectedBundle.so&quot;);
2538     $ENV{TEST_RUNNER_TEST_PLUGIN_PATH} = File::Spec-&gt;catdir($productDir, &quot;lib&quot;, &quot;plugins&quot;);
2539 }
2540 
2541 sub setupIOSWebKitEnvironment($)
2542 {
2543     my ($dyldFrameworkPath) = @_;
2544     $dyldFrameworkPath = File::Spec-&gt;rel2abs($dyldFrameworkPath);
2545 
2546     prependToEnvironmentVariableList(&quot;DYLD_FRAMEWORK_PATH&quot;, $dyldFrameworkPath);
2547     prependToEnvironmentVariableList(&quot;DYLD_LIBRARY_PATH&quot;, $dyldFrameworkPath);
2548 
2549     setUpGuardMallocIfNeeded();
2550 }
2551 
2552 sub iosSimulatorApplicationsPath()
2553 {
2554     # FIXME: We should ask simctl for this information, instead of guessing from available runtimes.
2555     my $runtimePath = File::Spec-&gt;catdir(sdkPlatformDirectory(&quot;iphoneos&quot;), &quot;Developer&quot;, &quot;Library&quot;, &quot;CoreSimulator&quot;, &quot;Profiles&quot;, &quot;Runtimes&quot;);
2556     opendir(RUNTIMES, $runtimePath);
2557     my @runtimes = grep {/.*\.simruntime/} readdir(RUNTIMES);
2558     close(RUNTIMES);
2559     my $sult = File::Spec-&gt;catdir($runtimePath, @runtimes ? $runtimes[0] : &quot;iOS.simruntime&quot;, &quot;Contents&quot;, &quot;Resources&quot;, &quot;RuntimeRoot&quot;, &quot;Applications&quot;);
2560     return $sult;
2561 }
2562 
2563 sub installedMobileSafariBundle()
2564 {
2565     return File::Spec-&gt;catfile(iosSimulatorApplicationsPath(), &quot;MobileSafari.app&quot;);
2566 }
2567 
2568 sub mobileSafariBundle()
2569 {
2570     determineConfigurationProductDir();
2571 
2572     # Use MobileSafari.app in product directory if present.
2573     if (isIOSWebKit() &amp;&amp; -d &quot;$configurationProductDir/MobileSafari.app&quot;) {
2574         return &quot;$configurationProductDir/MobileSafari.app&quot;;
2575     }
2576     return installedMobileSafariBundle();
2577 }
2578 
2579 sub plistPathFromBundle($)
2580 {
2581     my ($appBundle) = @_;
2582     return &quot;$appBundle/Info.plist&quot; if -f &quot;$appBundle/Info.plist&quot;; # iOS app bundle
2583     return &quot;$appBundle/Contents/Info.plist&quot; if -f &quot;$appBundle/Contents/Info.plist&quot;; # Mac app bundle
2584     return &quot;&quot;;
2585 }
2586 
2587 sub appIdentifierFromBundle($)
2588 {
2589     my ($appBundle) = @_;
2590     my $plistPath = File::Spec-&gt;rel2abs(plistPathFromBundle($appBundle)); # defaults(1) will complain if the specified path is not absolute.
2591     chomp(my $bundleIdentifier = `defaults read &#39;$plistPath&#39; CFBundleIdentifier 2&gt; /dev/null`);
2592     return $bundleIdentifier;
2593 }
2594 
2595 sub appDisplayNameFromBundle($)
2596 {
2597     my ($appBundle) = @_;
2598     my $plistPath = File::Spec-&gt;rel2abs(plistPathFromBundle($appBundle)); # defaults(1) will complain if the specified path is not absolute.
2599     chomp(my $bundleDisplayName = `defaults read &#39;$plistPath&#39; CFBundleDisplayName 2&gt; /dev/null`);
2600     return $bundleDisplayName;
2601 }
2602 
2603 sub waitUntilIOSSimulatorDeviceIsInState($$)
2604 {
2605     my ($deviceUDID, $waitUntilState) = @_;
2606     my $device = iosSimulatorDeviceByUDID($deviceUDID);
2607     # FIXME: We should add a maximum time limit to wait here.
2608     while ($device-&gt;{state} ne $waitUntilState) {
2609         usleep(500 * 1000); # Waiting 500ms between file system polls does not make script run-safari feel sluggish.
2610         $device = iosSimulatorDeviceByUDID($deviceUDID);
2611     }
2612 }
2613 
2614 sub waitUntilProcessNotRunning($)
2615 {
2616     my ($process) = @_;
2617     while (system(&quot;/bin/ps -eo pid,comm | /usr/bin/grep &#39;$process\$&#39;&quot;) == 0) {
2618         usleep(500 * 1000);
2619     }
2620 }
2621 
2622 sub shutDownIOSSimulatorDevice($)
2623 {
2624     my ($simulatorDevice) = @_;
2625     system(&quot;xcrun --sdk iphonesimulator simctl shutdown $simulatorDevice-&gt;{UDID} &gt; /dev/null 2&gt;&amp;1&quot;);
2626 }
2627 
2628 sub restartIOSSimulatorDevice($)
2629 {
2630     my ($simulatorDevice) = @_;
2631     shutDownIOSSimulatorDevice($simulatorDevice);
2632 
2633     exitStatus(system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;boot&quot;, $simulatorDevice-&gt;{UDID})) == 0 or die &quot;Failed to boot simulator device $simulatorDevice-&gt;{UDID}&quot;;
2634 }
2635 
2636 sub relaunchIOSSimulator($)
2637 {
2638     my ($simulatedDevice) = @_;
2639     quitIOSSimulator($simulatedDevice-&gt;{UDID});
2640 
2641     # FIXME: &lt;rdar://problem/20916140&gt; Switch to using CoreSimulator.framework for launching and quitting iOS Simulator
2642     chomp(my $developerDirectory = $ENV{DEVELOPER_DIR} || `xcode-select --print-path`); 
2643     my $iosSimulatorPath = File::Spec-&gt;catfile($developerDirectory, &quot;Applications&quot;, &quot;Simulator.app&quot;); 
2644     system(&quot;open&quot;, &quot;-a&quot;, $iosSimulatorPath, &quot;--args&quot;, &quot;-CurrentDeviceUDID&quot;, $simulatedDevice-&gt;{UDID}) == 0 or die &quot;Failed to open $iosSimulatorPath: $!&quot;; 
2645 
2646     waitUntilIOSSimulatorDeviceIsInState($simulatedDevice-&gt;{UDID}, SIMULATOR_DEVICE_STATE_BOOTED);
2647     waitUntilProcessNotRunning(&quot;com.apple.datamigrator&quot;);
2648 }
2649 
2650 sub quitIOSSimulator(;$)
2651 {
2652     my ($waitForShutdownOfSimulatedDeviceUDID) = @_;
2653     # FIXME: &lt;rdar://problem/20916140&gt; Switch to using CoreSimulator.framework for launching and quitting iOS Simulator
2654     if (exitStatus(system {&quot;osascript&quot;} &quot;osascript&quot;, &quot;-e&quot;, &#39;tell application id &quot;com.apple.iphonesimulator&quot; to quit&#39;)) {
2655         # osascript returns a non-zero exit status if Simulator.app is not registered in LaunchServices.
2656         return;
2657     }
2658 
2659     if (!defined($waitForShutdownOfSimulatedDeviceUDID)) {
2660         return;
2661     }
2662     # FIXME: We assume that $waitForShutdownOfSimulatedDeviceUDID was not booted using the simctl command line tool.
2663     #        Otherwise we will spin indefinitely since quiting the iOS Simulator will not shutdown this device. We
2664     #        should add a maximum time limit to wait for a device to shutdown and either return an error or die()
2665     #        on expiration of the time limit.
2666     waitUntilIOSSimulatorDeviceIsInState($waitForShutdownOfSimulatedDeviceUDID, SIMULATOR_DEVICE_STATE_SHUTDOWN);
2667 }
2668 
2669 sub iosSimulatorDeviceByName($)
2670 {
2671     my ($simulatorName) = @_;
2672     my $simulatorRuntime = iosSimulatorRuntime();
2673     my @devices = iOSSimulatorDevices();
2674     for my $device (@devices) {
2675         if ($device-&gt;{name} eq $simulatorName &amp;&amp; $device-&gt;{runtime} eq $simulatorRuntime) {
2676             return $device;
2677         }
2678     }
2679     return undef;
2680 }
2681 
2682 sub iosSimulatorDeviceByUDID($)
2683 {
2684     my ($simulatedDeviceUDID) = @_;
2685     my $devicePlistPath = File::Spec-&gt;catfile(iOSSimulatorDevicesPath(), $simulatedDeviceUDID, &quot;device.plist&quot;);
2686     if (!-f $devicePlistPath) {
2687         return;
2688     }
2689     # FIXME: We should parse the device.plist file ourself and map the dictionary keys in it to known
2690     #        dictionary keys so as to decouple our representation of the plist from the actual structure
2691     #        of the plist, which may change.
2692     eval &quot;require Foundation&quot;;
2693     return Foundation::perlRefFromObjectRef(NSDictionary-&gt;dictionaryWithContentsOfFile_($devicePlistPath));
2694 }
2695 
2696 sub iosSimulatorRuntime()
2697 {
2698     my $xcodeSDKVersion = xcodeSDKVersion();
2699     $xcodeSDKVersion =~ s/\./-/;
2700     return &quot;com.apple.CoreSimulator.SimRuntime.iOS-$xcodeSDKVersion&quot;;
2701 }
2702 
2703 sub findOrCreateSimulatorForIOSDevice($)
2704 {
2705     my ($simulatorNameSuffix) = @_;
2706     my $simulatorName;
2707     my $simulatorDeviceType;
2708     if (architecture() eq &quot;x86_64&quot;) {
2709         $simulatorName = &quot;iPhone SE &quot; . $simulatorNameSuffix;
2710         $simulatorDeviceType = &quot;com.apple.CoreSimulator.SimDeviceType.iPhone-SE&quot;;
2711     } else {
2712         $simulatorName = &quot;iPhone 5 &quot; . $simulatorNameSuffix;
2713         $simulatorDeviceType = &quot;com.apple.CoreSimulator.SimDeviceType.iPhone-5&quot;;
2714     }
2715     my $simulatedDevice = iosSimulatorDeviceByName($simulatorName);
2716     return $simulatedDevice if $simulatedDevice;
2717     return createiOSSimulatorDevice($simulatorName, $simulatorDeviceType, iosSimulatorRuntime());
2718 }
2719 
2720 sub isIOSSimulatorSystemInstalledApp($)
2721 {
2722     my ($appBundle) = @_;
2723     my $simulatorApplicationsPath = realpath(iosSimulatorApplicationsPath());
2724     return substr(realpath($appBundle), 0, length($simulatorApplicationsPath)) eq $simulatorApplicationsPath;
2725 }
2726 
2727 sub hasUserInstalledAppInSimulatorDevice($$)
2728 {
2729     my ($appIdentifier, $simulatedDeviceUDID) = @_;
2730     my $userInstalledAppPath = File::Spec-&gt;catfile($ENV{HOME}, &quot;Library&quot;, &quot;Developer&quot;, &quot;CoreSimulator&quot;, &quot;Devices&quot;, $simulatedDeviceUDID, &quot;data&quot;, &quot;Containers&quot;, &quot;Bundle&quot;, &quot;Application&quot;);
2731     if (!-d $userInstalledAppPath) {
2732         return 0; # No user installed apps.
2733     }
2734     local @::userInstalledAppBundles;
2735     my $wantedFunction = sub {
2736         my $file = $_;
2737 
2738         # Ignore hidden files and directories.
2739         if ($file =~ /^\../) {
2740             $File::Find::prune = 1;
2741             return;
2742         }
2743 
2744         return if !-d $file || $file !~ /\.app$/;
2745         push @::userInstalledAppBundles, $File::Find::name;
2746         $File::Find::prune = 1; # Do not traverse contents of app bundle.
2747     };
2748     find($wantedFunction, $userInstalledAppPath);
2749     for my $userInstalledAppBundle (@::userInstalledAppBundles) {
2750         if (appIdentifierFromBundle($userInstalledAppBundle) eq $appIdentifier) {
2751             return 1; # Has user installed app.
2752         }
2753     }
2754     return 0; # Does not have user installed app.
2755 }
2756 
2757 sub isSimulatorDeviceBooted($)
2758 {
2759     my ($simulatedDeviceUDID) = @_;
2760     my $device = iosSimulatorDeviceByUDID($simulatedDeviceUDID);
2761     return $device &amp;&amp; $device-&gt;{state} eq SIMULATOR_DEVICE_STATE_BOOTED;
2762 }
2763 
2764 sub runIOSWebKitAppInSimulator($;$)
2765 {
2766     my ($appBundle, $simulatorOptions) = @_;
2767     my $productDir = productDir();
2768     my $appDisplayName = appDisplayNameFromBundle($appBundle);
2769     my $appIdentifier = appIdentifierFromBundle($appBundle);
2770     my $simulatedDevice = findOrCreateSimulatorForIOSDevice(SIMULATOR_DEVICE_SUFFIX_FOR_WEBKIT_DEVELOPMENT);
2771     my $simulatedDeviceUDID = $simulatedDevice-&gt;{UDID};
2772 
2773     my $willUseSystemInstalledApp = isIOSSimulatorSystemInstalledApp($appBundle);
2774     if ($willUseSystemInstalledApp) {
2775         if (hasUserInstalledAppInSimulatorDevice($appIdentifier, $simulatedDeviceUDID)) {
2776             # Restore the system-installed app in the simulator device corresponding to $appBundle as it
2777             # was previously overwritten with a custom built version of the app.
2778             # FIXME: Only restore the system-installed version of the app instead of erasing all contents and settings.
2779             print &quot;Quitting iOS Simulator...\n&quot;;
2780             quitIOSSimulator($simulatedDeviceUDID);
2781             print &quot;Erasing contents and settings for simulator device \&quot;$simulatedDevice-&gt;{name}\&quot;.\n&quot;;
2782             exitStatus(system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;erase&quot;, $simulatedDeviceUDID)) == 0 or die;
2783         }
2784         # FIXME: We assume that if $simulatedDeviceUDID is not booted then iOS Simulator is not open. However
2785         #        $simulatedDeviceUDID may have been booted using the simctl command line tool. If $simulatedDeviceUDID
2786         #        was booted using simctl then we should shutdown the device and launch iOS Simulator to boot it again.
2787         if (!isSimulatorDeviceBooted($simulatedDeviceUDID)) {
2788             print &quot;Launching iOS Simulator...\n&quot;;
2789             relaunchIOSSimulator($simulatedDevice);
2790         }
2791     } else {
2792         # FIXME: We should killall(1) any running instances of $appBundle before installing it to ensure
2793         #        that simctl launch opens the latest installed version of the app. For now we quit and
2794         #        launch the iOS Simulator again to ensure there are no running instances of $appBundle.
2795         print &quot;Quitting and launching iOS Simulator...\n&quot;;
2796         relaunchIOSSimulator($simulatedDevice);
2797 
2798         print &quot;Installing $appBundle.\n&quot;;
2799         # Install custom built app, overwriting an app with the same app identifier if one exists.
2800         exitStatus(system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;install&quot;, $simulatedDeviceUDID, $appBundle)) == 0 or die;
2801 
2802     }
2803 
2804     $simulatorOptions = {} unless $simulatorOptions;
2805 
2806     my %simulatorENV;
2807     %simulatorENV = %{$simulatorOptions-&gt;{applicationEnvironment}} if $simulatorOptions-&gt;{applicationEnvironment};
2808     {
2809         local %ENV; # Shadow global-scope %ENV so that changes to it will not be seen outside of this scope.
2810         setupIOSWebKitEnvironment($productDir);
2811         %simulatorENV = %ENV;
2812     }
2813     my $applicationArguments = \@ARGV;
2814     $applicationArguments = $simulatorOptions-&gt;{applicationArguments} if $simulatorOptions &amp;&amp; $simulatorOptions-&gt;{applicationArguments};
2815 
2816     # Prefix the environment variables with SIMCTL_CHILD_ per `xcrun simctl help launch`.
2817     foreach my $key (keys %simulatorENV) {
2818         $ENV{&quot;SIMCTL_CHILD_$key&quot;} = $simulatorENV{$key};
2819     }
2820 
2821     print &quot;Starting $appDisplayName with DYLD_FRAMEWORK_PATH set to point to built WebKit in $productDir.\n&quot;;
2822     return exitStatus(system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;launch&quot;, $simulatedDeviceUDID, $appIdentifier, @$applicationArguments));
2823 }
2824 
2825 sub runIOSWebKitApp($)
2826 {
2827     my ($appBundle) = @_;
2828     if (willUseIOSDeviceSDK()) {
2829         die &quot;Only running Safari in iOS Simulator is supported now.&quot;;
2830     }
2831     if (willUseIOSSimulatorSDK()) {
2832         return runIOSWebKitAppInSimulator($appBundle);
2833     }
2834     die &quot;Not using an iOS SDK.&quot;
2835 }
2836 
2837 sub archCommandLineArgumentsForRestrictedEnvironmentVariables()
2838 {
2839     my @arguments = ();
2840     foreach my $key (keys(%ENV)) {
2841         if ($key =~ /^DYLD_/) {
2842             push @arguments, &quot;-e&quot;, &quot;$key=$ENV{$key}&quot;;
2843         }
2844     }
2845     return @arguments;
2846 }
2847 
2848 sub runMacWebKitApp($;$)
2849 {
2850     my ($appPath, $useOpenCommand) = @_;
2851     my $productDir = productDir();
2852     print &quot;Starting @{[basename($appPath)]} with DYLD_FRAMEWORK_PATH set to point to built WebKit in $productDir.\n&quot;;
2853 
2854     local %ENV = %ENV;
2855     setupMacWebKitEnvironment($productDir);
2856 
2857     if (defined($useOpenCommand) &amp;&amp; $useOpenCommand == USE_OPEN_COMMAND) {
2858         return system(&quot;open&quot;, &quot;-W&quot;, &quot;-a&quot;, $appPath, &quot;--args&quot;, argumentsForRunAndDebugMacWebKitApp());
2859     }
2860     if (architecture()) {
2861         return system &quot;arch&quot;, &quot;-&quot; . architecture(), archCommandLineArgumentsForRestrictedEnvironmentVariables(), $appPath, argumentsForRunAndDebugMacWebKitApp();
2862     }
2863     return system { $appPath } $appPath, argumentsForRunAndDebugMacWebKitApp();
2864 }
2865 
2866 sub execMacWebKitAppForDebugging($)
2867 {
2868     my ($appPath) = @_;
2869     my $architectureSwitch = &quot;--arch&quot;;
2870     my $argumentsSeparator = &quot;--&quot;;
2871 
2872     my $debuggerPath = `xcrun -find lldb`;
2873     chomp $debuggerPath;
2874     die &quot;Can&#39;t find the lldb executable.\n&quot; unless -x $debuggerPath;
2875 
2876     my $productDir = productDir();
2877     setupMacWebKitEnvironment($productDir);
2878 
2879     my @architectureFlags = ($architectureSwitch, architecture());
2880     print &quot;Starting @{[basename($appPath)]} under lldb with DYLD_FRAMEWORK_PATH set to point to built WebKit in $productDir.\n&quot;;
2881     exec { $debuggerPath } $debuggerPath, @architectureFlags, $argumentsSeparator, $appPath, argumentsForRunAndDebugMacWebKitApp() or die;
2882 }
2883 
2884 sub execUnixAppForDebugging($)
2885 {
2886     my ($appPath) = @_;
2887 
2888     my $debuggerPath = `which gdb | head -1`;
2889     chomp $debuggerPath;
2890     die &quot;Can&#39;t find the gdb executable.\n&quot; unless -x $debuggerPath;
2891 
2892     my $productDir = productDir();
2893     setupUnixWebKitEnvironment($productDir);
2894 
2895     my @cmdline = wrapperPrefixIfNeeded();
2896     push @cmdline, $debuggerPath, &quot;--args&quot;, $appPath;
2897 
2898     print &quot;Starting @{[basename($appPath)]} under gdb with build WebKit in $productDir.\n&quot;;
2899     exec @cmdline, @ARGV or die;
2900 }
2901 
2902 sub debugSafari
2903 {
2904     if (isAppleMacWebKit()) {
2905         checkFrameworks();
2906         execMacWebKitAppForDebugging(safariPath());
2907     }
2908 
2909     return 1; # Unsupported platform; can&#39;t debug Safari on this platform.
2910 }
2911 
2912 sub runSafari
2913 {
2914     if (isIOSWebKit()) {
2915         return runIOSWebKitApp(mobileSafariBundle());
2916     }
2917 
2918     if (isAppleMacWebKit()) {
2919         return runMacWebKitApp(safariPath());
2920     }
2921 
2922     if (isAppleWinWebKit()) {
2923         my $result;
2924         my $webKitLauncherPath = File::Spec-&gt;catfile(executableProductDir(), &quot;MiniBrowser.exe&quot;);
2925         return system { $webKitLauncherPath } $webKitLauncherPath, @ARGV;
2926     }
2927 
2928     return 1; # Unsupported platform; can&#39;t run Safari on this platform.
2929 }
2930 
2931 sub runMiniBrowser
2932 {
2933     if (isAppleMacWebKit()) {
2934         return runMacWebKitApp(File::Spec-&gt;catfile(productDir(), &quot;MiniBrowser.app&quot;, &quot;Contents&quot;, &quot;MacOS&quot;, &quot;MiniBrowser&quot;));
2935     }
2936     if (isAppleWinWebKit()) {
2937         my $webKitLauncherPath = File::Spec-&gt;catfile(executableProductDir(), &quot;MiniBrowser.exe&quot;);
2938         return system { $webKitLauncherPath } $webKitLauncherPath, @ARGV;
2939     }
2940     return 1;
2941 }
2942 
2943 sub debugMiniBrowser
2944 {
2945     if (isAppleMacWebKit()) {
2946         execMacWebKitAppForDebugging(File::Spec-&gt;catfile(productDir(), &quot;MiniBrowser.app&quot;, &quot;Contents&quot;, &quot;MacOS&quot;, &quot;MiniBrowser&quot;));
2947     }
2948     
2949     return 1;
2950 }
2951 
2952 sub runWebKitTestRunner
2953 {
2954     if (isAppleMacWebKit()) {
2955         return runMacWebKitApp(File::Spec-&gt;catfile(productDir(), &quot;WebKitTestRunner&quot;));
2956     }
2957 
2958     return 1;
2959 }
2960 
2961 sub debugWebKitTestRunner
2962 {
2963     if (isAppleMacWebKit()) {
2964         execMacWebKitAppForDebugging(File::Spec-&gt;catfile(productDir(), &quot;WebKitTestRunner&quot;));
2965     } elsif (isGtk() or isWPE()) {
2966         execUnixAppForDebugging(File::Spec-&gt;catfile(productDir(), &quot;bin&quot;, &quot;WebKitTestRunner&quot;));
2967     }
2968 
2969     return 1;
2970 }
2971 
2972 sub readRegistryString
2973 {
2974     my ($valueName) = @_;
2975     chomp(my $string = `regtool --wow32 get &quot;$valueName&quot;`);
2976     return $string;
2977 }
2978 
2979 sub writeRegistryString
2980 {
2981     my ($valueName, $string) = @_;
2982 
2983     my $error = system &quot;regtool&quot;, &quot;--wow32&quot;, &quot;set&quot;, &quot;-s&quot;, $valueName, $string;
2984 
2985     # On Windows Vista/7 with UAC enabled, regtool will fail to modify the registry, but will still
2986     # return a successful exit code. So we double-check here that the value we tried to write to the
2987     # registry was really written.
2988     return !$error &amp;&amp; readRegistryString($valueName) eq $string;
2989 }
2990 
2991 sub formatBuildTime($)
2992 {
2993     my ($buildTime) = @_;
2994 
2995     my $buildHours = int($buildTime / 3600);
2996     my $buildMins = int(($buildTime - $buildHours * 3600) / 60);
2997     my $buildSecs = $buildTime - $buildHours * 3600 - $buildMins * 60;
2998 
2999     if ($buildHours) {
3000         return sprintf(&quot;%dh:%02dm:%02ds&quot;, $buildHours, $buildMins, $buildSecs);
3001     }
3002     return sprintf(&quot;%02dm:%02ds&quot;, $buildMins, $buildSecs);
3003 }
3004 
3005 sub runSvnUpdateAndResolveChangeLogs(@)
3006 {
3007     my @svnOptions = @_;
3008     my $openCommand = &quot;svn update &quot; . join(&quot; &quot;, @svnOptions);
3009     open my $update, &quot;$openCommand |&quot; or die &quot;cannot execute command $openCommand&quot;;
3010     my @conflictedChangeLogs;
3011     while (my $line = &lt;$update&gt;) {
3012         print $line;
3013         $line =~ m/^C\s+(.+?)[\r\n]*$/;
3014         if ($1) {
3015           my $filename = normalizePath($1);
3016           push @conflictedChangeLogs, $filename if basename($filename) eq &quot;ChangeLog&quot;;
3017         }
3018     }
3019     close $update or die;
3020 
3021     if (@conflictedChangeLogs) {
3022         print &quot;Attempting to merge conflicted ChangeLogs.\n&quot;;
3023         my $resolveChangeLogsPath = File::Spec-&gt;catfile(sourceDir(), &quot;Tools&quot;, &quot;Scripts&quot;, &quot;resolve-ChangeLogs&quot;);
3024         (system($resolveChangeLogsPath, &quot;--no-warnings&quot;, @conflictedChangeLogs) == 0)
3025             or die &quot;Could not open resolve-ChangeLogs script: $!.\n&quot;;
3026     }
3027 }
3028 
3029 sub runGitUpdate()
3030 {
3031     # Doing a git fetch first allows setups with svn-remote.svn.fetch = trunk:refs/remotes/origin/master
3032     # to perform the rebase much much faster.
3033     system(&quot;git&quot;, &quot;fetch&quot;);
3034     if (isGitSVNDirectory(&quot;.&quot;)) {
3035         system(&quot;git&quot;, &quot;svn&quot;, &quot;rebase&quot;) == 0 or die;
3036     } else {
3037         # This will die if branch.$BRANCHNAME.merge isn&#39;t set, which is
3038         # almost certainly what we want.
3039         system(&quot;git&quot;, &quot;pull&quot;) == 0 or die;
3040     }
3041 }
3042 
3043 1;
    </pre>
  </body>
</html>