<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/StyleResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  * Copyright (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
   4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
   5  * Copyright (C) 2005-2014 Apple Inc. All rights reserved.
   6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
   7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
   8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
  10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
  11  * Copyright (C) 2012, 2013 Google Inc. All rights reserved.
  12  * Copyright (C) 2014 Igalia S.L.
  13  *
  14  * This library is free software; you can redistribute it and/or
  15  * modify it under the terms of the GNU Library General Public
  16  * License as published by the Free Software Foundation; either
  17  * version 2 of the License, or (at your option) any later version.
  18  *
  19  * This library is distributed in the hope that it will be useful,
  20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  22  * Library General Public License for more details.
  23  *
  24  * You should have received a copy of the GNU Library General Public License
  25  * along with this library; see the file COPYING.LIB.  If not, write to
  26  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  27  * Boston, MA 02110-1301, USA.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;StyleResolver.h&quot;
  32 
  33 #include &quot;CSSCalculationValue.h&quot;
  34 #include &quot;CSSCursorImageValue.h&quot;
  35 #include &quot;CSSCustomPropertyValue.h&quot;
  36 #include &quot;CSSDefaultStyleSheets.h&quot;
  37 #include &quot;CSSFilterImageValue.h&quot;
  38 #include &quot;CSSFontSelector.h&quot;
  39 #include &quot;CSSFunctionValue.h&quot;
  40 #include &quot;CSSGradientValue.h&quot;
  41 #include &quot;CSSImageSetValue.h&quot;
  42 #include &quot;CSSImageValue.h&quot;
  43 #include &quot;CSSKeyframeRule.h&quot;
  44 #include &quot;CSSKeyframesRule.h&quot;
  45 #include &quot;CSSPaintImageValue.h&quot;
  46 #include &quot;CSSParser.h&quot;
  47 #include &quot;CSSPrimitiveValueMappings.h&quot;
  48 #include &quot;CSSPropertyNames.h&quot;
  49 #include &quot;CSSReflectValue.h&quot;
  50 #include &quot;CSSSelector.h&quot;
  51 #include &quot;CSSShadowValue.h&quot;
  52 #include &quot;CSSStyleRule.h&quot;
  53 #include &quot;CSSStyleSheet.h&quot;
  54 #include &quot;CSSValueList.h&quot;
  55 #include &quot;CSSValuePool.h&quot;
  56 #include &quot;CachedResourceLoader.h&quot;
  57 #include &quot;ElementRuleCollector.h&quot;
  58 #include &quot;FilterOperation.h&quot;
  59 #include &quot;Frame.h&quot;
  60 #include &quot;FrameSelection.h&quot;
  61 #include &quot;FrameView.h&quot;
  62 #include &quot;HTMLInputElement.h&quot;
  63 #include &quot;HTMLMarqueeElement.h&quot;
  64 #include &quot;HTMLNames.h&quot;
  65 #include &quot;HTMLSlotElement.h&quot;
  66 #include &quot;HTMLTableElement.h&quot;
  67 #include &quot;HTMLTextAreaElement.h&quot;
  68 #include &quot;InspectorInstrumentation.h&quot;
  69 #include &quot;KeyframeList.h&quot;
  70 #include &quot;Logging.h&quot;
  71 #include &quot;MathMLElement.h&quot;
  72 #include &quot;MathMLNames.h&quot;
  73 #include &quot;MediaList.h&quot;
  74 #include &quot;MediaQueryEvaluator.h&quot;
  75 #include &quot;NodeRenderStyle.h&quot;
  76 #include &quot;PageRuleCollector.h&quot;
  77 #include &quot;PaintWorkletGlobalScope.h&quot;
  78 #include &quot;Pair.h&quot;
  79 #include &quot;Quirks.h&quot;
  80 #include &quot;RenderScrollbar.h&quot;
  81 #include &quot;RenderStyleConstants.h&quot;
  82 #include &quot;RenderTheme.h&quot;
  83 #include &quot;RenderView.h&quot;
  84 #include &quot;RuleSet.h&quot;
  85 #include &quot;RuntimeEnabledFeatures.h&quot;
  86 #include &quot;SVGDocument.h&quot;
  87 #include &quot;SVGDocumentExtensions.h&quot;
  88 #include &quot;SVGFontFaceElement.h&quot;
  89 #include &quot;SVGNames.h&quot;
  90 #include &quot;SVGSVGElement.h&quot;
  91 #include &quot;SVGURIReference.h&quot;
  92 #include &quot;Settings.h&quot;
  93 #include &quot;ShadowRoot.h&quot;
  94 #include &quot;SharedStringHash.h&quot;
  95 #include &quot;StyleBuilder.h&quot;
  96 #include &quot;StyleColor.h&quot;
  97 #include &quot;StyleCachedImage.h&quot;
  98 #include &quot;StyleFontSizeFunctions.h&quot;
  99 #include &quot;StyleGeneratedImage.h&quot;
 100 #include &quot;StyleProperties.h&quot;
 101 #include &quot;StylePropertyShorthand.h&quot;
 102 #include &quot;StyleRule.h&quot;
 103 #include &quot;StyleSheetContents.h&quot;
 104 #include &quot;TransformFunctions.h&quot;
 105 #include &quot;TransformOperations.h&quot;
 106 #include &quot;UserAgentStyleSheets.h&quot;
 107 #include &quot;ViewportStyleResolver.h&quot;
 108 #include &quot;VisitedLinkState.h&quot;
 109 #include &quot;WebKitFontFamilyNames.h&quot;
 110 #include &lt;bitset&gt;
 111 #include &lt;wtf/Seconds.h&gt;
 112 #include &lt;wtf/StdLibExtras.h&gt;
 113 #include &lt;wtf/Vector.h&gt;
 114 #include &lt;wtf/text/AtomStringHash.h&gt;
 115 
 116 namespace WebCore {
 117 
 118 using namespace HTMLNames;
 119 
 120 static const CSSPropertyID firstLowPriorityProperty = static_cast&lt;CSSPropertyID&gt;(lastHighPriorityProperty + 1);
 121 
 122 static void extractDirectionAndWritingMode(const RenderStyle&amp;, const StyleResolver::MatchResult&amp;, TextDirection&amp;, WritingMode&amp;);
 123 
 124 inline void StyleResolver::State::cacheBorderAndBackground()
 125 {
 126     m_hasUAAppearance = m_style-&gt;hasAppearance();
 127     if (m_hasUAAppearance) {
 128         m_borderData = m_style-&gt;border();
 129         m_backgroundData = m_style-&gt;backgroundLayers();
 130         m_backgroundColor = m_style-&gt;backgroundColor();
 131     }
 132 }
 133 
 134 inline void StyleResolver::State::clear()
 135 {
 136     m_element = nullptr;
 137     m_parentStyle = nullptr;
 138     m_ownedParentStyle = nullptr;
 139     m_cssToLengthConversionData = CSSToLengthConversionData();
 140 }
 141 
 142 void StyleResolver::MatchResult::addMatchedProperties(const StyleProperties&amp; properties, StyleRule* rule, unsigned linkMatchType, PropertyWhitelistType propertyWhitelistType, Style::ScopeOrdinal styleScopeOrdinal)
 143 {
 144     m_matchedProperties.grow(m_matchedProperties.size() + 1);
 145     StyleResolver::MatchedProperties&amp; newProperties = m_matchedProperties.last();
 146     newProperties.properties = const_cast&lt;StyleProperties*&gt;(&amp;properties);
 147     newProperties.linkMatchType = linkMatchType;
 148     newProperties.whitelistType = propertyWhitelistType;
 149     newProperties.styleScopeOrdinal = styleScopeOrdinal;
 150     matchedRules.append(rule);
 151 
 152     if (styleScopeOrdinal != Style::ScopeOrdinal::Element)
 153         isCacheable = false;
 154 
 155     if (isCacheable) {
 156         for (unsigned i = 0, count = properties.propertyCount(); i &lt; count; ++i) {
 157             // Currently the property cache only copy the non-inherited values and resolve
 158             // the inherited ones.
 159             // Here we define some exception were we have to resolve some properties that are not inherited
 160             // by default. If those exceptions become too common on the web, it should be possible
 161             // to build a list of exception to resolve instead of completely disabling the cache.
 162 
 163             StyleProperties::PropertyReference current = properties.propertyAt(i);
 164             if (!current.isInherited()) {
 165                 // If the property value is explicitly inherited, we need to apply further non-inherited properties
 166                 // as they might override the value inherited here. For this reason we don&#39;t allow declarations with
 167                 // explicitly inherited properties to be cached.
 168                 const CSSValue&amp; value = *current.value();
 169                 if (value.isInheritedValue()) {
 170                     isCacheable = false;
 171                     break;
 172                 }
 173 
 174                 // The value currentColor has implicitely the same side effect. It depends on the value of color,
 175                 // which is an inherited value, making the non-inherited property implicitly inherited.
 176                 if (is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueCurrentcolor) {
 177                     isCacheable = false;
 178                     break;
 179                 }
 180 
 181                 if (value.hasVariableReferences()) {
 182                     isCacheable = false;
 183                     break;
 184                 }
 185             }
 186         }
 187     }
 188 }
 189 
 190 StyleResolver::StyleResolver(Document&amp; document)
 191     : m_ruleSets(*this)
 192     , m_matchedPropertiesCacheSweepTimer(*this, &amp;StyleResolver::sweepMatchedPropertiesCache)
 193     , m_document(document)
 194 #if ENABLE(CSS_DEVICE_ADAPTATION)
 195     , m_viewportStyleResolver(ViewportStyleResolver::create(&amp;document))
 196 #endif
 197     , m_styleMap(this)
 198     , m_matchAuthorAndUserStyles(m_document.settings().authorAndUserStylesEnabled())
 199 {
 200     Element* root = m_document.documentElement();
 201 
 202     CSSDefaultStyleSheets::initDefaultStyle(root);
 203 
 204     // construct document root element default style. this is needed
 205     // to evaluate media queries that contain relative constraints, like &quot;screen and (max-width: 10em)&quot;
 206     // This is here instead of constructor, because when constructor is run,
 207     // document doesn&#39;t have documentElement
 208     // NOTE: this assumes that element that gets passed to styleForElement -call
 209     // is always from the document that owns the style selector
 210     FrameView* view = m_document.view();
 211     if (view)
 212         m_mediaQueryEvaluator = MediaQueryEvaluator { view-&gt;mediaType() };
 213     else
 214         m_mediaQueryEvaluator = MediaQueryEvaluator { &quot;all&quot; };
 215 
 216     if (root) {
 217         m_rootDefaultStyle = styleForElement(*root, m_document.renderStyle(), nullptr, RuleMatchingBehavior::MatchOnlyUserAgentRules).renderStyle;
 218         // Turn off assertion against font lookups during style resolver initialization. We may need root style font for media queries.
 219         m_document.fontSelector().incrementIsComputingRootStyleFont();
 220         m_rootDefaultStyle-&gt;fontCascade().update(&amp;m_document.fontSelector());
 221         m_rootDefaultStyle-&gt;fontCascade().primaryFont();
 222         m_document.fontSelector().decrementIsComputingRootStyleFont();
 223     }
 224 
 225     if (m_rootDefaultStyle &amp;&amp; view)
 226         m_mediaQueryEvaluator = MediaQueryEvaluator { view-&gt;mediaType(), m_document, m_rootDefaultStyle.get() };
 227 
 228     m_ruleSets.resetAuthorStyle();
 229     m_ruleSets.resetUserAgentMediaQueryStyle();
 230 }
 231 
 232 void StyleResolver::addCurrentSVGFontFaceRules()
 233 {
 234 #if ENABLE(SVG_FONTS)
 235     if (m_document.svgExtensions()) {
 236         const HashSet&lt;SVGFontFaceElement*&gt;&amp; svgFontFaceElements = m_document.svgExtensions()-&gt;svgFontFaceElements();
 237         for (auto* svgFontFaceElement : svgFontFaceElements)
 238             m_document.fontSelector().addFontFaceRule(svgFontFaceElement-&gt;fontFaceRule(), svgFontFaceElement-&gt;isInUserAgentShadowTree());
 239     }
 240 #endif
 241 }
 242 
 243 void StyleResolver::appendAuthorStyleSheets(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; styleSheets)
 244 {
 245     m_ruleSets.appendAuthorStyleSheets(styleSheets, &amp;m_mediaQueryEvaluator, m_inspectorCSSOMWrappers, this);
 246 
 247     if (auto renderView = document().renderView())
 248         renderView-&gt;style().fontCascade().update(&amp;document().fontSelector());
 249 
 250 #if ENABLE(CSS_DEVICE_ADAPTATION)
 251     viewportStyleResolver()-&gt;resolve();
 252 #endif
 253 }
 254 
 255 // This is a simplified style setting function for keyframe styles
 256 void StyleResolver::addKeyframeStyle(Ref&lt;StyleRuleKeyframes&gt;&amp;&amp; rule)
 257 {
 258     AtomString s(rule-&gt;name());
 259     m_keyframesRuleMap.set(s.impl(), WTFMove(rule));
 260 }
 261 
 262 StyleResolver::~StyleResolver()
 263 {
 264     RELEASE_ASSERT(!m_document.isResolvingTreeStyle());
 265     RELEASE_ASSERT(!m_isDeleted);
 266     m_isDeleted = true;
 267 
 268 #if ENABLE(CSS_DEVICE_ADAPTATION)
 269     m_viewportStyleResolver-&gt;clearDocument();
 270 #endif
 271 }
 272 
 273 void StyleResolver::sweepMatchedPropertiesCache()
 274 {
 275     // Look for cache entries containing a style declaration with a single ref and remove them.
 276     // This may happen when an element attribute mutation causes it to generate a new inlineStyle()
 277     // or presentationAttributeStyle(), potentially leaving this cache with the last ref on the old one.
 278     Vector&lt;unsigned, 16&gt; toRemove;
 279     MatchedPropertiesCache::iterator it = m_matchedPropertiesCache.begin();
 280     MatchedPropertiesCache::iterator end = m_matchedPropertiesCache.end();
 281     for (; it != end; ++it) {
 282         Vector&lt;MatchedProperties&gt;&amp; matchedProperties = it-&gt;value.matchedProperties;
 283         for (size_t i = 0; i &lt; matchedProperties.size(); ++i) {
 284             if (matchedProperties[i].properties-&gt;hasOneRef()) {
 285                 toRemove.append(it-&gt;key);
 286                 break;
 287             }
 288         }
 289     }
 290     for (size_t i = 0; i &lt; toRemove.size(); ++i)
 291         m_matchedPropertiesCache.remove(toRemove[i]);
 292 
 293     m_matchedPropertiesCacheAdditionsSinceLastSweep = 0;
 294 }
 295 
 296 StyleResolver::State::State(const Element&amp; element, const RenderStyle* parentStyle, const RenderStyle* documentElementStyle, const SelectorFilter* selectorFilter)
 297     : m_element(&amp;element)
 298     , m_parentStyle(parentStyle)
 299     , m_selectorFilter(selectorFilter)
 300     , m_elementLinkState(element.document().visitedLinkState().determineLinkState(element))
 301 {
 302     bool resetStyleInheritance = hasShadowRootParent(element) &amp;&amp; downcast&lt;ShadowRoot&gt;(element.parentNode())-&gt;resetStyleInheritance();
 303     if (resetStyleInheritance)
 304         m_parentStyle = nullptr;
 305 
 306     auto&amp; document = element.document();
 307     auto* documentElement = document.documentElement();
 308     if (!documentElement || documentElement == &amp;element)
 309         m_rootElementStyle = document.renderStyle();
 310     else
 311         m_rootElementStyle = documentElementStyle ? documentElementStyle : documentElement-&gt;renderStyle();
 312 
 313     updateConversionData();
 314 }
 315 
 316 inline void StyleResolver::State::updateConversionData()
 317 {
 318     m_cssToLengthConversionData = CSSToLengthConversionData(m_style.get(), m_rootElementStyle, m_element ? m_element-&gt;document().renderView() : nullptr);
 319 }
 320 
 321 inline void StyleResolver::State::setStyle(std::unique_ptr&lt;RenderStyle&gt; style)
 322 {
 323     m_style = WTFMove(style);
 324     updateConversionData();
 325 }
 326 
 327 inline void StyleResolver::State::setParentStyle(std::unique_ptr&lt;RenderStyle&gt; parentStyle)
 328 {
 329     m_ownedParentStyle = WTFMove(parentStyle);
 330     m_parentStyle = m_ownedParentStyle.get();
 331 }
 332 
 333 static inline bool isAtShadowBoundary(const Element&amp; element)
 334 {
 335     auto* parentNode = element.parentNode();
 336     return parentNode &amp;&amp; parentNode-&gt;isShadowRoot();
 337 }
 338 
 339 void StyleResolver::setNewStateWithElement(const Element&amp; element)
 340 {
 341     // Apply the declaration to the style. This is a simplified version of the logic in styleForElement.
 342     m_state = State(element, nullptr);
 343 }
 344 
 345 ElementStyle StyleResolver::styleForElement(const Element&amp; element, const RenderStyle* parentStyle, const RenderStyle* parentBoxStyle, RuleMatchingBehavior matchingBehavior, const SelectorFilter* selectorFilter)
 346 {
 347     RELEASE_ASSERT(!m_isDeleted);
 348 
 349     m_state = State(element, parentStyle, m_overrideDocumentElementStyle, selectorFilter);
 350     State&amp; state = m_state;
 351 
 352     if (state.parentStyle()) {
 353         state.setStyle(RenderStyle::createPtr());
 354         state.style()-&gt;inheritFrom(*state.parentStyle());
 355     } else {
 356         state.setStyle(defaultStyleForElement());
 357         state.setParentStyle(RenderStyle::clonePtr(*state.style()));
 358     }
 359 
 360     auto&amp; style = *state.style();
 361 
 362     if (element.isLink()) {
 363         style.setIsLink(true);
 364         InsideLink linkState = state.elementLinkState();
 365         if (linkState != InsideLink::NotInside) {
 366             bool forceVisited = InspectorInstrumentation::forcePseudoState(element, CSSSelector::PseudoClassVisited);
 367             if (forceVisited)
 368                 linkState = InsideLink::InsideVisited;
 369         }
 370         style.setInsideLink(linkState);
 371     }
 372 
 373     CSSDefaultStyleSheets::ensureDefaultStyleSheetsForElement(element);
 374 
 375     ElementRuleCollector collector(element, m_ruleSets, m_state.selectorFilter());
 376     collector.setMedium(&amp;m_mediaQueryEvaluator);
 377 
 378     if (matchingBehavior == RuleMatchingBehavior::MatchOnlyUserAgentRules)
 379         collector.matchUARules();
 380     else
 381         collector.matchAllRules(m_matchAuthorAndUserStyles, matchingBehavior != RuleMatchingBehavior::MatchAllRulesExcludingSMIL);
 382 
 383     if (collector.matchedPseudoElementIds())
 384         style.setHasPseudoStyles(collector.matchedPseudoElementIds());
 385 
 386     // This is required for style sharing.
 387     if (collector.didMatchUncommonAttributeSelector())
 388         style.setUnique();
 389 
 390     auto elementStyleRelations = Style::commitRelationsToRenderStyle(style, element, collector.styleRelations());
 391 
 392     applyMatchedProperties(collector.matchedResult(), element);
 393 
 394     // Clean up our style object&#39;s display and text decorations (among other fixups).
 395     adjustRenderStyle(*state.style(), *state.parentStyle(), parentBoxStyle, &amp;element);
 396 
 397     if (state.style()-&gt;hasViewportUnits())
 398         document().setHasStyleWithViewportUnits();
 399 
 400     state.clear(); // Clear out for the next resolve.
 401 
 402     return { state.takeStyle(), WTFMove(elementStyleRelations) };
 403 }
 404 
 405 std::unique_ptr&lt;RenderStyle&gt; StyleResolver::styleForKeyframe(const RenderStyle* elementStyle, const StyleRuleKeyframe* keyframe, KeyframeValue&amp; keyframeValue)
 406 {
 407     RELEASE_ASSERT(!m_isDeleted);
 408 
 409     MatchResult result;
 410     result.addMatchedProperties(keyframe-&gt;properties());
 411 
 412     ASSERT(!m_state.style());
 413 
 414     State&amp; state = m_state;
 415 
 416     // Create the style
 417     state.setStyle(RenderStyle::clonePtr(*elementStyle));
 418     state.setParentStyle(RenderStyle::clonePtr(*elementStyle));
 419 
 420     TextDirection direction;
 421     WritingMode writingMode;
 422     extractDirectionAndWritingMode(*state.style(), result, direction, writingMode);
 423 
 424     // We don&#39;t need to bother with !important. Since there is only ever one
 425     // decl, there&#39;s nothing to override. So just add the first properties.
 426     CascadedProperties cascade(direction, writingMode);
 427     cascade.addNormalMatches(result, 0, result.matchedProperties().size() - 1);
 428 
 429     ApplyCascadedPropertyState applyState { this, &amp;cascade, &amp;result };
 430     applyCascadedProperties(firstCSSProperty, lastHighPriorityProperty, applyState);
 431 
 432     // If our font got dirtied, update it now.
 433     updateFont();
 434 
 435     // Now resolve remaining custom properties and the rest, in any order
 436     for (auto it = cascade.customProperties().begin(); it != cascade.customProperties().end(); ++it)
 437         applyCascadedCustomProperty(it-&gt;key, applyState);
 438     applyCascadedProperties(firstLowPriorityProperty, lastCSSProperty, applyState);
 439 
 440     // If our font got dirtied by one of the non-essential font props, update it a second time.
 441     updateFont();
 442 
 443     cascade.applyDeferredProperties(*this, applyState);
 444 
 445     adjustRenderStyle(*state.style(), *state.parentStyle(), nullptr, nullptr);
 446 
 447     // Add all the animating properties to the keyframe.
 448     unsigned propertyCount = keyframe-&gt;properties().propertyCount();
 449     for (unsigned i = 0; i &lt; propertyCount; ++i) {
 450         CSSPropertyID property = keyframe-&gt;properties().propertyAt(i).id();
 451         // Timing-function within keyframes is special, because it is not animated; it just
 452         // describes the timing function between this keyframe and the next.
 453         if (property != CSSPropertyAnimationTimingFunction)
 454             keyframeValue.addProperty(property);
 455     }
 456 
 457     return state.takeStyle();
 458 }
 459 
 460 bool StyleResolver::isAnimationNameValid(const String&amp; name)
 461 {
 462     return m_keyframesRuleMap.find(AtomString(name).impl()) != m_keyframesRuleMap.end();
 463 }
 464 
 465 void StyleResolver::keyframeStylesForAnimation(const Element&amp; element, const RenderStyle* elementStyle, KeyframeList&amp; list)
 466 {
 467     list.clear();
 468 
 469     // Get the keyframesRule for this name.
 470     if (list.animationName().isEmpty())
 471         return;
 472 
 473     m_keyframesRuleMap.checkConsistency();
 474 
 475     KeyframesRuleMap::iterator it = m_keyframesRuleMap.find(list.animationName().impl());
 476     if (it == m_keyframesRuleMap.end())
 477         return;
 478 
 479     const StyleRuleKeyframes* keyframesRule = it-&gt;value.get();
 480 
 481     auto* keyframes = &amp;keyframesRule-&gt;keyframes();
 482     Vector&lt;Ref&lt;StyleRuleKeyframe&gt;&gt; newKeyframesIfNecessary;
 483 
 484     bool hasDuplicateKeys = false;
 485     HashSet&lt;double&gt; keyframeKeys;
 486     for (auto&amp; keyframe : *keyframes) {
 487         for (auto key : keyframe-&gt;keys()) {
 488             if (!keyframeKeys.add(key)) {
 489                 hasDuplicateKeys = true;
 490                 break;
 491             }
 492         }
 493         if (hasDuplicateKeys)
 494             break;
 495     }
 496 
 497     // FIXME: If HashMaps could have Ref&lt;&gt; as value types, we wouldn&#39;t need
 498     // to copy the HashMap into a Vector.
 499     if (hasDuplicateKeys) {
 500         // Merge duplicate key times.
 501         HashMap&lt;double, RefPtr&lt;StyleRuleKeyframe&gt;&gt; keyframesMap;
 502 
 503         for (auto&amp; originalKeyframe : keyframesRule-&gt;keyframes()) {
 504             for (auto key : originalKeyframe-&gt;keys()) {
 505                 if (auto keyframe = keyframesMap.get(key))
 506                     keyframe-&gt;mutableProperties().mergeAndOverrideOnConflict(originalKeyframe-&gt;properties());
 507                 else {
 508                     auto StyleRuleKeyframe = StyleRuleKeyframe::create(MutableStyleProperties::create());
 509                     StyleRuleKeyframe.ptr()-&gt;setKey(key);
 510                     StyleRuleKeyframe.ptr()-&gt;mutableProperties().mergeAndOverrideOnConflict(originalKeyframe-&gt;properties());
 511                     keyframesMap.set(key, StyleRuleKeyframe.ptr());
 512                 }
 513             }
 514         }
 515 
 516         for (auto&amp; keyframe : keyframesMap.values())
 517             newKeyframesIfNecessary.append(*keyframe.get());
 518 
 519         keyframes = &amp;newKeyframesIfNecessary;
 520     }
 521 
 522     // Construct and populate the style for each keyframe.
 523     for (auto&amp; keyframe : *keyframes) {
 524         setNewStateWithElement(element);
 525 
 526         // Add this keyframe style to all the indicated key times
 527         for (auto key : keyframe-&gt;keys()) {
 528             KeyframeValue keyframeValue(0, nullptr);
 529             keyframeValue.setStyle(styleForKeyframe(elementStyle, keyframe.ptr(), keyframeValue));
 530             keyframeValue.setKey(key);
 531             if (auto timingFunctionCSSValue = keyframe-&gt;properties().getPropertyCSSValue(CSSPropertyAnimationTimingFunction))
 532                 keyframeValue.setTimingFunction(TimingFunction::createFromCSSValue(*timingFunctionCSSValue.get()));
 533             list.insert(WTFMove(keyframeValue));
 534         }
 535     }
 536 
 537     // If the 0% keyframe is missing, create it (but only if there is at least one other keyframe).
 538     int initialListSize = list.size();
 539     if (initialListSize &gt; 0 &amp;&amp; list[0].key()) {
 540         static StyleRuleKeyframe* zeroPercentKeyframe;
 541         if (!zeroPercentKeyframe) {
 542             zeroPercentKeyframe = &amp;StyleRuleKeyframe::create(MutableStyleProperties::create()).leakRef();
 543             zeroPercentKeyframe-&gt;setKey(0);
 544         }
 545         KeyframeValue keyframeValue(0, nullptr);
 546         keyframeValue.setStyle(styleForKeyframe(elementStyle, zeroPercentKeyframe, keyframeValue));
 547         list.insert(WTFMove(keyframeValue));
 548     }
 549 
 550     // If the 100% keyframe is missing, create it (but only if there is at least one other keyframe).
 551     if (initialListSize &gt; 0 &amp;&amp; (list[list.size() - 1].key() != 1)) {
 552         static StyleRuleKeyframe* hundredPercentKeyframe;
 553         if (!hundredPercentKeyframe) {
 554             hundredPercentKeyframe = &amp;StyleRuleKeyframe::create(MutableStyleProperties::create()).leakRef();
 555             hundredPercentKeyframe-&gt;setKey(1);
 556         }
 557         KeyframeValue keyframeValue(1, nullptr);
 558         keyframeValue.setStyle(styleForKeyframe(elementStyle, hundredPercentKeyframe, keyframeValue));
 559         list.insert(WTFMove(keyframeValue));
 560     }
 561 }
 562 
 563 std::unique_ptr&lt;RenderStyle&gt; StyleResolver::pseudoStyleForElement(const Element&amp; element, const PseudoStyleRequest&amp; pseudoStyleRequest, const RenderStyle&amp; parentStyle, const SelectorFilter* selectorFilter)
 564 {
 565     m_state = State(element, &amp;parentStyle, m_overrideDocumentElementStyle, selectorFilter);
 566 
 567     State&amp; state = m_state;
 568 
 569     if (m_state.parentStyle()) {
 570         state.setStyle(RenderStyle::createPtr());
 571         state.style()-&gt;inheritFrom(*m_state.parentStyle());
 572     } else {
 573         state.setStyle(defaultStyleForElement());
 574         state.setParentStyle(RenderStyle::clonePtr(*state.style()));
 575     }
 576 
 577     // Since we don&#39;t use pseudo-elements in any of our quirk/print user agent rules, don&#39;t waste time walking
 578     // those rules.
 579 
 580     // Check UA, user and author rules.
 581     ElementRuleCollector collector(element, m_ruleSets, m_state.selectorFilter());
 582     collector.setPseudoStyleRequest(pseudoStyleRequest);
 583     collector.setMedium(&amp;m_mediaQueryEvaluator);
 584     collector.matchUARules();
 585 
 586     if (m_matchAuthorAndUserStyles) {
 587         collector.matchUserRules(false);
 588         collector.matchAuthorRules(false);
 589     }
 590 
 591     ASSERT(!collector.matchedPseudoElementIds());
 592 
 593     if (collector.matchedResult().matchedProperties().isEmpty())
 594         return nullptr;
 595 
 596     state.style()-&gt;setStyleType(pseudoStyleRequest.pseudoId);
 597 
 598     applyMatchedProperties(collector.matchedResult(), element);
 599 
 600     // Clean up our style object&#39;s display and text decorations (among other fixups).
 601     adjustRenderStyle(*state.style(), *m_state.parentStyle(), nullptr, nullptr);
 602 
 603     if (state.style()-&gt;hasViewportUnits())
 604         document().setHasStyleWithViewportUnits();
 605 
 606     // Now return the style.
 607     return state.takeStyle();
 608 }
 609 
 610 std::unique_ptr&lt;RenderStyle&gt; StyleResolver::styleForPage(int pageIndex)
 611 {
 612     RELEASE_ASSERT(!m_isDeleted);
 613 
 614     auto* documentElement = m_document.documentElement();
 615     if (!documentElement)
 616         return RenderStyle::createPtr();
 617 
 618     m_state = State(*documentElement, m_document.renderStyle());
 619 
 620     m_state.setStyle(RenderStyle::createPtr());
 621     m_state.style()-&gt;inheritFrom(*m_state.rootElementStyle());
 622 
 623     PageRuleCollector collector(m_state, m_ruleSets);
 624     collector.matchAllPageRules(pageIndex);
 625 
 626     MatchResult&amp; result = collector.matchedResult();
 627 
 628     TextDirection direction;
 629     WritingMode writingMode;
 630     extractDirectionAndWritingMode(*m_state.style(), result, direction, writingMode);
 631 
 632     CascadedProperties cascade(direction, writingMode);
 633     cascade.addNormalMatches(result, 0, result.matchedProperties().size() - 1);
 634 
 635     ApplyCascadedPropertyState applyState { this, &amp;cascade, &amp;result };
 636     applyCascadedProperties(firstCSSProperty, lastHighPriorityProperty, applyState);
 637 
 638     // If our font got dirtied, update it now.
 639     updateFont();
 640 
 641     // Now resolve remaining custom properties and the rest, in any order
 642     for (auto it = cascade.customProperties().begin(); it != cascade.customProperties().end(); ++it)
 643         applyCascadedCustomProperty(it-&gt;key, applyState);
 644     applyCascadedProperties(firstLowPriorityProperty, lastCSSProperty, applyState);
 645 
 646     cascade.applyDeferredProperties(*this, applyState);
 647 
 648     // Now return the style.
 649     return m_state.takeStyle();
 650 }
 651 
 652 std::unique_ptr&lt;RenderStyle&gt; StyleResolver::defaultStyleForElement()
 653 {
 654     m_state.setStyle(RenderStyle::createPtr());
 655     // Make sure our fonts are initialized if we don&#39;t inherit them from our parent style.
 656     initializeFontStyle();
 657     m_state.style()-&gt;fontCascade().update(&amp;document().fontSelector());
 658     return m_state.takeStyle();
 659 }
 660 
 661 static void addIntrinsicMargins(RenderStyle&amp; style)
 662 {
 663     // Intrinsic margin value.
 664     const int intrinsicMargin = clampToInteger(2 * style.effectiveZoom());
 665 
 666     // FIXME: Using width/height alone and not also dealing with min-width/max-width is flawed.
 667     // FIXME: Using &quot;hasQuirk&quot; to decide the margin wasn&#39;t set is kind of lame.
 668     if (style.width().isIntrinsicOrAuto()) {
 669         if (style.marginLeft().hasQuirk())
 670             style.setMarginLeft(Length(intrinsicMargin, Fixed));
 671         if (style.marginRight().hasQuirk())
 672             style.setMarginRight(Length(intrinsicMargin, Fixed));
 673     }
 674 
 675     if (style.height().isAuto()) {
 676         if (style.marginTop().hasQuirk())
 677             style.setMarginTop(Length(intrinsicMargin, Fixed));
 678         if (style.marginBottom().hasQuirk())
 679             style.setMarginBottom(Length(intrinsicMargin, Fixed));
 680     }
 681 }
 682 
 683 static DisplayType equivalentBlockDisplay(const RenderStyle&amp; style, const Document&amp; document)
 684 {
 685     switch (auto display = style.display()) {
 686     case DisplayType::Block:
 687     case DisplayType::Table:
 688     case DisplayType::Box:
 689     case DisplayType::Flex:
 690     case DisplayType::WebKitFlex:
 691     case DisplayType::Grid:
 692     case DisplayType::FlowRoot:
 693         return display;
 694 
 695     case DisplayType::ListItem:
 696         // It is a WinIE bug that floated list items lose their bullets, so we&#39;ll emulate the quirk, but only in quirks mode.
 697         if (document.inQuirksMode() &amp;&amp; style.isFloating())
 698             return DisplayType::Block;
 699         return display;
 700     case DisplayType::InlineTable:
 701         return DisplayType::Table;
 702     case DisplayType::InlineBox:
 703         return DisplayType::Box;
 704     case DisplayType::InlineFlex:
 705     case DisplayType::WebKitInlineFlex:
 706         return DisplayType::Flex;
 707     case DisplayType::InlineGrid:
 708         return DisplayType::Grid;
 709 
 710     case DisplayType::Inline:
 711     case DisplayType::Compact:
 712     case DisplayType::InlineBlock:
 713     case DisplayType::TableRowGroup:
 714     case DisplayType::TableHeaderGroup:
 715     case DisplayType::TableFooterGroup:
 716     case DisplayType::TableRow:
 717     case DisplayType::TableColumnGroup:
 718     case DisplayType::TableColumn:
 719     case DisplayType::TableCell:
 720     case DisplayType::TableCaption:
 721         return DisplayType::Block;
 722     case DisplayType::Contents:
 723         ASSERT_NOT_REACHED();
 724         return DisplayType::Contents;
 725     case DisplayType::None:
 726         ASSERT_NOT_REACHED();
 727         return DisplayType::None;
 728     }
 729     ASSERT_NOT_REACHED();
 730     return DisplayType::Block;
 731 }
 732 
 733 // CSS requires text-decoration to be reset at each DOM element for tables,
 734 // inline blocks, inline tables, shadow DOM crossings, floating elements,
 735 // and absolute or relatively positioned elements.
 736 static bool doesNotInheritTextDecoration(const RenderStyle&amp; style, const Element* element)
 737 {
 738     return style.display() == DisplayType::Table || style.display() == DisplayType::InlineTable
 739         || style.display() == DisplayType::InlineBlock || style.display() == DisplayType::InlineBox || (element &amp;&amp; isAtShadowBoundary(*element))
 740         || style.isFloating() || style.hasOutOfFlowPosition();
 741 }
 742 
 743 #if ENABLE(OVERFLOW_SCROLLING_TOUCH) || ENABLE(POINTER_EVENTS)
 744 static bool isScrollableOverflow(Overflow overflow)
 745 {
 746     return overflow == Overflow::Scroll || overflow == Overflow::Auto;
 747 }
 748 #endif
 749 
 750 void StyleResolver::adjustStyleForInterCharacterRuby()
 751 {
 752     RenderStyle* style = m_state.style();
 753     if (style-&gt;rubyPosition() != RubyPosition::InterCharacter || !m_state.element() || !m_state.element()-&gt;hasTagName(rtTag))
 754         return;
 755     style-&gt;setTextAlign(TextAlignMode::Center);
 756     if (style-&gt;isHorizontalWritingMode())
 757         style-&gt;setWritingMode(LeftToRightWritingMode);
 758 }
 759 
 760 static bool hasEffectiveDisplayNoneForDisplayContents(const Element&amp; element)
 761 {
 762     // https://drafts.csswg.org/css-display-3/#unbox-html
 763     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; tagNames = [] {
 764         static const HTMLQualifiedName* const tagList[] = {
 765             &amp;brTag.get(),
 766             &amp;wbrTag.get(),
 767             &amp;meterTag.get(),
 768             &amp;appletTag.get(),
 769             &amp;progressTag.get(),
 770             &amp;canvasTag.get(),
 771             &amp;embedTag.get(),
 772             &amp;objectTag.get(),
 773             &amp;audioTag.get(),
 774             &amp;iframeTag.get(),
 775             &amp;imgTag.get(),
 776             &amp;videoTag.get(),
 777             &amp;frameTag.get(),
 778             &amp;framesetTag.get(),
 779             &amp;inputTag.get(),
 780             &amp;textareaTag.get(),
 781             &amp;selectTag.get(),
 782         };
 783         HashSet&lt;AtomString&gt; set;
 784         for (auto&amp; name : tagList)
 785             set.add(name-&gt;localName());
 786         return set;
 787     }();
 788 
 789     // https://drafts.csswg.org/css-display-3/#unbox-svg
 790     // FIXME: &lt;g&gt;, &lt;use&gt; and &lt;tspan&gt; have special (?) behavior for display:contents in the current draft spec.
 791     if (is&lt;SVGElement&gt;(element))
 792         return true;
 793 #if ENABLE(MATHML)
 794     // Not sure MathML code can handle it.
 795     if (is&lt;MathMLElement&gt;(element))
 796         return true;
 797 #endif // ENABLE(MATHML)
 798     if (!is&lt;HTMLElement&gt;(element))
 799         return false;
 800     return tagNames.get().contains(element.localName());
 801 }
 802 
 803 static void adjustDisplayContentsStyle(RenderStyle&amp; style, const Element* element)
 804 {
 805     bool displayContentsEnabled = is&lt;HTMLSlotElement&gt;(element) || RuntimeEnabledFeatures::sharedFeatures().displayContentsEnabled();
 806     if (!displayContentsEnabled) {
 807         style.setDisplay(DisplayType::Inline);
 808         return;
 809     }
 810     if (!element) {
 811         if (style.styleType() != PseudoId::Before &amp;&amp; style.styleType() != PseudoId::After)
 812             style.setDisplay(DisplayType::None);
 813         return;
 814     }
 815     if (element-&gt;document().documentElement() == element) {
 816         style.setDisplay(DisplayType::Block);
 817         return;
 818     }
 819     if (hasEffectiveDisplayNoneForDisplayContents(*element))
 820         style.setDisplay(DisplayType::None);
 821 }
 822 
 823 void StyleResolver::adjustSVGElementStyle(const SVGElement&amp; svgElement, RenderStyle&amp; style)
 824 {
 825     // Only the root &lt;svg&gt; element in an SVG document fragment tree honors css position
 826     auto isPositioningAllowed = svgElement.hasTagName(SVGNames::svgTag) &amp;&amp; svgElement.parentNode() &amp;&amp; !svgElement.parentNode()-&gt;isSVGElement() &amp;&amp; !svgElement.correspondingElement();
 827     if (!isPositioningAllowed)
 828         style.setPosition(RenderStyle::initialPosition());
 829 
 830     // RenderSVGRoot handles zooming for the whole SVG subtree, so foreignObject content should
 831     // not be scaled again.
 832     if (svgElement.hasTagName(SVGNames::foreignObjectTag))
 833         style.setEffectiveZoom(RenderStyle::initialZoom());
 834 
 835     // SVG text layout code expects us to be a block-level style element.
 836     if ((svgElement.hasTagName(SVGNames::foreignObjectTag) || svgElement.hasTagName(SVGNames::textTag)) &amp;&amp; style.isDisplayInlineType())
 837         style.setDisplay(DisplayType::Block);
 838 }
 839 
 840 #if ENABLE(POINTER_EVENTS)
 841 static OptionSet&lt;TouchAction&gt; computeEffectiveTouchActions(const RenderStyle&amp; style, OptionSet&lt;TouchAction&gt; effectiveTouchActions)
 842 {
 843     // https://w3c.github.io/pointerevents/#determining-supported-touch-behavior
 844     // &quot;A touch behavior is supported if it conforms to the touch-action property of each element between
 845     // the hit tested element and its nearest ancestor with the default touch behavior (including both the
 846     // hit tested element and the element with the default touch behavior).&quot;
 847 
 848     bool hasDefaultTouchBehavior = isScrollableOverflow(style.overflowX()) || isScrollableOverflow(style.overflowY());
 849     if (hasDefaultTouchBehavior)
 850         effectiveTouchActions = RenderStyle::initialTouchActions();
 851 
 852     auto touchActions = style.touchActions();
 853     if (touchActions == RenderStyle::initialTouchActions())
 854         return effectiveTouchActions;
 855 
 856     if (effectiveTouchActions.contains(TouchAction::None))
 857         return { TouchAction::None };
 858 
 859     if (effectiveTouchActions.containsAny({ TouchAction::Auto, TouchAction::Manipulation }))
 860         return touchActions;
 861 
 862     if (touchActions.containsAny({ TouchAction::Auto, TouchAction::Manipulation }))
 863         return effectiveTouchActions;
 864 
 865     auto sharedTouchActions = effectiveTouchActions &amp; touchActions;
 866     if (sharedTouchActions.isEmpty())
 867         return { TouchAction::None };
 868 
 869     return sharedTouchActions;
 870 }
 871 #endif
 872 
 873 #if ENABLE(TEXT_AUTOSIZING)
 874 static bool hasTextChild(const Element&amp; element)
 875 {
 876     for (auto* child = element.firstChild(); child; child = child-&gt;nextSibling()) {
 877         if (is&lt;Text&gt;(child))
 878             return true;
 879     }
 880     return false;
 881 }
 882 
 883 bool StyleResolver::adjustRenderStyleForTextAutosizing(RenderStyle&amp; style, const Element&amp; element)
 884 {
 885     if (!settings().textAutosizingEnabled() || !settings().textAutosizingUsesIdempotentMode())
 886         return false;
 887 
 888     AutosizeStatus::updateStatus(style);
 889     if (style.textSizeAdjust().isNone())
 890         return false;
 891 
 892     float initialScale = document().page() ? document().page()-&gt;initialScale() : 1;
 893     auto adjustLineHeightIfNeeded = [&amp;](auto computedFontSize) {
 894         auto lineHeight = style.specifiedLineHeight();
 895         constexpr static unsigned eligibleFontSize = 12;
 896         if (computedFontSize * initialScale &gt;= eligibleFontSize)
 897             return;
 898 
 899         constexpr static float boostFactor = 1.25;
 900         auto minimumLineHeight = boostFactor * computedFontSize;
 901         if (!lineHeight.isFixed() || lineHeight.value() &gt;= minimumLineHeight)
 902             return;
 903 
 904         if (AutosizeStatus::probablyContainsASmallFixedNumberOfLines(style))
 905             return;
 906 
 907         style.setLineHeight({ minimumLineHeight, Fixed });
 908     };
 909 
 910     auto fontDescription = style.fontDescription();
 911     auto initialComputedFontSize = fontDescription.computedSize();
 912     auto specifiedFontSize = fontDescription.specifiedSize();
 913     bool isCandidate = style.isIdempotentTextAutosizingCandidate();
 914     if (!isCandidate &amp;&amp; WTF::areEssentiallyEqual(initialComputedFontSize, specifiedFontSize))
 915         return false;
 916 
 917     auto adjustedFontSize = AutosizeStatus::idempotentTextSize(fontDescription.specifiedSize(), initialScale);
 918     if (isCandidate &amp;&amp; WTF::areEssentiallyEqual(initialComputedFontSize, adjustedFontSize))
 919         return false;
 920 
 921     if (!hasTextChild(element))
 922         return false;
 923 
 924     fontDescription.setComputedSize(isCandidate ? adjustedFontSize : specifiedFontSize);
 925     style.setFontDescription(WTFMove(fontDescription));
 926     style.fontCascade().update(&amp;document().fontSelector());
 927 
 928     // FIXME: We should restore computed line height to its original value in the case where the element is not
 929     // an idempotent text autosizing candidate; otherwise, if an element that is a text autosizing candidate contains
 930     // children which are not autosized, the non-autosized content will end up with a boosted line height.
 931     if (isCandidate)
 932         adjustLineHeightIfNeeded(adjustedFontSize);
 933 
 934     return true;
 935 }
 936 #endif
 937 
 938 void StyleResolver::adjustRenderStyle(RenderStyle&amp; style, const RenderStyle&amp; parentStyle, const RenderStyle* parentBoxStyle, const Element* element)
 939 {
 940     // If the composed tree parent has display:contents, the parent box style will be different from the parent style.
 941     // We don&#39;t have it when resolving computed style for display:none subtree. Use parent style for adjustments in that case.
 942     if (!parentBoxStyle)
 943         parentBoxStyle = &amp;parentStyle;
 944 
 945     // Cache our original display.
 946     style.setOriginalDisplay(style.display());
 947 
 948     if (style.display() == DisplayType::Contents)
 949         adjustDisplayContentsStyle(style, element);
 950 
 951     if (style.display() != DisplayType::None &amp;&amp; style.display() != DisplayType::Contents) {
 952         if (element) {
 953             // If we have a &lt;td&gt; that specifies a float property, in quirks mode we just drop the float
 954             // property.
 955             // Sites also commonly use display:inline/block on &lt;td&gt;s and &lt;table&gt;s. In quirks mode we force
 956             // these tags to retain their display types.
 957             if (document().inQuirksMode()) {
 958                 if (element-&gt;hasTagName(tdTag)) {
 959                     style.setDisplay(DisplayType::TableCell);
 960                     style.setFloating(Float::No);
 961                 } else if (is&lt;HTMLTableElement&gt;(*element))
 962                     style.setDisplay(style.isDisplayInlineType() ? DisplayType::InlineTable : DisplayType::Table);
 963             }
 964 
 965             if (element-&gt;hasTagName(tdTag) || element-&gt;hasTagName(thTag)) {
 966                 if (style.whiteSpace() == WhiteSpace::KHTMLNoWrap) {
 967                     // Figure out if we are really nowrapping or if we should just
 968                     // use normal instead. If the width of the cell is fixed, then
 969                     // we don&#39;t actually use WhiteSpace::NoWrap.
 970                     if (style.width().isFixed())
 971                         style.setWhiteSpace(WhiteSpace::Normal);
 972                     else
 973                         style.setWhiteSpace(WhiteSpace::NoWrap);
 974                 }
 975             }
 976 
 977             // Tables never support the -webkit-* values for text-align and will reset back to the default.
 978             if (is&lt;HTMLTableElement&gt;(*element) &amp;&amp; (style.textAlign() == TextAlignMode::WebKitLeft || style.textAlign() == TextAlignMode::WebKitCenter || style.textAlign() == TextAlignMode::WebKitRight))
 979                 style.setTextAlign(TextAlignMode::Start);
 980 
 981             // Frames and framesets never honor position:relative or position:absolute. This is necessary to
 982             // fix a crash where a site tries to position these objects. They also never honor display.
 983             if (element-&gt;hasTagName(frameTag) || element-&gt;hasTagName(framesetTag)) {
 984                 style.setPosition(PositionType::Static);
 985                 style.setDisplay(DisplayType::Block);
 986             }
 987 
 988             // Ruby text does not support float or position. This might change with evolution of the specification.
 989             if (element-&gt;hasTagName(rtTag)) {
 990                 style.setPosition(PositionType::Static);
 991                 style.setFloating(Float::No);
 992             }
 993 
 994             // User agents are expected to have a rule in their user agent stylesheet that matches th elements that have a parent
 995             // node whose computed value for the &#39;text-align&#39; property is its initial value, whose declaration block consists of
 996             // just a single declaration that sets the &#39;text-align&#39; property to the value &#39;center&#39;.
 997             // https://html.spec.whatwg.org/multipage/rendering.html#rendering
 998             if (element-&gt;hasTagName(thTag) &amp;&amp; !style.hasExplicitlySetTextAlign() &amp;&amp; parentStyle.textAlign() == RenderStyle::initialTextAlign())
 999                 style.setTextAlign(TextAlignMode::Center);
1000 
1001             if (element-&gt;hasTagName(legendTag))
1002                 style.setDisplay(DisplayType::Block);
1003         }
1004 
1005         // Absolute/fixed positioned elements, floating elements and the document element need block-like outside display.
1006         if (style.hasOutOfFlowPosition() || style.isFloating() || (element &amp;&amp; element-&gt;document().documentElement() == element))
1007             style.setDisplay(equivalentBlockDisplay(style, document()));
1008 
1009         // FIXME: Don&#39;t support this mutation for pseudo styles like first-letter or first-line, since it&#39;s not completely
1010         // clear how that should work.
1011         if (style.display() == DisplayType::Inline &amp;&amp; style.styleType() == PseudoId::None &amp;&amp; style.writingMode() != parentStyle.writingMode())
1012             style.setDisplay(DisplayType::InlineBlock);
1013 
1014         // After performing the display mutation, check table rows. We do not honor position:relative or position:sticky on
1015         // table rows or cells. This has been established for position:relative in CSS2.1 (and caused a crash in containingBlock()
1016         // on some sites).
1017         if ((style.display() == DisplayType::TableHeaderGroup || style.display() == DisplayType::TableRowGroup
1018             || style.display() == DisplayType::TableFooterGroup || style.display() == DisplayType::TableRow)
1019             &amp;&amp; style.position() == PositionType::Relative)
1020             style.setPosition(PositionType::Static);
1021 
1022         // writing-mode does not apply to table row groups, table column groups, table rows, and table columns.
1023         // FIXME: Table cells should be allowed to be perpendicular or flipped with respect to the table, though.
1024         if (style.display() == DisplayType::TableColumn || style.display() == DisplayType::TableColumnGroup || style.display() == DisplayType::TableFooterGroup
1025             || style.display() == DisplayType::TableHeaderGroup || style.display() == DisplayType::TableRow || style.display() == DisplayType::TableRowGroup
1026             || style.display() == DisplayType::TableCell)
1027             style.setWritingMode(parentStyle.writingMode());
1028 
1029         // FIXME: Since we don&#39;t support block-flow on flexible boxes yet, disallow setting
1030         // of block-flow to anything other than TopToBottomWritingMode.
1031         // https://bugs.webkit.org/show_bug.cgi?id=46418 - Flexible box support.
1032         if (style.writingMode() != TopToBottomWritingMode &amp;&amp; (style.display() == DisplayType::Box || style.display() == DisplayType::InlineBox))
1033             style.setWritingMode(TopToBottomWritingMode);
1034 
1035         // https://www.w3.org/TR/css-display/#transformations
1036         // &quot;A parent with a grid or flex display value blockifies the box’s display type.&quot;
1037         if (parentBoxStyle-&gt;isDisplayFlexibleOrGridBox()) {
1038             style.setFloating(Float::No);
1039             style.setDisplay(equivalentBlockDisplay(style, document()));
1040         }
1041     }
1042 
1043     // Make sure our z-index value is only applied if the object is positioned.
1044     if (style.position() == PositionType::Static &amp;&amp; !parentBoxStyle-&gt;isDisplayFlexibleOrGridBox())
1045         style.setHasAutoZIndex();
1046 
1047     // Auto z-index becomes 0 for the root element and transparent objects. This prevents
1048     // cases where objects that should be blended as a single unit end up with a non-transparent
1049     // object wedged in between them. Auto z-index also becomes 0 for objects that specify transforms/masks/reflections.
1050     if (style.hasAutoZIndex()) {
1051         if ((element &amp;&amp; element-&gt;document().documentElement() == element)
1052             || style.opacity() &lt; 1.0f
1053             || style.hasTransformRelatedProperty()
1054             || style.hasMask()
1055             || style.clipPath()
1056             || style.boxReflect()
1057             || style.hasFilter()
1058 #if ENABLE(FILTERS_LEVEL_2)
1059             || style.hasBackdropFilter()
1060 #endif
1061             || style.hasBlendMode()
1062             || style.hasIsolation()
1063             || style.position() == PositionType::Sticky
1064             || style.position() == PositionType::Fixed
1065             || style.willChangeCreatesStackingContext())
1066             style.setZIndex(0);
1067     }
1068 
1069     if (element) {
1070         // Textarea considers overflow visible as auto.
1071         if (is&lt;HTMLTextAreaElement&gt;(*element)) {
1072             style.setOverflowX(style.overflowX() == Overflow::Visible ? Overflow::Auto : style.overflowX());
1073             style.setOverflowY(style.overflowY() == Overflow::Visible ? Overflow::Auto : style.overflowY());
1074         }
1075 
1076         // Disallow -webkit-user-modify on :pseudo and ::pseudo elements.
1077         if (!element-&gt;shadowPseudoId().isNull())
1078             style.setUserModify(UserModify::ReadOnly);
1079 
1080         if (is&lt;HTMLMarqueeElement&gt;(*element)) {
1081             // For now, &lt;marquee&gt; requires an overflow clip to work properly.
1082             style.setOverflowX(Overflow::Hidden);
1083             style.setOverflowY(Overflow::Hidden);
1084 
1085             bool isVertical = style.marqueeDirection() == MarqueeDirection::Up || style.marqueeDirection() == MarqueeDirection::Down;
1086             // Make horizontal marquees not wrap.
1087             if (!isVertical) {
1088                 style.setWhiteSpace(WhiteSpace::NoWrap);
1089                 style.setTextAlign(TextAlignMode::Start);
1090             }
1091             // Apparently this is the expected legacy behavior.
1092             if (isVertical &amp;&amp; style.height().isAuto())
1093                 style.setHeight(Length(200, Fixed));
1094         }
1095     }
1096 
1097     if (doesNotInheritTextDecoration(style, element))
1098         style.setTextDecorationsInEffect(style.textDecoration());
1099     else
1100         style.addToTextDecorationsInEffect(style.textDecoration());
1101 
1102     // If either overflow value is not visible, change to auto.
1103     if (style.overflowX() == Overflow::Visible &amp;&amp; style.overflowY() != Overflow::Visible) {
1104         // FIXME: Once we implement pagination controls, overflow-x should default to hidden
1105         // if overflow-y is set to -webkit-paged-x or -webkit-page-y. For now, we&#39;ll let it
1106         // default to auto so we can at least scroll through the pages.
1107         style.setOverflowX(Overflow::Auto);
1108     } else if (style.overflowY() == Overflow::Visible &amp;&amp; style.overflowX() != Overflow::Visible)
1109         style.setOverflowY(Overflow::Auto);
1110 
1111     // Call setStylesForPaginationMode() if a pagination mode is set for any non-root elements. If these
1112     // styles are specified on a root element, then they will be incorporated in
1113     // Style::createForDocument().
1114     if ((style.overflowY() == Overflow::PagedX || style.overflowY() == Overflow::PagedY) &amp;&amp; !(element &amp;&amp; (element-&gt;hasTagName(htmlTag) || element-&gt;hasTagName(bodyTag))))
1115         style.setColumnStylesFromPaginationMode(WebCore::paginationModeForRenderStyle(style));
1116 
1117     // Table rows, sections and the table itself will support overflow:hidden and will ignore scroll/auto.
1118     // FIXME: Eventually table sections will support auto and scroll.
1119     if (style.display() == DisplayType::Table || style.display() == DisplayType::InlineTable
1120         || style.display() == DisplayType::TableRowGroup || style.display() == DisplayType::TableRow) {
1121         if (style.overflowX() != Overflow::Visible &amp;&amp; style.overflowX() != Overflow::Hidden)
1122             style.setOverflowX(Overflow::Visible);
1123         if (style.overflowY() != Overflow::Visible &amp;&amp; style.overflowY() != Overflow::Hidden)
1124             style.setOverflowY(Overflow::Visible);
1125     }
1126 
1127     // Menulists should have visible overflow
1128     if (style.appearance() == MenulistPart) {
1129         style.setOverflowX(Overflow::Visible);
1130         style.setOverflowY(Overflow::Visible);
1131     }
1132 
1133 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
1134     // Touch overflow scrolling creates a stacking context.
1135     if (style.hasAutoZIndex() &amp;&amp; style.useTouchOverflowScrolling() &amp;&amp; (isScrollableOverflow(style.overflowX()) || isScrollableOverflow(style.overflowY())))
1136         style.setZIndex(0);
1137 #endif
1138 
1139     // Cull out any useless layers and also repeat patterns into additional layers.
1140     style.adjustBackgroundLayers();
1141     style.adjustMaskLayers();
1142 
1143     // Do the same for animations and transitions.
1144     style.adjustAnimations();
1145     style.adjustTransitions();
1146 
1147     // Important: Intrinsic margins get added to controls before the theme has adjusted the style, since the theme will
1148     // alter fonts and heights/widths.
1149     if (is&lt;HTMLFormControlElement&gt;(element) &amp;&amp; style.computedFontPixelSize() &gt;= 11) {
1150         // Don&#39;t apply intrinsic margins to image buttons. The designer knows how big the images are,
1151         // so we have to treat all image buttons as though they were explicitly sized.
1152         if (!is&lt;HTMLInputElement&gt;(*element) || !downcast&lt;HTMLInputElement&gt;(*element).isImageButton())
1153             addIntrinsicMargins(style);
1154     }
1155 
1156     // Let the theme also have a crack at adjusting the style.
1157     if (style.hasAppearance())
1158         RenderTheme::singleton().adjustStyle(*this, style, element, m_state.hasUAAppearance(), m_state.borderData(), m_state.backgroundData(), m_state.backgroundColor());
1159 
1160     // If we have first-letter pseudo style, do not share this style.
1161     if (style.hasPseudoStyle(PseudoId::FirstLetter))
1162         style.setUnique();
1163 
1164     // FIXME: when dropping the -webkit prefix on transform-style, we should also have opacity &lt; 1 cause flattening.
1165     if (style.preserves3D() &amp;&amp; (style.overflowX() != Overflow::Visible
1166         || style.overflowY() != Overflow::Visible
1167         || style.hasClip()
1168         || style.clipPath()
1169         || style.hasFilter()
1170 #if ENABLE(FILTERS_LEVEL_2)
1171         || style.hasBackdropFilter()
1172 #endif
1173         || style.hasBlendMode()))
1174         style.setTransformStyle3D(TransformStyle3D::Flat);
1175 
1176     if (is&lt;SVGElement&gt;(element))
1177         adjustSVGElementStyle(downcast&lt;SVGElement&gt;(*element), style);
1178 
1179     // If the inherited value of justify-items includes the &#39;legacy&#39; keyword (plus &#39;left&#39;, &#39;right&#39; or
1180     // &#39;center&#39;), &#39;legacy&#39; computes to the the inherited value. Otherwise, &#39;auto&#39; computes to &#39;normal&#39;.
1181     if (parentBoxStyle-&gt;justifyItems().positionType() == ItemPositionType::Legacy &amp;&amp; style.justifyItems().position() == ItemPosition::Legacy)
1182         style.setJustifyItems(parentBoxStyle-&gt;justifyItems());
1183 
1184 #if ENABLE(POINTER_EVENTS)
1185     style.setEffectiveTouchActions(computeEffectiveTouchActions(style, parentStyle.effectiveTouchActions()));
1186 #endif
1187 
1188     if (element) {
1189 #if ENABLE(TEXT_AUTOSIZING)
1190         adjustRenderStyleForTextAutosizing(style, *element);
1191 #endif
1192         adjustRenderStyleForSiteSpecificQuirks(style, *element);
1193     }
1194 }
1195 
1196 void StyleResolver::adjustRenderStyleForSiteSpecificQuirks(RenderStyle&amp; style, const Element&amp; element)
1197 {
1198     if (document().quirks().needsGMailOverflowScrollQuirk()) {
1199         // This turns sidebar scrollable without mouse move event.
1200         static NeverDestroyed&lt;AtomString&gt; roleValue(&quot;navigation&quot;, AtomString::ConstructFromLiteral);
1201         if (style.overflowY() == Overflow::Hidden &amp;&amp; element.attributeWithoutSynchronization(roleAttr) == roleValue)
1202             style.setOverflowY(Overflow::Auto);
1203     }
1204     if (document().quirks().needsYouTubeOverflowScrollQuirk()) {
1205         // This turns sidebar scrollable without hover.
1206         static NeverDestroyed&lt;AtomString&gt; idValue(&quot;guide-inner-content&quot;, AtomString::ConstructFromLiteral);
1207         if (style.overflowY() == Overflow::Hidden &amp;&amp; element.idForStyleResolution() == idValue)
1208             style.setOverflowY(Overflow::Auto);
1209     }
1210 }
1211 
1212 static void checkForOrientationChange(RenderStyle&amp; style)
1213 {
1214     auto [fontOrientation, glyphOrientation] = style.fontAndGlyphOrientation();
1215 
1216     const auto&amp; fontDescription = style.fontDescription();
1217     if (fontDescription.orientation() == fontOrientation &amp;&amp; fontDescription.nonCJKGlyphOrientation() == glyphOrientation)
1218         return;
1219 
1220     auto newFontDescription = fontDescription;
1221     newFontDescription.setNonCJKGlyphOrientation(glyphOrientation);
1222     newFontDescription.setOrientation(fontOrientation);
1223     style.setFontDescription(WTFMove(newFontDescription));
1224 }
1225 
1226 void StyleResolver::updateFont()
1227 {
1228     if (!m_state.fontDirty())
1229         return;
1230 
1231     auto&amp; style = *m_state.style();
1232 #if ENABLE(TEXT_AUTOSIZING)
1233     checkForTextSizeAdjust(style);
1234 #endif
1235     checkForGenericFamilyChange(style, m_state.parentStyle());
1236     checkForZoomChange(style, m_state.parentStyle());
1237     checkForOrientationChange(style);
1238     style.fontCascade().update(&amp;document().fontSelector());
1239     if (m_state.fontSizeHasViewportUnits())
1240         style.setHasViewportUnits(true);
1241     m_state.setFontDirty(false);
1242 }
1243 
1244 Vector&lt;RefPtr&lt;StyleRule&gt;&gt; StyleResolver::styleRulesForElement(const Element* element, unsigned rulesToInclude)
1245 {
1246     return pseudoStyleRulesForElement(element, PseudoId::None, rulesToInclude);
1247 }
1248 
1249 Vector&lt;RefPtr&lt;StyleRule&gt;&gt; StyleResolver::pseudoStyleRulesForElement(const Element* element, PseudoId pseudoId, unsigned rulesToInclude)
1250 {
1251     if (!element)
1252         return { };
1253 
1254     m_state = State(*element, nullptr);
1255 
1256     ElementRuleCollector collector(*element, m_ruleSets, m_state.selectorFilter());
1257     collector.setMode(SelectorChecker::Mode::CollectingRules);
1258     collector.setPseudoStyleRequest(PseudoStyleRequest(pseudoId));
1259     collector.setMedium(&amp;m_mediaQueryEvaluator);
1260 
1261     if (rulesToInclude &amp; UAAndUserCSSRules) {
1262         // First we match rules from the user agent sheet.
1263         collector.matchUARules();
1264 
1265         // Now we check user sheet rules.
1266         if (m_matchAuthorAndUserStyles)
1267             collector.matchUserRules(rulesToInclude &amp; EmptyCSSRules);
1268     }
1269 
1270     if (m_matchAuthorAndUserStyles &amp;&amp; (rulesToInclude &amp; AuthorCSSRules))
1271         collector.matchAuthorRules(rulesToInclude &amp; EmptyCSSRules);
1272 
1273     return collector.matchedRuleList();
1274 }
1275 
1276 static bool shouldApplyPropertyInParseOrder(CSSPropertyID propertyID)
1277 {
1278     switch (propertyID) {
1279     case CSSPropertyWebkitBackgroundClip:
1280     case CSSPropertyBackgroundClip:
1281     case CSSPropertyWebkitBackgroundOrigin:
1282     case CSSPropertyBackgroundOrigin:
1283     case CSSPropertyWebkitBackgroundSize:
1284     case CSSPropertyBackgroundSize:
1285     case CSSPropertyWebkitBorderImage:
1286     case CSSPropertyBorderImage:
1287     case CSSPropertyBorderImageSlice:
1288     case CSSPropertyBorderImageSource:
1289     case CSSPropertyBorderImageOutset:
1290     case CSSPropertyBorderImageRepeat:
1291     case CSSPropertyBorderImageWidth:
1292     case CSSPropertyWebkitBoxShadow:
1293     case CSSPropertyBoxShadow:
1294     case CSSPropertyWebkitTextDecoration:
1295     case CSSPropertyTextDecorationLine:
1296     case CSSPropertyTextDecorationStyle:
1297     case CSSPropertyTextDecorationColor:
1298     case CSSPropertyTextDecorationSkip:
1299     case CSSPropertyTextUnderlinePosition:
1300     case CSSPropertyTextUnderlineOffset:
1301     case CSSPropertyTextDecorationThickness:
1302     case CSSPropertyTextDecoration:
1303         return true;
1304     default:
1305         return false;
1306     }
1307 }
1308 
1309 static bool elementTypeHasAppearanceFromUAStyle(const Element&amp; element)
1310 {
1311     // NOTE: This is just a hard-coded list of elements that have some -webkit-appearance value in html.css
1312     const auto&amp; localName = element.localName();
1313     return localName == HTMLNames::inputTag
1314         || localName == HTMLNames::textareaTag
1315         || localName == HTMLNames::buttonTag
1316         || localName == HTMLNames::progressTag
1317         || localName == HTMLNames::selectTag
1318         || localName == HTMLNames::meterTag;
1319 }
1320 
1321 unsigned StyleResolver::computeMatchedPropertiesHash(const MatchedProperties* properties, unsigned size)
1322 {
1323     return StringHasher::hashMemory(properties, sizeof(MatchedProperties) * size);
1324 }
1325 
1326 bool operator==(const StyleResolver::MatchRanges&amp; a, const StyleResolver::MatchRanges&amp; b)
1327 {
1328     return a.firstUARule == b.firstUARule
1329         &amp;&amp; a.lastUARule == b.lastUARule
1330         &amp;&amp; a.firstAuthorRule == b.firstAuthorRule
1331         &amp;&amp; a.lastAuthorRule == b.lastAuthorRule
1332         &amp;&amp; a.firstUserRule == b.firstUserRule
1333         &amp;&amp; a.lastUserRule == b.lastUserRule;
1334 }
1335 
1336 bool operator!=(const StyleResolver::MatchRanges&amp; a, const StyleResolver::MatchRanges&amp; b)
1337 {
1338     return !(a == b);
1339 }
1340 
1341 bool operator==(const StyleResolver::MatchedProperties&amp; a, const StyleResolver::MatchedProperties&amp; b)
1342 {
1343     return a.properties == b.properties &amp;&amp; a.linkMatchType == b.linkMatchType;
1344 }
1345 
1346 bool operator!=(const StyleResolver::MatchedProperties&amp; a, const StyleResolver::MatchedProperties&amp; b)
1347 {
1348     return !(a == b);
1349 }
1350 
1351 const StyleResolver::MatchedPropertiesCacheItem* StyleResolver::findFromMatchedPropertiesCache(unsigned hash, const MatchResult&amp; matchResult)
1352 {
1353     ASSERT(hash);
1354 
1355     MatchedPropertiesCache::iterator it = m_matchedPropertiesCache.find(hash);
1356     if (it == m_matchedPropertiesCache.end())
1357         return nullptr;
1358     MatchedPropertiesCacheItem&amp; cacheItem = it-&gt;value;
1359 
1360     size_t size = matchResult.matchedProperties().size();
1361     if (size != cacheItem.matchedProperties.size())
1362         return nullptr;
1363     for (size_t i = 0; i &lt; size; ++i) {
1364         if (matchResult.matchedProperties()[i] != cacheItem.matchedProperties[i])
1365             return nullptr;
1366     }
1367     if (cacheItem.ranges != matchResult.ranges)
1368         return nullptr;
1369     return &amp;cacheItem;
1370 }
1371 
1372 void StyleResolver::addToMatchedPropertiesCache(const RenderStyle* style, const RenderStyle* parentStyle, unsigned hash, const MatchResult&amp; matchResult)
1373 {
1374     static const unsigned matchedDeclarationCacheAdditionsBetweenSweeps = 100;
1375     if (++m_matchedPropertiesCacheAdditionsSinceLastSweep &gt;= matchedDeclarationCacheAdditionsBetweenSweeps
1376         &amp;&amp; !m_matchedPropertiesCacheSweepTimer.isActive()) {
1377         static const Seconds matchedDeclarationCacheSweepTime { 1_min };
1378         m_matchedPropertiesCacheSweepTimer.startOneShot(matchedDeclarationCacheSweepTime);
1379     }
1380 
1381     ASSERT(hash);
1382     // Note that we don&#39;t cache the original RenderStyle instance. It may be further modified.
1383     // The RenderStyle in the cache is really just a holder for the substructures and never used as-is.
1384     MatchedPropertiesCacheItem cacheItem(matchResult, style, parentStyle);
1385     m_matchedPropertiesCache.add(hash, WTFMove(cacheItem));
1386 }
1387 
1388 void StyleResolver::invalidateMatchedPropertiesCache()
1389 {
1390     m_matchedPropertiesCache.clear();
1391 }
1392 
1393 void StyleResolver::clearCachedPropertiesAffectedByViewportUnits()
1394 {
1395     Vector&lt;unsigned, 16&gt; toRemove;
1396     for (auto&amp; cacheKeyValue : m_matchedPropertiesCache) {
1397         if (cacheKeyValue.value.renderStyle-&gt;hasViewportUnits())
1398             toRemove.append(cacheKeyValue.key);
1399     }
1400     for (auto key : toRemove)
1401         m_matchedPropertiesCache.remove(key);
1402 }
1403 
1404 static bool isCacheableInMatchedPropertiesCache(const Element&amp; element, const RenderStyle* style, const RenderStyle* parentStyle)
1405 {
1406     // FIXME: Writing mode and direction properties modify state when applying to document element by calling
1407     // Document::setWritingMode/DirectionSetOnDocumentElement. We can&#39;t skip the applying by caching.
1408     if (&amp;element == element.document().documentElement())
1409         return false;
1410     // content:attr() value depends on the element it is being applied to.
1411     if (style-&gt;hasAttrContent() || (style-&gt;styleType() != PseudoId::None &amp;&amp; parentStyle-&gt;hasAttrContent()))
1412         return false;
1413     if (style-&gt;hasAppearance())
1414         return false;
1415     if (style-&gt;zoom() != RenderStyle::initialZoom())
1416         return false;
1417     if (style-&gt;writingMode() != RenderStyle::initialWritingMode() || style-&gt;direction() != RenderStyle::initialDirection())
1418         return false;
1419     // The cache assumes static knowledge about which properties are inherited.
1420     if (style-&gt;hasExplicitlyInheritedProperties())
1421         return false;
1422     return true;
1423 }
1424 
1425 void extractDirectionAndWritingMode(const RenderStyle&amp; style, const StyleResolver::MatchResult&amp; matchResult, TextDirection&amp; direction, WritingMode&amp; writingMode)
1426 {
1427     direction = style.direction();
1428     writingMode = style.writingMode();
1429 
1430     bool hadImportantWritingMode = false;
1431     bool hadImportantDirection = false;
1432 
1433     for (const auto&amp; matchedProperties : matchResult.matchedProperties()) {
1434         for (unsigned i = 0, count = matchedProperties.properties-&gt;propertyCount(); i &lt; count; ++i) {
1435             auto property = matchedProperties.properties-&gt;propertyAt(i);
1436             if (!property.value()-&gt;isPrimitiveValue())
1437                 continue;
1438             switch (property.id()) {
1439             case CSSPropertyWritingMode:
1440                 if (!hadImportantWritingMode || property.isImportant()) {
1441                     writingMode = downcast&lt;CSSPrimitiveValue&gt;(*property.value());
1442                     hadImportantWritingMode = property.isImportant();
1443                 }
1444                 break;
1445             case CSSPropertyDirection:
1446                 if (!hadImportantDirection || property.isImportant()) {
1447                     direction = downcast&lt;CSSPrimitiveValue&gt;(*property.value());
1448                     hadImportantDirection = property.isImportant();
1449                 }
1450                 break;
1451             default:
1452                 break;
1453             }
1454         }
1455     }
1456 }
1457 
1458 void StyleResolver::applyMatchedProperties(const MatchResult&amp; matchResult, const Element&amp; element, ShouldUseMatchedPropertiesCache shouldUseMatchedPropertiesCache)
1459 {
1460     State&amp; state = m_state;
1461     unsigned cacheHash = shouldUseMatchedPropertiesCache &amp;&amp; matchResult.isCacheable ? computeMatchedPropertiesHash(matchResult.matchedProperties().data(), matchResult.matchedProperties().size()) : 0;
1462     bool applyInheritedOnly = false;
1463     const MatchedPropertiesCacheItem* cacheItem = nullptr;
1464     if (cacheHash &amp;&amp; (cacheItem = findFromMatchedPropertiesCache(cacheHash, matchResult))
1465         &amp;&amp; isCacheableInMatchedPropertiesCache(element, state.style(), state.parentStyle())) {
1466         // We can build up the style by copying non-inherited properties from an earlier style object built using the same exact
1467         // style declarations. We then only need to apply the inherited properties, if any, as their values can depend on the
1468         // element context. This is fast and saves memory by reusing the style data structures.
1469         state.style()-&gt;copyNonInheritedFrom(*cacheItem-&gt;renderStyle);
1470         if (state.parentStyle()-&gt;inheritedDataShared(cacheItem-&gt;parentRenderStyle.get()) &amp;&amp; !isAtShadowBoundary(element)) {
1471             InsideLink linkStatus = state.style()-&gt;insideLink();
1472             // If the cache item parent style has identical inherited properties to the current parent style then the
1473             // resulting style will be identical too. We copy the inherited properties over from the cache and are done.
1474             state.style()-&gt;inheritFrom(*cacheItem-&gt;renderStyle);
1475 
1476             // Unfortunately the link status is treated like an inherited property. We need to explicitly restore it.
1477             state.style()-&gt;setInsideLink(linkStatus);
1478             return;
1479         }
1480         applyInheritedOnly = true;
1481     }
1482 
1483     // Directional properties (*-before/after) are aliases that depend on the TextDirection and WritingMode.
1484     // These must be resolved before we can begin the property cascade.
1485     TextDirection direction;
1486     WritingMode writingMode;
1487     extractDirectionAndWritingMode(*state.style(), matchResult, direction, writingMode);
1488 
1489     if (elementTypeHasAppearanceFromUAStyle(*state.element())) {
1490         // FIXME: This is such a hack.
1491         // Find out if there&#39;s a -webkit-appearance property in effect from the UA sheet.
1492         // If so, we cache the border and background styles so that RenderTheme::adjustStyle()
1493         // can look at them later to figure out if this is a styled form control or not.
1494         CascadedProperties cascade(direction, writingMode);
1495         cascade.addNormalMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, applyInheritedOnly);
1496         cascade.addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, applyInheritedOnly);
1497 
1498         ApplyCascadedPropertyState applyState { this, &amp;cascade, &amp;matchResult };
1499 
1500         applyCascadedProperties(CSSPropertyWebkitRubyPosition, CSSPropertyWebkitRubyPosition, applyState);
1501         adjustStyleForInterCharacterRuby();
1502 
1503 #if ENABLE(DARK_MODE_CSS)
1504         // Supported color schemes can affect resolved colors, so we need to apply that property before any color properties.
1505         applyCascadedProperties(CSSPropertyColorScheme, CSSPropertyColorScheme, applyState);
1506 #endif
1507 
1508         applyCascadedProperties(firstCSSProperty, lastHighPriorityProperty, applyState);
1509 
1510         // If our font got dirtied, update it now.
1511         updateFont();
1512 
1513         // Now resolve remaining custom properties and the rest, in any order
1514         for (auto it = cascade.customProperties().begin(); it != cascade.customProperties().end(); ++it)
1515             applyCascadedCustomProperty(it-&gt;key, applyState);
1516         applyCascadedProperties(firstLowPriorityProperty, lastCSSProperty, applyState);
1517 
1518         state.cacheBorderAndBackground();
1519     }
1520 
1521     CascadedProperties cascade(direction, writingMode);
1522     cascade.addNormalMatches(matchResult, 0, matchResult.matchedProperties().size() - 1, applyInheritedOnly);
1523     cascade.addImportantMatches(matchResult, matchResult.ranges.firstAuthorRule, matchResult.ranges.lastAuthorRule, applyInheritedOnly);
1524     cascade.addImportantMatches(matchResult, matchResult.ranges.firstUserRule, matchResult.ranges.lastUserRule, applyInheritedOnly);
1525     cascade.addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, applyInheritedOnly);
1526 
1527     ApplyCascadedPropertyState applyState { this, &amp;cascade, &amp;matchResult };
1528 
1529     applyCascadedProperties(CSSPropertyWebkitRubyPosition, CSSPropertyWebkitRubyPosition, applyState);
1530     adjustStyleForInterCharacterRuby();
1531 
1532 #if ENABLE(DARK_MODE_CSS)
1533     // Supported color schemes can affect resolved colors, so we need to apply that property before any color properties.
1534     applyCascadedProperties(CSSPropertyColorScheme, CSSPropertyColorScheme, applyState);
1535 #endif
1536 
1537     applyCascadedProperties(firstCSSProperty, lastHighPriorityProperty, applyState);
1538 
1539     // If the effective zoom value changes, we can&#39;t use the matched properties cache. Start over.
1540     if (cacheItem &amp;&amp; cacheItem-&gt;renderStyle-&gt;effectiveZoom() != state.style()-&gt;effectiveZoom())
1541         return applyMatchedProperties(matchResult, element, DoNotUseMatchedPropertiesCache);
1542 
1543     // If our font got dirtied, update it now.
1544     updateFont();
1545 
1546     // If the font changed, we can&#39;t use the matched properties cache. Start over.
1547     if (cacheItem &amp;&amp; cacheItem-&gt;renderStyle-&gt;fontDescription() != state.style()-&gt;fontDescription())
1548         return applyMatchedProperties(matchResult, element, DoNotUseMatchedPropertiesCache);
1549 
1550     // Now resolve remaining custom properties and the rest, in any order
1551     for (auto it = cascade.customProperties().begin(); it != cascade.customProperties().end(); ++it)
1552         applyCascadedCustomProperty(it-&gt;key, applyState);
1553     applyCascadedProperties(firstLowPriorityProperty, lastCSSProperty, applyState);
1554 
1555     // Finally, some properties must be applied in the order they were parsed.
1556     // There are some CSS properties that affect the same RenderStyle values,
1557     // so to preserve behavior, we queue them up during cascade and flush here.
1558     cascade.applyDeferredProperties(*this, applyState);
1559 
1560     ASSERT(!state.fontDirty());
1561 
1562     if (cacheItem || !cacheHash)
1563         return;
1564     if (!isCacheableInMatchedPropertiesCache(*state.element(), state.style(), state.parentStyle()))
1565         return;
1566     addToMatchedPropertiesCache(state.style(), state.parentStyle(), cacheHash, matchResult);
1567 }
1568 
1569 void StyleResolver::applyPropertyToStyle(CSSPropertyID id, CSSValue* value, std::unique_ptr&lt;RenderStyle&gt; style)
1570 {
1571     m_state = State();
1572     m_state.setParentStyle(RenderStyle::clonePtr(*style));
1573     m_state.setStyle(WTFMove(style));
1574     applyPropertyToCurrentStyle(id, value);
1575 }
1576 
1577 void StyleResolver::applyPropertyToCurrentStyle(CSSPropertyID id, CSSValue* value)
1578 {
1579     ApplyCascadedPropertyState applyState { this, nullptr, nullptr };
1580     if (value)
1581         applyProperty(id, value, applyState);
1582 }
1583 
1584 inline bool isValidVisitedLinkProperty(CSSPropertyID id)
1585 {
1586     switch (id) {
1587     case CSSPropertyBackgroundColor:
1588     case CSSPropertyBorderLeftColor:
1589     case CSSPropertyBorderRightColor:
1590     case CSSPropertyBorderTopColor:
1591     case CSSPropertyBorderBottomColor:
1592     case CSSPropertyCaretColor:
1593     case CSSPropertyColor:
1594     case CSSPropertyOutlineColor:
1595     case CSSPropertyColumnRuleColor:
1596     case CSSPropertyTextDecorationColor:
1597     case CSSPropertyWebkitTextEmphasisColor:
1598     case CSSPropertyWebkitTextFillColor:
1599     case CSSPropertyWebkitTextStrokeColor:
1600     case CSSPropertyFill:
1601     case CSSPropertyStroke:
1602     case CSSPropertyStrokeColor:
1603         return true;
1604     default:
1605         break;
1606     }
1607 
1608     return false;
1609 }
1610 
1611 // https://www.w3.org/TR/css-pseudo-4/#marker-pseudo (Editor&#39;s Draft, 25 July 2017)
1612 static inline bool isValidMarkerStyleProperty(CSSPropertyID id)
1613 {
1614     switch (id) {
1615     case CSSPropertyColor:
1616     case CSSPropertyFontFamily:
1617     case CSSPropertyFontFeatureSettings:
1618     case CSSPropertyFontSize:
1619     case CSSPropertyFontStretch:
1620     case CSSPropertyFontStyle:
1621     case CSSPropertyFontSynthesis:
1622     case CSSPropertyFontVariantAlternates:
1623     case CSSPropertyFontVariantCaps:
1624     case CSSPropertyFontVariantEastAsian:
1625     case CSSPropertyFontVariantLigatures:
1626     case CSSPropertyFontVariantNumeric:
1627     case CSSPropertyFontVariantPosition:
1628     case CSSPropertyFontWeight:
1629 #if ENABLE(VARIATION_FONTS)
1630     case CSSPropertyFontOpticalSizing:
1631     case CSSPropertyFontVariationSettings:
1632 #endif
1633         return true;
1634     default:
1635         break;
1636     }
1637     return false;
1638 }
1639 
1640 #if ENABLE(VIDEO_TRACK)
1641 static inline bool isValidCueStyleProperty(CSSPropertyID id)
1642 {
1643     switch (id) {
1644     case CSSPropertyBackground:
1645     case CSSPropertyBackgroundAttachment:
1646     case CSSPropertyBackgroundClip:
1647     case CSSPropertyBackgroundColor:
1648     case CSSPropertyBackgroundImage:
1649     case CSSPropertyBackgroundOrigin:
1650     case CSSPropertyBackgroundPosition:
1651     case CSSPropertyBackgroundPositionX:
1652     case CSSPropertyBackgroundPositionY:
1653     case CSSPropertyBackgroundRepeat:
1654     case CSSPropertyBackgroundSize:
1655     case CSSPropertyColor:
1656     case CSSPropertyFont:
1657     case CSSPropertyFontFamily:
1658     case CSSPropertyFontSize:
1659     case CSSPropertyFontStyle:
1660     case CSSPropertyFontVariantCaps:
1661     case CSSPropertyFontWeight:
1662     case CSSPropertyLineHeight:
1663     case CSSPropertyOpacity:
1664     case CSSPropertyOutline:
1665     case CSSPropertyOutlineColor:
1666     case CSSPropertyOutlineOffset:
1667     case CSSPropertyOutlineStyle:
1668     case CSSPropertyOutlineWidth:
1669     case CSSPropertyVisibility:
1670     case CSSPropertyWhiteSpace:
1671     case CSSPropertyTextDecoration:
1672     case CSSPropertyTextShadow:
1673     case CSSPropertyBorderStyle:
1674     case CSSPropertyPaintOrder:
1675     case CSSPropertyStrokeLinejoin:
1676     case CSSPropertyStrokeLinecap:
1677     case CSSPropertyStrokeColor:
1678     case CSSPropertyStrokeWidth:
1679         return true;
1680     default:
1681         break;
1682     }
1683     return false;
1684 }
1685 #endif
1686 // SVG handles zooming in a different way compared to CSS. The whole document is scaled instead
1687 // of each individual length value in the render style / tree. CSSPrimitiveValue::computeLength*()
1688 // multiplies each resolved length with the zoom multiplier - so for SVG we need to disable that.
1689 // Though all CSS values that can be applied to outermost &lt;svg&gt; elements (width/height/border/padding...)
1690 // need to respect the scaling. RenderBox (the parent class of RenderSVGRoot) grabs values like
1691 // width/height/border/padding/... from the RenderStyle -&gt; for SVG these values would never scale,
1692 // if we&#39;d pass a 1.0 zoom factor everyhwere. So we only pass a zoom factor of 1.0 for specific
1693 // properties that are NOT allowed to scale within a zoomed SVG document (letter/word-spacing/font-size).
1694 bool StyleResolver::useSVGZoomRules() const
1695 {
1696     return m_state.element() &amp;&amp; m_state.element()-&gt;isSVGElement();
1697 }
1698 
1699 // Scale with/height properties on inline SVG root.
1700 bool StyleResolver::useSVGZoomRulesForLength() const
1701 {
1702     return is&lt;SVGElement&gt;(m_state.element()) &amp;&amp; !(is&lt;SVGSVGElement&gt;(*m_state.element()) &amp;&amp; m_state.element()-&gt;parentNode());
1703 }
1704 
1705 StyleResolver::CascadedProperties* StyleResolver::cascadedPropertiesForRollback(const MatchResult&amp; matchResult)
1706 {
1707     ASSERT(cascadeLevel() != CascadeLevel::UserAgentLevel);
1708 
1709     TextDirection direction;
1710     WritingMode writingMode;
1711     extractDirectionAndWritingMode(*state().style(), matchResult, direction, writingMode);
1712 
1713     if (cascadeLevel() == CascadeLevel::AuthorLevel) {
1714         CascadedProperties* authorRollback = state().authorRollback();
1715         if (authorRollback)
1716             return authorRollback;
1717 
1718         auto newAuthorRollback(makeUnique&lt;CascadedProperties&gt;(direction, writingMode));
1719 
1720         // This special rollback cascade contains UA rules and user rules but no author rules.
1721         newAuthorRollback-&gt;addNormalMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1722         newAuthorRollback-&gt;addNormalMatches(matchResult, matchResult.ranges.firstUserRule, matchResult.ranges.lastUserRule, false);
1723         newAuthorRollback-&gt;addImportantMatches(matchResult, matchResult.ranges.firstUserRule, matchResult.ranges.lastUserRule, false);
1724         newAuthorRollback-&gt;addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1725 
1726         state().setAuthorRollback(newAuthorRollback);
1727         return state().authorRollback();
1728     }
1729 
1730     if (cascadeLevel() == CascadeLevel::UserLevel) {
1731         CascadedProperties* userRollback = state().userRollback();
1732         if (userRollback)
1733             return userRollback;
1734 
1735         auto newUserRollback(makeUnique&lt;CascadedProperties&gt;(direction, writingMode));
1736 
1737         // This special rollback cascade contains only UA rules.
1738         newUserRollback-&gt;addNormalMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1739         newUserRollback-&gt;addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1740 
1741         state().setUserRollback(newUserRollback);
1742         return state().userRollback();
1743     }
1744 
1745     return nullptr;
1746 }
1747 
1748 void StyleResolver::applyProperty(CSSPropertyID id, CSSValue* value, ApplyCascadedPropertyState&amp; applyState, SelectorChecker::LinkMatchMask linkMatchMask)
1749 {
1750     auto* matchResult = applyState.matchResult;
1751     ASSERT_WITH_MESSAGE(!isShorthandCSSProperty(id), &quot;Shorthand property id = %d wasn&#39;t expanded at parsing time&quot;, id);
1752 
1753     State&amp; state = m_state;
1754 
1755     RefPtr&lt;CSSValue&gt; valueToApply = value;
1756     if (value-&gt;hasVariableReferences()) {
1757         valueToApply = resolvedVariableValue(id, *value, applyState);
1758         // If appliedProperties already has this id, then we detected a cycle, and this value should be unset.
1759         if (!valueToApply || applyState.appliedProperties.get(id)) {
1760             if (CSSProperty::isInheritedProperty(id))
1761                 valueToApply = CSSValuePool::singleton().createInheritedValue();
1762             else
1763                 valueToApply = CSSValuePool::singleton().createExplicitInitialValue();
1764         }
1765     }
1766 
1767     if (CSSProperty::isDirectionAwareProperty(id)) {
1768         CSSPropertyID newId = CSSProperty::resolveDirectionAwareProperty(id, state.style()-&gt;direction(), state.style()-&gt;writingMode());
1769         ASSERT(newId != id);
1770         return applyProperty(newId, valueToApply.get(), applyState, linkMatchMask);
1771     }
1772 
1773     CSSValue* valueToCheckForInheritInitial = valueToApply.get();
1774     CSSCustomPropertyValue* customPropertyValue = nullptr;
1775     CSSValueID customPropertyValueID = CSSValueInvalid;
1776 
1777     CSSRegisteredCustomProperty* customPropertyRegistered = nullptr;
1778 
1779     if (id == CSSPropertyCustom) {
1780         customPropertyValue = &amp;downcast&lt;CSSCustomPropertyValue&gt;(*valueToApply);
1781         ASSERT(customPropertyValue-&gt;isResolved());
1782         if (WTF::holds_alternative&lt;CSSValueID&gt;(customPropertyValue-&gt;value()))
1783             customPropertyValueID = WTF::get&lt;CSSValueID&gt;(customPropertyValue-&gt;value());
1784         auto&amp; name = customPropertyValue-&gt;name();
1785         customPropertyRegistered = document().getCSSRegisteredCustomPropertySet().get(name);
1786     }
1787 
1788     bool isInherit = state.parentStyle() ? valueToCheckForInheritInitial-&gt;isInheritedValue() || customPropertyValueID == CSSValueInherit : false;
1789     bool isInitial = valueToCheckForInheritInitial-&gt;isInitialValue() || customPropertyValueID == CSSValueInitial || (!state.parentStyle() &amp;&amp; (valueToCheckForInheritInitial-&gt;isInheritedValue() || customPropertyValueID == CSSValueInherit));
1790 
1791     bool isUnset = valueToCheckForInheritInitial-&gt;isUnsetValue() || customPropertyValueID == CSSValueUnset;
1792     bool isRevert = valueToCheckForInheritInitial-&gt;isRevertValue() || customPropertyValueID == CSSValueRevert;
1793 
1794     if (isRevert) {
1795         if (cascadeLevel() == CascadeLevel::UserAgentLevel || !matchResult)
1796             isUnset = true;
1797         else {
1798             // Fetch the correct rollback object from the state, building it if necessary.
1799             // This requires having the original MatchResult available.
1800             auto* rollback = cascadedPropertiesForRollback(*matchResult);
1801             ASSERT(rollback);
1802 
1803             // With the cascade built, we need to obtain the property and apply it. If the property is
1804             // not present, then we behave like &quot;unset.&quot; Otherwise we apply the property instead of
1805             // our own.
1806             if (customPropertyValue) {
1807                 if (customPropertyRegistered &amp;&amp; customPropertyRegistered-&gt;inherits &amp;&amp; rollback-&gt;hasCustomProperty(customPropertyValue-&gt;name())) {
1808                     auto property = rollback-&gt;customProperty(customPropertyValue-&gt;name());
1809                     if (property.cssValue[linkMatchMask])
1810                         applyProperty(property.id, property.cssValue[linkMatchMask], applyState, linkMatchMask);
1811                     return;
1812                 }
1813             } else if (rollback-&gt;hasProperty(id)) {
1814                 auto&amp; property = rollback-&gt;property(id);
1815                 if (property.cssValue[linkMatchMask])
1816                     applyProperty(property.id, property.cssValue[linkMatchMask], applyState, linkMatchMask);
1817                 return;
1818             }
1819 
1820             isUnset = true;
1821         }
1822     }
1823 
1824     if (isUnset) {
1825         if (CSSProperty::isInheritedProperty(id))
1826             isInherit = true;
1827         else
1828             isInitial = true;
1829     }
1830 
1831     ASSERT(!isInherit || !isInitial); // isInherit -&gt; !isInitial &amp;&amp; isInitial -&gt; !isInherit
1832 
1833     if (!state.applyPropertyToRegularStyle() &amp;&amp; (!state.applyPropertyToVisitedLinkStyle() || !isValidVisitedLinkProperty(id))) {
1834         // Limit the properties that can be applied to only the ones honored by :visited.
1835         return;
1836     }
1837 
1838     if (isInherit &amp;&amp; !CSSProperty::isInheritedProperty(id))
1839         state.style()-&gt;setHasExplicitlyInheritedProperties();
1840 
1841 #if ENABLE(CSS_PAINTING_API)
1842     if (is&lt;CSSPaintImageValue&gt;(*valueToApply)) {
1843         auto&amp; name = downcast&lt;CSSPaintImageValue&gt;(*valueToApply).name();
1844         if (auto* paintWorklet = document().paintWorkletGlobalScopeForName(name)) {
1845             auto locker = holdLock(paintWorklet-&gt;paintDefinitionLock());
1846             if (auto* registration = paintWorklet-&gt;paintDefinitionMap().get(name)) {
1847                 for (auto&amp; property : registration-&gt;inputProperties)
1848                     state.style()-&gt;addCustomPaintWatchProperty(property);
1849             }
1850         }
1851     }
1852 #endif
1853 
1854     // Use the generated StyleBuilder.
1855     StyleBuilder::applyProperty(id, *this, *valueToApply, isInitial, isInherit, customPropertyRegistered);
1856 }
1857 
1858 RefPtr&lt;CSSValue&gt; StyleResolver::resolvedVariableValue(CSSPropertyID propID, const CSSValue&amp; value, ApplyCascadedPropertyState&amp; state) const
1859 {
1860     CSSParser parser(document());
1861     return parser.parseValueWithVariableReferences(propID, value, state);
1862 }
1863 
1864 RefPtr&lt;StyleImage&gt; StyleResolver::styleImage(CSSValue&amp; value)
1865 {
1866     if (is&lt;CSSImageGeneratorValue&gt;(value)) {
1867         if (is&lt;CSSGradientValue&gt;(value))
1868             return StyleGeneratedImage::create(downcast&lt;CSSGradientValue&gt;(value).gradientWithStylesResolved(*this));
1869 
1870         if (is&lt;CSSFilterImageValue&gt;(value)) {
1871             // FilterImage needs to calculate FilterOperations.
1872             downcast&lt;CSSFilterImageValue&gt;(value).createFilterOperations(this);
1873         }
1874         return StyleGeneratedImage::create(downcast&lt;CSSImageGeneratorValue&gt;(value));
1875     }
1876 
1877     if (is&lt;CSSImageValue&gt;(value) || is&lt;CSSImageSetValue&gt;(value) || is&lt;CSSCursorImageValue&gt;(value))
1878         return StyleCachedImage::create(value);
1879 
1880     return nullptr;
1881 }
1882 
1883 #if ENABLE(TEXT_AUTOSIZING)
1884 void StyleResolver::checkForTextSizeAdjust(RenderStyle&amp; style)
1885 {
1886     if (style.textSizeAdjust().isAuto()
1887         || !settings().textAutosizingEnabled()
1888         || (settings().textAutosizingUsesIdempotentMode() &amp;&amp; !style.textSizeAdjust().isNone()))
1889         return;
1890 
1891     auto newFontDescription = style.fontDescription();
1892     if (!style.textSizeAdjust().isNone())
1893         newFontDescription.setComputedSize(newFontDescription.specifiedSize() * style.textSizeAdjust().multiplier());
1894     else
1895         newFontDescription.setComputedSize(newFontDescription.specifiedSize());
1896     style.setFontDescription(WTFMove(newFontDescription));
1897 }
1898 #endif
1899 
1900 void StyleResolver::checkForZoomChange(RenderStyle&amp; style, const RenderStyle* parentStyle)
1901 {
1902     if (!parentStyle)
1903         return;
1904 
1905     if (style.effectiveZoom() == parentStyle-&gt;effectiveZoom() &amp;&amp; style.textZoom() == parentStyle-&gt;textZoom())
1906         return;
1907 
1908     const auto&amp; childFont = style.fontDescription();
1909     auto newFontDescription = childFont;
1910     setFontSize(newFontDescription, childFont.specifiedSize());
1911     style.setFontDescription(WTFMove(newFontDescription));
1912 }
1913 
1914 void StyleResolver::checkForGenericFamilyChange(RenderStyle&amp; style, const RenderStyle* parentStyle)
1915 {
1916     const auto&amp; childFont = style.fontDescription();
1917 
1918     if (childFont.isAbsoluteSize() || !parentStyle)
1919         return;
1920 
1921     const auto&amp; parentFont = parentStyle-&gt;fontDescription();
1922     if (childFont.useFixedDefaultSize() == parentFont.useFixedDefaultSize())
1923         return;
1924     // We know the parent is monospace or the child is monospace, and that font
1925     // size was unspecified. We want to scale our font size as appropriate.
1926     // If the font uses a keyword size, then we refetch from the table rather than
1927     // multiplying by our scale factor.
1928     float size;
1929     if (CSSValueID sizeIdentifier = childFont.keywordSizeAsIdentifier())
1930         size = Style::fontSizeForKeyword(sizeIdentifier, childFont.useFixedDefaultSize(), document());
1931     else {
1932         float fixedScaleFactor = (settings().defaultFixedFontSize() &amp;&amp; settings().defaultFontSize())
1933             ? static_cast&lt;float&gt;(settings().defaultFixedFontSize()) / settings().defaultFontSize()
1934             : 1;
1935         size = parentFont.useFixedDefaultSize() ?
1936                 childFont.specifiedSize() / fixedScaleFactor :
1937                 childFont.specifiedSize() * fixedScaleFactor;
1938     }
1939 
1940     auto newFontDescription = childFont;
1941     setFontSize(newFontDescription, size);
1942     style.setFontDescription(WTFMove(newFontDescription));
1943 }
1944 
1945 void StyleResolver::initializeFontStyle()
1946 {
1947     FontCascadeDescription fontDescription;
1948     fontDescription.setRenderingMode(settings().fontRenderingMode());
1949     fontDescription.setOneFamily(standardFamily);
1950     fontDescription.setKeywordSizeFromIdentifier(CSSValueMedium);
1951     setFontSize(fontDescription, Style::fontSizeForKeyword(CSSValueMedium, false, document()));
1952     fontDescription.setShouldAllowUserInstalledFonts(settings().shouldAllowUserInstalledFonts() ? AllowUserInstalledFonts::Yes : AllowUserInstalledFonts::No);
1953     fontDescription.setShouldAllowDesignSystemUIFonts(settings().shouldAllowDesignSystemUIFonts());
1954     setFontDescription(WTFMove(fontDescription));
1955 }
1956 
1957 void StyleResolver::setFontSize(FontCascadeDescription&amp; fontDescription, float size)
1958 {
1959     fontDescription.setSpecifiedSize(size);
1960     fontDescription.setComputedSize(Style::computedFontSizeFromSpecifiedSize(size, fontDescription.isAbsoluteSize(), useSVGZoomRules(), m_state.style(), document()));
1961 }
1962 
1963 bool StyleResolver::colorFromPrimitiveValueIsDerivedFromElement(const CSSPrimitiveValue&amp; value)
1964 {
1965     switch (value.valueID()) {
1966     case CSSValueWebkitText:
1967     case CSSValueWebkitLink:
1968     case CSSValueWebkitActivelink:
1969     case CSSValueCurrentcolor:
1970         return true;
1971     default:
1972         return false;
1973     }
1974 }
1975 
1976 Color StyleResolver::colorFromPrimitiveValue(const CSSPrimitiveValue&amp; value, bool forVisitedLink) const
1977 {
1978     if (value.isRGBColor())
1979         return value.color();
1980 
1981     auto identifier = value.valueID();
1982     switch (identifier) {
1983     case CSSValueWebkitText:
1984         return document().textColor();
1985     case CSSValueWebkitLink:
1986         return (m_state.element()-&gt;isLink() &amp;&amp; forVisitedLink) ? document().visitedLinkColor() : document().linkColor();
1987     case CSSValueWebkitActivelink:
1988         return document().activeLinkColor();
1989     case CSSValueWebkitFocusRingColor:
1990         return RenderTheme::singleton().focusRingColor(document().styleColorOptions(m_state.style()));
1991     case CSSValueCurrentcolor:
1992         // Color is an inherited property so depending on it effectively makes the property inherited.
1993         // FIXME: Setting the flag as a side effect of calling this function is a bit oblique. Can we do better?
1994         m_state.style()-&gt;setHasExplicitlyInheritedProperties();
1995         return m_state.style()-&gt;color();
1996     default:
1997         return StyleColor::colorFromKeyword(identifier, document().styleColorOptions(m_state.style()));
1998     }
1999 }
2000 
2001 void StyleResolver::addViewportDependentMediaQueryResult(const MediaQueryExpression&amp; expression, bool result)
2002 {
2003     m_viewportDependentMediaQueryResults.append(MediaQueryResult { expression, result });
2004 }
2005 
2006 bool StyleResolver::hasMediaQueriesAffectedByViewportChange() const
2007 {
2008     LOG(MediaQueries, &quot;StyleResolver::hasMediaQueriesAffectedByViewportChange evaluating queries&quot;);
2009     for (auto&amp; result : m_viewportDependentMediaQueryResults) {
2010         if (m_mediaQueryEvaluator.evaluate(result.expression) != result.result)
2011             return true;
2012     }
2013     return false;
2014 }
2015 
2016 void StyleResolver::addAccessibilitySettingsDependentMediaQueryResult(const MediaQueryExpression&amp; expression, bool result)
2017 {
2018     m_accessibilitySettingsDependentMediaQueryResults.append(MediaQueryResult { expression, result });
2019 }
2020 
2021 bool StyleResolver::hasMediaQueriesAffectedByAccessibilitySettingsChange() const
2022 {
2023     LOG(MediaQueries, &quot;StyleResolver::hasMediaQueriesAffectedByAccessibilitySettingsChange evaluating queries&quot;);
2024     for (auto&amp; result : m_accessibilitySettingsDependentMediaQueryResults) {
2025         if (m_mediaQueryEvaluator.evaluate(result.expression) != result.result)
2026             return true;
2027     }
2028     return false;
2029 }
2030 
2031 void StyleResolver::addAppearanceDependentMediaQueryResult(const MediaQueryExpression&amp; expression, bool result)
2032 {
2033     m_appearanceDependentMediaQueryResults.append(MediaQueryResult { expression, result });
2034 }
2035 
2036 bool StyleResolver::hasMediaQueriesAffectedByAppearanceChange() const
2037 {
2038     LOG(MediaQueries, &quot;StyleResolver::hasMediaQueriesAffectedByAppearanceChange evaluating queries&quot;);
2039     for (auto&amp; result : m_appearanceDependentMediaQueryResults) {
2040         if (m_mediaQueryEvaluator.evaluate(result.expression) != result.result)
2041             return true;
2042     }
2043     return false;
2044 }
2045 
2046 static FilterOperation::OperationType filterOperationForType(CSSValueID type)
2047 {
2048     switch (type) {
2049     case CSSValueUrl:
2050         return FilterOperation::REFERENCE;
2051     case CSSValueGrayscale:
2052         return FilterOperation::GRAYSCALE;
2053     case CSSValueSepia:
2054         return FilterOperation::SEPIA;
2055     case CSSValueSaturate:
2056         return FilterOperation::SATURATE;
2057     case CSSValueHueRotate:
2058         return FilterOperation::HUE_ROTATE;
2059     case CSSValueInvert:
2060         return FilterOperation::INVERT;
2061     case CSSValueAppleInvertLightness:
2062         return FilterOperation::APPLE_INVERT_LIGHTNESS;
2063     case CSSValueOpacity:
2064         return FilterOperation::OPACITY;
2065     case CSSValueBrightness:
2066         return FilterOperation::BRIGHTNESS;
2067     case CSSValueContrast:
2068         return FilterOperation::CONTRAST;
2069     case CSSValueBlur:
2070         return FilterOperation::BLUR;
2071     case CSSValueDropShadow:
2072         return FilterOperation::DROP_SHADOW;
2073     default:
2074         break;
2075     }
2076     ASSERT_NOT_REACHED();
2077     return FilterOperation::NONE;
2078 }
2079 
2080 bool StyleResolver::createFilterOperations(const CSSValue&amp; inValue, FilterOperations&amp; outOperations)
2081 {
2082     State&amp; state = m_state;
2083     ASSERT(outOperations.isEmpty());
2084 
2085     if (is&lt;CSSPrimitiveValue&gt;(inValue)) {
2086         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(inValue);
2087         if (primitiveValue.valueID() == CSSValueNone)
2088             return true;
2089     }
2090 
2091     if (!is&lt;CSSValueList&gt;(inValue))
2092         return false;
2093 
2094     FilterOperations operations;
2095     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(inValue)) {
2096 
2097         if (is&lt;CSSPrimitiveValue&gt;(currentValue)) {
2098             auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(currentValue.get());
2099             if (!primitiveValue.isURI())
2100                 continue;
2101 
2102             String cssUrl = primitiveValue.stringValue();
2103             URL url = document().completeURL(cssUrl);
2104 
2105             auto operation = ReferenceFilterOperation::create(cssUrl, url.fragmentIdentifier());
2106             operations.operations().append(WTFMove(operation));
2107             continue;
2108         }
2109 
2110         if (!is&lt;CSSFunctionValue&gt;(currentValue))
2111             continue;
2112 
2113         auto&amp; filterValue = downcast&lt;CSSFunctionValue&gt;(currentValue.get());
2114         FilterOperation::OperationType operationType = filterOperationForType(filterValue.name());
2115 
2116         // Check that all parameters are primitive values, with the
2117         // exception of drop shadow which has a CSSShadowValue parameter.
2118         const CSSPrimitiveValue* firstValue = nullptr;
2119         if (operationType != FilterOperation::DROP_SHADOW) {
2120             bool haveNonPrimitiveValue = false;
2121             for (unsigned j = 0; j &lt; filterValue.length(); ++j) {
2122                 if (!is&lt;CSSPrimitiveValue&gt;(*filterValue.itemWithoutBoundsCheck(j))) {
2123                     haveNonPrimitiveValue = true;
2124                     break;
2125                 }
2126             }
2127             if (haveNonPrimitiveValue)
2128                 continue;
2129             if (filterValue.length())
2130                 firstValue = downcast&lt;CSSPrimitiveValue&gt;(filterValue.itemWithoutBoundsCheck(0));
2131         }
2132 
2133         switch (operationType) {
2134         case FilterOperation::GRAYSCALE:
2135         case FilterOperation::SEPIA:
2136         case FilterOperation::SATURATE: {
2137             double amount = 1;
2138             if (filterValue.length() == 1) {
2139                 amount = firstValue-&gt;doubleValue();
2140                 if (firstValue-&gt;isPercentage())
2141                     amount /= 100;
2142             }
2143 
2144             operations.operations().append(BasicColorMatrixFilterOperation::create(amount, operationType));
2145             break;
2146         }
2147         case FilterOperation::HUE_ROTATE: {
2148             double angle = 0;
2149             if (filterValue.length() == 1)
2150                 angle = firstValue-&gt;computeDegrees();
2151 
2152             operations.operations().append(BasicColorMatrixFilterOperation::create(angle, operationType));
2153             break;
2154         }
2155         case FilterOperation::INVERT:
2156         case FilterOperation::BRIGHTNESS:
2157         case FilterOperation::CONTRAST:
2158         case FilterOperation::OPACITY: {
2159             double amount = 1;
2160             if (filterValue.length() == 1) {
2161                 amount = firstValue-&gt;doubleValue();
2162                 if (firstValue-&gt;isPercentage())
2163                     amount /= 100;
2164             }
2165 
2166             operations.operations().append(BasicComponentTransferFilterOperation::create(amount, operationType));
2167             break;
2168         }
2169         case FilterOperation::APPLE_INVERT_LIGHTNESS: {
2170             operations.operations().append(InvertLightnessFilterOperation::create());
2171             break;
2172         }
2173         case FilterOperation::BLUR: {
2174             Length stdDeviation = Length(0, Fixed);
2175             if (filterValue.length() &gt;= 1)
2176                 stdDeviation = convertToFloatLength(firstValue, state.cssToLengthConversionData());
2177             if (stdDeviation.isUndefined())
2178                 return false;
2179 
2180             operations.operations().append(BlurFilterOperation::create(stdDeviation));
2181             break;
2182         }
2183         case FilterOperation::DROP_SHADOW: {
2184             if (filterValue.length() != 1)
2185                 return false;
2186 
2187             const auto* cssValue = filterValue.itemWithoutBoundsCheck(0);
2188             if (!is&lt;CSSShadowValue&gt;(cssValue))
2189                 continue;
2190 
2191             const auto&amp; item = downcast&lt;CSSShadowValue&gt;(*cssValue);
2192             int x = item.x-&gt;computeLength&lt;int&gt;(state.cssToLengthConversionData());
2193             int y = item.y-&gt;computeLength&lt;int&gt;(state.cssToLengthConversionData());
2194             IntPoint location(x, y);
2195             int blur = item.blur ? item.blur-&gt;computeLength&lt;int&gt;(state.cssToLengthConversionData()) : 0;
2196             Color color;
2197             if (item.color)
2198                 color = colorFromPrimitiveValue(*item.color);
2199 
2200             operations.operations().append(DropShadowFilterOperation::create(location, blur, color.isValid() ? color : Color::transparent));
2201             break;
2202         }
2203         default:
2204             ASSERT_NOT_REACHED();
2205             break;
2206         }
2207     }
2208 
2209     outOperations = operations;
2210     return true;
2211 }
2212 
2213 inline StyleResolver::MatchedProperties::MatchedProperties() = default;
2214 
2215 StyleResolver::MatchedProperties::~MatchedProperties() = default;
2216 
2217 StyleResolver::CascadedProperties::CascadedProperties(TextDirection direction, WritingMode writingMode)
2218     : m_direction(direction)
2219     , m_writingMode(writingMode)
2220 {
2221 }
2222 
2223 inline bool StyleResolver::CascadedProperties::hasProperty(CSSPropertyID id) const
2224 {
2225     ASSERT(id &lt; m_propertyIsPresent.size());
2226     return m_propertyIsPresent[id];
2227 }
2228 
2229 inline StyleResolver::CascadedProperties::Property&amp; StyleResolver::CascadedProperties::property(CSSPropertyID id)
2230 {
2231     return m_properties[id];
2232 }
2233 
2234 inline bool StyleResolver::CascadedProperties::hasCustomProperty(const String&amp; name) const
2235 {
2236     return m_customProperties.contains(name);
2237 }
2238 
2239 inline StyleResolver::CascadedProperties::Property StyleResolver::CascadedProperties::customProperty(const String&amp; name) const
2240 {
2241     return m_customProperties.get(name);
2242 }
2243 
2244 void StyleResolver::CascadedProperties::setPropertyInternal(Property&amp; property, CSSPropertyID id, CSSValue&amp; cssValue, unsigned linkMatchType, CascadeLevel cascadeLevel, Style::ScopeOrdinal styleScopeOrdinal)
2245 {
2246     ASSERT(linkMatchType &lt;= SelectorChecker::MatchAll);
2247     property.id = id;
2248     property.level = cascadeLevel;
2249     property.styleScopeOrdinal = styleScopeOrdinal;
2250     if (linkMatchType == SelectorChecker::MatchAll) {
2251         property.cssValue[0] = &amp;cssValue;
2252         property.cssValue[SelectorChecker::MatchLink] = &amp;cssValue;
2253         property.cssValue[SelectorChecker::MatchVisited] = &amp;cssValue;
2254     } else
2255         property.cssValue[linkMatchType] = &amp;cssValue;
2256 }
2257 
2258 void StyleResolver::CascadedProperties::set(CSSPropertyID id, CSSValue&amp; cssValue, unsigned linkMatchType, CascadeLevel cascadeLevel, Style::ScopeOrdinal styleScopeOrdinal)
2259 {
2260     if (CSSProperty::isDirectionAwareProperty(id))
2261         id = CSSProperty::resolveDirectionAwareProperty(id, m_direction, m_writingMode);
2262 
2263     ASSERT(!shouldApplyPropertyInParseOrder(id));
2264 
2265     auto&amp; property = m_properties[id];
2266     ASSERT(id &lt; m_propertyIsPresent.size());
2267     if (id == CSSPropertyCustom) {
2268         m_propertyIsPresent.set(id);
2269         const auto&amp; customValue = downcast&lt;CSSCustomPropertyValue&gt;(cssValue);
2270         bool hasValue = customProperties().contains(customValue.name());
2271         if (!hasValue) {
2272             Property property;
2273             property.id = id;
2274             memset(property.cssValue, 0, sizeof(property.cssValue));
2275             setPropertyInternal(property, id, cssValue, linkMatchType, cascadeLevel, styleScopeOrdinal);
2276             customProperties().set(customValue.name(), property);
2277         } else {
2278             Property property = customProperties().get(customValue.name());
2279             setPropertyInternal(property, id, cssValue, linkMatchType, cascadeLevel, styleScopeOrdinal);
2280             customProperties().set(customValue.name(), property);
2281         }
2282         return;
2283     }
2284 
2285     if (!m_propertyIsPresent[id])
2286         memset(property.cssValue, 0, sizeof(property.cssValue));
2287     m_propertyIsPresent.set(id);
2288     setPropertyInternal(property, id, cssValue, linkMatchType, cascadeLevel, styleScopeOrdinal);
2289 }
2290 
2291 void StyleResolver::CascadedProperties::setDeferred(CSSPropertyID id, CSSValue&amp; cssValue, unsigned linkMatchType, CascadeLevel cascadeLevel, Style::ScopeOrdinal styleScopeOrdinal)
2292 {
2293     ASSERT(!CSSProperty::isDirectionAwareProperty(id));
2294     ASSERT(shouldApplyPropertyInParseOrder(id));
2295 
2296     Property property;
2297     memset(property.cssValue, 0, sizeof(property.cssValue));
2298     setPropertyInternal(property, id, cssValue, linkMatchType, cascadeLevel, styleScopeOrdinal);
2299     m_deferredProperties.append(property);
2300 }
2301 
2302 static CascadeLevel cascadeLevelForIndex(const StyleResolver::MatchResult&amp; matchResult, int index)
2303 {
2304     if (index &gt;= matchResult.ranges.firstUARule &amp;&amp; index &lt;= matchResult.ranges.lastUARule)
2305         return CascadeLevel::UserAgentLevel;
2306     if (index &gt;= matchResult.ranges.firstUserRule &amp;&amp; index &lt;= matchResult.ranges.lastUserRule)
2307         return CascadeLevel::UserLevel;
2308     return CascadeLevel::AuthorLevel;
2309 }
2310 
2311 void StyleResolver::CascadedProperties::addMatch(const MatchResult&amp; matchResult, unsigned index, bool isImportant, bool inheritedOnly)
2312 {
2313     auto&amp; matchedProperties = matchResult.matchedProperties()[index];
2314     auto&amp; styleProperties = *matchedProperties.properties;
2315 
2316     auto propertyWhitelistType = static_cast&lt;PropertyWhitelistType&gt;(matchedProperties.whitelistType);
2317     auto cascadeLevel = cascadeLevelForIndex(matchResult, index);
2318 
2319     for (unsigned i = 0, count = styleProperties.propertyCount(); i &lt; count; ++i) {
2320         auto current = styleProperties.propertyAt(i);
2321         if (isImportant != current.isImportant())
2322             continue;
2323         if (inheritedOnly &amp;&amp; !current.isInherited()) {
2324             // We apply the inherited properties only when using the property cache.
2325             // A match with a value that is explicitely inherited should never have been cached.
2326             ASSERT(!current.value()-&gt;isInheritedValue());
2327             continue;
2328         }
2329         CSSPropertyID propertyID = current.id();
2330 
2331 #if ENABLE(VIDEO_TRACK)
2332         if (propertyWhitelistType == PropertyWhitelistCue &amp;&amp; !isValidCueStyleProperty(propertyID))
2333             continue;
2334 #endif
2335         if (propertyWhitelistType == PropertyWhitelistMarker &amp;&amp; !isValidMarkerStyleProperty(propertyID))
2336             continue;
2337 
2338         if (shouldApplyPropertyInParseOrder(propertyID))
2339             setDeferred(propertyID, *current.value(), matchedProperties.linkMatchType, cascadeLevel, matchedProperties.styleScopeOrdinal);
2340         else
2341             set(propertyID, *current.value(), matchedProperties.linkMatchType, cascadeLevel, matchedProperties.styleScopeOrdinal);
2342     }
2343 }
2344 
2345 void StyleResolver::CascadedProperties::addNormalMatches(const MatchResult&amp; matchResult, int startIndex, int endIndex, bool inheritedOnly)
2346 {
2347     if (startIndex == -1)
2348         return;
2349 
2350     for (int i = startIndex; i &lt;= endIndex; ++i)
2351         addMatch(matchResult, i, false, inheritedOnly);
2352 }
2353 
2354 static bool hasImportantProperties(const StyleProperties&amp; properties)
2355 {
2356     for (unsigned i = 0, count = properties.propertyCount(); i &lt; count; ++i) {
2357         if (properties.propertyAt(i).isImportant())
2358             return true;
2359     }
2360     return false;
2361 }
2362 
2363 void StyleResolver::CascadedProperties::addImportantMatches(const MatchResult&amp; matchResult, int startIndex, int endIndex, bool inheritedOnly)
2364 {
2365     if (startIndex == -1)
2366         return;
2367 
2368     struct IndexAndOrdinal {
2369         int index;
2370         Style::ScopeOrdinal ordinal;
2371     };
2372     Vector&lt;IndexAndOrdinal&gt; shadowTreeMatches;
2373 
2374     for (int i = startIndex; i &lt;= endIndex; ++i) {
2375         const MatchedProperties&amp; matchedProperties = matchResult.matchedProperties()[i];
2376 
2377         if (!hasImportantProperties(*matchedProperties.properties))
2378             continue;
2379 
2380         if (matchedProperties.styleScopeOrdinal != Style::ScopeOrdinal::Element) {
2381             shadowTreeMatches.append({ i, matchedProperties.styleScopeOrdinal });
2382             continue;
2383         }
2384 
2385         addMatch(matchResult, i, true, inheritedOnly);
2386     }
2387 
2388     if (shadowTreeMatches.isEmpty())
2389         return;
2390 
2391     // For !important properties a later shadow tree wins.
2392     // Match results are sorted in reverse tree context order so this is not needed for normal properties.
2393     std::stable_sort(shadowTreeMatches.begin(), shadowTreeMatches.end(), [] (const IndexAndOrdinal&amp; a, const IndexAndOrdinal&amp; b) {
2394         return a.ordinal &lt; b.ordinal;
2395     });
2396 
2397     for (auto&amp; match : shadowTreeMatches)
2398         addMatch(matchResult, match.index, true, inheritedOnly);
2399 }
2400 
2401 void StyleResolver::CascadedProperties::applyDeferredProperties(StyleResolver&amp; resolver, ApplyCascadedPropertyState&amp; applyState)
2402 {
2403     for (auto&amp; property : m_deferredProperties)
2404         property.apply(resolver, applyState);
2405 }
2406 
2407 void StyleResolver::CascadedProperties::Property::apply(StyleResolver&amp; resolver, ApplyCascadedPropertyState&amp; applyState)
2408 {
2409     State&amp; state = resolver.state();
2410     state.setCascadeLevel(level);
2411     state.setStyleScopeOrdinal(styleScopeOrdinal);
2412 
2413     if (cssValue[SelectorChecker::MatchDefault]) {
2414         state.setApplyPropertyToRegularStyle(true);
2415         state.setApplyPropertyToVisitedLinkStyle(false);
2416         resolver.applyProperty(id, cssValue[SelectorChecker::MatchDefault], applyState, SelectorChecker::MatchDefault);
2417     }
2418 
2419     if (state.style()-&gt;insideLink() == InsideLink::NotInside)
2420         return;
2421 
2422     if (cssValue[SelectorChecker::MatchLink]) {
2423         state.setApplyPropertyToRegularStyle(true);
2424         state.setApplyPropertyToVisitedLinkStyle(false);
2425         resolver.applyProperty(id, cssValue[SelectorChecker::MatchLink], applyState, SelectorChecker::MatchLink);
2426     }
2427 
2428     if (cssValue[SelectorChecker::MatchVisited]) {
2429         state.setApplyPropertyToRegularStyle(false);
2430         state.setApplyPropertyToVisitedLinkStyle(true);
2431         resolver.applyProperty(id, cssValue[SelectorChecker::MatchVisited], applyState, SelectorChecker::MatchVisited);
2432     }
2433 
2434     state.setApplyPropertyToRegularStyle(true);
2435     state.setApplyPropertyToVisitedLinkStyle(false);
2436 }
2437 
2438 void StyleResolver::applyCascadedCustomProperty(const String&amp; name, ApplyCascadedPropertyState&amp; state)
2439 {
2440     if (state.appliedCustomProperties.contains(name) || !state.cascade-&gt;customProperties().contains(name))
2441         return;
2442 
2443     auto property = state.cascade-&gt;customProperties().get(name);
2444     bool inCycle = state.inProgressPropertiesCustom.contains(name);
2445 
2446     for (auto index : { SelectorChecker::MatchDefault, SelectorChecker::MatchLink, SelectorChecker::MatchVisited }) {
2447         if (!property.cssValue[index])
2448             continue;
2449         if (index != SelectorChecker::MatchDefault &amp;&amp; this-&gt;state().style()-&gt;insideLink() == InsideLink::NotInside)
2450             continue;
2451 
2452         Ref&lt;CSSCustomPropertyValue&gt; valueToApply = CSSCustomPropertyValue::create(downcast&lt;CSSCustomPropertyValue&gt;(*property.cssValue[index]));
2453 
2454         if (inCycle) {
2455             state.appliedCustomProperties.add(name); // Make sure we do not try to apply this property again while resolving it.
2456             valueToApply = CSSCustomPropertyValue::createWithID(name, CSSValueInvalid);
2457         }
2458 
2459         state.inProgressPropertiesCustom.add(name);
2460 
2461         if (WTF::holds_alternative&lt;Ref&lt;CSSVariableReferenceValue&gt;&gt;(valueToApply-&gt;value())) {
2462             RefPtr&lt;CSSValue&gt; parsedValue = resolvedVariableValue(CSSPropertyCustom, valueToApply.get(), state);
2463 
2464             if (state.appliedCustomProperties.contains(name))
2465                 return; // There was a cycle and the value was reset, so bail.
2466 
2467             if (!parsedValue)
2468                 parsedValue = CSSCustomPropertyValue::createWithID(name, CSSValueUnset);
2469 
2470             valueToApply = downcast&lt;CSSCustomPropertyValue&gt;(*parsedValue);
2471         }
2472 
2473         if (state.inProgressPropertiesCustom.contains(name)) {
2474             if (index == SelectorChecker::MatchDefault) {
2475                 this-&gt;state().setApplyPropertyToRegularStyle(true);
2476                 this-&gt;state().setApplyPropertyToVisitedLinkStyle(false);
2477             }
2478 
2479             if (index == SelectorChecker::MatchLink) {
2480                 this-&gt;state().setApplyPropertyToRegularStyle(true);
2481                 this-&gt;state().setApplyPropertyToVisitedLinkStyle(false);
2482             }
2483 
2484             if (index == SelectorChecker::MatchVisited) {
2485                 this-&gt;state().setApplyPropertyToRegularStyle(false);
2486                 this-&gt;state().setApplyPropertyToVisitedLinkStyle(true);
2487             }
2488             applyProperty(CSSPropertyCustom, valueToApply.ptr(), state, index);
2489         }
2490     }
2491 
2492     state.inProgressPropertiesCustom.remove(name);
2493     state.appliedCustomProperties.add(name);
2494 
2495     for (auto index : { SelectorChecker::MatchDefault, SelectorChecker::MatchLink, SelectorChecker::MatchVisited }) {
2496         if (!property.cssValue[index])
2497             continue;
2498         if (index != SelectorChecker::MatchDefault &amp;&amp; this-&gt;state().style()-&gt;insideLink() == InsideLink::NotInside)
2499             continue;
2500 
2501         Ref&lt;CSSCustomPropertyValue&gt; valueToApply = CSSCustomPropertyValue::create(downcast&lt;CSSCustomPropertyValue&gt;(*property.cssValue[index]));
2502 
2503         if (inCycle &amp;&amp; WTF::holds_alternative&lt;Ref&lt;CSSVariableReferenceValue&gt;&gt;(valueToApply-&gt;value())) {
2504             // Resolve this value so that we reset its dependencies.
2505             resolvedVariableValue(CSSPropertyCustom, valueToApply.get(), state);
2506         }
2507     }
2508 }
2509 
2510 void StyleResolver::applyCascadedProperties(int firstProperty, int lastProperty, ApplyCascadedPropertyState&amp; state)
2511 {
2512     if (LIKELY(state.cascade-&gt;customProperties().isEmpty()))
2513         return applyCascadedPropertiesImpl&lt;CustomPropertyCycleTracking::Disabled&gt;(firstProperty, lastProperty, state);
2514     return applyCascadedPropertiesImpl&lt;CustomPropertyCycleTracking::Enabled&gt;(firstProperty, lastProperty, state);
2515 }
2516 
2517 template&lt;StyleResolver::CustomPropertyCycleTracking TrackCycles&gt;
2518 inline void StyleResolver::applyCascadedPropertiesImpl(int firstProperty, int lastProperty, ApplyCascadedPropertyState&amp; state)
2519 {
2520     for (int id = firstProperty; id &lt;= lastProperty; ++id) {
2521         CSSPropertyID propertyID = static_cast&lt;CSSPropertyID&gt;(id);
2522         if (!state.cascade-&gt;hasProperty(propertyID))
2523             continue;
2524         ASSERT(propertyID != CSSPropertyCustom);
2525         auto&amp; property = state.cascade-&gt;property(propertyID);
2526         ASSERT(!shouldApplyPropertyInParseOrder(propertyID));
2527 
2528         if (TrackCycles == CustomPropertyCycleTracking::Disabled) {
2529             // If we don&#39;t have any custom properties, then there can&#39;t be any cycles.
2530             property.apply(*this, state);
2531         } else {
2532             if (UNLIKELY(state.inProgressProperties.get(propertyID))) {
2533                 // We are in a cycle (eg. setting font size using registered custom property value containing em).
2534                 // So this value should be unset.
2535                 state.appliedProperties.set(propertyID);
2536                 // This property is in a cycle, and only the root of the call stack will have firstProperty != lastProperty.
2537                 ASSERT(firstProperty == lastProperty);
2538                 continue;
2539             }
2540 
2541             state.inProgressProperties.set(propertyID);
2542             property.apply(*this, state);
2543             state.appliedProperties.set(propertyID);
2544             state.inProgressProperties.set(propertyID, false);
2545         }
2546     }
2547 }
2548 
2549 } // namespace WebCore
    </pre>
  </body>
</html>