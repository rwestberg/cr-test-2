<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrJIT.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="YarrInterpreter.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="YarrJIT.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrJIT.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 70,17 ***</span>
      static const RegisterID regT2 = ARM64Registers::x8;
      static const RegisterID remainingMatchCount = ARM64Registers::x9;
      static const RegisterID regUnicodeInputAndTrail = ARM64Registers::x10;
      static const RegisterID initialStart = ARM64Registers::x11;
      static const RegisterID supplementaryPlanesBase = ARM64Registers::x12;
<span class="line-modified">!     static const RegisterID surrogateTagMask = ARM64Registers::x13;</span>
<span class="line-modified">!     static const RegisterID leadingSurrogateTag = ARM64Registers::x14;</span>
<span class="line-modified">!     static const RegisterID trailingSurrogateTag = ARM64Registers::x15;</span>
  
      static const RegisterID returnRegister = ARM64Registers::x0;
      static const RegisterID returnRegister2 = ARM64Registers::x1;
  
  #define HAVE_INITIAL_START_REG
  #define JIT_UNICODE_EXPRESSIONS
  #elif CPU(MIPS)
      static const RegisterID input = MIPSRegisters::a0;
      static const RegisterID index = MIPSRegisters::a1;
<span class="line-new-header">--- 70,18 ---</span>
      static const RegisterID regT2 = ARM64Registers::x8;
      static const RegisterID remainingMatchCount = ARM64Registers::x9;
      static const RegisterID regUnicodeInputAndTrail = ARM64Registers::x10;
      static const RegisterID initialStart = ARM64Registers::x11;
      static const RegisterID supplementaryPlanesBase = ARM64Registers::x12;
<span class="line-modified">!     static const RegisterID leadingSurrogateTag = ARM64Registers::x13;</span>
<span class="line-modified">!     static const RegisterID trailingSurrogateTag = ARM64Registers::x14;</span>
<span class="line-modified">!     static const RegisterID endOfStringAddress = ARM64Registers::x15;</span>
  
      static const RegisterID returnRegister = ARM64Registers::x0;
      static const RegisterID returnRegister2 = ARM64Registers::x1;
  
<span class="line-added">+     const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);</span>
  #define HAVE_INITIAL_START_REG
  #define JIT_UNICODE_EXPRESSIONS
  #elif CPU(MIPS)
      static const RegisterID input = MIPSRegisters::a0;
      static const RegisterID index = MIPSRegisters::a1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,16 ***</span>
  #else
      static const RegisterID remainingMatchCount = X86Registers::esi;
  #endif
      static const RegisterID regUnicodeInputAndTrail = X86Registers::r13;
      static const RegisterID leadingSurrogateTag = X86Registers::r14;
<span class="line-modified">!     static const RegisterID trailingSurrogateTag = X86Registers::r15;</span>
  
      static const RegisterID returnRegister = X86Registers::eax;
      static const RegisterID returnRegister2 = X86Registers::edx;
  
      const TrustedImm32 supplementaryPlanesBase = TrustedImm32(0x10000);
      const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);
  #define HAVE_INITIAL_START_REG
  #define JIT_UNICODE_EXPRESSIONS
  #endif
  
<span class="line-new-header">--- 142,17 ---</span>
  #else
      static const RegisterID remainingMatchCount = X86Registers::esi;
  #endif
      static const RegisterID regUnicodeInputAndTrail = X86Registers::r13;
      static const RegisterID leadingSurrogateTag = X86Registers::r14;
<span class="line-modified">!     static const RegisterID endOfStringAddress = X86Registers::r15;</span>
  
      static const RegisterID returnRegister = X86Registers::eax;
      static const RegisterID returnRegister2 = X86Registers::edx;
  
      const TrustedImm32 supplementaryPlanesBase = TrustedImm32(0x10000);
<span class="line-added">+     const TrustedImm32 trailingSurrogateTag = TrustedImm32(0xdc00);</span>
      const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);
  #define HAVE_INITIAL_START_REG
  #define JIT_UNICODE_EXPRESSIONS
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 224,13 ***</span>
  
          size_t parenContextSize = ParenContext::sizeFor(m_parenContextSizes);
  
          parenContextSize = WTF::roundUpToMultipleOf&lt;sizeof(uintptr_t)&gt;(parenContextSize);
  
<span class="line-modified">!         // Check that the paren context is a reasonable size.</span>
<span class="line-modified">!         if (parenContextSize &gt; INT16_MAX)</span>
<span class="line-modified">!             m_abortExecution.append(jump());</span>
  
          Jump emptyFreeList = branchTestPtr(Zero, freelistRegister);
          move(freelistRegister, parenContextPointer);
          addPtr(TrustedImm32(parenContextSize), freelistRegister, nextParenContextPointer);
          addPtr(freelistRegister, freelistSizeRegister);
<span class="line-new-header">--- 226,14 ---</span>
  
          size_t parenContextSize = ParenContext::sizeFor(m_parenContextSizes);
  
          parenContextSize = WTF::roundUpToMultipleOf&lt;sizeof(uintptr_t)&gt;(parenContextSize);
  
<span class="line-modified">!         if (parenContextSize &gt; VM::patternContextBufferSize) {</span>
<span class="line-modified">!             m_failureReason = JITFailureReason::ParenthesisNestedTooDeep;</span>
<span class="line-modified">!             return;</span>
<span class="line-added">+         }</span>
  
          Jump emptyFreeList = branchTestPtr(Zero, freelistRegister);
          move(freelistRegister, parenContextPointer);
          addPtr(TrustedImm32(parenContextSize), freelistRegister, nextParenContextPointer);
          addPtr(freelistRegister, freelistSizeRegister);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 317,11 ***</span>
              PatternTerm&amp; nextTerm = alternative-&gt;m_terms[i + 1];
  
              // We can move BMP only character classes after fixed character terms.
              if ((term.type == PatternTerm::TypeCharacterClass)
                  &amp;&amp; (term.quantityType == QuantifierFixedCount)
<span class="line-modified">!                 &amp;&amp; (!m_decodeSurrogatePairs || (!term.characterClass-&gt;m_hasNonBMPCharacters &amp;&amp; !term.m_invert))</span>
                  &amp;&amp; (nextTerm.type == PatternTerm::TypePatternCharacter)
                  &amp;&amp; (nextTerm.quantityType == QuantifierFixedCount)) {
                  PatternTerm termCopy = term;
                  alternative-&gt;m_terms[i] = nextTerm;
                  alternative-&gt;m_terms[i + 1] = termCopy;
<span class="line-new-header">--- 320,11 ---</span>
              PatternTerm&amp; nextTerm = alternative-&gt;m_terms[i + 1];
  
              // We can move BMP only character classes after fixed character terms.
              if ((term.type == PatternTerm::TypeCharacterClass)
                  &amp;&amp; (term.quantityType == QuantifierFixedCount)
<span class="line-modified">!                 &amp;&amp; (!m_decodeSurrogatePairs || (term.characterClass-&gt;hasOneCharacterSize() &amp;&amp; !term.m_invert))</span>
                  &amp;&amp; (nextTerm.type == PatternTerm::TypePatternCharacter)
                  &amp;&amp; (nextTerm.quantityType == QuantifierFixedCount)) {
                  PatternTerm termCopy = term;
                  alternative-&gt;m_terms[i] = nextTerm;
                  alternative-&gt;m_terms[i + 1] = termCopy;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 381,10 ***</span>
<span class="line-new-header">--- 384,11 ---</span>
          if (charClass-&gt;m_table &amp;&amp; !m_decodeSurrogatePairs) {
              ExtendedAddress tableEntry(character, reinterpret_cast&lt;intptr_t&gt;(charClass-&gt;m_table));
              matchDest.append(branchTest8(charClass-&gt;m_tableInverted ? Zero : NonZero, tableEntry));
              return;
          }
<span class="line-added">+ </span>
          JumpList unicodeFail;
          if (charClass-&gt;m_matchesUnicode.size() || charClass-&gt;m_rangesUnicode.size()) {
              JumpList isAscii;
              if (charClass-&gt;m_matches.size() || charClass-&gt;m_ranges.size())
                  isAscii.append(branch32(LessThanOrEqual, character, TrustedImm32(0x7f)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 446,10 ***</span>
<span class="line-new-header">--- 450,27 ---</span>
  
          if (charClass-&gt;m_matchesUnicode.size() || charClass-&gt;m_rangesUnicode.size())
              unicodeFail.link(this);
      }
  
<span class="line-added">+ #ifdef JIT_UNICODE_EXPRESSIONS</span>
<span class="line-added">+     void advanceIndexAfterCharacterClassTermMatch(const PatternTerm* term, JumpList&amp; failuresAfterIncrementingIndex, const RegisterID character)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ASSERT(term-&gt;type == PatternTerm::TypeCharacterClass);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (term-&gt;isFixedWidthCharacterClass())</span>
<span class="line-added">+             add32(TrustedImm32(term-&gt;characterClass-&gt;hasNonBMPCharacters() ? 2 : 1), index);</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             add32(TrustedImm32(1), index);</span>
<span class="line-added">+             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="line-added">+             failuresAfterIncrementingIndex.append(atEndOfInput());</span>
<span class="line-added">+             add32(TrustedImm32(1), index);</span>
<span class="line-added">+             isBMPChar.link(this);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      // Jumps if input not available; will have (incorrectly) incremented already!
      Jump jumpIfNoAvailableInput(unsigned countToCheck = 0)
      {
          if (countToCheck)
              add32(Imm32(countToCheck), index);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 518,16 ***</span>
      void tryReadUnicodeCharImpl(RegisterID resultReg)
      {
          ASSERT(m_charSize == Char16);
  
          JumpList notUnicode;
          load16Unaligned(regUnicodeInputAndTrail, resultReg);
          and32(surrogateTagMask, resultReg, regT2);
          notUnicode.append(branch32(NotEqual, regT2, leadingSurrogateTag));
          addPtr(TrustedImm32(2), regUnicodeInputAndTrail);
<span class="line-modified">!         getEffectiveAddress(BaseIndex(input, length, TimesTwo), regT2);</span>
<span class="line-removed">-         notUnicode.append(branch32(AboveOrEqual, regUnicodeInputAndTrail, regT2));</span>
          load16Unaligned(Address(regUnicodeInputAndTrail), regUnicodeInputAndTrail);
          and32(surrogateTagMask, regUnicodeInputAndTrail, regT2);
          notUnicode.append(branch32(NotEqual, regT2, trailingSurrogateTag));
          sub32(leadingSurrogateTag, resultReg);
          sub32(trailingSurrogateTag, regUnicodeInputAndTrail);
<span class="line-new-header">--- 539,16 ---</span>
      void tryReadUnicodeCharImpl(RegisterID resultReg)
      {
          ASSERT(m_charSize == Char16);
  
          JumpList notUnicode;
<span class="line-added">+ </span>
          load16Unaligned(regUnicodeInputAndTrail, resultReg);
          and32(surrogateTagMask, resultReg, regT2);
          notUnicode.append(branch32(NotEqual, regT2, leadingSurrogateTag));
          addPtr(TrustedImm32(2), regUnicodeInputAndTrail);
<span class="line-modified">!         notUnicode.append(branchPtr(AboveOrEqual, regUnicodeInputAndTrail, endOfStringAddress));</span>
          load16Unaligned(Address(regUnicodeInputAndTrail), regUnicodeInputAndTrail);
          and32(surrogateTagMask, regUnicodeInputAndTrail, regT2);
          notUnicode.append(branch32(NotEqual, regT2, trailingSurrogateTag));
          sub32(leadingSurrogateTag, resultReg);
          sub32(trailingSurrogateTag, regUnicodeInputAndTrail);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 616,11 ***</span>
          peek(reg, frameLocation);
      }
  
      void loadFromFrameAndJump(unsigned frameLocation)
      {
<span class="line-modified">!         jump(Address(stackPointerRegister, frameLocation * sizeof(void*)), YarrBacktrackPtrTag);</span>
      }
  
      unsigned alignCallFrameSizeInBytes(unsigned callFrameSize)
      {
          if (!callFrameSize)
<span class="line-new-header">--- 637,11 ---</span>
          peek(reg, frameLocation);
      }
  
      void loadFromFrameAndJump(unsigned frameLocation)
      {
<span class="line-modified">!         farJump(Address(stackPointerRegister, frameLocation * sizeof(void*)), YarrBacktrackPtrTag);</span>
      }
  
      unsigned alignCallFrameSizeInBytes(unsigned callFrameSize)
      {
          if (!callFrameSize)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 748,11 ***</span>
              load32(output, reg);
          else
              move(output, reg);
      }
  
<span class="line-modified">!     enum YarrOpCode {</span>
          // These nodes wrap body alternatives - those in the main disjunction,
          // rather than subpatterns or assertions. These are chained together in
          // a doubly linked list, with a &#39;begin&#39; node for the first alternative,
          // a &#39;next&#39; node for each subsequent alternative, and an &#39;end&#39; node at
          // the end. In the case of repeating alternatives, the &#39;end&#39; node also
<span class="line-new-header">--- 769,11 ---</span>
              load32(output, reg);
          else
              move(output, reg);
      }
  
<span class="line-modified">!     enum YarrOpCode : uint8_t {</span>
          // These nodes wrap body alternatives - those in the main disjunction,
          // rather than subpatterns or assertions. These are chained together in
          // a doubly linked list, with a &#39;begin&#39; node for the first alternative,
          // a &#39;next&#39; node for each subsequent alternative, and an &#39;end&#39; node at
          // the end. In the case of repeating alternatives, the &#39;end&#39; node also
</pre>
<hr />
<pre>
<span class="line-old-header">*** 794,35 ***</span>
      // This structure is used to hold the compiled opcode information,
      // including reference back to the original PatternTerm/PatternAlternatives,
      // and JIT compilation data structures.
      struct YarrOp {
          explicit YarrOp(PatternTerm* term)
<span class="line-modified">!             : m_op(OpTerm)</span>
<span class="line-modified">!             , m_term(term)</span>
              , m_isDeadCode(false)
          {
          }
  
          explicit YarrOp(YarrOpCode op)
              : m_op(op)
              , m_isDeadCode(false)
          {
          }
  
<span class="line-removed">-         // The operation, as a YarrOpCode, and also a reference to the PatternTerm.</span>
<span class="line-removed">-         YarrOpCode m_op;</span>
<span class="line-removed">-         PatternTerm* m_term;</span>
<span class="line-removed">- </span>
          // For alternatives, this holds the PatternAlternative and doubly linked
          // references to this alternative&#39;s siblings. In the case of the
          // OpBodyAlternativeEnd node at the end of a section of repeating nodes,
          // m_nextOp will reference the OpBodyAlternativeBegin node of the first
          // repeating alternative.
          PatternAlternative* m_alternative;
          size_t m_previousOp;
          size_t m_nextOp;
  
          // Used to record a set of Jumps out of the generated code, typically
          // used for jumps out to backtracking code, and a single reentry back
          // into the code for a node (likely where a backtrack will trigger
          // rematching).
          Label m_reentry;
<span class="line-new-header">--- 815,35 ---</span>
      // This structure is used to hold the compiled opcode information,
      // including reference back to the original PatternTerm/PatternAlternatives,
      // and JIT compilation data structures.
      struct YarrOp {
          explicit YarrOp(PatternTerm* term)
<span class="line-modified">!             : m_term(term)</span>
<span class="line-modified">!             , m_op(OpTerm)</span>
              , m_isDeadCode(false)
          {
          }
  
          explicit YarrOp(YarrOpCode op)
              : m_op(op)
              , m_isDeadCode(false)
          {
          }
  
          // For alternatives, this holds the PatternAlternative and doubly linked
          // references to this alternative&#39;s siblings. In the case of the
          // OpBodyAlternativeEnd node at the end of a section of repeating nodes,
          // m_nextOp will reference the OpBodyAlternativeBegin node of the first
          // repeating alternative.
          PatternAlternative* m_alternative;
          size_t m_previousOp;
          size_t m_nextOp;
  
<span class="line-added">+         // The operation, as a YarrOpCode, and also a reference to the PatternTerm.</span>
<span class="line-added">+         PatternTerm* m_term;</span>
<span class="line-added">+         YarrOpCode m_op;</span>
<span class="line-added">+ </span>
          // Used to record a set of Jumps out of the generated code, typically
          // used for jumps out to backtracking code, and a single reentry back
          // into the code for a node (likely where a backtrack will trigger
          // rematching).
          Label m_reentry;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1350,11 ***</span>
          YarrOp* nextOp = &amp;m_ops[opIndex + 1];
  
          PatternTerm* term = op.m_term;
          UChar32 ch = term-&gt;patternCharacter;
  
<span class="line-modified">!         if ((ch &gt; 0xff) &amp;&amp; (m_charSize == Char8)) {</span>
              // Have a 16 bit pattern character and an 8 bit string - short circuit
              op.m_jumps.append(jump());
              return;
          }
  
<span class="line-new-header">--- 1371,11 ---</span>
          YarrOp* nextOp = &amp;m_ops[opIndex + 1];
  
          PatternTerm* term = op.m_term;
          UChar32 ch = term-&gt;patternCharacter;
  
<span class="line-modified">!         if (!isLatin1(ch) &amp;&amp; (m_charSize == Char8)) {</span>
              // Have a 16 bit pattern character and an 8 bit string - short circuit
              op.m_jumps.append(jump());
              return;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1405,11 ***</span>
              int shiftAmount = (m_charSize == Char8 ? 8 : 16) * numberCharacters;
  #endif
  
              UChar32 currentCharacter = nextTerm-&gt;patternCharacter;
  
<span class="line-modified">!             if ((currentCharacter &gt; 0xff) &amp;&amp; (m_charSize == Char8)) {</span>
                  // Have a 16 bit pattern character and an 8 bit string - short circuit
                  op.m_jumps.append(jump());
                  return;
              }
  
<span class="line-new-header">--- 1426,11 ---</span>
              int shiftAmount = (m_charSize == Char8 ? 8 : 16) * numberCharacters;
  #endif
  
              UChar32 currentCharacter = nextTerm-&gt;patternCharacter;
  
<span class="line-modified">!             if (!isLatin1(currentCharacter) &amp;&amp; (m_charSize == Char8)) {</span>
                  // Have a 16 bit pattern character and an 8 bit string - short circuit
                  op.m_jumps.append(jump());
                  return;
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1600,11 ***</span>
          const RegisterID countRegister = regT1;
  
          move(TrustedImm32(0), countRegister);
  
          // Unless have a 16 bit pattern character and an 8 bit string - short circuit
<span class="line-modified">!         if (!((ch &gt; 0xff) &amp;&amp; (m_charSize == Char8))) {</span>
              JumpList failures;
              Label loop(this);
              failures.append(atEndOfInput());
              failures.append(jumpIfCharNotEquals(ch, m_checkedOffset - term-&gt;inputPosition, character));
  
<span class="line-new-header">--- 1621,11 ---</span>
          const RegisterID countRegister = regT1;
  
          move(TrustedImm32(0), countRegister);
  
          // Unless have a 16 bit pattern character and an 8 bit string - short circuit
<span class="line-modified">!         if (!(!isLatin1(ch) &amp;&amp; (m_charSize == Char8))) {</span>
              JumpList failures;
              Label loop(this);
              failures.append(atEndOfInput());
              failures.append(jumpIfCharNotEquals(ch, m_checkedOffset - term-&gt;inputPosition, character));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1673,11 ***</span>
          m_backtrackingState.link(this);
  
          loadFromFrame(term-&gt;frameLocation + BackTrackInfoPatternCharacter::matchAmountIndex(), countRegister);
  
          // Unless have a 16 bit pattern character and an 8 bit string - short circuit
<span class="line-modified">!         if (!((ch &gt; 0xff) &amp;&amp; (m_charSize == Char8))) {</span>
              JumpList nonGreedyFailures;
              nonGreedyFailures.append(atEndOfInput());
              if (term-&gt;quantityMaxCount != quantifyInfinite)
                  nonGreedyFailures.append(branch32(Equal, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())));
              nonGreedyFailures.append(jumpIfCharNotEquals(ch, m_checkedOffset - term-&gt;inputPosition, character));
<span class="line-new-header">--- 1694,11 ---</span>
          m_backtrackingState.link(this);
  
          loadFromFrame(term-&gt;frameLocation + BackTrackInfoPatternCharacter::matchAmountIndex(), countRegister);
  
          // Unless have a 16 bit pattern character and an 8 bit string - short circuit
<span class="line-modified">!         if (!(!isLatin1(ch) &amp;&amp; (m_charSize == Char8))) {</span>
              JumpList nonGreedyFailures;
              nonGreedyFailures.append(atEndOfInput());
              if (term-&gt;quantityMaxCount != quantifyInfinite)
                  nonGreedyFailures.append(branch32(Equal, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())));
              nonGreedyFailures.append(jumpIfCharNotEquals(ch, m_checkedOffset - term-&gt;inputPosition, character));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1732,12 ***</span>
                  op.m_jumps.append(jump());
                  matchDest.link(this);
              }
          }
  #ifdef JIT_UNICODE_EXPRESSIONS
<span class="line-modified">!         if (m_decodeSurrogatePairs) {</span>
              Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);
              add32(TrustedImm32(1), index);
              isBMPChar.link(this);
          }
  #endif
      }
<span class="line-new-header">--- 1753,13 ---</span>
                  op.m_jumps.append(jump());
                  matchDest.link(this);
              }
          }
  #ifdef JIT_UNICODE_EXPRESSIONS
<span class="line-modified">!         if (m_decodeSurrogatePairs &amp;&amp; (!term-&gt;characterClass-&gt;hasOneCharacterSize() || term-&gt;invert())) {</span>
              Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);
<span class="line-added">+             op.m_jumps.append(atEndOfInput());</span>
              add32(TrustedImm32(1), index);
              isBMPChar.link(this);
          }
  #endif
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1766,15 ***</span>
  
          if (m_decodeSurrogatePairs)
              op.m_jumps.append(jumpIfNoAvailableInput());
  
          move(index, countRegister);
<span class="line-modified">!         sub32(Imm32(term-&gt;quantityMaxCount.unsafeGet()), countRegister);</span>
  
          Label loop(this);
          JumpList matchDest;
<span class="line-modified">!         readCharacter(m_checkedOffset - term-&gt;inputPosition - term-&gt;quantityMaxCount, character, countRegister);</span>
          // If we are matching the &quot;any character&quot; builtin class we only need to read the
          // character and don&#39;t need to match as it will always succeed.
          if (term-&gt;invert() || !term-&gt;characterClass-&gt;m_anyCharacter) {
              matchCharacterClass(character, matchDest, term-&gt;characterClass);
  
<span class="line-new-header">--- 1788,22 ---</span>
  
          if (m_decodeSurrogatePairs)
              op.m_jumps.append(jumpIfNoAvailableInput());
  
          move(index, countRegister);
<span class="line-modified">! </span>
<span class="line-added">+         Checked&lt;unsigned&gt; scaledMaxCount = term-&gt;quantityMaxCount;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef JIT_UNICODE_EXPRESSIONS</span>
<span class="line-added">+         if (m_decodeSurrogatePairs &amp;&amp; term-&gt;characterClass-&gt;hasOnlyNonBMPCharacters() &amp;&amp; !term-&gt;invert())</span>
<span class="line-added">+             scaledMaxCount *= 2;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         sub32(Imm32(scaledMaxCount.unsafeGet()), countRegister);</span>
  
          Label loop(this);
          JumpList matchDest;
<span class="line-modified">!         readCharacter(m_checkedOffset - term-&gt;inputPosition - scaledMaxCount, character, countRegister);</span>
          // If we are matching the &quot;any character&quot; builtin class we only need to read the
          // character and don&#39;t need to match as it will always succeed.
          if (term-&gt;invert() || !term-&gt;characterClass-&gt;m_anyCharacter) {
              matchCharacterClass(character, matchDest, term-&gt;characterClass);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1784,20 ***</span>
                  op.m_jumps.append(jump());
                  matchDest.link(this);
              }
          }
  
<span class="line-removed">-         add32(TrustedImm32(1), countRegister);</span>
  #ifdef JIT_UNICODE_EXPRESSIONS
          if (m_decodeSurrogatePairs) {
<span class="line-modified">!             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="line-modified">!             op.m_jumps.append(atEndOfInput());</span>
<span class="line-modified">!             add32(TrustedImm32(1), countRegister);</span>
<span class="line-modified">!             add32(TrustedImm32(1), index);</span>
<span class="line-modified">!             isBMPChar.link(this);</span>
<span class="line-modified">!         }</span>
  #endif
          branch32(NotEqual, countRegister, index).linkTo(loop, this);
      }
      void backtrackCharacterClassFixed(size_t opIndex)
      {
          backtrackTermDefault(opIndex);
<span class="line-new-header">--- 1813,25 ---</span>
                  op.m_jumps.append(jump());
                  matchDest.link(this);
              }
          }
  
  #ifdef JIT_UNICODE_EXPRESSIONS
          if (m_decodeSurrogatePairs) {
<span class="line-modified">!             if (term-&gt;isFixedWidthCharacterClass())</span>
<span class="line-modified">!                 add32(TrustedImm32(term-&gt;characterClass-&gt;hasNonBMPCharacters() ? 2 : 1), countRegister);</span>
<span class="line-modified">!             else {</span>
<span class="line-modified">!                 add32(TrustedImm32(1), countRegister);</span>
<span class="line-modified">!                 Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="line-modified">!                 op.m_jumps.append(atEndOfInput());</span>
<span class="line-added">+                 add32(TrustedImm32(1), countRegister);</span>
<span class="line-added">+                 add32(TrustedImm32(1), index);</span>
<span class="line-added">+                 isBMPChar.link(this);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else</span>
  #endif
<span class="line-added">+             add32(TrustedImm32(1), countRegister);</span>
          branch32(NotEqual, countRegister, index).linkTo(loop, this);
      }
      void backtrackCharacterClassFixed(size_t opIndex)
      {
          backtrackTermDefault(opIndex);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1809,50 ***</span>
          PatternTerm* term = op.m_term;
  
          const RegisterID character = regT0;
          const RegisterID countRegister = regT1;
  
<span class="line-modified">!         if (m_decodeSurrogatePairs)</span>
              storeToFrame(index, term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex());
          move(TrustedImm32(0), countRegister);
  
          JumpList failures;
          Label loop(this);
<span class="line-modified">!         failures.append(atEndOfInput());</span>
  
          if (term-&gt;invert()) {
              readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
              matchCharacterClass(character, failures, term-&gt;characterClass);
          } else {
              JumpList matchDest;
              readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
<span class="line-modified">!             // If we are matching the &quot;any character&quot; builtin class we only need to read the</span>
<span class="line-modified">!             // character and don&#39;t need to match as it will always succeed.</span>
              if (!term-&gt;characterClass-&gt;m_anyCharacter) {
                  matchCharacterClass(character, matchDest, term-&gt;characterClass);
                  failures.append(jump());
              }
              matchDest.link(this);
          }
  
<span class="line-removed">-         add32(TrustedImm32(1), index);</span>
  #ifdef JIT_UNICODE_EXPRESSIONS
<span class="line-modified">!         if (m_decodeSurrogatePairs) {</span>
<span class="line-modified">!             failures.append(atEndOfInput());</span>
<span class="line-modified">!             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="line-removed">-             add32(TrustedImm32(1), index);</span>
<span class="line-removed">-             isBMPChar.link(this);</span>
<span class="line-removed">-         }</span>
  #endif
          add32(TrustedImm32(1), countRegister);
  
          if (term-&gt;quantityMaxCount != quantifyInfinite) {
              branch32(NotEqual, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())).linkTo(loop, this);
              failures.append(jump());
          } else
              jump(loop);
  
          failures.link(this);
          op.m_reentry = label();
  
          storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());
      }
<span class="line-new-header">--- 1843,59 ---</span>
          PatternTerm* term = op.m_term;
  
          const RegisterID character = regT0;
          const RegisterID countRegister = regT1;
  
<span class="line-modified">!         if (m_decodeSurrogatePairs &amp;&amp; (!term-&gt;characterClass-&gt;hasOneCharacterSize() || term-&gt;invert()))</span>
              storeToFrame(index, term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex());
          move(TrustedImm32(0), countRegister);
  
          JumpList failures;
<span class="line-added">+         JumpList failuresDecrementIndex;</span>
          Label loop(this);
<span class="line-modified">! #ifdef JIT_UNICODE_EXPRESSIONS</span>
<span class="line-added">+         if (term-&gt;isFixedWidthCharacterClass() &amp;&amp; term-&gt;characterClass-&gt;hasNonBMPCharacters()) {</span>
<span class="line-added">+             move(TrustedImm32(1), character);</span>
<span class="line-added">+             failures.append(checkNotEnoughInput(character));</span>
<span class="line-added">+         } else</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+             failures.append(atEndOfInput());</span>
  
          if (term-&gt;invert()) {
              readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
              matchCharacterClass(character, failures, term-&gt;characterClass);
          } else {
              JumpList matchDest;
              readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
<span class="line-modified">!             // If we are matching the &quot;any character&quot; builtin class for non-unicode patterns,</span>
<span class="line-modified">!             // we only need to read the character and don&#39;t need to match as it will always succeed.</span>
              if (!term-&gt;characterClass-&gt;m_anyCharacter) {
                  matchCharacterClass(character, matchDest, term-&gt;characterClass);
                  failures.append(jump());
              }
              matchDest.link(this);
          }
  
  #ifdef JIT_UNICODE_EXPRESSIONS
<span class="line-modified">!         if (m_decodeSurrogatePairs)</span>
<span class="line-modified">!             advanceIndexAfterCharacterClassTermMatch(term, failuresDecrementIndex, character);</span>
<span class="line-modified">!         else</span>
  #endif
<span class="line-added">+             add32(TrustedImm32(1), index);</span>
          add32(TrustedImm32(1), countRegister);
  
          if (term-&gt;quantityMaxCount != quantifyInfinite) {
              branch32(NotEqual, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())).linkTo(loop, this);
              failures.append(jump());
          } else
              jump(loop);
  
<span class="line-added">+         if (!failuresDecrementIndex.empty()) {</span>
<span class="line-added">+             failuresDecrementIndex.link(this);</span>
<span class="line-added">+             sub32(TrustedImm32(1), index);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          failures.link(this);
          op.m_reentry = label();
  
          storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1866,20 ***</span>
          m_backtrackingState.link(this);
  
          loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
          m_backtrackingState.append(branchTest32(Zero, countRegister));
          sub32(TrustedImm32(1), countRegister);
          if (!m_decodeSurrogatePairs)
              sub32(TrustedImm32(1), index);
          else {
              const RegisterID character = regT0;
  
              loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex(), index);
<span class="line-removed">-             // Rematch one less</span>
<span class="line-removed">-             storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());</span>
  
              Label rematchLoop(this);
              readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
  
              sub32(TrustedImm32(1), countRegister);
              add32(TrustedImm32(1), index);
  
<span class="line-new-header">--- 1909,25 ---</span>
          m_backtrackingState.link(this);
  
          loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
          m_backtrackingState.append(branchTest32(Zero, countRegister));
          sub32(TrustedImm32(1), countRegister);
<span class="line-added">+         storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());</span>
<span class="line-added">+ </span>
          if (!m_decodeSurrogatePairs)
              sub32(TrustedImm32(1), index);
<span class="line-added">+         else if (term-&gt;isFixedWidthCharacterClass())</span>
<span class="line-added">+             sub32(TrustedImm32(term-&gt;characterClass-&gt;hasNonBMPCharacters() ? 2 : 1), index);</span>
          else {
<span class="line-added">+             // Rematch one less</span>
              const RegisterID character = regT0;
  
              loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex(), index);
  
              Label rematchLoop(this);
<span class="line-added">+             Jump doneRematching = branchTest32(Zero, countRegister);</span>
<span class="line-added">+ </span>
              readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
  
              sub32(TrustedImm32(1), countRegister);
              add32(TrustedImm32(1), index);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1887,11 ***</span>
              Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);
              add32(TrustedImm32(1), index);
              isBMPChar.link(this);
  #endif
  
<span class="line-modified">!             branchTest32(Zero, countRegister).linkTo(rematchLoop, this);</span>
  
              loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
          }
          jump(op.m_reentry);
      }
<span class="line-new-header">--- 1935,12 ---</span>
              Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);
              add32(TrustedImm32(1), index);
              isBMPChar.link(this);
  #endif
  
<span class="line-modified">!             jump(rematchLoop);</span>
<span class="line-added">+             doneRematching.link(this);</span>
  
              loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
          }
          jump(op.m_reentry);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1903,12 ***</span>
  
          const RegisterID countRegister = regT1;
  
          move(TrustedImm32(0), countRegister);
          op.m_reentry = label();
<span class="line-modified">!         if (m_decodeSurrogatePairs)</span>
<span class="line-modified">!             storeToFrame(index, term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex());</span>
          storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());
      }
  
      void backtrackCharacterClassNonGreedy(size_t opIndex)
      {
<span class="line-new-header">--- 1952,18 ---</span>
  
          const RegisterID countRegister = regT1;
  
          move(TrustedImm32(0), countRegister);
          op.m_reentry = label();
<span class="line-modified">! </span>
<span class="line-modified">! #ifdef JIT_UNICODE_EXPRESSIONS</span>
<span class="line-added">+         if (m_decodeSurrogatePairs) {</span>
<span class="line-added">+             if (!term-&gt;characterClass-&gt;hasOneCharacterSize() || term-&gt;invert())</span>
<span class="line-added">+                 storeToFrame(index, term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex());</span>
<span class="line-added">+         }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
          storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());
      }
  
      void backtrackCharacterClassNonGreedy(size_t opIndex)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1917,24 ***</span>
  
          const RegisterID character = regT0;
          const RegisterID countRegister = regT1;
  
          JumpList nonGreedyFailures;
  
          m_backtrackingState.link(this);
  
<span class="line-modified">!         if (m_decodeSurrogatePairs)</span>
<span class="line-modified">!             loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex(), index);</span>
          loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
  
          nonGreedyFailures.append(atEndOfInput());
          nonGreedyFailures.append(branch32(Equal, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())));
  
          JumpList matchDest;
          readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
<span class="line-modified">!         // If we are matching the &quot;any character&quot; builtin class we only need to read the</span>
<span class="line-modified">!         // character and don&#39;t need to match as it will always succeed.</span>
          if (term-&gt;invert() || !term-&gt;characterClass-&gt;m_anyCharacter) {
              matchCharacterClass(character, matchDest, term-&gt;characterClass);
  
              if (term-&gt;invert())
                  nonGreedyFailures.append(matchDest);
<span class="line-new-header">--- 1972,30 ---</span>
  
          const RegisterID character = regT0;
          const RegisterID countRegister = regT1;
  
          JumpList nonGreedyFailures;
<span class="line-added">+         JumpList nonGreedyFailuresDecrementIndex;</span>
  
          m_backtrackingState.link(this);
  
<span class="line-modified">! #ifdef JIT_UNICODE_EXPRESSIONS</span>
<span class="line-modified">!         if (m_decodeSurrogatePairs) {</span>
<span class="line-added">+             if (!term-&gt;characterClass-&gt;hasOneCharacterSize() || term-&gt;invert())</span>
<span class="line-added">+                 loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex(), index);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
          loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
  
          nonGreedyFailures.append(atEndOfInput());
          nonGreedyFailures.append(branch32(Equal, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())));
  
          JumpList matchDest;
          readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
<span class="line-modified">!         // If we are matching the &quot;any character&quot; builtin class for non-unicode patterns,</span>
<span class="line-modified">!         // we only need to read the character and don&#39;t need to match as it will always succeed.</span>
          if (term-&gt;invert() || !term-&gt;characterClass-&gt;m_anyCharacter) {
              matchCharacterClass(character, matchDest, term-&gt;characterClass);
  
              if (term-&gt;invert())
                  nonGreedyFailures.append(matchDest);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1942,23 ***</span>
                  nonGreedyFailures.append(jump());
                  matchDest.link(this);
              }
          }
  
<span class="line-removed">-         add32(TrustedImm32(1), index);</span>
  #ifdef JIT_UNICODE_EXPRESSIONS
<span class="line-modified">!         if (m_decodeSurrogatePairs) {</span>
<span class="line-modified">!             nonGreedyFailures.append(atEndOfInput());</span>
<span class="line-modified">!             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="line-removed">-             add32(TrustedImm32(1), index);</span>
<span class="line-removed">-             isBMPChar.link(this);</span>
<span class="line-removed">-         }</span>
  #endif
          add32(TrustedImm32(1), countRegister);
  
          jump(op.m_reentry);
  
          nonGreedyFailures.link(this);
          sub32(countRegister, index);
          m_backtrackingState.fallthrough();
      }
  
<span class="line-new-header">--- 2003,24 ---</span>
                  nonGreedyFailures.append(jump());
                  matchDest.link(this);
              }
          }
  
  #ifdef JIT_UNICODE_EXPRESSIONS
<span class="line-modified">!         if (m_decodeSurrogatePairs)</span>
<span class="line-modified">!             advanceIndexAfterCharacterClassTermMatch(term, nonGreedyFailuresDecrementIndex, character);</span>
<span class="line-modified">!         else</span>
  #endif
<span class="line-added">+             add32(TrustedImm32(1), index);</span>
          add32(TrustedImm32(1), countRegister);
  
          jump(op.m_reentry);
  
<span class="line-added">+         if (!nonGreedyFailuresDecrementIndex.empty()) {</span>
<span class="line-added">+             nonGreedyFailuresDecrementIndex.link(this);</span>
<span class="line-added">+             breakpoint();</span>
<span class="line-added">+         }</span>
          nonGreedyFailures.link(this);
          sub32(countRegister, index);
          m_backtrackingState.fallthrough();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2459,18 ***</span>
              case OpParenthesesSubpatternOnceEnd: {
                  PatternTerm* term = op.m_term;
                  const RegisterID indexTemporary = regT0;
                  ASSERT(term-&gt;quantityMaxCount == 1);
  
<span class="line-modified">!                 // Runtime ASSERT to make sure that the nested alternative handled the</span>
<span class="line-modified">!                 // &quot;no input consumed&quot; check.</span>
<span class="line-modified">!                 if (!ASSERT_DISABLED &amp;&amp; term-&gt;quantityType != QuantifierFixedCount &amp;&amp; !term-&gt;parentheses.disjunction-&gt;m_minimumSize) {</span>
<span class="line-modified">!                     Jump pastBreakpoint;</span>
<span class="line-modified">!                     pastBreakpoint = branch32(NotEqual, index, Address(stackPointerRegister, term-&gt;frameLocation * sizeof(void*)));</span>
<span class="line-removed">-                     abortWithReason(YARRNoInputConsumed);</span>
<span class="line-removed">-                     pastBreakpoint.link(this);</span>
<span class="line-removed">-                 }</span>
  
                  // If the parenthese are capturing, store the ending index value to the
                  // captures array, offsetting as necessary.
                  //
                  // FIXME: could avoid offsetting this value in JIT code, apply
<span class="line-new-header">--- 2521,15 ---</span>
              case OpParenthesesSubpatternOnceEnd: {
                  PatternTerm* term = op.m_term;
                  const RegisterID indexTemporary = regT0;
                  ASSERT(term-&gt;quantityMaxCount == 1);
  
<span class="line-modified">!                 // If the nested alternative matched without consuming any characters, punt this back to the interpreter.</span>
<span class="line-modified">!                 // FIXME: &lt;https://bugs.webkit.org/show_bug.cgi?id=200786&gt; Add ability for the YARR JIT to properly</span>
<span class="line-modified">!                 // handle nested expressions that can match without consuming characters</span>
<span class="line-modified">!                 if (term-&gt;quantityType != QuantifierFixedCount &amp;&amp; !term-&gt;parentheses.disjunction-&gt;m_minimumSize)</span>
<span class="line-modified">!                     m_abortExecution.append(branch32(Equal, index, Address(stackPointerRegister, term-&gt;frameLocation * sizeof(void*))));</span>
  
                  // If the parenthese are capturing, store the ending index value to the
                  // captures array, offsetting as necessary.
                  //
                  // FIXME: could avoid offsetting this value in JIT code, apply
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2513,20 ***</span>
                  storeToFrame(index, term-&gt;frameLocation + BackTrackInfoParenthesesTerminal::beginIndex());
                  break;
              }
              case OpParenthesesSubpatternTerminalEnd: {
                  YarrOp&amp; beginOp = m_ops[op.m_previousOp];
<span class="line-modified">!                 if (!ASSERT_DISABLED) {</span>
<span class="line-modified">!                     PatternTerm* term = op.m_term;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     // Runtime ASSERT to make sure that the nested alternative handled the</span>
<span class="line-modified">!                     // &quot;no input consumed&quot; check.</span>
<span class="line-modified">!                     Jump pastBreakpoint;</span>
<span class="line-modified">!                     pastBreakpoint = branch32(NotEqual, index, Address(stackPointerRegister, term-&gt;frameLocation * sizeof(void*)));</span>
<span class="line-removed">-                     abortWithReason(YARRNoInputConsumed);</span>
<span class="line-removed">-                     pastBreakpoint.link(this);</span>
<span class="line-removed">-                 }</span>
  
                  // We know that the match is non-zero, we can accept it and
                  // loop back up to the head of the subpattern.
                  jump(beginOp.m_reentry);
  
<span class="line-new-header">--- 2572,17 ---</span>
                  storeToFrame(index, term-&gt;frameLocation + BackTrackInfoParenthesesTerminal::beginIndex());
                  break;
              }
              case OpParenthesesSubpatternTerminalEnd: {
                  YarrOp&amp; beginOp = m_ops[op.m_previousOp];
<span class="line-modified">!                 PatternTerm* term = op.m_term;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // If the nested alternative matched without consuming any characters, punt this back to the interpreter.</span>
<span class="line-modified">!                 // FIXME: &lt;https://bugs.webkit.org/show_bug.cgi?id=200786&gt; Add ability for the YARR JIT to properly</span>
<span class="line-modified">!                 // handle nested expressions that can match without consuming characters</span>
<span class="line-modified">!                 if (term-&gt;quantityType != QuantifierFixedCount &amp;&amp; !term-&gt;parentheses.disjunction-&gt;m_minimumSize)</span>
<span class="line-modified">!                     m_abortExecution.append(branch32(Equal, index, Address(stackPointerRegister, term-&gt;frameLocation * sizeof(void*))));</span>
  
                  // We know that the match is non-zero, we can accept it and
                  // loop back up to the head of the subpattern.
                  jump(beginOp.m_reentry);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2605,18 ***</span>
              case OpParenthesesSubpatternEnd: {
  #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
                  PatternTerm* term = op.m_term;
                  unsigned parenthesesFrameLocation = term-&gt;frameLocation;
  
<span class="line-modified">!                 // Runtime ASSERT to make sure that the nested alternative handled the</span>
<span class="line-modified">!                 // &quot;no input consumed&quot; check.</span>
<span class="line-modified">!                 if (!ASSERT_DISABLED &amp;&amp; term-&gt;quantityType != QuantifierFixedCount &amp;&amp; !term-&gt;parentheses.disjunction-&gt;m_minimumSize) {</span>
<span class="line-modified">!                     Jump pastBreakpoint;</span>
<span class="line-modified">!                     pastBreakpoint = branch32(NotEqual, index, Address(stackPointerRegister, parenthesesFrameLocation * sizeof(void*)));</span>
<span class="line-removed">-                     abortWithReason(YARRNoInputConsumed);</span>
<span class="line-removed">-                     pastBreakpoint.link(this);</span>
<span class="line-removed">-                 }</span>
  
                  const RegisterID countTemporary = regT1;
  
                  YarrOp&amp; beginOp = m_ops[op.m_previousOp];
                  loadFromFrame(parenthesesFrameLocation + BackTrackInfoParentheses::matchAmountIndex(), countTemporary);
<span class="line-new-header">--- 2661,15 ---</span>
              case OpParenthesesSubpatternEnd: {
  #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
                  PatternTerm* term = op.m_term;
                  unsigned parenthesesFrameLocation = term-&gt;frameLocation;
  
<span class="line-modified">!                 // If the nested alternative matched without consuming any characters, punt this back to the interpreter.</span>
<span class="line-modified">!                 // FIXME: &lt;https://bugs.webkit.org/show_bug.cgi?id=200786&gt; Add ability for the YARR JIT to properly</span>
<span class="line-modified">!                 // handle nested expressions that can match without consuming characters</span>
<span class="line-modified">!                 if (term-&gt;quantityType != QuantifierFixedCount &amp;&amp; !term-&gt;parentheses.disjunction-&gt;m_minimumSize)</span>
<span class="line-modified">!                     m_abortExecution.append(branch32(Equal, index, Address(stackPointerRegister, parenthesesFrameLocation * sizeof(void*))));</span>
  
                  const RegisterID countTemporary = regT1;
  
                  YarrOp&amp; beginOp = m_ops[op.m_previousOp];
                  loadFromFrame(parenthesesFrameLocation + BackTrackInfoParentheses::matchAmountIndex(), countTemporary);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3384,10 ***</span>
<span class="line-new-header">--- 3437,15 ---</span>
          YarrOpCode parenthesesEndOpCode;
          YarrOpCode alternativeBeginOpCode = OpSimpleNestedAlternativeBegin;
          YarrOpCode alternativeNextOpCode = OpSimpleNestedAlternativeNext;
          YarrOpCode alternativeEndOpCode = OpSimpleNestedAlternativeEnd;
  
<span class="line-added">+         if (UNLIKELY(!m_vm-&gt;isSafeToRecurse())) {</span>
<span class="line-added">+             m_failureReason = JITFailureReason::ParenthesisNestedTooDeep;</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          // We can currently only compile quantity 1 subpatterns that are
          // not copies. We generate a copy in the case of a range quantifier,
          // e.g. /(?:x){3,9}/, or /(?:x)+/ (These are effectively expanded to
          // /(?:x){3,3}(?:x){0,6}/ and /(?:x)(?:x)*/ repectively). The problem
          // comes where the subpattern is capturing, in which case we would
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3490,10 ***</span>
<span class="line-new-header">--- 3548,15 ---</span>
      // We can always use the OpSimpleNestedAlternative nodes in the
      // case of parenthetical assertions since these only ever match
      // once, and will never backtrack back into the assertion.
      void opCompileParentheticalAssertion(PatternTerm* term)
      {
<span class="line-added">+         if (UNLIKELY(!m_vm-&gt;isSafeToRecurse())) {</span>
<span class="line-added">+             m_failureReason = JITFailureReason::ParenthesisNestedTooDeep;</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          size_t parenBegin = m_ops.size();
          m_ops.append(OpParentheticalAssertionBegin);
  
          m_ops.append(OpSimpleNestedAlternativeBegin);
          m_ops.last().m_previousOp = notFound;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3570,10 ***</span>
<span class="line-new-header">--- 3633,15 ---</span>
      // alternatives, the end node is also linked back to the beginning.
      // If no repeating alternatives exist, then a OpMatchFailed node exists
      // to return the failing result.
      void opCompileBody(PatternDisjunction* disjunction)
      {
<span class="line-added">+         if (UNLIKELY(!m_vm-&gt;isSafeToRecurse())) {</span>
<span class="line-added">+             m_failureReason = JITFailureReason::ParenthesisNestedTooDeep;</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          Vector&lt;std::unique_ptr&lt;PatternAlternative&gt;&gt;&amp; alternatives = disjunction-&gt;m_alternatives;
          size_t currentAlternativeIndex = 0;
  
          // Emit the &#39;once through&#39; alternatives.
          if (alternatives.size() &amp;&amp; alternatives[0]-&gt;onceThrough()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3683,11 ***</span>
              push(X86Registers::r13);
              push(X86Registers::r14);
              push(X86Registers::r15);
  
              move(TrustedImm32(0xd800), leadingSurrogateTag);
<span class="line-removed">-             move(TrustedImm32(0xdc00), trailingSurrogateTag);</span>
          }
          // The ABI doesn&#39;t guarantee the upper bits are zero on unsigned arguments, so clear them ourselves.
          zeroExtend32ToPtr(index, index);
          zeroExtend32ToPtr(length, length);
  #if OS(WINDOWS)
<span class="line-new-header">--- 3751,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3717,11 ***</span>
  #elif CPU(ARM64)
          tagReturnAddress();
          if (m_decodeSurrogatePairs) {
              pushPair(framePointerRegister, linkRegister);
              move(TrustedImm32(0x10000), supplementaryPlanesBase);
<span class="line-removed">-             move(TrustedImm32(0xfffffc00), surrogateTagMask);</span>
              move(TrustedImm32(0xd800), leadingSurrogateTag);
              move(TrustedImm32(0xdc00), trailingSurrogateTag);
          }
  
          // The ABI doesn&#39;t guarantee the upper bits are zero on unsigned arguments, so clear them ourselves.
<span class="line-new-header">--- 3784,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3798,10 ***</span>
<span class="line-new-header">--- 3864,11 ---</span>
          , m_patternString(patternString)
          , m_codeBlock(codeBlock)
          , m_charSize(charSize)
          , m_decodeSurrogatePairs(m_charSize == Char16 &amp;&amp; m_pattern.unicode())
          , m_unicodeIgnoreCase(m_pattern.unicode() &amp;&amp; m_pattern.ignoreCase())
<span class="line-added">+         , m_fixedSizedAlternative(false)</span>
          , m_canonicalMode(m_pattern.unicode() ? CanonicalMode::Unicode : CanonicalMode::UCS2)
  #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
          , m_containsNestedSubpatterns(false)
          , m_parenContextSizes(compileMode == IncludeSubpatterns ? m_pattern.m_numSubpatterns : 0, m_pattern.m_body-&gt;m_callFrameSize)
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3836,11 ***</span>
              codeBlock.setFallBackWithFailureReason(*m_failureReason);
              return;
          }
  
          if (UNLIKELY(Options::dumpDisassembly() || Options::dumpRegExpDisassembly()))
<span class="line-modified">!             m_disassembler = std::make_unique&lt;YarrDisassembler&gt;(this);</span>
  
          if (m_disassembler)
              m_disassembler-&gt;setStartOfCode(label());
  
  #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
<span class="line-new-header">--- 3903,11 ---</span>
              codeBlock.setFallBackWithFailureReason(*m_failureReason);
              return;
          }
  
          if (UNLIKELY(Options::dumpDisassembly() || Options::dumpRegExpDisassembly()))
<span class="line-modified">!             m_disassembler = makeUnique&lt;YarrDisassembler&gt;(this);</span>
  
          if (m_disassembler)
              m_disassembler-&gt;setStartOfCode(label());
  
  #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3852,10 ***</span>
<span class="line-new-header">--- 3919,15 ---</span>
  
          Jump hasInput = checkInput();
          generateFailReturn();
          hasInput.link(this);
  
<span class="line-added">+ #ifdef JIT_UNICODE_EXPRESSIONS</span>
<span class="line-added">+         if (m_decodeSurrogatePairs)</span>
<span class="line-added">+             getEffectiveAddress(BaseIndex(input, length, TimesTwo), endOfStringAddress);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
          if (m_containsNestedSubpatterns)
              move(TrustedImm32(matchLimit), remainingMatchCount);
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3868,12 ***</span>
              setMatchStart(index);
  
          initCallFrame();
  
  #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
<span class="line-modified">!         if (m_containsNestedSubpatterns)</span>
              initParenContextFreeList();
  #endif
  
          if (m_pattern.m_saveInitialStartValue) {
  #ifdef HAVE_INITIAL_START_REG
              move(index, initialStart);
<span class="line-new-header">--- 3940,17 ---</span>
              setMatchStart(index);
  
          initCallFrame();
  
  #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
<span class="line-modified">!         if (m_containsNestedSubpatterns) {</span>
              initParenContextFreeList();
<span class="line-added">+             if (m_failureReason) {</span>
<span class="line-added">+                 codeBlock.setFallBackWithFailureReason(*m_failureReason);</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
  #endif
  
          if (m_pattern.m_saveInitialStartValue) {
  #ifdef HAVE_INITIAL_START_REG
              move(index, initialStart);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4146,10 ***</span>
<span class="line-new-header">--- 4223,11 ---</span>
      // supported in the JIT; fall back to the interpreter when this is detected.
      Optional&lt;JITFailureReason&gt; m_failureReason;
  
      bool m_decodeSurrogatePairs;
      bool m_unicodeIgnoreCase;
<span class="line-added">+     bool m_fixedSizedAlternative;</span>
      CanonicalMode m_canonicalMode;
  #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
      bool m_containsNestedSubpatterns;
      ParenContextSizes m_parenContextSizes;
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4198,10 ***</span>
<span class="line-new-header">--- 4276,13 ---</span>
          dataLog(&quot;Can&#39;t JIT a pattern containing parenthesized subpatterns\n&quot;);
          break;
      case JITFailureReason::FixedCountParenthesizedSubpattern:
          dataLog(&quot;Can&#39;t JIT a pattern containing fixed count parenthesized subpatterns\n&quot;);
          break;
<span class="line-added">+     case JITFailureReason::ParenthesisNestedTooDeep:</span>
<span class="line-added">+         dataLog(&quot;Can&#39;t JIT pattern due to parentheses nested too deeply\n&quot;);</span>
<span class="line-added">+         break;</span>
      case JITFailureReason::ExecutableMemoryAllocationFailure:
          dataLog(&quot;Can&#39;t JIT because of failure of allocation of executable memory\n&quot;);
          break;
      }
  }
</pre>
<center><a href="YarrInterpreter.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="YarrJIT.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>